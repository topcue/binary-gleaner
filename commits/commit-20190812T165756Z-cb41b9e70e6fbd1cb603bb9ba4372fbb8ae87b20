{
  "sha": "cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2I0MWI5ZTcwZTZmYmQxY2I2MDNiYjliYTQzNzJmYmI4YWU4N2IyMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-08-12T16:24:03Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-08-12T16:57:56Z"
    },
    "message": "Import readline 8.0\n\nThis imports readline 8.0.\n\nreadline/ChangeLog.gdb\n2019-08-12  Tom Tromey  <tom@tromey.com>\n\n\t* Imported readline 8.0.",
    "tree": {
      "sha": "6b03a978514e9f7df56c1243a3796776ecc65198",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6b03a978514e9f7df56c1243a3796776ecc65198"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ca2589f3bbad1e151abbb293d4c43a87b7a4d5ec",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca2589f3bbad1e151abbb293d4c43a87b7a4d5ec",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ca2589f3bbad1e151abbb293d4c43a87b7a4d5ec"
    }
  ],
  "stats": {
    "total": 6192,
    "additions": 4046,
    "deletions": 2146
  },
  "files": [
    {
      "sha": "18265ab10524a6f8aaba55f9208bc07bfd7893ec",
      "filename": "readline/CHANGELOG",
      "status": "modified",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/CHANGELOG",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/CHANGELOG",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/CHANGELOG?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1304,3 +1304,50 @@ configure.ac\n \t\t\t\t   ----\n configure.ac,Makefile.in,examples/Makefile.in\n \t- remove references to purify\n+\n+\t\t\t\t   11/21\n+\t\t\t\t   -----\n+configure.ac,config.h.in\n+\t- fnmatch: check for libc function, define HAVE_FNMATCH if found. Now\n+\t  used by vi-mode history search functions\n+\n+\t\t\t\t   7/12\n+\t\t\t\t   ----\n+Makefile.in,examples/Makefile.in\n+\t- add support for building with address sanitizer, using new target\n+\t  `asan'\n+\n+\t\t\t\t 4/23/2018\n+\t\t\t\t ---------\n+configure.ac\n+\t- TERMCAP_PKG_CONFIG_LIB: new variable, defined from TERMCAP_LIB,\n+\t  defaults to termcap\n+\n+readline.pc.in\n+\t- change Requires.private to use TERMCAP_PKG_CONFIG_LIB instead of\n+\t  hardcoded `tinfo'. Report and fix from Thomas Petazzoni\n+\t  <thomas.petazzoni@bootlin.com>\n+\n+\t\t\t\t    5/4\n+\t\t\t\t    ---\n+Makefile.in\n+\t- new targets to install and uninstall the `readline.pc' pkgconfig\n+\t  file\n+\t- install-{static,shared}: add install-pc to the list of prereqs\n+\t- uninstall{,-shared}: add uninstall-pc to list of prereqs. Change\n+\t  from Thomas Petazzoni <thomas.petazzoni@bootlin.com>\n+\n+configure.ac,Makefile.in\n+\t- add new configure option to optionally disable installing the\n+\t  source code examples. From Thomas Petazzoni <thomas.petazzoni@bootlin.com>\n+\n+\t\t\t\t   5/23\n+\t\t\t\t   ----\n+Makefile.in\n+\t- install-pc: make sure we install readline.pc into an existing\n+\t  pkgconfig directory. Report from ilove zfs <ilovezfs@icloud.com>\n+\n+\t\t\t\t   5/24\n+\t\t\t\t   ----\n+Makefile.in\n+\t- installdirs: create $(pkgconfigdir) if it doesn't exist"
    },
    {
      "sha": "09eab6ee03ef763f6db7546a47e58a11fa340e69",
      "filename": "readline/CHANGES",
      "status": "modified",
      "additions": 142,
      "deletions": 0,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/CHANGES",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/CHANGES",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/CHANGES?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,3 +1,145 @@\n+This document details the changes between this version, readline-8.0, and the\n+previous version, readline-7.0.\n+\n+1.  Changes to Readline\n+\n+a. Added a guard to prevent nested macros from causing an infinite expansion\n+   loop.\n+\n+b. Instead of allocating enough history list entries to hold the maximum list\n+   size, cap the number allocated initially.\n+   \n+c. Added a strategy to avoid allocating huge amounts of memory if a block of\n+   history entries without timestamps occurs after a block with timestamps.\n+\n+d. Added support for keyboard timeouts when an ESC character is the last\n+   character in a macro.\n+\n+e. There are several performance improvements when in a UTF-8 locale.\n+\n+f. Readline does a better job of preserving the original set of blocked\n+   signals when using pselect() to wait for input.\n+\n+g. Fixed a bug that caused multibyte characters in macros to be mishandled.\n+\n+h. Fixed several bugs in the code that calculates line breaks when expanding\n+   prompts that span several lines, contain multibyte characters, and contain\n+   invisible character seqeuences.\n+\n+i. Fixed several bugs in cursor positioning when displaying lines with prompts\n+   containing invisible characters and multibyte characters.\n+\n+j. When performing case-insensitive completion, Readline no longer sorts the\n+   list of matches unless directed to do so.\n+\n+k. Fixed a problem with key sequences ending with a backslash.\n+\n+l. Fixed out-of-bounds and free memory read errors found via fuzzing.\n+\n+m. Fixed several cases where the mark was set to an invalid value.\n+\n+n. Fixed a problem with the case-changing operators in the case where the\n+   lower and upper case versions of a character do not have the same number\n+   of bytes.\n+\n+o. Handle incremental and non-incremental search character reads returning EOF.\n+\n+p. Handle the case where a failing readline command at the end of a multi-key\n+   sequence could be misinterpreted.\n+\n+q. The history library now prints a meaningful error message if the history\n+   file isn't a regular file.\n+\n+r. Fixed a problem with vi-mode redo (`.') on a command when trying to replace\n+   a multibyte character.\n+\n+s. The key binding code now attempts to remove a keymap if a key unbinding\n+   leaves it empty.\n+\n+t. Fixed a line-wrapping issue that caused problems for some terminal\n+   emulators.\n+\n+u. If there is a key bound to the tty's VDISCARD special character, readline\n+   disables VDISCARD while it is active.\n+\n+v. Fixed a problem with exiting bracketed paste mode on terminals that assume\n+   the bracketed paste mode character sequence contains visible characters.\n+\n+w. Fixed a bug that could cause a key binding command to refer to an\n+   uninitialized variable.\n+\n+x. Added more UTF-8-specific versions of multibyte functions, and optimized\n+   existing functions if the current locale uses UTF-8 encoding.\n+\n+y. Fixed a problem with bracketed-paste inserting more than one character and\n+   interacting with other readline functions.\n+\n+z. Fixed a bug that caused the history library to attempt to append a history\n+   line to a non-existent history entry.\n+\n+aa. If using bracketed paste mode, output a newline after the \\r that is the\n+    last character of the mode disable string to avoid overwriting output.\n+\n+bb. Fixes to the vi-mode `b', `B', `w', `W', `e', and `E' commands to better\n+    handle multibyte characters.\n+\n+cc. Fixed a redisplay problem that caused an extra newline to be generated on\n+    accept-line when the line length is exactly the screenwidth.\n+\n+dd. Fixed a bug with adding multibyte characters to an incremental search\n+    string.\n+\n+ee. Fixed a bug with redoing text insertions in vi mode.\n+\n+ff. Fixed a bug with pasting text into an incremental search string if bracketed\n+    paste mode is enabled. ESC cannot be one of the incremental search\n+    terminator characters for this to work.\n+\n+gg. Fixed a bug with anchored search patterns when performing searches in vi\n+    mode.\n+\n+2.  New Features in Readline\n+\n+a. Non-incremental vi-mode search (`N', `n') can search for a shell pattern, as\n+   Posix specifies (uses fnmatch(3) if available).\n+\n+b. There are new `next-screen-line' and `previous-screen-line' bindable\n+   commands, which move the cursor to the same column in the next, or previous,\n+   physical line, respectively.\n+\n+c. There are default key bindings for control-arrow-key key combinations.\n+\n+d. A negative argument (-N) to `quoted-insert' means to insert the next N\n+   characters using quoted-insert.\n+\n+e. New public function: rl_check_signals(), which allows applications to\n+   respond to signals that readline catches while waiting for input using\n+   a custom read function.\n+\n+f. There is new support for conditionally testing the readline version in an\n+   inputrc file, with a full set of arithmetic comparison operators available.\n+\n+g. There is a simple variable comparison facility available for use within an\n+   inputrc file. Allowable operators are equality and inequality; string\n+   variables may be compared to a value; boolean variables must be compared to\n+   either `on' or `off'; variable names are separated from the operator by\n+   whitespace.\n+\n+h. The history expansion library now understands command and process\n+   substitution and extended globbing and allows them to appear anywhere in a\n+   word.\n+\n+i. The history library has a new variable that allows applications to set the\n+   initial quoting state, so quoting state can be inherited from a previous\n+   line.\n+\n+j. Readline now allows application-defined keymap names; there is a new public\n+   function, rl_set_keymap_name(), to do that.\n+\n+k. The \"Insert\" keypad key, if available, now puts readline into overwrite\n+   mode.\n+\n+-------------------------------------------------------------------------------\n This document details the changes between this version, readline-7.0, and the\n previous version, readline-6.3.\n "
    },
    {
      "sha": "982ef7b7107a41c508b0a20078ef880e29cbd223",
      "filename": "readline/ChangeLog.gdb",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/ChangeLog.gdb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/ChangeLog.gdb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/ChangeLog.gdb?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,3 +1,7 @@\n+2019-08-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* Imported readline 8.0.\n+\n 2019-08-12  Tom Tromey  <tom@tromey.com>\n \n \t* Makefile.in (xfree.o): Don't depend on readline.h."
    },
    {
      "sha": "afb4d53e8e587e7e61406bb8e322a860761dfd4c",
      "filename": "readline/INSTALL",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/INSTALL",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/INSTALL",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/INSTALL?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n Basic Installation\n ==================\n \n-These are installation instructions for Readline-7.0.\n+These are installation instructions for Readline-8.0.\n \n The simplest way to compile readline is:\n "
    },
    {
      "sha": "ad49d6686b06400813a0b26f3bb16a1c75e858a8",
      "filename": "readline/MANIFEST",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/MANIFEST",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/MANIFEST",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/MANIFEST?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -118,6 +118,7 @@ examples/rl-fgets.c\tf\n examples/rlbasic.c\tf\n examples/rlcat.c\tf\n examples/rlevent.c\tf\n+examples/rlkeymaps.c\tf\n examples/rltest.c\tf\n examples/rl-callbacktest.c\tf\n examples/rl.c\t\tf"
    },
    {
      "sha": "bcbd18b662ad77527a6ad7eaea22fba4fe29da33",
      "filename": "readline/Makefile.in",
      "status": "modified",
      "additions": 26,
      "deletions": 7,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/Makefile.in?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n ## -*- text -*- ##\n # Master Makefile for the GNU readline library.\n-# Copyright (C) 1994-2009 Free Software Foundation, Inc.\n+# Copyright (C) 1994-2018 Free Software Foundation, Inc.\n \n #   This program is free software: you can redistribute it and/or modify\n #   it under the terms of the GNU General Public License as published by\n@@ -59,6 +59,7 @@ mandir = @mandir@\n includedir = @includedir@\n datadir = @datadir@\n localedir = @localedir@\n+pkgconfigdir = ${libdir}/pkgconfig\n \n infodir = @infodir@\n \n@@ -85,7 +86,7 @@ TERMCAP_LIB = @TERMCAP_LIB@\n # For libraries which include headers from other libraries.\n INCLUDES = -I. -I$(srcdir)\n \n-XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(INCLUDES) $(CPPFLAGS)\n+XCCFLAGS = $(ASAN_CFLAGS) $(DEFS) $(LOCAL_DEFS) $(INCLUDES) $(CPPFLAGS)\n CCFLAGS = $(XCCFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)\n \n # could add -Werror here\n@@ -94,6 +95,11 @@ GCC_LINT_FLAGS = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-qual \\\n \t\t -Wmissing-prototypes -Wno-implicit -pedantic\n GCC_LINT_CFLAGS = $(XCCFLAGS) $(GCC_LINT_FLAGS) @CFLAGS@ @LOCAL_CFLAGS@\n \n+ASAN_XCFLAGS = -fsanitize=address -fno-omit-frame-pointer\n+ASAN_XLDFLAGS = -fsanitize=address\n+\n+install_examples = @EXAMPLES_INSTALL_TARGET@\n+\n .c.o:\n \t${RM} $@\n \t$(CC) -c $(CCFLAGS) $<\n@@ -160,6 +166,9 @@ all: $(TARGETS)\n \n everything: all examples\n \n+asan:\n+\t${MAKE} ${MFLAGS} ASAN_CFLAGS='${ASAN_XCFLAGS}' ASAN_LDFLAGS='${ASAN_XLDFLAGS}' everything\n+\n static: $(STATIC_LIBS)\n \n libreadline.a: $(OBJECTS)\n@@ -242,7 +251,16 @@ uninstall-headers:\n \n maybe-uninstall-headers: uninstall-headers\n \n-install-static: installdirs $(STATIC_LIBS) install-headers install-doc install-examples\n+install-pc: installdirs\n+\t-$(INSTALL_DATA) $(BUILD_DIR)/readline.pc $(DESTDIR)$(pkgconfigdir)/readline.pc\n+\n+uninstall-pc:\n+\t-test -n \"$(pkgconfigdir)\" && cd $(DESTDIR)$(pkgconfigdir) && \\\n+\t\t${RM} readline.pc\n+\n+maybe-uninstall-pc: uninstall-pc\n+\n+install-static: installdirs $(STATIC_LIBS) install-headers install-doc ${install_examples} install-pc\n \t-$(MV) $(DESTDIR)$(libdir)/libreadline.a $(DESTDIR)$(libdir)/libreadline.old\n \t$(INSTALL_DATA) libreadline.a $(DESTDIR)$(libdir)/libreadline.a\n \t-test -n \"$(RANLIB)\" && $(RANLIB) $(DESTDIR)$(libdir)/libreadline.a\n@@ -253,17 +271,18 @@ install-static: installdirs $(STATIC_LIBS) install-headers install-doc install-e\n installdirs: $(srcdir)/support/mkinstalldirs\n \t-$(SHELL) $(srcdir)/support/mkinstalldirs $(DESTDIR)$(includedir) \\\n \t\t$(DESTDIR)$(includedir)/readline $(DESTDIR)$(libdir) \\\n-\t\t$(DESTDIR)$(infodir) $(DESTDIR)$(man3dir) $(DESTDIR)$(docdir)\n+\t\t$(DESTDIR)$(infodir) $(DESTDIR)$(man3dir) $(DESTDIR)$(docdir) \\\n+\t\t$(DESTDIR)$(pkgconfigdir)\n \n-uninstall: uninstall-headers uninstall-doc uninstall-examples\n+uninstall: uninstall-headers uninstall-doc uninstall-examples uninstall-pc\n \t-test -n \"$(DESTDIR)$(libdir)\" && cd $(DESTDIR)$(libdir) && \\\n \t\t${RM} libreadline.a libreadline.old libhistory.a libhistory.old $(SHARED_LIBS)\n \t-( cd shlib; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} uninstall )\n \n-install-shared: installdirs install-headers shared install-doc\n+install-shared: installdirs install-headers shared install-doc install-pc\n \t( cd shlib ; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} install )\n \t\n-uninstall-shared: maybe-uninstall-headers\n+uninstall-shared: maybe-uninstall-headers maybe-uninstall-pc\n \t-( cd shlib; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} uninstall )\n \n install-examples: installdirs install-headers"
    },
    {
      "sha": "42be21eb02c2a521108b02c83633963e6a1444e1",
      "filename": "readline/NEWS",
      "status": "modified",
      "additions": 73,
      "deletions": 0,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/NEWS?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,3 +1,48 @@\n+This is a terse description of the new features added to readline-8.0 since\n+the release of readline-7.0.\n+\n+New Features in Readline\n+\n+a. Non-incremental vi-mode search (`N', `n') can search for a shell pattern, as\n+   Posix specifies (uses fnmatch(3) if available).\n+\n+b. There are new `next-screen-line' and `previous-screen-line' bindable\n+   commands, which move the cursor to the same column in the next, or previous,\n+   physical line, respectively.\n+\n+c. There are default key bindings for control-arrow-key key combinations.\n+\n+d. A negative argument (-N) to `quoted-insert' means to insert the next N\n+   characters using quoted-insert.\n+\n+e. New public function: rl_check_signals(), which allows applications to\n+   respond to signals that readline catches while waiting for input using\n+   a custom read function.\n+\n+f. There is new support for conditionally testing the readline version in an\n+   inputrc file, with a full set of arithmetic comparison operators available.\n+\n+g. There is a simple variable comparison facility available for use within an\n+   inputrc file. Allowable operators are equality and inequality; string\n+   variables may be compared to a value; boolean variables must be compared to\n+   either `on' or `off'; variable names are separated from the operator by\n+   whitespace.\n+\n+h. The history expansion library now understands command and process\n+   substitution and extended globbing and allows them to appear anywhere in a\n+   word.\n+\n+i. The history library has a new variable that allows applications to set the\n+   initial quoting state, so quoting state can be inherited from a previous\n+   line.\n+\n+j. Readline now allows application-defined keymap names; there is a new public\n+   function, rl_set_keymap_name(), to do that.\n+\n+k. The \"Insert\" keypad key, if available, now puts readline into overwrite\n+   mode.\n+\n+-------------------------------------------------------------------------------\n This is a terse description of the new features added to readline-7.0 since\n the release of readline-6.3.\n \n@@ -46,6 +91,34 @@ k.  If readline reads a history file that begins with `#' (or the value of\n l.  Readline now throws an error if it parses a key binding without a terminating\n     `:' or whitespace.\n \n+m.  The default binding for ^W in vi mode now uses word boundaries specified\n+    by Posix (vi-unix-word-rubout is bindable command name).\n+\n+n.  rl_clear_visible_line: new application-callable function; clears all\n+    screen lines occupied by the current visible readline line.\n+\n+o.  rl_tty_set_echoing: application-callable function that controls whether\n+    or not readline thinks it is echoing terminal output.\n+\n+p.  Handle >| and strings of digits preceding and following redirection\n+    specifications as single tokens when tokenizing the line for history\n+    expansion.\n+\n+q.  Fixed a bug with displaying completions when the prefix display length\n+    is greater than the length of the completions to be displayed.\n+\n+r.  The :p history modifier now applies to the entire line, so any expansion\n+    specifying :p causes the line to be printed instead of expanded.\n+\n+s.  New application-callable function: rl_pending_signal(): returns the signal\n+    number of any signal readline has caught but not yet handled.\n+    \n+t.  New application-settable variable: rl_persistent_signal_handlers: if set\n+    to a non-zero value, readline will enable the readline-6.2 signal handler\n+    behavior in callback mode: handlers are installed when\n+    rl_callback_handler_install is called and removed removed when a complete\n+    line has been read.\n+\n -------------------------------------------------------------------------------\n This is a terse description of the new features added to readline-6.3 since\n the release of readline-6.2."
    },
    {
      "sha": "4fb0804fca02dcc42077ea138da9a59f31e3a109",
      "filename": "readline/README",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/README",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/README",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/README?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n Introduction\n ============\n \n-This is the Gnu Readline library, version 7.0.\n+This is the Gnu Readline library, version 8.0.\n \n The Readline library provides a set of functions for use by applications\n that allow users to edit command lines as they are typed in.  Both"
    },
    {
      "sha": "1413267fc1689b5adfe4ed355a3409af27954060",
      "filename": "readline/aclocal.m4",
      "status": "modified",
      "additions": 86,
      "deletions": 21,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/aclocal.m4?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,4 +1,4 @@\n-dnl\n+nl\n dnl Bash specific tests\n dnl\n dnl Some derived from PDKSH 5.1.3 autoconf tests\n@@ -962,7 +962,8 @@ AC_CACHE_VAL(bash_cv_termcap_lib,\n     [AC_CHECK_LIB(tinfo, tgetent, bash_cv_termcap_lib=libtinfo,\n         [AC_CHECK_LIB(curses, tgetent, bash_cv_termcap_lib=libcurses,\n \t    [AC_CHECK_LIB(ncurses, tgetent, bash_cv_termcap_lib=libncurses,\n-\t        bash_cv_termcap_lib=gnutermcap)])])])])])\n+                [AC_CHECK_LIB(ncursesw, tgetent, bash_cv_termcap_lib=libncursesw,\n+\t            bash_cv_termcap_lib=gnutermcap)])])])])])])\n if test \"X$_bash_needmsg\" = \"Xyes\"; then\n AC_MSG_CHECKING(which library has the termcap functions)\n fi\n@@ -1307,7 +1308,7 @@ AC_CACHE_VAL(bash_cv_must_reinstall_sighandlers,\n \n typedef RETSIGTYPE sigfunc();\n \n-int nsigint;\n+volatile int nsigint;\n \n #ifdef HAVE_POSIX_SIGNALS\n sigfunc *\n@@ -1357,7 +1358,7 @@ AC_DEFUN(BASH_SYS_JOB_CONTROL_MISSING,\n [AC_REQUIRE([BASH_SYS_SIGNAL_VINTAGE])\n AC_MSG_CHECKING(for presence of necessary job control definitions)\n AC_CACHE_VAL(bash_cv_job_control_missing,\n-[AC_TRY_RUN([\n+[AC_TRY_COMPILE([\n #include <sys/types.h>\n #ifdef HAVE_SYS_WAIT_H\n #include <sys/wait.h>\n@@ -1367,42 +1368,38 @@ AC_CACHE_VAL(bash_cv_job_control_missing,\n #endif\n #include <signal.h>\n \n-/* Add more tests in here as appropriate. */\n-main()\n-{\n+/* add more tests in here as appropriate */\n+\n /* signal type */\n #if !defined (HAVE_POSIX_SIGNALS) && !defined (HAVE_BSD_SIGNALS)\n-exit(1);\n+#error\n #endif\n \n /* signals and tty control. */\n #if !defined (SIGTSTP) || !defined (SIGSTOP) || !defined (SIGCONT)\n-exit (1);\n+#error\n #endif\n \n /* process control */\n #if !defined (WNOHANG) || !defined (WUNTRACED) \n-exit(1);\n+#error\n #endif\n \n /* Posix systems have tcgetpgrp and waitpid. */\n #if defined (_POSIX_VERSION) && !defined (HAVE_TCGETPGRP)\n-exit(1);\n+#error\n #endif\n \n #if defined (_POSIX_VERSION) && !defined (HAVE_WAITPID)\n-exit(1);\n+#error\n #endif\n \n /* Other systems have TIOCSPGRP/TIOCGPRGP and wait3. */\n #if !defined (_POSIX_VERSION) && !defined (HAVE_WAIT3)\n-exit(1);\n+#error\n #endif\n \n-exit(0);\n-}], bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing,\n-    [AC_MSG_WARN(cannot check job control if cross-compiling -- defaulting to missing)\n-     bash_cv_job_control_missing=missing]\n+], , bash_cv_job_control_missing=present, bash_cv_job_control_missing=missing\n )])\n AC_MSG_RESULT($bash_cv_job_control_missing)\n if test $bash_cv_job_control_missing = missing; then\n@@ -1585,9 +1582,7 @@ fi\n AC_DEFUN(BASH_CHECK_DEV_STDIN,\n [AC_MSG_CHECKING(whether /dev/stdin stdout stderr are available)\n AC_CACHE_VAL(bash_cv_dev_stdin,\n-[if test -d /dev/fd && (exec test -r /dev/stdin < /dev/null) ; then\n-   bash_cv_dev_stdin=present\n- elif test -d /proc/self/fd && (exec test -r /dev/stdin < /dev/null) ; then\n+[if (exec test -r /dev/stdin < /dev/null) ; then\n    bash_cv_dev_stdin=present\n  else\n    bash_cv_dev_stdin=absent\n@@ -1798,6 +1793,8 @@ if test \"$am_cv_func_iconv\" = yes; then\n \tLIBS=\"$OLDLIBS\"\n fi\n \n+AC_CHECK_SIZEOF(wchar_t, 4)\n+\n ])\n \n dnl need: prefix exec_prefix libdir includedir CC TERMCAP_LIB\n@@ -1856,7 +1853,7 @@ main()\n ],\n ac_cv_rl_version=`cat conftest.rlv`,\n ac_cv_rl_version='0.0',\n-ac_cv_rl_version='6.3')])\n+ac_cv_rl_version='8.0')])\n \n CFLAGS=\"$_save_CFLAGS\"\n LDFLAGS=\"$_save_LDFLAGS\"\n@@ -4195,3 +4192,71 @@ fi\n AC_MSG_RESULT($bash_cv_wexitstatus_offset)\n AC_DEFINE_UNQUOTED([WEXITSTATUS_OFFSET], [$bash_cv_wexitstatus_offset], [Offset of exit status in wait status word])\n ])\n+\n+AC_DEFUN([BASH_FUNC_SBRK],\n+[\n+  AC_CHECK_FUNCS_ONCE([sbrk])\n+  if test X$ac_cv_func_sbrk = Xyes; then\n+    AC_CACHE_CHECK([for working sbrk], [bash_cv_func_sbrk],\n+      [AC_TRY_RUN([\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+int\n+main(int c, char **v)\n+{\n+\tvoid *x;\n+\n+\tx = sbrk (4096);\n+\texit ((x == (void *)-1) ? 1 : 0);\n+}\n+], bash_cv_func_sbrk=yes, bash_cv_func_snprintf=sbrk,\n+   [AC_MSG_WARN([cannot check working sbrk if cross-compiling])\n+    bash_cv_func_sbrk=yes]\n+)])\n+    if test $bash_cv_func_sbrk = no; then\n+      ac_cv_func_sbrk=no\n+    fi\n+  fi\n+  if test $ac_cv_func_sbrk = no; then\n+    AC_DEFINE(HAVE_SBRK, 0,\n+      [Define if you have a working sbrk function.])\n+  fi\n+])\n+\n+AC_DEFUN(BASH_FUNC_FNMATCH_EQUIV_FALLBACK,\n+[AC_MSG_CHECKING(whether fnmatch can be used to check bracket equivalence classes)\n+AC_CACHE_VAL(bash_cv_fnmatch_equiv_fallback,\n+[AC_TRY_RUN([\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <fnmatch.h>\n+#include <locale.h>\n+\n+char *pattern = \"[[=a=]]\";\n+\n+/* char *string = \"\u00e4\"; */\n+unsigned char string[4] = { '\\xc3', '\\xa4', '\\0' };\n+\n+int\n+main (int c, char **v)\n+{\n+  setlocale (LC_ALL, \"de_DE.UTF-8\");\n+  if (fnmatch (pattern, (const char *)string, 0) != FNM_NOMATCH)\n+    exit (0);\n+  exit (1);\n+}\n+\n+], bash_cv_fnmatch_equiv_fallback=yes, bash_cv_fnmatch_equiv_fallback=no,\n+   [AC_MSG_WARN(cannot check fnmatch if cross compiling -- defaulting to no)\n+    bash_cv_fnmatch_equiv_fallback=no]\n+)])\n+AC_MSG_RESULT($bash_cv_fnmatch_equiv_fallback)\n+if test \"$bash_cv_fnmatch_equiv_fallback\" = \"yes\" ; then\n+    bash_cv_fnmatch_equiv_value=1\n+else\n+    bash_cv_fnmatch_equiv_value=0\n+fi\n+AC_DEFINE_UNQUOTED([FNMATCH_EQUIV_FALLBACK], [$bash_cv_fnmatch_equiv_value], [Whether fnmatch can be used for bracket equivalence classes])\n+])"
    },
    {
      "sha": "57ae10f7318e521797fb4b8f7e426c7ab1324a49",
      "filename": "readline/bind.c",
      "status": "modified",
      "additions": 473,
      "deletions": 210,
      "changes": 683,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/bind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/bind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/bind.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* bind.c -- key binding and startup file support for the readline library. */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -80,21 +80,39 @@ static void _rl_init_file_error (const char *, ...)  __attribute__((__format__ (\n static void _rl_init_file_error ();\n #endif\n \n+static rl_command_func_t *_rl_function_of_keyseq_internal PARAMS((const char *, size_t, Keymap, int *));\n+\n static char *_rl_read_file PARAMS((char *, size_t *));\n static int _rl_read_init_file PARAMS((const char *, int));\n static int glean_key_from_name PARAMS((char *));\n \n static int find_boolean_var PARAMS((const char *));\n static int find_string_var PARAMS((const char *));\n \n+static const char *boolean_varname PARAMS((int));\n+static const char *string_varname PARAMS((int));\n+\n static char *_rl_get_string_variable_value PARAMS((const char *));\n static int substring_member_of_array PARAMS((const char *, const char * const *));\n \n+static int _rl_get_keymap_by_name PARAMS((const char *));\n+static int _rl_get_keymap_by_map PARAMS((Keymap));\n+\n static int currently_reading_init_file;\n \n /* used only in this file */\n static int _rl_prefer_visible_bell = 1;\n \n+#define OP_EQ\t1\n+#define OP_NE\t2\n+#define OP_GT\t3\n+#define OP_GE\t4\n+#define OP_LT\t5\n+#define OP_LE\t6\n+\n+#define OPSTART(c)\t((c) == '=' || (c) == '!' || (c) == '<' || (c) == '>')\n+#define CMPSTART(c)\t((c) == '=' || (c) == '!')\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tBinding keys\t\t\t\t    */\n@@ -105,10 +123,7 @@ static int _rl_prefer_visible_bell = 1;\n    Add NAME to the list of named functions.  Make FUNCTION be the function\n    that gets called.  If KEY is not -1, then bind it. */\n int\n-rl_add_defun (name, function, key)\n-     const char *name;\n-     rl_command_func_t *function;\n-     int key;\n+rl_add_defun (const char *name, rl_command_func_t *function, int key)\n {\n   if (key != -1)\n     rl_bind_key (key, function);\n@@ -118,9 +133,7 @@ rl_add_defun (name, function, key)\n \n /* Bind KEY to FUNCTION.  Returns non-zero if KEY is out of range. */\n int\n-rl_bind_key (key, function)\n-     int key;\n-     rl_command_func_t *function;\n+rl_bind_key (int key, rl_command_func_t *function)\n {\n   char keyseq[3];\n   int l;\n@@ -168,10 +181,7 @@ rl_bind_key (key, function)\n /* Bind KEY to FUNCTION in MAP.  Returns non-zero in case of invalid\n    KEY. */\n int\n-rl_bind_key_in_map (key, function, map)\n-     int key;\n-     rl_command_func_t *function;\n-     Keymap map;\n+rl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)\n {\n   int result;\n   Keymap oldmap;\n@@ -184,57 +194,44 @@ rl_bind_key_in_map (key, function, map)\n }\n \n /* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound.  Right\n-   now, this is always used to attempt to bind the arrow keys, hence the\n-   check for rl_vi_movement_mode. */\n+   now, this is always used to attempt to bind the arrow keys. */\n int\n-rl_bind_key_if_unbound_in_map (key, default_func, kmap)\n-     int key;\n-     rl_command_func_t *default_func;\n-     Keymap kmap;\n+rl_bind_key_if_unbound_in_map (int key, rl_command_func_t *default_func, Keymap kmap)\n {\n-  char keyseq[2];\n+  char *keyseq;\n \n-  keyseq[0] = (unsigned char)key;\n-  keyseq[1] = '\\0';\n+  keyseq = rl_untranslate_keyseq ((unsigned char)key);\n   return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap));\n }\n \n int\n-rl_bind_key_if_unbound (key, default_func)\n-     int key;\n-     rl_command_func_t *default_func;\n+rl_bind_key_if_unbound (int key, rl_command_func_t *default_func)\n {\n-  char keyseq[2];\n+  char *keyseq;\n \n-  keyseq[0] = (unsigned char)key;\n-  keyseq[1] = '\\0';\n+  keyseq = rl_untranslate_keyseq ((unsigned char)key);\n   return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));\n }\n \n /* Make KEY do nothing in the currently selected keymap.\n-   Returns non-zero in case of error. */\n+   Returns non-zero in case of error.  This is not the same as self-insert;\n+   this makes it a dead key. */\n int\n-rl_unbind_key (key)\n-     int key;\n+rl_unbind_key (int key)\n {\n   return (rl_bind_key (key, (rl_command_func_t *)NULL));\n }\n \n-/* Make KEY do nothing in MAP.\n-   Returns non-zero in case of error. */\n+/* Make KEY do nothing in MAP. Returns non-zero in case of error. */\n int\n-rl_unbind_key_in_map (key, map)\n-     int key;\n-     Keymap map;\n+rl_unbind_key_in_map (int key, Keymap map)\n {\n   return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));\n }\n \n /* Unbind all keys bound to FUNCTION in MAP. */\n int\n-rl_unbind_function_in_map (func, map)\n-     rl_command_func_t *func;\n-     Keymap map;\n+rl_unbind_function_in_map (rl_command_func_t *func, Keymap map)\n {\n   register int i, rval;\n \n@@ -249,10 +246,9 @@ rl_unbind_function_in_map (func, map)\n   return rval;\n }\n \n+/* Unbind all keys bound to COMMAND, which is a bindable command name, in MAP */\n int\n-rl_unbind_command_in_map (command, map)\n-     const char *command;\n-     Keymap map;\n+rl_unbind_command_in_map (const char *command, Keymap map)\n {\n   rl_command_func_t *func;\n \n@@ -266,9 +262,7 @@ rl_unbind_command_in_map (command, map)\n    FUNCTION, starting in the current keymap.  This makes new\n    keymaps as necessary. */\n int\n-rl_bind_keyseq (keyseq, function)\n-     const char *keyseq;\n-     rl_command_func_t *function;\n+rl_bind_keyseq (const char *keyseq, rl_command_func_t *function)\n {\n   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, _rl_keymap));\n }\n@@ -277,20 +271,14 @@ rl_bind_keyseq (keyseq, function)\n    FUNCTION.  This makes new keymaps as necessary.  The initial\n    place to do bindings is in MAP. */\n int\n-rl_bind_keyseq_in_map (keyseq, function, map)\n-     const char *keyseq;\n-     rl_command_func_t *function;\n-     Keymap map;\n+rl_bind_keyseq_in_map (const char *keyseq, rl_command_func_t *function, Keymap map)\n {\n   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));\n }\n \n /* Backwards compatibility; equivalent to rl_bind_keyseq_in_map() */\n int\n-rl_set_key (keyseq, function, map)\n-     const char *keyseq;\n-     rl_command_func_t *function;\n-     Keymap map;\n+rl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)\n {\n   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));\n }\n@@ -299,16 +287,24 @@ rl_set_key (keyseq, function, map)\n    now, this is always used to attempt to bind the arrow keys, hence the\n    check for rl_vi_movement_mode. */\n int\n-rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)\n-     const char *keyseq;\n-     rl_command_func_t *default_func;\n-     Keymap kmap;\n+rl_bind_keyseq_if_unbound_in_map (const char *keyseq, rl_command_func_t *default_func, Keymap kmap)\n {\n   rl_command_func_t *func;\n+  char *keys;\n+  int keys_len;\n \n   if (keyseq)\n     {\n-      func = rl_function_of_keyseq (keyseq, kmap, (int *)NULL);\n+      /* Handle key sequences that require translations and `raw' ones that\n+\t don't. This might be a problem with backslashes. */\n+      keys = (char *)xmalloc (1 + (2 * strlen (keyseq)));\n+      if (rl_translate_keyseq (keyseq, keys, &keys_len))\n+\t{\n+\t  xfree (keys);\n+\t  return -1;\n+\t}\n+      func = rl_function_of_keyseq_len (keys, keys_len, kmap, (int *)NULL);\n+      xfree (keys);\n #if defined (VI_MODE)\n       if (!func || func == rl_do_lowercase_version || func == rl_vi_movement_mode)\n #else\n@@ -322,9 +318,7 @@ rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, kmap)\n }\n \n int\n-rl_bind_keyseq_if_unbound (keyseq, default_func)\n-     const char *keyseq;\n-     rl_command_func_t *default_func;\n+rl_bind_keyseq_if_unbound (const char *keyseq, rl_command_func_t *default_func)\n {\n   return (rl_bind_keyseq_if_unbound_in_map (keyseq, default_func, _rl_keymap));\n }\n@@ -333,9 +327,7 @@ rl_bind_keyseq_if_unbound (keyseq, default_func)\n    the string of characters MACRO.  This makes new keymaps as\n    necessary.  The initial place to do bindings is in MAP. */\n int\n-rl_macro_bind (keyseq, macro, map)\n-     const char *keyseq, *macro;\n-     Keymap map;\n+rl_macro_bind (const char *keyseq, const char *macro, Keymap map)\n {\n   char *macro_keys;\n   int macro_keys_len;\n@@ -357,16 +349,13 @@ rl_macro_bind (keyseq, macro, map)\n    a macro (ISMACR), or a keymap (ISKMAP).  This makes new keymaps\n    as necessary.  The initial place to do bindings is in MAP. */\n int\n-rl_generic_bind (type, keyseq, data, map)\n-     int type;\n-     const char *keyseq;\n-     char *data;\n-     Keymap map;\n+rl_generic_bind (int type, const char *keyseq, char *data, Keymap map)\n {\n   char *keys;\n-  int keys_len;\n+  int keys_len, prevkey;\n   register int i;\n   KEYMAP_ENTRY k;\n+  Keymap prevmap;  \n \n   k.function = 0;\n \n@@ -389,12 +378,18 @@ rl_generic_bind (type, keyseq, data, map)\n       return -1;\n     }\n \n+  prevmap = map;\n+  prevkey = keys[0];\n+\n   /* Bind keys, making new keymaps as necessary. */\n   for (i = 0; i < keys_len; i++)\n     {\n       unsigned char uc = keys[i];\n       int ic;\n \n+      if (i > 0)\n+\tprevkey = ic;\n+\n       ic = uc;\n       if (ic < 0 || ic >= KEYMAP_SIZE)\n         {\n@@ -406,7 +401,10 @@ rl_generic_bind (type, keyseq, data, map)\n \t{\n \t  ic = UNMETA (ic);\n \t  if (map[ESC].type == ISKMAP)\n-\t    map = FUNCTION_TO_KEYMAP (map, ESC);\n+\t    {\n+\t      prevmap = map;\n+\t      map = FUNCTION_TO_KEYMAP (map, ESC);\n+\t    }\n \t}\n \n       if ((i + 1) < keys_len)\n@@ -425,6 +423,7 @@ rl_generic_bind (type, keyseq, data, map)\n \t      map[ic].type = ISKMAP;\n \t      map[ic].function = KEYMAP_TO_FUNCTION (rl_make_bare_keymap());\n \t    }\n+\t  prevmap = map;\n \t  map = FUNCTION_TO_KEYMAP (map, ic);\n \t  /* The dispatch code will return this function if no matching\n \t     key sequence is found in the keymap.  This (with a little\n@@ -444,6 +443,7 @@ rl_generic_bind (type, keyseq, data, map)\n \t    xfree ((char *)map[ic].function);\n \t  else if (map[ic].type == ISKMAP)\n \t    {\n+\t      prevmap = map;\n \t      map = FUNCTION_TO_KEYMAP (map, ic);\n \t      ic = ANYOTHERKEY;\n \t      /* If we're trying to override a keymap with a null function\n@@ -460,7 +460,28 @@ rl_generic_bind (type, keyseq, data, map)\n \t}\n \n       rl_binding_keymap = map;\n+\n     }\n+\n+  /* If we unbound a key (type == ISFUNC, data == 0), and the prev keymap\n+     points to the keymap where we unbound the key (sanity check), and the\n+     current binding keymap is empty (rl_empty_keymap() returns non-zero),\n+     and the binding keymap has ANYOTHERKEY set with type == ISFUNC\n+     (overridden function), delete the now-empty keymap, take the previously-\n+     overridden function and remove the override. */\n+  /* Right now, this only works one level back. */\n+  if (type == ISFUNC && data == 0 &&\n+      prevmap[prevkey].type == ISKMAP &&\n+      (FUNCTION_TO_KEYMAP(prevmap, prevkey) == rl_binding_keymap) &&\n+      rl_binding_keymap[ANYOTHERKEY].type == ISFUNC &&\n+      rl_empty_keymap (rl_binding_keymap))\n+    {\n+      prevmap[prevkey].type = rl_binding_keymap[ANYOTHERKEY].type;\n+      prevmap[prevkey].function = rl_binding_keymap[ANYOTHERKEY].function;\n+      rl_discard_keymap (rl_binding_keymap);\n+      rl_binding_keymap = prevmap;\n+    }\n+\n   xfree (keys);\n   return 0;\n }\n@@ -469,10 +490,7 @@ rl_generic_bind (type, keyseq, data, map)\n    an array of characters.  LEN gets the final length of ARRAY.  Return\n    non-zero if there was an error parsing SEQ. */\n int\n-rl_translate_keyseq (seq, array, len)\n-     const char *seq;\n-     char *array;\n-     int *len;\n+rl_translate_keyseq (const char *seq, char *array, int *len)\n {\n   register int i, c, l, temp;\n \n@@ -483,7 +501,10 @@ rl_translate_keyseq (seq, array, len)\n \t  c = seq[++i];\n \n \t  if (c == 0)\n-\t    break;\n+\t    {\n+\t      array[l++] = '\\\\';\t/* preserve trailing backslash */\n+\t      break;\n+\t    }\n \n \t  /* Handle \\C- and \\M- prefixes. */\n \t  if ((c == 'C' || c == 'M') && seq[i + 1] == '-')\n@@ -494,8 +515,6 @@ rl_translate_keyseq (seq, array, len)\n \t\t  array[l++] = ESC;\t/* ESC is meta-prefix */\n \t\t  i += 5;\n \t\t  array[l++] = CTRL (_rl_to_upper (seq[i]));\n-\t\t  if (seq[i] == '\\0')\n-\t\t    i--;\n \t\t}\n \t      else if (c == 'M')\n \t\t{\n@@ -524,6 +543,8 @@ rl_translate_keyseq (seq, array, len)\n \t\t  /* Special hack for C-?... */\n \t\t  array[l++] = (seq[i] == '?') ? RUBOUT : CTRL (_rl_to_upper (seq[i]));\n \t\t}\n+\t      if (seq[i] == '\\0')\n+\t\tbreak;\n \t      continue;\n \t    }\t      \n \n@@ -596,8 +617,7 @@ rl_translate_keyseq (seq, array, len)\n }\n \n static int\n-_rl_isescape (c)\n-     int c;\n+_rl_isescape (int c)\n {\n   switch (c)\n     {\n@@ -613,8 +633,7 @@ _rl_isescape (c)\n }\n \n static int\n-_rl_escchar (c)\n-     int c;\n+_rl_escchar (int c)\n {\n   switch (c)\n     {\n@@ -630,8 +649,7 @@ _rl_escchar (c)\n }\n \n char *\n-rl_untranslate_keyseq (seq)\n-     int seq;\n+rl_untranslate_keyseq (int seq)\n {\n   static char kseq[16];\n   int i, c;\n@@ -681,9 +699,7 @@ rl_untranslate_keyseq (seq)\n }\n \n char *\n-_rl_untranslate_macro_value (seq, use_escapes)\n-     char *seq;\n-     int use_escapes;\n+_rl_untranslate_macro_value (char *seq, int use_escapes)\n {\n   char *ret, *r, *s;\n   int c;\n@@ -742,8 +758,7 @@ _rl_untranslate_macro_value (seq, use_escapes)\n    If STRING doesn't have a matching function, then a NULL pointer\n    is returned. */\n rl_command_func_t *\n-rl_named_function (string)\n-     const char *string;\n+rl_named_function (const char *string)\n {\n   register int i;\n \n@@ -760,18 +775,15 @@ rl_named_function (string)\n    used.  TYPE, if non-NULL, is a pointer to an int which will receive the\n    type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),\n    or ISMACR (macro). */\n-rl_command_func_t *\n-rl_function_of_keyseq (keyseq, map, type)\n-     const char *keyseq;\n-     Keymap map;\n-     int *type;\n+static rl_command_func_t *\n+_rl_function_of_keyseq_internal (const char *keyseq, size_t len, Keymap map, int *type)\n {\n   register int i;\n \n   if (map == 0)\n     map = _rl_keymap;\n \n-  for (i = 0; keyseq && keyseq[i]; i++)\n+  for (i = 0; keyseq && i < len; i++)\n     {\n       unsigned char ic = keyseq[i];\n \n@@ -823,6 +835,18 @@ rl_function_of_keyseq (keyseq, map, type)\n   return ((rl_command_func_t *) NULL);\n }\n \n+rl_command_func_t *\n+rl_function_of_keyseq (const char *keyseq, Keymap map, int *type)\n+{\n+  return _rl_function_of_keyseq_internal (keyseq, strlen (keyseq), map, type);\n+}\n+\n+rl_command_func_t *\n+rl_function_of_keyseq_len (const char *keyseq, size_t len, Keymap map, int *type)\n+{\n+  return _rl_function_of_keyseq_internal (keyseq, len, map, type);\n+}\n+\n /* The last key bindings file read. */\n static char *last_readline_init_file = (char *)NULL;\n \n@@ -835,17 +859,20 @@ static int current_readline_init_lineno;\n    The size of the buffer is returned in *SIZEP.  Returns NULL if any\n    errors were encountered. */\n static char *\n-_rl_read_file (filename, sizep)\n-     char *filename;\n-     size_t *sizep;\n+_rl_read_file (char *filename, size_t *sizep)\n {\n   struct stat finfo;\n   size_t file_size;\n   char *buffer;\n   int i, file;\n \n-  if ((stat (filename, &finfo) < 0) || (file = open (filename, O_RDONLY, 0666)) < 0)\n-    return ((char *)NULL);\n+  file = -1;\n+  if (((file = open (filename, O_RDONLY, 0666)) < 0) || (fstat (file, &finfo) < 0))\n+    {\n+      if (file >= 0)\n+\tclose (file);\n+      return ((char *)NULL);\n+    }\n \n   file_size = (size_t)finfo.st_size;\n \n@@ -882,8 +909,7 @@ _rl_read_file (filename, sizep)\n \n /* Re-read the current keybindings file. */\n int\n-rl_re_read_init_file (count, ignore)\n-     int count, ignore;\n+rl_re_read_init_file (int count, int ignore)\n {\n   int r;\n   r = rl_read_init_file ((const char *)NULL);\n@@ -900,8 +926,7 @@ rl_re_read_init_file (count, ignore)\n    If the file existed and could be opened and read, 0 is returned,\n    otherwise errno is returned. */\n int\n-rl_read_init_file (filename)\n-     const char *filename;\n+rl_read_init_file (const char *filename)\n {\n   /* Default the filename. */\n   if (filename == 0)\n@@ -926,9 +951,7 @@ rl_read_init_file (filename)\n }\n \n static int\n-_rl_read_init_file (filename, include_level)\n-     const char *filename;\n-     int include_level;\n+_rl_read_init_file (const char *filename, int include_level)\n {\n   register int i;\n   char *buffer, *openname, *line, *end;\n@@ -1025,6 +1048,62 @@ _rl_init_file_error (va_alist)\n   va_end (args);\n }\n \n+/* **************************************************************** */\n+/*\t\t\t\t\t\t\t\t    */\n+/*\t\t\tParser Helper Functions       \t\t    */\n+/*\t\t\t\t\t\t\t\t    */\n+/* **************************************************************** */\n+\n+static int\n+parse_comparison_op (s, indp)\n+     const char *s;\n+     int *indp;\n+{\n+  int i, peekc, op;\n+\n+  if (OPSTART (s[*indp]) == 0)\n+    return -1;\n+  i = *indp;\n+  peekc = s[i] ? s[i+1] : 0;\n+  op = -1;\n+\n+  if (s[i] == '=')\n+    {\n+      op = OP_EQ;\n+      if (peekc == '=')\n+        i++;\n+      i++;\n+    }\n+  else if (s[i] == '!' && peekc == '=')\n+    {\n+      op = OP_NE;\n+      i += 2;\n+    }\n+  else if (s[i] == '<' && peekc == '=')\n+    {\n+      op = OP_LE;\n+      i += 2;\n+    }\n+  else if (s[i] == '>' && peekc == '=')\n+    {\n+      op = OP_GE;\n+      i += 2;\n+    }\n+  else if (s[i] == '<')\n+    {\n+      op = OP_LT;\n+      i += 1;\n+    }\n+  else if (s[i] == '>')\n+    {\n+      op = OP_GT;\n+      i += 1;\n+    }\n+\n+  *indp = i;\n+  return op;        \n+}\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tParser Directives       \t\t    */\n@@ -1055,10 +1134,11 @@ static int if_stack_size;\n /* Push _rl_parsing_conditionalized_out, and set parser state based\n    on ARGS. */\n static int\n-parser_if (args)\n-     char *args;\n+parser_if (char *args)\n {\n-  register int i;\n+  int i, llen, boolvar, strvar;\n+\n+  boolvar = strvar = -1;\n \n   /* Push parser state. */\n   if (if_stack_depth + 1 >= if_stack_size)\n@@ -1075,6 +1155,8 @@ parser_if (args)\n   if (_rl_parsing_conditionalized_out)\n     return 0;\n \n+  llen = strlen (args);\n+\n   /* Isolate first argument. */\n   for (i = 0; args[i] && !whitespace (args[i]); i++);\n \n@@ -1117,19 +1199,146 @@ parser_if (args)\n       _rl_parsing_conditionalized_out = mode != rl_editing_mode;\n     }\n #endif /* VI_MODE */\n+  else if (_rl_strnicmp (args, \"version\", 7) == 0)\n+    {\n+      int rlversion, versionarg, op, previ, major, minor;\n+\n+      _rl_parsing_conditionalized_out = 1;\n+      rlversion = RL_VERSION_MAJOR*10 + RL_VERSION_MINOR;\n+      /* if \"version\" is separated from the operator by whitespace, or the\n+         operand is separated from the operator by whitespace, restore it.\n+         We're more liberal with allowed whitespace for this variable. */\n+      if (i > 0 && i <= llen && args[i-1] == '\\0')\n+        args[i-1] = ' ';\n+      args[llen] = '\\0';\t\t/* just in case */\n+      for (i = 7; whitespace (args[i]); i++)\n+\t;\n+      if (OPSTART(args[i]) == 0)\n+\t{\n+\t  _rl_init_file_error (\"comparison operator expected, found `%s'\", args[i] ? args + i : \"end-of-line\");\n+\t  return 0;\n+\t}\n+      previ = i;\n+      op = parse_comparison_op (args, &i);\n+      if (op <= 0)\n+\t{\n+\t  _rl_init_file_error (\"comparison operator expected, found `%s'\", args+previ);\n+\t  return 0;\n+\t}\n+      for ( ; args[i] && whitespace (args[i]); i++)\n+\t;\n+      if (args[i] == 0 || _rl_digit_p (args[i]) == 0)\n+\t{\n+\t  _rl_init_file_error (\"numeric argument expected, found `%s'\", args+i);\n+\t  return 0;\n+\t}\n+      major = minor = 0;\n+      previ = i;\n+      for ( ; args[i] && _rl_digit_p (args[i]); i++)\n+\tmajor = major*10 + _rl_digit_value (args[i]);\n+      if (args[i] == '.')\n+\t{\n+\t  if (args[i + 1] && _rl_digit_p (args [i + 1]) == 0)\n+\t    {\n+\t      _rl_init_file_error (\"numeric argument expected, found `%s'\", args+previ);\n+\t      return 0;\n+\t    }\n+\t  for (++i; args[i] && _rl_digit_p (args[i]); i++)\n+\t    minor = minor*10 + _rl_digit_value (args[i]);\n+\t}\n+      /* optional - check for trailing garbage on the line, allow whitespace\n+\t and a trailing comment */\n+      previ = i;\n+      for ( ; args[i] && whitespace (args[i]); i++)\n+\t;\n+      if (args[i] && args[i] != '#')\n+\t{\n+\t  _rl_init_file_error (\"trailing garbage on line: `%s'\", args+previ);\n+\t  return 0;\n+\t}\n+      versionarg = major*10 + minor;\n+\n+      switch (op)\n+\t{\n+\tcase OP_EQ:\n+\t  _rl_parsing_conditionalized_out = rlversion == versionarg;\n+\t  break;\n+\tcase OP_NE:\n+\t  _rl_parsing_conditionalized_out = rlversion != versionarg;\n+\t  break;\n+\tcase OP_GT:\n+\t  _rl_parsing_conditionalized_out = rlversion > versionarg;\n+\t  break;\n+\tcase OP_GE:\n+\t  _rl_parsing_conditionalized_out = rlversion >= versionarg;\n+\t  break;\n+\tcase OP_LT:\n+\t  _rl_parsing_conditionalized_out = rlversion < versionarg;\n+\t  break;\n+\tcase OP_LE:\n+\t  _rl_parsing_conditionalized_out = rlversion <= versionarg;\n+\t  break;\n+\t}\n+    }\n   /* Check to see if the first word in ARGS is the same as the\n      value stored in rl_readline_name. */\n   else if (_rl_stricmp (args, rl_readline_name) == 0)\n     _rl_parsing_conditionalized_out = 0;\n+  else if ((boolvar = find_boolean_var (args)) >= 0 || (strvar = find_string_var (args)) >= 0)\n+    {\n+      int op, previ;\n+      size_t vlen;\n+      const char *vname;\n+      char *valuearg, *vval, prevc;\n+\n+      _rl_parsing_conditionalized_out = 1;\n+      vname = (boolvar >= 0) ? boolean_varname (boolvar) : string_varname (strvar);\n+      vlen = strlen (vname);\n+      if (i > 0 && i <= llen && args[i-1] == '\\0')\n+        args[i-1] = ' ';\n+      args[llen] = '\\0';\t\t/* just in case */\n+      for (i = vlen; whitespace (args[i]); i++)\n+\t;\n+      if (CMPSTART(args[i]) == 0)\n+\t{\n+\t  _rl_init_file_error (\"equality comparison operator expected, found `%s'\", args[i] ? args + i : \"end-of-line\");\n+\t  return 0;\n+\t}\n+      previ = i;\n+      op = parse_comparison_op (args, &i);\n+      if (op != OP_EQ && op != OP_NE)\n+\t{\n+\t  _rl_init_file_error (\"equality comparison operator expected, found `%s'\", args+previ);\n+\t  return 0;\n+\t}\n+      for ( ; args[i] && whitespace (args[i]); i++)\n+\t;\n+      if (args[i] == 0)\n+\t{\n+\t  _rl_init_file_error (\"argument expected, found `%s'\", args+i);\n+\t  return 0;\n+\t}\n+      previ = i;\n+      valuearg = args + i;\n+      for ( ; args[i] && whitespace (args[i]) == 0; i++)\n+\t;\n+      prevc = args[i];\n+      args[i] = '\\0';\t\t/* null-terminate valuearg */\n+      vval = rl_variable_value (vname);\n+      if (op == OP_EQ)\n+        _rl_parsing_conditionalized_out = _rl_stricmp (vval, valuearg) != 0;\n+      else if (op == OP_NE)\n+        _rl_parsing_conditionalized_out = _rl_stricmp (vval, valuearg) == 0;\n+      args[i] = prevc;\n+    }\n   else\n     _rl_parsing_conditionalized_out = 1;\n   return 0;\n }\n \n /* Invert the current parser state if there is anything on the stack. */\n static int\n-parser_else (args)\n-     char *args;\n+parser_else (char *args)\n {\n   register int i;\n \n@@ -1159,8 +1368,7 @@ parser_else (args)\n /* Terminate a conditional, popping the value of\n    _rl_parsing_conditionalized_out from the stack. */\n static int\n-parser_endif (args)\n-     char *args;\n+parser_endif (char *args)\n {\n   if (if_stack_depth)\n     _rl_parsing_conditionalized_out = if_stack[--if_stack_depth];\n@@ -1170,8 +1378,7 @@ parser_endif (args)\n }\n \n static int\n-parser_include (args)\n-     char *args;\n+parser_include (char *args)\n {\n   const char *old_init_file;\n   char *e;\n@@ -1211,8 +1418,7 @@ static const struct {\n /* Handle a parser directive.  STATEMENT is the line of the directive\n    without any leading `$'. */\n static int\n-handle_parser_directive (statement)\n-     char *statement;\n+handle_parser_directive (char *statement)\n {\n   register int i;\n   char *directive, *args;\n@@ -1249,9 +1455,7 @@ handle_parser_directive (statement)\n /* Start at STRING[START] and look for DELIM.  Return I where STRING[I] ==\n    DELIM or STRING[I] == 0.  DELIM is usually a double quote. */\n static int\n-_rl_skip_to_delim (string, start, delim)\n-     char *string;\n-     int start, delim;\n+_rl_skip_to_delim (char *string, int start, int delim)\n {\n   int i, c, passc;\n \n@@ -1283,8 +1487,7 @@ _rl_skip_to_delim (string, start, delim)\n    a variable binding command looks like: set variable value.\n    A new-style keybinding looks like \"\\C-x\\C-x\": exchange-point-and-mark. */\n int\n-rl_parse_and_bind (string)\n-     char *string;\n+rl_parse_and_bind (char *string)\n {\n   char *funname, *kname;\n   register int c, i;\n@@ -1328,6 +1531,12 @@ rl_parse_and_bind (string)\n   /* Advance to the colon (:) or whitespace which separates the two objects. */\n   for (; (c = string[i]) && c != ':' && c != ' ' && c != '\\t'; i++ );\n \n+  if (i == 0)\n+    {\n+      _rl_init_file_error (\"`%s': invalid key binding: missing key sequence\", string);\n+      return 1;\n+    }\n+\n   equivalency = (c == ':' && string[i + 1] == '=');\n \n   foundsep = c != 0;\n@@ -1406,6 +1615,11 @@ rl_parse_and_bind (string)\n       i = _rl_skip_to_delim (string, i+1, *funname);\n       if (string[i])\n \ti++;\n+      else\n+\t{\n+\t  _rl_init_file_error (\"`%s': missing closing quote for macro\", funname);\n+\t  return 1;\n+\t}\n     }\n \n   /* Advance to the end of the string.  */\n@@ -1583,8 +1797,7 @@ static const struct {\n };\n \n static int\n-find_boolean_var (name)\n-     const char *name;\n+find_boolean_var (const char *name)\n {\n   register int i;\n \n@@ -1594,12 +1807,17 @@ find_boolean_var (name)\n   return -1;\n }\n \n+static const char *\n+boolean_varname (int i)\n+{\n+  return ((i >= 0) ? boolean_varlist[i].name : (char *)NULL);\n+}  \n+\n /* Hooks for handling special boolean variables, where a\n    function needs to be called or another variable needs\n    to be changed when they're changed. */\n static void\n-hack_special_boolean_var (i)\n-     int i;\n+hack_special_boolean_var (int i)\n {\n   const char *name;\n \n@@ -1668,8 +1886,7 @@ static const struct {\n };\n \n static int\n-find_string_var (name)\n-     const char *name;\n+find_string_var (const char *name)\n {\n   register int i;\n \n@@ -1679,21 +1896,25 @@ find_string_var (name)\n   return -1;\n }\n \n+static const char *\n+string_varname (int i)\n+{\n+  return ((i >= 0) ? string_varlist[i].name : (char *)NULL);\n+}  \n+\n /* A boolean value that can appear in a `set variable' command is true if\n    the value is null or empty, `on' (case-insensitive), or \"1\".  Any other\n    values result in 0 (false). */\n static int\n-bool_to_int (value)\n-     const char *value;\n+bool_to_int (const char *value)\n {\n   return (value == 0 || *value == '\\0' ||\n \t\t(_rl_stricmp (value, \"on\") == 0) ||\n \t\t(value[0] == '1' && value[1] == '\\0'));\n }\n \n char *\n-rl_variable_value (name)\n-     const char *name;\n+rl_variable_value (const char *name)\n {\n   register int i;\n \n@@ -1711,8 +1932,7 @@ rl_variable_value (name)\n }\n \n int\n-rl_variable_bind (name, value)\n-     const char *name, *value;\n+rl_variable_bind (const char *name, const char *value)\n {\n   register int i;\n   int\tv;\n@@ -1743,8 +1963,7 @@ rl_variable_bind (name, value)\n }\n \n static int\n-sv_editmode (value)\n-     const char *value;\n+sv_editmode (const char *value)\n {\n   if (_rl_strnicmp (value, \"vi\", 2) == 0)\n     {\n@@ -1764,8 +1983,7 @@ sv_editmode (value)\n }\n \n static int\n-sv_combegin (value)\n-     const char *value;\n+sv_combegin (const char *value)\n {\n   if (value && *value)\n     {\n@@ -1777,8 +1995,7 @@ sv_combegin (value)\n }\n \n static int\n-sv_dispprefix (value)\n-     const char *value;\n+sv_dispprefix (const char *value)\n {\n   int nval = 0;\n \n@@ -1793,8 +2010,7 @@ sv_dispprefix (value)\n }\n \n static int\n-sv_compquery (value)\n-     const char *value;\n+sv_compquery (const char *value)\n {\n   int nval = 100;\n \n@@ -1809,8 +2025,7 @@ sv_compquery (value)\n }\n \n static int\n-sv_compwidth (value)\n-     const char *value;\n+sv_compwidth (const char *value)\n {\n   int nval = -1;\n \n@@ -1822,8 +2037,7 @@ sv_compwidth (value)\n }\n \n static int\n-sv_histsize (value)\n-     const char *value;\n+sv_histsize (const char *value)\n {\n   int nval;\n \n@@ -1842,8 +2056,7 @@ sv_histsize (value)\n }\n \n static int\n-sv_keymap (value)\n-     const char *value;\n+sv_keymap (const char *value)\n {\n   Keymap kmap;\n \n@@ -1857,8 +2070,7 @@ sv_keymap (value)\n }\n \n static int\n-sv_seqtimeout (value)\n-     const char *value;\n+sv_seqtimeout (const char *value)\n {\n   int nval;\n \n@@ -1874,8 +2086,7 @@ sv_seqtimeout (value)\n }\n \n static int\n-sv_bell_style (value)\n-     const char *value;\n+sv_bell_style (const char *value)\n {\n   if (value == 0 || *value == '\\0')\n     _rl_bell_preference = AUDIBLE_BELL;\n@@ -1891,8 +2102,7 @@ sv_bell_style (value)\n }\n \n static int\n-sv_isrchterm (value)\n-     const char *value;\n+sv_isrchterm (const char *value)\n {\n   int beg, end, delim;\n   char *v;\n@@ -1929,8 +2139,7 @@ sv_isrchterm (value)\n extern char *_rl_emacs_mode_str;\n \n static int\n-sv_emacs_modestr (value)\n-     const char *value;\n+sv_emacs_modestr (const char *value)\n {\n   if (value && *value)\n     {\n@@ -1958,8 +2167,7 @@ sv_emacs_modestr (value)\n }\n \n static int\n-sv_viins_modestr (value)\n-     const char *value;\n+sv_viins_modestr (const char *value)\n {\n   if (value && *value)\n     {\n@@ -1987,8 +2195,7 @@ sv_viins_modestr (value)\n }\n \n static int\n-sv_vicmd_modestr (value)\n-     const char *value;\n+sv_vicmd_modestr (const char *value)\n {\n   if (value && *value)\n     {\n@@ -2039,8 +2246,7 @@ static const assoc_list name_key_alist[] = {\n };\n \n static int\n-glean_key_from_name (name)\n-     char *name;\n+glean_key_from_name (char *name)\n {\n   register int i;\n \n@@ -2052,10 +2258,12 @@ glean_key_from_name (name)\n }\n \n /* Auxiliary functions to manage keymaps. */\n-static const struct {\n-  const char * const name;\n+struct name_and_keymap {\n+  char *name;\n   Keymap map;\n-} keymap_names[] = {\n+};\n+\n+static struct name_and_keymap builtin_keymap_names[] = {\n   { \"emacs\", emacs_standard_keymap },\n   { \"emacs-standard\", emacs_standard_keymap },\n   { \"emacs-meta\", emacs_meta_keymap },\n@@ -2069,45 +2277,116 @@ static const struct {\n   { (char *)0x0, (Keymap)0x0 }\n };\n \n-Keymap\n-rl_get_keymap_by_name (name)\n-     const char *name;\n+/* -1 for NULL entry */\n+#define NUM_BUILTIN_KEYMAPS (sizeof (builtin_keymap_names) / sizeof (builtin_keymap_names[0]) - 1)\n+\n+static struct name_and_keymap *keymap_names = builtin_keymap_names;\n+\n+static int\n+_rl_get_keymap_by_name (const char *name)\n {\n   register int i;\n \n   for (i = 0; keymap_names[i].name; i++)\n     if (_rl_stricmp (name, keymap_names[i].name) == 0)\n-      return (keymap_names[i].map);\n-  return ((Keymap) NULL);\n+      return (i);\n+  return -1;\n }\n \n-char *\n-rl_get_keymap_name (map)\n-     Keymap map;\n+Keymap\n+rl_get_keymap_by_name (const char *name)\n+{\n+  int i;\n+\n+  i = _rl_get_keymap_by_name (name);\n+  return ((i >= 0) ? keymap_names[i].map : (Keymap) NULL);\n+}\n+\n+static int\n+_rl_get_keymap_by_map (Keymap map)\n {\n   register int i;\n+\n   for (i = 0; keymap_names[i].name; i++)\n     if (map == keymap_names[i].map)\n-      return ((char *)keymap_names[i].name);\n-  return ((char *)NULL);\n+      return (i);\n+  return -1;\n }\n-  \n+\n+char *\n+rl_get_keymap_name (Keymap map)\n+{\n+  int i;\n+\n+  i = _rl_get_keymap_by_map (map);\n+  return ((i >= 0) ? keymap_names[i].name : (char *)NULL);\n+}\n+\n+int\n+rl_set_keymap_name (const char *name, Keymap map)\n+{\n+  int i, ni, mi;\n+\n+  /* First check whether or not we're trying to rename a builtin keymap */\n+  mi = _rl_get_keymap_by_map (map);\n+  if (mi >= 0 && mi < NUM_BUILTIN_KEYMAPS)\n+    return -1;\n+\n+  /* Then reject attempts to set one of the builtin names to a new map */\n+  ni = _rl_get_keymap_by_name (name);\n+  if (ni >= 0 && ni < NUM_BUILTIN_KEYMAPS)\n+    return -1;\n+\n+  /* Renaming a keymap we already added */\n+  if (mi >= 0)\t/* XXX - could be >= NUM_BUILTIN_KEYMAPS */\n+    {\n+      xfree (keymap_names[mi].name);\n+      keymap_names[mi].name = savestring (name);\n+      return mi;\n+    }\n+\n+  /* Associating new keymap with existing name */\n+  if (ni >= 0)\n+    {\n+      keymap_names[ni].map = map;\n+      return ni;\n+    }\n+\n+  for (i = 0; keymap_names[i].name; i++)\n+    ;\n+\n+  if (keymap_names == builtin_keymap_names)\n+    {\n+      keymap_names = xmalloc ((i + 2) * sizeof (struct name_and_keymap));\n+      memcpy (keymap_names, builtin_keymap_names, i * sizeof (struct name_and_keymap));\n+    }\n+  else\n+    keymap_names = xrealloc (keymap_names, (i + 2) * sizeof (struct name_and_keymap));\n+\n+  keymap_names[i].name = savestring (name);\n+  keymap_names[i].map = map;\n+\n+  keymap_names[i+1].name = NULL;\n+  keymap_names[i+1].map = NULL;\n+\n+  return i;\n+}\n+\n void\n-rl_set_keymap (map)\n-     Keymap map;\n+rl_set_keymap (Keymap map)\n {\n   if (map)\n     _rl_keymap = map;\n }\n \n Keymap\n-rl_get_keymap ()\n+rl_get_keymap (void)\n {\n   return (_rl_keymap);\n }\n \n void\n-rl_set_keymap_from_edit_mode ()\n+rl_set_keymap_from_edit_mode (void)\n {\n   if (rl_editing_mode == emacs_mode)\n     _rl_keymap = emacs_standard_keymap;\n@@ -2118,7 +2397,7 @@ rl_set_keymap_from_edit_mode ()\n }\n \n char *\n-rl_get_keymap_name_from_edit_mode ()\n+rl_get_keymap_name_from_edit_mode (void)\n {\n   if (rl_editing_mode == emacs_mode)\n     return \"emacs\";\n@@ -2143,7 +2422,7 @@ rl_get_keymap_name_from_edit_mode ()\n \n /* Print the names of functions known to Readline. */\n void\n-rl_list_funmap_names ()\n+rl_list_funmap_names (void)\n {\n   register int i;\n   const char **funmap_names;\n@@ -2160,8 +2439,7 @@ rl_list_funmap_names ()\n }\n \n static char *\n-_rl_get_keyname (key)\n-     int key;\n+_rl_get_keyname (int key)\n {\n   char *keyname;\n   int i, c;\n@@ -2236,9 +2514,7 @@ _rl_get_keyname (key)\n /* Return a NULL terminated array of strings which represent the key\n    sequences that are used to invoke FUNCTION in MAP. */\n char **\n-rl_invoking_keyseqs_in_map (function, map)\n-     rl_command_func_t *function;\n-     Keymap map;\n+rl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)\n {\n   register int key;\n   char **result;\n@@ -2345,8 +2621,7 @@ rl_invoking_keyseqs_in_map (function, map)\n /* Return a NULL terminated array of strings which represent the key\n    sequences that can be used to invoke FUNCTION using the current keymap. */\n char **\n-rl_invoking_keyseqs (function)\n-     rl_command_func_t *function;\n+rl_invoking_keyseqs (rl_command_func_t *function)\n {\n   return (rl_invoking_keyseqs_in_map (function, _rl_keymap));\n }\n@@ -2355,8 +2630,7 @@ rl_invoking_keyseqs (function)\n    PRINT_READABLY is non-zero, then print the output in such a way\n    that it can be read back in. */\n void\n-rl_function_dumper (print_readably)\n-     int print_readably;\n+rl_function_dumper (int print_readably)\n {\n   register int i;\n   const char **names;\n@@ -2427,8 +2701,7 @@ rl_function_dumper (print_readably)\n    rl_outstream.  If an explicit argument is given, then print\n    the output in such a way that it can be read back in. */\n int\n-rl_dump_functions (count, key)\n-     int count, key;\n+rl_dump_functions (int count, int key)\n {\n   if (rl_dispatching)\n     fprintf (rl_outstream, \"\\r\\n\");\n@@ -2438,10 +2711,7 @@ rl_dump_functions (count, key)\n }\n \n static void\n-_rl_macro_dumper_internal (print_readably, map, prefix)\n-     int print_readably;\n-     Keymap map;\n-     char *prefix;\n+_rl_macro_dumper_internal (int print_readably, Keymap map, char *prefix)\n {\n   register int key;\n   char *keyname, *out;\n@@ -2500,15 +2770,13 @@ _rl_macro_dumper_internal (print_readably, map, prefix)\n }\n \n void\n-rl_macro_dumper (print_readably)\n-     int print_readably;\n+rl_macro_dumper (int print_readably)\n {\n   _rl_macro_dumper_internal (print_readably, _rl_keymap, (char *)NULL);\n }\n \n int\n-rl_dump_macros (count, key)\n-     int count, key;\n+rl_dump_macros (int count, int key)\n {\n   if (rl_dispatching)\n     fprintf (rl_outstream, \"\\r\\n\");\n@@ -2518,8 +2786,7 @@ rl_dump_macros (count, key)\n }\n \n static char *\n-_rl_get_string_variable_value (name)\n-     const char *name;\n+_rl_get_string_variable_value (const char *name)\n {\n   static char numbuf[32];\n   char *ret;\n@@ -2599,8 +2866,7 @@ _rl_get_string_variable_value (name)\n }\n \n void\n-rl_variable_dumper (print_readably)\n-     int print_readably;\n+rl_variable_dumper (int print_readably)\n {\n   int i;\n   char *v;\n@@ -2631,8 +2897,7 @@ rl_variable_dumper (print_readably)\n    rl_outstream.  If an explicit argument is given, then print\n    the output in such a way that it can be read back in. */\n int\n-rl_dump_variables (count, key)\n-     int count, key;\n+rl_dump_variables (int count, int key)\n {\n   if (rl_dispatching)\n     fprintf (rl_outstream, \"\\r\\n\");\n@@ -2643,9 +2908,7 @@ rl_dump_variables (count, key)\n \n /* Return non-zero if any members of ARRAY are a substring in STRING. */\n static int\n-substring_member_of_array (string, array)\n-     const char *string;\n-     const char * const *array;\n+substring_member_of_array (const char *string, const char * const *array)\n {\n   while (*array)\n     {"
    },
    {
      "sha": "a466cf9b6ef1a5712a00f8837e86c23c55165e34",
      "filename": "readline/callback.c",
      "status": "modified",
      "additions": 9,
      "deletions": 13,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/callback.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/callback.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/callback.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* callback.c -- functions to use readline as an X `callback' mechanism. */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -60,7 +60,7 @@ int rl_persistent_signal_handlers = 0;\n \n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n-/*\t\t\tCallback Readline Functions\t\t */\n+/*\t\t\tCallback Readline Functions\t\t    */\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n@@ -80,7 +80,7 @@ static int in_handler;\t\t/* terminal_prepped and signals set? */\n \n /* Make sure the terminal is set up, initialize readline, and prompt. */\n static void\n-_rl_callback_newline ()\n+_rl_callback_newline (void)\n {\n   rl_initialize ();\n \n@@ -103,9 +103,7 @@ _rl_callback_newline ()\n \n /* Install a readline handler, set up the terminal, and issue the prompt. */\n void\n-rl_callback_handler_install (prompt, linefunc)\n-     const char *prompt;\n-     rl_vcpfunc_t *linefunc;\n+rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *linefunc)\n {\n   rl_set_prompt (prompt);\n   RL_SETSTATE (RL_STATE_CALLBACK);\n@@ -126,7 +124,7 @@ rl_callback_handler_install (prompt, linefunc)\n \n /* Read one character, and dispatch to the handler if it ends the line. */\n void\n-rl_callback_read_char ()\n+rl_callback_read_char (void)\n {\n   char *line;\n   int eof, jcode;\n@@ -299,7 +297,7 @@ rl_callback_read_char ()\n \n /* Remove the handler, and make sure the terminal is in its normal state. */\n void\n-rl_callback_handler_remove ()\n+rl_callback_handler_remove (void)\n {\n   rl_linefunc = NULL;\n   RL_UNSETSTATE (RL_STATE_CALLBACK);\n@@ -316,8 +314,7 @@ rl_callback_handler_remove ()\n }\n \n _rl_callback_generic_arg *\n-_rl_callback_data_alloc (count)\n-     int count;\n+_rl_callback_data_alloc (int count)\n {\n   _rl_callback_generic_arg *arg;\n \n@@ -330,15 +327,14 @@ _rl_callback_data_alloc (count)\n }\n \n void\n-_rl_callback_data_dispose (arg)\n-     _rl_callback_generic_arg *arg;\n+_rl_callback_data_dispose (_rl_callback_generic_arg *arg)\n {\n   xfree (arg);\n }\n \n /* Make sure that this agrees with cases in rl_callback_read_char */\n void\n-rl_callback_sigcleanup ()\n+rl_callback_sigcleanup (void)\n {\n   if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n     return;"
    },
    {
      "sha": "53758e0e7741401b3810d869af97e34b392be165",
      "filename": "readline/colors.c",
      "status": "modified",
      "additions": 19,
      "deletions": 4,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/colors.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/colors.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/colors.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -2,7 +2,7 @@\n \n    Modified by Chet Ramey for Readline.\n \n-   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2015\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2015, 2017\n    Free Software Foundation, Inc.\n \n    This program is free software: you can redistribute it and/or modify\n@@ -37,6 +37,10 @@\n #include \"posixstat.h\" // stat related macros (S_ISREG, ...)\n #include <fcntl.h> // S_ISUID\n \n+#ifndef S_ISDIR\n+#  define\tS_ISDIR(m)\t(((m) & S_IFMT) == S_IFDIR)\n+#endif\n+\n // strlen()\n #if defined (HAVE_STRING_H)\n #  include <string.h>\n@@ -66,7 +70,8 @@ COLOR_EXT_TYPE *_rl_color_ext_list = 0;\n \n /* Output a color indicator (which may contain nulls).  */\n void\n-_rl_put_indicator (const struct bin_str *ind) {\n+_rl_put_indicator (const struct bin_str *ind)\n+{\n   fwrite (ind->string, ind->len, 1, rl_outstream);\n }\n \n@@ -183,11 +188,17 @@ _rl_print_color_indicator (const char *f)\n         {\n           colored_filetype = C_FILE;\n \n+#if defined (S_ISUID)\n           if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n             colored_filetype = C_SETUID;\n-          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n+          else\n+#endif\n+#if defined (S_ISGID)\n+          if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n             colored_filetype = C_SETGID;\n-          else if (is_colored (C_CAP) && 0) //f->has_capability)\n+          else\n+#endif\n+          if (is_colored (C_CAP) && 0) //f->has_capability)\n             colored_filetype = C_CAP;\n           else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n             colored_filetype = C_EXEC;\n@@ -211,12 +222,16 @@ _rl_print_color_indicator (const char *f)\n             colored_filetype = C_STICKY;\n #endif\n         }\n+#if defined (S_ISLNK)\n       else if (S_ISLNK (mode))\n         colored_filetype = C_LINK;\n+#endif\n       else if (S_ISFIFO (mode))\n         colored_filetype = C_FIFO;\n+#if defined (S_ISSOCK)\n       else if (S_ISSOCK (mode))\n         colored_filetype = C_SOCK;\n+#endif\n       else if (S_ISBLK (mode))\n         colored_filetype = C_BLK;\n       else if (S_ISCHR (mode))"
    },
    {
      "sha": "3ade3629aef440a4d8bec22cc1419e49704c4eef",
      "filename": "readline/compat.c",
      "status": "modified",
      "additions": 11,
      "deletions": 18,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/compat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/compat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/compat.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* compat.c -- backwards compatibility functions. */\n \n-/* Copyright (C) 2000-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2000-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -46,68 +46,61 @@ extern char *rl_filename_completion_function PARAMS((const char *, int));\n /* Provide backwards-compatible entry points for old function names. */\n \n void\n-free_undo_list ()\n+free_undo_list (void)\n {\n   rl_free_undo_list ();\n }\n \n int\n-maybe_replace_line ()\n+maybe_replace_line (void)\n {\n   return rl_maybe_replace_line ();\n }\n \n int\n-maybe_save_line ()\n+maybe_save_line (void)\n {\n   return rl_maybe_save_line ();\n }\n \n int\n-maybe_unsave_line ()\n+maybe_unsave_line (void)\n {\n   return rl_maybe_unsave_line ();\n }\n \n int\n-ding ()\n+ding (void)\n {\n   return rl_ding ();\n }\n \n int\n-crlf ()\n+crlf (void)\n {\n   return rl_crlf ();\n }\n \n int\n-alphabetic (c)\n-     int c;\n+alphabetic (int c)\n {\n   return rl_alphabetic (c);\n }\n \n char **\n-completion_matches (s, f)\n-     const char *s;\n-     rl_compentry_func_t *f;\n+completion_matches (const char *s, rl_compentry_func_t *f)\n {\n   return rl_completion_matches (s, f);\n }\n \n char *\n-username_completion_function (s, i)\n-     const char *s;\n-     int i;\n+username_completion_function (const char *s, int i)\n {\n   return rl_username_completion_function (s, i);\n }\n \n char *\n-filename_completion_function (s, i)\n-     const char *s;\n-     int i;\n+filename_completion_function (const char *s, int i)\n {\n   return rl_filename_completion_function (s, i);\n }"
    },
    {
      "sha": "adce0d69ac1d9bbf57a335c1fb0c6df36d9320c2",
      "filename": "readline/complete.c",
      "status": "modified",
      "additions": 69,
      "deletions": 118,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/complete.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/complete.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/complete.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* complete.c -- filename completion for readline. */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -198,15 +198,6 @@ int _rl_completion_prefix_display_length = 0;\n    matches.  If < 0 or > _rl_screenwidth, it is ignored. */\n int _rl_completion_columns = -1;\n \n-/* Global variables available to applications using readline. */\n-\n-#if defined (VISIBLE_STATS)\n-/* Non-zero means add an additional character to each filename displayed\n-   during listing completion iff rl_filename_completion_desired which helps\n-   to indicate the type of file being listed. */\n-int rl_visible_stats = 0;\n-#endif /* VISIBLE_STATS */\n-\n #if defined (COLOR_SUPPORT)\n /* Non-zero means to use colors to indicate file type when listing possible\n    completions.  The colors used are taken from $LS_COLORS, if set. */\n@@ -227,6 +218,15 @@ int _rl_skip_completed_text = 0;\n    cycle of possible completions instead of the last. */\n int _rl_menu_complete_prefix_first = 0;\n \n+/* Global variables available to applications using readline. */\n+\n+#if defined (VISIBLE_STATS)\n+/* Non-zero means add an additional character to each filename displayed\n+   during listing completion iff rl_filename_completion_desired which helps\n+   to indicate the type of file being listed. */\n+int rl_visible_stats = 0;\n+#endif /* VISIBLE_STATS */\n+\n /* If non-zero, then this is the address of a function to call when\n    completing on a directory name.  The function is called with\n    the address of a string (the current directory name) as an arg. */\n@@ -422,8 +422,7 @@ static int _rl_complete_display_matches_interrupt = 0;\n    that does the initial simple matching selection algorithm (see\n    rl_completion_matches ()).  The default is to do filename completion. */\n int\n-rl_complete (ignore, invoking_key)\n-     int ignore, invoking_key;\n+rl_complete (int ignore, int invoking_key)\n {\n   rl_completion_invoking_key = invoking_key;\n \n@@ -441,16 +440,14 @@ rl_complete (ignore, invoking_key)\n \n /* List the possible completions.  See description of rl_complete (). */\n int\n-rl_possible_completions (ignore, invoking_key)\n-     int ignore, invoking_key;\n+rl_possible_completions (int ignore, int invoking_key)\n {\n   rl_completion_invoking_key = invoking_key;\n   return (rl_complete_internal ('?'));\n }\n \n int\n-rl_insert_completions (ignore, invoking_key)\n-     int ignore, invoking_key;\n+rl_insert_completions (int ignore, int invoking_key)\n {\n   rl_completion_invoking_key = invoking_key;\n   return (rl_complete_internal ('*'));\n@@ -462,8 +459,7 @@ rl_insert_completions (ignore, invoking_key)\n    an application-specific completion function to honor the\n    show-all-if-ambiguous readline variable. */\n int\n-rl_completion_mode (cfunc)\n-     rl_command_func_t *cfunc;\n+rl_completion_mode (rl_command_func_t *cfunc)\n {\n   if (rl_last_func == cfunc && !completion_changed_buffer)\n     return '?';\n@@ -483,16 +479,14 @@ rl_completion_mode (cfunc)\n \n /* Reset readline state on a signal or other event. */\n void\n-_rl_reset_completion_state ()\n+_rl_reset_completion_state (void)\n {\n   rl_completion_found_quote = 0;\n   rl_completion_quote_character = 0;\n }\n \n static void\n-_rl_complete_sigcleanup (sig, ptr)\n-     int sig;\n-     void *ptr;\n+_rl_complete_sigcleanup (int sig, void *ptr)\n {\n   if (sig == SIGINT)\t/* XXX - for now */\n     {\n@@ -504,8 +498,7 @@ _rl_complete_sigcleanup (sig, ptr)\n /* Set default values for readline word completion.  These are the variables\n    that application completion functions can change or inspect. */\n static void\n-set_completion_defaults (what_to_do)\n-     int what_to_do;\n+set_completion_defaults (int what_to_do)\n {\n   /* Only the completion entry function can change these. */\n   rl_filename_completion_desired = 0;\n@@ -523,8 +516,7 @@ set_completion_defaults (what_to_do)\n \n /* The user must press \"y\" or \"n\". Non-zero return means \"y\" pressed. */\n static int\n-get_y_or_n (for_pager)\n-     int for_pager;\n+get_y_or_n (int for_pager)\n {\n   int c;\n \n@@ -557,8 +549,7 @@ get_y_or_n (for_pager)\n }\n \n static int\n-_rl_internal_pager (lines)\n-     int lines;\n+_rl_internal_pager (int lines)\n {\n   int i;\n \n@@ -575,8 +566,7 @@ _rl_internal_pager (lines)\n }\n \n static int\n-path_isdir (filename)\n-     const char *filename;\n+path_isdir (const char *filename)\n {\n   struct stat finfo;\n \n@@ -593,8 +583,7 @@ path_isdir (filename)\n      `%' for character special devices\n      `#' for block special devices */\n static int\n-stat_char (filename)\n-     char *filename;\n+stat_char (char *filename)\n {\n   struct stat finfo;\n   int character, r;\n@@ -625,7 +614,10 @@ stat_char (filename)\n #endif\n \n   if (r == -1)\n-    return (0);\n+    {\n+      xfree (f);\n+      return (0);\n+    }\n \n   character = 0;\n   if (S_ISDIR (finfo.st_mode))\n@@ -675,29 +667,28 @@ stat_char (filename)\n \n #if defined (COLOR_SUPPORT)\n static int\n-colored_stat_start (filename)\n-     const char *filename;\n+colored_stat_start (const char *filename)\n {\n   _rl_set_normal_color ();\n   return (_rl_print_color_indicator (filename));\n }\n \n static void\n-colored_stat_end ()\n+colored_stat_end (void)\n {\n   _rl_prep_non_filename_text ();\n   _rl_put_indicator (&_rl_color_indicator[C_CLR_TO_EOL]);\n }\n \n static int\n-colored_prefix_start ()\n+colored_prefix_start (void)\n {\n   _rl_set_normal_color ();\n   return (_rl_print_prefix_color ());\n }\n \n static void\n-colored_prefix_end ()\n+colored_prefix_end (void)\n {\n   colored_stat_end ();\t\t/* for now */\n }\n@@ -712,8 +703,7 @@ colored_prefix_end ()\n    for the previous slash and return the portion following that.  If\n    there's no previous slash, we just return what we were passed. */\n static char *\n-printable_part (pathname)\n-      char *pathname;\n+printable_part (char *pathname)\n {\n   char *temp, *x;\n \n@@ -747,8 +737,7 @@ printable_part (pathname)\n \n /* Compute width of STRING when displayed on screen by print_filename */\n static int\n-fnwidth (string)\n-     const char *string;\n+fnwidth (const char *string)\n {\n   int width, pos;\n #if defined (HANDLE_MULTIBYTE)\n@@ -800,10 +789,7 @@ fnwidth (string)\n #define ELLIPSIS_LEN\t3\n \n static int\n-fnprint (to_print, prefix_bytes, real_pathname)\n-     const char *to_print;\n-     int prefix_bytes;\n-     const char *real_pathname;\n+fnprint (const char *to_print, int prefix_bytes, const char *real_pathname)\n {\n   int printed_len, w;\n   const char *s;\n@@ -818,6 +804,8 @@ fnprint (to_print, prefix_bytes, real_pathname)\n   print_len = strlen (to_print);\n   end = to_print + print_len + 1;\n   memset (&ps, 0, sizeof (mbstate_t));\n+#else\n+  print_len = strlen (to_print);\n #endif\n \n   printed_len = common_prefix_len = 0;\n@@ -929,9 +917,7 @@ fnprint (to_print, prefix_bytes, real_pathname)\n    filenames.  Return the number of characters we output. */\n \n static int\n-print_filename (to_print, full_pathname, prefix_bytes)\n-     char *to_print, *full_pathname;\n-     int prefix_bytes;\n+print_filename (char *to_print, char *full_pathname, int prefix_bytes)\n {\n   int printed_len, extension_char, slen, tlen;\n   char *s, c, *new_full_pathname, *dn;\n@@ -988,7 +974,6 @@ print_filename (to_print, full_pathname, prefix_bytes)\n \t    slen--;\n \t  else\n \t    new_full_pathname[slen] = '/';\n-\t  new_full_pathname[slen] = '/';\n \t  strcpy (new_full_pathname + slen + 1, to_print);\n \n #if defined (VISIBLE_STATS)\n@@ -1049,10 +1034,7 @@ print_filename (to_print, full_pathname, prefix_bytes)\n }\n \n static char *\n-rl_quote_filename (s, rtype, qcp)\n-     char *s;\n-     int rtype;\n-     char *qcp;\n+rl_quote_filename (char *s, int rtype, char *qcp)\n {\n   char *r;\n \n@@ -1080,8 +1062,7 @@ rl_quote_filename (s, rtype, qcp)\n    the value of the delimiter character that caused a word break. */\n \n char\n-_rl_find_completion_word (fp, dp)\n-     int *fp, *dp;\n+_rl_find_completion_word (int *fp, int *dp)\n {\n   int scan, end, found_quote, delimiter, pass_next, isbrk;\n   char quote_char, *brkchars;\n@@ -1213,11 +1194,7 @@ _rl_find_completion_word (fp, dp)\n }\n \n static char **\n-gen_completion_matches (text, start, end, our_func, found_quote, quote_char)\n-     char *text;\n-     int start, end;\n-     rl_compentry_func_t *our_func;\n-     int found_quote, quote_char;\n+gen_completion_matches (char *text, int start, int end, rl_compentry_func_t *our_func, int found_quote, int quote_char)\n {\n   char **matches;\n \n@@ -1261,8 +1238,7 @@ gen_completion_matches (text, start, end, our_func, found_quote, quote_char)\n /* Filter out duplicates in MATCHES.  This frees up the strings in\n    MATCHES. */\n static char **\n-remove_duplicate_matches (matches)\n-     char **matches;\n+remove_duplicate_matches (char **matches)\n {\n   char *lowest_common;\n   int i, j, newlen;\n@@ -1322,10 +1298,7 @@ remove_duplicate_matches (matches)\n /* Find the common prefix of the list of matches, and put it into\n    matches[0]. */\n static int\n-compute_lcd_of_matches (match_list, matches, text)\n-     char **match_list;\n-     int matches;\n-     const char *text;\n+compute_lcd_of_matches (char **match_list, int matches, const char *text)\n {\n   register int i, c1, c2, si;\n   int low;\t\t/* Count of max-matched characters. */\n@@ -1451,7 +1424,8 @@ compute_lcd_of_matches (match_list, matches, text)\n \t    }\n \n \t  /* sort the list to get consistent answers. */\n-\t  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);\n+\t  if (rl_sort_completion_matches)\n+\t    qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);\n \n \t  si = strlen (text);\n \t  lx = (si <= low) ? si : low;\t/* check shorter of text and matches */\n@@ -1481,9 +1455,7 @@ compute_lcd_of_matches (match_list, matches, text)\n }\n \n static int\n-postprocess_matches (matchesp, matching_filenames)\n-     char ***matchesp;\n-     int matching_filenames;\n+postprocess_matches (char ***matchesp, int matching_filenames)\n {\n   char *t, **matches, **temp_matches;\n   int nmatch, i;\n@@ -1537,7 +1509,7 @@ postprocess_matches (matchesp, matching_filenames)\n }\n \n static int\n-complete_get_screenwidth ()\n+complete_get_screenwidth (void)\n {\n   int cols;\n   char *envcols;\n@@ -1558,9 +1530,7 @@ complete_get_screenwidth ()\n    of strings, in argv format, LEN is the number of strings in MATCHES,\n    and MAX is the length of the longest string in MATCHES. */\n void\n-rl_display_match_list (matches, len, max)\n-     char **matches;\n-     int len, max;\n+rl_display_match_list (char **matches, int len, int max)\n {\n   int count, limit, printed_len, lines, cols;\n   int i, j, k, l, common_length, sind;\n@@ -1717,8 +1687,7 @@ rl_display_match_list (matches, len, max)\n    and ask the user if he wants to see the list if there are more matches\n    than RL_COMPLETION_QUERY_ITEMS. */\n static void\n-display_matches (matches)\n-     char **matches;\n+display_matches (char **matches)\n {\n   int len, max, i;\n   char *temp;\n@@ -1784,11 +1753,9 @@ display_matches (matches)\n   rl_display_fixed = 1;\n }\n \n+/* qc == pointer to quoting character, if any */\n static char *\n-make_quoted_replacement (match, mtype, qc)\n-     char *match;\n-     int mtype;\n-     char *qc;\t/* Pointer to quoting character, if any */\n+make_quoted_replacement (char *match, int mtype, char *qc)\n {\n   int should_quote, do_replace;\n   char *replacement;\n@@ -1830,10 +1797,7 @@ make_quoted_replacement (match, mtype, qc)\n }\n \n static void\n-insert_match (match, start, mtype, qc)\n-     char *match;\n-     int start, mtype;\n-     char *qc;\n+insert_match (char *match, int start, int mtype, char *qc)\n {\n   char *replacement, *r;\n   char oqc;\n@@ -1890,9 +1854,7 @@ insert_match (match, start, mtype, qc)\n    value of _rl_complete_mark_symlink_dirs, but may be modified by an\n    application's completion function). */\n static int\n-append_to_match (text, delimiter, quote_char, nontrivial_match)\n-     char *text;\n-     int delimiter, quote_char, nontrivial_match;\n+append_to_match (char *text, int delimiter, int quote_char, int nontrivial_match)\n {\n   char temp_string[4], *filename, *fn;\n   int temp_string_index, s;\n@@ -1959,10 +1921,7 @@ append_to_match (text, delimiter, quote_char, nontrivial_match)\n }\n \n static void\n-insert_all_matches (matches, point, qc)\n-     char **matches;\n-     int point;\n-     char *qc;\n+insert_all_matches (char **matches, int point, char *qc)\n {\n   int i;\n   char *rp;\n@@ -1998,8 +1957,7 @@ insert_all_matches (matches, point, qc)\n }\n \n void\n-_rl_free_match_list (matches)\n-     char **matches;\n+_rl_free_match_list (char **matches)\n {\n   register int i;\n \n@@ -2021,17 +1979,14 @@ _rl_free_match_list (matches)\n    `@' means to do standard completion, and list all possible completions if\n    there is more than one and partial completion is not possible. */\n int\n-rl_complete_internal (what_to_do)\n-     int what_to_do;\n+rl_complete_internal (int what_to_do)\n {\n   char **matches;\n   rl_compentry_func_t *our_func;\n   int start, end, delimiter, found_quote, i, nontrivial_lcd;\n   char *text, *saved_line_buffer;\n   char quote_char;\n-#if 1\n   int tlen, mlen;\n-#endif\n \n   RL_SETSTATE(RL_STATE_COMPLETING);\n \n@@ -2206,9 +2161,7 @@ rl_complete_internal (what_to_do)\n      when there are no more matches.\n  */\n char **\n-rl_completion_matches (text, entry_function)\n-     const char *text;\n-     rl_compentry_func_t *entry_function;\n+rl_completion_matches (const char *text, rl_compentry_func_t *entry_function)\n {\n   register int i;\n \n@@ -2276,9 +2229,7 @@ rl_completion_matches (text, entry_function)\n    TEXT contains a partial username preceded by a random\n    character (usually `~').  */\n char *\n-rl_username_completion_function (text, state)\n-     const char *text;\n-     int state;\n+rl_username_completion_function (const char *text, int state)\n {\n #if defined (__WIN32__) || defined (__OPENNT)\n   return (char *)NULL;\n@@ -2340,11 +2291,7 @@ rl_username_completion_function (text, state)\n    _rl_completion_case_map is set, make `-' and `_' equivalent.  CONVFN is\n    the possibly-converted directory entry; FILENAME is what the user typed. */\n static int\n-complete_fncmp (convfn, convlen, filename, filename_len)\n-     const char *convfn;\n-     int convlen;\n-     const char *filename;\n-     int filename_len;\n+complete_fncmp (const char *convfn, int convlen, const char *filename, int filename_len)\n {\n   register char *s1, *s2;\n   int d, len;\n@@ -2472,9 +2419,7 @@ complete_fncmp (convfn, convlen, filename, filename_len)\n    because of all the pathnames that must be followed when looking up the\n    completion for a command. */\n char *\n-rl_filename_completion_function (text, state)\n-     const char *text;\n-     int state;\n+rl_filename_completion_function (const char *text, int state)\n {\n   static DIR *directory = (DIR *)NULL;\n   static char *filename = (char *)NULL;\n@@ -2702,8 +2647,7 @@ rl_filename_completion_function (text, state)\n    hit the end of the match list, we restore the original unmatched text,\n    ring the bell, and reset the counter to zero. */\n int\n-rl_old_menu_complete (count, invoking_key)\n-     int count, invoking_key;\n+rl_old_menu_complete (int count, int invoking_key)\n {\n   rl_compentry_func_t *our_func;\n   int matching_filenames, found_quote;\n@@ -2824,9 +2768,17 @@ rl_old_menu_complete (count, invoking_key)\n   return (0);\n }\n \n+/* The current version of menu completion.\n+   The differences between this function and the original are:\n+\n+1. It honors the maximum number of completions variable (completion-query-items)\n+2. It appends to the word as usual if there is only one match\n+3. It displays the common prefix if there is one, and makes it the first menu\n+   choice if the menu-complete-display-prefix option is enabled\n+*/\n+ \n int\n-rl_menu_complete (count, ignore)\n-     int count, ignore;\n+rl_menu_complete (int count, int ignore)\n {\n   rl_compentry_func_t *our_func;\n   int matching_filenames, found_quote;\n@@ -2998,8 +2950,7 @@ rl_menu_complete (count, ignore)\n }\n \n int\n-rl_backward_menu_complete (count, key)\n-     int count, key;\n+rl_backward_menu_complete (int count, int key)\n {\n   /* Positive arguments to backward-menu-complete translate into negative\n      arguments for menu-complete, and vice versa. */"
    },
    {
      "sha": "6de47b5874396c2e79acd2080c3d30110898408d",
      "filename": "readline/config.h.in",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/config.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/config.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/config.h.in?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -46,6 +46,9 @@\n /* Define if you have the fcntl function. */\n #undef HAVE_FCNTL\n \n+/* Define if you have the fnmatch function. */\n+#undef HAVE_FNMATCH\n+\n /* Define if you have the getpwent function. */\n #undef HAVE_GETPWENT\n "
    },
    {
      "sha": "0e2d333477d5954ebac2ffa483521a3f14db4e5b",
      "filename": "readline/configure",
      "status": "modified",
      "additions": 296,
      "deletions": 13,
      "changes": 309,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/configure?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n #! /bin/sh\n-# From configure.ac for Readline 7.0, version 2.81.\n+# From configure.ac for Readline 8.0, version 2.85.\n # Guess values for system-dependent variables and create Makefiles.\n-# Generated by GNU Autoconf 2.69 for readline 7.0.\n+# Generated by GNU Autoconf 2.69 for readline 8.0.\n #\n # Report bugs to <bug-readline@gnu.org>.\n #\n@@ -581,8 +581,8 @@ MAKEFLAGS=\n # Identity of this package.\n PACKAGE_NAME='readline'\n PACKAGE_TARNAME='readline'\n-PACKAGE_VERSION='7.0'\n-PACKAGE_STRING='readline 7.0'\n+PACKAGE_VERSION='8.0'\n+PACKAGE_STRING='readline 8.0'\n PACKAGE_BUGREPORT='bug-readline@gnu.org'\n PACKAGE_URL=''\n \n@@ -624,13 +624,15 @@ ac_includes_default=\"\\\n #endif\"\n \n ac_subst_vars='LTLIBOBJS\n+TERMCAP_PKG_CONFIG_LIB\n TERMCAP_LIB\n LIBVERSION\n ARFLAGS\n LOCAL_DEFS\n LOCAL_LDFLAGS\n LOCAL_CFLAGS\n BUILD_DIR\n+EXAMPLES_INSTALL_TARGET\n SHARED_INSTALL_TARGET\n STATIC_INSTALL_TARGET\n SHARED_TARGET\n@@ -723,6 +725,7 @@ enable_option_checking\n with_curses\n enable_multibyte\n enable_static\n+enable_install_examples\n enable_largefile\n '\n       ac_precious_vars='build_alias\n@@ -1274,7 +1277,7 @@ if test \"$ac_init_help\" = \"long\"; then\n   # Omit some internal or obsolete options to make the list less imposing.\n   # This message is too long to be a string in the A/UX 3.1 sh.\n   cat <<_ACEOF\n-\\`configure' configures readline 7.0 to adapt to many kinds of systems.\n+\\`configure' configures readline 8.0 to adapt to many kinds of systems.\n \n Usage: $0 [OPTION]... [VAR=VALUE]...\n \n@@ -1339,7 +1342,7 @@ fi\n \n if test -n \"$ac_init_help\"; then\n   case $ac_init_help in\n-     short | recursive ) echo \"Configuration of readline 7.0:\";;\n+     short | recursive ) echo \"Configuration of readline 8.0:\";;\n    esac\n   cat <<\\_ACEOF\n \n@@ -1349,6 +1352,8 @@ Optional Features:\n   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]\n   --enable-multibyte      enable multibyte characters if OS supports them\n   --enable-static         build static libraries [[default=YES]]\n+  --disable-install-examples\n+                          don't install examples [[default=install]]\n   --disable-largefile     omit support for large files\n \n Optional Packages:\n@@ -1433,7 +1438,7 @@ fi\n test -n \"$ac_init_help\" && exit $ac_status\n if $ac_init_version; then\n   cat <<\\_ACEOF\n-readline configure 7.0\n+readline configure 8.0\n generated by GNU Autoconf 2.69\n \n Copyright (C) 2012 Free Software Foundation, Inc.\n@@ -1898,11 +1903,194 @@ $as_echo \"$ac_res\" >&6; }\n   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n \n } # ac_fn_c_check_decl\n+\n+# ac_fn_c_compute_int LINENO EXPR VAR INCLUDES\n+# --------------------------------------------\n+# Tries to find the compile-time value of EXPR in a program that includes\n+# INCLUDES, setting VAR accordingly. Returns whether the value could be\n+# computed\n+ac_fn_c_compute_int ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  if test \"$cross_compiling\" = yes; then\n+    # Depending upon the size, compute the lo and hi bounds.\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($2) >= 0)];\n+test_array [0] = 0;\n+return test_array [0];\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_lo=0 ac_mid=0\n+  while :; do\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($2) <= $ac_mid)];\n+test_array [0] = 0;\n+return test_array [0];\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_hi=$ac_mid; break\n+else\n+  as_fn_arith $ac_mid + 1 && ac_lo=$as_val\n+\t\t\tif test $ac_lo -le $ac_mid; then\n+\t\t\t  ac_lo= ac_hi=\n+\t\t\t  break\n+\t\t\tfi\n+\t\t\tas_fn_arith 2 '*' $ac_mid + 1 && ac_mid=$as_val\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($2) < 0)];\n+test_array [0] = 0;\n+return test_array [0];\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_hi=-1 ac_mid=-1\n+  while :; do\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($2) >= $ac_mid)];\n+test_array [0] = 0;\n+return test_array [0];\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_lo=$ac_mid; break\n+else\n+  as_fn_arith '(' $ac_mid ')' - 1 && ac_hi=$as_val\n+\t\t\tif test $ac_mid -le $ac_hi; then\n+\t\t\t  ac_lo= ac_hi=\n+\t\t\t  break\n+\t\t\tfi\n+\t\t\tas_fn_arith 2 '*' $ac_mid && ac_mid=$as_val\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+  done\n+else\n+  ac_lo= ac_hi=\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+# Binary search between lo and hi bounds.\n+while test \"x$ac_lo\" != \"x$ac_hi\"; do\n+  as_fn_arith '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo && ac_mid=$as_val\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+static int test_array [1 - 2 * !(($2) <= $ac_mid)];\n+test_array [0] = 0;\n+return test_array [0];\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  ac_hi=$ac_mid\n+else\n+  as_fn_arith '(' $ac_mid ')' + 1 && ac_lo=$as_val\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+done\n+case $ac_lo in #((\n+?*) eval \"$3=\\$ac_lo\"; ac_retval=0 ;;\n+'') ac_retval=1 ;;\n+esac\n+  else\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+static long int longval () { return $2; }\n+static unsigned long int ulongval () { return $2; }\n+#include <stdio.h>\n+#include <stdlib.h>\n+int\n+main ()\n+{\n+\n+  FILE *f = fopen (\"conftest.val\", \"w\");\n+  if (! f)\n+    return 1;\n+  if (($2) < 0)\n+    {\n+      long int i = longval ();\n+      if (i != ($2))\n+\treturn 1;\n+      fprintf (f, \"%ld\", i);\n+    }\n+  else\n+    {\n+      unsigned long int i = ulongval ();\n+      if (i != ($2))\n+\treturn 1;\n+      fprintf (f, \"%lu\", i);\n+    }\n+  /* Do not output a trailing newline, as this causes \\r\\n confusion\n+     on some platforms.  */\n+  return ferror (f) || fclose (f) != 0;\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  echo >>conftest.val; read $3 <conftest.val; ac_retval=0\n+else\n+  ac_retval=1\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+rm -f conftest.val\n+\n+  fi\n+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n+  as_fn_set_status $ac_retval\n+\n+} # ac_fn_c_compute_int\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n \n-It was created by readline $as_me 7.0, which was\n+It was created by readline $as_me 8.0, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   $ $0 $@\n@@ -2289,7 +2477,7 @@ ac_configure=\"$SHELL $ac_aux_dir/configure\"  # Please don't use this var.\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-LIBVERSION=7.0\n+LIBVERSION=8.0\n \n # Make sure we can run config.sub.\n $SHELL \"$ac_aux_dir/config.sub\" sun4 >/dev/null 2>&1 ||\n@@ -2380,6 +2568,7 @@ fi\n opt_multibyte=yes\n opt_static_libs=yes\n opt_shared_libs=no\n+opt_install_examples=no\n \n # Check whether --enable-multibyte was given.\n if test \"${enable_multibyte+set}\" = set; then :\n@@ -2391,6 +2580,11 @@ if test \"${enable_static+set}\" = set; then :\n   enableval=$enable_static; opt_static_libs=$enableval\n fi\n \n+# Check whether --enable-install-examples was given.\n+if test \"${enable_install_examples+set}\" = set; then :\n+  enableval=$enable_install_examples; opt_install_examples=$enableval\n+fi\n+\n \n if test $opt_multibyte = no; then\n $as_echo \"#define NO_MULTIBYTE_SUPPORT 1\" >>confdefs.h\n@@ -4586,7 +4780,7 @@ _ACEOF\n fi\n done\n \n-for ac_func in memmove pselect putenv select setenv setlocale \\\n+for ac_func in fnmatch memmove pselect putenv select setenv setlocale \\\n \t\tstrcasecmp strpbrk tcgetattr vsnprintf\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n@@ -5125,7 +5319,7 @@ else\n \n typedef RETSIGTYPE sigfunc();\n \n-int nsigint;\n+volatile int nsigint;\n \n #ifdef HAVE_POSIX_SIGNALS\n sigfunc *\n@@ -6056,6 +6250,45 @@ fi\n $as_echo \"$ac_cv_lib_ncurses_tgetent\" >&6; }\n if test \"x$ac_cv_lib_ncurses_tgetent\" = xyes; then :\n   bash_cv_termcap_lib=libncurses\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for tgetent in -lncursesw\" >&5\n+$as_echo_n \"checking for tgetent in -lncursesw... \" >&6; }\n+if ${ac_cv_lib_ncursesw_tgetent+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lncursesw  $LIBS\"\n+cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+/* Override any GCC internal prototype to avoid an error.\n+   Use char because int might match the return type of a GCC\n+   builtin and then its argument prototype would still apply.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+char tgetent ();\n+int\n+main ()\n+{\n+return tgetent ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_link \"$LINENO\"; then :\n+  ac_cv_lib_ncursesw_tgetent=yes\n+else\n+  ac_cv_lib_ncursesw_tgetent=no\n+fi\n+rm -f core conftest.err conftest.$ac_objext \\\n+    conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ncursesw_tgetent\" >&5\n+$as_echo \"$ac_cv_lib_ncursesw_tgetent\" >&6; }\n+if test \"x$ac_cv_lib_ncursesw_tgetent\" = xyes; then :\n+  bash_cv_termcap_lib=libncursesw\n else\n   bash_cv_termcap_lib=gnutermcap\n fi\n@@ -6070,6 +6303,8 @@ fi\n \n fi\n \n+fi\n+\n if test \"X$_bash_needmsg\" = \"Xyes\"; then\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking which library has the termcap functions\" >&5\n $as_echo_n \"checking which library has the termcap functions... \" >&6; }\n@@ -6120,6 +6355,14 @@ done\n \n fi\n \n+case \"$TERMCAP_LIB\" in\n+-ltinfo)  TERMCAP_PKG_CONFIG_LIB=tinfo ;;\n+-lcurses) TERMCAP_PKG_CONFIG_LIB=ncurses ;;\n+-lncurses) TERMCAP_PKG_CONFIG_LIB=ncurses ;;\n+-ltermcap) TERMCAP_PKG_CONFIG_LIB=termcap ;;\n+*) TERMCAP_PKG_CONFIG_LIB=termcap ;;\n+esac\n+\n \n for ac_header in wctype.h\n do :\n@@ -6517,6 +6760,40 @@ done\n \tLIBS=\"$OLDLIBS\"\n fi\n \n+# The cast to long int works around a bug in the HP C Compiler\n+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects\n+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.\n+# This bug is HP SR number 8606223364.\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking size of wchar_t\" >&5\n+$as_echo_n \"checking size of wchar_t... \" >&6; }\n+if ${ac_cv_sizeof_wchar_t+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if ac_fn_c_compute_int \"$LINENO\" \"(long int) (sizeof (wchar_t))\" \"ac_cv_sizeof_wchar_t\"        \"$ac_includes_default\"; then :\n+\n+else\n+  if test \"$ac_cv_type_wchar_t\" = yes; then\n+     { { $as_echo \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\n+$as_echo \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n+as_fn_error 77 \"cannot compute sizeof (wchar_t)\n+See \\`config.log' for more details\" \"$LINENO\" 5; }\n+   else\n+     ac_cv_sizeof_wchar_t=0\n+   fi\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_sizeof_wchar_t\" >&5\n+$as_echo \"$ac_cv_sizeof_wchar_t\" >&6; }\n+\n+\n+\n+cat >>confdefs.h <<_ACEOF\n+#define SIZEOF_WCHAR_T $ac_cv_sizeof_wchar_t\n+_ACEOF\n+\n+\n+\n \n \n case \"$host_cpu\" in\n@@ -6589,6 +6866,11 @@ fi\n \n \n \n+if test \"$opt_install_examples\" = \"yes\"; then\n+\tEXAMPLES_INSTALL_TARGET=install-examples\n+fi\n+\n+\n case \"$build_os\" in\n msdosdjgpp*)\tBUILD_DIR=`pwd.exe` ;;\t# to prevent //d/path/file\n *)\t\tBUILD_DIR=`pwd` ;;\n@@ -6616,6 +6898,7 @@ esac\n \n \n \n+\n ac_config_files=\"$ac_config_files Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc\"\n \n ac_config_commands=\"$ac_config_commands default\"\n@@ -7126,7 +7409,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n # report actual input values of CONFIG_FILES etc. instead of their\n # values after options handling.\n ac_log=\"\n-This file was extended by readline $as_me 7.0, which was\n+This file was extended by readline $as_me 8.0, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   CONFIG_FILES    = $CONFIG_FILES\n@@ -7192,7 +7475,7 @@ _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n ac_cs_config=\"`$as_echo \"$ac_configure_args\" | sed 's/^ //; s/[\\\\\"\"\\`\\$]/\\\\\\\\&/g'`\"\n ac_cs_version=\"\\\\\n-readline config.status 7.0\n+readline config.status 8.0\n configured by $0, generated by GNU Autoconf 2.69,\n   with options \\\\\"\\$ac_cs_config\\\\\"\n "
    },
    {
      "sha": "e33834344aabe4ad64984b41a7c689ba136778f1",
      "filename": "readline/configure.ac",
      "status": "modified",
      "additions": 21,
      "deletions": 5,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/configure.ac?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -5,7 +5,7 @@ dnl report bugs to chet@po.cwru.edu\n dnl\n dnl Process this file with autoconf to produce a configure script.\n \n-# Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+# Copyright (C) 1987-2018 Free Software Foundation, Inc.\n \n #   This program is free software: you can redistribute it and/or modify\n #   it under the terms of the GNU General Public License as published by\n@@ -20,11 +20,11 @@ dnl Process this file with autoconf to produce a configure script.\n #   You should have received a copy of the GNU General Public License\n #   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n-AC_REVISION([for Readline 7.0, version 2.81])\n+AC_REVISION([for Readline 8.0, version 2.85])\n \n m4_include([../config/override.m4])\n \n-AC_INIT(readline, 7.0, bug-readline@gnu.org)\n+AC_INIT(readline, 8.0, bug-readline@gnu.org)\n \n dnl make sure we are using a recent autoconf version\n AC_PREREQ(2.50)\n@@ -36,7 +36,7 @@ AC_CONFIG_AUX_DIR(`cd $srcdir;pwd`/..)\n AC_CONFIG_HEADERS(config.h)\n \n dnl update the value of RL_READLINE_VERSION in readline.h when this changes\n-LIBVERSION=7.0\n+LIBVERSION=8.0\n \n AC_CANONICAL_HOST\n AC_CANONICAL_BUILD\n@@ -55,10 +55,12 @@ dnl option parsing for optional features\n opt_multibyte=yes\n opt_static_libs=yes\n opt_shared_libs=no\n+opt_install_examples=no\n \n AC_ARG_ENABLE(multibyte, AC_HELP_STRING([--enable-multibyte], [enable multibyte characters if OS supports them]), opt_multibyte=$enableval)\n dnl AC_ARG_ENABLE(shared, AC_HELP_STRING([--enable-shared], [build shared libraries [[default=YES]]]), opt_shared_libs=$enableval)\n AC_ARG_ENABLE(static, AC_HELP_STRING([--enable-static], [build static libraries [[default=YES]]]), opt_static_libs=$enableval)\n+AC_ARG_ENABLE(install-examples, AC_HELP_STRING([--disable-install-examples], [don't install examples [[default=install]]]), opt_install_examples=$enableval)\n \n if test $opt_multibyte = no; then\n AC_DEFINE(NO_MULTIBYTE_SUPPORT)\n@@ -136,7 +138,7 @@ AC_HEADER_STAT\n AC_HEADER_DIRENT\n \n AC_CHECK_FUNCS(fcntl kill lstat readlink)\n-AC_CHECK_FUNCS(memmove pselect putenv select setenv setlocale \\\n+AC_CHECK_FUNCS(fnmatch memmove pselect putenv select setenv setlocale \\\n \t\tstrcasecmp strpbrk tcgetattr vsnprintf)\n AC_CHECK_FUNCS(isascii isxdigit)\n AC_CHECK_FUNCS(getpwent getpwnam getpwuid)\n@@ -200,6 +202,14 @@ if test \"$TERMCAP_LIB\" = \"-lncurses\"; then\n \tAC_CHECK_HEADERS(ncurses/termcap.h)\n fi\n \n+case \"$TERMCAP_LIB\" in\n+-ltinfo)  TERMCAP_PKG_CONFIG_LIB=tinfo ;;\n+-lcurses) TERMCAP_PKG_CONFIG_LIB=ncurses ;;\n+-lncurses) TERMCAP_PKG_CONFIG_LIB=ncurses ;;\n+-ltermcap) TERMCAP_PKG_CONFIG_LIB=termcap ;;\n+*) TERMCAP_PKG_CONFIG_LIB=termcap ;;\n+esac\n+\n BASH_CHECK_MULTIBYTE\n \n case \"$host_cpu\" in\n@@ -270,6 +280,11 @@ AC_SUBST(SHARED_TARGET)\n AC_SUBST(STATIC_INSTALL_TARGET)\n AC_SUBST(SHARED_INSTALL_TARGET)\n \n+if test \"$opt_install_examples\" = \"yes\"; then\n+\tEXAMPLES_INSTALL_TARGET=install-examples\n+fi\n+AC_SUBST(EXAMPLES_INSTALL_TARGET)\n+\n case \"$build_os\" in\n msdosdjgpp*)\tBUILD_DIR=`pwd.exe` ;;\t# to prevent //d/path/file\n *)\t\tBUILD_DIR=`pwd` ;;\n@@ -296,6 +311,7 @@ AC_SUBST(host_os)\n AC_SUBST(LIBVERSION)\n \n AC_SUBST(TERMCAP_LIB)\n+AC_SUBST(TERMCAP_PKG_CONFIG_LIB)\n \n AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc],\n ["
    },
    {
      "sha": "b39f28291bea78c4c73b9e38c613f08367233321",
      "filename": "readline/display.c",
      "status": "modified",
      "additions": 443,
      "deletions": 226,
      "changes": 669,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/display.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/display.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/display.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* display.c -- readline redisplay facility. */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library    \n    for reading lines of text with interactive input and history editing.\n@@ -124,7 +124,6 @@ static int _rl_col_width PARAMS((const char *, int, int, int));\n #define PROMPT_ENDING_INDEX \\\n   ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) ? prompt_physical_chars : prompt_last_invisible+1)\n   \n-\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tDisplay stuff\t\t\t\t    */\n@@ -159,9 +158,6 @@ rl_voidfunc_t *rl_redisplay_function = rl_redisplay;\n /* What YOU turn on when you have handled all redisplay yourself. */\n int rl_display_fixed = 0;\n \n-int _rl_suppress_redisplay = 0;\n-int _rl_want_redisplay = 0;\n-\n /* The stuff that gets printed out before the actual text of the line.\n    This is usually pointing to rl_prompt. */\n char *rl_display_prompt = (char *)NULL;\n@@ -178,6 +174,10 @@ int _rl_vi_cmd_modestr_len;\n \n /* Pseudo-global variables declared here. */\n \n+/* Hints for other parts of readline to give to the display engine. */\n+int _rl_suppress_redisplay = 0;\n+int _rl_want_redisplay = 0;\n+\n /* The visible cursor position.  If you print some text, adjust this. */\n /* NOTE: _rl_last_c_pos is used as a buffer index when not in a locale\n    supporting multibyte characters, and an absolute cursor position when\n@@ -186,14 +186,24 @@ int _rl_vi_cmd_modestr_len;\n int _rl_last_c_pos = 0;\n int _rl_last_v_pos = 0;\n \n+/* Number of physical lines consumed by the current line buffer currently\n+  on screen minus 1. */\n+int _rl_vis_botlin = 0;\n+\n+/* This is a hint update_line gives to rl_redisplay that it has adjusted the\n+   value of _rl_last_c_pos *and* taken the presence of any invisible chars in\n+   the prompt into account.  rl_redisplay notes this and does not do the\n+   adjustment itself. */\n static int cpos_adjusted;\n+\n+/* The index into the line buffer corresponding to the cursor position */\n static int cpos_buffer_position;\n+\n+/* A flag to note when we're displaying the first line of the prompt */\n static int displaying_prompt_first_line;\n+/* The number of multibyte characters in the prompt, if any */\n static int prompt_multibyte_chars;\n \n-/* Number of lines currently on screen minus 1. */\n-int _rl_vis_botlin = 0;\n-\n static int _rl_inv_botlin = 0;\n \n /* Variables used only in this file. */\n@@ -216,7 +226,11 @@ static int line_size = 1024;\n \n static char *local_prompt, *local_prompt_prefix;\n static int local_prompt_len;\n-static int prompt_visible_length, prompt_prefix_length;\n+static int prompt_prefix_length;\n+/* Number of chars in the buffer that contribute to visible chars on the screen.\n+   This might be different from the number of physical chars in the presence\n+   of multibyte characters */\n+static int prompt_visible_length;\n \n /* The number of invisible characters in the line currently being\n    displayed on the screen. */\n@@ -242,16 +256,26 @@ static int prompt_last_screen_line;\n \n static int prompt_physical_chars;\n \n+/* An array of indexes into the prompt string where we will break physical\n+   screen lines.  It's easier to compute in expand_prompt and use later in\n+   rl_redisplay instead of having rl_redisplay try to guess about invisible\n+   characters in the prompt or use heuristics about where they are. */\n+static int *local_prompt_newlines;\n+\n /* set to a non-zero value by rl_redisplay if we are marking modified history\n    lines and the current line is so marked. */\n static int modmark;\n \n+static int line_totbytes;\n+\n /* Variables to save and restore prompt and display information. */\n \n /* These are getting numerous enough that it's time to create a struct. */\n \n static char *saved_local_prompt;\n static char *saved_local_prefix;\n+static int *saved_local_prompt_newlines;\n+\n static int saved_last_invisible;\n static int saved_visible_length;\n static int saved_prefix_length;\n@@ -262,8 +286,7 @@ static int saved_physical_chars;\n /* Return a string indicating the editing mode, for use in the prompt. */\n \n static char *\n-prompt_modestr (lenp)\n-     int *lenp;\n+prompt_modestr (int *lenp)\n {\n   if (rl_editing_mode == emacs_mode)\n     {\n@@ -291,7 +314,8 @@ prompt_modestr (lenp)\n    index of the last invisible character in the returned string. NIFLP,\n    if non-zero, is a place to store the number of invisible characters in\n    the first prompt line.  The previous are used as byte counts -- indexes\n-   into a character buffer. */\n+   into a character buffer.  *VLP gets the number of physical characters in\n+   the expanded prompt (visible length) */\n \n /* Current implementation:\n \t\\001 (^A) start non-visible characters\n@@ -304,15 +328,16 @@ prompt_modestr (lenp)\n \tPMT_MULTILINE\tcaller indicates that this is part of a multiline prompt\n */\n \n+/* This approximates the number of lines the prompt will take when displayed */\n+#define APPROX_DIV(n, d)\t(((n) < (d)) ? 1 : ((n) / (d)) + 1)\n+\n static char *\n-expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n-     char *pmt;\n-     int flags;\n-     int *lp, *lip, *niflp, *vlp;\n+expand_prompt (char *pmt, int flags, int *lp, int *lip, int *niflp, int *vlp)\n {\n   char *r, *ret, *p, *igstart, *nprompt, *ms;\n   int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;\n-  int mlen;\n+  int mlen, newlines, newlines_guess, bound;\n+  int mb_cur_max;\n \n   /* We only expand the mode string for the last line of a multiline prompt\n      (a prompt with embedded newlines). */\n@@ -327,29 +352,54 @@ expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n   else\n     nprompt = pmt;\n \n-  /* Short-circuit if we can. */\n-  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (nprompt, RL_PROMPT_START_IGNORE) == 0)\n+  mb_cur_max = MB_CUR_MAX;\n+\n+  if (_rl_screenwidth == 0)\n+    _rl_get_screen_size (0, 0);\t/* avoid division by zero */\n+\n+  /* Short-circuit if we can.  We can do this if we are treating the prompt as\n+     a sequence of bytes and there are no invisible characters in the prompt\n+     to deal with. Since we populate local_prompt_newlines, we have to run\n+     through the rest of the function if this prompt looks like it's going to\n+     be longer than one screen line. */\n+  if ((mb_cur_max <= 1 || rl_byte_oriented) && strchr (nprompt, RL_PROMPT_START_IGNORE) == 0)\n     {\n-      r = (nprompt == pmt) ? savestring (pmt) : nprompt;\n+      l = strlen (nprompt);\n+      if (l < (_rl_screenwidth > 0 ? _rl_screenwidth : 80))\n+        {\n+\t  r = (nprompt == pmt) ? savestring (pmt) : nprompt;\n+\t  if (lp)\n+\t    *lp = l;\n+\t  if (lip)\n+\t    *lip = 0;\n+\t  if (niflp)\n+\t    *niflp = 0;\n+\t  if (vlp)\n+\t    *vlp = l;\n+\n+\t  local_prompt_newlines = (int *) xrealloc (local_prompt_newlines, sizeof (int) * 2);\n+\t  local_prompt_newlines[0] = 0;\n+\t  local_prompt_newlines[1] = -1;\n \n-      if (lp)\n-\t*lp = strlen (r);\n-      if (lip)\n-\t*lip = 0;\n-      if (niflp)\n-\t*niflp = 0;\n-      if (vlp)\n-\t*vlp = lp ? *lp : strlen (r);\n-      return r;\n+\t  return r;\n+        }\n     }\n \n   l = strlen (nprompt);\t\t\t/* XXX */\n   r = ret = (char *)xmalloc (l + 1);\n \n+  /* Guess at how many screen lines the prompt will take to size the array that\n+     keeps track of where the line wraps happen */\n+  newlines_guess = (_rl_screenwidth > 0) ? APPROX_DIV(l,  _rl_screenwidth) : APPROX_DIV(l, 80);\n+  local_prompt_newlines = (int *) xrealloc (local_prompt_newlines, sizeof (int) * (newlines_guess + 1));\n+  local_prompt_newlines[newlines = 0] = 0;\n+  for (rl = 1; rl <= newlines_guess; rl++)\n+    local_prompt_newlines[rl] = -1;\n+\n   rl = physchars = 0;\t/* mode string now part of nprompt */\n-  invfl = 0;\t/* invisible chars in first line of prompt */\n-  invflset = 0;\t/* we only want to set invfl once */\n-  igstart = 0;\n+  invfl = 0;\t\t/* invisible chars in first line of prompt */\n+  invflset = 0;\t\t/* we only want to set invfl once */\n+  igstart = 0;\t\t/* we're not ignoring any characters yet */\n \n   for (ignoring = last = ninvis = 0, p = nprompt; p && *p; p++)\n     {\n@@ -371,7 +421,7 @@ expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n       else\n \t{\n #if defined (HANDLE_MULTIBYTE)\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    {\n \t      pind = p - nprompt;\n \t      ind = _rl_find_next_mbchar (nprompt, pind, 1, MB_FIND_NONZERO);\n@@ -405,11 +455,29 @@ expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n \t\tninvis++;\t\t/* invisible chars byte counter */\n \t    }\n \n-\t  if (invflset == 0 && rl >= _rl_screenwidth)\n+\t  if (invflset == 0 && physchars >= _rl_screenwidth)\n \t    {\n \t      invfl = ninvis;\n \t      invflset = 1;\n \t    }\n+\n+\t  if (physchars >= (bound = (newlines + 1) * _rl_screenwidth) && local_prompt_newlines[newlines+1] == -1)\n+\t    {\n+\t      int new;\n+\t      if (physchars > bound)\t\t/* should rarely happen */\n+\t\t{\n+#if defined (HANDLE_MULTIBYTE)\n+\t\t  *r = '\\0';\t/* need null-termination for strlen */\n+\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n+\t\t    new = _rl_find_prev_mbchar (ret, r - ret, MB_FIND_ANY);\n+\t\t  else\n+#endif\n+\t\t    new = r - ret - (physchars - bound);\t/* XXX */\n+\t\t}\n+\t      else\n+\t        new = r - ret;\n+\t      local_prompt_newlines[++newlines] = new;\n+\t    }\n \t}\n     }\n \n@@ -435,8 +503,7 @@ expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n /* Just strip out RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE from\n    PMT and return the rest of PMT. */\n char *\n-_rl_strip_prompt (pmt)\n-     char *pmt;\n+_rl_strip_prompt (char *pmt)\n {\n   char *ret;\n \n@@ -445,7 +512,7 @@ _rl_strip_prompt (pmt)\n }\n \n void\n-_rl_reset_prompt ()\n+_rl_reset_prompt (void)\n {\n   rl_visible_prompt_length = rl_expand_prompt (rl_prompt);\n }\n@@ -461,15 +528,20 @@ _rl_reset_prompt ()\n  * prompt_visible_length = number of visible characters in local_prompt\n  * prompt_prefix_length = number of visible characters in local_prompt_prefix\n  *\n+ * It also tries to keep track of the number of invisible characters in the\n+ * prompt string, and where they are.\n+ *\n  * This function is called once per call to readline().  It may also be\n  * called arbitrarily to expand the primary prompt.\n  *\n  * The return value is the number of visible characters on the last line\n- * of the (possibly multi-line) prompt.\n+ * of the (possibly multi-line) prompt.  In this case, multi-line means\n+ * there are embedded newlines in the prompt string itself, not that the\n+ * number of physical characters exceeds the screen width and the prompt\n+ * wraps.\n  */\n int\n-rl_expand_prompt (prompt)\n-     char *prompt;\n+rl_expand_prompt (char *prompt)\n {\n   char *p, *t;\n   int c;\n@@ -527,8 +599,7 @@ rl_expand_prompt (prompt)\n    increased.  If the lines have already been allocated, this ensures that\n    they can hold at least MINSIZE characters. */\n static void\n-init_line_structures (minsize)\n-      int minsize;\n+init_line_structures (int minsize)\n {\n   register int n;\n \n@@ -578,9 +649,9 @@ init_line_structures (minsize)\n   line_structures_initialized = 1;\n }\n   \n-/* Basic redisplay algorithm. */\n+/* Basic redisplay algorithm.  See comments inline. */\n void\n-rl_redisplay ()\n+rl_redisplay (void)\n {\n   register int in, out, c, linenum, cursor_linenum;\n   register char *line;\n@@ -643,6 +714,10 @@ rl_redisplay ()\n      one passed to readline()), use the values we have already expanded.\n      If not, use what's already in rl_display_prompt.  WRAP_OFFSET is the\n      number of non-visible characters in the prompt string. */\n+  /* This is where we output the characters in the prompt before the last\n+     newline, if any.  If there aren't any embedded newlines, we don't\n+     write anything. Copy the last line of the prompt string into the line in\n+     any case */\n   if (rl_display_prompt == rl_prompt || local_prompt)\n     {\n       if (local_prompt_prefix && forced_display)\n@@ -697,14 +772,30 @@ rl_redisplay ()\n       wrap_offset = prompt_invis_chars_first_line = 0;\n     }\n \n+#if defined (HANDLE_MULTIBYTE)\n #define CHECK_INV_LBREAKS() \\\n       do { \\\n \tif (newlines >= (inv_lbsize - 2)) \\\n \t  { \\\n \t    inv_lbsize *= 2; \\\n \t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n \t  } \\\n+\tif (newlines >= (line_state_invisible->wbsize - 2)) \\\n+\t  { \\\n+\t    line_state_invisible->wbsize *= 2; \\\n+\t    line_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n+\t  } \\\n       } while (0)\n+#else\n+#define CHECK_INV_LBREAKS() \\\n+      do { \\\n+\tif (newlines >= (inv_lbsize - 2)) \\\n+\t  { \\\n+\t    inv_lbsize *= 2; \\\n+\t    inv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n+\t  } \\\n+      } while (0)\n+#endif /* !HANDLE_MULTIBYTE */\n \n #if defined (HANDLE_MULTIBYTE)\t  \n #define CHECK_LPOS() \\\n@@ -718,7 +809,7 @@ rl_redisplay ()\n \t\tinv_lbreaks = (int *)xrealloc (inv_lbreaks, inv_lbsize * sizeof (int)); \\\n \t      } \\\n \t    inv_lbreaks[++newlines] = out; \\\n-\t    if (newlines >= (line_state_invisible->wbsize - 1)) \\\n+\t    if (newlines >= (line_state_invisible->wbsize - 2)) \\\n \t      { \\\n \t\tline_state_invisible->wbsize *= 2; \\\n \t\tline_state_invisible->wrapped_line = (int *)xrealloc (line_state_invisible->wrapped_line, line_state_invisible->wbsize * sizeof(int)); \\\n@@ -747,7 +838,10 @@ rl_redisplay ()\n   /* inv_lbreaks[i] is where line i starts in the buffer. */\n   inv_lbreaks[newlines = 0] = 0;\n   /* lpos is a physical cursor position, so it needs to be adjusted by the\n-     number of invisible characters in the prompt, per line */\n+     number of invisible characters in the prompt, per line.  We compute\n+     the line breaks in the prompt string in expand_prompt, taking invisible\n+     characters into account, and if lpos exceeds the screen width, we copy\n+     the data in the loop below. */\n   lpos = prompt_physical_chars + modmark;\n \n #if defined (HANDLE_MULTIBYTE)\n@@ -757,92 +851,38 @@ rl_redisplay ()\n \n   /* prompt_invis_chars_first_line is the number of invisible characters in\n      the first physical line of the prompt.\n-     wrap_offset - prompt_invis_chars_first_line is the number of invis\n-     chars on the second (or, more generally, last) line. */\n+     wrap_offset - prompt_invis_chars_first_line is usually the number of\n+     invis chars on the second (or, more generally, last) line. */\n \n   /* This is zero-based, used to set the newlines */\n   prompt_lines_estimate = lpos / _rl_screenwidth;\n \n   /* what if lpos is already >= _rl_screenwidth before we start drawing the\n      contents of the command line? */\n-  while (lpos >= _rl_screenwidth)\n-    {\n-      int z, p;\n-      int nocorrect, wadjust;\n-\n-      nocorrect = 0;\n-      /* Adjust depending on the invisible characters in the line.  We use a\n-\t heuristic based on experience: invisible characters nearly always\n-\t appear in the first and last lines of the prompt */\n-      wadjust = (newlines == 0)\n-\t\t  ? prompt_invis_chars_first_line\n-\t\t  : ((newlines == prompt_lines_estimate)\n-\t\t  \t? (wrap_offset - prompt_invis_chars_first_line)\n-\t\t  \t: 0);\n-\n-      /* fix from Darin Johnson <darin@acuson.com> for prompt string with\n-         invisible characters that is longer than the screen width.  The\n-         prompt_invis_chars_first_line variable could be made into an array\n-         saying how many invisible characters there are per line, but that's\n-         probably too much work for the benefit gained.  How many people have\n-         prompts that exceed two physical lines?\n-         Additional logic fix from Edward Catmur <ed@catmur.co.uk> */\n-#if defined (HANDLE_MULTIBYTE)\n-      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n-\t{\n-\t  nocorrect = 1;\n-\t  n0 = num;\n-          temp = local_prompt_len;\n-          while (num < temp)\n-\t    {\n-\t      /* This has to take invisible characters in the prompt into\n-\t\t account. */\n-\t      z = _rl_col_width  (local_prompt, n0, num, 1) - wadjust;\n-\t      if (z > _rl_screenwidth)\n-\t\t{\n-\t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n-\t          break;\n-\t\t}\n-\t      else if (z == _rl_screenwidth)\n-\t\t{\n-\t\t  /* If we are in the middle or at the end of a multibyte\n-\t\t     character, we want to move to the start, then find out\n-\t\t     where it ends so we know where to insert the newline.\n-\t\t     If this isn't a multibyte character, its the same as num++ */\n-\t\t  p = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n-\t\t  num = _rl_find_next_mbchar (local_prompt, p, 1, MB_FIND_ANY);\n-\t\t  break;\n-\t\t}\n-\t      num++;\n-\t    }\n-          temp = num;\n-\t}\n-      else\n-#endif /* !HANDLE_MULTIBYTE */\n-\ttemp = ((newlines + 1) * _rl_screenwidth);\n+  if (lpos >= _rl_screenwidth)\n+    {\n+      temp = 0;\n \n-      /* Now account for invisible characters in the current line. */\n-      /* XXX - this assumes that the invisible characters may be split, but only\n-\t between the first and the last lines. */\n-      if (nocorrect == 0)\n-\ttemp += wadjust;\n+      /* first copy the linebreaks array we computed in expand_prompt */\n+      while (local_prompt_newlines[newlines+1] != -1)\n+\t{\n+\t  temp = local_prompt_newlines[newlines+1];\n+\t  inv_lbreaks[++newlines] = temp;\n+\t}  \n \n-      inv_lbreaks[++newlines] = temp;\n-#if defined (HANDLE_MULTIBYTE)\n-      /* lpos is a physical cursor position, so it needs to take the invisible\n-\t characters into account. */\n+      /* Now set lpos from the last newline */\n       if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n-\tlpos -= _rl_col_width (local_prompt, n0, num, 1) - wadjust;\n+        lpos = _rl_col_width (local_prompt, temp, local_prompt_len, 1) - (wrap_offset - prompt_invis_chars_first_line);\n       else\n-#endif\n-\tlpos -= _rl_screenwidth;\t/* all physical cursor positions */\n+        lpos -= (_rl_screenwidth * newlines);\n     }\n \n   prompt_last_screen_line = newlines;\n \n   /* Draw the rest of the line (after the prompt) into invisible_line, keeping\n-     track of where the cursor is (cpos_buffer_position), the number of the line containing\n-     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).\n+     track of where the cursor is (cpos_buffer_position), the number of the\n+     line containing the cursor (lb_linenum), the last line number (lb_botlin\n+     and inv_botlin).\n      It maintains an array of line breaks for display (inv_lbreaks).\n      This handles expanding tabs for display and displaying meta characters. */\n   lb_linenum = 0;\n@@ -851,8 +891,13 @@ rl_redisplay ()\n   if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       memset (&ps, 0, sizeof (mbstate_t));\n-      /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n-      wc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[0]))\n+\t{\n+\t  wc = (wchar_t)rl_line_buffer[0];\n+\t  wc_bytes = 1;\n+\t}\n+      else\n+\twc_bytes = mbrtowc (&wc, rl_line_buffer, rl_end, &ps);\n     }\n   else\n     wc_bytes = 1;\n@@ -914,6 +959,9 @@ rl_redisplay ()\n \t\t  temp = _rl_screenwidth - lpos;\n \t\t  CHECK_INV_LBREAKS ();\n \t\t  inv_lbreaks[++newlines] = out + temp;\n+#if defined (HANDLE_MULTIBYTE)\n+\t\t  line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n+#endif\n \t\t  lpos = 4 - temp;\n \t\t}\n \t      else\n@@ -944,6 +992,9 @@ rl_redisplay ()\n \t      temp2 = _rl_screenwidth - lpos;\n \t      CHECK_INV_LBREAKS ();\n \t      inv_lbreaks[++newlines] = out + temp2;\n+#if defined (HANDLE_MULTIBYTE)\n+\t      line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n+#endif\n \t      lpos = temp - temp2;\n \t      while (out < newout)\n \t\tline[out++] = ' ';\n@@ -961,6 +1012,9 @@ rl_redisplay ()\n \t  line[out++] = '\\0';\t/* XXX - sentinel */\n \t  CHECK_INV_LBREAKS ();\n \t  inv_lbreaks[++newlines] = out;\n+#if defined (HANDLE_MULTIBYTE)\n+\t  line_state_invisible->wrapped_line[newlines] = _rl_wrapped_multicolumn;\n+#endif\n \t  lpos = 0;\n \t}\n       else if (CTRL_CHAR (c) || c == RUBOUT)\n@@ -1012,15 +1066,21 @@ rl_redisplay ()\n       if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  in += wc_bytes;\n-\t  /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n-\t  wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);\n+\t  if (_rl_utf8locale && UTF8_SINGLEBYTE(rl_line_buffer[in]))\n+\t    {\n+\t      wc = (wchar_t)rl_line_buffer[in];\n+\t      wc_bytes = 1;\n+\t      memset (&ps, 0, sizeof (mbstate_t));\t/* re-init state */\n+\t    }\n+\t  else\n+\t    wc_bytes = mbrtowc (&wc, rl_line_buffer + in, rl_end - in, &ps);\n \t}\n       else\n         in++;\n #endif\n-\n     }\n   line[out] = '\\0';\n+  line_totbytes = out;\n   if (cpos_buffer_position < 0)\n     {\n       cpos_buffer_position = out;\n@@ -1030,6 +1090,10 @@ rl_redisplay ()\n   inv_botlin = lb_botlin = _rl_inv_botlin = newlines;\n   CHECK_INV_LBREAKS ();\n   inv_lbreaks[newlines+1] = out;\n+#if defined (HANDLE_MULTIBYTE)\n+  /* This should be 0 anyway */\n+  line_state_invisible->wrapped_line[newlines+1] = _rl_wrapped_multicolumn;\n+#endif\n   cursor_linenum = lb_linenum;\n \n   /* CPOS_BUFFER_POSITION == position in buffer where cursor should be placed.\n@@ -1097,8 +1161,8 @@ rl_redisplay ()\n \n \t      /* update_line potentially changes _rl_last_c_pos, but doesn't\n \t\t take invisible characters into account, since _rl_last_c_pos\n-\t\t is an absolute cursor position in a multibyte locale.  See\n-\t\t if compensating here is the right thing, or if we have to\n+\t\t is an absolute cursor position in a multibyte locale.  We\n+\t\t choose to (mostly) compensate for that here, rather than\n \t\t change update_line itself.  There are several cases in which\n \t\t update_line adjusts _rl_last_c_pos itself (so it can pass\n \t\t _rl_move_cursor_relative accurate values); it communicates\n@@ -1109,11 +1173,16 @@ rl_redisplay ()\n \t\t wrap_offset. */\n \t      if (linenum == 0 && (mb_cur_max > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n \t\t_rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n-\t      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&\n+\t      else if (cpos_adjusted == 0 &&\n+\t\t\tlinenum == prompt_last_screen_line &&\n+\t\t\tprompt_physical_chars > _rl_screenwidth &&\n \t\t\t(mb_cur_max > 1 && rl_byte_oriented == 0) &&\n-\t\t\tcpos_adjusted == 0 &&\n \t\t\t_rl_last_c_pos != o_cpos &&\n-\t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\n+\t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\t/* XXX - rethink this last one */\n+\t\t/* This assumes that all the invisible characters are split\n+\t\t   between the first and last lines of the prompt, if the \n+\t\t   prompt consumes more than two lines. It's usually right */\n+\t\t/* XXX - not sure this is ever executed */\n \t\t_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);\n \n \t      /* If this is the line with the prompt, we might need to\n@@ -1183,6 +1252,9 @@ rl_redisplay ()\n \t\t_rl_last_c_pos += wrap_offset;\n \t    }\n \n+\t  /* Now we move the cursor to where it needs to be.  First, make\n+\t     sure we are on the correct line (cursor_linenum). */\n+\n \t  /* We have to reprint the prompt if it contains invisible\n \t     characters, since it's not generally OK to just reprint\n \t     the characters from the current cursor position.  But we\n@@ -1224,9 +1296,10 @@ rl_redisplay ()\n \t     position that doesn't take invisible characters in the prompt\n \t     into account.  We use a fudge factor to compensate. */\n \n-\t  /* Since _rl_backspace() doesn't know about invisible characters in the\n-\t     prompt, and there's no good way to tell it, we compensate for\n-\t     those characters here and call _rl_backspace() directly. */\n+\t  /* Since _rl_backspace() doesn't know about invisible characters in\n+\t     the prompt, and there's no good way to tell it, we compensate for\n+\t     those characters here and call _rl_backspace() directly if\n+\t     necessary */\n \t  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)\n \t    {\n \t      /* TX == new physical cursor position in multibyte locale. */\n@@ -1251,7 +1324,7 @@ rl_redisplay ()\n \t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n \t}\n     }\n-  else\t\t\t\t/* Do horizontal scrolling. */\n+  else\t\t\t\t/* Do horizontal scrolling. Much simpler */\n     {\n #define M_OFFSET(margin, offset) ((margin) == 0 ? offset : 0)\n       int lmargin, ndisp, nleft, phys_c_pos, t;\n@@ -1311,7 +1384,7 @@ rl_redisplay ()\n \t right edge of the screen.  If LMARGIN is 0, we need to take the\n \t wrap offset into account. */\n       t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;\n-      if (t < out)\n+      if (t > 0 && t < out)\n \tline[t - 1] = '>';\n \n       if (rl_display_fixed == 0 || forced_display || lmargin != last_lmargin)\n@@ -1389,9 +1462,7 @@ new:\teddie> Oh, my little buggy says to me, as lurgid as\n \n    Could be made even smarter, but this works well enough */\n static void\n-update_line (old, new, current_line, omax, nmax, inv_botlin)\n-     register char *old, *new;\n-     int current_line, omax, nmax, inv_botlin;\n+update_line (char *old, char *new, int current_line, int omax, int nmax, int inv_botlin)\n {\n   register char *ofd, *ols, *oe, *nfd, *nls, *ne;\n   int temp, lendiff, wsatend, od, nd, twidth, o_cpos;\n@@ -1416,52 +1487,145 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode\n \t&& _rl_last_v_pos == current_line - 1)\n     {\n+      /* We're going to wrap around by writing the first character of NEW to\n+\t the screen and dealing with changes to what's visible by modifying\n+\t OLD to match it.  Complicated by the presence of multi-width\n+\t characters at the end of the line or beginning of the new one. */\n+      /* old is always somewhere in visible_line; new is always somewhere in\n+         invisible_line.  These should always be null-terminated. */\n #if defined (HANDLE_MULTIBYTE)\n       if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  wchar_t wc;\n \t  mbstate_t ps;\n-\t  int tempwidth, bytes;\n+\t  int oldwidth, newwidth;\n+\t  int oldbytes, newbytes;\n \t  size_t ret;\n \n \t  /* This fixes only double-column characters, but if the wrapped\n \t     character consumes more than three columns, spaces will be\n \t     inserted in the string buffer. */\n-\t  if (current_line < line_state_visible->wbsize && line_state_visible->wrapped_line[current_line] > 0)\n-\t    _rl_clear_to_eol (line_state_visible->wrapped_line[current_line]);\n+\t  /* XXX remember that we are working on the invisible line right now;\n+\t     we don't swap visible and invisible until just before rl_redisplay\n+\t     returns */\n+\t  /* This will remove the extra placeholder space we added with\n+\t     _rl_wrapped_multicolumn */\n+\t  if (current_line < line_state_invisible->wbsize && line_state_invisible->wrapped_line[current_line] > 0)\n+\t    _rl_clear_to_eol (line_state_invisible->wrapped_line[current_line]);\n+\n+\t  /* 1. how many screen positions does first char in old consume? */\n+\t  memset (&ps, 0, sizeof (mbstate_t));\n+\t  ret = mbrtowc (&wc, old, mb_cur_max, &ps);\n+\t  oldbytes = ret;\n+\t  if (MB_INVALIDCH (ret))\n+\t    {\n+\t      oldwidth = 1;\n+\t      oldbytes = 1;\n+\t    }\n+\t  else if (MB_NULLWCH (ret))\n+\t    oldwidth = 0;\n+\t  else\n+\t    oldwidth = WCWIDTH (wc);\n+\t  if (oldwidth < 0)\n+\t    oldwidth = 1;\n \n+\t  /* 2. how many screen positions does the first char in new consume? */\n \t  memset (&ps, 0, sizeof (mbstate_t));\n \t  ret = mbrtowc (&wc, new, mb_cur_max, &ps);\n+\t  newbytes = ret;\n \t  if (MB_INVALIDCH (ret))\n \t    {\n-\t      tempwidth = 1;\n-\t      ret = 1;\n+\t      newwidth = 1;\n+\t      newbytes = 1;\n \t    }\n \t  else if (MB_NULLWCH (ret))\n-\t    tempwidth = 0;\n+\t    newwidth = 0;\n \t  else\n-\t    tempwidth = WCWIDTH (wc);\n+\t    newwidth = WCWIDTH (wc);\n+\t  if (newwidth < 0)\n+\t    newwidth = 1;\n+\n+\t  /* 3. if the new width is less than the old width, we need to keep\n+\t     going in new until we have consumed at least that many screen\n+\t     positions, and figure out how many bytes that will take */\n+\t  while (newbytes < nmax && newwidth < oldwidth)\n+\t    {\n+\t      int t;\n \n-\t  if (tempwidth > 0)\n+\t      ret = mbrtowc (&wc, new+newbytes, mb_cur_max, &ps);\n+\t      if (MB_INVALIDCH (ret))\n+\t\t{\n+\t\t  newwidth += 1;\n+\t\t  newbytes += 1;\n+\t\t}\n+\t      else if (MB_NULLWCH (ret))\n+\t        break;\n+\t      else\n+\t\t{\n+\t\t  t = WCWIDTH (wc);\n+\t\t  newwidth += (t >= 0) ? t : 1;\n+\t\t  newbytes += ret;\n+\t\t}\n+\t    }\n+\t  /* 4. If the new width is more than the old width, keep going in old\n+\t     until we have consumed exactly that many screen positions, and\n+\t     figure out how many bytes that will take.  This is an optimization */\n+\t  while (oldbytes < omax && oldwidth < newwidth)\n \t    {\n-\t      int count, i;\n-\t      bytes = ret;\n-\t      for (count = 0; count < bytes; count++)\n-\t\tputc (new[count], rl_outstream);\n-\t      _rl_last_c_pos = tempwidth;\n+\t      int t;\n+\n+\t      ret = mbrtowc (&wc, old+oldbytes, mb_cur_max, &ps);\n+\t      if (MB_INVALIDCH (ret))\n+\t\t{\n+\t\t  oldwidth += 1;\n+\t\t  oldbytes += 1;\n+\t\t}\n+\t      else if (MB_NULLWCH (ret))\n+\t        break;\n+\t      else\n+\t\t{\n+\t\t  t = WCWIDTH (wc);\n+\t\t  oldwidth += (t >= 0) ? t : 1;\n+\t\t  oldbytes += ret;\n+\t\t}\n+\t    }\n+\t  /* 5. write the first newbytes of new, which takes newwidth.  This is\n+\t     where the screen wrapping takes place, and we are now writing\n+\t     characters onto the new line. We need to fix up old so it\n+\t     accurately reflects what is on the screen after the\n+\t     _rl_output_some_chars below. */\n+\t  if (newwidth > 0)\n+\t    {\n+\t      int count, i, j;\n+\t      char *optr;\n+\n+\t      _rl_output_some_chars (new, newbytes);\n+\t      _rl_last_c_pos = newwidth;\n \t      _rl_last_v_pos++;\n-\t      memset (&ps, 0, sizeof (mbstate_t));\n-\t      ret = mbrtowc (&wc, old, mb_cur_max, &ps);\n-\t      if (ret != 0 && bytes != 0)\n+\n+\t      /* 5a. If the number of screen positions doesn't match, punt\n+\t\t and do a dumb update. */\n+\t      if (newwidth != oldwidth)\n \t\t{\n-\t\t  if (MB_INVALIDCH (ret))\n-\t\t    ret = 1;\n-\t\t  memmove (old+bytes, old+ret, strlen (old+ret));\n-\t\t  memcpy (old, new, bytes);\n+\t\t  ne = new + nmax;\n+\t\t  nd = newbytes;\n+\t\t  nfd = new + nd;\n+\t\t  goto dumb_update;\n+\t\t}\n+\t      if (oldbytes != 0 && newbytes != 0)\n+\t\t{\n+\t\t  /* We have written as many bytes from new as we need to\n+\t\t     consume the first character of old. Fix up `old' so it\n+\t\t     reflects the new screen contents.  We use +1 in the\n+\t\t     memmove call to copy the trailing NUL. */\n+\t\t  memmove (old+newbytes, old+oldbytes, strlen (old+oldbytes) + 1);\n+\t\t  memcpy (old, new, newbytes);\n+\t\t  j = newbytes - oldbytes;\n+\t\t      \n+\t\t  omax += j;\n \t\t  /* Fix up indices if we copy data from one line to another */\n-\t\t  omax += bytes - ret;\n \t\t  for (i = current_line+1; i <= inv_botlin+1; i++)\n-\t\t    vis_lbreaks[i] += bytes - ret;\n+\t\t    vis_lbreaks[i] += j;\n \t\t}\n \t    }\n \t  else\n@@ -1487,7 +1651,6 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t}\n     }\n \n-      \n   /* Find first difference. */\n #if defined (HANDLE_MULTIBYTE)\n   if (mb_cur_max > 1 && rl_byte_oriented == 0)\n@@ -1506,6 +1669,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t  memset (&ps_new, 0, sizeof(mbstate_t));\n \t  memset (&ps_old, 0, sizeof(mbstate_t));\n \n+\t  /* Are the old and new lines the same? */\n \t  if (omax == nmax && STREQN (new, old, omax))\n \t    {\n \t      old_offset = omax;\n@@ -1515,6 +1679,8 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t    }\n \t  else\n \t    {\n+\t      /* Go through the line from the beginning and find the first\n+\t\t difference. */\n \t      new_offset = old_offset = 0;\n \t      for (ofd = old, nfd = new;\n \t\t    (ofd - old < omax) && *ofd &&\n@@ -1570,6 +1736,8 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n   wsatend = 1;\t\t\t/* flag for trailing whitespace */\n \n #if defined (HANDLE_MULTIBYTE)\n+  /* Find the last character that is the same between the two lines.  This\n+     bounds the region that needs to change. */\n   if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);\n@@ -1729,12 +1897,29 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t  nd = lendiff;\n \n \t  /* Do a dumb update and return */\n+dumb_update:\n \t  temp = ne - nfd;\n \t  if (temp > 0)\n \t    {\n \t      _rl_output_some_chars (nfd, temp);\n \t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n-\t\t_rl_last_c_pos += _rl_col_width (new, nd, ne - new, 1);\n+\t\t{\n+\t\t  _rl_last_c_pos += _rl_col_width (new, nd, ne - new, 1);\n+\t\t  /* Need to adjust here based on wrap_offset. Guess that if\n+\t\t     this is the line containing the last line of the prompt\n+\t\t     we need to adjust by\n+\t\t     \twrap_offset-prompt_invis_chars_first_line\n+\t\t     on the assumption that this is the number of invisible\n+\t\t     characters in the last line of the prompt. */\n+\t\t  if (wrap_offset > prompt_invis_chars_first_line &&\n+\t\t      current_line == prompt_last_screen_line &&\n+\t\t      prompt_physical_chars > _rl_screenwidth &&\n+\t\t      _rl_horizontal_scroll_mode == 0)\n+\t\t    {\n+\t\t      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;\n+\t\t      cpos_adjusted = 1;\n+\t\t    }\n+\t\t}\n \t      else\n \t\t_rl_last_c_pos += temp;\n \t    }\n@@ -1809,6 +1994,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n     {\n       /* Non-zero if we're increasing the number of lines. */\n       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;\n+\n       /* If col_lendiff is > 0, implying that the new string takes up more\n \t screen real estate than the old, but lendiff is < 0, meaning that it\n \t takes fewer bytes, we need to just output the characters starting\n@@ -1824,7 +2010,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t     cpos_adjusted to let the caller know. */\n \t  if (current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t    {\n-\t      _rl_last_c_pos -= wrap_offset;\n+\t      _rl_last_c_pos -= wrap_offset;\t/* XXX - prompt_invis_chars_first_line? */\n \t      cpos_adjusted = 1;\n \t    }\n \t  return;\n@@ -1877,7 +2063,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t and set cpos_adjusted to let the caller know. */\n \t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t\t{\n-\t\t  _rl_last_c_pos -= wrap_offset;\n+\t\t  _rl_last_c_pos -= wrap_offset;\t/* XXX - prompt_invis_chars_first_line? */\n \t\t  cpos_adjusted = 1;\n \t\t}\n \t      return;\n@@ -1890,7 +2076,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t and set cpos_adjusted to let the caller know. */\n \t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t\t{\n-\t\t  _rl_last_c_pos -= wrap_offset;\n+\t\t  _rl_last_c_pos -= wrap_offset;\t/* XXX - prompt_invis_chars_first_line? */\n \t\t  cpos_adjusted = 1;\n \t\t}\n \t    }\n@@ -1957,12 +2143,26 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t  _rl_last_c_pos += _rl_col_width (nfd, 0, bytes_to_insert, 1);\n \t\t  if (current_line == 0 && wrap_offset &&\n \t\t\tdisplaying_prompt_first_line &&\n-\t\t\t_rl_last_c_pos > wrap_offset &&\n+\t\t\t_rl_last_c_pos >= wrap_offset &&\t/* XXX was > */\n \t\t\t((nfd - new) <= prompt_last_invisible))\n \t\t    {\n-\t\t      _rl_last_c_pos -= wrap_offset;\n+\t\t      _rl_last_c_pos -= wrap_offset;\t/* XXX - prompt_invis_chars_first_line? */\n \t\t      cpos_adjusted = 1;\n \t\t    }\n+\n+#if 1\n+#ifdef HANDLE_MULTIBYTE\n+\t\t  /* If we write a non-space into the last screen column,\n+\t\t     remove the note that we added a space to compensate for\n+\t\t     a multibyte double-width character that didn't fit, since\n+\t\t     it's only valid for what was previously there. */\n+\t\t  /* XXX - watch this */\n+\t\t  if (_rl_last_c_pos == _rl_screenwidth &&\n+\t\t\tline_state_invisible->wrapped_line[current_line+1] &&\n+\t\t\tnfd[bytes_to_insert-1] != ' ')\n+\t\t    line_state_invisible->wrapped_line[current_line+1] = 0;\n+#endif\n+#endif\n \t\t}\n \t      else\n \t\t_rl_last_c_pos += bytes_to_insert;\n@@ -1994,7 +2194,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t\t_rl_last_c_pos > wrap_offset &&\n \t\t\t((nfd - new) <= prompt_last_invisible))\n \t\t    {\n-\t\t      _rl_last_c_pos -= wrap_offset;\n+\t\t      _rl_last_c_pos -= wrap_offset;\t/* XXX - prompt_invis_chars_first_line? */\n \t\t      cpos_adjusted = 1;\n \t\t    }\n \t\t}\n@@ -2024,7 +2224,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \n /* Tell the update routines that we have moved onto a new (empty) line. */\n int\n-rl_on_new_line ()\n+rl_on_new_line (void)\n {\n   if (visible_line)\n     visible_line[0] = '\\0';\n@@ -2040,7 +2240,7 @@ rl_on_new_line ()\n /* Clear all screen lines occupied by the current readline line buffer\n    (visible line) */\n int\n-rl_clear_visible_line ()\n+rl_clear_visible_line (void)\n {\n   int curr_line;\n \n@@ -2068,9 +2268,10 @@ rl_clear_visible_line ()\n /* Tell the update routines that we have moved onto a new line with the\n    prompt already displayed.  Code originally from the version of readline\n    distributed with CLISP.  rl_expand_prompt must have already been called\n-   (explicitly or implicitly).  This still doesn't work exactly right. */\n+   (explicitly or implicitly).  This still doesn't work exactly right; it\n+   should use expand_prompt() */\n int\n-rl_on_new_line_with_prompt ()\n+rl_on_new_line_with_prompt (void)\n {\n   int prompt_size, i, l, real_screenwidth, newlines;\n   char *prompt_last_line, *lprompt;\n@@ -2126,7 +2327,7 @@ rl_on_new_line_with_prompt ()\n \n /* Actually update the display, period. */\n int\n-rl_forced_update_display ()\n+rl_forced_update_display (void)\n {\n   register char *temp;\n \n@@ -2144,7 +2345,7 @@ rl_forced_update_display ()\n \n /* Redraw only the last line of a multi-line prompt. */\n void\n-rl_redraw_prompt_last_line ()\n+rl_redraw_prompt_last_line (void)\n {\n   char *t;\n \n@@ -2162,9 +2363,7 @@ rl_redraw_prompt_last_line ()\n    the movement is being done.\n    DATA is always the visible line or the invisible line */\n void\n-_rl_move_cursor_relative (new, data)\n-     int new;\n-     const char *data;\n+_rl_move_cursor_relative (int new, const char *data)\n {\n   register int i;\n   int woff;\t\t\t/* number of invisible chars on current line */\n@@ -2321,8 +2520,7 @@ _rl_move_cursor_relative (new, data)\n \n /* PWP: move the cursor up or down. */\n void\n-_rl_move_vert (to)\n-     int to;\n+_rl_move_vert (int to)\n {\n   register int delta, i;\n \n@@ -2362,8 +2560,7 @@ _rl_move_vert (to)\n /* Physically print C on rl_outstream.  This is for functions which know\n    how to optimize the display.  Return the number of characters output. */\n int\n-rl_show_char (c)\n-     int c;\n+rl_show_char (int c)\n {\n   int n = 1;\n   if (META_CHAR (c) && (_rl_output_meta_chars == 0))\n@@ -2390,8 +2587,7 @@ rl_show_char (c)\n }\n \n int\n-rl_character_len (c, pos)\n-     register int c, pos;\n+rl_character_len (int c, int pos)\n {\n   unsigned char uc;\n \n@@ -2526,7 +2722,7 @@ rl_message (format, arg1, arg2)\n \n /* How to clear things from the \"echo-area\". */\n int\n-rl_clear_message ()\n+rl_clear_message (void)\n {\n   rl_display_prompt = rl_prompt;\n   if (msg_saved_prompt)\n@@ -2539,7 +2735,7 @@ rl_clear_message ()\n }\n \n int\n-rl_reset_line_state ()\n+rl_reset_line_state (void)\n {\n   rl_on_new_line ();\n \n@@ -2548,8 +2744,12 @@ rl_reset_line_state ()\n   return 0;\n }\n \n+/* Save all of the variables associated with the prompt and its display. Most\n+   of the complexity is dealing with the invisible characters in the prompt\n+   string and where they are. There are enough of these that I should consider\n+   a struct. */\n void\n-rl_save_prompt ()\n+rl_save_prompt (void)\n {\n   saved_local_prompt = local_prompt;\n   saved_local_prefix = local_prompt_prefix;\n@@ -2559,22 +2759,28 @@ rl_save_prompt ()\n   saved_visible_length = prompt_visible_length;\n   saved_invis_chars_first_line = prompt_invis_chars_first_line;\n   saved_physical_chars = prompt_physical_chars;\n+  saved_local_prompt_newlines = local_prompt_newlines;\n \n   local_prompt = local_prompt_prefix = (char *)0;\n   local_prompt_len = 0;\n+  local_prompt_newlines = (int *)0;\n+\n   prompt_last_invisible = prompt_visible_length = prompt_prefix_length = 0;\n   prompt_invis_chars_first_line = prompt_physical_chars = 0;\n }\n \n void\n-rl_restore_prompt ()\n+rl_restore_prompt (void)\n {\n   FREE (local_prompt);\n   FREE (local_prompt_prefix);\n+  FREE (local_prompt_newlines);\n \n   local_prompt = saved_local_prompt;\n   local_prompt_prefix = saved_local_prefix;\n   local_prompt_len = saved_local_length;\n+  local_prompt_newlines = saved_local_prompt_newlines;\n+\n   prompt_prefix_length = saved_prefix_length;\n   prompt_last_invisible = saved_last_invisible;\n   prompt_visible_length = saved_visible_length;\n@@ -2586,11 +2792,11 @@ rl_restore_prompt ()\n   saved_local_length = 0;\n   saved_last_invisible = saved_visible_length = saved_prefix_length = 0;\n   saved_invis_chars_first_line = saved_physical_chars = 0;\n+  saved_local_prompt_newlines = 0;\n }\n \n char *\n-_rl_make_prompt_for_search (pchar)\n-     int pchar;\n+_rl_make_prompt_for_search (int pchar)\n {\n   int len;\n   char *pmt, *p;\n@@ -2628,8 +2834,7 @@ _rl_make_prompt_for_search (pchar)\n \n /* Quick redisplay hack when erasing characters at the end of the line. */\n void\n-_rl_erase_at_end_of_line (l)\n-     int l;\n+_rl_erase_at_end_of_line (int l)\n {\n   register int i;\n \n@@ -2643,10 +2848,10 @@ _rl_erase_at_end_of_line (l)\n }\n \n /* Clear to the end of the line.  COUNT is the minimum\n-   number of character spaces to clear, */\n+   number of character spaces to clear, but we use a terminal escape\n+   sequence if available. */\n void\n-_rl_clear_to_eol (count)\n-     int count;\n+_rl_clear_to_eol (int count)\n {\n #ifndef __MSDOS__\n   if (_rl_term_clreol)\n@@ -2660,36 +2865,33 @@ _rl_clear_to_eol (count)\n /* Clear to the end of the line using spaces.  COUNT is the minimum\n    number of character spaces to clear, */\n static void\n-space_to_eol (count)\n-     int count;\n+space_to_eol (int count)\n {\n   register int i;\n \n   for (i = 0; i < count; i++)\n-   putc (' ', rl_outstream);\n+    putc (' ', rl_outstream);\n \n   _rl_last_c_pos += count;\n }\n \n void\n-_rl_clear_screen ()\n+_rl_clear_screen (void)\n {\n-#ifndef __DJGPP__\n+#if defined (__DJGPP__)\n+  ScreenClear ();\n+  ScreenSetCursor (0, 0);\n+#else\n   if (_rl_term_clrpag)\n     tputs (_rl_term_clrpag, 1, _rl_output_character_function);\n   else\n     rl_crlf ();\n-#else\n-  ScreenClear ();\n-  ScreenSetCursor (0, 0);\n #endif /* __DJGPP__ */\n }\n \n /* Insert COUNT characters from STRING to the output stream at column COL. */\n static void\n-insert_some_chars (string, count, col)\n-     char *string;\n-     int count, col;\n+insert_some_chars (char *string, int count, int col)\n {\n   open_some_spaces (col);\n   _rl_output_some_chars (string, count);\n@@ -2699,8 +2901,7 @@ insert_some_chars (string, count, col)\n    ncurses documentation and use either im/ei with explicit spaces, or IC/ic\n    by itself.  We assume there will either be ei or we don't need to use it. */\n static void\n-open_some_spaces (col)\n-     int col;\n+open_some_spaces (int col)\n {\n #if !defined (__MSDOS__) && (!defined (__MINGW32__) || defined (NCURSES_VERSION))\n   char *buffer;\n@@ -2736,8 +2937,7 @@ open_some_spaces (col)\n \n /* Delete COUNT characters from the display line. */\n static void\n-delete_chars (count)\n-     int count;\n+delete_chars (int count)\n {\n   if (count > _rl_screenwidth)\t/* XXX */\n     return;\n@@ -2759,9 +2959,9 @@ delete_chars (count)\n }\n \n void\n-_rl_update_final ()\n+_rl_update_final (void)\n {\n-  int full_lines;\n+  int full_lines, woff, botline_length;\n \n   full_lines = 0;\n   /* If the cursor is the only thing on an otherwise-blank last line,\n@@ -2773,26 +2973,34 @@ _rl_update_final ()\n       full_lines = 1;\n     }\n   _rl_move_vert (_rl_vis_botlin);\n+  woff = W_OFFSET(_rl_vis_botlin, wrap_offset);\n+  botline_length = VIS_LLEN(_rl_vis_botlin) - woff;\n   /* If we've wrapped lines, remove the final xterm line-wrap flag. */\n-  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))\n+  if (full_lines && _rl_term_autowrap && botline_length == _rl_screenwidth)\n     {\n       char *last_line;\n \n-      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];\n+      /* LAST_LINE includes invisible characters, so if you want to get the\n+\t last character of the first line, you have to take WOFF into account.\n+\t This needs to be done for both calls to _rl_move_cursor_relative,\n+\t which takes a buffer position as the first argument, and any direct\n+\t subscripts of LAST_LINE. */\n+      last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]]; /* = VIS_CHARS(_rl_vis_botlin); */\n       cpos_buffer_position = -1;\t/* don't know where we are in buffer */\n-      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);\t/* XXX */\n+      _rl_move_cursor_relative (_rl_screenwidth - 1 + woff, last_line);\t/* XXX */\n       _rl_clear_to_eol (0);\n-      putc (last_line[_rl_screenwidth - 1], rl_outstream);\n+      putc (last_line[_rl_screenwidth - 1 + woff], rl_outstream);\n     }\n   _rl_vis_botlin = 0;\n-  rl_crlf ();\n+  if (botline_length > 0 || _rl_last_c_pos > 0)\n+    rl_crlf ();\n   fflush (rl_outstream);\n   rl_display_fixed++;\n }\n \n /* Move to the start of the current line. */\n static void\n-cr ()\n+cr (void)\n {\n   if (_rl_term_cr)\n     {\n@@ -2809,8 +3017,7 @@ cr ()\n    terminal escape sequences.  Called with the cursor at column 0 of the\n    line to draw the prompt on. */\n static void\n-redraw_prompt (t)\n-     char *t;\n+redraw_prompt (char *t)\n {\n   char *oldp;\n \n@@ -2834,7 +3041,7 @@ redraw_prompt (t)\n       \n /* Redisplay the current line after a SIGWINCH is received. */\n void\n-_rl_redisplay_after_sigwinch ()\n+_rl_redisplay_after_sigwinch (void)\n {\n   char *t;\n \n@@ -2879,7 +3086,7 @@ _rl_redisplay_after_sigwinch ()\n }\n \n void\n-_rl_clean_up_for_exit ()\n+_rl_clean_up_for_exit (void)\n {\n   if (_rl_echoing_p)\n     {\n@@ -2892,7 +3099,7 @@ _rl_clean_up_for_exit ()\n }\n \n void\n-_rl_erase_entire_line ()\n+_rl_erase_entire_line (void)\n {\n   cr ();\n   _rl_clear_to_eol (0);\n@@ -2901,15 +3108,15 @@ _rl_erase_entire_line ()\n }\n \n void\n-_rl_ttyflush ()\n+_rl_ttyflush (void)\n {\n   fflush (rl_outstream);\n }\n \n /* return the `current display line' of the cursor -- the number of lines to\n    move up to get to the first screen line of the current readline line. */\n int\n-_rl_current_display_line ()\n+_rl_current_display_line (void)\n {\n   int ret, nleft;\n \n@@ -2933,9 +3140,7 @@ _rl_current_display_line ()\n    In the case of multibyte characters with stateful encoding, we have to\n    scan from the beginning of the string to take the state into account. */\n static int\n-_rl_col_width (str, start, end, flags)\n-     const char *str;\n-     int start, end, flags;\n+_rl_col_width (const char *str, int start, int end, int flags)\n {\n   wchar_t wc;\n   mbstate_t ps;\n@@ -2968,7 +3173,13 @@ _rl_col_width (str, start, end, flags)\n \n   while (point < start)\n     {\n-      tmp = mbrlen (str + point, max, &ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(str[point]))\n+\t{\n+\t  memset (&ps, 0, sizeof (mbstate_t));\n+\t  tmp = 1;\n+\t}\n+      else\n+\ttmp = mbrlen (str + point, max, &ps);\n       if (MB_INVALIDCH ((size_t)tmp))\n \t{\n \t  /* In this case, the bytes are invalid or too short to compose a\n@@ -2997,7 +3208,13 @@ _rl_col_width (str, start, end, flags)\n \n   while (point < end)\n     {\n-      tmp = mbrtowc (&wc, str + point, max, &ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(str[point]))\n+\t{\n+\t  tmp = 1;\n+\t  wc = (wchar_t) str[point];\n+\t}\n+      else\n+\ttmp = mbrtowc (&wc, str + point, max, &ps);\n       if (MB_INVALIDCH ((size_t)tmp))\n \t{\n \t  /* In this case, the bytes are invalid or too short to compose a"
    },
    {
      "sha": "8de64f63cbce053921f4f3a9790e4b090d8de147",
      "filename": "readline/doc/history.3",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/history.3",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/history.3",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/history.3?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -6,9 +6,9 @@\n .\\\"\tCase Western Reserve University\n .\\\"\tchet.ramey@case.edu\n .\\\"\n-.\\\"\tLast Change: Sun May 24 18:01:17 EDT 2015\n+.\\\"\tLast Change: Sun Oct  8 11:43:43 EDT 2017\n .\\\"\n-.TH HISTORY 3 \"2015 May 24\" \"GNU History 6.3\"\n+.TH HISTORY 3 \"2017 October 8\" \"GNU History 6.3\"\n .\\\"\n .\\\" File Name macro.  This used to be `.PN', for Path Name,\n .\\\" but Sun doesn't seem to like that very much.\n@@ -40,8 +40,8 @@\n .SH NAME\n history \\- GNU History Library\n .SH COPYRIGHT\n-.if t The GNU History Library is Copyright \\(co 1989-2014 by the Free Software Foundation, Inc.\n-.if n The GNU History Library is Copyright (C) 1989-2014 by the Free Software Foundation, Inc.\n+.if t The GNU History Library is Copyright \\(co 1989-2017 by the Free Software Foundation, Inc.\n+.if n The GNU History Library is Copyright (C) 1989-2017 by the Free Software Foundation, Inc.\n .SH DESCRIPTION\n Many programs read input from the user a line at a time.  The GNU\n History library is able to keep track of those lines, associate arbitrary\n@@ -356,6 +356,9 @@ parameters managing the list itself.\n .Fn1 void add_history \"const char *string\"\n Place \\fIstring\\fP at the end of the history list.  The associated data\n field (if any) is set to \\fBNULL\\fP.\n+If the maximum number of history entries has been set using\n+\\fBstifle_history()\\fP, and the new number of history entries would exceed\n+that maximum, the oldest history entry is removed.\n \n .Fn1 void add_history_time \"const char *string\"\n Change the time stamp associated with the most recent history entry to\n@@ -382,6 +385,7 @@ Clear the history list by deleting all the entries.\n \n .Fn1 void stifle_history \"int max\"\n Stifle the history list, remembering only the last \\fImax\\fP entries.\n+The history list will contain only \\fImax\\fP entries at a time.\n \n .Fn1 int unstifle_history \"void\"\n Stop stifling the history.  This returns the previously-set\n@@ -411,10 +415,11 @@ Return the history entry at the current position, as determined by\n pointer.\n \n .Fn1 \"HIST_ENTRY *\" history_get \"int offset\"\n-Return the history entry at position \\fIoffset\\fP, starting from\n-\\fBhistory_base\\fP.\n-If there is no entry there, or if \\fIoffset\\fP\n-is greater than the history length, return a \\fBNULL\\fP pointer.\n+Return the history entry at position \\fIoffset\\fP.\n+The range of valid values of \\fIoffset\\fP starts at \\fBhistory_base\\fP\n+and ends at \\fBhistory_length\\fP \\- 1.\n+If there is no entry there, or if \\fIoffset\\fP is outside the valid\n+range, return a \\fBNULL\\fP pointer.\n \n .Fn1 \"time_t\" history_get_time \"HIST_ENTRY *\"\n Return the time stamp associated with the history entry passed as the argument."
    },
    {
      "sha": "dbc21c14d9c870428828b4f9f9047e6ee93d690f",
      "filename": "readline/doc/hstech.texi",
      "status": "modified",
      "additions": 29,
      "deletions": 7,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/hstech.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/hstech.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/hstech.texi?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -166,6 +166,9 @@ parameters managing the list itself.\n @deftypefun void add_history (const char *string)\n Place @var{string} at the end of the history list.  The associated data\n field (if any) is set to @code{NULL}.\n+If the maximum number of history entries has been set using\n+@code{stifle_history()}, and the new number of history entries would exceed\n+that maximum, the oldest history entry is removed.\n @end deftypefun\n \n @deftypefun void add_history_time (const char *string)\n@@ -198,6 +201,7 @@ Clear the history list by deleting all the entries.\n \n @deftypefun void stifle_history (int max)\n Stifle the history list, remembering only the last @var{max} entries.\n+The history list will contain only @var{max} entries at a time.\n @end deftypefun\n \n @deftypefun int unstifle_history (void)\n@@ -234,10 +238,12 @@ pointer.\n @end deftypefun\n \n @deftypefun {HIST_ENTRY *} history_get (int offset)\n-Return the history entry at position @var{offset}, starting from\n-@code{history_base} (@pxref{History Variables}).\n-If there is no entry there, or if @var{offset}\n-is greater than the history length, return a @code{NULL} pointer.\n+Return the history entry at position @var{offset}.\n+The range of valid\n+values of @var{offset} starts at @code{history_base} and ends at\n+@var{history_length} - 1 (@pxref{History Variables}).\n+If there is no entry there, or if @var{offset} is outside the valid\n+range, return a @code{NULL} pointer.\n @end deftypefun\n \n @deftypefun time_t history_get_time (HIST_ENTRY *entry)\n@@ -397,7 +403,7 @@ to the ``normal'' terminating characters.\n Return an array of tokens parsed out of @var{string}, much as the\n shell might.  The tokens are split on the characters in the\n @var{history_word_delimiters} variable,\n-and shell quoting conventions are obeyed.\n+and shell quoting conventions are obeyed as described below.\n @end deftypefun\n \n @deftypefun {char *} history_arg_extract (int first, int last, const char *string)\n@@ -470,8 +476,24 @@ carriage return, and @samp{=}.\n @end deftypevar\n \n @deftypevar int history_quotes_inhibit_expansion\n-If non-zero, double-quoted words are not scanned for the history expansion\n-character or the history comment character.  The default value is 0.\n+If non-zero, the history expansion code implements shell-like quoting:\n+single-quoted words are not scanned for the history expansion\n+character or the history comment character, and double-quoted words may\n+have history expansion performed, since single quotes are not special\n+within double quotes.\n+The default value is 0.\n+@end deftypevar\n+\n+@deftypevar int history_quoting_state\n+An application may set this variable to indicate that the current line\n+being expanded is subject to existing quoting. If set to @samp{'}, the\n+history expansion function will assume that the line is single-quoted and\n+inhibit expansion until it reads an unquoted closing single quote; if set\n+to @samp{\"}, history expansion will assume the line is double quoted until\n+it reads an unquoted closing double quote. If set to zero, the default,\n+the history expansion function will assume the line is not quoted and\n+treat quote characters within the line as described above.\n+This is only effective if @var{history_quotes_inhibit_expansion} is set.\n @end deftypevar\n \n @deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function"
    },
    {
      "sha": "e92c794b39cdd184cad60be051bfcd19d49bb2d3",
      "filename": "readline/doc/hsuser.texi",
      "status": "modified",
      "additions": 32,
      "deletions": 10,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/hsuser.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/hsuser.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/hsuser.texi?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n @ignore\n This file documents the user interface to the GNU History library.\n \n-Copyright (C) 1988--2016 Free Software Foundation, Inc.\n+Copyright (C) 1988--2018 Free Software Foundation, Inc.\n Authored by Brian Fox and Chet Ramey.\n \n Permission is granted to make and distribute verbatim copies of this manual\n@@ -126,7 +126,7 @@ The @code{lithist}\n shell option causes the shell to save the command with embedded newlines\n instead of semicolons.\n The @code{shopt} builtin is used to set these options.\n-@xref{Bash Builtins}, for a description of @code{shopt}.\n+@xref{The Shopt Builtin}, for a description of @code{shopt}.\n \n @node Bash History Builtins\n @section Bash History Builtins\n@@ -151,8 +151,8 @@ Both @var{first} and\n @var{last} may be specified as a string (to locate the most recent\n command beginning with that string) or as a number (an index into the\n history list, where a negative number is used as an offset from the\n-current command number).  If @var{last} is not specified it is set to\n-@var{first}.  If @var{first} is not specified it is set to the previous\n+current command number).  If @var{last} is not specified, it is set to\n+@var{first}.  If @var{first} is not specified, it is set to the previous\n command for editing and @minus{}16 for listing.  If the @option{-l} flag is\n given, the commands are listed on standard output.  The @option{-n} flag\n suppresses the command numbers when listing.  The @option{-r} flag\n@@ -178,6 +178,7 @@ and typing @samp{r} re-executes the last command (@pxref{Aliases}).\n history [@var{n}]\n history -c\n history -d @var{offset}\n+history -d @var{start}-@var{end}\n history [-anrw] [@var{filename}]\n history -ps @var{arg}\n @end example\n@@ -200,8 +201,17 @@ with the other options to replace the history list completely.\n \n @item -d @var{offset}\n Delete the history entry at position @var{offset}.\n-@var{offset} should be specified as it appears when the history is\n-displayed.\n+If @var{offset} is positive, it should be specified as it appears when\n+the history is displayed.\n+If @var{offset} is negative, it is interpreted as relative to one greater\n+than the last history position, so negative indices count back from the\n+end of the history, and an index of @samp{-1} refers to the current\n+@code{history -d} command.\n+\n+@item -d @var{start}-@var{end}\n+Delete the history entries between positions @var{start} and @var{end},\n+inclusive.  Positive and negative values for @var{start} and @var{end}\n+are interpreted as described above.\n \n @item -a\n Append the new history lines to the history file.\n@@ -253,7 +263,9 @@ fix errors in previous commands quickly.\n \n @ifset BashFeatures\n History expansion is performed immediately after a complete line\n-is read, before the shell breaks it into words.\n+is read, before the shell breaks it into words, and is performed\n+on each line individually.  Bash attempts to inform the history\n+expansion functions about quoting still in effect from previous lines.\n @end ifset\n \n History expansion takes place in two parts.  The first is to determine\n@@ -267,16 +279,26 @@ that Bash does, so that several words\n surrounded by quotes are considered one word.\n History expansions are introduced by the appearance of the\n history expansion character, which is @samp{!} by default.\n+\n+History expansion implements shell-like quoting conventions:\n+a backslash can be used to remove the special handling for the next character;\n+single quotes enclose verbatim sequences of characters, and can be used to\n+inhibit history expansion;\n+and characters enclosed within double quotes may be subject to history\n+expansion, since backslash can escape the history expansion character,\n+but single quotes may not, since they are not treated specially within\n+double quotes.\n+\n @ifset BashFeatures\n-Only @samp{\\} and @samp{'} may be used to escape the history expansion\n-character, but the history expansion character is\n+When using the shell, only @samp{\\} and @samp{'} may be used to escape the\n+history expansion character, but the history expansion character is\n also treated as quoted if it immediately precedes the closing double quote\n in a double-quoted string. \n @end ifset\n \n @ifset BashFeatures\n Several shell options settable with the @code{shopt}\n-builtin (@pxref{Bash Builtins}) may be used to tailor\n+builtin (@pxref{The Shopt Builtin}) may be used to tailor\n the behavior of history expansion.  If the\n @code{histverify} shell option is enabled, and Readline\n is being used, history substitutions are not immediately passed to"
    },
    {
      "sha": "be89c2dff870e1c30cd7f4ff1fc74fca813f0c39",
      "filename": "readline/doc/readline.3",
      "status": "modified",
      "additions": 70,
      "deletions": 22,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/readline.3",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/readline.3",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/readline.3?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -6,9 +6,9 @@\n .\\\"\tCase Western Reserve University\n .\\\"\tchet.ramey@case.edu\n .\\\"\n-.\\\"\tLast Change: Sun Feb 28 15:42:34 EST 2016\n+.\\\"\tLast Change: Thu Dec 28 14:49:51 EST 2017\n .\\\"\n-.TH READLINE 3 \"2016 February 28\" \"GNU Readline 7.0\"\n+.TH READLINE 3 \"2017 December 28\" \"GNU Readline 7.0\"\n .\\\"\n .\\\" File Name macro.  This used to be `.PN', for Path Name,\n .\\\" but Sun doesn't seem to like that very much.\n@@ -378,13 +378,13 @@ in emacs mode and to\n .B #\n in vi command mode.\n .TP\n-.B completion\\-display\\-width (-1)\n+.B completion\\-display\\-width (\\-1)\n The number of screen columns used to display possible matches\n when performing completion.\n The value is ignored if it is less than 0 or greater than the terminal\n screen width.\n A value of 0 will cause matches to be displayed one per line.\n-The default value is -1.\n+The default value is \\-1.\n .TP \n .B completion\\-ignore\\-case (Off)\n If set to \\fBOn\\fP, readline performs filename matching and completion\n@@ -438,6 +438,16 @@ can be set to either\n or\n .BR vi .\n .TP\n+.B emacs\\-mode\\-string (@)\n+If the \\fIshow\\-mode\\-in\\-prompt\\fP variable is enabled, \n+this string is displayed immediately before the last line of the primary\n+prompt when emacs editing mode is active.  The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the \\e1 and \\e2 escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control \n+sequence into the mode string.\n+.TP\n .B enable\\-bracketed\\-paste (Off)\n When set to \\fBOn\\fP, readline will configure the terminal in a way\n that will enable it to insert each paste into the editing buffer as a\n@@ -506,15 +516,6 @@ The value of\n .B editing\\-mode\n also affects the default keymap.\n .TP\n-.B emacs\\-mode\\-string (@)\n-This string is displayed immediately before the last line of the primary\n-prompt when emacs editing mode is active.  The value is expanded like a\n-key binding, so the standard set of meta- and control prefixes and\n-backslash escape sequences is available.\n-Use the \\e1 and \\e2 escapes to begin and end sequences of\n-non-printing characters, which can be used to embed a terminal control \n-sequence into the mode string.\n-.TP\n .B keyseq\\-timeout (500)\n Specifies the duration \\fIreadline\\fP will wait for a character when reading an\n ambiguous key sequence (one that can form a complete key sequence using\n@@ -592,9 +593,9 @@ a common prefix) cause the matches to be listed immediately instead\n of ringing the bell.\n .TP\n .B show\\-mode\\-in\\-prompt (Off)\n-If set to \\fBOn\\fP, add a character to the beginning of the prompt\n+If set to \\fBOn\\fP, add a string to the beginning of the prompt\n indicating the editing mode: emacs, vi command, or vi insertion.\n-The mode strings are user-settable.\n+The mode strings are user-settable (e.g., \\fIemacs\\-mode\\-string\\fP).\n .TP\n .B skip\\-completed\\-text (Off)\n If set to \\fBOn\\fP, this alters the default completion behavior when\n@@ -605,7 +606,8 @@ after point in the word being completed, so portions of the word\n following the cursor are not duplicated.\n .TP\n .B vi\\-cmd\\-mode\\-string ((cmd))\n-This string is displayed immediately before the last line of the primary\n+If the \\fIshow\\-mode\\-in\\-prompt\\fP variable is enabled, \n+this string is displayed immediately before the last line of the primary\n prompt when vi editing mode is active and in command mode.\n The value is expanded like a\n key binding, so the standard set of meta- and control prefixes and\n@@ -615,7 +617,8 @@ non-printing characters, which can be used to embed a terminal control\n sequence into the mode string.\n .TP\n .B vi\\-ins\\-mode\\-string ((ins))\n-This string is displayed immediately before the last line of the primary\n+If the \\fIshow\\-mode\\-in\\-prompt\\fP variable is enabled, \n+this string is displayed immediately before the last line of the primary\n prompt when vi editing mode is active and in insertion mode.  \n The value is expanded like a\n key binding, so the standard set of meta- and control prefixes and  \n@@ -640,8 +643,9 @@ The\n .B $if\n construct allows bindings to be made based on the\n editing mode, the terminal being used, or the application using\n-readline.  The text of the test extends to the end of the line;\n-no characters are required to isolate it.\n+readline.  The text of the test, after any comparison operator,\n+extends to the end of the line;\n+unless otherwise noted, no characters are required to isolate it.\n .RS\n .IP \\fBmode\\fP\n The \\fBmode=\\fP form of the \\fB$if\\fP directive is used to test\n@@ -663,6 +667,26 @@ to match both\n and\n .IR sun\\-cmd ,\n for instance.\n+.IP \\fBversion\\fP\n+The \\fBversion\\fP test may be used to perform comparisons against\n+specific readline versions.\n+The \\fBversion\\fP expands to the current readline version.\n+The set of comparison operators includes\n+.BR = ,\n+(and\n+.BR == ),\n+.BR != ,\n+.BR <= ,\n+.BR >= ,\n+.BR < ,\n+and\n+.BR > .\n+The version number supplied on the right side of the operator consists\n+of a major version number, an optional decimal point, and an optional\n+minor version (e.g., \\fB7.1\\fP). If the minor version is omitted, it\n+is assumed to be \\fB0\\fP.\n+The operator may be separated from the string \\fBversion\\fP\n+and from the version number argument by whitespace.\n .IP \\fBapplication\\fP\n The \\fBapplication\\fP construct is used to include\n application-specific settings.  Each program using the readline\n@@ -680,6 +704,15 @@ key sequence that quotes the current or previous word in \\fBbash\\fP:\n \\fB$endif\\fP\n .fi\n .RE\n+.IP \\fIvariable\\fP\n+The \\fIvariable\\fP construct provides simple equality tests for readline\n+variables and values.\n+The permitted comparison operators are \\fI=\\fP, \\fI==\\fP, and \\fI!=\\fP.\n+The variable name must be separated from the comparison operator by\n+whitespace; the operator may be separated from the value on the right hand\n+side by whitespace.\n+Both string and boolean variables may be tested. Boolean variables must be\n+tested against the values \\fIon\\fP and \\fIoff\\fP.\n .RE\n .IP \\fB$endif\\fP\n This command, as seen in the previous example, terminates an\n@@ -771,6 +804,19 @@ alphanumeric characters (letters and digits).\n Move back to the start of the current or previous word.  Words are\n composed of alphanumeric characters (letters and digits).\n .TP\n+.B previous\\-screen\\-line\n+Attempt to move point to the same physical screen column on the previous\n+physical screen line. This will not have the desired effect if the current\n+Readline line does not take up more than one physical line or if point is not\n+greater than the length of the prompt plus the screen width.\n+.TP\n+.B next\\-screen\\-line\n+Attempt to move point to the same physical screen column on the next\n+physical screen line. This will not have the desired effect if the current\n+Readline line does not take up more than one physical line or if the length\n+of the current Readline line is not greater than the length of the prompt\n+plus the screen width.\n+.TP\n .B clear\\-screen (C\\-l)\n Clear the screen leaving the current line at the top of the screen.\n With an argument, refresh the current line without clearing the\n@@ -1103,6 +1149,7 @@ and store the definition.\n .B call\\-last\\-kbd\\-macro (C\\-x e)\n Re-execute the last keyboard macro defined, by making the characters\n in the macro appear as if typed at the keyboard.\n+.TP\n .B print\\-last\\-kbd\\-macro ()\n Print the last keyboard macro defined in a format suitable for the\n \\fIinputrc\\fP file.\n@@ -1120,9 +1167,10 @@ Abort the current editing command and\n ring the terminal's bell (subject to the setting of\n .BR bell\\-style ).\n .TP\n-.B do\\-uppercase\\-version (M\\-a, M\\-b, M\\-\\fIx\\fP, ...)\n-If the metafied character \\fIx\\fP is lowercase, run the command\n-that is bound to the corresponding uppercase character.\n+.B do\\-lowercase\\-version (M\\-A, M\\-B, M\\-\\fIx\\fP, ...)\n+If the metafied character \\fIx\\fP is uppercase, run the command\n+that is bound to the corresponding metafied lowercase character.\n+The behavior is undefined if \\fIx\\fP is already lowercase.\n .TP\n .B prefix\\-meta (ESC)\n Metafy the next character typed."
    },
    {
      "sha": "28a02d99607344761b34c53f2ebc8b1100a3fe9a",
      "filename": "readline/doc/rltech.texi",
      "status": "modified",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/rltech.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/rltech.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rltech.texi?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -90,6 +90,12 @@ If @code{readline} encounters an @code{EOF} while reading the line, and the\n line is empty at that point, then @code{(char *)NULL} is returned.\n Otherwise, the line is ended just as if a newline had been typed.\n \n+Readline performs some expansion on the @var{prompt} before it is\n+displayed on the screen.  See the description of @code{rl_expand_prompt}\n+(@pxref{Redisplay}) for additional details, especially if @var{prompt}\n+will contain characters that do not consume physical screen space when\n+displayed.\n+\n If you want the user to be able to get at the line later, (with\n @key{C-p} for example), you must call @code{add_history()} to save the\n line away in a @dfn{history} list of such lines.\n@@ -688,6 +694,11 @@ Free all storage associated with @var{keymap}.  This calls\n @code{rl_discard_keymap} to free subordindate keymaps and macros.\n @end deftypefun\n \n+@deftypefun int rl_empty_keymap (Keymap keymap)\n+Return non-zero if there are no keys bound to functions in @var{keymap};\n+zero if there are any keys bound.\n+@end deftypefun\n+\n Readline has several internal keymaps.  These functions allow you to\n change which keymap is active.\n \n@@ -709,6 +720,24 @@ Return the name matching @var{keymap}.  @var{name} is one which would\n be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).\n @end deftypefun\n \n+@deftypefun int rl_set_keymap_name (const char *name, Keymap keymap)\n+Set the name of @var{keymap}.  This name will then be \"registered\" and\n+available for use in a @code{set keymap} inputrc directive\n+@pxref{Readline Init File}).\n+The @var{name} may not be one of Readline's builtin keymap names;\n+you may not add a different name for one of Readline's builtin keymaps.\n+You may replace the name associated with a given keymap by calling this\n+function more than once with the same @var{keymap} argument.\n+You may associate a registered @var{name} with a new keymap by calling this\n+function more than once  with the same @var{name} argument.\n+There is no way to remove a named keymap once the name has been\n+registered.\n+Readline will make a copy of @var{name}.\n+The return value is greater than zero unless @var{name} is one of\n+Readline's builtin keymap names or @var{keymap} is one of Readline's\n+builtin keymaps.\n+@end deftypefun\n+\n @node Binding Keys\n @subsection Binding Keys\n \n@@ -835,6 +864,16 @@ Return the function invoked by @var{keyseq} in keymap @var{map}.\n If @var{map} is @code{NULL}, the current keymap is used.  If @var{type} is\n not @code{NULL}, the type of the object is returned in the @code{int} variable\n it points to (one of @code{ISFUNC}, @code{ISKMAP}, or @code{ISMACR}).\n+It takes a \"translated\" key sequence and should not be used if the key sequence\n+can include NUL.\n+@end deftypefun\n+\n+@deftypefun {rl_command_func_t *} rl_function_of_keyseq_len (const char *keyseq, size_t len, Keymap map, int *type)\n+Return the function invoked by @var{keyseq} of length @var{len}\n+in keymap @var{map}. Equivalent to @code{rl_function_of_keyseq} with the\n+addition of the @var{len} parameter.\n+It takes a \"translated\" key sequence and should be used if the key sequence\n+can include NUL.\n @end deftypefun\n \n @deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)\n@@ -1679,6 +1718,19 @@ handlers, depending on the values of @code{rl_catch_signals} and\n @code{rl_catch_sigwinch}.\n @end deftypefun\n \n+If an application wants to force Readline to handle any signals that\n+have arrived while it has been executing, @code{rl_check_signals()}\n+will call Readline's internal signal handler if there are any pending\n+signals.  This is primarily intended for those applications that use\n+a custom @code{rl_getc_function} (@pxref{Readline Variables}) and wish\n+to handle signals received while waiting for input.\n+\n+@deftypefun void rl_check_signals (void)\n+If there are any pending signals, call Readline's internal signal handling\n+functions to process them. @code{rl_pending_signal()} can be used independently\n+to determine whether or not there are any pending signals.\n+@end deftypefun\n+\n If an application does not wish Readline to catch @code{SIGWINCH}, it may\n call @code{rl_resize_terminal()} or @code{rl_set_screen_size()} to force\n Readline to update its idea of the terminal size when a @code{SIGWINCH}\n@@ -2094,6 +2146,8 @@ character (@samp{\\0}) prevents anything being appended automatically.\n This can be changed in application-specific completion functions to\n provide the ``most sensible word separator character'' according to\n an application-specific command line syntax specification.\n+It is set to the default before any application-specific completion function\n+is called, and may only be changed within such a function.\n @end deftypevar\n \n @deftypevar int rl_completion_suppress_append"
    },
    {
      "sha": "a59bd144633f9707506b822828d070575607c719",
      "filename": "readline/doc/rluser.texi",
      "status": "modified",
      "additions": 110,
      "deletions": 33,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/rluser.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/rluser.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rluser.texi?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -475,6 +475,7 @@ The default value is @samp{off}.\n If set to @samp{on}, and @var{completion-ignore-case} is enabled, Readline\n treats hyphens (@samp{-}) and underscores (@samp{_}) as equivalent when\n performing case-insensitive filename matching and completion.\n+The default value is @samp{off}.\n \n @item completion-prefix-display-length\n @vindex completion-prefix-display-length\n@@ -524,7 +525,8 @@ set to either @samp{emacs} or @samp{vi}.\n \n @item emacs-mode-string\n @vindex emacs-mode-string\n-This string is displayed immediately before the last line of the primary\n+If the @var{show-mode-in-prompt} variable is enabled,\n+this string is displayed immediately before the last line of the primary\n prompt when emacs editing mode is active.  The value is expanded like a\n key binding, so the standard set of meta- and control prefixes and\n backslash escape sequences is available.\n@@ -604,7 +606,7 @@ If this variable has not been given a value, the characters @key{ESC} and\n @item keymap\n @vindex keymap\n Sets Readline's idea of the current keymap for key binding commands.\n-Acceptable @code{keymap} names are\n+Built-in @code{keymap} names are\n @code{emacs},\n @code{emacs-standard},\n @code{emacs-meta},\n@@ -615,6 +617,7 @@ Acceptable @code{keymap} names are\n @code{vi-insert}.\n @code{vi} is equivalent to @code{vi-command} (@code{vi-move} is also a\n synonym); @code{emacs} is equivalent to @code{emacs-standard}.\n+Applications may add additional names.\n The default value is @code{emacs}.\n The value of the @code{editing-mode} variable also affects the\n default keymap.\n@@ -714,9 +717,9 @@ The default value is @samp{off}.\n \n @item show-mode-in-prompt\n @vindex show-mode-in-prompt\n-If set to @samp{on}, add a character to the beginning of the prompt\n+If set to @samp{on}, add a string to the beginning of the prompt\n indicating the editing mode: emacs, vi command, or vi insertion.\n-The mode strings are user-settable.\n+The mode strings are user-settable (e.g., @var{emacs-mode-string}).\n The default value is @samp{off}.\n \n @item skip-completed-text\n@@ -735,7 +738,8 @@ The default value is @samp{off}.\n \n @item vi-cmd-mode-string\n @vindex vi-cmd-mode-string\n-This string is displayed immediately before the last line of the primary\n+If the @var{show-mode-in-prompt} variable is enabled,\n+this string is displayed immediately before the last line of the primary\n prompt when vi editing mode is active and in command mode.\n The value is expanded like a\n key binding, so the standard set of meta- and control prefixes and\n@@ -747,7 +751,8 @@ The default is @samp{(cmd)}.\n \n @item vi-ins-mode-string\n @vindex vi-ins-mode-string\n-This string is displayed immediately before the last line of the primary\n+If the @var{show-mode-in-prompt} variable is enabled,\n+this string is displayed immediately before the last line of the primary\n prompt when vi editing mode is active and in insertion mode.\n The value is expanded like a\n key binding, so the standard set of meta- and control prefixes and\n@@ -799,7 +804,7 @@ Meta-Rubout: backward-kill-word\n Control-o: \"> output\"\n @end example\n \n-In the above example, @kbd{C-u} is bound to the function\n+In the example above, @kbd{C-u} is bound to the function\n @code{universal-argument},\n @kbd{M-DEL} is bound to the function @code{backward-kill-word}, and\n @kbd{C-o} is bound to run the macro\n@@ -914,8 +919,9 @@ of tests.  There are four parser directives used.\n @item $if\n The @code{$if} construct allows bindings to be made based on the\n editing mode, the terminal being used, or the application using\n-Readline.  The text of the test extends to the end of the line;\n-no characters are required to isolate it.\n+Readline.  The text of the test, after any comparison operator,\n+extends to the end of the line;\n+unless otherwise noted, no characters are required to isolate it.\n \n @table @code\n @item mode\n@@ -935,6 +941,27 @@ the portion of the terminal name before the first @samp{-}.  This\n allows @code{sun} to match both @code{sun} and @code{sun-cmd},\n for instance.\n \n+@item version\n+The @code{version} test may be used to perform comparisons against\n+specific Readline versions.\n+The @code{version} expands to the current Readline version.\n+The set of comparison operators includes\n+@samp{=} (and @samp{==}), @samp{!=}, @samp{<=}, @samp{>=}, @samp{<},\n+and @samp{>}.\n+The version number supplied on the right side of the operator consists\n+of a major version number, an optional decimal point, and an optional\n+minor version (e.g., @samp{7.1}). If the minor version is omitted, it\n+is assumed to be @samp{0}.\n+The operator may be separated from the string @code{version} and\n+from the version number argument by whitespace.\n+The following example sets a variable if the Readline version being used\n+is 7.0 or newer:\n+@example\n+$if version >= 7.0\n+set show-mode-in-prompt on\n+$endif\n+@end example\n+\n @item application\n The @var{application} construct is used to include\n application-specific settings.  Each program using the Readline\n@@ -949,6 +976,23 @@ $if Bash\n \"\\C-xq\": \"\\eb\\\"\\ef\\\"\"\n $endif\n @end example\n+\n+@item variable\n+The @var{variable} construct provides simple equality tests for Readline\n+variables and values.\n+The permitted comparison operators are @samp{=}, @samp{==}, and @samp{!=}.\n+The variable name must be separated from the comparison operator by\n+whitespace; the operator may be separated from the value on the right hand\n+side by whitespace.\n+Both string and boolean variables may be tested. Boolean variables must be\n+tested against the values @var{on} and @var{off}.\n+The following example is equivalent to the @code{mode=emacs} test described\n+above:\n+@example\n+$if editing-mode == emacs\n+set show-mode-in-prompt on\n+$endif\n+@end example\n @end table\n \n @item $endif\n@@ -1138,6 +1182,19 @@ Move back to the start of the current or previous word.\n Words are delimited by non-quoted shell metacharacters.\n @end ifset\n \n+@item previous-screen-line ()\n+Attempt to move point to the same physical screen column on the previous\n+physical screen line. This will not have the desired effect if the current\n+Readline line does not take up more than one physical line or if point is not\n+greater than the length of the prompt plus the screen width.\n+\n+@item next-screen-line ()\n+Attempt to move point to the same physical screen column on the next\n+physical screen line. This will not have the desired effect if the current\n+Readline line does not take up more than one physical line or if the length\n+of the current Readline line is not greater than the length of the prompt\n+plus the screen width.\n+\n @item clear-screen (C-l)\n Clear the screen and redraw the current line,\n leaving the current line at the top of the screen.\n@@ -1216,14 +1273,14 @@ The search string must match at the beginning of a history line.\n This is a non-incremental search.\n By default, this command is unbound.\n \n-@item history-substr-search-forward ()\n+@item history-substring-search-forward ()\n Search forward through the history for the string of characters\n between the start of the current line and the point.\n The search string may match anywhere in a history line.\n This is a non-incremental search.\n By default, this command is unbound.\n \n-@item history-substr-search-backward ()\n+@item history-substring-search-backward ()\n Search backward through the history for the string of characters\n between the start of the current line and the point.\n The search string may match anywhere in a history line.\n@@ -1297,7 +1354,7 @@ This function is intended to be bound to the \"bracketed paste\" escape\n sequence sent by some terminals, and such a binding is assigned by default.\n It allows Readline to insert the pasted text as a single unit without treating\n each character as if it had been read from the keyboard.  The characters\n-are inserted as if each one was bound to @code{self-insert}) instead of\n+are inserted as if each one was bound to @code{self-insert} instead of\n executing any editing commands.\n \n @item transpose-chars (C-t)\n@@ -1590,9 +1647,10 @@ Abort the current editing command and\n ring the terminal's bell (subject to the setting of\n @code{bell-style}).\n \n-@item do-uppercase-version (M-a, M-b, M-@var{x}, @dots{})\n-If the metafied character @var{x} is lowercase, run the command\n-that is bound to the corresponding uppercase character.\n+@item do-lowercase-version (M-A, M-B, M-@var{x}, @dots{})\n+If the metafied character @var{x} is upper case, run the command\n+that is bound to the corresponding metafied lower case character.\n+The behavior is undefined if @var{x} is already lower case.\n \n @item prefix-meta (@key{ESC})\n Metafy the next character typed.  This is for keyboards\n@@ -1718,10 +1776,11 @@ A synonym for @code{yank-last-arg}.\n \n @item operate-and-get-next (C-o)\n Accept the current line for execution and fetch the next line\n-relative to the current line from the history for editing.  Any\n-argument is ignored.\n+relative to the current line from the history for editing.\n+A numeric argument, if supplied, specifies the history entry to use instead\n+of the current line.\n \n-@item edit-and-execute-command (C-xC-e)\n+@item edit-and-execute-command (C-x C-e)\n Invoke an editor on the current command line, and execute the result as shell\n commands.\n Bash attempts to invoke\n@@ -1792,6 +1851,9 @@ If no compspec is found for the full pathname, an attempt is made to\n find a compspec for the portion following the final slash.\n If those searches do not result in a compspec, any compspec defined with\n the @option{-D} option to @code{complete} is used as the default.\n+If there is no default compspec, Bash attempts alias expansion\n+on the command word as a final resort, and attempts to find a compspec\n+for the command word from any successful expansion \n \n Once a compspec has been found, it is used to generate the list of\n matching words.\n@@ -1816,7 +1878,9 @@ Next, the string specified as the argument to the @option{-W} option\n is considered.\n The string is first split using the characters in the @env{IFS}\n special variable as delimiters.\n-Shell quoting is honored.\n+Shell quoting is honored within the string, in order to provide a\n+mechanism for the words to contain shell metacharacters or characters\n+in the value of @env{IFS}.\n Each word is then expanded using\n brace expansion, tilde expansion, parameter and variable expansion,\n command substitution, and arithmetic expansion,\n@@ -1960,10 +2024,10 @@ matches were generated.\n @item complete\n @btindex complete\n @example\n-@code{complete [-abcdefgjksuv] [-o @var{comp-option}] [-DE] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]\n-[-F @var{function}] [-C @var{command}] [-X @var{filterpat}]\n+@code{complete [-abcdefgjksuv] [-o @var{comp-option}] [-DEI] [-A @var{action}] [-G @var{globpat}]\n+[-W @var{wordlist}] [-F @var{function}] [-C @var{command}] [-X @var{filterpat}]\n [-P @var{prefix}] [-S @var{suffix}] @var{name} [@var{name} @dots{}]}\n-@code{complete -pr [-DE] [@var{name} @dots{}]}\n+@code{complete -pr [-DEI] [@var{name} @dots{}]}\n @end example\n \n Specify how arguments to each @var{name} should be completed.\n@@ -1973,16 +2037,24 @@ reused as input.\n The @option{-r} option removes a completion specification for\n each @var{name}, or, if no @var{name}s are supplied, all\n completion specifications.\n-The @option{-D} option indicates that the remaining options and actions should\n+The @option{-D} option indicates that other supplied options and actions should\n apply to the ``default'' command completion; that is, completion attempted\n on a command for which no completion has previously been defined.\n-The @option{-E} option indicates that the remaining options and actions should\n+The @option{-E} option indicates that other supplied options and actions should\n apply to ``empty'' command completion; that is, completion attempted on a \n blank line.\n+The @option{-I} option indicates that other supplied options and actions should\n+apply to completion on the inital non-assignment word on the line, or after a\n+command delimiter such as @samp{;} or @samp{|}, which is usually command\n+name completion.\n+If multiple options are supplied, the @option{-D} option takes precedence\n+over @option{-E}, and both take precedence over @option{-I}.\n+If any of @option{-D}, @option{-E}, or @option{-I} are supplied, any other\n+@var{name} arguments are ignored; these completions only apply to the case\n+specified by the option.\n \n The process of applying these completion specifications when word completion\n-is attempted is described above (@pxref{Programmable Completion}).  The\n-@option{-D} option takes precedence over @option{-E}.\n+is attempted is described above (@pxref{Programmable Completion}).\n \n Other options, if specified, have the following meanings.\n The arguments to the @option{-G}, @option{-W}, and @option{-X} options\n@@ -2012,7 +2084,7 @@ Perform directory name completion if the compspec generates no matches.\n \n @item filenames\n Tell Readline that the compspec generates filenames, so it can perform any\n-filename-specific processing (like adding a slash to directory names\n+filename-specific processing (like adding a slash to directory names,\n quoting special characters, or suppressing trailing spaces).\n This option is intended to be used with shell functions specified\n with @option{-F}.\n@@ -2167,7 +2239,7 @@ an error occurs adding a completion specification.\n @item compopt\n @btindex compopt\n @example\n-@code{compopt} [-o @var{option}] [-DE] [+o @var{option}] [@var{name}]\n+@code{compopt} [-o @var{option}] [-DEI] [+o @var{option}] [@var{name}]\n @end example\n Modify completion options for each @var{name} according to the\n @var{option}s, or for the currently-executing completion if no @var{name}s\n@@ -2176,14 +2248,19 @@ If no @var{option}s are given, display the completion options for each\n @var{name} or the current completion.\n The possible values of @var{option} are those valid for the @code{complete}\n builtin described above.\n-The @option{-D} option indicates that the remaining options should\n+The @option{-D} option indicates that other supplied options should\n apply to the ``default'' command completion; that is, completion attempted\n on a command for which no completion has previously been defined.\n-The @option{-E} option indicates that the remaining options should\n+The @option{-E} option indicates that other supplied options should\n apply to ``empty'' command completion; that is, completion attempted on a \n blank line.\n+The @option{-I} option indicates that other supplied options should\n+apply to completion on the inital non-assignment word on the line, or after a\n+command delimiter such as @samp{;} or @samp{|}, which is usually command\n+name completion.\n \n-The @option{-D} option takes precedence over @option{-E}.\n+If multiple options are supplied, the @option{-D} option takes precedence\n+over @option{-E}, and both take precedence over @option{-I}\n \n The return value is true unless an invalid option is supplied, an attempt\n is made to modify the options for a @var{name} for which no completion\n@@ -2200,7 +2277,7 @@ a shell function and bind it to a particular command using @code{complete -F}.\n \n The following function provides completions for the @code{cd} builtin.\n It is a reasonably good example of what shell functions must do when\n-used for completion.  This function uses the word passsed as @code{$2}\n+used for completion.  This function uses the word passed as @code{$2}\n to determine the directory name to complete.  You can also use the\n @code{COMP_WORDS} array variable; the current word is indexed by the\n @code{COMP_CWORD} variable.\n@@ -2230,7 +2307,7 @@ _comp_cd()\n     local cur _skipdot _cdpath\n     local i j k\n \n-    # Tilde expansion, with side effect of expanding tilde to full pathname\n+    # Tilde expansion, which also expands tilde to full pathname\n     case \"$2\" in\n     \\~*)    eval cur=\"$2\" ;;\n     *)      cur=$2 ;;"
    },
    {
      "sha": "576c35c839d724c4e419cbddd8fe3055ec91b3b4",
      "filename": "readline/doc/version.texi",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/version.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/doc/version.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/version.texi?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,10 +1,10 @@\n @ignore\n-Copyright (C) 1988-2016 Free Software Foundation, Inc. \n+Copyright (C) 1988-2018 Free Software Foundation, Inc. \n @end ignore\n \n-@set EDITION 7.0\n-@set VERSION 7.0\n-@set UPDATED 16 July 2016\n-@set UPDATED-MONTH July 2016\n+@set EDITION 8.0\n+@set VERSION 8.0\n+@set UPDATED 30 November 2018\n+@set UPDATED-MONTH November 2018\n \n-@set LASTCHANGE Sat Jul 16 13:43:15 EDT 2016\n+@set LASTCHANGE Fri Nov 30 22:50:53 EST 2018"
    },
    {
      "sha": "b5e53f494a1a1b6115bb9dbe552d720fff1d9c50",
      "filename": "readline/emacs_keymap.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/emacs_keymap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/emacs_keymap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/emacs_keymap.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* emacs_keymap.c -- the keymap for emacs_mode in readline (). */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      "
    },
    {
      "sha": "4a7c39e0a4fb306dd2b1e3f1c10fc080183fd885",
      "filename": "readline/examples/Makefile.in",
      "status": "modified",
      "additions": 24,
      "deletions": 5,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/Makefile.in?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -53,8 +53,12 @@ CPPFLAGS = @CPPFLAGS@\n \n INCLUDES = -I$(srcdir) -I$(top_srcdir) -I..\n \n-CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n-LDFLAGS = -g -L.. @LDFLAGS@\n+CCFLAGS  = $(ASAN_CFLAGS) $(DEFS) $(LOCAL_CFLAGS) $(INCLUDES) $(CPPFLAGS) \\\n+\t$(CFLAGS)\n+LDFLAGS = -g -L.. @LDFLAGS@ $(ASAN_LDFLAGS)\n+\n+ASAN_XCFLAGS = -fsanitize=address -fno-omit-frame-pointer\n+ASAN_XLDFLAGS = -fsanitize=address\n \n READLINE_LIB = ../libreadline.a\n HISTORY_LIB = ../libhistory.a\n@@ -67,22 +71,28 @@ TERMCAP_LIB = @TERMCAP_LIB@\n \n SOURCES = excallback.c fileman.c histexamp.c manexamp.c rl-fgets.c rl.c \\\n \t\trlbasic.c rlcat.c rlevent.c rlptytest.c rltest.c rlversion.c \\\n-\t\trl-callbacktest.c hist_erasedups.c hist_purgecmd.c \n+\t\trltest2.c rl-callbacktest.c hist_erasedups.c hist_purgecmd.c \\\n+\t\trlkeymaps.c\n \n EXECUTABLES = fileman$(EXEEXT) rltest$(EXEEXT) rl$(EXEEXT) rlcat$(EXEEXT) \\\n \t\trlevent$(EXEEXT) rlversion$(EXEEXT) histexamp$(EXEEXT) \\\n \t\trl-callbacktest$(EXEEXT) rlbasic$(EXEEXT) \\\n-\t\thist_erasedups$(EXEEXT) hist_purgecmd$(EXEEXT)\n+\t\thist_erasedups$(EXEEXT) hist_purgecmd$(EXEEXT) \\\n+\t\trlkeymaps$(EXEEXT)\n \n OBJECTS = fileman.o rltest.o rl.o rlevent.o rlcat.o rlversion.o histexamp.o \\\n-\t  rl-callbacktest.o rlbasic.o hist_erasedups.o hist_purgecmd.o\n+\t  rltest2.o rl-callbacktest.o rlbasic.o hist_erasedups.o hist_purgecmd.o \\\n+\t  rlkeymaps.o\n \n OTHEREXE = rlptytest$(EXEEXT)\n OTHEROBJ = rlptytest.o\n \n all: $(EXECUTABLES)\n everything: all\n \n+asan:\n+\t${MAKE} ${MFLAGS} ASAN_CFLAGS='${ASAN_XCFLAGS}' ASAN_LDFLAGS='${ASAN_XLDFLAGS}' all\n+\n check:\trlversion$(EXEEXT)\n \t@echo Readline version: `rlversion$(EXEEXT)`\n \n@@ -113,12 +123,18 @@ rlcat$(EXEEXT): rlcat.o $(READLINE_LIB)\n rlevent$(EXEEXT): rlevent.o $(READLINE_LIB)\n \t$(CC) $(LDFLAGS) -o $@ rlevent.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n+rlkeymaps$(EXEEXT): rlkeymaps.o $(READLINE_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rlkeymaps.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\n fileman$(EXEEXT): fileman.o $(READLINE_LIB)\n \t$(CC) $(LDFLAGS) -o $@ fileman.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n rltest$(EXEEXT): rltest.o $(READLINE_LIB)\n \t$(CC) $(LDFLAGS) -o $@ rltest.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n+rltest2$(EXEEXT): rltest2.o $(READLINE_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rltest2.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\n rl-callbacktest$(EXEEXT): rl-callbacktest.o $(READLINE_LIB)\n \t$(CC) $(LDFLAGS) -o $@ rl-callbacktest.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n@@ -146,18 +162,21 @@ distclean maintainer-clean: clean\n \n fileman.o: fileman.c\n rltest.o: rltest.c\n+rltest2.o: rltest2.c\n rl.o: rl.c\n rlversion.o: rlversion.c\n histexamp.o: histexamp.c\n hist_erasedups.o: hist_erasedups.c\n hist_purgecmd.o: hist_purgecmd.c\n rlbasic.o: rlbasic.c\n+rlkeymaps.o: rlkeymaps.c\n rlcat.o: rlcat.c\n rlptytest.o: rlptytest.c\n rl-callbacktest.o: rl-callbacktest.c\n \n fileman.o: $(top_srcdir)/readline.h\n rltest.o: $(top_srcdir)/readline.h\n+rltest2.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h\n rl.o: $(top_srcdir)/readline.h\n rlversion.o: $(top_srcdir)/readline.h\n histexamp.o: $(top_srcdir)/history.h"
    },
    {
      "sha": "f820eba6aaab4db0c1835dde183c9f85532e7bd5",
      "filename": "readline/examples/hist_erasedups.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/hist_erasedups.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/hist_erasedups.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/hist_erasedups.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -38,6 +38,8 @@\n #define STREQN(a, b, n) ((n == 0) ? (1) \\\n                                   : ((a)[0] == (b)[0] && strncmp(a, b, n) == 0))\n \n+int hist_erasedups (void);\n+\n static void\n usage()\n {"
    },
    {
      "sha": "7992d810dd00c96fa1c6eecb1a8544b1624dfa56",
      "filename": "readline/examples/hist_purgecmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/hist_purgecmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/hist_purgecmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/hist_purgecmd.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -43,6 +43,8 @@\n \n #define PURGE_REGEXP\t0x01\n \n+int hist_purgecmd (char *, int);\n+\n static void\n usage()\n {"
    },
    {
      "sha": "309d769b3845e254132dab0aac3fb11050b4e150",
      "filename": "readline/examples/histexamp.c",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/histexamp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/histexamp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/histexamp.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -27,8 +27,11 @@\n #  include <readline/history.h>\n #endif\n \n+#include <unistd.h>\n+#include <stdlib.h>\n #include <string.h>\n \n+int\n main (argc, argv)\n      int argc;\n      char **argv;"
    },
    {
      "sha": "b4942413f8bebb6d08b83e035ce7dde3a9c52bf7",
      "filename": "readline/examples/rlcat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlcat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlcat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlcat.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -137,7 +137,7 @@ fcopy(fp)\n       if (vflag && isascii ((unsigned char)c) && isprint((unsigned char)c) == 0)\n \t{\n \t  x = rl_untranslate_keyseq (c);\n-\t  if (fputs (x, stdout) != 0)\n+\t  if (fputs (x, stdout) == EOF)\n \t    return 1;\n \t}\n       else if (putchar (c) == EOF)"
    },
    {
      "sha": "8143cb02aa0742a4dd4e040515a11bcdb6740138",
      "filename": "readline/examples/rlevent.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlevent.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -28,6 +28,13 @@\n #  include <config.h>\n #endif\n \n+#ifdef HAVE_UNISTD_H\n+#  include <unistd.h>\n+#else\n+extern int getopt();\n+extern int sleep();\n+#endif\n+\n #include <stdio.h>\n #include <sys/types.h>\n "
    },
    {
      "sha": "fef77b35ab90693c193003c128638f69ff1659fa",
      "filename": "readline/examples/rlkeymaps.c",
      "status": "added",
      "additions": 61,
      "deletions": 0,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlkeymaps.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rlkeymaps.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlkeymaps.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -0,0 +1,61 @@\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#if defined (READLINE_LIBRARY)\n+#  include \"readline.h\"\n+#  include \"history.h\"\n+#else\n+#  include <readline/readline.h>\n+#  include <readline/history.h>\n+#endif\n+\n+int\n+main (int c, char **v)\n+{\n+  Keymap nmap, emacsmap, newemacs;\n+  int r, errs;\n+\n+  errs = 0;\n+  nmap = rl_make_keymap ();\n+\n+  r = rl_set_keymap_name (\"emacs\", nmap);\n+  if (r >= 0)\n+    {\n+      fprintf (stderr, \"rlkeymaps: error: able to rename `emacs' keymap\\n\");\n+      errs++;\n+    }\n+\n+  emacsmap = rl_get_keymap_by_name (\"emacs\");\n+  r = rl_set_keymap_name (\"newemacs\", emacsmap);\n+  if (r >= 0)\n+    {\n+      fprintf (stderr, \"rlkeymaps: error: able to set new name for emacs keymap\\n\");\n+      errs++;\n+    }\n+\n+  r = rl_set_keymap_name (\"newemacs\", nmap);\n+  if (r < 0)\n+    {\n+      fprintf (stderr, \"rlkeymaps: error: newemacs: could not set keymap name\\n\");\n+      errs++;\n+    }\n+\n+  newemacs = rl_copy_keymap (emacsmap);\n+  r = rl_set_keymap_name (\"newemacs\", newemacs);\n+  if (r < 0)\n+    {\n+      fprintf (stderr, \"rlkeymaps: error: newemacs: could not set `newemacs' keymap to new map\\n\");\n+      errs++;\n+    }\n+\n+  r = rl_set_keymap_name (\"emacscopy\", newemacs);\n+  if (r < 0)\n+    {\n+      fprintf (stderr, \"rlkeymaps: error: emacscopy: could not rename created keymap\\n\");\n+      errs++;\n+    }\n+\n+  exit (errs);\n+}"
    },
    {
      "sha": "65abe87cc044d39175d58408d60ad27674c3e8be",
      "filename": "readline/examples/rltest.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rltest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/examples/rltest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rltest.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -46,6 +46,7 @@ extern void exit();\n \n extern HIST_ENTRY **history_list ();\n \n+int\n main ()\n {\n   char *temp, *prompt;"
    },
    {
      "sha": "aaf144de99133b7c5fc656add927ada655951b25",
      "filename": "readline/funmap.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/funmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/funmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/funmap.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* funmap.c -- attach names to functions. */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -110,6 +110,7 @@ static const FUNMAP default_funmap[] = {\n   { \"menu-complete\", rl_menu_complete },\n   { \"menu-complete-backward\", rl_backward_menu_complete },\n   { \"next-history\", rl_get_next_history },\n+  { \"next-screen-line\", rl_next_screen_line },\n   { \"non-incremental-forward-search-history\", rl_noninc_forward_search },\n   { \"non-incremental-reverse-search-history\", rl_noninc_reverse_search },\n   { \"non-incremental-forward-search-history-again\", rl_noninc_forward_search_again },\n@@ -121,6 +122,7 @@ static const FUNMAP default_funmap[] = {\n #endif\n   { \"possible-completions\", rl_possible_completions },\n   { \"previous-history\", rl_get_previous_history },\n+  { \"previous-screen-line\", rl_previous_screen_line },\n   { \"print-last-kbd-macro\", rl_print_last_kbd_macro },\n   { \"quoted-insert\", rl_quoted_insert },\n   { \"re-read-init-file\", rl_re_read_init_file },\n@@ -204,9 +206,7 @@ static const FUNMAP default_funmap[] = {\n };\n \n int\n-rl_add_funmap_entry (name, function)\n-     const char *name;\n-     rl_command_func_t *function;\n+rl_add_funmap_entry (const char *name, rl_command_func_t *function)\n {\n   if (funmap_entry + 2 >= funmap_size)\n     {\n@@ -226,7 +226,7 @@ static int funmap_initialized;\n \n /* Make the funmap contain all of the default entries. */\n void\n-rl_initialize_funmap ()\n+rl_initialize_funmap (void)\n {\n   register int i;\n \n@@ -244,7 +244,7 @@ rl_initialize_funmap ()\n    is sorted.  The array itself is allocated, but not the strings inside.\n    You should free () the array when you done, but not the pointers. */\n const char **\n-rl_funmap_names ()\n+rl_funmap_names (void)\n {\n   const char **result;\n   int result_size, result_index;"
    },
    {
      "sha": "adcf5dcb4e3cbfdfb29a2904452795e83acdd9ab",
      "filename": "readline/histexpand.c",
      "status": "modified",
      "additions": 80,
      "deletions": 85,
      "changes": 165,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histexpand.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histexpand.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histexpand.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* histexpand.c -- history expansion. */\n \n-/* Copyright (C) 1989-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2018 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -55,6 +55,8 @@\n \n #define slashify_in_quotes \"\\\\`\\\"$\"\n \n+#define fielddelim(c)\t(whitespace(c) || (c) == '\\n')\n+\n typedef int _hist_search_func_t PARAMS((const char *, int));\n \n static char error_pointer;\n@@ -107,6 +109,8 @@ char *history_word_delimiters = HISTORY_WORD_DELIMITERS;\n    particular history expansion should be performed. */\n rl_linebuf_func_t *history_inhibit_expansion_function;\n \n+int history_quoting_state = 0;\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tHistory Expansion\t\t\t    */\n@@ -132,10 +136,7 @@ static char *search_match;\n    So you might call this function like:\n    line = get_history_event (\"!echo:p\", &index, 0);  */\n char *\n-get_history_event (string, caller_index, delimiting_quote)\n-     const char *string;\n-     int *caller_index;\n-     int delimiting_quote;\n+get_history_event (const char *string, int *caller_index, int delimiting_quote)\n {\n   register int i;\n   register char c;\n@@ -316,9 +317,7 @@ get_history_event (string, caller_index, delimiting_quote)\n    to the closing single quote.  FLAGS currently used to allow backslash\n    to escape a single quote (e.g., for bash $'...'). */\n static void\n-hist_string_extract_single_quoted (string, sindex, flags)\n-     char *string;\n-     int *sindex, flags;\n+hist_string_extract_single_quoted (char *string, int *sindex, int flags)\n {\n   register int i;\n \n@@ -332,8 +331,7 @@ hist_string_extract_single_quoted (string, sindex, flags)\n }\n \n static char *\n-quote_breaks (s)\n-     char *s;\n+quote_breaks (char *s)\n {\n   register char *p, *r;\n   char *ret;\n@@ -374,9 +372,7 @@ quote_breaks (s)\n }\n \n static char *\n-hist_error(s, start, current, errtype)\n-      char *s;\n-      int start, current, errtype;\n+hist_error(char *s, int start, int current, int errtype)\n {\n   char *temp;\n   const char *emsg;\n@@ -433,9 +429,7 @@ hist_error(s, start, current, errtype)\n    subst_rhs is allowed to be set to the empty string. */\n \n static char *\n-get_subst_pattern (str, iptr, delimiter, is_rhs, lenptr)\n-     char *str;\n-     int *iptr, delimiter, is_rhs, *lenptr;\n+get_subst_pattern (char *str, int *iptr, int delimiter, int is_rhs, int *lenptr)\n {\n   register int si, i, j, k;\n   char *s;\n@@ -490,7 +484,7 @@ get_subst_pattern (str, iptr, delimiter, is_rhs, lenptr)\n }\n \n static void\n-postproc_subst_rhs ()\n+postproc_subst_rhs (void)\n {\n   char *new;\n   int i, j, new_size;\n@@ -526,12 +520,9 @@ postproc_subst_rhs ()\n    if the `p' modifier was supplied and the caller should just print\n    the returned string.  Returns the new index into string in\n    *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */\n+/* need current line for !# */\n static int\n-history_expand_internal (string, start, qc, end_index_ptr, ret_string, current_line)\n-     char *string;\n-     int start, qc, *end_index_ptr;\n-     char **ret_string;\n-     char *current_line;\t/* for !# */\n+history_expand_internal (char *string, int start, int qc, int *end_index_ptr, char **ret_string, char *current_line)\n {\n   int i, n, starting_index;\n   int substitute_globally, subst_bywords, want_quotes, print_only;\n@@ -780,7 +771,7 @@ history_expand_internal (string, start, qc, end_index_ptr, ret_string, current_l\n \t\t   the last time. */\n \t\tif (subst_bywords && si > we)\n \t\t  {\n-\t\t    for (; temp[si] && whitespace (temp[si]); si++)\n+\t\t    for (; temp[si] && fielddelim (temp[si]); si++)\n \t\t      ;\n \t\t    ws = si;\n \t\t    we = history_tokenize_word (temp, si);\n@@ -908,9 +899,7 @@ history_expand_internal (string, start, qc, end_index_ptr, ret_string, current_l\n \twhile (0)\n \n int\n-history_expand (hstring, output)\n-     char *hstring;\n-     char **output;\n+history_expand (char *hstring, char **output)\n {\n   register int j;\n   int i, r, l, passc, cc, modified, eindex, only_printing, dquote, squote, flag;\n@@ -976,7 +965,22 @@ history_expand (hstring, output)\n \n       /* `!' followed by one of the characters in history_no_expand_chars\n \t is NOT an expansion. */\n-      for (i = dquote = squote = 0; string[i]; i++)\n+      dquote = history_quoting_state == '\"';\n+      squote = history_quoting_state == '\\'';\n+\n+      /* If the calling application tells us we are already reading a\n+\t single-quoted string, consume the rest of the string right now\n+\t and then go on. */\n+      i = 0;\n+      if (squote && history_quotes_inhibit_expansion)\n+\t{\n+\t  hist_string_extract_single_quoted (string, &i, 0);\n+\t  squote = 0;\n+\t  if (string[i])\n+\t    i++;\n+\t}\n+\n+      for ( ; string[i]; i++)\n \t{\n #if defined (HANDLE_MULTIBYTE)\n \t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n@@ -1064,7 +1068,29 @@ history_expand (hstring, output)\n     }\n \n   /* Extract and perform the substitution. */\n-  for (passc = dquote = squote = i = j = 0; i < l; i++)\n+  dquote = history_quoting_state == '\"';\n+  squote = history_quoting_state == '\\'';\n+\n+  /* If the calling application tells us we are already reading a\n+     single-quoted string, consume the rest of the string right now\n+     and then go on. */\n+  i = j = 0;\n+  if (squote && history_quotes_inhibit_expansion)\n+    {\n+      int c;\n+\n+      hist_string_extract_single_quoted (string, &i, 0);\n+      squote = 0;\n+      for (c = 0; c < i; c++)\n+\tADD_CHAR (string[c]);      \n+      if (string[i])\n+\t{\n+\t  ADD_CHAR (string[i]);\n+\t  i++;\n+\t}\n+    }\n+\n+  for (passc = 0; i < l; i++)\n     {\n       int qc, tchar = string[i];\n \n@@ -1249,9 +1275,7 @@ history_expand (hstring, output)\n    CALLER_INDEX is the offset in SPEC to start looking; it is updated\n    to point to just after the last character parsed. */\n static char *\n-get_history_word_specifier (spec, from, caller_index)\n-     char *spec, *from;\n-     int *caller_index;\n+get_history_word_specifier (char *spec, char *from, int *caller_index)\n {\n   register int i = *caller_index;\n   int first, last;\n@@ -1357,9 +1381,7 @@ get_history_word_specifier (spec, from, caller_index)\n    tokens, so that FIRST = -1 means the next to last token on the line).\n    If LAST is `$' the last arg from STRING is used. */\n char *\n-history_arg_extract (first, last, string)\n-     int first, last;\n-     const char *string;\n+history_arg_extract (int first, int last, const char *string)\n {\n   register int i, len;\n   char *result;\n@@ -1418,17 +1440,15 @@ history_arg_extract (first, last, string)\n }\n \n static int\n-history_tokenize_word (string, ind)\n-     const char *string;\n-     int ind;\n+history_tokenize_word (const char *string, int ind)\n {\n   register int i, j;\n   int delimiter, nestdelim, delimopen;\n \n   i = ind;\n   delimiter = nestdelim = 0;\n \n-  if (member (string[i], \"()\\n\"))\n+  if (member (string[i], \"()\\n\"))\t/* XXX - included \\n, but why? been here forever */\n     {\n       i++;\n       return i;\n@@ -1450,11 +1470,11 @@ history_tokenize_word (string, ind)\n \t}\n     }\n \n-  if (member (string[i], \"<>;&|$\"))\n+  if (member (string[i], \"<>;&|\"))\n     {\n       int peek = string[i + 1];\n \n-      if (peek == string[i] && peek != '$')\n+      if (peek == string[i])\n \t{\n \t  if (peek == '<' && string[i + 2] == '-')\n \t    i++;\n@@ -1477,44 +1497,18 @@ history_tokenize_word (string, ind)\n \t  i += 2;\n \t  return i;\n \t}\n-      /* XXX - separated out for later -- bash-4.2 */\n-      else if ((peek == '(' && (string[i] == '>' || string[i] == '<')) || /* ) */\n-\t       (peek == '(' && string[i] == '$')) /*)*/\n+      /* XXX - process substitution -- separated out for later -- bash-4.2 */\n+      else if (peek == '(' && (string[i] == '>' || string[i] == '<')) /*)*/\n \t{\n \t  i += 2;\n \t  delimopen = '(';\n \t  delimiter = ')';\n \t  nestdelim = 1;\n \t  goto get_word;\n \t}\n-#if 0\n-      else if (peek == '\\'' && string[i] == '$')\n-        {\n-\t  i += 2;\t/* XXX */\n-\t  return i;\n-        }\n-#endif\n \n-      if (string[i] != '$')\n-\t{\n-\t  i++;\n-\t  return i;\n-\t}\n-    }\n-\n-  /* same code also used for $(...)/<(...)/>(...) above */\n-  if (member (string[i], \"!@?+*\"))\n-    {\n-      int peek = string[i + 1];\n-\n-      if (peek == '(')\t\t/*)*/\n-\t{\n-\t  /* Shell extended globbing patterns */\n-\t  i += 2;\n-\t  delimopen = '(';\n-\t  delimiter = ')';\t/* XXX - not perfect */\n-\t  nestdelim = 1;\n-\t}\n+      i++;\n+      return i;\n     }\n \n get_word:\n@@ -1559,6 +1553,16 @@ history_tokenize_word (string, ind)\n \t  continue;\n \t}\n \n+      /* Command and process substitution; shell extended globbing patterns */\n+      if (nestdelim == 0 && delimiter == 0 && member (string[i], \"<>$!@?+*\") && string[i+1] == '(') /*)*/\n+\t{\n+\t  i += 2;\n+\t  delimopen = '(';\n+\t  delimiter = ')';\n+\t  nestdelim = 1;\n+\t  continue;\n+\t}\n+      \n       if (delimiter == 0 && (member (string[i], history_word_delimiters)))\n \tbreak;\n \n@@ -1570,9 +1574,7 @@ history_tokenize_word (string, ind)\n }\n \n static char *\n-history_substring (string, start, end)\n-     const char *string;\n-     int start, end;\n+history_substring (const char *string, int start, int end)\n {\n   register int len;\n   register char *result;\n@@ -1589,9 +1591,7 @@ history_substring (string, start, end)\n    WIND.  The position in the returned array of strings is returned in\n    *INDP. */\n static char **\n-history_tokenize_internal (string, wind, indp)\n-     const char *string;\n-     int wind, *indp;\n+history_tokenize_internal (const char *string, int wind, int *indp)\n {\n   char **result;\n   register int i, start, result_index, size;\n@@ -1606,7 +1606,7 @@ history_tokenize_internal (string, wind, indp)\n   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )\n     {\n       /* Skip leading whitespace. */\n-      for (; string[i] && whitespace (string[i]); i++)\n+      for (; string[i] && fielddelim (string[i]); i++)\n \t;\n       if (string[i] == 0 || string[i] == history_comment_char)\n \treturn (result);\n@@ -1644,17 +1644,14 @@ history_tokenize_internal (string, wind, indp)\n /* Return an array of tokens, much as the shell might.  The tokens are\n    parsed out of STRING. */\n char **\n-history_tokenize (string)\n-     const char *string;\n+history_tokenize (const char *string)\n {\n   return (history_tokenize_internal (string, -1, (int *)NULL));\n }\n \n /* Free members of WORDS from START to an empty string */\n static void\n-freewords (words, start)\n-     char **words;\n-     int start;\n+freewords (char **words, int start)\n {\n   register int i;\n \n@@ -1666,9 +1663,7 @@ freewords (words, start)\n    in the history line LINE.  Used to save the word matched by the\n    last history !?string? search. */\n static char *\n-history_find_word (line, ind)\n-     char *line;\n-     int ind;\n+history_find_word (char *line, int ind)\n {\n   char **words, *s;\n   int i, wind;"
    },
    {
      "sha": "dc64bde1c5acf8c117080eb7c783a2cd3181311d",
      "filename": "readline/histfile.c",
      "status": "modified",
      "additions": 34,
      "deletions": 30,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histfile.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* histfile.c - functions to manipulate the history file. */\n \n-/* Copyright (C) 1989-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2018 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -143,8 +143,7 @@ static int histfile_restore PARAMS((const char *, const char *));\n    filename.  This only matters when you don't specify the\n    filename to read_history (), or write_history (). */\n static char *\n-history_filename (filename)\n-     const char *filename;\n+history_filename (const char *filename)\n {\n   char *return_val;\n   const char *home;\n@@ -179,8 +178,7 @@ history_filename (filename)\n }\n \n static char *\n-history_backupfile (filename)\n-     const char *filename;\n+history_backupfile (const char *filename)\n {\n   const char *fn;\n   char *ret, linkbuf[PATH_MAX+1];\n@@ -208,8 +206,7 @@ history_backupfile (filename)\n }\n   \n static char *\n-history_tempfile (filename)\n-     const char *filename;\n+history_tempfile (const char *filename)\n {\n   const char *fn;\n   char *ret, linkbuf[PATH_MAX+1];\n@@ -251,8 +248,7 @@ history_tempfile (filename)\n    If FILENAME is NULL, then read from ~/.history.  Returns 0 if\n    successful, or errno if not. */\n int\n-read_history (filename)\n-     const char *filename;\n+read_history (const char *filename)\n {\n   return (read_history_range (filename, 0, -1));\n }\n@@ -263,9 +259,7 @@ read_history (filename)\n    until the end of the file.  If FILENAME is NULL, then read from\n    ~/.history.  Returns 0 if successful, or errno if not. */\n int\n-read_history_range (filename, from, to)\n-     const char *filename;\n-     int from, to;\n+read_history_range (const char *filename, int from, int to)\n {\n   register char *line_start, *line_end, *p;\n   char *input, *buffer, *bufend, *last_ts;\n@@ -289,6 +283,16 @@ read_history_range (filename, from, to)\n   if ((file < 0) || (fstat (file, &finfo) == -1))\n     goto error_and_exit;\n \n+  if (S_ISREG (finfo.st_mode) == 0)\n+    {\n+#ifdef EFTYPE\n+      errno = EFTYPE;\n+#else\n+      errno = EINVAL;\n+#endif\n+      goto error_and_exit;\n+    }\n+\n   file_size = (size_t)finfo.st_size;\n \n   /* check for overflow on very large files */\n@@ -298,6 +302,12 @@ read_history_range (filename, from, to)\n       goto error_and_exit;\n     }\n \n+  if (file_size == 0)\n+    {\n+      free (input);\n+      return 0;\t/* don't waste time if we don't have to */\n+    }\n+\n #ifdef HISTORY_USE_MMAP\n   /* We map read/write and private so we can change newlines to NULs without\n      affecting the underlying object. */\n@@ -344,6 +354,7 @@ read_history_range (filename, from, to)\n \n   /* Start at beginning of file, work to end. */\n   bufend = buffer + chars_read;\n+  *bufend = '\\0';\t\t/* null-terminate buffer for timestamp checks */\n   current_line = 0;\n \n   /* Heuristic: the history comment character rarely changes, so assume we\n@@ -385,7 +396,7 @@ read_history_range (filename, from, to)\n \t  {\n \t    if (HIST_TIMESTAMP_START(line_start) == 0)\n \t      {\n-\t      \tif (last_ts == NULL && history_multiline_entries)\n+\t      \tif (last_ts == NULL && history_length > 0 && history_multiline_entries)\n \t\t  _hs_append_history_line (history_length - 1, line_start);\n \t\telse\n \t\t  add_history (line_start);\n@@ -427,9 +438,7 @@ read_history_range (filename, from, to)\n /* Save FILENAME to BACK, handling case where FILENAME is a symlink\n    (e.g., ~/.bash_history -> .histfiles/.bash_history.$HOSTNAME) */\n static int\n-histfile_backup (filename, back)\n-     const char *filename;\n-     const char *back;\n+histfile_backup (const char *filename, const char *back)\n {\n #if defined (HAVE_READLINK)\n   char linkbuf[PATH_MAX+1];\n@@ -448,9 +457,7 @@ histfile_backup (filename, back)\n /* Restore ORIG from BACKUP handling case where ORIG is a symlink\n    (e.g., ~/.bash_history -> .histfiles/.bash_history.$HOSTNAME) */\n static int\n-histfile_restore (backup, orig)\n-     const char *backup;\n-     const char *orig;\n+histfile_restore (const char *backup, const char *orig)\n {\n #if defined (HAVE_READLINK)\n   char linkbuf[PATH_MAX+1];\n@@ -470,9 +477,7 @@ histfile_restore (backup, orig)\n    If FNAME is NULL, then use ~/.history.  Writes a new file and renames\n    it to the original name.  Returns 0 on success, errno on failure. */\n int\n-history_truncate_file (fname, lines)\n-     const char *fname;\n-     int lines;\n+history_truncate_file (const char *fname, int lines)\n {\n   char *buffer, *filename, *tempname, *bp, *bp1;\t\t/* bp1 == bp+1 */\n   int file, chars_read, rv, orig_lines, exists, r;\n@@ -606,12 +611,14 @@ history_truncate_file (fname, lines)\n       history_lines_written_to_file = 0;\n     }\n \n+#if defined (HAVE_CHOWN)\n   /* Make sure the new filename is owned by the same user as the old.  If one\n      user is running this, it's a no-op.  If the shell is running after sudo\n      with a shared history file, we don't want to leave the history file\n      owned by root. */\n   if (rv == 0 && exists)\n     r = chown (filename, finfo.st_uid, finfo.st_gid);\n+#endif\n \n   xfree (filename);\n   FREE (tempname);\n@@ -623,9 +630,7 @@ history_truncate_file (fname, lines)\n    from the history list to FILENAME.  OVERWRITE is non-zero if you\n    wish to replace FILENAME with the entries. */\n static int\n-history_do_write (filename, nelements, overwrite)\n-     const char *filename;\n-     int nelements, overwrite;\n+history_do_write (const char *filename, int nelements, int overwrite)\n {\n   register int i;\n   char *output, *tempname, *histname;\n@@ -753,12 +758,14 @@ history_do_write (filename, nelements, overwrite)\n       history_lines_written_to_file = 0;\n     }\n \n+#if defined (HAVE_CHOWN)\n   /* Make sure the new filename is owned by the same user as the old.  If one\n      user is running this, it's a no-op.  If the shell is running after sudo\n      with a shared history file, we don't want to leave the history file\n      owned by root. */\n   if (rv == 0 && exists)\n     mode = chown (histname, finfo.st_uid, finfo.st_gid);\n+#endif\n \n   FREE (histname);\n   FREE (tempname);\n@@ -769,9 +776,7 @@ history_do_write (filename, nelements, overwrite)\n /* Append NELEMENT entries to FILENAME.  The entries appended are from\n    the end of the list minus NELEMENTs up to the end of the list. */\n int\n-append_history (nelements, filename)\n-     int nelements;\n-     const char *filename;\n+append_history (int nelements, const char *filename)\n {\n   return (history_do_write (filename, nelements, HISTORY_APPEND));\n }\n@@ -780,8 +785,7 @@ append_history (nelements, filename)\n    then write the history list to ~/.history.  Values returned\n    are as in read_history ().*/\n int\n-write_history (filename)\n-     const char *filename;\n+write_history (const char *filename)\n {\n   return (history_do_write (filename, history_length, HISTORY_OVERWRITE));\n }"
    },
    {
      "sha": "9627b24500012e03eefa8ad0e7dc056b756ed246",
      "filename": "readline/histlib.h",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histlib.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histlib.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histlib.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -51,9 +51,9 @@\n #endif\n \n #ifndef member\n-#  ifndef strchr\n+#  if !defined (strchr) && !defined (__STDC__)\n extern char *strchr ();\n-#  endif\n+#  endif /* !strchr && !__STDC__ */\n #define member(c, s) ((c) ? ((char *)strchr ((s), (c)) != (char *)NULL) : 0)\n #endif\n \n@@ -69,11 +69,17 @@ extern char *strchr ();\n #define NO_PREV_SUBST\t4\n \n /* Possible definitions for history starting point specification. */\n-#define ANCHORED_SEARCH 1\n-#define NON_ANCHORED_SEARCH 0\n+#define NON_ANCHORED_SEARCH\t0\n+#define ANCHORED_SEARCH\t\t0x01\n+#define PATTERN_SEARCH\t\t0x02\n \n /* Possible definitions for what style of writing the history file we want. */\n #define HISTORY_APPEND 0\n #define HISTORY_OVERWRITE 1\n \n+/* internal extern function declarations used by other parts of the library */\n+\n+/* histsearch.c */\n+extern int _hs_history_patsearch PARAMS((const char *, int, int));\n+\n #endif /* !_HISTLIB_H_ */"
    },
    {
      "sha": "67158b14bc711b73462dca023f69873bde271459",
      "filename": "readline/history.c",
      "status": "modified",
      "additions": 90,
      "deletions": 48,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/history.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/history.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/history.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* history.c -- standalone history library */\n \n-/* Copyright (C) 1989-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2017 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -97,7 +97,7 @@ int history_base = 1;\n \n /* Return the current HISTORY_STATE of the history. */\n HISTORY_STATE *\n-history_get_history_state ()\n+history_get_history_state (void)\n {\n   HISTORY_STATE *state;\n \n@@ -115,8 +115,7 @@ history_get_history_state ()\n \n /* Set the state of the current history array to STATE. */\n void\n-history_set_history_state (state)\n-     HISTORY_STATE *state;\n+history_set_history_state (HISTORY_STATE *state)\n {\n   the_history = state->entries;\n   history_offset = state->offset;\n@@ -129,7 +128,7 @@ history_set_history_state (state)\n /* Begin a session in which the history functions might be used.  This\n    initializes interactive variables. */\n void\n-using_history ()\n+using_history (void)\n {\n   history_offset = history_length;\n }\n@@ -138,7 +137,7 @@ using_history ()\n    This just adds up the lengths of the_history->lines and the associated\n    timestamps. */\n int\n-history_total_bytes ()\n+history_total_bytes (void)\n {\n   register int i, result;\n \n@@ -151,16 +150,15 @@ history_total_bytes ()\n /* Returns the magic number which says what history element we are\n    looking at now.  In this implementation, it returns history_offset. */\n int\n-where_history ()\n+where_history (void)\n {\n   return (history_offset);\n }\n \n /* Make the current history item be the one at POS, an absolute index.\n    Returns zero if POS is out of range, else non-zero. */\n int\n-history_set_pos (pos)\n-     int pos;\n+history_set_pos (int pos)\n {\n   if (pos > history_length || pos < 0 || !the_history)\n     return (0);\n@@ -172,15 +170,15 @@ history_set_pos (pos)\n    is the actual array of data, and could be bashed or made corrupt easily.\n    The array is terminated with a NULL pointer. */\n HIST_ENTRY **\n-history_list ()\n+history_list (void)\n {\n   return (the_history);\n }\n \n /* Return the history entry at the current position, as determined by\n    history_offset.  If there is no entry there, return a NULL pointer. */\n HIST_ENTRY *\n-current_history ()\n+current_history (void)\n {\n   return ((history_offset == history_length) || the_history == 0)\n \t\t? (HIST_ENTRY *)NULL\n@@ -191,7 +189,7 @@ current_history ()\n    a pointer to that entry.  If there is no previous entry then return\n    a NULL pointer. */\n HIST_ENTRY *\n-previous_history ()\n+previous_history (void)\n {\n   return history_offset ? the_history[--history_offset] : (HIST_ENTRY *)NULL;\n }\n@@ -200,16 +198,15 @@ previous_history ()\n    a pointer to that entry.  If there is no next entry then return a\n    NULL pointer. */\n HIST_ENTRY *\n-next_history ()\n+next_history (void)\n {\n   return (history_offset == history_length) ? (HIST_ENTRY *)NULL : the_history[++history_offset];\n }\n \n /* Return the history entry which is logically at OFFSET in the history array.\n    OFFSET is relative to history_base. */\n HIST_ENTRY *\n-history_get (offset)\n-     int offset;\n+history_get (int offset)\n {\n   int local_index;\n \n@@ -220,9 +217,7 @@ history_get (offset)\n }\n \n HIST_ENTRY *\n-alloc_history_entry (string, ts)\n-     char *string;\n-     char *ts;\n+alloc_history_entry (char *string, char *ts)\n {\n   HIST_ENTRY *temp;\n \n@@ -236,8 +231,7 @@ alloc_history_entry (string, ts)\n }\n \n time_t\n-history_get_time (hist)\n-     HIST_ENTRY *hist;\n+history_get_time (HIST_ENTRY *hist)\n {\n   char *ts;\n   time_t t;\n@@ -255,7 +249,7 @@ history_get_time (hist)\n }\n \n static char *\n-hist_inittime ()\n+hist_inittime (void)\n {\n   time_t t;\n   char ts[64], *ret;\n@@ -275,8 +269,7 @@ hist_inittime ()\n /* Place STRING at the end of the history list.  The data field\n    is  set to NULL. */\n void\n-add_history (string)\n-     const char *string;\n+add_history (const char *string)\n {\n   HIST_ENTRY *temp;\n   int new_length;\n@@ -335,8 +328,7 @@ add_history (string)\n \n /* Change the time stamp of the most recent history entry to STRING. */\n void\n-add_history_time (string)\n-     const char *string;\n+add_history_time (const char *string)\n {\n   HIST_ENTRY *hs;\n \n@@ -350,8 +342,7 @@ add_history_time (string)\n /* Free HIST and return the data so the calling application can free it\n    if necessary and desired. */\n histdata_t\n-free_history_entry (hist)\n-     HIST_ENTRY *hist;\n+free_history_entry (HIST_ENTRY *hist)\n {\n   histdata_t x;\n \n@@ -365,8 +356,7 @@ free_history_entry (hist)\n }\n \n HIST_ENTRY *\n-copy_history_entry (hist)\n-     HIST_ENTRY *hist;\n+copy_history_entry (HIST_ENTRY *hist)\n {\n   HIST_ENTRY *ret;\n   char *ts;\n@@ -388,10 +378,7 @@ copy_history_entry (hist)\n    the old entry so you can dispose of the data.  In the case of an\n    invalid WHICH, a NULL pointer is returned. */\n HIST_ENTRY *\n-replace_history_entry (which, line, data)\n-     int which;\n-     const char *line;\n-     histdata_t data;\n+replace_history_entry (int which, const char *line, histdata_t data)\n {\n   HIST_ENTRY *temp, *old_value;\n \n@@ -413,17 +400,26 @@ replace_history_entry (which, line, data)\n    end of the current line first.  This can be used to construct multi-line\n    history entries while reading lines from the history file. */\n void\n-_hs_append_history_line (which, line)\n-     int which;\n-     const char *line;\n+_hs_append_history_line (int which, const char *line)\n {\n   HIST_ENTRY *hent;\n-  size_t newlen, curlen;\n+  size_t newlen, curlen, minlen;\n   char *newline;\n \n   hent = the_history[which];\n   curlen = strlen (hent->line);\n-  newlen = curlen + strlen (line) + 2;\n+  minlen = curlen + strlen (line) + 2;\t/* min space needed */\n+  if (curlen > 256)\t\t/* XXX - for now */\n+    {\n+      newlen = 512;\t\t/* now realloc in powers of 2 */\n+      /* we recalcluate every time; the operations are cheap */\n+      while (newlen < minlen)\n+\tnewlen <<= 1;\n+    }\n+  else\n+    newlen = minlen;\n+  /* Assume that realloc returns the same pointer and doesn't try a new\n+     alloc/copy if the new size is the same as the one last passed. */\n   newline = realloc (hent->line, newlen);\n   if (newline)\n     {\n@@ -440,9 +436,7 @@ _hs_append_history_line (which, line)\n    WHICH >= 0 means to replace that particular history entry's data, as\n    long as it matches OLD. */\n void\n-_hs_replace_history_data (which, old, new)\n-     int which;\n-     histdata_t *old, *new;\n+_hs_replace_history_data (int which, histdata_t *old, histdata_t *new)\n {\n   HIST_ENTRY *entry;\n   register int i, last;\n@@ -482,29 +476,76 @@ _hs_replace_history_data (which, old, new)\n    element is returned to you so you can free the line, data,\n    and containing structure. */\n HIST_ENTRY *\n-remove_history (which)\n-     int which;\n+remove_history (int which)\n {\n   HIST_ENTRY *return_value;\n   register int i;\n+#if 1\n+  int nentries;\n+  HIST_ENTRY **start, **end;\n+#endif\n \n   if (which < 0 || which >= history_length || history_length ==  0 || the_history == 0)\n     return ((HIST_ENTRY *)NULL);\n \n   return_value = the_history[which];\n \n+#if 1\n+  /* Copy the rest of the entries, moving down one slot.  Copy includes\n+     trailing NULL.  */\n+  nentries = history_length - which;\n+  start = the_history + which;\n+  end = start + 1;\n+  memmove (start, end, nentries * sizeof (HIST_ENTRY *));\n+#else\n   for (i = which; i < history_length; i++)\n     the_history[i] = the_history[i + 1];\n+#endif\n \n   history_length--;\n \n   return (return_value);\n }\n \n+HIST_ENTRY **\n+remove_history_range (int first, int last)\n+{\n+  HIST_ENTRY **return_value;\n+  register int i;\n+  int nentries;\n+  HIST_ENTRY **start, **end;\n+\n+  if (the_history == 0 || history_length == 0)\n+    return ((HIST_ENTRY **)NULL);\n+  if (first < 0 || first >= history_length || last < 0 || last >= history_length)\n+    return ((HIST_ENTRY **)NULL);\n+  if (first > last)\n+    return (HIST_ENTRY **)NULL;\n+\n+  nentries = last - first + 1;\n+  return_value = (HIST_ENTRY **)malloc ((nentries + 1) * sizeof (HIST_ENTRY *));\n+  if (return_value == 0)\n+    return return_value;\n+\n+  /* Return all the deleted entries in a list */\n+  for (i = first ; i <= last; i++)\n+    return_value[i - first] = the_history[i];\n+  return_value[i - first] = (HIST_ENTRY *)NULL;\n+\n+  /* Copy the rest of the entries, moving down NENTRIES slots.  Copy includes\n+     trailing NULL.  */\n+  start = the_history + first;\n+  end = the_history + last + 1;\n+  memmove (start, end, (history_length - last) * sizeof (HIST_ENTRY *));\n+\n+  history_length -= nentries;\n+\n+  return (return_value);\n+}\n+\n /* Stifle the history list, remembering only MAX number of lines. */\n void\n-stifle_history (max)\n-     int max;\n+stifle_history (int max)\n {\n   register int i, j;\n \n@@ -532,7 +573,7 @@ stifle_history (max)\n    number of history entries.  The value is positive if the history\n    was stifled, negative if it wasn't. */\n int\n-unstifle_history ()\n+unstifle_history (void)\n {\n   if (history_stifled)\n     {\n@@ -544,13 +585,13 @@ unstifle_history ()\n }\n \n int\n-history_is_stifled ()\n+history_is_stifled (void)\n {\n   return (history_stifled);\n }\n \n void\n-clear_history ()\n+clear_history (void)\n {\n   register int i;\n \n@@ -562,4 +603,5 @@ clear_history ()\n     }\n \n   history_offset = history_length = 0;\n+  history_base = 1;\t\t/* reset history base to default */\n }"
    },
    {
      "sha": "cc3de29a64231d083d7b282e2eb247d692dbe521",
      "filename": "readline/history.h",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/history.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/history.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/history.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -86,11 +86,13 @@ extern void add_history PARAMS((const char *));\n    STRING. */\n extern void add_history_time PARAMS((const char *));\n \n-/* A reasonably useless function, only here for completeness.  WHICH\n-   is the magic number that tells us which element to delete.  The\n-   elements are numbered from 0. */\n+/* Remove an entry from the history list.  WHICH is the magic number that\n+   tells us which element to delete.  The elements are numbered from 0. */\n extern HIST_ENTRY *remove_history PARAMS((int));\n \n+/* Remove a set of entries from the history list: FIRST to LAST, inclusive */\n+extern HIST_ENTRY **remove_history_range PARAMS((int, int));\n+\n /* Allocate a history entry consisting of STRING and TIMESTAMP and return\n    a pointer to it. */\n extern HIST_ENTRY *alloc_history_entry PARAMS((char *, char *));\n@@ -259,7 +261,9 @@ extern char *history_word_delimiters;\n extern char history_comment_char;\n extern char *history_no_expand_chars;\n extern char *history_search_delimiter_chars;\n+\n extern int history_quotes_inhibit_expansion;\n+extern int history_quoting_state;\n \n extern int history_write_timestamps;\n "
    },
    {
      "sha": "7a426c96781429785f1b44ad3241da43e63df545",
      "filename": "readline/histsearch.c",
      "status": "modified",
      "additions": 109,
      "deletions": 16,
      "changes": 125,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histsearch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/histsearch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histsearch.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* histsearch.c -- searching the history list. */\n \n-/* Copyright (C) 1989, 1992-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1989, 1992-2009,2017 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -39,8 +39,13 @@\n #  include <unistd.h>\n #endif\n \n+#if defined (HAVE_FNMATCH)\n+#  include <fnmatch.h>\n+#endif\n+\n #include \"history.h\"\n #include \"histlib.h\"\n+#include \"xmalloc.h\"\n \n /* The list of alternate characters that can delimit a history search\n    string. */\n@@ -59,18 +64,22 @@ static int history_search_internal PARAMS((const char *, int, int));\n    returned. */\n \n static int\n-history_search_internal (string, direction, anchored)\n-     const char *string;\n-     int direction, anchored;\n+history_search_internal (const char *string, int direction, int flags)\n {\n   register int i, reverse;\n   register char *line;\n   register int line_index;\n-  int string_len;\n+  int string_len, anchored, patsearch;\n   HIST_ENTRY **the_history; \t/* local */\n \n   i = history_offset;\n   reverse = (direction < 0);\n+  anchored = (flags & ANCHORED_SEARCH);\n+#if defined (HAVE_FNMATCH)\n+  patsearch = (flags & PATTERN_SEARCH);\n+#else\n+  patsearch = 0;\n+#endif\n \n   /* Take care of trivial cases first. */\n   if (string == 0 || *string == '\\0')\n@@ -98,7 +107,7 @@ history_search_internal (string, direction, anchored)\n       line_index = strlen (line);\n \n       /* If STRING is longer than line, no match. */\n-      if (string_len > line_index)\n+      if (patsearch == 0 && (string_len > line_index))\n \t{\n \t  NEXT_LINE ();\n \t  continue;\n@@ -107,6 +116,17 @@ history_search_internal (string, direction, anchored)\n       /* Handle anchored searches first. */\n       if (anchored == ANCHORED_SEARCH)\n \t{\n+#if defined (HAVE_FNMATCH)\n+\t  if (patsearch)\n+\t    {\n+\t      if (fnmatch (string, line, 0) == 0)\n+\t\t{\n+\t\t  history_offset = i;\n+\t\t  return (0);\n+\t\t}\n+\t    }\n+\t  else\n+#endif\n \t  if (STREQN (string, line, string_len))\n \t    {\n \t      history_offset = i;\n@@ -120,10 +140,21 @@ history_search_internal (string, direction, anchored)\n       /* Do substring search. */\n       if (reverse)\n \t{\n-\t  line_index -= string_len;\n+\t  line_index -= (patsearch == 0) ? string_len : 1;\n \n \t  while (line_index >= 0)\n \t    {\n+#if defined (HAVE_FNMATCH)\n+\t      if (patsearch)\n+\t\t{\n+\t\t  if (fnmatch (string, line + line_index, 0) == 0)\n+\t\t    {\n+\t\t      history_offset = i;\n+\t\t      return (line_index);\n+\t\t    }\n+\t\t}\n+\t      else\n+#endif\n \t      if (STREQN (string, line + line_index, string_len))\n \t\t{\n \t\t  history_offset = i;\n@@ -141,6 +172,17 @@ history_search_internal (string, direction, anchored)\n \n \t  while (line_index < limit)\n \t    {\n+#if defined (HAVE_FNMATCH)\n+\t      if (patsearch)\n+\t\t{\n+\t\t  if (fnmatch (string, line + line_index, 0) == 0)\n+\t\t    {\n+\t\t      history_offset = i;\n+\t\t      return (line_index);\n+\t\t    }\n+\t\t}\n+\t      else\n+#endif\n \t      if (STREQN (string, line + line_index, string_len))\n \t\t{\n \t\t  history_offset = i;\n@@ -153,20 +195,73 @@ history_search_internal (string, direction, anchored)\n     }\n }\n \n+int\n+_hs_history_patsearch (const char *string, int direction, int flags)\n+{\n+  char *pat;\n+  size_t len, start;\n+  int ret, unescaped_backslash;\n+\n+#if defined (HAVE_FNMATCH)\n+  /* Assume that the string passed does not have a leading `^' and any\n+     anchored search request is captured in FLAGS */\n+  len = strlen (string);\n+  ret = len - 1;\n+  /* fnmatch is required to reject a pattern that ends with an unescaped\n+     backslash */\n+  if (unescaped_backslash = (string[ret] == '\\\\'))\n+    {\n+      while (ret > 0 && string[--ret] == '\\\\')\n+\tunescaped_backslash = 1 - unescaped_backslash;\n+    }\n+  if (unescaped_backslash)\n+    return -1;\n+  pat = (char *)xmalloc (len + 3);\n+  /* If the search string is not anchored, we'll be calling fnmatch (assuming\n+     we have it). Prefix a `*' to the front of the search string so we search\n+     anywhere in the line. */\n+  if ((flags & ANCHORED_SEARCH) == 0 && string[0] != '*')\n+    {\n+      pat[0] = '*';\n+      start = 1;\n+      len++;\n+    }\n+  else\n+    {\n+      start = 0;\n+    }\n+\n+  /* Attempt to reduce the number of searches by tacking a `*' onto the end\n+     of a pattern that doesn't have one.  Assume a pattern that ends in a\n+     backslash contains an even number of trailing backslashes; we check\n+     above */\n+  strcpy (pat + start, string);\n+  if (pat[len - 1] != '*')\n+    {\n+      pat[len] = '*';\t\t/* XXX */\n+      pat[len+1] = '\\0';\n+    }\n+#else\n+  pat = string;\n+#endif\n+\n+  ret = history_search_internal (pat, direction, flags|PATTERN_SEARCH);\n+\n+  if (pat != string)\n+    free (pat);\n+  return ret;\n+}\n+\t\n /* Do a non-anchored search for STRING through the history in DIRECTION. */\n int\n-history_search (string, direction)\n-     const char *string;\n-     int direction;\n+history_search (const char *string, int direction)\n {\n   return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));\n }\n \n /* Do an anchored search for string through the history in DIRECTION. */\n int\n-history_search_prefix (string, direction)\n-     const char *string;\n-     int direction;\n+history_search_prefix (const char *string, int direction)\n {\n   return (history_search_internal (string, direction, ANCHORED_SEARCH));\n }\n@@ -175,9 +270,7 @@ history_search_prefix (string, direction)\n    backwards.  POS is an absolute index into the history list at\n    which point to begin searching. */\n int\n-history_search_pos (string, dir, pos)\n-     const char *string;\n-     int dir, pos;\n+history_search_pos (const char *string, int dir, int pos)\n {\n   int ret, old;\n "
    },
    {
      "sha": "95ace842ba20e00f1bce6783b977898921915166",
      "filename": "readline/input.c",
      "status": "modified",
      "additions": 35,
      "deletions": 39,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/input.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/input.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/input.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* input.c -- character input functions for readline. */\n \n-/* Copyright (C) 1994-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -76,6 +76,10 @@ extern int errno;\n #  define O_NDELAY O_NONBLOCK\t/* Posix style */\n #endif\n \n+#if defined (HAVE_PSELECT)\n+extern sigset_t _rl_orig_sigset;\n+#endif\n+\n /* Non-null means it is a pointer to a function to run while waiting for\n    character input. */\n rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;\n@@ -108,10 +112,10 @@ int w32_isatty (int fd)\n {\n   if (_isatty(fd))\n     {\n-      HANDLE h = (HANDLE) _get_osfhandle (fd);\n+      HANDLE h;\n       DWORD ignored;\n \n-      if (h == INVALID_HANDLE_VALUE)\n+      if ((h = (HANDLE) _get_osfhandle (fd)) == INVALID_HANDLE_VALUE)\n \t{\n \t  errno = EBADF;\n \t  return 0;\n@@ -139,21 +143,21 @@ static int ibuffer_len = sizeof (ibuffer) - 1;\n #define any_typein (push_index != pop_index)\n \n int\n-_rl_any_typein ()\n+_rl_any_typein (void)\n {\n   return any_typein;\n }\n \n int\n-_rl_pushed_input_available ()\n+_rl_pushed_input_available (void)\n {\n   return (push_index != pop_index);\n }\n \n /* Return the amount of space available in the buffer for stuffing\n    characters. */\n static int\n-ibuffer_space ()\n+ibuffer_space (void)\n {\n   if (pop_index > push_index)\n     return (pop_index - push_index - 1);\n@@ -165,8 +169,7 @@ ibuffer_space ()\n    Return the key in KEY.\n    Result is non-zero if there was a key, or 0 if there wasn't. */\n static int\n-rl_get_char (key)\n-     int *key;\n+rl_get_char (int *key)\n {\n   if (push_index == pop_index)\n     return (0);\n@@ -186,8 +189,7 @@ rl_get_char (key)\n    Returns non-zero if successful, zero if there is\n    no space left in the buffer. */\n int\n-_rl_unget_char (key)\n-     int key;\n+_rl_unget_char (int key)\n {\n   if (ibuffer_space ())\n     {\n@@ -204,7 +206,7 @@ _rl_unget_char (key)\n    IBUFFER.  Otherwise, just return.  Returns number of characters read\n    (0 if none available) and -1 on error (EIO). */\n static int\n-rl_gather_tyi ()\n+rl_gather_tyi (void)\n {\n   int tty;\n   register int tem, result;\n@@ -307,8 +309,7 @@ rl_gather_tyi ()\n }\n \n int\n-rl_set_keyboard_input_timeout (u)\n-     int u;\n+rl_set_keyboard_input_timeout (int u)\n {\n   int o;\n \n@@ -325,7 +326,7 @@ rl_set_keyboard_input_timeout (u)\n    the user, it should use _rl_input_queued(timeout_value_in_microseconds)\n    instead. */\n int\n-_rl_input_available ()\n+_rl_input_available (void)\n {\n #if defined(HAVE_SELECT)\n   fd_set readfds, exceptfds;\n@@ -367,8 +368,7 @@ _rl_input_available ()\n }\n \n int\n-_rl_input_queued (t)\n-     int t;\n+_rl_input_queued (int t)\n {\n   int old_timeout, r;\n \n@@ -379,8 +379,7 @@ _rl_input_queued (t)\n }\n \n void\n-_rl_insert_typein (c)\n-     int c;     \n+_rl_insert_typein (int c)\n {    \t\n   int key, t, i;\n   char *string;\n@@ -405,8 +404,7 @@ _rl_insert_typein (c)\n /* Add KEY to the buffer of characters to be read.  Returns 1 if the\n    character was stuffed correctly; 0 otherwise. */\n int\n-rl_stuff_char (key)\n-     int key;\n+rl_stuff_char (int key)\n {\n   if (ibuffer_space () == 0)\n     return 0;\n@@ -430,8 +428,7 @@ rl_stuff_char (key)\n \n /* Make C be the next command to be executed. */\n int\n-rl_execute_next (c)\n-     int c;\n+rl_execute_next (int c)\n {\n   rl_pending_input = c;\n   RL_SETSTATE (RL_STATE_INPUTPENDING);\n@@ -440,7 +437,7 @@ rl_execute_next (c)\n \n /* Clear any pending input pushed with rl_execute_next() */\n int\n-rl_clear_pending_input ()\n+rl_clear_pending_input (void)\n {\n   rl_pending_input = 0;\n   RL_UNSETSTATE (RL_STATE_INPUTPENDING);\n@@ -455,20 +452,20 @@ rl_clear_pending_input ()\n \n /* Read a key, including pending input. */\n int\n-rl_read_key ()\n+rl_read_key (void)\n {\n   int c, r;\n \n   if (rl_pending_input)\n     {\n-      c = rl_pending_input;\n+      c = rl_pending_input;\t/* XXX - cast to unsigned char if > 0? */\n       rl_clear_pending_input ();\n     }\n   else\n     {\n       /* If input is coming from a macro, then use that. */\n       if (c = _rl_next_macro_key ())\n-\treturn (c);\n+\treturn ((unsigned char)c);\n \n       /* If the user has an event function, then call it periodically. */\n       if (rl_event_hook)\n@@ -505,8 +502,7 @@ rl_read_key ()\n }\n \n int\n-rl_getc (stream)\n-     FILE *stream;\n+rl_getc (FILE *stream)\n {\n   int result;\n   unsigned char c;\n@@ -527,11 +523,15 @@ rl_getc (stream)\n #endif\n       result = 0;\n #if defined (HAVE_PSELECT)\n-      sigemptyset (&empty_set);\n-      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);\n       FD_ZERO (&readfds);\n       FD_SET (fileno (stream), &readfds);\n+#  if defined (HANDLE_SIGNALS)\n+      result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &_rl_orig_sigset);\n+#  else\n+      sigemptyset (&empty_set);\n+      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);\n       result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &empty_set);\n+#  endif /* HANDLE_SIGNALS */\n #endif\n       if (result >= 0)\n \tresult = read (fileno (stream), &c, sizeof (unsigned char));\n@@ -618,9 +618,7 @@ rl_getc (stream)\n #if defined (HANDLE_MULTIBYTE)\n /* read multibyte char */\n int\n-_rl_read_mbchar (mbchar, size)\n-     char *mbchar;\n-     int size;\n+_rl_read_mbchar (char *mbchar, int size)\n {\n   int mb_len, c;\n   size_t mbchar_bytes_length;\n@@ -669,12 +667,9 @@ _rl_read_mbchar (mbchar, size)\n    may be FIRST.  Used by the search functions, among others.  Very similar\n    to _rl_read_mbchar. */\n int\n-_rl_read_mbstring (first, mb, mlen)\n-     int first;\n-     char *mb;\n-     int mlen;\n+_rl_read_mbstring (int first, char *mb, int mlen)\n {\n-  int i, c;\n+  int i, c, n;\n   mbstate_t ps;\n \n   c = first;\n@@ -683,7 +678,8 @@ _rl_read_mbstring (first, mb, mlen)\n     {\n       mb[i] = (char)c;\n       memset (&ps, 0, sizeof (mbstate_t));\n-      if (_rl_get_char_len (mb, &ps) == -2)\n+      n = _rl_get_char_len (mb, &ps);\n+      if (n == -2)\n \t{\n \t  /* Read more for multibyte character */\n \t  RL_SETSTATE (RL_STATE_MOREINPUT);"
    },
    {
      "sha": "d6c59041772cdb539db2076c7615328d47bbcc9b",
      "filename": "readline/isearch.c",
      "status": "modified",
      "additions": 60,
      "deletions": 37,
      "changes": 97,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/isearch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/isearch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/isearch.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -6,7 +6,7 @@\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -78,8 +78,7 @@ static int last_isearch_string_len;\n static char * const default_isearch_terminators = \"\\033\\012\";\n \n _rl_search_cxt *\n-_rl_scxt_alloc (type, flags)\n-     int type, flags;\n+_rl_scxt_alloc (int type, int flags)\n {\n   _rl_search_cxt *cxt;\n \n@@ -120,9 +119,7 @@ _rl_scxt_alloc (type, flags)\n }\n \n void\n-_rl_scxt_dispose (cxt, flags)\n-     _rl_search_cxt *cxt;\n-     int flags;\n+_rl_scxt_dispose (_rl_search_cxt *cxt, int flags)\n {\n   FREE (cxt->search_string);\n   FREE (cxt->allocated_line);\n@@ -134,17 +131,15 @@ _rl_scxt_dispose (cxt, flags)\n /* Search backwards through the history looking for a string which is typed\n    interactively.  Start with the current line. */\n int\n-rl_reverse_search_history (sign, key)\n-     int sign, key;\n+rl_reverse_search_history (int sign, int key)\n {\n   return (rl_search_history (-sign, key));\n }\n \n /* Search forwards through the history looking for a string which is typed\n    interactively.  Start with the current line. */\n int\n-rl_forward_search_history (sign, key)\n-     int sign, key;\n+rl_forward_search_history (int sign, int key)\n {\n   return (rl_search_history (sign, key));\n }\n@@ -155,9 +150,7 @@ rl_forward_search_history (sign, key)\n    WHERE is the history list number of the current line.  If it is\n    -1, then this line is the starting one. */\n static void\n-rl_display_search (search_string, flags, where)\n-     char *search_string;\n-     int flags, where;\n+rl_display_search (char *search_string, int flags, int where)\n {\n   char *message;\n   int msglen, searchlen;\n@@ -206,8 +199,7 @@ rl_display_search (search_string, flags, where)\n }\n \n static _rl_search_cxt *\n-_rl_isearch_init (direction)\n-     int direction;\n+_rl_isearch_init (int direction)\n {\n   _rl_search_cxt *cxt;\n   register int i;\n@@ -267,11 +259,10 @@ _rl_isearch_init (direction)\n }\n \n static void\n-_rl_isearch_fini (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_isearch_fini (_rl_search_cxt *cxt)\n {\n   /* First put back the original state. */\n-  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);\n+  rl_replace_line (cxt->lines[cxt->save_line], 0);\n \n   rl_restore_prompt ();\n \n@@ -301,13 +292,13 @@ _rl_isearch_fini (cxt)\n   rl_point = cxt->sline_index;\n   /* Don't worry about where to put the mark here; rl_get_previous_history\n      and rl_get_next_history take care of it. */\n+  _rl_fix_point (0);\n \n   rl_clear_message ();\n }\n \n int\n-_rl_search_getchar (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_search_getchar (_rl_search_cxt *cxt)\n {\n   int c;\n \n@@ -334,11 +325,12 @@ _rl_search_getchar (cxt)\n    -1 if the caller should just free the context and return, 0 if we should\n    break out of the loop, and 1 if we should continue to read characters. */\n int\n-_rl_isearch_dispatch (cxt, c)\n-     _rl_search_cxt *cxt;\n-     int c;\n+_rl_isearch_dispatch (_rl_search_cxt *cxt, int c)\n {\n-  int n, wstart, wlen, limit, cval;\n+  int n, wstart, wlen, limit, cval, incr;\n+  char *paste;\n+  size_t pastelen;\n+  int j;\n   rl_command_func_t *f;\n \n   f = (rl_command_func_t *)NULL;\n@@ -409,6 +401,8 @@ _rl_isearch_dispatch (cxt, c)\n \tcxt->lastc = -5;\n       else if (c == CTRL ('Y') || f == rl_yank)\t/* XXX */\n \tcxt->lastc = -6;\n+      else if (f == rl_bracketed_paste_begin)\n+\tcxt->lastc = -7;\n     }\n \n   /* If we changed the keymap earlier while translating a key sequence into\n@@ -527,7 +521,7 @@ _rl_isearch_dispatch (cxt, c)\n \t    }\n \t  return (1);\n \t}\n-      else if (cxt->sflags & SF_REVERSE)\n+      else if ((cxt->sflags & SF_REVERSE) && cxt->sline_index >= 0)\n \tcxt->sline_index--;\n       else if (cxt->sline_index != cxt->sline_len)\n \tcxt->sline_index++;\n@@ -631,22 +625,44 @@ _rl_isearch_dispatch (cxt, c)\n       cxt->search_string[cxt->search_string_index] = '\\0';\n       break;\n \n+    case -7:\t/* bracketed paste */\n+      paste = _rl_bracketed_text (&pastelen);\n+      if (paste == 0 || *paste == 0)\n+\t{\n+\t  free (paste);\n+\t  break;\n+\t}\n+      if (cxt->search_string_index + pastelen + 1 >= cxt->search_string_size)\n+\t{\n+\t  cxt->search_string_size += pastelen + 2;\n+\t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n+\t}\n+      strcpy (cxt->search_string + cxt->search_string_index, paste);\n+      cxt->search_string_index += pastelen;\n+      free (paste);\n+      break;\n+\n     /* Add character to search string and continue search. */\n     default:\n-      if (cxt->search_string_index + 2 >= cxt->search_string_size)\n+#if defined (HANDLE_MULTIBYTE)\n+      wlen = (cxt->mb[0] == 0 || cxt->mb[1] == 0) ? 1 : RL_STRLEN (cxt->mb);\n+#else\n+      wlen = 1;\n+#endif\n+      if (cxt->search_string_index + wlen + 1 >= cxt->search_string_size)\n \t{\n-\t  cxt->search_string_size += 128;\n+\t  cxt->search_string_size += 128;\t/* 128 much greater than MB_CUR_MAX */\n \t  cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n \t}\n #if defined (HANDLE_MULTIBYTE)\n       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \t{\n-\t  int j, l;\n+\t  int j;\n \n \t  if (cxt->mb[0] == 0 || cxt->mb[1] == 0)\n \t    cxt->search_string[cxt->search_string_index++] = cxt->mb[0];\n \t  else\n-\t    for (j = 0, l = RL_STRLEN (cxt->mb); j < l; )\n+\t    for (j = 0; j < wlen; )\n \t      cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];\n \t}\n       else\n@@ -676,6 +692,12 @@ _rl_isearch_dispatch (cxt, c)\n \t    }\n \t  else\n \t    cxt->sline_index += cxt->direction;\n+\n+\t  if (cxt->sline_index < 0)\n+\t    {\n+\t      cxt->sline_index = 0;\n+\t      break;\n+\t    }\n \t}\n       if (cxt->sflags & SF_FOUND)\n \tbreak;\n@@ -703,7 +725,12 @@ _rl_isearch_dispatch (cxt, c)\n \t     (cxt->search_string_index > cxt->sline_len));\n \n       if (cxt->sflags & SF_FAILED)\n-\tbreak;\n+\t{\n+\t  /* XXX - reset sline_index if < 0 */\n+\t  if (cxt->sline_index < 0)\n+\t    cxt->sline_index = 0;\n+\t  break;\n+\t}\n \n       /* Now set up the line for searching... */\n       cxt->sline_index = (cxt->sflags & SF_REVERSE) ? cxt->sline_len - cxt->search_string_index : 0;\n@@ -734,9 +761,7 @@ _rl_isearch_dispatch (cxt, c)\n }\n \n int\n-_rl_isearch_cleanup (cxt, r)\n-     _rl_search_cxt *cxt;\n-     int r;\n+_rl_isearch_cleanup (_rl_search_cxt *cxt, int r)\n {\n   if (r >= 0)\n     _rl_isearch_fini (cxt);\n@@ -753,8 +778,7 @@ _rl_isearch_cleanup (cxt, r)\n    DIRECTION is which direction to search; >= 0 means forward, < 0 means\n    backwards. */\n static int\n-rl_search_history (direction, invoking_key)\n-     int direction, invoking_key;\n+rl_search_history (int direction, int invoking_key)\n {\n   _rl_search_cxt *cxt;\t\t/* local for now, but saved globally */\n   int c, r;\n@@ -792,8 +816,7 @@ rl_search_history (direction, invoking_key)\n    If _rl_isearch_dispatch finishes searching, this function is responsible\n    for turning off RL_STATE_ISEARCH, which it does using _rl_isearch_cleanup. */\n int\n-_rl_isearch_callback (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_isearch_callback (_rl_search_cxt *cxt)\n {\n   int c, r;\n "
    },
    {
      "sha": "4ade30bcd0365771de5cfa92a3b45839fed989d1",
      "filename": "readline/keymaps.c",
      "status": "modified",
      "additions": 21,
      "deletions": 9,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/keymaps.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/keymaps.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/keymaps.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* keymaps.c -- Functions and keymaps for the GNU Readline library. */\n \n-/* Copyright (C) 1988,1989-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1988,1989-2009,2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -54,7 +54,7 @@\n /* Return a new, empty keymap.\n    Free it with free() when you are done. */\n Keymap\n-rl_make_bare_keymap ()\n+rl_make_bare_keymap (void)\n {\n   register int i;\n   Keymap keymap;\n@@ -77,11 +77,25 @@ rl_make_bare_keymap ()\n   return (keymap);\n }\n \n+/* A convenience function that returns 1 if there are no keys bound to\n+   functions in KEYMAP */\n+int\n+rl_empty_keymap (Keymap keymap)\n+{\n+  int i;\n+\n+  for (i = 0; i < ANYOTHERKEY; i++)\n+    {\n+      if (keymap[i].type != ISFUNC || keymap[i].function)\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n /* Return a new keymap which is a copy of MAP.  Just copies pointers, does\n    not copy text of macros or descend into child keymaps. */\n Keymap\n-rl_copy_keymap (map)\n-     Keymap map;\n+rl_copy_keymap (Keymap map)\n {\n   register int i;\n   Keymap temp;\n@@ -99,7 +113,7 @@ rl_copy_keymap (map)\n    the uppercase Meta characters bound to run their lowercase equivalents,\n    and the Meta digits bound to produce numeric arguments. */\n Keymap\n-rl_make_keymap ()\n+rl_make_keymap (void)\n {\n   register int i;\n   Keymap newmap;\n@@ -125,8 +139,7 @@ rl_make_keymap ()\n \n /* Free the storage associated with MAP. */\n void\n-rl_discard_keymap (map)\n-     Keymap map;\n+rl_discard_keymap (Keymap map)\n {\n   int i;\n \n@@ -154,8 +167,7 @@ rl_discard_keymap (map)\n \n /* Convenience function that discards, then frees, MAP. */\n void\n-rl_free_keymap (map)\n-     Keymap map;\n+rl_free_keymap (Keymap map)\n {\n   rl_discard_keymap (map);\n   xfree ((char *)map);"
    },
    {
      "sha": "1fa853d8c1e6a68a9e06d79c880e7d246759ced6",
      "filename": "readline/keymaps.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/keymaps.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/keymaps.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/keymaps.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -90,6 +90,9 @@ extern Keymap rl_get_keymap PARAMS((void));\n /* Set the current keymap to MAP. */\n extern void rl_set_keymap PARAMS((Keymap));\n \n+/* Set the name of MAP to NAME */\n+extern int rl_set_keymap_name PARAMS((const char *, Keymap));\n+\n #ifdef __cplusplus\n }\n #endif"
    },
    {
      "sha": "cf8ca93243b8b282f70c2f0b3ea7657e34c1b49c",
      "filename": "readline/kill.c",
      "status": "modified",
      "additions": 57,
      "deletions": 69,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/kill.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/kill.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/kill.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* kill.c -- kill ring management. */\n \n-/* Copyright (C) 1994-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -78,8 +78,7 @@ static int rl_yank_nth_arg_internal PARAMS((int, int, int));\n /* How to say that you only want to save a certain amount\n    of kill material. */\n int\n-rl_set_retained_kills (num)\n-     int num;\n+rl_set_retained_kills (int num)\n {\n   return 0;\n }\n@@ -89,9 +88,7 @@ rl_set_retained_kills (num)\n    non-zero, and the last command was a kill, the text is appended to the\n    current kill ring slot, otherwise prepended. */\n static int\n-_rl_copy_to_kill_ring (text, append)\n-     char *text;\n-     int append;\n+_rl_copy_to_kill_ring (char *text, int append)\n {\n   char *old, *new;\n   int slot;\n@@ -122,7 +119,7 @@ _rl_copy_to_kill_ring (text, append)\n \t  else\n \t    {\n \t      slot = rl_kill_ring_length += 1;\n-\t      rl_kill_ring = (char **)xrealloc (rl_kill_ring, slot * sizeof (char *));\n+\t      rl_kill_ring = (char **)xrealloc (rl_kill_ring, (slot + 1) * sizeof (char *));\n \t    }\n \t  rl_kill_ring[--slot] = (char *)NULL;\n \t}\n@@ -131,7 +128,7 @@ _rl_copy_to_kill_ring (text, append)\n     slot = rl_kill_ring_length - 1;\n \n   /* If the last command was a kill, prepend or append. */\n-  if (_rl_last_command_was_kill && rl_editing_mode != vi_mode)\n+  if (_rl_last_command_was_kill && rl_kill_ring[slot] && rl_editing_mode != vi_mode)\n     {\n       old = rl_kill_ring[slot];\n       new = (char *)xmalloc (1 + strlen (old) + strlen (text));\n@@ -163,8 +160,7 @@ _rl_copy_to_kill_ring (text, append)\n    last command was not a kill command, then a new slot is made for\n    this kill. */\n int\n-rl_kill_text (from, to)\n-     int from, to;\n+rl_kill_text (int from, int to)\n {\n   char *text;\n \n@@ -198,8 +194,7 @@ rl_kill_text (from, to)\n \n /* Delete the word at point, saving the text in the kill ring. */\n int\n-rl_kill_word (count, key)\n-     int count, key;\n+rl_kill_word (int count, int key)\n {\n   int orig_point;\n \n@@ -222,17 +217,16 @@ rl_kill_word (count, key)\n \n /* Rubout the word before point, placing it on the kill ring. */\n int\n-rl_backward_kill_word (count, ignore)\n-     int count, ignore;\n+rl_backward_kill_word (int count, int key)\n {\n   int orig_point;\n \n   if (count < 0)\n-    return (rl_kill_word (-count, ignore));\n+    return (rl_kill_word (-count, key));\n   else\n     {\n       orig_point = rl_point;\n-      rl_backward_word (count, ignore);\n+      rl_backward_word (count, key);\n \n       if (rl_point != orig_point)\n \trl_kill_text (orig_point, rl_point);\n@@ -246,17 +240,16 @@ rl_backward_kill_word (count, ignore)\n /* Kill from here to the end of the line.  If DIRECTION is negative, kill\n    back to the line start instead. */\n int\n-rl_kill_line (direction, ignore)\n-     int direction, ignore;\n+rl_kill_line (int direction, int key)\n {\n   int orig_point;\n \n   if (direction < 0)\n-    return (rl_backward_kill_line (1, ignore));\n+    return (rl_backward_kill_line (1, key));\n   else\n     {\n       orig_point = rl_point;\n-      rl_end_of_line (1, ignore);\n+      rl_end_of_line (1, key);\n       if (orig_point != rl_point)\n \trl_kill_text (orig_point, rl_point);\n       rl_point = orig_point;\n@@ -269,21 +262,20 @@ rl_kill_line (direction, ignore)\n /* Kill backwards to the start of the line.  If DIRECTION is negative, kill\n    forwards to the line end instead. */\n int\n-rl_backward_kill_line (direction, ignore)\n-     int direction, ignore;\n+rl_backward_kill_line (int direction, int key)\n {\n   int orig_point;\n \n   if (direction < 0)\n-    return (rl_kill_line (1, ignore));\n+    return (rl_kill_line (1, key));\n   else\n     {\n       if (rl_point == 0)\n \trl_ding ();\n       else\n \t{\n \t  orig_point = rl_point;\n-\t  rl_beg_of_line (1, ignore);\n+\t  rl_beg_of_line (1, key);\n \t  if (rl_point != orig_point)\n \t    rl_kill_text (orig_point, rl_point);\n \t  if (rl_editing_mode == emacs_mode)\n@@ -295,8 +287,7 @@ rl_backward_kill_line (direction, ignore)\n \n /* Kill the whole line, no matter where point is. */\n int\n-rl_kill_full_line (count, ignore)\n-     int count, ignore;\n+rl_kill_full_line (int count, int key)\n {\n   rl_begin_undo_group ();\n   rl_point = 0;\n@@ -313,8 +304,7 @@ rl_kill_full_line (count, ignore)\n /* This does what C-w does in Unix.  We can't prevent people from\n    using behaviour that they expect. */\n int\n-rl_unix_word_rubout (count, key)\n-     int count, key;\n+rl_unix_word_rubout (int count, int key)\n {\n   int orig_point;\n \n@@ -332,7 +322,7 @@ rl_unix_word_rubout (count, key)\n \t    rl_point--;\n \n \t  while (rl_point && (whitespace (rl_line_buffer[rl_point - 1]) == 0))\n-\t    rl_point--;\n+\t    rl_point--;\t\t/* XXX - multibyte? */\n \t}\n \n       rl_kill_text (orig_point, rl_point);\n@@ -346,8 +336,7 @@ rl_unix_word_rubout (count, key)\n /* This deletes one filename component in a Unix pathname.  That is, it\n    deletes backward to directory separator (`/') or whitespace.  */\n int\n-rl_unix_filename_rubout (count, key)\n-     int count, key;\n+rl_unix_filename_rubout (int count, int key)\n {\n   int orig_point, c;\n \n@@ -370,7 +359,7 @@ rl_unix_filename_rubout (count, key)\n \n \t  while (rl_point && (whitespace (c) == 0) && c != '/')\n \t    {\n-\t      rl_point--;\n+\t      rl_point--;\t/* XXX - multibyte? */\n \t      c = rl_line_buffer[rl_point - 1];\n \t    }\n \t}\n@@ -390,8 +379,7 @@ rl_unix_filename_rubout (count, key)\n    into the line at all, and if you aren't, then you know what you are\n    doing. */\n int\n-rl_unix_line_discard (count, key)\n-     int count, key;\n+rl_unix_line_discard (int count, int key)\n {\n   if (rl_point == 0)\n     rl_ding ();\n@@ -408,8 +396,7 @@ rl_unix_line_discard (count, key)\n /* Copy the text in the `region' to the kill ring.  If DELETE is non-zero,\n    delete the text from the line as well. */\n static int\n-region_kill_internal (delete)\n-     int delete;\n+region_kill_internal (int delete)\n {\n   char *text;\n \n@@ -427,16 +414,14 @@ region_kill_internal (delete)\n \n /* Copy the text in the region to the kill ring. */\n int\n-rl_copy_region_to_kill (count, ignore)\n-     int count, ignore;\n+rl_copy_region_to_kill (int count, int key)\n {\n   return (region_kill_internal (0));\n }\n \n /* Kill the text between the point and mark. */\n int\n-rl_kill_region (count, ignore)\n-     int count, ignore;\n+rl_kill_region (int count, int key)\n {\n   int r, npoint;\n \n@@ -450,8 +435,7 @@ rl_kill_region (count, ignore)\n /* Copy COUNT words to the kill ring.  DIR says which direction we look\n    to find the words. */\n static int\n-_rl_copy_word_as_kill (count, dir)\n-     int count, dir;\n+_rl_copy_word_as_kill (int count, int dir)\n {\n   int om, op, r;\n \n@@ -479,8 +463,7 @@ _rl_copy_word_as_kill (count, dir)\n }\n \n int\n-rl_copy_forward_word (count, key)\n-     int count, key;\n+rl_copy_forward_word (int count, int key)\n {\n   if (count < 0)\n     return (rl_copy_backward_word (-count, key));\n@@ -489,8 +472,7 @@ rl_copy_forward_word (count, key)\n }\n \n int\n-rl_copy_backward_word (count, key)\n-     int count, key;\n+rl_copy_backward_word (int count, int key)\n {\n   if (count < 0)\n     return (rl_copy_forward_word (-count, key));\n@@ -500,8 +482,7 @@ rl_copy_backward_word (count, key)\n   \n /* Yank back the last killed text.  This ignores arguments. */\n int\n-rl_yank (count, ignore)\n-     int count, ignore;\n+rl_yank (int count, int key)\n {\n   if (rl_kill_ring == 0)\n     {\n@@ -519,8 +500,7 @@ rl_yank (count, ignore)\n    delete that text from the line, rotate the index down, and\n    yank back some other text. */\n int\n-rl_yank_pop (count, key)\n-     int count, key;\n+rl_yank_pop (int count, int key)\n {\n   int l, n;\n \n@@ -552,8 +532,7 @@ rl_yank_pop (count, key)\n \n #if defined (VI_MODE)\n int\n-rl_vi_yank_pop (count, key)\n-     int count, key;\n+rl_vi_yank_pop (int count, int key)\n {\n   int l, n;\n \n@@ -587,8 +566,7 @@ rl_vi_yank_pop (count, key)\n /* Yank the COUNTh argument from the previous history line, skipping\n    HISTORY_SKIP lines before looking for the `previous line'. */\n static int\n-rl_yank_nth_arg_internal (count, ignore, history_skip)\n-     int count, ignore, history_skip;\n+rl_yank_nth_arg_internal (int count, int key, int history_skip)\n {\n   register HIST_ENTRY *entry;\n   char *arg;\n@@ -629,7 +607,7 @@ rl_yank_nth_arg_internal (count, ignore, history_skip)\n      inserts it right *after* rl_point. */\n   if (rl_editing_mode == vi_mode)\n     {\n-      rl_vi_append_mode (1, ignore);\n+      rl_vi_append_mode (1, key);\n       rl_insert_text (\" \");\n     }\n #endif /* VI_MODE */\n@@ -643,18 +621,16 @@ rl_yank_nth_arg_internal (count, ignore, history_skip)\n \n /* Yank the COUNTth argument from the previous history line. */\n int\n-rl_yank_nth_arg (count, ignore)\n-     int count, ignore;\n+rl_yank_nth_arg (int count, int key)\n {\n-  return (rl_yank_nth_arg_internal (count, ignore, 0));\n+  return (rl_yank_nth_arg_internal (count, key, 0));\n }\n \n /* Yank the last argument from the previous history line.  This `knows'\n    how rl_yank_nth_arg treats a count of `$'.  With an argument, this\n    behaves the same as rl_yank_nth_arg. */\n int\n-rl_yank_last_arg (count, key)\n-     int count, key;\n+rl_yank_last_arg (int count, int key)\n {\n   static int history_skip = 0;\n   static int explicit_arg_p = 0;\n@@ -694,17 +670,16 @@ rl_yank_last_arg (count, key)\n    `bracketed paste' sequence, read the rest of the pasted input until the\n    closing sequence and insert the pasted text as a single unit without\n    interpretation. */\n-int\n-rl_bracketed_paste_begin (count, key)\n-     int count, key;\n+char *\n+_rl_bracketed_text (size_t *lenp)\n {\n-  int retval, c;\n+  int c;\n   size_t len, cap;\n   char *buf;\n \n-  retval = 1;\n   len = 0;\n   buf = xmalloc (cap = 64);\n+  buf[0] = '\\0';\n \n   RL_SETSTATE (RL_STATE_MOREINPUT);\n   while ((c = rl_read_key ()) >= 0)\n@@ -733,20 +708,33 @@ rl_bracketed_paste_begin (count, key)\n       if (len == cap)\n \tbuf = xrealloc (buf, cap + 1);\n       buf[len] = '\\0';\n-      retval = rl_insert_text (buf);\n     }\n \n+  if (lenp)\n+    *lenp = len;\n+  return (buf);\n+}\n+\n+int\n+rl_bracketed_paste_begin (int count, int key)\n+{\n+  int retval, c;\n+  size_t len, cap;\n+  char *buf;\n+\n+  buf = _rl_bracketed_text (&len);\n+  retval = rl_insert_text (buf) == len ? 0 : 1;\n+\n   xfree (buf);\n   return (retval);\n }\n \n-/* A special paste command for Windows users.. */\n+/* A special paste command for Windows users. */\n #if defined (_WIN32)\n #include <windows.h>\n \n int\n-rl_paste_from_clipboard (count, key)\n-     int count, key;\n+rl_paste_from_clipboard (int count, int key)\n {\n   char *data, *ptr;\n   int len;"
    },
    {
      "sha": "92cc55c36dc001e78ddddd1e488dee0b1d42ab8a",
      "filename": "readline/macro.c",
      "status": "modified",
      "additions": 46,
      "deletions": 21,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/macro.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* macro.c -- keyboard macros for readline. */\n \n-/* Copyright (C) 1994-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2009,2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -49,6 +49,8 @@\n #include \"rlprivate.h\"\n #include \"xmalloc.h\"\n \n+#define MAX_MACRO_LEVEL 16\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tHacking Keyboard Macros \t\t    */\n@@ -83,13 +85,24 @@ struct saved_macro {\n /* The list of saved macros. */\n static struct saved_macro *macro_list = (struct saved_macro *)NULL;\n \n+static int macro_level = 0;\n+\n /* Set up to read subsequent input from STRING.\n    STRING is free ()'ed when we are done with it. */\n void\n-_rl_with_macro_input (string)\n-     char *string;\n+_rl_with_macro_input (char *string)\n {\n-  _rl_push_executing_macro ();\n+  if (macro_level > MAX_MACRO_LEVEL)\n+    {\n+      _rl_errmsg (\"maximum macro execution nesting level exceeded\");\n+      _rl_abort_internal ();\n+      return;\n+    }\n+\n+#if 0\n+  if (rl_executing_macro)\t\t/* XXX - later */\n+#endif\n+    _rl_push_executing_macro ();\n   rl_executing_macro = string;\n   executing_macro_index = 0;\n   RL_SETSTATE(RL_STATE_MACROINPUT);\n@@ -98,7 +111,7 @@ _rl_with_macro_input (string)\n /* Return the next character available from a macro, or 0 if\n    there are no macro characters. */\n int\n-_rl_next_macro_key ()\n+_rl_next_macro_key (void)\n {\n   int c;\n \n@@ -117,12 +130,26 @@ _rl_next_macro_key ()\n       _rl_pop_executing_macro ();\n   return c;\n #else\n+  /* XXX - consider doing the same as the callback code, just not testing\n+     whether we're running in callback mode */\n   return (rl_executing_macro[executing_macro_index++]);\n #endif\n }\n \n int\n-_rl_prev_macro_key ()\n+_rl_peek_macro_key (void)\n+{\n+  if (rl_executing_macro == 0)\n+    return (0);\n+  if (rl_executing_macro[executing_macro_index] == 0 && (macro_list == 0 || macro_list->string == 0))\n+    return (0);\n+  if (rl_executing_macro[executing_macro_index] == 0 && macro_list && macro_list->string)\n+    return (macro_list->string[0]);\n+  return (rl_executing_macro[executing_macro_index]);\n+}\n+\n+int\n+_rl_prev_macro_key (void)\n {\n   if (rl_executing_macro == 0)\n     return (0);\n@@ -136,7 +163,7 @@ _rl_prev_macro_key ()\n \n /* Save the currently executing macro on a stack of saved macros. */\n void\n-_rl_push_executing_macro ()\n+_rl_push_executing_macro (void)\n {\n   struct saved_macro *saver;\n \n@@ -146,12 +173,14 @@ _rl_push_executing_macro ()\n   saver->string = rl_executing_macro;\n \n   macro_list = saver;\n+\n+  macro_level++;\n }\n \n /* Discard the current macro, replacing it with the one\n    on the top of the stack of saved macros. */\n void\n-_rl_pop_executing_macro ()\n+_rl_pop_executing_macro (void)\n {\n   struct saved_macro *macro;\n \n@@ -168,14 +197,15 @@ _rl_pop_executing_macro ()\n       xfree (macro);\n     }\n \n+  macro_level--;\n+\n   if (rl_executing_macro == 0)\n     RL_UNSETSTATE(RL_STATE_MACROINPUT);\n }\n \n /* Add a character to the macro being built. */\n void\n-_rl_add_macro_char (c)\n-     int c;\n+_rl_add_macro_char (int c)\n {\n   if (current_macro_index + 1 >= current_macro_size)\n     {\n@@ -190,7 +220,7 @@ _rl_add_macro_char (c)\n }\n \n void\n-_rl_kill_kbd_macro ()\n+_rl_kill_kbd_macro (void)\n {\n   if (current_macro)\n     {\n@@ -213,8 +243,7 @@ _rl_kill_kbd_macro ()\n    definition to the end of the existing macro, and start by\n    re-executing the existing macro. */\n int\n-rl_start_kbd_macro (ignore1, ignore2)\n-     int ignore1, ignore2;\n+rl_start_kbd_macro (int ignore1, int ignore2)\n {\n   if (RL_ISSTATE (RL_STATE_MACRODEF))\n     {\n@@ -238,8 +267,7 @@ rl_start_kbd_macro (ignore1, ignore2)\n    A numeric argument says to execute the macro right now,\n    that many times, counting the definition as the first time. */\n int\n-rl_end_kbd_macro (count, ignore)\n-     int count, ignore;\n+rl_end_kbd_macro (int count, int ignore)\n {\n   if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)\n     {\n@@ -258,8 +286,7 @@ rl_end_kbd_macro (count, ignore)\n /* Execute the most recently defined keyboard macro.\n    COUNT says how many times to execute it. */\n int\n-rl_call_last_kbd_macro (count, ignore)\n-     int count, ignore;\n+rl_call_last_kbd_macro (int count, int ignore)\n {\n   if (current_macro == 0)\n     _rl_abort_internal ();\n@@ -277,8 +304,7 @@ rl_call_last_kbd_macro (count, ignore)\n }\n \n int\n-rl_print_last_kbd_macro (count, ignore)\n-     int count, ignore;\n+rl_print_last_kbd_macro (int count, int ignore)\n {\n   char *m;\n \n@@ -300,8 +326,7 @@ rl_print_last_kbd_macro (count, ignore)\n }\n \n void\n-rl_push_macro_input (macro)\n-     char *macro;\n+rl_push_macro_input (char *macro)\n {\n   _rl_with_macro_input (macro);\n }"
    },
    {
      "sha": "17716357feb0c31b686636ccece7a1567426db35",
      "filename": "readline/mbutil.c",
      "status": "modified",
      "additions": 109,
      "deletions": 47,
      "changes": 156,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/mbutil.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/mbutil.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/mbutil.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* mbutil.c -- readline multibyte character utility functions */\n \n-/* Copyright (C) 2001-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 2001-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -75,10 +75,59 @@ int _rl_utf8locale = 0;\n \n #if defined(HANDLE_MULTIBYTE)\n \n+/* **************************************************************** */\n+/*\t\t\t\t\t\t\t\t    */\n+/*\t\tUTF-8 specific Character Utility Functions\t    */\n+/*\t\t\t\t\t\t\t\t    */\n+/* **************************************************************** */\n+\n+/* Return the length in bytes of the possibly-multibyte character beginning\n+   at S. Encoding is UTF-8. */\n+static int\n+_rl_utf8_mblen (const char *s, size_t n)\n+{\n+  unsigned char c, c1;\n+\n+  if (s == 0)\n+    return (0);\t/* no shift states */\n+  if (n <= 0)\n+    return (-1);\n+\n+  c = (unsigned char)*s;\n+  if (c < 0x80)\n+    return (c != 0);\n+  if (c >= 0xc2)\n+    {\n+      c1 = (unsigned char)s[1];\n+      if (c < 0xe0)\n+\t{\n+\t  if (n >= 2 && (s[1] ^ 0x80) < 0x40)\n+\t    return 2;\n+\t}\n+      else if (c < 0xf0)\n+\t{\n+\t  if (n >= 3\n+\t\t&& (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n+\t\t&& (c >= 0xe1 || c1 >= 0xa0)\n+\t\t&& (c != 0xed || c1 < 0xa0))\n+\t    return 3;\n+\t}\n+      else if (c < 0xf8)\n+\t{\n+\t  if (n >= 4\n+\t\t&& (s[1] ^ 0x80) < 0x40 && (s[2] ^ 0x80) < 0x40\n+\t \t&& (s[3] ^ 0x80) < 0x40\n+\t\t&& (c >= 0xf1 || c1 >= 0x90)\n+\t\t&& (c < 0xf4 || (c == 0xf4 && c1 < 0x90)))\n+\t    return 4;\n+\t}\n+    }\n+  /* invalid or incomplete multibyte character */\n+  return -1;\n+}\n+\n static int\n-_rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n-     char *string;\n-     int seed, count, find_non_zero;\n+_rl_find_next_mbchar_internal (char *string, int seed, int count, int find_non_zero)\n {\n   size_t tmp, len;\n   mbstate_t ps;\n@@ -94,6 +143,11 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n     return seed;\n \n   point = seed + _rl_adjust_point (string, seed, &ps);\n+  /* if _rl_adjust_point returns -1, the character or string is invalid.\n+     treat as a byte. */\n+  if (point == seed - 1)\t/* invalid */\n+    return seed + 1;\n+    \n   /* if this is true, means that seed was not pointing to a byte indicating\n      the beginning of a multibyte character.  Correct the point and consume\n      one char. */\n@@ -105,7 +159,14 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n       len = strlen (string + point);\n       if (len == 0)\n \tbreak;\n-      tmp = mbrtowc (&wc, string+point, len, &ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))\n+\t{\n+\t  tmp = 1;\n+\t  wc = (wchar_t) string[point];\n+\t  memset(&ps, 0, sizeof(mbstate_t));\n+\t}\n+      else\n+\ttmp = mbrtowc (&wc, string+point, len, &ps);\n       if (MB_INVALIDCH ((size_t)tmp))\n \t{\n \t  /* invalid bytes. assume a byte represents a character */\n@@ -146,9 +207,7 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n }\n \n /*static*/ int\n-_rl_find_prev_mbchar_internal (string, seed, find_non_zero)\n-     char *string;\n-     int seed, find_non_zero;\n+_rl_find_prev_mbchar_internal (char *string, int seed, int find_non_zero)\n {\n   mbstate_t ps;\n   int prev, non_zero_prev, point, length;\n@@ -166,10 +225,17 @@ _rl_find_prev_mbchar_internal (string, seed, find_non_zero)\n   prev = non_zero_prev = point = 0;\n   while (point < seed)\n     {\n-      tmp = mbrtowc (&wc, string + point, length - point, &ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[point]))\n+\t{\n+\t  tmp = 1;\n+\t  wc = (wchar_t) string[point];\n+\t  memset(&ps, 0, sizeof(mbstate_t));\n+\t}\n+      else\n+\ttmp = mbrtowc (&wc, string + point, length - point, &ps);\n       if (MB_INVALIDCH ((size_t)tmp))\n \t{\n-\t  /* in this case, bytes are invalid or shorted to compose\n+\t  /* in this case, bytes are invalid or too short to compose\n \t     multibyte char, so assume that the first byte represents\n \t     a single character anyway. */\n \t  tmp = 1;\n@@ -206,16 +272,23 @@ _rl_find_prev_mbchar_internal (string, seed, find_non_zero)\n    if an invalid multibyte sequence was encountered. It returns (size_t)(-2) \n    if it couldn't parse a complete  multibyte character.  */\n int\n-_rl_get_char_len (src, ps)\n-     char *src;\n-     mbstate_t *ps;\n+_rl_get_char_len (char *src, mbstate_t *ps)\n {\n-  size_t tmp;\n+  size_t tmp, l;\n+  int mb_cur_max;\n \n-  tmp = mbrlen((const char *)src, (size_t)strlen (src), ps);\n+  /* Look at no more than MB_CUR_MAX characters */\n+  l = (size_t)strlen (src);\n+  if (_rl_utf8locale && l > 0 && UTF8_SINGLEBYTE(*src))\n+    tmp = (*src != 0) ? 1 : 0;\n+  else\n+    {\n+      mb_cur_max = MB_CUR_MAX;\n+      tmp = mbrlen((const char *)src, (l < mb_cur_max) ? l : mb_cur_max, ps);\n+    }\n   if (tmp == (size_t)(-2))\n     {\n-      /* shorted to compose multibyte char */\n+      /* too short to compose multibyte char */\n       if (ps)\n \tmemset (ps, 0, sizeof(mbstate_t));\n       return -2;\n@@ -237,13 +310,7 @@ _rl_get_char_len (src, ps)\n /* compare the specified two characters. If the characters matched,\n    return 1. Otherwise return 0. */\n int\n-_rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)\n-     char *buf1;\n-     int pos1;\n-     mbstate_t *ps1;\n-     char *buf2;\n-     int pos2;\n-     mbstate_t *ps2;\n+_rl_compare_chars (char *buf1, int pos1, mbstate_t *ps1, char *buf2, int pos2, mbstate_t *ps2)\n {\n   int i, w1, w2;\n \n@@ -263,18 +330,16 @@ _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)\n /* adjust pointed byte and find mbstate of the point of string.\n    adjusted point will be point <= adjusted_point, and returns\n    differences of the byte(adjusted_point - point).\n-   if point is invalied (point < 0 || more than string length),\n+   if point is invalid (point < 0 || more than string length),\n    it returns -1 */\n int\n-_rl_adjust_point (string, point, ps)\n-     char *string;\n-     int point;\n-     mbstate_t *ps;\n+_rl_adjust_point (char *string, int point, mbstate_t *ps)\n {\n-  size_t tmp = 0;\n-  int length;\n-  int pos = 0;\n+  size_t tmp;\n+  int length, pos;\n \n+  tmp = 0;\n+  pos = 0;\n   length = strlen(string);\n   if (point < 0)\n     return -1;\n@@ -283,10 +348,13 @@ _rl_adjust_point (string, point, ps)\n   \n   while (pos < point)\n     {\n-      tmp = mbrlen (string + pos, length - pos, ps);\n+      if (_rl_utf8locale && UTF8_SINGLEBYTE(string[pos]))\n+\ttmp = 1;\n+      else\n+\ttmp = mbrlen (string + pos, length - pos, ps);\n       if (MB_INVALIDCH ((size_t)tmp))\n \t{\n-\t  /* in this case, bytes are invalid or shorted to compose\n+\t  /* in this case, bytes are invalid or too short to compose\n \t     multibyte char, so assume that the first byte represents\n \t     a single character anyway. */\n \t  pos++;\n@@ -305,11 +373,7 @@ _rl_adjust_point (string, point, ps)\n }\n \n int\n-_rl_is_mbchar_matched (string, seed, end, mbchar, length)\n-     char *string;\n-     int seed, end;\n-     char *mbchar;\n-     int length;\n+_rl_is_mbchar_matched (char *string, int seed, int end, char *mbchar, int length)\n {\n   int i;\n \n@@ -323,9 +387,7 @@ _rl_is_mbchar_matched (string, seed, end, mbchar, length)\n }\n \n wchar_t\n-_rl_char_value (buf, ind)\n-     char *buf;\n-     int ind;\n+_rl_char_value (char *buf, int ind)\n {\n   size_t tmp;\n   wchar_t wc;\n@@ -334,9 +396,13 @@ _rl_char_value (buf, ind)\n \n   if (MB_LEN_MAX == 1 || rl_byte_oriented)\n     return ((wchar_t) buf[ind]);\n+  if (_rl_utf8locale && UTF8_SINGLEBYTE(buf[ind]))\n+    return ((wchar_t) buf[ind]);\n   l = strlen (buf);\n   if (ind >= l - 1)\n     return ((wchar_t) buf[ind]);\n+  if (l < ind)\t\t\t/* Sanity check */\n+    l = strlen (buf+ind);\n   memset (&ps, 0, sizeof (mbstate_t));\n   tmp = mbrtowc (&wc, buf + ind, l - ind, &ps);\n   if (MB_INVALIDCH (tmp) || MB_NULLWCH (tmp))  \n@@ -350,9 +416,7 @@ _rl_char_value (buf, ind)\n    characters. */\n #undef _rl_find_next_mbchar\n int\n-_rl_find_next_mbchar (string, seed, count, flags)\n-     char *string;\n-     int seed, count, flags;\n+_rl_find_next_mbchar (char *string, int seed, int count, int flags)\n {\n #if defined (HANDLE_MULTIBYTE)\n   return _rl_find_next_mbchar_internal (string, seed, count, flags);\n@@ -366,9 +430,7 @@ _rl_find_next_mbchar (string, seed, count, flags)\n    we look for non-zero-width multibyte characters. */\n #undef _rl_find_prev_mbchar\n int\n-_rl_find_prev_mbchar (string, seed, flags)\n-     char *string;\n-     int seed, flags;\n+_rl_find_prev_mbchar (char *string, int seed, int flags)\n {\n #if defined (HANDLE_MULTIBYTE)\n   return _rl_find_prev_mbchar_internal (string, seed, flags);"
    },
    {
      "sha": "64b1457d29e8af0bcefc6553ca97e93cf0cd6ad0",
      "filename": "readline/misc.c",
      "status": "modified",
      "additions": 36,
      "deletions": 47,
      "changes": 83,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/misc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/misc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/misc.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* misc.c -- miscellaneous bindable readline functions. */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -76,7 +76,7 @@ int _rl_history_saved_point = -1;\n /* **************************************************************** */\n \n int\n-_rl_arg_overflow ()\n+_rl_arg_overflow (void)\n {\n   if (rl_numeric_arg > 1000000)\n     {\n@@ -92,15 +92,15 @@ _rl_arg_overflow ()\n }\n \n void\n-_rl_arg_init ()\n+_rl_arg_init (void)\n {\n   rl_save_prompt ();\n   _rl_argcxt = 0;\n   RL_SETSTATE(RL_STATE_NUMERICARG);\n }\n \n int\n-_rl_arg_getchar ()\n+_rl_arg_getchar (void)\n {\n   int c;\n \n@@ -116,9 +116,7 @@ _rl_arg_getchar ()\n    argument should be aborted, 0 if we should not read any more chars, and\n    1 if we should continue to read chars. */\n int\n-_rl_arg_dispatch (cxt, c)\n-     _rl_arg_cxt cxt;\n-     int c;\n+_rl_arg_dispatch (_rl_arg_cxt cxt, int c)\n {\n   int key, r;\n \n@@ -193,7 +191,7 @@ _rl_arg_dispatch (cxt, c)\n \n /* Handle C-u style numeric args, as well as M--, and M-digits. */\n static int\n-rl_digit_loop ()\n+rl_digit_loop (void)\n {\n   int c, r;\n \n@@ -220,7 +218,7 @@ rl_digit_loop ()\n \n /* Create a default argument. */\n void\n-_rl_reset_argument ()\n+_rl_reset_argument (void)\n {\n   rl_numeric_arg = rl_arg_sign = 1;\n   rl_explicit_arg = 0;\n@@ -229,8 +227,7 @@ _rl_reset_argument ()\n \n /* Start a numeric argument with initial value KEY */\n int\n-rl_digit_argument (ignore, key)\n-     int ignore, key;\n+rl_digit_argument (int ignore, int key)\n {\n   _rl_arg_init ();\n   if (RL_ISSTATE (RL_STATE_CALLBACK))\n@@ -250,8 +247,7 @@ rl_digit_argument (ignore, key)\n    Read a key.  If the key has nothing to do with arguments, then\n    dispatch on it.  If the key is the abort character then abort. */\n int\n-rl_universal_argument (count, key)\n-     int count, key;\n+rl_universal_argument (int count, int key)\n {\n   _rl_arg_init ();\n   rl_numeric_arg *= 4;\n@@ -260,8 +256,7 @@ rl_universal_argument (count, key)\n }\n \n int\n-_rl_arg_callback (cxt)\n-     _rl_arg_cxt cxt;\n+_rl_arg_callback (_rl_arg_cxt cxt)\n {\n   int c, r;\n \n@@ -280,12 +275,14 @@ _rl_arg_callback (cxt)\n     }\n \n   r = _rl_arg_dispatch (cxt, c);\n+  if (r > 0)\n+    rl_message (\"(arg: %d) \", rl_arg_sign * rl_numeric_arg);\n   return (r != 1);\n }\n \n /* What to do when you abort reading an argument. */\n int\n-rl_discard_argument ()\n+rl_discard_argument (void)\n {\n   rl_ding ();\n   rl_clear_message ();\n@@ -310,7 +307,7 @@ HIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;\n \n /* Set the history pointer back to the last entry in the history. */\n void\n-_rl_start_using_history ()\n+_rl_start_using_history (void)\n {\n   using_history ();\n   if (_rl_saved_line_for_history)\n@@ -321,8 +318,7 @@ _rl_start_using_history ()\n \n /* Free the contents (and containing structure) of a HIST_ENTRY. */\n void\n-_rl_free_history_entry (entry)\n-     HIST_ENTRY *entry;\n+_rl_free_history_entry (HIST_ENTRY *entry)\n {\n   if (entry == 0)\n     return;\n@@ -335,7 +331,7 @@ _rl_free_history_entry (entry)\n \n /* Perhaps put back the current line if it has changed. */\n int\n-rl_maybe_replace_line ()\n+rl_maybe_replace_line (void)\n {\n   HIST_ENTRY *temp;\n \n@@ -353,7 +349,7 @@ rl_maybe_replace_line ()\n \n /* Restore the _rl_saved_line_for_history if there is one. */\n int\n-rl_maybe_unsave_line ()\n+rl_maybe_unsave_line (void)\n {\n   if (_rl_saved_line_for_history)\n     {\n@@ -372,7 +368,7 @@ rl_maybe_unsave_line ()\n \n /* Save the current line in _rl_saved_line_for_history. */\n int\n-rl_maybe_save_line ()\n+rl_maybe_save_line (void)\n {\n   if (_rl_saved_line_for_history == 0)\n     {\n@@ -386,7 +382,7 @@ rl_maybe_save_line ()\n }\n \n int\n-_rl_free_saved_history_line ()\n+_rl_free_saved_history_line (void)\n {\n   if (_rl_saved_line_for_history)\n     {\n@@ -397,7 +393,7 @@ _rl_free_saved_history_line ()\n }\n \n static void\n-_rl_history_set_point ()\n+_rl_history_set_point (void)\n {\n   rl_point = (_rl_history_preserve_point && _rl_history_saved_point != -1)\n \t\t? _rl_history_saved_point\n@@ -415,9 +411,7 @@ _rl_history_set_point ()\n }\n \n void\n-rl_replace_from_history (entry, flags)\n-     HIST_ENTRY *entry;\n-     int flags;\t\t\t/* currently unused */\n+rl_replace_from_history (HIST_ENTRY *entry, int flags)\n {\n   /* Can't call with `1' because rl_undo_list might point to an undo list\n      from a history entry, just like we're setting up here. */\n@@ -441,7 +435,7 @@ rl_replace_from_history (entry, flags)\n    intended to be called while actively editing, and the current line is\n    not assumed to have been added to the history list. */\n void\n-_rl_revert_all_lines ()\n+_rl_revert_all_lines (void)\n {\n   int hpos;\n   HIST_ENTRY *entry;\n@@ -490,7 +484,7 @@ _rl_revert_all_lines ()\n    to an UNDO_LIST * saved as some history entry's data member.  This\n    should not be called while editing is active. */\n void\n-rl_clear_history ()\n+rl_clear_history (void)\n {\n   HIST_ENTRY **hlist, *hent;\n   register int i;\n@@ -524,16 +518,14 @@ rl_clear_history ()\n \n /* Meta-< goes to the start of the history. */\n int\n-rl_beginning_of_history (count, key)\n-     int count, key;\n+rl_beginning_of_history (int count, int key)\n {\n   return (rl_get_previous_history (1 + where_history (), key));\n }\n \n /* Meta-> goes to the end of the history.  (The current line). */\n int\n-rl_end_of_history (count, key)\n-     int count, key;\n+rl_end_of_history (int count, int key)\n {\n   rl_maybe_replace_line ();\n   using_history ();\n@@ -543,8 +535,7 @@ rl_end_of_history (count, key)\n \n /* Move down to the next history line. */\n int\n-rl_get_next_history (count, key)\n-     int count, key;\n+rl_get_next_history (int count, int key)\n {\n   HIST_ENTRY *temp;\n \n@@ -582,15 +573,14 @@ rl_get_next_history (count, key)\n /* Get the previous item out of our interactive history, making it the current\n    line.  If there is no previous history, just ding. */\n int\n-rl_get_previous_history (count, key)\n-     int count, key;\n+rl_get_previous_history (int count, int key)\n {\n   HIST_ENTRY *old_temp, *temp;\n \n   if (count < 0)\n     return (rl_get_next_history (-count, key));\n \n-  if (count == 0)\n+  if (count == 0 || history_list () == 0)\n     return 0;\n \n   /* either not saved by rl_newline or at end of line, so set appropriately. */\n@@ -620,7 +610,10 @@ rl_get_previous_history (count, key)\n     temp = old_temp;\n \n   if (temp == 0)\n-    rl_ding ();\n+    {\n+      rl_maybe_unsave_line ();\n+      rl_ding ();\n+    }\n   else\n     {\n       rl_replace_from_history (temp, 0);\n@@ -637,8 +630,7 @@ rl_get_previous_history (count, key)\n /* **************************************************************** */\n /* How to toggle back and forth between editing modes. */\n int\n-rl_vi_editing_mode (count, key)\n-     int count, key;\n+rl_vi_editing_mode (int count, int key)\n {\n #if defined (VI_MODE)\n   _rl_set_insert_mode (RL_IM_INSERT, 1);\t/* vi mode ignores insert mode */\n@@ -650,8 +642,7 @@ rl_vi_editing_mode (count, key)\n }\n \n int\n-rl_emacs_editing_mode (count, key)\n-     int count, key;\n+rl_emacs_editing_mode (int count, int key)\n {\n   rl_editing_mode = emacs_mode;\n   _rl_set_insert_mode (RL_IM_INSERT, 1); /* emacs mode default is insert mode */\n@@ -665,8 +656,7 @@ rl_emacs_editing_mode (count, key)\n \n /* Function for the rest of the library to use to set insert/overwrite mode. */\n void\n-_rl_set_insert_mode (im, force)\n-     int im, force;\n+_rl_set_insert_mode (int im, int force)\n {\n #ifdef CURSOR_MODE\n   _rl_set_cursor (im, force);\n@@ -678,8 +668,7 @@ _rl_set_insert_mode (im, force)\n /* Toggle overwrite mode.  A positive explicit argument selects overwrite\n    mode.  A negative or zero explicit argument selects insert mode. */\n int\n-rl_overwrite_mode (count, key)\n-     int count, key;\n+rl_overwrite_mode (int count, int key)\n {\n   if (rl_explicit_arg == 0)\n     _rl_set_insert_mode (rl_insert_mode ^ 1, 0);"
    },
    {
      "sha": "d2f67e0d3e1ac1a9f085d3e10fbc7af0c129d8e0",
      "filename": "readline/nls.c",
      "status": "modified",
      "additions": 32,
      "deletions": 23,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/nls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/nls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/nls.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* nls.c -- skeletal internationalization code. */\n \n-/* Copyright (C) 1996-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1996-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -74,6 +74,7 @@ static char *legal_lang_values[] =\n  \"iso88599\",\n  \"iso885910\",\n  \"koi8r\",\n+ \"utf8\",\n   0\n };\n \n@@ -85,8 +86,7 @@ static char *find_codeset PARAMS((char *, size_t *));\n static char *_rl_get_locale_var PARAMS((const char *));\n \n static char *\n-_rl_get_locale_var (v)\n-     const char *v;\n+_rl_get_locale_var (const char *v)\n {\n   char *lspec;\n \n@@ -100,8 +100,7 @@ _rl_get_locale_var (v)\n }\n \n static int\n-utf8locale (lspec)\n-     char *lspec;\n+utf8locale (char *lspec)\n {\n   char *cp;\n   size_t len;\n@@ -118,16 +117,12 @@ utf8locale (lspec)\n #endif\n }\n \n-/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value\n-   to decide the defaults for 8-bit character input and output.  Returns\n-   1 if we set eight-bit mode. */\n-int\n-_rl_init_eightbit ()\n+/* Query the right environment variables and call setlocale() to initialize\n+   the C library locale settings. */\n+char *\n+_rl_init_locale (void)\n {\n-/* If we have setlocale(3), just check the current LC_CTYPE category\n-   value, and go into eight-bit mode if it's not C or POSIX. */\n-#if defined (HAVE_SETLOCALE)\n-  char *lspec, *t;\n+  char *ret, *lspec;\n \n   /* Set the LC_CTYPE locale category from environment variables. */\n   lspec = _rl_get_locale_var (\"LC_CTYPE\");\n@@ -140,10 +135,25 @@ _rl_init_eightbit ()\n     lspec = setlocale (LC_CTYPE, (char *)NULL);\n   if (lspec == 0)\n     lspec = \"\";\n-  t = setlocale (LC_CTYPE, lspec);\n+  ret = setlocale (LC_CTYPE, lspec);\t/* ok, since it does not change locale */\n+\n+  _rl_utf8locale = (ret && *ret) ? utf8locale (ret) : 0;\n+\n+  return ret;\n+}\n+\n+/* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value\n+   to decide the defaults for 8-bit character input and output.  Returns\n+   1 if we set eight-bit mode. */\n+int\n+_rl_init_eightbit (void)\n+{\n+/* If we have setlocale(3), just check the current LC_CTYPE category\n+   value, and go into eight-bit mode if it's not C or POSIX. */\n+#if defined (HAVE_SETLOCALE)\n+  char *lspec, *t;\n \n-  if (t && *t)\n-    _rl_utf8locale = utf8locale (t);\n+  t = _rl_init_locale ();\t/* returns static pointer */\n \n   if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, \"POSIX\") == 0))\n     {\n@@ -174,16 +184,17 @@ _rl_init_eightbit ()\n \t_rl_output_meta_chars = 1;\n \tbreak;\n       }\n+\n+  _rl_utf8locale = *t ? STREQ (t, \"utf8\") : 0;\n+\n   xfree (t);\n   return (legal_lang_values[i] ? 1 : 0);\n-\n #endif /* !HAVE_SETLOCALE */\n }\n \n #if !defined (HAVE_SETLOCALE)\n static char *\n-normalize_codeset (codeset)\n-     char *codeset;\n+normalize_codeset (char *codeset)\n {\n   size_t namelen, i;\n   int len, all_digits;\n@@ -230,9 +241,7 @@ normalize_codeset (codeset)\n \n /* Isolate codeset portion of locale specification. */\n static char *\n-find_codeset (name, lenp)\n-     char *name;\n-     size_t *lenp;\n+find_codeset (char *name, size_t *lenp)\n {\n   char *cp, *language, *result;\n "
    },
    {
      "sha": "af4797736293d4cefa2d9c57784a1c83a03b434c",
      "filename": "readline/parens.c",
      "status": "modified",
      "additions": 5,
      "deletions": 10,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/parens.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/parens.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/parens.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* parens.c -- implementation of matching parentheses feature. */\n \n-/* Copyright (C) 1987, 1989, 1992-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987, 1989, 1992-2015, 2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -64,8 +64,7 @@ static int _paren_blink_usec = 500000;\n /* Change emacs_standard_keymap to have bindings for paren matching when\n    ON_OR_OFF is 1, change them back to self_insert when ON_OR_OFF == 0. */\n void\n-_rl_enable_paren_matching (on_or_off)\n-     int on_or_off;\n+_rl_enable_paren_matching (int on_or_off)\n {\n   if (on_or_off)\n     {\n@@ -98,8 +97,7 @@ _rl_enable_paren_matching (on_or_off)\n }\n \n int\n-rl_set_paren_blink_timeout (u)\n-     int u;\n+rl_set_paren_blink_timeout (int u)\n {\n   int o;\n \n@@ -110,8 +108,7 @@ rl_set_paren_blink_timeout (u)\n }\n \n int\n-rl_insert_close (count, invoking_key)\n-     int count, invoking_key;\n+rl_insert_close (int count, int invoking_key)\n {\n   if (rl_explicit_arg || !rl_blink_matching_paren)\n     _rl_insert_char (count, invoking_key);\n@@ -148,9 +145,7 @@ rl_insert_close (count, invoking_key)\n }\n \n static int\n-find_matching_open (string, from, closer)\n-     char *string;\n-     int from, closer;\n+find_matching_open (char *string, int from, int closer)\n {\n   register int i;\n   int opener, level, delimiter;"
    },
    {
      "sha": "05ec9bc36a40def55f2984ec6014b65117d9a74b",
      "filename": "readline/parse-colors.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/parse-colors.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/parse-colors.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/parse-colors.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -2,8 +2,8 @@\n \n    Modified by Chet Ramey for Readline.\n \n-   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2017\n+   Free Software Foundation, Inc.\n \n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -297,7 +297,7 @@ get_funky_string (char **dest, const char **src, bool equals_end, size_t *output\n }\n #endif /* COLOR_SUPPORT */\n \n-void _rl_parse_colors()\n+void _rl_parse_colors(void)\n {\n #if defined (COLOR_SUPPORT)\n   const char *p;\t\t/* Pointer to character being parsed */"
    },
    {
      "sha": "d8c9df7e6bb19b63a7c7f1c4f192a91529e40699",
      "filename": "readline/patchlevel",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/patchlevel",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/patchlevel",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/patchlevel?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,3 +1,3 @@\n # Do not edit -- exists only for use by patch\n \n-5\n+0"
    },
    {
      "sha": "678f989c51aba1d522b366e67ed93968ced01cc1",
      "filename": "readline/readline.c",
      "status": "modified",
      "additions": 63,
      "deletions": 56,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n /* readline.c -- a general facility for reading lines of input\n    with emacs style editing and completion. */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -214,6 +214,9 @@ int _rl_eof_char = CTRL ('D');\n /* Non-zero makes this the next keystroke to read. */\n int rl_pending_input = 0;\n \n+/* If non-zero when readline_internal returns, it means we found EOF */\n+int _rl_eof_found = 0;\n+\n /* Pointer to a useful terminal name. */\n const char *rl_terminal_name = (const char *)NULL;\n \n@@ -222,7 +225,7 @@ int _rl_horizontal_scroll_mode = 0;\n \n /* Non-zero means to display an asterisk at the starts of history lines\n    which have been modified. */\n-int _rl_mark_modified_lines = 0;  \n+int _rl_mark_modified_lines = 0;\n \n /* The style of `bell' notification preferred.  This can be set to NO_BELL,\n    AUDIBLE_BELL, or VISIBLE_BELL. */\n@@ -242,7 +245,7 @@ int rl_erase_empty_line = 0;\n \n /* Non-zero means to read only this many characters rather than up to a\n    character bound to accept-line. */\n-int rl_num_chars_to_read;\n+int rl_num_chars_to_read = 0;\n \n /* Line buffer and maintenance. */\n char *rl_line_buffer = (char *)NULL;\n@@ -325,8 +328,7 @@ int _rl_meta_flag = 0;\t/* Forward declaration */\n /* Set up the prompt and expand it.  Called from readline() and\n    rl_callback_handler_install (). */\n int\n-rl_set_prompt (prompt)\n-     const char *prompt;\n+rl_set_prompt (const char *prompt)\n {\n   FREE (rl_prompt);\n   rl_prompt = prompt ? savestring (prompt) : (char *)NULL;\n@@ -339,8 +341,7 @@ rl_set_prompt (prompt)\n /* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means\n    none.  A return value of NULL means that EOF was encountered. */\n char *\n-readline (prompt)\n-     const char *prompt;\n+readline (const char *prompt)\n {\n   char *value;\n #if 0\n@@ -401,7 +402,7 @@ readline (prompt)\n #endif\n \n STATIC_CALLBACK void\n-readline_internal_setup ()\n+readline_internal_setup (void)\n {\n   char *nprompt;\n \n@@ -419,7 +420,10 @@ readline_internal_setup ()\n #if defined (VI_MODE)\n   if (rl_editing_mode == vi_mode)\n     rl_vi_insertion_mode (1, 'i');\t/* don't want to reset last */\n+  else\n #endif /* VI_MODE */\n+    if (_rl_show_mode_in_prompt)\n+      _rl_reset_prompt ();\n \n   /* If we're not echoing, we still want to at least print a prompt, because\n      rl_redisplay will not do it for us.  If the calling application has a\n@@ -450,8 +454,7 @@ readline_internal_setup ()\n }\n \n STATIC_CALLBACK char *\n-readline_internal_teardown (eof)\n-     int eof;\n+readline_internal_teardown (int eof)\n {\n   char *temp;\n   HIST_ENTRY *entry;\n@@ -493,7 +496,7 @@ readline_internal_teardown (eof)\n }\n \n void\n-_rl_internal_char_cleanup ()\n+_rl_internal_char_cleanup (void)\n {\n #if defined (VI_MODE)\n   /* In vi mode, when you exit insert mode, the cursor moves back\n@@ -524,13 +527,13 @@ _rl_internal_char_cleanup ()\n \n STATIC_CALLBACK int\n #if defined (READLINE_CALLBACKS)\n-readline_internal_char ()\n+readline_internal_char (void)\n #else\n-readline_internal_charloop ()\n+readline_internal_charloop (void)\n #endif\n {\n   static int lastc, eof_found;\n-  int c, code, lk;\n+  int c, code, lk, r;\n \n   lastc = EOF;\n \n@@ -626,7 +629,7 @@ readline_internal_charloop ()\n \t}\n \n       lastc = c;\n-      _rl_dispatch ((unsigned char)c, _rl_keymap);\n+      r = _rl_dispatch ((unsigned char)c, _rl_keymap);\n       RL_CHECK_SIGNALS ();\n \n       /* If there was no change in _rl_last_command_was_kill, then no kill\n@@ -648,7 +651,7 @@ readline_internal_charloop ()\n \n #if defined (READLINE_CALLBACKS)\n static int\n-readline_internal_charloop ()\n+readline_internal_charloop (void)\n {\n   int eof = 1;\n \n@@ -662,32 +665,30 @@ readline_internal_charloop ()\n    the global rl_outstream.\n    If rl_prompt is non-null, then that is our prompt. */\n static char *\n-readline_internal ()\n+readline_internal (void)\n {\n-  int eof;\n-\n   readline_internal_setup ();\n-  eof = readline_internal_charloop ();\n-  return (readline_internal_teardown (eof));\n+  _rl_eof_found = readline_internal_charloop ();\n+  return (readline_internal_teardown (_rl_eof_found));\n }\n \n void\n-_rl_init_line_state ()\n+_rl_init_line_state (void)\n {\n   rl_point = rl_end = rl_mark = 0;\n   the_line = rl_line_buffer;\n   the_line[0] = 0;\n }\n \n void\n-_rl_set_the_line ()\n+_rl_set_the_line (void)\n {\n   the_line = rl_line_buffer;\n }\n \n #if defined (READLINE_CALLBACKS)\n _rl_keyseq_cxt *\n-_rl_keyseq_cxt_alloc ()\n+_rl_keyseq_cxt_alloc (void)\n {\n   _rl_keyseq_cxt *cxt;\n \n@@ -703,14 +704,13 @@ _rl_keyseq_cxt_alloc ()\n }\n \n void\n-_rl_keyseq_cxt_dispose (cxt)\n-    _rl_keyseq_cxt *cxt;\n+_rl_keyseq_cxt_dispose (_rl_keyseq_cxt *cxt)\n {\n   xfree (cxt);\n }\n \n void\n-_rl_keyseq_chain_dispose ()\n+_rl_keyseq_chain_dispose (void)\n {\n   _rl_keyseq_cxt *cxt;\n \n@@ -724,8 +724,7 @@ _rl_keyseq_chain_dispose ()\n #endif\n \n static int\n-_rl_subseq_getchar (key)\n-     int key;\n+_rl_subseq_getchar (int key)\n {\n   int k;\n \n@@ -742,8 +741,7 @@ _rl_subseq_getchar (key)\n \n #if defined (READLINE_CALLBACKS)\n int\n-_rl_dispatch_callback (cxt)\n-     _rl_keyseq_cxt *cxt;\n+_rl_dispatch_callback (_rl_keyseq_cxt *cxt)\n {\n   int nkey, r;\n \n@@ -794,19 +792,14 @@ _rl_dispatch_callback (cxt)\n    If the associated command is really a keymap, then read\n    another key, and dispatch into that map. */\n int\n-_rl_dispatch (key, map)\n-     register int key;\n-     Keymap map;\n+_rl_dispatch (register int key, Keymap map)\n {\n   _rl_dispatching_keymap = map;\n   return _rl_dispatch_subseq (key, map, 0);\n }\n \n int\n-_rl_dispatch_subseq (key, map, got_subseq)\n-     register int key;\n-     Keymap map;\n-     int got_subseq;\n+_rl_dispatch_subseq (register int key, Keymap map, int got_subseq)\n {\n   int r, newkey;\n   char *macro;\n@@ -920,6 +913,15 @@ _rl_dispatch_subseq (key, map, got_subseq)\n               _rl_pushed_input_available () == 0 &&\n \t      _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)\n \t    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));\n+\t  /* This is a very specific test.  It can possibly be generalized in\n+\t     the future, but for now it handles a specific case of ESC being\n+\t     the last character in a keyboard macro. */\n+\t  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap &&\n+\t      (RL_ISSTATE (RL_STATE_INPUTPENDING) == 0) &&\n+\t      (RL_ISSTATE (RL_STATE_MACROINPUT) && _rl_peek_macro_key () == 0) &&\n+\t      _rl_pushed_input_available () == 0 &&\n+\t      _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)\n+\t    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));\t      \n #endif\n \n \t  RESIZE_KEYSEQ_BUFFER ();\n@@ -1014,10 +1016,7 @@ _rl_dispatch_subseq (key, map, got_subseq)\n }\n \n static int\n-_rl_subseq_result (r, map, key, got_subseq)\n-     int r;\n-     Keymap map;\n-     int key, got_subseq;\n+_rl_subseq_result (int r, Keymap map, int key, int got_subseq)\n {\n   Keymap m;\n   int type, nt;\n@@ -1091,18 +1090,20 @@ _rl_subseq_result (r, map, key, got_subseq)\n \n /* Initialize readline (and terminal if not already). */\n int\n-rl_initialize ()\n+rl_initialize (void)\n {\n   /* If we have never been called before, initialize the\n      terminal and data structures. */\n-  if (!rl_initialized)\n+  if (rl_initialized == 0)\n     {\n       RL_SETSTATE(RL_STATE_INITIALIZING);\n       readline_initialize_everything ();\n       RL_UNSETSTATE(RL_STATE_INITIALIZING);\n       rl_initialized++;\n       RL_SETSTATE(RL_STATE_INITIALIZED);\n     }\n+  else\n+    (void)_rl_init_locale ();\t/* check current locale */\n \n   /* Initialize the current line information. */\n   _rl_init_line_state ();\n@@ -1137,7 +1138,7 @@ rl_initialize ()\n #if 0\n #if defined (__EMX__)\n static void\n-_emx_build_environ ()\n+_emx_build_environ (void)\n {\n   TIB *tibp;\n   PIB *pibp;\n@@ -1162,7 +1163,7 @@ _emx_build_environ ()\n \n /* Initialize the entire state of the world. */\n static void\n-readline_initialize_everything ()\n+readline_initialize_everything (void)\n {\n #if 0\n #if defined (__EMX__)\n@@ -1247,7 +1248,7 @@ readline_initialize_everything ()\n    input editing characters, then bind them to their readline\n    equivalents, iff the characters are not bound to keymaps. */\n static void\n-readline_default_bindings ()\n+readline_default_bindings (void)\n {\n   if (_rl_bind_stty_chars)\n     rl_tty_set_default_bindings (_rl_keymap);\n@@ -1256,7 +1257,7 @@ readline_default_bindings ()\n /* Reset the default bindings for the terminal special characters we're\n    interested in back to rl_insert and read the new ones. */\n static void\n-reset_default_bindings ()\n+reset_default_bindings (void)\n {\n   if (_rl_bind_stty_chars)\n     {\n@@ -1267,8 +1268,7 @@ reset_default_bindings ()\n \n /* Bind some common arrow key sequences in MAP. */\n static void\n-bind_arrow_keys_internal (map)\n-     Keymap map;\n+bind_arrow_keys_internal (Keymap map)\n {\n   Keymap xkeymap;\n \n@@ -1296,6 +1296,15 @@ bind_arrow_keys_internal (map)\n   rl_bind_keyseq_if_unbound (\"\\033OH\", rl_beg_of_line);\n   rl_bind_keyseq_if_unbound (\"\\033OF\", rl_end_of_line);\n \n+  /* Key bindings for control-arrow keys */\n+  rl_bind_keyseq_if_unbound (\"\\033[1;5C\", rl_forward_word);\n+  rl_bind_keyseq_if_unbound (\"\\033[1;5D\", rl_backward_word);\n+  rl_bind_keyseq_if_unbound (\"\\033[3;5~\", rl_kill_word);\n+\n+  /* Key bindings for alt-arrow keys */\n+  rl_bind_keyseq_if_unbound (\"\\033[1;3C\", rl_forward_word);\n+  rl_bind_keyseq_if_unbound (\"\\033[1;3D\", rl_backward_word);\n+\n #if defined (__MINGW32__)\n   rl_bind_keyseq_if_unbound (\"\\340H\", rl_get_previous_history);\n   rl_bind_keyseq_if_unbound (\"\\340P\", rl_get_next_history);\n@@ -1324,7 +1333,7 @@ bind_arrow_keys_internal (map)\n    the inputrc file a chance to bind them and create `real' keymaps\n    for the arrow key prefix. */\n static void\n-bind_arrow_keys ()\n+bind_arrow_keys (void)\n {\n   bind_arrow_keys_internal (emacs_standard_keymap);\n \n@@ -1339,7 +1348,7 @@ bind_arrow_keys ()\n }\n \n static void\n-bind_bracketed_paste_prefix ()\n+bind_bracketed_paste_prefix (void)\n {\n   Keymap xkeymap;\n \n@@ -1361,8 +1370,7 @@ bind_bracketed_paste_prefix ()\n /* **************************************************************** */\n \n int\n-rl_save_state (sp)\n-     struct readline_state *sp;\n+rl_save_state (struct readline_state *sp)\n {\n   if (sp == 0)\n     return -1;\n@@ -1402,8 +1410,7 @@ rl_save_state (sp)\n }\n \n int\n-rl_restore_state (sp)\n-     struct readline_state *sp;\n+rl_restore_state (struct readline_state *sp)\n {\n   if (sp == 0)\n     return -1;"
    },
    {
      "sha": "da782716af2a52edf38c2e6252bddc54d2f7eb6e",
      "filename": "readline/readline.h",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -39,8 +39,8 @@ extern \"C\" {\n #endif\n \n /* Hex-encoded Readline version number. */\n-#define RL_READLINE_VERSION\t0x0700\t\t/* Readline 7.0 */\n-#define RL_VERSION_MAJOR\t7\n+#define RL_READLINE_VERSION\t0x0800\t\t/* Readline 8.0 */\n+#define RL_VERSION_MAJOR\t8\n #define RL_VERSION_MINOR\t0\n \n /* Readline data structures. */\n@@ -98,6 +98,9 @@ extern int rl_clear_screen PARAMS((int, int));\n extern int rl_skip_csi_sequence PARAMS((int, int));\n extern int rl_arrow_keys PARAMS((int, int));\n \n+extern int rl_previous_screen_line PARAMS((int, int));\n+extern int rl_next_screen_line PARAMS((int, int));\n+\n /* Bindable commands for inserting and deleting text. */\n extern int rl_insert PARAMS((int, int));\n extern int rl_quoted_insert PARAMS((int, int));\n@@ -329,6 +332,7 @@ extern char *rl_untranslate_keyseq PARAMS((int));\n \n extern rl_command_func_t *rl_named_function PARAMS((const char *));\n extern rl_command_func_t *rl_function_of_keyseq PARAMS((const char *, Keymap, int *));\n+extern rl_command_func_t *rl_function_of_keyseq_len PARAMS((const char *, size_t, Keymap, int *));\n \n extern void rl_list_funmap_names PARAMS((void));\n extern char **rl_invoking_keyseqs_in_map PARAMS((rl_command_func_t *, Keymap));\n@@ -343,6 +347,7 @@ extern int rl_parse_and_bind PARAMS((char *));\n \n /* Functions for manipulating keymaps. */\n extern Keymap rl_make_bare_keymap PARAMS((void));\n+extern int rl_empty_keymap PARAMS((Keymap));\n extern Keymap rl_copy_keymap PARAMS((Keymap));\n extern Keymap rl_make_keymap PARAMS((void));\n extern void rl_discard_keymap PARAMS((Keymap));\n@@ -352,6 +357,9 @@ extern Keymap rl_get_keymap_by_name PARAMS((const char *));\n extern char *rl_get_keymap_name PARAMS((Keymap));\n extern void rl_set_keymap PARAMS((Keymap));\n extern Keymap rl_get_keymap PARAMS((void));\n+\n+extern int rl_set_keymap_name PARAMS((const char *, Keymap));\n+\n /* Undocumented; used internally only. */\n extern void rl_set_keymap_from_edit_mode PARAMS((void));\n extern char *rl_get_keymap_name_from_edit_mode PARAMS((void));\n@@ -413,6 +421,7 @@ extern void rl_deprep_terminal PARAMS((void));\n extern void rl_tty_set_default_bindings PARAMS((Keymap));\n extern void rl_tty_unset_default_bindings PARAMS((Keymap));\n \n+extern int rl_tty_set_echoing PARAMS((int));\n extern int rl_reset_terminal PARAMS((const char *));\n extern void rl_resize_terminal PARAMS((void));\n extern void rl_set_screen_size PARAMS((int, int));\n@@ -443,6 +452,7 @@ extern void rl_reset_after_signal PARAMS((void));\n extern void rl_free_line_state PARAMS((void));\n \n extern int rl_pending_signal PARAMS((void));\n+extern void rl_check_signals PARAMS((void));\n \n extern void rl_echo_signal_char PARAMS((int)); \n "
    },
    {
      "sha": "a7f2cf3877f615d7402f17d953e04cc28b292d44",
      "filename": "readline/readline.pc.in",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.pc.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/readline.pc.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.pc.in?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -7,6 +7,6 @@ Name: Readline\n Description: Gnu Readline library for command line editing\n URL: http://tiswww.cwru.edu/php/chet/readline/rltop.html\n Version: @LIBVERSION@\n-Requires.private: tinfo\n+Requires.private: @TERMCAP_PKG_CONFIG_LIB@\n Libs: -L${libdir} -lreadline\n Cflags: -I${includedir}/readline"
    },
    {
      "sha": "b6d6a2f12841ac5e3a6d096f6c321e56b61919ad",
      "filename": "readline/rlconf.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlconf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlconf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlconf.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -42,7 +42,7 @@\n /* The next-to-last-ditch effort file name for a user-specific init file. */\n #define DEFAULT_INPUTRC \"~/.inputrc\"\n \n-/* The ultimate last-ditch filenname for an init file -- system-wide. */\n+/* The ultimate last-ditch filename for an init file -- system-wide. */\n #define SYS_INPUTRC \"/etc/inputrc\"\n \n /* If defined, expand tabs to spaces. */"
    },
    {
      "sha": "6fd03f6a0c1e5819f47f74e25d93ddee5f14ff9e",
      "filename": "readline/rlmbutil.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlmbutil.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlmbutil.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlmbutil.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -172,6 +172,10 @@ _rl_wcwidth (wc)\n #  define IS_COMBINING_CHAR(x)\t(WCWIDTH(x) == 0)\n #endif\n \n+#define UTF8_SINGLEBYTE(c)\t(((c) & 0x80) == 0)\n+#define UTF8_MBFIRSTCHAR(c)\t(((c) & 0xc0) == 0xc0)\n+#define UTF8_MBCHAR(c)\t\t(((c) & 0xc0) == 0x80)\n+\n #else /* !HANDLE_MULTIBYTE */\n \n #undef MB_LEN_MAX\n@@ -196,6 +200,12 @@ _rl_wcwidth (wc)\n #define MB_INVALIDCH(x)\t\t(0)\n #define MB_NULLWCH(x)\t\t(0)\n \n+#define UTF8_SINGLEBYTE(c)\t(1)\n+\n+#if !defined (HAVE_WCHAR_T) && !defined (wchar_t)\n+#  define wchar_t int\n+#endif\n+\n #endif /* !HANDLE_MULTIBYTE */\n \n extern int rl_byte_oriented;"
    },
    {
      "sha": "e85e4d8124da028bd27cb8794e6c41e3089b16b1",
      "filename": "readline/rlprivate.h",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlprivate.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rlprivate.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlprivate.h?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -26,6 +26,7 @@\n #include \"rlconf.h\"\t/* for VISIBLE_STATS */\n #include \"rlstdc.h\"\n #include \"posixjmp.h\"\t/* defines procenv_t */\n+#include \"rlmbutil.h\"\t/* for HANDLE_MULTIBYTE */\n \n /*************************************************************************\n  *\t\t\t\t\t\t\t\t\t *\n@@ -64,6 +65,7 @@\n #define SF_FOUND\t\t0x02\n #define SF_FAILED\t\t0x04\n #define SF_CHGKMAP\t\t0x08\n+#define SF_PATTERN\t\t0x10\t\t/* unused so far */\n \n typedef struct  __rl_search_context\n {\n@@ -305,10 +307,13 @@ extern int _rl_search_getchar PARAMS((_rl_search_cxt *));\n #define BRACK_PASTE_SLEN\t6\n \n #define BRACK_PASTE_INIT\t\"\\033[?2004h\"\n-#define BRACK_PASTE_FINI\t\"\\033[?2004l\"\n+#define BRACK_PASTE_FINI\t\"\\033[?2004l\\r\"\n+\n+extern char *_rl_bracketed_text PARAMS((size_t *));\n \n /* macro.c */\n extern void _rl_with_macro_input PARAMS((char *));\n+extern int _rl_peek_macro_key PARAMS((void));\n extern int _rl_next_macro_key PARAMS((void));\n extern int _rl_prev_macro_key PARAMS((void));\n extern void _rl_push_executing_macro PARAMS((void));\n@@ -330,6 +335,7 @@ extern void _rl_set_insert_mode PARAMS((int, int));\n extern void _rl_revert_all_lines PARAMS((void));\n \n /* nls.c */\n+extern char *_rl_init_locale PARAMS((void));\n extern int _rl_init_eightbit PARAMS((void));\n \n /* parens.c */\n@@ -378,6 +384,7 @@ extern void _rl_set_cursor PARAMS((int, int));\n extern void _rl_fix_point PARAMS((int));\n extern int _rl_replace_text PARAMS((const char *, int, int));\n extern int _rl_forward_char_internal PARAMS((int));\n+extern int _rl_backward_char_internal PARAMS((int));\n extern int _rl_insert_char PARAMS((int, int));\n extern int _rl_overwrite_char PARAMS((int, int));\n extern int _rl_overwrite_rubout PARAMS((int, int));\n@@ -507,6 +514,7 @@ extern FILE *_rl_in_stream;\n extern FILE *_rl_out_stream;\n extern int _rl_last_command_was_kill;\n extern int _rl_eof_char;\n+extern int _rl_eof_found;\n extern procenv_t _rl_top_level;\n extern _rl_keyseq_cxt *_rl_kscxt;\n extern int _rl_keyseq_timeout;\n@@ -534,6 +542,7 @@ extern int _rl_enable_keypad;\n extern int _rl_enable_meta;\n extern char *_rl_term_clreol;\n extern char *_rl_term_clrpag;\n+extern char *_rl_term_clrscroll;\n extern char *_rl_term_im;\n extern char *_rl_term_ic;\n extern char *_rl_term_ei;"
    },
    {
      "sha": "d0cd572713a9bea108e0a8bd58fbb9e7582aa3a7",
      "filename": "readline/rltty.c",
      "status": "modified",
      "additions": 53,
      "deletions": 72,
      "changes": 125,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rltty.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/rltty.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rltty.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n /* rltty.c -- functions to prepare and restore the terminal for readline's\n    use. */\n \n-/* Copyright (C) 1992-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1992-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -130,8 +130,7 @@ static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));\n static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t *));\n \n static void\n-save_tty_chars (tiop)\n-     TIOTYPE *tiop;\n+save_tty_chars (TIOTYPE *tiop)\n {\n   _rl_last_tty_chars = _rl_tty_chars;\n \n@@ -168,9 +167,7 @@ save_tty_chars (tiop)\n }\n \n static int\n-get_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+get_tty_settings (int tty, TIOTYPE *tiop)\n {\n   set_winsize (tty);\n \n@@ -200,9 +197,7 @@ get_tty_settings (tty, tiop)\n }\n \n static int\n-set_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+set_tty_settings (int tty, TIOTYPE *tiop)\n {\n   if (tiop->flags & SGTTY_SET)\n     {\n@@ -239,9 +234,7 @@ set_tty_settings (tty, tiop)\n }\n \n static void\n-prepare_terminal_settings (meta_flag, oldtio, tiop)\n-     int meta_flag;\n-     TIOTYPE oldtio, *tiop;\n+prepare_terminal_settings (int meta_flag, TIOTYPE oldtio, TIOTYPE *tiop)\n {\n   _rl_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);\n   _rl_echoctl = (oldtio.sgttyb.sg_flags & ECHOCTL);\n@@ -357,8 +350,7 @@ static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));\n #endif\n \n static void\n-save_tty_chars (tiop)\n-     TIOTYPE *tiop;\n+save_tty_chars (TIOTYPE *tiop)\n {\n   _rl_last_tty_chars = _rl_tty_chars;\n \n@@ -403,17 +395,15 @@ save_tty_chars (tiop)\n #if defined (_AIX) || defined (_AIX41)\n /* Currently this is only used on AIX */\n static void\n-rltty_warning (msg)\n-     char *msg;\n+rltty_warning (char *msg)\n {\n   _rl_errmsg (\"warning: %s\", msg);\n }\n #endif\n \n #if defined (_AIX)\n void\n-setopost(tp)\n-TIOTYPE *tp;\n+setopost (TIOTYPE *tp)\n {\n   if ((tp->c_oflag & OPOST) == 0)\n     {\n@@ -424,9 +414,7 @@ TIOTYPE *tp;\n #endif\n \n static int\n-_get_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+_get_tty_settings (int tty, TIOTYPE *tiop)\n {\n   int ioctl_ret;\n \n@@ -457,9 +445,7 @@ _get_tty_settings (tty, tiop)\n }\n \n static int\n-get_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+get_tty_settings (int tty, TIOTYPE *tiop)\n {\n   set_winsize (tty);\n \n@@ -475,9 +461,7 @@ get_tty_settings (tty, tiop)\n }\n \n static int\n-_set_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+_set_tty_settings (int tty, TIOTYPE *tiop)\n {\n   while (SETATTR (tty, tiop) < 0)\n     {\n@@ -489,9 +473,7 @@ _set_tty_settings (tty, tiop)\n }\n \n static int\n-set_tty_settings (tty, tiop)\n-     int tty;\n-     TIOTYPE *tiop;\n+set_tty_settings (int tty, TIOTYPE *tiop)\n {\n   if (_set_tty_settings (tty, tiop) < 0)\n     return -1;\n@@ -518,10 +500,11 @@ set_tty_settings (tty, tiop)\n }\n \n static void\n-prepare_terminal_settings (meta_flag, oldtio, tiop)\n-     int meta_flag;\n-     TIOTYPE oldtio, *tiop;\n+prepare_terminal_settings (int meta_flag, TIOTYPE oldtio, TIOTYPE *tiop)\n {\n+  int sc;\n+  Keymap kmap;\n+\n   _rl_echoing_p = (oldtio.c_lflag & ECHO);\n #if defined (ECHOCTL)\n   _rl_echoctl = (oldtio.c_lflag & ECHOCTL);\n@@ -578,28 +561,40 @@ prepare_terminal_settings (meta_flag, oldtio, tiop)\n   tiop->c_cc[VDSUSP] = _POSIX_VDISABLE;\n #endif\n \n+  /* Conditionally disable some other tty special characters if there is a\n+     key binding for them in the current keymap.  Readline ordinarily doesn't\n+     bind these characters, but an application or user might. */\n+#if defined (VI_MODE)\n+      kmap = (rl_editing_mode == vi_mode) ? vi_insertion_keymap : _rl_keymap;\n+#else\n+      kmap = _rl_keymap;\n+#endif\n+#if defined (VDISCARD)\n+  sc = tiop->c_cc[VDISCARD];\n+  if (sc != _POSIX_VDISABLE && kmap[(unsigned char)sc].type == ISFUNC)\n+    tiop->c_cc[VDISCARD] = _POSIX_VDISABLE;\n+#endif /* VDISCARD */\n+\n #endif /* TERMIOS_TTY_DRIVER && _POSIX_VDISABLE */\n }\n #endif  /* !NEW_TTY_DRIVER */\n \n /* Put the terminal in CBREAK mode so that we can detect key presses. */\n #if defined (NO_TTY_DRIVER)\n void\n-rl_prep_terminal (meta_flag)\n-     int meta_flag;\n+rl_prep_terminal (int meta_flag)\n {\n   _rl_echoing_p = 1;\n }\n \n void\n-rl_deprep_terminal ()\n+rl_deprep_terminal (void)\n {\n }\n \n #else /* ! NO_TTY_DRIVER */\n void\n-rl_prep_terminal (meta_flag)\n-     int meta_flag;\n+rl_prep_terminal (int meta_flag)\n {\n   int tty, nprep;\n   TIOTYPE tio;\n@@ -682,7 +677,7 @@ rl_prep_terminal (meta_flag)\n \n /* Restore the terminal's normal settings and modes. */\n void\n-rl_deprep_terminal ()\n+rl_deprep_terminal (void)\n {\n   int tty;\n \n@@ -695,7 +690,11 @@ rl_deprep_terminal ()\n   tty = rl_instream ? fileno (rl_instream) : fileno (stdin);\n \n   if (terminal_prepped & TPX_BRACKPASTE)\n-    fprintf (rl_outstream, BRACK_PASTE_FINI);\n+    {\n+      fprintf (rl_outstream, BRACK_PASTE_FINI);\n+      if (_rl_eof_found)\n+ \tfprintf (rl_outstream, \"\\n\");\n+    }\n \n   if (_rl_enable_keypad)\n     _rl_control_keypad (0);\n@@ -718,8 +717,7 @@ rl_deprep_terminal ()\n /* Set readline's idea of whether or not it is echoing output to the terminal,\n    returning the old value. */\n int\n-rl_tty_set_echoing (u)\n-     int u;\n+rl_tty_set_echoing (int u)\n {\n   int o;\n \n@@ -735,8 +733,7 @@ rl_tty_set_echoing (u)\n /* **************************************************************** */\n \n int\n-rl_restart_output (count, key)\n-     int count, key;\n+rl_restart_output (int count, int key)\n {\n #if defined (__MINGW32__)\n   return 0;\n@@ -773,8 +770,7 @@ rl_restart_output (count, key)\n }\n \n int\n-rl_stop_output (count, key)\n-     int count, key;\n+rl_stop_output (int count, int key)\n {\n #if defined (__MINGW32__)\n   return 0;\n@@ -822,11 +818,7 @@ rl_stop_output (count, key)\n \n #elif defined (NEW_TTY_DRIVER)\n static void\n-set_special_char (kmap, tiop, sc, func)\n-     Keymap kmap;\n-     TIOTYPE *tiop;\n-     int sc;\n-     rl_command_func_t *func;\n+set_special_char (Keymap kmap, TIOTYPE *tiop, int sc, rl_command_func_t *func)\n {\n   if (sc != -1 && kmap[(unsigned char)sc].type == ISFUNC)\n     kmap[(unsigned char)sc].function = func;\n@@ -837,9 +829,7 @@ set_special_char (kmap, tiop, sc, func)\n     kmap[(unsigned char)c].function = rl_insert;\n \n static void\n-_rl_bind_tty_special_chars (kmap, ttybuff)\n-     Keymap kmap;\n-     TIOTYPE ttybuff;\n+_rl_bind_tty_special_chars (Keymap kmap, TIOTYPE ttybuff)\n {\n   if (ttybuff.flags & SGTTY_SET)\n     {\n@@ -858,11 +848,7 @@ _rl_bind_tty_special_chars (kmap, ttybuff)\n \n #else /* !NEW_TTY_DRIVER */\n static void\n-set_special_char (kmap, tiop, sc, func)\n-     Keymap kmap;\n-     TIOTYPE *tiop;\n-     int sc;\n-     rl_command_func_t *func;\n+set_special_char (Keymap kmap, TIOTYPE *tiop, int sc, rl_command_func_t *func)\n {\n   unsigned char uc;\n \n@@ -877,9 +863,7 @@ set_special_char (kmap, tiop, sc, func)\n     kmap[uc].function = rl_insert;\n \n static void\n-_rl_bind_tty_special_chars (kmap, ttybuff)\n-     Keymap kmap;\n-     TIOTYPE ttybuff;\n+_rl_bind_tty_special_chars (Keymap kmap, TIOTYPE ttybuff)\n {\n   SET_SPECIAL (VERASE, rl_rubout);\n   SET_SPECIAL (VKILL, rl_unix_line_discard);\n@@ -903,8 +887,7 @@ _rl_bind_tty_special_chars (kmap, ttybuff)\n /* Set the system's default editing characters to their readline equivalents\n    in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */\n void\n-rltty_set_default_bindings (kmap)\n-     Keymap kmap;\n+rltty_set_default_bindings (Keymap kmap)\n {\n #if !defined (NO_TTY_DRIVER)\n   TIOTYPE ttybuff;\n@@ -920,8 +903,7 @@ rltty_set_default_bindings (kmap)\n /* New public way to set the system default editing chars to their readline\n    equivalents. */\n void\n-rl_tty_set_default_bindings (kmap)\n-     Keymap kmap;\n+rl_tty_set_default_bindings (Keymap kmap)\n {\n   rltty_set_default_bindings (kmap);\n }\n@@ -931,8 +913,7 @@ rl_tty_set_default_bindings (kmap)\n    chars with save_tty_chars().  This only works on POSIX termios or termio\n    systems. */\n void\n-rl_tty_unset_default_bindings (kmap)\n-     Keymap kmap;\n+rl_tty_unset_default_bindings (Keymap kmap)\n {\n   /* Don't bother before we've saved the tty special chars at least once. */\n   if (RL_ISSTATE(RL_STATE_TTYCSAVED) == 0)\n@@ -954,13 +935,13 @@ rl_tty_unset_default_bindings (kmap)\n \n #if defined (NEW_TTY_DRIVER) || defined (NO_TTY_DRIVER)\n int\n-_rl_disable_tty_signals ()\n+_rl_disable_tty_signals (void)\n {\n   return 0;\n }\n \n int\n-_rl_restore_tty_signals ()\n+_rl_restore_tty_signals (void)\n {\n   return 0;\n }\n@@ -970,7 +951,7 @@ static TIOTYPE sigstty, nosigstty;\n static int tty_sigs_disabled = 0;\n \n int\n-_rl_disable_tty_signals ()\n+_rl_disable_tty_signals (void)\n {\n   if (tty_sigs_disabled)\n     return 0;\n@@ -991,7 +972,7 @@ _rl_disable_tty_signals ()\n }\n \n int\n-_rl_restore_tty_signals ()\n+_rl_restore_tty_signals (void)\n {\n   int r;\n "
    },
    {
      "sha": "f4bb6aa1a957832d65af73c43543ebba0ba3a157",
      "filename": "readline/savestring.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/savestring.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/savestring.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/savestring.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* savestring.c - function version of savestring for backwards compatibility */\n \n-/* Copyright (C) 1998,2003 Free Software Foundation, Inc.\n+/* Copyright (C) 1998,2003,2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -30,8 +30,7 @@\n /* Backwards compatibility, now that savestring has been removed from\n    all `public' readline header files. */\n char *\n-savestring (s)\n-     const char *s;\n+savestring (const char *s)\n {\n   char *ret;\n "
    },
    {
      "sha": "c9c1f5d1dd331cba431ec891300ba3693f6e1c14",
      "filename": "readline/search.c",
      "status": "modified",
      "additions": 87,
      "deletions": 59,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/search.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/search.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/search.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* search.c - code for non-incremental searching in emacs and vi modes. */\n \n-/* Copyright (C) 1992-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1992-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -73,8 +73,8 @@ static char *history_search_string;\n static int history_string_size;\n \n static void make_history_line_current PARAMS((HIST_ENTRY *));\n-static int noninc_search_from_pos PARAMS((char *, int, int));\n-static int noninc_dosearch PARAMS((char *, int));\n+static int noninc_search_from_pos PARAMS((char *, int, int, int, int *));\n+static int noninc_dosearch PARAMS((char *, int, int));\n static int noninc_search PARAMS((int, int));\n static int rl_history_search_internal PARAMS((int, int));\n static void rl_history_search_reinit PARAMS((int));\n@@ -87,8 +87,7 @@ static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));\n    current line.  This doesn't do anything with rl_point; the caller\n    must set it. */\n static void\n-make_history_line_current (entry)\n-     HIST_ENTRY *entry;\n+make_history_line_current (HIST_ENTRY *entry)\n {\n   _rl_replace_text (entry->line, 0, rl_end);\n   _rl_fix_point (1);\n@@ -112,11 +111,10 @@ make_history_line_current (entry)\n    for STRING.  DIR < 0 means to search backwards through the history list,\n    DIR >= 0 means to search forward. */\n static int\n-noninc_search_from_pos (string, pos, dir)\n-     char *string;\n-     int pos, dir;\n+noninc_search_from_pos (char *string, int pos, int dir, int flags, int *ncp)\n {\n-  int ret, old;\n+  int ret, old, sflags;\n+  char *s;\n \n   if (pos < 0)\n     return -1;\n@@ -126,12 +124,28 @@ noninc_search_from_pos (string, pos, dir)\n     return -1;\n \n   RL_SETSTATE(RL_STATE_SEARCH);\n-  if (*string == '^')\n+  /* These functions return the match offset in the line; history_offset gives\n+     the matching line in the history list */\n+  if (flags & SF_PATTERN)\n+    {\n+      s = string;\n+      sflags = 0;\t\t/* Non-anchored search */\n+      if (*s == '^')\n+\t{\n+\t  sflags |= ANCHORED_SEARCH;\n+\t  s++;\n+\t}\n+      ret = _hs_history_patsearch (s, dir, sflags);\n+    }\n+  else if (*string == '^')\n     ret = history_search_prefix (string + 1, dir);\n   else\n     ret = history_search (string, dir);\n   RL_UNSETSTATE(RL_STATE_SEARCH);\n \n+  if (ncp)\n+    *ncp = ret;\t\t/* caller will catch -1 to indicate no-op */\n+\n   if (ret != -1)\n     ret = where_history ();\n \n@@ -143,9 +157,7 @@ noninc_search_from_pos (string, pos, dir)\n    search is backwards through previous entries, else through subsequent\n    entries.  Returns 1 if the search was successful, 0 otherwise. */\n static int\n-noninc_dosearch (string, dir)\n-     char *string;\n-     int dir;\n+noninc_dosearch (char *string, int dir, int flags)\n {\n   int oldpos, pos;\n   HIST_ENTRY *entry;\n@@ -156,7 +168,7 @@ noninc_dosearch (string, dir)\n       return 0;\n     }\n \n-  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir);\n+  pos = noninc_search_from_pos (string, noninc_history_pos + dir, dir, flags, (int *)0);\n   if (pos == -1)\n     {\n       /* Search failed, current history position unchanged. */\n@@ -188,15 +200,18 @@ noninc_dosearch (string, dir)\n }\n \n static _rl_search_cxt *\n-_rl_nsearch_init (dir, pchar)\n-     int dir, pchar;\n+_rl_nsearch_init (int dir, int pchar)\n {\n   _rl_search_cxt *cxt;\n   char *p;\n \n   cxt = _rl_scxt_alloc (RL_SEARCH_NSEARCH, 0);\n   if (dir < 0)\n     cxt->sflags |= SF_REVERSE;\t\t/* not strictly needed */\n+#if defined (VI_MODE)\n+  if (VI_COMMAND_MODE() && (pchar == '?' || pchar == '/'))\n+    cxt->sflags |= SF_PATTERN;\n+#endif\n \n   cxt->direction = dir;\n   cxt->history_pos = cxt->save_line;\n@@ -224,9 +239,7 @@ _rl_nsearch_init (dir, pchar)\n }\n \n int\n-_rl_nsearch_cleanup (cxt, r)\n-     _rl_search_cxt *cxt;\n-     int r;\n+_rl_nsearch_cleanup (_rl_search_cxt *cxt, int r)\n {\n   _rl_scxt_dispose (cxt, 0);\n   _rl_nscxt = 0;\n@@ -237,8 +250,7 @@ _rl_nsearch_cleanup (cxt, r)\n }\n \n static void\n-_rl_nsearch_abort (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_nsearch_abort (_rl_search_cxt *cxt)\n {\n   rl_maybe_unsave_line ();\n   rl_clear_message ();\n@@ -253,10 +265,11 @@ _rl_nsearch_abort (cxt)\n    if the caller should abort the search, 0 if we should break out of the\n    loop, and 1 if we should continue to read characters. */\n static int\n-_rl_nsearch_dispatch (cxt, c)\n-     _rl_search_cxt *cxt;\n-     int c;\n+_rl_nsearch_dispatch (_rl_search_cxt *cxt, int c)\n {\n+  if (c < 0)\n+    c = CTRL ('C');  \n+\n   switch (c)\n     {\n     case CTRL('W'):\n@@ -306,8 +319,7 @@ _rl_nsearch_dispatch (cxt, c)\n    using _rl_nsearch_cleanup ().  Returns 1 if the search was successful,\n    0 otherwise. */\n static int\n-_rl_nsearch_dosearch (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_nsearch_dosearch (_rl_search_cxt *cxt)\n {\n   rl_mark = cxt->save_mark;\n \n@@ -340,7 +352,7 @@ _rl_nsearch_dosearch (cxt)\n     }\n \n   rl_restore_prompt ();\n-  return (noninc_dosearch (noninc_search_string, cxt->direction));\n+  return (noninc_dosearch (noninc_search_string, cxt->direction, cxt->sflags&SF_PATTERN));\n }\n \n /* Search non-interactively through the history list.  DIR < 0 means to\n@@ -349,9 +361,7 @@ _rl_nsearch_dosearch (cxt)\n    history list.  PCHAR is the character to use for prompting when reading\n    the search string; if not specified (0), it defaults to `:'. */\n static int\n-noninc_search (dir, pchar)\n-     int dir;\n-     int pchar;\n+noninc_search (int dir, int pchar)\n {\n   _rl_search_cxt *cxt;\n   int c, r;\n@@ -367,6 +377,12 @@ noninc_search (dir, pchar)\n     {\n       c = _rl_search_getchar (cxt);\n \n+      if (c < 0)\n+\t{\n+\t  _rl_nsearch_abort (cxt);\n+\t  return 1;\n+\t}\n+\t  \n       if (c == 0)\n \tbreak;\n \n@@ -384,26 +400,24 @@ noninc_search (dir, pchar)\n /* Search forward through the history list for a string.  If the vi-mode\n    code calls this, KEY will be `?'. */\n int\n-rl_noninc_forward_search (count, key)\n-     int count, key;\n+rl_noninc_forward_search (int count, int key)\n {\n   return noninc_search (1, (key == '?') ? '?' : 0);\n }\n \n /* Reverse search the history list for a string.  If the vi-mode code\n    calls this, KEY will be `/'. */\n int\n-rl_noninc_reverse_search (count, key)\n-     int count, key;\n+rl_noninc_reverse_search (int count, int key)\n {\n   return noninc_search (-1, (key == '/') ? '/' : 0);\n }\n \n /* Search forward through the history list for the last string searched\n-   for.  If there is no saved search string, abort. */\n+   for.  If there is no saved search string, abort.  If the vi-mode code\n+   calls this, KEY will be `N'. */\n int\n-rl_noninc_forward_search_again (count, key)\n-     int count, key;\n+rl_noninc_forward_search_again (int count, int key)\n {\n   int r;\n \n@@ -412,15 +426,20 @@ rl_noninc_forward_search_again (count, key)\n       rl_ding ();\n       return (1);\n     }\n-  r = noninc_dosearch (noninc_search_string, 1);\n+#if defined (VI_MODE)\n+  if (VI_COMMAND_MODE() && key == 'N')\n+    r = noninc_dosearch (noninc_search_string, 1, SF_PATTERN);\n+  else\n+#endif\n+    r = noninc_dosearch (noninc_search_string, 1, 0);\n   return (r != 1);\n }\n \n /* Reverse search in the history list for the last string searched\n-   for.  If there is no saved search string, abort. */\n+   for.  If there is no saved search string, abort.  If the vi-mode code\n+   calls this, KEY will be `n'. */\n int\n-rl_noninc_reverse_search_again (count, key)\n-     int count, key;\n+rl_noninc_reverse_search_again (int count, int key)\n {\n   int r;\n \n@@ -429,18 +448,28 @@ rl_noninc_reverse_search_again (count, key)\n       rl_ding ();\n       return (1);\n     }\n-  r = noninc_dosearch (noninc_search_string, -1);\n+#if defined (VI_MODE)\n+  if (VI_COMMAND_MODE() && key == 'n')\n+    r = noninc_dosearch (noninc_search_string, -1, SF_PATTERN);\n+  else\n+#endif\n+    r = noninc_dosearch (noninc_search_string, -1, 0);\n   return (r != 1);\n }\n \n #if defined (READLINE_CALLBACKS)\n int\n-_rl_nsearch_callback (cxt)\n-     _rl_search_cxt *cxt;\n+_rl_nsearch_callback (_rl_search_cxt *cxt)\n {\n   int c, r;\n \n   c = _rl_search_getchar (cxt);\n+  if (c <= 0)\n+    {\n+      if (c < 0)\n+        _rl_nsearch_abort (cxt);\n+      return 1;\n+    }\n   r = _rl_nsearch_dispatch (cxt, c);\n   if (r != 0)\n     return 1;\n@@ -451,11 +480,10 @@ _rl_nsearch_callback (cxt)\n #endif\n   \n static int\n-rl_history_search_internal (count, dir)\n-     int count, dir;\n+rl_history_search_internal (int count, int dir)\n {\n   HIST_ENTRY *temp;\n-  int ret, oldpos;\n+  int ret, oldpos, newcol;\n   char *t;\n \n   rl_maybe_save_line ();\n@@ -469,7 +497,7 @@ rl_history_search_internal (count, dir)\n   while (count)\n     {\n       RL_CHECK_SIGNALS ();\n-      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);\n+      ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir, 0, &newcol);\n       if (ret == -1)\n \tbreak;\n \n@@ -512,21 +540,25 @@ rl_history_search_internal (count, dir)\n   /* Copy the line we found into the current line buffer. */\n   make_history_line_current (temp);\n \n+  /* decide where to put rl_point -- need to change this for pattern search */\n   if (rl_history_search_flags & ANCHORED_SEARCH)\n     rl_point = rl_history_search_len;\t/* easy case */\n   else\n     {\n-      t = strstr (rl_line_buffer, history_search_string);\n+#if 0\n+      t = strstr (rl_line_buffer, history_search_string);\t/* XXX */\n       rl_point = t ? (int)(t - rl_line_buffer) + rl_history_search_len : rl_end;\n+#else\n+      rl_point = (newcol >= 0) ? newcol : rl_end;\n+#endif\n     }\n   rl_mark = rl_end;\n \n   return 0;\n }\n \n static void\n-rl_history_search_reinit (flags)\n-     int flags;\n+rl_history_search_reinit (int flags)\n {\n   int sind;\n \n@@ -556,8 +588,7 @@ rl_history_search_reinit (flags)\n    from the start of the line to rl_point.  This is a non-incremental\n    search.  The search is anchored to the beginning of the history line. */\n int\n-rl_history_search_forward (count, ignore)\n-     int count, ignore;\n+rl_history_search_forward (int count, int ignore)\n {\n   if (count == 0)\n     return (0);\n@@ -575,8 +606,7 @@ rl_history_search_forward (count, ignore)\n    from the start of the line to rl_point.  This is a non-incremental\n    search. */\n int\n-rl_history_search_backward (count, ignore)\n-     int count, ignore;\n+rl_history_search_backward (int count, int ignore)\n {\n   if (count == 0)\n     return (0);\n@@ -595,8 +625,7 @@ rl_history_search_backward (count, ignore)\n    search.  The search succeeds if the search string is present anywhere\n    in the history line. */\n int\n-rl_history_substr_search_forward (count, ignore)\n-     int count, ignore;\n+rl_history_substr_search_forward (int count, int ignore)\n {\n   if (count == 0)\n     return (0);\n@@ -614,8 +643,7 @@ rl_history_substr_search_forward (count, ignore)\n    from the start of the line to rl_point.  This is a non-incremental\n    search. */\n int\n-rl_history_substr_search_backward (count, ignore)\n-     int count, ignore;\n+rl_history_substr_search_backward (int count, int ignore)\n {\n   if (count == 0)\n     return (0);"
    },
    {
      "sha": "7fe2e97c983360641288ca4ecca254932c6bf053",
      "filename": "readline/shell.c",
      "status": "modified",
      "additions": 6,
      "deletions": 10,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/shell.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/shell.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/shell.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n /* shell.c -- readline utility functions that are normally provided by\n \t      bash when readline is linked as part of the shell. */\n \n-/* Copyright (C) 1997-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1997-2009,2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -92,8 +92,7 @@ extern struct passwd *getpwuid PARAMS((uid_t));\n \n /* Does shell-like quoting using single quotes. */\n char *\n-sh_single_quote (string)\n-     char *string;\n+sh_single_quote (char *string)\n {\n   register int c;\n   char *result, *r, *s;\n@@ -127,8 +126,7 @@ static char putenv_buf1[INT_STRLEN_BOUND (int) + 6 + 1];\t/* sizeof(\"LINES=\") ==\n static char putenv_buf2[INT_STRLEN_BOUND (int) + 8 + 1];\t/* sizeof(\"COLUMNS=\") == 8 */\n \n void\n-sh_set_lines_and_columns (lines, cols)\n-     int lines, cols;\n+sh_set_lines_and_columns (int lines, int cols)\n {\n #if defined (HAVE_SETENV)\n   sprintf (setenv_buf, \"%d\", lines);\n@@ -148,14 +146,13 @@ sh_set_lines_and_columns (lines, cols)\n }\n \n char *\n-sh_get_env_value (varname)\n-     const char *varname;\n+sh_get_env_value (const char *varname)\n {\n   return ((char *)getenv (varname));\n }\n \n char *\n-sh_get_home_dir ()\n+sh_get_home_dir (void)\n {\n   static char *home_dir = (char *)NULL;\n   struct passwd *entry;\n@@ -188,8 +185,7 @@ sh_get_home_dir ()\n #endif\n \n int\n-sh_unset_nodelay_mode (fd)\n-     int fd;\n+sh_unset_nodelay_mode (int fd)\n {\n #if defined (HAVE_FCNTL)\n   int flags, bflags;"
    },
    {
      "sha": "76c5c4733010b61e5a891ebcf0c3fd308274975e",
      "filename": "readline/signals.c",
      "status": "modified",
      "additions": 42,
      "deletions": 40,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/signals.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/signals.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/signals.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* signals.c -- signal handling support for readline. */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -113,6 +113,10 @@ int _rl_susp_char = 0;\n static int signals_set_flag;\n static int sigwinch_set_flag;\n \n+#if defined (HAVE_POSIX_SIGNALS)\n+sigset_t _rl_orig_sigset;\n+#endif /* !HAVE_POSIX_SIGNALS */\n+\n /* **************************************************************** */\n /*\t\t\t\t\t        \t\t    */\n /*\t\t\t   Signal Handling                          */\n@@ -134,8 +138,7 @@ void *_rl_sigcleanarg;\n \n /* Called from RL_CHECK_SIGNALS() macro */\n RETSIGTYPE\n-_rl_signal_handler (sig)\n-     int sig;\n+_rl_signal_handler (int sig)\n {\n   _rl_caught_signal = 0;\t/* XXX */\n \n@@ -158,8 +161,7 @@ _rl_signal_handler (sig)\n }\n \n static RETSIGTYPE\n-rl_signal_handler (sig)\n-     int sig;\n+rl_signal_handler (int sig)\n {\n   if (_rl_interrupt_immediately)\n     {\n@@ -173,8 +175,7 @@ rl_signal_handler (sig)\n }\n \n static RETSIGTYPE\n-_rl_handle_signal (sig)\n-     int sig;\n+_rl_handle_signal (int sig)\n {\n #if defined (HAVE_POSIX_SIGNALS)\n   sigset_t set;\n@@ -248,9 +249,11 @@ _rl_handle_signal (sig)\n       rl_cleanup_after_signal ();\n \n #if defined (HAVE_POSIX_SIGNALS)\n+#  if defined (SIGTSTP)\n       /* Unblock SIGTTOU blocked above */\n       if (sig == SIGTTIN || sig == SIGTSTP)\n \tsigprocmask (SIG_UNBLOCK, &set, (sigset_t *)NULL);\n+#  endif\n \n       sigemptyset (&set);\n       sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);\n@@ -289,8 +292,7 @@ _rl_handle_signal (sig)\n \n #if defined (SIGWINCH)\n static RETSIGTYPE\n-rl_sigwinch_handler (sig)\n-     int sig;\n+rl_sigwinch_handler (int sig)\n {\n   SigHandler *oh;\n \n@@ -321,9 +323,7 @@ rl_sigwinch_handler (sig)\n \n #if !defined (HAVE_POSIX_SIGNALS)\n static int\n-rl_sigaction (sig, nh, oh)\n-     int sig;\n-     sighandler_cxt *nh, *oh;\n+rl_sigaction (int sig, sighandler_cxt *nh, sighandler_cxt *oh)\n {\n   oh->sa_handler = signal (sig, nh->sa_handler);\n   return 0;\n@@ -334,10 +334,7 @@ rl_sigaction (sig, nh, oh)\n    information in OHANDLER.  Return the old signal handler, like\n    signal(). */\n static SigHandler *\n-rl_set_sighandler (sig, handler, ohandler)\n-     int sig;\n-     SigHandler *handler;\n-     sighandler_cxt *ohandler;\n+rl_set_sighandler (int sig, SigHandler *handler, sighandler_cxt *ohandler)\n {\n   sighandler_cxt old_handler;\n #if defined (HAVE_POSIX_SIGNALS)\n@@ -368,10 +365,7 @@ rl_set_sighandler (sig, handler, ohandler)\n /* Set disposition of SIG to HANDLER, returning old state in OHANDLER.  Don't\n    change disposition if OHANDLER indicates the signal was ignored. */\n static void\n-rl_maybe_set_sighandler (sig, handler, ohandler)\n-     int sig;\n-     SigHandler *handler;\n-     sighandler_cxt *ohandler;\n+rl_maybe_set_sighandler (int sig, SigHandler *handler, sighandler_cxt *ohandler)\n {\n   sighandler_cxt dummy;\n   SigHandler *oh;\n@@ -388,9 +382,7 @@ rl_maybe_set_sighandler (sig, handler, ohandler)\n    disposition was changed using rl_maybe_set_sighandler or for which the\n    SIG_IGN check was performed inline (e.g., SIGALRM below). */\n static void\n-rl_maybe_restore_sighandler (sig, handler)\n-     int sig;\n-     sighandler_cxt *handler;\n+rl_maybe_restore_sighandler (int sig, sighandler_cxt *handler)\n {\n   sighandler_cxt dummy;\n \n@@ -401,7 +393,7 @@ rl_maybe_restore_sighandler (sig, handler)\n }\n \n int\n-rl_set_signals ()\n+rl_set_signals (void)\n {\n   sighandler_cxt dummy;\n   SigHandler *oh;\n@@ -442,8 +434,8 @@ rl_set_signals ()\n   if (rl_catch_signals && signals_set_flag == 0)\n     {\n #if defined (HAVE_POSIX_SIGNALS)\n-      sigemptyset (&oset);\n-      sigprocmask (SIG_BLOCK, &bset, &oset);\n+      sigemptyset (&_rl_orig_sigset);\n+      sigprocmask (SIG_BLOCK, &bset, &_rl_orig_sigset);\n #endif\n \n       rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);\n@@ -484,7 +476,14 @@ rl_set_signals ()\n       signals_set_flag = 1;\n \n #if defined (HAVE_POSIX_SIGNALS)\n-      sigprocmask (SIG_SETMASK, &oset, (sigset_t *)NULL);\n+      sigprocmask (SIG_SETMASK, &_rl_orig_sigset, (sigset_t *)NULL);\n+#endif\n+    }\n+  else if (rl_catch_signals == 0)\n+    {\n+#if defined (HAVE_POSIX_SIGNALS)\n+      sigemptyset (&_rl_orig_sigset);\n+      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &_rl_orig_sigset);\n #endif\n     }\n \n@@ -500,14 +499,12 @@ rl_set_signals ()\n }\n \n int\n-rl_clear_signals ()\n+rl_clear_signals (void)\n {\n   sighandler_cxt dummy;\n \n   if (rl_catch_signals && signals_set_flag == 1)\n     {\n-      sigemptyset (&dummy.sa_mask);\n-\n       /* Since rl_maybe_set_sighandler doesn't override a SIG_IGN handler,\n \t we should in theory not have to restore a handler where\n \t old_xxx.sa_handler == SIG_IGN.  That's what rl_maybe_restore_sighandler\n@@ -555,7 +552,7 @@ rl_clear_signals ()\n /* Clean up the terminal and readline state after catching a signal, before\n    resending it to the calling application. */\n void\n-rl_cleanup_after_signal ()\n+rl_cleanup_after_signal (void)\n {\n   _rl_clean_up_for_exit ();\n   if (rl_deprep_term_function)\n@@ -566,7 +563,7 @@ rl_cleanup_after_signal ()\n \n /* Reset the terminal and readline state after a signal handler returns. */\n void\n-rl_reset_after_signal ()\n+rl_reset_after_signal (void)\n {\n   if (rl_prep_term_function)\n     (*rl_prep_term_function) (_rl_meta_flag);\n@@ -578,7 +575,7 @@ rl_reset_after_signal ()\n    numeric arguments in process) after catching a signal, before calling\n    rl_cleanup_after_signal(). */ \n void\n-rl_free_line_state ()\n+rl_free_line_state (void)\n {\n   register HIST_ENTRY *entry;\n \n@@ -594,10 +591,16 @@ rl_free_line_state ()\n }\n \n int\n-rl_pending_signal ()\n+rl_pending_signal (void)\n {\n   return (_rl_caught_signal);\n }\n+\n+void\n+rl_check_signals (void)\n+{\n+  RL_CHECK_SIGNALS ();\n+}\n #endif  /* HANDLE_SIGNALS */\n \n /* **************************************************************** */\n@@ -622,7 +625,7 @@ static int sigwinch_blocked;\n /* Cause SIGINT to not be delivered until the corresponding call to\n    release_sigint(). */\n void\n-_rl_block_sigint ()\n+_rl_block_sigint (void)\n {\n   if (sigint_blocked)\n     return;\n@@ -632,7 +635,7 @@ _rl_block_sigint ()\n \n /* Allow SIGINT to be delivered. */\n void\n-_rl_release_sigint ()\n+_rl_release_sigint (void)\n {\n   if (sigint_blocked == 0)\n     return;\n@@ -644,7 +647,7 @@ _rl_release_sigint ()\n /* Cause SIGWINCH to not be delivered until the corresponding call to\n    release_sigwinch(). */\n void\n-_rl_block_sigwinch ()\n+_rl_block_sigwinch (void)\n {\n   if (sigwinch_blocked)\n     return;\n@@ -673,7 +676,7 @@ _rl_block_sigwinch ()\n \n /* Allow SIGWINCH to be delivered. */\n void\n-_rl_release_sigwinch ()\n+_rl_release_sigwinch (void)\n {\n   if (sigwinch_blocked == 0)\n     return;\n@@ -703,8 +706,7 @@ _rl_release_sigwinch ()\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n void\n-rl_echo_signal_char (sig)\n-     int sig;\n+rl_echo_signal_char (int sig)\n {\n   char cstr[3];\n   int cslen, c;"
    },
    {
      "sha": "15c6cbfc5dcdc04930f28cda3f07c1404fb97508",
      "filename": "readline/support/config.guess",
      "status": "modified",
      "additions": 19,
      "deletions": 15,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/config.guess",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/config.guess",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/config.guess?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -247,7 +247,7 @@ case \"$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION\" in\n \texit ;;\n     *:Bitrig:*:*)\n \tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n-\techo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}\n+\techo \"$UNAME_MACHINE_ARCH\"-unknown-bitrig\"$UNAME_RELEASE\"\n \texit ;;\n     *:OpenBSD:*:*)\n \tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n@@ -395,7 +395,7 @@ case \"$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION\" in\n \techo i386-pc-auroraux\"$UNAME_RELEASE\"\n \texit ;;\n     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n-\techo i386-pc-auroraux${UNAME_RELEASE}\n+\techo i386-pc-auroraux\"$UNAME_RELEASE\"\n \texit ;;\n     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n \tset_cc_for_build\n@@ -877,7 +877,7 @@ EOF\n \techo \"$UNAME_MACHINE\"-pc-mingw64\n \texit ;;\n     *:MINGW64*:*)\n-\techo ${UNAME_MACHINE}-pc-mingw64\n+\techo \"$UNAME_MACHINE\"-pc-mingw64\n \texit ;;\n     *:MINGW*:*)\n \techo \"$UNAME_MACHINE\"-pc-mingw32\n@@ -945,11 +945,11 @@ EOF\n \techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n     aarch64:Linux:*:*)\n-\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n     aarch64_be:Linux:*:*)\n \tUNAME_MACHINE=aarch64_be\n-\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n     alpha:Linux:*:*)\n \tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo` in\n@@ -962,11 +962,11 @@ EOF\n \t  EV68*) UNAME_MACHINE=alphaev68 ;;\n \tesac\n \tobjdump --private-headers /bin/sh | grep -q ld.so.1\n-\tif test \"$?\" = 0 ; then LIBC=\"gnulibc1\" ; fi\n-\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\tif test \"$?\" = 0 ; then LIBC=gnulibc1 ; fi\n+\techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n     arc:Linux:*:* | arceb:Linux:*:*)\n-\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n     arm*:Linux:*:*)\n \tset_cc_for_build\n@@ -1494,10 +1494,13 @@ EOF\n \techo \"$UNAME_MACHINE\"-unknown-unleashed\"$UNAME_RELEASE\"\n \texit ;;\n     i*86:AROS:*:*)\n-\techo ${UNAME_MACHINE}-pc-aros\n+\techo \"$UNAME_MACHINE\"-pc-aros\n \texit ;;\n     x86_64:VMkernel:*:*)\n-\techo ${UNAME_MACHINE}-unknown-esx\n+\techo \"$UNAME_MACHINE\"-unknown-esx\n+\texit ;;\n+    amd64:Isilon\\ OneFS:*:*)\n+\techo x86_64-unknown-onefs\n \texit ;;\n esac\n \n@@ -1624,12 +1627,13 @@ main ()\n #endif\n #endif\n \n-#if defined (alliant) && defined (i860)\n-  printf (\"i860-alliant-bsd\\n\"); exit (0);\n-#endif\n+case \"$UNAME_MACHINE:$UNAME_SYSTEM\" in\n+    mips:Linux | mips64:Linux)\n+\t# If we got here on MIPS GNU/Linux, output extra information.\n+\tcat >&2 <<EOF\n \n-  exit (1);\n-}\n+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize\n+the system type. Please install a C compiler and try again.\n EOF\n \n $CC_FOR_BUILD -o \"$dummy\" \"$dummy.c\" 2>/dev/null && SYSTEM_NAME=`$dummy` &&"
    },
    {
      "sha": "fc5913d7878bc855696d599b4585c0c44f166449",
      "filename": "readline/support/config.rpath",
      "status": "modified",
      "additions": 255,
      "deletions": 118,
      "changes": 373,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/config.rpath",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/config.rpath",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/config.rpath?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -2,27 +2,13 @@\n # Output a system dependent set of variables, describing how to set the\n # run time search path of shared libraries in an executable.\n #\n-#   Copyright 1996-2003 Free Software Foundation, Inc.\n+#   Copyright 1996-2018 Free Software Foundation, Inc.\n #   Taken from GNU libtool, 2001\n #   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n #\n-#   This program is free software: you can redistribute it and/or modify\n-#   it under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n-#\n-#   This program is distributed in the hope that it will be useful,\n-#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#   GNU General Public License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-#   As a special exception to the GNU General Public License, if you\n-#   distribute this file as part of a program that contains a\n-#   configuration script generated by Autoconf, you may include it under\n-#   the same distribution terms that you use for the rest of that program.\n+#   This file is free software; the Free Software Foundation gives\n+#   unlimited permission to copy and/or distribute it, with or without\n+#   modifications, as long as this notice is preserved.\n #\n # The first argument passed to this file is the canonical host specification,\n #    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM\n@@ -39,7 +25,7 @@\n #   known workaround is to choose shorter directory names for the build\n #   directory and/or the installation directory.\n \n-# All known linkers require a `.a' archive for static linking (except M$VC,\n+# All known linkers require a '.a' archive for static linking (except MSVC,\n # which needs '.lib').\n libext=a\n shrext=.so\n@@ -49,7 +35,19 @@ host_cpu=`echo \"$host\" | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\1/'`\n host_vendor=`echo \"$host\" | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\2/'`\n host_os=`echo \"$host\" | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n \n-# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.\n+# Code taken from libtool.m4's _LT_CC_BASENAME.\n+\n+for cc_temp in $CC\"\"; do\n+  case $cc_temp in\n+    compile | *[\\\\/]compile | ccache | *[\\\\/]ccache ) ;;\n+    distcc | *[\\\\/]distcc | purify | *[\\\\/]purify ) ;;\n+    \\-*) ;;\n+    *) break;;\n+  esac\n+done\n+cc_basename=`echo \"$cc_temp\" | sed -e 's%^.*/%%'`\n+\n+# Code taken from libtool.m4's _LT_COMPILER_PIC.\n \n wl=\n if test \"$GCC\" = yes; then\n@@ -59,96 +57,148 @@ else\n     aix*)\n       wl='-Wl,'\n       ;;\n-    mingw* | pw32* | os2*)\n+    mingw* | cygwin* | pw32* | os2* | cegcc*)\n       ;;\n     hpux9* | hpux10* | hpux11*)\n       wl='-Wl,'\n       ;;\n     irix5* | irix6* | nonstopux*)\n       wl='-Wl,'\n       ;;\n-    newsos6)\n-      ;;\n-    linux*)\n-      case $CC in\n-        icc|ecc)\n+    linux* | k*bsd*-gnu | kopensolaris*-gnu)\n+      case $cc_basename in\n+        ecc*)\n+          wl='-Wl,'\n+          ;;\n+        icc* | ifort*)\n+          wl='-Wl,'\n+          ;;\n+        lf95*)\n+          wl='-Wl,'\n+          ;;\n+        nagfor*)\n+          wl='-Wl,-Wl,,'\n+          ;;\n+        pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n+          wl='-Wl,'\n+          ;;\n+        ccc*)\n           wl='-Wl,'\n           ;;\n-        ccc)\n+        xl* | bgxl* | bgf* | mpixl*)\n           wl='-Wl,'\n           ;;\n+        como)\n+          wl='-lopt='\n+          ;;\n+        *)\n+          case `$CC -V 2>&1 | sed 5q` in\n+            *Sun\\ F* | *Sun*Fortran*)\n+              wl=\n+              ;;\n+            *Sun\\ C*)\n+              wl='-Wl,'\n+              ;;\n+          esac\n+          ;;\n       esac\n       ;;\n+    newsos6)\n+      ;;\n+    *nto* | *qnx*)\n+      ;;\n     osf3* | osf4* | osf5*)\n       wl='-Wl,'\n       ;;\n-    sco3.2v5*)\n+    rdos*)\n       ;;\n     solaris*)\n-      wl='-Wl,'\n+      case $cc_basename in\n+        f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n+          wl='-Qoption ld '\n+          ;;\n+        *)\n+          wl='-Wl,'\n+          ;;\n+      esac\n       ;;\n     sunos4*)\n       wl='-Qoption ld '\n       ;;\n-    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n+    sysv4 | sysv4.2uw2* | sysv4.3*)\n       wl='-Wl,'\n       ;;\n     sysv4*MP*)\n       ;;\n+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n+      wl='-Wl,'\n+      ;;\n+    unicos*)\n+      wl='-Wl,'\n+      ;;\n     uts4*)\n       ;;\n   esac\n fi\n \n-# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.\n+# Code taken from libtool.m4's _LT_LINKER_SHLIBS.\n \n hardcode_libdir_flag_spec=\n hardcode_libdir_separator=\n hardcode_direct=no\n hardcode_minus_L=no\n \n case \"$host_os\" in\n-  cygwin* | mingw* | pw32*)\n+  cygwin* | mingw* | pw32* | cegcc*)\n     # FIXME: the MSVC++ port hasn't been tested in a loooong time\n     # When not using gcc, we currently assume that we are using\n     # Microsoft Visual C++.\n     if test \"$GCC\" != yes; then\n       with_gnu_ld=no\n     fi\n     ;;\n+  interix*)\n+    # we just hope/assume this is gcc and not c89 (= MSVC++)\n+    with_gnu_ld=yes\n+    ;;\n   openbsd*)\n     with_gnu_ld=no\n     ;;\n esac\n \n ld_shlibs=yes\n if test \"$with_gnu_ld\" = yes; then\n+  # Set some defaults for GNU ld with shared library support. These\n+  # are reset later if shared libraries are not supported. Putting them\n+  # here allows them to be overridden if necessary.\n+  # Unlike libtool, we use -rpath here, not --rpath, since the documented\n+  # option of GNU ld is called -rpath, not --rpath.\n+  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'\n   case \"$host_os\" in\n-    aix3* | aix4* | aix5*)\n+    aix[3-9]*)\n       # On AIX/PPC, the GNU linker is very broken\n       if test \"$host_cpu\" != ia64; then\n         ld_shlibs=no\n       fi\n       ;;\n     amigaos*)\n-      hardcode_libdir_flag_spec='-L$libdir'\n-      hardcode_minus_L=yes\n-      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports\n-      # that the semantics of dynamic libraries on AmigaOS, at least up\n-      # to version 4, is to share data among multiple programs linked\n-      # with the same dynamic library.  Since this doesn't match the\n-      # behavior of shared libraries on other platforms, we can use\n-      # them.\n-      ld_shlibs=no\n+      case \"$host_cpu\" in\n+        powerpc)\n+          ;;\n+        m68k)\n+          hardcode_libdir_flag_spec='-L$libdir'\n+          hardcode_minus_L=yes\n+          ;;\n+      esac\n       ;;\n     beos*)\n-      if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then\n+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n         :\n       else\n         ld_shlibs=no\n       fi\n       ;;\n-    cygwin* | mingw* | pw32*)\n+    cygwin* | mingw* | pw32* | cegcc*)\n       # hardcode_libdir_flag_spec is actually meaningless, as there is\n       # no search path for DLLs.\n       hardcode_libdir_flag_spec='-L$libdir'\n@@ -158,32 +208,57 @@ if test \"$with_gnu_ld\" = yes; then\n         ld_shlibs=no\n       fi\n       ;;\n+    haiku*)\n+      ;;\n+    interix[3-9]*)\n+      hardcode_direct=no\n+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'\n+      ;;\n+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n+        :\n+      else\n+        ld_shlibs=no\n+      fi\n+      ;;\n     netbsd*)\n       ;;\n-    solaris* | sysv5*)\n-      if $LD -v 2>&1 | egrep 'BFD 2\\.8' > /dev/null; then\n+    solaris*)\n+      if $LD -v 2>&1 | grep 'BFD 2\\.8' > /dev/null; then\n         ld_shlibs=no\n-      elif $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then\n+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n         :\n       else\n         ld_shlibs=no\n       fi\n       ;;\n+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n+      case `$LD -v 2>&1` in\n+        *\\ [01].* | *\\ 2.[0-9].* | *\\ 2.1[0-5].*)\n+          ld_shlibs=no\n+          ;;\n+        *)\n+          if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n+            hardcode_libdir_flag_spec='`test -z \"$SCOABSPATH\" && echo ${wl}-rpath,$libdir`'\n+          else\n+            ld_shlibs=no\n+          fi\n+          ;;\n+      esac\n+      ;;\n     sunos4*)\n       hardcode_direct=yes\n       ;;\n     *)\n-      if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then\n+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then\n         :\n       else\n         ld_shlibs=no\n       fi\n       ;;\n   esac\n-  if test \"$ld_shlibs\" = yes; then\n-    # Unlike libtool, we use -rpath here, not --rpath, since the documented\n-    # option of GNU ld is called -rpath, not --rpath.\n-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'\n+  if test \"$ld_shlibs\" = no; then\n+    hardcode_libdir_flag_spec=\n   fi\n else\n   case \"$host_os\" in\n@@ -197,7 +272,7 @@ else\n         hardcode_direct=unsupported\n       fi\n       ;;\n-    aix4* | aix5*)\n+    aix[4-9]*)\n       if test \"$host_cpu\" = ia64; then\n         # On IA64, the linker does run time linking by default, so we don't\n         # have to do anything special.\n@@ -207,13 +282,14 @@ else\n         # Test if we are trying to use run time linking or normal\n         # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n         # need to do runtime linking.\n-        case $host_os in aix4.[23]|aix4.[23].*|aix5*)\n+        case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)\n           for ld_flag in $LDFLAGS; do\n             if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n               aix_use_runtimelinking=yes\n               break\n             fi\n           done\n+          ;;\n         esac\n       fi\n       hardcode_direct=yes\n@@ -225,14 +301,15 @@ else\n             strings \"$collect2name\" | grep resolve_lib_name >/dev/null\n           then\n             # We have reworked collect2\n-            hardcode_direct=yes\n+            :\n           else\n             # We have old collect2\n             hardcode_direct=unsupported\n             hardcode_minus_L=yes\n             hardcode_libdir_flag_spec='-L$libdir'\n             hardcode_libdir_separator=\n           fi\n+          ;;\n         esac\n       fi\n       # Begin _LT_AC_SYS_LIBPATH_AIX.\n@@ -260,14 +337,18 @@ else\n       fi\n       ;;\n     amigaos*)\n-      hardcode_libdir_flag_spec='-L$libdir'\n-      hardcode_minus_L=yes\n-      # see comment about different semantics on the GNU ld section\n-      ld_shlibs=no\n+      case \"$host_cpu\" in\n+        powerpc)\n+          ;;\n+        m68k)\n+          hardcode_libdir_flag_spec='-L$libdir'\n+          hardcode_minus_L=yes\n+          ;;\n+      esac\n       ;;\n-    bsdi4*)\n+    bsdi[45]*)\n       ;;\n-    cygwin* | mingw* | pw32*)\n+    cygwin* | mingw* | pw32* | cegcc*)\n       # When not using gcc, we currently assume that we are using\n       # Microsoft Visual C++.\n       # hardcode_libdir_flag_spec is actually meaningless, as there is\n@@ -276,25 +357,21 @@ else\n       libext=lib\n       ;;\n     darwin* | rhapsody*)\n-      if $CC -v 2>&1 | grep 'Apple' >/dev/null ; then\n-        hardcode_direct=no\n+      hardcode_direct=no\n+      if { case $cc_basename in ifort*) true;; *) test \"$GCC\" = yes;; esac; }; then\n+        :\n+      else\n+        ld_shlibs=no\n       fi\n       ;;\n     dgux*)\n       hardcode_libdir_flag_spec='-L$libdir'\n       ;;\n-    freebsd1*)\n-      ld_shlibs=no\n-      ;;\n-    freebsd2.2*)\n-      hardcode_libdir_flag_spec='-R$libdir'\n-      hardcode_direct=yes\n-      ;;\n-    freebsd2*)\n+    freebsd2.[01]*)\n       hardcode_direct=yes\n       hardcode_minus_L=yes\n       ;;\n-    freebsd*)\n+    freebsd* | dragonfly*)\n       hardcode_libdir_flag_spec='-R$libdir'\n       hardcode_direct=yes\n       ;;\n@@ -306,24 +383,25 @@ else\n       # but as the default location of the library.\n       hardcode_minus_L=yes\n       ;;\n-    hpux10* | hpux11*)\n+    hpux10*)\n       if test \"$with_gnu_ld\" = no; then\n-        case \"$host_cpu\" in\n-          hppa*64*)\n-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'\n-            hardcode_libdir_separator=:\n-            hardcode_direct=no\n-            ;;\n-          ia64*)\n-            hardcode_libdir_flag_spec='-L$libdir'\n+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'\n+        hardcode_libdir_separator=:\n+        hardcode_direct=yes\n+        # hardcode_minus_L: Not really in the search PATH,\n+        # but as the default location of the library.\n+        hardcode_minus_L=yes\n+      fi\n+      ;;\n+    hpux11*)\n+      if test \"$with_gnu_ld\" = no; then\n+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'\n+        hardcode_libdir_separator=:\n+        case $host_cpu in\n+          hppa*64*|ia64*)\n             hardcode_direct=no\n-            # hardcode_minus_L: Not really in the search PATH,\n-            # but as the default location of the library.\n-            hardcode_minus_L=yes\n             ;;\n           *)\n-            hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'\n-            hardcode_libdir_separator=:\n             hardcode_direct=yes\n             # hardcode_minus_L: Not really in the search PATH,\n             # but as the default location of the library.\n@@ -345,19 +423,25 @@ else\n       hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'\n       hardcode_libdir_separator=:\n       ;;\n+    *nto* | *qnx*)\n+      ;;\n     openbsd*)\n-      hardcode_direct=yes\n-      if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n-        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'\n+      if test -f /usr/libexec/ld.so; then\n+        hardcode_direct=yes\n+        if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n+          hardcode_libdir_flag_spec='${wl}-rpath,$libdir'\n+        else\n+          case \"$host_os\" in\n+            openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)\n+              hardcode_libdir_flag_spec='-R$libdir'\n+              ;;\n+            *)\n+              hardcode_libdir_flag_spec='${wl}-rpath,$libdir'\n+              ;;\n+          esac\n+        fi\n       else\n-        case \"$host_os\" in\n-          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)\n-            hardcode_libdir_flag_spec='-R$libdir'\n-            ;;\n-          *)\n-            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'\n-            ;;\n-        esac\n+        ld_shlibs=no\n       fi\n       ;;\n     os2*)\n@@ -377,8 +461,6 @@ else\n       fi\n       hardcode_libdir_separator=:\n       ;;\n-    sco3.2v5*)\n-      ;;\n     solaris*)\n       hardcode_libdir_flag_spec='-R$libdir'\n       ;;\n@@ -407,14 +489,11 @@ else\n         ld_shlibs=yes\n       fi\n       ;;\n-    sysv4.2uw2*)\n-      hardcode_direct=yes\n-      hardcode_minus_L=no\n+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)\n       ;;\n-    sysv5OpenUNIX8* | sysv5UnixWare7* |  sysv5uw[78]* | unixware7*)\n-      ;;\n-    sysv5*)\n-      hardcode_libdir_flag_spec=\n+    sysv5* | sco3.2v5* | sco5v6*)\n+      hardcode_libdir_flag_spec='`test -z \"$SCOABSPATH\" && echo ${wl}-R,$libdir`'\n+      hardcode_libdir_separator=':'\n       ;;\n     uts4*)\n       hardcode_libdir_flag_spec='-L$libdir'\n@@ -426,35 +505,59 @@ else\n fi\n \n # Check dynamic linker characteristics\n-# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.\n+# Code taken from libtool.m4's _LT_SYS_DYNAMIC_LINKER.\n+# Unlike libtool.m4, here we don't care about _all_ names of the library, but\n+# only about the one the linker finds when passed -lNAME. This is the last\n+# element of library_names_spec in libtool.m4, or possibly two of them if the\n+# linker has special search rules.\n+library_names_spec=      # the last element of library_names_spec in libtool.m4\n libname_spec='lib$name'\n case \"$host_os\" in\n   aix3*)\n+    library_names_spec='$libname.a'\n     ;;\n-  aix4* | aix5*)\n+  aix[4-9]*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   amigaos*)\n+    case \"$host_cpu\" in\n+      powerpc*)\n+        library_names_spec='$libname$shrext' ;;\n+      m68k)\n+        library_names_spec='$libname.a' ;;\n+    esac\n     ;;\n   beos*)\n+    library_names_spec='$libname$shrext'\n     ;;\n-  bsdi4*)\n+  bsdi[45]*)\n+    library_names_spec='$libname$shrext'\n     ;;\n-  cygwin* | mingw* | pw32*)\n+  cygwin* | mingw* | pw32* | cegcc*)\n     shrext=.dll\n+    library_names_spec='$libname.dll.a $libname.lib'\n     ;;\n   darwin* | rhapsody*)\n     shrext=.dylib\n+    library_names_spec='$libname$shrext'\n     ;;\n   dgux*)\n+    library_names_spec='$libname$shrext'\n     ;;\n-  freebsd1*)\n+  freebsd[23].*)\n+    library_names_spec='$libname$shrext$versuffix'\n     ;;\n-  freebsd*)\n+  freebsd* | dragonfly*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   gnu*)\n+    library_names_spec='$libname$shrext'\n+    ;;\n+  haiku*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   hpux9* | hpux10* | hpux11*)\n-    case \"$host_cpu\" in\n+    case $host_cpu in\n       ia64*)\n         shrext=.so\n         ;;\n@@ -465,8 +568,13 @@ case \"$host_os\" in\n         shrext=.sl\n         ;;\n     esac\n+    library_names_spec='$libname$shrext'\n+    ;;\n+  interix[3-9]*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   irix5* | irix6* | nonstopux*)\n+    library_names_spec='$libname$shrext'\n     case \"$host_os\" in\n       irix5* | nonstopux*)\n         libsuff= shlibsuff=\n@@ -483,42 +591,65 @@ case \"$host_os\" in\n     ;;\n   linux*oldld* | linux*aout* | linux*coff*)\n     ;;\n-  linux*)\n+  linux* | k*bsd*-gnu | kopensolaris*-gnu)\n+    library_names_spec='$libname$shrext'\n+    ;;\n+  knetbsd*-gnu)\n+    library_names_spec='$libname$shrext'\n     ;;\n   netbsd*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   newsos6)\n+    library_names_spec='$libname$shrext'\n     ;;\n-  nto-qnx)\n+  *nto* | *qnx*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   openbsd*)\n+    library_names_spec='$libname$shrext$versuffix'\n     ;;\n   os2*)\n     libname_spec='$name'\n     shrext=.dll\n+    library_names_spec='$libname.a'\n     ;;\n   osf3* | osf4* | osf5*)\n+    library_names_spec='$libname$shrext'\n     ;;\n-  sco3.2v5*)\n+  rdos*)\n     ;;\n   solaris*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   sunos4*)\n+    library_names_spec='$libname$shrext$versuffix'\n     ;;\n-  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n+  sysv4 | sysv4.3*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   sysv4*MP*)\n+    library_names_spec='$libname$shrext'\n+    ;;\n+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n+    library_names_spec='$libname$shrext'\n+    ;;\n+  tpf*)\n+    library_names_spec='$libname$shrext'\n     ;;\n   uts4*)\n+    library_names_spec='$libname$shrext'\n     ;;\n esac\n \n sed_quote_subst='s/\\([\"`$\\\\]\\)/\\\\\\1/g'\n escaped_wl=`echo \"X$wl\" | sed -e 's/^X//' -e \"$sed_quote_subst\"`\n shlibext=`echo \"$shrext\" | sed -e 's,^\\.,,'`\n+escaped_libname_spec=`echo \"X$libname_spec\" | sed -e 's/^X//' -e \"$sed_quote_subst\"`\n+escaped_library_names_spec=`echo \"X$library_names_spec\" | sed -e 's/^X//' -e \"$sed_quote_subst\"`\n escaped_hardcode_libdir_flag_spec=`echo \"X$hardcode_libdir_flag_spec\" | sed -e 's/^X//' -e \"$sed_quote_subst\"`\n \n-sed -e 's/^\\([a-zA-Z0-9_]*\\)=/acl_cv_\\1=/' <<EOF\n+LC_ALL=C sed -e 's/^\\([a-zA-Z0-9_]*\\)=/acl_cv_\\1=/' <<EOF\n \n # How to pass a linker flag through the compiler.\n wl=\"$escaped_wl\"\n@@ -529,6 +660,12 @@ libext=\"$libext\"\n # Shared library suffix (normally \"so\").\n shlibext=\"$shlibext\"\n \n+# Format of library name prefix.\n+libname_spec=\"$escaped_libname_spec\"\n+\n+# Library names that the linker finds when passed -lNAME.\n+library_names_spec=\"$escaped_library_names_spec\"\n+\n # Flag to hardcode \\$libdir into a binary during linking.\n # This must work even if \\$libdir does not exist.\n hardcode_libdir_flag_spec=\"$escaped_hardcode_libdir_flag_spec\""
    },
    {
      "sha": "f4eea278fae63fb3924afd323fe9f95356f8b69c",
      "filename": "readline/support/shlib-install",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/shlib-install",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/shlib-install",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/shlib-install?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -73,7 +73,7 @@ fi\n case \"$host_os\" in\n hpux*|darwin*|macosx*|linux*|solaris2*)\n \tif [ -z \"$uninstall\" ]; then\n-\t\tchmod 555 ${INSTALLDIR}/${LIBNAME}\n+\t\tchmod 755 ${INSTALLDIR}/${LIBNAME}\n \tfi ;;\n cygwin*|mingw*)\n \tIMPLIBNAME=`echo ${LIBNAME} \\"
    },
    {
      "sha": "7920f1b5cb907f84d06450fac158291ebe0f0401",
      "filename": "readline/support/shobj-conf",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/shobj-conf",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/support/shobj-conf",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/shobj-conf?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -189,7 +189,7 @@ darwin*)\n \tdarwin[1-7].*)\n \t\tSHOBJ_STATUS=unsupported\n \t\tSHOBJ_LDFLAGS='-dynamic'\n-\t\tSHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t\tSHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -v'\n \t\t;;\n \t# Darwin 8 == Mac OS X 10.4; Mac OS X 10.N == Darwin N+4\n \t*)\n@@ -205,7 +205,7 @@ darwin*)\n \t\t\t;;\n \t\t esac\n \t\t SHOBJ_LDFLAGS=\"-dynamiclib -dynamic -undefined dynamic_lookup ${SHOBJ_ARCHFLAGS}\"\n-\t\t SHLIB_XLDFLAGS=\"-dynamiclib ${SHOBJ_ARCHFLAGS}\"' -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t\t SHLIB_XLDFLAGS=\"-dynamiclib ${SHOBJ_ARCHFLAGS}\"' -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -v'\n \t\t;;\n \tesac\n "
    },
    {
      "sha": "e5573897762ee8fc37840354a06ffe863ba2ad7d",
      "filename": "readline/terminal.c",
      "status": "modified",
      "additions": 31,
      "deletions": 45,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/terminal.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/terminal.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/terminal.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* terminal.c -- controlling the terminal with termcap. */\n \n-/* Copyright (C) 1996-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1996-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -112,6 +112,7 @@ char PC, *BC, *UP;\n /* Some strings to control terminal actions.  These are output by tputs (). */\n char *_rl_term_clreol;\n char *_rl_term_clrpag;\n+char *_rl_term_clrscroll;\n char *_rl_term_cr;\n char *_rl_term_backspace;\n char *_rl_term_goto;\n@@ -131,6 +132,7 @@ char *_rl_term_IC;\n char *_rl_term_dc;\n char *_rl_term_DC;\n \n+/* How to move forward a char, non-destructively */\n char *_rl_term_forward_char;\n \n /* How to go up a line. */\n@@ -188,8 +190,7 @@ int _rl_enable_meta = 1;\n \n #if defined (__EMX__)\n static void\n-_emx_get_screensize (swp, shp)\n-     int *swp, *shp;\n+_emx_get_screensize (int *swp, int *shp)\n {\n   int sz[2];\n \n@@ -204,8 +205,7 @@ _emx_get_screensize (swp, shp)\n \n #if defined (__MINGW32__)\n static void\n-_win_get_screensize (swp, shp)\n-     int *swp, *shp;\n+_win_get_screensize (int *swp, int *shp)\n {\n   HANDLE hConOut;\n   CONSOLE_SCREEN_BUFFER_INFO scr;\n@@ -227,8 +227,7 @@ _win_get_screensize (swp, shp)\n    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being\n    non-null serve to check whether or not we have initialized termcap. */\n void\n-_rl_get_screen_size (tty, ignore_env)\n-     int tty, ignore_env;\n+_rl_get_screen_size (int tty, int ignore_env)\n {\n   char *ss;\n #if defined (TIOCGWINSZ)\n@@ -318,8 +317,7 @@ _rl_get_screen_size (tty, ignore_env)\n }\n \n void\n-_rl_set_screen_size (rows, cols)\n-     int rows, cols;\n+_rl_set_screen_size (int rows, int cols)\n {\n   if (_rl_term_autowrap == -1)\n     _rl_init_terminal_io (rl_terminal_name);\n@@ -338,15 +336,13 @@ _rl_set_screen_size (rows, cols)\n }\n \n void\n-rl_set_screen_size (rows, cols)\n-     int rows, cols;\n+rl_set_screen_size (int rows, int cols)\n {\n   _rl_set_screen_size (rows, cols);\n }\n \n void\n-rl_get_screen_size (rows, cols)\n-     int *rows, *cols;\n+rl_get_screen_size (int *rows, int *cols)\n {\n   if (rows)\n     *rows = _rl_screenheight;\n@@ -355,19 +351,19 @@ rl_get_screen_size (rows, cols)\n }\n \n void\n-rl_reset_screen_size ()\n+rl_reset_screen_size (void)\n {\n   _rl_get_screen_size (fileno (rl_instream), 0);\n }\n \n void\n-_rl_sigwinch_resize_terminal ()\n+_rl_sigwinch_resize_terminal (void)\n {\n   _rl_get_screen_size (fileno (rl_instream), 1);\n }\n \t\n void\n-rl_resize_terminal ()\n+rl_resize_terminal (void)\n {\n   _rl_get_screen_size (fileno (rl_instream), 1);\n   if (_rl_echoing_p)\n@@ -390,6 +386,7 @@ static const struct _tc_string tc_strings[] =\n {\n   { \"@7\", &_rl_term_at7 },\n   { \"DC\", &_rl_term_DC },\n+  { \"E3\", &_rl_term_clrscroll },\n   { \"IC\", &_rl_term_IC },\n   { \"ce\", &_rl_term_clreol },\n   { \"cl\", &_rl_term_clrpag },\n@@ -424,8 +421,7 @@ static const struct _tc_string tc_strings[] =\n /* Read the desired terminal capability strings into BP.  The capabilities\n    are described in the TC_STRINGS table. */\n static void\n-get_term_capabilities (bp)\n-     char **bp;\n+get_term_capabilities (char **bp)\n {\n #if !defined (__DJGPP__)\t/* XXX - doesn't DJGPP have a termcap library? */\n   register int i;\n@@ -437,15 +433,14 @@ get_term_capabilities (bp)\n }\n \n int\n-_rl_init_terminal_io (terminal_name)\n-     const char *terminal_name;\n+_rl_init_terminal_io (const char *terminal_name)\n {\n   const char *term;\n   char *buffer;\n   int tty, tgetent_ret;\n \n   term = terminal_name ? terminal_name : sh_get_env_value (\"TERM\");\n-  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;\n+  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = _rl_term_clrscroll = (char *)NULL;\n   tty = rl_instream ? fileno (rl_instream) : 0;\n \n   if (term == 0)\n@@ -458,7 +453,7 @@ _rl_init_terminal_io (terminal_name)\n   _rl_term_mm = _rl_term_mo = (char *)NULL;\n   _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;\n   _rl_term_cr = \"\\r\";\n-  _rl_term_clreol = _rl_term_clrpag = _rl_term_backspace = (char *)NULL;\n+  _rl_term_backspace = (char *)NULL;\n   _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;\n   _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;\n   _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;\n@@ -584,8 +579,7 @@ _rl_init_terminal_io (terminal_name)\n \n /* Bind the arrow key sequences from the termcap description in MAP. */\n static void\n-bind_termcap_arrow_keys (map)\n-     Keymap map;\n+bind_termcap_arrow_keys (Keymap map)\n {\n   Keymap xkeymap;\n \n@@ -601,13 +595,13 @@ bind_termcap_arrow_keys (map)\n   rl_bind_keyseq_if_unbound (_rl_term_at7, rl_end_of_line);\t/* End */\n \n   rl_bind_keyseq_if_unbound (_rl_term_kD, rl_delete);\n+  rl_bind_keyseq_if_unbound (_rl_term_kI, rl_overwrite_mode);\t/* Insert */\n \n   _rl_keymap = xkeymap;\n }\n \n char *\n-rl_get_termcap (cap)\n-     const char *cap;\n+rl_get_termcap (const char *cap)\n {\n   register int i;\n \n@@ -624,8 +618,7 @@ rl_get_termcap (cap)\n /* Re-initialize the terminal considering that the TERM/TERMCAP variable\n    has changed. */\n int\n-rl_reset_terminal (terminal_name)\n-     const char *terminal_name;\n+rl_reset_terminal (const char *terminal_name)\n {\n   _rl_screenwidth = _rl_screenheight = 0;\n   _rl_init_terminal_io (terminal_name);\n@@ -635,33 +628,28 @@ rl_reset_terminal (terminal_name)\n /* A function for the use of tputs () */\n #ifdef _MINIX\n void\n-_rl_output_character_function (c)\n-     int c;\n+_rl_output_character_function (int c)\n {\n   putc (c, _rl_out_stream);\n }\n #else /* !_MINIX */\n int\n-_rl_output_character_function (c)\n-     int c;\n+_rl_output_character_function (int c)\n {\n   return putc (c, _rl_out_stream);\n }\n #endif /* !_MINIX */\n \n /* Write COUNT characters from STRING to the output stream. */\n void\n-_rl_output_some_chars (string, count)\n-     const char *string;\n-     int count;\n+_rl_output_some_chars (const char *string, int count)\n {\n   fwrite (string, 1, count, _rl_out_stream);\n }\n \n /* Move the cursor back. */\n int\n-_rl_backspace (count)\n-     int count;\n+_rl_backspace (int count)\n {\n   register int i;\n \n@@ -678,7 +666,7 @@ _rl_backspace (count)\n \n /* Move to the start of the next line. */\n int\n-rl_crlf ()\n+rl_crlf (void)\n {\n #if defined (NEW_TTY_DRIVER) || defined (__MINT__)\n   if (_rl_term_cr)\n@@ -690,7 +678,7 @@ rl_crlf ()\n \n /* Ring the terminal bell. */\n int\n-rl_ding ()\n+rl_ding (void)\n {\n   if (_rl_echoing_p)\n     {\n@@ -729,7 +717,7 @@ rl_ding ()\n static int enabled_meta = 0;\t/* flag indicating we enabled meta mode */\n \n void\n-_rl_enable_meta_key ()\n+_rl_enable_meta_key (void)\n {\n #if !defined (__DJGPP__)\n   if (term_has_meta && _rl_term_mm)\n@@ -741,7 +729,7 @@ _rl_enable_meta_key ()\n }\n \n void\n-_rl_disable_meta_key ()\n+_rl_disable_meta_key (void)\n {\n #if !defined (__DJGPP__)\n   if (term_has_meta && _rl_term_mo && enabled_meta)\n@@ -753,8 +741,7 @@ _rl_disable_meta_key ()\n }\n \n void\n-_rl_control_keypad (on)\n-     int on;\n+_rl_control_keypad (int on)\n {\n #if !defined (__DJGPP__)\n   if (on && _rl_term_ks)\n@@ -775,8 +762,7 @@ _rl_control_keypad (on)\n    cursor.  Overwrite mode gets a very visible cursor.  Only does\n    anything if we have both capabilities. */\n void\n-_rl_set_cursor (im, force)\n-     int im, force;\n+_rl_set_cursor (int im, int force)\n {\n #ifndef __MSDOS__\n   if (_rl_term_ve && _rl_term_vs)"
    },
    {
      "sha": "cddaeebd2d7832d81c292146f26a751ea3aae518",
      "filename": "readline/text.c",
      "status": "modified",
      "additions": 192,
      "deletions": 127,
      "changes": 319,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/text.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/text.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/text.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* text.c -- text handling commands for readline. */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -83,8 +83,7 @@ int _rl_optimize_typeahead = 1;\t/* rl_insert tries to read typeahead */\n    way that you should do insertion.  _rl_insert_char () calls this\n    function.  Returns the number of characters inserted. */\n int\n-rl_insert_text (string)\n-     const char *string;\n+rl_insert_text (const char *string)\n {\n   register int i, l;\n \n@@ -121,8 +120,7 @@ rl_insert_text (string)\n /* Delete the string between FROM and TO.  FROM is inclusive, TO is not.\n    Returns the number of characters deleted. */\n int\n-rl_delete_text (from, to)\n-     int from, to;\n+rl_delete_text (int from, int to)\n {\n   register char *text;\n   register int diff, i;\n@@ -172,8 +170,7 @@ rl_delete_text (from, to)\n \t} while (0)\n \n void\n-_rl_fix_point (fix_mark_too)\n-     int fix_mark_too;\n+_rl_fix_point (int fix_mark_too)\n {\n   _RL_FIX_POINT (rl_point);\n   if (fix_mark_too)\n@@ -185,9 +182,7 @@ _rl_fix_point (fix_mark_too)\n    TEXT.  The operation is undoable.  To replace the entire line in an\n    undoable mode, use _rl_replace_text(text, 0, rl_end); */\n int\n-_rl_replace_text (text, start, end)\n-     const char *text;\n-     int start, end;\n+_rl_replace_text (const char *text, int start, int end)\n {\n   int n;\n \n@@ -206,9 +201,7 @@ _rl_replace_text (text, start, end)\n /* Replace the current line buffer contents with TEXT.  If CLEAR_UNDO is\n    non-zero, we free the current undo list. */\n void\n-rl_replace_line (text, clear_undo)\n-     const char *text;\n-     int clear_undo;\n+rl_replace_line (const char *text, int clear_undo)\n {\n   int len;\n \n@@ -259,8 +252,7 @@ rl_replace_line (text, clear_undo)\n \n /* Move forward COUNT bytes. */\n int\n-rl_forward_byte (count, key)\n-     int count, key;\n+rl_forward_byte (int count, int key)\n {\n   if (count < 0)\n     return (rl_backward_byte (-count, key));\n@@ -292,8 +284,7 @@ rl_forward_byte (count, key)\n }\n \n int\n-_rl_forward_char_internal (count)\n-     int count;\n+_rl_forward_char_internal (int count)\n {\n   int point;\n \n@@ -306,21 +297,47 @@ _rl_forward_char_internal (count)\n #endif\n \n     if (rl_end < 0)\n-\trl_end = 0;\n+      rl_end = 0;\n #else\n   point = rl_point + count;\n+#endif\n+\n   if (point > rl_end)\n     point = rl_end;\n+  return (point);\n+}\n+\n+int\n+_rl_backward_char_internal (int count)\n+{\n+  int point;\n+\n+  point = rl_point;\n+#if defined (HANDLE_MULTIBYTE)\n+  if (count > 0)\n+    {\n+      while (count > 0 && point > 0)\n+\t{\n+\t  point = _rl_find_prev_mbchar (rl_line_buffer, point, MB_FIND_NONZERO);\n+\t  count--;\n+\t}\n+      if (count > 0)\n+        return 0;\t/* XXX - rl_ding() here? */\n+    }\n+#else\n+  if (count > 0)\n+    point -= count;\n #endif\n \n+  if (point < 0)\n+    point = 0;\n   return (point);\n }\n \n #if defined (HANDLE_MULTIBYTE)\n /* Move forward COUNT characters. */\n int\n-rl_forward_char (count, key)\n-     int count, key;\n+rl_forward_char (int count, int key)\n {\n   int point;\n \n@@ -350,25 +367,22 @@ rl_forward_char (count, key)\n }\n #else /* !HANDLE_MULTIBYTE */\n int\n-rl_forward_char (count, key)\n-     int count, key;\n+rl_forward_char (int count, int key)\n {\n   return (rl_forward_byte (count, key));\n }\n #endif /* !HANDLE_MULTIBYTE */\n   \n /* Backwards compatibility. */\n int\n-rl_forward (count, key)\n-     int count, key;\n+rl_forward (int count, int key)\n {\n   return (rl_forward_char (count, key));\n }\n \n /* Move backward COUNT bytes. */\n int\n-rl_backward_byte (count, key)\n-     int count, key;\n+rl_backward_byte (int count, int key)\n {\n   if (count < 0)\n     return (rl_forward_byte (-count, key));\n@@ -393,8 +407,7 @@ rl_backward_byte (count, key)\n #if defined (HANDLE_MULTIBYTE)\n /* Move backward COUNT characters. */\n int\n-rl_backward_char (count, key)\n-     int count, key;\n+rl_backward_char (int count, int key)\n {\n   int point;\n \n@@ -426,43 +439,38 @@ rl_backward_char (count, key)\n }\n #else\n int\n-rl_backward_char (count, key)\n-     int count, key;\n+rl_backward_char (int count, int key)\n {\n   return (rl_backward_byte (count, key));\n }\n #endif\n \n /* Backwards compatibility. */\n int\n-rl_backward (count, key)\n-     int count, key;\n+rl_backward (int count, int key)\n {\n   return (rl_backward_char (count, key));\n }\n \n /* Move to the beginning of the line. */\n int\n-rl_beg_of_line (count, key)\n-     int count, key;\n+rl_beg_of_line (int count, int key)\n {\n   rl_point = 0;\n   return 0;\n }\n \n /* Move to the end of the line. */\n int\n-rl_end_of_line (count, key)\n-     int count, key;\n+rl_end_of_line (int count, int key)\n {\n   rl_point = rl_end;\n   return 0;\n }\n \n /* Move forward a word.  We do what Emacs does.  Handles multibyte chars. */\n int\n-rl_forward_word (count, key)\n-     int count, key;\n+rl_forward_word (int count, int key)\n {\n   int c;\n \n@@ -510,8 +518,7 @@ rl_forward_word (count, key)\n \n /* Move backward a word.  We do what Emacs does.  Handles multibyte chars. */\n int\n-rl_backward_word (count, key)\n-     int count, key;\n+rl_backward_word (int count, int key)\n {\n   int c, p;\n \n@@ -560,8 +567,7 @@ rl_backward_word (count, key)\n \n /* Clear the current line.  Numeric argument to C-l does this. */\n int\n-rl_refresh_line (ignore1, ignore2)\n-     int ignore1, ignore2;\n+rl_refresh_line (int ignore1, int ignore2)\n {\n   int curr_line;\n \n@@ -582,8 +588,7 @@ rl_refresh_line (ignore1, ignore2)\n    the prompt and the current input line.  Given a numeric arg, redraw only\n    the current line. */\n int\n-rl_clear_screen (count, key)\n-     int count, key;\n+rl_clear_screen (int count, int key)\n {\n   if (rl_explicit_arg)\n     {\n@@ -599,8 +604,25 @@ rl_clear_screen (count, key)\n }\n \n int\n-rl_skip_csi_sequence (count, key)\n-     int count, key;\n+rl_previous_screen_line (int count, int key)\n+{\n+  int c;\n+\n+  c = _rl_term_autowrap ? _rl_screenwidth : (_rl_screenwidth + 1);\n+  return (rl_backward_char (c, key));\n+}\n+\n+int\n+rl_next_screen_line (int count, int key)\n+{\n+  int c;\n+\n+  c = _rl_term_autowrap ? _rl_screenwidth : (_rl_screenwidth + 1);\n+  return (rl_forward_char (c, key));\n+}\n+\n+int\n+rl_skip_csi_sequence (int count, int key)\n {\n   int ch;\n \n@@ -614,8 +636,7 @@ rl_skip_csi_sequence (count, key)\n }\n \n int\n-rl_arrow_keys (count, c)\n-     int count, c;\n+rl_arrow_keys (int count, int key)\n {\n   int ch;\n \n@@ -672,8 +693,7 @@ static mbstate_t ps = {0};\n    If C introduces a multibyte sequence, we read the whole sequence and\n    then insert the multibyte char into the line buffer. */\n int\n-_rl_insert_char (count, c)\n-     int count, c;\n+_rl_insert_char (int count, int c)\n {\n   register int i;\n   char *string;\n@@ -695,6 +715,12 @@ _rl_insert_char (count, c)\n       incoming[1] = '\\0';\n       incoming_length = 1;\n     }\n+  else if (_rl_utf8locale && (c & 0x80) == 0)\n+    {\n+      incoming[0] = c;\n+      incoming[1] = '\\0';\n+      incoming_length = 1;\n+    }\n   else\n     {\n       wchar_t wc;\n@@ -739,6 +765,12 @@ _rl_insert_char (count, c)\n \t     effect of mbstate is undefined. */\n \t  memset (&ps, 0, sizeof (mbstate_t));\n \t}\n+      else if (ret == 1)\n+\t{\n+\t  incoming[0] = pending_bytes[0];\n+\t  incoming[incoming_length = 1] = '\\0';\n+\t  pending_bytes_length = 0;\n+\t}\n       else\n \t{\n \t  /* We successfully read a single multibyte character. */\n@@ -761,8 +793,13 @@ _rl_insert_char (count, c)\n       i = 0;\n       while (i < string_size)\n \t{\n-\t  strncpy (string + i, incoming, incoming_length);\n-\t  i += incoming_length;\n+\t  if (incoming_length == 1)\n+\t    string[i++] = *incoming;\n+\t  else\n+\t    {\n+\t      strncpy (string + i, incoming, incoming_length);\n+\t      i += incoming_length;\n+\t    }\n \t}\n       incoming_length = 0;\n       stored_count = 0;\n@@ -790,8 +827,13 @@ _rl_insert_char (count, c)\n       i = 0;\n       while (i < string_size)\n \t{\n-\t  strncpy (string + i, incoming, incoming_length);\n-\t  i += incoming_length;\n+\t  if (incoming_length == 1)\n+\t    string[i++] = *incoming;\n+\t  else\n+\t    {\n+\t      strncpy (string + i, incoming, incoming_length);\n+\t      i += incoming_length;\n+\t    }\n \t}\n \n       while (count)\n@@ -857,8 +899,7 @@ _rl_insert_char (count, c)\n    If C introduces a multibyte character sequence, read the entire sequence\n    before starting the overwrite loop. */\n int\n-_rl_overwrite_char (count, c)\n-     int count, c;\n+_rl_overwrite_char (int count, int c)\n {\n   int i;\n #if defined (HANDLE_MULTIBYTE)\n@@ -891,8 +932,7 @@ _rl_overwrite_char (count, c)\n }\n \n int\n-rl_insert (count, c)\n-     int count, c;\n+rl_insert (int count, int c)\n {\n   int r, n, x;\n \n@@ -902,6 +942,7 @@ rl_insert (count, c)\n   x = 0;\n   n = (unsigned short)-2;\n   while (_rl_optimize_typeahead &&\n+\t rl_num_chars_to_read == 0 &&\n \t (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n \t _rl_pushed_input_available () == 0 &&\n \t _rl_input_queued (0) &&\n@@ -941,8 +982,7 @@ rl_insert (count, c)\n \n /* Insert the next typed character verbatim. */\n static int\n-_rl_insert_next (count)\n-     int count;\n+_rl_insert_next (int count)\n {\n   int c;\n \n@@ -966,24 +1006,37 @@ _rl_insert_next (count)\n \n #if defined (READLINE_CALLBACKS)\n static int\n-_rl_insert_next_callback (data)\n-     _rl_callback_generic_arg *data;\n+_rl_insert_next_callback (_rl_callback_generic_arg *data)\n {\n-  int count;\n+  int count, r;\n \n   count = data->count;\n+  r = 0;\n+\n+  if (count < 0)\n+    {\n+      data->count++;\n+      r = _rl_insert_next (1);\n+      _rl_want_redisplay = 1;\n+      /* If we should keep going, leave the callback function installed */\n+      if (data->count < 0 && r == 0)\n+\treturn r;\n+      count = 0;\t/* data->count == 0 || r != 0; force break below */\n+    }\n \n   /* Deregister function, let rl_callback_read_char deallocate data */\n   _rl_callback_func = 0;\n   _rl_want_redisplay = 1;\n- \n+\n+  if (count == 0)\n+    return r;\n+\n   return _rl_insert_next (count);\n }\n #endif\n   \n int\n-rl_quoted_insert (count, key)\n-     int count, key;\n+rl_quoted_insert (int count, int key)\n {\n   /* Let's see...should the callback interface futz with signal handling? */\n #if defined (HANDLE_SIGNALS)\n@@ -999,14 +1052,24 @@ rl_quoted_insert (count, key)\n       return (0);\n     }\n #endif\n-      \n+\n+  /* A negative count means to quote the next -COUNT characters. */\n+  if (count < 0)\n+    {\n+      int r;\n+\n+      do\n+\tr = _rl_insert_next (1);\n+      while (r == 0 && ++count < 0);\n+      return r;\n+    }\n+\n   return _rl_insert_next (count);\n }\n \n /* Insert a tab character. */\n int\n-rl_tab_insert (count, key)\n-     int count, key;\n+rl_tab_insert (int count, int key)\n {\n   return (_rl_insert_char (count, '\\t'));\n }\n@@ -1015,8 +1078,7 @@ rl_tab_insert (count, key)\n    KEY is the key that invoked this command.  I guess it could have\n    meaning in the future. */\n int\n-rl_newline (count, key)\n-     int count, key;\n+rl_newline (int count, int key)\n {\n   rl_done = 1;\n \n@@ -1049,8 +1111,7 @@ rl_newline (count, key)\n    is just a stub, you bind keys to it and the code in _rl_dispatch ()\n    is special cased. */\n int\n-rl_do_lowercase_version (ignore1, ignore2)\n-     int ignore1, ignore2;\n+rl_do_lowercase_version (int ignore1, int ignore2)\n {\n   return 0;\n }\n@@ -1059,8 +1120,7 @@ rl_do_lowercase_version (ignore1, ignore2)\n    rubout in overwrite mode has one oddity:  it replaces a control\n    character that's displayed as two characters (^X) with two spaces. */\n int\n-_rl_overwrite_rubout (count, key)\n-     int count, key;\n+_rl_overwrite_rubout (int count, int key)\n {\n   int opoint;\n   int i, l;\n@@ -1102,8 +1162,7 @@ _rl_overwrite_rubout (count, key)\n   \n /* Rubout the character behind point. */\n int\n-rl_rubout (count, key)\n-     int count, key;\n+rl_rubout (int count, int key)\n {\n   if (count < 0)\n     return (rl_delete (-count, key));\n@@ -1121,8 +1180,7 @@ rl_rubout (count, key)\n }\n \n int\n-_rl_rubout_char (count, key)\n-     int count, key;\n+_rl_rubout_char (int count, int key)\n {\n   int orig_point;\n   unsigned char c;\n@@ -1167,8 +1225,7 @@ _rl_rubout_char (count, key)\n /* Delete the character under the cursor.  Given a numeric argument,\n    kill that many characters instead. */\n int\n-rl_delete (count, key)\n-     int count, key;\n+rl_delete (int count, int key)\n {\n   int xpoint;\n \n@@ -1205,8 +1262,7 @@ rl_delete (count, key)\n    behind the cursor is deleted.  COUNT is obeyed and may be used\n    to delete forward or backward that many characters. */      \n int\n-rl_rubout_or_delete (count, key)\n-     int count, key;\n+rl_rubout_or_delete (int count, int key)\n {\n   if (rl_end != 0 && rl_point == rl_end)\n     return (_rl_rubout_char (count, key));\n@@ -1216,8 +1272,7 @@ rl_rubout_or_delete (count, key)\n \n /* Delete all spaces and tabs around point. */\n int\n-rl_delete_horizontal_space (count, ignore)\n-     int count, ignore;\n+rl_delete_horizontal_space (int count, int ignore)\n {\n   int start;\n \n@@ -1245,8 +1300,7 @@ rl_delete_horizontal_space (count, ignore)\n    is caught before this is invoked, so this really does the same thing as\n    delete-char-or-list-or-eof, as long as it's bound to the eof character. */\n int\n-rl_delete_or_show_completions (count, key)\n-     int count, key;\n+rl_delete_or_show_completions (int count, int key)\n {\n   if (rl_end != 0 && rl_point == rl_end)\n     return (rl_possible_completions (count, key));\n@@ -1261,8 +1315,7 @@ rl_delete_or_show_completions (count, key)\n /* Turn the current line into a comment in shell history.\n    A K*rn shell style function. */\n int\n-rl_insert_comment (count, key)\n-     int count, key;\n+rl_insert_comment (int count, int key)\n {\n   char *rl_comment_text;\n   int rl_comment_len;\n@@ -1300,24 +1353,21 @@ rl_insert_comment (count, key)\n \n /* Uppercase the word at point. */\n int\n-rl_upcase_word (count, key)\n-     int count, key;\n+rl_upcase_word (int count, int key)\n {\n   return (rl_change_case (count, UpCase));\n }\n \n /* Lowercase the word at point. */\n int\n-rl_downcase_word (count, key)\n-     int count, key;\n+rl_downcase_word (int count, int key)\n {\n   return (rl_change_case (count, DownCase));\n }\n \n /* Upcase the first letter, downcase the rest. */\n int\n-rl_capitalize_word (count, key)\n-     int count, key;\n+rl_capitalize_word (int count, int key)\n {\n  return (rl_change_case (count, CapCase));\n }\n@@ -1328,11 +1378,11 @@ rl_capitalize_word (count, key)\n    If a negative argument is given, leave point where it started,\n    otherwise, leave it where it moves to. */\n static int\n-rl_change_case (count, op)\n-     int count, op;\n+rl_change_case (int count, int op)\n {\n   int start, next, end;\n-  int inword, c, nc, nop;\n+  int inword, nc, nop;\n+  wchar_t c;\n #if defined (HANDLE_MULTIBYTE)\n   wchar_t wc, nwc;\n   char mb[MB_LEN_MAX+1];\n@@ -1382,7 +1432,10 @@ rl_change_case (count, op)\n \t}\n       else\n \tnop = op;\n-      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii ((unsigned char)c))\n+      /* Can't check isascii here; some languages (e.g, Turkish) have\n+\t multibyte upper and lower case equivalents of single-byte ascii\n+\t characters */\n+      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n \t{\n \t  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);\n \t  rl_line_buffer[start] = nc;\n@@ -1398,11 +1451,35 @@ rl_change_case (count, op)\n \t  nwc = (nop == UpCase) ? _rl_to_wupper (wc) : _rl_to_wlower (wc);\n \t  if  (nwc != wc)\t/*  just skip unchanged characters */\n \t    {\n+\t      char *s, *e;\n \t      mlen = wcrtomb (mb, nwc, &mps);\n \t      if (mlen > 0)\n \t\tmb[mlen] = '\\0';\n-\t      /* Assume the same width */\n-\t      strncpy (rl_line_buffer + start, mb, mlen);\n+\t      /* what to do if m != mlen? adjust below */\n+\t      /* m == length of old char, mlen == length of new char */\n+\t      s = rl_line_buffer + start;\n+\t      e = rl_line_buffer + rl_end;\n+\t      if (m == mlen)\n+\t\tmemcpy (s, mb, mlen);\n+\t      else if (m > mlen)\n+\t\t{\n+\t\t  memcpy (s, mb, mlen);\n+\t\t  memmove (s + mlen, s + m, (e - s) - m);\n+\t\t  next -= m - mlen;\t/* next char changes */\n+\t\t  end -= m - mlen;\t/* end of word changes */\n+\t\t  rl_end -= m - mlen;\t/* end of line changes */\n+\t\t  rl_line_buffer[rl_end] = 0;\n+\t\t}\n+\t      else if (m < mlen)\n+\t\t{\n+\t\t  rl_extend_line_buffer (mlen - m + 1);\n+\t\t  memmove (s + mlen, s + m, (e - s) - m);\n+\t\t  memcpy (s, mb, mlen);\n+\t\t  next += mlen - m;\t/* next char changes */\n+\t\t  end += mlen - m;\t/* end of word changes */\n+\t\t  rl_end += mlen - m;\t/* end of line changes */\n+\t\t  rl_line_buffer[rl_end] = 0;\n+\t\t}\n \t    }\n \t}\n #endif\n@@ -1423,8 +1500,7 @@ rl_change_case (count, op)\n /* Transpose the words at point.  If point is at the end of the line,\n    transpose the two words before point. */\n int\n-rl_transpose_words (count, key)\n-     int count, key;\n+rl_transpose_words (int count, int key)\n {\n   char *word1, *word2;\n   int w1_beg, w1_end, w2_beg, w2_end;\n@@ -1484,8 +1560,7 @@ rl_transpose_words (count, key)\n /* Transpose the characters at point.  If point is at the end of the line,\n    then transpose the characters before point. */\n int\n-rl_transpose_chars (count, key)\n-     int count, key;\n+rl_transpose_chars (int count, int key)\n {\n #if defined (HANDLE_MULTIBYTE)\n   char *dummy;\n@@ -1549,13 +1624,9 @@ rl_transpose_chars (count, key)\n \n int\n #if defined (HANDLE_MULTIBYTE)\n-_rl_char_search_internal (count, dir, smbchar, len)\n-     int count, dir;\n-     char *smbchar;\n-     int len;\n+_rl_char_search_internal (int count, int dir, char *smbchar, int len)\n #else\n-_rl_char_search_internal (count, dir, schar)\n-     int count, dir, schar;\n+_rl_char_search_internal (int count, int dir, int schar)\n #endif\n {\n   int pos, inc;\n@@ -1619,8 +1690,7 @@ _rl_char_search_internal (count, dir, schar)\n    that there are two separate versions of this function. */\n #if defined (HANDLE_MULTIBYTE)\n static int\n-_rl_char_search (count, fdir, bdir)\n-     int count, fdir, bdir;\n+_rl_char_search (int count, int fdir, int bdir)\n {\n   char mbchar[MB_LEN_MAX];\n   int mb_len;\n@@ -1637,8 +1707,7 @@ _rl_char_search (count, fdir, bdir)\n }\n #else /* !HANDLE_MULTIBYTE */\n static int\n-_rl_char_search (count, fdir, bdir)\n-     int count, fdir, bdir;\n+_rl_char_search (int count, int fdir, int bdir)\n {\n   int c;\n \n@@ -1669,8 +1738,7 @@ _rl_char_search_callback (data)\n #endif\n \n int\n-rl_char_search (count, key)\n-     int count, key;\n+rl_char_search (int count, int key)\n {\n #if defined (READLINE_CALLBACKS)\n   if (RL_ISSTATE (RL_STATE_CALLBACK))\n@@ -1687,8 +1755,7 @@ rl_char_search (count, key)\n }\n \n int\n-rl_backward_char_search (count, key)\n-     int count, key;\n+rl_backward_char_search (int count, int key)\n {\n #if defined (READLINE_CALLBACKS)\n   if (RL_ISSTATE (RL_STATE_CALLBACK))\n@@ -1712,10 +1779,9 @@ rl_backward_char_search (count, key)\n \n /* Set the mark at POSITION. */\n int\n-_rl_set_mark_at_pos (position)\n-     int position;\n+_rl_set_mark_at_pos (int position)\n {\n-  if (position > rl_end)\n+  if (position < 0 || position > rl_end)\n     return 1;\n \n   rl_mark = position;\n@@ -1724,23 +1790,22 @@ _rl_set_mark_at_pos (position)\n \n /* A bindable command to set the mark. */\n int\n-rl_set_mark (count, key)\n-     int count, key;\n+rl_set_mark (int count, int key)\n {\n   return (_rl_set_mark_at_pos (rl_explicit_arg ? count : rl_point));\n }\n \n /* Exchange the position of mark and point. */\n int\n-rl_exchange_point_and_mark (count, key)\n-     int count, key;\n+rl_exchange_point_and_mark (int count, int key)\n {\n   if (rl_mark > rl_end)\n     rl_mark = -1;\n \n-  if (rl_mark == -1)\n+  if (rl_mark < 0)\n     {\n       rl_ding ();\n+      rl_mark = 0;\t\t/* like _RL_FIX_POINT */\n       return 1;\n     }\n   else"
    },
    {
      "sha": "9d0f29614b65f28245a2d170f11a6167dfefad35",
      "filename": "readline/tilde.c",
      "status": "modified",
      "additions": 13,
      "deletions": 30,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/tilde.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/tilde.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/tilde.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */\n \n-/* Copyright (C) 1988-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1988-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -125,9 +125,7 @@ static char *glue_prefix_and_suffix PARAMS((char *, const char *, int));\n    the tilde which starts the expansion.  Place the length of the text\n    which identified this tilde starter in LEN, excluding the tilde itself. */\n static int\n-tilde_find_prefix (string, len)\n-     const char *string;\n-     int *len;\n+tilde_find_prefix (const char *string, int *len)\n {\n   register int i, j, string_len;\n   register char **prefixes;\n@@ -160,8 +158,7 @@ tilde_find_prefix (string, len)\n /* Find the end of a tilde expansion in STRING, and return the index of\n    the character which ends the tilde definition.  */\n static int\n-tilde_find_suffix (string)\n-     const char *string;\n+tilde_find_suffix (const char *string)\n {\n   register int i, j, string_len;\n   register char **suffixes;\n@@ -189,8 +186,7 @@ tilde_find_suffix (string)\n \n /* Return a new string which is the result of tilde expanding STRING. */\n char *\n-tilde_expand (string)\n-     const char *string;\n+tilde_expand (const char *string)\n {\n   char *result;\n   int result_size, result_index;\n@@ -267,9 +263,7 @@ tilde_expand (string)\n    non-null, the index of the end of the prefix into FNAME is returned in\n    the location it points to. */\n static char *\n-isolate_tilde_prefix (fname, lenp)\n-     const char *fname;\n-     int *lenp;\n+isolate_tilde_prefix (const char *fname, int *lenp)\n {\n   char *ret;\n   int i;\n@@ -293,9 +287,7 @@ isolate_tilde_prefix (fname, lenp)\n    function.  Right now, it just calls tilde_find_suffix and allocates new\n    memory, but it can be expanded to do different things later. */\n char *\n-tilde_find_word (fname, flags, lenp)\n-     const char *fname;\n-     int flags, *lenp;\n+tilde_find_word (const char *fname, int flags, int *lenp)\n {\n   int x;\n   char *r;\n@@ -323,10 +315,7 @@ tilde_find_word (fname, flags, lenp)\n /* Return a string that is PREFIX concatenated with SUFFIX starting at\n    SUFFIND. */\n static char *\n-glue_prefix_and_suffix (prefix, suffix, suffind)\n-     char *prefix;\n-     const char *suffix;\n-     int suffind;\n+glue_prefix_and_suffix (char *prefix, const char *suffix, int suffind)\n {\n   char *ret;\n   int plen, slen;\n@@ -344,8 +333,7 @@ glue_prefix_and_suffix (prefix, suffix, suffind)\n    tilde.  If there is no expansion, call tilde_expansion_failure_hook.\n    This always returns a newly-allocated string, never static storage. */\n char *\n-tilde_expand_word (filename)\n-     const char *filename;\n+tilde_expand_word (const char *filename)\n {\n   char *dirname, *expansion, *username;\n   int user_len;\n@@ -434,9 +422,7 @@ tilde_expand_word (filename)\n #undef NULL\n #include <stdio.h>\n \n-main (argc, argv)\n-     int argc;\n-     char **argv;\n+main (int argc, char **argv)\n {\n   char *result, line[512];\n   int done = 0;\n@@ -464,11 +450,10 @@ main (argc, argv)\n   exit (0);\n }\n \n-static void memory_error_and_abort ();\n+static void memory_error_and_abort (void);\n \n static void *\n-xmalloc (bytes)\n-     size_t bytes;\n+xmalloc (size_t bytes)\n {\n   void *temp = (char *)malloc (bytes);\n \n@@ -478,9 +463,7 @@ xmalloc (bytes)\n }\n \n static void *\n-xrealloc (pointer, bytes)\n-     void *pointer;\n-     int bytes;\n+xrealloc (void *pointer, int bytes)\n {\n   void *temp;\n \n@@ -496,7 +479,7 @@ xrealloc (pointer, bytes)\n }\n \n static void\n-memory_error_and_abort ()\n+memory_error_and_abort (void)\n {\n   fprintf (stderr, \"readline: out of virtual memory\\n\");\n   abort ();"
    },
    {
      "sha": "ae65d38043a7acff72e94785aa669401696260dd",
      "filename": "readline/undo.c",
      "status": "modified",
      "additions": 40,
      "deletions": 28,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/undo.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/undo.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/undo.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* undo.c - manage list of changes to lines, offering opportunity to undo them */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -51,6 +51,8 @@\n \n extern void _hs_replace_history_data PARAMS((int, histdata_t *, histdata_t *));\n \n+extern HIST_ENTRY *_rl_saved_line_for_history;\n+\n /* Non-zero tells rl_delete_text and rl_insert_text to not add to\n    the undo list. */\n int _rl_doing_an_undo = 0;\n@@ -68,10 +70,7 @@ UNDO_LIST *rl_undo_list = (UNDO_LIST *)NULL;\n /* **************************************************************** */\n \n static UNDO_LIST *\n-alloc_undo_entry (what, start, end, text)\n-     enum undo_code what;\n-     int start, end;\n-     char *text;\n+alloc_undo_entry (enum undo_code what, int start, int end, char *text)\n {\n   UNDO_LIST *temp;\n \n@@ -88,10 +87,7 @@ alloc_undo_entry (what, start, end, text)\n /* Remember how to undo something.  Concatenate some undos if that\n    seems right. */\n void\n-rl_add_undo (what, start, end, text)\n-     enum undo_code what;\n-     int start, end;\n-     char *text;\n+rl_add_undo (enum undo_code what, int start, int end, char *text)\n {\n   UNDO_LIST *temp;\n \n@@ -102,8 +98,7 @@ rl_add_undo (what, start, end, text)\n \n /* Free an UNDO_LIST */\n void\n-_rl_free_undo_list (ul)\n-     UNDO_LIST *ul;\n+_rl_free_undo_list (UNDO_LIST *ul)\n {\n   UNDO_LIST *release;\n \n@@ -121,7 +116,7 @@ _rl_free_undo_list (ul)\n \n /* Free the existing undo list. */\n void\n-rl_free_undo_list ()\n+rl_free_undo_list (void)\n {\n   UNDO_LIST *release, *orig_list;\n \n@@ -132,8 +127,7 @@ rl_free_undo_list ()\n }\n \n UNDO_LIST *\n-_rl_copy_undo_entry (entry)\n-     UNDO_LIST *entry;\n+_rl_copy_undo_entry (UNDO_LIST *entry)\n {\n   UNDO_LIST *new;\n \n@@ -143,8 +137,7 @@ _rl_copy_undo_entry (entry)\n }\n \n UNDO_LIST *\n-_rl_copy_undo_list (head)\n-     UNDO_LIST *head;\n+_rl_copy_undo_list (UNDO_LIST *head)\n {\n   UNDO_LIST *list, *new, *roving, *c;\n \n@@ -173,9 +166,9 @@ _rl_copy_undo_list (head)\n /* Undo the next thing in the list.  Return 0 if there\n    is nothing to undo, or non-zero if there was. */\n int\n-rl_do_undo ()\n+rl_do_undo (void)\n {\n-  UNDO_LIST *release;\n+  UNDO_LIST *release, *search;\n   int waiting_for_begin, start, end;\n   HIST_ENTRY *cur, *temp;\n \n@@ -232,6 +225,7 @@ rl_do_undo ()\n \n       release = rl_undo_list;\n       rl_undo_list = rl_undo_list->next;\n+      release->next = 0;\t/* XXX */\n \n       /* If we are editing a history entry, make sure the change is replicated\n \t in the history entry's line */\n@@ -244,8 +238,30 @@ rl_do_undo ()\n \t  xfree (temp);\n \t}\n \n+      /* Make sure there aren't any history entries with that undo list */\n       _hs_replace_history_data (-1, (histdata_t *)release, (histdata_t *)rl_undo_list);\n \n+      /* And make sure this list isn't anywhere in the saved line for history */\n+      if (_rl_saved_line_for_history && _rl_saved_line_for_history->data)\n+\t{\n+\t  /* Brute force; no finesse here */\n+\t  search = (UNDO_LIST *)_rl_saved_line_for_history->data;\n+\t  if (search == release)\n+\t    _rl_saved_line_for_history->data = rl_undo_list;\n+\t  else\n+\t    {\n+\t      while (search->next)\n+\t\t{\n+\t\t  if (search->next == release)\n+\t\t    {\n+\t\t      search->next = rl_undo_list;\n+\t\t      break;\n+\t\t    }\n+\t\t  search = search->next;\n+\t\t}\n+\t    }\n+\t}\n+\n       xfree (release);\n     }\n   while (waiting_for_begin);\n@@ -255,8 +271,7 @@ rl_do_undo ()\n #undef TRANS\n \n int\n-_rl_fix_last_undo_of_type (type, start, end)\n-     int type, start, end;\n+_rl_fix_last_undo_of_type (int type, int start, int end)\n {\n   UNDO_LIST *rl;\n \n@@ -274,7 +289,7 @@ _rl_fix_last_undo_of_type (type, start, end)\n \n /* Begin a group.  Subsequent undos are undone as an atomic operation. */\n int\n-rl_begin_undo_group ()\n+rl_begin_undo_group (void)\n {\n   rl_add_undo (UNDO_BEGIN, 0, 0, 0);\n   _rl_undo_group_level++;\n@@ -283,7 +298,7 @@ rl_begin_undo_group ()\n \n /* End an undo group started with rl_begin_undo_group (). */\n int\n-rl_end_undo_group ()\n+rl_end_undo_group (void)\n {\n   rl_add_undo (UNDO_END, 0, 0, 0);\n   _rl_undo_group_level--;\n@@ -292,8 +307,7 @@ rl_end_undo_group ()\n \n /* Save an undo entry for the text from START to END. */\n int\n-rl_modifying (start, end)\n-     int start, end;\n+rl_modifying (int start, int end)\n {\n   if (start > end)\n     {\n@@ -313,8 +327,7 @@ rl_modifying (start, end)\n \n /* Revert the current line to its previous state. */\n int\n-rl_revert_line (count, key)\n-     int count, key;\n+rl_revert_line (int count, int key)\n {\n   if (rl_undo_list == 0)\n     rl_ding ();\n@@ -333,8 +346,7 @@ rl_revert_line (count, key)\n \n /* Do some undoing of things that were done. */\n int\n-rl_undo_command (count, key)\n-     int count, key;\n+rl_undo_command (int count, int key)\n {\n   if (count < 0)\n     return 0;\t/* Nothing to do. */"
    },
    {
      "sha": "e8ae9d7f56de685cae109c247b4864904017085c",
      "filename": "readline/util.c",
      "status": "modified",
      "additions": 23,
      "deletions": 42,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/util.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* util.c -- readline utility functions */\n \n-/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -70,8 +70,7 @@ int _rl_allow_pathname_alphabetic_chars = 0;\n static const char * const pathname_alphabetic_chars = \"/-_=~.#$\";\n \n int\n-rl_alphabetic (c)\n-     int c;\n+rl_alphabetic (int c)\n {\n   if (ALPHABETIC (c))\n     return (1);\n@@ -97,7 +96,7 @@ _rl_walphabetic (wchar_t wc)\n \n /* How to abort things. */\n int\n-_rl_abort_internal ()\n+_rl_abort_internal (void)\n {\n   rl_ding ();\n   rl_clear_message ();\n@@ -117,22 +116,19 @@ _rl_abort_internal ()\n }\n \n int\n-rl_abort (count, key)\n-     int count, key;\n+rl_abort (int count, int key)\n {\n   return (_rl_abort_internal ());\n }\n \n int\n-_rl_null_function (count, key)\n-     int count, key;\n+_rl_null_function (int count, int key)\n {\n   return 0;\n }\n \n int\n-rl_tty_status (count, key)\n-     int count, key;\n+rl_tty_status (int count, int key)\n {\n #if defined (TIOCSTAT)\n   ioctl (1, TIOCSTAT, (char *)0);\n@@ -146,8 +142,7 @@ rl_tty_status (count, key)\n /* Return a copy of the string between FROM and TO.\n    FROM is inclusive, TO is not. */\n char *\n-rl_copy_text (from, to)\n-     int from, to;\n+rl_copy_text (int from, int to)\n {\n   register int length;\n   char *copy;\n@@ -166,8 +161,7 @@ rl_copy_text (from, to)\n /* Increase the size of RL_LINE_BUFFER until it has enough space to hold\n    LEN characters. */\n void\n-rl_extend_line_buffer (len)\n-     int len;\n+rl_extend_line_buffer (int len)\n {\n   while (len >= rl_line_buffer_len)\n     {\n@@ -181,8 +175,7 @@ rl_extend_line_buffer (len)\n \n /* A function for simple tilde expansion. */\n int\n-rl_tilde_expand (ignore, key)\n-     int ignore, key;\n+rl_tilde_expand (int ignore, int key)\n {\n   register int start, end;\n   char *homedir, *temp;\n@@ -200,7 +193,7 @@ rl_tilde_expand (ignore, key)\n     }\n   else if (start >= 0 && rl_line_buffer[start] != '~')\n     {\n-      for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)\n+      for (; start >= 0 && !whitespace (rl_line_buffer[start]); start--)\n         ;\n       start++;\n     }\n@@ -324,8 +317,7 @@ _rl_errmsg (format, arg1, arg2)\n /* Determine if s2 occurs in s1.  If so, return a pointer to the\n    match in s1.  The compare is case insensitive. */\n char *\n-_rl_strindex (s1, s2)\n-     register const char *s1, *s2;\n+_rl_strindex (const char *s1, const char *s2)\n {\n   register int i, l, len;\n \n@@ -339,8 +331,7 @@ _rl_strindex (s1, s2)\n /* Find the first occurrence in STRING1 of any character from STRING2.\n    Return a pointer to the character in STRING1. */\n char *\n-_rl_strpbrk (string1, string2)\n-     const char *string1, *string2;\n+_rl_strpbrk (const char *string1, const char *string2)\n {\n   register const char *scan;\n #if defined (HANDLE_MULTIBYTE)\n@@ -374,10 +365,7 @@ _rl_strpbrk (string1, string2)\n /* Compare at most COUNT characters from string1 to string2.  Case\n    doesn't matter (strncasecmp). */\n int\n-_rl_strnicmp (string1, string2, count)\n-     const char *string1;\n-     const char *string2;\n-     int count;\n+_rl_strnicmp (const char *string1, const char *string2, int count)\n {\n   register const char *s1;\n   register const char *s2;\n@@ -404,9 +392,7 @@ _rl_strnicmp (string1, string2, count)\n \n /* strcmp (), but caseless (strcasecmp). */\n int\n-_rl_stricmp (string1, string2)\n-     const char *string1;\n-     const char *string2;\n+_rl_stricmp (const char *string1, const char *string2)\n {\n   register const char *s1;\n   register const char *s2;\n@@ -431,8 +417,7 @@ _rl_stricmp (string1, string2)\n \n /* Stupid comparison routine for qsort () ing strings. */\n int\n-_rl_qsort_string_compare (s1, s2)\n-  char **s1, **s2;\n+_rl_qsort_string_compare (char **s1, char **s2)\n {\n #if defined (HAVE_STRCOLL)\n   return (strcoll (*s1, *s2));\n@@ -448,7 +433,7 @@ _rl_qsort_string_compare (s1, s2)\n }\n \n /* Function equivalents for the macros defined in chardefs.h. */\n-#define FUNCTION_FOR_MACRO(f)\tint (f) (c) int c; { return f (c); }\n+#define FUNCTION_FOR_MACRO(f)\tint (f) (int c) { return f (c); }\n \n FUNCTION_FOR_MACRO (_rl_digit_p)\n FUNCTION_FOR_MACRO (_rl_digit_value)\n@@ -461,8 +446,7 @@ FUNCTION_FOR_MACRO (_rl_uppercase_p)\n /* A convenience function, to force memory deallocation to be performed\n    by readline.  DLLs on Windows apparently require this. */\n void\n-rl_free (mem)\n-     void *mem;\n+rl_free (void *mem)\n {\n   if (mem)\n     free (mem);\n@@ -472,8 +456,7 @@ rl_free (mem)\n    all `public' readline header files. */\n #undef _rl_savestring\n char *\n-_rl_savestring (s)\n-     const char *s;\n+_rl_savestring (const char *s)\n {\n   return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));\n }\n@@ -512,7 +495,7 @@ _rl_trace (va_alist)\n }\n \n int\n-_rl_tropen ()\n+_rl_tropen (void)\n {\n   char fnbuf[128], *x;\n \n@@ -521,7 +504,7 @@ _rl_tropen ()\n #if defined (_WIN32) && !defined (__CYGWIN__)\n   /* Windows doesn't have /var/tmp, so open the trace file in the\n      user's temporary directory instead.  */\n-  sprintf (fnbuf, \"%s/rltrace.%ld\",\n+  snprintf (fnbuf, sizeof (fnbuf), \"%s/rltrace.%ld\",\n \t   (sh_get_env_value (\"TEMP\")\n \t    ? sh_get_env_value (\"TEMP\")\n \t    : \".\"),\n@@ -535,7 +518,7 @@ _rl_tropen ()\n }\n \n int\n-_rl_trclose ()\n+_rl_trclose (void)\n {\n   int r;\n \n@@ -545,8 +528,7 @@ _rl_trclose ()\n }\n \n void\n-_rl_settracefp (fp)\n-     FILE *fp;\n+_rl_settracefp (FILE *fp)\n {\n   _rl_tracefp = fp;\n }\n@@ -562,8 +544,7 @@ _rl_settracefp (fp)\n \n /* Report STRING to the audit system. */\n void\n-_rl_audit_tty (string)\n-     char *string;\n+_rl_audit_tty (char *string)\n {\n   struct audit_message req;\n   struct sockaddr_nl addr;"
    },
    {
      "sha": "045258bd83b6bdc42a68a322fd1b81c2b6086b99",
      "filename": "readline/vi_keymap.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/vi_keymap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/vi_keymap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/vi_keymap.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* vi_keymap.c -- the keymap for vi_mode in readline (). */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      "
    },
    {
      "sha": "836371c95fff755e5bb9fc2faf8998310ef286ae",
      "filename": "readline/vi_mode.c",
      "status": "modified",
      "additions": 291,
      "deletions": 253,
      "changes": 544,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/vi_mode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/vi_mode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/vi_mode.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,7 +1,7 @@\n /* vi_mode.c -- A vi emulation mode for Bash.\n    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */\n \n-/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2018 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -63,6 +63,21 @@\n #define member(c, s) ((c) ? (char *)strchr ((s), (c)) != (char *)NULL : 0)\n #endif\n \n+/* Increment START to the next character in RL_LINE_BUFFER, handling multibyte chars */\n+#if defined (HANDLE_MULTIBYTE)\n+#define INCREMENT_POS(start) \\\n+  do { \\\n+\tif (MB_CUR_MAX == 1 || rl_byte_oriented) \\\n+\t  start++; \\\n+\telse \\\n+\t  start = _rl_find_next_mbchar (rl_line_buffer, start, 1, MB_FIND_ANY); \\\n+  } while (0)\n+#else /* !HANDLE_MULTIBYTE */\n+#define INCREMENT_POS(start)    (start)++\n+#endif /* !HANDLE_MULTIBYTE */\n+\n+/* This is global so other parts of the code can check whether the last\n+   command was a text modification command. */\n int _rl_vi_last_command = 'i';\t/* default `.' puts you in insert mode */\n \n _rl_vimotion_cxt *_rl_vimvcxt = 0;\n@@ -99,7 +114,7 @@ static int _rl_vi_last_search_mblen;\n #else\n static int _rl_vi_last_search_char;\n #endif\n-static int _rl_vi_last_replacement;\n+static char _rl_vi_last_replacement[MB_LEN_MAX+1];\t/* reserve for trailing NULL */\n \n static int _rl_vi_last_key_before_insert;\n \n@@ -116,14 +131,17 @@ static void _rl_vi_save_insert PARAMS((UNDO_LIST *));\n \n static void vi_save_insert_buffer PARAMS ((int, int));\n \n-static void _rl_vi_backup PARAMS((void));\n+static inline void _rl_vi_backup PARAMS((void));\n \n static int _rl_vi_arg_dispatch PARAMS((int));\n static int rl_digit_loop1 PARAMS((void));\n \n static int _rl_vi_set_mark PARAMS((void));\n static int _rl_vi_goto_mark PARAMS((void));\n \n+static inline int _rl_vi_advance_point PARAMS((void));\n+static inline int _rl_vi_backup_point PARAMS((void));\n+\n static void _rl_vi_append_forward PARAMS((int));\n \n static int _rl_vi_callback_getchar PARAMS((char *, int));\n@@ -146,7 +164,7 @@ static int vi_yank_dispatch PARAMS((_rl_vimotion_cxt *));\n static int vidomove_dispatch PARAMS((_rl_vimotion_cxt *));\n \n void\n-_rl_vi_initialize_line ()\n+_rl_vi_initialize_line (void)\n {\n   register int i, n;\n \n@@ -158,7 +176,7 @@ _rl_vi_initialize_line ()\n }\n \n void\n-_rl_vi_reset_last ()\n+_rl_vi_reset_last (void)\n {\n   _rl_vi_last_command = 'i';\n   _rl_vi_last_repeat = 1;\n@@ -167,8 +185,7 @@ _rl_vi_reset_last ()\n }\n \n void\n-_rl_vi_set_last (key, repeat, sign)\n-     int key, repeat, sign;\n+_rl_vi_set_last (int key, int repeat, int sign)\n {\n   _rl_vi_last_command = key;\n   _rl_vi_last_repeat = repeat;\n@@ -178,31 +195,28 @@ _rl_vi_set_last (key, repeat, sign)\n /* A convenience function that calls _rl_vi_set_last to save the last command\n    information and enters insertion mode. */\n void\n-rl_vi_start_inserting (key, repeat, sign)\n-     int key, repeat, sign;\n+rl_vi_start_inserting (int key, int repeat, int sign)\n {\n   _rl_vi_set_last (key, repeat, sign);\n+  rl_begin_undo_group ();\t\t/* ensure inserts aren't concatenated */\n   rl_vi_insertion_mode (1, key);\n }\n \n /* Is the command C a VI mode text modification command? */\n int\n-_rl_vi_textmod_command (c)\n-     int c;\n+_rl_vi_textmod_command (int c)\n {\n   return (member (c, vi_textmod));\n }\n \n int\n-_rl_vi_motion_command (c)\n-     int c;\n+_rl_vi_motion_command (int c)\n {\n   return (member (c, vi_motion));\n }\n \n static void\n-_rl_vi_replace_insert (count)\n-     int count;\n+_rl_vi_replace_insert (int count)\n {\n   int nchars;\n \n@@ -217,8 +231,7 @@ _rl_vi_replace_insert (count)\n }\n \n static void\n-_rl_vi_stuff_insert (count)\n-     int count;\n+_rl_vi_stuff_insert (int count)\n {\n   rl_begin_undo_group ();\n   while (count--)\n@@ -230,8 +243,7 @@ _rl_vi_stuff_insert (count)\n    redo a text modification command.  The default for _rl_vi_last_command\n    puts you back into insert mode. */\n int\n-rl_vi_redo (count, c)\n-     int count, c;\n+rl_vi_redo (int count, int c)\n {\n   int r;\n \n@@ -296,16 +308,14 @@ rl_vi_redo (count, c)\n \n /* A placeholder for further expansion. */\n int\n-rl_vi_undo (count, key)\n-     int count, key;\n+rl_vi_undo (int count, int key)\n {\n   return (rl_undo_command (count, key));\n }\n     \n /* Yank the nth arg from the previous line into this line at point. */\n int\n-rl_vi_yank_arg (count, key)\n-     int count, key;\n+rl_vi_yank_arg (int count, int key)\n {\n   /* Readline thinks that the first word on a line is the 0th, while vi\n      thinks the first word on a line is the 1st.  Compensate. */\n@@ -320,8 +330,7 @@ rl_vi_yank_arg (count, key)\n /* With an argument, move back that many history lines, else move to the\n    beginning of history. */\n int\n-rl_vi_fetch_history (count, c)\n-     int count, c;\n+rl_vi_fetch_history (int count, int c)\n {\n   int wanted;\n \n@@ -345,8 +354,7 @@ rl_vi_fetch_history (count, c)\n \n /* Search again for the last thing searched for. */\n int\n-rl_vi_search_again (count, key)\n-     int count, key;\n+rl_vi_search_again (int count, int key)\n {\n   switch (key)\n     {\n@@ -363,8 +371,7 @@ rl_vi_search_again (count, key)\n \n /* Do a vi style search. */\n int\n-rl_vi_search (count, key)\n-     int count, key;\n+rl_vi_search (int count, int key)\n {\n   switch (key)\n     {\n@@ -387,14 +394,13 @@ rl_vi_search (count, key)\n \n /* Completion, from vi's point of view. */\n int\n-rl_vi_complete (ignore, key)\n-     int ignore, key;\n+rl_vi_complete (int ignore, int key)\n {\n   if ((rl_point < rl_end) && (!whitespace (rl_line_buffer[rl_point])))\n     {\n       if (!whitespace (rl_line_buffer[rl_point + 1]))\n \trl_vi_end_word (1, 'E');\n-      rl_point++;\n+      _rl_vi_advance_point ();\n     }\n \n   if (key == '*')\n@@ -414,8 +420,7 @@ rl_vi_complete (ignore, key)\n \n /* Tilde expansion for vi mode. */\n int\n-rl_vi_tilde_expand (ignore, key)\n-     int ignore, key;\n+rl_vi_tilde_expand (int ignore, int key)\n {\n   rl_tilde_expand (0, key);\n   rl_vi_start_inserting (key, 1, rl_arg_sign);\n@@ -424,8 +429,7 @@ rl_vi_tilde_expand (ignore, key)\n \n /* Previous word in vi mode. */\n int\n-rl_vi_prev_word (count, key)\n-     int count, key;\n+rl_vi_prev_word (int count, int key)\n {\n   if (count < 0)\n     return (rl_vi_next_word (-count, key));\n@@ -446,8 +450,7 @@ rl_vi_prev_word (count, key)\n \n /* Next word in vi mode. */\n int\n-rl_vi_next_word (count, key)\n-     int count, key;\n+rl_vi_next_word (int count, int key)\n {\n   if (count < 0)\n     return (rl_vi_prev_word (-count, key));\n@@ -465,10 +468,72 @@ rl_vi_next_word (count, key)\n   return (0);\n }\n \n+static inline int\n+_rl_vi_advance_point (void)\n+{\n+  int point;\n+\n+  point = rl_point;\n+  if (rl_point < rl_end)\n+#if defined (HANDLE_MULTIBYTE)\n+    {\n+      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n+\trl_point++;\n+      else\n+\t{\n+\t  point = rl_point;\n+\t  rl_point = _rl_forward_char_internal (1);\n+\t  if (point == rl_point || rl_point > rl_end)\n+\t    rl_point = rl_end;\n+\t}\n+    }\n+#else\n+    rl_point++;\n+#endif\n+\n+  return point;\n+}\n+\n+/* Move the cursor back one character. */\n+static inline void\n+_rl_vi_backup (void)\n+{\n+  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n+  else\n+    rl_point--;\n+}\n+\n+/* Move the point back one character, returning the starting value and not\n+   doing anything at the beginning of the line */\n+static inline int\n+_rl_vi_backup_point (void)\n+{\n+  int point;\n+\n+  point = rl_point;\n+  if (rl_point > 0)\n+#if defined (HANDLE_MULTIBYTE)\n+    {\n+      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n+\trl_point--;\n+      else\n+\t{\n+\t  point = rl_point;\n+\t  rl_point = _rl_backward_char_internal (1);\n+\t  if (rl_point < 0)\n+\t    rl_point = 0;\t\t/* XXX - not really necessary */\n+\t}\n+    }\n+#else\n+    rl_point--;\n+#endif\n+  return point;\n+}\n+\n /* Move to the end of the ?next? word. */\n int\n-rl_vi_end_word (count, key)\n-     int count, key;\n+rl_vi_end_word (int count, int key)\n {\n   if (count < 0)\n     {\n@@ -485,25 +550,23 @@ rl_vi_end_word (count, key)\n \n /* Move forward a word the way that 'W' does. */\n int\n-rl_vi_fWord (count, ignore)\n-     int count, ignore;\n+rl_vi_fWord (int count, int ignore)\n {\n   while (count-- && rl_point < (rl_end - 1))\n     {\n       /* Skip until whitespace. */\n       while (!whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n \n       /* Now skip whitespace. */\n       while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n     }\n   return (0);\n }\n \n int\n-rl_vi_bWord (count, ignore)\n-     int count, ignore;\n+rl_vi_bWord (int count, int ignore)\n {\n   while (count-- && rl_point > 0)\n     {\n@@ -514,183 +577,199 @@ rl_vi_bWord (count, ignore)\n \trl_point--;\n \n       while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n-\trl_point--;\n+\t_rl_vi_backup_point ();\n \n       if (rl_point > 0)\n \t{\n-\t  while (--rl_point >= 0 && !whitespace (rl_line_buffer[rl_point]));\n-\t  rl_point++;\n+\t  do\n+\t    _rl_vi_backup_point ();\n+\t  while (rl_point > 0 && !whitespace (rl_line_buffer[rl_point]));\n+\t  if (rl_point > 0)\t/* hit whitespace */\n+\t    rl_point++;\t\t\n+\n+\t  if (rl_point < 0)\n+\t    rl_point = 0;\n \t}\n     }\n   return (0);\n }\n \n int\n-rl_vi_eWord (count, ignore)\n-     int count, ignore;\n+rl_vi_eWord (int count, int ignore)\n {\n+  int opoint;\n+\n   while (count-- && rl_point < (rl_end - 1))\n     {\n-      if (!whitespace (rl_line_buffer[rl_point]))\n-\trl_point++;\n+      if (whitespace (rl_line_buffer[rl_point]) == 0)\n+\t_rl_vi_advance_point ();\n \n       /* Move to the next non-whitespace character (to the start of the\n \t next word). */\n       while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n \n       if (rl_point && rl_point < rl_end)\n \t{\n+\t  opoint = rl_point;\n+\n \t  /* Skip whitespace. */\n \t  while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n-\t    rl_point++;\n+\t    opoint = _rl_vi_advance_point ();\t/* XXX - why? */\n \n \t  /* Skip until whitespace. */\n \t  while (rl_point < rl_end && !whitespace (rl_line_buffer[rl_point]))\n-\t    rl_point++;\n+\t    opoint = _rl_vi_advance_point ();\n \n \t  /* Move back to the last character of the word. */\n-\t  rl_point--;\n+\t  rl_point = opoint;\n \t}\n     }\n   return (0);\n }\n \n int\n-rl_vi_fword (count, ignore)\n-     int count, ignore;\n+rl_vi_fword (int count, int ignore)\n {\n+  int opoint;\n+\n   while (count-- && rl_point < (rl_end - 1))\n     {\n       /* Move to white space (really non-identifer). */\n       if (_rl_isident (rl_line_buffer[rl_point]))\n \t{\n \t  while (_rl_isident (rl_line_buffer[rl_point]) && rl_point < rl_end)\n-\t    rl_point++;\n+\t    _rl_vi_advance_point ();\n \t}\n       else /* if (!whitespace (rl_line_buffer[rl_point])) */\n \t{\n \t  while (!_rl_isident (rl_line_buffer[rl_point]) &&\n \t\t !whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n-\t    rl_point++;\n+\t    _rl_vi_advance_point ();\n \t}\n \n+      opoint = rl_point;\n+\n       /* Move past whitespace. */\n       while (whitespace (rl_line_buffer[rl_point]) && rl_point < rl_end)\n-\trl_point++;\n+\topoint = _rl_vi_advance_point ();\n     }\n   return (0);\n }\n \n int\n-rl_vi_bword (count, ignore)\n-     int count, ignore;\n+rl_vi_bword (int count, int ignore)\n {\n+  int opoint;\n+\n   while (count-- && rl_point > 0)\n     {\n-      int last_is_ident;\n+      int prev_is_ident, cur_is_ident;\n \n       /* If we are at the start of a word, move back to whitespace\n \t so we will go back to the start of the previous word. */\n       if (!whitespace (rl_line_buffer[rl_point]) &&\n \t  whitespace (rl_line_buffer[rl_point - 1]))\n-\trl_point--;\n+\tif (--rl_point == 0)\n+\t  break;\n \n       /* If this character and the previous character are `opposite', move\n \t back so we don't get messed up by the rl_point++ down there in\n \t the while loop.  Without this code, words like `l;' screw up the\n \t function. */\n-      last_is_ident = _rl_isident (rl_line_buffer[rl_point - 1]);\n-      if ((_rl_isident (rl_line_buffer[rl_point]) && !last_is_ident) ||\n-\t  (!_rl_isident (rl_line_buffer[rl_point]) && last_is_ident))\n-\trl_point--;\n+      cur_is_ident = _rl_isident (rl_line_buffer[rl_point]);\n+      opoint = _rl_vi_backup_point ();\n+      prev_is_ident = _rl_isident (rl_line_buffer[rl_point]);\n+      if ((cur_is_ident && !prev_is_ident) || (!cur_is_ident && prev_is_ident))\n+\t;\t/* leave point alone, we backed it up one character */\n+      else\n+\trl_point = opoint;\n \n       while (rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n-\trl_point--;\n+\t_rl_vi_backup_point ();\n \n       if (rl_point > 0)\n \t{\n+\t  opoint = rl_point;\n \t  if (_rl_isident (rl_line_buffer[rl_point]))\n-\t    while (--rl_point >= 0 && _rl_isident (rl_line_buffer[rl_point]));\n+\t    do\n+\t      opoint = _rl_vi_backup_point ();\n+\t    while (rl_point > 0 && _rl_isident (rl_line_buffer[rl_point]));\n \t  else\n-\t    while (--rl_point >= 0 && !_rl_isident (rl_line_buffer[rl_point]) &&\n+\t    do\n+\t      opoint = _rl_vi_backup_point ();\n+\t    while (rl_point > 0 && !_rl_isident (rl_line_buffer[rl_point]) &&\n \t\t   !whitespace (rl_line_buffer[rl_point]));\n-\t  rl_point++;\n+\n+\t  if (rl_point > 0)\n+\t    rl_point = opoint;\n+\n+\t  if (rl_point < 0)\n+\t    rl_point = 0;\n \t}\n     }\n   return (0);\n }\n \n int\n-rl_vi_eword (count, ignore)\n-     int count, ignore;\n+rl_vi_eword (int count, int ignore)\n {\n-  while (count-- && rl_point < rl_end - 1)\n+  int opoint;\n+\n+  while (count-- && rl_point < (rl_end - 1))\n     {\n-      if (!whitespace (rl_line_buffer[rl_point]))\n-\trl_point++;\n+      if (whitespace (rl_line_buffer[rl_point]) == 0)\n+\t_rl_vi_advance_point ();\n \n       while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n \n+      opoint = rl_point;\n       if (rl_point < rl_end)\n \t{\n \t  if (_rl_isident (rl_line_buffer[rl_point]))\n-\t    while (++rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));\n+\t    do\n+\t      {\n+\t\topoint = _rl_vi_advance_point ();\n+\t      }\n+\t    while (rl_point < rl_end && _rl_isident (rl_line_buffer[rl_point]));\n \t  else\n-\t    while (++rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])\n+\t    do\n+\t      {\n+\t\topoint = _rl_vi_advance_point ();\n+\t      }\n+\t    while (rl_point < rl_end && !_rl_isident (rl_line_buffer[rl_point])\n \t\t   && !whitespace (rl_line_buffer[rl_point]));\n \t}\n-      rl_point--;\n+      rl_point = opoint;\n     }\n   return (0);\n }\n \n int\n-rl_vi_insert_beg (count, key)\n-     int count, key;\n+rl_vi_insert_beg (int count, int key)\n {\n   rl_beg_of_line (1, key);\n   rl_vi_insert_mode (1, key);\n   return (0);\n }\n \n static void\n-_rl_vi_append_forward (key)\n-     int key;\n+_rl_vi_append_forward (int key)\n {\n-  int point;\n-\n-  if (rl_point < rl_end)\n-    {\n-      if (MB_CUR_MAX == 1 || rl_byte_oriented)\n-\trl_point++;\n-      else\n-\t{\n-\t  point = rl_point;\n-#if 0\n-\t  rl_forward_char (1, key);\n-#else\n-\t  rl_point = _rl_forward_char_internal (1);\n-#endif\n-\t  if (point == rl_point)\n-\t    rl_point = rl_end;\n-\t}\n-    }\n+  _rl_vi_advance_point ();\n }\n \n int\n-rl_vi_append_mode (count, key)\n-     int count, key;\n+rl_vi_append_mode (int count, int key)\n {\n   _rl_vi_append_forward (key);\n   rl_vi_start_inserting (key, 1, rl_arg_sign);\n   return (0);\n }\n \n int\n-rl_vi_append_eol (count, key)\n-     int count, key;\n+rl_vi_append_eol (int count, int key)\n {\n   rl_end_of_line (1, key);\n   rl_vi_append_mode (1, key);\n@@ -699,8 +778,7 @@ rl_vi_append_eol (count, key)\n \n /* What to do in the case of C-d. */\n int\n-rl_vi_eof_maybe (count, c)\n-     int count, c;\n+rl_vi_eof_maybe (int count, int c)\n {\n   return (rl_newline (1, '\\n'));\n }\n@@ -710,8 +788,7 @@ rl_vi_eof_maybe (count, c)\n /* Switching from one mode to the other really just involves\n    switching keymaps. */\n int\n-rl_vi_insertion_mode (count, key)\n-     int count, key;\n+rl_vi_insertion_mode (int count, int key)\n {\n   _rl_keymap = vi_insertion_keymap;\n   _rl_vi_last_key_before_insert = key;\n@@ -721,16 +798,14 @@ rl_vi_insertion_mode (count, key)\n }\n \n int\n-rl_vi_insert_mode (count, key)\n-     int count, key;\n+rl_vi_insert_mode (int count, int key)\n {\n   rl_vi_start_inserting (key, 1, rl_arg_sign);\n   return (0);\n }\n \n static void\n-vi_save_insert_buffer (start, len)\n-     int start, len;\n+vi_save_insert_buffer (int start, int len)\n {\n   /* Same code as _rl_vi_save_insert below */\n   if (len >= vi_insert_buffer_size)\n@@ -743,7 +818,7 @@ vi_save_insert_buffer (start, len)\n }\n \n static void\n-_rl_vi_save_replace ()\n+_rl_vi_save_replace (void)\n {\n   int len, start, end;\n   UNDO_LIST *up;\n@@ -766,8 +841,7 @@ _rl_vi_save_replace ()\n }\n \n static void\n-_rl_vi_save_insert (up)\n-      UNDO_LIST *up;\n+_rl_vi_save_insert (UNDO_LIST *up)\n {\n   int len, start, end;\n \n@@ -786,7 +860,7 @@ _rl_vi_save_insert (up)\n }\n     \n void\n-_rl_vi_done_inserting ()\n+_rl_vi_done_inserting (void)\n {\n   if (_rl_vi_doing_insert)\n     {\n@@ -821,8 +895,7 @@ _rl_vi_done_inserting ()\n }\n \n int\n-rl_vi_movement_mode (count, key)\n-     int count, key;\n+rl_vi_movement_mode (int count, int key)\n {\n   if (rl_point > 0)\n     rl_backward_char (1, key);\n@@ -843,8 +916,7 @@ rl_vi_movement_mode (count, key)\n }\n \n int\n-rl_vi_arg_digit (count, c)\n-     int count, c;\n+rl_vi_arg_digit (int count, int c)\n {\n   if (c == '0' && rl_numeric_arg == 1 && !rl_explicit_arg)\n     return (rl_beg_of_line (1, c));\n@@ -855,8 +927,7 @@ rl_vi_arg_digit (count, c)\n /* Change the case of the next COUNT characters. */\n #if defined (HANDLE_MULTIBYTE)\n static int\n-_rl_vi_change_mbchar_case (count)\n-     int count;\n+_rl_vi_change_mbchar_case (int count)\n {\n   wchar_t wc;\n   char mb[MB_LEN_MAX+1];\n@@ -895,7 +966,7 @@ _rl_vi_change_mbchar_case (count)\n \t  rl_begin_undo_group ();\n \t  rl_vi_delete (1, 0);\n \t  if (rl_point < p)\t/* Did we retreat at EOL? */\n-\t    rl_point++;\t/* XXX - should we advance more than 1 for mbchar? */\n+\t    _rl_vi_advance_point ();\n \t  rl_insert_text (mb);\n \t  rl_end_undo_group ();\n \t  rl_vi_check ();\n@@ -909,8 +980,7 @@ _rl_vi_change_mbchar_case (count)\n #endif\n \n int\n-rl_vi_change_case (count, ignore)\n-     int count, ignore;\n+rl_vi_change_case (int count, int ignore)\n {\n   int c, p;\n \n@@ -956,8 +1026,7 @@ rl_vi_change_case (count, ignore)\n }\n \n int\n-rl_vi_put (count, key)\n-     int count, key;\n+rl_vi_put (int count, int key)\n {\n   if (!_rl_uppercase_p (key) && (rl_point + 1 <= rl_end))\n     rl_point = _rl_find_next_mbchar (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);\n@@ -969,45 +1038,34 @@ rl_vi_put (count, key)\n   return (0);\n }\n \n-static void\n-_rl_vi_backup ()\n-{\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n-    rl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n-  else\n-    rl_point--;\n-}\n-\n+/* Move the cursor back one character if you're at the end of the line */\n int\n-rl_vi_check ()\n+rl_vi_check (void)\n {\n   if (rl_point && rl_point == rl_end)\n-    {\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n-\trl_point = _rl_find_prev_mbchar (rl_line_buffer, rl_point, MB_FIND_NONZERO);\n-      else\n-\trl_point--;\n-    }\n+    _rl_vi_backup ();\n   return (0);\n }\n \n+/* Move to the character position specified by COUNT */\n int\n-rl_vi_column (count, key)\n-     int count, key;\n+rl_vi_column (int count, int key)\n {\n   if (count > rl_end)\n     rl_end_of_line (1, key);\n   else\n-    rl_point = count - 1;\n+    {\n+      rl_point = 0;\n+      rl_point = _rl_forward_char_internal (count - 1);\n+    }\n   return (0);\n }\n \n /* Process C as part of the current numeric argument.  Return -1 if the\n    argument should be aborted, 0 if we should not read any more chars, and\n    1 if we should continue to read chars. */\n static int\n-_rl_vi_arg_dispatch (c)\n-     int c;\n+_rl_vi_arg_dispatch (int c)\n {\n   int key;\n \n@@ -1041,7 +1099,7 @@ _rl_vi_arg_dispatch (c)\n    Don't recognize minus sign?\n    Should this do rl_save_prompt/rl_restore_prompt? */\n static int\n-rl_digit_loop1 ()\n+rl_digit_loop1 (void)\n {\n   int c, r;\n \n@@ -1061,10 +1119,12 @@ rl_digit_loop1 ()\n   return (0);\n }\n \n+/* This set of functions is basically to handle the commands that take a\n+   motion argument while in callback mode: read the command, read the motion\n+   command modifier, find the extent of the text to affect, and dispatch the\n+   command for execution. */\n static void\n-_rl_mvcxt_init (m, op, key)\n-     _rl_vimotion_cxt *m;\n-     int op, key;\n+_rl_mvcxt_init (_rl_vimotion_cxt *m, int op, int key)\n {\n   m->op = op;\n   m->state = m->flags = 0;\n@@ -1077,8 +1137,7 @@ _rl_mvcxt_init (m, op, key)\n }\n \n static _rl_vimotion_cxt *\n-_rl_mvcxt_alloc (op, key)\n-     int op, key;\n+_rl_mvcxt_alloc (int op, int key)\n {\n   _rl_vimotion_cxt *m;\n \n@@ -1088,15 +1147,13 @@ _rl_mvcxt_alloc (op, key)\n }\n \n static void\n-_rl_mvcxt_dispose (m)\n-     _rl_vimotion_cxt *m;\n+_rl_mvcxt_dispose (_rl_vimotion_cxt *m)\n {\n   xfree (m);\n }\n \n static int\n-rl_domove_motion_callback (m)\n-     _rl_vimotion_cxt *m;\n+rl_domove_motion_callback (_rl_vimotion_cxt *m)\n {\n   int c;\n \n@@ -1129,9 +1186,7 @@ rl_domove_motion_callback (m)\n }\n \n int\n-_rl_vi_domove_motion_cleanup (c, m)\n-     int c;\n-     _rl_vimotion_cxt *m;\n+_rl_vi_domove_motion_cleanup (int c, _rl_vimotion_cxt *m)\n {\n   int r;\n \n@@ -1153,7 +1208,7 @@ _rl_vi_domove_motion_cleanup (c, m)\n      non-whitespace character, move back one (presumably to whitespace). */\n   if ((_rl_to_upper (c) == 'W') && rl_point < rl_end && rl_point > rl_mark &&\n       !whitespace (rl_line_buffer[rl_point]))\n-    rl_point--;\n+    rl_point--;\t\t/* XXX */\n \n   /* If cw or cW, back up to the end of a word, so the behaviour of ce\n      or cE is the actual result.  Brute-force, no subtlety. */\n@@ -1166,14 +1221,14 @@ _rl_vi_domove_motion_cleanup (c, m)\n       /* Posix.2 says that if cw or cW moves the cursor towards the end of\n \t the line, the character under the cursor should be deleted. */\n       if (rl_point == rl_mark)\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n       else\n \t{\n \t  /* Move past the end of the word so that the kill doesn't\n \t     remove the last letter of the previous word.  Only do this\n \t     if we are not at the end of the line. */\n \t  if (rl_point >= 0 && rl_point < (rl_end - 1) && !whitespace (rl_line_buffer[rl_point]))\n-\t    rl_point++;\n+\t    _rl_vi_advance_point ();\n \t}\n     }\n \n@@ -1193,8 +1248,7 @@ _rl_vi_domove_motion_cleanup (c, m)\n #define RL_VIMOVENUMARG()\t(RL_ISSTATE (RL_STATE_VIMOTION) && RL_ISSTATE (RL_STATE_NUMERICARG))\n \n static int\n-rl_domove_read_callback (m)\n-     _rl_vimotion_cxt *m;\n+rl_domove_read_callback (_rl_vimotion_cxt *m)\n {\n   int c, save;\n \n@@ -1260,8 +1314,7 @@ rl_domove_read_callback (m)\n }\n \n static int\n-rl_vi_domove_getchar (m)\n-     _rl_vimotion_cxt *m;\n+rl_vi_domove_getchar (_rl_vimotion_cxt *m)\n {\n   int c;\n \n@@ -1274,8 +1327,7 @@ rl_vi_domove_getchar (m)\n \n #if defined (READLINE_CALLBACKS)\n int\n-_rl_vi_domove_callback (m)\n-     _rl_vimotion_cxt *m;\n+_rl_vi_domove_callback (_rl_vimotion_cxt *m)\n {\n   int c, r;\n \n@@ -1288,10 +1340,9 @@ _rl_vi_domove_callback (m)\n }\n #endif\n \n-/* This code path taken when not in callback mode. */\n+/* This code path is taken when not in callback mode. */\n int\n-rl_vi_domove (x, ignore)\n-     int x, *ignore;\n+rl_vi_domove (int x, int *ignore)\n {\n   int r;\n   _rl_vimotion_cxt *m;\n@@ -1309,22 +1360,20 @@ rl_vi_domove (x, ignore)\n }\n \n static int\n-vi_delete_dispatch (m)\n-     _rl_vimotion_cxt *m;\n+vi_delete_dispatch (_rl_vimotion_cxt *m)\n {\n   /* These are the motion commands that do not require adjusting the\n      mark. */\n   if (((strchr (\" l|h^0bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n       (rl_mark < rl_end))\n-    rl_mark++;\n+    INCREMENT_POS (rl_mark);\n \n   rl_kill_text (rl_point, rl_mark);\n   return (0);\n }\n \n int\n-rl_vi_delete_to (count, key)\n-     int count, key;\n+rl_vi_delete_to (int count, int key)\n {\n   int c, r;\n \n@@ -1373,15 +1422,14 @@ rl_vi_delete_to (count, key)\n }\n \n static int\n-vi_change_dispatch (m)\n-     _rl_vimotion_cxt *m;\n+vi_change_dispatch (_rl_vimotion_cxt *m)\n {\n   /* These are the motion commands that do not require adjusting the\n      mark.  c[wW] are handled by special-case code in rl_vi_domove(),\n      and already leave the mark at the correct location. */\n   if (((strchr (\" l|hwW^0bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n       (rl_mark < rl_end))\n-    rl_mark++;\n+    INCREMENT_POS (rl_mark);\n \n   /* The cursor never moves with c[wW]. */\n   if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)\n@@ -1413,8 +1461,7 @@ vi_change_dispatch (m)\n }\n \n int\n-rl_vi_change_to (count, key)\n-     int count, key;\n+rl_vi_change_to (int count, int key)\n {\n   int c, r;\n \n@@ -1463,14 +1510,13 @@ rl_vi_change_to (count, key)\n }\n \n static int\n-vi_yank_dispatch (m)\n-     _rl_vimotion_cxt *m;\n+vi_yank_dispatch (_rl_vimotion_cxt *m)\n {\n   /* These are the motion commands that do not require adjusting the\n      mark. */\n   if (((strchr (\" l|h^0%bBFT`\", m->motion) == 0) && (rl_point >= m->start)) &&\n       (rl_mark < rl_end))\n-    rl_mark++;\n+    INCREMENT_POS (rl_mark);\n \n   rl_begin_undo_group ();\n   rl_kill_text (rl_point, rl_mark);\n@@ -1482,8 +1528,7 @@ vi_yank_dispatch (m)\n }\n \n int\n-rl_vi_yank_to (count, key)\n-     int count, key;\n+rl_vi_yank_to (int count, int key)\n {\n   int c, r;\n \n@@ -1532,8 +1577,7 @@ rl_vi_yank_to (count, key)\n }\n \n static int\n-vidomove_dispatch (m)\n-     _rl_vimotion_cxt *m;\n+vidomove_dispatch (_rl_vimotion_cxt *m)\n {\n   int r;\n \n@@ -1559,8 +1603,7 @@ vidomove_dispatch (m)\n }\n \n int\n-rl_vi_rubout (count, key)\n-     int count, key;\n+rl_vi_rubout (int count, int key)\n {\n   int opoint;\n \n@@ -1590,8 +1633,7 @@ rl_vi_rubout (count, key)\n }\n \n int\n-rl_vi_delete (count, key)\n-     int count, key;\n+rl_vi_delete (int count, int key)\n {\n   int end;\n \n@@ -1626,8 +1668,7 @@ rl_vi_delete (count, key)\n #define vi_unix_word_boundary(c)\t(whitespace(c) || ispunct(c))\n \n int\n-rl_vi_unix_word_rubout (count, key)\n-     int count, key;\n+rl_vi_unix_word_rubout (int count, int key)\n {\n   int orig_point;\n \n@@ -1665,8 +1706,8 @@ rl_vi_unix_word_rubout (count, key)\n \t    while (rl_point && vi_unix_word_boundary (rl_line_buffer[rl_point - 1]))\n \t      rl_point--;\n \t  else if (rl_point > 0 && vi_unix_word_boundary (rl_line_buffer[rl_point]) == 0)\n-\t    while (rl_point && (vi_unix_word_boundary (rl_line_buffer[rl_point - 1]) == 0))\n-\t      rl_point--;\n+\t    while (rl_point > 0 && (vi_unix_word_boundary (rl_line_buffer[rl_point - 1]) == 0))\n+\t      _rl_vi_backup_point ();\n \t}\n \n       rl_kill_text (orig_point, rl_point);\n@@ -1677,8 +1718,7 @@ rl_vi_unix_word_rubout (count, key)\n \n \n int\n-rl_vi_back_to_indent (count, key)\n-     int count, key;\n+rl_vi_back_to_indent (int count, int key)\n {\n   rl_beg_of_line (1, key);\n   while (rl_point < rl_end && whitespace (rl_line_buffer[rl_point]))\n@@ -1687,8 +1727,7 @@ rl_vi_back_to_indent (count, key)\n }\n \n int\n-rl_vi_first_print (count, key)\n-     int count, key;\n+rl_vi_first_print (int count, int key)\n {\n   return (rl_vi_back_to_indent (1, key));\n }\n@@ -1697,8 +1736,7 @@ static int _rl_cs_dir, _rl_cs_orig_dir;\n \n #if defined (READLINE_CALLBACKS)\n static int\n-_rl_vi_callback_char_search (data)\n-     _rl_callback_generic_arg *data;\n+_rl_vi_callback_char_search (_rl_callback_generic_arg *data)\n {\n   int c;\n #if defined (HANDLE_MULTIBYTE)\n@@ -1732,8 +1770,7 @@ _rl_vi_callback_char_search (data)\n #endif\n \n int\n-rl_vi_char_search (count, key)\n-     int count, key;\n+rl_vi_char_search (int count, int key)\n {\n   int c;\n #if defined (HANDLE_MULTIBYTE)\n@@ -1826,8 +1863,7 @@ rl_vi_char_search (count, key)\n \n /* Match brackets */\n int\n-rl_vi_match (ignore, key)\n-     int ignore, key;\n+rl_vi_match (int ignore, int key)\n {\n   int count = 1, brack, pos, tmp, pre;\n \n@@ -1916,8 +1952,7 @@ rl_vi_match (ignore, key)\n }\n \n int\n-rl_vi_bracktype (c)\n-     int c;\n+rl_vi_bracktype (int c)\n {\n   switch (c)\n     {\n@@ -1932,9 +1967,7 @@ rl_vi_bracktype (c)\n }\n \n static int\n-_rl_vi_change_char (count, c, mb)\n-     int count, c;\n-     char *mb;\n+_rl_vi_change_char (int count, int c, char *mb)\n {\n   int p;\n \n@@ -1947,7 +1980,7 @@ _rl_vi_change_char (count, c, mb)\n       p = rl_point;\n       rl_vi_delete (1, c);\n       if (rl_point < p)\t\t/* Did we retreat at EOL? */\n-\trl_point++;\n+\t_rl_vi_append_forward (c);\n #if defined (HANDLE_MULTIBYTE)\n       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \trl_insert_text (mb);\n@@ -1965,9 +1998,7 @@ _rl_vi_change_char (count, c, mb)\n }\n \n static int\n-_rl_vi_callback_getchar (mb, mlen)\n-     char *mb;\n-     int mlen;\n+_rl_vi_callback_getchar (char *mb, int mlen)\n {\n   int c;\n \n@@ -1988,13 +2019,18 @@ _rl_vi_callback_getchar (mb, mlen)\n \n #if defined (READLINE_CALLBACKS)\n static int\n-_rl_vi_callback_change_char (data)\n-     _rl_callback_generic_arg *data;\n+_rl_vi_callback_change_char (_rl_callback_generic_arg *data)\n {\n   int c;\n-  char mb[MB_LEN_MAX];\n+  char mb[MB_LEN_MAX+1];\n \n-  _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n+  c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n+#if defined (HANDLE_MULTIBYTE)\n+  strncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);\n+#else\n+  _rl_vi_last_replacement[0] = c;\n+#endif\n+  _rl_vi_last_replacement[MB_LEN_MAX] = '\\0';\t/* XXX */\n \n   if (c < 0)\n     return -1;\n@@ -2007,17 +2043,16 @@ _rl_vi_callback_change_char (data)\n #endif\n \n int\n-rl_vi_change_char (count, key)\n-     int count, key;\n+rl_vi_change_char (int count, int key)\n {\n   int c;\n-  char mb[MB_LEN_MAX];\n+  char mb[MB_LEN_MAX+1];\n \n   if (_rl_vi_redoing)\n     {\n-      c = _rl_vi_last_replacement;\n-      mb[0] = c;\n-      mb[1] = '\\0';\n+      strncpy (mb, _rl_vi_last_replacement, MB_LEN_MAX);\n+      c = (unsigned char)_rl_vi_last_replacement[0];\t/* XXX */\n+      mb[MB_LEN_MAX] = '\\0';\n     }\n #if defined (READLINE_CALLBACKS)\n   else if (RL_ISSTATE (RL_STATE_CALLBACK))\n@@ -2028,7 +2063,15 @@ rl_vi_change_char (count, key)\n     }\n #endif\n   else\n-    _rl_vi_last_replacement = c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n+    {\n+      c = _rl_vi_callback_getchar (mb, MB_LEN_MAX);\n+#ifdef HANDLE_MULTIBYTE\n+      strncpy (_rl_vi_last_replacement, mb, MB_LEN_MAX);\n+#else\n+      _rl_vi_last_replacement[0] = c;\n+#endif\n+      _rl_vi_last_replacement[MB_LEN_MAX] = '\\0';\t/* just in case */      \n+    }\n \n   if (c < 0)\n     return -1;\n@@ -2037,8 +2080,7 @@ rl_vi_change_char (count, key)\n }\n \n int\n-rl_vi_subst (count, key)\n-     int count, key;\n+rl_vi_subst (int count, int key)\n {\n   /* If we are redoing, rl_vi_change_to will stuff the last motion char */\n   if (_rl_vi_redoing == 0)\n@@ -2048,8 +2090,7 @@ rl_vi_subst (count, key)\n }\n \n int\n-rl_vi_overstrike (count, key)\n-     int count, key;\n+rl_vi_overstrike (int count, int key)\n {\n   if (_rl_vi_doing_insert == 0)\n     {\n@@ -2067,8 +2108,7 @@ rl_vi_overstrike (count, key)\n }\n \n int\n-rl_vi_overstrike_delete (count, key)\n-     int count, key;\n+rl_vi_overstrike_delete (int count, int key)\n {\n   int i, s;\n \n@@ -2098,8 +2138,7 @@ rl_vi_overstrike_delete (count, key)\n }\n \n int\n-rl_vi_replace (count, key)\n-     int count, key;\n+rl_vi_replace (int count, int key)\n {\n   int i;\n \n@@ -2130,6 +2169,9 @@ rl_vi_replace (count, key)\n \t  vi_insertion_keymap[CTRL ('H')].function == rl_rubout)\n \tvi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;\n \n+      /* Make sure this is the value we need. */\n+      vi_replace_map[ANYOTHERKEY].type = ISFUNC;\n+      vi_replace_map[ANYOTHERKEY].function = (rl_command_func_t *)NULL;\n     }\n \n   rl_vi_start_inserting (key, 1, rl_arg_sign);\n@@ -2145,15 +2187,15 @@ rl_vi_replace (count, key)\n    the previous character.  A space matches everything.  Word delimiters are\n    space and ;. */\n int\n-rl_vi_possible_completions()\n+rl_vi_possible_completions (void)\n {\n   int save_pos = rl_point;\n \n   if (rl_line_buffer[rl_point] != ' ' && rl_line_buffer[rl_point] != ';')\n     {\n       while (rl_point < rl_end && rl_line_buffer[rl_point] != ' ' &&\n \t     rl_line_buffer[rl_point] != ';')\n-\trl_point++;\n+\t_rl_vi_advance_point ();\n     }\n   else if (rl_line_buffer[rl_point - 1] == ';')\n     {\n@@ -2170,7 +2212,7 @@ rl_vi_possible_completions()\n \n /* Functions to save and restore marks. */\n static int\n-_rl_vi_set_mark ()\n+_rl_vi_set_mark (void)\n {\n   int ch;\n \n@@ -2190,8 +2232,7 @@ _rl_vi_set_mark ()\n \n #if defined (READLINE_CALLBACKS)\n static int\n-_rl_vi_callback_set_mark (data)\n-     _rl_callback_generic_arg *data;\n+_rl_vi_callback_set_mark (_rl_callback_generic_arg *data)\n {\n   _rl_callback_func = 0;\n   _rl_want_redisplay = 1;\n@@ -2201,8 +2242,7 @@ _rl_vi_callback_set_mark (data)\n #endif\n \n int\n-rl_vi_set_mark (count, key)\n-     int count, key;\n+rl_vi_set_mark (int count, int key)\n {\n #if defined (READLINE_CALLBACKS)\n   if (RL_ISSTATE (RL_STATE_CALLBACK))\n@@ -2217,7 +2257,7 @@ rl_vi_set_mark (count, key)\n }\n \n static int\n-_rl_vi_goto_mark ()\n+_rl_vi_goto_mark (void)\n {\n   int ch;\n \n@@ -2248,8 +2288,7 @@ _rl_vi_goto_mark ()\n \n #if defined (READLINE_CALLBACKS)\n static int\n-_rl_vi_callback_goto_mark (data)\n-     _rl_callback_generic_arg *data;\n+_rl_vi_callback_goto_mark (_rl_callback_generic_arg *data)\n {\n   _rl_callback_func = 0;\n   _rl_want_redisplay = 1;\n@@ -2259,8 +2298,7 @@ _rl_vi_callback_goto_mark (data)\n #endif\n \n int\n-rl_vi_goto_mark (count, key)\n-     int count, key;\n+rl_vi_goto_mark (int count, int key)\n {\n #if defined (READLINE_CALLBACKS)\n   if (RL_ISSTATE (RL_STATE_CALLBACK))"
    },
    {
      "sha": "c199b29bdfd769987494d6faa90270cea8625adf",
      "filename": "readline/xfree.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/xfree.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/xfree.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/xfree.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* xfree.c -- safe version of free that ignores attempts to free NUL */\n \n-/* Copyright (C) 1991-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1991-2010,2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -42,8 +42,7 @@\n /* Use this as the function to call when adding unwind protects so we\n    don't need to know what free() returns. */\n void\n-xfree (string)\n-     PTR_T string;\n+xfree (PTR_T string)\n {\n   if (string)\n     free (string);"
    },
    {
      "sha": "5d01d75eaeff07805e10fb512dc70949a59c6040",
      "filename": "readline/xmalloc.c",
      "status": "modified",
      "additions": 4,
      "deletions": 8,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/xmalloc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20/readline/xmalloc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/xmalloc.c?ref=cb41b9e70e6fbd1cb603bb9ba4372fbb8ae87b20",
      "patch": "@@ -1,6 +1,6 @@\n /* xmalloc.c -- safe versions of malloc and realloc */\n \n-/* Copyright (C) 1991-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1991-2017 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -42,8 +42,7 @@\n /* **************************************************************** */\n \n static void\n-memory_error_and_abort (fname)\n-     char *fname;\n+memory_error_and_abort (char *fname)\n {\n   fprintf (stderr, \"%s: out of virtual memory\\n\", fname);\n   exit (2);\n@@ -53,8 +52,7 @@ memory_error_and_abort (fname)\n    to hold BYTES number of bytes.  If the memory cannot be allocated,\n    print an error message and abort. */\n PTR_T\n-xmalloc (bytes)\n-     size_t bytes;\n+xmalloc (size_t bytes)\n {\n   PTR_T temp;\n \n@@ -65,9 +63,7 @@ xmalloc (bytes)\n }\n \n PTR_T\n-xrealloc (pointer, bytes)\n-     PTR_T pointer;\n-     size_t bytes;\n+xrealloc (PTR_T pointer, size_t bytes)\n {\n   PTR_T temp;\n "
    }
  ]
}