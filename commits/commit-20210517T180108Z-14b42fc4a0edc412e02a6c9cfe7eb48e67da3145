{
  "sha": "14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTRiNDJmYzRhMGVkYzQxMmUwMmE2YzljZmU3ZWI0OGU2N2RhMzE0NQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-17T18:01:08Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-17T18:01:08Z"
    },
    "message": "gdb: rename cmd_list_element::prefixlist to subcommands\n\nWhile browsing this code, I found the name \"prefixlist\" really\nconfusing.  I kept reading it as \"list of prefixes\".  Which it isn't:\nit's a list of sub-commands, for a prefix command.  I think that\nrenaming it to \"subcommands\" would make things clearer.\n\ngdb/ChangeLog:\n\n\t* Rename \"prefixlist\" parameters to \"subcommands\" throughout.\n\t* cli/cli-decode.h (cmd_list_element) <prefixlist>: Rename to...\n\t<subcommands>: ... this.\n\t* cli/cli-decode.c (lookup_cmd_for_prefixlist): Rename to...\n\t(lookup_cmd_with_subcommands): ... this.\n\nChange-Id: I150da10d03052c2420aa5b0dee41f422e2a97928",
    "tree": {
      "sha": "21dc1064114f57a24740462b0f30a2c5ca581635",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/21dc1064114f57a24740462b0f30a2c5ca581635"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ecd0a6b35d32aa6aca913e2d0348cfdf7e78d6c3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ecd0a6b35d32aa6aca913e2d0348cfdf7e78d6c3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ecd0a6b35d32aa6aca913e2d0348cfdf7e78d6c3"
    }
  ],
  "stats": {
    "total": 181,
    "additions": 94,
    "deletions": 87
  },
  "files": [
    {
      "sha": "4184c9f1ff82deb0c259e4fed872fe9570febbd3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -1,3 +1,11 @@\n+2021-05-17  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* Rename \"prefixlist\" parameters to \"subcommands\" throughout.\n+\t* cli/cli-decode.h (cmd_list_element) <prefixlist>: Rename to...\n+\t<subcommands>: ... this.\n+\t* cli/cli-decode.c (lookup_cmd_for_prefixlist): Rename to...\n+\t(lookup_cmd_with_subcommands): ... this.\n+\n 2021-05-17  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* cli/cli-decode.c (add_alias_cmd): Don't handle old == 0."
    },
    {
      "sha": "7745aa65b0367a59db4468b6a694118d23044abc",
      "filename": "gdb/auto-load.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/auto-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/auto-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auto-load.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -1465,7 +1465,7 @@ info_auto_load_cmd (const char *args, int from_tty)\n     {\n       ui_out_emit_tuple option_emitter (uiout, \"option\");\n \n-      gdb_assert (!list->prefixlist);\n+      gdb_assert (!list->subcommands);\n       gdb_assert (list->type == not_set_cmd);\n \n       uiout->field_string (\"name\", list->name);"
    },
    {
      "sha": "c29e5979acb427c11ebccafe7593ead43bae8c5c",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -1625,7 +1625,7 @@ show_user (const char *args, int from_tty)\n     {\n       for (c = cmdlist; c; c = c->next)\n \t{\n-\t  if (cli_user_command_p (c) || c->prefixlist != NULL)\n+\t  if (cli_user_command_p (c) || c->subcommands != NULL)\n \t    show_user_1 (c, \"\", c->name, gdb_stdout);\n \t}\n     }\n@@ -1900,7 +1900,7 @@ alias_command (const char *args, int from_tty)\n       /* We've already tried to look up COMMAND.  */\n       gdb_assert (c_command != NULL\n \t\t  && c_command != (struct cmd_list_element *) -1);\n-      gdb_assert (c_command->prefixlist != NULL);\n+      gdb_assert (c_command->subcommands != NULL);\n       c_alias = lookup_cmd_1 (& alias_prefix, cmdlist, NULL, NULL, 1);\n       if (c_alias != c_command)\n \terror (_(\"ALIAS and COMMAND prefixes do not match.\"));\n@@ -1909,7 +1909,7 @@ alias_command (const char *args, int from_tty)\n       alias_cmd = add_alias_cmd (xstrdup (alias_argv[alias_argc - 1]),\n \t\t\t\t command_argv[command_argc - 1],\n \t\t\t\t class_alias, a_opts.abbrev_flag,\n-\t\t\t\t c_command->prefixlist);\n+\t\t\t\t c_command->subcommands);\n     }\n \n   gdb_assert (alias_cmd != nullptr);"
    },
    {
      "sha": "27bd311e89c1a3a198cb3d09c4c33f8e03f354da",
      "filename": "gdb/cli/cli-decode.c",
      "status": "modified",
      "additions": 45,
      "deletions": 46,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-decode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-decode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -56,29 +56,29 @@ static int lookup_cmd_composition_1 (const char *text,\n \t\t\t\t     struct cmd_list_element **cmd,\n \t\t\t\t     struct cmd_list_element *cur_list);\n \n-/* Look up a command whose 'prefixlist' is KEY.  Return the command if found,\n-   otherwise return NULL.  */\n+/* Look up a command whose 'subcommands' field is SUBCOMMANDS.  Return the\n+   command if found, otherwise return NULL.  */\n \n static struct cmd_list_element *\n-lookup_cmd_for_prefixlist (struct cmd_list_element **key,\n-\t\t\t   struct cmd_list_element *list)\n+lookup_cmd_with_subcommands (cmd_list_element **subcommands,\n+\t\t\t     cmd_list_element *list)\n {\n   struct cmd_list_element *p = NULL;\n \n   for (p = list; p != NULL; p = p->next)\n     {\n       struct cmd_list_element *q;\n \n-      if (p->prefixlist == NULL)\n+      if (p->subcommands == NULL)\n \tcontinue;\n-      else if (p->prefixlist == key)\n+      else if (p->subcommands == subcommands)\n \t{\n \t  /* If we found an alias, we must return the aliased\n \t     command.  */\n \t  return p->cmd_pointer ? p->cmd_pointer : p;\n \t}\n \n-      q = lookup_cmd_for_prefixlist (key, *(p->prefixlist));\n+      q = lookup_cmd_with_subcommands (subcommands, *(p->subcommands));\n       if (q != NULL)\n \treturn q;\n     }\n@@ -163,7 +163,7 @@ set_cmd_completer_handle_brkchars (struct cmd_list_element *cmd,\n std::string\n cmd_list_element::prefixname () const\n {\n-  if (this->prefixlist == nullptr)\n+  if (this->subcommands == nullptr)\n     /* Not a prefix command.  */\n     return \"\";\n \n@@ -236,8 +236,7 @@ do_add_cmd (const char *name, enum command_class theclass,\n \n   /* Search the prefix cmd of C, and assigns it to C->prefix.\n      See also add_prefix_cmd and update_prefix_field_of_prefixed_commands.  */\n-  struct cmd_list_element *prefixcmd = lookup_cmd_for_prefixlist (list,\n-\t\t\t\t\t\t\t\t  cmdlist);\n+  cmd_list_element *prefixcmd = lookup_cmd_with_subcommands (list, cmdlist);\n   c->prefix = prefixcmd;\n \n \n@@ -323,7 +322,7 @@ add_alias_cmd (const char *name, cmd_list_element *old,\n   /* NOTE: Both FUNC and all the FUNCTIONs need to be copied.  */\n   c->func = old->func;\n   c->function = old->function;\n-  c->prefixlist = old->prefixlist;\n+  c->subcommands = old->subcommands;\n   c->allow_unknown = old->allow_unknown;\n   c->abbrev_flag = abbrev_flag;\n   c->cmd_pointer = old;\n@@ -358,7 +357,7 @@ add_alias_cmd (const char *name, const char *oldname,\n static void\n update_prefix_field_of_prefixed_commands (struct cmd_list_element *c)\n {\n-  for (cmd_list_element *p = *c->prefixlist; p != NULL; p = p->next)\n+  for (cmd_list_element *p = *c->subcommands; p != NULL; p = p->next)\n     {\n       p->prefix = c;\n \n@@ -371,28 +370,28 @@ update_prefix_field_of_prefixed_commands (struct cmd_list_element *c)\n \t In such a case, when 'auto-load' was created by do_add_cmd,\n \t the 'libthread-db' prefix field could not be updated, as the\n \t 'auto-load' command was not yet reachable by\n-\t    lookup_cmd_for_prefixlist (list, cmdlist)\n+\t    lookup_cmd_for_subcommands (list, cmdlist)\n \t    that searches from the top level 'cmdlist'.  */\n-      if (p->prefixlist != nullptr)\n+      if (p->subcommands != nullptr)\n \tupdate_prefix_field_of_prefixed_commands (p);\n     }\n }\n \n \n /* Like add_cmd but adds an element for a command prefix: a name that\n    should be followed by a subcommand to be looked up in another\n-   command list.  PREFIXLIST should be the address of the variable\n+   command list.  SUBCOMMANDS should be the address of the variable\n    containing that list.  */\n \n struct cmd_list_element *\n add_prefix_cmd (const char *name, enum command_class theclass,\n \t\tcmd_const_cfunc_ftype *fun,\n-\t\tconst char *doc, struct cmd_list_element **prefixlist,\n+\t\tconst char *doc, struct cmd_list_element **subcommands,\n \t\tint allow_unknown, struct cmd_list_element **list)\n {\n   struct cmd_list_element *c = add_cmd (name, theclass, fun, doc, list);\n \n-  c->prefixlist = prefixlist;\n+  c->subcommands = subcommands;\n   c->allow_unknown = allow_unknown;\n \n   /* Now that prefix command C is defined, we need to set the prefix field\n@@ -412,19 +411,19 @@ do_prefix_cmd (const char *args, int from_tty, struct cmd_list_element *c)\n   while (c->cmd_pointer != nullptr)\n     c = c->cmd_pointer;\n \n-  help_list (*c->prefixlist, c->prefixname ().c_str (),\n+  help_list (*c->subcommands, c->prefixname ().c_str (),\n \t     all_commands, gdb_stdout);\n }\n \n /* See command.h.  */\n \n struct cmd_list_element *\n add_basic_prefix_cmd (const char *name, enum command_class theclass,\n-\t\t      const char *doc, struct cmd_list_element **prefixlist,\n+\t\t      const char *doc, struct cmd_list_element **subcommands,\n \t\t      int allow_unknown, struct cmd_list_element **list)\n {\n   struct cmd_list_element *cmd = add_prefix_cmd (name, theclass, nullptr,\n-\t\t\t\t\t\t doc, prefixlist,\n+\t\t\t\t\t\t doc, subcommands,\n \t\t\t\t\t\t allow_unknown, list);\n   set_cmd_sfunc (cmd, do_prefix_cmd);\n   return cmd;\n@@ -436,18 +435,18 @@ add_basic_prefix_cmd (const char *name, enum command_class theclass,\n static void\n do_show_prefix_cmd (const char *args, int from_tty, struct cmd_list_element *c)\n {\n-  cmd_show_list (*c->prefixlist, from_tty);\n+  cmd_show_list (*c->subcommands, from_tty);\n }\n \n /* See command.h.  */\n \n struct cmd_list_element *\n add_show_prefix_cmd (const char *name, enum command_class theclass,\n-\t\t     const char *doc, struct cmd_list_element **prefixlist,\n+\t\t     const char *doc, struct cmd_list_element **subcommands,\n \t\t     int allow_unknown, struct cmd_list_element **list)\n {\n   struct cmd_list_element *cmd = add_prefix_cmd (name, theclass, nullptr,\n-\t\t\t\t\t\t doc, prefixlist,\n+\t\t\t\t\t\t doc, subcommands,\n \t\t\t\t\t\t allow_unknown, list);\n   set_cmd_sfunc (cmd, do_show_prefix_cmd);\n   return cmd;\n@@ -460,12 +459,12 @@ struct cmd_list_element *\n add_prefix_cmd_suppress_notification\n \t       (const char *name, enum command_class theclass,\n \t\tcmd_const_cfunc_ftype *fun,\n-\t\tconst char *doc, struct cmd_list_element **prefixlist,\n+\t\tconst char *doc, struct cmd_list_element **subcommands,\n \t\tint allow_unknown, struct cmd_list_element **list,\n \t\tint *suppress_notification)\n {\n   struct cmd_list_element *element\n-    = add_prefix_cmd (name, theclass, fun, doc, prefixlist,\n+    = add_prefix_cmd (name, theclass, fun, doc, subcommands,\n \t\t      allow_unknown, list);\n   element->suppress_notification = suppress_notification;\n   return element;\n@@ -476,12 +475,12 @@ add_prefix_cmd_suppress_notification\n struct cmd_list_element *\n add_abbrev_prefix_cmd (const char *name, enum command_class theclass,\n \t\t       cmd_const_cfunc_ftype *fun, const char *doc,\n-\t\t       struct cmd_list_element **prefixlist,\n+\t\t       struct cmd_list_element **subcommands,\n \t\t       int allow_unknown, struct cmd_list_element **list)\n {\n   struct cmd_list_element *c = add_cmd (name, theclass, fun, doc, list);\n \n-  c->prefixlist = prefixlist;\n+  c->subcommands = subcommands;\n   c->allow_unknown = allow_unknown;\n   c->abbrev_flag = 1;\n   return c;\n@@ -1188,11 +1187,11 @@ apropos_cmd (struct ui_file *stream,\n \t    print_doc_of_command (c, prefix, verbose, regex, stream);\n \t}\n       /* Check if this command has subcommands.  */\n-      if (c->prefixlist != NULL)\n+      if (c->subcommands != NULL)\n \t{\n \t  /* Recursively call ourselves on the subcommand list,\n \t     passing the right prefix in.  */\n-\t  apropos_cmd (stream, *c->prefixlist, verbose, regex,\n+\t  apropos_cmd (stream, *c->subcommands, verbose, regex,\n \t\t       c->prefixname ().c_str ());\n \t}\n     }\n@@ -1235,7 +1234,7 @@ help_cmd (const char *command, struct ui_file *stream)\n   lookup_cmd_composition (orig_command, &alias, &prefix_cmd, &c_cmd);\n \n   /* There are three cases here.\n-     If c->prefixlist is nonzero, we have a prefix command.\n+     If c->subcommands is nonzero, we have a prefix command.\n      Print its documentation, then list its subcommands.\n \n      If c->func is non NULL, we really have a command.  Print its\n@@ -1253,13 +1252,13 @@ help_cmd (const char *command, struct ui_file *stream)\n   fputs_filtered (c->doc, stream);\n   fputs_filtered (\"\\n\", stream);\n \n-  if (c->prefixlist == 0 && c->func != NULL)\n+  if (c->subcommands == 0 && c->func != NULL)\n     return;\n   fprintf_filtered (stream, \"\\n\");\n \n   /* If this is a prefix command, print it's subcommands.  */\n-  if (c->prefixlist)\n-    help_list (*c->prefixlist, c->prefixname ().c_str (),\n+  if (c->subcommands)\n+    help_list (*c->subcommands, c->prefixname ().c_str (),\n \t       all_commands, stream);\n \n   /* If this is a class name, print all of the commands in the class.  */\n@@ -1450,12 +1449,12 @@ print_help_for_command (struct cmd_list_element *c,\n   fput_aliases_definition_styled (c, stream);\n \n   if (recurse\n-      && c->prefixlist != 0\n+      && c->subcommands != 0\n       && c->abbrev_flag == 0)\n     /* Subcommands of a prefix command typically have 'all_commands'\n        as class.  If we pass CLASS to recursive invocation,\n        most often we won't see anything.  */\n-    help_cmd_list (*c->prefixlist, all_commands, true, stream);\n+    help_cmd_list (*c->subcommands, all_commands, true, stream);\n }\n \n /*\n@@ -1520,10 +1519,10 @@ help_cmd_list (struct cmd_list_element *list, enum command_class theclass,\n \n       if (recurse\n \t  && (theclass == class_user || theclass == class_alias)\n-\t  && c->prefixlist != NULL)\n+\t  && c->subcommands != NULL)\n \t{\n \t  /* User-defined commands or aliases may be subcommands.  */\n-\t  help_cmd_list (*c->prefixlist, theclass, recurse, stream);\n+\t  help_cmd_list (*c->subcommands, theclass, recurse, stream);\n \t  continue;\n \t}\n \n@@ -1698,9 +1697,9 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n     }\n   /* If we found a prefix command, keep looking.  */\n \n-  if (found->prefixlist)\n+  if (found->subcommands)\n     {\n-      c = lookup_cmd_1 (text, *found->prefixlist, result_list, default_args,\n+      c = lookup_cmd_1 (text, *found->subcommands, result_list, default_args,\n \t\t\tignore_help_classes, lookup_for_completion_p);\n       if (!c)\n \t{\n@@ -1718,7 +1717,7 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n \t     we've found (if an inferior hasn't already set it).  */\n \t  if (result_list != nullptr)\n \t    if (!*result_list)\n-\t      /* This used to say *result_list = *found->prefixlist.\n+\t      /* This used to say *result_list = *found->subcommands.\n \t\t If that was correct, need to modify the documentation\n \t\t at the top of this function to clarify what is\n \t\t supposed to be going on.  */\n@@ -1810,14 +1809,14 @@ lookup_cmd (const char **line, struct cmd_list_element *list,\n     }\n   else if (c == CMD_LIST_AMBIGUOUS)\n     {\n-      /* Ambigous.  Local values should be off prefixlist or called\n+      /* Ambigous.  Local values should be off subcommands or called\n \t values.  */\n       int local_allow_unknown = (last_list ? last_list->allow_unknown :\n \t\t\t\t allow_unknown);\n       std::string local_cmdtype\n \t= last_list ? last_list->prefixname () : cmdtype;\n       struct cmd_list_element *local_list =\n-\t(last_list ? *(last_list->prefixlist) : list);\n+\t(last_list ? *(last_list->subcommands) : list);\n \n       if (local_allow_unknown < 0)\n \t{\n@@ -1869,7 +1868,7 @@ lookup_cmd (const char **line, struct cmd_list_element *list,\n       while (**line == ' ' || **line == '\\t')\n \t(*line)++;\n \n-      if (c->prefixlist && **line && !c->allow_unknown)\n+      if (c->subcommands && **line && !c->allow_unknown)\n \tundef_cmd_error (c->prefixname ().c_str (), *line);\n \n       /* Seems to be what he wants.  Return it.  */\n@@ -2060,9 +2059,9 @@ lookup_cmd_composition_1 (const char *text,\n       text += len;\n       text = skip_spaces (text);\n \n-      if ((*cmd)->prefixlist != nullptr && *text != '\\0')\n+      if ((*cmd)->subcommands != nullptr && *text != '\\0')\n \t{\n-\t  cur_list = *(*cmd)->prefixlist;\n+\t  cur_list = *(*cmd)->subcommands;\n \t  *prefix_cmd = *cmd;\n \t}\n       else\n@@ -2127,7 +2126,7 @@ complete_on_cmdlist (struct cmd_list_element *list,\n \tif (!strncmp (ptr->name, text, textlen)\n \t    && !ptr->abbrev_flag\n \t    && (!ignore_help_classes || ptr->func\n-\t\t|| ptr->prefixlist))\n+\t\t|| ptr->subcommands))\n \t  {\n \t    if (pass == 0)\n \t      {"
    },
    {
      "sha": "e2428bdddf7de1828b66ade1737dc2dfa13a54d3",
      "filename": "gdb/cli/cli-decode.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-decode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-decode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.h?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -187,7 +187,7 @@ struct cmd_list_element\n \n   /* Nonzero identifies a prefix command.  For them, the address\n      of the variable containing the list of subcommands.  */\n-  struct cmd_list_element **prefixlist = nullptr;\n+  struct cmd_list_element **subcommands = nullptr;\n \n   /* The prefix command of this command.  */\n   struct cmd_list_element *prefix = nullptr;"
    },
    {
      "sha": "5ddfab9674a096b089c6a12445666b491393f3fd",
      "filename": "gdb/cli/cli-script.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-script.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-script.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-script.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -1350,10 +1350,10 @@ validate_comname (const char **comname)\n       const char *tem = prefix.c_str ();\n \n       c = lookup_cmd (&tem, cmdlist, \"\", NULL, 0, 1);\n-      if (c->prefixlist == NULL)\n+      if (c->subcommands == NULL)\n \terror (_(\"\\\"%s\\\" is not a prefix command.\"), prefix.c_str ());\n \n-      list = c->prefixlist;\n+      list = c->subcommands;\n       *comname = last_word;\n     }\n \n@@ -1414,7 +1414,7 @@ do_define_command (const char *comname, int from_tty,\n \t  /* if C is a prefix command that was previously defined,\n \t     tell the user its subcommands will be kept, and ask\n \t     if ok to redefine the command.  */\n-\t  if (c->prefixlist != nullptr)\n+\t  if (c->subcommands != nullptr)\n \t    q = (c->user_commands.get () == nullptr\n \t\t || query (_(\"Keeping subcommands of prefix command \\\"%s\\\".\\n\"\n \t\t\t     \"Redefine command \\\"%s\\\"? \"), c->name, c->name));\n@@ -1470,8 +1470,8 @@ do_define_command (const char *comname, int from_tty,\n     cmds = *commands;\n \n   {\n-    struct cmd_list_element **c_prefixlist\n-      = c == nullptr ? nullptr : c->prefixlist;\n+    struct cmd_list_element **c_subcommands\n+      = c == nullptr ? nullptr : c->subcommands;\n \n     newc = add_cmd (comname, class_user, user_defined_command,\n \t\t    (c != nullptr && c->theclass == class_user)\n@@ -1480,9 +1480,9 @@ do_define_command (const char *comname, int from_tty,\n \n     /* If we define or re-define a command that was previously defined\n        as a prefix, keep the prefix information.  */\n-    if (c_prefixlist != nullptr)\n+    if (c_subcommands != nullptr)\n       {\n-\tnewc->prefixlist = c_prefixlist;\n+\tnewc->subcommands = c_subcommands;\n \t/* allow_unknown: see explanation in equivalent logic in\n \t   define_prefix_command ().  */\n \tnewc->allow_unknown = newc->user_commands.get () != nullptr;\n@@ -1595,7 +1595,7 @@ define_prefix_command (const char *comname, int from_tty)\n   if (c != nullptr && c->theclass != class_user)\n     error (_(\"Command \\\"%s\\\" is built-in.\"), comfull);\n \n-  if (c != nullptr && c->prefixlist != nullptr)\n+  if (c != nullptr && c->subcommands != nullptr)\n     {\n       /* c is already a user defined prefix command.  */\n       return;\n@@ -1609,10 +1609,10 @@ define_prefix_command (const char *comname, int from_tty)\n \t\t   xstrdup (\"User-defined.\"), list);\n     }\n \n-  /* Allocate the c->prefixlist, which marks the command as a prefix\n+  /* Allocate the c->subcommands, which marks the command as a prefix\n      command.  */\n-  c->prefixlist = new struct cmd_list_element*;\n-  *(c->prefixlist) = nullptr;\n+  c->subcommands = new struct cmd_list_element*;\n+  *(c->subcommands) = nullptr;\n   /* If the prefix command C is not a command, then it must be followed\n      by known subcommands.  Otherwise, if C is also a normal command,\n      it can be followed by C args that must not cause a 'subcommand'\n@@ -1665,7 +1665,7 @@ show_user_1 (struct cmd_list_element *c, const char *prefix, const char *name,\n       struct command_line *cmdlines = c->user_commands.get ();\n \n       fprintf_filtered (stream, \"User %scommand \\\"\",\n-\t\t\tc->prefixlist == NULL ? \"\" : \"prefix \");\n+\t\t\tc->subcommands == NULL ? \"\" : \"prefix \");\n       fprintf_styled (stream, title_style.style (), \"%s%s\",\n \t\t      prefix, name);\n       fprintf_filtered (stream, \"\\\":\\n\");\n@@ -1676,12 +1676,12 @@ show_user_1 (struct cmd_list_element *c, const char *prefix, const char *name,\n \t}\n     }\n \n-  if (c->prefixlist != NULL)\n+  if (c->subcommands != NULL)\n     {\n       const std::string prefixname = c->prefixname ();\n \n-      for (c = *c->prefixlist; c != NULL; c = c->next)\n-\tif (c->theclass == class_user || c->prefixlist != NULL)\n+      for (c = *c->subcommands; c != NULL; c = c->next)\n+\tif (c->theclass == class_user || c->subcommands != NULL)\n \t  show_user_1 (c, prefixname.c_str (), c->name, gdb_stdout);\n     }\n "
    },
    {
      "sha": "cb72c6241cbf8f857ed1e9843d833c742ad5c3be",
      "filename": "gdb/cli/cli-setshow.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-setshow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/cli/cli-setshow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -550,10 +550,10 @@ do_set_command (const char *arg, int from_tty, struct cmd_list_element *c)\n \t  p = p->prefix;\n \t}\n \n-      /* Don't trigger any observer notification if prefixlist is not\n+      /* Don't trigger any observer notification if subcommands is not\n \t setlist.  */\n       i--;\n-      if (cmds[i]->prefixlist != &setlist)\n+      if (cmds[i]->subcommands != &setlist)\n \t{\n \t  xfree (cmds);\n \t  xfree (name);\n@@ -740,15 +740,15 @@ cmd_show_list (struct cmd_list_element *list, int from_tty)\n \n       /* If we find a prefix, run its list, prefixing our output by its\n \t prefix (with \"show \" skipped).  */\n-      if (list->prefixlist && list->cmd_pointer == nullptr)\n+      if (list->subcommands && list->cmd_pointer == nullptr)\n \t{\n \t  ui_out_emit_tuple optionlist_emitter (uiout, \"optionlist\");\n \t  std::string prefixname = list->prefixname ();\n \t  const char *new_prefix = strstr (prefixname.c_str (), \"show \") + 5;\n \n \t  if (uiout->is_mi_like_p ())\n \t    uiout->field_string (\"prefix\", new_prefix);\n-\t  cmd_show_list (*list->prefixlist, from_tty);\n+\t  cmd_show_list (*list->subcommands, from_tty);\n \t}\n       else if (list->theclass != no_set_class && list->cmd_pointer == nullptr)\n \t{\n@@ -758,7 +758,7 @@ cmd_show_list (struct cmd_list_element *list, int from_tty)\n \t    {\n \t      /* If we find a prefix, output it (with \"show \" skipped).  */\n \t      std::string prefixname = list->prefix->prefixname ();\n-\t      prefixname = (list->prefix->prefixlist == nullptr ? \"\"\n+\t      prefixname = (list->prefix->subcommands == nullptr ? \"\"\n \t\t\t    : strstr (prefixname.c_str (), \"show \") + 5);\n \t      uiout->text (prefixname.c_str ());\n \t    }"
    },
    {
      "sha": "fe3c7b482f04b809577da73957c02014873b20df",
      "filename": "gdb/command.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/command.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/command.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/command.h?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -208,7 +208,7 @@ extern struct cmd_list_element *add_show_prefix_cmd\n extern struct cmd_list_element *add_prefix_cmd_suppress_notification\n \t\t\t(const char *name, enum command_class theclass,\n \t\t\t cmd_const_cfunc_ftype *fun,\n-\t\t\t const char *doc, struct cmd_list_element **prefixlist,\n+\t\t\t const char *doc, struct cmd_list_element **subcommands,\n \t\t\t int allow_unknown,\n \t\t\t struct cmd_list_element **list,\n \t\t\t int *suppress_notification);"
    },
    {
      "sha": "6d39435c6ca3151ce04ff617a7e281e19fa09ee4",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -1428,7 +1428,7 @@ complete_line_internal_1 (completion_tracker &tracker,\n \t  if (result_list)\n \t    {\n \t      if (reason != handle_brkchars)\n-\t\tcomplete_on_cmdlist (*result_list->prefixlist, tracker, p,\n+\t\tcomplete_on_cmdlist (*result_list->subcommands, tracker, p,\n \t\t\t\t     word, ignore_help_classes);\n \t    }\n \t  else\n@@ -1456,12 +1456,12 @@ complete_line_internal_1 (completion_tracker &tracker,\n \t    {\n \t      /* The command is followed by whitespace; we need to\n \t\t complete on whatever comes after command.  */\n-\t      if (c->prefixlist)\n+\t      if (c->subcommands)\n \t\t{\n \t\t  /* It is a prefix command; what comes after it is\n \t\t     a subcommand (e.g. \"info \").  */\n \t\t  if (reason != handle_brkchars)\n-\t\t    complete_on_cmdlist (*c->prefixlist, tracker, p, word,\n+\t\t    complete_on_cmdlist (*c->subcommands, tracker, p, word,\n \t\t\t\t\t ignore_help_classes);\n \n \t\t  /* Ensure that readline does the right thing\n@@ -1524,7 +1524,7 @@ complete_line_internal_1 (completion_tracker &tracker,\n \t{\n \t  /* There is non-whitespace beyond the command.  */\n \n-\t  if (c->prefixlist && !c->allow_unknown)\n+\t  if (c->subcommands && !c->allow_unknown)\n \t    {\n \t      /* It is an unrecognized subcommand of a prefix command,\n \t\t e.g. \"info adsfkdj\".  */"
    },
    {
      "sha": "fc7dc2b7d0bedcabd11f0a4c7e91292240c1895e",
      "filename": "gdb/guile/scm-cmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/guile/scm-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/guile/scm-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-cmd.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -524,10 +524,10 @@ gdbscm_parse_command_name (const char *name,\n \t\t\t\t gdbscm_scm_from_c_string (name), msg);\n     }\n \n-  if (elt->prefixlist)\n+  if (elt->subcommands)\n     {\n       xfree (prefix_text);\n-      *base_list = elt->prefixlist;\n+      *base_list = elt->subcommands;\n       return result;\n     }\n "
    },
    {
      "sha": "c2c0df5798dad40f9785c1f27ac23cc6e2ddc124",
      "filename": "gdb/python/py-cmd.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/python/py-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/python/py-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-cmd.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -111,7 +111,7 @@ cmdpy_function (struct cmd_list_element *command,\n     error (_(\"Invalid invocation of Python command object.\"));\n   if (! PyObject_HasAttr ((PyObject *) obj, invoke_cst))\n     {\n-      if (obj->command->prefixlist != nullptr)\n+      if (obj->command->subcommands != nullptr)\n \t{\n \t  /* A prefix command does not need an invoke method.  */\n \t  return;\n@@ -393,9 +393,9 @@ gdbpy_parse_command_name (const char *name,\n       return NULL;\n     }\n \n-  if (elt->prefixlist)\n+  if (elt->subcommands)\n     {\n-      *base_list = elt->prefixlist;\n+      *base_list = elt->subcommands;\n       return result;\n     }\n "
    },
    {
      "sha": "a391e9359de01be444163b741f1a0c522cd51072",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -647,7 +647,7 @@ execute_command (const char *p, int from_tty)\n       if (c->theclass == class_user && c->user_commands)\n \texecute_user_command (c, arg);\n       else if (c->theclass == class_user\n-\t       && c->prefixlist && !c->allow_unknown)\n+\t       && c->subcommands && !c->allow_unknown)\n \t/* If this is a user defined prefix that does not allow unknown\n \t   (in other words, C is a prefix command and not a command\n \t   that can be followed by its args), report the list of\n@@ -659,7 +659,7 @@ execute_command (const char *p, int from_tty)\n \t  printf_unfiltered\n \t    (\"\\\"%s\\\" must be followed by the name of a subcommand.\\n\",\n \t     prefixname_no_space.c_str ());\n-\t  help_list (*c->prefixlist, prefixname.c_str (), all_commands,\n+\t  help_list (*c->subcommands, prefixname.c_str (), all_commands,\n \t\t     gdb_stdout);\n \t}\n       else if (c->type == set_cmd)"
    },
    {
      "sha": "53e5626f64598de2764387e996da6d1d8f5ff5a9",
      "filename": "gdb/unittests/command-def-selftests.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/unittests/command-def-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14b42fc4a0edc412e02a6c9cfe7eb48e67da3145/gdb/unittests/command-def-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/command-def-selftests.c?ref=14b42fc4a0edc412e02a6c9cfe7eb48e67da3145",
      "patch": "@@ -83,11 +83,11 @@ check_doc (struct cmd_list_element *commandlist, const char *prefix)\n       /* Check if this command has subcommands and is not an\n \t abbreviation.  We skip checking subcommands of abbreviations\n \t in order to avoid duplicates in the output.  */\n-      if (c->prefixlist != NULL && !c->abbrev_flag)\n+      if (c->subcommands != NULL && !c->abbrev_flag)\n \t{\n \t  /* Recursively call ourselves on the subcommand list,\n \t     passing the right prefix in.  */\n-\t  check_doc (*c->prefixlist, c->prefixname ().c_str ());\n+\t  check_doc (*c->subcommands, c->prefixname ().c_str ());\n \t}\n     }\n }\n@@ -155,11 +155,11 @@ traverse_command_structure (struct cmd_list_element **list,\n     {\n       /* If this command has subcommands and is not an alias,\n \t traverse the subcommands.  */\n-      if (c->prefixlist != NULL && c->cmd_pointer == nullptr)\n+      if (c->subcommands != NULL && c->cmd_pointer == nullptr)\n \t{\n \t  /* Recursively call ourselves on the subcommand list,\n \t     passing the right prefix in.  */\n-\t  traverse_command_structure (c->prefixlist, c->prefixname ().c_str ());\n+\t  traverse_command_structure (c->subcommands, c->prefixname ().c_str ());\n \t}\n       if (prefixcmd != c->prefix\n \t  || (prefixcmd == nullptr && *list != cmdlist))"
    }
  ]
}