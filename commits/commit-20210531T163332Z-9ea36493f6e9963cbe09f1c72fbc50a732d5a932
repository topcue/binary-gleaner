{
  "sha": "9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWVhMzY0OTNmNmU5OTYzY2JlMDlmMWM3MmZiYzUwYTczMmQ1YTkzMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-31T16:33:32Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-31T16:33:32Z"
    },
    "message": "gdb: pass signature to allocate_signatured_type and signatured_type constructor\n\nAll signatured_type constucted (even those used only for lookups in hash\nmaps) need a signature.  Enforce that by passing the signature all the\nway to the signatured_type constructor.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.h (struct structured_type) <signatured_type>: New.\n\tUpdate all callers.\n\t(struct dwarf2_per_bfd) <allocate_signatured_type>: Add\n\tsignature parameter, update all callers.\n\t* dwar2/read.c (dwarf2_per_bfd::allocate_signatured_type): Add\n\tsignature parameter.\n\nChange-Id: I99bc1f88f54127666aa133ddbbabb7f7668fa14a",
    "tree": {
      "sha": "8f0b4a938e7df4a6781dcd42c98d5d1e743d87ad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8f0b4a938e7df4a6781dcd42c98d5d1e743d87ad"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "46c6bcf650644ae22941ccb49dfe5fbb6e185513",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46c6bcf650644ae22941ccb49dfe5fbb6e185513",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/46c6bcf650644ae22941ccb49dfe5fbb6e185513"
    }
  ],
  "stats": {
    "total": 62,
    "additions": 34,
    "deletions": 28
  },
  "files": [
    {
      "sha": "7581c0949df3cad9eca875f438a124efbe8944c7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
      "patch": "@@ -1,3 +1,12 @@\n+2021-05-31  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* dwarf2/read.h (struct structured_type) <signatured_type>: New.\n+\tUpdate all callers.\n+\t(struct dwarf2_per_bfd) <allocate_signatured_type>: Add\n+\tsignature parameter, update all callers.\n+\t* dwar2/read.c (dwarf2_per_bfd::allocate_signatured_type): Add\n+\tsignature parameter.\n+\n 2021-05-31  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.h (signatured_type_up): New, use where possible."
    },
    {
      "sha": "338003590dce8bdb4f12685ca13a9a10e64d2cac",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 19,
      "deletions": 26,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
      "patch": "@@ -2295,9 +2295,9 @@ dwarf2_per_bfd::allocate_per_cu ()\n /* See read.h.  */\n \n signatured_type_up\n-dwarf2_per_bfd::allocate_signatured_type ()\n+dwarf2_per_bfd::allocate_signatured_type (ULONGEST signature)\n {\n-  signatured_type_up result (new signatured_type);\n+  signatured_type_up result (new signatured_type (signature));\n   result->per_bfd = this;\n   result->index = all_comp_units.size ();\n   result->is_debug_types = true;\n@@ -2396,8 +2396,7 @@ create_signatured_type_table_from_index\n       signature = extract_unsigned_integer (bytes + 16, 8, BFD_ENDIAN_LITTLE);\n       bytes += 3 * 8;\n \n-      sig_type = per_bfd->allocate_signatured_type ();\n-      sig_type->signature = signature;\n+      sig_type = per_bfd->allocate_signatured_type (signature);\n       sig_type->type_offset_in_tu = type_offset_in_tu;\n       sig_type->section = section;\n       sig_type->sect_off = sect_off;\n@@ -2447,8 +2446,8 @@ create_signatured_type_table_from_debug_names\n \t\t\t\t     section->buffer + to_underlying (sect_off),\n \t\t\t\t     rcuh_kind::TYPE);\n \n-      sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n-      sig_type->signature = cu_header.signature;\n+      sig_type = per_objfile->per_bfd->allocate_signatured_type\n+\t(cu_header.signature);\n       sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n       sig_type->section = section;\n       sig_type->sect_off = sect_off;\n@@ -5887,14 +5886,13 @@ add_type_unit (dwarf2_per_objfile *per_objfile, ULONGEST sig, void **slot)\n     ++per_objfile->per_bfd->tu_stats.nr_all_type_units_reallocs;\n \n   signatured_type_up sig_type_holder\n-    = per_objfile->per_bfd->allocate_signatured_type ();\n+    = per_objfile->per_bfd->allocate_signatured_type (sig);\n   signatured_type *sig_type = sig_type_holder.get ();\n \n   per_objfile->resize_symtabs ();\n \n   per_objfile->per_bfd->all_comp_units.emplace_back\n     (sig_type_holder.release ());\n-  sig_type->signature = sig;\n   if (per_objfile->per_bfd->using_index)\n     {\n       sig_type->v.quick =\n@@ -5965,7 +5963,6 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n   struct dwo_file *dwo_file;\n   struct dwo_unit find_dwo_entry, *dwo_entry;\n-  struct signatured_type find_sig_entry, *sig_entry;\n   void **slot;\n \n   gdb_assert (cu->dwo_unit && per_objfile->per_bfd->using_index);\n@@ -5981,10 +5978,10 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n      the TU has an entry in .gdb_index, replace the recorded data from\n      .gdb_index with this TU.  */\n \n-  find_sig_entry.signature = sig;\n+  signatured_type find_sig_entry (sig);\n   slot = htab_find_slot (per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_sig_entry, INSERT);\n-  sig_entry = (struct signatured_type *) *slot;\n+  signatured_type *sig_entry = (struct signatured_type *) *slot;\n \n   /* We can get here with the TU already read, *or* in the process of being\n      read.  Don't reassign the global entry to point to this DWO if that's\n@@ -6031,7 +6028,6 @@ lookup_dwp_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n   struct dwp_file *dwp_file = get_dwp_file (per_objfile);\n   struct dwo_unit *dwo_entry;\n-  struct signatured_type find_sig_entry, *sig_entry;\n   void **slot;\n \n   gdb_assert (cu->dwo_unit && per_objfile->per_bfd->using_index);\n@@ -6042,10 +6038,10 @@ lookup_dwp_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   if (per_objfile->per_bfd->signatured_types == NULL)\n     per_objfile->per_bfd->signatured_types = allocate_signatured_type_table ();\n \n-  find_sig_entry.signature = sig;\n+  signatured_type find_sig_entry (sig);\n   slot = htab_find_slot (per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_sig_entry, INSERT);\n-  sig_entry = (struct signatured_type *) *slot;\n+  signatured_type *sig_entry = (struct signatured_type *) *slot;\n \n   /* Have we already tried to read this TU?\n      Note: sig_entry can be NULL if the skeleton TU was removed (thus it\n@@ -6086,15 +6082,12 @@ lookup_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n     }\n   else\n     {\n-      struct signatured_type find_entry, *entry;\n-\n       if (per_objfile->per_bfd->signatured_types == NULL)\n \treturn NULL;\n-      find_entry.signature = sig;\n-      entry = ((struct signatured_type *)\n-\t       htab_find (per_objfile->per_bfd->signatured_types.get (),\n-\t\t\t  &find_entry));\n-      return entry;\n+      signatured_type find_entry (sig);\n+      return ((struct signatured_type *)\n+\t      htab_find (per_objfile->per_bfd->signatured_types.get (),\n+\t\t\t &find_entry));\n     }\n }\n \n@@ -7271,14 +7264,13 @@ process_skeletonless_type_unit (void **slot, void *info)\n {\n   struct dwo_unit *dwo_unit = (struct dwo_unit *) *slot;\n   dwarf2_per_objfile *per_objfile = (dwarf2_per_objfile *) info;\n-  struct signatured_type find_entry, *entry;\n \n   /* If this TU doesn't exist in the global table, add it and read it in.  */\n \n   if (per_objfile->per_bfd->signatured_types == NULL)\n     per_objfile->per_bfd->signatured_types = allocate_signatured_type_table ();\n \n-  find_entry.signature = dwo_unit->signature;\n+  signatured_type find_entry (dwo_unit->signature);\n   slot = htab_find_slot (per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_entry, INSERT);\n   /* If we've already seen this type there's nothing to do.  What's happening\n@@ -7288,7 +7280,8 @@ process_skeletonless_type_unit (void **slot, void *info)\n \n   /* This does the job that create_all_comp_units would have done for\n      this TU.  */\n-  entry = add_type_unit (per_objfile, dwo_unit->signature, slot);\n+  signatured_type *entry\n+    = add_type_unit (per_objfile, dwo_unit->signature, slot);\n   fill_in_sig_entry_from_dwo_entry (per_objfile, entry, dwo_unit);\n   *slot = entry;\n \n@@ -7482,9 +7475,9 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n \t  if (types_htab == nullptr)\n \t    types_htab = allocate_signatured_type_table ();\n \n-\t  auto sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n+\t  auto sig_type = per_objfile->per_bfd->allocate_signatured_type\n+\t    (cu_header.signature);\n \t  signatured_type *sig_ptr = sig_type.get ();\n-\t  sig_type->signature = cu_header.signature;\n \t  sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n \t  this_cu.reset (sig_type.release ());\n "
    },
    {
      "sha": "6f45eea1268baf6a52ab24fc54ca116c9b283291",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9ea36493f6e9963cbe09f1c72fbc50a732d5a932/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=9ea36493f6e9963cbe09f1c72fbc50a732d5a932",
      "patch": "@@ -281,8 +281,12 @@ struct dwarf2_per_cu_data\n \n struct signatured_type : public dwarf2_per_cu_data\n {\n+  signatured_type (ULONGEST signature)\n+    : signature (signature)\n+  {}\n+\n   /* The type's signature.  */\n-  ULONGEST signature = 0;\n+  ULONGEST signature;\n \n   /* Offset in the TU of the type's DIE, as read from the TU header.\n      If this TU is a DWO stub and the definition lives in a DWO file\n@@ -341,7 +345,7 @@ struct dwarf2_per_bfd\n   /* A convenience function to allocate a signatured_type.  The\n      returned object has its \"index\" field set properly.  The object\n      is allocated on the dwarf2_per_bfd obstack.  */\n-  signatured_type_up allocate_signatured_type ();\n+  signatured_type_up allocate_signatured_type (ULONGEST signature);\n \n private:\n   /* This function is mapped across the sections and remembers the"
    }
  ]
}