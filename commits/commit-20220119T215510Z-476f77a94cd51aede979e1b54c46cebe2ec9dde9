{
  "sha": "476f77a94cd51aede979e1b54c46cebe2ec9dde9",
  "node_id": "C_kwDOANOeidoAKDQ3NmY3N2E5NGNkNTFhZWRlOTc5ZTFiNTRjNDZjZWJlMmVjOWRkZTk",
  "commit": {
    "author": {
      "name": "Maciej W. Rozycki",
      "email": "macro@embecosm.com",
      "date": "2022-01-19T21:55:10Z"
    },
    "committer": {
      "name": "Maciej W. Rozycki",
      "email": "macro@embecosm.com",
      "date": "2022-01-19T21:55:10Z"
    },
    "message": "Respect `set print repeats' with Fortran arrays\n\nImplement `set print repeats' handling for Fortran arrays.  Currently\nthe setting is ignored and always treated as if no limit was set.\n\nUnlike the generic array walker implemented decades ago the Fortran one\nis a proper C++ class.  Rather than trying to mimic the old walker then,\nwhich turned out a bit of a challenge where interacting with the `set\nprint elements' setting, write it entirely from scratch, by adding an\nextra specialization handler method for processing dimensions other than\nthe innermost one and letting the specialization class call the `walk_1'\nmethod from the handler as it sees fit.  This way repeats can be tracked\nand the next inner dimension recursed into as a need arises only, or\nunconditionally in the base class.\n\nKeep track of the dimension number being handled in the class rather as\na parameter to the walker so that it does not have to be passed across\nby the specialization class.\n\nUse per-dimension element count tracking, needed to terminate processing\nearly when the limit set by `set print elements' is hit.  This requires\nextra care too where the limit triggers exactly where another element\nthat is a subarray begins.  In that case rather than recursing we need\nto terminate processing or lone `(...)' would be printed.  Additionally\nif the skipped element is the last one in the current dimension we need\nto print `...' by hand, because `continue_walking' won't print it at the\nupper level, because it can see the last element has already been taken\ncare of.\n\nPreserve the existing semantics of `set print elements' where the total\ncount of the elements handled is matched against the trigger level which\nis unlike with the C/C++ array printer where the per-dimension element\ncount is used instead.\n\nOutput now looks like:\n\n(gdb) set print repeats 4\n(gdb) print array_2d\n$1 = ((2, <repeats 5 times>) <repeats 5 times>)\n(gdb) set print elements 12\n(gdb) print array_2d\n$2 = ((2, <repeats 5 times>) (2, <repeats 5 times>) (2, 2, ...) ...)\n(gdb)\n\nfor a 5 by 5 array filled with the value of 2.\n\nAmend existing test cases accordingly that rely on the current incorrect\nbehavior and explicitly request that there be no limit for printing\nrepeated elements there.\n\nAdd suitable test cases as well covering sliced arrays in particular.\n\nCo-Authored-By: Andrew Burgess <andrew.burgess@embecosm.com>",
    "tree": {
      "sha": "23255051608cdb4f8385d31a2137b34ecbb35db0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/23255051608cdb4f8385d31a2137b34ecbb35db0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/476f77a94cd51aede979e1b54c46cebe2ec9dde9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/476f77a94cd51aede979e1b54c46cebe2ec9dde9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/476f77a94cd51aede979e1b54c46cebe2ec9dde9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/476f77a94cd51aede979e1b54c46cebe2ec9dde9/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "2ddd4c6082edcc92d57115152f8311f67b7bdd95",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2ddd4c6082edcc92d57115152f8311f67b7bdd95",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2ddd4c6082edcc92d57115152f8311f67b7bdd95"
    }
  ],
  "stats": {
    "total": 600,
    "additions": 572,
    "deletions": 28
  },
  "files": [
    {
      "sha": "a929dccead4873ff065dd56abf948d29a16c7591",
      "filename": "gdb/f-array-walker.h",
      "status": "modified",
      "additions": 49,
      "deletions": 19,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-array-walker.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-array-walker.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-array-walker.h?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -115,11 +115,12 @@ struct fortran_array_walker_base_impl\n   { return should_continue; }\n \n   /* Called when GDB starts iterating over a dimension of the array.  The\n-     argument INNER_P is true for the inner most dimension (the dimension\n-     containing the actual elements of the array), and false for more outer\n-     dimensions.  For a concrete example of how this function is called\n-     see the comment on process_element below.  */\n-  void start_dimension (bool inner_p)\n+     argument NELTS holds the number of the elements in the dimension and\n+     INNER_P is true for the inner most dimension (the dimension containing\n+     the actual elements of the array), and false for more outer dimensions.\n+     For a concrete example of how this function is called see the comment\n+     on process_element below.  */\n+  void start_dimension (LONGEST nelts, bool inner_p)\n   { /* Nothing.  */ }\n \n   /* Called when GDB finishes iterating over a dimension of the array.  The\n@@ -131,21 +132,38 @@ struct fortran_array_walker_base_impl\n   void finish_dimension (bool inner_p, bool last_p)\n   { /* Nothing.  */ }\n \n+  /* Called when processing dimensions of the array other than the\n+     innermost one.  WALK_1 is the walker to normally call, ELT_TYPE is\n+     the type of the element being extracted, and ELT_OFF is the offset\n+     of the element from the start of array being walked, and LAST_P is\n+     true only when this is the last element that will be processed in\n+     this dimension.  */\n+  void process_dimension (gdb::function_view<void (struct type *,\n+\t\t\t\t\t\t   int, bool)> walk_1,\n+\t\t\t  struct type *elt_type, LONGEST elt_off, bool last_p)\n+  {\n+    walk_1 (elt_type, elt_off, last_p);\n+  }\n+\n   /* Called when processing the inner most dimension of the array, for\n      every element in the array.  ELT_TYPE is the type of the element being\n      extracted, and ELT_OFF is the offset of the element from the start of\n      array being walked, and LAST_P is true only when this is the last\n      element that will be processed in this dimension.\n \n-     Given this two dimensional array ((1, 2) (3, 4)), the calls to\n+     Given this two dimensional array ((1, 2) (3, 4) (5, 6)), the calls to\n      start_dimension, process_element, and finish_dimension look like this:\n \n-     start_dimension (false);\n-       start_dimension (true);\n+     start_dimension (3, false);\n+       start_dimension (2, true);\n          process_element (TYPE, OFFSET, false);\n          process_element (TYPE, OFFSET, true);\n        finish_dimension (true, false);\n-       start_dimension (true);\n+       start_dimension (2, true);\n+         process_element (TYPE, OFFSET, false);\n+         process_element (TYPE, OFFSET, true);\n+       finish_dimension (true, true);\n+       start_dimension (2, true);\n          process_element (TYPE, OFFSET, false);\n          process_element (TYPE, OFFSET, true);\n        finish_dimension (true, true);\n@@ -177,22 +195,23 @@ class fortran_array_walker\n     : m_type (type),\n       m_address (address),\n       m_impl (type, address, args...),\n-      m_ndimensions (calc_f77_array_dims (m_type))\n+      m_ndimensions (calc_f77_array_dims (m_type)),\n+      m_nss (0)\n   { /* Nothing.  */ }\n \n   /* Walk the array.  */\n   void\n   walk ()\n   {\n-    walk_1 (1, m_type, 0, false);\n+    walk_1 (m_type, 0, false);\n   }\n \n private:\n-  /* The core of the array walking algorithm.  NSS is the current\n-     dimension number being processed, TYPE is the type of this dimension,\n-     and OFFSET is the offset (in bytes) for the start of this dimension.  */\n+  /* The core of the array walking algorithm.  TYPE is the type of\n+     the current dimension being processed and OFFSET is the offset\n+     (in bytes) for the start of this dimension.  */\n   void\n-  walk_1 (int nss, struct type *type, int offset, bool last_p)\n+  walk_1 (struct type *type, int offset, bool last_p)\n   {\n     /* Extract the range, and get lower and upper bounds.  */\n     struct type *range_type = check_typedef (type)->index_type ();\n@@ -204,9 +223,11 @@ class fortran_array_walker\n        dimension.  */\n     fortran_array_offset_calculator calc (type);\n \n-    m_impl.start_dimension (nss == m_ndimensions);\n+    m_nss++;\n+    m_impl.start_dimension (upperbound - lowerbound + 1,\n+\t\t\t    m_nss == m_ndimensions);\n \n-    if (nss != m_ndimensions)\n+    if (m_nss != m_ndimensions)\n       {\n \tstruct type *subarray_type = TYPE_TARGET_TYPE (check_typedef (type));\n \n@@ -220,7 +241,12 @@ class fortran_array_walker\n \t    LONGEST new_offset = offset + calc.index_offset (i);\n \n \t    /* Now print the lower dimension.  */\n-\t    walk_1 (nss + 1, subarray_type, new_offset, (i == upperbound));\n+\t    m_impl.process_dimension\n+\t      ([this] (struct type *w_type, int w_offset, bool w_last_p) -> void\n+\t\t{\n+\t\t  this->walk_1 (w_type, w_offset, w_last_p);\n+\t\t},\n+\t       subarray_type, new_offset, i == upperbound);\n \t  }\n       }\n     else\n@@ -245,7 +271,8 @@ class fortran_array_walker\n \t  }\n       }\n \n-    m_impl.finish_dimension (nss == m_ndimensions, last_p || nss == 1);\n+    m_impl.finish_dimension (m_nss == m_ndimensions, last_p || m_nss == 1);\n+    m_nss--;\n   }\n \n   /* The array type being processed.  */\n@@ -260,6 +287,9 @@ class fortran_array_walker\n \n   /* The total number of dimensions in M_TYPE.  */\n   int m_ndimensions;\n+\n+  /* The current dimension number being processed.  */\n+  int m_nss;\n };\n \n #endif /* F_ARRAY_WALKER_H */"
    },
    {
      "sha": "d181f38575349b9cbab8ed39779a90d35f045adf",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -263,7 +263,7 @@ class fortran_array_repacker_base_impl\n      will be creating values for each element as we load them and then copy\n      them into the M_DEST value.  Set a value mark so we can free these\n      temporary values.  */\n-  void start_dimension (bool inner_p)\n+  void start_dimension (LONGEST nelts, bool inner_p)\n   {\n     if (inner_p)\n       {"
    },
    {
      "sha": "4b1aaae3c641bfd548d8ccf6448097263dbbd93d",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 202,
      "deletions": 8,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -21,6 +21,7 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n+#include \"annotate.h\"\n #include \"symtab.h\"\n #include \"gdbtypes.h\"\n #include \"expression.h\"\n@@ -96,6 +97,14 @@ f77_get_dynamic_length_of_aggregate (struct type *type)\n     * TYPE_LENGTH (check_typedef (TYPE_TARGET_TYPE (type)));\n }\n \n+/* Per-dimension statistics.  */\n+\n+struct dimension_stats\n+{\n+  /* Total number of elements in the dimension, counted as we go.  */\n+  int nelts;\n+};\n+\n /* A class used by FORTRAN_PRINT_ARRAY as a specialisation of the array\n    walking template.  This specialisation prints Fortran arrays.  */\n \n@@ -117,7 +126,10 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n       m_val (val),\n       m_stream (stream),\n       m_recurse (recurse),\n-      m_options (options)\n+      m_options (options),\n+      m_dimension (0),\n+      m_nrepeats (0),\n+      m_stats (0)\n   { /* Nothing.  */ }\n \n   /* Called while iterating over the array bounds.  When SHOULD_CONTINUE is\n@@ -135,8 +147,17 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \n   /* Called when we start iterating over a dimension.  If it's not the\n      inner most dimension then print an opening '(' character.  */\n-  void start_dimension (bool inner_p)\n+  void start_dimension (LONGEST nelts, bool inner_p)\n   {\n+    size_t dim_indx = m_dimension++;\n+\n+    m_elt_type_prev = nullptr;\n+    if (m_stats.size () < m_dimension)\n+      {\n+\tm_stats.resize (m_dimension);\n+\tm_stats[dim_indx].nelts = nelts;\n+      }\n+\n     fputs_filtered (\"(\", m_stream);\n   }\n \n@@ -149,22 +170,181 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n     fputs_filtered (\")\", m_stream);\n     if (!last_p)\n       fputs_filtered (\" \", m_stream);\n+\n+    m_dimension--;\n+  }\n+\n+  /* Called when processing dimensions of the array other than the\n+     innermost one.  WALK_1 is the walker to normally call, ELT_TYPE is\n+     the type of the element being extracted, and ELT_OFF is the offset\n+     of the element from the start of array being walked, and LAST_P is\n+     true only when this is the last element that will be processed in\n+     this dimension.  */\n+  void process_dimension (gdb::function_view<void (struct type *,\n+\t\t\t\t\t\t   int, bool)> walk_1,\n+\t\t\t  struct type *elt_type, LONGEST elt_off, bool last_p)\n+  {\n+    size_t dim_indx = m_dimension - 1;\n+    struct type *elt_type_prev = m_elt_type_prev;\n+    LONGEST elt_off_prev = m_elt_off_prev;\n+    bool repeated = (m_options->repeat_count_threshold < UINT_MAX\n+\t\t     && elt_type_prev != nullptr\n+\t\t     && (m_elts + ((m_nrepeats + 1)\n+\t\t\t\t   * m_stats[dim_indx + 1].nelts)\n+\t\t\t <= m_options->print_max)\n+\t\t     && dimension_contents_eq (m_val, elt_type,\n+\t\t\t\t\t       elt_off_prev, elt_off));\n+\n+    if (repeated)\n+      m_nrepeats++;\n+    if (!repeated || last_p)\n+      {\n+\tLONGEST nrepeats = m_nrepeats;\n+\n+\tm_nrepeats = 0;\n+\tif (nrepeats >= m_options->repeat_count_threshold)\n+\t  {\n+\t    annotate_elt_rep (nrepeats + 1);\n+\t    fprintf_filtered (m_stream, \"%p[<repeats %s times>%p]\",\n+\t\t\t      metadata_style.style ().ptr (),\n+\t\t\t      plongest (nrepeats + 1),\n+\t\t\t      nullptr);\n+\t    annotate_elt_rep_end ();\n+\t    if (!repeated)\n+\t      fputs_filtered (\" \", m_stream);\n+\t    m_elts += nrepeats * m_stats[dim_indx + 1].nelts;\n+\t  }\n+\telse\n+\t  for (LONGEST i = nrepeats; i > 0; i--)\n+\t    walk_1 (elt_type_prev, elt_off_prev, repeated && i == 1);\n+\n+\tif (!repeated)\n+\t  {\n+\t    /* We need to specially handle the case of hitting `print_max'\n+\t       exactly as recursing would cause lone `(...)' to be printed.\n+\t       And we need to print `...' by hand if the skipped element\n+\t       would be the last one processed, because the subsequent call\n+\t       to `continue_walking' from our caller won't do that.  */\n+\t    if (m_elts < m_options->print_max)\n+\t      {\n+\t\twalk_1 (elt_type, elt_off, last_p);\n+\t\tnrepeats++;\n+\t      }\n+\t    else if (last_p)\n+\t      fputs_filtered (\"...\", m_stream);\n+\t  }\n+      }\n+\n+    m_elt_type_prev = elt_type;\n+    m_elt_off_prev = elt_off;\n   }\n \n   /* Called to process an element of ELT_TYPE at offset ELT_OFF from the\n      start of the parent object.  */\n   void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n   {\n-    /* Extract the element value from the parent value.  */\n-    struct value *e_val\n-      = value_from_component (m_val, elt_type, elt_off);\n-    common_val_print (e_val, m_stream, m_recurse, m_options, current_language);\n-    if (!last_p)\n-      fputs_filtered (\", \", m_stream);\n+    struct type *elt_type_prev = m_elt_type_prev;\n+    LONGEST elt_off_prev = m_elt_off_prev;\n+    bool repeated = (m_options->repeat_count_threshold < UINT_MAX\n+\t\t     && elt_type_prev != nullptr\n+\t\t     && value_contents_eq (m_val, elt_off_prev, m_val, elt_off,\n+\t\t\t\t\t   TYPE_LENGTH (elt_type)));\n+\n+    if (repeated)\n+      m_nrepeats++;\n+    if (!repeated || last_p || m_elts + 1 == m_options->print_max)\n+      {\n+\tLONGEST nrepeats = m_nrepeats;\n+\tbool printed = false;\n+\n+\tif (nrepeats != 0)\n+\t  {\n+\t    m_nrepeats = 0;\n+\t    if (nrepeats >= m_options->repeat_count_threshold)\n+\t      {\n+\t\tannotate_elt_rep (nrepeats + 1);\n+\t\tfprintf_filtered (m_stream, \"%p[<repeats %s times>%p]\",\n+\t\t\t\t  metadata_style.style ().ptr (),\n+\t\t\t\t  plongest (nrepeats + 1),\n+\t\t\t\t  nullptr);\n+\t\tannotate_elt_rep_end ();\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Extract the element value from the parent value.  */\n+\t\tstruct value *e_val\n+\t\t  = value_from_component (m_val, elt_type, elt_off_prev);\n+\n+\t\tfor (LONGEST i = nrepeats; i > 0; i--)\n+\t\t  {\n+\t\t    common_val_print (e_val, m_stream, m_recurse, m_options,\n+\t\t\t\t      current_language);\n+\t\t    if (i > 1)\n+\t\t      fputs_filtered (\", \", m_stream);\n+\t\t  }\n+\t      }\n+\t    printed = true;\n+\t  }\n+\n+\tif (!repeated)\n+\t  {\n+\t    /* Extract the element value from the parent value.  */\n+\t    struct value *e_val\n+\t      = value_from_component (m_val, elt_type, elt_off);\n+\n+\t    if (printed)\n+\t      fputs_filtered (\", \", m_stream);\n+\t    common_val_print (e_val, m_stream, m_recurse, m_options,\n+\t\t\t      current_language);\n+\t  }\n+\tif (!last_p)\n+\t  fputs_filtered (\", \", m_stream);\n+      }\n+\n+    m_elt_type_prev = elt_type;\n+    m_elt_off_prev = elt_off;\n     ++m_elts;\n   }\n \n private:\n+  /* Called to compare two VAL elements of ELT_TYPE at offsets OFFSET1\n+     and OFFSET2 each.  Handle subarrays recursively, because they may\n+     have been sliced and we do not want to compare any memory contents\n+     present between the slices requested.  */\n+  bool\n+  dimension_contents_eq (const struct value *val, struct type *type,\n+\t\t\t LONGEST offset1, LONGEST offset2)\n+  {\n+    if (type->code () == TYPE_CODE_ARRAY\n+\t&& TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_CHAR)\n+      {\n+\t/* Extract the range, and get lower and upper bounds.  */\n+\tstruct type *range_type = check_typedef (type)->index_type ();\n+\tLONGEST lowerbound, upperbound;\n+\tif (!get_discrete_bounds (range_type, &lowerbound, &upperbound))\n+\t  error (\"failed to get range bounds\");\n+\n+\t/* CALC is used to calculate the offsets for each element.  */\n+\tfortran_array_offset_calculator calc (type);\n+\n+\tstruct type *subarray_type = check_typedef (TYPE_TARGET_TYPE (type));\n+\tfor (LONGEST i = lowerbound; i < upperbound + 1; i++)\n+\t  {\n+\t    /* Use the index and the stride to work out a new offset.  */\n+\t    LONGEST index_offset = calc.index_offset (i);\n+\n+\t    if (!dimension_contents_eq (val, subarray_type,\n+\t\t\t\t\toffset1 + index_offset,\n+\t\t\t\t\toffset2 + index_offset))\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+    else\n+      return value_contents_eq (val, offset1, val, offset2,\n+\t\t\t\tTYPE_LENGTH (type));\n+  }\n+\n   /* The number of elements printed so far.  */\n   int m_elts;\n \n@@ -180,6 +360,20 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n   /* The print control options.  Gives us the maximum number of elements to\n      print, and is passed through to each element that we print.  */\n   const struct value_print_options *m_options = nullptr;\n+\n+  /* The number of the current dimension being handled.  */\n+  LONGEST m_dimension;\n+\n+  /* The number of element repetitions in the current series.  */\n+  LONGEST m_nrepeats;\n+\n+  /* The type and offset from M_VAL of the element handled in the previous\n+     iteration over the current dimension.  */\n+  struct type *m_elt_type_prev;\n+  LONGEST m_elt_off_prev;\n+\n+  /* Per-dimension stats.  */\n+  std::vector<struct dimension_stats> m_stats;\n };\n \n /* This function gets called to print a Fortran array.  */"
    },
    {
      "sha": "bf16735c7e48037b07c900f68d6ad0dde8cb5683",
      "filename": "gdb/testsuite/gdb.fortran/array-repeat.exp",
      "status": "added",
      "additions": 167,
      "deletions": 0,
      "changes": 167,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-repeat.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-repeat.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-repeat.exp?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -0,0 +1,167 @@\n+# Copyright 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the detection and printing of repeated elements in Fortran arrays.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+load_lib fortran.exp\n+\n+# Build up the expected output for each array.\n+set a9p9o \"(9, 9, 9, 9, 9, 9)\"\n+set a1p   \"(1, 1, 1, 1, 1)\"\n+set a1p9  \"(1, 1, 1, 1, 1, 9)\"\n+set a2po  \"(2, 2, 2, 2, 2)\"\n+set a2p   \"(${a2po} ${a2po} ${a2po} ${a2po} ${a2po})\"\n+set a2p9o \"(2, 2, 2, 2, 2, 9)\"\n+set a2p9  \"(${a2p9o} ${a2p9o} ${a2p9o} ${a2p9o} ${a2p9o} ${a9p9o})\"\n+set a3po  \"(3, 3, 3, 3, 3)\"\n+set a3p   \"(${a3po} ${a3po} ${a3po} ${a3po} ${a3po})\"\n+set a3p   \"(${a3p} ${a3p} ${a3p} ${a3p} ${a3p})\"\n+set a3p9o \"(3, 3, 3, 3, 3, 9)\"\n+set a3p9  \"(${a3p9o} ${a3p9o} ${a3p9o} ${a3p9o} ${a3p9o} ${a9p9o})\"\n+set a9p9  \"(${a9p9o} ${a9p9o} ${a9p9o} ${a9p9o} ${a9p9o} ${a9p9o})\"\n+set a3p9  \"(${a3p9} ${a3p9} ${a3p9} ${a3p9} ${a3p9} ${a9p9})\"\n+\n+# Convert the output into a regexp.\n+set r1p   [string_to_regexp $a1p]\n+set r1p9  [string_to_regexp $a1p9]\n+set r2po  [string_to_regexp $a2po]\n+set r2p9o [string_to_regexp $a2p9o]\n+set r2p   [string_to_regexp $a2p]\n+set r2p9  [string_to_regexp $a2p9]\n+set r3po  [string_to_regexp $a3po]\n+set r3p9o [string_to_regexp $a3p9o]\n+set r3p   [string_to_regexp $a3p]\n+set r3p9  [string_to_regexp $a3p9]\n+\n+set rep5  \"<repeats 5 times>\"\n+set rep6  \"<repeats 6 times>\"\n+\n+proc array_repeat { variant } {\n+    global testfile srcfile binfile\n+    upvar r1p r1p r1p9 r1p9 r2po r2po r2p9o r2p9o r2p r2p r2p9 r2p9\n+    upvar r3po r3po r3p9o r3p9o r3p r3p r3p9 r3p9\n+    upvar a2po a2po a2p9o a2p9o a3po a3po a3p9o a3p9o\n+    upvar rep5 rep5 rep6 rep6\n+\n+    standard_testfile \"${variant}.f90\"\n+\n+    if {[prepare_for_testing ${testfile}.exp ${variant} ${srcfile} \\\n+\t    {debug f90}]} {\n+\treturn -1\n+    }\n+\n+    if {![fortran_runto_main]} {\n+\tperror \"Could not run to main.\"\n+\tcontinue\n+    }\n+\n+    gdb_breakpoint [gdb_get_line_number \"Break here\"]\n+    gdb_continue_to_breakpoint \"${variant}\"\n+\n+    with_test_prefix \"${variant}: repeats=unlimited, elements=unlimited\" {\n+\t# Check the arrays print as expected.\n+\tgdb_test_no_output \"set print repeats unlimited\"\n+\tgdb_test_no_output \"set print elements unlimited\"\n+\n+\tgdb_test \"print array_1d\"  \"${r1p}\"\n+\tgdb_test \"print array_1d9\" \"${r1p9}\"\n+\tgdb_test \"print array_2d\"  \"${r2p}\"\n+\tgdb_test \"print array_2d9\" \"${r2p9}\"\n+\tgdb_test \"print array_3d\"  \"${r3p}\"\n+\tgdb_test \"print array_3d9\" \"${r3p9}\"\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=unlimited\" {\n+\t# Now set the repeat limit.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements unlimited\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"(1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"(1, ${rep5}, 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"((2, ${rep5}) ${rep5})\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"((2, ${rep5}, 9) ${rep5} (9, ${rep6}))\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}) ${rep5}) ${rep5})\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}, 9) ${rep5} (9, ${rep6})) ${rep5}\\\n+\t\t\t\t((9, ${rep6}) ${rep6}))\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=unlimited, elements=12\" {\n+\t# Now set the element limit.\n+\tgdb_test_no_output \"set print repeats unlimited\"\n+\tgdb_test_no_output \"set print elements 12\"\n+\n+\tgdb_test \"print array_1d\"  \"${r1p}\"\n+\tgdb_test \"print array_1d9\" \"${r1p9}\"\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"(${a2po} ${a2po} (2, 2, ...) ...)\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"(${a2p9o} ${a2p9o} ...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"((${a3po} ${a3po} (3, 3, ...) ...) ...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"((${a3p9o} ${a3p9o} ...) ...)\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=12\" {\n+\t# Now set both limits.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements 12\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"(1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"(1, ${rep5}, 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"((2, ${rep5}) (2, ${rep5}) (2, 2, ...) ...)\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"((2, ${rep5}, 9) (2, ${rep5}, 9) ...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}) (3, ${rep5}) (3, 3, ...) ...)\\\n+\t\t\t\t...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}, 9) (3, ${rep5}, 9) ...) ...)\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=30\" {\n+\t# Now set both limits.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements 30\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"(1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"(1, ${rep5}, 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"((2, ${rep5}) ${rep5})\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"((2, ${rep5}, 9) ${rep5} ...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}) ${rep5}) ((3, ${rep5}) ...)\\\n+\t\t\t\t...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"(((3, ${rep5}, 9) ${rep5} ...) ...)\"]\n+    }\n+}\n+\n+array_repeat \"array-repeat\"\n+array_repeat \"array-slices-repeat\""
    },
    {
      "sha": "adb6b2ad0e54fa0e1df93222a4572502f0b4302f",
      "filename": "gdb/testsuite/gdb.fortran/array-repeat.f90",
      "status": "added",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-repeat.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-repeat.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-repeat.f90?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -0,0 +1,50 @@\n+! Copyright 2022 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+!\n+! Start of test program.\n+!\n+program test\n+\n+  ! Declare variables used in this test.\n+  integer, dimension (-2:2) :: array_1d\n+  integer, dimension (-2:3) :: array_1d9\n+  integer, dimension (-2:2, -2:2) :: array_2d\n+  integer, dimension (-2:3, -2:3) :: array_2d9\n+  integer, dimension (-2:2, -2:2, -2:2) :: array_3d\n+  integer, dimension (-2:3, -2:3, -2:3) :: array_3d9\n+\n+  array_1d = 1\n+  array_1d9 = 1\n+  array_1d9 (3) = 9\n+  array_2d = 2\n+  array_2d9 = 2\n+  array_2d9 (3, :) = 9\n+  array_2d9 (:, 3) = 9\n+  array_3d = 3\n+  array_3d9 = 3\n+  array_3d9 (3, :, :) = 9\n+  array_3d9 (:, 3, :) = 9\n+  array_3d9 (:, :, 3) = 9\n+\n+  print *, \"\"           ! Break here\n+  print *, array_1d\n+  print *, array_1d9\n+  print *, array_2d\n+  print *, array_2d9\n+  print *, array_3d\n+  print *, array_3d9\n+\n+end program test"
    },
    {
      "sha": "3b9a9e3650c48da3e19d2de71a734bf2a0642af3",
      "filename": "gdb/testsuite/gdb.fortran/array-slices-repeat.f90",
      "status": "added",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-slices-repeat.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/array-slices-repeat.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-slices-repeat.f90?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -0,0 +1,99 @@\n+! Copyright 2022 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+subroutine show (array_1d, array_1d9, array_2d, array_2d9, array_3d, array_3d9)\n+  integer, dimension (-2:) :: array_1d\n+  integer, dimension (-2:) :: array_1d9\n+  integer, dimension (-2:, -2:) :: array_2d\n+  integer, dimension (-2:, -2:) :: array_2d9\n+  integer, dimension (-2:, -2:, -2:) :: array_3d\n+  integer, dimension (-2:, -2:, -2:) :: array_3d9\n+\n+  print *, \"\"           ! Break here\n+  print *, array_1d\n+  print *, array_1d9\n+  print *, array_2d\n+  print *, array_2d9\n+  print *, array_3d\n+  print *, array_3d9\n+end subroutine show\n+\n+!\n+! Start of test program.\n+!\n+program test\n+  interface\n+    subroutine show (array_1d, array_1d9, array_2d, array_2d9, &\n+\t\t     array_3d, array_3d9)\n+      integer, dimension (:) :: array_1d\n+      integer, dimension (:) :: array_1d9\n+      integer, dimension (:, :) :: array_2d\n+      integer, dimension (:, :) :: array_2d9\n+      integer, dimension (:, :, :) :: array_3d\n+      integer, dimension (:, :, :) :: array_3d9\n+    end subroutine show\n+  end interface\n+\n+  ! Declare variables used in this test.\n+  integer, dimension (-8:6) :: array_1d\n+  integer, dimension (-8:9) :: array_1d9\n+  integer, dimension (-8:6, -8:6) :: array_2d\n+  integer, dimension (-8:9, -8:9) :: array_2d9\n+  integer, dimension (-8:6, -8:6, -8:6) :: array_3d\n+  integer, dimension (-8:9, -8:9, -8:9) :: array_3d9\n+\n+  integer, parameter :: v6 (6) = [-5, -4, -3, 1, 2, 3]\n+  integer, parameter :: v9 (9) = [-5, -4, -3, 1, 2, 3, 7, 8, 9]\n+\n+  ! Intersperse slices selected with varying data to make sure it is\n+  ! correctly ignored for the purpose of repeated element recognition\n+  ! in the slices.\n+  array_1d = 7\n+  array_1d (::3) = 1\n+  array_1d9 = 7\n+  array_1d9 (::3) = 1\n+  array_1d9 (7) = 9\n+  array_2d = 7\n+  array_2d (:, v6) = 6\n+  array_2d (::3, ::3) = 2\n+  array_2d9 = 7\n+  array_2d9 (:, v9) = 6\n+  array_2d9 (::3, ::3) = 2\n+  array_2d9 (7, ::3) = 9\n+  array_2d9 (::3, 7) = 9\n+  array_3d = 7\n+  array_3d (:, v6, :) = 6\n+  array_3d (:, v6, v6) = 5\n+  array_3d (::3, ::3, ::3) = 3\n+  array_3d9 = 7\n+  array_3d9 (:, v9, :) = 6\n+  array_3d9 (:, v9, v9) = 5\n+  array_3d9 (::3, ::3, ::3) = 3\n+  array_3d9 (7, ::3, ::3) = 9\n+  array_3d9 (::3, 7, ::3) = 9\n+  array_3d9 (::3, ::3, 7) = 9\n+\n+  call show (array_1d (::3), array_1d9 (::3), &\n+\t     array_2d (::3, ::3), array_2d9 (::3, ::3), &\n+\t     array_3d (::3, ::3, ::3), array_3d9 (::3, ::3, ::3))\n+\n+  print *, array_1d\n+  print *, array_1d9\n+  print *, array_2d\n+  print *, array_2d9\n+  print *, array_3d\n+  print *, array_3d9\n+\n+end program test"
    },
    {
      "sha": "7b7b48940d2fe653d560ece4d61feaa28162aab9",
      "filename": "gdb/testsuite/gdb.fortran/vla-value-sub-finish.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/vla-value-sub-finish.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/vla-value-sub-finish.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/vla-value-sub-finish.exp?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -32,6 +32,8 @@ if ![fortran_runto_main] {\n # We need both variants as depending on the arch we optionally may still be\n # executing the caller line or not after `finish'.\n \n+gdb_test_no_output \"set print repeats unlimited\"\n+\n gdb_breakpoint [gdb_get_line_number \"array2-almost-filled\"]\n gdb_continue_to_breakpoint \"array2-almost-filled\"\n # array2 size is 296352 bytes."
    },
    {
      "sha": "b7ab7a517268b5f30d765388dbfd9b29a5d6b454",
      "filename": "gdb/testsuite/gdb.fortran/vla-value-sub.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/vla-value-sub.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/476f77a94cd51aede979e1b54c46cebe2ec9dde9/gdb/testsuite/gdb.fortran/vla-value-sub.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/vla-value-sub.exp?ref=476f77a94cd51aede979e1b54c46cebe2ec9dde9",
      "patch": "@@ -29,6 +29,8 @@ if ![fortran_runto_main] {\n \n # Check the values of VLA's in subroutine can be evaluated correctly\n \n+gdb_test_no_output \"set print repeats unlimited\"\n+\n # Try to access values from a fixed array handled as VLA in subroutine.\n gdb_breakpoint [gdb_get_line_number \"not-filled\"]\n gdb_continue_to_breakpoint \"not-filled (1st)\""
    }
  ]
}