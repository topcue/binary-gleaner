{
  "sha": "676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Njc2YzNlY2JhZDZlOWM0MWI5MDZiMGY4ODJlZjJjZTIzZjQ5OTc2YQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-08-07T16:55:09Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:56Z"
    },
    "message": "libctf: avoid the need to ever use ctf_update\n\nThe method of operation of libctf when the dictionary is writable has\nbefore now been that types that are added land in the dynamic type\nsection, which is a linked list and hash of IDs -> dynamic type\ndefinitions (and, recently a hash of names): the DTDs are a bit of CTF\nrepresenting the ctf_type_t and ad hoc C structures representing the\nvlen.  Historically, libctf was unable to do anything with these types,\nnot even look them up by ID, let alone by name: if you wanted to do that\nsay if you were adding a type that depended on one you just added) you\ncalled ctf_update, which serializes all the DTDs into a CTF file and\nreopens it, copying its guts over the fp it's called with.  The\nctf_updated types are then frozen in amber and unchangeable: all lookups\nwill return the types in the static portion in preference to the dynamic\nportion, and we will refuse to re-add things that already exist in the\nstatic portion (and, of late, in the dynamic portion too).  The libctf\nmachinery remembers the boundary between static and dynamic types and\nlooks in the right portion for each type.  Lots of things still don't\nquite work with dynamic types (e.g. getting their size), but enough\nworks to do a bunch of additions and then a ctf_update, most of the\ntime.\n\nExcept it doesn't, because ctf_add_type finds it necessary to walk the\nfull dynamic type definition list looking for types with matching names,\nso it gets slower and slower with every type you add: fixing this\nrequires calling ctf_update periodically for no other reason than to\navoid massively slowing things down.\n\nThis is all clunky and very slow but kind of works, until you consider\nthat it is in fact possible and indeed necessary to modify one sort of\ntype after it has been added: forwards.  These are necessarily promoted\nto structs, unions or enums, and when they do so *their type ID does not\nchange*.  So all of a sudden we are changing types that already exist in\nthe static portion.  ctf_update gets massively confused by this and\nallocates space enough for the forward (with no members), but then emits\nthe new dynamic type (with all the members) into it.  You get an\nassertion failure after that, if you're lucky, or a coredump.\n\nSo this commit rejigs things a bit and arranges to exclusively use the\ndynamic type definitions in writable dictionaries, and the static type\ndefinitions in readable dictionaries: we don't at any time have a mixture\nof static and dynamic types, and you don't need to call ctf_update to\nmake things \"appear\".  The ctf_dtbyname hash I introduced a few months\nago, which maps things like \"struct foo\" to DTDs, is removed, replaced\ninstead by a change of type of the four dictionaries which track names.\nRather than just being (unresizable) ctf_hash_t's populated only at\nctf_bufopen time, they are now a ctf_names_t structure, which is a pair\nof ctf_hash_t and ctf_dynhash_t, with the ctf_hash_t portion being used\nin readonly dictionaries, and the ctf_dynhash_t being used in writable\nones.  The decision as to which to use is centralized in the new\nfunctions ctf_lookup_by_rawname (which takes a type kind) and\nctf_lookup_by_rawhash, which it calls (which takes a ctf_names_t *.)\n\nThis change lets us switch from using static to dynamic name hashes on\nthe fly across the entirety of libctf without complexifying anything: in\nfact, because we now centralize the knowledge about how to map from type\nkind to name hash, it actually simplifies things and lets us throw out\nquite a lot of now-unnecessary complexity, from ctf_dtnyname (replaced\nby the dynamic half of the name tables), through to ctf_dtnextid (now\nthat a dictionary's static portion is never referenced if the dictionary\nis writable, we can just use ctf_typemax to indicate the maximum type:\ndynamic or non-dynamic does not matter, and we no longer need to track\nthe boundary between the types).  You can now ctf_rollback() as far as\nyou like, even past a ctf_update or for that matter a full writeout; all\nthe iteration functions work just as well on writable as on read-only\ndictionaries; ctf_add_type no longer needs expensive duplicated code to\nrun over the dynamic types hunting for ones it might be interested in;\nand the linker no longer needs a hack to call ctf_update so that calling\nctf_add_type is not impossibly expensive.\n\nThere is still a bit more complexity: some new code paths in ctf-types.c\nneed to know how to extract information from dynamic types.  This\ncomplexity will go away again in a few months when libctf acquires a\nproper intermediate representation.\n\nYou can still call ctf_update if you like (it's public API, after all),\nbut its only effect now is to set the point to which ctf_discard rolls\nback.\n\nObviously *something* still needs to serialize the CTF file before\nwriteout, and this job is done by ctf_serialize, which does everything\nctf_update used to except set the counter used by ctf_discard.  It is\nautomatically called by the various functions that do CTF writeout:\nnobody else ever needs to call it.\n\nWith this in place, forwards that are promoted to non-forwards no longer\ncrash the link, even if it happens tens of thousands of types later.\n\nv5: fix tabdamage.\n\nlibctf/\n\t* ctf-impl.h (ctf_names_t): New.\n\t(ctf_lookup_t) <ctf_hash>: Now a ctf_names_t, not a ctf_hash_t.\n\t(ctf_file_t) <ctf_structs>: Likewise.\n\t<ctf_unions>: Likewise.\n\t<ctf_enums>: Likewise.\n\t<ctf_names>: Likewise.\n\t<ctf_lookups>: Improve comment.\n\t<ctf_ptrtab_len>: New.\n\t<ctf_prov_strtab>: New.\n\t<ctf_str_prov_offset>: New.\n\t<ctf_dtbyname>: Remove, redundant to the names hashes.\n\t<ctf_dtnextid>: Remove, redundant to ctf_typemax.\n\t(ctf_dtdef_t) <dtd_name>: Remove.\n\t<dtd_data>: Note that the ctt_name is now populated.\n\t(ctf_str_atom_t) <csa_offset>: This is now the strtab\n\toffset for internal strings too.\n\t<csa_external_offset>: New, the external strtab offset.\n\t(CTF_INDEX_TO_TYPEPTR): Handle the LCTF_RDWR case.\n\t(ctf_name_table): New declaration.\n\t(ctf_lookup_by_rawname): Likewise.\n\t(ctf_lookup_by_rawhash): Likewise.\n\t(ctf_set_ctl_hashes): Likewise.\n\t(ctf_serialize): Likewise.\n\t(ctf_dtd_insert): Adjust.\n\t(ctf_simple_open_internal): Likewise.\n\t(ctf_bufopen_internal): Likewise.\n\t(ctf_list_empty_p): Likewise.\n\t(ctf_str_remove_ref): Likewise.\n\t(ctf_str_add): Returns uint32_t now.\n\t(ctf_str_add_ref): Likewise.\n\t(ctf_str_add_external): Now returns a boolean (int).\n\t* ctf-string.c (ctf_strraw_explicit): Check the ctf_prov_strtab\n\tfor strings in the appropriate range.\n\t(ctf_str_create_atoms): Create the ctf_prov_strtab.  Detect OOM\n\twhen adding the null string to the new strtab.\n\t(ctf_str_free_atoms): Destroy the ctf_prov_strtab.\n\t(ctf_str_add_ref_internal): Add make_provisional argument.  If\n\tmake_provisional, populate the offset and fill in the\n\tctf_prov_strtab accordingly.\n\t(ctf_str_add): Return the offset, not the string.\n\t(ctf_str_add_ref): Likewise.\n\t(ctf_str_add_external): Return a success integer.\n\t(ctf_str_remove_ref): New, remove a single ref.\n\t(ctf_str_count_strtab): Do not count the initial null string's\n\tlength or the existence or length of any unreferenced internal\n\tatoms.\n\t(ctf_str_populate_sorttab): Skip atoms with no refs.\n\t(ctf_str_write_strtab): Populate the nullstr earlier.  Add one\n\tto the cts_len for the null string, since it is no longer done\n\tin ctf_str_count_strtab.  Adjust for csa_external_offset rename.\n\tPopulate the csa_offset for both internal and external cases.\n\tFlush the ctf_prov_strtab afterwards, and reset the\n\tctf_str_prov_offset.\n\t* ctf-create.c (ctf_grow_ptrtab): New.\n\t(ctf_create): Call it.\tInitialize new fields rather than old\n\tones.  Tell ctf_bufopen_internal that this is a writable dictionary.\n\tSet the ctl hashes and data model.\n\t(ctf_update): Rename to...\n\t(ctf_serialize): ... this.  Leave a compatibility function behind.\n\tTell ctf_simple_open_internal that this is a writable dictionary.\n\tPass the new fields along from the old dictionary.  Drop\n\tctf_dtnextid and ctf_dtbyname.\tUse ctf_strraw, not dtd_name.\n\tDo not zero out the DTD's ctt_name.\n\t(ctf_prefixed_name): Rename to...\n\t(ctf_name_table): ... this.  No longer return a prefixed name: return\n\tthe applicable name table instead.\n\t(ctf_dtd_insert): Use it, and use the right name table.\t Pass in the\n\tkind we're adding.  Migrate away from dtd_name.\n\t(ctf_dtd_delete): Adjust similarly.  Remove the ref to the\n\tdeleted ctt_name.\n\t(ctf_dtd_lookup_type_by_name): Remove.\n\t(ctf_dynamic_type): Always return NULL on read-only dictionaries.\n\tNo longer check ctf_dtnextid: check ctf_typemax instead.\n\t(ctf_snapshot): No longer use ctf_dtnextid: use ctf_typemax instead.\n\t(ctf_rollback): Likewise.  No longer fail with ECTF_OVERROLLBACK. Use\n\tctf_name_table and the right name table, and migrate away from\n\tdtd_name as in ctf_dtd_delete.\n\t(ctf_add_generic): Pass in the kind explicitly and pass it to\n\tctf_dtd_insert. Use ctf_typemax, not ctf_dtnextid.  Migrate away\n\tfrom dtd_name to using ctf_str_add_ref to populate the ctt_name.\n\tGrow the ptrtab if needed.\n\t(ctf_add_encoded): Pass in the kind.\n\t(ctf_add_slice): Likewise.\n\t(ctf_add_array): Likewise.\n\t(ctf_add_function): Likewise.\n\t(ctf_add_typedef): Likewise.\n\t(ctf_add_reftype): Likewise. Initialize the ctf_ptrtab, checking\n\tctt_name rather than dtd_name.\n\t(ctf_add_struct_sized): Pass in the kind.  Use\n\tctf_lookup_by_rawname, not ctf_hash_lookup_type /\n\tctf_dtd_lookup_type_by_name.\n\t(ctf_add_union_sized): Likewise.\n\t(ctf_add_enum): Likewise.\n\t(ctf_add_enum_encoded): Likewise.\n\t(ctf_add_forward): Likewise.\n\t(ctf_add_type): Likewise.\n\t(ctf_compress_write): Call ctf_serialize: adjust for ctf_size not\n\tbeing initialized until after the call.\n\t(ctf_write_mem): Likewise.\n\t(ctf_write): Likewise.\n\t* ctf-archive.c (arc_write_one_ctf): Likewise.\n\t* ctf-lookup.c (ctf_lookup_by_name): Use ctf_lookuup_by_rawhash, not\n\tctf_hash_lookup_type.\n\t(ctf_lookup_by_id): No longer check the readonly types if the\n\tdictionary is writable.\n\t* ctf-open.c (init_types): Assert that this dictionary is not\n\twritable.  Adjust to use the new name hashes, ctf_name_table,\n\tand ctf_ptrtab_len.  GNU style fix for the final ptrtab scan.\n\t(ctf_bufopen_internal): New 'writable' parameter.  Flip on LCTF_RDWR\n\tif set.\t Drop out early when dictionary is writable.  Split the\n\tctf_lookups initialization into...\n\t(ctf_set_cth_hashes): ... this new function.\n\t(ctf_simple_open_internal): Adjust.  New 'writable' parameter.\n\t(ctf_simple_open): Adjust accordingly.\n\t(ctf_bufopen): Likewise.\n\t(ctf_file_close): Destroy the appropriate name hashes.\tNo longer\n\tdestroy ctf_dtbyname, which is gone.\n\t(ctf_getdatasect): Remove spurious \"extern\".\n\t* ctf-types.c (ctf_lookup_by_rawname): New, look up types in the\n\tspecified name table, given a kind.\n\t(ctf_lookup_by_rawhash): Likewise, given a ctf_names_t *.\n\t(ctf_member_iter): Add support for iterating over the\n\tdynamic type list.\n\t(ctf_enum_iter): Likewise.\n\t(ctf_variable_iter): Likewise.\n\t(ctf_type_rvisit): Likewise.\n\t(ctf_member_info): Add support for types in the dynamic type list.\n\t(ctf_enum_name): Likewise.\n\t(ctf_enum_value): Likewise.\n\t(ctf_func_type_info): Likewise.\n\t(ctf_func_type_args): Likewise.\n\t* ctf-link.c (ctf_accumulate_archive_names): No longer call\n\tctf_update.\n\t(ctf_link_write): Likewise.\n\t(ctf_link_intern_extern_string): Adjust for new\n\tctf_str_add_external return value.\n\t(ctf_link_add_strtab): Likewise.\n\t* ctf-util.c (ctf_list_empty_p): New.",
    "tree": {
      "sha": "3fac550f8df05fe8726316fa17fd5d99ad59f4e8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3fac550f8df05fe8726316fa17fd5d99ad59f4e8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "791915db4273edbfb1952897cbf4c9745101c0e4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/791915db4273edbfb1952897cbf4c9745101c0e4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/791915db4273edbfb1952897cbf4c9745101c0e4"
    }
  ],
  "stats": {
    "total": 1318,
    "additions": 896,
    "deletions": 422
  },
  "files": [
    {
      "sha": "723db81f182f0933e566249441063f90afc30ab2",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 141,
      "deletions": 0,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -1,3 +1,144 @@\n+2019-08-09  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_names_t): New.\n+\t(ctf_lookup_t) <ctf_hash>: Now a ctf_names_t, not a ctf_hash_t.\n+\t(ctf_file_t) <ctf_structs>: Likewise.\n+\t<ctf_unions>: Likewise.\n+\t<ctf_enums>: Likewise.\n+\t<ctf_names>: Likewise.\n+\t<ctf_lookups>: Improve comment.\n+\t<ctf_ptrtab_len>: New.\n+\t<ctf_prov_strtab>: New.\n+\t<ctf_str_prov_offset>: New.\n+\t<ctf_dtbyname>: Remove, redundant to the names hashes.\n+\t<ctf_dtnextid>: Remove, redundant to ctf_typemax.\n+\t(ctf_dtdef_t) <dtd_name>: Remove.\n+\t<dtd_data>: Note that the ctt_name is now populated.\n+\t(ctf_str_atom_t) <csa_offset>: This is now the strtab\n+\toffset for internal strings too.\n+\t<csa_external_offset>: New, the external strtab offset.\n+\t(CTF_INDEX_TO_TYPEPTR): Handle the LCTF_RDWR case.\n+\t(ctf_name_table): New declaration.\n+\t(ctf_lookup_by_rawname): Likewise.\n+\t(ctf_lookup_by_rawhash): Likewise.\n+\t(ctf_set_ctl_hashes): Likewise.\n+\t(ctf_serialize): Likewise.\n+\t(ctf_dtd_insert): Adjust.\n+\t(ctf_simple_open_internal): Likewise.\n+\t(ctf_bufopen_internal): Likewise.\n+\t(ctf_list_empty_p): Likewise.\n+\t(ctf_str_remove_ref): Likewise.\n+\t(ctf_str_add): Returns uint32_t now.\n+\t(ctf_str_add_ref): Likewise.\n+\t(ctf_str_add_external): Now returns a boolean (int).\n+\t* ctf-string.c (ctf_strraw_explicit): Check the ctf_prov_strtab\n+\tfor strings in the appropriate range.\n+\t(ctf_str_create_atoms): Create the ctf_prov_strtab.  Detect OOM\n+\twhen adding the null string to the new strtab.\n+\t(ctf_str_free_atoms): Destroy the ctf_prov_strtab.\n+\t(ctf_str_add_ref_internal): Add make_provisional argument.  If\n+\tmake_provisional, populate the offset and fill in the\n+\tctf_prov_strtab accordingly.\n+\t(ctf_str_add): Return the offset, not the string.\n+\t(ctf_str_add_ref): Likewise.\n+\t(ctf_str_add_external): Return a success integer.\n+\t(ctf_str_remove_ref): New, remove a single ref.\n+\t(ctf_str_count_strtab): Do not count the initial null string's\n+\tlength or the existence or length of any unreferenced internal\n+\tatoms.\n+\t(ctf_str_populate_sorttab): Skip atoms with no refs.\n+\t(ctf_str_write_strtab): Populate the nullstr earlier.  Add one\n+\tto the cts_len for the null string, since it is no longer done\n+\tin ctf_str_count_strtab.  Adjust for csa_external_offset rename.\n+\tPopulate the csa_offset for both internal and external cases.\n+\tFlush the ctf_prov_strtab afterwards, and reset the\n+\tctf_str_prov_offset.\n+\t* ctf-create.c (ctf_grow_ptrtab): New.\n+\t(ctf_create): Call it.\tInitialize new fields rather than old\n+\tones.  Tell ctf_bufopen_internal that this is a writable dictionary.\n+\tSet the ctl hashes and data model.\n+\t(ctf_update): Rename to...\n+\t(ctf_serialize): ... this.  Leave a compatibility function behind.\n+\tTell ctf_simple_open_internal that this is a writable dictionary.\n+\tPass the new fields along from the old dictionary.  Drop\n+\tctf_dtnextid and ctf_dtbyname.\tUse ctf_strraw, not dtd_name.\n+\tDo not zero out the DTD's ctt_name.\n+\t(ctf_prefixed_name): Rename to...\n+\t(ctf_name_table): ... this.  No longer return a prefixed name: return\n+\tthe applicable name table instead.\n+\t(ctf_dtd_insert): Use it, and use the right name table.\t Pass in the\n+\tkind we're adding.  Migrate away from dtd_name.\n+\t(ctf_dtd_delete): Adjust similarly.  Remove the ref to the\n+\tdeleted ctt_name.\n+\t(ctf_dtd_lookup_type_by_name): Remove.\n+\t(ctf_dynamic_type): Always return NULL on read-only dictionaries.\n+\tNo longer check ctf_dtnextid: check ctf_typemax instead.\n+\t(ctf_snapshot): No longer use ctf_dtnextid: use ctf_typemax instead.\n+\t(ctf_rollback): Likewise.  No longer fail with ECTF_OVERROLLBACK. Use\n+\tctf_name_table and the right name table, and migrate away from\n+\tdtd_name as in ctf_dtd_delete.\n+\t(ctf_add_generic): Pass in the kind explicitly and pass it to\n+\tctf_dtd_insert. Use ctf_typemax, not ctf_dtnextid.  Migrate away\n+\tfrom dtd_name to using ctf_str_add_ref to populate the ctt_name.\n+\tGrow the ptrtab if needed.\n+\t(ctf_add_encoded): Pass in the kind.\n+\t(ctf_add_slice): Likewise.\n+\t(ctf_add_array): Likewise.\n+\t(ctf_add_function): Likewise.\n+\t(ctf_add_typedef): Likewise.\n+\t(ctf_add_reftype): Likewise. Initialize the ctf_ptrtab, checking\n+\tctt_name rather than dtd_name.\n+\t(ctf_add_struct_sized): Pass in the kind.  Use\n+\tctf_lookup_by_rawname, not ctf_hash_lookup_type /\n+\tctf_dtd_lookup_type_by_name.\n+\t(ctf_add_union_sized): Likewise.\n+\t(ctf_add_enum): Likewise.\n+\t(ctf_add_enum_encoded): Likewise.\n+\t(ctf_add_forward): Likewise.\n+\t(ctf_add_type): Likewise.\n+\t(ctf_compress_write): Call ctf_serialize: adjust for ctf_size not\n+\tbeing initialized until after the call.\n+\t(ctf_write_mem): Likewise.\n+\t(ctf_write): Likewise.\n+\t* ctf-archive.c (arc_write_one_ctf): Likewise.\n+\t* ctf-lookup.c (ctf_lookup_by_name): Use ctf_lookuup_by_rawhash, not\n+\tctf_hash_lookup_type.\n+\t(ctf_lookup_by_id): No longer check the readonly types if the\n+\tdictionary is writable.\n+\t* ctf-open.c (init_types): Assert that this dictionary is not\n+\twritable.  Adjust to use the new name hashes, ctf_name_table,\n+\tand ctf_ptrtab_len.  GNU style fix for the final ptrtab scan.\n+\t(ctf_bufopen_internal): New 'writable' parameter.  Flip on LCTF_RDWR\n+\tif set.\t Drop out early when dictionary is writable.  Split the\n+\tctf_lookups initialization into...\n+\t(ctf_set_cth_hashes): ... this new function.\n+\t(ctf_simple_open_internal): Adjust.  New 'writable' parameter.\n+\t(ctf_simple_open): Adjust accordingly.\n+\t(ctf_bufopen): Likewise.\n+\t(ctf_file_close): Destroy the appropriate name hashes.\tNo longer\n+\tdestroy ctf_dtbyname, which is gone.\n+\t(ctf_getdatasect): Remove spurious \"extern\".\n+\t* ctf-types.c (ctf_lookup_by_rawname): New, look up types in the\n+\tspecified name table, given a kind.\n+\t(ctf_lookup_by_rawhash): Likewise, given a ctf_names_t *.\n+\t(ctf_member_iter): Add support for iterating over the\n+\tdynamic type list.\n+\t(ctf_enum_iter): Likewise.\n+\t(ctf_variable_iter): Likewise.\n+\t(ctf_type_rvisit): Likewise.\n+\t(ctf_member_info): Add support for types in the dynamic type list.\n+\t(ctf_enum_name): Likewise.\n+\t(ctf_enum_value): Likewise.\n+\t(ctf_func_type_info): Likewise.\n+\t(ctf_func_type_args): Likewise.\n+\t* ctf-link.c (ctf_accumulate_archive_names): No longer call\n+\tctf_update.\n+\t(ctf_link_write): Likewise.\n+\t(ctf_link_intern_extern_string): Adjust for new\n+\tctf_str_add_external return value.\n+\t(ctf_link_add_strtab): Likewise.\n+\t* ctf-util.c (ctf_list_empty_p): New.\n+\n 2019-08-05  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-types.c (ctf_type_resolve): Return ECTF_NONREPRESENTABLE on"
    },
    {
      "sha": "ed1483ade75af7a87b24675e18efa1e2c9f70865",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -267,6 +267,9 @@ arc_write_one_ctf (ctf_file_t * f, int fd, size_t threshold)\n   size_t ctfsz_len;\n   int (*writefn) (ctf_file_t * fp, int fd);\n \n+  if (ctf_serialize (f) < 0)\n+    return f->ctf_errno * -1;\n+\n   if ((off = lseek (fd, 0, SEEK_CUR)) < 0)\n     return errno * -1;\n "
    },
    {
      "sha": "16e7de85c157af3dc5f630cbdf185a67e2c6ffd9",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 235,
      "deletions": 188,
      "changes": 423,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -27,6 +27,40 @@\n #define roundup(x, y)  ((((x) + ((y) - 1)) / (y)) * (y))\n #endif\n \n+/* Make sure the ptrtab has enough space for at least one more type.\n+\n+   We start with 4KiB of ptrtab, enough for a thousand types, then grow it 25%\n+   at a time.  */\n+\n+static int\n+ctf_grow_ptrtab (ctf_file_t *fp)\n+{\n+  size_t new_ptrtab_len = fp->ctf_ptrtab_len;\n+\n+  /* We allocate one more ptrtab entry than we need, for the initial zero,\n+     plus one because the caller will probably allocate a new type.  */\n+\n+  if (fp->ctf_ptrtab == NULL)\n+    new_ptrtab_len = 1024;\n+  else if ((fp->ctf_typemax + 2) > fp->ctf_ptrtab_len)\n+    new_ptrtab_len = fp->ctf_ptrtab_len * 1.25;\n+\n+  if (new_ptrtab_len != fp->ctf_ptrtab_len)\n+    {\n+      uint32_t *new_ptrtab;\n+\n+      if ((new_ptrtab = realloc (fp->ctf_ptrtab,\n+\t\t\t\t new_ptrtab_len * sizeof (uint32_t))) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+\n+      fp->ctf_ptrtab = new_ptrtab;\n+      memset (fp->ctf_ptrtab + fp->ctf_ptrtab_len, 0,\n+\t      (new_ptrtab_len - fp->ctf_ptrtab_len) * sizeof (uint32_t));\n+      fp->ctf_ptrtab_len = new_ptrtab_len;\n+    }\n+  return 0;\n+}\n+\n /* To create an empty CTF container, we just declare a zeroed header and call\n    ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w\n    and initialize the dynamic members.  We start assigning type IDs at 1 because\n@@ -39,7 +73,7 @@ ctf_create (int *errp)\n \n   ctf_dynhash_t *dthash;\n   ctf_dynhash_t *dvhash;\n-  ctf_dynhash_t *dtbyname;\n+  ctf_dynhash_t *structs = NULL, *unions = NULL, *enums = NULL, *names = NULL;\n   ctf_sect_t cts;\n   ctf_file_t *fp;\n \n@@ -60,9 +94,15 @@ ctf_create (int *errp)\n       goto err_dt;\n     }\n \n-  dtbyname = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n-\t\t\t\t free, NULL);\n-  if (dtbyname == NULL)\n+  structs = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\tNULL, NULL);\n+  unions = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t       NULL, NULL);\n+  enums = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t      NULL, NULL);\n+  names = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t      NULL, NULL);\n+  if (!structs || !unions || !enums || !names)\n     {\n       ctf_set_open_errno (errp, EAGAIN);\n       goto err_dv;\n@@ -73,23 +113,35 @@ ctf_create (int *errp)\n   cts.cts_size = sizeof (hdr);\n   cts.cts_entsize = 1;\n \n-  if ((fp = ctf_bufopen (&cts, NULL, NULL, errp)) == NULL)\n-      goto err_dtbyname;\n+  if ((fp = ctf_bufopen_internal (&cts, NULL, NULL, NULL, 1, errp)) == NULL)\n+    goto err_dv;\n \n-  fp->ctf_flags |= LCTF_RDWR;\n-  fp->ctf_dtbyname = dtbyname;\n+  fp->ctf_structs.ctn_writable = structs;\n+  fp->ctf_unions.ctn_writable = unions;\n+  fp->ctf_enums.ctn_writable = enums;\n+  fp->ctf_names.ctn_writable = names;\n   fp->ctf_dthash = dthash;\n   fp->ctf_dvhash = dvhash;\n-  fp->ctf_dtnextid = 1;\n   fp->ctf_dtoldid = 0;\n   fp->ctf_snapshots = 1;\n   fp->ctf_snapshot_lu = 0;\n \n+  ctf_set_ctl_hashes (fp);\n+  ctf_setmodel (fp, CTF_MODEL_NATIVE);\n+  if (ctf_grow_ptrtab (fp) < 0)\n+    {\n+      ctf_set_open_errno (errp, ctf_errno (fp));\n+      ctf_file_close (fp);\n+      return NULL;\n+    }\n+\n   return fp;\n \n- err_dtbyname:\n-  ctf_dynhash_destroy (dtbyname);\n  err_dv:\n+  ctf_dynhash_destroy (structs);\n+  ctf_dynhash_destroy (unions);\n+  ctf_dynhash_destroy (enums);\n+  ctf_dynhash_destroy (names);\n   ctf_dynhash_destroy (dvhash);\n  err_dt:\n   ctf_dynhash_destroy (dthash);\n@@ -187,22 +239,29 @@ ctf_sort_var (const void *one_, const void *two_, void *arg_)\n \t\t  ctf_strraw_explicit (arg->fp, two->ctv_name, arg->strtab)));\n }\n \n-/* If the specified CTF container is writable and has been modified, reload this\n-   container with the updated type definitions.  In order to make this code and\n-   the rest of libctf as simple as possible, we perform updates by taking the\n-   dynamic type definitions and creating an in-memory CTF file containing the\n-   definitions, and then call ctf_simple_open_internal() on it.  This not only\n-   leverages ctf_simple_open(), but also avoids having to bifurcate the rest of\n-   the library code with different lookup paths for static and dynamic type\n-   definitions.  We are therefore optimizing greatly for lookup over update,\n-   which we assume will be an uncommon operation.  We perform one extra trick\n-   here for the benefit of callers and to keep our code simple:\n-   ctf_simple_open_internal() will return a new ctf_file_t, but we want to keep\n-   the fp constant for the caller, so after ctf_simple_open_internal() returns,\n-   we use memcpy to swap the interior of the old and new ctf_file_t's, and then\n-   free the old.  */\n+/* Compatibility: just update the threshold for ctf_discard.  */\n int\n ctf_update (ctf_file_t *fp)\n+{\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  fp->ctf_dtoldid = fp->ctf_typemax;\n+  return 0;\n+}\n+\n+/* If the specified CTF container is writable and has been modified, reload this\n+   container with the updated type definitions, ready for serialization.  In\n+   order to make this code and the rest of libctf as simple as possible, we\n+   perform updates by taking the dynamic type definitions and creating an\n+   in-memory CTF file containing the definitions, and then call\n+   ctf_simple_open_internal() on it.  We perform one extra trick here for the\n+   benefit of callers and to keep our code simple: ctf_simple_open_internal()\n+   will return a new ctf_file_t, but we want to keep the fp constant for the\n+   caller, so after ctf_simple_open_internal() returns, we use memcpy to swap\n+   the interior of the old and new ctf_file_t's, and then free the old.  */\n+int\n+ctf_serialize (ctf_file_t *fp)\n {\n   ctf_file_t ofp, *nfp;\n   ctf_header_t hdr, *hdrp;\n@@ -335,8 +394,7 @@ ctf_update (ctf_file_t *fp)\n       uint32_t encoding;\n       size_t len;\n       ctf_stype_t *copied;\n-\n-      dtd->dtd_data.ctt_name = 0;\n+      const char *name;\n \n       if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n \tlen = sizeof (ctf_stype_t);\n@@ -345,8 +403,9 @@ ctf_update (ctf_file_t *fp)\n \n       memcpy (t, &dtd->dtd_data, len);\n       copied = (ctf_stype_t *) t;  /* name is at the start: constant offset.  */\n-      if (dtd->dtd_name)\n-\tctf_str_add_ref (fp, dtd->dtd_name, &copied->ctt_name);\n+      if (copied->ctt_name\n+\t  && (name = ctf_strraw (fp, copied->ctt_name)) != NULL)\n+\tctf_str_add_ref (fp, name, &copied->ctt_name);\n       t += len;\n \n       switch (kind)\n@@ -448,7 +507,7 @@ ctf_update (ctf_file_t *fp)\n \n   if ((nfp = ctf_simple_open_internal ((char *) buf, buf_size, NULL, 0,\n \t\t\t\t       0, NULL, 0, fp->ctf_syn_ext_strtab,\n-\t\t\t\t       &err)) == NULL)\n+\t\t\t\t       1, &err)) == NULL)\n     {\n       ctf_free (buf);\n       return (ctf_set_errno (fp, err));\n@@ -463,15 +522,16 @@ ctf_update (ctf_file_t *fp)\n     nfp->ctf_dynbase = buf;\t\t/* Make sure buf is freed on close.  */\n   nfp->ctf_dthash = fp->ctf_dthash;\n   nfp->ctf_dtdefs = fp->ctf_dtdefs;\n-  nfp->ctf_dtbyname = fp->ctf_dtbyname;\n   nfp->ctf_dvhash = fp->ctf_dvhash;\n   nfp->ctf_dvdefs = fp->ctf_dvdefs;\n-  nfp->ctf_dtnextid = fp->ctf_dtnextid;\n-  nfp->ctf_dtoldid = fp->ctf_dtnextid - 1;\n+  nfp->ctf_dtoldid = fp->ctf_dtoldid;\n   nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n   nfp->ctf_specific = fp->ctf_specific;\n+  nfp->ctf_ptrtab = fp->ctf_ptrtab;\n+  nfp->ctf_ptrtab_len = fp->ctf_ptrtab_len;\n   nfp->ctf_link_inputs = fp->ctf_link_inputs;\n   nfp->ctf_link_outputs = fp->ctf_link_outputs;\n+  nfp->ctf_str_prov_offset = fp->ctf_str_prov_offset;\n   nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n   nfp->ctf_link_cu_mapping = fp->ctf_link_cu_mapping;\n   nfp->ctf_link_type_mapping = fp->ctf_link_type_mapping;\n@@ -480,12 +540,20 @@ ctf_update (ctf_file_t *fp)\n \n   nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n \n-  fp->ctf_dtbyname = NULL;\n+  memcpy (&nfp->ctf_lookups, fp->ctf_lookups, sizeof (fp->ctf_lookups));\n+  nfp->ctf_structs = fp->ctf_structs;\n+  nfp->ctf_unions = fp->ctf_unions;\n+  nfp->ctf_enums = fp->ctf_enums;\n+  nfp->ctf_names = fp->ctf_names;\n+\n   fp->ctf_dthash = NULL;\n   ctf_str_free_atoms (nfp);\n   nfp->ctf_str_atoms = fp->ctf_str_atoms;\n+  nfp->ctf_prov_strtab = fp->ctf_prov_strtab;\n   fp->ctf_str_atoms = NULL;\n+  fp->ctf_prov_strtab = NULL;\n   memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n+  fp->ctf_ptrtab = NULL;\n   fp->ctf_link_inputs = NULL;\n   fp->ctf_link_outputs = NULL;\n   fp->ctf_syn_ext_strtab = NULL;\n@@ -494,63 +562,54 @@ ctf_update (ctf_file_t *fp)\n \n   fp->ctf_dvhash = NULL;\n   memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n+  memset (fp->ctf_lookups, 0, sizeof (fp->ctf_lookups));\n+  fp->ctf_structs.ctn_writable = NULL;\n+  fp->ctf_unions.ctn_writable = NULL;\n+  fp->ctf_enums.ctn_writable = NULL;\n+  fp->ctf_names.ctn_writable = NULL;\n \n   memcpy (&ofp, fp, sizeof (ctf_file_t));\n   memcpy (fp, nfp, sizeof (ctf_file_t));\n   memcpy (nfp, &ofp, sizeof (ctf_file_t));\n \n-  /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n-     array of type name prefixes and the corresponding ctf_dynhash to use.\n-     NOTE: This code must be kept in sync with the code in ctf_bufopen().  */\n-\n-  fp->ctf_lookups[0].ctl_hash = fp->ctf_structs;\n-  fp->ctf_lookups[1].ctl_hash = fp->ctf_unions;\n-  fp->ctf_lookups[2].ctl_hash = fp->ctf_enums;\n-  fp->ctf_lookups[3].ctl_hash = fp->ctf_names;\n-\n   nfp->ctf_refcnt = 1;\t\t/* Force nfp to be freed.  */\n   ctf_file_close (nfp);\n \n   return 0;\n }\n \n-static char *\n-ctf_prefixed_name (int kind, const char *name)\n+ctf_names_t *\n+ctf_name_table (ctf_file_t *fp, int kind)\n {\n-  char *prefixed;\n-\n   switch (kind)\n     {\n     case CTF_K_STRUCT:\n-      prefixed = ctf_strdup (\"struct \");\n-      break;\n+      return &fp->ctf_structs;\n     case CTF_K_UNION:\n-      prefixed = ctf_strdup (\"union \");\n-      break;\n+      return &fp->ctf_unions;\n     case CTF_K_ENUM:\n-      prefixed = ctf_strdup (\"enum \");\n-      break;\n+      return &fp->ctf_enums;\n     default:\n-      prefixed = ctf_strdup (\"\");\n+      return &fp->ctf_names;\n     }\n-\n-  prefixed = ctf_str_append (prefixed, name);\n-  return prefixed;\n }\n \n int\n-ctf_dtd_insert (ctf_file_t *fp, ctf_dtdef_t *dtd)\n+ctf_dtd_insert (ctf_file_t *fp, ctf_dtdef_t *dtd, int kind)\n {\n+  const char *name;\n   if (ctf_dynhash_insert (fp->ctf_dthash, (void *) dtd->dtd_type, dtd) < 0)\n     return -1;\n \n-  if (dtd->dtd_name)\n+  if (dtd->dtd_data.ctt_name\n+      && (name = ctf_strraw (fp, dtd->dtd_data.ctt_name)) != NULL)\n     {\n-      int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n-      if (ctf_dynhash_insert (fp->ctf_dtbyname,\n-\t\t\t      ctf_prefixed_name (kind, dtd->dtd_name),\n-\t\t\t      dtd) < 0)\n-\treturn -1;\n+      if (ctf_dynhash_insert (ctf_name_table (fp, kind)->ctn_writable,\n+\t\t\t      (char *) name, (void *) dtd->dtd_type) < 0)\n+\t{\n+\t  ctf_dynhash_remove (fp->ctf_dthash, (void *) dtd->dtd_type);\n+\t  return -1;\n+\t}\n     }\n   ctf_list_append (&fp->ctf_dtdefs, dtd);\n   return 0;\n@@ -561,6 +620,7 @@ ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n {\n   ctf_dmdef_t *dmd, *nmd;\n   int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+  const char *name;\n \n   ctf_dynhash_remove (fp->ctf_dthash, (void *) dtd->dtd_type);\n \n@@ -583,14 +643,12 @@ ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n       break;\n     }\n \n-  if (dtd->dtd_name)\n+  if (dtd->dtd_data.ctt_name\n+      && (name = ctf_strraw (fp, dtd->dtd_data.ctt_name)) != NULL)\n     {\n-      char *name;\n-\n-      name = ctf_prefixed_name (kind, dtd->dtd_name);\n-      ctf_dynhash_remove (fp->ctf_dtbyname, name);\n-      free (name);\n-      ctf_free (dtd->dtd_name);\n+      ctf_dynhash_remove (ctf_name_table (fp, kind)->ctn_writable,\n+\t\t\t  name);\n+      ctf_str_remove_ref (fp, name, &dtd->dtd_data.ctt_name);\n     }\n \n   ctf_list_delete (&fp->ctf_dtdefs, dtd);\n@@ -603,33 +661,20 @@ ctf_dtd_lookup (const ctf_file_t *fp, ctf_id_t type)\n   return (ctf_dtdef_t *) ctf_dynhash_lookup (fp->ctf_dthash, (void *) type);\n }\n \n-static ctf_id_t\n-ctf_dtd_lookup_type_by_name (ctf_file_t *fp, int kind, const char *name)\n-{\n-  ctf_dtdef_t *dtd;\n-  char *decorated = ctf_prefixed_name (kind, name);\n-\n-  dtd = (ctf_dtdef_t *) ctf_dynhash_lookup (fp->ctf_dtbyname, decorated);\n-  free (decorated);\n-\n-  if (dtd)\n-    return dtd->dtd_type;\n-\n-  return 0;\n-}\n-\n ctf_dtdef_t *\n ctf_dynamic_type (const ctf_file_t *fp, ctf_id_t id)\n {\n   ctf_id_t idx;\n \n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return NULL;\n+\n   if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, id))\n     fp = fp->ctf_parent;\n \n   idx = LCTF_TYPE_TO_INDEX(fp, id);\n \n-  if (((unsigned long) idx > fp->ctf_typemax) &&\n-      ((unsigned long) idx < fp->ctf_dtnextid))\n+  if ((unsigned long) idx <= fp->ctf_typemax)\n     return ctf_dtd_lookup (fp, id);\n   return NULL;\n }\n@@ -684,7 +729,7 @@ ctf_snapshot_id_t\n ctf_snapshot (ctf_file_t *fp)\n {\n   ctf_snapshot_id_t snapid;\n-  snapid.dtd_id = fp->ctf_dtnextid - 1;\n+  snapid.dtd_id = fp->ctf_typemax;\n   snapid.snapshot_id = fp->ctf_snapshots++;\n   return snapid;\n }\n@@ -699,19 +744,30 @@ ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n   if (!(fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (fp, ECTF_RDONLY));\n \n-  if (fp->ctf_dtoldid > id.dtd_id)\n-    return (ctf_set_errno (fp, ECTF_OVERROLLBACK));\n-\n   if (fp->ctf_snapshot_lu >= id.snapshot_id)\n     return (ctf_set_errno (fp, ECTF_OVERROLLBACK));\n \n   for (dtd = ctf_list_next (&fp->ctf_dtdefs); dtd != NULL; dtd = ntd)\n     {\n+      int kind;\n+      const char *name;\n+\n       ntd = ctf_list_next (dtd);\n \n       if (LCTF_TYPE_TO_INDEX (fp, dtd->dtd_type) <= id.dtd_id)\n \tcontinue;\n \n+      kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+\n+      if (dtd->dtd_data.ctt_name\n+\t  && (name = ctf_strraw (fp, dtd->dtd_data.ctt_name)) != NULL)\n+\t{\n+\t  ctf_dynhash_remove (ctf_name_table (fp, kind)->ctn_writable,\n+\t\t\t      name);\n+\t  ctf_str_remove_ref (fp, name, &dtd->dtd_data.ctt_name);\n+\t}\n+\n+      ctf_dynhash_remove (fp->ctf_dthash, (void *) dtd->dtd_type);\n       ctf_dtd_delete (fp, dtd);\n     }\n \n@@ -725,7 +781,7 @@ ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n       ctf_dvd_delete (fp, dvd);\n     }\n \n-  fp->ctf_dtnextid = id.dtd_id + 1;\n+  fp->ctf_typemax = id.dtd_id;\n   fp->ctf_snapshots = id.snapshot_id;\n \n   if (fp->ctf_snapshots == fp->ctf_snapshot_lu)\n@@ -735,42 +791,45 @@ ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n }\n \n static ctf_id_t\n-ctf_add_generic (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_generic (ctf_file_t *fp, uint32_t flag, const char *name, int kind,\n \t\t ctf_dtdef_t **rp)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n-  char *s = NULL;\n \n   if (flag != CTF_ADD_NONROOT && flag != CTF_ADD_ROOT)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if (!(fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (fp, ECTF_RDONLY));\n \n-  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_dtnextid, 1) > CTF_MAX_TYPE)\n+  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_typemax, 1) >= CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, ECTF_FULL));\n \n-  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_dtnextid, 1) == CTF_MAX_PTYPE)\n+  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_typemax, 1) == (CTF_MAX_PTYPE - 1))\n     return (ctf_set_errno (fp, ECTF_FULL));\n \n+  /* Make sure ptrtab always grows to be big enough for all types.  */\n+  if (ctf_grow_ptrtab (fp) < 0)\n+      return CTF_ERR;\t\t/* errno is set for us. */\n+\n   if ((dtd = ctf_alloc (sizeof (ctf_dtdef_t))) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n \n-  if (name != NULL && (s = ctf_strdup (name)) == NULL)\n-    {\n-      ctf_free (dtd);\n-      return (ctf_set_errno (fp, EAGAIN));\n-    }\n-\n-  type = fp->ctf_dtnextid++;\n+  type = ++fp->ctf_typemax;\n   type = LCTF_INDEX_TO_TYPE (fp, type, (fp->ctf_flags & LCTF_CHILD));\n \n   memset (dtd, 0, sizeof (ctf_dtdef_t));\n-  dtd->dtd_name = s;\n+  dtd->dtd_data.ctt_name = ctf_str_add_ref (fp, name, &dtd->dtd_data.ctt_name);\n   dtd->dtd_type = type;\n \n-  if (ctf_dtd_insert (fp, dtd) < 0)\n+  if (dtd->dtd_data.ctt_name == 0 && name != NULL && name[0] != '\\0')\n+    {\n+      ctf_free (dtd);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+\n+  if (ctf_dtd_insert (fp, dtd, kind) < 0)\n     {\n       ctf_free (dtd);\n       return CTF_ERR;\t\t\t/* errno is set for us.  */\n@@ -808,7 +867,7 @@ ctf_add_encoded (ctf_file_t *fp, uint32_t flag,\n   if (ep == NULL)\n     return (ctf_set_errno (fp, EINVAL));\n \n-  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, name, kind, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n@@ -825,19 +884,46 @@ ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n   ctf_file_t *tmp = fp;\n+  int child = fp->ctf_flags & LCTF_CHILD;\n \n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n   if (ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, kind, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n   dtd->dtd_data.ctt_type = (uint32_t) ref;\n \n+  if (kind != CTF_K_POINTER)\n+    return type;\n+\n+  /* If we are adding a pointer, update the ptrtab, both the directly pointed-to\n+     type and (if an anonymous typedef node is being pointed at) the type that\n+     points at too.  Note that ctf_typemax is at this point one higher than we\n+     want to check against, because it's just been incremented for the addition\n+     of this type.  */\n+\n+  uint32_t type_idx = LCTF_TYPE_TO_INDEX (fp, type);\n+  uint32_t ref_idx = LCTF_TYPE_TO_INDEX (fp, ref);\n+\n+  if (LCTF_TYPE_ISCHILD (fp, ref) == child\n+      && ref_idx < fp->ctf_typemax)\n+    {\n+      fp->ctf_ptrtab[ref_idx] = type_idx;\n+\n+      ctf_id_t refref_idx = LCTF_TYPE_TO_INDEX (fp, dtd->dtd_data.ctt_type);\n+\n+      if (tmp == fp\n+\t  && (LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info) == CTF_K_TYPEDEF)\n+\t  && strcmp (ctf_strptr (fp, dtd->dtd_data.ctt_name), \"\") == 0\n+\t  && refref_idx < fp->ctf_typemax)\n+\tfp->ctf_ptrtab[refref_idx] = type_idx;\n+    }\n+\n   return type;\n }\n \n@@ -868,7 +954,7 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n       (kind != CTF_K_ENUM))\n     return (ctf_set_errno (fp, ECTF_NOTINTFP));\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_SLICE, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_SLICE, flag, 0);\n@@ -918,7 +1004,7 @@ ctf_add_array (ctf_file_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n   if (ctf_lookup_by_id (&tmp, arp->ctr_index) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_ARRAY, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ARRAY, flag, 0);\n@@ -981,7 +1067,8 @@ ctf_add_function (ctf_file_t *fp, uint32_t flag,\n   if (vlen != 0 && (vdat = ctf_alloc (sizeof (ctf_id_t) * vlen)) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n \n-  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_FUNCTION,\n+\t\t\t       &dtd)) == CTF_ERR)\n     {\n       ctf_free (vdat);\n       return CTF_ERR;\t\t   /* errno is set for us.  */\n@@ -1002,22 +1089,18 @@ ctf_id_t\n ctf_add_struct_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n \t\t      size_t size)\n {\n-  ctf_hash_t *hp = fp->ctf_structs;\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n \n   /* Promote forwards to structs.  */\n \n   if (name != NULL)\n-    {\n-      type = ctf_hash_lookup_type (hp, fp, name);\n-      if (type == 0)\n-\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_STRUCT, name);\n-    }\n+    type = ctf_lookup_by_rawname (fp, CTF_K_STRUCT, name);\n \n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n-  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  else if ((type = ctf_add_generic (fp, flag, name, CTF_K_STRUCT,\n+\t\t\t\t    &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_STRUCT, flag, 0);\n@@ -1044,21 +1127,17 @@ ctf_id_t\n ctf_add_union_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n \t\t     size_t size)\n {\n-  ctf_hash_t *hp = fp->ctf_unions;\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n \n   /* Promote forwards to unions.  */\n   if (name != NULL)\n-    {\n-      type = ctf_hash_lookup_type (hp, fp, name);\n-      if (type == 0)\n-\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_UNION, name);\n-    }\n+    type = ctf_lookup_by_rawname (fp, CTF_K_UNION, name);\n \n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n-  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  else if ((type = ctf_add_generic (fp, flag, name, CTF_K_UNION,\n+\t\t\t\t    &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_UNION, flag, 0);\n@@ -1084,21 +1163,17 @@ ctf_add_union (ctf_file_t *fp, uint32_t flag, const char *name)\n ctf_id_t\n ctf_add_enum (ctf_file_t *fp, uint32_t flag, const char *name)\n {\n-  ctf_hash_t *hp = fp->ctf_enums;\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n \n   /* Promote forwards to enums.  */\n   if (name != NULL)\n-    {\n-      type = ctf_hash_lookup_type (hp, fp, name);\n-      if (type == 0)\n-\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_ENUM, name);\n-    }\n+    type = ctf_lookup_by_rawname (fp, CTF_K_ENUM, name);\n \n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n-  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  else if ((type = ctf_add_generic (fp, flag, name, CTF_K_ENUM,\n+\t\t\t\t    &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ENUM, flag, 0);\n@@ -1111,7 +1186,6 @@ ctf_id_t\n ctf_add_enum_encoded (ctf_file_t *fp, uint32_t flag, const char *name,\n \t\t      const ctf_encoding_t *ep)\n {\n-  ctf_hash_t *hp = fp->ctf_enums;\n   ctf_id_t type = 0;\n \n   /* First, create the enum if need be, using most of the same machinery as\n@@ -1120,11 +1194,7 @@ ctf_add_enum_encoded (ctf_file_t *fp, uint32_t flag, const char *name,\n      slice, which would be a useless thing to do anyway.)  */\n \n   if (name != NULL)\n-    {\n-      type = ctf_hash_lookup_type (hp, fp, name);\n-      if (type == 0)\n-\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_ENUM, name);\n-    }\n+    type = ctf_lookup_by_rawname (fp, CTF_K_ENUM, name);\n \n   if (type != 0)\n     {\n@@ -1144,36 +1214,19 @@ ctf_id_t\n ctf_add_forward (ctf_file_t *fp, uint32_t flag, const char *name,\n \t\t uint32_t kind)\n {\n-  ctf_hash_t *hp;\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n \n-  switch (kind)\n-    {\n-    case CTF_K_STRUCT:\n-      hp = fp->ctf_structs;\n-      break;\n-    case CTF_K_UNION:\n-      hp = fp->ctf_unions;\n-      break;\n-    case CTF_K_ENUM:\n-      hp = fp->ctf_enums;\n-      break;\n-    default:\n-      return (ctf_set_errno (fp, ECTF_NOTSUE));\n-    }\n+  if (kind != CTF_K_STRUCT && kind != CTF_K_UNION && kind != CTF_K_ENUM)\n+    return (ctf_set_errno (fp, ECTF_NOTSUE));\n \n   /* If the type is already defined or exists as a forward tag, just\n      return the ctf_id_t of the existing definition.  */\n \n   if (name != NULL)\n-    {\n-      if (((type = ctf_hash_lookup_type (hp, fp, name)) != 0)\n-\t  || (type = ctf_dtd_lookup_type_by_name (fp, kind, name)) != 0)\n-\treturn type;\n-    }\n+    type = ctf_lookup_by_rawname (fp, kind, name);\n \n-  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, name, CTF_K_FORWARD,&dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_FORWARD, flag, 0);\n@@ -1196,7 +1249,8 @@ ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n   if (ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+  if ((type = ctf_add_generic (fp, flag, name, CTF_K_TYPEDEF,\n+\t\t\t       &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_TYPEDEF, flag, 0);\n@@ -1567,7 +1621,6 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n   ctf_dtdef_t *dtd;\n   ctf_funcinfo_t ctc;\n \n-  ctf_hash_t *hp;\n   ctf_id_t orig_src_type = src_type;\n \n   if (!(dst_fp->ctf_flags & LCTF_RDWR))\n@@ -1589,28 +1642,12 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n   if (kind == CTF_K_FORWARD)\n     forward_kind = src_tp->ctt_type;\n \n-  switch (forward_kind)\n-    {\n-    case CTF_K_STRUCT:\n-      hp = dst_fp->ctf_structs;\n-      break;\n-    case CTF_K_UNION:\n-      hp = dst_fp->ctf_unions;\n-      break;\n-    case CTF_K_ENUM:\n-      hp = dst_fp->ctf_enums;\n-      break;\n-    default:\n-      hp = dst_fp->ctf_names;\n-      break;\n-    }\n-\n   /* If the source type has a name and is a root type (visible at the\n      top-level scope), lookup the name in the destination container and\n      verify that it is of the same kind before we do anything else.  */\n \n   if ((flag & CTF_ADD_ROOT) && name[0] != '\\0'\n-      && (tmp = ctf_hash_lookup_type (hp, dst_fp, name)) != 0)\n+      && (tmp = ctf_lookup_by_rawname (dst_fp, forward_kind, name)) != 0)\n     {\n       dst_type = tmp;\n       dst_kind = ctf_type_kind_unsliced (dst_fp, dst_type);\n@@ -1708,8 +1745,12 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t     && LCTF_TYPE_TO_INDEX (src_fp, dtd->dtd_type) > dst_fp->ctf_dtoldid;\n \t   dtd = ctf_list_prev (dtd))\n \t{\n+\t  const char *ctt_name;\n+\n \t  if (LCTF_INFO_KIND (src_fp, dtd->dtd_data.ctt_info) == kind\n-\t      && dtd->dtd_name != NULL && strcmp (dtd->dtd_name, name) == 0)\n+\t      && dtd->dtd_data.ctt_name\n+\t      && ((ctt_name = ctf_strraw (src_fp, dtd->dtd_data.ctt_name)) != NULL)\n+\t      && strcmp (ctt_name, name) == 0)\n \t    {\n \t      int sroot;\t/* Is the src root-visible?  */\n \t      int droot;\t/* Is the dst root-visible?  */\n@@ -1888,7 +1929,7 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \t   manually so as to avoid repeated lookups in ctf_add_member\n \t   and to ensure the exact same member offsets as in src_type.  */\n \n-\tdst_type = ctf_add_generic (dst_fp, flag, name, &dtd);\n+\tdst_type = ctf_add_generic (dst_fp, flag, name, kind, &dtd);\n \tif (dst_type == CTF_ERR)\n \t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n \n@@ -2032,18 +2073,20 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   ctf_header_t *hp = &h;\n   ssize_t header_len = sizeof (ctf_header_t);\n   ssize_t compress_len;\n-  size_t max_compress_len = compressBound (fp->ctf_size);\n   ssize_t len;\n   int rc;\n   int err = 0;\n \n+  if (ctf_serialize (fp) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n   memcpy (hp, fp->ctf_header, header_len);\n   hp->cth_flags |= CTF_F_COMPRESS;\n+  compress_len = compressBound (fp->ctf_size);\n \n-  if ((buf = ctf_alloc (max_compress_len)) == NULL)\n+  if ((buf = ctf_alloc (compress_len)) == NULL)\n     return (ctf_set_errno (fp, ECTF_ZALLOC));\n \n-  compress_len = max_compress_len;\n   if ((rc = compress (buf, (uLongf *) &compress_len,\n \t\t      fp->ctf_buf, fp->ctf_size)) != Z_OK)\n     {\n@@ -2090,12 +2133,15 @@ ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n   ctf_header_t *hp;\n   ssize_t header_len = sizeof (ctf_header_t);\n   ssize_t compress_len;\n-  size_t max_compress_len = compressBound (fp->ctf_size);\n   int rc;\n \n+  if (ctf_serialize (fp) < 0)\n+    return NULL;\t\t\t\t/* errno is set for us.  */\n+\n+  compress_len = compressBound (fp->ctf_size);\n   if (fp->ctf_size < threshold)\n-    max_compress_len = fp->ctf_size;\n-  if ((buf = malloc (max_compress_len\n+    compress_len = fp->ctf_size;\n+  if ((buf = malloc (compress_len\n \t\t     + sizeof (struct ctf_header))) == NULL)\n     {\n       ctf_set_errno (fp, ENOMEM);\n@@ -2107,8 +2153,6 @@ ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n   bp = buf + sizeof (struct ctf_header);\n   *size = sizeof (struct ctf_header);\n \n-  compress_len = max_compress_len;\n-\n   if (fp->ctf_size < threshold)\n     {\n       hp->cth_flags &= ~CTF_F_COMPRESS;\n@@ -2139,6 +2183,9 @@ ctf_write (ctf_file_t *fp, int fd)\n   ssize_t resid;\n   ssize_t len;\n \n+  if (ctf_serialize (fp) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n   resid = sizeof (ctf_header_t);\n   buf = (unsigned char *) fp->ctf_header;\n   while (resid != 0)"
    },
    {
      "sha": "d284717b3a853e73520451f05eab019e49086038",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 36,
      "deletions": 18,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -89,11 +89,17 @@ typedef struct ctf_dmodel\n   size_t ctd_long;\t\t/* Size of long in bytes.  */\n } ctf_dmodel_t;\n \n+typedef struct ctf_names\n+{\n+  ctf_hash_t *ctn_readonly;\t/* Hash table when readonly.  */\n+  ctf_dynhash_t *ctn_writable;\t/* Hash table when writable.  */\n+} ctf_names_t;\n+\n typedef struct ctf_lookup\n {\n   const char *ctl_prefix;\t/* String prefix for this lookup.  */\n   size_t ctl_len;\t\t/* Length of prefix string in bytes.  */\n-  ctf_hash_t *ctl_hash;\t\t/* Pointer to hash table for lookup.  */\n+  ctf_names_t *ctl_hash;\t/* Pointer to hash table for lookup.  */\n } ctf_lookup_t;\n \n typedef struct ctf_fileops\n@@ -152,9 +158,8 @@ typedef struct ctf_dmdef\n typedef struct ctf_dtdef\n {\n   ctf_list_t dtd_list;\t\t/* List forward/back pointers.  */\n-  char *dtd_name;\t\t/* Name associated with definition (if any).  */\n   ctf_id_t dtd_type;\t\t/* Type identifier for this definition.  */\n-  ctf_type_t dtd_data;\t\t/* Type node: name left unpopulated.  */\n+  ctf_type_t dtd_data;\t\t/* Type node, including name.  */\n   union\n   {\n     ctf_list_t dtu_members;\t/* struct, union, or enum */\n@@ -193,7 +198,8 @@ typedef struct ctf_str_atom\n {\n   const char *csa_str;\t\t/* Backpointer to string (hash key).  */\n   ctf_list_t csa_refs;\t\t/* This string's refs.  */\n-  uint32_t csa_offset;\t\t/* External strtab offset, if any.  */\n+  uint32_t csa_offset;\t\t/* Strtab offset, if any.  */\n+  uint32_t csa_external_offset;\t/* External strtab offset, if any.  */\n   unsigned long csa_snapshot_id; /* Snapshot ID at time of creation.  */\n } ctf_str_atom_t;\n \n@@ -235,17 +241,20 @@ struct ctf_file\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n+  ctf_dynhash_t *ctf_prov_strtab;   /* Maps provisional-strtab offsets\n+\t\t\t\t       to names.  */\n   ctf_dynhash_t *ctf_syn_ext_strtab; /* Maps ext-strtab offsets to names.  */\n   void *ctf_data_mmapped;\t    /* CTF data we mmapped, to free later.  */\n   size_t ctf_data_mmapped_len;\t    /* Length of CTF data we mmapped.  */\n-  ctf_hash_t *ctf_structs;\t    /* Hash table of struct types.  */\n-  ctf_hash_t *ctf_unions;\t    /* Hash table of union types.  */\n-  ctf_hash_t *ctf_enums;\t    /* Hash table of enum types.  */\n-  ctf_hash_t *ctf_names;\t    /* Hash table of remaining type names.  */\n-  ctf_lookup_t ctf_lookups[5];\t    /* Pointers to hashes for name lookup.  */\n+  ctf_names_t ctf_structs;\t    /* Hash table of struct types.  */\n+  ctf_names_t ctf_unions;\t    /* Hash table of union types.  */\n+  ctf_names_t ctf_enums;\t    /* Hash table of enum types.  */\n+  ctf_names_t ctf_names;\t    /* Hash table of remaining type names.  */\n+  ctf_lookup_t ctf_lookups[5];\t    /* Pointers to nametabs for name lookup.  */\n   ctf_strs_t ctf_str[2];\t    /* Array of string table base and bounds.  */\n   ctf_dynhash_t *ctf_str_atoms;\t  /* Hash table of ctf_str_atoms_t.  */\n   uint64_t ctf_str_num_refs;\t  /* Number of refs to cts_str_atoms.  */\n+  uint32_t ctf_str_prov_offset;\t  /* Latest provisional offset assigned so far.  */\n   unsigned char *ctf_base;\t  /* CTF file pointer.  */\n   unsigned char *ctf_dynbase;\t  /* Freeable CTF file pointer. */\n   unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n@@ -254,6 +263,7 @@ struct ctf_file\n   unsigned long ctf_nsyms;\t  /* Number of entries in symtab xlate table.  */\n   uint32_t *ctf_txlate;\t\t  /* Translation table for type IDs.  */\n   uint32_t *ctf_ptrtab;\t\t  /* Translation table for pointer-to lookups.  */\n+  size_t ctf_ptrtab_len;\t  /* Num types storable in ptrtab currently.  */\n   struct ctf_varent *ctf_vars;\t  /* Sorted variable->type mapping.  */\n   unsigned long ctf_nvars;\t  /* Number of variables in ctf_vars.  */\n   unsigned long ctf_typemax;\t  /* Maximum valid type ID number.  */\n@@ -270,11 +280,9 @@ struct ctf_file\n   int ctf_errno;\t\t  /* Error code for most recent error.  */\n   int ctf_version;\t\t  /* CTF data version.  */\n   ctf_dynhash_t *ctf_dthash;\t  /* Hash of dynamic type definitions.  */\n-  ctf_dynhash_t *ctf_dtbyname;\t  /* DTDs, indexed by name.  */\n   ctf_list_t ctf_dtdefs;\t  /* List of dynamic type definitions.  */\n   ctf_dynhash_t *ctf_dvhash;\t  /* Hash of dynamic variable mappings.  */\n   ctf_list_t ctf_dvdefs;\t  /* List of dynamic variable definitions.  */\n-  unsigned long ctf_dtnextid;\t  /* Next dynamic type id to assign.  */\n   unsigned long ctf_dtoldid;\t  /* Oldest id that has been committed.  */\n   unsigned long ctf_snapshots;\t  /* ctf_snapshot() plus ctf_update() count.  */\n   unsigned long ctf_snapshot_lu;  /* ctf_snapshot() call count at last update.  */\n@@ -320,7 +328,10 @@ struct ctf_archive_internal\n \t\t\t\t\t   (id))\n \n #define LCTF_INDEX_TO_TYPEPTR(fp, i) \\\n-  ((ctf_type_t *)((uintptr_t)(fp)->ctf_buf + (fp)->ctf_txlate[(i)]))\n+    ((fp->ctf_flags & LCTF_RDWR) ?\t\t\t\t\t\\\n+     &(ctf_dtd_lookup (fp, LCTF_INDEX_TO_TYPE\t\t\t\t\\\n+\t\t       (fp, i, fp->ctf_flags & LCTF_CHILD))->dtd_data) : \\\n+     (ctf_type_t *)((uintptr_t)(fp)->ctf_buf + (fp)->ctf_txlate[(i)]))\n \n #define LCTF_INFO_KIND(fp, info)\t((fp)->ctf_fileops->ctfo_get_kind(info))\n #define LCTF_INFO_ISROOT(fp, info)\t((fp)->ctf_fileops->ctfo_get_root(info))\n@@ -340,7 +351,11 @@ static inline ssize_t ctf_get_ctt_size (const ctf_file_t *fp,\n #define LCTF_RDWR\t0x0002\t/* CTF container is writable */\n #define LCTF_DIRTY\t0x0004\t/* CTF container has been modified */\n \n+extern ctf_names_t *ctf_name_table (ctf_file_t *, int);\n extern const ctf_type_t *ctf_lookup_by_id (ctf_file_t **, ctf_id_t);\n+extern ctf_id_t ctf_lookup_by_rawname (ctf_file_t *, int, const char *);\n+extern ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *, ctf_names_t *, const char *);\n+extern void ctf_set_ctl_hashes (ctf_file_t *);\n \n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n extern unsigned int ctf_hash_integer (const void *ptr);\n@@ -381,8 +396,9 @@ extern void ctf_dynhash_iter_remove (ctf_dynhash_t *, ctf_hash_iter_remove_f,\n extern void ctf_list_append (ctf_list_t *, void *);\n extern void ctf_list_prepend (ctf_list_t *, void *);\n extern void ctf_list_delete (ctf_list_t *, void *);\n+extern int ctf_list_empty_p (ctf_list_t *lp);\n \n-extern int ctf_dtd_insert (ctf_file_t *, ctf_dtdef_t *);\n+extern int ctf_dtd_insert (ctf_file_t *, ctf_dtdef_t *, int);\n extern void ctf_dtd_delete (ctf_file_t *, ctf_dtdef_t *);\n extern ctf_dtdef_t *ctf_dtd_lookup (const ctf_file_t *, ctf_id_t);\n extern ctf_dtdef_t *ctf_dynamic_type (const ctf_file_t *, ctf_id_t);\n@@ -410,9 +426,10 @@ extern const char *ctf_strraw_explicit (ctf_file_t *, uint32_t,\n \t\t\t\t\tctf_strs_t *);\n extern int ctf_str_create_atoms (ctf_file_t *);\n extern void ctf_str_free_atoms (ctf_file_t *);\n-extern const char *ctf_str_add (ctf_file_t *, const char *);\n-extern const char *ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *ref);\n-extern const char *ctf_str_add_external (ctf_file_t *, const char *, uint32_t offset);\n+extern uint32_t ctf_str_add (ctf_file_t *, const char *);\n+extern uint32_t ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *ref);\n+extern int ctf_str_add_external (ctf_file_t *, const char *, uint32_t offset);\n+extern void ctf_str_remove_ref (ctf_file_t *, const char *, uint32_t *ref);\n extern void ctf_str_rollback (ctf_file_t *, ctf_snapshot_id_t);\n extern void ctf_str_purge_refs (ctf_file_t *);\n extern ctf_strs_writable_t ctf_str_write_strtab (ctf_file_t *);\n@@ -426,10 +443,11 @@ extern unsigned long ctf_set_errno (ctf_file_t *, int);\n extern ctf_file_t *ctf_simple_open_internal (const char *, size_t, const char *,\n \t\t\t\t\t     size_t, size_t,\n \t\t\t\t\t     const char *, size_t,\n-\t\t\t\t\t     ctf_dynhash_t *, int *);\n+\t\t\t\t\t     ctf_dynhash_t *, int, int *);\n extern ctf_file_t *ctf_bufopen_internal (const ctf_sect_t *, const ctf_sect_t *,\n \t\t\t\t\t const ctf_sect_t *, ctf_dynhash_t *,\n-\t\t\t\t\t int *);\n+\t\t\t\t\t int, int *);\n+extern int ctf_serialize (ctf_file_t *);\n \n _libctf_malloc_\n extern void *ctf_mmap (size_t length, size_t offset, int fd);"
    },
    {
      "sha": "2f05522d012293ff263dee1b6787e426856b1a5a",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 3,
      "deletions": 17,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -639,7 +639,7 @@ ctf_link_intern_extern_string (void *key _libctf_unused_, void *value,\n   ctf_link_out_string_cb_arg_t *arg = (ctf_link_out_string_cb_arg_t *) arg_;\n \n   fp->ctf_flags |= LCTF_DIRTY;\n-  if (ctf_str_add_external (fp, arg->str, arg->offset) == NULL)\n+  if (!ctf_str_add_external (fp, arg->str, arg->offset))\n     arg->err = ENOMEM;\n }\n \n@@ -662,7 +662,7 @@ ctf_link_add_strtab (ctf_file_t *fp, ctf_link_strtab_string_f *add_string,\n       ctf_link_out_string_cb_arg_t iter_arg = { str, offset, 0 };\n \n       fp->ctf_flags |= LCTF_DIRTY;\n-      if (ctf_str_add_external (fp, str, offset) == NULL)\n+      if (!ctf_str_add_external (fp, str, offset))\n \terr = ENOMEM;\n \n       ctf_dynhash_iter (fp->ctf_link_outputs, ctf_link_intern_extern_string,\n@@ -693,8 +693,7 @@ typedef struct ctf_name_list_accum_cb_arg\n   size_t ndynames;\n } ctf_name_list_accum_cb_arg_t;\n \n-/* Accumulate the names and a count of the names in the link output hash,\n-   and run ctf_update() on them to generate them.  */\n+/* Accumulate the names and a count of the names in the link output hash.  */\n static void\n ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n {\n@@ -703,13 +702,6 @@ ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n   char **names;\n   ctf_file_t **files;\n   ctf_name_list_accum_cb_arg_t *arg = (ctf_name_list_accum_cb_arg_t *) arg_;\n-  int err;\n-\n-  if ((err = ctf_update (fp)) < 0)\n-    {\n-      ctf_set_errno (arg->fp, ctf_errno (fp));\n-      return;\n-    }\n \n   if ((names = realloc (arg->names, sizeof (char *) * ++(arg->i))) == NULL)\n     {\n@@ -788,12 +780,6 @@ ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n   memset (&arg, 0, sizeof (ctf_name_list_accum_cb_arg_t));\n   arg.fp = fp;\n \n-  if (ctf_update (fp) < 0)\n-    {\n-      errloc = \"CTF file construction\";\n-      goto err;\n-    }\n-\n   if (fp->ctf_link_outputs)\n     {\n       ctf_dynhash_iter (fp->ctf_link_outputs, ctf_accumulate_archive_names, &arg);"
    },
    {
      "sha": "6f180d68c2eb602248f26942c91b15347e29ebd1",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -161,8 +161,8 @@ ctf_lookup_by_name (ctf_file_t *fp, const char *name)\n \t\t    }\n \t\t}\n \n-\t      if ((type = ctf_hash_lookup_type (lp->ctl_hash, fp,\n-\t\t\t\t\t\tfp->ctf_tmp_typeslice)) == 0)\n+\t      if ((type = ctf_lookup_by_rawhash (fp, lp->ctl_hash,\n+\t\t\t\t\t\t fp->ctf_tmp_typeslice)) == 0)\n \t\t{\n \t\t  (void) ctf_set_errno (fp, ECTF_NOTYPE);\n \t\t  goto err;\n@@ -322,13 +322,6 @@ ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n       return NULL;\n     }\n \n-  idx = LCTF_TYPE_TO_INDEX (fp, type);\n-  if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n-    {\n-      *fpp = fp;\t\t/* Function returns ending CTF container.  */\n-      return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n-    }\n-\n   /* If this container is writable, check for a dynamic type.  */\n \n   if (fp->ctf_flags & LCTF_RDWR)\n@@ -340,7 +333,19 @@ ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n \t  *fpp = fp;\n \t  return &dtd->dtd_data;\n \t}\n+      (void) ctf_set_errno (*fpp, ECTF_BADID);\n+      return NULL;\n     }\n+\n+  /* Check for a type in the static portion.  */\n+\n+  idx = LCTF_TYPE_TO_INDEX (fp, type);\n+  if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n+    {\n+      *fpp = fp;\t\t/* Function returns ending CTF container.  */\n+      return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n+    }\n+\n   (void) ctf_set_errno (*fpp, ECTF_BADID);\n   return NULL;\n }"
    },
    {
      "sha": "c4fca243391729bdf9a446fa1e375dcd86b7a2c7",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 115,
      "deletions": 91,
      "changes": 206,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -655,7 +655,6 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \n   unsigned long pop[CTF_K_MAX + 1] = { 0 };\n   const ctf_type_t *tp;\n-  ctf_hash_t *hp;\n   uint32_t id, dst;\n   uint32_t *xp;\n \n@@ -666,6 +665,8 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n   int nlstructs = 0, nlunions = 0;\n   int err;\n \n+  assert (!(fp->ctf_flags & LCTF_RDWR));\n+\n   if (_libctf_unlikely_ (fp->ctf_version == CTF_VERSION_1))\n     {\n       int err;\n@@ -717,32 +718,37 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n   /* Now that we've counted up the number of each type, we can allocate\n      the hash tables, type translation table, and pointer table.  */\n \n-  if ((fp->ctf_structs = ctf_hash_create (pop[CTF_K_STRUCT], ctf_hash_string,\n-\t\t\t\t\t  ctf_hash_eq_string)) == NULL)\n+  if ((fp->ctf_structs.ctn_readonly\n+       = ctf_hash_create (pop[CTF_K_STRUCT], ctf_hash_string,\n+\t\t\t  ctf_hash_eq_string)) == NULL)\n     return ENOMEM;\n \n-  if ((fp->ctf_unions = ctf_hash_create (pop[CTF_K_UNION], ctf_hash_string,\n-\t\t\t\t\t ctf_hash_eq_string)) == NULL)\n+  if ((fp->ctf_unions.ctn_readonly\n+       = ctf_hash_create (pop[CTF_K_UNION], ctf_hash_string,\n+\t\t\t  ctf_hash_eq_string)) == NULL)\n     return ENOMEM;\n \n-  if ((fp->ctf_enums = ctf_hash_create (pop[CTF_K_ENUM], ctf_hash_string,\n-\t\t\t\t\tctf_hash_eq_string)) == NULL)\n+  if ((fp->ctf_enums.ctn_readonly\n+       = ctf_hash_create (pop[CTF_K_ENUM], ctf_hash_string,\n+\t\t\t  ctf_hash_eq_string)) == NULL)\n     return ENOMEM;\n \n-  if ((fp->ctf_names = ctf_hash_create (pop[CTF_K_INTEGER] +\n-\t\t\t\t\tpop[CTF_K_FLOAT] +\n-\t\t\t\t\tpop[CTF_K_FUNCTION] +\n-\t\t\t\t\tpop[CTF_K_TYPEDEF] +\n-\t\t\t\t\tpop[CTF_K_POINTER] +\n-\t\t\t\t\tpop[CTF_K_VOLATILE] +\n-\t\t\t\t\tpop[CTF_K_CONST] +\n-\t\t\t\t\tpop[CTF_K_RESTRICT],\n-\t\t\t\t\tctf_hash_string,\n-\t\t\t\t\tctf_hash_eq_string)) == NULL)\n+  if ((fp->ctf_names.ctn_readonly\n+       = ctf_hash_create (pop[CTF_K_INTEGER] +\n+\t\t\t  pop[CTF_K_FLOAT] +\n+\t\t\t  pop[CTF_K_FUNCTION] +\n+\t\t\t  pop[CTF_K_TYPEDEF] +\n+\t\t\t  pop[CTF_K_POINTER] +\n+\t\t\t  pop[CTF_K_VOLATILE] +\n+\t\t\t  pop[CTF_K_CONST] +\n+\t\t\t  pop[CTF_K_RESTRICT],\n+\t\t\t  ctf_hash_string,\n+\t\t\t  ctf_hash_eq_string)) == NULL)\n     return ENOMEM;\n \n   fp->ctf_txlate = ctf_alloc (sizeof (uint32_t) * (fp->ctf_typemax + 1));\n-  fp->ctf_ptrtab = ctf_alloc (sizeof (uint32_t) * (fp->ctf_typemax + 1));\n+  fp->ctf_ptrtab_len = fp->ctf_typemax + 1;\n+  fp->ctf_ptrtab = ctf_alloc (sizeof (uint32_t) * fp->ctf_ptrtab_len);\n \n   if (fp->ctf_txlate == NULL || fp->ctf_ptrtab == NULL)\n     return ENOMEM;\t\t/* Memory allocation failed.  */\n@@ -779,10 +785,11 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t     root-visible version so that we can be sure to find it when\n \t     checking for conflicting definitions in ctf_add_type().  */\n \n-\t  if (((ctf_hash_lookup_type (fp->ctf_names, fp, name)) == 0)\n+\t  if (((ctf_hash_lookup_type (fp->ctf_names.ctn_readonly,\n+\t\t\t\t      fp, name)) == 0)\n \t      || (flag & CTF_ADD_ROOT))\n \t    {\n-\t      err = ctf_hash_define_type (fp->ctf_names, fp,\n+\t      err = ctf_hash_define_type (fp->ctf_names.ctn_readonly, fp,\n \t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t\t  tp->ctt_name);\n \t      if (err != 0)\n@@ -797,15 +804,15 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  break;\n \n \tcase CTF_K_FUNCTION:\n-\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t  err = ctf_hash_insert_type (fp->ctf_names.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \t  if (err != 0)\n \t    return err;\n \t  break;\n \n \tcase CTF_K_STRUCT:\n-\t  err = ctf_hash_define_type (fp->ctf_structs, fp,\n+\t  err = ctf_hash_define_type (fp->ctf_structs.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n@@ -817,7 +824,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  break;\n \n \tcase CTF_K_UNION:\n-\t  err = ctf_hash_define_type (fp->ctf_unions, fp,\n+\t  err = ctf_hash_define_type (fp->ctf_unions.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n@@ -829,7 +836,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  break;\n \n \tcase CTF_K_ENUM:\n-\t  err = ctf_hash_define_type (fp->ctf_enums, fp,\n+\t  err = ctf_hash_define_type (fp->ctf_enums.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \n@@ -838,40 +845,28 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  break;\n \n \tcase CTF_K_TYPEDEF:\n-\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t  err = ctf_hash_insert_type (fp->ctf_names.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \t  if (err != 0)\n \t    return err;\n \t  break;\n \n \tcase CTF_K_FORWARD:\n-\t  /* Only insert forward tags into the given hash if the type or tag\n-\t     name is not already present.  */\n-\t  switch (tp->ctt_type)\n-\t    {\n-\t    case CTF_K_STRUCT:\n-\t      hp = fp->ctf_structs;\n-\t      break;\n-\t    case CTF_K_UNION:\n-\t      hp = fp->ctf_unions;\n-\t      break;\n-\t    case CTF_K_ENUM:\n-\t      hp = fp->ctf_enums;\n-\t      break;\n-\t    default:\n-\t      hp = fp->ctf_structs;\n-\t    }\n-\n-\t  if (ctf_hash_lookup_type (hp, fp, name) == 0)\n-\t    {\n-\t      err = ctf_hash_insert_type (hp, fp,\n-\t\t\t\t\t  LCTF_INDEX_TO_TYPE (fp, id, child),\n-\t\t\t\t\t  tp->ctt_name);\n-\t      if (err != 0)\n-\t\treturn err;\n-\t    }\n-\t  break;\n+\t  {\n+\t    ctf_names_t *np = ctf_name_table (fp, tp->ctt_type);\n+\t    /* Only insert forward tags into the given hash if the type or tag\n+\t       name is not already present.  */\n+\t    if (ctf_hash_lookup_type (np->ctn_readonly, fp, name) == 0)\n+\t      {\n+\t\terr = ctf_hash_insert_type (np->ctn_readonly, fp,\n+\t\t\t\t\t    LCTF_INDEX_TO_TYPE (fp, id, child),\n+\t\t\t\t\t    tp->ctt_name);\n+\t\tif (err != 0)\n+\t\t  return err;\n+\t      }\n+\t    break;\n+\t  }\n \n \tcase CTF_K_POINTER:\n \t  /* If the type referenced by the pointer is in this CTF container,\n@@ -886,7 +881,7 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \tcase CTF_K_VOLATILE:\n \tcase CTF_K_CONST:\n \tcase CTF_K_RESTRICT:\n-\t  err = ctf_hash_insert_type (fp->ctf_names, fp,\n+\t  err = ctf_hash_insert_type (fp->ctf_names.ctn_readonly, fp,\n \t\t\t\t      LCTF_INDEX_TO_TYPE (fp, id, child),\n \t\t\t\t      tp->ctt_name);\n \t  if (err != 0)\n@@ -903,12 +898,14 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n     }\n \n   ctf_dprintf (\"%lu total types processed\\n\", fp->ctf_typemax);\n-  ctf_dprintf (\"%u enum names hashed\\n\", ctf_hash_size (fp->ctf_enums));\n+  ctf_dprintf (\"%u enum names hashed\\n\",\n+\t       ctf_hash_size (fp->ctf_enums.ctn_readonly));\n   ctf_dprintf (\"%u struct names hashed (%d long)\\n\",\n-\t       ctf_hash_size (fp->ctf_structs), nlstructs);\n+\t       ctf_hash_size (fp->ctf_structs.ctn_readonly), nlstructs);\n   ctf_dprintf (\"%u union names hashed (%d long)\\n\",\n-\t       ctf_hash_size (fp->ctf_unions), nlunions);\n-  ctf_dprintf (\"%u base type names hashed\\n\", ctf_hash_size (fp->ctf_names));\n+\t       ctf_hash_size (fp->ctf_unions.ctn_readonly), nlunions);\n+  ctf_dprintf (\"%u base type names hashed\\n\",\n+\t       ctf_hash_size (fp->ctf_names.ctn_readonly));\n \n   /* Make an additional pass through the pointer table to find pointers that\n      point to anonymous typedef nodes.  If we find one, modify the pointer table\n@@ -921,11 +918,11 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t{\n \t  tp = LCTF_INDEX_TO_TYPEPTR (fp, id);\n \n-\t  if (LCTF_INFO_KIND (fp, tp->ctt_info) == CTF_K_TYPEDEF &&\n-\t      strcmp (ctf_strptr (fp, tp->ctt_name), \"\") == 0 &&\n-\t      LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child &&\n-\t      LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n-\t    fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, tp->ctt_type)] = dst;\n+\t  if (LCTF_INFO_KIND (fp, tp->ctt_info) == CTF_K_TYPEDEF\n+\t      && strcmp (ctf_strptr (fp, tp->ctt_name), \"\") == 0\n+\t      && LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child\n+\t      && LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n+\t      fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, tp->ctt_type)] = dst;\n \t}\n     }\n \n@@ -1197,6 +1194,29 @@ flip_ctf (ctf_header_t *cth, unsigned char *buf)\n   return flip_types (buf + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n }\n \n+/* Set up the ctl hashes in a ctf_file_t.  Called by both writable and\n+   non-writable dictionary initialization.  */\n+void ctf_set_ctl_hashes (ctf_file_t *fp)\n+{\n+  /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n+     array of type name prefixes and the corresponding ctf_hash to use.  */\n+  fp->ctf_lookups[0].ctl_prefix = \"struct\";\n+  fp->ctf_lookups[0].ctl_len = strlen (fp->ctf_lookups[0].ctl_prefix);\n+  fp->ctf_lookups[0].ctl_hash = &fp->ctf_structs;\n+  fp->ctf_lookups[1].ctl_prefix = \"union\";\n+  fp->ctf_lookups[1].ctl_len = strlen (fp->ctf_lookups[1].ctl_prefix);\n+  fp->ctf_lookups[1].ctl_hash = &fp->ctf_unions;\n+  fp->ctf_lookups[2].ctl_prefix = \"enum\";\n+  fp->ctf_lookups[2].ctl_len = strlen (fp->ctf_lookups[2].ctl_prefix);\n+  fp->ctf_lookups[2].ctl_hash = &fp->ctf_enums;\n+  fp->ctf_lookups[3].ctl_prefix = _CTF_NULLSTR;\n+  fp->ctf_lookups[3].ctl_len = strlen (fp->ctf_lookups[3].ctl_prefix);\n+  fp->ctf_lookups[3].ctl_hash = &fp->ctf_names;\n+  fp->ctf_lookups[4].ctl_prefix = NULL;\n+  fp->ctf_lookups[4].ctl_len = 0;\n+  fp->ctf_lookups[4].ctl_hash = NULL;\n+}\n+\n /* Open a CTF file, mocking up a suitable ctf_sect.  */\n \n ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n@@ -1207,7 +1227,7 @@ ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n {\n   return ctf_simple_open_internal (ctfsect, ctfsect_size, symsect, symsect_size,\n \t\t\t\t   symsect_entsize, strsect, strsect_size, NULL,\n-\t\t\t\t   errp);\n+\t\t\t\t   0, errp);\n }\n \n /* Open a CTF file, mocking up a suitable ctf_sect and overriding the external\n@@ -1217,7 +1237,8 @@ ctf_file_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n \t\t\t\t      const char *symsect, size_t symsect_size,\n \t\t\t\t      size_t symsect_entsize,\n \t\t\t\t      const char *strsect, size_t strsect_size,\n-\t\t\t\t      ctf_dynhash_t *syn_strtab, int *errp)\n+\t\t\t\t      ctf_dynhash_t *syn_strtab, int writable,\n+\t\t\t\t      int *errp)\n {\n   ctf_sect_t skeleton;\n \n@@ -1254,7 +1275,8 @@ ctf_file_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n       strsectp = &str_sect;\n     }\n \n-  return ctf_bufopen_internal (ctfsectp, symsectp, strsectp, syn_strtab, errp);\n+  return ctf_bufopen_internal (ctfsectp, symsectp, strsectp, syn_strtab,\n+\t\t\t       writable, errp);\n }\n \n /* Decode the specified CTF buffer and optional symbol table, and create a new\n@@ -1266,15 +1288,15 @@ ctf_file_t *\n ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t     const ctf_sect_t *strsect, int *errp)\n {\n-  return ctf_bufopen_internal (ctfsect, symsect, strsect, NULL, errp);\n+  return ctf_bufopen_internal (ctfsect, symsect, strsect, NULL, 0, errp);\n }\n \n /* Like ctf_bufopen, but overriding the external strtab with a synthetic one.  */\n \n ctf_file_t *\n ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t\t      const ctf_sect_t *strsect, ctf_dynhash_t *syn_strtab,\n-\t\t      int *errp)\n+\t\t      int writable, int *errp)\n {\n   const ctf_preamble_t *pp;\n   size_t hdrsz = sizeof (ctf_header_t);\n@@ -1353,6 +1375,9 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   memset (fp, 0, sizeof (ctf_file_t));\n \n+  if (writable)\n+    fp->ctf_flags |= LCTF_RDWR;\n+\n   if ((fp->ctf_header = ctf_alloc (sizeof (struct ctf_header))) == NULL)\n     {\n       ctf_free (fp);\n@@ -1514,6 +1539,14 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   ctf_set_base (fp, hp, fp->ctf_base);\n \n+  /* No need to do anything else for dynamic containers: they do not support\n+     symbol lookups, and the type table is maintained in the dthashes.  */\n+  if (fp->ctf_flags & LCTF_RDWR)\n+    {\n+      fp->ctf_refcnt = 1;\n+      return fp;\n+    }\n+\n   if ((err = init_types (fp, hp)) != 0)\n     goto bad;\n \n@@ -1537,24 +1570,7 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \tgoto bad;\n     }\n \n-  /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n-     array of type name prefixes and the corresponding ctf_hash to use.\n-     NOTE: This code must be kept in sync with the code in ctf_update().  */\n-  fp->ctf_lookups[0].ctl_prefix = \"struct\";\n-  fp->ctf_lookups[0].ctl_len = strlen (fp->ctf_lookups[0].ctl_prefix);\n-  fp->ctf_lookups[0].ctl_hash = fp->ctf_structs;\n-  fp->ctf_lookups[1].ctl_prefix = \"union\";\n-  fp->ctf_lookups[1].ctl_len = strlen (fp->ctf_lookups[1].ctl_prefix);\n-  fp->ctf_lookups[1].ctl_hash = fp->ctf_unions;\n-  fp->ctf_lookups[2].ctl_prefix = \"enum\";\n-  fp->ctf_lookups[2].ctl_len = strlen (fp->ctf_lookups[2].ctl_prefix);\n-  fp->ctf_lookups[2].ctl_hash = fp->ctf_enums;\n-  fp->ctf_lookups[3].ctl_prefix = _CTF_NULLSTR;\n-  fp->ctf_lookups[3].ctl_len = strlen (fp->ctf_lookups[3].ctl_prefix);\n-  fp->ctf_lookups[3].ctl_hash = fp->ctf_names;\n-  fp->ctf_lookups[4].ctl_prefix = NULL;\n-  fp->ctf_lookups[4].ctl_len = 0;\n-  fp->ctf_lookups[4].ctl_hash = NULL;\n+  ctf_set_ctl_hashes (fp);\n \n   if (symsect != NULL)\n     {\n@@ -1607,7 +1623,20 @@ ctf_file_close (ctf_file_t *fp)\n       ctf_dtd_delete (fp, dtd);\n     }\n   ctf_dynhash_destroy (fp->ctf_dthash);\n-  ctf_dynhash_destroy (fp->ctf_dtbyname);\n+  if (fp->ctf_flags & LCTF_RDWR)\n+    {\n+      ctf_dynhash_destroy (fp->ctf_structs.ctn_writable);\n+      ctf_dynhash_destroy (fp->ctf_unions.ctn_writable);\n+      ctf_dynhash_destroy (fp->ctf_enums.ctn_writable);\n+      ctf_dynhash_destroy (fp->ctf_names.ctn_writable);\n+    }\n+  else\n+    {\n+      ctf_hash_destroy (fp->ctf_structs.ctn_readonly);\n+      ctf_hash_destroy (fp->ctf_unions.ctn_readonly);\n+      ctf_hash_destroy (fp->ctf_enums.ctn_readonly);\n+      ctf_hash_destroy (fp->ctf_names.ctn_readonly);\n+    }\n \n   for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n     {\n@@ -1641,11 +1670,6 @@ ctf_file_close (ctf_file_t *fp)\n   ctf_free (fp->ctf_txlate);\n   ctf_free (fp->ctf_ptrtab);\n \n-  ctf_hash_destroy (fp->ctf_structs);\n-  ctf_hash_destroy (fp->ctf_unions);\n-  ctf_hash_destroy (fp->ctf_enums);\n-  ctf_hash_destroy (fp->ctf_names);\n-\n   ctf_free (fp->ctf_header);\n   ctf_free (fp);\n }\n@@ -1670,7 +1694,7 @@ ctf_get_arc (const ctf_file_t *fp)\n    structure, not a pointer to it, since that is likely to become a pointer to\n    freed data before the return value is used under the expected use case of\n    ctf_getsect()/ ctf_file_close()/free().  */\n-extern ctf_sect_t\n+ctf_sect_t\n ctf_getdatasect (const ctf_file_t *fp)\n {\n   return fp->ctf_data;"
    },
    {
      "sha": "243e1acb36a1dc6b5c0657a34eb12c325cc270ba",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 130,
      "deletions": 33,
      "changes": 163,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -38,6 +38,16 @@ ctf_strraw_explicit (ctf_file_t *fp, uint32_t name, ctf_strs_t *strtab)\n     return ctf_dynhash_lookup (fp->ctf_syn_ext_strtab,\n \t\t\t       (void *) (uintptr_t) name);\n \n+  /* If the name is in the internal strtab, and the offset is beyond the end of\n+     the ctsp->cts_len but below the ctf_str_prov_offset, this is a provisional\n+     string added by ctf_str_add*() but not yet built into a real strtab: get\n+     the value out of the ctf_prov_strtab.  */\n+\n+  if (CTF_NAME_STID (name) == CTF_STRTAB_0\n+      && name >= ctsp->cts_len && name < fp->ctf_str_prov_offset)\n+      return ctf_dynhash_lookup (fp->ctf_prov_strtab,\n+\t\t\t\t (void *) (uintptr_t) name);\n+\n   if (ctsp->cts_strs != NULL && CTF_NAME_OFFSET (name) < ctsp->cts_len)\n     return (ctsp->cts_strs + CTF_NAME_OFFSET (name));\n \n@@ -96,24 +106,45 @@ ctf_str_create_atoms (ctf_file_t *fp)\n   if (fp->ctf_str_atoms == NULL)\n     return -ENOMEM;\n \n+  if (!fp->ctf_prov_strtab)\n+    fp->ctf_prov_strtab = ctf_dynhash_create (ctf_hash_integer,\n+\t\t\t\t\t      ctf_hash_eq_integer,\n+\t\t\t\t\t      NULL, NULL);\n+  if (!fp->ctf_prov_strtab)\n+    goto oom_prov_strtab;\n+\n+  errno = 0;\n   ctf_str_add (fp, \"\");\n+  if (errno == ENOMEM)\n+    goto oom_str_add;\n+\n   return 0;\n+\n+ oom_str_add:\n+  ctf_dynhash_destroy (fp->ctf_prov_strtab);\n+  fp->ctf_prov_strtab = NULL;\n+ oom_prov_strtab:\n+  ctf_dynhash_destroy (fp->ctf_str_atoms);\n+  fp->ctf_str_atoms = NULL;\n+  return -ENOMEM;\n }\n \n /* Destroy the atoms table.  */\n void\n ctf_str_free_atoms (ctf_file_t *fp)\n {\n+  ctf_dynhash_destroy (fp->ctf_prov_strtab);\n   ctf_dynhash_destroy (fp->ctf_str_atoms);\n }\n \n /* Add a string to the atoms table, copying the passed-in string.  Return the\n    atom added. Return NULL only when out of memory (and do not touch the\n    passed-in string in that case).  Possibly augment the ref list with the\n-   passed-in ref.  */\n+   passed-in ref.  Possibly add a provisional entry for this string to the\n+   provisional strtab.   */\n static ctf_str_atom_t *\n ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n-\t\t\t  int add_ref, uint32_t *ref)\n+\t\t\t  int add_ref, int make_provisional, uint32_t *ref)\n {\n   char *newstr = NULL;\n   ctf_str_atom_t *atom = NULL;\n@@ -150,6 +181,18 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n \n   atom->csa_str = newstr;\n   atom->csa_snapshot_id = fp->ctf_snapshots;\n+\n+  if (make_provisional)\n+    {\n+      atom->csa_offset = fp->ctf_str_prov_offset;\n+\n+      if (ctf_dynhash_insert (fp->ctf_prov_strtab, (void *) (uintptr_t)\n+\t\t\t      atom->csa_offset, (void *) atom->csa_str) < 0)\n+\tgoto oom;\n+\n+      fp->ctf_str_prov_offset += strlen (atom->csa_str) + 1;\n+    }\n+\n   if (add_ref)\n     {\n       ctf_list_append (&atom->csa_refs, aref);\n@@ -158,59 +201,87 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n   return atom;\n \n  oom:\n+  if (newstr)\n+    ctf_dynhash_remove (fp->ctf_str_atoms, newstr);\n   ctf_free (atom);\n   ctf_free (aref);\n   ctf_free (newstr);\n   return NULL;\n }\n \n-/* Add a string to the atoms table and return it, without augmenting the ref\n-   list for this string.  */\n-const char *\n+/* Add a string to the atoms table, without augmenting the ref list for this\n+   string: return a 'provisional offset' which can be used to return this string\n+   until ctf_str_write_strtab is called, or 0 on failure.  (Everywhere the\n+   provisional offset is assigned to should be added as a ref using\n+   ctf_str_add_ref() as well.) */\n+uint32_t\n ctf_str_add (ctf_file_t *fp, const char *str)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n-    return NULL;\n+    return 0;\n \n-  atom = ctf_str_add_ref_internal (fp, str, FALSE, 0);\n+  atom = ctf_str_add_ref_internal (fp, str, FALSE, TRUE, 0);\n   if (!atom)\n-    return NULL;\n+    return 0;\n \n-  return atom->csa_str;\n+  return atom->csa_offset;\n }\n \n /* Like ctf_str_add(), but additionally augment the atom's refs list with the\n    passed-in ref, whether or not the string is already present.  There is no\n    attempt to deduplicate the refs list (but duplicates are harmless).  */\n-const char *\n+uint32_t\n ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n-    return NULL;\n+    return 0;\n \n-  atom = ctf_str_add_ref_internal (fp, str, TRUE, ref);\n+  atom = ctf_str_add_ref_internal (fp, str, TRUE, TRUE, ref);\n   if (!atom)\n-    return NULL;\n+    return 0;\n \n-  return atom->csa_str;\n+  return atom->csa_offset;\n }\n \n-/* Add an external strtab reference at OFFSET.  */\n-const char *\n+/* Add an external strtab reference at OFFSET.  Returns zero if the addition\n+   failed, nonzero otherwise.  */\n+int\n ctf_str_add_external (ctf_file_t *fp, const char *str, uint32_t offset)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n-    return NULL;\n+    return 0;\n+\n+  atom = ctf_str_add_ref_internal (fp, str, FALSE, FALSE, 0);\n+  if (!atom)\n+    return 0;\n+\n+  atom->csa_external_offset = CTF_SET_STID (offset, CTF_STRTAB_1);\n+  return 1;\n+}\n \n-  atom = ctf_str_add_ref_internal (fp, str, FALSE, 0);\n+/* Remove a single ref.  */\n+void\n+ctf_str_remove_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n+{\n+  ctf_str_atom_ref_t *aref, *anext;\n+  ctf_str_atom_t *atom = NULL;\n+\n+  atom = ctf_dynhash_lookup (fp->ctf_str_atoms, str);\n   if (!atom)\n-    return NULL;\n+    return;\n \n-  atom->csa_offset = CTF_SET_STID (offset, CTF_STRTAB_1);\n-  return atom->csa_str;\n+  for (aref = ctf_list_next (&atom->csa_refs); aref != NULL; aref = anext)\n+    {\n+      anext = ctf_list_next (aref);\n+      if (aref->caf_ref == ref)\n+\t{\n+\t  ctf_list_delete (&atom->csa_refs, aref);\n+\t  ctf_free (aref);\n+\t}\n+    }\n }\n \n /* A ctf_dynhash_iter_remove() callback that removes atoms later than a given\n@@ -285,12 +356,25 @@ ctf_str_count_strtab (void *key _libctf_unused_, void *value,\n   ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n   ctf_strtab_write_state_t *s = (ctf_strtab_write_state_t *) arg;\n \n-  /* We only factor in the length of items that have no offset:\n-     other items are in the external strtab.  They still contribute to the\n-     total count, though, because we still have to sort them.  */\n-  if (!atom->csa_offset)\n-    s->strtab->cts_len += strlen (atom->csa_str) + 1;\n-  s->strtab_count++;\n+  /* We only factor in the length of items that have no offset and have refs:\n+     other items are in the external strtab, or will simply not be written out\n+     at all.  They still contribute to the total count, though, because we still\n+     have to sort them.  We add in the null string's length explicitly, outside\n+     this function, since it is explicitly written out even if it has no refs at\n+     all.  */\n+\n+  if (s->nullstr == atom)\n+    {\n+      s->strtab_count++;\n+      return;\n+    }\n+\n+  if (!ctf_list_empty_p (&atom->csa_refs))\n+    {\n+      if (!atom->csa_external_offset)\n+\ts->strtab->cts_len += strlen (atom->csa_str) + 1;\n+      s->strtab_count++;\n+    }\n }\n \n /* Populate the sorttab with pointers to the strtab atoms.  */\n@@ -305,7 +389,9 @@ ctf_str_populate_sorttab (void *key _libctf_unused_, void *value,\n   if (s->nullstr == atom)\n     return;\n \n-  s->sorttab[s->i++] = atom;\n+  /* Skip atoms with no refs.  */\n+  if (!ctf_list_empty_p (&atom->csa_refs))\n+    s->sorttab[s->i++] = atom;\n }\n \n /* Sort the strtab.  */\n@@ -346,7 +432,9 @@ ctf_str_write_strtab (ctf_file_t *fp)\n       return strtab;\n     }\n \n+  s.nullstr = nullstr;\n   ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_count_strtab, &s);\n+  strtab.cts_len++;\t\t\t\t/* For the null string.  */\n \n   ctf_dprintf (\"%lu bytes of strings in strtab.\\n\",\n \t       (unsigned long) strtab.cts_len);\n@@ -359,7 +447,6 @@ ctf_str_write_strtab (ctf_file_t *fp)\n   sorttab[0] = nullstr;\n   s.i = 1;\n   s.sorttab = sorttab;\n-  s.nullstr = nullstr;\n   ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_populate_sorttab, &s);\n \n   qsort (&sorttab[1], s.strtab_count - 1, sizeof (ctf_str_atom_t *),\n@@ -378,7 +465,7 @@ ctf_str_write_strtab (ctf_file_t *fp)\n   /* Update all refs: also update the strtab appropriately.  */\n   for (i = 0; i < s.strtab_count; i++)\n     {\n-      if (sorttab[i]->csa_offset)\n+      if (sorttab[i]->csa_external_offset)\n \t{\n \t  /* External strtab entry: populate the synthetic external strtab.\n \n@@ -388,17 +475,21 @@ ctf_str_write_strtab (ctf_file_t *fp)\n \t     until ctf_file_close.  */\n \n \t  any_external = 1;\n-\t  ctf_str_update_refs (sorttab[i], sorttab[i]->csa_offset);\n+\t  ctf_str_update_refs (sorttab[i], sorttab[i]->csa_external_offset);\n \t  if (ctf_dynhash_insert (fp->ctf_syn_ext_strtab,\n-\t\t\t\t  (void *) (uintptr_t) sorttab[i]->csa_offset,\n+\t\t\t\t  (void *) (uintptr_t)\n+\t\t\t\t  sorttab[i]->csa_external_offset,\n \t\t\t\t  (void *) sorttab[i]->csa_str) < 0)\n \t    goto oom_strtab;\n+\t  sorttab[i]->csa_offset = sorttab[i]->csa_external_offset;\n \t}\n       else\n \t{\n-\t  /* Internal strtab entry: actually add to the string table.  */\n+\t  /* Internal strtab entry with refs: actually add to the string\n+\t     table.  */\n \n \t  ctf_str_update_refs (sorttab[i], cur_stroff);\n+\t  sorttab[i]->csa_offset = cur_stroff;\n \t  strcpy (&strtab.cts_strs[cur_stroff], sorttab[i]->csa_str);\n \t  cur_stroff += strlen (sorttab[i]->csa_str) + 1;\n \t}\n@@ -411,6 +502,12 @@ ctf_str_write_strtab (ctf_file_t *fp)\n       fp->ctf_syn_ext_strtab = NULL;\n     }\n \n+  /* All the provisional strtab entries are now real strtab entries, and\n+     ctf_strptr() will find them there.  The provisional offset now starts right\n+     beyond the new end of the strtab.  */\n+\n+  ctf_dynhash_empty (fp->ctf_prov_strtab);\n+  fp->ctf_str_prov_offset = strtab.cts_len + 1;\n   return strtab;\n \n  oom_strtab:"
    },
    {
      "sha": "6e6776223438c5c3ee99260274317d1e6183b58e",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 211,
      "deletions": 66,
      "changes": 277,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -42,6 +42,7 @@ ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n {\n   ctf_file_t *ofp = fp;\n   const ctf_type_t *tp;\n+  ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n   uint32_t kind, n;\n   int rc;\n@@ -58,29 +59,43 @@ ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n   if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n     return (ctf_set_errno (ofp, ECTF_NOTSOU));\n \n-  if (size < CTF_LSTRUCT_THRESH)\n+  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n     {\n-      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t       increment);\n-\n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+      if (size < CTF_LSTRUCT_THRESH)\n \t{\n-\t  const char *name = ctf_strptr (fp, mp->ctm_name);\n-\t  if ((rc = func (name, mp->ctm_type, mp->ctm_offset, arg)) != 0)\n+\t  const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t   increment);\n+\n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t    {\n+\t      const char *name = ctf_strptr (fp, mp->ctm_name);\n+\t      if ((rc = func (name, mp->ctm_type, mp->ctm_offset, arg)) != 0)\n \t    return rc;\n+\t    }\n \t}\n+      else\n+\t{\n+\t  const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t      increment);\n \n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+\t    {\n+\t      const char *name = ctf_strptr (fp, lmp->ctlm_name);\n+\t      if ((rc = func (name, lmp->ctlm_type,\n+\t\t\t      (unsigned long) CTF_LMEM_OFFSET (lmp), arg)) != 0)\n+\t\treturn rc;\n+\t    }\n+\t}\n     }\n   else\n     {\n-      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t  increment);\n+      ctf_dmdef_t *dmd;\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n \t{\n-\t  const char *name = ctf_strptr (fp, lmp->ctlm_name);\n-\t  if ((rc = func (name, lmp->ctlm_type,\n-\t\t\t  (unsigned long) CTF_LMEM_OFFSET (lmp), arg)) != 0)\n+\t  if ((rc = func (dmd->dmd_name, dmd->dmd_type,\n+\t\t\t  dmd->dmd_offset, arg)) != 0)\n \t    return rc;\n \t}\n     }\n@@ -97,6 +112,7 @@ ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n   ctf_file_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n+  ctf_dtdef_t *dtd;\n   ssize_t increment;\n   uint32_t n;\n   int rc;\n@@ -112,13 +128,27 @@ ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n \n   (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n \n-  ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n+  if ((dtd = ctf_dynamic_type (ofp, type)) == NULL)\n+    {\n+      ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n \n-  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+\t{\n+\t  const char *name = ctf_strptr (fp, ep->cte_name);\n+\t  if ((rc = func (name, ep->cte_value, arg)) != 0)\n+\t    return rc;\n+\t}\n+    }\n+  else\n     {\n-      const char *name = ctf_strptr (fp, ep->cte_name);\n-      if ((rc = func (name, ep->cte_value, arg)) != 0)\n-\treturn rc;\n+      ctf_dmdef_t *dmd;\n+\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+\t{\n+\t  if ((rc = func (dmd->dmd_name, dmd->dmd_value, arg)) != 0)\n+\t    return rc;\n+\t}\n     }\n \n   return 0;\n@@ -171,16 +201,30 @@ ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n int\n ctf_variable_iter (ctf_file_t *fp, ctf_variable_f *func, void *arg)\n {\n-  unsigned long i;\n   int rc;\n \n   if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parent == NULL))\n     return ECTF_NOPARENT;\n \n-  for (i = 0; i < fp->ctf_nvars; i++)\n-    if ((rc = func (ctf_strptr (fp, fp->ctf_vars[i].ctv_name),\n-\t\t    fp->ctf_vars[i].ctv_type, arg)) != 0)\n-      return rc;\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    {\n+      unsigned long i;\n+      for (i = 0; i < fp->ctf_nvars; i++)\n+\tif ((rc = func (ctf_strptr (fp, fp->ctf_vars[i].ctv_name),\n+\t\t\tfp->ctf_vars[i].ctv_type, arg)) != 0)\n+\t  return rc;\n+    }\n+  else\n+    {\n+      ctf_dvdef_t *dvd;\n+\n+      for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n+\t   dvd = ctf_list_next (dvd))\n+\t{\n+\t  if ((rc = func (dvd->dvd_name, dvd->dvd_type, arg)) != 0)\n+\t    return rc;\n+\t}\n+    }\n \n   return 0;\n }\n@@ -249,6 +293,29 @@ ctf_type_resolve_unsliced (ctf_file_t *fp, ctf_id_t type)\n   return type;\n }\n \n+/* Look up a name in the given name table, in the appropriate hash given the\n+   kind of the identifier.  The name is a raw, undecorated identifier.  */\n+\n+ctf_id_t ctf_lookup_by_rawname (ctf_file_t *fp, int kind, const char *name)\n+{\n+  return ctf_lookup_by_rawhash (fp, ctf_name_table (fp, kind), name);\n+}\n+\n+/* Look up a name in the given name table, in the appropriate hash given the\n+   readability state of the dictionary.  The name is a raw, undecorated\n+   identifier.  */\n+\n+ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *fp, ctf_names_t *np, const char *name)\n+{\n+  ctf_id_t id;\n+\n+  if (fp->ctf_flags & LCTF_RDWR)\n+    id = (ctf_id_t) ctf_dynhash_lookup (np->ctn_writable, name);\n+  else\n+    id = ctf_hash_lookup_type (np->ctn_readonly, fp, name);\n+  return id;\n+}\n+\n /* Lookup the given type ID and return its name as a new dynamcally-allocated\n    string.  */\n \n@@ -829,6 +896,7 @@ ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n {\n   ctf_file_t *ofp = fp;\n   const ctf_type_t *tp;\n+  ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n   uint32_t kind, n;\n \n@@ -844,32 +912,50 @@ ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n   if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n     return (ctf_set_errno (ofp, ECTF_NOTSOU));\n \n-  if (size < CTF_LSTRUCT_THRESH)\n+  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n     {\n-      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t       increment);\n+      if (size < CTF_LSTRUCT_THRESH)\n+\t{\n+\t  const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t   increment);\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t    {\n+\t      if (strcmp (ctf_strptr (fp, mp->ctm_name), name) == 0)\n+\t\t{\n+\t\t  mip->ctm_type = mp->ctm_type;\n+\t\t  mip->ctm_offset = mp->ctm_offset;\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t}\n+      else\n \t{\n-\t  if (strcmp (ctf_strptr (fp, mp->ctm_name), name) == 0)\n+\t  const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t      increment);\n+\n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n \t    {\n-\t      mip->ctm_type = mp->ctm_type;\n-\t      mip->ctm_offset = mp->ctm_offset;\n-\t      return 0;\n+\t      if (strcmp (ctf_strptr (fp, lmp->ctlm_name), name) == 0)\n+\t\t{\n+\t\t  mip->ctm_type = lmp->ctlm_type;\n+\t\t  mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n+\t\t  return 0;\n+\t\t}\n \t    }\n \t}\n     }\n   else\n     {\n-      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t  increment);\n+      ctf_dmdef_t *dmd;\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n \t{\n-\t  if (strcmp (ctf_strptr (fp, lmp->ctlm_name), name) == 0)\n+\t  if (strcmp (dmd->dmd_name, name) == 0)\n \t    {\n-\t      mip->ctm_type = lmp->ctlm_type;\n-\t      mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n+\t      mip->ctm_type = dmd->dmd_type;\n+\t      mip->ctm_offset = dmd->dmd_offset;\n \t      return 0;\n \t    }\n \t}\n@@ -920,6 +1006,7 @@ ctf_enum_name (ctf_file_t *fp, ctf_id_t type, int value)\n   ctf_file_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n+  const ctf_dtdef_t *dtd;\n   ssize_t increment;\n   uint32_t n;\n \n@@ -937,12 +1024,26 @@ ctf_enum_name (ctf_file_t *fp, ctf_id_t type, int value)\n \n   (void) ctf_get_ctt_size (fp, tp, NULL, &increment);\n \n-  ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n+  if ((dtd = ctf_dynamic_type (ofp, type)) == NULL)\n+    {\n+      ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n \n-  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+\t{\n+\t  if (ep->cte_value == value)\n+\t    return (ctf_strptr (fp, ep->cte_name));\n+\t}\n+    }\n+  else\n     {\n-      if (ep->cte_value == value)\n-\treturn (ctf_strptr (fp, ep->cte_name));\n+      ctf_dmdef_t *dmd;\n+\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+\t{\n+\t  if (dmd->dmd_value == value)\n+\t    return dmd->dmd_name;\n+\t}\n     }\n \n   (void) ctf_set_errno (ofp, ECTF_NOENUMNAM);\n@@ -958,6 +1059,7 @@ ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n   ctf_file_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n+  const ctf_dtdef_t *dtd;\n   ssize_t increment;\n   uint32_t n;\n \n@@ -977,13 +1079,31 @@ ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n \n   ep = (const ctf_enum_t *) ((uintptr_t) tp + increment);\n \n-  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n+  if ((dtd = ctf_dynamic_type (ofp, type)) == NULL)\n     {\n-      if (strcmp (ctf_strptr (fp, ep->cte_name), name) == 0)\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, ep++)\n \t{\n-\t  if (valp != NULL)\n-\t    *valp = ep->cte_value;\n-\t  return 0;\n+\t  if (strcmp (ctf_strptr (fp, ep->cte_name), name) == 0)\n+\t    {\n+\t      if (valp != NULL)\n+\t\t*valp = ep->cte_value;\n+\t      return 0;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      ctf_dmdef_t *dmd;\n+\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+\t{\n+\t  if (strcmp (dmd->dmd_name, name) == 0)\n+\t    {\n+\t      if (valp != NULL)\n+\t\t*valp = dmd->dmd_value;\n+\t      return 0;\n+\t    }\n \t}\n     }\n \n@@ -1000,6 +1120,7 @@ ctf_func_type_info (ctf_file_t *fp, ctf_id_t type, ctf_funcinfo_t *fip)\n   const ctf_type_t *tp;\n   uint32_t kind;\n   const uint32_t *args;\n+  const ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n@@ -1015,10 +1136,13 @@ ctf_func_type_info (ctf_file_t *fp, ctf_id_t type, ctf_funcinfo_t *fip)\n     return (ctf_set_errno (fp, ECTF_NOTFUNC));\n \n   fip->ctc_return = tp->ctt_type;\n-  fip->ctc_argc = LCTF_INFO_VLEN (fp, tp->ctt_info);\n   fip->ctc_flags = 0;\n+  fip->ctc_argc = LCTF_INFO_VLEN (fp, tp->ctt_info);\n \n-  args = (uint32_t *) ((uintptr_t) tp + increment);\n+  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n+    args = (uint32_t *) ((uintptr_t) tp + increment);\n+  else\n+    args = (uint32_t *) dtd->dtd_u.dtu_argv;\n \n   if (fip->ctc_argc != 0 && args[fip->ctc_argc - 1] == 0)\n     {\n@@ -1037,6 +1161,7 @@ ctf_func_type_args (ctf_file_t *fp, ctf_id_t type, uint32_t argc, ctf_id_t *argv\n {\n   const ctf_type_t *tp;\n   const uint32_t *args;\n+  const ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n   ctf_funcinfo_t f;\n \n@@ -1051,7 +1176,10 @@ ctf_func_type_args (ctf_file_t *fp, ctf_id_t type, uint32_t argc, ctf_id_t *argv\n \n   (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n \n-  args = (uint32_t *) ((uintptr_t) tp + increment);\n+  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n+    args = (uint32_t *) ((uintptr_t) tp + increment);\n+  else\n+    args = (uint32_t *) dtd->dtd_u.dtu_argv;\n \n   for (argc = MIN (argc, f.ctc_argc); argc != 0; argc--)\n     *argv++ = *args++;\n@@ -1071,6 +1199,7 @@ ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n {\n   ctf_id_t otype = type;\n   const ctf_type_t *tp;\n+  const ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n   uint32_t kind, n;\n   int rc;\n@@ -1091,32 +1220,48 @@ ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n \n   (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n \n-  if (size < CTF_LSTRUCT_THRESH)\n+  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n     {\n-      const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t       increment);\n-\n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+      if (size < CTF_LSTRUCT_THRESH)\n \t{\n-\t  if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n-\t\t\t\t     func, arg, ctf_strptr (fp, mp->ctm_name),\n-\t\t\t\t     offset + mp->ctm_offset,\n-\t\t\t\t     depth + 1)) != 0)\n-\t    return rc;\n+\t  const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t   increment);\n+\n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n+\t    {\n+\t      if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n+\t\t\t\t\t func, arg, ctf_strptr (fp,\n+\t\t\t\t\t\t\t\tmp->ctm_name),\n+\t\t\t\t\t offset + mp->ctm_offset,\n+\t\t\t\t\t depth + 1)) != 0)\n+\t\treturn rc;\n+\t    }\n \t}\n+      else\n+\t{\n+\t  const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t\t      increment);\n \n+\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+\t    {\n+\t      if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n+\t\t\t\t\t func, arg, ctf_strptr (fp,\n+\t\t\t\t\t\t\t\tlmp->ctlm_name),\n+\t\t\t\t\t offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n+\t\t\t\t\t depth + 1)) != 0)\n+\t\treturn rc;\n+\t    }\n+\t}\n     }\n   else\n     {\n-      const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t  increment);\n+      ctf_dmdef_t *dmd;\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n \t{\n-\t  if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n-\t\t\t\t     func, arg, ctf_strptr (fp,\n-\t\t\t\t\t\t\t    lmp->ctlm_name),\n-\t\t\t\t     offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n+\t  if ((rc = ctf_type_rvisit (fp, dmd->dmd_type, func, arg,\n+\t\t\t\t     dmd->dmd_name, dmd->dmd_offset,\n \t\t\t\t     depth + 1)) != 0)\n \t    return rc;\n \t}"
    },
    {
      "sha": "f27c76852005223f7e174447ae031f04f9f3a5b5",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/676c3ecbad6e9c41b906b0f882ef2ce23f49976a/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=676c3ecbad6e9c41b906b0f882ef2ce23f49976a",
      "patch": "@@ -80,6 +80,14 @@ ctf_list_delete (ctf_list_t *lp, void *existing)\n     lp->l_prev = p->l_prev;\n }\n \n+/* Return 1 if the list is empty.  */\n+\n+int\n+ctf_list_empty_p (ctf_list_t *lp)\n+{\n+  return (lp->l_next == NULL && lp->l_prev == NULL);\n+}\n+\n /* Convert a 32-bit ELF symbol into Elf64 and return a pointer to it.  */\n \n Elf64_Sym *"
    }
  ]
}