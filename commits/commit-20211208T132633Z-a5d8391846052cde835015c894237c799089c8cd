{
  "sha": "a5d8391846052cde835015c894237c799089c8cd",
  "node_id": "C_kwDOANOeidoAKGE1ZDgzOTE4NDYwNTJjZGU4MzUwMTVjODk0MjM3Yzc5OTA4OWM4Y2Q",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-06T11:25:12Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-08T13:26:33Z"
    },
    "message": "gdb: use try/catch around a gdb_disassembler::print_insn call\n\nWhile investigating some disassembler problems I ran into this case;\nGDB compiled on a 32-bit arm target, with --enable-targets=all.  Then\nin GDB:\n\n  (gdb) set architecture i386\n  (gdb) disassemble 0x0,+4\n  unknown disassembler error (error = -1)\n\nThis is interesting because it shows a case where the libopcodes\ndisassembler is returning -1 without first calling the\nmemory_error_func callback.  Indeed, the return from libopcodes\nhappens from this code snippet in i386-dis.c in the print_insn\nfunction:\n\n  if (address_mode == mode_64bit && sizeof (bfd_vma) < 8)\n    {\n      (*info->fprintf_func) (info->stream,\n\t\t\t     _(\"64-bit address is disabled\"));\n      return -1;\n    }\n\nNotice how, prior to the return the disassembler tries to print a\nhelpful message out, but GDB doesn't print this message.\n\nThe reason this message goes missing is the call stack, it looks like\nthis:\n\n  gdb_pretty_print_disassembler::pretty_print_insn\n    gdb_disassembler::print_insn\n      gdbarch_print_insn\n        ...\n          i386-dis.c:print_insn\n\nWhen i386-dis.c:print_insn returns -1 this is handled in\ngdb_disassembler::print_insn, where an exception is thrown.  However,\nthe actual printing of the disassembler output is done in\ngdb_pretty_print_disassembler::pretty_print_insn, and is only done if\nan exception is not thrown.\n\nIn this commit I change this.  The pretty_print_insn now uses\ntry/catch around the call to gdb_disassembler::print_insn, if we catch\nan error then we first print any pending output in the instruction\nbuffer, before rethrowing the exception.  As a result, even if an\nexception is thrown we still print any pending disassembler output to\nthe screen; in the above case the helpful message will now be shown.\n\nBefore my patch we might expect to see this output:\n\n  (gdb) disassemble 0x0,+4\n  Dump of assembler code from 0x0 to 0x4:\n     0x0000000000000000:\tunknown disassembler error (error = -1)\n  (gdb)\n\nBut now we see this:\n\n  (gdb) disassemble 0x0,+4\n  Dump of assembler code from 0x0 to 0x4:\n     0x0000000000000000:\t64-bit address is disabled\n  unknown disassembler error (error = -1)\n\nIf the disassembler returns -1 without printing a helpful message then\nwe would still expect a change in output, something like:\n\n  (gdb) disassemble 0x0,+4\n  Dump of assembler code from 0x0 to 0x4:\n     0x0000000000000000:\n  unknown disassembler error (error = -1)\n\nWhich I think is still acceptable, though at this point I think a\nstrong case can be made that this is a disassembler bug (not printing\nanything, but still returning -1).\n\nNotice however, that the error message is always printed on a new line\nnow.  This is also true for the memory error case, where before we\nmight see this:\n\n  (gdb) disassemble 0x0,+4\n  Dump of assembler code from 0x0 to 0x4:\n     0x00000000:\tCannot access memory at address 0x0\n\nWe now get this:\n\n  (gdb) disassemble 0x0,+4\n  Dump of assembler code from 0x0 to 0x4:\n     0x00000000:\n  Cannot access memory at address 0x0\n\nFor me, I'm happy to accept this change, having the error on a line by\nitself, rather than just appended to the end of the previous line,\nseems like an improvement, but I'm aware others might feel\ndifferently, so I'd appreciate any feedback.",
    "tree": {
      "sha": "a4faef1db7d2e0a1da79d259cb22d0a5af52789d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a4faef1db7d2e0a1da79d259cb22d0a5af52789d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a5d8391846052cde835015c894237c799089c8cd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5d8391846052cde835015c894237c799089c8cd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a5d8391846052cde835015c894237c799089c8cd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5d8391846052cde835015c894237c799089c8cd/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "2bd64d21094f9527c9a6019f668c16ca897b2631",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2bd64d21094f9527c9a6019f668c16ca897b2631",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2bd64d21094f9527c9a6019f668c16ca897b2631"
    }
  ],
  "stats": {
    "total": 39,
    "additions": 34,
    "deletions": 5
  },
  "files": [
    {
      "sha": "4d1ee6893f559608dc8090a2bcbb1c4c3705795d",
      "filename": "gdb/disasm.c",
      "status": "modified",
      "additions": 34,
      "deletions": 5,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a5d8391846052cde835015c894237c799089c8cd/gdb/disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a5d8391846052cde835015c894237c799089c8cd/gdb/disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/disasm.c?ref=a5d8391846052cde835015c894237c799089c8cd",
      "patch": "@@ -270,8 +270,40 @@ gdb_pretty_print_disassembler::pretty_print_insn (const struct disasm_insn *insn\n     else\n       m_uiout->text (\":\\t\");\n \n+    /* Clear the buffer into which we will disassemble the instruction.  */\n     m_insn_stb.clear ();\n \n+    /* A helper function to write the M_INSN_STB buffer, followed by a\n+       newline.  This can be called in a couple of situations.  */\n+    auto write_out_insn_buffer = [&] ()\n+    {\n+      m_uiout->field_stream (\"inst\", m_insn_stb);\n+      m_uiout->text (\"\\n\");\n+    };\n+\n+    try\n+      {\n+\t/* Now we can disassemble the instruction.  If the disassembler\n+\t   returns a negative value this indicates an error and is handled\n+\t   within the print_insn call, resulting in an exception being\n+\t   thrown.  Returning zero makes no sense, as this indicates we\n+\t   disassembled something successfully, but it was something of no\n+\t   size?  */\n+\tsize = m_di.print_insn (pc);\n+\tgdb_assert (size > 0);\n+      }\n+    catch (const gdb_exception &ex)\n+      {\n+\t/* An exception was thrown while disassembling the instruction.\n+\t   However, the disassembler might still have written something\n+\t   out, so ensure that we flush the instruction buffer before\n+\t   rethrowing the exception.  We can't perform this write from an\n+\t   object destructor as the write itself might throw an exception\n+\t   if the pager kicks in, and the user selects quit.  */\n+\twrite_out_insn_buffer ();\n+\tthrow ex;\n+      }\n+\n     if (flags & DISASSEMBLY_RAW_INSN)\n       {\n \tCORE_ADDR end_pc;\n@@ -282,7 +314,6 @@ gdb_pretty_print_disassembler::pretty_print_insn (const struct disasm_insn *insn\n \t   write them out in a single go for the MI.  */\n \tm_opcode_stb.clear ();\n \n-\tsize = m_di.print_insn (pc);\n \tend_pc = pc + size;\n \n \tfor (;pc < end_pc; ++pc)\n@@ -295,12 +326,10 @@ gdb_pretty_print_disassembler::pretty_print_insn (const struct disasm_insn *insn\n \tm_uiout->field_stream (\"opcodes\", m_opcode_stb);\n \tm_uiout->text (\"\\t\");\n       }\n-    else\n-      size = m_di.print_insn (pc);\n \n-    m_uiout->field_stream (\"inst\", m_insn_stb);\n+    /* Disassembly was a success, write out the instruction buffer.  */\n+    write_out_insn_buffer ();\n   }\n-  m_uiout->text (\"\\n\");\n \n   return size;\n }"
    }
  ]
}