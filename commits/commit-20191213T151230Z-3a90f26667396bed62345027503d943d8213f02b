{
  "sha": "3a90f26667396bed62345027503d943d8213f02b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2E5MGYyNjY2NzM5NmJlZDYyMzQ1MDI3NTAzZDk0M2Q4MjEzZjAyYg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2019-12-13T15:12:30Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2019-12-13T15:12:30Z"
    },
    "message": "Fix indentation in jit.c\n\nMany places in this file use spaces only for indentation.  Fix them to\nconform to GNU style.\n\ngdb/ChangeLog:\n\n\t* jit.c: Fix indentation, replace spaces with tabs where\n\tapplicable.",
    "tree": {
      "sha": "a4fe6ff172d78b2a1f81d9bf30cc5045417f423c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a4fe6ff172d78b2a1f81d9bf30cc5045417f423c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3a90f26667396bed62345027503d943d8213f02b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3a90f26667396bed62345027503d943d8213f02b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3a90f26667396bed62345027503d943d8213f02b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3a90f26667396bed62345027503d943d8213f02b/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b3f4b80fba8bee1d1d2601424d0be0f2adcb0d79",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3f4b80fba8bee1d1d2601424d0be0f2adcb0d79",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b3f4b80fba8bee1d1d2601424d0be0f2adcb0d79"
    }
  ],
  "stats": {
    "total": 117,
    "additions": 61,
    "deletions": 56
  },
  "files": [
    {
      "sha": "81f70f27c9f92d88b2c36c569cfae07689908882",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3a90f26667396bed62345027503d943d8213f02b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3a90f26667396bed62345027503d943d8213f02b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3a90f26667396bed62345027503d943d8213f02b",
      "patch": "@@ -1,3 +1,8 @@\n+2019-12-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* jit.c: Fix indentation, replace spaces with tabs where\n+\tapplicable.\n+\n 2019-12-13  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* configure.tgt: Match msp430-*-elf* targets when configuring GDB."
    },
    {
      "sha": "9ea68330212aafe23451a93364ce6c1688a147fc",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 56,
      "deletions": 56,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3a90f26667396bed62345027503d943d8213f02b/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3a90f26667396bed62345027503d943d8213f02b/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=3a90f26667396bed62345027503d943d8213f02b",
      "patch": "@@ -100,7 +100,7 @@ mem_bfd_iovec_close (struct bfd *abfd, void *stream)\n \n static file_ptr\n mem_bfd_iovec_pread (struct bfd *abfd, void *stream, void *buf,\n-                     file_ptr nbytes, file_ptr offset)\n+\t\t     file_ptr nbytes, file_ptr offset)\n {\n   int err;\n   struct target_buffer *buffer = (struct target_buffer *) stream;\n@@ -185,13 +185,13 @@ jit_reader_load (const char *file_name)\n \n   if (jit_debug)\n     fprintf_unfiltered (gdb_stdlog, _(\"Opening shared object %s.\\n\"),\n-                        file_name);\n+\t\t\tfile_name);\n   gdb_dlhandle_up so = gdb_dlopen (file_name);\n \n   init_fn = (reader_init_fn_type *) gdb_dlsym (so, reader_init_fn_sym);\n   if (!init_fn)\n     error (_(\"Could not locate initialization function: %s.\"),\n-          reader_init_fn_sym);\n+\t   reader_init_fn_sym);\n \n   if (gdb_dlsym (so, \"plugin_is_GPL_compatible\") == NULL)\n     error (_(\"Reader not GPL compatible.\"));\n@@ -509,8 +509,8 @@ jit_object_open_impl (struct gdb_symbol_callbacks *cb)\n \n static struct gdb_symtab *\n jit_symtab_open_impl (struct gdb_symbol_callbacks *cb,\n-                      struct gdb_object *object,\n-                      const char *file_name)\n+\t\t      struct gdb_object *object,\n+\t\t      const char *file_name)\n {\n   struct gdb_symtab *ret;\n \n@@ -528,7 +528,7 @@ jit_symtab_open_impl (struct gdb_symbol_callbacks *cb,\n \n static int\n compare_block (const struct gdb_block *const old,\n-               const struct gdb_block *const newobj)\n+\t       const struct gdb_block *const newobj)\n {\n   if (old == NULL)\n     return 1;\n@@ -537,9 +537,9 @@ compare_block (const struct gdb_block *const old,\n   else if (old->begin == newobj->begin)\n     {\n       if (old->end > newobj->end)\n-        return 1;\n+\treturn 1;\n       else\n-        return 0;\n+\treturn 0;\n     }\n   else\n     return 0;\n@@ -551,8 +551,8 @@ compare_block (const struct gdb_block *const old,\n \n static struct gdb_block *\n jit_block_open_impl (struct gdb_symbol_callbacks *cb,\n-                     struct gdb_symtab *symtab, struct gdb_block *parent,\n-                     GDB_CORE_ADDR begin, GDB_CORE_ADDR end, const char *name)\n+\t\t     struct gdb_symtab *symtab, struct gdb_block *parent,\n+\t\t     GDB_CORE_ADDR begin, GDB_CORE_ADDR end, const char *name)\n {\n   struct gdb_block *block = XCNEW (struct gdb_block);\n \n@@ -573,16 +573,16 @@ jit_block_open_impl (struct gdb_symbol_callbacks *cb,\n       struct gdb_block *i = symtab->blocks;\n \n       for (;; i = i->next)\n-        {\n-          /* Guaranteed to terminate, since compare_block (NULL, _)\n-             returns 1.  */\n-          if (compare_block (i->next, block))\n-            {\n-              block->next = i->next;\n-              i->next = block;\n-              break;\n-            }\n-        }\n+\t{\n+\t  /* Guaranteed to terminate, since compare_block (NULL, _)\n+\t     returns 1.  */\n+\t  if (compare_block (i->next, block))\n+\t    {\n+\t      block->next = i->next;\n+\t      i->next = block;\n+\t      break;\n+\t    }\n+\t}\n     }\n   symtab->nblocks++;\n \n@@ -594,8 +594,8 @@ jit_block_open_impl (struct gdb_symbol_callbacks *cb,\n \n static void\n jit_symtab_line_mapping_add_impl (struct gdb_symbol_callbacks *cb,\n-                                  struct gdb_symtab *stab, int nlines,\n-                                  struct gdb_line_mapping *map)\n+\t\t\t\t  struct gdb_symtab *stab, int nlines,\n+\t\t\t\t  struct gdb_line_mapping *map)\n {\n   int i;\n   int alloc_len;\n@@ -619,7 +619,7 @@ jit_symtab_line_mapping_add_impl (struct gdb_symbol_callbacks *cb,\n \n static void\n jit_symtab_close_impl (struct gdb_symbol_callbacks *cb,\n-                       struct gdb_symtab *stab)\n+\t\t       struct gdb_symtab *stab)\n {\n   /* Right now nothing needs to be done here.  We may need to do some\n      cleanup here in the future (again, without breaking the plugin\n@@ -661,7 +661,7 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n     }\n \n   blockvector_size = (sizeof (struct blockvector)\n-                      + (actual_nblocks - 1) * sizeof (struct block *));\n+\t\t      + (actual_nblocks - 1) * sizeof (struct block *));\n   bv = (struct blockvector *) obstack_alloc (&objfile->objfile_obstack,\n \t\t\t\t\t     blockvector_size);\n   COMPUNIT_BLOCKVECTOR (cust) = bv;\n@@ -707,9 +707,9 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n \n       BLOCKVECTOR_BLOCK (bv, i) = new_block;\n       if (begin > BLOCK_START (new_block))\n-        begin = BLOCK_START (new_block);\n+\tbegin = BLOCK_START (new_block);\n       if (end < BLOCK_END (new_block))\n-        end = BLOCK_END (new_block);\n+\tend = BLOCK_END (new_block);\n \n       gdb_block_iter->real_block = new_block;\n     }\n@@ -778,7 +778,7 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n \n static void\n jit_object_close_impl (struct gdb_symbol_callbacks *cb,\n-                       struct gdb_object *obj)\n+\t\t       struct gdb_object *obj)\n {\n   struct gdb_symtab *i, *j;\n   struct objfile *objfile;\n@@ -806,7 +806,7 @@ jit_object_close_impl (struct gdb_symbol_callbacks *cb,\n \n static int\n jit_reader_try_read_symtab (struct jit_code_entry *code_entry,\n-                            CORE_ADDR entry_addr)\n+\t\t\t    CORE_ADDR entry_addr)\n {\n   int status;\n   jit_dbg_reader_data priv_data;\n@@ -849,13 +849,13 @@ jit_reader_try_read_symtab (struct jit_code_entry *code_entry,\n       funcs = loaded_jit_reader->functions;\n       if (funcs->read (funcs, &callbacks, gdb_mem.data (),\n \t\t       code_entry->symfile_size)\n-          != GDB_SUCCESS)\n-        status = 0;\n+\t  != GDB_SUCCESS)\n+\tstatus = 0;\n     }\n \n   if (jit_debug && status == 0)\n     fprintf_unfiltered (gdb_stdlog,\n-                        \"Could not read symtab using the loaded JIT reader.\\n\");\n+\t\t\t\"Could not read symtab using the loaded JIT reader.\\n\");\n   return status;\n }\n \n@@ -864,8 +864,8 @@ jit_reader_try_read_symtab (struct jit_code_entry *code_entry,\n \n static void\n jit_bfd_try_read_symtab (struct jit_code_entry *code_entry,\n-                         CORE_ADDR entry_addr,\n-                         struct gdbarch *gdbarch)\n+\t\t\t CORE_ADDR entry_addr,\n+\t\t\t struct gdbarch *gdbarch)\n {\n   struct bfd_section *sec;\n   struct objfile *objfile;\n@@ -900,7 +900,7 @@ JITed symbol file is not an object file, ignoring it.\\n\"));\n   b = gdbarch_bfd_arch_info (gdbarch);\n   if (b->compatible (b, bfd_get_arch_info (nbfd.get ())) != b)\n     warning (_(\"JITed object file architecture %s is not compatible \"\n-               \"with target architecture %s.\"),\n+\t       \"with target architecture %s.\"),\n \t     bfd_get_arch_info (nbfd.get ())->printable_name,\n \t     b->printable_name);\n \n@@ -911,8 +911,8 @@ JITed symbol file is not an object file, ignoring it.\\n\"));\n   for (sec = nbfd->sections; sec != NULL; sec = sec->next)\n     if ((bfd_section_flags (sec) & (SEC_ALLOC|SEC_LOAD)) != 0)\n       {\n-        /* We assume that these virtual addresses are absolute, and do not\n-           treat them as offsets.  */\n+\t/* We assume that these virtual addresses are absolute, and do not\n+\t   treat them as offsets.  */\n \tsai.emplace_back (bfd_section_vma (sec),\n \t\t\t  bfd_section_name (sec),\n \t\t\t  sec->index);\n@@ -934,16 +934,16 @@ JITed symbol file is not an object file, ignoring it.\\n\"));\n \n static void\n jit_register_code (struct gdbarch *gdbarch,\n-                   CORE_ADDR entry_addr, struct jit_code_entry *code_entry)\n+\t\t   CORE_ADDR entry_addr, struct jit_code_entry *code_entry)\n {\n   int success;\n \n   if (jit_debug)\n     fprintf_unfiltered (gdb_stdlog,\n-                        \"jit_register_code, symfile_addr = %s, \"\n-                        \"symfile_size = %s\\n\",\n-                        paddress (gdbarch, code_entry->symfile_addr),\n-                        pulongest (code_entry->symfile_size));\n+\t\t\t\"jit_register_code, symfile_addr = %s, \"\n+\t\t\t\"symfile_size = %s\\n\",\n+\t\t\tpaddress (gdbarch, code_entry->symfile_addr),\n+\t\t\tpulongest (code_entry->symfile_size));\n \n   success = jit_reader_try_read_symtab (code_entry, entry_addr);\n \n@@ -963,7 +963,7 @@ jit_find_objf_with_entry_addr (CORE_ADDR entry_addr)\n       objf_data\n \t= (struct jit_objfile_data *) objfile_data (objf, jit_objfile_data);\n       if (objf_data != NULL && objf_data->addr == entry_addr)\n-        return objf;\n+\treturn objf;\n     }\n   return NULL;\n }\n@@ -1067,21 +1067,21 @@ struct jit_unwind_private\n \n static void\n jit_unwind_reg_set_impl (struct gdb_unwind_callbacks *cb, int dwarf_regnum,\n-                         struct gdb_reg_value *value)\n+\t\t\t struct gdb_reg_value *value)\n {\n   struct jit_unwind_private *priv;\n   int gdb_reg;\n \n   priv = (struct jit_unwind_private *) cb->priv_data;\n \n   gdb_reg = gdbarch_dwarf2_reg_to_regnum (get_frame_arch (priv->this_frame),\n-                                          dwarf_regnum);\n+\t\t\t\t\t  dwarf_regnum);\n   if (gdb_reg == -1)\n     {\n       if (jit_debug)\n-        fprintf_unfiltered (gdb_stdlog,\n-                            _(\"Could not recognize DWARF regnum %d\"),\n-                            dwarf_regnum);\n+\tfprintf_unfiltered (gdb_stdlog,\n+\t\t\t    _(\"Could not recognize DWARF regnum %d\"),\n+\t\t\t    dwarf_regnum);\n       value->free (value);\n       return;\n     }\n@@ -1143,7 +1143,7 @@ jit_dealloc_cache (struct frame_info *this_frame, void *cache)\n \n static int\n jit_frame_sniffer (const struct frame_unwind *self,\n-                   struct frame_info *this_frame, void **cache)\n+\t\t   struct frame_info *this_frame, void **cache)\n {\n   struct jit_unwind_private *priv_data;\n   struct gdb_unwind_callbacks callbacks;\n@@ -1173,13 +1173,13 @@ jit_frame_sniffer (const struct frame_unwind *self,\n   if (funcs->unwind (funcs, &callbacks) == GDB_SUCCESS)\n     {\n       if (jit_debug)\n-        fprintf_unfiltered (gdb_stdlog, _(\"Successfully unwound frame using \"\n-                                          \"JIT reader.\\n\"));\n+\tfprintf_unfiltered (gdb_stdlog, _(\"Successfully unwound frame using \"\n+\t\t\t\t\t  \"JIT reader.\\n\"));\n       return 1;\n     }\n   if (jit_debug)\n     fprintf_unfiltered (gdb_stdlog, _(\"Could not unwind frame using \"\n-                                      \"JIT reader.\\n\"));\n+\t\t\t\t      \"JIT reader.\\n\"));\n \n   jit_dealloc_cache (this_frame, *cache);\n   *cache = NULL;\n@@ -1193,7 +1193,7 @@ jit_frame_sniffer (const struct frame_unwind *self,\n \n static void\n jit_frame_this_id (struct frame_info *this_frame, void **cache,\n-                   struct frame_id *this_id)\n+\t\t   struct frame_id *this_id)\n {\n   struct jit_unwind_private priv;\n   struct gdb_frame_id frame_id;\n@@ -1321,9 +1321,9 @@ jit_inferior_init (struct gdbarch *gdbarch)\n       jit_read_code_entry (gdbarch, cur_entry_addr, &cur_entry);\n \n       /* This hook may be called many times during setup, so make sure we don't\n-         add the same symbol file twice.  */\n+\t add the same symbol file twice.  */\n       if (jit_find_objf_with_entry_addr (cur_entry_addr) != NULL)\n-        continue;\n+\tcontinue;\n \n       jit_register_code (gdbarch, cur_entry_addr, &cur_entry);\n     }\n@@ -1402,7 +1402,7 @@ jit_event_handler (struct gdbarch *gdbarch)\n \t\t\t     \"entry at address: %s\\n\"),\n \t\t\t   paddress (gdbarch, entry_addr));\n       else\n-        objf->unlink ();\n+\tobjf->unlink ();\n \n       break;\n     default:\n@@ -1453,7 +1453,7 @@ void\n _initialize_jit (void)\n {\n   jit_reader_dir = relocate_gdb_directory (JIT_READER_DIR,\n-                                           JIT_READER_DIR_RELOCATABLE);\n+\t\t\t\t\t   JIT_READER_DIR_RELOCATABLE);\n   add_setshow_zuinteger_cmd (\"jit\", class_maintenance, &jit_debug,\n \t\t\t     _(\"Set JIT debugging.\"),\n \t\t\t     _(\"Show JIT debugging.\"),"
    }
  ]
}