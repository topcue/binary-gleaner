{
  "sha": "b331e677d748b322003d4f59eb0bd2ce3feada4b",
  "node_id": "C_kwDOANOeidoAKGIzMzFlNjc3ZDc0OGIzMjIwMDNkNGY1OWViMGJkMmNlM2ZlYWRhNGI",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-06T07:17:02Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:38Z"
    },
    "message": "sim: mips: migrate to standard uintXX_t types\n\nMove off the sim-specific unsignedXX types and to the standard uintXX_t\ntypes that C11 provides.",
    "tree": {
      "sha": "503b5ffee9d67e7d258d15a3c30ac6c367f313bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/503b5ffee9d67e7d258d15a3c30ac6c367f313bd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b331e677d748b322003d4f59eb0bd2ce3feada4b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b331e677d748b322003d4f59eb0bd2ce3feada4b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b331e677d748b322003d4f59eb0bd2ce3feada4b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b331e677d748b322003d4f59eb0bd2ce3feada4b/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2875d098a59a72d3dd942d89901318aed6331cf6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2875d098a59a72d3dd942d89901318aed6331cf6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2875d098a59a72d3dd942d89901318aed6331cf6"
    }
  ],
  "stats": {
    "total": 2166,
    "additions": 1083,
    "deletions": 1083
  },
  "files": [
    {
      "sha": "a6d1b56fdb704620e0859dc5306c82e8d0fcdeca",
      "filename": "sim/mips/cp1.c",
      "status": "modified",
      "additions": 126,
      "deletions": 126,
      "changes": 252,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/cp1.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/cp1.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/cp1.c?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -90,8 +90,8 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n /* Extract packed single values:  */\n #define FP_PS_upper(v) (((v) >> 32) & (unsigned)0xFFFFFFFF)\n #define FP_PS_lower(v) ((v) & (unsigned)0xFFFFFFFF)\n-#define FP_PS_cat(u,l) (((unsigned64)((u) & (unsigned)0xFFFFFFFF) << 32) \\\n-                        | (unsigned64)((l) & 0xFFFFFFFF))\n+#define FP_PS_cat(u,l) (((uint64_t)((u) & (unsigned)0xFFFFFFFF) << 32) \\\n+                        | (uint64_t)((l) & 0xFFFFFFFF))\n \n /* Explicit QNaN values.  */\n #define FPQNaN_SINGLE   (0x7FBFFFFF)\n@@ -360,7 +360,7 @@ value_fcr(sim_cpu *cpu,\n \t  address_word cia,\n \t  int fcr)\n {\n-  unsigned32 value = 0;\n+  uint32_t value = 0;\n \n   switch (fcr)\n     {\n@@ -393,7 +393,7 @@ store_fcr(sim_cpu *cpu,\n \t  int fcr,\n \t  unsigned_word value)\n {\n-  unsigned32 v;\n+  uint32_t v;\n \n   v = VL4_8(value);\n   switch (fcr)\n@@ -523,8 +523,8 @@ denorm_mode(sim_cpu *cpu)\n /* Comparison operations.  */\n \n static sim_fpu_status\n-fp_test(unsigned64 op1,\n-\tunsigned64 op2,\n+fp_test(uint64_t op1,\n+\tuint64_t op2,\n \tFP_formats fmt,\n \tint abs,\n \tint cond,\n@@ -584,8 +584,8 @@ fp_test(unsigned64 op1,\n void\n fp_cmp(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op1,\n-       unsigned64 op2,\n+       uint64_t op1,\n+       uint64_t op2,\n        FP_formats fmt,\n        int abs,\n        int cond,\n@@ -628,26 +628,26 @@ fp_cmp(sim_cpu *cpu,\n \n /* Basic arithmetic operations.  */\n \n-static unsigned64\n+static uint64_t\n fp_unary(sim_cpu *cpu,\n \t address_word cia,\n \t int (*sim_fpu_op)(sim_fpu *, const sim_fpu *),\n-\t unsigned64 op,\n+\t uint64_t op,\n \t FP_formats fmt)\n {\n   sim_fpu wop;\n   sim_fpu ans;\n   sim_fpu_round round = rounding_mode (GETRM());\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n   sim_fpu_status status = 0;\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n \n   /* The format type has already been checked: */\n   switch (fmt)\n     {\n     case fmt_single:\n       {\n-\tunsigned32 res;\n+\tuint32_t res;\n \tsim_fpu_32to (&wop, op);\n \tstatus |= (*sim_fpu_op) (&ans, &wop);\n \tstatus |= sim_fpu_round_32 (&ans, round, denorm);\n@@ -657,7 +657,7 @@ fp_unary(sim_cpu *cpu,\n       }\n     case fmt_double:\n       {\n-\tunsigned64 res;\n+\tuint64_t res;\n \tsim_fpu_64to (&wop, op);\n \tstatus |= (*sim_fpu_op) (&ans, &wop);\n \tstatus |= sim_fpu_round_64 (&ans, round, denorm);\n@@ -668,7 +668,7 @@ fp_unary(sim_cpu *cpu,\n     case fmt_ps:\n       {\n \tint status_u = 0, status_l = 0;\n-\tunsigned32 res_u, res_l;\n+\tuint32_t res_u, res_l;\n \tsim_fpu_32to (&wop, FP_PS_upper(op));\n \tstatus_u |= (*sim_fpu_op) (&ans, &wop);\n \tsim_fpu_to32 (&res_u, &ans);\n@@ -688,12 +688,12 @@ fp_unary(sim_cpu *cpu,\n   return result;\n }\n \n-static unsigned64\n+static uint64_t\n fp_binary(sim_cpu *cpu,\n \t  address_word cia,\n \t  int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n-\t  unsigned64 op1,\n-\t  unsigned64 op2,\n+\t  uint64_t op1,\n+\t  uint64_t op2,\n \t  FP_formats fmt)\n {\n   sim_fpu wop1;\n@@ -702,14 +702,14 @@ fp_binary(sim_cpu *cpu,\n   sim_fpu_round round = rounding_mode (GETRM());\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n   sim_fpu_status status = 0;\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n \n   /* The format type has already been checked: */\n   switch (fmt)\n     {\n     case fmt_single:\n       {\n-\tunsigned32 res;\n+\tuint32_t res;\n \tsim_fpu_32to (&wop1, op1);\n \tsim_fpu_32to (&wop2, op2);\n \tstatus |= (*sim_fpu_op) (&ans, &wop1, &wop2);\n@@ -720,7 +720,7 @@ fp_binary(sim_cpu *cpu,\n       }\n     case fmt_double:\n       {\n-\tunsigned64 res;\n+\tuint64_t res;\n \tsim_fpu_64to (&wop1, op1);\n \tsim_fpu_64to (&wop2, op2);\n \tstatus |= (*sim_fpu_op) (&ans, &wop1, &wop2);\n@@ -732,7 +732,7 @@ fp_binary(sim_cpu *cpu,\n     case fmt_ps:\n       {\n \tint status_u = 0, status_l = 0;\n-\tunsigned32 res_u, res_l;\n+\tuint32_t res_u, res_l;\n \tsim_fpu_32to (&wop1, FP_PS_upper(op1));\n \tsim_fpu_32to (&wop2, FP_PS_upper(op2));\n \tstatus_u |= (*sim_fpu_op) (&ans, &wop1, &wop2);\n@@ -757,28 +757,28 @@ fp_binary(sim_cpu *cpu,\n /* Common MAC code for single operands (.s or .d), defers setting FCSR.  */\n static sim_fpu_status\n inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n-\t  unsigned64 op1,\n-\t  unsigned64 op2,\n-\t  unsigned64 op3,\n+\t  uint64_t op1,\n+\t  uint64_t op2,\n+\t  uint64_t op3,\n \t  int scale,\n \t  int negate,\n \t  FP_formats fmt,\n \t  sim_fpu_round round,\n \t  sim_fpu_denorm denorm,\n-\t  unsigned64 *result)\n+\t  uint64_t *result)\n {\n   sim_fpu wop1;\n   sim_fpu wop2;\n   sim_fpu ans;\n   sim_fpu_status status = 0;\n   sim_fpu_status op_status;\n-  unsigned64 temp = 0;\n+  uint64_t temp = 0;\n \n   switch (fmt)\n     {\n     case fmt_single:\n       {\n-\tunsigned32 res;\n+\tuint32_t res;\n \tsim_fpu_32to (&wop1, op1);\n \tsim_fpu_32to (&wop2, op2);\n \tstatus |= sim_fpu_mul (&ans, &wop1, &wop2);\n@@ -804,7 +804,7 @@ inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n       }\n     case fmt_double:\n       {\n-\tunsigned64 res;\n+\tuint64_t res;\n \tsim_fpu_64to (&wop1, op1);\n \tsim_fpu_64to (&wop2, op2);\n \tstatus |= sim_fpu_mul (&ans, &wop1, &wop2);\n@@ -842,21 +842,21 @@ inner_mac(int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n    argument is an adjustment to the exponent of the intermediate\n    product op1*op2.  It is currently non-zero for rsqrt2 (-1), which\n    requires an effective division by 2. */\n-static unsigned64\n+static uint64_t\n fp_mac(sim_cpu *cpu,\n        address_word cia,\n        int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n-       unsigned64 op1,\n-       unsigned64 op2,\n-       unsigned64 op3,\n+       uint64_t op1,\n+       uint64_t op2,\n+       uint64_t op3,\n        int scale,\n        int negate,\n        FP_formats fmt)\n {\n   sim_fpu_round round = rounding_mode (GETRM());\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n   sim_fpu_status status = 0;\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n \n   /* The format type has already been checked: */\n   switch (fmt)\n@@ -869,7 +869,7 @@ fp_mac(sim_cpu *cpu,\n     case fmt_ps:\n       {\n \tint status_u, status_l;\n-\tunsigned64 result_u, result_l;\n+\tuint64_t result_u, result_l;\n \tstatus_u = inner_mac(sim_fpu_op, FP_PS_upper(op1), FP_PS_upper(op2),\n \t\t\t     FP_PS_upper(op3), scale, negate, fmt_single,\n \t\t\t     round, denorm, &result_u);\n@@ -891,23 +891,23 @@ fp_mac(sim_cpu *cpu,\n \n /* Common rsqrt code for single operands (.s or .d), intermediate rounding.  */\n static sim_fpu_status\n-inner_rsqrt(unsigned64 op1,\n+inner_rsqrt(uint64_t op1,\n \t    FP_formats fmt,\n \t    sim_fpu_round round,\n \t    sim_fpu_denorm denorm,\n-\t    unsigned64 *result)\n+\t    uint64_t *result)\n {\n   sim_fpu wop1;\n   sim_fpu ans;\n   sim_fpu_status status = 0;\n   sim_fpu_status op_status;\n-  unsigned64 temp = 0;\n+  uint64_t temp = 0;\n \n   switch (fmt)\n     {\n     case fmt_single:\n       {\n-\tunsigned32 res;\n+\tuint32_t res;\n \tsim_fpu_32to (&wop1, op1);\n \tstatus |= sim_fpu_sqrt (&ans, &wop1);\n \tstatus |= sim_fpu_round_32 (&ans, status, round);\n@@ -921,7 +921,7 @@ inner_rsqrt(unsigned64 op1,\n       }\n     case fmt_double:\n       {\n-\tunsigned64 res;\n+\tuint64_t res;\n \tsim_fpu_64to (&wop1, op1);\n \tstatus |= sim_fpu_sqrt (&ans, &wop1);\n \tstatus |= sim_fpu_round_64 (&ans, round, denorm);\n@@ -941,16 +941,16 @@ inner_rsqrt(unsigned64 op1,\n   return status;\n }\n \n-static unsigned64\n+static uint64_t\n fp_inv_sqrt(sim_cpu *cpu,\n \t    address_word cia,\n-\t    unsigned64 op1,\n+\t    uint64_t op1,\n \t    FP_formats fmt)\n {\n   sim_fpu_round round = rounding_mode (GETRM());\n   sim_fpu_round denorm = denorm_mode (cpu);\n   sim_fpu_status status = 0;\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n \n   /* The format type has already been checked: */\n   switch (fmt)\n@@ -962,7 +962,7 @@ fp_inv_sqrt(sim_cpu *cpu,\n     case fmt_ps:\n       {\n \tint status_u, status_l;\n-\tunsigned64 result_u, result_l;\n+\tuint64_t result_u, result_l;\n \tstatus_u = inner_rsqrt (FP_PS_upper(op1), fmt_single, round, denorm,\n \t\t\t\t&result_u);\n \tstatus_l = inner_rsqrt (FP_PS_lower(op1), fmt_single, round, denorm,\n@@ -981,130 +981,130 @@ fp_inv_sqrt(sim_cpu *cpu,\n }\n \n \n-unsigned64\n+uint64_t\n fp_abs(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op,\n+       uint64_t op,\n        FP_formats fmt)\n {\n   return fp_unary(cpu, cia, &sim_fpu_abs, op, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_neg(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op,\n+       uint64_t op,\n        FP_formats fmt)\n {\n   return fp_unary(cpu, cia, &sim_fpu_neg, op, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_add(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op1,\n-       unsigned64 op2,\n+       uint64_t op1,\n+       uint64_t op2,\n        FP_formats fmt)\n {\n   return fp_binary(cpu, cia, &sim_fpu_add, op1, op2, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_sub(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op1,\n-       unsigned64 op2,\n+       uint64_t op1,\n+       uint64_t op2,\n        FP_formats fmt)\n {\n   return fp_binary(cpu, cia, &sim_fpu_sub, op1, op2, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_mul(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op1,\n-       unsigned64 op2,\n+       uint64_t op1,\n+       uint64_t op2,\n        FP_formats fmt)\n {\n   return fp_binary(cpu, cia, &sim_fpu_mul, op1, op2, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_div(sim_cpu *cpu,\n        address_word cia,\n-       unsigned64 op1,\n-       unsigned64 op2,\n+       uint64_t op1,\n+       uint64_t op2,\n        FP_formats fmt)\n {\n   return fp_binary(cpu, cia, &sim_fpu_div, op1, op2, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_recip(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op,\n+         uint64_t op,\n          FP_formats fmt)\n {\n   return fp_unary(cpu, cia, &sim_fpu_inv, op, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_sqrt(sim_cpu *cpu,\n         address_word cia,\n-        unsigned64 op,\n+        uint64_t op,\n         FP_formats fmt)\n {\n   return fp_unary(cpu, cia, &sim_fpu_sqrt, op, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_rsqrt(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op,\n+         uint64_t op,\n          FP_formats fmt)\n {\n   return fp_inv_sqrt(cpu, cia, op, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_madd(sim_cpu *cpu,\n         address_word cia,\n-        unsigned64 op1,\n-        unsigned64 op2,\n-        unsigned64 op3,\n+        uint64_t op1,\n+        uint64_t op2,\n+        uint64_t op3,\n         FP_formats fmt)\n {\n   return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 0, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_msub(sim_cpu *cpu,\n         address_word cia,\n-        unsigned64 op1,\n-        unsigned64 op2,\n-        unsigned64 op3,\n+        uint64_t op1,\n+        uint64_t op2,\n+        uint64_t op3,\n         FP_formats fmt)\n {\n   return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 0, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_nmadd(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op1,\n-         unsigned64 op2,\n-         unsigned64 op3,\n+         uint64_t op1,\n+         uint64_t op2,\n+         uint64_t op3,\n          FP_formats fmt)\n {\n   return fp_mac(cpu, cia, &sim_fpu_add, op1, op2, op3, 0, 1, fmt);\n }\n \n-unsigned64\n+uint64_t\n fp_nmsub(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op1,\n-         unsigned64 op2,\n-         unsigned64 op3,\n+         uint64_t op1,\n+         uint64_t op2,\n+         uint64_t op3,\n          FP_formats fmt)\n {\n   return fp_mac(cpu, cia, &sim_fpu_sub, op1, op2, op3, 0, 1, fmt);\n@@ -1114,21 +1114,21 @@ fp_nmsub(sim_cpu *cpu,\n /* MIPS-3D ASE operations.  */\n \n /* Variant of fp_binary for *r.ps MIPS-3D operations. */\n-static unsigned64\n+static uint64_t\n fp_binary_r(sim_cpu *cpu,\n \t    address_word cia,\n \t    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n-\t    unsigned64 op1,\n-\t    unsigned64 op2)\n+\t    uint64_t op1,\n+\t    uint64_t op2)\n {\n   sim_fpu wop1;\n   sim_fpu wop2;\n   sim_fpu ans;\n   sim_fpu_round round = rounding_mode (GETRM ());\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n   sim_fpu_status status_u, status_l;\n-  unsigned64 result;\n-  unsigned32 res_u, res_l;\n+  uint64_t result;\n+  uint32_t res_u, res_l;\n \n   /* The format must be fmt_ps.  */\n   status_u = 0;\n@@ -1149,21 +1149,21 @@ fp_binary_r(sim_cpu *cpu,\n   return result;\n }\n \n-unsigned64\n+uint64_t\n fp_add_r(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op1,\n-         unsigned64 op2,\n+         uint64_t op1,\n+         uint64_t op2,\n          FP_formats fmt)\n {\n   return fp_binary_r (cpu, cia, &sim_fpu_add, op1, op2);\n }\n \n-unsigned64\n+uint64_t\n fp_mul_r(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op1,\n-         unsigned64 op2,\n+         uint64_t op1,\n+         uint64_t op2,\n          FP_formats fmt)\n {\n   return fp_binary_r (cpu, cia, &sim_fpu_mul, op1, op2);\n@@ -1221,10 +1221,10 @@ fpu_inv1_64(sim_fpu *f, const sim_fpu *l)\n   return fpu_inv1 (f, l);\n }\n \n-unsigned64\n+uint64_t\n fp_recip1(sim_cpu *cpu,\n           address_word cia,\n-          unsigned64 op,\n+          uint64_t op,\n           FP_formats fmt)\n {\n   switch (fmt)\n@@ -1238,17 +1238,17 @@ fp_recip1(sim_cpu *cpu,\n   return 0;\n }\n \n-unsigned64\n+uint64_t\n fp_recip2(sim_cpu *cpu,\n           address_word cia,\n-          unsigned64 op1,\n-          unsigned64 op2,\n+          uint64_t op1,\n+          uint64_t op2,\n           FP_formats fmt)\n {\n-  static const unsigned64 one_single = UNSIGNED64 (0x3F800000);\n-  static const unsigned64 one_double = UNSIGNED64 (0x3FF0000000000000);\n-  static const unsigned64 one_ps = (UNSIGNED64 (0x3F800000) << 32 | UNSIGNED64 (0x3F800000));\n-  unsigned64 one;\n+  static const uint64_t one_single = UNSIGNED64 (0x3F800000);\n+  static const uint64_t one_double = UNSIGNED64 (0x3FF0000000000000);\n+  static const uint64_t one_ps = (UNSIGNED64 (0x3F800000) << 32 | UNSIGNED64 (0x3F800000));\n+  uint64_t one;\n \n   /* Implemented as nmsub fd, 1, fs, ft.  */\n   switch (fmt)\n@@ -1319,10 +1319,10 @@ fpu_inv_sqrt1_64(sim_fpu *f, const sim_fpu *l)\n   return fpu_inv_sqrt1 (f, l);\n }\n \n-unsigned64\n+uint64_t\n fp_rsqrt1(sim_cpu *cpu,\n           address_word cia,\n-          unsigned64 op,\n+          uint64_t op,\n           FP_formats fmt)\n {\n   switch (fmt)\n@@ -1336,17 +1336,17 @@ fp_rsqrt1(sim_cpu *cpu,\n   return 0;\n }\n \n-unsigned64\n+uint64_t\n fp_rsqrt2(sim_cpu *cpu,\n           address_word cia,\n-          unsigned64 op1,\n-          unsigned64 op2,\n+          uint64_t op1,\n+          uint64_t op2,\n           FP_formats fmt)\n {\n-  static const unsigned64 half_single = UNSIGNED64 (0x3F000000);\n-  static const unsigned64 half_double = UNSIGNED64 (0x3FE0000000000000);\n-  static const unsigned64 half_ps = (UNSIGNED64 (0x3F000000) << 32 | UNSIGNED64 (0x3F000000));\n-  unsigned64 half;\n+  static const uint64_t half_single = UNSIGNED64 (0x3F000000);\n+  static const uint64_t half_double = UNSIGNED64 (0x3FE0000000000000);\n+  static const uint64_t half_ps = (UNSIGNED64 (0x3F000000) << 32 | UNSIGNED64 (0x3F000000));\n+  uint64_t half;\n \n   /* Implemented as (nmsub fd, 0.5, fs, ft)/2, where the divide is\n      done by scaling the exponent during multiply.  */\n@@ -1374,8 +1374,8 @@ convert (sim_cpu *cpu,\n   sim_fpu wop;\n   sim_fpu_round round = rounding_mode (rm);\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n-  unsigned32 result32;\n-  unsigned64 result64;\n+  uint32_t result32;\n+  uint64_t result64;\n   sim_fpu_status status = 0;\n \n   /* Convert the input to sim_fpu internal format */\n@@ -1438,30 +1438,30 @@ convert (sim_cpu *cpu,\n   return result64;\n }\n \n-unsigned64\n+uint64_t\n ps_lower(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op)\n+         uint64_t op)\n {\n   return FP_PS_lower (op);\n }\n \n-unsigned64\n+uint64_t\n ps_upper(sim_cpu *cpu,\n          address_word cia,\n-         unsigned64 op)\n+         uint64_t op)\n {\n   return FP_PS_upper(op);\n }\n \n-unsigned64\n+uint64_t\n pack_ps(sim_cpu *cpu,\n         address_word cia,\n-        unsigned64 op1,\n-        unsigned64 op2,\n+        uint64_t op1,\n+        uint64_t op2,\n         FP_formats fmt)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n \n   /* The registers must specify FPRs valid for operands of type\n      \"fmt\". If they are not valid, the result is undefined. */\n@@ -1472,7 +1472,7 @@ pack_ps(sim_cpu *cpu,\n     case fmt_single:\n       {\n \tsim_fpu wop;\n-\tunsigned32 res_u, res_l;\n+\tuint32_t res_u, res_l;\n \tsim_fpu_32to (&wop, op1);\n \tsim_fpu_to32 (&res_u, &wop);\n \tsim_fpu_32to (&wop, op2);\n@@ -1488,19 +1488,19 @@ pack_ps(sim_cpu *cpu,\n   return result;\n }\n \n-unsigned64\n+uint64_t\n convert_ps (sim_cpu *cpu,\n             address_word cia,\n             int rm,\n-            unsigned64 op,\n+            uint64_t op,\n             FP_formats from,\n             FP_formats to)\n {\n   sim_fpu wop_u, wop_l;\n   sim_fpu_round round = rounding_mode (rm);\n   sim_fpu_denorm denorm = denorm_mode (cpu);\n-  unsigned32 res_u, res_l;\n-  unsigned64 result;\n+  uint32_t res_u, res_l;\n+  uint64_t result;\n   sim_fpu_status status_u = 0, status_l = 0;\n \n   /* As convert, but used only for paired values (formats PS, PW) */\n@@ -1527,7 +1527,7 @@ convert_ps (sim_cpu *cpu,\n     case fmt_word:   /* fmt_pw */\n       status_u |= sim_fpu_to32u (&res_u, &wop_u, round);\n       status_l |= sim_fpu_to32u (&res_l, &wop_l, round);\n-      result = (((unsigned64)res_u) << 32) | (unsigned64)res_l;\n+      result = (((uint64_t)res_u) << 32) | (uint64_t)res_l;\n       break;\n     case fmt_ps:\n       status_u |= sim_fpu_round_32 (&wop_u, 0, round);"
    },
    {
      "sha": "ec11011042ac8be8650d8781eacd4a28bc0cdc4d",
      "filename": "sim/mips/dsp.igen",
      "status": "modified",
      "additions": 324,
      "deletions": 324,
      "changes": 648,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/dsp.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/dsp.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dsp.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -25,54 +25,54 @@\n :function:::void:do_ph_op:int rd, int rs, int rt, int op, int sat\n {\n   int i;\n-  signed32 h0 = 0;\n-  signed16 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n+  int32_t h0 = 0;\n+  int16_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n       if (op == 0) // ADD\n-\th0 = (signed32)h1 + (signed32)h2;\n+\th0 = (int32_t)h1 + (int32_t)h2;\n       else if (op == 1) // SUB\n-        h0 = (signed32)h1 - (signed32)h2;\n+        h0 = (int32_t)h1 - (int32_t)h2;\n       else // MUL\n-        h0 = (signed32)h1 * (signed32)h2;\n-      if (h0 > (signed32)0x7fff || h0 < (signed32)0xffff8000)\n+        h0 = (int32_t)h1 * (int32_t)h2;\n+      if (h0 > (int32_t)0x7fff || h0 < (int32_t)0xffff8000)\n \t{\n \t  if (op == 0 || op == 1) // ADD, SUB\n \t    DSPCR |= DSPCR_OUFLAG4;\n \t  else if (op == 2) // MUL\n \t    DSPCR |= DSPCR_OUFLAG5;\n \t  if (sat == 1)\n \t    {\n-\t      if (h0 > (signed32)0x7fff)\n+\t      if (h0 > (int32_t)0x7fff)\n \t\th0 = 0x7fff;\n \t      else\n \t\th0 = 0x8000;\n \t    }\n \t}\n-      result |= ((unsigned32)((unsigned16)h0) << i);\n+      result |= ((uint32_t)((uint16_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n // op: 0 = ADD, 1 = SUB\n :function:::void:do_w_op:int rd, int rs, int rt, int op\n {\n-  signed64 h0;\n-  signed32 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n-  h1 = (signed32)v1;\n-  h2 = (signed32)v2;\n+  int64_t h0;\n+  int32_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n+  h1 = (int32_t)v1;\n+  h2 = (int32_t)v2;\n   if (op == 0) // ADD\n-    h0 = (signed64)h1 + (signed64)h2;\n+    h0 = (int64_t)h1 + (int64_t)h2;\n   else // SUB\n-    h0 = (signed64)h1 - (signed64)h2;\n+    h0 = (int64_t)h1 - (int64_t)h2;\n   if (((h0 & 0x100000000LL) >> 1) != (h0 & 0x80000000))\n     {\n       DSPCR |= DSPCR_OUFLAG4;\n@@ -89,19 +89,19 @@\n :function:::void:do_qb_op:int rd, int rs, int rt, int op, int sat\n {\n   int i;\n-  unsigned32 h0;\n-  unsigned8 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint32_t h0;\n+  uint8_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       if (op == 0) // ADD\n-\th0 = (unsigned32)h1 + (unsigned32)h2;\n+\th0 = (uint32_t)h1 + (uint32_t)h2;\n       else // SUB\n-\th0 = (unsigned32)h1 - (unsigned32)h2;\n+\th0 = (uint32_t)h1 - (uint32_t)h2;\n       if (h0 & 0x100)\n \t{\n \t  DSPCR |= DSPCR_OUFLAG4;\n@@ -113,7 +113,7 @@\n \t\th0 = 0;\n \t    }\n \t}\n-      result |= ((unsigned32)((unsigned8)h0) << i);\n+      result |= ((uint32_t)((uint8_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -122,12 +122,12 @@\n :function:::void:do_qb_shift:int rd, int rt, int shift, int op\n {\n   int i, j;\n-  unsigned8 h0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint8_t h0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8)\n     {\n-      h0 = (unsigned8)(v1 & 0xff);\n+      h0 = (uint8_t)(v1 & 0xff);\n       if (op == 0) // left\n \t{\n \t  for (j = 7; j >= 8 - shift; j--)\n@@ -142,7 +142,7 @@\n \t}\n       else // right\n         h0 = h0 >> shift;\n-      result |= ((unsigned32)h0 << i);\n+      result |= ((uint32_t)h0 << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -152,13 +152,13 @@\n :function:::void:do_ph_shift:int rd, int rt, int shift, int op, int sat\n {\n   int i, j;\n-  signed16 h0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  int16_t h0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   int setcond;\n   for (i = 0; i < 32; i += 16, v1 >>= 16)\n     {\n-      h0 = (signed16)(v1 & 0xffff);\n+      h0 = (int16_t)(v1 & 0xffff);\n       if (op == 0) // left\n \t{\n \t  setcond = 0;\n@@ -203,16 +203,16 @@\n \t    h0 = h0 >> shift;\n \t}\n \n-      result |= ((unsigned32)((unsigned16)h0) << i);\n+      result |= ((uint32_t)((uint16_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_w_shll:int rd, int rt, int shift\n {\n   int i;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   int setcond = 0;\n   if (v1 & (1 << 31))\n     {\n@@ -250,29 +250,29 @@\n :function:::void:do_ph_s_absq:int rd, int rt\n {\n   int i;\n-  signed16 h0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  int16_t h0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 16, v1 >>= 16)\n     {\n-      h0 = (signed16)(v1 & 0xffff);\n-      if (h0 == (signed16)0x8000)\n+      h0 = (int16_t)(v1 & 0xffff);\n+      if (h0 == (int16_t)0x8000)\n \t{\n \t  DSPCR |= DSPCR_OUFLAG4;\n \t  h0 = 0x7fff;\n \t}\n       else if (h0 & 0x8000)\n \th0 = -h0;\n-      result |= ((unsigned32)((unsigned16)h0) << i);\n+      result |= ((uint32_t)((uint16_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_w_s_absq:int rd, int rt\n {\n-  unsigned32 v1 = GPR[rt];\n-  signed32 h0 = (signed32)v1;\n-  if (h0 == (signed32)0x80000000)\n+  uint32_t v1 = GPR[rt];\n+  int32_t h0 = (int32_t)v1;\n+  if (h0 == (int32_t)0x80000000)\n     {\n       DSPCR |= DSPCR_OUFLAG4;\n       h0 = 0x7fffffff;\n@@ -285,44 +285,44 @@\n :function:::void:do_qb_s_absq:int rd, int rt\n {\n   int i;\n-  signed8 q0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  int8_t q0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8)\n     {\n-      q0 = (signed8)(v1 & 0xff);\n-      if (q0 == (signed8)0x80)\n+      q0 = (int8_t)(v1 & 0xff);\n+      if (q0 == (int8_t)0x80)\n \t{\n \t  DSPCR |= DSPCR_OUFLAG4;\n \t  q0 = 0x7f;\n \t}\n       else if (q0 & 0x80)\n \tq0 = -q0;\n-      result |= ((unsigned32)((unsigned8)q0) << i);\n+      result |= ((uint32_t)((uint8_t)q0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_addsc:int rd, int rs, int rt\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned64 h0;\n-  h0 = (unsigned64)v1 + (unsigned64)v2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint64_t h0;\n+  h0 = (uint64_t)v1 + (uint64_t)v2;\n   if (h0 & 0x100000000LL)\n     DSPCR |= DSPCR_CARRY;\n   GPR[rd] = EXTEND32 (h0);\n }\n \n :function:::void:do_addwc:int rd, int rs, int rt\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned64 h0;\n-  signed32 h1 = (signed32) v1;\n-  signed32 h2 = (signed32) v2;\n-  h0 = (signed64)h1 + (signed64)h2\n-    + (signed64)((DSPCR >> DSPCR_CARRY_SHIFT) & DSPCR_CARRY_MASK);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint64_t h0;\n+  int32_t h1 = (int32_t) v1;\n+  int32_t h2 = (int32_t) v2;\n+  h0 = (int64_t)h1 + (int64_t)h2\n+    + (int64_t)((DSPCR >> DSPCR_CARRY_SHIFT) & DSPCR_CARRY_MASK);\n   if (((h0 & 0x100000000LL) >> 1) != (h0 & 0x80000000))\n     DSPCR |= DSPCR_OUFLAG4;\n   GPR[rd] = EXTEND32 (h0);\n@@ -331,8 +331,8 @@\n :function:::void:do_bitrev:int rd, int rt\n {\n   int i;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 h1 = 0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t h1 = 0;\n   for (i = 0; i < 16; i++)\n     {\n       if (v1 & (1 << i))\n@@ -344,30 +344,30 @@\n // op: 0 = EXTPV, 1 = EXTPDPV\n :function:::void:do_extpv:int rt, int ac, int rs, int op\n {\n-  unsigned32 size = GPR[rs] & 0x1f;\n+  uint32_t size = GPR[rs] & 0x1f;\n   do_extp (SD_, rt, ac, size, op);\n }\n \n // op: 0 = EXTRV, 1 = EXTRV_R, 2 = EXTRV_RS\n :function:::void:do_extrv:int rt, int ac, int rs, int op\n {\n-  unsigned32 shift = GPR[rs] & 0x1f;\n+  uint32_t shift = GPR[rs] & 0x1f;\n   do_w_extr (SD_, rt, ac, shift, op);\n }\n \n :function:::void:do_extrv_s_h:int rt, int ac, int rs\n {\n-  unsigned32 shift = GPR[rs] & 0x1f;\n+  uint32_t shift = GPR[rs] & 0x1f;\n   do_h_extr (SD_, rt, ac, shift);\n }\n \n :function:::void:do_insv:int rt, int rs\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n-  unsigned32 size = (DSPCR >> DSPCR_SCOUNT_SHIFT) & DSPCR_SCOUNT_MASK;\n-  unsigned32 mask1, mask2, mask3, result;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n+  uint32_t size = (DSPCR >> DSPCR_SCOUNT_SHIFT) & DSPCR_SCOUNT_MASK;\n+  uint32_t mask1, mask2, mask3, result;\n   if (size < 32)\n     mask1 = (1 << size) - 1;\n   else\n@@ -394,11 +394,11 @@\n \n :function:::void:do_modsub:int rd, int rs, int rt\n {\n-  unsigned32 result = 0;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 decr = v2 & 0xff;\n-  unsigned32 lastindex = (v2 & 0xffff00) >> 8;\n+  uint32_t result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t decr = v2 & 0xff;\n+  uint32_t lastindex = (v2 & 0xffff00) >> 8;\n   if (v1 == 0)\n     result = lastindex;\n   else\n@@ -408,7 +408,7 @@\n \n :function:::void:do_mthlip:int rs, int ac\n {\n-  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n+  uint32_t pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n   DSPHI(ac) = DSPLO(ac);\n   DSPLO(ac) = GPR[rs];\n   if (pos >= 32)\n@@ -422,29 +422,29 @@\n :function:::void:do_mulsaq_s_w_ph:int ac, int rs, int rt\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n-      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n+      if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n \t{\n \t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n-\t  result = (signed32) 0x7fffffff;\n+\t  result = (int32_t) 0x7fffffff;\n \t}\n       else\n-\tresult = ((signed32)h1 * (signed32)h2) << 1;\n+\tresult = ((int32_t)h1 * (int32_t)h2) << 1;\n \n       if (i == 0)\n-\tprod -= (signed64) result;\n+\tprod -= (int64_t) result;\n       else\n-\tprod += (signed64) result;\n+\tprod += (int64_t) result;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n@@ -453,53 +453,53 @@\n :function:::void:do_ph_packrl:int rd, int rs, int rt\n {\n \n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n   GPR[rd] = EXTEND32 ((v1 << 16) + (v2 >> 16));\n }\n \n :function:::void:do_qb_pick:int rd, int rs, int rt\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned8 h1, h2;\n-  unsigned32 result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint8_t h1, h2;\n+  uint32_t result = 0;\n   for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       if (DSPCR & (1 << (DSPCR_CCOND_SHIFT + j)))\n-\tresult |= (unsigned32)(h1 << i);\n+\tresult |= (uint32_t)(h1 << i);\n       else\n-\tresult |= (unsigned32)(h2 << i);\n+\tresult |= (uint32_t)(h2 << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_ph_pick:int rd, int rs, int rt\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned16 h1, h2;\n-  unsigned32 result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint16_t h1, h2;\n+  uint32_t result = 0;\n   for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (unsigned16)(v1 & 0xffff);\n-      h2 = (unsigned16)(v2 & 0xffff);\n+      h1 = (uint16_t)(v1 & 0xffff);\n+      h2 = (uint16_t)(v2 & 0xffff);\n       if (DSPCR & (1 << (DSPCR_CCOND_SHIFT + j)))\n-\tresult |= (unsigned32)(h1 << i);\n+\tresult |= (uint32_t)(h1 << i);\n       else\n-\tresult |= (unsigned32)(h2 << i);\n+\tresult |= (uint32_t)(h2 << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n // op: 0 = QBR, 1 = QBRA, 2 = QBL, 3 = QBLA\n :function:::void:do_qb_ph_precequ:int rd, int rt, int op\n {\n-  unsigned32 v1 = GPR[rt];\n+  uint32_t v1 = GPR[rt];\n   if (op == 0)\n     GPR[rd] = EXTEND32 ((v1 & 0xff00) << 15) | ((v1 & 0xff) << 7);\n   else if (op == 1)\n@@ -513,7 +513,7 @@\n // op: 0 = QBR, 1 = QBRA, 2 = QBL, 3 = QBLA\n :function:::void:do_qb_ph_preceu:int rd, int rt, int op\n {\n-  unsigned32 v1 = GPR[rt];\n+  uint32_t v1 = GPR[rt];\n   if (op == 0)\n     GPR[rd] = EXTEND32 ((v1 & 0xff00) << 8) | (v1 & 0xff);\n   else if (op == 1)\n@@ -527,7 +527,7 @@\n // op: 0 = .PHL, 1 = PHR\n :function:::void:do_w_preceq:int rd, int rt, int op\n {\n-  unsigned32 v1 = GPR[rt];\n+  uint32_t v1 = GPR[rt];\n   if (op == 0)\n     GPR[rd] = EXTEND32 (v1 & 0xffff0000);\n   else if (op == 1)\n@@ -536,19 +536,19 @@\n \n :function:::void:do_w_ph_precrq:int rd, int rs, int rt\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 tempu = (v1 & 0xffff0000) >> 16;\n-  unsigned32 tempv = (v2 & 0xffff0000) >> 16;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t tempu = (v1 & 0xffff0000) >> 16;\n+  uint32_t tempv = (v2 & 0xffff0000) >> 16;\n   GPR[rd] = EXTEND32 ((tempu << 16) | tempv);\n }\n \n // sat: 0 = PRECRQ.QB.PH, 1 = PRECRQU_S.QB.PH\n :function:::void:do_ph_qb_precrq:int rd, int rs, int rt, int sat\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 tempu = 0, tempv = 0, tempw = 0, tempx = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t tempu = 0, tempv = 0, tempw = 0, tempx = 0;\n   if (sat == 0)\n     {\n       tempu = (v1 & 0xff000000) >> 24;\n@@ -563,7 +563,7 @@\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempu = 0;\n \t}\n-      else if (!(v1 & 0x80000000) && ((v1 >> 16) > (unsigned32)0x7f80))\n+      else if (!(v1 & 0x80000000) && ((v1 >> 16) > (uint32_t)0x7f80))\n \t{\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempu = 0xff;\n@@ -575,7 +575,7 @@\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempv = 0;\n \t}\n-      else if (!(v1 & 0x8000) && ((v1 & 0xffff) > (unsigned32)0x7f80))\n+      else if (!(v1 & 0x8000) && ((v1 & 0xffff) > (uint32_t)0x7f80))\n \t{\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempv = 0xff;\n@@ -587,7 +587,7 @@\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempw = 0;\n \t}\n-      else if (!(v2 & 0x80000000) && ((v2 >> 16) > (unsigned32)0x7f80))\n+      else if (!(v2 & 0x80000000) && ((v2 >> 16) > (uint32_t)0x7f80))\n \t{\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempw = 0xff;\n@@ -599,7 +599,7 @@\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempx = 0;\n \t}\n-      else if (!(v2 & 0x8000) && ((v2 & 0xffff) > (unsigned32)0x7f80))\n+      else if (!(v2 & 0x8000) && ((v2 & 0xffff) > (uint32_t)0x7f80))\n \t{\n \t  DSPCR |= DSPCR_OUFLAG6;\n \t  tempx = 0xff;\n@@ -612,48 +612,48 @@\n \n :function:::void:do_w_ph_rs_precrq:int rd, int rs, int rt\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed32 h1 = (signed32)v1;\n-  signed32 h2 = (signed32)v2;\n-  signed64 temp1 = (signed64)h1 + (signed64)0x8000;\n-  signed32 temp2;\n-  signed64 temp3 = (signed64)h2 + (signed64)0x8000;\n-  signed32 temp4;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int32_t h1 = (int32_t)v1;\n+  int32_t h2 = (int32_t)v2;\n+  int64_t temp1 = (int64_t)h1 + (int64_t)0x8000;\n+  int32_t temp2;\n+  int64_t temp3 = (int64_t)h2 + (int64_t)0x8000;\n+  int32_t temp4;\n   if (((temp1 & 0x100000000LL) >> 1) != (temp1 & 0x80000000))\n     {\n       DSPCR |= DSPCR_OUFLAG6;\n       temp2 = 0x7fff;\n     }\n   else\n-    temp2 = (signed32)((temp1 & 0xffff0000) >> 16);\n+    temp2 = (int32_t)((temp1 & 0xffff0000) >> 16);\n   if (((temp3 & 0x100000000LL) >> 1) != (temp3 & 0x80000000))\n     {\n       DSPCR |= DSPCR_OUFLAG6;\n       temp4 = 0x7fff;\n     }\n   else\n-    temp4 = (signed32)((temp3 & 0xffff0000) >> 16);\n+    temp4 = (int32_t)((temp3 & 0xffff0000) >> 16);\n   GPR[rd] = EXTEND32 ((temp2 << 16) | temp4);\n }\n \n :function:::void:do_qb_w_raddu:int rd, int rs\n {\n   int i;\n-  unsigned8 h0;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 result = 0;\n+  uint8_t h0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8)\n     {\n-      h0 = (unsigned8)(v1 & 0xff);\n-      result += (unsigned32)h0;\n+      h0 = (uint8_t)(v1 & 0xff);\n+      result += (uint32_t)h0;\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_rddsp:int rd, int mask\n {\n-  unsigned32 result = 0;\n+  uint32_t result = 0;\n   if (mask & 0x1)\n     {\n       result &= (~DSPCR_POS_SMASK);\n@@ -694,66 +694,66 @@\n     GPR[rd] = EXTEND32 ((p2 << 24) | (p2 << 16) | (p2 << 8) | p2);\n   else if (op == 1)\n     {\n-      unsigned32 v1 = GPR[p2] & 0xff;\n+      uint32_t v1 = GPR[p2] & 0xff;\n       GPR[rd] = EXTEND32 ((v1 << 24) | (v1 << 16) | (v1 << 8) | v1);\n     }\n   else if (op == 2)\n     {\n-      signed32 v1 = p2;\n+      int32_t v1 = p2;\n       if (v1 & 0x200)\n \tv1 |= 0xfffffc00;\n       GPR[rd] = EXTEND32 ((v1 << 16) | (v1 & 0xffff));\n     }\n   else if (op == 3)\n     {\n-      unsigned32 v1 = GPR[p2];\n+      uint32_t v1 = GPR[p2];\n       v1 = v1 & 0xffff;\n       GPR[rd] = EXTEND32 ((v1 << 16) | v1);\n     }\n }\n \n :function:::void:do_shilov:int ac, int rs\n {\n-  signed32 shift = GPR[rs] & 0x3f;\n+  int32_t shift = GPR[rs] & 0x3f;\n   do_shilo (SD_, ac, shift);\n }\n \n // op: 0 = SHLLV, 1 = SHRAV\n // sat: 0 =  normal, 1 = saturate/rounding\n :function:::void:do_ph_shl:int rd, int rt, int rs, int op, int sat\n {\n-  unsigned32 shift = GPR[rs] & 0xf;\n+  uint32_t shift = GPR[rs] & 0xf;\n   do_ph_shift (SD_, rd, rt, shift, op, sat);\n }\n \n // op: 0 = SHLLV, 1 = SHRLV\n :function:::void:do_qb_shl:int rd, int rt, int rs, int op\n {\n-  unsigned32 shift = GPR[rs] & 0x7;\n+  uint32_t shift = GPR[rs] & 0x7;\n   do_qb_shift (SD_, rd, rt, shift, op);\n }\n \n :function:::void:do_w_s_shllv:int rd, int rt, int rs\n {\n-  unsigned32 shift = GPR[rs] & 0x1f;\n+  uint32_t shift = GPR[rs] & 0x1f;\n   do_w_shll (SD_, rd, rt, shift);\n }\n \n :function:::void:do_ph_shrlv:int rd, int rt, int rs\n {\n-  unsigned32 shift = GPR[rs] & 0xf;\n+  uint32_t shift = GPR[rs] & 0xf;\n   do_ph_shrl (SD_, rd, rt, shift);\n }\n \n :function:::void:do_w_r_shrav:int rd, int rt, int rs\n {\n-  unsigned32 shift = GPR[rs] & 0x1f;\n+  uint32_t shift = GPR[rs] & 0x1f;\n   do_w_shra (SD_, rd, rt, shift);\n }\n \n :function:::void:do_wrdsp:int rs, int mask\n {\n-  unsigned32 v1 = GPR[rs];\n+  uint32_t v1 = GPR[rs];\n   if (mask & 0x1)\n     {\n       DSPCR &= (~DSPCR_POS_SMASK);\n@@ -789,25 +789,25 @@\n // round: 0 = no rounding, 1 = rounding\n :function:::void:do_qb_shrav:int rd, int rt, int rs, int round\n {\n-  unsigned32 shift = GPR[rs] & 0x7;\n+  uint32_t shift = GPR[rs] & 0x7;\n   do_qb_shra (SD_, rd, rt, shift, round);\n }\n \n :function:::void:do_append:int rt, int rs, int sa\n {\n-  unsigned32 v0 = GPR[rs];\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result;\n-  unsigned32 mask = (1 << sa) - 1;\n+  uint32_t v0 = GPR[rs];\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result;\n+  uint32_t mask = (1 << sa) - 1;\n   result = (v1 << sa) | (v0 & mask);\n   GPR[rt] = EXTEND32 (result);\n }\n \n :function:::void:do_balign:int rt, int rs, int bp\n {\n-  unsigned32 v0 = GPR[rs];\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result;\n+  uint32_t v0 = GPR[rs];\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result;\n   if (bp == 0)\n     result = v1;\n   else\n@@ -818,44 +818,44 @@\n :function:::void:do_ph_w_mulsa:int ac, int rs, int rt\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n-      result = (signed32)h1 * (signed32)h2;\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n+      result = (int32_t)h1 * (int32_t)h2;\n \n       if (i == 0)\n-\tprod -= (signed64) result;\n+\tprod -= (int64_t) result;\n       else\n-\tprod += (signed64) result;\n+\tprod += (int64_t) result;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n }\n \n :function:::void:do_ph_qb_precr:int rd, int rs, int rt\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 tempu = (v1 & 0xff0000) >> 16;\n-  unsigned32 tempv = (v1 & 0xff);\n-  unsigned32 tempw = (v2 & 0xff0000) >> 16;\n-  unsigned32 tempx = (v2 & 0xff);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t tempu = (v1 & 0xff0000) >> 16;\n+  uint32_t tempv = (v1 & 0xff);\n+  uint32_t tempw = (v2 & 0xff0000) >> 16;\n+  uint32_t tempx = (v2 & 0xff);\n   GPR[rd] = EXTEND32 ((tempu << 24) | (tempv << 16) | (tempw << 8) | tempx);\n }\n \n :function:::void:do_prepend:int rt, int rs, int sa\n {\n-  unsigned32 v0 = GPR[rs];\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result;\n+  uint32_t v0 = GPR[rs];\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result;\n   if (sa == 0)\n     result = v1;\n   else\n@@ -865,8 +865,8 @@\n \n :function:::void:do_w_shra:int rd, int rt, int shift\n {\n-  unsigned32 result = GPR[rt];\n-  signed32 h0 = (signed32)result;\n+  uint32_t result = GPR[rt];\n+  int32_t h0 = (int32_t)result;\n   if (shift != 0 && (h0 & (1 << (shift-1))))\n     h0 = (h0 >> shift) + 1;\n   else\n@@ -1200,24 +1200,24 @@\n :function:::void:do_qb_muleu:int rd, int rs, int rt, int loc\n {\n   int i;\n-  unsigned32 result = 0;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned16 h1, h2;\n-  unsigned32 prod;\n+  uint32_t result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint16_t h1, h2;\n+  uint32_t prod;\n   if (loc == 0)\n     v1 >>= 16;\n   for (i = 0; i < 32; i += 16, v1 >>= 8, v2 >>= 16)\n     {\n-      h1 = (unsigned16)(v1 & 0xff);\n-      h2 = (unsigned16)(v2 & 0xffff);\n-      prod = (unsigned32)h1 * (unsigned32)h2;\n+      h1 = (uint16_t)(v1 & 0xff);\n+      h2 = (uint16_t)(v2 & 0xffff);\n+      prod = (uint32_t)h1 * (uint32_t)h2;\n       if (prod > 0xffff)\n \t{\n \t  DSPCR |= DSPCR_OUFLAG5;\n \t  prod = 0xffff;\n \t}\n-      result |= ((unsigned32)prod << i);\n+      result |= ((uint32_t)prod << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -1240,27 +1240,27 @@\n :function:::void:do_ph_mulq:int rd, int rs, int rt, int round\n {\n   int i;\n-  unsigned32 result = 0;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 prod;\n+  uint32_t result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t prod;\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n-      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n+      if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n \t{\n \t  DSPCR |= DSPCR_OUFLAG5;\n \t  prod = 0x7fffffff;\n \t}\n       else\n \t{\n-\t  prod = ((signed32)h1 * (signed32)h2) << 1;\n+\t  prod = ((int32_t)h1 * (int32_t)h2) << 1;\n \t  if (round == 1)\n-\t    prod += (signed32)0x8000;\n+\t    prod += (int32_t)0x8000;\n \t}\n-      result |= (((unsigned32)prod >> 16) << i);\n+      result |= (((uint32_t)prod >> 16) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -1275,27 +1275,27 @@\n // loc: 0 = phl, 1 = phr\n :function:::void:do_ph_muleq:int rd, int rs, int rt, int loc\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 prod;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t prod;\n   if (loc == 0)\n     {\n-      h1 = (signed16)(v1 >> 16);\n-      h2 = (signed16)(v2 >> 16);\n+      h1 = (int16_t)(v1 >> 16);\n+      h2 = (int16_t)(v2 >> 16);\n     }\n   else\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n     }\n-  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+  if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n     {\n       DSPCR |= DSPCR_OUFLAG5;\n       prod = 0x7fffffff;\n     }\n   else\n-    prod = ((signed32)h1 * (signed32)h2) << 1;\n+    prod = ((int32_t)h1 * (int32_t)h2) << 1;\n   GPR[rd] = EXTEND32 (prod);\n }\n \n@@ -1318,25 +1318,25 @@\n :function:::void:do_qb_dot_product:int ac, int rs, int rt, int op, int loc\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned8 h1, h2;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint8_t h1, h2;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint64_t prod = (((uint64_t)hi) << 32) + (uint64_t)lo;\n   if (loc == 0)\n     {\n       v1 >>= 16;\n       v2 >>= 16;\n     }\n   for (i = 0; i < 16; i += 8, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       if (op == 0) // DPAU\n-\tprod += (unsigned64)h1 * (unsigned64)h2;\n+\tprod += (uint64_t)h1 * (uint64_t)h2;\n       else // DPSU\n-\tprod -= (unsigned64)h1 * (unsigned64)h2;\n+\tprod -= (uint64_t)h1 * (uint64_t)h2;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n@@ -1374,29 +1374,29 @@\n :function:::void:do_ph_dot_product:int ac, int rs, int rt, int op\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n-      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n+      if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n \t{\n \t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n-\t  result = (signed32)0x7fffffff;\n+\t  result = (int32_t)0x7fffffff;\n \t}\n       else\n-\tresult = ((signed32)h1 * (signed32)h2) << 1;\n+\tresult = ((int32_t)h1 * (int32_t)h2) << 1;\n \n       if (op == 0) // DPAQ\n-\tprod += (signed64)result;\n+\tprod += (int64_t)result;\n       else // DPSQ\n-\tprod -= (signed64)result;\n+\tprod -= (int64_t)result;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n@@ -1426,41 +1426,41 @@\n // op: 0 = DPAQ 1 = DPSQ\n :function:::void:do_w_dot_product:int ac, int rs, int rt, int op\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed32 h1, h2;\n-  signed64 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned32 resultlo;\n-  unsigned32 resulthi;\n-  unsigned32 carry;\n-  unsigned64 temp1;\n-  signed64 temp2;\n-  h1 = (signed32) v1;\n-  h2 = (signed32) v2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int32_t h1, h2;\n+  int64_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint32_t resultlo;\n+  uint32_t resulthi;\n+  uint32_t carry;\n+  uint64_t temp1;\n+  int64_t temp2;\n+  h1 = (int32_t) v1;\n+  h2 = (int32_t) v2;\n   if (h1 == 0x80000000 && h2 == 0x80000000)\n     {\n       DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n-      result = (signed64) 0x7fffffffffffffffLL;\n+      result = (int64_t) 0x7fffffffffffffffLL;\n     }\n   else\n-    result = ((signed64)h1 * (signed64)h2) << 1;\n-  resultlo = (unsigned32)(result);\n-  resulthi = (unsigned32)(result >> 32);\n+    result = ((int64_t)h1 * (int64_t)h2) << 1;\n+  resultlo = (uint32_t)(result);\n+  resulthi = (uint32_t)(result >> 32);\n   if (op ==0) // DPAQ\n     {\n-      temp1 = (unsigned64)lo + (unsigned64)resultlo;\n-      carry = (unsigned32)((temp1 >> 32) & 1);\n-      temp2 = (signed64)((signed32)hi) + (signed64)((signed32)resulthi) +\n-\t      (signed64)((signed32)carry);\n+      temp1 = (uint64_t)lo + (uint64_t)resultlo;\n+      carry = (uint32_t)((temp1 >> 32) & 1);\n+      temp2 = (int64_t)((int32_t)hi) + (int64_t)((int32_t)resulthi) +\n+\t      (int64_t)((int32_t)carry);\n     }\n   else // DPSQ\n     {\n-      temp1 = (unsigned64)lo - (unsigned64)resultlo;\n-      carry = (unsigned32)((temp1 >> 32) & 1);\n-      temp2 = (signed64)((signed32)hi) - (signed64)((signed32)resulthi) -\n-\t      (signed64)((signed32)carry);\n+      temp1 = (uint64_t)lo - (uint64_t)resultlo;\n+      carry = (uint32_t)((temp1 >> 32) & 1);\n+      temp2 = (int64_t)((int32_t)hi) - (int64_t)((int32_t)resulthi) -\n+\t      (int64_t)((int32_t)carry);\n     }\n   if (((temp2 & 0x100000000LL) >> 1) != (temp2 & 0x80000000LL))\n     {\n@@ -1502,38 +1502,38 @@\n :function:::void:do_ph_maq:int ac, int rs, int rt, int op, int loc\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   if (loc == 0)\n     {\n-      h1 = (signed16)(v1 >> 16);\n-      h2 = (signed16)(v2 >> 16);\n+      h1 = (int16_t)(v1 >> 16);\n+      h2 = (int16_t)(v2 >> 16);\n     }\n   else\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n     }\n-  if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+  if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n     {\n       DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n-      result = (signed32)0x7fffffff;\n+      result = (int32_t)0x7fffffff;\n     }\n   else\n-    result = ((signed32)h1 * (signed32)h2) << 1;\n-  prod += (signed64)result;\n+    result = ((int32_t)h1 * (int32_t)h2) << 1;\n+  prod += (int64_t)result;\n   if (op == 1) // MAQ_SA\n     {\n       if (prod & 0x8000000000000000LL)\n \t{\n \t  for (i = 62; i >= 31; i--)\n \t    {\n-\t      if (!(prod & ((signed64)1 << i)))\n+\t      if (!(prod & ((int64_t)1 << i)))\n \t\t{\n \t\t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n \t\t  prod = 0xffffffff80000000LL;\n@@ -1545,7 +1545,7 @@\n \t{\n \t  for (i = 62; i >= 31; i--)\n \t    {\n-\t      if (prod & ((signed64)1 << i))\n+\t      if (prod & ((int64_t)1 << i))\n \t\t{\n \t\t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n \t\t  prod = 0x7fffffff;\n@@ -1632,14 +1632,14 @@\n :function:::void:do_qb_cmpu:int rs, int rt, int op\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned8 h1, h2;\n-  unsigned32 mask;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint8_t h1, h2;\n+  uint32_t mask;\n   for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       mask = ~(1 << (DSPCR_CCOND_SHIFT + j));\n       DSPCR &= mask;\n       if (op == 0) // EQ\n@@ -1676,14 +1676,14 @@\n :function:::void:do_qb_cmpgu:int rd, int rs, int rt, int op\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned8 h1, h2;\n-  unsigned32 result = 0;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint8_t h1, h2;\n+  uint32_t result = 0;\n   for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       if (op == 0) // EQ\n \tresult |= ((h1 == h2) << j);\n       else if (op == 1) // LT\n@@ -1719,14 +1719,14 @@\n :function:::void:do_ph_cmpu:int rs, int rt, int op\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  unsigned32 mask;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  uint32_t mask;\n   for (i = 0, j = 0; i < 32; i += 16, j++, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n       mask = ~(1 << (DSPCR_CCOND_SHIFT + j));\n       DSPCR &= mask;\n       if (op == 0) // EQ\n@@ -1784,16 +1784,16 @@\n :function:::void:do_w_extr:int rt, int ac, int shift, int op\n {\n   int i;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;\n-  signed64 result = (signed64)prod;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint64_t prod = (((uint64_t)hi) << 32) + (uint64_t)lo;\n+  int64_t result = (int64_t)prod;\n   int setcond = 0;\n   if (!(prod & 0x8000000000000000LL))\n     {\n       for (i = 62; i >= (shift + 31); i--)\n \t{\n-\t  if (prod & ((unsigned64)1 << i))\n+\t  if (prod & ((uint64_t)1 << i))\n \t    {\n \t      DSPCR |= DSPCR_OUFLAG7;\n \t      setcond = 1;\n@@ -1810,7 +1810,7 @@\n     {\n       for (i = 62; i >= (shift + 31); i--)\n \t{\n-\t  if (!(prod & ((unsigned64)1 << i)))\n+\t  if (!(prod & ((uint64_t)1 << i)))\n \t    {\n \t      DSPCR |= DSPCR_OUFLAG7;\n \t      setcond = 2;\n@@ -1889,11 +1889,11 @@\n :function:::void:do_h_extr:int rt, int ac, int shift\n {\n   int i;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;\n-  signed64 result = (signed64)prod;\n-  signed64 value = 0xffffffffffff8000LL;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint64_t prod = (((uint64_t)hi) << 32) + (uint64_t)lo;\n+  int64_t result = (int64_t)prod;\n+  int64_t value = 0xffffffffffff8000LL;\n   result >>= shift;\n   if (result > 0x7fff)\n     {\n@@ -1925,15 +1925,15 @@\n // op: 0 = EXTP, 1 = EXTPDP\n :function:::void:do_extp:int rt, int ac, int size, int op\n {\n-  signed32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;\n-  unsigned64 result = 0;\n+  int32_t pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint64_t prod = (((uint64_t)hi) << 32) + (uint64_t)lo;\n+  uint64_t result = 0;\n   if (pos - (size + 1) >= -1)\n     {\n       prod >>= (pos - size);\n-      result = prod & (((unsigned64)1 << (size + 1)) - 1);\n+      result = prod & (((uint64_t)1 << (size + 1)) - 1);\n       DSPCR &= (~DSPCR_EFI_SMASK);\n       if (op == 1) // EXTPDP\n \t{\n@@ -1986,9 +1986,9 @@\n \n :function:::void:do_shilo:int ac, int shift\n {\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  unsigned64 prod = (((unsigned64)hi) << 32) + (unsigned64)lo;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  uint64_t prod = (((uint64_t)hi) << 32) + (uint64_t)lo;\n   if (shift > 31)\n     shift = shift - 64;\n   if (shift >= 0)\n@@ -2061,7 +2061,7 @@\n \"bposge32 <OFFSET>\"\n *dsp:\n {\n-  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n+  uint32_t pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n   address_word offset = EXTEND16 (OFFSET) << 2;\n   if (pos >= 32)\n     {"
    },
    {
      "sha": "032ef1e043f840c07fd8b78959469765dfbed7d3",
      "filename": "sim/mips/dsp2.igen",
      "status": "modified",
      "additions": 108,
      "deletions": 108,
      "changes": 216,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/dsp2.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/dsp2.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dsp2.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -26,20 +26,20 @@\n :function:::void:do_u_ph_op:int rd, int rs, int rt, int op, int sat\n {\n   int i;\n-  unsigned32 h0;\n-  unsigned16 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint32_t h0;\n+  uint16_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (unsigned16)(v1 & 0xffff);\n-      h2 = (unsigned16)(v2 & 0xffff);\n+      h1 = (uint16_t)(v1 & 0xffff);\n+      h2 = (uint16_t)(v2 & 0xffff);\n       if (op == 0) // ADD\n-\th0 = (unsigned32)h1 + (unsigned32)h2;\n+\th0 = (uint32_t)h1 + (uint32_t)h2;\n       else // SUB\n-\th0 = (unsigned32)h1 - (unsigned32)h2;\n-      if (op == 0 && (h0 > (unsigned32)0x0000ffff)) // ADD SAT\n+\th0 = (uint32_t)h1 - (uint32_t)h2;\n+      if (op == 0 && (h0 > (uint32_t)0x0000ffff)) // ADD SAT\n \t{\n \t  DSPCR |= DSPCR_OUFLAG4;\n \t  if (sat == 1)\n@@ -51,7 +51,7 @@\n \t  if (sat == 1)\n \t    h0 = 0x0;\n \t}\n-      result |= ((unsigned32)((unsigned16)h0) << i);\n+      result |= ((uint32_t)((uint16_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -61,24 +61,24 @@\n :function:::void:do_uh_qb_op:int rd, int rs, int rt, int op, int round\n {\n   int i;\n-  unsigned32 h0;\n-  unsigned8 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint32_t h0;\n+  uint8_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       if (op == 0) // ADD\n-\th0 = (unsigned32)h1 + (unsigned32)h2;\n+\th0 = (uint32_t)h1 + (uint32_t)h2;\n       else // SUB\n-\th0 = (unsigned32)h1 - (unsigned32)h2;\n+\th0 = (uint32_t)h1 - (uint32_t)h2;\n       if (round == 1)\n \th0 = (h0 + 1) >> 1;\n       else\n \th0 = h0 >> 1;\n-      result |= ((unsigned32)((unsigned8)h0) << i);\n+      result |= ((uint32_t)((uint8_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -87,15 +87,15 @@\n :function:::void:do_qb_cmpgdu:int rd, int rs, int rt, int op\n {\n   int i, j;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned8 h1, h2;\n-  unsigned32 result = 0;\n-  unsigned32 mask;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint8_t h1, h2;\n+  uint32_t result = 0;\n+  uint32_t mask;\n   for (i = 0, j = 0; i < 32; i += 8, j++, v1 >>= 8, v2 >>= 8)\n     {\n-      h1 = (unsigned8)(v1 & 0xff);\n-      h2 = (unsigned8)(v2 & 0xff);\n+      h1 = (uint8_t)(v1 & 0xff);\n+      h2 = (uint8_t)(v2 & 0xff);\n       mask = ~(1 << (DSPCR_CCOND_SHIFT + j));\n       DSPCR &= mask;\n       if (op == 0) // EQ\n@@ -121,22 +121,22 @@\n :function:::void:do_w_ph_dot_product:int ac, int rs, int rt, int op\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n-      result = (signed32)h1 * (signed32)h2;\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n+      result = (int32_t)h1 * (int32_t)h2;\n       if (op == 0) // DPA\n-        prod += (signed64)result;\n+        prod += (int64_t)result;\n       else // DPS\n-        prod -= (signed64)result;\n+        prod -= (int64_t)result;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n@@ -145,37 +145,37 @@\n // round: 0 = no rounding, 1 = rounding\n :function:::void:do_w_mulq:int rd, int rs, int rt, int round\n {\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed32 w1, w2;\n-  signed64 prod;\n-  unsigned32 result;\n-  w1 = (signed32) v1;\n-  w2 = (signed32) v2;\n-  if (w1 == (signed32) 0x80000000 && w2 == (signed32) 0x80000000)\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int32_t w1, w2;\n+  int64_t prod;\n+  uint32_t result;\n+  w1 = (int32_t) v1;\n+  w2 = (int32_t) v2;\n+  if (w1 == (int32_t) 0x80000000 && w2 == (int32_t) 0x80000000)\n     {\n       DSPCR |= DSPCR_OUFLAG5;\n       prod = 0x7fffffff;\n     }\n   else\n     {\n-      prod = ((signed64) w1 * (signed64) w2) << 1;\n+      prod = ((int64_t) w1 * (int64_t) w2) << 1;\n       if (round == 1)\n \tprod += 0x0000000080000000LL;\n       prod = prod >> 32;\n     }\n-  result = (unsigned32) prod;\n+  result = (uint32_t) prod;\n   GPR[rd] = EXTEND32 (result);\n }\n \n // round: 0 = no rounding, 1 = rounding\n :function:::void:do_precr_sra:int rt, int rs, int sa, int round\n {\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 v2 = GPR[rs];\n-  signed32 w1 = (signed32) v1;\n-  signed32 w2 = (signed32) v2;\n-  signed32 result;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t v2 = GPR[rs];\n+  int32_t w1 = (int32_t) v1;\n+  int32_t w2 = (int32_t) v2;\n+  int32_t result;\n   if (sa != 0)\n     {\n       if (round == 1 && (w1 & (1 << (sa - 1))))\n@@ -196,35 +196,35 @@\n :function:::void:do_qb_shra:int rd, int rt, int shift, int round\n {\n   int i, j;\n-  signed8 q0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  int8_t q0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 8, v1 >>= 8)\n     {\n-      q0 = (signed8)(v1 & 0xff);\n+      q0 = (int8_t)(v1 & 0xff);\n       if (shift != 0)\n  \t{\n \t  if (round == 1 && (q0 & (1 << (shift - 1))))\n \t    q0 = (q0 >> shift) + 1;\n \t  else\n \t    q0 = q0 >> shift;\n  \t}\n-      result |= ((unsigned32)((unsigned8)q0) << i);\n+      result |= ((uint32_t)((uint8_t)q0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n \n :function:::void:do_ph_shrl:int rd, int rt, int shift\n {\n   int i, j;\n-  unsigned16 h0;\n-  unsigned32 v1 = GPR[rt];\n-  unsigned32 result = 0;\n+  uint16_t h0;\n+  uint32_t v1 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 16, v1 >>= 16)\n     {\n-      h0 = (unsigned16)(v1 & 0xffff);\n+      h0 = (uint16_t)(v1 & 0xffff);\n       h0 = h0 >> shift;\n-      result |= ((unsigned32)h0 << i);\n+      result |= ((uint32_t)h0 << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -234,24 +234,24 @@\n :function:::void:do_qh_ph_op:int rd, int rs, int rt, int op, int round\n {\n   int i;\n-  signed32 h0;\n-  signed16 h1, h2;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  unsigned32 result = 0;\n+  int32_t h0;\n+  int16_t h1, h2;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  uint32_t result = 0;\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 >>= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)(v2 & 0xffff);\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)(v2 & 0xffff);\n       if (op == 0) // ADD\n-\th0 = (signed32)h1 + (signed32)h2;\n+\th0 = (int32_t)h1 + (int32_t)h2;\n       else // SUB\n-\th0 = (signed32)h1 - (signed32)h2;\n+\th0 = (int32_t)h1 - (int32_t)h2;\n       if (round == 1)\n \th0 = (h0 + 1) >> 1;\n       else\n \th0 = h0 >> 1;\n-      result |= ((unsigned32)((unsigned16)h0) << i);\n+      result |= ((uint32_t)((uint16_t)h0) << i);\n     }\n   GPR[rd] = EXTEND32 (result);\n }\n@@ -261,13 +261,13 @@\n :function:::void:do_qh_w_op:int rd, int rs, int rt, int op, int round\n {\n   int i;\n-  signed64 v0;\n-  signed32 v1 = (signed32)GPR[rs];\n-  signed32 v2 = (signed32)GPR[rt];\n+  int64_t v0;\n+  int32_t v1 = (int32_t)GPR[rs];\n+  int32_t v2 = (int32_t)GPR[rt];\n   if (op == 0) // ADD\n-    v0 = (signed64)v1 + (signed64)v2;\n+    v0 = (int64_t)v1 + (int64_t)v2;\n   else // SUB\n-    v0 = (signed64)v1 - (signed64)v2;\n+    v0 = (int64_t)v1 - (int64_t)v2;\n   if (round == 1)\n     v0 = (v0 + 1) >> 1;\n   else\n@@ -279,22 +279,22 @@\n :function:::void:do_x_w_ph_dot_product:int ac, int rs, int rt, int op\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)((v2 & 0xffff0000) >> 16);\n-      result = (signed32)h1 * (signed32)h2;\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)((v2 & 0xffff0000) >> 16);\n+      result = (int32_t)h1 * (int32_t)h2;\n       if (op == 0) // DPAX\n-        prod += (signed64)result;\n+        prod += (int64_t)result;\n       else // DPSX\n-        prod -= (signed64)result;\n+        prod -= (int64_t)result;\n     }\n   DSPLO(ac) = EXTEND32 (prod);\n   DSPHI(ac) = EXTEND32 (prod >> 32);\n@@ -305,35 +305,35 @@\n :function:::void:do_qx_w_ph_dot_product:int ac, int rs, int rt, int op, int sat\n {\n   int i;\n-  unsigned32 v1 = GPR[rs];\n-  unsigned32 v2 = GPR[rt];\n-  signed16 h1, h2;\n-  signed32 result;\n-  unsigned32 lo = DSPLO(ac);\n-  unsigned32 hi = DSPHI(ac);\n-  signed64 prod = (signed64)((((unsigned64)hi) << 32) + (unsigned64)lo);\n-  signed64 max, min;\n+  uint32_t v1 = GPR[rs];\n+  uint32_t v2 = GPR[rt];\n+  int16_t h1, h2;\n+  int32_t result;\n+  uint32_t lo = DSPLO(ac);\n+  uint32_t hi = DSPHI(ac);\n+  int64_t prod = (int64_t)((((uint64_t)hi) << 32) + (uint64_t)lo);\n+  int64_t max, min;\n   for (i = 0; i < 32; i += 16, v1 >>= 16, v2 <<= 16)\n     {\n-      h1 = (signed16)(v1 & 0xffff);\n-      h2 = (signed16)((v2 & 0xffff0000) >> 16);\n-      if (h1 == (signed16)0x8000 && h2 == (signed16)0x8000)\n+      h1 = (int16_t)(v1 & 0xffff);\n+      h2 = (int16_t)((v2 & 0xffff0000) >> 16);\n+      if (h1 == (int16_t)0x8000 && h2 == (int16_t)0x8000)\n \t{\n \t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));\n \t  result = 0x7fffffff;\n \t}\n       else\n-\tresult = ((signed32)h1 * (signed32)h2) << 1;\n+\tresult = ((int32_t)h1 * (int32_t)h2) << 1;\n       if (op == 0) // DPAQX\n-        prod += (signed64)result;\n+        prod += (int64_t)result;\n       else // DPSQX\n-        prod -= (signed64)result;\n+        prod -= (int64_t)result;\n     }\n   // Saturation on the accumulator.\n   if (sat == 1)\n     {\n-      max = (signed64) 0x7fffffffLL;\n-      min = (signed64) 0xffffffff80000000LL;\n+      max = (int64_t) 0x7fffffffLL;\n+      min = (int64_t) 0xffffffff80000000LL;\n       if (prod > max)\n \t{\n \t  DSPCR |= (1 << (DSPCR_OUFLAG_SHIFT + ac));"
    },
    {
      "sha": "65015623ee52baca6405e7eb0294b53aa573eaeb",
      "filename": "sim/mips/interp.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/interp.c?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -718,7 +718,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n       for (loop = 0; (loop < idt_monitor_size); loop += 4)\n \t{\n \t  address_word vaddr = (idt_monitor_base + loop);\n-\t  unsigned32 insn = (RSVD_INSTRUCTION |\n+\t  uint32_t insn = (RSVD_INSTRUCTION |\n \t\t\t     (((loop >> 2) & RSVD_INSTRUCTION_ARG_MASK)\n \t\t\t      << RSVD_INSTRUCTION_ARG_SHIFT));\n \t  H2T (insn);\n@@ -737,7 +737,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n       unsigned loop;\n       for (loop = 0; (loop < 24); loop++)\n \t{\n-\t  unsigned32 value = ((0x500 - 8) / 8); /* default UNDEFINED reason code */\n+\t  uint32_t value = ((0x500 - 8) / 8); /* default UNDEFINED reason code */\n \t  switch (loop)\n \t    {\n             case 0: /* read */\n@@ -787,7 +787,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n       (pmon_monitor_base != 0) ||\n       (lsipmon_monitor_base != 0))\n     {\n-      unsigned32 halt[2] = { 0x2404002f /* addiu r4, r0, 47 */,\n+      uint32_t halt[2] = { 0x2404002f /* addiu r4, r0, 47 */,\n \t\t\t     HALT_INSTRUCTION /* BREAK */ };\n       H2T (halt[0]);\n       H2T (halt[1]);\n@@ -869,25 +869,25 @@ mips_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n \t  if (length == 8)\n \t    {\n \t      cpu->fgr[rn - FGR_BASE] =\n-\t\t(unsigned32) T2H_8 (*(unsigned64*)memory);\n+\t\t(uint32_t) T2H_8 (*(uint64_t*)memory);\n \t      return 8;\n \t    }\n \t  else\n \t    {\n-\t      cpu->fgr[rn - FGR_BASE] = T2H_4 (*(unsigned32*)memory);\n+\t      cpu->fgr[rn - FGR_BASE] = T2H_4 (*(uint32_t*)memory);\n \t      return 4;\n \t    }\n \t}\n       else\n \t{\n           if (length == 8)\n \t    {\n-\t      cpu->fgr[rn - FGR_BASE] = T2H_8 (*(unsigned64*)memory);\n+\t      cpu->fgr[rn - FGR_BASE] = T2H_8 (*(uint64_t*)memory);\n \t      return 8;\n \t    }\n \t  else\n \t    {\n-\t      cpu->fgr[rn - FGR_BASE] = T2H_4 (*(unsigned32*)memory);\n+\t      cpu->fgr[rn - FGR_BASE] = T2H_4 (*(uint32_t*)memory);\n \t      return 4;\n \t    }\n \t}\n@@ -898,25 +898,25 @@ mips_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n       if (length == 8)\n \t{\n \t  cpu->registers[rn] =\n-\t    (unsigned32) T2H_8 (*(unsigned64*)memory);\n+\t    (uint32_t) T2H_8 (*(uint64_t*)memory);\n \t  return 8;\n \t}\n       else\n \t{\n-\t  cpu->registers[rn] = T2H_4 (*(unsigned32*)memory);\n+\t  cpu->registers[rn] = T2H_4 (*(uint32_t*)memory);\n \t  return 4;\n \t}\n     }\n   else\n     {\n       if (length == 8)\n \t{\n-\t  cpu->registers[rn] = T2H_8 (*(unsigned64*)memory);\n+\t  cpu->registers[rn] = T2H_8 (*(uint64_t*)memory);\n \t  return 8;\n \t}\n       else\n \t{\n-\t  cpu->registers[rn] = (signed32) T2H_4(*(unsigned32*)memory);\n+\t  cpu->registers[rn] = (int32_t) T2H_4(*(uint32_t*)memory);\n \t  return 4;\n \t}\n     }\n@@ -943,26 +943,26 @@ mips_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n \t{\n \t  if (length == 8)\n \t    {\n-\t      *(unsigned64*)memory =\n-\t\tH2T_8 ((unsigned32) (cpu->fgr[rn - FGR_BASE]));\n+\t      *(uint64_t*)memory =\n+\t\tH2T_8 ((uint32_t) (cpu->fgr[rn - FGR_BASE]));\n \t      return 8;\n \t    }\n \t  else\n \t    {\n-\t      *(unsigned32*)memory = H2T_4 (cpu->fgr[rn - FGR_BASE]);\n+\t      *(uint32_t*)memory = H2T_4 (cpu->fgr[rn - FGR_BASE]);\n \t      return 4;\n \t    }\n \t}\n       else\n \t{\n \t  if (length == 8)\n \t    {\n-\t      *(unsigned64*)memory = H2T_8 (cpu->fgr[rn - FGR_BASE]);\n+\t      *(uint64_t*)memory = H2T_8 (cpu->fgr[rn - FGR_BASE]);\n \t      return 8;\n \t    }\n \t  else\n \t    {\n-\t      *(unsigned32*)memory = H2T_4 ((unsigned32)(cpu->fgr[rn - FGR_BASE]));\n+\t      *(uint32_t*)memory = H2T_4 ((uint32_t)(cpu->fgr[rn - FGR_BASE]));\n \t      return 4;\n \t    }\n \t}\n@@ -972,27 +972,27 @@ mips_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n     {\n       if (length == 8)\n \t{\n-\t  *(unsigned64*)memory =\n-\t    H2T_8 ((unsigned32) (cpu->registers[rn]));\n+\t  *(uint64_t*)memory =\n+\t    H2T_8 ((uint32_t) (cpu->registers[rn]));\n \t  return 8;\n \t}\n       else\n \t{\n-\t  *(unsigned32*)memory = H2T_4 ((unsigned32)(cpu->registers[rn]));\n+\t  *(uint32_t*)memory = H2T_4 ((uint32_t)(cpu->registers[rn]));\n \t  return 4;\n \t}\n     }\n   else\n     {\n       if (length == 8)\n \t{\n-\t  *(unsigned64*)memory =\n-\t    H2T_8 ((unsigned64) (cpu->registers[rn]));\n+\t  *(uint64_t*)memory =\n+\t    H2T_8 ((uint64_t) (cpu->registers[rn]));\n \t  return 8;\n \t}\n       else\n \t{\n-\t  *(unsigned32*)memory = H2T_4 ((unsigned32)(cpu->registers[rn]));\n+\t  *(uint32_t*)memory = H2T_4 ((uint32_t)(cpu->registers[rn]));\n \t  return 4;\n \t}\n     }\n@@ -1028,7 +1028,7 @@ sim_create_inferior (SIM_DESC sd, struct bfd *abfd,\n \t     These addresses work as is on 64-bit targets but\n \t     can be truncated for 32-bit targets.  */\n \t  if (WITH_TARGET_WORD_BITSIZE == 32)\n-\t    pc = (unsigned32) pc;\n+\t    pc = (uint32_t) pc;\n \n \t  CPU_PC_SET (cpu, pc);\n \t}\n@@ -2321,7 +2321,7 @@ decode_coproc (SIM_DESC sd,\n \t\t/* CPR[0,rd] = GPR[rt]; */\n \t      default:\n \t\tif (op == cp0_mfc0 || op == cp0_dmfc0)\n-\t\t  GPR[rt] = (signed_word) (signed32) COP0_GPR[rd];\n+\t\t  GPR[rt] = (signed_word) (int32_t) COP0_GPR[rd];\n \t\telse\n \t\t  COP0_GPR[rd] = GPR[rt];\n #if 0\n@@ -2336,7 +2336,7 @@ decode_coproc (SIM_DESC sd,\n \t\t && rd == 16)\n \t  {\n \t    /* [D]MFC0 RT,C0_CONFIG,SEL */\n-\t    signed32 cfg = 0;\n+\t    int32_t cfg = 0;\n \t    switch (sel)\n \t      {\n \t      case 0:"
    },
    {
      "sha": "1d53d187596e51a41411cea89e15de49d1137f67",
      "filename": "sim/mips/m16.igen",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/m16.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/m16.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/m16.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -454,7 +454,7 @@\n *mips16:\n *vr4100:\n {\n-  unsigned32 temp = (basepc (SD_) & ~3) + (IMMED << 2);\n+  uint32_t temp = (basepc (SD_) & ~3) + (IMMED << 2);\n   GPR[TRX] = EXTEND32 (temp);\n }\n \n@@ -463,7 +463,7 @@\n *mips16:\n *vr4100:\n {\n-  unsigned32 temp = (basepc (SD_) & ~3) + EXTEND16 (IMMEDIATE);\n+  uint32_t temp = (basepc (SD_) & ~3) + EXTEND16 (IMMEDIATE);\n   GPR[TRX] = EXTEND32 (temp);\n }\n "
    },
    {
      "sha": "cb8948906707d866d13053cacaae7d53bc8392b9",
      "filename": "sim/mips/m16e.igen",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/m16e.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/m16e.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/m16e.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -55,7 +55,7 @@\n *mips16e:\n {\n   TRACE_ALU_INPUT1 (GPR[TRX]);\n-  GPR[TRX] =  (unsigned_word)(unsigned8)(GPR[TRX]);\n+  GPR[TRX] =  (unsigned_word)(uint8_t)(GPR[TRX]);\n   TRACE_ALU_RESULT (GPR[TRX]);\n }\n \n@@ -64,7 +64,7 @@\n *mips16e:\n {\n   TRACE_ALU_INPUT1 (GPR[TRX]);\n-  GPR[TRX] = (unsigned_word)(unsigned16)(GPR[TRX]);\n+  GPR[TRX] = (unsigned_word)(uint16_t)(GPR[TRX]);\n   TRACE_ALU_RESULT (GPR[TRX]);\n }\n \n@@ -74,7 +74,7 @@\n {\n   check_u64 (SD_, instruction_0);\n   TRACE_ALU_INPUT1 (GPR[TRX]);\n-  GPR[TRX] = (unsigned_word)(unsigned32)(GPR[TRX]);\n+  GPR[TRX] = (unsigned_word)(uint32_t)(GPR[TRX]);\n   TRACE_ALU_RESULT (GPR[TRX]);\n }\n "
    },
    {
      "sha": "e355da9193bc8aaa72eb36ac836157a28a720b01",
      "filename": "sim/mips/mdmx.c",
      "status": "modified",
      "additions": 258,
      "deletions": 258,
      "changes": 516,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mdmx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mdmx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mdmx.c?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -54,10 +54,10 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n    the (not guaranteed portable) assumption that right shifts of signed\n    quantities in C do sign extension.  */\n \n-typedef unsigned64 unsigned48;\n+typedef uint64_t unsigned48;\n #define MASK48 (UNSIGNED64 (0xffffffffffff))\n \n-typedef unsigned32 unsigned24;\n+typedef uint32_t unsigned24;\n #define MASK24 (UNSIGNED32 (0xffffff))\n \n typedef enum {\n@@ -71,183 +71,183 @@ typedef enum {\n   sel_imm           /* immediate select */\n } VT_select;\n \n-#define OB_MAX  ((unsigned8)0xFF)\n-#define QH_MIN  ((signed16)0x8000)\n-#define QH_MAX  ((signed16)0x7FFF)\n+#define OB_MAX  ((uint8_t)0xFF)\n+#define QH_MIN  ((int16_t)0x8000)\n+#define QH_MAX  ((int16_t)0x7FFF)\n \n-#define OB_CLAMP(x)  ((unsigned8)((x) > OB_MAX ? OB_MAX : (x)))\n-#define QH_CLAMP(x)  ((signed16)((x) < QH_MIN ? QH_MIN : \\\n+#define OB_CLAMP(x)  ((uint8_t)((x) > OB_MAX ? OB_MAX : (x)))\n+#define QH_CLAMP(x)  ((int16_t)((x) < QH_MIN ? QH_MIN : \\\n                                 ((x) > QH_MAX ? QH_MAX : (x))))\n \n #define MX_FMT(fmtsel) (((fmtsel) & 0x1) == 0 ? mdmx_ob : mdmx_qh)\n #define MX_VT(fmtsel)  (((fmtsel) & 0x10) == 0 ?    sel_elem : \\\n                        (((fmtsel) & 0x18) == 0x10 ? sel_vect : sel_imm))\n \n #define QH_ELEM(v,fmtsel) \\\n-        ((signed16)(((v) >> (((fmtsel) & 0xC) << 2)) & 0xFFFF))\n+        ((int16_t)(((v) >> (((fmtsel) & 0xC) << 2)) & 0xFFFF))\n #define OB_ELEM(v,fmtsel) \\\n-        ((unsigned8)(((v) >> (((fmtsel) & 0xE) << 2)) & 0xFF))\n+        ((uint8_t)(((v) >> (((fmtsel) & 0xE) << 2)) & 0xFF))\n \n \n-typedef signed16 (*QH_FUNC)(signed16, signed16);\n-typedef unsigned8 (*OB_FUNC)(unsigned8, unsigned8);\n+typedef int16_t (*QH_FUNC)(int16_t, int16_t);\n+typedef uint8_t (*OB_FUNC)(uint8_t, uint8_t);\n \n /* vectorized logical operators */\n \n-static signed16\n-AndQH(signed16 ts, signed16 tt)\n+static int16_t\n+AndQH(int16_t ts, int16_t tt)\n {\n-  return (signed16)((unsigned16)ts & (unsigned16)tt);\n+  return (int16_t)((uint16_t)ts & (uint16_t)tt);\n }\n \n-static unsigned8\n-AndOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+AndOB(uint8_t ts, uint8_t tt)\n {\n   return ts & tt;\n }\n \n-static signed16\n-NorQH(signed16 ts, signed16 tt)\n+static int16_t\n+NorQH(int16_t ts, int16_t tt)\n {\n-  return (signed16)(((unsigned16)ts | (unsigned16)tt) ^ 0xFFFF);\n+  return (int16_t)(((uint16_t)ts | (uint16_t)tt) ^ 0xFFFF);\n }\n \n-static unsigned8\n-NorOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+NorOB(uint8_t ts, uint8_t tt)\n {\n   return (ts | tt) ^ 0xFF;\n }\n \n-static signed16\n-OrQH(signed16 ts, signed16 tt)\n+static int16_t\n+OrQH(int16_t ts, int16_t tt)\n {\n-  return (signed16)((unsigned16)ts | (unsigned16)tt);\n+  return (int16_t)((uint16_t)ts | (uint16_t)tt);\n }\n \n-static unsigned8\n-OrOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+OrOB(uint8_t ts, uint8_t tt)\n {\n   return ts | tt;\n }\n \n-static signed16\n-XorQH(signed16 ts, signed16 tt)\n+static int16_t\n+XorQH(int16_t ts, int16_t tt)\n {\n-  return (signed16)((unsigned16)ts ^ (unsigned16)tt);\n+  return (int16_t)((uint16_t)ts ^ (uint16_t)tt);\n }\n \n-static unsigned8\n-XorOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+XorOB(uint8_t ts, uint8_t tt)\n {\n   return ts ^ tt;\n }\n \n-static signed16\n-SLLQH(signed16 ts, signed16 tt)\n+static int16_t\n+SLLQH(int16_t ts, int16_t tt)\n {\n-  unsigned32 s = (unsigned32)tt & 0xF;\n-  return (signed16)(((unsigned32)ts << s) & 0xFFFF);\n+  uint32_t s = (uint32_t)tt & 0xF;\n+  return (int16_t)(((uint32_t)ts << s) & 0xFFFF);\n }\n \n-static unsigned8\n-SLLOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+SLLOB(uint8_t ts, uint8_t tt)\n {\n-  unsigned32 s = tt & 0x7;\n+  uint32_t s = tt & 0x7;\n   return (ts << s) & 0xFF;\n }\n \n-static signed16\n-SRLQH(signed16 ts, signed16 tt)\n+static int16_t\n+SRLQH(int16_t ts, int16_t tt)\n {\n-  unsigned32 s = (unsigned32)tt & 0xF;\n-  return (signed16)((unsigned16)ts >> s);\n+  uint32_t s = (uint32_t)tt & 0xF;\n+  return (int16_t)((uint16_t)ts >> s);\n }\n \n-static unsigned8\n-SRLOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+SRLOB(uint8_t ts, uint8_t tt)\n {\n-  unsigned32 s = tt & 0x7;\n+  uint32_t s = tt & 0x7;\n   return ts >> s;\n }\n \n \n /* Vectorized arithmetic operators.  */\n \n-static signed16\n-AddQH(signed16 ts, signed16 tt)\n+static int16_t\n+AddQH(int16_t ts, int16_t tt)\n {\n-  signed32 t = (signed32)ts + (signed32)tt;\n+  int32_t t = (int32_t)ts + (int32_t)tt;\n   return QH_CLAMP(t);\n }\n \n-static unsigned8\n-AddOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+AddOB(uint8_t ts, uint8_t tt)\n {\n-  unsigned32 t = (unsigned32)ts + (unsigned32)tt;\n+  uint32_t t = (uint32_t)ts + (uint32_t)tt;\n   return OB_CLAMP(t);\n }\n \n-static signed16\n-SubQH(signed16 ts, signed16 tt)\n+static int16_t\n+SubQH(int16_t ts, int16_t tt)\n {\n-  signed32 t = (signed32)ts - (signed32)tt;\n+  int32_t t = (int32_t)ts - (int32_t)tt;\n   return QH_CLAMP(t);\n }\n \n-static unsigned8\n-SubOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+SubOB(uint8_t ts, uint8_t tt)\n {\n-  signed32 t;\n-  t = (signed32)ts - (signed32)tt;\n+  int32_t t;\n+  t = (int32_t)ts - (int32_t)tt;\n   if (t < 0)\n     t = 0;\n-  return (unsigned8)t;\n+  return (uint8_t)t;\n }\n \n-static signed16\n-MinQH(signed16 ts, signed16 tt)\n+static int16_t\n+MinQH(int16_t ts, int16_t tt)\n {\n   return (ts < tt ? ts : tt);\n }\n \n-static unsigned8\n-MinOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+MinOB(uint8_t ts, uint8_t tt)\n {\n   return (ts < tt ? ts : tt);\n }\n \n-static signed16\n-MaxQH(signed16 ts, signed16 tt)\n+static int16_t\n+MaxQH(int16_t ts, int16_t tt)\n {\n   return (ts > tt ? ts : tt);\n }\n \n-static unsigned8\n-MaxOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+MaxOB(uint8_t ts, uint8_t tt)\n {\n   return (ts > tt ? ts : tt);\n }\n \n-static signed16\n-MulQH(signed16 ts, signed16 tt)\n+static int16_t\n+MulQH(int16_t ts, int16_t tt)\n {\n-  signed32 t = (signed32)ts * (signed32)tt;\n+  int32_t t = (int32_t)ts * (int32_t)tt;\n   return QH_CLAMP(t);\n }\n \n-static unsigned8\n-MulOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+MulOB(uint8_t ts, uint8_t tt)\n {\n-  unsigned32 t = (unsigned32)ts * (unsigned32)tt;\n+  uint32_t t = (uint32_t)ts * (uint32_t)tt;\n   return OB_CLAMP(t);\n }\n \n /* \"msgn\" and \"sra\" are defined only for QH format.  */\n \n-static signed16\n-MsgnQH(signed16 ts, signed16 tt)\n+static int16_t\n+MsgnQH(int16_t ts, int16_t tt)\n {\n-  signed16 t;\n+  int16_t t;\n   if (ts < 0)\n     t = (tt == QH_MIN ? QH_MAX : -tt);\n   else if (ts == 0)\n@@ -257,26 +257,26 @@ MsgnQH(signed16 ts, signed16 tt)\n   return t;\n }\n \n-static signed16\n-SRAQH(signed16 ts, signed16 tt)\n+static int16_t\n+SRAQH(int16_t ts, int16_t tt)\n {\n-  unsigned32 s = (unsigned32)tt & 0xF;\n-  return (signed16)((signed32)ts >> s);\n+  uint32_t s = (uint32_t)tt & 0xF;\n+  return (int16_t)((int32_t)ts >> s);\n }\n \n \n /* \"pabsdiff\" and \"pavg\" are defined only for OB format.  */\n \n-static unsigned8\n-AbsDiffOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+AbsDiffOB(uint8_t ts, uint8_t tt)\n {\n   return (ts >= tt ? ts - tt : tt - ts);\n }\n \n-static unsigned8\n-AvgOB(unsigned8 ts, unsigned8 tt)\n+static uint8_t\n+AvgOB(uint8_t ts, uint8_t tt)\n {\n-  return ((unsigned32)ts + (unsigned32)tt + 1) >> 1;\n+  return ((uint32_t)ts + (uint32_t)tt + 1) >> 1;\n }\n \n \n@@ -297,87 +297,87 @@ static const OB_FUNC ob_func[] = {\n /* Auxiliary functions for CPR updates.  */\n \n /* Vector mapping for QH format.  */\n-static unsigned64\n-qh_vector_op(unsigned64 v1, unsigned64 v2, QH_FUNC func)\n+static uint64_t\n+qh_vector_op(uint64_t v1, uint64_t v2, QH_FUNC func)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i;\n-  signed16 h, h1, h2;\n+  int16_t h, h1, h2;\n \n   for (i = 0; i < 64; i += 16)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n-      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n+      h2 = (int16_t)(v2 & 0xFFFF);  v2 >>= 16;\n       h = (*func)(h1, h2);\n-      result |= ((unsigned64)((unsigned16)h) << i);\n+      result |= ((uint64_t)((uint16_t)h) << i);\n     }\n   return result;\n }\n \n-static unsigned64\n-qh_map_op(unsigned64 v1, signed16 h2, QH_FUNC func)\n+static uint64_t\n+qh_map_op(uint64_t v1, int16_t h2, QH_FUNC func)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i;\n-  signed16 h, h1;\n+  int16_t h, h1;\n \n   for (i = 0; i < 64; i += 16)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n       h = (*func)(h1, h2);\n-      result |= ((unsigned64)((unsigned16)h) << i);\n+      result |= ((uint64_t)((uint16_t)h) << i);\n     }\n   return result;\n }\n \n \n /* Vector operations for OB format.  */\n \n-static unsigned64\n-ob_vector_op(unsigned64 v1, unsigned64 v2, OB_FUNC func)\n+static uint64_t\n+ob_vector_op(uint64_t v1, uint64_t v2, OB_FUNC func)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i;\n-  unsigned8 b, b1, b2;\n+  uint8_t b, b1, b2;\n \n   for (i = 0; i < 64; i += 8)\n     {\n       b1 = v1 & 0xFF;  v1 >>= 8;\n       b2 = v2 & 0xFF;  v2 >>= 8;\n       b = (*func)(b1, b2);\n-      result |= ((unsigned64)b << i);\n+      result |= ((uint64_t)b << i);\n     }\n   return result;\n }\n \n-static unsigned64\n-ob_map_op(unsigned64 v1, unsigned8 b2, OB_FUNC func)\n+static uint64_t\n+ob_map_op(uint64_t v1, uint8_t b2, OB_FUNC func)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i;\n-  unsigned8 b, b1;\n+  uint8_t b, b1;\n \n   for (i = 0; i < 64; i += 8)\n     {\n       b1 = v1 & 0xFF;  v1 >>= 8;\n       b = (*func)(b1, b2);\n-      result |= ((unsigned64)b << i);\n+      result |= ((uint64_t)b << i);\n     }\n   return result;\n }\n \n \n /* Primary entry for operations that update CPRs.  */\n-unsigned64\n+uint64_t\n mdmx_cpr_op(sim_cpu *cpu,\n \t    address_word cia,\n \t    int op,\n-\t    unsigned64 op1,\n+\t    uint64_t op1,\n \t    int vt,\n \t    MX_fmtsel fmtsel)\n {\n-  unsigned64 op2;\n-  unsigned64 result = 0;\n+  uint64_t op2;\n+  uint64_t result = 0;\n \n   switch (MX_FMT (fmtsel))\n     {\n@@ -422,43 +422,43 @@ mdmx_cpr_op(sim_cpu *cpu,\n /* Operations that update CCs */\n \n static void\n-qh_vector_test(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int cond)\n+qh_vector_test(sim_cpu *cpu, uint64_t v1, uint64_t v2, int cond)\n {\n   int  i;\n-  signed16 h1, h2;\n+  int16_t h1, h2;\n   int  boolean;\n \n   for (i = 0; i < 4; i++)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n-      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n+      h2 = (int16_t)(v2 & 0xFFFF);  v2 >>= 16;\n       boolean = ((cond & MX_C_EQ) && (h1 == h2)) ||\n \t((cond & MX_C_LT) && (h1 < h2));\n       SETFCC(i, boolean);\n     }\n }\n \n static void\n-qh_map_test(sim_cpu *cpu, unsigned64 v1, signed16 h2, int cond)\n+qh_map_test(sim_cpu *cpu, uint64_t v1, int16_t h2, int cond)\n {\n   int  i;\n-  signed16 h1;\n+  int16_t h1;\n   int  boolean;\n \n   for (i = 0; i < 4; i++)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n       boolean = ((cond & MX_C_EQ) && (h1 == h2)) ||\n \t((cond & MX_C_LT) && (h1 < h2));\n       SETFCC(i, boolean);\n     }\n }\n \n static void\n-ob_vector_test(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int cond)\n+ob_vector_test(sim_cpu *cpu, uint64_t v1, uint64_t v2, int cond)\n {\n   int  i;\n-  unsigned8 b1, b2;\n+  uint8_t b1, b2;\n   int  boolean;\n \n   for (i = 0; i < 8; i++)\n@@ -472,15 +472,15 @@ ob_vector_test(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int cond)\n }\n \n static void\n-ob_map_test(sim_cpu *cpu, unsigned64 v1, unsigned8 b2, int cond)\n+ob_map_test(sim_cpu *cpu, uint64_t v1, uint8_t b2, int cond)\n {\n   int  i;\n-  unsigned8 b1;\n+  uint8_t b1;\n   int  boolean;\n \n   for (i = 0; i < 8; i++)\n     {\n-      b1 = (unsigned8)(v1 & 0xFF);  v1 >>= 8;\n+      b1 = (uint8_t)(v1 & 0xFF);  v1 >>= 8;\n       boolean = ((cond & MX_C_EQ) && (b1 == b2)) ||\n \t((cond & MX_C_LT) && (b1 < b2));\n       SETFCC(i, boolean);\n@@ -492,11 +492,11 @@ void\n mdmx_cc_op(sim_cpu *cpu,\n \t   address_word cia,\n \t   int cond,\n-\t   unsigned64 v1,\n+\t   uint64_t v1,\n \t   int vt,\n \t   MX_fmtsel fmtsel)\n {\n-  unsigned64 op2;\n+  uint64_t op2;\n \n   switch (MX_FMT (fmtsel))\n     {\n@@ -538,89 +538,89 @@ mdmx_cc_op(sim_cpu *cpu,\n \n /* Pick operations.  */\n \n-static unsigned64\n-qh_vector_pick(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int tf)\n+static uint64_t\n+qh_vector_pick(sim_cpu *cpu, uint64_t v1, uint64_t v2, int tf)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned16 h;\n+  uint16_t h;\n \n   s = 0;\n   for (i = 0; i < 4; i++)\n     {\n       h = ((GETFCC(i) == tf) ? (v1 & 0xFFFF) : (v2 & 0xFFFF));\n       v1 >>= 16;  v2 >>= 16;\n-      result |= ((unsigned64)h << s);\n+      result |= ((uint64_t)h << s);\n       s += 16;\n     }\n   return result;\n }\n \n-static unsigned64\n-qh_map_pick(sim_cpu *cpu, unsigned64 v1, signed16 h2, int tf)\n+static uint64_t\n+qh_map_pick(sim_cpu *cpu, uint64_t v1, int16_t h2, int tf)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned16 h;\n+  uint16_t h;\n \n   s = 0;\n   for (i = 0; i < 4; i++)\n     {\n-      h = (GETFCC(i) == tf) ? (v1 & 0xFFFF) : (unsigned16)h2;\n+      h = (GETFCC(i) == tf) ? (v1 & 0xFFFF) : (uint16_t)h2;\n       v1 >>= 16;\n-      result |= ((unsigned64)h << s);\n+      result |= ((uint64_t)h << s);\n       s += 16;\n     }\n   return result;\n }\n \n-static unsigned64\n-ob_vector_pick(sim_cpu *cpu, unsigned64 v1, unsigned64 v2, int tf)\n+static uint64_t\n+ob_vector_pick(sim_cpu *cpu, uint64_t v1, uint64_t v2, int tf)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned8 b;\n+  uint8_t b;\n \n   s = 0;\n   for (i = 0; i < 8; i++)\n     {\n       b = (GETFCC(i) == tf) ? (v1 & 0xFF) : (v2 & 0xFF);\n       v1 >>= 8;  v2 >>= 8;\n-      result |= ((unsigned64)b << s);\n+      result |= ((uint64_t)b << s);\n       s += 8;\n     }\n   return result;\n }\n \n-static unsigned64\n-ob_map_pick(sim_cpu *cpu, unsigned64 v1, unsigned8 b2, int tf)\n+static uint64_t\n+ob_map_pick(sim_cpu *cpu, uint64_t v1, uint8_t b2, int tf)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned8 b;\n+  uint8_t b;\n \n   s = 0;\n   for (i = 0; i < 8; i++)\n     {\n       b = (GETFCC(i) == tf) ? (v1 & 0xFF) : b2;\n       v1 >>= 8;\n-      result |= ((unsigned64)b << s);\n+      result |= ((uint64_t)b << s);\n       s += 8;\n     }\n   return result;\n }\n \n \n-unsigned64\n+uint64_t\n mdmx_pick_op(sim_cpu *cpu,\n \t     address_word cia,\n \t     int tf,\n-\t     unsigned64 v1,\n+\t     uint64_t v1,\n \t     int vt,\n \t     MX_fmtsel fmtsel)\n {\n-  unsigned64 result = 0;\n-  unsigned64 op2;\n+  uint64_t result = 0;\n+  uint64_t op2;\n \n   switch (MX_FMT (fmtsel))\n     {\n@@ -663,111 +663,111 @@ mdmx_pick_op(sim_cpu *cpu,\n \n /* Accumulators.  */\n \n-typedef void (*QH_ACC)(signed48 *a, signed16 ts, signed16 tt);\n+typedef void (*QH_ACC)(signed48 *a, int16_t ts, int16_t tt);\n \n static void\n-AccAddAQH(signed48 *a, signed16 ts, signed16 tt)\n+AccAddAQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a += (signed48)ts + (signed48)tt;\n }\n \n static void\n-AccAddLQH(signed48 *a, signed16 ts, signed16 tt)\n+AccAddLQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a = (signed48)ts + (signed48)tt;\n }\n \n static void\n-AccMulAQH(signed48 *a, signed16 ts, signed16 tt)\n+AccMulAQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a += (signed48)ts * (signed48)tt;\n }\n \n static void\n-AccMulLQH(signed48 *a, signed16 ts, signed16 tt)\n+AccMulLQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a = (signed48)ts * (signed48)tt;\n }\n \n static void\n-SubMulAQH(signed48 *a, signed16 ts, signed16 tt)\n+SubMulAQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a -= (signed48)ts * (signed48)tt;\n }\n \n static void\n-SubMulLQH(signed48 *a, signed16 ts, signed16 tt)\n+SubMulLQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a = -((signed48)ts * (signed48)tt);\n }\n \n static void\n-AccSubAQH(signed48 *a, signed16 ts, signed16 tt)\n+AccSubAQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a += (signed48)ts - (signed48)tt;\n }\n \n static void\n-AccSubLQH(signed48 *a, signed16 ts, signed16 tt)\n+AccSubLQH(signed48 *a, int16_t ts, int16_t tt)\n {\n   *a =  (signed48)ts - (signed48)tt;\n }\n \n \n-typedef void (*OB_ACC)(signed24 *acc, unsigned8 ts, unsigned8 tt);\n+typedef void (*OB_ACC)(signed24 *acc, uint8_t ts, uint8_t tt);\n \n static void\n-AccAddAOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccAddAOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a += (signed24)ts + (signed24)tt;\n }\n \n static void\n-AccAddLOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccAddLOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a = (signed24)ts + (signed24)tt;\n }\n \n static void\n-AccMulAOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccMulAOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a += (signed24)ts * (signed24)tt;\n }\n \n static void\n-AccMulLOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccMulLOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a = (signed24)ts * (signed24)tt;\n }\n \n static void\n-SubMulAOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+SubMulAOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a -= (signed24)ts * (signed24)tt;\n }\n \n static void\n-SubMulLOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+SubMulLOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a = -((signed24)ts * (signed24)tt);\n }\n \n static void\n-AccSubAOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccSubAOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a += (signed24)ts - (signed24)tt;\n }\n \n static void\n-AccSubLOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccSubLOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n   *a = (signed24)ts - (signed24)tt;\n }\n \n static void\n-AccAbsDiffOB(signed24 *a, unsigned8 ts, unsigned8 tt)\n+AccAbsDiffOB(signed24 *a, uint8_t ts, uint8_t tt)\n {\n-  unsigned8 t = (ts >= tt ? ts - tt : tt - ts);\n+  uint8_t t = (ts >= tt ? ts - tt : tt - ts);\n   *a += (signed24)t;\n }\n \n@@ -788,37 +788,37 @@ static const OB_ACC ob_acc[] = {\n \n \n static void\n-qh_vector_acc(signed48 a[], unsigned64 v1, unsigned64 v2, QH_ACC acc)\n+qh_vector_acc(signed48 a[], uint64_t v1, uint64_t v2, QH_ACC acc)\n {\n   int  i;\n-  signed16 h1, h2;\n+  int16_t h1, h2;\n \n   for (i = 0; i < 4; i++)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n-      h2 = (signed16)(v2 & 0xFFFF);  v2 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n+      h2 = (int16_t)(v2 & 0xFFFF);  v2 >>= 16;\n       (*acc)(&a[i], h1, h2);\n     }\n }\n \n static void\n-qh_map_acc(signed48 a[], unsigned64 v1, signed16 h2, QH_ACC acc)\n+qh_map_acc(signed48 a[], uint64_t v1, int16_t h2, QH_ACC acc)\n {\n   int  i;\n-  signed16 h1;\n+  int16_t h1;\n \n   for (i = 0; i < 4; i++)\n     {\n-      h1 = (signed16)(v1 & 0xFFFF);  v1 >>= 16;\n+      h1 = (int16_t)(v1 & 0xFFFF);  v1 >>= 16;\n       (*acc)(&a[i], h1, h2);\n     }\n }\n \n static void\n-ob_vector_acc(signed24 a[], unsigned64 v1, unsigned64 v2, OB_ACC acc)\n+ob_vector_acc(signed24 a[], uint64_t v1, uint64_t v2, OB_ACC acc)\n {\n   int  i;\n-  unsigned8  b1, b2;\n+  uint8_t  b1, b2;\n \n   for (i = 0; i < 8; i++)\n     {\n@@ -829,10 +829,10 @@ ob_vector_acc(signed24 a[], unsigned64 v1, unsigned64 v2, OB_ACC acc)\n }\n \n static void\n-ob_map_acc(signed24 a[], unsigned64 v1, unsigned8 b2, OB_ACC acc)\n+ob_map_acc(signed24 a[], uint64_t v1, uint8_t b2, OB_ACC acc)\n {\n   int  i;\n-  unsigned8 b1;\n+  uint8_t b1;\n \n   for (i = 0; i < 8; i++)\n     {\n@@ -847,11 +847,11 @@ void\n mdmx_acc_op(sim_cpu *cpu,\n \t    address_word cia,\n \t    int op,\n-\t    unsigned64 op1,\n+\t    uint64_t op1,\n \t    int vt,\n \t    MX_fmtsel fmtsel)\n {\n-  unsigned64 op2;\n+  uint64_t op2;\n \n   switch (MX_FMT (fmtsel))\n     {\n@@ -893,13 +893,13 @@ mdmx_acc_op(sim_cpu *cpu,\n \n /* Reading and writing accumulator (no conversion).  */\n \n-unsigned64\n+uint64_t\n mdmx_rac_op(sim_cpu *cpu,\n \t    address_word cia,\n \t    int op,\n \t    int fmt)\n {\n-  unsigned64    result;\n+  uint64_t    result;\n   unsigned int  shift;\n   int           i;\n \n@@ -934,8 +934,8 @@ void\n mdmx_wacl(sim_cpu *cpu,\n \t  address_word cia,\n \t  int fmt,\n-\t  unsigned64 vs,\n-\t  unsigned64 vt)\n+\t  uint64_t vs,\n+\t  uint64_t vt)\n {\n   int           i;\n \n@@ -944,15 +944,15 @@ mdmx_wacl(sim_cpu *cpu,\n     case MX_FMT_QH:\n       for (i = 0; i < 4; i++)\n \t{\n-\t  signed32  s = (signed16)(vs & 0xFFFF);\n+\t  int32_t  s = (int16_t)(vs & 0xFFFF);\n \t  ACC.qh[i] = ((signed48)s << 16) | (vt & 0xFFFF);\n \t  vs >>= 16;  vt >>= 16;\n \t}\n       break;\n     case MX_FMT_OB:\n       for (i = 0; i < 8; i++)\n \t{\n-\t  signed16  s = (signed8)(vs & 0xFF);\n+\t  int16_t  s = (int8_t)(vs & 0xFF);\n \t  ACC.ob[i] = ((signed24)s << 8) | (vt & 0xFF);\n \t  vs >>= 8;   vt >>= 8;\n \t}\n@@ -966,7 +966,7 @@ void\n mdmx_wach(sim_cpu *cpu,\n \t  address_word cia,\n \t  int fmt,\n-\t  unsigned64 vs)\n+\t  uint64_t vs)\n {\n   int           i;\n \n@@ -975,7 +975,7 @@ mdmx_wach(sim_cpu *cpu,\n     case MX_FMT_QH:\n       for (i = 0; i < 4; i++)\n \t{\n-\t  signed32  s = (signed16)(vs & 0xFFFF);\n+\t  int32_t  s = (int16_t)(vs & 0xFFFF);\n \t  ACC.qh[i] &= ~((signed48)0xFFFF << 32);\n \t  ACC.qh[i] |=  ((signed48)s << 32);\n \t  vs >>= 16;\n@@ -998,16 +998,16 @@ mdmx_wach(sim_cpu *cpu,\n /* Reading and writing accumulator (rounding conversions).\n    Enumerating function guarantees s >= 0 for QH ops.  */\n \n-typedef signed16 (*QH_ROUND)(signed48 a, signed16 s);\n+typedef int16_t (*QH_ROUND)(signed48 a, int16_t s);\n \n #define QH_BIT(n)  ((unsigned48)1 << (n))\n #define QH_ONES(n) (((unsigned48)1 << (n))-1)\n \n-static signed16\n-RNASQH(signed48 a, signed16 s)\n+static int16_t\n+RNASQH(signed48 a, int16_t s)\n {\n   signed48 t;\n-  signed16 result = 0;\n+  int16_t result = 0;\n \n   if (s > 48)\n     result = 0;\n@@ -1031,16 +1031,16 @@ RNASQH(signed48 a, signed16 s)\n \t  if (t < QH_MIN)\n \t    t = QH_MIN;\n \t}\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n-static signed16\n-RNAUQH(signed48 a, signed16 s)\n+static int16_t\n+RNAUQH(signed48 a, int16_t s)\n {\n   unsigned48 t;\n-  signed16 result;\n+  int16_t result;\n \n   if (s > 48)\n     result = 0;\n@@ -1053,16 +1053,16 @@ RNAUQH(signed48 a, signed16 s)\n \tt++;\n       if (t > 0xFFFF)\n \tt = 0xFFFF;\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n-static signed16\n-RNESQH(signed48 a, signed16 s)\n+static int16_t\n+RNESQH(signed48 a, int16_t s)\n {\n   signed48 t;\n-  signed16 result = 0;\n+  int16_t result = 0;\n \n   if (s > 47)\n     result = 0;\n@@ -1086,16 +1086,16 @@ RNESQH(signed48 a, signed16 s)\n \t  if (t < QH_MIN)\n \t    t = QH_MIN;\n \t}\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n-static signed16\n-RNEUQH(signed48 a, signed16 s)\n+static int16_t\n+RNEUQH(signed48 a, int16_t s)\n {\n   unsigned48 t;\n-  signed16 result;\n+  int16_t result;\n \n   if (s > 48)\n     result = 0;\n@@ -1113,16 +1113,16 @@ RNEUQH(signed48 a, signed16 s)\n \t}\n       if (t > 0xFFFF)\n \tt = 0xFFFF;\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n-static signed16\n-RZSQH(signed48 a, signed16 s)\n+static int16_t\n+RZSQH(signed48 a, int16_t s)\n {\n   signed48 t;\n-  signed16 result = 0;\n+  int16_t result = 0;\n \n   if (s > 47)\n     result = 0;\n@@ -1139,16 +1139,16 @@ RZSQH(signed48 a, signed16 s)\n \t  if (t < QH_MIN)\n \t    t = QH_MIN;\n \t}\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n-static signed16\n-RZUQH(signed48 a, signed16 s)\n+static int16_t\n+RZUQH(signed48 a, int16_t s)\n {\n   unsigned48 t;\n-  signed16 result = 0;\n+  int16_t result = 0;\n \n   if (s > 48)\n     result = 0;\n@@ -1159,21 +1159,21 @@ RZUQH(signed48 a, signed16 s)\n       t = ((unsigned48)a & MASK48) >> s;\n       if (t > 0xFFFF)\n \tt = 0xFFFF;\n-      result = (signed16)t;\n+      result = (int16_t)t;\n     }\n   return result;\n }\n \n \n-typedef unsigned8 (*OB_ROUND)(signed24 a, unsigned8 s);\n+typedef uint8_t (*OB_ROUND)(signed24 a, uint8_t s);\n \n #define OB_BIT(n)  ((unsigned24)1 << (n))\n #define OB_ONES(n) (((unsigned24)1 << (n))-1)\n \n-static unsigned8\n-RNAUOB(signed24 a, unsigned8 s)\n+static uint8_t\n+RNAUOB(signed24 a, uint8_t s)\n {\n-  unsigned8 result;\n+  uint8_t result;\n   unsigned24 t;\n \n   if (s > 24)\n@@ -1190,10 +1190,10 @@ RNAUOB(signed24 a, unsigned8 s)\n   return result;\n }\n \n-static unsigned8\n-RNEUOB(signed24 a, unsigned8 s)\n+static uint8_t\n+RNEUOB(signed24 a, uint8_t s)\n {\n-  unsigned8 result;\n+  uint8_t result;\n   unsigned24 t;\n \n   if (s > 24)\n@@ -1215,10 +1215,10 @@ RNEUOB(signed24 a, unsigned8 s)\n   return result;\n }\n \n-static unsigned8\n-RZUOB(signed24 a, unsigned8 s)\n+static uint8_t\n+RZUOB(signed24 a, uint8_t s)\n {\n-  unsigned8 result;\n+  uint8_t result;\n   unsigned24 t;\n \n   if (s >= 24)\n@@ -1241,17 +1241,17 @@ static const OB_ROUND ob_round[] = {\n };\n \n \n-static unsigned64\n-qh_vector_round(sim_cpu *cpu, address_word cia, unsigned64 v2, QH_ROUND round)\n+static uint64_t\n+qh_vector_round(sim_cpu *cpu, address_word cia, uint64_t v2, QH_ROUND round)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  signed16 h, h2;\n+  int16_t h, h2;\n \n   s = 0;\n   for (i = 0; i < 4; i++)\n     {\n-      h2 = (signed16)(v2 & 0xFFFF);\n+      h2 = (int16_t)(v2 & 0xFFFF);\n       if (h2 >= 0)\n \th = (*round)(ACC.qh[i], h2);\n       else\n@@ -1260,18 +1260,18 @@ qh_vector_round(sim_cpu *cpu, address_word cia, unsigned64 v2, QH_ROUND round)\n \t  h = 0xdead;\n \t}\n       v2 >>= 16;\n-      result |= ((unsigned64)((unsigned16)h) << s);\n+      result |= ((uint64_t)((uint16_t)h) << s);\n       s += 16;\n     }\n   return result;\n }\n \n-static unsigned64\n-qh_map_round(sim_cpu *cpu, address_word cia, signed16 h2, QH_ROUND round)\n+static uint64_t\n+qh_map_round(sim_cpu *cpu, address_word cia, int16_t h2, QH_ROUND round)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  signed16  h;\n+  int16_t  h;\n \n   s = 0;\n   for (i = 0; i < 4; i++)\n@@ -1283,57 +1283,57 @@ qh_map_round(sim_cpu *cpu, address_word cia, signed16 h2, QH_ROUND round)\n \t  UnpredictableResult ();\n \t  h = 0xdead;\n \t}\n-      result |= ((unsigned64)((unsigned16)h) << s);\n+      result |= ((uint64_t)((uint16_t)h) << s);\n       s += 16;\n     }\n   return result;\n }\n \n-static unsigned64\n-ob_vector_round(sim_cpu *cpu, address_word cia, unsigned64 v2, OB_ROUND round)\n+static uint64_t\n+ob_vector_round(sim_cpu *cpu, address_word cia, uint64_t v2, OB_ROUND round)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned8 b, b2;\n+  uint8_t b, b2;\n \n   s = 0;\n   for (i = 0; i < 8; i++)\n     {\n       b2 = v2 & 0xFF;  v2 >>= 8;\n       b = (*round)(ACC.ob[i], b2);\n-      result |= ((unsigned64)b << s);\n+      result |= ((uint64_t)b << s);\n       s += 8;\n     }\n   return result;\n }\n \n-static unsigned64\n-ob_map_round(sim_cpu *cpu, address_word cia, unsigned8 b2, OB_ROUND round)\n+static uint64_t\n+ob_map_round(sim_cpu *cpu, address_word cia, uint8_t b2, OB_ROUND round)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n-  unsigned8 b;\n+  uint8_t b;\n \n   s = 0;\n   for (i = 0; i < 8; i++)\n     {\n       b = (*round)(ACC.ob[i], b2);\n-      result |= ((unsigned64)b << s);\n+      result |= ((uint64_t)b << s);\n       s += 8;\n     }\n   return result;\n }\n \n \n-unsigned64\n+uint64_t\n mdmx_round_op(sim_cpu *cpu,\n \t      address_word cia,\n \t      int rm,\n \t      int vt,\n \t      MX_fmtsel fmtsel)\n {\n-  unsigned64 op2;\n-  unsigned64 result = 0;\n+  uint64_t op2;\n+  uint64_t result = 0;\n \n   switch (MX_FMT (fmtsel))\n     {\n@@ -1409,14 +1409,14 @@ static const sh_map qh_shuffle[][4] = {\n };\n \n \n-unsigned64\n+uint64_t\n mdmx_shuffle(sim_cpu *cpu,\n \t     address_word cia,\n \t     int shop,\n-\t     unsigned64 op1,\n-\t     unsigned64 op2)\n+\t     uint64_t op1,\n+\t     uint64_t op2)\n {\n-  unsigned64 result = 0;\n+  uint64_t result = 0;\n   int  i, s;\n   int  op;\n \n@@ -1426,7 +1426,7 @@ mdmx_shuffle(sim_cpu *cpu,\n       s = 0;\n       for (i = 0; i < 4; i++)\n \t{\n-\t  unsigned64 v;\n+\t  uint64_t v;\n \n \t  switch (qh_shuffle[op][i].source)\n \t    {\n@@ -1450,7 +1450,7 @@ mdmx_shuffle(sim_cpu *cpu,\n       s = 0;\n       for (i = 0; i < 8; i++)\n \t{\n-\t  unsigned8 b;\n+\t  uint8_t b;\n \t  unsigned int ishift = 8*ob_shuffle[op][i].index;\n \n \t  switch (ob_shuffle[op][i].source)\n@@ -1468,7 +1468,7 @@ mdmx_shuffle(sim_cpu *cpu,\n \t      Unpredictable ();\n \t      b = 0;\n \t    }\n-\t  result |= ((unsigned64)b << s);\n+\t  result |= ((uint64_t)b << s);\n \t  s += 8;\n \t}\n     }"
    },
    {
      "sha": "0fd870c09f5694d7a0b2121c9b9c1731f4cea891",
      "filename": "sim/mips/mdmx.igen",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mdmx.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mdmx.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mdmx.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -188,7 +188,7 @@\n *mdmx:\n *sb1:\n {\n-  unsigned64 result;\n+  uint64_t result;\n   int s;\n   check_mdmx (SD_, instruction_0);\n   check_mdmx_fmtop (SD_, instruction_0, FMTOP);\n@@ -205,7 +205,7 @@\n *mdmx:\n *sb1:\n {\n-  unsigned64 result;\n+  uint64_t result;\n   int s;\n   check_mdmx (SD_, instruction_0);\n   check_mdmx_fmtop (SD_, instruction_0, FMTOP);"
    },
    {
      "sha": "acbff6f2db2114519b81350e37ee0484f61fc2ac",
      "filename": "sim/mips/micromips.igen",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/micromips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/micromips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/micromips.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -81,7 +81,7 @@\n }\n \n \n-:function:::unsigned32:compute_movep_src_reg:int reg\n+:function:::uint32_t:compute_movep_src_reg:int reg\n *micromips32:\n *micromips64:\n {\n@@ -99,7 +99,7 @@\n     }\n }\n \n-:function:::unsigned32:compute_andi16_imm:int encoded_imm\n+:function:::uint32_t:compute_andi16_imm:int encoded_imm\n *micromips32:\n *micromips64:\n {"
    },
    {
      "sha": "a68d25007b83c6d407c6643044d67ca1240a7e3b",
      "filename": "sim/mips/micromipsdsp.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/micromipsdsp.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/micromipsdsp.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/micromipsdsp.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -169,7 +169,7 @@\n \"bposge32 <IMMEDIATE>\"\n *micromipsdsp:\n {\n-  unsigned32 pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n+  uint32_t pos = (DSPCR >> DSPCR_POS_SHIFT) & DSPCR_POS_MASK;\n   if (pos >= 32)\n     NIA = delayslot_micromips (SD_, NIA + (EXTEND12 (IMMEDIATE) << 1), NIA,\n \t\t\t       MICROMIPS_DELAYSLOT_SIZE_ANY);"
    },
    {
      "sha": "c5db5c2304fabf63fe1393fd857351f5cbe14bf5",
      "filename": "sim/mips/mips.igen",
      "status": "modified",
      "additions": 156,
      "deletions": 156,
      "changes": 312,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mips.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -161,7 +161,7 @@\n      Programmers Volume III, Revision 0.95, section 4.9.  */\n   if ((SR & (status_KSU_mask|status_EXL|status_ERL|status_UX))\n       == (ksu_user << status_KSU_shift))\n-    return (address_word)((signed32)base + (signed32)offset);\n+    return (address_word)((int32_t)base + (int32_t)offset);\n #endif\n   return base + offset;\n }\n@@ -263,7 +263,7 @@\n // Helper used by check_mt_hilo, check_mult_hilo, and check_div_hilo\n // to check for restrictions (2) and (3) above.\n //\n-:function:::int:check_mf_cycles:hilo_history *history, signed64 time, const char *new\n+:function:::int:check_mf_cycles:hilo_history *history, int64_t time, const char *new\n {\n   if (history->mf.timestamp + 3 > time)\n     {\n@@ -289,7 +289,7 @@\n *vr4100:\n *vr5000:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = check_mf_cycles (SD_, history, time, \"MT\");\n   history->mt.timestamp = time;\n   history->mt.cia = CIA;\n@@ -300,7 +300,7 @@\n *mipsIV:\n *mipsV:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = (! MIPS_MACH_HAS_MT_HILO_HAZARD (SD)\n \t    || check_mf_cycles (SD_, history, time, \"MT\"));\n   history->mt.timestamp = time;\n@@ -317,7 +317,7 @@\n *micromips32:\n *micromips64:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   history->mt.timestamp = time;\n   history->mt.cia = CIA;\n   return 1;\n@@ -345,7 +345,7 @@\n *micromips32:\n *micromips64:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = 1;\n   if (peer != NULL\n       && peer->mt.timestamp > history->op.timestamp\n@@ -383,7 +383,7 @@\n *vr4100:\n *vr5000:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = (check_mf_cycles (SD_, hi, time, \"OP\")\n \t    && check_mf_cycles (SD_, lo, time, \"OP\"));\n   hi->op.timestamp = time;\n@@ -397,7 +397,7 @@\n *mipsIV:\n *mipsV:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = (! MIPS_MACH_HAS_MULT_HILO_HAZARD (SD)\n \t    || (check_mf_cycles (SD_, hi, time, \"OP\")\n \t        && check_mf_cycles (SD_, lo, time, \"OP\")));\n@@ -418,7 +418,7 @@\n *micromips64:\n {\n   /* FIXME: could record the fact that a stall occured if we want */\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   hi->op.timestamp = time;\n   lo->op.timestamp = time;\n   hi->op.cia = CIA;\n@@ -440,7 +440,7 @@\n *vr5000:\n *r3900:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = (check_mf_cycles (SD_, hi, time, \"OP\")\n \t    && check_mf_cycles (SD_, lo, time, \"OP\"));\n   hi->op.timestamp = time;\n@@ -454,7 +454,7 @@\n *mipsIV:\n *mipsV:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   int ok = (! MIPS_MACH_HAS_DIV_HILO_HAZARD (SD)\n \t    || (check_mf_cycles (SD_, hi, time, \"OP\")\n \t        && check_mf_cycles (SD_, lo, time, \"OP\")));\n@@ -473,7 +473,7 @@\n *micromips32:\n *micromips64:\n {\n-  signed64 time = sim_events_time (SD);\n+  int64_t time = sim_events_time (SD);\n   hi->op.timestamp = time;\n   lo->op.timestamp = time;\n   hi->op.cia = CIA;\n@@ -538,7 +538,7 @@\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n-:function:::void:do_addi:int rs, int rt, unsigned16 immediate\n+:function:::void:do_addi:int rs, int rt, uint16_t immediate\n {\n   if (NotWordValue (GPR[rs]))\n     Unpredictable ();\n@@ -592,15 +592,15 @@\n {\n   int s = 32 + shift;\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n-  GPR[rd] = ((signed64) GPR[rt]) >> s;\n+  GPR[rd] = ((int64_t) GPR[rt]) >> s;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n :function:::void:do_dsrl32:int rd, int rt, int shift\n {\n   int s = 32 + shift;\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n-  GPR[rd] = (unsigned64) GPR[rt] >> s;\n+  GPR[rd] = (uint64_t) GPR[rt] >> s;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n@@ -655,12 +655,12 @@\n \n :function:::void:do_clo:int rd, int rs\n {\n-  unsigned32 temp = GPR[rs];\n-  unsigned32 i, mask;\n+  uint32_t temp = GPR[rs];\n+  uint32_t i, mask;\n   if (NotWordValue (GPR[rs]))\n     Unpredictable ();\n   TRACE_ALU_INPUT1 (GPR[rs]);\n-  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)\n+  for (mask = ((uint32_t)1<<31), i = 0; i < 32; ++i)\n     {\n       if ((temp & mask) == 0)\n \tbreak;\n@@ -672,12 +672,12 @@\n \n :function:::void:do_clz:int rd, int rs\n {\n-  unsigned32 temp = GPR[rs];\n-  unsigned32 i, mask;\n+  uint32_t temp = GPR[rs];\n+  uint32_t i, mask;\n   if (NotWordValue (GPR[rs]))\n     Unpredictable ();\n   TRACE_ALU_INPUT1 (GPR[rs]);\n-  for (mask = ((unsigned32)1<<31), i = 0; i < 32; ++i)\n+  for (mask = ((uint32_t)1<<31), i = 0; i < 32; ++i)\n     {\n       if ((temp & mask) != 0)\n \tbreak;\n@@ -689,11 +689,11 @@\n \n :function:::void:do_dclo:int rd, int rs\n {\n-  unsigned64 temp = GPR[rs];\n-  unsigned32 i;\n-  unsigned64 mask;\n+  uint64_t temp = GPR[rs];\n+  uint32_t i;\n+  uint64_t mask;\n   TRACE_ALU_INPUT1 (GPR[rs]);\n-  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)\n+  for (mask = ((uint64_t)1<<63), i = 0; i < 64; ++i)\n     {\n       if ((temp & mask) == 0)\n \tbreak;\n@@ -705,11 +705,11 @@\n \n :function:::void:do_dclz:int rd, int rs\n {\n-  unsigned64 temp = GPR[rs];\n-  unsigned32 i;\n-  unsigned64 mask;\n+  uint64_t temp = GPR[rs];\n+  uint32_t i;\n+  uint64_t mask;\n   TRACE_ALU_INPUT1 (GPR[rs]);\n-  for (mask = ((unsigned64)1<<63), i = 0; i < 64; ++i)\n+  for (mask = ((uint64_t)1<<63), i = 0; i < 64; ++i)\n     {\n       if ((temp & mask) != 0)\n \tbreak;\n@@ -791,9 +791,9 @@\n \t}\n       else\n \t{\n-\t  unsigned64 memval = 0;\n-\t  unsigned64 memval1 = 0;\n-\t  unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n+\t  uint64_t memval = 0;\n+\t  uint64_t memval1 = 0;\n+\t  uint64_t mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n \t  unsigned int shift = 2;\n \t  unsigned int reverse = (ReverseEndian ? (mask >> shift) : 0);\n \t  unsigned int bigend = (BigEndianCPU ? (mask >> shift) : 0);\n@@ -823,8 +823,8 @@\n       }\n     else\n       {\n-\tunsigned64 memval = 0;\n-\tunsigned64 memval1 = 0;\n+\tuint64_t memval = 0;\n+\tuint64_t memval1 = 0;\n \tLoadMemory (&memval, &memval1, AccessLength_DOUBLEWORD, paddr, vaddr,\n \t\t    isDATA, isREAL);\n \tGPR[rt] = memval;\n@@ -842,28 +842,28 @@\n \n :function:::void:do_madd:int rs, int rt\n {\n-  signed64 temp;\n+  int64_t temp;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t  + ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));\n+\t  + ((int64_t) EXTEND32 (GPR[rt]) * (int64_t) EXTEND32 (GPR[rs])));\n   LO = EXTEND32 (temp);\n   HI = EXTEND32 (VH4_8 (temp));\n   TRACE_ALU_RESULT2 (HI, LO);\n }\n \n :function:::void:do_dsp_madd:int ac, int rs, int rt\n {\n-  signed64 temp;\n+  int64_t temp;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))\n-\t  + ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));\n+\t  + ((int64_t) EXTEND32 (GPR[rt]) * (int64_t) EXTEND32 (GPR[rs])));\n   DSPLO(ac) = EXTEND32 (temp);\n   DSPHI(ac) = EXTEND32 (VH4_8 (temp));\n   if (ac == 0)\n@@ -872,13 +872,13 @@\n \n :function:::void:do_maddu:int rs, int rt\n {\n-  unsigned64 temp;\n+  uint64_t temp;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t  + ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));\n+\t  + ((uint64_t) VL4_8 (GPR[rs]) * (uint64_t) VL4_8 (GPR[rt])));\n   ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */\n   LO = EXTEND32 (temp);\n   HI = EXTEND32 (VH4_8 (temp));\n@@ -887,14 +887,14 @@\n \n :function:::void:do_dsp_maddu:int ac, int rs, int rt\n {\n-  unsigned64 temp;\n+  uint64_t temp;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))\n-\t  + ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));\n+\t  + ((uint64_t) VL4_8 (GPR[rs]) * (uint64_t) VL4_8 (GPR[rt])));\n   if (ac == 0)\n     ACX += U8_4 (VL4_8 (HI), VL4_8 (LO)) < temp;  /* SmartMIPS */\n   DSPLO(ac) = EXTEND32 (temp);\n@@ -939,28 +939,28 @@\n \n :function:::void:do_msub:int rs, int rt\n {\n-  signed64 temp;\n+  int64_t temp;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t  - ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));\n+\t  - ((int64_t) EXTEND32 (GPR[rt]) * (int64_t) EXTEND32 (GPR[rs])));\n   LO = EXTEND32 (temp);\n   HI = EXTEND32 (VH4_8 (temp));\n   TRACE_ALU_RESULT2 (HI, LO);\n }\n \n :function:::void:do_dsp_msub:int ac, int rs, int rt\n {\n-  signed64 temp;\n+  int64_t temp;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))\n-\t  - ((signed64) EXTEND32 (GPR[rt]) * (signed64) EXTEND32 (GPR[rs])));\n+\t  - ((int64_t) EXTEND32 (GPR[rt]) * (int64_t) EXTEND32 (GPR[rs])));\n   DSPLO(ac) = EXTEND32 (temp);\n   DSPHI(ac) = EXTEND32 (VH4_8 (temp));\n   if (ac == 0)\n@@ -969,28 +969,28 @@\n \n :function:::void:do_msubu:int rs, int rt\n {\n-  unsigned64 temp;\n+  uint64_t temp;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t  - ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));\n+\t  - ((uint64_t) VL4_8 (GPR[rs]) * (uint64_t) VL4_8 (GPR[rt])));\n   LO = EXTEND32 (temp);\n   HI = EXTEND32 (VH4_8 (temp));\n   TRACE_ALU_RESULT2 (HI, LO);\n }\n \n :function:::void:do_dsp_msubu:int ac, int rs, int rt\n {\n-  unsigned64 temp;\n+  uint64_t temp;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   temp = (U8_4 (VL4_8 (DSPHI(ac)), VL4_8 (DSPLO(ac)))\n-\t  - ((unsigned64) VL4_8 (GPR[rs]) * (unsigned64) VL4_8 (GPR[rt])));\n+\t  - ((uint64_t) VL4_8 (GPR[rs]) * (uint64_t) VL4_8 (GPR[rt])));\n   DSPLO(ac) = EXTEND32 (temp);\n   DSPHI(ac) = EXTEND32 (VH4_8 (temp));\n   if (ac == 0)\n@@ -1025,26 +1025,26 @@\n \n :function:::void:do_mul:int rd, int rs, int rt\n {\n-  signed64 prod;\n+  int64_t prod;\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n-  prod = (((signed64)(signed32) GPR[rs])\n-\t  * ((signed64)(signed32) GPR[rt]));\n+  prod = (((int64_t)(int32_t) GPR[rs])\n+\t  * ((int64_t)(int32_t) GPR[rt]));\n   GPR[rd] = EXTEND32 (VL4_8 (prod));\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n :function:::void:do_dsp_mult:int ac, int rs, int rt\n {\n-  signed64 prod;\n+  int64_t prod;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n-  prod = ((signed64)(signed32) GPR[rs])\n-\t  * ((signed64)(signed32) GPR[rt]);\n+  prod = ((int64_t)(int32_t) GPR[rs])\n+\t  * ((int64_t)(int32_t) GPR[rt]);\n   DSPLO(ac) = EXTEND32 (VL4_8 (prod));\n   DSPHI(ac) = EXTEND32 (VH4_8 (prod));\n   if (ac == 0)\n@@ -1056,14 +1056,14 @@\n \n :function:::void:do_dsp_multu:int ac, int rs, int rt\n {\n-  unsigned64 prod;\n+  uint64_t prod;\n   if (ac == 0)\n     check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n-  prod = ((unsigned64)(unsigned32) GPR[rs])\n-          * ((unsigned64)(unsigned32) GPR[rt]);\n+  prod = ((uint64_t)(uint32_t) GPR[rs])\n+          * ((uint64_t)(uint32_t) GPR[rt]);\n   DSPLO(ac) = EXTEND32 (VL4_8 (prod));\n   DSPHI(ac) = EXTEND32 (VH4_8 (prod));\n   if (ac == 0)\n@@ -1083,7 +1083,7 @@\n \n :function:::void:do_sc:int rt, int offsetarg, int basereg, address_word instruction_0\n {\n-  unsigned32 instruction = instruction_0;\n+  uint32_t instruction = instruction_0;\n   address_word base = GPR[basereg];\n   address_word offset = EXTEND16 (offsetarg);\n   {\n@@ -1097,17 +1097,17 @@\n       }\n     else\n       {\n-\tunsigned64 memval = 0;\n-\tunsigned64 memval1 = 0;\n-\tunsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n+\tuint64_t memval = 0;\n+\tuint64_t memval1 = 0;\n+\tuint64_t mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n \taddress_word reverseendian =\n \t  (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);\n \taddress_word bigendiancpu =\n \t  (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);\n \tunsigned int byte;\n \tpaddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));\n \tbyte = ((vaddr & mask) ^ bigendiancpu);\n-\tmemval = ((unsigned64) GPR[rt] << (8 * byte));\n+\tmemval = ((uint64_t) GPR[rt] << (8 * byte));\n \tif (LLBIT)\n \t  StoreMemory (AccessLength_WORD, memval, memval1, paddr, vaddr,\n \t\t        isREAL);\n@@ -1131,8 +1131,8 @@\n       }\n     else\n       {\n-\tunsigned64 memval = 0;\n-\tunsigned64 memval1 = 0;\n+\tuint64_t memval = 0;\n+\tuint64_t memval1 = 0;\n \tmemval = GPR[rt];\n \tif (LLBIT)\n \t  StoreMemory (AccessLength_DOUBLEWORD, memval, memval1, paddr, vaddr,\n@@ -1248,9 +1248,9 @@\n \n :function:::void:do_alnv_ps:int fd, int fs, int ft, int rs, address_word instruction_0\n {\n-  unsigned64 fsx;\n-  unsigned64 ftx;\n-  unsigned64 fdx;\n+  uint64_t fsx;\n+  uint64_t ftx;\n+  uint64_t fdx;\n   check_fpu (SD_);\n   check_u64 (SD_, instruction_0);\n   fsx = ValueFPR (fs, fmt_ps);\n@@ -1493,7 +1493,7 @@\n   }\n   else\n   {\n-    unsigned64 fdx;\n+    uint64_t fdx;\n     fdx = PackPS (PSUpper (ValueFPR ((GETFCC (cc+1) == tf) ? fs : fd,\n \t\t\t\t      fmt_ps)),\n                   PSLower (ValueFPR ((GETFCC (cc+0) == tf) ? fs : fd,\n@@ -1730,17 +1730,17 @@\n \t}\n       else\n \t{\n-\t  unsigned64 memval = 0;\n-\t  unsigned64 memval1 = 0;\n-\t  unsigned64 mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n+\t  uint64_t memval = 0;\n+\t  uint64_t memval1 = 0;\n+\t  uint64_t mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);\n \t  address_word reverseendian =\n \t    (ReverseEndian ? (mask ^ AccessLength_WORD) : 0);\n \t  address_word bigendiancpu =\n \t    (BigEndianCPU ? (mask ^ AccessLength_WORD) : 0);\n \t  unsigned int byte;\n \t  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));\n \t  byte = ((vaddr & mask) ^ bigendiancpu);\n-\t  memval = (((unsigned64)COP_SW(1,fs)) << (8 * byte));\n+\t  memval = (((uint64_t)COP_SW(1,fs)) << (8 * byte));\n \t  StoreMemory (AccessLength_WORD, memval, memval1, paddr, vaddr,\n \t\t       isREAL);\n \t}\n@@ -1794,7 +1794,7 @@\n \n \n \n-:function:::void:do_addiu:int rs, int rt, unsigned16 immediate\n+:function:::void:do_addiu:int rs, int rt, uint16_t immediate\n {\n   if (NotWordValue (GPR[rs]))\n     Unpredictable ();\n@@ -2395,7 +2395,7 @@\n \n \n \n-:function:::void:do_daddiu:int rs, int rt, unsigned16 immediate\n+:function:::void:do_daddiu:int rs, int rt, uint16_t immediate\n {\n   TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));\n   GPR[rt] = GPR[rs] + EXTEND16 (immediate);\n@@ -2474,10 +2474,10 @@\n   check_div_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   {\n-    signed64 n = GPR[rs];\n-    signed64 d = GPR[rt];\n-    signed64 hi;\n-    signed64 lo;\n+    int64_t n = GPR[rs];\n+    int64_t d = GPR[rt];\n+    int64_t hi;\n+    int64_t lo;\n     if (d == 0)\n       {\n \tlo = SIGNED64 (0x8000000000000000);\n@@ -2520,10 +2520,10 @@\n   check_div_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   {\n-    unsigned64 n = GPR[rs];\n-    unsigned64 d = GPR[rt];\n-    unsigned64 hi;\n-    unsigned64 lo;\n+    uint64_t n = GPR[rs];\n+    uint64_t d = GPR[rt];\n+    uint64_t hi;\n+    uint64_t lo;\n     if (d == 0)\n       {\n \tlo = SIGNED64 (0x8000000000000000);\n@@ -2559,8 +2559,8 @@\n   check_div_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   {\n-    signed32 n = GPR[rs];\n-    signed32 d = GPR[rt];\n+    int32_t n = GPR[rs];\n+    int32_t d = GPR[rt];\n     if (d == 0)\n       {\n \tLO = EXTEND32 (0x80000000);\n@@ -2605,8 +2605,8 @@\n   check_div_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   {\n-    unsigned32 n = GPR[rs];\n-    unsigned32 d = GPR[rt];\n+    uint32_t n = GPR[rs];\n+    uint32_t d = GPR[rt];\n     if (d == 0)\n       {\n \tLO = EXTEND32 (0x80000000);\n@@ -2642,47 +2642,47 @@\n \n :function:::void:do_dmultx:int rs, int rt, int rd, int signed_p\n {\n-  unsigned64 lo;\n-  unsigned64 hi;\n-  unsigned64 m00;\n-  unsigned64 m01;\n-  unsigned64 m10;\n-  unsigned64 m11;\n-  unsigned64 mid;\n+  uint64_t lo;\n+  uint64_t hi;\n+  uint64_t m00;\n+  uint64_t m01;\n+  uint64_t m10;\n+  uint64_t m11;\n+  uint64_t mid;\n   int sign;\n-  unsigned64 op1 = GPR[rs];\n-  unsigned64 op2 = GPR[rt];\n+  uint64_t op1 = GPR[rs];\n+  uint64_t op2 = GPR[rt];\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n   /* make signed multiply unsigned */\n   sign = 0;\n   if (signed_p)\n     {\n-      if ((signed64) op1 < 0)\n+      if ((int64_t) op1 < 0)\n \t{\n \t  op1 = - op1;\n \t  ++sign;\n \t}\n-      if ((signed64) op2 < 0)\n+      if ((int64_t) op2 < 0)\n \t{\n \t  op2 = - op2;\n \t  ++sign;\n \t}\n     }\n   /* multiply out the 4 sub products */\n-  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));\n-  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));\n-  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));\n-  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));\n+  m00 = ((uint64_t) VL4_8 (op1) * (uint64_t) VL4_8 (op2));\n+  m10 = ((uint64_t) VH4_8 (op1) * (uint64_t) VL4_8 (op2));\n+  m01 = ((uint64_t) VL4_8 (op1) * (uint64_t) VH4_8 (op2));\n+  m11 = ((uint64_t) VH4_8 (op1) * (uint64_t) VH4_8 (op2));\n   /* add the products */\n-  mid = ((unsigned64) VH4_8 (m00)\n-\t + (unsigned64) VL4_8 (m10)\n-\t + (unsigned64) VL4_8 (m01));\n+  mid = ((uint64_t) VH4_8 (m00)\n+\t + (uint64_t) VL4_8 (m10)\n+\t + (uint64_t) VL4_8 (m01));\n   lo = U8_4 (mid, m00);\n   hi = (m11\n-\t+ (unsigned64) VH4_8 (mid)\n-\t+ (unsigned64) VH4_8 (m01)\n-\t+ (unsigned64) VH4_8 (m10));\n+\t+ (uint64_t) VH4_8 (mid)\n+\t+ (uint64_t) VH4_8 (m01)\n+\t+ (uint64_t) VH4_8 (m10));\n   /* fix the sign */\n   if (sign & 1)\n     {\n@@ -2757,9 +2757,9 @@\n }\n \n \n-:function:::unsigned64:do_dror:unsigned64 x,unsigned64 y\n+:function:::uint64_t:do_dror:uint64_t x,uint64_t y\n {\n-  unsigned64 result;\n+  uint64_t result;\n \n   y &= 63;\n   TRACE_ALU_INPUT2 (x, y);\n@@ -2860,7 +2860,7 @@\n :function:::void:do_dsra:int rt, int rd, int shift\n {\n   TRACE_ALU_INPUT2 (GPR[rt], shift);\n-  GPR[rd] = ((signed64) GPR[rt]) >> shift;\n+  GPR[rd] = ((int64_t) GPR[rt]) >> shift;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n@@ -2899,7 +2899,7 @@\n {\n   int s = MASKED64 (GPR[rs], 5, 0);\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n-  GPR[rd] = ((signed64) GPR[rt]) >> s;\n+  GPR[rd] = ((int64_t) GPR[rt]) >> s;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n@@ -2920,7 +2920,7 @@\n :function:::void:do_dsrl:int rt, int rd, int shift\n {\n   TRACE_ALU_INPUT2 (GPR[rt], shift);\n-  GPR[rd] = (unsigned64) GPR[rt] >> shift;\n+  GPR[rd] = (uint64_t) GPR[rt] >> shift;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n@@ -2959,7 +2959,7 @@\n {\n   int s = MASKED64 (GPR[rs], 5, 0);\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n-  GPR[rd] = (unsigned64) GPR[rt] >> s;\n+  GPR[rd] = (uint64_t) GPR[rt] >> s;\n   TRACE_ALU_RESULT (GPR[rd]);\n }\n \n@@ -3126,7 +3126,7 @@\n   address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);\n   unsigned int byte;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n@@ -3148,7 +3148,7 @@\n   unsigned int byte;\n   unsigned int word;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n   int nr_lhs_bits;\n   int nr_rhs_bits;\n@@ -3168,8 +3168,8 @@\n   /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */\n \n   /* fprintf (stderr, \"l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\\n\",\n-\t   (long) ((unsigned64) vaddr >> 32), (long) vaddr,\n-\t   (long) ((unsigned64) paddr >> 32), (long) paddr,\n+\t   (long) ((uint64_t) vaddr >> 32), (long) vaddr,\n+\t   (long) ((uint64_t) paddr >> 32), (long) paddr,\n \t   word, byte, nr_lhs_bits, nr_rhs_bits); */\n \n   LoadMemory (&memval, NULL, byte, paddr, vaddr, isDATA, isREAL);\n@@ -3187,9 +3187,9 @@\n   rt = (rt & ~lhs_mask) | (temp & lhs_mask);\n \n   /* fprintf (stderr, \"l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\\n\",\n-\t   (long) ((unsigned64) memval >> 32), (long) memval,\n-\t   (long) ((unsigned64) temp >> 32), (long) temp,\n-\t   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,\n+\t   (long) ((uint64_t) memval >> 32), (long) memval,\n+\t   (long) ((uint64_t) temp >> 32), (long) temp,\n+\t   (long) ((uint64_t) lhs_mask >> 32), (long) lhs_mask,\n \t   (long) (rt >> 32), (long) rt); */\n   return rt;\n }\n@@ -3201,7 +3201,7 @@\n   address_word bigendiancpu = (BigEndianCPU ? -1 : 0);\n   unsigned int byte;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n@@ -3763,13 +3763,13 @@\n \n :function:::void:do_mult:int rs, int rt, int rd\n {\n-  signed64 prod;\n+  int64_t prod;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n-  prod = (((signed64)(signed32) GPR[rs])\n-\t  * ((signed64)(signed32) GPR[rt]));\n+  prod = (((int64_t)(int32_t) GPR[rs])\n+\t  * ((int64_t)(int32_t) GPR[rt]));\n   LO = EXTEND32 (VL4_8 (prod));\n   HI = EXTEND32 (VH4_8 (prod));\n   ACX = 0;  /* SmartMIPS */\n@@ -3816,13 +3816,13 @@\n \n :function:::void:do_multu:int rs, int rt, int rd\n {\n-  unsigned64 prod;\n+  uint64_t prod;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);\n-  prod = (((unsigned64)(unsigned32) GPR[rs])\n-\t  * ((unsigned64)(unsigned32) GPR[rt]));\n+  prod = (((uint64_t)(uint32_t) GPR[rs])\n+\t  * ((uint64_t)(uint32_t) GPR[rt]));\n   LO = EXTEND32 (VL4_8 (prod));\n   HI = EXTEND32 (VH4_8 (prod));\n   if (rd != 0)\n@@ -3959,9 +3959,9 @@\n }\n \n \n-:function:::unsigned64:do_ror:unsigned32 x,unsigned32 y\n+:function:::uint64_t:do_ror:uint32_t x,uint32_t y\n {\n-  unsigned64 result;\n+  uint64_t result;\n \n   y &= 31;\n   TRACE_ALU_INPUT2 (x, y);\n@@ -4000,7 +4000,7 @@\n   address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);\n   unsigned int byte;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n@@ -4022,7 +4022,7 @@\n   unsigned int byte;\n   unsigned int word;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n   int nr_lhs_bits;\n   int nr_rhs_bits;\n@@ -4039,8 +4039,8 @@\n   nr_rhs_bits = 8 * access - 8 * byte;\n   /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */\n   /* fprintf (stderr, \"s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\\n\",\n-\t   (long) ((unsigned64) vaddr >> 32), (long) vaddr,\n-\t   (long) ((unsigned64) paddr >> 32), (long) paddr,\n+\t   (long) ((uint64_t) vaddr >> 32), (long) vaddr,\n+\t   (long) ((uint64_t) paddr >> 32), (long) paddr,\n \t   word, byte, nr_lhs_bits, nr_rhs_bits); */\n \n   if (word == 0)\n@@ -4052,8 +4052,8 @@\n       memval = (rt << nr_lhs_bits);\n     }\n   /* fprintf (stderr, \"s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\\n\",\n-\t   (long) ((unsigned64) rt >> 32), (long) rt,\n-\t   (long) ((unsigned64) memval >> 32), (long) memval); */\n+\t   (long) ((uint64_t) rt >> 32), (long) rt,\n+\t   (long) ((uint64_t) memval >> 32), (long) memval); */\n   StoreMemory (byte, memval, 0, paddr, vaddr, isREAL);\n }\n \n@@ -4064,7 +4064,7 @@\n   address_word bigendiancpu = (BigEndianCPU ? -1 : 0);\n   unsigned int byte;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n   address_word vaddr;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n@@ -4212,7 +4212,7 @@\n \n :function:::void:do_sll:int rt, int rd, int shift\n {\n-  unsigned32 temp = (GPR[rt] << shift);\n+  uint32_t temp = (GPR[rt] << shift);\n   TRACE_ALU_INPUT2 (GPR[rt], shift);\n   GPR[rd] = EXTEND32 (temp);\n   TRACE_ALU_RESULT (GPR[rd]);\n@@ -4255,7 +4255,7 @@\n :function:::void:do_sllv:int rs, int rt, int rd\n {\n   int s = MASKED (GPR[rs], 4, 0);\n-  unsigned32 temp = (GPR[rt] << s);\n+  uint32_t temp = (GPR[rt] << s);\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n   GPR[rd] = EXTEND32 (temp);\n   TRACE_ALU_RESULT (GPR[rd]);\n@@ -4306,7 +4306,7 @@\n }\n \n \n-:function:::void:do_slti:int rs, int rt, unsigned16 immediate\n+:function:::void:do_slti:int rs, int rt, uint16_t immediate\n {\n   TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));\n   GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));\n@@ -4332,7 +4332,7 @@\n }\n \n \n-:function:::void:do_sltiu:int rs, int rt, unsigned16 immediate\n+:function:::void:do_sltiu:int rs, int rt, uint16_t immediate\n {\n   TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));\n   GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));\n@@ -4387,7 +4387,7 @@\n \n :function:::void:do_sra:int rt, int rd, int shift\n {\n-  signed32 temp = (signed32) GPR[rt] >> shift;\n+  int32_t temp = (int32_t) GPR[rt] >> shift;\n   if (NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rt], shift);\n@@ -4418,7 +4418,7 @@\n :function:::void:do_srav:int rs, int rt, int rd\n {\n   int s = MASKED (GPR[rs], 4, 0);\n-  signed32 temp = (signed32) GPR[rt] >> s;\n+  int32_t temp = (int32_t) GPR[rt] >> s;\n   if (NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n@@ -4448,7 +4448,7 @@\n \n :function:::void:do_srl:int rt, int rd, int shift\n {\n-  unsigned32 temp = (unsigned32) GPR[rt] >> shift;\n+  uint32_t temp = (uint32_t) GPR[rt] >> shift;\n   if (NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rt], shift);\n@@ -4478,7 +4478,7 @@\n :function:::void:do_srlv:int rs, int rt, int rd\n {\n   int s = MASKED (GPR[rs], 4, 0);\n-  unsigned32 temp = (unsigned32) GPR[rt] >> s;\n+  uint32_t temp = (uint32_t) GPR[rt] >> s;\n   if (NotWordValue (GPR[rt]))\n     Unpredictable ();\n   TRACE_ALU_INPUT2 (GPR[rt], s);\n@@ -4896,7 +4896,7 @@\n }\n \n \n-:function:::void:do_xori:int rs, int rt, unsigned16 immediate\n+:function:::void:do_xori:int rs, int rt, uint16_t immediate\n {\n   TRACE_ALU_INPUT2 (GPR[rs], immediate);\n   GPR[rt] = GPR[rs] ^ immediate;\n@@ -5060,7 +5060,7 @@\n // unsigned_word, which is limited to the size of the machine's registers.\n //\n \n-:function:::unsigned64:do_load_double:address_word base, address_word offset\n+:function:::uint64_t:do_load_double:address_word base, address_word offset\n *mipsII:\n *mips32:\n *mips32r2:\n@@ -5069,8 +5069,8 @@\n   int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);\n   address_word vaddr;\n   address_word paddr;\n-  unsigned64 memval;\n-  unsigned64 v;\n+  uint64_t memval;\n+  uint64_t v;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n   if ((vaddr & AccessLength_DOUBLEWORD) != 0)\n@@ -5080,7 +5080,7 @@\n \t\t       sim_core_unaligned_signal);\n     }\n   LoadMemory (&memval, NULL, AccessLength_WORD, paddr, vaddr, isDATA, isREAL);\n-  v = (unsigned64)memval;\n+  v = (uint64_t)memval;\n   LoadMemory (&memval, NULL, AccessLength_WORD, paddr + 4, vaddr + 4, isDATA,\n \t      isREAL);\n   return (bigendian ? ((v << 32) | memval) : (v | (memval << 32)));\n@@ -5094,7 +5094,7 @@\n // unsigned_word, which is limited to the size of the machine's registers.\n //\n \n-:function:::void:do_store_double:address_word base, address_word offset, unsigned64 v\n+:function:::void:do_store_double:address_word base, address_word offset, uint64_t v\n *mipsII:\n *mips32:\n *mips32r2:\n@@ -5103,7 +5103,7 @@\n   int bigendian = (BigEndianCPU ? ! ReverseEndian : ReverseEndian);\n   address_word vaddr;\n   address_word paddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n \n   paddr = vaddr = loadstore_ea (SD_, base, offset);\n   if ((vaddr & AccessLength_DOUBLEWORD) != 0)\n@@ -5504,7 +5504,7 @@\n \"dmfc1 r<RT>, f<FS>\"\n *mipsIII:\n {\n-  unsigned64 v;\n+  uint64_t v;\n   check_fpu (SD_);\n   check_u64 (SD_, instruction_0);\n   if (SizeFGR () == 64)\n@@ -5537,7 +5537,7 @@\n \"dmtc1 r<RT>, f<FS>\"\n *mipsIII:\n {\n-  unsigned64 v;\n+  uint64_t v;\n   check_fpu (SD_);\n   check_u64 (SD_, instruction_0);\n   if (SizeFGR () == 64)\n@@ -5724,7 +5724,7 @@\n *mipsII:\n *mipsIII:\n {\n-  unsigned64 v;\n+  uint64_t v;\n   check_fpu (SD_);\n   v = EXTEND32 (FGR[FS]);\n   PENDING_FILL (RT, v);"
    },
    {
      "sha": "e0b838c4df234a128fa3bc6008e5e30876d07c3c",
      "filename": "sim/mips/mips3264r2.igen",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mips3264r2.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/mips3264r2.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mips3264r2.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -21,7 +21,7 @@\n \n :function:::void:do_dsbh:int rd, int rt\n {\n-  union { unsigned64 d; unsigned16 h[4]; } u;\n+  union { uint64_t d; uint16_t h[4]; } u;\n   TRACE_ALU_INPUT1 (GPR[rt]);\n   u.d = GPR[rt];\n   u.h[0] = SWAP_2 (u.h[0]);\n@@ -34,7 +34,7 @@\n \n :function:::void:do_dshd:int rd, int rt\n {\n-  unsigned64 d;\n+  uint64_t d;\n   TRACE_ALU_INPUT1 (GPR[rt]);\n   d = GPR[rt];\n   GPR[rd] = ((d >> 48)\n@@ -181,7 +181,7 @@\n \n :function:::void:do_wsbh:int rd, int rt\n {\n-  union { unsigned32 w; unsigned16 h[2]; } u;\n+  union { uint32_t w; uint16_t h[2]; } u;\n   TRACE_ALU_INPUT1 (GPR[rt]);\n   u.w = GPR[rt];\n   u.h[0] = SWAP_2 (u.h[0]);"
    },
    {
      "sha": "250310eceb37c45a42ca28ec7518b0c7b738962a",
      "filename": "sim/mips/sim-main.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/sim-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/sim-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/sim-main.c?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -254,7 +254,7 @@ store_memory (SIM_DESC SD,\n }\n \n \n-INLINE_SIM_MAIN (unsigned32)\n+INLINE_SIM_MAIN (uint32_t)\n ifetch32 (SIM_DESC SD,\n \t  sim_cpu *CPU,\n \t  address_word cia,\n@@ -267,7 +267,7 @@ ifetch32 (SIM_DESC SD,\n   address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);\n   unsigned int byte;\n   address_word paddr = vaddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n \n   if ((vaddr & access) != 0)\n     SignalExceptionInstructionFetch ();\n@@ -278,7 +278,7 @@ ifetch32 (SIM_DESC SD,\n }\n \n \n-INLINE_SIM_MAIN (unsigned16)\n+INLINE_SIM_MAIN (uint16_t)\n ifetch16 (SIM_DESC SD,\n \t  sim_cpu *CPU,\n \t  address_word cia,\n@@ -291,7 +291,7 @@ ifetch16 (SIM_DESC SD,\n   address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);\n   unsigned int byte;\n   address_word paddr = vaddr;\n-  unsigned64 memval;\n+  uint64_t memval;\n \n   if ((vaddr & access) != 0)\n     SignalExceptionInstructionFetch ();\n@@ -433,30 +433,30 @@ pending_tick (SIM_DESC SD,\n \t\t      {\n \t\t      case 4:\n \t\t\tif (PENDING_SLOT_VALUE[index])\n-\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] |=\n+\t\t\t  *(uint32_t*)PENDING_SLOT_DEST[index] |=\n \t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\n \t\t\telse\n-\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] &=\n+\t\t\t  *(uint32_t*)PENDING_SLOT_DEST[index] &=\n \t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\n \t\t\tbreak;\n \t\t      case 8:\n \t\t\tif (PENDING_SLOT_VALUE[index])\n-\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] |=\n+\t\t\t  *(uint64_t*)PENDING_SLOT_DEST[index] |=\n \t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\n \t\t\telse\n-\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] &=\n+\t\t\t  *(uint64_t*)PENDING_SLOT_DEST[index] &=\n \t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\n \t\t\tbreak;\n \t\t      }\n \t\t  else\n \t\t    switch (PENDING_SLOT_SIZE[index])\n \t\t      {\n \t\t      case 4:\n-\t\t\t*(unsigned32*)PENDING_SLOT_DEST[index] =\n+\t\t\t*(uint32_t*)PENDING_SLOT_DEST[index] =\n \t\t\t  PENDING_SLOT_VALUE[index];\n \t\t\tbreak;\n \t\t      case 8:\n-\t\t\t*(unsigned64*)PENDING_SLOT_DEST[index] =\n+\t\t\t*(uint64_t*)PENDING_SLOT_DEST[index] =\n \t\t\t  PENDING_SLOT_VALUE[index];\n \t\t\tbreak;\n \t\t      }"
    },
    {
      "sha": "d724688a4348c93d0d767286bf4395d95b1961bb",
      "filename": "sim/mips/sim-main.h",
      "status": "modified",
      "additions": 49,
      "deletions": 49,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/sim-main.h?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -33,8 +33,8 @@ mips_core_signal ((SD), (CPU), (CIA), (MAP), (NR_BYTES), (ADDR), (TRANSFER), (ER\n /* Deprecated macros and types for manipulating 64bit values.  Use\n    ../common/sim-bits.h and ../common/sim-endian.h macros instead. */\n \n-typedef signed64 word64;\n-typedef unsigned64 uword64;\n+typedef int64_t word64;\n+typedef uint64_t uword64;\n \n #define WORD64LO(t)     (unsigned int)((t)&0xFFFFFFFF)\n #define WORD64HI(t)     (unsigned int)(((uword64)(t))>>32)\n@@ -115,7 +115,7 @@ typedef enum {\n    more details. */\n \n typedef struct _hilo_access {\n-  signed64 timestamp;\n+  int64_t timestamp;\n   address_word cia;\n } hilo_access;\n \n@@ -135,7 +135,7 @@ typedef struct _hilo_history {\n #define ALU32_END(ANS) \\\n   if (ALU32_HAD_OVERFLOW) \\\n     SignalExceptionIntegerOverflow (); \\\n-  (ANS) = (signed32) ALU32_OVERFLOW_RESULT\n+  (ANS) = (int32_t) ALU32_OVERFLOW_RESULT\n \n \n #define ALU64_END(ANS) \\\n@@ -163,7 +163,7 @@ typedef struct _pending_write_queue {\n   int slot_size[PSLOTS];\n   int slot_bit[PSLOTS];\n   void *slot_dest[PSLOTS];\n-  unsigned64 slot_value[PSLOTS];\n+  uint64_t slot_value[PSLOTS];\n } pending_write_queue;\n \n #ifndef PENDING_TRACE\n@@ -243,8 +243,8 @@ enum float_operation\n    32 or 64 bits.  Since the accumulators are 2's complement with\n    overflow suppressed, high-order bits can be ignored in most contexts.  */\n \n-typedef signed32 signed24;\n-typedef signed64 signed48;\n+typedef int32_t signed24;\n+typedef int64_t signed48;\n \n typedef union {\n   signed24  ob[8];\n@@ -700,15 +700,15 @@ int sim_monitor (SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int arg);\n \n \n /* FPR access.  */\n-unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);\n+uint64_t value_fpr (SIM_STATE, int fpr, FP_formats);\n #define ValueFPR(FPR,FMT) value_fpr (SIM_ARGS, (FPR), (FMT))\n-void store_fpr (SIM_STATE, int fpr, FP_formats fmt, unsigned64 value);\n+void store_fpr (SIM_STATE, int fpr, FP_formats fmt, uint64_t value);\n #define StoreFPR(FPR,FMT,VALUE) store_fpr (SIM_ARGS, (FPR), (FMT), (VALUE))\n-unsigned64 ps_lower (SIM_STATE, unsigned64 op);\n+uint64_t ps_lower (SIM_STATE, uint64_t op);\n #define PSLower(op) ps_lower (SIM_ARGS, op)\n-unsigned64 ps_upper (SIM_STATE, unsigned64 op);\n+uint64_t ps_upper (SIM_STATE, uint64_t op);\n #define PSUpper(op) ps_upper (SIM_ARGS, op)\n-unsigned64 pack_ps (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats from);\n+uint64_t pack_ps (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats from);\n #define PackPS(op1,op2) pack_ps (SIM_ARGS, op1, op2, fmt_single)\n \n \n@@ -722,59 +722,59 @@ void test_fcsr (SIM_STATE);\n \n \n /* FPU operations.  */\n-void fp_cmp (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt, int abs, int cond, int cc);\n+void fp_cmp (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt, int abs, int cond, int cc);\n #define Compare(op1,op2,fmt,cond,cc) fp_cmp(SIM_ARGS, op1, op2, fmt, 0, cond, cc)\n-unsigned64 fp_abs (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_abs (SIM_STATE, uint64_t op, FP_formats fmt);\n #define AbsoluteValue(op,fmt) fp_abs(SIM_ARGS, op, fmt)\n-unsigned64 fp_neg (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_neg (SIM_STATE, uint64_t op, FP_formats fmt);\n #define Negate(op,fmt) fp_neg(SIM_ARGS, op, fmt)\n-unsigned64 fp_add (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_add (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define Add(op1,op2,fmt) fp_add(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_sub (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_sub (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define Sub(op1,op2,fmt) fp_sub(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_mul (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_mul (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define Multiply(op1,op2,fmt) fp_mul(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_div (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_div (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define Divide(op1,op2,fmt) fp_div(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_recip (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_recip (SIM_STATE, uint64_t op, FP_formats fmt);\n #define Recip(op,fmt) fp_recip(SIM_ARGS, op, fmt)\n-unsigned64 fp_sqrt (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_sqrt (SIM_STATE, uint64_t op, FP_formats fmt);\n #define SquareRoot(op,fmt) fp_sqrt(SIM_ARGS, op, fmt)\n-unsigned64 fp_rsqrt (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_rsqrt (SIM_STATE, uint64_t op, FP_formats fmt);\n #define RSquareRoot(op,fmt) fp_rsqrt(SIM_ARGS, op, fmt)\n-unsigned64 fp_madd (SIM_STATE, unsigned64 op1, unsigned64 op2,\n-\t\t    unsigned64 op3, FP_formats fmt);\n+uint64_t fp_madd (SIM_STATE, uint64_t op1, uint64_t op2,\n+\t\t    uint64_t op3, FP_formats fmt);\n #define MultiplyAdd(op1,op2,op3,fmt) fp_madd(SIM_ARGS, op1, op2, op3, fmt)\n-unsigned64 fp_msub (SIM_STATE, unsigned64 op1, unsigned64 op2,\n-\t\t    unsigned64 op3, FP_formats fmt);\n+uint64_t fp_msub (SIM_STATE, uint64_t op1, uint64_t op2,\n+\t\t    uint64_t op3, FP_formats fmt);\n #define MultiplySub(op1,op2,op3,fmt) fp_msub(SIM_ARGS, op1, op2, op3, fmt)\n-unsigned64 fp_nmadd (SIM_STATE, unsigned64 op1, unsigned64 op2,\n-\t\t     unsigned64 op3, FP_formats fmt);\n+uint64_t fp_nmadd (SIM_STATE, uint64_t op1, uint64_t op2,\n+\t\t     uint64_t op3, FP_formats fmt);\n #define NegMultiplyAdd(op1,op2,op3,fmt) fp_nmadd(SIM_ARGS, op1, op2, op3, fmt)\n-unsigned64 fp_nmsub (SIM_STATE, unsigned64 op1, unsigned64 op2,\n-\t\t     unsigned64 op3, FP_formats fmt);\n+uint64_t fp_nmsub (SIM_STATE, uint64_t op1, uint64_t op2,\n+\t\t     uint64_t op3, FP_formats fmt);\n #define NegMultiplySub(op1,op2,op3,fmt) fp_nmsub(SIM_ARGS, op1, op2, op3, fmt)\n-unsigned64 convert (SIM_STATE, int rm, unsigned64 op, FP_formats from, FP_formats to);\n+uint64_t convert (SIM_STATE, int rm, uint64_t op, FP_formats from, FP_formats to);\n #define Convert(rm,op,from,to) convert (SIM_ARGS, rm, op, from, to)\n-unsigned64 convert_ps (SIM_STATE, int rm, unsigned64 op, FP_formats from,\n+uint64_t convert_ps (SIM_STATE, int rm, uint64_t op, FP_formats from,\n \t\t       FP_formats to);\n #define ConvertPS(rm,op,from,to) convert_ps (SIM_ARGS, rm, op, from, to)\n \n \n /* MIPS-3D ASE operations.  */\n #define CompareAbs(op1,op2,fmt,cond,cc) \\\n fp_cmp(SIM_ARGS, op1, op2, fmt, 1, cond, cc)\n-unsigned64 fp_add_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_add_r (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define AddR(op1,op2,fmt) fp_add_r(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_mul_r (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_mul_r (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define MultiplyR(op1,op2,fmt) fp_mul_r(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_recip1 (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_recip1 (SIM_STATE, uint64_t op, FP_formats fmt);\n #define Recip1(op,fmt) fp_recip1(SIM_ARGS, op, fmt)\n-unsigned64 fp_recip2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_recip2 (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define Recip2(op1,op2,fmt) fp_recip2(SIM_ARGS, op1, op2, fmt)\n-unsigned64 fp_rsqrt1 (SIM_STATE, unsigned64 op, FP_formats fmt);\n+uint64_t fp_rsqrt1 (SIM_STATE, uint64_t op, FP_formats fmt);\n #define RSquareRoot1(op,fmt) fp_rsqrt1(SIM_ARGS, op, fmt)\n-unsigned64 fp_rsqrt2 (SIM_STATE, unsigned64 op1, unsigned64 op2, FP_formats fmt);\n+uint64_t fp_rsqrt2 (SIM_STATE, uint64_t op1, uint64_t op2, FP_formats fmt);\n #define RSquareRoot2(op1,op2,fmt) fp_rsqrt2(SIM_ARGS, op1, op2, fmt)\n \n \n@@ -802,7 +802,7 @@ typedef unsigned int MX_fmtsel;   /* MDMX format select field (5 bits).  */\n #define MX_VECT_ABSD (13)\t\t/* SB-1 only.  */\n #define MX_VECT_AVG  (14)\t\t/* SB-1 only.  */\n \n-unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);\n+uint64_t mdmx_cpr_op (SIM_STATE, int op, uint64_t op1, int vt, MX_fmtsel fmtsel);\n #define MX_Add(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_ADD, op1, vt, fmtsel)\n #define MX_And(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_AND, op1, vt, fmtsel)\n #define MX_Max(op1,vt,fmtsel) mdmx_cpr_op(SIM_ARGS, MX_VECT_MAX, op1, vt, fmtsel)\n@@ -822,10 +822,10 @@ unsigned64 mdmx_cpr_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmt\n #define MX_C_EQ  0x1\n #define MX_C_LT  0x4\n \n-void mdmx_cc_op (SIM_STATE, int cond, unsigned64 op1, int vt, MX_fmtsel fmtsel);\n+void mdmx_cc_op (SIM_STATE, int cond, uint64_t op1, int vt, MX_fmtsel fmtsel);\n #define MX_Comp(op1,cond,vt,fmtsel) mdmx_cc_op(SIM_ARGS, cond, op1, vt, fmtsel)\n \n-unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fmtsel);\n+uint64_t mdmx_pick_op (SIM_STATE, int tf, uint64_t op1, int vt, MX_fmtsel fmtsel);\n #define MX_Pick(tf,op1,vt,fmtsel) mdmx_pick_op(SIM_ARGS, tf, op1, vt, fmtsel)\n \n #define MX_VECT_ADDA  (0)\n@@ -838,7 +838,7 @@ unsigned64 mdmx_pick_op (SIM_STATE, int tf, unsigned64 op1, int vt, MX_fmtsel fm\n #define MX_VECT_SUBL  (7)\n #define MX_VECT_ABSDA (8)\t\t/* SB-1 only.  */\n \n-void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);\n+void mdmx_acc_op (SIM_STATE, int op, uint64_t op1, int vt, MX_fmtsel fmtsel);\n #define MX_AddA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDA, op1, vt, fmtsel)\n #define MX_AddL(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_ADDL, op1, vt, fmtsel)\n #define MX_MulA(op1,vt,fmtsel) mdmx_acc_op(SIM_ARGS, MX_VECT_MULA, op1, vt, fmtsel)\n@@ -857,12 +857,12 @@ void mdmx_acc_op (SIM_STATE, int op, unsigned64 op1, int vt, MX_fmtsel fmtsel);\n #define MX_RAC_M    (1)\n #define MX_RAC_H    (2)\n \n-unsigned64 mdmx_rac_op (SIM_STATE, int, int);\n+uint64_t mdmx_rac_op (SIM_STATE, int, int);\n #define MX_RAC(op,fmt) mdmx_rac_op(SIM_ARGS, op, fmt)\n \n-void mdmx_wacl (SIM_STATE, int, unsigned64, unsigned64);\n+void mdmx_wacl (SIM_STATE, int, uint64_t, uint64_t);\n #define MX_WACL(fmt,vs,vt) mdmx_wacl(SIM_ARGS, fmt, vs, vt)\n-void mdmx_wach (SIM_STATE, int, unsigned64);\n+void mdmx_wach (SIM_STATE, int, uint64_t);\n #define MX_WACH(fmt,vs) mdmx_wach(SIM_ARGS, fmt, vs)\n \n #define MX_RND_AS   (0)\n@@ -872,15 +872,15 @@ void mdmx_wach (SIM_STATE, int, unsigned64);\n #define MX_RND_ZS   (4)\n #define MX_RND_ZU   (5)\n \n-unsigned64 mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);\n+uint64_t mdmx_round_op (SIM_STATE, int, int, MX_fmtsel);\n #define MX_RNAS(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AS, vt, fmt)\n #define MX_RNAU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_AU, vt, fmt)\n #define MX_RNES(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_ES, vt, fmt)\n #define MX_RNEU(vt,fmt) mdmx_round_op(SIM_ARGS, MX_RND_EU, vt, fmt)\n #define MX_RZS(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZS, vt, fmt)\n #define MX_RZU(vt,fmt)  mdmx_round_op(SIM_ARGS, MX_RND_ZU, vt, fmt)\n \n-unsigned64 mdmx_shuffle (SIM_STATE, int, unsigned64, unsigned64);\n+uint64_t mdmx_shuffle (SIM_STATE, int, uint64_t, uint64_t);\n #define MX_SHFL(shop,op1,op2) mdmx_shuffle(SIM_ARGS, shop, op1, op2)\n \n \n@@ -937,9 +937,9 @@ void unpredictable_action (sim_cpu *cpu, address_word cia);\n #define Unpredictable()\t\tunpredictable (SD_)\n #define UnpredictableResult()\t/* For now, do nothing.  */\n \n-INLINE_SIM_MAIN (unsigned32) ifetch32 (SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr);\n+INLINE_SIM_MAIN (uint32_t) ifetch32 (SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr);\n #define IMEM32(CIA) ifetch32 (SD, CPU, (CIA), (CIA))\n-INLINE_SIM_MAIN (unsigned16) ifetch16 (SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr);\n+INLINE_SIM_MAIN (uint16_t) ifetch16 (SIM_DESC sd, sim_cpu *cpu, address_word cia, address_word vaddr);\n #define IMEM16(CIA) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1))\n #define IMEM16_IMMED(CIA,NR) ifetch16 (SD, CPU, (CIA), ((CIA) & ~1) + 2 * (NR))\n #define IMEM32_MICROMIPS(CIA) \\"
    },
    {
      "sha": "ef9bf81aaebf641a2a1cc41de5d4640f67cbb2af",
      "filename": "sim/mips/smartmips.igen",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/smartmips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/smartmips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/smartmips.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -31,8 +31,8 @@\n \"maddp r<RS>, r<RT>\"\n *smartmips:\n {\n-  unsigned64 res;\n-  unsigned64 rs, rt;\n+  uint64_t res;\n+  uint64_t rs, rt;\n   int i;\n \n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n@@ -83,8 +83,8 @@\n \"multp r<RS>, r<RT>\"\n *smartmips:\n {\n-  unsigned64 res;\n-  unsigned64 rs, rt;\n+  uint64_t res;\n+  uint64_t rs, rt;\n   int i;\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);"
    },
    {
      "sha": "2e84452ba103b9a8e238807ec3a34cedcaca3aa1",
      "filename": "sim/mips/tx.igen",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/tx.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/tx.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/tx.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -8,9 +8,9 @@\n \"madd r<RD>, r<RS>, r<RT>\"\n *r3900\n {\n-  signed64 prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t\t   + ((signed64) EXTEND32 (GPR[RT])\n-\t\t      * (signed64) EXTEND32 (GPR[RS])));\n+  int64_t prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n+\t\t   + ((int64_t) EXTEND32 (GPR[RT])\n+\t\t      * (int64_t) EXTEND32 (GPR[RS])));\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);\n   LO = EXTEND32 (prod);\n@@ -26,9 +26,9 @@\n \"maddu r<RD>, r<RS>, r<RT>\"\n *r3900\n {\n-  unsigned64 prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n-\t\t     + ((unsigned64) VL4_8 (GPR[RS])\n-\t\t\t* (unsigned64) VL4_8 (GPR[RT])));\n+  uint64_t prod = (U8_4 (VL4_8 (HI), VL4_8 (LO))\n+\t\t     + ((uint64_t) VL4_8 (GPR[RS])\n+\t\t\t* (uint64_t) VL4_8 (GPR[RT])));\n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n   TRACE_ALU_INPUT2 (GPR[RS], GPR[RT]);\n   LO = EXTEND32 (prod);"
    },
    {
      "sha": "1d87da2253538e65011c34a6d9d2cf5920fdef81",
      "filename": "sim/mips/vr.igen",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/vr.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b331e677d748b322003d4f59eb0bd2ce3feada4b/sim/mips/vr.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/vr.igen?ref=b331e677d748b322003d4f59eb0bd2ce3feada4b",
      "patch": "@@ -40,7 +40,7 @@\n //     concatenation of the low 32 bits of HI and LO.\n :function:::void:do_vr_mul_op:int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p\n {\n-  unsigned64 lhs, x, y, xcut, ycut, product, result;\n+  uint64_t lhs, x, y, xcut, ycut, product, result;\n \n   check_mult_hilo (SD_, HIHISTORY, LOHISTORY);\n \n@@ -82,10 +82,10 @@\n       /* Saturate the result to 32 bits.  An unsigned, unsaturated\n \t result is zero-extended to 64 bits, but unsigned overflow\n \t causes all 64 bits to be set.  */\n-      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)\n-\tresult = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);\n+      if (!unsigned_p && (uint64_t) EXTEND32 (result) != result)\n+\tresult = ((int64_t) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);\n       else if (unsigned_p && (result >> 32) != 0)\n-\tresult = (unsigned64) 0 - 1;\n+\tresult = (uint64_t) 0 - 1;\n     }\n   TRACE_ALU_RESULT (result);\n "
    }
  ]
}