{
  "sha": "c7748ee9ceb5a394658cd07aeb0445924599e442",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yzc3NDhlZTljZWI1YTM5NDY1OGNkMDdhZWIwNDQ1OTI0NTk5ZTQ0Mg==",
  "commit": {
    "author": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-10T21:57:08Z"
    },
    "committer": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-10T21:57:08Z"
    },
    "message": "gdb/23712: Introduce multidictionary's\n\ngdb/23712 is a new manifestation of the now-infamous (at least to me)\nsymtab/23010 assertion failure (DICT_LANGUAGE == SYMBOL_LANGAUGE).\n\nAn example of the problem (using test case from symtab/23010):\n\nReading symbols from /home/rdiez/rdiez/arduino/JtagDue/BuildOutput/JtagDue-obj-release/firmware.elf...done.\n(gdb) p SysTick_Handler\ndwarf2read.c:9715: internal-error: void dw2_add_symbol_to_list(symbol*, pending**): Assertion `(*listhead) == NULL || (SYMBOL_LANGUAGE ((*listhead)->symbol[0]) == SYMBOL_LANGUAGE (symbol))' failed.\nA problem internal to GDB has been detected,\nfurther debugging may prove unreliable.\nQuit this debugging session? (y or n)\n\nThis assertion was added specifically to catch this condition (of adding\nsymbols of different languages to a single pending list).\n\nThe problems we're now seeing on systems utilizing DWARF debugging seem to\nbe caused by the use of LTO, which adds a CU with an artificial DIE of\nlanguage C99 which references DIEs in other CUs of language C++.\n\nThus, we create a dictionary containing symbols of C99 but end up\nstuffing C++ symbols into it, and the dw2_add_symbol_to_list triggers.\n\nThe approach taken here to fix this is to introduce multi-language\ndictionaries to \"replace\" the standard, single-language dictionaries\nused today.\n\nNote to reviewers: This patch introduces some temporary functions to\naide with review.  This and other artifacts (such as \"See dictionary.h\"\nwhich appear incorrect) will all be valid at the end of the series.\n\nThis first patch introduces the new multidictionary and its API (which\nis, by design, identical to the old dictionary interface).  It also\nmutates dict_create_hashed and dict_create_linear so that they take\na std::vector instead of the usual struct pending linked list.  This will\nbe needed later on.\n\nThis patch does /not/ actually enable multidictionary's.  That is left\nfor a subsequent patch in the series.\n\nI've done exhaustive performance testing with this approach, and I've\nattempted to minimize the overhead for the (overwhelmingly) most common\none-language scenario.\n\nOn average, a -g3 -O0 GDB (the one we developers use) will see\napproximately a 4% slowdown when initially reading symbols. [I've\ntested only GDB and firefox with -readnow.]  When using -O2, this\ndifference shrinks to ~0.5%.  Since a number of runs with these\npatches actually run /faster/ than unpatched GDB, I conclude that\nthese tests have at least a 0.5% error margin.\n\nOn our own gdb.perf test suite, again, results appear to be pretty\nnegligible.  Differences to unpatched GDB range from -7.8% (yes,\npatched version is again faster than unpatched) to 27%.  All tests\nlying outside \"negligible,\" such as the 27% slowdown, involve a total\nrun time of 0.0007 (or less) with smaller numbers of CUs/DSOs (usually 10\nor 100).  In all cases, the follow-up tests with more CUs/DSOs is never\nmore than 3% difference to the baseline, unpatched GDB.\n\nIn my opinion, these results are satisfactory.\n\ngdb/ChangeLog:\n\n\tPR gdb/23712\n\tPR symtab/23010\n\t* dictionary.c: Include unordered_map.\n\t(pending_to_vector): New function.\n\t(dict_create_hashed_1, dict_create_linear_1, dict_add_pending_1):\n\tRewrite the non-\"_1\" functions to take vector instead\n\tof linked list.\n\t(dict_create_hashed, dict_create_linear, dict_add_pending): Use the\n\t\"new\" _1 versions of the same name.\n\t(multidictionary): Define.\n\t(std::hash<enum language): New definition.\n\t(collate_pending_symbols_by_language, mdict_create_hashed)\n\t(mdict_create_hashed_expandable, mdict_create_linear)\n\t(mdict_create_linear_expandable, mdict_free)\n\t(find_language_dictionary, create_new_language_dictionary)\n\t(mdict_add_symbol, mdict_add_pending, mdict_iterator_first)\n\t(mdict_iterator_next, mdict_iter_match_first, mdict_iter_match_next)\n\t(mdict_size, mdict_empty): New functions.\n\t* dictionary.h (mdict_iterator): Define.",
    "tree": {
      "sha": "09151639089516f9ff612224c9aecd9fea0368d2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/09151639089516f9ff612224c9aecd9fea0368d2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c7748ee9ceb5a394658cd07aeb0445924599e442",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7748ee9ceb5a394658cd07aeb0445924599e442",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c7748ee9ceb5a394658cd07aeb0445924599e442",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7748ee9ceb5a394658cd07aeb0445924599e442/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "67aa1f3c2881e607081d9e1b57be3e7544c2c45c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/67aa1f3c2881e607081d9e1b57be3e7544c2c45c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/67aa1f3c2881e607081d9e1b57be3e7544c2c45c"
    }
  ],
  "stats": {
    "total": 591,
    "additions": 523,
    "deletions": 68
  },
  "files": [
    {
      "sha": "24af9eb732f4c53dc227fc3eaacd9cb5071b05d3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c7748ee9ceb5a394658cd07aeb0445924599e442",
      "patch": "@@ -1,3 +1,25 @@\n+2019-01-10  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR gdb/23712\n+\tPR symtab/23010\n+\t* dictionary.c: Include unordered_map.\n+\t(pending_to_vector): New function.\n+\t(dict_create_hashed_1, dict_create_linear_1, dict_add_pending_1):\n+\tRewrite the non-\"_1\" functions to take vector instead\n+\tof linked list.\n+\t(dict_create_hashed, dict_create_linear, dict_add_pending): Use the\n+\t\"new\" _1 versions of the same name.\n+\t(multidictionary): Define.\n+\t(std::hash<enum language): New definition.\n+\t(collate_pending_symbols_by_language, mdict_create_hashed)\n+\t(mdict_create_hashed_expandable, mdict_create_linear)\n+\t(mdict_create_linear_expandable, mdict_free)\n+\t(find_language_dictionary, create_new_language_dictionary)\n+\t(mdict_add_symbol, mdict_add_pending, mdict_iterator_first)\n+\t(mdict_iterator_next, mdict_iter_match_first, mdict_iter_match_next)\n+\t(mdict_size, mdict_empty): New functions.\n+\t* dictionary.h (mdict_iterator): Define.\n+\n 2019-01-10  Pedro Alves  <palves@redhat.com>\n \n \t* breakpoint.c (read_uploaded_action)"
    },
    {
      "sha": "b5ad71ba064ff3206761f9d22508e27f56776ca6",
      "filename": "gdb/dictionary.c",
      "status": "modified",
      "additions": 486,
      "deletions": 68,
      "changes": 554,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/dictionary.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/dictionary.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dictionary.c?ref=c7748ee9ceb5a394658cd07aeb0445924599e442",
      "patch": "@@ -27,6 +27,7 @@\n #include \"buildsym.h\"\n #include \"dictionary.h\"\n #include \"safe-ctype.h\"\n+#include <unordered_map>\n \n /* This file implements dictionaries, which are tables that associate\n    symbols to names.  They are represented by an opaque type 'struct\n@@ -341,53 +342,66 @@ static void insert_symbol_hashed (struct dictionary *dict,\n \n static void expand_hashtable (struct dictionary *dict);\n \n+/* A function to convert a linked list into a vector.  */\n+\n+static std::vector<symbol *>\n+pending_to_vector (const struct pending *symbol_list)\n+{\n+  std::vector<symbol *> symlist;\n+\n+  for (const struct pending *list_counter = symbol_list;\n+       list_counter != nullptr; list_counter = list_counter->next)\n+    {\n+      for (int i = list_counter->nsyms - 1; i >= 0; --i)\n+\tsymlist.push_back (list_counter->symbol[i]);\n+    }\n+\n+  return symlist;\n+}\n+\n /* The creation functions.  */\n \n-/* See dictionary.h.  */\n+/* A function to transition dict_create_hashed to new API.  */\n \n-struct dictionary *\n-dict_create_hashed (struct obstack *obstack,\n-\t\t    enum language language,\n-\t\t    const struct pending *symbol_list)\n+static struct dictionary *\n+dict_create_hashed_1 (struct obstack *obstack,\n+\t\t      enum language language,\n+\t\t      const std::vector<symbol *> &symbol_list)\n {\n-  struct dictionary *retval;\n-  int nsyms = 0, nbuckets, i;\n-  struct symbol **buckets;\n-  const struct pending *list_counter;\n-\n-  retval = XOBNEW (obstack, struct dictionary);\n+  /* Allocate the dictionary.  */\n+  struct dictionary *retval = XOBNEW (obstack, struct dictionary);\n   DICT_VECTOR (retval) = &dict_hashed_vector;\n   DICT_LANGUAGE (retval) = language_def (language);\n \n-  /* Calculate the number of symbols, and allocate space for them.  */\n-  for (list_counter = symbol_list;\n-       list_counter != NULL;\n-       list_counter = list_counter->next)\n-    {\n-      nsyms += list_counter->nsyms;\n-    }\n-  nbuckets = DICT_HASHTABLE_SIZE (nsyms);\n+  /* Allocate space for symbols.  */\n+  int nsyms = symbol_list.size ();\n+  int nbuckets = DICT_HASHTABLE_SIZE (nsyms);\n   DICT_HASHED_NBUCKETS (retval) = nbuckets;\n-  buckets = XOBNEWVEC (obstack, struct symbol *, nbuckets);\n+  struct symbol **buckets = XOBNEWVEC (obstack, struct symbol *, nbuckets);\n   memset (buckets, 0, nbuckets * sizeof (struct symbol *));\n   DICT_HASHED_BUCKETS (retval) = buckets;\n \n   /* Now fill the buckets.  */\n-  for (list_counter = symbol_list;\n-       list_counter != NULL;\n-       list_counter = list_counter->next)\n-    {\n-      for (i = list_counter->nsyms - 1; i >= 0; --i)\n-\t{\n-\t  insert_symbol_hashed (retval, list_counter->symbol[i]);\n-\t}\n-    }\n+  for (const auto &sym : symbol_list)\n+    insert_symbol_hashed (retval, sym);\n \n   return retval;\n }\n \n /* See dictionary.h.  */\n \n+struct dictionary *\n+dict_create_hashed (struct obstack *obstack,\n+\t\t    enum language language,\n+\t\t    const struct pending *symbol_list)\n+{\n+  std::vector<symbol *> symlist = pending_to_vector (symbol_list);\n+\n+  return dict_create_hashed_1 (obstack, language, symlist);\n+}\n+\n+/* See dictionary.h.  */\n+\n extern struct dictionary *\n dict_create_hashed_expandable (enum language language)\n {\n@@ -403,52 +417,45 @@ dict_create_hashed_expandable (enum language language)\n   return retval;\n }\n \n-/* See dictionary.h.  */\n+/* A function to transition dict_create_linear to new API.  */\n \n-struct dictionary *\n-dict_create_linear (struct obstack *obstack,\n-\t\t    enum language language,\n-\t\t    const struct pending *symbol_list)\n+static struct dictionary *\n+dict_create_linear_1 (struct obstack *obstack,\n+\t\t      enum language language,\n+\t\t      const std::vector<symbol *> &symbol_list)\n {\n-  struct dictionary *retval;\n-  int nsyms = 0, i, j;\n-  struct symbol **syms;\n-  const struct pending *list_counter;\n-\n-  retval = XOBNEW (obstack, struct dictionary);\n+  struct dictionary *retval = XOBNEW (obstack, struct dictionary);\n   DICT_VECTOR (retval) = &dict_linear_vector;\n   DICT_LANGUAGE (retval) = language_def (language);\n \n-  /* Calculate the number of symbols, and allocate space for them.  */\n-  for (list_counter = symbol_list;\n-       list_counter != NULL;\n-       list_counter = list_counter->next)\n-    {\n-      nsyms += list_counter->nsyms;\n-    }\n+  /* Allocate space for symbols.  */\n+  int nsyms = symbol_list.size ();\n   DICT_LINEAR_NSYMS (retval) = nsyms;\n-  syms = XOBNEWVEC (obstack, struct symbol *, nsyms );\n+  struct symbol **syms = XOBNEWVEC (obstack, struct symbol *, nsyms);\n   DICT_LINEAR_SYMS (retval) = syms;\n \n-  /* Now fill in the symbols.  Start filling in from the back, so as\n-     to preserve the original order of the symbols.  */\n-  for (list_counter = symbol_list, j = nsyms - 1;\n-       list_counter != NULL;\n-       list_counter = list_counter->next)\n-    {\n-      for (i = list_counter->nsyms - 1;\n-\t   i >= 0;\n-\t   --i, --j)\n-\t{\n-\t  syms[j] = list_counter->symbol[i];\n-\t}\n-    }\n+  /* Now fill in the symbols.  */\n+  int idx = nsyms - 1;\n+  for (const auto &sym : symbol_list)\n+    syms[idx--] = sym;\n \n   return retval;\n }\n \n /* See dictionary.h.  */\n \n+struct dictionary *\n+dict_create_linear (struct obstack *obstack,\n+\t\t    enum language language,\n+\t\t    const struct pending *symbol_list)\n+{\n+  std::vector<symbol *> symlist = pending_to_vector (symbol_list);\n+\n+  return dict_create_linear_1 (obstack, language, symlist);\n+}\n+\n+/* See dictionary.h.  */\n+\n struct dictionary *\n dict_create_linear_expandable (enum language language)\n {\n@@ -483,20 +490,26 @@ dict_add_symbol (struct dictionary *dict, struct symbol *sym)\n   (DICT_VECTOR (dict))->add_symbol (dict, sym);\n }\n \n+/* A function to transition dict_add_pending to new API.  */\n+\n+static void\n+dict_add_pending_1 (struct dictionary *dict,\n+\t\t    const std::vector<symbol *> &symbol_list)\n+{\n+  /* Preserve ordering by reversing the list.  */\n+  for (auto sym = symbol_list.rbegin (); sym != symbol_list.rend (); ++sym)\n+    dict_add_symbol (dict, *sym);\n+}\n+\n /* Utility to add a list of symbols to a dictionary.\n    DICT must be an expandable dictionary.  */\n \n void\n dict_add_pending (struct dictionary *dict, const struct pending *symbol_list)\n {\n-  const struct pending *list;\n-  int i;\n+  std::vector<symbol *> symlist = pending_to_vector (symbol_list);\n \n-  for (list = symbol_list; list != NULL; list = list->next)\n-    {\n-      for (i = 0; i < list->nsyms; ++i)\n-\tdict_add_symbol (dict, list->symbol[i]);\n-    }\n+  dict_add_pending_1 (dict, symlist);\n }\n \n /* Initialize ITERATOR to point at the first symbol in DICT, and\n@@ -929,3 +942,408 @@ add_symbol_linear_expandable (struct dictionary *dict,\n \n   DICT_LINEAR_SYM (dict, nsyms - 1) = sym;\n }\n+\n+/* Multi-language dictionary support.  */\n+\n+/* The structure describing a multi-language dictionary.  */\n+\n+struct multidictionary\n+{\n+  /* An array of dictionaries, one per language.  All dictionaries\n+     must be of the same type.  This should be free'd for expandable\n+     dictionary types.  */\n+  struct dictionary **dictionaries;\n+\n+  /* The number of language dictionaries currently allocated.\n+     Only used for expandable dictionaries.  */\n+  unsigned short n_allocated_dictionaries;\n+};\n+\n+/* A hasher for enum language.  Injecting this into std is a convenience\n+   when using unordered_map with C++11.  */\n+\n+namespace std\n+{\n+  template<> struct hash<enum language>\n+  {\n+    typedef enum language argument_type;\n+    typedef std::size_t result_type;\n+\n+    result_type operator() (const argument_type &l) const noexcept\n+    {\n+      return static_cast<result_type> (l);\n+    }\n+  };\n+} /* namespace std */\n+\n+/* A helper function to collate symbols on the pending list by language.  */\n+\n+static std::unordered_map<enum language, std::vector<symbol *>>\n+collate_pending_symbols_by_language (const struct pending *symbol_list)\n+{\n+  std::unordered_map<enum language, std::vector<symbol *>> nsyms;\n+\n+  for (const struct pending *list_counter = symbol_list;\n+       list_counter != nullptr; list_counter = list_counter->next)\n+    {\n+      for (int i = list_counter->nsyms - 1; i >= 0; --i)\n+\t{\n+\t  enum language language = SYMBOL_LANGUAGE (list_counter->symbol[i]);\n+\t  nsyms[language].push_back (list_counter->symbol[i]);\n+\t}\n+    }\n+\n+  return nsyms;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct multidictionary *\n+mdict_create_hashed (struct obstack *obstack,\n+\t\t     const struct pending *symbol_list)\n+{\n+  struct multidictionary *retval\n+    = XOBNEW (obstack, struct multidictionary);\n+  std::unordered_map<enum language, std::vector<symbol *>> nsyms\n+    = collate_pending_symbols_by_language (symbol_list);\n+\n+  /* Loop over all languages and create/populate dictionaries.  */\n+  retval->dictionaries\n+    = XOBNEWVEC (obstack, struct dictionary *, nsyms.size ());\n+  retval->n_allocated_dictionaries = nsyms.size ();\n+\n+  int idx = 0;\n+  for (const auto &pair : nsyms)\n+    {\n+      enum language language = pair.first;\n+      std::vector<symbol *> symlist = pair.second;\n+\n+      retval->dictionaries[idx++]\n+\t= dict_create_hashed_1 (obstack, language, symlist);\n+    }\n+\n+  return retval;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct multidictionary *\n+mdict_create_hashed_expandable (enum language language)\n+{\n+  struct multidictionary *retval = XNEW (struct multidictionary);\n+\n+  /* We have no symbol list to populate, but we create an empty\n+     dictionary of the requested language to populate later.  */\n+  retval->n_allocated_dictionaries = 1;\n+  retval->dictionaries = XNEW (struct dictionary *);\n+  retval->dictionaries[0] = dict_create_hashed_expandable (language);\n+\n+  return retval;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct multidictionary *\n+mdict_create_linear (struct obstack *obstack,\n+\t\t     const struct pending *symbol_list)\n+{\n+  struct multidictionary *retval\n+    = XOBNEW (obstack, struct multidictionary);\n+  std::unordered_map<enum language, std::vector<symbol *>> nsyms\n+    = collate_pending_symbols_by_language (symbol_list);\n+\n+  /* Loop over all languages and create/populate dictionaries.  */\n+  retval->dictionaries\n+    = XOBNEWVEC (obstack, struct dictionary *, nsyms.size ());\n+  retval->n_allocated_dictionaries = nsyms.size ();\n+\n+  int idx = 0;\n+  for (const auto &pair : nsyms)\n+    {\n+      enum language language = pair.first;\n+      std::vector<symbol *> symlist = pair.second;\n+\n+      retval->dictionaries[idx++]\n+\t= dict_create_linear_1 (obstack, language, symlist);\n+    }\n+\n+  return retval;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct multidictionary *\n+mdict_create_linear_expandable (enum language language)\n+{\n+  struct multidictionary *retval = XNEW (struct multidictionary);\n+\n+  /* We have no symbol list to populate, but we create an empty\n+     dictionary to populate later.  */\n+  retval->n_allocated_dictionaries = 1;\n+  retval->dictionaries = XNEW (struct dictionary *);\n+  retval->dictionaries[0] = dict_create_linear_expandable (language);\n+\n+  return retval;\n+}\n+\n+/* See dictionary.h.  */\n+\n+void\n+mdict_free (struct multidictionary *mdict)\n+{\n+  /* Grab the type of dictionary being used.  */\n+  enum dict_type type = mdict->dictionaries[0]->vector->type;\n+\n+  /* Loop over all dictionaries and free them.  */\n+  for (unsigned short idx = 0; idx < mdict->n_allocated_dictionaries; ++idx)\n+    dict_free (mdict->dictionaries[idx]);\n+\n+  /* Free the dictionary list, if needed.  */\n+  switch (type)\n+    {\n+    case DICT_HASHED:\n+    case DICT_LINEAR:\n+      /* Memory was allocated on an obstack when created.  */\n+      break;\n+\n+    case DICT_HASHED_EXPANDABLE:\n+    case DICT_LINEAR_EXPANDABLE:\n+      xfree (mdict->dictionaries);\n+      break;\n+    }\n+}\n+\n+/* Helper function to find the dictionary associated with LANGUAGE\n+   or NULL if there is no dictionary of that language.  */\n+\n+static struct dictionary *\n+find_language_dictionary (const struct multidictionary *mdict,\n+\t\t\t  enum language language)\n+{\n+  for (unsigned short idx = 0; idx < mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      if (DICT_LANGUAGE (mdict->dictionaries[idx])->la_language == language)\n+\treturn mdict->dictionaries[idx];\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* Create a new language dictionary for LANGUAGE and add it to the\n+   multidictionary MDICT's list of dictionaries.  If MDICT is not\n+   based on expandable dictionaries, this function throws an\n+   internal error.  */\n+\n+static struct dictionary *\n+create_new_language_dictionary (struct multidictionary *mdict,\n+\t\t\t\tenum language language)\n+{\n+  struct dictionary *retval = nullptr;\n+\n+  /* We use the first dictionary entry to decide what create function\n+     to call.  Not optimal but sufficient.  */\n+  gdb_assert (mdict->dictionaries[0] != nullptr);\n+  switch (mdict->dictionaries[0]->vector->type)\n+    {\n+    case DICT_HASHED:\n+    case DICT_LINEAR:\n+      internal_error (__FILE__, __LINE__,\n+\t\t      _(\"create_new_language_dictionary: attempted to expand \"\n+\t\t\t\"non-expandable multidictionary\"));\n+\n+    case DICT_HASHED_EXPANDABLE:\n+      retval = dict_create_hashed_expandable (language);\n+      break;\n+\n+    case DICT_LINEAR_EXPANDABLE:\n+      retval = dict_create_linear_expandable (language);\n+      break;\n+    }\n+\n+  /* Grow the dictionary vector and save the new dictionary.  */\n+  mdict->dictionaries\n+    = (struct dictionary **) xrealloc (mdict->dictionaries,\n+\t\t\t\t       (++mdict->n_allocated_dictionaries\n+\t\t\t\t\t* sizeof (struct dictionary *)));\n+  mdict->dictionaries[mdict->n_allocated_dictionaries - 1] = retval;\n+\n+  return retval;\n+}\n+\n+/* See dictionary.h.  */\n+\n+void\n+mdict_add_symbol (struct multidictionary *mdict, struct symbol *sym)\n+{\n+  struct dictionary *dict\n+    = find_language_dictionary (mdict, SYMBOL_LANGUAGE (sym));\n+\n+  if (dict == nullptr)\n+    {\n+      /* SYM is of a new language that we haven't previously seen.\n+\t Create a new dictionary for it.  */\n+      dict = create_new_language_dictionary (mdict, SYMBOL_LANGUAGE (sym));\n+    }\n+\n+  dict_add_symbol (dict, sym);\n+}\n+\n+/* See dictionary.h.  */\n+\n+void\n+mdict_add_pending (struct multidictionary *mdict,\n+\t\t   const struct pending *symbol_list)\n+{\n+  std::unordered_map<enum language, std::vector<symbol *>> nsyms\n+    = collate_pending_symbols_by_language (symbol_list);\n+\n+  for (const auto &pair : nsyms)\n+    {\n+      enum language language = pair.first;\n+      std::vector<symbol *> symlist = pair.second;\n+      struct dictionary *dict = find_language_dictionary (mdict, language);\n+\n+      if (dict == nullptr)\n+\t{\n+\t  /* The language was not previously seen.  Create a new dictionary\n+\t     for it.  */\n+\t  dict = create_new_language_dictionary (mdict, language);\n+\t}\n+\n+      dict_add_pending_1 (dict, symlist);\n+    }\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct symbol *\n+mdict_iterator_first (const multidictionary *mdict,\n+\t\t      struct mdict_iterator *miterator)\n+{\n+  miterator->mdict = mdict;\n+  miterator->current_idx = 0;\n+\n+  for (unsigned short idx = miterator->current_idx;\n+       idx < mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      struct symbol *result\n+\t= dict_iterator_first (mdict->dictionaries[idx], &miterator->iterator);\n+\n+      if (result != nullptr)\n+\t{\n+\t  miterator->current_idx = idx;\n+\t  return result;\n+\t}\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct symbol *\n+mdict_iterator_next (struct mdict_iterator *miterator)\n+{\n+  struct symbol *result = dict_iterator_next (&miterator->iterator);\n+\n+  if (result != nullptr)\n+    return result;\n+\n+  /* The current dictionary had no matches -- move to the next\n+     dictionary, if any.  */\n+  for (unsigned short idx = ++miterator->current_idx;\n+       idx < miterator->mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      result\n+\t= dict_iterator_first (miterator->mdict->dictionaries[idx],\n+\t\t\t       &miterator->iterator);\n+      if (result != nullptr)\n+\t{\n+\t  miterator->current_idx = idx;\n+\t  return result;\n+\t}\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct symbol *\n+mdict_iter_match_first (const struct multidictionary *mdict,\n+\t\t\tconst lookup_name_info &name,\n+\t\t\tstruct mdict_iterator *miterator)\n+{\n+  miterator->mdict = mdict;\n+  miterator->current_idx = 0;\n+\n+  for (unsigned short idx = miterator->current_idx;\n+       idx < mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      struct symbol *result\n+\t= dict_iter_match_first (mdict->dictionaries[idx], name,\n+\t\t\t\t &miterator->iterator);\n+\n+      if (result != nullptr)\n+\treturn result;\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* See dictionary.h.  */\n+\n+struct symbol *\n+mdict_iter_match_next (const lookup_name_info &name,\n+\t\t       struct mdict_iterator *miterator)\n+{\n+  /* Search the current dictionary.  */\n+  struct symbol *result = dict_iter_match_next (name, &miterator->iterator);\n+\n+  if (result != nullptr)\n+    return result;\n+\n+  /* The current dictionary had no matches -- move to the next\n+     dictionary, if any.  */\n+  for (unsigned short idx = ++miterator->current_idx;\n+       idx < miterator->mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      result\n+\t= dict_iter_match_first (miterator->mdict->dictionaries[idx],\n+\t\t\t\t name, &miterator->iterator);\n+      if (result != nullptr)\n+\t{\n+\t  miterator->current_idx = idx;\n+\t  return result;\n+\t}\n+    }\n+\n+  return nullptr;\n+}\n+\n+/* See dictionary.h.  */\n+\n+int\n+mdict_size (const struct multidictionary *mdict)\n+{\n+  int size = 0;\n+\n+  for (unsigned short idx = 0; idx < mdict->n_allocated_dictionaries; ++idx)\n+    size += dict_size (mdict->dictionaries[idx]);\n+\n+  return size;\n+}\n+\n+/* See dictionary.h.  */\n+\n+bool\n+mdict_empty (const struct multidictionary *mdict)\n+{\n+  for (unsigned short idx = 0; idx < mdict->n_allocated_dictionaries; ++idx)\n+    {\n+      if (!dict_empty (mdict->dictionaries[idx]))\n+\treturn false;\n+    }\n+\n+  return true;\n+}"
    },
    {
      "sha": "5e17a8bb7989664b2277f623a83c777f227a747b",
      "filename": "gdb/dictionary.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/dictionary.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7748ee9ceb5a394658cd07aeb0445924599e442/gdb/dictionary.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dictionary.h?ref=c7748ee9ceb5a394658cd07aeb0445924599e442",
      "patch": "@@ -113,6 +113,21 @@ struct dict_iterator\n   struct symbol *current;\n };\n \n+/* The multi-language dictionary iterator.  Like dict_iterator above,\n+   these contents should be considered private.  */\n+\n+struct mdict_iterator\n+{\n+  /* The multidictionary with whcih this iterator is associated.  */\n+  const struct multidictionary *mdict;\n+\n+  /* The iterator used to iterate through individual dictionaries.  */\n+  struct dict_iterator iterator;\n+\n+  /* The current index of the dictionary being iterated over.  */\n+  unsigned short current_idx;\n+};\n+\n /* Initialize ITERATOR to point at the first symbol in DICT, and\n    return that first symbol, or NULL if DICT is empty.  */\n "
    }
  ]
}