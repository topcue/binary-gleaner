{
  "sha": "dda83cd783075941aabe9b0292b004b11f00c831",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGRhODNjZDc4MzA3NTk0MWFhYmU5YjAyOTJiMDA0YjExZjAwYzgzMQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-11-02T15:26:14Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-11-02T15:28:45Z"
    },
    "message": "gdb, gdbserver, gdbsupport: fix leading space vs tabs issues\n\nMany spots incorrectly use only spaces for indentation (for example,\nthere are a lot of spots in ada-lang.c).  I've always found it awkward\nwhen I needed to edit one of these spots: do I keep the original wrong\nindentation, or do I fix it?  What if the lines around it are also\nwrong, do I fix them too?  I probably don't want to fix them in the same\npatch, to avoid adding noise to my patch.\n\nSo I propose to fix as much as possible once and for all (hopefully).\n\nOne typical counter argument for this is that it makes code archeology\nmore difficult, because git-blame will show this commit as the last\nchange for these lines.  My counter counter argument is: when\ngit-blaming, you often need to do \"blame the file at the parent commit\"\nanyway, to go past some other refactor that touched the line you are\ninterested in, but is not the change you are looking for.  So you\nalready need a somewhat efficient way to do this.\n\nUsing some interactive tool, rather than plain git-blame, makes this\ntrivial.  For example, I use \"tig blame <file>\", where going back past\nthe commit that changed the currently selected line is one keystroke.\nIt looks like Magit in Emacs does it too (though I've never used it).\nWeb viewers of Github and Gitlab do it too.  My point is that it won't\nreally make archeology more difficult.\n\nThe other typical counter argument is that it will cause conflicts with\nexisting patches.  That's true... but it's a one time cost, and those\nare not conflicts that are difficult to resolve.  I have also tried \"git\nrebase --ignore-whitespace\", it seems to work well.  Although that will\nre-introduce the faulty indentation, so one needs to take care of fixing\nthe indentation in the patch after that (which is easy).\n\ngdb/ChangeLog:\n\n\t* aarch64-linux-tdep.c: Fix indentation.\n\t* aarch64-ravenscar-thread.c: Fix indentation.\n\t* aarch64-tdep.c: Fix indentation.\n\t* aarch64-tdep.h: Fix indentation.\n\t* ada-lang.c: Fix indentation.\n\t* ada-lang.h: Fix indentation.\n\t* ada-tasks.c: Fix indentation.\n\t* ada-typeprint.c: Fix indentation.\n\t* ada-valprint.c: Fix indentation.\n\t* ada-varobj.c: Fix indentation.\n\t* addrmap.c: Fix indentation.\n\t* addrmap.h: Fix indentation.\n\t* agent.c: Fix indentation.\n\t* aix-thread.c: Fix indentation.\n\t* alpha-bsd-nat.c: Fix indentation.\n\t* alpha-linux-tdep.c: Fix indentation.\n\t* alpha-mdebug-tdep.c: Fix indentation.\n\t* alpha-nbsd-tdep.c: Fix indentation.\n\t* alpha-obsd-tdep.c: Fix indentation.\n\t* alpha-tdep.c: Fix indentation.\n\t* amd64-bsd-nat.c: Fix indentation.\n\t* amd64-darwin-tdep.c: Fix indentation.\n\t* amd64-linux-nat.c: Fix indentation.\n\t* amd64-linux-tdep.c: Fix indentation.\n\t* amd64-nat.c: Fix indentation.\n\t* amd64-obsd-tdep.c: Fix indentation.\n\t* amd64-tdep.c: Fix indentation.\n\t* amd64-windows-tdep.c: Fix indentation.\n\t* annotate.c: Fix indentation.\n\t* arc-tdep.c: Fix indentation.\n\t* arch-utils.c: Fix indentation.\n\t* arch/arm-get-next-pcs.c: Fix indentation.\n\t* arch/arm.c: Fix indentation.\n\t* arm-linux-nat.c: Fix indentation.\n\t* arm-linux-tdep.c: Fix indentation.\n\t* arm-nbsd-tdep.c: Fix indentation.\n\t* arm-pikeos-tdep.c: Fix indentation.\n\t* arm-tdep.c: Fix indentation.\n\t* arm-tdep.h: Fix indentation.\n\t* arm-wince-tdep.c: Fix indentation.\n\t* auto-load.c: Fix indentation.\n\t* auxv.c: Fix indentation.\n\t* avr-tdep.c: Fix indentation.\n\t* ax-gdb.c: Fix indentation.\n\t* ax-general.c: Fix indentation.\n\t* bfin-linux-tdep.c: Fix indentation.\n\t* block.c: Fix indentation.\n\t* block.h: Fix indentation.\n\t* blockframe.c: Fix indentation.\n\t* bpf-tdep.c: Fix indentation.\n\t* break-catch-sig.c: Fix indentation.\n\t* break-catch-syscall.c: Fix indentation.\n\t* break-catch-throw.c: Fix indentation.\n\t* breakpoint.c: Fix indentation.\n\t* breakpoint.h: Fix indentation.\n\t* bsd-uthread.c: Fix indentation.\n\t* btrace.c: Fix indentation.\n\t* build-id.c: Fix indentation.\n\t* buildsym-legacy.h: Fix indentation.\n\t* buildsym.c: Fix indentation.\n\t* c-typeprint.c: Fix indentation.\n\t* c-valprint.c: Fix indentation.\n\t* c-varobj.c: Fix indentation.\n\t* charset.c: Fix indentation.\n\t* cli/cli-cmds.c: Fix indentation.\n\t* cli/cli-decode.c: Fix indentation.\n\t* cli/cli-decode.h: Fix indentation.\n\t* cli/cli-script.c: Fix indentation.\n\t* cli/cli-setshow.c: Fix indentation.\n\t* coff-pe-read.c: Fix indentation.\n\t* coffread.c: Fix indentation.\n\t* compile/compile-cplus-types.c: Fix indentation.\n\t* compile/compile-object-load.c: Fix indentation.\n\t* compile/compile-object-run.c: Fix indentation.\n\t* completer.c: Fix indentation.\n\t* corefile.c: Fix indentation.\n\t* corelow.c: Fix indentation.\n\t* cp-abi.h: Fix indentation.\n\t* cp-namespace.c: Fix indentation.\n\t* cp-support.c: Fix indentation.\n\t* cp-valprint.c: Fix indentation.\n\t* cris-linux-tdep.c: Fix indentation.\n\t* cris-tdep.c: Fix indentation.\n\t* darwin-nat-info.c: Fix indentation.\n\t* darwin-nat.c: Fix indentation.\n\t* darwin-nat.h: Fix indentation.\n\t* dbxread.c: Fix indentation.\n\t* dcache.c: Fix indentation.\n\t* disasm.c: Fix indentation.\n\t* dtrace-probe.c: Fix indentation.\n\t* dwarf2/abbrev.c: Fix indentation.\n\t* dwarf2/attribute.c: Fix indentation.\n\t* dwarf2/expr.c: Fix indentation.\n\t* dwarf2/frame.c: Fix indentation.\n\t* dwarf2/index-cache.c: Fix indentation.\n\t* dwarf2/index-write.c: Fix indentation.\n\t* dwarf2/line-header.c: Fix indentation.\n\t* dwarf2/loc.c: Fix indentation.\n\t* dwarf2/macro.c: Fix indentation.\n\t* dwarf2/read.c: Fix indentation.\n\t* dwarf2/read.h: Fix indentation.\n\t* elfread.c: Fix indentation.\n\t* eval.c: Fix indentation.\n\t* event-top.c: Fix indentation.\n\t* exec.c: Fix indentation.\n\t* exec.h: Fix indentation.\n\t* expprint.c: Fix indentation.\n\t* f-lang.c: Fix indentation.\n\t* f-typeprint.c: Fix indentation.\n\t* f-valprint.c: Fix indentation.\n\t* fbsd-nat.c: Fix indentation.\n\t* fbsd-tdep.c: Fix indentation.\n\t* findvar.c: Fix indentation.\n\t* fork-child.c: Fix indentation.\n\t* frame-unwind.c: Fix indentation.\n\t* frame-unwind.h: Fix indentation.\n\t* frame.c: Fix indentation.\n\t* frv-linux-tdep.c: Fix indentation.\n\t* frv-tdep.c: Fix indentation.\n\t* frv-tdep.h: Fix indentation.\n\t* ft32-tdep.c: Fix indentation.\n\t* gcore.c: Fix indentation.\n\t* gdb_bfd.c: Fix indentation.\n\t* gdbarch.sh: Fix indentation.\n\t* gdbarch.c: Re-generate\n\t* gdbarch.h: Re-generate.\n\t* gdbcore.h: Fix indentation.\n\t* gdbthread.h: Fix indentation.\n\t* gdbtypes.c: Fix indentation.\n\t* gdbtypes.h: Fix indentation.\n\t* glibc-tdep.c: Fix indentation.\n\t* gnu-nat.c: Fix indentation.\n\t* gnu-nat.h: Fix indentation.\n\t* gnu-v2-abi.c: Fix indentation.\n\t* gnu-v3-abi.c: Fix indentation.\n\t* go32-nat.c: Fix indentation.\n\t* guile/guile-internal.h: Fix indentation.\n\t* guile/scm-cmd.c: Fix indentation.\n\t* guile/scm-frame.c: Fix indentation.\n\t* guile/scm-iterator.c: Fix indentation.\n\t* guile/scm-math.c: Fix indentation.\n\t* guile/scm-ports.c: Fix indentation.\n\t* guile/scm-pretty-print.c: Fix indentation.\n\t* guile/scm-value.c: Fix indentation.\n\t* h8300-tdep.c: Fix indentation.\n\t* hppa-linux-nat.c: Fix indentation.\n\t* hppa-linux-tdep.c: Fix indentation.\n\t* hppa-nbsd-nat.c: Fix indentation.\n\t* hppa-nbsd-tdep.c: Fix indentation.\n\t* hppa-obsd-nat.c: Fix indentation.\n\t* hppa-tdep.c: Fix indentation.\n\t* hppa-tdep.h: Fix indentation.\n\t* i386-bsd-nat.c: Fix indentation.\n\t* i386-darwin-nat.c: Fix indentation.\n\t* i386-darwin-tdep.c: Fix indentation.\n\t* i386-dicos-tdep.c: Fix indentation.\n\t* i386-gnu-nat.c: Fix indentation.\n\t* i386-linux-nat.c: Fix indentation.\n\t* i386-linux-tdep.c: Fix indentation.\n\t* i386-nto-tdep.c: Fix indentation.\n\t* i386-obsd-tdep.c: Fix indentation.\n\t* i386-sol2-nat.c: Fix indentation.\n\t* i386-tdep.c: Fix indentation.\n\t* i386-tdep.h: Fix indentation.\n\t* i386-windows-tdep.c: Fix indentation.\n\t* i387-tdep.c: Fix indentation.\n\t* i387-tdep.h: Fix indentation.\n\t* ia64-libunwind-tdep.c: Fix indentation.\n\t* ia64-libunwind-tdep.h: Fix indentation.\n\t* ia64-linux-nat.c: Fix indentation.\n\t* ia64-linux-tdep.c: Fix indentation.\n\t* ia64-tdep.c: Fix indentation.\n\t* ia64-tdep.h: Fix indentation.\n\t* ia64-vms-tdep.c: Fix indentation.\n\t* infcall.c: Fix indentation.\n\t* infcmd.c: Fix indentation.\n\t* inferior.c: Fix indentation.\n\t* infrun.c: Fix indentation.\n\t* iq2000-tdep.c: Fix indentation.\n\t* language.c: Fix indentation.\n\t* linespec.c: Fix indentation.\n\t* linux-fork.c: Fix indentation.\n\t* linux-nat.c: Fix indentation.\n\t* linux-tdep.c: Fix indentation.\n\t* linux-thread-db.c: Fix indentation.\n\t* lm32-tdep.c: Fix indentation.\n\t* m2-lang.c: Fix indentation.\n\t* m2-typeprint.c: Fix indentation.\n\t* m2-valprint.c: Fix indentation.\n\t* m32c-tdep.c: Fix indentation.\n\t* m32r-linux-tdep.c: Fix indentation.\n\t* m32r-tdep.c: Fix indentation.\n\t* m68hc11-tdep.c: Fix indentation.\n\t* m68k-bsd-nat.c: Fix indentation.\n\t* m68k-linux-nat.c: Fix indentation.\n\t* m68k-linux-tdep.c: Fix indentation.\n\t* m68k-tdep.c: Fix indentation.\n\t* machoread.c: Fix indentation.\n\t* macrocmd.c: Fix indentation.\n\t* macroexp.c: Fix indentation.\n\t* macroscope.c: Fix indentation.\n\t* macrotab.c: Fix indentation.\n\t* macrotab.h: Fix indentation.\n\t* main.c: Fix indentation.\n\t* mdebugread.c: Fix indentation.\n\t* mep-tdep.c: Fix indentation.\n\t* mi/mi-cmd-catch.c: Fix indentation.\n\t* mi/mi-cmd-disas.c: Fix indentation.\n\t* mi/mi-cmd-env.c: Fix indentation.\n\t* mi/mi-cmd-stack.c: Fix indentation.\n\t* mi/mi-cmd-var.c: Fix indentation.\n\t* mi/mi-cmds.c: Fix indentation.\n\t* mi/mi-main.c: Fix indentation.\n\t* mi/mi-parse.c: Fix indentation.\n\t* microblaze-tdep.c: Fix indentation.\n\t* minidebug.c: Fix indentation.\n\t* minsyms.c: Fix indentation.\n\t* mips-linux-nat.c: Fix indentation.\n\t* mips-linux-tdep.c: Fix indentation.\n\t* mips-nbsd-tdep.c: Fix indentation.\n\t* mips-tdep.c: Fix indentation.\n\t* mn10300-linux-tdep.c: Fix indentation.\n\t* mn10300-tdep.c: Fix indentation.\n\t* moxie-tdep.c: Fix indentation.\n\t* msp430-tdep.c: Fix indentation.\n\t* namespace.h: Fix indentation.\n\t* nat/fork-inferior.c: Fix indentation.\n\t* nat/gdb_ptrace.h: Fix indentation.\n\t* nat/linux-namespaces.c: Fix indentation.\n\t* nat/linux-osdata.c: Fix indentation.\n\t* nat/netbsd-nat.c: Fix indentation.\n\t* nat/x86-dregs.c: Fix indentation.\n\t* nbsd-nat.c: Fix indentation.\n\t* nbsd-tdep.c: Fix indentation.\n\t* nios2-linux-tdep.c: Fix indentation.\n\t* nios2-tdep.c: Fix indentation.\n\t* nto-procfs.c: Fix indentation.\n\t* nto-tdep.c: Fix indentation.\n\t* objfiles.c: Fix indentation.\n\t* objfiles.h: Fix indentation.\n\t* opencl-lang.c: Fix indentation.\n\t* or1k-tdep.c: Fix indentation.\n\t* osabi.c: Fix indentation.\n\t* osabi.h: Fix indentation.\n\t* osdata.c: Fix indentation.\n\t* p-lang.c: Fix indentation.\n\t* p-typeprint.c: Fix indentation.\n\t* p-valprint.c: Fix indentation.\n\t* parse.c: Fix indentation.\n\t* ppc-linux-nat.c: Fix indentation.\n\t* ppc-linux-tdep.c: Fix indentation.\n\t* ppc-nbsd-nat.c: Fix indentation.\n\t* ppc-nbsd-tdep.c: Fix indentation.\n\t* ppc-obsd-nat.c: Fix indentation.\n\t* ppc-ravenscar-thread.c: Fix indentation.\n\t* ppc-sysv-tdep.c: Fix indentation.\n\t* ppc64-tdep.c: Fix indentation.\n\t* printcmd.c: Fix indentation.\n\t* proc-api.c: Fix indentation.\n\t* producer.c: Fix indentation.\n\t* producer.h: Fix indentation.\n\t* prologue-value.c: Fix indentation.\n\t* prologue-value.h: Fix indentation.\n\t* psymtab.c: Fix indentation.\n\t* python/py-arch.c: Fix indentation.\n\t* python/py-bpevent.c: Fix indentation.\n\t* python/py-event.c: Fix indentation.\n\t* python/py-event.h: Fix indentation.\n\t* python/py-finishbreakpoint.c: Fix indentation.\n\t* python/py-frame.c: Fix indentation.\n\t* python/py-framefilter.c: Fix indentation.\n\t* python/py-inferior.c: Fix indentation.\n\t* python/py-infthread.c: Fix indentation.\n\t* python/py-objfile.c: Fix indentation.\n\t* python/py-prettyprint.c: Fix indentation.\n\t* python/py-registers.c: Fix indentation.\n\t* python/py-signalevent.c: Fix indentation.\n\t* python/py-stopevent.c: Fix indentation.\n\t* python/py-stopevent.h: Fix indentation.\n\t* python/py-threadevent.c: Fix indentation.\n\t* python/py-tui.c: Fix indentation.\n\t* python/py-unwind.c: Fix indentation.\n\t* python/py-value.c: Fix indentation.\n\t* python/py-xmethods.c: Fix indentation.\n\t* python/python-internal.h: Fix indentation.\n\t* python/python.c: Fix indentation.\n\t* ravenscar-thread.c: Fix indentation.\n\t* record-btrace.c: Fix indentation.\n\t* record-full.c: Fix indentation.\n\t* record.c: Fix indentation.\n\t* reggroups.c: Fix indentation.\n\t* regset.h: Fix indentation.\n\t* remote-fileio.c: Fix indentation.\n\t* remote.c: Fix indentation.\n\t* reverse.c: Fix indentation.\n\t* riscv-linux-tdep.c: Fix indentation.\n\t* riscv-ravenscar-thread.c: Fix indentation.\n\t* riscv-tdep.c: Fix indentation.\n\t* rl78-tdep.c: Fix indentation.\n\t* rs6000-aix-tdep.c: Fix indentation.\n\t* rs6000-lynx178-tdep.c: Fix indentation.\n\t* rs6000-nat.c: Fix indentation.\n\t* rs6000-tdep.c: Fix indentation.\n\t* rust-lang.c: Fix indentation.\n\t* rx-tdep.c: Fix indentation.\n\t* s12z-tdep.c: Fix indentation.\n\t* s390-linux-tdep.c: Fix indentation.\n\t* score-tdep.c: Fix indentation.\n\t* ser-base.c: Fix indentation.\n\t* ser-mingw.c: Fix indentation.\n\t* ser-uds.c: Fix indentation.\n\t* ser-unix.c: Fix indentation.\n\t* serial.c: Fix indentation.\n\t* sh-linux-tdep.c: Fix indentation.\n\t* sh-nbsd-tdep.c: Fix indentation.\n\t* sh-tdep.c: Fix indentation.\n\t* skip.c: Fix indentation.\n\t* sol-thread.c: Fix indentation.\n\t* solib-aix.c: Fix indentation.\n\t* solib-darwin.c: Fix indentation.\n\t* solib-frv.c: Fix indentation.\n\t* solib-svr4.c: Fix indentation.\n\t* solib.c: Fix indentation.\n\t* source.c: Fix indentation.\n\t* sparc-linux-tdep.c: Fix indentation.\n\t* sparc-nbsd-tdep.c: Fix indentation.\n\t* sparc-obsd-tdep.c: Fix indentation.\n\t* sparc-ravenscar-thread.c: Fix indentation.\n\t* sparc-tdep.c: Fix indentation.\n\t* sparc64-linux-tdep.c: Fix indentation.\n\t* sparc64-nbsd-tdep.c: Fix indentation.\n\t* sparc64-obsd-tdep.c: Fix indentation.\n\t* sparc64-tdep.c: Fix indentation.\n\t* stabsread.c: Fix indentation.\n\t* stack.c: Fix indentation.\n\t* stap-probe.c: Fix indentation.\n\t* stubs/ia64vms-stub.c: Fix indentation.\n\t* stubs/m32r-stub.c: Fix indentation.\n\t* stubs/m68k-stub.c: Fix indentation.\n\t* stubs/sh-stub.c: Fix indentation.\n\t* stubs/sparc-stub.c: Fix indentation.\n\t* symfile-mem.c: Fix indentation.\n\t* symfile.c: Fix indentation.\n\t* symfile.h: Fix indentation.\n\t* symmisc.c: Fix indentation.\n\t* symtab.c: Fix indentation.\n\t* symtab.h: Fix indentation.\n\t* target-float.c: Fix indentation.\n\t* target.c: Fix indentation.\n\t* target.h: Fix indentation.\n\t* tic6x-tdep.c: Fix indentation.\n\t* tilegx-linux-tdep.c: Fix indentation.\n\t* tilegx-tdep.c: Fix indentation.\n\t* top.c: Fix indentation.\n\t* tracefile-tfile.c: Fix indentation.\n\t* tracepoint.c: Fix indentation.\n\t* tui/tui-disasm.c: Fix indentation.\n\t* tui/tui-io.c: Fix indentation.\n\t* tui/tui-regs.c: Fix indentation.\n\t* tui/tui-stack.c: Fix indentation.\n\t* tui/tui-win.c: Fix indentation.\n\t* tui/tui-winsource.c: Fix indentation.\n\t* tui/tui.c: Fix indentation.\n\t* typeprint.c: Fix indentation.\n\t* ui-out.h: Fix indentation.\n\t* unittests/copy_bitwise-selftests.c: Fix indentation.\n\t* unittests/memory-map-selftests.c: Fix indentation.\n\t* utils.c: Fix indentation.\n\t* v850-tdep.c: Fix indentation.\n\t* valarith.c: Fix indentation.\n\t* valops.c: Fix indentation.\n\t* valprint.c: Fix indentation.\n\t* valprint.h: Fix indentation.\n\t* value.c: Fix indentation.\n\t* value.h: Fix indentation.\n\t* varobj.c: Fix indentation.\n\t* vax-tdep.c: Fix indentation.\n\t* windows-nat.c: Fix indentation.\n\t* windows-tdep.c: Fix indentation.\n\t* xcoffread.c: Fix indentation.\n\t* xml-syscall.c: Fix indentation.\n\t* xml-tdesc.c: Fix indentation.\n\t* xstormy16-tdep.c: Fix indentation.\n\t* xtensa-config.c: Fix indentation.\n\t* xtensa-linux-nat.c: Fix indentation.\n\t* xtensa-linux-tdep.c: Fix indentation.\n\t* xtensa-tdep.c: Fix indentation.\n\ngdbserver/ChangeLog:\n\n\t* ax.cc: Fix indentation.\n\t* dll.cc: Fix indentation.\n\t* inferiors.h: Fix indentation.\n\t* linux-low.cc: Fix indentation.\n\t* linux-nios2-low.cc: Fix indentation.\n\t* linux-ppc-ipa.cc: Fix indentation.\n\t* linux-ppc-low.cc: Fix indentation.\n\t* linux-x86-low.cc: Fix indentation.\n\t* linux-xtensa-low.cc: Fix indentation.\n\t* regcache.cc: Fix indentation.\n\t* server.cc: Fix indentation.\n\t* tracepoint.cc: Fix indentation.\n\ngdbsupport/ChangeLog:\n\n\t* common-exceptions.h: Fix indentation.\n\t* event-loop.cc: Fix indentation.\n\t* fileio.cc: Fix indentation.\n\t* filestuff.cc: Fix indentation.\n\t* gdb-dlfcn.cc: Fix indentation.\n\t* gdb_string_view.h: Fix indentation.\n\t* job-control.cc: Fix indentation.\n\t* signals.cc: Fix indentation.\n\nChange-Id: I4bad7ae6be0fbe14168b8ebafb98ffe14964a695",
    "tree": {
      "sha": "185c06ef106c06ecc55ea045a4916495c1a3526b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/185c06ef106c06ecc55ea045a4916495c1a3526b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dda83cd783075941aabe9b0292b004b11f00c831",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dda83cd783075941aabe9b0292b004b11f00c831",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dda83cd783075941aabe9b0292b004b11f00c831",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dda83cd783075941aabe9b0292b004b11f00c831/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1c2bec1918cee91221bccc30db4f0253dc31d1b7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c2bec1918cee91221bccc30db4f0253dc31d1b7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1c2bec1918cee91221bccc30db4f0253dc31d1b7"
    }
  ],
  "stats": {
    "total": 29086,
    "additions": 14751,
    "deletions": 14335
  },
  "files": [
    {
      "sha": "e414cfd4d8cc8117bfe7f223e8835bc900aa4eb4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 390,
      "deletions": 0,
      "changes": 390,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1,3 +1,393 @@\n+2020-11-02  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* aarch64-linux-tdep.c: Fix indentation.\n+\t* aarch64-ravenscar-thread.c: Fix indentation.\n+\t* aarch64-tdep.c: Fix indentation.\n+\t* aarch64-tdep.h: Fix indentation.\n+\t* ada-lang.c: Fix indentation.\n+\t* ada-lang.h: Fix indentation.\n+\t* ada-tasks.c: Fix indentation.\n+\t* ada-typeprint.c: Fix indentation.\n+\t* ada-valprint.c: Fix indentation.\n+\t* ada-varobj.c: Fix indentation.\n+\t* addrmap.c: Fix indentation.\n+\t* addrmap.h: Fix indentation.\n+\t* agent.c: Fix indentation.\n+\t* aix-thread.c: Fix indentation.\n+\t* alpha-bsd-nat.c: Fix indentation.\n+\t* alpha-linux-tdep.c: Fix indentation.\n+\t* alpha-mdebug-tdep.c: Fix indentation.\n+\t* alpha-nbsd-tdep.c: Fix indentation.\n+\t* alpha-obsd-tdep.c: Fix indentation.\n+\t* alpha-tdep.c: Fix indentation.\n+\t* amd64-bsd-nat.c: Fix indentation.\n+\t* amd64-darwin-tdep.c: Fix indentation.\n+\t* amd64-linux-nat.c: Fix indentation.\n+\t* amd64-linux-tdep.c: Fix indentation.\n+\t* amd64-nat.c: Fix indentation.\n+\t* amd64-obsd-tdep.c: Fix indentation.\n+\t* amd64-tdep.c: Fix indentation.\n+\t* amd64-windows-tdep.c: Fix indentation.\n+\t* annotate.c: Fix indentation.\n+\t* arc-tdep.c: Fix indentation.\n+\t* arch-utils.c: Fix indentation.\n+\t* arch/arm-get-next-pcs.c: Fix indentation.\n+\t* arch/arm.c: Fix indentation.\n+\t* arm-linux-nat.c: Fix indentation.\n+\t* arm-linux-tdep.c: Fix indentation.\n+\t* arm-nbsd-tdep.c: Fix indentation.\n+\t* arm-pikeos-tdep.c: Fix indentation.\n+\t* arm-tdep.c: Fix indentation.\n+\t* arm-tdep.h: Fix indentation.\n+\t* arm-wince-tdep.c: Fix indentation.\n+\t* auto-load.c: Fix indentation.\n+\t* auxv.c: Fix indentation.\n+\t* avr-tdep.c: Fix indentation.\n+\t* ax-gdb.c: Fix indentation.\n+\t* ax-general.c: Fix indentation.\n+\t* bfin-linux-tdep.c: Fix indentation.\n+\t* block.c: Fix indentation.\n+\t* block.h: Fix indentation.\n+\t* blockframe.c: Fix indentation.\n+\t* bpf-tdep.c: Fix indentation.\n+\t* break-catch-sig.c: Fix indentation.\n+\t* break-catch-syscall.c: Fix indentation.\n+\t* break-catch-throw.c: Fix indentation.\n+\t* breakpoint.c: Fix indentation.\n+\t* breakpoint.h: Fix indentation.\n+\t* bsd-uthread.c: Fix indentation.\n+\t* btrace.c: Fix indentation.\n+\t* build-id.c: Fix indentation.\n+\t* buildsym-legacy.h: Fix indentation.\n+\t* buildsym.c: Fix indentation.\n+\t* c-typeprint.c: Fix indentation.\n+\t* c-valprint.c: Fix indentation.\n+\t* c-varobj.c: Fix indentation.\n+\t* charset.c: Fix indentation.\n+\t* cli/cli-cmds.c: Fix indentation.\n+\t* cli/cli-decode.c: Fix indentation.\n+\t* cli/cli-decode.h: Fix indentation.\n+\t* cli/cli-script.c: Fix indentation.\n+\t* cli/cli-setshow.c: Fix indentation.\n+\t* coff-pe-read.c: Fix indentation.\n+\t* coffread.c: Fix indentation.\n+\t* compile/compile-cplus-types.c: Fix indentation.\n+\t* compile/compile-object-load.c: Fix indentation.\n+\t* compile/compile-object-run.c: Fix indentation.\n+\t* completer.c: Fix indentation.\n+\t* corefile.c: Fix indentation.\n+\t* corelow.c: Fix indentation.\n+\t* cp-abi.h: Fix indentation.\n+\t* cp-namespace.c: Fix indentation.\n+\t* cp-support.c: Fix indentation.\n+\t* cp-valprint.c: Fix indentation.\n+\t* cris-linux-tdep.c: Fix indentation.\n+\t* cris-tdep.c: Fix indentation.\n+\t* darwin-nat-info.c: Fix indentation.\n+\t* darwin-nat.c: Fix indentation.\n+\t* darwin-nat.h: Fix indentation.\n+\t* dbxread.c: Fix indentation.\n+\t* dcache.c: Fix indentation.\n+\t* disasm.c: Fix indentation.\n+\t* dtrace-probe.c: Fix indentation.\n+\t* dwarf2/abbrev.c: Fix indentation.\n+\t* dwarf2/attribute.c: Fix indentation.\n+\t* dwarf2/expr.c: Fix indentation.\n+\t* dwarf2/frame.c: Fix indentation.\n+\t* dwarf2/index-cache.c: Fix indentation.\n+\t* dwarf2/index-write.c: Fix indentation.\n+\t* dwarf2/line-header.c: Fix indentation.\n+\t* dwarf2/loc.c: Fix indentation.\n+\t* dwarf2/macro.c: Fix indentation.\n+\t* dwarf2/read.c: Fix indentation.\n+\t* dwarf2/read.h: Fix indentation.\n+\t* elfread.c: Fix indentation.\n+\t* eval.c: Fix indentation.\n+\t* event-top.c: Fix indentation.\n+\t* exec.c: Fix indentation.\n+\t* exec.h: Fix indentation.\n+\t* expprint.c: Fix indentation.\n+\t* f-lang.c: Fix indentation.\n+\t* f-typeprint.c: Fix indentation.\n+\t* f-valprint.c: Fix indentation.\n+\t* fbsd-nat.c: Fix indentation.\n+\t* fbsd-tdep.c: Fix indentation.\n+\t* findvar.c: Fix indentation.\n+\t* fork-child.c: Fix indentation.\n+\t* frame-unwind.c: Fix indentation.\n+\t* frame-unwind.h: Fix indentation.\n+\t* frame.c: Fix indentation.\n+\t* frv-linux-tdep.c: Fix indentation.\n+\t* frv-tdep.c: Fix indentation.\n+\t* frv-tdep.h: Fix indentation.\n+\t* ft32-tdep.c: Fix indentation.\n+\t* gcore.c: Fix indentation.\n+\t* gdb_bfd.c: Fix indentation.\n+\t* gdbarch.sh: Fix indentation.\n+\t* gdbarch.c: Re-generate\n+\t* gdbarch.h: Re-generate.\n+\t* gdbcore.h: Fix indentation.\n+\t* gdbthread.h: Fix indentation.\n+\t* gdbtypes.c: Fix indentation.\n+\t* gdbtypes.h: Fix indentation.\n+\t* glibc-tdep.c: Fix indentation.\n+\t* gnu-nat.c: Fix indentation.\n+\t* gnu-nat.h: Fix indentation.\n+\t* gnu-v2-abi.c: Fix indentation.\n+\t* gnu-v3-abi.c: Fix indentation.\n+\t* go32-nat.c: Fix indentation.\n+\t* guile/guile-internal.h: Fix indentation.\n+\t* guile/scm-cmd.c: Fix indentation.\n+\t* guile/scm-frame.c: Fix indentation.\n+\t* guile/scm-iterator.c: Fix indentation.\n+\t* guile/scm-math.c: Fix indentation.\n+\t* guile/scm-ports.c: Fix indentation.\n+\t* guile/scm-pretty-print.c: Fix indentation.\n+\t* guile/scm-value.c: Fix indentation.\n+\t* h8300-tdep.c: Fix indentation.\n+\t* hppa-linux-nat.c: Fix indentation.\n+\t* hppa-linux-tdep.c: Fix indentation.\n+\t* hppa-nbsd-nat.c: Fix indentation.\n+\t* hppa-nbsd-tdep.c: Fix indentation.\n+\t* hppa-obsd-nat.c: Fix indentation.\n+\t* hppa-tdep.c: Fix indentation.\n+\t* hppa-tdep.h: Fix indentation.\n+\t* i386-bsd-nat.c: Fix indentation.\n+\t* i386-darwin-nat.c: Fix indentation.\n+\t* i386-darwin-tdep.c: Fix indentation.\n+\t* i386-dicos-tdep.c: Fix indentation.\n+\t* i386-gnu-nat.c: Fix indentation.\n+\t* i386-linux-nat.c: Fix indentation.\n+\t* i386-linux-tdep.c: Fix indentation.\n+\t* i386-nto-tdep.c: Fix indentation.\n+\t* i386-obsd-tdep.c: Fix indentation.\n+\t* i386-sol2-nat.c: Fix indentation.\n+\t* i386-tdep.c: Fix indentation.\n+\t* i386-tdep.h: Fix indentation.\n+\t* i386-windows-tdep.c: Fix indentation.\n+\t* i387-tdep.c: Fix indentation.\n+\t* i387-tdep.h: Fix indentation.\n+\t* ia64-libunwind-tdep.c: Fix indentation.\n+\t* ia64-libunwind-tdep.h: Fix indentation.\n+\t* ia64-linux-nat.c: Fix indentation.\n+\t* ia64-linux-tdep.c: Fix indentation.\n+\t* ia64-tdep.c: Fix indentation.\n+\t* ia64-tdep.h: Fix indentation.\n+\t* ia64-vms-tdep.c: Fix indentation.\n+\t* infcall.c: Fix indentation.\n+\t* infcmd.c: Fix indentation.\n+\t* inferior.c: Fix indentation.\n+\t* infrun.c: Fix indentation.\n+\t* iq2000-tdep.c: Fix indentation.\n+\t* language.c: Fix indentation.\n+\t* linespec.c: Fix indentation.\n+\t* linux-fork.c: Fix indentation.\n+\t* linux-nat.c: Fix indentation.\n+\t* linux-tdep.c: Fix indentation.\n+\t* linux-thread-db.c: Fix indentation.\n+\t* lm32-tdep.c: Fix indentation.\n+\t* m2-lang.c: Fix indentation.\n+\t* m2-typeprint.c: Fix indentation.\n+\t* m2-valprint.c: Fix indentation.\n+\t* m32c-tdep.c: Fix indentation.\n+\t* m32r-linux-tdep.c: Fix indentation.\n+\t* m32r-tdep.c: Fix indentation.\n+\t* m68hc11-tdep.c: Fix indentation.\n+\t* m68k-bsd-nat.c: Fix indentation.\n+\t* m68k-linux-nat.c: Fix indentation.\n+\t* m68k-linux-tdep.c: Fix indentation.\n+\t* m68k-tdep.c: Fix indentation.\n+\t* machoread.c: Fix indentation.\n+\t* macrocmd.c: Fix indentation.\n+\t* macroexp.c: Fix indentation.\n+\t* macroscope.c: Fix indentation.\n+\t* macrotab.c: Fix indentation.\n+\t* macrotab.h: Fix indentation.\n+\t* main.c: Fix indentation.\n+\t* mdebugread.c: Fix indentation.\n+\t* mep-tdep.c: Fix indentation.\n+\t* mi/mi-cmd-catch.c: Fix indentation.\n+\t* mi/mi-cmd-disas.c: Fix indentation.\n+\t* mi/mi-cmd-env.c: Fix indentation.\n+\t* mi/mi-cmd-stack.c: Fix indentation.\n+\t* mi/mi-cmd-var.c: Fix indentation.\n+\t* mi/mi-cmds.c: Fix indentation.\n+\t* mi/mi-main.c: Fix indentation.\n+\t* mi/mi-parse.c: Fix indentation.\n+\t* microblaze-tdep.c: Fix indentation.\n+\t* minidebug.c: Fix indentation.\n+\t* minsyms.c: Fix indentation.\n+\t* mips-linux-nat.c: Fix indentation.\n+\t* mips-linux-tdep.c: Fix indentation.\n+\t* mips-nbsd-tdep.c: Fix indentation.\n+\t* mips-tdep.c: Fix indentation.\n+\t* mn10300-linux-tdep.c: Fix indentation.\n+\t* mn10300-tdep.c: Fix indentation.\n+\t* moxie-tdep.c: Fix indentation.\n+\t* msp430-tdep.c: Fix indentation.\n+\t* namespace.h: Fix indentation.\n+\t* nat/fork-inferior.c: Fix indentation.\n+\t* nat/gdb_ptrace.h: Fix indentation.\n+\t* nat/linux-namespaces.c: Fix indentation.\n+\t* nat/linux-osdata.c: Fix indentation.\n+\t* nat/netbsd-nat.c: Fix indentation.\n+\t* nat/x86-dregs.c: Fix indentation.\n+\t* nbsd-nat.c: Fix indentation.\n+\t* nbsd-tdep.c: Fix indentation.\n+\t* nios2-linux-tdep.c: Fix indentation.\n+\t* nios2-tdep.c: Fix indentation.\n+\t* nto-procfs.c: Fix indentation.\n+\t* nto-tdep.c: Fix indentation.\n+\t* objfiles.c: Fix indentation.\n+\t* objfiles.h: Fix indentation.\n+\t* opencl-lang.c: Fix indentation.\n+\t* or1k-tdep.c: Fix indentation.\n+\t* osabi.c: Fix indentation.\n+\t* osabi.h: Fix indentation.\n+\t* osdata.c: Fix indentation.\n+\t* p-lang.c: Fix indentation.\n+\t* p-typeprint.c: Fix indentation.\n+\t* p-valprint.c: Fix indentation.\n+\t* parse.c: Fix indentation.\n+\t* ppc-linux-nat.c: Fix indentation.\n+\t* ppc-linux-tdep.c: Fix indentation.\n+\t* ppc-nbsd-nat.c: Fix indentation.\n+\t* ppc-nbsd-tdep.c: Fix indentation.\n+\t* ppc-obsd-nat.c: Fix indentation.\n+\t* ppc-ravenscar-thread.c: Fix indentation.\n+\t* ppc-sysv-tdep.c: Fix indentation.\n+\t* ppc64-tdep.c: Fix indentation.\n+\t* printcmd.c: Fix indentation.\n+\t* proc-api.c: Fix indentation.\n+\t* producer.c: Fix indentation.\n+\t* producer.h: Fix indentation.\n+\t* prologue-value.c: Fix indentation.\n+\t* prologue-value.h: Fix indentation.\n+\t* psymtab.c: Fix indentation.\n+\t* python/py-arch.c: Fix indentation.\n+\t* python/py-bpevent.c: Fix indentation.\n+\t* python/py-event.c: Fix indentation.\n+\t* python/py-event.h: Fix indentation.\n+\t* python/py-finishbreakpoint.c: Fix indentation.\n+\t* python/py-frame.c: Fix indentation.\n+\t* python/py-framefilter.c: Fix indentation.\n+\t* python/py-inferior.c: Fix indentation.\n+\t* python/py-infthread.c: Fix indentation.\n+\t* python/py-objfile.c: Fix indentation.\n+\t* python/py-prettyprint.c: Fix indentation.\n+\t* python/py-registers.c: Fix indentation.\n+\t* python/py-signalevent.c: Fix indentation.\n+\t* python/py-stopevent.c: Fix indentation.\n+\t* python/py-stopevent.h: Fix indentation.\n+\t* python/py-threadevent.c: Fix indentation.\n+\t* python/py-tui.c: Fix indentation.\n+\t* python/py-unwind.c: Fix indentation.\n+\t* python/py-value.c: Fix indentation.\n+\t* python/py-xmethods.c: Fix indentation.\n+\t* python/python-internal.h: Fix indentation.\n+\t* python/python.c: Fix indentation.\n+\t* ravenscar-thread.c: Fix indentation.\n+\t* record-btrace.c: Fix indentation.\n+\t* record-full.c: Fix indentation.\n+\t* record.c: Fix indentation.\n+\t* reggroups.c: Fix indentation.\n+\t* regset.h: Fix indentation.\n+\t* remote-fileio.c: Fix indentation.\n+\t* remote.c: Fix indentation.\n+\t* reverse.c: Fix indentation.\n+\t* riscv-linux-tdep.c: Fix indentation.\n+\t* riscv-ravenscar-thread.c: Fix indentation.\n+\t* riscv-tdep.c: Fix indentation.\n+\t* rl78-tdep.c: Fix indentation.\n+\t* rs6000-aix-tdep.c: Fix indentation.\n+\t* rs6000-lynx178-tdep.c: Fix indentation.\n+\t* rs6000-nat.c: Fix indentation.\n+\t* rs6000-tdep.c: Fix indentation.\n+\t* rust-lang.c: Fix indentation.\n+\t* rx-tdep.c: Fix indentation.\n+\t* s12z-tdep.c: Fix indentation.\n+\t* s390-linux-tdep.c: Fix indentation.\n+\t* score-tdep.c: Fix indentation.\n+\t* ser-base.c: Fix indentation.\n+\t* ser-mingw.c: Fix indentation.\n+\t* ser-uds.c: Fix indentation.\n+\t* ser-unix.c: Fix indentation.\n+\t* serial.c: Fix indentation.\n+\t* sh-linux-tdep.c: Fix indentation.\n+\t* sh-nbsd-tdep.c: Fix indentation.\n+\t* sh-tdep.c: Fix indentation.\n+\t* skip.c: Fix indentation.\n+\t* sol-thread.c: Fix indentation.\n+\t* solib-aix.c: Fix indentation.\n+\t* solib-darwin.c: Fix indentation.\n+\t* solib-frv.c: Fix indentation.\n+\t* solib-svr4.c: Fix indentation.\n+\t* solib.c: Fix indentation.\n+\t* source.c: Fix indentation.\n+\t* sparc-linux-tdep.c: Fix indentation.\n+\t* sparc-nbsd-tdep.c: Fix indentation.\n+\t* sparc-obsd-tdep.c: Fix indentation.\n+\t* sparc-ravenscar-thread.c: Fix indentation.\n+\t* sparc-tdep.c: Fix indentation.\n+\t* sparc64-linux-tdep.c: Fix indentation.\n+\t* sparc64-nbsd-tdep.c: Fix indentation.\n+\t* sparc64-obsd-tdep.c: Fix indentation.\n+\t* sparc64-tdep.c: Fix indentation.\n+\t* stabsread.c: Fix indentation.\n+\t* stack.c: Fix indentation.\n+\t* stap-probe.c: Fix indentation.\n+\t* stubs/ia64vms-stub.c: Fix indentation.\n+\t* stubs/m32r-stub.c: Fix indentation.\n+\t* stubs/m68k-stub.c: Fix indentation.\n+\t* stubs/sh-stub.c: Fix indentation.\n+\t* stubs/sparc-stub.c: Fix indentation.\n+\t* symfile-mem.c: Fix indentation.\n+\t* symfile.c: Fix indentation.\n+\t* symfile.h: Fix indentation.\n+\t* symmisc.c: Fix indentation.\n+\t* symtab.c: Fix indentation.\n+\t* symtab.h: Fix indentation.\n+\t* target-float.c: Fix indentation.\n+\t* target.c: Fix indentation.\n+\t* target.h: Fix indentation.\n+\t* tic6x-tdep.c: Fix indentation.\n+\t* tilegx-linux-tdep.c: Fix indentation.\n+\t* tilegx-tdep.c: Fix indentation.\n+\t* top.c: Fix indentation.\n+\t* tracefile-tfile.c: Fix indentation.\n+\t* tracepoint.c: Fix indentation.\n+\t* tui/tui-disasm.c: Fix indentation.\n+\t* tui/tui-io.c: Fix indentation.\n+\t* tui/tui-regs.c: Fix indentation.\n+\t* tui/tui-stack.c: Fix indentation.\n+\t* tui/tui-win.c: Fix indentation.\n+\t* tui/tui-winsource.c: Fix indentation.\n+\t* tui/tui.c: Fix indentation.\n+\t* typeprint.c: Fix indentation.\n+\t* ui-out.h: Fix indentation.\n+\t* unittests/copy_bitwise-selftests.c: Fix indentation.\n+\t* unittests/memory-map-selftests.c: Fix indentation.\n+\t* utils.c: Fix indentation.\n+\t* v850-tdep.c: Fix indentation.\n+\t* valarith.c: Fix indentation.\n+\t* valops.c: Fix indentation.\n+\t* valprint.c: Fix indentation.\n+\t* valprint.h: Fix indentation.\n+\t* value.c: Fix indentation.\n+\t* value.h: Fix indentation.\n+\t* varobj.c: Fix indentation.\n+\t* vax-tdep.c: Fix indentation.\n+\t* windows-nat.c: Fix indentation.\n+\t* windows-tdep.c: Fix indentation.\n+\t* xcoffread.c: Fix indentation.\n+\t* xml-syscall.c: Fix indentation.\n+\t* xml-tdesc.c: Fix indentation.\n+\t* xstormy16-tdep.c: Fix indentation.\n+\t* xtensa-config.c: Fix indentation.\n+\t* xtensa-linux-nat.c: Fix indentation.\n+\t* xtensa-linux-tdep.c: Fix indentation.\n+\t* xtensa-tdep.c: Fix indentation.\n+\n 2020-11-02  Andrew Burgess  <andrew.burgess@embecosm.com>\n \t    Craig Blackmore   <craig.blackmore@embecosm.com>\n "
    },
    {
      "sha": "c9898bdafda6c65b55c62c83250c6d8d85d576ef",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1452,7 +1452,7 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   /* Shared library handling.  */\n   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);"
    },
    {
      "sha": "666bf9c421d09dad79c7854cd96db3b068264651",
      "filename": "gdb/aarch64-ravenscar-thread.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-ravenscar-thread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -81,7 +81,7 @@ struct ravenscar_reg_info\n \n static void\n supply_register_at_address (struct regcache *regcache, int regnum,\n-                            CORE_ADDR register_addr)\n+\t\t\t    CORE_ADDR register_addr)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   int buf_size = register_size (gdbarch, regnum);\n@@ -125,12 +125,12 @@ aarch64_ravenscar_generic_fetch_registers\n   for (current_regnum = 0; current_regnum < num_regs; current_regnum++)\n     {\n       if (register_in_thread_descriptor_p (reg_info, current_regnum))\n-        {\n-          current_address = thread_descriptor_address\n-            + reg_info->context_offsets[current_regnum];\n-          supply_register_at_address (regcache, current_regnum,\n-                                      current_address);\n-        }\n+\t{\n+\t  current_address = thread_descriptor_address\n+\t    + reg_info->context_offsets[current_regnum];\n+\t  supply_register_at_address (regcache, current_regnum,\n+\t\t\t\t      current_address);\n+\t}\n     }\n }\n \n@@ -155,8 +155,8 @@ aarch64_ravenscar_generic_store_registers\n \n   regcache->raw_collect (regnum, buf);\n   write_memory (register_address,\n-                buf,\n-                buf_size);\n+\t\tbuf,\n+\t\tbuf_size);\n }\n \n /* The ravenscar_reg_info for most Aarch64 targets.  */"
    },
    {
      "sha": "2c1d888904a980c9bdf6ada65be741a385416fdb",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 258,
      "deletions": 258,
      "changes": 516,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -210,7 +210,7 @@ struct aarch64_prologue_cache\n \n static void\n show_aarch64_debug (struct ui_file *file, int from_tty,\n-                    struct cmd_list_element *c, const char *value)\n+\t\t    struct cmd_list_element *c, const char *value)\n {\n   fprintf_filtered (file, _(\"AArch64 debugging is %s.\\n\"), value);\n }\n@@ -1093,17 +1093,17 @@ aarch64_prologue_prev_register (struct frame_info *this_frame,\n      identified by the next frame's stack pointer at the time of the\n      call.  The value was already reconstructed into PREV_SP.  */\n   /*\n-         +----------+  ^\n-         | saved lr |  |\n+\t +----------+  ^\n+\t | saved lr |  |\n       +->| saved fp |--+\n       |  |          |\n       |  |          |     <- Previous SP\n       |  +----------+\n       |  | saved lr |\n       +--| saved fp |<- FP\n-         |          |\n-         |          |<- SP\n-         +----------+  */\n+\t |          |\n+\t |          |<- SP\n+\t +----------+  */\n   if (prev_regnum == AARCH64_SP_REGNUM)\n     return frame_unwind_got_constant (this_frame, prev_regnum,\n \t\t\t\t      cache->prev_sp);\n@@ -2288,8 +2288,8 @@ aarch64_extract_return_value (struct type *type, struct regcache *regs,\n   else\n     {\n       /* For a structure or union the behaviour is as if the value had\n-         been stored to word-aligned memory and then loaded into\n-         registers with 64-bit load instruction(s).  */\n+\t been stored to word-aligned memory and then loaded into\n+\t registers with 64-bit load instruction(s).  */\n       int len = TYPE_LENGTH (type);\n       int regno = AARCH64_X0_REGNUM;\n       bfd_byte buf[X_REGISTER_SIZE];\n@@ -2327,7 +2327,7 @@ aarch64_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n   if (TYPE_LENGTH (type) > 16)\n     {\n       /* PCS B.6 Aggregates larger than 16 bytes are passed by\n-         invisible reference.  */\n+\t invisible reference.  */\n \n       return 1;\n     }\n@@ -3627,29 +3627,29 @@ When on, AArch64 specific debugging is enabled.\"),\n /* AArch64 process record-replay related structures, defines etc.  */\n \n #define REG_ALLOC(REGS, LENGTH, RECORD_BUF) \\\n-        do  \\\n-          { \\\n-            unsigned int reg_len = LENGTH; \\\n-            if (reg_len) \\\n-              { \\\n-                REGS = XNEWVEC (uint32_t, reg_len); \\\n-                memcpy(&REGS[0], &RECORD_BUF[0], sizeof(uint32_t)*LENGTH); \\\n-              } \\\n-          } \\\n-        while (0)\n+\tdo  \\\n+\t  { \\\n+\t    unsigned int reg_len = LENGTH; \\\n+\t    if (reg_len) \\\n+\t      { \\\n+\t\tREGS = XNEWVEC (uint32_t, reg_len); \\\n+\t\tmemcpy(&REGS[0], &RECORD_BUF[0], sizeof(uint32_t)*LENGTH); \\\n+\t      } \\\n+\t  } \\\n+\twhile (0)\n \n #define MEM_ALLOC(MEMS, LENGTH, RECORD_BUF) \\\n-        do  \\\n-          { \\\n-            unsigned int mem_len = LENGTH; \\\n-            if (mem_len) \\\n-            { \\\n-              MEMS =  XNEWVEC (struct aarch64_mem_r, mem_len);  \\\n-              memcpy(&MEMS->len, &RECORD_BUF[0], \\\n-                     sizeof(struct aarch64_mem_r) * LENGTH); \\\n-            } \\\n-          } \\\n-          while (0)\n+\tdo  \\\n+\t  { \\\n+\t    unsigned int mem_len = LENGTH; \\\n+\t    if (mem_len) \\\n+\t    { \\\n+\t      MEMS =  XNEWVEC (struct aarch64_mem_r, mem_len);  \\\n+\t      memcpy(&MEMS->len, &RECORD_BUF[0], \\\n+\t\t     sizeof(struct aarch64_mem_r) * LENGTH); \\\n+\t    } \\\n+\t  } \\\n+\t  while (0)\n \n /* AArch64 record/replay structures and enumerations.  */\n \n@@ -3907,46 +3907,46 @@ aarch64_record_asimd_load_store (insn_decode_record *aarch64_insn_r)\n       uint8_t sindex, scale, selem, esize, replicate = 0;\n       scale = opcode_bits >> 2;\n       selem = ((opcode_bits & 0x02) |\n-              bit (aarch64_insn_r->aarch64_insn, 21)) + 1;\n+\t      bit (aarch64_insn_r->aarch64_insn, 21)) + 1;\n       switch (scale)\n-        {\n-        case 1:\n-          if (size_bits & 0x01)\n-            return AARCH64_RECORD_UNKNOWN;\n-          break;\n-        case 2:\n-          if ((size_bits >> 1) & 0x01)\n-            return AARCH64_RECORD_UNKNOWN;\n-          if (size_bits & 0x01)\n-            {\n-              if (!((opcode_bits >> 1) & 0x01))\n-                scale = 3;\n-              else\n-                return AARCH64_RECORD_UNKNOWN;\n-            }\n-          break;\n-        case 3:\n-          if (bit (aarch64_insn_r->aarch64_insn, 22) && !(opcode_bits & 0x01))\n-            {\n-              scale = size_bits;\n-              replicate = 1;\n-              break;\n-            }\n-          else\n-            return AARCH64_RECORD_UNKNOWN;\n-        default:\n-          break;\n-        }\n+\t{\n+\tcase 1:\n+\t  if (size_bits & 0x01)\n+\t    return AARCH64_RECORD_UNKNOWN;\n+\t  break;\n+\tcase 2:\n+\t  if ((size_bits >> 1) & 0x01)\n+\t    return AARCH64_RECORD_UNKNOWN;\n+\t  if (size_bits & 0x01)\n+\t    {\n+\t      if (!((opcode_bits >> 1) & 0x01))\n+\t\tscale = 3;\n+\t      else\n+\t\treturn AARCH64_RECORD_UNKNOWN;\n+\t    }\n+\t  break;\n+\tcase 3:\n+\t  if (bit (aarch64_insn_r->aarch64_insn, 22) && !(opcode_bits & 0x01))\n+\t    {\n+\t      scale = size_bits;\n+\t      replicate = 1;\n+\t      break;\n+\t    }\n+\t  else\n+\t    return AARCH64_RECORD_UNKNOWN;\n+\tdefault:\n+\t  break;\n+\t}\n       esize = 8 << scale;\n       if (replicate)\n-        for (sindex = 0; sindex < selem; sindex++)\n-          {\n-            record_buf[reg_index++] = reg_rt + AARCH64_V0_REGNUM;\n-            reg_rt = (reg_rt + 1) % 32;\n-          }\n+\tfor (sindex = 0; sindex < selem; sindex++)\n+\t  {\n+\t    record_buf[reg_index++] = reg_rt + AARCH64_V0_REGNUM;\n+\t    reg_rt = (reg_rt + 1) % 32;\n+\t  }\n       else\n-        {\n-          for (sindex = 0; sindex < selem; sindex++)\n+\t{\n+\t  for (sindex = 0; sindex < selem; sindex++)\n \t    {\n \t      if (bit (aarch64_insn_r->aarch64_insn, 22))\n \t\trecord_buf[reg_index++] = reg_rt + AARCH64_V0_REGNUM;\n@@ -3958,7 +3958,7 @@ aarch64_record_asimd_load_store (insn_decode_record *aarch64_insn_r)\n \t      addr_offset = addr_offset + (esize / 8);\n \t      reg_rt = (reg_rt + 1) % 32;\n \t    }\n-        }\n+\t}\n     }\n   /* Load/store multiple structure.  */\n   else\n@@ -3968,69 +3968,69 @@ aarch64_record_asimd_load_store (insn_decode_record *aarch64_insn_r)\n \n       esize = 8 << size_bits;\n       if (bit (aarch64_insn_r->aarch64_insn, 30))\n-        elements = 128 / esize;\n+\telements = 128 / esize;\n       else\n-        elements = 64 / esize;\n+\telements = 64 / esize;\n \n       switch (opcode_bits)\n-        {\n-        /*LD/ST4 (4 Registers).  */\n-        case 0:\n-          rpt = 1;\n-          selem = 4;\n-          break;\n-        /*LD/ST1 (4 Registers).  */\n-        case 2:\n-          rpt = 4;\n-          selem = 1;\n-          break;\n-        /*LD/ST3 (3 Registers).  */\n-        case 4:\n-          rpt = 1;\n-          selem = 3;\n-          break;\n-        /*LD/ST1 (3 Registers).  */\n-        case 6:\n-          rpt = 3;\n-          selem = 1;\n-          break;\n-        /*LD/ST1 (1 Register).  */\n-        case 7:\n-          rpt = 1;\n-          selem = 1;\n-          break;\n-        /*LD/ST2 (2 Registers).  */\n-        case 8:\n-          rpt = 1;\n-          selem = 2;\n-          break;\n-        /*LD/ST1 (2 Registers).  */\n-        case 10:\n-          rpt = 2;\n-          selem = 1;\n-          break;\n-        default:\n-          return AARCH64_RECORD_UNSUPPORTED;\n-          break;\n-        }\n+\t{\n+\t/*LD/ST4 (4 Registers).  */\n+\tcase 0:\n+\t  rpt = 1;\n+\t  selem = 4;\n+\t  break;\n+\t/*LD/ST1 (4 Registers).  */\n+\tcase 2:\n+\t  rpt = 4;\n+\t  selem = 1;\n+\t  break;\n+\t/*LD/ST3 (3 Registers).  */\n+\tcase 4:\n+\t  rpt = 1;\n+\t  selem = 3;\n+\t  break;\n+\t/*LD/ST1 (3 Registers).  */\n+\tcase 6:\n+\t  rpt = 3;\n+\t  selem = 1;\n+\t  break;\n+\t/*LD/ST1 (1 Register).  */\n+\tcase 7:\n+\t  rpt = 1;\n+\t  selem = 1;\n+\t  break;\n+\t/*LD/ST2 (2 Registers).  */\n+\tcase 8:\n+\t  rpt = 1;\n+\t  selem = 2;\n+\t  break;\n+\t/*LD/ST1 (2 Registers).  */\n+\tcase 10:\n+\t  rpt = 2;\n+\t  selem = 1;\n+\t  break;\n+\tdefault:\n+\t  return AARCH64_RECORD_UNSUPPORTED;\n+\t  break;\n+\t}\n       for (rindex = 0; rindex < rpt; rindex++)\n-        for (eindex = 0; eindex < elements; eindex++)\n-          {\n-            uint8_t reg_tt, sindex;\n-            reg_tt = (reg_rt + rindex) % 32;\n-            for (sindex = 0; sindex < selem; sindex++)\n-              {\n-                if (bit (aarch64_insn_r->aarch64_insn, 22))\n-                  record_buf[reg_index++] = reg_tt + AARCH64_V0_REGNUM;\n-                else\n-                  {\n-                    record_buf_mem[mem_index++] = esize / 8;\n-                    record_buf_mem[mem_index++] = address + addr_offset;\n-                  }\n-                addr_offset = addr_offset + (esize / 8);\n-                reg_tt = (reg_tt + 1) % 32;\n-              }\n-          }\n+\tfor (eindex = 0; eindex < elements; eindex++)\n+\t  {\n+\t    uint8_t reg_tt, sindex;\n+\t    reg_tt = (reg_rt + rindex) % 32;\n+\t    for (sindex = 0; sindex < selem; sindex++)\n+\t      {\n+\t\tif (bit (aarch64_insn_r->aarch64_insn, 22))\n+\t\t  record_buf[reg_index++] = reg_tt + AARCH64_V0_REGNUM;\n+\t\telse\n+\t\t  {\n+\t\t    record_buf_mem[mem_index++] = esize / 8;\n+\t\t    record_buf_mem[mem_index++] = address + addr_offset;\n+\t\t  }\n+\t\taddr_offset = addr_offset + (esize / 8);\n+\t\treg_tt = (reg_tt + 1) % 32;\n+\t      }\n+\t  }\n     }\n \n   if (bit (aarch64_insn_r->aarch64_insn, 23))\n@@ -4039,9 +4039,9 @@ aarch64_record_asimd_load_store (insn_decode_record *aarch64_insn_r)\n   aarch64_insn_r->reg_rec_count = reg_index;\n   aarch64_insn_r->mem_rec_count = mem_index / 2;\n   MEM_ALLOC (aarch64_insn_r->aarch64_mems, aarch64_insn_r->mem_rec_count,\n-             record_buf_mem);\n+\t     record_buf_mem);\n   REG_ALLOC (aarch64_insn_r->aarch64_regs, aarch64_insn_r->reg_rec_count,\n-             record_buf);\n+\t     record_buf);\n   return AARCH64_RECORD_SUCCESS;\n }\n \n@@ -4112,9 +4112,9 @@ aarch64_record_load_store (insn_decode_record *aarch64_insn_r)\n       if (record_debug)\n \tdebug_printf (\"Process record: load register (literal)\\n\");\n       if (vector_flag)\n-        record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n+\trecord_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n       else\n-        record_buf[0] = reg_rt;\n+\trecord_buf[0] = reg_rt;\n       aarch64_insn_r->reg_rec_count = 1;\n     }\n   /* All types of load/store pair instructions decoding.  */\n@@ -4124,46 +4124,46 @@ aarch64_record_load_store (insn_decode_record *aarch64_insn_r)\n \tdebug_printf (\"Process record: load/store pair\\n\");\n \n       if (ld_flag)\n-        {\n-          if (vector_flag)\n-            {\n-              record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n-              record_buf[1] = reg_rt2 + AARCH64_V0_REGNUM;\n-            }\n-          else\n-            {\n-              record_buf[0] = reg_rt;\n-              record_buf[1] = reg_rt2;\n-            }\n-          aarch64_insn_r->reg_rec_count = 2;\n-        }\n+\t{\n+\t  if (vector_flag)\n+\t    {\n+\t      record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n+\t      record_buf[1] = reg_rt2 + AARCH64_V0_REGNUM;\n+\t    }\n+\t  else\n+\t    {\n+\t      record_buf[0] = reg_rt;\n+\t      record_buf[1] = reg_rt2;\n+\t    }\n+\t  aarch64_insn_r->reg_rec_count = 2;\n+\t}\n       else\n-        {\n-          uint16_t imm7_off;\n-          imm7_off = bits (aarch64_insn_r->aarch64_insn, 15, 21);\n-          if (!vector_flag)\n-            size_bits = size_bits >> 1;\n-          datasize = 8 << (2 + size_bits);\n-          offset = (imm7_off & 0x40) ? (~imm7_off & 0x007f) + 1 : imm7_off;\n-          offset = offset << (2 + size_bits);\n-          regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n-                                      &address);\n-          if (!((insn_bits24_27 & 0x0b) == 0x08 && insn_bit23))\n-            {\n-              if (imm7_off & 0x40)\n-                address = address - offset;\n-              else\n-                address = address + offset;\n-            }\n-\n-          record_buf_mem[0] = datasize / 8;\n-          record_buf_mem[1] = address;\n-          record_buf_mem[2] = datasize / 8;\n-          record_buf_mem[3] = address + (datasize / 8);\n-          aarch64_insn_r->mem_rec_count = 2;\n-        }\n+\t{\n+\t  uint16_t imm7_off;\n+\t  imm7_off = bits (aarch64_insn_r->aarch64_insn, 15, 21);\n+\t  if (!vector_flag)\n+\t    size_bits = size_bits >> 1;\n+\t  datasize = 8 << (2 + size_bits);\n+\t  offset = (imm7_off & 0x40) ? (~imm7_off & 0x007f) + 1 : imm7_off;\n+\t  offset = offset << (2 + size_bits);\n+\t  regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n+\t\t\t\t      &address);\n+\t  if (!((insn_bits24_27 & 0x0b) == 0x08 && insn_bit23))\n+\t    {\n+\t      if (imm7_off & 0x40)\n+\t\taddress = address - offset;\n+\t      else\n+\t\taddress = address + offset;\n+\t    }\n+\n+\t  record_buf_mem[0] = datasize / 8;\n+\t  record_buf_mem[1] = address;\n+\t  record_buf_mem[2] = datasize / 8;\n+\t  record_buf_mem[3] = address + (datasize / 8);\n+\t  aarch64_insn_r->mem_rec_count = 2;\n+\t}\n       if (bit (aarch64_insn_r->aarch64_insn, 23))\n-        record_buf[aarch64_insn_r->reg_rec_count++] = reg_rn;\n+\trecord_buf[aarch64_insn_r->reg_rec_count++] = reg_rn;\n     }\n   /* Load/store register (unsigned immediate) instructions.  */\n   else if ((insn_bits24_27 & 0x0b) == 0x09 && insn_bits28_29 == 0x03)\n@@ -4205,26 +4205,26 @@ aarch64_record_load_store (insn_decode_record *aarch64_insn_r)\n \t}\n \n       if (!ld_flag)\n-        {\n-          offset = bits (aarch64_insn_r->aarch64_insn, 10, 21);\n-          datasize = 8 << size_bits;\n-          regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n-                                      &address);\n-          offset = offset << size_bits;\n-          address = address + offset;\n-\n-          record_buf_mem[0] = datasize >> 3;\n-          record_buf_mem[1] = address;\n-          aarch64_insn_r->mem_rec_count = 1;\n-        }\n+\t{\n+\t  offset = bits (aarch64_insn_r->aarch64_insn, 10, 21);\n+\t  datasize = 8 << size_bits;\n+\t  regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n+\t\t\t\t      &address);\n+\t  offset = offset << size_bits;\n+\t  address = address + offset;\n+\n+\t  record_buf_mem[0] = datasize >> 3;\n+\t  record_buf_mem[1] = address;\n+\t  aarch64_insn_r->mem_rec_count = 1;\n+\t}\n       else\n-        {\n-          if (vector_flag)\n-            record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n-          else\n-            record_buf[0] = reg_rt;\n-          aarch64_insn_r->reg_rec_count = 1;\n-        }\n+\t{\n+\t  if (vector_flag)\n+\t    record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n+\t  else\n+\t    record_buf[0] = reg_rt;\n+\t  aarch64_insn_r->reg_rec_count = 1;\n+\t}\n     }\n   /* Load/store register (register offset) instructions.  */\n   else if ((insn_bits24_27 & 0x0b) == 0x08 && insn_bits28_29 == 0x03\n@@ -4234,42 +4234,42 @@ aarch64_record_load_store (insn_decode_record *aarch64_insn_r)\n \tdebug_printf (\"Process record: load/store (register offset)\\n\");\n       opc = bits (aarch64_insn_r->aarch64_insn, 22, 23);\n       if (!(opc >> 1))\n-        if (opc & 0x01)\n-          ld_flag = 0x01;\n-        else\n-          ld_flag = 0x0;\n+\tif (opc & 0x01)\n+\t  ld_flag = 0x01;\n+\telse\n+\t  ld_flag = 0x0;\n       else\n-        if (size_bits != 0x03)\n-          ld_flag = 0x01;\n-        else\n-          return AARCH64_RECORD_UNKNOWN;\n+\tif (size_bits != 0x03)\n+\t  ld_flag = 0x01;\n+\telse\n+\t  return AARCH64_RECORD_UNKNOWN;\n \n       if (!ld_flag)\n-        {\n-          ULONGEST reg_rm_val;\n-\n-          regcache_raw_read_unsigned (aarch64_insn_r->regcache,\n-                     bits (aarch64_insn_r->aarch64_insn, 16, 20), &reg_rm_val);\n-          if (bit (aarch64_insn_r->aarch64_insn, 12))\n-            offset = reg_rm_val << size_bits;\n-          else\n-            offset = reg_rm_val;\n-          datasize = 8 << size_bits;\n-          regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n-                                      &address);\n-          address = address + offset;\n-          record_buf_mem[0] = datasize >> 3;\n-          record_buf_mem[1] = address;\n-          aarch64_insn_r->mem_rec_count = 1;\n-        }\n+\t{\n+\t  ULONGEST reg_rm_val;\n+\n+\t  regcache_raw_read_unsigned (aarch64_insn_r->regcache,\n+\t\t     bits (aarch64_insn_r->aarch64_insn, 16, 20), &reg_rm_val);\n+\t  if (bit (aarch64_insn_r->aarch64_insn, 12))\n+\t    offset = reg_rm_val << size_bits;\n+\t  else\n+\t    offset = reg_rm_val;\n+\t  datasize = 8 << size_bits;\n+\t  regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n+\t\t\t\t      &address);\n+\t  address = address + offset;\n+\t  record_buf_mem[0] = datasize >> 3;\n+\t  record_buf_mem[1] = address;\n+\t  aarch64_insn_r->mem_rec_count = 1;\n+\t}\n       else\n-        {\n-          if (vector_flag)\n-            record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n-          else\n-            record_buf[0] = reg_rt;\n-          aarch64_insn_r->reg_rec_count = 1;\n-        }\n+\t{\n+\t  if (vector_flag)\n+\t    record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n+\t  else\n+\t    record_buf[0] = reg_rt;\n+\t  aarch64_insn_r->reg_rec_count = 1;\n+\t}\n     }\n   /* Load/store register (immediate and unprivileged) instructions.  */\n   else if ((insn_bits24_27 & 0x0b) == 0x08 && insn_bits28_29 == 0x03\n@@ -4282,54 +4282,54 @@ aarch64_record_load_store (insn_decode_record *aarch64_insn_r)\n \t}\n       opc = bits (aarch64_insn_r->aarch64_insn, 22, 23);\n       if (!(opc >> 1))\n-        if (opc & 0x01)\n-          ld_flag = 0x01;\n-        else\n-          ld_flag = 0x0;\n+\tif (opc & 0x01)\n+\t  ld_flag = 0x01;\n+\telse\n+\t  ld_flag = 0x0;\n       else\n-        if (size_bits != 0x03)\n-          ld_flag = 0x01;\n-        else\n-          return AARCH64_RECORD_UNKNOWN;\n+\tif (size_bits != 0x03)\n+\t  ld_flag = 0x01;\n+\telse\n+\t  return AARCH64_RECORD_UNKNOWN;\n \n       if (!ld_flag)\n-        {\n-          uint16_t imm9_off;\n-          imm9_off = bits (aarch64_insn_r->aarch64_insn, 12, 20);\n-          offset = (imm9_off & 0x0100) ? (((~imm9_off) & 0x01ff) + 1) : imm9_off;\n-          datasize = 8 << size_bits;\n-          regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n-                                      &address);\n-          if (insn_bits10_11 != 0x01)\n-            {\n-              if (imm9_off & 0x0100)\n-                address = address - offset;\n-              else\n-                address = address + offset;\n-            }\n-          record_buf_mem[0] = datasize >> 3;\n-          record_buf_mem[1] = address;\n-          aarch64_insn_r->mem_rec_count = 1;\n-        }\n+\t{\n+\t  uint16_t imm9_off;\n+\t  imm9_off = bits (aarch64_insn_r->aarch64_insn, 12, 20);\n+\t  offset = (imm9_off & 0x0100) ? (((~imm9_off) & 0x01ff) + 1) : imm9_off;\n+\t  datasize = 8 << size_bits;\n+\t  regcache_raw_read_unsigned (aarch64_insn_r->regcache, reg_rn,\n+\t\t\t\t      &address);\n+\t  if (insn_bits10_11 != 0x01)\n+\t    {\n+\t      if (imm9_off & 0x0100)\n+\t\taddress = address - offset;\n+\t      else\n+\t\taddress = address + offset;\n+\t    }\n+\t  record_buf_mem[0] = datasize >> 3;\n+\t  record_buf_mem[1] = address;\n+\t  aarch64_insn_r->mem_rec_count = 1;\n+\t}\n       else\n-        {\n-          if (vector_flag)\n-            record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n-          else\n-            record_buf[0] = reg_rt;\n-          aarch64_insn_r->reg_rec_count = 1;\n-        }\n+\t{\n+\t  if (vector_flag)\n+\t    record_buf[0] = reg_rt + AARCH64_V0_REGNUM;\n+\t  else\n+\t    record_buf[0] = reg_rt;\n+\t  aarch64_insn_r->reg_rec_count = 1;\n+\t}\n       if (insn_bits10_11 == 0x01 || insn_bits10_11 == 0x03)\n-        record_buf[aarch64_insn_r->reg_rec_count++] = reg_rn;\n+\trecord_buf[aarch64_insn_r->reg_rec_count++] = reg_rn;\n     }\n   /* Advanced SIMD load/store instructions.  */\n   else\n     return aarch64_record_asimd_load_store (aarch64_insn_r);\n \n   MEM_ALLOC (aarch64_insn_r->aarch64_mems, aarch64_insn_r->mem_rec_count,\n-             record_buf_mem);\n+\t     record_buf_mem);\n   REG_ALLOC (aarch64_insn_r->aarch64_regs, aarch64_insn_r->reg_rec_count,\n-             record_buf);\n+\t     record_buf);\n   return AARCH64_RECORD_SUCCESS;\n }\n \n@@ -4378,7 +4378,7 @@ aarch64_record_data_proc_simd_fp (insn_decode_record *aarch64_insn_r)\n \t  record_buf[0] = AARCH64_CPSR_REGNUM;\n \t}\n       /* Floating point - data processing (2-source) and\n-         conditional select instructions.  */\n+\t conditional select instructions.  */\n       else if (insn_bits10_11 == 0x02 || insn_bits10_11 == 0x03)\n \t{\n \t  if (record_debug)\n@@ -4435,10 +4435,10 @@ aarch64_record_data_proc_simd_fp (insn_decode_record *aarch64_insn_r)\n \t\t}\n \t      else\n \t\treturn AARCH64_RECORD_UNKNOWN;\n-            }\n+\t    }\n \t  else\n \t    return AARCH64_RECORD_UNKNOWN;\n-        }\n+\t}\n       else\n \treturn AARCH64_RECORD_UNKNOWN;\n     }"
    },
    {
      "sha": "81ce4d84b41bfb5e6c46d10be9c4541ac8aacaf9",
      "filename": "gdb/aarch64-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aarch64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -105,7 +105,7 @@ struct gdbarch_tdep\n const target_desc *aarch64_read_description (uint64_t vq, bool pauth_p);\n \n extern int aarch64_process_record (struct gdbarch *gdbarch,\n-                               struct regcache *regcache, CORE_ADDR addr);\n+\t\t\t       struct regcache *regcache, CORE_ADDR addr);\n \n displaced_step_closure_up\n   aarch64_displaced_step_copy_insn (struct gdbarch *gdbarch,"
    },
    {
      "sha": "83d711cce8bf47b38f429a04bf124802b9e7f478",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 45,
      "deletions": 45,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -208,7 +208,7 @@ primary :\tprimary '(' arglist ')'\n \t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n \t\t\t  write_exp_elt_longcst (pstate, $3);\n \t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t        }\n+\t\t\t}\n \t|\tvar_or_type '(' arglist ')'\n \t\t\t{\n \t\t\t  if ($1 != NULL)\n@@ -248,7 +248,7 @@ primary :\n \t\t\t{ write_exp_elt_opcode (pstate, TERNOP_SLICE); }\n \t|\tvar_or_type '(' simple_exp DOTDOT simple_exp ')'\n \t\t\t{ if ($1 == NULL) \n-                            write_exp_elt_opcode (pstate, TERNOP_SLICE);\n+\t\t\t    write_exp_elt_opcode (pstate, TERNOP_SLICE);\n \t\t\t  else\n \t\t\t    error (_(\"Cannot slice a type\"));\n \t\t\t}\n@@ -280,7 +280,7 @@ primary :\tDOLLAR_VARIABLE /* Various GDB extensions */\n \t;\n \n primary :     \taggregate\n-        ;        \n+\t;        \n \n simple_exp : \tprimary\n \t;\n@@ -380,7 +380,7 @@ relation :\tsimple_exp LEQ simple_exp\n \n relation :\tsimple_exp IN simple_exp DOTDOT simple_exp\n \t\t\t{ write_exp_elt_opcode (pstate, TERNOP_IN_RANGE); }\n-        |       simple_exp IN primary TICK_RANGE tick_arglist\n+\t|       simple_exp IN primary TICK_RANGE tick_arglist\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n \t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $5);\n \t\t\t  write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n@@ -390,27 +390,27 @@ relation :\tsimple_exp IN simple_exp DOTDOT simple_exp\n \t\t\t  if ($3 == NULL)\n \t\t\t    error (_(\"Right operand of 'in' must be type\"));\n \t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t          write_exp_elt_type (pstate, $3);\n-\t\t          write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n+\t\t\t  write_exp_elt_type (pstate, $3);\n+\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n \t\t\t}\n \t|\tsimple_exp NOT IN simple_exp DOTDOT simple_exp\n \t\t\t{ write_exp_elt_opcode (pstate, TERNOP_IN_RANGE);\n-\t\t          write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n+\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n \t\t\t}\n-        |       simple_exp NOT IN primary TICK_RANGE tick_arglist\n+\t|       simple_exp NOT IN primary TICK_RANGE tick_arglist\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n \t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $6);\n \t\t\t  write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n-\t\t          write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n+\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n \t\t\t}\n  \t|\tsimple_exp NOT IN var_or_type\t%prec TICK_ACCESS\n \t\t\t{ \n \t\t\t  if ($4 == NULL)\n \t\t\t    error (_(\"Right operand of 'in' must be type\"));\n \t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t          write_exp_elt_type (pstate, $4);\n-\t\t          write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t          write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n+\t\t\t  write_exp_elt_type (pstate, $4);\n+\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n+\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n \t\t\t}\n \t;\n \n@@ -446,7 +446,7 @@ and_then_exp :\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n \t|\tand_then_exp _AND_ THEN relation\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n-        ;\n+\t;\n \n or_exp :\n \t\trelation OR relation \n@@ -460,13 +460,13 @@ or_else_exp :\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n \t|      or_else_exp OR ELSE relation\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n-        ;\n+\t;\n \n xor_exp :       relation XOR relation\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n \t|\txor_exp XOR relation\n \t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n-        ;\n+\t;\n \n /* Primaries can denote types (OP_TYPE).  In cases such as \n    primary TICK_ADDRESS, where a type would be invalid, it will be\n@@ -494,13 +494,13 @@ primary :\tprimary TICK_ACCESS\n \t| \tprimary TICK_LENGTH tick_arglist\n \t\t\t{ write_int (pstate, $3, type_int (pstate));\n \t\t\t  write_exp_elt_opcode (pstate, OP_ATR_LENGTH); }\n-        |       primary TICK_SIZE\n+\t|       primary TICK_SIZE\n \t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_SIZE); }\n \t|\tprimary TICK_TAG\n \t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_TAG); }\n-        |       opt_type_prefix TICK_MIN '(' exp ',' exp ')'\n+\t|       opt_type_prefix TICK_MIN '(' exp ',' exp ')'\n \t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_MIN); }\n-        |       opt_type_prefix TICK_MAX '(' exp ',' exp ')'\n+\t|       opt_type_prefix TICK_MAX '(' exp ',' exp ')'\n \t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_MAX); }\n \t| \topt_type_prefix TICK_POS '(' exp ')'\n \t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_POS); }\n@@ -517,7 +517,7 @@ tick_arglist :\t\t\t%prec '('\n \t;\n \n type_prefix :\n-                var_or_type\n+\t\tvar_or_type\n \t\t\t{ \n \t\t\t  if ($1 == NULL)\n \t\t\t    error (_(\"Prefix must be type\"));\n@@ -541,7 +541,7 @@ primary\t:\tINT\n \t;\n \n primary\t:\tCHARLIT\n-                  { write_int (pstate,\n+\t\t  { write_int (pstate,\n \t\t\t       convert_char_literal (type_qualifier, $1.val),\n \t\t\t       (type_qualifier == NULL) \n \t\t\t       ? $1.type : type_qualifier);\n@@ -568,7 +568,7 @@ primary\t:\tSTRING\n \n primary :\tTRUEKEYWORD\n \t\t\t{ write_int (pstate, 1, type_boolean (pstate)); }\n-        |\tFALSEKEYWORD\n+\t|\tFALSEKEYWORD\n \t\t\t{ write_int (pstate, 0, type_boolean (pstate)); }\n \t;\n \n@@ -579,7 +579,7 @@ primary\t: \tNEW NAME\n var_or_type:\tNAME   \t    %prec VAR\n \t\t\t\t{ $$ = write_var_or_type (pstate, NULL, $1); }\n \t|\tblock NAME  %prec VAR\n-                                { $$ = write_var_or_type (pstate, $1, $2); }\n+\t\t\t\t{ $$ = write_var_or_type (pstate, $1, $2); }\n \t|       NAME TICK_ACCESS \n \t\t\t{ \n \t\t\t  $$ = write_var_or_type (pstate, NULL, $1);\n@@ -611,7 +611,7 @@ aggregate :\n \t\t\t  write_exp_elt_opcode (pstate, OP_AGGREGATE);\n \t\t\t  write_exp_elt_longcst (pstate, $2);\n \t\t\t  write_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\t\t        }\n+\t\t\t}\n \t;\n \n aggregate_component_list :\n@@ -658,7 +658,7 @@ component_group :\n \t\t\t  write_exp_elt_opcode (pstate, OP_CHOICES);\n \t\t\t  write_exp_elt_longcst (pstate, $1);\n \t\t\t  write_exp_elt_opcode (pstate, OP_CHOICES);\n-\t\t        }\n+\t\t\t}\n \t;\n \n /* We use this somewhat obscure definition in order to handle NAME => and\n@@ -679,10 +679,10 @@ component_associations :\n \t\t\t}\n \t\t    exp { $$ = 1; }\n \t|\tNAME '|' \n-\t\t        { write_name_assoc (pstate, $1); }\n+\t\t\t{ write_name_assoc (pstate, $1); }\n \t\t    component_associations  { $$ = $4 + 1; }\n \t|\tsimple_exp '|'  \n-\t            component_associations  { $$ = $3 + 1; }\n+\t\t    component_associations  { $$ = $3 + 1; }\n \t|\tsimple_exp DOTDOT simple_exp '|'\n \t\t\t{ write_exp_elt_opcode (pstate, OP_DISCRETE_RANGE); }\n \t\t    component_associations  { $$ = $6 + 1; }\n@@ -851,9 +851,9 @@ write_object_renaming (struct parser_state *par_state,\n \n       switch (*renaming_expr) {\n       case 'A':\n-        renaming_expr += 1;\n-        write_exp_elt_opcode (par_state, UNOP_IND);\n-        break;\n+\trenaming_expr += 1;\n+\twrite_exp_elt_opcode (par_state, UNOP_IND);\n+\tbreak;\n       case 'L':\n \tslice_state = LOWER_BOUND;\n \t/* FALLTHROUGH */\n@@ -1124,7 +1124,7 @@ write_ambiguous_var (struct parser_state *par_state,\n \n static int\n ada_nget_field_index (const struct type *type, const char *field_name0,\n-                      int field_name_len, int maybe_missing)\n+\t\t      int field_name_len, int maybe_missing)\n {\n   char *field_name = (char *) alloca ((field_name_len + 1) * sizeof (char));\n \n@@ -1162,20 +1162,20 @@ get_symbol_field_type (struct symbol *sym, char *encoded_field_name)\n \n       fieldno = ada_get_field_index (type, field_name, 1);\n       if (fieldno >= 0)\n-        return type->field (fieldno).type ();\n+\treturn type->field (fieldno).type ();\n \n       subfield_name = field_name;\n       while (*subfield_name != '\\0' && *subfield_name != '.' \n \t     && (subfield_name[0] != '_' || subfield_name[1] != '_'))\n \tsubfield_name += 1;\n \n       if (subfield_name[0] == '\\0')\n-        return NULL;\n+\treturn NULL;\n \n       fieldno = ada_nget_field_index (type, field_name,\n-                                      subfield_name - field_name, 1);\n+\t\t\t\t      subfield_name - field_name, 1);\n       if (fieldno < 0)\n-        return NULL;\n+\treturn NULL;\n \n       type = type->field (fieldno).type ();\n       field_name = subfield_name;\n@@ -1248,7 +1248,7 @@ write_var_or_type (struct parser_state *par_state,\n \t    case ADA_EXCEPTION_RENAMING:\n \t    case ADA_SUBPROGRAM_RENAMING:\n \t      {\n-\t        int alloc_len = renaming_len + name_len - tail_index + 1;\n+\t\tint alloc_len = renaming_len + name_len - tail_index + 1;\n \t\tchar *new_name\n \t\t  = (char *) obstack_alloc (&temp_parse_space, alloc_len);\n \t\tstrncpy (new_name, renaming, renaming_len);\n@@ -1269,21 +1269,21 @@ write_var_or_type (struct parser_state *par_state,\n \n \t  if (type_sym != NULL)\n \t    {\n-              struct type *field_type;\n-              \n-              if (tail_index == name_len)\n+\t      struct type *field_type;\n+\t      \n+\t      if (tail_index == name_len)\n \t\treturn SYMBOL_TYPE (type_sym);\n \n-              /* We have some extraneous characters after the type name.\n-                 If this is an expression \"TYPE_NAME.FIELD0.[...].FIELDN\",\n-                 then try to get the type of FIELDN.  */\n-              field_type\n-                = get_symbol_field_type (type_sym, encoded_name + tail_index);\n-              if (field_type != NULL)\n+\t      /* We have some extraneous characters after the type name.\n+\t\t If this is an expression \"TYPE_NAME.FIELD0.[...].FIELDN\",\n+\t\t then try to get the type of FIELDN.  */\n+\t      field_type\n+\t\t= get_symbol_field_type (type_sym, encoded_name + tail_index);\n+\t      if (field_type != NULL)\n \t\treturn field_type;\n \t      else \n \t\terror (_(\"Invalid attempt to select from type: \\\"%s\\\".\"),\n-                       name0.ptr);\n+\t\t       name0.ptr);\n \t    }\n \t  else if (tail_index == name_len && nsyms == 0)\n \t    {"
    },
    {
      "sha": "a1f5d93fee31f475083036dcdf711a1161f9b556",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 1799,
      "deletions": 1799,
      "changes": 3598,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "336d83f8fcb1b9124ad2006371996a6867f6b6b4",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -85,17 +85,17 @@ enum ada_renaming_category\n     ADA_NOT_RENAMING,\n \n     /* For symbols declared\n-         Foo : TYPE renamed OBJECT;  */\n+\t Foo : TYPE renamed OBJECT;  */\n     ADA_OBJECT_RENAMING,\n \n     /* For symbols declared\n-         Foo : exception renames EXCEPTION;  */\n+\t Foo : exception renames EXCEPTION;  */\n     ADA_EXCEPTION_RENAMING,\n     /* For packages declared\n-          package Foo renames PACKAGE; */\n+\t  package Foo renames PACKAGE; */\n     ADA_PACKAGE_RENAMING,\n     /* For subprograms declared\n-          SUBPROGRAM_SPEC renames SUBPROGRAM;\n+\t  SUBPROGRAM_SPEC renames SUBPROGRAM;\n        (Currently not used).  */\n     ADA_SUBPROGRAM_RENAMING\n   };\n@@ -152,14 +152,14 @@ struct ada_task_info\n extern void ada_ensure_varsize_limit (const struct type *type);\n \n extern int ada_get_field_index (const struct type *type,\n-                                const char *field_name,\n-                                int maybe_missing);\n+\t\t\t\tconst char *field_name,\n+\t\t\t\tint maybe_missing);\n \n extern int ada_parse (struct parser_state *);    /* Defined in ada-exp.y */\n \n-                        /* Defined in ada-typeprint.c */\n+\t\t\t/* Defined in ada-typeprint.c */\n extern void ada_print_type (struct type *, const char *, struct ui_file *, int,\n-                            int, const struct type_print_options *);\n+\t\t\t    int, const struct type_print_options *);\n \n extern void ada_print_typedef (struct type *type, struct symbol *new_symbol,\n \t\t\t       struct ui_file *stream);\n@@ -172,7 +172,7 @@ extern void ada_value_print_inner (struct value *, struct ui_file *, int,\n extern void ada_value_print (struct value *, struct ui_file *,\n \t\t\t     const struct value_print_options *);\n \n-                                /* Defined in ada-lang.c */\n+\t\t\t\t/* Defined in ada-lang.c */\n \n extern void ada_emit_char (int, struct type *, struct ui_file *, int, int);\n \n@@ -183,12 +183,12 @@ extern void ada_printstr (struct ui_file *, struct type *, const gdb_byte *,\n \t\t\t  const struct value_print_options *);\n \n struct value *ada_convert_actual (struct value *actual,\n-                                  struct type *formal_type0);\n+\t\t\t\t  struct type *formal_type0);\n \n extern bool ada_is_access_to_unconstrained_array (struct type *type);\n \n extern struct value *ada_value_subscript (struct value *, int,\n-                                          struct value **);\n+\t\t\t\t\t  struct value **);\n \n extern void ada_fixup_array_indexes_type (struct type *index_desc_type);\n \n@@ -219,7 +219,7 @@ extern const char *ada_decode_symbol (const struct general_symbol_info *);\n extern std::string ada_decode (const char*);\n \n extern int ada_lookup_symbol_list (const char *, const struct block *,\n-                                   domain_enum,\n+\t\t\t\t   domain_enum,\n \t\t\t\t   std::vector<struct block_symbol> *);\n \n extern struct block_symbol ada_lookup_symbol (const char *,\n@@ -247,8 +247,8 @@ extern int ada_is_constrained_packed_array_type (struct type *);\n \n extern struct value *ada_value_primitive_packed_val (struct value *,\n \t\t\t\t\t\t     const gdb_byte *,\n-                                                     long, int, int,\n-                                                     struct type *);\n+\t\t\t\t\t\t     long, int, int,\n+\t\t\t\t\t\t     struct type *);\n \n extern struct type *ada_coerce_to_simple_array_type (struct type *);\n \n@@ -293,7 +293,7 @@ extern int ada_which_variant_applies (struct type *, struct value *);\n \n extern struct type *ada_to_fixed_type (struct type *, const gdb_byte *,\n \t\t\t\t       CORE_ADDR, struct value *,\n-                                       int check_tag);\n+\t\t\t\t       int check_tag);\n \n extern struct value *ada_to_fixed_value (struct value *val);\n \n@@ -308,7 +308,7 @@ extern int ada_name_prefix_len (const char *);\n extern const char *ada_type_name (struct type *);\n \n extern struct type *ada_find_parallel_type (struct type *,\n-                                            const char *suffix);\n+\t\t\t\t\t    const char *suffix);\n \n extern bool get_int_var_value (const char *, LONGEST &value);\n "
    },
    {
      "sha": "c66d08f92fa76b564b6d87c0fe5916d0ef11bcb8",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -203,9 +203,9 @@ struct ada_tasks_inferior_data\n      the list of Ada tasks.  The value of this field influences\n      the interpretation of the known_tasks_addr field below:\n        - ADA_TASKS_UNKNOWN: The value of known_tasks_addr hasn't\n-         been determined yet;\n+\t been determined yet;\n        - ADA_TASKS_NOT_FOUND: The program probably does not use tasking\n-         and the known_tasks_addr is irrelevant;\n+\t and the known_tasks_addr is irrelevant;\n        - ADA_TASKS_ARRAY: The known_tasks is an array;\n        - ADA_TASKS_LIST: The known_tasks is a list.  */\n   enum ada_known_tasks_kind known_tasks_kind = ADA_TASKS_UNKNOWN;\n@@ -324,7 +324,7 @@ get_task_number_from_id (CORE_ADDR task_id, struct inferior *inf)\n   for (int i = 0; i < data->task_list.size (); i++)\n     {\n       if (data->task_list[i].task_id == task_id)\n-        return i + 1;\n+\treturn i + 1;\n     }\n \n   /* Task not found.  Return 0.  */\n@@ -386,7 +386,7 @@ iterate_over_live_ada_tasks (ada_task_list_iterator_ftype iterator)\n   for (ada_task_info &task : data->task_list)\n     {\n       if (!ada_task_is_alive (&task))\n-        continue;\n+\tcontinue;\n       iterator (&task);\n     }\n }\n@@ -432,9 +432,9 @@ read_fat_string_value (char *dest, struct value *val, int max_len)\n \n       bounds_type = type->field (bounds_fieldno).type ();\n       if (bounds_type->code () == TYPE_CODE_PTR)\n-        bounds_type = TYPE_TARGET_TYPE (bounds_type);\n+\tbounds_type = TYPE_TARGET_TYPE (bounds_type);\n       if (bounds_type->code () != TYPE_CODE_STRUCT)\n-        error (_(\"Unknown task name format. Aborting\"));\n+\terror (_(\"Unknown task name format. Aborting\"));\n       upper_bound_fieldno = ada_get_field_index (bounds_type, \"UB0\", 0);\n \n       initialize_fieldnos = 0;\n@@ -502,20 +502,20 @@ ada_get_tcb_types_info (void)\n   if (atcb_sym == NULL || atcb_sym->type == NULL)\n     {\n       /* In Ravenscar run-time libs, the  ATCB does not have a dynamic\n-         size, so the symbol name differs.  */\n+\t size, so the symbol name differs.  */\n       atcb_sym = lookup_symbol_in_language (atcb_name_fixed, NULL,\n \t\t\t\t\t    STRUCT_DOMAIN, language_c,\n \t\t\t\t\t    NULL).symbol;\n \n       if (atcb_sym == NULL || atcb_sym->type == NULL)\n-        return _(\"Cannot find Ada_Task_Control_Block type\");\n+\treturn _(\"Cannot find Ada_Task_Control_Block type\");\n \n       type = atcb_sym->type;\n     }\n   else\n     {\n       /* Get a static representation of the type record\n-         Ada_Task_Control_Block.  */\n+\t Ada_Task_Control_Block.  */\n       type = atcb_sym->type;\n       type = ada_template_to_fixed_record_type_1 (type, NULL, 0, NULL, 0);\n     }\n@@ -547,7 +547,7 @@ ada_get_tcb_types_info (void)\n   fieldnos.image = ada_get_field_index (common_type, \"task_image\", 1);\n   fieldnos.image_len = ada_get_field_index (common_type, \"task_image_len\", 1);\n   fieldnos.activation_link = ada_get_field_index (common_type,\n-                                                  \"activation_link\", 1);\n+\t\t\t\t\t\t  \"activation_link\", 1);\n   fieldnos.call = ada_get_field_index (common_type, \"call\", 1);\n   fieldnos.ll = ada_get_field_index (common_type, \"ll\", 0);\n   fieldnos.base_cpu = ada_get_field_index (common_type, \"base_cpu\", 0);\n@@ -658,10 +658,10 @@ read_atcb (CORE_ADDR task_id, struct ada_task_info *task_info)\n   if (pspace_data->atcb_fieldno.image_len == -1)\n     {\n       if (pspace_data->atcb_fieldno.image >= 0)\n-        read_fat_string_value (task_info->name,\n-                               value_field (common_value,\n+\tread_fat_string_value (task_info->name,\n+\t\t\t       value_field (common_value,\n \t\t\t\t\t    pspace_data->atcb_fieldno.image),\n-                               sizeof (task_info->name) - 1);\n+\t\t\t       sizeof (task_info->name) - 1);\n       else\n \t{\n \t  struct bound_minimal_symbol msym;\n@@ -697,7 +697,7 @@ read_atcb (CORE_ADDR task_id, struct ada_task_info *task_info)\n \t\t\t\tpspace_data->atcb_fieldno.image_len));\n \n       value_as_string (task_info->name,\n-                       value_field (common_value,\n+\t\t       value_field (common_value,\n \t\t\t\t    pspace_data->atcb_fieldno.image),\n \t\t       len);\n     }\n@@ -727,22 +727,22 @@ read_atcb (CORE_ADDR task_id, struct ada_task_info *task_info)\n       && pspace_data->atcb_fieldno.entry_calls > 0)\n     {\n       /* Let My_ATCB be the Ada task control block of a task calling the\n-         entry of another task; then the Task_Id of the called task is\n-         in My_ATCB.Entry_Calls (My_ATCB.ATC_Nesting_Level).Called_Task.  */\n+\t entry of another task; then the Task_Id of the called task is\n+\t in My_ATCB.Entry_Calls (My_ATCB.ATC_Nesting_Level).Called_Task.  */\n       atc_nesting_level_value =\n-        value_field (tcb_value, pspace_data->atcb_fieldno.atc_nesting_level);\n+\tvalue_field (tcb_value, pspace_data->atcb_fieldno.atc_nesting_level);\n       entry_calls_value =\n-        ada_coerce_to_simple_array_ptr\n+\tada_coerce_to_simple_array_ptr\n \t  (value_field (tcb_value, pspace_data->atcb_fieldno.entry_calls));\n       entry_calls_value_element =\n-        value_subscript (entry_calls_value,\n+\tvalue_subscript (entry_calls_value,\n \t\t\t value_as_long (atc_nesting_level_value));\n       called_task_fieldno =\n-        ada_get_field_index (value_type (entry_calls_value_element),\n-                             \"called_task\", 0);\n+\tada_get_field_index (value_type (entry_calls_value_element),\n+\t\t\t     \"called_task\", 0);\n       task_info->called_task =\n-        value_as_address (value_field (entry_calls_value_element,\n-                                       called_task_fieldno));\n+\tvalue_as_address (value_field (entry_calls_value_element,\n+\t\t\t\t       called_task_fieldno));\n     }\n \n   /* If the ATCB contains some information about RV callers, then\n@@ -751,21 +751,21 @@ read_atcb (CORE_ADDR task_id, struct ada_task_info *task_info)\n   if (pspace_data->atcb_fieldno.call >= 0)\n     {\n       /* Get the ID of the caller task from Common_ATCB.Call.all.Self.\n-         If Common_ATCB.Call is null, then there is no caller.  */\n+\t If Common_ATCB.Call is null, then there is no caller.  */\n       const CORE_ADDR call =\n-        value_as_address (value_field (common_value,\n+\tvalue_as_address (value_field (common_value,\n \t\t\t\t       pspace_data->atcb_fieldno.call));\n       struct value *call_val;\n \n       if (call != 0)\n-        {\n-          call_val =\n-            value_from_contents_and_address (pspace_data->atcb_call_type,\n+\t{\n+\t  call_val =\n+\t    value_from_contents_and_address (pspace_data->atcb_call_type,\n \t\t\t\t\t     NULL, call);\n-          task_info->caller_task =\n-            value_as_address\n+\t  task_info->caller_task =\n+\t    value_as_address\n \t      (value_field (call_val, pspace_data->atcb_fieldno.call_self));\n-        }\n+\t}\n     }\n \n   task_info->base_cpu\n@@ -811,11 +811,11 @@ read_known_tasks_array (struct ada_tasks_inferior_data *data)\n   for (i = 0; i < data->known_tasks_length; i++)\n     {\n       CORE_ADDR task_id =\n-        extract_typed_address (known_tasks + i * target_ptr_byte,\n+\textract_typed_address (known_tasks + i * target_ptr_byte,\n \t\t\t       data->known_tasks_element);\n \n       if (task_id != 0)\n-        add_ada_task (task_id, current_inferior ());\n+\tadd_ada_task (task_id, current_inferior ());\n     }\n \n   return true;\n@@ -853,7 +853,7 @@ read_known_tasks_list (struct ada_tasks_inferior_data *data)\n       common_value = value_field (tcb_value, pspace_data->atcb_fieldno.common);\n       task_id = value_as_address\n \t\t  (value_field (common_value,\n-                                pspace_data->atcb_fieldno.activation_link));\n+\t\t\t\tpspace_data->atcb_fieldno.activation_link));\n     }\n \n   return true;\n@@ -1108,12 +1108,12 @@ print_ada_task_info (struct ui_out *uiout,\n \t to one task only, and this is not the task, skip\n \t to the next one.  */\n       if (taskno_arg && taskno != taskno_arg)\n-        continue;\n+\tcontinue;\n \n       ui_out_emit_tuple tuple_emitter (uiout, NULL);\n \n       /* Print a star if this task is the current task (or the task\n-         currently selected).  */\n+\t currently selected).  */\n       if (task_info->ptid == inferior_ptid)\n \tuiout->field_string (\"current\", \"*\");\n       else\n@@ -1128,7 +1128,7 @@ print_ada_task_info (struct ui_out *uiout,\n \n       /* Print the associated Thread ID.  */\n       if (uiout->is_mi_like_p ())\n-        {\n+\t{\n \t  thread_info *thread = (ada_task_is_alive (task_info)\n \t\t\t\t ? find_thread_ptid (inf, task_info->ptid)\n \t\t\t\t : nullptr);\n@@ -1145,9 +1145,9 @@ print_ada_task_info (struct ui_out *uiout,\n       /* Print the ID of the parent task.  */\n       parent_id = get_task_number_from_id (task_info->parent, inf);\n       if (parent_id)\n-        uiout->field_signed (\"parent-id\", parent_id);\n+\tuiout->field_signed (\"parent-id\", parent_id);\n       else\n-        uiout->field_skip (\"parent-id\");\n+\tuiout->field_skip (\"parent-id\");\n \n       /* Print the base priority of the task.  */\n       uiout->field_signed (\"priority\", task_info->priority);\n@@ -1168,7 +1168,7 @@ print_ada_task_info (struct ui_out *uiout,\n \n       /* Finally, print the task name, without quotes around it, as mi like\n \t is not expecting quotes, and in non mi-like no need for quotes\n-         as there is a specific column for the name.  */\n+\t as there is a specific column for the name.  */\n       uiout->field_fmt (\"name\",\n \t\t\t(task_info->name[0] != '\\0'\n \t\t\t ? ui_file_style ()\n@@ -1201,7 +1201,7 @@ info_task (struct ui_out *uiout, const char *taskno_str, struct inferior *inf)\n \n   if (taskno <= 0 || taskno > data->task_list.size ())\n     error (_(\"Task ID %d not known.  Use the \\\"info tasks\\\" command to\\n\"\n-             \"see the IDs of currently known tasks\"), taskno);\n+\t     \"see the IDs of currently known tasks\"), taskno);\n   task_info = &data->task_list[taskno - 1];\n \n   /* Print the Ada task ID.  */\n@@ -1231,7 +1231,7 @@ info_task (struct ui_out *uiout, const char *taskno_str, struct inferior *inf)\n \n       printf_filtered (_(\"Parent: %d\"), parent_taskno);\n       if (parent->name[0] != '\\0')\n-        printf_filtered (\" (%s)\", parent->name);\n+\tprintf_filtered (\" (%s)\", parent->name);\n       printf_filtered (\"\\n\");\n     }\n   else\n@@ -1246,25 +1246,25 @@ info_task (struct ui_out *uiout, const char *taskno_str, struct inferior *inf)\n \n     if (task_info->caller_task)\n       {\n-        target_taskno = get_task_number_from_id (task_info->caller_task, inf);\n-        printf_filtered (_(\"State: Accepting rendezvous with %d\"),\n-                         target_taskno);\n+\ttarget_taskno = get_task_number_from_id (task_info->caller_task, inf);\n+\tprintf_filtered (_(\"State: Accepting rendezvous with %d\"),\n+\t\t\t target_taskno);\n       }\n     else if (task_info->called_task)\n       {\n-        target_taskno = get_task_number_from_id (task_info->called_task, inf);\n-        printf_filtered (_(\"State: Waiting on task %d's entry\"),\n-                         target_taskno);\n+\ttarget_taskno = get_task_number_from_id (task_info->called_task, inf);\n+\tprintf_filtered (_(\"State: Waiting on task %d's entry\"),\n+\t\t\t target_taskno);\n       }\n     else\n       printf_filtered (_(\"State: %s\"), _(long_task_states[task_info->state]));\n \n     if (target_taskno)\n       {\n-        ada_task_info *target_task_info = &data->task_list[target_taskno - 1];\n+\tada_task_info *target_task_info = &data->task_list[target_taskno - 1];\n \n-        if (target_task_info->name[0] != '\\0')\n-          printf_filtered (\" (%s)\", target_task_info->name);\n+\tif (target_task_info->name[0] != '\\0')\n+\t  printf_filtered (\" (%s)\", target_task_info->name);\n       }\n \n     printf_filtered (\"\\n\");\n@@ -1321,7 +1321,7 @@ task_command_1 (const char *taskno_str, int from_tty, struct inferior *inf)\n \n   if (taskno <= 0 || taskno > data->task_list.size ())\n     error (_(\"Task ID %d not known.  Use the \\\"info tasks\\\" command to\\n\"\n-             \"see the IDs of currently known tasks\"), taskno);\n+\t     \"see the IDs of currently known tasks\"), taskno);\n   task_info = &data->task_list[taskno - 1];\n \n   if (!ada_task_is_alive (task_info))\n@@ -1348,15 +1348,15 @@ task_command_1 (const char *taskno_str, int from_tty, struct inferior *inf)\n   thread_info *tp = find_thread_ptid (inf, task_info->ptid);\n   if (tp == NULL)\n     error (_(\"Unable to compute thread ID for task %s.\\n\"\n-             \"Cannot switch to this task.\"),\n-           task_to_str (taskno, task_info).c_str ());\n+\t     \"Cannot switch to this task.\"),\n+\t   task_to_str (taskno, task_info).c_str ());\n \n   switch_to_thread (tp);\n   ada_find_printable_frame (get_selected_frame (NULL));\n   printf_filtered (_(\"[Switching to task %s]\\n\"),\n \t\t   task_to_str (taskno, task_info).c_str ());\n   print_stack_frame (get_selected_frame (NULL),\n-                     frame_relative_level (get_selected_frame (NULL)),\n+\t\t     frame_relative_level (get_selected_frame (NULL)),\n \t\t     SRC_AND_LOC, 1);\n }\n \n@@ -1435,7 +1435,7 @@ ada_tasks_new_objfile_observer (struct objfile *objfile)\n       /* All objfiles are being cleared, so we should clear all\n \t our caches for all program spaces.  */\n       for (struct program_space *pspace : program_spaces)\n-        ada_tasks_invalidate_pspace_data (pspace);\n+\tada_tasks_invalidate_pspace_data (pspace);\n     }\n   else\n     {\n@@ -1465,9 +1465,9 @@ _initialize_tasks ()\n \n   /* Some new commands provided by this module.  */\n   add_info (\"tasks\", info_tasks_command,\n-            _(\"Provide information about all known Ada tasks.\"));\n+\t    _(\"Provide information about all known Ada tasks.\"));\n   add_cmd (\"task\", class_run, task_command,\n-           _(\"Use this command to switch between Ada tasks.\\n\\\n+\t   _(\"Use this command to switch between Ada tasks.\\n\\\n Without argument, this command simply prints the current task ID.\"),\n-           &cmdlist);\n+\t   &cmdlist);\n }"
    },
    {
      "sha": "11cc51cf106dfe3dcbb9c1baeb00c7e6d29ad325",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -198,16 +198,16 @@ print_range_bound (struct type *type, const char *bounds, int *n,\n   if (ada_scan_number (bounds, *n, &B, n))\n     {\n       /* STABS decodes all range types which bounds are 0 .. -1 as\n-         unsigned integers (ie. the type code is TYPE_CODE_INT, not\n-         TYPE_CODE_RANGE).  Unfortunately, ada_print_scalar() relies\n-         on the unsigned flag to determine whether the bound should\n-         be printed as a signed or an unsigned value.  This causes\n-         the upper bound of the 0 .. -1 range types to be printed as\n-         a very large unsigned number instead of -1.\n-         To workaround this stabs deficiency, we replace the TYPE by NULL\n-         to indicate default output when we detect that the bound is negative,\n-         and the type is a TYPE_CODE_INT.  The bound is negative when\n-         'm' is the last character of the number scanned in BOUNDS.  */\n+\t unsigned integers (ie. the type code is TYPE_CODE_INT, not\n+\t TYPE_CODE_RANGE).  Unfortunately, ada_print_scalar() relies\n+\t on the unsigned flag to determine whether the bound should\n+\t be printed as a signed or an unsigned value.  This causes\n+\t the upper bound of the 0 .. -1 range types to be printed as\n+\t a very large unsigned number instead of -1.\n+\t To workaround this stabs deficiency, we replace the TYPE by NULL\n+\t to indicate default output when we detect that the bound is negative,\n+\t and the type is a TYPE_CODE_INT.  The bound is negative when\n+\t 'm' is the last character of the number scanned in BOUNDS.  */\n       if (bounds[*n - 1] == 'm' && type->code () == TYPE_CODE_INT)\n \ttype = NULL;\n       ada_print_scalar (type, B, stream);\n@@ -1071,7 +1071,7 @@ ada_print_type (struct type *type0, const char *varstring,\n \n void\n ada_print_typedef (struct type *type, struct symbol *new_symbol,\n-                   struct ui_file *stream)\n+\t\t   struct ui_file *stream)\n {\n   type = ada_check_typedef (type);\n   ada_print_type (type, \"\", stream, 0, 0, &type_print_raw_options);"
    },
    {
      "sha": "f1964a29e6def87788ec67a3445ee89639d9db1f",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -76,10 +76,10 @@ print_optional_low_bound (struct ui_file *stream, struct type *type,\n   while (index_type->code () == TYPE_CODE_RANGE)\n     {\n       /* We need to know what the base type is, in order to do the\n-         appropriate check below.  Otherwise, if this is a subrange\n-         of an enumerated type, where the underlying value of the\n-         first element is typically 0, we might test the low bound\n-         against the wrong value.  */\n+\t appropriate check below.  Otherwise, if this is a subrange\n+\t of an enumerated type, where the underlying value of the\n+\t first element is typically 0, we might test the low bound\n+\t against the wrong value.  */\n       index_type = TYPE_TARGET_TYPE (index_type);\n     }\n \n@@ -140,10 +140,10 @@ val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,\n       len = 1;\n     else if (low > high)\n       {\n-        /* The array length should normally be HIGH_POS - LOW_POS + 1.\n-           But in Ada we allow LOW_POS to be greater than HIGH_POS for\n-           empty arrays.  In that situation, the array length is just zero,\n-           not negative!  */\n+\t/* The array length should normally be HIGH_POS - LOW_POS + 1.\n+\t   But in Ada we allow LOW_POS to be greater than HIGH_POS for\n+\t   empty arrays.  In that situation, the array length is just zero,\n+\t   not negative!  */\n \tlen = 0;\n       }\n     else\n@@ -291,7 +291,7 @@ char_at (const gdb_byte *string, int i, int type_len,\n     return string[i];\n   else\n     return (int) extract_unsigned_integer (string + type_len * i,\n-                                           type_len, byte_order);\n+\t\t\t\t\t   type_len, byte_order);\n }\n \n /* Print a floating-point value of type TYPE, pointed to in GDB by\n@@ -462,7 +462,7 @@ printstr (struct ui_file *stream, struct type *elttype, const gdb_byte *string,\n   for (i = 0; i < length && things_printed < options->print_max; i += 1)\n     {\n       /* Position of the character we are examining\n-         to see whether it is repeated.  */\n+\t to see whether it is repeated.  */\n       unsigned int rep1;\n       /* Number of repetitions we have detected so far.  */\n       unsigned int reps;\n@@ -1126,7 +1126,7 @@ ada_value_print (struct value *val0, struct ui_file *stream,\n   if (type->code () == TYPE_CODE_PTR)\n     {\n       /* Hack:  don't print (char *) for char strings.  Their\n-         type is indicated by the quoted string anyway.  */\n+\t type is indicated by the quoted string anyway.  */\n       if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) != sizeof (char)\n \t  || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_INT\n \t  || TYPE_TARGET_TYPE (type)->is_unsigned ())\n@@ -1142,7 +1142,7 @@ ada_value_print (struct value *val0, struct ui_file *stream,\n \t access type (this is encoded by the compiler as a typedef to\n \t a fat pointer - hence the check against TYPE_CODE_TYPEDEF).  */\n       if (type->code () == TYPE_CODE_TYPEDEF)\n-        {\n+\t{\n \t  fprintf_filtered (stream, \"(\");\n \t  type_print (type, \"\", stream, -1);\n \t  fprintf_filtered (stream, \") \");"
    },
    {
      "sha": "39dc9488d5c7480ce39bffaaa4e136b2ef905455",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -208,7 +208,7 @@ ada_varobj_adjust_for_child_access (struct value **value,\n       the (value, type) couple.  */\n   if ((*type)->code () == TYPE_CODE_PTR\n       && (TYPE_TARGET_TYPE (*type)->code () == TYPE_CODE_STRUCT\n-          || TYPE_TARGET_TYPE (*type)->code () == TYPE_CODE_UNION)\n+\t  || TYPE_TARGET_TYPE (*type)->code () == TYPE_CODE_UNION)\n       && *value != nullptr\n       && value_as_address (*value) != 0\n       && !ada_is_array_descriptor_type (TYPE_TARGET_TYPE (*type))"
    },
    {
      "sha": "da22c8d22a90e1a83be76a4d032a9a229c749c67",
      "filename": "gdb/addrmap.c",
      "status": "modified",
      "additions": 41,
      "deletions": 41,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/addrmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/addrmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/addrmap.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -35,11 +35,11 @@ gdb_static_assert (sizeof (splay_tree_value) >= sizeof (void *));\n struct addrmap_funcs\n {\n   void (*set_empty) (struct addrmap *self,\n-                     CORE_ADDR start, CORE_ADDR end_inclusive,\n-                     void *obj);\n+\t\t     CORE_ADDR start, CORE_ADDR end_inclusive,\n+\t\t     void *obj);\n   void *(*find) (struct addrmap *self, CORE_ADDR addr);\n   struct addrmap *(*create_fixed) (struct addrmap *self,\n-                                   struct obstack *obstack);\n+\t\t\t\t   struct obstack *obstack);\n   void (*relocate) (struct addrmap *self, CORE_ADDR offset);\n   int (*foreach) (struct addrmap *self, addrmap_foreach_fn fn, void *data);\n };\n@@ -53,8 +53,8 @@ struct addrmap\n \n void\n addrmap_set_empty (struct addrmap *map,\n-                   CORE_ADDR start, CORE_ADDR end_inclusive,\n-                   void *obj)\n+\t\t   CORE_ADDR start, CORE_ADDR end_inclusive,\n+\t\t   void *obj)\n {\n   map->funcs->set_empty (map, start, end_inclusive, obj);\n }\n@@ -119,12 +119,12 @@ struct addrmap_fixed\n \n static void\n addrmap_fixed_set_empty (struct addrmap *self,\n-                   CORE_ADDR start, CORE_ADDR end_inclusive,\n-                   void *obj)\n+\t\t   CORE_ADDR start, CORE_ADDR end_inclusive,\n+\t\t   void *obj)\n {\n   internal_error (__FILE__, __LINE__,\n-                  \"addrmap_fixed_set_empty: \"\n-                  \"fixed addrmaps can't be changed\\n\");\n+\t\t  \"addrmap_fixed_set_empty: \"\n+\t\t  \"fixed addrmaps can't be changed\\n\");\n }\n \n \n@@ -138,23 +138,23 @@ addrmap_fixed_find (struct addrmap *self, CORE_ADDR addr)\n   while (bottom < top)\n     {\n       /* This needs to round towards top, or else when top = bottom +\n-         1 (i.e., two entries are under consideration), then mid ==\n-         bottom, and then we may not narrow the range when (mid->addr\n-         < addr).  */\n+\t 1 (i.e., two entries are under consideration), then mid ==\n+\t bottom, and then we may not narrow the range when (mid->addr\n+\t < addr).  */\n       struct addrmap_transition *mid = top - (top - bottom) / 2;\n \n       if (mid->addr == addr)\n-        {\n-          bottom = mid;\n-          break;\n-        }\n+\t{\n+\t  bottom = mid;\n+\t  break;\n+\t}\n       else if (mid->addr < addr)\n-        /* We don't eliminate mid itself here, since each transition\n-           covers all subsequent addresses until the next.  This is why\n-           we must round up in computing the midpoint.  */\n-        bottom = mid;\n+\t/* We don't eliminate mid itself here, since each transition\n+\t   covers all subsequent addresses until the next.  This is why\n+\t   we must round up in computing the midpoint.  */\n+\tbottom = mid;\n       else\n-        top = mid - 1;\n+\ttop = mid - 1;\n     }\n \n   return bottom->value;\n@@ -165,8 +165,8 @@ static struct addrmap *\n addrmap_fixed_create_fixed (struct addrmap *self, struct obstack *obstack)\n {\n   internal_error (__FILE__, __LINE__,\n-                  _(\"addrmap_create_fixed is not implemented yet \"\n-                    \"for fixed addrmaps\"));\n+\t\t  _(\"addrmap_create_fixed is not implemented yet \"\n+\t\t    \"for fixed addrmaps\"));\n }\n \n \n@@ -311,8 +311,8 @@ addrmap_splay_tree_insert (struct addrmap_mutable *map,\n \t\t\t   CORE_ADDR key, void *value)\n {\n   splay_tree_insert (map->tree,\n-                     allocate_key (map, key),\n-                     (splay_tree_value) value);\n+\t\t     allocate_key (map, key),\n+\t\t     (splay_tree_value) value);\n }\n \n \n@@ -329,15 +329,15 @@ force_transition (struct addrmap_mutable *self, CORE_ADDR addr)\n     {\n       n = addrmap_splay_tree_predecessor (self, addr);\n       addrmap_splay_tree_insert (self, addr,\n-                                 n ? addrmap_node_value (n) : NULL);\n+\t\t\t\t n ? addrmap_node_value (n) : NULL);\n     }\n }\n \n \n static void\n addrmap_mutable_set_empty (struct addrmap *self,\n-                           CORE_ADDR start, CORE_ADDR end_inclusive,\n-                           void *obj)\n+\t\t\t   CORE_ADDR start, CORE_ADDR end_inclusive,\n+\t\t\t   void *obj)\n {\n   struct addrmap_mutable *map = (struct addrmap_mutable *) self;\n   splay_tree_node n, next;\n@@ -366,7 +366,7 @@ addrmap_mutable_set_empty (struct addrmap *self,\n        n = addrmap_splay_tree_successor (map, addrmap_node_key (n)))\n     {\n       if (! addrmap_node_value (n))\n-        addrmap_node_set_value (n, obj);\n+\taddrmap_node_set_value (n, obj);\n     }\n \n   /* Walk the area again, removing transitions from any value to\n@@ -376,14 +376,14 @@ addrmap_mutable_set_empty (struct addrmap *self,\n   prior_value = n ? addrmap_node_value (n) : NULL;\n   for (n = addrmap_splay_tree_lookup (map, start), gdb_assert (n);\n        n && (end_inclusive == CORE_ADDR_MAX\n-             || addrmap_node_key (n) <= end_inclusive + 1);\n+\t     || addrmap_node_key (n) <= end_inclusive + 1);\n        n = next)\n     {\n       next = addrmap_splay_tree_successor (map, addrmap_node_key (n));\n       if (addrmap_node_value (n) == prior_value)\n-        addrmap_splay_tree_remove (map, addrmap_node_key (n));\n+\taddrmap_splay_tree_remove (map, addrmap_node_key (n));\n       else\n-        prior_value = addrmap_node_value (n);\n+\tprior_value = addrmap_node_value (n);\n     }\n }\n \n@@ -393,8 +393,8 @@ addrmap_mutable_find (struct addrmap *self, CORE_ADDR addr)\n {\n   /* Not needed yet.  */\n   internal_error (__FILE__, __LINE__,\n-                  _(\"addrmap_find is not implemented yet \"\n-                    \"for mutable addrmaps\"));\n+\t\t  _(\"addrmap_find is not implemented yet \"\n+\t\t    \"for mutable addrmaps\"));\n }\n \n \n@@ -466,8 +466,8 @@ addrmap_mutable_relocate (struct addrmap *self, CORE_ADDR offset)\n {\n   /* Not needed yet.  */\n   internal_error (__FILE__, __LINE__,\n-                  _(\"addrmap_relocate is not implemented yet \"\n-                    \"for mutable addrmaps\"));\n+\t\t  _(\"addrmap_relocate is not implemented yet \"\n+\t\t    \"for mutable addrmaps\"));\n }\n \n \n@@ -584,11 +584,11 @@ addrmap_create_mutable (struct obstack *obstack)\n   map->free_nodes = NULL;\n \n   map->tree = splay_tree_new_with_allocator (splay_compare_CORE_ADDR_ptr,\n-                                             NULL, /* no delete key */\n-                                             NULL, /* no delete value */\n-                                             splay_obstack_alloc,\n-                                             splay_obstack_free,\n-                                             map);\n+\t\t\t\t\t     NULL, /* no delete key */\n+\t\t\t\t\t     NULL, /* no delete value */\n+\t\t\t\t\t     splay_obstack_alloc,\n+\t\t\t\t\t     splay_obstack_free,\n+\t\t\t\t\t     map);\n \n   return (struct addrmap *) map;\n }"
    },
    {
      "sha": "34d637313e53606af3bcb56e8218b622b92edbf9",
      "filename": "gdb/addrmap.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/addrmap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/addrmap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/addrmap.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -76,16 +76,16 @@ struct addrmap *addrmap_create_mutable (struct obstack *obstack);\n    implemented efficiently, but doesn't reveal too much of the\n    representation.  */\n void addrmap_set_empty (struct addrmap *map,\n-                        CORE_ADDR start, CORE_ADDR end_inclusive,\n-                        void *obj);\n+\t\t\tCORE_ADDR start, CORE_ADDR end_inclusive,\n+\t\t\tvoid *obj);\n \n /* Return the object associated with ADDR in MAP.  */\n void *addrmap_find (struct addrmap *map, CORE_ADDR addr);\n \n /* Create a fixed address map which is a copy of the mutable address\n    map ORIGINAL.  Allocate entries in OBSTACK.  */\n struct addrmap *addrmap_create_fixed (struct addrmap *original,\n-                                      struct obstack *obstack);\n+\t\t\t\t      struct obstack *obstack);\n \n /* Relocate all the addresses in MAP by OFFSET.  (This can be applied\n    to either mutable or immutable maps.)  */"
    },
    {
      "sha": "ffcefeb674885de11917ae8bda21a6b6bc7fc2b9",
      "filename": "gdb/agent.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/agent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/agent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/agent.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -52,7 +52,7 @@ set_can_use_agent (const char *args, int from_tty, struct cmd_list_element *c)\n   if (can_use && !agent_loaded_p ())\n     {\n       /* Since the setting was off, we may not have observed the objfiles and\n-         therefore not looked up the required symbols.  Do so now.  */\n+\t therefore not looked up the required symbols.  Do so now.  */\n       for (objfile *objfile : current_program_space->objfiles ())\n \tif (agent_look_up_symbols (objfile) == 0)\n \t  break;"
    },
    {
      "sha": "d327e6c9a7580fcd4affacb337e5e6ce6b9c0299",
      "filename": "gdb/aix-thread.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aix-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/aix-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aix-thread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -397,7 +397,7 @@ pdc_read_regs (pthdb_user_t user,\n   \n   if (debug_aix_thread)\n     fprintf_unfiltered (gdb_stdlog, \"pdc_read_regs tid=%d flags=%s\\n\",\n-                        (int) tid, hex_string (flags));\n+\t\t\t(int) tid, hex_string (flags));\n \n   /* General-purpose registers.  */\n   if (flags & PTHDB_FLAG_GPRS)\n@@ -463,7 +463,7 @@ pdc_write_regs (pthdb_user_t user,\n \n   if (debug_aix_thread)\n     fprintf_unfiltered (gdb_stdlog, \"pdc_write_regs tid=%d flags=%s\\n\",\n-                        (int) tid, hex_string (flags));\n+\t\t\t(int) tid, hex_string (flags));\n \n   /* General-purpose registers.  */\n   if (flags & PTHDB_FLAG_GPRS)\n@@ -549,7 +549,7 @@ pdc_alloc (pthdb_user_t user, size_t len, void **bufp)\n {\n   if (debug_aix_thread)\n     fprintf_unfiltered (gdb_stdlog,\n-                        \"pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)\\n\",\n+\t\t\t\"pdc_alloc (user = %ld, len = %ld, bufp = 0x%lx)\\n\",\n \t\t\tuser, len, (long) bufp);\n   *bufp = xmalloc (len);\n   if (debug_aix_thread)\n@@ -589,7 +589,7 @@ pdc_dealloc (pthdb_user_t user, void *buf)\n   if (debug_aix_thread)\n     fprintf_unfiltered (gdb_stdlog, \n \t\t\t\"pdc_free (user = %ld, buf = 0x%lx)\\n\", user,\n-                        (long) buf);\n+\t\t\t(long) buf);\n   xfree (buf);\n   return PDC_SUCCESS;\n }\n@@ -709,7 +709,7 @@ get_signaled_thread (void)\n   while (1)\n   {\n     if (getthrds (inferior_ptid.pid (), &thrinf, \n-          \t  sizeof (thrinf), &ktid, 1) != 1)\n+\t  \t  sizeof (thrinf), &ktid, 1) != 1)\n       break;\n \n     if (thrinf.ti_cursig == SIGTRAP)\n@@ -1231,7 +1231,7 @@ fetch_regs_user_thread (struct regcache *regcache, pthdb_pthread_t pdtid)\n   status = pthdb_pthread_context (pd_session, pdtid, &ctx);\n   if (status != PTHDB_SUCCESS)\n     error (_(\"aix-thread: fetch_registers: pthdb_pthread_context returned %s\"),\n-           pd_status2str (status));\n+\t   pd_status2str (status));\n \n   /* General-purpose registers.  */\n \n@@ -1292,7 +1292,7 @@ fetch_regs_kernel_thread (struct regcache *regcache, int regno,\n   /* General-purpose registers.  */\n   if (regno == -1\n       || (tdep->ppc_gp0_regnum <= regno\n-          && regno < tdep->ppc_gp0_regnum + ppc_num_gprs))\n+\t  && regno < tdep->ppc_gp0_regnum + ppc_num_gprs))\n     {\n       if (arch64)\n \t{\n@@ -1314,8 +1314,8 @@ fetch_regs_kernel_thread (struct regcache *regcache, int regno,\n \n   if (ppc_floating_point_unit_p (gdbarch)\n       && (regno == -1\n-          || (regno >= tdep->ppc_fp0_regnum\n-              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))\n+\t  || (regno >= tdep->ppc_fp0_regnum\n+\t      && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))\n     {\n       if (!ptrace32 (PTT_READ_FPRS, tid, (uintptr_t) fprs, 0, NULL))\n \tmemset (fprs, 0, sizeof (fprs));\n@@ -1514,7 +1514,7 @@ store_regs_user_thread (const struct regcache *regcache, pthdb_pthread_t pdtid)\n   status = pthdb_pthread_context (pd_session, pdtid, &ctx);\n   if (status != PTHDB_SUCCESS)\n     error (_(\"aix-thread: store_registers: pthdb_pthread_context returned %s\"),\n-           pd_status2str (status));\n+\t   pd_status2str (status));\n \n   /* Collect general-purpose register values from the regcache.  */\n \n@@ -1573,7 +1573,7 @@ store_regs_user_thread (const struct regcache *regcache, pthdb_pthread_t pdtid)\n   if (status != PTHDB_SUCCESS)\n     error (_(\"aix-thread: store_registers: \"\n \t     \"pthdb_pthread_setcontext returned %s\"),\n-           pd_status2str (status));\n+\t   pd_status2str (status));\n }\n \n /* Store register REGNO if != -1 or all registers otherwise into\n@@ -1599,12 +1599,12 @@ store_regs_kernel_thread (const struct regcache *regcache, int regno,\n   if (debug_aix_thread)\n     fprintf_unfiltered (gdb_stdlog, \n \t\t\t\"store_regs_kernel_thread tid=%lx regno=%d\\n\",\n-                        (long) tid, regno);\n+\t\t\t(long) tid, regno);\n \n   /* General-purpose registers.  */\n   if (regno == -1\n       || (tdep->ppc_gp0_regnum <= regno\n-          && regno < tdep->ppc_gp0_regnum + ppc_num_fprs))\n+\t  && regno < tdep->ppc_gp0_regnum + ppc_num_fprs))\n     {\n       if (arch64)\n \t{\n@@ -1626,8 +1626,8 @@ store_regs_kernel_thread (const struct regcache *regcache, int regno,\n \n   if (ppc_floating_point_unit_p (gdbarch)\n       && (regno == -1\n-          || (regno >= tdep->ppc_fp0_regnum\n-              && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))\n+\t  || (regno >= tdep->ppc_fp0_regnum\n+\t      && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)))\n     {\n       /* Pre-fetch: some regs may not be in the cache.  */\n       ptrace32 (PTT_READ_FPRS, tid, (uintptr_t) fprs, 0, NULL);"
    },
    {
      "sha": "a7c937c50ee7a12ae6600cce5a82a0f8148e67da",
      "filename": "gdb/alpha-bsd-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-bsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -95,14 +95,14 @@ alpha_bsd_nat_target::store_registers (struct regcache *regcache, int regno)\n     {\n       struct reg gregs;\n       if (ptrace (PT_GETREGS, regcache->ptid ().pid (),\n-                  (PTRACE_TYPE_ARG3) &gregs, lwp) == -1)\n-        perror_with_name (_(\"Couldn't get registers\"));\n+\t\t  (PTRACE_TYPE_ARG3) &gregs, lwp) == -1)\n+\tperror_with_name (_(\"Couldn't get registers\"));\n \n       alphabsd_fill_reg (regcache, (char *) &gregs, regno);\n \n       if (ptrace (PT_SETREGS, regcache->ptid ().pid (),\n-                  (PTRACE_TYPE_ARG3) &gregs, lwp) == -1)\n-        perror_with_name (_(\"Couldn't write registers\"));\n+\t\t  (PTRACE_TYPE_ARG3) &gregs, lwp) == -1)\n+\tperror_with_name (_(\"Couldn't write registers\"));\n \n       if (regno != -1)\n \treturn;"
    },
    {
      "sha": "70ac5a87766d80205498bdc88c503d70f4a4f74e",
      "filename": "gdb/alpha-linux-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -64,11 +64,11 @@ enum\n \n    This is somewhat complicated in that:\n      (1) the expansion of the \"mov\" assembler macro has changed over\n-         time, from \"bis src,src,dst\" to \"bis zero,src,dst\",\n+\t time, from \"bis src,src,dst\" to \"bis zero,src,dst\",\n      (2) the kernel has changed from using \"addq\" to \"lda\" to load the\n-         syscall number,\n+\t syscall number,\n      (3) there is a \"normal\" sigreturn and an \"rt\" sigreturn which\n-         has a different stack layout.  */\n+\t has a different stack layout.  */\n \n static long\n alpha_linux_sigtramp_offset_1 (struct gdbarch *gdbarch, CORE_ADDR pc)\n@@ -144,7 +144,7 @@ alpha_linux_sigcontext_addr (struct frame_info *this_frame)\n \tstruct rt_sigframe {\n \t  struct siginfo info;\n \t  struct ucontext uc;\n-        };\n+\t};\n \n \toffsetof (struct rt_sigframe, uc.uc_mcontext);  */\n \n@@ -378,7 +378,7 @@ alpha_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   set_gdbarch_iterate_over_regset_sections\n     (gdbarch, alpha_linux_iterate_over_regset_sections);\n@@ -394,5 +394,5 @@ void\n _initialize_alpha_linux_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_alpha, 0, GDB_OSABI_LINUX,\n-                          alpha_linux_init_abi);\n+\t\t\t  alpha_linux_init_abi);\n }"
    },
    {
      "sha": "bb35228201bfb9263604f8c19df4bc81ffbbbbb1",
      "filename": "gdb/alpha-mdebug-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-mdebug-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-mdebug-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-mdebug-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -34,10 +34,10 @@\n /* *INDENT-OFF* */\n /* Layout of a stack frame on the alpha:\n \n-                |\t\t\t\t|\n+\t\t|\t\t\t\t|\n  pdr members:\t|  7th ... nth arg,\t\t|\n-                |  `pushed' by caller.\t\t|\n-                |\t\t\t\t|\n+\t\t|  `pushed' by caller.\t\t|\n+\t\t|\t\t\t\t|\n ----------------|-------------------------------|<--  old_sp == vfp\n    ^  ^  ^  ^\t|\t\t\t\t|\n    |  |  |  |\t|\t\t\t\t|\n@@ -72,7 +72,7 @@\n    |            |  called procedure.\t\t|\n    v            |  \t\t\t\t|\n    -------------|-------------------------------|<-- sp\n-                |\t\t\t\t|\n+\t\t|\t\t\t\t|\n */\n /* *INDENT-ON* */\n \n@@ -117,7 +117,7 @@ find_proc_desc (CORE_ADDR pc)\n       proc_desc = (struct mdebug_extra_func_info *) SYMBOL_VALUE_BYTES (sym);\n \n       /* Correct incorrect setjmp procedure descriptor from the library\n-         to make backtrace through setjmp work.  */\n+\t to make backtrace through setjmp work.  */\n       if (proc_desc->pdr.pcreg == 0\n \t  && strcmp (sh_name, \"setjmp\") == 0)\n \t{\n@@ -154,7 +154,7 @@ alpha_mdebug_after_prologue (CORE_ADDR pc,\n   if (proc_desc)\n     {\n       /* If function is frameless, then we need to do it the hard way.  I\n-         strongly suspect that frameless always means prologueless...  */\n+\t strongly suspect that frameless always means prologueless...  */\n       if (alpha_mdebug_frameless (proc_desc))\n \treturn 0;\n     }\n@@ -308,8 +308,8 @@ alpha_mdebug_max_frame_size_exceeded (struct mdebug_extra_func_info *proc_desc)\n \n static int\n alpha_mdebug_frame_sniffer (const struct frame_unwind *self,\n-                            struct frame_info *this_frame,\n-                            void **this_cache)\n+\t\t\t    struct frame_info *this_frame,\n+\t\t\t    void **this_cache)\n {\n   CORE_ADDR pc = get_frame_address_in_block (this_frame);\n   struct mdebug_extra_func_info *proc_desc;"
    },
    {
      "sha": "8db5fa286bfd20676597276fdc498fb43b37fb56",
      "filename": "gdb/alpha-netbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -248,7 +248,7 @@ alphanbsd_sigcontext_addr (struct frame_info *frame)\n \n static void\n alphanbsd_init_abi (struct gdbarch_info info,\n-                    struct gdbarch *gdbarch)\n+\t\t    struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n@@ -288,5 +288,5 @@ _initialize_alphanbsd_tdep ()\n      traditional a.out-style core dump format before NetBSD 1.6, but\n      we don't support those.  */\n   gdbarch_register_osabi (bfd_arch_alpha, 0, GDB_OSABI_NETBSD,\n-                          alphanbsd_init_abi);\n+\t\t\t  alphanbsd_init_abi);\n }"
    },
    {
      "sha": "91035c82e6b2cc48f2a433ded1d0997a5c8506fb",
      "filename": "gdb/alpha-obsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-obsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -131,5 +131,5 @@ void\n _initialize_alphaobsd_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_alpha, 0, GDB_OSABI_OPENBSD,\n-                          alphaobsd_init_abi);\n+\t\t\t  alphaobsd_init_abi);\n }"
    },
    {
      "sha": "cacab0077600555885e80863a5e8ff6762bf6439",
      "filename": "gdb/alpha-tdep.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/alpha-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -116,7 +116,7 @@ static int\n alpha_cannot_store_register (struct gdbarch *gdbarch, int regno)\n {\n   return (regno == ALPHA_ZERO_REGNUM\n-          || strlen (alpha_register_name (gdbarch, regno)) == 0);\n+\t  || strlen (alpha_register_name (gdbarch, regno)) == 0);\n }\n \n static struct type *\n@@ -974,7 +974,7 @@ alpha_sigtramp_frame_prev_register (struct frame_info *this_frame,\n       addr = alpha_sigtramp_register_address (get_frame_arch (this_frame),\n \t\t\t\t\t      info->sigcontext_addr, regnum);\n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n     }\n \n   /* This extra register may actually be in the sigcontext, but our\n@@ -986,8 +986,8 @@ alpha_sigtramp_frame_prev_register (struct frame_info *this_frame,\n \n static int\n alpha_sigtramp_frame_sniffer (const struct frame_unwind *self,\n-                              struct frame_info *this_frame,\n-                              void **this_prologue_cache)\n+\t\t\t      struct frame_info *this_frame,\n+\t\t\t      void **this_prologue_cache)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n   CORE_ADDR pc = get_frame_pc (this_frame);\n@@ -1137,16 +1137,16 @@ alpha_heuristic_analyze_probing_loop (struct gdbarch *gdbarch, CORE_ADDR *pc,\n \n   /* The following pattern is recognized as a probing loop:\n \n-        lda     REG_INDEX,NB_OF_ITERATIONS\n-        lda     REG_PROBE,<immediate>(sp)\n+\tlda     REG_INDEX,NB_OF_ITERATIONS\n+\tlda     REG_PROBE,<immediate>(sp)\n \n      LOOP_START:\n-        stq     zero,<immediate>(REG_PROBE)\n-        subq    REG_INDEX,0x1,REG_INDEX\n-        lda     REG_PROBE,<immediate>(REG_PROBE)\n-        bne     REG_INDEX, LOOP_START\n+\tstq     zero,<immediate>(REG_PROBE)\n+\tsubq    REG_INDEX,0x1,REG_INDEX\n+\tlda     REG_PROBE,<immediate>(REG_PROBE)\n+\tbne     REG_INDEX, LOOP_START\n  \n-        lda     sp,<immediate>(REG_PROBE)\n+\tlda     sp,<immediate>(REG_PROBE)\n \n      If anything different is found, the function returns without\n      changing PC and FRAME_SIZE.  Otherwise, PC will point immediately\n@@ -1282,15 +1282,15 @@ alpha_heuristic_frame_unwind_cache (struct frame_info *this_frame,\n \t    {\n \t      reg = (word & 0x03e00000) >> 21;\n \n-              /* Ignore this instruction if we have already encountered\n-                 an instruction saving the same register earlier in the\n-                 function code.  The current instruction does not tell\n-                 us where the original value upon function entry is saved.\n-                 All it says is that the function we are scanning reused\n-                 that register for some computation of its own, and is now\n-                 saving its result.  */\n-              if (trad_frame_addr_p(info->saved_regs, reg))\n-                continue;\n+\t      /* Ignore this instruction if we have already encountered\n+\t\t an instruction saving the same register earlier in the\n+\t\t function code.  The current instruction does not tell\n+\t\t us where the original value upon function entry is saved.\n+\t\t All it says is that the function we are scanning reused\n+\t\t that register for some computation of its own, and is now\n+\t\t saving its result.  */\n+\t      if (trad_frame_addr_p(info->saved_regs, reg))\n+\t\tcontinue;\n \n \t      if (reg == 31)\n \t\tcontinue;\n@@ -1601,7 +1601,7 @@ alpha_next_pc (struct regcache *regcache, CORE_ADDR pc)\n \t  || op == 0x34)\t/* BSR */\n \t{\n  branch_taken:\n-          offset = (insn & 0x001fffff);\n+\t  offset = (insn & 0x001fffff);\n \t  if (offset & 0x00100000)\n \t    offset  |= 0xffe00000;\n \t  offset *= ALPHA_INSN_SIZE;\n@@ -1611,14 +1611,14 @@ alpha_next_pc (struct regcache *regcache, CORE_ADDR pc)\n       /* Need to determine if branch is taken; read RA.  */\n       regno = (insn >> 21) & 0x1f;\n       switch (op)\n-        {\n-          case 0x31:              /* FBEQ */\n-          case 0x36:              /* FBGE */\n-          case 0x37:              /* FBGT */\n-          case 0x33:              /* FBLE */\n-          case 0x32:              /* FBLT */\n-          case 0x35:              /* FBNE */\n-            regno += gdbarch_fp0_regnum (gdbarch);\n+\t{\n+\t  case 0x31:              /* FBEQ */\n+\t  case 0x36:              /* FBGE */\n+\t  case 0x37:              /* FBGT */\n+\t  case 0x33:              /* FBLE */\n+\t  case 0x32:              /* FBLT */\n+\t  case 0x35:              /* FBNE */\n+\t    regno += gdbarch_fp0_regnum (gdbarch);\n \t}\n       \n       rav = regcache_raw_get_signed (regcache, regno);\n@@ -1658,32 +1658,32 @@ alpha_next_pc (struct regcache *regcache, CORE_ADDR pc)\n \t    goto branch_taken;\n \t  break;\n \n-        /* Floating point branches.  */\n-        \n-        case 0x31:              /* FBEQ */\n-          if (fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n-        case 0x36:              /* FBGE */\n-          if (fp_register_sign_bit (rav) == 0 || fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n-        case 0x37:              /* FBGT */\n-          if (fp_register_sign_bit (rav) == 0 && ! fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n-        case 0x33:              /* FBLE */\n-          if (fp_register_sign_bit (rav) == 1 || fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n-        case 0x32:              /* FBLT */\n-          if (fp_register_sign_bit (rav) == 1 && ! fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n-        case 0x35:              /* FBNE */\n-          if (! fp_register_zero_p (rav))\n-            goto branch_taken;\n-          break;\n+\t/* Floating point branches.  */\n+\t\n+\tcase 0x31:              /* FBEQ */\n+\t  if (fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n+\tcase 0x36:              /* FBGE */\n+\t  if (fp_register_sign_bit (rav) == 0 || fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n+\tcase 0x37:              /* FBGT */\n+\t  if (fp_register_sign_bit (rav) == 0 && ! fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n+\tcase 0x33:              /* FBLE */\n+\t  if (fp_register_sign_bit (rav) == 1 || fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n+\tcase 0x32:              /* FBLT */\n+\t  if (fp_register_sign_bit (rav) == 1 && ! fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n+\tcase 0x35:              /* FBNE */\n+\t  if (! fp_register_zero_p (rav))\n+\t    goto branch_taken;\n+\t  break;\n \t}\n     }\n "
    },
    {
      "sha": "a62644d59ff64e6e8573b1a838e46c5292a71cc8",
      "filename": "gdb/amd64-bsd-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-bsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -144,12 +144,12 @@ amd64bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n       struct reg regs;\n \n       if (gdb_ptrace (PT_GETREGS, ptid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't get registers\"));\n+\tperror_with_name (_(\"Couldn't get registers\"));\n \n       amd64_collect_native_gregset (regcache, &regs, regnum);\n \n       if (gdb_ptrace (PT_SETREGS, ptid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't write registers\"));\n+\tperror_with_name (_(\"Couldn't write registers\"));\n \n       if (regnum != -1)\n \treturn;"
    },
    {
      "sha": "a43055d469cc968bd347ab2cdd60ec2f1ff7e711",
      "filename": "gdb/amd64-darwin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-darwin-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -121,5 +121,5 @@ void\n _initialize_amd64_darwin_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64,\n-                          GDB_OSABI_DARWIN, x86_darwin_init_abi_64);\n+\t\t\t  GDB_OSABI_DARWIN, x86_darwin_init_abi_64);\n }"
    },
    {
      "sha": "753911497c6fa2650c2c242e47d7bc86ff64ed29",
      "filename": "gdb/amd64-linux-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -99,7 +99,7 @@ static int amd64_linux_gregset32_reg_offset[] =\n \n static void\n amd64_linux_collect_native_gregset (const struct regcache *regcache,\n-\t\t\t            void *gregs, int regnum)\n+\t\t\t\t    void *gregs, int regnum)\n {\n   amd64_collect_native_gregset (regcache, gregs, regnum);\n \n@@ -333,7 +333,7 @@ amd64_linux_nat_target::store_registers (struct regcache *regcache, int regnum)\n \n ps_err_e\n ps_get_thread_area (struct ps_prochandle *ph,\n-                    lwpid_t lwpid, int idx, void **base)\n+\t\t    lwpid_t lwpid, int idx, void **base)\n {\n   if (gdbarch_bfd_arch_info (ph->thread->inf->gdbarch)->bits_per_word == 32)\n     {"
    },
    {
      "sha": "d484b1a1c5984cd9728c39a24b88d8473805f15e",
      "filename": "gdb/amd64-linux-tdep.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -284,8 +284,8 @@ amd64_linux_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n       || regnum == AMD64_FSBASE_REGNUM\n       || regnum == AMD64_GSBASE_REGNUM)\n     return (group == system_reggroup\n-            || group == save_reggroup\n-            || group == restore_reggroup);\n+\t    || group == save_reggroup\n+\t    || group == restore_reggroup);\n   return i386_register_reggroup_p (gdbarch, regnum, group);\n }\n \n@@ -1464,7 +1464,7 @@ amd64_linux_syscall_record_common (struct regcache *regcache,\n     case amd64_sys_rt_sigreturn:\n     case amd64_x32_sys_rt_sigreturn:\n       if (amd64_all_but_ip_registers_record (regcache))\n-        return -1;\n+\treturn -1;\n       return 0;\n       break;\n \n@@ -1496,16 +1496,16 @@ amd64_linux_syscall_record_common (struct regcache *regcache,\n   if (syscall_gdb == gdb_sys_no_syscall)\n     {\n       printf_unfiltered (_(\"Process record and replay target doesn't \"\n-                           \"support syscall number %s\\n\"), \n+\t\t\t   \"support syscall number %s\\n\"), \n \t\t\t pulongest (syscall_native));\n       return -1;\n     }\n   else\n     {\n       ret = record_linux_system_call (syscall_gdb, regcache,\n-                                      linux_record_tdep_p);\n+\t\t\t\t      linux_record_tdep_p);\n       if (ret)\n-        return ret;\n+\treturn ret;\n     }\n \n  record_regs:\n@@ -1538,8 +1538,8 @@ amd64_x32_linux_syscall_record (struct regcache *regcache)\n \n static int\n amd64_linux_record_signal (struct gdbarch *gdbarch,\n-                           struct regcache *regcache,\n-                           enum gdb_signal signal)\n+\t\t\t   struct regcache *regcache,\n+\t\t\t   enum gdb_signal signal)\n {\n   ULONGEST rsp;\n \n@@ -1561,8 +1561,8 @@ amd64_linux_record_signal (struct gdbarch *gdbarch,\n      sp -= sizeof (struct rt_sigframe);  */\n   rsp -= AMD64_LINUX_frame_size;\n   if (record_full_arch_list_add_mem (rsp, AMD64_LINUX_redzone\n-                                     + AMD64_LINUX_xstate\n-                                     + AMD64_LINUX_frame_size))\n+\t\t\t\t     + AMD64_LINUX_xstate\n+\t\t\t\t     + AMD64_LINUX_frame_size))\n     return -1;\n \n   if (record_full_arch_list_add_end ())\n@@ -1816,11 +1816,11 @@ amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch)\n   /* Functions for 'catch syscall'.  */\n   set_xml_syscall_file_name (gdbarch, XML_SYSCALL_FILENAME_AMD64);\n   set_gdbarch_get_syscall_number (gdbarch,\n-                                  amd64_linux_get_syscall_number);\n+\t\t\t\t  amd64_linux_get_syscall_number);\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   /* GNU/Linux uses SVR4-style shared libraries.  */\n   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);\n@@ -1837,10 +1837,10 @@ amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Displaced stepping.  */\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n-                                        amd64_displaced_step_copy_insn);\n+\t\t\t\t\tamd64_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, amd64_displaced_step_fixup);\n   set_gdbarch_displaced_step_location (gdbarch,\n-                                       linux_displaced_step_location);\n+\t\t\t\t       linux_displaced_step_location);\n \n   set_gdbarch_process_record (gdbarch, i386_process_record);\n   set_gdbarch_process_record_signal (gdbarch, amd64_linux_record_signal);"
    },
    {
      "sha": "453cc70759a5fac4c5ee4dc4f1ff256ab9d33b5e",
      "filename": "gdb/amd64-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -129,7 +129,7 @@ amd64_collect_native_gregset (const struct regcache *regcache,\n       num_regs = amd64_native_gregset32_num_regs;\n \n       /* Make sure %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp, %esp and\n-         %eip get zero-extended to 64 bits.  */\n+\t %eip get zero-extended to 64 bits.  */\n       for (i = 0; i <= I386_EIP_REGNUM; i++)\n \t{\n \t  if (regnum == -1 || regnum == i)"
    },
    {
      "sha": "b99b6cad444f6970c926ab27fff389dfa92c4a42",
      "filename": "gdb/amd64-obsd-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-obsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -106,11 +106,11 @@ amd64obsd_sigcontext_addr (struct frame_info *this_frame)\n   /* The %rsp register points at `struct sigcontext' upon entry of a\n      signal trampoline.  The relevant part of the trampoline is\n \n-        call    *%rax\n-        movq    %rsp, %rdi\n-        pushq   %rdi\n-        movq    $SYS_sigreturn,%rax\n-        int     $0x80\n+\tcall    *%rax\n+\tmovq    %rsp, %rdi\n+\tpushq   %rdi\n+\tmovq    $SYS_sigreturn,%rax\n+\tint     $0x80\n \n      (see /usr/src/sys/arch/amd64/amd64/locore.S).  The `pushq'\n      instruction clobbers %rsp, but its value is saved in `%rdi'.  */\n@@ -238,7 +238,7 @@ amd64obsd_supply_uthread (struct regcache *regcache,\n       sp = read_memory_unsigned_integer (sp_addr, 8, byte_order);\n \n       /* Adjust the stack pointer such that it looks as if we just\n-         returned from _thread_machdep_switch.  */\n+\t returned from _thread_machdep_switch.  */\n       offset = amd64obsd_uthread_reg_offset[AMD64_RIP_REGNUM] + 8;\n       store_unsigned_integer (buf, 8, byte_order, sp + offset);\n       regcache->raw_supply (AMD64_RSP_REGNUM, buf);\n@@ -250,7 +250,7 @@ amd64obsd_supply_uthread (struct regcache *regcache,\n \t  && (regnum == -1 || regnum == i))\n \t{\n \t  /* Fetch stack pointer from thread structure (if we didn't\n-             do so already).  */\n+\t     do so already).  */\n \t  if (sp == 0)\n \t    sp = read_memory_unsigned_integer (sp_addr, 8, byte_order);\n \n@@ -279,7 +279,7 @@ amd64obsd_collect_uthread (const struct regcache *regcache,\n       int offset;\n \n       /* Calculate the stack pointer (frame pointer) that will be\n-         stored into the thread structure.  */\n+\t stored into the thread structure.  */\n       offset = amd64obsd_uthread_reg_offset[AMD64_RIP_REGNUM] + 8;\n       regcache->raw_collect (AMD64_RSP_REGNUM, buf);\n       sp = extract_unsigned_integer (buf, 8, byte_order) - offset;\n@@ -288,7 +288,7 @@ amd64obsd_collect_uthread (const struct regcache *regcache,\n       write_memory_unsigned_integer (sp_addr, 8, byte_order, sp);\n \n       /* The stack pointer was (potentially) modified.  Make sure we\n-         build a proper stack frame.  */\n+\t build a proper stack frame.  */\n       regnum = -1;\n     }\n \n@@ -298,7 +298,7 @@ amd64obsd_collect_uthread (const struct regcache *regcache,\n \t  && (regnum == -1 || regnum == i))\n \t{\n \t  /* Fetch stack pointer from thread structure (if we didn't\n-             calculate it already).  */\n+\t     calculate it already).  */\n \t  if (sp == 0)\n \t    sp = read_memory_unsigned_integer (sp_addr, 8, byte_order);\n "
    },
    {
      "sha": "975718b1de2e1fdae398c6dc6c3673dd14d379c7",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -652,7 +652,7 @@ static void\n amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n {\n   /* 1. If the size of an object is larger than two eightbytes, or it has\n-        unaligned fields, it has class memory.  */\n+\tunaligned fields, it has class memory.  */\n   if (TYPE_LENGTH (type) > 16 || amd64_has_unaligned_fields (type))\n     {\n       theclass[0] = theclass[1] = AMD64_MEMORY;\n@@ -663,9 +663,9 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n   theclass[0] = theclass[1] = AMD64_NO_CLASS;\n \n   /* 3. Each field of an object is classified recursively so that\n-        always two fields are considered. The resulting class is\n-        calculated according to the classes of the fields in the\n-        eightbyte: */\n+\talways two fields are considered. The resulting class is\n+\tcalculated according to the classes of the fields in the\n+\teightbyte: */\n \n   if (type->code () == TYPE_CODE_ARRAY)\n     {\n@@ -798,8 +798,8 @@ amd64_return_value (struct gdbarch *gdbarch, struct value *function,\n   if (theclass[0] == AMD64_MEMORY)\n     {\n       /* As indicated by the comment above, the ABI guarantees that we\n-         can always find the return value just after the function has\n-         returned.  */\n+\t can always find the return value just after the function has\n+\t returned.  */\n \n       if (readbuf)\n \t{\n@@ -813,7 +813,7 @@ amd64_return_value (struct gdbarch *gdbarch, struct value *function,\n     }\n \n   /* 8. If the class is COMPLEX_X87, the real part of the value is\n-        returned in %st0 and the imaginary part in %st1.  */\n+\treturned in %st0 and the imaginary part in %st1.  */\n   if (theclass[0] == AMD64_COMPLEX_X87)\n     {\n       if (readbuf)\n@@ -854,7 +854,7 @@ amd64_return_value (struct gdbarch *gdbarch, struct value *function,\n \n \tcase AMD64_SSE:\n \t  /* 4. If the class is SSE, the next available SSE register\n-             of the sequence %xmm0, %xmm1 is used.  */\n+\t     of the sequence %xmm0, %xmm1 is used.  */\n \t  regnum = sse_regnum[sse_reg++];\n \t  break;\n \n@@ -868,15 +868,15 @@ amd64_return_value (struct gdbarch *gdbarch, struct value *function,\n \n \tcase AMD64_X87:\n \t  /* 6. If the class is X87, the value is returned on the X87\n-             stack in %st0 as 80-bit x87 number.  */\n+\t     stack in %st0 as 80-bit x87 number.  */\n \t  regnum = AMD64_ST0_REGNUM;\n \t  if (writebuf)\n \t    i387_return_value (gdbarch, regcache);\n \t  break;\n \n \tcase AMD64_X87UP:\n \t  /* 7. If the class is X87UP, the value is returned together\n-             with the previous X87 value in %st0.  */\n+\t     with the previous X87 value in %st0.  */\n \t  gdb_assert (i > 0 && theclass[0] == AMD64_X87);\n \t  regnum = AMD64_ST0_REGNUM;\n \t  offset = 8;\n@@ -950,7 +950,7 @@ if (return_method == return_method_struct)\n       amd64_classify (type, theclass);\n \n       /* Calculate the number of integer and SSE registers needed for\n-         this argument.  */\n+\t this argument.  */\n       for (j = 0; j < 2; j++)\n \t{\n \t  if (theclass[j] == AMD64_INTEGER)\n@@ -960,7 +960,7 @@ if (return_method == return_method_struct)\n \t}\n \n       /* Check whether enough registers are available, and if the\n-         argument should be passed in registers at all.  */\n+\t argument should be passed in registers at all.  */\n       if (integer_reg + needed_integer_regs > ARRAY_SIZE (integer_regnum)\n \t  || sse_reg + needed_sse_regs > ARRAY_SIZE (sse_regnum)\n \t  || (needed_integer_regs == 0 && needed_sse_regs == 0))\n@@ -2389,13 +2389,13 @@ amd64_analyze_prologue (struct gdbarch *gdbarch,\n   if (op == 0x55)\t\t/* pushq %rbp */\n     {\n       /* Take into account that we've executed the `pushq %rbp' that\n-         starts this instruction sequence.  */\n+\t starts this instruction sequence.  */\n       cache->saved_regs[AMD64_RBP_REGNUM] = 0;\n       cache->sp_offset += 8;\n \n       /* If that's all, return now.  */\n       if (current_pc <= pc + 1)\n-        return current_pc;\n+\treturn current_pc;\n \n       read_code (pc + 1, buf, 3);\n \n@@ -2481,7 +2481,7 @@ amd64_skip_xmm_prologue (CORE_ADDR pc, CORE_ADDR start_pc)\n     {\n       /* 0x0f 0x29 0b??000101 movaps %xmmreg?,-0x??(%rbp) */\n       if (buf[offset] != 0x0f || buf[offset + 1] != 0x29\n-          || (buf[offset + 2] & 0x3f) != (xmmreg << 3 | 0x5))\n+\t  || (buf[offset + 2] & 0x3f) != (xmmreg << 3 | 0x5))\n \treturn pc;\n \n       /* 0b01?????? */\n@@ -2523,13 +2523,13 @@ amd64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n       struct compunit_symtab *cust = find_pc_compunit_symtab (func_addr);\n \n       /* LLVM backend (Clang/Flang) always emits a line note before the\n-         prologue and another one after.  We trust clang to emit usable\n-         line notes.  */\n+\t prologue and another one after.  We trust clang to emit usable\n+\t line notes.  */\n       if (post_prologue_pc\n \t  && (cust != NULL\n \t      && COMPUNIT_PRODUCER (cust) != NULL\n \t      && producer_is_llvm (COMPUNIT_PRODUCER (cust))))\n-        return std::max (start_pc, post_prologue_pc);\n+\treturn std::max (start_pc, post_prologue_pc);\n     }\n \n   amd64_init_frame_cache (&cache);"
    },
    {
      "sha": "a6563cc9e1203fbd83090a6c0f38d9de18f9153c",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -144,7 +144,7 @@ amd64_windows_passed_by_xmm_register (struct type *type)\n {\n   return ((type->code () == TYPE_CODE_FLT\n \t   || type->code () == TYPE_CODE_DECFLOAT)\n-          && (TYPE_LENGTH (type) == 4 || TYPE_LENGTH (type) == 8));\n+\t  && (TYPE_LENGTH (type) == 4 || TYPE_LENGTH (type) == 8));\n }\n \n /* Return non-zero iff an argument of the given TYPE should be passed\n@@ -268,7 +268,7 @@ amd64_windows_push_arguments (struct regcache *regcache, int nargs,\n \t  else if (amd64_windows_passed_by_xmm_register (type))\n \t    {\n \t      amd64_windows_store_arg_in_reg\n-\t        (regcache, args[i], AMD64_XMM0_REGNUM + reg_idx);\n+\t\t(regcache, args[i], AMD64_XMM0_REGNUM + reg_idx);\n \t      /* In case of varargs, these parameters must also be\n \t\t passed via the integer registers.  */\n \t      amd64_windows_store_arg_in_reg\n@@ -324,7 +324,7 @@ amd64_windows_push_dummy_call\n   if (return_method == return_method_struct)\n     {\n       /* The \"hidden\" argument is passed throught the first argument\n-         register.  */\n+\t register.  */\n       const int arg_regnum = amd64_windows_dummy_call_integer_regs[0];\n \n       store_unsigned_integer (buf, 8, byte_order, struct_addr);\n@@ -367,8 +367,8 @@ amd64_windows_return_value (struct gdbarch *gdbarch, struct value *function,\n       case TYPE_CODE_FLT:\n \t/* floats, and doubles are returned via XMM0.  */\n \tif (len == 4 || len == 8)\n-          regnum = AMD64_XMM0_REGNUM;\n-        break;\n+\t  regnum = AMD64_XMM0_REGNUM;\n+\tbreak;\n       case TYPE_CODE_ARRAY:\n \t/* __m128, __m128i and __m128d are returned via XMM0.  */\n \tif (type->is_vector () && len == 16)\n@@ -382,20 +382,20 @@ amd64_windows_return_value (struct gdbarch *gdbarch, struct value *function,\n \t  }\n \t/* fall through */\n       default:\n-        /* All other values that are 1, 2, 4 or 8 bytes long are returned\n-           via RAX.  */\n-        if (len == 1 || len == 2 || len == 4 || len == 8)\n-          regnum = AMD64_RAX_REGNUM;\n+\t/* All other values that are 1, 2, 4 or 8 bytes long are returned\n+\t   via RAX.  */\n+\tif (len == 1 || len == 2 || len == 4 || len == 8)\n+\t  regnum = AMD64_RAX_REGNUM;\n \telse if (len == 16 && type->code () == TYPE_CODE_INT)\n \t  regnum = AMD64_XMM0_REGNUM;\n-        break;\n+\tbreak;\n     }\n \n   if (regnum < 0)\n     {\n       /* RAX contains the address where the return value has been stored.  */\n       if (readbuf)\n-        {\n+\t{\n \t  ULONGEST addr;\n \n \t  regcache_raw_read_unsigned (regcache, AMD64_RAX_REGNUM, &addr);\n@@ -1389,9 +1389,9 @@ void\n _initialize_amd64_windows_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64, GDB_OSABI_WINDOWS,\n-                          amd64_windows_init_abi);\n+\t\t\t  amd64_windows_init_abi);\n   gdbarch_register_osabi (bfd_arch_i386, bfd_mach_x86_64, GDB_OSABI_CYGWIN,\n-                          amd64_cygwin_init_abi);\n+\t\t\t  amd64_cygwin_init_abi);\n \n   gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_coff_flavour,\n \t\t\t\t  amd64_windows_osabi_sniffer);"
    },
    {
      "sha": "2895b2bb95956a4986c3d6735b9fc3f022423382",
      "filename": "gdb/annotate.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/annotate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/annotate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/annotate.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -238,8 +238,8 @@ annotate_thread_exited (struct thread_info *t, int silent)\n   if (annotation_level > 1)\n     {\n       printf_filtered((\"\\n\\032\\032thread-exited,\"\n-                       \"id=\\\"%d\\\",group-id=\\\"i%d\\\"\\n\"),\n-                      t->global_num, t->inf->num);\n+\t\t       \"id=\\\"%d\\\",group-id=\\\"i%d\\\"\\n\"),\n+\t\t      t->global_num, t->inf->num);\n     }\n }\n "
    },
    {
      "sha": "bcc73590087209681796e02d10dd2222e2791c5e",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 33,
      "deletions": 33,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -675,35 +675,35 @@ arc_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc,\n    The stack grows downward, so SP points below FP in memory; SP always\n    points to the last used word on the stack, not the first one.\n \n-                      |                       |   |\n-                      |      arg word N       |   | caller's\n-                      |           :           |   | frame\n-                      |      arg word 10      |   |\n-                      |      arg word 9       |   |\n-          old SP ---> +-----------------------+ --+\n-                      |                       |   |\n-                      |      callee-saved     |   |\n-                      |       registers       |   |\n-                      |  including fp, blink  |   |\n-                      |                       |   | callee's\n-          new FP ---> +-----------------------+   | frame\n-                      |                       |   |\n-                      |         local         |   |\n-                      |       variables       |   |\n-                      |                       |   |\n-                      |       register        |   |\n-                      |      spill area       |   |\n-                      |                       |   |\n-                      |     outgoing args     |   |\n-                      |                       |   |\n-          new SP ---> +-----------------------+ --+\n-                      |                       |\n-                      |         unused        |\n-                      |                       |\n-                                  |\n-                                  |\n-                                  V\n-                              downwards\n+\t\t      |                       |   |\n+\t\t      |      arg word N       |   | caller's\n+\t\t      |           :           |   | frame\n+\t\t      |      arg word 10      |   |\n+\t\t      |      arg word 9       |   |\n+\t  old SP ---> +-----------------------+ --+\n+\t\t      |                       |   |\n+\t\t      |      callee-saved     |   |\n+\t\t      |       registers       |   |\n+\t\t      |  including fp, blink  |   |\n+\t\t      |                       |   | callee's\n+\t  new FP ---> +-----------------------+   | frame\n+\t\t      |                       |   |\n+\t\t      |         local         |   |\n+\t\t      |       variables       |   |\n+\t\t      |                       |   |\n+\t\t      |       register        |   |\n+\t\t      |      spill area       |   |\n+\t\t      |                       |   |\n+\t\t      |     outgoing args     |   |\n+\t\t      |                       |   |\n+\t  new SP ---> +-----------------------+ --+\n+\t\t      |                       |\n+\t\t      |         unused        |\n+\t\t      |                       |\n+\t\t\t\t  |\n+\t\t\t\t  |\n+\t\t\t\t  V\n+\t\t\t      downwards\n \n    The list of arguments to be passed to a function is considered to be a\n    sequence of _N_ words (as though all the parameters were stored in order in\n@@ -1958,7 +1958,7 @@ determine_core_reg_feature_set (const unsigned long mach)\n       return &arc_v2_core_reg_feature;\n     default:\n       gdb_assert_not_reached\n-        (\"Unknown machine type to determine the core feature set.\");\n+\t(\"Unknown machine type to determine the core feature set.\");\n     }\n }\n \n@@ -1974,8 +1974,8 @@ determine_aux_reg_feature_set ()\n /* Update accumulator register names (ACCH/ACCL) for r58 and r59 in the\n    register sets.  The endianness determines the assignment:\n \n-        ,------.------.\n-        | acch | accl |\n+\t,------.------.\n+\t| acch | accl |\n    ,----|------+------|\n    | LE | r59  | r58  |\n    | BE | r58  | r59  |\n@@ -2139,7 +2139,7 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n   if (!valid_p)\n     {\n       if (arc_debug)\n-        debug_printf (\"arc: Target description is not valid\\n\");\n+\tdebug_printf (\"arc: Target description is not valid\\n\");\n       return false;\n     }\n "
    },
    {
      "sha": "e50df82091972ecc5bf61ea7bd75ec7c5b351bce",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -210,7 +210,7 @@ legacy_virtual_frame_pointer (struct gdbarch *gdbarch,\n     *frame_regnum = gdbarch_deprecated_fp_regnum (gdbarch);\n   else if (gdbarch_sp_regnum (gdbarch) >= 0\n \t   && gdbarch_sp_regnum (gdbarch)\n-\t        < gdbarch_num_regs (gdbarch))\n+\t\t< gdbarch_num_regs (gdbarch))\n     *frame_regnum = gdbarch_sp_regnum (gdbarch);\n   else\n     /* Should this be an internal error?  I guess so, it is reflecting\n@@ -1038,11 +1038,11 @@ default_get_pc_address_flags (frame_info *frame, CORE_ADDR pc)\n /* See arch-utils.h.  */\n void\n default_read_core_file_mappings (struct gdbarch *gdbarch,\n-                                 struct bfd *cbfd,\n+\t\t\t\t struct bfd *cbfd,\n \t\t\t\t gdb::function_view<void (ULONGEST count)>\n \t\t\t\t   pre_loop_cb,\n \t\t\t\t gdb::function_view<void (int num,\n-\t\t\t\t                          ULONGEST start,\n+\t\t\t\t\t\t\t  ULONGEST start,\n \t\t\t\t\t\t\t  ULONGEST end,\n \t\t\t\t\t\t\t  ULONGEST file_ofs,\n \t\t\t\t\t\t\t  const char *filename,"
    },
    {
      "sha": "d76d86f16bb3e490a0e3c7089f22207598f59002",
      "filename": "gdb/arch/arm-get-next-pcs.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch/arm-get-next-pcs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch/arm-get-next-pcs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/arm-get-next-pcs.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -77,7 +77,7 @@ thumb_deal_with_atomic_sequence_raw (struct arm_get_next_pcs *self)\n \n   loc += 2;\n   if (!((insn1 & 0xfff0) == 0xe850\n-        || ((insn1 & 0xfff0) == 0xe8d0 && (insn2 & 0x00c0) == 0x0040)))\n+\t|| ((insn1 & 0xfff0) == 0xe8d0 && (insn2 & 0x00c0) == 0x0040)))\n     return {};\n \n   /* Assume that no atomic sequence is longer than \"atomic_sequence_length\"\n@@ -215,20 +215,20 @@ arm_deal_with_atomic_sequence_raw (struct arm_get_next_pcs *self)\n       loc += 4;\n \n       /* Assume that there is at most one conditional branch in the atomic\n-         sequence.  If a conditional branch is found, put a breakpoint in\n-         its destination address.  */\n+\t sequence.  If a conditional branch is found, put a breakpoint in\n+\t its destination address.  */\n       if (bits (insn, 24, 27) == 0xa)\n \t{\n-          if (last_breakpoint > 0)\n-            return {}; /* More than one conditional branch found, fallback\n+\t  if (last_breakpoint > 0)\n+\t    return {}; /* More than one conditional branch found, fallback\n \t\t\t  to the standard single-step code.  */\n \n \t  breaks[1] = BranchDest (loc - 4, insn);\n \t  last_breakpoint++;\n-        }\n+\t}\n \n       /* We do not support atomic sequences that use any *other* instructions\n-         but conditional branches to change the PC.  Fall back to standard\n+\t but conditional branches to change the PC.  Fall back to standard\n \t code to avoid losing control of execution.  */\n       else if (arm_instruction_changes_pc (insn))\n \treturn {};\n@@ -408,7 +408,7 @@ thumb_get_next_pcs_raw (struct arm_get_next_pcs *self)\n       CORE_ADDR sp;\n \n       /* Fetch the saved PC from the stack.  It's stored above\n-         all of the other registers.  */\n+\t all of the other registers.  */\n       unsigned long offset\n \t= count_one_bits (bits (inst1, 0, 7)) * ARM_INT_REGISTER_SIZE;\n       sp = regcache_raw_get_unsigned (regcache, ARM_SP_REGNUM);\n@@ -679,7 +679,7 @@ arm_get_next_pcs_raw (struct arm_get_next_pcs *self)\n       case 0xd:\n       case 0xe:\n \t/* Coprocessor register transfer.  */\n-        if (bits (this_instr, 12, 15) == 15)\n+\tif (bits (this_instr, 12, 15) == 15)\n \t  error (_(\"Invalid update to pc in instruction\"));\n \tbreak;\n       }"
    },
    {
      "sha": "32720eccfd93819eddc932bbc168d49296725427",
      "filename": "gdb/arch/arm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch/arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arch/arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/arm.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -119,7 +119,7 @@ arm_instruction_changes_pc (uint32_t this_instr)\n       case 0xd:\n       case 0xe:\n \t/* Coprocessor register transfer.  */\n-        if (bits (this_instr, 12, 15) == 15)\n+\tif (bits (this_instr, 12, 15) == 15)\n \t  error (_(\"Invalid update to pc in instruction\"));\n \treturn 0;\n       default:"
    },
    {
      "sha": "e589ff01e19dcebcac7161e69468ffaa9e57e99a",
      "filename": "gdb/arm-linux-nat.c",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -515,7 +515,7 @@ supply_fpregset (struct regcache *regcache, const gdb_fpregset_t *fpregsetp)\n \n ps_err_e\n ps_get_thread_area (struct ps_prochandle *ph,\n-                    lwpid_t lwpid, int idx, void **base)\n+\t\t    lwpid_t lwpid, int idx, void **base)\n {\n   if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)\n     return PS_ERR;\n@@ -619,18 +619,18 @@ arm_linux_get_hwbp_cap (void)\n \t  info.bp_count = (gdb_byte)(val & 0xff);\n \n       if (info.wp_count > MAX_WPTS)\n-        {\n-          warning (_(\"arm-linux-gdb supports %d hardware watchpoints but target \\\n-                      supports %d\"), MAX_WPTS, info.wp_count);\n-          info.wp_count = MAX_WPTS;\n-        }\n+\t{\n+\t  warning (_(\"arm-linux-gdb supports %d hardware watchpoints but target \\\n+\t\t      supports %d\"), MAX_WPTS, info.wp_count);\n+\t  info.wp_count = MAX_WPTS;\n+\t}\n \n       if (info.bp_count > MAX_BPTS)\n-        {\n-          warning (_(\"arm-linux-gdb supports %d hardware breakpoints but target \\\n-                      supports %d\"), MAX_BPTS, info.bp_count);\n-          info.bp_count = MAX_BPTS;\n-        }\n+\t{\n+\t  warning (_(\"arm-linux-gdb supports %d hardware breakpoints but target \\\n+\t\t      supports %d\"), MAX_BPTS, info.bp_count);\n+\t  info.bp_count = MAX_BPTS;\n+\t}\n \t  available = (info.arch != 0);\n \t}\n     }\n@@ -717,7 +717,7 @@ struct arm_linux_hw_breakpoint\n    The Linux vector is indexed as follows:\n       -((i << 1) + 2): Control register for watchpoint i.\n       -((i << 1) + 1): Address register for watchpoint i.\n-                    0: Information register.\n+\t\t    0: Information register.\n        ((i << 1) + 1): Address register for breakpoint i.\n        ((i << 1) + 2): Control register for breakpoint i.\n \n@@ -963,7 +963,7 @@ update_registers_callback (struct lwp_info *lwp, int watch, int index)\n    =1) BPT for thread TID.  */\n static void\n arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt, \n-                                 int watchpoint)\n+\t\t\t\t int watchpoint)\n {\n   int pid;\n   ptid_t pid_ptid;\n@@ -987,14 +987,14 @@ arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt,\n   for (i = 0; i < count; ++i)\n     if (!arm_hwbp_control_is_enabled (bpts[i].control))\n       {\n-        bpts[i] = *bpt;\n-        iterate_over_lwps (pid_ptid,\n+\tbpts[i] = *bpt;\n+\titerate_over_lwps (pid_ptid,\n \t\t\t   [=] (struct lwp_info *info)\n \t\t\t   {\n \t\t\t     return update_registers_callback (info, watchpoint,\n \t\t\t\t\t\t\t       i);\n \t\t\t   });\n-        break;\n+\tbreak;\n       }\n \n   gdb_assert (i != count);\n@@ -1004,7 +1004,7 @@ arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt,\n    (WATCHPOINT = 1) BPT for thread TID.  */\n static void\n arm_linux_remove_hw_breakpoint1 (const struct arm_linux_hw_breakpoint *bpt, \n-                                 int watchpoint)\n+\t\t\t\t int watchpoint)\n {\n   int pid;\n   gdb_byte count, i;\n@@ -1028,14 +1028,14 @@ arm_linux_remove_hw_breakpoint1 (const struct arm_linux_hw_breakpoint *bpt,\n   for (i = 0; i < count; ++i)\n     if (arm_linux_hw_breakpoint_equal (bpt, bpts + i))\n       {\n-        bpts[i].control = arm_hwbp_control_disable (bpts[i].control);\n+\tbpts[i].control = arm_hwbp_control_disable (bpts[i].control);\n \titerate_over_lwps (pid_ptid,\n \t\t\t   [=] (struct lwp_info *info)\n \t\t\t   {\n \t\t\t     return update_registers_callback (info, watchpoint,\n \t\t\t\t\t\t\t       i);\n \t\t\t   });\n-        break;\n+\tbreak;\n       }\n \n   gdb_assert (i != count);\n@@ -1241,35 +1241,35 @@ arm_linux_nat_target::low_prepare_to_resume (struct lwp_info *lwp)\n   for (i = 0; i < arm_linux_get_hw_breakpoint_count (); i++)\n     if (arm_lwp_info->bpts_changed[i])\n       {\n-        errno = 0;\n-        if (arm_hwbp_control_is_enabled (bpts[i].control))\n-          if (ptrace (PTRACE_SETHBPREGS, pid,\n-              (PTRACE_TYPE_ARG3) ((i << 1) + 1), &bpts[i].address) < 0)\n-            perror_with_name (_(\"Unexpected error setting breakpoint\"));\n-\n-        if (bpts[i].control != 0)\n-          if (ptrace (PTRACE_SETHBPREGS, pid,\n-              (PTRACE_TYPE_ARG3) ((i << 1) + 2), &bpts[i].control) < 0)\n-            perror_with_name (_(\"Unexpected error setting breakpoint\"));\n-\n-        arm_lwp_info->bpts_changed[i] = 0;\n+\terrno = 0;\n+\tif (arm_hwbp_control_is_enabled (bpts[i].control))\n+\t  if (ptrace (PTRACE_SETHBPREGS, pid,\n+\t      (PTRACE_TYPE_ARG3) ((i << 1) + 1), &bpts[i].address) < 0)\n+\t    perror_with_name (_(\"Unexpected error setting breakpoint\"));\n+\n+\tif (bpts[i].control != 0)\n+\t  if (ptrace (PTRACE_SETHBPREGS, pid,\n+\t      (PTRACE_TYPE_ARG3) ((i << 1) + 2), &bpts[i].control) < 0)\n+\t    perror_with_name (_(\"Unexpected error setting breakpoint\"));\n+\n+\tarm_lwp_info->bpts_changed[i] = 0;\n       }\n \n   for (i = 0; i < arm_linux_get_hw_watchpoint_count (); i++)\n     if (arm_lwp_info->wpts_changed[i])\n       {\n-        errno = 0;\n-        if (arm_hwbp_control_is_enabled (wpts[i].control))\n-          if (ptrace (PTRACE_SETHBPREGS, pid,\n-              (PTRACE_TYPE_ARG3) -((i << 1) + 1), &wpts[i].address) < 0)\n-            perror_with_name (_(\"Unexpected error setting watchpoint\"));\n-\n-        if (wpts[i].control != 0)\n-          if (ptrace (PTRACE_SETHBPREGS, pid,\n-              (PTRACE_TYPE_ARG3) -((i << 1) + 2), &wpts[i].control) < 0)\n-            perror_with_name (_(\"Unexpected error setting watchpoint\"));\n-\n-        arm_lwp_info->wpts_changed[i] = 0;\n+\terrno = 0;\n+\tif (arm_hwbp_control_is_enabled (wpts[i].control))\n+\t  if (ptrace (PTRACE_SETHBPREGS, pid,\n+\t      (PTRACE_TYPE_ARG3) -((i << 1) + 1), &wpts[i].address) < 0)\n+\t    perror_with_name (_(\"Unexpected error setting watchpoint\"));\n+\n+\tif (wpts[i].control != 0)\n+\t  if (ptrace (PTRACE_SETHBPREGS, pid,\n+\t      (PTRACE_TYPE_ARG3) -((i << 1) + 2), &wpts[i].control) < 0)\n+\t    perror_with_name (_(\"Unexpected error setting watchpoint\"));\n+\n+\tarm_lwp_info->wpts_changed[i] = 0;\n       }\n }\n "
    },
    {
      "sha": "2d563c2b024f0a36431d1724affab3e58ed90509",
      "filename": "gdb/arm-linux-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -728,15 +728,15 @@ arm_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n \n static const struct target_desc *\n arm_linux_core_read_description (struct gdbarch *gdbarch,\n-                                 struct target_ops *target,\n-                                 bfd *abfd)\n+\t\t\t\t struct target_ops *target,\n+\t\t\t\t bfd *abfd)\n {\n   CORE_ADDR arm_hwcap = linux_get_hwcap (target);\n \n   if (arm_hwcap & HWCAP_VFP)\n     {\n       /* NEON implies VFPv3-D32 or no-VFP unit.  Say that we only support\n-         Neon with VFPv3-D32.  */\n+\t Neon with VFPv3-D32.  */\n       if (arm_hwcap & HWCAP_NEON)\n \treturn aarch32_read_description ();\n       else if ((arm_hwcap & (HWCAP_VFPv3 | HWCAP_VFPv3D16)) == HWCAP_VFPv3)\n@@ -850,12 +850,12 @@ arm_linux_get_syscall_number (struct gdbarch *gdbarch,\n \n       if (svc_operand)\n \t{\n-          /* OABI */\n+\t  /* OABI */\n \t  svc_number = svc_operand - 0x900000;\n \t}\n       else\n \t{\n-          /* EABI */\n+\t  /* EABI */\n \t  regcache_cooked_read_unsigned (regs, 7, &svc_number);\n \t}\n     }\n@@ -1028,7 +1028,7 @@ arm_linux_copy_svc (struct gdbarch *gdbarch, struct regcache *regs,\n \t\t  location, else nothing.\n      Insn: unmodified svc.\n      Cleanup: if pc lands in scratch space, pc <- insn_addr + insn_size\n-              else leave pc alone.  */\n+\t      else leave pc alone.  */\n \n \n   dsc->cleanup = &arm_linux_cleanup_svc;\n@@ -1077,7 +1077,7 @@ arm_catch_kernel_helper_return (struct gdbarch *gdbarch, CORE_ADDR from,\n   dsc->wrote_to_pc = 1;\n \n   /* Preparation: tmp[0] <- r14\n-                  r14 <- <scratch space>+4\n+\t\t  r14 <- <scratch space>+4\n \t\t  *(<scratch space>+8) <- from\n      Insn: ldr pc, [r14, #4]\n      Cleanup: r14 <- tmp[0], pc <- tmp[0].  */\n@@ -1634,7 +1634,7 @@ arm_all_but_pc_registers_record (struct regcache *regcache)\n   for (i = 0; i < ARM_PC_REGNUM; i++)\n     {\n       if (record_full_arch_list_add_reg (regcache, ARM_A1_REGNUM + i))\n-        return -1;\n+\treturn -1;\n     }\n \n   if (record_full_arch_list_add_reg (regcache, ARM_PS_REGNUM))\n@@ -1656,8 +1656,8 @@ arm_linux_syscall_record (struct regcache *regcache, unsigned long svc_number)\n   if (syscall_gdb == gdb_sys_no_syscall)\n     {\n       printf_unfiltered (_(\"Process record and replay target doesn't \"\n-                           \"support syscall number %s\\n\"),\n-                           plongest (svc_number));\n+\t\t\t   \"support syscall number %s\\n\"),\n+\t\t\t   plongest (svc_number));\n       return -1;\n     }\n \n@@ -1670,7 +1670,7 @@ arm_linux_syscall_record (struct regcache *regcache, unsigned long svc_number)\n    }\n \n   ret = record_linux_system_call (syscall_gdb, regcache,\n-                                  &arm_linux_record_tdep);\n+\t\t\t\t  &arm_linux_record_tdep);\n   if (ret != 0)\n     return ret;\n \n@@ -1762,7 +1762,7 @@ arm_linux_init_abi (struct gdbarch_info info,\n     default:\n       internal_error\n \t(__FILE__, __LINE__,\n-         _(\"arm_linux_init_abi: Floating point model not supported\"));\n+\t _(\"arm_linux_init_abi: Floating point model not supported\"));\n       break;\n     }\n   tdep->jb_elt_size = ARM_LINUX_JB_ELEMENT_SIZE;\n@@ -1779,7 +1779,7 @@ arm_linux_init_abi (struct gdbarch_info info,\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   tramp_frame_prepend_unwinder (gdbarch,\n \t\t\t\t&arm_linux_sigreturn_tramp_frame);"
    },
    {
      "sha": "e4cfc96473a419f2455f1ab69d7a971be94d4641",
      "filename": "gdb/arm-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -167,5 +167,5 @@ void\n _initialize_arm_netbsd_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_NETBSD,\n-                          arm_netbsd_elf_init_abi);\n+\t\t\t  arm_netbsd_elf_init_abi);\n }"
    },
    {
      "sha": "bbba2c3e69007a7baf1468089de78e8eaff16e0d",
      "filename": "gdb/arm-pikeos-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-pikeos-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-pikeos-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-pikeos-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -87,7 +87,7 @@ _initialize_arm_pikeos_tdep ()\n {\n   /* Register the sniffer for the PikeOS targets.  */\n   gdbarch_register_osabi_sniffer (bfd_arch_arm, bfd_target_elf_flavour,\n-                                  arm_pikeos_osabi_sniffer);\n+\t\t\t\t  arm_pikeos_osabi_sniffer);\n   gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_PIKEOS,\n-                          arm_pikeos_init_abi);\n+\t\t\t  arm_pikeos_init_abi);\n }"
    },
    {
      "sha": "82e8ec4df49c5d794ab5adf6884801ee1c275136",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 1214,
      "deletions": 1214,
      "changes": 2428,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "fd7e2ea7e766b4b2ccf92e0d219e66057e5dfe4a",
      "filename": "gdb/arm-tdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -194,7 +194,7 @@ struct arm_displaced_step_closure : public displaced_step_closure\n     struct\n     {\n       /* If non-NULL, override generic SVC handling (e.g. for a particular\n-         OS).  */\n+\t OS).  */\n       int (*copy_svc_os) (struct gdbarch *gdbarch, struct regcache *regs,\n \t\t\t  arm_displaced_step_closure *dsc);\n     } svc;\n@@ -273,7 +273,7 @@ extern int arm_psr_thumb_bit (struct gdbarch *);\n extern int arm_pc_is_thumb (struct gdbarch *, CORE_ADDR);\n \n extern int arm_process_record (struct gdbarch *gdbarch, \n-                               struct regcache *regcache, CORE_ADDR addr);\n+\t\t\t       struct regcache *regcache, CORE_ADDR addr);\n /* Functions exported from arm-bsd-tdep.h.  */\n \n /* Return the appropriate register set for the core section identified"
    },
    {
      "sha": "d2a5d074098a0c7c6b2aa603090fa71a05dea35e",
      "filename": "gdb/arm-wince-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-wince-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/arm-wince-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-wince-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -159,8 +159,8 @@ void\n _initialize_arm_wince_tdep ()\n {\n   gdbarch_register_osabi_sniffer (bfd_arch_arm, bfd_target_coff_flavour,\n-                                  arm_wince_osabi_sniffer);\n+\t\t\t\t  arm_wince_osabi_sniffer);\n \n   gdbarch_register_osabi (bfd_arch_arm, 0, GDB_OSABI_WINCE,\n-                          arm_wince_init_abi);\n+\t\t\t  arm_wince_init_abi);\n }"
    },
    {
      "sha": "71f0ecda7a766432b5dd49d624004769f9c62083",
      "filename": "gdb/auto-load.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/auto-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/auto-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auto-load.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -364,7 +364,7 @@ filename_is_in_pattern_1 (char *filename, char *pattern)\n   for (;;)\n     {\n       /* Trim trailing slashes (\"/\").  PATTERN also has slashes trimmed the\n-         same way so they will match.  */\n+\t same way so they will match.  */\n       while (filename_len && IS_DIR_SEPARATOR (filename[filename_len - 1]))\n \tfilename_len--;\n       filename[filename_len] = '\\0';"
    },
    {
      "sha": "a73c3ebdf057d2f2e3f700f60a910ba46907121f",
      "filename": "gdb/auxv.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/auxv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/auxv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auxv.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -192,8 +192,8 @@ ld_so_xfer_auxv (gdb_byte *readbuf,\n       len -= block;\n \n       /* Check terminal AT_NULL.  This function is being called\n-         indefinitely being extended its READBUF until it returns EOF\n-         (0).  */\n+\t indefinitely being extended its READBUF until it returns EOF\n+\t (0).  */\n \n       while (block >= auxv_pair_size)\n \t{"
    },
    {
      "sha": "2b0854c8c46b5cc11a4569e9e98855f958049aa3",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 179,
      "deletions": 179,
      "changes": 358,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -382,12 +382,12 @@ static void\n avr_write_pc (struct regcache *regcache, CORE_ADDR val)\n {\n   regcache_cooked_write_unsigned (regcache, AVR_PC_REGNUM,\n-                                  avr_convert_iaddr_to_raw (val));\n+\t\t\t\t  avr_convert_iaddr_to_raw (val));\n }\n \n static enum register_status\n avr_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n-                          int regnum, gdb_byte *buf)\n+\t\t\t  int regnum, gdb_byte *buf)\n {\n   ULONGEST val;\n   enum register_status status;\n@@ -408,7 +408,7 @@ avr_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \n static void\n avr_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n-                           int regnum, const gdb_byte *buf)\n+\t\t\t   int regnum, const gdb_byte *buf)\n {\n   ULONGEST val;\n \n@@ -433,87 +433,87 @@ avr_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n    This information is stored in the avr_unwind_cache structure.\n \n    Some devices lack the sbiw instruction, so on those replace this:\n-        sbiw    r28, XX\n+\tsbiw    r28, XX\n    with this:\n-        subi    r28,lo8(XX)\n-        sbci    r29,hi8(XX)\n+\tsubi    r28,lo8(XX)\n+\tsbci    r29,hi8(XX)\n \n    A typical AVR function prologue with a frame pointer might look like this:\n-        push    rXX        ; saved regs\n-        ...\n-        push    r28\n-        push    r29\n-        in      r28,__SP_L__\n-        in      r29,__SP_H__\n-        sbiw    r28,<LOCALS_SIZE>\n-        in      __tmp_reg__,__SREG__\n-        cli\n-        out     __SP_H__,r29\n-        out     __SREG__,__tmp_reg__\n-        out     __SP_L__,r28\n+\tpush    rXX        ; saved regs\n+\t...\n+\tpush    r28\n+\tpush    r29\n+\tin      r28,__SP_L__\n+\tin      r29,__SP_H__\n+\tsbiw    r28,<LOCALS_SIZE>\n+\tin      __tmp_reg__,__SREG__\n+\tcli\n+\tout     __SP_H__,r29\n+\tout     __SREG__,__tmp_reg__\n+\tout     __SP_L__,r28\n \n    A typical AVR function prologue without a frame pointer might look like\n    this:\n-        push    rXX        ; saved regs\n-        ...\n+\tpush    rXX        ; saved regs\n+\t...\n \n    A main function prologue looks like this:\n-        ldi     r28,lo8(<RAM_ADDR> - <LOCALS_SIZE>)\n-        ldi     r29,hi8(<RAM_ADDR> - <LOCALS_SIZE>)\n-        out     __SP_H__,r29\n-        out     __SP_L__,r28\n+\tldi     r28,lo8(<RAM_ADDR> - <LOCALS_SIZE>)\n+\tldi     r29,hi8(<RAM_ADDR> - <LOCALS_SIZE>)\n+\tout     __SP_H__,r29\n+\tout     __SP_L__,r28\n \n    A signal handler prologue looks like this:\n-        push    __zero_reg__\n-        push    __tmp_reg__\n-        in      __tmp_reg__, __SREG__\n-        push    __tmp_reg__\n-        clr     __zero_reg__\n-        push    rXX             ; save registers r18:r27, r30:r31\n-        ...\n-        push    r28             ; save frame pointer\n-        push    r29\n-        in      r28, __SP_L__\n-        in      r29, __SP_H__\n-        sbiw    r28, <LOCALS_SIZE>\n-        out     __SP_H__, r29\n-        out     __SP_L__, r28\n-        \n+\tpush    __zero_reg__\n+\tpush    __tmp_reg__\n+\tin      __tmp_reg__, __SREG__\n+\tpush    __tmp_reg__\n+\tclr     __zero_reg__\n+\tpush    rXX             ; save registers r18:r27, r30:r31\n+\t...\n+\tpush    r28             ; save frame pointer\n+\tpush    r29\n+\tin      r28, __SP_L__\n+\tin      r29, __SP_H__\n+\tsbiw    r28, <LOCALS_SIZE>\n+\tout     __SP_H__, r29\n+\tout     __SP_L__, r28\n+\t\n    A interrupt handler prologue looks like this:\n-        sei\n-        push    __zero_reg__\n-        push    __tmp_reg__\n-        in      __tmp_reg__, __SREG__\n-        push    __tmp_reg__\n-        clr     __zero_reg__\n-        push    rXX             ; save registers r18:r27, r30:r31\n-        ...\n-        push    r28             ; save frame pointer\n-        push    r29\n-        in      r28, __SP_L__\n-        in      r29, __SP_H__\n-        sbiw    r28, <LOCALS_SIZE>\n-        cli\n-        out     __SP_H__, r29\n-        sei     \n-        out     __SP_L__, r28\n+\tsei\n+\tpush    __zero_reg__\n+\tpush    __tmp_reg__\n+\tin      __tmp_reg__, __SREG__\n+\tpush    __tmp_reg__\n+\tclr     __zero_reg__\n+\tpush    rXX             ; save registers r18:r27, r30:r31\n+\t...\n+\tpush    r28             ; save frame pointer\n+\tpush    r29\n+\tin      r28, __SP_L__\n+\tin      r29, __SP_H__\n+\tsbiw    r28, <LOCALS_SIZE>\n+\tcli\n+\tout     __SP_H__, r29\n+\tsei     \n+\tout     __SP_L__, r28\n \n    A `-mcall-prologues' prologue looks like this (Note that the megas use a\n    jmp instead of a rjmp, thus the prologue is one word larger since jmp is a\n    32 bit insn and rjmp is a 16 bit insn):\n-        ldi     r26,lo8(<LOCALS_SIZE>)\n-        ldi     r27,hi8(<LOCALS_SIZE>)\n-        ldi     r30,pm_lo8(.L_foo_body)\n-        ldi     r31,pm_hi8(.L_foo_body)\n-        rjmp    __prologue_saves__+RRR\n-        .L_foo_body:  */\n+\tldi     r26,lo8(<LOCALS_SIZE>)\n+\tldi     r27,hi8(<LOCALS_SIZE>)\n+\tldi     r30,pm_lo8(.L_foo_body)\n+\tldi     r31,pm_hi8(.L_foo_body)\n+\trjmp    __prologue_saves__+RRR\n+\t.L_foo_body:  */\n \n /* Not really part of a prologue, but still need to scan for it, is when a\n    function prologue moves values passed via registers as arguments to new\n    registers.  In this case, all local variables live in registers, so there\n    may be some register saves.  This is what it looks like:\n-        movw    rMM, rNN\n-        ...\n+\tmovw    rMM, rNN\n+\t...\n \n    There could be multiple movw's.  If the target doesn't have a movw insn, it\n    will use two mov insns.  This could be done after any of the above prologue\n@@ -569,9 +569,9 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t      if (vpc + 4 + sizeof (img) < len\n \t\t  && memcmp (prologue + vpc + 4, img, sizeof (img)) == 0)\n \t\t{\n-                  info->prologue_type = AVR_PROLOGUE_MAIN;\n-                  info->base = locals;\n-                  return pc_beg + 4;\n+\t\t  info->prologue_type = AVR_PROLOGUE_MAIN;\n+\t\t  info->base = locals;\n+\t\t  return pc_beg + 4;\n \t\t}\n \t    }\n \t}\n@@ -627,46 +627,46 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n       insn = extract_unsigned_integer (&prologue[vpc + 8], 2, byte_order);\n       /* rjmp __prologue_saves__+RRR */\n       if ((insn & 0xf000) == 0xc000)\n-        {\n-          /* Extract PC relative offset from RJMP */\n-          i = (insn & 0xfff) | (insn & 0x800 ? (-1 ^ 0xfff) : 0);\n-          /* Convert offset to byte addressable mode */\n-          i *= 2;\n-          /* Destination address */\n-          i += pc_beg + 10;\n-\n-          if (body_addr != (pc_beg + 10)/2)\n-            break;\n-\n-          pc_offset += 2;\n-        }\n+\t{\n+\t  /* Extract PC relative offset from RJMP */\n+\t  i = (insn & 0xfff) | (insn & 0x800 ? (-1 ^ 0xfff) : 0);\n+\t  /* Convert offset to byte addressable mode */\n+\t  i *= 2;\n+\t  /* Destination address */\n+\t  i += pc_beg + 10;\n+\n+\t  if (body_addr != (pc_beg + 10)/2)\n+\t    break;\n+\n+\t  pc_offset += 2;\n+\t}\n       else if ((insn & 0xfe0e) == 0x940c)\n-        {\n-          /* Extract absolute PC address from JMP */\n-          i = (((insn & 0x1) | ((insn & 0x1f0) >> 3) << 16)\n+\t{\n+\t  /* Extract absolute PC address from JMP */\n+\t  i = (((insn & 0x1) | ((insn & 0x1f0) >> 3) << 16)\n \t       | (extract_unsigned_integer (&prologue[vpc + 10], 2, byte_order)\n \t\t  & 0xffff));\n-          /* Convert address to byte addressable mode */\n-          i *= 2;\n+\t  /* Convert address to byte addressable mode */\n+\t  i *= 2;\n \n-          if (body_addr != (pc_beg + 12)/2)\n-            break;\n+\t  if (body_addr != (pc_beg + 12)/2)\n+\t    break;\n \n-          pc_offset += 4;\n-        }\n+\t  pc_offset += 4;\n+\t}\n       else\n-        break;\n+\tbreak;\n \n       /* Resolve offset (in words) from __prologue_saves__ symbol.\n-         Which is a pushes count in `-mcall-prologues' mode */\n+\t Which is a pushes count in `-mcall-prologues' mode */\n       num_pushes = AVR_MAX_PUSHES - (i - BMSYMBOL_VALUE_ADDRESS (msymbol)) / 2;\n \n       if (num_pushes > AVR_MAX_PUSHES)\n-        {\n-          fprintf_unfiltered (gdb_stderr, _(\"Num pushes too large: %d\\n\"),\n-                              num_pushes);\n-          num_pushes = 0;\n-        }\n+\t{\n+\t  fprintf_unfiltered (gdb_stderr, _(\"Num pushes too large: %d\\n\"),\n+\t\t\t      num_pushes);\n+\t  num_pushes = 0;\n+\t}\n \n       if (num_pushes)\n \t{\n@@ -705,22 +705,22 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n       if (len >= sizeof (img)\n \t  && memcmp (prologue, img, sizeof (img)) == 0)\n \t{\n-          info->prologue_type = AVR_PROLOGUE_INTR;\n+\t  info->prologue_type = AVR_PROLOGUE_INTR;\n \t  vpc += sizeof (img);\n-          info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n-          info->saved_regs[0].addr = 2;\n-          info->saved_regs[1].addr = 1;\n-          info->size += 3;\n+\t  info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n+\t  info->saved_regs[0].addr = 2;\n+\t  info->saved_regs[1].addr = 1;\n+\t  info->size += 3;\n \t}\n       else if (len >= sizeof (img) - 2\n \t       && memcmp (img + 2, prologue, sizeof (img) - 2) == 0)\n \t{\n-          info->prologue_type = AVR_PROLOGUE_SIG;\n-          vpc += sizeof (img) - 2;\n-          info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n-          info->saved_regs[0].addr = 2;\n-          info->saved_regs[1].addr = 1;\n-          info->size += 2;\n+\t  info->prologue_type = AVR_PROLOGUE_SIG;\n+\t  vpc += sizeof (img) - 2;\n+\t  info->saved_regs[AVR_SREG_REGNUM].addr = 3;\n+\t  info->saved_regs[0].addr = 2;\n+\t  info->saved_regs[1].addr = 1;\n+\t  info->size += 2;\n \t}\n     }\n \n@@ -750,17 +750,17 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n     {\n       insn = extract_unsigned_integer (&prologue[vpc], 2, byte_order);\n       if (insn == 0xd000)\t/* rcall .+0 */\n-        {\n-          info->size += gdbarch_tdep (gdbarch)->call_length;\n-          vpc += 2;\n-        }\n+\t{\n+\t  info->size += gdbarch_tdep (gdbarch)->call_length;\n+\t  vpc += 2;\n+\t}\n       else if (insn == 0x920f || insn == 0x921f)  /* push r0 or push r1 */\n-        {\n-          info->size += 1;\n-          vpc += 2;\n-        }\n+\t{\n+\t  info->size += 1;\n+\t  vpc += 2;\n+\t}\n       else\n-        break;\n+\tbreak;\n     }\n \n   /* Second stage of the prologue scanning.\n@@ -786,7 +786,7 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n   /* Third stage of the prologue scanning.  (Really two stages).\n      Scan for:\n      sbiw r28,XX or subi r28,lo8(XX)\n-                    sbci r29,hi8(XX)\n+\t\t    sbci r29,hi8(XX)\n      in __tmp_reg__,__SREG__\n      cli\n      out __SP_H__,r29\n@@ -816,10 +816,10 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \n       insn = extract_unsigned_integer (&prologue[vpc], 2, byte_order);\n       if ((insn & 0xff30) == 0x9720)\t/* sbiw r28,XXX */\n-        {\n-          locals_size = (insn & 0xf) | ((insn & 0xc0) >> 2);\n-          vpc += 2;\n-        }\n+\t{\n+\t  locals_size = (insn & 0xf) | ((insn & 0xc0) >> 2);\n+\t  vpc += 2;\n+\t}\n       else if ((insn & 0xf0f0) == 0x50c0)\t/* subi r28,lo8(XX) */\n \t{\n \t  locals_size = (insn & 0xf) | ((insn & 0xf00) >> 4);\n@@ -829,28 +829,28 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n \t  locals_size += ((insn & 0xf) | ((insn & 0xf00) >> 4)) << 8;\n \t}\n       else\n-        return pc_beg + vpc;\n+\treturn pc_beg + vpc;\n \n       /* Scan the last part of the prologue.  May not be present for interrupt\n-         or signal handler functions, which is why we set the prologue type\n-         when we saw the beginning of the prologue previously.  */\n+\t or signal handler functions, which is why we set the prologue type\n+\t when we saw the beginning of the prologue previously.  */\n \n       if (vpc + sizeof (img_sig) < len\n \t  && memcmp (prologue + vpc, img_sig, sizeof (img_sig)) == 0)\n-        {\n-          vpc += sizeof (img_sig);\n-        }\n+\t{\n+\t  vpc += sizeof (img_sig);\n+\t}\n       else if (vpc + sizeof (img_int) < len \n \t       && memcmp (prologue + vpc, img_int, sizeof (img_int)) == 0)\n-        {\n-          vpc += sizeof (img_int);\n-        }\n+\t{\n+\t  vpc += sizeof (img_int);\n+\t}\n       if (vpc + sizeof (img) < len\n \t  && memcmp (prologue + vpc, img, sizeof (img)) == 0)\n-        {\n-          info->prologue_type = AVR_PROLOGUE_NORMAL;\n-          vpc += sizeof (img);\n-        }\n+\t{\n+\t  info->prologue_type = AVR_PROLOGUE_NORMAL;\n+\t  vpc += sizeof (img);\n+\t}\n \n       info->size += locals_size;\n \n@@ -864,11 +864,11 @@ avr_scan_prologue (struct gdbarch *gdbarch, CORE_ADDR pc_beg, CORE_ADDR pc_end,\n     {\n       insn = extract_unsigned_integer (&prologue[vpc], 2, byte_order);\n       if ((insn & 0xff00) == 0x0100)\t/* movw rXX, rYY */\n-        continue;\n+\tcontinue;\n       else if ((insn & 0xfc00) == 0x2c00) /* mov rXX, rYY */\n-        continue;\n+\tcontinue;\n       else\n-          break;\n+\t  break;\n     }\n     \n   return pc_beg + vpc;\n@@ -977,7 +977,7 @@ avr_return_value (struct gdbarch *gdbarch, struct value *function,\n \n static struct avr_unwind_cache *\n avr_frame_unwind_cache (struct frame_info *this_frame,\n-                        void **this_prologue_cache)\n+\t\t\tvoid **this_prologue_cache)\n {\n   CORE_ADDR start_pc, current_pc;\n   ULONGEST prev_sp;\n@@ -1009,20 +1009,20 @@ avr_frame_unwind_cache (struct frame_info *this_frame,\n       ULONGEST high_base;       /* High byte of FP */\n \n       /* The SP was moved to the FP.  This indicates that a new frame\n-         was created.  Get THIS frame's FP value by unwinding it from\n-         the next frame.  */\n+\t was created.  Get THIS frame's FP value by unwinding it from\n+\t the next frame.  */\n       this_base = get_frame_register_unsigned (this_frame, AVR_FP_REGNUM);\n       high_base = get_frame_register_unsigned (this_frame, AVR_FP_REGNUM + 1);\n       this_base += (high_base << 8);\n       \n       /* The FP points at the last saved register.  Adjust the FP back\n-         to before the first saved register giving the SP.  */\n+\t to before the first saved register giving the SP.  */\n       prev_sp = this_base + info->size; \n    }\n   else\n     {\n       /* Assume that the FP is this frame's SP but with that pushed\n-         stack space added back.  */\n+\t stack space added back.  */\n       this_base = get_frame_register_unsigned (this_frame, AVR_SP_REGNUM);\n       prev_sp = this_base + info->size;\n     }\n@@ -1050,7 +1050,7 @@ avr_frame_unwind_cache (struct frame_info *this_frame,\n      value.  */\n   tdep = gdbarch_tdep (gdbarch);\n   trad_frame_set_value (info->saved_regs, AVR_SP_REGNUM,\n-                        info->prev_sp - 1 + tdep->call_length);\n+\t\t\tinfo->prev_sp - 1 + tdep->call_length);\n \n   return info;\n }\n@@ -1080,8 +1080,8 @@ avr_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)\n \n static void\n avr_frame_this_id (struct frame_info *this_frame,\n-                   void **this_prologue_cache,\n-                   struct frame_id *this_id)\n+\t\t   void **this_prologue_cache,\n+\t\t   struct frame_id *this_id)\n {\n   struct avr_unwind_cache *info\n     = avr_frame_unwind_cache (this_frame, this_prologue_cache);\n@@ -1113,7 +1113,7 @@ avr_frame_prev_register (struct frame_info *this_frame,\n   if (regnum == AVR_PC_REGNUM || regnum == AVR_PSEUDO_PC_REGNUM)\n     {\n       if (trad_frame_addr_p (info->saved_regs, AVR_PC_REGNUM))\n-        {\n+\t{\n \t  /* Reading the return PC from the PC register is slightly\n \t     abnormal.  register_size(AVR_PC_REGNUM) says it is 4 bytes,\n \t     but in reality, only two bytes (3 in upcoming mega256) are\n@@ -1133,18 +1133,18 @@ avr_frame_prev_register (struct frame_info *this_frame,\n \t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n \t  read_memory (info->saved_regs[AVR_PC_REGNUM].addr,\n-                       buf, tdep->call_length);\n+\t\t       buf, tdep->call_length);\n \n \t  /* Extract the PC read from memory as a big-endian.  */\n \t  pc = 0;\n \t  for (i = 0; i < tdep->call_length; i++)\n \t    pc = (pc << 8) | buf[i];\n \n-          if (regnum == AVR_PC_REGNUM)\n-            pc <<= 1;\n+\t  if (regnum == AVR_PC_REGNUM)\n+\t    pc <<= 1;\n \n \t  return frame_unwind_got_constant (this_frame, regnum, pc);\n-        }\n+\t}\n \n       return frame_unwind_got_optimized (this_frame, regnum);\n     }\n@@ -1264,8 +1264,8 @@ pop_stack_item (struct stack_item *si)\n \n static CORE_ADDR\n avr_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n-                     struct regcache *regcache, CORE_ADDR bp_addr,\n-                     int nargs, struct value **args, CORE_ADDR sp,\n+\t\t     struct regcache *regcache, CORE_ADDR bp_addr,\n+\t\t     int nargs, struct value **args, CORE_ADDR sp,\n \t\t     function_call_return_method return_method,\n \t\t     CORE_ADDR struct_addr)\n {\n@@ -1279,13 +1279,13 @@ avr_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   if (return_method == return_method_struct)\n     {\n       regcache_cooked_write_unsigned\n-        (regcache, regnum--, (struct_addr >> 8) & 0xff);\n+\t(regcache, regnum--, (struct_addr >> 8) & 0xff);\n       regcache_cooked_write_unsigned\n-        (regcache, regnum--, struct_addr & 0xff);\n+\t(regcache, regnum--, struct_addr & 0xff);\n       /* SP being post decremented, we need to reserve one byte so that the\n-         return address won't overwrite the result (or vice-versa).  */\n+\t return address won't overwrite the result (or vice-versa).  */\n       if (sp == struct_addr)\n-        sp--;\n+\tsp--;\n     }\n \n   for (i = 0; i < nargs; i++)\n@@ -1298,30 +1298,30 @@ avr_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       int len = TYPE_LENGTH (type);\n \n       /* Calculate the potential last register needed.\n-         E.g. For length 2, registers regnum and regnum-1 (say 25 and 24)\n-         shall be used. So, last needed register will be regnum-1(24).  */\n+\t E.g. For length 2, registers regnum and regnum-1 (say 25 and 24)\n+\t shall be used. So, last needed register will be regnum-1(24).  */\n       last_regnum = regnum - (len + (len & 1)) + 1;\n \n       /* If there are registers available, use them.  Once we start putting\n-         stuff on the stack, all subsequent args go on stack.  */\n+\t stuff on the stack, all subsequent args go on stack.  */\n       if ((si == NULL) && (last_regnum >= AVR_LAST_ARG_REGNUM))\n-        {\n-          /* Skip a register for odd length args.  */\n-          if (len & 1)\n-            regnum--;\n-\n-          /* Write MSB of argument into register and subsequent bytes in\n-             decreasing register numbers.  */\n-          for (j = 0; j < len; j++)\n-            regcache_cooked_write_unsigned\n-              (regcache, regnum--, contents[len - j - 1]);\n-        }\n+\t{\n+\t  /* Skip a register for odd length args.  */\n+\t  if (len & 1)\n+\t    regnum--;\n+\n+\t  /* Write MSB of argument into register and subsequent bytes in\n+\t     decreasing register numbers.  */\n+\t  for (j = 0; j < len; j++)\n+\t    regcache_cooked_write_unsigned\n+\t      (regcache, regnum--, contents[len - j - 1]);\n+\t}\n       /* No registers available, push the args onto the stack.  */\n       else\n-        {\n-          /* From here on, we don't care about regnum.  */\n-          si = push_stack_item (si, contents, len);\n-        }\n+\t{\n+\t  /* From here on, we don't care about regnum.  */\n+\t  si = push_stack_item (si, contents, len);\n+\t}\n     }\n \n   /* Push args onto the stack.  */\n@@ -1591,18 +1591,18 @@ avr_io_reg_read_command (const char *args, int from_tty)\n       /* how many registers this round? */\n       int j = step;\n       if ((i+j) >= nreg)\n-        j = nreg - i;           /* last block is less than 8 registers */\n+\tj = nreg - i;           /* last block is less than 8 registers */\n \n       snprintf (query, sizeof (query) - 1, \"avr.io_reg:%x,%x\", i, j);\n       buf = target_read_alloc (current_top_target (), TARGET_OBJECT_AVR, query);\n \n       if (!buf)\n-        {\n-          fprintf_unfiltered (gdb_stderr,\n+\t{\n+\t  fprintf_unfiltered (gdb_stderr,\n \t\t\t      _(\"ERR: error reading avr.io_reg:%x,%x\\n\"),\n \t\t\t      i, j);\n-          return;\n-        }\n+\t  return;\n+\t}\n \n       const char *p = (const char *) buf->data ();\n       for (int k = i; k < (i + j); k++)"
    },
    {
      "sha": "01c421245390bce10578785fa3710c45c2a48f9b",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -327,8 +327,8 @@ gen_trace_static_fields (struct agent_expr *ax,\n \t    {\n \t    case axs_lvalue_memory:\n \t      {\n-\t        /* Initialize the TYPE_LENGTH if it is a typedef.  */\n-\t        check_typedef (value.type);\n+\t\t/* Initialize the TYPE_LENGTH if it is a typedef.  */\n+\t\tcheck_typedef (value.type);\n \t\tax_const_l (ax, TYPE_LENGTH (value.type));\n \t\tax_simple (ax, aop_trace);\n \t      }\n@@ -396,10 +396,10 @@ gen_traced_pop (struct agent_expr *ax, struct axs_value *value)\n \t  else\n \t    {\n \t      /* There's no point in trying to use a trace_quick bytecode\n-\t         here, since \"trace_quick SIZE pop\" is three bytes, whereas\n-\t         \"const8 SIZE trace\" is also three bytes, does the same\n-\t         thing, and the simplest code which generates that will also\n-\t         work correctly for objects with large sizes.  */\n+\t\t here, since \"trace_quick SIZE pop\" is three bytes, whereas\n+\t\t \"const8 SIZE trace\" is also three bytes, does the same\n+\t\t thing, and the simplest code which generates that will also\n+\t\t work correctly for objects with large sizes.  */\n \t      ax_const_l (ax, TYPE_LENGTH (value->type));\n \t      ax_simple (ax, aop_trace);\n \t    }\n@@ -487,7 +487,7 @@ gen_fetch (struct agent_expr *ax, struct type *type)\n     case TYPE_CODE_CHAR:\n     case TYPE_CODE_BOOL:\n       /* It's a scalar value, so we know how to dereference it.  How\n-         many bytes long is it?  */\n+\t many bytes long is it?  */\n       switch (TYPE_LENGTH (type))\n \t{\n \tcase 8 / TARGET_CHAR_BIT:\n@@ -685,16 +685,16 @@ gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n \n     case LOC_REGISTER:\n       /* Don't generate any code at all; in the process of treating\n-         this as an lvalue or rvalue, the caller will generate the\n-         right code.  */\n+\t this as an lvalue or rvalue, the caller will generate the\n+\t right code.  */\n       value->kind = axs_lvalue_register;\n       value->u.reg\n \t= SYMBOL_REGISTER_OPS (var)->register_number (var, ax->gdbarch);\n       break;\n \n       /* A lot like LOC_REF_ARG, but the pointer lives directly in a\n-         register, not on the stack.  Simpler than LOC_REGISTER\n-         because it's just like any other case where the thing\n+\t register, not on the stack.  Simpler than LOC_REGISTER\n+\t because it's just like any other case where the thing\n \t has a real address.  */\n     case LOC_REGPARM_ADDR:\n       ax_reg (ax,\n@@ -794,10 +794,10 @@ require_rvalue (struct agent_expr *ax, struct axs_value *value)\n \n     case axs_lvalue_register:\n       /* There's nothing on the stack, but value->u.reg is the\n-         register number containing the value.\n+\t register number containing the value.\n \n-         When we add floating-point support, this is going to have to\n-         change.  What about SPARC register pairs, for example?  */\n+\t When we add floating-point support, this is going to have to\n+\t change.  What about SPARC register pairs, for example?  */\n       ax_reg (ax, value->u.reg);\n       gen_extend (ax, value->type);\n       break;\n@@ -840,7 +840,7 @@ gen_usual_unary (struct agent_expr *ax, struct axs_value *value)\n       break;\n \n       /* Arrays get converted to a pointer to their first element, and\n-         are no longer an lvalue.  */\n+\t are no longer an lvalue.  */\n     case TYPE_CODE_ARRAY:\n       {\n \tstruct type *elements = TYPE_TARGET_TYPE (value->type);\n@@ -853,7 +853,7 @@ gen_usual_unary (struct agent_expr *ax, struct axs_value *value)\n       break;\n \n       /* Don't try to convert structures and unions to rvalues.  Let the\n-         consumer signal an error.  */\n+\t consumer signal an error.  */\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n       return;\n@@ -947,19 +947,19 @@ gen_usual_arithmetic (struct agent_expr *ax, struct axs_value *value1,\n       && value2->type->code () == TYPE_CODE_INT)\n     {\n       /* The ANSI integral promotions seem to work this way: Order the\n-         integer types by size, and then by signedness: an n-bit\n-         unsigned type is considered \"wider\" than an n-bit signed\n-         type.  Promote to the \"wider\" of the two types, and always\n-         promote at least to int.  */\n+\t integer types by size, and then by signedness: an n-bit\n+\t unsigned type is considered \"wider\" than an n-bit signed\n+\t type.  Promote to the \"wider\" of the two types, and always\n+\t promote at least to int.  */\n       struct type *target = max_type (builtin_type (ax->gdbarch)->builtin_int,\n \t\t\t\t      max_type (value1->type, value2->type));\n \n       /* Deal with value2, on the top of the stack.  */\n       gen_conversion (ax, value2->type, target);\n \n       /* Deal with value1, not on the top of the stack.  Don't\n-         generate the `swap' instructions if we're not actually going\n-         to do anything.  */\n+\t generate the `swap' instructions if we're not actually going\n+\t to do anything.  */\n       if (is_nontrivial_conversion (value1->type, target))\n \t{\n \t  ax_simple (ax, aop_swap);\n@@ -1009,7 +1009,7 @@ gen_cast (struct agent_expr *ax, struct axs_value *value, struct type *type)\n     case TYPE_CODE_REF:\n     case TYPE_CODE_RVALUE_REF:\n       /* It's implementation-defined, and I'll bet this is what GCC\n-         does.  */\n+\t does.  */\n       break;\n \n     case TYPE_CODE_ARRAY:\n@@ -1021,10 +1021,10 @@ gen_cast (struct agent_expr *ax, struct axs_value *value, struct type *type)\n     case TYPE_CODE_ENUM:\n     case TYPE_CODE_BOOL:\n       /* We don't have to worry about the size of the value, because\n-         all our integral values are fully sign-extended, and when\n-         casting pointers we can do anything we like.  Is there any\n-         way for us to know what GCC actually does with a cast like\n-         this?  */\n+\t all our integral values are fully sign-extended, and when\n+\t casting pointers we can do anything we like.  Is there any\n+\t way for us to know what GCC actually does with a cast like\n+\t this?  */\n       break;\n \n     case TYPE_CODE_INT:\n@@ -1033,9 +1033,9 @@ gen_cast (struct agent_expr *ax, struct axs_value *value, struct type *type)\n \n     case TYPE_CODE_VOID:\n       /* We could pop the value, and rely on everyone else to check\n-         the type and notice that this value doesn't occupy a stack\n-         slot.  But for now, leave the value on the stack, and\n-         preserve the \"value == stack element\" assumption.  */\n+\t the type and notice that this value doesn't occupy a stack\n+\t slot.  But for now, leave the value on the stack, and\n+\t preserve the \"value == stack element\" assumption.  */\n       break;\n \n     default:\n@@ -1321,7 +1321,7 @@ gen_bitfield_ref (struct agent_expr *ax, struct axs_value *value,\n       int op_size = 8 << op;\n \n       /* The stack at this point, from bottom to top, contains zero or\n-         more fragments, then the address.  */\n+\t more fragments, then the address.  */\n \n       /* Does this fetch fit within the bitfield?  */\n       if (offset + op_size <= bound_end)\n@@ -1725,7 +1725,7 @@ gen_repeat (struct expression *exp, union exp_element **pc,\n        all we need to do is frob the type of the lvalue.  */\n     {\n       /* FIXME-type-allocation: need a way to free this type when we are\n-         done with it.  */\n+\t done with it.  */\n       struct type *array\n \t= lookup_array_range_type (value1.type, 0, length - 1);\n \n@@ -1976,17 +1976,17 @@ gen_expr (struct expression *exp, union exp_element **pc,\n       break;\n \n       /* Note that we need to be a little subtle about generating code\n-         for comma.  In C, we can do some optimizations here because\n-         we know the left operand is only being evaluated for effect.\n-         However, if the tracing kludge is in effect, then we always\n-         need to evaluate the left hand side fully, so that all the\n-         variables it mentions get traced.  */\n+\t for comma.  In C, we can do some optimizations here because\n+\t we know the left operand is only being evaluated for effect.\n+\t However, if the tracing kludge is in effect, then we always\n+\t need to evaluate the left hand side fully, so that all the\n+\t variables it mentions get traced.  */\n     case BINOP_COMMA:\n       (*pc)++;\n       gen_expr (exp, pc, ax, &value1);\n       /* Don't just dispose of the left operand.  We might be tracing,\n-         in which case we want to emit code to trace it if it's an\n-         lvalue.  */\n+\t in which case we want to emit code to trace it if it's an\n+\t lvalue.  */\n       gen_traced_pop (ax, &value1);\n       gen_expr (exp, pc, ax, value);\n       /* It's the consumer's responsibility to trace the right operand.  */\n@@ -2194,8 +2194,8 @@ gen_expr (struct expression *exp, union exp_element **pc,\n     case UNOP_SIZEOF:\n       (*pc)++;\n       /* Notice that gen_sizeof handles its own operand, unlike most\n-         of the other unary operator functions.  This is because we\n-         have to throw away the code we generate.  */\n+\t of the other unary operator functions.  This is because we\n+\t have to throw away the code we generate.  */\n       gen_sizeof (exp, pc, ax, value,\n \t\t  builtin_type (ax->gdbarch)->builtin_int);\n       break;\n@@ -2583,7 +2583,7 @@ agent_eval_command_one (const char *exp, int eval, CORE_ADDR pc)\n   if (!eval)\n     {\n       if (*exp == '/')\n-        exp = decode_agent_options (exp, &trace_string);\n+\texp = decode_agent_options (exp, &trace_string);\n     }\n \n   agent_expr_up agent;\n@@ -2640,7 +2640,7 @@ agent_command_1 (const char *exp, int eval)\n \t\t\tNULL, NULL);\n       exp = skip_spaces (exp);\n       if (exp[0] == ',')\n-        {\n+\t{\n \t  exp++;\n \t  exp = skip_spaces (exp);\n \t}"
    },
    {
      "sha": "e3a766c53d6b3aa97c60b7d1103390922b9ca5d6",
      "filename": "gdb/ax-general.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ax-general.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ax-general.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-general.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -244,7 +244,7 @@ ax_const_l (struct agent_expr *x, LONGEST l)\n       LONGEST lim = ((LONGEST) 1) << (size - 1);\n \n       if (-lim <= l && l <= lim - 1)\n-        break;\n+\tbreak;\n     }\n \n   /* Emit the right opcode...  */\n@@ -292,7 +292,7 @@ ax_reg (struct agent_expr *x, int reg)\n \n       /* Make sure the register number is in range.  */\n       if (reg < 0 || reg > 0xffff)\n-        error (_(\"GDB bug: ax-general.c (ax_reg): \"\n+\terror (_(\"GDB bug: ax-general.c (ax_reg): \"\n \t\t \"register number out of range\"));\n       grow_expr (x, 3);\n       x->buf[x->len] = aop_reg;\n@@ -446,18 +446,18 @@ ax_reg_mask (struct agent_expr *ax, int reg)\n \n       /* Grow the bit mask if necessary.  */\n       if (byte >= ax->reg_mask_len)\n-        {\n-          /* It's not appropriate to double here.  This isn't a\n+\t{\n+\t  /* It's not appropriate to double here.  This isn't a\n \t     string buffer.  */\n-          int new_len = byte + 1;\n-          unsigned char *new_reg_mask\n+\t  int new_len = byte + 1;\n+\t  unsigned char *new_reg_mask\n \t    = XRESIZEVEC (unsigned char, ax->reg_mask, new_len);\n \n-          memset (new_reg_mask + ax->reg_mask_len, 0,\n-\t          (new_len - ax->reg_mask_len) * sizeof (ax->reg_mask[0]));\n-          ax->reg_mask_len = new_len;\n-          ax->reg_mask = new_reg_mask;\n-        }\n+\t  memset (new_reg_mask + ax->reg_mask_len, 0,\n+\t\t  (new_len - ax->reg_mask_len) * sizeof (ax->reg_mask[0]));\n+\t  ax->reg_mask_len = new_len;\n+\t  ax->reg_mask = new_reg_mask;\n+\t}\n \n       ax->reg_mask[byte] |= 1 << (reg % 8);\n     }\n@@ -517,8 +517,8 @@ ax_reqs (struct agent_expr *ax)\n \t}\n \n       /* If this instruction is a forward jump target, does the\n-         current stack height match the stack height at the jump\n-         source?  */\n+\t current stack height match the stack height at the jump\n+\t source?  */\n       if (targets[i] && (heights[i] != height))\n \t{\n \t  ax->flaw = agent_flaw_height_mismatch;\n@@ -539,8 +539,8 @@ ax_reqs (struct agent_expr *ax)\n \tax->max_data_size = op->data_size;\n \n       /* For jump instructions, check that the target is a valid\n-         offset.  If it is, record the fact that that location is a\n-         jump target, and record the height we expect there.  */\n+\t offset.  If it is, record the fact that that location is a\n+\t jump target, and record the height we expect there.  */\n       if (aop_goto == op - aop_map\n \t  || aop_if_goto == op - aop_map)\n \t{\n@@ -552,7 +552,7 @@ ax_reqs (struct agent_expr *ax)\n \t    }\n \n \t  /* Do we have any information about what the stack height\n-             should be at the target?  */\n+\t     should be at the target?  */\n \t  if (targets[target] || boundary[target])\n \t    {\n \t      if (heights[target] != height)\n@@ -562,13 +562,13 @@ ax_reqs (struct agent_expr *ax)\n \t\t}\n \t    }\n \n-          /* Record the target, along with the stack height we expect.  */\n-          targets[target] = 1;\n-          heights[target] = height;\n+\t  /* Record the target, along with the stack height we expect.  */\n+\t  targets[target] = 1;\n+\t  heights[target] = height;\n \t}\n \n       /* For unconditional jumps with a successor, check that the\n-         successor is a target, and pick up its stack height.  */\n+\t successor is a target, and pick up its stack height.  */\n       if (aop_goto == op - aop_map\n \t  && i + 3 < ax->len)\n \t{"
    },
    {
      "sha": "16a0a97eaf4007d8bf3b09bbab310f1ccade2b2d",
      "filename": "gdb/bfin-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bfin-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bfin-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -158,13 +158,13 @@ bfin_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   /* Functions for 'catch syscall'.  */\n   set_xml_syscall_file_name (gdbarch, \"syscalls/bfin-linux.xml\");\n   set_gdbarch_get_syscall_number (gdbarch,\n-                                  bfin_linux_get_syscall_number);\n+\t\t\t\t  bfin_linux_get_syscall_number);\n }\n \n void _initialize_bfin_linux_tdep ();\n void\n _initialize_bfin_linux_tdep ()\n {\n   gdbarch_register_osabi (bfd_arch_bfin, 0, GDB_OSABI_LINUX,\n-                          bfin_linux_init_abi);\n+\t\t\t  bfin_linux_init_abi);\n }"
    },
    {
      "sha": "fc6bfb9c636ac64ad0eaa039d7b44b7ae7006c0e",
      "filename": "gdb/block.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -79,9 +79,9 @@ contained_in (const struct block *a, const struct block *b,\n       if (a == b)\n \treturn true;\n       /* If A is a function block, then A cannot be contained in B,\n-         except if A was inlined.  */\n+\t except if A was inlined.  */\n       if (!allow_nested && BLOCK_FUNCTION (a) != NULL && !block_inlined_p (a))\n-        return false;\n+\treturn false;\n       a = BLOCK_SUPERBLOCK (a);\n     }\n   while (a != NULL);\n@@ -879,14 +879,14 @@ block_find_non_opaque_type_preferred (struct symbol *sym, void *data)\n \n struct blockranges *\n make_blockranges (struct objfile *objfile,\n-                  const std::vector<blockrange> &rangevec)\n+\t\t  const std::vector<blockrange> &rangevec)\n {\n   struct blockranges *blr;\n   size_t n = rangevec.size();\n \n   blr = (struct blockranges *)\n     obstack_alloc (&objfile->objfile_obstack,\n-                   sizeof (struct blockranges)\n+\t\t   sizeof (struct blockranges)\n \t\t   + (n - 1) * sizeof (struct blockrange));\n \n   blr->nranges = n;"
    },
    {
      "sha": "417558c748f1c3f60d405ea1e541a3a97a48d39e",
      "filename": "gdb/block.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/block.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/block.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -392,7 +392,7 @@ extern int block_find_non_opaque_type (struct symbol *sym, void *data);\n    struct symbol *with_opaque = NULL;\n    struct symbol *sym\n      = block_find_symbol (block, name, domain,\n-                          block_find_non_opaque_type_preferred, &with_opaque);\n+\t\t\t  block_find_non_opaque_type_preferred, &with_opaque);\n \n    At this point if SYM is non-NULL then a non-opaque type has been found.\n    Otherwise, if WITH_OPAQUE is non-NULL then an opaque type has been found.\n@@ -423,6 +423,6 @@ extern int block_find_non_opaque_type_preferred (struct symbol *sym,\n /* Given a vector of pairs, allocate and build an obstack allocated\n    blockranges struct for a block.  */\n struct blockranges *make_blockranges (struct objfile *objfile,\n-                                      const std::vector<blockrange> &rangevec);\n+\t\t\t\t      const std::vector<blockrange> &rangevec);\n \n #endif /* BLOCK_H */"
    },
    {
      "sha": "143d234809da47e80bc7264d94f6de741e04fe5d",
      "filename": "gdb/blockframe.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/blockframe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/blockframe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/blockframe.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -285,7 +285,7 @@ find_pc_partial_function_sym (CORE_ADDR pc,\n \t    {\n \t      int i;\n \t      for (i = 0; i < BLOCK_NRANGES (b); i++)\n-\t        {\n+\t\t{\n \t\t  if (BLOCK_RANGE_START (b, i) <= mapped_pc\n \t\t      && mapped_pc < BLOCK_RANGE_END (b, i))\n \t\t    {\n@@ -395,24 +395,24 @@ find_function_entry_range_from_pc (CORE_ADDR pc, const char **name,\n       CORE_ADDR entry_pc = BLOCK_ENTRY_PC (block);\n \n       for (int i = 0; i < BLOCK_NRANGES (block); i++)\n-        {\n+\t{\n \t  if (BLOCK_RANGE_START (block, i) <= entry_pc\n \t      && entry_pc < BLOCK_RANGE_END (block, i))\n \t    {\n \t      if (address != nullptr)\n-\t        *address = BLOCK_RANGE_START (block, i);\n+\t\t*address = BLOCK_RANGE_START (block, i);\n \n \t      if (endaddr != nullptr)\n-\t        *endaddr = BLOCK_RANGE_END (block, i);\n+\t\t*endaddr = BLOCK_RANGE_END (block, i);\n \n \t      return status;\n \t    }\n \t}\n \n       /* It's an internal error if we exit the above loop without finding\n-         the range.  */\n+\t the range.  */\n       internal_error (__FILE__, __LINE__,\n-                      _(\"Entry block not found in find_function_entry_range_from_pc\"));\n+\t\t      _(\"Entry block not found in find_function_entry_range_from_pc\"));\n     }\n \n   return status;"
    },
    {
      "sha": "22b170b7f84f40b9b149f8be233f56e70cab3b92",
      "filename": "gdb/bpf-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bpf-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bpf-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bpf-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -73,7 +73,7 @@ static unsigned int bpf_debug_flag = 0;\n \n static void\n show_bpf_debug (struct ui_file *file, int from_tty,\n-\t        struct cmd_list_element *c, const char *value)\n+\t\tstruct cmd_list_element *c, const char *value)\n {\n   fprintf_filtered (file, _(\"Debugging of BPF is %s.\\n\"), value);\n }"
    },
    {
      "sha": "fd25cc166002097af13e52f20d627c3203987ca2",
      "filename": "gdb/break-catch-sig.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-sig.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-sig.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-sig.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -228,15 +228,15 @@ signal_catchpoint_print_one (struct breakpoint *b,\n \n       bool first = true;\n       for (gdb_signal iter : c->signals_to_be_caught)\n-        {\n+\t{\n \t  const char *name = signal_to_name_or_int (iter);\n \n \t  if (!first)\n \t    text += \" \";\n \t  first = false;\n \n \t  text += name;\n-        }\n+\t}\n       uiout->field_string (\"what\", text.c_str ());\n     }\n   else\n@@ -260,16 +260,16 @@ signal_catchpoint_print_mention (struct breakpoint *b)\n   if (!c->signals_to_be_caught.empty ())\n     {\n       if (c->signals_to_be_caught.size () > 1)\n-        printf_filtered (_(\"Catchpoint %d (signals\"), b->number);\n+\tprintf_filtered (_(\"Catchpoint %d (signals\"), b->number);\n       else\n-        printf_filtered (_(\"Catchpoint %d (signal\"), b->number);\n+\tprintf_filtered (_(\"Catchpoint %d (signal\"), b->number);\n \n       for (gdb_signal iter : c->signals_to_be_caught)\n-        {\n+\t{\n \t  const char *name = signal_to_name_or_int (iter);\n \n \t  printf_filtered (\" %s\", name);\n-        }\n+\t}\n       printf_filtered (\")\");\n     }\n   else if (c->catch_all)"
    },
    {
      "sha": "d1ec07ad5a6029d06cada0ede0663f8a518d67a2",
      "filename": "gdb/break-catch-syscall.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-syscall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-syscall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-syscall.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -126,8 +126,8 @@ remove_catch_syscall (struct bp_location *bl, enum remove_bp_reason reason)\n \t  if (iter >= inf_data->syscalls_counts.size ())\n \t    /* Shouldn't happen.  */\n \t    continue;\n-          --inf_data->syscalls_counts[iter];\n-        }\n+\t  --inf_data->syscalls_counts[iter];\n+\t}\n     }\n \n   return target_set_syscall_catchpoint (inferior_ptid.pid (),\n@@ -252,20 +252,20 @@ print_one_catch_syscall (struct breakpoint *b,\n       char *text = xstrprintf (\"%s\", \"\");\n \n       for (int iter : c->syscalls_to_be_caught)\n-        {\n-          char *previous_text = text;\n-          struct syscall s;\n-          get_syscall_by_number (gdbarch, iter, &s);\n+\t{\n+\t  char *previous_text = text;\n+\t  struct syscall s;\n+\t  get_syscall_by_number (gdbarch, iter, &s);\n \n-          if (s.name != NULL)\n-            text = xstrprintf (\"%s%s, \", text, s.name);\n-          else\n-            text = xstrprintf (\"%s%d, \", text, iter);\n+\t  if (s.name != NULL)\n+\t    text = xstrprintf (\"%s%s, \", text, s.name);\n+\t  else\n+\t    text = xstrprintf (\"%s%d, \", text, iter);\n \n-          /* We have to xfree previous_text because xstrprintf dynamically\n+\t  /* We have to xfree previous_text because xstrprintf dynamically\n \t     allocates new space for text on every call.  */\n \t  xfree (previous_text);\n-        }\n+\t}\n       /* Remove the last comma.  */\n       text[strlen (text) - 2] = '\\0';\n       uiout->field_string (\"what\", text);\n@@ -292,25 +292,25 @@ print_mention_catch_syscall (struct breakpoint *b)\n   if (!c->syscalls_to_be_caught.empty ())\n     {\n       if (c->syscalls_to_be_caught.size () > 1)\n-        printf_filtered (_(\"Catchpoint %d (syscalls\"), b->number);\n+\tprintf_filtered (_(\"Catchpoint %d (syscalls\"), b->number);\n       else\n-        printf_filtered (_(\"Catchpoint %d (syscall\"), b->number);\n+\tprintf_filtered (_(\"Catchpoint %d (syscall\"), b->number);\n \n       for (int iter : c->syscalls_to_be_caught)\n-        {\n-          struct syscall s;\n-          get_syscall_by_number (gdbarch, iter, &s);\n-\n-          if (s.name != NULL)\n-            printf_filtered (\" '%s' [%d]\", s.name, s.number);\n-          else\n-            printf_filtered (\" %d\", s.number);\n-        }\n+\t{\n+\t  struct syscall s;\n+\t  get_syscall_by_number (gdbarch, iter, &s);\n+\n+\t  if (s.name != NULL)\n+\t    printf_filtered (\" '%s' [%d]\", s.name, s.number);\n+\t  else\n+\t    printf_filtered (\" %d\", s.number);\n+\t}\n       printf_filtered (\")\");\n     }\n   else\n     printf_filtered (_(\"Catchpoint %d (any syscall)\"),\n-                     b->number);\n+\t\t     b->number);\n }\n \n /* Implement the \"print_recreate\" breakpoint_ops method for syscall\n@@ -352,7 +352,7 @@ syscall_catchpoint_p (struct breakpoint *b)\n \n static void\n create_syscall_event_catchpoint (int tempflag, std::vector<int> &&filter,\n-                                 const struct breakpoint_ops *ops)\n+\t\t\t\t const struct breakpoint_ops *ops)\n {\n   struct gdbarch *gdbarch = get_current_arch ();\n \n@@ -524,7 +524,7 @@ catching_syscall_number (int syscall_number)\n static void\n catch_syscall_completer (struct cmd_list_element *cmd,\n \t\t\t completion_tracker &tracker,\n-                         const char *text, const char *word)\n+\t\t\t const char *text, const char *word)\n {\n   struct gdbarch *gdbarch = get_current_arch ();\n   gdb::unique_xmalloc_ptr<const char *> group_list;"
    },
    {
      "sha": "3736a3d17621ca36869d6260857b295eed0d2803",
      "filename": "gdb/break-catch-throw.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-throw.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/break-catch-throw.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-throw.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -544,19 +544,19 @@ _initialize_break_catch_throw ()\n   add_catch_command (\"catch\", _(\"\\\n Catch an exception, when caught.\"),\n \t\t     catch_catch_command,\n-                     NULL,\n+\t\t     NULL,\n \t\t     CATCH_PERMANENT,\n \t\t     CATCH_TEMPORARY);\n   add_catch_command (\"throw\", _(\"\\\n Catch an exception, when thrown.\"),\n \t\t     catch_throw_command,\n-                     NULL,\n+\t\t     NULL,\n \t\t     CATCH_PERMANENT,\n \t\t     CATCH_TEMPORARY);\n   add_catch_command (\"rethrow\", _(\"\\\n Catch an exception, when rethrown.\"),\n \t\t     catch_rethrow_command,\n-                     NULL,\n+\t\t     NULL,\n \t\t     CATCH_PERMANENT,\n \t\t     CATCH_TEMPORARY);\n "
    },
    {
      "sha": "23278320d9d465943bf94ec2c35a5a1438c45f2a",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 106,
      "deletions": 106,
      "changes": 212,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -135,7 +135,7 @@ static void breakpoint_adjustment_warning (CORE_ADDR, CORE_ADDR, int, int);\n \n static CORE_ADDR adjust_breakpoint_address (struct gdbarch *gdbarch,\n \t\t\t\t\t    CORE_ADDR bpaddr,\n-                                            enum bptype bptype);\n+\t\t\t\t\t    enum bptype bptype);\n \n static void describe_other_breakpoints (struct gdbarch *,\n \t\t\t\t\tstruct program_space *, CORE_ADDR,\n@@ -958,10 +958,10 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \t    }\n \n \t  /* If we reach here, the condition is valid at some locations.  */\n-          int loc_num = 1;\n-          for (bp_location *loc = b->loc; loc != nullptr;\n-               loc = loc->next, loc_num++)\n-            set_breakpoint_location_condition (exp, loc, b->number, loc_num);\n+\t  int loc_num = 1;\n+\t  for (bp_location *loc = b->loc; loc != nullptr;\n+\t       loc = loc->next, loc_num++)\n+\t    set_breakpoint_location_condition (exp, loc, b->number, loc_num);\n \t}\n \n       /* We know that the new condition parsed successfully.  The\n@@ -1204,8 +1204,8 @@ validate_commands_for_breakpoint (struct breakpoint *b,\n       struct command_line *while_stepping = 0;\n \n       /* Reset the while-stepping step count.  The previous commands\n-         might have included a while-stepping action, while the new\n-         ones might not.  */\n+\t might have included a while-stepping action, while the new\n+\t ones might not.  */\n       t->step_count = 0;\n \n       /* We need to verify that each top-level element of commands is\n@@ -1835,10 +1835,10 @@ update_watchpoint (struct watchpoint *b, int reparse)\n \treturn;\n \n       /* Save the current frame's ID so we can restore it after\n-         evaluating the watchpoint expression on its own frame.  */\n+\t evaluating the watchpoint expression on its own frame.  */\n       /* FIXME drow/2003-09-09: It would be nice if evaluate_expression\n-         took a frame parameter, so that we didn't have to change the\n-         selected frame.  */\n+\t took a frame parameter, so that we didn't have to change the\n+\t selected frame.  */\n       frame_saved = 1;\n       saved_frame_id = get_frame_id (get_selected_frame (NULL));\n \n@@ -2691,17 +2691,17 @@ insert_bp_location (struct bp_location *bl,\n \t    {\n \t      /* Yes.  This overlay section is mapped into memory.  */\n \t      try\n-\t        {\n+\t\t{\n \t\t  int val;\n \n-\t          val = bl->owner->ops->insert_location (bl);\n+\t\t  val = bl->owner->ops->insert_location (bl);\n \t\t  if (val)\n \t\t    bp_excpt = gdb_exception {RETURN_ERROR, GENERIC_ERROR};\n-\t        }\n+\t\t}\n \t      catch (gdb_exception &e)\n-\t        {\n+\t\t{\n \t\t  bp_excpt = std::move (e);\n-\t        }\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -2754,12 +2754,12 @@ insert_bp_location (struct bp_location *bl,\n \t\t{\n \t\t  *hw_breakpoint_error = 1;\n \t\t  *hw_bp_error_explained_already = bp_excpt.message != NULL;\n-                  fprintf_unfiltered (tmp_error_stream,\n-                                      \"Cannot insert hardware breakpoint %d%s\",\n-                                      bl->owner->number,\n+\t\t  fprintf_unfiltered (tmp_error_stream,\n+\t\t\t\t      \"Cannot insert hardware breakpoint %d%s\",\n+\t\t\t\t      bl->owner->number,\n \t\t\t\t      bp_excpt.message ? \":\" : \".\\n\");\n-                  if (bp_excpt.message != NULL)\n-                    fprintf_unfiltered (tmp_error_stream, \"%s.\\n\",\n+\t\t  if (bp_excpt.message != NULL)\n+\t\t    fprintf_unfiltered (tmp_error_stream, \"%s.\\n\",\n \t\t\t\t\tbp_excpt.what ());\n \t\t}\n \t      else\n@@ -3101,7 +3101,7 @@ insert_breakpoint_locations (void)\n   if (error_flag)\n     {\n       /* If a hardware breakpoint or watchpoint was inserted, add a\n-         message about possibly exhausted resources.  */\n+\t message about possibly exhausted resources.  */\n       if (hw_breakpoint_error && !hw_bp_error_explained_already)\n \t{\n \t  tmp_error_stream.printf (\"Could not insert hardware breakpoints:\\n\\\n@@ -3310,21 +3310,21 @@ create_overlay_event_breakpoint (void)\n \n       addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->overlay_msym);\n       b = create_internal_breakpoint (objfile->arch (), addr,\n-                                      bp_overlay_event,\n+\t\t\t\t      bp_overlay_event,\n \t\t\t\t      &internal_breakpoint_ops);\n       initialize_explicit_location (&explicit_loc);\n       explicit_loc.function_name = ASTRDUP (func_name);\n       b->location = new_explicit_location (&explicit_loc);\n \n       if (overlay_debugging == ovly_auto)\n-        {\n-          b->enable_state = bp_enabled;\n-          overlay_events_enabled = 1;\n-        }\n+\t{\n+\t  b->enable_state = bp_enabled;\n+\t  overlay_events_enabled = 1;\n+\t}\n       else\n        {\n-         b->enable_state = bp_disabled;\n-         overlay_events_enabled = 0;\n+\t b->enable_state = bp_disabled;\n+\t overlay_events_enabled = 0;\n        }\n     }\n }\n@@ -3649,11 +3649,11 @@ update_breakpoints_after_exec (void)\n \n     if (b->type == bp_catchpoint)\n       {\n-        /* For now, none of the bp_catchpoint breakpoints need to\n-           do anything at this point.  In the future, if some of\n-           the catchpoints need to something, we will need to add\n-           a new method, and call this method from here.  */\n-        continue;\n+\t/* For now, none of the bp_catchpoint breakpoints need to\n+\t   do anything at this point.  In the future, if some of\n+\t   the catchpoints need to something, we will need to add\n+\t   a new method, and call this method from here.  */\n+\tcontinue;\n       }\n \n     /* bp_finish is a special case.  The only way we ought to be able\n@@ -3868,8 +3868,8 @@ remove_breakpoint_1 (struct bp_location *bl, enum remove_bp_reason reason)\n \t\t bl->owner->number);\n     }\n   else if (bl->owner->type == bp_catchpoint\n-           && breakpoint_enabled (bl->owner)\n-           && !bl->duplicate)\n+\t   && breakpoint_enabled (bl->owner)\n+\t   && !bl->duplicate)\n     {\n       gdb_assert (bl->owner->ops != NULL\n \t\t  && bl->owner->ops->remove_location != NULL);\n@@ -4467,14 +4467,14 @@ bpstat_do_actions_1 (bpstat *bsp)\n \n       /* Take ownership of the BSP's command tree, if it has one.\n \n-         The command tree could legitimately contain commands like\n-         'step' and 'next', which call clear_proceed_status, which\n-         frees stop_bpstat's command tree.  To make sure this doesn't\n-         free the tree we're executing out from under us, we need to\n-         take ownership of the tree ourselves.  Since a given bpstat's\n-         commands are only executed once, we don't need to copy it; we\n-         can clear the pointer in the bpstat, and make sure we free\n-         the tree when we're done.  */\n+\t The command tree could legitimately contain commands like\n+\t 'step' and 'next', which call clear_proceed_status, which\n+\t frees stop_bpstat's command tree.  To make sure this doesn't\n+\t free the tree we're executing out from under us, we need to\n+\t take ownership of the tree ourselves.  Since a given bpstat's\n+\t commands are only executed once, we don't need to copy it; we\n+\t can clear the pointer in the bpstat, and make sure we free\n+\t the tree when we're done.  */\n       counted_command_line ccmd = bs->commands;\n       bs->commands = NULL;\n       if (ccmd != NULL)\n@@ -4622,7 +4622,7 @@ print_bp_stop_message (bpstat bs)\n \n     case print_it_done:\n       /* We still want to print the frame, but we already printed the\n-         relevant messages.  */\n+\t relevant messages.  */\n       return PRINT_SRC_AND_LOC;\n       break;\n \n@@ -4954,9 +4954,9 @@ watchpoint_check (bpstat bs)\n   if (within_current_scope)\n     {\n       /* We use value_{,free_to_}mark because it could be a *long*\n-         time before we return to the command level and call\n-         free_all_values.  We can't call free_all_values because we\n-         might be in the middle of evaluating a function call.  */\n+\t time before we return to the command level and call\n+\t free_all_values.  We can't call free_all_values because we\n+\t might be in the middle of evaluating a function call.  */\n \n       int pc = 0;\n       struct value *mark;\n@@ -4999,21 +4999,21 @@ watchpoint_check (bpstat bs)\n   else\n     {\n       /* This seems like the only logical thing to do because\n-         if we temporarily ignored the watchpoint, then when\n-         we reenter the block in which it is valid it contains\n-         garbage (in the case of a function, it may have two\n-         garbage values, one before and one after the prologue).\n-         So we can't even detect the first assignment to it and\n-         watch after that (since the garbage may or may not equal\n-         the first value assigned).  */\n+\t if we temporarily ignored the watchpoint, then when\n+\t we reenter the block in which it is valid it contains\n+\t garbage (in the case of a function, it may have two\n+\t garbage values, one before and one after the prologue).\n+\t So we can't even detect the first assignment to it and\n+\t watch after that (since the garbage may or may not equal\n+\t the first value assigned).  */\n       /* We print all the stop information in\n \t breakpoint_ops->print_it, but in this case, by the time we\n \t call breakpoint_ops->print_it this bp will be deleted\n \t already.  So we have no choice but print the information\n \t here.  */\n \n       SWITCH_THRU_ALL_UIS ()\n-        {\n+\t{\n \t  struct ui_out *uiout = current_uiout;\n \n \t  if (uiout->is_mi_like_p ())\n@@ -6195,7 +6195,7 @@ print_one_breakpoint_location (struct breakpoint *b,\n \t    inf_nums.push_back (inf->num);\n \t}\n \n-        /* For backward compatibility, don't display inferiors in CLI unless\n+\t/* For backward compatibility, don't display inferiors in CLI unless\n \t   there are several.  Always display for MI. */\n \tif (allflag\n \t    || (!gdbarch_has_global_breakpoints (target_gdbarch ())\n@@ -6234,7 +6234,7 @@ print_one_breakpoint_location (struct breakpoint *b,\n       annotate_field (6);\n       uiout->text (\"\\tstop only in stack frame at \");\n       /* FIXME: cagney/2002-12-01: Shouldn't be poking around inside\n-         the frame ID.  */\n+\t the frame ID.  */\n       uiout->field_core_addr (\"frame\",\n \t\t\t      b->gdbarch, b->frame_id.stack_addr);\n       uiout->text (\"\\n\");\n@@ -6758,7 +6758,7 @@ describe_other_breakpoints (struct gdbarch *gdbarch,\n \n   ALL_BREAKPOINTS (b)\n     others += (user_breakpoint_p (b)\n-               && breakpoint_has_pc (b, pspace, pc, section));\n+\t       && breakpoint_has_pc (b, pspace, pc, section));\n   if (others > 0)\n     {\n       if (others == 1)\n@@ -6972,7 +6972,7 @@ breakpoint_locations_match (struct bp_location *loc1,\n \n static void\n breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,\n-                               int bnum, int have_bnum)\n+\t\t\t       int bnum, int have_bnum)\n {\n   /* The longest string possibly returned by hex_string_custom\n      is 50 chars.  These must be at least that big for safety.  */\n@@ -6983,7 +6983,7 @@ breakpoint_adjustment_warning (CORE_ADDR from_addr, CORE_ADDR to_addr,\n   strcpy (astr2, hex_string_custom ((unsigned long) to_addr, 8));\n   if (have_bnum)\n     warning (_(\"Breakpoint %d address previously adjusted from %s to %s.\"),\n-             bnum, astr1, astr2);\n+\t     bnum, astr1, astr2);\n   else\n     warning (_(\"Breakpoint address adjusted from %s to %s.\"), astr1, astr2);\n }\n@@ -7004,7 +7004,7 @@ adjust_breakpoint_address (struct gdbarch *gdbarch,\n       || bptype == bp_catchpoint)\n     {\n       /* Watchpoints and the various bp_catch_* eventpoints should not\n-         have their addresses modified.  */\n+\t have their addresses modified.  */\n       return bpaddr;\n     }\n   else if (bptype == bp_single_step)\n@@ -7031,7 +7031,7 @@ adjust_breakpoint_address (struct gdbarch *gdbarch,\n       adjusted_bpaddr = address_significant (gdbarch, adjusted_bpaddr);\n \n       /* An adjusted breakpoint address can significantly alter\n-         a user's expectations.  Print a warning if an adjustment\n+\t a user's expectations.  Print a warning if an adjustment\n \t is required.  */\n       if (adjusted_bpaddr != bpaddr)\n \tbreakpoint_adjustment_warning (bpaddr, adjusted_bpaddr, 0, 0);\n@@ -7229,7 +7229,7 @@ set_breakpoint_location_function (struct bp_location *loc)\n \t\t mess more complicated breakpoints with multiple locations.  */\n \t      b->type = bp_gnu_ifunc_resolver;\n \t      /* Remember the resolver's address for use by the return\n-\t         breakpoint.  */\n+\t\t breakpoint.  */\n \t      loc->related_address = loc->address;\n \t    }\n \t}\n@@ -8267,7 +8267,7 @@ install_breakpoint (int internal, std::unique_ptr<breakpoint> &&arg, int update_\n static void\n create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,\n \t\t\t\t    bool temp, const char *cond_string,\n-                                    const struct breakpoint_ops *ops)\n+\t\t\t\t    const struct breakpoint_ops *ops)\n {\n   std::unique_ptr<fork_catchpoint> c (new fork_catchpoint ());\n \n@@ -9457,7 +9457,7 @@ create_breakpoint (struct gdbarch *gdbarch,\n \n \t  exception_print (gdb_stderr, e);\n \n-          /* If pending breakpoint support is auto query and the user\n+\t  /* If pending breakpoint support is auto query and the user\n \t     selects no, then simply return the error code.  */\n \t  if (pending_break_support == AUTO_BOOLEAN_AUTO\n \t      && !nquery (_(\"Make %s pending on future shared library load? \"),\n@@ -9501,7 +9501,7 @@ create_breakpoint (struct gdbarch *gdbarch,\n       gdb::unique_xmalloc_ptr<char> extra_string_copy;\n \n       if (parse_extra)\n-        {\n+\t{\n \t  char *rest;\n \t  char *cond;\n \n@@ -9511,9 +9511,9 @@ create_breakpoint (struct gdbarch *gdbarch,\n \t\t\t\t\t      &cond, &thread, &task, &rest);\n \t  cond_string_copy.reset (cond);\n \t  extra_string_copy.reset (rest);\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  if (type_wanted != bp_dprintf\n \t      && extra_string != NULL && *extra_string != '\\0')\n \t\terror (_(\"Garbage '%s' at end of location\"), extra_string);\n@@ -9524,7 +9524,7 @@ create_breakpoint (struct gdbarch *gdbarch,\n \t  /* Create a private copy of any extra string.  */\n \t  if (extra_string)\n \t    extra_string_copy.reset (xstrdup (extra_string));\n-        }\n+\t}\n \n       ops->create_breakpoints_sal (gdbarch, &canonical,\n \t\t\t\t   std::move (cond_string_copy),\n@@ -9557,7 +9557,7 @@ create_breakpoint (struct gdbarch *gdbarch,\n       b->condition_not_parsed = 1;\n       b->enable_state = enabled ? bp_enabled : bp_disabled;\n       if ((type_wanted != bp_breakpoint\n-           && type_wanted != bp_hardware_breakpoint) || thread != -1)\n+\t   && type_wanted != bp_hardware_breakpoint) || thread != -1)\n \tb->pspace = current_program_space;\n \n       install_breakpoint (internal, std::move (b), 0);\n@@ -9622,7 +9622,7 @@ resolve_sal_pc (struct symtab_and_line *sal)\n       sal->pc = pc;\n \n       /* If this SAL corresponds to a breakpoint inserted using a line\n-         number, then skip the function prologue if necessary.  */\n+\t number, then skip the function prologue if necessary.  */\n       if (sal->explicit_line)\n \tskip_prologue_sal (sal);\n     }\n@@ -9647,9 +9647,9 @@ resolve_sal_pc (struct symtab_and_line *sal)\n \t  else\n \t    {\n \t      /* It really is worthwhile to have the section, so we'll\n-\t         just have to look harder. This case can be executed\n-\t         if we have line numbers but no functions (as can\n-\t         happen in assembly source).  */\n+\t\t just have to look harder. This case can be executed\n+\t\t if we have line numbers but no functions (as can\n+\t\t happen in assembly source).  */\n \n \t      scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \t      switch_to_program_space_and_thread (sal->pspace);\n@@ -9707,8 +9707,8 @@ stopin_command (const char *arg, int from_tty)\n       int hasColon = 0;\n \n       /* Look for a ':'.  If this is a line number specification, then\n-         say it is bad, otherwise, it should be an address or\n-         function/method name.  */\n+\t say it is bad, otherwise, it should be an address or\n+\t function/method name.  */\n       while (*argptr && !hasColon)\n \t{\n \t  hasColon = (*argptr == ':');\n@@ -9740,7 +9740,7 @@ stopat_command (const char *arg, int from_tty)\n       int hasColon = 0;\n \n       /* Look for a ':'.  If there is a '::' then get out, otherwise\n-         it is probably a line number.  */\n+\t it is probably a line number.  */\n       while (*argptr && !hasColon)\n \t{\n \t  hasColon = (*argptr == ':');\n@@ -10505,7 +10505,7 @@ remove_masked_watchpoint (struct bp_location *bl, enum remove_bp_reason reason)\n   struct watchpoint *w = (struct watchpoint *) bl->owner;\n \n   return target_remove_mask_watchpoint (bl->address, w->hw_wp_mask,\n-\t\t\t\t        bl->watchpoint_type);\n+\t\t\t\t\tbl->watchpoint_type);\n }\n \n /* Implement the \"resources_needed\" breakpoint_ops method for\n@@ -10672,7 +10672,7 @@ is_masked_watchpoint (const struct breakpoint *b)\n }\n \n /* accessflag:  hw_write:  watch write, \n-                hw_read:   watch read, \n+\t\thw_read:   watch read, \n \t\thw_access: watch access (read or write) */\n static void\n watch_command_1 (const char *arg, int accessflag, int from_tty,\n@@ -11038,7 +11038,7 @@ can_use_hardware_watchpoint (const std::vector<value_ref_ptr> &vals)\n \t  else\n \t    {\n \t      /* Ahh, memory we actually used!  Check if we can cover\n-                 it with hardware watchpoints.  */\n+\t\t it with hardware watchpoints.  */\n \t      struct type *vtype = check_typedef (value_type (v));\n \n \t      /* We only watch structs and arrays if user asked for it\n@@ -11363,12 +11363,12 @@ catch_fork_command_1 (const char *arg, int from_tty,\n     case catch_fork_temporary:\n     case catch_fork_permanent:\n       create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n-                                          &catch_fork_breakpoint_ops);\n+\t\t\t\t\t  &catch_fork_breakpoint_ops);\n       break;\n     case catch_vfork_temporary:\n     case catch_vfork_permanent:\n       create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n-                                          &catch_vfork_breakpoint_ops);\n+\t\t\t\t\t  &catch_vfork_breakpoint_ops);\n       break;\n     default:\n       error (_(\"unsupported or unknown fork kind; cannot catch it\"));\n@@ -11425,13 +11425,13 @@ init_ada_exception_breakpoint (struct breakpoint *b,\n       describe_other_breakpoints (loc_gdbarch,\n \t\t\t\t  sal.pspace, sal.pc, sal.section, -1);\n       /* FIXME: brobecker/2006-12-28: Actually, re-implement a special\n-         version for exception catchpoints, because two catchpoints\n-         used for different exception names will use the same address.\n-         In this case, a \"breakpoint ... also set at...\" warning is\n-         unproductive.  Besides, the warning phrasing is also a bit\n-         inappropriate, we should use the word catchpoint, and tell\n-         the user what type of catchpoint it is.  The above is good\n-         enough for now, though.  */\n+\t version for exception catchpoints, because two catchpoints\n+\t used for different exception names will use the same address.\n+\t In this case, a \"breakpoint ... also set at...\" warning is\n+\t unproductive.  Besides, the warning phrasing is also a bit\n+\t inappropriate, we should use the word catchpoint, and tell\n+\t the user what type of catchpoint it is.  The above is good\n+\t enough for now, though.  */\n     }\n \n   init_raw_breakpoint (b, gdbarch, sal, bp_catchpoint, ops);\n@@ -11526,16 +11526,16 @@ clear_command (const char *arg, int from_tty)\n       const char *sal_fullname;\n \n       /* If exact pc given, clear bpts at that pc.\n-         If line given (pc == 0), clear all bpts on specified line.\n-         If defaulting, clear all bpts on default line\n-         or at default pc.\n+\t If line given (pc == 0), clear all bpts on specified line.\n+\t If defaulting, clear all bpts on default line\n+\t or at default pc.\n \n-         defaulting    sal.pc != 0    tests to do\n+\t defaulting    sal.pc != 0    tests to do\n \n-         0              1             pc\n-         1              1             pc _and_ line\n-         0              0             line\n-         1              0             <can't happen> */\n+\t 0              1             pc\n+\t 1              1             pc _and_ line\n+\t 0              0             line\n+\t 1              0             <can't happen> */\n \n       sal_fullname = (sal.symtab == NULL\n \t\t      ? NULL : symtab_to_fullname (sal.symtab));\n@@ -12764,7 +12764,7 @@ internal_bkpt_re_set (struct breakpoint *b)\n       break;\n \n       /* This breakpoint is special, it's set up when the inferior\n-         starts and we really don't want to touch it.  */\n+\t starts and we really don't want to touch it.  */\n     case bp_shlib_event:\n \n       /* Like bp_shlib_event, this breakpoint type is special.  Once\n@@ -13393,8 +13393,8 @@ delete_command (const char *arg, int from_tty)\n       int breaks_to_delete = 0;\n \n       /* Delete all breakpoints if no argument.  Do not delete\n-         internal breakpoints, these have to be deleted with an\n-         explicit breakpoint number argument.  */\n+\t internal breakpoints, these have to be deleted with an\n+\t explicit breakpoint number argument.  */\n       ALL_BREAKPOINTS (b)\n \tif (user_breakpoint_p (b))\n \t  {\n@@ -14956,8 +14956,8 @@ delete_trace_command (const char *arg, int from_tty)\n       int breaks_to_delete = 0;\n \n       /* Delete all breakpoints if no argument.\n-         Do not delete internal or call-dummy breakpoints, these\n-         have to be deleted with an explicit breakpoint number \n+\t Do not delete internal or call-dummy breakpoints, these\n+\t have to be deleted with an explicit breakpoint number \n \t argument.  */\n       ALL_TRACEPOINTS (b)\n \tif (is_tracepoint (b) && user_breakpoint_p (b))\n@@ -15886,17 +15886,17 @@ Set temporary catchpoints to catch events.\"),\n \n   add_catch_command (\"fork\", _(\"Catch calls to fork.\"),\n \t\t     catch_fork_command_1,\n-                     NULL,\n+\t\t     NULL,\n \t\t     (void *) (uintptr_t) catch_fork_permanent,\n \t\t     (void *) (uintptr_t) catch_fork_temporary);\n   add_catch_command (\"vfork\", _(\"Catch calls to vfork.\"),\n \t\t     catch_fork_command_1,\n-                     NULL,\n+\t\t     NULL,\n \t\t     (void *) (uintptr_t) catch_vfork_permanent,\n \t\t     (void *) (uintptr_t) catch_vfork_temporary);\n   add_catch_command (\"exec\", _(\"Catch calls to exec.\"),\n \t\t     catch_exec_command_1,\n-                     NULL,\n+\t\t     NULL,\n \t\t     CATCH_PERMANENT,\n \t\t     CATCH_TEMPORARY);\n   add_catch_command (\"load\", _(\"Catch loads of shared libraries.\\n\\\n@@ -16137,7 +16137,7 @@ where START-LOCATION and END-LOCATION can be one of the following:\\n\\\n   LINENUM, for that line in the current file,\\n\\\n   FILE:LINENUM, for that line in that file,\\n\\\n   +OFFSET, for that number of lines after the current line\\n\\\n-           or the start of the range\\n\\\n+\t   or the start of the range\\n\\\n   FUNCTION, for the first line in that function,\\n\\\n   FILE:FUNCTION, to distinguish among like-named static functions.\\n\\\n   *ADDRESS, for the instruction at that address.\\n\\"
    },
    {
      "sha": "b13522e236b53169eadf94a8e8998acfb48d23fa",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1542,7 +1542,7 @@ extern void breakpoint_set_task (struct breakpoint *b, int task);\n extern void mark_breakpoints_out (void);\n \n extern struct breakpoint *create_jit_event_breakpoint (struct gdbarch *,\n-                                                       CORE_ADDR);\n+\t\t\t\t\t\t       CORE_ADDR);\n \n extern struct breakpoint *create_solib_event_breakpoint (struct gdbarch *,\n \t\t\t\t\t\t\t CORE_ADDR);"
    },
    {
      "sha": "c989f425540e442425a585924077abada6dcd772",
      "filename": "gdb/bsd-uthread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bsd-uthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/bsd-uthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-uthread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -370,7 +370,7 @@ bsd_uthread_target::store_registers (struct regcache *regcache, int regnum)\n   else\n     {\n       /* Updating the thread that is currently running; pass the\n-         request to the layer beneath.  */\n+\t request to the layer beneath.  */\n       beneath ()->store_registers (regcache, regnum);\n     }\n }\n@@ -401,9 +401,9 @@ bsd_uthread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n       gdb_byte buf[4];\n \n       /* FIXME: For executables linked statically with the threads\n-         library, we end up here before the program has actually been\n-         executed.  In that case ADDR will be garbage since it has\n-         been read from the wrong virtual memory image.  */\n+\t library, we end up here before the program has actually been\n+\t executed.  In that case ADDR will be garbage since it has\n+\t been read from the wrong virtual memory image.  */\n       if (target_read_memory (addr, buf, 4) == 0)\n \t{\n \t  ULONGEST magic = extract_unsigned_integer (buf, 4, byte_order);"
    },
    {
      "sha": "af598dfbc25d9420941436d188cc480a2e23e454",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -62,7 +62,7 @@ static void btrace_add_pc (struct thread_info *tp);\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (record_debug != 0)\t\t\t\t\t\t\\\n-        fprintf_unfiltered (gdb_stdlog,\t\t\t\t\t\\\n+\tfprintf_unfiltered (gdb_stdlog,\t\t\t\t\t\\\n \t\t\t    \"[btrace] \" msg \"\\n\", ##args);\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)"
    },
    {
      "sha": "62016ccf34f4cf16019793115dffd98daeb29bd0",
      "filename": "gdb/build-id.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/build-id.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/build-id.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/build-id.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -57,7 +57,7 @@ build_id_verify (bfd *abfd, size_t check_len, const bfd_byte *check)\n     warning (_(\"File \\\"%s\\\" has no build-id, file skipped\"),\n \t     bfd_get_filename (abfd));\n   else if (found->size != check_len\n-           || memcmp (found->data, check, found->size) != 0)\n+\t   || memcmp (found->data, check, found->size) != 0)\n     warning (_(\"File \\\"%s\\\" has a different build-id, file skipped\"),\n \t     bfd_get_filename (abfd));\n   else\n@@ -140,7 +140,7 @@ build_id_to_bfd_suffix (size_t build_id_len, const bfd_byte *build_id,\n       /* Compute where the file named after the build-id would be.\n \n \t If debugdir is \"/usr/lib/debug\" and the build-id is abcdef, this will\n-         give \"/usr/lib/debug/.build-id/ab/cdef.debug\".  */\n+\t give \"/usr/lib/debug/.build-id/ab/cdef.debug\".  */\n       std::string link = debugdir.get ();\n       link += \"/.build-id/\";\n \n@@ -161,12 +161,12 @@ build_id_to_bfd_suffix (size_t build_id_len, const bfd_byte *build_id,\n \treturn debug_bfd;\n \n       /* Try to look under the sysroot as well.  If the sysroot is\n-         \"/the/sysroot\", it will give\n-         \"/the/sysroot/usr/lib/debug/.build-id/ab/cdef.debug\".\n+\t \"/the/sysroot\", it will give\n+\t \"/the/sysroot/usr/lib/debug/.build-id/ab/cdef.debug\".\n \n-         Don't do it if the sysroot is the target system (\"target:\").  It\n-         could work in theory, but the lrealpath in build_id_to_debug_bfd_1\n-         only works with local paths.  */\n+\t Don't do it if the sysroot is the target system (\"target:\").  It\n+\t could work in theory, but the lrealpath in build_id_to_debug_bfd_1\n+\t only works with local paths.  */\n       if (strcmp (gdb_sysroot, TARGET_SYSROOT_PREFIX) != 0)\n \t{\n \t  link = gdb_sysroot + link;"
    },
    {
      "sha": "72e2e8de45f30edbb3dd3fba373593076922667e",
      "filename": "gdb/buildsym-legacy.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/buildsym-legacy.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/buildsym-legacy.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym-legacy.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -63,7 +63,7 @@ extern struct block *finish_block (struct symbol *symbol,\n \t\t\t\t   CORE_ADDR end);\n \n extern void record_block_range (struct block *,\n-                                CORE_ADDR start, CORE_ADDR end_inclusive);\n+\t\t\t\tCORE_ADDR start, CORE_ADDR end_inclusive);\n \n extern void start_subfile (const char *name);\n "
    },
    {
      "sha": "9525962d9668436f76eb870ed118d6ea91b8f42e",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -621,15 +621,15 @@ buildsym_compunit::patch_subfile_names (struct subfile *subfile,\n       set_last_source_file (name);\n \n       /* Default the source language to whatever can be deduced from\n-         the filename.  If nothing can be deduced (such as for a C/C++\n-         include file with a \".h\" extension), then inherit whatever\n-         language the previous subfile had.  This kludgery is\n-         necessary because there is no standard way in some object\n-         formats to record the source language.  Also, when symtabs\n-         are allocated we try to deduce a language then as well, but\n-         it is too late for us to use that information while reading\n-         symbols, since symtabs aren't allocated until after all the\n-         symbols have been processed for a given source file.  */\n+\t the filename.  If nothing can be deduced (such as for a C/C++\n+\t include file with a \".h\" extension), then inherit whatever\n+\t language the previous subfile had.  This kludgery is\n+\t necessary because there is no standard way in some object\n+\t formats to record the source language.  Also, when symtabs\n+\t are allocated we try to deduce a language then as well, but\n+\t it is too late for us to use that information while reading\n+\t symbols, since symtabs aren't allocated until after all the\n+\t symbols have been processed for a given source file.  */\n \n       subfile->language = deduce_language_from_filename (subfile->name);\n       if (subfile->language == language_unknown"
    },
    {
      "sha": "8fd565abbb546bfd0da96c68c24d98efc1460d4f",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -976,19 +976,19 @@ exp     :\tNSSTRING\t/* ObjC NextStep NSString constant\n \n /* C++.  */\n exp     :       TRUEKEYWORD\n-                        { write_exp_elt_opcode (pstate, OP_LONG);\n-                          write_exp_elt_type (pstate,\n+\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_type (pstate,\n \t\t\t\t\t  parse_type (pstate)->builtin_bool);\n-                          write_exp_elt_longcst (pstate, (LONGEST) 1);\n-                          write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 1);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n \t;\n \n exp     :       FALSEKEYWORD\n-                        { write_exp_elt_opcode (pstate, OP_LONG);\n-                          write_exp_elt_type (pstate,\n+\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_type (pstate,\n \t\t\t\t\t  parse_type (pstate)->builtin_bool);\n-                          write_exp_elt_longcst (pstate, (LONGEST) 0);\n-                          write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n \t;\n \n /* end of C++.  */\n@@ -1159,7 +1159,7 @@ variable:\tname_not_typename\n \t\t\t  else if ($1.is_a_field_of_this)\n \t\t\t    {\n \t\t\t      /* C++: it hangs off of `this'.  Must\n-\t\t\t         not inadvertently convert from a method call\n+\t\t\t\t not inadvertently convert from a method call\n \t\t\t\t to data ref.  */\n \t\t\t      pstate->block_tracker->update (sym);\n \t\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n@@ -1528,9 +1528,9 @@ typebase\n \t\t\t\t\t\t       $2.length);\n \t\t\t  $$ = NULL;\n \t\t\t}\n-                /* It appears that this rule for templates is never\n-                   reduced; template recognition happens by lookahead\n-                   in the token processing code in yylex. */\n+\t\t/* It appears that this rule for templates is never\n+\t\t   reduced; template recognition happens by lookahead\n+\t\t   in the token processing code in yylex. */\n \t|\tTEMPLATE name '<' type '>'\n \t\t\t{ $$ = lookup_template_type\n \t\t\t    (copy_name($2).c_str (), $4,\n@@ -1973,7 +1973,7 @@ parse_number (struct parser_state *par_state,\n       if (!parse_float (p, len,\n \t\t\tputithere->typed_val_float.type,\n \t\t\tputithere->typed_val_float.val))\n-        return ERROR;\n+\treturn ERROR;\n \n       if (imaginary_p)\n \tputithere->typed_val_float.type\n@@ -2631,7 +2631,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t= macro_expand_next (&pstate->lexptr, *expression_macro_scope);\n \n       if (expanded != nullptr)\n-        scan_macro_expansion (expanded.get ());\n+\tscan_macro_expansion (expanded.get ());\n     }\n \n   pstate->prev_lexptr = pstate->lexptr;\n@@ -2671,16 +2671,16 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n     {\n     case 0:\n       /* If we were just scanning the result of a macro expansion,\n-         then we need to resume scanning the original text.\n+\t then we need to resume scanning the original text.\n \t If we're parsing for field name completion, and the previous\n \t token allows such completion, return a COMPLETE token.\n-         Otherwise, we were already scanning the original text, and\n-         we're really done.  */\n+\t Otherwise, we were already scanning the original text, and\n+\t we're really done.  */\n       if (scanning_macro_expansion ())\n-        {\n-          finished_macro_expansion ();\n-          goto retry;\n-        }\n+\t{\n+\t  finished_macro_expansion ();\n+\t  goto retry;\n+\t}\n       else if (saw_name_at_eof)\n \t{\n \t  saw_name_at_eof = 0;\n@@ -2689,7 +2689,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n       else if (par_state->parse_completion && saw_structop)\n \treturn COMPLETE;\n       else\n-        return 0;\n+\treturn 0;\n \n     case ' ':\n     case '\\t':\n@@ -2716,8 +2716,8 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \n     case ',':\n       if (pstate->comma_terminates\n-          && paren_depth == 0\n-          && ! scanning_macro_expansion ())\n+\t  && paren_depth == 0\n+\t  && ! scanning_macro_expansion ())\n \treturn 0;\n       pstate->lexptr++;\n       return c;\n@@ -2786,7 +2786,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t  }\n \ttoktype = parse_number (par_state, tokstart, p - tokstart,\n \t\t\t\tgot_dot | got_e | got_p, &yylval);\n-        if (toktype == ERROR)\n+\tif (toktype == ERROR)\n \t  {\n \t    char *err_copy = (char *) alloca (p - tokstart + 1);\n \n@@ -2969,7 +2969,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t\t\t       pstate->expression_context_block,\n \t\t\t       VAR_DOMAIN,\n \t\t\t       (par_state->language ()->la_language\n-\t\t\t        == language_cplus ? &is_a_field_of_this\n+\t\t\t\t== language_cplus ? &is_a_field_of_this\n \t\t\t\t: NULL)).symbol\n \t\t!= NULL)\n \t      {"
    },
    {
      "sha": "e72fdaad30ae28956426ee0f9c0ab3718c3617b4",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -151,7 +151,7 @@ c_print_type_1 (struct type *type,\n \tfputs_styled (varstring, variable_name_style.style (), stream);\n \n       /* For demangled function names, we have the arglist as part of\n-         the name, so don't print an additional pair of ()'s.  */\n+\t the name, so don't print an additional pair of ()'s.  */\n       if (local_name == NULL)\n \t{\n \t  demangled_args = strchr (varstring, '(') != NULL;\n@@ -466,7 +466,7 @@ c_type_print_varspec_prefix (struct type *type,\n     case TYPE_CODE_NAMESPACE:\n     case TYPE_CODE_DECFLOAT:\n       /* These types need no prefix.  They are listed here so that\n-         gcc -Wall will reveal any types that haven't been handled.  */\n+\t gcc -Wall will reveal any types that haven't been handled.  */\n       break;\n     default:\n       error (_(\"type not handled in c_type_print_varspec_prefix()\"));\n@@ -845,8 +845,8 @@ c_type_print_varspec_suffix (struct type *type,\n     case TYPE_CODE_NAMESPACE:\n     case TYPE_CODE_DECFLOAT:\n       /* These types do not need a suffix.  They are listed so that\n-         gcc -Wall will report types that may not have been\n-         considered.  */\n+\t gcc -Wall will report types that may not have been\n+\t considered.  */\n       break;\n     default:\n       error (_(\"type not handled in c_type_print_varspec_suffix()\"));\n@@ -1553,10 +1553,10 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n       if (TYPE_DECLARED_CLASS (type))\n \tfprintf_filtered (stream, \"class \");\n       /* Print the tag name if it exists.\n-         The aCC compiler emits a spurious \n-         \"{unnamed struct}\"/\"{unnamed union}\"/\"{unnamed enum}\"\n-         tag for unnamed struct/union/enum's, which we don't\n-         want to print.  */\n+\t The aCC compiler emits a spurious \n+\t \"{unnamed struct}\"/\"{unnamed union}\"/\"{unnamed enum}\"\n+\t tag for unnamed struct/union/enum's, which we don't\n+\t want to print.  */\n       if (type->name () != NULL\n \t  && !startswith (type->name (), \"{unnamed\"))\n \t{\n@@ -1690,9 +1690,9 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \n     default:\n       /* Handle types not explicitly handled by the other cases, such\n-         as fundamental types.  For these, just print whatever the\n-         type name is, as recorded in the type itself.  If there is no\n-         type name, then complain.  */\n+\t as fundamental types.  For these, just print whatever the\n+\t type name is, as recorded in the type itself.  If there is no\n+\t type name, then complain.  */\n       if (type->name () != NULL)\n \t{\n \t  c_type_print_modifier (type, stream, 0, 1, language);"
    },
    {
      "sha": "f2d4cc930ca8d5c9ca0260a89a6809404c277382",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -493,9 +493,9 @@ c_value_print (struct value *val, struct ui_file *stream,\n       struct type *original_type = value_type (val);\n \n       /* Hack:  remove (char *) for char strings.  Their\n-         type is indicated by the quoted string anyway.\n-         (Don't use c_textual_element_type here; quoted strings\n-         are always exactly (char *), (wchar_t *), or the like.  */\n+\t type is indicated by the quoted string anyway.\n+\t (Don't use c_textual_element_type here; quoted strings\n+\t are always exactly (char *), (wchar_t *), or the like.  */\n       if (original_type->code () == TYPE_CODE_PTR\n \t  && original_type->name () == NULL\n \t  && TYPE_TARGET_TYPE (original_type)->name () != NULL"
    },
    {
      "sha": "09293b4189a9bf9a4202e435a643fa643f0b6824",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -120,10 +120,10 @@ adjust_value_for_child_access (struct value **value,\n \n       enclosing_type = value_actual_type (*value, 1, &real_type_found);\n       if (real_type_found)\n-        {\n-          *type = enclosing_type;\n-          *value = value_cast (enclosing_type, *value);\n-        }\n+\t{\n+\t  *type = enclosing_type;\n+\t  *value = value_cast (enclosing_type, *value);\n+\t}\n     }\n }\n \n@@ -210,10 +210,10 @@ c_number_of_children (const struct varobj *var)\n \t have one child, except for function ptrs, which have no children,\n \t and except for void*, as we don't know what to show.\n \n-         We can show char* so we allow it to be dereferenced.  If you decide\n-         to test for it, please mind that a little magic is necessary to\n-         properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and \n-         TYPE_NAME == \"char\".  */\n+\t We can show char* so we allow it to be dereferenced.  If you decide\n+\t to test for it, please mind that a little magic is necessary to\n+\t properly identify it: char* has TYPE_CODE == TYPE_CODE_INT and \n+\t TYPE_NAME == \"char\".  */\n       if (target->code () == TYPE_CODE_FUNC\n \t  || target->code () == TYPE_CODE_VOID)\n \tchildren = 0;\n@@ -572,11 +572,11 @@ cplus_number_of_children (const struct varobj *var)\n \n       /* It is necessary to access a real type (via RTTI).  */\n       if (opts.objectprint)\n-        {\n-          value = var->value.get ();\n-          lookup_actual_type = (TYPE_IS_REFERENCE (var->type)\n+\t{\n+\t  value = var->value.get ();\n+\t  lookup_actual_type = (TYPE_IS_REFERENCE (var->type)\n \t\t\t\t|| var->type->code () == TYPE_CODE_PTR);\n-        }\n+\t}\n       adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);\n \n       if (((type->code ()) == TYPE_CODE_STRUCT)\n@@ -607,13 +607,13 @@ cplus_number_of_children (const struct varobj *var)\n \n       /* It is necessary to access a real type (via RTTI).  */\n       if (opts.objectprint)\n-        {\n+\t{\n \t  const struct varobj *parent = var->parent;\n \n \t  value = parent->value.get ();\n \t  lookup_actual_type = (TYPE_IS_REFERENCE (parent->type)\n \t\t\t\t|| parent->type->code () == TYPE_CODE_PTR);\n-        }\n+\t}\n       adjust_value_for_child_access (&value, &type, NULL, lookup_actual_type);\n \n       cplus_class_num_children (type, kids);\n@@ -817,10 +817,10 @@ cplus_describe_child (const struct varobj *parent, int index,\n \n \t      /* Cast the parent to the base' type.  Note that in gdb,\n \t\t expression like \n-\t\t         (Base1)d\n+\t\t\t (Base1)d\n \t\t will create an lvalue, for all appearences, so we don't\n \t\t need to use more fancy:\n-\t\t         *(Base1*)(&d)\n+\t\t\t *(Base1*)(&d)\n \t\t construct.\n \n \t\t When we are in the scope of the base class or of one"
    },
    {
      "sha": "b48b897d857116f7eb30ebf0a3fb86b155b691a1",
      "filename": "gdb/charset.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/charset.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/charset.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/charset.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -247,7 +247,7 @@ show_target_charset_name (struct ui_file *file, int from_tty,\n   if (!strcmp (value, \"auto\"))\n     fprintf_filtered (file,\n \t\t      _(\"The target character set is \\\"auto; \"\n-\t\t        \"currently %s\\\".\\n\"),\n+\t\t\t\"currently %s\\\".\\n\"),\n \t\t      gdbarch_auto_charset (get_current_arch ()));\n   else\n     fprintf_filtered (file, _(\"The target character set is \\\"%s\\\".\\n\"),\n@@ -264,7 +264,7 @@ show_target_wide_charset_name (struct ui_file *file,\n   if (!strcmp (value, \"auto\"))\n     fprintf_filtered (file,\n \t\t      _(\"The target wide character set is \\\"auto; \"\n-\t\t        \"currently %s\\\".\\n\"),\n+\t\t\t\"currently %s\\\".\\n\"),\n \t\t      gdbarch_auto_wide_charset (get_current_arch ()));\n   else\n     fprintf_filtered (file, _(\"The target wide character set is \\\"%s\\\".\\n\"),"
    },
    {
      "sha": "54822fad481cbe4f5dbac078b8fada4070f59467",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -488,7 +488,7 @@ pwd_command (const char *args, int from_tty)\n \n   if (cwd == NULL)\n     error (_(\"Error finding name of working directory: %s\"),\n-           safe_strerror (errno));\n+\t   safe_strerror (errno));\n \n   if (strcmp (cwd.get (), current_directory) != 0)\n     printf_unfiltered (_(\"Working directory %ps\\n (canonically %ps).\\n\"),\n@@ -532,7 +532,7 @@ cd_command (const char *dir, int from_tty)\n   if (IS_DIR_SEPARATOR (dir[len - 1]))\n     {\n       /* Remove the trailing slash unless this is a root directory\n-         (including a drive letter on non-Unix systems).  */\n+\t (including a drive letter on non-Unix systems).  */\n       if (!(len == 1)\t\t/* \"/\" */\n #ifdef HAVE_DOS_BASED_FILE_SYSTEM\n \t  && !(len == 3 && dir[1] == ':') /* \"d:/\" */\n@@ -571,7 +571,7 @@ cd_command (const char *dir, int from_tty)\n \t  if (found_real_path)\n \t    {\n \t      /* Search backwards for the directory just before the \"/..\"\n-\t         and obliterate it and the \"/..\".  */\n+\t\t and obliterate it and the \"/..\".  */\n \t      char *q = p;\n \n \t      while (q != current_directory && !IS_DIR_SEPARATOR (q[-1]))\n@@ -716,7 +716,7 @@ source_script_with_search (const char *file, int from_tty, int search_path)\n   if (!opened)\n     {\n       /* The script wasn't found, or was otherwise inaccessible.\n-         If the source command was invoked interactively, throw an\n+\t If the source command was invoked interactively, throw an\n \t error.  Otherwise (e.g. if it was invoked by a script),\n \t just emit a warning, rather than cause an error.  */\n       if (from_tty)\n@@ -971,40 +971,40 @@ edit_command (const char *arg, int from_tty)\n       sal = sals[0];\n \n       if (*arg1)\n-        error (_(\"Junk at end of line specification.\"));\n+\terror (_(\"Junk at end of line specification.\"));\n \n       /* If line was specified by address, first print exactly which\n-         line, and which file.  In this case, sal.symtab == 0 means\n-         address is outside of all known source files, not that user\n-         failed to give a filename.  */\n+\t line, and which file.  In this case, sal.symtab == 0 means\n+\t address is outside of all known source files, not that user\n+\t failed to give a filename.  */\n       if (*arg == '*')\n-        {\n+\t{\n \t  struct gdbarch *gdbarch;\n \n-          if (sal.symtab == 0)\n+\t  if (sal.symtab == 0)\n \t    error (_(\"No source file for address %s.\"),\n \t\t   paddress (get_current_arch (), sal.pc));\n \n \t  gdbarch = SYMTAB_OBJFILE (sal.symtab)->arch ();\n-          sym = find_pc_function (sal.pc);\n-          if (sym)\n+\t  sym = find_pc_function (sal.pc);\n+\t  if (sym)\n \t    printf_filtered (\"%s is in %s (%s:%d).\\n\",\n \t\t\t     paddress (gdbarch, sal.pc),\n \t\t\t     sym->print_name (),\n \t\t\t     symtab_to_filename_for_display (sal.symtab),\n \t\t\t     sal.line);\n-          else\n+\t  else\n \t    printf_filtered (\"%s is at %s:%d.\\n\",\n \t\t\t     paddress (gdbarch, sal.pc),\n \t\t\t     symtab_to_filename_for_display (sal.symtab),\n \t\t\t     sal.line);\n-        }\n+\t}\n \n       /* If what was given does not imply a symtab, it must be an\n-         undebuggable symbol which means no source code.  */\n+\t undebuggable symbol which means no source code.  */\n \n       if (sal.symtab == 0)\n-        error (_(\"No line number known for %s.\"), arg);\n+\terror (_(\"No line number known for %s.\"), arg);\n     }\n \n   if ((editor = getenv (\"EDITOR\")) == NULL)\n@@ -1110,7 +1110,7 @@ pipe_command (const char *arg, int from_tty)\n \n   if (exit_status < 0)\n     error (_(\"shell command \\\"%s\\\" failed: %s\"), shell_command,\n-           safe_strerror (errno));\n+\t   safe_strerror (errno));\n   exit_status_set_internal_vars (exit_status);\n }\n \n@@ -1400,7 +1400,7 @@ print_disassembly (struct gdbarch *gdbarch, const char *name,\n \tprintf_filtered (_(\"for function %ps:\\n\"),\n \t\t\t styled_string (function_name_style.style (), name));\n       if (block == nullptr || BLOCK_CONTIGUOUS_P (block))\n-        {\n+\t{\n \t  if (name == NULL)\n \t    printf_filtered (_(\"from %ps to %ps:\\n\"),\n \t\t\t     styled_string (address_style.style (),\n@@ -1412,7 +1412,7 @@ print_disassembly (struct gdbarch *gdbarch, const char *name,\n \t  gdb_disassembly (gdbarch, current_uiout, flags, -1, low, high);\n \t}\n       else\n-        {\n+\t{\n \t  for (int i = 0; i < BLOCK_NRANGES (block); i++)\n \t    {\n \t      CORE_ADDR range_low = BLOCK_RANGE_START (block, i);"
    },
    {
      "sha": "71924c3fb8c05ea686839e07dbd3e534a7688b24",
      "filename": "gdb/cli/cli-decode.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-decode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-decode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -354,11 +354,11 @@ update_prefix_field_of_prefixed_commands (struct cmd_list_element *c)\n       /* We must recursively update the prefix field to cover\n \t e.g.  'info auto-load libthread-db' where the creation\n \t order was:\n-           libthread-db\n-           auto-load\n-           info\n+\t   libthread-db\n+\t   auto-load\n+\t   info\n \t In such a case, when 'auto-load' was created by do_add_cmd,\n-         the 'libthread-db' prefix field could not be updated, as the\n+\t the 'libthread-db' prefix field could not be updated, as the\n \t 'auto-load' command was not yet reachable by\n \t    lookup_cmd_for_prefixlist (list, cmdlist)\n \t    that searches from the top level 'cmdlist'.  */\n@@ -450,7 +450,7 @@ add_show_prefix_cmd (const char *name, enum command_class theclass,\n \n struct cmd_list_element *\n add_prefix_cmd_suppress_notification\n-               (const char *name, enum command_class theclass,\n+\t       (const char *name, enum command_class theclass,\n \t\tcmd_const_cfunc_ftype *fun,\n \t\tconst char *doc, struct cmd_list_element **prefixlist,\n \t\tconst char *prefixname, int allow_unknown,\n@@ -1260,16 +1260,16 @@ help_cmd (const char *command, struct ui_file *stream)\n \n   if (c->hook_pre || c->hook_post)\n     fprintf_filtered (stream,\n-                      \"\\nThis command has a hook (or hooks) defined:\\n\");\n+\t\t      \"\\nThis command has a hook (or hooks) defined:\\n\");\n \n   if (c->hook_pre)\n     fprintf_filtered (stream,\n-                      \"\\tThis command is run after  : %s (pre hook)\\n\",\n-                    c->hook_pre->name);\n+\t\t      \"\\tThis command is run after  : %s (pre hook)\\n\",\n+\t\t    c->hook_pre->name);\n   if (c->hook_post)\n     fprintf_filtered (stream,\n-                      \"\\tThis command is run before : %s (post hook)\\n\",\n-                    c->hook_post->name);\n+\t\t      \"\\tThis command is run before : %s (post hook)\\n\",\n+\t\t    c->hook_post->name);\n }\n \n /*\n@@ -1352,7 +1352,7 @@ help_all (struct ui_file *stream)\n   for (c = cmdlist; c; c = c->next)\n     {\n       if (c->abbrev_flag)\n-        continue;\n+\tcontinue;\n       /* If this is a class name, print all of the commands in the\n \t class.  */\n \n@@ -1370,7 +1370,7 @@ help_all (struct ui_file *stream)\n   for (c = cmdlist; c; c = c->next)\n     {\n       if (c->abbrev_flag)\n-        continue;\n+\tcontinue;\n \n       if (c->theclass == no_class)\n \t{\n@@ -1496,7 +1496,7 @@ help_cmd_list (struct cmd_list_element *list, enum command_class theclass,\n \t  || (theclass == c->theclass && c->func != NULL))\n \t{\n \t  /* show C when\n-             - showing all commands\n+\t     - showing all commands\n \t     - showing all classes and C is a help class\n \t     - showing commands of THECLASS and C is not the help class  */\n \n@@ -1748,9 +1748,9 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n \t  if (result_list != nullptr)\n \t    if (!*result_list)\n \t      /* This used to say *result_list = *found->prefixlist.\n-\t         If that was correct, need to modify the documentation\n-\t         at the top of this function to clarify what is\n-\t         supposed to be going on.  */\n+\t\t If that was correct, need to modify the documentation\n+\t\t at the top of this function to clarify what is\n+\t\t supposed to be going on.  */\n \t      *result_list = found;\n \t  /* For ambiguous commands, do not return any default_args args.  */\n \t  if (default_args != nullptr)\n@@ -1840,7 +1840,7 @@ lookup_cmd (const char **line, struct cmd_list_element *list,\n   else if (c == CMD_LIST_AMBIGUOUS)\n     {\n       /* Ambigous.  Local values should be off prefixlist or called\n-         values.  */\n+\t values.  */\n       int local_allow_unknown = (last_list ? last_list->allow_unknown :\n \t\t\t\t allow_unknown);\n       const char *local_cmdtype = last_list ? last_list->prefixname : cmdtype;\n@@ -1890,10 +1890,10 @@ lookup_cmd (const char **line, struct cmd_list_element *list,\n   else\n     {\n       if (c->type == set_cmd && **line != '\\0' && !isspace (**line))\n-        error (_(\"Argument must be preceded by space.\"));\n+\terror (_(\"Argument must be preceded by space.\"));\n \n       /* We've got something.  It may still not be what the caller\n-         wants (if this command *needs* a subcommand).  */\n+\t wants (if this command *needs* a subcommand).  */\n       while (**line == ' ' || **line == '\\t')\n \t(*line)++;\n "
    },
    {
      "sha": "295a59030230b8f46c86eb215647c547975a2b2a",
      "filename": "gdb/cli/cli-decode.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-decode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-decode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -89,7 +89,7 @@ struct cmd_list_element\n     /* The user needs to be warned that this is a deprecated command.\n        The user should only be warned the first time a command is\n        used.  */\n-        \n+\t\n     unsigned int deprecated_warn_user : 1;\n \n     /* When functions are deprecated at compile time (this is the way"
    },
    {
      "sha": "afa44af95a03555083a9a901199f3e9612a981c7",
      "filename": "gdb/cli/cli-script.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-script.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-script.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-script.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -210,7 +210,7 @@ print_command_lines (struct ui_out *uiout, struct command_line *cmd,\n \t}\n \n       /* loop_continue to jump to the start of a while loop, print it\n-         and continue. */\n+\t and continue. */\n       if (list->control_type == continue_control)\n \t{\n \t  uiout->field_string (NULL, \"loop_continue\");\n@@ -544,15 +544,15 @@ execute_control_command_1 (struct command_line *cmd, int from_tty)\n       print_command_trace (\"loop_continue\");\n \n       /* Return for \"continue\", and \"break\" so we can either\n-         continue the loop at the top, or break out.  */\n+\t continue the loop at the top, or break out.  */\n       ret = cmd->control_type;\n       break;\n \n     case break_control:\n       print_command_trace (\"loop_break\");\n \n       /* Return for \"continue\", and \"break\" so we can either\n-         continue the loop at the top, or break out.  */\n+\t continue the loop at the top, or break out.  */\n       ret = cmd->control_type;\n       break;\n \n@@ -1147,7 +1147,7 @@ recurse_read_control_structure (gdb::function_view<const char * ()> read_next_li\n       child_tail = next;\n \n       /* If the latest line is another control structure, then recurse\n-         on it.  */\n+\t on it.  */\n       if (multi_line_command_p (next->control_type))\n \t{\n \t  control_level++;\n@@ -1485,20 +1485,20 @@ do_define_command (const char *comname, int from_tty,\n   if (hookc)\n     {\n       switch (hook_type)\n-        {\n-        case CMD_PRE_HOOK:\n-          hookc->hook_pre  = newc;  /* Target gets hooked.  */\n-          newc->hookee_pre = hookc; /* We are marked as hooking target cmd.  */\n-          break;\n-        case CMD_POST_HOOK:\n-          hookc->hook_post  = newc;  /* Target gets hooked.  */\n-          newc->hookee_post = hookc; /* We are marked as hooking\n+\t{\n+\tcase CMD_PRE_HOOK:\n+\t  hookc->hook_pre  = newc;  /* Target gets hooked.  */\n+\t  newc->hookee_pre = hookc; /* We are marked as hooking target cmd.  */\n+\t  break;\n+\tcase CMD_POST_HOOK:\n+\t  hookc->hook_post  = newc;  /* Target gets hooked.  */\n+\t  newc->hookee_post = hookc; /* We are marked as hooking\n \t\t\t\t\ttarget cmd.  */\n-          break;\n-        default:\n-          /* Should never come here as hookc would be 0.  */\n+\t  break;\n+\tdefault:\n+\t  /* Should never come here as hookc would be 0.  */\n \t  internal_error (__FILE__, __LINE__, _(\"bad switch\"));\n-        }\n+\t}\n     }\n }\n "
    },
    {
      "sha": "cec97dd00d5feac53d2c9add9940e6781da9e061",
      "filename": "gdb/cli/cli-setshow.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-setshow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cli/cli-setshow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-setshow.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -743,7 +743,7 @@ cmd_show_list (struct cmd_list_element *list, int from_tty)\n       /* We skip show command aliases to avoid showing duplicated values.  */\n \n       /* If we find a prefix, run its list, prefixing our output by its\n-         prefix (with \"show \" skipped).  */\n+\t prefix (with \"show \" skipped).  */\n       if (list->prefixlist && list->cmd_pointer == nullptr)\n \t{\n \t  ui_out_emit_tuple optionlist_emitter (uiout, \"optionlist\");"
    },
    {
      "sha": "49c5efd949dc7cfa6be0a6fab99a4738ba81e4f4",
      "filename": "gdb/coff-pe-read.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/coff-pe-read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/coff-pe-read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coff-pe-read.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -133,7 +133,7 @@ get_section_vmas (bfd *abfd, asection *sectp, void *context)\n   if (sectix != PE_SECTION_INDEX_INVALID)\n     {\n       /* Data within the section start at rva_start in the pe and at\n-         bfd_get_section_vma() within memory.  Store the offset.  */\n+\t bfd_get_section_vma() within memory.  Store the offset.  */\n \n       sections[sectix].vma_offset\n \t= bfd_section_vma (sectp) - sections[sectix].rva_start;\n@@ -549,7 +549,7 @@ read_pe_exported_syms (minimal_symbol_reader &reader,\n       /* Pointer to the function address vector.  */\n       /* This is relative to ordinal value. */\n       unsigned long func_rva = pe_as32 (erva + exp_funcbase +\n-                                        ordinal * 4);\n+\t\t\t\t\tordinal * 4);\n \n       /* Find this symbol's section in our own array.  */\n       int sectix = 0;"
    },
    {
      "sha": "c61c9a7ca15e88c43dec9bcef47d01952b5440a4",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -241,7 +241,7 @@ coff_locate_sections (bfd *abfd, asection *sectp, void *csip)\n       const char *s;\n \n       /* We can have multiple .stab sections if linked with\n-         --split-by-reloc.  */\n+\t --split-by-reloc.  */\n       for (s = name + sizeof \".stab\" - 1; *s != '\\0'; s++)\n \tif (!isdigit (*s))\n \t  break;\n@@ -610,10 +610,10 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n       bfd_map_over_sections (abfd, find_linenos, (void *) info);\n \n       val = init_lineno (abfd, info->min_lineno_offset,\n-                         info->max_lineno_offset - info->min_lineno_offset,\n+\t\t\t info->max_lineno_offset - info->min_lineno_offset,\n \t\t\t &linetab_storage);\n       if (val < 0)\n-        error (_(\"\\\"%s\\\": error reading line numbers.\"), filename);\n+\terror (_(\"\\\"%s\\\": error reading line numbers.\"), filename);\n     }\n \n   /* Now read the string table, all at once.  */\n@@ -659,7 +659,7 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \t\t  int lead = bfd_get_symbol_leading_char (objfile->obfd);\n \t\t  struct bound_minimal_symbol found;\n \n-                  if (lead != '\\0' && *name1 == lead)\n+\t\t  if (lead != '\\0' && *name1 == lead)\n \t\t    name1 += 1;\n \n \t\t  found = lookup_minimal_symbol (name1, NULL, objfile);\n@@ -688,7 +688,7 @@ coff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \t}\n \n       /* FIXME: dubious.  Why can't we use something normal like\n-         bfd_get_section_contents?  */\n+\t bfd_get_section_contents?  */\n       bfd_seek (abfd, abfd->where, 0);\n \n       stabstrsize = bfd_section_size (info->stabstrsect);\n@@ -1039,15 +1039,15 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t      /* Value contains address of first non-init type\n \t\t code.  */\n \t      /* main_aux.x_sym.x_misc.x_lnsz.x_lnno\n-\t         contains line number of '{' }.  */\n+\t\t contains line number of '{' }.  */\n \t      if (cs->c_naux != 1)\n \t\tcomplaint (_(\"`.bf' symbol %d has no aux entry\"),\n \t\t\t   cs->c_symnum);\n \t      fcn_first_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;\n \t      fcn_first_line_addr = cs->c_value;\n \n \t      /* Might want to check that locals are 0 and\n-\t         context_stack_depth is zero, and complain if not.  */\n+\t\t context_stack_depth is zero, and complain if not.  */\n \n \t      depth = 0;\n \t      newobj = push_context (depth, fcn_start_addr);\n@@ -1061,9 +1061,9 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t      if (!within_function)\n \t\terror (_(\"Bad coff function information.\"));\n \t      /* The value of .ef is the address of epilogue code;\n-\t         not useful for gdb.  */\n+\t\t not useful for gdb.  */\n \t      /* { main_aux.x_sym.x_misc.x_lnsz.x_lnno\n-\t         contains number of lines to '}' */\n+\t\t contains number of lines to '}' */\n \n \t      if (outermost_context_p ())\n \t\t{\t/* We attempted to pop an empty context stack.  */\n@@ -1095,12 +1095,12 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t\t  fcn_last_line = main_aux.x_sym.x_misc.x_lnsz.x_lnno;\n \t\t}\n \t      /* fcn_first_line is the line number of the opening '{'.\n-\t         Do not record it - because it would affect gdb's idea\n-\t         of the line number of the first statement of the\n-\t         function - except for one-line functions, for which\n-\t         it is also the line number of all the statements and\n-\t         of the closing '}', and for which we do not have any\n-\t         other statement-line-number.  */\n+\t\t Do not record it - because it would affect gdb's idea\n+\t\t of the line number of the first statement of the\n+\t\t function - except for one-line functions, for which\n+\t\t it is also the line number of all the statements and\n+\t\t of the closing '}', and for which we do not have any\n+\t\t other statement-line-number.  */\n \t      if (fcn_last_line == 1)\n \t\trecord_line (get_current_subfile (), fcn_first_line,\n \t\t\t     gdbarch_addr_bits_remove (gdbarch,\n@@ -1214,7 +1214,7 @@ read_one_sym (struct coff_symbol *cs,\n \t\t\t    sym->n_type, sym->n_sclass,\n \t\t\t    0, cs->c_naux, (char *) aux);\n       /* If more than one aux entry, read past it (only the first aux\n-         is important).  */\n+\t is important).  */\n       for (i = 1; i < cs->c_naux; i++)\n \t{\n \t  bytes = bfd_bread (temp_aux, local_auxesz, nlist_bfd_global);\n@@ -1317,7 +1317,7 @@ getsymname (struct internal_syment *symbol_entry)\n   if (symbol_entry->_n._n_n._n_zeroes == 0)\n     {\n       /* FIXME: Probably should be detecting corrupt symbol files by\n-         seeing whether offset points to within the stringtab.  */\n+\t seeing whether offset points to within the stringtab.  */\n       result = stringtab + symbol_entry->_n._n_n._n_offset;\n     }\n   else\n@@ -1486,9 +1486,9 @@ patch_opaque_types (struct symtab *s)\n   ALL_BLOCK_SYMBOLS (b, iter, real_sym)\n     {\n       /* Find completed typedefs to use to fix opaque ones.\n-         Remove syms from the chain when their types are stored,\n-         but search the whole chain, as there may be several syms\n-         from different files with the same name.  */\n+\t Remove syms from the chain when their types are stored,\n+\t but search the whole chain, as there may be several syms\n+\t from different files with the same name.  */\n       if (SYMBOL_CLASS (real_sym) == LOC_TYPEDEF\n \t  && SYMBOL_DOMAIN (real_sym) == VAR_DOMAIN\n \t  && SYMBOL_TYPE (real_sym)->code () == TYPE_CODE_PTR"
    },
    {
      "sha": "75b226d900e992e213abd34218d4fc8fb229badd",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -383,7 +383,7 @@ compile_cplus_instance::new_scope (const char *type_name, struct type *type)\n \t{\n \t  scope_component comp\n \t    = {\n-\t        decl_name (type->name ()).get (),\n+\t\tdecl_name (type->name ()).get (),\n \t\tlookup_symbol (type->name (), block (), VAR_DOMAIN, nullptr)\n \t      };\n \t  scope.push_back (comp);"
    },
    {
      "sha": "13a8639a48304a53cf97c34e741981e1ad7134e2",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -208,7 +208,7 @@ link_callbacks_multiple_definition (struct bfd_link_info *link_info,\n \n static void\n link_callbacks_warning (struct bfd_link_info *link_info, const char *xwarning,\n-                        const char *symbol, bfd *abfd, asection *section,\n+\t\t\tconst char *symbol, bfd *abfd, asection *section,\n \t\t\tbfd_vma address)\n {\n   warning (_(\"Compiled module \\\"%s\\\" section \\\"%s\\\": warning: %s\"),\n@@ -621,7 +621,7 @@ compile_object_load (const compile_file_names &file_names,\n   gdb_bfd_ref_ptr abfd (gdb_bfd_open (filename.get (), gnutarget));\n   if (abfd == NULL)\n     error (_(\"\\\"%s\\\": could not open as compiled module: %s\"),\n-          filename.get (), bfd_errmsg (bfd_get_error ()));\n+\t  filename.get (), bfd_errmsg (bfd_get_error ()));\n \n   if (!bfd_check_format_matches (abfd.get (), bfd_object, &matching))\n     error (_(\"\\\"%s\\\": not in loadable format: %s\"),"
    },
    {
      "sha": "262c8556bf6c9cf339fce4ba175c3c4a8d83003a",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -228,7 +228,7 @@ filename_completer (struct cmd_list_element *ignore,\n \t will loop indefinitely.  */\n       subsequent_name = 1;\n       /* Like emacs, don't complete on old versions.  Especially\n-         useful in the \"source\" command.  */\n+\t useful in the \"source\" command.  */\n       const char *p = p_rl.get ();\n       if (p[strlen (p) - 1] == '~')\n \tcontinue;\n@@ -2650,8 +2650,8 @@ gdb_printable_part (char *pathname)\n   else if (temp[1] == '\\0')\n     {\n       for (x = temp - 1; x > pathname; x--)\n-        if (*x == '/')\n-          break;\n+\tif (*x == '/')\n+\t  break;\n       return ((*x == '/') ? x + 1 : pathname);\n     }\n   else\n@@ -2753,15 +2753,15 @@ gdb_fnprint (const char *to_print, int prefix_bytes,\n   while (*s)\n     {\n       if (CTRL_CHAR (*s))\n-        {\n-          displayer->putch (displayer, '^');\n-          displayer->putch (displayer, UNCTRL (*s));\n-          printed_len += 2;\n-          s++;\n+\t{\n+\t  displayer->putch (displayer, '^');\n+\t  displayer->putch (displayer, UNCTRL (*s));\n+\t  printed_len += 2;\n+\t  s++;\n #if defined (HANDLE_MULTIBYTE)\n \t  memset (&ps, 0, sizeof (mbstate_t));\n #endif\n-        }\n+\t}\n       else if (*s == RUBOUT)\n \t{\n \t  displayer->putch (displayer, '^');"
    },
    {
      "sha": "336b351b61ee18e256e0137973461ece6b6d3d47",
      "filename": "gdb/corefile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corefile.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -88,8 +88,8 @@ specify_exec_file_hook (void (*hook) (const char *))\n \t}\n \n       /* Grow the hook array by one and add the new hook to the end.\n-         Yes, it's inefficient to grow it by one each time but since\n-         this is hardly ever called it's not a big deal.  */\n+\t Yes, it's inefficient to grow it by one each time but since\n+\t this is hardly ever called it's not a big deal.  */\n       exec_file_hook_count++;\n       new_array = (hook_type *)\n \txrealloc (exec_file_extra_hooks,"
    },
    {
      "sha": "aef1a02e5d87b332ab23802c0881affce43a51bf",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -199,7 +199,7 @@ core_target::build_file_mappings ()\n     /* read_core_file_mappings will invoke this lambda for each mapping\n        that it finds.  */\n     [&] (int num, ULONGEST start, ULONGEST end, ULONGEST file_ofs,\n-         const char *filename, const void *other)\n+\t const char *filename, const void *other)\n       {\n \t/* Architecture-specific read_core_mapping methods are expected to\n \t   weed out non-file-backed mappings.  */\n@@ -226,7 +226,7 @@ core_target::build_file_mappings ()\n \t      }\n \n \t    bfd = bfd_map[filename] = bfd_openr (expanded_fname.get (),\n-\t                                         \"binary\");\n+\t\t\t\t\t\t \"binary\");\n \n \t    if (bfd == nullptr || !bfd_check_format (bfd, bfd_object))\n \t      {\n@@ -287,7 +287,7 @@ core_target::close ()\n       exit_inferior_silent (current_inferior ());\n \n       /* Clear out solib state while the bfd is still open.  See\n-         comments in clear_solib in solib.c.  */\n+\t comments in clear_solib in solib.c.  */\n       clear_solib ();\n \n       current_program_space->cbfd.reset (nullptr);\n@@ -435,8 +435,8 @@ core_target_open (const char *arg, int from_tty)\n     {\n       /* Do it after the err msg */\n       /* FIXME: should be checking for errors from bfd_close (for one\n-         thing, on error it does not free all the storage associated\n-         with the bfd).  */\n+\t thing, on error it does not free all the storage associated\n+\t with the bfd).  */\n       error (_(\"\\\"%s\\\" is not a core dump: %s\"),\n \t     filename.get (), bfd_errmsg (bfd_get_error ()));\n     }\n@@ -760,7 +760,7 @@ core_target::xfer_memory_via_mappings (gdb_byte *readbuf,\n   for (const auto &mr : m_core_unavailable_mappings)\n     {\n       if (address_in_mem_range (memaddr, &mr))\n-        {\n+\t{\n \t  if (!address_in_mem_range (memend, &mr))\n \t    len = mr.start + mr.length - memaddr;\n \n@@ -1167,7 +1167,7 @@ _initialize_corelow ()\n {\n   add_target (core_target_info, core_target_open, filename_completer);\n   add_cmd (\"core-file-backed-mappings\", class_maintenance,\n-           maintenance_print_core_file_backed_mappings,\n+\t   maintenance_print_core_file_backed_mappings,\n \t   _(\"Print core file's file-backed mappings.\"),\n \t   &maintenanceprintlist);\n }"
    },
    {
      "sha": "e74b0134cc636ea05dcc838967e11f295ade8070",
      "filename": "gdb/cp-abi.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-abi.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-abi.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-abi.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -135,7 +135,7 @@ extern struct value *value_virtual_fn_field (struct value **valuep,\n    FULL, TOP, and USING_ENC can each be zero, in which case we don't\n    provide the corresponding piece of information.  */\n extern struct type *value_rtti_type (struct value *value,\n-                                     int *full, LONGEST *top,\n+\t\t\t\t     int *full, LONGEST *top,\n \t\t\t\t     int *using_enc);\n \n /* Compute the offset of the baseclass which is the INDEXth baseclass"
    },
    {
      "sha": "ea4f11b4b30224190b218eeceb97bcd221fa9432",
      "filename": "gdb/cp-name-parser.y",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-name-parser.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-name-parser.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-name-parser.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1337,8 +1337,8 @@ cpname_state::parse_number (const char *p, int len, int parsed_float,\n       char c;\n \n       /* The GDB lexer checks the result of scanf at this point.  Not doing\n-         this leaves our error checking slightly weaker but only for invalid\n-         data.  */\n+\t this leaves our error checking slightly weaker but only for invalid\n+\t data.  */\n \n       /* See if it has `f' or `l' suffix (float or long double).  */\n \n@@ -1696,7 +1696,7 @@ yylex (YYSTYPE *lvalp, cpname_state *state)\n \t  }\n \ttoktype = state->parse_number (tokstart, p - tokstart, got_dot|got_e,\n \t\t\t\t       lvalp);\n-        if (toktype == ERROR)\n+\tif (toktype == ERROR)\n \t  {\n \t    char *err_copy = (char *) alloca (p - tokstart + 1);\n \n@@ -1804,7 +1804,7 @@ yylex (YYSTYPE *lvalp, cpname_state *state)\n     {\n     case 16:\n       if (strncmp (tokstart, \"reinterpret_cast\", 16) == 0)\n-        return REINTERPRET_CAST;\n+\treturn REINTERPRET_CAST;\n       break;\n     case 12:\n       if (strncmp (tokstart, \"construction vtable for \", 24) == 0)\n@@ -1813,11 +1813,11 @@ yylex (YYSTYPE *lvalp, cpname_state *state)\n \t  return CONSTRUCTION_VTABLE;\n \t}\n       if (strncmp (tokstart, \"dynamic_cast\", 12) == 0)\n-        return DYNAMIC_CAST;\n+\treturn DYNAMIC_CAST;\n       break;\n     case 11:\n       if (strncmp (tokstart, \"static_cast\", 11) == 0)\n-        return STATIC_CAST;\n+\treturn STATIC_CAST;\n       break;\n     case 9:\n       HANDLE_SPECIAL (\"covariant return thunk to \", DEMANGLE_COMPONENT_COVARIANT_THUNK);"
    },
    {
      "sha": "6cfe885554b2ba4294728867bf76e58d45bded9e",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -359,7 +359,7 @@ cp_lookup_symbol_in_namespace (const char *the_namespace, const char *name,\n      namespace A {\n        using namespace X;\n        namespace B {\n-         using namespace Y;\n+\t using namespace Y;\n        }\n      }\n \n@@ -404,14 +404,14 @@ cp_lookup_symbol_via_imports (const char *scope,\n \n       len = strlen (current->import_dest);\n       directive_match = (search_parents\n-                         ? (startswith (scope, current->import_dest)\n-                            && (len == 0\n-                                || scope[len] == ':'\n+\t\t\t ? (startswith (scope, current->import_dest)\n+\t\t\t    && (len == 0\n+\t\t\t\t|| scope[len] == ':'\n \t\t\t\t|| scope[len] == '\\0'))\n-                         : strcmp (scope, current->import_dest) == 0);\n+\t\t\t : strcmp (scope, current->import_dest) == 0);\n \n       /* If the import destination is the current scope or one of its\n-         ancestors then it is applicable.  */\n+\t ancestors then it is applicable.  */\n       if (directive_match && !current->searched)\n \t{\n \t  /* Mark this import as searched so that the recursive call\n@@ -628,9 +628,9 @@ cp_lookup_symbol_via_all_imports (const char *scope, const char *name,\n \n struct block_symbol\n cp_lookup_symbol_namespace (const char *scope,\n-                            const char *name,\n-                            const struct block *block,\n-                            const domain_enum domain)\n+\t\t\t    const char *name,\n+\t\t\t    const struct block *block,\n+\t\t\t    const domain_enum domain)\n {\n   struct block_symbol sym;\n "
    },
    {
      "sha": "e152d12779f9cfb7a8404651fd06c454d14fa610",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -735,8 +735,8 @@ cp_class_name_from_physname (const char *physname)\n       case DEMANGLE_COMPONENT_RESTRICT_THIS:\n       case DEMANGLE_COMPONENT_VOLATILE_THIS:\n       case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n-        ret_comp = d_left (ret_comp);\n-        break;\n+\tret_comp = d_left (ret_comp);\n+\tbreak;\n       default:\n \tdone = 1;\n \tbreak;\n@@ -763,8 +763,8 @@ cp_class_name_from_physname (const char *physname)\n       case DEMANGLE_COMPONENT_QUAL_NAME:\n       case DEMANGLE_COMPONENT_LOCAL_NAME:\n \tprev_comp = cur_comp;\n-        cur_comp = d_right (cur_comp);\n-        break;\n+\tcur_comp = d_right (cur_comp);\n+\tbreak;\n       case DEMANGLE_COMPONENT_TEMPLATE:\n       case DEMANGLE_COMPONENT_NAME:\n       case DEMANGLE_COMPONENT_CTOR:\n@@ -811,11 +811,11 @@ unqualified_name_from_comp (struct demangle_component *comp)\n       {\n       case DEMANGLE_COMPONENT_QUAL_NAME:\n       case DEMANGLE_COMPONENT_LOCAL_NAME:\n-        ret_comp = d_right (ret_comp);\n-        break;\n+\tret_comp = d_right (ret_comp);\n+\tbreak;\n       case DEMANGLE_COMPONENT_TYPED_NAME:\n-        ret_comp = d_left (ret_comp);\n-        break;\n+\tret_comp = d_left (ret_comp);\n+\tbreak;\n       case DEMANGLE_COMPONENT_TEMPLATE:\n \tgdb_assert (last_template == NULL);\n \tlast_template = ret_comp;\n@@ -828,8 +828,8 @@ unqualified_name_from_comp (struct demangle_component *comp)\n       case DEMANGLE_COMPONENT_RESTRICT_THIS:\n       case DEMANGLE_COMPONENT_VOLATILE_THIS:\n       case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n-        ret_comp = d_left (ret_comp);\n-        break;\n+\tret_comp = d_left (ret_comp);\n+\tbreak;\n       case DEMANGLE_COMPONENT_NAME:\n       case DEMANGLE_COMPONENT_CTOR:\n       case DEMANGLE_COMPONENT_DTOR:\n@@ -936,8 +936,8 @@ cp_remove_params_1 (const char *demangled_name, bool require_params)\n       case DEMANGLE_COMPONENT_RESTRICT_THIS:\n       case DEMANGLE_COMPONENT_VOLATILE_THIS:\n       case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n-        ret_comp = d_left (ret_comp);\n-        break;\n+\tret_comp = d_left (ret_comp);\n+\tbreak;\n       default:\n \tdone = true;\n \tbreak;\n@@ -1337,8 +1337,8 @@ add_symbol_overload_list_adl_namespace (struct type *type,\n \n   while (type->code () == TYPE_CODE_PTR\n \t || TYPE_IS_REFERENCE (type)\n-         || type->code () == TYPE_CODE_ARRAY\n-         || type->code () == TYPE_CODE_TYPEDEF)\n+\t || type->code () == TYPE_CODE_ARRAY\n+\t || type->code () == TYPE_CODE_TYPEDEF)\n     {\n       if (type->code () == TYPE_CODE_TYPEDEF)\n \ttype = check_typedef (type);\n@@ -1415,12 +1415,12 @@ add_symbol_overload_list_using (const char *func_name,\n \tif (current->searched)\n \t  continue;\n \n-        /* If this is a namespace alias or imported declaration ignore\n+\t/* If this is a namespace alias or imported declaration ignore\n \t   it.  */\n-        if (current->alias != NULL || current->declaration != NULL)\n-          continue;\n+\tif (current->alias != NULL || current->declaration != NULL)\n+\t  continue;\n \n-        if (strcmp (the_namespace, current->import_dest) == 0)\n+\tif (strcmp (the_namespace, current->import_dest) == 0)\n \t  {\n \t    /* Mark this import as searched so that the recursive call\n \t       does not search it again.  */\n@@ -1628,7 +1628,7 @@ gdb_demangle (const char *name, int options)\n   if (catch_demangler_crashes)\n     {\n       /* The signal handler may keep the signal blocked when we longjmp out\n-         of it.  If we have sigprocmask, we can use it to unblock the signal\n+\t of it.  If we have sigprocmask, we can use it to unblock the signal\n \t afterwards and we can avoid the performance overhead of saving the\n \t signal mask just in case the signal gets triggered.  Otherwise, just\n \t tell sigsetjmp to save the mask.  */\n@@ -1647,7 +1647,7 @@ gdb_demangle (const char *name, int options)\n   if (catch_demangler_crashes)\n     {\n       if (crash_signal != 0)\n-        {\n+\t{\n #ifdef HAVE_SIGPROCMASK\n \t  /* If we got the signal, SIGSEGV may still be blocked; restore it.  */\n \t  sigset_t segv_sig_set;\n@@ -1659,15 +1659,15 @@ gdb_demangle (const char *name, int options)\n \t  /* If there was a failure, we can't report it here, because\n \t     we might be in a background thread.  Instead, arrange for\n \t     the reporting to happen on the main thread.  */\n-          std::string copy = name;\n-          run_on_main_thread ([=] ()\n-            {\n-              report_failed_demangle (copy.c_str (), core_dump_allowed,\n-                                      crash_signal);\n-            });\n-\n-          result = NULL;\n-        }\n+\t  std::string copy = name;\n+\t  run_on_main_thread ([=] ()\n+\t    {\n+\t      report_failed_demangle (copy.c_str (), core_dump_allowed,\n+\t\t\t\t      crash_signal);\n+\t    });\n+\n+\t  result = NULL;\n+\t}\n     }\n #endif\n "
    },
    {
      "sha": "108f9413b8ca991c351710667aa7c71dbcbe1233",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -84,7 +84,7 @@ cp_is_vtbl_member (struct type *type)\n \t      || type->code () == TYPE_CODE_PTR)   /* if using thunks */\n \t    {\n \t      /* Virtual functions tables are full of pointers\n-\t         to virtual functions.  */\n+\t\t to virtual functions.  */\n \t      return cp_is_vtbl_ptr_type (type);\n \t    }\n \t}\n@@ -262,7 +262,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t      struct value *v;\n \n \t      /* Bitfields require special handling, especially due to\n-\t         byte order problems.  */\n+\t\t byte order problems.  */\n \t      if (TYPE_FIELD_IGNORE (type, i))\n \t\t{\n \t\t  fputs_styled (\"<optimized out or zero length>\",\n@@ -342,7 +342,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n       if (dont_print_statmem == 0)\n \t{\n \t  size_t obstack_final_size =\n-           obstack_object_size (&dont_print_statmem_obstack);\n+\t   obstack_object_size (&dont_print_statmem_obstack);\n \n \t  if (obstack_final_size > statmem_obstack_initial_size)\n \t    {\n@@ -400,8 +400,8 @@ cp_print_value (struct value *val, struct ui_file *stream,\n   if (dont_print_vb == 0)\n     {\n       /* If we're at top level, carve out a completely fresh chunk of\n-         the obstack and use that until this particular invocation\n-         returns.  */\n+\t the obstack and use that until this particular invocation\n+\t returns.  */\n       /* Bump up the high-water mark.  Now alpha is omega.  */\n       obstack_finish (&dont_print_vb_obstack);\n     }\n@@ -483,7 +483,7 @@ cp_print_value (struct value *val, struct ui_file *stream,\n \t}\n       fputs_filtered (\"<\", stream);\n       /* Not sure what the best notation is in the case where there is\n-         no baseclass name.  */\n+\t no baseclass name.  */\n       fputs_filtered (basename ? basename : \"\", stream);\n       fputs_filtered (\"> = \", stream);\n \n@@ -531,10 +531,10 @@ cp_print_value (struct value *val, struct ui_file *stream,\n   if (dont_print_vb == 0)\n     {\n       /* Free the space used to deal with the printing\n-         of this type from top level.  */\n+\t of this type from top level.  */\n       obstack_free (&dont_print_vb_obstack, last_dont_print);\n       /* Reset watermark so that we can continue protecting\n-         ourselves from whatever we were protecting ourselves.  */\n+\t ourselves from whatever we were protecting ourselves.  */\n       dont_print_vb_obstack = tmp_obstack;\n     }\n }"
    },
    {
      "sha": "535dc4a1fcebf6bb421272fc76aa0786e89152cd",
      "filename": "gdb/cris-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cris-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cris-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -40,7 +40,7 @@ cris_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   if (tdep->cris_version == 32)\n     /* Threaded debugging is only supported on CRISv32 for now.  */\n     set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                               svr4_fetch_objfile_link_map);\n+\t\t\t\t\t       svr4_fetch_objfile_link_map);\n \n   set_solib_svr4_fetch_link_map_offsets (gdbarch,\n \t\t\t\t\t svr4_ilp32_fetch_link_map_offsets);"
    },
    {
      "sha": "66575b76130f39313d89978c522e29d925b3e7e7",
      "filename": "gdb/cris-tdep.c",
      "status": "modified",
      "additions": 549,
      "deletions": 549,
      "changes": 1098,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cris-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/cris-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -404,7 +404,7 @@ cris_sigtramp_frame_unwind_cache (struct frame_info *this_frame,\n \n static void\n cris_sigtramp_frame_this_id (struct frame_info *this_frame, void **this_cache,\n-                             struct frame_id *this_id)\n+\t\t\t     struct frame_id *this_id)\n {\n   struct cris_unwind_cache *cache =\n     cris_sigtramp_frame_unwind_cache (this_frame, this_cache);\n@@ -417,7 +417,7 @@ static struct value *cris_frame_prev_register (struct frame_info *this_frame,\n \t\t\t\t\t       void **this_cache, int regnum);\n static struct value *\n cris_sigtramp_frame_prev_register (struct frame_info *this_frame,\n-                                   void **this_cache, int regnum)\n+\t\t\t\t   void **this_cache, int regnum)\n {\n   /* Make sure we've initialized the cache.  */\n   cris_sigtramp_frame_unwind_cache (this_frame, this_cache);\n@@ -534,9 +534,9 @@ enum cris_opcode_masks\n /* Functions for opcodes.  The general form of the ETRAX 16-bit instruction:\n    Bit 15 - 12   Operand2\n        11 - 10   Mode\n-        9 -  6   Opcode\n-        5 -  4   Size\n-        3 -  0   Operand1  */\n+\t9 -  6   Opcode\n+\t5 -  4   Size\n+\t3 -  0   Operand1  */\n \n static int \n cris_get_operand2 (unsigned short insn)\n@@ -631,7 +631,7 @@ static void cris_gdb_func (struct gdbarch *, enum cris_op_type, unsigned short,\n \t\t\t   inst_env_type *);\n \n static struct gdbarch *cris_gdbarch_init (struct gdbarch_info,\n-                                          struct gdbarch_list *);\n+\t\t\t\t\t  struct gdbarch_list *);\n \n static void cris_dump_tdep (struct gdbarch *, struct ui_file *);\n \n@@ -772,10 +772,10 @@ cris_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)\n \n static CORE_ADDR\n cris_push_dummy_code (struct gdbarch *gdbarch,\n-                      CORE_ADDR sp, CORE_ADDR funaddr,\n-                      struct value **args, int nargs,\n-                      struct type *value_type,\n-                      CORE_ADDR *real_pc, CORE_ADDR *bp_addr,\n+\t\t      CORE_ADDR sp, CORE_ADDR funaddr,\n+\t\t      struct value **args, int nargs,\n+\t\t      struct type *value_type,\n+\t\t      CORE_ADDR *real_pc, CORE_ADDR *bp_addr,\n \t\t      struct regcache *regcache)\n {\n   /* Allocate space sufficient for a breakpoint.  */\n@@ -825,40 +825,40 @@ cris_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       \n       /* How may registers worth of storage do we need for this argument?  */\n       reg_demand = (len / 4) + (len % 4 != 0 ? 1 : 0);\n-        \n+\t\n       if (len <= (2 * 4) && (argreg + reg_demand - 1 <= ARG4_REGNUM))\n-        {\n-          /* Data passed by value.  Fits in available register(s).  */\n-          for (i = 0; i < reg_demand; i++)\n-            {\n-              regcache->cooked_write (argreg, val);\n-              argreg++;\n-              val += 4;\n-            }\n-        }\n+\t{\n+\t  /* Data passed by value.  Fits in available register(s).  */\n+\t  for (i = 0; i < reg_demand; i++)\n+\t    {\n+\t      regcache->cooked_write (argreg, val);\n+\t      argreg++;\n+\t      val += 4;\n+\t    }\n+\t}\n       else if (len <= (2 * 4) && argreg <= ARG4_REGNUM)\n-        {\n-          /* Data passed by value. Does not fit in available register(s).\n-             Use the register(s) first, then the stack.  */\n-          for (i = 0; i < reg_demand; i++)\n-            {\n-              if (argreg <= ARG4_REGNUM)\n-                {\n-        \t  regcache->cooked_write (argreg, val);\n-                  argreg++;\n-                  val += 4;\n-                }\n-              else\n-                {\n+\t{\n+\t  /* Data passed by value. Does not fit in available register(s).\n+\t     Use the register(s) first, then the stack.  */\n+\t  for (i = 0; i < reg_demand; i++)\n+\t    {\n+\t      if (argreg <= ARG4_REGNUM)\n+\t\t{\n+\t\t  regcache->cooked_write (argreg, val);\n+\t\t  argreg++;\n+\t\t  val += 4;\n+\t\t}\n+\t      else\n+\t\t{\n \t\t  /* Push item for later so that pushed arguments\n \t\t     come in the right order.  */\n \t\t  si = push_stack_item (si, val, 4);\n-                  val += 4;\n-                }\n-            }\n-        }\n+\t\t  val += 4;\n+\t\t}\n+\t    }\n+\t}\n       else if (len > (2 * 4))\n-        {\n+\t{\n \t  /* Data passed by reference.  Push copy of data onto stack\n \t     and pass pointer to this copy as argument.  */\n \t  sp = (sp - len) & ~3;\n@@ -875,13 +875,13 @@ cris_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      store_unsigned_integer (buf, 4, byte_order, sp);\n \t      si = push_stack_item (si, buf, 4);\n \t    }\n-        }\n+\t}\n       else\n-        {\n-          /* Data passed by value.  No available registers.  Put it on\n-             the stack.  */\n+\t{\n+\t  /* Data passed by value.  No available registers.  Put it on\n+\t     the stack.  */\n \t   si = push_stack_item (si, val, len);\n-        }\n+\t}\n     }\n \n   while (si)\n@@ -1049,165 +1049,165 @@ cris_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n       insn = read_memory_unsigned_integer (pc, 2, byte_order);\n       pc += 2;\n       if (insn == 0xE1FC)\n-        {\n-          /* push <reg> 32 bit instruction.  */\n-          insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n-          pc += 2;\n-          regno = cris_get_operand2 (insn_next);\n+\t{\n+\t  /* push <reg> 32 bit instruction.  */\n+\t  insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n+\t  pc += 2;\n+\t  regno = cris_get_operand2 (insn_next);\n \t  if (info)\n \t    {\n \t      info->sp_offset += 4;\n \t    }\n-          /* This check, meant to recognize srp, used to be regno == \n-             (SRP_REGNUM - NUM_GENREGS), but that covers r11 also.  */\n-          if (insn_next == 0xBE7E)\n-            {\n+\t  /* This check, meant to recognize srp, used to be regno == \n+\t     (SRP_REGNUM - NUM_GENREGS), but that covers r11 also.  */\n+\t  if (insn_next == 0xBE7E)\n+\t    {\n \t      if (info)\n \t\t{\n \t\t  info->leaf_function = 0;\n \t\t}\n-            }\n+\t    }\n \t  else if (insn_next == 0x8FEE)\n-            {\n+\t    {\n \t      /* push $r8 */\n \t      if (info)\n \t\t{\n \t\t  info->r8_offset = info->sp_offset;\n \t\t}\n-            }\n-        }\n+\t    }\n+\t}\n       else if (insn == 0x866E)\n-        {\n-          /* move.d sp,r8 */\n+\t{\n+\t  /* move.d sp,r8 */\n \t  if (info)\n \t    {\n \t      info->uses_frame = 1;\n \t    }\n-          continue;\n-        }\n+\t  continue;\n+\t}\n       else if (cris_get_operand2 (insn) == gdbarch_sp_regnum (gdbarch)\n-               && cris_get_mode (insn) == 0x0000\n-               && cris_get_opcode (insn) == 0x000A)\n-        {\n-          /* subq <val>,sp */\n+\t       && cris_get_mode (insn) == 0x0000\n+\t       && cris_get_opcode (insn) == 0x000A)\n+\t{\n+\t  /* subq <val>,sp */\n \t  if (info)\n \t    {\n \t      info->sp_offset += cris_get_quick_value (insn);\n \t    }\n-        }\n+\t}\n       else if (cris_get_mode (insn) == 0x0002 \n-               && cris_get_opcode (insn) == 0x000F\n-               && cris_get_size (insn) == 0x0003\n-               && cris_get_operand1 (insn) == gdbarch_sp_regnum (gdbarch))\n-        {\n-          /* movem r<regsave>,[sp] */\n-          regsave = cris_get_operand2 (insn);\n-        }\n+\t       && cris_get_opcode (insn) == 0x000F\n+\t       && cris_get_size (insn) == 0x0003\n+\t       && cris_get_operand1 (insn) == gdbarch_sp_regnum (gdbarch))\n+\t{\n+\t  /* movem r<regsave>,[sp] */\n+\t  regsave = cris_get_operand2 (insn);\n+\t}\n       else if (cris_get_operand2 (insn) == gdbarch_sp_regnum (gdbarch)\n-               && ((insn & 0x0F00) >> 8) == 0x0001\n-               && (cris_get_signed_offset (insn) < 0))\n-        {\n-          /* Immediate byte offset addressing prefix word with sp as base \n-             register.  Used for CRIS v8 i.e. ETRAX 100 and newer if <val> \n-             is between 64 and 128. \n-             movem r<regsave>,[sp=sp-<val>] */\n+\t       && ((insn & 0x0F00) >> 8) == 0x0001\n+\t       && (cris_get_signed_offset (insn) < 0))\n+\t{\n+\t  /* Immediate byte offset addressing prefix word with sp as base \n+\t     register.  Used for CRIS v8 i.e. ETRAX 100 and newer if <val> \n+\t     is between 64 and 128. \n+\t     movem r<regsave>,[sp=sp-<val>] */\n \t  if (info)\n \t    {\n \t      info->sp_offset += -cris_get_signed_offset (insn);\n \t    }\n \t  insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n-          pc += 2;\n-          if (cris_get_mode (insn_next) == PREFIX_ASSIGN_MODE\n-              && cris_get_opcode (insn_next) == 0x000F\n-              && cris_get_size (insn_next) == 0x0003\n-              && cris_get_operand1 (insn_next) == gdbarch_sp_regnum\n+\t  pc += 2;\n+\t  if (cris_get_mode (insn_next) == PREFIX_ASSIGN_MODE\n+\t      && cris_get_opcode (insn_next) == 0x000F\n+\t      && cris_get_size (insn_next) == 0x0003\n+\t      && cris_get_operand1 (insn_next) == gdbarch_sp_regnum\n \t\t\t\t\t\t  (gdbarch))\n-            {\n-              regsave = cris_get_operand2 (insn_next);\n-            }\n-          else\n-            {\n-              /* The prologue ended before the limit was reached.  */\n-              pc -= 4;\n-              break;\n-            }\n-        }\n+\t    {\n+\t      regsave = cris_get_operand2 (insn_next);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The prologue ended before the limit was reached.  */\n+\t      pc -= 4;\n+\t      break;\n+\t    }\n+\t}\n       else if (cris_get_mode (insn) == 0x0001\n-               && cris_get_opcode (insn) == 0x0009\n-               && cris_get_size (insn) == 0x0002)\n-        {\n-          /* move.d r<10..13>,r<0..15> */\n-          source_register = cris_get_operand1 (insn);\n-\n-          /* FIXME?  In the glibc solibs, the prologue might contain something\n-             like (this example taken from relocate_doit):\n-             move.d $pc,$r0\n-             sub.d 0xfffef426,$r0\n-             which isn't covered by the source_register check below.  Question\n-             is whether to add a check for this combo, or make better use of\n-             the limit variable instead.  */\n-          if (source_register < ARG1_REGNUM || source_register > ARG4_REGNUM)\n-            {\n-              /* The prologue ended before the limit was reached.  */\n-              pc -= 2;\n-              break;\n-            }\n-        }\n+\t       && cris_get_opcode (insn) == 0x0009\n+\t       && cris_get_size (insn) == 0x0002)\n+\t{\n+\t  /* move.d r<10..13>,r<0..15> */\n+\t  source_register = cris_get_operand1 (insn);\n+\n+\t  /* FIXME?  In the glibc solibs, the prologue might contain something\n+\t     like (this example taken from relocate_doit):\n+\t     move.d $pc,$r0\n+\t     sub.d 0xfffef426,$r0\n+\t     which isn't covered by the source_register check below.  Question\n+\t     is whether to add a check for this combo, or make better use of\n+\t     the limit variable instead.  */\n+\t  if (source_register < ARG1_REGNUM || source_register > ARG4_REGNUM)\n+\t    {\n+\t      /* The prologue ended before the limit was reached.  */\n+\t      pc -= 2;\n+\t      break;\n+\t    }\n+\t}\n       else if (cris_get_operand2 (insn) == CRIS_FP_REGNUM \n-               /* The size is a fixed-size.  */\n-               && ((insn & 0x0F00) >> 8) == 0x0001 \n-               /* A negative offset.  */\n-               && (cris_get_signed_offset (insn) < 0))  \n-        {\n-          /* move.S rZ,[r8-U] (?) */\n-          insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n-          pc += 2;\n-          regno = cris_get_operand2 (insn_next);\n-          if ((regno >= 0 && regno < gdbarch_sp_regnum (gdbarch))\n-              && cris_get_mode (insn_next) == PREFIX_OFFSET_MODE\n-              && cris_get_opcode (insn_next) == 0x000F)\n-            {\n-              /* move.S rZ,[r8-U] */\n-              continue;\n-            }\n-          else\n-            {\n-              /* The prologue ended before the limit was reached.  */\n-              pc -= 4;\n-              break;\n-            }\n-        }\n+\t       /* The size is a fixed-size.  */\n+\t       && ((insn & 0x0F00) >> 8) == 0x0001 \n+\t       /* A negative offset.  */\n+\t       && (cris_get_signed_offset (insn) < 0))  \n+\t{\n+\t  /* move.S rZ,[r8-U] (?) */\n+\t  insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n+\t  pc += 2;\n+\t  regno = cris_get_operand2 (insn_next);\n+\t  if ((regno >= 0 && regno < gdbarch_sp_regnum (gdbarch))\n+\t      && cris_get_mode (insn_next) == PREFIX_OFFSET_MODE\n+\t      && cris_get_opcode (insn_next) == 0x000F)\n+\t    {\n+\t      /* move.S rZ,[r8-U] */\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The prologue ended before the limit was reached.  */\n+\t      pc -= 4;\n+\t      break;\n+\t    }\n+\t}\n       else if (cris_get_operand2 (insn) == CRIS_FP_REGNUM \n-               /* The size is a fixed-size.  */\n-               && ((insn & 0x0F00) >> 8) == 0x0001 \n-               /* A positive offset.  */\n-               && (cris_get_signed_offset (insn) > 0))  \n-        {\n-          /* move.S [r8+U],rZ (?) */\n+\t       /* The size is a fixed-size.  */\n+\t       && ((insn & 0x0F00) >> 8) == 0x0001 \n+\t       /* A positive offset.  */\n+\t       && (cris_get_signed_offset (insn) > 0))  \n+\t{\n+\t  /* move.S [r8+U],rZ (?) */\n \t  insn_next = read_memory_unsigned_integer (pc, 2, byte_order);\n-          pc += 2;\n-          regno = cris_get_operand2 (insn_next);\n-          if ((regno >= 0 && regno < gdbarch_sp_regnum (gdbarch))\n-              && cris_get_mode (insn_next) == PREFIX_OFFSET_MODE\n-              && cris_get_opcode (insn_next) == 0x0009\n-              && cris_get_operand1 (insn_next) == regno)\n-            {\n-              /* move.S [r8+U],rZ */\n-              continue;\n-            }\n-          else\n-            {\n-              /* The prologue ended before the limit was reached.  */\n-              pc -= 4;\n-              break;\n-            }\n-        }\n+\t  pc += 2;\n+\t  regno = cris_get_operand2 (insn_next);\n+\t  if ((regno >= 0 && regno < gdbarch_sp_regnum (gdbarch))\n+\t      && cris_get_mode (insn_next) == PREFIX_OFFSET_MODE\n+\t      && cris_get_opcode (insn_next) == 0x0009\n+\t      && cris_get_operand1 (insn_next) == regno)\n+\t    {\n+\t      /* move.S [r8+U],rZ */\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* The prologue ended before the limit was reached.  */\n+\t      pc -= 4;\n+\t      break;\n+\t    }\n+\t}\n       else\n-        {\n-          /* The prologue ended before the limit was reached.  */\n-          pc -= 2;\n-          break;\n-        }\n+\t{\n+\t  /* The prologue ended before the limit was reached.  */\n+\t  pc -= 2;\n+\t  break;\n+\t}\n     }\n \n   /* We only want to know the end of the prologue when this_frame and info\n@@ -1225,21 +1225,21 @@ cris_scan_prologue (CORE_ADDR pc, struct frame_info *this_frame,\n     {\n       ULONGEST this_base;\n       /* The SP was moved to the FP.  This indicates that a new frame\n-         was created.  Get THIS frame's FP value by unwinding it from\n-         the next frame.  */\n+\t was created.  Get THIS frame's FP value by unwinding it from\n+\t the next frame.  */\n       this_base = get_frame_register_unsigned (this_frame, CRIS_FP_REGNUM);\n       info->base = this_base;\n       info->saved_regs[CRIS_FP_REGNUM].addr = info->base;\n   \n       /* The FP points at the last saved register.  Adjust the FP back\n-         to before the first saved register giving the SP.  */\n+\t to before the first saved register giving the SP.  */\n       info->prev_sp = info->base + info->r8_offset;\n     }\n   else\n     {\n       ULONGEST this_base;      \n       /* Assume that the FP is this frame's SP but with that pushed\n-         stack space added back.  */\n+\t stack space added back.  */\n       this_base = get_frame_register_unsigned (this_frame,\n \t\t\t\t\t       gdbarch_sp_regnum (gdbarch));\n       info->base = this_base;\n@@ -1440,16 +1440,16 @@ cris_register_size (struct gdbarch *gdbarch, int regno)\n   else if (regno >= NUM_GENREGS && regno < (NUM_GENREGS + NUM_SPECREGS))\n     {\n       /* Special register (R16 - R31).  cris_spec_regs is zero-based. \n-         Adjust regno accordingly.  */\n+\t Adjust regno accordingly.  */\n       spec_regno = regno - NUM_GENREGS;\n       \n       for (i = 0; cris_spec_regs[i].name != NULL; i++)\n-        {\n-          if (cris_spec_regs[i].number == spec_regno \n-              && cris_spec_reg_applicable (gdbarch, cris_spec_regs[i]))\n-            /* Go with the first applicable register.  */\n-            return cris_spec_regs[i].reg_size;\n-        }\n+\t{\n+\t  if (cris_spec_regs[i].number == spec_regno \n+\t      && cris_spec_reg_applicable (gdbarch, cris_spec_regs[i]))\n+\t    /* Go with the first applicable register.  */\n+\t    return cris_spec_regs[i].reg_size;\n+\t}\n       /* Special register not applicable to this CRIS version.  */\n       return 0;\n     }\n@@ -1472,7 +1472,7 @@ static int\n cris_cannot_fetch_register (struct gdbarch *gdbarch, int regno)\n {\n   return ((regno < 0 || regno >= gdbarch_num_regs (gdbarch))\n-          || (cris_register_size (gdbarch, regno) == 0));\n+\t  || (cris_register_size (gdbarch, regno) == 0));\n }\n \n /* Nonzero if regno should not be written to the target, for various \n@@ -1513,7 +1513,7 @@ static int\n crisv32_cannot_fetch_register (struct gdbarch *gdbarch, int regno)\n {\n   return ((regno < 0 || regno >= gdbarch_num_regs (gdbarch))\n-          || (cris_register_size (gdbarch, regno) == 0));\n+\t  || (cris_register_size (gdbarch, regno) == 0));\n }\n \n /* Nonzero if regno should not be written to the target, for various \n@@ -1753,7 +1753,7 @@ cris_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n \n static void\n cris_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n-                            struct dwarf2_frame_state_reg *reg,\n+\t\t\t    struct dwarf2_frame_state_reg *reg,\n \t\t\t    struct frame_info *this_frame)\n {\n   /* The return address column.  */\n@@ -1825,7 +1825,7 @@ cris_return_value (struct gdbarch *gdbarch, struct value *function,\n \n static int\n constraint (unsigned int insn, const char *inst_args,\n-            inst_env_type *inst_env)\n+\t    inst_env_type *inst_env)\n {\n   int retval = 0;\n   int tmp, i;\n@@ -1836,61 +1836,61 @@ constraint (unsigned int insn, const char *inst_args,\n     switch (*s) \n       {\n       case 'm':\n-        if ((insn & 0x30) == 0x30)\n-          return -1;\n-        break;\n-        \n+\tif ((insn & 0x30) == 0x30)\n+\t  return -1;\n+\tbreak;\n+\t\n       case 'S':\n-        /* A prefix operand.  */\n-        if (inst_env->prefix_found)\n-          break;\n-        else\n-          return -1;\n+\t/* A prefix operand.  */\n+\tif (inst_env->prefix_found)\n+\t  break;\n+\telse\n+\t  return -1;\n \n       case 'B':\n-        /* A \"push\" prefix.  (This check was REMOVED by san 970921.)  Check for\n-           valid \"push\" size.  In case of special register, it may be != 4.  */\n-        if (inst_env->prefix_found)\n-          break;\n-        else\n-          return -1;\n+\t/* A \"push\" prefix.  (This check was REMOVED by san 970921.)  Check for\n+\t   valid \"push\" size.  In case of special register, it may be != 4.  */\n+\tif (inst_env->prefix_found)\n+\t  break;\n+\telse\n+\t  return -1;\n \n       case 'D':\n-        retval = (((insn >> 0xC) & 0xF) == (insn & 0xF));\n-        if (!retval)\n-          return -1;\n-        else \n-          retval += 4;\n-        break;\n+\tretval = (((insn >> 0xC) & 0xF) == (insn & 0xF));\n+\tif (!retval)\n+\t  return -1;\n+\telse \n+\t  retval += 4;\n+\tbreak;\n \n       case 'P':\n-        tmp = (insn >> 0xC) & 0xF;\n-\n-        for (i = 0; cris_spec_regs[i].name != NULL; i++)\n-          {\n-            /* Since we match four bits, we will give a value of\n-               4 - 1 = 3 in a match.  If there is a corresponding\n-               exact match of a special register in another pattern, it\n-               will get a value of 4, which will be higher.  This should\n-               be correct in that an exact pattern would match better that\n-               a general pattern.\n-               Note that there is a reason for not returning zero; the\n-               pattern for \"clear\" is partly  matched in the bit-pattern\n-               (the two lower bits must be zero), while the bit-pattern\n-               for a move from a special register is matched in the\n-               register constraint.\n-               This also means we will will have a race condition if\n-               there is a partly match in three bits in the bit pattern.  */\n-            if (tmp == cris_spec_regs[i].number)\n-              {\n-                retval += 3;\n-                break;\n-              }\n-          }\n-        \n-        if (cris_spec_regs[i].name == NULL)\n-          return -1;\n-        break;\n+\ttmp = (insn >> 0xC) & 0xF;\n+\n+\tfor (i = 0; cris_spec_regs[i].name != NULL; i++)\n+\t  {\n+\t    /* Since we match four bits, we will give a value of\n+\t       4 - 1 = 3 in a match.  If there is a corresponding\n+\t       exact match of a special register in another pattern, it\n+\t       will get a value of 4, which will be higher.  This should\n+\t       be correct in that an exact pattern would match better that\n+\t       a general pattern.\n+\t       Note that there is a reason for not returning zero; the\n+\t       pattern for \"clear\" is partly  matched in the bit-pattern\n+\t       (the two lower bits must be zero), while the bit-pattern\n+\t       for a move from a special register is matched in the\n+\t       register constraint.\n+\t       This also means we will will have a race condition if\n+\t       there is a partly match in three bits in the bit pattern.  */\n+\t    if (tmp == cris_spec_regs[i].number)\n+\t      {\n+\t\tretval += 3;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t\n+\tif (cris_spec_regs[i].name == NULL)\n+\t  return -1;\n+\tbreak;\n       }\n   return retval;\n }\n@@ -1924,27 +1924,27 @@ find_cris_op (unsigned short insn, inst_env_type *inst_env)\n   for (i = 0; cris_opcodes[i].name != NULL; i++)\n     {\n       if (((cris_opcodes[i].match & insn) == cris_opcodes[i].match) \n-          && ((cris_opcodes[i].lose & insn) == 0)\n+\t  && ((cris_opcodes[i].lose & insn) == 0)\n \t  /* Only CRISv10 instructions, please.  */\n \t  && (cris_opcodes[i].applicable_version != cris_ver_v32p))\n-        {\n-          level_of_match = constraint (insn, cris_opcodes[i].args, inst_env);\n-          if (level_of_match >= 0)\n-            {\n-              level_of_match +=\n-                number_of_bits (cris_opcodes[i].match | cris_opcodes[i].lose);\n-              if (level_of_match > max_level_of_match)\n-                {\n-                  max_matched = i;\n-                  max_level_of_match = level_of_match;\n-                  if (level_of_match == 16)\n-                    {\n-                      /* All bits matched, cannot find better.  */\n-                      break;\n-                    }\n-                }\n-            }\n-        }\n+\t{\n+\t  level_of_match = constraint (insn, cris_opcodes[i].args, inst_env);\n+\t  if (level_of_match >= 0)\n+\t    {\n+\t      level_of_match +=\n+\t\tnumber_of_bits (cris_opcodes[i].match | cris_opcodes[i].lose);\n+\t      if (level_of_match > max_level_of_match)\n+\t\t{\n+\t\t  max_matched = i;\n+\t\t  max_level_of_match = level_of_match;\n+\t\t  if (level_of_match == 16)\n+\t\t    {\n+\t\t      /* All bits matched, cannot find better.  */\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n   return max_matched;\n }\n@@ -1990,33 +1990,33 @@ find_step_target (struct regcache *regcache, inst_env_type *inst_env)\n \t     (inst_env->reg[gdbarch_pc_regnum (gdbarch)], 2, byte_order);\n \n       /* If the instruction is not in a delay slot the new content of the\n-         PC is [PC] + 2.  If the instruction is in a delay slot it is not\n-         that simple.  Since a instruction in a delay slot cannot change \n-         the content of the PC, it does not matter what value PC will have. \n-         Just make sure it is a valid instruction.  */\n+\t PC is [PC] + 2.  If the instruction is in a delay slot it is not\n+\t that simple.  Since a instruction in a delay slot cannot change \n+\t the content of the PC, it does not matter what value PC will have. \n+\t Just make sure it is a valid instruction.  */\n       if (!inst_env->delay_slot_pc_active)\n-        {\n-          inst_env->reg[gdbarch_pc_regnum (gdbarch)] += 2;\n-        }\n+\t{\n+\t  inst_env->reg[gdbarch_pc_regnum (gdbarch)] += 2;\n+\t}\n       else\n-        {\n-          inst_env->delay_slot_pc_active = 0;\n-          inst_env->reg[gdbarch_pc_regnum (gdbarch)]\n+\t{\n+\t  inst_env->delay_slot_pc_active = 0;\n+\t  inst_env->reg[gdbarch_pc_regnum (gdbarch)]\n \t    = inst_env->delay_slot_pc;\n-        }\n+\t}\n       /* Analyse the present instruction.  */\n       i = find_cris_op (insn, inst_env);\n       if (i == -1)\n-        {\n-          inst_env->invalid = 1;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t}\n       else\n-        {\n-          cris_gdb_func (gdbarch, cris_opcodes[i].op, insn, inst_env);\n-        }\n+\t{\n+\t  cris_gdb_func (gdbarch, cris_opcodes[i].op, insn, inst_env);\n+\t}\n     } while (!inst_env->invalid \n-             && (inst_env->prefix_found || inst_env->xflag_found \n-                 || inst_env->slot_needed));\n+\t     && (inst_env->prefix_found || inst_env->xflag_found \n+\t\t || inst_env->slot_needed));\n   return i;\n }\n \n@@ -2043,7 +2043,7 @@ cris_software_single_step (struct regcache *regcache)\n   else\n     {\n       /* Insert at most two breakpoints.  One for the next PC content\n-         and possibly another one for a branch, jump, etc.  */\n+\t and possibly another one for a branch, jump, etc.  */\n       CORE_ADDR next_pc\n \t= (CORE_ADDR) inst_env.reg[gdbarch_pc_regnum (gdbarch)];\n \n@@ -2095,11 +2095,11 @@ process_autoincrement (int size, unsigned short inst, inst_env_type *inst_env)\n       inst_env->reg[cris_get_operand1 (inst)] += 1;\n \n       /* The PC must be word aligned, so increase the PC with one\n-         word even if the size is byte.  */\n+\t word even if the size is byte.  */\n       if (cris_get_operand1 (inst) == REG_PC)\n-        {\n-          inst_env->reg[REG_PC] += 1;\n-        }\n+\t{\n+\t  inst_env->reg[REG_PC] += 1;\n+\t}\n     }\n   else if (size == INST_WORD_SIZE)\n     {\n@@ -2316,19 +2316,19 @@ abs_op (unsigned short inst, inst_env_type *inst_env)\n     \n       /* It's invalid to change to the PC if we are in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n \n       value = (long) inst_env->reg[REG_PC];\n \n       /* The value of abs (SIGNED_DWORD_MASK) is SIGNED_DWORD_MASK.  */\n       if (value != SIGNED_DWORD_MASK)\n-        {\n-          value = -value;\n-          inst_env->reg[REG_PC] = (long) value;\n-        }\n+\t{\n+\t  value = -value;\n+\t  inst_env->reg[REG_PC] = (long) value;\n+\t}\n     }\n \n   inst_env->slot_needed = 0;\n@@ -2377,56 +2377,56 @@ asr_op (unsigned short inst, inst_env_type *inst_env)\n     {\n       /* It's invalid to change the PC in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       /* Get the number of bits to shift.  */\n       shift_steps\n \t= cris_get_asr_shift_steps (inst_env->reg[cris_get_operand1 (inst)]);\n       value = inst_env->reg[REG_PC];\n \n       /* Find out how many bits the operation should apply to.  */\n       if (cris_get_size (inst) == INST_BYTE_SIZE)\n-        {\n-          if (value & SIGNED_BYTE_MASK)\n-            {\n-              signed_extend_mask = 0xFF;\n-              signed_extend_mask = signed_extend_mask >> shift_steps;\n-              signed_extend_mask = ~signed_extend_mask;\n-            }\n-          value = value >> shift_steps;\n-          value |= signed_extend_mask;\n-          value &= 0xFF;\n-          inst_env->reg[REG_PC] &= 0xFFFFFF00;\n-          inst_env->reg[REG_PC] |= value;\n-        }\n+\t{\n+\t  if (value & SIGNED_BYTE_MASK)\n+\t    {\n+\t      signed_extend_mask = 0xFF;\n+\t      signed_extend_mask = signed_extend_mask >> shift_steps;\n+\t      signed_extend_mask = ~signed_extend_mask;\n+\t    }\n+\t  value = value >> shift_steps;\n+\t  value |= signed_extend_mask;\n+\t  value &= 0xFF;\n+\t  inst_env->reg[REG_PC] &= 0xFFFFFF00;\n+\t  inst_env->reg[REG_PC] |= value;\n+\t}\n       else if (cris_get_size (inst) == INST_WORD_SIZE)\n-        {\n-          if (value & SIGNED_WORD_MASK)\n-            {\n-              signed_extend_mask = 0xFFFF;\n-              signed_extend_mask = signed_extend_mask >> shift_steps;\n-              signed_extend_mask = ~signed_extend_mask;\n-            }\n-          value = value >> shift_steps;\n-          value |= signed_extend_mask;\n-          value &= 0xFFFF;\n-          inst_env->reg[REG_PC] &= 0xFFFF0000;\n-          inst_env->reg[REG_PC] |= value;\n-        }\n+\t{\n+\t  if (value & SIGNED_WORD_MASK)\n+\t    {\n+\t      signed_extend_mask = 0xFFFF;\n+\t      signed_extend_mask = signed_extend_mask >> shift_steps;\n+\t      signed_extend_mask = ~signed_extend_mask;\n+\t    }\n+\t  value = value >> shift_steps;\n+\t  value |= signed_extend_mask;\n+\t  value &= 0xFFFF;\n+\t  inst_env->reg[REG_PC] &= 0xFFFF0000;\n+\t  inst_env->reg[REG_PC] |= value;\n+\t}\n       else if (cris_get_size (inst) == INST_DWORD_SIZE)\n-        {\n-          if (value & SIGNED_DWORD_MASK)\n-            {\n-              signed_extend_mask = 0xFFFFFFFF;\n-              signed_extend_mask = signed_extend_mask >> shift_steps;\n-              signed_extend_mask = ~signed_extend_mask;\n-            }\n-          value = value >> shift_steps;\n-          value |= signed_extend_mask;\n-          inst_env->reg[REG_PC]  = value;\n-        }\n+\t{\n+\t  if (value & SIGNED_DWORD_MASK)\n+\t    {\n+\t      signed_extend_mask = 0xFFFFFFFF;\n+\t      signed_extend_mask = signed_extend_mask >> shift_steps;\n+\t      signed_extend_mask = ~signed_extend_mask;\n+\t    }\n+\t  value = value >> shift_steps;\n+\t  value |= signed_extend_mask;\n+\t  inst_env->reg[REG_PC]  = value;\n+\t}\n     }\n   inst_env->slot_needed = 0;\n   inst_env->prefix_found = 0;\n@@ -2457,20 +2457,20 @@ asrq_op (unsigned short inst, inst_env_type *inst_env)\n \n       /* It's invalid to change the PC in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       /* The shift size is given as a 5 bit quick value, i.e. we don't\n-         want the sign bit of the quick value.  */\n+\t want the sign bit of the quick value.  */\n       shift_steps = cris_get_asr_shift_steps (inst);\n       value = inst_env->reg[REG_PC];\n       if (value & SIGNED_DWORD_MASK)\n-        {\n-          signed_extend_mask = 0xFFFFFFFF;\n-          signed_extend_mask = signed_extend_mask >> shift_steps;\n-          signed_extend_mask = ~signed_extend_mask;\n-        }\n+\t{\n+\t  signed_extend_mask = 0xFFFFFFFF;\n+\t  signed_extend_mask = signed_extend_mask >> shift_steps;\n+\t  signed_extend_mask = ~signed_extend_mask;\n+\t}\n       value = value >> shift_steps;\n       value |= signed_extend_mask;\n       inst_env->reg[REG_PC]  = value;\n@@ -2541,10 +2541,10 @@ two_operand_bound_op (unsigned short inst, inst_env_type *inst_env)\n     {\n       /* It's invalid to change the PC in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       process_autoincrement (cris_get_size (inst), inst, inst_env);\n     }\n   inst_env->slot_needed = 0;\n@@ -2618,19 +2618,19 @@ reg_mode_clear_op (unsigned short inst, inst_env_type *inst_env)\n       /* The instruction will clear the instruction's size bits.  */\n       int clear_size = cris_get_clear_size (inst);\n       if (clear_size == INST_BYTE_SIZE)\n-        {\n-          inst_env->delay_slot_pc = inst_env->reg[REG_PC] & 0xFFFFFF00;\n-        }\n+\t{\n+\t  inst_env->delay_slot_pc = inst_env->reg[REG_PC] & 0xFFFFFF00;\n+\t}\n       if (clear_size == INST_WORD_SIZE)\n-        {\n-          inst_env->delay_slot_pc = inst_env->reg[REG_PC] & 0xFFFF0000;\n-        }\n+\t{\n+\t  inst_env->delay_slot_pc = inst_env->reg[REG_PC] & 0xFFFF0000;\n+\t}\n       if (clear_size == INST_DWORD_SIZE)\n-        {\n-          inst_env->delay_slot_pc = 0x0;\n-        }\n+\t{\n+\t  inst_env->delay_slot_pc = 0x0;\n+\t}\n       /* The jump will be delayed with one delay slot.  So we need a delay \n-         slot.  */\n+\t slot.  */\n       inst_env->slot_needed = 1;\n       inst_env->delay_slot_pc_active = 1;\n     }\n@@ -2672,7 +2672,7 @@ none_reg_mode_clear_test_op (unsigned short inst, inst_env_type *inst_env)\n   if (inst_env->prefix_found)\n     {\n       /* The only way the PC can change is if this instruction is in\n-         assign addressing mode.  */\n+\t assign addressing mode.  */\n       check_assign (inst, inst_env);\n     }\n   /* Indirect mode can't change the PC so just check if the mode is\n@@ -2783,27 +2783,27 @@ none_reg_mode_jump_op (unsigned short inst, inst_env_type *inst_env)\n     {\n       /* Check if we have a prefix.  */\n       if (inst_env->prefix_found)\n-        {\n-          check_assign (inst, inst_env);\n-\n-          /* Get the new value for the PC.  */\n-          newpc = \n-            read_memory_unsigned_integer ((CORE_ADDR) inst_env->prefix_value,\n-                                          4, inst_env->byte_order);\n-        }\n+\t{\n+\t  check_assign (inst, inst_env);\n+\n+\t  /* Get the new value for the PC.  */\n+\t  newpc = \n+\t    read_memory_unsigned_integer ((CORE_ADDR) inst_env->prefix_value,\n+\t\t\t\t\t  4, inst_env->byte_order);\n+\t}\n       else\n-        {\n-          /* Get the new value for the PC.  */\n-          address = (CORE_ADDR) inst_env->reg[cris_get_operand1 (inst)];\n-          newpc = read_memory_unsigned_integer (address,\n+\t{\n+\t  /* Get the new value for the PC.  */\n+\t  address = (CORE_ADDR) inst_env->reg[cris_get_operand1 (inst)];\n+\t  newpc = read_memory_unsigned_integer (address,\n \t\t\t\t\t\t4, inst_env->byte_order);\n \n-          /* Check if we should increment a register.  */\n-          if (cris_get_mode (inst) == AUTOINC_MODE)\n-            {\n-              inst_env->reg[cris_get_operand1 (inst)] += 4;\n-            }\n-        }\n+\t  /* Check if we should increment a register.  */\n+\t  if (cris_get_mode (inst) == AUTOINC_MODE)\n+\t    {\n+\t      inst_env->reg[cris_get_operand1 (inst)] += 4;\n+\t    }\n+\t}\n       inst_env->reg[REG_PC] = newpc;\n     }\n   inst_env->slot_needed = 0;\n@@ -2821,45 +2821,45 @@ move_to_preg_op (struct gdbarch *gdbarch, unsigned short inst,\n   if (inst_env->prefix_found)\n     {\n       /* The instruction has a prefix that means we are only interested if\n-         the instruction is in assign mode.  */\n+\t the instruction is in assign mode.  */\n       if (cris_get_mode (inst) == PREFIX_ASSIGN_MODE)\n-        {\n-          /* The prefix handles the problem if we are in a delay slot.  */\n-          if (cris_get_operand1 (inst) == REG_PC)\n-            {\n-              /* Just take care of the assign.  */\n-              check_assign (inst, inst_env);\n-            }\n-        }\n+\t{\n+\t  /* The prefix handles the problem if we are in a delay slot.  */\n+\t  if (cris_get_operand1 (inst) == REG_PC)\n+\t    {\n+\t      /* Just take care of the assign.  */\n+\t      check_assign (inst, inst_env);\n+\t    }\n+\t}\n     }\n   else if (cris_get_mode (inst) == AUTOINC_MODE)\n     {\n       /* The instruction doesn't have a prefix, the only case left that we\n-         are interested in is the autoincrement mode.  */\n+\t are interested in is the autoincrement mode.  */\n       if (cris_get_operand1 (inst) == REG_PC)\n-        {\n-          /* If the PC is to be incremented it's invalid to be in a \n-             delay slot.  */\n-          if (inst_env->slot_needed)\n-            {\n-              inst_env->invalid = 1;\n-              return;\n-            }\n-\n-          /* The increment depends on the size of the special register.  */\n-          if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 1)\n-            {\n-              process_autoincrement (INST_BYTE_SIZE, inst, inst_env);\n-            }\n-          else if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 2)\n-            {\n-              process_autoincrement (INST_WORD_SIZE, inst, inst_env);\n-            }\n-          else\n-            {\n-              process_autoincrement (INST_DWORD_SIZE, inst, inst_env);\n-            }\n-        }\n+\t{\n+\t  /* If the PC is to be incremented it's invalid to be in a \n+\t     delay slot.  */\n+\t  if (inst_env->slot_needed)\n+\t    {\n+\t      inst_env->invalid = 1;\n+\t      return;\n+\t    }\n+\n+\t  /* The increment depends on the size of the special register.  */\n+\t  if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 1)\n+\t    {\n+\t      process_autoincrement (INST_BYTE_SIZE, inst, inst_env);\n+\t    }\n+\t  else if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 2)\n+\t    {\n+\t      process_autoincrement (INST_WORD_SIZE, inst, inst_env);\n+\t    }\n+\t  else\n+\t    {\n+\t      process_autoincrement (INST_DWORD_SIZE, inst, inst_env);\n+\t    }\n+\t}\n     }\n   inst_env->slot_needed = 0;\n   inst_env->prefix_found = 0;\n@@ -2877,45 +2877,45 @@ none_reg_mode_move_from_preg_op (struct gdbarch *gdbarch, unsigned short inst,\n   if (inst_env->prefix_found)\n     {\n       /* The instruction has a prefix that means we are only interested if\n-         the instruction is in assign mode.  */\n+\t the instruction is in assign mode.  */\n       if (cris_get_mode (inst) == PREFIX_ASSIGN_MODE)\n-        {\n-          /* The prefix handles the problem if we are in a delay slot.  */\n-          if (cris_get_operand1 (inst) == REG_PC)\n-            {\n-              /* Just take care of the assign.  */\n-              check_assign (inst, inst_env);\n-            }\n-        }\n+\t{\n+\t  /* The prefix handles the problem if we are in a delay slot.  */\n+\t  if (cris_get_operand1 (inst) == REG_PC)\n+\t    {\n+\t      /* Just take care of the assign.  */\n+\t      check_assign (inst, inst_env);\n+\t    }\n+\t}\n     }    \n   /* The instruction doesn't have a prefix, the only case left that we\n      are interested in is the autoincrement mode.  */\n   else if (cris_get_mode (inst) == AUTOINC_MODE)\n     {\n       if (cris_get_operand1 (inst) == REG_PC)\n-        {\n-          /* If the PC is to be incremented it's invalid to be in a \n-             delay slot.  */\n-          if (inst_env->slot_needed)\n-            {\n-              inst_env->invalid = 1;\n-              return;\n-            }\n-          \n-          /* The increment depends on the size of the special register.  */\n-          if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 1)\n-            {\n-              process_autoincrement (INST_BYTE_SIZE, inst, inst_env);\n-            }\n-          else if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 2)\n-            {\n-              process_autoincrement (INST_WORD_SIZE, inst, inst_env);\n-            }\n-          else\n-            {\n-              process_autoincrement (INST_DWORD_SIZE, inst, inst_env);\n-            }\n-        }\n+\t{\n+\t  /* If the PC is to be incremented it's invalid to be in a \n+\t     delay slot.  */\n+\t  if (inst_env->slot_needed)\n+\t    {\n+\t      inst_env->invalid = 1;\n+\t      return;\n+\t    }\n+\t  \n+\t  /* The increment depends on the size of the special register.  */\n+\t  if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 1)\n+\t    {\n+\t      process_autoincrement (INST_BYTE_SIZE, inst, inst_env);\n+\t    }\n+\t  else if (cris_register_size (gdbarch, cris_get_operand2 (inst)) == 2)\n+\t    {\n+\t      process_autoincrement (INST_WORD_SIZE, inst, inst_env);\n+\t    }\n+\t  else\n+\t    {\n+\t      process_autoincrement (INST_DWORD_SIZE, inst, inst_env);\n+\t    }\n+\t}\n     }\n   inst_env->slot_needed = 0;\n   inst_env->prefix_found = 0;\n@@ -2940,10 +2940,10 @@ reg_mode_move_from_preg_op (unsigned short inst, inst_env_type *inst_env)\n     {\n       /* It's invalid to change the PC in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       /* The destination is the PC, the jump will have a delay slot.  */\n       inst_env->delay_slot_pc = inst_env->preg[cris_get_operand2 (inst)];\n       inst_env->slot_needed = 1;\n@@ -2967,50 +2967,50 @@ move_mem_to_reg_movem_op (unsigned short inst, inst_env_type *inst_env)\n   if (inst_env->prefix_found)\n     {\n       /* The prefix handles the problem if we are in a delay slot.  Is the\n-         MOVEM instruction going to change the PC?  */\n+\t MOVEM instruction going to change the PC?  */\n       if (cris_get_operand2 (inst) >= REG_PC)\n-        {\n-          inst_env->reg[REG_PC] = \n-            read_memory_unsigned_integer (inst_env->prefix_value,\n+\t{\n+\t  inst_env->reg[REG_PC] = \n+\t    read_memory_unsigned_integer (inst_env->prefix_value,\n \t\t\t\t\t  4, inst_env->byte_order);\n-        }\n+\t}\n       /* The assign value is the value after the increment.  Normally, the   \n-         assign value is the value before the increment.  */\n+\t assign value is the value before the increment.  */\n       if ((cris_get_operand1 (inst) == REG_PC) \n-          && (cris_get_mode (inst) == PREFIX_ASSIGN_MODE))\n-        {\n-          inst_env->reg[REG_PC] = inst_env->prefix_value;\n-          inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n-        }\n+\t  && (cris_get_mode (inst) == PREFIX_ASSIGN_MODE))\n+\t{\n+\t  inst_env->reg[REG_PC] = inst_env->prefix_value;\n+\t  inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n+\t}\n     }\n   else\n     {\n       /* Is the MOVEM instruction going to change the PC?  */\n       if (cris_get_operand2 (inst) == REG_PC)\n-        {\n-          /* It's invalid to change the PC in a delay slot.  */\n-          if (inst_env->slot_needed)\n-            {\n-              inst_env->invalid = 1;\n-              return;\n-            }\n-          inst_env->reg[REG_PC] =\n-            read_memory_unsigned_integer (inst_env->reg[cris_get_operand1 (inst)], \n-                                          4, inst_env->byte_order);\n-        }\n+\t{\n+\t  /* It's invalid to change the PC in a delay slot.  */\n+\t  if (inst_env->slot_needed)\n+\t    {\n+\t      inst_env->invalid = 1;\n+\t      return;\n+\t    }\n+\t  inst_env->reg[REG_PC] =\n+\t    read_memory_unsigned_integer (inst_env->reg[cris_get_operand1 (inst)], \n+\t\t\t\t\t  4, inst_env->byte_order);\n+\t}\n       /* The increment is not depending on the size, instead it's depending\n-         on the number of registers loaded from memory.  */\n+\t on the number of registers loaded from memory.  */\n       if ((cris_get_operand1 (inst) == REG_PC)\n \t  && (cris_get_mode (inst) == AUTOINC_MODE))\n-        {\n-          /* It's invalid to change the PC in a delay slot.  */\n-          if (inst_env->slot_needed)\n-            {\n-              inst_env->invalid = 1;\n-              return;\n-            }\n-          inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1); \n-        }\n+\t{\n+\t  /* It's invalid to change the PC in a delay slot.  */\n+\t  if (inst_env->slot_needed)\n+\t    {\n+\t      inst_env->invalid = 1;\n+\t      return;\n+\t    }\n+\t  inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1); \n+\t}\n     }\n   inst_env->slot_needed = 0;\n   inst_env->prefix_found = 0;\n@@ -3026,30 +3026,30 @@ move_reg_to_mem_movem_op (unsigned short inst, inst_env_type *inst_env)\n   if (inst_env->prefix_found)\n     {\n       /* The assign value is the value after the increment.  Normally, the\n-         assign value is the value before the increment.  */\n+\t assign value is the value before the increment.  */\n       if ((cris_get_operand1 (inst) == REG_PC)\n-          && (cris_get_mode (inst) == PREFIX_ASSIGN_MODE))\n-        {\n-          /* The prefix handles the problem if we are in a delay slot.  */\n-          inst_env->reg[REG_PC] = inst_env->prefix_value;\n-          inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n-        }\n+\t  && (cris_get_mode (inst) == PREFIX_ASSIGN_MODE))\n+\t{\n+\t  /* The prefix handles the problem if we are in a delay slot.  */\n+\t  inst_env->reg[REG_PC] = inst_env->prefix_value;\n+\t  inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n+\t}\n     }\n   else\n     {\n       /* The increment is not depending on the size, instead it's depending\n-         on the number of registers loaded to memory.  */\n+\t on the number of registers loaded to memory.  */\n       if ((cris_get_operand1 (inst) == REG_PC)\n \t  && (cris_get_mode (inst) == AUTOINC_MODE))\n-        {\n-          /* It's invalid to change the PC in a delay slot.  */\n-          if (inst_env->slot_needed)\n-            {\n-              inst_env->invalid = 1;\n-              return;\n-            }\n-          inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n-        }\n+\t{\n+\t  /* It's invalid to change the PC in a delay slot.  */\n+\t  if (inst_env->slot_needed)\n+\t    {\n+\t      inst_env->invalid = 1;\n+\t      return;\n+\t    }\n+\t  inst_env->reg[REG_PC] += 4 * (cris_get_operand2 (inst) + 1);\n+\t}\n     }\n   inst_env->slot_needed = 0;\n   inst_env->prefix_found = 0;\n@@ -3083,10 +3083,10 @@ xor_op (unsigned short inst, inst_env_type *inst_env)\n     {\n       /* It's invalid to change the PC in a delay slot.  */\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       inst_env->reg[REG_PC] ^= inst_env->reg[cris_get_operand1 (inst)];\n     }\n   inst_env->slot_needed = 0;\n@@ -3148,7 +3148,7 @@ mulu_op (unsigned short inst, inst_env_type *inst_env)\n \n static void \n add_sub_cmp_and_or_move_action (unsigned short inst, inst_env_type *inst_env, \n-                                unsigned long source1, unsigned long source2)\n+\t\t\t\tunsigned long source1, unsigned long source2)\n {\n   unsigned long pc_mask;\n   unsigned long operation_mask;\n@@ -3240,23 +3240,23 @@ do_sign_or_zero_extend (unsigned long value, unsigned short *inst)\n       value &= 0xFFFF;\n \n       /* Check if the instruction is signed extend.  If so, check if value has\n-         the sign bit on.  */\n+\t the sign bit on.  */\n       if (cris_is_signed_extend_bit_on (*inst) && (value & SIGNED_WORD_MASK))\n-        {\n-          value |= SIGNED_WORD_EXTEND_MASK;\n-        } \n+\t{\n+\t  value |= SIGNED_WORD_EXTEND_MASK;\n+\t} \n     }\n   else\n     {\n       /* Byte size.  */\n       value &= 0xFF;\n \n       /* Check if the instruction is signed extend.  If so, check if value has\n-         the sign bit on.  */\n+\t the sign bit on.  */\n       if (cris_is_signed_extend_bit_on (*inst) && (value & SIGNED_BYTE_MASK))\n-        {\n-          value |= SIGNED_BYTE_EXTEND_MASK;\n-        }\n+\t{\n+\t  value |= SIGNED_BYTE_EXTEND_MASK;\n+\t}\n     }\n   /* The size should now be dword.  */\n   cris_set_size_to_dword (inst);\n@@ -3268,7 +3268,7 @@ do_sign_or_zero_extend (unsigned long value, unsigned short *inst)\n \n static void \n reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst,\n-                                     inst_env_type *inst_env)\n+\t\t\t\t     inst_env_type *inst_env)\n {\n   unsigned long operand1;\n   unsigned long operand2;\n@@ -3284,21 +3284,21 @@ reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst,\n   if (cris_get_operand2 (inst) == REG_PC)\n     {\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       /* The instruction has the PC as its target register.  */\n       operand1 = inst_env->reg[cris_get_operand1 (inst)]; \n       operand2 = inst_env->reg[REG_PC];\n \n       /* Check if it's a extend, signed or zero instruction.  */\n       if (cris_get_opcode (inst) < 4)\n-        {\n-          operand1 = do_sign_or_zero_extend (operand1, &inst);\n-        }\n+\t{\n+\t  operand1 = do_sign_or_zero_extend (operand1, &inst);\n+\t}\n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  The order of the udw_operands is vital.  */\n+\t breakpoint should be.  The order of the udw_operands is vital.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand1); \n     }\n   inst_env->slot_needed = 0;\n@@ -3342,7 +3342,7 @@ get_data_from_address (unsigned short *inst, CORE_ADDR address,\n \n static void \n handle_prefix_assign_mode_for_aritm_op (unsigned short inst, \n-                                        inst_env_type *inst_env)\n+\t\t\t\t\tinst_env_type *inst_env)\n {\n   unsigned long operand2;\n   unsigned long operand3;\n@@ -3357,7 +3357,7 @@ handle_prefix_assign_mode_for_aritm_op (unsigned short inst,\n \t\t\t\t\tinst_env->byte_order);\n \n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  The order of the udw_operands is vital.  */\n+\t breakpoint should be.  The order of the udw_operands is vital.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand3);\n     }\n   inst_env->slot_needed = 0;\n@@ -3372,7 +3372,7 @@ handle_prefix_assign_mode_for_aritm_op (unsigned short inst,\n \n static void \n three_operand_add_sub_cmp_and_or_op (unsigned short inst, \n-                                     inst_env_type *inst_env)\n+\t\t\t\t     inst_env_type *inst_env)\n {\n   unsigned long operand2;\n   unsigned long operand3;\n@@ -3387,7 +3387,7 @@ three_operand_add_sub_cmp_and_or_op (unsigned short inst,\n \t\t\t\t\tinst_env->byte_order);\n \n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  */\n+\t breakpoint should be.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand3);\n     }\n   inst_env->slot_needed = 0;\n@@ -3401,20 +3401,20 @@ three_operand_add_sub_cmp_and_or_op (unsigned short inst,\n \n static void \n handle_prefix_index_mode_for_aritm_op (unsigned short inst, \n-                                       inst_env_type *inst_env)\n+\t\t\t\t       inst_env_type *inst_env)\n {\n   if (cris_get_operand1 (inst) != cris_get_operand2 (inst))\n     {\n       /* If the instruction is MOVE it's invalid.  If the instruction is ADD,\n-         SUB, AND or OR something weird is going on (if everything works these\n-         instructions should end up in the three operand version).  */\n+\t SUB, AND or OR something weird is going on (if everything works these\n+\t instructions should end up in the three operand version).  */\n       inst_env->invalid = 1;\n       return;\n     }\n   else\n     {\n       /* three_operand_add_sub_cmp_and_or does the same as we should do here\n-         so use it.  */\n+\t so use it.  */\n       three_operand_add_sub_cmp_and_or_op (inst, inst_env);\n     }\n   inst_env->slot_needed = 0;\n@@ -3429,7 +3429,7 @@ handle_prefix_index_mode_for_aritm_op (unsigned short inst,\n \n static void \n handle_inc_and_index_mode_for_aritm_op (unsigned short inst, \n-                                        inst_env_type *inst_env)\n+\t\t\t\t\tinst_env_type *inst_env)\n {\n   unsigned long operand1;\n   unsigned long operand2;\n@@ -3441,7 +3441,7 @@ handle_inc_and_index_mode_for_aritm_op (unsigned short inst,\n   if (cris_get_operand2 (inst) == REG_PC)\n     {\n       /* Must be done here, get_data_from_address may change the size \n-         field.  */\n+\t field.  */\n       size = cris_get_size (inst);\n       operand2 = inst_env->reg[REG_PC];\n \n@@ -3450,7 +3450,7 @@ handle_inc_and_index_mode_for_aritm_op (unsigned short inst,\n       operand3 = get_data_from_address (&inst, operand1, inst_env->byte_order);\n \n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  The order of the udw_operands is vital.  */\n+\t breakpoint should be.  The order of the udw_operands is vital.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand3); \n     }\n   /* If this is an autoincrement addressing mode, check if the increment\n@@ -3462,11 +3462,11 @@ handle_inc_and_index_mode_for_aritm_op (unsigned short inst,\n       size = cris_get_size (inst);\n \n       /* If it's an extend instruction we don't want the signed extend bit,\n-         because it influences the size.  */\n+\t because it influences the size.  */\n       if (cris_get_opcode (inst) < 4)\n-        {\n-          size &= ~SIGNED_EXTEND_BIT_MASK;\n-        }\n+\t{\n+\t  size &= ~SIGNED_EXTEND_BIT_MASK;\n+\t}\n       process_autoincrement (size, inst, inst_env);\n     } \n   inst_env->slot_needed = 0;\n@@ -3480,24 +3480,24 @@ handle_inc_and_index_mode_for_aritm_op (unsigned short inst,\n \n static void \n none_reg_mode_add_sub_cmp_and_or_move_op (unsigned short inst, \n-                                          inst_env_type *inst_env)\n+\t\t\t\t\t  inst_env_type *inst_env)\n {\n   if (inst_env->prefix_found)\n     {\n       if (cris_get_mode (inst) == PREFIX_INDEX_MODE)\n-        {\n-          handle_prefix_index_mode_for_aritm_op (inst, inst_env);\n-        }\n+\t{\n+\t  handle_prefix_index_mode_for_aritm_op (inst, inst_env);\n+\t}\n       else if (cris_get_mode (inst) == PREFIX_ASSIGN_MODE)\n-        {\n-          handle_prefix_assign_mode_for_aritm_op (inst, inst_env);\n-        }\n+\t{\n+\t  handle_prefix_assign_mode_for_aritm_op (inst, inst_env);\n+\t}\n       else\n-        {\n-          /* The mode is invalid for a prefixed base instruction.  */\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  /* The mode is invalid for a prefixed base instruction.  */\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n     }\n   else\n     {\n@@ -3525,18 +3525,18 @@ quick_mode_add_sub_op (unsigned short inst, inst_env_type *inst_env)\n   if (cris_get_operand2 (inst) == REG_PC)\n     {\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       operand1 = cris_get_quick_value (inst);\n       operand2 = inst_env->reg[REG_PC];\n \n       /* The size should now be dword.  */\n       cris_set_size_to_dword (&inst);\n \n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  */\n+\t breakpoint should be.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand1);\n     }\n   inst_env->slot_needed = 0;\n@@ -3564,25 +3564,25 @@ quick_mode_and_cmp_move_or_op (unsigned short inst, inst_env_type *inst_env)\n   if (cris_get_operand2 (inst) == REG_PC)\n     {\n       if (inst_env->slot_needed)\n-        {\n-          inst_env->invalid = 1;\n-          return;\n-        }\n+\t{\n+\t  inst_env->invalid = 1;\n+\t  return;\n+\t}\n       /* The instruction has the PC as its target register.  */\n       operand1 = cris_get_quick_value (inst);\n       operand2 = inst_env->reg[REG_PC];\n \n       /* The quick value is signed, so check if we must do a signed extend.  */\n       if (operand1 & SIGNED_QUICK_VALUE_MASK)\n-        {\n-          /* sign extend  */\n-          operand1 |= SIGNED_QUICK_VALUE_EXTEND_MASK;\n-        }\n+\t{\n+\t  /* sign extend  */\n+\t  operand1 |= SIGNED_QUICK_VALUE_EXTEND_MASK;\n+\t}\n       /* The size should now be dword.  */\n       cris_set_size_to_dword (&inst);\n \n       /* Calculate the PC value after the instruction, i.e. where the\n-         breakpoint should be.  */\n+\t breakpoint should be.  */\n       add_sub_cmp_and_or_move_action (inst, inst_env, operand2, operand1);\n     }\n   inst_env->slot_needed = 0;\n@@ -3864,11 +3864,11 @@ cris_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n   if (tdep != NULL)\n     {\n       fprintf_unfiltered (file, \"cris_dump_tdep: tdep->cris_version = %i\\n\",\n-                          tdep->cris_version);\n+\t\t\t  tdep->cris_version);\n       fprintf_unfiltered (file, \"cris_dump_tdep: tdep->cris_mode = %s\\n\",\n-                          tdep->cris_mode);\n+\t\t\t  tdep->cris_mode);\n       fprintf_unfiltered (file, \"cris_dump_tdep: tdep->cris_dwarf2_cfi = %i\\n\",\n-                          tdep->cris_dwarf2_cfi);\n+\t\t\t  tdep->cris_dwarf2_cfi);\n     }\n }\n \n@@ -3949,7 +3949,7 @@ cris_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t   == usr_cmd_cris_mode)\n \t  && (gdbarch_tdep (arches->gdbarch)->cris_dwarf2_cfi \n \t      == usr_cmd_cris_dwarf2_cfi))\n-        return arches->gdbarch;\n+\treturn arches->gdbarch;\n     }\n \n   /* No matching architecture was found.  Create a new one.  */\n@@ -3991,7 +3991,7 @@ cris_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     case 10:\n     case 11: \n       /* CRIS v10 and v11, a.k.a. ETRAX 100LX.  In addition to ETRAX 100, \n-         P7 (32 bits), and P15 (32 bits) have been implemented.  */\n+\t P7 (32 bits), and P15 (32 bits) have been implemented.  */\n       set_gdbarch_pc_regnum (gdbarch, 15);\n       set_gdbarch_register_type (gdbarch, cris_register_type);\n       /* There are 32 registers (some of which may not be implemented).  */"
    },
    {
      "sha": "9d9342bce128e4348f908f4ae273fef937f1d9fe",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -511,7 +511,7 @@ PrimaryExpression:\n \t\t{ write_dollar_variable (pstate, $1); }\n |\tNAME_OR_INT\n \t\t{ YYSTYPE val;\n-                  parse_number (pstate, $1.ptr, $1.length, 0, &val);\n+\t\t  parse_number (pstate, $1.ptr, $1.length, 0, &val);\n \t\t  write_exp_elt_opcode (pstate, OP_LONG);\n \t\t  write_exp_elt_type (pstate, val.typed_val_int.type);\n \t\t  write_exp_elt_longcst (pstate,\n@@ -793,7 +793,7 @@ parse_number (struct parser_state *ps, const char *p,\n \t  if (base > 10 && c >= 'a' && c <= 'f')\n \t    {\n \t      if (found_suffix)\n-\t        return ERROR;\n+\t\treturn ERROR;\n \t      n += i = c - 'a' + 10;\n \t    }\n \t  else if (c == 'l' && long_p == 0)\n@@ -1080,7 +1080,7 @@ lex_one_token (struct parser_state *par_state)\n       else if (saw_structop)\n \treturn COMPLETE;\n       else\n-        return 0;\n+\treturn 0;\n \n     case ' ':\n     case '\\t':\n@@ -1269,9 +1269,9 @@ lex_one_token (struct parser_state *par_state)\n       const char *p = tokstart + namelen + 1;\n \n       while (*p == ' ' || *p == '\\t')\n-        p++;\n+\tp++;\n       if (*p >= '0' && *p <= '9')\n-        return 0;\n+\treturn 0;\n     }\n \n   pstate->lexptr += namelen;\n@@ -1488,7 +1488,7 @@ yylex (void)\n \t  if (next.token == IDENTIFIER && last_was_dot)\n \t    {\n \t      /* Update the partial name we are constructing.  */\n-              obstack_grow_str (&name_obstack, \".\");\n+\t      obstack_grow_str (&name_obstack, \".\");\n \t      obstack_grow (&name_obstack, next.value.sval.ptr,\n \t\t\t    next.value.sval.length);\n \n@@ -1568,7 +1568,7 @@ yylex (void)\n \t  if (context_type != NULL)\n \t    {\n \t      /* We don't want to put a leading \".\" into the name.  */\n-              obstack_grow_str (&name_obstack, \".\");\n+\t      obstack_grow_str (&name_obstack, \".\");\n \t    }\n \t  obstack_grow (&name_obstack, next.value.sval.ptr,\n \t\t\tnext.value.sval.length);"
    },
    {
      "sha": "205a045578d3ac7aa2a5ae26e3989e1a414b1005",
      "filename": "gdb/darwin-nat-info.c",
      "status": "modified",
      "additions": 79,
      "deletions": 79,
      "changes": 158,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat-info.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat-info.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat-info.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -90,20 +90,20 @@ info_mach_tasks_command (const char *args, int from_tty)\n       mach_port_t taskPort;\n \n       result =\n-        task_by_unix_pid (mach_task_self (), procInfo[index].kp_proc.p_pid,\n-                          &taskPort);\n+\ttask_by_unix_pid (mach_task_self (), procInfo[index].kp_proc.p_pid,\n+\t\t\t  &taskPort);\n       if (KERN_SUCCESS == result)\n-        {\n-          printf_unfiltered (_(\"    %s is %d has task %#x\\n\"),\n-                             procInfo[index].kp_proc.p_comm,\n-                             procInfo[index].kp_proc.p_pid, taskPort);\n-        }\n+\t{\n+\t  printf_unfiltered (_(\"    %s is %d has task %#x\\n\"),\n+\t\t\t     procInfo[index].kp_proc.p_comm,\n+\t\t\t     procInfo[index].kp_proc.p_pid, taskPort);\n+\t}\n       else\n-        {\n-          printf_unfiltered (_(\"    %s is %d unknown task port\\n\"),\n-                             procInfo[index].kp_proc.p_comm,\n-                             procInfo[index].kp_proc.p_pid);\n-        }\n+\t{\n+\t  printf_unfiltered (_(\"    %s is %d unknown task port\\n\"),\n+\t\t\t     procInfo[index].kp_proc.p_comm,\n+\t\t\t     procInfo[index].kp_proc.p_pid);\n+\t}\n     }\n \n   xfree (procInfo);\n@@ -156,8 +156,8 @@ info_mach_task_command (const char *args, int from_tty)\n   printf_unfiltered (_(\"TASK_BASIC_INFO for 0x%x:\\n\"), task);\n   info_count = TASK_BASIC_INFO_COUNT;\n   result = task_info (task,\n-                      TASK_BASIC_INFO,\n-                      (task_info_t) & task_info_data.basic, &info_count);\n+\t\t      TASK_BASIC_INFO,\n+\t\t      (task_info_t) & task_info_data.basic, &info_count);\n   MACH_CHECK_ERROR (result);\n \n   PRINT_FIELD (&task_info_data.basic, suspend_count);\n@@ -168,8 +168,8 @@ info_mach_task_command (const char *args, int from_tty)\n   printf_unfiltered (_(\"\\nTASK_EVENTS_INFO:\\n\"));\n   info_count = TASK_EVENTS_INFO_COUNT;\n   result = task_info (task,\n-                      TASK_EVENTS_INFO,\n-                      (task_info_t) & task_info_data.events, &info_count);\n+\t\t      TASK_EVENTS_INFO,\n+\t\t      (task_info_t) & task_info_data.events, &info_count);\n   MACH_CHECK_ERROR (result);\n \n   PRINT_FIELD (&task_info_data.events, faults);\n@@ -184,9 +184,9 @@ info_mach_task_command (const char *args, int from_tty)\n   printf_unfiltered (_(\"\\nTASK_THREAD_TIMES_INFO:\\n\"));\n   info_count = TASK_THREAD_TIMES_INFO_COUNT;\n   result = task_info (task,\n-                      TASK_THREAD_TIMES_INFO,\n-                      (task_info_t) & task_info_data.thread_times,\n-                      &info_count);\n+\t\t      TASK_THREAD_TIMES_INFO,\n+\t\t      (task_info_t) & task_info_data.thread_times,\n+\t\t      &info_count);\n   MACH_CHECK_ERROR (result);\n   PRINT_TV_FIELD (&task_info_data.thread_times, user_time);\n   PRINT_TV_FIELD (&task_info_data.thread_times, system_time);\n@@ -293,9 +293,9 @@ info_mach_ports_command (const char *args, int from_tty)\n     }\n \n   vm_deallocate (task_self (), (vm_address_t) names,\n-                 (name_count * sizeof (mach_port_t)));\n+\t\t (name_count * sizeof (mach_port_t)));\n   vm_deallocate (task_self (), (vm_address_t) types,\n-                 (type_count * sizeof (mach_port_type_t)));\n+\t\t (type_count * sizeof (mach_port_type_t)));\n }\n \n \n@@ -311,7 +311,7 @@ darwin_debug_port_info (task_t task, mach_port_t port)\n   MACH_CHECK_ERROR (kret);\n \n   printf_unfiltered (_(\"Port 0x%lx in task 0x%lx:\\n\"), (unsigned long) port,\n-                     (unsigned long) task);\n+\t\t     (unsigned long) task);\n   printf_unfiltered (_(\"  port set: 0x%x\\n\"), status.mps_pset);\n   printf_unfiltered (_(\"     seqno: 0x%x\\n\"), status.mps_seqno);\n   printf_unfiltered (_(\"   mscount: 0x%x\\n\"), status.mps_mscount);\n@@ -360,7 +360,7 @@ info_mach_threads_command (const char *args, int from_tty)\n     }\n \n   vm_deallocate (task_self (), (vm_address_t) threads,\n-                 (thread_count * sizeof (thread_t)));\n+\t\t (thread_count * sizeof (thread_t)));\n }\n \n static void\n@@ -543,65 +543,65 @@ darwin_debug_regions (task_t task, mach_vm_address_t address, int max)\n \n       /* Check to see if address space has wrapped around.  */\n       if (address == 0)\n-        print = done = 1;\n+\tprint = done = 1;\n \n       if (!done)\n-        {\n-          count = VM_REGION_BASIC_INFO_COUNT_64;\n-          kret =\n-            mach_vm_region (task, &address, &size, VM_REGION_BASIC_INFO_64,\n-                 \t      (vm_region_info_t) &info, &count, &object_name);\n-          if (kret != KERN_SUCCESS)\n-            {\n-              size = 0;\n-              print = done = 1;\n-            }\n-        }\n+\t{\n+\t  count = VM_REGION_BASIC_INFO_COUNT_64;\n+\t  kret =\n+\t    mach_vm_region (task, &address, &size, VM_REGION_BASIC_INFO_64,\n+\t\t \t      (vm_region_info_t) &info, &count, &object_name);\n+\t  if (kret != KERN_SUCCESS)\n+\t    {\n+\t      size = 0;\n+\t      print = done = 1;\n+\t    }\n+\t}\n \n       if (address != prev_address + prev_size)\n-        print = 1;\n+\tprint = 1;\n \n       if ((info.protection != prev_info.protection)\n-          || (info.max_protection != prev_info.max_protection)\n-          || (info.inheritance != prev_info.inheritance)\n-          || (info.shared != prev_info.reserved)\n-          || (info.reserved != prev_info.reserved))\n-        print = 1;\n+\t  || (info.max_protection != prev_info.max_protection)\n+\t  || (info.inheritance != prev_info.inheritance)\n+\t  || (info.shared != prev_info.reserved)\n+\t  || (info.reserved != prev_info.reserved))\n+\tprint = 1;\n \n       if (print)\n-        {\n-          printf_filtered (_(\"%s-%s %s/%s  %s %s %s\"),\n-                           paddress (target_gdbarch (), prev_address),\n-                           paddress (target_gdbarch (), prev_address + prev_size),\n-                           unparse_protection (prev_info.protection),\n-                           unparse_protection (prev_info.max_protection),\n-                           unparse_inheritance (prev_info.inheritance),\n-                           prev_info.shared ? _(\"shrd\") : _(\"priv\"),\n-                           prev_info.reserved ? _(\"reserved\") : _(\"not-rsvd\"));\n-\n-          if (nsubregions > 1)\n-            printf_filtered (_(\" (%d sub-rgn)\"), nsubregions);\n-\n-          printf_filtered (_(\"\\n\"));\n-\n-          prev_address = address;\n-          prev_size = size;\n-          memcpy (&prev_info, &info, sizeof (vm_region_basic_info_data_64_t));\n-          nsubregions = 1;\n-\n-          num_printed++;\n-        }\n+\t{\n+\t  printf_filtered (_(\"%s-%s %s/%s  %s %s %s\"),\n+\t\t\t   paddress (target_gdbarch (), prev_address),\n+\t\t\t   paddress (target_gdbarch (), prev_address + prev_size),\n+\t\t\t   unparse_protection (prev_info.protection),\n+\t\t\t   unparse_protection (prev_info.max_protection),\n+\t\t\t   unparse_inheritance (prev_info.inheritance),\n+\t\t\t   prev_info.shared ? _(\"shrd\") : _(\"priv\"),\n+\t\t\t   prev_info.reserved ? _(\"reserved\") : _(\"not-rsvd\"));\n+\n+\t  if (nsubregions > 1)\n+\t    printf_filtered (_(\" (%d sub-rgn)\"), nsubregions);\n+\n+\t  printf_filtered (_(\"\\n\"));\n+\n+\t  prev_address = address;\n+\t  prev_size = size;\n+\t  memcpy (&prev_info, &info, sizeof (vm_region_basic_info_data_64_t));\n+\t  nsubregions = 1;\n+\n+\t  num_printed++;\n+\t}\n       else\n-        {\n-          prev_size += size;\n-          nsubregions++;\n-        }\n+\t{\n+\t  prev_size += size;\n+\t  nsubregions++;\n+\t}\n \n       if ((max > 0) && (num_printed >= max))\n-        done = 1;\n+\tdone = 1;\n \n       if (done)\n-        break;\n+\tbreak;\n     }\n }\n \n@@ -843,25 +843,25 @@ void\n _initialize_darwin_info_commands ()\n {\n   add_info (\"mach-tasks\", info_mach_tasks_command,\n-            _(\"Get list of tasks in system.\"));\n+\t    _(\"Get list of tasks in system.\"));\n   add_info (\"mach-ports\", info_mach_ports_command,\n-            _(\"Get list of ports in a task.\"));\n+\t    _(\"Get list of ports in a task.\"));\n   add_info (\"mach-port\", info_mach_port_command,\n-            _(\"Get info on a specific port.\"));\n+\t    _(\"Get info on a specific port.\"));\n   add_info (\"mach-task\", info_mach_task_command,\n-            _(\"Get info on a specific task.\"));\n+\t    _(\"Get info on a specific task.\"));\n   add_info (\"mach-threads\", info_mach_threads_command,\n-            _(\"Get list of threads in a task.\"));\n+\t    _(\"Get list of threads in a task.\"));\n   add_info (\"mach-thread\", info_mach_thread_command,\n-            _(\"Get info on a specific thread.\"));\n+\t    _(\"Get info on a specific thread.\"));\n \n   add_info (\"mach-regions\", info_mach_regions_command,\n-            _(\"Get information on all mach region for the task.\"));\n+\t    _(\"Get information on all mach region for the task.\"));\n   add_info (\"mach-regions-rec\", info_mach_regions_recurse_command,\n-            _(\"Get information on all mach sub region for the task.\"));\n+\t    _(\"Get information on all mach sub region for the task.\"));\n   add_info (\"mach-region\", info_mach_region_command,\n-            _(\"Get information on mach region at given address.\"));\n+\t    _(\"Get information on mach region at given address.\"));\n \n   add_info (\"mach-exceptions\", info_mach_exceptions_command,\n-            _(\"Disp mach exceptions.\"));\n+\t    _(\"Disp mach exceptions.\"));\n }"
    },
    {
      "sha": "796b92ce3642f3e55e8ad27d6af5ef6fc3a223ff",
      "filename": "gdb/darwin-nat.c",
      "status": "modified",
      "additions": 36,
      "deletions": 36,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -176,7 +176,7 @@ inferior_debug (int level, const char *fmt, ...)\n \n void\n mach_check_error (kern_return_t ret, const char *file,\n-                  unsigned int line, const char *func)\n+\t\t  unsigned int line, const char *func)\n {\n   if (ret == KERN_SUCCESS)\n     return;\n@@ -241,8 +241,8 @@ darwin_ptrace (const char *name,\n     ret = 0;\n \n   inferior_debug (4, _(\"ptrace (%s, %d, 0x%lx, %d): %d (%s)\\n\"),\n-                  name, pid, (unsigned long) arg3, arg4, ret,\n-                  (ret != 0) ? safe_strerror (errno) : _(\"no error\"));\n+\t\t  name, pid, (unsigned long) arg3, arg4, ret,\n+\t\t  (ret != 0) ? safe_strerror (errno) : _(\"no error\"));\n   return ret;\n }\n \n@@ -940,19 +940,19 @@ darwin_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n       darwin_suspend_inferior (inf);\n \n       if (tid == 0)\n-        darwin_resume_inferior_threads (inf, step, nsignal);\n+\tdarwin_resume_inferior_threads (inf, step, nsignal);\n       else\n-        {\n-          darwin_thread_t *thread;\n+\t{\n+\t  darwin_thread_t *thread;\n \n-          /* Suspend threads of the task.  */\n-          darwin_suspend_inferior_threads (inf);\n+\t  /* Suspend threads of the task.  */\n+\t  darwin_suspend_inferior_threads (inf);\n \n-          /* Resume the selected thread.  */\n-          thread = darwin_find_thread (inf, tid);\n-          gdb_assert (thread);\n-          darwin_resume_thread (inf, thread, step, nsignal);\n-        }\n+\t  /* Resume the selected thread.  */\n+\t  thread = darwin_find_thread (inf, tid);\n+\t  gdb_assert (thread);\n+\t  darwin_resume_thread (inf, thread, step, nsignal);\n+\t}\n \n       /* Resume the task.  */\n       darwin_resume_inferior (inf);\n@@ -1432,10 +1432,10 @@ darwin_restore_exception_ports (darwin_inferior *inf)\n   for (i = 0; i < inf->exception_info.count; i++)\n     {\n       kret = task_set_exception_ports\n-        (inf->task, inf->exception_info.masks[i], inf->exception_info.ports[i],\n+\t(inf->task, inf->exception_info.masks[i], inf->exception_info.ports[i],\n \t inf->exception_info.behaviors[i], inf->exception_info.flavors[i]);\n       if (kret != KERN_SUCCESS)\n-        return kret;\n+\treturn kret;\n     }\n \n   return KERN_SUCCESS;\n@@ -1508,21 +1508,21 @@ darwin_nat_target::kill ()\n   if (res == 0)\n     {\n       /* On MacOS version Sierra, the darwin_restore_exception_ports call\n-         does not work as expected.\n-         When the kill function is called, the SIGKILL signal is received\n-         by gdb whereas it should have been received by the kernel since\n-         the exception ports have been restored.\n-         This behavior is not the expected one thus gdb does not reply to\n-         the received SIGKILL message. This situation leads to a \"busy\"\n-         resource from the kernel point of view and the inferior is never\n-         released, causing it to remain as a zombie process, even after\n+\t does not work as expected.\n+\t When the kill function is called, the SIGKILL signal is received\n+\t by gdb whereas it should have been received by the kernel since\n+\t the exception ports have been restored.\n+\t This behavior is not the expected one thus gdb does not reply to\n+\t the received SIGKILL message. This situation leads to a \"busy\"\n+\t resource from the kernel point of view and the inferior is never\n+\t released, causing it to remain as a zombie process, even after\n \t GDB exits.\n-         To work around this, we mark all the threads of the inferior as\n-         signaled thus darwin_decode_message function knows that the kill\n-         signal was sent by gdb and will take the appropriate action\n-         (cancel signal and reply to the signal message).  */\n+\t To work around this, we mark all the threads of the inferior as\n+\t signaled thus darwin_decode_message function knows that the kill\n+\t signal was sent by gdb and will take the appropriate action\n+\t (cancel signal and reply to the signal message).  */\n       for (darwin_thread_t *thread : priv->threads)\n-        thread->signaled = 1;\n+\tthread->signaled = 1;\n \n       darwin_resume_inferior (inf);\n \n@@ -1775,7 +1775,7 @@ darwin_execvp (const char *file, char * const argv[], char * const env[])\n   if (res != 0)\n     {\n       fprintf_unfiltered\n-        (gdb_stderr, \"Cannot initialize attribute for posix_spawn\\n\");\n+\t(gdb_stderr, \"Cannot initialize attribute for posix_spawn\\n\");\n       return;\n     }\n \n@@ -1813,7 +1813,7 @@ may_have_sip ()\n     {\n       unsigned long ver = strtoul (str, NULL, 10);\n       if (ver >= 16)\n-        return true;\n+\treturn true;\n     }\n   return false;\n }\n@@ -2024,7 +2024,7 @@ darwin_nat_target::attach (const char *args, int from_tty)\n \n   if (pid == 0 || ::kill (pid, 0) < 0)\n     error (_(\"Can't attach to process %d: %s (%d)\"),\n-           pid, safe_strerror (errno), errno);\n+\t   pid, safe_strerror (errno), errno);\n \n   inf = current_inferior ();\n   inferior_appeared (inf, pid);\n@@ -2327,10 +2327,10 @@ darwin_nat_target::xfer_partial (enum target_object object, const char *annex,\n #ifdef TASK_DYLD_INFO_COUNT\n     case TARGET_OBJECT_DARWIN_DYLD_INFO:\n       if (writebuf != NULL || readbuf == NULL)\n-        {\n-          /* Support only read.  */\n-          return TARGET_XFER_E_IO;\n-        }\n+\t{\n+\t  /* Support only read.  */\n+\t  return TARGET_XFER_E_IO;\n+\t}\n       return darwin_read_dyld_info (priv->task, offset, readbuf, len,\n \t\t\t\t    xfered_len);\n #endif\n@@ -2434,7 +2434,7 @@ darwin_nat_target::get_ada_task_ptid (long lwp, long thread)\n     }\n \n   vm_deallocate (gdb_task, (vm_address_t) names,\n-                 names_count * sizeof (mach_port_t));\n+\t\t names_count * sizeof (mach_port_t));\n \n   if (res)\n     return ptid_t (current_inferior ()->pid, 0, res);"
    },
    {
      "sha": "78b16ab565fdd4af0e6413d9b4aadb65075afbe4",
      "filename": "gdb/darwin-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/darwin-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -117,7 +117,7 @@ class darwin_nat_target : public inf_child_target\n   ptid_t wait_1 (ptid_t, struct target_waitstatus *);\n   void check_new_threads (inferior *inf);\n   int decode_exception_message (mach_msg_header_t *hdr,\n-\t\t\t        inferior **pinf,\n+\t\t\t\tinferior **pinf,\n \t\t\t\tdarwin_thread_t **pthread);\n   ptid_t decode_message (mach_msg_header_t *hdr,\n \t\t\t darwin_thread_t **pthread,"
    },
    {
      "sha": "5f648aca38e67675543a67e21ec9574a30de35c6",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 72,
      "deletions": 72,
      "changes": 144,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -461,8 +461,8 @@ record_minimal_symbol (minimal_symbol_reader &reader,\n       break;\n     case N_SETV:\n       /* I don't think this type actually exists; since a N_SETV is the result\n-         of going over many .o files, it doesn't make sense to have one\n-         file local.  */\n+\t of going over many .o files, it doesn't make sense to have one\n+\t file local.  */\n       ms_type = mst_file_data;\n       section = SECT_OFF_DATA (objfile);\n       break;\n@@ -478,9 +478,9 @@ record_minimal_symbol (minimal_symbol_reader &reader,\n       ms_type = mst_file_data;\n \n       /* Check for __DYNAMIC, which is used by Sun shared libraries. \n-         Record it as global even if it's local, not global, so\n-         lookup_minimal_symbol can find it.  We don't check symbol_leading_char\n-         because for SunOS4 it always is '_'.  */\n+\t Record it as global even if it's local, not global, so\n+\t lookup_minimal_symbol can find it.  We don't check symbol_leading_char\n+\t because for SunOS4 it always is '_'.  */\n       if (name[8] == 'C' && strcmp (\"__DYNAMIC\", name) == 0)\n \tms_type = mst_data;\n \n@@ -627,8 +627,8 @@ dbx_symfile_init (struct objfile *objfile)\n   if (STRING_TABLE_OFFSET == 0)\n     {\n       /* It appears that with the existing bfd code, STRING_TABLE_OFFSET\n-         will never be zero, even when there is no string table.  This\n-         would appear to be a bug in bfd.  */\n+\t will never be zero, even when there is no string table.  This\n+\t would appear to be a bug in bfd.  */\n       DBX_STRINGTAB_SIZE (objfile) = 0;\n       DBX_STRINGTAB (objfile) = NULL;\n     }\n@@ -762,7 +762,7 @@ fill_symbuf (bfd *sym_bfd)\n     {\n       nbytes = sizeof (symbuf);\n       if (nbytes > symbuf_left)\n-        nbytes = symbuf_left;\n+\tnbytes = symbuf_left;\n       memcpy (symbuf, stabs_data + symbuf_read, nbytes);\n     }\n   else if (symbuf_sections == NULL)\n@@ -910,8 +910,8 @@ find_stab_function (const char *namestring, const char *filename,\n   if (msym.minsym == NULL)\n     {\n       /* Sun Fortran appends an underscore to the minimal symbol name,\n-         try again with an appended underscore if the minimal symbol\n-         was not found.  */\n+\t try again with an appended underscore if the minimal symbol\n+\t was not found.  */\n       p[n] = '_';\n       p[n + 1] = 0;\n       msym = lookup_minimal_symbol (p, filename, objfile);\n@@ -1066,15 +1066,15 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n       OBJSTAT (objfile, n_stabs++);\n \n       /* Ok.  There is a lot of code duplicated in the rest of this\n-         switch statement (for efficiency reasons).  Since I don't\n-         like duplicating code, I will do my penance here, and\n-         describe the code which is duplicated:\n+\t switch statement (for efficiency reasons).  Since I don't\n+\t like duplicating code, I will do my penance here, and\n+\t describe the code which is duplicated:\n \n-         *) The assignment to namestring.\n-         *) The call to strchr.\n-         *) The addition of a partial symbol the two partial\n-         symbol lists.  This last is a large section of code, so\n-         I've imbedded it in the following macro.  */\n+\t *) The assignment to namestring.\n+\t *) The call to strchr.\n+\t *) The addition of a partial symbol the two partial\n+\t symbol lists.  This last is a large section of code, so\n+\t I've imbedded it in the following macro.  */\n \n       switch (nlist.n_type)\n \t{\n@@ -1275,8 +1275,8 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \t      {\n \t\t/* Save the directory name SOs locally, then save it into\n \t\t   the psymtab when it's created below.  */\n-\t        dirname_nso = namestring;\n-\t        continue;\t\t\n+\t\tdirname_nso = namestring;\n+\t\tcontinue;\t\t\n \t      }\n \n \t    /* Some other compilers (C++ ones in particular) emit useless\n@@ -1993,9 +1993,9 @@ dbx_end_psymtab (struct objfile *objfile, legacy_psymtab *pst,\n   else\n     {\n       /* If we know our own starting text address, then walk through all other\n-         psymtabs for this objfile, and if any didn't know their ending text\n-         address, set it to our starting address.  Take care to not set our\n-         own ending address to our starting address.  */\n+\t psymtabs for this objfile, and if any didn't know their ending text\n+\t address, set it to our starting address.  Take care to not set our\n+\t own ending address to our starting address.  */\n \n       for (partial_symtab *p1 : objfile->psymtabs ())\n \tif (!p1->text_high_valid && p1->text_low_valid && p1 != pst)\n@@ -2028,7 +2028,7 @@ dbx_end_psymtab (struct objfile *objfile, legacy_psymtab *pst,\n \tLDSYMLEN (subpst) = 0;\n \n       /* We could save slight bits of space by only making one of these,\n-         shared by the entire set of include files.  FIXME-someday.  */\n+\t shared by the entire set of include files.  FIXME-someday.  */\n       subpst->dependencies =\n \tobjfile->partial_symtabs->allocate_dependencies (1);\n       subpst->dependencies[0] = pst;\n@@ -2045,10 +2045,10 @@ dbx_end_psymtab (struct objfile *objfile, legacy_psymtab *pst,\n     {\n       /* Throw away this psymtab, it's empty.  */\n       /* Empty psymtabs happen as a result of header files which don't have\n-         any symbols in them.  There can be a lot of them.  But this check\n-         is wrong, in that a psymtab with N_SLINE entries but nothing else\n-         is not empty, but we don't realize that.  Fixing that without slowing\n-         things down might be tricky.  */\n+\t any symbols in them.  There can be a lot of them.  But this check\n+\t is wrong, in that a psymtab with N_SLINE entries but nothing else\n+\t is not empty, but we don't realize that.  Fixing that without slowing\n+\t things down might be tricky.  */\n \n       objfile->partial_symtabs->discard_psymtab (pst);\n \n@@ -2110,7 +2110,7 @@ dbx_read_symtab (legacy_psymtab *self, struct objfile *objfile)\n       }\n \n       /* Match with global symbols.  This only needs to be done once,\n-         after all of the symtabs and dependencies have been read in.   */\n+\t after all of the symtabs and dependencies have been read in.   */\n       scan_file_globals (objfile);\n     }\n }\n@@ -2182,8 +2182,8 @@ read_ofile_symtab (struct objfile *objfile, legacy_psymtab *pst)\n   else\n     {\n       /* The N_SO starting this symtab is the first symbol, so we\n-         better not check the symbol before it.  I'm not this can\n-         happen, but it doesn't hurt to check for it.  */\n+\t better not check the symbol before it.  I'm not this can\n+\t happen, but it doesn't hurt to check for it.  */\n       stabs_seek (sym_offset);\n       processing_gcc_compilation = 0;\n     }\n@@ -2231,7 +2231,7 @@ read_ofile_symtab (struct objfile *objfile, legacy_psymtab *pst)\n \t\t\t      PST_LANGUAGE (pst));\n \t}\n       /* We skip checking for a new .o or -l file; that should never\n-         happen in this routine.  */\n+\t happen in this routine.  */\n       else if (type == N_TEXT)\n \t{\n \t  /* I don't think this code will ever be executed, because\n@@ -2362,9 +2362,9 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n   if (get_last_source_file () == NULL && type != (unsigned char) N_SO)\n     {\n       /* Ignore any symbols which appear before an N_SO symbol.\n-         Currently no one puts symbols there, but we should deal\n-         gracefully with the case.  A complain()t might be in order,\n-         but this should not be an error ().  */\n+\t Currently no one puts symbols there, but we should deal\n+\t gracefully with the case.  A complain()t might be in order,\n+\t but this should not be an error ().  */\n       return;\n     }\n \n@@ -2427,7 +2427,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     case N_LBRAC:\n       /* This \"symbol\" just indicates the start of an inner lexical\n-         context within a function.  */\n+\t context within a function.  */\n \n       /* Ignore extra outermost context from SunPRO cc and acc.  */\n       if (n_opt_found && desc == 1)\n@@ -2440,7 +2440,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     case N_RBRAC:\n       /* This \"symbol\" just indicates the end of an inner lexical\n-         context that was started with N_LBRAC.  */\n+\t context that was started with N_LBRAC.  */\n \n       /* Ignore extra outermost context from SunPRO cc and acc.  */\n       if (n_opt_found && desc == 1)\n@@ -2506,15 +2506,15 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n     case N_FN:\n     case N_FN_SEQ:\n       /* This kind of symbol indicates the start of an object file.\n-         Relocate for dynamic loading.  */\n+\t Relocate for dynamic loading.  */\n       valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       break;\n \n     case N_SO:\n       /* This type of symbol indicates the start of data for one\n-         source file.  Finish the symbol table of the previous source\n-         file (if any) and start accumulating a new symbol table.\n-         Relocate for dynamic loading.  */\n+\t source file.  Finish the symbol table of the previous source\n+\t file (if any) and start accumulating a new symbol table.\n+\t Relocate for dynamic loading.  */\n       valu += section_offsets[SECT_OFF_TEXT (objfile)];\n \n       n_opt_found = 0;\n@@ -2535,7 +2535,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \t}\n \n       /* Null name means this just marks the end of text for this .o\n-         file.  Don't start a new symtab in this case.  */\n+\t file.  Don't start a new symtab in this case.  */\n       if (*name == '\\000')\n \tbreak;\n \n@@ -2548,9 +2548,9 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     case N_SOL:\n       /* This type of symbol indicates the start of data for a\n-         sub-source-file, one whose contents were copied or included\n-         in the compilation of the main source file (whose name was\n-         given in the N_SO symbol).  Relocate for dynamic loading.  */\n+\t sub-source-file, one whose contents were copied or included\n+\t in the compilation of the main source file (whose name was\n+\t given in the N_SO symbol).  Relocate for dynamic loading.  */\n       valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       start_subfile (name);\n       break;\n@@ -2571,11 +2571,11 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     case N_SLINE:\n       /* This type of \"symbol\" really just records one line-number --\n-         core-address correspondence.  Enter it in the line list for\n-         this symbol table.  */\n+\t core-address correspondence.  Enter it in the line list for\n+\t this symbol table.  */\n \n       /* Relocate for dynamic loading and for ELF acc\n-         function-relative symbols.  */\n+\t function-relative symbols.  */\n       valu += function_start_offset;\n \n       /* GCC 2.95.3 emits the first N_SLINE stab somewhere in the\n@@ -2615,22 +2615,22 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n       break;\n \n       /* The following symbol types need to have the appropriate\n-         offset added to their value; then we process symbol\n-         definitions in the name.  */\n+\t offset added to their value; then we process symbol\n+\t definitions in the name.  */\n \n     case N_STSYM:\t\t/* Static symbol in data segment.  */\n     case N_LCSYM:\t\t/* Static symbol in BSS segment.  */\n     case N_ROSYM:\t\t/* Static symbol in read-only data segment.  */\n       /* HORRID HACK DEPT.  However, it's Sun's furgin' fault.\n-         Solaris 2's stabs-in-elf makes *most* symbols relative but\n-         leaves a few absolute (at least for Solaris 2.1 and version\n-         2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on\n-         the fence.  .stab \"foo:S...\",N_STSYM is absolute (ld\n-         relocates it) .stab \"foo:V...\",N_STSYM is relative (section\n-         base subtracted).  This leaves us no choice but to search for\n-         the 'S' or 'V'...  (or pass the whole section_offsets stuff\n-         down ONE MORE function call level, which we really don't want\n-         to do).  */\n+\t Solaris 2's stabs-in-elf makes *most* symbols relative but\n+\t leaves a few absolute (at least for Solaris 2.1 and version\n+\t 2.0.1 of the SunPRO compiler).  N_STSYM and friends sit on\n+\t the fence.  .stab \"foo:S...\",N_STSYM is absolute (ld\n+\t relocates it) .stab \"foo:V...\",N_STSYM is relative (section\n+\t base subtracted).  This leaves us no choice but to search for\n+\t the 'S' or 'V'...  (or pass the whole section_offsets stuff\n+\t down ONE MORE function call level, which we really don't want\n+\t to do).  */\n       {\n \tconst char *p;\n \n@@ -2656,7 +2656,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \t      }\n \t  }\n \t/* Since it's not the kludge case, re-dispatch to the right\n-           handler.  */\n+\t   handler.  */\n \tswitch (type)\n \t  {\n \t  case N_STSYM:\n@@ -2692,8 +2692,8 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n       goto define_a_symbol;\n \n       /* The following symbol types we don't know how to process.\n-         Handle them in a \"default\" way, but complain to people who\n-         care.  */\n+\t Handle them in a \"default\" way, but complain to people who\n+\t care.  */\n     default:\n     case N_CATCH:\t\t/* Exception handler catcher.  */\n     case N_EHDECL:\t\t/* Exception handler name.  */\n@@ -2712,7 +2712,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     define_a_symbol:\n       /* These symbol types don't need the address field relocated,\n-         since it is either unused, or is absolute.  */\n+\t since it is either unused, or is absolute.  */\n     case N_GSYM:\t\t/* Global variable.  */\n     case N_NSYMS:\t\t/* Number of symbols (Ultrix).  */\n     case N_NOMAP:\t\t/* No map?  (Ultrix).  */\n@@ -2737,7 +2737,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \t    case 'f':\n \t    case 'F':\n \t      /* Deal with the SunPRO 3.0 compiler which omits the\n-\t         address from N_FUN symbols.  */\n+\t\t address from N_FUN symbols.  */\n \t      if (type == N_FUN\n \t\t  && valu == section_offsets[SECT_OFF_TEXT (objfile)]\n \t\t  && gdbarch_sofun_address_maybe_missing (gdbarch))\n@@ -2789,8 +2789,8 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n       break;\n \n       /* We use N_OPT to carry the gcc2_compiled flag.  Sun uses it\n-         for a bunch of other flags, too.  Someday we may parse their\n-         flags; for now we ignore theirs and hope they'll ignore ours.  */\n+\t for a bunch of other flags, too.  Someday we may parse their\n+\t flags; for now we ignore theirs and hope they'll ignore ours.  */\n     case N_OPT:\t\t\t/* Solaris 2: Compiler options.  */\n       if (name)\n \t{\n@@ -2821,7 +2821,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n     case N_PATCH:\t\t/* Solaris 2: Patch Run Time Checker.  */\n       /* N_UNDF:                   Solaris 2: File separator mark.  */\n       /* N_UNDF: -- we will never encounter it, since we only process\n-         one file's symbols at once.  */\n+\t one file's symbols at once.  */\n     case N_ENDM:\t\t/* Solaris 2: End of module.  */\n     case N_ALIAS:\t\t/* SunPro F77: alias name, ignore for now.  */\n       break;\n@@ -2836,17 +2836,17 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n   if (name[0] == '#')\n     {\n       /* Initialize symbol reference names and determine if this is a\n-         definition.  If a symbol reference is being defined, go ahead\n-         and add it.  Otherwise, just return.  */\n+\t definition.  If a symbol reference is being defined, go ahead\n+\t and add it.  Otherwise, just return.  */\n \n       const char *s = name;\n       int refnum;\n \n       /* If this stab defines a new reference ID that is not on the\n-         reference list, then put it on the reference list.\n+\t reference list, then put it on the reference list.\n \n-         We go ahead and advance NAME past the reference, even though\n-         it is not strictly necessary at this time.  */\n+\t We go ahead and advance NAME past the reference, even though\n+\t it is not strictly necessary at this time.  */\n       refnum = symbol_reference_defined (&s);\n       if (refnum >= 0)\n \tif (!ref_search (refnum))"
    },
    {
      "sha": "9f7cc1a12d6479fa0b5361d2da2b850ba28c2061",
      "filename": "gdb/dcache.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dcache.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -324,7 +324,7 @@ dcache_read_line (DCACHE *dcache, struct dcache_block *db)\n \treg_len = region->hi - memaddr;\n \n       /* Skip non-readable regions.  The cache attribute can be ignored,\n-         since we may be loading this for a stack access.  */\n+\t since we may be loading this for a stack access.  */\n       if (region->attrib.mode == MEM_WO)\n \t{\n \t  memaddr += reg_len;\n@@ -401,7 +401,7 @@ dcache_peek_byte (DCACHE *dcache, CORE_ADDR addr, gdb_byte *ptr)\n       db = dcache_alloc (dcache, addr);\n \n       if (!dcache_read_line (dcache, db))\n-         return 0;\n+\t return 0;\n     }\n \n   *ptr = db->data[XFORM (dcache, addr)];\n@@ -597,7 +597,7 @@ dcache_info_1 (DCACHE *dcache, const char *exp)\n       if (linestart == exp || i < 0)\n \t{\n \t  printf_filtered (_(\"Usage: info dcache [LINENUMBER]\\n\"));\n-          return;\n+\t  return;\n \t}\n \n       dcache_print_line (dcache, i);"
    },
    {
      "sha": "e19939f2537d3f5b3ee9a4b5b0096d64617fe275",
      "filename": "gdb/disasm.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/disasm.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -176,14 +176,14 @@ line_is_less_than (const deprecated_dis_line_entry &mle1,\n       if (mle1.start_pc != mle2.start_pc)\n \tval = mle1.start_pc < mle2.start_pc;\n     else\n-        val = mle1.line < mle2.line;\n+\tval = mle1.line < mle2.line;\n     }\n   else\n     {\n       if (mle1.line != mle2.line)\n \tval = mle1.line < mle2.line;\n       else\n-        val = mle1.start_pc < mle2.start_pc;\n+\tval = mle1.start_pc < mle2.start_pc;\n     }\n   return val;\n }\n@@ -238,7 +238,7 @@ gdb_pretty_print_disassembler::pretty_print_insn (const struct disasm_insn *insn\n     std::string name, filename;\n     bool omit_fname = ((flags & DISASSEMBLY_OMIT_FNAME) != 0);\n     if (!build_address_symbolic (gdbarch, pc, false, omit_fname, &name,\n-                                 &offset, &filename, &line, &unmapped))\n+\t\t\t\t &offset, &filename, &line, &unmapped))\n       {\n \t/* We don't care now about line, filename and unmapped.  But we might in\n \t   the future.  */\n@@ -460,7 +460,7 @@ do_mixed_source_and_assembly_deprecated\n \t\t\t\t   how_many, flags, NULL);\n \n       /* When we've reached the end of the mle array, or we've seen the last\n-         assembly range for this source line, close out the list/tuple.  */\n+\t assembly range for this source line, close out the list/tuple.  */\n       if (i == (newlines - 1) || mle[i + 1].line > mle[i].line)\n \t{\n \t  inner_list_emitter.reset ();"
    },
    {
      "sha": "1d150fb25b9da3061da112d743fc190c17faba45",
      "filename": "gdb/dtrace-probe.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dtrace-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dtrace-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dtrace-probe.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -462,8 +462,8 @@ dtrace_process_dof_probe (struct objfile *objfile,\n       int probe_argc = DOF_UINT (dof, probe->dofpr_nargc);\n \n       /* Store argument type descriptions.  A description of the type\n-         of the argument is in the (J+1)th null-terminated string\n-         starting at 'strtab' + 'probe->dofpr_nargv'.  */\n+\t of the argument is in the (J+1)th null-terminated string\n+\t starting at 'strtab' + 'probe->dofpr_nargv'.  */\n       std::vector<struct dtrace_probe_arg> args;\n       p = strtab + DOF_UINT (dof, probe->dofpr_nargv);\n       for (j = 0; j < probe_argc; j++)\n@@ -481,7 +481,7 @@ dtrace_process_dof_probe (struct objfile *objfile,\n \t  /* Try to parse a type expression from the type string.  If\n \t     this does not work then we set the type to `long\n \t     int'.  */\n-          struct type *type = builtin_type (gdbarch)->builtin_long;\n+\t  struct type *type = builtin_type (gdbarch)->builtin_long;\n \n \t  try\n \t    {\n@@ -856,8 +856,8 @@ dtrace_static_probe_ops::get_probes\n \t     extract the information of any probe defined into it.  */\n \t  if (bfd_malloc_and_get_section (abfd, sect, &dof) && dof != NULL)\n \t    dtrace_process_dof (sect, objfile, probesp,\n-\t\t\t        (struct dtrace_dof_hdr *) dof);\n-         else\n+\t\t\t\t(struct dtrace_dof_hdr *) dof);\n+\t else\n \t    complaint (_(\"could not obtain the contents of\"\n \t\t\t \"section '%s' in objfile `%s'.\"),\n \t\t       bfd_section_name (sect), bfd_get_filename (abfd));"
    },
    {
      "sha": "86789e56beca2810df10d1bc0991f1700eb357b0",
      "filename": "gdb/dwarf2/abbrev.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/abbrev.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/abbrev.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/abbrev.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -165,12 +165,12 @@ abbrev_table::read (struct objfile *objfile,\n       abbrev_table->add_abbrev (cur_abbrev);\n \n       /* Get next abbreviation.\n-         Under Irix6 the abbreviations for a compilation unit are not\n-         always properly terminated with an abbrev number of 0.\n-         Exit loop if we encounter an abbreviation which we have\n-         already read (which means we are about to read the abbreviations\n-         for the next compile unit) or if the end of the abbreviation\n-         table is reached.  */\n+\t Under Irix6 the abbreviations for a compilation unit are not\n+\t always properly terminated with an abbrev number of 0.\n+\t Exit loop if we encounter an abbreviation which we have\n+\t already read (which means we are about to read the abbreviations\n+\t for the next compile unit) or if the end of the abbreviation\n+\t table is reached.  */\n       if ((unsigned int) (abbrev_ptr - section->buffer) >= section->size)\n \tbreak;\n       abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);"
    },
    {
      "sha": "9596158b4da92efb93041f860cc09ecdbfe0336a",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -107,7 +107,7 @@ bool\n attribute::form_is_section_offset () const\n {\n   return (form == DW_FORM_data4\n-          || form == DW_FORM_data8\n+\t  || form == DW_FORM_data8\n \t  || form == DW_FORM_sec_offset\n \t  || form == DW_FORM_loclistx);\n }"
    },
    {
      "sha": "eaeb76f9c61c45687140122b2f2c6790969bab39",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -859,8 +859,8 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    stack.clear ();\n \n \t    /* FIXME: cagney/2003-03-26: This code should be using\n-               get_frame_base_address(), and then implement a dwarf2\n-               specific this_base method.  */\n+\t       get_frame_base_address(), and then implement a dwarf2\n+\t       specific this_base method.  */\n \t    this->get_frame_base (&datastart, &datalen);\n \t    eval (datastart, datalen);\n \t    if (this->location == DWARF_VALUE_MEMORY)\n@@ -1040,7 +1040,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\tbreak;\n \t      case DW_OP_div:\n \t\tresult_val = value_binop (first, second, BINOP_DIV);\n-                break;\n+\t\tbreak;\n \t      case DW_OP_minus:\n \t\tresult_val = value_binop (first, second, BINOP_SUB);\n \t\tbreak;\n@@ -1100,7 +1100,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t\t   with.  */\n \t\tif (value_type (result_val) != value_type (second))\n \t\t  result_val = value_cast (value_type (second), result_val);\n-                break;\n+\t\tbreak;\n \t      case DW_OP_shra:\n \t\tdwarf_require_integral (value_type (first));\n \t\tdwarf_require_integral (value_type (second));\n@@ -1202,38 +1202,38 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \tcase DW_OP_nop:\n \t  goto no_push;\n \n-        case DW_OP_piece:\n-          {\n-            uint64_t size;\n+\tcase DW_OP_piece:\n+\t  {\n+\t    uint64_t size;\n \n-            /* Record the piece.  */\n-            op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);\n+\t    /* Record the piece.  */\n+\t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);\n \t    add_piece (8 * size, 0);\n \n-            /* Pop off the address/regnum, and reset the location\n+\t    /* Pop off the address/regnum, and reset the location\n \t       type.  */\n \t    if (this->location != DWARF_VALUE_LITERAL\n \t\t&& this->location != DWARF_VALUE_OPTIMIZED_OUT)\n \t      pop ();\n-            this->location = DWARF_VALUE_MEMORY;\n-          }\n-          goto no_push;\n+\t    this->location = DWARF_VALUE_MEMORY;\n+\t  }\n+\t  goto no_push;\n \n \tcase DW_OP_bit_piece:\n \t  {\n \t    uint64_t size, uleb_offset;\n \n-            /* Record the piece.  */\n+\t    /* Record the piece.  */\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &uleb_offset);\n \t    add_piece (size, uleb_offset);\n \n-            /* Pop off the address/regnum, and reset the location\n+\t    /* Pop off the address/regnum, and reset the location\n \t       type.  */\n \t    if (this->location != DWARF_VALUE_LITERAL\n \t\t&& this->location != DWARF_VALUE_OPTIMIZED_OUT)\n \t      pop ();\n-            this->location = DWARF_VALUE_MEMORY;\n+\t    this->location = DWARF_VALUE_MEMORY;\n \t  }\n \t  goto no_push;\n \n@@ -1267,7 +1267,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t  {\n \t    sect_offset sect_off\n \t      = (sect_offset) extract_unsigned_integer (op_ptr,\n-\t                                                this->ref_addr_size,\n+\t\t\t\t\t\t\tthis->ref_addr_size,\n \t\t\t\t\t\t\tbyte_order);\n \t    op_ptr += this->ref_addr_size;\n \t    result_val = value_cast (address_type,"
    },
    {
      "sha": "a577a671f2427bf20fc01d1480b76bd0ea265b15",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -492,7 +492,7 @@ bad CFI data; mismatched DW_CFA_restore_state at %s\"),\n \t    case DW_CFA_def_cfa_register:\n \t      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);\n \t      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, reg,\n-                                                             eh_frame_p);\n+\t\t\t\t\t\t\t     eh_frame_p);\n \t      fs->regs.cfa_how = CFA_REG_OFFSET;\n \t      break;\n \n@@ -569,7 +569,7 @@ bad CFI data; mismatched DW_CFA_restore_state at %s\"),\n \t    case DW_CFA_def_cfa_sf:\n \t      insn_ptr = safe_read_uleb128 (insn_ptr, insn_end, &reg);\n \t      fs->regs.cfa_reg = dwarf2_frame_adjust_regnum (gdbarch, reg,\n-                                                             eh_frame_p);\n+\t\t\t\t\t\t\t     eh_frame_p);\n \t      insn_ptr = safe_read_sleb128 (insn_ptr, insn_end, &offset);\n \t      fs->regs.cfa_offset = offset * fs->data_align;\n \t      fs->regs.cfa_how = CFA_REG_OFFSET;\n@@ -1159,12 +1159,12 @@ incomplete CFI data; unspecified registers (e.g., %s) at %s\"),\n \t    ULONGEST retaddr_column = fs.retaddr_column;\n \n \t    /* It seems rather bizarre to specify an \"empty\" column as\n-               the return adress column.  However, this is exactly\n-               what GCC does on some targets.  It turns out that GCC\n-               assumes that the return address can be found in the\n-               register corresponding to the return address column.\n-               Incidentally, that's how we should treat a return\n-               address column specifying \"same value\" too.  */\n+\t       the return adress column.  However, this is exactly\n+\t       what GCC does on some targets.  It turns out that GCC\n+\t       assumes that the return address can be found in the\n+\t       register corresponding to the return address column.\n+\t       Incidentally, that's how we should treat a return\n+\t       address column specifying \"same value\" too.  */\n \t    if (fs.retaddr_column < fs.regs.reg.size ()\n \t\t&& regs[retaddr_column].how != DWARF2_FRAME_REG_UNSPECIFIED\n \t\t&& regs[retaddr_column].how != DWARF2_FRAME_REG_SAME_VALUE)\n@@ -1461,13 +1461,13 @@ dwarf2_frame_cfa (struct frame_info *this_frame)\n     this_frame = get_prev_frame (this_frame);\n   if (get_frame_unwind_stop_reason (this_frame) == UNWIND_UNAVAILABLE)\n     throw_error (NOT_AVAILABLE_ERROR,\n-                _(\"can't compute CFA for this frame: \"\n-                  \"required registers or memory are unavailable\"));\n+\t\t_(\"can't compute CFA for this frame: \"\n+\t\t  \"required registers or memory are unavailable\"));\n \n   if (get_frame_id (this_frame).stack_status != FID_STACK_VALID)\n     throw_error (NOT_AVAILABLE_ERROR,\n-                _(\"can't compute CFA for this frame: \"\n-                  \"frame base not available\"));\n+\t\t_(\"can't compute CFA for this frame: \"\n+\t\t  \"frame base not available\"));\n \n   return get_frame_base (this_frame);\n }\n@@ -1684,19 +1684,19 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, dwarf2_per_objfile **out_per_objfile)\n \n       gdb_assert (!fde_table->empty ());\n       if (*pc < offset + (*fde_table)[0]->initial_location)\n-        continue;\n+\tcontinue;\n \n       seek_pc = *pc - offset;\n       auto it = gdb::binary_search (fde_table->begin (), fde_table->end (),\n \t\t\t\t    seek_pc, bsearch_fde_cmp);\n       if (it != fde_table->end ())\n-        {\n-          *pc = (*it)->initial_location + offset;\n+\t{\n+\t  *pc = (*it)->initial_location + offset;\n \t  if (out_per_objfile != nullptr)\n \t    *out_per_objfile = get_dwarf2_per_objfile (objfile);\n \n-          return *it;\n-        }\n+\t  return *it;\n+\t}\n     }\n   return NULL;\n }\n@@ -1739,9 +1739,9 @@ static const gdb_byte *\n decode_frame_entry_1 (struct gdbarch *gdbarch,\n \t\t      struct comp_unit *unit, const gdb_byte *start,\n \t\t      int eh_frame_p,\n-                      dwarf2_cie_table &cie_table,\n-                      dwarf2_fde_table *fde_table,\n-                      enum eh_frame_type entry_type)\n+\t\t      dwarf2_cie_table &cie_table,\n+\t\t      dwarf2_fde_table *fde_table,\n+\t\t      enum eh_frame_type entry_type)\n {\n   const gdb_byte *buf, *end;\n   ULONGEST length;\n@@ -1809,7 +1809,7 @@ decode_frame_entry_1 (struct gdbarch *gdbarch,\n       cie->cie_pointer = cie_pointer;\n \n       /* The encoding for FDE's in a normal .debug_frame section\n-         depends on the target address size.  */\n+\t depends on the target address size.  */\n       cie->encoding = DW_EH_PE_absptr;\n \n       /* We'll determine the final value later, but we need to\n@@ -1833,8 +1833,8 @@ decode_frame_entry_1 (struct gdbarch *gdbarch,\n \taugmentation += strlen (augmentation);\n \n       /* The GCC 2.x \"eh\" augmentation has a pointer immediately\n-         following the augmentation string, so it must be handled\n-         first.  */\n+\t following the augmentation string, so it must be handled\n+\t first.  */\n       if (augmentation[0] == 'e' && augmentation[1] == 'h')\n \t{\n \t  /* Skip.  */\n@@ -2043,8 +2043,8 @@ decode_frame_entry (struct gdbarch *gdbarch,\n \t\t    struct comp_unit *unit, const gdb_byte *start,\n \t\t    int eh_frame_p,\n \t\t    dwarf2_cie_table &cie_table,\n-                    dwarf2_fde_table *fde_table,\n-                    enum eh_frame_type entry_type)\n+\t\t    dwarf2_fde_table *fde_table,\n+\t\t    enum eh_frame_type entry_type)\n {\n   enum { NONE, ALIGN4, ALIGN8, FAIL } workaround = NONE;\n   const gdb_byte *ret;\n@@ -2139,13 +2139,13 @@ fde_is_less_than (const dwarf2_fde *aa, const dwarf2_fde *bb)\n   if (aa->initial_location == bb->initial_location)\n     {\n       if (aa->address_range != bb->address_range\n-          && aa->eh_frame_p == 0 && bb->eh_frame_p == 0)\n-        /* Linker bug, e.g. gold/10400.\n-           Work around it by keeping stable sort order.  */\n-        return aa < bb;\n+\t  && aa->eh_frame_p == 0 && bb->eh_frame_p == 0)\n+\t/* Linker bug, e.g. gold/10400.\n+\t   Work around it by keeping stable sort order.  */\n+\treturn aa < bb;\n       else\n-        /* Put eh_frame entries after debug_frame ones.  */\n-        return aa->eh_frame_p < bb->eh_frame_p;\n+\t/* Put eh_frame entries after debug_frame ones.  */\n+\treturn aa->eh_frame_p < bb->eh_frame_p;\n     }\n \n   return aa->initial_location < bb->initial_location;\n@@ -2166,28 +2166,28 @@ dwarf2_build_frame_info (struct objfile *objfile)\n   if (objfile->separate_debug_objfile_backlink == NULL)\n     {\n       /* Do not read .eh_frame from separate file as they must be also\n-         present in the main file.  */\n+\t present in the main file.  */\n       dwarf2_get_section_info (objfile, DWARF2_EH_FRAME,\n-                               &unit->dwarf_frame_section,\n-                               &unit->dwarf_frame_buffer,\n-                               &unit->dwarf_frame_size);\n+\t\t\t       &unit->dwarf_frame_section,\n+\t\t\t       &unit->dwarf_frame_buffer,\n+\t\t\t       &unit->dwarf_frame_size);\n       if (unit->dwarf_frame_size)\n-        {\n-          asection *got, *txt;\n-\n-          /* FIXME: kettenis/20030602: This is the DW_EH_PE_datarel base\n-             that is used for the i386/amd64 target, which currently is\n-             the only target in GCC that supports/uses the\n-             DW_EH_PE_datarel encoding.  */\n-          got = bfd_get_section_by_name (unit->abfd, \".got\");\n-          if (got)\n-            unit->dbase = got->vma;\n-\n-          /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64\n-             so far.  */\n-          txt = bfd_get_section_by_name (unit->abfd, \".text\");\n-          if (txt)\n-            unit->tbase = txt->vma;\n+\t{\n+\t  asection *got, *txt;\n+\n+\t  /* FIXME: kettenis/20030602: This is the DW_EH_PE_datarel base\n+\t     that is used for the i386/amd64 target, which currently is\n+\t     the only target in GCC that supports/uses the\n+\t     DW_EH_PE_datarel encoding.  */\n+\t  got = bfd_get_section_by_name (unit->abfd, \".got\");\n+\t  if (got)\n+\t    unit->dbase = got->vma;\n+\n+\t  /* GCC emits the DW_EH_PE_textrel encoding type on sh and ia64\n+\t     so far.  */\n+\t  txt = bfd_get_section_by_name (unit->abfd, \".text\");\n+\t  if (txt)\n+\t    unit->tbase = txt->vma;\n \n \t  try\n \t    {\n@@ -2209,13 +2209,13 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t    }\n \n \t  cie_table.clear ();\n-        }\n+\t}\n     }\n \n   dwarf2_get_section_info (objfile, DWARF2_DEBUG_FRAME,\n-                           &unit->dwarf_frame_section,\n-                           &unit->dwarf_frame_buffer,\n-                           &unit->dwarf_frame_size);\n+\t\t\t   &unit->dwarf_frame_section,\n+\t\t\t   &unit->dwarf_frame_buffer,\n+\t\t\t   &unit->dwarf_frame_size);\n   if (unit->dwarf_frame_size)\n     {\n       size_t num_old_fde_entries = fde_table.size ();"
    },
    {
      "sha": "e91e50731ef2aef967f88b7043b6339998459b13",
      "filename": "gdb/dwarf2/index-cache.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/index-cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/index-cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-cache.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -144,11 +144,11 @@ index_cache::store (dwarf2_per_objfile *per_objfile)\n \t}\n \n       if (debug_index_cache)\n-        printf_unfiltered (\"index cache: writing index cache for objfile %s\\n\",\n+\tprintf_unfiltered (\"index cache: writing index cache for objfile %s\\n\",\n \t\t\t   objfile_name (obj));\n \n       /* Write the index itself to the directory, using the build id as the\n-         filename.  */\n+\t filename.  */\n       write_psymtabs_to_index (per_objfile, m_dir.c_str (),\n \t\t\t       build_id_str.c_str (), dwz_build_id_ptr,\n \t\t\t       dw_index_kind::GDB_INDEX);\n@@ -198,7 +198,7 @@ index_cache::lookup_gdb_index (const bfd_build_id *build_id,\n   try\n     {\n       if (debug_index_cache)\n-        printf_unfiltered (\"index cache: trying to read %s\\n\",\n+\tprintf_unfiltered (\"index cache: trying to read %s\\n\",\n \t\t\t   filename.c_str ());\n \n       /* Try to map that file.  */"
    },
    {
      "sha": "4881105793ddfeb2fd630e76a77b9c92bca633b3",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -57,7 +57,7 @@\n #define DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE(cu_index, value) \\\n   do { \\\n     gdb_assert ((value) >= GDB_INDEX_SYMBOL_KIND_TYPE \\\n-                && (value) <= GDB_INDEX_SYMBOL_KIND_OTHER); \\\n+\t\t&& (value) <= GDB_INDEX_SYMBOL_KIND_OTHER); \\\n     GDB_INDEX_SYMBOL_KIND_SET_VALUE((cu_index), (value)); \\\n   } while (0)\n \n@@ -594,7 +594,7 @@ write_psymbols (struct mapped_symtab *symtab,\n struct signatured_type_index_data\n {\n   signatured_type_index_data (data_buf &types_list_,\n-                              std::unordered_set<partial_symbol *> &psyms_seen_)\n+\t\t\t      std::unordered_set<partial_symbol *> &psyms_seen_)\n     : types_list (types_list_), psyms_seen (psyms_seen_)\n   {}\n \n@@ -941,7 +941,7 @@ class debug_names\n   {\n   public:\n     write_one_signatured_type_data (debug_names &nametable_,\n-                                    signatured_type_index_data &&info_)\n+\t\t\t\t    signatured_type_index_data &&info_)\n     : nametable (nametable_), info (std::move (info_))\n     {}\n     debug_names &nametable;\n@@ -1069,7 +1069,7 @@ class debug_names\n     symbol_value (int dwarf_tag_, int cu_index_, bool is_static_,\n \t\t  unit_kind kind_)\n       : dwarf_tag (dwarf_tag_), cu_index (cu_index_), is_static (is_static_),\n-        kind (kind_)\n+\tkind (kind_)\n     {}\n \n     bool"
    },
    {
      "sha": "3d38e077e266cad8902554fdf64c423d3c74320b",
      "filename": "gdb/dwarf2/line-header.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/line-header.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/line-header.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -32,9 +32,9 @@ line_header::add_include_dir (const char *include_dir)\n     {\n       size_t new_size;\n       if (version >= 5)\n-        new_size = m_include_dirs.size ();\n+\tnew_size = m_include_dirs.size ();\n       else\n-        new_size = m_include_dirs.size () + 1;\n+\tnew_size = m_include_dirs.size () + 1;\n       fprintf_unfiltered (gdb_stdlog, \"Adding dir %zu: %s\\n\",\n \t\t\t  new_size, include_dir);\n     }\n@@ -51,9 +51,9 @@ line_header::add_file_name (const char *name,\n     {\n       size_t new_size;\n       if (version >= 5)\n-        new_size = file_names_size ();\n+\tnew_size = file_names_size ();\n       else\n-        new_size = file_names_size () + 1;\n+\tnew_size = file_names_size () + 1;\n       fprintf_unfiltered (gdb_stdlog, \"Adding file %zu: %s\\n\",\n \t\t\t  new_size, name);\n     }\n@@ -82,15 +82,15 @@ line_header::file_file_name (int file) const\n   else\n     {\n       /* The compiler produced a bogus file number.  We can at least\n-         record the macro definitions made in the file, even if we\n-         won't be able to find the file by name.  */\n+\t record the macro definitions made in the file, even if we\n+\t won't be able to find the file by name.  */\n       char fake_name[80];\n \n       xsnprintf (fake_name, sizeof (fake_name),\n \t\t \"<bad macro file number %d>\", file);\n \n       complaint (_(\"bad file number in macro information (%d)\"),\n-                 file);\n+\t\t file);\n \n       return make_unique_xstrdup (fake_name);\n     }"
    },
    {
      "sha": "86d0ca496a26e72bf4c3d5a8a8af55c7b6d91dab",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1590,7 +1590,7 @@ value_of_dwarf_block_entry (struct type *type, struct frame_info *frame,\n \n   if (dwarf_block_to_fb_offset (block, block + block_len, &kind_u.fb_offset))\n     return value_of_dwarf_reg_entry (type, frame, CALL_SITE_PARAMETER_FB_OFFSET,\n-                                     kind_u);\n+\t\t\t\t     kind_u);\n \n   /* This can normally happen - throw NO_ENTRY_VALUE_ERROR to get the message\n      suppressed during normal operation.  The expression can be arbitrary if\n@@ -3556,7 +3556,7 @@ dwarf2_compile_expr_to_ax (struct agent_expr *expr, struct axs_value *loc,\n \tcase DW_OP_nop:\n \t  break;\n \n-        case DW_OP_piece:\n+\tcase DW_OP_piece:\n \tcase DW_OP_bit_piece:\n \t  {\n \t    uint64_t size;\n@@ -3565,7 +3565,7 @@ dwarf2_compile_expr_to_ax (struct agent_expr *expr, struct axs_value *loc,\n \t      error (_(\"Cannot translate empty pieces to agent expressions\"));\n \t    previous_piece = op_ptr - 1;\n \n-            op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);\n+\t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);\n \t    if (op == DW_OP_piece)\n \t      {\n \t\tsize *= 8;\n@@ -3857,7 +3857,7 @@ locexpr_describe_location_piece (struct symbol *symbol, struct ui_file *stream,\n      64-bit LE machine):\n \n      DW_AT_location    : 10 byte block: 3 4 0 0 0 0 0 0 0 e0\n-                        (DW_OP_addr: 4; DW_OP_GNU_push_tls_address)\n+\t\t\t(DW_OP_addr: 4; DW_OP_GNU_push_tls_address)\n \n      0x3 is the encoding for DW_OP_addr, which has an operand as long\n      as the size of an address on the target machine (here is 8\n@@ -3889,7 +3889,7 @@ locexpr_describe_location_piece (struct symbol *symbol, struct ui_file *stream,\n \n   /* With -gsplit-dwarf a TLS variable can also look like this:\n      DW_AT_location    : 3 byte block: fc 4 e0\n-                        (DW_OP_GNU_const_index: 4;\n+\t\t\t(DW_OP_GNU_const_index: 4;\n \t\t\t DW_OP_GNU_push_tls_address)  */\n   else if (data + 3 <= end\n \t   && data + 1 + (leb128_size = skip_leb128 (data + 1, end)) < end\n@@ -4166,7 +4166,7 @@ disassemble_dwarf_expression (struct ui_file *stream,\n \t  fprintf_filtered (stream, \" offset %s\", phex_nz (ul, offset_size));\n \t  break;\n \n-        case DW_OP_piece:\n+\tcase DW_OP_piece:\n \t  data = safe_read_uleb128 (data, end, &ul);\n \t  fprintf_filtered (stream, \" %s (bytes)\", pulongest (ul));\n \t  break;"
    },
    {
      "sha": "bafb8aafb6db136f6dcf78515dae287e20b1db8b",
      "filename": "gdb/dwarf2/macro.c",
      "status": "modified",
      "additions": 112,
      "deletions": 112,
      "changes": 224,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/macro.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -47,8 +47,8 @@ dwarf2_macro_malformed_definition_complaint (const char *arg1)\n static struct macro_source_file *\n macro_start_file (buildsym_compunit *builder,\n \t\t  int file, int line,\n-                  struct macro_source_file *current_file,\n-                  const struct line_header *lh)\n+\t\t  struct macro_source_file *current_file,\n+\t\t  const struct line_header *lh)\n {\n   /* File name relative to the compilation directory of this source file.  */\n   gdb::unique_xmalloc_ptr<char> file_name = lh->file_file_name (file);\n@@ -80,7 +80,7 @@ consume_improper_spaces (const char *p, const char *body)\n \t\t body);\n \n       while (*p == ' ')\n-        p++;\n+\tp++;\n     }\n \n   return p;\n@@ -89,20 +89,20 @@ consume_improper_spaces (const char *p, const char *body)\n \n static void\n parse_macro_definition (struct macro_source_file *file, int line,\n-                        const char *body)\n+\t\t\tconst char *body)\n {\n   const char *p;\n \n   /* The body string takes one of two forms.  For object-like macro\n      definitions, it should be:\n \n-        <macro name> \" \" <definition>\n+\t<macro name> \" \" <definition>\n \n      For function-like macro definitions, it should be:\n \n-        <macro name> \"() \" <definition>\n+\t<macro name> \"() \" <definition>\n      or\n-        <macro name> \"(\" <arg name> ( \",\" <arg name> ) * \") \" <definition>\n+\t<macro name> \"(\" <arg name> ( \",\" <arg name> ) * \") \" <definition>\n \n      Spaces may appear only where explicitly indicated, and in the\n      <definition>.\n@@ -132,12 +132,12 @@ parse_macro_definition (struct macro_source_file *file, int line,\n       const char *replacement;\n \n       if (*p == ' ')\n-        replacement = body + name_len + 1;\n+\treplacement = body + name_len + 1;\n       else\n-        {\n+\t{\n \t  dwarf2_macro_malformed_definition_complaint (body);\n-          replacement = body + name_len;\n-        }\n+\t  replacement = body + name_len;\n+\t}\n \n       macro_define_object (file, line, name.c_str (), replacement);\n     }\n@@ -155,68 +155,68 @@ parse_macro_definition (struct macro_source_file *file, int line,\n \n       /* Parse the formal argument list.  */\n       while (*p && *p != ')')\n-        {\n-          /* Find the extent of the current argument name.  */\n-          const char *arg_start = p;\n+\t{\n+\t  /* Find the extent of the current argument name.  */\n+\t  const char *arg_start = p;\n \n-          while (*p && *p != ',' && *p != ')' && *p != ' ')\n-            p++;\n+\t  while (*p && *p != ',' && *p != ')' && *p != ' ')\n+\t    p++;\n \n-          if (! *p || p == arg_start)\n+\t  if (! *p || p == arg_start)\n \t    dwarf2_macro_malformed_definition_complaint (body);\n-          else\n-            {\n-              /* Make sure argv has room for the new argument.  */\n-              if (argc >= argv_size)\n-                {\n-                  argv_size *= 2;\n-                  argv = XRESIZEVEC (char *, argv, argv_size);\n-                }\n-\n-              argv[argc++] = savestring (arg_start, p - arg_start);\n-            }\n+\t  else\n+\t    {\n+\t      /* Make sure argv has room for the new argument.  */\n+\t      if (argc >= argv_size)\n+\t\t{\n+\t\t  argv_size *= 2;\n+\t\t  argv = XRESIZEVEC (char *, argv, argv_size);\n+\t\t}\n+\n+\t      argv[argc++] = savestring (arg_start, p - arg_start);\n+\t    }\n \n-          p = consume_improper_spaces (p, body);\n+\t  p = consume_improper_spaces (p, body);\n \n-          /* Consume the comma, if present.  */\n-          if (*p == ',')\n-            {\n-              p++;\n+\t  /* Consume the comma, if present.  */\n+\t  if (*p == ',')\n+\t    {\n+\t      p++;\n \n-              p = consume_improper_spaces (p, body);\n-            }\n-        }\n+\t      p = consume_improper_spaces (p, body);\n+\t    }\n+\t}\n \n       if (*p == ')')\n-        {\n-          p++;\n-\n-          if (*p == ' ')\n-            /* Perfectly formed definition, no complaints.  */\n-            macro_define_function (file, line, name.c_str (),\n-                                   argc, (const char **) argv,\n-                                   p + 1);\n-          else if (*p == '\\0')\n-            {\n-              /* Complain, but do define it.  */\n+\t{\n+\t  p++;\n+\n+\t  if (*p == ' ')\n+\t    /* Perfectly formed definition, no complaints.  */\n+\t    macro_define_function (file, line, name.c_str (),\n+\t\t\t\t   argc, (const char **) argv,\n+\t\t\t\t   p + 1);\n+\t  else if (*p == '\\0')\n+\t    {\n+\t      /* Complain, but do define it.  */\n \t      dwarf2_macro_malformed_definition_complaint (body);\n-              macro_define_function (file, line, name.c_str (),\n-                                     argc, (const char **) argv,\n-                                     p);\n-            }\n-          else\n-            /* Just complain.  */\n+\t      macro_define_function (file, line, name.c_str (),\n+\t\t\t\t     argc, (const char **) argv,\n+\t\t\t\t     p);\n+\t    }\n+\t  else\n+\t    /* Just complain.  */\n \t    dwarf2_macro_malformed_definition_complaint (body);\n-        }\n+\t}\n       else\n-        /* Just complain.  */\n+\t/* Just complain.  */\n \tdwarf2_macro_malformed_definition_complaint (body);\n \n       {\n-        int i;\n+\tint i;\n \n-        for (i = 0; i < argc; i++)\n-          xfree (argv[i]);\n+\tfor (i = 0; i < argc; i++)\n+\t  xfree (argv[i]);\n       }\n       xfree (argv);\n     }\n@@ -477,16 +477,16 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \tcase 0:\n \t  break;\n \n-        case DW_MACRO_define:\n-        case DW_MACRO_undef:\n+\tcase DW_MACRO_define:\n+\tcase DW_MACRO_undef:\n \tcase DW_MACRO_define_strp:\n \tcase DW_MACRO_undef_strp:\n \tcase DW_MACRO_define_sup:\n \tcase DW_MACRO_undef_sup:\n-          {\n-            unsigned int bytes_read;\n-            int line;\n-            const char *body;\n+\t  {\n+\t    unsigned int bytes_read;\n+\t    int line;\n+\t    const char *body;\n \t    int is_define;\n \n \t    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);\n@@ -522,7 +522,7 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t    is_define = (macinfo_type == DW_MACRO_define\n \t\t\t || macinfo_type == DW_MACRO_define_strp\n \t\t\t || macinfo_type == DW_MACRO_define_sup);\n-            if (! current_file)\n+\t    if (! current_file)\n \t      {\n \t\t/* DWARF violation as no main source is present.  */\n \t\tcomplaint (_(\"debug info with no main source gives macro %s \"\n@@ -561,8 +561,8 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t\t\t    || macinfo_type == DW_MACRO_undef_sup);\n \t\tmacro_undef (current_file, line, body);\n \t      }\n-          }\n-          break;\n+\t  }\n+\t  break;\n \n \tcase DW_MACRO_define_strx:\n \tcase DW_MACRO_undef_strx:\n@@ -611,15 +611,15 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t   }\n \t   break;\n \n-        case DW_MACRO_start_file:\n-          {\n-            unsigned int bytes_read;\n-            int line, file;\n+\tcase DW_MACRO_start_file:\n+\t  {\n+\t    unsigned int bytes_read;\n+\t    int line, file;\n \n-            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);\n-            mac_ptr += bytes_read;\n-            file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);\n-            mac_ptr += bytes_read;\n+\t    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);\n+\t    mac_ptr += bytes_read;\n+\t    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);\n+\t    mac_ptr += bytes_read;\n \n \t    if ((line == 0 && !at_commandline)\n \t\t|| (line != 0 && at_commandline))\n@@ -637,45 +637,45 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t    else\n \t      current_file = macro_start_file (builder, file, line,\n \t\t\t\t\t       current_file, lh);\n-          }\n-          break;\n+\t  }\n+\t  break;\n \n-        case DW_MACRO_end_file:\n-          if (! current_file)\n+\tcase DW_MACRO_end_file:\n+\t  if (! current_file)\n \t    complaint (_(\"macro debug info has an unmatched \"\n \t\t\t \"`close_file' directive\"));\n-          else\n-            {\n-              current_file = current_file->included_by;\n-              if (! current_file)\n-                {\n-                  enum dwarf_macro_record_type next_type;\n-\n-                  /* GCC circa March 2002 doesn't produce the zero\n-                     type byte marking the end of the compilation\n-                     unit.  Complain if it's not there, but exit no\n-                     matter what.  */\n-\n-                  /* Do we at least have room for a macinfo type byte?  */\n-                  if (mac_ptr >= mac_end)\n-                    {\n+\t  else\n+\t    {\n+\t      current_file = current_file->included_by;\n+\t      if (! current_file)\n+\t\t{\n+\t\t  enum dwarf_macro_record_type next_type;\n+\n+\t\t  /* GCC circa March 2002 doesn't produce the zero\n+\t\t     type byte marking the end of the compilation\n+\t\t     unit.  Complain if it's not there, but exit no\n+\t\t     matter what.  */\n+\n+\t\t  /* Do we at least have room for a macinfo type byte?  */\n+\t\t  if (mac_ptr >= mac_end)\n+\t\t    {\n \t\t      section->overflow_complaint ();\n-                      return;\n-                    }\n+\t\t      return;\n+\t\t    }\n \n-                  /* We don't increment mac_ptr here, so this is just\n-                     a look-ahead.  */\n-                  next_type\n+\t\t  /* We don't increment mac_ptr here, so this is just\n+\t\t     a look-ahead.  */\n+\t\t  next_type\n \t\t    = (enum dwarf_macro_record_type) read_1_byte (abfd,\n \t\t\t\t\t\t\t\t  mac_ptr);\n-                  if (next_type != 0)\n+\t\t  if (next_type != 0)\n \t\t    complaint (_(\"no terminating 0-type entry for \"\n \t\t\t\t \"macros in `.debug_macinfo' section\"));\n \n-                  return;\n-                }\n-            }\n-          break;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  break;\n \n \tcase DW_MACRO_import:\n \tcase DW_MACRO_import_sup:\n@@ -729,7 +729,7 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t  }\n \t  break;\n \n-        case DW_MACINFO_vendor_ext:\n+\tcase DW_MACINFO_vendor_ext:\n \t  if (!section_is_gnu)\n \t    {\n \t      unsigned int bytes_read;\n@@ -753,7 +753,7 @@ dwarf_decode_macro_bytes (dwarf2_per_objfile *per_objfile,\n \t  if (mac_ptr == NULL)\n \t    return;\n \t  break;\n-        }\n+\t}\n       DIAGNOSTIC_POP\n     } while (macinfo_type != 0);\n }\n@@ -802,12 +802,12 @@ dwarf_decode_macros (dwarf2_per_objfile *per_objfile,\n     {\n       /* Do we at least have room for a macinfo type byte?  */\n       if (mac_ptr >= mac_end)\n-        {\n+\t{\n \t  /* Complaint is printed during the second pass as GDB will probably\n \t     stop the first pass earlier upon finding\n \t     DW_MACINFO_start_file.  */\n \t  break;\n-        }\n+\t}\n \n       macinfo_type = (enum dwarf_macro_record_type) read_1_byte (abfd, mac_ptr);\n       mac_ptr++;\n@@ -817,10 +817,10 @@ dwarf_decode_macros (dwarf2_per_objfile *per_objfile,\n       DIAGNOSTIC_PUSH\n       DIAGNOSTIC_IGNORE_SWITCH_DIFFERENT_ENUM_TYPES\n       switch (macinfo_type)\n-        {\n-          /* A zero macinfo type indicates the end of the macro\n-             information.  */\n-        case 0:\n+\t{\n+\t  /* A zero macinfo type indicates the end of the macro\n+\t     information.  */\n+\tcase 0:\n \t  break;\n \n \tcase DW_MACRO_define:"
    },
    {
      "sha": "7d258f30eba7a5376c9ff4290c6142c0cae5020c",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 345,
      "deletions": 345,
      "changes": 690,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1337,12 +1337,12 @@ static struct attribute *dwarf2_attr (struct die_info *, unsigned int,\n \t\t\t\t      struct dwarf2_cu *);\n \n static const char *dwarf2_string_attr (struct die_info *die, unsigned int name,\n-                                       struct dwarf2_cu *cu);\n+\t\t\t\t       struct dwarf2_cu *cu);\n \n static const char *dwarf2_dwo_name (struct die_info *die, struct dwarf2_cu *cu);\n \n static int dwarf2_flag_true_p (struct die_info *die, unsigned name,\n-                               struct dwarf2_cu *cu);\n+\t\t\t       struct dwarf2_cu *cu);\n \n static int die_is_declaration (struct die_info *, struct dwarf2_cu *cu);\n \n@@ -1446,7 +1446,7 @@ static void get_scope_pc_bounds (struct die_info *,\n \t\t\t\t struct dwarf2_cu *);\n \n static void dwarf2_record_block_ranges (struct die_info *, struct block *,\n-                                        CORE_ADDR, struct dwarf2_cu *);\n+\t\t\t\t\tCORE_ADDR, struct dwarf2_cu *);\n \n static void dwarf2_add_field (struct field_info *, struct die_info *,\n \t\t\t      struct dwarf2_cu *);\n@@ -1892,7 +1892,7 @@ dwarf2_per_objfile::set_symtab (const dwarf2_per_cu_data *per_cu,\n \n int\n dwarf2_has_info (struct objfile *objfile,\n-                 const struct dwarf2_debug_sections *names,\n+\t\t const struct dwarf2_debug_sections *names,\n \t\t bool can_copy)\n {\n   if (objfile->flags & OBJF_READNEVER)\n@@ -1905,7 +1905,7 @@ dwarf2_has_info (struct objfile *objfile,\n       dwarf2_per_bfd *per_bfd;\n \n       /* We can share a \"dwarf2_per_bfd\" with other objfiles if the BFD\n-         doesn't require relocations and if there aren't partial symbols\n+\t doesn't require relocations and if there aren't partial symbols\n \t from some other reader.  */\n       if (!objfile_has_partial_symbols (objfile)\n \t  && !gdb_bfd_requires_relocations (objfile->obfd))\n@@ -1941,7 +1941,7 @@ dwarf2_has_info (struct objfile *objfile,\n \n static int\n section_is_p (const char *section_name,\n-              const struct dwarf2_section_names *names)\n+\t      const struct dwarf2_section_names *names)\n {\n   if (names->normal != NULL\n       && strcmp (section_name, names->normal) == 0)\n@@ -2083,9 +2083,9 @@ dwarf2_per_bfd::locate_sections (bfd *abfd, asection *sectp,\n \n void\n dwarf2_get_section_info (struct objfile *objfile,\n-                         enum dwarf2_section_enum sect,\n-                         asection **sectp, const gdb_byte **bufp,\n-                         bfd_size_type *sizep)\n+\t\t\t enum dwarf2_section_enum sect,\n+\t\t\t asection **sectp, const gdb_byte **bufp,\n+\t\t\t bfd_size_type *sizep)\n {\n   dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n   struct dwarf2_section_info *info;\n@@ -2796,7 +2796,7 @@ create_addrmap_from_aranges (dwarf2_per_objfile *per_objfile,\n       if (addr + entry_length > section->buffer + section->size)\n \t{\n \t  warning (_(\"Section .debug_aranges in %s entry at offset %s \"\n-\t             \"length %s exceeds section length %s, \"\n+\t\t     \"length %s exceeds section length %s, \"\n \t\t     \"ignoring .debug_aranges.\"),\n \t\t   objfile_name (objfile),\n \t\t   plongest (entry_addr - section->buffer),\n@@ -2857,11 +2857,11 @@ create_addrmap_from_aranges (dwarf2_per_objfile *per_objfile,\n \t}\n \n       /* Must pad to an alignment boundary that is twice the address\n-         size.  It is undocumented by the DWARF standard but GCC does\n-         use it.  */\n+\t size.  It is undocumented by the DWARF standard but GCC does\n+\t use it.  */\n       for (size_t padding = ((-(addr - section->buffer))\n \t\t\t     & (2 * address_size - 1));\n-           padding > 0; padding--)\n+\t   padding > 0; padding--)\n \tif (*addr++ != 0)\n \t  {\n \t    warning (_(\"Section .debug_aranges in %s entry at offset %s \"\n@@ -2942,7 +2942,7 @@ find_slot_in_mapped_hash (struct mapped_index *index, const char *name,\n      indices for case insensitive languages are built in lowercase, therefore\n      simulate our NAME being searched is also lowercased.  */\n   hash = mapped_index_string_hash ((index->version == 4\n-                                    && case_sensitivity == case_sensitive_off\n+\t\t\t\t    && case_sensitivity == case_sensitive_off\n \t\t\t\t    ? 5 : index->version),\n \t\t\t\t   name);\n \n@@ -4134,7 +4134,7 @@ dw2_expand_symtabs_matching_symbol\n \t= lang->get_symbol_name_matcher (lookup_name_without_params);\n \n       name_and_matcher key {\n-         name_matcher,\n+\t name_matcher,\n \t lookup_name_without_params.language_lookup_name (lang_e)\n       };\n \n@@ -6272,7 +6272,7 @@ struct dwarf2_include_psymtab : public partial_symtab\n \n static void\n dwarf2_create_include_psymtab (const char *name, dwarf2_psymtab *pst,\n-                               struct objfile *objfile)\n+\t\t\t       struct objfile *objfile)\n {\n   dwarf2_include_psymtab *subpst = new dwarf2_include_psymtab (name, objfile);\n \n@@ -7053,7 +7053,7 @@ cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n   else\n     {\n       /* If an existing_cu is provided, a dwarf2_cu must not exist for this_cu\n-         in per_objfile yet.  */\n+\t in per_objfile yet.  */\n       gdb_assert (per_objfile->get_cu (this_cu) == nullptr);\n       m_new_cu.reset (new dwarf2_cu (this_cu, per_objfile));\n       cu = m_new_cu.get ();\n@@ -7144,7 +7144,7 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n   else\n     {\n       /* If an existing_cu is provided, a dwarf2_cu must not exist for this_cu\n-         in per_objfile yet.  */\n+\t in per_objfile yet.  */\n       gdb_assert (per_objfile->get_cu (this_cu) == nullptr);\n       m_new_cu.reset (new dwarf2_cu (this_cu, per_objfile));\n       cu = m_new_cu.get ();\n@@ -7284,7 +7284,7 @@ cutu_reader::keep ()\n   if (m_new_cu != NULL)\n     {\n       /* Save this dwarf2_cu in the per_objfile.  The per_objfile owns it\n-         now.  */\n+\t now.  */\n       dwarf2_per_objfile *per_objfile = m_new_cu->per_objfile;\n       per_objfile->set_cu (m_this_cu, m_new_cu.release ());\n     }\n@@ -8259,9 +8259,9 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \t\tadd_partial_enumeration (pdi, cu);\n \t      break;\n \t    case DW_TAG_base_type:\n-            case DW_TAG_subrange_type:\n+\t    case DW_TAG_subrange_type:\n \t      /* File scope base type definitions are added to the partial\n-\t         symbol table.  */\n+\t\t symbol table.  */\n \t      add_partial_symbol (pdi, cu);\n \t      break;\n \t    case DW_TAG_namespace:\n@@ -8494,10 +8494,10 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \t      && pdi->die_parent != NULL\n \t      && pdi->die_parent->tag == DW_TAG_subprogram))\n \t{\n-          /* Normally, only \"external\" DIEs are part of the global scope.\n-             But in Ada and Fortran, we want to be able to access nested\n-             procedures globally.  So all Ada and Fortran subprograms are\n-             stored in the global scope.  */\n+\t  /* Normally, only \"external\" DIEs are part of the global scope.\n+\t     But in Ada and Fortran, we want to be able to access nested\n+\t     procedures globally.  So all Ada and Fortran subprograms are\n+\t     stored in the global scope.  */\n \t  where = psymbol_placement::GLOBAL;\n \t}\n       else\n@@ -8587,8 +8587,8 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n       break;\n     case DW_TAG_module:\n       /* With Fortran 77 there might be a \"BLOCK DATA\" module\n-         available without any name.  If so, we skip the module as it\n-         doesn't bring any value.  */\n+\t available without any name.  If so, we skip the module as it\n+\t doesn't bring any value.  */\n       if (actual_name != nullptr)\n \t{\n \t  psymbol.domain = MODULE_DOMAIN;\n@@ -8602,10 +8602,10 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n     case DW_TAG_union_type:\n     case DW_TAG_enumeration_type:\n       /* Skip external references.  The DWARF standard says in the section\n-         about \"Structure, Union, and Class Type Entries\": \"An incomplete\n-         structure, union or class type is represented by a structure,\n-         union or class entry that does not have a byte size attribute\n-         and that has a DW_AT_declaration attribute.\"  */\n+\t about \"Structure, Union, and Class Type Entries\": \"An incomplete\n+\t structure, union or class type is represented by a structure,\n+\t union or class entry that does not have a byte size attribute\n+\t and that has a DW_AT_declaration attribute.\"  */\n       if (!pdi->has_byte_size && pdi->is_declaration)\n \treturn;\n \n@@ -8699,11 +8699,11 @@ add_partial_subprogram (struct partial_die_info *pdi,\n   if (pdi->tag == DW_TAG_subprogram || pdi->tag == DW_TAG_inlined_subroutine)\n     {\n       if (pdi->has_pc_info)\n-        {\n-          if (pdi->lowpc < *lowpc)\n-            *lowpc = pdi->lowpc;\n-          if (pdi->highpc > *highpc)\n-            *highpc = pdi->highpc;\n+\t{\n+\t  if (pdi->lowpc < *lowpc)\n+\t    *lowpc = pdi->lowpc;\n+\t  if (pdi->highpc > *highpc)\n+\t    *highpc = pdi->highpc;\n \t  if (set_addrmap)\n \t    {\n \t      struct objfile *objfile = cu->per_objfile->objfile;\n@@ -8725,17 +8725,17 @@ add_partial_subprogram (struct partial_die_info *pdi,\n \t\t\t\t this_lowpc, this_highpc - 1,\n \t\t\t\t cu->per_cu->v.psymtab);\n \t    }\n-        }\n+\t}\n \n       if (pdi->has_pc_info || (!pdi->is_external && pdi->may_be_inlined))\n \t{\n-          if (!pdi->is_declaration)\n+\t  if (!pdi->is_declaration)\n \t    /* Ignore subprogram DIEs that do not have a name, they are\n \t       illegal.  Do not emit a complaint at this point, we will\n \t       do so when we convert this psymtab into a symtab.  */\n \t    if (pdi->name (cu))\n \t      add_partial_symbol (pdi, cu);\n-        }\n+\t}\n     }\n \n   if (! pdi->has_children)\n@@ -10211,7 +10211,7 @@ process_die (struct die_info *die, struct dwarf2_cu *cu)\n     case DW_TAG_subrange_type:\n     case DW_TAG_typedef:\n       /* Add a typedef symbol for the type definition, if it has a\n-         DW_AT_name.  */\n+\t DW_AT_name.  */\n       new_symbol (die, read_type_die (die, cu), cu);\n       break;\n     case DW_TAG_common_block:\n@@ -10809,36 +10809,36 @@ read_import_statement (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       /* GCC bug: https://bugzilla.redhat.com/show_bug.cgi?id=506524\n \n-        The import in the following code:\n-        namespace A\n-          {\n-            typedef int B;\n-          }\n-\n-        int main ()\n-          {\n-            using A::B;\n-            B b;\n-            return b;\n-          }\n-\n-        ...\n-         <2><51>: Abbrev Number: 3 (DW_TAG_imported_declaration)\n-            <52>   DW_AT_decl_file   : 1\n-            <53>   DW_AT_decl_line   : 6\n-            <54>   DW_AT_import      : <0x75>\n-         <2><58>: Abbrev Number: 4 (DW_TAG_typedef)\n-            <59>   DW_AT_name        : B\n-            <5b>   DW_AT_decl_file   : 1\n-            <5c>   DW_AT_decl_line   : 2\n-            <5d>   DW_AT_type        : <0x6e>\n-        ...\n-         <1><75>: Abbrev Number: 7 (DW_TAG_base_type)\n-            <76>   DW_AT_byte_size   : 4\n-            <77>   DW_AT_encoding    : 5        (signed)\n-\n-        imports the wrong die ( 0x75 instead of 0x58 ).\n-        This case will be ignored until the gcc bug is fixed.  */\n+\tThe import in the following code:\n+\tnamespace A\n+\t  {\n+\t    typedef int B;\n+\t  }\n+\n+\tint main ()\n+\t  {\n+\t    using A::B;\n+\t    B b;\n+\t    return b;\n+\t  }\n+\n+\t...\n+\t <2><51>: Abbrev Number: 3 (DW_TAG_imported_declaration)\n+\t    <52>   DW_AT_decl_file   : 1\n+\t    <53>   DW_AT_decl_line   : 6\n+\t    <54>   DW_AT_import      : <0x75>\n+\t <2><58>: Abbrev Number: 4 (DW_TAG_typedef)\n+\t    <59>   DW_AT_name        : B\n+\t    <5b>   DW_AT_decl_file   : 1\n+\t    <5c>   DW_AT_decl_line   : 2\n+\t    <5d>   DW_AT_type        : <0x6e>\n+\t...\n+\t <1><75>: Abbrev Number: 7 (DW_TAG_base_type)\n+\t    <76>   DW_AT_byte_size   : 4\n+\t    <77>   DW_AT_encoding    : 5        (signed)\n+\n+\timports the wrong die ( 0x75 instead of 0x58 ).\n+\tThis case will be ignored until the gcc bug is fixed.  */\n       return;\n     }\n \n@@ -11081,7 +11081,7 @@ handle_DW_AT_stmt_list (struct die_info *die, struct dwarf2_cu *cu,\n   else\n     {\n       /* We cannot free any current entry in (*slot) as that struct line_header\n-         may be already used by multiple CUs.  Create only temporary decoded\n+\t may be already used by multiple CUs.  Create only temporary decoded\n \t line_header for this CU - it may happen at most once for each line\n \t number information unit.  And if we're not using line_header_hash\n \t then this is what we want as well.  */\n@@ -12357,7 +12357,7 @@ create_dwo_unit_in_dwp_v2 (dwarf2_per_objfile *per_objfile,\n   dwo_unit->section =\n     XOBNEW (&per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n   *dwo_unit->section = create_dwp_v2_or_v5_section\n-                         (per_objfile,\n+\t\t\t (per_objfile,\n \t\t\t  is_debug_types\n \t\t\t  ? &dwp_file->sections.types\n \t\t\t  : &dwp_file->sections.info,\n@@ -12394,9 +12394,9 @@ create_dwo_unit_in_dwp_v5 (dwarf2_per_objfile *per_objfile,\n   if (dwarf_read_debug)\n     {\n       fprintf_unfiltered (gdb_stdlog, \"Reading %s %s/%s in DWP V5 file: %s\\n\",\n-                          kind,\n-                          pulongest (unit_index), hex_string (signature),\n-                          dwp_file->name);\n+\t\t\t  kind,\n+\t\t\t  pulongest (unit_index), hex_string (signature),\n+\t\t\t  dwp_file->name);\n     }\n \n   /* Fetch the section offsets of this DWO unit.  */\n@@ -12406,51 +12406,51 @@ create_dwo_unit_in_dwp_v5 (dwarf2_per_objfile *per_objfile,\n   for (int i = 0; i < dwp_htab->nr_columns; ++i)\n     {\n       uint32_t offset = read_4_bytes (dbfd,\n-                                      dwp_htab->section_pool.v5.offsets\n-                                      + (((unit_index - 1)\n-                                          * dwp_htab->nr_columns\n-                                          + i)\n-                                         * sizeof (uint32_t)));\n+\t\t\t\t      dwp_htab->section_pool.v5.offsets\n+\t\t\t\t      + (((unit_index - 1)\n+\t\t\t\t\t  * dwp_htab->nr_columns\n+\t\t\t\t\t  + i)\n+\t\t\t\t\t * sizeof (uint32_t)));\n       uint32_t size = read_4_bytes (dbfd,\n-                                    dwp_htab->section_pool.v5.sizes\n-                                    + (((unit_index - 1) * dwp_htab->nr_columns\n-                                        + i)\n-                                       * sizeof (uint32_t)));\n+\t\t\t\t    dwp_htab->section_pool.v5.sizes\n+\t\t\t\t    + (((unit_index - 1) * dwp_htab->nr_columns\n+\t\t\t\t\t+ i)\n+\t\t\t\t       * sizeof (uint32_t)));\n \n       switch (dwp_htab->section_pool.v5.section_ids[i])\n-        {\n-          case DW_SECT_ABBREV_V5:\n-            sections.abbrev_offset = offset;\n-            sections.abbrev_size = size;\n-            break;\n-          case DW_SECT_INFO_V5:\n-            sections.info_or_types_offset = offset;\n-            sections.info_or_types_size = size;\n-            break;\n-          case DW_SECT_LINE_V5:\n-            sections.line_offset = offset;\n-            sections.line_size = size;\n-            break;\n-          case DW_SECT_LOCLISTS_V5:\n-            sections.loclists_offset = offset;\n-            sections.loclists_size = size;\n-            break;\n-          case DW_SECT_MACRO_V5:\n-            sections.macro_offset = offset;\n-            sections.macro_size = size;\n-            break;\n-          case DW_SECT_RNGLISTS_V5:\n-            sections.rnglists_offset = offset;\n-            sections.rnglists_size = size;\n-            break;\n-          case DW_SECT_STR_OFFSETS_V5:\n-            sections.str_offsets_offset = offset;\n-            sections.str_offsets_size = size;\n-            break;\n-          case DW_SECT_RESERVED_V5:\n-          default:\n-            break;\n-        }\n+\t{\n+\t  case DW_SECT_ABBREV_V5:\n+\t    sections.abbrev_offset = offset;\n+\t    sections.abbrev_size = size;\n+\t    break;\n+\t  case DW_SECT_INFO_V5:\n+\t    sections.info_or_types_offset = offset;\n+\t    sections.info_or_types_size = size;\n+\t    break;\n+\t  case DW_SECT_LINE_V5:\n+\t    sections.line_offset = offset;\n+\t    sections.line_size = size;\n+\t    break;\n+\t  case DW_SECT_LOCLISTS_V5:\n+\t    sections.loclists_offset = offset;\n+\t    sections.loclists_size = size;\n+\t    break;\n+\t  case DW_SECT_MACRO_V5:\n+\t    sections.macro_offset = offset;\n+\t    sections.macro_size = size;\n+\t    break;\n+\t  case DW_SECT_RNGLISTS_V5:\n+\t    sections.rnglists_offset = offset;\n+\t    sections.rnglists_size = size;\n+\t    break;\n+\t  case DW_SECT_STR_OFFSETS_V5:\n+\t    sections.str_offsets_offset = offset;\n+\t    sections.str_offsets_size = size;\n+\t    break;\n+\t  case DW_SECT_RESERVED_V5:\n+\t  default:\n+\t    break;\n+\t}\n     }\n \n   /* It's easier for the rest of the code if we fake a struct dwo_file and\n@@ -12464,75 +12464,75 @@ create_dwo_unit_in_dwp_v5 (dwarf2_per_objfile *per_objfile,\n \n   std::string virtual_dwo_name =\n     string_printf (\"virtual-dwo/%ld-%ld-%ld-%ld-%ld-%ld\",\n-                 (long) (sections.abbrev_size ? sections.abbrev_offset : 0),\n-                 (long) (sections.line_size ? sections.line_offset : 0),\n-                 (long) (sections.loclists_size ? sections.loclists_offset : 0),\n-                 (long) (sections.str_offsets_size\n-                            ? sections.str_offsets_offset : 0),\n-                 (long) (sections.macro_size ? sections.macro_offset : 0),\n-                 (long) (sections.rnglists_size ? sections.rnglists_offset: 0));\n+\t\t (long) (sections.abbrev_size ? sections.abbrev_offset : 0),\n+\t\t (long) (sections.line_size ? sections.line_offset : 0),\n+\t\t (long) (sections.loclists_size ? sections.loclists_offset : 0),\n+\t\t (long) (sections.str_offsets_size\n+\t\t\t    ? sections.str_offsets_offset : 0),\n+\t\t (long) (sections.macro_size ? sections.macro_offset : 0),\n+\t\t (long) (sections.rnglists_size ? sections.rnglists_offset: 0));\n   /* Can we use an existing virtual DWO file?  */\n   dwo_file_slot = lookup_dwo_file_slot (per_objfile,\n-                                        virtual_dwo_name.c_str (),\n-                                        comp_dir);\n+\t\t\t\t\tvirtual_dwo_name.c_str (),\n+\t\t\t\t\tcomp_dir);\n   /* Create one if necessary.  */\n   if (*dwo_file_slot == NULL)\n     {\n       if (dwarf_read_debug)\n-        {\n-          fprintf_unfiltered (gdb_stdlog, \"Creating virtual DWO: %s\\n\",\n-                              virtual_dwo_name.c_str ());\n-        }\n+\t{\n+\t  fprintf_unfiltered (gdb_stdlog, \"Creating virtual DWO: %s\\n\",\n+\t\t\t      virtual_dwo_name.c_str ());\n+\t}\n       dwo_file = new struct dwo_file;\n       dwo_file->dwo_name = per_objfile->objfile->intern (virtual_dwo_name);\n       dwo_file->comp_dir = comp_dir;\n       dwo_file->sections.abbrev =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.abbrev,\n-                                     sections.abbrev_offset,\n-                                     sections.abbrev_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.abbrev,\n+\t\t\t\t     sections.abbrev_offset,\n+\t\t\t\t     sections.abbrev_size);\n       dwo_file->sections.line =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.line,\n-                                     sections.line_offset, sections.line_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.line,\n+\t\t\t\t     sections.line_offset, sections.line_size);\n       dwo_file->sections.macro =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.macro,\n-                                     sections.macro_offset,\n-                                     sections.macro_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.macro,\n+\t\t\t\t     sections.macro_offset,\n+\t\t\t\t     sections.macro_size);\n       dwo_file->sections.loclists =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.loclists,\n-                                     sections.loclists_offset,\n-                                     sections.loclists_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.loclists,\n+\t\t\t\t     sections.loclists_offset,\n+\t\t\t\t     sections.loclists_size);\n       dwo_file->sections.rnglists =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.rnglists,\n-                                     sections.rnglists_offset,\n-                                     sections.rnglists_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.rnglists,\n+\t\t\t\t     sections.rnglists_offset,\n+\t\t\t\t     sections.rnglists_size);\n       dwo_file->sections.str_offsets =\n-        create_dwp_v2_or_v5_section (per_objfile,\n-                                     &dwp_file->sections.str_offsets,\n-                                     sections.str_offsets_offset,\n-                                     sections.str_offsets_size);\n+\tcreate_dwp_v2_or_v5_section (per_objfile,\n+\t\t\t\t     &dwp_file->sections.str_offsets,\n+\t\t\t\t     sections.str_offsets_offset,\n+\t\t\t\t     sections.str_offsets_size);\n       /* The \"str\" section is global to the entire DWP file.  */\n       dwo_file->sections.str = dwp_file->sections.str;\n       /* The info or types section is assigned below to dwo_unit,\n-         there's no need to record it in dwo_file.\n-         Also, we can't simply record type sections in dwo_file because\n-         we record a pointer into the vector in dwo_unit.  As we collect more\n-         types we'll grow the vector and eventually have to reallocate space\n-         for it, invalidating all copies of pointers into the previous\n-         contents.  */\n+\t there's no need to record it in dwo_file.\n+\t Also, we can't simply record type sections in dwo_file because\n+\t we record a pointer into the vector in dwo_unit.  As we collect more\n+\t types we'll grow the vector and eventually have to reallocate space\n+\t for it, invalidating all copies of pointers into the previous\n+\t contents.  */\n       *dwo_file_slot = dwo_file;\n     }\n   else\n     {\n       if (dwarf_read_debug)\n-        {\n-          fprintf_unfiltered (gdb_stdlog, \"Using existing virtual DWO: %s\\n\",\n-                              virtual_dwo_name.c_str ());\n-        }\n+\t{\n+\t  fprintf_unfiltered (gdb_stdlog, \"Using existing virtual DWO: %s\\n\",\n+\t\t\t      virtual_dwo_name.c_str ());\n+\t}\n       dwo_file = (struct dwo_file *) *dwo_file_slot;\n     }\n \n@@ -12542,9 +12542,9 @@ create_dwo_unit_in_dwp_v5 (dwarf2_per_objfile *per_objfile,\n   dwo_unit->section\n     = XOBNEW (&per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n   *dwo_unit->section = create_dwp_v2_or_v5_section (per_objfile,\n-                                              &dwp_file->sections.info,\n-                                              sections.info_or_types_offset,\n-                                              sections.info_or_types_size);\n+\t\t\t\t\t      &dwp_file->sections.info,\n+\t\t\t\t\t      sections.info_or_types_offset,\n+\t\t\t\t\t      sections.info_or_types_size);\n   /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */\n \n   return dwo_unit;\n@@ -13450,7 +13450,7 @@ inherit_abstract_dies (struct die_info *die, struct dwarf2_cu *cu)\n \t present in the abstract instance but not referenced in the concrete\n \t one.  */\n       if (child_die->tag == DW_TAG_call_site\n-          || child_die->tag == DW_TAG_GNU_call_site)\n+\t  || child_die->tag == DW_TAG_GNU_call_site)\n \tcontinue;\n \n       /* For each CHILD_DIE, find the corresponding child of\n@@ -13695,7 +13695,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n       templ_func->n_template_arguments = template_args.size ();\n       templ_func->template_arguments\n-        = XOBNEWVEC (&objfile->objfile_obstack, struct symbol *,\n+\t= XOBNEWVEC (&objfile->objfile_obstack, struct symbol *,\n \t\t     templ_func->n_template_arguments);\n       memcpy (templ_func->template_arguments,\n \t      template_args.data (),\n@@ -13784,19 +13784,19 @@ read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)\n       || (*cu->get_builder ()->get_local_using_directives ()) != NULL)\n     {\n       struct block *block\n-        = cu->get_builder ()->finish_block (0, cstk.old_blocks, NULL,\n+\t= cu->get_builder ()->finish_block (0, cstk.old_blocks, NULL,\n \t\t\t\t     cstk.start_addr, highpc);\n \n       /* Note that recording ranges after traversing children, as we\n-         do here, means that recording a parent's ranges entails\n-         walking across all its children's ranges as they appear in\n-         the address map, which is quadratic behavior.\n-\n-         It would be nicer to record the parent's ranges before\n-         traversing its children, simply overriding whatever you find\n-         there.  But since we don't even decide whether to create a\n-         block until after we've traversed its children, that's hard\n-         to do.  */\n+\t do here, means that recording a parent's ranges entails\n+\t walking across all its children's ranges as they appear in\n+\t the address map, which is quadratic behavior.\n+\n+\t It would be nicer to record the parent's ranges before\n+\t traversing its children, simply overriding whatever you find\n+\t there.  But since we don't even decide whether to create a\n+\t block until after we've traversed its children, that's hard\n+\t to do.  */\n       dwarf2_record_block_ranges (die, block, baseaddr, cu);\n     }\n   *cu->get_builder ()->get_local_symbols () = cstk.locals;\n@@ -13859,7 +13859,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n        child_die = child_die->sibling)\n     {\n       if (child_die->tag != DW_TAG_call_site_parameter\n-          && child_die->tag != DW_TAG_GNU_call_site_parameter)\n+\t  && child_die->tag != DW_TAG_GNU_call_site_parameter)\n \t{\n \t  complaint (_(\"Tag %d is not DW_TAG_call_site_parameter in \"\n \t\t       \"DW_TAG_call_site child DIE %s [in module %s]\"),\n@@ -13894,8 +13894,8 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n       /* DW_AT_call_all_calls is a superset\n \t of DW_AT_call_all_tail_calls.  */\n       if (func_die\n-          && !dwarf2_flag_true_p (func_die, DW_AT_call_all_calls, cu)\n-          && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_call_sites, cu)\n+\t  && !dwarf2_flag_true_p (func_die, DW_AT_call_all_calls, cu)\n+\t  && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_call_sites, cu)\n \t  && !dwarf2_flag_true_p (func_die, DW_AT_call_all_tail_calls, cu)\n \t  && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_tail_call_sites, cu))\n \t{\n@@ -13972,7 +13972,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t    target_physname = dwarf2_physname (NULL, target_die, target_cu);\n \t  if (target_physname == NULL)\n \t    complaint (_(\"DW_AT_call_target target DIE has invalid \"\n-\t\t         \"physname, for referencing DIE %s [in module %s]\"),\n+\t\t\t \"physname, for referencing DIE %s [in module %s]\"),\n \t\t       sect_offset_str (die->sect_off), objfile_name (objfile));\n \t  else\n \t    SET_FIELD_PHYSNAME (call_site->target, target_physname);\n@@ -13985,7 +13985,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t  if (dwarf2_get_pc_bounds (target_die, &lowpc, NULL, target_cu, NULL)\n \t      <= PC_BOUNDS_INVALID)\n \t    complaint (_(\"DW_AT_call_target target DIE has invalid \"\n-\t\t         \"low pc, for referencing DIE %s [in module %s]\"),\n+\t\t\t \"low pc, for referencing DIE %s [in module %s]\"),\n \t\t       sect_offset_str (die->sect_off), objfile_name (objfile));\n \t  else\n \t    {\n@@ -14010,7 +14010,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n       struct attribute *loc, *origin;\n \n       if (child_die->tag != DW_TAG_call_site_parameter\n-          && child_die->tag != DW_TAG_GNU_call_site_parameter)\n+\t  && child_die->tag != DW_TAG_GNU_call_site_parameter)\n \t{\n \t  /* Already printed the complaint above.  */\n \t  continue;\n@@ -14251,11 +14251,11 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t  base = cu->header.read_address (obfd, buffer, &bytes_read);\n \t  buffer += bytes_read;\n \t  break;\n-        case DW_RLE_base_addressx:\n-          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n-          buffer += bytes_read;\n-          base = read_addr_index (cu, addr_index);\n-          break;\n+\tcase DW_RLE_base_addressx:\n+\t  addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+\t  buffer += bytes_read;\n+\t  base = read_addr_index (cu, addr_index);\n+\t  break;\n \tcase DW_RLE_start_length:\n \t  if (buffer + cu->header.addr_size > buf_end)\n \t    {\n@@ -14275,18 +14275,18 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t    }\n \t  break;\n \tcase DW_RLE_startx_length:\n-          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n-          buffer += bytes_read;\n-          range_beginning = read_addr_index (cu, addr_index);\n-          if (buffer > buf_end)\n-            {\n-              overflow = true;\n-              break;\n-            }\n-          range_end = (range_beginning\n-                       + read_unsigned_leb128 (obfd, buffer, &bytes_read));\n-          buffer += bytes_read;\n-          break;\n+\t  addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+\t  buffer += bytes_read;\n+\t  range_beginning = read_addr_index (cu, addr_index);\n+\t  if (buffer > buf_end)\n+\t    {\n+\t      overflow = true;\n+\t      break;\n+\t    }\n+\t  range_end = (range_beginning\n+\t\t       + read_unsigned_leb128 (obfd, buffer, &bytes_read));\n+\t  buffer += bytes_read;\n+\t  break;\n \tcase DW_RLE_offset_pair:\n \t  range_beginning = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n \t  buffer += bytes_read;\n@@ -14316,18 +14316,18 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t  buffer += bytes_read;\n \t  break;\n \tcase DW_RLE_startx_endx:\n-          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n-          buffer += bytes_read;\n-          range_beginning = read_addr_index (cu, addr_index);\n-          if (buffer > buf_end)\n-            {\n-              overflow = true;\n-              break;\n-            }\n-          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n-          buffer += bytes_read;\n-          range_end = read_addr_index (cu, addr_index);\n-          break;\n+\t  addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+\t  buffer += bytes_read;\n+\t  range_beginning = read_addr_index (cu, addr_index);\n+\t  if (buffer > buf_end)\n+\t    {\n+\t      overflow = true;\n+\t      break;\n+\t    }\n+\t  addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+\t  buffer += bytes_read;\n+\t  range_end = read_addr_index (cu, addr_index);\n+\t  break;\n \tdefault:\n \t  complaint (_(\"Invalid .debug_rnglists data (no base address)\"));\n \t  return false;\n@@ -14578,7 +14578,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n       if (attr != nullptr)\n-        {\n+\t{\n \t  low = attr->as_address ();\n \t  high = attr_high->as_address ();\n \t  if (cu->header.version >= 4 && attr_high->form_is_constant ())\n@@ -14651,8 +14651,8 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n \n static void\n dwarf2_get_subprogram_pc_bounds (struct die_info *die,\n-                                 CORE_ADDR *lowpc, CORE_ADDR *highpc,\n-                                 struct dwarf2_cu *cu)\n+\t\t\t\t CORE_ADDR *lowpc, CORE_ADDR *highpc,\n+\t\t\t\t struct dwarf2_cu *cu)\n {\n   CORE_ADDR low, high;\n   struct die_info *child = die->child;\n@@ -14675,8 +14675,8 @@ dwarf2_get_subprogram_pc_bounds (struct die_info *die,\n   while (child && child->tag)\n     {\n       if (child->tag == DW_TAG_subprogram\n-          || child->tag == DW_TAG_lexical_block)\n-        dwarf2_get_subprogram_pc_bounds (child, lowpc, highpc, cu);\n+\t  || child->tag == DW_TAG_lexical_block)\n+\tdwarf2_get_subprogram_pc_bounds (child, lowpc, highpc, cu);\n       child = child->sibling;\n     }\n }\n@@ -14708,7 +14708,7 @@ get_scope_pc_bounds (struct die_info *die,\n \t{\n \t  switch (child->tag) {\n \t  case DW_TAG_subprogram:\n-            dwarf2_get_subprogram_pc_bounds (child, &best_low, &best_high, cu);\n+\t    dwarf2_get_subprogram_pc_bounds (child, &best_low, &best_high, cu);\n \t    break;\n \t  case DW_TAG_namespace:\n \t  case DW_TAG_module:\n@@ -14746,7 +14746,7 @@ get_scope_pc_bounds (struct die_info *die,\n \n static void\n dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n-                            CORE_ADDR baseaddr, struct dwarf2_cu *cu)\n+\t\t\t    CORE_ADDR baseaddr, struct dwarf2_cu *cu)\n {\n   struct objfile *objfile = cu->per_objfile->objfile;\n   struct gdbarch *gdbarch = objfile->arch ();\n@@ -14758,7 +14758,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n       if (attr != nullptr)\n-        {\n+\t{\n \t  CORE_ADDR low = attr->as_address ();\n \t  CORE_ADDR high = attr_high->as_address ();\n \n@@ -14768,7 +14768,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n \t  low = gdbarch_adjust_dwarf2_addr (gdbarch, low + baseaddr);\n \t  high = gdbarch_adjust_dwarf2_addr (gdbarch, high + baseaddr);\n \t  cu->get_builder ()->record_block_range (block, low, high - 1);\n-        }\n+\t}\n     }\n \n   attr = dwarf2_attr (die, DW_AT_ranges, cu);\n@@ -14786,7 +14786,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n \t\t\t      && attr->form != DW_FORM_rnglistx);\n \n       /* The value of the DW_AT_ranges attribute is the offset of the\n-         address range list in the .debug_ranges section.  */\n+\t address range list in the .debug_ranges section.  */\n       unsigned long offset = (attr->as_unsigned ()\n \t\t\t      + (need_ranges_base ? cu->ranges_base : 0));\n \n@@ -15063,21 +15063,21 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n \t    {\n \t      /* For big endian bits, the DW_AT_bit_offset gives the\n-\t         additional bit offset from the MSB of the containing\n-\t         anonymous object to the MSB of the field.  We don't\n-\t         have to do anything special since we don't need to\n-\t         know the size of the anonymous object.  */\n+\t\t additional bit offset from the MSB of the containing\n+\t\t anonymous object to the MSB of the field.  We don't\n+\t\t have to do anything special since we don't need to\n+\t\t know the size of the anonymous object.  */\n \t      SET_FIELD_BITPOS (*fp, (FIELD_BITPOS (*fp)\n \t\t\t\t      + attr->constant_value (0)));\n \t    }\n \t  else\n \t    {\n \t      /* For little endian bits, compute the bit offset to the\n-\t         MSB of the anonymous object, subtract off the number of\n-\t         bits from the MSB of the field to the MSB of the\n-\t         object, and then subtract off the number of bits of\n-\t         the field itself.  The result is the bit offset of\n-\t         the LSB of the field.  */\n+\t\t MSB of the anonymous object, subtract off the number of\n+\t\t bits from the MSB of the field to the MSB of the\n+\t\t object, and then subtract off the number of bits of\n+\t\t the field itself.  The result is the bit offset of\n+\t\t the LSB of the field.  */\n \t      int anonymous_size;\n \t      int bit_offset = attr->constant_value (0);\n \n@@ -15118,7 +15118,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       fp->name = fieldname;\n \n       /* Change accessibility for artificial fields (e.g. virtual table\n-         pointer or virtual base class pointer) to private.  */\n+\t pointer or virtual base class pointer) to private.  */\n       if (dwarf2_attr (die, DW_AT_artificial, cu))\n \t{\n \t  FIELD_ARTIFICIAL (*fp) = 1;\n@@ -15618,11 +15618,11 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \t\t\t    this_type->has_varargs ());\n \n       /* Handle static member functions.\n-         Dwarf2 has no clean way to discern C++ static and non-static\n-         member functions.  G++ helps GDB by marking the first\n-         parameter for non-static member functions (which is the this\n-         pointer) as artificial.  We obtain this information from\n-         read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */\n+\t Dwarf2 has no clean way to discern C++ static and non-static\n+\t member functions.  G++ helps GDB by marking the first\n+\t parameter for non-static member functions (which is the this\n+\t pointer) as artificial.  We obtain this information from\n+\t read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */\n       if (nparams == 0 || TYPE_FIELD_ARTIFICIAL (this_type, 0) == 0)\n \tfnp->voffset = VOFFSET_STATIC;\n     }\n@@ -15676,7 +15676,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n   if (attr != nullptr)\n     {\n       if (attr->form_is_block () && attr->as_block ()->size > 0)\n-        {\n+\t{\n \t  struct dwarf_block *block = attr->as_block ();\n \n \t  if (block->data[0] == DW_OP_constu)\n@@ -15719,14 +15719,14 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \t    }\n \t}\n       else if (attr->form_is_section_offset ())\n-        {\n+\t{\n \t  dwarf2_complex_location_expr_complaint ();\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  dwarf2_invalid_attrib_class_complaint (\"DW_AT_vtable_elem_location\",\n \t\t\t\t\t\t fieldname);\n-        }\n+\t}\n     }\n   else\n     {\n@@ -16037,13 +16037,13 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (attr != nullptr)\n     {\n       if (attr->form_is_constant ())\n-        TYPE_LENGTH (type) = attr->constant_value (0);\n+\tTYPE_LENGTH (type) = attr->constant_value (0);\n       else\n \t{\n \t  struct dynamic_prop prop;\n \t  if (attr_to_dynamic_prop (attr, die, cu, &prop, cu->addr_type ()))\n \t    type->add_dyn_prop (DYN_PROP_BYTE_SIZE, prop);\n-          TYPE_LENGTH (type) = 0;\n+\t  TYPE_LENGTH (type) = 0;\n \t}\n     }\n   else\n@@ -16330,7 +16330,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t    {\n \t\t      const char *fieldname = TYPE_FIELD_NAME (t, i);\n \n-                      if (is_vtable_name (fieldname, cu))\n+\t\t      if (is_vtable_name (fieldname, cu))\n \t\t\t{\n \t\t\t  set_type_vptr_fieldno (type, i);\n \t\t\t  break;\n@@ -16352,8 +16352,8 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t   && startswith (cu->producer, \"IBM(R) XL C/C++ Advanced Edition\"))\n \t    {\n \t      /* The IBM XLC compiler does not provide direct indication\n-\t         of the containing type, but the vtable pointer is\n-\t         always named __vfp.  */\n+\t\t of the containing type, but the vtable pointer is\n+\t\t always named __vfp.  */\n \n \t      int i;\n \n@@ -16773,12 +16773,12 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n \t{\n \t  struct type *child_type = read_type_die (child_die, cu);\n \n-          if (child_type != NULL)\n-            {\n+\t  if (child_type != NULL)\n+\t    {\n \t      /* The range type was succesfully read.  Save it for the\n-                 array type creation.  */\n+\t\t array type creation.  */\n \t      range_types.push_back (child_type);\n-            }\n+\t    }\n \t}\n       child_die = child_die->sibling;\n     }\n@@ -16996,20 +16996,20 @@ read_common_block (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       /* Support the .debug_loc offsets.  */\n       if (attr->form_is_block ())\n-        {\n+\t{\n \t  /* Ok.  */\n-        }\n+\t}\n       else if (attr->form_is_section_offset ())\n-        {\n+\t{\n \t  dwarf2_complex_location_expr_complaint ();\n \t  attr = NULL;\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  dwarf2_invalid_attrib_class_complaint (\"DW_AT_location\",\n \t\t\t\t\t\t \"common block member\");\n \t  attr = NULL;\n-        }\n+\t}\n     }\n \n   if (die->child != NULL)\n@@ -17346,7 +17346,7 @@ read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)\n \n static struct type *\n read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu,\n-                          enum type_code refcode)\n+\t\t\t  enum type_code refcode)\n {\n   struct comp_unit_head *cu_header = &cu->header;\n   struct type *type, *target_type;\n@@ -17678,8 +17678,8 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n       int nparams, iparams;\n \n       /* Count the number of parameters.\n-         FIXME: GDB currently ignores vararg functions, but knows about\n-         vararg member functions.  */\n+\t FIXME: GDB currently ignores vararg functions, but knows about\n+\t vararg member functions.  */\n       nparams = 0;\n       child_die = die->child;\n       while (child_die && child_die->tag)\n@@ -18993,12 +18993,12 @@ partial_die_info::read (const struct die_reader_specs *reader,\n       attribute attr;\n       info_ptr = read_attribute (reader, &attr, &abbrev.attrs[i], info_ptr);\n       /* String and address offsets that need to do the reprocessing have\n-         already been read at this point, so there is no need to wait until\n+\t already been read at this point, so there is no need to wait until\n \t the loop terminates to do the reprocessing.  */\n       if (attr.requires_reprocessing_p ())\n \tread_attribute_reprocess (reader, &attr, tag);\n       /* Store the data if it is of an attribute we want to keep in a\n-         partial symbol table.  */\n+\t partial symbol table.  */\n       switch (attr.name)\n \t{\n \tcase DW_AT_name:\n@@ -19040,20 +19040,20 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t\thigh_pc_relative = 1;\n \t  break;\n \tcase DW_AT_location:\n-          /* Support the .debug_loc offsets.  */\n-          if (attr.form_is_block ())\n-            {\n+\t  /* Support the .debug_loc offsets.  */\n+\t  if (attr.form_is_block ())\n+\t    {\n \t      d.locdesc = attr.as_block ();\n-            }\n-          else if (attr.form_is_section_offset ())\n-            {\n+\t    }\n+\t  else if (attr.form_is_section_offset ())\n+\t    {\n \t      dwarf2_complex_location_expr_complaint ();\n-            }\n-          else\n-            {\n+\t    }\n+\t  else\n+\t    {\n \t      dwarf2_invalid_attrib_class_complaint (\"DW_AT_location\",\n \t\t\t\t\t\t     \"partial symbol information\");\n-            }\n+\t    }\n \t  break;\n \tcase DW_AT_external:\n \t  is_external = attr.as_boolean ();\n@@ -19091,12 +19091,12 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t\tsibling = sibling_ptr;\n \t    }\n \t  break;\n-        case DW_AT_byte_size:\n-          has_byte_size = 1;\n-          break;\n-        case DW_AT_const_value:\n-          has_const_value = 1;\n-          break;\n+\tcase DW_AT_byte_size:\n+\t  has_byte_size = 1;\n+\t  break;\n+\tcase DW_AT_const_value:\n+\t  has_const_value = 1;\n+\t  break;\n \tcase DW_AT_calling_convention:\n \t  /* DWARF doesn't provide a way to identify a program's source-level\n \t     entry point.  DW_AT_calling_convention attributes are only meant\n@@ -19145,7 +19145,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t       does not appear in DW_TAG_compile_unit of DWO files.\n \n \t       Attributes of the form DW_FORM_rnglistx have already had\n-               their value changed by read_rnglist_index and already\n+\t       their value changed by read_rnglist_index and already\n \t       include DW_AT_rnglists_base, so don't need to add the ranges\n \t       base, either.  */\n \t    int need_ranges_base = (tag != DW_TAG_compile_unit\n@@ -19539,18 +19539,18 @@ read_loclist_index (struct dwarf2_cu *cu, ULONGEST loclist_index)\n   section->read (objfile);\n   if (section->buffer == NULL)\n     complaint (_(\"DW_FORM_loclistx used without .debug_loclists \"\n-\t        \"section [in module %s]\"), objfile_name (objfile));\n+\t\t\"section [in module %s]\"), objfile_name (objfile));\n   struct loclists_rnglists_header header;\n   read_loclists_rnglists_header (&header, section);\n   if (loclist_index >= header.offset_entry_count)\n     complaint (_(\"DW_FORM_loclistx pointing outside of \"\n-\t        \".debug_loclists offset array [in module %s]\"),\n-\t        objfile_name (objfile));\n+\t\t\".debug_loclists offset array [in module %s]\"),\n+\t\tobjfile_name (objfile));\n   if (loclist_base + loclist_index * cu->header.offset_size\n \t>= section->size)\n     complaint (_(\"DW_FORM_loclistx pointing outside of \"\n-\t        \".debug_loclists section [in module %s]\"),\n-\t        objfile_name (objfile));\n+\t\t\".debug_loclists section [in module %s]\"),\n+\t\tobjfile_name (objfile));\n   const gdb_byte *info_ptr\n     = section->buffer + loclist_base + loclist_index * cu->header.offset_size;\n \n@@ -19598,7 +19598,7 @@ read_rnglist_index (struct dwarf2_cu *cu, ULONGEST rnglist_index,\n   /* Validate that the offset is within the section's range.  */\n   if (start_offset >= section->size)\n     error (_(\"DW_FORM_rnglistx pointing outside of \"\n-             \".debug_rnglists section [in module %s]\"),\n+\t     \".debug_rnglists section [in module %s]\"),\n \t   objfile_name (objfile));\n \n   /* Validate that reading won't go beyond the end of the section.  */\n@@ -19630,13 +19630,13 @@ read_attribute_reprocess (const struct die_reader_specs *reader,\n       case DW_FORM_GNU_addr_index:\n \tattr->set_address (read_addr_index (cu,\n \t\t\t\t\t    attr->as_unsigned_reprocess ()));\n-        break;\n+\tbreak;\n       case DW_FORM_loclistx:\n \tattr->set_address (read_loclist_index (cu, attr->as_unsigned ()));\n \t break;\n       case DW_FORM_rnglistx:\n \tattr->set_address (read_rnglist_index (cu, attr->as_unsigned (), tag));\n-        break;\n+\tbreak;\n       case DW_FORM_strx:\n       case DW_FORM_strx1:\n       case DW_FORM_strx2:\n@@ -19931,8 +19931,8 @@ read_attribute_value (const struct die_reader_specs *reader,\n       && attr->as_unsigned () >= 0xffffffff)\n     {\n       complaint\n-        (_(\"Suspicious DW_AT_byte_size value treated as zero instead of %s\"),\n-         hex_string (attr->as_unsigned ()));\n+\t(_(\"Suspicious DW_AT_byte_size value treated as zero instead of %s\"),\n+\t hex_string (attr->as_unsigned ()));\n       attr->set_unsigned (0);\n     }\n \n@@ -20108,12 +20108,12 @@ read_str_index (struct dwarf2_cu *cu,\n     error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n \t   form_name, str_section->get_name (),\n-           sect_offset_str (cu->header.sect_off), objf_name);\n+\t   sect_offset_str (cu->header.sect_off), objf_name);\n   if (str_offsets_section->buffer == NULL)\n     error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n \t   form_name, str_section->get_name (),\n-           sect_offset_str (cu->header.sect_off), objf_name);\n+\t   sect_offset_str (cu->header.sect_off), objf_name);\n   info_ptr = (str_offsets_section->buffer\n \t      + str_offsets_base\n \t      + str_index * cu->header.offset_size);\n@@ -20282,7 +20282,7 @@ dwarf2_string_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *c\n     {\n       str = attr->as_string ();\n       if (str == nullptr)\n-        complaint (_(\"string type expected for attribute %s for \"\n+\tcomplaint (_(\"string type expected for attribute %s for \"\n \t\t     \"DIE at %s in module %s\"),\n \t\t   dwarf_attr_name (name), sect_offset_str (die->sect_off),\n \t\t   objfile_name (cu->per_objfile->objfile));\n@@ -20838,9 +20838,9 @@ lnp_state_machine::record_line (bool end_sequence)\n \t  bool file_changed\n \t    = m_last_subfile != m_cu->get_builder ()->get_current_subfile ();\n \t  bool ignore_this_line\n-           = ((file_changed && !end_sequence && m_last_address == m_address\n-               && !m_is_stmt && m_stmt_at_address)\n-              || (!end_sequence && m_line == 0));\n+\t   = ((file_changed && !end_sequence && m_last_address == m_address\n+\t       && !m_is_stmt && m_stmt_at_address)\n+\t      || (!end_sequence && m_line == 0));\n \n \t  if ((file_changed && !ignore_this_line) || end_sequence)\n \t    {\n@@ -21017,25 +21017,25 @@ dwarf_decode_lines_1 (struct line_header *lh, struct dwarf2_cu *cu,\n \t\t  }\n \t\t  break;\n \t\tcase DW_LNE_define_file:\n-                  {\n-                    const char *cur_file;\n+\t\t  {\n+\t\t    const char *cur_file;\n \t\t    unsigned int mod_time, length;\n \t\t    dir_index dindex;\n \n-                    cur_file = read_direct_string (abfd, line_ptr,\n+\t\t    cur_file = read_direct_string (abfd, line_ptr,\n \t\t\t\t\t\t   &bytes_read);\n-                    line_ptr += bytes_read;\n-                    dindex = (dir_index)\n-                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-                    line_ptr += bytes_read;\n-                    mod_time =\n-                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-                    line_ptr += bytes_read;\n-                    length =\n-                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-                    line_ptr += bytes_read;\n-                    lh->add_file_name (cur_file, dindex, mod_time, length);\n-                  }\n+\t\t    line_ptr += bytes_read;\n+\t\t    dindex = (dir_index)\n+\t\t      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t\t    line_ptr += bytes_read;\n+\t\t    mod_time =\n+\t\t      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t\t    line_ptr += bytes_read;\n+\t\t    length =\n+\t\t      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t\t    line_ptr += bytes_read;\n+\t\t    lh->add_file_name (cur_file, dindex, mod_time, length);\n+\t\t  }\n \t\t  break;\n \t\tcase DW_LNE_set_discriminator:\n \t\t  {\n@@ -21186,17 +21186,17 @@ dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n   if (decode_for_pst_p)\n     {\n       /* Now that we're done scanning the Line Header Program, we can\n-         create the psymtab of each included file.  */\n+\t create the psymtab of each included file.  */\n       for (auto &file_entry : lh->file_names ())\n-        if (file_entry.included_p == 1)\n-          {\n+\tif (file_entry.included_p == 1)\n+\t  {\n \t    gdb::unique_xmalloc_ptr<char> name_holder;\n \t    const char *include_name =\n \t      psymtab_include_file_name (lh, file_entry, pst,\n \t\t\t\t\t comp_dir, &name_holder);\n \t    if (include_name != NULL)\n-              dwarf2_create_include_psymtab (include_name, pst, objfile);\n-          }\n+\t      dwarf2_create_include_psymtab (include_name, pst, objfile);\n+\t  }\n     }\n   else\n     {\n@@ -21325,7 +21325,7 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n       if ((block->data[0] == DW_OP_addr\n \t   && block->size == 1 + cu_header->addr_size)\n \t  || ((block->data[0] == DW_OP_GNU_addr_index\n-               || block->data[0] == DW_OP_addrx)\n+\t       || block->data[0] == DW_OP_addrx)\n \t      && (block->size\n \t\t  == 1 + leb128_size (&block->data[1]))))\n \t{\n@@ -21419,7 +21419,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t}\n \n       /* Default assumptions.\n-         Use the passed type or decode it from the die.  */\n+\t Use the passed type or decode it from the die.  */\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n       if (type != NULL)\n@@ -21480,12 +21480,12 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      || cu->language == language_ada\n \t      || cu->language == language_fortran)\n \t    {\n-              /* Subprograms marked external are stored as a global symbol.\n-                 Ada and Fortran subprograms, whether marked external or\n-                 not, are always stored as a global symbol, because we want\n-                 to be able to access them globally.  For instance, we want\n-                 to be able to break on a nested subprogram without having\n-                 to specify the context.  */\n+\t      /* Subprograms marked external are stored as a global symbol.\n+\t\t Ada and Fortran subprograms, whether marked external or\n+\t\t not, are always stored as a global symbol, because we want\n+\t\t to be able to access them globally.  For instance, we want\n+\t\t to be able to break on a nested subprogram without having\n+\t\t to specify the context.  */\n \t      list_to_add = cu->get_builder ()->get_global_symbols ();\n \t    }\n \t  else\n@@ -21588,11 +21588,11 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  else\n \t    {\n \t      /* We do not know the address of this symbol.\n-\t         If it is an external symbol and we have type information\n-\t         for it, enter the symbol as a LOC_UNRESOLVED symbol.\n-\t         The address of the variable will then be determined from\n-\t         the minimal symbol table whenever the variable is\n-\t         referenced.  */\n+\t\t If it is an external symbol and we have type information\n+\t\t for it, enter the symbol as a LOC_UNRESOLVED symbol.\n+\t\t The address of the variable will then be determined from\n+\t\t the minimal symbol table whenever the variable is\n+\t\t referenced.  */\n \t      attr2 = dwarf2_attr (die, DW_AT_external, cu);\n \n \t      /* Fortran explicitly imports any global symbols to the local\n@@ -21709,7 +21709,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  list_to_add = cu->list_in_scope;\n \t  break;\n \tcase DW_TAG_base_type:\n-        case DW_TAG_subrange_type:\n+\tcase DW_TAG_subrange_type:\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n \t  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n \t  list_to_add = cu->list_in_scope;\n@@ -22410,13 +22410,13 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \t template class <class Enum> Class{};\n \t Class<enum E> class_e;\n \n-         1: DW_TAG_class_type (Class)\n-           2: DW_TAG_enumeration_type (E)\n-             3: DW_TAG_enumerator (enum1:0)\n-             3: DW_TAG_enumerator (enum2:1)\n-             ...\n-           2: DW_TAG_template_type_param\n-              DW_AT_type  DW_FORM_ref_udata (E)\n+\t 1: DW_TAG_class_type (Class)\n+\t   2: DW_TAG_enumeration_type (E)\n+\t     3: DW_TAG_enumerator (enum1:0)\n+\t     3: DW_TAG_enumerator (enum2:1)\n+\t     ...\n+\t   2: DW_TAG_template_type_param\n+\t      DW_AT_type  DW_FORM_ref_udata (E)\n \n \t Besides being broken debug info, it can put GDB into an\n \t infinite loop.  Consider:\n@@ -22513,7 +22513,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \n static char *\n typename_concat (struct obstack *obs, const char *prefix, const char *suffix,\n-                 int physname, struct dwarf2_cu *cu)\n+\t\t int physname, struct dwarf2_cu *cu)\n {\n   const char *lead = \"\";\n   const char *sep;\n@@ -23370,8 +23370,8 @@ follow_die_sig (struct die_info *src_die, const struct attribute *attr,\n   if (sig_type == NULL)\n     {\n       error (_(\"Dwarf Error: Cannot find signatured DIE %s referenced\"\n-               \" from DIE at %s [in module %s]\"),\n-             hex_string (signature), sect_offset_str (src_die->sect_off),\n+\t       \" from DIE at %s [in module %s]\"),\n+\t     hex_string (signature), sect_offset_str (src_die->sect_off),\n \t     objfile_name ((*ref_cu)->per_objfile->objfile));\n     }\n \n@@ -23763,7 +23763,7 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu, bool *computed)\n \t    }\n \t  break;\n \n-        case DW_OP_GNU_push_tls_address:\n+\tcase DW_OP_GNU_push_tls_address:\n \tcase DW_OP_form_tls_address:\n \t  /* The top of the stack has the offset from the beginning\n \t     of the thread control block at which the variable is located.  */\n@@ -23781,7 +23781,7 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu, bool *computed)\n \t\treturn 0;\n \t    }\n \t  stack[stacki]++;\n-          break;\n+\t  break;\n \n \tcase DW_OP_GNU_uninit:\n \t  if (computed != nullptr)\n@@ -23813,7 +23813,7 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu, bool *computed)\n \t}\n \n       /* Enforce maximum stack depth of SIZE-1 to avoid writing\n-         outside of the allocated space.  Also enforce minimum>0.  */\n+\t outside of the allocated space.  Also enforce minimum>0.  */\n       if (stacki >= ARRAY_SIZE (stack) - 1)\n \t{\n \t  if (computed == nullptr)\n@@ -24461,7 +24461,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n     {\n       struct type *prop_type = cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n-        type->add_dyn_prop (DYN_PROP_ALLOCATED, prop);\n+\ttype->add_dyn_prop (DYN_PROP_ALLOCATED, prop);\n     }\n \n   /* Read DW_AT_associated and set in type.  */\n@@ -24470,7 +24470,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n     {\n       struct type *prop_type = cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n-        type->add_dyn_prop (DYN_PROP_ASSOCIATED, prop);\n+\ttype->add_dyn_prop (DYN_PROP_ASSOCIATED, prop);\n     }\n \n   /* Read DW_AT_data_location and set in type.  */"
    },
    {
      "sha": "a0d76f349e822b2076e11efb7a030d20c9549db5",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -100,9 +100,9 @@ struct dwarf2_per_bfd\n      for (i = 0; i < (dwarf2_per_bfd->n_comp_units\n \t\t      + dwarf2_per_bfd->n_type_units); ++i)\n        {\n-         dwarf2_per_cu_data *per_cu = dwarf2_per_bfd->get_cutu (i);\n+\t dwarf2_per_cu_data *per_cu = dwarf2_per_bfd->get_cutu (i);\n \n-         ...;\n+\t ...;\n        }\n   */\n   dwarf2_per_cu_data *get_cutu (int index);"
    },
    {
      "sha": "f362bc8a622b3fce7089d4e7ea17db4705487dca",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1232,7 +1232,7 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n       const struct ecoff_debug_swap *swap;\n \n       /* .mdebug section, presumably holding ECOFF debugging\n-         information.  */\n+\t information.  */\n       swap = get_elf_backend_data (abfd)->elf_backend_ecoff_debug_swap;\n       if (swap)\n \telfmdebug_build_psymtabs (objfile, swap, ei.mdebugsect);\n@@ -1242,7 +1242,7 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n       asection *str_sect;\n \n       /* Stab sections have an associated string table that looks like\n-         a separate section.  */\n+\t a separate section.  */\n       str_sect = bfd_get_section_by_name (abfd, \".stabstr\");\n \n       /* FIXME should probably warn about a stab section without a stabstr.  */"
    },
    {
      "sha": "8d0c5747f3960d314ab6b3a84dc032be4c1c3723",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 39,
      "deletions": 39,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -479,7 +479,7 @@ binop_promote (const struct language_defn *language, struct gdbarch *gdbarch,\n       int unsigned_operation;\n \n       /* Determine type length and signedness after promotion for\n-         both operands.  */\n+\t both operands.  */\n       if (promoted_len1 < TYPE_LENGTH (builtin->builtin_int))\n \t{\n \t  is_unsigned1 = 0;\n@@ -1354,11 +1354,11 @@ evaluate_subexp_standard (struct type *expect_type,\n \tif (regno == -1)\n \t  error (_(\"Register $%s not available.\"), name);\n \n-        /* In EVAL_AVOID_SIDE_EFFECTS mode, we only need to return\n-           a value with the appropriate register type.  Unfortunately,\n-           we don't have easy access to the type of user registers.\n-           So for these registers, we fetch the register value regardless\n-           of the evaluation mode.  */\n+\t/* In EVAL_AVOID_SIDE_EFFECTS mode, we only need to return\n+\t   a value with the appropriate register type.  Unfortunately,\n+\t   we don't have easy access to the type of user registers.\n+\t   So for these registers, we fetch the register value regardless\n+\t   of the evaluation mode.  */\n \tif (noside == EVAL_AVOID_SIDE_EFFECTS\n \t    && regno < gdbarch_num_cooked_regs (exp->gdbarch))\n \t  val = value_zero (register_type (exp->gdbarch, regno), not_lval);\n@@ -1487,8 +1487,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \t      range_low = range_high = value_as_long (elem_val);\n \n \t      /* Check types of elements to avoid mixture of elements from\n-\t         different types. Also check if type of element is \"compatible\"\n-\t         with element type of powerset.  */\n+\t\t different types. Also check if type of element is \"compatible\"\n+\t\t with element type of powerset.  */\n \t      if (range_low_type->code () == TYPE_CODE_RANGE)\n \t\trange_low_type = TYPE_TARGET_TYPE (range_low_type);\n \t      if (range_high_type->code () == TYPE_CODE_RANGE)\n@@ -1740,7 +1740,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  }\n \n \t/* If we found a method with symbol information, check to see\n-           if it returns a struct.  Otherwise assume it doesn't.  */\n+\t   if it returns a struct.  Otherwise assume it doesn't.  */\n \n \tif (method)\n \t  {\n@@ -1873,7 +1873,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     case OP_COMPLEX:\n       /* We have a complex number, There should be 2 floating \n-         point numbers that compose it.  */\n+\t point numbers that compose it.  */\n       (*pos) += 2;\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n@@ -1900,7 +1900,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \treturn eval_skip_value (exp);\n \n       /* Check to see if operator '->' has been overloaded.  If so replace\n-         arg1 with the value returned by evaluating operator->().  */\n+\t arg1 with the value returned by evaluating operator->().  */\n       while (unop_user_defined_p (op, arg1))\n \t{\n \t  struct value *value = NULL;\n@@ -1924,21 +1924,21 @@ evaluate_subexp_standard (struct type *expect_type,\n \t with rtti type in order to continue on with successful\n \t lookup of member / method only available in the rtti type.  */\n       {\n-        struct type *arg_type = value_type (arg1);\n-        struct type *real_type;\n-        int full, using_enc;\n-        LONGEST top;\n+\tstruct type *arg_type = value_type (arg1);\n+\tstruct type *real_type;\n+\tint full, using_enc;\n+\tLONGEST top;\n \tstruct value_print_options opts;\n \n \tget_user_print_options (&opts);\n-        if (opts.objectprint && TYPE_TARGET_TYPE (arg_type)\n-            && (TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_STRUCT))\n-          {\n-            real_type = value_rtti_indirect_type (arg1, &full, &top,\n+\tif (opts.objectprint && TYPE_TARGET_TYPE (arg_type)\n+\t    && (TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_STRUCT))\n+\t  {\n+\t    real_type = value_rtti_indirect_type (arg1, &full, &top,\n \t\t\t\t\t\t  &using_enc);\n-            if (real_type)\n-                arg1 = value_cast (real_type, arg1);\n-          }\n+\t    if (real_type)\n+\t\targ1 = value_cast (real_type, arg1);\n+\t  }\n       }\n \n       arg3 = value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,\n@@ -2208,8 +2208,8 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t    {\n \t      /* If the user attempts to subscript something that has no target\n-\t         type (like a plain int variable for example), then report this\n-\t         as an error.  */\n+\t\t type (like a plain int variable for example), then report this\n+\t\t as an error.  */\n \n \t      type = TYPE_TARGET_TYPE (check_typedef (value_type (arg1)));\n \t      if (type != NULL)\n@@ -2416,7 +2416,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \treturn eval_skip_value (exp);\n       type = check_typedef (value_type (arg2));\n       if (type->code () != TYPE_CODE_INT\n-          && type->code () != TYPE_CODE_ENUM)\n+\t  && type->code () != TYPE_CODE_ENUM)\n \terror (_(\"Non-integral right operand for \\\"@\\\" operator.\"));\n       if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \t{\n@@ -2712,14 +2712,14 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     case OP_TYPE:\n       /* The value is not supposed to be used.  This is here to make it\n-         easier to accommodate expressions that contain types.  */\n+\t easier to accommodate expressions that contain types.  */\n       (*pos) += 2;\n       if (noside == EVAL_SKIP)\n \treturn eval_skip_value (exp);\n       else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n \treturn allocate_value (exp->elts[pc + 1].type);\n       else\n-        error (_(\"Attempt to use a type name as an expression\"));\n+\terror (_(\"Attempt to use a type name as an expression\"));\n \n     case OP_TYPEOF:\n     case OP_DECLTYPE:\n@@ -2757,7 +2757,7 @@ evaluate_subexp_standard (struct type *expect_type,\n \t  return result;\n \t}\n       else\n-        error (_(\"Attempt to use a type as an expression\"));\n+\terror (_(\"Attempt to use a type as an expression\"));\n \n     case OP_TYPEID:\n       {\n@@ -2777,13 +2777,13 @@ evaluate_subexp_standard (struct type *expect_type,\n \n     default:\n       /* Removing this case and compiling with gcc -Wall reveals that\n-         a lot of cases are hitting this case.  Some of these should\n-         probably be removed from expression.h; others are legitimate\n-         expressions which are (apparently) not fully implemented.\n+\t a lot of cases are hitting this case.  Some of these should\n+\t probably be removed from expression.h; others are legitimate\n+\t expressions which are (apparently) not fully implemented.\n \n-         If there are any cases landing here which mean a user error,\n-         then they should be separate cases, with more descriptive\n-         error messages.  */\n+\t If there are any cases landing here which mean a user error,\n+\t then they should be separate cases, with more descriptive\n+\t error messages.  */\n \n       error (_(\"GDB does not (yet) know how to \"\n \t       \"evaluate that kind of expression\"));\n@@ -2985,9 +2985,9 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n   switch (op)\n     {\n       /* This case is handled specially\n-         so that we avoid creating a value for the result type.\n-         If the result type is very big, it's desirable not to\n-         create a value unnecessarily.  */\n+\t so that we avoid creating a value for the result type.\n+\t If the result type is very big, it's desirable not to\n+\t create a value unnecessarily.  */\n     case UNOP_IND:\n       (*pos)++;\n       val = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n@@ -3019,8 +3019,8 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t  val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n \t  type = value_type (val);\n \t  if (type->code () == TYPE_CODE_ARRAY\n-              && is_dynamic_type (type->index_type ())\n-              && type->bounds ()->high.kind () == PROP_UNDEFINED)\n+\t      && is_dynamic_type (type->index_type ())\n+\t      && type->bounds ()->high.kind () == PROP_UNDEFINED)\n \t    return allocate_optimized_out_value (size_type);\n \t}\n       else"
    },
    {
      "sha": "8ae1eb91c204f9035cbb32e690b21edbf8376ac2",
      "filename": "gdb/event-top.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/event-top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/event-top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-top.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -415,8 +415,8 @@ display_gdb_prompt (const char *new_prompt)\n   else\n     {\n       /* Don't use a _filtered function here.  It causes the assumed\n-         character position to be off, since the newline we read from\n-         the user is not accounted for.  */\n+\t character position to be off, since the newline we read from\n+\t the user is not accounted for.  */\n       fprintf_unfiltered (gdb_stdout, \"%s\", actual_gdb_prompt.c_str ());\n       gdb_flush (gdb_stdout);\n     }\n@@ -676,8 +676,8 @@ handle_line_of_input (struct buffer *cmd_line_buffer,\n   if (server_command)\n     {\n       /* Note that we don't call `save_command_line'.  Between this\n-         and the check in dont_repeat, this insures that repeating\n-         will still do the right thing.  */\n+\t and the check in dont_repeat, this insures that repeating\n+\t will still do the right thing.  */\n       return cmd + strlen (SERVER_COMMAND_PREFIX);\n     }\n \n@@ -816,7 +816,7 @@ gdb_readline_no_editing_callback (gdb_client_data client_data)\n   while (1)\n     {\n       /* Read from stdin if we are executing a user defined command.\n-         This is the right thing for prompt_for_continue, at least.  */\n+\t This is the right thing for prompt_for_continue, at least.  */\n       c = fgetc (ui->instream != NULL ? ui->instream : ui->stdin_stream);\n \n       if (c == EOF)"
    },
    {
      "sha": "26674a1ff95fc1607f3576327dd2acc0a59f92af",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -379,7 +379,7 @@ exec_file_attach (const char *filename, int from_tty)\n   if (!filename)\n     {\n       if (from_tty)\n-        printf_unfiltered (_(\"No executable file now.\\n\"));\n+\tprintf_unfiltered (_(\"No executable file now.\\n\"));\n \n       set_gdbarch_from_file (NULL);\n     }\n@@ -525,16 +525,16 @@ exec_file_command (const char *args, int from_tty)\n   if (args)\n     {\n       /* Scan through the args and pick up the first non option arg\n-         as the filename.  */\n+\t as the filename.  */\n \n       gdb_argv built_argv (args);\n       char **argv = built_argv.get ();\n \n       for (; (*argv != NULL) && (**argv == '-'); argv++)\n-        {;\n-        }\n+\t{;\n+\t}\n       if (*argv == NULL)\n-        error (_(\"No executable file name was specified\"));\n+\terror (_(\"No executable file name was specified\"));\n \n       gdb::unique_xmalloc_ptr<char> filename (tilde_expand (*argv));\n       exec_file_attach (filename.get (), from_tty);\n@@ -832,7 +832,7 @@ section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n       if (match_cb != nullptr && !match_cb (&p))\n \tcontinue;\t\t/* not the section we need.  */\n       if (memaddr >= p.addr)\n-        {\n+\t{\n \t  if (memend <= p.endaddr)\n \t    {\n \t      /* Entire transfer is within this section.  */\n@@ -878,7 +878,7 @@ section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n \t      else\n \t\treturn TARGET_XFER_EOF;\n \t    }\n-        }\n+\t}\n     }\n \n   return TARGET_XFER_EOF;\t\t/* We can't help.  */"
    },
    {
      "sha": "975f7b1f852f981d888dcf19e961ee239db1c4f2",
      "filename": "gdb/exec.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/exec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/exec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -79,7 +79,7 @@ extern enum target_xfer_status\n \t\t\t\t     const target_section_table &,\n \t\t\t\t     gdb::function_view<bool\n \t\t\t\t       (const struct target_section *)> match_cb\n-\t\t\t\t         = nullptr);\n+\t\t\t\t\t = nullptr);\n \n /* Read from mappable read-only sections of BFD executable files.\n    Similar to exec_read_partial_read_only, but return"
    },
    {
      "sha": "f4668aa297dd1b74944004ac08efd4f7af49f8ed",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -348,9 +348,9 @@ print_subexp_standard (struct expression *exp, int *pos,\n       if ((int) prec > (int) PREC_COMMA)\n \tfputs_filtered (\"(\", stream);\n       /* Print the subexpressions, forcing parentheses\n-         around any binary operations within them.\n-         This is more parentheses than are strictly necessary,\n-         but it looks clearer.  */\n+\t around any binary operations within them.\n+\t This is more parentheses than are strictly necessary,\n+\t but it looks clearer.  */\n       print_subexp (exp, pos, stream, PREC_HYPER);\n       fputs_filtered (\" ? \", stream);\n       print_subexp (exp, pos, stream, PREC_HYPER);\n@@ -642,8 +642,8 @@ print_subexp_standard (struct expression *exp, int *pos,\n     {\n       /* Binary operator.  */\n       /* Print left operand.\n-         If operator is right-associative,\n-         increment precedence for this operand.  */\n+\t If operator is right-associative,\n+\t increment precedence for this operand.  */\n       print_subexp (exp, pos, stream,\n \t\t    (enum precedence) ((int) myprec + assoc));\n       /* Print the operator itself.  */\n@@ -654,8 +654,8 @@ print_subexp_standard (struct expression *exp, int *pos,\n       else\n \tfprintf_filtered (stream, \" %s \", op_str);\n       /* Print right operand.\n-         If operator is left-associative,\n-         increment precedence for this operand.  */\n+\t If operator is left-associative,\n+\t increment precedence for this operand.  */\n       print_subexp (exp, pos, stream,\n \t\t    (enum precedence) ((int) myprec + !assoc));\n     }"
    },
    {
      "sha": "5e16678886b2e0c4ec96a000359dd68ca16f357c",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -213,8 +213,8 @@ type_exp:\ttype\n \t;\n \n exp     :       '(' exp ')'\n-        \t\t{ }\n-        ;\n+\t\t\t{ }\n+\t;\n \n /* Expressions, not including the comma operator.  */\n exp\t:\t'*' exp    %prec UNARY\n@@ -351,8 +351,8 @@ subrange:\t':' ':' exp\t%prec ABOVE_COMMA\n \t;\n \n complexnum:     exp ',' exp \n-                \t{ }                          \n-        ;\n+\t\t\t{ }                          \n+\t;\n \n exp\t:\t'(' complexnum ')'\n \t\t\t{ write_exp_elt_opcode (pstate, OP_COMPLEX);\n@@ -369,10 +369,10 @@ exp\t:\t'(' type ')' exp  %prec UNARY\n \t;\n \n exp     :       exp '%' name\n-                        { write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-                          write_exp_string (pstate, $3);\n-                          write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n-        ;\n+\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n+\t\t\t  write_exp_string (pstate, $3);\n+\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t;\n \n /* Binary operators in order of decreasing precedence.  */\n \n@@ -510,7 +510,7 @@ exp     :       BOOLEAN_LITERAL\n \t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n \t\t\t  write_exp_elt_opcode (pstate, OP_BOOL);\n \t\t\t}\n-        ;\n+\t;\n \n exp\t:\tSTRING_LITERAL\n \t\t\t{\n@@ -553,7 +553,7 @@ variable:\tname_not_typename\n \n \n type    :       ptype\n-        ;\n+\t;\n \n ptype\t:\ttypebase\n \t|\ttypebase abs_decl\n@@ -1205,7 +1205,7 @@ yylex (void)\n     case '8':\n     case '9':\n       {\n-        /* It's a number.  */\n+\t/* It's a number.  */\n \tint got_dot = 0, got_e = 0, got_d = 0, toktype;\n \tconst char *p = tokstart;\n \tint hex = input_radix > 10;\n@@ -1246,8 +1246,8 @@ yylex (void)\n \ttoktype = parse_number (pstate, tokstart, p - tokstart,\n \t\t\t\tgot_dot|got_e|got_d,\n \t\t\t\t&yylval);\n-        if (toktype == ERROR)\n-          {\n+\tif (toktype == ERROR)\n+\t  {\n \t    char *err_copy = (char *) alloca (p - tokstart + 1);\n \t    \n \t    memcpy (err_copy, tokstart, p - tokstart);"
    },
    {
      "sha": "d3391d9442fbb5d31694a8fb8f605e7b891eff95",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -366,7 +366,7 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \ttype = value_type (arg1);\n \tif (type->code () != value_type (arg2)->code ())\n \t  error (_(\"non-matching types for parameters to MODULO ()\"));\n-        /* MODULO(A, P) = A - FLOOR (A / P) * P */\n+\t/* MODULO(A, P) = A - FLOOR (A / P) * P */\n \tswitch (type->code ())\n \t  {\n \t  case TYPE_CODE_INT:\n@@ -408,28 +408,28 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       type = value_type (arg1);\n \n       switch (type->code ())\n-        {\n-          case TYPE_CODE_STRUCT:\n-          case TYPE_CODE_UNION:\n-          case TYPE_CODE_MODULE:\n-          case TYPE_CODE_FUNC:\n-            error (_(\"argument to kind must be an intrinsic type\"));\n-        }\n+\t{\n+\t  case TYPE_CODE_STRUCT:\n+\t  case TYPE_CODE_UNION:\n+\t  case TYPE_CODE_MODULE:\n+\t  case TYPE_CODE_FUNC:\n+\t    error (_(\"argument to kind must be an intrinsic type\"));\n+\t}\n \n       if (!TYPE_TARGET_TYPE (type))\n-        return value_from_longest (builtin_type (exp->gdbarch)->builtin_int,\n+\treturn value_from_longest (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t\t   TYPE_LENGTH (type));\n       return value_from_longest (builtin_type (exp->gdbarch)->builtin_int,\n \t\t\t\t TYPE_LENGTH (TYPE_TARGET_TYPE (type)));\n \n \n     case OP_F77_UNDETERMINED_ARGLIST:\n       /* Remember that in F77, functions, substring ops and array subscript\n-         operations cannot be disambiguated at parse time.  We have made\n-         all array subscript operations, substring operations as well as\n-         function calls come here and we now have to discover what the heck\n-         this thing actually was.  If it is a function, we process just as\n-         if we got an OP_FUNCALL.  */\n+\t operations cannot be disambiguated at parse time.  We have made\n+\t all array subscript operations, substring operations as well as\n+\t function calls come here and we now have to discover what the heck\n+\t this thing actually was.  If it is a function, we process just as\n+\t if we got an OP_FUNCALL.  */\n       int nargs = longest_to_int (exp->elts[pc + 1].longconst);\n       (*pos) += 2;\n "
    },
    {
      "sha": "28f5c8831fbcdeb901bac16eeb4bf920c25401c1",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -59,7 +59,7 @@ f_language::print_type (struct type *type, const char *varstring,\n \t will print just a type name.  */\n       || ((show > 0\n \t   || type->name () == 0)\n-          && (code == TYPE_CODE_FUNC\n+\t  && (code == TYPE_CODE_FUNC\n \t      || code == TYPE_CODE_METHOD\n \t      || code == TYPE_CODE_ARRAY\n \t      || ((code == TYPE_CODE_PTR\n@@ -79,7 +79,7 @@ f_language::print_type (struct type *type, const char *varstring,\n       fputs_filtered (varstring, stream);\n \n       /* For demangled function names, we have the arglist as part of the name,\n-         so don't print an additional pair of ()'s.  */\n+\t so don't print an additional pair of ()'s.  */\n \n       demangled_args = (*varstring != '\\0'\n \t\t\t&& varstring[strlen (varstring) - 1] == ')');\n@@ -136,7 +136,7 @@ f_language::f_type_print_varspec_prefix (struct type *type,\n     case TYPE_CODE_COMPLEX:\n     case TYPE_CODE_TYPEDEF:\n       /* These types need no prefix.  They are listed here so that\n-         gcc -Wall will reveal any types that haven't been handled.  */\n+\t gcc -Wall will reveal any types that haven't been handled.  */\n       break;\n     }\n }\n@@ -197,7 +197,7 @@ f_language::f_type_print_varspec_suffix (struct type *type,\n \t{\n \t  LONGEST lower_bound = f77_get_lowerbound (type);\n \t  if (lower_bound != 1)\t/* Not the default.  */\n-            fprintf_filtered (stream, \"%s:\", plongest (lower_bound));\n+\t    fprintf_filtered (stream, \"%s:\", plongest (lower_bound));\n \n \t  /* Make sure that, if we have an assumed size array, we\n \t       print out a warning and print the upperbound as '*'.  */\n@@ -208,7 +208,7 @@ f_language::f_type_print_varspec_suffix (struct type *type,\n \t    {\n \t      LONGEST upper_bound = f77_get_upperbound (type);\n \n-              fputs_filtered (plongest (upper_bound), stream);\n+\t      fputs_filtered (plongest (upper_bound), stream);\n \t    }\n \t}\n \n@@ -275,7 +275,7 @@ f_language::f_type_print_varspec_suffix (struct type *type,\n     case TYPE_CODE_COMPLEX:\n     case TYPE_CODE_TYPEDEF:\n       /* These types do not need a suffix.  They are listed so that\n-         gcc -Wall will report types that may not have been considered.  */\n+\t gcc -Wall will report types that may not have been considered.  */\n       break;\n     }\n }\n@@ -364,8 +364,8 @@ f_language::f_type_print_base (struct type *type, struct ui_file *stream,\n     case TYPE_CODE_CHAR:\n     case TYPE_CODE_INT:\n       /* There may be some character types that attempt to come\n-         through as TYPE_CODE_INT since dbxstclass.h is so\n-         C-oriented, we must change these to \"character\" from \"char\".  */\n+\t through as TYPE_CODE_INT since dbxstclass.h is so\n+\t C-oriented, we must change these to \"character\" from \"char\".  */\n \n       if (strcmp (type->name (), \"char\") == 0)\n \tfprintfi_filtered (level, stream, \"character\");\n@@ -398,7 +398,7 @@ f_language::f_type_print_base (struct type *type, struct ui_file *stream,\n \tfprintfi_filtered (level, stream, \"Type \");\n       fputs_filtered (type->name (), stream);\n       /* According to the definition,\n-         we only print structure elements in case show > 0.  */\n+\t we only print structure elements in case show > 0.  */\n       if (show > 0)\n \t{\n \t  fputs_filtered (\"\\n\", stream);\n@@ -425,9 +425,9 @@ f_language::f_type_print_base (struct type *type, struct ui_file *stream,\n     default_case:\n     default:\n       /* Handle types not explicitly handled by the other cases,\n-         such as fundamental types.  For these, just print whatever\n-         the type name is, as recorded in the type itself.  If there\n-         is no type name, then complain.  */\n+\t such as fundamental types.  For these, just print whatever\n+\t the type name is, as recorded in the type itself.  If there\n+\t is no type name, then complain.  */\n       if (type->name () != NULL)\n \tfprintfi_filtered (level, stream, \"%s\", type->name ());\n       else"
    },
    {
      "sha": "33ac761f85de4de380e73d3840f1069c5325efba",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -302,10 +302,10 @@ f_language::value_print_inner (struct value *val, struct ui_file *stream,\n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n       /* Starting from the Fortran 90 standard, Fortran supports derived\n-         types.  */\n+\t types.  */\n       fprintf_filtered (stream, \"( \");\n       for (index = 0; index < type->num_fields (); index++)\n-        {\n+\t{\n \t  struct value *field = value_field (val, index);\n \n \t  struct type *field_type = check_typedef (type->field (index).type ());\n@@ -392,7 +392,7 @@ info_common_command_for_block (const struct block *block, const char *comname,\n \tgdb_assert (SYMBOL_CLASS (sym) == LOC_COMMON_BLOCK);\n \n \tif (comname && (!sym->linkage_name ()\n-\t                || strcmp (comname, sym->linkage_name ()) != 0))\n+\t\t\t|| strcmp (comname, sym->linkage_name ()) != 0))\n \t  continue;\n \n \tif (*any_printed)\n@@ -462,7 +462,7 @@ info_common_command (const char *comname, int from_tty)\n     {\n       info_common_command_for_block (block, comname, &values_printed);\n       /* After handling the function's top-level block, stop.  Don't\n-         continue to its superblock, the block of per-file symbols.  */\n+\t continue to its superblock, the block of per-file symbols.  */\n       if (BLOCK_FUNCTION (block))\n \tbreak;\n       block = BLOCK_SUPERBLOCK (block);"
    },
    {
      "sha": "0fb5726b8c1474c61e9aafaa188797e2d775e840",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1048,7 +1048,7 @@ fbsd_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n       inferior *inf = find_inferior_ptid (this, ptid);\n \n       for (thread_info *tp : inf->non_exited_threads ())\n-        {\n+\t{\n \t  int request;\n \n \t  if (tp->ptid.lwp () == ptid.lwp ())"
    },
    {
      "sha": "3df49d092d4c62b14dba7747abb2192501c3c223",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1849,7 +1849,7 @@ fbsd_gdb_signal_from_target (struct gdbarch *gdbarch, int signal)\n \n static int\n fbsd_gdb_signal_to_target (struct gdbarch *gdbarch,\n-                enum gdb_signal signal)\n+\t\tenum gdb_signal signal)\n {\n   switch (signal)\n     {"
    },
    {
      "sha": "95d0ff03a276dff47bd174eef17122a5fd9a490f",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -362,7 +362,7 @@ symbol_read_needs (struct symbol *sym)\n   switch (SYMBOL_CLASS (sym))\n     {\n       /* All cases listed explicitly so that gcc -Wall will detect it if\n-         we failed to consider one.  */\n+\t we failed to consider one.  */\n     case LOC_COMPUTED:\n       gdb_assert_not_reached (_(\"LOC_COMPUTED variable missing a method\"));\n \n@@ -380,8 +380,8 @@ symbol_read_needs (struct symbol *sym)\n \n     case LOC_LABEL:\n       /* Getting the address of a label can be done independently of the block,\n-         even if some *uses* of that address wouldn't work so well without\n-         the right frame.  */\n+\t even if some *uses* of that address wouldn't work so well without\n+\t the right frame.  */\n \n     case LOC_BLOCK:\n     case LOC_CONST_BYTES:\n@@ -729,7 +729,7 @@ language_defn::read_var_value (struct symbol *var,\n \n \t    if (regval == NULL)\n \t      error (_(\"Value of register variable not available for `%s'.\"),\n-\t             var->print_name ());\n+\t\t     var->print_name ());\n \n \t    addr = value_as_address (regval);\n \t  }\n@@ -739,7 +739,7 @@ language_defn::read_var_value (struct symbol *var,\n \n \t    if (regval == NULL)\n \t      error (_(\"Value of register variable not available for `%s'.\"),\n-\t             var->print_name ());\n+\t\t     var->print_name ());\n \t    return regval;\n \t  }\n       }\n@@ -826,7 +826,7 @@ read_var_value (struct symbol *var, const struct block *var_block,\n \n struct value *\n default_value_from_register (struct gdbarch *gdbarch, struct type *type,\n-                             int regnum, struct frame_id frame_id)\n+\t\t\t     int regnum, struct frame_id frame_id)\n {\n   int len = TYPE_LENGTH (type);\n   struct value *value = allocate_value (type);\n@@ -890,7 +890,7 @@ read_frame_register_value (struct value *value, struct frame_info *frame)\n       int reg_len = type_length_units (value_type (regval)) - reg_offset;\n \n       /* If the register length is larger than the number of bytes\n-         remaining to copy, then only copy the appropriate bytes.  */\n+\t remaining to copy, then only copy the appropriate bytes.  */\n       if (reg_len > len)\n \treg_len = len;\n \n@@ -917,12 +917,12 @@ value_from_register (struct type *type, int regnum, struct frame_info *frame)\n       int optim, unavail, ok;\n \n       /* The ISA/ABI need to something weird when obtaining the\n-         specified value from this register.  It might need to\n-         re-order non-adjacent, starting with REGNUM (see MIPS and\n-         i386).  It might need to convert the [float] register into\n-         the corresponding [integer] type (see Alpha).  The assumption\n-         is that gdbarch_register_to_value populates the entire value\n-         including the location.  */\n+\t specified value from this register.  It might need to\n+\t re-order non-adjacent, starting with REGNUM (see MIPS and\n+\t i386).  It might need to convert the [float] register into\n+\t the corresponding [integer] type (see Alpha).  The assumption\n+\t is that gdbarch_register_to_value populates the entire value\n+\t including the location.  */\n       v = allocate_value (type);\n       VALUE_LVAL (v) = lval_register;\n       VALUE_NEXT_FRAME_ID (v) = get_frame_id (get_next_frame_sentinel_okay (frame));"
    },
    {
      "sha": "284018a5ce179c29aa22ad374527bd8bd492d09c",
      "filename": "gdb/fork-child.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fork-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/fork-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fork-child.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -165,8 +165,8 @@ Show the wrapper for running programs.\"), NULL,\n \t\t\t    &setlist, &showlist);\n \n   add_cmd (\"exec-wrapper\", class_run, unset_exec_wrapper_command,\n-           _(\"Disable use of an execution wrapper.\"),\n-           &unsetlist);\n+\t   _(\"Disable use of an execution wrapper.\"),\n+\t   &unsetlist);\n \n   add_setshow_boolean_cmd (\"startup-with-shell\", class_support,\n \t\t\t   &startup_with_shell, _(\"\\"
    },
    {
      "sha": "cc01732e9267cc1bcce6849f82d4cd10832c1e6d",
      "filename": "gdb/frame-unwind.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -117,7 +117,7 @@ frame_unwind_append_unwinder (struct gdbarch *gdbarch,\n \n static int\n frame_unwind_try_unwinder (struct frame_info *this_frame, void **this_cache,\n-                          const struct frame_unwind *unwinder)\n+\t\t\t  const struct frame_unwind *unwinder)\n {\n   int res = 0;\n \n@@ -180,13 +180,13 @@ frame_unwind_find_by_frame (struct frame_info *this_frame, void **this_cache)\n   unwinder_from_target = target_get_unwinder ();\n   if (unwinder_from_target != NULL\n       && frame_unwind_try_unwinder (this_frame, this_cache,\n-                                   unwinder_from_target))\n+\t\t\t\t   unwinder_from_target))\n     return;\n \n   unwinder_from_target = target_get_tailcall_unwinder ();\n   if (unwinder_from_target != NULL\n       && frame_unwind_try_unwinder (this_frame, this_cache,\n-                                   unwinder_from_target))\n+\t\t\t\t   unwinder_from_target))\n     return;\n \n   for (entry = table->list; entry != NULL; entry = entry->next)"
    },
    {
      "sha": "0f0fdd4c2d1ed0225f29d9e9bd101b1b206a4696",
      "filename": "gdb/frame-unwind.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame-unwind.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame-unwind.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -226,7 +226,7 @@ struct value *frame_unwind_got_constant (struct frame_info *frame, int regnum,\n    inside BUF.  */\n \n struct value *frame_unwind_got_bytes (struct frame_info *frame, int regnum,\n-                                      gdb_byte *buf);\n+\t\t\t\t      gdb_byte *buf);\n \n /* Return a value which indicates that FRAME's saved version of REGNUM\n    has a known constant (computed) value of ADDR.  Convert the"
    },
    {
      "sha": "e783638e0d145d77f24c3bbd8fa51688d8baac69",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -601,7 +601,7 @@ compute_frame_id (struct frame_info *fi)\n   catch (const gdb_exception &ex)\n     {\n       /* On error, revert the frame id status to not computed.  If the frame\n-         cache generation changed, the frame object doesn't exist anymore, so\n+\t cache generation changed, the frame object doesn't exist anymore, so\n \t don't touch it.  */\n       if (get_frame_cache_generation () == entry_generation)\n \tfi->this_id.p = frame_id_status::NOT_COMPUTED;\n@@ -677,7 +677,7 @@ const struct frame_id outer_frame_id = { 0, 0, 0, FID_STACK_OUTER, 0, 1, 0 };\n \n struct frame_id\n frame_id_build_special (CORE_ADDR stack_addr, CORE_ADDR code_addr,\n-                        CORE_ADDR special_addr)\n+\t\t\tCORE_ADDR special_addr)\n {\n   struct frame_id id = null_frame_id;\n \n@@ -1048,7 +1048,7 @@ get_frame_func_if_available (frame_info *this_frame, CORE_ADDR *pc)\n       CORE_ADDR addr_in_block;\n \n       /* Make certain that this, and not the adjacent, function is\n-         found.  */\n+\t found.  */\n       if (!get_frame_address_in_block_if_available (this_frame, &addr_in_block))\n \t{\n \t  next_frame->prev_func.status = CC_UNAVAILABLE;\n@@ -2329,9 +2329,9 @@ get_prev_frame_always (struct frame_info *this_frame)\n \t      size_t size;\n \n \t      /* The error needs to live as long as the frame does.\n-\t         Allocate using stack local STOP_STRING then assign the\n-\t         pointer to the frame, this allows the STOP_STRING on the\n-\t         frame to be of type 'const char *'.  */\n+\t\t Allocate using stack local STOP_STRING then assign the\n+\t\t pointer to the frame, this allows the STOP_STRING on the\n+\t\t frame to be of type 'const char *'.  */\n \t      size = ex.message->size () + 1;\n \t      stop_string = (char *) frame_obstack_zalloc (size);\n \t      memcpy (stop_string, ex.what (), size);"
    },
    {
      "sha": "2dc18206975a33f93db2b08765871acea60a2636",
      "filename": "gdb/frv-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -169,7 +169,7 @@ frv_linux_pc_in_sigtramp (struct gdbarch *gdbarch, CORE_ADDR pc,\n \n static LONGEST\n frv_linux_sigcontext_reg_addr (struct frame_info *this_frame, int regno,\n-                               CORE_ADDR *sc_addr_cache_ptr)\n+\t\t\t       CORE_ADDR *sc_addr_cache_ptr)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n@@ -410,7 +410,7 @@ static const struct regcache_map_entry frv_linux_fpregmap[] =\n \n static void \n frv_linux_supply_gregset (const struct regset *regset,\n-                          struct regcache *regcache,\n+\t\t\t  struct regcache *regcache,\n \t\t\t  int regnum, const void *gregs, size_t len)\n {\n   int regi;"
    },
    {
      "sha": "d9cfd5d8cae83d52d0439f10783380211e25422c",
      "filename": "gdb/frv-tdep.c",
      "status": "modified",
      "additions": 120,
      "deletions": 120,
      "changes": 240,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -100,7 +100,7 @@ frv_abi (struct gdbarch *gdbarch)\n    not.  (E.g, -1 will be returned if the ABI isn't the FDPIC ABI.)  */\n int\n frv_fdpic_loadmap_addresses (struct gdbarch *gdbarch, CORE_ADDR *interp_addr,\n-                             CORE_ADDR *exec_addr)\n+\t\t\t     CORE_ADDR *exec_addr)\n {\n   if (frv_abi (gdbarch) != FRV_ABI_FDPIC)\n     return -1;\n@@ -296,7 +296,7 @@ frv_register_type (struct gdbarch *gdbarch, int reg)\n \n static enum register_status\n frv_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n-                          int reg, gdb_byte *buffer)\n+\t\t\t  int reg, gdb_byte *buffer)\n {\n   enum register_status status;\n \n@@ -309,7 +309,7 @@ frv_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n   else if (accg0_regnum <= reg && reg <= accg7_regnum)\n     {\n       /* The accg raw registers have four values in each slot with the\n-         lowest register number occupying the first byte.  */\n+\t lowest register number occupying the first byte.  */\n \n       int raw_regnum = accg0123_regnum + (reg - accg0_regnum) / 4;\n       int byte_num = (reg - accg0_regnum) % 4;\n@@ -333,7 +333,7 @@ frv_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \n static void\n frv_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n-                          int reg, const gdb_byte *buffer)\n+\t\t\t  int reg, const gdb_byte *buffer)\n {\n   if (reg == iacc0_regnum)\n     {\n@@ -343,7 +343,7 @@ frv_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n   else if (accg0_regnum <= reg && reg <= accg7_regnum)\n     {\n       /* The accg raw registers have four values in each slot with the\n-         lowest register number occupying the first byte.  */\n+\t lowest register number occupying the first byte.  */\n \n       int raw_regnum = accg0123_regnum + (reg - accg0_regnum) / 4;\n       int byte_num = (reg - accg0_regnum) % 4;\n@@ -409,7 +409,7 @@ frv_register_sim_regno (struct gdbarch *gdbarch, int reg)\n   else if (pc_regnum == reg)\n     return SIM_FRV_PC_REGNUM;\n   else if (reg >= first_spr_regnum\n-           && reg < first_spr_regnum + sizeof (spr_map) / sizeof (spr_map[0]))\n+\t   && reg < first_spr_regnum + sizeof (spr_map) / sizeof (spr_map[0]))\n     {\n       int spr_reg_offset = spr_map[reg - first_spr_regnum];\n \n@@ -457,8 +457,8 @@ frv_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr)\n \tbreak;\n \n       /* This is a big endian architecture, so byte zero will have most\n-         significant byte.  The most significant bit of this byte is the\n-         packing bit.  */\n+\t significant byte.  The most significant bit of this byte is the\n+\t packing bit.  */\n       if (instr[0] & 0x80)\n \tbreak;\n \n@@ -478,8 +478,8 @@ static int\n is_caller_saves_reg (int reg)\n {\n   return ((4 <= reg && reg <= 7)\n-          || (14 <= reg && reg <= 15)\n-          || (32 <= reg && reg <= 47));\n+\t  || (14 <= reg && reg <= 15)\n+\t  || (32 <= reg && reg <= 47));\n }\n \n \n@@ -488,7 +488,7 @@ static int\n is_callee_saves_reg (int reg)\n {\n   return ((16 <= reg && reg <= 31)\n-          || (48 <= reg && reg <= 63));\n+\t  || (48 <= reg && reg <= 63));\n }\n \n \n@@ -514,7 +514,7 @@ is_argument_reg (int reg)\n static CORE_ADDR\n frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t\t      struct frame_info *this_frame,\n-                      struct frv_unwind_cache *info)\n+\t\t      struct frv_unwind_cache *info)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n@@ -638,7 +638,7 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t Media Trap\n \t  X XXXX XX 0000100 XXXXXX XXXX 10 XXXXXX */\n       if ((op & 0x01d80000) == 0x00180000 /* Conditional branches and Call */\n-          || (op & 0x01f80000) == 0x00300000  /* Jump and Link */\n+\t  || (op & 0x01f80000) == 0x00300000  /* Jump and Link */\n \t  || (op & 0x01f80000) == 0x00100000  /* Return from Trap, Trap */\n \t  || (op & 0x01f80000) == 0x00700000) /* Trap immediate */\n \t{\n@@ -647,13 +647,13 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t}\n \n       /* Loading something from memory into fp probably means that\n-         we're in the epilogue.  Stop scanning the prologue.\n-         ld @(GRi, GRk), fp\n+\t we're in the epilogue.  Stop scanning the prologue.\n+\t ld @(GRi, GRk), fp\n \t X 000010 0000010 XXXXXX 000100 XXXXXX\n \t ldi @(GRi, d12), fp\n \t X 000010 0110010 XXXXXX XXXXXXXXXXXX */\n       else if ((op & 0x7ffc0fc0) == 0x04080100\n-               || (op & 0x7ffc0000) == 0x04c80000)\n+\t       || (op & 0x7ffc0000) == 0x04c80000)\n \t{\n \t  break;\n \t}\n@@ -662,7 +662,7 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t ori sp, 0, fp\n \t P 000010 0100010 000001 000000000000 = 0x04881000\n \t 0 111111 1111111 111111 111111111111 = 0x7fffffff\n-             .    .   .    .   .    .   .   .\n+\t     .    .   .    .   .    .   .   .\n \t We treat this as part of the prologue.  */\n       else if ((op & 0x7fffffff) == 0x04881000)\n \t{\n@@ -672,25 +672,25 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t}\n \n       /* Move the link register to the scratch register grJ, before saving:\n-         movsg lr, grJ\n-         P 000100 0000011 010000 000111 JJJJJJ = 0x080d01c0\n-         0 111111 1111111 111111 111111 000000 = 0x7fffffc0\n-             .    .   .    .   .    .    .   .\n+\t movsg lr, grJ\n+\t P 000100 0000011 010000 000111 JJJJJJ = 0x080d01c0\n+\t 0 111111 1111111 111111 111111 000000 = 0x7fffffc0\n+\t     .    .   .    .   .    .    .   .\n \t We treat this as part of the prologue.  */\n       else if ((op & 0x7fffffc0) == 0x080d01c0)\n-        {\n-          int gr_j = op & 0x3f;\n+\t{\n+\t  int gr_j = op & 0x3f;\n \n-          /* If we're moving it to a scratch register, that's fine.  */\n-          if (is_caller_saves_reg (gr_j))\n+\t  /* If we're moving it to a scratch register, that's fine.  */\n+\t  if (is_caller_saves_reg (gr_j))\n \t    {\n \t      lr_save_reg = gr_j;\n \t      last_prologue_pc = next_pc;\n \t    }\n-        }\n+\t}\n \n       /* To save multiple callee-saves registers on the stack, at\n-         offset zero:\n+\t offset zero:\n \n \t std grK,@(sp,gr0)\n \t P KKKKKK 0000011 000001 000011 000000 = 0x000c10c0\n@@ -699,28 +699,28 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t stq grK,@(sp,gr0)\n \t P KKKKKK 0000011 000001 000100 000000 = 0x000c1100\n \t 0 000000 1111111 111111 111111 111111 = 0x01ffffff\n-             .    .   .    .   .    .    .   .\n-         We treat this as part of the prologue, and record the register's\n+\t     .    .   .    .   .    .    .   .\n+\t We treat this as part of the prologue, and record the register's\n \t saved address in the frame structure.  */\n       else if ((op & 0x01ffffff) == 0x000c10c0\n-            || (op & 0x01ffffff) == 0x000c1100)\n+\t    || (op & 0x01ffffff) == 0x000c1100)\n \t{\n \t  int gr_k = ((op >> 25) & 0x3f);\n \t  int ope  = ((op >> 6)  & 0x3f);\n-          int count;\n+\t  int count;\n \t  int i;\n \n-          /* Is it an std or an stq?  */\n-          if (ope == 0x03)\n-            count = 2;\n-          else\n-            count = 4;\n+\t  /* Is it an std or an stq?  */\n+\t  if (ope == 0x03)\n+\t    count = 2;\n+\t  else\n+\t    count = 4;\n \n \t  /* Is it really a callee-saves register?  */\n \t  if (is_callee_saves_reg (gr_k))\n \t    {\n \t      for (i = 0; i < count; i++)\n-\t        {\n+\t\t{\n \t\t  gr_saved[gr_k + i] = 1;\n \t\t  gr_sp_offset[gr_k + i] = 4 * i;\n \t\t}\n@@ -730,12 +730,12 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \n       /* Adjusting the stack pointer.  (The stack pointer is GR1.)\n \t addi sp, S, sp\n-         P 000001 0010000 000001 SSSSSSSSSSSS = 0x02401000\n-         0 111111 1111111 111111 000000000000 = 0x7ffff000\n-             .    .   .    .   .    .   .   .\n+\t P 000001 0010000 000001 SSSSSSSSSSSS = 0x02401000\n+\t 0 111111 1111111 111111 000000000000 = 0x7ffff000\n+\t     .    .   .    .   .    .   .   .\n \t We treat this as part of the prologue.  */\n       else if ((op & 0x7ffff000) == 0x02401000)\n-        {\n+\t{\n \t  if (framesize == 0)\n \t    {\n \t      /* Sign-extend the twelve-bit field.\n@@ -748,17 +748,17 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t  else\n \t    {\n \t      /* If the prologue is being adjusted again, we've\n-\t         likely gone too far; i.e. we're probably in the\n+\t\t likely gone too far; i.e. we're probably in the\n \t\t epilogue.  */\n \t      break;\n \t    }\n \t}\n \n       /* Setting the FP to a constant distance from the SP:\n \t addi sp, S, fp\n-         P 000010 0010000 000001 SSSSSSSSSSSS = 0x04401000\n-         0 111111 1111111 111111 000000000000 = 0x7ffff000\n-             .    .   .    .   .    .   .   .\n+\t P 000010 0010000 000001 SSSSSSSSSSSS = 0x04401000\n+\t 0 111111 1111111 111111 000000000000 = 0x7ffff000\n+\t     .    .   .    .   .    .   .   .\n \t We treat this as part of the prologue.  */\n       else if ((op & 0x7ffff000) == 0x04401000)\n \t{\n@@ -786,7 +786,7 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t{\n \t  int gr_i = ((op >> 12) & 0x3f);\n \n-          /* Make sure that the source is an arg register; if it is, we'll\n+\t  /* Make sure that the source is an arg register; if it is, we'll\n \t     treat it as a prologue instruction.  */\n \t  if (is_argument_reg (gr_i))\n \t    last_prologue_pc = next_pc;\n@@ -796,50 +796,50 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t     sthi GRk, @(fp, s)\n \t P KKKKKK 1010001 000010 SSSSSSSSSSSS = 0x01442000\n \t 0 000000 1111111 111111 000000000000 = 0x01fff000\n-             .    .   .    .   .    .   .   . \n-         And for 8-bit values, we use STB instructions.\n+\t     .    .   .    .   .    .   .   . \n+\t And for 8-bit values, we use STB instructions.\n \t     stbi GRk, @(fp, s)\n \t P KKKKKK 1010000 000010 SSSSSSSSSSSS = 0x01402000\n \t 0 000000 1111111 111111 000000000000 = 0x01fff000\n \t     .    .   .    .   .    .   .   .\n-         We check that GRk is really an argument register, and treat\n-         all such as part of the prologue.  */\n+\t We check that GRk is really an argument register, and treat\n+\t all such as part of the prologue.  */\n       else if (   (op & 0x01fff000) == 0x01442000\n \t       || (op & 0x01fff000) == 0x01402000)\n \t{\n \t  int gr_k = ((op >> 25) & 0x3f);\n \n-          /* Make sure that GRk is really an argument register; treat\n+\t  /* Make sure that GRk is really an argument register; treat\n \t     it as a prologue instruction if so.  */\n \t  if (is_argument_reg (gr_k))\n \t    last_prologue_pc = next_pc;\n \t}\n \n       /* To save multiple callee-saves register on the stack, at a\n-         non-zero offset:\n+\t non-zero offset:\n \n \t stdi GRk, @(sp, s)\n \t P KKKKKK 1010011 000001 SSSSSSSSSSSS = 0x014c1000\n \t 0 000000 1111111 111111 000000000000 = 0x01fff000\n-             .    .   .    .   .    .   .   .\n+\t     .    .   .    .   .    .   .   .\n \t stqi GRk, @(sp, s)\n \t P KKKKKK 1010100 000001 SSSSSSSSSSSS = 0x01501000\n \t 0 000000 1111111 111111 000000000000 = 0x01fff000\n \t     .    .   .    .   .    .   .   .\n-         We treat this as part of the prologue, and record the register's\n+\t We treat this as part of the prologue, and record the register's\n \t saved address in the frame structure.  */\n       else if ((op & 0x01fff000) == 0x014c1000\n-            || (op & 0x01fff000) == 0x01501000)\n+\t    || (op & 0x01fff000) == 0x01501000)\n \t{\n \t  int gr_k = ((op >> 25) & 0x3f);\n-          int count;\n+\t  int count;\n \t  int i;\n \n-          /* Is it a stdi or a stqi?  */\n-          if ((op & 0x01fff000) == 0x014c1000)\n-            count = 2;\n-          else\n-            count = 4;\n+\t  /* Is it a stdi or a stqi?  */\n+\t  if ((op & 0x01fff000) == 0x014c1000)\n+\t    count = 2;\n+\t  else\n+\t    count = 4;\n \n \t  /* Is it really a callee-saves register?  */\n \t  if (is_callee_saves_reg (gr_k))\n@@ -858,77 +858,77 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t}\n \n       /* Storing any kind of integer register at any constant offset\n-         from any other register.\n+\t from any other register.\n \n \t st GRk, @(GRi, gr0)\n-         P KKKKKK 0000011 IIIIII 000010 000000 = 0x000c0080\n-         0 000000 1111111 000000 111111 111111 = 0x01fc0fff\n-             .    .   .    .   .    .    .   .\n+\t P KKKKKK 0000011 IIIIII 000010 000000 = 0x000c0080\n+\t 0 000000 1111111 000000 111111 111111 = 0x01fc0fff\n+\t     .    .   .    .   .    .    .   .\n \t sti GRk, @(GRi, d12)\n \t P KKKKKK 1010010 IIIIII SSSSSSSSSSSS = 0x01480000\n \t 0 000000 1111111 000000 000000000000 = 0x01fc0000\n-             .    .   .    .   .    .   .   .\n-         These could be almost anything, but a lot of prologue\n-         instructions fall into this pattern, so let's decode the\n-         instruction once, and then work at a higher level.  */\n+\t     .    .   .    .   .    .   .   .\n+\t These could be almost anything, but a lot of prologue\n+\t instructions fall into this pattern, so let's decode the\n+\t instruction once, and then work at a higher level.  */\n       else if (((op & 0x01fc0fff) == 0x000c0080)\n-            || ((op & 0x01fc0000) == 0x01480000))\n-        {\n-          int gr_k = ((op >> 25) & 0x3f);\n-          int gr_i = ((op >> 12) & 0x3f);\n-          int offset;\n-\n-          /* Are we storing with gr0 as an offset, or using an\n-             immediate value?  */\n-          if ((op & 0x01fc0fff) == 0x000c0080)\n-            offset = 0;\n-          else\n-            offset = (((op & 0xfff) - 0x800) & 0xfff) - 0x800;\n-\n-          /* If the address isn't relative to the SP or FP, it's not a\n-             prologue instruction.  */\n-          if (gr_i != sp_regnum && gr_i != fp_regnum)\n+\t    || ((op & 0x01fc0000) == 0x01480000))\n+\t{\n+\t  int gr_k = ((op >> 25) & 0x3f);\n+\t  int gr_i = ((op >> 12) & 0x3f);\n+\t  int offset;\n+\n+\t  /* Are we storing with gr0 as an offset, or using an\n+\t     immediate value?  */\n+\t  if ((op & 0x01fc0fff) == 0x000c0080)\n+\t    offset = 0;\n+\t  else\n+\t    offset = (((op & 0xfff) - 0x800) & 0xfff) - 0x800;\n+\n+\t  /* If the address isn't relative to the SP or FP, it's not a\n+\t     prologue instruction.  */\n+\t  if (gr_i != sp_regnum && gr_i != fp_regnum)\n \t    {\n \t      /* Do nothing; not a prologue instruction.  */\n \t    }\n \n-          /* Saving the old FP in the new frame (relative to the SP).  */\n-          else if (gr_k == fp_regnum && gr_i == sp_regnum)\n+\t  /* Saving the old FP in the new frame (relative to the SP).  */\n+\t  else if (gr_k == fp_regnum && gr_i == sp_regnum)\n \t    {\n \t      gr_saved[fp_regnum] = 1;\n-              gr_sp_offset[fp_regnum] = offset;\n+\t      gr_sp_offset[fp_regnum] = offset;\n \t      last_prologue_pc = next_pc;\n \t    }\n \n-          /* Saving callee-saves register(s) on the stack, relative to\n-             the SP.  */\n-          else if (gr_i == sp_regnum\n-                   && is_callee_saves_reg (gr_k))\n-            {\n-              gr_saved[gr_k] = 1;\n+\t  /* Saving callee-saves register(s) on the stack, relative to\n+\t     the SP.  */\n+\t  else if (gr_i == sp_regnum\n+\t\t   && is_callee_saves_reg (gr_k))\n+\t    {\n+\t      gr_saved[gr_k] = 1;\n \t      if (gr_i == sp_regnum)\n \t\tgr_sp_offset[gr_k] = offset;\n \t      else\n \t\tgr_sp_offset[gr_k] = offset + fp_offset;\n \t      last_prologue_pc = next_pc;\n-            }\n+\t    }\n \n-          /* Saving the scratch register holding the return address.  */\n-          else if (lr_save_reg != -1\n-                   && gr_k == lr_save_reg)\n+\t  /* Saving the scratch register holding the return address.  */\n+\t  else if (lr_save_reg != -1\n+\t\t   && gr_k == lr_save_reg)\n \t    {\n \t      lr_saved_on_stack = 1;\n \t      if (gr_i == sp_regnum)\n \t\tlr_sp_offset = offset;\n \t      else\n-\t        lr_sp_offset = offset + fp_offset;\n+\t\tlr_sp_offset = offset + fp_offset;\n \t      last_prologue_pc = next_pc;\n \t    }\n \n-          /* Spilling int-sized arguments to the stack.  */\n-          else if (is_argument_reg (gr_k))\n+\t  /* Spilling int-sized arguments to the stack.  */\n+\t  else if (is_argument_reg (gr_k))\n \t    last_prologue_pc = next_pc;\n-        }\n+\t}\n       pc = next_pc;\n     }\n \n@@ -938,10 +938,10 @@ frv_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,\n       ULONGEST this_base;\n \n       /* If we know the relationship between the stack and frame\n-         pointers, record the addresses of the registers we noticed.\n-         Note that we have to do this as a separate step at the end,\n-         because instructions may save relative to the SP, but we need\n-         their addresses relative to the FP.  */\n+\t pointers, record the addresses of the registers we noticed.\n+\t Note that we have to do this as a separate step at the end,\n+\t because instructions may save relative to the SP, but we need\n+\t their addresses relative to the FP.  */\n       if (fp_set)\n \tthis_base = get_frame_register_unsigned (this_frame, fp_regnum);\n       else\n@@ -1055,7 +1055,7 @@ frv_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n      call label24\n      P HHHHHH 0001111 LLLLLLLLLLLLLLLLLL = 0x003c0000\n      0 000000 1111111 000000000000000000 = 0x01fc0000\n-         .    .   .    .   .   .   .   .\n+\t .    .   .    .   .   .   .   .\n \n      where label24 is constructed by concatenating the H bits with the\n      L bits.  The call target is PC + (4 * sign_ext(label24)).  */\n@@ -1074,7 +1074,7 @@ frv_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n       s = lookup_minimal_symbol_by_pc (call_dest);\n \n       if (s.minsym != NULL\n-          && s.minsym->linkage_name () != NULL\n+\t  && s.minsym->linkage_name () != NULL\n \t  && strcmp (s.minsym->linkage_name (), \"__main\") == 0)\n \t{\n \t  pc += 4;\n@@ -1108,7 +1108,7 @@ frv_frame_unwind_cache (struct frame_info *this_frame,\n \n static void\n frv_extract_return_value (struct type *type, struct regcache *regcache,\n-                          gdb_byte *valbuf)\n+\t\t\t  gdb_byte *valbuf)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n@@ -1167,14 +1167,14 @@ find_func_descr (struct gdbarch *gdbarch, CORE_ADDR entry_point)\n   store_unsigned_integer (valbuf, 4, byte_order, entry_point);\n   write_memory (descr, valbuf, 4);\n   store_unsigned_integer (valbuf, 4, byte_order,\n-                          frv_fdpic_find_global_pointer (entry_point));\n+\t\t\t  frv_fdpic_find_global_pointer (entry_point));\n   write_memory (descr + 4, valbuf, 4);\n   return descr;\n }\n \n static CORE_ADDR\n frv_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,\n-                                struct target_ops *targ)\n+\t\t\t\tstruct target_ops *targ)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   CORE_ADDR entry_point;\n@@ -1191,8 +1191,8 @@ frv_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,\n \n static CORE_ADDR\n frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n-                     struct regcache *regcache, CORE_ADDR bp_addr,\n-                     int nargs, struct value **args, CORE_ADDR sp,\n+\t\t     struct regcache *regcache, CORE_ADDR bp_addr,\n+\t\t     int nargs, struct value **args, CORE_ADDR sp,\n \t\t     function_call_return_method return_method,\n \t\t     CORE_ADDR struct_addr)\n {\n@@ -1233,7 +1233,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n   if (return_method == return_method_struct)\n     regcache_cooked_write_unsigned (regcache, struct_return_regnum,\n-                                    struct_addr);\n+\t\t\t\t    struct_addr);\n \n   for (argnum = 0; argnum < nargs; ++argnum)\n     {\n@@ -1252,8 +1252,8 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t}\n       else if (abi == FRV_ABI_FDPIC\n \t       && len == 4\n-               && typecode == TYPE_CODE_PTR\n-               && TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_FUNC)\n+\t       && typecode == TYPE_CODE_PTR\n+\t       && TYPE_TARGET_TYPE (arg_type)->code () == TYPE_CODE_FUNC)\n \t{\n \t  /* The FDPIC ABI requires function descriptors to be passed instead\n \t     of entry points.  */\n@@ -1308,7 +1308,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       /* Set the GOT register for the FDPIC ABI.  */\n       regcache_cooked_write_unsigned\n \t(regcache, first_gpr_regnum + 15,\n-         frv_fdpic_find_global_pointer (func_addr));\n+\t frv_fdpic_find_global_pointer (func_addr));\n     }\n \n   /* Finally, update the SP register.  */\n@@ -1319,7 +1319,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n static void\n frv_store_return_value (struct type *type, struct regcache *regcache,\n-                        const gdb_byte *valbuf)\n+\t\t\tconst gdb_byte *valbuf)\n {\n   int len = TYPE_LENGTH (type);\n \n@@ -1337,7 +1337,7 @@ frv_store_return_value (struct type *type, struct regcache *regcache,\n     }\n   else\n     internal_error (__FILE__, __LINE__,\n-                    _(\"Don't know how to return a %d-byte value.\"), len);\n+\t\t    _(\"Don't know how to return a %d-byte value.\"), len);\n }\n \n static enum return_value_convention\n@@ -1568,7 +1568,7 @@ frv_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             frv_fetch_objfile_link_map);\n+\t\t\t\t\t     frv_fetch_objfile_link_map);\n \n   return gdbarch;\n }"
    },
    {
      "sha": "d152e9766848d61c375beedc4d6c1a9ae040de0a",
      "filename": "gdb/frv-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/frv-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -102,7 +102,7 @@ enum frv_abi frv_abi (struct gdbarch *gdbarch);\n    library support) for the FDPIC ABI.  Return 0 if successful, -1 if\n    not.  (E.g, -1 will be returned if the ABI isn't the FDPIC ABI.)  */\n int frv_fdpic_loadmap_addresses (struct gdbarch *gdbarch,\n-                                 CORE_ADDR *interp_addr, CORE_ADDR *exec_addr);\n+\t\t\t\t CORE_ADDR *interp_addr, CORE_ADDR *exec_addr);\n \n /* Given a function entry point, find and return the GOT address for the\n    containing load module.  */"
    },
    {
      "sha": "0b6f7a7bcc1ab563ec413d1b23f27400b562fdf7",
      "filename": "gdb/ft32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ft32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ft32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ft32-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -144,7 +144,7 @@ ft32_store_return_value (struct type *type, struct regcache *regcache,\n \n static ULONGEST\n ft32_fetch_instruction (CORE_ADDR a, int *isize,\n-\t\t        enum bfd_endian byte_order)\n+\t\t\tenum bfd_endian byte_order)\n {\n   unsigned int sc[2];\n   ULONGEST inst;"
    },
    {
      "sha": "9a22b1005f0fdaf51ef182675876cc12992ea753",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -384,10 +384,10 @@ gcore_create_callback (CORE_ADDR vaddr, unsigned long size, int read,\n   if (read == 0 && write == 0 && exec == 0 && modified == 0)\n     {\n       if (info_verbose)\n-        {\n-          fprintf_filtered (gdb_stdout, \"Ignore segment, %s bytes at %s\\n\",\n-                            plongest (size), paddress (target_gdbarch (), vaddr));\n-        }\n+\t{\n+\t  fprintf_filtered (gdb_stdout, \"Ignore segment, %s bytes at %s\\n\",\n+\t\t\t    plongest (size), paddress (target_gdbarch (), vaddr));\n+\t}\n \n       return 0;\n     }"
    },
    {
      "sha": "a61656a6ffe2e5df11a45f039f2e936f84e458b1",
      "filename": "gdb/gdb_bfd.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_bfd.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -216,47 +216,47 @@ fileio_errno_to_host (int errnum)\n   switch (errnum)\n     {\n       case FILEIO_EPERM:\n-        return EPERM;\n+\treturn EPERM;\n       case FILEIO_ENOENT:\n-        return ENOENT;\n+\treturn ENOENT;\n       case FILEIO_EINTR:\n-        return EINTR;\n+\treturn EINTR;\n       case FILEIO_EIO:\n-        return EIO;\n+\treturn EIO;\n       case FILEIO_EBADF:\n-        return EBADF;\n+\treturn EBADF;\n       case FILEIO_EACCES:\n-        return EACCES;\n+\treturn EACCES;\n       case FILEIO_EFAULT:\n-        return EFAULT;\n+\treturn EFAULT;\n       case FILEIO_EBUSY:\n-        return EBUSY;\n+\treturn EBUSY;\n       case FILEIO_EEXIST:\n-        return EEXIST;\n+\treturn EEXIST;\n       case FILEIO_ENODEV:\n-        return ENODEV;\n+\treturn ENODEV;\n       case FILEIO_ENOTDIR:\n-        return ENOTDIR;\n+\treturn ENOTDIR;\n       case FILEIO_EISDIR:\n-        return EISDIR;\n+\treturn EISDIR;\n       case FILEIO_EINVAL:\n-        return EINVAL;\n+\treturn EINVAL;\n       case FILEIO_ENFILE:\n-        return ENFILE;\n+\treturn ENFILE;\n       case FILEIO_EMFILE:\n-        return EMFILE;\n+\treturn EMFILE;\n       case FILEIO_EFBIG:\n-        return EFBIG;\n+\treturn EFBIG;\n       case FILEIO_ENOSPC:\n-        return ENOSPC;\n+\treturn ENOSPC;\n       case FILEIO_ESPIPE:\n-        return ESPIPE;\n+\treturn ESPIPE;\n       case FILEIO_EROFS:\n-        return EROFS;\n+\treturn EROFS;\n       case FILEIO_ENOSYS:\n-        return ENOSYS;\n+\treturn ENOSYS;\n       case FILEIO_ENAMETOOLONG:\n-        return ENAMETOOLONG;\n+\treturn ENAMETOOLONG;\n     }\n   return -1;\n }\n@@ -317,8 +317,8 @@ gdb_bfd_iovec_fileio_pread (struct bfd *abfd, void *stream, void *buf,\n \t\t\t\t   nbytes - pos, offset + pos,\n \t\t\t\t   &target_errno);\n       if (bytes == 0)\n-        /* Success, but no bytes, means end-of-file.  */\n-        break;\n+\t/* Success, but no bytes, means end-of-file.  */\n+\tbreak;\n       if (bytes == -1)\n \t{\n \t  errno = fileio_errno_to_host (target_errno);"
    },
    {
      "sha": "6f6d77b0cd9ca5161fc9cdbe9b65f6c253b55888",
      "filename": "gdb/gdb_buildall.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_buildall.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_buildall.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_buildall.sh?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -39,7 +39,7 @@ Options:\n   -e <regexp>    Regular expression for selecting the targets to build.\n   --force        Force rebuild.\n   -j <makejobs>  Run <makejobs> in parallel.  Passed to make.\n-                 On a single cpu machine, 2 is recommended.\n+\t\t On a single cpu machine, 2 is recommended.\n  Arguments:\n    <srcdir>       Source code directory.\n    <builddir>     Build directory.\n@@ -66,9 +66,9 @@ do\n       makejobs=\"-j $1\"\n       ;;\n       --clean )\n-        # Shall the build directory be deleted after processing?\n-        clean=true\n-        ;;\n+\t# Shall the build directory be deleted after processing?\n+\tclean=true\n+\t;;\n     -e )\n       # A regular expression for selecting targets\n       shift"
    },
    {
      "sha": "7ab466407f5cb6d62e9f1acca6802fd0252fa007",
      "filename": "gdb/gdb_mbuild.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_mbuild.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdb_mbuild.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_mbuild.sh?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -31,7 +31,7 @@ usage()\n Usage: gdb_mbuild.sh [ <options> ... ] <srcdir> <builddir>\n  Options:\n    -j <makejobs>  Run <makejobs> in parallel.  Passed to make.\n-\t          On a single cpu machine, 2 is recommended.\n+\t\t  On a single cpu machine, 2 is recommended.\n    -k             Keep going.  Do not stop after the first build fails.\n    --keep         Keep builds.  Do not remove each build when finished.\n    -e <regexp>    Regular expression for selecting the targets to build.\n@@ -79,7 +79,7 @@ do\n \tkeepgoing=-k\n \t;;\n     --keep )\n-        keep=true\n+\tkeep=true\n \t;;\n     -e )\n \t# A regular expression for selecting targets"
    },
    {
      "sha": "0b43ae434ea9cff6f0e08ede4cbdc4e8d8a8a10a",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -53,7 +53,7 @@ static void alloc_gdbarch_data (struct gdbarch *);\n unsigned int gdbarch_debug = GDBARCH_DEBUG;\n static void\n show_gdbarch_debug (struct ui_file *file, int from_tty,\n-                    struct cmd_list_element *c, const char *value)\n+\t\t    struct cmd_list_element *c, const char *value)\n {\n   fprintf_filtered (file, _(\"Architecture debugging is %s.\\n\"), value);\n }\n@@ -358,7 +358,7 @@ struct gdbarch\n \n struct gdbarch *\n gdbarch_alloc (const struct gdbarch_info *info,\n-               struct gdbarch_tdep *tdep)\n+\t       struct gdbarch_tdep *tdep)\n {\n   struct gdbarch *gdbarch;\n \n@@ -723,8 +723,8 @@ verify_gdbarch (struct gdbarch *gdbarch)\n   /* Skip verify of read_core_file_mappings, invalid_p == 0 */\n   if (!log.empty ())\n     internal_error (__FILE__, __LINE__,\n-                    _(\"verify_gdbarch: the following are invalid ...%s\"),\n-                    log.c_str ());\n+\t\t    _(\"verify_gdbarch: the following are invalid ...%s\"),\n+\t\t    log.c_str ());\n }\n \n \n@@ -739,8 +739,8 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   gdb_nm_file = GDB_NM_FILE;\n #endif\n   fprintf_unfiltered (file,\n-                      \"gdbarch_dump: GDB_NM_FILE = %s\\n\",\n-                      gdb_nm_file);\n+\t\t      \"gdbarch_dump: GDB_NM_FILE = %s\\n\",\n+\t\t      gdb_nm_file);\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: addr_bit = %s\\n\",\n                       plongest (gdbarch->addr_bit));\n@@ -5351,13 +5351,13 @@ gdbarch_printable_names (void)\n       const struct bfd_arch_info *ap;\n       ap = bfd_lookup_arch (rego->bfd_architecture, 0);\n       if (ap == NULL)\n-        internal_error (__FILE__, __LINE__,\n-                        _(\"gdbarch_architecture_names: multi-arch unknown\"));\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n       do\n-        {\n-          append_name (&arches, &nr_arches, ap->printable_name);\n-          ap = ap->next;\n-        }\n+\t{\n+\t  append_name (&arches, &nr_arches, ap->printable_name);\n+\t  ap = ap->next;\n+\t}\n       while (ap != NULL);\n     }\n   append_name (&arches, &nr_arches, NULL);\n@@ -5367,7 +5367,7 @@ gdbarch_printable_names (void)\n \n void\n gdbarch_register (enum bfd_architecture bfd_architecture,\n-                  gdbarch_init_ftype *init,\n+\t\t  gdbarch_init_ftype *init,\n \t\t  gdbarch_dump_tdep_ftype *dump_tdep)\n {\n   struct gdbarch_registration **curr;\n@@ -5378,9 +5378,9 @@ gdbarch_register (enum bfd_architecture bfd_architecture,\n   if (bfd_arch_info == NULL)\n     {\n       internal_error (__FILE__, __LINE__,\n-                      _(\"gdbarch: Attempt to register \"\n+\t\t      _(\"gdbarch: Attempt to register \"\n \t\t\t\"unknown architecture (%d)\"),\n-                      bfd_architecture);\n+\t\t      bfd_architecture);\n     }\n   /* Check that we haven't seen this architecture before.  */\n   for (curr = &gdbarch_registry;\n@@ -5389,9 +5389,9 @@ gdbarch_register (enum bfd_architecture bfd_architecture,\n     {\n       if (bfd_architecture == (*curr)->bfd_architecture)\n \tinternal_error (__FILE__, __LINE__,\n-                        _(\"gdbarch: Duplicate registration \"\n+\t\t\t_(\"gdbarch: Duplicate registration \"\n \t\t\t  \"of architecture (%s)\"),\n-\t                bfd_arch_info->printable_name);\n+\t\t\tbfd_arch_info->printable_name);\n     }\n   /* log it */\n   if (gdbarch_debug)\n@@ -5419,7 +5419,7 @@ register_gdbarch_init (enum bfd_architecture bfd_architecture,\n \n struct gdbarch_list *\n gdbarch_list_lookup_by_info (struct gdbarch_list *arches,\n-                             const struct gdbarch_info *info)\n+\t\t\t     const struct gdbarch_info *info)\n {\n   for (; arches != NULL; arches = arches->next)\n     {\n@@ -5589,7 +5589,7 @@ _initialize_gdbarch ()\n Set architecture debugging.\"), _(\"\\\n Show architecture debugging.\"), _(\"\\\n When non-zero, architecture debugging is enabled.\"),\n-                            NULL,\n-                            show_gdbarch_debug,\n-                            &setdebuglist, &showdebuglist);\n+\t\t\t    NULL,\n+\t\t\t    show_gdbarch_debug,\n+\t\t\t    &setdebuglist, &showdebuglist);\n }"
    },
    {
      "sha": "b620bb25b9014aaf65c5da30879a26a3d1806b9f",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1748,8 +1748,8 @@ typedef void (gdbarch_dump_tdep_ftype) (struct gdbarch *gdbarch, struct ui_file\n extern void register_gdbarch_init (enum bfd_architecture architecture, gdbarch_init_ftype *);\n \n extern void gdbarch_register (enum bfd_architecture architecture,\n-                              gdbarch_init_ftype *,\n-                              gdbarch_dump_tdep_ftype *);\n+\t\t\t      gdbarch_init_ftype *,\n+\t\t\t      gdbarch_dump_tdep_ftype *);\n \n \n /* Return a freshly allocated, NULL terminated, array of the valid"
    },
    {
      "sha": "d27318a757c78ac39e615fcb90ce6fb40107551a",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 32,
      "deletions": 32,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -189,7 +189,7 @@ do\n \t#   hiding something from the ``struct info'' object\n \t# m -> multi-arch function\n \t#   hiding a multi-arch function (parameterised with the architecture)\n-        # M -> multi-arch function + predicate\n+\t# M -> multi-arch function + predicate\n \t#   hiding a multi-arch function + predicate to test function validity\n \n     returntype ) : ;;\n@@ -1530,8 +1530,8 @@ typedef void (gdbarch_dump_tdep_ftype) (struct gdbarch *gdbarch, struct ui_file\n extern void register_gdbarch_init (enum bfd_architecture architecture, gdbarch_init_ftype *);\n \n extern void gdbarch_register (enum bfd_architecture architecture,\n-                              gdbarch_init_ftype *,\n-                              gdbarch_dump_tdep_ftype *);\n+\t\t\t      gdbarch_init_ftype *,\n+\t\t\t      gdbarch_dump_tdep_ftype *);\n \n \n /* Return a freshly allocated, NULL terminated, array of the valid\n@@ -1706,7 +1706,7 @@ static void alloc_gdbarch_data (struct gdbarch *);\n unsigned int gdbarch_debug = GDBARCH_DEBUG;\n static void\n show_gdbarch_debug (struct ui_file *file, int from_tty,\n-                    struct cmd_list_element *c, const char *value)\n+\t\t    struct cmd_list_element *c, const char *value)\n {\n   fprintf_filtered (file, _(\"Architecture debugging is %s.\\\\n\"), value);\n }\n@@ -1844,7 +1844,7 @@ printf \"\\n\"\n cat <<EOF\n struct gdbarch *\n gdbarch_alloc (const struct gdbarch_info *info,\n-               struct gdbarch_tdep *tdep)\n+\t       struct gdbarch_tdep *tdep)\n {\n   struct gdbarch *gdbarch;\n \n@@ -1980,8 +1980,8 @@ done\n cat <<EOF\n   if (!log.empty ())\n     internal_error (__FILE__, __LINE__,\n-                    _(\"verify_gdbarch: the following are invalid ...%s\"),\n-                    log.c_str ());\n+\t\t    _(\"verify_gdbarch: the following are invalid ...%s\"),\n+\t\t    log.c_str ());\n }\n EOF\n \n@@ -2000,8 +2000,8 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   gdb_nm_file = GDB_NM_FILE;\n #endif\n   fprintf_unfiltered (file,\n-                      \"gdbarch_dump: GDB_NM_FILE = %s\\\\n\",\n-                      gdb_nm_file);\n+\t\t      \"gdbarch_dump: GDB_NM_FILE = %s\\\\n\",\n+\t\t      gdb_nm_file);\n EOF\n function_list | sort '-t;' -k 3 | while do_read\n do\n@@ -2026,13 +2026,13 @@ do\n \t\tprint=\"core_addr_to_string_nz (gdbarch->${function})\"\n \t\t;;\n \t    :* )\n-\t        fmt=\"%s\"\n+\t\tfmt=\"%s\"\n \t\tprint=\"plongest (gdbarch->${function})\"\n \t\t;;\n \t    * )\n-\t        fmt=\"%s\"\n+\t\tfmt=\"%s\"\n \t\t;;\n-        esac\n+\tesac\n \tprintf \"  fprintf_unfiltered (file,\\n\"\n \tprintf \"                      \\\"gdbarch_dump: %s = %s\\\\\\\\n\\\",\\n\" \"$function\" \"$fmt\"\n \tprintf \"                      %s);\\n\" \"$print\"\n@@ -2065,7 +2065,7 @@ do\n \tprintf \"bool\\n\"\n \tprintf \"gdbarch_%s_p (struct gdbarch *gdbarch)\\n\" \"$function\"\n \tprintf \"{\\n\"\n-        printf \"  gdb_assert (gdbarch != NULL);\\n\"\n+\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n \tprintf \"  return %s;\\n\" \"$predicate\"\n \tprintf \"}\\n\"\n     fi\n@@ -2080,7 +2080,7 @@ do\n \t  printf \"gdbarch_%s (struct gdbarch *gdbarch, %s)\\n\" \"$function\" \"$formal\"\n \tfi\n \tprintf \"{\\n\"\n-        printf \"  gdb_assert (gdbarch != NULL);\\n\"\n+\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n \tprintf \"  gdb_assert (gdbarch->%s != NULL);\\n\" \"$function\"\n \tif class_is_predicate_p && test -n \"${predefault}\"\n \tthen\n@@ -2104,7 +2104,7 @@ do\n \t    else\n \t\tparams=\"${actual}\"\n \t    fi\n-        fi\n+\tfi\n        \tif [ \"x${returntype}\" = \"xvoid\" ]\n \tthen\n \t  printf \"  gdbarch->%s (%s);\\n\" \"$function\" \"$params\"\n@@ -2125,7 +2125,7 @@ do\n \tprintf \"%s\\n\" \"$returntype\"\n \tprintf \"gdbarch_%s (struct gdbarch *gdbarch)\\n\" \"$function\"\n \tprintf \"{\\n\"\n-        printf \"  gdb_assert (gdbarch != NULL);\\n\"\n+\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n \tif [ \"x${invalid_p}\" = \"x0\" ]\n \tthen\n \t    printf \"  /* Skip verify of %s, invalid_p == 0 */\\n\" \"$function\"\n@@ -2155,7 +2155,7 @@ do\n \tprintf \"%s\\n\" \"$returntype\"\n \tprintf \"gdbarch_%s (struct gdbarch *gdbarch)\\n\" \"$function\"\n \tprintf \"{\\n\"\n-        printf \"  gdb_assert (gdbarch != NULL);\\n\"\n+\tprintf \"  gdb_assert (gdbarch != NULL);\\n\"\n \tprintf \"  if (gdbarch_debug >= 2)\\n\"\n \tprintf \"    fprintf_unfiltered (gdb_stdlog, \\\"gdbarch_%s called\\\\\\\\n\\\");\\n\" \"$function\"\n \tprintf \"  return gdbarch->%s;\\n\" \"$function\"\n@@ -2312,13 +2312,13 @@ gdbarch_printable_names (void)\n       const struct bfd_arch_info *ap;\n       ap = bfd_lookup_arch (rego->bfd_architecture, 0);\n       if (ap == NULL)\n-        internal_error (__FILE__, __LINE__,\n-                        _(\"gdbarch_architecture_names: multi-arch unknown\"));\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"gdbarch_architecture_names: multi-arch unknown\"));\n       do\n-        {\n-          append_name (&arches, &nr_arches, ap->printable_name);\n-          ap = ap->next;\n-        }\n+\t{\n+\t  append_name (&arches, &nr_arches, ap->printable_name);\n+\t  ap = ap->next;\n+\t}\n       while (ap != NULL);\n     }\n   append_name (&arches, &nr_arches, NULL);\n@@ -2328,7 +2328,7 @@ gdbarch_printable_names (void)\n \n void\n gdbarch_register (enum bfd_architecture bfd_architecture,\n-                  gdbarch_init_ftype *init,\n+\t\t  gdbarch_init_ftype *init,\n \t\t  gdbarch_dump_tdep_ftype *dump_tdep)\n {\n   struct gdbarch_registration **curr;\n@@ -2339,9 +2339,9 @@ gdbarch_register (enum bfd_architecture bfd_architecture,\n   if (bfd_arch_info == NULL)\n     {\n       internal_error (__FILE__, __LINE__,\n-                      _(\"gdbarch: Attempt to register \"\n+\t\t      _(\"gdbarch: Attempt to register \"\n \t\t\t\"unknown architecture (%d)\"),\n-                      bfd_architecture);\n+\t\t      bfd_architecture);\n     }\n   /* Check that we haven't seen this architecture before.  */\n   for (curr = &gdbarch_registry;\n@@ -2350,9 +2350,9 @@ gdbarch_register (enum bfd_architecture bfd_architecture,\n     {\n       if (bfd_architecture == (*curr)->bfd_architecture)\n \tinternal_error (__FILE__, __LINE__,\n-                        _(\"gdbarch: Duplicate registration \"\n+\t\t\t_(\"gdbarch: Duplicate registration \"\n \t\t\t  \"of architecture (%s)\"),\n-\t                bfd_arch_info->printable_name);\n+\t\t\tbfd_arch_info->printable_name);\n     }\n   /* log it */\n   if (gdbarch_debug)\n@@ -2380,7 +2380,7 @@ register_gdbarch_init (enum bfd_architecture bfd_architecture,\n \n struct gdbarch_list *\n gdbarch_list_lookup_by_info (struct gdbarch_list *arches,\n-                             const struct gdbarch_info *info)\n+\t\t\t     const struct gdbarch_info *info)\n {\n   for (; arches != NULL; arches = arches->next)\n     {\n@@ -2550,9 +2550,9 @@ _initialize_gdbarch ()\n Set architecture debugging.\"), _(\"\\\\\n Show architecture debugging.\"), _(\"\\\\\n When non-zero, architecture debugging is enabled.\"),\n-                            NULL,\n-                            show_gdbarch_debug,\n-                            &setdebuglist, &showdebuglist);\n+\t\t\t    NULL,\n+\t\t\t    show_gdbarch_debug,\n+\t\t\t    &setdebuglist, &showdebuglist);\n }\n EOF\n "
    },
    {
      "sha": "397163c3b758d94fb592cb943980d2df973e374e",
      "filename": "gdb/gdbcore.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbcore.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -106,13 +106,13 @@ extern void write_memory_with_notification (CORE_ADDR memaddr,\n \n /* Store VALUE at ADDR in the inferior as a LEN-byte unsigned integer.  */\n extern void write_memory_unsigned_integer (CORE_ADDR addr, int len,\n-                                           enum bfd_endian byte_order,\n+\t\t\t\t\t   enum bfd_endian byte_order,\n \t\t\t\t\t   ULONGEST value);\n \n /* Store VALUE at ADDR in the inferior as a LEN-byte unsigned integer.  */\n extern void write_memory_signed_integer (CORE_ADDR addr, int len,\n-                                         enum bfd_endian byte_order,\n-                                         LONGEST value);\n+\t\t\t\t\t enum bfd_endian byte_order,\n+\t\t\t\t\t LONGEST value);\n \f\n /* Hook for `exec_file_command' command to call.  */\n "
    },
    {
      "sha": "630727e2fb50777467228fbcae1d362216d4a291",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -243,14 +243,14 @@ class thread_info : public refcounted_object\n \n      a) The thread ID (Id).  This consists of the pair of:\n \n-        - the number of the thread's inferior and,\n+\t- the number of the thread's inferior and,\n \n-        - the thread's thread number in its inferior, aka, the\n-          per-inferior thread number.  This number is unique in the\n-          inferior but not unique between inferiors.\n+\t- the thread's thread number in its inferior, aka, the\n+\t  per-inferior thread number.  This number is unique in the\n+\t  inferior but not unique between inferiors.\n \n      b) The global ID (GId).  This is a a single integer unique\n-        between all inferiors.\n+\tbetween all inferiors.\n \n      E.g.:\n "
    },
    {
      "sha": "66dceac4a3dc0b178c706573838bd423d70b093a",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -405,7 +405,7 @@ lookup_pointer_type (struct type *type)\n \n struct type *\n make_reference_type (struct type *type, struct type **typeptr,\n-                      enum type_code refcode)\n+\t\t      enum type_code refcode)\n {\n   struct type *ntype;\t/* New type */\n   struct type **reftype;\n@@ -414,7 +414,7 @@ make_reference_type (struct type *type, struct type **typeptr,\n   gdb_assert (refcode == TYPE_CODE_REF || refcode == TYPE_CODE_RVALUE_REF);\n \n   ntype = (refcode == TYPE_CODE_REF ? TYPE_REFERENCE_TYPE (type)\n-           : TYPE_RVALUE_REFERENCE_TYPE (type));\n+\t   : TYPE_RVALUE_REFERENCE_TYPE (type));\n \n   if (ntype)\n     {\n@@ -444,7 +444,7 @@ make_reference_type (struct type *type, struct type **typeptr,\n \n   TYPE_TARGET_TYPE (ntype) = type;\n   reftype = (refcode == TYPE_CODE_REF ? &TYPE_REFERENCE_TYPE (type)\n-             : &TYPE_RVALUE_REFERENCE_TYPE (type));\n+\t     : &TYPE_RVALUE_REFERENCE_TYPE (type));\n \n   *reftype = ntype;\n \n@@ -590,7 +590,7 @@ address_space_name_to_type_instance_flags (struct gdbarch *gdbarch,\n   else if (!strcmp (space_identifier, \"data\"))\n     return TYPE_INSTANCE_FLAG_DATA_SPACE;\n   else if (gdbarch_address_class_name_to_type_flags_p (gdbarch)\n-           && gdbarch_address_class_name_to_type_flags (gdbarch,\n+\t   && gdbarch_address_class_name_to_type_flags (gdbarch,\n \t\t\t\t\t\t\tspace_identifier,\n \t\t\t\t\t\t\t&type_flags))\n     return type_flags;\n@@ -610,7 +610,7 @@ address_space_type_instance_flags_to_name (struct gdbarch *gdbarch,\n   else if (space_flag & TYPE_INSTANCE_FLAG_DATA_SPACE)\n     return \"data\";\n   else if ((space_flag & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL)\n-           && gdbarch_address_class_type_flags_to_name_p (gdbarch))\n+\t   && gdbarch_address_class_type_flags_to_name_p (gdbarch))\n     return gdbarch_address_class_type_flags_to_name (gdbarch, space_flag);\n   else\n     return NULL;\n@@ -1048,7 +1048,7 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n     {\n     case TYPE_CODE_RANGE:\n       /* This function currently only works for ranges with two defined,\n-         constant bounds.  */\n+\t constant bounds.  */\n       if (type->bounds ()->low.kind () != PROP_CONST\n \t  || type->bounds ()->high.kind () != PROP_CONST)\n \treturn -1;\n@@ -1106,8 +1106,8 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n     case TYPE_CODE_CHAR:\n       *lowp = 0;\n       /* This round-about calculation is to avoid shifting by\n-         TYPE_LENGTH (type) * TARGET_CHAR_BIT, which will not work\n-         if TYPE_LENGTH (type) == sizeof (LONGEST).  */\n+\t TYPE_LENGTH (type) * TARGET_CHAR_BIT, which will not work\n+\t if TYPE_LENGTH (type) == sizeof (LONGEST).  */\n       *highp = 1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1);\n       *highp = (*highp - 1) | *highp;\n       return 0;\n@@ -1172,13 +1172,13 @@ discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n       int i;\n \n       for (i = 0; i < type->num_fields (); i += 1)\n-        {\n-          if (val == TYPE_FIELD_ENUMVAL (type, i))\n+\t{\n+\t  if (val == TYPE_FIELD_ENUMVAL (type, i))\n \t    {\n \t      *pos = i;\n \t      return 1;\n \t    }\n-        }\n+\t}\n       /* Invalid enumeration value.  */\n       return 0;\n     }\n@@ -1305,11 +1305,11 @@ create_array_type_with_stride (struct type *result_type,\n   if (!update_static_array_size (result_type))\n     {\n       /* This type is dynamic and its length needs to be computed\n-         on demand.  In the meantime, avoid leaving the TYPE_LENGTH\n-         undefined by setting it to zero.  Although we are not expected\n-         to trust TYPE_LENGTH in this case, setting the size to zero\n-         allows us to avoid allocating objects of random sizes in case\n-         we accidently do.  */\n+\t on demand.  In the meantime, avoid leaving the TYPE_LENGTH\n+\t undefined by setting it to zero.  Although we are not expected\n+\t to trust TYPE_LENGTH in this case, setting the size to zero\n+\t allows us to avoid allocating objects of random sizes in case\n+\t we accidently do.  */\n       TYPE_LENGTH (result_type) = 0;\n     }\n \n@@ -1923,7 +1923,7 @@ get_vptr_fieldno (struct type *type, struct type **basetypep)\n       int i;\n \n       /* We must start at zero in case the first (and only) baseclass\n-         is virtual (and hence we cannot share the table pointer).  */\n+\t is virtual (and hence we cannot share the table pointer).  */\n       for (i = 0; i < TYPE_N_BASECLASSES (type); i++)\n \t{\n \t  struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n@@ -2214,7 +2214,7 @@ resolve_dynamic_array_or_string (struct type *type,\n     bit_stride = TYPE_FIELD_BITSIZE (type, 0);\n \n   return create_array_type_with_stride (type, elt_type, range_type, NULL,\n-                                        bit_stride);\n+\t\t\t\t\tbit_stride);\n }\n \n /* Resolve dynamic bounds of members of the union TYPE to static\n@@ -2655,7 +2655,7 @@ type::dyn_prop (dynamic_prop_node_kind prop_kind) const\n   while (node != NULL)\n     {\n       if (node->prop_kind == prop_kind)\n-        return &node->prop;\n+\treturn &node->prop;\n       node = node->next;\n     }\n   return NULL;\n@@ -2851,7 +2851,7 @@ check_typedef (struct type *type)\n     {\n       const char *name = type->name ();\n       /* FIXME: shouldn't we look in STRUCT_DOMAIN and/or VAR_DOMAIN\n-         as appropriate?  */\n+\t as appropriate?  */\n       struct symbol *sym;\n \n       if (name == NULL)\n@@ -2861,16 +2861,16 @@ check_typedef (struct type *type)\n \t}\n       sym = lookup_symbol (name, 0, STRUCT_DOMAIN, 0).symbol;\n       if (sym)\n-        {\n-          /* Same as above for opaque types, we can replace the stub\n-             with the complete type only if they are in the same\n-             objfile.  */\n+\t{\n+\t  /* Same as above for opaque types, we can replace the stub\n+\t     with the complete type only if they are in the same\n+\t     objfile.  */\n \t  if (TYPE_OBJFILE (SYMBOL_TYPE (sym)) == TYPE_OBJFILE (type))\n \t    type = make_qualified_type (SYMBOL_TYPE (sym),\n \t\t\t\t\ttype->instance_flags (), type);\n \t  else\n \t    type = SYMBOL_TYPE (sym);\n-        }\n+\t}\n     }\n \n   if (type->target_is_stub ())\n@@ -3010,7 +3010,7 @@ check_stub_method (struct type *type, int method_id, int signature_id)\n \t  if (depth <= 0 && (*p == ',' || *p == ')'))\n \t    {\n \t      /* Avoid parsing of ellipsis, they will be handled below.\n-\t         Also avoid ``void'' as above.  */\n+\t\t Also avoid ``void'' as above.  */\n \t      if (strncmp (argtypetext, \"...\", p - argtypetext) != 0\n \t\t  && strncmp (argtypetext, \"void\", p - argtypetext) != 0)\n \t\t{\n@@ -3115,14 +3115,14 @@ set_type_code (struct type *type, enum type_code code)\n       case TYPE_CODE_STRUCT:\n       case TYPE_CODE_UNION:\n       case TYPE_CODE_NAMESPACE:\n-        INIT_CPLUS_SPECIFIC (type);\n-        break;\n+\tINIT_CPLUS_SPECIFIC (type);\n+\tbreak;\n       case TYPE_CODE_FLT:\n-        TYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_FLOATFORMAT;\n-        break;\n+\tTYPE_SPECIFIC_FIELD (type) = TYPE_SPECIFIC_FLOATFORMAT;\n+\tbreak;\n       case TYPE_CODE_FUNC:\n \tINIT_FUNC_SPECIFIC (type);\n-        break;\n+\tbreak;\n     }\n }\n \n@@ -3569,7 +3569,7 @@ int\n class_or_union_p (const struct type *t)\n {\n   return (t->code () == TYPE_CODE_STRUCT\n-          || t->code () == TYPE_CODE_UNION);\n+\t  || t->code () == TYPE_CODE_UNION);\n }\n \n /* A helper function which returns true if types A and B represent the\n@@ -3725,7 +3725,7 @@ type_byte_order (const struct type *type)\n   if (type->endianity_is_not_default ())\n     {\n       if (byteorder == BFD_ENDIAN_BIG)\n-        return BFD_ENDIAN_LITTLE;\n+\treturn BFD_ENDIAN_LITTLE;\n       else\n \t{\n \t  gdb_assert (byteorder == BFD_ENDIAN_LITTLE);\n@@ -3927,7 +3927,7 @@ types_equal (struct type *a, struct type *b)\n   if (a->code () == TYPE_CODE_PTR\n       || a->code () == TYPE_CODE_REF)\n     return types_equal (TYPE_TARGET_TYPE (a),\n-                        TYPE_TARGET_TYPE (b));\n+\t\t\tTYPE_TARGET_TYPE (b));\n \n   /* Well, damnit, if the names are exactly the same, I'll say they\n      are exactly the same.  This happens when we generate method\n@@ -4626,10 +4626,10 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n \n   if (TYPE_IS_REFERENCE (arg))\n     return (sum_ranks (rank_one_type (parm, TYPE_TARGET_TYPE (arg), NULL),\n-                       REFERENCE_SEE_THROUGH_BADNESS));\n+\t\t       REFERENCE_SEE_THROUGH_BADNESS));\n   if (TYPE_IS_REFERENCE (parm))\n     return (sum_ranks (rank_one_type (TYPE_TARGET_TYPE (parm), arg, NULL),\n-                       REFERENCE_SEE_THROUGH_BADNESS));\n+\t\t       REFERENCE_SEE_THROUGH_BADNESS));\n   if (overload_debug)\n   /* Debugging only.  */\n     fprintf_filtered (gdb_stderr,\n@@ -5193,7 +5193,7 @@ recursive_dump_type (struct type *type, int spaces)\n \n       case TYPE_SPECIFIC_FUNC:\n \tprintfi_filtered (spaces, \"calling_convention %d\\n\",\n-                          TYPE_CALLING_CONVENTION (type));\n+\t\t\t  TYPE_CALLING_CONVENTION (type));\n \t/* tail_call_list is not printed.  */\n \tbreak;\n \n@@ -5385,7 +5385,7 @@ copy_type_recursive (struct objfile *objfile,\n   if (type->code () == TYPE_CODE_RANGE)\n     {\n       range_bounds *bounds\n-        = ((struct range_bounds *) TYPE_ALLOC\n+\t= ((struct range_bounds *) TYPE_ALLOC\n \t   (new_type, sizeof (struct range_bounds)));\n \n       *bounds = *type->bounds ();"
    },
    {
      "sha": "4d574e229a953a51f105fddfa181798b08687f07",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -310,7 +310,7 @@ DEF_ENUM_FLAGS_TYPE (enum type_instance_flag_value, type_instance_flags);\n    classes.  */\n \n #define TYPE_ADDRESS_CLASS_1(t) (((t)->instance_flags ()) \\\n-                                 & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)\n+\t\t\t\t & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)\n #define TYPE_ADDRESS_CLASS_2(t) (((t)->instance_flags ()) \\\n \t\t\t\t & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2)\n #define TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL \\\n@@ -2141,9 +2141,9 @@ extern const struct floatformat *floatformats_bfloat16[BFD_ENDIAN_UNKNOWN];\n \n #define TYPE_ALLOC(t,size)                                              \\\n   (obstack_alloc ((TYPE_OBJFILE_OWNED (t)                               \\\n-                   ? &TYPE_OBJFILE (t)->objfile_obstack                 \\\n-                   : gdbarch_obstack (TYPE_OWNER (t).gdbarch)),         \\\n-                  size))\n+\t\t   ? &TYPE_OBJFILE (t)->objfile_obstack                 \\\n+\t\t   : gdbarch_obstack (TYPE_OWNER (t).gdbarch)),         \\\n+\t\t  size))\n \n \n /* See comment on TYPE_ALLOC.  */\n@@ -2245,7 +2245,7 @@ extern struct type *lookup_rvalue_reference_type (struct type *);\n \n \n extern struct type *make_reference_type (struct type *, struct type **,\n-                                         enum type_code);\n+\t\t\t\t\t enum type_code);\n \n extern struct type *make_cv_type (int, int, struct type *, struct type **);\n "
    },
    {
      "sha": "73355d4718436a685f7a4e2a7f4491215c44a3d3",
      "filename": "gdb/glibc-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/glibc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/glibc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/glibc-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -64,7 +64,7 @@ glibc_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc)\n       \n       /* This is the name used in older versions.  */\n       if (! fixup.minsym)\n-        fixup = lookup_minimal_symbol (\"fixup\", NULL, resolver.objfile);\n+\tfixup = lookup_minimal_symbol (\"fixup\", NULL, resolver.objfile);\n \n       if (fixup.minsym && BMSYMBOL_VALUE_ADDRESS (fixup) == pc)\n \treturn frame_unwind_caller_pc (get_current_frame ());"
    },
    {
      "sha": "1693ce0c43db0fe9b2af7398c02230d8dbec96ff",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -506,7 +506,7 @@ gnu_nat_target::proc_trace (struct proc *proc, int set)\n   if (set)\n     {\n       /* XXX We don't get the exception unless the thread has its own\n-         exception port????  */\n+\t exception port????  */\n       if (proc->exc_port == MACH_PORT_NULL)\n \tproc_steal_exc_port (proc, proc->inf->event_port);\n       THREAD_STATE_SET_TRACED (state);\n@@ -578,7 +578,7 @@ gnu_nat_target::make_proc (struct inf *inf, mach_port_t port, int tid)\n \tproc_steal_exc_port (proc, inf->event_port);\n       else\n \t/* Just clear thread exception ports -- they default to the\n-           task one.  */\n+\t   task one.  */\n \tproc_steal_exc_port (proc, MACH_PORT_NULL);\n     }\n \n@@ -825,9 +825,9 @@ gnu_nat_target::inf_validate_task_sc (struct inf *inf)\n   if (inf->task->cur_sc < pi->taskinfo.suspend_count && suspend_count == -1)\n     {\n       /* The proc server might have suspended the task while stopping\n-         it.  This happens when the task is handling a traced signal.\n-         Refetch the suspend count.  The proc server should be\n-         finished stopping the task by now.  */\n+\t it.  This happens when the task is handling a traced signal.\n+\t Refetch the suspend count.  The proc server should be\n+\t finished stopping the task by now.  */\n       suspend_count = pi->taskinfo.suspend_count;\n       goto retry;\n     }\n@@ -929,7 +929,7 @@ gnu_nat_target::inf_update_suspends (struct inf *inf)\n       inf->running = thread_running && task_running;\n \n       /* Once any thread has executed some code, we can't depend on the\n-         threads list any more.  */\n+\t threads list any more.  */\n       if (inf->running)\n \tinf->threads_up_to_date = 0;\n \n@@ -2116,7 +2116,7 @@ gnu_nat_target::create_inferior (const char *exec_file,\n     push_target (this);\n \n   pid = fork_inferior (exec_file, allargs, env, gnu_ptrace_me,\n-                       NULL, NULL, NULL, NULL);\n+\t\t       NULL, NULL, NULL, NULL);\n \n   /* We have something that executes now.  We'll be running through\n      the shell at this point (if startup-with-shell is true), but the"
    },
    {
      "sha": "83d9ba2c7b6a7c5b881136d68349d8f6d783ed13",
      "filename": "gdb/gnu-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -109,7 +109,7 @@ extern bool gnu_debug_flag;\n \n #define debug(msg, args...) \\\n  do { if (gnu_debug_flag) \\\n-        fprintf_unfiltered (gdb_stdlog, \"%s:%d: \" msg \"\\r\\n\", \\\n+\tfprintf_unfiltered (gdb_stdlog, \"%s:%d: \" msg \"\\r\\n\", \\\n \t\t\t    __FILE__ , __LINE__ , ##args); } while (0)\n \n /* A prototype generic GNU/Hurd target.  The client can override it"
    },
    {
      "sha": "a76b38eec76a3f52855dc9f64bb7c7c7f1a97015",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -136,13 +136,13 @@ gnuv2_virtual_fn_field (struct value **arg1p, struct fn_field * f, int j,\n       && TYPE_TARGET_TYPE (value_type (vtbl))->code () == TYPE_CODE_ARRAY)\n     {\n       /* Handle the case where the vtbl field points to an\n-         array of structures.  */\n+\t array of structures.  */\n       vtbl = value_ind (vtbl);\n \n       /* Index into the virtual function table.  This is hard-coded because\n-         looking up a field is not cheap, and it may be important to save\n-         time, e.g. if the user has set a conditional breakpoint calling\n-         a virtual function.  */\n+\t looking up a field is not cheap, and it may be important to save\n+\t time, e.g. if the user has set a conditional breakpoint calling\n+\t a virtual function.  */\n       entry = value_subscript (vtbl, vi);\n     }\n   else\n@@ -230,7 +230,7 @@ gnuv2_value_rtti_type (struct value *v, int *full, LONGEST *top, int *using_enc)\n     {\n       v = value_cast (btype, v);\n       if (using_enc)\n-        *using_enc=1;\n+\t*using_enc=1;\n     }\n   /* We can't use value_ind here, because it would want to use RTTI, and\n      we'd waste a bunch of time figuring out we already know the type.\n@@ -262,26 +262,26 @@ gnuv2_value_rtti_type (struct value *v, int *full, LONGEST *top, int *using_enc)\n   if (TYPE_N_BASECLASSES(rtti_type) > 1 &&  full && (*full) != 1)\n     {\n       if (top)\n-        *top = TYPE_BASECLASS_BITPOS (rtti_type,\n+\t*top = TYPE_BASECLASS_BITPOS (rtti_type,\n \t\t\t\t      TYPE_VPTR_FIELDNO(rtti_type)) / 8;\n       if (top && ((*top) >0))\n-        {\n-          if (TYPE_LENGTH(rtti_type) > TYPE_LENGTH(known_type))\n-            {\n-              if (full)\n-                *full=0;\n-            }\n-          else\n-            {\n-              if (full)\n-                *full=1;\n-            }\n-        }\n+\t{\n+\t  if (TYPE_LENGTH(rtti_type) > TYPE_LENGTH(known_type))\n+\t    {\n+\t      if (full)\n+\t\t*full=0;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (full)\n+\t\t*full=1;\n+\t    }\n+\t}\n     }\n   else\n     {\n       if (full)\n-        *full=1;\n+\t*full=1;\n     }\n \n   return rtti_type;\n@@ -352,7 +352,7 @@ gnuv2_baseclass_offset (struct type *type, int index,\n       int n_baseclasses = TYPE_N_BASECLASSES (type);\n \n       /* First look for the virtual baseclass pointer\n-         in the fields.  */\n+\t in the fields.  */\n       for (i = n_baseclasses; i < len; i++)\n \t{\n \t  if (vb_match (type, i, basetype))"
    },
    {
      "sha": "356f21ea868786502add4a4dbe5b3cbb0d0009c4",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -60,25 +60,25 @@ gnuv3_is_operator_name (const char *name)\n    struct gdb_gnu_v3_abi_vtable {\n \n      / * An array of virtual call and virtual base offsets.  The real\n-         length of this array depends on the class hierarchy; we use\n-         negative subscripts to access the elements.  Yucky, but\n-         better than the alternatives.  * /\n+\t length of this array depends on the class hierarchy; we use\n+\t negative subscripts to access the elements.  Yucky, but\n+\t better than the alternatives.  * /\n      ptrdiff_t vcall_and_vbase_offsets[0];\n \n      / * The offset from a virtual pointer referring to this table\n-         to the top of the complete object.  * /\n+\t to the top of the complete object.  * /\n      ptrdiff_t offset_to_top;\n \n      / * The type_info pointer for this class.  This is really a\n-         std::type_info *, but GDB doesn't really look at the\n-         type_info object itself, so we don't bother to get the type\n-         exactly right.  * /\n+\t std::type_info *, but GDB doesn't really look at the\n+\t type_info object itself, so we don't bother to get the type\n+\t exactly right.  * /\n      void *type_info;\n \n      / * Virtual table pointers in objects point here.  * /\n \n      / * Virtual function pointers.  Like the vcall/vbase array, the\n-         real length of this table depends on the class hierarchy.  * /\n+\t real length of this table depends on the class hierarchy.  * /\n      void (*virtual_functions[0]) ();\n \n    };\n@@ -195,7 +195,7 @@ vtable_address_point_offset (struct gdbarch *gdbarch)\n     = (struct type *) gdbarch_data (gdbarch, vtable_type_gdbarch_data);\n \n   return (TYPE_FIELD_BITPOS (vtable_type, vtable_field_virtual_functions)\n-          / TARGET_CHAR_BIT);\n+\t  / TARGET_CHAR_BIT);\n }\n \n \n@@ -290,7 +290,7 @@ gnuv3_get_vtable (struct gdbarch *gdbarch,\n \n static struct type *\n gnuv3_rtti_type (struct value *value,\n-                 int *full_p, LONGEST *top_p, int *using_enc_p)\n+\t\t int *full_p, LONGEST *top_p, int *using_enc_p)\n {\n   struct gdbarch *gdbarch;\n   struct type *values_type = check_typedef (value_type (value));\n@@ -321,7 +321,7 @@ gnuv3_rtti_type (struct value *value,\n   /* Find the linker symbol for this vtable.  */\n   vtable_symbol\n     = lookup_minimal_symbol_by_pc (value_address (vtable)\n-                                   + value_embedded_offset (vtable)).minsym;\n+\t\t\t\t   + value_embedded_offset (vtable)).minsym;\n   if (! vtable_symbol)\n     return NULL;\n   \n@@ -367,8 +367,8 @@ gnuv3_rtti_type (struct value *value,\n \n   if (full_p)\n     *full_p = (- offset_to_top == value_embedded_offset (value)\n-               && (TYPE_LENGTH (value_enclosing_type (value))\n-                   >= TYPE_LENGTH (run_time_type)));\n+\t       && (TYPE_LENGTH (value_enclosing_type (value))\n+\t\t   >= TYPE_LENGTH (run_time_type)));\n   if (top_p)\n     *top_p = - offset_to_top;\n   return run_time_type;\n@@ -390,7 +390,7 @@ gnuv3_get_virtual_fn (struct gdbarch *gdbarch, struct value *container,\n \n   /* Fetch the appropriate function pointer from the vtable.  */\n   vfn = value_subscript (value_field (vtable, vtable_field_virtual_functions),\n-                         vtable_index);\n+\t\t\t vtable_index);\n \n   /* If this architecture uses function descriptors directly in the vtable,\n      then the address of the vtable entry is actually a \"function pointer\"\n@@ -411,7 +411,7 @@ gnuv3_get_virtual_fn (struct gdbarch *gdbarch, struct value *container,\n \n static struct value *\n gnuv3_virtual_fn_field (struct value **value_p,\n-                        struct fn_field *f, int j,\n+\t\t\tstruct fn_field *f, int j,\n \t\t\tstruct type *vfn_base, int offset)\n {\n   struct type *values_type = check_typedef (value_type (*value_p));"
    },
    {
      "sha": "a9118749097579f678a5cfd7a3e85f90a9a47122",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -682,15 +682,15 @@ parse_number (struct parser_state *par_state,\n \t}\n       /* Default type for floating-point literals is float64.  */\n       else\n-        {\n+\t{\n \t  putithere->typed_val_float.type\n \t    = builtin_go_types->builtin_float64;\n-        }\n+\t}\n \n       if (!parse_float (p, len,\n \t\t\tputithere->typed_val_float.type,\n \t\t\tputithere->typed_val_float.val))\n-        return ERROR;\n+\treturn ERROR;\n       return FLOAT;\n     }\n \n@@ -806,7 +806,7 @@ parse_number (struct parser_state *par_state,\n       && (un >> (gdbarch_int_bit (par_state->gdbarch ()) - 2)) == 0)\n     {\n       high_bit\n-        = ((ULONGEST)1) << (gdbarch_int_bit (par_state->gdbarch ()) - 1);\n+\t= ((ULONGEST)1) << (gdbarch_int_bit (par_state->gdbarch ()) - 1);\n \n       /* A large decimal (not hex or octal) constant (between INT_MAX\n \t and UINT_MAX) is a long or unsigned long, according to ANSI,\n@@ -1053,7 +1053,7 @@ lex_one_token (struct parser_state *par_state)\n       else if (saw_structop)\n \treturn COMPLETE;\n       else\n-        return 0;\n+\treturn 0;\n \n     case ' ':\n     case '\\t':\n@@ -1077,7 +1077,7 @@ lex_one_token (struct parser_state *par_state)\n \n     case ',':\n       if (pstate->comma_terminates\n-          && paren_depth == 0)\n+\t  && paren_depth == 0)\n \treturn 0;\n       par_state->lexptr++;\n       return c;\n@@ -1139,7 +1139,7 @@ lex_one_token (struct parser_state *par_state)\n \t  }\n \ttoktype = parse_number (par_state, tokstart, p - tokstart,\n \t\t\t\tgot_dot|got_e, &yylval);\n-        if (toktype == ERROR)\n+\tif (toktype == ERROR)\n \t  {\n \t    char *err_copy = (char *) alloca (p - tokstart + 1);\n "
    },
    {
      "sha": "24d0c00a740e681ba434777db02d0fd75da3e6aa",
      "filename": "gdb/go32-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/go32-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/go32-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go32-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1106,8 +1106,8 @@ go32_sysinfo (const char *arg, int from_tty)\n       /* CPUID with EAX = 0 returns the Vendor ID.  */\n #if 0\n       /* Ideally we would use x86_cpuid(), but it needs someone to run\n-         native tests first to make sure things actually work.  They should.\n-         http://sourceware.org/ml/gdb-patches/2013-05/msg00164.html  */\n+\t native tests first to make sure things actually work.  They should.\n+\t http://sourceware.org/ml/gdb-patches/2013-05/msg00164.html  */\n       unsigned int eax, ebx, ecx, edx;\n \n       if (x86_cpuid (0, &eax, &ebx, &ecx, &edx))\n@@ -1259,8 +1259,8 @@ go32_sysinfo (const char *arg, int from_tty)\n \t    }\n \t}\n       xsnprintf (cpu_string, sizeof (cpu_string), \"%s%s Model %d Stepping %d\",\n-\t         intel_p ? \"Pentium\" : (amd_p ? \"AMD\" : (hygon_p ? \"Hygon\" : \"ix86\")),\n-\t         cpu_brand, cpu_model, cpuid_eax & 0xf);\n+\t\t intel_p ? \"Pentium\" : (amd_p ? \"AMD\" : (hygon_p ? \"Hygon\" : \"ix86\")),\n+\t\t cpu_brand, cpu_model, cpuid_eax & 0xf);\n       printfi_filtered (31, \"%s\\n\", cpu_string);\n       if (((cpuid_edx & (6 | (0x0d << 23))) != 0)\n \t  || ((cpuid_edx & 1) == 0)"
    },
    {
      "sha": "bb2bc1191879baee72129f4606a4f1ea283980dc",
      "filename": "gdb/guile/guile-internal.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/guile-internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/guile-internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/guile-internal.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -684,7 +684,7 @@ unpack (const gdb_exception &exc)\n     if (exception.reason < 0)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tgdbscm_throw_gdb_exception (exception);\t\t\\\n-        /*NOTREACHED */\t\t\t\t\t\\\n+\t/*NOTREACHED */\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\\\n   } while (0)\n "
    },
    {
      "sha": "f4db41144035dc4feb11a9f5358d9f60d12939bb",
      "filename": "gdb/guile/scm-cmd.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-cmd.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -635,9 +635,9 @@ gdbscm_canonicalize_command_name (const char *name, int want_trailing_space)\n      One of the COMPLETE_* constants defined in the gdb module.\n      A procedure of three arguments: (lambda (self text word) ...).\n        Its result is one of:\n-         A list of strings.\n-         A <gdb:iterator> object that returns the set of possible completions,\n-         ending with #f.\n+\t A list of strings.\n+\t A <gdb:iterator> object that returns the set of possible completions,\n+\t ending with #f.\n \t TODO(dje): Once PR 16699 is fixed, add support for returning\n \t a COMPLETE_* constant.\n    If not specified, then completion is not supported for this command."
    },
    {
      "sha": "211c663823249f4d27af52538391dee88428f1ab",
      "filename": "gdb/guile/scm-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-frame.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1132,7 +1132,7 @@ Return the frame's symtab-and-line <gdb:sal> object.\" },\n Return the value of the symbol in the frame.\\n\\\n \\n\\\n   Arguments: <gdb:frame> <gdb:symbol>\\n\\\n-         Or: <gdb:frame> string [#:block <gdb:block>]\" },\n+\t Or: <gdb:frame> string [#:block <gdb:block>]\" },\n \n   { \"frame-read-register\", 2, 0, 0,\n     as_a_scm_t_subr (gdbscm_frame_read_register),"
    },
    {
      "sha": "36ab5c01d3d5a5307ff8ce8c4cef236aa2fae108",
      "filename": "gdb/guile/scm-iterator.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-iterator.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-iterator.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-iterator.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -35,8 +35,8 @@\n      (let ((next! (lambda (iter)\n \t\t    (let ((l (iterator-progress iter)))\n \t\t      (if (eq? l '())\n-\t\t          end-marker\n-\t\t          (begin\n+\t\t\t  end-marker\n+\t\t\t  (begin\n \t\t\t    (set-iterator-progress! iter (cdr l))\n \t\t\t    (car l)))))))\n        (make-iterator l l next!)))"
    },
    {
      "sha": "1aacab9f7e7a1eb7fe9840d836626757d156505b",
      "filename": "gdb/guile/scm-math.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-math.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-math.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-math.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -439,7 +439,7 @@ vlscm_rich_compare (int op, SCM x, SCM y, const char *func_name)\n       int result;\n       switch (op)\n \t{\n-        case BINOP_LESS:\n+\tcase BINOP_LESS:\n \t  result = value_less (v1, v2);\n \t  break;\n \tcase BINOP_LEQ:\n@@ -451,7 +451,7 @@ vlscm_rich_compare (int op, SCM x, SCM y, const char *func_name)\n \t  break;\n \tcase BINOP_NOTEQUAL:\n \t  gdb_assert_not_reached (\"not-equal not implemented\");\n-        case BINOP_GTR:\n+\tcase BINOP_GTR:\n \t  result = value_less (v2, v1);\n \t  break;\n \tcase BINOP_GEQ:"
    },
    {
      "sha": "66efdf4465bd7b07d6a053832a9dbe6192ff5e8b",
      "filename": "gdb/guile/scm-ports.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-ports.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-ports.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-ports.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -269,7 +269,7 @@ ioscm_input_waiting (SCM port)\n       {\n \t/* Guile doesn't export SIGINT hooks like Python does.\n \t   For now pass EINTR to scm_syserror, that's what fports.c does.  */\n-        scm_syserror (FUNC_NAME);\n+\tscm_syserror (FUNC_NAME);\n       }\n     return num_found > 0 && FD_ISSET (fdes, &input_fds);\n   }"
    },
    {
      "sha": "df09dae434e0c0f97604d01ae5017f6e14d70e26",
      "filename": "gdb/guile/scm-pretty-print.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-pretty-print.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-pretty-print.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-pretty-print.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -824,10 +824,10 @@ ppscm_print_children (SCM printer, enum display_hint hint,\n \t 3. Other.  Always print a \",\".  */\n       if (i == 0)\n \t{\n-         if (printed_nothing)\n-           fputs_filtered (\"{\", stream);\n-         else\n-           fputs_filtered (\" = {\", stream);\n+\t if (printed_nothing)\n+\t   fputs_filtered (\"{\", stream);\n+\t else\n+\t   fputs_filtered (\" = {\", stream);\n        }\n \n       else if (! is_map || i % 2 == 0)"
    },
    {
      "sha": "5ba1f2cb00326ca1a5d52562096b1f1a1a5c9e64",
      "filename": "gdb/guile/scm-value.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/guile/scm-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-value.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -471,17 +471,17 @@ gdbscm_value_referenced_value (SCM self)\n       struct value *res_val;\n \n       switch (check_typedef (value_type (value))->code ())\n-        {\n-        case TYPE_CODE_PTR:\n-          res_val = value_ind (value);\n-          break;\n-        case TYPE_CODE_REF:\n-          res_val = coerce_ref (value);\n-          break;\n-        default:\n-          error (_(\"Trying to get the referenced value from a value which is\"\n+\t{\n+\tcase TYPE_CODE_PTR:\n+\t  res_val = value_ind (value);\n+\t  break;\n+\tcase TYPE_CODE_REF:\n+\t  res_val = coerce_ref (value);\n+\t  break;\n+\tdefault:\n+\t  error (_(\"Trying to get the referenced value from a value which is\"\n \t\t   \" neither a pointer nor a reference\"));\n-        }\n+\t}\n \n       return vlscm_scm_from_value (res_val);\n     });\n@@ -1404,8 +1404,8 @@ characters to be replaced with \\\"?\\\".  The default is \\\"error\\\".\\n\\\n If LENGTH is provided, only fetch string to the length provided.\\n\\\n \\n\\\n   Arguments: <gdb:value>\\n\\\n-             [#:encoding encoding] [#:errors \\\"error\\\"|\\\"substitute\\\"]\\n\\\n-             [#:length length]\" },\n+\t     [#:encoding encoding] [#:errors \\\"error\\\"|\\\"substitute\\\"]\\n\\\n+\t     [#:length length]\" },\n \n   { \"value->lazy-string\", 1, 0, 1,\n     as_a_scm_t_subr (gdbscm_value_to_lazy_string),"
    },
    {
      "sha": "9cf7477342936a65ba968c1e07fdc435a8277724",
      "filename": "gdb/h8300-tdep.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/h8300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/h8300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/h8300-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -294,7 +294,7 @@ h8300_analyze_prologue (struct gdbarch *gdbarch,\n       cache->saved_regs[E_FP_REGNUM] = 0;\n       pc += 4;\n       if (pc >= current_pc)\n-        return current_pc;\n+\treturn current_pc;\n       op = read_memory_unsigned_integer (pc, 2, byte_order);\n       if (IS_MOV_SP_FP (op))\n \t{\n@@ -332,7 +332,7 @@ h8300_analyze_prologue (struct gdbarch *gdbarch,\n \t  pc += 2;\n \t}\n       else if (IS_MOV_IMM_Rn (op))\n-        {\n+\t{\n \t  int offset = read_memory_integer (pc + 2, 2, byte_order);\n \t  regno = op & 0x000f;\n \t  op = read_memory_unsigned_integer (pc + 4, 2, byte_order);\n@@ -376,7 +376,7 @@ h8300_analyze_prologue (struct gdbarch *gdbarch,\n \t  if (IS_PUSH (op1))\n \t    {\n \t      /* Since the prefix is 0x01x0, this is not a simple pushm but a\n-\t         stm.l reglist,@-sp */\n+\t\t stm.l reglist,@-sp */\n \t      i = ((op & 0x0030) >> 4) + 1;\n \t      regno = op1 & 0x000f;\n \t      for (; i > 0; regno++, --i)\n@@ -397,7 +397,7 @@ h8300_analyze_prologue (struct gdbarch *gdbarch,\n      This could also be an initializing store from non-prologue code,\n      but I don't think there's any harm in skipping that.  */\n   while ((spill_size = h8300_is_argument_spill (gdbarch, pc)) > 0\n-         && pc + spill_size <= current_pc)\n+\t && pc + spill_size <= current_pc)\n     pc += spill_size;\n \n   return pc;\n@@ -438,12 +438,12 @@ h8300_frame_cache (struct frame_info *this_frame, void **this_cache)\n   if (!cache->uses_fp)\n     {\n       /* We didn't find a valid frame, which means that CACHE->base\n-         currently holds the frame pointer for our calling frame.  If\n-         we're at the start of a function, or somewhere half-way its\n-         prologue, the function's frame probably hasn't been fully\n-         setup yet.  Try to reconstruct the base address for the stack\n-         frame by looking at the stack pointer.  For truly \"frameless\"\n-         functions this might work too.  */\n+\t currently holds the frame pointer for our calling frame.  If\n+\t we're at the start of a function, or somewhere half-way its\n+\t prologue, the function's frame probably hasn't been fully\n+\t setup yet.  Try to reconstruct the base address for the stack\n+\t frame by looking at the stack pointer.  For truly \"frameless\"\n+\t functions this might work too.  */\n \n       cache->base = get_frame_register_unsigned (this_frame, E_SP_REGNUM)\n \t\t    + cache->sp_offset;\n@@ -495,7 +495,7 @@ h8300_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n   if (regnum < gdbarch_num_regs (gdbarch)\n       && cache->saved_regs[regnum] != -1)\n     return frame_unwind_got_memory (this_frame, regnum,\n-                                    cache->saved_regs[regnum]);\n+\t\t\t\t    cache->saved_regs[regnum]);\n \n   return frame_unwind_got_register (this_frame, regnum, regnum);\n }\n@@ -536,8 +536,8 @@ h8300_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n       /* Found a function.  */\n       sal = find_pc_line (func_addr, 0);\n       if (sal.end && sal.end < func_end)\n-        /* Found a line number, use it as end of prologue.  */\n-        return sal.end;\n+\t/* Found a line number, use it as end of prologue.  */\n+\treturn sal.end;\n \n       /* No useable line symbol.  Use prologue parsing method.  */\n       h8300_init_frame_cache (gdbarch, &cache);\n@@ -670,15 +670,15 @@ h8300_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      stack_offset += padded_len;\n \n \t      /* That's right --- even though we passed the argument\n-\t         on the stack, we consume the registers anyway!  Love\n-\t         me, love my dog.  */\n+\t\t on the stack, we consume the registers anyway!  Love\n+\t\t me, love my dog.  */\n \t      reg += padded_len / wordsize;\n \t    }\n \t  else\n \t    {\n \t      /* Heavens to Betsy --- it's really going in registers!\n-\t         Note that on the h8/300s, there are gaps between the\n-\t         registers in the register file.  */\n+\t\t Note that on the h8/300s, there are gaps between the\n+\t\t registers in the register file.  */\n \t      int offset;\n \n \t      for (offset = 0; offset < padded_len; offset += wordsize)"
    },
    {
      "sha": "e54be8625c529c5cf6849cfcdc9f430c4e75ad30",
      "filename": "gdb/hppa-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -281,7 +281,7 @@ hppa_linux_nat_target::fetch_registers (struct regcache *regcache, int regno)\n       for (regno = 0;\n \t   regno < gdbarch_num_regs (regcache->arch ());\n \t   regno++)\n-        fetch_register (regcache, regno);\n+\tfetch_register (regcache, regno);\n     }\n   else \n     {"
    },
    {
      "sha": "080379992aeb8c0ee6274e331f7f09da240c6b0a",
      "filename": "gdb/hppa-linux-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -88,8 +88,8 @@ static struct insn_pattern hppa_sigtramp[] = {\n    matched.  */\n static int\n insns_match_pattern (struct gdbarch *gdbarch, CORE_ADDR pc,\n-                     struct insn_pattern *pattern,\n-                     unsigned int *insn)\n+\t\t     struct insn_pattern *pattern,\n+\t\t     unsigned int *insn)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   int i;\n@@ -102,9 +102,9 @@ insns_match_pattern (struct gdbarch *gdbarch, CORE_ADDR pc,\n       target_read_memory (npc, buf, 4);\n       insn[i] = extract_unsigned_integer (buf, 4, byte_order);\n       if ((insn[i] & pattern[i].mask) == pattern[i].data)\n-        npc += 4;\n+\tnpc += 4;\n       else\n-        return 0;\n+\treturn 0;\n     }\n   return 1;\n }\n@@ -158,7 +158,7 @@ hppa_linux_sigtramp_find_sigcontext (struct gdbarch *gdbarch, CORE_ADDR pc)\n       if (insns_match_pattern (gdbarch, sp + pcoffs[attempt],\n \t\t\t       hppa_sigtramp, dummy))\n \t{\n-          offs = sfoffs[attempt];\n+\t  offs = sfoffs[attempt];\n \t  break;\n \t}\n     }\n@@ -175,7 +175,7 @@ hppa_linux_sigtramp_find_sigcontext (struct gdbarch *gdbarch, CORE_ADDR pc)\n \t}\n       else\n       {\n-        return 0;\n+\treturn 0;\n       }\n     }\n \n@@ -523,7 +523,7 @@ hppa_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n }\n \n void _initialize_hppa_linux_tdep ();"
    },
    {
      "sha": "caeeb47ad51a7e7892cc22b80cec9c473a9ab10f",
      "filename": "gdb/hppa-netbsd-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-netbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-netbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-netbsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -42,8 +42,8 @@ static int\n hppanbsd_gregset_supplies_p (int regnum)\n {\n   return ((regnum >= HPPA_R0_REGNUM && regnum <= HPPA_R31_REGNUM) ||\n-          (regnum >= HPPA_SAR_REGNUM && regnum <= HPPA_PCSQ_TAIL_REGNUM) ||\n-          regnum == HPPA_IPSW_REGNUM ||\n+\t  (regnum >= HPPA_SAR_REGNUM && regnum <= HPPA_PCSQ_TAIL_REGNUM) ||\n+\t  regnum == HPPA_IPSW_REGNUM ||\n \t  (regnum >= HPPA_SR4_REGNUM && regnum <= HPPA_SR4_REGNUM + 5));\n }\n \n@@ -208,12 +208,12 @@ hppa_nbsd_nat_target::store_registers (struct regcache *regcache, int regnum)\n       struct reg regs;\n \n       if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, lwp) == -1)\n-        perror_with_name (_(\"Couldn't get registers\"));\n+\tperror_with_name (_(\"Couldn't get registers\"));\n \n       hppanbsd_collect_gregset (regcache, &regs, regnum);\n \n       if (ptrace (PT_SETREGS, pid, (PTRACE_TYPE_ARG3) &regs, lwp) == -1)\n-        perror_with_name (_(\"Couldn't write registers\"));\n+\tperror_with_name (_(\"Couldn't write registers\"));\n     }\n \n   if (regnum == -1 || hppanbsd_fpregset_supplies_p (regnum))"
    },
    {
      "sha": "4bcd67124e9436f1ac8977479054a603d86e7c88",
      "filename": "gdb/hppa-netbsd-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -64,9 +64,9 @@ static int hppanbsd_mc_reg_offset[] =\n };\n \n static void hppanbsd_sigtramp_cache_init (const struct tramp_frame *,\n-                                         struct frame_info *,\n-                                         struct trad_frame_cache *,\n-                                         CORE_ADDR);\n+\t\t\t\t\t struct frame_info *,\n+\t\t\t\t\t struct trad_frame_cache *,\n+\t\t\t\t\t CORE_ADDR);\n \n static const struct tramp_frame hppanbsd_sigtramp_si4 =\n {\n@@ -99,9 +99,9 @@ static const struct tramp_frame hppanbsd_sigtramp_si4 =\n \n static void\n hppanbsd_sigtramp_cache_init (const struct tramp_frame *self,\n-                             struct frame_info *this_frame,\n-                             struct trad_frame_cache *this_cache,\n-                             CORE_ADDR func)\n+\t\t\t     struct frame_info *this_frame,\n+\t\t\t     struct trad_frame_cache *this_cache,\n+\t\t\t     CORE_ADDR func)\n {\n   CORE_ADDR sp = get_frame_register_unsigned (this_frame, HPPA_SP_REGNUM);\n   CORE_ADDR base;"
    },
    {
      "sha": "d2df92e5c4e648704abc7f2f048b9bfd43ea803d",
      "filename": "gdb/hppa-obsd-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-obsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-obsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-obsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -230,12 +230,12 @@ hppa_obsd_nat_target::store_registers (struct regcache *regcache, int regnum)\n       struct reg regs;\n \n       if (ptrace (PT_GETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't get registers\"));\n+\tperror_with_name (_(\"Couldn't get registers\"));\n \n       hppaobsd_collect_gregset (regcache, &regs, regnum);\n \n       if (ptrace (PT_SETREGS, pid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't write registers\"));\n+\tperror_with_name (_(\"Couldn't write registers\"));\n     }\n \n   if (regnum == -1 || hppaobsd_fpregset_supplies_p (regnum))"
    },
    {
      "sha": "ac7d268a677d4d5a4b245145c18de8e7678b02dc",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 125,
      "deletions": 125,
      "changes": 250,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -244,7 +244,7 @@ record_text_segment_lowaddr (bfd *abfd, asection *section, void *data)\n       CORE_ADDR *low_text_segment_address = (CORE_ADDR *)data;\n \n       if (value < *low_text_segment_address)\n-          *low_text_segment_address = value;\n+\t  *low_text_segment_address = value;\n     }\n }\n \n@@ -272,7 +272,7 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,\n \t passed in.  */\n       if (gdbarch_tdep (gdbarch)->is_elf && text_offset == 0)\n \t{\n-          low_text_segment_address = -1;\n+\t  low_text_segment_address = -1;\n \n \t  bfd_map_over_sections (objfile->obfd,\n \t\t\t\t record_text_segment_lowaddr, \n@@ -281,14 +281,14 @@ internalize_unwinds (struct objfile *objfile, struct unwind_table_entry *table,\n \t  text_offset = low_text_segment_address;\n \t}\n       else if (gdbarch_tdep (gdbarch)->solib_get_text_base)\n-        {\n+\t{\n \t  text_offset = gdbarch_tdep (gdbarch)->solib_get_text_base (objfile);\n \t}\n \n       bfd_get_section_contents (objfile->obfd, section, buf, 0, size);\n \n       /* Now internalize the information being careful to handle host/target\n-         endian issues.  */\n+\t endian issues.  */\n       for (i = 0; i < entries; i++)\n \t{\n \t  table[i].region_start = bfd_get_32 (objfile->obfd,\n@@ -488,7 +488,7 @@ find_unwind_entry (CORE_ADDR pc)\n \n   if (hppa_debug)\n     fprintf_unfiltered (gdb_stdlog, \"{ find_unwind_entry %s -> \",\n-\t\t        hex_string (pc));\n+\t\t\thex_string (pc));\n \n   /* A function at address 0?  Not in HP-UX!  */\n   if (pc == (CORE_ADDR) 0)\n@@ -736,7 +736,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n     {\n       CORE_ADDR struct_ptr = 0;\n       /* The first parameter goes into sp-36, each stack slot is 4-bytes.\n-         struct_ptr is adjusted for each argument below, so the first\n+\t struct_ptr is adjusted for each argument below, so the first\n \t argument will end up at sp-36.  */\n       CORE_ADDR param_ptr = 32;\n       int i;\n@@ -774,11 +774,11 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t\t\t   value_contents (arg)));\n \t    }\n \t  else if (type->code () == TYPE_CODE_FLT)\n-            {\n+\t    {\n \t      /* Floating point value store, right aligned.  */\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n \t      memcpy (param_val, value_contents (arg), param_len);\n-            }\n+\t    }\n \t  else\n \t    {\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n@@ -788,7 +788,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      value_contents (arg), TYPE_LENGTH (type));\n \n \t      /* Structures of size 5, 6 and 7 bytes are special in that\n-\t         the higher-ordered word is stored in the lower-ordered\n+\t\t the higher-ordered word is stored in the lower-ordered\n \t\t argument, and even though it is a 8-byte quantity the\n \t\t registers need not be 8-byte aligned.  */\n \t      if (param_len > 4 && param_len < 8)\n@@ -797,7 +797,7 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  param_ptr += param_len;\n \t  if (param_len == 8 && !small_struct)\n-            param_ptr = align_up (param_ptr, 8);\n+\t    param_ptr = align_up (param_ptr, 8);\n \n \t  /* First 4 non-FP arguments are passed in gr26-gr23.\n \t     First 4 32-bit FP arguments are passed in fr4L-fr7L.\n@@ -995,10 +995,10 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       if (hppa64_integral_or_pointer_p (type))\n \t{\n \t  /* \"Integral scalar parameters smaller than 64 bits are\n-             padded on the left (i.e., the value is in the\n-             least-significant bits of the 64-bit storage unit, and\n-             the high-order bits are undefined).\"  Therefore we can\n-             safely sign-extend them.  */\n+\t     padded on the left (i.e., the value is in the\n+\t     least-significant bits of the 64-bit storage unit, and\n+\t     the high-order bits are undefined).\"  Therefore we can\n+\t     safely sign-extend them.  */\n \t  if (len < 8)\n \t    {\n \t      arg = value_cast (builtin_type (gdbarch)->builtin_int64, arg);\n@@ -1014,8 +1014,8 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      offset = align_up (offset, 16);\n \n \t      /* \"Double-extended- and quad-precision floating-point\n-                 parameters within the first 64 bytes of the parameter\n-                 list are always passed in general registers.\"  */\n+\t\t parameters within the first 64 bytes of the parameter\n+\t\t list are always passed in general registers.\"  */\n \t    }\n \t  else\n \t    {\n@@ -1030,12 +1030,12 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t}\n \n \t      /* \"Single- and double-precision floating-point\n-                 parameters in this area are passed according to the\n-                 available formal parameter information in a function\n-                 prototype.  [...]  If no prototype is in scope,\n-                 floating-point parameters must be passed both in the\n-                 corresponding general registers and in the\n-                 corresponding floating-point registers.\"  */\n+\t\t parameters in this area are passed according to the\n+\t\t available formal parameter information in a function\n+\t\t prototype.  [...]  If no prototype is in scope,\n+\t\t floating-point parameters must be passed both in the\n+\t\t corresponding general registers and in the\n+\t\t corresponding floating-point registers.\"  */\n \t      regnum = HPPA64_FP4_REGNUM + offset / 8;\n \n \t      if (regnum < HPPA64_FP4_REGNUM + 8)\n@@ -1063,10 +1063,10 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t}\n \n       /* If we are passing a function pointer, make sure we pass a function\n-         descriptor instead of the function entry address.  */\n+\t descriptor instead of the function entry address.  */\n       if (type->code () == TYPE_CODE_PTR\n-          && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n-        {\n+\t  && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n+\t{\n \t  ULONGEST codeptr, fptr;\n \n \t  codeptr = unpack_long (type, value_contents (arg));\n@@ -1076,8 +1076,8 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  valbuf = fptrbuf;\n \t}\n       else\n-        {\n-          valbuf = value_contents (arg);\n+\t{\n+\t  valbuf = value_contents (arg);\n \t}\n \n       /* Always store the argument in memory.  */\n@@ -1183,7 +1183,7 @@ hppa64_return_value (struct gdbarch *gdbarch, struct value *function,\n   if (len > 16)\n     {\n       /* All return values larger than 128 bits must be aggregate\n-         return values.  */\n+\t return values.  */\n       gdb_assert (!hppa64_integral_or_pointer_p (type));\n       gdb_assert (!hppa64_floating_p (type));\n \n@@ -1196,7 +1196,7 @@ hppa64_return_value (struct gdbarch *gdbarch, struct value *function,\n   if (hppa64_integral_or_pointer_p (type))\n     {\n       /* \"Integral return values are returned in GR 28.  Values\n-         smaller than 64 bits are padded on the left (with garbage).\"  */\n+\t smaller than 64 bits are padded on the left (with garbage).\"  */\n       regnum = HPPA_RET0_REGNUM;\n       offset = 8 - len;\n     }\n@@ -1226,8 +1226,8 @@ hppa64_return_value (struct gdbarch *gdbarch, struct value *function,\n   else\n     {\n       /* \"Aggregate return values up to 64 bits in size are returned\n-         in GR 28.  Aggregates smaller than 64 bits are left aligned\n-         in the register; the pad bits on the right are undefined.\"\n+\t in GR 28.  Aggregates smaller than 64 bits are left aligned\n+\t in the register; the pad bits on the right are undefined.\"\n \n \t \"Aggregate return values between 65 and 128 bits are returned\n \t in GRs 28 and 29.  The first 64 bits are placed in GR 28, and\n@@ -1413,11 +1413,11 @@ is_branch (unsigned long inst)\n      the general registers are:\n \n        Store:          stb, sth, stw, std (according to Chapter 7, they\n-                       are only in both \"inst >> 26\" and \"inst >> 6\".\n+\t\t       are only in both \"inst >> 26\" and \"inst >> 6\".\n        Store Absolute: stwa, stda (according to Chapter 7, they are only\n-                       in \"inst >> 6\".\n+\t\t       in \"inst >> 6\".\n        Store Bytes:    stby, stdby (according to Chapter 7, they are\n-                       only in \"inst >> 6\").\n+\t\t       only in \"inst >> 6\").\n \n    For (inst >> 26), according to Chapter 7:\n \n@@ -1609,7 +1609,7 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n       unsigned long old_save_rp, old_save_sp, next_inst;\n \n       /* Save copies of all the triggers so we can compare them later\n-         (only for HPC).  */\n+\t (only for HPC).  */\n       old_save_gr = save_gr;\n       old_save_fr = save_fr;\n       old_save_rp = save_rp;\n@@ -1632,13 +1632,13 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n \tsave_rp = 0;\n \n       /* These are the only ways we save SP into the stack.  At this time\n-         the HP compilers never bother to save SP into the stack.  */\n+\t the HP compilers never bother to save SP into the stack.  */\n       if ((inst & 0xffffc000) == 0x6fc10000\n \t  || (inst & 0xffffc00c) == 0x73c10008)\n \tsave_sp = 0;\n \n       /* Are we loading some register with an offset from the argument\n-         pointer?  */\n+\t pointer?  */\n       if ((inst & 0xffe00000) == 0x37a00000\n \t  || (inst & 0xffffffe0) == 0x081d0240)\n \t{\n@@ -1651,15 +1651,15 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n       save_gr &= ~(1 << reg_num);\n \n       /* Ugh.  Also account for argument stores into the stack.\n-         Unfortunately args_stored only tells us that some arguments\n-         where stored into the stack.  Not how many or what kind!\n+\t Unfortunately args_stored only tells us that some arguments\n+\t where stored into the stack.  Not how many or what kind!\n \n-         This is a kludge as on the HP compiler sets this bit and it\n-         never does prologue scheduling.  So once we see one, skip past\n-         all of them.   We have similar code for the fp arg stores below.\n+\t This is a kludge as on the HP compiler sets this bit and it\n+\t never does prologue scheduling.  So once we see one, skip past\n+\t all of them.   We have similar code for the fp arg stores below.\n \n-         FIXME.  Can still die if we have a mix of GR and FR argument\n-         stores!  */\n+\t FIXME.  Can still die if we have a mix of GR and FR argument\n+\t stores!  */\n       if (reg_num >= (gdbarch_ptr_bit (gdbarch) == 64 ? 19 : 23)\n \t  && reg_num <= 26)\n \t{\n@@ -1688,7 +1688,7 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n \treturn pc;\n \n       /* We've got to be read to handle the ldo before the fp register\n-         save.  */\n+\t save.  */\n       if ((inst & 0xfc000000) == 0x34000000\n \t  && inst_saves_fr (next_inst) >= 4\n \t  && inst_saves_fr (next_inst)\n@@ -1700,9 +1700,9 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t}\n \n       /* Ugh.  Also account for argument stores into the stack.\n-         This is a kludge as on the HP compiler sets this bit and it\n-         never does prologue scheduling.  So once we see one, skip past\n-         all of them.  */\n+\t This is a kludge as on the HP compiler sets this bit and it\n+\t never does prologue scheduling.  So once we see one, skip past\n+\t all of them.  */\n       if (reg_num >= 4\n \t  && reg_num <= (gdbarch_ptr_bit (gdbarch) == 64 ? 11 : 7))\n \t{\n@@ -1728,19 +1728,19 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n \t}\n \n       /* Quit if we hit any kind of branch.  This can happen if a prologue\n-         instruction is in the delay slot of the first call/branch.  */\n+\t instruction is in the delay slot of the first call/branch.  */\n       if (is_branch (inst) && stop_before_branch)\n \tbreak;\n \n       /* What a crock.  The HP compilers set args_stored even if no\n-         arguments were stored into the stack (boo hiss).  This could\n-         cause this code to then skip a bunch of user insns (up to the\n-         first branch).\n-\n-         To combat this we try to identify when args_stored was bogusly\n-         set and clear it.   We only do this when args_stored is nonzero,\n-         all other resources are accounted for, and nothing changed on\n-         this pass.  */\n+\t arguments were stored into the stack (boo hiss).  This could\n+\t cause this code to then skip a bunch of user insns (up to the\n+\t first branch).\n+\n+\t To combat this we try to identify when args_stored was bogusly\n+\t set and clear it.   We only do this when args_stored is nonzero,\n+\t all other resources are accounted for, and nothing changed on\n+\t this pass.  */\n       if (args_stored\n        && !(save_gr || save_fr || save_rp || save_sp || stack_remaining > 0)\n \t  && old_save_gr == save_gr && old_save_fr == save_fr\n@@ -1752,7 +1752,7 @@ skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR pc,\n       pc += 4;\n \n       /* !stop_before_branch, so also look at the insn in the delay slot \n-         of the branch.  */\n+\t of the branch.  */\n       if (final_iteration)\n \tbreak;\n       if (is_branch (inst))\n@@ -1890,8 +1890,8 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n   if ((*this_cache) != NULL)\n     {\n       if (hppa_debug)\n-        fprintf_unfiltered (gdb_stdlog, \"base=%s (cached) }\",\n-          paddress (gdbarch, ((struct hppa_frame_cache *)*this_cache)->base));\n+\tfprintf_unfiltered (gdb_stdlog, \"base=%s (cached) }\",\n+\t  paddress (gdbarch, ((struct hppa_frame_cache *)*this_cache)->base));\n       return (struct hppa_frame_cache *) (*this_cache);\n     }\n   cache = FRAME_OBSTACK_ZALLOC (struct hppa_frame_cache);\n@@ -1903,7 +1903,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n   if (!u)\n     {\n       if (hppa_debug)\n-        fprintf_unfiltered (gdb_stdlog, \"base=NULL (no unwind entry) }\");\n+\tfprintf_unfiltered (gdb_stdlog, \"base=NULL (no unwind entry) }\");\n       return (struct hppa_frame_cache *) (*this_cache);\n     }\n \n@@ -2015,7 +2015,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t    cache->saved_regs[HPPA_RP_REGNUM].addr = -24;\n \t  }\n \telse if (inst == 0x0fc212c1 \n-\t         || inst == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n+\t\t || inst == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n \t  {\n \t    looking_for_rp = 0;\n \t    cache->saved_regs[HPPA_RP_REGNUM].addr = -16;\n@@ -2120,32 +2120,32 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n        the current function (and is thus equivalent to the \"saved\"\n        stack pointer.  */\n     CORE_ADDR this_sp = get_frame_register_unsigned (this_frame,\n-                                                     HPPA_SP_REGNUM);\n+\t\t\t\t\t\t     HPPA_SP_REGNUM);\n     CORE_ADDR fp;\n \n     if (hppa_debug)\n       fprintf_unfiltered (gdb_stdlog, \" (this_sp=%s, pc=%s, \"\n-\t\t          \"prologue_end=%s) \",\n-\t\t          paddress (gdbarch, this_sp),\n+\t\t\t  \"prologue_end=%s) \",\n+\t\t\t  paddress (gdbarch, this_sp),\n \t\t\t  paddress (gdbarch, get_frame_pc (this_frame)),\n \t\t\t  paddress (gdbarch, prologue_end));\n \n      /* Check to see if a frame pointer is available, and use it for\n-        frame unwinding if it is.\n+\tframe unwinding if it is.\n  \n-        There are some situations where we need to rely on the frame\n-        pointer to do stack unwinding.  For example, if a function calls\n-        alloca (), the stack pointer can get adjusted inside the body of\n-        the function.  In this case, the ABI requires that the compiler\n-        maintain a frame pointer for the function.\n+\tThere are some situations where we need to rely on the frame\n+\tpointer to do stack unwinding.  For example, if a function calls\n+\talloca (), the stack pointer can get adjusted inside the body of\n+\tthe function.  In this case, the ABI requires that the compiler\n+\tmaintain a frame pointer for the function.\n  \n-        The unwind record has a flag (alloca_frame) that indicates that\n-        a function has a variable frame; unfortunately, gcc/binutils \n-        does not set this flag.  Instead, whenever a frame pointer is used\n-        and saved on the stack, the Save_SP flag is set.  We use this to\n-        decide whether to use the frame pointer for unwinding.\n+\tThe unwind record has a flag (alloca_frame) that indicates that\n+\ta function has a variable frame; unfortunately, gcc/binutils \n+\tdoes not set this flag.  Instead, whenever a frame pointer is used\n+\tand saved on the stack, the Save_SP flag is set.  We use this to\n+\tdecide whether to use the frame pointer for unwinding.\n \t\n-        TODO: For the HP compiler, maybe we should use the alloca_frame flag \n+\tTODO: For the HP compiler, maybe we should use the alloca_frame flag \n \tinstead of Save_SP.  */\n  \n      fp = get_frame_register_unsigned (this_frame, HPPA_FP_REGNUM);\n@@ -2154,7 +2154,7 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n        fp -= u->Total_frame_size << 3;\n  \n      if (get_frame_pc (this_frame) >= prologue_end\n-         && (u->Save_SP || u->alloca_frame) && fp != 0)\n+\t && (u->Save_SP || u->alloca_frame) && fp != 0)\n       {\n  \tcache->base = fp;\n  \n@@ -2165,20 +2165,20 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n      else if (u->Save_SP \n \t      && trad_frame_addr_p (cache->saved_regs, HPPA_SP_REGNUM))\n       {\n-            /* Both we're expecting the SP to be saved and the SP has been\n+\t    /* Both we're expecting the SP to be saved and the SP has been\n \t       saved.  The entry SP value is saved at this frame's SP\n \t       address.  */\n-            cache->base = read_memory_integer (this_sp, word_size, byte_order);\n+\t    cache->base = read_memory_integer (this_sp, word_size, byte_order);\n \n \t    if (hppa_debug)\n \t      fprintf_unfiltered (gdb_stdlog, \" (base=%s) [saved]\",\n-\t\t\t          paddress (gdbarch, cache->base));\n+\t\t\t\t  paddress (gdbarch, cache->base));\n       }\n     else\n       {\n-        /* The prologue has been slowly allocating stack space.  Adjust\n+\t/* The prologue has been slowly allocating stack space.  Adjust\n \t   the SP back.  */\n-        cache->base = this_sp - frame_size;\n+\tcache->base = this_sp - frame_size;\n \tif (hppa_debug)\n \t  fprintf_unfiltered (gdb_stdlog, \" (base=%s) [unwind adjust]\",\n \t\t\t      paddress (gdbarch, cache->base));\n@@ -2192,32 +2192,32 @@ hppa_frame_cache (struct frame_info *this_frame, void **this_cache)\n   if (u->Millicode)\n     {\n       if (trad_frame_addr_p (cache->saved_regs, 31))\n-        {\n-          cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[31];\n+\t{\n+\t  cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = cache->saved_regs[31];\n \t  if (hppa_debug)\n \t    fprintf_unfiltered (gdb_stdlog, \" (pc=r31) [stack] } \");\n-        }\n+\t}\n       else\n \t{\n \t  ULONGEST r31 = get_frame_register_unsigned (this_frame, 31);\n \t  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, r31);\n \t  if (hppa_debug)\n \t    fprintf_unfiltered (gdb_stdlog, \" (pc=r31) [frame] } \");\n-        }\n+\t}\n     }\n   else\n     {\n       if (trad_frame_addr_p (cache->saved_regs, HPPA_RP_REGNUM))\n-        {\n-          cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = \n+\t{\n+\t  cache->saved_regs[HPPA_PCOQ_HEAD_REGNUM] = \n \t    cache->saved_regs[HPPA_RP_REGNUM];\n \t  if (hppa_debug)\n \t    fprintf_unfiltered (gdb_stdlog, \" (pc=rp) [stack] } \");\n-        }\n+\t}\n       else\n \t{\n \t  ULONGEST rp = get_frame_register_unsigned (this_frame,\n-                                                     HPPA_RP_REGNUM);\n+\t\t\t\t\t\t     HPPA_RP_REGNUM);\n \t  trad_frame_set_value (cache->saved_regs, HPPA_PCOQ_HEAD_REGNUM, rp);\n \t  if (hppa_debug)\n \t    fprintf_unfiltered (gdb_stdlog, \" (pc=rp) [frame] } \");\n@@ -2295,7 +2295,7 @@ hppa_frame_prev_register (struct frame_info *this_frame,\n \n static int\n hppa_frame_unwind_sniffer (const struct frame_unwind *self,\n-                           struct frame_info *this_frame, void **this_cache)\n+\t\t\t   struct frame_info *this_frame, void **this_cache)\n {\n   if (hppa_find_unwind_entry_in_block (this_frame))\n     return 1;\n@@ -2361,7 +2361,7 @@ hppa_fallback_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t      found_rp = 1;\n \t    }\n \t  else if (insn == 0x0fc212c1\n-\t           || insn == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n+\t\t   || insn == 0x73c23fe1) /* std rp,-0x10(sr0,sp) */\n \t    {\n \t      cache->saved_regs[HPPA_RP_REGNUM].addr = -16;\n \t      found_rp = 1;\n@@ -2405,7 +2405,7 @@ hppa_fallback_frame_this_id (struct frame_info *this_frame, void **this_cache,\n \n static struct value *\n hppa_fallback_frame_prev_register (struct frame_info *this_frame,\n-\t\t\t           void **this_cache, int regnum)\n+\t\t\t\t   void **this_cache, int regnum)\n {\n   struct hppa_frame_cache *info\n     = hppa_fallback_frame_cache (this_frame, this_cache);\n@@ -2480,8 +2480,8 @@ hppa_stub_frame_prev_register (struct frame_info *this_frame,\n \n static int\n hppa_stub_unwind_sniffer (const struct frame_unwind *self,\n-                          struct frame_info *this_frame,\n-                          void **this_cache)\n+\t\t\t  struct frame_info *this_frame,\n+\t\t\t  void **this_cache)\n {\n   CORE_ADDR pc = get_frame_address_in_block (this_frame);\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n@@ -2529,7 +2529,7 @@ hppa_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)\n \n struct bound_minimal_symbol\n hppa_lookup_stub_minimal_symbol (const char *name,\n-                                 enum unwind_stub_types stub_type)\n+\t\t\t\t enum unwind_stub_types stub_type)\n {\n   struct bound_minimal_symbol result = { NULL, NULL };\n \n@@ -2622,7 +2622,7 @@ unwind_command (const char *exp, int from_tty)\n     {\n       printf_unfiltered (\"\\tstub type = \");\n       switch (u->stub_unwind.stub_type)\n-        {\n+\t{\n \t  case LONG_BRANCH:\n \t    printf_unfiltered (\"long branch\\n\");\n \t    break;\n@@ -2672,9 +2672,9 @@ static int\n hppa32_cannot_store_register (struct gdbarch *gdbarch, int regnum)\n {\n   return (regnum == 0\n-          || regnum == HPPA_PCSQ_HEAD_REGNUM\n-          || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)\n-          || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA_FP4_REGNUM));\n+\t  || regnum == HPPA_PCSQ_HEAD_REGNUM\n+\t  || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)\n+\t  || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA_FP4_REGNUM));\n }\n \n static int\n@@ -2691,9 +2691,9 @@ static int\n hppa64_cannot_store_register (struct gdbarch *gdbarch, int regnum)\n {\n   return (regnum == 0\n-          || regnum == HPPA_PCSQ_HEAD_REGNUM\n-          || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)\n-          || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA64_FP4_REGNUM));\n+\t  || regnum == HPPA_PCSQ_HEAD_REGNUM\n+\t  || (regnum >= HPPA_PCSQ_TAIL_REGNUM && regnum < HPPA_IPSW_REGNUM)\n+\t  || (regnum > HPPA_IPSW_REGNUM && regnum < HPPA64_FP4_REGNUM));\n }\n \n static int\n@@ -2754,7 +2754,7 @@ hppa_find_global_pointer (struct gdbarch *gdbarch, struct value *function)\n \n struct value *\n hppa_frame_prev_register_helper (struct frame_info *this_frame,\n-\t\t\t         struct trad_frame_saved_reg saved_regs[],\n+\t\t\t\t struct trad_frame_saved_reg saved_regs[],\n \t\t\t\t int regnum)\n {\n   struct gdbarch *arch = get_frame_arch (this_frame);\n@@ -2765,8 +2765,8 @@ hppa_frame_prev_register_helper (struct frame_info *this_frame,\n       int size = register_size (arch, HPPA_PCOQ_HEAD_REGNUM);\n       CORE_ADDR pc;\n       struct value *pcoq_val =\n-        trad_frame_get_prev_register (this_frame, saved_regs,\n-                                      HPPA_PCOQ_HEAD_REGNUM);\n+\ttrad_frame_get_prev_register (this_frame, saved_regs,\n+\t\t\t\t      HPPA_PCOQ_HEAD_REGNUM);\n \n       pc = extract_unsigned_integer (value_contents_all (pcoq_val),\n \t\t\t\t     size, byte_order);\n@@ -2861,9 +2861,9 @@ hppa_match_insns (struct gdbarch *gdbarch, CORE_ADDR pc,\n       target_read_memory (npc, buf, HPPA_INSN_SIZE);\n       insn[i] = extract_unsigned_integer (buf, HPPA_INSN_SIZE, byte_order);\n       if ((insn[i] & pattern[i].mask) == pattern[i].data)\n-        npc += 4;\n+\tnpc += 4;\n       else\n-        return 0;\n+\treturn 0;\n     }\n \n   return 1;\n@@ -2958,9 +2958,9 @@ hppa_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n       pc = hppa_extract_21 (insn[0]) + hppa_extract_14 (insn[1]);\n \n       if (dp_rel)\n-        pc += get_frame_register_unsigned (frame, HPPA_DP_REGNUM);\n+\tpc += get_frame_register_unsigned (frame, HPPA_DP_REGNUM);\n       else\n-        pc += get_frame_register_unsigned (frame, HPPA_R0_REGNUM + 19);\n+\tpc += get_frame_register_unsigned (frame, HPPA_R0_REGNUM + 19);\n \n       /* fallthrough */\n     }\n@@ -2970,7 +2970,7 @@ hppa_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n       pc = read_memory_typed_address (pc, func_ptr_type);\n \n       /* If the PLT slot has not yet been resolved, the target will be\n-         the PLT stub.  */\n+\t the PLT stub.  */\n       if (in_plt_section (pc))\n \t{\n \t  /* Sanity check: are we pointing to the PLT stub?  */\n@@ -3056,27 +3056,27 @@ hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   switch (tdep->bytes_per_address)\n     {\n       case 4:\n-        set_gdbarch_num_regs (gdbarch, hppa32_num_regs);\n-        set_gdbarch_register_name (gdbarch, hppa32_register_name);\n-        set_gdbarch_register_type (gdbarch, hppa32_register_type);\n+\tset_gdbarch_num_regs (gdbarch, hppa32_num_regs);\n+\tset_gdbarch_register_name (gdbarch, hppa32_register_name);\n+\tset_gdbarch_register_type (gdbarch, hppa32_register_type);\n \tset_gdbarch_cannot_store_register (gdbarch,\n \t\t\t\t\t   hppa32_cannot_store_register);\n \tset_gdbarch_cannot_fetch_register (gdbarch,\n \t\t\t\t\t   hppa32_cannot_fetch_register);\n-        break;\n+\tbreak;\n       case 8:\n-        set_gdbarch_num_regs (gdbarch, hppa64_num_regs);\n-        set_gdbarch_register_name (gdbarch, hppa64_register_name);\n-        set_gdbarch_register_type (gdbarch, hppa64_register_type);\n-        set_gdbarch_dwarf2_reg_to_regnum (gdbarch, hppa64_dwarf_reg_to_regnum);\n+\tset_gdbarch_num_regs (gdbarch, hppa64_num_regs);\n+\tset_gdbarch_register_name (gdbarch, hppa64_register_name);\n+\tset_gdbarch_register_type (gdbarch, hppa64_register_type);\n+\tset_gdbarch_dwarf2_reg_to_regnum (gdbarch, hppa64_dwarf_reg_to_regnum);\n \tset_gdbarch_cannot_store_register (gdbarch,\n \t\t\t\t\t   hppa64_cannot_store_register);\n \tset_gdbarch_cannot_fetch_register (gdbarch,\n \t\t\t\t\t   hppa64_cannot_fetch_register);\n-        break;\n+\tbreak;\n       default:\n-        internal_error (__FILE__, __LINE__, _(\"Unsupported address size: %d\"),\n-                        tdep->bytes_per_address);\n+\tinternal_error (__FILE__, __LINE__, _(\"Unsupported address size: %d\"),\n+\t\t\ttdep->bytes_per_address);\n     }\n \n   set_gdbarch_long_bit (gdbarch, tdep->bytes_per_address * TARGET_CHAR_BIT);\n@@ -3117,7 +3117,7 @@ hppa_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       set_gdbarch_push_dummy_call (gdbarch, hppa32_push_dummy_call);\n       set_gdbarch_frame_align (gdbarch, hppa32_frame_align);\n       set_gdbarch_convert_from_func_ptr_addr\n-        (gdbarch, hppa32_convert_from_func_ptr_addr);\n+\t(gdbarch, hppa32_convert_from_func_ptr_addr);\n       break;\n     case 8:\n       set_gdbarch_push_dummy_call (gdbarch, hppa64_push_dummy_call);\n@@ -3164,7 +3164,7 @@ hppa_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n   fprintf_unfiltered (file, \"bytes_per_address = %d\\n\", \n-                      tdep->bytes_per_address);\n+\t\t      tdep->bytes_per_address);\n   fprintf_unfiltered (file, \"elf = %s\\n\", tdep->is_elf ? \"yes\" : \"no\");\n }\n "
    },
    {
      "sha": "ac8bdfd8af21b5d918494735b8f9c371f57ed9e8",
      "filename": "gdb/hppa-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/hppa-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -209,7 +209,7 @@ extern CORE_ADDR hppa_unwind_pc (struct gdbarch *gdbarch,\n \n extern struct bound_minimal_symbol\n   hppa_lookup_stub_minimal_symbol (const char *name,\n-                                   enum unwind_stub_types stub_type);\n+\t\t\t\t   enum unwind_stub_types stub_type);\n \n extern int hppa_in_solib_call_trampoline (struct gdbarch *gdbarch,\n \t\t\t\t\t  CORE_ADDR pc);"
    },
    {
      "sha": "d05d0ceb9ec63db610f5f43ab4c613dfd1e54c8d",
      "filename": "gdb/i386-bsd-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-bsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -220,7 +220,7 @@ i386bsd_fetch_inferior_registers (struct regcache *regcache, int regnum)\n \t{\n \t  have_ptrace_xmmregs = 0;\n #endif\n-          if (gdb_ptrace (PT_GETFPREGS, ptid,\n+\t  if (gdb_ptrace (PT_GETFPREGS, ptid,\n \t\t\t  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n \t    perror_with_name (_(\"Couldn't get floating point status\"));\n \n@@ -244,12 +244,12 @@ i386bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n       struct reg regs;\n \n       if (gdb_ptrace (PT_GETREGS, ptid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't get registers\"));\n+\tperror_with_name (_(\"Couldn't get registers\"));\n \n       i386bsd_collect_gregset (regcache, &regs, regnum);\n \n       if (gdb_ptrace (PT_SETREGS, ptid, (PTRACE_TYPE_ARG3) &regs, 0) == -1)\n-        perror_with_name (_(\"Couldn't write registers\"));\n+\tperror_with_name (_(\"Couldn't write registers\"));\n \n       if (regnum != -1)\n \treturn;\n@@ -319,23 +319,23 @@ i386bsd_store_inferior_registers (struct regcache *regcache, int regnum)\n \n \t  if (gdb_ptrace (PT_SETXMMREGS, ptid,\n \t\t\t  (PTRACE_TYPE_ARG3) xmmregs, 0) == -1)\n-            perror_with_name (_(\"Couldn't write XMM registers\"));\n+\t    perror_with_name (_(\"Couldn't write XMM registers\"));\n \t}\n       else\n \t{\n \t  have_ptrace_xmmregs = 0;\n #endif\n-          if (gdb_ptrace (PT_GETFPREGS, ptid,\n+\t  if (gdb_ptrace (PT_GETFPREGS, ptid,\n \t\t\t  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n \t    perror_with_name (_(\"Couldn't get floating point status\"));\n \n-          i387_collect_fsave (regcache, regnum, &fpregs);\n+\t  i387_collect_fsave (regcache, regnum, &fpregs);\n \n-          if (gdb_ptrace (PT_SETFPREGS, ptid,\n+\t  if (gdb_ptrace (PT_SETFPREGS, ptid,\n \t\t\t  (PTRACE_TYPE_ARG3) &fpregs, 0) == -1)\n \t    perror_with_name (_(\"Couldn't write floating point status\"));\n #ifdef HAVE_PT_GETXMMREGS\n-        }\n+\t}\n #endif\n     }\n }"
    },
    {
      "sha": "20ac4dbcd60c8e7ce512647673f9615ebfa3e2a8",
      "filename": "gdb/i386-darwin-nat.c",
      "status": "modified",
      "additions": 73,
      "deletions": 73,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-darwin-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-darwin-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -67,14 +67,14 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)\n   if (gdbarch_ptr_bit (gdbarch) == 64)\n     {\n       if (regno == -1 || amd64_native_gregset_supplies_p (gdbarch, regno))\n-        {\n-          x86_thread_state_t gp_regs;\n-          unsigned int gp_count = x86_THREAD_STATE_COUNT;\n-          kern_return_t ret;\n+\t{\n+\t  x86_thread_state_t gp_regs;\n+\t  unsigned int gp_count = x86_THREAD_STATE_COUNT;\n+\t  kern_return_t ret;\n \n \t  ret = thread_get_state\n-            (current_thread, x86_THREAD_STATE, (thread_state_t) & gp_regs,\n-             &gp_count);\n+\t    (current_thread, x86_THREAD_STATE, (thread_state_t) & gp_regs,\n+\t     &gp_count);\n \t  if (ret != KERN_SUCCESS)\n \t    {\n \t      printf_unfiltered (_(\"Error calling thread_get_state for \"\n@@ -88,42 +88,42 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)\n \t  gp_regs.uts.ts64.__gs &= 0xffff;\n \n \t  amd64_supply_native_gregset (regcache, &gp_regs.uts, -1);\n-          fetched++;\n-        }\n+\t  fetched++;\n+\t}\n \n       if (regno == -1 || !amd64_native_gregset_supplies_p (gdbarch, regno))\n-        {\n-          x86_float_state_t fp_regs;\n-          unsigned int fp_count = x86_FLOAT_STATE_COUNT;\n-          kern_return_t ret;\n+\t{\n+\t  x86_float_state_t fp_regs;\n+\t  unsigned int fp_count = x86_FLOAT_STATE_COUNT;\n+\t  kern_return_t ret;\n \n \t  ret = thread_get_state\n-            (current_thread, x86_FLOAT_STATE, (thread_state_t) & fp_regs,\n-             &fp_count);\n+\t    (current_thread, x86_FLOAT_STATE, (thread_state_t) & fp_regs,\n+\t     &fp_count);\n \t  if (ret != KERN_SUCCESS)\n \t    {\n \t      printf_unfiltered (_(\"Error calling thread_get_state for \"\n \t\t\t\t   \"float registers for thread 0x%lx\\n\"),\n \t\t\t\t (unsigned long) current_thread);\n \t      MACH_CHECK_ERROR (ret);\n \t    }\n-          amd64_supply_fxsave (regcache, -1, &fp_regs.ufs.fs64.__fpu_fcw);\n-          fetched++;\n-        }\n+\t  amd64_supply_fxsave (regcache, -1, &fp_regs.ufs.fs64.__fpu_fcw);\n+\t  fetched++;\n+\t}\n     }\n   else\n #endif\n     {\n       if (regno == -1 || regno < I386_NUM_GREGS)\n-        {\n-          x86_thread_state32_t gp_regs;\n-          unsigned int gp_count = x86_THREAD_STATE32_COUNT;\n-          kern_return_t ret;\n+\t{\n+\t  x86_thread_state32_t gp_regs;\n+\t  unsigned int gp_count = x86_THREAD_STATE32_COUNT;\n+\t  kern_return_t ret;\n \t  int i;\n \n \t  ret = thread_get_state\n-            (current_thread, x86_THREAD_STATE32, (thread_state_t) &gp_regs,\n-             &gp_count);\n+\t    (current_thread, x86_THREAD_STATE32, (thread_state_t) &gp_regs,\n+\t     &gp_count);\n \t  if (ret != KERN_SUCCESS)\n \t    {\n \t      printf_unfiltered (_(\"Error calling thread_get_state for \"\n@@ -135,29 +135,29 @@ i386_darwin_nat_target::fetch_registers (struct regcache *regcache, int regno)\n \t    regcache->raw_supply\n \t      (i, (char *) &gp_regs + i386_darwin_thread_state_reg_offset[i]);\n \n-          fetched++;\n-        }\n+\t  fetched++;\n+\t}\n \n       if (regno == -1\n \t  || (regno >= I386_ST0_REGNUM && regno < I386_SSE_NUM_REGS))\n-        {\n-          x86_float_state32_t fp_regs;\n-          unsigned int fp_count = x86_FLOAT_STATE32_COUNT;\n-          kern_return_t ret;\n+\t{\n+\t  x86_float_state32_t fp_regs;\n+\t  unsigned int fp_count = x86_FLOAT_STATE32_COUNT;\n+\t  kern_return_t ret;\n \n \t  ret = thread_get_state\n-            (current_thread, x86_FLOAT_STATE32, (thread_state_t) &fp_regs,\n-             &fp_count);\n+\t    (current_thread, x86_FLOAT_STATE32, (thread_state_t) &fp_regs,\n+\t     &fp_count);\n \t  if (ret != KERN_SUCCESS)\n \t    {\n \t      printf_unfiltered (_(\"Error calling thread_get_state for \"\n \t\t\t\t   \"float registers for thread 0x%lx\\n\"),\n \t\t\t\t (unsigned long) current_thread);\n \t      MACH_CHECK_ERROR (ret);\n \t    }\n-          i387_supply_fxsave (regcache, -1, &fp_regs.__fpu_fcw);\n-          fetched++;\n-        }\n+\t  i387_supply_fxsave (regcache, -1, &fp_regs.__fpu_fcw);\n+\t  fetched++;\n+\t}\n     }\n \n   if (! fetched)\n@@ -182,87 +182,87 @@ i386_darwin_nat_target::store_registers (struct regcache *regcache,\n   if (gdbarch_ptr_bit (gdbarch) == 64)\n     {\n       if (regno == -1 || amd64_native_gregset_supplies_p (gdbarch, regno))\n-        {\n-          x86_thread_state_t gp_regs;\n-          kern_return_t ret;\n+\t{\n+\t  x86_thread_state_t gp_regs;\n+\t  kern_return_t ret;\n \t  unsigned int gp_count = x86_THREAD_STATE_COUNT;\n \n \t  ret = thread_get_state\n \t    (current_thread, x86_THREAD_STATE, (thread_state_t) &gp_regs,\n \t     &gp_count);\n-          MACH_CHECK_ERROR (ret);\n+\t  MACH_CHECK_ERROR (ret);\n \t  gdb_assert (gp_regs.tsh.flavor == x86_THREAD_STATE64);\n-          gdb_assert (gp_regs.tsh.count == x86_THREAD_STATE64_COUNT);\n+\t  gdb_assert (gp_regs.tsh.count == x86_THREAD_STATE64_COUNT);\n \n \t  amd64_collect_native_gregset (regcache, &gp_regs.uts, regno);\n \n \t  /* Some kernels don't sanitize the values.  */\n \t  gp_regs.uts.ts64.__fs &= 0xffff;\n \t  gp_regs.uts.ts64.__gs &= 0xffff;\n \n-          ret = thread_set_state (current_thread, x86_THREAD_STATE,\n-                                  (thread_state_t) &gp_regs,\n-                                  x86_THREAD_STATE_COUNT);\n-          MACH_CHECK_ERROR (ret);\n-        }\n+\t  ret = thread_set_state (current_thread, x86_THREAD_STATE,\n+\t\t\t\t  (thread_state_t) &gp_regs,\n+\t\t\t\t  x86_THREAD_STATE_COUNT);\n+\t  MACH_CHECK_ERROR (ret);\n+\t}\n \n       if (regno == -1 || !amd64_native_gregset_supplies_p (gdbarch, regno))\n-        {\n-          x86_float_state_t fp_regs;\n-          kern_return_t ret;\n+\t{\n+\t  x86_float_state_t fp_regs;\n+\t  kern_return_t ret;\n \t  unsigned int fp_count = x86_FLOAT_STATE_COUNT;\n \n \t  ret = thread_get_state\n \t    (current_thread, x86_FLOAT_STATE, (thread_state_t) & fp_regs,\n \t     &fp_count);\n-          MACH_CHECK_ERROR (ret);\n-          gdb_assert (fp_regs.fsh.flavor == x86_FLOAT_STATE64);\n-          gdb_assert (fp_regs.fsh.count == x86_FLOAT_STATE64_COUNT);\n+\t  MACH_CHECK_ERROR (ret);\n+\t  gdb_assert (fp_regs.fsh.flavor == x86_FLOAT_STATE64);\n+\t  gdb_assert (fp_regs.fsh.count == x86_FLOAT_STATE64_COUNT);\n \n \t  amd64_collect_fxsave (regcache, regno, &fp_regs.ufs.fs64.__fpu_fcw);\n \n \t  ret = thread_set_state (current_thread, x86_FLOAT_STATE,\n \t\t\t\t  (thread_state_t) & fp_regs,\n \t\t\t\t  x86_FLOAT_STATE_COUNT);\n \t  MACH_CHECK_ERROR (ret);\n-        }\n+\t}\n     }\n   else\n #endif\n     {\n       if (regno == -1 || regno < I386_NUM_GREGS)\n-        {\n-          x86_thread_state32_t gp_regs;\n-          kern_return_t ret;\n-          unsigned int gp_count = x86_THREAD_STATE32_COUNT;\n+\t{\n+\t  x86_thread_state32_t gp_regs;\n+\t  kern_return_t ret;\n+\t  unsigned int gp_count = x86_THREAD_STATE32_COUNT;\n \t  int i;\n \n-          ret = thread_get_state\n-            (current_thread, x86_THREAD_STATE32, (thread_state_t) &gp_regs,\n-             &gp_count);\n+\t  ret = thread_get_state\n+\t    (current_thread, x86_THREAD_STATE32, (thread_state_t) &gp_regs,\n+\t     &gp_count);\n \t  MACH_CHECK_ERROR (ret);\n \n \t  for (i = 0; i < I386_NUM_GREGS; i++)\n \t    if (regno == -1 || regno == i)\n \t      regcache->raw_collect\n \t\t(i, (char *) &gp_regs + i386_darwin_thread_state_reg_offset[i]);\n \n-          ret = thread_set_state (current_thread, x86_THREAD_STATE32,\n-                                  (thread_state_t) &gp_regs,\n-                                  x86_THREAD_STATE32_COUNT);\n-          MACH_CHECK_ERROR (ret);\n-        }\n+\t  ret = thread_set_state (current_thread, x86_THREAD_STATE32,\n+\t\t\t\t  (thread_state_t) &gp_regs,\n+\t\t\t\t  x86_THREAD_STATE32_COUNT);\n+\t  MACH_CHECK_ERROR (ret);\n+\t}\n \n       if (regno == -1\n \t  || (regno >= I386_ST0_REGNUM && regno < I386_SSE_NUM_REGS))\n-        {\n-          x86_float_state32_t fp_regs;\n-          unsigned int fp_count = x86_FLOAT_STATE32_COUNT;\n-          kern_return_t ret;\n+\t{\n+\t  x86_float_state32_t fp_regs;\n+\t  unsigned int fp_count = x86_FLOAT_STATE32_COUNT;\n+\t  kern_return_t ret;\n \n \t  ret = thread_get_state\n-            (current_thread, x86_FLOAT_STATE32, (thread_state_t) & fp_regs,\n-             &fp_count);\n+\t    (current_thread, x86_FLOAT_STATE32, (thread_state_t) & fp_regs,\n+\t     &fp_count);\n \t  MACH_CHECK_ERROR (ret);\n \n \t  i387_collect_fxsave (regcache, regno, &fp_regs.__fpu_fcw);\n@@ -271,7 +271,7 @@ i386_darwin_nat_target::store_registers (struct regcache *regcache,\n \t\t\t\t  (thread_state_t) &fp_regs,\n \t\t\t\t  x86_FLOAT_STATE32_COUNT);\n \t  MACH_CHECK_ERROR (ret);\n-        }\n+\t}\n     }\n }\n \n@@ -293,7 +293,7 @@ i386_darwin_dr_set (int regnum, CORE_ADDR value)\n   dr_regs.dsh.count = x86_DEBUG_STATE_COUNT;\n   dr_count = x86_DEBUG_STATE_COUNT;\n   ret = thread_get_state (current_thread, x86_DEBUG_STATE,\n-                          (thread_state_t) &dr_regs, &dr_count);\n+\t\t\t  (thread_state_t) &dr_regs, &dr_count);\n   MACH_CHECK_ERROR (ret);\n \n   switch (dr_regs.dsh.flavor)\n@@ -361,7 +361,7 @@ i386_darwin_dr_set (int regnum, CORE_ADDR value)\n     }\n \n   ret = thread_set_state (current_thread, dr_regs.dsh.flavor,\n-                          (thread_state_t) &dr_regs.uds, dr_count);\n+\t\t\t  (thread_state_t) &dr_regs.uds, dr_count);\n \n   MACH_CHECK_ERROR (ret);\n }\n@@ -382,7 +382,7 @@ i386_darwin_dr_get (int regnum)\n   dr_regs.dsh.count = x86_DEBUG_STATE_COUNT;\n   dr_count = x86_DEBUG_STATE_COUNT;\n   ret = thread_get_state (current_thread, x86_DEBUG_STATE,\n-                          (thread_state_t) &dr_regs, &dr_count);\n+\t\t\t  (thread_state_t) &dr_regs, &dr_count);\n   MACH_CHECK_ERROR (ret);\n \n   switch (dr_regs.dsh.flavor)"
    },
    {
      "sha": "b9f52406b55d226b99e9ffbc680d99f5473d4629",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -110,7 +110,7 @@ static int\n i386_m128_p (struct type *type)\n {\n   return (type->code () == TYPE_CODE_ARRAY && type->is_vector ()\n-          && TYPE_LENGTH (type) == 16);\n+\t  && TYPE_LENGTH (type) == 16);\n }\n \n /* Return the alignment for TYPE when passed as an argument.  */\n@@ -121,16 +121,16 @@ i386_darwin_arg_type_alignment (struct type *type)\n   type = check_typedef (type);\n   /* According to Mac OS X ABI document (passing arguments):\n      6.  The caller places 64-bit vectors (__m64) on the parameter area,\n-         aligned to 8-byte boundaries.\n+\t aligned to 8-byte boundaries.\n      7.  [...]  The caller aligns 128-bit vectors in the parameter area to\n-         16-byte boundaries.  */\n+\t 16-byte boundaries.  */\n   if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     return TYPE_LENGTH (type);\n   /* 4.  The caller places all the fields of structures (or unions) with no\n-         vector elements in the parameter area.  These structures are 4-byte\n-         aligned.\n+\t vector elements in the parameter area.  These structures are 4-byte\n+\t aligned.\n      5.  The caller places structures with vector elements on the stack,\n-         16-byte aligned.  */\n+\t 16-byte aligned.  */\n   if (type->code () == TYPE_CODE_STRUCT\n       || type->code () == TYPE_CODE_UNION)\n     {\n@@ -178,41 +178,41 @@ i386_darwin_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      store_unsigned_integer (buf, 4, byte_order, struct_addr);\n \t      write_memory (sp, buf, 4);\n \t    }\n-          args_space += 4;\n+\t  args_space += 4;\n \t}\n \n       for (i = 0; i < nargs; i++)\n \t{\n-          struct type *arg_type = value_enclosing_type (args[i]);\n-\n-          if (i386_m128_p (arg_type) && num_m128 < 4)\n-            {\n-              if (write_pass)\n-                {\n-                  const gdb_byte *val = value_contents_all (args[i]);\n-                  regcache->raw_write (I387_MM0_REGNUM(tdep) + num_m128, val);\n-                }\n-              num_m128++;\n-            }\n-          else\n-            {\n-              args_space = align_up (args_space,\n+\t  struct type *arg_type = value_enclosing_type (args[i]);\n+\n+\t  if (i386_m128_p (arg_type) && num_m128 < 4)\n+\t    {\n+\t      if (write_pass)\n+\t\t{\n+\t\t  const gdb_byte *val = value_contents_all (args[i]);\n+\t\t  regcache->raw_write (I387_MM0_REGNUM(tdep) + num_m128, val);\n+\t\t}\n+\t      num_m128++;\n+\t    }\n+\t  else\n+\t    {\n+\t      args_space = align_up (args_space,\n \t\t\t\t     i386_darwin_arg_type_alignment (arg_type));\n-              if (write_pass)\n-                write_memory (sp + args_space,\n-                              value_contents_all (args[i]),\n+\t      if (write_pass)\n+\t\twrite_memory (sp + args_space,\n+\t\t\t      value_contents_all (args[i]),\n \t\t\t      TYPE_LENGTH (arg_type));\n \n-              /* The System V ABI says that:\n-                 \n-                 \"An argument's size is increased, if necessary, to make it a\n-                 multiple of [32-bit] words.  This may require tail padding,\n-                 depending on the size of the argument.\"\n-                 \n-                 This makes sure the stack stays word-aligned.  */\n-              args_space += align_up (TYPE_LENGTH (arg_type), 4);\n-            }\n-        }\n+\t      /* The System V ABI says that:\n+\t\t \n+\t\t \"An argument's size is increased, if necessary, to make it a\n+\t\t multiple of [32-bit] words.  This may require tail padding,\n+\t\t depending on the size of the argument.\"\n+\t\t \n+\t\t This makes sure the stack stays word-aligned.  */\n+\t      args_space += align_up (TYPE_LENGTH (arg_type), 4);\n+\t    }\n+\t}\n \n       /* Darwin i386 ABI:\n \t 1.  The caller ensures that the stack is 16-byte aligned at the point\n@@ -291,7 +291,7 @@ void\n _initialize_i386_darwin_tdep ()\n {\n   gdbarch_register_osabi_sniffer (bfd_arch_unknown, bfd_target_mach_o_flavour,\n-                                  i386_mach_o_osabi_sniffer);\n+\t\t\t\t  i386_mach_o_osabi_sniffer);\n \n   gdbarch_register_osabi (bfd_arch_i386, bfd_mach_i386_i386,\n \t\t\t  GDB_OSABI_DARWIN, i386_darwin_init_abi);"
    },
    {
      "sha": "a47ff63da03df87b52cee8c2f663f20ac3e94330",
      "filename": "gdb/i386-dicos-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-dicos-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-dicos-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-dicos-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -46,8 +46,8 @@ void\n _initialize_i386_dicos_tdep ()\n {\n   gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_elf_flavour,\n-                                  i386_dicos_osabi_sniffer);\n+\t\t\t\t  i386_dicos_osabi_sniffer);\n \n   gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_DICOS,\n-                          i386_dicos_init_abi);\n+\t\t\t  i386_dicos_init_abi);\n }"
    },
    {
      "sha": "06949d123bc33751234fea6c768e2d83f23bbd7d",
      "filename": "gdb/i386-gnu-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-gnu-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -230,7 +230,7 @@ i386_gnu_nat_target::store_registers (struct regcache *regcache, int regno)\n \t}\n \n       /* Save the T bit.  We might try to restore the %eflags register\n-         below, but changing the T bit would seriously confuse GDB.  */\n+\t below, but changing the T bit would seriously confuse GDB.  */\n       trace = ((struct i386_thread_state *)state)->efl & 0x100;\n \n       if (!was_aborted && was_valid)"
    },
    {
      "sha": "3c6999fa2364ed5a5f7cb578bf25d5bcae37430b",
      "filename": "gdb/i386-linux-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -215,7 +215,7 @@ fetch_regs (struct regcache *regcache, int tid)\n       if (errno == EIO)\n \t{\n \t  /* The kernel we're running on doesn't support the GETREGS\n-             request.  Reset `have_ptrace_getregs'.  */\n+\t     request.  Reset `have_ptrace_getregs'.  */\n \t  have_ptrace_getregs = 0;\n \t  return;\n \t}\n@@ -669,12 +669,12 @@ i386_linux_nat_target::low_resume (ptid_t ptid, int step, enum gdb_signal signal\n \t\t\t\t     gdbarch_pc_regnum (gdbarch), &pc);\n \n       /* Returning from a signal trampoline is done by calling a\n-         special system call (sigreturn or rt_sigreturn, see\n-         i386-linux-tdep.c for more information).  This system call\n-         restores the registers that were saved when the signal was\n-         raised, including %eflags.  That means that single-stepping\n-         won't work.  Instead, we'll have to modify the signal context\n-         that's about to be restored, and set the trace flag there.  */\n+\t special system call (sigreturn or rt_sigreturn, see\n+\t i386-linux-tdep.c for more information).  This system call\n+\t restores the registers that were saved when the signal was\n+\t raised, including %eflags.  That means that single-stepping\n+\t won't work.  Instead, we'll have to modify the signal context\n+\t that's about to be restored, and set the trace flag there.  */\n \n       /* First check if PC is at a system call.  */\n       if (target_read_memory (pc, buf, LINUX_SYSCALL_LEN) == 0\n@@ -698,7 +698,7 @@ i386_linux_nat_target::low_resume (ptid_t ptid, int step, enum gdb_signal signal\n \t\taddr = sp;\n \n \t      /* Set the trace flag in the context that's about to be\n-                 restored.  */\n+\t\t restored.  */\n \t      addr += LINUX_SIGCONTEXT_EFLAGS_OFFSET;\n \t      read_memory (addr, (gdb_byte *) &eflags, 4);\n \t      eflags |= 0x0100;"
    },
    {
      "sha": "b9ec95806349073c98ef91c151847e37fa8e642d",
      "filename": "gdb/i386-linux-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -409,11 +409,11 @@ i386_linux_report_signal_info (struct gdbarch *gdbarch, struct ui_out *uiout,\n       sig_code = parse_and_eval_long (\"$_siginfo.si_code\\n\");\n \n       lower_bound\n-        = parse_and_eval_long (\"$_siginfo._sifields._sigfault._addr_bnd._lower\");\n+\t= parse_and_eval_long (\"$_siginfo._sifields._sigfault._addr_bnd._lower\");\n       upper_bound\n-        = parse_and_eval_long (\"$_siginfo._sifields._sigfault._addr_bnd._upper\");\n+\t= parse_and_eval_long (\"$_siginfo._sifields._sigfault._addr_bnd._upper\");\n       access\n-        = parse_and_eval_long (\"$_siginfo._sifields._sigfault.si_addr\");\n+\t= parse_and_eval_long (\"$_siginfo._sifields._sigfault.si_addr\");\n     }\n   catch (const gdb_exception &exception)\n     {\n@@ -467,7 +467,7 @@ i386_linux_intx80_sysenter_syscall_record (struct regcache *regcache)\n   if (syscall_gdb < 0)\n     {\n       printf_unfiltered (_(\"Process record and replay target doesn't \"\n-                           \"support syscall number %s\\n\"), \n+\t\t\t   \"support syscall number %s\\n\"), \n \t\t\t plongest (syscall_native));\n       return -1;\n     }\n@@ -497,8 +497,8 @@ i386_linux_intx80_sysenter_syscall_record (struct regcache *regcache)\n \n static int\n i386_linux_record_signal (struct gdbarch *gdbarch,\n-                          struct regcache *regcache,\n-                          enum gdb_signal signal)\n+\t\t\t  struct regcache *regcache,\n+\t\t\t  enum gdb_signal signal)\n {\n   ULONGEST esp;\n \n@@ -1052,7 +1052,7 @@ i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   /* Core file support.  */\n   set_gdbarch_iterate_over_regset_sections\n@@ -1062,15 +1062,15 @@ i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Displaced stepping.  */\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n-                                        i386_linux_displaced_step_copy_insn);\n+\t\t\t\t\ti386_linux_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, i386_displaced_step_fixup);\n   set_gdbarch_displaced_step_location (gdbarch,\n-                                       linux_displaced_step_location);\n+\t\t\t\t       linux_displaced_step_location);\n \n   /* Functions for 'catch syscall'.  */\n   set_xml_syscall_file_name (gdbarch, XML_SYSCALL_FILENAME_I386);\n   set_gdbarch_get_syscall_number (gdbarch,\n-                                  i386_linux_get_syscall_number);\n+\t\t\t\t  i386_linux_get_syscall_number);\n \n   set_gdbarch_get_siginfo_type (gdbarch, x86_linux_get_siginfo_type);\n   set_gdbarch_report_signal_info (gdbarch, i386_linux_report_signal_info);"
    },
    {
      "sha": "09d2f750bb0339c9b3fdc9d6031d0aaabede781e",
      "filename": "gdb/i386-nto-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-nto-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-nto-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-nto-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -161,7 +161,7 @@ i386nto_register_area (struct gdbarch *gdbarch,\n \t  if (first_four)\n \t    {\n \t      /* fpu_control_word, fpu_status_word, fpu_tag_word, fpu_operand\n-\t         registers.  */\n+\t\t registers.  */\n \t      regsize = 2; /* Two bytes each.  */\n \t      off_adjust = 0;\n \t      regno_base = I387_FCTRL_REGNUM (tdep);\n@@ -351,15 +351,15 @@ i386nto_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n       /* Our loader handles solib relocations differently than svr4.  */\n       nto_svr4_so_ops.relocate_section_addresses\n-        = nto_relocate_section_addresses;\n+\t= nto_relocate_section_addresses;\n \n       /* Supply a nice function to find our solibs.  */\n       nto_svr4_so_ops.find_and_open_solib\n-        = nto_find_and_open_solib;\n+\t= nto_find_and_open_solib;\n \n       /* Our linker code is in libc.  */\n       nto_svr4_so_ops.in_dynsym_resolve_code\n-        = nto_in_dynsym_resolve_code;\n+\t= nto_in_dynsym_resolve_code;\n     }\n   set_solib_ops (gdbarch, &nto_svr4_so_ops);\n "
    },
    {
      "sha": "0787c43c9a4eaca13adb50b611b184bfb0801c6c",
      "filename": "gdb/i386-obsd-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-obsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-obsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-obsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -207,7 +207,7 @@ i386obsd_supply_uthread (struct regcache *regcache,\n       sp = read_memory_unsigned_integer (sp_addr, 4, byte_order);\n \n       /* Adjust the stack pointer such that it looks as if we just\n-         returned from _thread_machdep_switch.  */\n+\t returned from _thread_machdep_switch.  */\n       offset = i386obsd_uthread_reg_offset[I386_EIP_REGNUM] + 4;\n       store_unsigned_integer (buf, 4, byte_order, sp + offset);\n       regcache->raw_supply (I386_ESP_REGNUM, buf);\n@@ -219,7 +219,7 @@ i386obsd_supply_uthread (struct regcache *regcache,\n \t  && (regnum == -1 || regnum == i))\n \t{\n \t  /* Fetch stack pointer from thread structure (if we didn't\n-             do so already).  */\n+\t     do so already).  */\n \t  if (sp == 0)\n \t    sp = read_memory_unsigned_integer (sp_addr, 4, byte_order);\n \n@@ -248,7 +248,7 @@ i386obsd_collect_uthread (const struct regcache *regcache,\n       int offset;\n \n       /* Calculate the stack pointer (frame pointer) that will be\n-         stored into the thread structure.  */\n+\t stored into the thread structure.  */\n       offset = i386obsd_uthread_reg_offset[I386_EIP_REGNUM] + 4;\n       regcache->raw_collect (I386_ESP_REGNUM, buf);\n       sp = extract_unsigned_integer (buf, 4, byte_order) - offset;\n@@ -257,7 +257,7 @@ i386obsd_collect_uthread (const struct regcache *regcache,\n       write_memory_unsigned_integer (sp_addr, 4, byte_order, sp);\n \n       /* The stack pointer was (potentially) modified.  Make sure we\n-         build a proper stack frame.  */\n+\t build a proper stack frame.  */\n       regnum = -1;\n     }\n \n@@ -267,7 +267,7 @@ i386obsd_collect_uthread (const struct regcache *regcache,\n \t  && (regnum == -1 || regnum == i))\n \t{\n \t  /* Fetch stack pointer from thread structure (if we didn't\n-             calculate it already).  */\n+\t     calculate it already).  */\n \t  if (sp == 0)\n \t    sp = read_memory_unsigned_integer (sp_addr, 4, byte_order);\n "
    },
    {
      "sha": "74f347b7586d7c9d55931ca596f104ac15dec70f",
      "filename": "gdb/i386-sol2-nat.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-sol2-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-sol2-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-sol2-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -149,21 +149,21 @@ fill_fpregset (const struct regcache *regcache,\n    and the floating-point set by:\n \n    typedef struct fpregset   {\n-           union {\n-                   struct fpchip_state            // fp extension state //\n-                   {\n-                           int     state[27];     // 287/387 saved state //\n-                           int     status;        // status word saved at //\n-                                                  // exception //\n-                   } fpchip_state;\n-                   struct fp_emul_space           // for emulators //\n-                   {\n-                           char    fp_emul[246];\n-                           char    fp_epad[2];\n-                   } fp_emul_space;\n-                   int     f_fpregs[62];          // union of the above //\n-           } fp_reg_set;\n-           long            f_wregs[33];           // saved weitek state //\n+\t   union {\n+\t\t   struct fpchip_state            // fp extension state //\n+\t\t   {\n+\t\t\t   int     state[27];     // 287/387 saved state //\n+\t\t\t   int     status;        // status word saved at //\n+\t\t\t\t\t\t  // exception //\n+\t\t   } fpchip_state;\n+\t\t   struct fp_emul_space           // for emulators //\n+\t\t   {\n+\t\t\t   char    fp_emul[246];\n+\t\t\t   char    fp_epad[2];\n+\t\t   } fp_emul_space;\n+\t\t   int     f_fpregs[62];          // union of the above //\n+\t   } fp_reg_set;\n+\t   long            f_wregs[33];           // saved weitek state //\n    } fpregset_t;\n \n    Incidentally fpchip_state contains the FPU state in the same format"
    },
    {
      "sha": "00de4e1ccb9ed670d97241798ce409c92011024e",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 1023,
      "deletions": 1023,
      "changes": 2046,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -490,11 +490,11 @@ i386_dbx_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n   if (reg >= 0 && reg <= 7)\n     {\n       /* General-purpose registers.  The debug info calls %ebp\n-         register 4, and %esp register 5.  */\n+\t register 4, and %esp register 5.  */\n       if (reg == 4)\n-        return 5;\n+\treturn 5;\n       else if (reg == 5)\n-        return 4;\n+\treturn 4;\n       else return reg;\n     }\n   else if (reg >= 12 && reg <= 19)\n@@ -661,11 +661,11 @@ i386_absolute_jmp_p (const gdb_byte *insn)\n     {\n       /* jump near, absolute indirect (/4).  */\n       if ((insn[1] & 0x38) == 0x20)\n-        return 1;\n+\treturn 1;\n \n       /* jump far, absolute indirect (/5).  */\n       if ((insn[1] & 0x38) == 0x28)\n-        return 1;\n+\treturn 1;\n     }\n \n   return 0;\n@@ -698,11 +698,11 @@ i386_absolute_call_p (const gdb_byte *insn)\n     {\n       /* Call near, absolute indirect (/2).  */\n       if ((insn[1] & 0x38) == 0x10)\n-        return 1;\n+\treturn 1;\n \n       /* Call far, absolute indirect (/3).  */\n       if ((insn[1] & 0x38) == 0x18)\n-        return 1;\n+\treturn 1;\n     }\n \n   return 0;\n@@ -826,7 +826,7 @@ i386_displaced_step_copy_insn (struct gdbarch *gdbarch,\n   write_memory (to, buf, len);\n \n   displaced_debug_printf (\"%s->%s: %s\",\n-                          paddress (gdbarch, from), paddress (gdbarch, to),\n+\t\t\t  paddress (gdbarch, from), paddress (gdbarch, to),\n \t\t\t  displaced_step_dump_bytes (buf, len).c_str ());\n \n   /* This is a work around for a problem with g++ 4.8.  */\n@@ -838,9 +838,9 @@ i386_displaced_step_copy_insn (struct gdbarch *gdbarch,\n \n void\n i386_displaced_step_fixup (struct gdbarch *gdbarch,\n-                           struct displaced_step_closure *closure_,\n-                           CORE_ADDR from, CORE_ADDR to,\n-                           struct regcache *regs)\n+\t\t\t   struct displaced_step_closure *closure_,\n+\t\t\t   CORE_ADDR from, CORE_ADDR to,\n+\t\t\t   struct regcache *regs)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \n@@ -893,41 +893,41 @@ i386_displaced_step_fixup (struct gdbarch *gdbarch,\n       regcache_cooked_read_unsigned (regs, I386_EIP_REGNUM, &orig_eip);\n \n       /* A signal trampoline system call changes the %eip, resuming\n-         execution of the main program after the signal handler has\n-         returned.  That makes them like 'return' instructions; we\n-         shouldn't relocate %eip.\n-\n-         But most system calls don't, and we do need to relocate %eip.\n-\n-         Our heuristic for distinguishing these cases: if stepping\n-         over the system call instruction left control directly after\n-         the instruction, the we relocate --- control almost certainly\n-         doesn't belong in the displaced copy.  Otherwise, we assume\n-         the instruction has put control where it belongs, and leave\n-         it unrelocated.  Goodness help us if there are PC-relative\n-         system calls.  */\n+\t execution of the main program after the signal handler has\n+\t returned.  That makes them like 'return' instructions; we\n+\t shouldn't relocate %eip.\n+\n+\t But most system calls don't, and we do need to relocate %eip.\n+\n+\t Our heuristic for distinguishing these cases: if stepping\n+\t over the system call instruction left control directly after\n+\t the instruction, the we relocate --- control almost certainly\n+\t doesn't belong in the displaced copy.  Otherwise, we assume\n+\t the instruction has put control where it belongs, and leave\n+\t it unrelocated.  Goodness help us if there are PC-relative\n+\t system calls.  */\n       if (i386_syscall_p (insn, &insn_len)\n-          && orig_eip != to + (insn - insn_start) + insn_len\n+\t  && orig_eip != to + (insn - insn_start) + insn_len\n \t  /* GDB can get control back after the insn after the syscall.\n \t     Presumably this is a kernel bug.\n \t     i386_displaced_step_copy_insn ensures its a nop,\n \t     we add one to the length for it.  */\n \t  && orig_eip != to + (insn - insn_start) + insn_len + 1)\n \tdisplaced_debug_printf (\"syscall changed %%eip; not relocating\");\n       else\n-        {\n-          ULONGEST eip = (orig_eip - insn_offset) & 0xffffffffUL;\n+\t{\n+\t  ULONGEST eip = (orig_eip - insn_offset) & 0xffffffffUL;\n \n \t  /* If we just stepped over a breakpoint insn, we don't backup\n \t     the pc on purpose; this is to match behaviour without\n \t     stepping.  */\n \n-          regcache_cooked_write_unsigned (regs, I386_EIP_REGNUM, eip);\n+\t  regcache_cooked_write_unsigned (regs, I386_EIP_REGNUM, eip);\n \n \t  displaced_debug_printf (\"relocated %%eip from %s to %s\",\n \t\t\t\t  paddress (gdbarch, orig_eip),\n \t\t\t\t  paddress (gdbarch, eip));\n-        }\n+\t}\n     }\n \n   /* If the instruction was PUSHFL, then the TF bit will be set in the\n@@ -1126,7 +1126,7 @@ i386_follow_jump (struct gdbarch *gdbarch, CORE_ADDR pc)\n \t  delta = read_memory_integer (pc + 2, 2, byte_order);\n \n \t  /* Include the size of the jmp instruction (including the\n-             0x66 prefix).  */\n+\t     0x66 prefix).  */\n \t  delta += 4;\n \t}\n       else\n@@ -1160,8 +1160,8 @@ i386_analyze_struct_return (CORE_ADDR pc, CORE_ADDR current_pc,\n {\n   /* Functions that return a structure or union start with:\n \n-        popl %eax             0x58\n-        xchgl %eax, (%esp)    0x87 0x04 0x24\n+\tpopl %eax             0x58\n+\txchgl %eax, (%esp)    0x87 0x04 0x24\n      or xchgl %eax, 0(%esp)   0x87 0x44 0x24 0x00\n \n      (the System V compiler puts out the second `xchg' instruction,\n@@ -1211,13 +1211,13 @@ i386_skip_probe (CORE_ADDR pc)\n {\n   /* A function may start with\n \n-        pushl constant\n-        call _probe\n+\tpushl constant\n+\tcall _probe\n \taddl $4, %esp\n \t   \n      followed by\n \n-        pushl %ebp\n+\tpushl %ebp\n \n      etc.  */\n   gdb_byte buf[8];\n@@ -1846,13 +1846,13 @@ i386_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n       struct compunit_symtab *cust = find_pc_compunit_symtab (func_addr);\n \n       /* LLVM backend (Clang/Flang) always emits a line note before the\n-         prologue and another one after.  We trust clang to emit usable\n-         line notes.  */\n+\t prologue and another one after.  We trust clang to emit usable\n+\t line notes.  */\n       if (post_prologue_pc\n \t  && (cust != NULL\n \t      && COMPUNIT_PRODUCER (cust) != NULL\n \t      && producer_is_llvm (COMPUNIT_PRODUCER (cust))))\n-        return std::max (start_pc, post_prologue_pc);\n+\treturn std::max (start_pc, post_prologue_pc);\n     }\n  \n   cache.locals = -1;\n@@ -1866,10 +1866,10 @@ i386_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n      to get the address of the global offset table (GOT) into register\n      %ebx:\n \n-        call\t0x0\n+\tcall\t0x0\n \tpopl    %ebx\n-        movl    %ebx,x(%ebp)    (optional)\n-        addl    y,%ebx\n+\tmovl    %ebx,x(%ebp)    (optional)\n+\taddl    y,%ebx\n \n      This code is with the rest of the prologue (at the end of the\n      function), so we have to skip it to get to the first real\n@@ -1901,7 +1901,7 @@ i386_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n \t  else\t\t\t/* Unexpected instruction.  */\n \t    delta = 0;\n \n-          if (target_read_code (pc + delta, &op, 1))\n+\t  if (target_read_code (pc + delta, &op, 1))\n \t    return pc;\n \t}\n \n@@ -2872,8 +2872,8 @@ i386_store_return_value (struct gdbarch *gdbarch, struct type *type,\n \t}\n \n       /* Returning floating-point values is a bit tricky.  Apart from\n-         storing the return value in %st(0), we have to simulate the\n-         state of the FPU at function return point.  */\n+\t storing the return value in %st(0), we have to simulate the\n+\t state of the FPU at function return point.  */\n \n       /* Convert the value found in VALBUF to the extended\n \t floating-point format used by the FPU.  This is probably\n@@ -2883,16 +2883,16 @@ i386_store_return_value (struct gdbarch *gdbarch, struct type *type,\n       regcache->raw_write (I386_ST0_REGNUM, buf);\n \n       /* Set the top of the floating-point register stack to 7.  The\n-         actual value doesn't really matter, but 7 is what a normal\n-         function return would end up with if the program started out\n-         with a freshly initialized FPU.  */\n+\t actual value doesn't really matter, but 7 is what a normal\n+\t function return would end up with if the program started out\n+\t with a freshly initialized FPU.  */\n       regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);\n       fstat |= (7 << 11);\n       regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM (tdep), fstat);\n \n       /* Mark %st(1) through %st(7) as empty.  Since we set the top of\n-         the floating-point register stack to 7, the appropriate value\n-         for the tag word is 0x3fff.  */\n+\t the floating-point register stack to 7, the appropriate value\n+\t for the tag word is 0x3fff.  */\n       regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM (tdep), 0x3fff);\n     }\n   else\n@@ -2941,8 +2941,8 @@ i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n   int len = TYPE_LENGTH (type);\n \n   gdb_assert (code == TYPE_CODE_STRUCT\n-              || code == TYPE_CODE_UNION\n-              || code == TYPE_CODE_ARRAY);\n+\t      || code == TYPE_CODE_UNION\n+\t      || code == TYPE_CODE_ARRAY);\n \n   if (struct_convention == pcc_struct_convention\n       || (struct_convention == default_struct_convention\n@@ -2996,10 +2996,10 @@ i386_return_value (struct gdbarch *gdbarch, struct value *function,\n \t value just after the function has returned.  */\n \n       /* Note that the ABI doesn't mention functions returning arrays,\n-         which is something possible in certain languages such as Ada.\n-         In this case, the value is returned as if it was wrapped in\n-         a record, so the convention applied to records also applies\n-         to arrays.  */\n+\t which is something possible in certain languages such as Ada.\n+\t In this case, the value is returned as if it was wrapped in\n+\t a record, so the convention applied to records also applies\n+\t to arrays.  */\n \n       if (readbuf)\n \t{\n@@ -3158,14 +3158,14 @@ i386_ymm_type (struct gdbarch *gdbarch)\n #if 0\n       union __gdb_builtin_type_vec256i\n       {\n-        int128_t v2_int128[2];\n-        int64_t v4_int64[4];\n-        int32_t v8_int32[8];\n-        int16_t v16_int16[16];\n-        int8_t v32_int8[32];\n-        double v4_double[4];\n-        float v8_float[8];\n-        bfloat16_t v16_bfloat16[16];\n+\tint128_t v2_int128[2];\n+\tint64_t v4_int64[4];\n+\tint32_t v8_int32[8];\n+\tint16_t v16_int16[16];\n+\tint8_t v32_int8[32];\n+\tdouble v4_double[4];\n+\tfloat v8_float[8];\n+\tbfloat16_t v16_bfloat16[16];\n       };\n #endif\n \n@@ -3212,10 +3212,10 @@ i386_mmx_type (struct gdbarch *gdbarch)\n #if 0\n       union __gdb_builtin_type_vec64i\n       {\n-        int64_t uint64;\n-        int32_t v2_int32[2];\n-        int16_t v4_int16[4];\n-        int8_t v8_int8[8];\n+\tint64_t uint64;\n+\tint32_t v2_int32[2];\n+\tint16_t v4_int16[4];\n+\tint8_t v8_int8[8];\n       };\n #endif\n \n@@ -4789,23 +4789,23 @@ i386_record_lea_modrm_addr (struct i386_record_s *irp, uint64_t *addr)\n \n       offset64 = 0;\n       if (base != 0xff)\n-        {\n+\t{\n \t  if (base == 4 && irp->popl_esp_hack)\n \t    *addr += irp->popl_esp_hack;\n \t  regcache_raw_read_unsigned (irp->regcache, irp->regmap[base],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t}\n       if (irp->aflag == 2)\n-        {\n+\t{\n \t  *addr += offset64;\n-        }\n+\t}\n       else\n-        *addr = (uint32_t) (offset64 + *addr);\n+\t*addr = (uint32_t) (offset64 + *addr);\n \n       if (havesib && (index != 4 || scale != 0))\n \t{\n \t  regcache_raw_read_unsigned (irp->regcache, irp->regmap[index],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  if (irp->aflag == 2)\n \t    *addr += offset64 << scale;\n \t  else\n@@ -4854,65 +4854,65 @@ i386_record_lea_modrm_addr (struct i386_record_s *irp, uint64_t *addr)\n \tcase 0:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBX_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_RESI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 1:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBX_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REDI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 2:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBP_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_RESI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 3:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBP_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REDI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 4:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_RESI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 5:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REDI_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 6:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBP_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \tcase 7:\n \t  regcache_raw_read_unsigned (irp->regcache,\n \t\t\t\t      irp->regmap[X86_RECORD_REBX_REGNUM],\n-                                      &offset64);\n+\t\t\t\t      &offset64);\n \t  *addr = (uint32_t) (*addr + offset64);\n \t  break;\n \t}\n@@ -4936,14 +4936,14 @@ i386_record_lea_modrm (struct i386_record_s *irp)\n   if (irp->override >= 0)\n     {\n       if (record_full_memory_query)\n-        {\n-          if (yquery (_(\"\\\n+\t{\n+\t  if (yquery (_(\"\\\n Process record ignores the memory change of instruction at address %s\\n\\\n because it can't get the value of the segment register.\\n\\\n Do you want to stop the program?\"),\n-                      paddress (gdbarch, irp->orig_addr)))\n+\t\t      paddress (gdbarch, irp->orig_addr)))\n \t    return -1;\n-        }\n+\t}\n \n       return 0;\n     }\n@@ -4988,8 +4988,8 @@ i386_record_push (struct i386_record_s *irp, int size)\n    wrong, 0 otherwise.  */\n \n static int i386_record_floats (struct gdbarch *gdbarch,\n-                               struct i386_record_s *ir,\n-                               uint32_t iregnum)\n+\t\t\t       struct i386_record_s *ir,\n+\t\t\t       uint32_t iregnum)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n   int i;\n@@ -5002,32 +5002,32 @@ static int i386_record_floats (struct gdbarch *gdbarch,\n   if (I386_SAVE_FPU_REGS == iregnum)\n     {\n       for (i = I387_ST0_REGNUM (tdep); i <= I387_ST0_REGNUM (tdep) + 7; i++)\n-        {\n-          if (record_full_arch_list_add_reg (ir->regcache, i))\n-            return -1;\n-        }\n+\t{\n+\t  if (record_full_arch_list_add_reg (ir->regcache, i))\n+\t    return -1;\n+\t}\n     }\n   else if (I386_SAVE_FPU_ENV == iregnum)\n     {\n       for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)\n \t      {\n \t      if (record_full_arch_list_add_reg (ir->regcache, i))\n-\t        return -1;\n+\t\treturn -1;\n \t      }\n     }\n   else if (I386_SAVE_FPU_ENV_REG_STACK == iregnum)\n     {\n       for (i = I387_ST0_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)\n       {\n-        if (record_full_arch_list_add_reg (ir->regcache, i))\n-          return -1;\n+\tif (record_full_arch_list_add_reg (ir->regcache, i))\n+\t  return -1;\n       }\n     }\n   else if ((iregnum >= I387_ST0_REGNUM (tdep)) &&\n-           (iregnum <= I387_FOP_REGNUM (tdep)))\n+\t   (iregnum <= I387_FOP_REGNUM (tdep)))\n     {\n       if (record_full_arch_list_add_reg (ir->regcache,iregnum))\n-        return -1;\n+\treturn -1;\n     }\n   else\n     {\n@@ -5039,7 +5039,7 @@ static int i386_record_floats (struct gdbarch *gdbarch,\n     for (i = I387_FCTRL_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)\n       {\n       if (record_full_arch_list_add_reg (ir->regcache, i))\n-        return -1;\n+\treturn -1;\n       }\n     }\n   return 0;\n@@ -5081,7 +5081,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n   if (record_debug > 1)\n     fprintf_unfiltered (gdb_stdlog, \"Process record: i386_process_record \"\n-\t\t\t            \"addr = %s\\n\",\n+\t\t\t\t    \"addr = %s\\n\",\n \t\t\tpaddress (gdbarch, ir.addr));\n \n   /* prefixes */\n@@ -5125,33 +5125,33 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \tcase ADDR_PREFIX_OPCODE:\n \t  prefixes |= PREFIX_ADDR;\n \t  break;\n-        case 0x40:\t/* i386 inc %eax */\n-        case 0x41:\t/* i386 inc %ecx */\n-        case 0x42:\t/* i386 inc %edx */\n-        case 0x43:\t/* i386 inc %ebx */\n-        case 0x44:\t/* i386 inc %esp */\n-        case 0x45:\t/* i386 inc %ebp */\n-        case 0x46:\t/* i386 inc %esi */\n-        case 0x47:\t/* i386 inc %edi */\n-        case 0x48:\t/* i386 dec %eax */\n-        case 0x49:\t/* i386 dec %ecx */\n-        case 0x4a:\t/* i386 dec %edx */\n-        case 0x4b:\t/* i386 dec %ebx */\n-        case 0x4c:\t/* i386 dec %esp */\n-        case 0x4d:\t/* i386 dec %ebp */\n-        case 0x4e:\t/* i386 dec %esi */\n-        case 0x4f:\t/* i386 dec %edi */\n-          if (ir.regmap[X86_RECORD_R8_REGNUM])\t/* 64 bit target */\n-            {\n-               /* REX */\n-               rex_w = (opcode8 >> 3) & 1;\n-               rex_r = (opcode8 & 0x4) << 1;\n-               ir.rex_x = (opcode8 & 0x2) << 2;\n-               ir.rex_b = (opcode8 & 0x1) << 3;\n-            }\n+\tcase 0x40:\t/* i386 inc %eax */\n+\tcase 0x41:\t/* i386 inc %ecx */\n+\tcase 0x42:\t/* i386 inc %edx */\n+\tcase 0x43:\t/* i386 inc %ebx */\n+\tcase 0x44:\t/* i386 inc %esp */\n+\tcase 0x45:\t/* i386 inc %ebp */\n+\tcase 0x46:\t/* i386 inc %esi */\n+\tcase 0x47:\t/* i386 inc %edi */\n+\tcase 0x48:\t/* i386 dec %eax */\n+\tcase 0x49:\t/* i386 dec %ecx */\n+\tcase 0x4a:\t/* i386 dec %edx */\n+\tcase 0x4b:\t/* i386 dec %ebx */\n+\tcase 0x4c:\t/* i386 dec %esp */\n+\tcase 0x4d:\t/* i386 dec %ebp */\n+\tcase 0x4e:\t/* i386 dec %esi */\n+\tcase 0x4f:\t/* i386 dec %edi */\n+\t  if (ir.regmap[X86_RECORD_R8_REGNUM])\t/* 64 bit target */\n+\t    {\n+\t       /* REX */\n+\t       rex_w = (opcode8 >> 3) & 1;\n+\t       rex_r = (opcode8 & 0x4) << 1;\n+\t       ir.rex_x = (opcode8 & 0x2) << 2;\n+\t       ir.rex_b = (opcode8 & 0x1) << 3;\n+\t    }\n \t  else\t\t\t\t\t/* 32 bit target */\n \t    goto out_prefixes;\n-          break;\n+\t  break;\n \tdefault:\n \t  goto out_prefixes;\n \t  break;\n@@ -5165,7 +5165,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n   else\n     {\n       if (prefixes & PREFIX_DATA)\n-        ir.dflag ^= 1;\n+\tir.dflag ^= 1;\n     }\n   if (prefixes & PREFIX_ADDR)\n     ir.aflag ^= 1;\n@@ -5252,7 +5252,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t\t}\n \t      else\n \t\t{\n-                  ir.rm |= ir.rex_b;\n+\t\t  ir.rm |= ir.rex_b;\n \t\t  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \t\t    ir.rm &= 0x3;\n \t\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);\n@@ -5261,7 +5261,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t    case 1:    /* OP Gv, Ev */\n \t      if (i386_record_modrm (&ir))\n \t\treturn -1;\n-              ir.reg |= rex_r;\n+\t      ir.reg |= rex_r;\n \t      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \t\tir.reg &= 0x3;\n \t      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);\n@@ -5290,10 +5290,10 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n \t  if (ir.mod != 3)\n \t    {\n-              if (opcode == 0x83)\n-                ir.rip_offset = 1;\n-              else\n-                ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n+\t      if (opcode == 0x83)\n+\t\tir.rip_offset = 1;\n+\t      else\n+\t\tir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n \t      if (i386_record_lea_modrm (&ir))\n \t\treturn -1;\n \t    }\n@@ -5335,7 +5335,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \treturn -1;\n \n       if (ir.mod != 3 && ir.reg == 0)\n-        ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n+\tir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n \n       switch (ir.reg)\n \t{\n@@ -5351,7 +5351,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t    }\n \t  else\n \t    {\n-              ir.rm |= ir.rex_b;\n+\t      ir.rm |= ir.rex_b;\n \t      if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \t\tir.rm &= 0x3;\n \t      I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm);\n@@ -5390,9 +5390,9 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t{\n \tcase 0:    /* inc */\n \tcase 1:    /* dec */\n-          if ((opcode & 1) == 0)\n+\t  if ((opcode & 1) == 0)\n \t    ir.ot = OT_BYTE;\n-          else\n+\t  else\n \t    ir.ot = ir.dflag + OT_WORD;\n \t  if (ir.mod != 3)\n \t    {\n@@ -5409,8 +5409,8 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t  break;\n \tcase 2:    /* call */\n-          if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-            ir.dflag = 2;\n+\t  if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n+\t    ir.dflag = 2;\n \t  if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n \t    return -1;\n \t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n@@ -5426,8 +5426,8 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t  break;\n \tcase 6:    /* push */\n-          if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-            ir.dflag = 2;\n+\t  if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n+\t    ir.dflag = 2;\n \t  if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n \t    return -1;\n \t  break;\n@@ -5462,9 +5462,9 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (opcode == 0x69)\n-        ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n+\tir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n       else if (opcode == 0x6b)\n-        ir.rip_offset = 1;\n+\tir.rip_offset = 1;\n       ir.reg |= rex_r;\n       if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \tir.reg &= 0x3;\n@@ -5511,7 +5511,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \treturn -1;\n       if (ir.mod == 3)\n \t{\n-          ir.reg |= rex_r;\n+\t  ir.reg |= rex_r;\n \t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);\n \t  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \t    ir.reg &= 0x3;\n@@ -5575,7 +5575,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n     case 0x68:\n     case 0x6a:\n       if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-        ir.dflag = 2;\n+\tir.dflag = 2;\n       if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n \treturn -1;\n       break;\n@@ -5585,7 +5585,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n     case 0x16:    /* push ss */\n     case 0x1e:    /* push ds */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5596,7 +5596,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n     case 0x0fa0:    /* push fs */\n     case 0x0fa8:    /* push gs */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 2;\n \t  goto no_support;\n \t}\n@@ -5606,7 +5606,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case 0x60:    /* pusha */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5628,7 +5628,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case 0x61:    /* popa */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5642,14 +5642,14 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n \tir.ot = ir.dflag ? OT_QUAD : OT_WORD;\n       else\n-        ir.ot = ir.dflag + OT_WORD;\n+\tir.ot = ir.dflag + OT_WORD;\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (ir.mod == 3)\n \tI386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n       else\n \t{\n-          ir.popl_esp_hack = 1 << ir.ot;\n+\t  ir.popl_esp_hack = 1 << ir.ot;\n \t  if (i386_record_lea_modrm (&ir))\n \t    return -1;\n \t}\n@@ -5659,7 +5659,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n     case 0xc8:    /* enter */\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REBP_REGNUM);\n       if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-        ir.dflag = 2;\n+\tir.dflag = 2;\n       if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n \treturn -1;\n       break;\n@@ -5671,7 +5671,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case 0x07:    /* pop es */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5682,7 +5682,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case 0x17:    /* pop ss */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5693,7 +5693,7 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case 0x1f:    /* pop ds */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -5728,14 +5728,14 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n \n       if (ir.mod != 3)\n \t{\n-          if (opcode == 0xc6 || opcode == 0xc7)\n+\t  if (opcode == 0xc6 || opcode == 0xc7)\n \t    ir.rip_offset = (ir.ot > OT_LONG) ? 4 : (1 << ir.ot);\n \t  if (i386_record_lea_modrm (&ir))\n \t    return -1;\n \t}\n       else\n \t{\n-          if (opcode == 0xc6 || opcode == 0xc7)\n+\t  if (opcode == 0xc6 || opcode == 0xc7)\n \t    ir.rm |= ir.rex_b;\n \t  if (ir.ot == OT_BYTE && !ir.regmap[X86_RECORD_R8_REGNUM])\n \t    ir.rm &= 0x3;\n@@ -5842,47 +5842,47 @@ i386_process_record (struct gdbarch *gdbarch, struct regcache *regcache,\n     case 0xa2:    /* mov EAX */\n     case 0xa3:\n       if (ir.override >= 0)\n-        {\n-          if (record_full_memory_query)\n-            {\n-              if (yquery (_(\"\\\n+\t{\n+\t  if (record_full_memory_query)\n+\t    {\n+\t      if (yquery (_(\"\\\n Process record ignores the memory change of instruction at address %s\\n\\\n because it can't get the value of the segment register.\\n\\\n Do you want to stop the program?\"),\n-                          paddress (gdbarch, ir.orig_addr)))\n-                return -1;\n-            }\n+\t\t\t  paddress (gdbarch, ir.orig_addr)))\n+\t\treturn -1;\n+\t    }\n \t}\n       else\n \t{\n-          if ((opcode & 1) == 0)\n+\t  if ((opcode & 1) == 0)\n \t    ir.ot = OT_BYTE;\n \t  else\n \t    ir.ot = ir.dflag + OT_WORD;\n \t  if (ir.aflag == 2)\n \t    {\n-              if (record_read_memory (gdbarch, ir.addr, buf, 8))\n+\t      if (record_read_memory (gdbarch, ir.addr, buf, 8))\n \t\treturn -1;\n \t      ir.addr += 8;\n \t      addr = extract_unsigned_integer (buf, 8, byte_order);\n \t    }\n-          else if (ir.aflag)\n+\t  else if (ir.aflag)\n \t    {\n-              if (record_read_memory (gdbarch, ir.addr, buf, 4))\n+\t      if (record_read_memory (gdbarch, ir.addr, buf, 4))\n \t\treturn -1;\n \t      ir.addr += 4;\n-              addr = extract_unsigned_integer (buf, 4, byte_order);\n+\t      addr = extract_unsigned_integer (buf, 4, byte_order);\n \t    }\n-          else\n+\t  else\n \t    {\n-              if (record_read_memory (gdbarch, ir.addr, buf, 2))\n+\t      if (record_read_memory (gdbarch, ir.addr, buf, 2))\n \t\treturn -1;\n \t      ir.addr += 2;\n-              addr = extract_unsigned_integer (buf, 2, byte_order);\n+\t      addr = extract_unsigned_integer (buf, 2, byte_order);\n \t    }\n \t  if (record_full_arch_list_add_mem (addr, 1 << ir.ot))\n \t    return -1;\n-        }\n+\t}\n       break;\n \n     case 0xb0:    /* mov R, Ib */\n@@ -5949,7 +5949,7 @@ Do you want to stop the program?\"),\n     case 0xc4:    /* les Gv */\n     case 0xc5:    /* lds Gv */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n+\t{\n \t  ir.addr -= 1;\n \t  goto no_support;\n \t}\n@@ -6057,21 +6057,21 @@ Do you want to stop the program?\"),\n \t  switch (ir.reg)\n \t    {\n \t    case 0x02:\n-            case 0x12:\n-            case 0x22:\n-            case 0x32:\n+\t    case 0x12:\n+\t    case 0x22:\n+\t    case 0x32:\n \t      /* For fcom, ficom nothing to do.  */\n-              break;\n+\t      break;\n \t    case 0x03:\n-            case 0x13:\n-            case 0x23:\n-            case 0x33:\n+\t    case 0x13:\n+\t    case 0x23:\n+\t    case 0x33:\n \t      /* For fcomp, ficomp pop FPU stack, store all.  */\n-              if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n-                return -1;\n-              break;\n-            case 0x00:\n-            case 0x01:\n+\t      if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n+\t\treturn -1;\n+\t      break;\n+\t    case 0x00:\n+\t    case 0x01:\n \t    case 0x04:\n \t    case 0x05:\n \t    case 0x06:\n@@ -6094,11 +6094,11 @@ Do you want to stop the program?\"),\n \t    case 0x35:\n \t    case 0x36:\n \t    case 0x37:\n-              /* For fadd, fmul, fsub, fsubr, fdiv, fdivr, fiadd, fimul,\n-                 fisub, fisubr, fidiv, fidivr, modR/M.reg is an extension\n-                 of code,  always affects st(0) register.  */\n-              if (i386_record_floats (gdbarch, &ir, I387_ST0_REGNUM (tdep)))\n-                return -1;\n+\t      /* For fadd, fmul, fsub, fsubr, fdiv, fdivr, fiadd, fimul,\n+\t\t fisub, fisubr, fidiv, fidivr, modR/M.reg is an extension\n+\t\t of code,  always affects st(0) register.  */\n+\t      if (i386_record_floats (gdbarch, &ir, I387_ST0_REGNUM (tdep)))\n+\t\treturn -1;\n \t      break;\n \t    case 0x08:\n \t    case 0x0a:\n@@ -6107,7 +6107,7 @@ Do you want to stop the program?\"),\n \t    case 0x19:\n \t    case 0x1a:\n \t    case 0x1b:\n-            case 0x1d:\n+\t    case 0x1d:\n \t    case 0x28:\n \t    case 0x29:\n \t    case 0x2a:\n@@ -6116,8 +6116,8 @@ Do you want to stop the program?\"),\n \t    case 0x39:\n \t    case 0x3a:\n \t    case 0x3b:\n-            case 0x3c:\n-            case 0x3d:\n+\t    case 0x3c:\n+\t    case 0x3d:\n \t      switch (ir.reg & 7)\n \t\t{\n \t\tcase 0:\n@@ -6200,21 +6200,21 @@ Do you want to stop the program?\"),\n \t\t}\n \t      break;\n \t    case 0x0c:\n-              /* Insn fldenv.  */\n-              if (i386_record_floats (gdbarch, &ir,\n-                                      I386_SAVE_FPU_ENV_REG_STACK))\n-                return -1;\n-              break;\n+\t      /* Insn fldenv.  */\n+\t      if (i386_record_floats (gdbarch, &ir,\n+\t\t\t\t      I386_SAVE_FPU_ENV_REG_STACK))\n+\t\treturn -1;\n+\t      break;\n \t    case 0x0d:\n-              /* Insn fldcw.  */\n-              if (i386_record_floats (gdbarch, &ir, I387_FCTRL_REGNUM (tdep)))\n-                return -1;\n-              break;\n+\t      /* Insn fldcw.  */\n+\t      if (i386_record_floats (gdbarch, &ir, I387_FCTRL_REGNUM (tdep)))\n+\t\treturn -1;\n+\t      break;\n \t    case 0x2c:\n-              /* Insn frstor.  */\n-              if (i386_record_floats (gdbarch, &ir,\n-                                      I386_SAVE_FPU_ENV_REG_STACK))\n-                return -1;\n+\t      /* Insn frstor.  */\n+\t      if (i386_record_floats (gdbarch, &ir,\n+\t\t\t\t      I386_SAVE_FPU_ENV_REG_STACK))\n+\t\treturn -1;\n \t      break;\n \t    case 0x0e:\n \t      if (ir.dflag)\n@@ -6232,9 +6232,9 @@ Do you want to stop the program?\"),\n \t    case 0x2f:\n \t      if (record_full_arch_list_add_mem (addr64, 2))\n \t\treturn -1;\n-              /* Insn fstp, fbstp.  */\n-              if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n-                return -1;\n+\t      /* Insn fstp, fbstp.  */\n+\t      if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n+\t\treturn -1;\n \t      break;\n \t    case 0x1f:\n \t    case 0x3e:\n@@ -6277,7 +6277,7 @@ Do you want to stop the program?\"),\n \t}\n       /* Opcode is an extension of modR/M byte.  */\n       else\n-        {\n+\t{\n \t  switch (opcode)\n \t    {\n \t    case 0xd8:\n@@ -6293,7 +6293,7 @@ Do you want to stop the program?\"),\n \t\t\t\t\t      I386_SAVE_FPU_REGS))\n \t\t\treturn -1;\n \t\t    }\n-                  else\n+\t\t  else\n \t\t    {\n \t\t      if (i386_record_floats (gdbarch, &ir,\n \t\t\t\t\t      I387_ST0_REGNUM (tdep)))\n@@ -6309,8 +6309,8 @@ Do you want to stop the program?\"),\n \t\t\t}\n \t\t    }\n \t\t}\n-              else\n-                {\n+\t      else\n+\t\t{\n \t\t  switch (ir.modrm)\n \t\t    {\n \t\t    case 0xe0:\n@@ -6355,15 +6355,15 @@ Do you want to stop the program?\"),\n \t\t      break;\n \t\t    }\n \t\t}\n-              break;\n-            case 0xda:\n-              if (0xe9 == ir.modrm)\n-                {\n+\t      break;\n+\t    case 0xda:\n+\t      if (0xe9 == ir.modrm)\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n \t\t    return -1;\n-                }\n-              else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))\n-                {\n+\t\t}\n+\t      else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir,\n \t\t\t\t\t  I387_ST0_REGNUM (tdep)))\n \t\t    return -1;\n@@ -6381,16 +6381,16 @@ Do you want to stop the program?\"),\n \t\t\t\t\t      ((ir.modrm & 0x0f) - 0x08)))\n \t\t\treturn -1;\n \t\t    }\n-                }\n-              break;\n-            case 0xdb:\n-              if (0xe3 == ir.modrm)\n-                {\n+\t\t}\n+\t      break;\n+\t    case 0xdb:\n+\t      if (0xe3 == ir.modrm)\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_ENV))\n \t\t    return -1;\n-                }\n-              else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))\n-                {\n+\t\t}\n+\t      else if ((0x0c == ir.modrm >> 4) || (0x0d == ir.modrm >> 4))\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir,\n \t\t\t\t\t  I387_ST0_REGNUM (tdep)))\n \t\t    return -1;\n@@ -6408,13 +6408,13 @@ Do you want to stop the program?\"),\n \t\t\t\t\t      ((ir.modrm & 0x0f) - 0x08)))\n \t\t\treturn -1;\n \t\t    }\n-                }\n-              break;\n-            case 0xdc:\n-              if ((0x0c == ir.modrm >> 4)\n+\t\t}\n+\t      break;\n+\t    case 0xdc:\n+\t      if ((0x0c == ir.modrm >> 4)\n \t\t  || (0x0d == ir.modrm >> 4)\n \t\t  || (0x0f == ir.modrm >> 4))\n-                {\n+\t\t{\n \t\t  if ((ir.modrm & 0x0f) <= 7)\n \t\t    {\n \t\t      if (i386_record_floats (gdbarch, &ir,\n@@ -6429,55 +6429,55 @@ Do you want to stop the program?\"),\n \t\t\t\t\t      ((ir.modrm & 0x0f) - 0x08)))\n \t\t\treturn -1;\n \t\t    }\n-                }\n+\t\t}\n \t      break;\n-            case 0xdd:\n-              if (0x0c == ir.modrm >> 4)\n-                {\n-                  if (i386_record_floats (gdbarch, &ir,\n-                                          I387_FTAG_REGNUM (tdep)))\n-                    return -1;\n-                }\n-              else if ((0x0d == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))\n-                {\n-                  if ((ir.modrm & 0x0f) <= 7)\n-                    {\n+\t    case 0xdd:\n+\t      if (0x0c == ir.modrm >> 4)\n+\t\t{\n+\t\t  if (i386_record_floats (gdbarch, &ir,\n+\t\t\t\t\t  I387_FTAG_REGNUM (tdep)))\n+\t\t    return -1;\n+\t\t}\n+\t      else if ((0x0d == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))\n+\t\t{\n+\t\t  if ((ir.modrm & 0x0f) <= 7)\n+\t\t    {\n \t\t      if (i386_record_floats (gdbarch, &ir,\n \t\t\t\t\t      I387_ST0_REGNUM (tdep) +\n \t\t\t\t\t      (ir.modrm & 0x0f)))\n \t\t\treturn -1;\n-                    }\n-                  else\n-                    {\n-                      if (i386_record_floats (gdbarch, &ir,\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (i386_record_floats (gdbarch, &ir,\n \t\t\t\t\t      I386_SAVE_FPU_REGS))\n-                        return -1;\n-                    }\n-                }\n-              break;\n-            case 0xde:\n-              if ((0x0c == ir.modrm >> 4)\n+\t\t\treturn -1;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\t    case 0xde:\n+\t      if ((0x0c == ir.modrm >> 4)\n \t\t  || (0x0e == ir.modrm >> 4)\n \t\t  || (0x0f == ir.modrm >> 4)\n \t\t  || (0xd9 == ir.modrm))\n-                {\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n \t\t    return -1;\n-                }\n-              break;\n-            case 0xdf:\n-              if (0xe0 == ir.modrm)\n-                {\n+\t\t}\n+\t      break;\n+\t    case 0xdf:\n+\t      if (0xe0 == ir.modrm)\n+\t\t{\n \t\t  if (record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t\t     I386_EAX_REGNUM))\n \t\t    return -1;\n-                }\n-              else if ((0x0f == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))\n-                {\n+\t\t}\n+\t      else if ((0x0f == ir.modrm >> 4) || (0x0e == ir.modrm >> 4))\n+\t\t{\n \t\t  if (i386_record_floats (gdbarch, &ir, I386_SAVE_FPU_REGS))\n \t\t    return -1;\n-                }\n-              break;\n+\t\t}\n+\t      break;\n \t    }\n \t}\n       break;\n@@ -6489,51 +6489,51 @@ Do you want to stop the program?\"),\n     case 0x6c:    /* insS */\n     case 0x6d:\n       regcache_raw_read_unsigned (ir.regcache,\n-                                  ir.regmap[X86_RECORD_RECX_REGNUM],\n-                                  &addr);\n+\t\t\t\t  ir.regmap[X86_RECORD_RECX_REGNUM],\n+\t\t\t\t  &addr);\n       if (addr)\n-        {\n-          ULONGEST es, ds;\n+\t{\n+\t  ULONGEST es, ds;\n \n-          if ((opcode & 1) == 0)\n+\t  if ((opcode & 1) == 0)\n \t    ir.ot = OT_BYTE;\n-          else\n+\t  else\n \t    ir.ot = ir.dflag + OT_WORD;\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[X86_RECORD_REDI_REGNUM],\n-                                      &addr);\n-\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[X86_RECORD_ES_REGNUM],\n-                                      &es);\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[X86_RECORD_DS_REGNUM],\n-                                      &ds);\n-          if (ir.aflag && (es != ds))\n-            {\n-              /* addr += ((uint32_t) read_register (I386_ES_REGNUM)) << 4; */\n-              if (record_full_memory_query)\n-                {\n-                  if (yquery (_(\"\\\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[X86_RECORD_REDI_REGNUM],\n+\t\t\t\t      &addr);\n+\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[X86_RECORD_ES_REGNUM],\n+\t\t\t\t      &es);\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[X86_RECORD_DS_REGNUM],\n+\t\t\t\t      &ds);\n+\t  if (ir.aflag && (es != ds))\n+\t    {\n+\t      /* addr += ((uint32_t) read_register (I386_ES_REGNUM)) << 4; */\n+\t      if (record_full_memory_query)\n+\t\t{\n+\t\t  if (yquery (_(\"\\\n Process record ignores the memory change of instruction at address %s\\n\\\n because it can't get the value of the segment register.\\n\\\n Do you want to stop the program?\"),\n-                              paddress (gdbarch, ir.orig_addr)))\n-                    return -1;\n-                }\n-            }\n-          else\n-            {\n-              if (record_full_arch_list_add_mem (addr, 1 << ir.ot))\n-                return -1;\n-            }\n-\n-          if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n-          if (opcode == 0xa4 || opcode == 0xa5)\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t\t\t      paddress (gdbarch, ir.orig_addr)))\n+\t\t    return -1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (record_full_arch_list_add_mem (addr, 1 << ir.ot))\n+\t\treturn -1;\n+\t    }\n+\n+\t  if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n+\t  if (opcode == 0xa4 || opcode == 0xa5)\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t}\n       break;\n \n@@ -6542,7 +6542,7 @@ Do you want to stop the program?\"),\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);\n       if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n@@ -6551,23 +6551,23 @@ Do you want to stop the program?\"),\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);\n       if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n     case 0xae:    /* scasS */\n     case 0xaf:\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REDI_REGNUM);\n       if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n     case 0x6e:    /* outsS */\n     case 0x6f:\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RESI_REGNUM);\n       if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_RECX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n@@ -6602,20 +6602,20 @@ Do you want to stop the program?\"),\n \n     case 0xe8:    /* call im */\n       if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-        ir.dflag = 2;\n+\tir.dflag = 2;\n       if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n-        return -1;\n+\treturn -1;\n       break;\n \n     case 0x9a:    /* lcall im */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          ir.addr -= 1;\n-          goto no_support;\n-        }\n+\t{\n+\t  ir.addr -= 1;\n+\t  goto no_support;\n+\t}\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_CS_REGNUM);\n       if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n-        return -1;\n+\treturn -1;\n       break;\n \n     case 0xe9:    /* jmp im */\n@@ -6676,7 +6676,7 @@ Do you want to stop the program?\"),\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (ir.mod == 3)\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rex_b ? (ir.rm | ir.rex_b)\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rex_b ? (ir.rm | ir.rex_b)\n \t\t\t\t\t    : (ir.rm & 0x3));\n       else\n \t{\n@@ -6713,9 +6713,9 @@ Do you want to stop the program?\"),\n     case 0x9c:    /* pushf */\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       if (ir.regmap[X86_RECORD_R8_REGNUM] && ir.dflag)\n-        ir.dflag = 2;\n+\tir.dflag = 2;\n       if (i386_record_push (&ir, 1 << (ir.dflag + 1)))\n-        return -1;\n+\treturn -1;\n       break;\n \n     case 0x9d:    /* popf */\n@@ -6725,10 +6725,10 @@ Do you want to stop the program?\"),\n \n     case 0x9e:    /* sahf */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          ir.addr -= 1;\n-          goto no_support;\n-        }\n+\t{\n+\t  ir.addr -= 1;\n+\t  goto no_support;\n+\t}\n       /* FALLTHROUGH */\n     case 0xf5:    /* cmc */\n     case 0xf8:    /* clc */\n@@ -6740,10 +6740,10 @@ Do you want to stop the program?\"),\n \n     case 0x9f:    /* lahf */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          ir.addr -= 1;\n-          goto no_support;\n-        }\n+\t{\n+\t  ir.addr -= 1;\n+\t  goto no_support;\n+\t}\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);\n       break;\n@@ -6761,8 +6761,8 @@ Do you want to stop the program?\"),\n \t}\n       if (ir.reg != 4)\n \t{\n-          if (ir.mod == 3)\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n+\t  if (ir.mod == 3)\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n \t  else\n \t    {\n \t      if (i386_record_lea_modrm (&ir))\n@@ -6781,34 +6781,34 @@ Do you want to stop the program?\"),\n     case 0x0fbb:    /* btc */\n       ir.ot = ir.dflag + OT_WORD;\n       if (i386_record_modrm (&ir))\n-        return -1;\n+\treturn -1;\n       if (ir.mod == 3)\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n       else\n-        {\n-          uint64_t addr64;\n-          if (i386_record_lea_modrm_addr (&ir, &addr64))\n-            return -1;\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[ir.reg | rex_r],\n-                                      &addr);\n-          switch (ir.dflag)\n-            {\n-            case 0:\n-              addr64 += ((int16_t) addr >> 4) << 4;\n-              break;\n-            case 1:\n-              addr64 += ((int32_t) addr >> 5) << 5;\n-              break;\n-            case 2:\n-              addr64 += ((int64_t) addr >> 6) << 6;\n-              break;\n-            }\n-          if (record_full_arch_list_add_mem (addr64, 1 << ir.ot))\n-            return -1;\n-          if (i386_record_lea_modrm (&ir))\n-            return -1;\n-        }\n+\t{\n+\t  uint64_t addr64;\n+\t  if (i386_record_lea_modrm_addr (&ir, &addr64))\n+\t    return -1;\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[ir.reg | rex_r],\n+\t\t\t\t      &addr);\n+\t  switch (ir.dflag)\n+\t    {\n+\t    case 0:\n+\t      addr64 += ((int16_t) addr >> 4) << 4;\n+\t      break;\n+\t    case 1:\n+\t      addr64 += ((int32_t) addr >> 5) << 5;\n+\t      break;\n+\t    case 2:\n+\t      addr64 += ((int64_t) addr >> 6) << 6;\n+\t      break;\n+\t    }\n+\t  if (record_full_arch_list_add_mem (addr64, 1 << ir.ot))\n+\t    return -1;\n+\t  if (i386_record_lea_modrm (&ir))\n+\t    return -1;\n+\t}\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n@@ -6826,10 +6826,10 @@ Do you want to stop the program?\"),\n     case 0xd4:    /* aam */\n     case 0xd5:    /* aad */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          ir.addr -= 1;\n-          goto no_support;\n-        }\n+\t{\n+\t  ir.addr -= 1;\n+\t  goto no_support;\n+\t}\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n@@ -6914,10 +6914,10 @@ Do you want to stop the program?\"),\n \n     case 0xd6:    /* salc */\n       if (ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          ir.addr -= 1;\n-          goto no_support;\n-        }\n+\t{\n+\t  ir.addr -= 1;\n+\t  goto no_support;\n+\t}\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_REAX_REGNUM);\n       I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n@@ -6952,11 +6952,11 @@ Do you want to stop the program?\"),\n     case 0x0f34:    /* sysenter */\n       {\n \tint ret;\n-        if (ir.regmap[X86_RECORD_R8_REGNUM])\n-          {\n-            ir.addr -= 2;\n-            goto no_support;\n-          }\n+\tif (ir.regmap[X86_RECORD_R8_REGNUM])\n+\t  {\n+\t    ir.addr -= 2;\n+\t    goto no_support;\n+\t  }\n \tif (tdep->i386_sysenter_record == NULL)\n \t  {\n \t    printf_unfiltered (_(\"Process record does not support \"\n@@ -6995,7 +6995,7 @@ Do you want to stop the program?\"),\n \n     case 0x0f07:    /* sysret */\n       printf_unfiltered (_(\"Process record does not support \"\n-                           \"instruction sysret.\\n\"));\n+\t\t\t   \"instruction sysret.\\n\"));\n       ir.addr -= 2;\n       goto no_support;\n       break;\n@@ -7022,7 +7022,7 @@ Do you want to stop the program?\"),\n \tcase 0:  /* sldt */\n \tcase 1:  /* str  */\n \t  if (ir.mod == 3)\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n \t  else\n \t    {\n \t      ir.ot = OT_WORD;\n@@ -7035,7 +7035,7 @@ Do you want to stop the program?\"),\n \t  break;\n \tcase 4:  /* verr */\n \tcase 5:  /* verw */\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t  break;\n \tdefault:\n \t  ir.addr -= 3;\n@@ -7062,15 +7062,15 @@ Do you want to stop the program?\"),\n \t      }\n \t    if (ir.override >= 0)\n \t      {\n-                if (record_full_memory_query)\n-                  {\n-                    if (yquery (_(\"\\\n+\t\tif (record_full_memory_query)\n+\t\t  {\n+\t\t    if (yquery (_(\"\\\n Process record ignores the memory change of instruction at address %s\\n\\\n because it can't get the value of the segment register.\\n\\\n Do you want to stop the program?\"),\n-                                paddress (gdbarch, ir.orig_addr)))\n+\t\t\t\tpaddress (gdbarch, ir.orig_addr)))\n \t\t      return -1;\n-                  }\n+\t\t  }\n \t      }\n \t    else\n \t      {\n@@ -7079,16 +7079,16 @@ Do you want to stop the program?\"),\n \t\tif (record_full_arch_list_add_mem (addr64, 2))\n \t\t  return -1;\n \t\taddr64 += 2;\n-                if (ir.regmap[X86_RECORD_R8_REGNUM])\n-                  {\n-                    if (record_full_arch_list_add_mem (addr64, 8))\n+\t\tif (ir.regmap[X86_RECORD_R8_REGNUM])\n+\t\t  {\n+\t\t    if (record_full_arch_list_add_mem (addr64, 8))\n \t\t      return -1;\n-                  }\n-                else\n-                  {\n-                    if (record_full_arch_list_add_mem (addr64, 4))\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    if (record_full_arch_list_add_mem (addr64, 4))\n \t\t      return -1;\n-                  }\n+\t\t  }\n \t      }\n \t  }\n \t  break;\n@@ -7114,15 +7114,15 @@ Do you want to stop the program?\"),\n \t      /* sidt */\n \t      if (ir.override >= 0)\n \t\t{\n-                  if (record_full_memory_query)\n-                    {\n-                      if (yquery (_(\"\\\n+\t\t  if (record_full_memory_query)\n+\t\t    {\n+\t\t      if (yquery (_(\"\\\n Process record ignores the memory change of instruction at address %s\\n\\\n because it can't get the value of the segment register.\\n\\\n Do you want to stop the program?\"),\n-                                  paddress (gdbarch, ir.orig_addr)))\n-                        return -1;\n-                    }\n+\t\t\t\t  paddress (gdbarch, ir.orig_addr)))\n+\t\t\treturn -1;\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n@@ -7133,16 +7133,16 @@ Do you want to stop the program?\"),\n \t\t  if (record_full_arch_list_add_mem (addr64, 2))\n \t\t    return -1;\n \t\t  addr64 += 2;\n-                  if (ir.regmap[X86_RECORD_R8_REGNUM])\n-                    {\n-                      if (record_full_arch_list_add_mem (addr64, 8))\n-\t\t        return -1;\n-                    }\n-                  else\n-                    {\n-                      if (record_full_arch_list_add_mem (addr64, 4))\n-\t\t        return -1;\n-                    }\n+\t\t  if (ir.regmap[X86_RECORD_R8_REGNUM])\n+\t\t    {\n+\t\t      if (record_full_arch_list_add_mem (addr64, 8))\n+\t\t\treturn -1;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      if (record_full_arch_list_add_mem (addr64, 4))\n+\t\t\treturn -1;\n+\t\t    }\n \t\t}\n \t    }\n \t  break;\n@@ -7190,13 +7190,13 @@ Do you want to stop the program?\"),\n \t  if (ir.mod == 3)\n \t    {\n \t      if (ir.rm == 0 && ir.regmap[X86_RECORD_R8_REGNUM])\n-\t        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);\n+\t\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_GS_REGNUM);\n \t      else\n-\t        {\n-\t          ir.addr -= 3;\n-\t          opcode = opcode << 8 | ir.modrm;\n-\t          goto no_support;\n-\t        }\n+\t\t{\n+\t\t  ir.addr -= 3;\n+\t\t  opcode = opcode << 8 | ir.modrm;\n+\t\t  goto no_support;\n+\t\t}\n \t    }\n \t  else\n \t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n@@ -7217,18 +7217,18 @@ Do you want to stop the program?\"),\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (ir.mod == 3 || ir.regmap[X86_RECORD_R8_REGNUM])\n-        {\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.regmap[X86_RECORD_R8_REGNUM]\n+\t{\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.regmap[X86_RECORD_R8_REGNUM]\n \t\t\t\t\t      ? (ir.reg | rex_r) : ir.rm);\n-        }\n+\t}\n       else\n-        {\n-          ir.ot = ir.dflag ? OT_LONG : OT_WORD;\n-          if (i386_record_lea_modrm (&ir))\n-            return -1;\n-        }\n+\t{\n+\t  ir.ot = ir.dflag ? OT_LONG : OT_WORD;\n+\t  if (i386_record_lea_modrm (&ir))\n+\t    return -1;\n+\t}\n       if (!ir.regmap[X86_RECORD_R8_REGNUM])\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       break;\n \n     case 0x0f02:    /* lar */\n@@ -7243,7 +7243,7 @@ Do you want to stop the program?\"),\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (ir.mod == 3 && ir.reg == 3)\n-        {\n+\t{\n \t  ir.addr -= 3;\n \t  opcode = opcode << 8 | ir.modrm;\n \t  goto no_support;\n@@ -7280,7 +7280,7 @@ Do you want to stop the program?\"),\n \t  if (opcode & 2)\n \t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t  else\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n \t  break;\n \tdefault:\n \t  ir.addr -= 3;\n@@ -7302,7 +7302,7 @@ Do you want to stop the program?\"),\n \t  goto no_support;\n \t}\n       if (opcode & 2)\n-        I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\tI386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n       else\n \tI386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n       break;\n@@ -7319,7 +7319,7 @@ Do you want to stop the program?\"),\n     case 0x0f0e:    /* 3DNow! femms */\n     case 0x0f77:    /* emms */\n       if (i386_fpc_regnum_p (gdbarch, I387_FTAG_REGNUM(tdep)))\n-        goto no_support;\n+\tgoto no_support;\n       record_full_arch_list_add_reg (ir.regcache, I387_FTAG_REGNUM(tdep));\n       break;\n \n@@ -7330,42 +7330,42 @@ Do you want to stop the program?\"),\n \treturn -1;\n       ir.addr++;\n       switch (opcode8)\n-        {\n-        case 0x0c:    /* 3DNow! pi2fw */\n-        case 0x0d:    /* 3DNow! pi2fd */\n-        case 0x1c:    /* 3DNow! pf2iw */\n-        case 0x1d:    /* 3DNow! pf2id */\n-        case 0x8a:    /* 3DNow! pfnacc */\n-        case 0x8e:    /* 3DNow! pfpnacc */\n-        case 0x90:    /* 3DNow! pfcmpge */\n-        case 0x94:    /* 3DNow! pfmin */\n-        case 0x96:    /* 3DNow! pfrcp */\n-        case 0x97:    /* 3DNow! pfrsqrt */\n-        case 0x9a:    /* 3DNow! pfsub */\n-        case 0x9e:    /* 3DNow! pfadd */\n-        case 0xa0:    /* 3DNow! pfcmpgt */\n-        case 0xa4:    /* 3DNow! pfmax */\n-        case 0xa6:    /* 3DNow! pfrcpit1 */\n-        case 0xa7:    /* 3DNow! pfrsqit1 */\n-        case 0xaa:    /* 3DNow! pfsubr */\n-        case 0xae:    /* 3DNow! pfacc */\n-        case 0xb0:    /* 3DNow! pfcmpeq */\n-        case 0xb4:    /* 3DNow! pfmul */\n-        case 0xb6:    /* 3DNow! pfrcpit2 */\n-        case 0xb7:    /* 3DNow! pmulhrw */\n-        case 0xbb:    /* 3DNow! pswapd */\n-        case 0xbf:    /* 3DNow! pavgusb */\n-          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))\n-            goto no_support_3dnow_data;\n-          record_full_arch_list_add_reg (ir.regcache, ir.reg);\n-          break;\n-\n-        default:\n+\t{\n+\tcase 0x0c:    /* 3DNow! pi2fw */\n+\tcase 0x0d:    /* 3DNow! pi2fd */\n+\tcase 0x1c:    /* 3DNow! pf2iw */\n+\tcase 0x1d:    /* 3DNow! pf2id */\n+\tcase 0x8a:    /* 3DNow! pfnacc */\n+\tcase 0x8e:    /* 3DNow! pfpnacc */\n+\tcase 0x90:    /* 3DNow! pfcmpge */\n+\tcase 0x94:    /* 3DNow! pfmin */\n+\tcase 0x96:    /* 3DNow! pfrcp */\n+\tcase 0x97:    /* 3DNow! pfrsqrt */\n+\tcase 0x9a:    /* 3DNow! pfsub */\n+\tcase 0x9e:    /* 3DNow! pfadd */\n+\tcase 0xa0:    /* 3DNow! pfcmpgt */\n+\tcase 0xa4:    /* 3DNow! pfmax */\n+\tcase 0xa6:    /* 3DNow! pfrcpit1 */\n+\tcase 0xa7:    /* 3DNow! pfrsqit1 */\n+\tcase 0xaa:    /* 3DNow! pfsubr */\n+\tcase 0xae:    /* 3DNow! pfacc */\n+\tcase 0xb0:    /* 3DNow! pfcmpeq */\n+\tcase 0xb4:    /* 3DNow! pfmul */\n+\tcase 0xb6:    /* 3DNow! pfrcpit2 */\n+\tcase 0xb7:    /* 3DNow! pmulhrw */\n+\tcase 0xbb:    /* 3DNow! pswapd */\n+\tcase 0xbf:    /* 3DNow! pavgusb */\n+\t  if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))\n+\t    goto no_support_3dnow_data;\n+\t  record_full_arch_list_add_reg (ir.regcache, ir.reg);\n+\t  break;\n+\n+\tdefault:\n no_support_3dnow_data:\n-          opcode = (opcode << 8) | opcode8;\n-          goto no_support;\n-          break;\n-        }\n+\t  opcode = (opcode << 8) | opcode8;\n+\t  goto no_support;\n+\t  break;\n+\t}\n       break;\n \n     case 0x0faa:    /* rsm */\n@@ -7384,80 +7384,80 @@ Do you want to stop the program?\"),\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       switch(ir.reg)\n-        {\n-        case 0:    /* fxsave */\n-          {\n-            uint64_t tmpu64;\n+\t{\n+\tcase 0:    /* fxsave */\n+\t  {\n+\t    uint64_t tmpu64;\n \n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \t    if (i386_record_lea_modrm_addr (&ir, &tmpu64))\n \t      return -1;\n-            if (record_full_arch_list_add_mem (tmpu64, 512))\n-              return -1;\n-          }\n-          break;\n+\t    if (record_full_arch_list_add_mem (tmpu64, 512))\n+\t      return -1;\n+\t  }\n+\t  break;\n \n-        case 1:    /* fxrstor */\n-          {\n-            int i;\n+\tcase 1:    /* fxrstor */\n+\t  {\n+\t    int i;\n \n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n \n-            for (i = I387_MM0_REGNUM (tdep);\n-                 i386_mmx_regnum_p (gdbarch, i); i++)\n-              record_full_arch_list_add_reg (ir.regcache, i);\n+\t    for (i = I387_MM0_REGNUM (tdep);\n+\t\t i386_mmx_regnum_p (gdbarch, i); i++)\n+\t      record_full_arch_list_add_reg (ir.regcache, i);\n \n-            for (i = I387_XMM0_REGNUM (tdep);\n-                 i386_xmm_regnum_p (gdbarch, i); i++)\n-              record_full_arch_list_add_reg (ir.regcache, i);\n+\t    for (i = I387_XMM0_REGNUM (tdep);\n+\t\t i386_xmm_regnum_p (gdbarch, i); i++)\n+\t      record_full_arch_list_add_reg (ir.regcache, i);\n \n-            if (i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))\n-              record_full_arch_list_add_reg (ir.regcache,\n+\t    if (i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))\n+\t      record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t     I387_MXCSR_REGNUM(tdep));\n \n-            for (i = I387_ST0_REGNUM (tdep);\n-                 i386_fp_regnum_p (gdbarch, i); i++)\n-              record_full_arch_list_add_reg (ir.regcache, i);\n-\n-            for (i = I387_FCTRL_REGNUM (tdep);\n-                 i386_fpc_regnum_p (gdbarch, i); i++)\n-              record_full_arch_list_add_reg (ir.regcache, i);\n-          }\n-          break;\n-\n-        case 2:    /* ldmxcsr */\n-          if (!i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))\n-            goto no_support;\n-          record_full_arch_list_add_reg (ir.regcache, I387_MXCSR_REGNUM(tdep));\n-          break;\n-\n-        case 3:    /* stmxcsr */\n-          ir.ot = OT_LONG;\n-          if (i386_record_lea_modrm (&ir))\n-            return -1;\n-          break;\n-\n-        case 5:    /* lfence */\n-        case 6:    /* mfence */\n-        case 7:    /* sfence clflush */\n-          break;\n-\n-        default:\n-          opcode = (opcode << 8) | ir.modrm;\n-          goto no_support;\n-          break;\n-        }\n+\t    for (i = I387_ST0_REGNUM (tdep);\n+\t\t i386_fp_regnum_p (gdbarch, i); i++)\n+\t      record_full_arch_list_add_reg (ir.regcache, i);\n+\n+\t    for (i = I387_FCTRL_REGNUM (tdep);\n+\t\t i386_fpc_regnum_p (gdbarch, i); i++)\n+\t      record_full_arch_list_add_reg (ir.regcache, i);\n+\t  }\n+\t  break;\n+\n+\tcase 2:    /* ldmxcsr */\n+\t  if (!i386_mxcsr_regnum_p (gdbarch, I387_MXCSR_REGNUM(tdep)))\n+\t    goto no_support;\n+\t  record_full_arch_list_add_reg (ir.regcache, I387_MXCSR_REGNUM(tdep));\n+\t  break;\n+\n+\tcase 3:    /* stmxcsr */\n+\t  ir.ot = OT_LONG;\n+\t  if (i386_record_lea_modrm (&ir))\n+\t    return -1;\n+\t  break;\n+\n+\tcase 5:    /* lfence */\n+\tcase 6:    /* mfence */\n+\tcase 7:    /* sfence clflush */\n+\t  break;\n+\n+\tdefault:\n+\t  opcode = (opcode << 8) | ir.modrm;\n+\t  goto no_support;\n+\t  break;\n+\t}\n       break;\n \n     case 0x0fc3:    /* movnti */\n       ir.ot = (ir.dflag == 2) ? OT_QUAD : OT_LONG;\n       if (i386_record_modrm (&ir))\n \treturn -1;\n       if (ir.mod == 3)\n-        goto no_support;\n+\tgoto no_support;\n       ir.reg |= rex_r;\n       if (i386_record_lea_modrm (&ir))\n-        return -1;\n+\treturn -1;\n       break;\n \n     /* Add prefix to opcode.  */\n@@ -7577,541 +7577,541 @@ Do you want to stop the program?\"),\n     case 0x0ffe:\n       /* Mask out PREFIX_ADDR.  */\n       switch ((prefixes & ~PREFIX_ADDR))\n-        {\n-        case PREFIX_REPNZ:\n-          opcode |= 0xf20000;\n-          break;\n-        case PREFIX_DATA:\n-          opcode |= 0x660000;\n-          break;\n-        case PREFIX_REPZ:\n-          opcode |= 0xf30000;\n-          break;\n-        }\n+\t{\n+\tcase PREFIX_REPNZ:\n+\t  opcode |= 0xf20000;\n+\t  break;\n+\tcase PREFIX_DATA:\n+\t  opcode |= 0x660000;\n+\t  break;\n+\tcase PREFIX_REPZ:\n+\t  opcode |= 0xf30000;\n+\t  break;\n+\t}\n reswitch_prefix_add:\n       switch (opcode)\n-        {\n-        case 0x0f38:\n-        case 0x660f38:\n-        case 0xf20f38:\n-        case 0x0f3a:\n-        case 0x660f3a:\n-          if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))\n+\t{\n+\tcase 0x0f38:\n+\tcase 0x660f38:\n+\tcase 0xf20f38:\n+\tcase 0x0f3a:\n+\tcase 0x660f3a:\n+\t  if (record_read_memory (gdbarch, ir.addr, &opcode8, 1))\n \t    return -1;\n-          ir.addr++;\n-          opcode = (uint32_t) opcode8 | opcode << 8;\n-          goto reswitch_prefix_add;\n-          break;\n-\n-        case 0x0f10:        /* movups */\n-        case 0x660f10:      /* movupd */\n-        case 0xf30f10:      /* movss */\n-        case 0xf20f10:      /* movsd */\n-        case 0x0f12:        /* movlps */\n-        case 0x660f12:      /* movlpd */\n-        case 0xf30f12:      /* movsldup */\n-        case 0xf20f12:      /* movddup */\n-        case 0x0f14:        /* unpcklps */\n-        case 0x660f14:      /* unpcklpd */\n-        case 0x0f15:        /* unpckhps */\n-        case 0x660f15:      /* unpckhpd */\n-        case 0x0f16:        /* movhps */\n-        case 0x660f16:      /* movhpd */\n-        case 0xf30f16:      /* movshdup */\n-        case 0x0f28:        /* movaps */\n-        case 0x660f28:      /* movapd */\n-        case 0x0f2a:        /* cvtpi2ps */\n-        case 0x660f2a:      /* cvtpi2pd */\n-        case 0xf30f2a:      /* cvtsi2ss */\n-        case 0xf20f2a:      /* cvtsi2sd */\n-        case 0x0f2c:        /* cvttps2pi */\n-        case 0x660f2c:      /* cvttpd2pi */\n-        case 0x0f2d:        /* cvtps2pi */\n-        case 0x660f2d:      /* cvtpd2pi */\n-        case 0x660f3800:    /* pshufb */\n-        case 0x660f3801:    /* phaddw */\n-        case 0x660f3802:    /* phaddd */\n-        case 0x660f3803:    /* phaddsw */\n-        case 0x660f3804:    /* pmaddubsw */\n-        case 0x660f3805:    /* phsubw */\n-        case 0x660f3806:    /* phsubd */\n-        case 0x660f3807:    /* phsubsw */\n-        case 0x660f3808:    /* psignb */\n-        case 0x660f3809:    /* psignw */\n-        case 0x660f380a:    /* psignd */\n-        case 0x660f380b:    /* pmulhrsw */\n-        case 0x660f3810:    /* pblendvb */\n-        case 0x660f3814:    /* blendvps */\n-        case 0x660f3815:    /* blendvpd */\n-        case 0x660f381c:    /* pabsb */\n-        case 0x660f381d:    /* pabsw */\n-        case 0x660f381e:    /* pabsd */\n-        case 0x660f3820:    /* pmovsxbw */\n-        case 0x660f3821:    /* pmovsxbd */\n-        case 0x660f3822:    /* pmovsxbq */\n-        case 0x660f3823:    /* pmovsxwd */\n-        case 0x660f3824:    /* pmovsxwq */\n-        case 0x660f3825:    /* pmovsxdq */\n-        case 0x660f3828:    /* pmuldq */\n-        case 0x660f3829:    /* pcmpeqq */\n-        case 0x660f382a:    /* movntdqa */\n-        case 0x660f3a08:    /* roundps */\n-        case 0x660f3a09:    /* roundpd */\n-        case 0x660f3a0a:    /* roundss */\n-        case 0x660f3a0b:    /* roundsd */\n-        case 0x660f3a0c:    /* blendps */\n-        case 0x660f3a0d:    /* blendpd */\n-        case 0x660f3a0e:    /* pblendw */\n-        case 0x660f3a0f:    /* palignr */\n-        case 0x660f3a20:    /* pinsrb */\n-        case 0x660f3a21:    /* insertps */\n-        case 0x660f3a22:    /* pinsrd pinsrq */\n-        case 0x660f3a40:    /* dpps */\n-        case 0x660f3a41:    /* dppd */\n-        case 0x660f3a42:    /* mpsadbw */\n-        case 0x660f3a60:    /* pcmpestrm */\n-        case 0x660f3a61:    /* pcmpestri */\n-        case 0x660f3a62:    /* pcmpistrm */\n-        case 0x660f3a63:    /* pcmpistri */\n-        case 0x0f51:        /* sqrtps */\n-        case 0x660f51:      /* sqrtpd */\n-        case 0xf20f51:      /* sqrtsd */\n-        case 0xf30f51:      /* sqrtss */\n-        case 0x0f52:        /* rsqrtps */\n-        case 0xf30f52:      /* rsqrtss */\n-        case 0x0f53:        /* rcpps */\n-        case 0xf30f53:      /* rcpss */\n-        case 0x0f54:        /* andps */\n-        case 0x660f54:      /* andpd */\n-        case 0x0f55:        /* andnps */\n-        case 0x660f55:      /* andnpd */\n-        case 0x0f56:        /* orps */\n-        case 0x660f56:      /* orpd */\n-        case 0x0f57:        /* xorps */\n-        case 0x660f57:      /* xorpd */\n-        case 0x0f58:        /* addps */\n-        case 0x660f58:      /* addpd */\n-        case 0xf20f58:      /* addsd */\n-        case 0xf30f58:      /* addss */\n-        case 0x0f59:        /* mulps */\n-        case 0x660f59:      /* mulpd */\n-        case 0xf20f59:      /* mulsd */\n-        case 0xf30f59:      /* mulss */\n-        case 0x0f5a:        /* cvtps2pd */\n-        case 0x660f5a:      /* cvtpd2ps */\n-        case 0xf20f5a:      /* cvtsd2ss */\n-        case 0xf30f5a:      /* cvtss2sd */\n-        case 0x0f5b:        /* cvtdq2ps */\n-        case 0x660f5b:      /* cvtps2dq */\n-        case 0xf30f5b:      /* cvttps2dq */\n-        case 0x0f5c:        /* subps */\n-        case 0x660f5c:      /* subpd */\n-        case 0xf20f5c:      /* subsd */\n-        case 0xf30f5c:      /* subss */\n-        case 0x0f5d:        /* minps */\n-        case 0x660f5d:      /* minpd */\n-        case 0xf20f5d:      /* minsd */\n-        case 0xf30f5d:      /* minss */\n-        case 0x0f5e:        /* divps */\n-        case 0x660f5e:      /* divpd */\n-        case 0xf20f5e:      /* divsd */\n-        case 0xf30f5e:      /* divss */\n-        case 0x0f5f:        /* maxps */\n-        case 0x660f5f:      /* maxpd */\n-        case 0xf20f5f:      /* maxsd */\n-        case 0xf30f5f:      /* maxss */\n-        case 0x660f60:      /* punpcklbw */\n-        case 0x660f61:      /* punpcklwd */\n-        case 0x660f62:      /* punpckldq */\n-        case 0x660f63:      /* packsswb */\n-        case 0x660f64:      /* pcmpgtb */\n-        case 0x660f65:      /* pcmpgtw */\n-        case 0x660f66:      /* pcmpgtd */\n-        case 0x660f67:      /* packuswb */\n-        case 0x660f68:      /* punpckhbw */\n-        case 0x660f69:      /* punpckhwd */\n-        case 0x660f6a:      /* punpckhdq */\n-        case 0x660f6b:      /* packssdw */\n-        case 0x660f6c:      /* punpcklqdq */\n-        case 0x660f6d:      /* punpckhqdq */\n-        case 0x660f6e:      /* movd */\n-        case 0x660f6f:      /* movdqa */\n-        case 0xf30f6f:      /* movdqu */\n-        case 0x660f70:      /* pshufd */\n-        case 0xf20f70:      /* pshuflw */\n-        case 0xf30f70:      /* pshufhw */\n-        case 0x660f74:      /* pcmpeqb */\n-        case 0x660f75:      /* pcmpeqw */\n-        case 0x660f76:      /* pcmpeqd */\n-        case 0x660f7c:      /* haddpd */\n-        case 0xf20f7c:      /* haddps */\n-        case 0x660f7d:      /* hsubpd */\n-        case 0xf20f7d:      /* hsubps */\n-        case 0xf30f7e:      /* movq */\n-        case 0x0fc2:        /* cmpps */\n-        case 0x660fc2:      /* cmppd */\n-        case 0xf20fc2:      /* cmpsd */\n-        case 0xf30fc2:      /* cmpss */\n-        case 0x660fc4:      /* pinsrw */\n-        case 0x0fc6:        /* shufps */\n-        case 0x660fc6:      /* shufpd */\n-        case 0x660fd0:      /* addsubpd */\n-        case 0xf20fd0:      /* addsubps */\n-        case 0x660fd1:      /* psrlw */\n-        case 0x660fd2:      /* psrld */\n-        case 0x660fd3:      /* psrlq */\n-        case 0x660fd4:      /* paddq */\n-        case 0x660fd5:      /* pmullw */\n-        case 0xf30fd6:      /* movq2dq */\n-        case 0x660fd8:      /* psubusb */\n-        case 0x660fd9:      /* psubusw */\n-        case 0x660fda:      /* pminub */\n-        case 0x660fdb:      /* pand */\n-        case 0x660fdc:      /* paddusb */\n-        case 0x660fdd:      /* paddusw */\n-        case 0x660fde:      /* pmaxub */\n-        case 0x660fdf:      /* pandn */\n-        case 0x660fe0:      /* pavgb */\n-        case 0x660fe1:      /* psraw */\n-        case 0x660fe2:      /* psrad */\n-        case 0x660fe3:      /* pavgw */\n-        case 0x660fe4:      /* pmulhuw */\n-        case 0x660fe5:      /* pmulhw */\n-        case 0x660fe6:      /* cvttpd2dq */\n-        case 0xf20fe6:      /* cvtpd2dq */\n-        case 0xf30fe6:      /* cvtdq2pd */\n-        case 0x660fe8:      /* psubsb */\n-        case 0x660fe9:      /* psubsw */\n-        case 0x660fea:      /* pminsw */\n-        case 0x660feb:      /* por */\n-        case 0x660fec:      /* paddsb */\n-        case 0x660fed:      /* paddsw */\n-        case 0x660fee:      /* pmaxsw */\n-        case 0x660fef:      /* pxor */\n-        case 0xf20ff0:      /* lddqu */\n-        case 0x660ff1:      /* psllw */\n-        case 0x660ff2:      /* pslld */\n-        case 0x660ff3:      /* psllq */\n-        case 0x660ff4:      /* pmuludq */\n-        case 0x660ff5:      /* pmaddwd */\n-        case 0x660ff6:      /* psadbw */\n-        case 0x660ff8:      /* psubb */\n-        case 0x660ff9:      /* psubw */\n-        case 0x660ffa:      /* psubd */\n-        case 0x660ffb:      /* psubq */\n-        case 0x660ffc:      /* paddb */\n-        case 0x660ffd:      /* paddw */\n-        case 0x660ffe:      /* paddd */\n-          if (i386_record_modrm (&ir))\n+\t  ir.addr++;\n+\t  opcode = (uint32_t) opcode8 | opcode << 8;\n+\t  goto reswitch_prefix_add;\n+\t  break;\n+\n+\tcase 0x0f10:        /* movups */\n+\tcase 0x660f10:      /* movupd */\n+\tcase 0xf30f10:      /* movss */\n+\tcase 0xf20f10:      /* movsd */\n+\tcase 0x0f12:        /* movlps */\n+\tcase 0x660f12:      /* movlpd */\n+\tcase 0xf30f12:      /* movsldup */\n+\tcase 0xf20f12:      /* movddup */\n+\tcase 0x0f14:        /* unpcklps */\n+\tcase 0x660f14:      /* unpcklpd */\n+\tcase 0x0f15:        /* unpckhps */\n+\tcase 0x660f15:      /* unpckhpd */\n+\tcase 0x0f16:        /* movhps */\n+\tcase 0x660f16:      /* movhpd */\n+\tcase 0xf30f16:      /* movshdup */\n+\tcase 0x0f28:        /* movaps */\n+\tcase 0x660f28:      /* movapd */\n+\tcase 0x0f2a:        /* cvtpi2ps */\n+\tcase 0x660f2a:      /* cvtpi2pd */\n+\tcase 0xf30f2a:      /* cvtsi2ss */\n+\tcase 0xf20f2a:      /* cvtsi2sd */\n+\tcase 0x0f2c:        /* cvttps2pi */\n+\tcase 0x660f2c:      /* cvttpd2pi */\n+\tcase 0x0f2d:        /* cvtps2pi */\n+\tcase 0x660f2d:      /* cvtpd2pi */\n+\tcase 0x660f3800:    /* pshufb */\n+\tcase 0x660f3801:    /* phaddw */\n+\tcase 0x660f3802:    /* phaddd */\n+\tcase 0x660f3803:    /* phaddsw */\n+\tcase 0x660f3804:    /* pmaddubsw */\n+\tcase 0x660f3805:    /* phsubw */\n+\tcase 0x660f3806:    /* phsubd */\n+\tcase 0x660f3807:    /* phsubsw */\n+\tcase 0x660f3808:    /* psignb */\n+\tcase 0x660f3809:    /* psignw */\n+\tcase 0x660f380a:    /* psignd */\n+\tcase 0x660f380b:    /* pmulhrsw */\n+\tcase 0x660f3810:    /* pblendvb */\n+\tcase 0x660f3814:    /* blendvps */\n+\tcase 0x660f3815:    /* blendvpd */\n+\tcase 0x660f381c:    /* pabsb */\n+\tcase 0x660f381d:    /* pabsw */\n+\tcase 0x660f381e:    /* pabsd */\n+\tcase 0x660f3820:    /* pmovsxbw */\n+\tcase 0x660f3821:    /* pmovsxbd */\n+\tcase 0x660f3822:    /* pmovsxbq */\n+\tcase 0x660f3823:    /* pmovsxwd */\n+\tcase 0x660f3824:    /* pmovsxwq */\n+\tcase 0x660f3825:    /* pmovsxdq */\n+\tcase 0x660f3828:    /* pmuldq */\n+\tcase 0x660f3829:    /* pcmpeqq */\n+\tcase 0x660f382a:    /* movntdqa */\n+\tcase 0x660f3a08:    /* roundps */\n+\tcase 0x660f3a09:    /* roundpd */\n+\tcase 0x660f3a0a:    /* roundss */\n+\tcase 0x660f3a0b:    /* roundsd */\n+\tcase 0x660f3a0c:    /* blendps */\n+\tcase 0x660f3a0d:    /* blendpd */\n+\tcase 0x660f3a0e:    /* pblendw */\n+\tcase 0x660f3a0f:    /* palignr */\n+\tcase 0x660f3a20:    /* pinsrb */\n+\tcase 0x660f3a21:    /* insertps */\n+\tcase 0x660f3a22:    /* pinsrd pinsrq */\n+\tcase 0x660f3a40:    /* dpps */\n+\tcase 0x660f3a41:    /* dppd */\n+\tcase 0x660f3a42:    /* mpsadbw */\n+\tcase 0x660f3a60:    /* pcmpestrm */\n+\tcase 0x660f3a61:    /* pcmpestri */\n+\tcase 0x660f3a62:    /* pcmpistrm */\n+\tcase 0x660f3a63:    /* pcmpistri */\n+\tcase 0x0f51:        /* sqrtps */\n+\tcase 0x660f51:      /* sqrtpd */\n+\tcase 0xf20f51:      /* sqrtsd */\n+\tcase 0xf30f51:      /* sqrtss */\n+\tcase 0x0f52:        /* rsqrtps */\n+\tcase 0xf30f52:      /* rsqrtss */\n+\tcase 0x0f53:        /* rcpps */\n+\tcase 0xf30f53:      /* rcpss */\n+\tcase 0x0f54:        /* andps */\n+\tcase 0x660f54:      /* andpd */\n+\tcase 0x0f55:        /* andnps */\n+\tcase 0x660f55:      /* andnpd */\n+\tcase 0x0f56:        /* orps */\n+\tcase 0x660f56:      /* orpd */\n+\tcase 0x0f57:        /* xorps */\n+\tcase 0x660f57:      /* xorpd */\n+\tcase 0x0f58:        /* addps */\n+\tcase 0x660f58:      /* addpd */\n+\tcase 0xf20f58:      /* addsd */\n+\tcase 0xf30f58:      /* addss */\n+\tcase 0x0f59:        /* mulps */\n+\tcase 0x660f59:      /* mulpd */\n+\tcase 0xf20f59:      /* mulsd */\n+\tcase 0xf30f59:      /* mulss */\n+\tcase 0x0f5a:        /* cvtps2pd */\n+\tcase 0x660f5a:      /* cvtpd2ps */\n+\tcase 0xf20f5a:      /* cvtsd2ss */\n+\tcase 0xf30f5a:      /* cvtss2sd */\n+\tcase 0x0f5b:        /* cvtdq2ps */\n+\tcase 0x660f5b:      /* cvtps2dq */\n+\tcase 0xf30f5b:      /* cvttps2dq */\n+\tcase 0x0f5c:        /* subps */\n+\tcase 0x660f5c:      /* subpd */\n+\tcase 0xf20f5c:      /* subsd */\n+\tcase 0xf30f5c:      /* subss */\n+\tcase 0x0f5d:        /* minps */\n+\tcase 0x660f5d:      /* minpd */\n+\tcase 0xf20f5d:      /* minsd */\n+\tcase 0xf30f5d:      /* minss */\n+\tcase 0x0f5e:        /* divps */\n+\tcase 0x660f5e:      /* divpd */\n+\tcase 0xf20f5e:      /* divsd */\n+\tcase 0xf30f5e:      /* divss */\n+\tcase 0x0f5f:        /* maxps */\n+\tcase 0x660f5f:      /* maxpd */\n+\tcase 0xf20f5f:      /* maxsd */\n+\tcase 0xf30f5f:      /* maxss */\n+\tcase 0x660f60:      /* punpcklbw */\n+\tcase 0x660f61:      /* punpcklwd */\n+\tcase 0x660f62:      /* punpckldq */\n+\tcase 0x660f63:      /* packsswb */\n+\tcase 0x660f64:      /* pcmpgtb */\n+\tcase 0x660f65:      /* pcmpgtw */\n+\tcase 0x660f66:      /* pcmpgtd */\n+\tcase 0x660f67:      /* packuswb */\n+\tcase 0x660f68:      /* punpckhbw */\n+\tcase 0x660f69:      /* punpckhwd */\n+\tcase 0x660f6a:      /* punpckhdq */\n+\tcase 0x660f6b:      /* packssdw */\n+\tcase 0x660f6c:      /* punpcklqdq */\n+\tcase 0x660f6d:      /* punpckhqdq */\n+\tcase 0x660f6e:      /* movd */\n+\tcase 0x660f6f:      /* movdqa */\n+\tcase 0xf30f6f:      /* movdqu */\n+\tcase 0x660f70:      /* pshufd */\n+\tcase 0xf20f70:      /* pshuflw */\n+\tcase 0xf30f70:      /* pshufhw */\n+\tcase 0x660f74:      /* pcmpeqb */\n+\tcase 0x660f75:      /* pcmpeqw */\n+\tcase 0x660f76:      /* pcmpeqd */\n+\tcase 0x660f7c:      /* haddpd */\n+\tcase 0xf20f7c:      /* haddps */\n+\tcase 0x660f7d:      /* hsubpd */\n+\tcase 0xf20f7d:      /* hsubps */\n+\tcase 0xf30f7e:      /* movq */\n+\tcase 0x0fc2:        /* cmpps */\n+\tcase 0x660fc2:      /* cmppd */\n+\tcase 0xf20fc2:      /* cmpsd */\n+\tcase 0xf30fc2:      /* cmpss */\n+\tcase 0x660fc4:      /* pinsrw */\n+\tcase 0x0fc6:        /* shufps */\n+\tcase 0x660fc6:      /* shufpd */\n+\tcase 0x660fd0:      /* addsubpd */\n+\tcase 0xf20fd0:      /* addsubps */\n+\tcase 0x660fd1:      /* psrlw */\n+\tcase 0x660fd2:      /* psrld */\n+\tcase 0x660fd3:      /* psrlq */\n+\tcase 0x660fd4:      /* paddq */\n+\tcase 0x660fd5:      /* pmullw */\n+\tcase 0xf30fd6:      /* movq2dq */\n+\tcase 0x660fd8:      /* psubusb */\n+\tcase 0x660fd9:      /* psubusw */\n+\tcase 0x660fda:      /* pminub */\n+\tcase 0x660fdb:      /* pand */\n+\tcase 0x660fdc:      /* paddusb */\n+\tcase 0x660fdd:      /* paddusw */\n+\tcase 0x660fde:      /* pmaxub */\n+\tcase 0x660fdf:      /* pandn */\n+\tcase 0x660fe0:      /* pavgb */\n+\tcase 0x660fe1:      /* psraw */\n+\tcase 0x660fe2:      /* psrad */\n+\tcase 0x660fe3:      /* pavgw */\n+\tcase 0x660fe4:      /* pmulhuw */\n+\tcase 0x660fe5:      /* pmulhw */\n+\tcase 0x660fe6:      /* cvttpd2dq */\n+\tcase 0xf20fe6:      /* cvtpd2dq */\n+\tcase 0xf30fe6:      /* cvtdq2pd */\n+\tcase 0x660fe8:      /* psubsb */\n+\tcase 0x660fe9:      /* psubsw */\n+\tcase 0x660fea:      /* pminsw */\n+\tcase 0x660feb:      /* por */\n+\tcase 0x660fec:      /* paddsb */\n+\tcase 0x660fed:      /* paddsw */\n+\tcase 0x660fee:      /* pmaxsw */\n+\tcase 0x660fef:      /* pxor */\n+\tcase 0xf20ff0:      /* lddqu */\n+\tcase 0x660ff1:      /* psllw */\n+\tcase 0x660ff2:      /* pslld */\n+\tcase 0x660ff3:      /* psllq */\n+\tcase 0x660ff4:      /* pmuludq */\n+\tcase 0x660ff5:      /* pmaddwd */\n+\tcase 0x660ff6:      /* psadbw */\n+\tcase 0x660ff8:      /* psubb */\n+\tcase 0x660ff9:      /* psubw */\n+\tcase 0x660ffa:      /* psubd */\n+\tcase 0x660ffb:      /* psubq */\n+\tcase 0x660ffc:      /* paddb */\n+\tcase 0x660ffd:      /* paddw */\n+\tcase 0x660ffe:      /* paddd */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          ir.reg |= rex_r;\n-          if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.reg))\n-            goto no_support;\n-          record_full_arch_list_add_reg (ir.regcache,\n+\t  ir.reg |= rex_r;\n+\t  if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.reg))\n+\t    goto no_support;\n+\t  record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t I387_XMM0_REGNUM (tdep) + ir.reg);\n-          if ((opcode & 0xfffffffc) == 0x660f3a60)\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n-          break;\n-\n-        case 0x0f11:        /* movups */\n-        case 0x660f11:      /* movupd */\n-        case 0xf30f11:      /* movss */\n-        case 0xf20f11:      /* movsd */\n-        case 0x0f13:        /* movlps */\n-        case 0x660f13:      /* movlpd */\n-        case 0x0f17:        /* movhps */\n-        case 0x660f17:      /* movhpd */\n-        case 0x0f29:        /* movaps */\n-        case 0x660f29:      /* movapd */\n-        case 0x660f3a14:    /* pextrb */\n-        case 0x660f3a15:    /* pextrw */\n-        case 0x660f3a16:    /* pextrd pextrq */\n-        case 0x660f3a17:    /* extractps */\n-        case 0x660f7f:      /* movdqa */\n-        case 0xf30f7f:      /* movdqu */\n-          if (i386_record_modrm (&ir))\n+\t  if ((opcode & 0xfffffffc) == 0x660f3a60)\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t  break;\n+\n+\tcase 0x0f11:        /* movups */\n+\tcase 0x660f11:      /* movupd */\n+\tcase 0xf30f11:      /* movss */\n+\tcase 0xf20f11:      /* movsd */\n+\tcase 0x0f13:        /* movlps */\n+\tcase 0x660f13:      /* movlpd */\n+\tcase 0x0f17:        /* movhps */\n+\tcase 0x660f17:      /* movhpd */\n+\tcase 0x0f29:        /* movaps */\n+\tcase 0x660f29:      /* movapd */\n+\tcase 0x660f3a14:    /* pextrb */\n+\tcase 0x660f3a15:    /* pextrw */\n+\tcase 0x660f3a16:    /* pextrd pextrq */\n+\tcase 0x660f3a17:    /* extractps */\n+\tcase 0x660f7f:      /* movdqa */\n+\tcase 0xf30f7f:      /* movdqu */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          if (ir.mod == 3)\n-            {\n-              if (opcode == 0x0f13 || opcode == 0x660f13\n-                  || opcode == 0x0f17 || opcode == 0x660f17)\n-                goto no_support;\n-              ir.rm |= ir.rex_b;\n-              if (!i386_xmm_regnum_p (gdbarch,\n+\t  if (ir.mod == 3)\n+\t    {\n+\t      if (opcode == 0x0f13 || opcode == 0x660f13\n+\t\t  || opcode == 0x0f17 || opcode == 0x660f17)\n+\t\tgoto no_support;\n+\t      ir.rm |= ir.rex_b;\n+\t      if (!i386_xmm_regnum_p (gdbarch,\n \t\t\t\t      I387_XMM0_REGNUM (tdep) + ir.rm))\n-                goto no_support;\n-              record_full_arch_list_add_reg (ir.regcache,\n+\t\tgoto no_support;\n+\t      record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t     I387_XMM0_REGNUM (tdep) + ir.rm);\n-            }\n-          else\n-            {\n-              switch (opcode)\n-                {\n-                  case 0x660f3a14:\n-                    ir.ot = OT_BYTE;\n-                    break;\n-                  case 0x660f3a15:\n-                    ir.ot = OT_WORD;\n-                    break;\n-                  case 0x660f3a16:\n-                    ir.ot = OT_LONG;\n-                    break;\n-                  case 0x660f3a17:\n-                    ir.ot = OT_QUAD;\n-                    break;\n-                  default:\n-                    ir.ot = OT_DQUAD;\n-                    break;\n-                }\n-              if (i386_record_lea_modrm (&ir))\n-                return -1;\n-            }\n-          break;\n-\n-        case 0x0f2b:      /* movntps */\n-        case 0x660f2b:    /* movntpd */\n-        case 0x0fe7:      /* movntq */\n-        case 0x660fe7:    /* movntdq */\n-          if (ir.mod == 3)\n-            goto no_support;\n-          if (opcode == 0x0fe7)\n-            ir.ot = OT_QUAD;\n-          else\n-            ir.ot = OT_DQUAD;\n-          if (i386_record_lea_modrm (&ir))\n-            return -1;\n-          break;\n-\n-        case 0xf30f2c:      /* cvttss2si */\n-        case 0xf20f2c:      /* cvttsd2si */\n-        case 0xf30f2d:      /* cvtss2si */\n-        case 0xf20f2d:      /* cvtsd2si */\n-        case 0xf20f38f0:    /* crc32 */\n-        case 0xf20f38f1:    /* crc32 */\n-        case 0x0f50:        /* movmskps */\n-        case 0x660f50:      /* movmskpd */\n-        case 0x0fc5:        /* pextrw */\n-        case 0x660fc5:      /* pextrw */\n-        case 0x0fd7:        /* pmovmskb */\n-        case 0x660fd7:      /* pmovmskb */\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);\n-          break;\n-\n-        case 0x0f3800:    /* pshufb */\n-        case 0x0f3801:    /* phaddw */\n-        case 0x0f3802:    /* phaddd */\n-        case 0x0f3803:    /* phaddsw */\n-        case 0x0f3804:    /* pmaddubsw */\n-        case 0x0f3805:    /* phsubw */\n-        case 0x0f3806:    /* phsubd */\n-        case 0x0f3807:    /* phsubsw */\n-        case 0x0f3808:    /* psignb */\n-        case 0x0f3809:    /* psignw */\n-        case 0x0f380a:    /* psignd */\n-        case 0x0f380b:    /* pmulhrsw */\n-        case 0x0f381c:    /* pabsb */\n-        case 0x0f381d:    /* pabsw */\n-        case 0x0f381e:    /* pabsd */\n-        case 0x0f382b:    /* packusdw */\n-        case 0x0f3830:    /* pmovzxbw */\n-        case 0x0f3831:    /* pmovzxbd */\n-        case 0x0f3832:    /* pmovzxbq */\n-        case 0x0f3833:    /* pmovzxwd */\n-        case 0x0f3834:    /* pmovzxwq */\n-        case 0x0f3835:    /* pmovzxdq */\n-        case 0x0f3837:    /* pcmpgtq */\n-        case 0x0f3838:    /* pminsb */\n-        case 0x0f3839:    /* pminsd */\n-        case 0x0f383a:    /* pminuw */\n-        case 0x0f383b:    /* pminud */\n-        case 0x0f383c:    /* pmaxsb */\n-        case 0x0f383d:    /* pmaxsd */\n-        case 0x0f383e:    /* pmaxuw */\n-        case 0x0f383f:    /* pmaxud */\n-        case 0x0f3840:    /* pmulld */\n-        case 0x0f3841:    /* phminposuw */\n-        case 0x0f3a0f:    /* palignr */\n-        case 0x0f60:      /* punpcklbw */\n-        case 0x0f61:      /* punpcklwd */\n-        case 0x0f62:      /* punpckldq */\n-        case 0x0f63:      /* packsswb */\n-        case 0x0f64:      /* pcmpgtb */\n-        case 0x0f65:      /* pcmpgtw */\n-        case 0x0f66:      /* pcmpgtd */\n-        case 0x0f67:      /* packuswb */\n-        case 0x0f68:      /* punpckhbw */\n-        case 0x0f69:      /* punpckhwd */\n-        case 0x0f6a:      /* punpckhdq */\n-        case 0x0f6b:      /* packssdw */\n-        case 0x0f6e:      /* movd */\n-        case 0x0f6f:      /* movq */\n-        case 0x0f70:      /* pshufw */\n-        case 0x0f74:      /* pcmpeqb */\n-        case 0x0f75:      /* pcmpeqw */\n-        case 0x0f76:      /* pcmpeqd */\n-        case 0x0fc4:      /* pinsrw */\n-        case 0x0fd1:      /* psrlw */\n-        case 0x0fd2:      /* psrld */\n-        case 0x0fd3:      /* psrlq */\n-        case 0x0fd4:      /* paddq */\n-        case 0x0fd5:      /* pmullw */\n-        case 0xf20fd6:    /* movdq2q */\n-        case 0x0fd8:      /* psubusb */\n-        case 0x0fd9:      /* psubusw */\n-        case 0x0fda:      /* pminub */\n-        case 0x0fdb:      /* pand */\n-        case 0x0fdc:      /* paddusb */\n-        case 0x0fdd:      /* paddusw */\n-        case 0x0fde:      /* pmaxub */\n-        case 0x0fdf:      /* pandn */\n-        case 0x0fe0:      /* pavgb */\n-        case 0x0fe1:      /* psraw */\n-        case 0x0fe2:      /* psrad */\n-        case 0x0fe3:      /* pavgw */\n-        case 0x0fe4:      /* pmulhuw */\n-        case 0x0fe5:      /* pmulhw */\n-        case 0x0fe8:      /* psubsb */\n-        case 0x0fe9:      /* psubsw */\n-        case 0x0fea:      /* pminsw */\n-        case 0x0feb:      /* por */\n-        case 0x0fec:      /* paddsb */\n-        case 0x0fed:      /* paddsw */\n-        case 0x0fee:      /* pmaxsw */\n-        case 0x0fef:      /* pxor */\n-        case 0x0ff1:      /* psllw */\n-        case 0x0ff2:      /* pslld */\n-        case 0x0ff3:      /* psllq */\n-        case 0x0ff4:      /* pmuludq */\n-        case 0x0ff5:      /* pmaddwd */\n-        case 0x0ff6:      /* psadbw */\n-        case 0x0ff8:      /* psubb */\n-        case 0x0ff9:      /* psubw */\n-        case 0x0ffa:      /* psubd */\n-        case 0x0ffb:      /* psubq */\n-        case 0x0ffc:      /* paddb */\n-        case 0x0ffd:      /* paddw */\n-        case 0x0ffe:      /* paddd */\n-          if (i386_record_modrm (&ir))\n+\t    }\n+\t  else\n+\t    {\n+\t      switch (opcode)\n+\t\t{\n+\t\t  case 0x660f3a14:\n+\t\t    ir.ot = OT_BYTE;\n+\t\t    break;\n+\t\t  case 0x660f3a15:\n+\t\t    ir.ot = OT_WORD;\n+\t\t    break;\n+\t\t  case 0x660f3a16:\n+\t\t    ir.ot = OT_LONG;\n+\t\t    break;\n+\t\t  case 0x660f3a17:\n+\t\t    ir.ot = OT_QUAD;\n+\t\t    break;\n+\t\t  default:\n+\t\t    ir.ot = OT_DQUAD;\n+\t\t    break;\n+\t\t}\n+\t      if (i386_record_lea_modrm (&ir))\n+\t\treturn -1;\n+\t    }\n+\t  break;\n+\n+\tcase 0x0f2b:      /* movntps */\n+\tcase 0x660f2b:    /* movntpd */\n+\tcase 0x0fe7:      /* movntq */\n+\tcase 0x660fe7:    /* movntdq */\n+\t  if (ir.mod == 3)\n+\t    goto no_support;\n+\t  if (opcode == 0x0fe7)\n+\t    ir.ot = OT_QUAD;\n+\t  else\n+\t    ir.ot = OT_DQUAD;\n+\t  if (i386_record_lea_modrm (&ir))\n \t    return -1;\n-          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))\n-            goto no_support;\n-          record_full_arch_list_add_reg (ir.regcache,\n+\t  break;\n+\n+\tcase 0xf30f2c:      /* cvttss2si */\n+\tcase 0xf20f2c:      /* cvttsd2si */\n+\tcase 0xf30f2d:      /* cvtss2si */\n+\tcase 0xf20f2d:      /* cvtsd2si */\n+\tcase 0xf20f38f0:    /* crc32 */\n+\tcase 0xf20f38f1:    /* crc32 */\n+\tcase 0x0f50:        /* movmskps */\n+\tcase 0x660f50:      /* movmskpd */\n+\tcase 0x0fc5:        /* pextrw */\n+\tcase 0x660fc5:      /* pextrw */\n+\tcase 0x0fd7:        /* pmovmskb */\n+\tcase 0x660fd7:      /* pmovmskb */\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg | rex_r);\n+\t  break;\n+\n+\tcase 0x0f3800:    /* pshufb */\n+\tcase 0x0f3801:    /* phaddw */\n+\tcase 0x0f3802:    /* phaddd */\n+\tcase 0x0f3803:    /* phaddsw */\n+\tcase 0x0f3804:    /* pmaddubsw */\n+\tcase 0x0f3805:    /* phsubw */\n+\tcase 0x0f3806:    /* phsubd */\n+\tcase 0x0f3807:    /* phsubsw */\n+\tcase 0x0f3808:    /* psignb */\n+\tcase 0x0f3809:    /* psignw */\n+\tcase 0x0f380a:    /* psignd */\n+\tcase 0x0f380b:    /* pmulhrsw */\n+\tcase 0x0f381c:    /* pabsb */\n+\tcase 0x0f381d:    /* pabsw */\n+\tcase 0x0f381e:    /* pabsd */\n+\tcase 0x0f382b:    /* packusdw */\n+\tcase 0x0f3830:    /* pmovzxbw */\n+\tcase 0x0f3831:    /* pmovzxbd */\n+\tcase 0x0f3832:    /* pmovzxbq */\n+\tcase 0x0f3833:    /* pmovzxwd */\n+\tcase 0x0f3834:    /* pmovzxwq */\n+\tcase 0x0f3835:    /* pmovzxdq */\n+\tcase 0x0f3837:    /* pcmpgtq */\n+\tcase 0x0f3838:    /* pminsb */\n+\tcase 0x0f3839:    /* pminsd */\n+\tcase 0x0f383a:    /* pminuw */\n+\tcase 0x0f383b:    /* pminud */\n+\tcase 0x0f383c:    /* pmaxsb */\n+\tcase 0x0f383d:    /* pmaxsd */\n+\tcase 0x0f383e:    /* pmaxuw */\n+\tcase 0x0f383f:    /* pmaxud */\n+\tcase 0x0f3840:    /* pmulld */\n+\tcase 0x0f3841:    /* phminposuw */\n+\tcase 0x0f3a0f:    /* palignr */\n+\tcase 0x0f60:      /* punpcklbw */\n+\tcase 0x0f61:      /* punpcklwd */\n+\tcase 0x0f62:      /* punpckldq */\n+\tcase 0x0f63:      /* packsswb */\n+\tcase 0x0f64:      /* pcmpgtb */\n+\tcase 0x0f65:      /* pcmpgtw */\n+\tcase 0x0f66:      /* pcmpgtd */\n+\tcase 0x0f67:      /* packuswb */\n+\tcase 0x0f68:      /* punpckhbw */\n+\tcase 0x0f69:      /* punpckhwd */\n+\tcase 0x0f6a:      /* punpckhdq */\n+\tcase 0x0f6b:      /* packssdw */\n+\tcase 0x0f6e:      /* movd */\n+\tcase 0x0f6f:      /* movq */\n+\tcase 0x0f70:      /* pshufw */\n+\tcase 0x0f74:      /* pcmpeqb */\n+\tcase 0x0f75:      /* pcmpeqw */\n+\tcase 0x0f76:      /* pcmpeqd */\n+\tcase 0x0fc4:      /* pinsrw */\n+\tcase 0x0fd1:      /* psrlw */\n+\tcase 0x0fd2:      /* psrld */\n+\tcase 0x0fd3:      /* psrlq */\n+\tcase 0x0fd4:      /* paddq */\n+\tcase 0x0fd5:      /* pmullw */\n+\tcase 0xf20fd6:    /* movdq2q */\n+\tcase 0x0fd8:      /* psubusb */\n+\tcase 0x0fd9:      /* psubusw */\n+\tcase 0x0fda:      /* pminub */\n+\tcase 0x0fdb:      /* pand */\n+\tcase 0x0fdc:      /* paddusb */\n+\tcase 0x0fdd:      /* paddusw */\n+\tcase 0x0fde:      /* pmaxub */\n+\tcase 0x0fdf:      /* pandn */\n+\tcase 0x0fe0:      /* pavgb */\n+\tcase 0x0fe1:      /* psraw */\n+\tcase 0x0fe2:      /* psrad */\n+\tcase 0x0fe3:      /* pavgw */\n+\tcase 0x0fe4:      /* pmulhuw */\n+\tcase 0x0fe5:      /* pmulhw */\n+\tcase 0x0fe8:      /* psubsb */\n+\tcase 0x0fe9:      /* psubsw */\n+\tcase 0x0fea:      /* pminsw */\n+\tcase 0x0feb:      /* por */\n+\tcase 0x0fec:      /* paddsb */\n+\tcase 0x0fed:      /* paddsw */\n+\tcase 0x0fee:      /* pmaxsw */\n+\tcase 0x0fef:      /* pxor */\n+\tcase 0x0ff1:      /* psllw */\n+\tcase 0x0ff2:      /* pslld */\n+\tcase 0x0ff3:      /* psllq */\n+\tcase 0x0ff4:      /* pmuludq */\n+\tcase 0x0ff5:      /* pmaddwd */\n+\tcase 0x0ff6:      /* psadbw */\n+\tcase 0x0ff8:      /* psubb */\n+\tcase 0x0ff9:      /* psubw */\n+\tcase 0x0ffa:      /* psubd */\n+\tcase 0x0ffb:      /* psubq */\n+\tcase 0x0ffc:      /* paddb */\n+\tcase 0x0ffd:      /* paddw */\n+\tcase 0x0ffe:      /* paddd */\n+\t  if (i386_record_modrm (&ir))\n+\t    return -1;\n+\t  if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.reg))\n+\t    goto no_support;\n+\t  record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t I387_MM0_REGNUM (tdep) + ir.reg);\n-          break;\n+\t  break;\n \n-        case 0x0f71:    /* psllw */\n-        case 0x0f72:    /* pslld */\n-        case 0x0f73:    /* psllq */\n-          if (i386_record_modrm (&ir))\n+\tcase 0x0f71:    /* psllw */\n+\tcase 0x0f72:    /* pslld */\n+\tcase 0x0f73:    /* psllq */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))\n-            goto no_support;\n-          record_full_arch_list_add_reg (ir.regcache,\n+\t  if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))\n+\t    goto no_support;\n+\t  record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t I387_MM0_REGNUM (tdep) + ir.rm);\n-          break;\n+\t  break;\n \n-        case 0x660f71:    /* psllw */\n-        case 0x660f72:    /* pslld */\n-        case 0x660f73:    /* psllq */\n-          if (i386_record_modrm (&ir))\n+\tcase 0x660f71:    /* psllw */\n+\tcase 0x660f72:    /* pslld */\n+\tcase 0x660f73:    /* psllq */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          ir.rm |= ir.rex_b;\n-          if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))\n-            goto no_support;\n-          record_full_arch_list_add_reg (ir.regcache,\n+\t  ir.rm |= ir.rex_b;\n+\t  if (!i386_xmm_regnum_p (gdbarch, I387_XMM0_REGNUM (tdep) + ir.rm))\n+\t    goto no_support;\n+\t  record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t I387_XMM0_REGNUM (tdep) + ir.rm);\n-          break;\n+\t  break;\n \n-        case 0x0f7e:      /* movd */\n-        case 0x660f7e:    /* movd */\n-          if (i386_record_modrm (&ir))\n+\tcase 0x0f7e:      /* movd */\n+\tcase 0x660f7e:    /* movd */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          if (ir.mod == 3)\n-            I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n-          else\n-            {\n-              if (ir.dflag == 2)\n-                ir.ot = OT_QUAD;\n-              else\n-                ir.ot = OT_LONG;\n-              if (i386_record_lea_modrm (&ir))\n-                return -1;\n-            }\n-          break;\n-\n-        case 0x0f7f:    /* movq */\n-          if (i386_record_modrm (&ir))\n+\t  if (ir.mod == 3)\n+\t    I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.rm | ir.rex_b);\n+\t  else\n+\t    {\n+\t      if (ir.dflag == 2)\n+\t\tir.ot = OT_QUAD;\n+\t      else\n+\t\tir.ot = OT_LONG;\n+\t      if (i386_record_lea_modrm (&ir))\n+\t\treturn -1;\n+\t    }\n+\t  break;\n+\n+\tcase 0x0f7f:    /* movq */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          if (ir.mod == 3)\n-            {\n-              if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))\n-                goto no_support;\n-              record_full_arch_list_add_reg (ir.regcache,\n+\t  if (ir.mod == 3)\n+\t    {\n+\t      if (!i386_mmx_regnum_p (gdbarch, I387_MM0_REGNUM (tdep) + ir.rm))\n+\t\tgoto no_support;\n+\t      record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t     I387_MM0_REGNUM (tdep) + ir.rm);\n-            }\n-          else\n-            {\n-              ir.ot = OT_QUAD;\n-              if (i386_record_lea_modrm (&ir))\n-                return -1;\n-            }\n-          break;\n-\n-        case 0xf30fb8:    /* popcnt */\n-          if (i386_record_modrm (&ir))\n+\t    }\n+\t  else\n+\t    {\n+\t      ir.ot = OT_QUAD;\n+\t      if (i386_record_lea_modrm (&ir))\n+\t\treturn -1;\n+\t    }\n+\t  break;\n+\n+\tcase 0xf30fb8:    /* popcnt */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n-          break;\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (ir.reg);\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t  break;\n \n-        case 0x660fd6:    /* movq */\n-          if (i386_record_modrm (&ir))\n+\tcase 0x660fd6:    /* movq */\n+\t  if (i386_record_modrm (&ir))\n \t    return -1;\n-          if (ir.mod == 3)\n-            {\n-              ir.rm |= ir.rex_b;\n-              if (!i386_xmm_regnum_p (gdbarch,\n+\t  if (ir.mod == 3)\n+\t    {\n+\t      ir.rm |= ir.rex_b;\n+\t      if (!i386_xmm_regnum_p (gdbarch,\n \t\t\t\t      I387_XMM0_REGNUM (tdep) + ir.rm))\n-                goto no_support;\n-              record_full_arch_list_add_reg (ir.regcache,\n+\t\tgoto no_support;\n+\t      record_full_arch_list_add_reg (ir.regcache,\n \t\t\t\t\t     I387_XMM0_REGNUM (tdep) + ir.rm);\n-            }\n-          else\n-            {\n-              ir.ot = OT_QUAD;\n-              if (i386_record_lea_modrm (&ir))\n-                return -1;\n-            }\n-          break;\n-\n-        case 0x660f3817:    /* ptest */\n-        case 0x0f2e:        /* ucomiss */\n-        case 0x660f2e:      /* ucomisd */\n-        case 0x0f2f:        /* comiss */\n-        case 0x660f2f:      /* comisd */\n-          I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n-          break;\n-\n-        case 0x0ff7:    /* maskmovq */\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[X86_RECORD_REDI_REGNUM],\n-                                      &addr);\n-          if (record_full_arch_list_add_mem (addr, 64))\n-            return -1;\n-          break;\n-\n-        case 0x660ff7:    /* maskmovdqu */\n-          regcache_raw_read_unsigned (ir.regcache,\n-                                      ir.regmap[X86_RECORD_REDI_REGNUM],\n-                                      &addr);\n-          if (record_full_arch_list_add_mem (addr, 128))\n-            return -1;\n-          break;\n-\n-        default:\n-          goto no_support;\n-          break;\n-        }\n+\t    }\n+\t  else\n+\t    {\n+\t      ir.ot = OT_QUAD;\n+\t      if (i386_record_lea_modrm (&ir))\n+\t\treturn -1;\n+\t    }\n+\t  break;\n+\n+\tcase 0x660f3817:    /* ptest */\n+\tcase 0x0f2e:        /* ucomiss */\n+\tcase 0x660f2e:      /* ucomisd */\n+\tcase 0x0f2f:        /* comiss */\n+\tcase 0x660f2f:      /* comisd */\n+\t  I386_RECORD_FULL_ARCH_LIST_ADD_REG (X86_RECORD_EFLAGS_REGNUM);\n+\t  break;\n+\n+\tcase 0x0ff7:    /* maskmovq */\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[X86_RECORD_REDI_REGNUM],\n+\t\t\t\t      &addr);\n+\t  if (record_full_arch_list_add_mem (addr, 64))\n+\t    return -1;\n+\t  break;\n+\n+\tcase 0x660ff7:    /* maskmovdqu */\n+\t  regcache_raw_read_unsigned (ir.regcache,\n+\t\t\t\t      ir.regmap[X86_RECORD_REDI_REGNUM],\n+\t\t\t\t      &addr);\n+\t  if (record_full_arch_list_add_mem (addr, 128))\n+\t    return -1;\n+\t  break;\n+\n+\tdefault:\n+\t  goto no_support;\n+\t  break;\n+\t}\n       break;\n \n     default:\n@@ -8128,9 +8128,9 @@ Do you want to stop the program?\"),\n \n  no_support:\n   printf_unfiltered (_(\"Process record does not support instruction 0x%02x \"\n-                       \"at address %s.\\n\"),\n-                     (unsigned int) (opcode),\n-                     paddress (gdbarch, ir.orig_addr));\n+\t\t       \"at address %s.\\n\"),\n+\t\t     (unsigned int) (opcode),\n+\t\t     paddress (gdbarch, ir.orig_addr));\n   return -1;\n }\n "
    },
    {
      "sha": "45d64eb009e9d82fe082e4b0d411a90f2cc58bee",
      "filename": "gdb/i386-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -460,7 +460,7 @@ extern void i386_svr4_init_abi (struct gdbarch_info, struct gdbarch *);\n extern int i386_svr4_reg_to_regnum (struct gdbarch *gdbarch, int reg);\n \n extern int i386_process_record (struct gdbarch *gdbarch,\n-                                struct regcache *regcache, CORE_ADDR addr);\n+\t\t\t\tstruct regcache *regcache, CORE_ADDR addr);\n extern const struct target_desc *i386_target_description (uint64_t xcr0,\n \t\t\t\t\t\t\t  bool segments);\n "
    },
    {
      "sha": "28a0362e6b323805c9e6a152a84b86f51c188b88",
      "filename": "gdb/i386-windows-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i386-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -215,14 +215,14 @@ void\n _initialize_i386_windows_tdep ()\n {\n   gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_coff_flavour,\n-                                  i386_windows_osabi_sniffer);\n+\t\t\t\t  i386_windows_osabi_sniffer);\n \n   /* Cygwin uses elf core dumps.  */\n   gdbarch_register_osabi_sniffer (bfd_arch_i386, bfd_target_elf_flavour,\n-                                  i386_cygwin_core_osabi_sniffer);\n+\t\t\t\t  i386_cygwin_core_osabi_sniffer);\n \n   gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_WINDOWS,\n-                          i386_windows_init_abi);\n+\t\t\t  i386_windows_init_abi);\n   gdbarch_register_osabi (bfd_arch_i386, 0, GDB_OSABI_CYGWIN,\n \t\t\t  i386_cygwin_init_abi);\n }"
    },
    {
      "sha": "35aee65dc31cdc167677f76e3197f71e3887bd34",
      "filename": "gdb/i387-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i387-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i387-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i387-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -502,7 +502,7 @@ i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)\n     if (regnum == -1 || regnum == i)\n       {\n \t/* Most of the FPU control registers occupy only 16 bits in\n-           the fsave area.  Give those a special treatment.  */\n+\t   the fsave area.  Give those a special treatment.  */\n \tif (i >= I387_FCTRL_REGNUM (tdep)\n \t    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))\n \t  {\n@@ -513,7 +513,7 @@ i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)\n \t    if (i == I387_FOP_REGNUM (tdep))\n \t      {\n \t\t/* The opcode occupies only 11 bits.  Make sure we\n-                   don't touch the other bits.  */\n+\t\t   don't touch the other bits.  */\n \t\tbuf[1] &= ((1 << 3) - 1);\n \t\tbuf[1] |= ((FSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));\n \t      }\n@@ -633,7 +633,7 @@ i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)\n \t\t    if (val[0] & (1 << fpreg))\n \t\t      {\n \t\t\tint thisreg = (fpreg + 8 - top) % 8 \n-\t\t\t               + I387_ST0_REGNUM (tdep);\n+\t\t\t\t       + I387_ST0_REGNUM (tdep);\n \t\t\ttag = i387_tag (FXSAVE_ADDR (tdep, regs, thisreg));\n \t\t      }\n \t\t    else\n@@ -679,7 +679,7 @@ i387_collect_fxsave (const struct regcache *regcache, int regnum, void *fxsave)\n     if (regnum == -1 || regnum == i)\n       {\n \t/* Most of the FPU control registers occupy only 16 bits in\n-           the fxsave area.  Give those a special treatment.  */\n+\t   the fxsave area.  Give those a special treatment.  */\n \tif (i >= I387_FCTRL_REGNUM (tdep) && i < I387_XMM0_REGNUM (tdep)\n \t    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))\n \t  {\n@@ -690,7 +690,7 @@ i387_collect_fxsave (const struct regcache *regcache, int regnum, void *fxsave)\n \t    if (i == I387_FOP_REGNUM (tdep))\n \t      {\n \t\t/* The opcode occupies only 11 bits.  Make sure we\n-                   don't touch the other bits.  */\n+\t\t   don't touch the other bits.  */\n \t\tbuf[1] &= ((1 << 3) - 1);\n \t\tbuf[1] |= ((FXSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));\n \t      }"
    },
    {
      "sha": "28ac983b5dd010cee6dfb3a18d9ea928e210befb",
      "filename": "gdb/i387-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i387-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/i387-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i387-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -170,5 +170,5 @@ extern void i387_return_value (struct gdbarch *gdbarch,\n /* Set all bnd registers to the INIT state.  INIT state means\n    all memory range can be accessed.  */\n extern void i387_reset_bnd_regs (struct gdbarch *gdbarch,\n-\t\t\t         struct regcache *regcache);\n+\t\t\t\t struct regcache *regcache);\n #endif /* i387-tdep.h */"
    },
    {
      "sha": "c888707fcaed8c7b3a53b8ce13b2854b5a44691e",
      "filename": "gdb/ia64-libunwind-tdep.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-libunwind-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-libunwind-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-libunwind-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -256,7 +256,7 @@ libunwind_find_dyn_list (unw_addr_space_t as, unw_dyn_info_t *di, void *arg)\n    libunwind frame unwinding.  */\n int\n libunwind_frame_sniffer (const struct frame_unwind *self,\n-                         struct frame_info *this_frame, void **this_cache)\n+\t\t\t struct frame_info *this_frame, void **this_cache)\n {\n   unw_cursor_t cursor;\n   unw_accessors_t *acc;\n@@ -302,7 +302,7 @@ libunwind_frame_sniffer (const struct frame_unwind *self,\n \n void\n libunwind_frame_this_id (struct frame_info *this_frame, void **this_cache,\n-\t\t         struct frame_id *this_id)\n+\t\t\t struct frame_id *this_id)\n {\n   struct libunwind_frame_cache *cache =\n     libunwind_frame_cache (this_frame, this_cache);\n@@ -313,7 +313,7 @@ libunwind_frame_this_id (struct frame_info *this_frame, void **this_cache,\n \n struct value *\n libunwind_frame_prev_register (struct frame_info *this_frame,\n-                               void **this_cache, int regnum)\n+\t\t\t       void **this_cache, int regnum)\n {\n   struct libunwind_frame_cache *cache =\n     libunwind_frame_cache (this_frame, this_cache);\n@@ -352,29 +352,29 @@ libunwind_frame_prev_register (struct frame_info *this_frame,\n \n     case UNW_SLT_REG:\n       val = frame_unwind_got_register (this_frame, regnum,\n-                                       descr->uw2gdb (sl.u.regnum));\n+\t\t\t\t       descr->uw2gdb (sl.u.regnum));\n       break;\n     case UNW_SLT_NONE:\n       {\n-        /* The register is not stored at a specific memory address nor\n-           inside another register.  So use libunwind to fetch the register\n-           value for us, and create a constant value with the result.  */\n-        if (descr->is_fpreg (uw_regnum))\n-          {\n-            ret = unw_get_fpreg_p (&cache->cursor, uw_regnum, &fpval);\n-            if (ret < 0)\n-              return frame_unwind_got_constant (this_frame, regnum, 0);\n-            val = frame_unwind_got_bytes (this_frame, regnum,\n-                                          (gdb_byte *) &fpval);\n-          }\n-        else\n-          {\n-            ret = unw_get_reg_p (&cache->cursor, uw_regnum, &intval);\n-            if (ret < 0)\n-              return frame_unwind_got_constant (this_frame, regnum, 0);\n-            val = frame_unwind_got_constant (this_frame, regnum, intval);\n-          }\n-        break;\n+\t/* The register is not stored at a specific memory address nor\n+\t   inside another register.  So use libunwind to fetch the register\n+\t   value for us, and create a constant value with the result.  */\n+\tif (descr->is_fpreg (uw_regnum))\n+\t  {\n+\t    ret = unw_get_fpreg_p (&cache->cursor, uw_regnum, &fpval);\n+\t    if (ret < 0)\n+\t      return frame_unwind_got_constant (this_frame, regnum, 0);\n+\t    val = frame_unwind_got_bytes (this_frame, regnum,\n+\t\t\t\t\t  (gdb_byte *) &fpval);\n+\t  }\n+\telse\n+\t  {\n+\t    ret = unw_get_reg_p (&cache->cursor, uw_regnum, &intval);\n+\t    if (ret < 0)\n+\t      return frame_unwind_got_constant (this_frame, regnum, 0);\n+\t    val = frame_unwind_got_constant (this_frame, regnum, intval);\n+\t  }\n+\tbreak;\n       }\n     }\n \n@@ -396,8 +396,8 @@ libunwind_search_unwind_table (void *as, long ip, void *di,\n /* Verify if we are in a sigtramp frame and we can use libunwind to unwind.  */\n int\n libunwind_sigtramp_frame_sniffer (const struct frame_unwind *self,\n-                                  struct frame_info *this_frame,\n-                                  void **this_cache)\n+\t\t\t\t  struct frame_info *this_frame,\n+\t\t\t\t  void **this_cache)\n {\n   unw_cursor_t cursor;\n   unw_accessors_t *acc;"
    },
    {
      "sha": "53921fd22245241d0f658051048606cfd58aa0d5",
      "filename": "gdb/ia64-libunwind-tdep.h",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-libunwind-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-libunwind-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-libunwind-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -48,20 +48,20 @@ struct libunwind_descr\n };\n \n int libunwind_frame_sniffer (const struct frame_unwind *self,\n-                             struct frame_info *this_frame,\n-                             void **this_cache);\n-                          \n+\t\t\t     struct frame_info *this_frame,\n+\t\t\t     void **this_cache);\n+\t\t\t  \n int libunwind_sigtramp_frame_sniffer (const struct frame_unwind *self,\n-                                      struct frame_info *this_frame,\n-                                      void **this_cache);\n+\t\t\t\t      struct frame_info *this_frame,\n+\t\t\t\t      void **this_cache);\n \n void libunwind_frame_set_descr (struct gdbarch *arch,\n \t\t\t\tstruct libunwind_descr *descr);\n \n void libunwind_frame_this_id (struct frame_info *this_frame, void **this_cache,\n \t\t\t      struct frame_id *this_id);\n struct value *libunwind_frame_prev_register (struct frame_info *this_frame,\n-                                             void **this_cache, int regnum);\n+\t\t\t\t\t     void **this_cache, int regnum);\n void libunwind_frame_dealloc_cache (struct frame_info *self, void *cache);\n \n int libunwind_is_initialized (void);"
    },
    {
      "sha": "1f82872de6bd7e85fb11e137f310e612452236d6",
      "filename": "gdb/ia64-linux-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -404,7 +404,7 @@ ia64_cannot_store_register (struct gdbarch *gdbarch, int regno)\n   return regno < 0\n \t || regno >= gdbarch_num_regs (gdbarch)\n \t || u_offsets[regno] == -1\n-         || regno == IA64_BSPSTORE_REGNUM;\n+\t || regno == IA64_BSPSTORE_REGNUM;\n }\n \n void\n@@ -542,7 +542,7 @@ ia64_linux_nat_target::enable_watchpoints_in_psr (ptid_t ptid)\n   if (!(psr & IA64_PSR_DB))\n     {\n       psr |= IA64_PSR_DB;\t/* Set the db bit - this enables hardware\n-\t\t\t           watchpoints and breakpoints.  */\n+\t\t\t\t   watchpoints and breakpoints.  */\n       regcache_cooked_write_unsigned (regcache, IA64_PSR_REGNUM, psr);\n     }\n }\n@@ -706,7 +706,7 @@ ia64_linux_nat_target::stopped_data_address (CORE_ADDR *addr_p)\n \n   regcache_cooked_read_unsigned (regcache, IA64_PSR_REGNUM, &psr);\n   psr |= IA64_PSR_DD;\t/* Set the dd bit - this will disable the watchpoint\n-                           for the next instruction.  */\n+\t\t\t   for the next instruction.  */\n   regcache_cooked_write_unsigned (regcache, IA64_PSR_REGNUM, psr);\n \n   *addr_p = (CORE_ADDR) siginfo.si_addr;\n@@ -887,7 +887,7 @@ ia64_linux_nat_target::xfer_partial (enum target_object object,\n \n       /* Probe for the table size once.  */\n       if (gate_table_size == 0)\n-        gate_table_size = syscall (__NR_getunwind, NULL, 0);\n+\tgate_table_size = syscall (__NR_getunwind, NULL, 0);\n       if (gate_table_size < 0)\n \treturn TARGET_XFER_E_IO;\n "
    },
    {
      "sha": "587a455467dafa15fc88cda4f35fb5148918f843",
      "filename": "gdb/ia64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -241,7 +241,7 @@ ia64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* Enable TLS support.  */\n   set_gdbarch_fetch_tls_load_module_address (gdbarch,\n-                                             svr4_fetch_objfile_link_map);\n+\t\t\t\t\t     svr4_fetch_objfile_link_map);\n \n   /* Core file support. */\n   set_gdbarch_iterate_over_regset_sections"
    },
    {
      "sha": "d43b507273ef2909f67a30f1b9556a98e6fada54",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 154,
      "deletions": 154,
      "changes": 308,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -44,19 +44,19 @@\n #include \"ia64-libunwind-tdep.h\"\n \n /* Note: KERNEL_START is supposed to be an address which is not going\n-         to ever contain any valid unwind info.  For ia64 linux, the choice\n-         of 0xc000000000000000 is fairly safe since that's uncached space.\n+\t to ever contain any valid unwind info.  For ia64 linux, the choice\n+\t of 0xc000000000000000 is fairly safe since that's uncached space.\n  \n-         We use KERNEL_START as follows: after obtaining the kernel's\n-         unwind table via getunwind(), we project its unwind data into\n-         address-range KERNEL_START-(KERNEL_START+ktab_size) and then\n-         when ia64_access_mem() sees a memory access to this\n-         address-range, we redirect it to ktab instead.\n+\t We use KERNEL_START as follows: after obtaining the kernel's\n+\t unwind table via getunwind(), we project its unwind data into\n+\t address-range KERNEL_START-(KERNEL_START+ktab_size) and then\n+\t when ia64_access_mem() sees a memory access to this\n+\t address-range, we redirect it to ktab instead.\n \n-         None of this hackery is needed with a modern kernel/libcs\n-         which uses the kernel virtual DSO to provide access to the\n-         kernel's unwind info.  In that case, ktab_size remains 0 and\n-         hence the value of KERNEL_START doesn't matter.  */\n+\t None of this hackery is needed with a modern kernel/libcs\n+\t which uses the kernel virtual DSO to provide access to the\n+\t kernel's unwind info.  In that case, ktab_size remains 0 and\n+\t hence the value of KERNEL_START doesn't matter.  */\n \n #define KERNEL_START 0xc000000000000000ULL\n \n@@ -618,7 +618,7 @@ fetch_instruction (CORE_ADDR addr, instruction_type *it, long long *instr)\n    \n    The current addressing used by the code below:\n    original PC   placed_address   placed_size             required    covered\n-                                  == bp_tgt->shadow_len   reqd \\subset covered\n+\t\t\t\t  == bp_tgt->shadow_len   reqd \\subset covered\n    0xABCDE0      0xABCDE0         0x10                    <0x0...0x5> <0x0..0xF>\n    0xABCDE1      0xABCDE1         0xF                     <0x5...0xA> <0x1..0xF>\n    0xABCDE2      0xABCDE2         0xE                     <0xA...0xF> <0x2..0xF>\n@@ -929,7 +929,7 @@ rse_address_add(CORE_ADDR addr, int nslots)\n \n static enum register_status\n ia64_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n-                           int regnum, gdb_byte *buf)\n+\t\t\t   int regnum, gdb_byte *buf)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   enum register_status status;\n@@ -1033,7 +1033,7 @@ ia64_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n   else if (regnum == VBOF_REGNUM)\n     {\n       /* A virtual register frame start is provided for user convenience.\n-         It can be calculated as the bsp - sof (sizeof frame).  */\n+\t It can be calculated as the bsp - sof (sizeof frame).  */\n       ULONGEST bsp, vbsp;\n       ULONGEST cfm;\n \n@@ -1071,7 +1071,7 @@ ia64_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n \n \t  /* Adjust the register number to account for register rotation.  */\n \t  regnum = VP16_REGNUM \n-\t         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n+\t\t + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n \t}\n       prN_val = (pr & (1LL << (regnum - VP0_REGNUM))) != 0;\n       store_unsigned_integer (buf, register_size (gdbarch, regnum),\n@@ -1192,7 +1192,7 @@ ia64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n \n \t  /* Adjust the register number to account for register rotation.  */\n \t  regnum = VP16_REGNUM \n-\t         + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n+\t\t + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n \t}\n       prN_val = extract_unsigned_integer (buf, register_size (gdbarch, regnum),\n \t\t\t\t\t  byte_order);\n@@ -1237,7 +1237,7 @@ ia64_register_to_value (struct frame_info *frame, int regnum,\n \n static void\n ia64_value_to_register (struct frame_info *frame, int regnum,\n-                         struct type *valtype, const gdb_byte *in)\n+\t\t\t struct type *valtype, const gdb_byte *in)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   gdb_byte out[IA64_FP_REGISTER_SIZE];\n@@ -1285,16 +1285,16 @@ refine_prologue_limit (CORE_ADDR pc, CORE_ADDR lim_pc, int *trust_limit)\n       CORE_ADDR addr = prologue_sal.end;\n \n       /* Handle the case in which compiler's optimizer/scheduler\n-         has moved instructions into the prologue.  We scan ahead\n+\t has moved instructions into the prologue.  We scan ahead\n \t in the function looking for address ranges whose corresponding\n \t line number is less than or equal to the first one that we\n \t found for the function.  (It can be less than when the\n \t scheduler puts a body instruction before the first prologue\n \t instruction.)  */\n       for (i = 2 * max_skip_non_prologue_insns; \n-           i > 0 && (lim_pc == 0 || addr < lim_pc);\n+\t   i > 0 && (lim_pc == 0 || addr < lim_pc);\n \t   i--)\n-        {\n+\t{\n \t  struct symtab_and_line sal;\n \n \t  sal = find_pc_line (addr, 0);\n@@ -1356,8 +1356,8 @@ ia64_alloc_frame_cache (void)\n \n static CORE_ADDR\n examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n-                  struct frame_info *this_frame,\n-                  struct ia64_frame_cache *cache)\n+\t\t  struct frame_info *this_frame,\n+\t\t  struct ia64_frame_cache *cache)\n {\n   CORE_ADDR next_pc;\n   CORE_ADDR last_prologue_pc = pc;\n@@ -1421,12 +1421,12 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n       /* Look for a leaf routine.  */\n       if (pc < lim_pc && next_pc\n \t  && (it == I || it == M) \n-          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))\n+\t  && ((instr & 0x1ee00000000LL) == 0x10800000000LL))\n \t{\n \t  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */\n \t  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) \n-\t                   | ((instr & 0x001f8000000LL) >> 20)\n-\t\t           | ((instr & 0x000000fe000LL) >> 13));\n+\t\t\t   | ((instr & 0x001f8000000LL) >> 20)\n+\t\t\t   | ((instr & 0x000000fe000LL) >> 13));\n \t  int rM = (int) ((instr & 0x00007f00000LL) >> 20);\n \t  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);\n \t  int qp = (int) (instr & 0x0000000003fLL);\n@@ -1473,7 +1473,7 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t  break;\n \t}\n       else if (it == I && ((instr & 0x1eff8000000LL) == 0x00188000000LL))\n-        {\n+\t{\n \t  /* Move from BR */\n \t  int b2 = (int) ((instr & 0x0000000e000LL) >> 13);\n \t  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);\n@@ -1486,12 +1486,12 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    }\n \t}\n       else if ((it == I || it == M) \n-          && ((instr & 0x1ee00000000LL) == 0x10800000000LL))\n+\t  && ((instr & 0x1ee00000000LL) == 0x10800000000LL))\n \t{\n \t  /* adds rN = imm14, rM   (or mov rN, rM  when imm14 is 0) */\n \t  int imm = (int) ((((instr & 0x01000000000LL) ? -1 : 0) << 13) \n-\t                   | ((instr & 0x001f8000000LL) >> 20)\n-\t\t           | ((instr & 0x000000fe000LL) >> 13));\n+\t\t\t   | ((instr & 0x001f8000000LL) >> 20)\n+\t\t\t   | ((instr & 0x000000fe000LL) >> 13));\n \t  int rM = (int) ((instr & 0x00007f00000LL) >> 20);\n \t  int rN = (int) ((instr & 0x00000001fc0LL) >> 6);\n \t  int qp = (int) (instr & 0x0000000003fLL);\n@@ -1509,26 +1509,26 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t      last_prologue_pc = next_pc;\n \t    }\n \t  else if (qp == 0 && rN == 2 \n-\t        && ((rM == fp_reg && fp_reg != 0) || rM == 12))\n+\t\t&& ((rM == fp_reg && fp_reg != 0) || rM == 12))\n \t    {\n \t      CORE_ADDR saved_sp = 0;\n \t      /* adds r2, spilloffset, rFramePointer \n-\t           or\n+\t\t   or\n \t\t adds r2, spilloffset, r12\n \n-\t         Get ready for stf.spill or st8.spill instructions.\n+\t\t Get ready for stf.spill or st8.spill instructions.\n \t\t The address to start spilling at is loaded into r2.\n \t\t FIXME:  Why r2?  That's what gcc currently uses; it\n \t\t could well be different for other compilers.  */\n \n \t      /* Hmm...  whether or not this will work will depend on\n-\t         where the pc is.  If it's still early in the prologue\n+\t\t where the pc is.  If it's still early in the prologue\n \t\t this'll be wrong.  FIXME */\n \t      if (this_frame)\n \t\tsaved_sp = get_frame_register_unsigned (this_frame,\n \t\t\t\t\t\t\tsp_regnum);\n \t      spill_addr  = saved_sp\n-\t                  + (rM == 12 ? 0 : mem_stack_frame_size) \n+\t\t\t  + (rM == 12 ? 0 : mem_stack_frame_size) \n \t\t\t  + imm;\n \t      spill_reg   = rN;\n \t      last_prologue_pc = next_pc;\n@@ -1549,8 +1549,8 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    }\n \t}\n       else if (it == M \n-            && (   ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)\n-                || ((instr & 0x1ffc8000000LL) == 0x0cec0000000LL) ))\n+\t    && (   ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)\n+\t\t|| ((instr & 0x1ffc8000000LL) == 0x0cec0000000LL) ))\n \t{\n \t  /* stf.spill [rN] = fM, imm9\n \t     or\n@@ -1565,15 +1565,15 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    {\n \t      cache->saved_regs[IA64_FR0_REGNUM + fM] = spill_addr;\n \n-              if ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)\n+\t      if ((instr & 0x1efc0000000LL) == 0x0eec0000000LL)\n \t\tspill_addr += imm;\n \t      else\n \t\tspill_addr = 0;\t\t/* last one; must be done.  */\n \t      last_prologue_pc = next_pc;\n \t    }\n \t}\n       else if ((it == M && ((instr & 0x1eff8000000LL) == 0x02110000000LL))\n-            || (it == I && ((instr & 0x1eff8000000LL) == 0x00050000000LL)) )\n+\t    || (it == I && ((instr & 0x1eff8000000LL) == 0x00050000000LL)) )\n \t{\n \t  /* mov.m rN = arM   \n \t       or \n@@ -1602,8 +1602,8 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    }\n \t}\n       else if (it == M \n-            && (   ((instr & 0x1ffc8000000LL) == 0x08cc0000000LL)\n-\t        || ((instr & 0x1efc0000000LL) == 0x0acc0000000LL)))\n+\t    && (   ((instr & 0x1ffc8000000LL) == 0x08cc0000000LL)\n+\t\t|| ((instr & 0x1efc0000000LL) == 0x0acc0000000LL)))\n \t{\n \t  /* st8 [rN] = rM \n \t      or\n@@ -1616,7 +1616,7 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t      && (rM == unat_save_reg || rM == pr_save_reg))\n \t    {\n \t      /* We've found a spill of either the UNAT register or the PR\n-\t         register.  (Well, not exactly; what we've actually found is\n+\t\t register.  (Well, not exactly; what we've actually found is\n \t\t a spill of the register that UNAT or PR was moved to).\n \t\t Record that fact and move on...  */\n \t      if (rM == unat_save_reg)\n@@ -1626,7 +1626,7 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t\t  unat_save_reg = 0;\n \t\t}\n \t      else\n-\t        {\n+\t\t{\n \t\t  /* Track PR register.  */\n \t\t  cache->saved_regs[IA64_PR_REGNUM] = spill_addr;\n \t\t  pr_save_reg = 0;\n@@ -1680,7 +1680,7 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    }\n \t}\n       else if (it == M && ((instr & 0x1ff88000000LL) == 0x0cc80000000LL))\n-        {\n+\t{\n \t  /* Either\n \t       stfs [rN] = fM\n \t     or\n@@ -1697,8 +1697,8 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t    }\n \t}\n       else if (it == M\n-            && (   ((instr & 0x1ffc8000000LL) == 0x08ec0000000LL)\n-\t        || ((instr & 0x1efc0000000LL) == 0x0aec0000000LL)))\n+\t    && (   ((instr & 0x1ffc8000000LL) == 0x08ec0000000LL)\n+\t\t|| ((instr & 0x1efc0000000LL) == 0x0aec0000000LL)))\n \t{\n \t  /* st8.spill [rN] = rM\n \t       or\n@@ -1709,11 +1709,11 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t  if (qp == 0 && rN == spill_reg && 4 <= rM && rM <= 7)\n \t    {\n \t      /* We've found a spill of one of the preserved general purpose\n-\t         regs.  Record the spill address and advance the spill\n+\t\t regs.  Record the spill address and advance the spill\n \t\t register if appropriate.  */\n \t      cache->saved_regs[IA64_GR0_REGNUM + rM] = spill_addr;\n \t      if ((instr & 0x1efc0000000LL) == 0x0aec0000000LL)\n-\t        /* st8.spill [rN] = rM, imm9 */\n+\t\t/* st8.spill [rN] = rM, imm9 */\n \t\tspill_addr += imm9(instr);\n \t      else\n \t\tspill_addr = 0;\t\t/* Done spilling.  */\n@@ -1784,8 +1784,8 @@ examine_prologue (CORE_ADDR pc, CORE_ADDR lim_pc,\n \t  rrb_gr = (cfm >> 18) & 0x7f;\n \n \t  /* The previous bof only requires subtraction of the sol (size of\n-             locals) due to the overlap between output and input of\n-             subsequent frames.  */\n+\t     locals) due to the overlap between output and input of\n+\t     subsequent frames.  */\n \t  bof = rse_address_add (bof, -sol);\n \t  \n \t  for (i = 0, addr = bof;\n@@ -1925,19 +1925,19 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       CORE_ADDR prev_cfm, bsp, prev_bsp;\n \n       /* We want to calculate the previous bsp as the end of the previous\n-         register stack frame.  This corresponds to what the hardware bsp\n-         register will be if we pop the frame back which is why we might\n-         have been called.  We know the beginning of the current frame is\n-         cache->bsp - cache->sof.  This value in the previous frame points\n-         to the start of the output registers.  We can calculate the end of\n-         that frame by adding the size of output:\n-            (sof (size of frame) - sol (size of locals)).  */\n+\t register stack frame.  This corresponds to what the hardware bsp\n+\t register will be if we pop the frame back which is why we might\n+\t have been called.  We know the beginning of the current frame is\n+\t cache->bsp - cache->sof.  This value in the previous frame points\n+\t to the start of the output registers.  We can calculate the end of\n+\t that frame by adding the size of output:\n+\t    (sof (size of frame) - sol (size of locals)).  */\n       val = ia64_frame_prev_register (this_frame, this_cache, IA64_CFM_REGNUM);\n       prev_cfm = extract_unsigned_integer (value_contents_all (val),\n \t\t\t\t\t   8, byte_order);\n       bsp = rse_address_add (cache->bsp, -(cache->sof));\n       prev_bsp =\n-        rse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));\n+\trse_address_add (bsp, (prev_cfm & 0x7f) - ((prev_cfm >> 7) & 0x7f));\n \n       return frame_unwind_got_constant (this_frame, regnum, prev_bsp);\n     }\n@@ -1947,21 +1947,21 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       CORE_ADDR addr = cache->saved_regs[IA64_CFM_REGNUM];\n       \n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n \n       if (cache->prev_cfm)\n-        return frame_unwind_got_constant (this_frame, regnum, cache->prev_cfm);\n+\treturn frame_unwind_got_constant (this_frame, regnum, cache->prev_cfm);\n \n       if (cache->frameless)\n-        return frame_unwind_got_register (this_frame, IA64_PFS_REGNUM,\n-                                          IA64_PFS_REGNUM);\n+\treturn frame_unwind_got_register (this_frame, IA64_PFS_REGNUM,\n+\t\t\t\t\t  IA64_PFS_REGNUM);\n       return frame_unwind_got_register (this_frame, regnum, 0);\n     }\n \n   else if (regnum == IA64_VFP_REGNUM)\n     {\n       /* If the function in question uses an automatic register (r32-r127)\n-         for the frame pointer, it'll be found by ia64_find_saved_register()\n+\t for the frame pointer, it'll be found by ia64_find_saved_register()\n \t above.  If the function lacks one of these frame pointers, we can\n \t still provide a value since we know the size of the frame.  */\n       return frame_unwind_got_constant (this_frame, regnum, cache->base);\n@@ -1973,7 +1973,7 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       ULONGEST prN;\n       \n       pr_val = ia64_frame_prev_register (this_frame, this_cache,\n-                                         IA64_PR_REGNUM);\n+\t\t\t\t\t IA64_PR_REGNUM);\n       if (VP16_REGNUM <= regnum && regnum <= VP63_REGNUM)\n \t{\n \t  /* Fetch predicate register rename base from current frame\n@@ -1984,7 +1984,7 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \t  regnum = VP16_REGNUM + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n \t}\n       prN = extract_bit_field (value_contents_all (pr_val),\n-                               regnum - VP0_REGNUM, 1);\n+\t\t\t       regnum - VP0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, prN);\n     }\n \n@@ -1993,17 +1993,17 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       struct value *unat_val;\n       ULONGEST unatN;\n       unat_val = ia64_frame_prev_register (this_frame, this_cache,\n-                                           IA64_UNAT_REGNUM);\n+\t\t\t\t\t   IA64_UNAT_REGNUM);\n       unatN = extract_bit_field (value_contents_all (unat_val),\n-                                 regnum - IA64_NAT0_REGNUM, 1);\n+\t\t\t\t regnum - IA64_NAT0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, unatN);\n     }\n \n   else if (IA64_NAT32_REGNUM <= regnum && regnum <= IA64_NAT127_REGNUM)\n     {\n       int natval = 0;\n       /* Find address of general register corresponding to nat bit we're\n-         interested in.  */\n+\t interested in.  */\n       CORE_ADDR gr_addr;\n \n       gr_addr = cache->saved_regs[regnum - IA64_NAT0_REGNUM + IA64_GR0_REGNUM];\n@@ -2041,10 +2041,10 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       CORE_ADDR addr = cache->saved_regs[IA64_VRAP_REGNUM];\n \n       if (addr != 0)\n-        {\n-          read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));\n-          pc = extract_unsigned_integer (buf, 8, byte_order);\n-        }\n+\t{\n+\t  read_memory (addr, buf, register_size (gdbarch, IA64_IP_REGNUM));\n+\t  pc = extract_unsigned_integer (buf, 8, byte_order);\n+\t}\n       else if (cache->frameless)\n \t{\n \t  get_frame_register (this_frame, IA64_BR0_REGNUM, buf);\n@@ -2057,9 +2057,9 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n   else if (regnum == IA64_PSR_REGNUM)\n     {\n       /* We don't know how to get the complete previous PSR, but we need it\n-         for the slot information when we unwind the pc (pc is formed of IP\n-         register plus slot information from PSR).  To get the previous\n-         slot information, we mask it off the return address.  */\n+\t for the slot information when we unwind the pc (pc is formed of IP\n+\t register plus slot information from PSR).  To get the previous\n+\t slot information, we mask it off the return address.  */\n       ULONGEST slot_num = 0;\n       CORE_ADDR pc = 0;\n       CORE_ADDR psr = 0;\n@@ -2089,44 +2089,44 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       CORE_ADDR addr = cache->saved_regs[IA64_BR0_REGNUM];\n \n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n \n       return frame_unwind_got_constant (this_frame, regnum, 0);\n     }\n \n   else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM)\n-           || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))\n+\t   || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))\n     {\n       CORE_ADDR addr = 0;\n \n       if (regnum >= V32_REGNUM)\n \tregnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);\n       addr = cache->saved_regs[regnum];\n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n \n       if (cache->frameless)\n-        {\n-          struct value *reg_val;\n-          CORE_ADDR prev_cfm, prev_bsp, prev_bof;\n+\t{\n+\t  struct value *reg_val;\n+\t  CORE_ADDR prev_cfm, prev_bsp, prev_bof;\n \n-          /* FIXME: brobecker/2008-05-01: Doesn't this seem redundant\n-             with the same code above?  */\n+\t  /* FIXME: brobecker/2008-05-01: Doesn't this seem redundant\n+\t     with the same code above?  */\n \t  if (regnum >= V32_REGNUM)\n \t    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);\n-          reg_val = ia64_frame_prev_register (this_frame, this_cache,\n-                                              IA64_CFM_REGNUM);\n+\t  reg_val = ia64_frame_prev_register (this_frame, this_cache,\n+\t\t\t\t\t      IA64_CFM_REGNUM);\n \t  prev_cfm = extract_unsigned_integer (value_contents_all (reg_val),\n-                                               8, byte_order);\n+\t\t\t\t\t       8, byte_order);\n \t  reg_val = ia64_frame_prev_register (this_frame, this_cache,\n-                                              IA64_BSP_REGNUM);\n+\t\t\t\t\t      IA64_BSP_REGNUM);\n \t  prev_bsp = extract_unsigned_integer (value_contents_all (reg_val),\n-                                               8, byte_order);\n+\t\t\t\t\t       8, byte_order);\n \t  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));\n \n \t  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));\n-          return frame_unwind_got_memory (this_frame, regnum, addr);\n-        }\n+\t  return frame_unwind_got_memory (this_frame, regnum, addr);\n+\t}\n       \n       return frame_unwind_got_constant (this_frame, regnum, 0);\n     }\n@@ -2144,16 +2144,16 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \t  /* Adjust the floating point register number to account for\n \t     register rotation.  */\n \t  regnum = IA64_FR32_REGNUM\n-\t         + ((regnum - IA64_FR32_REGNUM) + rrb_fr) % 96;\n+\t\t + ((regnum - IA64_FR32_REGNUM) + rrb_fr) % 96;\n \t}\n \n       /* If we have stored a memory address, access the register.  */\n       addr = cache->saved_regs[regnum];\n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n       /* Otherwise, punt and get the current value of the register.  */\n       else \n-        return frame_unwind_got_register (this_frame, regnum, regnum);\n+\treturn frame_unwind_got_register (this_frame, regnum, regnum);\n     }\n }\n  \n@@ -2263,8 +2263,8 @@ ia64_sigtramp_frame_this_id (struct frame_info *this_frame,\n     ia64_sigtramp_frame_cache (this_frame, this_cache);\n \n   (*this_id) = frame_id_build_special (cache->base,\n-                                       get_frame_pc (this_frame),\n-                                       cache->bsp);\n+\t\t\t\t       get_frame_pc (this_frame),\n+\t\t\t\t       cache->bsp);\n   if (gdbarch_debug >= 1)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"sigtramp frame id: code %s, stack %s, \"\n@@ -2303,15 +2303,15 @@ ia64_sigtramp_frame_prev_register (struct frame_info *this_frame,\n     }\n \n   else if ((regnum >= IA64_GR32_REGNUM && regnum <= IA64_GR127_REGNUM)\n-           || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))\n+\t   || (regnum >= V32_REGNUM && regnum <= V127_REGNUM))\n     {\n       CORE_ADDR addr = 0;\n \n       if (regnum >= V32_REGNUM)\n \tregnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);\n       addr = cache->saved_regs[regnum];\n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n \n       return frame_unwind_got_constant (this_frame, regnum, 0);\n     }\n@@ -2321,16 +2321,16 @@ ia64_sigtramp_frame_prev_register (struct frame_info *this_frame,\n       CORE_ADDR addr = cache->saved_regs[regnum];\n \n       if (addr != 0)\n-        return frame_unwind_got_memory (this_frame, regnum, addr);\n+\treturn frame_unwind_got_memory (this_frame, regnum, addr);\n \n       return frame_unwind_got_constant (this_frame, regnum, 0);\n     }\n }\n \n static int\n ia64_sigtramp_frame_sniffer (const struct frame_unwind *self,\n-                             struct frame_info *this_frame,\n-                             void **this_cache)\n+\t\t\t     struct frame_info *this_frame,\n+\t\t\t     void **this_cache)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n   if (tdep->pc_in_sigtramp)\n@@ -2583,7 +2583,7 @@ ia64_access_rse_reg (unw_addr_space_t as, unw_regnum_t uw_regnum,\n \tbreak;\n \n       default:\n-        /* For all other registers, just unwind the value directly.  */\n+\t/* For all other registers, just unwind the value directly.  */\n \tregcache_cooked_read_unsigned (regcache, regnum, val);\n \tbreak;\n     }\n@@ -2623,12 +2623,12 @@ ia64_access_mem (unw_addr_space_t as,\n   if (addr - KERNEL_START < ktab_size)\n     {\n       unw_word_t *laddr = (unw_word_t*) ((char *) ktab\n-                          + (addr - KERNEL_START));\n+\t\t\t  + (addr - KERNEL_START));\n \t\t\n       if (write)\n-        *laddr = *val; \n+\t*laddr = *val; \n       else \n-        *val = *laddr;\n+\t*val = *laddr;\n       return 0;\n     }\n \n@@ -2671,7 +2671,7 @@ get_kernel_table (unw_word_t ip, unw_dyn_info_t *di)\n       ktab_size = ktab_buf->size ();\n \n       for (etab = ktab; etab->start_offset; ++etab)\n-        etab->info_offset += KERNEL_START;\n+\tetab->info_offset += KERNEL_START;\n     }\n   \n   if (ip < ktab[0].start_offset || ip >= etab[-1].end_offset)\n@@ -2748,18 +2748,18 @@ ia64_find_unwind_table (struct objfile *objfile, unw_word_t ip,\n     {\n       int ok = 0;\n       for (i = 0; i < ehdr->e_phnum; ++i)\n-        {\n-          if (phdr[i].p_type == PT_LOAD\n+\t{\n+\t  if (phdr[i].p_type == PT_LOAD\n \t      && (p_unwind->p_vaddr - phdr[i].p_vaddr) < phdr[i].p_memsz)\n \t    {\n-              ok = 1;\n+\t      ok = 1;\n \t      /* Get the segbase from the section containing the\n \t\t libunwind table.  */\n \t      segbase = phdr[i].p_vaddr + load_base;\n \t    }\n \t}\n       if (!ok)\n-        return -UNW_ENOINFO;\n+\treturn -UNW_ENOINFO;\n     }\n \n   dip->start_ip = p_text->p_vaddr + load_base;\n@@ -2962,7 +2962,7 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n       ULONGEST unatN_val;\n \n       unatN_val = extract_bit_field (value_contents_all (val),\n-                                     regnum - IA64_NAT0_REGNUM, 1);\n+\t\t\t\t     regnum - IA64_NAT0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, unatN_val);\n     }\n \n@@ -2972,14 +2972,14 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n       CORE_ADDR prev_bsp, prev_cfm;\n \n       /* We want to calculate the previous bsp as the end of the previous\n-         register stack frame.  This corresponds to what the hardware bsp\n-         register will be if we pop the frame back which is why we might\n-         have been called.  We know that libunwind will pass us back the\n-         beginning of the current frame so we should just add sof to it.  */\n+\t register stack frame.  This corresponds to what the hardware bsp\n+\t register will be if we pop the frame back which is why we might\n+\t have been called.  We know that libunwind will pass us back the\n+\t beginning of the current frame so we should just add sof to it.  */\n       prev_bsp = extract_unsigned_integer (value_contents_all (val),\n \t\t\t\t\t   8, byte_order);\n       cfm_val = libunwind_frame_prev_register (this_frame, this_cache,\n-                                               IA64_CFM_REGNUM);\n+\t\t\t\t\t       IA64_CFM_REGNUM);\n       prev_cfm = extract_unsigned_integer (value_contents_all (cfm_val),\n \t\t\t\t\t   8, byte_order);\n       prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));\n@@ -2992,8 +2992,8 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n \n static int\n ia64_libunwind_frame_sniffer (const struct frame_unwind *self,\n-                              struct frame_info *this_frame,\n-                              void **this_cache)\n+\t\t\t      struct frame_info *this_frame,\n+\t\t\t      void **this_cache)\n {\n   if (libunwind_is_initialized ()\n       && libunwind_frame_sniffer (self, this_frame, this_cache))\n@@ -3015,7 +3015,7 @@ static const struct frame_unwind ia64_libunwind_frame_unwind =\n \n static void\n ia64_libunwind_sigtramp_frame_this_id (struct frame_info *this_frame,\n-                                       void **this_cache,\n+\t\t\t\t       void **this_cache,\n \t\t\t\t       struct frame_id *this_id)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n@@ -3061,29 +3061,29 @@ ia64_libunwind_sigtramp_frame_prev_register (struct frame_info *this_frame,\n   /* If the previous frame pc value is 0, then we want to use the SIGCONTEXT\n      method of getting previous registers.  */\n   prev_ip_val = libunwind_frame_prev_register (this_frame, this_cache,\n-                                               IA64_IP_REGNUM);\n+\t\t\t\t\t       IA64_IP_REGNUM);\n   prev_ip = extract_unsigned_integer (value_contents_all (prev_ip_val),\n \t\t\t\t      8, byte_order);\n \n   if (prev_ip == 0)\n     {\n       void *tmp_cache = NULL;\n       return ia64_sigtramp_frame_prev_register (this_frame, &tmp_cache,\n-                                                regnum);\n+\t\t\t\t\t\tregnum);\n     }\n   else\n     return ia64_libunwind_frame_prev_register (this_frame, this_cache, regnum);\n }\n \n static int\n ia64_libunwind_sigtramp_frame_sniffer (const struct frame_unwind *self,\n-                                       struct frame_info *this_frame,\n-                                       void **this_cache)\n+\t\t\t\t       struct frame_info *this_frame,\n+\t\t\t\t       void **this_cache)\n {\n   if (libunwind_is_initialized ())\n     {\n       if (libunwind_sigtramp_frame_sniffer (self, this_frame, this_cache))\n-        return 1;\n+\treturn 1;\n       return 0;\n     }\n   else\n@@ -3174,7 +3174,7 @@ static int\n ia64_struct_type_p (const struct type *type)\n {\n   return (type->code () == TYPE_CODE_STRUCT\n-          || type->code () == TYPE_CODE_UNION);\n+\t  || type->code () == TYPE_CODE_UNION);\n }\n \n static void\n@@ -3204,8 +3204,8 @@ ia64_extract_return_value (struct type *type, struct regcache *regcache,\n   else if (!ia64_struct_type_p (type) && TYPE_LENGTH (type) < 8)\n     {\n       /* This is an integral value, and its size is less than 8 bytes.\n-         These values are LSB-aligned, so extract the relevant bytes,\n-         and copy them into VALBUF.  */\n+\t These values are LSB-aligned, so extract the relevant bytes,\n+\t and copy them into VALBUF.  */\n       /* brobecker/2005-12-30: Actually, all integral values are LSB aligned,\n \t so I suppose we should also add handling here for integral values\n \t whose size is greater than 8.  But I wasn't able to create such\n@@ -3236,7 +3236,7 @@ ia64_extract_return_value (struct type *type, struct regcache *regcache,\n \n       if (m)\n \t{\n-          regcache_cooked_read_unsigned (regcache, regnum, &val);\n+\t  regcache_cooked_read_unsigned (regcache, regnum, &val);\n \t  memcpy ((char *)valbuf + offset, &val, m);\n \t}\n     }\n@@ -3287,7 +3287,7 @@ ia64_store_return_value (struct type *type, struct regcache *regcache,\n \t{\n \t  ULONGEST val;\n \t  memcpy (&val, (char *)valbuf + offset, m);\n-          regcache_cooked_write_unsigned (regcache, regnum, val);\n+\t  regcache_cooked_write_unsigned (regcache, regnum, val);\n \t}\n     }\n }\n@@ -3604,7 +3604,7 @@ ia64_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr,\n       struct obj_section *pc_section = find_pc_section (pc);\n \n       if (pc_section && (pc_section->the_bfd_section->flags & SEC_CODE))\n-        return pc;\n+\treturn pc;\n     }\n \n   /* There are also descriptors embedded in vtables.  */\n@@ -3741,8 +3741,8 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       /* Special handling for function parameters.  */\n       if (len == 8\n-          && type->code () == TYPE_CODE_PTR\n-          && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n+\t  && type->code () == TYPE_CODE_PTR\n+\t  && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n \t{\n \t  gdb_byte val_buf[8];\n \t  ULONGEST faddr = extract_unsigned_integer (value_contents (arg),\n@@ -3771,30 +3771,30 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  gdb_byte val_buf[8];\n \n \t  memset (val_buf, 0, 8);\n-          if (!ia64_struct_type_p (type) && len < 8)\n-            {\n-              /* Integral types are LSB-aligned, so we have to be careful\n-                 to insert the argument on the correct side of the buffer.\n-                 This is why we use store_unsigned_integer.  */\n-              store_unsigned_integer\n-                (val_buf, 8, byte_order,\n-                 extract_unsigned_integer (value_contents (arg), len,\n+\t  if (!ia64_struct_type_p (type) && len < 8)\n+\t    {\n+\t      /* Integral types are LSB-aligned, so we have to be careful\n+\t\t to insert the argument on the correct side of the buffer.\n+\t\t This is why we use store_unsigned_integer.  */\n+\t      store_unsigned_integer\n+\t\t(val_buf, 8, byte_order,\n+\t\t extract_unsigned_integer (value_contents (arg), len,\n \t\t\t\t\t   byte_order));\n-            }\n-          else\n-            {\n-              /* This is either an 8bit integral type, or an aggregate.\n-                 For 8bit integral type, there is no problem, we just\n-                 copy the value over.\n-\n-                 For aggregates, the only potentially tricky portion\n-                 is to write the last one if it is less than 8 bytes.\n-                 In this case, the data is Byte0-aligned.  Happy news,\n-                 this means that we don't need to differentiate the\n-                 handling of 8byte blocks and less-than-8bytes blocks.  */\n-              memcpy (val_buf, value_contents (arg) + argoffset,\n-                      (len > 8) ? 8 : len);\n-            }\n+\t    }\n+\t  else\n+\t    {\n+\t      /* This is either an 8bit integral type, or an aggregate.\n+\t\t For 8bit integral type, there is no problem, we just\n+\t\t copy the value over.\n+\n+\t\t For aggregates, the only potentially tricky portion\n+\t\t is to write the last one if it is less than 8 bytes.\n+\t\t In this case, the data is Byte0-aligned.  Happy news,\n+\t\t this means that we don't need to differentiate the\n+\t\t handling of 8byte blocks and less-than-8bytes blocks.  */\n+\t      memcpy (val_buf, value_contents (arg) + argoffset,\n+\t\t      (len > 8) ? 8 : len);\n+\t    }\n \n \t  if (slotnum < rseslots)\n \t    tdep->infcall_ops.store_argument_in_slot (regcache, bsp,\n@@ -3985,7 +3985,7 @@ ia64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   set_gdbarch_unwind_pc (gdbarch, ia64_unwind_pc);\n #ifdef HAVE_LIBUNWIND_IA64_H\n   frame_unwind_append_unwinder (gdbarch,\n-                                &ia64_libunwind_sigtramp_frame_unwind);\n+\t\t\t\t&ia64_libunwind_sigtramp_frame_unwind);\n   frame_unwind_append_unwinder (gdbarch, &ia64_libunwind_frame_unwind);\n   frame_unwind_append_unwinder (gdbarch, &ia64_sigtramp_frame_unwind);\n   libunwind_frame_set_descr (gdbarch, &ia64_libunwind_descr);"
    },
    {
      "sha": "297a3da62bd999b8b5b58fd1fa289848fe646407",
      "filename": "gdb/ia64-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.h?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -219,7 +219,7 @@ struct ia64_infcall_ops\n   /* Store the argument stored in BUF into the appropriate location\n      given the BSP and the SLOTNUM.  */\n   void (*store_argument_in_slot) (struct regcache *regcache, CORE_ADDR bsp,\n-                                  int slotnum, gdb_byte *buf);\n+\t\t\t\t  int slotnum, gdb_byte *buf);\n \n   /* For targets where we cannot call the function directly, store\n      the address of the function we want to call at the location"
    },
    {
      "sha": "a284d72c330fc94c4af7f98821281fa61a2f8c34",
      "filename": "gdb/ia64-vms-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-vms-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ia64-vms-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-vms-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -31,8 +31,8 @@\n \n static int\n ia64_vms_find_proc_info_x (unw_addr_space_t as, unw_word_t ip,\n-                           unw_proc_info_t *pi,\n-                           int need_unwind_info, void *arg)\n+\t\t\t   unw_proc_info_t *pi,\n+\t\t\t   int need_unwind_info, void *arg)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n   gdb_byte buf[32];\n@@ -42,7 +42,7 @@ ia64_vms_find_proc_info_x (unw_addr_space_t as, unw_word_t ip,\n   unsigned int info_len;\n \n   res = target_read (current_top_target (), TARGET_OBJECT_OPENVMS_UIB,\n-                     annex + 2, buf, 0, sizeof (buf));\n+\t\t     annex + 2, buf, 0, sizeof (buf));\n \n   if (res != sizeof (buf))\n     return -UNW_ENOINFO;\n@@ -75,7 +75,7 @@ ia64_vms_find_proc_info_x (unw_addr_space_t as, unw_word_t ip,\n   pi->unwind_info = xmalloc (pi->unwind_info_size);\n \n   res = target_read_memory (table_addr + 8,\n-                            (gdb_byte *) pi->unwind_info, pi->unwind_info_size);\n+\t\t\t    (gdb_byte *) pi->unwind_info, pi->unwind_info_size);\n   if (res != 0)\n     {\n       xfree (pi->unwind_info);\n@@ -103,7 +103,7 @@ ia64_vms_find_proc_info_x (unw_addr_space_t as, unw_word_t ip,\n \n static void\n ia64_vms_put_unwind_info (unw_addr_space_t as,\n-                          unw_proc_info_t *pip, void *arg)\n+\t\t\t  unw_proc_info_t *pip, void *arg)\n {\n   /* Nothing required for now.  */\n }\n@@ -113,7 +113,7 @@ ia64_vms_put_unwind_info (unw_addr_space_t as,\n \n static int\n ia64_vms_get_dyn_info_list (unw_addr_space_t as,\n-                            unw_word_t *dilap, void *arg)\n+\t\t\t    unw_word_t *dilap, void *arg)\n {\n   return -UNW_ENOINFO;\n }"
    },
    {
      "sha": "4239acb17f74567a11e7065aa8095faff6cdad3e",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -48,7 +48,7 @@\n    we print this instead.  */\n #define RAW_FUNCTION_ADDRESS_FORMAT \"at 0x%s\"\n #define RAW_FUNCTION_ADDRESS_SIZE (sizeof (RAW_FUNCTION_ADDRESS_FORMAT) \\\n-                                   + 2 * sizeof (CORE_ADDR))\n+\t\t\t\t   + 2 * sizeof (CORE_ADDR))\n \n /* NOTE: cagney/2003-04-16: What's the future of this code?\n \n@@ -198,8 +198,8 @@ value_arg_coerce (struct gdbarch *gdbarch, struct value *arg,\n \t    type = builtin->builtin_int;\n \t}\n       /* Currently all target ABIs require at least the width of an integer\n-         type for an argument.  We may have to conditionalize the following\n-         type coercion for future targets.  */\n+\t type for an argument.  We may have to conditionalize the following\n+\t type coercion for future targets.  */\n       if (TYPE_LENGTH (type) < TYPE_LENGTH (builtin->builtin_int))\n \ttype = builtin->builtin_int;\n       break;\n@@ -217,8 +217,8 @@ value_arg_coerce (struct gdbarch *gdbarch, struct value *arg,\n       break;\n     case TYPE_CODE_ARRAY:\n       /* Arrays are coerced to pointers to their first element, unless\n-         they are vectors, in which case we want to leave them alone,\n-         because they are passed by value.  */\n+\t they are vectors, in which case we want to leave them alone,\n+\t because they are passed by value.  */\n       if (current_language->c_style_arrays_p ())\n \tif (!type->is_vector ())\n \t  type = lookup_pointer_type (TYPE_TARGET_TYPE (type));\n@@ -306,7 +306,7 @@ find_function_addr (struct value *function,\n   else if (ftype->code () == TYPE_CODE_INT)\n     {\n       /* Handle the case of functions lacking debugging info.\n-         Their values are characters since their addresses are char.  */\n+\t Their values are characters since their addresses are char.  */\n       if (TYPE_LENGTH (ftype) == 1)\n \tfunaddr = value_as_address (value_addr (function));\n       else\n@@ -903,8 +903,8 @@ call_function_by_hand_dummy (struct value *function,\n \t do is add FRAME_ALIGN() to the architecture vector.  If that\n \t fails, try dummy_id().\n \n-         If the ABI specifies a \"Red Zone\" (see the doco) the code\n-         below will quietly trash it.  */\n+\t If the ABI specifies a \"Red Zone\" (see the doco) the code\n+\t below will quietly trash it.  */\n       sp = old_sp;\n \n     /* Skip over the stack temporaries that might have been generated during\n@@ -914,7 +914,7 @@ call_function_by_hand_dummy (struct value *function,\n \tstruct value *lastval;\n \n \tlastval = get_last_thread_stack_temporary (call_thread.get ());\n-        if (lastval != NULL)\n+\tif (lastval != NULL)\n \t  {\n \t    CORE_ADDR lastval_addr = value_address (lastval);\n \n@@ -1327,13 +1327,13 @@ call_function_by_hand_dummy (struct value *function,\n   if (e.reason < 0)\n     {\n       const char *name = get_function_name (funaddr,\n-                                            name_buf, sizeof (name_buf));\n+\t\t\t\t\t    name_buf, sizeof (name_buf));\n \n       discard_infcall_control_state (inf_status.release ());\n \n       /* We could discard the dummy frame here if the program exited,\n-         but it will get garbage collected the next time the program is\n-         run anyway.  */\n+\t but it will get garbage collected the next time the program is\n+\t run anyway.  */\n \n       switch (e.reason)\n \t{\n@@ -1363,8 +1363,8 @@ When the function is done executing, GDB will silently stop.\"),\n       discard_infcall_control_state (inf_status.release ());\n \n       /* We could discard the dummy frame here given that the program exited,\n-         but it will get garbage collected the next time the program is\n-         run anyway.  */\n+\t but it will get garbage collected the next time the program is\n+\t run anyway.  */\n \n       error (_(\"The program being debugged exited while in a function \"\n \t       \"called from GDB.\\n\""
    },
    {
      "sha": "a5d190ed8483854ed89b97aaec79bc8041357e57",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -131,7 +131,7 @@ get_inferior_args (void)\n   if (current_inferior ()->argc != 0)\n     {\n       gdb::array_view<char * const> args (current_inferior ()->argv,\n-                                          current_inferior ()->argc);\n+\t\t\t\t\t  current_inferior ()->argc);\n       std::string n = construct_inferior_arguments (args);\n       set_inferior_args (n.c_str ());\n     }\n@@ -1896,7 +1896,7 @@ info_program_command (const char *args, int from_tty)\n   else if (stat != 0)\n     {\n       /* There may be several breakpoints in the same place, so this\n-         isn't as strange as it seems.  */\n+\t isn't as strange as it seems.  */\n       while (stat != 0)\n \t{\n \t  if (stat < 0)\n@@ -1972,14 +1972,14 @@ set_environment_command (const char *arg, int from_tty)\n   if (p != 0 && val != 0)\n     {\n       /* We have both a space and an equals.  If the space is before the\n-         equals, walk forward over the spaces til we see a nonspace \n-         (possibly the equals).  */\n+\t equals, walk forward over the spaces til we see a nonspace \n+\t (possibly the equals).  */\n       if (p > val)\n \twhile (*val == ' ')\n \t  val++;\n \n       /* Now if the = is after the char following the spaces,\n-         take the char following the spaces.  */\n+\t take the char following the spaces.  */\n       if (p > val)\n \tp = val - 1;\n     }\n@@ -2024,7 +2024,7 @@ unset_environment_command (const char *var, int from_tty)\n   if (var == 0)\n     {\n       /* If there is no argument, delete all environment variables.\n-         Ask for confirmation if reading from the terminal.  */\n+\t Ask for confirmation if reading from the terminal.  */\n       if (!from_tty || query (_(\"Delete all environment variables? \")))\n \tcurrent_inferior ()->environment.clear ();\n     }\n@@ -2091,7 +2091,7 @@ default_print_one_register_info (struct ui_file *file,\n     {\n       value_column_1 = 15,\n       /* Give enough room for \"0x\", 16 hex digits and two spaces in\n-         preceding column.  */\n+\t preceding column.  */\n       value_column_2 = value_column_1 + 2 + 16 + 2,\n     };\n \n@@ -2170,7 +2170,7 @@ default_print_registers_info (struct gdbarch *gdbarch,\n   for (i = 0; i < numregs; i++)\n     {\n       /* Decide between printing all regs, non-float / vector regs, or\n-         specific reg.  */\n+\t specific reg.  */\n       if (regnum == -1)\n \t{\n \t  if (print_all)\n@@ -2191,7 +2191,7 @@ default_print_registers_info (struct gdbarch *gdbarch,\n \t}\n \n       /* If the register name is empty, it is undefined for this\n-         processor, so don't display anything.  */\n+\t processor, so don't display anything.  */\n       if (gdbarch_register_name (gdbarch, i) == NULL\n \t  || *(gdbarch_register_name (gdbarch, i)) == '\\0')\n \tcontinue;\n@@ -2229,7 +2229,7 @@ registers_info (const char *addr_exp, int fpregs)\n       addr_exp = skip_spaces (addr_exp);\n \n       /* Discard any leading ``$''.  Check that there is something\n-         resembling a register following it.  */\n+\t resembling a register following it.  */\n       if (addr_exp[0] == '$')\n \taddr_exp++;\n       if (isspace ((*addr_exp)) || (*addr_exp) == '\\0')"
    },
    {
      "sha": "d4a783b3e6db755f106e6266dcc1449db0a9e1df",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=dda83cd783075941aabe9b0292b004b11f00c831",
      "patch": "@@ -1018,12 +1018,12 @@ The new inferior ID must be currently known.\"),\n \t   &cmdlist);\n \n   add_setshow_boolean_cmd (\"inferior-events\", no_class,\n-         &print_inferior_events, _(\"\\\n+\t &print_inferior_events, _(\"\\\n Set printing of inferior events (such as inferior start and exit).\"), _(\"\\\n Show printing of inferior events (such as inferior start and exit).\"), NULL,\n-         NULL,\n-         show_print_inferior_events,\n-         &setprintlist, &showprintlist);\n+\t NULL,\n+\t show_print_inferior_events,\n+\t &setprintlist, &showprintlist);\n \n   create_internalvar_type_lazy (\"_inferior\", &inferior_funcs, NULL);\n }"
    },
    {
      "sha": "990f40aa6262ba1d2b29ad013f857b7b9709f079",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "499f1b7188f088f976e77dd86bd0eb4f089eb8b4",
      "filename": "gdb/iq2000-tdep.c",
      "status": "modified",
      "additions": 73,
      "deletions": 73,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/iq2000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/iq2000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/iq2000-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "1a0e20ea95037d39d9b870a50e40d3f2a635bc1d",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "74560953d71747765577c1845bd2cf39827c8610",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "98b8771216cc834929d41941b5f7368507f17c80",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "f1b2c744bed9be01ff21a74e86d2a45b60d4eb65",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "bacb61398fab6e384da3db3e50e3313f7dcee560",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "4c04aa4ceb670798883549d3f1f35d3f8d3b3f80",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9c89de2d24e9219a53c2f4e702a58876a0f5258d",
      "filename": "gdb/lm32-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/lm32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/lm32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/lm32-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "f6f11126c6901770358ebaf47bb816f17f25665a",
      "filename": "gdb/m2-exp.y",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "1ede3ae78c34113b4c463ebef3c3f7a3a7c5012b",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "8fbcdf4c603cc806b7df7d67713900ba7d61b72a",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "96dc18119cf2898eda67f03c26c57cdb51e88549",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "ca618de113ba322793e8e7f7c53da628fd1d5aba",
      "filename": "gdb/m32c-tdep.c",
      "status": "modified",
      "additions": 65,
      "deletions": 65,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32c-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32c-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32c-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "60a52e60b6ede3bd57e20a6c2e58d333ae37c862",
      "filename": "gdb/m32r-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32r-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32r-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "96a2549e751d068eba631d58a9ecd9d46b6846e3",
      "filename": "gdb/m32r-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32r-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m32r-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "07bf4cbbf7d26e726929db273b7be87ee251acbc",
      "filename": "gdb/m68hc11-tdep.c",
      "status": "modified",
      "additions": 218,
      "deletions": 218,
      "changes": 436,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68hc11-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68hc11-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68hc11-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "890718bcafb7d565cddf938208b2996cbc8634cc",
      "filename": "gdb/m68k-bsd-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-bsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "c799c6d41864197f34c82830ac0021b85a4f5dee",
      "filename": "gdb/m68k-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "63dd53e71d6d5cc0367b962dabd6e63a983cf3b8",
      "filename": "gdb/m68k-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "083e6ef5cb856f7364b058f111ccf7fd6ad6fbb5",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "079b6e72f177e53af492ad9e17ea4426741a6de7",
      "filename": "gdb/machoread.c",
      "status": "modified",
      "additions": 326,
      "deletions": 326,
      "changes": 652,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/machoread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/machoread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/machoread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "fba2f40e0545d17b3ee68aad8acbe8b9b933608f",
      "filename": "gdb/macrocmd.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrocmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrocmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macrocmd.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "68fb19671617557b32ebf91b449c78a7ce99dbc2",
      "filename": "gdb/macroexp.c",
      "status": "modified",
      "additions": 226,
      "deletions": 226,
      "changes": 452,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macroexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macroexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroexp.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "996a6c94245078f15cc234eddf6dc714f9c8c682",
      "filename": "gdb/macroscope.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macroscope.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macroscope.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroscope.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "4a2892558eb2f8f5c7b8a5d630500e594e7d44ca",
      "filename": "gdb/macrotab.c",
      "status": "modified",
      "additions": 166,
      "deletions": 166,
      "changes": 332,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrotab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrotab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macrotab.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "871596a003e9acfc97925e7ad92e999ea887e738",
      "filename": "gdb/macrotab.h",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrotab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/macrotab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macrotab.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "7b44bfee36690441b38eb5f3625142e5e502e98f",
      "filename": "gdb/main.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/main.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "c67dd71ef60512dac1f2c5d59d0fc657b7ecb911",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 295,
      "deletions": 295,
      "changes": 590,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "b3bf2e8d6e8f43b4817c8a215059b347496d80a9",
      "filename": "gdb/mep-tdep.c",
      "status": "modified",
      "additions": 300,
      "deletions": 300,
      "changes": 600,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mep-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mep-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mep-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "28eb960560d6d9b10d3fa9816e4237e4d44b92b3",
      "filename": "gdb/mi/mi-cmd-catch.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-catch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-catch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-catch.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "aa61db523525220478b7314644519a76e4bcbffd",
      "filename": "gdb/mi/mi-cmd-disas.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-disas.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-disas.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-disas.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9621e21fc34c04c2745d860329c179308732a87b",
      "filename": "gdb/mi/mi-cmd-env.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-env.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-env.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-env.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "ea7ea8d4d4674fec90f3ae33fc688459f1127078",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "178eeec8e7d97796aeee4107d910c694adfa1c58",
      "filename": "gdb/mi/mi-cmd-var.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-var.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmd-var.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-var.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "b63a6db8f6cdf2520faca3bd3ef40a40f79a578d",
      "filename": "gdb/mi/mi-cmds.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmds.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "63ade2934cb40e7596f209d1aa4ed83f6857f550",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "0a5e2400d84a9728e84a6548ef782ebe51032926",
      "filename": "gdb/mi/mi-parse.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mi/mi-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-parse.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "16e92b574e6bc0c3167d1f0989debdd100c15ebc",
      "filename": "gdb/microblaze-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/microblaze-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/microblaze-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/microblaze-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "aebbaf9aa772b7e04c6b3ba5f5fb65b91d03fefe",
      "filename": "gdb/minidebug.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/minidebug.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/minidebug.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minidebug.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "70800a9d8390c5420af14c2d8cf4c373bca3c6f0",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "156672075365b348de81f3ff4d4bdc413a1a8c1f",
      "filename": "gdb/mips-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "aa2bd53348d21e399fcfe4b6c9ff5f41648d70b0",
      "filename": "gdb/mips-linux-tdep.c",
      "status": "modified",
      "additions": 34,
      "deletions": 34,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "17e841c085d9a7a60844d8a001776b2a4f40a85f",
      "filename": "gdb/mips-netbsd-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "666b18cd4630d11e00dd5376980d7e440f0d7829",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 219,
      "deletions": 219,
      "changes": 438,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "b5c391c0ccce8200af33af32cb5980fce2cbe60e",
      "filename": "gdb/mn10300-linux-tdep.c",
      "status": "modified",
      "additions": 36,
      "deletions": 36,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mn10300-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mn10300-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "b34a2718da7fc08853712f2855d352098feb297e",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "1338ce3426ff1069af320d0bd2649fa7e84c3775",
      "filename": "gdb/moxie-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/moxie-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/moxie-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/moxie-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "bf2cad3592d6a9c0048d4e3b35192a57f491a4f9",
      "filename": "gdb/msp430-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/msp430-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/msp430-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/msp430-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "87c9be4b60696c9628d60103c52d664fd8c47d35",
      "filename": "gdb/namespace.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/namespace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/namespace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/namespace.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "cf6bcc96163445a006824cedbef5a3b5eb6f79e8",
      "filename": "gdb/nat/fork-inferior.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/fork-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/fork-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "10eb1a60462a34898f1b7a15ba71fd3044bd9ecc",
      "filename": "gdb/nat/gdb_ptrace.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/gdb_ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/gdb_ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/gdb_ptrace.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "76da96bd7e8534fd3557ce8dbbea26fc88b118be",
      "filename": "gdb/nat/linux-namespaces.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/linux-namespaces.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/linux-namespaces.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-namespaces.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "2363acc84c9803e94c1c6ee537882300cbbd09cf",
      "filename": "gdb/nat/linux-osdata.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/linux-osdata.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/linux-osdata.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-osdata.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "a1c895db2ca61e555ab8c4450732084ebe577bc5",
      "filename": "gdb/nat/netbsd-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/netbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/netbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/netbsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9bef16aa4c100084fe1581bcf6e40b03c99cb3e7",
      "filename": "gdb/nat/x86-dregs.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/x86-dregs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nat/x86-dregs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/x86-dregs.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9f7a13d9a266eedf2e74f920839a0b56e3ab44c6",
      "filename": "gdb/netbsd-nat.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/netbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/netbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/netbsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "f45cc1faf40adff53118dec208d32829e97c5773",
      "filename": "gdb/netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "e6703ae9bccb5f981f134c33b1bb9a2daf4df6cb",
      "filename": "gdb/nios2-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nios2-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nios2-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9f167fe05bf4d30d478ba23072f95056fb4015fd",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "7831c0b672d706c0ec921c0c5438480973ab8e3c",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "65eafce1c5167e699ee4862ac8ebd30cf56ef578",
      "filename": "gdb/nto-tdep.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nto-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/nto-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "3461b31b6ead72d41ce5718eb8fd07594e18bb07",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "b9bb80b7a621fbf5dc49ac564a51e29a87360eff",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "38b98dec3d2f65cc07ea3e80864fe9b3bc874125",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "d7c23ef49fe30b9c2615492ca0082085f3460766",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "939ffc6721e6ac9ec7fadd2c4add08465a67bb21",
      "filename": "gdb/osabi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osabi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osabi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/osabi.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "311d05ddd8b2346fb4fbe03682d5c6329a4ca5e3",
      "filename": "gdb/osabi.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osabi.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osabi.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/osabi.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "7b5c20a8ca92fd2e579d1faef1d3d8c9ce2ed41f",
      "filename": "gdb/osdata.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osdata.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/osdata.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/osdata.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9caf15f69f552facae8a26fe04bfcac746662c74",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 53,
      "deletions": 53,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "9498dc09897c588ef3f5e02ac42848d920530b59",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "ef0f25486d1d58a2a0b0aef4c37086efab5e4312",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "428b2efc656629472d2ea96731b7e5fc2771939e",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "8b9dfba0fb713cc3ff21981145f323fc8fa60cf8",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "7131134c10aa864d9074d07371cbac43d99d8c07",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 111,
      "deletions": 111,
      "changes": 222,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "8cd8ef893ad439593d85ff88bb555b0b539cb15e",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "6b94aa837f85057f68ca8ff813e57f02cac67c09",
      "filename": "gdb/ppc-netbsd-nat.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-netbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-netbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-netbsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "444c49c4d43ab444b7e471b6c7dea754fba9354c",
      "filename": "gdb/ppc-netbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-netbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-netbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-netbsd-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "4e57e19ac4c2abdb1af82202e5a3478d52fe7a50",
      "filename": "gdb/ppc-obsd-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-obsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-obsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-obsd-nat.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "ac3e3c130cd6cfcff1e33c8edc3a0f482bf849ee",
      "filename": "gdb/ppc-ravenscar-thread.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-ravenscar-thread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "c2c9c8477e25ea945a693119d5b2e0cfe32a707a",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "e910f8d99ee0db512ce113afd92fd9075c45f269",
      "filename": "gdb/ppc64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ppc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc64-tdep.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "f7186c296afc1a1087f0e8c3cf3826537416f5bc",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 87,
      "deletions": 87,
      "changes": 174,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "cfc92c9a078adc2e6965eea2d1637d3fc0346ef1",
      "filename": "gdb/proc-api.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/proc-api.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/proc-api.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/proc-api.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "730d3129f808ac097ab1e1cf17d8c88ce75d81a6",
      "filename": "gdb/producer.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/producer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/producer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/producer.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "741741dee8063ccba76b97313921ed1c2d80fa74",
      "filename": "gdb/producer.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/producer.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/producer.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/producer.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "221df335d202e4c81bbdf6e0b3a7900035f4384d",
      "filename": "gdb/prologue-value.c",
      "status": "modified",
      "additions": 74,
      "deletions": 74,
      "changes": 148,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/prologue-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/prologue-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/prologue-value.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "214c88c37454349aaba2eaba31eda250c8db5ada",
      "filename": "gdb/prologue-value.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/prologue-value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/prologue-value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/prologue-value.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "7e70f8045f25c970f4ab673d870b8c7042d23b67",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "ec955e79654638d2265e3f73cbb066f14e4f4d6b",
      "filename": "gdb/python/py-arch.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-arch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-arch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-arch.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "59849a0644326f5c45b0971ea2a6ea72fe3caf32",
      "filename": "gdb/python/py-bpevent.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-bpevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-bpevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-bpevent.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "64b4178b28ccc9b6a5a3aa318104d358f1fbddf6",
      "filename": "gdb/python/py-event.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-event.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-event.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-event.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "92a71f675af21fb5074d130c86799b1692e6efe2",
      "filename": "gdb/python/py-event.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-event.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-event.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-event.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "3844af690c50a1104a2d4d8b825cdafac72d5c94",
      "filename": "gdb/python/py-finishbreakpoint.c",
      "status": "modified",
      "additions": 62,
      "deletions": 62,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-finishbreakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-finishbreakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-finishbreakpoint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "6f0bb8e5a4ca4e0c6402ff1148898bb42011dbbf",
      "filename": "gdb/python/py-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-frame.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "944a0eee502a76bb4206cf2cbd1c8d1197527741",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "102a4270af35324aa0f8478ef0c2717c37b1bf29",
      "filename": "gdb/python/py-inferior.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-inferior.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "089ea22cb1200d0ee20c1f4734050b01486d79e8",
      "filename": "gdb/python/py-infthread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-infthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-infthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-infthread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "a006eb3883002c812def04421ffd449a18707033",
      "filename": "gdb/python/py-objfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-objfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-objfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-objfile.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "8eaa41fb187c7ef9fad2f2fe2b0ed21dc2b18db0",
      "filename": "gdb/python/py-prettyprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-prettyprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-prettyprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-prettyprint.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "d7b876bae289fb644e390f9d9d0edd14328cac82",
      "filename": "gdb/python/py-registers.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-registers.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-registers.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-registers.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "69db8ce4f68ec7e1796b2bc0145ef07473129ab6",
      "filename": "gdb/python/py-signalevent.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-signalevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-signalevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-signalevent.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "e83d85f8a3ba6d9333e5b54503acd54fd3dd2b45",
      "filename": "gdb/python/py-stopevent.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-stopevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-stopevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-stopevent.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "fdb16fdc2cc0dadb721e8ac61da2c242888054c9",
      "filename": "gdb/python/py-stopevent.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-stopevent.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-stopevent.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-stopevent.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "e33c22832a2e1f5edb344fb13a0db4c04c002841",
      "filename": "gdb/python/py-threadevent.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-threadevent.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-threadevent.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-threadevent.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "87065eaf60bc5a6af8856f22a443b736d88d4085",
      "filename": "gdb/python/py-tui.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-tui.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-tui.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-tui.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "4571ef685c7ed48669ff1d36d2d2dd196d200f5d",
      "filename": "gdb/python/py-unwind.c",
      "status": "modified",
      "additions": 79,
      "deletions": 79,
      "changes": 158,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-unwind.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "4e8d93e15ab30a951d07aa100e9bab1e7b6a108f",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "0b41daebc033a552c02c4ae49b86f7b8fbce0c10",
      "filename": "gdb/python/py-xmethods.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-xmethods.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/py-xmethods.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-xmethods.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "cc113cb7bfad92133568fab936af5703b958cda1",
      "filename": "gdb/python/python-internal.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/python-internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/python-internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python-internal.h?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "74fee00edb6965550d60ecdae7198cc5090ae48b",
      "filename": "gdb/python/python.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/python.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/python/python.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "d17dfa6daed219c15926e1b5de6001faaa8cc232",
      "filename": "gdb/ravenscar-thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ravenscar-thread.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "dece9b60778d2d8f7f475af5680f08bb10ae773a",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "3b5e6fee7cdf86073e7c9804e86864cf4341e9d0",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 97,
      "deletions": 97,
      "changes": 194,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    },
    {
      "sha": "f91411927794b6d73f075820a54bf27100cd4aa4",
      "filename": "gdb/record.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dda83cd783075941aabe9b0292b004b11f00c831/gdb/record.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record.c?ref=dda83cd783075941aabe9b0292b004b11f00c831"
    }
  ]
}