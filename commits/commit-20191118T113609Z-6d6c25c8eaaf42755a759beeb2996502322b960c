{
  "sha": "6d6c25c8eaaf42755a759beeb2996502322b960c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmQ2YzI1YzhlYWFmNDI3NTVhNzU5YmVlYjI5OTY1MDIzMjJiOTYwYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-11-18T06:39:01Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-11-18T11:36:09Z"
    },
    "message": "elf_backend_modify_headers\n\nThis patch renames elf_backend_modify_program_headers and moves the\nelf.c code tweaking the ELF file header for -pie -Ttext-segment to a\nnew function, _bfd_elf_modify_headers, which then becomes the default\nelf_backed_modify_headers and is called from any other target\nelf_backed_modify_headers.\n\n\t* elf-bfd.h (struct elf_backend_data <elf_backend_modify_headers>):\n\tRename from elf_backend_modify_program_headers.\n\t(_bfd_elf_modify_headers): Declare.\n\t* elf.c (assign_file_positions_except_relocs): Set\n\telf_program_header_size.  Always call elf_backend_modify_headers.\n\tExtract code modifying file header..\n\t(_bfd_elf_modify_headers): ..to here.  New function.\n\t* elf32-arm.c (elf_backend_modify_headers): Renamed from\n\telf_backend_modify_program_headers.\n\t* elf32-i386.c: Similarly.\n\t* elf64-x86-64.c: Similarly.\n\t* elfxx-target.h: Similarly.  Default elf_backend_modify_headers\n\tto _bfd_elf_modify_headers.\n\t* elf-nacl.h (nacl_modify_headers): Rename from\n\tnacl_modify_program_headers.\n\t* elf-nacl.c (nacl_modify_headers): Rename from\n\tnacl_modify_program_headers and call _bfd_elf_modify_headers.\n\t* elf32-rx.c (elf32_rx_modify_headers): Similarly.\n\t* elf32-spu.c (spu_elf_modify_headers): Similarly.\n\t* elfnn-ia64.c (elfNN_ia64_modify_headers): Similarly.\n\t* elf32-sh.c (elf_backend_modify_program_headers): Don't undef.",
    "tree": {
      "sha": "3ec735f2069634d339bde6d46dab7a7c758eb164",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3ec735f2069634d339bde6d46dab7a7c758eb164"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6d6c25c8eaaf42755a759beeb2996502322b960c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d6c25c8eaaf42755a759beeb2996502322b960c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6d6c25c8eaaf42755a759beeb2996502322b960c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d6c25c8eaaf42755a759beeb2996502322b960c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9aea1e31371a883452e80bd96e8818289c3e6b6e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9aea1e31371a883452e80bd96e8818289c3e6b6e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9aea1e31371a883452e80bd96e8818289c3e6b6e"
    }
  ],
  "stats": {
    "total": 426,
    "additions": 230,
    "deletions": 196
  },
  "files": [
    {
      "sha": "a6705ef68859f908e930143d8b4b279201795e9c",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -1,3 +1,27 @@\n+2019-11-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf-bfd.h (struct elf_backend_data <elf_backend_modify_headers>):\n+\tRename from elf_backend_modify_program_headers.\n+\t(_bfd_elf_modify_headers): Declare.\n+\t* elf.c (assign_file_positions_except_relocs): Set\n+\telf_program_header_size.  Always call elf_backend_modify_headers.\n+\tExtract code modifying file header..\n+\t(_bfd_elf_modify_headers): ..to here.  New function.\n+\t* elf32-arm.c (elf_backend_modify_headers): Renamed from\n+\telf_backend_modify_program_headers.\n+\t* elf32-i386.c: Similarly.\n+\t* elf64-x86-64.c: Similarly.\n+\t* elfxx-target.h: Similarly.  Default elf_backend_modify_headers\n+\tto _bfd_elf_modify_headers.\n+\t* elf-nacl.h (nacl_modify_headers): Rename from\n+\tnacl_modify_program_headers.\n+\t* elf-nacl.c (nacl_modify_headers): Rename from\n+\tnacl_modify_program_headers and call _bfd_elf_modify_headers.\n+\t* elf32-rx.c (elf32_rx_modify_headers): Similarly.\n+\t* elf32-spu.c (spu_elf_modify_headers): Similarly.\n+\t* elfnn-ia64.c (elfNN_ia64_modify_headers): Similarly.\n+\t* elf32-sh.c (elf_backend_modify_program_headers): Don't undef.\n+\n 2019-11-18  Alan Modra  <amodra@gmail.com>\n \n \tPR 25196"
    },
    {
      "sha": "09975c75fc1861f62138734352cca071c65a9042",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -1165,7 +1165,7 @@ struct elf_backend_data\n \n   /* This function is called to modify program headers just before\n      they are written.  */\n-  bfd_boolean (*elf_backend_modify_program_headers)\n+  bfd_boolean (*elf_backend_modify_headers)\n     (bfd *, struct bfd_link_info *);\n \n   /* This function is called to see if the PHDR header should be\n@@ -2305,6 +2305,8 @@ extern bfd_boolean _bfd_elf_compute_section_file_positions\n   (bfd *, struct bfd_link_info *);\n extern file_ptr _bfd_elf_assign_file_position_for_section\n   (Elf_Internal_Shdr *, file_ptr, bfd_boolean);\n+extern bfd_boolean _bfd_elf_modify_headers\n+  (bfd *, struct bfd_link_info *);\n \n extern bfd_boolean _bfd_elf_validate_reloc\n   (bfd *, arelent *);"
    },
    {
      "sha": "d8d67f338ff4bdd05124bf697221aaad7814775e",
      "filename": "bfd/elf-nacl.c",
      "status": "modified",
      "additions": 63,
      "deletions": 60,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-nacl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-nacl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-nacl.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -235,90 +235,93 @@ nacl_modify_segment_map (bfd *abfd, struct bfd_link_info *info)\n    proper order for the ELF rule that they must appear in ascending address\n    order.  So find the two segments we swapped before, and swap them back.  */\n bfd_boolean\n-nacl_modify_program_headers (bfd *abfd, struct bfd_link_info *info)\n+nacl_modify_headers (bfd *abfd, struct bfd_link_info *info)\n {\n-  struct elf_segment_map **m = &elf_seg_map (abfd);\n-  Elf_Internal_Phdr *phdr = elf_tdata (abfd)->phdr;\n-  Elf_Internal_Phdr *p = phdr;\n-\n   if (info != NULL && info->user_phdrs)\n     /* The linker script used PHDRS explicitly, so don't change what the\n        user asked for.  */\n-    return TRUE;\n-\n-  /* Find the PT_LOAD that contains the headers (should be the first).  */\n-  while (*m != NULL)\n-    {\n-      if ((*m)->p_type == PT_LOAD && (*m)->includes_filehdr)\n-\tbreak;\n-\n-      m = &(*m)->next;\n-      ++p;\n-    }\n-\n-  if (*m != NULL)\n+    ;\n+  else\n     {\n-      struct elf_segment_map **first_load_seg = m;\n-      Elf_Internal_Phdr *first_load_phdr = p;\n-      struct elf_segment_map **next_load_seg = NULL;\n-      Elf_Internal_Phdr *next_load_phdr = NULL;\n-\n-      /* Now move past that first one and find the PT_LOAD that should be\n-\t before it by address order.  */\n-\n-      m = &(*m)->next;\n-      ++p;\n+      struct elf_segment_map **m = &elf_seg_map (abfd);\n+      Elf_Internal_Phdr *phdr = elf_tdata (abfd)->phdr;\n+      Elf_Internal_Phdr *p = phdr;\n \n+      /* Find the PT_LOAD that contains the headers (should be the first).  */\n       while (*m != NULL)\n \t{\n-\t  if (p->p_type == PT_LOAD && p->p_vaddr < first_load_phdr->p_vaddr)\n-\t    {\n-\t      next_load_seg = m;\n-\t      next_load_phdr = p;\n-\t      break;\n-\t    }\n+\t  if ((*m)->p_type == PT_LOAD && (*m)->includes_filehdr)\n+\t    break;\n \n \t  m = &(*m)->next;\n \t  ++p;\n \t}\n \n-      /* Swap their positions in the segment_map back to how they used to be.\n-\t The phdrs have already been set up by now, so we have to slide up\n-\t the earlier ones to insert the one that should be first.  */\n-      if (next_load_seg != NULL)\n+      if (*m != NULL)\n \t{\n-\t  Elf_Internal_Phdr move_phdr;\n-\t  struct elf_segment_map *first_seg = *first_load_seg;\n-\t  struct elf_segment_map *next_seg = *next_load_seg;\n-\t  struct elf_segment_map *first_next = first_seg->next;\n-\t  struct elf_segment_map *next_next = next_seg->next;\n+\t  struct elf_segment_map **first_load_seg = m;\n+\t  Elf_Internal_Phdr *first_load_phdr = p;\n+\t  struct elf_segment_map **next_load_seg = NULL;\n+\t  Elf_Internal_Phdr *next_load_phdr = NULL;\n+\n+\t  /* Now move past that first one and find the PT_LOAD that should be\n+\t     before it by address order.  */\n \n-\t  if (next_load_seg == &first_seg->next)\n+\t  m = &(*m)->next;\n+\t  ++p;\n+\n+\t  while (*m != NULL)\n \t    {\n-\t      *first_load_seg = next_seg;\n-\t      next_seg->next = first_seg;\n-\t      first_seg->next = next_next;\n+\t      if (p->p_type == PT_LOAD && p->p_vaddr < first_load_phdr->p_vaddr)\n+\t\t{\n+\t\t  next_load_seg = m;\n+\t\t  next_load_phdr = p;\n+\t\t  break;\n+\t\t}\n+\n+\t      m = &(*m)->next;\n+\t      ++p;\n \t    }\n-\t  else\n+\n+\t  /* Swap their positions in the segment_map back to how they\n+\t     used to be.  The phdrs have already been set up by now,\n+\t     so we have to slide up the earlier ones to insert the one\n+\t     that should be first.  */\n+\t  if (next_load_seg != NULL)\n \t    {\n-\t      *first_load_seg = first_next;\n-\t      *next_load_seg = next_next;\n+\t      Elf_Internal_Phdr move_phdr;\n+\t      struct elf_segment_map *first_seg = *first_load_seg;\n+\t      struct elf_segment_map *next_seg = *next_load_seg;\n+\t      struct elf_segment_map *first_next = first_seg->next;\n+\t      struct elf_segment_map *next_next = next_seg->next;\n \n-\t      first_seg->next = *next_load_seg;\n-\t      *next_load_seg = first_seg;\n+\t      if (next_load_seg == &first_seg->next)\n+\t\t{\n+\t\t  *first_load_seg = next_seg;\n+\t\t  next_seg->next = first_seg;\n+\t\t  first_seg->next = next_next;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  *first_load_seg = first_next;\n+\t\t  *next_load_seg = next_next;\n \n-\t      next_seg->next = *first_load_seg;\n-\t      *first_load_seg = next_seg;\n-\t    }\n+\t\t  first_seg->next = *next_load_seg;\n+\t\t  *next_load_seg = first_seg;\n \n-\t  move_phdr = *next_load_phdr;\n-\t  memmove (first_load_phdr + 1, first_load_phdr,\n-\t\t   (next_load_phdr - first_load_phdr) * sizeof move_phdr);\n-\t  *first_load_phdr = move_phdr;\n+\t\t  next_seg->next = *first_load_seg;\n+\t\t  *first_load_seg = next_seg;\n+\t\t}\n+\n+\t      move_phdr = *next_load_phdr;\n+\t      memmove (first_load_phdr + 1, first_load_phdr,\n+\t\t       (next_load_phdr - first_load_phdr) * sizeof move_phdr);\n+\t      *first_load_phdr = move_phdr;\n+\t    }\n \t}\n     }\n \n-  return TRUE;\n+  return _bfd_elf_modify_headers (abfd, info);\n }\n \n bfd_boolean"
    },
    {
      "sha": "0b151d1436f61bc06a0d2d57775d9be6750a1650",
      "filename": "bfd/elf-nacl.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-nacl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf-nacl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-nacl.h?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -17,5 +17,5 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n bfd_boolean nacl_modify_segment_map (bfd *, struct bfd_link_info *);\n-bfd_boolean nacl_modify_program_headers (bfd *, struct bfd_link_info *);\n+bfd_boolean nacl_modify_headers (bfd *, struct bfd_link_info *);\n bfd_boolean nacl_final_write_processing (bfd *);"
    },
    {
      "sha": "d1815e152646a679ca9589e71c70d5db5fe21beb",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 41,
      "deletions": 35,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -6313,6 +6313,7 @@ assign_file_positions_except_relocs (bfd *abfd,\n   struct elf_obj_tdata *tdata = elf_tdata (abfd);\n   Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (abfd);\n   const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n+  unsigned int alloc;\n \n   if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0\n       && bfd_get_format (abfd) != bfd_core)\n@@ -6355,11 +6356,10 @@ assign_file_positions_except_relocs (bfd *abfd,\n \t}\n \n       elf_next_file_pos (abfd) = off;\n+      elf_program_header_size (abfd) = 0;\n     }\n   else\n     {\n-      unsigned int alloc;\n-\n       /* Assign file positions for the loaded sections based on the\n \t assignment of sections to segments.  */\n       if (!assign_file_positions_for_load_sections (abfd, link_info))\n@@ -6368,41 +6368,15 @@ assign_file_positions_except_relocs (bfd *abfd,\n       /* And for non-load sections.  */\n       if (!assign_file_positions_for_non_load_sections (abfd, link_info))\n \treturn FALSE;\n+    }\n \n-      if (bed->elf_backend_modify_program_headers != NULL)\n-\t{\n-\t  if (!(*bed->elf_backend_modify_program_headers) (abfd, link_info))\n-\t    return FALSE;\n-\t}\n-\n-      /* Set e_type in ELF header to ET_EXEC for -pie -Ttext-segment=.  */\n-      if (link_info != NULL && bfd_link_pie (link_info))\n-\t{\n-\t  unsigned int num_segments = i_ehdrp->e_phnum;\n-\t  Elf_Internal_Phdr *segment = tdata->phdr;\n-\t  Elf_Internal_Phdr *end_segment = &segment[num_segments];\n-\n-\t  /* Find the lowest p_vaddr in PT_LOAD segments.  */\n-\t  bfd_vma p_vaddr = (bfd_vma) -1;\n-\t  for (; segment < end_segment; segment++)\n-\t    if (segment->p_type == PT_LOAD && p_vaddr > segment->p_vaddr)\n-\t      p_vaddr = segment->p_vaddr;\n-\n-\t  /* Set e_type to ET_EXEC if the lowest p_vaddr in PT_LOAD\n-\t     segments is non-zero.  */\n-\t  if (p_vaddr)\n-\t    i_ehdrp->e_type = ET_EXEC;\n-\t}\n-\n-      /* Write out the program headers.\n-\t FIXME: We used to have code here to sort the PT_LOAD segments into\n-\t ascending order, as per the ELF spec.  But this breaks some programs,\n-\t including the Linux kernel.  But really either the spec should be\n-\t changed or the programs updated.  */\n-      alloc = i_ehdrp->e_phnum;\n-      if (alloc == 0)\n-\treturn TRUE;\n+  if (!(*bed->elf_backend_modify_headers) (abfd, link_info))\n+    return FALSE;\n \n+  /* Write out the program headers.  */\n+  alloc = i_ehdrp->e_phnum;\n+  if (alloc != 0)\n+    {\n       if (bfd_seek (abfd, i_ehdrp->e_phoff, SEEK_SET) != 0\n \t  || bed->s->write_out_phdrs (abfd, tdata->phdr, alloc) != 0)\n \treturn FALSE;\n@@ -6499,6 +6473,38 @@ prep_headers (bfd *abfd)\n   return TRUE;\n }\n \n+/* Set e_type in ELF header to ET_EXEC for -pie -Ttext-segment=.\n+\n+   FIXME: We used to have code here to sort the PT_LOAD segments into\n+   ascending order, as per the ELF spec.  But this breaks some programs,\n+   including the Linux kernel.  But really either the spec should be\n+   changed or the programs updated.  */\n+\n+bfd_boolean\n+_bfd_elf_modify_headers (bfd *obfd, struct bfd_link_info *link_info)\n+{\n+  if (link_info != NULL && bfd_link_pie (link_info))\n+    {\n+      Elf_Internal_Ehdr *i_ehdrp = elf_elfheader (obfd);\n+      unsigned int num_segments = i_ehdrp->e_phnum;\n+      struct elf_obj_tdata *tdata = elf_tdata (obfd);\n+      Elf_Internal_Phdr *segment = tdata->phdr;\n+      Elf_Internal_Phdr *end_segment = &segment[num_segments];\n+\n+      /* Find the lowest p_vaddr in PT_LOAD segments.  */\n+      bfd_vma p_vaddr = (bfd_vma) -1;\n+      for (; segment < end_segment; segment++)\n+\tif (segment->p_type == PT_LOAD && p_vaddr > segment->p_vaddr)\n+\t  p_vaddr = segment->p_vaddr;\n+\n+      /* Set e_type to ET_EXEC if the lowest p_vaddr in PT_LOAD\n+\t segments is non-zero.  */\n+      if (p_vaddr)\n+\ti_ehdrp->e_type = ET_EXEC;\n+    }\n+  return TRUE;\n+}\n+\n /* Assign file positions for all the reloc sections which are not part\n    of the loadable file image, and the file position of section headers.  */\n "
    },
    {
      "sha": "8fb2b473786f88783c2a252fee137bfee51e31d7",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -20624,8 +20624,8 @@ elf32_arm_nacl_plt_sym_val (bfd_vma i, const asection *plt,\n #define elf_backend_plt_alignment\t\t4\n #undef\telf_backend_modify_segment_map\n #define\telf_backend_modify_segment_map\t\telf32_arm_nacl_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n-#define\telf_backend_modify_program_headers\tnacl_modify_program_headers\n+#undef\telf_backend_modify_headers\n+#define\telf_backend_modify_headers\t\tnacl_modify_headers\n #undef  elf_backend_final_write_processing\n #define elf_backend_final_write_processing\telf32_arm_nacl_final_write_processing\n #undef bfd_elf32_get_synthetic_symtab\n@@ -20643,7 +20643,7 @@ elf32_arm_nacl_plt_sym_val (bfd_vma i, const asection *plt,\n #undef\telf_backend_plt_alignment\n #undef\telf_backend_modify_segment_map\n #define elf_backend_modify_segment_map\t\telf32_arm_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n+#undef\telf_backend_modify_headers\n #undef  elf_backend_final_write_processing\n #define elf_backend_final_write_processing\telf32_arm_final_write_processing\n #undef\tELF_MINPAGESIZE"
    },
    {
      "sha": "2afd4f6766cc92a0edb3e0d4435a8b2fca1078b3",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -4774,8 +4774,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)\n #define elf_backend_object_p\t\t\telf32_i386_nacl_elf_object_p\n #undef\telf_backend_modify_segment_map\n #define\telf_backend_modify_segment_map\t\tnacl_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n-#define\telf_backend_modify_program_headers\tnacl_modify_program_headers\n+#undef\telf_backend_modify_headers\n+#define\telf_backend_modify_headers\t\tnacl_modify_headers\n #undef\telf_backend_final_write_processing\n #define elf_backend_final_write_processing\tnacl_final_write_processing\n \n@@ -4784,7 +4784,7 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)\n /* Restore defaults.  */\n #undef\telf_backend_object_p\n #undef\telf_backend_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n+#undef\telf_backend_modify_headers\n #undef\telf_backend_final_write_processing\n \n /* VxWorks support.  */"
    },
    {
      "sha": "a1a5ce11be151a22621fe223829db6a894965d28",
      "filename": "bfd/elf32-rx.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rx.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -3684,8 +3684,7 @@ rx_final_link (bfd * abfd, struct bfd_link_info * info)\n }\n \n static bfd_boolean\n-elf32_rx_modify_program_headers (bfd * abfd ATTRIBUTE_UNUSED,\n-\t\t\t\t struct bfd_link_info * info ATTRIBUTE_UNUSED)\n+elf32_rx_modify_headers (bfd *abfd, struct bfd_link_info *info)\n {\n   const struct elf_backend_data * bed;\n   struct elf_obj_tdata * tdata;\n@@ -3717,7 +3716,7 @@ elf32_rx_modify_program_headers (bfd * abfd ATTRIBUTE_UNUSED,\n #endif\n \t}\n \n-  return TRUE;\n+  return _bfd_elf_modify_headers (abfd, info);\n }\n \n /* The default literal sections should always be marked as \"code\" (i.e.,\n@@ -4037,7 +4036,7 @@ rx_additional_link_map_text (bfd *obfd, struct bfd_link_info *info, FILE *mapfil\n #define elf_backend_relocate_section\t\trx_elf_relocate_section\n #define elf_symbol_leading_char\t\t\t('_')\n #define elf_backend_can_gc_sections\t\t1\n-#define elf_backend_modify_program_headers\telf32_rx_modify_program_headers\n+#define elf_backend_modify_headers\t\telf32_rx_modify_headers\n \n #define bfd_elf32_bfd_reloc_type_lookup\t\trx_reloc_type_lookup\n #define bfd_elf32_bfd_reloc_name_lookup\t\trx_reloc_name_lookup"
    },
    {
      "sha": "c10691e422ca50fc228c29b70d8bcb34679ed87d",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -6847,8 +6847,6 @@ sh_elf_encode_eh_address (bfd *abfd,\n \n #include \"elf32-target.h\"\n \n-#undef elf_backend_modify_program_headers\n-\n /* VxWorks support.  */\n #undef\tTARGET_BIG_SYM\n #define\tTARGET_BIG_SYM\t\t\tsh_elf32_vxworks_vec"
    },
    {
      "sha": "aa1510596fb53b81e876fe133ac5aec826534faa",
      "filename": "bfd/elf32-spu.c",
      "status": "modified",
      "additions": 79,
      "deletions": 76,
      "changes": 155,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf32-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-spu.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -2128,7 +2128,7 @@ spu_elf_build_stubs (struct bfd_link_info *info)\n \t      bfd_put_32 (htab->ovtab->owner, s->vma, p + off);\n \t      bfd_put_32 (htab->ovtab->owner, (s->size + 15) & -16,\n \t\t\t  p + off + 4);\n-\t      /* file_off written later in spu_elf_modify_program_headers.  */\n+\t      /* file_off written later in spu_elf_modify_headers.  */\n \t      bfd_put_32 (htab->ovtab->owner, ovl_buf, p + off + 12);\n \t    }\n \t}\n@@ -5344,96 +5344,99 @@ spu_elf_fake_sections (bfd *obfd ATTRIBUTE_UNUSED,\n /* Tweak phdrs before writing them out.  */\n \n static int\n-spu_elf_modify_program_headers (bfd *abfd, struct bfd_link_info *info)\n+spu_elf_modify_headers (bfd *abfd, struct bfd_link_info *info)\n {\n-  const struct elf_backend_data *bed;\n-  struct elf_obj_tdata *tdata;\n-  Elf_Internal_Phdr *phdr, *last;\n-  struct spu_link_hash_table *htab;\n-  unsigned int count;\n-  unsigned int i;\n-\n-  if (info == NULL)\n-    return TRUE;\n-\n-  bed = get_elf_backend_data (abfd);\n-  tdata = elf_tdata (abfd);\n-  phdr = tdata->phdr;\n-  count = elf_program_header_size (abfd) / bed->s->sizeof_phdr;\n-  htab = spu_hash_table (info);\n-  if (htab->num_overlays != 0)\n+  if (info != NULL)\n     {\n-      struct elf_segment_map *m;\n-      unsigned int o;\n-\n-      for (i = 0, m = elf_seg_map (abfd); m; ++i, m = m->next)\n-\tif (m->count != 0\n-\t    && (o = spu_elf_section_data (m->sections[0])->u.o.ovl_index) != 0)\n-\t  {\n-\t    /* Mark this as an overlay header.  */\n-\t    phdr[i].p_flags |= PF_OVERLAY;\n+      const struct elf_backend_data *bed;\n+      struct elf_obj_tdata *tdata;\n+      Elf_Internal_Phdr *phdr, *last;\n+      struct spu_link_hash_table *htab;\n+      unsigned int count;\n+      unsigned int i;\n+\n+      bed = get_elf_backend_data (abfd);\n+      tdata = elf_tdata (abfd);\n+      phdr = tdata->phdr;\n+      count = elf_program_header_size (abfd) / bed->s->sizeof_phdr;\n+      htab = spu_hash_table (info);\n+      if (htab->num_overlays != 0)\n+\t{\n+\t  struct elf_segment_map *m;\n+\t  unsigned int o;\n \n-\t    if (htab->ovtab != NULL && htab->ovtab->size != 0\n-\t\t&& htab->params->ovly_flavour != ovly_soft_icache)\n+\t  for (i = 0, m = elf_seg_map (abfd); m; ++i, m = m->next)\n+\t    if (m->count != 0\n+\t\t&& ((o = spu_elf_section_data (m->sections[0])->u.o.ovl_index)\n+\t\t    != 0))\n \t      {\n-\t\tbfd_byte *p = htab->ovtab->contents;\n-\t\tunsigned int off = o * 16 + 8;\n+\t\t/* Mark this as an overlay header.  */\n+\t\tphdr[i].p_flags |= PF_OVERLAY;\n \n-\t\t/* Write file_off into _ovly_table.  */\n-\t\tbfd_put_32 (htab->ovtab->owner, phdr[i].p_offset, p + off);\n+\t\tif (htab->ovtab != NULL && htab->ovtab->size != 0\n+\t\t    && htab->params->ovly_flavour != ovly_soft_icache)\n+\t\t  {\n+\t\t    bfd_byte *p = htab->ovtab->contents;\n+\t\t    unsigned int off = o * 16 + 8;\n+\n+\t\t    /* Write file_off into _ovly_table.  */\n+\t\t    bfd_put_32 (htab->ovtab->owner, phdr[i].p_offset, p + off);\n+\t\t  }\n \t      }\n-\t  }\n-      /* Soft-icache has its file offset put in .ovl.init.  */\n-      if (htab->init != NULL && htab->init->size != 0)\n-\t{\n-\t  bfd_vma val = elf_section_data (htab->ovl_sec[0])->this_hdr.sh_offset;\n+\t  /* Soft-icache has its file offset put in .ovl.init.  */\n+\t  if (htab->init != NULL && htab->init->size != 0)\n+\t    {\n+\t      bfd_vma val\n+\t\t= elf_section_data (htab->ovl_sec[0])->this_hdr.sh_offset;\n \n-\t  bfd_put_32 (htab->init->owner, val, htab->init->contents + 4);\n+\t      bfd_put_32 (htab->init->owner, val, htab->init->contents + 4);\n+\t    }\n \t}\n-    }\n \n-  /* Round up p_filesz and p_memsz of PT_LOAD segments to multiples\n-     of 16.  This should always be possible when using the standard\n-     linker scripts, but don't create overlapping segments if\n-     someone is playing games with linker scripts.  */\n-  last = NULL;\n-  for (i = count; i-- != 0; )\n-    if (phdr[i].p_type == PT_LOAD)\n-      {\n-\tunsigned adjust;\n+      /* Round up p_filesz and p_memsz of PT_LOAD segments to multiples\n+\t of 16.  This should always be possible when using the standard\n+\t linker scripts, but don't create overlapping segments if\n+\t someone is playing games with linker scripts.  */\n+      last = NULL;\n+      for (i = count; i-- != 0; )\n+\tif (phdr[i].p_type == PT_LOAD)\n+\t  {\n+\t    unsigned adjust;\n \n-\tadjust = -phdr[i].p_filesz & 15;\n-\tif (adjust != 0\n-\t    && last != NULL\n-\t    && phdr[i].p_offset + phdr[i].p_filesz > last->p_offset - adjust)\n-\t  break;\n+\t    adjust = -phdr[i].p_filesz & 15;\n+\t    if (adjust != 0\n+\t\t&& last != NULL\n+\t\t&& (phdr[i].p_offset + phdr[i].p_filesz\n+\t\t    > last->p_offset - adjust))\n+\t      break;\n \n-\tadjust = -phdr[i].p_memsz & 15;\n-\tif (adjust != 0\n-\t    && last != NULL\n-\t    && phdr[i].p_filesz != 0\n-\t    && phdr[i].p_vaddr + phdr[i].p_memsz > last->p_vaddr - adjust\n-\t    && phdr[i].p_vaddr + phdr[i].p_memsz <= last->p_vaddr)\n-\t  break;\n+\t    adjust = -phdr[i].p_memsz & 15;\n+\t    if (adjust != 0\n+\t\t&& last != NULL\n+\t\t&& phdr[i].p_filesz != 0\n+\t\t&& phdr[i].p_vaddr + phdr[i].p_memsz > last->p_vaddr - adjust\n+\t\t&& phdr[i].p_vaddr + phdr[i].p_memsz <= last->p_vaddr)\n+\t      break;\n \n-\tif (phdr[i].p_filesz != 0)\n-\t  last = &phdr[i];\n-      }\n+\t    if (phdr[i].p_filesz != 0)\n+\t      last = &phdr[i];\n+\t  }\n \n-  if (i == (unsigned int) -1)\n-    for (i = count; i-- != 0; )\n-      if (phdr[i].p_type == PT_LOAD)\n-\t{\n-\tunsigned adjust;\n+      if (i == (unsigned int) -1)\n+\tfor (i = count; i-- != 0; )\n+\t  if (phdr[i].p_type == PT_LOAD)\n+\t    {\n+\t      unsigned adjust;\n \n-\tadjust = -phdr[i].p_filesz & 15;\n-\tphdr[i].p_filesz += adjust;\n+\t      adjust = -phdr[i].p_filesz & 15;\n+\t      phdr[i].p_filesz += adjust;\n \n-\tadjust = -phdr[i].p_memsz & 15;\n-\tphdr[i].p_memsz += adjust;\n-      }\n+\t      adjust = -phdr[i].p_memsz & 15;\n+\t      phdr[i].p_memsz += adjust;\n+\t    }\n+    }\n \n-  return TRUE;\n+  return _bfd_elf_modify_headers (abfd, info);\n }\n \n bfd_boolean\n@@ -5527,7 +5530,7 @@ spu_elf_size_sections (bfd *obfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n \n #define elf_backend_additional_program_headers\tspu_elf_additional_program_headers\n #define elf_backend_modify_segment_map\t\tspu_elf_modify_segment_map\n-#define elf_backend_modify_program_headers\tspu_elf_modify_program_headers\n+#define elf_backend_modify_headers\t\tspu_elf_modify_headers\n #define elf_backend_post_process_headers\tspu_elf_post_process_headers\n #define elf_backend_fake_sections\t\tspu_elf_fake_sections\n #define elf_backend_special_sections\t\tspu_elf_special_sections"
    },
    {
      "sha": "f214fa1420d64d15b18b2a5f2e60b1b5b70cb9e5",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -5429,8 +5429,8 @@ static const struct elf_x86_backend_data elf_x86_64_nacl_arch_bed =\n #define elf_backend_object_p\t\t\telf64_x86_64_nacl_elf_object_p\n #undef\telf_backend_modify_segment_map\n #define\telf_backend_modify_segment_map\t\tnacl_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n-#define\telf_backend_modify_program_headers\tnacl_modify_program_headers\n+#undef\telf_backend_modify_headers\n+#define\telf_backend_modify_headers\t\tnacl_modify_headers\n #undef\telf_backend_final_write_processing\n #define elf_backend_final_write_processing\tnacl_final_write_processing\n \n@@ -5483,7 +5483,7 @@ elf32_x86_64_nacl_elf_object_p (bfd *abfd)\n #undef\telf_backend_bfd_from_remote_memory\n #undef\telf_backend_size_info\n #undef\telf_backend_modify_segment_map\n-#undef\telf_backend_modify_program_headers\n+#undef\telf_backend_modify_headers\n #undef\telf_backend_final_write_processing\n \n /* Intel L1OM support.  */"
    },
    {
      "sha": "63917702dedf3b7596a6188d0138dfbed07235cf",
      "filename": "bfd/elfnn-ia64.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elfnn-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elfnn-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-ia64.c?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -1191,8 +1191,7 @@ elfNN_ia64_modify_segment_map (bfd *abfd,\n    for SHF_IA_64_NORECOV on each.  */\n \n static bfd_boolean\n-elfNN_ia64_modify_program_headers (bfd *abfd,\n-\t\t\t\t   struct bfd_link_info *info ATTRIBUTE_UNUSED)\n+elfNN_ia64_modify_headers (bfd *abfd, struct bfd_link_info *info)\n {\n   struct elf_obj_tdata *tdata = elf_tdata (abfd);\n   struct elf_segment_map *m;\n@@ -1224,7 +1223,7 @@ elfNN_ia64_modify_program_headers (bfd *abfd,\n       found:;\n       }\n \n-  return TRUE;\n+  return _bfd_elf_modify_headers (abfd, info);\n }\n \n /* According to the Tahoe assembler spec, all labels starting with a\n@@ -5037,8 +5036,8 @@ elfNN_hpux_backend_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,\n \telfNN_ia64_additional_program_headers\n #define elf_backend_modify_segment_map \\\n \telfNN_ia64_modify_segment_map\n-#define elf_backend_modify_program_headers \\\n-\telfNN_ia64_modify_program_headers\n+#define elf_backend_modify_headers \\\n+\telfNN_ia64_modify_headers\n #define elf_info_to_howto \\\n \telfNN_ia64_info_to_howto\n "
    },
    {
      "sha": "a10601bd5311c13c78cfbe161c36da83ce5573af",
      "filename": "bfd/elfxx-target.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elfxx-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6d6c25c8eaaf42755a759beeb2996502322b960c/bfd/elfxx-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-target.h?ref=6d6c25c8eaaf42755a759beeb2996502322b960c",
      "patch": "@@ -509,8 +509,8 @@\n #ifndef elf_backend_modify_segment_map\n #define elf_backend_modify_segment_map\t0\n #endif\n-#ifndef elf_backend_modify_program_headers\n-#define elf_backend_modify_program_headers\t0\n+#ifndef elf_backend_modify_headers\n+#define elf_backend_modify_headers\t\t_bfd_elf_modify_headers\n #endif\n #ifndef elf_backend_allow_non_load_phdr\n #define elf_backend_allow_non_load_phdr\t0\n@@ -823,7 +823,7 @@ static struct elf_backend_data elfNN_bed =\n   elf_backend_final_write_processing,\n   elf_backend_additional_program_headers,\n   elf_backend_modify_segment_map,\n-  elf_backend_modify_program_headers,\n+  elf_backend_modify_headers,\n   elf_backend_allow_non_load_phdr,\n   elf_backend_gc_keep,\n   elf_backend_gc_mark_dynamic_ref,"
    }
  ]
}