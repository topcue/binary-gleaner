{
  "sha": "50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
  "node_id": "C_kwDOANOeidoAKDUwODg4ZTQyZGNkMzJiMzBlMTE0NGMwYWE2ZDFjMTQ5MGRhNDVjZDk",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-10-05T00:47:06Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-10-25T18:51:44Z"
    },
    "message": "gdb: change functions returning value contents to use gdb::array_view\n\nThe bug fixed by this [1] patch was caused by an out-of-bounds access to\na value's content.  The code gets the value's content (just a pointer)\nand then indexes it with a non-sensical index.\n\nThis made me think of changing functions that return value contents to\nreturn array_views instead of a plain pointer.  This has the advantage\nthat when GDB is built with _GLIBCXX_DEBUG, accesses to the array_view\nare checked, making bugs more apparent / easier to find.\n\nThis patch changes the return types of these functions, and updates\ncallers to call .data() on the result, meaning it's not changing\nanything in practice.  Additional work will be needed (which can be done\nlittle by little) to make callers propagate the use of array_view and\nreap the benefits.\n\n[1] https://sourceware.org/pipermail/gdb-patches/2021-September/182306.html\n\nChange-Id: I5151f888f169e1c36abe2cbc57620110673816f3",
    "tree": {
      "sha": "72fad89d67057ecb53f26bac0464542829053e3e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/72fad89d67057ecb53f26bac0464542829053e3e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d9f82e931394efed68858eb7c7bb5832ad888482",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d9f82e931394efed68858eb7c7bb5832ad888482",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d9f82e931394efed68858eb7c7bb5832ad888482"
    }
  ],
  "stats": {
    "total": 870,
    "additions": 453,
    "deletions": 417
  },
  "files": [
    {
      "sha": "abb8be307317ccbbeb94103daa9fa068340a3de5",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1621,7 +1621,7 @@ aarch64_linux_set_memtags (struct gdbarch *gdbarch, struct value *address,\n \n       /* Update the value's content with the tag.  */\n       enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-      gdb_byte *srcbuf = value_contents_raw (address);\n+      gdb_byte *srcbuf = value_contents_raw (address).data ();\n       store_unsigned_integer (srcbuf, sizeof (addr), byte_order, addr);\n     }\n   else"
    },
    {
      "sha": "42b8494980c9618b01d2959080c2d4ee56b2675c",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1593,7 +1593,7 @@ pass_in_x (struct gdbarch *gdbarch, struct regcache *regcache,\n   int len = TYPE_LENGTH (type);\n   enum type_code typecode = type->code ();\n   int regnum = AARCH64_X0_REGNUM + info->ngrn;\n-  const bfd_byte *buf = value_contents (arg);\n+  const bfd_byte *buf = value_contents (arg).data ();\n \n   info->argnum++;\n \n@@ -1663,7 +1663,7 @@ static void\n pass_on_stack (struct aarch64_call_info *info, struct type *type,\n \t       struct value *arg)\n {\n-  const bfd_byte *buf = value_contents (arg);\n+  const bfd_byte *buf = value_contents (arg).data ();\n   int len = TYPE_LENGTH (type);\n   int align;\n   stack_item_t item;\n@@ -1739,12 +1739,12 @@ pass_in_v_vfp_candidate (struct gdbarch *gdbarch, struct regcache *regcache,\n     {\n     case TYPE_CODE_FLT:\n       return pass_in_v (gdbarch, regcache, info, TYPE_LENGTH (arg_type),\n-\t\t\tvalue_contents (arg));\n+\t\t\tvalue_contents (arg).data ());\n       break;\n \n     case TYPE_CODE_COMPLEX:\n       {\n-\tconst bfd_byte *buf = value_contents (arg);\n+\tconst bfd_byte *buf = value_contents (arg).data ();\n \tstruct type *target_type = check_typedef (TYPE_TARGET_TYPE (arg_type));\n \n \tif (!pass_in_v (gdbarch, regcache, info, TYPE_LENGTH (target_type),\n@@ -1758,7 +1758,7 @@ pass_in_v_vfp_candidate (struct gdbarch *gdbarch, struct regcache *regcache,\n     case TYPE_CODE_ARRAY:\n       if (arg_type->is_vector ())\n \treturn pass_in_v (gdbarch, regcache, info, TYPE_LENGTH (arg_type),\n-\t\t\t  value_contents (arg));\n+\t\t\t  value_contents (arg).data ());\n       /* fall through.  */\n \n     case TYPE_CODE_STRUCT:\n@@ -1900,7 +1900,7 @@ aarch64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      sp = align_down (sp - len, 16);\n \n \t      /* Write the real data into the stack.  */\n-\t      write_memory (sp, value_contents (arg), len);\n+\t      write_memory (sp, value_contents (arg).data (), len);\n \n \t      /* Construct the indirection.  */\n \t      arg_type = lookup_pointer_type (arg_type);\n@@ -2682,7 +2682,7 @@ aarch64_pseudo_read_value_1 (struct gdbarch *gdbarch,\n     mark_value_bytes_unavailable (result_value, 0,\n \t\t\t\t  TYPE_LENGTH (value_type (result_value)));\n   else\n-    memcpy (value_contents_raw (result_value), reg_buf, regsize);\n+    memcpy (value_contents_raw (result_value).data (), reg_buf, regsize);\n \n   return result_value;\n  }"
    },
    {
      "sha": "b0c915fcc46ab70fbd1818f17aa702bb60c41b5a",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 31,
      "deletions": 23,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2181,7 +2181,7 @@ decode_constrained_packed_array (struct value *arr)\n      bounds may be variable and were not passed to that function.  So,\n      we further resolve the array bounds here and then update the\n      sizes.  */\n-  const gdb_byte *valaddr = value_contents_for_printing (arr);\n+  const gdb_byte *valaddr = value_contents_for_printing (arr).data ();\n   CORE_ADDR address = value_address (arr);\n   gdb::array_view<const gdb_byte> view\n     = gdb::make_array_view (valaddr, TYPE_LENGTH (type));\n@@ -2438,7 +2438,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,\n   if (obj == NULL)\n     src = valaddr + offset;\n   else\n-    src = value_contents (obj) + offset;\n+    src = value_contents (obj).data () + offset;\n \n   if (is_dynamic_type (type))\n     {\n@@ -2488,7 +2488,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,\n   else\n     {\n       v = allocate_value (type);\n-      src = value_contents (obj) + offset;\n+      src = value_contents (obj).data () + offset;\n     }\n \n   if (obj != NULL)\n@@ -2511,7 +2511,7 @@ ada_value_primitive_packed_val (struct value *obj, const gdb_byte *valaddr,\n     }\n   else\n     set_value_bitsize (v, bit_size);\n-  unpacked = value_contents_writeable (v);\n+  unpacked = value_contents_writeable (v).data ();\n \n   if (bit_size == 0)\n     {\n@@ -2581,12 +2581,13 @@ ada_value_assign (struct value *toval, struct value *fromval)\n       if (is_big_endian && is_scalar_type (value_type (fromval)))\n \tfrom_offset = from_size - bits;\n       copy_bitwise (buffer, value_bitpos (toval),\n-\t\t    value_contents (fromval), from_offset,\n+\t\t    value_contents (fromval).data (), from_offset,\n \t\t    bits, is_big_endian);\n       write_memory_with_notification (to_addr, buffer, len);\n \n       val = value_copy (toval);\n-      memcpy (value_contents_raw (val), value_contents (fromval),\n+      memcpy (value_contents_raw (val).data (),\n+\t      value_contents (fromval).data (),\n \t      TYPE_LENGTH (type));\n       deprecated_set_value_type (val, type);\n \n@@ -2634,14 +2635,16 @@ value_assign_to_component (struct value *container, struct value *component,\n \t  = TYPE_LENGTH (value_type (component)) * TARGET_CHAR_BIT - bits;\n       else\n \tsrc_offset = 0;\n-      copy_bitwise (value_contents_writeable (container) + offset_in_container,\n+      copy_bitwise ((value_contents_writeable (container).data ()\n+\t\t     + offset_in_container),\n \t\t    value_bitpos (container) + bit_offset_in_container,\n-\t\t    value_contents (val), src_offset, bits, 1);\n+\t\t    value_contents (val).data (), src_offset, bits, 1);\n     }\n   else\n-    copy_bitwise (value_contents_writeable (container) + offset_in_container,\n+    copy_bitwise ((value_contents_writeable (container).data ()\n+\t\t   + offset_in_container),\n \t\t  value_bitpos (container) + bit_offset_in_container,\n-\t\t  value_contents (val), 0, bits, 0);\n+\t\t  value_contents (val).data (), 0, bits, 0);\n }\n \n /* Determine if TYPE is an access to an unconstrained array.  */\n@@ -4010,7 +4013,7 @@ ensure_lval (struct value *val)\n \n       VALUE_LVAL (val) = lval_memory;\n       set_value_address (val, addr);\n-      write_memory (addr, value_contents (val), len);\n+      write_memory (addr, value_contents (val).data (), len);\n     }\n \n   return val;\n@@ -4181,8 +4184,8 @@ ada_convert_actual (struct value *actual, struct type *formal_type0)\n \n \t      actual_type = ada_check_typedef (value_type (actual));\n \t      val = allocate_value (actual_type);\n-\t      memcpy ((char *) value_contents_raw (val),\n-\t\t      (char *) value_contents (actual),\n+\t      memcpy ((char *) value_contents_raw (val).data (),\n+\t\t      (char *) value_contents (actual).data (),\n \t\t      TYPE_LENGTH (actual_type));\n \t      actual = ensure_lval (val);\n \t    }\n@@ -4245,11 +4248,13 @@ make_array_descriptor (struct type *type, struct value *arr)\n   for (i = ada_array_arity (ada_check_typedef (value_type (arr)));\n        i > 0; i -= 1)\n     {\n-      modify_field (value_type (bounds), value_contents_writeable (bounds),\n+      modify_field (value_type (bounds),\n+\t\t    value_contents_writeable (bounds).data (),\n \t\t    ada_array_bound (arr, i, 0),\n \t\t    desc_bound_bitpos (bounds_type, i, 0),\n \t\t    desc_bound_bitsize (bounds_type, i, 0));\n-      modify_field (value_type (bounds), value_contents_writeable (bounds),\n+      modify_field (value_type (bounds),\n+\t\t    value_contents_writeable (bounds).data (),\n \t\t    ada_array_bound (arr, i, 1),\n \t\t    desc_bound_bitpos (bounds_type, i, 1),\n \t\t    desc_bound_bitsize (bounds_type, i, 1));\n@@ -4258,14 +4263,14 @@ make_array_descriptor (struct type *type, struct value *arr)\n   bounds = ensure_lval (bounds);\n \n   modify_field (value_type (descriptor),\n-\t\tvalue_contents_writeable (descriptor),\n+\t\tvalue_contents_writeable (descriptor).data (),\n \t\tvalue_pointer (ensure_lval (arr),\n \t\t\t       desc_type->field (0).type ()),\n \t\tfat_pntr_data_bitpos (desc_type),\n \t\tfat_pntr_data_bitsize (desc_type));\n \n   modify_field (value_type (descriptor),\n-\t\tvalue_contents_writeable (descriptor),\n+\t\tvalue_contents_writeable (descriptor).data (),\n \t\tvalue_pointer (bounds,\n \t\t\t       desc_type->field (1).type ()),\n \t\tfat_pntr_bounds_bitpos (desc_type),\n@@ -6553,7 +6558,8 @@ ada_value_primitive_field (struct value *arg1, int offset, int fieldno,\n       int bit_pos = TYPE_FIELD_BITPOS (arg_type, fieldno);\n       int bit_size = TYPE_FIELD_BITSIZE (arg_type, fieldno);\n \n-      return ada_value_primitive_packed_val (arg1, value_contents (arg1),\n+      return ada_value_primitive_packed_val (arg1,\n+\t\t\t\t\t     value_contents (arg1).data (),\n \t\t\t\t\t     offset + bit_pos / 8,\n \t\t\t\t\t     bit_pos % 8, bit_size, type);\n     }\n@@ -8480,7 +8486,7 @@ ada_to_fixed_value_create (struct type *type0, CORE_ADDR address,\n       /* Our value does not live in memory; it could be a convenience\n \t variable, for instance.  Create a not_lval value using val0's\n \t contents.  */\n-      return value_from_contents (type, value_contents (val0));\n+      return value_from_contents (type, value_contents (val0).data ());\n     }\n \n   return value_from_contents_and_address (type, 0, address);\n@@ -8916,8 +8922,9 @@ ada_promote_array_of_integrals (struct type *type, struct value *val)\n     {\n       struct value *elt = value_cast (elt_type, value_subscript (val, lo + i));\n \n-      memcpy (value_contents_writeable (res) + (i * TYPE_LENGTH (elt_type)),\n-\t      value_contents_all (elt), TYPE_LENGTH (elt_type));\n+      memcpy ((value_contents_writeable (res).data ()\n+\t       + (i * TYPE_LENGTH (elt_type))),\n+\t      value_contents_all (elt).data (), TYPE_LENGTH (elt_type));\n     }\n \n   return res;\n@@ -9033,7 +9040,7 @@ ada_value_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n     }\n \n   val = allocate_value (type1);\n-  store_unsigned_integer (value_contents_raw (val),\n+  store_unsigned_integer (value_contents_raw (val).data (),\n \t\t\t  TYPE_LENGTH (value_type (val)),\n \t\t\t  type_byte_order (type1), v);\n   return val;\n@@ -9065,7 +9072,8 @@ ada_value_equal (struct value *arg1, struct value *arg2)\n \t representations use all bits (no padding or undefined bits)\n \t and do not have user-defined equality.  */\n       return (TYPE_LENGTH (arg1_type) == TYPE_LENGTH (arg2_type)\n-\t      && memcmp (value_contents (arg1), value_contents (arg2),\n+\t      && memcmp (value_contents (arg1).data (),\n+\t\t\t value_contents (arg2).data (),\n \t\t\t TYPE_LENGTH (arg1_type)) == 0);\n     }\n   return value_equal (arg1, arg2);"
    },
    {
      "sha": "32fbc14f703d371b97dd7d1fb39ffcb691edf8f2",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -401,7 +401,7 @@ iterate_over_live_ada_tasks (ada_task_list_iterator_ftype iterator)\n static void\n value_as_string (char *dest, struct value *val, int length)\n {\n-  memcpy (dest, value_contents (val), length);\n+  memcpy (dest, value_contents (val).data (), length);\n   dest[length] = '\\0';\n }\n "
    },
    {
      "sha": "17cace04d3d9b06efeb09dd7066c75d5b136fd70",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -747,7 +747,7 @@ ada_value_print_num (struct value *val, struct ui_file *stream, int recurse,\n \t\t     const struct value_print_options *options)\n {\n   struct type *type = ada_check_typedef (value_type (val));\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n   if (type->code () == TYPE_CODE_RANGE\n       && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM\n@@ -827,7 +827,7 @@ ada_val_print_enum (struct value *value, struct ui_file *stream, int recurse,\n     }\n \n   struct type *type = ada_check_typedef (value_type (value));\n-  const gdb_byte *valaddr = value_contents_for_printing (value);\n+  const gdb_byte *valaddr = value_contents_for_printing (value).data ();\n   int offset_aligned = ada_aligned_value_addr (type, valaddr) - valaddr;\n \n   len = type->num_fields ();\n@@ -895,7 +895,7 @@ ada_value_print_array (struct value *val, struct ui_file *stream, int recurse,\n   if (ada_is_string_type (type)\n       && (options->format == 0 || options->format == 's'))\n     {\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       int offset_aligned = ada_aligned_value_addr (type, valaddr) - valaddr;\n \n       ada_val_print_string (type, valaddr, offset_aligned, stream, recurse,\n@@ -910,7 +910,7 @@ ada_value_print_array (struct value *val, struct ui_file *stream, int recurse,\n     val_print_optimized_out (val, stream);\n   else if (TYPE_FIELD_BITSIZE (type, 0) > 0)\n     {\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       int offset_aligned = ada_aligned_value_addr (type, valaddr) - valaddr;\n       val_print_packed_array_elements (type, valaddr, offset_aligned,\n \t\t\t\t       stream, recurse, options);\n@@ -1009,7 +1009,7 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n   type = value_type (val);\n   struct type *saved_type = type;\n \n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n   CORE_ADDR address = value_address (val);\n   gdb::array_view<const gdb_byte> view\n     = gdb::make_array_view (valaddr, TYPE_LENGTH (type));"
    },
    {
      "sha": "03935d1db7861e6d99688c43cc20e1703d7c7d99",
      "filename": "gdb/alpha-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/alpha-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/alpha-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -258,7 +258,7 @@ alpha_register_to_value (struct frame_info *frame, int regnum,\n   /* Convert to VALTYPE.  */\n \n   gdb_assert (TYPE_LENGTH (valtype) == 4);\n-  alpha_sts (gdbarch, out, value_contents_all (value));\n+  alpha_sts (gdbarch, out, value_contents_all (value).data ());\n \n   release_value (value);\n   return 1;\n@@ -365,7 +365,7 @@ alpha_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      sp = (sp & -16) - 16;\n \n \t      /* Write the real data into the stack.  */\n-\t      write_memory (sp, value_contents (arg), 16);\n+\t      write_memory (sp, value_contents (arg).data (), 16);\n \n \t      /* Construct the indirection.  */\n \t      arg_type = lookup_pointer_type (arg_type);\n@@ -386,7 +386,7 @@ alpha_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      sp = (sp & -16) - 16;\n \n \t      /* Write the real data into the stack.  */\n-\t      write_memory (sp, value_contents (arg), 32);\n+\t      write_memory (sp, value_contents (arg).data (), 32);\n \n \t      /* Construct the indirection.  */\n \t      arg_type = lookup_pointer_type (arg_type);\n@@ -400,7 +400,7 @@ alpha_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       m_arg->len = TYPE_LENGTH (arg_type);\n       m_arg->offset = accumulate_size;\n       accumulate_size = (accumulate_size + m_arg->len + 7) & ~7;\n-      m_arg->contents = value_contents (arg);\n+      m_arg->contents = value_contents (arg).data ();\n     }\n \n   /* Determine required argument register loads, loading an argument register"
    },
    {
      "sha": "e563d369d8cb3eb3c2f732c2fa850ec70ba8d63b",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -358,7 +358,7 @@ amd64_pseudo_register_read_value (struct gdbarch *gdbarch,\n   value *result_value = allocate_value (register_type (gdbarch, regnum));\n   VALUE_LVAL (result_value) = lval_register;\n   VALUE_REGNUM (result_value) = regnum;\n-  gdb_byte *buf = value_contents_raw (result_value);\n+  gdb_byte *buf = value_contents_raw (result_value).data ();\n \n   if (i386_byte_regnum_p (gdbarch, regnum))\n     {\n@@ -977,7 +977,7 @@ if (return_method == return_method_struct)\n       else\n \t{\n \t  /* The argument will be passed in registers.  */\n-\t  const gdb_byte *valbuf = value_contents (args[i]);\n+\t  const gdb_byte *valbuf = value_contents (args[i]).data ();\n \t  gdb_byte buf[8];\n \n \t  gdb_assert (len <= 16);\n@@ -1029,7 +1029,7 @@ if (return_method == return_method_struct)\n   for (i = 0; i < num_stack_args; i++)\n     {\n       struct type *type = value_type (stack_args[i]);\n-      const gdb_byte *valbuf = value_contents (stack_args[i]);\n+      const gdb_byte *valbuf = value_contents (stack_args[i]).data ();\n       int len = TYPE_LENGTH (type);\n \n       write_memory (sp + element * 8, valbuf, len);"
    },
    {
      "sha": "ed783f6420ce776ba86a3c462de23329d25bcb0e",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -179,7 +179,7 @@ amd64_windows_adjust_args_passed_by_pointer (struct value **args,\n     if (amd64_windows_passed_by_pointer (value_type (args[i])))\n       {\n \tstruct type *type = value_type (args[i]);\n-\tconst gdb_byte *valbuf = value_contents (args[i]);\n+\tconst gdb_byte *valbuf = value_contents (args[i]).data ();\n \tconst int len = TYPE_LENGTH (type);\n \n \t/* Store a copy of that argument on the stack, aligned to\n@@ -205,7 +205,7 @@ amd64_windows_store_arg_in_reg (struct regcache *regcache,\n \t\t\t\tstruct value *arg, int regno)\n {\n   struct type *type = value_type (arg);\n-  const gdb_byte *valbuf = value_contents (arg);\n+  const gdb_byte *valbuf = value_contents (arg).data ();\n   gdb_byte buf[8];\n \n   gdb_assert (TYPE_LENGTH (type) <= 8);\n@@ -295,7 +295,7 @@ amd64_windows_push_arguments (struct regcache *regcache, int nargs,\n   for (i = 0; i < num_stack_args; i++)\n     {\n       struct type *type = value_type (stack_args[i]);\n-      const gdb_byte *valbuf = value_contents (stack_args[i]);\n+      const gdb_byte *valbuf = value_contents (stack_args[i]).data ();\n \n       write_memory (sp + element * 8, valbuf, TYPE_LENGTH (type));\n       element += ((TYPE_LENGTH (type) + 7) / 8);"
    },
    {
      "sha": "35874ebb5109ed7347235109ad374f60f6aceb52",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -779,9 +779,10 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  unsigned int len = TYPE_LENGTH (value_type (args[i]));\n \t  unsigned int space = align_up (len, 4);\n \n-\t  memcpy (data, value_contents (args[i]), (size_t) len);\n+\t  memcpy (data, value_contents (args[i]).data (), (size_t) len);\n \t  arc_debug_printf (\"copying arg %d, val 0x%08x, len %d to mem\",\n-\t\t\t    i, *((int *) value_contents (args[i])), len);\n+\t\t\t    i, *((int *) value_contents (args[i]).data ()),\n+\t\t\t    len);\n \n \t  data += space;\n \t}"
    },
    {
      "sha": "768844dd6c918334540ff59430034c74e1999db5",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -3820,7 +3820,7 @@ arm_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       len = TYPE_LENGTH (arg_type);\n       target_type = TYPE_TARGET_TYPE (arg_type);\n       typecode = arg_type->code ();\n-      val = value_contents (args[argnum]);\n+      val = value_contents (args[argnum]).data ();\n \n       align = type_align (arg_type);\n       /* Round alignment up to a whole number of words.  */"
    },
    {
      "sha": "ea259b9a5c14b8657abe7a3ba0c7f0fde038ea68",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1296,7 +1296,7 @@ avr_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       int j;\n       struct value *arg = args[i];\n       struct type *type = check_typedef (value_type (arg));\n-      const bfd_byte *contents = value_contents (arg);\n+      const bfd_byte *contents = value_contents (arg).data ();\n       int len = TYPE_LENGTH (type);\n \n       /* Calculate the potential last register needed."
    },
    {
      "sha": "d381f927b8f7186f4e494d45902713da1d29589f",
      "filename": "gdb/bfin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/bfin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/bfin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -530,7 +530,7 @@ bfin_push_dummy_call (struct gdbarch *gdbarch,\n       int container_len = align_up (TYPE_LENGTH (arg_type), 4);\n \n       sp -= container_len;\n-      write_memory (sp, value_contents (args[i]), container_len);\n+      write_memory (sp, value_contents (args[i]).data (), container_len);\n     }\n \n   /* Initialize R0, R1, and R2 to the first 3 words of parameters.  */"
    },
    {
      "sha": "de96f911900cd14a49643cf844f2e66e5dcbabe9",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1695,7 +1695,7 @@ extract_bitfield_from_watchpoint_value (struct watchpoint *w, struct value *val)\n   unpack_value_bitfield (bit_val,\n \t\t\t w->val_bitpos,\n \t\t\t w->val_bitsize,\n-\t\t\t value_contents_for_printing (val),\n+\t\t\t value_contents_for_printing (val).data (),\n \t\t\t value_offset (val),\n \t\t\t val);\n "
    },
    {
      "sha": "2a7dd4dd194d330f731b620b3afbdf20954b1d6d",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -302,7 +302,7 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n       && (*length < 0 || *length <= fetchlimit))\n     {\n       int i;\n-      const gdb_byte *contents = value_contents (value);\n+      const gdb_byte *contents = value_contents (value).data ();\n \n       /* If a length is specified, use that.  */\n       if (*length >= 0)\n@@ -675,7 +675,7 @@ c_string_operation::evaluate (struct type *expect_type,\n \t    error (_(\"Too many array elements\"));\n \n \t  result = allocate_value (expect_type);\n-\t  memcpy (value_contents_raw (result), obstack_base (&output),\n+\t  memcpy (value_contents_raw (result).data (), obstack_base (&output),\n \t\t  obstack_object_size (&output));\n \t}\n       else"
    },
    {
      "sha": "c491d37020d1766f18bb8e403644b07e7abf6f8e",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -237,7 +237,7 @@ c_value_print_array (struct value *val,\n {\n   struct type *type = check_typedef (value_type (val));\n   CORE_ADDR address = value_address (val);\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n   struct type *unresolved_elttype = TYPE_TARGET_TYPE (type);\n   struct type *elttype = check_typedef (unresolved_elttype);\n \n@@ -333,7 +333,7 @@ c_value_print_ptr (struct value *val, struct ui_file *stream, int recurse,\n     }\n \n   struct type *type = check_typedef (value_type (val));\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n   if (options->vtblprint && cp_is_vtbl_ptr_type (type))\n     {\n@@ -374,7 +374,7 @@ c_value_print_struct (struct value *val, struct ui_file *stream, int recurse,\n \t TYPE_CODE_PTR.)  */\n       int offset = TYPE_FIELD_BITPOS (type, VTBL_FNADDR_OFFSET) / 8;\n       struct type *field_type = type->field (VTBL_FNADDR_OFFSET).type ();\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       CORE_ADDR addr = extract_typed_address (valaddr + offset, field_type);\n \n       print_function_pointer_address (options, type->arch (), addr, stream);\n@@ -405,7 +405,7 @@ c_value_print_int (struct value *val, struct ui_file *stream,\n \t intended to be used as an integer or a character, print\n \t the character equivalent as well.  */\n       struct type *type = value_type (val);\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       if (c_textual_element_type (type, options->format))\n \t{\n \t  fputs_filtered (\" \", stream);"
    },
    {
      "sha": "9b77409b86f6f06f1c4f13742112fbc8a935cb38",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2075,7 +2075,7 @@ setting_cmd (const char *fnname, struct cmd_list_element *showlist,\n       && type0->code () != TYPE_CODE_STRING)\n     error (_(\"First argument of %s must be a string.\"), fnname);\n \n-  const char *a0 = (const char *) value_contents (argv[0]);\n+  const char *a0 = (const char *) value_contents (argv[0]).data ();\n   cmd_list_element *cmd = lookup_cmd (&a0, showlist, \"\", NULL, -1, 0);\n \n   if (cmd == nullptr || cmd->type != show_cmd)"
    },
    {
      "sha": "cb2070894a196408ea8aced4326aa8eefb31da35",
      "filename": "gdb/cli/cli-dump.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cli/cli-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cli/cli-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-dump.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -224,7 +224,7 @@ dump_value_to_file (const char *cmd, const char *mode, const char *file_format)\n \n   /* Have everything.  Open/write the data.  */\n   if (file_format == NULL || strcmp (file_format, \"binary\") == 0)\n-    dump_binary_file (filename.get (), mode, value_contents (val),\n+    dump_binary_file (filename.get (), mode, value_contents (val).data (),\n \t\t      TYPE_LENGTH (value_type (val)));\n   else\n     {\n@@ -241,7 +241,7 @@ dump_value_to_file (const char *cmd, const char *mode, const char *file_format)\n \t}\n \n       dump_bfd_file (filename.get (), mode, file_format, vaddr,\n-\t\t     value_contents (val), \n+\t\t     value_contents (val).data (), \n \t\t     TYPE_LENGTH (value_type (val)));\n     }\n }"
    },
    {
      "sha": "6786b422ec9f938b4f52654a982b8a49e5ed212a",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -585,7 +585,8 @@ store_regs (struct type *regs_type, CORE_ADDR regs_base)\n \terror (_(\"Register \\\"%s\\\" is not available.\"), reg_name);\n \n       inferior_addr = regs_base + reg_offset;\n-      if (0 != target_write_memory (inferior_addr, value_contents (regval),\n+      if (0 != target_write_memory (inferior_addr,\n+\t\t\t\t    value_contents (regval).data (),\n \t\t\t\t    reg_size))\n \terror (_(\"Cannot write register \\\"%s\\\" to inferior memory at %s.\"),\n \t       reg_name, paddress (gdbarch, inferior_addr));"
    },
    {
      "sha": "10237289f6ca350cc15269cab1c1c63c115d77cb",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -189,7 +189,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n       vptr_fieldno = get_vptr_fieldno (type, &vptr_basetype);\n       for (i = n_baseclasses; i < len; i++)\n \t{\n-\t  const gdb_byte *valaddr = value_contents_for_printing (val);\n+\t  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n \t  /* If requested, skip printing of static fields.  */\n \t  if (!options->static_field_print\n@@ -397,7 +397,7 @@ cp_print_value (struct value *val, struct ui_file *stream,\n     = (struct type **) obstack_next_free (&dont_print_vb_obstack);\n   struct obstack tmp_obstack = dont_print_vb_obstack;\n   int i, n_baseclasses = TYPE_N_BASECLASSES (type);\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n   if (dont_print_vb == 0)\n     {\n@@ -761,7 +761,7 @@ test_print_fields (gdbarch *arch)\n     }\n \n   value *val = allocate_value (the_struct);\n-  gdb_byte *contents = value_contents_writeable (val);\n+  gdb_byte *contents = value_contents_writeable (val).data ();\n   store_unsigned_integer (contents, TYPE_LENGTH (value_enclosing_type (val)),\n \t\t\t  gdbarch_byte_order (arch), 0xe9);\n "
    },
    {
      "sha": "6b5dfc33076d6f04ac2d2345a1d5ea290cb6c387",
      "filename": "gdb/cris-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cris-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/cris-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -821,7 +821,7 @@ cris_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       int i;\n       \n       len = TYPE_LENGTH (value_type (args[argnum]));\n-      val = value_contents (args[argnum]);\n+      val = value_contents (args[argnum]).data ();\n       \n       /* How may registers worth of storage do we need for this argument?  */\n       reg_demand = (len / 4) + (len % 4 != 0 ? 1 : 0);"
    },
    {
      "sha": "8835aba5e64d5dbd2f9235dc0cfd7ac87214487e",
      "filename": "gdb/csky-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/csky-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/csky-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/csky-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -362,7 +362,7 @@ csky_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       arg_type = check_typedef (value_type (args[argnum]));\n       len = TYPE_LENGTH (arg_type);\n-      val = value_contents (args[argnum]);\n+      val = value_contents (args[argnum]).data ();\n \n       /* Copy the argument to argument registers or the dummy stack.\n \t Large arguments are split between registers and stack."
    },
    {
      "sha": "4b73c96857827ecb0022b32e110362d00820a7d5",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -48,7 +48,7 @@ dynamic_array_type (struct type *type,\n       struct type *ptr_type;\n       struct value *ival;\n       int length;\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n       length = unpack_field_as_long (type, valaddr + embedded_offset, 0);\n "
    },
    {
      "sha": "bdfd518dc7f2e696bbe2b9ac5eb6e1ff6b29a39e",
      "filename": "gdb/dummy-frame.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dummy-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dummy-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dummy-frame.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -353,8 +353,8 @@ dummy_frame_prev_register (struct frame_info *this_frame,\n   /* Use the regcache_cooked_read() method so that it, on the fly,\n      constructs either a raw or pseudo register from the raw\n      register cache.  */\n-  cache->prev_regcache->cooked_read (regnum,\n-\t\t\t\t     value_contents_writeable (reg_val));\n+  cache->prev_regcache->cooked_read\n+    (regnum, value_contents_writeable (reg_val).data ());\n   return reg_val;\n }\n "
    },
    {
      "sha": "652161955d5265ff48922f21606e5b5b9f8de55b",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -169,7 +169,7 @@ rw_pieced_value (value *v, value *from, bool check_optimized)\n   gdb_assert (!check_optimized || from == nullptr);\n   if (from != nullptr)\n     {\n-      from_contents = value_contents (from);\n+      from_contents = value_contents (from).data ();\n       v_contents = nullptr;\n     }\n   else\n@@ -181,7 +181,7 @@ rw_pieced_value (value *v, value *from, bool check_optimized)\n       if (check_optimized)\n \tv_contents = nullptr;\n       else\n-\tv_contents = value_contents_raw (v);\n+\tv_contents = value_contents_raw (v).data ();\n       from_contents = nullptr;\n     }\n \n@@ -394,7 +394,7 @@ rw_pieced_value (value *v, value *from, bool check_optimized)\n \t      bits_to_skip += p->offset;\n \n \t    copy_bitwise (v_contents, offset,\n-\t\t\t  value_contents_all (p->v.value),\n+\t\t\t  value_contents_all (p->v.value).data (),\n \t\t\t  bits_to_skip,\n \t\t\t  this_size_bits, bits_big_endian);\n \t  }\n@@ -577,7 +577,7 @@ indirect_pieced_value (value *value)\n      encode address spaces and other things in CORE_ADDR.  */\n   bfd_endian byte_order = gdbarch_byte_order (get_frame_arch (frame));\n   LONGEST byte_offset\n-    = extract_signed_integer (value_contents (value),\n+    = extract_signed_integer (value_contents (value).data (),\n \t\t\t      TYPE_LENGTH (type), byte_order);\n   byte_offset += piece->v.ptr.offset;\n \n@@ -1037,8 +1037,8 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG)\n \t      subobj_offset += n - max;\n \n-\t    memcpy (value_contents_raw (retval),\n-\t\t    value_contents_all (val) + subobj_offset, len);\n+\t    memcpy (value_contents_raw (retval).data (),\n+\t\t    value_contents_all (val).data () + subobj_offset, len);\n \t  }\n \t  break;\n \n@@ -1050,7 +1050,7 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t      invalid_synthetic_pointer ();\n \n \t    retval = allocate_value (subobj_type);\n-\t    bfd_byte *contents = value_contents_raw (retval);\n+\t    bfd_byte *contents = value_contents_raw (retval).data ();\n \t    memcpy (contents, this->m_data + subobj_offset, n);\n \t  }\n \t  break;\n@@ -1157,7 +1157,7 @@ dwarf_expr_context::fetch_address (int n)\n   ULONGEST result;\n \n   dwarf_require_integral (value_type (result_val));\n-  result = extract_unsigned_integer (value_contents (result_val),\n+  result = extract_unsigned_integer (value_contents (result_val).data (),\n \t\t\t\t     TYPE_LENGTH (value_type (result_val)),\n \t\t\t\t     byte_order);\n \n@@ -2366,7 +2366,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    else\n \t      result_val\n \t\t= value_from_contents (type,\n-\t\t\t\t       value_contents_all (result_val));\n+\t\t\t\t       value_contents_all (result_val).data ());\n \t  }\n \t  break;\n "
    },
    {
      "sha": "33f0d99f069e9007dd502eaa99b75b7b86d9d791",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1338,7 +1338,8 @@ value_of_dwarf_reg_entry (struct type *type, struct frame_info *frame,\n \t\t\t\t release_value (target_val).release ());\n \n   /* Copy the referencing pointer to the new computed value.  */\n-  memcpy (value_contents_raw (val), value_contents_raw (outer_val),\n+  memcpy (value_contents_raw (val).data (),\n+\t  value_contents_raw (outer_val).data (),\n \t  TYPE_LENGTH (checked_type));\n   set_value_lazy (val, 0);\n "
    },
    {
      "sha": "bd0754618d0ceaea942b9057c74652106025395f",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -10045,7 +10045,7 @@ dwarf2_compute_name (const char *name,\n \t\t      else if (bytes != NULL)\n \t\t\t{\n \t\t\t  v = allocate_value (type);\n-\t\t\t  memcpy (value_contents_writeable (v), bytes,\n+\t\t\t  memcpy (value_contents_writeable (v).data (), bytes,\n \t\t\t\t  TYPE_LENGTH (type));\n \t\t\t}\n \t\t      else"
    },
    {
      "sha": "463e09179f7c6eeb2194c540fdb4cf7fb4d8e7f5",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1020,7 +1020,7 @@ elf_gnu_ifunc_resolver_return_stop (struct breakpoint *b)\n \n   value = allocate_value (value_type);\n   gdbarch_return_value (gdbarch, func_func, value_type, regcache,\n-\t\t\tvalue_contents_raw (value), NULL);\n+\t\t\tvalue_contents_raw (value).data (), NULL);\n   resolved_address = value_as_address (value);\n   resolved_pc = gdbarch_convert_from_func_ptr_addr\n     (gdbarch, resolved_address, current_inferior ()->top_target ());"
    },
    {
      "sha": "6416ac55b7081d34bec47484f08f39cfc4c7c2f6",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2322,12 +2322,12 @@ array_operation::evaluate_struct_tuple (struct value *struct_val,\n \n       bitsize = TYPE_FIELD_BITSIZE (struct_type, fieldno);\n       bitpos = TYPE_FIELD_BITPOS (struct_type, fieldno);\n-      addr = value_contents_writeable (struct_val) + bitpos / 8;\n+      addr = value_contents_writeable (struct_val).data () + bitpos / 8;\n       if (bitsize)\n \tmodify_field (struct_type, addr,\n \t\t      value_as_long (val), bitpos % 8, bitsize);\n       else\n-\tmemcpy (addr, value_contents (val),\n+\tmemcpy (addr, value_contents (val).data (),\n \t\tTYPE_LENGTH (value_type (val)));\n \n     }\n@@ -2351,7 +2351,7 @@ array_operation::evaluate (struct type *expect_type,\n     {\n       struct value *rec = allocate_value (expect_type);\n \n-      memset (value_contents_raw (rec), '\\0', TYPE_LENGTH (type));\n+      memset (value_contents_raw (rec).data (), '\\0', TYPE_LENGTH (type));\n       return evaluate_struct_tuple (rec, exp, noside, nargs);\n     }\n \n@@ -2370,7 +2370,7 @@ array_operation::evaluate (struct type *expect_type,\n \t  high_bound = (TYPE_LENGTH (type) / element_size) - 1;\n \t}\n       index = low_bound;\n-      memset (value_contents_raw (array), 0, TYPE_LENGTH (expect_type));\n+      memset (value_contents_raw (array).data (), 0, TYPE_LENGTH (expect_type));\n       for (tem = nargs; --nargs >= 0;)\n \t{\n \t  struct value *element;\n@@ -2382,9 +2382,9 @@ array_operation::evaluate (struct type *expect_type,\n \t  if (index > high_bound)\n \t    /* To avoid memory corruption.  */\n \t    error (_(\"Too many array elements\"));\n-\t  memcpy (value_contents_raw (array)\n+\t  memcpy (value_contents_raw (array).data ()\n \t\t  + (index - low_bound) * element_size,\n-\t\t  value_contents (element),\n+\t\t  value_contents (element).data (),\n \t\t  element_size);\n \t  index++;\n \t}\n@@ -2395,7 +2395,7 @@ array_operation::evaluate (struct type *expect_type,\n       && type->code () == TYPE_CODE_SET)\n     {\n       struct value *set = allocate_value (expect_type);\n-      gdb_byte *valaddr = value_contents_raw (set);\n+      gdb_byte *valaddr = value_contents_raw (set).data ();\n       struct type *element_type = type->index_type ();\n       struct type *check_type = element_type;\n       LONGEST low_bound, high_bound;"
    },
    {
      "sha": "1b5a99c5961cfb83e9010ba17e97d1f36bca91fc",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 17,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -770,7 +770,7 @@ eval_op_f_abs (struct type *expect_type, struct expression *exp,\n     case TYPE_CODE_FLT:\n       {\n \tdouble d\n-\t  = fabs (target_float_to_host_double (value_contents (arg1),\n+\t  = fabs (target_float_to_host_double (value_contents (arg1).data (),\n \t\t\t\t\t       value_type (arg1)));\n \treturn value_from_host_double (type, d);\n       }\n@@ -800,10 +800,10 @@ eval_op_f_mod (struct type *expect_type, struct expression *exp,\n     case TYPE_CODE_FLT:\n       {\n \tdouble d1\n-\t  = target_float_to_host_double (value_contents (arg1),\n+\t  = target_float_to_host_double (value_contents (arg1).data (),\n \t\t\t\t\t value_type (arg1));\n \tdouble d2\n-\t  = target_float_to_host_double (value_contents (arg2),\n+\t  = target_float_to_host_double (value_contents (arg2).data (),\n \t\t\t\t\t value_type (arg2));\n \tdouble d3 = fmod (d1, d2);\n \treturn value_from_host_double (type, d3);\n@@ -833,7 +833,7 @@ eval_op_f_ceil (struct type *expect_type, struct expression *exp,\n   if (type->code () != TYPE_CODE_FLT)\n     error (_(\"argument to CEILING must be of type float\"));\n   double val\n-    = target_float_to_host_double (value_contents (arg1),\n+    = target_float_to_host_double (value_contents (arg1).data (),\n \t\t\t\t   value_type (arg1));\n   val = ceil (val);\n   return value_from_host_double (type, val);\n@@ -851,7 +851,7 @@ eval_op_f_floor (struct type *expect_type, struct expression *exp,\n   if (type->code () != TYPE_CODE_FLT)\n     error (_(\"argument to FLOOR must be of type float\"));\n   double val\n-    = target_float_to_host_double (value_contents (arg1),\n+    = target_float_to_host_double (value_contents (arg1).data (),\n \t\t\t\t   value_type (arg1));\n   val = floor (val);\n   return value_from_host_double (type, val);\n@@ -883,10 +883,10 @@ eval_op_f_modulo (struct type *expect_type, struct expression *exp,\n     case TYPE_CODE_FLT:\n       {\n \tdouble a\n-\t  = target_float_to_host_double (value_contents (arg1),\n+\t  = target_float_to_host_double (value_contents (arg1).data (),\n \t\t\t\t\t value_type (arg1));\n \tdouble p\n-\t  = target_float_to_host_double (value_contents (arg2),\n+\t  = target_float_to_host_double (value_contents (arg2).data (),\n \t\t\t\t\t value_type (arg2));\n \tdouble result = fmod (a, p);\n \tif (result != 0 && (a < 0.0) != (p < 0.0))\n@@ -1384,11 +1384,9 @@ fortran_undetermined::value_subarray (value *array,\n \t    array = value_at_lazy (array_slice_type,\n \t\t\t\t   value_address (array) + total_offset);\n \t  else\n-\t    array = value_from_contents_and_address (array_slice_type,\n-\t\t\t\t\t\t     (value_contents (array)\n-\t\t\t\t\t\t      + total_offset),\n-\t\t\t\t\t\t     (value_address (array)\n-\t\t\t\t\t\t      + total_offset));\n+\t    array = value_from_contents_and_address\n+\t      (array_slice_type, value_contents (array).data () + total_offset,\n+\t       value_address (array) + total_offset);\n \t}\n       else if (!value_lazy (array))\n \tarray = value_from_component (array, array_slice_type, total_offset);\n@@ -1518,7 +1516,7 @@ fortran_structop_operation::evaluate (struct type *expect_type,\n       struct type *elt_type = value_type (elt);\n       if (is_dynamic_type (elt_type))\n \t{\n-\t  const gdb_byte *valaddr = value_contents_for_printing (elt);\n+\t  const gdb_byte *valaddr = value_contents_for_printing (elt).data ();\n \t  CORE_ADDR address = value_address (elt);\n \t  gdb::array_view<const gdb_byte> view\n \t    = gdb::make_array_view (valaddr, TYPE_LENGTH (elt_type));\n@@ -1746,10 +1744,9 @@ fortran_argument_convert (struct value *value, bool is_artificial)\n \t  const int length = TYPE_LENGTH (type);\n \t  const CORE_ADDR addr\n \t    = value_as_long (value_allocate_space_in_inferior (length));\n-\t  write_memory (addr, value_contents (value), length);\n-\t  struct value *val\n-\t    = value_from_contents_and_address (type, value_contents (value),\n-\t\t\t\t\t       addr);\n+\t  write_memory (addr, value_contents (value).data (), length);\n+\t  struct value *val = value_from_contents_and_address\n+\t    (type, value_contents (value).data (), addr);\n \t  return value_addr (val);\n \t}\n       else"
    },
    {
      "sha": "7d7130a29c577f4f123d58b06719f3c18460ed76",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -223,7 +223,7 @@ f_language::value_print_inner (struct value *val, struct ui_file *stream,\n   struct type *elttype;\n   CORE_ADDR addr;\n   int index;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n   const CORE_ADDR address = value_address (val);\n \n   switch (type->code ())"
    },
    {
      "sha": "812c22e37312fd15464629f51e742e7f4baa3d8c",
      "filename": "gdb/findcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/findcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/findcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findcmd.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -185,7 +185,7 @@ parse_find_args (const char *args, ULONGEST *max_countp,\n \t}\n       else\n \t{\n-\t  const gdb_byte *contents = value_contents (v);\n+\t  const gdb_byte *contents = value_contents (v).data ();\n \t  pattern_buf.insert (pattern_buf.end (), contents,\n \t\t\t      contents + TYPE_LENGTH (t));\n \t}"
    },
    {
      "sha": "d2b77133982acd07505c5044c66f82d6e2a5f83d",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -627,7 +627,7 @@ language_defn::read_var_value (struct symbol *var,\n \t}\n       /* Put the constant back in target format. */\n       v = allocate_value (type);\n-      store_signed_integer (value_contents_raw (v), TYPE_LENGTH (type),\n+      store_signed_integer (value_contents_raw (v).data (), TYPE_LENGTH (type),\n \t\t\t    type_byte_order (type),\n \t\t\t    (LONGEST) SYMBOL_VALUE (var));\n       VALUE_LVAL (v) = not_lval;\n@@ -641,10 +641,10 @@ language_defn::read_var_value (struct symbol *var,\n \t  struct objfile *var_objfile = symbol_objfile (var);\n \t  addr = symbol_overlayed_address (SYMBOL_VALUE_ADDRESS (var),\n \t\t\t\t\t   var->obj_section (var_objfile));\n-\t  store_typed_address (value_contents_raw (v), type, addr);\n+\t  store_typed_address (value_contents_raw (v).data (), type, addr);\n \t}\n       else\n-\tstore_typed_address (value_contents_raw (v), type,\n+\tstore_typed_address (value_contents_raw (v).data (), type,\n \t\t\t      SYMBOL_VALUE_ADDRESS (var));\n       VALUE_LVAL (v) = not_lval;\n       return v;\n@@ -656,7 +656,7 @@ language_defn::read_var_value (struct symbol *var,\n \t  type = resolve_dynamic_type (type, {}, /* Unused address.  */ 0);\n \t}\n       v = allocate_value (type);\n-      memcpy (value_contents_raw (v), SYMBOL_VALUE_BYTES (var),\n+      memcpy (value_contents_raw (v).data (), SYMBOL_VALUE_BYTES (var),\n \t      TYPE_LENGTH (type));\n       VALUE_LVAL (v) = not_lval;\n       return v;\n@@ -926,7 +926,7 @@ value_from_register (struct type *type, int regnum, struct frame_info *frame)\n       VALUE_NEXT_FRAME_ID (v) = get_frame_id (get_next_frame_sentinel_okay (frame));\n       VALUE_REGNUM (v) = regnum;\n       ok = gdbarch_register_to_value (gdbarch, frame, regnum, type1,\n-\t\t\t\t      value_contents_raw (v), &optim,\n+\t\t\t\t      value_contents_raw (v).data (), &optim,\n \t\t\t\t      &unavail);\n \n       if (!ok)"
    },
    {
      "sha": "8110278ff1b2f34313ef4af1458fd62658b6a3fb",
      "filename": "gdb/frame-unwind.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frame-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frame-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -300,7 +300,7 @@ frame_unwind_got_constant (struct frame_info *frame, int regnum,\n   struct value *reg_val;\n \n   reg_val = value_zero (register_type (gdbarch, regnum), not_lval);\n-  store_unsigned_integer (value_contents_writeable (reg_val),\n+  store_unsigned_integer (value_contents_writeable (reg_val).data (),\n \t\t\t  register_size (gdbarch, regnum), byte_order, val);\n   return reg_val;\n }\n@@ -312,7 +312,8 @@ frame_unwind_got_bytes (struct frame_info *frame, int regnum, const gdb_byte *bu\n   struct value *reg_val;\n \n   reg_val = value_zero (register_type (gdbarch, regnum), not_lval);\n-  memcpy (value_contents_raw (reg_val), buf, register_size (gdbarch, regnum));\n+  memcpy (value_contents_raw (reg_val).data (), buf,\n+\t  register_size (gdbarch, regnum));\n   return reg_val;\n }\n \n@@ -328,7 +329,7 @@ frame_unwind_got_address (struct frame_info *frame, int regnum,\n   struct value *reg_val;\n \n   reg_val = value_zero (register_type (gdbarch, regnum), not_lval);\n-  pack_long (value_contents_writeable (reg_val),\n+  pack_long (value_contents_writeable (reg_val).data (),\n \t     register_type (gdbarch, regnum), addr);\n   return reg_val;\n }"
    },
    {
      "sha": "b121892f799a5f0d2089ce5df43087f608d87a17",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 13,
      "deletions": 10,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1156,7 +1156,7 @@ frame_register_unwind (frame_info *next_frame, int regnum,\n   if (bufferp)\n     {\n       if (!*optimizedp && !*unavailablep)\n-\tmemcpy (bufferp, value_contents_all (value),\n+\tmemcpy (bufferp, value_contents_all (value).data (),\n \t\tTYPE_LENGTH (value_type (value)));\n       else\n \tmemset (bufferp, 0, TYPE_LENGTH (value_type (value)));\n@@ -1261,7 +1261,7 @@ frame_unwind_register_value (frame_info *next_frame, int regnum)\n \t  else\n \t    {\n \t      int i;\n-\t      const gdb_byte *buf = value_contents (value);\n+\t      const gdb_byte *buf = value_contents (value).data ();\n \n \t      fprintf_unfiltered (&debug_file, \" bytes=\");\n \t      fprintf_unfiltered (&debug_file, \"[\");\n@@ -1304,7 +1304,7 @@ frame_unwind_register_signed (frame_info *next_frame, int regnum)\n \t\t   _(\"Register %d is not available\"), regnum);\n     }\n \n-  LONGEST r = extract_signed_integer (value_contents_all (value), size,\n+  LONGEST r = extract_signed_integer (value_contents_all (value).data (), size,\n \t\t\t\t      byte_order);\n \n   release_value (value);\n@@ -1338,8 +1338,8 @@ frame_unwind_register_unsigned (frame_info *next_frame, int regnum)\n \t\t   _(\"Register %d is not available\"), regnum);\n     }\n \n-  ULONGEST r = extract_unsigned_integer (value_contents_all (value), size,\n-\t\t\t\t\t byte_order);\n+  ULONGEST r = extract_unsigned_integer (value_contents_all (value).data (),\n+\t\t\t\t\t size, byte_order);\n \n   release_value (value);\n   return r;\n@@ -1364,7 +1364,8 @@ read_frame_register_unsigned (frame_info *frame, int regnum,\n       enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n       int size = register_size (gdbarch, VALUE_REGNUM (regval));\n \n-      *val = extract_unsigned_integer (value_contents (regval), size, byte_order);\n+      *val = extract_unsigned_integer (value_contents (regval).data (), size,\n+\t\t\t\t       byte_order);\n       return true;\n     }\n \n@@ -1496,7 +1497,8 @@ get_frame_register_bytes (frame_info *frame, int regnum,\n \t      return false;\n \t    }\n \n-\t  memcpy (myaddr, value_contents_all (value) + offset, curr_len);\n+\t  memcpy (myaddr, value_contents_all (value).data () + offset,\n+\t\t  curr_len);\n \t  release_value (value);\n \t}\n \n@@ -1546,9 +1548,10 @@ put_frame_register_bytes (struct frame_info *frame, int regnum,\n \t\t\t\t\t\t\t     regnum);\n \t  gdb_assert (value != NULL);\n \n-\t  memcpy ((char *) value_contents_writeable (value) + offset, myaddr,\n-\t\t  curr_len);\n-\t  put_frame_register (frame, regnum, value_contents_raw (value));\n+\t  memcpy ((char *) value_contents_writeable (value).data () + offset,\n+\t\t  myaddr, curr_len);\n+\t  put_frame_register (frame, regnum,\n+\t\t\t      value_contents_raw (value).data ());\n \t  release_value (value);\n \t}\n "
    },
    {
      "sha": "e105c27ae82deafca18e4e1f58d05522363f5ca4",
      "filename": "gdb/frv-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/frv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1259,7 +1259,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  /* The FDPIC ABI requires function descriptors to be passed instead\n \t     of entry points.  */\n \t  CORE_ADDR addr = extract_unsigned_integer\n-\t\t\t     (value_contents (arg), 4, byte_order);\n+\t\t\t     (value_contents (arg).data (), 4, byte_order);\n \t  addr = find_func_descr (gdbarch, addr);\n \t  store_unsigned_integer (valbuf, 4, byte_order, addr);\n \t  typecode = TYPE_CODE_PTR;\n@@ -1268,7 +1268,7 @@ frv_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t}\n       else\n \t{\n-\t  val = value_contents (arg);\n+\t  val = value_contents (arg).data ();\n \t}\n \n       while (len > 0)"
    },
    {
      "sha": "c947215d1094424634e26a907b508b88614a1f00",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -3878,7 +3878,7 @@ is_unique_ancestor (struct type *base, struct value *val)\n   int offset = -1;\n \n   return is_unique_ancestor_worker (base, value_type (val), &offset,\n-\t\t\t\t    value_contents_for_printing (val),\n+\t\t\t\t    value_contents_for_printing (val).data (),\n \t\t\t\t    value_embedded_offset (val),\n \t\t\t\t    value_address (val), val) == 1;\n }"
    },
    {
      "sha": "93113710137de36febca52d1944d78a2f08a9b51",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -729,7 +729,7 @@ static struct value *\n gnuv3_method_ptr_to_value (struct value **this_p, struct value *method_ptr)\n {\n   struct gdbarch *gdbarch;\n-  const gdb_byte *contents = value_contents (method_ptr);\n+  const gdb_byte *contents = value_contents (method_ptr).data ();\n   CORE_ADDR ptr_value;\n   struct type *self_type, *final_type, *method_type;\n   LONGEST adjustment;"
    },
    {
      "sha": "5001e676b9e0f9da13141e951fe4d7d704ce0ff0",
      "filename": "gdb/go-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/go-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/go-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -52,7 +52,7 @@ print_go_string (struct type *type,\n      unpack_value_field_as_pointer.  Do this until we can get\n      unpack_value_field_as_pointer.  */\n   LONGEST addr;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n \n   if (! unpack_value_field_as_long (type, valaddr, embedded_offset, 0,"
    },
    {
      "sha": "659acf0c423145f029a2ab295398b7e6a42d34d2",
      "filename": "gdb/guile/scm-value.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/guile/scm-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/guile/scm-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-value.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -828,7 +828,7 @@ gdbscm_value_to_bytevector (SCM self)\n     {\n       type = check_typedef (type);\n       length = TYPE_LENGTH (type);\n-      contents = value_contents (value);\n+      contents = value_contents (value).data ();\n     }\n   catch (const gdb_exception &except)\n     {\n@@ -978,7 +978,8 @@ gdbscm_value_to_real (SCM self)\n     {\n       if (is_floating_value (value))\n \t{\n-\t  d = target_float_to_host_double (value_contents (value), type);\n+\t  d = target_float_to_host_double (value_contents (value).data (),\n+\t\t\t\t\t   type);\n \t  check = value_from_host_double (type, d);\n \t}\n       else if (type->is_unsigned ())"
    },
    {
      "sha": "7a7da9d10311020bfb685d63dcec9b8c3df62a42",
      "filename": "gdb/h8300-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/h8300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/h8300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/h8300-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -648,7 +648,7 @@ h8300_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n     {\n       struct type *type = value_type (args[argument]);\n       int len = TYPE_LENGTH (type);\n-      char *contents = (char *) value_contents (args[argument]);\n+      char *contents = (char *) value_contents (args[argument]).data ();\n \n       /* Pad the argument appropriately.  */\n       int padded_len = align_up (len, wordsize);"
    },
    {
      "sha": "344022ccaa443499e1a4c7496b1c82518569494d",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -758,8 +758,8 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      param_len = 4;\n \t      struct_ptr += align_up (TYPE_LENGTH (type), 8);\n \t      if (write_pass)\n-\t\twrite_memory (struct_end - struct_ptr, value_contents (arg),\n-\t\t\t      TYPE_LENGTH (type));\n+\t\twrite_memory (struct_end - struct_ptr,\n+\t\t\t      value_contents (arg).data (), TYPE_LENGTH (type));\n \t      store_unsigned_integer (param_val, 4, byte_order,\n \t\t\t\t      struct_end - struct_ptr);\n \t    }\n@@ -769,23 +769,23 @@ hppa32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      /* Integer value store, right aligned.  \"unpack_long\"\n \t\t takes care of any sign-extension problems.  */\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n-\t      store_unsigned_integer (param_val, param_len, byte_order,\n-\t\t\t\t      unpack_long (type,\n-\t\t\t\t\t\t   value_contents (arg)));\n+\t      store_unsigned_integer\n+\t\t(param_val, param_len, byte_order,\n+\t\t unpack_long (type, value_contents (arg).data ()));\n \t    }\n \t  else if (type->code () == TYPE_CODE_FLT)\n \t    {\n \t      /* Floating point value store, right aligned.  */\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n-\t      memcpy (param_val, value_contents (arg), param_len);\n+\t      memcpy (param_val, value_contents (arg).data (), param_len);\n \t    }\n \t  else\n \t    {\n \t      param_len = align_up (TYPE_LENGTH (type), 4);\n \n \t      /* Small struct value are stored right-aligned.  */\n \t      memcpy (param_val + param_len - TYPE_LENGTH (type),\n-\t\t      value_contents (arg), TYPE_LENGTH (type));\n+\t\t      value_contents (arg).data (), TYPE_LENGTH (type));\n \n \t      /* Structures of size 5, 6 and 7 bytes are special in that\n \t\t the higher-ordered word is stored in the lower-ordered\n@@ -1041,7 +1041,7 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t     the right halves of the floating point registers;\n \t\t     the left halves are unused.\"  */\n \t\t  regcache->cooked_write_part (regnum, offset % 8, len,\n-\t\t\t\t\t       value_contents (arg));\n+\t\t\t\t\t       value_contents (arg).data ());\n \t\t}\n \t    }\n \t}\n@@ -1065,15 +1065,15 @@ hppa64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t{\n \t  ULONGEST codeptr, fptr;\n \n-\t  codeptr = unpack_long (type, value_contents (arg));\n+\t  codeptr = unpack_long (type, value_contents (arg).data ());\n \t  fptr = hppa64_convert_code_addr_to_fptr (gdbarch, codeptr);\n \t  store_unsigned_integer (fptrbuf, TYPE_LENGTH (type), byte_order,\n \t\t\t\t  fptr);\n \t  valbuf = fptrbuf;\n \t}\n       else\n \t{\n-\t  valbuf = value_contents (arg);\n+\t  valbuf = value_contents (arg).data ();\n \t}\n \n       /* Always store the argument in memory.  */\n@@ -2769,7 +2769,7 @@ hppa_frame_prev_register_helper (struct frame_info *this_frame,\n \ttrad_frame_get_prev_register (this_frame, saved_regs,\n \t\t\t\t      HPPA_PCOQ_HEAD_REGNUM);\n \n-      pc = extract_unsigned_integer (value_contents_all (pcoq_val),\n+      pc = extract_unsigned_integer (value_contents_all (pcoq_val).data (),\n \t\t\t\t     size, byte_order);\n       return frame_unwind_got_constant (this_frame, regnum, pc + 4);\n     }"
    },
    {
      "sha": "c038d8bbc2a6d7e74797a623be4b6de4e3bc64c2",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -189,7 +189,7 @@ i386_darwin_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    {\n \t      if (write_pass)\n \t\t{\n-\t\t  const gdb_byte *val = value_contents_all (args[i]);\n+\t\t  const gdb_byte *val = value_contents_all (args[i]).data ();\n \t\t  regcache->raw_write (I387_MM0_REGNUM(tdep) + num_m128, val);\n \t\t}\n \t      num_m128++;\n@@ -200,7 +200,7 @@ i386_darwin_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t\t     i386_darwin_arg_type_alignment (arg_type));\n \t      if (write_pass)\n \t\twrite_memory (sp + args_space,\n-\t\t\t      value_contents_all (args[i]),\n+\t\t\t      value_contents_all (args[i]).data (),\n \t\t\t      TYPE_LENGTH (arg_type));\n \n \t      /* The System V ABI says that:"
    },
    {
      "sha": "23dc39a900de31ff9a1ec12f746c58125734b58d",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2729,7 +2729,7 @@ i386_thiscall_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\targs_space_used = align_up (args_space_used, 16);\n \n \t      write_memory (sp + args_space_used,\n-\t\t\t    value_contents_all (args[i]), len);\n+\t\t\t    value_contents_all (args[i]).data (), len);\n \t      /* The System V ABI says that:\n \n \t      \"An argument's size is increased, if necessary, to make it a\n@@ -2773,7 +2773,8 @@ i386_thiscall_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n   /* The 'this' pointer needs to be in ECX.  */\n   if (thiscall)\n-    regcache->cooked_write (I386_ECX_REGNUM, value_contents_all (args[0]));\n+    regcache->cooked_write (I386_ECX_REGNUM,\n+\t\t\t    value_contents_all (args[0]).data ());\n \n   /* MarkK wrote: This \"+ 8\" is all over the place:\n      (i386_frame_this_id, i386_sigtramp_frame_this_id,\n@@ -3324,7 +3325,7 @@ i386_pseudo_register_read_into_value (struct gdbarch *gdbarch,\n {\n   gdb_byte raw_buf[I386_MAX_REGISTER_SIZE];\n   enum register_status status;\n-  gdb_byte *buf = value_contents_raw (result_value);\n+  gdb_byte *buf = value_contents_raw (result_value).data ();\n \n   if (i386_mmx_regnum_p (gdbarch, regnum))\n     {"
    },
    {
      "sha": "cb1aa152f317b787f181d56d6126f895ae8a4b6a",
      "filename": "gdb/i387-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i387-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/i387-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i387-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -284,7 +284,7 @@ i387_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,\n \n \t  if (value_entirely_available (regval))\n \t    {\n-\t      const gdb_byte *raw = value_contents (regval);\n+\t      const gdb_byte *raw = value_contents (regval).data ();\n \n \t      fputs_filtered (\"0x\", file);\n \t      for (i = 9; i >= 0; i--)"
    },
    {
      "sha": "b6816cb78b46db32da6b3a4b13b852ef9f038e38",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1935,7 +1935,7 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \t that frame by adding the size of output:\n \t    (sof (size of frame) - sol (size of locals)).  */\n       val = ia64_frame_prev_register (this_frame, this_cache, IA64_CFM_REGNUM);\n-      prev_cfm = extract_unsigned_integer (value_contents_all (val),\n+      prev_cfm = extract_unsigned_integer (value_contents_all (val).data (),\n \t\t\t\t\t   8, byte_order);\n       bsp = rse_address_add (cache->bsp, -(cache->sof));\n       prev_bsp =\n@@ -1985,7 +1985,7 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \t  /* Adjust the register number to account for register rotation.  */\n \t  regnum = VP16_REGNUM + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n \t}\n-      prN = extract_bit_field (value_contents_all (pr_val),\n+      prN = extract_bit_field (value_contents_all (pr_val).data (),\n \t\t\t       regnum - VP0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, prN);\n     }\n@@ -1996,7 +1996,7 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n       ULONGEST unatN;\n       unat_val = ia64_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t   IA64_UNAT_REGNUM);\n-      unatN = extract_bit_field (value_contents_all (unat_val),\n+      unatN = extract_bit_field (value_contents_all (unat_val).data (),\n \t\t\t\t regnum - IA64_NAT0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, unatN);\n     }\n@@ -2118,12 +2118,12 @@ ia64_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \t    regnum = IA64_GR32_REGNUM + (regnum - V32_REGNUM);\n \t  reg_val = ia64_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t      IA64_CFM_REGNUM);\n-\t  prev_cfm = extract_unsigned_integer (value_contents_all (reg_val),\n-\t\t\t\t\t       8, byte_order);\n+\t  prev_cfm = extract_unsigned_integer\n+\t    (value_contents_all (reg_val).data (), 8, byte_order);\n \t  reg_val = ia64_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t      IA64_BSP_REGNUM);\n-\t  prev_bsp = extract_unsigned_integer (value_contents_all (reg_val),\n-\t\t\t\t\t       8, byte_order);\n+\t  prev_bsp = extract_unsigned_integer\n+\t    (value_contents_all (reg_val).data (), 8, byte_order);\n \t  prev_bof = rse_address_add (prev_bsp, -(prev_cfm & 0x7f));\n \n \t  addr = rse_address_add (prev_bof, (regnum - IA64_GR32_REGNUM));\n@@ -2956,7 +2956,7 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n \t  /* Adjust the register number to account for register rotation.  */\n \t  regnum = VP16_REGNUM + ((regnum - VP16_REGNUM) + rrb_pr) % 48;\n \t}\n-      prN_val = extract_bit_field (value_contents_all (val),\n+      prN_val = extract_bit_field (value_contents_all (val).data (),\n \t\t\t\t   regnum - VP0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, prN_val);\n     }\n@@ -2965,7 +2965,7 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n     {\n       ULONGEST unatN_val;\n \n-      unatN_val = extract_bit_field (value_contents_all (val),\n+      unatN_val = extract_bit_field (value_contents_all (val).data (),\n \t\t\t\t     regnum - IA64_NAT0_REGNUM, 1);\n       return frame_unwind_got_constant (this_frame, regnum, unatN_val);\n     }\n@@ -2980,11 +2980,11 @@ ia64_libunwind_frame_prev_register (struct frame_info *this_frame,\n \t register will be if we pop the frame back which is why we might\n \t have been called.  We know that libunwind will pass us back the\n \t beginning of the current frame so we should just add sof to it.  */\n-      prev_bsp = extract_unsigned_integer (value_contents_all (val),\n+      prev_bsp = extract_unsigned_integer (value_contents_all (val).data (),\n \t\t\t\t\t   8, byte_order);\n       cfm_val = libunwind_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t       IA64_CFM_REGNUM);\n-      prev_cfm = extract_unsigned_integer (value_contents_all (cfm_val),\n+      prev_cfm = extract_unsigned_integer (value_contents_all (cfm_val).data (),\n \t\t\t\t\t   8, byte_order);\n       prev_bsp = rse_address_add (prev_bsp, (prev_cfm & 0x7f));\n \n@@ -3067,7 +3067,7 @@ ia64_libunwind_sigtramp_frame_prev_register (struct frame_info *this_frame,\n      method of getting previous registers.  */\n   prev_ip_val = libunwind_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t       IA64_IP_REGNUM);\n-  prev_ip = extract_unsigned_integer (value_contents_all (prev_ip_val),\n+  prev_ip = extract_unsigned_integer (value_contents_all (prev_ip_val).data (),\n \t\t\t\t      8, byte_order);\n \n   if (prev_ip == 0)\n@@ -3747,8 +3747,8 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_FUNC)\n \t{\n \t  gdb_byte val_buf[8];\n-\t  ULONGEST faddr = extract_unsigned_integer (value_contents (arg),\n-\t\t\t\t\t\t     8, byte_order);\n+\t  ULONGEST faddr = extract_unsigned_integer\n+\t    (value_contents (arg).data (), 8, byte_order);\n \t  store_unsigned_integer (val_buf, 8, byte_order,\n \t\t\t\t  find_func_descr (regcache, faddr,\n \t\t\t\t\t\t   &funcdescaddr));\n@@ -3780,7 +3780,7 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t This is why we use store_unsigned_integer.  */\n \t      store_unsigned_integer\n \t\t(val_buf, 8, byte_order,\n-\t\t extract_unsigned_integer (value_contents (arg), len,\n+\t\t extract_unsigned_integer (value_contents (arg).data (), len,\n \t\t\t\t\t   byte_order));\n \t    }\n \t  else\n@@ -3794,7 +3794,7 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t In this case, the data is Byte0-aligned.  Happy news,\n \t\t this means that we don't need to differentiate the\n \t\t handling of 8byte blocks and less-than-8bytes blocks.  */\n-\t      memcpy (val_buf, value_contents (arg) + argoffset,\n+\t      memcpy (val_buf, value_contents (arg).data () + argoffset,\n \t\t      (len > 8) ? 8 : len);\n \t    }\n \n@@ -3818,7 +3818,7 @@ ia64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  while (len > 0 && floatreg < IA64_FR16_REGNUM)\n \t    {\n \t      gdb_byte to[IA64_FP_REGISTER_SIZE];\n-\t      target_float_convert (value_contents (arg) + argoffset,\n+\t      target_float_convert (value_contents (arg).data () + argoffset,\n \t\t\t\t    float_elt_type, to,\n \t\t\t\t    ia64_ext_type (gdbarch));\n \t      regcache->cooked_write (floatreg, to);"
    },
    {
      "sha": "4416a0c08e1d12df741ee6a125bf60f75312526e",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -451,7 +451,7 @@ get_call_return_value (struct call_return_meta_info *ri)\n \t{\n \t  retval = allocate_value (ri->value_type);\n \t  read_value_memory (retval, 0, 1, ri->struct_addr,\n-\t\t\t     value_contents_raw (retval),\n+\t\t\t     value_contents_raw (retval).data (),\n \t\t\t     TYPE_LENGTH (ri->value_type));\n \t}\n     }\n@@ -460,7 +460,7 @@ get_call_return_value (struct call_return_meta_info *ri)\n       retval = allocate_value (ri->value_type);\n       gdbarch_return_value (ri->gdbarch, ri->function, ri->value_type,\n \t\t\t    get_current_regcache (),\n-\t\t\t    value_contents_raw (retval), NULL);\n+\t\t\t    value_contents_raw (retval).data (), NULL);\n       if (stack_temporaries && class_or_union_p (ri->value_type))\n \t{\n \t  /* Values of class type returned in registers are copied onto\n@@ -1083,7 +1083,7 @@ call_function_by_hand_dummy (struct value *function,\n       if (info.trivially_copy_constructible)\n \t{\n \t  int length = TYPE_LENGTH (param_type);\n-\t  write_memory (addr, value_contents (args[i]), length);\n+\t  write_memory (addr, value_contents (args[i]).data (), length);\n \t}\n       else\n \t{"
    },
    {
      "sha": "302db421a21fa210103292e975cd88f3392bb6c6",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1430,7 +1430,7 @@ get_return_value (struct value *function, struct type *value_type)\n     case RETURN_VALUE_ABI_PRESERVES_ADDRESS:\n       value = allocate_value (value_type);\n       gdbarch_return_value (gdbarch, function, value_type, stop_regs,\n-\t\t\t    value_contents_raw (value), NULL);\n+\t\t\t    value_contents_raw (value).data (), NULL);\n       break;\n     case RETURN_VALUE_STRUCT_CONVENTION:\n       value = NULL;\n@@ -2076,7 +2076,7 @@ default_print_one_register_info (struct ui_file *file,\n       || regtype->code () == TYPE_CODE_DECFLOAT)\n     {\n       struct value_print_options opts;\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       enum bfd_endian byte_order = type_byte_order (regtype);\n \n       get_user_print_options (&opts);"
    },
    {
      "sha": "edc0e8f1d73002126b3e3b9e8c379d159c0e23ac",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -8998,7 +8998,7 @@ siginfo_value_read (struct value *v)\n     target_read (current_inferior ()->top_target (),\n \t\t TARGET_OBJECT_SIGNAL_INFO,\n \t\t NULL,\n-\t\t value_contents_all_raw (v),\n+\t\t value_contents_all_raw (v).data (),\n \t\t value_offset (v),\n \t\t TYPE_LENGTH (value_type (v)));\n \n@@ -9021,7 +9021,7 @@ siginfo_value_write (struct value *v, struct value *fromval)\n   transferred = target_write (current_inferior ()->top_target (),\n \t\t\t      TARGET_OBJECT_SIGNAL_INFO,\n \t\t\t      NULL,\n-\t\t\t      value_contents_all_raw (fromval),\n+\t\t\t      value_contents_all_raw (fromval).data (),\n \t\t\t      value_offset (v),\n \t\t\t      TYPE_LENGTH (value_type (fromval)));\n "
    },
    {
      "sha": "806fa765676ee1197bb5ab00254d243f5101575b",
      "filename": "gdb/iq2000-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/iq2000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/iq2000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/iq2000-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -712,7 +712,7 @@ iq2000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n     {\n       type = value_type (args[i]);\n       typelen = TYPE_LENGTH (type);\n-      val = value_contents (args[i]);\n+      val = value_contents (args[i]).data ();\n       if (typelen <= 4)\n \t{\n \t  /* Char, short, int, float, pointer, and structs <= four bytes.  */"
    },
    {
      "sha": "9c5dda306d0b64cdec44eb6e25a3b4c5b6c935be",
      "filename": "gdb/lm32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/lm32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/lm32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/lm32-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -271,7 +271,7 @@ lm32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       /* FIXME: Handle structures.  */\n \n-      contents = (gdb_byte *) value_contents (arg);\n+      contents = (gdb_byte *) value_contents (arg).data ();\n       val = extract_unsigned_integer (contents, TYPE_LENGTH (arg_type),\n \t\t\t\t      byte_order);\n "
    },
    {
      "sha": "a3af19541e8970e12c24c1a30b593bf7559ab765",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -165,7 +165,7 @@ m2_print_unbounded_array (struct value *value,\n   struct value *val;\n \n   struct type *type = check_typedef (value_type (value));\n-  const gdb_byte *valaddr = value_contents_for_printing (value);\n+  const gdb_byte *valaddr = value_contents_for_printing (value).data ();\n \n   addr = unpack_pointer (type->field (0).type (),\n \t\t\t (TYPE_FIELD_BITPOS (type, 0) / 8) +\n@@ -305,7 +305,7 @@ m2_language::value_print_inner (struct value *val, struct ui_file *stream,\n   unsigned len;\n   struct type *elttype;\n   CORE_ADDR addr;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n   const CORE_ADDR address = value_address (val);\n \n   struct type *type = check_typedef (value_type (val));"
    },
    {
      "sha": "3374b00cb5ac49847e6bde68c5f49a16d5921598",
      "filename": "gdb/m32c-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m32c-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m32c-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32c-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2043,7 +2043,7 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   for (i = nargs - 1; i >= 0; i--)\n     {\n       struct value *arg = args[i];\n-      const gdb_byte *arg_bits = value_contents (arg);\n+      const gdb_byte *arg_bits = value_contents (arg).data ();\n       struct type *arg_type = value_type (arg);\n       ULONGEST arg_size = TYPE_LENGTH (arg_type);\n "
    },
    {
      "sha": "48cc42c868bd3852cf76f08eb1536b4628ce3273",
      "filename": "gdb/m32r-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m32r-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m32r-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -710,11 +710,11 @@ m32r_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t{\n \t  /* Value gets right-justified in the register or stack word.  */\n \t  memcpy (valbuf + (register_size (gdbarch, argreg) - len),\n-\t\t  (gdb_byte *) value_contents (args[argnum]), len);\n+\t\t  (gdb_byte *) value_contents (args[argnum]).data (), len);\n \t  val = valbuf;\n \t}\n       else\n-\tval = (gdb_byte *) value_contents (args[argnum]);\n+\tval = (gdb_byte *) value_contents (args[argnum]).data ();\n \n       while (len > 0)\n \t{"
    },
    {
      "sha": "bbf7e5d98e88c0e0e3c04b181e8460ff2d451cbc",
      "filename": "gdb/m68hc11-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m68hc11-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m68hc11-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68hc11-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1159,7 +1159,7 @@ m68hc11_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t{\n \t  ULONGEST v;\n \n-\t  v = extract_unsigned_integer (value_contents (args[0]),\n+\t  v = extract_unsigned_integer (value_contents (args[0]).data (),\n \t\t\t\t\tTYPE_LENGTH (type), byte_order);\n \t  first_stack_argnum = 1;\n \n@@ -1183,7 +1183,7 @@ m68hc11_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  sp--;\n \t  write_memory (sp, &zero, 1);\n \t}\n-      val = value_contents (args[argnum]);\n+      val = value_contents (args[argnum]).data ();\n       sp -= TYPE_LENGTH (type);\n       write_memory (sp, val, TYPE_LENGTH (type));\n     }"
    },
    {
      "sha": "75fa189b762473e7ed2bee7f42ff50206c87b2e8",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -560,7 +560,7 @@ m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       else\n \toffset = container_len - len;\n       sp -= container_len;\n-      write_memory (sp + offset, value_contents_all (args[i]), len);\n+      write_memory (sp + offset, value_contents_all (args[i]).data (), len);\n     }\n \n   /* Store struct value address.  */"
    },
    {
      "sha": "d48e1f117a74a188315aab75752bf7ebc71c0245",
      "filename": "gdb/mep-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mep-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mep-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mep-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2229,7 +2229,7 @@ push_large_arguments (CORE_ADDR sp, int argc, struct value **argv,\n \t  /* Reserve space for the copy, and then round the SP down, to\n \t     make sure it's all aligned properly.  */\n \t  sp = (sp - arg_len) & -4;\n-\t  write_memory (sp, value_contents (argv[i]), arg_len);\n+\t  write_memory (sp, value_contents (argv[i]).data (), arg_len);\n \t  copy[i] = sp;\n \t}\n     }\n@@ -2283,7 +2283,7 @@ mep_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       /* Arguments that fit in a GPR get expanded to fill the GPR.  */\n       if (TYPE_LENGTH (value_type (argv[i])) <= MEP_GPR_SIZE)\n-\tvalue = extract_unsigned_integer (value_contents (argv[i]),\n+\tvalue = extract_unsigned_integer (value_contents (argv[i]).data (),\n \t\t\t\t\t  TYPE_LENGTH (value_type (argv[i])),\n \t\t\t\t\t  byte_order);\n "
    },
    {
      "sha": "57295d6fd1a8c11f00b78911d6f844182d05ec74",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -4585,7 +4585,7 @@ mips_eabi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t    fprintf_unfiltered (gdb_stdlog, \" push\");\n \t}\n       else\n-\tval = value_contents (arg);\n+\tval = value_contents (arg).data ();\n \n       /* 32-bit ABIs always start floating point arguments in an\n \t even-numbered floating point register.  Round the FP register\n@@ -4960,7 +4960,7 @@ mips_n32n64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t    \"mips_n32n64_push_dummy_call: %d len=%d type=%d\",\n \t\t\t    argnum + 1, len, (int) typecode);\n \n-      val = value_contents (arg);\n+      val = value_contents (arg).data ();\n \n       /* A 128-bit long double value requires an even-odd pair of\n \t floating-point registers.  */\n@@ -5427,7 +5427,7 @@ mips_o32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t    \"mips_o32_push_dummy_call: %d len=%d type=%d\",\n \t\t\t    argnum + 1, len, (int) typecode);\n \n-      val = value_contents (arg);\n+      val = value_contents (arg).data ();\n \n       /* 32-bit ABIs always start floating point arguments in an\n \t even-numbered floating point register.  Round the FP register\n@@ -5949,7 +5949,7 @@ mips_o64_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t\t    \"mips_o64_push_dummy_call: %d len=%d type=%d\",\n \t\t\t    argnum + 1, len, (int) typecode);\n \n-      val = value_contents (arg);\n+      val = value_contents (arg).data ();\n \n       /* Floating point arguments passed in registers have to be\n \t treated specially.  On 32-bit architectures, doubles are\n@@ -6556,7 +6556,7 @@ print_gp_register_row (struct ui_file *file, struct frame_info *frame,\n \t  col++;\n \t  continue;\n \t}\n-      raw_buffer = value_contents_all (value);\n+      raw_buffer = value_contents_all (value).data ();\n       /* pad small registers */\n       for (byte = 0;\n \t   byte < (mips_abi_regsize (gdbarch)"
    },
    {
      "sha": "7feab0b3fecfca4179f5e1273019739094ab47b5",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1222,7 +1222,7 @@ mn10300_push_dummy_call (struct gdbarch *gdbarch,\n       else\n \t{\n \t  arg_len = TYPE_LENGTH (value_type (*args));\n-\t  val = value_contents (*args);\n+\t  val = value_contents (*args).data ();\n \t}\n \n       while (regs_used < 2 && arg_len > 0)"
    },
    {
      "sha": "c1b0c4c2e916bff093a3ff0c44b713a00e97e63f",
      "filename": "gdb/msp430-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/msp430-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/msp430-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/msp430-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -683,7 +683,7 @@ msp430_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       for (i = 0; i < nargs; i++)\n \t{\n \t  struct value *arg = args[i];\n-\t  const gdb_byte *arg_bits = value_contents_all (arg);\n+\t  const gdb_byte *arg_bits = value_contents_all (arg).data ();\n \t  struct type *arg_type = check_typedef (value_type (arg));\n \t  ULONGEST arg_size = TYPE_LENGTH (arg_type);\n \t  int offset;"
    },
    {
      "sha": "828853ed8e17260d8eac159b524182e36db54c7f",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1481,7 +1481,7 @@ nds32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       calling_use_fpr = nds32_check_calling_use_fpr (type);\n       len = TYPE_LENGTH (type);\n       align = type_align (type);\n-      val = value_contents (args[i]);\n+      val = value_contents (args[i]).data ();\n \n       /* The size of a composite type larger than 4 bytes will be rounded\n \t up to the nearest multiple of 4.  */"
    },
    {
      "sha": "be5544ec9fd2fc39e8f9090fb6bbd56ac6a34610",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1839,7 +1839,7 @@ nios2_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct type *arg_type = check_typedef (value_type (arg));\n       int len = TYPE_LENGTH (arg_type);\n \n-      val = value_contents (arg);\n+      val = value_contents (arg).data ();\n \n       /* Copy the argument to general registers or the stack in\n \t register-sized pieces.  Large arguments are split between"
    },
    {
      "sha": "437f27f0dabc5175f1601046544aa19f056f99bd",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 12,
      "deletions": 10,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -139,8 +139,8 @@ lval_func_read (struct value *v)\n   gdb_assert (n <= c->n);\n \n   for (i = offset; i < n; i++)\n-    memcpy (value_contents_raw (v) + j++ * elsize,\n-\t    value_contents (c->val) + c->indices[i] * elsize,\n+    memcpy (value_contents_raw (v).data () + j++ * elsize,\n+\t    value_contents (c->val).data () + c->indices[i] * elsize,\n \t    elsize);\n }\n \n@@ -179,8 +179,8 @@ lval_func_write (struct value *v, struct value *fromval)\n       struct value *from_elm_val = allocate_value (eltype);\n       struct value *to_elm_val = value_subscript (c->val, c->indices[i]);\n \n-      memcpy (value_contents_writeable (from_elm_val),\n-\t      value_contents (fromval) + j++ * elsize,\n+      memcpy (value_contents_writeable (from_elm_val).data (),\n+\t      value_contents (fromval).data () + j++ * elsize,\n \t      elsize);\n       value_assign (to_elm_val, from_elm_val);\n     }\n@@ -315,9 +315,9 @@ create_value (struct gdbarch *gdbarch, struct value *val, enum noside noside,\n \n \t      /* Copy src val contents into the destination value.  */\n \t      for (i = 0; i < n; i++)\n-\t\tmemcpy (value_contents_writeable (ret)\n+\t\tmemcpy (value_contents_writeable (ret).data ()\n \t\t\t+ (i * TYPE_LENGTH (elm_type)),\n-\t\t\tvalue_contents (val)\n+\t\t\tvalue_contents (val).data ()\n \t\t\t+ (indices[i] * TYPE_LENGTH (elm_type)),\n \t\t\tTYPE_LENGTH (elm_type));\n \t    }\n@@ -473,7 +473,8 @@ opencl_logical_not (struct type *expect_type, struct expression *exp,\n \t  value of its operand compares unequal to 0, and -1 (i.e. all bits\n \t  set) if the value of its operand compares equal to 0.  */\n \t  int tmp = value_logical_not (value_subscript (arg, i)) ? -1 : 0;\n-\t  memset (value_contents_writeable (ret) + i * TYPE_LENGTH (eltype),\n+\t  memset ((value_contents_writeable (ret).data ()\n+\t\t   + i * TYPE_LENGTH (eltype)),\n \t\t  tmp, TYPE_LENGTH (eltype));\n \t}\n     }\n@@ -573,7 +574,8 @@ vector_relop (struct expression *exp, struct value *val1, struct value *val2,\n \t if the specified relation is true.  */\n       int tmp = scalar_relop (value_subscript (val1, i),\n \t\t\t      value_subscript (val2, i), op) ? -1 : 0;\n-      memset (value_contents_writeable (ret) + i * TYPE_LENGTH (eltype1),\n+      memset ((value_contents_writeable (ret).data ()\n+\t       + i * TYPE_LENGTH (eltype1)),\n \t      tmp, TYPE_LENGTH (eltype1));\n      }\n \n@@ -836,8 +838,8 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \t{\n \t  tmp = value_logical_not (value_subscript (arg1, i)) ?\n \t    value_subscript (arg3, i) : value_subscript (arg2, i);\n-\t  memcpy (value_contents_writeable (ret) +\n-\t\t  i * TYPE_LENGTH (eltype2), value_contents_all (tmp),\n+\t  memcpy (value_contents_writeable (ret).data () +\n+\t\t  i * TYPE_LENGTH (eltype2), value_contents_all (tmp).data (),\n \t\t  TYPE_LENGTH (eltype2));\n \t}\n "
    },
    {
      "sha": "6b0b62d2c474677f11850a523140fec766a87877",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -655,7 +655,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      heap_offset += align_up (len, bpw);\n \t      valaddr = heap_sp + heap_offset;\n \n-\t      write_memory (valaddr, value_contents (arg), len);\n+\t      write_memory (valaddr, value_contents (arg).data (), len);\n \t    }\n \n \t  /* The ABI passes all structures by reference, so get its\n@@ -667,7 +667,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       else\n \t{\n \t  /* Everything else, we just get the value.  */\n-\t  val = value_contents (arg);\n+\t  val = value_contents (arg).data ();\n \t}\n \n       /* Stick the value in a register.  */\n@@ -767,7 +767,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  val = valbuf;\n \t}\n       else\n-\tval = value_contents (arg);\n+\tval = value_contents (arg).data ();\n \n       while (len > 0)\n \t{"
    },
    {
      "sha": "335d4b8b471126a57e802871389865fd33cf711d",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -80,7 +80,7 @@ pascal_language::value_print_inner (struct value *val,\n   struct type *char_type;\n   CORE_ADDR addr;\n   int want_space = 0;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n   switch (type->code ())\n     {\n@@ -536,7 +536,7 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n     {\n       struct obstack tmp_obstack = dont_print_statmem_obstack;\n       int fields_seen = 0;\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n       if (dont_print_statmem == 0)\n \t{"
    },
    {
      "sha": "d98af2552b43627061048793c5f97389f355eee1",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -122,7 +122,7 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  struct value *arg = args[argno];\n \t  struct type *type = check_typedef (value_type (arg));\n \t  int len = TYPE_LENGTH (type);\n-\t  const bfd_byte *val = value_contents (arg);\n+\t  const bfd_byte *val = value_contents (arg).data ();\n \n \t  if (type->code () == TYPE_CODE_FLT && len <= 8\n \t      && !tdep->soft_float)\n@@ -1633,7 +1633,7 @@ ppc64_sysv_abi_push_dummy_call (struct gdbarch *gdbarch,\n \t{\n \t  struct value *arg = args[argno];\n \t  struct type *type = check_typedef (value_type (arg));\n-\t  const bfd_byte *val = value_contents (arg);\n+\t  const bfd_byte *val = value_contents (arg).data ();\n \n \t  if (type->code () == TYPE_CODE_COMPLEX)\n \t    {"
    },
    {
      "sha": "03abd7576fc9a08c751cb80943b95ba0e68a082a",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -2447,7 +2447,7 @@ printf_c_string (struct ui_file *stream, const char *format,\n \t null terminated) to be printed without problems.  */\n       gdb_byte *tem_str = (gdb_byte *) alloca (len + 1);\n \n-      memcpy (tem_str, value_contents (value), len);\n+      memcpy (tem_str, value_contents (value).data (), len);\n       tem_str [len] = 0;\n       str = tem_str;\n     }\n@@ -2511,7 +2511,7 @@ printf_wide_c_string (struct ui_file *stream, const char *format,\n   if (VALUE_LVAL (value) == lval_internalvar\n       && c_is_string_type_p (value_type (value)))\n     {\n-      str = value_contents (value);\n+      str = value_contents (value).data ();\n       len = TYPE_LENGTH (value_type (value));\n     }\n   else\n@@ -2620,14 +2620,15 @@ printf_floating (struct ui_file *stream, const char *format,\n     {\n       param_type = float_type_from_length (param_type);\n       if (param_type != value_type (value))\n-\tvalue = value_from_contents (param_type, value_contents (value));\n+\tvalue = value_from_contents (param_type,\n+\t\t\t\t     value_contents (value).data ());\n     }\n \n   value = value_cast (fmt_type, value);\n \n   /* Convert the value to a string and print it.  */\n   std::string str\n-    = target_float_to_string (value_contents (value), fmt_type, format);\n+    = target_float_to_string (value_contents (value).data (), fmt_type, format);\n   fputs_filtered (str.c_str (), stream);\n }\n \n@@ -2788,7 +2789,7 @@ ui_printf (const char *arg, struct ui_file *stream)\n \t\t  || valtype->code () != TYPE_CODE_INT)\n \t\terror (_(\"expected wchar_t argument for %%lc\"));\n \n-\t      bytes = value_contents (val_args[i]);\n+\t      bytes = value_contents (val_args[i]).data ();\n \n \t      auto_obstack output;\n "
    },
    {
      "sha": "3938dd81419a6c581f3ed05c5797aa114eff4075",
      "filename": "gdb/python/py-inferior.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-inferior.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -689,7 +689,7 @@ infpy_thread_from_thread_handle (PyObject *self, PyObject *args, PyObject *kw)\n   else if (gdbpy_is_value_object (handle_obj))\n     {\n       struct value *val = value_object_to_value (handle_obj);\n-      bytes = value_contents_all (val);\n+      bytes = value_contents_all (val).data ();\n       bytes_len = TYPE_LENGTH (value_type (val));\n     }\n   else"
    },
    {
      "sha": "1669834b9d20acfbfc88e79599de8f8fe6255bff",
      "filename": "gdb/python/py-unwind.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-unwind.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -133,7 +133,7 @@ pyuw_value_obj_to_pointer (PyObject *pyo_value, CORE_ADDR *addr)\n       if ((value = value_object_to_value (pyo_value)) != NULL)\n \t{\n \t  *addr = unpack_pointer (value_type (value),\n-\t\t\t\t  value_contents (value));\n+\t\t\t\t  value_contents (value).data ());\n \t  rc = 1;\n \t}\n     }\n@@ -631,7 +631,8 @@ pyuw_sniffer (const struct frame_unwind *self, struct frame_info *this_frame,\n \tgdb_assert (data_size == TYPE_LENGTH (value_type (value)));\n \n \tcached_frame->reg[i].data = (gdb_byte *) xmalloc (data_size);\n-\tmemcpy (cached_frame->reg[i].data, value_contents (value), data_size);\n+\tmemcpy (cached_frame->reg[i].data,\n+\t\tvalue_contents (value).data (), data_size);\n       }\n   }\n "
    },
    {
      "sha": "c843c2c3072ceb1611253383278faaeaad537d4d",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1500,8 +1500,8 @@ valpy_nonzero (PyObject *self)\n       if (is_integral_type (type) || type->code () == TYPE_CODE_PTR)\n \tnonzero = !!value_as_long (self_value->value);\n       else if (is_floating_value (self_value->value))\n-\tnonzero = !target_float_is_zero (value_contents (self_value->value),\n-\t\t\t\t\t type);\n+\tnonzero = !target_float_is_zero\n+\t  (value_contents (self_value->value).data (), type);\n       else\n \t/* All other values are True.  */\n \tnonzero = 1;\n@@ -1754,7 +1754,7 @@ valpy_float (PyObject *self)\n       type = check_typedef (type);\n \n       if (type->code () == TYPE_CODE_FLT && is_floating_value (value))\n-\td = target_float_to_host_double (value_contents (value), type);\n+\td = target_float_to_host_double (value_contents (value).data (), type);\n       else if (type->code () == TYPE_CODE_INT)\n \t{\n \t  /* Note that valpy_long accepts TYPE_CODE_PTR and some"
    },
    {
      "sha": "8457284c12a1483bbbe797a93e44f120a90250d6",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -712,7 +712,7 @@ readable_regcache::cooked_read (int regnum, gdb_byte *buf)\n       computed = gdbarch_pseudo_register_read_value (m_descr->gdbarch,\n \t\t\t\t\t\t     this, regnum);\n       if (value_entirely_available (computed))\n-\tmemcpy (buf, value_contents_raw (computed),\n+\tmemcpy (buf, value_contents_raw (computed).data (),\n \t\tm_descr->sizeof_register[regnum]);\n       else\n \t{\n@@ -749,7 +749,7 @@ readable_regcache::cooked_read_value (int regnum)\n \t direction than in the other one, even though the value-based\n \t API is preferred.  */\n       if (cooked_read (regnum,\n-\t\t       value_contents_raw (result)) == REG_UNAVAILABLE)\n+\t\t       value_contents_raw (result).data ()) == REG_UNAVAILABLE)\n \tmark_value_bytes_unavailable (result, 0,\n \t\t\t\t      TYPE_LENGTH (value_type (result)));\n "
    },
    {
      "sha": "4b92754f4cd7730bdf41f0f275615215bc16a5bb",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1059,7 +1059,7 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n \t  && regtype->field (2).type ()->code () == TYPE_CODE_FLT))\n     {\n       struct value_print_options opts;\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       enum bfd_endian byte_order = type_byte_order (regtype);\n \n       get_user_print_options (&opts);\n@@ -2942,7 +2942,7 @@ riscv_push_dummy_call (struct gdbarch *gdbarch,\n \n       if (info->type != arg_type)\n \targ_value = value_cast (info->type, arg_value);\n-      info->contents = value_contents (arg_value);\n+      info->contents = value_contents (arg_value).data ();\n     }\n \n   /* Adjust the stack pointer and align it.  */\n@@ -3137,13 +3137,13 @@ riscv_return_value (struct gdbarch  *gdbarch,\n \t  {\n \t    struct value *arg_val = value_from_contents (arg_type, writebuf);\n \t    abi_val = value_cast (info.type, arg_val);\n-\t    writebuf = value_contents_raw (abi_val);\n+\t    writebuf = value_contents_raw (abi_val).data ();\n \t  }\n \telse\n \t  {\n \t    abi_val = allocate_value (info.type);\n \t    old_readbuf = readbuf;\n-\t    readbuf = value_contents_raw (abi_val);\n+\t    readbuf = value_contents_raw (abi_val).data ();\n \t  }\n \targ_len = TYPE_LENGTH (info.type);\n \n@@ -3241,7 +3241,7 @@ riscv_return_value (struct gdbarch  *gdbarch,\n \tif (readbuf != nullptr)\n \t  {\n \t    struct value *arg_val = value_cast (arg_type, abi_val);\n-\t    memcpy (old_readbuf, value_contents_raw (arg_val),\n+\t    memcpy (old_readbuf, value_contents_raw (arg_val).data (),\n \t\t    TYPE_LENGTH (arg_type));\n \t  }\n     }"
    },
    {
      "sha": "3b2cf9667df4f79df83671e6084954c7fce00582",
      "filename": "gdb/rl78-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rl78-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rl78-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rl78-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1345,7 +1345,7 @@ rl78_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n       sp -= container_len;\n       write_memory (rl78_make_data_address (sp),\n-\t\t    value_contents_all (args[i]), len);\n+\t\t    value_contents_all (args[i]).data (), len);\n     }\n \n   /* Store struct value address.  */"
    },
    {
      "sha": "80e19570a4dc333f9aca1e62f192384d4148e005",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -364,7 +364,8 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  gdb_assert (len <= 8);\n \n-\t  target_float_convert (value_contents (arg), type, reg_val, reg_type);\n+\t  target_float_convert (value_contents (arg).data (), type, reg_val,\n+\t\t\t\treg_type);\n \t  regcache->cooked_write (fp_regnum, reg_val);\n \t  ++f_argno;\n \t}\n@@ -378,7 +379,7 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      gdb_byte word[PPC_MAX_REGISTER_SIZE];\n \t      memset (word, 0, reg_size);\n \t      memcpy (word,\n-\t\t      ((char *) value_contents (arg)) + argbytes,\n+\t\t      ((char *) value_contents (arg).data ()) + argbytes,\n \t\t      (len - argbytes) > reg_size\n \t\t\t? reg_size : len - argbytes);\n \t      regcache->cooked_write (tdep->ppc_gp0_regnum + 3 + ii, word);\n@@ -396,7 +397,7 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  gdb_byte word[PPC_MAX_REGISTER_SIZE];\n \n \t  memset (word, 0, reg_size);\n-\t  memcpy (word, value_contents (arg), len);\n+\t  memcpy (word, value_contents (arg).data (), len);\n \t  regcache->cooked_write (tdep->ppc_gp0_regnum + 3 +ii, word);\n \t}\n       ++argno;\n@@ -457,7 +458,7 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       if (argbytes)\n \t{\n \t  write_memory (sp + 24 + (ii * 4),\n-\t\t\tvalue_contents (arg) + argbytes,\n+\t\t\tvalue_contents (arg).data () + argbytes,\n \t\t\tlen - argbytes);\n \t  ++argno;\n \t  ii += ((len - argbytes + 3) & -4) / 4;\n@@ -480,11 +481,11 @@ rs6000_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t      gdb_assert (len <= 8);\n \n \t      regcache->cooked_write (tdep->ppc_fp0_regnum + 1 + f_argno,\n-\t\t\t\t      value_contents (arg));\n+\t\t\t\t      value_contents (arg).data ());\n \t      ++f_argno;\n \t    }\n \n-\t  write_memory (sp + 24 + (ii * 4), value_contents (arg), len);\n+\t  write_memory (sp + 24 + (ii * 4), value_contents (arg).data (), len);\n \t  ii += ((len + 3) & -4) / 4;\n \t}\n     }"
    },
    {
      "sha": "21f1baf19dcf54ad83098932e6c9ad4fa398c6ab",
      "filename": "gdb/rs6000-lynx178-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rs6000-lynx178-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rs6000-lynx178-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-lynx178-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -111,7 +111,8 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \n \t  gdb_assert (len <= 8);\n \n-\t  target_float_convert (value_contents (arg), type, reg_val, reg_type);\n+\t  target_float_convert (value_contents (arg).data (), type, reg_val,\n+\t\t\t\treg_type);\n \t  regcache->cooked_write (fp_regnum, reg_val);\n \t  ++f_argno;\n \t}\n@@ -125,7 +126,7 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \t      gdb_byte word[PPC_MAX_REGISTER_SIZE];\n \t      memset (word, 0, reg_size);\n \t      memcpy (word,\n-\t\t      ((char *) value_contents (arg)) + argbytes,\n+\t\t      ((char *) value_contents (arg).data ()) + argbytes,\n \t\t      (len - argbytes) > reg_size\n \t\t\t? reg_size : len - argbytes);\n \t      regcache->cooked_write (tdep->ppc_gp0_regnum + 3 + ii, word);\n@@ -143,7 +144,7 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \t  gdb_byte word[PPC_MAX_REGISTER_SIZE];\n \n \t  memset (word, 0, reg_size);\n-\t  memcpy (word, value_contents (arg), len);\n+\t  memcpy (word, value_contents (arg).data (), len);\n \t  regcache->cooked_write (tdep->ppc_gp0_regnum + 3 +ii, word);\n \t}\n       ++argno;\n@@ -205,7 +206,7 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n       if (argbytes)\n \t{\n \t  write_memory (sp + 24 + (ii * 4),\n-\t\t\tvalue_contents (arg) + argbytes,\n+\t\t\tvalue_contents (arg).data () + argbytes,\n \t\t\tlen - argbytes);\n \t  ++argno;\n \t  ii += align_up (len - argbytes, 4) / 4;\n@@ -228,11 +229,11 @@ rs6000_lynx178_push_dummy_call (struct gdbarch *gdbarch,\n \t      gdb_assert (len <= 8);\n \n \t      regcache->cooked_write (tdep->ppc_fp0_regnum + 1 + f_argno,\n-\t\t\t\t      value_contents (arg));\n+\t\t\t\t      value_contents (arg).data ());\n \t      ++f_argno;\n \t    }\n \n-\t  write_memory (sp + 24 + (ii * 4), value_contents (arg), len);\n+\t  write_memory (sp + 24 + (ii * 4), value_contents (arg).data (), len);\n \t  ii += align_up (len, 4) / 4;\n \t}\n     }"
    },
    {
      "sha": "1da758f781665e4cb32b7cc8aad9e165b0b55623",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -415,8 +415,9 @@ rust_language::print_enum (struct value *val, struct ui_file *stream,\n   opts.deref_ref = 0;\n \n   gdb_assert (rust_enum_p (type));\n-  gdb::array_view<const gdb_byte> view (value_contents_for_printing (val),\n-\t\t\t\t\tTYPE_LENGTH (value_type (val)));\n+  gdb::array_view<const gdb_byte> view\n+    (value_contents_for_printing (val).data (),\n+     TYPE_LENGTH (value_type (val)));\n   type = resolve_dynamic_type (type, view, value_address (val));\n \n   if (rust_empty_enum_p (type))\n@@ -558,7 +559,7 @@ rust_language::value_print_inner\n \t   encoding.  */\n \tfputs_filtered (\"b\", stream);\n \tprintstr (stream, TYPE_TARGET_TYPE (type),\n-\t\t  value_contents_for_printing (val),\n+\t\t  value_contents_for_printing (val).data (),\n \t\t  high_bound - low_bound + 1, \"ASCII\", 0, &opts);\n       }\n       break;\n@@ -1316,7 +1317,7 @@ eval_op_rust_struct_anon (struct type *expect_type, struct expression *exp,\n \n       if (rust_enum_p (type))\n \t{\n-\t  gdb::array_view<const gdb_byte> view (value_contents (lhs),\n+\t  gdb::array_view<const gdb_byte> view (value_contents (lhs).data (),\n \t\t\t\t\t\tTYPE_LENGTH (type));\n \t  type = resolve_dynamic_type (type, view, value_address (lhs));\n \n@@ -1379,7 +1380,7 @@ eval_op_rust_structop (struct type *expect_type, struct expression *exp,\n   struct type *type = value_type (lhs);\n   if (type->code () == TYPE_CODE_STRUCT && rust_enum_p (type))\n     {\n-      gdb::array_view<const gdb_byte> view (value_contents (lhs),\n+      gdb::array_view<const gdb_byte> view (value_contents (lhs).data (),\n \t\t\t\t\t    TYPE_LENGTH (type));\n       type = resolve_dynamic_type (type, view, value_address (lhs));\n "
    },
    {
      "sha": "2d20aedf99417773fe90a8e24cb813990149069b",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -518,9 +518,9 @@ rx_frame_prev_register (struct frame_info *this_frame, void **this_cache,\n \n \t  psw_val = rx_frame_prev_register (this_frame, this_cache,\n \t\t\t\t\t    RX_PSW_REGNUM);\n-\t  psw = extract_unsigned_integer (value_contents_all (psw_val), 4, \n-\t\t\t\t\t  gdbarch_byte_order (\n-\t\t\t\t\t    get_frame_arch (this_frame)));\n+\t  psw = extract_unsigned_integer\n+\t    (value_contents_all (psw_val).data (), 4,\n+\t     gdbarch_byte_order (get_frame_arch (this_frame)));\n \n \t  if ((psw & 0x20000 /* U bit */) != 0)\n \t    return rx_frame_prev_register (this_frame, this_cache,\n@@ -724,7 +724,7 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       for (i = 0; i < nargs; i++)\n \t{\n \t  struct value *arg = args[i];\n-\t  const gdb_byte *arg_bits = value_contents_all (arg);\n+\t  const gdb_byte *arg_bits = value_contents_all (arg).data ();\n \t  struct type *arg_type = check_typedef (value_type (arg));\n \t  ULONGEST arg_size = TYPE_LENGTH (arg_type);\n "
    },
    {
      "sha": "0a4a574787cd0037d65b4f5a6bef9a214b1fcd68",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 12,
      "deletions": 11,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1764,7 +1764,7 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t     it occupies the leftmost bits.  */\n \t  if (write_mode)\n \t    as->regcache->cooked_write_part (S390_F0_REGNUM + as->fr, 0, length,\n-\t\t\t\t\t     value_contents (arg));\n+\t\t\t\t\t     value_contents (arg).data ());\n \t  as->fr += 2;\n \t}\n       else\n@@ -1773,7 +1773,7 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t     it occupies the rightmost bits.  */\n \t  as->argp = align_up (as->argp + length, word_size);\n \t  if (write_mode)\n-\t    write_memory (as->argp - length, value_contents (arg),\n+\t    write_memory (as->argp - length, value_contents (arg).data (),\n \t\t\t  length);\n \t}\n     }\n@@ -1788,13 +1788,13 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \n \t  if (write_mode)\n \t    as->regcache->cooked_write_part (regnum, 0, length,\n-\t\t\t\t\t     value_contents (arg));\n+\t\t\t\t\t     value_contents (arg).data ());\n \t  as->vr++;\n \t}\n       else\n \t{\n \t  if (write_mode)\n-\t    write_memory (as->argp, value_contents (arg), length);\n+\t    write_memory (as->argp, value_contents (arg).data (), length);\n \t  as->argp = align_up (as->argp + length, word_size);\n \t}\n     }\n@@ -1809,9 +1809,9 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t     memory word and sign- or zero-extend to full word size.\n \t     This also applies to a struct or union.  */\n \t  val = type->is_unsigned ()\n-\t    ? extract_unsigned_integer (value_contents (arg),\n+\t    ? extract_unsigned_integer (value_contents (arg).data (),\n \t\t\t\t\tlength, byte_order)\n-\t    : extract_signed_integer (value_contents (arg),\n+\t    : extract_signed_integer (value_contents (arg).data (),\n \t\t\t\t      length, byte_order);\n \t}\n \n@@ -1838,9 +1838,10 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t  if (write_mode)\n \t    {\n \t      as->regcache->cooked_write (S390_R0_REGNUM + as->gr,\n-\t\t\t\t\t  value_contents (arg));\n-\t      as->regcache->cooked_write (S390_R0_REGNUM + as->gr + 1,\n-\t\t\t\t\t  value_contents (arg) + word_size);\n+\t\t\t\t\t  value_contents (arg).data ());\n+\t      as->regcache->cooked_write\n+\t\t(S390_R0_REGNUM + as->gr + 1,\n+\t\t value_contents (arg).data () + word_size);\n \t    }\n \t  as->gr += 2;\n \t}\n@@ -1851,7 +1852,7 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t  as->gr = 7;\n \n \t  if (write_mode)\n-\t    write_memory (as->argp, value_contents (arg), length);\n+\t    write_memory (as->argp, value_contents (arg).data (), length);\n \t  as->argp += length;\n \t}\n     }\n@@ -1862,7 +1863,7 @@ s390_handle_arg (struct s390_arg_state *as, struct value *arg,\n \t alignment as a conservative assumption.  */\n       as->copy = align_down (as->copy - length, 8);\n       if (write_mode)\n-\twrite_memory (as->copy, value_contents (arg), length);\n+\twrite_memory (as->copy, value_contents (arg).data (), length);\n \n       if (as->gr <= 6)\n \t{"
    },
    {
      "sha": "12c9287f89c2d2c0b2160f3ae5ade5e245a45629",
      "filename": "gdb/score-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/score-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/score-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/score-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -530,7 +530,7 @@ score_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       struct value *arg = args[argnum];\n       struct type *arg_type = check_typedef (value_type (arg));\n       enum type_code typecode = arg_type->code ();\n-      const gdb_byte *val = value_contents (arg);\n+      const gdb_byte *val = value_contents (arg).data ();\n       int downward_offset = 0;\n       int arg_last_part_p = 0;\n "
    },
    {
      "sha": "04431df3408e5640dcb8b9a924a43b816d09dbcc",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -923,12 +923,12 @@ sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, int len)\n     {\n       /* value gets right-justified in the register or stack word.  */\n       if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)\n-\tmemcpy (valbuf + (4 - len), value_contents (val), len);\n+\tmemcpy (valbuf + (4 - len), value_contents (val).data (), len);\n       else\n-\tmemcpy (valbuf, value_contents (val), len);\n+\tmemcpy (valbuf, value_contents (val).data (), len);\n       return valbuf;\n     }\n-  return value_contents (val);\n+  return value_contents (val).data ();\n }\n \n /* Helper function to eval number of bytes to allocate on stack.  */"
    },
    {
      "sha": "7302929c9b7c01316a7979989fff74a3810ae558",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -642,7 +642,7 @@ sparc32_store_arguments (struct regcache *regcache, int nargs,\n \t     correct, and wasting a few bytes shouldn't be a problem.  */\n \t  sp &= ~0x7;\n \n-\t  write_memory (sp, value_contents (args[i]), len);\n+\t  write_memory (sp, value_contents (args[i]).data (), len);\n \t  args[i] = value_from_pointer (lookup_pointer_type (type), sp);\n \t  num_elements++;\n \t}\n@@ -673,7 +673,7 @@ sparc32_store_arguments (struct regcache *regcache, int nargs,\n \n   for (i = 0; i < nargs; i++)\n     {\n-      const bfd_byte *valbuf = value_contents (args[i]);\n+      const bfd_byte *valbuf = value_contents (args[i]).data ();\n       struct type *type = value_type (args[i]);\n       int len = TYPE_LENGTH (type);\n       gdb_byte buf[4];"
    },
    {
      "sha": "4a1b864621d0a2d743173ea18eb31d40d8486a0b",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1418,7 +1418,7 @@ sparc64_store_arguments (struct regcache *regcache, int nargs,\n \t\t a problem.  */\n \t      sp &= ~0xf;\n \n-\t      write_memory (sp, value_contents (args[i]), len);\n+\t      write_memory (sp, value_contents (args[i]).data (), len);\n \t      args[i] = value_from_pointer (lookup_pointer_type (type), sp);\n \t      num_elements++;\n \t    }\n@@ -1487,7 +1487,7 @@ sparc64_store_arguments (struct regcache *regcache, int nargs,\n \n   for (i = 0; i < nargs; i++)\n     {\n-      const gdb_byte *valbuf = value_contents (args[i]);\n+      const gdb_byte *valbuf = value_contents (args[i]).data ();\n       struct type *type = value_type (args[i]);\n       int len = TYPE_LENGTH (type);\n       int regnum = -1;"
    },
    {
      "sha": "66517cf18600e55c53997973a6267ec2dbd5cb1f",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1716,8 +1716,8 @@ info_frame_command_core (struct frame_info *fi, bool selected_frame_p)\n \t\tenum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n \t\tint sp_size = register_size (gdbarch, sp_regnum);\n \n-\t\tsp = extract_unsigned_integer (value_contents_all (value),\n-\t\t\t\t\t       sp_size, byte_order);\n+\t\tsp = extract_unsigned_integer\n+\t\t  (value_contents_all (value).data (), sp_size, byte_order);\n \n \t\tprintf_filtered (\" Previous frame's sp is \");\n \t\tfputs_filtered (paddress (gdbarch, sp), gdb_stdout);\n@@ -2842,7 +2842,7 @@ return_command (const char *retval_exp, int from_tty)\n \t\t  && rv_conv != RETURN_VALUE_ABI_RETURNS_ADDRESS);\n       gdbarch_return_value (cache_arch, function, return_type,\n \t\t\t    get_current_regcache (), NULL /*read*/,\n-\t\t\t    value_contents (return_value) /*write*/);\n+\t\t\t    value_contents (return_value).data () /*write*/);\n     }\n \n   /* If we are at the end of a call dummy now, pop the dummy frame"
    },
    {
      "sha": "5cf01c3e131597ba3b90d1e378f6117c0d50bd82",
      "filename": "gdb/std-regs.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/std-regs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/std-regs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/std-regs.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -44,7 +44,7 @@ value_of_builtin_frame_fp_reg (struct frame_info *frame, const void *baton)\n     {\n       struct type *data_ptr_type = builtin_type (gdbarch)->builtin_data_ptr;\n       struct value *val = allocate_value (data_ptr_type);\n-      gdb_byte *buf = value_contents_raw (val);\n+      gdb_byte *buf = value_contents_raw (val).data ();\n \n       gdbarch_address_to_pointer (gdbarch, data_ptr_type,\n \t\t\t\t  buf, get_frame_base_address (frame));\n@@ -63,7 +63,7 @@ value_of_builtin_frame_pc_reg (struct frame_info *frame, const void *baton)\n     {\n       struct type *func_ptr_type = builtin_type (gdbarch)->builtin_func_ptr;\n       struct value *val = allocate_value (func_ptr_type);\n-      gdb_byte *buf = value_contents_raw (val);\n+      gdb_byte *buf = value_contents_raw (val).data ();\n \n       gdbarch_address_to_pointer (gdbarch, func_ptr_type,\n \t\t\t\t  buf, get_frame_pc (frame));"
    },
    {
      "sha": "afa034c994286ea6ac23fbd36a754a67dc6f3fda",
      "filename": "gdb/tic6x-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tic6x-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tic6x-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -919,7 +919,7 @@ tic6x_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       int len = TYPE_LENGTH (arg_type);\n       enum type_code typecode = arg_type->code ();\n \n-      val = value_contents (arg);\n+      val = value_contents (arg).data ();\n \n       /* Copy the argument to general registers or the stack in\n \t register-sized pieces.  */"
    },
    {
      "sha": "5a00537951d0103ae44463207bd22e4eb855ef8b",
      "filename": "gdb/tilegx-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tilegx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tilegx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tilegx-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -308,7 +308,7 @@ tilegx_push_dummy_call (struct gdbarch *gdbarch,\n \tbreak;\n \n       /* Put argument into registers wordwise.\t*/\n-      val = value_contents (args[i]);\n+      val = value_contents (args[i]).data ();\n       for (j = 0; j < typelen; j += tilegx_reg_size)\n \t{\n \t  /* ISSUE: Why special handling for \"typelen = 4x + 1\"?\n@@ -327,7 +327,7 @@ tilegx_push_dummy_call (struct gdbarch *gdbarch,\n      the stack, word aligned.  */\n   for (j = nargs - 1; j >= i; j--)\n     {\n-      const gdb_byte *contents = value_contents (args[j]);\n+      const gdb_byte *contents = value_contents (args[j]).data ();\n \n       typelen = TYPE_LENGTH (value_enclosing_type (args[j]));\n       slacklen = align_up (typelen, 8) - typelen;"
    },
    {
      "sha": "042fcc7f364e27647631aab80fff3a4a4802b304",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -3820,7 +3820,7 @@ sdata_make_value (struct gdbarch *gdbarch, struct internalvar *var,\n       type = init_vector_type (builtin_type (gdbarch)->builtin_true_char,\n \t\t\t       buf->size ());\n       v = allocate_value (type);\n-      memcpy (value_contents_raw (v), buf->data (), buf->size ());\n+      memcpy (value_contents_raw (v).data (), buf->data (), buf->size ());\n       return v;\n     }\n   else"
    },
    {
      "sha": "f829f4db2dd383aa23d4299fee8e95b85ef16796",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1065,7 +1065,7 @@ v850_push_dummy_call (struct gdbarch *gdbarch,\n       else\n \t{\n \t  len = TYPE_LENGTH (value_type (*args));\n-\t  val = (gdb_byte *) value_contents (*args);\n+\t  val = (gdb_byte *) value_contents (*args).data ();\n \t}\n \n       if (gdbarch_tdep (gdbarch)->eight_byte_align"
    },
    {
      "sha": "140ef448137ec58fedb7297d59a144b90434e2f6",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 36,
      "deletions": 35,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -716,7 +716,7 @@ value_concat (struct value *arg1, struct value *arg2)\n \t      char_type = type2;\n \n \t      inchar = (char) unpack_long (type2,\n-\t\t\t\t\t   value_contents (inval2));\n+\t\t\t\t\t   value_contents (inval2).data ());\n \t      for (idx = 0; idx < count; idx++)\n \t\t{\n \t\t  ptr[idx] = inchar;\n@@ -727,10 +727,8 @@ value_concat (struct value *arg1, struct value *arg2)\n \t      char_type = TYPE_TARGET_TYPE (type2);\n \n \t      for (idx = 0; idx < count; idx++)\n-\t\t{\n-\t\t  memcpy (&ptr[idx * inval2len], value_contents (inval2),\n-\t\t\t  inval2len);\n-\t\t}\n+\t\tmemcpy (&ptr[idx * inval2len], value_contents (inval2).data (),\n+\t\t\tinval2len);\n \t    }\n \t  outval = value_string (ptr.data (), count * inval2len, char_type);\n \t}\n@@ -759,22 +757,22 @@ value_concat (struct value *arg1, struct value *arg2)\n \t{\n \t  char_type = type1;\n \n-\t  ptr[0] = (char) unpack_long (type1, value_contents (inval1));\n+\t  ptr[0] = (char) unpack_long (type1, value_contents (inval1).data ());\n \t}\n       else\n \t{\n \t  char_type = TYPE_TARGET_TYPE (type1);\n \n-\t  memcpy (ptr.data (), value_contents (inval1), inval1len);\n+\t  memcpy (ptr.data (), value_contents (inval1).data (), inval1len);\n \t}\n       if (type2->code () == TYPE_CODE_CHAR)\n \t{\n \t  ptr[inval1len] =\n-\t    (char) unpack_long (type2, value_contents (inval2));\n+\t    (char) unpack_long (type2, value_contents (inval2).data ());\n \t}\n       else\n \t{\n-\t  memcpy (&ptr[inval1len], value_contents (inval2), inval2len);\n+\t  memcpy (&ptr[inval1len], value_contents (inval2).data (), inval2len);\n \t}\n       outval = value_string (ptr.data (), inval1len + inval2len, char_type);\n     }\n@@ -855,7 +853,7 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n   if (is_floating_type (type1))\n     {\n       *eff_type_x = type1;\n-      memcpy (x, value_contents (arg1), TYPE_LENGTH (type1));\n+      memcpy (x, value_contents (arg1).data (), TYPE_LENGTH (type1));\n     }\n   else if (is_integral_type (type1))\n     {\n@@ -874,7 +872,7 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n   if (is_floating_type (type2))\n     {\n       *eff_type_y = type2;\n-      memcpy (y, value_contents (arg2), TYPE_LENGTH (type2));\n+      memcpy (y, value_contents (arg2).data (), TYPE_LENGTH (type2));\n     }\n   else if (is_integral_type (type2))\n     {\n@@ -929,11 +927,11 @@ fixed_point_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \t  type2 = type1;\n \t}\n \n-      v1.read_fixed_point (gdb::make_array_view (value_contents (arg1),\n+      v1.read_fixed_point (gdb::make_array_view (value_contents (arg1).data (),\n \t\t\t\t\t\t TYPE_LENGTH (type1)),\n \t\t\t   type_byte_order (type1), type1->is_unsigned (),\n \t\t\t   type1->fixed_point_scaling_factor ());\n-      v2.read_fixed_point (gdb::make_array_view (value_contents (arg2),\n+      v2.read_fixed_point (gdb::make_array_view (value_contents (arg2).data (),\n \t\t\t\t\t\t TYPE_LENGTH (type2)),\n \t\t\t   type_byte_order (type2), type2->is_unsigned (),\n \t\t\t   type2->fixed_point_scaling_factor ());\n@@ -944,7 +942,7 @@ fixed_point_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n       value *fp_val = allocate_value (type1);\n \n       fp.write_fixed_point\n-\t(gdb::make_array_view (value_contents_raw (fp_val),\n+\t(gdb::make_array_view (value_contents_raw (fp_val).data (),\n \t\t\t       TYPE_LENGTH (type1)),\n \t type_byte_order (type1),\n \t type1->is_unsigned (),\n@@ -1204,7 +1202,7 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \t\t\t\t  v2.data (), &eff_type_v2);\n       target_float_binop (op, v1.data (), eff_type_v1,\n \t\t\t      v2.data (), eff_type_v2,\n-\t\t\t      value_contents_raw (val), result_type);\n+\t\t\t      value_contents_raw (val).data (), result_type);\n     }\n   else if (type1->code () == TYPE_CODE_BOOL\n \t   || type2->code () == TYPE_CODE_BOOL)\n@@ -1243,7 +1241,7 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n       result_type = type1;\n \n       val = allocate_value (result_type);\n-      store_signed_integer (value_contents_raw (val),\n+      store_signed_integer (value_contents_raw (val).data (),\n \t\t\t    TYPE_LENGTH (result_type),\n \t\t\t    type_byte_order (result_type),\n \t\t\t    v);\n@@ -1383,7 +1381,7 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \t    }\n \n \t  val = allocate_value (result_type);\n-\t  store_unsigned_integer (value_contents_raw (val),\n+\t  store_unsigned_integer (value_contents_raw (val).data (),\n \t\t\t\t  TYPE_LENGTH (value_type (val)),\n \t\t\t\t  type_byte_order (result_type),\n \t\t\t\t  v);\n@@ -1512,7 +1510,7 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n \t    }\n \n \t  val = allocate_value (result_type);\n-\t  store_signed_integer (value_contents_raw (val),\n+\t  store_signed_integer (value_contents_raw (val).data (),\n \t\t\t\tTYPE_LENGTH (value_type (val)),\n \t\t\t\ttype_byte_order (result_type),\n \t\t\t\tv);\n@@ -1559,8 +1557,8 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n   val = allocate_value (vector_type);\n   for (i = 0; i < high_bound - low_bound + 1; i++)\n     /* Duplicate the contents of elval into the destination vector.  */\n-    memcpy (value_contents_writeable (val) + (i * TYPE_LENGTH (eltype)),\n-\t    value_contents_all (elval), TYPE_LENGTH (eltype));\n+    memcpy (value_contents_writeable (val).data () + (i * TYPE_LENGTH (eltype)),\n+\t    value_contents_all (elval).data (), TYPE_LENGTH (eltype));\n \n   return val;\n }\n@@ -1607,8 +1605,8 @@ vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n     {\n       tmp = value_binop (value_subscript (val1, i),\n \t\t\t value_subscript (val2, i), op);\n-      memcpy (value_contents_writeable (val) + i * elsize,\n-\t      value_contents_all (tmp),\n+      memcpy (value_contents_writeable (val).data () + i * elsize,\n+\t      value_contents_all (tmp).data (),\n \t      elsize);\n      }\n   value_free_to_mark (mark);\n@@ -1666,10 +1664,10 @@ value_logical_not (struct value *arg1)\n   type1 = check_typedef (value_type (arg1));\n \n   if (is_floating_value (arg1))\n-    return target_float_is_zero (value_contents (arg1), type1);\n+    return target_float_is_zero (value_contents (arg1).data (), type1);\n \n   len = TYPE_LENGTH (type1);\n-  p = value_contents (arg1);\n+  p = value_contents (arg1).data ();\n \n   while (--len >= 0)\n     {\n@@ -1688,8 +1686,8 @@ value_strcmp (struct value *arg1, struct value *arg2)\n {\n   int len1 = TYPE_LENGTH (value_type (arg1));\n   int len2 = TYPE_LENGTH (value_type (arg2));\n-  const gdb_byte *s1 = value_contents (arg1);\n-  const gdb_byte *s2 = value_contents (arg2);\n+  const gdb_byte *s1 = value_contents (arg1).data ();\n+  const gdb_byte *s2 = value_contents (arg2).data ();\n   int i, len = len1 < len2 ? len1 : len2;\n \n   for (i = 0; i < len; i++)\n@@ -1764,8 +1762,8 @@ value_equal (struct value *arg1, struct value *arg2)\n \t   && ((len = (int) TYPE_LENGTH (type1))\n \t       == (int) TYPE_LENGTH (type2)))\n     {\n-      p1 = value_contents (arg1);\n-      p2 = value_contents (arg2);\n+      p1 = value_contents (arg1).data ();\n+      p2 = value_contents (arg2).data ();\n       while (--len >= 0)\n \t{\n \t  if (*p1++ != *p2++)\n@@ -1795,7 +1793,8 @@ value_equal_contents (struct value *arg1, struct value *arg2)\n \n   return (type1->code () == type2->code ()\n \t  && TYPE_LENGTH (type1) == TYPE_LENGTH (type2)\n-\t  && memcmp (value_contents (arg1), value_contents (arg2),\n+\t  && memcmp (value_contents (arg1).data (),\n+\t\t     value_contents (arg2).data (),\n \t\t     TYPE_LENGTH (type1)) == 0);\n }\n \n@@ -1870,7 +1869,7 @@ value_pos (struct value *arg1)\n   if (is_integral_type (type) || is_floating_value (arg1)\n       || (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n       || type->code () == TYPE_CODE_COMPLEX)\n-    return value_from_contents (type, value_contents (arg1));\n+    return value_from_contents (type, value_contents (arg1).data ());\n   else\n     error (_(\"Argument to positive operation not a number.\"));\n }\n@@ -1900,8 +1899,9 @@ value_neg (struct value *arg1)\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n \t  tmp = value_neg (value_subscript (arg1, i));\n-\t  memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),\n-\t\t  value_contents_all (tmp), TYPE_LENGTH (eltype));\n+\t  memcpy ((value_contents_writeable (val).data ()\n+\t\t   + i * TYPE_LENGTH (eltype)),\n+\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n \t}\n       return val;\n     }\n@@ -1943,8 +1943,9 @@ value_complement (struct value *arg1)\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n \t  tmp = value_complement (value_subscript (arg1, i));\n-\t  memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),\n-\t\t  value_contents_all (tmp), TYPE_LENGTH (eltype));\n+\t  memcpy ((value_contents_writeable (val).data ()\n+\t\t   + i * TYPE_LENGTH (eltype)),\n+\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n \t}\n     }\n   else if (type->code () == TYPE_CODE_COMPLEX)\n@@ -2005,7 +2006,7 @@ value_in (struct value *element, struct value *set)\n       && eltype->code () != TYPE_CODE_ENUM\n       && eltype->code () != TYPE_CODE_BOOL)\n     error (_(\"First argument of 'IN' has wrong type\"));\n-  member = value_bit_index (settype, value_contents (set),\n+  member = value_bit_index (settype, value_contents (set).data (),\n \t\t\t    value_as_long (element));\n   if (member < 0)\n     error (_(\"First argument of 'IN' not in range\"));"
    },
    {
      "sha": "4847f937cd070cd1a25a105d6c3d24896afdb55e",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 41,
      "deletions": 38,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -341,7 +341,7 @@ value_to_gdb_mpq (struct value *value)\n   gdb_mpq result;\n   if (is_floating_type (type))\n     {\n-      double d = target_float_to_host_double (value_contents (value),\n+      double d = target_float_to_host_double (value_contents (value).data (),\n \t\t\t\t\t      type);\n       mpq_set_d (result.val, d);\n     }\n@@ -351,7 +351,7 @@ value_to_gdb_mpq (struct value *value)\n \t\t  || is_fixed_point_type (type));\n \n       gdb_mpz vz;\n-      vz.read (gdb::make_array_view (value_contents (value),\n+      vz.read (gdb::make_array_view (value_contents (value).data (),\n \t\t\t\t     TYPE_LENGTH (type)),\n \t       type_byte_order (type), type->is_unsigned ());\n       mpq_set_z (result.val, vz.val);\n@@ -392,7 +392,7 @@ value_cast_to_fixed_point (struct type *to_type, struct value *from_val)\n   /* Finally, create the result value, and pack the unscaled value\n      in it.  */\n   struct value *result = allocate_value (to_type);\n-  unscaled.write (gdb::make_array_view (value_contents_raw (result),\n+  unscaled.write (gdb::make_array_view (value_contents_raw (result).data (),\n \t\t\t\t\tTYPE_LENGTH (to_type)),\n \t\t  type_byte_order (to_type),\n \t\t  to_type->is_unsigned ());\n@@ -546,21 +546,22 @@ value_cast (struct type *type, struct value *arg2)\n       if (is_floating_value (arg2))\n \t{\n \t  struct value *v = allocate_value (to_type);\n-\t  target_float_convert (value_contents (arg2), type2,\n-\t\t\t\tvalue_contents_raw (v), type);\n+\t  target_float_convert (value_contents (arg2).data (), type2,\n+\t\t\t\tvalue_contents_raw (v).data (), type);\n \t  return v;\n \t}\n       else if (is_fixed_point_type (type2))\n \t{\n \t  gdb_mpq fp_val;\n \n \t  fp_val.read_fixed_point\n-\t    (gdb::make_array_view (value_contents (arg2), TYPE_LENGTH (type2)),\n+\t    (gdb::make_array_view (value_contents (arg2).data (),\n+\t\t\t\t   TYPE_LENGTH (type2)),\n \t     type_byte_order (type2), type2->is_unsigned (),\n \t     type2->fixed_point_scaling_factor ());\n \n \t  struct value *v = allocate_value (to_type);\n-\t  target_float_from_host_double (value_contents_raw (v),\n+\t  target_float_from_host_double (value_contents_raw (v).data (),\n \t\t\t\t\t to_type, mpq_get_d (fp_val.val));\n \t  return v;\n \t}\n@@ -586,7 +587,7 @@ value_cast (struct type *type, struct value *arg2)\n \t bits.  */\n       if (code2 == TYPE_CODE_PTR)\n \tlongest = extract_unsigned_integer\n-\t\t    (value_contents (arg2), TYPE_LENGTH (type2),\n+\t\t    (value_contents (arg2).data (), TYPE_LENGTH (type2),\n \t\t     type_byte_order (type2));\n       else\n \tlongest = value_as_long (arg2);\n@@ -623,7 +624,8 @@ value_cast (struct type *type, struct value *arg2)\n     {\n       struct value *result = allocate_value (to_type);\n \n-      cplus_make_method_ptr (to_type, value_contents_writeable (result), 0, 0);\n+      cplus_make_method_ptr (to_type,\n+\t\t\t     value_contents_writeable (result).data (), 0, 0);\n       return result;\n     }\n   else if (code1 == TYPE_CODE_MEMBERPTR && code2 == TYPE_CODE_INT\n@@ -904,7 +906,7 @@ value_dynamic_cast (struct type *type, struct value *arg)\n \treturn tem;\n       result = NULL;\n       if (dynamic_cast_check_1 (TYPE_TARGET_TYPE (resolved_type),\n-\t\t\t\tvalue_contents_for_printing (tem),\n+\t\t\t\tvalue_contents_for_printing (tem).data (),\n \t\t\t\tvalue_embedded_offset (tem),\n \t\t\t\tvalue_address (tem), tem,\n \t\t\t\trtti_type, addr,\n@@ -920,7 +922,7 @@ value_dynamic_cast (struct type *type, struct value *arg)\n   result = NULL;\n   if (is_public_ancestor (arg_type, rtti_type)\n       && dynamic_cast_check_2 (TYPE_TARGET_TYPE (resolved_type),\n-\t\t\t       value_contents_for_printing (tem),\n+\t\t\t       value_contents_for_printing (tem).data (),\n \t\t\t       value_embedded_offset (tem),\n \t\t\t       value_address (tem), tem,\n \t\t\t       rtti_type, &result) == 1)\n@@ -961,8 +963,9 @@ value_one (struct type *type)\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n \t  tmp = value_one (eltype);\n-\t  memcpy (value_contents_writeable (val) + i * TYPE_LENGTH (eltype),\n-\t\t  value_contents_all (tmp), TYPE_LENGTH (eltype));\n+\t  memcpy ((value_contents_writeable (val).data ()\n+\t\t   + i * TYPE_LENGTH (eltype)),\n+\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n \t}\n     }\n   else\n@@ -1173,7 +1176,7 @@ value_assign (struct value *toval, struct value *fromval)\n \t  {\n \t    changed_addr = value_address (toval);\n \t    changed_len = type_length_units (type);\n-\t    dest_buffer = value_contents (fromval);\n+\t    dest_buffer = value_contents (fromval).data ();\n \t  }\n \n \twrite_memory_with_notification (changed_addr, dest_buffer, changed_len);\n@@ -1249,12 +1252,12 @@ value_assign (struct value *toval, struct value *fromval)\n \t\t   format.  */\n \t\tgdbarch_value_to_register (gdbarch, frame,\n \t\t\t\t\t   VALUE_REGNUM (toval), type,\n-\t\t\t\t\t   value_contents (fromval));\n+\t\t\t\t\t   value_contents (fromval).data ());\n \t      }\n \t    else\n \t      {\n \t\tgdb::array_view<const gdb_byte> contents\n-\t\t  = gdb::make_array_view (value_contents (fromval),\n+\t\t  = gdb::make_array_view (value_contents (fromval).data (),\n \t\t\t\t\t  TYPE_LENGTH (type));\n \t\tput_frame_register_bytes (frame, value_reg,\n \t\t\t\t\t  value_offset (toval),\n@@ -1339,7 +1342,7 @@ value_assign (struct value *toval, struct value *fromval)\n      implies the returned value is not lazy, even if TOVAL was.  */\n   val = value_copy (toval);\n   set_value_lazy (val, 0);\n-  memcpy (value_contents_raw (val), value_contents (fromval),\n+  memcpy (value_contents_raw (val).data (), value_contents (fromval).data (),\n \t  TYPE_LENGTH (type));\n \n   /* We copy over the enclosing type and pointed-to offset from FROMVAL\n@@ -1373,7 +1376,7 @@ value_repeat (struct value *arg1, int count)\n   set_value_address (val, value_address (arg1));\n \n   read_value_memory (val, 0, value_stack (val), value_address (val),\n-\t\t     value_contents_all_raw (val),\n+\t\t     value_contents_all_raw (val).data (),\n \t\t     type_length_units (value_enclosing_type (val)));\n \n   return val;\n@@ -1481,7 +1484,7 @@ value_coerce_to_target (struct value *val)\n \n   length = TYPE_LENGTH (check_typedef (value_type (val)));\n   addr = allocate_space_in_inferior (length);\n-  write_memory (addr, value_contents (val), length);\n+  write_memory (addr, value_contents (val).data (), length);\n   return value_at_lazy (value_type (val), addr);\n }\n \n@@ -1747,7 +1750,7 @@ value_cstring (const char *ptr, ssize_t len, struct type *char_type)\n     = lookup_array_range_type (char_type, lowbound, highbound + lowbound - 1);\n \n   val = allocate_value (stringtype);\n-  memcpy (value_contents_raw (val), ptr, len);\n+  memcpy (value_contents_raw (val).data (), ptr, len);\n   return val;\n }\n \n@@ -1770,7 +1773,7 @@ value_string (const char *ptr, ssize_t len, struct type *char_type)\n     = lookup_string_range_type (char_type, lowbound, highbound + lowbound - 1);\n \n   val = allocate_value (stringtype);\n-  memcpy (value_contents_raw (val), ptr, len);\n+  memcpy (value_contents_raw (val).data (), ptr, len);\n   return val;\n }\n \n@@ -2054,7 +2057,7 @@ struct_field_searcher::search (struct value *arg1, LONGEST offset,\n \t  struct value *v2;\n \n \t  boffset = baseclass_offset (type, i,\n-\t\t\t\t      value_contents_for_printing (arg1),\n+\t\t\t\t      value_contents_for_printing (arg1).data (),\n \t\t\t\t      value_embedded_offset (arg1) + offset,\n \t\t\t\t      value_address (arg1),\n \t\t\t\t      arg1);\n@@ -2072,7 +2075,7 @@ struct_field_searcher::search (struct value *arg1, LONGEST offset,\n \t      base_addr = value_address (arg1) + boffset;\n \t      v2 = value_at_lazy (basetype, base_addr);\n \t      if (target_read_memory (base_addr, \n-\t\t\t\t      value_contents_raw (v2),\n+\t\t\t\t      value_contents_raw (v2).data (),\n \t\t\t\t      TYPE_LENGTH (value_type (v2))) != 0)\n \t\terror (_(\"virtual baseclass botch\"));\n \t    }\n@@ -2258,13 +2261,13 @@ search_struct_method (const char *name, struct value **arg1p,\n \t      base_val = value_from_contents_and_address (baseclass,\n \t\t\t\t\t\t\t  tmp.data (),\n \t\t\t\t\t\t\t  address + offset);\n-\t      base_valaddr = value_contents_for_printing (base_val);\n+\t      base_valaddr = value_contents_for_printing (base_val).data ();\n \t      this_offset = 0;\n \t    }\n \t  else\n \t    {\n \t      base_val = *arg1p;\n-\t      base_valaddr = value_contents_for_printing (*arg1p);\n+\t      base_valaddr = value_contents_for_printing (*arg1p).data ();\n \t      this_offset = offset;\n \t    }\n \n@@ -2520,7 +2523,7 @@ find_method_list (struct value **argp, const char *method,\n       if (BASETYPE_VIA_VIRTUAL (type, i))\n \t{\n \t  base_offset = baseclass_offset (type, i,\n-\t\t\t\t\t  value_contents_for_printing (*argp),\n+\t\t\t\t\t  value_contents_for_printing (*argp).data (),\n \t\t\t\t\t  value_offset (*argp) + offset,\n \t\t\t\t\t  value_address (*argp), *argp);\n \t}\n@@ -3448,7 +3451,7 @@ get_baseclass_offset (struct type *vt, struct type *cls,\n \t{\n \t  if (BASETYPE_VIA_VIRTUAL (vt, i))\n \t    {\n-\t      const gdb_byte *adr = value_contents_for_printing (v);\n+\t      const gdb_byte *adr = value_contents_for_printing (v).data ();\n \t      *boffs = baseclass_offset (vt, i, adr, value_offset (v),\n \t\t\t\t\t value_as_long (v), v);\n \t      *isvirt = true;\n@@ -3462,7 +3465,7 @@ get_baseclass_offset (struct type *vt, struct type *cls,\n \t{\n \t  if (*isvirt == false)\t/* Add non-virtual base offset.  */\n \t    {\n-\t      const gdb_byte *adr = value_contents_for_printing (v);\n+\t      const gdb_byte *adr = value_contents_for_printing (v).data ();\n \t      *boffs += baseclass_offset (vt, i, adr, value_offset (v),\n \t\t\t\t\t  value_as_long (v), v);\n \t    }\n@@ -3659,7 +3662,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n \t\t  result = allocate_value\n \t\t    (lookup_methodptr_type (TYPE_FN_FIELD_TYPE (f, j)));\n \t\t  cplus_make_method_ptr (value_type (result),\n-\t\t\t\t\t value_contents_writeable (result),\n+\t\t\t\t\t value_contents_writeable (result).data (),\n \t\t\t\t\t TYPE_FN_FIELD_VOFFSET (f, j), 1);\n \t\t}\n \t      else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n@@ -3684,7 +3687,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n \t\t{\n \t\t  result = allocate_value (lookup_methodptr_type (TYPE_FN_FIELD_TYPE (f, j)));\n \t\t  cplus_make_method_ptr (value_type (result),\n-\t\t\t\t\t value_contents_writeable (result),\n+\t\t\t\t\t value_contents_writeable (result).data (),\n \t\t\t\t\t value_address (v), 0);\n \t\t}\n \t    }\n@@ -4027,10 +4030,10 @@ value_literal_complex (struct value *arg1,\n   arg1 = value_cast (real_type, arg1);\n   arg2 = value_cast (real_type, arg2);\n \n-  memcpy (value_contents_raw (val),\n-\t  value_contents (arg1), TYPE_LENGTH (real_type));\n-  memcpy (value_contents_raw (val) + TYPE_LENGTH (real_type),\n-\t  value_contents (arg2), TYPE_LENGTH (real_type));\n+  memcpy (value_contents_raw (val).data (),\n+\t  value_contents (arg1).data (), TYPE_LENGTH (real_type));\n+  memcpy (value_contents_raw (val).data () + TYPE_LENGTH (real_type),\n+\t  value_contents (arg2).data (), TYPE_LENGTH (real_type));\n   return val;\n }\n \n@@ -4072,10 +4075,10 @@ cast_into_complex (struct type *type, struct value *val)\n       struct value *re_val = allocate_value (val_real_type);\n       struct value *im_val = allocate_value (val_real_type);\n \n-      memcpy (value_contents_raw (re_val),\n-\t      value_contents (val), TYPE_LENGTH (val_real_type));\n-      memcpy (value_contents_raw (im_val),\n-\t      value_contents (val) + TYPE_LENGTH (val_real_type),\n+      memcpy (value_contents_raw (re_val).data (),\n+\t      value_contents (val).data (), TYPE_LENGTH (val_real_type));\n+      memcpy (value_contents_raw (im_val).data (),\n+\t      value_contents (val).data () + TYPE_LENGTH (val_real_type),\n \t      TYPE_LENGTH (val_real_type));\n \n       return value_literal_complex (re_val, im_val, type);"
    },
    {
      "sha": "6eb3db2ed44d0a724caada4a19cedbab2362e6b0",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -484,7 +484,7 @@ generic_value_print_ptr (struct value *val, struct ui_file *stream,\n     {\n       struct type *type = check_typedef (value_type (val));\n       struct type *elttype = check_typedef (TYPE_TARGET_TYPE (type));\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       CORE_ADDR addr = unpack_pointer (type, valaddr);\n \n       print_unpacked_pointer (type, elttype, addr, stream, options);\n@@ -520,7 +520,7 @@ get_value_addr_contents (struct value *deref_val)\n   gdb_assert (deref_val != NULL);\n \n   if (value_lval_const (deref_val) == lval_memory)\n-    return value_contents_for_printing_const (value_addr (deref_val));\n+    return value_contents_for_printing_const (value_addr (deref_val)).data ();\n   else\n     {\n       /* We have a non-addressable value, such as a DW_AT_const_value.  */\n@@ -545,7 +545,7 @@ generic_val_print_ref (struct type *type,\n   const int must_coerce_ref = ((options->addressprint && value_is_synthetic)\n \t\t\t       || options->deref_ref);\n   const int type_is_defined = elttype->code () != TYPE_CODE_UNDEF;\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n+  const gdb_byte *valaddr = value_contents_for_printing (original_value).data ();\n \n   if (must_coerce_ref && type_is_defined)\n     {\n@@ -693,7 +693,7 @@ generic_val_print_enum (struct type *type,\n \n   gdb_assert (!options->format);\n \n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n+  const gdb_byte *valaddr = value_contents_for_printing (original_value).data ();\n \n   val = unpack_long (type, valaddr + embedded_offset * unit_size);\n \n@@ -740,7 +740,7 @@ generic_value_print_bool\n     }\n   else\n     {\n-      const gdb_byte *valaddr = value_contents_for_printing (value);\n+      const gdb_byte *valaddr = value_contents_for_printing (value).data ();\n       struct type *type = check_typedef (value_type (value));\n       LONGEST val = unpack_long (type, valaddr);\n       if (val == 0)\n@@ -783,7 +783,7 @@ generic_value_print_char (struct value *value, struct ui_file *stream,\n     {\n       struct type *unresolved_type = value_type (value);\n       struct type *type = check_typedef (unresolved_type);\n-      const gdb_byte *valaddr = value_contents_for_printing (value);\n+      const gdb_byte *valaddr = value_contents_for_printing (value).data ();\n \n       LONGEST val = unpack_long (type, valaddr);\n       if (type->is_unsigned ())\n@@ -804,7 +804,7 @@ generic_val_print_float (struct type *type, struct ui_file *stream,\n {\n   gdb_assert (!options->format);\n \n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n+  const gdb_byte *valaddr = value_contents_for_printing (original_value).data ();\n \n   print_floating (valaddr, type, stream);\n }\n@@ -821,7 +821,7 @@ generic_val_print_fixed_point (struct value *val, struct ui_file *stream,\n     {\n       struct type *type = value_type (val);\n \n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       gdb_mpf f;\n \n       f.read_fixed_point (gdb::make_array_view (valaddr, TYPE_LENGTH (type)),\n@@ -867,7 +867,7 @@ generic_value_print_memberptr\n       /* Member pointers are essentially specific to C++, and so if we\n \t encounter one, we should print it according to C++ rules.  */\n       struct type *type = check_typedef (value_type (val));\n-      const gdb_byte *valaddr = value_contents_for_printing (val);\n+      const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n       cp_print_class_member (valaddr, type, stream, \"&\");\n     }\n   else\n@@ -977,7 +977,7 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n       break;\n \n     case TYPE_CODE_METHODPTR:\n-      cplus_print_method_ptr (value_contents_for_printing (val), type,\n+      cplus_print_method_ptr (value_contents_for_printing (val).data (), type,\n \t\t\t      stream);\n       break;\n \n@@ -1193,7 +1193,7 @@ static void\n val_print_type_code_flags (struct type *type, struct value *original_value,\n \t\t\t   int embedded_offset, struct ui_file *stream)\n {\n-  const gdb_byte *valaddr = (value_contents_for_printing (original_value)\n+  const gdb_byte *valaddr = (value_contents_for_printing (original_value).data ()\n \t\t\t     + embedded_offset);\n   ULONGEST val = unpack_long (type, valaddr);\n   int field, nfields = type->num_fields ();\n@@ -1267,7 +1267,7 @@ value_print_scalar_formatted (struct value *val,\n   /* value_contents_for_printing fetches all VAL's contents.  They are\n      needed to check whether VAL is optimized-out or unavailable\n      below.  */\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  const gdb_byte *valaddr = value_contents_for_printing (val).data ();\n \n   /* A scalar object that does not have all bits available can't be\n      printed, because all bits contribute to its representation.  */\n@@ -3155,7 +3155,7 @@ test_print_flags (gdbarch *arch)\n   append_flags_type_field (flags_type, 5, 3, field_type, \"C\");\n \n   value *val = allocate_value (flags_type);\n-  gdb_byte *contents = value_contents_writeable (val);\n+  gdb_byte *contents = value_contents_writeable (val).data ();\n   store_unsigned_integer (contents, 4, gdbarch_byte_order (arch), 0xaa);\n \n   string_file out;"
    },
    {
      "sha": "42ce80416f143d2b229e14fe9dfd320aa438c4d8",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 45,
      "deletions": 35,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1146,21 +1146,25 @@ set_value_parent (struct value *value, struct value *parent)\n   value->parent = value_ref_ptr::new_reference (parent);\n }\n \n-gdb_byte *\n+gdb::array_view<gdb_byte>\n value_contents_raw (struct value *value)\n {\n   struct gdbarch *arch = get_value_arch (value);\n   int unit_size = gdbarch_addressable_memory_unit_size (arch);\n \n   allocate_value_contents (value);\n-  return value->contents.get () + value->embedded_offset * unit_size;\n+\n+  ULONGEST length = TYPE_LENGTH (value_type (value));\n+  return {value->contents.get () + value->embedded_offset * unit_size, length};\n }\n \n-gdb_byte *\n+gdb::array_view<gdb_byte>\n value_contents_all_raw (struct value *value)\n {\n   allocate_value_contents (value);\n-  return value->contents.get ();\n+\n+  ULONGEST length = TYPE_LENGTH (value_type (value));\n+  return {value->contents.get (), length};\n }\n \n struct type *\n@@ -1238,25 +1242,29 @@ require_available (const struct value *value)\n     throw_error (NOT_AVAILABLE_ERROR, _(\"value is not available\"));\n }\n \n-const gdb_byte *\n+gdb::array_view<const gdb_byte>\n value_contents_for_printing (struct value *value)\n {\n   if (value->lazy)\n     value_fetch_lazy (value);\n-  return value->contents.get ();\n+\n+  ULONGEST length = TYPE_LENGTH (value_type (value));\n+  return {value->contents.get (), length};\n }\n \n-const gdb_byte *\n+gdb::array_view<const gdb_byte>\n value_contents_for_printing_const (const struct value *value)\n {\n   gdb_assert (!value->lazy);\n-  return value->contents.get ();\n+\n+  ULONGEST length = TYPE_LENGTH (value_type (value));\n+  return {value->contents.get (), length};\n }\n \n-const gdb_byte *\n+gdb::array_view<const gdb_byte>\n value_contents_all (struct value *value)\n {\n-  const gdb_byte *result = value_contents_for_printing (value);\n+  gdb::array_view<const gdb_byte> result = value_contents_for_printing (value);\n   require_not_optimized_out (value);\n   require_available (value);\n   return result;\n@@ -1334,8 +1342,8 @@ value_contents_copy_raw (struct value *dst, LONGEST dst_offset,\n \t\t\t\t\t     TARGET_CHAR_BIT * length));\n \n   /* Copy the data.  */\n-  memcpy (value_contents_all_raw (dst) + dst_offset * unit_size,\n-\t  value_contents_all_raw (src) + src_offset * unit_size,\n+  memcpy (value_contents_all_raw (dst).data () + dst_offset * unit_size,\n+\t  value_contents_all_raw (src).data () + src_offset * unit_size,\n \t  length * unit_size);\n \n   /* Copy the meta-data, adjusted.  */\n@@ -1392,16 +1400,16 @@ set_value_stack (struct value *value, int val)\n   value->stack = val;\n }\n \n-const gdb_byte *\n+gdb::array_view<const gdb_byte>\n value_contents (struct value *value)\n {\n-  const gdb_byte *result = value_contents_writeable (value);\n+  gdb::array_view<const gdb_byte> result = value_contents_writeable (value);\n   require_not_optimized_out (value);\n   require_available (value);\n   return result;\n }\n \n-gdb_byte *\n+gdb::array_view<gdb_byte>\n value_contents_writeable (struct value *value)\n {\n   if (value->lazy)\n@@ -1713,7 +1721,8 @@ value_copy (struct value *arg)\n   val->initialized = arg->initialized;\n   if (!value_lazy (val))\n     {\n-      memcpy (value_contents_all_raw (val), value_contents_all_raw (arg),\n+      memcpy (value_contents_all_raw (val).data (),\n+\t      value_contents_all_raw (arg).data (),\n \t      TYPE_LENGTH (value_enclosing_type (arg)));\n \n     }\n@@ -1761,7 +1770,8 @@ value_non_lval (struct value *arg)\n       struct type *enc_type = value_enclosing_type (arg);\n       struct value *val = allocate_value (enc_type);\n \n-      memcpy (value_contents_all_raw (val), value_contents_all (arg),\n+      memcpy (value_contents_all_raw (val).data (),\n+\t      value_contents_all (arg).data (),\n \t      TYPE_LENGTH (enc_type));\n       val->type = arg->type;\n       set_value_embedded_offset (val, value_embedded_offset (arg));\n@@ -1778,7 +1788,7 @@ value_force_lval (struct value *v, CORE_ADDR addr)\n {\n   gdb_assert (VALUE_LVAL (v) == not_lval);\n \n-  write_memory (addr, value_contents_raw (v), TYPE_LENGTH (value_type (v)));\n+  write_memory (addr, value_contents_raw (v).data (), TYPE_LENGTH (value_type (v)));\n   v->lval = lval_memory;\n   v->location.address = addr;\n }\n@@ -2303,15 +2313,15 @@ set_internalvar_component (struct internalvar *var,\n   switch (var->kind)\n     {\n     case INTERNALVAR_VALUE:\n-      addr = value_contents_writeable (var->u.value);\n+      addr = value_contents_writeable (var->u.value).data ();\n       arch = get_value_arch (var->u.value);\n       unit_size = gdbarch_addressable_memory_unit_size (arch);\n \n       if (bitsize)\n \tmodify_field (value_type (var->u.value), addr + offset,\n \t\t      value_as_long (newval), bitpos, bitsize);\n       else\n-\tmemcpy (addr + offset * unit_size, value_contents (newval),\n+\tmemcpy (addr + offset * unit_size, value_contents (newval).data (),\n \t\tTYPE_LENGTH (value_type (newval)));\n       break;\n \n@@ -2695,7 +2705,7 @@ value_as_long (struct value *val)\n      in disassemble_command).  It also dereferences references, which\n      I suspect is the most logical thing to do.  */\n   val = coerce_array (val);\n-  return unpack_long (value_type (val), value_contents (val));\n+  return unpack_long (value_type (val), value_contents (val).data ());\n }\n \n /* Extract a value as a C pointer.  Does not deallocate the value.\n@@ -2798,9 +2808,9 @@ value_as_address (struct value *val)\n   if (!value_type (val)->is_pointer_or_reference ()\n       && gdbarch_integer_to_address_p (gdbarch))\n     return gdbarch_integer_to_address (gdbarch, value_type (val),\n-\t\t\t\t       value_contents (val));\n+\t\t\t\t       value_contents (val).data ());\n \n-  return unpack_long (value_type (val), value_contents (val));\n+  return unpack_long (value_type (val), value_contents (val).data ());\n #endif\n }\n \f\n@@ -2924,7 +2934,7 @@ is_floating_value (struct value *val)\n \n   if (is_floating_type (type))\n     {\n-      if (!target_float_is_valid (value_contents (val), type))\n+      if (!target_float_is_valid (value_contents (val).data (), type))\n \terror (_(\"Invalid floating value found in program.\"));\n       return true;\n     }\n@@ -3066,7 +3076,7 @@ value_primitive_field (struct value *arg1, LONGEST offset,\n \t for references to ordinary fields of unavailable values.  */\n       if (BASETYPE_VIA_VIRTUAL (arg_type, fieldno))\n \tboffset = baseclass_offset (arg_type, fieldno,\n-\t\t\t\t    value_contents (arg1),\n+\t\t\t\t    value_contents (arg1).data (),\n \t\t\t\t    value_embedded_offset (arg1),\n \t\t\t\t    value_address (arg1),\n \t\t\t\t    arg1);\n@@ -3325,7 +3335,7 @@ unpack_value_bitfield (struct value *dest_val,\n \n       num = unpack_bits_as_long (field_type, valaddr + embedded_offset,\n \t\t\t\t bitpos, bitsize);\n-      store_signed_integer (value_contents_raw (dest_val),\n+      store_signed_integer (value_contents_raw (dest_val).data (),\n \t\t\t    TYPE_LENGTH (field_type), byte_order, num);\n     }\n \n@@ -3532,7 +3542,7 @@ value_from_longest (struct type *type, LONGEST num)\n {\n   struct value *val = allocate_value (type);\n \n-  pack_long (value_contents_raw (val), type, num);\n+  pack_long (value_contents_raw (val).data (), type, num);\n   return val;\n }\n \n@@ -3544,7 +3554,7 @@ value_from_ulongest (struct type *type, ULONGEST num)\n {\n   struct value *val = allocate_value (type);\n \n-  pack_unsigned_long (value_contents_raw (val), type, num);\n+  pack_unsigned_long (value_contents_raw (val).data (), type, num);\n \n   return val;\n }\n@@ -3558,7 +3568,7 @@ value_from_pointer (struct type *type, CORE_ADDR addr)\n {\n   struct value *val = allocate_value (type);\n \n-  store_typed_address (value_contents_raw (val),\n+  store_typed_address (value_contents_raw (val).data (),\n \t\t       check_typedef (type), addr);\n   return val;\n }\n@@ -3572,7 +3582,7 @@ value_from_host_double (struct type *type, double d)\n {\n   struct value *value = allocate_value (type);\n   gdb_assert (type->code () == TYPE_CODE_FLT);\n-  target_float_from_host_double (value_contents_raw (value),\n+  target_float_from_host_double (value_contents_raw (value).data (),\n \t\t\t\t value_type (value), d);\n   return value;\n }\n@@ -3638,7 +3648,7 @@ value_from_contents (struct type *type, const gdb_byte *contents)\n   struct value *result;\n \n   result = allocate_value (type);\n-  memcpy (value_contents_raw (result), contents, TYPE_LENGTH (type));\n+  memcpy (value_contents_raw (result).data (), contents, TYPE_LENGTH (type));\n   return result;\n }\n \n@@ -3790,7 +3800,7 @@ coerce_ref (struct value *arg)\n   enc_type = check_typedef (value_enclosing_type (arg));\n   enc_type = TYPE_TARGET_TYPE (enc_type);\n \n-  CORE_ADDR addr = unpack_pointer (value_type (arg), value_contents (arg));\n+  CORE_ADDR addr = unpack_pointer (value_type (arg), value_contents (arg).data ());\n   retval = value_at_lazy (enc_type, addr);\n   enc_type = value_type (retval);\n   return readjust_indirect_value_type (retval, enc_type, value_type_arg_tmp,\n@@ -3887,7 +3897,7 @@ value_fetch_lazy_bitfield (struct value *val)\n     value_fetch_lazy (parent);\n \n   unpack_value_bitfield (val, value_bitpos (val), value_bitsize (val),\n-\t\t\t value_contents_for_printing (parent),\n+\t\t\t value_contents_for_printing (parent).data (),\n \t\t\t value_offset (val), parent);\n }\n \n@@ -3903,7 +3913,7 @@ value_fetch_lazy_memory (struct value *val)\n \n   if (TYPE_LENGTH (type))\n       read_value_memory (val, 0, value_stack (val),\n-\t\t\t addr, value_contents_all_raw (val),\n+\t\t\t addr, value_contents_all_raw (val).data (),\n \t\t\t type_length_units (type));\n }\n \n@@ -3999,7 +4009,7 @@ value_fetch_lazy_register (struct value *val)\n       else\n \t{\n \t  int i;\n-\t  const gdb_byte *buf = value_contents (new_val);\n+\t  const gdb_byte *buf = value_contents (new_val).data ();\n \n \t  if (VALUE_LVAL (new_val) == lval_register)\n \t    fprintf_unfiltered (&debug_file, \" register=%d\","
    },
    {
      "sha": "aa105645034a0aa28c08af56633b22ecb94e63bd",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -360,32 +360,32 @@ extern void error_value_optimized_out (void);\n    get to the real subobject, if the value happens to represent\n    something embedded in a larger run-time object.  */\n \n-extern gdb_byte *value_contents_raw (struct value *);\n+extern gdb::array_view<gdb_byte> value_contents_raw (struct value *);\n \n /* Actual contents of the value.  For use of this value; setting it\n    uses the stuff above.  Not valid if lazy is nonzero.  Target\n    byte-order.  We force it to be aligned properly for any possible\n    value.  Note that a value therefore extends beyond what is\n    declared here.  */\n \n-extern const gdb_byte *value_contents (struct value *);\n-extern gdb_byte *value_contents_writeable (struct value *);\n+extern gdb::array_view<const gdb_byte> value_contents (struct value *);\n+extern gdb::array_view<gdb_byte> value_contents_writeable (struct value *);\n \n /* The ALL variants of the above two macros do not adjust the returned\n    pointer by the embedded_offset value.  */\n \n-extern gdb_byte *value_contents_all_raw (struct value *);\n-extern const gdb_byte *value_contents_all (struct value *);\n+extern gdb::array_view<gdb_byte> value_contents_all_raw (struct value *);\n+extern gdb::array_view<const gdb_byte> value_contents_all (struct value *);\n \n /* Like value_contents_all, but does not require that the returned\n    bits be valid.  This should only be used in situations where you\n    plan to check the validity manually.  */\n-extern const gdb_byte *value_contents_for_printing (struct value *value);\n+extern gdb::array_view<const gdb_byte> value_contents_for_printing (struct value *value);\n \n /* Like value_contents_for_printing, but accepts a constant value\n    pointer.  Unlike value_contents_for_printing however, the pointed\n    value must _not_ be lazy.  */\n-extern const gdb_byte *\n+extern gdb::array_view<const gdb_byte>\n   value_contents_for_printing_const (const struct value *value);\n \n extern void value_fetch_lazy (struct value *val);"
    },
    {
      "sha": "70bed6a216fb4519b46f1c0b08a527ba20779f99",
      "filename": "gdb/vax-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/vax-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/vax-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/vax-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -123,7 +123,7 @@ vax_store_arguments (struct regcache *regcache, int nargs,\n \n       sp -= (len + 3) & ~3;\n       count += (len + 3) / 4;\n-      write_memory (sp, value_contents_all (args[i]), len);\n+      write_memory (sp, value_contents_all (args[i]).data (), len);\n     }\n \n   /* Push argument count.  */"
    },
    {
      "sha": "891c48a7956887e500e0772472fdcbb3e0a82274",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -408,7 +408,7 @@ tlb_value_read (struct value *val)\n \n   if (!target_get_tib_address (inferior_ptid, &tlb))\n     error (_(\"Unable to read tlb\"));\n-  store_typed_address (value_contents_raw (val), type, tlb);\n+  store_typed_address (value_contents_raw (val).data (), type, tlb);\n }\n \n /* This function implements the lval_computed support for writing a"
    },
    {
      "sha": "dfff60800fcc0b67bcdfc2c73564ab27cafe3610",
      "filename": "gdb/xstormy16-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/xstormy16-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/xstormy16-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xstormy16-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -257,7 +257,7 @@ xstormy16_push_dummy_call (struct gdbarch *gdbarch,\n \tbreak;\n \n       /* Put argument into registers wordwise.  */\n-      const gdb_byte *val = value_contents (args[i]);\n+      const gdb_byte *val = value_contents (args[i]).data ();\n       for (j = 0; j < typelen; j += xstormy16_reg_size)\n \t{\n \t  ULONGEST regval;\n@@ -275,7 +275,7 @@ xstormy16_push_dummy_call (struct gdbarch *gdbarch,\n      wordaligned.  */\n   for (j = nargs - 1; j >= i; j--)\n     {\n-      const gdb_byte *bytes = value_contents (args[j]);\n+      const gdb_byte *bytes = value_contents (args[j]).data ();\n \n       typelen = TYPE_LENGTH (value_enclosing_type (args[j]));\n       slacklen = typelen & 1;"
    },
    {
      "sha": "42bff4c818f58751a58d04e2d183e6ca6e5890e1",
      "filename": "gdb/xtensa-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/xtensa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/50888e42dcd32b30e1144c0aa6d1c1490da45cd9/gdb/xtensa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-tdep.c?ref=50888e42dcd32b30e1144c0aa6d1c1490da45cd9",
      "patch": "@@ -1731,7 +1731,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t      break;\n \t    }\n \t  fprintf_unfiltered (gdb_stdlog, \" %s\\n\",\n-\t\t\t      host_address_to_string (value_contents (arg)));\n+\t\t\t      host_address_to_string (value_contents (arg).data ()));\n \t}\n     }\n \n@@ -1787,7 +1787,7 @@ xtensa_push_dummy_call (struct gdbarch *gdbarch,\n \t  break;\n \t}\n       info->length = TYPE_LENGTH (arg_type);\n-      info->contents = value_contents (arg);\n+      info->contents = value_contents (arg).data ();\n \n       /* Align size and onstack_size.  */\n       size = (size + info->align - 1) & ~(info->align - 1);"
    }
  ]
}