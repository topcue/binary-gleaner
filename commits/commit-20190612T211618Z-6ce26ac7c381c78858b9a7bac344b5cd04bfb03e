{
  "sha": "6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmNlMjZhYzdjMzgxYzc4ODU4YjlhN2JhYzM0NGI1Y2QwNGJmYjAzZQ==",
  "commit": {
    "author": {
      "name": "Stafford Horne",
      "email": "shorne@gmail.com",
      "date": "2019-06-12T21:16:18Z"
    },
    "committer": {
      "name": "Stafford Horne",
      "email": "shorne@gmail.com",
      "date": "2019-06-12T21:16:18Z"
    },
    "message": "cpu/or1k: Add support for orfp64a32 spec\n\nThis patch adds support for OpenRISC 64-bit FPU operations on 32-bit cores by\nusing register pairs.  The functionality has been added to OpenRISC architecture\nspecification version 1.3 as per architecture proposal 14[0].\n\nFor supporting assembly of both 64-bit and 32-bit precision instructions we have\ndefined CGEN_VALIDATE_INSN_SUPPORTED.  This allows cgen to use 64-bit bit\narchitecture assembly parsing on 64-bit toolchains and 32-bit architecture\nassembly parsing on 32-bit toolchains.  Without this the assembler has issues\nparsing register pairs.\n\nThis patch also contains a few fixes to the symantics for existing OpenRISC\nsingle and double precision FPU operations.\n\n[0] https://openrisc.io/proposals/orfpx64a32\n\ncpu/ChangeLog:\n\nyyyy-mm-dd  Andrey Bacherov  <avbacherov@opencores.org>\n\t    Stafford Horne  <shorne@gmail.com>\n\n\t* or1k.cpu (ORFPX64A32-MACHS): New pmacro.\n\t(ORFPX-MACHS): Removed pmacro.\n\t* or1k.opc (or1k_cgen_insn_supported): New function.\n\t(CGEN_VALIDATE_INSN_SUPPORTED): Define macro.\n\t(parse_regpair, print_regpair): New functions.\n\t* or1kcommon.cpu (h-spr, spr-shift, spr-address, h-gpr): Reorder\n\tand add comments.\n\t(h-fdr): Update comment to indicate or64.\n\t(reg-pair-reg-lo, reg-pair-reg-hi): New pmacros for register pairs.\n\t(h-fd32r): New hardware for 64-bit fpu registers.\n\t(h-i64r): New hardware for 64-bit int registers.\n\t* or1korbis.cpu (f-resv-8-1): New field.\n\t* or1korfpx.cpu (rDSF, rASF, rBSF): Update attribute to ORFPX32-MACHS.\n\t(rDDF, rADF, rBDF): Update operand comment to indicate or64.\n\t(f-rdoff-10-1, f-raoff-9-1, f-rboff-8-1): New fields.\n\t(h-roff1): New hardware.\n\t(double-field-and-ops mnemonic): New pmacro to generate operations\n\trDD32F, rAD32F, rBD32F, rDDI and rADI.\n\t(float-regreg-insn): Update single precision generator to MACH\n\tORFPX32-MACHS.  Add generator for or32 64-bit instructions.\n\t(float-setflag-insn): Update single precision generator to MACH\n\tORFPX32-MACHS.  Fix double instructions from single to double\n\tprecision.  Add generator for or32 64-bit instructions.\n\t(float-cust-insn cust-num): Update single precision generator to MACH\n\tORFPX32-MACHS.  Add generator for or32 64-bit instructions.\n\t(lf-rem-s, lf-itof-s, lf-ftoi-s, lf-madd-s): Update MACH to\n\tORFPX32-MACHS.\n\t(lf-rem-d): Fix operation from mod to rem.\n\t(lf-rem-d32, lf-itof-d32, lf-ftoi-d32, lf-madd-d32): New instruction.\n\t(lf-itof-d): Fix operands from single to double.\n\t(lf-ftoi-d): Update operand mode from DI to WI.",
    "tree": {
      "sha": "87569f01173efe774eb0ee4c470f78f4b0b08af7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/87569f01173efe774eb0ee4c470f78f4b0b08af7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/comments",
  "author": {
    "login": "stffrdhrn",
    "id": 2404255,
    "node_id": "MDQ6VXNlcjI0MDQyNTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stffrdhrn",
    "html_url": "https://github.com/stffrdhrn",
    "followers_url": "https://api.github.com/users/stffrdhrn/followers",
    "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}",
    "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions",
    "organizations_url": "https://api.github.com/users/stffrdhrn/orgs",
    "repos_url": "https://api.github.com/users/stffrdhrn/repos",
    "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stffrdhrn/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "stffrdhrn",
    "id": 2404255,
    "node_id": "MDQ6VXNlcjI0MDQyNTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stffrdhrn",
    "html_url": "https://github.com/stffrdhrn",
    "followers_url": "https://api.github.com/users/stffrdhrn/followers",
    "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}",
    "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions",
    "organizations_url": "https://api.github.com/users/stffrdhrn/orgs",
    "repos_url": "https://api.github.com/users/stffrdhrn/repos",
    "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stffrdhrn/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a0e44ef56c4d1a20785fe3bcb368638d1af148cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a0e44ef56c4d1a20785fe3bcb368638d1af148cf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a0e44ef56c4d1a20785fe3bcb368638d1af148cf"
    }
  ],
  "stats": {
    "total": 421,
    "additions": 375,
    "deletions": 46
  },
  "files": [
    {
      "sha": "cd35e7e222a2272eff8ac23057da5c6ca3de09bf",
      "filename": "cpu/ChangeLog",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/ChangeLog?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -1,3 +1,38 @@\n+2019-06-13  Andrey Bacherov  <avbacherov@opencores.org>\n+\t    Stafford Horne  <shorne@gmail.com>\n+\n+\t* or1k.cpu (ORFPX64A32-MACHS): New pmacro.\n+\t(ORFPX-MACHS): Removed pmacro.\n+\t* or1k.opc (or1k_cgen_insn_supported): New function.\n+\t(CGEN_VALIDATE_INSN_SUPPORTED): Define macro.\n+\t(parse_regpair, print_regpair): New functions.\n+\t* or1kcommon.cpu (h-spr, spr-shift, spr-address, h-gpr): Reorder\n+\tand add comments.\n+\t(h-fdr): Update comment to indicate or64.\n+\t(reg-pair-reg-lo, reg-pair-reg-hi): New pmacros for register pairs.\n+\t(h-fd32r): New hardware for 64-bit fpu registers.\n+\t(h-i64r): New hardware for 64-bit int registers.\n+\t* or1korbis.cpu (f-resv-8-1): New field.\n+\t* or1korfpx.cpu (rDSF, rASF, rBSF): Update attribute to ORFPX32-MACHS.\n+\t(rDDF, rADF, rBDF): Update operand comment to indicate or64.\n+\t(f-rdoff-10-1, f-raoff-9-1, f-rboff-8-1): New fields.\n+\t(h-roff1): New hardware.\n+\t(double-field-and-ops mnemonic): New pmacro to generate operations\n+\trDD32F, rAD32F, rBD32F, rDDI and rADI.\n+\t(float-regreg-insn): Update single precision generator to MACH\n+\tORFPX32-MACHS.  Add generator for or32 64-bit instructions.\n+\t(float-setflag-insn): Update single precision generator to MACH\n+\tORFPX32-MACHS.  Fix double instructions from single to double\n+\tprecision.  Add generator for or32 64-bit instructions.\n+\t(float-cust-insn cust-num): Update single precision generator to MACH\n+\tORFPX32-MACHS.  Add generator for or32 64-bit instructions.\n+\t(lf-rem-s, lf-itof-s, lf-ftoi-s, lf-madd-s): Update MACH to\n+\tORFPX32-MACHS.\n+\t(lf-rem-d): Fix operation from mod to rem.\n+\t(lf-rem-d32, lf-itof-d32, lf-ftoi-d32, lf-madd-d32): New instruction.\n+\t(lf-itof-d): Fix operands from single to double.\n+\t(lf-ftoi-d): Update operand mode from DI to WI.\n+\n 2019-05-23  Jose E. Marchesi  <jose.marchesi@oracle.com>\n \n \t* bpf.cpu: New file."
    },
    {
      "sha": "e1ae1b8c8861e31ad741c256c3c1fc9b1561dc2c",
      "filename": "cpu/or1k.cpu",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1k.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1k.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/or1k.cpu?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -1,8 +1,9 @@\n ; OpenRISC 1000 architecture.  -*- Scheme -*-\n-; Copyright 2000-2014 Free Software Foundation, Inc.\n+; Copyright 2000-2019 Free Software Foundation, Inc.\n ; Contributed for OR32 by Johan Rydberg, jrydberg@opencores.org\n ; Modified by Julius Baxter, juliusbaxter@gmail.com\n ; Modified by Peter Gavin, pgavin@gmail.com\n+; Modified by Andrey Bacherov, avbacherov@opencores.org\n ;\n ; This program is free software; you can redistribute it and/or modify\n ; it under the terms of the GNU General Public License as published by\n@@ -42,12 +43,12 @@\n   (base-insn-bitsize 32)\n   )\n \n-(define-pmacro OR32-MACHS    or32,or32nd)\n-(define-pmacro OR64-MACHS    or64,or64nd)\n-(define-pmacro ORBIS-MACHS   or32,or32nd,or64,or64nd)\n-(define-pmacro ORFPX-MACHS   or32,or32nd,or64,or64nd)\n-(define-pmacro ORFPX32-MACHS or32,or32nd,or64,or64nd)\n-(define-pmacro ORFPX64-MACHS or64,or64nd)\n+(define-pmacro OR32-MACHS       or32,or32nd)\n+(define-pmacro OR64-MACHS       or64,or64nd)\n+(define-pmacro ORBIS-MACHS      or32,or32nd,or64,or64nd)\n+(define-pmacro ORFPX32-MACHS    or32,or32nd,or64,or64nd)\n+(define-pmacro ORFPX64-MACHS    or64,or64nd)\n+(define-pmacro ORFPX64A32-MACHS or32,or32nd) ; float64 for 32-bit machs\n \n (define-attr\n   (for model)"
    },
    {
      "sha": "f0adcbb00a5b94ade4949d8b3594eb030e5b66ae",
      "filename": "cpu/or1k.opc",
      "status": "modified",
      "additions": 92,
      "deletions": 0,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1k.opc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1k.opc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/or1k.opc?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -40,9 +40,29 @@\n #undef  CGEN_DIS_HASH\n #define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)\n \n+/* Check applicability of instructions against machines.  */\n+#define CGEN_VALIDATE_INSN_SUPPORTED\n+\n+extern int or1k_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);\n+\n /* -- */\n \n /* -- opc.c */\n+\n+/* Special check to ensure that instruction exists for given machine.  */\n+\n+int\n+or1k_cgen_insn_supported (CGEN_CPU_DESC cd, const CGEN_INSN *insn)\n+{\n+  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);\n+\n+  /* No mach attribute?  Assume it's supported for all machs.  */\n+  if (machs == 0)\n+    return 1;\n+\n+  return ((machs & cd->machs) != 0);\n+}\n+\n /* -- */\n \n /* -- asm.c */\n@@ -415,6 +435,78 @@ parse_uimm16_split (CGEN_CPU_DESC cd, const char **strp, int opindex,\n   return errmsg;\n }\n \n+/* Parse register pairs with syntax rA,rB to a flag + rA value.  */\n+\n+static const char *\n+parse_regpair (CGEN_CPU_DESC cd, const char **strp,\n+\t       int opindex ATTRIBUTE_UNUSED, unsigned long *valuep)\n+{\n+  long reg1_index;\n+  long reg2_index;\n+  const char *errmsg;\n+\n+  /* The first part should just be a register.  */\n+  errmsg = cgen_parse_keyword (cd, strp, &or1k_cgen_opval_h_gpr,\n+\t\t\t       &reg1_index);\n+\n+  /* If that worked skip the comma separator.  */\n+  if (errmsg == NULL)\n+    {\n+      if (**strp == ',')\n+\t++*strp;\n+      else\n+\terrmsg = \"Unexpected character, expected ','\";\n+    }\n+\n+  /* If that worked the next part is just another register.  */\n+  if (errmsg == NULL)\n+    errmsg = cgen_parse_keyword (cd, strp, &or1k_cgen_opval_h_gpr,\n+\t\t\t\t &reg2_index);\n+\n+  /* Validate the register pair is valid and create the output value.  */\n+  if (errmsg == NULL)\n+    {\n+      int regoffset = reg2_index - reg1_index;\n+\n+      if (regoffset == 1 || regoffset == 2)\n+\t{\n+\t  unsigned short offsetmask;\n+\t  unsigned short value;\n+\n+\t  offsetmask = ((regoffset == 2 ? 1 : 0) << 5);\n+\t  value = offsetmask | reg1_index;\n+\n+\t  *valuep = value;\n+\t}\n+      else\n+\terrmsg = \"Invalid register pair, offset not 1 or 2.\";\n+    }\n+\n+  return errmsg;\n+}\n+\n+/* -- */\n+\n+/* -- dis.c */\n+\n+static void\n+print_regpair (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,\n+\t       void * dis_info,\n+\t       long value,\n+\t       unsigned int attrs ATTRIBUTE_UNUSED,\n+\t       bfd_vma pc ATTRIBUTE_UNUSED,\n+\t       int length ATTRIBUTE_UNUSED)\n+{\n+  disassemble_info *info = dis_info;\n+  char reg1_index;\n+  char reg2_index;\n+\n+  reg1_index = value & 0x1f;\n+  reg2_index = reg1_index + ((value & (1 << 5)) ? 2 : 1);\n+\n+  (*info->fprintf_func) (info->stream, \"r%d,r%d\", reg1_index, reg2_index);\n+}\n+\n /* -- */\n \n /* -- ibd.h */"
    },
    {
      "sha": "65154407df91858993d926b4672a43e0e5b798ce",
      "filename": "cpu/or1kcommon.cpu",
      "status": "modified",
      "additions": 94,
      "deletions": 19,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1kcommon.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1kcommon.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/or1kcommon.cpu?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -1,7 +1,8 @@\n ; OpenRISC 1000 32-bit CPU hardware description.  -*- Scheme -*-\n-; Copyright 2000-2014 Free Software Foundation, Inc.\n+; Copyright 2000-2019 Free Software Foundation, Inc.\n ; Contributed for OR32 by Johan Rydberg, jrydberg@opencores.org\n ; Modified by Julius Baxter, juliusbaxter@gmail.com\n+; Modified by Andrey Bacherov, avbacherov@opencores.org\n ;\n ; This program is free software; you can redistribute it and/or modify\n ; it under the terms of the GNU General Public License as published by\n@@ -71,6 +72,38 @@\n    (fp 2))\n   )\n \n+;\n+; Hardware: [S]pecial [P]urpose [R]egisters\n+;\n+(define-hardware\n+  (name h-spr) (comment \"special purpose registers\")\n+  (attrs VIRTUAL (MACH ORBIS-MACHS))\n+  (type register UWI (#x20000))\n+  (get (index) (c-call UWI \"@cpu@_h_spr_get_raw\" index))\n+  (set (index newval) (c-call VOID \"@cpu@_h_spr_set_raw\" index newval))\n+)\n+\n+(define-pmacro spr-shift 11)\n+(define-pmacro (spr-address spr-group spr-index)\n+  (or (sll UWI (enum UWI (.sym \"SPR-GROUP-\" spr-group)) spr-shift)\n+      (enum UWI (.sym \"SPR-INDEX-\" spr-group \"-\" spr-index))))\n+\n+;\n+; Hardware: [G]enepral  [P]urpose [R]egisters\n+;\n+(define-hardware\n+  (name h-gpr) (comment \"general registers\")\n+  (attrs (MACH ORBIS-MACHS))\n+  (type register UWI (32))\n+  (indices keyword \"\" REG-INDICES)\n+  (get (index) (reg UWI h-spr (add index (spr-address SYS GPR0))))\n+  (set (index newval) (set UWI (reg UWI h-spr (add index (spr-address SYS GPR0))) newval))\n+  )\n+\n+;\n+; Hardware: virtual registerts for FPU (single precision)\n+;           mapped to GPRs\n+;\n (define-hardware\n   (name h-fsr)\n   (comment \"floating point registers (single, virtual)\")\n@@ -81,36 +114,78 @@\n   (set (index newval) (set UWI (reg h-gpr index) (zext UWI (subword SI newval 0))))\n   )\n \n+;\n+; Hardware: virtual registerts for FPU (double precision)\n+;           mapped to GPRs\n+;\n (define-hardware\n-  (name h-fdr) (comment \"floating point registers (double, virtual)\")\n+  (name h-fdr)\n+  (comment \"or64 floating point registers (double, virtual)\")\n   (attrs VIRTUAL (MACH ORFPX64-MACHS))\n   (type register DF (32))\n   (indices keyword \"\" REG-INDICES)\n   (get (index) (subword DF (trunc DI (reg h-gpr index)) 0))\n   (set (index newval) (set UDI (reg h-gpr index) (zext UDI (subword DI newval 0))))\n   )\n \n-(define-hardware\n-  (name h-spr) (comment \"special purpose registers\")\n-  (attrs VIRTUAL (MACH ORBIS-MACHS))\n-  (type register UWI (#x20000))\n-  (get (index) (c-call UWI \"@cpu@_h_spr_get_raw\" index))\n-  (set (index newval) (c-call VOID \"@cpu@_h_spr_set_raw\" index newval))\n+;\n+; Register pairs are offset by 2 for registers r16 and above.  This is to\n+; be able to allow registers to be call saved in GCC across function calls.\n+;\n+(define-pmacro (reg-pair-reg-lo index)\n+  (and index (const #x1f))\n )\n \n-(define-pmacro spr-shift 11)\n-(define-pmacro (spr-address spr-group spr-index)\n-  (or (sll UWI (enum UWI (.sym \"SPR-GROUP-\" spr-group)) spr-shift)\n-      (enum UWI (.sym \"SPR-INDEX-\" spr-group \"-\" spr-index))))\n+(define-pmacro (reg-pair-reg-hi index)\n+  (add (and index (const #x1f))\n+       (if (eq (sra index (const 5))\n+\t       (const 1))\n+\t   (const 2)\n+\t   (const 1)\n+\t )\n+    )\n+)\n+\n+;\n+; Hardware: vrtual registers for double precision floating point\n+;           operands on 32-bit machines\n+;           mapped to GPRs\n+;\n+(define-hardware\n+  (name h-fd32r)\n+  (comment \"or32 floating point registers (double, virtual)\")\n+  (attrs VIRTUAL (MACH ORFPX64A32-MACHS))\n+  (type register DF (32))\n+  (get (index) (join DF SI\n+                        (reg h-gpr (reg-pair-reg-lo index))\n+                        (reg h-gpr (reg-pair-reg-hi index))))\n+  (set (index newval)\n+       (sequence ()\n+                 (set (reg h-gpr (reg-pair-reg-lo index)) (subword SI newval 0))\n+                 (set (reg h-gpr (reg-pair-reg-hi index))\n+                                 (subword SI newval 1))))\n+)\n \n+;\n+; Hardware: vrtual 64-bit integer registers for conversions\n+;           float64 <-> int64 on 32-bit machines\n+;           mapped to GPRs\n+;\n (define-hardware\n-  (name h-gpr) (comment \"general registers\")\n-  (attrs (MACH ORBIS-MACHS))\n-  (type register UWI (32))\n-  (indices keyword \"\" REG-INDICES)\n-  (get (index) (reg UWI h-spr (add index (spr-address SYS GPR0))))\n-  (set (index newval) (set UWI (reg UWI h-spr (add index (spr-address SYS GPR0))) newval))\n-  )\n+  (name h-i64r)\n+  (comment \"or32 double word registers (int64, virtual)\")\n+  (attrs VIRTUAL (MACH ORFPX64A32-MACHS))\n+  (type register DI (32))\n+  (get (index) (join DI SI\n+                        (reg h-gpr (reg-pair-reg-lo index))\n+                        (reg h-gpr (reg-pair-reg-hi index))))\n+  (set (index newval)\n+       (sequence ()\n+                 (set (reg h-gpr (reg-pair-reg-lo index)) (subword SI newval 0))\n+                 (set (reg h-gpr (reg-pair-reg-hi index))\n+                                 (subword SI newval 1))))\n+)\n+\n \n (define-normal-enum\n   except-number"
    },
    {
      "sha": "308f37861d4ef5c22d14698fe2ef41a4d808ed35",
      "filename": "cpu/or1korbis.cpu",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1korbis.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1korbis.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/or1korbis.cpu?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -61,6 +61,7 @@\n (dnf f-resv-10-7   \"resv-10-7\"                 ((MACH ORBIS-MACHS) RESERVED) 10 7)\n (dnf f-resv-10-3   \"resv-10-3\"                 ((MACH ORBIS-MACHS) RESERVED) 10 3)\n (dnf f-resv-10-1   \"resv-10-1\"                 ((MACH ORBIS-MACHS) RESERVED) 10 1)\n+(dnf f-resv-8-1    \"resv-8-1\"                  ((MACH ORBIS-MACHS) RESERVED) 8 1)\n (dnf f-resv-7-4    \"resv-7-4\"                  ((MACH ORBIS-MACHS) RESERVED) 7 4)\n (dnf f-resv-5-2    \"resv-5-2\"                  ((MACH ORBIS-MACHS) RESERVED) 5 2)\n "
    },
    {
      "sha": "eb01f1ca665a7e4c08d196a2217338fd465211ef",
      "filename": "cpu/or1korfpx.cpu",
      "status": "modified",
      "additions": 145,
      "deletions": 20,
      "changes": 165,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1korfpx.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ce26ac7c381c78858b9a7bac344b5cd04bfb03e/cpu/or1korfpx.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/or1korfpx.cpu?ref=6ce26ac7c381c78858b9a7bac344b5cd04bfb03e",
      "patch": "@@ -1,6 +1,7 @@\n ; OpenRISC 1000 architecture.  -*- Scheme -*-\n-; Copyright 2000-2014 Free Software Foundation, Inc.\n+; Copyright 2000-2019 Free Software Foundation, Inc.\n ; Contributed by Peter Gavin, pgavin@gmail.com\n+; Modified by Andrey Bacherov, avbacherov@opencores.org\n ;\n ; This program is free software; you can redistribute it and/or modify\n ; it under the terms of the GNU General Public License as published by\n@@ -58,19 +59,80 @@\n    )\n   )\n \n-(dnop rDSF \"destination register (single floating point mode)\" () h-fsr f-r1)\n-(dnop rASF \"source register A (single floating point mode)\"    () h-fsr f-r2)\n-(dnop rBSF \"source register B (single floating point mode)\"    () h-fsr f-r3)\n+; Register offset flags, if set offset is 2 otherwise offset is 1\n+(dnf f-rdoff-10-1   \"destination register pair offset flag\" ((MACH ORFPX64A32-MACHS)) 10 1)\n+(dnf f-raoff-9-1    \"source register A pair offset flag\"    ((MACH ORFPX64A32-MACHS)) 9 1)\n+(dnf f-rboff-8-1    \"source register B pair offset flag\"    ((MACH ORFPX64A32-MACHS)) 8 1)\n \n-(dnop rDDF \"destination register (double floating point mode)\" ((MACH ORFPX64-MACHS)) h-fdr f-r1)\n-(dnop rADF \"source register A (double floating point mode)\"    ((MACH ORFPX64-MACHS)) h-fdr f-r1)\n-(dnop rBDF \"source register B (double floating point mode)\"    ((MACH ORFPX64-MACHS)) h-fdr f-r1)\n+(dsh h-roff1        \"1-bit offset flag\"                     () (register BI))\n+\n+(dnop rDSF \"destination register (single floating point mode)\" ((MACH ORFPX32-MACHS)) h-fsr f-r1)\n+(dnop rASF \"source register A (single floating point mode)\"    ((MACH ORFPX32-MACHS)) h-fsr f-r2)\n+(dnop rBSF \"source register B (single floating point mode)\"    ((MACH ORFPX32-MACHS)) h-fsr f-r3)\n+\n+(dnop rDDF \"or64 destination register (double floating point mode)\" ((MACH ORFPX64-MACHS)) h-fdr f-r1)\n+(dnop rADF \"or64 source register A (double floating point mode)\"    ((MACH ORFPX64-MACHS)) h-fdr f-r2)\n+(dnop rBDF \"or64 source register B (double floating point mode)\"    ((MACH ORFPX64-MACHS)) h-fdr f-r3)\n+\n+(define-pmacro (double-field-and-ops mnemonic reg offbit op-comment)\n+  (begin\n+    (define-multi-ifield\n+      (name (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+      (comment op-comment)\n+      (attrs (MACH ORFPX64A32-MACHS))\n+      (mode SI)\n+      (subfields reg offbit)\n+      ; From the multi-ifield insert the bits into subfields\n+      (insert (sequence\n+\t\t()\n+\t\t(set (ifield reg)\n+\t\t  (and (ifield (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+\t\t       (const #x1f))\n+\t\t  )\n+\t\t(set (ifield offbit)\n+\t\t  (and (sra (ifield (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+\t\t            (const 5))\n+\t\t       (const 1))\n+\t\t  )\n+\t\t)\n+\t)\n+      ; Extract the multi-ifield from the subfield bits\n+      (extract\n+\t       (set (ifield (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+\t\t    (or (ifield reg)\n+\t\t\t(sll (ifield offbit)\n+\t\t\t     (const 5)))\n+\t\t )\n+        )\n+      )\n+    (define-operand\n+      (name (.sym \"r\" (.upcase mnemonic) \"D32F\"))\n+      (comment (.str op-comment \" (double floating point pair)\"))\n+      (attrs (MACH ORFPX64A32-MACHS))\n+      (type h-fd32r)\n+      (index (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+      (handlers (parse \"regpair\") (print \"regpair\"))\n+      )\n+    (define-operand\n+      (name (.sym \"r\" (.upcase mnemonic) \"DI\"))\n+      (comment (.str op-comment \" (double integer pair)\"))\n+      (attrs (MACH ORFPX64A32-MACHS))\n+      (type h-i64r)\n+      (index (.sym \"f-r\" (.downcase mnemonic) \"d32\"))\n+      (handlers (parse \"regpair\") (print \"regpair\"))\n+      )\n+    )\n+  )\n+\n+(double-field-and-ops D f-r1 f-rdoff-10-1 \"destination register\")\n+(double-field-and-ops A f-r2 f-raoff-9-1  \"source register A\")\n+(double-field-and-ops B f-r3 f-rboff-8-1  \"source register B\")\n \n (define-pmacro (float-regreg-insn mnemonic)\n   (begin\n     (dni (.sym lf- mnemonic -s)\n          (.str \"lf.\" mnemonic \".s reg/reg/reg\")\n-         ((MACH ORFPX-MACHS))\n+         ((MACH ORFPX32-MACHS))\n          (.str \"lf.\" mnemonic \".s $rDSF,$rASF,$rBSF\")\n          (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_ (.upcase mnemonic) _S))\n          (set SF rDSF (mnemonic SF rASF rBSF))\n@@ -84,6 +146,14 @@\n          (set DF rDDF (mnemonic DF rADF rBDF))\n          ()\n          )\n+    (dni (.sym lf- mnemonic -d32)\n+         (.str \"lf.\" mnemonic \".d regpair/regpair/regpair\")\n+         ((MACH ORFPX64A32-MACHS))\n+         (.str \"lf.\" mnemonic \".d $rDD32F,$rAD32F,$rBD32F\")\n+         (+ OPC_FLOAT rDD32F rAD32F rBD32F (.sym OPC_FLOAT_REGREG_ (.upcase mnemonic) _D))\n+         (set DF rDD32F (mnemonic DF rAD32F rBD32F))\n+         ()\n+         )\n     )\n   )\n \n@@ -94,18 +164,28 @@\n \n (dni lf-rem-s\n      \"lf.rem.s reg/reg/reg\"\n-     ((MACH ORFPX-MACHS))\n+     ((MACH ORFPX32-MACHS))\n      \"lf.rem.s $rDSF,$rASF,$rBSF\"\n      (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) OPC_FLOAT_REGREG_REM_S)\n      (set SF rDSF (rem SF rASF rBSF))\n      ()\n      )\n+\n (dni lf-rem-d\n      \"lf.rem.d reg/reg/reg\"\n      ((MACH ORFPX64-MACHS))\n      \"lf.rem.d $rDDF,$rADF,$rBDF\"\n      (+ OPC_FLOAT rDDF rADF rBDF (f-resv-10-3 0) OPC_FLOAT_REGREG_REM_D)\n-     (set DF rDDF (mod DF rADF rBDF))\n+     (set DF rDDF (rem DF rADF rBDF))\n+     ()\n+     )\n+\n+(dni lf-rem-d32\n+     \"lf.rem.d regpair/regpair/regpair\"\n+     ((MACH ORFPX64A32-MACHS))\n+     \"lf.rem.d $rDD32F,$rAD32F,$rBD32F\"\n+     (+ OPC_FLOAT rDD32F rAD32F rBD32F OPC_FLOAT_REGREG_REM_D)\n+     (set DF rDD32F (rem DF rAD32F rBD32F))\n      ()\n      )\n \n@@ -120,24 +200,34 @@\n \n (dni lf-itof-s\n      \"lf.itof.s reg/reg\"\n-     ((MACH ORFPX-MACHS))\n+     ((MACH ORFPX32-MACHS))\n      \"lf.itof.s $rDSF,$rA\"\n      (+ OPC_FLOAT rDSF rA (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_ITOF_S)\n      (set SF rDSF (float SF (get-rounding-mode) (trunc SI rA)))\n      ()\n      )\n+\n (dni lf-itof-d\n      \"lf.itof.d reg/reg\"\n      ((MACH ORFPX64-MACHS))\n-     \"lf.itof.d $rDSF,$rA\"\n-     (+ OPC_FLOAT rDSF rA (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_ITOF_D)\n+     \"lf.itof.d $rDDF,$rA\"\n+     (+ OPC_FLOAT rDDF rA (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_ITOF_D)\n      (set DF rDDF (float DF (get-rounding-mode) rA))\n      ()\n      )\n \n+(dni lf-itof-d32\n+     \"lf.itof.d regpair/regpair\"\n+     ((MACH ORFPX64A32-MACHS))\n+     \"lf.itof.d $rDD32F,$rADI\"\n+     (+ OPC_FLOAT rDD32F rADI (f-r3 0) (f-resv-8-1 0) OPC_FLOAT_REGREG_ITOF_D)\n+     (set DF rDD32F (float DF (get-rounding-mode) rADI))\n+     ()\n+     )\n+\n (dni lf-ftoi-s\n      \"lf.ftoi.s reg/reg\"\n-     ((MACH ORFPX-MACHS))\n+     ((MACH ORFPX32-MACHS))\n      \"lf.ftoi.s $rD,$rASF\"\n      (+ OPC_FLOAT rD rASF (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_FTOI_S)\n      (set WI rD (ext WI (fix SI (get-rounding-mode) rASF)))\n@@ -149,15 +239,24 @@\n      ((MACH ORFPX64-MACHS))\n      \"lf.ftoi.d $rD,$rADF\"\n      (+ OPC_FLOAT rD rADF (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_FTOI_D)\n-     (set DI rD (fix DI (get-rounding-mode) rADF))\n+     (set WI rD (fix WI (get-rounding-mode) rADF))\n+     ()\n+     )\n+\n+(dni lf-ftoi-d32\n+     \"lf.ftoi.d regpair/regpair\"\n+     ((MACH ORFPX64A32-MACHS))\n+     \"lf.ftoi.d $rDDI,$rAD32F\"\n+     (+ OPC_FLOAT rDDI rAD32F (f-r3 0) (f-resv-8-1 0) OPC_FLOAT_REGREG_FTOI_D)\n+     (set DI rDDI (fix DI (get-rounding-mode) rAD32F))\n      ()\n      )\n \n (define-pmacro (float-setflag-insn mnemonic)\n   (begin\n     (dni (.sym lf- mnemonic -s)\n          (.str \"lf.sf\" mnemonic \".s reg/reg\")\n-         ((MACH ORFPX-MACHS))\n+         ((MACH ORFPX32-MACHS))\n          (.str \"lf.sf\" mnemonic \".s $rASF,$rBSF\")\n          (+ OPC_FLOAT (f-r1 0) rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _S))\n          (set BI sys-sr-f (mnemonic SF rASF rBSF))\n@@ -166,11 +265,19 @@\n     (dni (.sym lf- mnemonic -d)\n          (.str \"lf.sf\" mnemonic \".d reg/reg\")\n          ((MACH ORFPX64-MACHS))\n-         (.str \"lf.sf\" mnemonic \".d $rASF,$rBSF\")\n-         (+ OPC_FLOAT (f-r1 0) rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _D))\n+         (.str \"lf.sf\" mnemonic \".d $rADF,$rBDF\")\n+         (+ OPC_FLOAT (f-r1 0) rADF rBDF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _D))\n          (set BI sys-sr-f (mnemonic DF rADF rBDF))\n          ()\n          )\n+    (dni (.sym lf- mnemonic -d32)\n+         (.str \"lf.sf\" mnemonic \".d regpair/regpair\")\n+         ((MACH ORFPX64A32-MACHS))\n+         (.str \"lf.sf\" mnemonic \".d $rAD32F,$rBD32F\")\n+         (+ OPC_FLOAT (f-r1 0) rAD32F rBD32F (f-resv-10-1 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _D))\n+         (set BI sys-sr-f (mnemonic DF rAD32F rBD32F))\n+         ()\n+         )\n     )\n   )\n \n@@ -183,12 +290,13 @@\n \n (dni lf-madd-s\n      \"lf.madd.s reg/reg/reg\"\n-     ((MACH ORFPX-MACHS))\n+     ((MACH ORFPX32-MACHS))\n      \"lf.madd.s $rDSF,$rASF,$rBSF\"\n      (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) OPC_FLOAT_REGREG_MADD_S)\n      (set SF rDSF (add SF (mul SF rASF rBSF) rDSF))\n      ()\n      )\n+\n (dni lf-madd-d\n      \"lf.madd.d reg/reg/reg\"\n      ((MACH ORFPX64-MACHS))\n@@ -198,11 +306,20 @@\n      ()\n      )\n \n+(dni lf-madd-d32\n+     \"lf.madd.d regpair/regpair/regpair\"\n+     ((MACH ORFPX64A32-MACHS))\n+     \"lf.madd.d $rDD32F,$rAD32F,$rBD32F\"\n+     (+ OPC_FLOAT rDD32F rAD32F rBD32F OPC_FLOAT_REGREG_MADD_D)\n+     (set DF rDD32F (add DF (mul DF rAD32F rBD32F) rDD32F))\n+     ()\n+     )\n+\n (define-pmacro (float-cust-insn cust-num)\n   (begin\n     (dni (.sym \"lf-cust\" cust-num \"-s\")\n          (.str \"lf.cust\" cust-num \".s\")\n-         ((MACH ORFPX-MACHS))\n+         ((MACH ORFPX32-MACHS))\n          (.str \"lf.cust\" cust-num \".s $rASF,$rBSF\")\n          (+ OPC_FLOAT (f-resv-25-5 0) rASF rBSF (f-resv-10-3 0) (.sym \"OPC_FLOAT_REGREG_CUST\" cust-num \"_S\"))\n          (nop)\n@@ -216,6 +333,14 @@\n          (nop)\n          ()\n          )\n+    (dni (.sym \"lf-cust\" cust-num \"-d32\")\n+         (.str \"lf.cust\" cust-num \".d\")\n+         ((MACH ORFPX64A32-MACHS))\n+         (.str \"lf.cust\" cust-num \".d\")\n+         (+ OPC_FLOAT (f-resv-25-5 0) rAD32F rBD32F (f-resv-10-1 0) (.sym \"OPC_FLOAT_REGREG_CUST\" cust-num \"_D\"))\n+         (nop)\n+         ()\n+         )\n     )\n   )\n "
    }
  ]
}