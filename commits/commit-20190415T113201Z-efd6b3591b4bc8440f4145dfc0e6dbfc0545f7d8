{
  "sha": "efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWZkNmIzNTkxYjRiYzg0NDBmNDE0NWRmYzBlNmRiZmMwNTQ1ZjdkOA==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-04-15T11:18:16Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-04-15T11:32:01Z"
    },
    "message": "[binutils, ARM, 15/16] Add support for VSCCLRM\n\nLike for CLRM, this patch aims to share as much logic with the similar looking VLDM/VSTM. This is achieved by adding 2 new enumerator values in enum reg_list_els for the single-precision and double-precision variants of VSCCLRM and extending parse_vfp_reg_list () to deal with these types.\nThese behave like the existing REGLIST_VFP_S and REGLIST_VFP_D types with extra logic to expect VPR as the last element in the register list.\nThe function is algo augmented with a new partial_match parameter to indicate if any register other than VPR had already been parsed in the register list so as to not try parsing the second variant if that's the case and return the right error message.\n\nThe rest of the patch is the usual encoding function, new disassembler table entries and format specifier and parsing, encoding and disassembling tests.\n\nIt is worth mentioning that the new entry in the disassembler table was added in the coprocessor-related table despite VSCCLRM always being available even in FPU-less configurations. The main reason for this is that VSCCLRM also match VLDMIA entry and must thus be tried first but coprocessor entries are tried before T32 entries. It also makes sense because it is in the same encoding space as coprocessor and VFP instructions and is thus the natural place for someone to look for this instruction.\n\nNote: Both variants of VSCCLRM support D16-D31 registers but Armv8.1-M Mainline overall does not. I have thus decided not to implement support for these registers in order to keep the code simpler. It can always be added later if needed.\n\nChangeLog entries are as follows:\n\n*** gas/ChangeLog ***\n\n2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/tc-arm.c (arm_typed_reg_parse): Fix typo in comment.\n\t(enum reg_list_els): New REGLIST_VFP_S_VPR and REGLIST_VFP_D_VPR\n\tenumerators.\n\t(parse_vfp_reg_list): Add new partial_match parameter.  Set\n\t*partial_match to TRUE if at least one element in the register list has\n\tmatched.  Add support for REGLIST_VFP_S_VPR and REGLIST_VFP_D_VPR\n\tregister lists which expect VPR as last element in the list.\n\t(s_arm_unwind_save_vfp_armv6): Adapt call to parse_vfp_reg_list to new\n\tprototype.\n\t(s_arm_unwind_save_vfp): Likewise.\n\t(enum operand_parse_code): New OP_VRSDVLST enumerator.\n\t(parse_operands): Adapt call to parse_vfp_reg_list to new prototype.\n\tHandle new OP_VRSDVLST case.\n\t(do_t_vscclrm): New function.\n\t(insns): New entry for VSCCLRM instruction.\n\t* testsuite/gas/arm/archv8m_1m-cmse-main-bad.s: Add invalid VSCCLRM\n\tinstructions.\n\t* testsuite/gas/arm/archv8m_1m-cmse-main-bad.l: Add error expectations\n\tfor above instructions.\n\t* testsuite/gas/arm/archv8m_1m-cmse-main.s: Add tests for VSCCLRM\n\tinstruction.\n\t* testsuite/gas/arm/archv8m_1m-cmse-main.d: Add expected disassembly\n\tfor above instructions.\n\n*** opcodes/ChangeLog ***\n\n2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* arm-dis.c (coprocessor_opcodes): Document new %C format control code.\n\tAdd new entries for VSCCLRM instruction.\n\t(print_insn_coprocessor): Handle new %C format control code.",
    "tree": {
      "sha": "c476839cb0a080902c9cdf252c91738216ffa6e1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c476839cb0a080902c9cdf252c91738216ffa6e1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6b0dd094741bc5e9963eabc64a7030783e471941",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6b0dd094741bc5e9963eabc64a7030783e471941",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6b0dd094741bc5e9963eabc64a7030783e471941"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 196,
    "deletions": 14
  },
  "files": [
    {
      "sha": "d669d00b9cfe849a81a84b91da2e765d4da2ff81",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -1,3 +1,29 @@\n+2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/tc-arm.c (arm_typed_reg_parse): Fix typo in comment.\n+\t(enum reg_list_els): New REGLIST_VFP_S_VPR and REGLIST_VFP_D_VPR\n+\tenumerators.\n+\t(parse_vfp_reg_list): Add new partial_match parameter.  Set\n+\t*partial_match to TRUE if at least one element in the register list has\n+\tmatched.  Add support for REGLIST_VFP_S_VPR and REGLIST_VFP_D_VPR\n+\tregister lists which expect VPR as last element in the list.\n+\t(s_arm_unwind_save_vfp_armv6): Adapt call to parse_vfp_reg_list to new\n+\tprototype.\n+\t(s_arm_unwind_save_vfp): Likewise.\n+\t(enum operand_parse_code): New OP_VRSDVLST enumerator.\n+\t(parse_operands): Adapt call to parse_vfp_reg_list to new prototype.\n+\tHandle new OP_VRSDVLST case.\n+\t(do_t_vscclrm): New function.\n+\t(insns): New entry for VSCCLRM instruction.\n+\t* testsuite/gas/arm/archv8m_1m-cmse-main-bad.s: Add invalid VSCCLRM\n+\tinstructions.\n+\t* testsuite/gas/arm/archv8m_1m-cmse-main-bad.l: Add error expectations\n+\tfor above instructions.\n+\t* testsuite/gas/arm/archv8m_1m-cmse-main.s: Add tests for VSCCLRM\n+\tinstruction.\n+\t* testsuite/gas/arm/archv8m_1m-cmse-main.d: Add expected disassembly\n+\tfor above instructions.\n+\n 2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/tc-arm.c (enum reg_list_els): Define earlier and add"
    },
    {
      "sha": "b5dc3eb212ea414e86c8620160496d8f1ee508b6",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 103,
      "deletions": 14,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -1609,7 +1609,7 @@ parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,\n   return reg->number;\n }\n \n-/* Like arm_reg_parse, but allow allow the following extra features:\n+/* Like arm_reg_parse, but also allow the following extra features:\n     - If RTYPE is non-zero, return the (possibly restricted) type of the\n       register (e.g. Neon double or quad reg when either has been requested).\n     - If this is a Neon vector type with additional type information, fill\n@@ -1695,7 +1695,9 @@ enum reg_list_els\n   REGLIST_RN,\n   REGLIST_CLRM,\n   REGLIST_VFP_S,\n+  REGLIST_VFP_S_VPR,\n   REGLIST_VFP_D,\n+  REGLIST_VFP_D_VPR,\n   REGLIST_NEON_D\n };\n \n@@ -1869,7 +1871,8 @@ parse_reg_list (char ** strp, enum reg_list_els etype)\n    bug.  */\n \n static int\n-parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n+parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype,\n+\t\t    bfd_boolean *partial_match)\n {\n   char *str = *ccp;\n   int base_reg;\n@@ -1880,6 +1883,9 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n   int warned = 0;\n   unsigned long mask = 0;\n   int i;\n+  bfd_boolean vpr_seen = FALSE;\n+  bfd_boolean expect_vpr =\n+    (etype == REGLIST_VFP_S_VPR) || (etype == REGLIST_VFP_D_VPR);\n \n   if (skip_past_char (&str, '{') == FAIL)\n     {\n@@ -1890,11 +1896,13 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n   switch (etype)\n     {\n     case REGLIST_VFP_S:\n+    case REGLIST_VFP_S_VPR:\n       regtype = REG_TYPE_VFS;\n       max_regs = 32;\n       break;\n \n     case REGLIST_VFP_D:\n+    case REGLIST_VFP_D_VPR:\n       regtype = REG_TYPE_VFD;\n       break;\n \n@@ -1906,7 +1914,7 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n       gas_assert (0);\n     }\n \n-  if (etype != REGLIST_VFP_S)\n+  if (etype != REGLIST_VFP_S && etype != REGLIST_VFP_S_VPR)\n     {\n       /* VFPv3 allows 32 D registers, except for the VFPv3-D16 variant.  */\n       if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_d32))\n@@ -1924,19 +1932,54 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n     }\n \n   base_reg = max_regs;\n+  *partial_match = FALSE;\n \n   do\n     {\n       int setmask = 1, addregs = 1;\n+      const char vpr_str[] = \"vpr\";\n+      int vpr_str_len = strlen (vpr_str);\n \n       new_base = arm_typed_reg_parse (&str, regtype, &regtype, NULL);\n \n-      if (new_base == FAIL)\n+      if (expect_vpr)\n+\t{\n+\t  if (new_base == FAIL\n+\t      && !strncasecmp (str, vpr_str, vpr_str_len)\n+\t      && !ISALPHA (*(str + vpr_str_len))\n+\t      && !vpr_seen)\n+\t    {\n+\t      vpr_seen = TRUE;\n+\t      str += vpr_str_len;\n+\t      if (count == 0)\n+\t\tbase_reg = 0; /* Canonicalize VPR only on d0 with 0 regs.  */\n+\t    }\n+\t  else if (vpr_seen)\n+\t    {\n+\t      first_error (_(\"VPR expected last\"));\n+\t      return FAIL;\n+\t    }\n+\t  else if (new_base == FAIL)\n+\t    {\n+\t      if (regtype == REG_TYPE_VFS)\n+\t\tfirst_error (_(\"VFP single precision register or VPR \"\n+\t\t\t       \"expected\"));\n+\t      else /* regtype == REG_TYPE_VFD.  */\n+\t\tfirst_error (_(\"VFP/Neon double precision register or VPR \"\n+\t\t\t       \"expected\"));\n+\t      return FAIL;\n+\t    }\n+\t}\n+      else if (new_base == FAIL)\n \t{\n \t  first_error (_(reg_expected_msgs[regtype]));\n \t  return FAIL;\n \t}\n \n+      *partial_match = TRUE;\n+      if (vpr_seen)\n+\tcontinue;\n+\n       if (new_base >= max_regs)\n \t{\n \t  first_error (_(\"register out of range in list\"));\n@@ -1959,7 +2002,7 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n \t  return FAIL;\n \t}\n \n-      if ((mask >> new_base) != 0 && ! warned)\n+      if ((mask >> new_base) != 0 && ! warned && !vpr_seen)\n \t{\n \t  as_tsktsk (_(\"register list not in ascending order\"));\n \t  warned = 1;\n@@ -2014,11 +2057,17 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype)\n   str++;\n \n   /* Sanity check -- should have raised a parse error above.  */\n-  if (count == 0 || count > max_regs)\n+  if ((!vpr_seen && count == 0) || count > max_regs)\n     abort ();\n \n   *pbase = base_reg;\n \n+  if (expect_vpr && !vpr_seen)\n+    {\n+      first_error (_(\"VPR expected last\"));\n+      return FAIL;\n+    }\n+\n   /* Final test -- the registers must be consecutive.  */\n   mask >>= base_reg;\n   for (i = 0; i < count; i++)\n@@ -4146,8 +4195,10 @@ s_arm_unwind_save_vfp_armv6 (void)\n   valueT op;\n   int num_vfpv3_regs = 0;\n   int num_regs_below_16;\n+  bfd_boolean partial_match;\n \n-  count = parse_vfp_reg_list (&input_line_pointer, &start, REGLIST_VFP_D);\n+  count = parse_vfp_reg_list (&input_line_pointer, &start, REGLIST_VFP_D,\n+\t\t\t      &partial_match);\n   if (count == FAIL)\n     {\n       as_bad (_(\"expected register list\"));\n@@ -4194,8 +4245,10 @@ s_arm_unwind_save_vfp (void)\n   int count;\n   unsigned int reg;\n   valueT op;\n+  bfd_boolean partial_match;\n \n-  count = parse_vfp_reg_list (&input_line_pointer, &reg, REGLIST_VFP_D);\n+  count = parse_vfp_reg_list (&input_line_pointer, &reg, REGLIST_VFP_D,\n+\t\t\t      &partial_match);\n   if (count == FAIL)\n     {\n       as_bad (_(\"expected register list\"));\n@@ -6585,6 +6638,7 @@ enum operand_parse_code\n   OP_VRSDLST,   /* VFP single or double-precision register list (& quad) */\n   OP_NRDLST,    /* Neon double-precision register list (d0-d31, qN aliases) */\n   OP_NSTRLST,   /* Neon element/structure list */\n+  OP_VRSDVLST,  /* VFP single or double-precision register list and VPR */\n \n   OP_RNDQ_I0,   /* Neon D or Q reg, or immediate zero.  */\n   OP_RVSD_I0,\t/* VFP S or D reg, or immediate zero.  */\n@@ -6694,6 +6748,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n   enum arm_reg_type rtype;\n   parse_operand_result result;\n   unsigned int op_parse_code;\n+  bfd_boolean partial_match;\n \n #define po_char_or_fail(chr)\t\t\t\\\n   do\t\t\t\t\t\t\\\n@@ -7218,29 +7273,43 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \t  break;\n \n \tcase OP_VRSLST:\n-\t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_S);\n+\t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_S,\n+\t\t\t\t    &partial_match);\n \t  break;\n \n \tcase OP_VRDLST:\n-\t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_D);\n+\t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg, REGLIST_VFP_D,\n+\t\t\t\t    &partial_match);\n \t  break;\n \n \tcase OP_VRSDLST:\n \t  /* Allow Q registers too.  */\n \t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,\n-\t\t\t\t    REGLIST_NEON_D);\n+\t\t\t\t    REGLIST_NEON_D, &partial_match);\n \t  if (val == FAIL)\n \t    {\n \t      inst.error = NULL;\n \t      val = parse_vfp_reg_list (&str, &inst.operands[i].reg,\n-\t\t\t\t\tREGLIST_VFP_S);\n+\t\t\t\t\tREGLIST_VFP_S, &partial_match);\n+\t      inst.operands[i].issingle = 1;\n+\t    }\n+\t  break;\n+\n+\tcase OP_VRSDVLST:\n+\t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,\n+\t\t\t\t    REGLIST_VFP_D_VPR, &partial_match);\n+\t  if (val == FAIL && !partial_match)\n+\t    {\n+\t      inst.error = NULL;\n+\t      val = parse_vfp_reg_list (&str, &inst.operands[i].reg,\n+\t\t\t\t\tREGLIST_VFP_S_VPR, &partial_match);\n \t      inst.operands[i].issingle = 1;\n \t    }\n \t  break;\n \n \tcase OP_NRDLST:\n \t  val = parse_vfp_reg_list (&str, &inst.operands[i].reg,\n-\t\t\t\t    REGLIST_NEON_D);\n+\t\t\t\t    REGLIST_NEON_D, &partial_match);\n \t  break;\n \n \tcase OP_NSTRLST:\n@@ -7344,6 +7413,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \tcase OP_VRSLST:\n \tcase OP_VRDLST:\n \tcase OP_VRSDLST:\n+\tcase OP_VRSDVLST:\n \tcase OP_NRDLST:\n \tcase OP_NSTRLST:\n \t  if (val == FAIL)\n@@ -12814,6 +12884,24 @@ do_t_clrm (void)\n     }\n }\n \n+static void\n+do_t_vscclrm (void)\n+{\n+  if (inst.operands[0].issingle)\n+    {\n+      inst.instruction |= (inst.operands[0].reg & 0x1) << 22;\n+      inst.instruction |= (inst.operands[0].reg & 0x1e) << 11;\n+      inst.instruction |= inst.operands[0].imm;\n+    }\n+  else\n+    {\n+      inst.instruction |= (inst.operands[0].reg & 0x10) << 18;\n+      inst.instruction |= (inst.operands[0].reg & 0xf) << 12;\n+      inst.instruction |= 1 << 8;\n+      inst.instruction |= inst.operands[0].imm << 1;\n+    }\n+}\n+\n static void\n do_t_rbit (void)\n {\n@@ -21889,7 +21977,8 @@ static const struct asm_opcode insns[] =\n  toU(\"wls\", _wls, 3, (LR, RRnpcsp, EXP), t_loloop),\n  toU(\"le\",  _le,  2, (oLR, EXP),\t t_loloop),\n \n- ToC(\"clrm\",\te89f0000, 1, (CLRMLST),  t_clrm)\n+ ToC(\"clrm\",\te89f0000, 1, (CLRMLST),  t_clrm),\n+ ToC(\"vscclrm\",\tec9f0a00, 1, (VRSDVLST), t_vscclrm)\n };\n #undef ARM_VARIANT\n #undef THUMB_VARIANT"
    },
    {
      "sha": "b64937d27f2af469daac5e3feb9167dccde0a986",
      "filename": "gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.l",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.l?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -2,3 +2,7 @@\n [^:]*:6: Error: r0-r12, lr or APSR expected -- `clrm {}'\n [^:]*:7: Error: r0-r12, lr or APSR expected -- `clrm {sp}'\n [^:]*:8: Error: r0-r12, lr or APSR expected -- `clrm {pc}'\n+[^:]*:10: Error: VFP single precision register or VPR expected -- `vscclrm {}'\n+[^:]*:11: Error: VPR expected last -- `vscclrm {s0}'\n+[^:]*:12: Error: VFP single precision register or VPR expected -- `vscclrm {s1,d1,VPR}'\n+[^:]*:13: Error: VFP single precision register expected -- `vscclrm {s1-d1,VPR}'"
    },
    {
      "sha": "f4baefe73f84a0c93a9ab992b80a9f0b3644d051",
      "filename": "gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.s",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/archv8m_1m-cmse-main-bad.s?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -6,3 +6,8 @@ T:\n clrm {} @ Rejects empty list\n clrm {sp} @ Rejects SP in list\n clrm {pc} @ Reject PC in list\n+\n+vscclrm {} @ Rejects empty list\n+vscclrm {s0} @ Rejects list without VPR\n+vscclrm {s1, d1, VPR} @ Reject mix of single and double-precision VFP registers\n+vscclrm {s1-d1, VPR} @ Likewise when using a range"
    },
    {
      "sha": "866adc9cb0db7a8c0f6061c3829ac07f3d5233f3",
      "filename": "gas/testsuite/gas/arm/archv8m_1m-cmse-main.d",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/archv8m_1m-cmse-main.d?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -11,4 +11,13 @@ Disassembly of section .text:\n 0+.* <[^>]*> e89f 8008 \tclrm\t{r3, APSR}\n 0+.* <[^>]*> bf08      \tit\teq\n 0+.* <[^>]*> e89f 0010 \tclrmeq\t{r4}\n+0+.* <[^>]*> ec9f 0b00 \tvscclrm\t{VPR}\n+0+.* <[^>]*> ec9f fa01 \tvscclrm\t{s30, VPR}\n+0+.* <[^>]*> ec9f eb02 \tvscclrm\t{d14, VPR}\n+0+.* <[^>]*> ecdf 0a04 \tvscclrm\t{s1-s4, VPR}\n+0+.* <[^>]*> ec9f 1b08 \tvscclrm\t{d1-d4, VPR}\n+0+.* <[^>]*> ec9f 0a20 \tvscclrm\t{s0-s31, VPR}\n+0+.* <[^>]*> ec9f 0b20 \tvscclrm\t{d0-d15, VPR}\n+0+.* <[^>]*> bf18      \tit\tne\n+0+.* <[^>]*> ecdf 1a01 \tvscclrmne\t{s3, VPR}\n #..."
    },
    {
      "sha": "f4df2dbb2f7666c4c762a9b62463d809ba91577e",
      "filename": "gas/testsuite/gas/arm/archv8m_1m-cmse-main.s",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/gas/testsuite/gas/arm/archv8m_1m-cmse-main.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/archv8m_1m-cmse-main.s?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -7,3 +7,14 @@ clrm {r0, r2} @ Accepts list without APSR\n clrm {APSR} @ Accepts APSR alone\n clrm {r3, APSR} @ Accepts core register and APSR together\n clrmeq {r4} @ Accepts conditional execution\n+\n+vscclrm {VPR} @ Accepts list with only VPR\n+vscclrm {s30, VPR} @ Accept single-precision VFP register and VPR together\n+vscclrm {d14, VPR} @ Likewise for double-precision VFP register\n+vscclrm {s1-s4, VPR} @ Accept range of single-precision VFP registers\n+\t\t     @ and VPR together\n+vscclrm {d1-d4, VPR} @ Likewise for double-precision VFP registers\n+vscclrm {s0-s31, VPR} @ Accept all single-precision VFP registers and VPR\n+\t\t      @ together\n+vscclrm {d0-d15, VPR} @ Likewise for double-precision VFP registers\n+vscclrmne {s3, VPR} @ Accepts conditional execution"
    },
    {
      "sha": "7b330c7d099b9c1735b8f5502b0d57fea68c1eae",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -1,3 +1,9 @@\n+2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* arm-dis.c (coprocessor_opcodes): Document new %C format control code.\n+\tAdd new entries for VSCCLRM instruction.\n+\t(print_insn_coprocessor): Handle new %C format control code.\n+\n 2019-04-15  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* arm-dis.c (enum isa): New enum."
    },
    {
      "sha": "ea053a32fd0a710616981d99814c77911f3f145b",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=efd6b3591b4bc8440f4145dfc0e6dbfc0545f7d8",
      "patch": "@@ -109,6 +109,7 @@ struct opcode16\n                           UNPREDICTABLE if not AL in Thumb)\n    %A\t\t\tprint address for ldc/stc/ldf/stf instruction\n    %B\t\t\tprint vstm/vldm register list\n+   %C\t\t\tprint vscclrm register list\n    %I                   print cirrus signed shift immediate: bits 0..3|4..6\n    %F\t\t\tprint the COUNT field of a LFM/SFM instruction.\n    %P\t\t\tprint floating point precision in arithmetic insn\n@@ -425,6 +426,12 @@ static const struct sopcode32 coprocessor_opcodes[] =\n   {ANY, ARM_FEATURE_COPROC (FPU_FPA_EXT_V2),\n     0x0c100200, 0x0e100f00, \"lfm%c\\t%12-14f, %F, %A\"},\n \n+  /* Armv8.1-M Mainline instructions.  */\n+  {T32, ARM_FEATURE_CORE_HIGH (ARM_EXT2_V8_1M_MAIN),\n+    0xec9f0b00, 0xffbf0f01, \"vscclrm%c\\t%C\"},\n+  {T32, ARM_FEATURE_CORE_HIGH (ARM_EXT2_V8_1M_MAIN),\n+    0xec9f0a00, 0xffbf0f00, \"vscclrm%c\\t%C\"},\n+\n   /* ARMv8-M Mainline Security Extensions instructions.  */\n   {ANY, ARM_FEATURE_CORE_HIGH (ARM_EXT2_V8M_MAIN),\n     0xec300a00, 0xfff0ffff, \"vlldm\\t%16-19r\"},\n@@ -3642,6 +3649,31 @@ print_insn_coprocessor (bfd_vma pc,\n \t\t  }\n \t\t  break;\n \n+\t\tcase 'C':\n+\t\t  {\n+\t\t    bfd_boolean single = ((given >> 8) & 1) == 0;\n+\t\t    char reg_prefix = single ? 's' : 'd';\n+\t\t    int Dreg = (given >> 22) & 0x1;\n+\t\t    int Vdreg = (given >> 12) & 0xf;\n+\t\t    int reg = single ? ((Vdreg << 1) | Dreg)\n+\t\t\t\t     : ((Dreg << 4) | Vdreg);\n+\t\t    int num = (given >> (single ? 0 : 1)) & 0x7f;\n+\t\t    int maxreg = single ? 31 : 15;\n+\t\t    int topreg = reg + num - 1;\n+\n+\t\t    if (!num)\n+\t\t      func (stream, \"{VPR}\");\n+\t\t    else if (num == 1)\n+\t\t      func (stream, \"{%c%d, VPR}\", reg_prefix, reg);\n+\t\t    else if (topreg > maxreg)\n+\t\t      func (stream, \"{%c%d-<overflow reg d%d, VPR}\",\n+\t\t\t    reg_prefix, reg, single ? topreg >> 1 : topreg);\n+\t\t    else\n+\t\t      func (stream, \"{%c%d-%c%d, VPR}\", reg_prefix, reg,\n+\t\t\t    reg_prefix, topreg);\n+\t\t  }\n+\t\t  break;\n+\n \t\tcase 'u':\n \t\t  if (cond != COND_UNCOND)\n \t\t    is_unpredictable = TRUE;"
    }
  ]
}