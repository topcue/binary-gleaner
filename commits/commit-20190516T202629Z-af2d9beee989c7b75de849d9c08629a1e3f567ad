{
  "sha": "af2d9beee989c7b75de849d9c08629a1e3f567ad",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWYyZDliZWVlOTg5YzdiNzVkZTg0OWQ5YzA4NjI5YTFlM2Y1NjdhZA==",
  "commit": {
    "author": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-05-16T19:58:55Z"
    },
    "committer": {
      "name": "Sergio Durigan Junior",
      "email": "sergiodj@redhat.com",
      "date": "2019-05-16T20:26:29Z"
    },
    "message": "Bool-ify stap-probe.c and stap-related code on i386-tdep.c\n\nThis simple patch converts a bunch of \"int\"s to \"bool\" on stap-probe.c\nand on the stap-related code present on i386-tdep.c.\n\nPushed as obvious (+ I'm the maintainer of this code).\n\ngdb/ChangeLog:\n2019-05-16  Sergio Durigan Junior  <sergiodj@redhat.com>\n\n\t* i386-tdep.c (i386_stap_parse_special_token_triplet): Change\n\treturn type to 'bool'.  Adjust comment.  Use 'bool' when\n\tappropriate.\n\t(i386_stap_parse_special_token_three_arg_disp): Likewise.\n\t* stap-probe.c (stap_parse_argument_1): Likewise.\n\t(stap_is_operator): Likewise.\n\t(stap_is_generic_prefix): Likewise.\n\t(stap_is_register_prefix): Likewise.\n\t(stap_is_register_indirection_prefix): Likewise.\n\t(stap_is_integer_prefix): Likewise.\n\t(stap_generic_check_suffix): Likewise.\n\t(stap_check_integer_suffix): Likewise.\n\t(stap_check_register_suffix): Likewise.\n\t(stap_check_register_indirection_suffix): Likewise.\n\t(stap_parse_register_operand): Likewise.\n\t(stap_parse_single_operand): Likewise.\n\t(stap_parse_argument_1): Likewise.\n\t(stap_probe::get_argument_count): Likewise.\n\t(stap_is_operator): Likewise.",
    "tree": {
      "sha": "7c56817fa8d548f4d6ace1456f1285370a63d943",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7c56817fa8d548f4d6ace1456f1285370a63d943"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/af2d9beee989c7b75de849d9c08629a1e3f567ad",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af2d9beee989c7b75de849d9c08629a1e3f567ad",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/af2d9beee989c7b75de849d9c08629a1e3f567ad",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af2d9beee989c7b75de849d9c08629a1e3f567ad/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "61c9c4212daa0be96503b9069da387aebf9cba04",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/61c9c4212daa0be96503b9069da387aebf9cba04",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/61c9c4212daa0be96503b9069da387aebf9cba04"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 103,
    "deletions": 80
  },
  "files": [
    {
      "sha": "8d40fc95ea91cddd5a8d1989719e9736fdd97cf2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=af2d9beee989c7b75de849d9c08629a1e3f567ad",
      "patch": "@@ -1,3 +1,25 @@\n+2019-05-16  Sergio Durigan Junior  <sergiodj@redhat.com>\n+\n+\t* i386-tdep.c (i386_stap_parse_special_token_triplet): Change\n+\treturn type to 'bool'.  Adjust comment.  Use 'bool' when\n+\tappropriate.\n+\t(i386_stap_parse_special_token_three_arg_disp): Likewise.\n+\t* stap-probe.c (stap_parse_argument_1): Likewise.\n+\t(stap_is_operator): Likewise.\n+\t(stap_is_generic_prefix): Likewise.\n+\t(stap_is_register_prefix): Likewise.\n+\t(stap_is_register_indirection_prefix): Likewise.\n+\t(stap_is_integer_prefix): Likewise.\n+\t(stap_generic_check_suffix): Likewise.\n+\t(stap_check_integer_suffix): Likewise.\n+\t(stap_check_register_suffix): Likewise.\n+\t(stap_check_register_indirection_suffix): Likewise.\n+\t(stap_parse_register_operand): Likewise.\n+\t(stap_parse_single_operand): Likewise.\n+\t(stap_parse_argument_1): Likewise.\n+\t(stap_probe::get_argument_count): Likewise.\n+\t(stap_is_operator): Likewise.\n+\n 2019-05-16  Tom Tromey  <tromey@adacore.com>\n \n \t* darwin-nat.c (thread_info_from_private_thread_info): Add struct"
    },
    {
      "sha": "8990583d8721427d51098fb1b9b347b1af73ea1e",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=af2d9beee989c7b75de849d9c08629a1e3f567ad",
      "patch": "@@ -4033,18 +4033,18 @@ i386_stap_is_single_operand (struct gdbarch *gdbarch, const char *s)\n    This function parses operands of the form `-8+3+1(%rbp)', which\n    must be interpreted as `*(-8 + 3 - 1 + (void *) $eax)'.\n \n-   Return 1 if the operand was parsed successfully, zero\n+   Return true if the operand was parsed successfully, false\n    otherwise.  */\n \n-static int\n+static bool\n i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t\t\t\t       struct stap_parse_info *p)\n {\n   const char *s = p->arg;\n \n   if (isdigit (*s) || *s == '-' || *s == '+')\n     {\n-      int got_minus[3];\n+      bool got_minus[3];\n       int i;\n       long displacements[3];\n       const char *start;\n@@ -4053,65 +4053,65 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n       struct stoken str;\n       char *endp;\n \n-      got_minus[0] = 0;\n+      got_minus[0] = false;\n       if (*s == '+')\n \t++s;\n       else if (*s == '-')\n \t{\n \t  ++s;\n-\t  got_minus[0] = 1;\n+\t  got_minus[0] = true;\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn 0;\n+\treturn false;\n \n       displacements[0] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '+' && *s != '-')\n \t{\n \t  /* We are not dealing with a triplet.  */\n-\t  return 0;\n+\t  return false;\n \t}\n \n-      got_minus[1] = 0;\n+      got_minus[1] = false;\n       if (*s == '+')\n \t++s;\n       else\n \t{\n \t  ++s;\n-\t  got_minus[1] = 1;\n+\t  got_minus[1] = true;\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn 0;\n+\treturn false;\n \n       displacements[1] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '+' && *s != '-')\n \t{\n \t  /* We are not dealing with a triplet.  */\n-\t  return 0;\n+\t  return false;\n \t}\n \n-      got_minus[2] = 0;\n+      got_minus[2] = false;\n       if (*s == '+')\n \t++s;\n       else\n \t{\n \t  ++s;\n-\t  got_minus[2] = 1;\n+\t  got_minus[2] = true;\n \t}\n \n       if (!isdigit ((unsigned char) *s))\n-\treturn 0;\n+\treturn false;\n \n       displacements[2] = strtol (s, &endp, 10);\n       s = endp;\n \n       if (*s != '(' || s[1] != '%')\n-\treturn 0;\n+\treturn false;\n \n       s += 2;\n       start = s;\n@@ -4120,7 +4120,7 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \t++s;\n \n       if (*s++ != ')')\n-\treturn 0;\n+\treturn false;\n \n       len = s - start - 1;\n       regname = (char *) alloca (len + 1);\n@@ -4167,10 +4167,10 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n \n       p->arg = s;\n \n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Helper function for i386_stap_parse_special_token.\n@@ -4179,20 +4179,20 @@ i386_stap_parse_special_token_triplet (struct gdbarch *gdbarch,\n    (register index * size) + offset', as represented in\n    `(%rcx,%rax,8)', or `[OFFSET](BASE_REG,INDEX_REG[,SIZE])'.\n \n-   Return 1 if the operand was parsed successfully, zero\n+   Return true if the operand was parsed successfully, false\n    otherwise.  */\n \n-static int\n+static bool\n i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t\t\t\t\t      struct stap_parse_info *p)\n {\n   const char *s = p->arg;\n \n   if (isdigit (*s) || *s == '(' || *s == '-' || *s == '+')\n     {\n-      int offset_minus = 0;\n+      bool offset_minus = false;\n       long offset = 0;\n-      int size_minus = 0;\n+      bool size_minus = false;\n       long size = 0;\n       const char *start;\n       char *base;\n@@ -4206,11 +4206,11 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n       else if (*s == '-')\n \t{\n \t  ++s;\n-\t  offset_minus = 1;\n+\t  offset_minus = true;\n \t}\n \n       if (offset_minus && !isdigit (*s))\n-\treturn 0;\n+\treturn false;\n \n       if (isdigit (*s))\n \t{\n@@ -4221,7 +4221,7 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t}\n \n       if (*s != '(' || s[1] != '%')\n-\treturn 0;\n+\treturn false;\n \n       s += 2;\n       start = s;\n@@ -4230,7 +4230,7 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t++s;\n \n       if (*s != ',' || s[1] != '%')\n-\treturn 0;\n+\treturn false;\n \n       len_base = s - start;\n       base = (char *) alloca (len_base + 1);\n@@ -4257,7 +4257,7 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t       index, p->saved_arg);\n \n       if (*s != ',' && *s != ')')\n-\treturn 0;\n+\treturn false;\n \n       if (*s == ',')\n \t{\n@@ -4269,14 +4269,14 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \t  else if (*s == '-')\n \t    {\n \t      ++s;\n-\t      size_minus = 1;\n+\t      size_minus = true;\n \t    }\n \n \t  size = strtol (s, &endp, 10);\n \t  s = endp;\n \n \t  if (*s != ')')\n-\t    return 0;\n+\t    return false;\n \t}\n \n       ++s;\n@@ -4330,10 +4330,10 @@ i386_stap_parse_special_token_three_arg_disp (struct gdbarch *gdbarch,\n \n       p->arg = s;\n \n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Implementation of `gdbarch_stap_parse_special_token', as defined in"
    },
    {
      "sha": "89cd780747ea0a7ba193c5761513a1c31e22daa6",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 50,
      "deletions": 49,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af2d9beee989c7b75de849d9c08629a1e3f567ad/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=af2d9beee989c7b75de849d9c08629a1e3f567ad",
      "patch": "@@ -257,14 +257,14 @@ enum stap_operand_prec\n   STAP_OPERAND_PREC_MUL\n };\n \n-static void stap_parse_argument_1 (struct stap_parse_info *p, int has_lhs,\n+static void stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n \t\t\t\t   enum stap_operand_prec prec);\n \n static void stap_parse_argument_conditionally (struct stap_parse_info *p);\n \n-/* Returns 1 if *S is an operator, zero otherwise.  */\n+/* Returns true if *S is an operator, false otherwise.  */\n \n-static int stap_is_operator (const char *op);\n+static bool stap_is_operator (const char *op);\n \n static void\n show_stapexpressiondebug (struct ui_file *file, int from_tty,\n@@ -474,9 +474,9 @@ stap_get_expected_argument_type (struct gdbarch *gdbarch,\n \n    This function does a case-insensitive match.\n \n-   Return 1 if any prefix has been found, zero otherwise.  */\n+   Return true if any prefix has been found, false otherwise.  */\n \n-static int\n+static bool\n stap_is_generic_prefix (struct gdbarch *gdbarch, const char *s,\n \t\t\tconst char **r, const char *const *prefixes)\n {\n@@ -487,7 +487,7 @@ stap_is_generic_prefix (struct gdbarch *gdbarch, const char *s,\n       if (r != NULL)\n \t*r = \"\";\n \n-      return 1;\n+      return true;\n     }\n \n   for (p = prefixes; *p != NULL; ++p)\n@@ -496,16 +496,16 @@ stap_is_generic_prefix (struct gdbarch *gdbarch, const char *s,\n \tif (r != NULL)\n \t  *r = *p;\n \n-\treturn 1;\n+\treturn true;\n       }\n \n-  return 0;\n+  return false;\n }\n \n-/* Return 1 if S points to a register prefix, zero otherwise.  For a\n-   description of the arguments, look at stap_is_generic_prefix.  */\n+/* Return true if S points to a register prefix, false otherwise.  For\n+   a description of the arguments, look at stap_is_generic_prefix.  */\n \n-static int\n+static bool\n stap_is_register_prefix (struct gdbarch *gdbarch, const char *s,\n \t\t\t const char **r)\n {\n@@ -514,11 +514,11 @@ stap_is_register_prefix (struct gdbarch *gdbarch, const char *s,\n   return stap_is_generic_prefix (gdbarch, s, r, t);\n }\n \n-/* Return 1 if S points to a register indirection prefix, zero\n+/* Return true if S points to a register indirection prefix, false\n    otherwise.  For a description of the arguments, look at\n    stap_is_generic_prefix.  */\n \n-static int\n+static bool\n stap_is_register_indirection_prefix (struct gdbarch *gdbarch, const char *s,\n \t\t\t\t     const char **r)\n {\n@@ -527,15 +527,15 @@ stap_is_register_indirection_prefix (struct gdbarch *gdbarch, const char *s,\n   return stap_is_generic_prefix (gdbarch, s, r, t);\n }\n \n-/* Return 1 if S points to an integer prefix, zero otherwise.  For a\n-   description of the arguments, look at stap_is_generic_prefix.\n+/* Return true if S points to an integer prefix, false otherwise.  For\n+   a description of the arguments, look at stap_is_generic_prefix.\n \n    This function takes care of analyzing whether we are dealing with\n    an expected integer prefix, or, if there is no integer prefix to be\n    expected, whether we are dealing with a digit.  It does a\n    case-insensitive match.  */\n \n-static int\n+static bool\n stap_is_integer_prefix (struct gdbarch *gdbarch, const char *s,\n \t\t\tconst char **r)\n {\n@@ -549,7 +549,7 @@ stap_is_integer_prefix (struct gdbarch *gdbarch, const char *s,\n       if (r != NULL)\n \t*r = \"\";\n \n-      return isdigit (*s);\n+      return isdigit (*s) > 0;\n     }\n \n   for (p = t; *p != NULL; ++p)\n@@ -567,35 +567,35 @@ stap_is_integer_prefix (struct gdbarch *gdbarch, const char *s,\n \t  if (r != NULL)\n \t    *r = *p;\n \n-\t  return 1;\n+\t  return true;\n \t}\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Helper function to check for a generic list of suffixes.  If we are\n    not expecting any suffixes, then it just returns 1.  If we are\n-   expecting at least one suffix, then it returns 1 if a suffix has\n-   been found, zero otherwise.  GDBARCH is the current gdbarch being\n+   expecting at least one suffix, then it returns true if a suffix has\n+   been found, false otherwise.  GDBARCH is the current gdbarch being\n    used.  S is the expression being analyzed.  If R is not NULL, it\n    will be used to return the found suffix.  SUFFIXES is the list of\n    expected suffixes.  This function does a case-insensitive\n    match.  */\n \n-static int\n+static bool\n stap_generic_check_suffix (struct gdbarch *gdbarch, const char *s,\n \t\t\t   const char **r, const char *const *suffixes)\n {\n   const char *const *p;\n-  int found = 0;\n+  bool found = false;\n \n   if (suffixes == NULL)\n     {\n       if (r != NULL)\n \t*r = \"\";\n \n-      return 1;\n+      return true;\n     }\n \n   for (p = suffixes; *p != NULL; ++p)\n@@ -604,18 +604,18 @@ stap_generic_check_suffix (struct gdbarch *gdbarch, const char *s,\n \tif (r != NULL)\n \t  *r = *p;\n \n-\tfound = 1;\n+\tfound = true;\n \tbreak;\n       }\n \n   return found;\n }\n \n-/* Return 1 if S points to an integer suffix, zero otherwise.  For a\n-   description of the arguments, look at\n+/* Return true if S points to an integer suffix, false otherwise.  For\n+   a description of the arguments, look at\n    stap_generic_check_suffix.  */\n \n-static int\n+static bool\n stap_check_integer_suffix (struct gdbarch *gdbarch, const char *s,\n \t\t\t   const char **r)\n {\n@@ -624,11 +624,11 @@ stap_check_integer_suffix (struct gdbarch *gdbarch, const char *s,\n   return stap_generic_check_suffix (gdbarch, s, r, p);\n }\n \n-/* Return 1 if S points to a register suffix, zero otherwise.  For a\n-   description of the arguments, look at\n+/* Return true if S points to a register suffix, false otherwise.  For\n+   a description of the arguments, look at\n    stap_generic_check_suffix.  */\n \n-static int\n+static bool\n stap_check_register_suffix (struct gdbarch *gdbarch, const char *s,\n \t\t\t    const char **r)\n {\n@@ -637,11 +637,11 @@ stap_check_register_suffix (struct gdbarch *gdbarch, const char *s,\n   return stap_generic_check_suffix (gdbarch, s, r, p);\n }\n \n-/* Return 1 if S points to a register indirection suffix, zero\n+/* Return true if S points to a register indirection suffix, false\n    otherwise.  For a description of the arguments, look at\n    stap_generic_check_suffix.  */\n \n-static int\n+static bool\n stap_check_register_indirection_suffix (struct gdbarch *gdbarch, const char *s,\n \t\t\t\t\tconst char **r)\n {\n@@ -674,10 +674,11 @@ stap_parse_register_operand (struct stap_parse_info *p)\n {\n   /* Simple flag to indicate whether we have seen a minus signal before\n      certain number.  */\n-  int got_minus = 0;\n+  bool got_minus = false;\n   /* Flags to indicate whether this register access is being displaced and/or\n      indirected.  */\n-  int disp_p = 0, indirect_p = 0;\n+  bool disp_p = false;\n+  bool indirect_p = false;\n   struct gdbarch *gdbarch = p->gdbarch;\n   /* Needed to generate the register name as a part of an expression.  */\n   struct stoken str;\n@@ -705,7 +706,7 @@ stap_parse_register_operand (struct stap_parse_info *p)\n \n   if (*p->arg == '-')\n     {\n-      got_minus = 1;\n+      got_minus = true;\n       ++p->arg;\n     }\n \n@@ -715,7 +716,7 @@ stap_parse_register_operand (struct stap_parse_info *p)\n       long displacement;\n       char *endp;\n \n-      disp_p = 1;\n+      disp_p = true;\n       displacement = strtol (p->arg, &endp, 10);\n       p->arg = endp;\n \n@@ -731,7 +732,7 @@ stap_parse_register_operand (struct stap_parse_info *p)\n   /* Getting rid of register indirection prefix.  */\n   if (stap_is_register_indirection_prefix (gdbarch, p->arg, &reg_ind_prefix))\n     {\n-      indirect_p = 1;\n+      indirect_p = true;\n       p->arg += strlen (reg_ind_prefix);\n     }\n \n@@ -854,7 +855,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n       char c = *p->arg;\n       /* We use this variable to do a lookahead.  */\n       const char *tmp = p->arg;\n-      int has_digit = 0;\n+      bool has_digit = false;\n \n       /* Skipping signal.  */\n       ++tmp;\n@@ -879,7 +880,7 @@ stap_parse_single_operand (struct stap_parse_info *p)\n \t     called below ('stap_parse_argument_conditionally' or\n \t     'stap_parse_register_operand').  */\n \t  ++tmp;\n-\t  has_digit = 1;\n+\t  has_digit = true;\n \t}\n \n       if (has_digit && stap_is_register_indirection_prefix (gdbarch, tmp,\n@@ -1023,7 +1024,7 @@ stap_parse_argument_conditionally (struct stap_parse_info *p)\n    better understand what this function does.  */\n \n static void\n-stap_parse_argument_1 (struct stap_parse_info *p, int has_lhs,\n+stap_parse_argument_1 (struct stap_parse_info *p, bool has_lhs,\n \t\t       enum stap_operand_prec prec)\n {\n   /* This is an operator-precedence parser.\n@@ -1295,15 +1296,15 @@ stap_probe::get_argument_count (struct frame_info *frame)\n \tthis->parse_arguments (gdbarch);\n       else\n \t{\n-\t  static int have_warned_stap_incomplete = 0;\n+\t  static bool have_warned_stap_incomplete = false;\n \n \t  if (!have_warned_stap_incomplete)\n \t    {\n \t      warning (_(\n \"The SystemTap SDT probe support is not fully implemented on this target;\\n\"\n \"you will not be able to inspect the arguments of the probes.\\n\"\n \"Please report a bug against GDB requesting a port to this target.\"));\n-\t      have_warned_stap_incomplete = 1;\n+\t      have_warned_stap_incomplete = true;\n \t    }\n \n \t  /* Marking the arguments as \"already parsed\".  */\n@@ -1315,13 +1316,13 @@ stap_probe::get_argument_count (struct frame_info *frame)\n   return m_parsed_args.size ();\n }\n \n-/* Return 1 if OP is a valid operator inside a probe argument, or zero\n-   otherwise.  */\n+/* Return true if OP is a valid operator inside a probe argument, or\n+   false otherwise.  */\n \n-static int\n+static bool\n stap_is_operator (const char *op)\n {\n-  int ret = 1;\n+  bool ret = true;\n \n   switch (*op)\n     {\n@@ -1340,12 +1341,12 @@ stap_is_operator (const char *op)\n \n     case '=':\n       if (op[1] != '=')\n-\tret = 0;\n+\tret = false;\n       break;\n \n     default:\n       /* We didn't find any operator.  */\n-      ret = 0;\n+      ret = false;\n     }\n \n   return ret;"
    }
  ]
}