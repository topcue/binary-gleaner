{
  "sha": "7aba54da426b9999085d8f84e7896b8afdbb9ca6",
  "node_id": "C_kwDOANOeidoAKDdhYmE1NGRhNDI2Yjk5OTkwODVkOGY4NGU3ODk2YjhhZmRiYjljYTY",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-09T22:19:05Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-15T01:50:13Z"
    },
    "message": "PowerPC64 @notoc in non-power10 code\n\nR_PPC64_REL24_P9NOTOC is a variant of R_PPC64_REL24_NOTOC for use on\n@notoc cals from non-power10 code in the rare case that using such a\nconstruct is useful.  R_PPC64_REL24_P9NOTOC will be emitted by gas\nrather than R_PPC64_REL24_NOTOC when @notoc is used in a branch\ninstruction if power10 instructions are not enabled at that point.\nThe new relocation tells the linker to not use power10 instructions on\nany stub emitted for that branch, unless overridden by\n--power10-stubs=yes.\n\nThe current linker heuristic of only generating power10 instructions\nfor stubs if power10-only relocations are detected, continues to be\nused.\n\ninclude/\n\t* elf/ppc64.h (R_PPC64_REL24_P9NOTOC): Define.\nbfd/\n\t* reloc.c (BFD_RELOC_PPC64_REL24_P9NOTOC): Define.\n\t* elf64-ppc.c (ppc64_elf_howto_raw): Add entry for new reloc.\n\t(ppc64_elf_reloc_type_lookup): Handle it.\n\t(enum ppc_stub_type): Delete.\n\t(enum ppc_stub_main_type, ppc_stub_sub_type): New.\n\t(struct ppc_stub_type): New.\n\t(struct ppc_stub_hash_entry): Use the above new type.\n\t(struct ppc_link_hash_table): Update stub_count.\n\t(is_branch_reloc, ppc64_elf_check_relocs),\n\t(toc_adjusting_stub_needed): Handle new reloc.\n\t(stub_hash_newfunc, select_alt_stub, ppc_merge_stub),\n\t(ppc_type_of_stub, plt_stub_size, build_plt_stub),\n\t(build_tls_get_addr_head, build_tls_get_addr_tail),\n\t(ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_size_stubs),\n\t(ppc64_elf_build_stubs, ppc64_elf_relocate_section): Handle new\n\treloc.  Modify stub handling to suit new scheme.\n\t* bfd-in2.h: Regenerate.\n\t* libbfd.h: Regenerate.\ngas/\n\t* config/tc-ppc.c (ppc_elf_suffix): When power10 is not enabled\n\treturn BFD_RELOC_PPC64_REL24_P9NOTOC for @notoc.\n\t(fixup_size, ppc_force_relocation, ppc_fix_adjustable): Handle\n\tBFD_RELOC_PPC64_REL24_P9NOTOC.\nld/\n\t* testsuite/ld-powerpc/callstub-2.s: Add .machine power10.",
    "tree": {
      "sha": "58612237fa11e0a5f5a9c001163a4c979c8482d8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/58612237fa11e0a5f5a9c001163a4c979c8482d8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7aba54da426b9999085d8f84e7896b8afdbb9ca6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7aba54da426b9999085d8f84e7896b8afdbb9ca6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7aba54da426b9999085d8f84e7896b8afdbb9ca6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7aba54da426b9999085d8f84e7896b8afdbb9ca6/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "64f5c8167b1bf098d7e054fb32a65bc252f9d18b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64f5c8167b1bf098d7e054fb32a65bc252f9d18b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/64f5c8167b1bf098d7e054fb32a65bc252f9d18b"
    }
  ],
  "stats": {
    "total": 754,
    "additions": 356,
    "deletions": 398
  },
  "files": [
    {
      "sha": "7b7a329cd6253aca34e527f8fe8710fe890e0550",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -2957,6 +2957,7 @@ instruction.  */\n   BFD_RELOC_PPC64_ADDR64_LOCAL,\n   BFD_RELOC_PPC64_ENTRY,\n   BFD_RELOC_PPC64_REL24_NOTOC,\n+  BFD_RELOC_PPC64_REL24_P9NOTOC,\n   BFD_RELOC_PPC64_D34,\n   BFD_RELOC_PPC64_D34_LO,\n   BFD_RELOC_PPC64_D34_HI30,"
    },
    {
      "sha": "8be7c31d14ea0357d47fd7f346167e7f9c4c319a",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 343,
      "deletions": 398,
      "changes": 741,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -371,6 +371,10 @@ static reloc_howto_type ppc64_elf_howto_raw[] =\n   HOW (R_PPC64_REL24_NOTOC, 2, 26, 0x03fffffc, 0, true, signed,\n        ppc64_elf_branch_reloc),\n \n+  /* Another variant, when p10 insns can't be used on stubs.  */\n+  HOW (R_PPC64_REL24_P9NOTOC, 2, 26, 0x03fffffc, 0, true, signed,\n+       ppc64_elf_branch_reloc),\n+\n   /* A relative 16 bit branch; the lower two bits must be zero.  */\n   HOW (R_PPC64_REL14, 2, 16, 0x0000fffc, 0, true, signed,\n        ppc64_elf_branch_reloc),\n@@ -1053,6 +1057,8 @@ ppc64_elf_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code)\n       break;\n     case BFD_RELOC_PPC64_REL24_NOTOC:\t\tr = R_PPC64_REL24_NOTOC;\n       break;\n+    case BFD_RELOC_PPC64_REL24_P9NOTOC:\t\tr = R_PPC64_REL24_P9NOTOC;\n+      break;\n     case BFD_RELOC_PPC_B16:\t\t\tr = R_PPC64_REL14;\n       break;\n     case BFD_RELOC_PPC_B16_BRTAKEN:\t\tr = R_PPC64_REL14_BRTAKEN;\n@@ -2884,7 +2890,7 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    Used to call a function in a shared library.  If it so happens that\n    the plt entry referenced crosses a 64k boundary, then an extra\n    \"addi %r11,%r11,xxx@toc@l\" will be inserted before the \"mtctr\".\n-   ppc_stub_plt_call_r2save starts with \"std %r2,40(%r1)\".\n+   An r2save variant starts with \"std %r2,40(%r1)\".\n    .\taddis\t%r11,%r2,xxx@toc@ha\n    .\tld\t%r12,xxx+0@toc@l(%r11)\n    .\tmtctr\t%r12\n@@ -2913,13 +2919,8 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    variants exist too, simpler for plt calls since a new toc pointer\n    and static chain are not loaded by the stub.  In addition, ELFv2\n    has some more complex stubs to handle calls marked with NOTOC\n-   relocs from functions where r2 is not a valid toc pointer.  These\n-   come in two flavours, the ones shown below, and _both variants that\n-   start with \"std %r2,24(%r1)\" to save r2 in the unlikely event that\n-   one call is from a function where r2 is used as the toc pointer but\n-   needs a toc adjusting stub for small-model multi-toc, and another\n-   call is from a function where r2 is not valid.\n-   ppc_stub_long_branch_notoc:\n+   relocs from functions where r2 is not a valid toc pointer.\n+   ppc_stub_long_branch_p9notoc:\n    .\tmflr\t%r12\n    .\tbcl\t20,31,1f\n    .  1:\n@@ -2929,7 +2930,7 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    .\taddi\t%r12,%r12,dest-1b@l\n    .\tb\tdest\n \n-   ppc_stub_plt_branch_notoc:\n+   ppc_stub_plt_branch_p9notoc:\n    .\tmflr\t%r12\n    .\tbcl\t20,31,1f\n    .  1:\n@@ -2944,7 +2945,7 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    .\tmtctr\t%r12\n    .\tbctr\n \n-   ppc_stub_plt_call_notoc:\n+   ppc_stub_plt_call_p9notoc:\n    .\tmflr\t%r12\n    .\tbcl\t20,31,1f\n    .  1:\n@@ -2988,9 +2989,7 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    .\tmtctr\t%r12\n    .\tbctr\n \n-   For a given stub group (a set of sections all using the same toc\n-   pointer value) there will be just one stub type used for any\n-   particular function symbol.  For example, if printf is called from\n+   Stub variants may be merged.  For example, if printf is called from\n    code with the tocsave optimization (ie. r2 saved in function\n    prologue) and therefore calls use a ppc_stub_plt_call linkage stub,\n    and from other code without the tocsave optimization requiring a\n@@ -3001,33 +3000,36 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    relocations.  These require a ppc_stub_plt_call_notoc linkage stub\n    to call an external function like printf.  If other calls to printf\n    require a ppc_stub_plt_call linkage stub then a single\n-   ppc_stub_plt_call_notoc linkage stub will be used for both types of\n-   call.  If other calls to printf require a ppc_stub_plt_call_r2save\n-   linkage stub then a single ppc_stub_plt_call_both linkage stub will\n-   be created and calls not requiring r2 to be saved will enter the\n-   stub after the r2 save instruction.  There is an analogous\n-   hierarchy of long branch and plt branch stubs for local call\n-   linkage.  */\n-\n-enum ppc_stub_type\n+   ppc_stub_plt_call_notoc linkage stub may be used for both types of\n+   call.  */\n+\n+enum ppc_stub_main_type\n {\n   ppc_stub_none,\n   ppc_stub_long_branch,\n-  ppc_stub_long_branch_r2off,\n-  ppc_stub_long_branch_notoc,\n-  ppc_stub_long_branch_both, /* r2off and notoc variants both needed.  */\n   ppc_stub_plt_branch,\n-  ppc_stub_plt_branch_r2off,\n-  ppc_stub_plt_branch_notoc,\n-  ppc_stub_plt_branch_both,\n   ppc_stub_plt_call,\n-  ppc_stub_plt_call_r2save,\n-  ppc_stub_plt_call_notoc,\n-  ppc_stub_plt_call_both,\n   ppc_stub_global_entry,\n   ppc_stub_save_res\n };\n \n+/* ppc_stub_long_branch, ppc_stub_plt_branch and ppc_stub_plt_call have\n+   these variations.  */\n+\n+enum ppc_stub_sub_type\n+{\n+  ppc_stub_toc,\n+  ppc_stub_notoc,\n+  ppc_stub_p9notoc\n+};\n+\n+struct ppc_stub_type\n+{\n+  ENUM_BITFIELD (ppc_stub_main_type) main : 3;\n+  ENUM_BITFIELD (ppc_stub_sub_type) sub : 2;\n+  unsigned int r2save : 1;\n+};\n+\n /* Information on stub grouping.  */\n struct map_stub\n {\n@@ -3056,7 +3058,7 @@ struct ppc_stub_hash_entry\n   /* Base hash table entry structure.  */\n   struct bfd_hash_entry root;\n \n-  enum ppc_stub_type stub_type;\n+  struct ppc_stub_type type;\n \n   /* Group information.  */\n   struct map_stub *group;\n@@ -3249,7 +3251,7 @@ struct ppc_link_hash_table\n   bfd_size_type got_reli_size;\n \n   /* Statistics.  */\n-  unsigned long stub_count[ppc_stub_global_entry];\n+  unsigned long stub_count[ppc_stub_save_res];\n \n   /* Number of stubs against global syms.  */\n   unsigned long stub_globals;\n@@ -3348,7 +3350,9 @@ stub_hash_newfunc (struct bfd_hash_entry *entry,\n \n       /* Initialize the local fields.  */\n       eh = (struct ppc_stub_hash_entry *) entry;\n-      eh->stub_type = ppc_stub_none;\n+      eh->type.main = ppc_stub_none;\n+      eh->type.sub = ppc_stub_toc;\n+      eh->type.r2save = 0;\n       eh->group = NULL;\n       eh->stub_offset = 0;\n       eh->target_value = 0;\n@@ -3717,24 +3721,33 @@ ppc_stub_name (const asection *input_section,\n }\n \n /* If mixing power10 with non-power10 code and --power10-stubs is not\n-   specified (or is auto) then calls using @notoc relocations that\n-   need a stub will utilize power10 instructions in the stub, and\n-   calls without @notoc relocations will not use power10 instructions.\n-   The two classes of stubs are stored in separate stub_hash_table\n-   entries having the same key string.  The two entries will always be\n-   adjacent on entry->root.next chain, even if hash table resizing\n-   occurs.  This function selects the correct entry to use.  */\n+   specified (or is auto) then there may be multiple stub types for any\n+   given symbol.  Up to three classes of stubs are stored in separate\n+   stub_hash_table entries having the same key string.  The entries\n+   will always be adjacent on entry->root.next chain, even if hash\n+   table resizing occurs.  This function selects the correct entry to\n+   use.  */\n \n static struct ppc_stub_hash_entry *\n-select_alt_stub (struct ppc_stub_hash_entry *entry, bool notoc)\n+select_alt_stub (struct ppc_stub_hash_entry *entry,\n+\t\t enum elf_ppc64_reloc_type r_type)\n {\n-  bool have_notoc;\n+  enum ppc_stub_sub_type subt;\n \n-  have_notoc = (entry->stub_type == ppc_stub_plt_call_notoc\n-\t\t|| entry->stub_type == ppc_stub_plt_branch_notoc\n-\t\t|| entry->stub_type == ppc_stub_long_branch_notoc);\n+  switch (r_type)\n+    {\n+    case R_PPC64_REL24_NOTOC:\n+      subt = ppc_stub_notoc;\n+      break;\n+    case R_PPC64_REL24_P9NOTOC:\n+      subt = ppc_stub_p9notoc;\n+      break;\n+    default:\n+      subt = ppc_stub_toc;\n+      break;\n+    }\n \n-  if (have_notoc != notoc)\n+  while (entry != NULL && entry->type.sub != subt)\n     {\n       const char *stub_name = entry->root.string;\n \n@@ -3792,11 +3805,7 @@ ppc_get_stub_entry (const asection *input_section,\n     }\n \n   if (stub_entry != NULL && htab->params->power10_stubs == -1)\n-    {\n-      bool notoc = ELF64_R_TYPE (rel->r_info) == R_PPC64_REL24_NOTOC;\n-\n-      stub_entry = select_alt_stub (stub_entry, notoc);\n-    }\n+    stub_entry = select_alt_stub (stub_entry, ELF64_R_TYPE (rel->r_info));\n \n   return stub_entry;\n }\n@@ -3854,6 +3863,75 @@ ppc_add_stub (const char *stub_name,\n   return stub_entry;\n }\n \n+/* A stub has already been created, but it may not be the required\n+   type.  We shouldn't be transitioning from plt_call to long_branch\n+   stubs or vice versa, but we might be upgrading from plt_call to\n+   plt_call with r2save for example.  */\n+\n+static bool\n+ppc_merge_stub (struct ppc_link_hash_table *htab,\n+\t\tstruct ppc_stub_hash_entry *stub_entry,\n+\t\tstruct ppc_stub_type stub_type,\n+\t\tenum elf_ppc64_reloc_type r_type)\n+{\n+  struct ppc_stub_type old_type = stub_entry->type;\n+\n+  if (old_type.main == ppc_stub_save_res)\n+    return true;\n+\n+  if (htab->params->power10_stubs == -1)\n+    {\n+      /* For --power10-stubs=auto, don't merge _notoc and other\n+\t varieties of stubs.  */\n+      struct ppc_stub_hash_entry *alt_stub;\n+\n+      alt_stub = select_alt_stub (stub_entry, r_type);\n+      if (alt_stub == NULL)\n+\t{\n+\t  alt_stub = ((struct ppc_stub_hash_entry *)\n+\t\t      stub_hash_newfunc (NULL,\n+\t\t\t\t\t &htab->stub_hash_table,\n+\t\t\t\t\t stub_entry->root.string));\n+\t  if (alt_stub == NULL)\n+\t    return false;\n+\n+\t  *alt_stub = *stub_entry;\n+\t  stub_entry->root.next = &alt_stub->root;\n+\n+\t  /* Sort notoc stubs first, then toc stubs, then p9notoc.\n+\t     Not that it matters, this just puts smaller stubs first.  */\n+\t  if (stub_type.sub == ppc_stub_notoc)\n+\t    alt_stub = stub_entry;\n+\t  else if (stub_type.sub == ppc_stub_p9notoc\n+\t\t   && alt_stub->root.next\n+\t\t   && alt_stub->root.next->string == alt_stub->root.string)\n+\t    {\n+\t      struct ppc_stub_hash_entry *next\n+\t\t= (struct ppc_stub_hash_entry *) alt_stub->root.next;\n+\t      alt_stub->type = next->type;\n+\t      alt_stub = next;\n+\t    }\n+\t  alt_stub->type = stub_type;\n+\t  return true;\n+\t}\n+      stub_entry = alt_stub;\n+    }\n+\n+  old_type = stub_entry->type;\n+  if (old_type.main == ppc_stub_plt_branch)\n+    old_type.main += ppc_stub_long_branch - ppc_stub_plt_branch;\n+\n+  if (old_type.main != stub_type.main\n+      || (old_type.sub != stub_type.sub\n+\t  && old_type.sub != ppc_stub_toc\n+\t  && stub_type.sub != ppc_stub_toc))\n+    abort ();\n+\n+  stub_entry->type.sub |= stub_type.sub;\n+  stub_entry->type.r2save |= stub_type.r2save;\n+  return true;\n+}\n+\n /* Create .got and .rela.got sections in ABFD, and .got in dynobj if\n    not already done.  */\n \n@@ -4575,6 +4653,7 @@ is_branch_reloc (enum elf_ppc64_reloc_type r_type)\n {\n   return (r_type == R_PPC64_REL24\n \t  || r_type == R_PPC64_REL24_NOTOC\n+\t  || r_type == R_PPC64_REL24_P9NOTOC\n \t  || r_type == R_PPC64_REL14\n \t  || r_type == R_PPC64_REL14_BRTAKEN\n \t  || r_type == R_PPC64_REL14_BRNTAKEN\n@@ -5031,6 +5110,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \n \tcase R_PPC64_REL24:\n \tcase R_PPC64_REL24_NOTOC:\n+\tcase R_PPC64_REL24_P9NOTOC:\n \trel24:\n \t  plt_list = ifunc;\n \t  if (h != NULL)\n@@ -10454,7 +10534,7 @@ ppc64_elf_hash_symbol (struct elf_link_hash_entry *h)\n \n /* Determine the type of stub needed, if any, for a call.  */\n \n-static inline enum ppc_stub_type\n+static inline enum ppc_stub_main_type\n ppc_type_of_stub (asection *input_sec,\n \t\t  const Elf_Internal_Rela *rel,\n \t\t  struct ppc_link_hash_entry **hash,\n@@ -10947,20 +11027,22 @@ plt_stub_size (struct ppc_link_hash_table *htab,\n {\n   unsigned size;\n \n-  if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)\n+  if (stub_entry->type.sub == ppc_stub_notoc)\n     {\n-      if (htab->params->power10_stubs != 0)\n-\tsize = 8 + size_power10_offset (off, odd);\n-      else\n-\tsize = 8 + size_offset (off - 8);\n-      if (stub_entry->stub_type > ppc_stub_plt_call_notoc)\n+      size = 8 + size_power10_offset (off, odd);\n+      if (stub_entry->type.r2save)\n+\tsize += 4;\n+    }\n+  else if (stub_entry->type.sub == ppc_stub_p9notoc)\n+    {\n+      size = 8 + size_offset (off - 8);\n+      if (stub_entry->type.r2save)\n \tsize += 4;\n     }\n   else\n     {\n       size = 12;\n-      if (ALWAYS_EMIT_R2SAVE\n-\t  || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+      if (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \tsize += 4;\n       if (PPC_HA (off) != 0)\n \tsize += 4;\n@@ -10986,15 +11068,13 @@ plt_stub_size (struct ppc_link_hash_table *htab,\n       if (!htab->params->no_tls_get_addr_regsave)\n \t{\n \t  size += 30 * 4;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t      || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t  if (stub_entry->type.r2save)\n \t    size += 4;\n \t}\n       else\n \t{\n \t  size += 7 * 4;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t      || stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t  if (stub_entry->type.r2save)\n \t    size += 6 * 4;\n \t}\n     }\n@@ -11033,7 +11113,7 @@ plt_stub_pad (struct ppc_link_hash_table *htab,\n   return 0;\n }\n \n-/* Build a .plt call stub.  */\n+/* Build a toc using .plt call stub.  */\n \n static inline bfd_byte *\n build_plt_stub (struct ppc_link_hash_table *htab,\n@@ -11069,8 +11149,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n \t    + htab->glink->output_offset\n \t    + htab->glink->output_section->vma);\n       from = (p - stub_entry->group->stub_sec->contents\n-\t      + 4 * (ALWAYS_EMIT_R2SAVE\n-\t\t     || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+\t      + 4 * (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \t      + 4 * (PPC_HA (offset) != 0)\n \t      + 4 * (PPC_HA (offset + 8 + 8 * plt_static_chain)\n \t\t     != PPC_HA (offset))\n@@ -11086,8 +11165,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n     {\n       if (r != NULL)\n \t{\n-\t  if (ALWAYS_EMIT_R2SAVE\n-\t      || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+\t  if (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \t    r[0].r_offset += 4;\n \t  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_HA);\n \t  r[1].r_offset = r[0].r_offset + 4;\n@@ -11115,8 +11193,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n \t\t}\n \t    }\n \t}\n-      if (ALWAYS_EMIT_R2SAVE\n-\t  || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+      if (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \tbfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p),\tp += 4;\n       if (plt_load_toc)\n \t{\n@@ -11151,8 +11228,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n     {\n       if (r != NULL)\n \t{\n-\t  if (ALWAYS_EMIT_R2SAVE\n-\t      || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+\t  if (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \t    r[0].r_offset += 4;\n \t  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);\n \t  if (plt_load_toc)\n@@ -11177,8 +11253,7 @@ build_plt_stub (struct ppc_link_hash_table *htab,\n \t\t}\n \t    }\n \t}\n-      if (ALWAYS_EMIT_R2SAVE\n-\t  || stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+      if (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save)\n \tbfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p),\tp += 4;\n       bfd_put_32 (obfd, LD_R12_0R2 | PPC_LO (offset), p),\tp += 4;\n       if (plt_load_toc\n@@ -11239,8 +11314,7 @@ build_tls_get_addr_head (struct ppc_link_hash_table *htab,\n \n   if (!htab->params->no_tls_get_addr_regsave)\n     p = tls_get_addr_prologue (obfd, p, htab);\n-  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n+  else if (stub_entry->type.r2save)\n     {\n       bfd_put_32 (obfd, MFLR_R0, p);\n       p += 4;\n@@ -11262,16 +11336,14 @@ build_tls_get_addr_tail (struct ppc_link_hash_table *htab,\n     {\n       bfd_put_32 (obfd, BCTRL, p - 4);\n \n-      if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t  || stub_entry->stub_type == ppc_stub_plt_call_both)\n+      if (stub_entry->type.r2save)\n \t{\n \t  bfd_put_32 (obfd, LD_R2_0R1 + STK_TOC (htab), p);\n \t  p += 4;\n \t}\n       p = tls_get_addr_epilogue (obfd, p, htab);\n     }\n-  else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n+  else if (stub_entry->type.r2save)\n     {\n       bfd_put_32 (obfd, BCTRL, p - 4);\n \n@@ -11339,8 +11411,7 @@ build_tls_get_addr_tail (struct ppc_link_hash_table *htab,\n \t  *eh++ = 65;\n \t  stub_entry->group->eh_size = eh - base;\n \t}\n-      else if (stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t       || stub_entry->stub_type == ppc_stub_plt_call_both)\n+      else if (stub_entry->type.r2save)\n \t{\n \t  unsigned int lr_used, delta;\n \n@@ -11529,11 +11600,10 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n   BFD_ASSERT (stub_entry->stub_offset >= stub_entry->group->stub_sec->size);\n   loc = stub_entry->group->stub_sec->contents + stub_entry->stub_offset;\n \n-  htab->stub_count[stub_entry->stub_type - 1] += 1;\n-  switch (stub_entry->stub_type)\n+  htab->stub_count[stub_entry->type.main - 1] += 1;\n+  if (stub_entry->type.main == ppc_stub_long_branch\n+      && stub_entry->type.sub == ppc_stub_toc)\n     {\n-    case ppc_stub_long_branch:\n-    case ppc_stub_long_branch_r2off:\n       /* Branches are relative.  This is where we are going to.  */\n       targ = (stub_entry->target_value\n \t      + stub_entry->target_section->output_offset\n@@ -11548,7 +11618,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       p = loc;\n       obfd = htab->params->stub_bfd;\n-      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)\n+      if (stub_entry->type.r2save)\n \t{\n \t  bfd_vma r2off = get_r2off (info, stub_entry);\n \n@@ -11595,10 +11665,10 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      && !use_global_in_relocs (htab, stub_entry, r, 1))\n \t    return false;\n \t}\n-      break;\n-\n-    case ppc_stub_plt_branch:\n-    case ppc_stub_plt_branch_r2off:\n+    }\n+  else if (stub_entry->type.main == ppc_stub_plt_branch\n+\t   && stub_entry->type.sub == ppc_stub_toc)\n+    {\n       br_entry = ppc_branch_hash_lookup (&htab->branch_hash_table,\n \t\t\t\t\t stub_entry->root.string + 9,\n \t\t\t\t\t false, false);\n@@ -11613,7 +11683,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       targ = (stub_entry->target_value\n \t      + stub_entry->target_section->output_offset\n \t      + stub_entry->target_section->output_section->vma);\n-      if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)\n+      if (!stub_entry->type.r2save)\n \ttarg += PPC64_LOCAL_ENTRY_OFFSET (stub_entry->other);\n \n       bfd_put_64 (htab->brlt->owner, targ,\n@@ -11683,7 +11753,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  r[0].r_offset = loc - stub_entry->group->stub_sec->contents;\n \t  if (bfd_big_endian (info->output_bfd))\n \t    r[0].r_offset += 2;\n-\t  if (stub_entry->stub_type == ppc_stub_plt_branch_r2off)\n+\t  if (stub_entry->type.r2save)\n \t    r[0].r_offset += 4;\n \t  r[0].r_info = ELF64_R_INFO (0, R_PPC64_TOC16_DS);\n \t  r[0].r_addend = targ;\n@@ -11698,7 +11768,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       p = loc;\n       obfd = htab->params->stub_bfd;\n-      if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)\n+      if (!stub_entry->type.r2save)\n \t{\n \t  if (PPC_HA (off) != 0)\n \t    {\n@@ -11746,21 +11816,16 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       p += 4;\n       bfd_put_32 (obfd, BCTR, p);\n       p += 4;\n-      break;\n-\n-    case ppc_stub_long_branch_notoc:\n-    case ppc_stub_long_branch_both:\n-    case ppc_stub_plt_branch_notoc:\n-    case ppc_stub_plt_branch_both:\n-    case ppc_stub_plt_call_notoc:\n-    case ppc_stub_plt_call_both:\n+    }\n+  else if (stub_entry->type.sub >= ppc_stub_notoc)\n+    {\n+      bool is_plt = stub_entry->type.main == ppc_stub_plt_call;\n       p = loc;\n       off = (stub_entry->stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma);\n       obfd = htab->params->stub_bfd;\n-      is_tga = ((stub_entry->stub_type == ppc_stub_plt_call_notoc\n-\t\t || stub_entry->stub_type == ppc_stub_plt_call_both)\n+      is_tga = (is_plt\n \t\t&& stub_entry->h != NULL\n \t\t&& is_tls_get_addr (&stub_entry->h->elf, htab)\n \t\t&& htab->params->tls_get_addr_opt);\n@@ -11769,15 +11834,13 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  p = build_tls_get_addr_head (htab, stub_entry, p);\n \t  off += p - loc;\n \t}\n-      if (stub_entry->stub_type == ppc_stub_long_branch_both\n-\t  || stub_entry->stub_type == ppc_stub_plt_branch_both\n-\t  || stub_entry->stub_type == ppc_stub_plt_call_both)\n+      if (stub_entry->type.r2save)\n \t{\n \t  off += 4;\n \t  bfd_put_32 (obfd, STD_R2_0R1 + STK_TOC (htab), p);\n \t  p += 4;\n \t}\n-      if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)\n+      if (is_plt)\n \t{\n \t  targ = stub_entry->plt_ent->plt.offset & ~1;\n \t  if (targ >= (bfd_vma) -2)\n@@ -11802,11 +11865,8 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       relp = p;\n       num_rel = 0;\n-      if (htab->params->power10_stubs != 0)\n-\t{\n-\t  bool load = stub_entry->stub_type >= ppc_stub_plt_call_notoc;\n-\t  p = build_power10_offset (obfd, p, off, odd, load);\n-\t}\n+      if (stub_entry->type.sub == ppc_stub_notoc)\n+\tp = build_power10_offset (obfd, p, off, odd, is_plt);\n       else\n \t{\n \t  if (htab->glink_eh_frame != NULL\n@@ -11837,11 +11897,10 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t     sequence emitted by build_offset.  The offset is therefore 8\n \t     less than calculated from the start of the sequence.  */\n \t  off -= 8;\n-\t  p = build_offset (obfd, p, off,\n-\t\t\t    stub_entry->stub_type >= ppc_stub_plt_call_notoc);\n+\t  p = build_offset (obfd, p, off, is_plt);\n \t}\n \n-      if (stub_entry->stub_type <= ppc_stub_long_branch_both)\n+      if (stub_entry->type.main == ppc_stub_long_branch)\n \t{\n \t  bfd_vma from;\n \t  num_rel = 1;\n@@ -11865,7 +11924,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (info->emitrelocations)\n \t{\n \t  bfd_vma roff = relp - stub_entry->group->stub_sec->contents;\n-\t  if (htab->params->power10_stubs != 0)\n+\t  if (stub_entry->type.sub == ppc_stub_notoc)\n \t    num_rel += num_relocs_for_power10_offset (off, odd);\n \t  else\n \t    {\n@@ -11875,12 +11934,11 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  r = get_relocs (stub_entry->group->stub_sec, num_rel);\n \t  if (r == NULL)\n \t    return false;\n-\t  if (htab->params->power10_stubs != 0)\n+\t  if (stub_entry->type.sub == ppc_stub_notoc)\n \t    r = emit_relocs_for_power10_offset (info, r, roff, targ, off, odd);\n \t  else\n \t    r = emit_relocs_for_offset (info, r, roff, targ, off);\n-\t  if (stub_entry->stub_type == ppc_stub_long_branch_notoc\n-\t      || stub_entry->stub_type == ppc_stub_long_branch_both)\n+\t  if (stub_entry->type.main == ppc_stub_long_branch)\n \t    {\n \t      ++r;\n \t      roff = p - 4 - stub_entry->group->stub_sec->contents;\n@@ -11892,10 +11950,9 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t\treturn false;\n \t    }\n \t}\n-      break;\n-\n-    case ppc_stub_plt_call:\n-    case ppc_stub_plt_call_r2save:\n+    }\n+  else if (stub_entry->type.main == ppc_stub_plt_call)\n+    {\n       if (stub_entry->h != NULL\n \t  && stub_entry->h->is_func_descriptor\n \t  && stub_entry->h->oh != NULL)\n@@ -11972,12 +12029,11 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       p = build_plt_stub (htab, stub_entry, p, off, r);\n       if (is_tga)\n \tp = build_tls_get_addr_tail (htab, stub_entry, p, loc);\n-      break;\n-\n-    case ppc_stub_save_res:\n-      return true;\n-\n-    default:\n+    }\n+  else if (stub_entry->type.main == ppc_stub_save_res)\n+    return true;\n+  else\n+    {\n       BFD_FAIL ();\n       return false;\n     }\n@@ -11990,25 +12046,16 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       size_t len1, len2;\n       char *name;\n       const char *const stub_str[] = { \"long_branch\",\n-\t\t\t\t       \"long_branch\",\n-\t\t\t\t       \"long_branch\",\n-\t\t\t\t       \"long_branch\",\n-\t\t\t\t       \"plt_branch\",\n-\t\t\t\t       \"plt_branch\",\n-\t\t\t\t       \"plt_branch\",\n \t\t\t\t       \"plt_branch\",\n-\t\t\t\t       \"plt_call\",\n-\t\t\t\t       \"plt_call\",\n-\t\t\t\t       \"plt_call\",\n \t\t\t\t       \"plt_call\" };\n \n-      len1 = strlen (stub_str[stub_entry->stub_type - 1]);\n+      len1 = strlen (stub_str[stub_entry->type.main - 1]);\n       len2 = strlen (stub_entry->root.string);\n       name = bfd_malloc (len1 + len2 + 2);\n       if (name == NULL)\n \treturn false;\n       memcpy (name, stub_entry->root.string, 9);\n-      memcpy (name + 9, stub_str[stub_entry->stub_type - 1], len1);\n+      memcpy (name + 9, stub_str[stub_entry->type.main - 1], len1);\n       memcpy (name + len1 + 9, stub_entry->root.string + 8, len2 - 8 + 1);\n       h = elf_link_hash_lookup (&htab->elf, name, true, false, false);\n       if (h == NULL)\n@@ -12082,20 +12129,22 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       /* Don't make stubs to out-of-line register save/restore\n \t functions.  Instead, emit copies of the functions.  */\n       stub_entry->group->needs_save_res = 1;\n-      stub_entry->stub_type = ppc_stub_save_res;\n+      stub_entry->type.main = ppc_stub_save_res;\n+      stub_entry->type.sub = ppc_stub_toc;\n+      stub_entry->type.r2save = 0;\n       return true;\n     }\n \n-  switch (stub_entry->stub_type)\n+  if (stub_entry->type.main == ppc_stub_plt_branch)\n     {\n-    case ppc_stub_plt_branch:\n-    case ppc_stub_plt_branch_r2off:\n       /* Reset the stub type from the plt branch variant in case we now\n \t can reach with a shorter stub.  */\n-      stub_entry->stub_type += ppc_stub_long_branch - ppc_stub_plt_branch;\n-      /* Fall through.  */\n-    case ppc_stub_long_branch:\n-    case ppc_stub_long_branch_r2off:\n+      stub_entry->type.main += ppc_stub_long_branch - ppc_stub_plt_branch;\n+    }\n+\n+  if (stub_entry->type.main == ppc_stub_long_branch\n+      && stub_entry->type.sub == ppc_stub_toc)\n+    {\n       targ = (stub_entry->target_value\n \t      + stub_entry->target_section->output_offset\n \t      + stub_entry->target_section->output_section->vma);\n@@ -12106,7 +12155,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       size = 4;\n       r2off = 0;\n-      if (stub_entry->stub_type == ppc_stub_long_branch_r2off)\n+      if (stub_entry->type.r2save)\n \t{\n \t  r2off = get_r2off (info, stub_entry);\n \t  if (r2off == (bfd_vma) -1)\n@@ -12125,7 +12174,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       /* If the branch offset is too big, use a ppc_stub_plt_branch.\n \t Do the same for -R objects without function descriptors.  */\n-      if ((stub_entry->stub_type == ppc_stub_long_branch_r2off\n+      if ((stub_entry->type.r2save\n \t   && r2off == 0\n \t   && htab->sec_info[stub_entry->target_section->id].toc_off == 0)\n \t  || off + (1 << 25) >= (bfd_vma) (1 << 26))\n@@ -12172,8 +12221,8 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t    }\n \n-\t  stub_entry->stub_type += ppc_stub_plt_branch - ppc_stub_long_branch;\n-\t  if (stub_entry->stub_type != ppc_stub_plt_branch_r2off)\n+\t  stub_entry->type.main += ppc_stub_plt_branch - ppc_stub_long_branch;\n+\t  if (!stub_entry->type.r2save)\n \t    {\n \t      size = 12;\n \t      if (PPC_HA (off) != 0)\n@@ -12196,19 +12245,14 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  stub_entry->group->stub_sec->reloc_count += 1;\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n-      break;\n-\n-    case ppc_stub_plt_branch_notoc:\n-    case ppc_stub_plt_branch_both:\n-      stub_entry->stub_type += ppc_stub_long_branch - ppc_stub_plt_branch;\n-      /* Fall through.  */\n-    case ppc_stub_long_branch_notoc:\n-    case ppc_stub_long_branch_both:\n+    }\n+  else if (stub_entry->type.main == ppc_stub_long_branch)\n+    {\n       off = (stub_entry->stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma);\n       size = 0;\n-      if (stub_entry->stub_type == ppc_stub_long_branch_both)\n+      if (stub_entry->type.r2save)\n \tsize = 4;\n       off += size;\n       targ = (stub_entry->target_value\n@@ -12220,15 +12264,15 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (info->emitrelocations)\n \t{\n \t  unsigned int num_rel;\n-\t  if (htab->params->power10_stubs != 0)\n+\t  if (stub_entry->type.sub == ppc_stub_notoc)\n \t    num_rel = num_relocs_for_power10_offset (off, odd);\n \t  else\n \t    num_rel = num_relocs_for_offset (off - 8);\n \t  stub_entry->group->stub_sec->reloc_count += num_rel;\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n \n-      if (htab->params->power10_stubs != 0)\n+      if (stub_entry->type.sub == ppc_stub_notoc)\n \textra = size_power10_offset (off, odd);\n       else\n \textra = size_offset (off - 8);\n@@ -12239,12 +12283,12 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t calculated.  */\n       off -= extra;\n \n-      if (htab->params->power10_stubs == 0)\n+      if (stub_entry->type.sub != ppc_stub_notoc)\n \t{\n \t  /* After the bcl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is in r12.  */\n \t  lr_used = stub_entry->stub_offset + 8;\n-\t  if (stub_entry->stub_type == ppc_stub_long_branch_both)\n+\t  if (stub_entry->type.r2save)\n \t    lr_used += 4;\n \t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n \t     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n@@ -12257,16 +12301,15 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       /* If the branch can't reach, use a plt_branch.  */\n       if (off + (1 << 25) >= (bfd_vma) (1 << 26))\n \t{\n-\t  stub_entry->stub_type += (ppc_stub_plt_branch_notoc\n-\t\t\t\t    - ppc_stub_long_branch_notoc);\n+\t  stub_entry->type.main += ppc_stub_plt_branch - ppc_stub_long_branch;\n \t  size += 4;\n \t}\n       else if (info->emitrelocations)\n \tstub_entry->group->stub_sec->reloc_count +=1;\n-      break;\n-\n-    case ppc_stub_plt_call_notoc:\n-    case ppc_stub_plt_call_both:\n+    }\n+  else if (stub_entry->type.sub >= ppc_stub_notoc)\n+    {\n+      BFD_ASSERT (stub_entry->type.main == ppc_stub_plt_call);\n       lr_used = 0;\n       if (stub_entry->h != NULL\n \t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n@@ -12275,10 +12318,10 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  lr_used += 7 * 4;\n \t  if (!htab->params->no_tls_get_addr_regsave)\n \t    lr_used += 11 * 4;\n-\t  else if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t  else if (stub_entry->type.r2save)\n \t    lr_used += 2 * 4;\n \t}\n-      if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+      if (stub_entry->type.r2save)\n \tlr_used += 4;\n       targ = stub_entry->plt_ent->plt.offset & ~1;\n       if (targ >= (bfd_vma) -2)\n@@ -12313,7 +12356,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (info->emitrelocations)\n \t{\n \t  unsigned int num_rel;\n-\t  if (htab->params->power10_stubs != 0)\n+\t  if (stub_entry->type.sub == ppc_stub_notoc)\n \t    num_rel = num_relocs_for_power10_offset (off, odd);\n \t  else\n \t    num_rel = num_relocs_for_offset (off - 8);\n@@ -12323,7 +12366,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       size = plt_stub_size (htab, stub_entry, off, odd);\n \n-      if (htab->params->power10_stubs == 0)\n+      if (stub_entry->type.sub != ppc_stub_notoc)\n \t{\n \t  /* After the bcl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is in r12.  */\n@@ -12335,9 +12378,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n \t  stub_entry->group->lr_restore = lr_used + 8;\n \t}\n-      if ((stub_entry->stub_type == ppc_stub_plt_call_notoc\n-\t   || stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t  && stub_entry->h != NULL\n+      if (stub_entry->h != NULL\n \t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n \t  && htab->params->tls_get_addr_opt)\n \t{\n@@ -12350,7 +12391,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      stub_entry->group->lr_restore\n \t\t= stub_entry->stub_offset + size - 4;\n \t    }\n-\t  else if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t  else if (stub_entry->type.r2save)\n \t    {\n \t      lr_used = stub_entry->stub_offset + size - 20;\n \t      delta = lr_used - stub_entry->group->lr_restore;\n@@ -12359,10 +12400,9 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t\t= stub_entry->stub_offset + size - 4;\n \t    }\n \t}\n-      break;\n-\n-    case ppc_stub_plt_call:\n-    case ppc_stub_plt_call_r2save:\n+    }\n+  else if (stub_entry->type.main == ppc_stub_plt_call)\n+    {\n       targ = stub_entry->plt_ent->plt.offset & ~(bfd_vma) 1;\n       if (targ >= (bfd_vma) -2)\n \tabort ();\n@@ -12404,7 +12444,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       if (stub_entry->h != NULL\n \t  && is_tls_get_addr (&stub_entry->h->elf, htab)\n \t  && htab->params->tls_get_addr_opt\n-\t  && stub_entry->stub_type == ppc_stub_plt_call_r2save)\n+\t  && stub_entry->type.r2save)\n \t{\n \t  if (!htab->params->no_tls_get_addr_regsave)\n \t    {\n@@ -12425,9 +12465,9 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    }\n \t  stub_entry->group->lr_restore = stub_entry->stub_offset + size - 4;\n \t}\n-      break;\n-\n-    default:\n+    }\n+  else\n+    {\n       BFD_FAIL ();\n       return false;\n     }\n@@ -12837,6 +12877,7 @@ toc_adjusting_stub_needed (struct bfd_link_info *info, asection *isec)\n \t  r_type = ELF64_R_TYPE (rel->r_info);\n \t  if (r_type != R_PPC64_REL24\n \t      && r_type != R_PPC64_REL24_NOTOC\n+\t      && r_type != R_PPC64_REL24_P9NOTOC\n \t      && r_type != R_PPC64_REL14\n \t      && r_type != R_PPC64_REL14_BRTAKEN\n \t      && r_type != R_PPC64_REL14_BRNTAKEN\n@@ -13425,7 +13466,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t{\n \t\t  enum elf_ppc64_reloc_type r_type;\n \t\t  unsigned int r_indx;\n-\t\t  enum ppc_stub_type stub_type;\n+\t\t  struct ppc_stub_type stub_type;\n \t\t  struct ppc_stub_hash_entry *stub_entry;\n \t\t  asection *sym_sec, *code_sec;\n \t\t  bfd_vma sym_value, code_value;\n@@ -13453,6 +13494,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t  /* Only look for stubs on branch instructions.  */\n \t\t  if (r_type != R_PPC64_REL24\n \t\t      && r_type != R_PPC64_REL24_NOTOC\n+\t\t      && r_type != R_PPC64_REL24_P9NOTOC\n \t\t      && r_type != R_PPC64_REL14\n \t\t      && r_type != R_PPC64_REL14_BRTAKEN\n \t\t      && r_type != R_PPC64_REL14_BRNTAKEN)\n@@ -13556,23 +13598,35 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \n \t\t  /* Determine what (if any) linker stub is needed.  */\n \t\t  plt_ent = NULL;\n-\t\t  stub_type = ppc_type_of_stub (section, irela, &hash,\n-\t\t\t\t\t\t&plt_ent, destination,\n-\t\t\t\t\t\tlocal_off);\n-\n-\t\t  if (r_type == R_PPC64_REL24_NOTOC)\n+\t\t  stub_type.main = ppc_type_of_stub (section, irela, &hash,\n+\t\t\t\t\t\t     &plt_ent, destination,\n+\t\t\t\t\t\t     local_off);\n+\t\t  stub_type.sub = ppc_stub_toc;\n+\t\t  stub_type.r2save = 0;\n+\n+\t\t  if (r_type == R_PPC64_REL24_NOTOC\n+\t\t      || r_type == R_PPC64_REL24_P9NOTOC)\n \t\t    {\n-\t\t      if (stub_type == ppc_stub_plt_call)\n-\t\t\tstub_type = ppc_stub_plt_call_notoc;\n-\t\t      else if (stub_type == ppc_stub_long_branch\n+\t\t      enum ppc_stub_sub_type notoc = ppc_stub_notoc;\n+\t\t      if (htab->params->power10_stubs == 0\n+\t\t\t  || (r_type == R_PPC64_REL24_P9NOTOC\n+\t\t\t      && htab->params->power10_stubs != 1))\n+\t\t\tnotoc = ppc_stub_p9notoc;\n+\t\t      if (stub_type.main == ppc_stub_plt_call)\n+\t\t\tstub_type.sub = notoc;\n+\t\t      else if (stub_type.main == ppc_stub_long_branch\n \t\t\t       || (code_sec != NULL\n \t\t\t\t   && code_sec->output_section != NULL\n \t\t\t\t   && (((hash ? hash->elf.other : sym->st_other)\n \t\t\t\t\t& STO_PPC64_LOCAL_MASK)\n \t\t\t\t       > 1 << STO_PPC64_LOCAL_BIT)))\n-\t\t\tstub_type = ppc_stub_long_branch_notoc;\n+\t\t\t{\n+\t\t\t  stub_type.main = ppc_stub_long_branch;\n+\t\t\t  stub_type.sub = notoc;\n+\t\t\t  stub_type.r2save = 0;\n+\t\t\t}\n \t\t    }\n-\t\t  else if (stub_type != ppc_stub_plt_call)\n+\t\t  else if (stub_type.main != ppc_stub_plt_call)\n \t\t    {\n \t\t      /* Check whether we need a TOC adjusting stub.\n \t\t\t Since the linker pastes together pieces from\n@@ -13589,15 +13643,18 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t\t  || (((hash ? hash->elf.other : sym->st_other)\n \t\t\t       & STO_PPC64_LOCAL_MASK)\n \t\t\t      == 1 << STO_PPC64_LOCAL_BIT))\n-\t\t\tstub_type = ppc_stub_long_branch_r2off;\n+\t\t\t{\n+\t\t\t  stub_type.main = ppc_stub_long_branch;\n+\t\t\t  stub_type.sub = ppc_stub_toc;\n+\t\t\t  stub_type.r2save = 1;\n+\t\t\t}\n \t\t    }\n \n-\t\t  if (stub_type == ppc_stub_none)\n+\t\t  if (stub_type.main == ppc_stub_none)\n \t\t    continue;\n \n \t\t  /* __tls_get_addr calls might be eliminated.  */\n-\t\t  if (stub_type != ppc_stub_plt_call\n-\t\t      && stub_type != ppc_stub_plt_call_notoc\n+\t\t  if (stub_type.main != ppc_stub_plt_call\n \t\t      && hash != NULL\n \t\t      && is_tls_get_addr (&hash->elf, htab)\n \t\t      && section->has_tls_reloc\n@@ -13614,7 +13671,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t\tcontinue;\n \t\t    }\n \n-\t\t  if (stub_type == ppc_stub_plt_call)\n+\t\t  if (stub_type.main == ppc_stub_plt_call\n+\t\t      && stub_type.sub == ppc_stub_toc)\n \t\t    {\n \t\t      if (!htab->opd_abi\n \t\t\t  && htab->params->plt_localentry0 != 0\n@@ -13630,7 +13688,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t\t    goto error_ret_free_internal;\n \t\t\t}\n \t\t      else\n-\t\t\tstub_type = ppc_stub_plt_call_r2save;\n+\t\t\tstub_type.r2save = 1;\n \t\t    }\n \n \t\t  /* Support for grouping stub sections.  */\n@@ -13645,106 +13703,15 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t\t\t\t\t     stub_name, false, false);\n \t\t  if (stub_entry != NULL)\n \t\t    {\n-\t\t      enum ppc_stub_type old_type;\n-\n-\t\t      /* A stub has already been created, but it may\n-\t\t\t not be the required type.  We shouldn't be\n-\t\t\t transitioning from plt_call to long_branch\n-\t\t\t stubs or vice versa, but we might be\n-\t\t\t upgrading from plt_call to plt_call_r2save or\n-\t\t\t from long_branch to long_branch_r2off.  */\n \t\t      free (stub_name);\n-\t\t      if (htab->params->power10_stubs == -1)\n+\t\t      if (!ppc_merge_stub (htab, stub_entry, stub_type, r_type))\n \t\t\t{\n-\t\t\t  /* For --power10-stubs=auto, don't merge _notoc\n-\t\t\t     and other varieties of stubs.  (The _both\n-\t\t\t     variety won't be created.)  */\n-\t\t\t  bool notoc = r_type == R_PPC64_REL24_NOTOC;\n-\t\t\t  struct ppc_stub_hash_entry *alt_stub\n-\t\t\t    = select_alt_stub (stub_entry, notoc);\n-\n-\t\t\t  if (alt_stub == NULL)\n-\t\t\t    {\n-\t\t\t      alt_stub = (struct ppc_stub_hash_entry *)\n-\t\t\t\tstub_hash_newfunc (NULL,\n-\t\t\t\t\t\t   &htab->stub_hash_table,\n-\t\t\t\t\t\t   stub_entry->root.string);\n-\t\t\t      if (alt_stub == NULL)\n-\t\t\t\t{\n-\t\t\t\t  /* xgettext:c-format */\n-\t\t\t\t  _bfd_error_handler\n-\t\t\t\t    (_(\"%pB: cannot create stub entry %s\"),\n-\t\t\t\t     section->owner, stub_entry->root.string);\n-\t\t\t\t  goto error_ret_free_internal;\n-\t\t\t\t}\n-\t\t\t      *alt_stub = *stub_entry;\n-\t\t\t      stub_entry->root.next = &alt_stub->root;\n-\t\t\t      if (notoc)\n-\t\t\t\t/* Sort notoc stubs first, for no good\n-\t\t\t\t   reason.  */\n-\t\t\t\talt_stub = stub_entry;\n-\t\t\t      alt_stub->stub_type = stub_type;\n-\t\t\t    }\n-\t\t\t  stub_entry = alt_stub;\n+\t\t\t  /* xgettext:c-format */\n+\t\t\t  _bfd_error_handler\n+\t\t\t    (_(\"%pB: cannot create stub entry %s\"),\n+\t\t\t     section->owner, stub_entry->root.string);\n+\t\t\t  goto error_ret_free_internal;\n \t\t\t}\n-\t\t      old_type = stub_entry->stub_type;\n-\t\t      switch (old_type)\n-\t\t\t{\n-\t\t\tdefault:\n-\t\t\t  abort ();\n-\n-\t\t\tcase ppc_stub_save_res:\n-\t\t\t  continue;\n-\n-\t\t\tcase ppc_stub_plt_call:\n-\t\t\tcase ppc_stub_plt_call_r2save:\n-\t\t\tcase ppc_stub_plt_call_notoc:\n-\t\t\tcase ppc_stub_plt_call_both:\n-\t\t\t  if (stub_type == ppc_stub_plt_call)\n-\t\t\t    continue;\n-\t\t\t  else if (stub_type == ppc_stub_plt_call_r2save)\n-\t\t\t    {\n-\t\t\t      if (old_type == ppc_stub_plt_call_notoc)\n-\t\t\t\tstub_type = ppc_stub_plt_call_both;\n-\t\t\t    }\n-\t\t\t  else if (stub_type == ppc_stub_plt_call_notoc)\n-\t\t\t    {\n-\t\t\t      if (old_type == ppc_stub_plt_call_r2save)\n-\t\t\t\tstub_type = ppc_stub_plt_call_both;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    abort ();\n-\t\t\t  break;\n-\n-\t\t\tcase ppc_stub_plt_branch:\n-\t\t\tcase ppc_stub_plt_branch_r2off:\n-\t\t\tcase ppc_stub_plt_branch_notoc:\n-\t\t\tcase ppc_stub_plt_branch_both:\n-\t\t\t  old_type += (ppc_stub_long_branch\n-\t\t\t\t       - ppc_stub_plt_branch);\n-\t\t\t  /* Fall through.  */\n-\t\t\tcase ppc_stub_long_branch:\n-\t\t\tcase ppc_stub_long_branch_r2off:\n-\t\t\tcase ppc_stub_long_branch_notoc:\n-\t\t\tcase ppc_stub_long_branch_both:\n-\t\t\t  if (stub_type == ppc_stub_long_branch)\n-\t\t\t    continue;\n-\t\t\t  else if (stub_type == ppc_stub_long_branch_r2off)\n-\t\t\t    {\n-\t\t\t      if (old_type == ppc_stub_long_branch_notoc)\n-\t\t\t\tstub_type = ppc_stub_long_branch_both;\n-\t\t\t    }\n-\t\t\t  else if (stub_type == ppc_stub_long_branch_notoc)\n-\t\t\t    {\n-\t\t\t      if (old_type == ppc_stub_long_branch_r2off)\n-\t\t\t\tstub_type = ppc_stub_long_branch_both;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    abort ();\n-\t\t\t  break;\n-\t\t\t}\n-\t\t      if (old_type < stub_type)\n-\t\t\tstub_entry->stub_type = stub_type;\n \t\t      continue;\n \t\t    }\n \n@@ -13762,9 +13729,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t\t      return false;\n \t\t    }\n \n-\t\t  stub_entry->stub_type = stub_type;\n-\t\t  if (stub_type >= ppc_stub_plt_call\n-\t\t      && stub_type <= ppc_stub_plt_call_both)\n+\t\t  stub_entry->type = stub_type;\n+\t\t  if (stub_type.main == ppc_stub_plt_call)\n \t\t    {\n \t\t      stub_entry->target_value = sym_value;\n \t\t      stub_entry->target_section = sym_sec;\n@@ -14815,31 +14781,13 @@ ppc64_elf_build_stubs (struct bfd_link_info *info,\n \t{\n \t  if (asprintf (stats, _(\"%s\"\n \t\t\t\t \"  branch         %lu\\n\"\n-\t\t\t\t \"  branch toc adj %lu\\n\"\n-\t\t\t\t \"  branch notoc   %lu\\n\"\n-\t\t\t\t \"  branch both    %lu\\n\"\n \t\t\t\t \"  long branch    %lu\\n\"\n-\t\t\t\t \"  long toc adj   %lu\\n\"\n-\t\t\t\t \"  long notoc     %lu\\n\"\n-\t\t\t\t \"  long both      %lu\\n\"\n \t\t\t\t \"  plt call       %lu\\n\"\n-\t\t\t\t \"  plt call save  %lu\\n\"\n-\t\t\t\t \"  plt call notoc %lu\\n\"\n-\t\t\t\t \"  plt call both  %lu\\n\"\n \t\t\t\t \"  global entry   %lu\"),\n \t\t\tgroupmsg,\n \t\t\thtab->stub_count[ppc_stub_long_branch - 1],\n-\t\t\thtab->stub_count[ppc_stub_long_branch_r2off - 1],\n-\t\t\thtab->stub_count[ppc_stub_long_branch_notoc - 1],\n-\t\t\thtab->stub_count[ppc_stub_long_branch_both - 1],\n \t\t\thtab->stub_count[ppc_stub_plt_branch - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_branch_r2off - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_branch_notoc - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_branch_both - 1],\n \t\t\thtab->stub_count[ppc_stub_plt_call - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_call_r2save - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_call_notoc - 1],\n-\t\t\thtab->stub_count[ppc_stub_plt_call_both - 1],\n \t\t\thtab->stub_count[ppc_stub_global_entry - 1]) < 0)\n \t    *stats = NULL;\n \t  free (groupmsg);\n@@ -15626,6 +15574,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t      rel->r_addend = toc_addend;\n \t\t    }\n \t\t  if (r_type1 == R_PPC64_REL24_NOTOC\n+\t\t      || r_type1 == R_PPC64_REL24_P9NOTOC\n \t\t      || r_type1 == R_PPC64_PLTCALL_NOTOC)\n \t\t    {\n \t\t      r_type = R_PPC64_NONE;\n@@ -15675,6 +15624,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\tbfd_put_32 (output_bfd, NOP, contents + offset + 4);\n \n \t      if (r_type1 == R_PPC64_REL24_NOTOC\n+\t\t  || r_type1 == R_PPC64_REL24_P9NOTOC\n \t\t  || r_type1 == R_PPC64_PLTCALL_NOTOC)\n \t\t{\n \t\t  r_type = R_PPC64_NONE;\n@@ -15871,6 +15821,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC64_REL24:\n \tcase R_PPC64_REL24_NOTOC:\n+\tcase R_PPC64_REL24_P9NOTOC:\n \tcase R_PPC64_PLTCALL:\n \tcase R_PPC64_PLTCALL_NOTOC:\n \t  /* Calls to functions with a different TOC, such as calls to\n@@ -15889,32 +15840,28 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  if ((r_type == R_PPC64_PLTCALL\n \t       || r_type == R_PPC64_PLTCALL_NOTOC)\n \t      && stub_entry != NULL\n-\t      && stub_entry->stub_type >= ppc_stub_plt_call\n-\t      && stub_entry->stub_type <= ppc_stub_plt_call_both)\n+\t      && stub_entry->type.main == ppc_stub_plt_call)\n \t    stub_entry = NULL;\n \n \t  if (stub_entry != NULL\n-\t      && ((stub_entry->stub_type >= ppc_stub_plt_call\n-\t\t   && stub_entry->stub_type <= ppc_stub_plt_call_both)\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_r2off\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_both\n-\t\t  || stub_entry->stub_type == ppc_stub_long_branch_r2off\n-\t\t  || stub_entry->stub_type == ppc_stub_long_branch_both))\n+\t      && (stub_entry->type.main == ppc_stub_plt_call\n+\t\t  || stub_entry->type.r2save))\n \t    {\n \t      bool can_plt_call = false;\n \n-\t      if (stub_entry->stub_type == ppc_stub_plt_call\n-\t\t  && !htab->opd_abi\n-\t\t  && htab->params->plt_localentry0 != 0\n-\t\t  && h != NULL\n-\t\t  && is_elfv2_localentry0 (&h->elf))\n+\t      if (r_type == R_PPC64_REL24_NOTOC\n+\t\t  || r_type == R_PPC64_REL24_P9NOTOC)\n \t\t{\n-\t\t  /* The function doesn't use or change r2.  */\n+\t\t  /* NOTOC calls don't need to restore r2.  */\n \t\t  can_plt_call = true;\n \t\t}\n-\t      else if (r_type == R_PPC64_REL24_NOTOC)\n+\t      else if (stub_entry->type.main == ppc_stub_plt_call\n+\t\t       && !htab->opd_abi\n+\t\t       && htab->params->plt_localentry0 != 0\n+\t\t       && h != NULL\n+\t\t       && is_elfv2_localentry0 (&h->elf))\n \t\t{\n-\t\t  /* NOTOC calls don't need to restore r2.  */\n+\t\t  /* The function doesn't use or change r2.  */\n \t\t  can_plt_call = true;\n \t\t}\n \n@@ -15997,8 +15944,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \t      if (!can_plt_call)\n \t\t{\n-\t\t  if (stub_entry->stub_type >= ppc_stub_plt_call\n-\t\t      && stub_entry->stub_type <= ppc_stub_plt_call_both)\n+\t\t  if (stub_entry->type.main == ppc_stub_plt_call)\n \t\t    info->callbacks->einfo\n \t\t      /* xgettext:c-format */\n \t\t      (_(\"%H: call to `%pT' lacks nop, can't restore toc; \"\n@@ -16016,14 +15962,13 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t}\n \n \t      if (can_plt_call\n-\t\t  && stub_entry->stub_type >= ppc_stub_plt_call\n-\t\t  && stub_entry->stub_type <= ppc_stub_plt_call_both)\n+\t\t  && stub_entry->type.main == ppc_stub_plt_call)\n \t\tunresolved_reloc = false;\n \t    }\n \n \t  if ((stub_entry == NULL\n-\t       || stub_entry->stub_type == ppc_stub_long_branch\n-\t       || stub_entry->stub_type == ppc_stub_plt_branch)\n+\t       || stub_entry->type.main == ppc_stub_long_branch\n+\t       || stub_entry->type.main == ppc_stub_plt_branch)\n \t      && get_opd_info (sec) != NULL)\n \t    {\n \t      /* The branch destination is the value of the opd entry. */\n@@ -16050,44 +15995,44 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t\t\t\t\t  : sym->st_other);\n \n \t  if (stub_entry != NULL\n-\t      && (stub_entry->stub_type == ppc_stub_long_branch\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch)\n-\t      && (r_type == R_PPC64_ADDR14_BRTAKEN\n-\t\t  || r_type == R_PPC64_ADDR14_BRNTAKEN\n-\t\t  || (relocation + addend - from + max_br_offset\n-\t\t      < 2 * max_br_offset)))\n-\t    /* Don't use the stub if this branch is in range.  */\n-\t    stub_entry = NULL;\n-\n-\t  if (stub_entry != NULL\n-\t      && (stub_entry->stub_type == ppc_stub_long_branch_notoc\n-\t\t  || stub_entry->stub_type == ppc_stub_long_branch_both\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_notoc\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_both)\n-\t      && (r_type != R_PPC64_REL24_NOTOC\n-\t\t  || ((fdh ? fdh->elf.other : sym->st_other)\n-\t\t      & STO_PPC64_LOCAL_MASK) <= 1 << STO_PPC64_LOCAL_BIT)\n-\t      && (relocation + addend - from + max_br_offset\n-\t\t  < 2 * max_br_offset))\n-\t    stub_entry = NULL;\n-\n-\t  if (stub_entry != NULL\n-\t      && (stub_entry->stub_type == ppc_stub_long_branch_r2off\n-\t\t  || stub_entry->stub_type == ppc_stub_long_branch_both\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_r2off\n-\t\t  || stub_entry->stub_type == ppc_stub_plt_branch_both)\n-\t      && r_type == R_PPC64_REL24_NOTOC\n-\t      && (relocation + addend - from + max_br_offset\n-\t\t  < 2 * max_br_offset))\n-\t    stub_entry = NULL;\n+\t      && (stub_entry->type.main == ppc_stub_long_branch\n+\t\t  || stub_entry->type.main == ppc_stub_plt_branch))\n+\t    {\n+\t      if (stub_entry->type.sub == ppc_stub_toc\n+\t\t  && !stub_entry->type.r2save\n+\t\t  && (r_type == R_PPC64_ADDR14_BRTAKEN\n+\t\t      || r_type == R_PPC64_ADDR14_BRNTAKEN\n+\t\t      || (relocation + addend - from + max_br_offset\n+\t\t\t  < 2 * max_br_offset)))\n+\t\t/* Don't use the stub if this branch is in range.  */\n+\t\tstub_entry = NULL;\n+\n+\t      if (stub_entry != NULL\n+\t\t  && stub_entry->type.sub >= ppc_stub_notoc\n+\t\t  && ((r_type != R_PPC64_REL24_NOTOC\n+\t\t       && r_type != R_PPC64_REL24_P9NOTOC)\n+\t\t      || ((fdh ? fdh->elf.other : sym->st_other)\n+\t\t\t  & STO_PPC64_LOCAL_MASK) <= 1 << STO_PPC64_LOCAL_BIT)\n+\t\t  && (relocation + addend - from + max_br_offset\n+\t\t      < 2 * max_br_offset))\n+\t\tstub_entry = NULL;\n+\n+\t      if (stub_entry != NULL\n+\t\t  && stub_entry->type.r2save\n+\t\t  && (r_type == R_PPC64_REL24_NOTOC\n+\t\t      || r_type == R_PPC64_REL24_P9NOTOC)\n+\t\t  && (relocation + addend - from + max_br_offset\n+\t\t      < 2 * max_br_offset))\n+\t\tstub_entry = NULL;\n+\t    }\n \n \t  if (stub_entry != NULL)\n \t    {\n \t      /* Munge up the value and addend so that we call the stub\n \t\t rather than the procedure directly.  */\n \t      asection *stub_sec = stub_entry->group->stub_sec;\n \n-\t      if (stub_entry->stub_type == ppc_stub_save_res)\n+\t      if (stub_entry->type.main == ppc_stub_save_res)\n \t\trelocation += (stub_sec->output_offset\n \t\t\t       + stub_sec->output_section->vma\n \t\t\t       + stub_sec->size - htab->sfpr->size\n@@ -16100,29 +16045,27 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t      addend = 0;\n \t      reloc_dest = DEST_STUB;\n \n-\t      if ((((stub_entry->stub_type == ppc_stub_plt_call\n-\t\t     && ALWAYS_EMIT_R2SAVE)\n-\t\t    || stub_entry->stub_type == ppc_stub_plt_call_r2save\n-\t\t    || stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t\t   && rel + 1 < relend\n-\t\t   && rel[1].r_offset == rel->r_offset + 4\n-\t\t   && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE)\n-\t\t  || ((stub_entry->stub_type == ppc_stub_long_branch_both\n-\t\t       || stub_entry->stub_type == ppc_stub_plt_branch_both\n-\t\t       || stub_entry->stub_type == ppc_stub_plt_call_both)\n-\t\t      && r_type == R_PPC64_REL24_NOTOC))\n+\t      if (((stub_entry->type.r2save\n+\t\t    && (r_type == R_PPC64_REL24_NOTOC\n+\t\t\t|| r_type == R_PPC64_REL24_P9NOTOC))\n+\t\t   || ((stub_entry->type.main == ppc_stub_plt_call\n+\t\t\t&& (ALWAYS_EMIT_R2SAVE || stub_entry->type.r2save))\n+\t\t       && rel + 1 < relend\n+\t\t       && rel[1].r_offset == rel->r_offset + 4\n+\t\t       && ELF64_R_TYPE (rel[1].r_info) == R_PPC64_TOCSAVE))\n+\t\t  && !(stub_entry->type.main == ppc_stub_plt_call\n+\t\t       && htab->params->tls_get_addr_opt\n+\t\t       && h != NULL\n+\t\t       && is_tls_get_addr (&h->elf, htab)))\n \t\t{\n \t\t  /* Skip over the r2 store at the start of the stub.  */\n-\t\t  if (!(stub_entry->stub_type >= ppc_stub_plt_call\n-\t\t\t&& htab->params->tls_get_addr_opt\n-\t\t\t&& h != NULL\n-\t\t\t&& is_tls_get_addr (&h->elf, htab)))\n-\t\t    relocation += 4;\n+\t\t  relocation += 4;\n \t\t}\n \n-\t      if (r_type == R_PPC64_REL24_NOTOC\n-\t\t  && (stub_entry->stub_type == ppc_stub_plt_call_notoc\n-\t\t      || stub_entry->stub_type == ppc_stub_plt_call_both))\n+\t      if ((r_type == R_PPC64_REL24_NOTOC\n+\t\t   || r_type == R_PPC64_REL24_P9NOTOC)\n+\t\t  && stub_entry->type.main == ppc_stub_plt_call\n+\t\t  && stub_entry->type.sub >= ppc_stub_notoc)\n \t\thtab->notoc_plt = 1;\n \t    }\n \n@@ -16157,7 +16100,8 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t   && h->elf.root.type == bfd_link_hash_undefweak\n \t\t   && h->elf.dynindx == -1\n \t\t   && (r_type == R_PPC64_REL24\n-\t\t       || r_type == R_PPC64_REL24_NOTOC)\n+\t\t       || r_type == R_PPC64_REL24_NOTOC\n+\t\t       || r_type == R_PPC64_REL24_P9NOTOC)\n \t\t   && relocation == 0\n \t\t   && addend == 0\n \t\t   && offset_in_range (input_section, rel->r_offset, 4))\n@@ -16694,6 +16638,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC64_REL14_BRTAKEN:\n \tcase R_PPC64_REL24:\n \tcase R_PPC64_REL24_NOTOC:\n+\tcase R_PPC64_REL24_P9NOTOC:\n \tcase R_PPC64_PCREL34:\n \tcase R_PPC64_PCREL28:\n \t  break;"
    },
    {
      "sha": "382a574d9545fedfdcb6207777e6d60c5ae22727",
      "filename": "bfd/libbfd.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/libbfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/libbfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.h?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -1549,6 +1549,7 @@ static const char *const bfd_reloc_code_real_names[] = { \"@@uninitialized@@\",\n   \"BFD_RELOC_PPC64_ADDR64_LOCAL\",\n   \"BFD_RELOC_PPC64_ENTRY\",\n   \"BFD_RELOC_PPC64_REL24_NOTOC\",\n+  \"BFD_RELOC_PPC64_REL24_P9NOTOC\",\n   \"BFD_RELOC_PPC64_D34\",\n   \"BFD_RELOC_PPC64_D34_LO\",\n   \"BFD_RELOC_PPC64_D34_HI30\","
    },
    {
      "sha": "0d6111d9146304023048aca18a137d404eaa351e",
      "filename": "bfd/reloc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/reloc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/bfd/reloc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/reloc.c?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -2902,6 +2902,8 @@ ENUMX\n   BFD_RELOC_PPC64_ENTRY\n ENUMX\n   BFD_RELOC_PPC64_REL24_NOTOC\n+ENUMX\n+  BFD_RELOC_PPC64_REL24_P9NOTOC\n ENUMX\n   BFD_RELOC_PPC64_D34\n ENUMX"
    },
    {
      "sha": "66d0bb302891170ca3ed9835f2aa40cb49f10114",
      "filename": "gas/config/tc-ppc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/gas/config/tc-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/gas/config/tc-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.c?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -2255,6 +2255,10 @@ ppc_elf_suffix (char **str_p, expressionS *exp_p)\n \t    exp_p->X_add_symbol = &abs_symbol;\n \t  }\n \n+\tif (reloc == BFD_RELOC_PPC64_REL24_NOTOC\n+\t    && (ppc_cpu & PPC_OPCODE_POWER10) == 0)\n+\t  reloc = BFD_RELOC_PPC64_REL24_P9NOTOC;\n+\n \treturn (bfd_reloc_code_real_type) reloc;\n       }\n \n@@ -3128,6 +3132,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bool *pc_relative)\n     case BFD_RELOC_32_PCREL:\n     case BFD_RELOC_32_PLT_PCREL:\n     case BFD_RELOC_PPC64_REL24_NOTOC:\n+    case BFD_RELOC_PPC64_REL24_P9NOTOC:\n #ifndef OBJ_XCOFF\n     case BFD_RELOC_PPC_B16:\n #endif\n@@ -6557,6 +6562,7 @@ ppc_force_relocation (fixS *fix)\n     case BFD_RELOC_PPC_B16:\n     case BFD_RELOC_PPC_BA16:\n     case BFD_RELOC_PPC64_REL24_NOTOC:\n+    case BFD_RELOC_PPC64_REL24_P9NOTOC:\n       /* All branch fixups targeting a localentry symbol must\n          force a relocation.  */\n       if (fix->fx_addsy)\n@@ -6595,6 +6601,7 @@ ppc_fix_adjustable (fixS *fix)\n     case BFD_RELOC_PPC_BA16_BRTAKEN:\n     case BFD_RELOC_PPC_BA16_BRNTAKEN:\n     case BFD_RELOC_PPC64_REL24_NOTOC:\n+    case BFD_RELOC_PPC64_REL24_P9NOTOC:\n       if (fix->fx_addsy)\n \t{\n \t  asymbol *bfdsym = symbol_get_bfdsym (fix->fx_addsy);"
    },
    {
      "sha": "2d503c1dabc00cd5587cef31f3811ffe8ca88105",
      "filename": "include/elf/ppc64.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/include/elf/ppc64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/include/elf/ppc64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/elf/ppc64.h?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -162,6 +162,7 @@ START_RELOC_NUMBERS (elf_ppc64_reloc_type)\n   RELOC_NUMBER (R_PPC64_PLTSEQ_NOTOC,\t   121)\n   RELOC_NUMBER (R_PPC64_PLTCALL_NOTOC,\t   122)\n   RELOC_NUMBER (R_PPC64_PCREL_OPT,\t   123)\n+  RELOC_NUMBER (R_PPC64_REL24_P9NOTOC,\t   124)\n \n   RELOC_NUMBER (R_PPC64_D34,\t\t   128)\n   RELOC_NUMBER (R_PPC64_D34_LO,\t\t   129)"
    },
    {
      "sha": "1427c47e0b80d4bb1d12a5cd844051b30a56cb6f",
      "filename": "ld/testsuite/ld-powerpc/callstub-2.s",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7aba54da426b9999085d8f84e7896b8afdbb9ca6/ld/testsuite/ld-powerpc/callstub-2.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7aba54da426b9999085d8f84e7896b8afdbb9ca6/ld/testsuite/ld-powerpc/callstub-2.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-powerpc/callstub-2.s?ref=7aba54da426b9999085d8f84e7896b8afdbb9ca6",
      "patch": "@@ -1,6 +1,7 @@\n #notoc call stubs, no pcrel insns\n  .text\n  .abiversion 2\n+ .machine power10\n _start:\n  bl f1\n  nop"
    }
  ]
}