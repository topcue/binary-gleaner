{
  "sha": "a30b3e182aad25f94de6412efd5d78f7805fb4d3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTMwYjNlMTgyYWFkMjVmOTRkZTY0MTJlZmQ1ZDc4Zjc4MDVmYjRkMw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T10:41:00Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:09:37Z"
    },
    "message": "libctf: debug dumping\n\nThis introduces ctf_dump(), an iterator which returns a series of\nstrings, each representing a debugging dump of one item from a given\nsection in the CTF file.  The items may be multiline: a callback is\nprovided to allow the caller to decorate each line as they desire before\nthe line is returned.\n\nlibctf/\n\t* ctf-dump.c: New.\n\ninclude/\n\t* ctf-api.h (ctf_dump_decorate_f): New.\n\t(ctf_dump_state_t): new.\n\t(ctf_dump): New.",
    "tree": {
      "sha": "349e87e7cb16ccf37ad4bf6367211c8c423da2a8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/349e87e7cb16ccf37ad4bf6367211c8c423da2a8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a30b3e182aad25f94de6412efd5d78f7805fb4d3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a30b3e182aad25f94de6412efd5d78f7805fb4d3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a30b3e182aad25f94de6412efd5d78f7805fb4d3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a30b3e182aad25f94de6412efd5d78f7805fb4d3/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6dbf2b734063522b4f3d7403ce7a2b436802b839",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6dbf2b734063522b4f3d7403ce7a2b436802b839"
    }
  ],
  "stats": {
    "total": 612,
    "additions": 612,
    "deletions": 0
  },
  "files": [
    {
      "sha": "05083763b1a3912b986ae6e8a5f350a4ae187615",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a30b3e182aad25f94de6412efd5d78f7805fb4d3/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a30b3e182aad25f94de6412efd5d78f7805fb4d3/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=a30b3e182aad25f94de6412efd5d78f7805fb4d3",
      "patch": "@@ -1,3 +1,9 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_dump_decorate_f): New.\n+\t(ctf_dump_state_t): new.\n+\t(ctf_dump): New.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_label_f): New."
    },
    {
      "sha": "822b3bf5a9afcf39c1ddaf9aff28af1389b4616e",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a30b3e182aad25f94de6412efd5d78f7805fb4d3/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a30b3e182aad25f94de6412efd5d78f7805fb4d3/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=a30b3e182aad25f94de6412efd5d78f7805fb4d3",
      "patch": "@@ -218,6 +218,10 @@ typedef int ctf_label_f (const char *name, const ctf_lblinfo_t *info,\n typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n \t\t\t\t      size_t len, void *arg);\n+typedef char *ctf_dump_decorate_f (ctf_sect_names_t sect,\n+\t\t\t\t   char *line, void *arg);\n+\n+typedef struct ctf_dump_state ctf_dump_state_t;\n \n /* Opening.  These mostly return an abstraction over both CTF files and CTF\n    archives: so they can be used to open both.  CTF files will appear to be an\n@@ -320,6 +324,9 @@ extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n    to deal with non-archives at all.  */\n extern int ctf_archive_raw_iter (const ctf_archive_t *,\n \t\t\t\t ctf_archive_raw_member_f *, void *);\n+extern char *ctf_dump (ctf_file_t *, ctf_dump_state_t **state,\n+\t\t       ctf_sect_names_t sect, ctf_dump_decorate_f *,\n+\t\t       void *arg);\n \n extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n \t\t\t       const ctf_arinfo_t *);"
    },
    {
      "sha": "94787115fde98a727b384d17f8f66a7e653abaec",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a30b3e182aad25f94de6412efd5d78f7805fb4d3/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a30b3e182aad25f94de6412efd5d78f7805fb4d3/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=a30b3e182aad25f94de6412efd5d78f7805fb4d3",
      "patch": "@@ -1,3 +1,7 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-dump.c: New.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-labels.c: New."
    },
    {
      "sha": "28f31e4872a07b44fec6cebcf2fbd0cef938f0fb",
      "filename": "libctf/ctf-dump.c",
      "status": "added",
      "additions": 595,
      "deletions": 0,
      "changes": 595,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a30b3e182aad25f94de6412efd5d78f7805fb4d3/libctf/ctf-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a30b3e182aad25f94de6412efd5d78f7805fb4d3/libctf/ctf-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dump.c?ref=a30b3e182aad25f94de6412efd5d78f7805fb4d3",
      "patch": "@@ -0,0 +1,595 @@\n+/* Textual dumping of CTF data.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+/* One item to be dumped, in string form.  */\n+\n+typedef struct ctf_dump_item\n+{\n+  ctf_list_t cdi_list;\n+  char *cdi_item;\n+} ctf_dump_item_t;\n+\n+/* Cross-call state for dumping.  Basically just enough to track the section in\n+   use and a list of return strings.  */\n+\n+struct ctf_dump_state\n+{\n+  ctf_sect_names_t cds_sect;\n+  ctf_file_t *cds_fp;\n+  ctf_dump_item_t *cds_current;\n+  ctf_list_t cds_items;\n+};\n+\n+/* Cross-call state for ctf_dump_member. */\n+\n+typedef struct ctf_dump_membstate\n+{\n+  char **cdm_str;\n+  ctf_file_t *cdm_fp;\n+} ctf_dump_membstate_t;\n+\n+static int\n+ctf_dump_append (ctf_dump_state_t *state, char *str)\n+{\n+  ctf_dump_item_t *cdi;\n+\n+  if ((cdi = ctf_alloc (sizeof (struct ctf_dump_item))) == NULL)\n+    return (ctf_set_errno (state->cds_fp, ENOMEM));\n+\n+  cdi->cdi_item = str;\n+  ctf_list_append (&state->cds_items, cdi);\n+  return 0;\n+}\n+\n+static void\n+ctf_dump_free (ctf_dump_state_t *state)\n+{\n+  ctf_dump_item_t *cdi, *next_cdi;\n+\n+  if (state == NULL)\n+    return;\n+\n+  for (cdi = ctf_list_next (&state->cds_items); cdi != NULL;\n+       cdi = next_cdi)\n+    {\n+      free (cdi->cdi_item);\n+      next_cdi = ctf_list_next (cdi);\n+      ctf_free (cdi);\n+    }\n+}\n+\n+/* Slices need special handling to distinguish them from their referenced\n+   type.  */\n+\n+static int\n+ctf_is_slice (ctf_file_t *fp, ctf_id_t id, ctf_encoding_t *enc)\n+{\n+  int kind = ctf_type_kind (fp, id);\n+\n+  return (((kind == CTF_K_INTEGER) || (kind == CTF_K_ENUM)\n+\t   || (kind == CTF_K_FLOAT))\n+\t  && ctf_type_reference (fp, id) != CTF_ERR\n+\t  && ctf_type_encoding (fp, id, enc) != CTF_ERR);\n+}\n+\n+/* Return a dump for a single type, without member info: but do show the\n+   type's references.  */\n+\n+static char *\n+ctf_dump_format_type (ctf_file_t *fp, ctf_id_t id)\n+{\n+  ctf_id_t new_id;\n+  char *str = NULL, *bit = NULL, *buf = NULL;\n+\n+  new_id = id;\n+  do\n+    {\n+      ctf_encoding_t enc;\n+\n+      id = new_id;\n+      buf = ctf_type_aname (fp, id);\n+      if (!buf)\n+\tgoto oom;\n+\n+      /* Slices get a different print representation.  */\n+\n+      if (ctf_is_slice (fp, id, &enc))\n+\t{\n+\t  ctf_type_encoding (fp, id, &enc);\n+\t  if (asprintf (&bit, \" %lx: [slice 0x%x:0x%x]\",\n+\t\t\tid, enc.cte_offset, enc.cte_bits) < 0)\n+\t    goto oom;\n+\t}\n+      else\n+\t{\n+\t  if (asprintf (&bit, \" %lx: %s (size %lx)\", id, buf[0] == '\\0' ?\n+\t\t\t\"(nameless)\" : buf, ctf_type_size (fp, id)) < 0)\n+\t    goto oom;\n+\t}\n+      free (buf);\n+      buf = NULL;\n+      str = ctf_str_append (str, bit);\n+      free (bit);\n+      bit = NULL;\n+\n+      new_id = ctf_type_reference (fp, id);\n+      if (new_id != CTF_ERR)\n+\tstr = ctf_str_append (str, \" ->\");\n+    } while (new_id != CTF_ERR);\n+\n+  if (ctf_errno (fp) != ECTF_NOTREF)\n+    {\n+      free (str);\n+      return NULL;\n+    }\n+\n+  return str;\n+\n+ oom:\n+  free (buf);\n+  free (str);\n+  free (bit);\n+  ctf_set_errno (fp, ENOMEM);\n+  return NULL;\n+}\n+\n+/* Dump a single label into the cds_items.  */\n+\n+static int\n+ctf_dump_label (const char *name, const ctf_lblinfo_t *info,\n+\t\tvoid *arg)\n+{\n+  char *str;\n+  char *typestr;\n+  ctf_dump_state_t *state = arg;\n+\n+  if (asprintf (&str, \"%s -> \", name) < 0)\n+    return (ctf_set_errno (state->cds_fp, ENOMEM));\n+\n+  if ((typestr = ctf_dump_format_type (state->cds_fp, info->ctb_type)) == NULL)\n+    {\n+      free (str);\n+      return CTF_ERR;\t\t\t/* errno is set for us.  */\n+    }\n+\n+  str = ctf_str_append (str, typestr);\n+  free (typestr);\n+\n+  ctf_dump_append (state, str);\n+  return 0;\n+}\n+\n+/* Dump all the object entries into the cds_items.  (There is no iterator for\n+   this section, so we just do it in a loop, and this function handles all of\n+   them, rather than only one.  */\n+\n+static int\n+ctf_dump_objts (ctf_file_t *fp, ctf_dump_state_t *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < fp->ctf_nsyms; i++)\n+    {\n+      char *str;\n+      char *typestr;\n+      const char *sym_name;\n+      ctf_id_t type;\n+\n+      if ((type = ctf_lookup_by_symbol (state->cds_fp, i)) < 0)\n+\tswitch (ctf_errno (state->cds_fp))\n+\t  {\n+\t    /* Most errors are just an indication that this symbol is not a data\n+\t       symbol, but this one indicates that we were called wrong, on a\n+\t       CTF file with no associated symbol table.  */\n+\t  case ECTF_NOSYMTAB:\n+\t    return CTF_ERR;\n+\t  case ECTF_NOTDATA:\n+\t  case ECTF_NOTYPEDAT:\n+\t    continue;\n+\t  }\n+\n+      /* Variable name.  */\n+      sym_name = ctf_lookup_symbol_name (fp, i);\n+      if (sym_name[0] == '\\0')\n+\t{\n+\t  if (asprintf (&str, \"%lx -> \", i) < 0)\n+\t    return (ctf_set_errno (fp, ENOMEM));\n+\t}\n+      else\n+\t{\n+\t  if (asprintf (&str, \"%s (%lx) -> \", sym_name, i) < 0)\n+\t    return (ctf_set_errno (fp, ENOMEM));\n+\t}\n+\n+      /* Variable type.  */\n+      if ((typestr = ctf_dump_format_type (state->cds_fp, type)) == NULL)\n+\t{\n+\t  free (str);\n+\t  return CTF_ERR;\t\t/* errno is set for us.  */\n+\t}\n+\n+      str = ctf_str_append (str, typestr);\n+      free (typestr);\n+\n+      ctf_dump_append (state, str);\n+    }\n+  return 0;\n+}\n+\n+/* Dump all the function entries into the cds_items.  (As above, there is no\n+   iterator for this section.)  */\n+\n+static int\n+ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < fp->ctf_nsyms; i++)\n+    {\n+      char *str ;\n+      char *bit;\n+      const char *sym_name;\n+      ctf_funcinfo_t fi;\n+      ctf_id_t type;\n+      size_t j;\n+      ctf_id_t *args;\n+\n+      if ((type = ctf_func_info (state->cds_fp, i, &fi)) < 0)\n+\tswitch (ctf_errno (state->cds_fp))\n+\t  {\n+\t    /* Most errors are just an indication that this symbol is not a data\n+\t       symbol, but this one indicates that we were called wrong, on a\n+\t       CTF file with no associated symbol table.  */\n+\t  case ECTF_NOSYMTAB:\n+\t    return CTF_ERR;\n+\t  case ECTF_NOTDATA:\n+\t  case ECTF_NOTYPEDAT:\n+\t    continue;\n+\t  }\n+      if ((args = calloc (fi.ctc_argc, sizeof (ctf_id_t))) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+\n+      /* Return type.  */\n+      if ((str = ctf_type_aname (state->cds_fp, type)) == NULL)\n+\tgoto err;\n+\n+      str = ctf_str_append (str, \" \");\n+      free (bit);\n+\n+      /* Function name.  */\n+\n+      sym_name = ctf_lookup_symbol_name (fp, i);\n+      if (sym_name[0] == '\\0')\n+\t{\n+\t  if (asprintf (&bit, \"%lx \", i) < 0)\n+\t    goto oom;\n+\t}\n+      else\n+\t{\n+\t  if (asprintf (&bit, \"%s (%lx) \", sym_name, i) < 0)\n+\t    goto oom;\n+\t}\n+      str = ctf_str_append (str, bit);\n+      str = ctf_str_append (str, \" (\");\n+\n+      /* Function arguments.  */\n+\n+      if (ctf_func_args (state->cds_fp, i, fi.ctc_argc, args) < 0)\n+\tgoto err;\n+\n+      for (j = 0; j < fi.ctc_argc; j++)\n+\t{\n+\t  if ((bit = ctf_type_aname (state->cds_fp, args[j])) == NULL)\n+\t    goto err;\n+\t  str = ctf_str_append (str, bit);\n+\t  if ((j < fi.ctc_argc - 1) || (fi.ctc_flags & CTF_FUNC_VARARG))\n+\t    str = ctf_str_append (str, \", \");\n+\t  free (bit);\n+\t}\n+\n+      if (fi.ctc_flags & CTF_FUNC_VARARG)\n+\tstr = ctf_str_append (str, \"...\");\n+      str = ctf_str_append (str, \")\");\n+\n+      free (args);\n+      ctf_dump_append (state, str);\n+      continue;\n+\n+    oom:\n+      free (args);\n+      free (str);\n+      return (ctf_set_errno (fp, ENOMEM));\n+    err:\n+      free (args);\n+      free (str);\n+      return CTF_ERR;\t\t/* errno is set for us.  */\n+    }\n+  return 0;\n+}\n+\n+/* Dump a single variable into the cds_items.  */\n+static int\n+ctf_dump_var (const char *name, ctf_id_t type, void *arg)\n+{\n+  char *str;\n+  char *typestr;\n+  ctf_dump_state_t *state = arg;\n+\n+  if (asprintf (&str, \"%s -> \", name) < 0)\n+    return (ctf_set_errno (state->cds_fp, ENOMEM));\n+\n+  if ((typestr = ctf_dump_format_type (state->cds_fp, type)) == NULL)\n+    {\n+      free (str);\n+      return CTF_ERR;\t\t\t/* errno is set for us.  */\n+    }\n+\n+  str = ctf_str_append (str, typestr);\n+  free (typestr);\n+\n+  ctf_dump_append (state, str);\n+  return 0;\n+}\n+\n+/* Dump a single member into the string in the membstate.  */\n+static int\n+ctf_dump_member (const char *name, ctf_id_t id, unsigned long offset,\n+\t\t  int depth, void *arg)\n+{\n+  ctf_dump_membstate_t *state = arg;\n+  char *typestr = NULL;\n+  char *bit = NULL;\n+  ctf_encoding_t ep;\n+  ssize_t i;\n+\n+  for (i = 0; i < depth; i++)\n+    *state->cdm_str = ctf_str_append (*state->cdm_str, \"    \");\n+\n+  if ((typestr = ctf_type_aname (state->cdm_fp, id)) == NULL)\n+    goto oom;\n+\n+  if (asprintf (&bit, \"    [0x%lx] (ID 0x%lx) (kind %i) %s %s (aligned at 0x%lx\",\n+\t\toffset, id, ctf_type_kind (state->cdm_fp, id), typestr, name,\n+\t\tctf_type_align (state->cdm_fp, id)) < 0)\n+    goto oom;\n+  *state->cdm_str = ctf_str_append (*state->cdm_str, bit);\n+  free (typestr);\n+  free (bit);\n+  typestr = NULL;\n+  bit = NULL;\n+\n+  if ((ctf_type_kind (state->cdm_fp, id) == CTF_K_INTEGER)\n+      || (ctf_type_kind (state->cdm_fp, id) == CTF_K_FLOAT)\n+      || (ctf_is_slice (state->cdm_fp, id, &ep) == CTF_K_ENUM))\n+    {\n+      ctf_type_encoding (state->cdm_fp, id, &ep);\n+      if (asprintf (&bit, \", format 0x%x, offset:bits 0x%x:0x%x\", ep.cte_format,\n+\t\t    ep.cte_offset, ep.cte_bits) < 0)\n+\tgoto oom;\n+      *state->cdm_str = ctf_str_append (*state->cdm_str, bit);\n+      free (bit);\n+      bit = NULL;\n+    }\n+\n+  *state->cdm_str = ctf_str_append (*state->cdm_str, \")\\n\");\n+  return 0;\n+\n+ oom:\n+  free (typestr);\n+  free (bit);\n+  return (ctf_set_errno (state->cdm_fp, ENOMEM));\n+}\n+\n+/* Dump a single type into the cds_items.  */\n+\n+static int\n+ctf_dump_type (ctf_id_t id, void *arg)\n+{\n+  char *str;\n+  ctf_dump_state_t *state = arg;\n+  ctf_dump_membstate_t membstate = { &str, state->cds_fp };\n+  size_t len;\n+\n+  if ((str = ctf_dump_format_type (state->cds_fp, id)) == NULL)\n+    goto err;\n+\n+  str = ctf_str_append (str, \"\\n\");\n+  if ((ctf_type_visit (state->cds_fp, id, ctf_dump_member, &membstate)) < 0)\n+    goto err;\n+\n+  /* Trim off the last linefeed added by ctf_dump_member().  */\n+  len = strlen (str);\n+  if (str[len-1] == '\\n')\n+    str[len-1] = '\\0';\n+\n+  ctf_dump_append (state, str);\n+  return 0;\n+\n+ err:\n+  free (str);\n+  return CTF_ERR;\t\t\t/* errno is set for us.  */\n+}\n+\n+/* Dump the string table into the cds_items.  */\n+\n+static int\n+ctf_dump_str (ctf_file_t *fp, ctf_dump_state_t *state)\n+{\n+  const char *s = fp->ctf_str[CTF_STRTAB_0].cts_strs;\n+\n+  for (; s < fp->ctf_str[CTF_STRTAB_0].cts_strs +\n+\t fp->ctf_str[CTF_STRTAB_0].cts_len;)\n+    {\n+      char *str;\n+      if (asprintf (&str, \"%lx: %s\", s - fp->ctf_str[CTF_STRTAB_0].cts_strs,\n+\t\t    s) < 0)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+      ctf_dump_append (state, str);\n+      s += strlen (s) + 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Dump a particular section of a CTF file, in textual form.  Call with a\n+   pointer to a NULL STATE: each call emits a dynamically allocated string\n+   containing a description of one entity in the specified section, in order.\n+   Only the first call (with a NULL state) may vary SECT.  Once the CTF section\n+   has been entirely dumped, the call returns NULL and frees and annuls the\n+   STATE, ready for another section to be dumped.  The returned textual content\n+   may span multiple lines: between each call the FUNC is called with one\n+   textual line at a time, and should return a suitably decorated line (it can\n+   allocate a new one and return it if it likes).  */\n+\n+char *\n+ctf_dump (ctf_file_t *fp, ctf_dump_state_t **statep, ctf_sect_names_t sect,\n+\t  ctf_dump_decorate_f *func, void *arg)\n+{\n+  char *str;\n+  char *line;\n+  ctf_dump_state_t *state = NULL;\n+\n+  if (*statep == NULL)\n+    {\n+      /* Data collection.  Transforming a call-at-a-time iterator into a\n+\t return-at-a-time iterator in a language without call/cc is annoying. It\n+\t is easiest to simply collect everything at once and then return it bit\n+\t by bit.  The first call will take (much) longer than otherwise, but the\n+\t amortized time needed is the same.  */\n+\n+      if ((*statep = ctf_alloc (sizeof (struct ctf_dump_state))) == NULL)\n+\t{\n+\t  ctf_set_errno (fp, ENOMEM);\n+\t  goto end;\n+\t}\n+      state = *statep;\n+\n+      memset (state, 0, sizeof (struct ctf_dump_state));\n+      state->cds_fp = fp;\n+      state->cds_sect = sect;\n+\n+      switch (sect)\n+\t{\n+\tcase CTF_SECT_HEADER:\n+\t  /* Nothing doable (yet): entire header is discarded after read-phase.  */\n+\t  str = strdup (\"\");\n+\t  break;\n+\tcase CTF_SECT_LABEL:\n+\t  if (ctf_label_iter (fp, ctf_dump_label, state) < 0)\n+\t    {\n+\t      if (ctf_errno (fp) != ECTF_NOLABELDATA)\n+\t\tgoto end;\t\t/* errno is set for us.  */\n+\t      ctf_set_errno (fp, 0);\n+\t    }\n+\t  break;\n+\tcase CTF_SECT_OBJT:\n+\t  if (ctf_dump_objts (fp, state) < 0)\n+\t    goto end;\t\t\t/* errno is set for us.  */\n+\t  break;\n+\tcase CTF_SECT_FUNC:\n+\t  if (ctf_dump_funcs (fp, state) < 0)\n+\t    goto end;\t\t\t/* errno is set for us.  */\n+\t  break;\n+\tcase CTF_SECT_VAR:\n+\t  if (ctf_variable_iter (fp, ctf_dump_var, state) < 0)\n+\t    goto end;\t\t\t/* errno is set for us.  */\n+\t  break;\n+\tcase CTF_SECT_TYPE:\n+\t  if (ctf_type_iter (fp, ctf_dump_type, state) < 0)\n+\t    goto end;\t\t\t/* errno is set for us.  */\n+\t  break;\n+\tcase CTF_SECT_STR:\n+\t  ctf_dump_str (fp, state);\n+\t  break;\n+\tdefault:\n+\t  ctf_set_errno (fp, ECTF_DUMPSECTUNKNOWN);\n+\t  goto end;\n+\t}\n+    }\n+  else\n+    {\n+      state = *statep;\n+\n+      if (state->cds_sect != sect)\n+\t{\n+\t  ctf_set_errno (fp, ECTF_DUMPSECTCHANGED);\n+\t  goto end;\n+\t}\n+    }\n+\n+  if (state->cds_current == NULL)\n+    state->cds_current = ctf_list_next (&state->cds_items);\n+  else\n+    state->cds_current = ctf_list_next (state->cds_current);\n+\n+  if (state->cds_current == NULL)\n+    goto end;\n+\n+  /* Hookery.  There is some extra complexity to preserve linefeeds within each\n+     item while removing linefeeds at the end.  */\n+  if (func)\n+    {\n+      size_t len;\n+\n+      str = NULL;\n+      for (line = state->cds_current->cdi_item; line && *line; )\n+\t{\n+\t  char *nline = line;\n+\t  char *ret;\n+\n+\t  nline = strchr (line, '\\n');\n+\t  if (nline)\n+\t    nline[0] = '\\0';\n+\n+\t  ret = func (sect, line, arg);\n+\t  str = ctf_str_append (str, ret);\n+\t  str = ctf_str_append (str, \"\\n\");\n+\t  if (ret != line)\n+\t    free (ret);\n+\n+\t  if (nline)\n+\t    {\n+\t      nline[0] = '\\n';\n+\t      nline++;\n+\t    }\n+\n+\t  line = nline;\n+\t}\n+\n+      len = strlen (str);\n+\n+      if (str[len-1] == '\\n')\n+\tstr[len-1] = '\\0';\n+    }\n+  else\n+    str = strdup (state->cds_current->cdi_item);\n+\n+  ctf_set_errno (fp, 0);\n+  return str;\n+\n+ end:\n+  ctf_dump_free (state);\n+  ctf_free (state);\n+  ctf_set_errno (fp, 0);\n+  *statep = NULL;\n+  return NULL;\n+}"
    }
  ]
}