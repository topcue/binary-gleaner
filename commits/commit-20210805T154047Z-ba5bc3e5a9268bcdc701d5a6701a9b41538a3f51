{
  "sha": "ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmE1YmMzZTVhOTI2OGJjZGM3MDFkNWE2NzAxYTliNDE1MzhhM2Y1MQ==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-15T15:52:11Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:40:47Z"
    },
    "message": "Make DWARF evaluator return a single struct value\n\nThe patch is addressing the issue of class users writing and reading\nthe internal data of the dwarf_expr_context class.\n\nAt this point, all conditions are met for the DWARF evaluator to return\nan evaluation result in a form of a single struct value object.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (pieced_value_funcs): Chenge to static\n\tfunction.\n\t(allocate_piece_closure): Change to static function.\n\t(dwarf_expr_context::fetch_result): New function.\n\t* dwarf2/expr.h (struct piece_closure): Remove declaration.\n\t(struct dwarf_expr_context): fetch_result new declaration.\n\tfetch, fetch_address and fetch_in_stack_memory members move\n\tto private.\n\t(allocate_piece_closure): Remove.\n\t* dwarf2/frame.c (execute_stack_op): Change to use\n\tfetch_result.\n\t* dwarf2/loc.c (dwarf2_evaluate_loc_desc_full): Change to use\n\tfetch_result.\n\t(dwarf2_locexpr_baton_eval): Change to use fetch_result.\n        * dwarf2/loc.h (invalid_synthetic_pointer): Expose function.",
    "tree": {
      "sha": "d90bed1f7780e64faf9fe4e92cc7060ab8533745",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d90bed1f7780e64faf9fe4e92cc7060ab8533745"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "efa86d3c26457c4c619fddef8232738d5091978b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efa86d3c26457c4c619fddef8232738d5091978b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/efa86d3c26457c4c619fddef8232738d5091978b"
    }
  ],
  "stats": {
    "total": 401,
    "additions": 203,
    "deletions": 198
  },
  "files": [
    {
      "sha": "5b4b734ccd2daf9d4392de6e86413146ce39df86",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 156,
      "deletions": 3,
      "changes": 159,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "patch": "@@ -117,9 +117,10 @@ struct piece_closure\n   struct frame_id frame_id;\n };\n \n-/* See expr.h.  */\n+/* Allocate a closure for a value formed from separately-described\n+   PIECES.  */\n \n-piece_closure *\n+static piece_closure *\n allocate_piece_closure (dwarf2_per_cu_data *per_cu,\n \t\t\tdwarf2_per_objfile *per_objfile,\n \t\t\tstd::vector<dwarf_expr_piece> &&pieces,\n@@ -612,7 +613,7 @@ free_pieced_value_closure (value *v)\n }\n \n /* Functions for accessing a variable described by DW_OP_piece.  */\n-const struct lval_funcs pieced_value_funcs = {\n+static const struct lval_funcs pieced_value_funcs = {\n   read_pieced_value,\n   write_pieced_value,\n   indirect_pieced_value,\n@@ -879,6 +880,158 @@ dwarf_expr_context::push_dwarf_reg_entry_value (call_site_parameter_kind kind,\n   this->eval (data_src, size);\n }\n \n+/* See expr.h.  */\n+\n+value *\n+dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n+\t\t\t\t  LONGEST subobj_offset)\n+{\n+  value *retval = nullptr;\n+\n+  if (type == nullptr)\n+    type = address_type ();\n+\n+  if (subobj_type == nullptr)\n+    subobj_type = type;\n+\n+  if (this->pieces.size () > 0)\n+    {\n+      ULONGEST bit_size = 0;\n+\n+      for (dwarf_expr_piece &piece : this->pieces)\n+\tbit_size += piece.size;\n+      /* Complain if the expression is larger than the size of the\n+\t outer type.  */\n+      if (bit_size > 8 * TYPE_LENGTH (type))\n+\tinvalid_synthetic_pointer ();\n+\n+      piece_closure *c\n+\t= allocate_piece_closure (this->per_cu, this->per_objfile,\n+\t\t\t\t  std::move (this->pieces), this->frame);\n+      retval = allocate_computed_value (subobj_type,\n+\t\t\t\t\t&pieced_value_funcs, c);\n+      set_value_offset (retval, subobj_offset);\n+    }\n+  else\n+    {\n+      switch (this->location)\n+\t{\n+\tcase DWARF_VALUE_REGISTER:\n+\t  {\n+\t    int dwarf_regnum\n+\t      = longest_to_int (value_as_long (this->fetch (0)));\n+\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (this->gdbarch,\n+\t\t\t\t\t\t\t   dwarf_regnum);\n+\n+\t    if (subobj_offset != 0)\n+\t      error (_(\"cannot use offset on synthetic pointer to register\"));\n+\n+\t    gdb_assert (this->frame != NULL);\n+\n+\t    retval = value_from_register (subobj_type, gdb_regnum,\n+\t\t\t\t\t  this->frame);\n+\t    if (value_optimized_out (retval))\n+\t      {\n+\t\t/* This means the register has undefined value / was\n+\t\t   not saved.  As we're computing the location of some\n+\t\t   variable etc. in the program, not a value for\n+\t\t   inspecting a register ($pc, $sp, etc.), return a\n+\t\t   generic optimized out value instead, so that we show\n+\t\t   <optimized out> instead of <not saved>.  */\n+\t\tvalue *tmp = allocate_value (subobj_type);\n+\t\tvalue_contents_copy (tmp, 0, retval, 0,\n+\t\t\t\t     TYPE_LENGTH (subobj_type));\n+\t\tretval = tmp;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_MEMORY:\n+\t  {\n+\t    struct type *ptr_type;\n+\t    CORE_ADDR address = this->fetch_address (0);\n+\t    bool in_stack_memory = this->fetch_in_stack_memory (0);\n+\n+\t    /* DW_OP_deref_size (and possibly other operations too) may\n+\t       create a pointer instead of an address.  Ideally, the\n+\t       pointer to address conversion would be performed as part\n+\t       of those operations, but the type of the object to\n+\t       which the address refers is not known at the time of\n+\t       the operation.  Therefore, we do the conversion here\n+\t       since the type is readily available.  */\n+\n+\t    switch (subobj_type->code ())\n+\t      {\n+\t\tcase TYPE_CODE_FUNC:\n+\t\tcase TYPE_CODE_METHOD:\n+\t\t  ptr_type = builtin_type (this->gdbarch)->builtin_func_ptr;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  ptr_type = builtin_type (this->gdbarch)->builtin_data_ptr;\n+\t\t  break;\n+\t      }\n+\t    address = value_as_address (value_from_pointer (ptr_type, address));\n+\n+\t    retval = value_at_lazy (subobj_type,\n+\t\t\t\t    address + subobj_offset);\n+\t    if (in_stack_memory)\n+\t      set_value_stack (retval, 1);\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_STACK:\n+\t  {\n+\t    value *val = this->fetch (0);\n+\t    size_t n = TYPE_LENGTH (value_type (val));\n+\t    size_t len = TYPE_LENGTH (subobj_type);\n+\t    size_t max = TYPE_LENGTH (type);\n+\n+\t    if (subobj_offset + len > max)\n+\t      invalid_synthetic_pointer ();\n+\n+\t    retval = allocate_value (subobj_type);\n+\n+\t    /* The given offset is relative to the actual object.  */\n+\t    if (gdbarch_byte_order (this->gdbarch) == BFD_ENDIAN_BIG)\n+\t      subobj_offset += n - max;\n+\n+\t    memcpy (value_contents_raw (retval),\n+\t\t    value_contents_all (val) + subobj_offset, len);\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_LITERAL:\n+\t  {\n+\t    size_t n = TYPE_LENGTH (subobj_type);\n+\n+\t    if (subobj_offset + n > this->len)\n+\t      invalid_synthetic_pointer ();\n+\n+\t    retval = allocate_value (subobj_type);\n+\t    bfd_byte *contents = value_contents_raw (retval);\n+\t    memcpy (contents, this->data + subobj_offset, n);\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_OPTIMIZED_OUT:\n+\t  retval = allocate_optimized_out_value (subobj_type);\n+\t  break;\n+\n+\t  /* DWARF_VALUE_IMPLICIT_POINTER was converted to a pieced\n+\t     operation by execute_stack_op.  */\n+\tcase DWARF_VALUE_IMPLICIT_POINTER:\n+\t  /* DWARF_VALUE_OPTIMIZED_OUT can't occur in this context --\n+\t     it can only be encountered when making a piece.  */\n+\tdefault:\n+\t  internal_error (__FILE__, __LINE__, _(\"invalid location type\"));\n+\t}\n+    }\n+\n+  set_value_initialized (retval, this->initialized);\n+\n+  return retval;\n+}\n+\n /* Require that TYPE be an integral type; throw an exception if not.  */\n \n static void"
    },
    {
      "sha": "4b94951c3a5f0c3996d27f20e499aca065bcf744",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 10,
      "deletions": 13,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "patch": "@@ -26,7 +26,6 @@\n #include \"gdbtypes.h\"\n \n struct dwarf2_per_objfile;\n-struct piece_closure;\n \n /* The location of a value.  */\n enum dwarf_value_location\n@@ -125,9 +124,13 @@ struct dwarf_expr_context\n \n   void push_address (CORE_ADDR value, bool in_stack_memory);\n   void eval (const gdb_byte *addr, size_t len);\n-  struct value *fetch (int n);\n-  CORE_ADDR fetch_address (int n);\n-  bool fetch_in_stack_memory (int n);\n+\n+  /* Fetch the result of the expression evaluation in a form of\n+     a struct value, where TYPE, SUBOBJ_TYPE and SUBOBJ_OFFSET\n+     describe the source level representation of that result.  */\n+  value *fetch_result (struct type *type = nullptr,\n+\t\t       struct type *subobj_type = nullptr,\n+\t\t       LONGEST subobj_offset = 0);\n \n   /* The stack of values.  */\n   std::vector<dwarf_stack_value> stack;\n@@ -203,6 +206,9 @@ struct dwarf_expr_context\n   void add_piece (ULONGEST size, ULONGEST offset);\n   void execute_stack_op (const gdb_byte *op_ptr, const gdb_byte *op_end);\n   void pop ();\n+  struct value *fetch (int n);\n+  CORE_ADDR fetch_address (int n);\n+  bool fetch_in_stack_memory (int n);\n \n   /* Return the location expression for the frame base attribute, in\n      START and LENGTH.  The result must be live until the current\n@@ -301,13 +307,4 @@ extern const gdb_byte *safe_read_sleb128 (const gdb_byte *buf,\n extern const gdb_byte *safe_skip_leb128 (const gdb_byte *buf,\n \t\t\t\t\t const gdb_byte *buf_end);\n \n-extern const struct lval_funcs pieced_value_funcs;\n-\n-/* Allocate a closure for a value formed from separately-described\n-   PIECES.  */\n-\n-piece_closure *allocate_piece_closure\n-  (dwarf2_per_cu_data *per_cu, dwarf2_per_objfile *per_objfile,\n-   std::vector<dwarf_expr_piece> &&pieces, frame_info *frame);\n-\n #endif /* dwarf2expr.h */"
    },
    {
      "sha": "c773034c3057513973b3d12ec6b31073e1b4b9b9",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 6,
      "deletions": 13,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "patch": "@@ -229,8 +229,6 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n \t\t  struct frame_info *this_frame, CORE_ADDR initial,\n \t\t  int initial_in_stack_memory, dwarf2_per_objfile *per_objfile)\n {\n-  CORE_ADDR result;\n-\n   dwarf_expr_context ctx (per_objfile);\n   scoped_value_mark free_values;\n \n@@ -241,18 +239,13 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n   ctx.push_address (initial, initial_in_stack_memory);\n   ctx.eval (exp, len);\n \n-  if (ctx.location == DWARF_VALUE_MEMORY)\n-    result = ctx.fetch_address (0);\n-  else if (ctx.location == DWARF_VALUE_REGISTER)\n-    result = read_addr_from_reg (this_frame, value_as_long (ctx.fetch (0)));\n+  CORE_ADDR result;\n+  struct value *result_val = ctx.fetch_result ();\n+\n+  if (VALUE_LVAL (result_val) == lval_memory)\n+    result = value_address (result_val);\n   else\n-    {\n-      /* This is actually invalid DWARF, but if we ever do run across\n-\t it somehow, we might as well support it.  So, instead, report\n-\t it as unimplemented.  */\n-      error (_(\"\\\n-Not implemented: computing unwound register using explicit value operator\"));\n-    }\n+    result = value_as_address (result_val);\n \n   return result;\n }"
    },
    {
      "sha": "894cda238a98bd794b54cb8493b8f01001af48f2",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 26,
      "deletions": 169,
      "changes": 195,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "patch": "@@ -92,7 +92,7 @@ enum debug_loc_kind\n /* Helper function which throws an error if a synthetic pointer is\n    invalid.  */\n \n-static void\n+void\n invalid_synthetic_pointer (void)\n {\n   error (_(\"access outside bounds of object \"\n@@ -1487,6 +1487,8 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   try\n     {\n       ctx.eval (data, size);\n+      retval = ctx.fetch_result (type, subobj_type,\n+\t\t\t\t subobj_byte_offset);\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -1509,155 +1511,15 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n \tthrow;\n     }\n \n-  if (ctx.pieces.size () > 0)\n-    {\n-      struct piece_closure *c;\n-      ULONGEST bit_size = 0;\n-\n-      for (dwarf_expr_piece &piece : ctx.pieces)\n-\tbit_size += piece.size;\n-      /* Complain if the expression is larger than the size of the\n-\t outer type.  */\n-      if (bit_size > 8 * TYPE_LENGTH (type))\n-\tinvalid_synthetic_pointer ();\n-\n-      c = allocate_piece_closure (per_cu, per_objfile, std::move (ctx.pieces),\n-\t\t\t\t  frame);\n-      /* We must clean up the value chain after creating the piece\n-\t closure but before allocating the result.  */\n-      free_values.free_to_mark ();\n-      retval = allocate_computed_value (subobj_type,\n-\t\t\t\t\t&pieced_value_funcs, c);\n-      set_value_offset (retval, subobj_byte_offset);\n-    }\n-  else\n-    {\n-      switch (ctx.location)\n-\t{\n-\tcase DWARF_VALUE_REGISTER:\n-\t  {\n-\t    struct gdbarch *arch = get_frame_arch (frame);\n-\t    int dwarf_regnum\n-\t      = longest_to_int (value_as_long (ctx.fetch (0)));\n-\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (arch, dwarf_regnum);\n-\n-\t    if (subobj_byte_offset != 0)\n-\t      error (_(\"cannot use offset on synthetic pointer to register\"));\n-\t    free_values.free_to_mark ();\n-\t    retval = value_from_register (subobj_type, gdb_regnum, frame);\n-\t    if (value_optimized_out (retval))\n-\t      {\n-\t\tstruct value *tmp;\n-\n-\t\t/* This means the register has undefined value / was\n-\t\t   not saved.  As we're computing the location of some\n-\t\t   variable etc. in the program, not a value for\n-\t\t   inspecting a register ($pc, $sp, etc.), return a\n-\t\t   generic optimized out value instead, so that we show\n-\t\t   <optimized out> instead of <not saved>.  */\n-\t\ttmp = allocate_value (subobj_type);\n-\t\tvalue_contents_copy (tmp, 0, retval, 0,\n-\t\t\t\t     TYPE_LENGTH (subobj_type));\n-\t\tretval = tmp;\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_MEMORY:\n-\t  {\n-\t    struct type *ptr_type;\n-\t    CORE_ADDR address = ctx.fetch_address (0);\n-\t    bool in_stack_memory = ctx.fetch_in_stack_memory (0);\n-\n-\t    /* DW_OP_deref_size (and possibly other operations too) may\n-\t       create a pointer instead of an address.  Ideally, the\n-\t       pointer to address conversion would be performed as part\n-\t       of those operations, but the type of the object to\n-\t       which the address refers is not known at the time of\n-\t       the operation.  Therefore, we do the conversion here\n-\t       since the type is readily available.  */\n-\n-\t    switch (subobj_type->code ())\n-\t      {\n-\t\tcase TYPE_CODE_FUNC:\n-\t\tcase TYPE_CODE_METHOD:\n-\t\t  ptr_type = builtin_type (ctx.gdbarch)->builtin_func_ptr;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  ptr_type = builtin_type (ctx.gdbarch)->builtin_data_ptr;\n-\t\t  break;\n-\t      }\n-\t    address = value_as_address (value_from_pointer (ptr_type, address));\n-\n-\t    free_values.free_to_mark ();\n-\t    retval = value_at_lazy (subobj_type,\n-\t\t\t\t    address + subobj_byte_offset);\n-\t    if (in_stack_memory)\n-\t      set_value_stack (retval, 1);\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_STACK:\n-\t  {\n-\t    struct value *value = ctx.fetch (0);\n-\t    size_t n = TYPE_LENGTH (value_type (value));\n-\t    size_t len = TYPE_LENGTH (subobj_type);\n-\t    size_t max = TYPE_LENGTH (type);\n-\t    gdbarch *objfile_gdbarch = per_objfile->objfile->arch ();\n-\n-\t    if (subobj_byte_offset + len > max)\n-\t      invalid_synthetic_pointer ();\n-\n-\t    /* Preserve VALUE because we are going to free values back\n-\t       to the mark, but we still need the value contents\n-\t       below.  */\n-\t    value_ref_ptr value_holder = value_ref_ptr::new_reference (value);\n-\t    free_values.free_to_mark ();\n-\n-\t    retval = allocate_value (subobj_type);\n-\n-\t    /* The given offset is relative to the actual object.  */\n-\t    if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)\n-\t      subobj_byte_offset += n - max;\n-\n-\t    memcpy (value_contents_raw (retval),\n-\t\t    value_contents_all (value) + subobj_byte_offset, len);\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_LITERAL:\n-\t  {\n-\t    bfd_byte *contents;\n-\t    size_t n = TYPE_LENGTH (subobj_type);\n-\n-\t    if (subobj_byte_offset + n > ctx.len)\n-\t      invalid_synthetic_pointer ();\n-\n-\t    free_values.free_to_mark ();\n-\t    retval = allocate_value (subobj_type);\n-\t    contents = value_contents_raw (retval);\n-\t    memcpy (contents, ctx.data + subobj_byte_offset, n);\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_OPTIMIZED_OUT:\n-\t  free_values.free_to_mark ();\n-\t  retval = allocate_optimized_out_value (subobj_type);\n-\t  break;\n-\n-\t  /* DWARF_VALUE_IMPLICIT_POINTER was converted to a pieced\n-\t     operation by execute_stack_op.  */\n-\tcase DWARF_VALUE_IMPLICIT_POINTER:\n-\t  /* DWARF_VALUE_OPTIMIZED_OUT can't occur in this context --\n-\t     it can only be encountered when making a piece.  */\n-\tdefault:\n-\t  internal_error (__FILE__, __LINE__, _(\"invalid location type\"));\n-\t}\n-    }\n-\n-  set_value_initialized (retval, ctx.initialized);\n+  /* We need to clean up all the values that are not needed any more.\n+     The problem with a value_ref_ptr class is that it disconnects the\n+     RETVAL from the value garbage collection, so we need to make\n+     a copy of that value on the stack to keep everything consistent.\n+     The value_ref_ptr will clean up after itself at the end of this block.  */\n+  value_ref_ptr value_holder = value_ref_ptr::new_reference (retval);\n+  free_values.free_to_mark ();\n \n-  return retval;\n+  return value_copy (retval);\n }\n \n /* The exported interface to dwarf2_evaluate_loc_desc_full; it always\n@@ -1698,6 +1560,9 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   dwarf2_per_objfile *per_objfile = dlbaton->per_objfile;\n   dwarf_expr_context ctx (per_objfile);\n \n+  struct value *result;\n+  scoped_value_mark free_values;\n+\n   ctx.frame = frame;\n   ctx.per_cu = dlbaton->per_cu;\n   if (addr_stack != nullptr)\n@@ -1715,6 +1580,7 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   try\n     {\n       ctx.eval (dlbaton->data, dlbaton->size);\n+      result = ctx.fetch_result ();\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -1732,29 +1598,20 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n \tthrow;\n     }\n \n-  switch (ctx.location)\n+  if (value_optimized_out (result))\n+    return 0;\n+\n+  if (VALUE_LVAL (result) == lval_memory)\n+    *valp = value_address (result);\n+  else\n     {\n-    case DWARF_VALUE_STACK:\n-      *is_reference = false;\n-      /* FALLTHROUGH */\n-\n-    case DWARF_VALUE_REGISTER:\n-    case DWARF_VALUE_MEMORY:\n-      *valp = ctx.fetch_address (0);\n-      if (ctx.location == DWARF_VALUE_REGISTER)\n-\t*valp = read_addr_from_reg (frame, *valp);\n-      return 1;\n-    case DWARF_VALUE_LITERAL:\n-      *valp = extract_signed_integer (ctx.data, ctx.len,\n-\t\t\t\t      gdbarch_byte_order (ctx.gdbarch));\n-      return 1;\n-      /* Unsupported dwarf values.  */\n-    case DWARF_VALUE_OPTIMIZED_OUT:\n-    case DWARF_VALUE_IMPLICIT_POINTER:\n-      break;\n+      if (VALUE_LVAL (result) == not_lval)\n+\t*is_reference = false;\n+\n+      *valp = value_as_address (result);\n     }\n \n-  return 0;\n+  return 1;\n }\n \n /* See dwarf2loc.h.  */"
    },
    {
      "sha": "5d964b07a5035143fc8278d66a90a675a552360e",
      "filename": "gdb/dwarf2/loc.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51/gdb/dwarf2/loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.h?ref=ba5bc3e5a9268bcdc701d5a6701a9b41538a3f51",
      "patch": "@@ -280,6 +280,11 @@ extern int dwarf_reg_to_regnum (struct gdbarch *arch, int dwarf_reg);\n extern int dwarf_reg_to_regnum_or_error (struct gdbarch *arch,\n \t\t\t\t\t ULONGEST dwarf_reg);\n \n+/* Helper function which throws an error if a synthetic pointer is\n+   invalid.  */\n+\n+extern void invalid_synthetic_pointer ();\n+\n /* Fetch the value pointed to by a synthetic pointer.  */\n \n extern struct value *indirect_synthetic_pointer"
    }
  ]
}