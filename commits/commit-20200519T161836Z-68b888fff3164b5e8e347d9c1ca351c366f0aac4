{
  "sha": "68b888fff3164b5e8e347d9c1ca351c366f0aac4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjhiODg4ZmZmMzE2NGI1ZThlMzQ3ZDljMWNhMzUxYzM2NmYwYWFjNA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-19T16:18:04Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-19T16:18:36Z"
    },
    "message": "gdb: use std::vector to store segments in symfile_segment_data\n\nInstead of maintaining two vectors, I added a small `segment` class\nwhich holds both the base address and size of one segment and replaced\nthe two `segment_bases` and `segment_sizes` arrays with a single vector.\n\nThe rest of the changes are straightforward, no behavior changes are\nexpected.\n\ngdb/ChangeLog:\n\n\t* symfile.h (struct symfile_segment_data) <struct segment>: New.\n\t<segments>: New.\n\t<segment_bases, segment_sizes>: Remove.\n\t* symfile.c (default_symfile_segments): Update.\n\t* elfread.c (elf_symfile_segments): Update.\n\t* remote.c (remote_target::get_offsets): Update.\n\t* solib-target.c (solib_target_relocate_section_addresses):\n\tUpdate.",
    "tree": {
      "sha": "407df662edc349c3ec33bf23379f33d3bce06cd4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/407df662edc349c3ec33bf23379f33d3bce06cd4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/68b888fff3164b5e8e347d9c1ca351c366f0aac4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68b888fff3164b5e8e347d9c1ca351c366f0aac4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/68b888fff3164b5e8e347d9c1ca351c366f0aac4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/68b888fff3164b5e8e347d9c1ca351c366f0aac4/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62982abdee45cb20a7cfadb2b1bcc358655d4ad3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/62982abdee45cb20a7cfadb2b1bcc358655d4ad3"
    }
  ],
  "stats": {
    "total": 86,
    "additions": 45,
    "deletions": 41
  },
  "files": [
    {
      "sha": "c9f4a5ebb0282f4b5c50eb7c12e4ce74155cf505",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -1,3 +1,14 @@\n+2020-05-19  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* symfile.h (struct symfile_segment_data) <struct segment>: New.\n+\t<segments>: New.\n+\t<segment_bases, segment_sizes>: Remove.\n+\t* symfile.c (default_symfile_segments): Update.\n+\t* elfread.c (elf_symfile_segments): Update.\n+\t* remote.c (remote_target::get_offsets): Update.\n+\t* solib-target.c (solib_target_relocate_section_addresses):\n+\tUpdate.\n+\n 2020-05-19  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* symfile.h (struct symfile_segment_data): Initialize fields."
    },
    {
      "sha": "4318ebf9eb9b9ea5ef9b66f6f1905d01da555f98",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -112,15 +112,10 @@ elf_symfile_segments (bfd *abfd)\n     return NULL;\n \n   symfile_segment_data_up data (new symfile_segment_data);\n-  data->num_segments = num_segments;\n-  data->segment_bases = XCNEWVEC (CORE_ADDR, num_segments);\n-  data->segment_sizes = XCNEWVEC (CORE_ADDR, num_segments);\n+  data->segments.reserve (num_segments);\n \n   for (i = 0; i < num_segments; i++)\n-    {\n-      data->segment_bases[i] = segments[i]->p_vaddr;\n-      data->segment_sizes[i] = segments[i]->p_memsz;\n-    }\n+    data->segments.emplace_back (segments[i]->p_vaddr, segments[i]->p_memsz);\n \n   num_sections = bfd_count_sections (abfd);\n   data->segment_info = XCNEWVEC (int, num_sections);"
    },
    {
      "sha": "312a03c8fb42d2c256a049812eff5e19cb58a91f",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -4198,20 +4198,20 @@ remote_target::get_offsets ()\n      by assuming that the .text and .data offsets apply to the whole\n      text and data segments.  Convert the offsets given in the packet\n      to base addresses for symfile_map_offsets_to_segments.  */\n-  else if (data && data->num_segments == 2)\n+  else if (data != nullptr && data->segments.size () == 2)\n     {\n-      segments[0] = data->segment_bases[0] + text_addr;\n-      segments[1] = data->segment_bases[1] + data_addr;\n+      segments[0] = data->segments[0].base + text_addr;\n+      segments[1] = data->segments[1].base + data_addr;\n       num_segments = 2;\n     }\n   /* If the object file has only one segment, assume that it is text\n      rather than data; main programs with no writable data are rare,\n      but programs with no code are useless.  Of course the code might\n      have ended up in the data segment... to detect that we would need\n      the permissions here.  */\n-  else if (data && data->num_segments == 1)\n+  else if (data && data->segments.size () == 1)\n     {\n-      segments[0] = data->segment_bases[0] + text_addr;\n+      segments[0] = data->segments[0].base + text_addr;\n       num_segments = 1;\n     }\n   /* There's no way to relocate by segment.  */"
    },
    {
      "sha": "ba056478c061f22deb9dc692c2f324ce430c8a2f",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -386,9 +386,9 @@ Could not relocate shared library \\\"%s\\\": bad offsets\"), so->so_name);\n \t\t \"info sharedlibrary\".  Report any consecutive segments\n \t\t which were relocated as a single unit.  */\n \t      gdb_assert (li->segment_bases.size () > 0);\n-\t      orig_delta = li->segment_bases[0] - data->segment_bases[0];\n+\t      orig_delta = li->segment_bases[0] - data->segments[0].base;\n \n-\t      for (i = 1; i < data->num_segments; i++)\n+\t      for (i = 1; i < data->segments.size (); i++)\n \t\t{\n \t\t  /* If we have run out of offsets, assume all\n \t\t     remaining segments have the same offset.  */\n@@ -397,14 +397,14 @@ Could not relocate shared library \\\"%s\\\": bad offsets\"), so->so_name);\n \n \t\t  /* If this segment does not have the same offset, do\n \t\t     not include it in the library's range.  */\n-\t\t  if (li->segment_bases[i] - data->segment_bases[i]\n+\t\t  if (li->segment_bases[i] - data->segments[i].base\n \t\t      != orig_delta)\n \t\t    break;\n \t\t}\n \n \t      so->addr_low = li->segment_bases[0];\n-\t      so->addr_high = (data->segment_bases[i - 1]\n-\t\t\t       + data->segment_sizes[i - 1]\n+\t      so->addr_high = (data->segments[i - 1].base\n+\t\t\t       + data->segments[i - 1].size\n \t\t\t       + orig_delta);\n \t      gdb_assert (so->addr_low <= so->addr_high);\n \t    }"
    },
    {
      "sha": "22793e736398c0da9c7eca22ecd85007c0a81a91",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -745,9 +745,6 @@ default_symfile_segments (bfd *abfd)\n   high = low + bfd_section_size (sect);\n \n   symfile_segment_data_up data (new symfile_segment_data);\n-  data->num_segments = 1;\n-  data->segment_bases = XCNEW (CORE_ADDR);\n-  data->segment_sizes = XCNEW (CORE_ADDR);\n \n   num_sections = bfd_count_sections (abfd);\n   data->segment_info = XCNEWVEC (int, num_sections);\n@@ -768,8 +765,7 @@ default_symfile_segments (bfd *abfd)\n       data->segment_info[i] = 1;\n     }\n \n-  data->segment_bases[0] = low;\n-  data->segment_sizes[0] = high - low;\n+  data->segments.emplace_back (low, high - low);\n \n   return data;\n }\n@@ -3663,13 +3659,13 @@ symfile_map_offsets_to_segments (bfd *abfd,\n   /* If we do not have segment mappings for the object file, we\n      can not relocate it by segments.  */\n   gdb_assert (data != NULL);\n-  gdb_assert (data->num_segments > 0);\n+  gdb_assert (data->segments.size () > 0);\n \n   for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)\n     {\n       int which = data->segment_info[i];\n \n-      gdb_assert (0 <= which && which <= data->num_segments);\n+      gdb_assert (0 <= which && which <= data->segments.size ());\n \n       /* Don't bother computing offsets for sections that aren't\n          loaded as part of any segment.  */\n@@ -3681,7 +3677,7 @@ symfile_map_offsets_to_segments (bfd *abfd,\n       if (which > num_segment_bases)\n         which = num_segment_bases;\n \n-      offsets[i] = segment_bases[which - 1] - data->segment_bases[which - 1];\n+      offsets[i] = segment_bases[which - 1] - data->segments[which - 1].base;\n     }\n \n   return 1;\n@@ -3699,7 +3695,7 @@ symfile_find_segment_sections (struct objfile *objfile)\n   if (data == NULL)\n     return;\n \n-  if (data->num_segments != 1 && data->num_segments != 2)\n+  if (data->segments.size () != 1 && data->segments.size () != 2)\n     return;\n \n   for (i = 0, sect = abfd->sections; sect != NULL; i++, sect = sect->next)"
    },
    {
      "sha": "1f2395169af984eded7438a5ca73d10901c8a391",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 17,
      "deletions": 15,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/68b888fff3164b5e8e347d9c1ca351c366f0aac4/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=68b888fff3164b5e8e347d9c1ca351c366f0aac4",
      "patch": "@@ -80,29 +80,31 @@ typedef std::vector<other_sections> section_addr_info;\n    each BFD section belongs to.  */\n struct symfile_segment_data\n {\n+  struct segment\n+  {\n+    segment (CORE_ADDR base, CORE_ADDR size)\n+      : base (base), size (size)\n+    {}\n+\n+    /* The original base address the segment.  */\n+    CORE_ADDR base;\n+\n+    /* The memory size of the segment.  */\n+    CORE_ADDR size;\n+  };\n+\n   ~symfile_segment_data ()\n   {\n-    xfree (this->segment_bases);\n-    xfree (this->segment_sizes);\n     xfree (this->segment_info);\n   }\n \n-  /* How many segments are present in this file.  If there are\n+  /* The segments present in this file.  If there are\n      two, the text segment is the first one and the data segment\n      is the second one.  */\n-  int num_segments = 0;\n-\n-  /* If NUM_SEGMENTS is greater than zero, the original base address\n-     of each segment.  */\n-  CORE_ADDR *segment_bases = nullptr;\n-\n-  /* If NUM_SEGMENTS is greater than zero, the memory size of each\n-     segment.  */\n-  CORE_ADDR *segment_sizes = nullptr;\n+  std::vector<segment> segments;\n \n-  /* If NUM_SEGMENTS is greater than zero, this is an array of entries\n-     recording which segment contains each BFD section.\n-     SEGMENT_INFO[I] is S+1 if the I'th BFD section belongs to segment\n+  /* This is an array of entries recording which segment contains each BFD\n+     section.  SEGMENT_INFO[I] is S+1 if the I'th BFD section belongs to segment\n      S, or zero if it is not in any segment.  */\n   int *segment_info = nullptr;\n };"
    }
  ]
}