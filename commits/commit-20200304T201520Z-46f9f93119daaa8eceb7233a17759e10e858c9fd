{
  "sha": "46f9f93119daaa8eceb7233a17759e10e858c9fd",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDZmOWY5MzExOWRhYWE4ZWNlYjcyMzNhMTc3NTllMTBlODU4YzlmZA==",
  "commit": {
    "author": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-01-26T21:04:04Z"
    },
    "committer": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-03-04T20:15:20Z"
    },
    "message": "Implement debugging of WOW64 processes\n\nFor WOW64 processes, the Wow64* variants of SuspendThread,\nGetThreadContext, SetThreadContext, and GetThreadSelectorEntry have to\nbe used instead.\nAnd instead of EnumProcessModules, EnumProcessModulesEx with\nLIST_MODULES_32BIT is necessary.\n\ngdb/ChangeLog:\n\n2020-03-04  Hannes Domani  <ssbssa@yahoo.de>\n\n\t* NEWS: Mention support for WOW64 processes.\n\t* amd64-windows-nat.c (amd64_mappings): Rename and remove static.\n\t(amd64_windows_segment_register_p): Remove static.\n\t(_initialize_amd64_windows_nat): Update.\n\t* configure.nat <windows> (NATDEPFILES): Add i386-windows-nat.o.\n\t* i386-windows-nat.c (context_offset): Update.\n\t(i386_mappings): Rename and remove static.\n\t(i386_windows_segment_register_p): Remove static.\n\t(_initialize_i386_windows_nat): Update.\n\t* windows-nat.c (STATUS_WX86_BREAKPOINT): New macro.\n\t(STATUS_WX86_SINGLE_STEP): New macro.\n\t(EnumProcessModulesEx): New macro.\n\t(Wow64SuspendThread): New macro.\n\t(Wow64GetThreadContext): New macro.\n\t(Wow64SetThreadContext): New macro.\n\t(Wow64GetThreadSelectorEntry): New macro.\n\t(windows_set_context_register_offsets): Add static.\n\t(windows_set_segment_register_p): Likewise.\n\t(windows_add_thread): Adapt for WOW64 processes.\n\t(windows_fetch_one_register): Likewise.\n\t(windows_nat_target::fetch_registers): Likewise.\n\t(windows_store_one_register): Likewise.\n\t(display_selector): Likewise.\n\t(display_selectors): Likewise.\n\t(handle_exception): Likewise.\n\t(windows_continue): Likewise.\n\t(windows_nat_target::resume): Likewise.\n\t(windows_add_all_dlls): Likewise.\n\t(do_initial_windows_stuff): Likewise.\n\t(windows_nat_target::attach): Likewise.\n\t(windows_get_exec_module_filename): Likewise.\n\t(windows_nat_target::create_inferior): Likewise.\n\t(windows_xfer_siginfo): Likewise.\n\t(_initialize_loadable): Initialize Wow64SuspendThread,\n\tWow64GetThreadContext, Wow64SetThreadContext,\n\tWow64GetThreadSelectorEntry and EnumProcessModulesEx.\n\t* windows-nat.h (windows_set_context_register_offsets):\n\tRemove declaration.\n\t(windows_set_segment_register_p): Likewise.\n\t(i386_windows_segment_register_p): Add declaration.\n\t(amd64_windows_segment_register_p): Likewise.",
    "tree": {
      "sha": "7a2dcb557732eab4a173d0d2e336a1eb071be521",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7a2dcb557732eab4a173d0d2e336a1eb071be521"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/46f9f93119daaa8eceb7233a17759e10e858c9fd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46f9f93119daaa8eceb7233a17759e10e858c9fd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/46f9f93119daaa8eceb7233a17759e10e858c9fd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46f9f93119daaa8eceb7233a17759e10e858c9fd/comments",
  "author": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "749479c8d3b63c9075d2fabf4b87b1f7109608b6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/749479c8d3b63c9075d2fabf4b87b1f7109608b6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/749479c8d3b63c9075d2fabf4b87b1f7109608b6"
    }
  ],
  "stats": {
    "total": 563,
    "additions": 463,
    "deletions": 100
  },
  "files": [
    {
      "sha": "51785c761271f881d723651c7b5b71eb9152271e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -1,3 +1,47 @@\n+2020-03-04  Hannes Domani  <ssbssa@yahoo.de>\n+\n+\t* NEWS: Mention support for WOW64 processes.\n+\t* amd64-windows-nat.c (amd64_mappings): Rename and remove static.\n+\t(amd64_windows_segment_register_p): Remove static.\n+\t(_initialize_amd64_windows_nat): Update.\n+\t* configure.nat <windows> (NATDEPFILES): Add i386-windows-nat.o.\n+\t* i386-windows-nat.c (context_offset): Update.\n+\t(i386_mappings): Rename and remove static.\n+\t(i386_windows_segment_register_p): Remove static.\n+\t(_initialize_i386_windows_nat): Update.\n+\t* windows-nat.c (STATUS_WX86_BREAKPOINT): New macro.\n+\t(STATUS_WX86_SINGLE_STEP): New macro.\n+\t(EnumProcessModulesEx): New macro.\n+\t(Wow64SuspendThread): New macro.\n+\t(Wow64GetThreadContext): New macro.\n+\t(Wow64SetThreadContext): New macro.\n+\t(Wow64GetThreadSelectorEntry): New macro.\n+\t(windows_set_context_register_offsets): Add static.\n+\t(windows_set_segment_register_p): Likewise.\n+\t(windows_add_thread): Adapt for WOW64 processes.\n+\t(windows_fetch_one_register): Likewise.\n+\t(windows_nat_target::fetch_registers): Likewise.\n+\t(windows_store_one_register): Likewise.\n+\t(display_selector): Likewise.\n+\t(display_selectors): Likewise.\n+\t(handle_exception): Likewise.\n+\t(windows_continue): Likewise.\n+\t(windows_nat_target::resume): Likewise.\n+\t(windows_add_all_dlls): Likewise.\n+\t(do_initial_windows_stuff): Likewise.\n+\t(windows_nat_target::attach): Likewise.\n+\t(windows_get_exec_module_filename): Likewise.\n+\t(windows_nat_target::create_inferior): Likewise.\n+\t(windows_xfer_siginfo): Likewise.\n+\t(_initialize_loadable): Initialize Wow64SuspendThread,\n+\tWow64GetThreadContext, Wow64SetThreadContext,\n+\tWow64GetThreadSelectorEntry and EnumProcessModulesEx.\n+\t* windows-nat.h (windows_set_context_register_offsets):\n+\tRemove declaration.\n+\t(windows_set_segment_register_p): Likewise.\n+\t(i386_windows_segment_register_p): Add declaration.\n+\t(amd64_windows_segment_register_p): Likewise.\n+\n 2020-03-04  Luis Machado  <luis.machado@linaro.org>\n \n \tRevert aa66aac47b4dd38f9524ddb5546c08cc09930d37 due to regressions"
    },
    {
      "sha": "4dc6b33b650600ea11809db3485ea60333858516",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -39,6 +39,9 @@\n   string is that GDB will not try to load any previous command\n   history.\n \n+* On Windows targets, it is now possible to debug 32-bit programs with a\n+  64-bit GDB.\n+\n * New commands\n \n set exec-file-mismatch -- Set exec-file-mismatch handling (ask|warn|off)."
    },
    {
      "sha": "6f185ad15becde9f652be4d73fd776cbdd02f12d",
      "filename": "gdb/amd64-windows-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/amd64-windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/amd64-windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-nat.c?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -23,7 +23,7 @@\n #include <windows.h>\n \n #define context_offset(x) (offsetof (CONTEXT, x))\n-static const int mappings[] =\n+const int amd64_mappings[] =\n {\n   context_offset (Rax),\n   context_offset (Rbx),\n@@ -89,7 +89,7 @@ static const int mappings[] =\n \n /* segment_register_p_ftype implementation for amd64.  */\n \n-static int\n+int\n amd64_windows_segment_register_p (int regnum)\n {\n   return regnum >= AMD64_CS_REGNUM && regnum <= AMD64_GS_REGNUM;\n@@ -99,7 +99,5 @@ void _initialize_amd64_windows_nat ();\n void\n _initialize_amd64_windows_nat ()\n {\n-  windows_set_context_register_offsets (mappings);\n-  windows_set_segment_register_p (amd64_windows_segment_register_p);\n   x86_set_debug_register_length (8);\n }"
    },
    {
      "sha": "83ffdb80486d9f993e1e5e081a84dfcae5f11daf",
      "filename": "gdb/configure.nat",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/configure.nat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/configure.nat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.nat?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -137,7 +137,7 @@ case ${gdb_host} in\n \t    i386)\n \t\t# Native config information for GDB on amd64\n \t\t# systems running Cygwin.\n-\t\tNATDEPFILES=\"${NATDEPFILES} amd64-windows-nat.o\"\n+\t\tNATDEPFILES=\"${NATDEPFILES} i386-windows-nat.o amd64-windows-nat.o\"\n \t\t;;\n \tesac\n \t;;\n@@ -325,7 +325,7 @@ case ${gdb_host} in\n     mingw64)\n \tcase ${gdb_host_cpu} in\n \t    i386)\n-\t\tNATDEPFILES=\"${NATDEPFILES} amd64-windows-nat.o\"\n+\t\tNATDEPFILES=\"${NATDEPFILES} i386-windows-nat.o amd64-windows-nat.o\"\n \t\t;;\n \tesac\n \t;;"
    },
    {
      "sha": "3091fc362825aa2cac685301f99145f608952139",
      "filename": "gdb/i386-windows-nat.c",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/i386-windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/i386-windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-nat.c?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -22,8 +22,11 @@\n \n #include <windows.h>\n \n-#define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))\n-static const int mappings[] =\n+#ifdef __x86_64__\n+#define CONTEXT WOW64_CONTEXT\n+#endif\n+#define context_offset(x) ((int)(size_t)&(((CONTEXT *)NULL)->x))\n+const int i386_mappings[] =\n {\n   context_offset (Eax),\n   context_offset (Ecx),\n@@ -70,10 +73,11 @@ static const int mappings[] =\n   context_offset (ExtendedRegisters[24])\n };\n #undef context_offset\n+#undef CONTEXT\n \n /* segment_register_p_ftype implementation for x86.  */\n \n-static int\n+int\n i386_windows_segment_register_p (int regnum)\n {\n   return regnum >= I386_CS_REGNUM && regnum <= I386_GS_REGNUM;\n@@ -83,7 +87,7 @@ void _initialize_i386_windows_nat ();\n void\n _initialize_i386_windows_nat ()\n {\n-  windows_set_context_register_offsets (mappings);\n-  windows_set_segment_register_p (i386_windows_segment_register_p);\n+#ifndef __x86_64__\n   x86_set_debug_register_length (4);\n+#endif\n }"
    },
    {
      "sha": "614b235edeac8c2bae374df3e4427cf4d64d0ff6",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 390,
      "deletions": 84,
      "changes": 474,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -70,16 +70,24 @@\n #include \"gdbsupport/pathstuff.h\"\n #include \"gdbsupport/gdb_wait.h\"\n \n+#define STATUS_WX86_BREAKPOINT 0x4000001F\n+#define STATUS_WX86_SINGLE_STEP 0x4000001E\n+\n #define AdjustTokenPrivileges\t\tdyn_AdjustTokenPrivileges\n #define DebugActiveProcessStop\t\tdyn_DebugActiveProcessStop\n #define DebugBreakProcess\t\tdyn_DebugBreakProcess\n #define DebugSetProcessKillOnExit\tdyn_DebugSetProcessKillOnExit\n #define EnumProcessModules\t\tdyn_EnumProcessModules\n+#define EnumProcessModulesEx\t\tdyn_EnumProcessModulesEx\n #define GetModuleInformation\t\tdyn_GetModuleInformation\n #define LookupPrivilegeValueA\t\tdyn_LookupPrivilegeValueA\n #define OpenProcessToken\t\tdyn_OpenProcessToken\n #define GetConsoleFontSize\t\tdyn_GetConsoleFontSize\n #define GetCurrentConsoleFont\t\tdyn_GetCurrentConsoleFont\n+#define Wow64SuspendThread\t\tdyn_Wow64SuspendThread\n+#define Wow64GetThreadContext\t\tdyn_Wow64GetThreadContext\n+#define Wow64SetThreadContext\t\tdyn_Wow64SetThreadContext\n+#define Wow64GetThreadSelectorEntry\tdyn_Wow64GetThreadSelectorEntry\n \n typedef BOOL WINAPI (AdjustTokenPrivileges_ftype) (HANDLE, BOOL,\n \t\t\t\t\t\t   PTOKEN_PRIVILEGES,\n@@ -100,6 +108,12 @@ typedef BOOL WINAPI (EnumProcessModules_ftype) (HANDLE, HMODULE *, DWORD,\n \t\t\t\t\t\tLPDWORD);\n static EnumProcessModules_ftype *EnumProcessModules;\n \n+#ifdef __x86_64__\n+typedef BOOL WINAPI (EnumProcessModulesEx_ftype) (HANDLE, HMODULE *, DWORD,\n+\t\t\t\t\t\t  LPDWORD, DWORD);\n+static EnumProcessModulesEx_ftype *EnumProcessModulesEx;\n+#endif\n+\n typedef BOOL WINAPI (GetModuleInformation_ftype) (HANDLE, HMODULE,\n \t\t\t\t\t\t  LPMODULEINFO, DWORD);\n static GetModuleInformation_ftype *GetModuleInformation;\n@@ -117,6 +131,22 @@ static GetCurrentConsoleFont_ftype *GetCurrentConsoleFont;\n typedef COORD WINAPI (GetConsoleFontSize_ftype) (HANDLE, DWORD);\n static GetConsoleFontSize_ftype *GetConsoleFontSize;\n \n+#ifdef __x86_64__\n+typedef DWORD WINAPI (Wow64SuspendThread_ftype) (HANDLE);\n+static Wow64SuspendThread_ftype *Wow64SuspendThread;\n+\n+typedef BOOL WINAPI (Wow64GetThreadContext_ftype) (HANDLE, PWOW64_CONTEXT);\n+static Wow64GetThreadContext_ftype *Wow64GetThreadContext;\n+\n+typedef BOOL WINAPI (Wow64SetThreadContext_ftype) (HANDLE,\n+\t\t\t\t\t\t   const WOW64_CONTEXT *);\n+static Wow64SetThreadContext_ftype *Wow64SetThreadContext;\n+\n+typedef BOOL WINAPI (Wow64GetThreadSelectorEntry_ftype) (HANDLE, DWORD,\n+\t\t\t\t\t\t\t PLDT_ENTRY);\n+static Wow64GetThreadSelectorEntry_ftype *Wow64GetThreadSelectorEntry;\n+#endif\n+\n #undef STARTUPINFO\n #undef CreateProcess\n #undef GetModuleFileNameEx\n@@ -224,7 +254,13 @@ typedef struct windows_thread_info_struct\n     char *name;\n     int suspended;\n     int reload_context;\n-    CONTEXT context;\n+    union\n+      {\n+\tCONTEXT context;\n+#ifdef __x86_64__\n+\tWOW64_CONTEXT wow64_context;\n+#endif\n+      };\n   }\n windows_thread_info;\n \n@@ -243,6 +279,10 @@ static int exception_count = 0;\n static int event_count = 0;\n static int saw_create;\n static int open_process_used = 0;\n+#ifdef __x86_64__\n+static bool wow64_process = false;\n+static bool ignore_first_breakpoint = false;\n+#endif\n \n /* User options.  */\n static bool new_console = false;\n@@ -360,15 +400,16 @@ static windows_nat_target the_windows_nat_target;\n /* Set the MAPPINGS static global to OFFSETS.\n    See the description of MAPPINGS for more details.  */\n \n-void\n+static void\n windows_set_context_register_offsets (const int *offsets)\n {\n   mappings = offsets;\n }\n \n-/* See windows-nat.h.  */\n+/* Set the function that should be used by this module to determine\n+   whether a given register is a segment register or not.  */\n \n-void\n+static void\n windows_set_segment_register_p (segment_register_p_ftype *fun)\n {\n   segment_register_p = fun;\n@@ -452,6 +493,12 @@ windows_add_thread (ptid_t ptid, HANDLE h, void *tlb, bool main_thread_p)\n   th->id = id;\n   th->h = h;\n   th->thread_local_base = (CORE_ADDR) (uintptr_t) tlb;\n+#ifdef __x86_64__\n+  /* For WOW64 processes, this is actually the pointer to the 64bit TIB,\n+     and the 32bit TIB is exactly 2 pages after it.  */\n+  if (wow64_process)\n+    th->thread_local_base += 0x2000;\n+#endif\n   th->next = thread_head.next;\n   thread_head.next = th;\n \n@@ -468,17 +515,36 @@ windows_add_thread (ptid_t ptid, HANDLE h, void *tlb, bool main_thread_p)\n   /* Set the debug registers for the new thread if they are used.  */\n   if (debug_registers_used)\n     {\n-      /* Only change the value of the debug registers.  */\n-      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n-      CHECK (GetThreadContext (th->h, &th->context));\n-      th->context.Dr0 = dr[0];\n-      th->context.Dr1 = dr[1];\n-      th->context.Dr2 = dr[2];\n-      th->context.Dr3 = dr[3];\n-      th->context.Dr6 = DR6_CLEAR_VALUE;\n-      th->context.Dr7 = dr[7];\n-      CHECK (SetThreadContext (th->h, &th->context));\n-      th->context.ContextFlags = 0;\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\t{\n+\t  /* Only change the value of the debug registers.  */\n+\t  th->wow64_context.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n+\t  CHECK (Wow64GetThreadContext (th->h, &th->wow64_context));\n+\t  th->wow64_context.Dr0 = dr[0];\n+\t  th->wow64_context.Dr1 = dr[1];\n+\t  th->wow64_context.Dr2 = dr[2];\n+\t  th->wow64_context.Dr3 = dr[3];\n+\t  th->wow64_context.Dr6 = DR6_CLEAR_VALUE;\n+\t  th->wow64_context.Dr7 = dr[7];\n+\t  CHECK (Wow64SetThreadContext (th->h, &th->wow64_context));\n+\t  th->wow64_context.ContextFlags = 0;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  /* Only change the value of the debug registers.  */\n+\t  th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;\n+\t  CHECK (GetThreadContext (th->h, &th->context));\n+\t  th->context.Dr0 = dr[0];\n+\t  th->context.Dr1 = dr[1];\n+\t  th->context.Dr2 = dr[2];\n+\t  th->context.Dr3 = dr[3];\n+\t  th->context.Dr6 = DR6_CLEAR_VALUE;\n+\t  th->context.Dr7 = dr[7];\n+\t  CHECK (SetThreadContext (th->h, &th->context));\n+\t  th->context.ContextFlags = 0;\n+\t}\n     }\n   return th;\n }\n@@ -565,7 +631,13 @@ windows_fetch_one_register (struct regcache *regcache,\n   gdb_assert (r >= 0);\n   gdb_assert (!th->reload_context);\n \n-  char *context_offset = ((char *) &th->context) + mappings[r];\n+  char *context_ptr = (char *) &th->context;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    context_ptr = (char *) &th->wow64_context;\n+#endif\n+\n+  char *context_offset = context_ptr + mappings[r];\n   struct gdbarch *gdbarch = regcache->arch ();\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n@@ -616,6 +688,26 @@ windows_nat_target::fetch_registers (struct regcache *regcache, int r)\n \t  have_saved_context = 0;\n \t}\n       else\n+#endif\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\t{\n+\t  th->wow64_context.ContextFlags = CONTEXT_DEBUGGER_DR;\n+\t  CHECK (Wow64GetThreadContext (th->h, &th->wow64_context));\n+\t  /* Copy dr values from that thread.\n+\t     But only if there were not modified since last stop.\n+\t     PR gdb/2388 */\n+\t  if (!debug_registers_changed)\n+\t    {\n+\t      dr[0] = th->wow64_context.Dr0;\n+\t      dr[1] = th->wow64_context.Dr1;\n+\t      dr[2] = th->wow64_context.Dr2;\n+\t      dr[3] = th->wow64_context.Dr3;\n+\t      dr[6] = th->wow64_context.Dr6;\n+\t      dr[7] = th->wow64_context.Dr7;\n+\t    }\n+\t}\n+      else\n #endif\n \t{\n \t  th->context.ContextFlags = CONTEXT_DEBUGGER_DR;\n@@ -655,7 +747,13 @@ windows_store_one_register (const struct regcache *regcache,\n {\n   gdb_assert (r >= 0);\n \n-  regcache->raw_collect (r, ((char *) &th->context) + mappings[r]);\n+  char *context_ptr = (char *) &th->context;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    context_ptr = (char *) &th->wow64_context;\n+#endif\n+\n+  regcache->raw_collect (r, context_ptr + mappings[r]);\n }\n \n /* Store a new register value into the context of the thread tied to\n@@ -1043,7 +1141,14 @@ static int\n display_selector (HANDLE thread, DWORD sel)\n {\n   LDT_ENTRY info;\n-  if (GetThreadSelectorEntry (thread, sel, &info))\n+  BOOL ret;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    ret = Wow64GetThreadSelectorEntry (thread, sel, &info);\n+  else\n+#endif\n+    ret = GetThreadSelectorEntry (thread, sel, &info);\n+  if (ret)\n     {\n       int base, limit;\n       printf_filtered (\"0x%03x: \", (unsigned) sel);\n@@ -1127,25 +1232,50 @@ display_selectors (const char * args, int from_tty)\n     }\n   if (!args)\n     {\n-\n-      puts_filtered (\"Selector $cs\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegCs);\n-      puts_filtered (\"Selector $ds\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegDs);\n-      puts_filtered (\"Selector $es\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegEs);\n-      puts_filtered (\"Selector $ss\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegSs);\n-      puts_filtered (\"Selector $fs\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegFs);\n-      puts_filtered (\"Selector $gs\\n\");\n-      display_selector (current_thread->h,\n-\tcurrent_thread->context.SegGs);\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\t{\n+\t  puts_filtered (\"Selector $cs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegCs);\n+\t  puts_filtered (\"Selector $ds\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegDs);\n+\t  puts_filtered (\"Selector $es\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegEs);\n+\t  puts_filtered (\"Selector $ss\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegSs);\n+\t  puts_filtered (\"Selector $fs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegFs);\n+\t  puts_filtered (\"Selector $gs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->wow64_context.SegGs);\n+\t}\n+      else\n+#endif\n+\t{\n+\t  puts_filtered (\"Selector $cs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegCs);\n+\t  puts_filtered (\"Selector $ds\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegDs);\n+\t  puts_filtered (\"Selector $es\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegEs);\n+\t  puts_filtered (\"Selector $ss\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegSs);\n+\t  puts_filtered (\"Selector $fs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegFs);\n+\t  puts_filtered (\"Selector $gs\\n\");\n+\t  display_selector (current_thread->h,\n+\t\t\t    current_thread->context.SegGs);\n+\t}\n     }\n   else\n     {\n@@ -1246,6 +1376,19 @@ handle_exception (struct target_waitstatus *ourstatus)\n       ourstatus->value.sig = GDB_SIGNAL_FPE;\n       break;\n     case EXCEPTION_BREAKPOINT:\n+#ifdef __x86_64__\n+      if (ignore_first_breakpoint)\n+\t{\n+\t  /* For WOW64 processes, there are always 2 breakpoint exceptions\n+\t     on startup, first a BREAKPOINT for the 64bit ntdll.dll,\n+\t     then a WX86_BREAKPOINT for the 32bit ntdll.dll.\n+\t     Here we only care about the WX86_BREAKPOINT's.  */\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ignore_first_breakpoint = false;\n+\t}\n+#endif\n+      /* FALLTHROUGH */\n+    case STATUS_WX86_BREAKPOINT:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_BREAKPOINT\");\n       ourstatus->value.sig = GDB_SIGNAL_TRAP;\n       break;\n@@ -1258,6 +1401,7 @@ handle_exception (struct target_waitstatus *ourstatus)\n       ourstatus->value.sig = GDB_SIGNAL_INT;\n       break;\n     case EXCEPTION_SINGLE_STEP:\n+    case STATUS_WX86_SINGLE_STEP:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_SINGLE_STEP\");\n       ourstatus->value.sig = GDB_SIGNAL_TRAP;\n       break;\n@@ -1346,29 +1490,62 @@ windows_continue (DWORD continue_status, int id, int killed)\n     if ((id == -1 || id == (int) th->id)\n \t&& th->suspended)\n       {\n-\tif (debug_registers_changed)\n+#ifdef __x86_64__\n+\tif (wow64_process)\n \t  {\n-\t    th->context.ContextFlags |= CONTEXT_DEBUG_REGISTERS;\n-\t    th->context.Dr0 = dr[0];\n-\t    th->context.Dr1 = dr[1];\n-\t    th->context.Dr2 = dr[2];\n-\t    th->context.Dr3 = dr[3];\n-\t    th->context.Dr6 = DR6_CLEAR_VALUE;\n-\t    th->context.Dr7 = dr[7];\n+\t    if (debug_registers_changed)\n+\t      {\n+\t\tth->wow64_context.ContextFlags |= CONTEXT_DEBUG_REGISTERS;\n+\t\tth->wow64_context.Dr0 = dr[0];\n+\t\tth->wow64_context.Dr1 = dr[1];\n+\t\tth->wow64_context.Dr2 = dr[2];\n+\t\tth->wow64_context.Dr3 = dr[3];\n+\t\tth->wow64_context.Dr6 = DR6_CLEAR_VALUE;\n+\t\tth->wow64_context.Dr7 = dr[7];\n+\t      }\n+\t    if (th->wow64_context.ContextFlags)\n+\t      {\n+\t\tDWORD ec = 0;\n+\n+\t\tif (GetExitCodeThread (th->h, &ec)\n+\t\t    && ec == STILL_ACTIVE)\n+\t\t  {\n+\t\t    BOOL status = Wow64SetThreadContext (th->h,\n+\t\t\t\t\t\t\t &th->wow64_context);\n+\n+\t\t    if (!killed)\n+\t\t      CHECK (status);\n+\t\t  }\n+\t\tth->wow64_context.ContextFlags = 0;\n+\t      }\n \t  }\n-\tif (th->context.ContextFlags)\n+\telse\n+#endif\n \t  {\n-\t    DWORD ec = 0;\n-\n-\t    if (GetExitCodeThread (th->h, &ec)\n-\t\t&& ec == STILL_ACTIVE)\n+\t    if (debug_registers_changed)\n \t      {\n-\t\tBOOL status = SetThreadContext (th->h, &th->context);\n+\t\tth->context.ContextFlags |= CONTEXT_DEBUG_REGISTERS;\n+\t\tth->context.Dr0 = dr[0];\n+\t\tth->context.Dr1 = dr[1];\n+\t\tth->context.Dr2 = dr[2];\n+\t\tth->context.Dr3 = dr[3];\n+\t\tth->context.Dr6 = DR6_CLEAR_VALUE;\n+\t\tth->context.Dr7 = dr[7];\n+\t      }\n+\t    if (th->context.ContextFlags)\n+\t      {\n+\t\tDWORD ec = 0;\n+\n+\t\tif (GetExitCodeThread (th->h, &ec)\n+\t\t    && ec == STILL_ACTIVE)\n+\t\t  {\n+\t\t    BOOL status = SetThreadContext (th->h, &th->context);\n \n-\t\tif (!killed)\n-\t\t  CHECK (status);\n+\t\t    if (!killed)\n+\t\t      CHECK (status);\n+\t\t  }\n+\t\tth->context.ContextFlags = 0;\n \t      }\n-\t    th->context.ContextFlags = 0;\n \t  }\n \tif (th->suspended > 0)\n \t  (void) ResumeThread (th->h);\n@@ -1468,28 +1645,59 @@ windows_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n   th = thread_rec (inferior_ptid.tid (), FALSE);\n   if (th)\n     {\n-      if (step)\n+#ifdef __x86_64__\n+      if (wow64_process)\n \t{\n-\t  /* Single step by setting t bit.  */\n-\t  struct regcache *regcache = get_current_regcache ();\n-\t  struct gdbarch *gdbarch = regcache->arch ();\n-\t  fetch_registers (regcache, gdbarch_ps_regnum (gdbarch));\n-\t  th->context.EFlags |= FLAG_TRACE_BIT;\n-\t}\n+\t  if (step)\n+\t    {\n+\t      /* Single step by setting t bit.  */\n+\t      struct regcache *regcache = get_current_regcache ();\n+\t      struct gdbarch *gdbarch = regcache->arch ();\n+\t      fetch_registers (regcache, gdbarch_ps_regnum (gdbarch));\n+\t      th->wow64_context.EFlags |= FLAG_TRACE_BIT;\n+\t    }\n \n-      if (th->context.ContextFlags)\n+\t  if (th->wow64_context.ContextFlags)\n+\t    {\n+\t      if (debug_registers_changed)\n+\t\t{\n+\t\t  th->wow64_context.Dr0 = dr[0];\n+\t\t  th->wow64_context.Dr1 = dr[1];\n+\t\t  th->wow64_context.Dr2 = dr[2];\n+\t\t  th->wow64_context.Dr3 = dr[3];\n+\t\t  th->wow64_context.Dr6 = DR6_CLEAR_VALUE;\n+\t\t  th->wow64_context.Dr7 = dr[7];\n+\t\t}\n+\t      CHECK (Wow64SetThreadContext (th->h, &th->wow64_context));\n+\t      th->wow64_context.ContextFlags = 0;\n+\t    }\n+\t}\n+      else\n+#endif\n \t{\n-\t  if (debug_registers_changed)\n+\t  if (step)\n \t    {\n-\t      th->context.Dr0 = dr[0];\n-\t      th->context.Dr1 = dr[1];\n-\t      th->context.Dr2 = dr[2];\n-\t      th->context.Dr3 = dr[3];\n-\t      th->context.Dr6 = DR6_CLEAR_VALUE;\n-\t      th->context.Dr7 = dr[7];\n+\t      /* Single step by setting t bit.  */\n+\t      struct regcache *regcache = get_current_regcache ();\n+\t      struct gdbarch *gdbarch = regcache->arch ();\n+\t      fetch_registers (regcache, gdbarch_ps_regnum (gdbarch));\n+\t      th->context.EFlags |= FLAG_TRACE_BIT;\n+\t    }\n+\n+\t  if (th->context.ContextFlags)\n+\t    {\n+\t      if (debug_registers_changed)\n+\t\t{\n+\t\t  th->context.Dr0 = dr[0];\n+\t\t  th->context.Dr1 = dr[1];\n+\t\t  th->context.Dr2 = dr[2];\n+\t\t  th->context.Dr3 = dr[3];\n+\t\t  th->context.Dr6 = DR6_CLEAR_VALUE;\n+\t\t  th->context.Dr7 = dr[7];\n+\t\t}\n+\t      CHECK (SetThreadContext (th->h, &th->context));\n+\t      th->context.ContextFlags = 0;\n \t    }\n-\t  CHECK (SetThreadContext (th->h, &th->context));\n-\t  th->context.ContextFlags = 0;\n \t}\n     }\n \n@@ -1814,17 +2022,41 @@ windows_add_all_dlls (void)\n   HMODULE *hmodules;\n   int i;\n \n-  if (EnumProcessModules (current_process_handle, &dummy_hmodule,\n-\t\t\t  sizeof (HMODULE), &cb_needed) == 0)\n-    return;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    {\n+      if (EnumProcessModulesEx (current_process_handle, &dummy_hmodule,\n+\t\t\t\tsizeof (HMODULE), &cb_needed,\n+\t\t\t\tLIST_MODULES_32BIT) == 0)\n+\treturn;\n+    }\n+  else\n+#endif\n+    {\n+      if (EnumProcessModules (current_process_handle, &dummy_hmodule,\n+\t\t\t      sizeof (HMODULE), &cb_needed) == 0)\n+\treturn;\n+    }\n \n   if (cb_needed < 1)\n     return;\n \n   hmodules = (HMODULE *) alloca (cb_needed);\n-  if (EnumProcessModules (current_process_handle, hmodules,\n-\t\t\t  cb_needed, &cb_needed) == 0)\n-    return;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    {\n+      if (EnumProcessModulesEx (current_process_handle, hmodules,\n+\t\t\t\tcb_needed, &cb_needed,\n+\t\t\t\tLIST_MODULES_32BIT) == 0)\n+\treturn;\n+    }\n+  else\n+#endif\n+    {\n+      if (EnumProcessModules (current_process_handle, hmodules,\n+\t\t\t      cb_needed, &cb_needed) == 0)\n+\treturn;\n+    }\n \n   for (i = 1; i < (int) (cb_needed / sizeof (HMODULE)); i++)\n     {\n@@ -1879,6 +2111,21 @@ do_initial_windows_stuff (struct target_ops *ops, DWORD pid, int attaching)\n   clear_proceed_status (0);\n   init_wait_for_inferior ();\n \n+#ifdef __x86_64__\n+  ignore_first_breakpoint = !attaching && wow64_process;\n+\n+  if (!wow64_process)\n+    {\n+      windows_set_context_register_offsets (amd64_mappings);\n+      windows_set_segment_register_p (amd64_windows_segment_register_p);\n+    }\n+  else\n+#endif\n+    {\n+      windows_set_context_register_offsets (i386_mappings);\n+      windows_set_segment_register_p (i386_windows_segment_register_p);\n+    }\n+\n   inf = current_inferior ();\n   inferior_appeared (inf, pid);\n   inf->attach_flag = attaching;\n@@ -2029,6 +2276,17 @@ windows_nat_target::attach (const char *args, int from_tty)\n \t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n+#ifdef __x86_64__\n+  HANDLE h = OpenProcess (PROCESS_QUERY_INFORMATION, FALSE, pid);\n+  if (h != NULL)\n+    {\n+      BOOL wow64;\n+      if (IsWow64Process (h, &wow64))\n+\twow64_process = wow64;\n+      CloseHandle (h);\n+    }\n+#endif\n+\n   do_initial_windows_stuff (this, pid, 1);\n   target_terminal::ours ();\n }\n@@ -2083,9 +2341,21 @@ windows_get_exec_module_filename (char *exe_name_ret, size_t exe_name_max_len)\n   DWORD cbNeeded;\n \n   cbNeeded = 0;\n-  if (!EnumProcessModules (current_process_handle, &dh_buf,\n-\t\t\t   sizeof (HMODULE), &cbNeeded) || !cbNeeded)\n-    return 0;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    {\n+      if (!EnumProcessModulesEx (current_process_handle, &dh_buf,\n+\t\t\t\t sizeof (HMODULE), &cbNeeded,\n+\t\t\t\t LIST_MODULES_32BIT) || !cbNeeded)\n+\treturn 0;\n+    }\n+  else\n+#endif\n+    {\n+      if (!EnumProcessModules (current_process_handle, &dh_buf,\n+\t\t\t       sizeof (HMODULE), &cbNeeded) || !cbNeeded)\n+\treturn 0;\n+    }\n \n   /* We know the executable is always first in the list of modules,\n      which we just fetched.  So no need to fetch more.  */\n@@ -2843,6 +3113,12 @@ windows_nat_target::create_inferior (const char *exec_file,\n     error (_(\"Error creating process %s, (error %u).\"),\n \t   exec_file, (unsigned) GetLastError ());\n \n+#ifdef __x86_64__\n+  BOOL wow64;\n+  if (IsWow64Process (pi.hProcess, &wow64))\n+    wow64_process = wow64;\n+#endif\n+\n   CloseHandle (pi.hThread);\n   CloseHandle (pi.hProcess);\n \n@@ -3006,19 +3282,40 @@ static enum target_xfer_status\n windows_xfer_siginfo (gdb_byte *readbuf, ULONGEST offset, ULONGEST len,\n \t\t      ULONGEST *xfered_len)\n {\n+  char *buf = (char *) &siginfo_er;\n+  size_t bufsize = sizeof (siginfo_er);\n+\n+#ifdef __x86_64__\n+  EXCEPTION_RECORD32 er32;\n+  if (wow64_process)\n+    {\n+      buf = (char *) &er32;\n+      bufsize = sizeof (er32);\n+\n+      er32.ExceptionCode = siginfo_er.ExceptionCode;\n+      er32.ExceptionFlags = siginfo_er.ExceptionFlags;\n+      er32.ExceptionRecord = (uintptr_t) siginfo_er.ExceptionRecord;\n+      er32.ExceptionAddress = (uintptr_t) siginfo_er.ExceptionAddress;\n+      er32.NumberParameters = siginfo_er.NumberParameters;\n+      int i;\n+      for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)\n+\ter32.ExceptionInformation[i] = siginfo_er.ExceptionInformation[i];\n+    }\n+#endif\n+\n   if (siginfo_er.ExceptionCode == 0)\n     return TARGET_XFER_E_IO;\n \n   if (readbuf == nullptr)\n     return TARGET_XFER_E_IO;\n \n-  if (offset > sizeof (siginfo_er))\n+  if (offset > bufsize)\n     return TARGET_XFER_E_IO;\n \n-  if (offset + len > sizeof (siginfo_er))\n-    len = sizeof (siginfo_er) - offset;\n+  if (offset + len > bufsize)\n+    len = bufsize - offset;\n \n-  memcpy (readbuf, (char *) &siginfo_er + offset, len);\n+  memcpy (readbuf, buf + offset, len);\n   *xfered_len = len;\n \n   return TARGET_XFER_OK;\n@@ -3368,6 +3665,12 @@ _initialize_loadable ()\n       GPA (hm, GetConsoleFontSize);\n       GPA (hm, DebugActiveProcessStop);\n       GPA (hm, GetCurrentConsoleFont);\n+#ifdef __x86_64__\n+      GPA (hm, Wow64SuspendThread);\n+      GPA (hm, Wow64GetThreadContext);\n+      GPA (hm, Wow64SetThreadContext);\n+      GPA (hm, Wow64GetThreadSelectorEntry);\n+#endif\n     }\n \n   /* Set variables to dummy versions of these processes if the function\n@@ -3390,6 +3693,9 @@ _initialize_loadable ()\n   if (hm)\n     {\n       GPA (hm, EnumProcessModules);\n+#ifdef __x86_64__\n+      GPA (hm, EnumProcessModulesEx);\n+#endif\n       GPA (hm, GetModuleInformation);\n       GetModuleFileNameEx = (GetModuleFileNameEx_ftype *)\n         GetProcAddress (hm, GetModuleFileNameEx_name);"
    },
    {
      "sha": "43c788c497e2dbc1412ba9ed20169141299b4a87",
      "filename": "gdb/windows-nat.h",
      "status": "modified",
      "additions": 13,
      "deletions": 5,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/windows-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46f9f93119daaa8eceb7233a17759e10e858c9fd/gdb/windows-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.h?ref=46f9f93119daaa8eceb7233a17759e10e858c9fd",
      "patch": "@@ -18,15 +18,23 @@\n #ifndef WINDOWS_NAT_H\n #define WINDOWS_NAT_H\n \n-extern void windows_set_context_register_offsets (const int *offsets);\n-\n /* A pointer to a function that should return non-zero iff REGNUM\n    corresponds to one of the segment registers.  */\n typedef int (segment_register_p_ftype) (int regnum);\n \n-/* Set the function that should be used by this module to determine\n-   whether a given register is a segment register or not.  */\n-extern void windows_set_segment_register_p (segment_register_p_ftype *fun);\n+/* segment_register_p_ftype implementation for x86.  */\n+int i386_windows_segment_register_p (int regnum);\n+\n+/* context register offests for x86.  */\n+extern const int i386_mappings[];\n+\n+#ifdef __x86_64__\n+/* segment_register_p_ftype implementation for amd64.  */\n+int amd64_windows_segment_register_p (int regnum);\n+\n+/* context register offests for amd64.  */\n+extern const int amd64_mappings[];\n+#endif\n \n #endif\n "
    }
  ]
}