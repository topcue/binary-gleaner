{
  "sha": "0df7ad3a675692fcc75c85c43e475015b87a297e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGRmN2FkM2E2NzU2OTJmY2M3NWM4NWM0M2U0NzUwMTViODdhMjk3ZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-26T15:28:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-26T15:28:20Z"
    },
    "message": "Move more code to line-header.c\n\nThis moves some more code out of read.c and into line-header.c.\ndwarf_decode_line_header is split into two -- the part remaining in\nread.c handles interfacing to the dwarf2_cu; while the part in\nline-header.c (more or less) purely handles the actual decoding.\n\ngdb/ChangeLog\n2020-03-26  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/line-header.h (dwarf_decode_line_header): Declare.\n\t* dwarf2/read.c\n\t(dwarf2_statement_list_fits_in_line_number_section_complaint):\n\tMove to line-header.c.\n\t(read_checked_initial_length_and_offset, read_formatted_entries):\n\tLikewise.\n\t(dwarf_decode_line_header): Split into two.\n\t* dwarf2/line-header.c\n\t(dwarf2_statement_list_fits_in_line_number_section_complaint):\n\tMove from read.c.\n\t(read_checked_initial_length_and_offset, read_formatted_entries):\n\tLikewise.\n\t(dwarf_decode_line_header): New function, split from read.c.",
    "tree": {
      "sha": "c0393ec9b1527e4ae97e23c90e7310d1461bc9f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c0393ec9b1527e4ae97e23c90e7310d1461bc9f6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0df7ad3a675692fcc75c85c43e475015b87a297e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0df7ad3a675692fcc75c85c43e475015b87a297e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0df7ad3a675692fcc75c85c43e475015b87a297e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0df7ad3a675692fcc75c85c43e475015b87a297e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "86c0bb4c57111422b30da6b1b20256bd3a06778a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/86c0bb4c57111422b30da6b1b20256bd3a06778a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/86c0bb4c57111422b30da6b1b20256bd3a06778a"
    }
  ],
  "stats": {
    "total": 697,
    "additions": 368,
    "deletions": 329
  },
  "files": [
    {
      "sha": "bc524e1133ea7efda55dc639316224dfdf66465c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0df7ad3a675692fcc75c85c43e475015b87a297e",
      "patch": "@@ -1,3 +1,19 @@\n+2020-03-26  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/line-header.h (dwarf_decode_line_header): Declare.\n+\t* dwarf2/read.c\n+\t(dwarf2_statement_list_fits_in_line_number_section_complaint):\n+\tMove to line-header.c.\n+\t(read_checked_initial_length_and_offset, read_formatted_entries):\n+\tLikewise.\n+\t(dwarf_decode_line_header): Split into two.\n+\t* dwarf2/line-header.c\n+\t(dwarf2_statement_list_fits_in_line_number_section_complaint):\n+\tMove from read.c.\n+\t(read_checked_initial_length_and_offset, read_formatted_entries):\n+\tLikewise.\n+\t(dwarf_decode_line_header): New function, split from read.c.\n+\n 2020-03-26  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.h (struct dwarf2_per_objfile) <read_line_string>:"
    },
    {
      "sha": "58749e9594bedbaf223cd42194805a6242157f74",
      "filename": "gdb/dwarf2/line-header.c",
      "status": "modified",
      "additions": 335,
      "deletions": 0,
      "changes": 335,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/line-header.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/line-header.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.c?ref=0df7ad3a675692fcc75c85c43e475015b87a297e",
      "patch": "@@ -18,6 +18,8 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n+#include \"dwarf2/comp-unit.h\"\n+#include \"dwarf2/leb.h\"\n #include \"dwarf2/line-header.h\"\n #include \"dwarf2/read.h\"\n #include \"complaints.h\"\n@@ -112,3 +114,336 @@ line_header::file_full_name (int file, const char *comp_dir) const\n   else\n     return file_file_name (file);\n }\n+\n+static void\n+dwarf2_statement_list_fits_in_line_number_section_complaint (void)\n+{\n+  complaint (_(\"statement list doesn't fit in .debug_line section\"));\n+}\n+\n+/* Cover function for read_initial_length.\n+   Returns the length of the object at BUF, and stores the size of the\n+   initial length in *BYTES_READ and stores the size that offsets will be in\n+   *OFFSET_SIZE.\n+   If the initial length size is not equivalent to that specified in\n+   CU_HEADER then issue a complaint.\n+   This is useful when reading non-comp-unit headers.  */\n+\n+static LONGEST\n+read_checked_initial_length_and_offset (bfd *abfd, const gdb_byte *buf,\n+\t\t\t\t\tconst struct comp_unit_head *cu_header,\n+\t\t\t\t\tunsigned int *bytes_read,\n+\t\t\t\t\tunsigned int *offset_size)\n+{\n+  LONGEST length = read_initial_length (abfd, buf, bytes_read);\n+\n+  gdb_assert (cu_header->initial_length_size == 4\n+\t      || cu_header->initial_length_size == 8\n+\t      || cu_header->initial_length_size == 12);\n+\n+  if (cu_header->initial_length_size != *bytes_read)\n+    complaint (_(\"intermixed 32-bit and 64-bit DWARF sections\"));\n+\n+  *offset_size = (*bytes_read == 4) ? 4 : 8;\n+  return length;\n+}\n+\n+/* Read directory or file name entry format, starting with byte of\n+   format count entries, ULEB128 pairs of entry formats, ULEB128 of\n+   entries count and the entries themselves in the described entry\n+   format.  */\n+\n+static void\n+read_formatted_entries (struct dwarf2_per_objfile *dwarf2_per_objfile,\n+\t\t\tbfd *abfd, const gdb_byte **bufp,\n+\t\t\tstruct line_header *lh,\n+\t\t\tconst struct comp_unit_head *cu_header,\n+\t\t\tvoid (*callback) (struct line_header *lh,\n+\t\t\t\t\t  const char *name,\n+\t\t\t\t\t  dir_index d_index,\n+\t\t\t\t\t  unsigned int mod_time,\n+\t\t\t\t\t  unsigned int length))\n+{\n+  gdb_byte format_count, formati;\n+  ULONGEST data_count, datai;\n+  const gdb_byte *buf = *bufp;\n+  const gdb_byte *format_header_data;\n+  unsigned int bytes_read;\n+\n+  format_count = read_1_byte (abfd, buf);\n+  buf += 1;\n+  format_header_data = buf;\n+  for (formati = 0; formati < format_count; formati++)\n+    {\n+      read_unsigned_leb128 (abfd, buf, &bytes_read);\n+      buf += bytes_read;\n+      read_unsigned_leb128 (abfd, buf, &bytes_read);\n+      buf += bytes_read;\n+    }\n+\n+  data_count = read_unsigned_leb128 (abfd, buf, &bytes_read);\n+  buf += bytes_read;\n+  for (datai = 0; datai < data_count; datai++)\n+    {\n+      const gdb_byte *format = format_header_data;\n+      struct file_entry fe;\n+\n+      for (formati = 0; formati < format_count; formati++)\n+\t{\n+\t  ULONGEST content_type = read_unsigned_leb128 (abfd, format, &bytes_read);\n+\t  format += bytes_read;\n+\n+\t  ULONGEST form  = read_unsigned_leb128 (abfd, format, &bytes_read);\n+\t  format += bytes_read;\n+\n+\t  gdb::optional<const char *> string;\n+\t  gdb::optional<unsigned int> uint;\n+\n+\t  switch (form)\n+\t    {\n+\t    case DW_FORM_string:\n+\t      string.emplace (read_direct_string (abfd, buf, &bytes_read));\n+\t      buf += bytes_read;\n+\t      break;\n+\n+\t    case DW_FORM_line_strp:\n+\t      string.emplace\n+\t\t(dwarf2_per_objfile->read_line_string (buf,\n+\t\t\t\t\t\t       cu_header,\n+\t\t\t\t\t\t       &bytes_read));\n+\t      buf += bytes_read;\n+\t      break;\n+\n+\t    case DW_FORM_data1:\n+\t      uint.emplace (read_1_byte (abfd, buf));\n+\t      buf += 1;\n+\t      break;\n+\n+\t    case DW_FORM_data2:\n+\t      uint.emplace (read_2_bytes (abfd, buf));\n+\t      buf += 2;\n+\t      break;\n+\n+\t    case DW_FORM_data4:\n+\t      uint.emplace (read_4_bytes (abfd, buf));\n+\t      buf += 4;\n+\t      break;\n+\n+\t    case DW_FORM_data8:\n+\t      uint.emplace (read_8_bytes (abfd, buf));\n+\t      buf += 8;\n+\t      break;\n+\n+\t    case DW_FORM_data16:\n+\t      /*  This is used for MD5, but file_entry does not record MD5s. */\n+\t      buf += 16;\n+\t      break;\n+\n+\t    case DW_FORM_udata:\n+\t      uint.emplace (read_unsigned_leb128 (abfd, buf, &bytes_read));\n+\t      buf += bytes_read;\n+\t      break;\n+\n+\t    case DW_FORM_block:\n+\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n+\t\t current GDB.  */\n+\t      break;\n+\t    }\n+\n+\t  switch (content_type)\n+\t    {\n+\t    case DW_LNCT_path:\n+\t      if (string.has_value ())\n+\t\tfe.name = *string;\n+\t      break;\n+\t    case DW_LNCT_directory_index:\n+\t      if (uint.has_value ())\n+\t\tfe.d_index = (dir_index) *uint;\n+\t      break;\n+\t    case DW_LNCT_timestamp:\n+\t      if (uint.has_value ())\n+\t\tfe.mod_time = *uint;\n+\t      break;\n+\t    case DW_LNCT_size:\n+\t      if (uint.has_value ())\n+\t\tfe.length = *uint;\n+\t      break;\n+\t    case DW_LNCT_MD5:\n+\t      break;\n+\t    default:\n+\t      complaint (_(\"Unknown format content type %s\"),\n+\t\t\t pulongest (content_type));\n+\t    }\n+\t}\n+\n+      callback (lh, fe.name, fe.d_index, fe.mod_time, fe.length);\n+    }\n+\n+  *bufp = buf;\n+}\n+\n+/* See line-header.h.  */\n+\n+line_header_up\n+dwarf_decode_line_header  (sect_offset sect_off, bool is_dwz,\n+\t\t\t   struct dwarf2_per_objfile *dwarf2_per_objfile,\n+\t\t\t   struct dwarf2_section_info *section,\n+\t\t\t   const struct comp_unit_head *cu_header)\n+{\n+  const gdb_byte *line_ptr;\n+  unsigned int bytes_read, offset_size;\n+  int i;\n+  const char *cur_dir, *cur_file;\n+\n+  bfd *abfd = section->get_bfd_owner ();\n+\n+  /* Make sure that at least there's room for the total_length field.\n+     That could be 12 bytes long, but we're just going to fudge that.  */\n+  if (to_underlying (sect_off) + 4 >= section->size)\n+    {\n+      dwarf2_statement_list_fits_in_line_number_section_complaint ();\n+      return 0;\n+    }\n+\n+  line_header_up lh (new line_header ());\n+\n+  lh->sect_off = sect_off;\n+  lh->offset_in_dwz = is_dwz;\n+\n+  line_ptr = section->buffer + to_underlying (sect_off);\n+\n+  /* Read in the header.  */\n+  lh->total_length =\n+    read_checked_initial_length_and_offset (abfd, line_ptr, cu_header,\n+\t\t\t\t\t    &bytes_read, &offset_size);\n+  line_ptr += bytes_read;\n+\n+  const gdb_byte *start_here = line_ptr;\n+\n+  if (line_ptr + lh->total_length > (section->buffer + section->size))\n+    {\n+      dwarf2_statement_list_fits_in_line_number_section_complaint ();\n+      return 0;\n+    }\n+  lh->statement_program_end = start_here + lh->total_length;\n+  lh->version = read_2_bytes (abfd, line_ptr);\n+  line_ptr += 2;\n+  if (lh->version > 5)\n+    {\n+      /* This is a version we don't understand.  The format could have\n+\t changed in ways we don't handle properly so just punt.  */\n+      complaint (_(\"unsupported version in .debug_line section\"));\n+      return NULL;\n+    }\n+  if (lh->version >= 5)\n+    {\n+      gdb_byte segment_selector_size;\n+\n+      /* Skip address size.  */\n+      read_1_byte (abfd, line_ptr);\n+      line_ptr += 1;\n+\n+      segment_selector_size = read_1_byte (abfd, line_ptr);\n+      line_ptr += 1;\n+      if (segment_selector_size != 0)\n+\t{\n+\t  complaint (_(\"unsupported segment selector size %u \"\n+\t\t       \"in .debug_line section\"),\n+\t\t     segment_selector_size);\n+\t  return NULL;\n+\t}\n+    }\n+  lh->header_length = read_offset (abfd, line_ptr, offset_size);\n+  line_ptr += offset_size;\n+  lh->statement_program_start = line_ptr + lh->header_length;\n+  lh->minimum_instruction_length = read_1_byte (abfd, line_ptr);\n+  line_ptr += 1;\n+  if (lh->version >= 4)\n+    {\n+      lh->maximum_ops_per_instruction = read_1_byte (abfd, line_ptr);\n+      line_ptr += 1;\n+    }\n+  else\n+    lh->maximum_ops_per_instruction = 1;\n+\n+  if (lh->maximum_ops_per_instruction == 0)\n+    {\n+      lh->maximum_ops_per_instruction = 1;\n+      complaint (_(\"invalid maximum_ops_per_instruction \"\n+\t\t   \"in `.debug_line' section\"));\n+    }\n+\n+  lh->default_is_stmt = read_1_byte (abfd, line_ptr);\n+  line_ptr += 1;\n+  lh->line_base = read_1_signed_byte (abfd, line_ptr);\n+  line_ptr += 1;\n+  lh->line_range = read_1_byte (abfd, line_ptr);\n+  line_ptr += 1;\n+  lh->opcode_base = read_1_byte (abfd, line_ptr);\n+  line_ptr += 1;\n+  lh->standard_opcode_lengths.reset (new unsigned char[lh->opcode_base]);\n+\n+  lh->standard_opcode_lengths[0] = 1;  /* This should never be used anyway.  */\n+  for (i = 1; i < lh->opcode_base; ++i)\n+    {\n+      lh->standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr);\n+      line_ptr += 1;\n+    }\n+\n+  if (lh->version >= 5)\n+    {\n+      /* Read directory table.  */\n+      read_formatted_entries (dwarf2_per_objfile, abfd, &line_ptr, lh.get (),\n+\t\t\t      cu_header,\n+\t\t\t      [] (struct line_header *header, const char *name,\n+\t\t\t\t  dir_index d_index, unsigned int mod_time,\n+\t\t\t\t  unsigned int length)\n+\t{\n+\t  header->add_include_dir (name);\n+\t});\n+\n+      /* Read file name table.  */\n+      read_formatted_entries (dwarf2_per_objfile, abfd, &line_ptr, lh.get (),\n+\t\t\t      cu_header,\n+\t\t\t      [] (struct line_header *header, const char *name,\n+\t\t\t\t  dir_index d_index, unsigned int mod_time,\n+\t\t\t\t  unsigned int length)\n+\t{\n+\t  header->add_file_name (name, d_index, mod_time, length);\n+\t});\n+    }\n+  else\n+    {\n+      /* Read directory table.  */\n+      while ((cur_dir = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)\n+\t{\n+\t  line_ptr += bytes_read;\n+\t  lh->add_include_dir (cur_dir);\n+\t}\n+      line_ptr += bytes_read;\n+\n+      /* Read file name table.  */\n+      while ((cur_file = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)\n+\t{\n+\t  unsigned int mod_time, length;\n+\t  dir_index d_index;\n+\n+\t  line_ptr += bytes_read;\n+\t  d_index = (dir_index) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t  line_ptr += bytes_read;\n+\t  mod_time = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t  line_ptr += bytes_read;\n+\t  length = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n+\t  line_ptr += bytes_read;\n+\n+\t  lh->add_file_name (cur_file, d_index, mod_time, length);\n+\t}\n+      line_ptr += bytes_read;\n+    }\n+\n+  if (line_ptr > (section->buffer + section->size))\n+    complaint (_(\"line number info header doesn't \"\n+\t\t \"fit in `.debug_line' section\"));\n+\n+  return lh;\n+}"
    },
    {
      "sha": "700aaddacf7c6a78b2e7c65b566882d1a1eb7b9a",
      "filename": "gdb/dwarf2/line-header.h",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/line-header.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/line-header.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.h?ref=0df7ad3a675692fcc75c85c43e475015b87a297e",
      "patch": "@@ -195,4 +195,18 @@ file_entry::include_dir (const line_header *lh) const\n   return lh->include_dir_at (d_index);\n }\n \n+/* Read the statement program header starting at SECT_OFF in SECTION.\n+   Return line_header.  Returns nullptr if there is a problem reading\n+   the header, e.g., if it has a version we don't understand.\n+\n+   NOTE: the strings in the include directory and file name tables of\n+   the returned object point into the dwarf line section buffer,\n+   and must not be freed.  */\n+\n+extern line_header_up dwarf_decode_line_header\n+  (sect_offset sect_off, bool is_dwz,\n+   struct dwarf2_per_objfile *dwarf2_per_objfile,\n+   struct dwarf2_section_info *section,\n+   const struct comp_unit_head *cu_header);\n+\n #endif /* DWARF2_LINE_HEADER_H */"
    },
    {
      "sha": "ff5fa74997ceffe52437fc2164b2c23c51becec9",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 3,
      "deletions": 329,
      "changes": 332,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0df7ad3a675692fcc75c85c43e475015b87a297e/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=0df7ad3a675692fcc75c85c43e475015b87a297e",
      "patch": "@@ -1239,10 +1239,6 @@ static void read_attribute_reprocess (const struct die_reader_specs *reader,\n \n static CORE_ADDR read_addr_index (struct dwarf2_cu *cu, unsigned int addr_index);\n \n-static LONGEST read_checked_initial_length_and_offset\n-  (bfd *, const gdb_byte *, const struct comp_unit_head *,\n-   unsigned int *, unsigned int *);\n-\n static sect_offset read_abbrev_offset\n   (struct dwarf2_per_objfile *dwarf2_per_objfile,\n    struct dwarf2_section_info *, sect_offset);\n@@ -1673,12 +1669,6 @@ static void free_line_header_voidp (void *arg);\n \f\n /* Various complaints about symbol reading that don't abort the process.  */\n \n-static void\n-dwarf2_statement_list_fits_in_line_number_section_complaint (void)\n-{\n-  complaint (_(\"statement list doesn't fit in .debug_line section\"));\n-}\n-\n static void\n dwarf2_debug_line_missing_file_complaint (void)\n {\n@@ -18730,33 +18720,6 @@ read_attribute (const struct die_reader_specs *reader,\n \t\t\t       need_reprocess);\n }\n \n-/* Cover function for read_initial_length.\n-   Returns the length of the object at BUF, and stores the size of the\n-   initial length in *BYTES_READ and stores the size that offsets will be in\n-   *OFFSET_SIZE.\n-   If the initial length size is not equivalent to that specified in\n-   CU_HEADER then issue a complaint.\n-   This is useful when reading non-comp-unit headers.  */\n-\n-static LONGEST\n-read_checked_initial_length_and_offset (bfd *abfd, const gdb_byte *buf,\n-\t\t\t\t\tconst struct comp_unit_head *cu_header,\n-\t\t\t\t\tunsigned int *bytes_read,\n-\t\t\t\t\tunsigned int *offset_size)\n-{\n-  LONGEST length = read_initial_length (abfd, buf, bytes_read);\n-\n-  gdb_assert (cu_header->initial_length_size == 4\n-\t      || cu_header->initial_length_size == 8\n-\t      || cu_header->initial_length_size == 12);\n-\n-  if (cu_header->initial_length_size != *bytes_read)\n-    complaint (_(\"intermixed 32-bit and 64-bit DWARF sections\"));\n-\n-  *offset_size = (*bytes_read == 4) ? 4 : 8;\n-  return length;\n-}\n-\n /* Return pointer to string at .debug_str offset STR_OFFSET.  */\n \n static const char *\n@@ -19217,140 +19180,6 @@ get_debug_line_section (struct dwarf2_cu *cu)\n   return section;\n }\n \n-/* Read directory or file name entry format, starting with byte of\n-   format count entries, ULEB128 pairs of entry formats, ULEB128 of\n-   entries count and the entries themselves in the described entry\n-   format.  */\n-\n-static void\n-read_formatted_entries (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t\tbfd *abfd, const gdb_byte **bufp,\n-\t\t\tstruct line_header *lh,\n-\t\t\tconst struct comp_unit_head *cu_header,\n-\t\t\tvoid (*callback) (struct line_header *lh,\n-\t\t\t\t\t  const char *name,\n-\t\t\t\t\t  dir_index d_index,\n-\t\t\t\t\t  unsigned int mod_time,\n-\t\t\t\t\t  unsigned int length))\n-{\n-  gdb_byte format_count, formati;\n-  ULONGEST data_count, datai;\n-  const gdb_byte *buf = *bufp;\n-  const gdb_byte *format_header_data;\n-  unsigned int bytes_read;\n-\n-  format_count = read_1_byte (abfd, buf);\n-  buf += 1;\n-  format_header_data = buf;\n-  for (formati = 0; formati < format_count; formati++)\n-    {\n-      read_unsigned_leb128 (abfd, buf, &bytes_read);\n-      buf += bytes_read;\n-      read_unsigned_leb128 (abfd, buf, &bytes_read);\n-      buf += bytes_read;\n-    }\n-\n-  data_count = read_unsigned_leb128 (abfd, buf, &bytes_read);\n-  buf += bytes_read;\n-  for (datai = 0; datai < data_count; datai++)\n-    {\n-      const gdb_byte *format = format_header_data;\n-      struct file_entry fe;\n-\n-      for (formati = 0; formati < format_count; formati++)\n-\t{\n-\t  ULONGEST content_type = read_unsigned_leb128 (abfd, format, &bytes_read);\n-\t  format += bytes_read;\n-\n-\t  ULONGEST form  = read_unsigned_leb128 (abfd, format, &bytes_read);\n-\t  format += bytes_read;\n-\n-\t  gdb::optional<const char *> string;\n-\t  gdb::optional<unsigned int> uint;\n-\n-\t  switch (form)\n-\t    {\n-\t    case DW_FORM_string:\n-\t      string.emplace (read_direct_string (abfd, buf, &bytes_read));\n-\t      buf += bytes_read;\n-\t      break;\n-\n-\t    case DW_FORM_line_strp:\n-\t      string.emplace\n-\t\t(dwarf2_per_objfile->read_line_string (buf,\n-\t\t\t\t\t\t       cu_header,\n-\t\t\t\t\t\t       &bytes_read));\n-\t      buf += bytes_read;\n-\t      break;\n-\n-\t    case DW_FORM_data1:\n-\t      uint.emplace (read_1_byte (abfd, buf));\n-\t      buf += 1;\n-\t      break;\n-\n-\t    case DW_FORM_data2:\n-\t      uint.emplace (read_2_bytes (abfd, buf));\n-\t      buf += 2;\n-\t      break;\n-\n-\t    case DW_FORM_data4:\n-\t      uint.emplace (read_4_bytes (abfd, buf));\n-\t      buf += 4;\n-\t      break;\n-\n-\t    case DW_FORM_data8:\n-\t      uint.emplace (read_8_bytes (abfd, buf));\n-\t      buf += 8;\n-\t      break;\n-\n-\t    case DW_FORM_data16:\n-\t      /*  This is used for MD5, but file_entry does not record MD5s. */\n-\t      buf += 16;\n-\t      break;\n-\n-\t    case DW_FORM_udata:\n-\t      uint.emplace (read_unsigned_leb128 (abfd, buf, &bytes_read));\n-\t      buf += bytes_read;\n-\t      break;\n-\n-\t    case DW_FORM_block:\n-\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n-\t\t current GDB.  */\n-\t      break;\n-\t    }\n-\n-\t  switch (content_type)\n-\t    {\n-\t    case DW_LNCT_path:\n-\t      if (string.has_value ())\n-\t\tfe.name = *string;\n-\t      break;\n-\t    case DW_LNCT_directory_index:\n-\t      if (uint.has_value ())\n-\t\tfe.d_index = (dir_index) *uint;\n-\t      break;\n-\t    case DW_LNCT_timestamp:\n-\t      if (uint.has_value ())\n-\t\tfe.mod_time = *uint;\n-\t      break;\n-\t    case DW_LNCT_size:\n-\t      if (uint.has_value ())\n-\t\tfe.length = *uint;\n-\t      break;\n-\t    case DW_LNCT_MD5:\n-\t      break;\n-\t    default:\n-\t      complaint (_(\"Unknown format content type %s\"),\n-\t\t\t pulongest (content_type));\n-\t    }\n-\t}\n-\n-      callback (lh, fe.name, fe.d_index, fe.mod_time, fe.length);\n-    }\n-\n-  *bufp = buf;\n-}\n-\n /* Read the statement program header starting at OFFSET in\n    .debug_line, or .debug_line.dwo.  Return a pointer\n    to a struct line_header, allocated using xmalloc.\n@@ -19364,12 +19193,7 @@ read_formatted_entries (struct dwarf2_per_objfile *dwarf2_per_objfile,\n static line_header_up\n dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n {\n-  const gdb_byte *line_ptr;\n-  unsigned int bytes_read, offset_size;\n-  int i;\n-  const char *cur_dir, *cur_file;\n   struct dwarf2_section_info *section;\n-  bfd *abfd;\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = cu->per_cu->dwarf2_per_objfile;\n \n@@ -19384,159 +19208,9 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n       return 0;\n     }\n \n-  /* We can't do this until we know the section is non-empty.\n-     Only then do we know we have such a section.  */\n-  abfd = section->get_bfd_owner ();\n-\n-  /* Make sure that at least there's room for the total_length field.\n-     That could be 12 bytes long, but we're just going to fudge that.  */\n-  if (to_underlying (sect_off) + 4 >= section->size)\n-    {\n-      dwarf2_statement_list_fits_in_line_number_section_complaint ();\n-      return 0;\n-    }\n-\n-  line_header_up lh (new line_header ());\n-\n-  lh->sect_off = sect_off;\n-  lh->offset_in_dwz = cu->per_cu->is_dwz;\n-\n-  line_ptr = section->buffer + to_underlying (sect_off);\n-\n-  /* Read in the header.  */\n-  lh->total_length =\n-    read_checked_initial_length_and_offset (abfd, line_ptr, &cu->header,\n-\t\t\t\t\t    &bytes_read, &offset_size);\n-  line_ptr += bytes_read;\n-\n-  const gdb_byte *start_here = line_ptr;\n-\n-  if (line_ptr + lh->total_length > (section->buffer + section->size))\n-    {\n-      dwarf2_statement_list_fits_in_line_number_section_complaint ();\n-      return 0;\n-    }\n-  lh->statement_program_end = start_here + lh->total_length;\n-  lh->version = read_2_bytes (abfd, line_ptr);\n-  line_ptr += 2;\n-  if (lh->version > 5)\n-    {\n-      /* This is a version we don't understand.  The format could have\n-\t changed in ways we don't handle properly so just punt.  */\n-      complaint (_(\"unsupported version in .debug_line section\"));\n-      return NULL;\n-    }\n-  if (lh->version >= 5)\n-    {\n-      gdb_byte segment_selector_size;\n-\n-      /* Skip address size.  */\n-      read_1_byte (abfd, line_ptr);\n-      line_ptr += 1;\n-\n-      segment_selector_size = read_1_byte (abfd, line_ptr);\n-      line_ptr += 1;\n-      if (segment_selector_size != 0)\n-\t{\n-\t  complaint (_(\"unsupported segment selector size %u \"\n-\t\t       \"in .debug_line section\"),\n-\t\t     segment_selector_size);\n-\t  return NULL;\n-\t}\n-    }\n-  lh->header_length = read_offset (abfd, line_ptr, offset_size);\n-  line_ptr += offset_size;\n-  lh->statement_program_start = line_ptr + lh->header_length;\n-  lh->minimum_instruction_length = read_1_byte (abfd, line_ptr);\n-  line_ptr += 1;\n-  if (lh->version >= 4)\n-    {\n-      lh->maximum_ops_per_instruction = read_1_byte (abfd, line_ptr);\n-      line_ptr += 1;\n-    }\n-  else\n-    lh->maximum_ops_per_instruction = 1;\n-\n-  if (lh->maximum_ops_per_instruction == 0)\n-    {\n-      lh->maximum_ops_per_instruction = 1;\n-      complaint (_(\"invalid maximum_ops_per_instruction \"\n-\t\t   \"in `.debug_line' section\"));\n-    }\n-\n-  lh->default_is_stmt = read_1_byte (abfd, line_ptr);\n-  line_ptr += 1;\n-  lh->line_base = read_1_signed_byte (abfd, line_ptr);\n-  line_ptr += 1;\n-  lh->line_range = read_1_byte (abfd, line_ptr);\n-  line_ptr += 1;\n-  lh->opcode_base = read_1_byte (abfd, line_ptr);\n-  line_ptr += 1;\n-  lh->standard_opcode_lengths.reset (new unsigned char[lh->opcode_base]);\n-\n-  lh->standard_opcode_lengths[0] = 1;  /* This should never be used anyway.  */\n-  for (i = 1; i < lh->opcode_base; ++i)\n-    {\n-      lh->standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr);\n-      line_ptr += 1;\n-    }\n-\n-  if (lh->version >= 5)\n-    {\n-      /* Read directory table.  */\n-      read_formatted_entries (dwarf2_per_objfile, abfd, &line_ptr, lh.get (),\n-\t\t\t      &cu->header,\n-\t\t\t      [] (struct line_header *header, const char *name,\n-\t\t\t\t  dir_index d_index, unsigned int mod_time,\n-\t\t\t\t  unsigned int length)\n-\t{\n-\t  header->add_include_dir (name);\n-\t});\n-\n-      /* Read file name table.  */\n-      read_formatted_entries (dwarf2_per_objfile, abfd, &line_ptr, lh.get (),\n-\t\t\t      &cu->header,\n-\t\t\t      [] (struct line_header *header, const char *name,\n-\t\t\t\t  dir_index d_index, unsigned int mod_time,\n-\t\t\t\t  unsigned int length)\n-\t{\n-\t  header->add_file_name (name, d_index, mod_time, length);\n-\t});\n-    }\n-  else\n-    {\n-      /* Read directory table.  */\n-      while ((cur_dir = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)\n-\t{\n-\t  line_ptr += bytes_read;\n-\t  lh->add_include_dir (cur_dir);\n-\t}\n-      line_ptr += bytes_read;\n-\n-      /* Read file name table.  */\n-      while ((cur_file = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)\n-\t{\n-\t  unsigned int mod_time, length;\n-\t  dir_index d_index;\n-\n-\t  line_ptr += bytes_read;\n-\t  d_index = (dir_index) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-\t  line_ptr += bytes_read;\n-\t  mod_time = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-\t  line_ptr += bytes_read;\n-\t  length = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);\n-\t  line_ptr += bytes_read;\n-\n-\t  lh->add_file_name (cur_file, d_index, mod_time, length);\n-\t}\n-      line_ptr += bytes_read;\n-    }\n-\n-  if (line_ptr > (section->buffer + section->size))\n-    complaint (_(\"line number info header doesn't \"\n-\t\t \"fit in `.debug_line' section\"));\n-\n-  return lh;\n+  return dwarf_decode_line_header (sect_off, cu->per_cu->is_dwz,\n+\t\t\t\t   dwarf2_per_objfile, section,\n+\t\t\t\t   &cu->header);\n }\n \n /* Subroutine of dwarf_decode_lines to simplify it."
    }
  ]
}