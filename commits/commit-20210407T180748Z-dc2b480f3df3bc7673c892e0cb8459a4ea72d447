{
  "sha": "dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGMyYjQ4MGYzZGYzYmM3NjczYzg5MmUwY2I4NDU5YTRlYTcyZDQ0Nw==",
  "commit": {
    "author": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-04-07T18:07:48Z"
    },
    "committer": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-04-07T18:07:48Z"
    },
    "message": "CTF: handle forward reference type\n\nAdded function fetch_tid_type which calls get_tid_type and will set up\nthe type, associated with a tid, if it is not read in yet. Also implement\nfunction read_forward_type which handles the CTF_K_FORWARD kind.\n\nExpanded gdb.base/ctf-ptype.exp to add cases with forward references.\n\ngdb/ChangeLog:\n       * ctfread.c (fetch_tid_type): New function, use throughout file.\n       (read_forward_type): New function.\n       (read_type_record): Call read_forward_type.\n\ngdb/testsuite/ChangeLog:\n       * gdb.base/ctf-ptype.c: Add struct link containing a forward\n       reference type.\n       * gdb.base/ctf-ptype.exp: Add \"ptype struct link\".",
    "tree": {
      "sha": "726c2ad7e681e30b01f30cc3c5ac44cec3b5f51e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/726c2ad7e681e30b01f30cc3c5ac44cec3b5f51e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/comments",
  "author": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0a703a4cedffa6f3824e87f115e8d392e32de191",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a703a4cedffa6f3824e87f115e8d392e32de191",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0a703a4cedffa6f3824e87f115e8d392e32de191"
    }
  ],
  "stats": {
    "total": 104,
    "additions": 91,
    "deletions": 13
  },
  "files": [
    {
      "sha": "e817ba66b04ad5951613a8af776e9444405576e9",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
      "patch": "@@ -1,3 +1,9 @@\n+2021-04-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* ctfread.c (fetch_tid_type): New function, use throughout file.\n+\t(read_forward_type): New function.\n+\t(read_type_record): Call read_forward_type.\n+\n 2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-exp.h (class fortran_structop_operation): New class."
    },
    {
      "sha": "e2b65b622de20d6f5a0268931a64371264fba101",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 65,
      "deletions": 13,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
      "patch": "@@ -190,6 +190,8 @@ static void process_structure_type (struct ctf_context *cp, ctf_id_t tid);\n static void process_struct_members (struct ctf_context *cp, ctf_id_t tid,\n \t\t\t\t    struct type *type);\n \n+static struct type *read_forward_type (struct ctf_context *cp, ctf_id_t tid);\n+\n static struct symbol *new_symbol (struct ctf_context *cp, struct type *type,\n \t\t\t\t  ctf_id_t tid);\n \n@@ -273,6 +275,25 @@ get_tid_type (struct objfile *of, ctf_id_t tid)\n     return nullptr;\n }\n \n+/* Fetch the type for TID in CCP OF's tid_and_type hash, add the type to\n+ *    context CCP if hash is empty or TID does not have a saved type.  */\n+\n+static struct type *\n+fetch_tid_type (struct ctf_context *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  struct type *typ;\n+\n+  typ = get_tid_type (of, tid);\n+  if (typ == nullptr)\n+    {\n+      ctf_add_type_cb (tid, ccp);\n+      typ = get_tid_type (of, tid);\n+    }\n+\n+  return typ;\n+}\n+\n /* Return the size of storage in bits for INTEGER, FLOAT, or ENUM.  */\n \n static int\n@@ -372,7 +393,7 @@ ctf_add_member_cb (const char *name,\n   FIELD_NAME (*fp) = name;\n \n   kind = ctf_type_kind (ccp->fp, tid);\n-  t = get_tid_type (ccp->of, tid);\n+  t = fetch_tid_type (ccp, tid);\n   if (t == nullptr)\n     {\n       t = read_type_record (ccp, tid);\n@@ -667,7 +688,7 @@ read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   type->set_code (TYPE_CODE_FUNC);\n   ctf_func_type_info (fp, tid, &cfi);\n-  rettype = get_tid_type (of, cfi.ctc_return);\n+  rettype = fetch_tid_type (ccp, cfi.ctc_return);\n   TYPE_TARGET_TYPE (type) = rettype;\n   set_type_align (type, ctf_type_align (fp, tid));\n \n@@ -794,11 +815,11 @@ read_array_type (struct ctf_context *ccp, ctf_id_t tid)\n       return nullptr;\n     }\n \n-  element_type = get_tid_type (objfile, ar.ctr_contents);\n+  element_type = fetch_tid_type (ccp, ar.ctr_contents);\n   if (element_type == nullptr)\n     return nullptr;\n \n-  idx_type = get_tid_type (objfile, ar.ctr_index);\n+  idx_type = fetch_tid_type (ccp, ar.ctr_index);\n   if (idx_type == nullptr)\n     idx_type = objfile_type (objfile)->builtin_int;\n \n@@ -826,7 +847,7 @@ read_const_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct objfile *objfile = ccp->of;\n   struct type *base_type, *cv_type;\n \n-  base_type = get_tid_type (objfile, btid);\n+  base_type = fetch_tid_type (ccp, btid);\n   if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n@@ -850,7 +871,7 @@ read_volatile_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   ctf_dict_t *fp = ccp->fp;\n   struct type *base_type, *cv_type;\n \n-  base_type = get_tid_type (objfile, btid);\n+  base_type = fetch_tid_type (ccp, btid);\n   if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n@@ -876,7 +897,7 @@ read_restrict_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct objfile *objfile = ccp->of;\n   struct type *base_type, *cv_type;\n \n-  base_type = get_tid_type (objfile, btid);\n+  base_type = fetch_tid_type (ccp, btid);\n   if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n@@ -903,7 +924,7 @@ read_typedef_type (struct ctf_context *ccp, ctf_id_t tid,\n   char *aname = obstack_strdup (&objfile->objfile_obstack, name);\n   this_type = init_type (objfile, TYPE_CODE_TYPEDEF, 0, aname);\n   set_tid_type (objfile, tid, this_type);\n-  target_type = get_tid_type (objfile, btid);\n+  target_type = fetch_tid_type (ccp, btid);\n   if (target_type != this_type)\n     TYPE_TARGET_TYPE (this_type) = target_type;\n   else\n@@ -922,7 +943,7 @@ read_pointer_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct objfile *of = ccp->of;\n   struct type *target_type, *type;\n \n-  target_type = get_tid_type (of, btid);\n+  target_type = fetch_tid_type (ccp, btid);\n   if (target_type == nullptr)\n     {\n       target_type = read_type_record (ccp, btid);\n@@ -939,6 +960,34 @@ read_pointer_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   return set_tid_type (of, tid, type);\n }\n \n+/* Read information from a TID of CTF_K_FORWARD.  */\n+\n+static struct type *\n+read_forward_type (struct ctf_context *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  ctf_dict_t *fp = ccp->fp;\n+  struct type *type;\n+  uint32_t kind;\n+\n+  type = alloc_type (of);\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  if (name != NULL && strlen (name.get()) != 0)\n+    type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n+\n+  kind = ctf_type_kind_forwarded (fp, tid);\n+  if (kind == CTF_K_UNION)\n+    type->set_code (TYPE_CODE_UNION);\n+  else\n+    type->set_code (TYPE_CODE_STRUCT);\n+\n+  TYPE_LENGTH (type) = 0;\n+  type->set_is_stub (true);\n+\n+  return set_tid_type (of, tid, type);\n+}\n+\n /* Read information associated with type TID.  */\n \n static struct type *\n@@ -992,6 +1041,9 @@ read_type_record (struct ctf_context *ccp, ctf_id_t tid)\n       case CTF_K_ARRAY:\n \ttype = read_array_type (ccp, tid);\n \tbreak;\n+      case CTF_K_FORWARD:\n+\ttype = read_forward_type (ccp, tid);\n+\tbreak;\n       case CTF_K_UNKNOWN:\n \tbreak;\n       default:\n@@ -1138,7 +1190,7 @@ add_stt_obj (struct ctf_context *ccp, unsigned long idx)\n   if ((tid = ctf_lookup_by_symbol (ccp->fp, idx)) == CTF_ERR)\n     return nullptr;\n \n-  type = get_tid_type (ccp->of, tid);\n+  type = fetch_tid_type (ccp, tid);\n   if (type == nullptr)\n     return nullptr;\n \n@@ -1172,7 +1224,7 @@ add_stt_func (struct ctf_context *ccp, unsigned long idx)\n     return nullptr;\n \n   tid = ctf_lookup_by_symbol (ccp->fp, idx);\n-  ftype = get_tid_type (ccp->of, tid);\n+  ftype = fetch_tid_type (ccp, tid);\n   if ((finfo.ctc_flags & CTF_FUNC_VARARG) != 0)\n     ftype->set_has_varargs (true);\n   ftype->set_num_fields (argc);\n@@ -1186,15 +1238,15 @@ add_stt_func (struct ctf_context *ccp, unsigned long idx)\n      to find the argument type.  */\n   for (int iparam = 0; iparam < argc; iparam++)\n     {\n-      atyp = get_tid_type (ccp->of, argv[iparam]);\n+      atyp = fetch_tid_type (ccp, argv[iparam]);\n       if (atyp)\n \tftype->field (iparam).set_type (atyp);\n       else\n \tftype->field (iparam).set_type (void_type);\n     }\n \n   sym = new_symbol (ccp, ftype, tid);\n-  rettyp = get_tid_type (ccp->of, finfo.ctc_return);\n+  rettyp = fetch_tid_type (ccp, finfo.ctc_return);\n   if (rettyp != nullptr)\n     SYMBOL_TYPE (sym) = rettyp;\n   else"
    },
    {
      "sha": "53333f93379b4e179e56e7f4c6e1a21474430b3b",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
      "patch": "@@ -1,3 +1,9 @@\n+2021-04-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* gdb.base/ctf-ptype.c: Add struct link containing a forward\n+\treference type.\n+\t* gdb.base/ctf-ptype.exp: Add \"ptype struct link\".\n+\n 2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.fortran/dynamic-ptype-whatis.exp: New file."
    },
    {
      "sha": "51c7c6868ee190097063a002ddcb8f44e1efe97a",
      "filename": "gdb/testsuite/gdb.base/ctf-ptype.c",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/gdb.base/ctf-ptype.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/gdb.base/ctf-ptype.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-ptype.c?ref=dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
      "patch": "@@ -124,6 +124,18 @@ typedef struct {\n    a symbol.  */\n t_struct3 v_struct3;\n \n+/**** Some misc more complicated things *******/\n+\n+struct link {\n+\tstruct link *next;\n+#ifdef __STDC__\n+\tstruct link *(*linkfunc) (struct link *self, int flags);\n+#else\n+\tstruct link *(*linkfunc) ();\n+#endif\n+\tstruct t_struct stuff[3];\n+} *s_link;\n+\n /**** unions *******/\n \n union t_union {"
    },
    {
      "sha": "7dd6d95ce772277523d7b9b7a34b1edf6ddc14ab",
      "filename": "gdb/testsuite/gdb.base/ctf-ptype.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dc2b480f3df3bc7673c892e0cb8459a4ea72d447/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-ptype.exp?ref=dc2b480f3df3bc7673c892e0cb8459a4ea72d447",
      "patch": "@@ -76,6 +76,8 @@ if [gdb_test \"ptype v_t_struct_p->v_float_member\"\t\"type = float\"]<0 then {\n     return -1\n }\n \n+gdb_test \"ptype struct link\" \"type = struct link \\{\\[\\r\\n\\]+\\[ \\t\\]+struct link \\\\*next;\\[\\r\\n\\]+\\[ \\t\\]+struct link \\\\*\\\\(\\\\*linkfunc\\\\)\\\\((struct link \\\\*, int|void|)\\\\);\\[\\r\\n\\]+\\[ \\t\\]+struct t_struct stuff.3.;\\[\\r\\n\\]+\\}.*\" \"ptype linked list structure\"\n+\n #\n # test ptype command with unions\n #"
    }
  ]
}