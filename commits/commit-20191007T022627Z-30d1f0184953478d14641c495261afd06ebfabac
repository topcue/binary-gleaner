{
  "sha": "30d1f0184953478d14641c495261afd06ebfabac",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzBkMWYwMTg0OTUzNDc4ZDE0NjQxYzQ5NTI2MWFmZDA2ZWJmYWJhYw==",
  "commit": {
    "author": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2019-10-07T00:46:52Z"
    },
    "committer": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2019-10-07T02:26:27Z"
    },
    "message": "gdb: CTF support\n\nThis patch adds the CTF (Compact Ansi-C Type Format) support in gdb.\nTwo submissions on which this gdb work depends were posted earlier\nin May:\n\n * On the binutils mailing list - adding libctf which creates, updates,\n   reads, and manipulates the CTF data.\n * On the gcc mailing list - expanding gcc to directly emit the CFT data\n   with a new command line option -gt.\n\nCTF is a reduced form of debugging information whose main purpose is to\ndescribe the type of C entities such as structures, unions, typedefs and\nfunction arguments at the global scope only. It does not contain debug\ninformation about source lines, location expressions, or local variables.\nFor more information on CTF, see the documentation in the libdtrace-ctf\nsource tree, available here:\n\n<https://raw.githubusercontent.com/oracle/libdtrace-ctf/master/doc/ctf-format>.\n\nThis patch expands struct elfinfo by adding the .ctf section, which\ncontains CTF debugging info, and modifies elf_symfile_read() to read it.\nIf both DWARF and CTF exist in a program, only DWARF will be read. CTF data\nwill be read only when there is no DWARF. The two-stage symbolic reading\nand setting strategy, partial and full, was used.\n\nFile ctfread.c contains functions to transform CTF data into gdb's internal\nsymbol table structures by iterately reading entries from CTF sections\nof \"data objects\", \"function info\", \"variable info\", and \"data types\"\nwhen setting up either partial or full symbol table. If the ELF symbol table\nis available, e.g. not stripped, the CTF reader will associate the found\ntype information with these symbol entries. Due to the proximity between DWARF\nand CTF (CTF being a much simplified subset of DWARF), some DWARF implementation\nwas reused to support CTF.\n\nTest cases ctf-constvars.exp, ctf-cvexpr.exp, ctf-ptype.exp, and ctf-whatis.exp\nhave been added to verify the correctness of this support.\n\nThis patch has missing features and limitations which we will add and\naddress in the future patches.\n\ngdb/ChangeLog\n+2019-10-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+       * gdb/ctfread.c: New file.\n+       * gdb/ctfread.h: New file.\n+       * gdb/elfread.c: Include ctfread.h.\n+       (struct elfinfo text_p): New member ctfsect.\n+       (elf_locate_sections): Mark CTF section.\n+       (elf_symfile_read): Call elfctf_build_psymtabs.\n+       * gdb/Makefile.in (LIBCTF): Add.\n+       (CLIBS): Use it.\n+       (CDEPS): Likewise.\n+       (DIST): Add ctfread.c.\n+       * Makefile.def (dependencies): Add all-libctf to all-gdb\n+       * Makefile.in: Add \"all-gdb: maybe-all-libctf\"\n+\ngdb/testsuite/ChangeLog\n+2019-10-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+       * gdb.base/ctf-whatis.exp: New file.\n+       * gdb.base/ctf-whatis.c: New file.\n+       * gdb.base/ctf-ptype.exp: New file.\n+       * gdb.base/ctf-ptype.c: New file.\n+       * gdb.base/ctf-constvars.exp: New file.\n+       * gdb.base/ctf-constvars.c: New file.\n+       * gdb.base/ctf-cvexpr.exp: New file.\n+",
    "tree": {
      "sha": "8fde16f1b36e4bc889e54f9803d94cee835b66be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8fde16f1b36e4bc889e54f9803d94cee835b66be"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/30d1f0184953478d14641c495261afd06ebfabac",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30d1f0184953478d14641c495261afd06ebfabac",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/30d1f0184953478d14641c495261afd06ebfabac",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30d1f0184953478d14641c495261afd06ebfabac/comments",
  "author": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "518fe38cd9c206b2a239d9b93677017203c385cb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/518fe38cd9c206b2a239d9b93677017203c385cb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/518fe38cd9c206b2a239d9b93677017203c385cb"
    }
  ],
  "stats": {
    "total": 3578,
    "additions": 3575,
    "deletions": 3
  },
  "files": [
    {
      "sha": "311feb9de3bac4285bd4f33b168076100983ed74",
      "filename": "Makefile.def",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/Makefile.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/Makefile.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/Makefile.def?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -404,6 +404,7 @@ dependencies = { module=all-gdb; on=all-build-bison; };\n dependencies = { module=all-gdb; on=all-sim; };\n dependencies = { module=all-gdb; on=all-libdecnumber; };\n dependencies = { module=all-gdb; on=all-libtermcap; };\n+dependencies = { module=all-gdb; on=all-libctf; };\n \n dependencies = { module=configure-libgui; on=configure-tcl; };\n dependencies = { module=configure-libgui; on=configure-tk; };"
    },
    {
      "sha": "1aabf6ede4474774b55edd058ebaa4328c0dd23c",
      "filename": "Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/Makefile.in?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -51524,6 +51524,7 @@ all-gdb: maybe-all-libiberty\n all-gdb: maybe-all-libiconv\n all-gdb: maybe-all-opcodes\n all-gdb: maybe-all-libdecnumber\n+all-gdb: maybe-all-libctf\n configure-gprof: maybe-configure-intl\n all-gprof: maybe-all-libiberty\n all-gprof: maybe-all-bfd"
    },
    {
      "sha": "af80baa2cba0522acba75dec1c897331921498d7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -1,3 +1,18 @@\n+2019-10-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* ctfread.c: New file.\n+\t* ctfread.h: New file.\n+\t* elfread.c: Include ctfread.h.\n+\t(struct elfinfo text_p): New member ctfsect.\n+\t(elf_locate_sections): Mark CTF section.\n+\t(elf_symfile_read): Call elfctf_build_psymtabs.\n+\t* Makefile.in (LIBCTF): Add.\n+\t(CLIBS): Use it.\n+\t(CDEPS): Likewise.\n+\t(DIST): Add ctfread.c.\n+\t* ../Makefile.def (dependencies): Add all-libctf to all-gdb\n+\t* ../Makefile.in: Add \"all-gdb: maybe-all-libctf\"\n+\n 2019-10-07  Weimin Pan  <weimin.pan@oracle.com>\n \n \t* tracectf.h: Rename, was ctf.h."
    },
    {
      "sha": "36650ad555fa28e5bfe4f6966039ac6301d04c12",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -153,6 +153,9 @@ INCLUDE_CFLAGS = -I$(INCLUDE_DIR)\n # Where is the \"-liberty\" library?  Typically in ../libiberty.\n LIBIBERTY = ../libiberty/libiberty.a\n \n+# Where is the CTF library?  Typically in ../libctf.\n+LIBCTF = ../libctf/.libs/libctf.a\n+\n # Where is the BFD library?  Typically in ../bfd.\n BFD_DIR = ../bfd\n BFD = $(BFD_DIR)/libbfd.a\n@@ -588,13 +591,14 @@ INTERNAL_LDFLAGS = \\\n # Libraries and corresponding dependencies for compiling gdb.\n # XM_CLIBS, defined in *config files, have host-dependent libs.\n # LIBIBERTY appears twice on purpose.\n-CLIBS = $(SIM) $(READLINE) $(OPCODES) $(BFD) $(ZLIB) $(INTL) $(LIBIBERTY) $(LIBDECNUMBER) \\\n+CLIBS = $(SIM) $(READLINE) $(OPCODES) $(BFD) $(LIBCTF) $(ZLIB) \\\n+        $(INTL) $(LIBIBERTY) $(LIBDECNUMBER) \\\n \t$(XM_CLIBS) $(GDBTKLIBS) \\\n \t@LIBS@ @GUILE_LIBS@ @PYTHON_LIBS@ \\\n \t$(LIBEXPAT) $(LIBLZMA) $(LIBBABELTRACE) $(LIBIPT) \\\n \t$(LIBIBERTY) $(WIN32LIBS) $(LIBGNU) $(LIBICONV) $(LIBMPFR) \\\n \t$(SRCHIGH_LIBS)\n-CDEPS = $(NAT_CDEPS) $(SIM) $(BFD) $(READLINE_DEPS) \\\n+CDEPS = $(NAT_CDEPS) $(SIM) $(BFD) $(READLINE_DEPS) $(LIBCTF) \\\n \t$(OPCODES) $(INTL_DEPS) $(LIBIBERTY) $(CONFIG_DEPS) $(LIBGNU)\n \n DIST = gdb\n@@ -988,6 +992,7 @@ COMMON_SFILES = \\\n \tcp-namespace.c \\\n \tcp-support.c \\\n \tcp-valprint.c \\\n+\tctfread.c \\\n \td-lang.c \\\n \td-namespace.c \\\n \td-valprint.c \\"
    },
    {
      "sha": "3e3bd89d5f1be742d30a7925beef51dc1452a93e",
      "filename": "gdb/ctfread.c",
      "status": "added",
      "additions": 1486,
      "deletions": 0,
      "changes": 1486,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,1486 @@\n+/* Compact ANSI-C Type Format (CTF) support in GDB.\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file format can be used to compactly represent the information needed\n+   by a debugger to interpret the ANSI-C types used by a given program.\n+   Traditionally, this kind of information is generated by the compiler when\n+   invoked with the -g flag and is stored in \"stabs\" strings or in the more\n+   modern DWARF format. A new -gtLEVEL option has been added in gcc to generate\n+   such information. CTF provides a representation of only the information\n+   that is relevant to debugging a complex, optimized C program such as the\n+   operating system kernel in a form that is significantly more compact than\n+   the equivalent stabs or DWARF representation.  The format is data-model\n+   independent, so consumers do not need different code depending on whether\n+   they are 32-bit or 64-bit programs.  CTF assumes that a standard ELF symbol\n+   table is available for use in the debugger, and uses the structure and data\n+   of the symbol table to avoid storing redundant information.  The CTF data\n+   may be compressed on disk or in memory, indicated by a bit in the header.\n+   CTF may be interpreted in a raw disk file, or it may be stored in an ELF\n+   section, typically named .ctf.  Data structures are aligned so that a raw\n+   CTF file or CTF ELF section may be manipulated using mmap(2).\n+\n+   The CTF file or section itself has the following structure:\n+\n+   +--------+--------+---------+----------+----------+-------+--------+\n+   |  file  |  type  |  data   | function | variable | data  | string |\n+   | header | labels | objects |   info   |   info   | types | table  |\n+   +--------+--------+---------+----------+----------+-------+--------+\n+\n+   The file header stores a magic number and version information, encoding\n+   flags, and the byte offset of each of the sections relative to the end of the\n+   header itself.  If the CTF data has been uniquified against another set of\n+   CTF data, a reference to that data also appears in the the header.  This\n+   reference is the name of the label corresponding to the types uniquified\n+   against.\n+\n+   Following the header is a list of labels, used to group the types included in\n+   the data types section.  Each label is accompanied by a type ID i.  A given\n+   label refers to the group of types whose IDs are in the range [0, i].\n+\n+   Data object and function records are stored in the same order as they appear\n+   in the corresponding symbol table, except that symbols marked SHN_UNDEF are\n+   not stored and symbols that have no type data are padded out with zeroes.\n+   For each data object, the type ID (a small integer) is recorded.  For each\n+   function, the type ID of the return type and argument types is recorded.\n+\n+   Variable records (as distinct from data objects) provide a modicum of support\n+   for non-ELF systems, mapping a variable name to a CTF type ID.  The variable\n+   names are sorted into ASCIIbetical order, permitting binary searching.\n+\n+   The data types section is a list of variable size records that represent each\n+   type, in order by their ID.  The types themselves form a directed graph,\n+   where each node may contain one or more outgoing edges to other type nodes,\n+   denoted by their ID.\n+\n+   Strings are recorded as a string table ID (0 or 1) and a byte offset into the\n+   string table.  String table 0 is the internal CTF string table.  String table\n+   1 is the external string table, which is the string table associated with the\n+   ELF symbol table for this object.  CTF does not record any strings that are\n+   already in the symbol table, and the CTF string table does not contain any\n+   duplicated strings.  */\n+\n+#include \"defs.h\"\n+#include \"buildsym.h\"\n+#include \"complaints.h\"\n+#include \"block.h\"\n+#include \"ctfread.h\"\n+#include \"psympriv.h\"\n+#include \"ctf.h\"\n+#include \"ctf-api.h\"\n+\n+static const struct objfile_key<htab, htab_deleter> ctf_tid_key;\n+static const struct objfile_data *ctf_file_key;\n+\n+/* A CTF context consists of a file pointer and an objfile pointer.  */\n+\n+typedef struct ctf_context\n+{\n+  ctf_file_t *fp;\n+  struct objfile *of;\n+  struct buildsym_compunit *builder;\n+} ctf_context_t;\n+\n+/* The routines that read and process fields/members of a C struct, union,\n+   or enumeration, pass lists of data member fields in an instance of a\n+   field_info structure. It is derived from dwarf2read.c.  */\n+\n+struct nextfield\n+{\n+  struct field field {};\n+};\n+\n+struct field_info\n+{\n+  /* List of data member fields.  */\n+  std::vector<struct nextfield> fields;\n+\n+  /* Context.  */\n+  ctf_context_t *cur_context;\n+\n+  /* Parent type.  */\n+  struct type *ptype;\n+\n+  /* typedefs defined inside this class.  TYPEDEF_FIELD_LIST contains head\n+     of a NULL terminated list of TYPEDEF_FIELD_LIST_COUNT elements.  */\n+  std::vector<struct decl_field> typedef_field_list;\n+\n+  /* Nested types defined by this struct and the number of elements in\n+     this list.  */\n+  std::vector<struct decl_field> nested_types_list;\n+};\n+\n+\n+/* Local function prototypes */\n+\n+static void psymtab_to_symtab (struct partial_symtab *);\n+\n+static int ctf_add_type_cb (ctf_id_t tid, void *arg);\n+\n+static struct type *read_array_type (ctf_context_t *ccp, ctf_id_t tid);\n+\n+static struct type *read_pointer_type (ctf_context_t *ccp, ctf_id_t tid,\n+\t\t\t\t       ctf_id_t btid);\n+\n+static struct type *read_structure_type (ctf_context_t *ccp, ctf_id_t tid);\n+\n+static struct type *read_enum_type (ctf_context_t *ccp, ctf_id_t tid);\n+\n+static struct type *read_typedef_type (ctf_context_t *ccp, ctf_id_t tid,\n+\t\t\t\t       ctf_id_t btid, const char *name);\n+\n+static struct type *read_type_record (ctf_context_t *ccp, ctf_id_t tid);\n+\n+static void process_structure_type (ctf_context_t *ccp, ctf_id_t tid);\n+\n+static void process_struct_members (ctf_context_t *ccp, ctf_id_t tid,\n+\t\t\t\t    struct type *type);\n+\n+static struct symbol *new_symbol (ctf_context_t *ccp, struct type *type,\n+\t\t\t\t  ctf_id_t tid);\n+\n+struct ctf_tid_and_type\n+{\n+  ctf_id_t tid;\n+  struct type *type;\n+};\n+\n+/* Hash function for a ctf_tid_and_type.  */\n+\n+static hashval_t\n+tid_and_type_hash (const void *item)\n+{\n+  const struct ctf_tid_and_type *ids\n+    = (const struct ctf_tid_and_type *) item;\n+\n+  return ids->tid;\n+}\n+\n+/* Equality function for a ctf_tid_and_type.  */\n+\n+static int\n+tid_and_type_eq (const void *item_lhs, const void *item_rhs)\n+{\n+  const struct ctf_tid_and_type *ids_lhs\n+    = (const struct ctf_tid_and_type *) item_lhs;\n+  const struct ctf_tid_and_type *ids_rhs\n+    = (const struct ctf_tid_and_type *) item_rhs;\n+\n+  return ids_lhs->tid == ids_rhs->tid;\n+}\n+\n+/* Set the type associated with TID to TYP.  */\n+\n+static struct type *\n+set_tid_type (struct objfile *of, ctf_id_t tid, struct type *typ)\n+{\n+  htab_t htab;\n+\n+  htab = (htab_t) ctf_tid_key.get (of);\n+  if (htab == NULL)\n+    {\n+      htab = htab_create_alloc (1, tid_and_type_hash,\n+\t\t\t\ttid_and_type_eq,\n+\t\t\t\tNULL, xcalloc, xfree);\n+      ctf_tid_key.set (of, htab);\n+    }\n+\n+  struct ctf_tid_and_type **slot, ids;\n+  ids.tid = tid;\n+  ids.type = typ;\n+  slot = (struct ctf_tid_and_type **) htab_find_slot (htab, &ids, INSERT);\n+  if (*slot)\n+    complaint (_(\"An internal GDB problem: ctf_ id_t %ld type already set\"),\n+\t       (tid));\n+  *slot = XOBNEW (&of->objfile_obstack, struct ctf_tid_and_type);\n+  **slot = ids;\n+  return typ;\n+}\n+\n+/* Look up the type for TID in tid_and_type hash, return NULL if hash is\n+   empty or TID does not have a saved type.  */\n+\n+static struct type *\n+get_tid_type (struct objfile *of, ctf_id_t tid)\n+{\n+  struct ctf_tid_and_type *slot, ids;\n+  htab_t htab;\n+\n+  htab = (htab_t) ctf_tid_key.get (of);\n+  if (htab == NULL)\n+    return NULL;\n+\n+  ids.tid = tid;\n+  ids.type = NULL;\n+  slot = (struct ctf_tid_and_type *) htab_find (htab, &ids);\n+  if (slot)\n+    return slot->type;\n+  else\n+    return NULL;\n+}\n+\n+/* Return the size of storage in bits for INTEGER, FLOAT, or ENUM.  */\n+\n+static int\n+get_bitsize (ctf_file_t *fp, ctf_id_t tid, uint32_t kind)\n+{\n+  ctf_encoding_t cet;\n+\n+  if ((kind == CTF_K_INTEGER || kind == CTF_K_ENUM\n+      || kind == CTF_K_FLOAT)\n+      && ctf_type_reference (fp, tid) != CTF_ERR\n+      && ctf_type_encoding (fp, tid, &cet) != CTF_ERR)\n+    return cet.cte_bits;\n+\n+  return 0;\n+}\n+\n+/* Set SYM's address, with NAME, from its minimal symbol entry.  */\n+\n+static void\n+set_symbol_address (struct objfile *of, struct symbol *sym, const char *name)\n+{\n+  struct bound_minimal_symbol msym;\n+\n+  msym = lookup_minimal_symbol (name, NULL, of);\n+  if (msym.minsym != NULL)\n+    {\n+      SET_SYMBOL_VALUE_ADDRESS (sym, BMSYMBOL_VALUE_ADDRESS (msym));\n+      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+      SYMBOL_SECTION (sym) = MSYMBOL_SECTION (msym.minsym);\n+    }\n+}\n+\n+/* Create the vector of fields, and attach it to TYPE.  */\n+\n+static void\n+attach_fields_to_type (struct field_info *fip, struct type *type)\n+{\n+  int nfields = fip->fields.size ();\n+\n+  if (nfields == 0)\n+    return;\n+\n+  /* Record the field count, allocate space for the array of fields.  */\n+  TYPE_NFIELDS (type) = nfields;\n+  TYPE_FIELDS (type)\n+    = (struct field *) TYPE_ZALLOC (type, sizeof (struct field) * nfields);\n+\n+  /* Copy the saved-up fields into the field vector.  */\n+  for (int i = 0; i < nfields; ++i)\n+    {\n+      struct nextfield &field = fip->fields[i];\n+      TYPE_FIELD (type, i) = field.field;\n+    }\n+}\n+\n+/* Allocate a floating-point type of size BITS and name NAME.  Pass NAME_HINT\n+   (which may be different from NAME) to the architecture back-end to allow\n+   it to guess the correct format if necessary.  */\n+\n+static struct type *\n+ctf_init_float_type (struct objfile *objfile,\n+\t\t     int bits,\n+\t\t     const char *name,\n+\t\t     const char *name_hint)\n+{\n+  struct gdbarch *gdbarch = get_objfile_arch (objfile);\n+  const struct floatformat **format;\n+  struct type *type;\n+\n+  format = gdbarch_floatformat_for_type (gdbarch, name_hint, bits);\n+  if (format != NULL)\n+    type = init_float_type (objfile, bits, name, format);\n+  else\n+    type = init_type (objfile, TYPE_CODE_ERROR, bits, name);\n+\n+  return type;\n+}\n+\n+/* Callback to add member NAME to a struct/union type. TID is the type\n+   of struct/union member, OFFSET is the offset of member in bits,\n+   and ARG contains the field_info.  */\n+\n+static int\n+ctf_add_member_cb (const char *name,\n+\t\t   ctf_id_t tid,\n+\t\t   unsigned long offset,\n+\t\t   void *arg)\n+{\n+  struct field_info *fip = (struct field_info *) arg;\n+  ctf_context_t *ccp = fip->cur_context;\n+  struct nextfield new_field;\n+  struct field *fp;\n+  struct type *t;\n+  uint32_t kind;\n+\n+  fp = &new_field.field;\n+  FIELD_NAME (*fp) = name;\n+\n+  kind = ctf_type_kind (ccp->fp, tid);\n+  t = get_tid_type (ccp->of, tid);\n+  if (t == NULL)\n+    {\n+      t = read_type_record (ccp, tid);\n+      if (t == NULL)\n+\t{\n+\t  complaint (_(\"ctf_add_member_cb: %s has NO type (%ld)\"), name, tid);\n+\t  t = objfile_type (ccp->of)->builtin_error;\n+\t  set_tid_type (ccp->of, tid, t);\n+\t}\n+    }\n+\n+  if (kind == CTF_K_STRUCT || kind == CTF_K_UNION)\n+    process_struct_members (ccp, tid, t);\n+\n+  FIELD_TYPE (*fp) = t;\n+  SET_FIELD_BITPOS (*fp, offset / TARGET_CHAR_BIT);\n+  FIELD_BITSIZE (*fp) = get_bitsize (ccp->fp, tid, kind);\n+\n+  fip->fields.emplace_back (new_field);\n+\n+  return 0;\n+}\n+\n+/* Callback to add member NAME of EVAL to an enumeration type.\n+   ARG contains the field_info.  */\n+\n+static int\n+ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n+{\n+  struct field_info *fip = (struct field_info *) arg;\n+  struct nextfield new_field;\n+  struct field *fp;\n+  ctf_context_t *ccp = fip->cur_context;\n+\n+  fp = &new_field.field;\n+  FIELD_NAME (*fp) = name;\n+  FIELD_TYPE (*fp) = NULL;\n+  SET_FIELD_ENUMVAL (*fp, enum_value);\n+  FIELD_BITSIZE (*fp) = 0;\n+\n+  if (name != NULL)\n+    {\n+      struct symbol *sym = allocate_symbol (ccp->of);\n+      OBJSTAT (ccp->of, n_syms++);\n+\n+      SYMBOL_SET_LANGUAGE (sym, language_c, &ccp->of->objfile_obstack);\n+      SYMBOL_SET_NAMES (sym, name, strlen (name), 0, ccp->of);\n+      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;\n+      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n+      SYMBOL_TYPE (sym) = fip->ptype;\n+      add_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n+    }\n+\n+  fip->fields.emplace_back (new_field);\n+\n+  return 0;\n+}\n+\n+/* Add a new symbol entry, with its name from TID, its access index and\n+   domain from TID's kind, and its type from TYPE.  */\n+\n+static struct symbol *\n+new_symbol (ctf_context_t *ccp, struct type *type, ctf_id_t tid)\n+{\n+  struct objfile *objfile = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct symbol *sym = NULL;\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  if (name != NULL)\n+    {\n+      sym = allocate_symbol (objfile);\n+      OBJSTAT (objfile, n_syms++);\n+\n+      SYMBOL_SET_LANGUAGE (sym, language_c, &objfile->objfile_obstack);\n+      SYMBOL_SET_NAMES (sym, name.get (), strlen (name.get ()), 1, objfile);\n+      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n+      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+\n+      if (type != NULL)\n+\tSYMBOL_TYPE (sym) = type;\n+\n+      uint32_t kind = ctf_type_kind (fp, tid);\n+      switch (kind)\n+\t{\n+\t  case CTF_K_STRUCT:\n+\t  case CTF_K_UNION:\n+\t  case CTF_K_ENUM:\n+\t    SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t    SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;\n+\t    break;\n+\t  case CTF_K_FUNCTION:\n+\t    SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t    break;\n+\t  case CTF_K_CONST:\n+\t    if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_VOID)\n+\t      SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_int;\n+\t    break;\n+\t  case CTF_K_TYPEDEF:\n+\t  case CTF_K_INTEGER:\n+\t  case CTF_K_FLOAT:\n+\t    SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n+\t    SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n+\t    break;\n+\t  case CTF_K_POINTER:\n+\t    break;\n+\t  case CTF_K_VOLATILE:\n+\t  case CTF_K_RESTRICT:\n+\t    break;\n+\t  case CTF_K_SLICE:\n+\t  case CTF_K_ARRAY:\n+\t  case CTF_K_UNKNOWN:\n+\t    break;\n+\t}\n+\n+      add_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n+    }\n+\n+  return sym;\n+}\n+\n+/* Given a TID of kind CTF_K_INTEGER or CTF_K_FLOAT, find a representation\n+   and create the symbol for it.  */\n+\n+static struct type *\n+read_base_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  ctf_encoding_t cet;\n+  struct type *type = NULL;\n+  char *name;\n+  uint32_t kind;\n+\n+  if (ctf_type_encoding (fp, tid, &cet))\n+    {\n+      complaint (_(\"ctf_type_encoding read_base_type failed - %s\"),\n+\t\t ctf_errmsg (ctf_errno (fp)));\n+      return NULL;\n+    }\n+\n+  gdb::unique_xmalloc_ptr<char> copied_name (ctf_type_aname_raw (fp, tid));\n+  if (copied_name == NULL || strlen (copied_name.get ()) == 0)\n+    {\n+      name = ctf_type_aname (fp, tid);\n+      if (name == NULL)\n+\tcomplaint (_(\"ctf_type_aname read_base_type failed - %s\"),\n+\t\t   ctf_errmsg (ctf_errno (fp)));\n+    }\n+  else\n+    name = obstack_strdup (&of->objfile_obstack, copied_name.get ());\n+\n+  kind = ctf_type_kind (fp, tid);\n+  if (kind == CTF_K_INTEGER)\n+    {\n+      uint32_t issigned, ischar, isbool;\n+      struct gdbarch *gdbarch = get_objfile_arch (of);\n+\n+      issigned = cet.cte_format & CTF_INT_SIGNED;\n+      ischar = cet.cte_format & CTF_INT_CHAR;\n+      isbool = cet.cte_format & CTF_INT_BOOL;\n+      if (ischar)\n+\ttype = init_character_type (of, TARGET_CHAR_BIT, !issigned, name);\n+      else if (isbool)\n+\ttype = init_boolean_type (of, gdbarch_int_bit (gdbarch),\n+\t\t\t\t  !issigned, name);\n+      else\n+\t{\n+\t  int bits;\n+\t  if (cet.cte_bits && ((cet.cte_bits % TARGET_CHAR_BIT) == 0))\n+\t    bits = cet.cte_bits;\n+\t  else\n+\t    bits = gdbarch_int_bit (gdbarch);\n+\t  type = init_integer_type (of, bits, !issigned, name);\n+\t}\n+    }\n+  else if (kind == CTF_K_FLOAT)\n+    {\n+      uint32_t isflt;\n+      isflt = !((cet.cte_format & CTF_FP_IMAGRY) == CTF_FP_IMAGRY\n+\t\t || (cet.cte_format & CTF_FP_DIMAGRY) == CTF_FP_DIMAGRY\n+\t\t || (cet.cte_format & CTF_FP_LDIMAGRY) == CTF_FP_LDIMAGRY);\n+      if (isflt)\n+\ttype = ctf_init_float_type (of, cet.cte_bits, name, name);\n+      else\n+\t{\n+\t  struct type *t\n+\t    = ctf_init_float_type (of, cet.cte_bits / 2, NULL, name);\n+\t  type = init_complex_type (of, name, t);\n+\t}\n+    }\n+  else\n+    {\n+      complaint (_(\"read_base_type: unsupported base kind (%d)\"), kind);\n+      type = init_type (of, TYPE_CODE_ERROR, cet.cte_bits, name);\n+    }\n+\n+  if (name != NULL && strcmp (name, \"char\") == 0)\n+    TYPE_NOSIGN (type) = 1;\n+\n+  return set_tid_type (of, tid, type);\n+}\n+\n+static void\n+process_base_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct type *type;\n+\n+  type = read_base_type (ccp, tid);\n+  new_symbol (ccp, type, tid);\n+}\n+\n+/* Start a structure or union scope (definition) with TID to create a type\n+   for the structure or union.\n+\n+   Fill in the type's name and general properties. The members will not be\n+   processed, nor a symbol table entry be done until process_structure_type\n+   (assuming the type has a name).  */\n+\n+static struct type *\n+read_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct type *type;\n+  uint32_t kind;\n+\n+  type = alloc_type (of);\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  if (name != NULL && strlen (name.get() ) != 0)\n+    TYPE_NAME (type) = obstack_strdup (&of->objfile_obstack, name.get ());\n+\n+  kind = ctf_type_kind (fp, tid);\n+  if (kind == CTF_K_UNION)\n+    TYPE_CODE (type) = TYPE_CODE_UNION;\n+  else\n+    TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+\n+  TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n+  set_type_align (type, ctf_type_align (fp, tid));\n+\n+  return set_tid_type (ccp->of, tid, type);\n+}\n+\n+/* Given a tid of CTF_K_STRUCT or CTF_K_UNION, process all its members\n+   and create the symbol for it.  */\n+\n+static void\n+process_struct_members (ctf_context_t *ccp,\n+\t\t\tctf_id_t tid,\n+\t\t\tstruct type *type)\n+{\n+  struct field_info fi;\n+\n+  fi.cur_context = ccp;\n+  if (ctf_member_iter (ccp->fp, tid, ctf_add_member_cb, &fi) == CTF_ERR)\n+    complaint (_(\"ctf_member_iter process_struct_members failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (ccp->fp)));\n+\n+  /* Attach fields to the type.  */\n+  attach_fields_to_type (&fi, type);\n+\n+  new_symbol (ccp, type, tid);\n+}\n+\n+static void\n+process_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct type *type;\n+\n+  type = read_structure_type (ccp, tid);\n+  process_struct_members (ccp, tid, type);\n+}\n+\n+/* Create a function type for TID and set its return type.  */\n+\n+static struct type *\n+read_func_kind_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct type *type, *rettype;\n+  ctf_funcinfo_t cfi;\n+\n+  type = alloc_type (of);\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  if (name != NULL && strlen (name.get ()) != 0)\n+    TYPE_NAME (type) = obstack_strdup (&of->objfile_obstack, name.get ());\n+\n+  TYPE_CODE (type) = TYPE_CODE_FUNC;\n+  ctf_func_type_info (fp, tid, &cfi);\n+  rettype = get_tid_type (of, cfi.ctc_return);\n+  TYPE_TARGET_TYPE (type) = rettype;\n+  set_type_align (type, ctf_type_align (fp, tid));\n+\n+  return set_tid_type (of, tid, type);\n+}\n+\n+/* Given a TID of CTF_K_ENUM, process all the members of the\n+   enumeration, and create the symbol for the enumeration type.  */\n+\n+static struct type *\n+read_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct objfile *of = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct type *type, *target_type;\n+  ctf_funcinfo_t fi;\n+\n+  type = alloc_type (of);\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  if (name != NULL && strlen (name.get ()) != 0)\n+    TYPE_NAME (type) = obstack_strdup (&of->objfile_obstack, name.get ());\n+\n+  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+  TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n+  ctf_func_type_info (fp, tid, &fi);\n+  target_type = get_tid_type (of, fi.ctc_return);\n+  TYPE_TARGET_TYPE (type) = target_type;\n+  set_type_align (type, ctf_type_align (fp, tid));\n+\n+  return set_tid_type (of, tid, type);\n+}\n+\n+static void\n+process_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct type *type;\n+  struct field_info fi;\n+\n+  type = read_enum_type (ccp, tid);\n+\n+  fi.cur_context = ccp;\n+  fi.ptype = type;\n+  if (ctf_enum_iter (ccp->fp, tid, ctf_add_enum_member_cb, &fi) == CTF_ERR)\n+    complaint (_(\"ctf_enum_iter process_enum_type failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (ccp->fp)));\n+\n+  /* Attach fields to the type.  */\n+  attach_fields_to_type (&fi, type);\n+\n+  new_symbol (ccp, type, tid);\n+}\n+\n+/* Add given cv-qualifiers CNST+VOLTL to the BASE_TYPE of array TID.  */\n+\n+static struct type *\n+add_array_cv_type (ctf_context_t *ccp,\n+\t\t   ctf_id_t tid,\n+\t\t   struct type *base_type,\n+\t\t   int cnst,\n+\t\t   int voltl)\n+{\n+  struct type *el_type, *inner_array;\n+\n+  base_type = copy_type (base_type);\n+  inner_array = base_type;\n+\n+  while (TYPE_CODE (TYPE_TARGET_TYPE (inner_array)) == TYPE_CODE_ARRAY)\n+    {\n+      TYPE_TARGET_TYPE (inner_array)\n+\t= copy_type (TYPE_TARGET_TYPE (inner_array));\n+      inner_array = TYPE_TARGET_TYPE (inner_array);\n+    }\n+\n+  el_type = TYPE_TARGET_TYPE (inner_array);\n+  cnst |= TYPE_CONST (el_type);\n+  voltl |= TYPE_VOLATILE (el_type);\n+  TYPE_TARGET_TYPE (inner_array) = make_cv_type (cnst, voltl, el_type, NULL);\n+\n+  return set_tid_type (ccp->of, tid, base_type);\n+}\n+\n+/* Read all information from a TID of CTF_K_ARRAY.  */\n+\n+static struct type *\n+read_array_type (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  struct objfile *objfile = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct type *element_type, *range_type, *idx_type;\n+  struct type *type;\n+  ctf_arinfo_t ar;\n+\n+  if (ctf_array_info (fp, tid, &ar) == CTF_ERR)\n+    {\n+      complaint (_(\"ctf_array_info read_array_type failed - %s\"),\n+\t\t ctf_errmsg (ctf_errno (fp)));\n+      return NULL;\n+    }\n+\n+  element_type = get_tid_type (objfile, ar.ctr_contents);\n+  if (element_type == NULL)\n+    return NULL;\n+\n+  idx_type = get_tid_type (objfile, ar.ctr_index);\n+  if (idx_type == NULL)\n+    idx_type = objfile_type (objfile)->builtin_int;\n+\n+  range_type = create_static_range_type (NULL, idx_type, 0, ar.ctr_nelems - 1);\n+  type = create_array_type (NULL, element_type, range_type);\n+  if (ar.ctr_nelems <= 1)\t/* Check if undefined upper bound.  */\n+    {\n+      TYPE_HIGH_BOUND_KIND (range_type) = PROP_UNDEFINED;\n+      TYPE_LENGTH (type) = 0;\n+      TYPE_TARGET_STUB (type) = 1;\n+    }\n+  else\n+    TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n+\n+  set_type_align (type, ctf_type_align (fp, tid));\n+\n+  return set_tid_type (objfile, tid, type);\n+}\n+\n+/* Read TID of kind CTF_K_CONST with base type BTID.  */\n+\n+static struct type *\n+read_const_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+{\n+  struct objfile *objfile = ccp->of;\n+  struct type *base_type, *cv_type;\n+\n+  base_type = get_tid_type (objfile, btid);\n+  if (base_type == NULL)\n+    {\n+      base_type = read_type_record (ccp, btid);\n+      if (base_type == NULL)\n+\t{\n+\t  complaint (_(\"read_const_type: NULL base type (%ld)\"), btid);\n+\t  base_type = objfile_type (objfile)->builtin_error;\n+\t}\n+    }\n+  cv_type = make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0);\n+\n+  return set_tid_type (objfile, tid, cv_type);\n+}\n+\n+/* Read TID of kind CTF_K_VOLATILE with base type BTID.  */\n+\n+static struct type *\n+read_volatile_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+{\n+  struct objfile *objfile = ccp->of;\n+  ctf_file_t *fp = ccp->fp;\n+  struct type *base_type, *cv_type;\n+\n+  base_type = get_tid_type (objfile, btid);\n+  if (base_type == NULL)\n+    {\n+      base_type = read_type_record (ccp, btid);\n+      if (base_type == NULL)\n+\t{\n+\t  complaint (_(\"read_volatile_type: NULL base type (%ld)\"), btid);\n+\t  base_type = objfile_type (objfile)->builtin_error;\n+\t}\n+    }\n+\n+  if (ctf_type_kind (fp, btid) == CTF_K_ARRAY)\n+    return add_array_cv_type (ccp, tid, base_type, 0, 1);\n+  cv_type = make_cv_type (TYPE_CONST (base_type), 1, base_type, 0);\n+\n+  return set_tid_type (objfile, tid, cv_type);\n+}\n+\n+/* Read TID of kind CTF_K_RESTRICT with base type BTID.  */\n+\n+static struct type *\n+read_restrict_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+{\n+  struct objfile *objfile = ccp->of;\n+  struct type *base_type, *cv_type;\n+\n+  base_type = get_tid_type (objfile, btid);\n+  if (base_type == NULL)\n+    {\n+      base_type = read_type_record (ccp, btid);\n+      if (base_type == NULL)\n+\t{\n+\t  complaint (_(\"read_restrict_type: NULL base type (%ld)\"), btid);\n+\t  base_type = objfile_type (objfile)->builtin_error;\n+\t}\n+    }\n+  cv_type = make_restrict_type (base_type);\n+\n+  return set_tid_type (objfile, tid, cv_type);\n+}\n+\n+/* Read TID of kind CTF_K_TYPEDEF with its NAME and base type BTID.  */\n+\n+static struct type *\n+read_typedef_type (ctf_context_t *ccp, ctf_id_t tid,\n+\t\t   ctf_id_t btid, const char *name)\n+{\n+  struct objfile *objfile = ccp->of;\n+  struct type *this_type, *target_type;\n+\n+  char *aname = obstack_strdup (&objfile->objfile_obstack, name);\n+  this_type = init_type (objfile, TYPE_CODE_TYPEDEF, 0, aname);\n+  set_tid_type (objfile, tid, this_type);\n+  target_type = get_tid_type (objfile, btid);\n+  if (target_type != this_type)\n+    TYPE_TARGET_TYPE (this_type) = target_type;\n+  else\n+    TYPE_TARGET_TYPE (this_type) = NULL;\n+  TYPE_TARGET_STUB (this_type) = TYPE_TARGET_TYPE (this_type) ? 1 : 0;\n+\n+  return set_tid_type (objfile, tid, this_type);\n+}\n+\n+/* Read TID of kind CTF_K_POINTER with base type BTID.  */\n+\n+static struct type *\n+read_pointer_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+{\n+  struct objfile *of = ccp->of;\n+  struct type *target_type, *type;\n+\n+  target_type = get_tid_type (of, btid);\n+  if (target_type == NULL)\n+    {\n+      target_type = read_type_record (ccp, btid);\n+      if (target_type == NULL)\n+\t{\n+\t  complaint (_(\"read_pointer_type: NULL target type (%ld)\"), btid);\n+\t  target_type = objfile_type (ccp->of)->builtin_error;\n+\t}\n+    }\n+\n+  type = lookup_pointer_type (target_type);\n+  set_type_align (type, ctf_type_align (ccp->fp, tid));\n+\n+  return set_tid_type (of, tid, type);\n+}\n+\n+/* Read information associated with type TID.  */\n+\n+static struct type *\n+read_type_record (ctf_context_t *ccp, ctf_id_t tid)\n+{\n+  ctf_file_t *fp = ccp->fp;\n+  uint32_t kind;\n+  struct type *type = NULL;\n+  ctf_id_t btid;\n+\n+  kind = ctf_type_kind (fp, tid);\n+  switch (kind)\n+    {\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+\ttype = read_structure_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_ENUM:\n+\ttype = read_enum_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_FUNCTION:\n+\ttype = read_func_kind_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_CONST:\n+\tbtid = ctf_type_reference (fp, tid);\n+\ttype = read_const_type (ccp, tid, btid);\n+\tbreak;\n+      case CTF_K_TYPEDEF:\n+\t{\n+\t  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+\t  btid = ctf_type_reference (fp, tid);\n+\t  type = read_typedef_type (ccp, tid, btid, name.get ());\n+\t}\n+\tbreak;\n+      case CTF_K_VOLATILE:\n+\tbtid = ctf_type_reference (fp, tid);\n+\ttype = read_volatile_type (ccp, tid, btid);\n+\tbreak;\n+      case CTF_K_RESTRICT:\n+\tbtid = ctf_type_reference (fp, tid);\n+\ttype = read_restrict_type (ccp, tid, btid);\n+\tbreak;\n+      case CTF_K_POINTER:\n+\tbtid = ctf_type_reference (fp, tid);\n+\ttype = read_pointer_type (ccp, tid, btid);\n+\tbreak;\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+\ttype = read_base_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_ARRAY:\n+\ttype = read_array_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_UNKNOWN:\n+\tbreak;\n+      default:\n+\tbreak;\n+    }\n+\n+  return type;\n+}\n+\n+/* Callback to add type TID to the symbol table.  */\n+\n+static int\n+ctf_add_type_cb (ctf_id_t tid, void *arg)\n+{\n+  ctf_context_t *ccp = (ctf_context_t *) arg;\n+  struct type *type;\n+  uint32_t kind;\n+\n+  /* Check if tid's type has already been defined.  */\n+  type = get_tid_type (ccp->of, tid);\n+  if (type != NULL)\n+    return 0;\n+\n+  ctf_id_t btid = ctf_type_reference (ccp->fp, tid);\n+  kind = ctf_type_kind (ccp->fp, tid);\n+  switch (kind)\n+    {\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+\tprocess_structure_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_ENUM:\n+\tprocess_enum_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_FUNCTION:\n+\ttype = read_func_kind_type (ccp, tid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+\tprocess_base_type (ccp, tid);\n+\tbreak;\n+      case CTF_K_TYPEDEF:\n+\tnew_symbol (ccp, read_type_record (ccp, tid), tid);\n+\tbreak;\n+      case CTF_K_CONST:\n+\ttype = read_const_type (ccp, tid, btid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_VOLATILE:\n+\ttype = read_volatile_type (ccp, tid, btid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_RESTRICT:\n+\ttype = read_restrict_type (ccp, tid, btid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_POINTER:\n+\ttype = read_pointer_type (ccp, tid, btid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_ARRAY:\n+\ttype = read_array_type (ccp, tid);\n+\tnew_symbol (ccp, type, tid);\n+\tbreak;\n+      case CTF_K_UNKNOWN:\n+\tbreak;\n+      default:\n+\tbreak;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Callback to add variable NAME with TID to the symbol table.  */\n+\n+static int\n+ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n+{\n+  ctf_context_t *ccp = (ctf_context_t *) arg;\n+  struct symbol *sym = NULL;\n+  struct type *type;\n+  uint32_t kind;\n+\n+  type = get_tid_type (ccp->of, id);\n+\n+  kind = ctf_type_kind (ccp->fp, id);\n+  switch (kind)\n+    {\n+      case CTF_K_FUNCTION:\n+\tif (name && !strcmp(name, \"main\"))\n+\t  set_objfile_main_name (ccp->of, name, language_c);\n+\tbreak;\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+      case CTF_K_VOLATILE:\n+      case CTF_K_RESTRICT:\n+      case CTF_K_TYPEDEF:\n+      case CTF_K_CONST:\n+      case CTF_K_POINTER:\n+      case CTF_K_ARRAY:\n+\tif (type)\n+\t  {\n+\t    sym = new_symbol (ccp, type, id);\n+\t    SYMBOL_SET_NAMES (sym, name, strlen (name), 0, ccp->of);\n+\t  }\n+\tbreak;\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+      case CTF_K_ENUM:\n+\tif (type == NULL)\n+\t{\n+\t  complaint (_(\"ctf_add_var_cb: %s has NO type (%ld)\"), name, id);\n+\t  type = objfile_type (ccp->of)->builtin_error;\n+\t}\n+\tsym = allocate_symbol (ccp->of);\n+\tOBJSTAT (ccp->of, n_syms++);\n+\tSYMBOL_TYPE (sym) = type;\n+\tSYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n+\tSYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n+\tSYMBOL_SET_NAMES (sym, name, strlen (name), 0, ccp->of);\n+\tadd_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n+\tbreak;\n+      default:\n+\tcomplaint (_(\"ctf_add_var_cb: kind unsupported (%d)\"), kind);\n+\tbreak;\n+    }\n+\n+  if (sym)\n+    set_symbol_address (ccp->of, sym, name);\n+\n+  return 0;\n+}\n+\n+/* Add an ELF STT_OBJ symbol with index IDX to the symbol table.  */\n+\n+static struct symbol *\n+add_stt_obj (ctf_context_t *ccp, unsigned long idx)\n+{\n+  struct symbol *sym;\n+  struct type *type;\n+  ctf_id_t tid;\n+\n+  if ((tid = ctf_lookup_by_symbol (ccp->fp, idx)) == CTF_ERR)\n+    return NULL;\n+\n+  type = get_tid_type (ccp->of, tid);\n+  if (type == NULL)\n+    return NULL;\n+\n+  sym = new_symbol (ccp, type, tid);\n+\n+  return sym;\n+}\n+\n+/* Add an ELF STT_FUNC symbol with index IDX to the symbol table.  */\n+\n+static struct symbol *\n+add_stt_func (ctf_context_t *ccp, unsigned long idx)\n+{\n+  struct type *ftype, *atyp, *rettyp;\n+  struct symbol *sym;\n+  ctf_funcinfo_t finfo;\n+  ctf_id_t argv[32];\n+  uint32_t argc;\n+  ctf_id_t tid;\n+  struct type *void_type = objfile_type (ccp->of)->builtin_void;\n+\n+  if (ctf_func_info (ccp->fp, idx, &finfo) == CTF_ERR)\n+    return NULL;\n+\n+  argc = finfo.ctc_argc;\n+  if (ctf_func_args (ccp->fp, idx, argc, argv) == CTF_ERR)\n+    return NULL;\n+\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, idx));\n+  if (name == NULL)\n+    return NULL;\n+\n+  tid = ctf_lookup_by_symbol (ccp->fp, idx);\n+  ftype = get_tid_type (ccp->of, tid);\n+  if (finfo.ctc_flags & CTF_FUNC_VARARG)\n+    TYPE_VARARGS (ftype) = 1;\n+  TYPE_NFIELDS (ftype) = argc;\n+\n+  /* If argc is 0, it has a \"void\" type.  */\n+  if (argc != 0)\n+    TYPE_FIELDS (ftype)\n+      = (struct field *) TYPE_ZALLOC (ftype, argc * sizeof (struct field));\n+\n+  /* TYPE_FIELD_TYPE must never be NULL.  Fill it with void_type, if failed\n+     to find the argument type.  */\n+  for (int iparam = 0; iparam < argc; iparam++)\n+    {\n+      atyp = get_tid_type (ccp->of, argv[iparam]);\n+      if (atyp)\n+\tTYPE_FIELD_TYPE (ftype, iparam) = atyp;\n+      else\n+\tTYPE_FIELD_TYPE (ftype, iparam) = void_type;\n+    }\n+\n+  sym = new_symbol (ccp, ftype, tid);\n+  rettyp = get_tid_type (ccp->of, finfo.ctc_return);\n+  if (rettyp != NULL)\n+    SYMBOL_TYPE (sym) = rettyp;\n+  else\n+    SYMBOL_TYPE (sym) = void_type;\n+\n+  return sym;\n+}\n+\n+/* Get text segment base for OBJFILE, TSIZE contains the segment size.  */\n+\n+static CORE_ADDR\n+get_objfile_text_range (struct objfile *of, int *tsize)\n+{\n+  CORE_ADDR text_base;\n+  bfd *abfd = of->obfd;\n+  const asection *codes;\n+\n+  codes = bfd_get_section_by_name (abfd, \".text\");\n+  if (codes == NULL)\n+    {\n+      text_base = 0;\n+      *tsize = 0;\n+    }\n+  else\n+    {\n+      text_base = bfd_section_vma (codes);\n+      *tsize = codes->size;\n+    }\n+\n+  return text_base;\n+}\n+\n+/* Start a symtab for OBJFILE in CTF format.  */\n+\n+static void\n+ctf_start_symtab (struct partial_symtab *pst,\n+\t\t  struct objfile *of, CORE_ADDR text_offset)\n+{\n+  ctf_context_t *ccp;\n+\n+  ccp = (ctf_context_t *) pst->read_symtab_private;\n+  ccp->builder = new buildsym_compunit\n+\t\t       (of, of->original_name, NULL,\n+\t\t       language_c, text_offset);\n+  ccp->builder->record_debugformat (\"ctf\");\n+}\n+\n+/* Finish reading symbol/type definitions in CTF format.\n+   END_ADDR is the end address of the file's text.  SECTION is\n+   the .text section number.  */\n+\n+static struct compunit_symtab *\n+ctf_end_symtab (struct partial_symtab *pst,\n+\t\tCORE_ADDR end_addr, int section)\n+{\n+  ctf_context_t *ccp;\n+\n+  ccp = (ctf_context_t *) pst->read_symtab_private;\n+  struct compunit_symtab *result\n+    = ccp->builder->end_symtab (end_addr, section);\n+  delete ccp->builder;\n+  ccp->builder = NULL;\n+  return result;\n+}\n+\n+/* Read in full symbols for PST, and anything it depends on.  */\n+\n+static void\n+psymtab_to_symtab (struct partial_symtab *pst)\n+{\n+  struct symbol *sym;\n+  ctf_context_t *ccp;\n+\n+  gdb_assert (!pst->readin);\n+\n+  ccp = (ctf_context_t *) pst->read_symtab_private;\n+\n+  /* Iterate over entries in data types section.  */\n+  if (ctf_type_iter (ccp->fp, ctf_add_type_cb, ccp) == CTF_ERR)\n+    complaint (_(\"ctf_type_iter psymtab_to_symtab failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (ccp->fp)));\n+\n+\n+  /* Iterate over entries in variable info section.  */\n+  if (ctf_variable_iter (ccp->fp, ctf_add_var_cb, ccp) == CTF_ERR)\n+    complaint (_(\"ctf_variable_iter psymtab_to_symtab failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (ccp->fp)));\n+\n+  /* Add entries in data objects and function info sections.  */\n+  for (unsigned long i = 0; ; i++)\n+    {\n+      sym = add_stt_obj (ccp, i);\n+      if (sym == NULL)\n+\t{\n+\t  if (ctf_errno (ccp->fp) == EINVAL\n+\t      || ctf_errno (ccp->fp) == ECTF_NOSYMTAB)\n+\t    break;\n+\t  sym = add_stt_func (ccp, i);\n+\t}\n+      if (sym == NULL)\n+\tcontinue;\n+\n+      set_symbol_address (ccp->of, sym, SYMBOL_LINKAGE_NAME (sym));\n+    }\n+\n+  pst->readin = 1;\n+}\n+\n+/* Expand partial symbol table PST into a full symbol table.\n+   PST is not NULL.  */\n+\n+static void\n+ctf_read_symtab (struct partial_symtab *pst, struct objfile *objfile)\n+{\n+  if (pst->readin)\n+    warning (_(\"bug: psymtab for %s is already read in.\"), pst->filename);\n+  else\n+    {\n+      if (info_verbose)\n+\t{\n+\t  printf_filtered (_(\"Reading in CTF data for %s...\"), pst->filename);\n+\t  gdb_flush (gdb_stdout);\n+\t}\n+\n+      /* Start a symtab.  */\n+      CORE_ADDR text_offset;        /* Start of text segment.  */\n+      int tsize;\n+\n+      text_offset = get_objfile_text_range (objfile, &tsize);\n+      ctf_start_symtab (pst, objfile, text_offset);\n+      psymtab_to_symtab (pst);\n+\n+      pst->set_text_low (text_offset);\n+      pst->set_text_high (text_offset + tsize);\n+      pst->compunit_symtab = ctf_end_symtab (pst, text_offset + tsize,\n+\t\t\t\t\t     SECT_OFF_TEXT (objfile));\n+\n+      /* Finish up the debug error message.  */\n+      if (info_verbose)\n+\tprintf_filtered (_(\"done.\\n\"));\n+    }\n+}\n+\n+/* Cleanup function for the ctf_file_key data.  */\n+\n+static void\n+ctf_close_objfile (struct objfile *of, void *datum)\n+{\n+  ctf_file_t *fp = static_cast<ctf_file_t *> (datum);\n+  ctf_archive_t *arc = ctf_get_arc (fp);\n+  ctf_file_close (fp);\n+  ctf_close (arc);\n+}\n+\n+/* Allocate a new partial_symtab NAME.\n+\n+   Each source file that has not been fully read in is represented by\n+   a partial_symtab.  This contains the information on where in the\n+   executable the debugging symbols for a specific file are, and a\n+   list of names of global symbols which are located in this file.\n+   They are all chained on partial symtab lists.\n+\n+   Even after the source file has been read into a symtab, the\n+   partial_symtab remains around.  They are allocated on an obstack,\n+   objfile_obstack.  */\n+\n+static struct partial_symtab *\n+create_partial_symtab (const char *name,\n+\t\t       ctf_file_t *cfp,\n+\t\t       struct objfile *objfile)\n+{\n+  struct partial_symtab *pst;\n+  ctf_context_t *ccx;\n+\n+  pst = start_psymtab_common (objfile, name, 0);\n+\n+  ccx = XOBNEW (&objfile->objfile_obstack, ctf_context_t);\n+  ccx->fp = cfp;\n+  ccx->of = objfile;\n+  pst->read_symtab_private = (void *) ccx;\n+  pst->read_symtab = ctf_read_symtab;\n+\n+  return pst;\n+}\n+\n+/* Callback to add type TID to partial symbol table.  */\n+\n+static int\n+ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n+{\n+  ctf_context_t *ccp;\n+  uint32_t kind;\n+  short section = -1;\n+\n+  ccp = (ctf_context_t *) arg;\n+  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, tid));\n+  if (name == NULL || strlen (name.get ()) == 0)\n+    return 0;\n+\n+  domain_enum domain = UNDEF_DOMAIN;\n+  enum address_class aclass = LOC_UNDEF;\n+  kind = ctf_type_kind (ccp->fp, tid);\n+  switch (kind)\n+    {\n+      case CTF_K_STRUCT:\n+      case CTF_K_UNION:\n+      case CTF_K_ENUM:\n+\tdomain = STRUCT_DOMAIN;\n+\taclass = LOC_TYPEDEF;\n+\tbreak;\n+      case CTF_K_FUNCTION:\n+      case CTF_K_FORWARD:\n+\tdomain = VAR_DOMAIN;\n+\taclass = LOC_STATIC;\n+\tsection = SECT_OFF_TEXT (ccp->of);\n+\tbreak;\n+      case CTF_K_CONST:\n+\tdomain = VAR_DOMAIN;\n+\taclass = LOC_STATIC;\n+\tbreak;\n+      case CTF_K_TYPEDEF:\n+      case CTF_K_POINTER:\n+      case CTF_K_VOLATILE:\n+      case CTF_K_RESTRICT:\n+\tdomain = VAR_DOMAIN;\n+\taclass = LOC_TYPEDEF;\n+\tbreak;\n+      case CTF_K_INTEGER:\n+      case CTF_K_FLOAT:\n+\tdomain = VAR_DOMAIN;\n+\taclass = LOC_TYPEDEF;\n+\tbreak;\n+      case CTF_K_ARRAY:\n+      case CTF_K_UNKNOWN:\n+\treturn 0;\n+    }\n+\n+    add_psymbol_to_list (name.get (), strlen (name.get ()), true,\n+\t\t\t domain, aclass, section,\n+\t\t\t psymbol_placement::GLOBAL,\n+\t\t\t 0, language_c, ccp->of);\n+\n+  return 0;\n+}\n+\n+/* Callback to add variable NAME with ID to partial symbol table.  */\n+\n+static int\n+ctf_psymtab_var_cb (const char *name, ctf_id_t id, void *arg)\n+{\n+  ctf_context_t *ccp = (ctf_context_t *) arg;\n+\n+  add_psymbol_to_list (name, strlen (name), true,\n+\t\t       VAR_DOMAIN, LOC_STATIC, -1,\n+\t\t       psymbol_placement::GLOBAL,\n+\t\t       0, language_c, ccp->of);\n+  return 0;\n+}\n+\n+/* Setup partial_symtab's describing each source file for which\n+   debugging information is available.  */\n+\n+static void\n+scan_partial_symbols (ctf_file_t *cfp, struct objfile *of)\n+{\n+  ctf_context_t ccx;\n+  bfd *abfd = of->obfd;\n+  const char *name = bfd_get_filename (abfd);\n+  struct partial_symtab *pst = create_partial_symtab (name, cfp, of);\n+\n+  ccx.fp = cfp;\n+  ccx.of = of;\n+\n+  if (ctf_type_iter (cfp, ctf_psymtab_type_cb, &ccx) == CTF_ERR)\n+    complaint (_(\"ctf_type_iter scan_partial_symbols failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (cfp)));\n+\n+  if (ctf_variable_iter (cfp, ctf_psymtab_var_cb, &ccx) == CTF_ERR)\n+    complaint (_(\"ctf_variable_iter scan_partial_symbols failed - %s\"),\n+\t       ctf_errmsg (ctf_errno (cfp)));\n+\n+  /* Scan CTF object and function sections which correspond to each\n+     STT_FUNC or STT_OBJECT entry in the symbol table,\n+     pick up what init_symtab has done.  */\n+  for (unsigned long idx = 0; ; idx++)\n+    {\n+      ctf_id_t tid;\n+      if ((tid = ctf_lookup_by_symbol (cfp, idx)) == CTF_ERR)\n+\t{\n+\tif (ctf_errno (cfp) == EINVAL || ctf_errno (cfp) == ECTF_NOSYMTAB)\n+\t  break;\t// Done, reach end of the section.\n+\telse\n+\t  continue;\n+\t}\n+      gdb::unique_xmalloc_ptr<char> tname (ctf_type_aname_raw (cfp, tid));\n+      uint32_t kind = ctf_type_kind (cfp, tid);\n+      address_class aclass;\n+      domain_enum tdomain;\n+      switch (kind)\n+\t{\n+\t  case CTF_K_STRUCT:\n+\t  case CTF_K_UNION:\n+\t  case CTF_K_ENUM:\n+\t    tdomain = STRUCT_DOMAIN;\n+\t    break;\n+\t  default:\n+\t    tdomain = VAR_DOMAIN;\n+\t    break;\n+\t}\n+\n+      if (kind == CTF_K_FUNCTION)\n+\taclass = LOC_STATIC;\n+      else if (kind == CTF_K_CONST)\n+\taclass = LOC_CONST;\n+      else\n+\taclass = LOC_TYPEDEF;\n+\n+      add_psymbol_to_list (tname.get (), strlen (tname.get ()), true,\n+\t\t\t   tdomain, aclass, -1,\n+\t\t\t   psymbol_placement::STATIC,\n+\t\t\t   0, language_c, of);\n+    }\n+\n+  end_psymtab_common (of, pst);\n+}\n+\n+/* Read CTF debugging information from a BFD section.  This is\n+   called from elfread.c.  It does a quick pass through the\n+   .ctf section to set up the partial symbol table.  */\n+\n+void\n+elfctf_build_psymtabs (struct objfile *of)\n+{\n+  bfd *abfd = of->obfd;\n+  int err;\n+\n+  ctf_archive_t *arc = ctf_bfdopen (abfd, &err);\n+  if (arc == NULL)\n+    error (_(\"ctf_bfdopen failed on %s - %s\"),\n+\t   bfd_get_filename (abfd), ctf_errmsg (err));\n+\n+  ctf_file_t *fp = ctf_arc_open_by_name (arc, NULL, &err);\n+  if (fp == NULL)\n+    error (_(\"ctf_arc_open_by_name failed on %s - %s\"),\n+\t   bfd_get_filename (abfd), ctf_errmsg (err));\n+  set_objfile_data (of, ctf_file_key, fp);\n+\n+  scan_partial_symbols (fp, of);\n+}\n+\n+void\n+_initialize_ctfread (void)\n+{\n+  ctf_file_key\n+    = register_objfile_data_with_cleanup (NULL, ctf_close_objfile);\n+}"
    },
    {
      "sha": "632ee12b68139a5670c93ec41a945ae7dcb7313b",
      "filename": "gdb/ctfread.h",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/ctfread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/ctfread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.h?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,25 @@\n+/* CTF debugging format support for GDB.\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CTFREAD_H\n+#define CTFREAD_H\n+\n+extern void elfctf_build_psymtabs (struct objfile *objfile);\n+\n+#endif /* CTFREAD_H */"
    },
    {
      "sha": "53bdd3565943da00baf921521efb6571f2b26b06",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 17,
      "deletions": 1,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -47,6 +47,7 @@\n #include \"location.h\"\n #include \"auxv.h\"\n #include \"mdebugread.h\"\n+#include \"ctfread.h\"\n \n /* Forward declarations.  */\n extern const struct sym_fns elf_sym_fns_gdb_index;\n@@ -61,6 +62,7 @@ struct elfinfo\n   {\n     asection *stabsect;\t\t/* Section pointer for .stab section */\n     asection *mdebugsect;\t/* Section pointer for .mdebug section */\n+    asection *ctfsect;\t\t/* Section pointer for .ctf section */\n   };\n \n /* Type for per-BFD data.  */\n@@ -188,6 +190,10 @@ elf_locate_sections (bfd *ignore_abfd, asection *sectp, void *eip)\n     {\n       ei->mdebugsect = sectp;\n     }\n+  else if (strcmp (sectp->name, \".ctf\") == 0)\n+    {\n+      ei->ctfsect = sectp;\n+    }\n }\n \n static struct minimal_symbol *\n@@ -1059,7 +1065,8 @@ elf_read_minimal_symbols (struct objfile *objfile, int symfile_flags,\n      go away once all types of symbols are in the per-BFD object.  */\n   if (objfile->per_bfd->minsyms_read\n       && ei->stabsect == NULL\n-      && ei->mdebugsect == NULL)\n+      && ei->mdebugsect == NULL\n+      && ei->ctfsect == NULL)\n     {\n       if (symtab_create_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -1200,6 +1207,7 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n {\n   bfd *abfd = objfile->obfd;\n   struct elfinfo ei;\n+  bool has_dwarf2 = true;\n \n   memset ((char *) &ei, 0, sizeof (ei));\n   if (!(objfile->flags & OBJF_READNEVER))\n@@ -1302,6 +1310,14 @@ elf_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \t  symbol_file_add_separate (debug_bfd.get (), debugfile.c_str (),\n \t\t\t\t    symfile_flags, objfile);\n \t}\n+\telse\n+\t  has_dwarf2 = false;\n+    }\n+\n+  /* Read the CTF section only if there is no DWARF info.  */\n+  if (!has_dwarf2 && ei.ctfsect)\n+    {\n+      elfctf_build_psymtabs (objfile);\n     }\n }\n "
    },
    {
      "sha": "0d42016edf8af5810fa1789ecbea6bf0358750fc",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -1,3 +1,13 @@\n+2019-10-07  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* gdb.base/ctf-whatis.exp: New file.\n+\t* gdb.base/ctf-whatis.c: New file.\n+\t* gdb.base/ctf-ptype.exp: New file.\n+\t* gdb.base/ctf-ptype.c: New file.\n+\t* gdb.base/ctf-constvars.exp: New file.\n+\t* gdb.base/ctf-constvars.c: New file.\n+\t* gdb.base/ctf-cvexpr.exp: New file.\n+\n 2019-10-04  Tom de Vries  <tdevries@suse.de>\n \n \t* gdb.cp/local-static.c (main): Move declaration of int i out of the"
    },
    {
      "sha": "75f4250d4749f873a4881a744bf557f4c9ff34be",
      "filename": "gdb/testsuite/gdb.base/ctf-constvars.c",
      "status": "added",
      "additions": 116,
      "deletions": 0,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-constvars.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-constvars.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-constvars.c?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,116 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+const char            laconic = 'A';\n+const char           *const lewd=&laconic;\n+\n+/* volatile variables */\n+\n+volatile char vox = 'B';\n+volatile unsigned char victuals = 'C';\n+volatile short vixen = 200;\n+volatile unsigned short vitriol = 300;\n+volatile long vellum = 1000;\n+volatile unsigned long valve = 2000;\n+volatile float vacuity = 3.0;\n+volatile double vertigo = 10;\n+\n+/* pointers to volatile variables */\n+\n+volatile char           * vampire = &vox;\n+volatile unsigned char  * viper  = &victuals;\n+volatile short          * vigour = &vixen;\n+volatile unsigned short * vapour = &vitriol;\n+volatile long           * ventricle = &vellum;\n+volatile unsigned long  * vigintillion = &valve;\n+volatile float          * vocation = &vacuity;\n+volatile double         * veracity = &vertigo;\n+\n+/* volatile pointers to volatile variables */\n+\n+volatile char           * volatile vapidity = &vox;\n+volatile unsigned char  * volatile velocity = &victuals;\n+volatile short          * volatile veneer = &vixen;\n+volatile unsigned short * volatile video = &vitriol;\n+volatile long           * volatile vacuum = &vellum;\n+volatile unsigned long  * volatile veniality = &valve;\n+volatile float          * volatile vitality = &vacuity;\n+volatile double         * volatile voracity = &vertigo;\n+\n+/* volatile arrays */\n+\n+volatile char violent[2];\n+volatile unsigned char violet[2];\n+volatile short vips[2];\n+volatile unsigned short virgen[2];\n+volatile long vulgar[2];\n+volatile unsigned long vulture[2];\n+volatile float vilify[2];\n+volatile double villar[2];\n+\n+/* const volatile vars */\n+\n+const volatile char           victor = 'Y';\n+\n+/* pointers to const volatiles */\n+\n+const volatile char              * victory = &victor;\n+\n+/* const pointers to const volatile vars */\n+\n+const volatile char              * const cavern = &victor;\n+\n+/* volatile pointers to const vars */\n+\n+const char                       * volatile caveat = &laconic;\n+const unsigned char              * volatile covenant;\n+\n+/* volatile pointers to const volatile vars */\n+\n+const volatile char              * volatile vizier = &victor;\n+const volatile unsigned char     * volatile vanadium;\n+\n+/* const volatile pointers */\n+\n+char                             * const volatile vane;\n+unsigned char                    * const volatile veldt;\n+\n+/* const volatile pointers to const vars */\n+\n+const char                       * const volatile cove;\n+const unsigned char              * const volatile cavity;\n+ \n+/* const volatile pointers to volatile vars */\n+\n+volatile char                    * const volatile vagus;\n+volatile unsigned char           * const volatile vagrancy;\n+ \n+/* const volatile pointers to const volatile */\n+\n+const volatile char              * const volatile vagary;\n+const volatile unsigned char     * const volatile vendor;\n+\n+/* const volatile arrays */\n+\n+const volatile char vindictive[2];\n+const volatile unsigned char vegetation[2];\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"
    },
    {
      "sha": "4a81a94ddb403706f182d3350141c1e7943d173f",
      "filename": "gdb/testsuite/gdb.base/ctf-constvars.exp",
      "status": "added",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-constvars.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-constvars.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-constvars.exp?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,114 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+# This file is a subset of constvars.exp, written by\n+# Elena Zannoni (elz@apollo.hp.com)\n+#\n+# This file is part of the gdb testsuite\n+#\n+# tests for const variables\n+#           const pointers to vars\n+#           pointers to const variables\n+#           const pointers to const vars\n+# with mixed types\n+\n+#\n+# test running programs\n+#\n+# -gt generates full-fledged CTF.\n+\n+standard_testfile .c\n+set opts \"additional_flags=-gt\"\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+\t  [list $srcfile] [list $opts nowarnings]] } {\n+    return 0\n+}\n+\n+#\n+# set it up at a breakpoint so we can play with the variable values\n+#\n+if ![runto_main] then {\n+    perror \"couldn't run to breakpoint\"\n+    continue\n+}\n+\n+# test vars and pointers\n+\n+proc do_constvar_tests {} {\n+    gdb_test \"print vox\" \" = 66 'B'\"\n+    gdb_test \"ptype vox\" \"type = volatile char\"\n+    gdb_test \"print victuals\" \" = 67 'C'\"\n+    gdb_test \"ptype victuals\" \"type = volatile unsigned char\"\n+    gdb_test \"print vixen\" \" = 200\"\n+    gdb_test \"ptype vixen\" \"type = volatile short.*\"\n+    gdb_test \"print vitriol\" \" = 300\"\n+    gdb_test \"ptype vitriol\" \"type = volatile (unsigned short|short unsigned)( int)?\"\n+    gdb_test \"print vellum\" \" = 1000\"\n+    gdb_test \"ptype vellum\" \"type = volatile long.*\"\n+    gdb_test \"print valve\" \" = 2000\"\n+    gdb_test \"ptype valve\" \"type = volatile (unsigned long|long unsigned)( int)?\"\n+    gdb_test \"print vacuity\" \" = 3\"\n+    gdb_test \"ptype vacuity\" \"type = volatile float\"\n+    gdb_test \"print vertigo\" \" = 10\"\n+    gdb_test \"ptype vertigo\" \"type = volatile double\"\n+    gdb_test \"print laconic\" \" = 65 'A'\"\n+\n+    gdb_test \"ptype vampire\" \"type = volatile char.*\"\n+    gdb_test \"ptype viper\" \"type = volatile unsigned char.*\"\n+    gdb_test \"ptype vigour\" \"type = volatile short.*\"\n+    gdb_test \"ptype vapour\" \"type = volatile (unsigned short|short unsigned)( int)?.*\"\n+    gdb_test \"ptype ventricle\" \"type = volatile long.*\"\n+    gdb_test \"ptype vigintillion\" \"type = volatile (unsigned long|long unsigned)( int)?.*\"\n+    gdb_test \"ptype vocation\" \"type = volatile float.*\"\n+    gdb_test \"ptype veracity\" \"type = volatile double.*\"\n+\n+    gdb_test \"ptype vapidity\" \"type = volatile char.* volatile\"\n+    gdb_test \"ptype velocity\" \"type = volatile unsigned char.* volatile\"\n+    gdb_test \"ptype veneer\" \"type = volatile short.* volatile\"\n+    gdb_test \"ptype video\" \"type = volatile (unsigned short|short unsigned)( int)?.* volatile\"\n+    gdb_test \"ptype vacuum\" \"type = volatile long.* volatile\"\n+    gdb_test \"ptype veniality\" \"type = volatile (unsigned long|long unsigned)( int)?.* volatile\"\n+    gdb_test \"ptype vitality\" \"type = volatile float.* volatile\"\n+    gdb_test \"ptype voracity\" \"type = volatile double.* volatile\"\n+\n+    gdb_test \"ptype violent\" \"type = volatile char \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype violet\" \"type = volatile unsigned char \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype vips\" \"type = volatile short.* \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype virgen\" \"type = volatile unsigned short.* \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype vulgar\" \"type = volatile long.* \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype vulture\" \"type = volatile (unsigned long|long unsigned)( int)? \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype vilify\" \"type = volatile float \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype villar\" \"type = volatile double \\\\\\[2\\\\\\]\"\n+\n+    gdb_test \"print victor\" \" = 89 'Y'\"\n+    gdb_test \"ptype victor\" \"type = const volatile char\"\n+    gdb_test \"ptype victory\" \"type = const volatile char.*\"\n+    gdb_test \"ptype cavern\" \"type = const volatile char.* const\"\n+    gdb_test \"ptype caveat\" \"type = const char.* volatile\"\n+    gdb_test \"ptype covenant\" \"type = const unsigned char.* volatile\"\n+    gdb_test \"ptype vanadium\" \"type = const volatile unsigned char.* volatile\"\n+\n+    gdb_test \"ptype cove\" \"type = const char.* const volatile\"\n+    gdb_test \"ptype cavity\" \"type = const unsigned char.* const volatile\"\n+    gdb_test \"ptype vagus\" \"type = volatile char.* const volatile\"\n+    gdb_test \"ptype vagrancy\" \"type = volatile unsigned char.* const volatile\"\n+    gdb_test \"ptype vagary\" \"type = const volatile char.* const volatile\"\n+    gdb_test \"ptype vendor\" \"type = const volatile unsigned char.* const volatile\"\n+    gdb_test \"ptype vindictive\" \"type = const volatile char \\\\\\[2\\\\\\]\"\n+    gdb_test \"ptype vegetation\" \"type = const volatile unsigned char \\\\\\[2\\\\\\]\"\n+}\n+\n+do_constvar_tests"
    },
    {
      "sha": "67ceb21f5206e13743960e7e7bb989b707ea95a6",
      "filename": "gdb/testsuite/gdb.base/ctf-cvexpr.exp",
      "status": "added",
      "additions": 495,
      "deletions": 0,
      "changes": 495,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-cvexpr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-cvexpr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-cvexpr.exp?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,495 @@\n+#   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is a subset of cvexpr.exp written by\n+# Michael Snyder, Red Hat, Inc., 9/20/2001\n+\n+# This file is part of the gdb testsuite\n+# Tests for type expressions using const and volatile keywords.\n+\n+#\n+# test running programs\n+#\n+# -gt generates full-fledged CTF.\n+\n+standard_testfile cvexpr.c\n+set opts \"additional_flags=-gt\"\n+\n+if  { [gdb_compile \"${srcdir}/${subdir}/${srcfile}\" \"${binfile}\" executable {debug}] != \"\" } {\n+     untested \"failed to compile\"\n+     return -1\n+}\n+\n+clean_restart ${binfile}\n+\n+gdb_test_no_output \"set print sevenbit-strings\"\n+gdb_test_no_output \"set print address off\"\n+gdb_test_no_output \"set width 0\"\n+\n+set ws  \"\\[ \\t\\]*\"\n+\n+#\n+# Test casting a scalar to const\n+#\n+\n+gdb_test \"whatis (const char) v_char\" \\\n+\t\"type = const char\" \\\n+\t\"(const char)\"\n+gdb_test \"whatis (const signed char) v_signed_char\" \\\n+\t\"type = const signed char\" \\\n+\t\"(const signed char)\"\n+gdb_test \"whatis (const unsigned char) v_unsigned_char\" \\\n+\t\"type = const (unsigned char|char)\" \\\n+\t\"(const unsigned char)\"\n+gdb_test \"whatis (const short) v_short\" \\\n+\t\"type = const (short|short int)\" \\\n+\t\"(const short)\"\n+gdb_test \"whatis (const signed short) v_signed_short\" \\\n+\t\"type = const (short|short int|signed short|signed short int)\" \\\n+\t\"(const signed short)\"\n+gdb_test \"whatis (const unsigned short) v_unsigned_short\" \\\n+\t\"type = const (unsigned short|short unsigned int)\" \\\n+\t\"(const unsigned short)\"\n+gdb_test \"whatis (const int) v_int\" \\\n+\t\"type = const int\" \\\n+\t\"(const int)\"\n+gdb_test \"whatis (const signed int) v_signed_int\" \\\n+\t\"type = const (signed int|int)\" \\\n+\t\"(const signed int)\"\n+gdb_test \"whatis (const unsigned int) v_unsigned_int\" \\\n+\t\"type = const unsigned int\" \\\n+\t\"(const unsigned int)\"\n+gdb_test \"whatis (const long) v_long\" \\\n+\t\"type = const (long|long int)\" \\\n+\t\"(const long)\"\n+gdb_test \"whatis (const signed long) v_signed_long\" \\\n+\t\"type = const (signed |)long( int|)\" \\\n+\t\"(const signed long)\"\n+gdb_test \"whatis (const unsigned long) v_unsigned_long\" \\\n+\t\"type = const (unsigned long|long unsigned int)\" \\\n+\t\"(const unsigned long)\"\n+gdb_test \"whatis (const long long) v_long_long\" \\\n+\t\"type = const long long( int|)\" \\\n+\t\"(const long long)\"\n+gdb_test \"whatis (const signed long long) v_signed_long_long\" \\\n+\t\"type = const (signed |)long long( int|)\" \\\n+\t\"(const signed long long)\"\n+gdb_test \"whatis (const unsigned long long) v_unsigned_long_long\" \\\n+\t\"type = const (unsigned long long|long long unsigned int)\" \\\n+\t\"(const unsigned long long)\"\n+gdb_test \"whatis (const float) v_float\" \\\n+\t\"type = const float\" \\\n+\t\"(const float)\"\n+gdb_test \"whatis (const double) v_double\" \\\n+\t\"type = const double\" \\\n+\t\"(const double)\"\n+\n+#\n+# Test casting a scalar to volatile\n+#\n+\n+gdb_test \"whatis (volatile char) v_char\" \\\n+\t\"type = volatile char\" \\\n+\t\"(volatile char)\"\n+gdb_test \"whatis (volatile signed char) v_signed_char\" \\\n+\t\"type = volatile signed char\" \\\n+\t\"(volatile signed char)\"\n+gdb_test \"whatis (volatile unsigned char) v_unsigned_char\" \\\n+\t\"type = volatile (unsigned char|char)\" \\\n+\t\"(volatile unsigned char)\"\n+gdb_test \"whatis (volatile short) v_short\" \\\n+\t\"type = volatile (short|short int)\" \\\n+\t\"(volatile short)\"\n+gdb_test \"whatis (volatile signed short) v_signed_short\" \\\n+\t\"type = volatile (short|short int|signed short|signed short int)\" \\\n+\t\"(volatile signed short)\"\n+gdb_test \"whatis (volatile unsigned short) v_unsigned_short\" \\\n+\t\"type = volatile (unsigned short|short unsigned int)\" \\\n+\t\"(volatile unsigned short)\"\n+gdb_test \"whatis (volatile int) v_int\" \\\n+\t\"type = volatile int\" \\\n+\t\"(volatile int)\"\n+gdb_test \"whatis (volatile signed int) v_signed_int\" \\\n+\t\"type = volatile (signed int|int)\" \\\n+\t\"(volatile signed int)\"\n+gdb_test \"whatis (volatile unsigned int) v_unsigned_int\" \\\n+\t\"type = volatile unsigned int\" \\\n+\t\"(volatile unsigned int)\"\n+gdb_test \"whatis (volatile long) v_long\" \\\n+\t\"type = volatile (long|long int)\" \\\n+\t\"(volatile long)\"\n+gdb_test \"whatis (volatile signed long) v_signed_long\" \\\n+\t\"type = volatile (signed |)long( int|)\" \\\n+\t\"(volatile signed long)\"\n+gdb_test \"whatis (volatile unsigned long) v_unsigned_long\" \\\n+\t\"type = volatile (unsigned long|long unsigned int)\" \\\n+\t\"(volatile unsigned long)\"\n+gdb_test \"whatis (volatile long long) v_long_long\" \\\n+\t\"type = volatile long long( int|)\" \\\n+\t\"(volatile long long)\"\n+gdb_test \"whatis (volatile signed long long) v_signed_long_long\" \\\n+\t\"type = volatile (signed |)long long( int|)\" \\\n+\t\"(volatile signed long long)\"\n+gdb_test \"whatis (volatile unsigned long long) v_unsigned_long_long\" \\\n+\t\"type = volatile (unsigned long long|long long unsigned int)\" \\\n+\t\"(volatile unsigned long long)\"\n+gdb_test \"whatis (volatile float) v_float\" \\\n+\t\"type = volatile float\" \\\n+\t\"(volatile float)\"\n+gdb_test \"whatis (volatile double) v_double\" \\\n+\t\"type = volatile double\" \\\n+\t\"(volatile double)\"\n+\n+#\n+# Combine const and volatile\n+#\n+\n+gdb_test \"whatis (const volatile int) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(const volatile int)\"\n+gdb_test \"whatis (volatile const int) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(volatile const int)\"\n+gdb_test \"whatis (const int volatile) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(const int volatile)\"\n+gdb_test \"whatis (volatile int const) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(volatile int const)\"\n+gdb_test \"whatis (int const volatile) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(int const volatile)\"\n+gdb_test \"whatis (int volatile const) v_int\" \\\n+\t\"type = const volatile int\" \\\n+\t\"(int volatile const)\"\n+\n+gdb_test \"whatis (const volatile int *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(const volatile int *)\"\n+gdb_test \"whatis (volatile const int *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(volatile const int *)\"\n+gdb_test \"whatis (const int volatile *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(const int volatile)\"\n+gdb_test \"whatis (volatile int const *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(volatile int const *)\"\n+gdb_test \"whatis (int const volatile *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(int const volatile *)\"\n+gdb_test \"whatis (int volatile const *) v_int_pointer\" \\\n+\t\"type = const volatile int${ws}\\\\*\" \\\n+\t\"(int volatile const *)\"\n+gdb_test \"whatis (int * const volatile) v_int_pointer\" \\\n+\t\"type = int${ws}\\\\*${ws}const volatile\" \\\n+\t\"(int * const volatile)\"\n+gdb_test \"whatis (int * volatile const) v_int_pointer\" \\\n+\t\"type = int${ws}\\\\*${ws}const volatile\" \\\n+\t\"(int * volatile const)\"\n+\n+\n+#\n+# Put 'signed' and 'unsigned' before const/volatile (FIXME)\n+#\n+\n+#gdb_test \"whatis (signed const char) v_signed_char\" \\\n+#\t\"type = const char\" \\\n+#\t\"(signed const char)\"\n+#gdb_test \"whatis (unsigned const char) v_unsigned_char\" \\\n+#\t\"type = const (unsigned char|char)\" \\\n+#\t\"(unsigned const char)\"\n+#gdb_test \"whatis (signed const short) v_signed_short\" \\\n+#\t\"type = const (short|short int|signed short|signed short int)\" \\\n+#\t\"(signed const short)\"\n+#gdb_test \"whatis (unsigned const short) v_unsigned_short\" \\\n+#\t\"type = const (unsigned short|short unsigned int)\" \\\n+#\t\"(unsigned const short)\"\n+#gdb_test \"whatis (signed const int) v_signed_int\" \\\n+#\t\"type = const (signed int|int)\" \\\n+#\t\"(signed const int)\"\n+#gdb_test \"whatis (unsigned const int) v_unsigned_int\" \\\n+#\t\"type = const unsigned int\" \\\n+#\t\"(unsigned const int)\"\n+#gdb_test \"whatis (signed const long) v_signed_long\" \\\n+#\t\"type = const (signed |)long( int|)\" \\\n+#\t\"(signed const long)\"\n+#gdb_test \"whatis (unsigned const long) v_unsigned_long\" \\\n+#\t\"type = const (unsigned long|long unsigned int)\" \\\n+#\t\"(unsigned const long)\"\n+#gdb_test \"whatis (signed const long long) v_signed_long_long\" \\\n+#\t\"type = const (signed |)long long( int|)\" \\\n+#\t\"(signed const long long)\"\n+#gdb_test \"whatis (unsigned const long long) v_unsigned_long_long\" \\\n+#\t\"type = const (unsigned long long|long long unsigned int)\" \\\n+#\t\"(const unsigned long long)\"\n+\n+#gdb_test \"whatis (signed volatile char) v_signed_char\" \\\n+#\t\"type = volatile char\" \\\n+#\t\"(signed volatile char)\"\n+#gdb_test \"whatis (unsigned volatile char) v_unsigned_char\" \\\n+#\t\"type = volatile (unsigned char|char)\" \\\n+#\t\"(unsigned volatile char)\"\n+#gdb_test \"whatis (signed volatile short) v_signed_short\" \\\n+#\t\"type = volatile (short|short int|signed short|signed short int)\" \\\n+#\t\"(signed volatile short)\"\n+#gdb_test \"whatis (unsigned volatile short) v_unsigned_short\" \\\n+#\t\"type = volatile (unsigned short|short unsigned int)\" \\\n+#\t\"(unsigned volatile short)\"\n+#gdb_test \"whatis (signed volatile int) v_signed_int\" \\\n+#\t\"type = volatile (signed int|int)\" \\\n+#\t\"(signed volatile int)\"\n+#gdb_test \"whatis (unsigned volatile int) v_unsigned_int\" \\\n+#\t\"type = volatile unsigned int\" \\\n+#\t\"(unsigned volatile int)\"\n+#gdb_test \"whatis (signed volatile long) v_signed_long\" \\\n+#\t\"type = volatile (signed |)long( int|)\" \\\n+#\t\"(signed volatile long)\"\n+#gdb_test \"whatis (unsigned volatile long) v_unsigned_long\" \\\n+#\t\"type = volatile (unsigned long|long unsigned int)\" \\\n+#\t\"(unsigned volatile long)\"\n+#gdb_test \"whatis (signed volatile long long) v_signed_long_long\" \\\n+#\t\"type = volatile (signed |)long long( int|)\" \\\n+#\t\"(signed volatile long long)\"\n+#gdb_test \"whatis (unsigned volatile long long) v_unsigned_long_long\" \\\n+#\t\"type = volatile (unsigned long long|long long unsigned int)\" \\\n+#\t\"(unsigned volatile long long)\"\n+\n+#\n+# Now put the 'const' and 'volatile' keywords after the base type.\n+#\n+\n+gdb_test \"whatis (char const) v_char\" \\\n+\t\"type = const char\" \\\n+\t\"(char const)\"\n+gdb_test \"whatis (signed char const) v_signed_char\" \\\n+\t\"type = const signed char\" \\\n+\t\"(signed char const)\"\n+gdb_test \"whatis (unsigned char const) v_unsigned_char\" \\\n+\t\"type = const (unsigned char|char)\" \\\n+\t\"(unsigned char const)\"\n+gdb_test \"whatis (short const) v_short\" \\\n+\t\"type = const (short|short int)\" \\\n+\t\"(short const)\"\n+gdb_test \"whatis (signed short const) v_signed_short\" \\\n+\t\"type = const (short|short int|signed short|signed short int)\" \\\n+\t\"(signed short const)\"\n+gdb_test \"whatis (unsigned short const) v_unsigned_short\" \\\n+\t\"type = const (unsigned short|short unsigned int)\" \\\n+\t\"(unsigned short const)\"\n+gdb_test \"whatis (int const) v_int\" \\\n+\t\"type = const int\" \\\n+\t\"(int const)\"\n+gdb_test \"whatis (signed int const) v_signed_int\" \\\n+\t\"type = const (signed int|int)\" \\\n+\t\"(signed int const)\"\n+gdb_test \"whatis (unsigned int const) v_unsigned_int\" \\\n+\t\"type = const unsigned int\" \\\n+\t\"(unsigned int const)\"\n+gdb_test \"whatis (long const) v_long\" \\\n+\t\"type = const (long|long int)\" \\\n+\t\"(long const)\"\n+gdb_test \"whatis (signed long const) v_signed_long\" \\\n+\t\"type = const (signed |)long( int|)\" \\\n+\t\"(signed long const)\"\n+gdb_test \"whatis (unsigned long const) v_unsigned_long\" \\\n+\t\"type = const (unsigned long|long unsigned int)\" \\\n+\t\"(unsigned long const)\"\n+gdb_test \"whatis (long long const) v_long_long\" \\\n+\t\"type = const long long( int|)\" \\\n+\t\"(long long const)\"\n+gdb_test \"whatis (signed long long const) v_signed_long_long\" \\\n+\t\"type = const (signed |)long long( int|)\" \\\n+\t\"(signed long long const)\"\n+gdb_test \"whatis (unsigned long long const) v_unsigned_long_long\" \\\n+\t\"type = const (unsigned long long|long long unsigned int)\" \\\n+\t\"(unsigned long long const)\"\n+gdb_test \"whatis (float const) v_float\" \\\n+\t\"type = const float\" \\\n+\t\"(float const)\"\n+gdb_test \"whatis (double const) v_double\" \\\n+\t\"type = const double\" \\\n+\t\"(double const)\"\n+\n+gdb_test \"whatis (char volatile) v_char\" \\\n+\t\"type = volatile char\" \\\n+\t\"(char volatile)\"\n+gdb_test \"whatis (signed char volatile) v_signed_char\" \\\n+\t\"type = volatile signed char\" \\\n+\t\"(signed char volatile)\"\n+gdb_test \"whatis (unsigned char volatile) v_unsigned_char\" \\\n+\t\"type = volatile (unsigned char|char)\" \\\n+\t\"(unsigned char volatile)\"\n+gdb_test \"whatis (short volatile) v_short\" \\\n+\t\"type = volatile (short|short int)\" \\\n+\t\"(short volatile)\"\n+gdb_test \"whatis (signed short volatile) v_signed_short\" \\\n+\t\"type = volatile (short|short int|signed short|signed short int)\" \\\n+\t\"(signed short volatile)\"\n+gdb_test \"whatis (unsigned short volatile) v_unsigned_short\" \\\n+\t\"type = volatile (unsigned short|short unsigned int)\" \\\n+\t\"(unsigned short volatile)\"\n+gdb_test \"whatis (int volatile) v_int\" \\\n+\t\"type = volatile int\" \\\n+\t\"(int volatile)\"\n+gdb_test \"whatis (signed int volatile) v_signed_int\" \\\n+\t\"type = volatile (signed int|int)\" \\\n+\t\"(signed int volatile)\"\n+gdb_test \"whatis (unsigned int volatile) v_unsigned_int\" \\\n+\t\"type = volatile unsigned int\" \\\n+\t\"(unsigned int volatile)\"\n+gdb_test \"whatis (long volatile) v_long\" \\\n+\t\"type = volatile (long|long int)\" \\\n+\t\"(long volatile)\"\n+gdb_test \"whatis (signed long volatile) v_signed_long\" \\\n+\t\"type = volatile (signed |)long( int|)\" \\\n+\t\"(signed long volatile)\"\n+gdb_test \"whatis (unsigned long volatile) v_unsigned_long\" \\\n+\t\"type = volatile (unsigned long|long unsigned int)\" \\\n+\t\"(unsigned long volatile)\"\n+gdb_test \"whatis (long long volatile) v_long_long\" \\\n+\t\"type = volatile long long( int|)\" \\\n+\t\"(long long volatile)\"\n+gdb_test \"whatis (signed long long volatile) v_signed_long_long\" \\\n+\t\"type = volatile (signed |)long long( int|)\" \\\n+\t\"(signed long long volatile)\"\n+gdb_test \"whatis (unsigned long long volatile) v_unsigned_long_long\" \\\n+\t\"type = volatile (unsigned long long|long long unsigned int)\" \\\n+\t\"(unsigned long long volatile)\"\n+gdb_test \"whatis (float volatile) v_float\" \\\n+\t\"type = volatile float\" \\\n+\t\"(float volatile)\"\n+gdb_test \"whatis (double volatile) v_double\" \\\n+\t\"type = volatile double\" \\\n+\t\"(double volatile)\"\n+\n+#\n+# enums\n+#\n+\n+gdb_test \"whatis (const enum misordered) v_misordered\" \\\n+\t\"type = const enum misordered\" \\\n+\t\"(const enum misordered)\"\n+gdb_test \"whatis (enum misordered const) v_misordered\" \\\n+\t\"type = const enum misordered\" \\\n+\t\"(enum misordered const)\"\n+gdb_test \"whatis (volatile enum misordered) v_misordered\" \\\n+\t\"type = volatile enum misordered\" \\\n+\t\"(volatile enum misordered)\"\n+gdb_test \"whatis (enum misordered volatile) v_misordered\" \\\n+\t\"type = volatile enum misordered\" \\\n+\t\"(enum misordered volatile)\"\n+\n+#\n+# Pointers\n+#\n+\n+gdb_test \"whatis (const int *) v_int_pointer\" \\\n+\t\"type = const int${ws}\\\\*\" \\\n+\t\"(const int *)\"\n+gdb_test \"whatis (int const *) v_int_pointer\" \\\n+\t\"type = const int${ws}\\\\*\" \\\n+\t\"(int const *)\"\n+gdb_test \"whatis (int * const) v_int_pointer\" \\\n+\t\"type = int \\\\*${ws}const\" \\\n+\t\"(int * const)\"\n+gdb_test \"whatis (const int * const) v_int_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const\" \\\n+\t\"(const int * const)\"\n+gdb_test \"whatis (int const * const) v_int_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const\" \\\n+\t\"(int const * const)\"\n+\n+gdb_test \"whatis (const int **) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}\\\\*\" \\\n+\t\"(const int **)\"\n+gdb_test \"whatis (int const **) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}\\\\*\" \\\n+\t\"(int const **)\"\n+gdb_test \"whatis (int ** const) v_int_pointer_pointer\" \\\n+\t\"type = int \\\\*${ws}\\\\*${ws}const\" \\\n+\t\"(int ** const)\"\n+gdb_test \"whatis (const int * const *) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const${ws}\\\\*\" \\\n+\t\"(const int * const *)\"\n+gdb_test \"whatis (int const * const *) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const${ws}\\\\*\" \\\n+\t\"(int const * const *)\"\n+gdb_test \"whatis (const int * const * const) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const${ws}\\\\*${ws}const\" \\\n+\t\"(const int * const * const)\"\n+gdb_test \"whatis (int const * const * const) v_int_pointer_pointer\" \\\n+\t\"type = const int${ws}\\\\*${ws}const${ws}\\\\*${ws}const\" \\\n+\t\"(int const * const * const)\"\n+\n+#\n+# Arrays TODO\n+#\n+\n+#\n+# Pointers to arrays, arrays of pointers TODO\n+#\n+\n+#\n+# Structs and Unions\n+#\n+\n+gdb_test \"whatis (const struct t_struct) v_struct1\" \\\n+\t\"type = const struct t_struct\" \\\n+\t\"(const struct t_struct)\"\n+gdb_test \"whatis (const union t_union) v_union\" \\\n+\t\"type = const union t_union\" \\\n+\t\"(const union t_union)\"\n+gdb_test \"whatis (struct t_struct const) v_struct1\" \\\n+\t\"type = const struct t_struct\" \\\n+\t\"(struct t_struct const)\"\n+gdb_test \"whatis (union t_union const) v_union\" \\\n+\t\"type = const union t_union\" \\\n+\t\"(union t_union const)\"\n+gdb_test \"whatis (const struct t_struct *) &v_struct1\" \\\n+\t\"type = const struct t_struct${ws}\\\\*\" \\\n+\t\"(const struct t_struct *)\"\n+gdb_test \"whatis (const union t_union *) &v_union\" \\\n+\t\"type = const union t_union${ws}\\\\*\" \\\n+\t\"(const union t_union *)\"\n+gdb_test \"whatis (struct t_struct const *) &v_struct1\" \\\n+\t\"type = const struct t_struct${ws}\\\\*\" \\\n+\t\"(struct t_struct const *)\"\n+gdb_test \"whatis (union t_union const *) &v_union\" \\\n+\t\"type = const union t_union${ws}\\\\*\" \\\n+\t\"(union t_union const *)\"\n+gdb_test \"whatis (struct t_struct * const) &v_struct1\" \\\n+\t\"type = struct t_struct${ws}\\\\*${ws}const\" \\\n+\t\"(struct t_struct * const)\"\n+gdb_test \"whatis (union t_union * const) &v_union\" \\\n+\t\"type = union t_union${ws}\\\\*${ws}const\" \\\n+\t\"(union t_union * const)\"\n+gdb_test \"whatis (const struct t_struct * const) &v_struct1\" \\\n+\t\"type = const struct t_struct${ws}\\\\*${ws}const\" \\\n+\t\"(const struct t_struct * const)\"\n+gdb_test \"whatis (const union t_union * const) &v_union\" \\\n+\t\"type = const union t_union${ws}\\\\*${ws}const\" \\\n+\t\"(const union t_union * const)\"\n+gdb_test \"whatis (struct t_struct const * const) &v_struct1\" \\\n+\t\"type = const struct t_struct${ws}\\\\*${ws}const\" \\\n+\t\"(struct t_struct const * const)\"\n+gdb_test \"whatis (union t_union const * const) &v_union\" \\\n+\t\"type = const union t_union${ws}\\\\*${ws}const\" \\\n+\t\"(union t_union const * const)\"\n+\n+#\n+# Function pointers TODO\n+#\n+"
    },
    {
      "sha": "2d2e881f0f56fdf3c475fff92f0aefc504bed9d2",
      "filename": "gdb/testsuite/gdb.base/ctf-ptype.c",
      "status": "added",
      "additions": 305,
      "deletions": 0,
      "changes": 305,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-ptype.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-ptype.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-ptype.c?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,305 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/*\n+ *\tTest file with lots of different types, for testing the\n+ *\t\"ptype\" command on CTF data. It's devired from ptype.c.\n+ */\n+\n+/*\n+ *\tFirst the basic C types.\n+ */\n+\n+#if !defined (__STDC__) && !defined (_AIX)\n+#define signed  /**/\n+#endif\n+\n+char\t\tv_char;\n+signed char\tv_signed_char;\n+unsigned char\tv_unsigned_char;\n+\n+short\t\tv_short;\n+signed short\tv_signed_short;\n+unsigned short\tv_unsigned_short;\n+\n+int\t\tv_int;\n+signed int\tv_signed_int;\n+unsigned int\tv_unsigned_int;\n+\n+long\t\tv_long;\n+signed long\tv_signed_long;\n+unsigned long\tv_unsigned_long;\n+\n+float\t\tv_float;\n+double\t\tv_double;\n+\n+/**** arrays *******/\n+\n+char\t\tv_char_array[2];\n+signed char\tv_signed_char_array[2];\n+unsigned char\tv_unsigned_char_array[2];\n+\n+short\t\tv_short_array[2];\n+signed short\tv_signed_short_array[2];\n+unsigned short\tv_unsigned_short_array[2];\n+\n+int\t\tv_int_array[2];\n+signed int\tv_signed_int_array[2];\n+unsigned int\tv_unsigned_int_array[2];\n+\n+long\t\tv_long_array[2];\n+signed long\tv_signed_long_array[2];\n+unsigned long\tv_unsigned_long_array[2];\n+\n+float\t\tv_float_array[2];\n+double\t\tv_double_array[2];\n+\n+/* PR 3742 */\n+typedef char t_char_array[];\n+t_char_array *pv_char_array;\n+\n+/**** pointers *******/\n+\n+char\t\t*v_char_pointer;\n+signed char\t*v_signed_char_pointer;\n+unsigned char\t*v_unsigned_char_pointer;\n+\n+short\t\t*v_short_pointer;\n+signed short\t*v_signed_short_pointer;\n+unsigned short\t*v_unsigned_short_pointer;\n+\n+int\t\t*v_int_pointer;\n+signed int\t*v_signed_int_pointer;\n+unsigned int\t*v_unsigned_int_pointer;\n+\n+long\t\t*v_long_pointer;\n+signed long\t*v_signed_long_pointer;\n+unsigned long\t*v_unsigned_long_pointer;\n+\n+float\t\t*v_float_pointer;\n+double\t\t*v_double_pointer;\n+\n+/**** structs *******/\n+\n+struct t_struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct1;\n+\n+struct t_struct *v_t_struct_p;\n+\n+struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct2;\n+\n+/* typedef'd struct without a tag.  */\n+typedef struct {\n+  double v_double_member;\n+  int v_int_member;\n+} t_struct3;\n+/* GCC seems to want a variable of this type, or else it won't put out\n+   a symbol.  */\n+t_struct3 v_struct3;\n+\n+/**** unions *******/\n+\n+union t_union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union;\n+\n+union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union2;\n+\n+/* typedef'd union without a tag.  */\n+typedef union {\n+  double v_double_member;\n+  int v_int_member;\n+} t_union3;\n+/* GCC seems to want a variable of this type, or else it won't put out\n+   a symbol.  */\n+t_union3 v_union3;\n+\n+/**** Some misc more complicated things *******/\n+\n+struct outer_struct {\n+\tint outer_int;\n+\tstruct inner_struct {\n+\t\tint inner_int;\n+\t\tlong inner_long;\n+\t}inner_struct_instance;\n+\tunion inner_union {\n+\t\tint inner_union_int;\n+\t\tlong inner_union_long;\n+\t}inner_union_instance;\n+\tlong outer_long;\n+} nested_su;\n+\n+struct highest\n+{\n+  int a;\n+  struct\n+  {\n+    int b;\n+    struct { int c; } anonymous_level_2;\n+  } anonymous_level_1;\n+} the_highest;\n+\n+/**** Enumerations *******/\n+\n+enum\n+/* Work around the bug for compilers which don't put out the right stabs.  */\n+#if __GNUC__ < 2 && !defined (_AIX)\n+primary1_tag\n+#endif\n+{red1, green1, blue1} primary1;\n+\n+enum {red, green, blue} primary;\n+enum colors {yellow, purple, pink} nonprimary;\n+\n+enum {chevy, ford} clunker;\n+enum cars {bmw, porsche} sportscar;\n+\n+#undef FALSE\n+#undef TRUE\n+typedef enum {FALSE, TRUE} boolean;\n+boolean v_boolean;\n+/*note: aCC has bool type predefined with 'false' and 'true'*/\n+typedef enum bvals {my_false, my_true} boolean2;\n+boolean2 v_boolean2;\n+\n+enum misordered {two = 2, one = 1, zero = 0, three = 3};\n+\n+/* Seems like we need a variable of this type to get the type to be put\n+   in the executable, at least for AIX xlc.  */\n+enum misordered v_misordered = three;\n+\n+/**** Pointers to functions *******/\n+\n+typedef int (*func_type) (int (*) (int, float), float);\n+double (*old_fptr) ();\n+double (*new_fptr) (void);\n+int (*fptr) (int, float);\n+int *(*fptr2) (int (*) (int, float), float);\n+int (*xptr) (int (*) (), int (*) (void), int);\n+int (*(*ffptr) (char)) (short);\n+int (*(*(*fffptr) (char)) (short)) (long);\n+\n+func_type v_func_type;\n+\n+int main ()\n+{\n+  /* Ensure that malloc is a pointer type; avoid use of \"void\" and any include files. */\n+/*  extern char *malloc();*/\n+\n+  /* Some of the tests in ptype.exp require invoking malloc, so make\n+     sure it is linked in to this program.  */\n+  v_char_pointer = (char *) malloc (1);\n+\n+  /* Some linkers (e.g. on AIX) remove unreferenced variables,\n+     so make sure to reference them. */\n+  primary = blue;\n+  primary1 = blue1;\n+  nonprimary = pink;\n+  sportscar = porsche;\n+  clunker = ford;\n+  v_struct1.v_int_member = 5;\n+  v_struct2.v_int_member = 6;\n+  v_struct3.v_int_member = 7;\n+\n+  v_char = 0;\n+  v_signed_char = 0;\n+  v_unsigned_char = 0;\n+\n+  v_short = 0;\n+  v_signed_short = 0;\n+  v_unsigned_short = 0;\n+\n+  v_int = 0;\n+  v_signed_int = 0;\n+  v_unsigned_int = 0;\n+\n+  v_long = 0;\n+  v_signed_long = 0;\n+  v_unsigned_long = 0;\n+\n+  v_float = 0;\n+  v_double = 0;\n+\n+  v_char_array[0] = 0;\n+  v_signed_char_array[0] = 0;\n+  v_unsigned_char_array[0] = 0;\n+\n+  v_short_array[0] = 0;\n+  v_signed_short_array[0] = 0;\n+  v_unsigned_short_array[0] = 0;\n+\n+  v_int_array[0] = 0;\n+  v_signed_int_array[0] = 0;\n+  v_unsigned_int_array[0] = 0;\n+\n+  v_long_array[0] = 0;\n+  v_signed_long_array[0] = 0;\n+  v_unsigned_long_array[0] = 0;\n+\n+  v_float_array[0] = 0;\n+  v_double_array[0] = 0;\n+\n+  v_char_pointer = 0;\n+  v_signed_char_pointer = 0;\n+  v_unsigned_char_pointer = 0;\n+\n+  v_short_pointer = 0;\n+  v_signed_short_pointer = 0;\n+  v_unsigned_short_pointer = 0;\n+\n+  v_int_pointer = 0;\n+  v_signed_int_pointer = 0;\n+  v_unsigned_int_pointer = 0;\n+\n+  v_long_pointer = 0;\n+  v_signed_long_pointer = 0;\n+  v_unsigned_long_pointer = 0;\n+\n+  v_float_pointer = 0;\n+  v_double_pointer = 0;\n+\n+  nested_su.outer_int = 0;\n+  v_t_struct_p = 0;\n+\n+  the_highest.a = 0;\n+  return 0;\n+}"
    },
    {
      "sha": "9f545824224a02776d9a45e0d1fdd565c7f7d7b5",
      "filename": "gdb/testsuite/gdb.base/ctf-ptype.exp",
      "status": "added",
      "additions": 288,
      "deletions": 0,
      "changes": 288,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-ptype.exp?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,288 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is a subset of ptype.exp written by Rob Savoye. (rob@cygnus.com)\n+\n+#\n+# test running programs\n+#\n+# -gt generates full-fledged CTF.\n+\n+standard_testfile .c\n+set opts \"additional_flags=-gt\"\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+\t  [list $srcfile] [list $opts nowarnings]] } {\n+    return 0\n+}\n+\n+# Create and source the file that provides information about the compiler\n+# used to compile the test case.\n+if [get_compiler_info] {\n+    return -1\n+}\n+\n+# Test ptype of unnamed enumeration members before any action causes\n+# the partial symbol table to be expanded to full symbols.  This fails\n+# with stabs compilers which fail to use a nameless stab (such as\n+# pre-2.4.5 versions of gcc and most non-gcc compilers).\n+\n+gdb_test_multiple \"ptype red1\" \"ptype unnamed enumeration member\" {\n+    -re \"type = enum primary1_tag \\{red1, green1, blue1\\}.*$gdb_prompt $\" {\n+\t# The workaround is in effect.  As this is a compiler, not GDB,\n+\t# bug, we'll make it a PASS but perhaps it should be an XFAIL.\n+\tpass \"ptype unnamed enumeration member (worked around)\"\n+    }\n+    -re \"type = enum \\{red1, green1, blue1\\}.*$gdb_prompt $\" {\n+\tpass \"ptype unnamed enumeration member\"\n+    }\n+}\n+\n+#\n+# test ptype command with structures\n+#\n+# Here and elsewhere, we accept\n+# \"long\", \"long int\", or \"int\" for long variables (whatis.exp already\n+# has an XFAIL for \"int\" (Sun cc bug), so no need to fail it here).\n+gdb_test \"ptype struct t_struct\" \"type = struct t_struct \\{.*\\[\\r\\n\\]    (unsigned |)char v_char_member;.*\\[\\r\\n\\]    (short|short int) v_short_member;.*\\[\\r\\n\\]    int v_int_member;.*\\[\\r\\n\\]    (long|long int|int) v_long_member;.*\\[\\r\\n\\]    float v_float_member;.*\\[\\r\\n\\]    double v_double_member;.*\\[\\r\\n\\]\\}.*\" \"ptype structure\"\n+\n+\n+# Test the equivalence between '.' and '->' for struct member references.\n+\n+if [gdb_test \"ptype v_t_struct_p.v_float_member\"\t\"type = float\"]<0 then {\n+    return -1\n+}\n+if [gdb_test \"ptype v_t_struct_p->v_float_member\"\t\"type = float\"]<0 then {\n+    return -1\n+}\n+if [gdb_test \"ptype v_t_struct_p.v_float_member\"\t\"type = float\"]<0 then {\n+    return -1\n+}\n+if [gdb_test \"ptype v_t_struct_p->v_float_member\"\t\"type = float\"]<0 then {\n+    return -1\n+}\n+\n+#\n+# test ptype command with unions\n+#\n+gdb_test \"ptype union t_union\" \"type = union t_union \\{.*\\[\\r\\n\\]    (unsigned |)char v_char_member;.*\\[\\r\\n\\]    (short|short int) v_short_member;.*\\[\\r\\n\\]    int v_int_member;.*\\[\\r\\n\\]    (long|long int|int) v_long_member;.*\\[\\r\\n\\]    float v_float_member;.*\\[\\r\\n\\]    double v_double_member;.*\\[\\r\\n\\]\\}.*\" \"ptype union\"\n+\n+#\n+# test ptype command with enums\n+#\n+\n+gdb_test \"ptype primary\" \"type = enum .red, green, blue.*\" \"ptype unnamed enumeration\"\n+\n+gdb_test \"ptype enum colors\" \"type = enum colors \\{yellow, purple, pink\\}.*\" \"ptype named enumeration\"\n+\n+\n+#\n+# test ptype command with enums as typedef\n+#\n+gdb_test \"ptype boolean\" \"type = enum (boolean |)\\{FALSE, TRUE\\}.*\" \"ptype unnamed typedef'd enumeration\"\n+\n+gdb_test \"list main\" \".*\"\n+\n+# Same thing with struct and union.\n+gdb_test \"ptype t_struct3\" \"type = struct (t_struct3 |)\\{.*\n+ *double v_double_member;.*\n+ *int v_int_member;.*\\}\" \"printing typedef'd struct\"\n+\n+gdb_test \"ptype t_union3\" \"type = union (t_union3 |)\\{.*\n+ *double v_double_member;.*\n+ *int v_int_member;.*\\}\" \"printing typedef'd union\"\n+\n+gdb_test \"ptype enum bvals\" \"type = enum bvals \\{my_false, my_true\\}.*\" \"ptype named typedef'd enumf'd enum\"\n+\n+#\n+# test ptype command with out-of-order enum values\n+#\n+gdb_test \"ptype enum misordered\" \"type = enum misordered \\{two = 2, one = 1, zero = 0, three = 3\\}.*\" \"ptype misordered enumeration\"\n+\n+#\n+# test ptype command with a named enum's value\n+#\n+gdb_test \"ptype three\" \"type = enum misordered \\{two = 2, one = 1, zero = 0, three = 3\\}.*\" \"ptype named enumeration member\"\n+\n+gdb_test \"ptype red\" \"type = enum \\{red, green, blue\\}.*\" \"ptype unnamed enumeration member #2\"\n+\n+#\n+# test ptype command with arrays\n+#\n+gdb_test \"ptype v_char_array\" \"type = char .2..*\" \"ptype char array\"\n+\n+gdb_test \"ptype v_signed_char_array\" \"type = (|signed )char .2..*\" \"ptype signed char array\"\n+\n+gdb_test \"ptype v_unsigned_char_array\" \"type = unsigned char .2..*\" \"ptype unsigned char array\"\n+\n+gdb_test \"ptype v_int_array\" \"type = int .2..*\" \"ptype int array\"\n+\n+gdb_test \"ptype v_signed_int_array\" \"type = int .2..*\" \"ptype signed int array\"\n+\n+gdb_test \"ptype v_unsigned_int_array\" \"type = unsigned int .2..*\" \"ptype unsigned int array\"\n+\n+gdb_test \"ptype v_long_array\" \"type = (long|int|long int) .2..*\" \"ptype long array\"\n+\n+gdb_test \"ptype v_signed_long_array\" \"type = (long|int|long int) .2..*\" \"ptype signed long array\"\n+\n+gdb_test \"ptype v_unsigned_long_array\" \"type = unsigned long .2..*\" \"ptype unsigned long array\"\n+\n+gdb_test \"ptype v_float_array\" \"type = float .2..*\" \"ptype float array\"\n+\n+gdb_test \"ptype v_double_array\" \"type = double .2..*\" \"ptype double array\"\n+\n+gdb_test \"ptype pv_char_array\" \"type = (|unsigned )char \\\\(\\\\*\\\\)\\\\\\[0?\\\\\\]\"\n+\n+#\n+# test ptype command with pointers\n+#\n+gdb_test \"ptype v_char_pointer\" \"type = char \\*.*\" \"ptype char pointer\"\n+\n+gdb_test \"ptype v_short_pointer\" \"type = short \\*.*\" \"ptype short pointer\"\n+\n+gdb_test \"ptype v_long_pointer\" \"type = long \\*.*\" \"ptype long pointer\"\n+\n+gdb_test \"ptype v_int_pointer\" \"type = int \\*.*\" \"ptype int pointer\"\n+\n+gdb_test \"ptype v_signed_long_pointer\" \"type = long \\*.*\" \"ptype signed long pointer\"\n+\n+gdb_test \"ptype v_unsigned_long_pointer\" \"type = unsigned long \\*.*\" \"ptype unsigned long pointer\"\n+\n+gdb_test \"ptype v_float_pointer\" \"type = float \\*.*\" \"ptype float pointer\"\n+\n+gdb_test \"ptype v_double_pointer\" \"type = double \\*.*\" \"ptype double pointer\"\n+\n+#\n+# test ptype command with basic C types\n+#\n+gdb_test \"ptype v_short\" \"type = short(| int).*\" \"ptype short\"\n+\n+gdb_test \"ptype v_int\" \"type = int.*\" \"ptype int\"\n+\n+#\n+# test ptype command with nested structure and union\n+#\n+gdb_test \"ptype struct outer_struct\" \"type = struct outer_struct \\{.*\\[\\r\\n\\]+\\\n+.*int outer_int;.*\\[\\r\\n\\]+\\\n+.*(struct|) inner_struct inner_struct_instance;.*\\[\\r\\n\\]+\\\n+.*(union|) inner_union inner_union_instance;.*\\[\\r\\n\\]+\\\n+.*(long|long int|int) outer_long;.*\\[\\r\\n\\]\\}.*\" \"ptype outer structure\"\n+\n+gdb_test \"ptype struct inner_struct\" \"type = struct inner_struct \\{.*\\[\\r\\n\\]    int inner_int;.*\\[\\r\\n\\]    (long|long int|int) inner_long;.*\\[\\r\\n\\]\\}.*\" \"ptype inner structure\"\n+\n+gdb_test \"ptype union inner_union\" \"type = union inner_union \\{.*\\[\\r\\n\\]    int inner_union_int;.*\\[\\r\\n\\]    (long|long int|int) inner_union_long;.*\\[\\r\\n\\]\\}.*\" \"ptype inner union\"\n+\n+gdb_test \"ptype nested_su\" \"type = struct outer_struct \\{.*\\[\\r\\n\\]    int outer_int;.*\\[\\r\\n\\]    (struct |)inner_struct inner_struct_instance;.*\\[\\r\\n\\]    (union |)inner_union inner_union_instance;.*\\[\\r\\n\\]    (long|long int|int) outer_long;.*\\[\\r\\n\\]\\}.*\" \"ptype nested structure\"\n+\n+gdb_test \"ptype nested_su.outer_int\" \"type = int.*\" \"ptype outer int\"\n+\n+gdb_test \"ptype nested_su.inner_struct_instance\" \"type = struct inner_struct \\{.*\\[\\r\\n\\]    int inner_int;.*\\[\\r\\n\\]    (long|long int|int) inner_long;.*\\[\\r\\n\\]\\}.*\" \"ptype nested structure #2\"\n+\n+gdb_test \"ptype nested_su.inner_struct_instance.inner_int\" \"type = int.*\" \"ptype inner int\"\n+\n+gdb_test \"ptype nested_su.inner_union_instance\" \"type = union inner_union \\{.*\\[\\r\\n\\]    int inner_union_int;.*\\[\\r\\n\\]    (long|long int|int) inner_union_long;.*\\[\\r\\n\\]\\}.*\" \"ptype nested union\"\n+\n+# Print the type description of variable the_highest, and verify that\n+# the type description for the fields whose type is anonymous are\n+# correctly printed (at nesting level 1 and 2).\n+\n+gdb_test \"ptype the_highest\" \\\n+         \"type = struct highest \\{.*\\[\\r\\n\\] *int a;.*\\[\\r\\n\\] *struct \\{.*\\[\\r\\n\\] *int b;.*\\[\\r\\n\\] *struct \\{\\.\\.\\.\\} anonymous_level_2;.*\\[\\r\\n\\] *\\} anonymous_level_1;.*\\[\\r\\n\\]}.*\" \\\n+         \"ptype the_highest\"\n+\n+# Print the type descrption for one of the fields of variable the_highest.\n+# The purpose is to verify that the type of a field that was printed above\n+# as \"struct {...}\" is now printed in a more descriptive way (because the\n+# nesting level is now one level less).\n+\n+gdb_test \"ptype the_highest.anonymous_level_1\" \\\n+         \"type = struct \\{.*\\[\\r\\n\\] *int b;.*\\[\\r\\n\\] *struct \\{.*\\[\\r\\n\\] *int c;.*\\[\\r\\n\\] *\\} anonymous_level_2;.*\\[\\r\\n\\]}.*\" \\\n+         \"ptype the_highest\"\n+\n+# Print the type of the identifier ID, and check the response:\n+# - Expect to see PROTOTYPED as the type.  PROTOTYPED is not a regular\n+#   expression; it's a literal string.\n+# - If we instead see the unprototyped type PLAIN, and we're using STABS\n+#   generated by GCC, that's an xfail; as of 9 Feb 2002, GCC never emits\n+#   prototyped function types in STABS.  Like PROTOTYPED, PLAIN is a\n+#   literal string, not a regular expression.\n+# - If we see OVERPROTOTYPED, it's an xfail for RealView; RealView\n+#   does not distinguish prototyped and unprototyped functions, and\n+#   GDB defaults to prototyped.\n+# - Otherwise, it's a failure.\n+proc ptype_maybe_prototyped { id prototyped plain { overprototyped \"NO-MATCH\" } } {\n+    global gdb_prompt\n+    global gcc_compiled\n+\n+    # Turn the arguments, which are literal strings, into\n+    # regular expressions by quoting any special characters they contain.\n+    foreach var { prototyped plain overprototyped } {\n+\teval \"set val \\$$var\"\n+\tregsub -all \"\\[\\]\\[*()\\]\" $val \"\\\\\\\\&\" val\n+\tregsub -all \"short int\" $val \"short( int)?\" val\n+\tregsub -all \"long int\" $val \"long( int)?\" val\n+\teval \"set $var \\$val\"\n+    }\n+\n+    gdb_test_multiple \"ptype $id\" \"ptype $id\" {\n+        -re \"type = $prototyped\\[\\r\\n\\]+$gdb_prompt $\" {\n+            pass \"ptype $id\"\n+        }\n+        -re \"type = $plain\\[\\r\\n\\]+$gdb_prompt $\" {\n+            if {$gcc_compiled} { setup_xfail_format \"stabs\" }\n+            fail \"ptype $id (compiler doesn't emit prototyped types)\"\n+        }\n+        -re \"type = $overprototyped\\[\\r\\n\\]+$gdb_prompt $\" {\n+            if { [test_compiler_info \"armcc-*\"] } {\n+\t\tsetup_xfail \"*-*-*\"\n+\t    }\n+            fail \"ptype $id (compiler doesn't emit unprototyped types)\"\n+        }\n+    }\n+}\n+\n+ptype_maybe_prototyped \"old_fptr\" \"double (*)()\" \"double (*)()\" \\\n+                                  \"double (*)(void)\"\n+\n+# Test printing type of string constants and array constants, but\n+# requires a running process.  These call malloc, and can take a long\n+# time to execute over a slow serial link, so increase the timeout.\n+\n+if [runto_main] then {\n+\n+  if [target_info exists gdb,cannot_call_functions] {\n+    unsupported \"this target can not call functions\"\n+    continue\n+  }\n+\n+  # We need to up this because this can be really slow on some boards.\n+  # (malloc() is called as part of the test).\n+  set prev_timeout $timeout\n+  set timeout 60\n+\n+  gdb_test \"ptype \\\"abc\\\"\"\t\"type = char \\\\\\[4\\\\\\]\"\n+  gdb_test \"ptype {'a','b','c'}\"\t\"type = char \\\\\\[3\\\\\\]\"\n+  gdb_test \"ptype {0,1,2}\"\t\t\"type = int \\\\\\[3\\\\\\]\"\n+  gdb_test \"ptype {(long)0,(long)1,(long)2}\"\t  \"type = long \\\\\\[3\\\\\\]\"\n+  gdb_test \"ptype {(float)0,(float)1,(float)2}\" \"type = float \\\\\\[3\\\\\\]\"\n+  gdb_test \"ptype {{0,1,2},{3,4,5}}\"\t\"type = int \\\\\\[2\\\\\\]\\\\\\[3\\\\\\]\"\n+  gdb_test \"ptype {4,5,6}\\[2\\]\"\t\"type = int\"\n+  gdb_test \"ptype *&{4,5,6}\\[1\\]\"\t\"Attempt to take address of value not located in memory.\"\n+\n+  set timeout $prev_timeout\n+\n+  # Test ptype of user register\n+  gdb_test \"ptype \\$pc\" \"void \\\\(\\\\*\\\\)\\\\(\\\\)\" \"ptype \\$pc\"\n+}"
    },
    {
      "sha": "548dcbb7afde0ee401b28a161b41496d59ba2532",
      "filename": "gdb/testsuite/gdb.base/ctf-whatis.c",
      "status": "added",
      "additions": 282,
      "deletions": 0,
      "changes": 282,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-whatis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-whatis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-whatis.c?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,282 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/*\n+ *\tTest file with lots of different types, for testing the\n+ *\t\"whatis\" command on CTF data. It's derived from whatis.c.\n+ */\n+ \n+/*\n+ *\tFirst the basic C types.\n+ */\n+\n+char\t\tv_char;\n+signed char\tv_signed_char;\n+unsigned char\tv_unsigned_char;\n+\n+short\t\tv_short;\n+signed short\tv_signed_short;\n+unsigned short\tv_unsigned_short;\n+\n+int\t\tv_int;\n+signed int\tv_signed_int;\n+unsigned int\tv_unsigned_int;\n+\n+long\t\tv_long;\n+signed long\tv_signed_long;\n+unsigned long\tv_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+long long\t\tv_long_long;\n+signed long long\tv_signed_long_long;\n+unsigned long long\tv_unsigned_long_long;\n+#endif\n+\n+float\t\tv_float;\n+double\t\tv_double;\n+\n+/*\n+ *\tNow some derived types, which are arrays, functions-returning,\n+ *\tpointers, structures, unions, and enumerations.\n+ */\n+\n+/**** arrays *******/\n+\n+char\t\tv_char_array[2];\n+signed char\tv_signed_char_array[2];\n+unsigned char\tv_unsigned_char_array[2];\n+\n+short\t\tv_short_array[2];\n+signed short\tv_signed_short_array[2];\n+unsigned short\tv_unsigned_short_array[2];\n+\n+int\t\tv_int_array[2];\n+signed int\tv_signed_int_array[2];\n+unsigned int\tv_unsigned_int_array[2];\n+\n+long\t\tv_long_array[2];\n+signed long\tv_signed_long_array[2];\n+unsigned long\tv_unsigned_long_array[2];\n+\n+#ifndef NO_LONG_LONG\n+long long\t\tv_long_long_array[2];\n+signed long long\tv_signed_long_long_array[2];\n+unsigned long long\tv_unsigned_long_long_array[2];\n+#endif\n+\n+float\t\tv_float_array[2];\n+double\t\tv_double_array[2];\n+\n+/**** pointers *******/\n+\n+/* Make sure they still print as pointer to foo even there is a typedef\n+   for that type.  Test this not just for char *, which might be\n+   a special case kludge in GDB (Unix system include files like to define\n+   caddr_t), but for a variety of types.  */\n+typedef char *char_addr;\n+char_addr a_char_addr;\n+typedef unsigned short *ushort_addr;\n+ushort_addr a_ushort_addr;\n+typedef signed long *slong_addr;\n+slong_addr a_slong_addr;\n+#ifndef NO_LONG_LONG\n+typedef signed long long *slong_long_addr;\n+slong_long_addr a_slong_long_addr;\n+#endif\n+\n+char\t\t*v_char_pointer;\n+signed char\t*v_signed_char_pointer;\n+unsigned char\t*v_unsigned_char_pointer;\n+\n+short\t\t*v_short_pointer;\n+signed short\t*v_signed_short_pointer;\n+unsigned short\t*v_unsigned_short_pointer;\n+\n+int\t\t*v_int_pointer;\n+signed int\t*v_signed_int_pointer;\n+unsigned int\t*v_unsigned_int_pointer;\n+\n+long\t\t*v_long_pointer;\n+signed long\t*v_signed_long_pointer;\n+unsigned long\t*v_unsigned_long_pointer;\n+\n+#ifndef NO_LONG_LONG\n+long long\t\t*v_long_long_pointer;\n+signed long long\t*v_signed_long_long_pointer;\n+unsigned long long\t*v_unsigned_long_long_pointer;\n+#endif\n+\n+float\t\t*v_float_pointer;\n+double\t\t*v_double_pointer;\n+\n+/**** structs *******/\n+\n+struct t_struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct1, *v_struct_ptr1;\n+\n+struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct2, *v_struct_ptr2;\n+\n+/**** unions *******/\n+\n+union t_union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union, *v_union_ptr;\n+\n+union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union2, *v_union_ptr2;\n+\n+/**** Some misc more complicated things *******/\n+\n+struct outer_struct {\n+\tint outer_int;\n+\tstruct inner_struct {\n+\t\tint inner_int;\n+\t\tlong inner_long;\n+\t}inner_struct_instance;\n+\tunion inner_union {\n+\t\tint inner_union_int;\n+\t\tlong inner_union_long;\n+\t}inner_union_instance;\n+\tlong outer_long;\n+} nested_su;\n+\n+/***********/\n+\n+int main ()\n+{\n+  /* Some linkers (e.g. on AIX) remove unreferenced variables,\n+     so make sure to reference them. */\n+  v_char = 0;\n+  v_signed_char = 1;\n+  v_unsigned_char = 2;\n+\n+  v_short = 3;\n+  v_signed_short = 4;\n+  v_unsigned_short = 5;\n+\n+  v_int = 6;\n+  v_signed_int = 7;\n+  v_unsigned_int = 8;\n+\n+  v_long = 9;\n+  v_signed_long = 10;\n+  v_unsigned_long = 11;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long = 12;\n+  v_signed_long_long = 13;\n+  v_unsigned_long_long = 14;\n+#endif\n+\n+  v_float = 100.0;\n+  v_double = 200.0;\n+\n+\n+  v_char_array[0] = v_char;\n+  v_signed_char_array[0] = v_signed_char;\n+  v_unsigned_char_array[0] = v_unsigned_char;\n+\n+  v_short_array[0] = v_short;\n+  v_signed_short_array[0] = v_signed_short;\n+  v_unsigned_short_array[0] = v_unsigned_short;\n+\n+  v_int_array[0] = v_int;\n+  v_signed_int_array[0] = v_signed_int;\n+  v_unsigned_int_array[0] = v_unsigned_int;\n+\n+  v_long_array[0] = v_long;\n+  v_signed_long_array[0] = v_signed_long;\n+  v_unsigned_long_array[0] = v_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long_array[0] = v_long_long;\n+  v_signed_long_long_array[0] = v_signed_long_long;\n+  v_unsigned_long_long_array[0] = v_unsigned_long_long;\n+#endif\n+\n+  v_float_array[0] = v_float;\n+  v_double_array[0] = v_double;\n+\n+  v_char_pointer = &v_char;\n+  v_signed_char_pointer = &v_signed_char;\n+  v_unsigned_char_pointer = &v_unsigned_char;\n+\n+  v_short_pointer = &v_short;\n+  v_signed_short_pointer = &v_signed_short;\n+  v_unsigned_short_pointer = &v_unsigned_short;\n+\n+  v_int_pointer = &v_int;\n+  v_signed_int_pointer = &v_signed_int;\n+  v_unsigned_int_pointer = &v_unsigned_int;\n+\n+  v_long_pointer = &v_long;\n+  v_signed_long_pointer = &v_signed_long;\n+  v_unsigned_long_pointer = &v_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long_pointer = &v_long_long;\n+  v_signed_long_long_pointer = &v_signed_long_long;\n+  v_unsigned_long_long_pointer = &v_unsigned_long_long;\n+#endif\n+\n+  v_float_pointer = &v_float;\n+  v_double_pointer = &v_double;\n+\n+  v_union2.v_short_member = v_union.v_short_member;\n+\n+  v_struct1.v_char_member = 0;\n+  v_struct2.v_char_member = 0;\n+\n+  nested_su.outer_int = 0;\n+  return 0;\n+}"
    },
    {
      "sha": "3f26fc326e391c8ea330db69093cff01c7fac767",
      "filename": "gdb/testsuite/gdb.base/ctf-whatis.exp",
      "status": "added",
      "additions": 413,
      "deletions": 0,
      "changes": 413,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-whatis.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30d1f0184953478d14641c495261afd06ebfabac/gdb/testsuite/gdb.base/ctf-whatis.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-whatis.exp?ref=30d1f0184953478d14641c495261afd06ebfabac",
      "patch": "@@ -0,0 +1,413 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is a subset of whatis.exp written by Rob Savoye. (rob@cygnus.com)\n+\n+#\n+# test running programs\n+#\n+# -gt generates full-fledged CTF.\n+\n+standard_testfile .c\n+set opts \"additional_flags=-gt\"\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+          [list $srcfile] [list $opts nowarnings]] } {\n+    return 0\n+}\n+\n+# Create and source the file that provides information about the compiler\n+# used to compile the test case.\n+if [get_compiler_info] {\n+    return -1\n+}\n+\n+# Start with a fresh gdb.\n+\n+clean_restart $binfile\n+\n+# Define a procedure to set up an xfail for all targets that put out a\n+# `long' type as an `int' type.\n+# Sun cc has this problem.\n+# It was said that COFF targets can not distinguish int from long either.\n+\n+proc setup_xfail_on_long_vs_int {} {\n+    global gcc_compiled\n+\n+    if {!$gcc_compiled} {\n+\tsetup_xfail \"*-sun-sunos4*\" \"i*86-sequent-bsd*\"\n+    }\n+}\n+\n+#\n+# Test whatis command with basic C types\n+#\n+# The name printed now (as of 23 May 1993) is whatever name the compiler\n+# uses in the stabs.  So we need to deal with names both from gcc and\n+# native compilers.\n+#\n+\n+gdb_test \"whatis v_char\" \\\n+    \"type = (unsigned char|char)\" \\\n+    \"whatis char\"\n+\n+gdb_test \"whatis v_signed_char\" \\\n+    \"type = (signed char|char)\" \\\n+    \"whatis signed char\"\n+\n+gdb_test \"whatis v_unsigned_char\" \\\n+    \"type = unsigned char\" \\\n+    \"whatis unsigned char\"\n+\n+gdb_test \"whatis v_short\" \\\n+    \"type = (short|short int)\" \\\n+    \"whatis short\"\n+\n+gdb_test \"whatis v_signed_short\" \\\n+    \"type = (short|short int|signed short|signed short int)\" \\\n+    \"whatis signed short\"\n+\n+gdb_test \"whatis v_unsigned_short\" \\\n+    \"type = (unsigned short|short unsigned int)\" \\\n+    \"whatis unsigned short\"\n+\n+gdb_test \"whatis v_int\" \\\n+    \"type = int\" \\\n+    \"whatis int\"\n+\n+gdb_test \"whatis v_signed_int\" \\\n+    \"type = (signed |)int\" \\\n+    \"whatis signed int\"\n+\n+gdb_test \"whatis v_unsigned_int\" \\\n+    \"type = unsigned int\" \\\n+    \"whatis unsigned int\"\n+\n+setup_xfail_on_long_vs_int\n+# AIX xlc gets this wrong and unsigned long right.  Go figure.\n+if {!$gcc_compiled} then {setup_xfail \"rs6000-*-aix*\"}\n+gdb_test \"whatis v_long\" \\\n+    \"type = (long|long int)\" \\\n+    \"whatis long\"\n+\n+setup_xfail_on_long_vs_int\n+# AIX xlc gets this wrong and unsigned long right.  Go figure.\n+if {!$gcc_compiled} then {setup_xfail \"rs6000-*-aix*\"}\n+gdb_test \"whatis v_signed_long\" \\\n+    \"type = (signed |)(long|long int)\" \\\n+    \"whatis signed long\"\n+\n+setup_xfail_on_long_vs_int\n+gdb_test \"whatis v_unsigned_long\" \\\n+    \"type = (unsigned long|long unsigned int)\" \\\n+    \"whatis unsigned long\"\n+\n+\n+if ![target_info exists no_long_long] {\n+    gdb_test \"whatis v_unsigned_long_long\" \\\n+\t\"type = (unsigned long long|long long unsigned int)\" \\\n+\t\"whatis unsigned long long\"\n+}\n+\n+gdb_test \"whatis v_float\" \\\n+    \"type = float\" \\\n+    \"whatis float\"\n+\n+gdb_test \"whatis v_double\" \\\n+    \"type = double\" \\\n+    \"whatis double\"\n+\n+\n+# test whatis command with arrays\n+#\n+# We already tested whether char prints as \"char\", so here we accept\n+# \"unsigned char\", \"signed char\", and other perversions.  No need for more\n+# than one xfail for the same thing.\n+gdb_test \"whatis v_char_array\" \\\n+    \"type = (signed |unsigned |)char \\\\\\[2\\\\\\]\" \\\n+    \"whatis char array\"\n+\n+gdb_test \"whatis v_signed_char_array\" \\\n+    \"type = (signed |unsigned |)char \\\\\\[2\\\\\\]\" \\\n+    \"whatis signed char array\"\n+\n+gdb_test \"whatis v_unsigned_char_array\" \\\n+    \"type = unsigned char \\\\\\[2\\\\\\]\" \\\n+    \"whatis unsigned char array\"\n+\n+gdb_test \"whatis v_short_array\" \\\n+    \"type = (short|short int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis short array\"\n+\n+gdb_test \"whatis v_signed_short_array\" \\\n+    \"type = (signed |)(short|short int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis signed short array\"\n+\n+gdb_test \"whatis v_unsigned_short_array\" \\\n+    \"type = (unsigned short|short unsigned int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis unsigned short array\"\n+\n+gdb_test \"whatis v_int_array\" \\\n+    \"type = int \\\\\\[2\\\\\\]\" \\\n+    \"whatis int array\"\n+\n+gdb_test \"whatis v_signed_int_array\" \\\n+    \"type = (signed |)int \\\\\\[2\\\\\\]\" \\\n+    \"whatis signed int array\"\n+\n+gdb_test \"whatis v_unsigned_int_array\" \\\n+    \"type = unsigned int \\\\\\[2\\\\\\]\" \\\n+    \"whatis unsigned int array\"\n+\n+# We already tested whether long prints as long, so here we accept int\n+# No need for more than one xfail for the same thing.\n+gdb_test \"whatis v_long_array\" \\\n+    \"type = (int|long|long int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis long array\"\n+\n+gdb_test \"whatis v_signed_long_array\" \\\n+    \"type = (signed |)(int|long|long int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis signed long array\"\n+\n+gdb_test \"whatis v_unsigned_long_array\" \\\n+    \"type = (unsigned (int|long|long int)|long unsigned int) \\\\\\[2\\\\\\]\" \\\n+    \"whatis unsigned long array\"\n+\n+if ![target_info exists no_long_long] {\n+    gdb_test \"whatis v_unsigned_long_long_array\" \\\n+\t\"type = (unsigned long long|long long unsigned int) \\\\\\[2\\\\\\]\" \\\n+\t\"whatis unsigned long array\"\n+}\n+\n+gdb_test \"whatis v_float_array\" \\\n+    \"type = float \\\\\\[2\\\\\\]\" \\\n+    \"whatis float array\"\n+\n+gdb_test \"whatis v_double_array\" \\\n+    \"type = double \\\\\\[2\\\\\\]\" \\\n+    \"whatis double array\"\n+\n+\n+# test whatis command with pointers\n+#\n+# We already tested whether char prints as char, so accept various perversions\n+# here.  We especially want to make sure we test that it doesn't print as\n+# caddr_t.\n+gdb_test \"whatis v_char_pointer\" \\\n+    \"type = (unsigned |signed |)char \\\\*\" \\\n+    \"whatis char pointer\"\n+\n+gdb_test \"whatis v_signed_char_pointer\" \\\n+    \"type = (unsigned |signed |)char \\\\*\" \\\n+    \"whatis signed char pointer\"\n+\n+gdb_test \"whatis v_unsigned_char_pointer\" \\\n+    \"type = unsigned char \\\\*\" \\\n+    \"whatis unsigned char pointer\"\n+\n+gdb_test \"whatis v_short_pointer\" \\\n+    \"type = (short|short int) \\\\*\" \\\n+    \"whatis short pointer\"\n+\n+gdb_test \"whatis v_signed_short_pointer\" \\\n+    \"type = (signed |)(short|short int) \\\\*\" \\\n+    \"whatis signed short pointer\"\n+\n+gdb_test \"whatis v_unsigned_short_pointer\" \\\n+    \"type = (unsigned short|short unsigned int) \\\\*\" \\\n+    \"whatis unsigned short pointer\"\n+\n+gdb_test \"whatis v_int_pointer\" \\\n+    \"type = int \\\\*\" \\\n+    \"whatis int pointer\"\n+\n+gdb_test \"whatis v_signed_int_pointer\" \\\n+    \"type = (signed |)int \\\\*\" \\\n+    \"whatis signed int pointer\"\n+\n+gdb_test \"whatis v_unsigned_int_pointer\" \\\n+    \"type = unsigned int \\\\*\" \\\n+    \"whatis unsigned int pointer\"\n+\n+# We already tested whether long prints as long, so here we accept int\n+gdb_test \"whatis v_long_pointer\" \\\n+    \"type = (long|int|long int) \\\\*\" \\\n+    \"whatis long pointer\"\n+\n+gdb_test \"whatis v_signed_long_pointer\" \\\n+    \"type = (signed |)(long|int|long int) \\\\*\" \\\n+    \"whatis signed long pointer\"\n+\n+gdb_test \"whatis v_unsigned_long_pointer\" \\\n+    \"type = (unsigned (int|long|long int)|long unsigned int) \\\\*\" \\\n+    \"whatis unsigned long pointer\"\n+\n+if ![target_info exists no_long_long] {\n+    gdb_test \"whatis v_long_long_pointer\" \\\n+\t\"type = long long(| int) \\\\*\" \\\n+\t\"whatis long long pointer\"\n+\n+    gdb_test \"whatis v_signed_long_long_pointer\" \\\n+\t\"type = (signed |)long long(| int) \\\\*\" \\\n+\t\"whatis signed long long pointer\"\n+\n+    gdb_test \"whatis v_unsigned_long_long_pointer\" \\\n+\t\"type = (unsigned long long|long long unsigned int) \\\\*\" \\\n+\t\"whatis unsigned long long pointer\"\n+}\n+\n+gdb_test \"whatis v_float_pointer\" \\\n+    \"type = float \\\\*\" \\\n+    \"whatis float pointer\"\n+\n+gdb_test \"whatis v_double_pointer\" \\\n+    \"type = double \\\\*\" \\\n+    \"whatis double pointer\"\n+\n+\n+# test whatis command with structure types\n+\n+# First with a type argument, with both \"set print object\" set to \"on\"\n+# and \"off\", ending with \"off\" for the following tests.\n+foreach_with_prefix print_object {\"on\" \"off\"} {\n+    gdb_test_no_output \"set print object $print_object\"\n+\n+    gdb_test \"whatis struct t_struct\" \\\n+\t\"type = struct t_struct\" \\\n+\t\"whatis named structure using type name\"\n+\n+    gdb_test \"whatis struct t_struct *\" \\\n+\t\"type = struct t_struct \\\\*\" \\\n+\t\"whatis named structure using type name and pointer\"\n+\n+    gdb_test \"whatis struct t_struct &\" \\\n+\t\"type = struct t_struct &\" \\\n+\t\"whatis named structure using type name and reference\"\n+}\n+\n+# Now with an expression argument.\n+\n+gdb_test \"whatis v_struct_ptr1\" \\\n+    \"type = struct t_struct \\\\*\"\n+\n+gdb_test \"whatis &v_struct_ptr1\" \\\n+    \"type = struct t_struct \\\\*\\\\*\"\n+\n+gdb_test \"whatis v_struct_ptr1->v_char_member\" \\\n+    \"type = char\"\n+\n+gdb_test \"whatis v_struct_ptr2->v_char_member\" \\\n+    \"type = char\"\n+\n+gdb_test \"whatis &(v_struct_ptr1->v_char_member)\" \\\n+    \"type = char \\\\*\"\n+\n+gdb_test \"whatis &(v_struct_ptr2->v_char_member)\" \\\n+    \"type = char \\\\*\"\n+\n+# test whatis command with union types\n+\n+gdb_test \"whatis union t_union\" \\\n+    \"type = union t_union\" \\\n+    \"whatis named union using type name\"\n+\n+gdb_test \"whatis v_union_ptr\" \\\n+    \"type = union t_union \\\\*\"\n+\n+gdb_test \"whatis &v_union_ptr\" \\\n+    \"type = union t_union \\\\*\\\\*\"\n+\n+gdb_test \"whatis v_union_ptr->v_char_member\" \\\n+    \"type = char\"\n+\n+gdb_test \"whatis v_union_ptr2->v_char_member\" \\\n+    \"type = char\"\n+\n+gdb_test \"whatis &(v_union_ptr->v_char_member)\" \\\n+    \"type = char \\\\*\"\n+\n+gdb_test \"whatis &(v_union_ptr2->v_char_member)\" \\\n+    \"type = char \\\\*\"\n+\n+# test whatis command with nested struct and union\n+gdb_test \"whatis nested_su\" \\\n+    \"type = struct outer_struct\" \\\n+    \"whatis outer structure\"\n+\n+gdb_test \"whatis nested_su.outer_int\" \\\n+    \"type = int\" \\\n+    \"whatis outer structure member\"\n+\n+gdb_test \"whatis nested_su.inner_struct_instance\" \\\n+    \"type = struct inner_struct\" \\\n+    \"whatis inner structure\"\n+\n+gdb_test \"whatis nested_su.inner_struct_instance.inner_int\" \\\n+    \"type = int\" \\\n+    \"whatis inner structure member\"\n+\n+gdb_test \"whatis nested_su.inner_union_instance\" \\\n+    \"type = union inner_union\" \\\n+    \"whatis inner union\"\n+\n+gdb_test \"whatis nested_su.inner_union_instance.inner_union_int\" \\\n+    \"type = int\" \\\n+    \"whatis inner union member\"\n+\n+# Using stabs we will mark these functions as prototyped.  This\n+# is harmless but causes an extra VOID to be printed.\n+set void \"(void|)\"\n+\n+# Regression tests for PR 9514.\n+\n+gdb_test \"whatis void (**)()\" \\\n+  \"type = void \\\\(\\\\*\\\\*\\\\)\\\\(\\\\)\" \\\n+  \"whatis applied to pointer to pointer to function\"\n+\n+gdb_test \"whatis void (** const)()\" \\\n+  \"type = void \\\\(\\\\*\\\\* const\\\\)\\\\(\\\\)\" \\\n+  \"whatis applied to const pointer to pointer to function\"\n+\n+gdb_test \"whatis void (* const *)()\" \\\n+  \"type = void \\\\(\\\\* const \\\\*\\\\)\\\\(\\\\)\" \\\n+  \"whatis applied to pointer to const pointer to function\"\n+\n+gdb_test \"whatis int *(*)()\" \\\n+    \"type = int \\\\*\\\\(\\\\*\\\\)\\\\(\\\\)\" \\\n+    \"whatis applied to pointer to function returning pointer to int\"\n+\n+gdb_test \"whatis int *(**)()\" \\\n+    \"type = int \\\\*\\\\(\\\\*\\\\*\\\\)\\\\(\\\\)\" \\\n+    \"whatis applied to pointer to pointer to function returning pointer to int\"\n+\n+gdb_test \"whatis char (*(*)())\\[23\\]\" \\\n+    \"type = char \\\\(\\\\*\\\\(\\\\*\\\\)\\\\(\\\\)\\\\)\\\\\\[23\\\\\\]\" \\\n+    \"whatis applied to pointer to function returning pointer to array\"\n+\n+gdb_test \"whatis int (*)(int, int)\" \\\n+    \"type = int \\\\(\\\\*\\\\)\\\\(int, int\\\\)\" \\\n+    \"whatis applied to pointer to function taking int,int and returning int\"\n+\n+gdb_test \"whatis int (*)(const int *, ...)\" \\\n+    \"type = int \\\\(\\\\*\\\\)\\\\(const int \\\\*, \\\\.\\\\.\\\\.\\\\)\" \\\n+    \"whatis applied to pointer to function taking const int ptr and varargs and returning int\"\n+\n+gdb_test \"whatis int (*)(void, int, int)\" \\\n+    \"parameter types following 'void'\" \\\n+    \"whatis applied to function with types trailing 'void'\"\n+\n+gdb_test \"whatis int (*)(int, void, int)\" \\\n+    \"'void' invalid as parameter type\" \\\n+    \"whatis applied to function with 'void' parameter type\""
    }
  ]
}