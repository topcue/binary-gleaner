{
  "sha": "7d186bc04245c5757f396c2d4f8f89f24818628e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2QxODZiYzA0MjQ1YzU3NTdmMzk2YzJkNGY4Zjg5ZjI0ODE4NjI4ZQ==",
  "commit": {
    "author": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-04-24T15:23:59Z"
    },
    "committer": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-04-30T16:30:20Z"
    },
    "message": "Implement debugging of WOW64 processes in gdbserver\n\ngdbserver/ChangeLog:\n\n2020-04-30  Hannes Domani  <ssbssa@yahoo.de>\n\n\t* configure.srv <x86_64-*-mingw*, x86_64-*-cygwin*> (srv_tgtobj):\n\tAdd arch/i386.o.\n\t* win32-arm-low.cc (arm_num_regs): New function.\n\t(struct win32_target_ops): Use arm_num_regs.\n\t* win32-i386-low.cc (win32_get_current_dr): Adapt for WOW64\n\tprocesses.\n\t(i386_get_thread_context): Likewise.\n\t(i386_prepare_to_resume): Likewise.\n\t(i386_thread_added): Likewise.\n\t(i386_single_step): Likewise.\n\t(i386_fetch_inferior_register): Likewise.\n\t(i386_store_inferior_register): Likewise.\n\t(i386_arch_setup): Likewise.\n\t(i386_win32_num_regs): New function.\n\t(struct win32_target_ops): Use i386_win32_num_regs.\n\t* win32-low.cc (win32_get_thread_context): Adapt for WOW64\n\tprocesses.\n\t(win32_require_context): Likewise.\n\t(child_add_thread): Likewise.\n\t(do_initial_child_stuff): Likewise.\n\t(continue_one_thread): Likewise.\n\t(win32_process_target::resume): Likewise.\n\t(load_psapi): Likewise.\n\t(win32_add_all_dlls): Likewise.\n\t(maybe_adjust_pc): Likewise.\n\t(win32_process_target::qxfer_siginfo): Likewise.\n\t(initialize_low): Likewise.\n\t* win32-low.h (struct win32_target_ops): Change num_regs to\n\tcallback function.",
    "tree": {
      "sha": "cd43bdbf890d076a6a2a8889c0be130e30e8d3e9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cd43bdbf890d076a6a2a8889c0be130e30e8d3e9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7d186bc04245c5757f396c2d4f8f89f24818628e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d186bc04245c5757f396c2d4f8f89f24818628e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7d186bc04245c5757f396c2d4f8f89f24818628e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d186bc04245c5757f396c2d4f8f89f24818628e/comments",
  "author": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ee9d1e5f76033cd8432713a76381ade76697df04",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ee9d1e5f76033cd8432713a76381ade76697df04",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ee9d1e5f76033cd8432713a76381ade76697df04"
    }
  ],
  "stats": {
    "total": 466,
    "additions": 404,
    "deletions": 62
  },
  "files": [
    {
      "sha": "4853463d05d30a28e53d407f1e16595d8d1bfe91",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -1,3 +1,35 @@\n+2020-04-30  Hannes Domani  <ssbssa@yahoo.de>\n+\n+\t* configure.srv <x86_64-*-mingw*, x86_64-*-cygwin*> (srv_tgtobj):\n+\tAdd arch/i386.o.\n+\t* win32-arm-low.cc (arm_num_regs): New function.\n+\t(struct win32_target_ops): Use arm_num_regs.\n+\t* win32-i386-low.cc (win32_get_current_dr): Adapt for WOW64\n+\tprocesses.\n+\t(i386_get_thread_context): Likewise.\n+\t(i386_prepare_to_resume): Likewise.\n+\t(i386_thread_added): Likewise.\n+\t(i386_single_step): Likewise.\n+\t(i386_fetch_inferior_register): Likewise.\n+\t(i386_store_inferior_register): Likewise.\n+\t(i386_arch_setup): Likewise.\n+\t(i386_win32_num_regs): New function.\n+\t(struct win32_target_ops): Use i386_win32_num_regs.\n+\t* win32-low.cc (win32_get_thread_context): Adapt for WOW64\n+\tprocesses.\n+\t(win32_require_context): Likewise.\n+\t(child_add_thread): Likewise.\n+\t(do_initial_child_stuff): Likewise.\n+\t(continue_one_thread): Likewise.\n+\t(win32_process_target::resume): Likewise.\n+\t(load_psapi): Likewise.\n+\t(win32_add_all_dlls): Likewise.\n+\t(maybe_adjust_pc): Likewise.\n+\t(win32_process_target::qxfer_siginfo): Likewise.\n+\t(initialize_low): Likewise.\n+\t* win32-low.h (struct win32_target_ops): Change num_regs to\n+\tcallback function.\n+\n 2020-04-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* configure.ac: Remove check for fs_base/gs_base in"
    },
    {
      "sha": "9a027e44af60010d784f77b12ff7a5d356e09a3d",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -397,14 +397,14 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_tgtobj=\"x86-low.o nat/x86-dregs.o i387-fp.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} win32-low.o win32-i386-low.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/windows-nat.o\"\n-\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o\"\n+\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o arch/i386.o\"\n \t\t\tsrv_mingw=yes\n \t\t\t;;\n   x86_64-*-cygwin*)\tsrv_regobj=\"\"\n \t\t\tsrv_tgtobj=\"x86-low.o nat/x86-dregs.o i387-fp.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} win32-low.o win32-i386-low.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/windows-nat.o\"\n-\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o\"\n+\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/amd64.o arch/i386.o\"\n \t\t\t;;\n \n   xtensa*-*-linux*)\tsrv_regobj=reg-xtensa.o"
    },
    {
      "sha": "aacf2cdf8cd37203af010df5432f43b393f511d0",
      "filename": "gdbserver/win32-arm-low.cc",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-arm-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-arm-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-arm-low.cc?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -111,6 +111,14 @@ arm_arch_setup (void)\n   win32_tdesc = tdesc_arm;\n }\n \n+/* Implement win32_target_ops \"num_regs\" method.  */\n+\n+static int\n+arm_num_regs (void)\n+{\n+  return sizeof (mappings) / sizeof (mappings[0]),\n+}\n+\n /* Correct in either endianness.  We do not support Thumb yet.  */\n static const unsigned long arm_wince_breakpoint = 0xe6000010;\n #define arm_wince_breakpoint_len 4\n@@ -138,7 +146,7 @@ arm_win32_set_pc (struct regcache *regcache, CORE_ADDR pc)\n \n struct win32_target_ops the_low_target = {\n   arm_arch_setup,\n-  sizeof (mappings) / sizeof (mappings[0]),\n+  arm_num_regs,\n   NULL, /* initial_stuff */\n   arm_get_thread_context,\n   NULL, /* prepare_to_resume */"
    },
    {
      "sha": "389ec4928478d61371d547940502f5f387eb99ef",
      "filename": "gdbserver/win32-i386-low.cc",
      "status": "modified",
      "additions": 138,
      "deletions": 33,
      "changes": 171,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-i386-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-i386-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-i386-low.cc?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -80,18 +80,40 @@ win32_get_current_dr (int dr)\n \n   win32_require_context (th);\n \n+#ifdef __x86_64__\n+#define RET_DR(DR)\t\t\t\t\\\n+  case DR:\t\t\t\t\t\\\n+    return th->wow64_context.Dr ## DR\n+\n+  if (wow64_process)\n+    {\n+      switch (dr)\n+\t{\n+\t  RET_DR (0);\n+\t  RET_DR (1);\n+\t  RET_DR (2);\n+\t  RET_DR (3);\n+\t  RET_DR (6);\n+\t  RET_DR (7);\n+\t}\n+    }\n+  else\n+#undef RET_DR\n+#endif\n #define RET_DR(DR)\t\t\t\t\\\n   case DR:\t\t\t\t\t\\\n     return th->context.Dr ## DR\n \n-  switch (dr)\n     {\n-      RET_DR (0);\n-      RET_DR (1);\n-      RET_DR (2);\n-      RET_DR (3);\n-      RET_DR (6);\n-      RET_DR (7);\n+      switch (dr)\n+\t{\n+\t  RET_DR (0);\n+\t  RET_DR (1);\n+\t  RET_DR (2);\n+\t  RET_DR (3);\n+\t  RET_DR (6);\n+\t  RET_DR (7);\n+\t}\n     }\n \n #undef RET_DR\n@@ -219,12 +241,27 @@ i386_get_thread_context (windows_thread_info *th)\n   static DWORD extended_registers = CONTEXT_EXTENDED_REGISTERS;\n \n  again:\n-  th->context.ContextFlags = (CONTEXT_FULL\n-\t\t\t      | CONTEXT_FLOATING_POINT\n-\t\t\t      | CONTEXT_DEBUG_REGISTERS\n-\t\t\t      | extended_registers);\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    th->wow64_context.ContextFlags = (CONTEXT_FULL\n+\t\t\t\t      | CONTEXT_FLOATING_POINT\n+\t\t\t\t      | CONTEXT_DEBUG_REGISTERS\n+\t\t\t\t      | extended_registers);\n+  else\n+#endif\n+    th->context.ContextFlags = (CONTEXT_FULL\n+\t\t\t\t| CONTEXT_FLOATING_POINT\n+\t\t\t\t| CONTEXT_DEBUG_REGISTERS\n+\t\t\t\t| extended_registers);\n \n-  if (!GetThreadContext (th->h, &th->context))\n+  BOOL ret;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    ret = win32_Wow64GetThreadContext (th->h, &th->wow64_context);\n+  else\n+#endif\n+    ret = GetThreadContext (th->h, &th->context);\n+  if (!ret)\n     {\n       DWORD e = GetLastError ();\n \n@@ -247,13 +284,28 @@ i386_prepare_to_resume (windows_thread_info *th)\n \n       win32_require_context (th);\n \n-      th->context.Dr0 = dr->dr_mirror[0];\n-      th->context.Dr1 = dr->dr_mirror[1];\n-      th->context.Dr2 = dr->dr_mirror[2];\n-      th->context.Dr3 = dr->dr_mirror[3];\n-      /* th->context.Dr6 = dr->dr_status_mirror;\n-\t FIXME: should we set dr6 also ?? */\n-      th->context.Dr7 = dr->dr_control_mirror;\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\t{\n+\t  th->wow64_context.Dr0 = dr->dr_mirror[0];\n+\t  th->wow64_context.Dr1 = dr->dr_mirror[1];\n+\t  th->wow64_context.Dr2 = dr->dr_mirror[2];\n+\t  th->wow64_context.Dr3 = dr->dr_mirror[3];\n+\t  /* th->wow64_context.Dr6 = dr->dr_status_mirror;\n+\t     FIXME: should we set dr6 also ?? */\n+\t  th->wow64_context.Dr7 = dr->dr_control_mirror;\n+\t}\n+      else\n+#endif\n+\t{\n+\t  th->context.Dr0 = dr->dr_mirror[0];\n+\t  th->context.Dr1 = dr->dr_mirror[1];\n+\t  th->context.Dr2 = dr->dr_mirror[2];\n+\t  th->context.Dr3 = dr->dr_mirror[3];\n+\t  /* th->context.Dr6 = dr->dr_status_mirror;\n+\t     FIXME: should we set dr6 also ?? */\n+\t  th->context.Dr7 = dr->dr_control_mirror;\n+\t}\n \n       th->debug_registers_changed = false;\n     }\n@@ -268,20 +320,27 @@ i386_thread_added (windows_thread_info *th)\n static void\n i386_single_step (windows_thread_info *th)\n {\n-  th->context.EFlags |= FLAG_TRACE_BIT;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    th->wow64_context.EFlags |= FLAG_TRACE_BIT;\n+  else\n+#endif\n+    th->context.EFlags |= FLAG_TRACE_BIT;\n }\n \n-#ifndef __x86_64__\n-\n /* An array of offset mappings into a Win32 Context structure.\n    This is a one-to-one mapping which is indexed by gdb's register\n    numbers.  It retrieves an offset into the context structure where\n    the 4 byte register is located.\n    An offset value of -1 indicates that Win32 does not provide this\n    register in it's CONTEXT structure.  In this case regptr will return\n    a pointer into a dummy register.  */\n+#ifdef __x86_64__\n+#define context_offset(x) (offsetof (WOW64_CONTEXT, x))\n+#else\n #define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))\n-static const int mappings[] = {\n+#endif\n+static const int i386_mappings[] = {\n   context_offset (Eax),\n   context_offset (Ecx),\n   context_offset (Edx),\n@@ -328,10 +387,10 @@ static const int mappings[] = {\n };\n #undef context_offset\n \n-#else /* __x86_64__ */\n+#ifdef __x86_64__\n \n #define context_offset(x) (offsetof (CONTEXT, x))\n-static const int mappings[] =\n+static const int amd64_mappings[] =\n {\n   context_offset (Rax),\n   context_offset (Rbx),\n@@ -402,7 +461,21 @@ static void\n i386_fetch_inferior_register (struct regcache *regcache,\n \t\t\t      windows_thread_info *th, int r)\n {\n-  char *context_offset = (char *) &th->context + mappings[r];\n+  const int *mappings;\n+#ifdef __x86_64__\n+  if (!wow64_process)\n+    mappings = amd64_mappings;\n+  else\n+#endif\n+    mappings = i386_mappings;\n+\n+  char *context_offset;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    context_offset = (char *) &th->wow64_context + mappings[r];\n+  else\n+#endif\n+    context_offset = (char *) &th->context + mappings[r];\n \n   long l;\n   if (r == FCS_REGNUM)\n@@ -424,7 +497,22 @@ static void\n i386_store_inferior_register (struct regcache *regcache,\n \t\t\t      windows_thread_info *th, int r)\n {\n-  char *context_offset = (char *) &th->context + mappings[r];\n+  const int *mappings;\n+#ifdef __x86_64__\n+  if (!wow64_process)\n+    mappings = amd64_mappings;\n+  else\n+#endif\n+    mappings = i386_mappings;\n+\n+  char *context_offset;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    context_offset = (char *) &th->wow64_context + mappings[r];\n+  else\n+#endif\n+    context_offset = (char *) &th->context + mappings[r];\n+\n   collect_register (regcache, r, context_offset);\n }\n \n@@ -439,15 +527,32 @@ i386_arch_setup (void)\n #ifdef __x86_64__\n   tdesc = amd64_create_target_description (X86_XSTATE_SSE_MASK, false,\n \t\t\t\t\t   false, false);\n-  const char **expedite_regs = amd64_expedite_regs;\n-#else\n+  init_target_desc (tdesc, amd64_expedite_regs);\n+  win32_tdesc = tdesc;\n+#endif\n+\n   tdesc = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);\n-  const char **expedite_regs = i386_expedite_regs;\n+  init_target_desc (tdesc, i386_expedite_regs);\n+#ifdef __x86_64__\n+  wow64_win32_tdesc = tdesc;\n+#else\n+  win32_tdesc = tdesc;\n #endif\n+}\n \n-  init_target_desc (tdesc, expedite_regs);\n+/* Implement win32_target_ops \"num_regs\" method.  */\n \n-  win32_tdesc = tdesc;\n+static int\n+i386_win32_num_regs (void)\n+{\n+  int num_regs;\n+#ifdef __x86_64__\n+  if (!wow64_process)\n+    num_regs = sizeof (amd64_mappings) / sizeof (amd64_mappings[0]);\n+  else\n+#endif\n+    num_regs = sizeof (i386_mappings) / sizeof (i386_mappings[0]);\n+  return num_regs;\n }\n \n /* Implement win32_target_ops \"get_pc\" method.  */\n@@ -496,7 +601,7 @@ i386_win32_set_pc (struct regcache *regcache, CORE_ADDR pc)\n \n struct win32_target_ops the_low_target = {\n   i386_arch_setup,\n-  sizeof (mappings) / sizeof (mappings[0]),\n+  i386_win32_num_regs,\n   i386_initial_stuff,\n   i386_get_thread_context,\n   i386_prepare_to_resume,"
    },
    {
      "sha": "4eb63b7ca25ad1e875c9cc80cfeecf7bffce8336",
      "filename": "gdbserver/win32-low.cc",
      "status": "modified",
      "additions": 214,
      "deletions": 25,
      "changes": 239,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.cc?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -88,15 +88,30 @@ static int soft_interrupt_requested = 0;\n    by suspending all the threads.  */\n static int faked_breakpoint = 0;\n \n+#ifdef __x86_64__\n+bool wow64_process = false;\n+#endif\n+\n const struct target_desc *win32_tdesc;\n+#ifdef __x86_64__\n+const struct target_desc *wow64_win32_tdesc;\n+#endif\n \n-#define NUM_REGS (the_low_target.num_regs)\n+#define NUM_REGS (the_low_target.num_regs ())\n \n typedef BOOL (WINAPI *winapi_DebugActiveProcessStop) (DWORD dwProcessId);\n typedef BOOL (WINAPI *winapi_DebugSetProcessKillOnExit) (BOOL KillOnExit);\n typedef BOOL (WINAPI *winapi_DebugBreakProcess) (HANDLE);\n typedef BOOL (WINAPI *winapi_GenerateConsoleCtrlEvent) (DWORD, DWORD);\n \n+#ifdef __x86_64__\n+typedef BOOL (WINAPI *winapi_Wow64SetThreadContext) (HANDLE,\n+\t\t\t\t\t\t     const WOW64_CONTEXT *);\n+\n+winapi_Wow64GetThreadContext win32_Wow64GetThreadContext;\n+static winapi_Wow64SetThreadContext win32_Wow64SetThreadContext;\n+#endif\n+\n #ifndef _WIN32_WCE\n static void win32_add_all_dlls (void);\n #endif\n@@ -121,7 +136,12 @@ debug_event_ptid (DEBUG_EVENT *event)\n static void\n win32_get_thread_context (windows_thread_info *th)\n {\n-  memset (&th->context, 0, sizeof (CONTEXT));\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    memset (&th->wow64_context, 0, sizeof (WOW64_CONTEXT));\n+  else\n+#endif\n+    memset (&th->context, 0, sizeof (CONTEXT));\n   (*the_low_target.get_thread_context) (th);\n #ifdef _WIN32_WCE\n   memcpy (&th->base_context, &th->context, sizeof (CONTEXT));\n@@ -146,7 +166,14 @@ win32_set_thread_context (windows_thread_info *th)\n      it between stopping and resuming.  */\n   if (memcmp (&th->context, &th->base_context, sizeof (CONTEXT)) != 0)\n #endif\n-    SetThreadContext (th->h, &th->context);\n+    {\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\twin32_Wow64SetThreadContext (th->h, &th->wow64_context);\n+      else\n+#endif\n+\tSetThreadContext (th->h, &th->context);\n+    }\n }\n \n /* Set the thread context of the thread associated with TH.  */\n@@ -163,7 +190,14 @@ win32_prepare_to_resume (windows_thread_info *th)\n void\n win32_require_context (windows_thread_info *th)\n {\n-  if (th->context.ContextFlags == 0)\n+  DWORD context_flags;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    context_flags = th->wow64_context.ContextFlags;\n+  else\n+#endif\n+    context_flags = th->context.ContextFlags;\n+  if (context_flags == 0)\n     {\n       th->suspend ();\n       win32_get_thread_context (th);\n@@ -195,7 +229,14 @@ child_add_thread (DWORD pid, DWORD tid, HANDLE h, void *tlb)\n   if ((th = thread_rec (ptid, DONT_INVALIDATE_CONTEXT)))\n     return th;\n \n-  th = new windows_thread_info (tid, h, (CORE_ADDR) (uintptr_t) tlb);\n+  CORE_ADDR base = (CORE_ADDR) (uintptr_t) tlb;\n+#ifdef __x86_64__\n+  /* For WOW64 processes, this is actually the pointer to the 64bit TIB,\n+     and the 32bit TIB is exactly 2 pages after it.  */\n+  if (wow64_process)\n+    base += 2 * 4096; /* page size = 4096 */\n+#endif\n+  th = new windows_thread_info (tid, h, base);\n \n   add_thread (ptid, th);\n \n@@ -345,8 +386,31 @@ do_initial_child_stuff (HANDLE proch, DWORD pid, int attached)\n \n   memset (&current_event, 0, sizeof (current_event));\n \n+#ifdef __x86_64__\n+  BOOL wow64;\n+  if (!IsWow64Process (proch, &wow64))\n+    {\n+      DWORD err = GetLastError ();\n+      error (\"Check if WOW64 process failed (error %d): %s\\n\",\n+\t     (int) err, strwinerror (err));\n+    }\n+  wow64_process = wow64;\n+\n+  if (wow64_process\n+      && (win32_Wow64GetThreadContext == nullptr\n+\t  || win32_Wow64SetThreadContext == nullptr))\n+    error (\"WOW64 debugging is not supported on this system.\\n\");\n+\n+  ignore_first_breakpoint = !attached && wow64_process;\n+#endif\n+\n   proc = add_process (pid, attached);\n-  proc->tdesc = win32_tdesc;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    proc->tdesc = wow64_win32_tdesc;\n+  else\n+#endif\n+    proc->tdesc = win32_tdesc;\n   child_init_thread_list ();\n   child_initialization_done = 0;\n \n@@ -416,10 +480,17 @@ continue_one_thread (thread_info *thread, int thread_id)\n \n       if (th->suspended)\n \t{\n-\t  if (th->context.ContextFlags)\n+\t  DWORD *context_flags;\n+#ifdef __x86_64__\n+\t  if (wow64_process)\n+\t    context_flags = &th->wow64_context.ContextFlags;\n+\t  else\n+#endif\n+\t    context_flags = &th->context.ContextFlags;\n+\t  if (*context_flags)\n \t    {\n \t      win32_set_thread_context (th);\n-\t      th->context.ContextFlags = 0;\n+\t      *context_flags = 0;\n \t    }\n \n \t  th->resume ();\n@@ -943,7 +1014,14 @@ win32_process_target::resume (thread_resume *resume_info, size_t n)\n     {\n       win32_prepare_to_resume (th);\n \n-      if (th->context.ContextFlags)\n+      DWORD *context_flags;\n+#ifdef __x86_64__\n+      if (wow64_process)\n+\tcontext_flags = &th->wow64_context.ContextFlags;\n+      else\n+#endif\n+\tcontext_flags = &th->context.ContextFlags;\n+      if (*context_flags)\n \t{\n \t  /* Move register values from the inferior into the thread\n \t     context structure.  */\n@@ -959,7 +1037,7 @@ win32_process_target::resume (thread_resume *resume_info, size_t n)\n \t    }\n \n \t  win32_set_thread_context (th);\n-\t  th->context.ContextFlags = 0;\n+\t  *context_flags = 0;\n \t}\n     }\n \n@@ -1032,12 +1110,19 @@ win32_add_one_solib (const char *name, CORE_ADDR load_addr)\n \n typedef BOOL (WINAPI *winapi_EnumProcessModules) (HANDLE, HMODULE *,\n \t\t\t\t\t\t  DWORD, LPDWORD);\n+#ifdef __x86_64__\n+typedef BOOL (WINAPI *winapi_EnumProcessModulesEx) (HANDLE, HMODULE *, DWORD,\n+\t\t\t\t\t\t    LPDWORD, DWORD);\n+#endif\n typedef BOOL (WINAPI *winapi_GetModuleInformation) (HANDLE, HMODULE,\n \t\t\t\t\t\t    LPMODULEINFO, DWORD);\n typedef DWORD (WINAPI *winapi_GetModuleFileNameExA) (HANDLE, HMODULE,\n \t\t\t\t\t\t     LPSTR, DWORD);\n \n static winapi_EnumProcessModules win32_EnumProcessModules;\n+#ifdef __x86_64__\n+static winapi_EnumProcessModulesEx win32_EnumProcessModulesEx;\n+#endif\n static winapi_GetModuleInformation win32_GetModuleInformation;\n static winapi_GetModuleFileNameExA win32_GetModuleFileNameExA;\n \n@@ -1055,12 +1140,21 @@ load_psapi (void)\n \treturn FALSE;\n       win32_EnumProcessModules =\n \t      GETPROCADDRESS (dll, EnumProcessModules);\n+#ifdef __x86_64__\n+      win32_EnumProcessModulesEx =\n+\t      GETPROCADDRESS (dll, EnumProcessModulesEx);\n+#endif\n       win32_GetModuleInformation =\n \t      GETPROCADDRESS (dll, GetModuleInformation);\n       win32_GetModuleFileNameExA =\n \t      GETPROCADDRESS (dll, GetModuleFileNameExA);\n     }\n \n+#ifdef __x86_64__\n+  if (wow64_process && win32_EnumProcessModulesEx == nullptr)\n+    return FALSE;\n+#endif\n+\n   return (win32_EnumProcessModules != NULL\n \t  && win32_GetModuleInformation != NULL\n \t  && win32_GetModuleFileNameExA != NULL);\n@@ -1084,10 +1178,19 @@ win32_add_all_dlls (void)\n     return;\n \n   cbNeeded = 0;\n-  ok = (*win32_EnumProcessModules) (current_process_handle,\n-\t\t\t\t    DllHandle,\n-\t\t\t\t    sizeof (HMODULE),\n-\t\t\t\t    &cbNeeded);\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    ok = (*win32_EnumProcessModulesEx) (current_process_handle,\n+\t\t\t\t\tDllHandle,\n+\t\t\t\t\tsizeof (HMODULE),\n+\t\t\t\t\t&cbNeeded,\n+\t\t\t\t\tLIST_MODULES_32BIT);\n+  else\n+#endif\n+    ok = (*win32_EnumProcessModules) (current_process_handle,\n+\t\t\t\t      DllHandle,\n+\t\t\t\t      sizeof (HMODULE),\n+\t\t\t\t      &cbNeeded);\n \n   if (!ok || !cbNeeded)\n     return;\n@@ -1096,13 +1199,53 @@ win32_add_all_dlls (void)\n   if (!DllHandle)\n     return;\n \n-  ok = (*win32_EnumProcessModules) (current_process_handle,\n-\t\t\t\t    DllHandle,\n-\t\t\t\t    cbNeeded,\n-\t\t\t\t    &cbNeeded);\n+#ifdef __x86_64__\n+  if (wow64_process)\n+    ok = (*win32_EnumProcessModulesEx) (current_process_handle,\n+\t\t\t\t\tDllHandle,\n+\t\t\t\t\tcbNeeded,\n+\t\t\t\t\t&cbNeeded,\n+\t\t\t\t\tLIST_MODULES_32BIT);\n+  else\n+#endif\n+    ok = (*win32_EnumProcessModules) (current_process_handle,\n+\t\t\t\t      DllHandle,\n+\t\t\t\t      cbNeeded,\n+\t\t\t\t      &cbNeeded);\n   if (!ok)\n     return;\n \n+  char system_dir[MAX_PATH];\n+  char syswow_dir[MAX_PATH];\n+  size_t system_dir_len = 0;\n+  bool convert_syswow_dir = false;\n+#ifdef __x86_64__\n+  if (wow64_process)\n+#endif\n+    {\n+      /* This fails on 32bit Windows because it has no SysWOW64 directory,\n+\t and in this case a path conversion isn't necessary.  */\n+      UINT len = GetSystemWow64DirectoryA (syswow_dir, sizeof (syswow_dir));\n+      if (len > 0)\n+\t{\n+\t  /* Check that we have passed a large enough buffer.  */\n+\t  gdb_assert (len < sizeof (syswow_dir));\n+\n+\t  len = GetSystemDirectoryA (system_dir, sizeof (system_dir));\n+\t  /* Error check.  */\n+\t  gdb_assert (len != 0);\n+\t  /* Check that we have passed a large enough buffer.  */\n+\t  gdb_assert (len < sizeof (system_dir));\n+\n+\t  strcat (system_dir, \"\\\\\");\n+\t  strcat (syswow_dir, \"\\\\\");\n+\t  system_dir_len = strlen (system_dir);\n+\n+\t  convert_syswow_dir = true;\n+\t}\n+\n+    }\n+\n   for (i = 1; i < ((size_t) cbNeeded / sizeof (HMODULE)); i++)\n     {\n       MODULEINFO mi;\n@@ -1118,7 +1261,22 @@ win32_add_all_dlls (void)\n \t\t\t\t\t dll_name,\n \t\t\t\t\t MAX_PATH) == 0)\n \tcontinue;\n-      win32_add_one_solib (dll_name, (CORE_ADDR) (uintptr_t) mi.lpBaseOfDll);\n+\n+      const char *name = dll_name;\n+      /* Convert the DLL path of 32bit processes returned by\n+\t GetModuleFileNameEx from the 64bit system directory to the\n+\t 32bit syswow64 directory if necessary.  */\n+      std::string syswow_dll_path;\n+      if (convert_syswow_dir\n+\t  && strncasecmp (dll_name, system_dir, system_dir_len) == 0\n+\t  && strchr (dll_name + system_dir_len, '\\\\') == nullptr)\n+\t{\n+\t  syswow_dll_path = syswow_dir;\n+\t  syswow_dll_path += dll_name + system_dir_len;\n+\t  name = syswow_dll_path.c_str();\n+\t}\n+\n+      win32_add_one_solib (name, (CORE_ADDR) (uintptr_t) mi.lpBaseOfDll);\n     }\n }\n #endif\n@@ -1221,8 +1379,10 @@ maybe_adjust_pc ()\n   th->stopped_at_software_breakpoint = false;\n \n   if (current_event.dwDebugEventCode == EXCEPTION_DEBUG_EVENT\n-      && (current_event.u.Exception.ExceptionRecord.ExceptionCode\n-\t  == EXCEPTION_BREAKPOINT)\n+      && ((current_event.u.Exception.ExceptionRecord.ExceptionCode\n+\t   == EXCEPTION_BREAKPOINT)\n+\t  || (current_event.u.Exception.ExceptionRecord.ExceptionCode\n+\t      == STATUS_WX86_BREAKPOINT))\n       && child_initialization_done)\n     {\n       th->stopped_at_software_breakpoint = true;\n@@ -1684,13 +1844,34 @@ win32_process_target::qxfer_siginfo (const char *annex,\n   if (readbuf == nullptr)\n     return -1;\n \n-  if (offset > sizeof (siginfo_er))\n+  char *buf = (char *) &siginfo_er;\n+  size_t bufsize = sizeof (siginfo_er);\n+\n+#ifdef __x86_64__\n+  EXCEPTION_RECORD32 er32;\n+  if (wow64_process)\n+    {\n+      buf = (char *) &er32;\n+      bufsize = sizeof (er32);\n+\n+      er32.ExceptionCode = siginfo_er.ExceptionCode;\n+      er32.ExceptionFlags = siginfo_er.ExceptionFlags;\n+      er32.ExceptionRecord = (uintptr_t) siginfo_er.ExceptionRecord;\n+      er32.ExceptionAddress = (uintptr_t) siginfo_er.ExceptionAddress;\n+      er32.NumberParameters = siginfo_er.NumberParameters;\n+      int i;\n+      for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++)\n+\ter32.ExceptionInformation[i] = siginfo_er.ExceptionInformation[i];\n+    }\n+#endif\n+\n+  if (offset > bufsize)\n     return -1;\n \n-  if (offset + len > sizeof (siginfo_er))\n-    len = sizeof (siginfo_er) - offset;\n+  if (offset + len > bufsize)\n+    len = bufsize - offset;\n \n-  memcpy (readbuf, (char *) &siginfo_er + offset, len);\n+  memcpy (readbuf, buf + offset, len);\n \n   return len;\n }\n@@ -1760,4 +1941,12 @@ initialize_low (void)\n {\n   set_target_ops (&the_win32_target);\n   the_low_target.arch_setup ();\n+\n+#ifdef __x86_64__\n+  /* These functions are loaded dynamically, because they are not available\n+     on Windows XP.  */\n+  HMODULE dll = GetModuleHandle (_T(\"KERNEL32.DLL\"));\n+  win32_Wow64GetThreadContext = GETPROCADDRESS (dll, Wow64GetThreadContext);\n+  win32_Wow64SetThreadContext = GETPROCADDRESS (dll, Wow64SetThreadContext);\n+#endif\n }"
    },
    {
      "sha": "a023eb1f839418f62c5438eb3b182172777335be",
      "filename": "gdbserver/win32-low.h",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d186bc04245c5757f396c2d4f8f89f24818628e/gdbserver/win32-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.h?ref=7d186bc04245c5757f396c2d4f8f89f24818628e",
      "patch": "@@ -27,14 +27,22 @@ struct target_desc;\n /* The inferior's target description.  This is a global because the\n    Windows ports support neither bi-arch nor multi-process.  */\n extern const struct target_desc *win32_tdesc;\n+#ifdef __x86_64__\n+extern const struct target_desc *wow64_win32_tdesc;\n+\n+extern bool wow64_process;\n+\n+typedef BOOL (WINAPI *winapi_Wow64GetThreadContext) (HANDLE, PWOW64_CONTEXT);\n+extern winapi_Wow64GetThreadContext win32_Wow64GetThreadContext;\n+#endif\n \n struct win32_target_ops\n {\n   /* Architecture-specific setup.  */\n   void (*arch_setup) (void);\n \n   /* The number of target registers.  */\n-  int num_regs;\n+  int (*num_regs) (void);\n \n   /* Perform initializations on startup.  */\n   void (*initial_stuff) (void);"
    }
  ]
}