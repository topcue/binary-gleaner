{
  "sha": "6225c532b4ce85661c5148d513335c0d8bd90e4f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjIyNWM1MzJiNGNlODU2NjFjNTE0OGQ1MTMzMzVjMGQ4YmQ5MGU0Zg==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:05:42Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-30T12:05:42Z"
    },
    "message": "x86: integrate mask_op into struct _i386_insn\n\nThere's no need for the extra level of indirection and the extra storage\nneeded for the pointer, pointing from one piece of static data to\nanother. Key checking of masking being in effect off of the register\nfield of the structure instead.",
    "tree": {
      "sha": "cf785a513f09ba77afc5718d500d9904831ae246",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cf785a513f09ba77afc5718d500d9904831ae246"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6225c532b4ce85661c5148d513335c0d8bd90e4f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6225c532b4ce85661c5148d513335c0d8bd90e4f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6225c532b4ce85661c5148d513335c0d8bd90e4f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6225c532b4ce85661c5148d513335c0d8bd90e4f/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "783c187b8ce8a2b414ca0145e27ae9747d857e98",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/783c187b8ce8a2b414ca0145e27ae9747d857e98",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/783c187b8ce8a2b414ca0145e27ae9747d857e98"
    }
  ],
  "stats": {
    "total": 124,
    "additions": 69,
    "deletions": 55
  },
  "files": [
    {
      "sha": "94c7cc4271dddcb6c573ff1c6a4aa4bdeb2f959e",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6225c532b4ce85661c5148d513335c0d8bd90e4f/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6225c532b4ce85661c5148d513335c0d8bd90e4f/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=6225c532b4ce85661c5148d513335c0d8bd90e4f",
      "patch": "@@ -1,3 +1,17 @@\n+2021-03-30  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (reg_k0): New.\n+\t(mask_op): Delete.\n+\t(struct Mask_Operation): Move ...\n+\t(struct _i386_insn): ... here. Change field \"mask\".\n+\t(md_begin): Initialize reg_k0.\n+\t(build_evex_prefix): Adjust mask processing.\n+\t(swap_2_operands): Likewise.\n+\t(check_VecOperands): Likewise.\n+\t(check_VecOperations): Likewise.\n+\t(optimize_encoding): Adjust checks for masking.\n+\t(output_insn): Likewise.\n+\n 2021-03-30  Jan Beulich  <jbeulich@suse.com>\n \n \t* config/tc-i386.c (swap_2_operands): Switch parameters to"
    },
    {
      "sha": "d5baf95da95424f0a5bb5ebd8c6d0d63d770e327",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6225c532b4ce85661c5148d513335c0d8bd90e4f/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6225c532b4ce85661c5148d513335c0d8bd90e4f/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=6225c532b4ce85661c5148d513335c0d8bd90e4f",
      "patch": "@@ -214,6 +214,8 @@ static const char *default_arch = DEFAULT_ARCH;\n static const reg_entry bad_reg = { \"<bad>\", OPERAND_TYPE_NONE, 0, 0,\n \t\t\t\t   { Dw2Inval, Dw2Inval } };\n \n+static const reg_entry *reg_k0;\n+\n /* This struct describes rounding control and SAE in the instruction.  */\n struct RC_Operation\n {\n@@ -230,19 +232,6 @@ struct RC_Operation\n \n static struct RC_Operation rc_op;\n \n-/* The struct describes masking, applied to OPERAND in the instruction.\n-   MASK is a pointer to the corresponding mask register.  ZEROING tells\n-   whether merging or zeroing mask is used.  */\n-struct Mask_Operation\n-{\n-  const reg_entry *mask;\n-  unsigned int zeroing;\n-  /* The operand where this operation is associated.  */\n-  unsigned int operand;\n-};\n-\n-static struct Mask_Operation mask_op;\n-\n /* The struct describes broadcasting, applied to OPERAND.  FACTOR is\n    broadcast factor.  */\n struct Broadcast_Operation\n@@ -393,8 +382,18 @@ struct _i386_insn\n     sib_byte sib;\n     vex_prefix vex;\n \n-    /* Masking attributes.  */\n-    struct Mask_Operation *mask;\n+    /* Masking attributes.\n+\n+       The struct describes masking, applied to OPERAND in the instruction.\n+       REG is a pointer to the corresponding mask register.  ZEROING tells\n+       whether merging or zeroing mask is used.  */\n+    struct Mask_Operation\n+    {\n+      const reg_entry *reg;\n+      unsigned int zeroing;\n+      /* The operand where this operation is associated.  */\n+      unsigned int operand;\n+    } mask;\n \n     /* Rounding control and SAE attributes.  */\n     struct RC_Operation *rounding;\n@@ -3093,8 +3092,13 @@ md_begin (void)\n     unsigned int regtab_size = i386_regtab_size;\n \n     for (regtab = i386_regtab; regtab_size--; regtab++)\n-      if (str_hash_insert (reg_hash, regtab->reg_name, regtab, 0) != NULL)\n-\tas_fatal (_(\"duplicate %s\"), regtab->reg_name);\n+      {\n+\tif (str_hash_insert (reg_hash, regtab->reg_name, regtab, 0) != NULL)\n+\t  as_fatal (_(\"duplicate %s\"), regtab->reg_name);\n+\n+\tif (regtab->reg_type.bitfield.class == RegMask && !regtab->reg_num)\n+\t  reg_k0 = regtab;\n+      }\n   }\n \n   /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */\n@@ -3871,7 +3875,7 @@ build_evex_prefix (void)\n \n   /* The fourth byte of the EVEX prefix.  */\n   /* The zeroing-masking bit.  */\n-  if (i.mask && i.mask->zeroing)\n+  if (i.mask.reg && i.mask.zeroing)\n     i.vex.bytes[3] |= 0x80;\n \n   /* Don't always set the broadcast bit if there is no RC.  */\n@@ -3962,8 +3966,8 @@ build_evex_prefix (void)\n \ti.vex.bytes[3] |= 0x10 | (evexrcig << 5);\n     }\n \n-  if (i.mask && i.mask->mask)\n-    i.vex.bytes[3] |= i.mask->mask->reg_num;\n+  if (i.mask.reg)\n+    i.vex.bytes[3] |= i.mask.reg->reg_num;\n }\n \n static void\n@@ -4164,7 +4168,7 @@ optimize_encoding (void)\n \t   && i.op[0].regs == i.op[1].regs\n \t   && !i.types[2].bitfield.xmmword\n \t   && (i.tm.opcode_modifier.vex\n-\t       || ((!i.mask || i.mask->zeroing)\n+\t       || ((!i.mask.reg || i.mask.zeroing)\n \t\t   && !i.rounding\n \t\t   && is_evex_encoding (&i.tm)\n \t\t   && (i.vec_encoding != vex_encoding_evex\n@@ -4250,7 +4254,7 @@ optimize_encoding (void)\n   else if (i.vec_encoding != vex_encoding_evex\n \t   && !i.types[0].bitfield.zmmword\n \t   && !i.types[1].bitfield.zmmword\n-\t   && !i.mask\n+\t   && !i.mask.reg\n \t   && !i.broadcast\n \t   && is_evex_encoding (&i.tm)\n \t   && ((i.tm.base_opcode & ~Opcode_SIMD_IntD) == 0x6f\n@@ -5461,12 +5465,12 @@ swap_2_operands (unsigned int xchg1, unsigned int xchg2)\n   i.reloc[xchg2] = i.reloc[xchg1];\n   i.reloc[xchg1] = temp_reloc;\n \n-  if (i.mask)\n+  if (i.mask.reg)\n     {\n-      if (i.mask->operand == xchg1)\n-\ti.mask->operand = xchg2;\n-      else if (i.mask->operand == xchg2)\n-\ti.mask->operand = xchg1;\n+      if (i.mask.operand == xchg1)\n+\ti.mask.operand = xchg2;\n+      else if (i.mask.operand == xchg2)\n+\ti.mask.operand = xchg1;\n     }\n   if (i.broadcast)\n     {\n@@ -5802,7 +5806,7 @@ check_VecOperands (const insn_template *t)\n \n   /* Check if default mask is allowed.  */\n   if (t->opcode_modifier.nodefmask\n-      && (!i.mask || i.mask->mask->reg_num == 0))\n+      && (!i.mask.reg || i.mask.reg->reg_num == 0))\n     {\n       i.error = no_default_mask;\n       return 1;\n@@ -5824,8 +5828,8 @@ check_VecOperands (const insn_template *t)\n \treturn 1;\n       }\n \n-      gas_assert (i.reg_operands == 2 || i.mask);\n-      if (i.reg_operands == 2 && !i.mask)\n+      gas_assert (i.reg_operands == 2 || i.mask.reg);\n+      if (i.reg_operands == 2 && !i.mask.reg)\n \t{\n \t  gas_assert (i.types[0].bitfield.class == RegSIMD);\n \t  gas_assert (i.types[0].bitfield.xmmword\n@@ -5849,7 +5853,7 @@ check_VecOperands (const insn_template *t)\n \t    }\n \t  as_warn (_(\"mask, index, and destination registers should be distinct\"));\n \t}\n-      else if (i.reg_operands == 1 && i.mask)\n+      else if (i.reg_operands == 1 && i.mask.reg)\n \t{\n \t  if (i.types[1].bitfield.class == RegSIMD\n \t      && (i.types[1].bitfield.xmmword\n@@ -5982,14 +5986,14 @@ check_VecOperands (const insn_template *t)\n     op = MAX_OPERANDS - 1; /* Avoid uninitialized variable warning.  */\n \n   /* Check if requested masking is supported.  */\n-  if (i.mask)\n+  if (i.mask.reg)\n     {\n       switch (t->opcode_modifier.masking)\n \t{\n \tcase BOTH_MASKING:\n \t  break;\n \tcase MERGING_MASKING:\n-\t  if (i.mask->zeroing)\n+\t  if (i.mask.zeroing)\n \t    {\n \tcase 0:\n \t      i.error = unsupported_masking;\n@@ -5998,7 +6002,7 @@ check_VecOperands (const insn_template *t)\n \t  break;\n \tcase DYNAMIC_MASKING:\n \t  /* Memory destinations allow only merging masking.  */\n-\t  if (i.mask->zeroing && i.mem_operands)\n+\t  if (i.mask.zeroing && i.mem_operands)\n \t    {\n \t      /* Find memory operand.  */\n \t      for (op = 0; op < i.operands; op++)\n@@ -6018,7 +6022,7 @@ check_VecOperands (const insn_template *t)\n     }\n \n   /* Check if masking is applied to dest operand.  */\n-  if (i.mask && (i.mask->operand != i.operands - 1))\n+  if (i.mask.reg && (i.mask.operand != i.operands - 1))\n     {\n       i.error = mask_not_on_destination;\n       return 1;\n@@ -9230,7 +9234,7 @@ output_insn (void)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_YMM;\n       if ((i.xstate & xstate_zmm) == xstate_zmm)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_ZMM;\n-      if (i.mask || (i.xstate & xstate_mask) == xstate_mask)\n+      if (i.mask.reg || (i.xstate & xstate_mask) == xstate_mask)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_MASK;\n       if (i.tm.cpu_flags.bitfield.cpufxsr)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_FXSR;\n@@ -10431,23 +10435,20 @@ check_VecOperations (char *op_string, char *op_end)\n \t\t  return NULL;\n \t\t}\n \n-\t      if (!i.mask)\n+\t      if (!i.mask.reg)\n \t\t{\n-\t\t  mask_op.mask = mask;\n-\t\t  mask_op.zeroing = 0;\n-\t\t  mask_op.operand = this_operand;\n-\t\t  i.mask = &mask_op;\n+\t\t  i.mask.reg = mask;\n+\t\t  i.mask.operand = this_operand;\n \t\t}\n+\t      else if (i.mask.reg->reg_num)\n+\t\tgoto duplicated_vec_op;\n \t      else\n \t\t{\n-\t\t  if (i.mask->mask)\n-\t\t    goto duplicated_vec_op;\n-\n-\t\t  i.mask->mask = mask;\n+\t\t  i.mask.reg = mask;\n \n \t\t  /* Only \"{z}\" is allowed here.  No need to check\n \t\t     zeroing mask explicitly.  */\n-\t\t  if (i.mask->operand != (unsigned int) this_operand)\n+\t\t  if (i.mask.operand != (unsigned int) this_operand)\n \t\t    {\n \t\t      as_bad (_(\"invalid write mask `%s'\"), saved);\n \t\t      return NULL;\n@@ -10459,27 +10460,26 @@ check_VecOperations (char *op_string, char *op_end)\n \t  /* Check zeroing-flag for masking operation.  */\n \t  else if (*op_string == 'z')\n \t    {\n-\t      if (!i.mask)\n+\t      if (!i.mask.reg)\n \t\t{\n-\t\t  mask_op.mask = NULL;\n-\t\t  mask_op.zeroing = 1;\n-\t\t  mask_op.operand = this_operand;\n-\t\t  i.mask = &mask_op;\n+\t\t  i.mask.reg = reg_k0;\n+\t\t  i.mask.zeroing = 1;\n+\t\t  i.mask.operand = this_operand;\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (i.mask->zeroing)\n+\t\t  if (i.mask.zeroing)\n \t\t    {\n \t\t    duplicated_vec_op:\n \t\t      as_bad (_(\"duplicated `%s'\"), saved);\n \t\t      return NULL;\n \t\t    }\n \n-\t\t  i.mask->zeroing = 1;\n+\t\t  i.mask.zeroing = 1;\n \n \t\t  /* Only \"{%k}\" is allowed here.  No need to check mask\n \t\t     register explicitly.  */\n-\t\t  if (i.mask->operand != (unsigned int) this_operand)\n+\t\t  if (i.mask.operand != (unsigned int) this_operand)\n \t\t    {\n \t\t      as_bad (_(\"invalid zeroing-masking `%s'\"),\n \t\t\t      saved);\n@@ -10512,7 +10512,7 @@ check_VecOperations (char *op_string, char *op_end)\n       return NULL;\n     }\n \n-  if (i.mask && i.mask->zeroing && !i.mask->mask)\n+  if (i.mask.reg && i.mask.zeroing && !i.mask.reg->reg_num)\n     {\n       as_bad (_(\"zeroing-masking only allowed with write mask\"));\n       return NULL;"
    }
  ]
}