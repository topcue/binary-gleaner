{
  "sha": "cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2QzMGJjZWY0YTY4NWFlNGE2N2Y4YjRhNzkzYWYwY2Y3MjMwYjlmYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-23T07:31:34Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-23T07:31:34Z"
    },
    "message": "Revise sleb128 and uleb128 reader\n\nThis patch catches and reports errors when reading leb128 values,\naddressing a FIXME in read_leb128.\n\n\t* dwarf.h (read_leb128): Update prototype.\n\t(report_leb_status): New inline function.\n\t(SKIP_ULEB, SKIP_SLEB, READ_ULEB, READ_SLEB): Define.\n\t* dwarf.c: Use above macros throughout file.  Formatting.\n\t(read_leb128): Reorder params.  Add status return param.\n\tDon't stop reading until finding terminator or end of data.\n\tDetect loss of significant bits.  Sign extend only on\n\tterminating byte.\n\t(read_sleb128, read_uleb128): Delete functions.\n\t(SKIP_ULEB, SKIP_SLEB, READ_ULEB, READ_SLEB): Delete macros.\n\t(read_and_print_leb128): Rewrite.\n\t(process_extended_line_op): Return a size_t.  Use size_t vars.\n\tAdjust to suit new macros.  Add proper name size to \"data\" when\n\tprocessing DW_LNE_define_file.\n\t(process_abbrev_section): Adjust to suit new macros.\n\t(decode_location_expression, skip_attr_bytes): Likewise.\n\t(get_type_signedness): Likewise.\n\t(read_and_display_attr_value): Likewise.  Consolidate block code.\n\t(process_debug_info): Adjust to suit new macros.\n\t(display_formatted_table, display_debug_lines_raw): Likewise.\n\t(display_debug_lines_decoded): Likewise.  Properly check for end\n\tof DW_LNS_extended_op.\n\t(display_debug_macinfo): Adjust to suit new macros.\n\t(get_line_filename_and_dirname, display_debug_macro): Likewise.\n\t(display_view_pair_list): Likewise.  Don't back off when hitting\n\tend of data.\n\t(display_loc_list): Adjust to suit new macros.\n\t(display_loclists_list, display_loc_list_dwo): Likewise.\n\t(display_debug_rnglists_list, read_cie): Likewise.\n\t(display_debug_frames): Likewise.\n\t* readelf.c: Use new ULEB macros throughout file.\n\t(read_uleb128): Delete.\n\t(decode_arm_unwind_bytecode): Use read_leb128.\n\t(decode_tic6x_unwind_bytecode): Likewise.\n\t(display_tag_value): Adjust to suit new macros.\n\t(display_arc_attribute, display_arm_attribute): Likewise.\n\t(display_gnu_attribute, display_power_gnu_attribute): Likewise.\n\t(display_s390_gnu_attribute, display_sparc_gnu_attribute): Likewise.\n\t(display_mips_gnu_attribute, display_tic6x_attribute): Likewise.\n\t(display_msp430x_attribute, display_msp430_gnu_attribute): Likewise.\n\t(display_riscv_attribute, process_attributes): Likewise.",
    "tree": {
      "sha": "ae8ab56c2f996c81fb1d395fdad4e35f94c1e296",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ae8ab56c2f996c81fb1d395fdad4e35f94c1e296"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "27c1c4271a14cc2ebc27227212c19d4227ef212d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/27c1c4271a14cc2ebc27227212c19d4227ef212d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/27c1c4271a14cc2ebc27227212c19d4227ef212d"
    }
  ],
  "stats": {
    "total": 1898,
    "additions": 833,
    "deletions": 1065
  },
  "files": [
    {
      "sha": "de6cf421efdadb13b55521843208c2c2328ebf28",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
      "patch": "@@ -1,3 +1,47 @@\n+2019-12-23  Alan Modra  <amodra@gmail.com>\n+\n+\t* dwarf.h (read_leb128): Update prototype.\n+\t(report_leb_status): New inline function.\n+\t(SKIP_ULEB, SKIP_SLEB, READ_ULEB, READ_SLEB): Define.\n+\t* dwarf.c: Use above macros throughout file.  Formatting.\n+\t(read_leb128): Reorder params.  Add status return param.\n+\tDon't stop reading until finding terminator or end of data.\n+\tDetect loss of significant bits.  Sign extend only on\n+\tterminating byte.\n+\t(read_sleb128, read_uleb128): Delete functions.\n+\t(SKIP_ULEB, SKIP_SLEB, READ_ULEB, READ_SLEB): Delete macros.\n+\t(read_and_print_leb128): Rewrite.\n+\t(process_extended_line_op): Return a size_t.  Use size_t vars.\n+\tAdjust to suit new macros.  Add proper name size to \"data\" when\n+\tprocessing DW_LNE_define_file.\n+\t(process_abbrev_section): Adjust to suit new macros.\n+\t(decode_location_expression, skip_attr_bytes): Likewise.\n+\t(get_type_signedness): Likewise.\n+\t(read_and_display_attr_value): Likewise.  Consolidate block code.\n+\t(process_debug_info): Adjust to suit new macros.\n+\t(display_formatted_table, display_debug_lines_raw): Likewise.\n+\t(display_debug_lines_decoded): Likewise.  Properly check for end\n+\tof DW_LNS_extended_op.\n+\t(display_debug_macinfo): Adjust to suit new macros.\n+\t(get_line_filename_and_dirname, display_debug_macro): Likewise.\n+\t(display_view_pair_list): Likewise.  Don't back off when hitting\n+\tend of data.\n+\t(display_loc_list): Adjust to suit new macros.\n+\t(display_loclists_list, display_loc_list_dwo): Likewise.\n+\t(display_debug_rnglists_list, read_cie): Likewise.\n+\t(display_debug_frames): Likewise.\n+\t* readelf.c: Use new ULEB macros throughout file.\n+\t(read_uleb128): Delete.\n+\t(decode_arm_unwind_bytecode): Use read_leb128.\n+\t(decode_tic6x_unwind_bytecode): Likewise.\n+\t(display_tag_value): Adjust to suit new macros.\n+\t(display_arc_attribute, display_arm_attribute): Likewise.\n+\t(display_gnu_attribute, display_power_gnu_attribute): Likewise.\n+\t(display_s390_gnu_attribute, display_sparc_gnu_attribute): Likewise.\n+\t(display_mips_gnu_attribute, display_tic6x_attribute): Likewise.\n+\t(display_msp430x_attribute, display_msp430_gnu_attribute): Likewise.\n+\t(display_riscv_attribute, process_attributes): Likewise.\n+\n 2019-12-17  Alan Modra  <amodra@gmail.com>\n \n \t* objdump.c (compare_section): New static var."
    },
    {
      "sha": "30abee56c351b4a93f8a6a10148c0020783349a0",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 660,
      "deletions": 909,
      "changes": 1569,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
      "patch": "@@ -319,93 +319,56 @@ dwarf_vmatoa64 (dwarf_vma hvalue, dwarf_vma lvalue, char *buf,\n /* Read in a LEB128 encoded value starting at address DATA.\n    If SIGN is true, return a signed LEB128 value.\n    If LENGTH_RETURN is not NULL, return in it the number of bytes read.\n+   If STATUS_RETURN in not NULL, return with bit 0 (LSB) set if the\n+   terminating byte was not found and with bit 1 set if the value\n+   overflows a dwarf_vma.\n    No bytes will be read at address END or beyond.  */\n \n dwarf_vma\n read_leb128 (unsigned char *data,\n-\t     unsigned int *length_return,\n+\t     const unsigned char *const end,\n \t     bfd_boolean sign,\n-\t     const unsigned char * const end)\n+\t     unsigned int *length_return,\n+\t     int *status_return)\n {\n   dwarf_vma result = 0;\n   unsigned int num_read = 0;\n   unsigned int shift = 0;\n-  unsigned char byte = 0;\n+  int status = 1;\n \n   while (data < end)\n     {\n-      byte = *data++;\n+      unsigned char byte = *data++;\n       num_read++;\n \n-      result |= ((dwarf_vma) (byte & 0x7f)) << shift;\n+      if (shift < sizeof (result) * 8)\n+\t{\n+\t  result |= ((dwarf_vma) (byte & 0x7f)) << shift;\n+\t  if ((result >> shift) != (byte & 0x7f))\n+\t    /* Overflow.  */\n+\t    status |= 2;\n+\t  shift += 7;\n+\t}\n+      else if ((byte & 0x7f) != 0)\n+\tstatus |= 2;\n \n-      shift += 7;\n       if ((byte & 0x80) == 0)\n-\tbreak;\n-\n-      /* PR 17512: file: 0ca183b8.\n-\t FIXME: Should we signal this error somehow ?  */\n-      if (shift >= sizeof (result) * 8)\n-\tbreak;\n+\t{\n+\t  status &= ~1;\n+\t  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))\n+\t    result |= -((dwarf_vma) 1 << shift);\n+\t  break;\n+\t}\n     }\n \n   if (length_return != NULL)\n     *length_return = num_read;\n-\n-  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))\n-    result |= -((dwarf_vma) 1 << shift);\n+  if (status_return != NULL)\n+    *status_return = status;\n \n   return result;\n }\n \n-/* Create a signed version to avoid painful typecasts.  */\n-static inline dwarf_signed_vma\n-read_sleb128 (unsigned char * data,\n-\t      unsigned int *  length_return,\n-\t      const unsigned char * const end)\n-{\n-  return (dwarf_signed_vma) read_leb128 (data, length_return, TRUE, end);\n-}\n-\n-static inline dwarf_vma\n-read_uleb128 (unsigned char * data,\n-\t      unsigned int *  length_return,\n-\t      const unsigned char * const end)\n-{\n-  return read_leb128 (data, length_return, FALSE, end);\n-}\n-\n-#define SKIP_ULEB()\tread_uleb128 (start, & length_return, end); start += length_return\n-#define SKIP_SLEB()\tread_sleb128 (start, & length_return, end); start += length_return\n-\n-#define READ_ULEB(var)\t\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      dwarf_vma _val;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      (var) = _val = read_uleb128 (start, &length_return, end);\t\\\n-      if ((var) != _val)\t\t\t\t\t\\\n-\terror (_(\"Internal error: %s:%d: LEB value (%s) \"\t\\\n-\t\t \"too large for containing variable\\n\"),\t\\\n-\t       __FILE__, __LINE__, dwarf_vmatoa (\"u\", _val));\t\\\n-      start += length_return;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define READ_SLEB(var)\t\t\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      dwarf_signed_vma _val;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      (var) = _val = read_sleb128 (start, &length_return, end);\t\\\n-      if ((var) != _val)\t\t\t\t\t\\\n-\terror (_(\"Internal error: %s:%d: LEB value (%s) \"\t\\\n-\t\t \"too large for containing variable\\n\"),\t\\\n-\t       __FILE__, __LINE__, dwarf_vmatoa (\"d\", _val));\t\\\n-      start += length_return;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n /* Read AMOUNT bytes from PTR and store them in VAL as an unsigned value.\n    Checks to make sure that the read will not reach or pass END\n    and that VAL is big enough to hold AMOUNT bytes.  */\n@@ -524,28 +487,26 @@ reset_state_machine (int is_stmt)\n /* Handled an extend line op.\n    Returns the number of bytes read.  */\n \n-static int\n+static size_t\n process_extended_line_op (unsigned char * data,\n \t\t\t  int is_stmt,\n \t\t\t  unsigned char * end)\n {\n   unsigned char op_code;\n-  unsigned int bytes_read;\n-  unsigned int len;\n+  size_t len, header_len;\n   unsigned char *name;\n   unsigned char *orig_data = data;\n-  dwarf_vma adr;\n+  dwarf_vma adr, val;\n \n-  len = read_uleb128 (data, & bytes_read, end);\n-  data += bytes_read;\n+  READ_ULEB (len, data, end);\n+  header_len = data - orig_data;\n \n-  if (len == 0 || data == end || len > (uintptr_t) (end - data))\n+  if (len == 0 || data == end || len > (size_t) (end - data))\n     {\n       warn (_(\"Badly formed extended line op encountered!\\n\"));\n-      return bytes_read;\n+      return header_len;\n     }\n \n-  len += bytes_read;\n   op_code = *data++;\n \n   printf (_(\"  Extended opcode %d: \"), op_code);\n@@ -559,14 +520,14 @@ process_extended_line_op (unsigned char * data,\n \n     case DW_LNE_set_address:\n       /* PR 17512: file: 002-100480-0.004.  */\n-      if (len - bytes_read - 1 > 8)\n+      if (len - 1 > 8)\n \t{\n-\t  warn (_(\"Length (%d) of DW_LNE_set_address op is too long\\n\"),\n-\t\tlen - bytes_read - 1);\n+\t  warn (_(\"Length (%lu) of DW_LNE_set_address op is too long\\n\"),\n+\t\t(unsigned long) len - 1);\n \t  adr = 0;\n \t}\n       else\n-\tSAFE_BYTE_GET (adr, data, len - bytes_read - 1, end);\n+\tSAFE_BYTE_GET (adr, data, len - 1, end);\n       printf (_(\"set Address to 0x%s\\n\"), dwarf_vmatoa (\"x\", adr));\n       state_machine_regs.address = adr;\n       state_machine_regs.view = 0;\n@@ -583,23 +544,23 @@ process_extended_line_op (unsigned char * data,\n \n \tname = data;\n \tl = strnlen ((char *) data, end - data);\n-\tdata += len + 1;\n-\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\tdata += bytes_read;\n-\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\tdata += bytes_read;\n-\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\tdata += bytes_read;\n+\tdata += l + 1;\n+\tREAD_ULEB (val, data, end);\n+\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n+\tREAD_ULEB (val, data, end);\n+\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n+\tREAD_ULEB (val, data, end);\n+\tprintf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n \tprintf (\"%.*s\\n\\n\", (int) l, name);\n       }\n \n-      if (((unsigned int) (data - orig_data) != len) || data == end)\n+      if (((size_t) (data - orig_data) != len + header_len) || data == end)\n \twarn (_(\"DW_LNE_define_file: Bad opcode length\\n\"));\n       break;\n \n     case DW_LNE_set_discriminator:\n-      printf (_(\"set Discriminator to %s\\n\"),\n-\t      dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n+      READ_ULEB (val, data, end);\n+      printf (_(\"set Discriminator to %s\\n\"), dwarf_vmatoa (\"u\", val));\n       break;\n \n     /* HP extensions.  */\n@@ -635,42 +596,34 @@ process_extended_line_op (unsigned char * data,\n       break;\n     case DW_LNE_HP_source_file_correlation:\n       {\n-\tunsigned char *edata = data + len - bytes_read - 1;\n+\tunsigned char *edata = data + len - 1;\n \n \tprintf (\"DW_LNE_HP_source_file_correlation\\n\");\n \n \twhile (data < edata)\n \t  {\n \t    unsigned int opc;\n \n-\t    opc = read_uleb128 (data, & bytes_read, edata);\n-\t    data += bytes_read;\n+\t    READ_ULEB (opc, data, edata);\n \n \t    switch (opc)\n \t      {\n \t      case DW_LNE_HP_SFC_formfeed:\n \t\tprintf (\"    DW_LNE_HP_SFC_formfeed\\n\");\n \t\tbreak;\n \t      case DW_LNE_HP_SFC_set_listing_line:\n+\t\tREAD_ULEB (val, data, edata);\n \t\tprintf (\"    DW_LNE_HP_SFC_set_listing_line (%s)\\n\",\n-\t\t\tdwarf_vmatoa (\"u\",\n-\t\t\t\t      read_uleb128 (data, & bytes_read, edata)));\n-\t\tdata += bytes_read;\n+\t\t\tdwarf_vmatoa (\"u\", val));\n \t\tbreak;\n \t      case DW_LNE_HP_SFC_associate:\n \t\tprintf (\"    DW_LNE_HP_SFC_associate \");\n-\t\tprintf (\"(%s\",\n-\t\t\tdwarf_vmatoa (\"u\",\n-\t\t\t\t      read_uleb128 (data, & bytes_read, edata)));\n-\t\tdata += bytes_read;\n-\t\tprintf (\",%s\",\n-\t\t\tdwarf_vmatoa (\"u\",\n-\t\t\t\t      read_uleb128 (data, & bytes_read, edata)));\n-\t\tdata += bytes_read;\n-\t\tprintf (\",%s)\\n\",\n-\t\t\tdwarf_vmatoa (\"u\",\n-\t\t\t\t      read_uleb128 (data, & bytes_read, edata)));\n-\t\tdata += bytes_read;\n+\t\tREAD_ULEB (val, data, edata);\n+\t\tprintf (\"(%s\", dwarf_vmatoa (\"u\", val));\n+\t\tREAD_ULEB (val, data, edata);\n+\t\tprintf (\",%s\", dwarf_vmatoa (\"u\", val));\n+\t\tREAD_ULEB (val, data, edata);\n+\t\tprintf (\",%s)\\n\", dwarf_vmatoa (\"u\", val));\n \t\tbreak;\n \t      default:\n \t\tprintf (_(\"    UNKNOWN DW_LNE_HP_SFC opcode (%u)\\n\"), opc);\n@@ -683,7 +636,7 @@ process_extended_line_op (unsigned char * data,\n \n     default:\n       {\n-\tunsigned int rlen = len - bytes_read - 1;\n+\tunsigned int rlen = len - 1;\n \n \tif (op_code >= DW_LNE_lo_user\n \t    /* The test against DW_LNW_hi_user is redundant due to\n@@ -701,7 +654,7 @@ process_extended_line_op (unsigned char * data,\n       break;\n     }\n \n-  return len;\n+  return len + header_len;\n }\n \n static const unsigned char *\n@@ -941,14 +894,12 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n \n   while (start < end)\n     {\n-      unsigned int bytes_read;\n       unsigned long entry;\n       unsigned long tag;\n       unsigned long attribute;\n       int children;\n \n-      entry = read_uleb128 (start, & bytes_read, end);\n-      start += bytes_read;\n+      READ_ULEB (entry, start, end);\n \n       /* A single zero is supposed to end the section according\n \t to the standard.  If there's more, then signal that to\n@@ -958,8 +909,7 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n       if (entry == 0)\n \treturn start;\n \n-      tag = read_uleb128 (start, & bytes_read, end);\n-      start += bytes_read;\n+      READ_ULEB (tag, start, end);\n       if (start == end)\n \treturn NULL;\n \n@@ -973,20 +923,17 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n \t  /* Initialize it due to a false compiler warning.  */\n \t  bfd_signed_vma implicit_const = -1;\n \n-\t  attribute = read_uleb128 (start, & bytes_read, end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (attribute, start, end);\n \t  if (start == end)\n \t    break;\n \n-\t  form = read_uleb128 (start, & bytes_read, end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (form, start, end);\n \t  if (start == end)\n \t    break;\n \n \t  if (form == DW_FORM_implicit_const)\n \t    {\n-\t      implicit_const = read_sleb128 (start, & bytes_read, end);\n-\t      start += bytes_read;\n+\t      READ_SLEB (implicit_const, start, end);\n \t      if (start == end)\n \t\tbreak;\n \t    }\n@@ -1087,7 +1034,6 @@ decode_location_expression (unsigned char * data,\n \t\t\t    struct dwarf_section * section)\n {\n   unsigned op;\n-  unsigned int bytes_read;\n   dwarf_vma uvalue;\n   dwarf_signed_vma svalue;\n   unsigned char *end = data + length;\n@@ -1143,14 +1089,12 @@ decode_location_expression (unsigned char * data,\n \t  printf (\"%ld\", (long) svalue);\n \t  break;\n \tcase DW_OP_constu:\n-\t  printf (\"DW_OP_constu: %s\",\n-\t\t  dwarf_vmatoa (\"u\", read_uleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n+\t  printf (\"DW_OP_constu: %s\", dwarf_vmatoa (\"u\", uvalue));\n \t  break;\n \tcase DW_OP_consts:\n-\t  printf (\"DW_OP_consts: %s\",\n-\t\t  dwarf_vmatoa (\"d\", read_sleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_SLEB (svalue, data, end);\n+\t  printf (\"DW_OP_consts: %s\", dwarf_vmatoa (\"d\", svalue));\n \t  break;\n \tcase DW_OP_dup:\n \t  printf (\"DW_OP_dup\");\n@@ -1205,9 +1149,8 @@ decode_location_expression (unsigned char * data,\n \t  printf (\"DW_OP_plus\");\n \t  break;\n \tcase DW_OP_plus_uconst:\n-\t  printf (\"DW_OP_plus_uconst: %s\",\n-\t\t  dwarf_vmatoa (\"u\", read_uleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n+\t  printf (\"DW_OP_plus_uconst: %s\", dwarf_vmatoa (\"u\", uvalue));\n \t  break;\n \tcase DW_OP_shl:\n \t  printf (\"DW_OP_shl\");\n@@ -1351,37 +1294,31 @@ decode_location_expression (unsigned char * data,\n \tcase DW_OP_breg29:\n \tcase DW_OP_breg30:\n \tcase DW_OP_breg31:\n-\t  printf (\"DW_OP_breg%d (%s): %s\",\n-\t\t  op - DW_OP_breg0,\n-\t\t  regname (op - DW_OP_breg0, 1),\n-\t\t  dwarf_vmatoa (\"d\", read_sleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_SLEB (svalue, data, end);\n+\t  printf (\"DW_OP_breg%d (%s): %s\", op - DW_OP_breg0,\n+\t\t  regname (op - DW_OP_breg0, 1), dwarf_vmatoa (\"d\", svalue));\n \t  break;\n \n \tcase DW_OP_regx:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"DW_OP_regx: %s (%s)\",\n \t\t  dwarf_vmatoa (\"u\", uvalue), regname (uvalue, 1));\n \t  break;\n \tcase DW_OP_fbreg:\n \t  need_frame_base = 1;\n-\t  printf (\"DW_OP_fbreg: %s\",\n-\t\t  dwarf_vmatoa (\"d\", read_sleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_SLEB (svalue, data, end);\n+\t  printf (\"DW_OP_fbreg: %s\", dwarf_vmatoa (\"d\", svalue));\n \t  break;\n \tcase DW_OP_bregx:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n+\t  READ_SLEB (svalue, data, end);\n \t  printf (\"DW_OP_bregx: %s (%s) %s\",\n \t\t  dwarf_vmatoa (\"u\", uvalue), regname (uvalue, 1),\n-\t\t  dwarf_vmatoa (\"d\", read_sleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t\t  dwarf_vmatoa (\"d\", svalue));\n \t  break;\n \tcase DW_OP_piece:\n-\t  printf (\"DW_OP_piece: %s\",\n-\t\t  dwarf_vmatoa (\"u\", read_uleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n+\t  printf (\"DW_OP_piece: %s\", dwarf_vmatoa (\"u\", uvalue));\n \t  break;\n \tcase DW_OP_deref_size:\n \t  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);\n@@ -1440,12 +1377,10 @@ decode_location_expression (unsigned char * data,\n \t  break;\n \tcase DW_OP_bit_piece:\n \t  printf (\"DW_OP_bit_piece: \");\n-\t  printf (_(\"size: %s \"),\n-\t\t  dwarf_vmatoa (\"u\", read_uleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n-\t  printf (_(\"offset: %s \"),\n-\t\t  dwarf_vmatoa (\"u\", read_uleb128 (data, &bytes_read, end)));\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n+\t  printf (_(\"size: %s \"), dwarf_vmatoa (\"u\", uvalue));\n+\t  READ_ULEB (uvalue, data, end);\n+\t  printf (_(\"offset: %s \"), dwarf_vmatoa (\"u\", uvalue));\n \t  break;\n \n \t  /* DWARF 4 extensions.  */\n@@ -1455,8 +1390,7 @@ decode_location_expression (unsigned char * data,\n \n \tcase DW_OP_implicit_value:\n \t  printf (\"DW_OP_implicit_value\");\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  data = display_block (data, uvalue, end, ' ');\n \t  break;\n \n@@ -1502,18 +1436,16 @@ decode_location_expression (unsigned char * data,\n \t    {\n \t      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);\n \t    }\n+\t  READ_SLEB (svalue, data, end);\n \t  printf (\"%s: <0x%s> %s\",\n \t\t  (op == DW_OP_implicit_pointer\n \t\t   ? \"DW_OP_implicit_pointer\" : \"DW_OP_GNU_implicit_pointer\"),\n \t\t  dwarf_vmatoa (\"x\", uvalue),\n-\t\t  dwarf_vmatoa (\"d\", read_sleb128 (data,\n-\t\t\t\t\t\t   &bytes_read, end)));\n-\t  data += bytes_read;\n+\t\t  dwarf_vmatoa (\"d\", svalue));\n \t  break;\n \tcase DW_OP_entry_value:\n \tcase DW_OP_GNU_entry_value:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  /* PR 17531: file: 0cc9cd00.  */\n \t  if (uvalue > (dwarf_vma) (end - data))\n \t    uvalue = end - data;\n@@ -1530,8 +1462,7 @@ decode_location_expression (unsigned char * data,\n \t  break;\n \tcase DW_OP_const_type:\n \tcase DW_OP_GNU_const_type:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"%s: <0x%s> \",\n \t\t  (op == DW_OP_const_type ? \"DW_OP_const_type\"\n \t\t\t\t\t  : \"DW_OP_GNU_const_type\"),\n@@ -1541,14 +1472,12 @@ decode_location_expression (unsigned char * data,\n \t  break;\n \tcase DW_OP_regval_type:\n \tcase DW_OP_GNU_regval_type:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"%s: %s (%s)\",\n \t\t  (op == DW_OP_regval_type ? \"DW_OP_regval_type\"\n \t\t\t\t\t   : \"DW_OP_GNU_regval_type\"),\n \t\t  dwarf_vmatoa (\"u\", uvalue), regname (uvalue, 1));\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\" <0x%s>\", dwarf_vmatoa (\"x\", cu_offset + uvalue));\n \t  break;\n \tcase DW_OP_deref_type:\n@@ -1558,22 +1487,19 @@ decode_location_expression (unsigned char * data,\n \t\t  (op == DW_OP_deref_type ? \"DW_OP_deref_type\"\n \t\t\t\t\t  : \"DW_OP_GNU_deref_type\"),\n \t\t  (long) uvalue);\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\" <0x%s>\", dwarf_vmatoa (\"x\", cu_offset + uvalue));\n \t  break;\n \tcase DW_OP_convert:\n \tcase DW_OP_GNU_convert:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"%s <0x%s>\",\n \t\t  (op == DW_OP_convert ? \"DW_OP_convert\" : \"DW_OP_GNU_convert\"),\n \t\t  dwarf_vmatoa (\"x\", uvalue ? cu_offset + uvalue : 0));\n \t  break;\n \tcase DW_OP_reinterpret:\n \tcase DW_OP_GNU_reinterpret:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"%s <0x%s>\",\n \t\t  (op == DW_OP_reinterpret ? \"DW_OP_reinterpret\"\n \t\t\t\t\t   : \"DW_OP_GNU_reinterpret\"),\n@@ -1585,13 +1511,11 @@ decode_location_expression (unsigned char * data,\n \t\t  dwarf_vmatoa (\"x\", cu_offset + uvalue));\n \t  break;\n \tcase DW_OP_GNU_addr_index:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"DW_OP_GNU_addr_index <0x%s>\", dwarf_vmatoa (\"x\", uvalue));\n \t  break;\n \tcase DW_OP_GNU_const_index:\n-\t  uvalue = read_uleb128 (data, &bytes_read, end);\n-\t  data += bytes_read;\n+\t  READ_ULEB (uvalue, data, end);\n \t  printf (\"DW_OP_GNU_const_index <0x%s>\", dwarf_vmatoa (\"x\", uvalue));\n \t  break;\n \tcase DW_OP_GNU_variable_value:\n@@ -1869,8 +1793,8 @@ skip_attr_bytes (unsigned long          form,\n \t\t int                    dwarf_version,\n \t\t dwarf_vma *            value_return)\n {\n-  unsigned int  bytes_read;\n-  dwarf_vma     uvalue = 0;\n+  dwarf_signed_vma svalue;\n+  dwarf_vma uvalue = 0;\n \n   * value_return = 0;\n \n@@ -1918,16 +1842,15 @@ skip_attr_bytes (unsigned long          form,\n       break;\n \n     case DW_FORM_sdata:\n-      uvalue = read_sleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+      READ_SLEB (svalue, data, end);\n+      uvalue = svalue;\n       break;\n \n     case DW_FORM_ref_udata:\n     case DW_FORM_udata:\n     case DW_FORM_GNU_str_index:\n     case DW_FORM_GNU_addr_index:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+      READ_ULEB (uvalue, data, end);\n       break;\n \n     case DW_FORM_ref8:\n@@ -1945,8 +1868,7 @@ skip_attr_bytes (unsigned long          form,\n \n     case DW_FORM_block:\n     case DW_FORM_exprloc:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read + uvalue;\n+      READ_ULEB (uvalue, data, end);\n       break;\n \n     case DW_FORM_block1:\n@@ -1994,14 +1916,12 @@ get_type_signedness (unsigned char *        start,\n \t\t     bfd_boolean\t    is_nested)\n {\n   unsigned long   abbrev_number;\n-  unsigned int    bytes_read;\n   abbrev_entry *  entry;\n   abbrev_attr *   attr;\n \n   * is_signed = FALSE;\n \n-  abbrev_number = read_uleb128 (data, & bytes_read, end);\n-  data += bytes_read;\n+  READ_ULEB (abbrev_number, data, end);\n \n   for (entry = first_abbrev;\n        entry != NULL && entry->entry != abbrev_number;\n@@ -2081,16 +2001,12 @@ read_and_print_leb128 (unsigned char *        data,\n \t\t       unsigned const char *  end,\n \t\t       bfd_boolean            is_signed)\n {\n-  if (is_signed)\n-    {\n-      dwarf_signed_vma sval = read_sleb128 (data, bytes_read, end);\n-      printf (\"%ld\", (long) sval);\n-    }\n+  int status;\n+  dwarf_vma val = read_leb128 (data, end, is_signed, bytes_read, &status);\n+  if (status != 0)\n+    report_leb_status (status);\n   else\n-    {\n-      dwarf_vma uval = read_uleb128 (data, bytes_read, end);\n-      printf (\"%lu\", (unsigned long) uval);\n-    }\n+    printf (\"%s\", dwarf_vmatoa (is_signed ? \"d\" : \"u\", val));\n }\n \n static void\n@@ -2202,10 +2118,10 @@ read_and_display_attr_value (unsigned long           attribute,\n \t\t\t     char                    delimiter,\n \t\t\t     int                     level)\n {\n+  dwarf_signed_vma svalue;\n   dwarf_vma        uvalue = 0;\n   unsigned char *  block_start = NULL;\n   unsigned char *  orig_data = data;\n-  unsigned int     bytes_read;\n \n   if (data > end || (data == end && form != DW_FORM_flag_present))\n     {\n@@ -2261,41 +2177,29 @@ read_and_display_attr_value (unsigned long           attribute,\n       break;\n \n     case DW_FORM_sdata:\n-      uvalue = read_sleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+      READ_SLEB (svalue, data, end);\n+      uvalue = svalue;\n       break;\n \n     case DW_FORM_GNU_str_index:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n-      break;\n-\n     case DW_FORM_ref_udata:\n     case DW_FORM_udata:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+    case DW_FORM_GNU_addr_index:\n+      READ_ULEB (uvalue, data, end);\n       break;\n \n     case DW_FORM_indirect:\n-      form = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+      READ_ULEB (form, data, end);\n       if (!do_loc)\n \tprintf (\"%c%s\", delimiter, get_FORM_name (form));\n       if (form == DW_FORM_implicit_const)\n-\t{\n-\t  implicit_const = read_sleb128 (data, & bytes_read, end);\n-\t  data += bytes_read;\n-\t}\n+\tREAD_SLEB (implicit_const, data, end);\n       return read_and_display_attr_value (attribute, form, implicit_const,\n \t\t\t\t\t  start, data, end,\n \t\t\t\t\t  cu_offset, pointer_size,\n \t\t\t\t\t  offset_size, dwarf_version,\n \t\t\t\t\t  debug_info_p, do_loc,\n \t\t\t\t\t  section, this_set, delimiter, level);\n-    case DW_FORM_GNU_addr_index:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n-      break;\n     }\n \n   switch (form)\n@@ -2403,8 +2307,9 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_FORM_block:\n     case DW_FORM_exprloc:\n-      uvalue = read_uleb128 (data, & bytes_read, end);\n-      block_start = data + bytes_read;\n+      READ_ULEB (uvalue, data, end);\n+    do_block:\n+      block_start = data;\n       if (block_start >= end)\n \t{\n \t  warn (_(\"Block ends prematurely\\n\"));\n@@ -2421,59 +2326,16 @@ read_and_display_attr_value (unsigned long           attribute,\n       break;\n \n     case DW_FORM_block1:\n-      SAFE_BYTE_GET (uvalue, data, 1, end);\n-      block_start = data + 1;\n-      if (block_start >= end)\n-\t{\n-\t  warn (_(\"Block ends prematurely\\n\"));\n-\t  uvalue = 0;\n-\t  block_start = end;\n-\t}\n-\n-      uvalue = check_uvalue (block_start, uvalue, end);\n-\n-      if (do_loc)\n-\tdata = block_start + uvalue;\n-      else\n-\tdata = display_block (block_start, uvalue, end, delimiter);\n-      break;\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);\n+      goto do_block;\n \n     case DW_FORM_block2:\n-      SAFE_BYTE_GET (uvalue, data, 2, end);\n-      block_start = data + 2;\n-      if (block_start >= end)\n-\t{\n-\t  warn (_(\"Block ends prematurely\\n\"));\n-\t  uvalue = 0;\n-\t  block_start = end;\n-\t}\n-\n-      uvalue = check_uvalue (block_start, uvalue, end);\n-\n-      if (do_loc)\n-\tdata = block_start + uvalue;\n-      else\n-\tdata = display_block (block_start, uvalue, end, delimiter);\n-      break;\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 2, end);\n+      goto do_block;\n \n     case DW_FORM_block4:\n-      SAFE_BYTE_GET (uvalue, data, 4, end);\n-      block_start = data + 4;\n-      /* PR 17512: file: 3371-3907-0.004.  */\n-      if (block_start >= end)\n-\t{\n-\t  warn (_(\"Block ends prematurely\\n\"));\n-\t  uvalue = 0;\n-\t  block_start = end;\n-\t}\n-\n-      uvalue = check_uvalue (block_start, uvalue, end);\n-\n-      if (do_loc)\n-\tdata = block_start + uvalue;\n-      else\n-\tdata = display_block (block_start, uvalue, end, delimiter);\n-      break;\n+      SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);\n+      goto do_block;\n \n     case DW_FORM_strp:\n       if (!do_loc)\n@@ -3070,9 +2932,10 @@ read_and_display_attr_value (unsigned long           attribute,\n \telse\n \t  {\n \t    unsigned long abbrev_number;\n-\t    abbrev_entry * entry;\n+\t    abbrev_entry *entry;\n+\t    unsigned char *p = section->start + uvalue;\n \n-\t    abbrev_number = read_uleb128 (section->start + uvalue, NULL, end);\n+\t    READ_ULEB (abbrev_number, p, end);\n \n \t    printf (_(\"\\t[Abbrev Number: %ld\"), abbrev_number);\n \t    /* Don't look up abbrev for DW_FORM_ref_addr, as it very often will\n@@ -3517,7 +3380,6 @@ process_debug_info (struct dwarf_section *           section,\n       saved_level = -1;\n       while (tags < start)\n \t{\n-\t  unsigned int bytes_read;\n \t  unsigned long abbrev_number;\n \t  unsigned long die_offset;\n \t  abbrev_entry *entry;\n@@ -3526,8 +3388,7 @@ process_debug_info (struct dwarf_section *           section,\n \n \t  die_offset = tags - section_begin;\n \n-\t  abbrev_number = read_uleb128 (tags, & bytes_read, start);\n-\t  tags += bytes_read;\n+\t  READ_ULEB (abbrev_number, tags, start);\n \n \t  /* A null DIE marks the end of a list of siblings or it may also be\n \t     a section padding.  */\n@@ -3871,16 +3732,14 @@ display_formatted_table (unsigned char *                   data,\n {\n   unsigned char *format_start, format_count, *format, formati;\n   dwarf_vma data_count, datai;\n-  unsigned int bytes_read, namepass, last_entry = 0;\n+  unsigned int namepass, last_entry = 0;\n \n   SAFE_BYTE_GET_AND_INC (format_count, data, 1, end);\n   format_start = data;\n   for (formati = 0; formati < format_count; formati++)\n     {\n-      read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n-      read_uleb128 (data, & bytes_read, end);\n-      data += bytes_read;\n+      SKIP_ULEB (data, end);\n+      SKIP_ULEB (data, end);\n       if (data == end)\n \t{\n \t  if (is_dir)\n@@ -3891,8 +3750,7 @@ display_formatted_table (unsigned char *                   data,\n \t}\n     }\n \n-  data_count = read_uleb128 (data, & bytes_read, end);\n-  data += bytes_read;\n+  READ_ULEB (data_count, data, end);\n   if (data == end)\n     {\n       if (is_dir)\n@@ -3927,8 +3785,7 @@ display_formatted_table (unsigned char *                   data,\n \t{\n \t  dwarf_vma content_type;\n \n-\t  content_type = read_uleb128 (format, & bytes_read, end);\n-\t  format += bytes_read;\n+\t  READ_ULEB (content_type, format, end);\n \t  if ((content_type == DW_LNCT_path) == (namepass == 1))\n \t    switch (content_type)\n \t      {\n@@ -3951,8 +3808,7 @@ display_formatted_table (unsigned char *                   data,\n \t\tprintf (_(\"\\t(Unknown format content type %s)\"),\n \t\t\tdwarf_vmatoa (\"u\", content_type));\n \t      }\n-\t  read_uleb128 (format, & bytes_read, end);\n-\t  format += bytes_read;\n+\t  SKIP_ULEB (format, end);\n \t}\n     }\n   putchar ('\\n');\n@@ -3971,12 +3827,10 @@ display_formatted_table (unsigned char *                   data,\n \t    {\n \t      dwarf_vma content_type, form;\n \n-\t      content_type = read_uleb128 (format, & bytes_read, end);\n-\t      format += bytes_read;\n-\t      form = read_uleb128 (format, & bytes_read, end);\n-\t      format += bytes_read;\n-\t      data = read_and_display_attr_value (0, form, 0, start, data, end, 0, 0,\n-\t\t\t\t\t\t  linfo->li_offset_size,\n+\t      READ_ULEB (content_type, format, end);\n+\t      READ_ULEB (form, format, end);\n+\t      data = read_and_display_attr_value (0, form, 0, start, data, end,\n+\t\t\t\t\t\t  0, 0, linfo->li_offset_size,\n \t\t\t\t\t\t  linfo->li_version, NULL,\n \t\t\t    ((content_type == DW_LNCT_path) != (namepass == 1)),\n \t\t\t\t\t\t  section, NULL, '\\t', -1);\n@@ -4137,21 +3991,18 @@ display_debug_lines_raw (struct dwarf_section *  section,\n \t\t  while (data < end && *data != 0)\n \t\t    {\n \t\t      unsigned char *name;\n-\t\t      unsigned int bytes_read;\n+\t\t      dwarf_vma val;\n \n \t\t      printf (\"  %d\\t\", ++state_machine_regs.last_file_entry);\n \t\t      name = data;\n \t\t      data += strnlen ((char *) data, end - data) + 1;\n \n-\t\t      printf (\"%s\\t\",\n-\t\t\t      dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\t\t      data += bytes_read;\n-\t\t      printf (\"%s\\t\",\n-\t\t\t      dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\t\t      data += bytes_read;\n-\t\t      printf (\"%s\\t\",\n-\t\t\t      dwarf_vmatoa (\"u\", read_uleb128 (data, & bytes_read, end)));\n-\t\t      data += bytes_read;\n+\t\t      READ_ULEB (val, data, end);\n+\t\t      printf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n+\t\t      READ_ULEB (val, data, end);\n+\t\t      printf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n+\t\t      READ_ULEB (val, data, end);\n+\t\t      printf (\"%s\\t\", dwarf_vmatoa (\"u\", val));\n \t\t      printf (\"%.*s\\n\", (int)(end - name), name);\n \n \t\t      if (data == end)\n@@ -4182,7 +4033,6 @@ display_debug_lines_raw (struct dwarf_section *  section,\n \t      unsigned char op_code;\n \t      dwarf_signed_vma adv;\n \t      dwarf_vma uladv;\n-\t      unsigned int bytes_read;\n \n \t      printf (\"  [0x%08lx]\", (long)(data - start));\n \n@@ -4236,169 +4086,166 @@ display_debug_lines_raw (struct dwarf_section *  section,\n \t\t    putchar ('\\n');\n \t\t  state_machine_regs.view++;\n \t\t}\n-\t      else switch (op_code)\n-\t\t     {\n-\t\t     case DW_LNS_extended_op:\n-\t\t       data += process_extended_line_op (data, linfo.li_default_is_stmt, end);\n-\t\t       break;\n-\n-\t\t     case DW_LNS_copy:\n-\t\t       printf (_(\"  Copy\"));\n-\t\t       if (verbose_view || state_machine_regs.view)\n-\t\t\t printf (_(\" (view %u)\\n\"), state_machine_regs.view);\n-\t\t       else\n-\t\t\t putchar ('\\n');\n-\t\t       state_machine_regs.view++;\n-\t\t       break;\n-\n-\t\t     case DW_LNS_advance_pc:\n-\t\t       uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t       data += bytes_read;\n-\t\t       if (linfo.li_max_ops_per_insn == 1)\n-\t\t\t {\n-\t\t\t   uladv *= linfo.li_min_insn_length;\n-\t\t\t   state_machine_regs.address += uladv;\n-\t\t\t   if (uladv)\n-\t\t\t     state_machine_regs.view = 0;\n-\t\t\t   printf (_(\"  Advance PC by %s to 0x%s%s\\n\"),\n-\t\t\t\t   dwarf_vmatoa (\"u\", uladv),\n-\t\t\t\t   dwarf_vmatoa (\"x\", state_machine_regs.address),\n-\t\t\t\t   verbose_view && uladv\n-\t\t\t\t   ? _(\" (reset view)\") : \"\");\n-\t\t\t }\n-\t\t       else\n-\t\t\t {\n-\t\t\t   unsigned addrdelta\n-\t\t\t     = ((state_machine_regs.op_index + uladv)\n-\t\t\t\t/ linfo.li_max_ops_per_insn)\n-\t\t\t     * linfo.li_min_insn_length;\n-\t\t\t   state_machine_regs.address\n-\t\t\t     += addrdelta;\n-\t\t\t   state_machine_regs.op_index\n-\t\t\t     = (state_machine_regs.op_index + uladv)\n-\t\t\t     % linfo.li_max_ops_per_insn;\n-\t\t\t   if (addrdelta)\n-\t\t\t     state_machine_regs.view = 0;\n-\t\t\t   printf (_(\"  Advance PC by %s to 0x%s[%d]%s\\n\"),\n-\t\t\t\t   dwarf_vmatoa (\"u\", uladv),\n-\t\t\t\t   dwarf_vmatoa (\"x\", state_machine_regs.address),\n-\t\t\t\t   state_machine_regs.op_index,\n-\t\t\t\t   verbose_view && addrdelta\n-\t\t\t\t   ? _(\" (reset view)\") : \"\");\n-\t\t\t }\n-\t\t       break;\n-\n-\t\t     case DW_LNS_advance_line:\n-\t\t       adv = read_sleb128 (data, & bytes_read, end);\n-\t\t       data += bytes_read;\n-\t\t       state_machine_regs.line += adv;\n-\t\t       printf (_(\"  Advance Line by %s to %d\\n\"),\n-\t\t\t       dwarf_vmatoa (\"d\", adv),\n-\t\t\t       state_machine_regs.line);\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_file:\n-\t\t       adv = read_uleb128 (data, & bytes_read, end);\n-\t\t       data += bytes_read;\n-\t\t       printf (_(\"  Set File Name to entry %s in the File Name Table\\n\"),\n-\t\t\t       dwarf_vmatoa (\"d\", adv));\n-\t\t       state_machine_regs.file = adv;\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_column:\n-\t\t       uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t       data += bytes_read;\n-\t\t       printf (_(\"  Set column to %s\\n\"),\n-\t\t\t       dwarf_vmatoa (\"u\", uladv));\n-\t\t       state_machine_regs.column = uladv;\n-\t\t       break;\n-\n-\t\t     case DW_LNS_negate_stmt:\n-\t\t       adv = state_machine_regs.is_stmt;\n-\t\t       adv = ! adv;\n-\t\t       printf (_(\"  Set is_stmt to %s\\n\"), dwarf_vmatoa (\"d\", adv));\n-\t\t       state_machine_regs.is_stmt = adv;\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_basic_block:\n-\t\t       printf (_(\"  Set basic block\\n\"));\n-\t\t       state_machine_regs.basic_block = 1;\n-\t\t       break;\n-\n-\t\t     case DW_LNS_const_add_pc:\n-\t\t       uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n-\t\t       if (linfo.li_max_ops_per_insn)\n-\t\t\t {\n-\t\t\t   uladv *= linfo.li_min_insn_length;\n-\t\t\t   state_machine_regs.address += uladv;\n-\t\t\t   if (uladv)\n-\t\t\t     state_machine_regs.view = 0;\n-\t\t\t   printf (_(\"  Advance PC by constant %s to 0x%s%s\\n\"),\n-\t\t\t\t   dwarf_vmatoa (\"u\", uladv),\n-\t\t\t\t   dwarf_vmatoa (\"x\", state_machine_regs.address),\n-\t\t\t\t   verbose_view && uladv\n-\t\t\t\t   ? _(\" (reset view)\") : \"\");\n-\t\t\t }\n-\t\t       else\n-\t\t\t {\n-\t\t\t   unsigned addrdelta\n-\t\t\t     = ((state_machine_regs.op_index + uladv)\n-\t\t\t\t/ linfo.li_max_ops_per_insn)\n-\t\t\t     * linfo.li_min_insn_length;\n-\t\t\t   state_machine_regs.address\n-\t\t\t     += addrdelta;\n-\t\t\t   state_machine_regs.op_index\n-\t\t\t     = (state_machine_regs.op_index + uladv)\n-\t\t\t     % linfo.li_max_ops_per_insn;\n-\t\t\t   if (addrdelta)\n-\t\t\t     state_machine_regs.view = 0;\n-\t\t\t   printf (_(\"  Advance PC by constant %s to 0x%s[%d]%s\\n\"),\n-\t\t\t\t   dwarf_vmatoa (\"u\", uladv),\n-\t\t\t\t   dwarf_vmatoa (\"x\", state_machine_regs.address),\n-\t\t\t\t   state_machine_regs.op_index,\n-\t\t\t\t   verbose_view && addrdelta\n-\t\t\t\t   ? _(\" (reset view)\") : \"\");\n-\t\t\t }\n-\t\t       break;\n-\n-\t\t     case DW_LNS_fixed_advance_pc:\n-\t\t       SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n-\t\t       state_machine_regs.address += uladv;\n-\t\t       state_machine_regs.op_index = 0;\n-\t\t       printf (_(\"  Advance PC by fixed size amount %s to 0x%s\\n\"),\n-\t\t\t       dwarf_vmatoa (\"u\", uladv),\n-\t\t\t       dwarf_vmatoa (\"x\", state_machine_regs.address));\n-\t\t       /* Do NOT reset view.  */\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_prologue_end:\n-\t\t       printf (_(\"  Set prologue_end to true\\n\"));\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_epilogue_begin:\n-\t\t       printf (_(\"  Set epilogue_begin to true\\n\"));\n-\t\t       break;\n-\n-\t\t     case DW_LNS_set_isa:\n-\t\t       uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t       data += bytes_read;\n-\t\t       printf (_(\"  Set ISA to %s\\n\"), dwarf_vmatoa (\"u\", uladv));\n-\t\t       break;\n-\n-\t\t     default:\n-\t\t       printf (_(\"  Unknown opcode %d with operands: \"), op_code);\n-\n-\t\t       if (standard_opcodes != NULL)\n-\t\t\t for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n-\t\t\t   {\n-\t\t\t     printf (\"0x%s%s\", dwarf_vmatoa (\"x\", read_uleb128 (data,\n-\t\t\t\t\t\t\t\t\t\t&bytes_read, end)),\n-\t\t\t\t     i == 1 ? \"\" : \", \");\n-\t\t\t     data += bytes_read;\n-\t\t\t   }\n-\t\t       putchar ('\\n');\n-\t\t       break;\n-\t\t     }\n+\t      else\n+\t\tswitch (op_code)\n+\t\t  {\n+\t\t  case DW_LNS_extended_op:\n+\t\t    data += process_extended_line_op (data,\n+\t\t\t\t\t\t      linfo.li_default_is_stmt,\n+\t\t\t\t\t\t      end);\n+\t\t    break;\n+\n+\t\t  case DW_LNS_copy:\n+\t\t    printf (_(\"  Copy\"));\n+\t\t    if (verbose_view || state_machine_regs.view)\n+\t\t      printf (_(\" (view %u)\\n\"), state_machine_regs.view);\n+\t\t    else\n+\t\t      putchar ('\\n');\n+\t\t    state_machine_regs.view++;\n+\t\t    break;\n+\n+\t\t  case DW_LNS_advance_pc:\n+\t\t    READ_ULEB (uladv, data, end);\n+\t\t    if (linfo.li_max_ops_per_insn == 1)\n+\t\t      {\n+\t\t\tuladv *= linfo.li_min_insn_length;\n+\t\t\tstate_machine_regs.address += uladv;\n+\t\t\tif (uladv)\n+\t\t\t  state_machine_regs.view = 0;\n+\t\t\tprintf (_(\"  Advance PC by %s to 0x%s%s\\n\"),\n+\t\t\t\tdwarf_vmatoa (\"u\", uladv),\n+\t\t\t\tdwarf_vmatoa (\"x\", state_machine_regs.address),\n+\t\t\t\tverbose_view && uladv\n+\t\t\t\t? _(\" (reset view)\") : \"\");\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tunsigned addrdelta\n+\t\t\t  = ((state_machine_regs.op_index + uladv)\n+\t\t\t     / linfo.li_max_ops_per_insn)\n+\t\t\t  * linfo.li_min_insn_length;\n+\t\t\tstate_machine_regs.address\n+\t\t\t  += addrdelta;\n+\t\t\tstate_machine_regs.op_index\n+\t\t\t  = (state_machine_regs.op_index + uladv)\n+\t\t\t  % linfo.li_max_ops_per_insn;\n+\t\t\tif (addrdelta)\n+\t\t\t  state_machine_regs.view = 0;\n+\t\t\tprintf (_(\"  Advance PC by %s to 0x%s[%d]%s\\n\"),\n+\t\t\t\tdwarf_vmatoa (\"u\", uladv),\n+\t\t\t\tdwarf_vmatoa (\"x\", state_machine_regs.address),\n+\t\t\t\tstate_machine_regs.op_index,\n+\t\t\t\tverbose_view && addrdelta\n+\t\t\t\t? _(\" (reset view)\") : \"\");\n+\t\t      }\n+\t\t    break;\n+\n+\t\t  case DW_LNS_advance_line:\n+\t\t    READ_SLEB (adv, data, end);\n+\t\t    state_machine_regs.line += adv;\n+\t\t    printf (_(\"  Advance Line by %s to %d\\n\"),\n+\t\t\t    dwarf_vmatoa (\"d\", adv),\n+\t\t\t    state_machine_regs.line);\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_file:\n+\t\t    READ_ULEB (uladv, data, end);\n+\t\t    printf (_(\"  Set File Name to entry %s in the File Name Table\\n\"),\n+\t\t\t    dwarf_vmatoa (\"u\", uladv));\n+\t\t    state_machine_regs.file = uladv;\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_column:\n+\t\t    READ_ULEB (uladv, data, end);\n+\t\t    printf (_(\"  Set column to %s\\n\"),\n+\t\t\t    dwarf_vmatoa (\"u\", uladv));\n+\t\t    state_machine_regs.column = uladv;\n+\t\t    break;\n+\n+\t\t  case DW_LNS_negate_stmt:\n+\t\t    adv = state_machine_regs.is_stmt;\n+\t\t    adv = ! adv;\n+\t\t    printf (_(\"  Set is_stmt to %s\\n\"), dwarf_vmatoa (\"d\", adv));\n+\t\t    state_machine_regs.is_stmt = adv;\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_basic_block:\n+\t\t    printf (_(\"  Set basic block\\n\"));\n+\t\t    state_machine_regs.basic_block = 1;\n+\t\t    break;\n+\n+\t\t  case DW_LNS_const_add_pc:\n+\t\t    uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n+\t\t    if (linfo.li_max_ops_per_insn)\n+\t\t      {\n+\t\t\tuladv *= linfo.li_min_insn_length;\n+\t\t\tstate_machine_regs.address += uladv;\n+\t\t\tif (uladv)\n+\t\t\t  state_machine_regs.view = 0;\n+\t\t\tprintf (_(\"  Advance PC by constant %s to 0x%s%s\\n\"),\n+\t\t\t\tdwarf_vmatoa (\"u\", uladv),\n+\t\t\t\tdwarf_vmatoa (\"x\", state_machine_regs.address),\n+\t\t\t\tverbose_view && uladv\n+\t\t\t\t? _(\" (reset view)\") : \"\");\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tunsigned addrdelta\n+\t\t\t  = ((state_machine_regs.op_index + uladv)\n+\t\t\t     / linfo.li_max_ops_per_insn)\n+\t\t\t  * linfo.li_min_insn_length;\n+\t\t\tstate_machine_regs.address\n+\t\t\t  += addrdelta;\n+\t\t\tstate_machine_regs.op_index\n+\t\t\t  = (state_machine_regs.op_index + uladv)\n+\t\t\t  % linfo.li_max_ops_per_insn;\n+\t\t\tif (addrdelta)\n+\t\t\t  state_machine_regs.view = 0;\n+\t\t\tprintf (_(\"  Advance PC by constant %s to 0x%s[%d]%s\\n\"),\n+\t\t\t\tdwarf_vmatoa (\"u\", uladv),\n+\t\t\t\tdwarf_vmatoa (\"x\", state_machine_regs.address),\n+\t\t\t\tstate_machine_regs.op_index,\n+\t\t\t\tverbose_view && addrdelta\n+\t\t\t\t? _(\" (reset view)\") : \"\");\n+\t\t      }\n+\t\t    break;\n+\n+\t\t  case DW_LNS_fixed_advance_pc:\n+\t\t    SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n+\t\t    state_machine_regs.address += uladv;\n+\t\t    state_machine_regs.op_index = 0;\n+\t\t    printf (_(\"  Advance PC by fixed size amount %s to 0x%s\\n\"),\n+\t\t\t    dwarf_vmatoa (\"u\", uladv),\n+\t\t\t    dwarf_vmatoa (\"x\", state_machine_regs.address));\n+\t\t    /* Do NOT reset view.  */\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_prologue_end:\n+\t\t    printf (_(\"  Set prologue_end to true\\n\"));\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_epilogue_begin:\n+\t\t    printf (_(\"  Set epilogue_begin to true\\n\"));\n+\t\t    break;\n+\n+\t\t  case DW_LNS_set_isa:\n+\t\t    READ_ULEB (uladv, data, end);\n+\t\t    printf (_(\"  Set ISA to %s\\n\"), dwarf_vmatoa (\"u\", uladv));\n+\t\t    break;\n+\n+\t\t  default:\n+\t\t    printf (_(\"  Unknown opcode %d with operands: \"), op_code);\n+\n+\t\t    if (standard_opcodes != NULL)\n+\t\t      for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n+\t\t\t{\n+\t\t\t  READ_ULEB (uladv, data, end);\n+\t\t\t  printf (\"0x%s%s\", dwarf_vmatoa (\"x\", uladv),\n+\t\t\t\t  i == 1 ? \"\" : \", \");\n+\t\t\t}\n+\t\t    putchar ('\\n');\n+\t\t    break;\n+\t\t  }\n \t    }\n \t  putchar ('\\n');\n \t}\n@@ -4490,7 +4337,6 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t    {\n \t      unsigned char *format_start, format_count, *format;\n \t      dwarf_vma formati, entryi;\n-\t      unsigned int bytes_read;\n \n \t      load_debug_section_with_follow (line_str, fileptr);\n \n@@ -4499,14 +4345,11 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t      format_start = data;\n \t      for (formati = 0; formati < format_count; formati++)\n \t\t{\n-\t\t  read_uleb128 (data, & bytes_read, end);\n-\t\t  data += bytes_read;\n-\t\t  read_uleb128 (data, & bytes_read, end);\n-\t\t  data += bytes_read;\n+\t\t  SKIP_ULEB (data, end);\n+\t\t  SKIP_ULEB (data, end);\n \t\t}\n \n-\t      n_directories = read_uleb128 (data, & bytes_read, end);\n-\t      data += bytes_read;\n+\t      READ_ULEB (n_directories, data, end);\n \t      if (data == end)\n \t\t{\n \t\t  warn (_(\"Corrupt directories list\\n\"));\n@@ -4526,10 +4369,8 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t      dwarf_vma content_type, form;\n \t\t      dwarf_vma uvalue;\n \n-\t\t      content_type = read_uleb128 (format, & bytes_read, end);\n-\t\t      format += bytes_read;\n-\t\t      form = read_uleb128 (format, & bytes_read, end);\n-\t\t      format += bytes_read;\n+\t\t      READ_ULEB (content_type, format, end);\n+\t\t      READ_ULEB (form, format, end);\n \t\t      if (data == end)\n \t\t\t{\n \t\t\t  warn (_(\"Corrupt directories list\\n\"));\n@@ -4553,8 +4394,8 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n-\t\t      data = read_and_display_attr_value (0, form, 0, start, data, end,\n-\t\t                                          0, 0,\n+\t\t      data = read_and_display_attr_value (0, form, 0, start,\n+\t\t\t\t\t\t\t  data, end, 0, 0,\n \t\t\t\t\t\t\t  linfo.li_offset_size,\n \t\t\t\t\t\t\t  linfo.li_version,\n \t\t\t\t\t\t\t  NULL, 1, section,\n@@ -4572,14 +4413,11 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t      format_start = data;\n \t      for (formati = 0; formati < format_count; formati++)\n \t\t{\n-\t\t  read_uleb128 (data, & bytes_read, end);\n-\t\t  data += bytes_read;\n-\t\t  read_uleb128 (data, & bytes_read, end);\n-\t\t  data += bytes_read;\n+\t\t  SKIP_ULEB (data, end);\n+\t\t  SKIP_ULEB (data, end);\n \t\t}\n \n-\t      n_files = read_uleb128 (data, & bytes_read, end);\n-\t      data += bytes_read;\n+\t      READ_ULEB (n_files, data, end);\n \t      if (data == end)\n \t\t{\n \t\t  warn (_(\"Corrupt file name list\\n\"));\n@@ -4598,11 +4436,10 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t    {\n \t\t      dwarf_vma content_type, form;\n \t\t      dwarf_vma uvalue;\n+\t\t      unsigned char *tmp;\n \n-\t\t      content_type = read_uleb128 (format, & bytes_read, end);\n-\t\t      format += bytes_read;\n-\t\t      form = read_uleb128 (format, & bytes_read, end);\n-\t\t      format += bytes_read;\n+\t\t      READ_ULEB (content_type, format, end);\n+\t\t      READ_ULEB (form, format, end);\n \t\t      if (data == end)\n \t\t\t{\n \t\t\t  warn (_(\"Corrupt file name list\\n\"));\n@@ -4637,14 +4474,14 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t\t\t\t     end);\n \t\t\t      break;\n \t\t\t    case DW_FORM_udata:\n-\t\t\t      file->directory_index = read_uleb128 (data, NULL,\n-\t\t\t\t\t\t\t\t    end);\n+\t\t\t      tmp = data;\n+\t\t\t      READ_ULEB (file->directory_index, tmp, end);\n \t\t\t      break;\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n-\t\t      data = read_and_display_attr_value (0, form, 0, start, data, end,\n-\t\t\t\t\t\t\t  0, 0,\n+\t\t      data = read_and_display_attr_value (0, form, 0, start,\n+\t\t\t\t\t\t\t  data, end, 0, 0,\n \t\t\t\t\t\t\t  linfo.li_offset_size,\n \t\t\t\t\t\t\t  linfo.li_version,\n \t\t\t\t\t\t\t  NULL, 1, section,\n@@ -4700,18 +4537,12 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \n \t\t  while (data < end && *data != 0)\n \t\t    {\n-\t\t      unsigned int bytes_read;\n-\n-\t\t      /* Skip Name, directory index, last modification time and length\n-\t\t\t of file.  */\n+\t\t      /* Skip Name, directory index, last modification\n+\t\t\t time and length of file.  */\n \t\t      data += strnlen ((char *) data, end - data) + 1;\n-\t\t      read_uleb128 (data, & bytes_read, end);\n-\t\t      data += bytes_read;\n-\t\t      read_uleb128 (data, & bytes_read, end);\n-\t\t      data += bytes_read;\n-\t\t      read_uleb128 (data, & bytes_read, end);\n-\t\t      data += bytes_read;\n-\n+\t\t      SKIP_ULEB (data, end);\n+\t\t      SKIP_ULEB (data, end);\n+\t\t      SKIP_ULEB (data, end);\n \t\t      n_files++;\n \t\t    }\n \n@@ -4728,21 +4559,17 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t\t  i = 0;\n \t\t  while (*ptr_file_name_table != 0)\n \t\t    {\n-\t\t      unsigned int bytes_read;\n-\n \t\t      file_table[i].name = ptr_file_name_table;\n \t\t      ptr_file_name_table += strnlen ((char *) ptr_file_name_table,\n \t\t\t\t\t\t      end - ptr_file_name_table) + 1;\n \n \t\t      /* We are not interested in directory, time or size.  */\n-\t\t      file_table[i].directory_index = read_uleb128 (ptr_file_name_table,\n-\t\t\t\t\t\t\t\t    & bytes_read, end);\n-\t\t      ptr_file_name_table += bytes_read;\n-\t\t      file_table[i].modification_date = read_uleb128 (ptr_file_name_table,\n-\t\t\t\t\t\t\t\t      & bytes_read, end);\n-\t\t      ptr_file_name_table += bytes_read;\n-\t\t      file_table[i].length = read_uleb128 (ptr_file_name_table, & bytes_read, end);\n-\t\t      ptr_file_name_table += bytes_read;\n+\t\t      READ_ULEB (file_table[i].directory_index,\n+\t\t\t\t ptr_file_name_table, end);\n+\t\t      READ_ULEB (file_table[i].modification_date,\n+\t\t\t\t ptr_file_name_table, end);\n+\t\t      READ_ULEB (file_table[i].length,\n+\t\t\t\t ptr_file_name_table, end);\n \t\t      i++;\n \t\t    }\n \t\t  i = 0;\n@@ -4793,7 +4620,6 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t  int xop;\n \t  int adv;\n \t  unsigned long int uladv;\n-\t  unsigned int bytes_read;\n \t  int is_special_opcode = 0;\n \n \t  op_code = *data++;\n@@ -4830,228 +4656,216 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n \t      is_special_opcode = 1;\n \t      /* Increment view after printing this row.  */\n \t    }\n-\t  else switch (op_code)\n-\t\t {\n-\t\t case DW_LNS_extended_op:\n-\t\t   {\n-\t\t     unsigned int ext_op_code_len;\n-\t\t     unsigned char ext_op_code;\n-\t\t     unsigned char *op_code_data = data;\n-\n-\t\t     ext_op_code_len = read_uleb128 (op_code_data, &bytes_read,\n-\t\t\t\t\t\t     end_of_sequence);\n-\t\t     op_code_data += bytes_read;\n-\n-\t\t     if (ext_op_code_len == 0)\n-\t\t       {\n-\t\t\t warn (_(\"Badly formed extended line op encountered!\\n\"));\n-\t\t\t break;\n-\t\t       }\n-\t\t     ext_op_code_len += bytes_read;\n-\t\t     ext_op_code = *op_code_data++;\n-\t\t     xop = ext_op_code;\n-\t\t     xop = -xop;\n-\n-\t\t     switch (ext_op_code)\n-\t\t       {\n-\t\t       case DW_LNE_end_sequence:\n-\t\t\t /* Reset stuff after printing this row.  */\n-\t\t\t break;\n-\t\t       case DW_LNE_set_address:\n-\t\t\t SAFE_BYTE_GET_AND_INC (state_machine_regs.address,\n-\t\t\t\t\t\top_code_data,\n-\t\t\t\t\t\text_op_code_len - bytes_read - 1,\n-\t\t\t\t\t\tend);\n-\t\t\t state_machine_regs.op_index = 0;\n-\t\t\t state_machine_regs.view = 0;\n-\t\t\t break;\n-\t\t       case DW_LNE_define_file:\n-\t\t\t {\n-\t\t\t   file_table = (File_Entry *) xrealloc\n-\t\t\t     (file_table, (n_files + 1) * sizeof (File_Entry));\n-\n-\t\t\t   ++state_machine_regs.last_file_entry;\n-\t\t\t   /* Source file name.  */\n-\t\t\t   file_table[n_files].name = op_code_data;\n-\t\t\t   op_code_data += strlen ((char *) op_code_data) + 1;\n-\t\t\t   /* Directory index.  */\n-\t\t\t   file_table[n_files].directory_index =\n-\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n-\t\t\t\t\t   end_of_sequence);\n-\t\t\t   op_code_data += bytes_read;\n-\t\t\t   /* Last modification time.  */\n-\t\t\t   file_table[n_files].modification_date =\n-\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n-\t\t\t\t\t   end_of_sequence);\n-\t\t\t   op_code_data += bytes_read;\n-\t\t\t   /* File length.  */\n-\t\t\t   file_table[n_files].length =\n-\t\t\t     read_uleb128 (op_code_data, & bytes_read,\n-\t\t\t\t\t   end_of_sequence);\n-\n-\t\t\t   n_files++;\n-\t\t\t   break;\n-\t\t\t }\n-\t\t       case DW_LNE_set_discriminator:\n-\t\t       case DW_LNE_HP_set_sequence:\n-\t\t\t /* Simply ignored.  */\n-\t\t\t break;\n-\n-\t\t       default:\n-\t\t\t printf (_(\"UNKNOWN (%u): length %d\\n\"),\n-\t\t\t\t ext_op_code, ext_op_code_len - bytes_read);\n-\t\t\t break;\n-\t\t       }\n-\t\t     data += ext_op_code_len;\n-\t\t     break;\n-\t\t   }\n-\t\t case DW_LNS_copy:\n-\t\t   /* Increment view after printing this row.  */\n-\t\t   break;\n-\n-\t\t case DW_LNS_advance_pc:\n-\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t   data += bytes_read;\n-\t\t   if (linfo.li_max_ops_per_insn == 1)\n-\t\t     {\n-\t\t       uladv *= linfo.li_min_insn_length;\n-\t\t       state_machine_regs.address += uladv;\n-\t\t       if (uladv)\n-\t\t\t state_machine_regs.view = 0;\n-\t\t     }\n-\t\t   else\n-\t\t     {\n-\t\t       unsigned addrdelta\n-\t\t\t = ((state_machine_regs.op_index + uladv)\n-\t\t\t    / linfo.li_max_ops_per_insn)\n-\t\t\t * linfo.li_min_insn_length;\n-\t\t       state_machine_regs.address\n-\t\t\t += addrdelta;\n-\t\t       state_machine_regs.op_index\n-\t\t\t = (state_machine_regs.op_index + uladv)\n-\t\t\t % linfo.li_max_ops_per_insn;\n-\t\t       if (addrdelta)\n-\t\t\t state_machine_regs.view = 0;\n-\t\t     }\n-\t\t   break;\n-\n-\t\t case DW_LNS_advance_line:\n-\t\t   adv = read_sleb128 (data, & bytes_read, end);\n-\t\t   data += bytes_read;\n-\t\t   state_machine_regs.line += adv;\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_file:\n-\t\t   adv = read_uleb128 (data, & bytes_read, end);\n-\t\t   data += bytes_read;\n-\t\t   state_machine_regs.file = adv;\n-\n-\t\t   {\n-\t\t     unsigned file = state_machine_regs.file - 1;\n-\t\t     unsigned dir;\n-\n-\t\t     if (file_table == NULL || n_files == 0)\n-\t\t       printf (_(\"\\n [Use file table entry %d]\\n\"), file);\n-\t\t     /* PR 20439 */\n-\t\t     else if (file >= n_files)\n-\t\t       {\n-\t\t\t warn (_(\"file index %u > number of files %u\\n\"), file + 1, n_files);\n-\t\t\t printf (_(\"\\n <over large file table index %u>\"), file);\n-\t\t       }\n-\t\t     else if ((dir = file_table[file].directory_index) == 0)\n-\t\t       /* If directory index is 0, that means current directory.  */\n-\t\t       printf (\"\\n./%s:[++]\\n\", file_table[file].name);\n-\t\t     else if (directory_table == NULL || n_directories == 0)\n-\t\t       printf (_(\"\\n [Use file %s in directory table entry %d]\\n\"),\n-\t\t\t       file_table[file].name, dir);\n-\t\t     /* PR 20439 */\n-\t\t     else if (dir > n_directories)\n-\t\t       {\n-\t\t\t warn (_(\"directory index %u > number of directories %s\\n\"),\n-\t\t\t       dir, dwarf_vmatoa (\"u\", n_directories));\n-\t\t\t printf (_(\"\\n <over large directory table entry %u>\\n\"), dir);\n-\t\t       }\n-\t\t     else\n-\t\t       printf (\"\\n%s/%s:\\n\",\n-\t\t\t       /* The directory index starts counting at 1.  */\n-\t\t\t       directory_table[dir - 1], file_table[file].name);\n-\t\t   }\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_column:\n-\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t   data += bytes_read;\n-\t\t   state_machine_regs.column = uladv;\n-\t\t   break;\n-\n-\t\t case DW_LNS_negate_stmt:\n-\t\t   adv = state_machine_regs.is_stmt;\n-\t\t   adv = ! adv;\n-\t\t   state_machine_regs.is_stmt = adv;\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_basic_block:\n-\t\t   state_machine_regs.basic_block = 1;\n-\t\t   break;\n-\n-\t\t case DW_LNS_const_add_pc:\n-\t\t   uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n-\t\t   if (linfo.li_max_ops_per_insn == 1)\n-\t\t     {\n-\t\t       uladv *= linfo.li_min_insn_length;\n-\t\t       state_machine_regs.address += uladv;\n-\t\t       if (uladv)\n-\t\t\t state_machine_regs.view = 0;\n-\t\t     }\n-\t\t   else\n-\t\t     {\n-\t\t       unsigned addrdelta\n-\t\t\t = ((state_machine_regs.op_index + uladv)\n-\t\t\t    / linfo.li_max_ops_per_insn)\n-\t\t\t * linfo.li_min_insn_length;\n-\t\t       state_machine_regs.address\n-\t\t\t += addrdelta;\n-\t\t       state_machine_regs.op_index\n-\t\t\t = (state_machine_regs.op_index + uladv)\n-\t\t\t % linfo.li_max_ops_per_insn;\n-\t\t       if (addrdelta)\n-\t\t\t state_machine_regs.view = 0;\n-\t\t     }\n-\t\t   break;\n-\n-\t\t case DW_LNS_fixed_advance_pc:\n-\t\t   SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n-\t\t   state_machine_regs.address += uladv;\n-\t\t   state_machine_regs.op_index = 0;\n-\t\t   /* Do NOT reset view.  */\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_prologue_end:\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_epilogue_begin:\n-\t\t   break;\n-\n-\t\t case DW_LNS_set_isa:\n-\t\t   uladv = read_uleb128 (data, & bytes_read, end);\n-\t\t   data += bytes_read;\n-\t\t   printf (_(\"  Set ISA to %lu\\n\"), uladv);\n-\t\t   break;\n-\n-\t\t default:\n-\t\t   printf (_(\"  Unknown opcode %d with operands: \"), op_code);\n-\n-\t\t   if (standard_opcodes != NULL)\n-\t\t     for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n-\t\t       {\n-\t\t\t printf (\"0x%s%s\", dwarf_vmatoa (\"x\", read_uleb128 (data,\n-\t\t\t\t\t\t\t\t\t    &bytes_read, end)),\n-\t\t\t\t i == 1 ? \"\" : \", \");\n-\t\t\t data += bytes_read;\n-\t\t       }\n-\t\t   putchar ('\\n');\n-\t\t   break;\n-\t\t }\n+\t  else\n+\t    switch (op_code)\n+\t      {\n+\t      case DW_LNS_extended_op:\n+\t\t{\n+\t\t  unsigned int ext_op_code_len;\n+\t\t  unsigned char ext_op_code;\n+\t\t  unsigned char *op_code_end;\n+\t\t  unsigned char *op_code_data = data;\n+\n+\t\t  READ_ULEB (ext_op_code_len, op_code_data, end_of_sequence);\n+\t\t  op_code_end = op_code_data + ext_op_code_len;\n+\t\t  if (ext_op_code_len == 0 || op_code_end > end_of_sequence)\n+\t\t    {\n+\t\t      warn (_(\"Badly formed extended line op encountered!\\n\"));\n+\t\t      break;\n+\t\t    }\n+\t\t  ext_op_code = *op_code_data++;\n+\t\t  xop = ext_op_code;\n+\t\t  xop = -xop;\n+\n+\t\t  switch (ext_op_code)\n+\t\t    {\n+\t\t    case DW_LNE_end_sequence:\n+\t\t      /* Reset stuff after printing this row.  */\n+\t\t      break;\n+\t\t    case DW_LNE_set_address:\n+\t\t      SAFE_BYTE_GET_AND_INC (state_machine_regs.address,\n+\t\t\t\t\t     op_code_data,\n+\t\t\t\t\t     op_code_end - op_code_data,\n+\t\t\t\t\t     op_code_end);\n+\t\t      state_machine_regs.op_index = 0;\n+\t\t      state_machine_regs.view = 0;\n+\t\t      break;\n+\t\t    case DW_LNE_define_file:\n+\t\t      file_table = (File_Entry *) xrealloc\n+\t\t\t(file_table, (n_files + 1) * sizeof (File_Entry));\n+\n+\t\t      ++state_machine_regs.last_file_entry;\n+\t\t      /* Source file name.  */\n+\t\t      file_table[n_files].name = op_code_data;\n+\t\t      op_code_data += strlen ((char *) op_code_data) + 1;\n+\t\t      /* Directory index.  */\n+\t\t      READ_ULEB (file_table[n_files].directory_index,\n+\t\t\t\t op_code_data, op_code_end);\n+\t\t      /* Last modification time.  */\n+\t\t      READ_ULEB (file_table[n_files].modification_date,\n+\t\t\t\t op_code_data, op_code_end);\n+\t\t      /* File length.  */\n+\t\t      READ_ULEB (file_table[n_files].length,\n+\t\t\t\t op_code_data, op_code_end);\n+\t\t      n_files++;\n+\t\t      break;\n+\n+\t\t    case DW_LNE_set_discriminator:\n+\t\t    case DW_LNE_HP_set_sequence:\n+\t\t      /* Simply ignored.  */\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      printf (_(\"UNKNOWN (%u): length %ld\\n\"),\n+\t\t\t      ext_op_code, op_code_data - data);\n+\t\t      break;\n+\t\t    }\n+\t\t  data = op_code_end;\n+\t\t  break;\n+\t\t}\n+\t      case DW_LNS_copy:\n+\t\t/* Increment view after printing this row.  */\n+\t\tbreak;\n+\n+\t      case DW_LNS_advance_pc:\n+\t\tREAD_ULEB (uladv, data, end);\n+\t\tif (linfo.li_max_ops_per_insn == 1)\n+\t\t  {\n+\t\t    uladv *= linfo.li_min_insn_length;\n+\t\t    state_machine_regs.address += uladv;\n+\t\t    if (uladv)\n+\t\t      state_machine_regs.view = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    unsigned addrdelta\n+\t\t      = ((state_machine_regs.op_index + uladv)\n+\t\t\t / linfo.li_max_ops_per_insn)\n+\t\t      * linfo.li_min_insn_length;\n+\t\t    state_machine_regs.address\n+\t\t      += addrdelta;\n+\t\t    state_machine_regs.op_index\n+\t\t      = (state_machine_regs.op_index + uladv)\n+\t\t      % linfo.li_max_ops_per_insn;\n+\t\t    if (addrdelta)\n+\t\t      state_machine_regs.view = 0;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case DW_LNS_advance_line:\n+\t\tREAD_SLEB (adv, data, end);\n+\t\tstate_machine_regs.line += adv;\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_file:\n+\t\tREAD_ULEB (uladv, data, end);\n+\t\tstate_machine_regs.file = uladv;\n+\n+\t\t{\n+\t\t  unsigned file = state_machine_regs.file - 1;\n+\t\t  unsigned dir;\n+\n+\t\t  if (file_table == NULL || n_files == 0)\n+\t\t    printf (_(\"\\n [Use file table entry %d]\\n\"), file);\n+\t\t  /* PR 20439 */\n+\t\t  else if (file >= n_files)\n+\t\t    {\n+\t\t      warn (_(\"file index %u > number of files %u\\n\"), file + 1, n_files);\n+\t\t      printf (_(\"\\n <over large file table index %u>\"), file);\n+\t\t    }\n+\t\t  else if ((dir = file_table[file].directory_index) == 0)\n+\t\t    /* If directory index is 0, that means current directory.  */\n+\t\t    printf (\"\\n./%s:[++]\\n\", file_table[file].name);\n+\t\t  else if (directory_table == NULL || n_directories == 0)\n+\t\t    printf (_(\"\\n [Use file %s in directory table entry %d]\\n\"),\n+\t\t\t    file_table[file].name, dir);\n+\t\t  /* PR 20439 */\n+\t\t  else if (dir > n_directories)\n+\t\t    {\n+\t\t      warn (_(\"directory index %u > number of directories %s\\n\"),\n+\t\t\t    dir, dwarf_vmatoa (\"u\", n_directories));\n+\t\t      printf (_(\"\\n <over large directory table entry %u>\\n\"), dir);\n+\t\t    }\n+\t\t  else\n+\t\t    printf (\"\\n%s/%s:\\n\",\n+\t\t\t    /* The directory index starts counting at 1.  */\n+\t\t\t    directory_table[dir - 1], file_table[file].name);\n+\t\t}\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_column:\n+\t\tREAD_ULEB (uladv, data, end);\n+\t\tstate_machine_regs.column = uladv;\n+\t\tbreak;\n+\n+\t      case DW_LNS_negate_stmt:\n+\t\tadv = state_machine_regs.is_stmt;\n+\t\tadv = ! adv;\n+\t\tstate_machine_regs.is_stmt = adv;\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_basic_block:\n+\t\tstate_machine_regs.basic_block = 1;\n+\t\tbreak;\n+\n+\t      case DW_LNS_const_add_pc:\n+\t\tuladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);\n+\t\tif (linfo.li_max_ops_per_insn == 1)\n+\t\t  {\n+\t\t    uladv *= linfo.li_min_insn_length;\n+\t\t    state_machine_regs.address += uladv;\n+\t\t    if (uladv)\n+\t\t      state_machine_regs.view = 0;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    unsigned addrdelta\n+\t\t      = ((state_machine_regs.op_index + uladv)\n+\t\t\t / linfo.li_max_ops_per_insn)\n+\t\t      * linfo.li_min_insn_length;\n+\t\t    state_machine_regs.address\n+\t\t      += addrdelta;\n+\t\t    state_machine_regs.op_index\n+\t\t      = (state_machine_regs.op_index + uladv)\n+\t\t      % linfo.li_max_ops_per_insn;\n+\t\t    if (addrdelta)\n+\t\t      state_machine_regs.view = 0;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case DW_LNS_fixed_advance_pc:\n+\t\tSAFE_BYTE_GET_AND_INC (uladv, data, 2, end);\n+\t\tstate_machine_regs.address += uladv;\n+\t\tstate_machine_regs.op_index = 0;\n+\t\t/* Do NOT reset view.  */\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_prologue_end:\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_epilogue_begin:\n+\t\tbreak;\n+\n+\t      case DW_LNS_set_isa:\n+\t\tREAD_ULEB (uladv, data, end);\n+\t\tprintf (_(\"  Set ISA to %lu\\n\"), uladv);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tprintf (_(\"  Unknown opcode %d with operands: \"), op_code);\n+\n+\t\tif (standard_opcodes != NULL)\n+\t\t  for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)\n+\t\t    {\n+\t\t      dwarf_vma val;\n+\n+\t\t      READ_ULEB (val, data, end);\n+\t\t      printf (\"0x%s%s\", dwarf_vmatoa (\"x\", val),\n+\t\t\t      i == 1 ? \"\" : \", \");\n+\t\t    }\n+\t\tputchar ('\\n');\n+\t\tbreak;\n+\t      }\n \n \t  /* Only Special opcodes, DW_LNS_copy and DW_LNE_end_sequence adds a row\n \t     to the DWARF address/line matrix.  */\n@@ -5373,7 +5187,6 @@ display_debug_macinfo (struct dwarf_section *section,\n   unsigned char *start = section->start;\n   unsigned char *end = start + section->size;\n   unsigned char *curr = start;\n-  unsigned int bytes_read;\n   enum dwarf_macinfo_record_type op;\n \n   introduce (section, FALSE);\n@@ -5392,11 +5205,8 @@ display_debug_macinfo (struct dwarf_section *section,\n \t  {\n \t    unsigned int filenum;\n \n-\t    lineno = read_uleb128 (curr, & bytes_read, end);\n-\t    curr += bytes_read;\n-\t    filenum = read_uleb128 (curr, & bytes_read, end);\n-\t    curr += bytes_read;\n-\n+\t    READ_ULEB (lineno, curr, end);\n+\t    READ_ULEB (filenum, curr, end);\n \t    printf (_(\" DW_MACINFO_start_file - lineno: %d filenum: %d\\n\"),\n \t\t    lineno, filenum);\n \t  }\n@@ -5407,17 +5217,15 @@ display_debug_macinfo (struct dwarf_section *section,\n \t  break;\n \n \tcase DW_MACINFO_define:\n-\t  lineno = read_uleb128 (curr, & bytes_read, end);\n-\t  curr += bytes_read;\n+\t  READ_ULEB (lineno, curr, end);\n \t  string = curr;\n \t  curr += strnlen ((char *) string, end - string) + 1;\n \t  printf (_(\" DW_MACINFO_define - lineno : %d macro : %s\\n\"),\n \t\t  lineno, string);\n \t  break;\n \n \tcase DW_MACINFO_undef:\n-\t  lineno = read_uleb128 (curr, & bytes_read, end);\n-\t  curr += bytes_read;\n+\t  READ_ULEB (lineno, curr, end);\n \t  string = curr;\n \t  curr += strnlen ((char *) string, end - string) + 1;\n \t  printf (_(\" DW_MACINFO_undef - lineno : %d macro : %s\\n\"),\n@@ -5428,8 +5236,7 @@ display_debug_macinfo (struct dwarf_section *section,\n \t  {\n \t    unsigned int constant;\n \n-\t    constant = read_uleb128 (curr, & bytes_read, end);\n-\t    curr += bytes_read;\n+\t    READ_ULEB (constant, curr, end);\n \t    string = curr;\n \t    curr += strnlen ((char *) string, end - string) + 1;\n \t    printf (_(\" DW_MACINFO_vendor_ext - constant : %d string : %s\\n\"),\n@@ -5454,7 +5261,7 @@ get_line_filename_and_dirname (dwarf_vma line_offset,\n   struct dwarf_section *section = &debug_displays [line].section;\n   unsigned char *hdrptr, *dirtable, *file_name;\n   unsigned int offset_size, initial_length_size;\n-  unsigned int version, opcode_base, bytes_read;\n+  unsigned int version, opcode_base;\n   dwarf_vma length, diridx;\n   const unsigned char * end;\n \n@@ -5514,12 +5321,9 @@ get_line_filename_and_dirname (dwarf_vma line_offset,\n   for (; hdrptr < end && *hdrptr != '\\0' && fileidx > 1; fileidx--)\n     {\n       hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;\n-      read_uleb128 (hdrptr, &bytes_read, end);\n-      hdrptr += bytes_read;\n-      read_uleb128 (hdrptr, &bytes_read, end);\n-      hdrptr += bytes_read;\n-      read_uleb128 (hdrptr, &bytes_read, end);\n-      hdrptr += bytes_read;\n+      SKIP_ULEB (hdrptr, end);\n+      SKIP_ULEB (hdrptr, end);\n+      SKIP_ULEB (hdrptr, end);\n     }\n   if (hdrptr >= end || *hdrptr == '\\0')\n     return NULL;\n@@ -5528,7 +5332,7 @@ get_line_filename_and_dirname (dwarf_vma line_offset,\n   hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;\n   if (hdrptr >= end)\n     return NULL;\n-  diridx = read_uleb128 (hdrptr, &bytes_read, end);\n+  READ_ULEB (diridx, hdrptr, end);\n   if (diridx == 0)\n     return file_name;\n   for (; dirtable < end && *dirtable != '\\0' && diridx > 1; diridx--)\n@@ -5547,7 +5351,6 @@ display_debug_macro (struct dwarf_section *section,\n   unsigned char *end = start + section->size;\n   unsigned char *curr = start;\n   unsigned char *extended_op_buf[256];\n-  unsigned int bytes_read;\n \n   load_debug_section_with_follow (str, file);\n   load_debug_section_with_follow (line, file);\n@@ -5599,8 +5402,7 @@ display_debug_macro (struct dwarf_section *section,\n \t\t{\n \t\t  SAFE_BYTE_GET_AND_INC (op, curr, 1, end);\n \t\t  extended_ops[op] = curr;\n-\t\t  nargs = read_uleb128 (curr, &bytes_read, end);\n-\t\t  curr += bytes_read;\n+\t\t  READ_ULEB (nargs, curr, end);\n \t\t  if (nargs == 0)\n \t\t    printf (_(\"    DW_MACRO_%02x has no arguments\\n\"), op);\n \t\t  else\n@@ -5663,10 +5465,8 @@ display_debug_macro (struct dwarf_section *section,\n \t\tunsigned int filenum;\n \t\tunsigned char *file_name = NULL, *dir_name = NULL;\n \n-\t\tlineno = read_uleb128 (curr, &bytes_read, end);\n-\t\tcurr += bytes_read;\n-\t\tfilenum = read_uleb128 (curr, &bytes_read, end);\n-\t\tcurr += bytes_read;\n+\t\tREAD_ULEB (lineno, curr, end);\n+\t\tREAD_ULEB (filenum, curr, end);\n \n \t\tif ((flags & 2) == 0)\n \t\t  error (_(\"DW_MACRO_start_file used, but no .debug_line offset provided.\\n\"));\n@@ -5690,35 +5490,31 @@ display_debug_macro (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_MACRO_define:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      string = curr;\n \t      curr += strnlen ((char *) string, end - string) + 1;\n \t      printf (_(\" DW_MACRO_define - lineno : %d macro : %s\\n\"),\n \t\t      lineno, string);\n \t      break;\n \n \t    case DW_MACRO_undef:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      string = curr;\n \t      curr += strnlen ((char *) string, end - string) + 1;\n \t      printf (_(\" DW_MACRO_undef - lineno : %d macro : %s\\n\"),\n \t\t      lineno, string);\n \t      break;\n \n \t    case DW_MACRO_define_strp:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);\n \t      string = fetch_indirect_string (offset);\n \t      printf (_(\" DW_MACRO_define_strp - lineno : %d macro : %s\\n\"),\n \t\t      lineno, string);\n \t      break;\n \n \t    case DW_MACRO_undef_strp:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);\n \t      string = fetch_indirect_string (offset);\n \t      printf (_(\" DW_MACRO_undef_strp - lineno : %d macro : %s\\n\"),\n@@ -5732,16 +5528,14 @@ display_debug_macro (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_MACRO_define_sup:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);\n \t      printf (_(\" DW_MACRO_define_sup - lineno : %d macro offset : 0x%lx\\n\"),\n \t\t      lineno, (unsigned long) offset);\n \t      break;\n \n \t    case DW_MACRO_undef_sup:\n-\t      lineno = read_uleb128 (curr, &bytes_read, end);\n-\t      curr += bytes_read;\n+\t      READ_ULEB (lineno, curr, end);\n \t      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);\n \t      printf (_(\" DW_MACRO_undef_sup - lineno : %d macro offset : 0x%lx\\n\"),\n \t\t      lineno, (unsigned long) offset);\n@@ -5764,8 +5558,7 @@ display_debug_macro (struct dwarf_section *section,\n \t\t  /* Skip over unhandled opcodes.  */\n \t\t  dwarf_vma nargs, n;\n \t\t  unsigned char *desc = extended_ops[op];\n-\t\t  nargs = read_uleb128 (desc, &bytes_read, end);\n-\t\t  desc += bytes_read;\n+\t\t  READ_ULEB (nargs, desc, end);\n \t\t  if (nargs == 0)\n \t\t    {\n \t\t      printf (_(\" DW_MACRO_%02x\\n\"), op);\n@@ -5882,18 +5675,11 @@ display_view_pair_list (struct dwarf_section *section,\n       dwarf_vma off = vstart - section->start;\n       dwarf_vma vbegin, vend;\n \n-      unsigned int bytes_read;\n-      vbegin = read_uleb128 (vstart, &bytes_read, section_end);\n-      vstart += bytes_read;\n+      READ_ULEB (vbegin, vstart, section_end);\n       if (vstart == section_end)\n-\t{\n-\t  vstart -= bytes_read;\n-\t  break;\n-\t}\n-\n-      vend = read_uleb128 (vstart, &bytes_read, section_end);\n-      vstart += bytes_read;\n+\tbreak;\n \n+      READ_ULEB (vend, vstart, section_end);\n       printf (\"    %8.8lx \", (unsigned long) off);\n \n       print_dwarf_view (vbegin, pointer_size, 1);\n@@ -5993,16 +5779,12 @@ display_loc_list (struct dwarf_section *section,\n \n       if (vstart)\n \t{\n-\t  unsigned int bytes_read;\n-\n \t  off = offset + (vstart - *start_ptr);\n \n-\t  vbegin = read_uleb128 (vstart, &bytes_read, section_end);\n-\t  vstart += bytes_read;\n+\t  READ_ULEB (vbegin, vstart, section_end);\n \t  print_dwarf_view (vbegin, pointer_size, 1);\n \n-\t  vend = read_uleb128 (vstart, &bytes_read, section_end);\n-\t  vstart += bytes_read;\n+\t  READ_ULEB (vend, vstart, section_end);\n \t  print_dwarf_view (vend, pointer_size, 1);\n \n \t  printf (_(\"views at %8.8lx for:\\n    %*s \"),\n@@ -6071,7 +5853,6 @@ display_loclists_list (struct dwarf_section *section,\n   unsigned int pointer_size;\n   unsigned int offset_size;\n   int dwarf_version;\n-  unsigned int bytes_read;\n \n   /* Initialize it due to a false compiler warning.  */\n   dwarf_vma begin = -1, vbegin = -1;\n@@ -6119,12 +5900,10 @@ display_loclists_list (struct dwarf_section *section,\n \t{\n \t  off = offset + (vstart - *start_ptr);\n \n-\t  vbegin = read_uleb128 (vstart, &bytes_read, section_end);\n-\t  vstart += bytes_read;\n+\t  READ_ULEB (vbegin, vstart, section_end);\n \t  print_dwarf_view (vbegin, pointer_size, 1);\n \n-\t  vend = read_uleb128 (vstart, &bytes_read, section_end);\n-\t  vstart += bytes_read;\n+\t  READ_ULEB (vend, vstart, section_end);\n \t  print_dwarf_view (vend, pointer_size, 1);\n \n \t  printf (_(\"views at %8.8lx for:\\n    %*s \"),\n@@ -6137,10 +5916,8 @@ display_loclists_list (struct dwarf_section *section,\n \t  printf (_(\"<End of list>\\n\"));\n \t  break;\n \tcase DW_LLE_offset_pair:\n-\t  begin = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n-\t  end = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (begin, start, section_end);\n+\t  READ_ULEB (end, start, section_end);\n \t  break;\n \tcase DW_LLE_base_address:\n \t  SAFE_BYTE_GET_AND_INC (base_address, start, pointer_size,\n@@ -6152,12 +5929,10 @@ display_loclists_list (struct dwarf_section *section,\n \tcase DW_LLE_view_pair:\n \t  if (vstart)\n \t    printf (_(\"View pair entry in loclist with locviews attribute\\n\"));\n-\t  vbegin = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (vbegin, start, section_end);\n \t  print_dwarf_view (vbegin, pointer_size, 1);\n \n-\t  vend = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (vend, start, section_end);\n \t  print_dwarf_view (vend, pointer_size, 1);\n \n \t  printf (_(\"views for:\\n\"));\n@@ -6179,8 +5954,7 @@ display_loclists_list (struct dwarf_section *section,\n \t  break;\n \t}\n \n-      length = read_uleb128 (start, &bytes_read, section_end);\n-      start += bytes_read;\n+      READ_ULEB (length, start, section_end);\n \n       print_dwarf_vma (begin + base_address, pointer_size);\n       print_dwarf_vma (end + base_address, pointer_size);\n@@ -6248,7 +6022,6 @@ display_loc_list_dwo (struct dwarf_section *section,\n   unsigned short length;\n   int need_frame_base;\n   unsigned int idx;\n-  unsigned int bytes_read;\n \n   if (debug_info_entry >= num_debug_info_entries)\n     {\n@@ -6295,12 +6068,10 @@ display_loc_list_dwo (struct dwarf_section *section,\n \t      dwarf_vma view;\n \t      dwarf_vma off = offset + (vstart - *start_ptr);\n \n-\t      view = read_uleb128 (vstart, &bytes_read, section_end);\n-\t      vstart += bytes_read;\n+\t      READ_ULEB (view, vstart, section_end);\n \t      print_dwarf_view (view, 8, 1);\n \n-\t      view = read_uleb128 (vstart, &bytes_read, section_end);\n-\t      vstart += bytes_read;\n+\t      READ_ULEB (view, vstart, section_end);\n \t      print_dwarf_view (view, 8, 1);\n \n \t      printf (_(\"views at %8.8lx for:\\n    %*s \"),\n@@ -6318,23 +6089,19 @@ display_loc_list_dwo (struct dwarf_section *section,\n \t  printf (_(\"<End of list>\\n\"));\n \t  return;\n \tcase 1: /* A base-address entry.  */\n-\t  idx = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (idx, start, section_end);\n \t  print_addr_index (idx, 8);\n \t  printf (\"%*s\", 9 + (vstart ? 2 * 6 : 0), \"\");\n \t  printf (_(\"(base address selection entry)\\n\"));\n \t  continue;\n \tcase 2: /* A start/end entry.  */\n-\t  idx = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (idx, start, section_end);\n \t  print_addr_index (idx, 8);\n-\t  idx = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (idx, start, section_end);\n \t  print_addr_index (idx, 8);\n \t  break;\n \tcase 3: /* A start/length entry.  */\n-\t  idx = read_uleb128 (start, &bytes_read, section_end);\n-\t  start += bytes_read;\n+\t  READ_ULEB (idx, start, section_end);\n \t  print_addr_index (idx, 8);\n \t  SAFE_BYTE_GET_AND_INC (idx, start, 4, section_end);\n \t  printf (\"%08x \", idx);\n@@ -7079,7 +6846,6 @@ display_debug_rnglists_list (unsigned char *start, unsigned char *finish,\n       enum dwarf_range_list_entry rlet;\n       /* Initialize it due to a false compiler warning.  */\n       dwarf_vma begin = -1, length, end = -1;\n-      unsigned int bytes_read;\n \n       if (start + 1 > finish)\n \t{\n@@ -7104,15 +6870,12 @@ display_debug_rnglists_list (unsigned char *start, unsigned char *finish,\n \t  break;\n \tcase DW_RLE_start_length:\n \t  SAFE_BYTE_GET_AND_INC (begin, start, pointer_size, finish);\n-\t  length = read_uleb128 (start, &bytes_read, finish);\n-\t  start += bytes_read;\n+\t  READ_ULEB (length, start, finish);\n \t  end = begin + length;\n \t  break;\n \tcase DW_RLE_offset_pair:\n-\t  begin = read_uleb128 (start, &bytes_read, finish);\n-\t  start += bytes_read;\n-\t  end = read_uleb128 (start, &bytes_read, finish);\n-\t  start += bytes_read;\n+\t  READ_ULEB (begin, start, finish);\n+\t  READ_ULEB (end, start, finish);\n \t  break;\n \tcase DW_RLE_start_end:\n \t  SAFE_BYTE_GET_AND_INC (begin, start, pointer_size, finish);\n@@ -7836,7 +7599,6 @@ read_cie (unsigned char *start, unsigned char *end,\n {\n   int version;\n   Frame_Chunk *fc;\n-  unsigned int length_return;\n   unsigned char *augmentation_data = NULL;\n   bfd_size_type augmentation_data_len = 0;\n \n@@ -7893,21 +7655,21 @@ read_cie (unsigned char *start, unsigned char *end,\n       fc->segment_size = 0;\n     }\n \n-  READ_ULEB (fc->code_factor);\n-  READ_SLEB (fc->data_factor);\n+  READ_ULEB (fc->code_factor, start, end);\n+  READ_SLEB (fc->data_factor, start, end);\n \n   if (version == 1)\n     {\n       GET (fc->ra, 1);\n     }\n   else\n     {\n-      READ_ULEB (fc->ra);\n+      READ_ULEB (fc->ra, start, end);\n     }\n \n   if (fc->augmentation[0] == 'z')\n     {\n-      READ_ULEB (augmentation_data_len);\n+      READ_ULEB (augmentation_data_len, start, end);\n       augmentation_data = start;\n       /* PR 17512: file: 11042-2589-0.004.  */\n       if (augmentation_data_len > (bfd_size_type) (end - start))\n@@ -8014,7 +7776,6 @@ display_debug_frames (struct dwarf_section *section,\n   Frame_Chunk *remembered_state = NULL;\n   Frame_Chunk *rs;\n   bfd_boolean is_eh = strcmp (section->name, \".eh_frame\") == 0;\n-  unsigned int length_return;\n   unsigned int max_regs = 0;\n   const char *bad_reg = _(\"bad register: \");\n   unsigned int saved_eh_addr_size = eh_addr_size;\n@@ -8279,7 +8040,7 @@ display_debug_frames (struct dwarf_section *section,\n \n \t  if (cie->augmentation[0] == 'z')\n \t    {\n-\t      READ_ULEB (augmentation_data_len);\n+\t      READ_ULEB (augmentation_data_len, start, end);\n \t      augmentation_data = start;\n \t      /* PR 17512 file: 722-8446-0.004 and PR 22386.  */\n \t      if (augmentation_data_len > (bfd_size_type) (end - start))\n@@ -8346,7 +8107,7 @@ display_debug_frames (struct dwarf_section *section,\n \t\tcase DW_CFA_advance_loc:\n \t\t  break;\n \t\tcase DW_CFA_offset:\n-\t\t  SKIP_ULEB ();\n+\t\t  SKIP_ULEB (start, end);\n \t\t  if (frame_need_space (fc, opa) >= 0)\n \t\t    fc->col_type[opa] = DW_CFA_undefined;\n \t\t  break;\n@@ -8368,44 +8129,44 @@ display_debug_frames (struct dwarf_section *section,\n \t\t  break;\n \t\tcase DW_CFA_offset_extended:\n \t\tcase DW_CFA_val_offset:\n-\t\t  READ_ULEB (reg);\n-\t\t  SKIP_ULEB ();\n+\t\t  READ_ULEB (reg, start, end);\n+\t\t  SKIP_ULEB (start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_restore_extended:\n-\t\t  READ_ULEB (reg);\n+\t\t  READ_ULEB (reg, start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_undefined:\n-\t\t  READ_ULEB (reg);\n+\t\t  READ_ULEB (reg, start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_same_value:\n-\t\t  READ_ULEB (reg);\n+\t\t  READ_ULEB (reg, start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_register:\n-\t\t  READ_ULEB (reg);\n-\t\t  SKIP_ULEB ();\n+\t\t  READ_ULEB (reg, start, end);\n+\t\t  SKIP_ULEB (start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_def_cfa:\n-\t\t  SKIP_ULEB ();\n-\t\t  SKIP_ULEB ();\n+\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_register:\n-\t\t  SKIP_ULEB ();\n+\t\t  SKIP_ULEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_offset:\n-\t\t  SKIP_ULEB ();\n+\t\t  SKIP_ULEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_expression:\n-\t\t  READ_ULEB (temp);\n+\t\t  READ_ULEB (temp, start, end);\n \t\t  new_start = start + temp;\n \t\t  if (new_start < start)\n \t\t    {\n@@ -8417,8 +8178,8 @@ display_debug_frames (struct dwarf_section *section,\n \t\t  break;\n \t\tcase DW_CFA_expression:\n \t\tcase DW_CFA_val_expression:\n-\t\t  READ_ULEB (reg);\n-\t\t  READ_ULEB (temp);\n+\t\t  READ_ULEB (reg, start, end);\n+\t\t  READ_ULEB (temp, start, end);\n \t\t  new_start = start + temp;\n \t\t  if (new_start < start)\n \t\t    {\n@@ -8433,27 +8194,27 @@ display_debug_frames (struct dwarf_section *section,\n \t\t  break;\n \t\tcase DW_CFA_offset_extended_sf:\n \t\tcase DW_CFA_val_offset_sf:\n-\t\t  READ_ULEB (reg);\n-\t\t  SKIP_SLEB ();\n+\t\t  READ_ULEB (reg, start, end);\n+\t\t  SKIP_SLEB (start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_sf:\n-\t\t  SKIP_ULEB ();\n-\t\t  SKIP_SLEB ();\n+\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_SLEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_offset_sf:\n-\t\t  SKIP_SLEB ();\n+\t\t  SKIP_SLEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_MIPS_advance_loc8:\n \t\t  start += 8;\n \t\t  break;\n \t\tcase DW_CFA_GNU_args_size:\n-\t\t  SKIP_ULEB ();\n+\t\t  SKIP_ULEB (start, end);\n \t\t  break;\n \t\tcase DW_CFA_GNU_negative_offset_extended:\n-\t\t  READ_ULEB (reg);\n-\t\t  SKIP_ULEB ();\n+\t\t  READ_ULEB (reg, start, end);\n+\t\t  SKIP_ULEB (start, end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n@@ -8509,7 +8270,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_offset:\n-\t      READ_ULEB (roffs);\n+\t      READ_ULEB (roffs, start, end);\n \t      if (opa >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8596,8 +8357,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_offset_extended:\n-\t      READ_ULEB (reg);\n-\t      READ_ULEB (roffs);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (roffs, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8612,8 +8373,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_val_offset:\n-\t      READ_ULEB (reg);\n-\t      READ_ULEB (roffs);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (roffs, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8628,7 +8389,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_restore_extended:\n-\t      READ_ULEB (reg);\n+\t      READ_ULEB (reg, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8650,7 +8411,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_undefined:\n-\t      READ_ULEB (reg);\n+\t      READ_ULEB (reg, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8664,7 +8425,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_same_value:\n-\t      READ_ULEB (reg);\n+\t      READ_ULEB (reg, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8678,8 +8439,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_register:\n-\t      READ_ULEB (reg);\n-\t      READ_ULEB (roffs);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (roffs, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8742,24 +8503,24 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa:\n-\t      READ_ULEB (fc->cfa_reg);\n-\t      READ_ULEB (fc->cfa_offset);\n+\t      READ_ULEB (fc->cfa_reg, start, end);\n+\t      READ_ULEB (fc->cfa_offset, start, end);\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa: %s ofs %d\\n\",\n \t\t\tregname (fc->cfa_reg, 0), (int) fc->cfa_offset);\n \t      break;\n \n \t    case DW_CFA_def_cfa_register:\n-\t      READ_ULEB (fc->cfa_reg);\n+\t      READ_ULEB (fc->cfa_reg, start, end);\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_register: %s\\n\",\n \t\t\tregname (fc->cfa_reg, 0));\n \t      break;\n \n \t    case DW_CFA_def_cfa_offset:\n-\t      READ_ULEB (fc->cfa_offset);\n+\t      READ_ULEB (fc->cfa_offset, start, end);\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_offset: %d\\n\", (int) fc->cfa_offset);\n \t      break;\n@@ -8770,7 +8531,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_expression:\n-\t      READ_ULEB (ul);\n+\t      READ_ULEB (ul, start, end);\n \t      if (start >= block_end || ul > (unsigned long) (block_end - start))\n \t\t{\n \t\t  printf (_(\"  DW_CFA_def_cfa_expression: <corrupt len %lu>\\n\"), ul);\n@@ -8788,8 +8549,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_expression:\n-\t      READ_ULEB (reg);\n-\t      READ_ULEB (ul);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (ul, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      /* PR 17512: file: 069-133014-0.006.  */\n@@ -8814,8 +8575,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_val_expression:\n-\t      READ_ULEB (reg);\n-\t      READ_ULEB (ul);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (ul, start, end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      tmp = start + ul;\n@@ -8838,8 +8599,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_offset_extended_sf:\n-\t      READ_ULEB (reg);\n-\t      READ_SLEB (l);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_SLEB (l, start, end);\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8854,8 +8615,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_val_offset_sf:\n-\t      READ_ULEB (reg);\n-\t      READ_SLEB (l);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_SLEB (l, start, end);\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -8870,8 +8631,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_sf:\n-\t      READ_ULEB (fc->cfa_reg);\n-\t      READ_ULEB (fc->cfa_offset);\n+\t      READ_ULEB (fc->cfa_reg, start, end);\n+\t      READ_ULEB (fc->cfa_offset, start, end);\n \t      fc->cfa_offset = fc->cfa_offset * fc->data_factor;\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n@@ -8880,7 +8641,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_offset_sf:\n-\t      READ_ULEB (fc->cfa_offset);\n+\t      READ_ULEB (fc->cfa_offset, start, end);\n \t      fc->cfa_offset *= fc->data_factor;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_offset_sf: %d\\n\", (int) fc->cfa_offset);\n@@ -8905,14 +8666,14 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_GNU_args_size:\n-\t      READ_ULEB (ul);\n+\t      READ_ULEB (ul, start, end);\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_GNU_args_size: %ld\\n\", ul);\n \t      break;\n \n \t    case DW_CFA_GNU_negative_offset_extended:\n-\t      READ_ULEB (reg);\n-\t      READ_SLEB (l);\n+\t      READ_ULEB (reg, start, end);\n+\t      READ_SLEB (l, start, end);\n \t      l = - l;\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;\n@@ -9203,10 +8964,9 @@ display_debug_names (struct dwarf_section *section, void *file)\n       unsigned char *abbrevptr = abbrev_table;\n       for (;;)\n \t{\n-\t  unsigned int bytes_read;\n-\t  const dwarf_vma abbrev_tag = read_uleb128 (abbrevptr, &bytes_read,\n-\t\t\t\t\t\t     abbrev_table_end);\n-\t  abbrevptr += bytes_read;\n+\t  dwarf_vma abbrev_tag;\n+\n+\t  READ_ULEB (abbrev_tag, abbrevptr, abbrev_table_end);\n \t  if (abbrev_tag == 0)\n \t    break;\n \t  if (abbrev_lookup_used == abbrev_lookup_allocated)\n@@ -9234,17 +8994,13 @@ display_debug_names (struct dwarf_section *section, void *file)\n \t  entry->abbrev_lookup_ptr = abbrevptr;\n \n \t  /* Skip DWARF tag.  */\n-\t  read_uleb128 (abbrevptr, &bytes_read, abbrev_table_end);\n-\t  abbrevptr += bytes_read;\n+\t  SKIP_ULEB (abbrevptr, abbrev_table_end);\n \t  for (;;)\n \t    {\n-\t      const dwarf_vma xindex = read_uleb128 (abbrevptr,\n-\t\t\t\t\t\t     &bytes_read,\n-\t\t\t\t\t\t     abbrev_table_end);\n-\t      abbrevptr += bytes_read;\n-\t      const dwarf_vma form = read_uleb128 (abbrevptr, &bytes_read,\n-\t\t\t\t\t\t   abbrev_table_end);\n-\t      abbrevptr += bytes_read;\n+\t      dwarf_vma xindex, form;\n+\n+\t      READ_ULEB (xindex, abbrevptr, abbrev_table_end);\n+\t      READ_ULEB (form, abbrevptr, abbrev_table_end);\n \t      if (xindex == 0 && form == 0)\n \t\tbreak;\n \t    }\n@@ -9277,10 +9033,11 @@ display_debug_names (struct dwarf_section *section, void *file)\n \t  dwarf_vma second_abbrev_tag = -1;\n \t  for (;;)\n \t    {\n-\t      unsigned int bytes_read;\n-\t      const dwarf_vma abbrev_tag = read_uleb128 (entryptr, &bytes_read,\n-\t\t\t\t\t\t\t unit_end);\n-\t      entryptr += bytes_read;\n+\t      dwarf_vma abbrev_tag;\n+\t      dwarf_vma dwarf_tag;\n+\t      const struct abbrev_lookup_entry *entry;\n+\n+\t      READ_ULEB (abbrev_tag, entryptr, unit_end);\n \t      if (tagno == -1)\n \t\t{\n \t\t  second_abbrev_tag = abbrev_tag;\n@@ -9295,7 +9052,6 @@ display_debug_names (struct dwarf_section *section, void *file)\n \t\t        (tagno == 0 && second_abbrev_tag == 0 ? \" \" : \"\\n\\t\"),\n \t\t\t(unsigned long) abbrev_tag);\n \n-\t      const struct abbrev_lookup_entry *entry;\n \t      for (entry = abbrev_lookup;\n \t\t   entry < abbrev_lookup + abbrev_lookup_used;\n \t\t   entry++)\n@@ -9310,20 +9066,15 @@ display_debug_names (struct dwarf_section *section, void *file)\n \t\t  break;\n \t\t}\n \t      abbrevptr = entry->abbrev_lookup_ptr;\n-\t      const dwarf_vma dwarf_tag = read_uleb128 (abbrevptr, &bytes_read,\n-\t\t\t\t\t\t\tabbrev_table_end);\n-\t      abbrevptr += bytes_read;\n+\t      READ_ULEB (dwarf_tag, abbrevptr, abbrev_table_end);\n \t      if (tagno >= 0)\n \t\tprintf (\" %s\", get_TAG_name (dwarf_tag));\n \t      for (;;)\n \t\t{\n-\t\t  const dwarf_vma xindex = read_uleb128 (abbrevptr,\n-\t\t\t\t\t\t\t &bytes_read,\n-\t\t\t\t\t\t\t abbrev_table_end);\n-\t\t  abbrevptr += bytes_read;\n-\t\t  const dwarf_vma form = read_uleb128 (abbrevptr, &bytes_read,\n-\t\t\t\t\t\t       abbrev_table_end);\n-\t\t  abbrevptr += bytes_read;\n+\t\t  dwarf_vma xindex, form;\n+\n+\t\t  READ_ULEB (xindex, abbrevptr, abbrev_table_end);\n+\t\t  READ_ULEB (form, abbrevptr, abbrev_table_end);\n \t\t  if (xindex == 0 && form == 0)\n \t\t    break;\n "
    },
    {
      "sha": "cfb3abea3b074d6552435fe968df36668feaec15",
      "filename": "binutils/dwarf.h",
      "status": "modified",
      "additions": 58,
      "deletions": 2,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/dwarf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/dwarf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.h?ref=cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
      "patch": "@@ -248,9 +248,65 @@ extern void * xcalloc2 (size_t, size_t);\n extern void * xcmalloc (size_t, size_t);\n extern void * xcrealloc (void *, size_t, size_t);\n \n-extern dwarf_vma read_leb128 (unsigned char *, unsigned int *, bfd_boolean, const unsigned char * const);\n-\n /* A callback into the client.  Returns TRUE if there is a\n    relocation against the given debug section at the given\n    offset.  */\n extern bfd_boolean reloc_at (struct dwarf_section *, dwarf_vma);\n+\n+extern dwarf_vma read_leb128 (unsigned char *, const unsigned char *const,\n+\t\t\t      bfd_boolean, unsigned int *, int *);\n+\n+static inline void\n+report_leb_status (int status)\n+{\n+  if ((status & 1) != 0)\n+    error (_(\"LEB end of data\\n\"));\n+  else if ((status & 2) != 0)\n+    error (_(\"LEB value too large\\n\"));\n+}\n+\n+#define SKIP_ULEB(start, end)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      unsigned int _len;\t\t\t\t\t\\\n+      read_leb128 (start, end, FALSE, &_len, NULL);\t\t\\\n+      start += _len;\t\t\t\t\t\t\\\n+    } while (0)\n+\n+#define SKIP_SLEB(start, end)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      unsigned int _len;\t\t\t\t\t\\\n+      read_leb128 (start, end, TRUE, &_len, NULL);\t\t\\\n+      start += _len;\t\t\t\t\t\t\\\n+    } while (0)\n+\n+#define READ_ULEB(var, start, end)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      dwarf_vma _val;\t\t\t\t\t\t\\\n+      unsigned int _len;\t\t\t\t\t\\\n+      int _status;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      _val = read_leb128 (start, end, FALSE, &_len, &_status);\t\\\n+      start += _len;\t\t\t\t\t\t\\\n+      (var) = _val;\t\t\t\t\t\t\\\n+      if ((var) != _val)\t\t\t\t\t\\\n+\t_status |= 2;\t\t\t\t\t\t\\\n+      report_leb_status (_status);\t\t\t\t\\\n+    } while (0)\n+\n+#define READ_SLEB(var, start, end)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      dwarf_signed_vma _val;\t\t\t\t\t\\\n+      unsigned int _len;\t\t\t\t\t\\\n+      int _status;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      _val = read_leb128 (start, end, TRUE, &_len, &_status);\t\\\n+      start += _len;\t\t\t\t\t\t\\\n+      (var) = _val;\t\t\t\t\t\t\\\n+      if ((var) != _val)\t\t\t\t\t\\\n+\t_status |= 2;\t\t\t\t\t\t\\\n+      report_leb_status (_status);\t\t\t\t\\\n+    } while (0)"
    },
    {
      "sha": "0853c1f0a14f01a7ac9a8212249a4ffc91215d11",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 71,
      "deletions": 154,
      "changes": 225,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=cd30bcef4a685ae4a67f8b4a793af0cf7230b9fc",
      "patch": "@@ -749,17 +749,6 @@ find_section_in_set (Filedata * filedata, const char * name, unsigned int * set)\n   return find_section (filedata, name);\n }\n \n-/* Read an unsigned LEB128 encoded value from DATA.\n-   Set *LENGTH_RETURN to the number of bytes read.  */\n-\n-static inline unsigned long\n-read_uleb128 (unsigned char * data,\n-\t      unsigned int * length_return,\n-\t      const unsigned char * const end)\n-{\n-  return read_leb128 (data, length_return, FALSE, end);\n-}\n-\n /* Return TRUE if the current file is for IA-64 machine and OpenVMS ABI.\n    This OS has so many departures from the ELF standard that we test it at\n    many places.  */\n@@ -8782,7 +8771,7 @@ decode_arm_unwind_bytecode (Filedata *                 filedata,\n \t    }\n \t  else\n \t    {\n-\t      offset = read_uleb128 (buf, &len, buf + i + 1);\n+\t      offset = read_leb128 (buf, buf + i + 1, FALSE, &len, NULL);\n \t      assert (len == i + 1);\n \t      offset = offset * 4 + 0x204;\n \t      printf (\"vsp = vsp + %ld\", offset);\n@@ -9001,7 +8990,7 @@ decode_tic6x_unwind_bytecode (Filedata *                 filedata,\n \t      return FALSE;\n \t    }\n \n-\t  offset = read_uleb128 (buf, &len, buf + i + 1);\n+\t  offset = read_leb128 (buf, buf + i + 1, FALSE, &len, NULL);\n \t  assert (len == i + 1);\n \t  offset = offset * 8 + 0x408;\n \t  printf (_(\"sp = sp + %ld\"), offset);\n@@ -14492,10 +14481,7 @@ display_tag_value (signed int tag,\n     }\n   else\n     {\n-      unsigned int len;\n-\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"%ld (0x%lx)\\n\", val, val);\n     }\n \n@@ -14510,17 +14496,14 @@ display_arc_attribute (unsigned char * p,\n \t\t       const unsigned char * const end)\n {\n   unsigned int tag;\n-  unsigned int len;\n   unsigned int val;\n \n-  tag = read_uleb128 (p, &len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n \n   switch (tag)\n     {\n     case Tag_ARC_PCS_config:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_PCS_config: \");\n       switch (val)\n \t{\n@@ -14546,8 +14529,7 @@ display_arc_attribute (unsigned char * p,\n       break;\n \n     case Tag_ARC_CPU_base:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_CPU_base: \");\n       switch (val)\n \t{\n@@ -14571,8 +14553,7 @@ display_arc_attribute (unsigned char * p,\n       break;\n \n     case Tag_ARC_CPU_variation:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_CPU_variation: \");\n       switch (val)\n \t{\n@@ -14595,21 +14576,18 @@ display_arc_attribute (unsigned char * p,\n       break;\n \n     case Tag_ARC_ABI_rf16:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_rf16: %s\\n\", val ? _(\"yes\") : _(\"no\"));\n       break;\n \n     case Tag_ARC_ABI_osver:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_osver: v%d\\n\", val);\n       break;\n \n     case Tag_ARC_ABI_pic:\n     case Tag_ARC_ABI_sda:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (tag == Tag_ARC_ABI_sda ? \"  Tag_ARC_ABI_sda: \"\n \t      : \"  Tag_ARC_ABI_pic: \");\n       switch (val)\n@@ -14630,28 +14608,24 @@ display_arc_attribute (unsigned char * p,\n       break;\n \n     case Tag_ARC_ABI_tls:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_tls: %s\\n\", val ? \"r25\": \"none\");\n       break;\n \n     case Tag_ARC_ABI_enumsize:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_enumsize: %s\\n\", val ? _(\"default\") :\n \t      _(\"smallest\"));\n       break;\n \n     case Tag_ARC_ABI_exceptions:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_exceptions: %s\\n\", val ? _(\"OPTFP\")\n \t      : _(\"default\"));\n       break;\n \n     case Tag_ARC_ABI_double_size:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ABI_double_size: %d\\n\", val);\n       break;\n \n@@ -14666,14 +14640,12 @@ display_arc_attribute (unsigned char * p,\n       break;\n \n     case Tag_ARC_ISA_mpy_option:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ISA_mpy_option: %d\\n\", val);\n       break;\n \n     case Tag_ARC_ATR_version:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ARC_ATR_version: %d\\n\", val);\n       break;\n \n@@ -14818,14 +14790,12 @@ display_arm_attribute (unsigned char * p,\n \t\t       const unsigned char * const end)\n {\n   unsigned int tag;\n-  unsigned int len;\n   unsigned int val;\n   arm_attr_public_tag * attr;\n   unsigned i;\n   unsigned int type;\n \n-  tag = read_uleb128 (p, &len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n   attr = NULL;\n   for (i = 0; i < ARRAY_SIZE (arm_attr_public_tags); i++)\n     {\n@@ -14845,8 +14815,7 @@ display_arm_attribute (unsigned char * p,\n \t  switch (tag)\n \t    {\n \t    case 7: /* Tag_CPU_arch_profile.  */\n-\t      val = read_uleb128 (p, &len, end);\n-\t      p += len;\n+\t      READ_ULEB (val, p, end);\n \t      switch (val)\n \t\t{\n \t\tcase 0: printf (_(\"None\\n\")); break;\n@@ -14859,8 +14828,7 @@ display_arm_attribute (unsigned char * p,\n \t      break;\n \n \t    case 24: /* Tag_align_needed.  */\n-\t      val = read_uleb128 (p, &len, end);\n-\t      p += len;\n+\t      READ_ULEB (val, p, end);\n \t      switch (val)\n \t\t{\n \t\tcase 0: printf (_(\"None\\n\")); break;\n@@ -14878,8 +14846,7 @@ display_arm_attribute (unsigned char * p,\n \t      break;\n \n \t    case 25: /* Tag_align_preserved.  */\n-\t      val = read_uleb128 (p, &len, end);\n-\t      p += len;\n+\t      READ_ULEB (val, p, end);\n \t      switch (val)\n \t\t{\n \t\tcase 0: printf (_(\"None\\n\")); break;\n@@ -14898,8 +14865,7 @@ display_arm_attribute (unsigned char * p,\n \n \t    case 32: /* Tag_compatibility.  */\n \t      {\n-\t\tval = read_uleb128 (p, &len, end);\n-\t\tp += len;\n+\t\tREAD_ULEB (val, p, end);\n \t\tprintf (_(\"flag = %d, vendor = \"), val);\n \t\tif (p < end - 1)\n \t\t  {\n@@ -14925,12 +14891,10 @@ display_arm_attribute (unsigned char * p,\n \t      break;\n \n \t    case 65: /* Tag_also_compatible_with.  */\n-\t      val = read_uleb128 (p, &len, end);\n-\t      p += len;\n+\t      READ_ULEB (val, p, end);\n \t      if (val == 6 /* Tag_CPU_arch.  */)\n \t\t{\n-\t\t  val = read_uleb128 (p, &len, end);\n-\t\t  p += len;\n+\t\t  READ_ULEB (val, p, end);\n \t\t  if ((unsigned int) val >= ARRAY_SIZE (arm_attr_tag_CPU_arch))\n \t\t    printf (\"??? (%d)\\n\", val);\n \t\t  else\n@@ -14955,8 +14919,7 @@ display_arm_attribute (unsigned char * p,\n \n \tdefault:\n \t  assert (attr->type & 0x80);\n-\t  val = read_uleb128 (p, &len, end);\n-\t  p += len;\n+\t  READ_ULEB (val, p, end);\n \t  type = attr->type & 0x7f;\n \t  if (val >= type)\n \t    printf (\"??? (%d)\\n\", val);\n@@ -14974,19 +14937,16 @@ display_gnu_attribute (unsigned char * p,\n \t\t       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const),\n \t\t       const unsigned char * const end)\n {\n-  int tag;\n-  unsigned int len;\n+  unsigned int tag;\n   unsigned int val;\n \n-  tag = read_uleb128 (p, &len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n \n   /* Tag_compatibility is the only generic GNU attribute defined at\n      present.  */\n   if (tag == 32)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n \n       printf (_(\"flag = %d, vendor = \"), val);\n       if (p == end)\n@@ -15024,19 +14984,17 @@ display_power_gnu_attribute (unsigned char * p,\n \t\t\t     unsigned int tag,\n \t\t\t     const unsigned char * const end)\n {\n-  unsigned int len;\n   unsigned int val;\n \n   if (tag == Tag_GNU_Power_ABI_FP)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_Power_ABI_FP: \");\n-      if (len == 0)\n+      if (p == end)\n \t{\n \t  printf (_(\"<corrupt>\\n\"));\n \t  return p;\n \t}\n+      READ_ULEB (val, p, end);\n \n       if (val > 15)\n \tprintf (\"(%#x), \", val);\n@@ -15077,14 +15035,13 @@ display_power_gnu_attribute (unsigned char * p,\n \n   if (tag == Tag_GNU_Power_ABI_Vector)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_Power_ABI_Vector: \");\n-      if (len == 0)\n+      if (p == end)\n \t{\n \t  printf (_(\"<corrupt>\\n\"));\n \t  return p;\n \t}\n+      READ_ULEB (val, p, end);\n \n       if (val > 3)\n \tprintf (\"(%#x), \", val);\n@@ -15109,14 +15066,13 @@ display_power_gnu_attribute (unsigned char * p,\n \n   if (tag == Tag_GNU_Power_ABI_Struct_Return)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_Power_ABI_Struct_Return: \");\n-      if (len == 0)\n+      if (p == end)\n \t{\n \t  printf (_(\"<corrupt>\\n\"));\n \t  return p;\n \t}\n+      READ_ULEB (val, p, end);\n \n       if (val > 2)\n \tprintf (\"(%#x), \", val);\n@@ -15147,14 +15103,12 @@ display_s390_gnu_attribute (unsigned char * p,\n \t\t\t    unsigned int tag,\n \t\t\t    const unsigned char * const end)\n {\n-  unsigned int len;\n-  int val;\n+  unsigned int val;\n \n   if (tag == Tag_GNU_S390_ABI_Vector)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_S390_ABI_Vector: \");\n+      READ_ULEB (val, p, end);\n \n       switch (val)\n \t{\n@@ -15262,21 +15216,18 @@ display_sparc_gnu_attribute (unsigned char * p,\n \t\t\t     unsigned int tag,\n \t\t\t     const unsigned char * const end)\n {\n-  unsigned int len;\n-  int val;\n+  unsigned int val;\n \n   if (tag == Tag_GNU_Sparc_HWCAPS)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_GNU_Sparc_HWCAPS: \");\n       display_sparc_hwcaps (val);\n       return p;\n     }\n   if (tag == Tag_GNU_Sparc_HWCAPS2)\n     {\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_GNU_Sparc_HWCAPS2: \");\n       display_sparc_hwcaps2 (val);\n       return p;\n@@ -15330,26 +15281,20 @@ display_mips_gnu_attribute (unsigned char * p,\n {\n   if (tag == Tag_GNU_MIPS_ABI_FP)\n     {\n-      unsigned int len;\n       unsigned int val;\n \n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_MIPS_ABI_FP: \");\n-\n+      READ_ULEB (val, p, end);\n       print_mips_fp_abi_value (val);\n-\n       return p;\n    }\n \n   if (tag == Tag_GNU_MIPS_ABI_MSA)\n     {\n-      unsigned int len;\n       unsigned int val;\n \n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_MIPS_ABI_MSA: \");\n+      READ_ULEB (val, p, end);\n \n       switch (val)\n \t{\n@@ -15374,18 +15319,15 @@ display_tic6x_attribute (unsigned char * p,\n \t\t\t const unsigned char * const end)\n {\n   unsigned int tag;\n-  unsigned int len;\n-  int val;\n+  unsigned int val;\n \n-  tag = read_uleb128 (p, &len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n \n   switch (tag)\n     {\n     case Tag_ISA:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_ISA: \");\n+      READ_ULEB (val, p, end);\n \n       switch (val)\n \t{\n@@ -15417,9 +15359,8 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_wchar_t:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_ABI_wchar_t: \");\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0:\n@@ -15438,9 +15379,8 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_stack_align_needed:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_ABI_stack_align_needed: \");\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0:\n@@ -15456,8 +15396,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_stack_align_preserved:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_stack_align_preserved: \");\n       switch (val)\n \t{\n@@ -15474,8 +15413,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_DSBT:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_DSBT: \");\n       switch (val)\n \t{\n@@ -15492,8 +15430,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_PID:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_PID: \");\n       switch (val)\n \t{\n@@ -15513,8 +15450,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_PIC:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_PIC: \");\n       switch (val)\n \t{\n@@ -15531,8 +15467,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_array_object_alignment:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_array_object_alignment: \");\n       switch (val)\n \t{\n@@ -15552,8 +15487,7 @@ display_tic6x_attribute (unsigned char * p,\n       return p;\n \n     case Tag_ABI_array_object_align_expected:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       printf (\"  Tag_ABI_array_object_align_expected: \");\n       switch (val)\n \t{\n@@ -15574,8 +15508,7 @@ display_tic6x_attribute (unsigned char * p,\n \n     case Tag_ABI_compatibility:\n       {\n-\tval = read_uleb128 (p, &len, end);\n-\tp += len;\n+\tREAD_ULEB (val, p, end);\n \tprintf (\"  Tag_ABI_compatibility: \");\n \tprintf (_(\"flag = %d, vendor = \"), val);\n \tif (p < end - 1)\n@@ -15666,19 +15599,16 @@ static unsigned char *\n display_msp430x_attribute (unsigned char * p,\n \t\t\t   const unsigned char * const end)\n {\n-  unsigned int len;\n   unsigned int val;\n   unsigned int tag;\n \n-  tag = read_uleb128 (p, & len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n \n   switch (tag)\n     {\n     case OFBA_MSPABI_Tag_ISA:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_ISA: \");\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0: printf (_(\"None\\n\")); break;\n@@ -15689,9 +15619,8 @@ display_msp430x_attribute (unsigned char * p,\n       break;\n \n     case OFBA_MSPABI_Tag_Code_Model:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_Code_Model: \");\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0: printf (_(\"None\\n\")); break;\n@@ -15702,9 +15631,8 @@ display_msp430x_attribute (unsigned char * p,\n       break;\n \n     case OFBA_MSPABI_Tag_Data_Model:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_Data_Model: \");\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0: printf (_(\"None\\n\")); break;\n@@ -15737,8 +15665,7 @@ display_msp430x_attribute (unsigned char * p,\n \t}\n       else\n \t{\n-\t  val = read_uleb128 (p, &len, end);\n-\t  p += len;\n+\t  READ_ULEB (val, p, end);\n \t  printf (\"%d (0x%x)\\n\", val, val);\n \t}\n       break;\n@@ -15755,12 +15682,10 @@ display_msp430_gnu_attribute (unsigned char * p,\n {\n   if (tag == Tag_GNU_MSP430_Data_Region)\n     {\n-      unsigned int len;\n-      int val;\n+      unsigned int val;\n \n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n       printf (\"  Tag_GNU_MSP430_Data_Region: \");\n+      READ_ULEB (val, p, end);\n \n       switch (val)\n \t{\n@@ -15771,7 +15696,7 @@ display_msp430_gnu_attribute (unsigned char * p,\n \t  printf (_(\"Lower Region Only\\n\"));\n \t  break;\n \tdefault:\n-\t  printf (\"??? (%d)\\n\", val);\n+\t  printf (\"??? (%u)\\n\", val);\n \t}\n       return p;\n     }\n@@ -15780,7 +15705,7 @@ display_msp430_gnu_attribute (unsigned char * p,\n \n struct riscv_attr_tag_t {\n   const char *name;\n-  int tag;\n+  unsigned int tag;\n };\n \n static struct riscv_attr_tag_t riscv_attr_tag[] =\n@@ -15799,14 +15724,12 @@ static unsigned char *\n display_riscv_attribute (unsigned char *p,\n \t\t\t const unsigned char * const end)\n {\n-  unsigned int len;\n-  int val;\n-  int tag;\n+  unsigned int val;\n+  unsigned int tag;\n   struct riscv_attr_tag_t *attr = NULL;\n   unsigned i;\n \n-  tag = read_uleb128 (p, &len, end);\n-  p += len;\n+  READ_ULEB (tag, p, end);\n \n   /* Find the name of attribute. */\n   for (i = 0; i < ARRAY_SIZE (riscv_attr_tag); i++)\n@@ -15828,13 +15751,11 @@ display_riscv_attribute (unsigned char *p,\n     case Tag_RISCV_priv_spec:\n     case Tag_RISCV_priv_spec_minor:\n     case Tag_RISCV_priv_spec_revision:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n-      printf (_(\"%d\\n\"), val);\n+      READ_ULEB (val, p, end);\n+      printf (_(\"%u\\n\"), val);\n       break;\n     case Tag_RISCV_unaligned_access:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n+      READ_ULEB (val, p, end);\n       switch (val)\n \t{\n \tcase 0:\n@@ -15846,9 +15767,8 @@ display_riscv_attribute (unsigned char *p,\n \t}\n       break;\n     case Tag_RISCV_stack_align:\n-      val = read_uleb128 (p, &len, end);\n-      p += len;\n-      printf (_(\"%d-bytes\\n\"), val);\n+      READ_ULEB (val, p, end);\n+      printf (_(\"%u-bytes\\n\"), val);\n       break;\n     case Tag_RISCV_arch:\n       p = display_tag_value (-1, p, end);\n@@ -15967,7 +15887,7 @@ process_attributes (Filedata * filedata,\n \t      while (attr_len > 0 && p < contents + sect->sh_size)\n \t\t{\n \t\t  int tag;\n-\t\t  int val;\n+\t\t  unsigned int val;\n \t\t  bfd_vma size;\n \t\t  unsigned char * end;\n \n@@ -16018,10 +15938,7 @@ process_attributes (Filedata * filedata,\n \t\t    do_numlist:\n \t\t      for (;;)\n \t\t\t{\n-\t\t\t  unsigned int j;\n-\n-\t\t\t  val = read_uleb128 (p, &j, end);\n-\t\t\t  p += j;\n+\t\t\t  READ_ULEB (val, p, end);\n \t\t\t  if (val == 0)\n \t\t\t    break;\n \t\t\t  printf (\" %d\", val);"
    }
  ]
}