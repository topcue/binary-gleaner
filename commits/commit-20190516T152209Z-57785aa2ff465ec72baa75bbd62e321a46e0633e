{
  "sha": "57785aa2ff465ec72baa75bbd62e321a46e0633e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTc3ODVhYTJmZjQ2NWVjNzJiYWE3NWJiZDYyZTMyMWE0NmUwNjMzZQ==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-15T16:31:25Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:22:09Z"
    },
    "message": "[PATCH 9/57][Arm][GAS] Add support for MVE instructions: vmov\n\ngas/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/tc-arm.c (struct arm_it): Expand isscalar field to be able to\n\tdistinguish between types of scalar.\n\t(parse_typed_reg_or_scalar): Change to accept MVE scalar variants.\n\t(parse_scalar): Likewise.\n\t(parse_neon_mov): Accept MVE variant.\n\t(po_scalar_or_goto): Make use reg_type.\n\t(parse_operands): Change uses of po_scalar_or_goto.\n\t(do_vfp_sp_monadic): Change to accept MVE variants.\n\t(do_vfp_reg_from_sp): Likewise.\n\t(do_vfp_sp_from_reg): Likewise.\n\t(do_vfp_dp_rd_rm): Likewise.\n\t(do_vfp_dp_rd_rn_rm): Likewise.\n\t(do_vfp_dp_rm_rd_rn): Likewise.\n\t(M_MNEM_vmovlt, M_MNEM_vmovlb, M_MNEM_vmovnt, M_MNEM_vmovnb): New\n\tinstruction encodings.\n\t(NEON_SHAPE_DEF): New shape.\n\t(do_mve_mov): New encoding fuction.\n\t(do_mve_movn): Likewise.\n\t(do_mve_movl): Likewise.\n\t(do_neon_mov): Change to accept MVE variants.\n\t(mcCE): New MACRO.\n\t(insns): Accept new MVE variants and instructions.\n\t* testsuite/gas/arm/mve-vmov-bad-1.d: New test.\n\t* testsuite/gas/arm/mve-vmov-bad-1.l: New test.\n\t* testsuite/gas/arm/mve-vmov-bad-1.s: New test.\n\t* testsuite/gas/arm/mve-vmov-bad-2.d: New test.\n\t* testsuite/gas/arm/mve-vmov-bad-2.l: New test.\n\t* testsuite/gas/arm/mve-vmov-bad-2.s: New test.",
    "tree": {
      "sha": "449b80604992e8cc530d897812a604b4ec172b16",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/449b80604992e8cc530d897812a604b4ec172b16"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/57785aa2ff465ec72baa75bbd62e321a46e0633e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57785aa2ff465ec72baa75bbd62e321a46e0633e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/57785aa2ff465ec72baa75bbd62e321a46e0633e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/57785aa2ff465ec72baa75bbd62e321a46e0633e/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dd9634d97c05168870624cadf8fddf9b62ee3008",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd9634d97c05168870624cadf8fddf9b62ee3008",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd9634d97c05168870624cadf8fddf9b62ee3008"
    }
  ],
  "stats": {
    "total": 604,
    "additions": 520,
    "deletions": 84
  },
  "files": [
    {
      "sha": "6d4342a1cfae75e53946d5b546f5c516a60cc9b3",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -1,3 +1,34 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/tc-arm.c (struct arm_it): Expand isscalar field to be able to\n+\tdistinguish between types of scalar.\n+\t(parse_typed_reg_or_scalar): Change to accept MVE scalar variants.\n+\t(parse_scalar): Likewise.\n+\t(parse_neon_mov): Accept MVE variant.\n+\t(po_scalar_or_goto): Make use reg_type.\n+\t(parse_operands): Change uses of po_scalar_or_goto.\n+\t(do_vfp_sp_monadic): Change to accept MVE variants.\n+\t(do_vfp_reg_from_sp): Likewise.\n+\t(do_vfp_sp_from_reg): Likewise.\n+\t(do_vfp_dp_rd_rm): Likewise.\n+\t(do_vfp_dp_rd_rn_rm): Likewise.\n+\t(do_vfp_dp_rm_rd_rn): Likewise.\n+\t(M_MNEM_vmovlt, M_MNEM_vmovlb, M_MNEM_vmovnt, M_MNEM_vmovnb): New\n+\tinstruction encodings.\n+\t(NEON_SHAPE_DEF): New shape.\n+\t(do_mve_mov): New encoding fuction.\n+\t(do_mve_movn): Likewise.\n+\t(do_mve_movl): Likewise.\n+\t(do_neon_mov): Change to accept MVE variants.\n+\t(mcCE): New MACRO.\n+\t(insns): Accept new MVE variants and instructions.\n+\t* testsuite/gas/arm/mve-vmov-bad-1.d: New test.\n+\t* testsuite/gas/arm/mve-vmov-bad-1.l: New test.\n+\t* testsuite/gas/arm/mve-vmov-bad-1.s: New test.\n+\t* testsuite/gas/arm/mve-vmov-bad-2.d: New test.\n+\t* testsuite/gas/arm/mve-vmov-bad-2.l: New test.\n+\t* testsuite/gas/arm/mve-vmov-bad-2.s: New test.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* config/tc-arm.c (enum operand_parse_code): Add new operand."
    },
    {
      "sha": "b103345078121f6c72039f41de4cfd8fb2bfcf0d",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 405,
      "deletions": 84,
      "changes": 489,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -510,7 +510,10 @@ struct arm_it\n     unsigned isreg\t: 1;  /* Operand was a register.  */\n     unsigned immisreg\t: 2;  /* .imm field is a second register.\n \t\t\t\t 0: imm, 1: gpr, 2: MVE Q-register.  */\n-    unsigned isscalar   : 1;  /* Operand is a (Neon) scalar.  */\n+    unsigned isscalar   : 2;  /* Operand is a (SIMD) scalar:\n+\t\t\t\t 0) not scalar,\n+\t\t\t\t 1) Neon scalar,\n+\t\t\t\t 2) MVE scalar.  */\n     unsigned immisalign : 1;  /* Immediate is an alignment specifier.  */\n     unsigned immisfloat : 1;  /* Immediate was parsed as a float.  */\n     /* Note: we abuse \"regisimm\" to mean \"is Neon register\" in VMOV\n@@ -1653,9 +1656,14 @@ parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,\n     {\n       if (type != REG_TYPE_VFD\n \t  && !(type == REG_TYPE_VFS\n-\t       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8_2)))\n+\t       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8_2))\n+\t  && !(type == REG_TYPE_NQ\n+\t       && ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext)))\n \t{\n-\t  first_error (_(\"only D registers may be indexed\"));\n+\t  if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\t    first_error (_(\"only D and Q registers may be indexed\"));\n+\t  else\n+\t    first_error (_(\"only D registers may be indexed\"));\n \t  return FAIL;\n \t}\n \n@@ -1744,27 +1752,41 @@ arm_typed_reg_parse (char **ccp, enum arm_reg_type type,\n    just do easy checks here, and do further checks later.  */\n \n static int\n-parse_scalar (char **ccp, int elsize, struct neon_type_el *type)\n+parse_scalar (char **ccp, int elsize, struct neon_type_el *type, enum\n+\t      arm_reg_type reg_type)\n {\n   int reg;\n   char *str = *ccp;\n   struct neon_typed_alias atype;\n-  enum arm_reg_type reg_type = REG_TYPE_VFD;\n-\n-  if (elsize == 4)\n-    reg_type = REG_TYPE_VFS;\n+  unsigned reg_size;\n \n   reg = parse_typed_reg_or_scalar (&str, reg_type, NULL, &atype);\n \n+  switch (reg_type)\n+    {\n+    case REG_TYPE_VFS:\n+      reg_size = 32;\n+      break;\n+    case REG_TYPE_VFD:\n+      reg_size = 64;\n+      break;\n+    case REG_TYPE_MQ:\n+      reg_size = 128;\n+      break;\n+    default:\n+      gas_assert (0);\n+      return FAIL;\n+    }\n+\n   if (reg == FAIL || (atype.defined & NTA_HASINDEX) == 0)\n     return FAIL;\n \n-  if (atype.index == NEON_ALL_LANES)\n+  if (reg_type != REG_TYPE_MQ && atype.index == NEON_ALL_LANES)\n     {\n       first_error (_(\"scalar must have an index\"));\n       return FAIL;\n     }\n-  else if (atype.index >= 64 / elsize)\n+  else if (atype.index >= reg_size / elsize)\n     {\n       first_error (_(\"scalar index out of range\"));\n       return FAIL;\n@@ -6539,7 +6561,61 @@ parse_neon_mov (char **str, int *which_operand)\n   char *ptr = *str;\n   struct neon_type_el optype;\n \n-  if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)\n+   if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_MQ)) != FAIL)\n+    {\n+      /* Cases 17 or 19.  */\n+      inst.operands[i].reg = val;\n+      inst.operands[i].isvec = 1;\n+      inst.operands[i].isscalar = 2;\n+      inst.operands[i].vectype = optype;\n+      inst.operands[i++].present = 1;\n+\n+      if (skip_past_comma (&ptr) == FAIL)\n+\tgoto wanted_comma;\n+\n+      if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)\n+\t{\n+\t  /* Case 17: VMOV<c>.<dt> <Qd[idx]>, <Rt>  */\n+\t  inst.operands[i].reg = val;\n+\t  inst.operands[i].isreg = 1;\n+\t  inst.operands[i].present = 1;\n+\t}\n+      else if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_MQ)) != FAIL)\n+\t{\n+\t  /* Case 19: VMOV<c> <Qd[idx]>, <Qd[idx2]>, <Rt>, <Rt2>  */\n+\t  inst.operands[i].reg = val;\n+\t  inst.operands[i].isvec = 1;\n+\t  inst.operands[i].isscalar = 2;\n+\t  inst.operands[i].vectype = optype;\n+\t  inst.operands[i++].present = 1;\n+\n+\t  if (skip_past_comma (&ptr) == FAIL)\n+\t    goto wanted_comma;\n+\n+\t  if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)\n+\t    goto wanted_arm;\n+\n+\t  inst.operands[i].reg = val;\n+\t  inst.operands[i].isreg = 1;\n+\t  inst.operands[i++].present = 1;\n+\n+\t  if (skip_past_comma (&ptr) == FAIL)\n+\t    goto wanted_comma;\n+\n+\t  if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) == FAIL)\n+\t    goto wanted_arm;\n+\n+\t  inst.operands[i].reg = val;\n+\t  inst.operands[i].isreg = 1;\n+\t  inst.operands[i].present = 1;\n+\t}\n+      else\n+\t{\n+\t  first_error (_(\"expected ARM or MVE vector register\"));\n+\t  return FAIL;\n+\t}\n+    }\n+   else if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_VFD)) != FAIL)\n     {\n       /* Case 4: VMOV<c><q>.<size> <Dn[x]>, <Rd>.  */\n       inst.operands[i].reg = val;\n@@ -6557,8 +6633,10 @@ parse_neon_mov (char **str, int *which_operand)\n       inst.operands[i].isreg = 1;\n       inst.operands[i].present = 1;\n     }\n-  else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype, &optype))\n-\t   != FAIL)\n+  else if (((val = arm_typed_reg_parse (&ptr, REG_TYPE_NSDQ, &rtype, &optype))\n+\t    != FAIL)\n+\t   || ((val = arm_typed_reg_parse (&ptr, REG_TYPE_MQ, &rtype, &optype))\n+\t       != FAIL))\n     {\n       /* Cases 0, 1, 2, 3, 5 (D only).  */\n       if (skip_past_comma (&ptr) == FAIL)\n@@ -6655,15 +6733,23 @@ parse_neon_mov (char **str, int *which_operand)\n     }\n   else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)\n     {\n-      /* Cases 6, 7.  */\n+      /* Cases 6, 7, 16, 18.  */\n       inst.operands[i].reg = val;\n       inst.operands[i].isreg = 1;\n       inst.operands[i++].present = 1;\n \n       if (skip_past_comma (&ptr) == FAIL)\n \tgoto wanted_comma;\n \n-      if ((val = parse_scalar (&ptr, 8, &optype)) != FAIL)\n+      if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_MQ)) != FAIL)\n+\t{\n+\t  /* Case 18: VMOV<c>.<dt> <Rt>, <Qn[idx]>  */\n+\t  inst.operands[i].reg = val;\n+\t  inst.operands[i].isscalar = 2;\n+\t  inst.operands[i].present = 1;\n+\t  inst.operands[i].vectype = optype;\n+\t}\n+      else if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_VFD)) != FAIL)\n \t{\n \t  /* Case 6: VMOV<c><q>.<dt> <Rd>, <Dn[x]>  */\n \t  inst.operands[i].reg = val;\n@@ -6673,7 +6759,6 @@ parse_neon_mov (char **str, int *which_operand)\n \t}\n       else if ((val = arm_reg_parse (&ptr, REG_TYPE_RN)) != FAIL)\n \t{\n-\t  /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */\n \t  inst.operands[i].reg = val;\n \t  inst.operands[i].isreg = 1;\n \t  inst.operands[i++].present = 1;\n@@ -6682,37 +6767,70 @@ parse_neon_mov (char **str, int *which_operand)\n \t    goto wanted_comma;\n \n \t  if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFSD, &rtype, &optype))\n-\t      == FAIL)\n+\t      != FAIL)\n \t    {\n-\t      first_error (_(reg_expected_msgs[REG_TYPE_VFSD]));\n-\t      return FAIL;\n-\t    }\n-\n-\t  inst.operands[i].reg = val;\n-\t  inst.operands[i].isreg = 1;\n-\t  inst.operands[i].isvec = 1;\n-\t  inst.operands[i].issingle = (rtype == REG_TYPE_VFS);\n-\t  inst.operands[i].vectype = optype;\n-\t  inst.operands[i].present = 1;\n+\t      /* Case 7: VMOV<c><q> <Rd>, <Rn>, <Dm>  */\n \n-\t  if (rtype == REG_TYPE_VFS)\n-\t    {\n-\t      /* Case 14.  */\n-\t      i++;\n-\t      if (skip_past_comma (&ptr) == FAIL)\n-\t\tgoto wanted_comma;\n-\t      if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,\n-\t\t\t\t\t      &optype)) == FAIL)\n-\t\t{\n-\t\t  first_error (_(reg_expected_msgs[REG_TYPE_VFS]));\n-\t\t  return FAIL;\n-\t\t}\n \t      inst.operands[i].reg = val;\n \t      inst.operands[i].isreg = 1;\n \t      inst.operands[i].isvec = 1;\n-\t      inst.operands[i].issingle = 1;\n+\t      inst.operands[i].issingle = (rtype == REG_TYPE_VFS);\n \t      inst.operands[i].vectype = optype;\n \t      inst.operands[i].present = 1;\n+\n+\t      if (rtype == REG_TYPE_VFS)\n+\t\t{\n+\t\t  /* Case 14.  */\n+\t\t  i++;\n+\t\t  if (skip_past_comma (&ptr) == FAIL)\n+\t\t    goto wanted_comma;\n+\t\t  if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL,\n+\t\t\t\t\t\t  &optype)) == FAIL)\n+\t\t    {\n+\t\t      first_error (_(reg_expected_msgs[REG_TYPE_VFS]));\n+\t\t      return FAIL;\n+\t\t    }\n+\t\t  inst.operands[i].reg = val;\n+\t\t  inst.operands[i].isreg = 1;\n+\t\t  inst.operands[i].isvec = 1;\n+\t\t  inst.operands[i].issingle = 1;\n+\t\t  inst.operands[i].vectype = optype;\n+\t\t  inst.operands[i].present = 1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_MQ))\n+\t\t       != FAIL)\n+\t\t{\n+\t\t  /* Case 16: VMOV<c> <Rt>, <Rt2>, <Qd[idx]>, <Qd[idx2]>  */\n+\t\t  inst.operands[i].reg = val;\n+\t\t  inst.operands[i].isvec = 1;\n+\t\t  inst.operands[i].isscalar = 2;\n+\t\t  inst.operands[i].vectype = optype;\n+\t\t  inst.operands[i++].present = 1;\n+\n+\t\t  if (skip_past_comma (&ptr) == FAIL)\n+\t\t    goto wanted_comma;\n+\n+\t\t  if ((val = parse_scalar (&ptr, 8, &optype, REG_TYPE_MQ))\n+\t\t      == FAIL)\n+\t\t    {\n+\t\t      first_error (_(reg_expected_msgs[REG_TYPE_MQ]));\n+\t\t      return FAIL;\n+\t\t    }\n+\t\t  inst.operands[i].reg = val;\n+\t\t  inst.operands[i].isvec = 1;\n+\t\t  inst.operands[i].isscalar = 2;\n+\t\t  inst.operands[i].vectype = optype;\n+\t\t  inst.operands[i].present = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  first_error (_(\"VFP single, double or MVE vector register\"\n+\t\t\t       \" expected\"));\n+\t\t  return FAIL;\n+\t\t}\n \t    }\n \t}\n       else if ((val = arm_typed_reg_parse (&ptr, REG_TYPE_VFS, NULL, &optype))\n@@ -6989,10 +7107,11 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n-#define po_scalar_or_goto(elsz, label)\t\t\t\t\t\\\n+#define po_scalar_or_goto(elsz, label, reg_type)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      val = parse_scalar (& str, elsz, & inst.operands[i].vectype);\t\\\n+      val = parse_scalar (& str, elsz, & inst.operands[i].vectype,\t\\\n+\t\t\t  reg_type);\t\t\t\t\t\\\n       if (val == FAIL)\t\t\t\t\t\t\t\\\n \tgoto label;\t\t\t\t\t\t\t\\\n       inst.operands[i].reg = val;\t\t\t\t\t\\\n@@ -7140,7 +7259,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \t  break;\n \t/* Neon scalar. Using an element size of 8 means that some invalid\n \t   scalars are accepted here, so deal with those in later code.  */\n-\tcase OP_RNSC:  po_scalar_or_goto (8, failure);    break;\n+\tcase OP_RNSC:  po_scalar_or_goto (8, failure, REG_TYPE_VFD);    break;\n \n \tcase OP_RNDQ_I0:\n \t  {\n@@ -7173,7 +7292,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \n \tcase OP_RR_RNSC:\n \t  {\n-\t    po_scalar_or_goto (8, try_rr);\n+\t    po_scalar_or_goto (8, try_rr, REG_TYPE_VFD);\n \t    break;\n \t    try_rr:\n \t    po_reg_or_fail (REG_TYPE_RN);\n@@ -7186,19 +7305,21 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \ttry_rnsdq_rnsc:\n \tcase OP_RNSDQ_RNSC:\n \t  {\n-\t    po_scalar_or_goto (8, try_nsdq);\n+\t    po_scalar_or_goto (8, try_nsdq, REG_TYPE_VFD);\n+\t    inst.error = 0;\n \t    break;\n \t    try_nsdq:\n \t    po_reg_or_fail (REG_TYPE_NSDQ);\n+\t    inst.error = 0;\n \t  }\n \t  break;\n \n \tcase OP_RNSD_RNSC:\n \t  {\n-\t    po_scalar_or_goto (8, try_s_scalar);\n+\t    po_scalar_or_goto (8, try_s_scalar, REG_TYPE_VFD);\n \t    break;\n \t    try_s_scalar:\n-\t    po_scalar_or_goto (4, try_nsd);\n+\t    po_scalar_or_goto (4, try_nsd, REG_TYPE_VFS);\n \t    break;\n \t    try_nsd:\n \t    po_reg_or_fail (REG_TYPE_NSD);\n@@ -7207,7 +7328,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \n \tcase OP_RNDQ_RNSC:\n \t  {\n-\t    po_scalar_or_goto (8, try_ndq);\n+\t    po_scalar_or_goto (8, try_ndq, REG_TYPE_VFD);\n \t    break;\n \t    try_ndq:\n \t    po_reg_or_fail (REG_TYPE_NDQ);\n@@ -7216,7 +7337,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \n \tcase OP_RND_RNSC:\n \t  {\n-\t    po_scalar_or_goto (8, try_vfd);\n+\t    po_scalar_or_goto (8, try_vfd, REG_TYPE_VFD);\n \t    break;\n \t    try_vfd:\n \t    po_reg_or_fail (REG_TYPE_VFD);\n@@ -10169,6 +10290,10 @@ do_sxth (void)\n static void\n do_vfp_sp_monadic (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1xd)\n+\t      && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t      _(BAD_FPU));\n+\n   encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sd);\n   encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sm);\n }\n@@ -10204,6 +10329,10 @@ do_vfp_sp_dp_cvt (void)\n static void\n do_vfp_reg_from_sp (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1xd)\n+\t     && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t     _(BAD_FPU));\n+\n   inst.instruction |= inst.operands[0].reg << 12;\n   encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Sn);\n }\n@@ -10221,6 +10350,10 @@ do_vfp_reg2_from_sp2 (void)\n static void\n do_vfp_sp_from_reg (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1xd)\n+\t     && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t     _(BAD_FPU));\n+\n   encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Sn);\n   inst.instruction |= inst.operands[1].reg << 12;\n }\n@@ -10323,6 +10456,10 @@ do_vfp_xp_ldstmdb (void)\n static void\n do_vfp_dp_rd_rm (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1)\n+\t      && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t      _(BAD_FPU));\n+\n   encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);\n   encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dm);\n }\n@@ -10344,6 +10481,10 @@ do_vfp_dp_rd_rn (void)\n static void\n do_vfp_dp_rd_rn_rm (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t      && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t      _(BAD_FPU));\n+\n   encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dd);\n   encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dn);\n   encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dm);\n@@ -10358,6 +10499,10 @@ do_vfp_dp_rd (void)\n static void\n do_vfp_dp_rm_rd_rn (void)\n {\n+  constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t      && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t      _(BAD_FPU));\n+\n   encode_arm_vfp_reg (inst.operands[0].reg, VFP_REG_Dm);\n   encode_arm_vfp_reg (inst.operands[1].reg, VFP_REG_Dd);\n   encode_arm_vfp_reg (inst.operands[2].reg, VFP_REG_Dn);\n@@ -13961,6 +14106,10 @@ do_t_loloop (void)\n #define M_MNEM_vldrh\t0xec100e10\n #define M_MNEM_vldrw\t0xec100e40\n #define M_MNEM_vldrd\t0xec100e50\n+#define M_MNEM_vmovlt\t0xeea01f40\n+#define M_MNEM_vmovlb\t0xeea00f40\n+#define M_MNEM_vmovnt\t0xfe311e81\n+#define M_MNEM_vmovnb\t0xfe310e81\n \n /* Neon instruction encoder helpers.  */\n \n@@ -14125,6 +14274,8 @@ NEON_ENC_TAB\n      - a table used to drive neon_select_shape.  */\n \n #define NEON_SHAPE_DEF\t\t\t\\\n+  X(4, (R, R, S, S), QUAD),\t\t\\\n+  X(4, (S, S, R, R), QUAD),\t\t\\\n   X(3, (R, Q, Q), QUAD),\t\t\\\n   X(3, (D, D, D), DOUBLE),\t\t\\\n   X(3, (Q, Q, Q), QUAD),\t\t\\\n@@ -17854,6 +18005,67 @@ do_neon_dup (void)\n     }\n }\n \n+static void\n+do_mve_mov (int toQ)\n+{\n+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+    return;\n+  if (inst.cond > COND_ALWAYS)\n+    inst.pred_insn_type = MVE_UNPREDICABLE_INSN;\n+\n+  unsigned Rt = 0, Rt2 = 1, Q0 = 2, Q1 = 3;\n+  if (toQ)\n+    {\n+      Q0 = 0;\n+      Q1 = 1;\n+      Rt = 2;\n+      Rt2 = 3;\n+    }\n+\n+  constraint (inst.operands[Q0].reg != inst.operands[Q1].reg + 2,\n+\t      _(\"Index one must be [2,3] and index two must be two less than\"\n+\t\t\" index one.\"));\n+  constraint (inst.operands[Rt].reg == inst.operands[Rt2].reg,\n+\t      _(\"General purpose registers may not be the same\"));\n+  constraint (inst.operands[Rt].reg == REG_SP\n+\t      || inst.operands[Rt2].reg == REG_SP,\n+\t      BAD_SP);\n+  constraint (inst.operands[Rt].reg == REG_PC\n+\t      || inst.operands[Rt2].reg == REG_PC,\n+\t      BAD_PC);\n+\n+  inst.instruction = 0xec000f00;\n+  inst.instruction |= HI1 (inst.operands[Q1].reg / 32) << 23;\n+  inst.instruction |= !!toQ << 20;\n+  inst.instruction |= inst.operands[Rt2].reg << 16;\n+  inst.instruction |= LOW4 (inst.operands[Q1].reg / 32) << 13;\n+  inst.instruction |= (inst.operands[Q1].reg % 4) << 4;\n+  inst.instruction |= inst.operands[Rt].reg;\n+}\n+\n+static void\n+do_mve_movn (void)\n+{\n+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+    return;\n+\n+  if (inst.cond > COND_ALWAYS)\n+    inst.pred_insn_type = INSIDE_VPT_INSN;\n+  else\n+    inst.pred_insn_type = MVE_OUTSIDE_PRED_INSN;\n+\n+  struct neon_type_el et = neon_check_type (2, NS_QQ, N_EQK, N_I16 | N_I32\n+\t\t\t\t\t    | N_KEY);\n+\n+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;\n+  inst.instruction |= (neon_logbits (et.size) - 1) << 18;\n+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;\n+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;\n+  inst.instruction |= LOW4 (inst.operands[1].reg);\n+  inst.is_neon = 1;\n+\n+}\n+\n /* VMOV has particularly many variations. It can be one of:\n      0. VMOV<c><q> <Qd>, <Qm>\n      1. VMOV<c><q> <Dd>, <Dm>\n@@ -17883,6 +18095,10 @@ do_neon_dup (void)\n    (Two ARM regs to two VFP singles.)\n     15. VMOV <Sd>, <Se>, <Rn>, <Rm>\n    (Two VFP singles to two ARM regs.)\n+   16. VMOV<c> <Rt>, <Rt2>, <Qd[idx]>, <Qd[idx2]>\n+   17. VMOV<c> <Qd[idx]>, <Qd[idx2]>, <Rt>, <Rt2>\n+   18. VMOV<c>.<dt> <Rt>, <Qn[idx]>\n+   19. VMOV<c>.<dt> <Qd[idx]>, <Rt>\n \n    These cases can be disambiguated using neon_select_shape, except cases 1/9\n    and 3/11 which depend on the operand type too.\n@@ -17898,10 +18114,11 @@ do_neon_dup (void)\n static void\n do_neon_mov (void)\n {\n-  enum neon_shape rs = neon_select_shape (NS_RRFF, NS_FFRR, NS_DRR, NS_RRD,\n-\t\t\t\t\t  NS_QQ, NS_DD, NS_QI, NS_DI, NS_SR,\n-\t\t\t\t\t  NS_RS, NS_FF, NS_FI, NS_RF, NS_FR,\n-\t\t\t\t\t  NS_HR, NS_RH, NS_HI, NS_NULL);\n+  enum neon_shape rs = neon_select_shape (NS_RRSS, NS_SSRR, NS_RRFF, NS_FFRR,\n+\t\t\t\t\t  NS_DRR, NS_RRD, NS_QQ, NS_DD, NS_QI,\n+\t\t\t\t\t  NS_DI, NS_SR, NS_RS, NS_FF, NS_FI,\n+\t\t\t\t\t  NS_RF, NS_FR, NS_HR, NS_RH, NS_HI,\n+\t\t\t\t\t  NS_NULL);\n   struct neon_type_el et;\n   const char *ldconst = 0;\n \n@@ -17920,7 +18137,7 @@ do_neon_mov (void)\n \n     case NS_QQ:  /* case 0/1.  */\n       {\n-\tif (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)\n+\tif (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n \t  return;\n \t/* The architecture manual I have doesn't explicitly state which\n \t   value the U bit should have for register->register moves, but\n@@ -17950,7 +18167,7 @@ do_neon_mov (void)\n       /* fall through.  */\n \n     case NS_QI:  /* case 2/3.  */\n-      if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)\n+      if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n \treturn;\n       inst.instruction = 0x0800010;\n       neon_move_immediate ();\n@@ -17977,12 +18194,31 @@ do_neon_mov (void)\n \tet = neon_check_type (2, NS_NULL, N_8 | N_16 | N_32 | N_KEY, N_EQK);\n \tlogsize = neon_logbits (et.size);\n \n-\tconstraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),\n-\t\t    _(BAD_FPU));\n-\tconstraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)\n-\t\t    && et.size != 32, _(BAD_FPU));\n+\tif (et.size != 32)\n+\t  {\n+\t    if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext)\n+\t\t&& vfp_or_neon_is_neon (NEON_CHECK_ARCH) == FAIL)\n+\t      return;\n+\t  }\n+\telse\n+\t  {\n+\t    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1)\n+\t\t\t&& !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t\t\t_(BAD_FPU));\n+\t  }\n+\n+\tif (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\t  {\n+\t    if (inst.operands[1].reg == REG_SP)\n+\t      as_tsktsk (MVE_BAD_SP);\n+\t    else if (inst.operands[1].reg == REG_PC)\n+\t      as_tsktsk (MVE_BAD_PC);\n+\t  }\n+\tunsigned size = inst.operands[0].isscalar == 1 ? 64 : 128;\n+\n \tconstraint (et.type == NT_invtype, _(\"bad type for scalar\"));\n-\tconstraint (x >= 64 / et.size, _(\"scalar index out of range\"));\n+\tconstraint (x >= size / et.size, _(\"scalar index out of range\"));\n+\n \n \tswitch (et.size)\n \t  {\n@@ -17992,20 +18228,22 @@ do_neon_mov (void)\n \t  default: ;\n \t  }\n \n-\tbcdebits |= x << logsize;\n+\tbcdebits |= (x & ((1 << (3-logsize)) - 1)) << logsize;\n \n \tinst.instruction = 0xe000b10;\n \tdo_vfp_cond_or_thumb ();\n \tinst.instruction |= LOW4 (dn) << 16;\n \tinst.instruction |= HI1 (dn) << 7;\n \tinst.instruction |= inst.operands[1].reg << 12;\n \tinst.instruction |= (bcdebits & 3) << 5;\n-\tinst.instruction |= (bcdebits >> 2) << 21;\n+\tinst.instruction |= ((bcdebits >> 2) & 3) << 21;\n+\tinst.instruction |= (x >> (3-logsize)) << 16;\n       }\n       break;\n \n     case NS_DRR:  /* case 5 (fmdrr).  */\n-      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),\n+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t\t  && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n \t\t  _(BAD_FPU));\n \n       inst.instruction = 0xc400b10;\n@@ -18037,12 +18275,32 @@ do_neon_mov (void)\n \t\t\t      N_EQK, N_S8 | N_S16 | N_U8 | N_U16 | N_32 | N_KEY);\n \tlogsize = neon_logbits (et.size);\n \n-\tconstraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1),\n-\t\t    _(BAD_FPU));\n-\tconstraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1)\n-\t\t    && et.size != 32, _(BAD_FPU));\n+\tif (et.size != 32)\n+\t  {\n+\t    if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext)\n+\t\t&& vfp_or_neon_is_neon (NEON_CHECK_CC\n+\t\t\t\t\t| NEON_CHECK_ARCH) == FAIL)\n+\t      return;\n+\t  }\n+\telse\n+\t  {\n+\t    constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1)\n+\t\t\t&& !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t\t\t_(BAD_FPU));\n+\t  }\n+\n+\tif (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\t  {\n+\t    if (inst.operands[0].reg == REG_SP)\n+\t      as_tsktsk (MVE_BAD_SP);\n+\t    else if (inst.operands[0].reg == REG_PC)\n+\t      as_tsktsk (MVE_BAD_PC);\n+\t  }\n+\n+\tunsigned size = inst.operands[1].isscalar == 1 ? 64 : 128;\n+\n \tconstraint (et.type == NT_invtype, _(\"bad type for scalar\"));\n-\tconstraint (x >= 64 / et.size, _(\"scalar index out of range\"));\n+\tconstraint (x >= size / et.size, _(\"scalar index out of range\"));\n \n \tswitch (et.size)\n \t  {\n@@ -18052,19 +18310,21 @@ do_neon_mov (void)\n \t  default: ;\n \t  }\n \n-\tabcdebits |= x << logsize;\n+\tabcdebits |= (x & ((1 << (3-logsize)) - 1)) << logsize;\n \tinst.instruction = 0xe100b10;\n \tdo_vfp_cond_or_thumb ();\n \tinst.instruction |= LOW4 (dn) << 16;\n \tinst.instruction |= HI1 (dn) << 7;\n \tinst.instruction |= inst.operands[0].reg << 12;\n \tinst.instruction |= (abcdebits & 3) << 5;\n \tinst.instruction |= (abcdebits >> 2) << 21;\n+\tinst.instruction |= (x >> (3-logsize)) << 16;\n       }\n       break;\n \n     case NS_RRD:  /* case 7 (fmrrd).  */\n-      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2),\n+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t\t  && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n \t\t  _(BAD_FPU));\n \n       inst.instruction = 0xc500b10;\n@@ -18131,11 +18391,21 @@ do_neon_mov (void)\n \tdo_scalar_fp16_v82_encode ();\n       break;\n \n+    case NS_RRSS:\n+      do_mve_mov (0);\n+      break;\n+    case NS_SSRR:\n+      do_mve_mov (1);\n+      break;\n+\n     /* The encoders for the fmrrs and fmsrr instructions expect three operands\n        (one of which is a list), but we have parsed four.  Do some fiddling to\n        make the operands what do_vfp_reg2_from_sp2 and do_vfp_sp2_from_reg2\n        expect.  */\n     case NS_RRFF:  /* case 14 (fmrrs).  */\n+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t\t  && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t\t  _(BAD_FPU));\n       constraint (inst.operands[3].reg != inst.operands[2].reg + 1,\n \t\t  _(\"VFP registers must be adjacent\"));\n       inst.operands[2].imm = 2;\n@@ -18144,6 +18414,9 @@ do_neon_mov (void)\n       break;\n \n     case NS_FFRR:  /* case 15 (fmsrr).  */\n+      constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v2)\n+\t\t  && !ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext),\n+\t\t  _(BAD_FPU));\n       constraint (inst.operands[1].reg != inst.operands[0].reg + 1,\n \t\t  _(\"VFP registers must be adjacent\"));\n       inst.operands[1] = inst.operands[2];\n@@ -18163,6 +18436,39 @@ do_neon_mov (void)\n     }\n }\n \n+static void\n+do_mve_movl (void)\n+{\n+  if (!(inst.operands[0].present && inst.operands[0].isquad\n+      && inst.operands[1].present && inst.operands[1].isquad\n+      && !inst.operands[2].present))\n+    {\n+      inst.instruction = 0;\n+      inst.cond = 0xb;\n+      if (thumb_mode)\n+\tset_pred_insn_type (INSIDE_IT_INSN);\n+      do_neon_mov ();\n+      return;\n+    }\n+\n+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+    return;\n+\n+  if (inst.cond != COND_ALWAYS)\n+    inst.pred_insn_type = INSIDE_VPT_INSN;\n+\n+  struct neon_type_el et = neon_check_type (2, NS_QQ, N_EQK, N_S8 | N_U8\n+\t\t\t\t\t    | N_S16 | N_U16 | N_KEY);\n+\n+  inst.instruction |= (et.type == NT_unsigned) << 28;\n+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;\n+  inst.instruction |= (neon_logbits (et.size) + 1) << 19;\n+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;\n+  inst.instruction |= HI1 (inst.operands[1].reg) << 5;\n+  inst.instruction |= LOW4 (inst.operands[1].reg);\n+  inst.is_neon = 1;\n+}\n+\n static void\n do_neon_rshift_round_imm (void)\n {\n@@ -21208,6 +21514,10 @@ static struct asm_barrier_opt barrier_opt_names[] =\n #define cCE(mnem,  op, nops, ops, ae)\t\\\n   { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae, 0 }\n \n+/* mov instructions that are shared between coprocessor and MVE.  */\n+#define mcCE(mnem,  op, nops, ops, ae)\t\\\n+  { #mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, THUMB_VARIANT, do_##ae, do_##ae, 0 }\n+\n /* Legacy coprocessor instructions where conditional infix and conditional\n    suffix are ambiguous.  For consistency this includes all FPA instructions,\n    not just the potentially ambiguous ones.  */\n@@ -22482,9 +22792,6 @@ static const struct asm_opcode insns[] =\n #define ARM_VARIANT  & fpu_vfp_ext_v1xd  /* VFP V1xD (single precision).  */\n \n   /* Moves and type conversions.  */\n- cCE(\"fcpys\",\teb00a40, 2, (RVS, RVS),\t      vfp_sp_monadic),\n- cCE(\"fmrs\",\te100a10, 2, (RR, RVS),\t      vfp_reg_from_sp),\n- cCE(\"fmsr\",\te000a10, 2, (RVS, RR),\t      vfp_sp_from_reg),\n  cCE(\"fmstat\",\tef1fa10, 0, (),\t\t      noargs),\n  cCE(\"vmrs\",\tef00a10, 2, (APSR_RR, RVC),   vmrs),\n  cCE(\"vmsr\",\tee00a10, 2, (RVC, RR),        vmsr),\n@@ -22556,7 +22863,6 @@ static const struct asm_opcode insns[] =\n #define ARM_VARIANT  & fpu_vfp_ext_v1 /* VFP V1 (Double precision).  */\n \n   /* Moves and type conversions.  */\n- cCE(\"fcpyd\",\teb00b40, 2, (RVD, RVD),\t      vfp_dp_rd_rm),\n  cCE(\"fcvtds\",\teb70ac0, 2, (RVD, RVS),\t      vfp_dp_sp_cvt),\n  cCE(\"fcvtsd\",\teb70bc0, 2, (RVS, RVD),\t      vfp_sp_dp_cvt),\n  cCE(\"fmdhr\",\te200b10, 2, (RVD, RR),\t      vfp_dp_rn_rd),\n@@ -22592,14 +22898,6 @@ static const struct asm_opcode insns[] =\n  cCE(\"fcmped\",\teb40bc0, 2, (RVD, RVD),\t      vfp_dp_rd_rm),\n  cCE(\"fcmpezd\",\teb50bc0, 1, (RVD),\t      vfp_dp_rd),\n \n-#undef  ARM_VARIANT\n-#define ARM_VARIANT  & fpu_vfp_ext_v2\n-\n- cCE(\"fmsrr\",\tc400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),\n- cCE(\"fmrrs\",\tc500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),\n- cCE(\"fmdrr\",\tc400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),\n- cCE(\"fmrrd\",\tc500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),\n-\n /* Instructions which may belong to either the Neon or VFP instruction sets.\n    Individual encoder functions perform additional architecture checks.  */\n #undef  ARM_VARIANT\n@@ -22638,7 +22936,6 @@ static const struct asm_opcode insns[] =\n \n \n   /* NOTE: All VMOV encoding is special-cased!  */\n- NCE(vmov,      0,       1, (VMOV), neon_mov),\n  NCE(vmovq,     0,       1, (VMOV), neon_mov),\n \n #undef  THUMB_VARIANT\n@@ -23382,18 +23679,42 @@ static const struct asm_opcode insns[] =\n  mCEF(vldrw,\t_vldrw,\t    2, (RMQ, ADDRMVE),\t\t\tmve_vstr_vldr),\n  mCEF(vldrd,\t_vldrd,\t    2, (RMQ, ADDRMVE),\t\t\tmve_vstr_vldr),\n \n+ mCEF(vmovnt,\t_vmovnt,    2, (RMQ, RMQ),\t\t\t  mve_movn),\n+ mCEF(vmovnb,\t_vmovnb,    2, (RMQ, RMQ),\t\t\t  mve_movn),\n+\n #undef  ARM_VARIANT\n-#define ARM_VARIANT    & fpu_vfp_ext_v1xd\n+#define ARM_VARIANT  & fpu_vfp_ext_v1\n #undef  THUMB_VARIANT\n #define THUMB_VARIANT  & arm_ext_v6t2\n \n+ mcCE(fcpyd,\teb00b40, 2, (RVD, RVD),\t      vfp_dp_rd_rm),\n+\n+#undef  ARM_VARIANT\n+#define ARM_VARIANT  & fpu_vfp_ext_v1xd\n+\n+ MNCE(vmov,   0,\t1, (VMOV),\t      neon_mov),\n+ mcCE(fmrs,\te100a10, 2, (RR, RVS),\t      vfp_reg_from_sp),\n+ mcCE(fmsr,\te000a10, 2, (RVS, RR),\t      vfp_sp_from_reg),\n+ mcCE(fcpys,\teb00a40, 2, (RVS, RVS),\t      vfp_sp_monadic),\n+\n  mCEF(vmullt, _vmullt,\t3, (RNSDQMQ, oRNSDQMQ, RNSDQ_RNSC_MQ),\tmve_vmull),\n  mnCEF(vadd,  _vadd,\t3, (RNSDQMQ, oRNSDQMQ, RNSDQMQR),\tneon_addsub_if_i),\n  mnCEF(vsub,  _vsub,\t3, (RNSDQMQ, oRNSDQMQ, RNSDQMQR),\tneon_addsub_if_i),\n \n  MNCEF(vabs,  1b10300,\t2, (RNSDQMQ, RNSDQMQ),\tneon_abs_neg),\n  MNCEF(vneg,  1b10380,\t2, (RNSDQMQ, RNSDQMQ),\tneon_abs_neg),\n \n+ mCEF(vmovlt, _vmovlt,\t1, (VMOV),\t\tmve_movl),\n+ mCEF(vmovlb, _vmovlb,\t1, (VMOV),\t\tmve_movl),\n+\n+#undef  ARM_VARIANT\n+#define ARM_VARIANT  & fpu_vfp_ext_v2\n+\n+ mcCE(fmsrr,\tc400a10, 3, (VRSLST, RR, RR), vfp_sp2_from_reg2),\n+ mcCE(fmrrs,\tc500a10, 3, (RR, RR, VRSLST), vfp_reg2_from_sp2),\n+ mcCE(fmdrr,\tc400b10, 3, (RVD, RR, RR),    vfp_dp_rm_rd_rn),\n+ mcCE(fmrrd,\tc500b10, 3, (RR, RR, RVD),    vfp_dp_rd_rn_rm),\n+\n #undef  ARM_VARIANT\n #define ARM_VARIANT    & fpu_vfp_ext_armv8xd\n  mnUF(vcvta,  _vcvta,  2, (RNSDQMQ, oRNSDQMQ),\t\tneon_cvta),"
    },
    {
      "sha": "a1933bf5dff7015f0dff118b8643b9f454c4dddb",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-1.d",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-1.d?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,5 @@\n+#name: bad MVE VMOV (between general-purpose register and vector lane)\n+#as: -march=armv8.1-m.main+mve.fp\n+#error_output: mve-vmov-bad-1.l\n+\n+.*: +file format .*arm.*"
    },
    {
      "sha": "4cff35850df1f4a4b79d9936ce73482ec6220b08",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-1.l",
      "status": "added",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-1.l?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,24 @@\n+[^:]*: Assembler messages:\n+[^:]*:3: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:4: Warning: instruction is UNPREDICTABLE with PC operand\n+[^:]*:5: Error: bad type for scalar -- `vmov.64 q0\\[0\\],r0'\n+[^:]*:6: Error: scalar index out of range -- `vmov.8 q0\\[16\\],r0'\n+[^:]*:7: Error: scalar index out of range -- `vmov.16 q0\\[8\\],r0'\n+[^:]*:8: Error: scalar index out of range -- `vmov.32 q0\\[4\\],r0'\n+[^:]*:10: Error: syntax error -- `vmovt.8 q0\\[0\\],r0'\n+[^:]*:11: Error: syntax error -- `vmovt.8 q0\\[0\\],r0'\n+[^:]*:13: Error: instruction not allowed in IT block -- `vmov.8 q0\\[0\\],r0'\n+[^:]*:14: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:15: Warning: instruction is UNPREDICTABLE with PC operand\n+[^:]*:16: Error: bad type for scalar -- `vmov.u64 r0,q0\\[0\\]'\n+[^:]*:17: Error: bad type for scalar -- `vmov.s64 r0,q0\\[0\\]'\n+[^:]*:18: Error: bad type for scalar -- `vmov.64 r0,q0\\[0\\]'\n+[^:]*:19: Error: bad type for scalar -- `vmov.8 r0,q0\\[0\\]'\n+[^:]*:20: Error: bad type for scalar -- `vmov.16 r0,q0\\[0\\]'\n+[^:]*:21: Error: bad type for scalar -- `vmov.f16 r0,q0\\[0\\]'\n+[^:]*:22: Error: scalar index out of range -- `vmov.u8 r0,q0\\[16\\]'\n+[^:]*:23: Error: scalar index out of range -- `vmov.u16 r0,q0\\[8\\]'\n+[^:]*:24: Error: scalar index out of range -- `vmov.32 r0,q0\\[4\\]'\n+[^:]*:26: Error: syntax error -- `vmovt.u8 r0,q0\\[0\\]'\n+[^:]*:27: Error: syntax error -- `vmovt.u8 r0,q0\\[0\\]'\n+[^:]*:29: Error: instruction not allowed in IT block -- `vmov.u8 r0,q0\\[0\\]'"
    },
    {
      "sha": "5d58d498f28aefbb7af4623d0004ce4a9ce4c4d9",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-1.s",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-1.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-1.s?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,29 @@\n+.syntax unified\n+.thumb\n+vmov.8 q0[0], sp\n+vmov.8 q0[0], pc\n+vmov.64 q0[0], r0\n+vmov.8 q0[16], r0\n+vmov.16 q0[8], r0\n+vmov.32 q0[4], r0\n+vpst\n+vmovt.8 q0[0], r0\n+vmovt.8 q0[0], r0\n+it eq\n+vmov.8 q0[0], r0\n+vmov.u8 sp, q0[0]\n+vmov.u8 pc, q0[0]\n+vmov.u64 r0, q0[0]\n+vmov.s64 r0, q0[0]\n+vmov.64 r0, q0[0]\n+vmov.8 r0, q0[0]\n+vmov.16 r0, q0[0]\n+vmov.f16 r0, q0[0]\n+vmov.u8 r0, q0[16]\n+vmov.u16 r0, q0[8]\n+vmov.32 r0, q0[4]\n+vpst\n+vmovt.u8 r0, q0[0]\n+vmovt.u8 r0, q0[0]\n+it eq\n+vmov.u8 r0, q0[0]"
    },
    {
      "sha": "c2b02d00100760a8ed1cb7975fc40364b4ed0cc9",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-2.d",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-2.d?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,5 @@\n+#name: bad MVE VMOV (between two 32-bit vector lanes to two general-purpose registers)\n+#as: -march=armv8.1-m.main+mve.fp\n+#error_output: mve-vmov-bad-2.l\n+\n+.*: +file format .*arm.*"
    },
    {
      "sha": "2f4bdc8293a04e3814a9cc80871af51048b23c44",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-2.l",
      "status": "added",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-2.l?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,10 @@\n+[^:]*: Assembler messages:\n+[^:]*:3: Error: General purpose registers may not be the same -- `vmov r0,r0,q0\\[2\\],q0\\[0\\]'\n+[^:]*:4: Error: r13 not allowed here -- `vmov sp,r0,q0\\[2\\],q0\\[0\\]'\n+[^:]*:5: Error: r13 not allowed here -- `vmov r0,sp,q0\\[2\\],q0\\[0\\]'\n+[^:]*:6: Error: r15 not allowed here -- `vmov pc,r0,q0\\[2\\],q0\\[0\\]'\n+[^:]*:7: Error: r15 not allowed here -- `vmov r0,pc,q0\\[2\\],q0\\[0\\]'\n+[^:]*:8: Error: r13 not allowed here -- `vmov q0\\[2\\],q0\\[0\\],sp,r0'\n+[^:]*:9: Error: r13 not allowed here -- `vmov q0\\[2\\],q0\\[0\\],r0,sp'\n+[^:]*:10: Error: r15 not allowed here -- `vmov q0\\[2\\],q0\\[0\\],pc,r0'\n+[^:]*:11: Error: r15 not allowed here -- `vmov q0\\[2\\],q0\\[0\\],r0,pc'"
    },
    {
      "sha": "20db239cbb9259e680a4a1b2fcc90d61c7aad60e",
      "filename": "gas/testsuite/gas/arm/mve-vmov-bad-2.s",
      "status": "added",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/57785aa2ff465ec72baa75bbd62e321a46e0633e/gas/testsuite/gas/arm/mve-vmov-bad-2.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vmov-bad-2.s?ref=57785aa2ff465ec72baa75bbd62e321a46e0633e",
      "patch": "@@ -0,0 +1,11 @@\n+.syntax unified\n+.thumb\n+vmov r0, r0, q0[2], q0[0]\n+vmov sp, r0, q0[2], q0[0]\n+vmov r0, sp, q0[2], q0[0]\n+vmov pc, r0, q0[2], q0[0]\n+vmov r0, pc, q0[2], q0[0]\n+vmov q0[2], q0[0], sp, r0\n+vmov q0[2], q0[0], r0, sp\n+vmov q0[2], q0[0], pc, r0\n+vmov q0[2], q0[0], r0, pc"
    }
  ]
}