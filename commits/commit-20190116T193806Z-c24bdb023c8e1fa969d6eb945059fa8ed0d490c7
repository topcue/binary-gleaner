{
  "sha": "c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzI0YmRiMDIzYzhlMWZhOTY5ZDZlYjk0NTA1OWZhOGVkMGQ0OTBjNw==",
  "commit": {
    "author": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-16T19:38:06Z"
    },
    "committer": {
      "name": "Keith Seitz",
      "email": "keiths@redhat.com",
      "date": "2019-01-16T19:38:06Z"
    },
    "message": "Introduce dwarf2_cu::get_builder\n\nThis patch is an attempt to deal with a variety of bugs reported where\nGDB segfaults attempting to access a dwarf2_cu's builder.  In certain\ncircumstances, this builder can be NULL.  This is especially common\nwhen inheriting DIEs via inlined subroutines in other CUs.  The test\ncase demonstrates one such situation reported by users.  See gdb/23773,\nrhbz1638798, and dups for other concrete examples.\n\nThe approach taken here is to save the ancestor CU into the dwarf2_cu of\nall CUs with DIEs that are \"imported.\"  This can happen whenever\nfollow_die_offset and friends are called.  This essentially introduces a\nchain of CUs that caused the importation of a DIE from a CU.  Whenever\na builder is requested of a CU that has none, the ancestors are searched\nfor the first one with a builder.\n\nA design side effect of this is that the builder can now only be\naccessed by getter and setter methods because the builder itself\nis private.\n\nThe bulk of the patch is relatively mindless text conversion from\n\"cu->builder\" to \"cu->get_builder ()\".  I've included one test which\nwas derived from one (of the many) bugs reported on the issue in both\nsourceware and Fedora bugzillas.\n\ngdb/ChangeLog:\n\n\tPR gdb/23773\n\t* dwarf2read.c (dwarf2_cu) <ancestor>: New field.\n\t<builder>: Rename to ..\n\t<m_builder>: ... this and make private.\n\t(dwarf2_cu::get_builder): New method.  Change all users of\n\t`builder' to use this method.\n\t(dwarf2_start_symtab): Move to ...\n\t(dwarf2_cu::start_symtab): ... here.  Update all callers\n\t(setup_type_unit_groups): Move to ...\n\t(dwarf2_cu::setup_type_unit_groups): ... here.  Update all\n\tcallers.\n\t(dwarf2_cu::reset_builder): New method.\n\t(process_full_compunit, process_full_type_unit): Use\n\tdwarf2_cu::reset_builder.\n\t(follow_die_offset): Record the ancestor CU if it is different\n\tfrom the followed DIE's CU.\n\t(follow_die_sig_1): Likewise.\n\ngdb/testsuite/ChangeLog:\n\n\tPR gdb/23773\n\t* gdb.dwarf2/inlined_subroutine-inheritance.exp: New file.",
    "tree": {
      "sha": "b8980f7864acb6e4725d60481a680b261d053232",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b8980f7864acb6e4725d60481a680b261d053232"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "1fea0d5379be553f9bcee7c50fba4cff00176d1b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1fea0d5379be553f9bcee7c50fba4cff00176d1b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1fea0d5379be553f9bcee7c50fba4cff00176d1b"
    }
  ],
  "stats": {
    "total": 509,
    "additions": 393,
    "deletions": 116
  },
  "files": [
    {
      "sha": "a0700367dd5c2e3a18ab9bc693e6901b9e32c725",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
      "patch": "@@ -1,3 +1,23 @@\n+2019-01-16  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR gdb/23773\n+\t* dwarf2read.c (dwarf2_cu) <ancestor>: New field.\n+\t<builder>: Rename to ..\n+\t<m_builder>: ... this and make private.\n+\t(dwarf2_cu::get_builder): New method.  Change all users of\n+\t`builder' to use this method.\n+\t(dwarf2_start_symtab): Move to ...\n+\t(dwarf2_cu::start_symtab): ... here.  Update all callers\n+\t(setup_type_unit_groups): Move to ...\n+\t(dwarf2_cu::setup_type_unit_groups): ... here.  Update all\n+\tcallers.\n+\t(dwarf2_cu::reset_builder): New method.\n+\t(process_full_compunit, process_full_type_unit): Use\n+\tdwarf2_cu::reset_builder.\n+\t(follow_die_offset): Record the ancestor CU if it is different\n+\tfrom the followed DIE's CU.\n+\t(follow_die_sig_1): Likewise.\n+\n 2019-01-15  Tom Tromey  <tom@tromey.com>\n \n \t* remote.c (class remote_state) <buf>: Now a char_vector."
    },
    {
      "sha": "f6aedfc6366113591b39ef63a916ebbafdae6676",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 155,
      "deletions": 116,
      "changes": 271,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
      "patch": "@@ -421,6 +421,22 @@ struct dwarf2_cu\n \n   DISABLE_COPY_AND_ASSIGN (dwarf2_cu);\n \n+  /* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.\n+     Create the set of symtabs used by this TU, or if this TU is sharing\n+     symtabs with another TU and the symtabs have already been created\n+     then restore those symtabs in the line header.\n+     We don't need the pc/line-number mapping for type units.  */\n+  void setup_type_unit_groups (struct die_info *die);\n+\n+  /* Start a symtab for DWARF.  NAME, COMP_DIR, LOW_PC are passed to the\n+     buildsym_compunit constructor.  */\n+  struct compunit_symtab *start_symtab (const char *name,\n+\t\t\t\t\tconst char *comp_dir,\n+\t\t\t\t\tCORE_ADDR low_pc);\n+\n+  /* Reset the builder.  */\n+  void reset_builder () { m_builder.reset (); }\n+\n   /* The header of the compilation unit.  */\n   struct comp_unit_head header {};\n \n@@ -436,10 +452,12 @@ struct dwarf2_cu\n \n   const char *producer = nullptr;\n \n+private:\n   /* The symtab builder for this CU.  This is only non-NULL when full\n      symbols are being read.  */\n-  std::unique_ptr<buildsym_compunit> builder;\n+  std::unique_ptr<buildsym_compunit> m_builder;\n \n+public:\n   /* The generic symbol table building routines have separate lists for\n      file scope symbols and all all other scopes (local scopes).  So\n      we need to select the right one to pass to add_symbol_to_list().\n@@ -562,6 +580,24 @@ struct dwarf2_cu\n   bool processing_has_namespace_info : 1;\n \n   struct partial_die_info *find_partial_die (sect_offset sect_off);\n+\n+  /* If this CU was inherited by another CU (via specification,\n+     abstract_origin, etc), this is the ancestor CU.  */\n+  dwarf2_cu *ancestor;\n+\n+  /* Get the buildsym_compunit for this CU.  */\n+  buildsym_compunit *get_builder ()\n+  {\n+    /* If this CU has a builder associated with it, use that.  */\n+    if (m_builder != nullptr)\n+      return m_builder.get ();\n+\n+    /* Otherwise, search ancestors for a valid builder.  */\n+    if (ancestor != nullptr)\n+      return ancestor->get_builder ();\n+\n+    return nullptr;\n+  }\n };\n \n /* A struct that can be used as a hash key for tables based on DW_AT_stmt_list.\n@@ -1584,10 +1620,6 @@ static void dwarf_decode_lines (struct line_header *, const char *,\n static void dwarf2_start_subfile (struct dwarf2_cu *, const char *,\n \t\t\t\t  const char *);\n \n-static struct compunit_symtab *dwarf2_start_symtab (struct dwarf2_cu *,\n-\t\t\t\t\t\t    const char *, const char *,\n-\t\t\t\t\t\t    CORE_ADDR);\n-\n static struct symbol *new_symbol (struct die_info *, struct type *,\n \t\t\t\t  struct dwarf2_cu *, struct symbol * = NULL);\n \n@@ -9797,7 +9829,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n   struct pending *list;\n   int i;\n \n-  for (list = *cu->builder->get_global_symbols ();\n+  for (list = *cu->get_builder ()->get_global_symbols ();\n        list != NULL;\n        list = list->next)\n     {\n@@ -9852,7 +9884,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n       SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n       SYMBOL_TYPE (sym) = type;\n \n-      add_symbol_to_list (sym, cu->builder->get_global_symbols ());\n+      add_symbol_to_list (sym, cu->get_builder ()->get_global_symbols ());\n \n       xfree (package_name);\n     }\n@@ -10347,7 +10379,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n   get_scope_pc_bounds (cu->dies, &lowpc, &highpc, cu);\n \n   addr = gdbarch_adjust_dwarf2_addr (gdbarch, highpc + baseaddr);\n-  static_block = cu->builder->end_symtab_get_static_block (addr, 0, 1);\n+  static_block = cu->get_builder ()->end_symtab_get_static_block (addr, 0, 1);\n \n   /* If the comp unit has DW_AT_ranges, it may have discontiguous ranges.\n      Also, DW_AT_ranges may record ranges not belonging to any child DIEs\n@@ -10356,7 +10388,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n      this comp unit.  */\n   dwarf2_record_block_ranges (cu->dies, static_block, baseaddr, cu);\n \n-  cust = cu->builder->end_symtab_from_static_block (static_block,\n+  cust = cu->get_builder ()->end_symtab_from_static_block (static_block,\n \t\t\t\t\t\t    SECT_OFF_TEXT (objfile),\n \t\t\t\t\t\t    0);\n \n@@ -10405,7 +10437,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n   dwarf2_per_objfile->just_read_cus.push_back (per_cu);\n \n   /* Not needed any more.  */\n-  cu->builder.reset ();\n+  cu->reset_builder ();\n }\n \n /* Generate full symbol information for type unit PER_CU, whose DIEs have\n@@ -10451,7 +10483,8 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n      this TU's symbols to the existing symtab.  */\n   if (sig_type->type_unit_group->compunit_symtab == NULL)\n     {\n-      cust = cu->builder->end_expandable_symtab (0, SECT_OFF_TEXT (objfile));\n+      buildsym_compunit *builder = cu->get_builder ();\n+      cust = builder->end_expandable_symtab (0, SECT_OFF_TEXT (objfile));\n       sig_type->type_unit_group->compunit_symtab = cust;\n \n       if (cust != NULL)\n@@ -10467,7 +10500,7 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n     }\n   else\n     {\n-      cu->builder->augment_type_symtab ();\n+      cu->get_builder ()->augment_type_symtab ();\n       cust = sig_type->type_unit_group->compunit_symtab;\n     }\n \n@@ -10481,7 +10514,7 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n     }\n \n   /* Not needed any more.  */\n-  cu->builder.reset ();\n+  cu->reset_builder ();\n }\n \n /* Process an imported unit DIE.  */\n@@ -11176,10 +11209,11 @@ read_namespace_alias (struct die_info *die, struct dwarf2_cu *cu)\n static struct using_direct **\n using_directives (struct dwarf2_cu *cu)\n {\n-  if (cu->language == language_ada && cu->builder->outermost_context_p ())\n-    return cu->builder->get_global_using_directives ();\n+  if (cu->language == language_ada\n+      && cu->get_builder ()->outermost_context_p ())\n+    return cu->get_builder ()->get_global_using_directives ();\n   else\n-    return cu->builder->get_local_using_directives ();\n+    return cu->get_builder ()->get_local_using_directives ();\n }\n \n /* Read the import statement specified by the given die and record it.  */\n@@ -11540,7 +11574,7 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n   if (cu->producer && strstr (cu->producer, \"GNU Go \") != NULL)\n     set_cu_language (DW_LANG_Go, cu);\n \n-  dwarf2_start_symtab (cu, fnd.name, fnd.comp_dir, lowpc);\n+  cu->start_symtab (fnd.name, fnd.comp_dir, lowpc);\n \n   /* Decode line number information if present.  We do this before\n      processing child DIEs, so that the line header table is available\n@@ -11584,16 +11618,9 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n     }\n }\n \n-/* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.\n-   Create the set of symtabs used by this TU, or if this TU is sharing\n-   symtabs with another TU and the symtabs have already been created\n-   then restore those symtabs in the line header.\n-   We don't need the pc/line-number mapping for type units.  */\n-\n-static void\n-setup_type_unit_groups (struct die_info *die, struct dwarf2_cu *cu)\n+void\n+dwarf2_cu::setup_type_unit_groups (struct die_info *die)\n {\n-  struct dwarf2_per_cu_data *per_cu = cu->per_cu;\n   struct type_unit_group *tu_group;\n   int first_time;\n   struct attribute *attr;\n@@ -11603,12 +11630,12 @@ setup_type_unit_groups (struct die_info *die, struct dwarf2_cu *cu)\n   gdb_assert (per_cu->is_debug_types);\n   sig_type = (struct signatured_type *) per_cu;\n \n-  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);\n+  attr = dwarf2_attr (die, DW_AT_stmt_list, this);\n \n   /* If we're using .gdb_index (includes -readnow) then\n      per_cu->type_unit_group may not have been set up yet.  */\n   if (sig_type->type_unit_group == NULL)\n-    sig_type->type_unit_group = get_type_unit_group (cu, attr);\n+    sig_type->type_unit_group = get_type_unit_group (this, attr);\n   tu_group = sig_type->type_unit_group;\n \n   /* If we've already processed this stmt_list there's no real need to\n@@ -11623,77 +11650,77 @@ setup_type_unit_groups (struct die_info *die, struct dwarf2_cu *cu)\n   if (attr != NULL)\n     {\n       sect_offset line_offset = (sect_offset) DW_UNSND (attr);\n-      lh = dwarf_decode_line_header (line_offset, cu);\n+      lh = dwarf_decode_line_header (line_offset, this);\n     }\n   if (lh == NULL)\n     {\n       if (first_time)\n-\tdwarf2_start_symtab (cu, \"\", NULL, 0);\n+\tstart_symtab (\"\", NULL, 0);\n       else\n \t{\n \t  gdb_assert (tu_group->symtabs == NULL);\n-\t  gdb_assert (cu->builder == nullptr);\n+\t  gdb_assert (m_builder == nullptr);\n \t  struct compunit_symtab *cust = tu_group->compunit_symtab;\n-\t  cu->builder.reset (new struct buildsym_compunit\n-\t\t\t     (COMPUNIT_OBJFILE (cust), \"\",\n-\t\t\t      COMPUNIT_DIRNAME (cust),\n-\t\t\t      compunit_language (cust),\n-\t\t\t      0, cust));\n+\t  m_builder.reset (new struct buildsym_compunit\n+\t\t\t   (COMPUNIT_OBJFILE (cust), \"\",\n+\t\t\t    COMPUNIT_DIRNAME (cust),\n+\t\t\t    compunit_language (cust),\n+\t\t\t    0, cust));\n \t}\n       return;\n     }\n \n-  cu->line_header = lh.release ();\n-  cu->line_header_die_owner = die;\n+  line_header = lh.release ();\n+  line_header_die_owner = die;\n \n   if (first_time)\n     {\n-      struct compunit_symtab *cust = dwarf2_start_symtab (cu, \"\", NULL, 0);\n+      struct compunit_symtab *cust = start_symtab (\"\", NULL, 0);\n \n       /* Note: We don't assign tu_group->compunit_symtab yet because we're\n \t still initializing it, and our caller (a few levels up)\n \t process_full_type_unit still needs to know if this is the first\n \t time.  */\n \n-      tu_group->num_symtabs = cu->line_header->file_names.size ();\n+      tu_group->num_symtabs = line_header->file_names.size ();\n       tu_group->symtabs = XNEWVEC (struct symtab *,\n-\t\t\t\t   cu->line_header->file_names.size ());\n+\t\t\t\t   line_header->file_names.size ());\n \n-      for (i = 0; i < cu->line_header->file_names.size (); ++i)\n+      for (i = 0; i < line_header->file_names.size (); ++i)\n \t{\n-\t  file_entry &fe = cu->line_header->file_names[i];\n+\t  file_entry &fe = line_header->file_names[i];\n \n-\t  dwarf2_start_subfile (cu, fe.name, fe.include_dir (cu->line_header));\n-\n-\t  if (cu->builder->get_current_subfile ()->symtab == NULL)\n+\t  dwarf2_start_subfile (this, fe.name,\n+\t\t\t\tfe.include_dir (line_header));\n+\t  buildsym_compunit *b = get_builder ();\n+\t  if (b->get_current_subfile ()->symtab == NULL)\n \t    {\n \t      /* NOTE: start_subfile will recognize when it's been\n \t\t passed a file it has already seen.  So we can't\n \t\t assume there's a simple mapping from\n \t\t cu->line_header->file_names to subfiles, plus\n \t\t cu->line_header->file_names may contain dups.  */\n-\t      cu->builder->get_current_subfile ()->symtab\n-\t\t= allocate_symtab (cust,\n-\t\t\t\t   cu->builder->get_current_subfile ()->name);\n+\t      b->get_current_subfile ()->symtab\n+\t\t= allocate_symtab (cust, b->get_current_subfile ()->name);\n \t    }\n \n-\t  fe.symtab = cu->builder->get_current_subfile ()->symtab;\n+\t  fe.symtab = b->get_current_subfile ()->symtab;\n \t  tu_group->symtabs[i] = fe.symtab;\n \t}\n     }\n   else\n     {\n-      gdb_assert (cu->builder == nullptr);\n+      gdb_assert (m_builder == nullptr);\n       struct compunit_symtab *cust = tu_group->compunit_symtab;\n-      cu->builder.reset (new struct buildsym_compunit\n-\t\t\t (COMPUNIT_OBJFILE (cust), \"\",\n-\t\t\t  COMPUNIT_DIRNAME (cust),\n-\t\t\t  compunit_language (cust),\n-\t\t\t  0, cust));\n+      m_builder.reset (new struct buildsym_compunit\n+\t\t       (COMPUNIT_OBJFILE (cust), \"\",\n+\t\t\tCOMPUNIT_DIRNAME (cust),\n+\t\t\tcompunit_language (cust),\n+\t\t\t0, cust));\n \n-      for (i = 0; i < cu->line_header->file_names.size (); ++i)\n+      for (i = 0; i < line_header->file_names.size (); ++i)\n \t{\n-\t  file_entry &fe = cu->line_header->file_names[i];\n+\t  file_entry &fe = line_header->file_names[i];\n \n \t  fe.symtab = tu_group->symtabs[i];\n \t}\n@@ -11721,7 +11748,7 @@ read_type_unit_scope (struct die_info *die, struct dwarf2_cu *cu)\n   /* Initialize (or reinitialize) the machinery for building symtabs.\n      We do this before processing child DIEs, so that the line header table\n      is available for DW_AT_decl_file.  */\n-  setup_type_unit_groups (die, cu);\n+  cu->setup_type_unit_groups (die);\n \n   if (die->child != NULL)\n     {\n@@ -13714,7 +13741,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n     }\n \n-  newobj = cu->builder->push_context (0, lowpc);\n+  newobj = cu->get_builder ()->push_context (0, lowpc);\n   newobj->name = new_symbol (die, read_type_die (die, cu), cu,\n \t\t\t     (struct symbol *) templ_func);\n \n@@ -13734,7 +13761,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n       attr_to_dynamic_prop (attr, die, cu, newobj->static_link);\n     }\n \n-  cu->list_in_scope = cu->builder->get_local_symbols ();\n+  cu->list_in_scope = cu->get_builder ()->get_local_symbols ();\n \n   if (die->child != NULL)\n     {\n@@ -13782,9 +13809,9 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n     }\n \n-  struct context_stack cstk = cu->builder->pop_context ();\n+  struct context_stack cstk = cu->get_builder ()->pop_context ();\n   /* Make a block for the local symbols within.  */\n-  block = cu->builder->finish_block (cstk.name, cstk.old_blocks,\n+  block = cu->get_builder ()->finish_block (cstk.name, cstk.old_blocks,\n \t\t\t\t     cstk.static_link, lowpc, highpc);\n \n   /* For C++, set the block's scope.  */\n@@ -13826,13 +13853,13 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n      a function declares a class that has methods).  This means that\n      when we finish processing a function scope, we may need to go\n      back to building a containing block's symbol lists.  */\n-  *cu->builder->get_local_symbols () = cstk.locals;\n-  cu->builder->set_local_using_directives (cstk.local_using_directives);\n+  *cu->get_builder ()->get_local_symbols () = cstk.locals;\n+  cu->get_builder ()->set_local_using_directives (cstk.local_using_directives);\n \n   /* If we've finished processing a top-level function, subsequent\n      symbols go in the file symbol list.  */\n-  if (cu->builder->outermost_context_p ())\n-    cu->list_in_scope = cu->builder->get_file_symbols ();\n+  if (cu->get_builder ()->outermost_context_p ())\n+    cu->list_in_scope = cu->get_builder ()->get_file_symbols ();\n }\n \n /* Process all the DIES contained within a lexical block scope.  Start\n@@ -13871,7 +13898,7 @@ read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)\n   lowpc = gdbarch_adjust_dwarf2_addr (gdbarch, lowpc + baseaddr);\n   highpc = gdbarch_adjust_dwarf2_addr (gdbarch, highpc + baseaddr);\n \n-  cu->builder->push_context (0, lowpc);\n+  cu->get_builder ()->push_context (0, lowpc);\n   if (die->child != NULL)\n     {\n       child_die = die->child;\n@@ -13882,13 +13909,13 @@ read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n     }\n   inherit_abstract_dies (die, cu);\n-  struct context_stack cstk = cu->builder->pop_context ();\n+  struct context_stack cstk = cu->get_builder ()->pop_context ();\n \n-  if (*cu->builder->get_local_symbols () != NULL\n-      || (*cu->builder->get_local_using_directives ()) != NULL)\n+  if (*cu->get_builder ()->get_local_symbols () != NULL\n+      || (*cu->get_builder ()->get_local_using_directives ()) != NULL)\n     {\n       struct block *block\n-        = cu->builder->finish_block (0, cstk.old_blocks, NULL,\n+        = cu->get_builder ()->finish_block (0, cstk.old_blocks, NULL,\n \t\t\t\t     cstk.start_addr, highpc);\n \n       /* Note that recording ranges after traversing children, as we\n@@ -13903,8 +13930,8 @@ read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)\n          to do.  */\n       dwarf2_record_block_ranges (die, block, baseaddr, cu);\n     }\n-  *cu->builder->get_local_symbols () = cstk.locals;\n-  cu->builder->set_local_using_directives (cstk.local_using_directives);\n+  *cu->get_builder ()->get_local_symbols () = cstk.locals;\n+  cu->get_builder ()->set_local_using_directives (cstk.local_using_directives);\n }\n \n /* Read in DW_TAG_call_site and insert it to CU->call_site_htab.  */\n@@ -14827,7 +14854,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n \n \t  low = gdbarch_adjust_dwarf2_addr (gdbarch, low + baseaddr);\n \t  high = gdbarch_adjust_dwarf2_addr (gdbarch, high + baseaddr);\n-\t  cu->builder->record_block_range (block, low, high - 1);\n+\t  cu->get_builder ()->record_block_range (block, low, high - 1);\n         }\n     }\n \n@@ -14852,7 +14879,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n \t  end += baseaddr;\n \t  start = gdbarch_adjust_dwarf2_addr (gdbarch, start);\n \t  end = gdbarch_adjust_dwarf2_addr (gdbarch, end);\n-\t  cu->builder->record_block_range (block, start, end - 1);\n+\t  cu->get_builder ()->record_block_range (block, start, end - 1);\n \t  blockvec.emplace_back (start, end);\n \t});\n \n@@ -20672,7 +20699,7 @@ lnp_state_machine::handle_set_file (file_name_index file)\n     {\n       const char *dir = fe->include_dir (m_line_header);\n \n-      m_last_subfile = m_cu->builder->get_current_subfile ();\n+      m_last_subfile = m_cu->get_builder ()->get_current_subfile ();\n       m_line_has_non_zero_discriminator = m_discriminator != 0;\n       dwarf2_start_subfile (m_cu, fe->name, dir);\n     }\n@@ -20730,7 +20757,7 @@ dwarf_record_line_p (struct dwarf2_cu *cu,\n \t\t     int line_has_non_zero_discriminator,\n \t\t     struct subfile *last_subfile)\n {\n-  if (cu->builder->get_current_subfile () != last_subfile)\n+  if (cu->get_builder ()->get_current_subfile () != last_subfile)\n     return 1;\n   if (line != last_line)\n     return 1;\n@@ -20761,7 +20788,7 @@ dwarf_record_line_1 (struct gdbarch *gdbarch, struct subfile *subfile,\n     }\n \n   if (cu != nullptr)\n-    cu->builder->record_line (subfile, line, addr);\n+    cu->get_builder ()->record_line (subfile, line, addr);\n }\n \n /* Subroutine of dwarf_decode_lines_1 to simplify it.\n@@ -20812,7 +20839,7 @@ lnp_state_machine::record_line (bool end_sequence)\n       fe->included_p = 1;\n       if (m_record_lines_p && (producer_is_codewarrior (m_cu) || m_is_stmt))\n \t{\n-\t  if (m_last_subfile != m_cu->builder->get_current_subfile ()\n+\t  if (m_last_subfile != m_cu->get_builder ()->get_current_subfile ()\n \t      || end_sequence)\n \t    {\n \t      dwarf_finish_line (m_gdbarch, m_last_subfile, m_address,\n@@ -20825,12 +20852,13 @@ lnp_state_machine::record_line (bool end_sequence)\n \t\t\t\t       m_line_has_non_zero_discriminator,\n \t\t\t\t       m_last_subfile))\n \t\t{\n+\t\t  buildsym_compunit *builder = m_cu->get_builder ();\n \t\t  dwarf_record_line_1 (m_gdbarch,\n-\t\t\t\t       m_cu->builder->get_current_subfile (),\n+\t\t\t\t       builder->get_current_subfile (),\n \t\t\t\t       m_line, m_address,\n \t\t\t\t       m_currently_recording_lines ? m_cu : nullptr);\n \t\t}\n-\t      m_last_subfile = m_cu->builder->get_current_subfile ();\n+\t      m_last_subfile = m_cu->get_builder ()->get_current_subfile ();\n \t      m_last_line = m_line;\n \t    }\n \t}\n@@ -21153,7 +21181,8 @@ dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n       /* Make sure a symtab is created for every file, even files\n \t which contain only variables (i.e. no code with associated\n \t line numbers).  */\n-      struct compunit_symtab *cust = cu->builder->get_compunit_symtab ();\n+      buildsym_compunit *builder = cu->get_builder ();\n+      struct compunit_symtab *cust = builder->get_compunit_symtab ();\n       int i;\n \n       for (i = 0; i < lh->file_names.size (); i++)\n@@ -21162,13 +21191,13 @@ dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n \n \t  dwarf2_start_subfile (cu, fe.name, fe.include_dir (lh));\n \n-\t  if (cu->builder->get_current_subfile ()->symtab == NULL)\n+\t  if (builder->get_current_subfile ()->symtab == NULL)\n \t    {\n-\t      cu->builder->get_current_subfile ()->symtab\n+\t      builder->get_current_subfile ()->symtab\n \t\t= allocate_symtab (cust,\n-\t\t\t\t   cu->builder->get_current_subfile ()->name);\n+\t\t\t\t   builder->get_current_subfile ()->name);\n \t    }\n-\t  fe.symtab = cu->builder->get_current_subfile ()->symtab;\n+\t  fe.symtab = builder->get_current_subfile ()->symtab;\n \t}\n     }\n }\n@@ -21215,7 +21244,7 @@ dwarf2_start_subfile (struct dwarf2_cu *cu, const char *filename,\n       filename = copy;\n     }\n \n-  cu->builder->start_subfile (filename);\n+  cu->get_builder ()->start_subfile (filename);\n \n   if (copy != NULL)\n     xfree (copy);\n@@ -21224,24 +21253,24 @@ dwarf2_start_subfile (struct dwarf2_cu *cu, const char *filename,\n /* Start a symtab for DWARF.  NAME, COMP_DIR, LOW_PC are passed to the\n    buildsym_compunit constructor.  */\n \n-static struct compunit_symtab *\n-dwarf2_start_symtab (struct dwarf2_cu *cu,\n-\t\t     const char *name, const char *comp_dir, CORE_ADDR low_pc)\n+struct compunit_symtab *\n+dwarf2_cu::start_symtab (const char *name, const char *comp_dir,\n+\t\t\t CORE_ADDR low_pc)\n {\n-  gdb_assert (cu->builder == nullptr);\n+  gdb_assert (m_builder == nullptr);\n \n-  cu->builder.reset (new struct buildsym_compunit\n-\t\t     (cu->per_cu->dwarf2_per_objfile->objfile,\n-\t\t      name, comp_dir, cu->language, low_pc));\n+  m_builder.reset (new struct buildsym_compunit\n+\t\t   (per_cu->dwarf2_per_objfile->objfile,\n+\t\t    name, comp_dir, language, low_pc));\n \n-  cu->list_in_scope = cu->builder->get_file_symbols ();\n+  list_in_scope = get_builder ()->get_file_symbols ();\n \n-  cu->builder->record_debugformat (\"DWARF 2\");\n-  cu->builder->record_producer (cu->producer);\n+  get_builder ()->record_debugformat (\"DWARF 2\");\n+  get_builder ()->record_producer (producer);\n \n-  cu->processing_has_namespace_info = false;\n+  processing_has_namespace_info = false;\n \n-  return cu->builder->get_compunit_symtab ();\n+  return get_builder ()->get_compunit_symtab ();\n }\n \n static void\n@@ -21427,7 +21456,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n                  access them globally.  For instance, we want to be able\n                  to break on a nested subprogram without having to\n                  specify the context.  */\n-\t      list_to_add = cu->builder->get_global_symbols ();\n+\t      list_to_add = cu->get_builder ()->get_global_symbols ();\n \t    }\n \t  else\n \t    {\n@@ -21470,7 +21499,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      if (!suppress_add)\n \t\t{\n \t\t  if (attr2 && (DW_UNSND (attr2) != 0))\n-\t\t    list_to_add = cu->builder->get_global_symbols ();\n+\t\t    list_to_add = cu->get_builder ()->get_global_symbols ();\n \t\t  else\n \t\t    list_to_add = cu->list_in_scope;\n \t\t}\n@@ -21516,8 +21545,9 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t  /* A variable with DW_AT_external is never static,\n \t\t     but it may be block-scoped.  */\n \t\t  list_to_add\n-\t\t    = (cu->list_in_scope == cu->builder->get_file_symbols ()\n-\t\t       ? cu->builder->get_global_symbols ()\n+\t\t    = ((cu->list_in_scope\n+\t\t\t== cu->get_builder ()->get_file_symbols ())\n+\t\t       ? cu->get_builder ()->get_global_symbols ()\n \t\t       : cu->list_in_scope);\n \t\t}\n \t      else\n@@ -21549,8 +21579,9 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t  /* A variable with DW_AT_external is never static, but it\n \t\t     may be block-scoped.  */\n \t\t  list_to_add\n-\t\t    = (cu->list_in_scope == cu->builder->get_file_symbols ()\n-\t\t       ? cu->builder->get_global_symbols ()\n+\t\t    = ((cu->list_in_scope\n+\t\t\t== cu->get_builder ()->get_file_symbols ())\n+\t\t       ? cu->get_builder ()->get_global_symbols ()\n \t\t       : cu->list_in_scope);\n \n \t\t  SYMBOL_ACLASS_INDEX (sym) = LOC_UNRESOLVED;\n@@ -21572,7 +21603,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t       pretend it's a local variable in that case so that the user can\n \t       still see it.  */\n \t    struct context_stack *curr\n-\t      = cu->builder->get_current_context_stack ();\n+\t      = cu->get_builder ()->get_current_context_stack ();\n \t    if (curr != nullptr && curr->name != nullptr)\n \t      SYMBOL_IS_ARGUMENT (sym) = 1;\n \t    attr = dwarf2_attr (die, DW_AT_location, cu);\n@@ -21617,10 +21648,11 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n \t    if (!suppress_add)\n \t      {\n+\t\tbuildsym_compunit *builder = cu->get_builder ();\n \t\tlist_to_add\n-\t\t  = (cu->list_in_scope == cu->builder->get_file_symbols ()\n+\t\t  = (cu->list_in_scope == builder->get_file_symbols ()\n \t\t     && cu->language == language_cplus\n-\t\t     ? cu->builder->get_global_symbols ()\n+\t\t     ? builder->get_global_symbols ()\n \t\t     : cu->list_in_scope);\n \n \t\t/* The semantics of C++ state that \"struct foo {\n@@ -21661,21 +21693,21 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t       DW_TAG_class_type, etc. block.  */\n \n \t    list_to_add\n-\t      = (cu->list_in_scope == cu->builder->get_file_symbols ()\n+\t      = (cu->list_in_scope == cu->get_builder ()->get_file_symbols ()\n \t\t && cu->language == language_cplus\n-\t\t ? cu->builder->get_global_symbols ()\n+\t\t ? cu->get_builder ()->get_global_symbols ()\n \t\t : cu->list_in_scope);\n \t  }\n \t  break;\n \tcase DW_TAG_imported_declaration:\n \tcase DW_TAG_namespace:\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n-\t  list_to_add = cu->builder->get_global_symbols ();\n+\t  list_to_add = cu->get_builder ()->get_global_symbols ();\n \t  break;\n \tcase DW_TAG_module:\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;\n \t  SYMBOL_DOMAIN (sym) = MODULE_DOMAIN;\n-\t  list_to_add = cu->builder->get_global_symbols ();\n+\t  list_to_add = cu->get_builder ()->get_global_symbols ();\n \t  break;\n \tcase DW_TAG_common_block:\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_COMMON_BLOCK;\n@@ -21706,7 +21738,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t namespaces based on the demangled name.  */\n       if (!cu->processing_has_namespace_info\n \t  && cu->language == language_cplus)\n-\tcp_scan_for_anonymous_namespaces (cu->builder.get (), sym, objfile);\n+\tcp_scan_for_anonymous_namespaces (cu->get_builder (), sym, objfile);\n     }\n   return (sym);\n }\n@@ -23007,6 +23039,10 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n \n   *ref_cu = target_cu;\n   temp_die.sect_off = sect_off;\n+\n+  if (target_cu != cu)\n+    target_cu->ancestor = cu;\n+\n   return (struct die_info *) htab_find_with_hash (target_cu->die_hash,\n \t\t\t\t\t\t  &temp_die,\n \t\t\t\t\t\t  to_underlying (sect_off));\n@@ -23341,7 +23377,7 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n \t\t  struct dwarf2_cu **ref_cu)\n {\n   struct die_info temp_die;\n-  struct dwarf2_cu *sig_cu;\n+  struct dwarf2_cu *sig_cu, *cu = *ref_cu;\n   struct die_info *die;\n \n   /* While it might be nice to assert sig_type->type == NULL here,\n@@ -23375,6 +23411,9 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n \t}\n \n       *ref_cu = sig_cu;\n+      if (sig_cu != cu)\n+\tsig_cu->ancestor = cu;\n+\n       return die;\n     }\n \n@@ -23951,7 +23990,7 @@ macro_start_file (struct dwarf2_cu *cu,\n     {\n       /* Note: We don't create a macro table for this compilation unit\n \t at all until we actually get a filename.  */\n-      struct macro_table *macro_table = cu->builder->get_macro_table ();\n+      struct macro_table *macro_table = cu->get_builder ()->get_macro_table ();\n \n       /* If we have no current file, then this must be the start_file\n \t directive for the compilation unit's main source file.  */"
    },
    {
      "sha": "71afd4142c68fffc66bbc81c59554aab612074dd",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
      "patch": "@@ -1,3 +1,8 @@\n+2019-01-16  Keith Seitz  <keiths@redhat.com>\n+\n+\tPR gdb/23773\n+\t* gdb.dwarf2/inlined_subroutine-inheritance.exp: New file.\n+\n 2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n \n \t* gdb.arch/vsx-regs.exp: Add tests that use the vector register"
    },
    {
      "sha": "4250e397d8da1bab0986f2779c577a63e2e17aab",
      "filename": "gdb/testsuite/gdb.dwarf2/inlined_subroutine-inheritance.exp",
      "status": "added",
      "additions": 213,
      "deletions": 0,
      "changes": 213,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/testsuite/gdb.dwarf2/inlined_subroutine-inheritance.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c24bdb023c8e1fa969d6eb945059fa8ed0d490c7/gdb/testsuite/gdb.dwarf2/inlined_subroutine-inheritance.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/inlined_subroutine-inheritance.exp?ref=c24bdb023c8e1fa969d6eb945059fa8ed0d490c7",
      "patch": "@@ -0,0 +1,213 @@\n+# Copyright 2018 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This tests a segfault that occurs when reading inlined_subroutine DIEs\n+# with abstract_origins pointing to DIEs in other CUs.\n+#\n+# See https://bugzilla.redhat.com/show_bug.cgi?id=1638798 .\n+\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+standard_testfile main.c .S\n+\n+# Create the DWARF.  This is derived from the reproducer in the Fedora\n+# bugzila mentioned above.  For clarity, some \"superfluous\" DIES have\n+# been left instead of simplifying/pruning the test further.\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    declare_labels Db D72f8 D736e\n+    declare_labels D266465 D266477 D266483 D266496 D266498 D266ad3 D266ad9 \\\n+\tD266ade D26b227 D26b237\n+    declare_labels D26d8b1 D26d8c3 D26d8cf D26d944 D26d946 D26e103 D26e145 \\\n+\tD26e415 D26e48c D26df00 D26df06 D26df0b D272519 D274c1a D274c42\n+\n+    cu {} {\n+\tDb: compile_unit {\n+\t    {language @DW_LANG_C99}\n+\t    {name \"<artificial>\"}\n+\t} {\n+\t    D72f8: subprogram {\n+\t\t{abstract_origin :$D272519}\n+\t\t{low_pc 0xb9e20 addr}\n+\t\t{high_pc 0x1f5 data4}\n+\t    } {\n+\t\tD736e: inlined_subroutine {\n+\t\t    {abstract_origin :$D26b227}\n+\t\t    {low_pc 0xb9efc addr}\n+\t\t    {high_pc 0xc data4}\n+\t\t} {\n+\t\t    formal_parameter {\n+\t\t\t{abstract_origin :$D274c42}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    cu {} {\n+\tD266465: compile_unit {\n+\t    {language @DW_LANG_C99}\n+\t} {\n+\t    D266477: typedef {\n+\t\t{name \"size_t\"}\n+\t\t{type :$D266483}\n+\t    }\n+\n+\t    D266483: base_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{encoding @DW_ATE_unsigned}\n+\t    }\n+\n+\t    D266496: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t    }\n+\n+\t    D266498: restrict_type {\n+\t\t{type :$D266496}\n+\t    }\n+\n+\t    D266ad3: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{type :$D266ade}\n+\t    }\n+\n+\t    D266ad9: restrict_type {\n+\t\t{type :$D266ad3}\n+\t    }\n+\n+\t    D266ade: const_type {}\n+\n+\t    D26b227: subprogram {\n+\t\t{external 1 flag}\n+\t\t{name \"memcpy\"}\n+\t\t{type :$D266496}\n+\t    } {\n+\t\tD26b237: formal_parameter {\n+\t\t    {name \"__dest\"}\n+\t\t    {type :$D266498}\n+\t\t}\n+\t\tformal_parameter {\n+\t\t    {name \"__src\"}\n+\t\t    {type :$D266ad9}\n+\t\t}\n+\t\tformal_parameter {\n+\t\t    {name \"__len\"}\n+\t\t    {type :$D266477}\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    cu {} {\n+\tD26d8b1: compile_unit {\n+\t    {language @DW_LANG_C99}\n+\t} {\n+\t    D26d8c3: typedef {\n+\t\t{name \"size_t\"}\n+\t\t{type :$D26d8cf}\n+\t    }\n+\n+\t    D26d8cf: base_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{encoding @DW_ATE_unsigned}\n+\t\t{name \"long unsigned int\"}\n+\t    }\n+\n+\t    D26d944: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t    }\n+\n+\t    D26d946: restrict_type {\n+\t\t{type :$D26d944}\n+\t    }\n+\n+\t    D26e103: structure_type {\n+\t\t{name \"__object\"}\n+\t\t{byte_size 12 sdata}\n+\t    } {\n+\t\tmember {\n+\t\t    {name \"__ob_next\"}\n+\t\t    {type :$D26e145}\n+\t\t    {data_member_location 0 sdata}\n+\t\t}\n+\t    }\n+\n+\t    D26e145: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{type :$D26e103}\n+\t    }\n+\n+\t    D26e415: typedef {\n+\t\t{name \"PyObject\"}\n+\t\t{type :$D26e103}\n+\t    }\n+\n+\t    D26e48c: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{type :$D26e415}\n+\t    }\n+\n+\t    D26df00: pointer_type {\n+\t\t{byte_size 8 sdata}\n+\t\t{type :$D26df0b}\n+\t    }\n+\n+\t    D26df06: restrict_type {\n+\t\t{type :$D26df00}\n+\t    }\n+\n+\t    D26df0b: const_type {}\n+\n+\t    D272519: subprogram {\n+\t\t{name \"bytes_repeat\"}\n+\t\t{type :$D26e48c}\n+\t    }\n+\n+\t    D274c1a: subprogram {\n+\t\t{external 1 flag}\n+\t\t{name \"memcpy\"}\n+\t\t{type :$D26d944}\n+\t    } {\n+\t\tformal_parameter {\n+\t\t    {name \"__dest\"}\n+\t\t    {type :$D26d946}\n+\t\t}\n+\t\tformal_parameter {\n+\t\t    {name \"__src\"}\n+\t\t    {type :$D26df06}\n+\t\t}\n+\t\tD274c42: formal_parameter {\n+\t\t    {name \"__len\"}\n+\t\t    {type :$D26d8c3}\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile \\\n+\t \"${asm_file} ${srcfile}\" {}]} {\n+    return -1\n+}\n+\n+# All we need to do is set a breakpoint, which causes the DWARF\n+# info to be read, to demonstrate the problem.\n+\n+gdb_breakpoint \"bytes_repeat\" message"
    }
  ]
}