{
  "sha": "74ccc978200bc96b48ef52385cadf5ddb131dc21",
  "node_id": "C_kwDOANOeidoAKDc0Y2NjOTc4MjAwYmM5NmI0OGVmNTIzODVjYWRmNWRkYjEzMWRjMjE",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-05T17:28:57Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:37Z"
    },
    "message": "sim: mn10300: migrate to standard uintXX_t types\n\nThis old port setup its own uintXX types, but since we require C11\nnow, we can assume the standard uintXX_t types exist and use them.",
    "tree": {
      "sha": "f41ed8ba853d1f4594916169b00ba8f34e8a967c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f41ed8ba853d1f4594916169b00ba8f34e8a967c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/74ccc978200bc96b48ef52385cadf5ddb131dc21",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74ccc978200bc96b48ef52385cadf5ddb131dc21",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/74ccc978200bc96b48ef52385cadf5ddb131dc21",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74ccc978200bc96b48ef52385cadf5ddb131dc21/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "436c3d9d7b20b522d9bc9d737c491ac4e6c719be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/436c3d9d7b20b522d9bc9d737c491ac4e6c719be",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/436c3d9d7b20b522d9bc9d737c491ac4e6c719be"
    }
  ],
  "stats": {
    "total": 1003,
    "additions": 498,
    "deletions": 505
  },
  "files": [
    {
      "sha": "40761b2a19d9c9bdaf06cf45fbb3b92a3dc1d035",
      "filename": "sim/mn10300/am33-2.igen",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/am33-2.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/am33-2.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/am33-2.igen?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -98,7 +98,7 @@\n \"bset\"\n *am33_2\n {\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n   \n   PC = cia;\n@@ -115,7 +115,7 @@\n \"bclr\"\n *am33_2\n {\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n   \n   PC = cia;\n@@ -1114,7 +1114,7 @@\n   else\n     {\n       int reg = translate_rreg (SD_, Rm);\n-      unsigned32 val = State.regs[reg];\n+      uint32_t val = State.regs[reg];\n       FPCR = (val & (EC_MASK | EE_MASK | FCC_MASK))\n \t| ((FPCR & ~val) & EF_MASK);\n     }\n@@ -1147,7 +1147,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      unsigned32 val = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t val = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n       FPCR = (val & (EC_MASK | EE_MASK | FCC_MASK))\n \t| ((FPCR & ~val) & EF_MASK);\n     }\n@@ -1424,7 +1424,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      uint32 imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n       fpu_cmp (SD, CPU, cia, &XS2FS (Y,Sm), &imm, FP_SINGLE);\n     }\n@@ -1496,7 +1496,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      uint32 imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n       fpu_add (SD, CPU, cia,\n \t       &XS2FS (Y,Sm), &imm, &XS2FS (X,Sn), FP_SINGLE);\n@@ -1569,7 +1569,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      uint32 imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n       fpu_sub (SD, CPU, cia,\n \t       &XS2FS (Y,Sm), &imm, &XS2FS (X,Sn), FP_SINGLE);\n@@ -1642,7 +1642,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      uint32 imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n       fpu_mul (SD, CPU, cia,\n \t       &imm, &XS2FS (Y,Sm), &XS2FS (X,Sn), FP_SINGLE);\n@@ -1715,7 +1715,7 @@\n     fpu_disabled_exception (SD, CPU, cia);\n   else\n     {\n-      uint32 imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n+      uint32_t imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n       fpu_div (SD, CPU, cia,\n \t       &XS2FS (Y,Sm), &imm, &XS2FS (X,Sn), FP_SINGLE);"
    },
    {
      "sha": "964f07521a8c64c40245a7b99cfcdfa12938a802",
      "filename": "sim/mn10300/am33.igen",
      "status": "modified",
      "additions": 290,
      "deletions": 290,
      "changes": 580,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/am33.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/am33.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/am33.igen?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -119,7 +119,7 @@\n *am33\n *am33_2\n {\n-  unsigned32 sp, next_pc;\n+  uint32_t sp, next_pc;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -207,8 +207,8 @@\n *am33\n *am33_2\n {\n-  unsigned32 usp = State.regs[REG_USP];\n-  unsigned32 mask;\n+  uint32_t usp = State.regs[REG_USP];\n+  uint32_t mask;\n \n   PC = cia;\n   mask = REGS;\n@@ -301,8 +301,8 @@\n *am33\n *am33_2\n {\n-  unsigned32 usp = State.regs[REG_USP];\n-  unsigned32 mask;\n+  uint32_t usp = State.regs[REG_USP];\n+  uint32_t mask;\n \n   PC = cia;\n   mask = REGS;\n@@ -533,7 +533,7 @@\n {\n   int srcreg, dstreg;\n   int z, c, n, v;\n-  unsigned32 reg1, reg2, sum;\n+  uint32_t reg1, reg2, sum;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n@@ -577,7 +577,7 @@\n {\n   int srcreg, dstreg;\n   int z, c, n, v;\n-  unsigned32 reg1, reg2, difference;\n+  uint32_t reg1, reg2, difference;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n@@ -756,7 +756,7 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  signed32 temp;\n+  int32_t temp;\n   int c, z, n;\n \n   PC = cia;\n@@ -842,7 +842,7 @@\n {\n   int dstreg;\n   int c, n, z;\n-  unsigned32 value;\n+  uint32_t value;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -867,7 +867,7 @@\n {\n   int dstreg;\n   int c, n, z;\n-  unsigned32 value;\n+  uint32_t value;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -891,15 +891,15 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((signed64)(signed32)State.regs[dstreg]\n-          *  (signed64)(signed32)State.regs[srcreg]);\n+  temp = ((int64_t)(int32_t)State.regs[dstreg]\n+          *  (int64_t)(int32_t)State.regs[srcreg]);\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -915,15 +915,15 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)State.regs[dstreg]\n-          * (unsigned64)State.regs[srcreg]);\n+  temp = ((uint64_t)State.regs[dstreg]\n+          * (uint64_t)State.regs[srcreg]);\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -939,7 +939,7 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  signed64 temp;\n+  int64_t temp;\n   int n, z;\n \n   PC = cia;\n@@ -949,8 +949,8 @@\n   temp = State.regs[REG_MDR];\n   temp <<= 32;\n   temp |= State.regs[dstreg];\n-  State.regs[REG_MDR] = temp % (signed32)State.regs[srcreg];\n-  temp /= (signed32)State.regs[srcreg];\n+  State.regs[REG_MDR] = temp % (int32_t)State.regs[srcreg];\n+  temp /= (int32_t)State.regs[srcreg];\n   State.regs[dstreg] = temp & 0xffffffff;\n   z = (State.regs[dstreg] == 0);\n   n = (State.regs[dstreg] & 0x80000000) != 0;\n@@ -965,7 +965,7 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n@@ -1215,15 +1215,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((signed64)(signed32)State.regs[srcreg2]\n-          * (signed64)(signed32)State.regs[srcreg1]);\n+  temp = ((int64_t)(int32_t)State.regs[srcreg2]\n+          * (int64_t)(int32_t)State.regs[srcreg1]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -1244,15 +1244,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  unsigned64 temp, sum;\n+  uint64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)State.regs[srcreg2]\n-          * (unsigned64)State.regs[srcreg1]);\n+  temp = ((uint64_t)State.regs[srcreg2]\n+          * (uint64_t)State.regs[srcreg1]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -1273,15 +1273,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((signed32)(signed8)(State.regs[srcreg2] & 0xff)\n-          * (signed32)(signed8)(State.regs[srcreg1] & 0xff));\n+  temp = ((int32_t)(int8_t)(State.regs[srcreg2] & 0xff)\n+          * (int32_t)(int8_t)(State.regs[srcreg1] & 0xff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -1297,15 +1297,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned32)(State.regs[srcreg2] & 0xff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xff));\n+  temp = ((uint32_t)(State.regs[srcreg2] & 0xff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -1321,15 +1321,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)(signed16)(State.regs[srcreg2] & 0xffff)\n-          * (unsigned64)(signed16)(State.regs[srcreg1] & 0xffff));\n+  temp = ((uint64_t)(int16_t)(State.regs[srcreg2] & 0xffff)\n+          * (uint64_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -1350,15 +1350,15 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)(State.regs[srcreg2] & 0xffff)\n-          * (unsigned64)(State.regs[srcreg1] & 0xffff));\n+  temp = ((uint64_t)(State.regs[srcreg2] & 0xffff)\n+          * (uint64_t)(State.regs[srcreg1] & 0xffff));\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -1379,17 +1379,17 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((signed32)(signed16)(State.regs[srcreg2] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-\t   * (signed32)(signed16)((State.regs[srcreg2] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[srcreg2] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+\t   * (int32_t)(int16_t)((State.regs[srcreg2] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -1405,17 +1405,17 @@\n *am33_2\n {\n   int srcreg1, srcreg2;\n-  unsigned32 temp, temp2, sum;\n+  uint32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)\n-\t   * (unsigned32)((State.regs[srcreg2] >> 16) & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg2] & 0xffff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((uint32_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+\t   * (uint32_t)((State.regs[srcreg2] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -1431,17 +1431,17 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  signed32 temp;\n+  int32_t temp;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg] & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg] & 0xffff));\n   State.regs[REG_MDRQ] = temp;\n-  temp = ((signed32)(signed16)((State.regs[dstreg] >> 16) & 0xffff)\n-          * (signed32)(signed16)((State.regs[srcreg] >>16) & 0xffff));\n+  temp = ((int32_t)(int16_t)((State.regs[dstreg] >> 16) & 0xffff)\n+          * (int32_t)(int16_t)((State.regs[srcreg] >>16) & 0xffff));\n   State.regs[dstreg] = temp;\n }\n \n@@ -1452,17 +1452,17 @@\n *am33_2\n {\n   int srcreg, dstreg;\n-  unsigned32 temp;\n+  uint32_t temp;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RM2);\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned32)(State.regs[dstreg] & 0xffff)\n-          * (unsigned32)(State.regs[srcreg] & 0xffff));\n+  temp = ((uint32_t)(State.regs[dstreg] & 0xffff)\n+          * (uint32_t)(State.regs[srcreg] & 0xffff));\n   State.regs[REG_MDRQ] = temp;\n-  temp = ((unsigned32)((State.regs[dstreg] >> 16) & 0xffff)\n-          * (unsigned32)((State.regs[srcreg] >>16) & 0xffff));\n+  temp = ((uint32_t)((State.regs[dstreg] >> 16) & 0xffff)\n+          * (uint32_t)((State.regs[srcreg] >>16) & 0xffff));\n   State.regs[dstreg] = temp;\n }\n \n@@ -1512,7 +1512,7 @@\n   /* 32bit saturation.  */\n   if (State.regs[srcreg] == 0x20)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -1528,7 +1528,7 @@\n   /* 16bit saturation */\n   else if (State.regs[srcreg] == 0x10)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -1544,7 +1544,7 @@\n   /* 8 bit saturation */\n   else if (State.regs[srcreg] == 0x8)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -1560,7 +1560,7 @@\n   /* 9 bit saturation */\n   else if (State.regs[srcreg] == 0x9)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -1576,7 +1576,7 @@\n   /* 9 bit saturation */\n   else if (State.regs[srcreg] == 0x30)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -1731,7 +1731,7 @@\n {\n   int dstreg, imm;\n   int z, c, n, v;\n-  unsigned32 reg2, sum;\n+  uint32_t reg2, sum;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -1774,7 +1774,7 @@\n {\n   int imm, dstreg;\n   int z, c, n, v;\n-  unsigned32 reg2, difference;\n+  uint32_t reg2, difference;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -1886,7 +1886,7 @@\n *am33_2\n {\n   int dstreg;\n-  signed32 temp;\n+  int32_t temp;\n   int c, z, n;\n \n   PC = cia;\n@@ -1948,14 +1948,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((signed64)(signed32)State.regs[dstreg]\n-          *  (signed64)(signed32)EXTEND8 (IMM8));\n+  temp = ((int64_t)(int32_t)State.regs[dstreg]\n+          *  (int64_t)(int32_t)EXTEND8 (IMM8));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -1971,14 +1971,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)State.regs[dstreg]\n-          * (unsigned64)(IMM8 & 0xff));\n+  temp = ((uint64_t)State.regs[dstreg]\n+          * (uint64_t)(IMM8 & 0xff));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -2231,14 +2231,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)(signed32)EXTEND8 (IMM8)\n-          * (signed64)(signed32)State.regs[srcreg]);\n+  temp = ((int64_t)(int32_t)EXTEND8 (IMM8)\n+          * (int64_t)(int32_t)State.regs[srcreg]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2259,14 +2259,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (IMM8)\n-          * (unsigned64)State.regs[srcreg]);\n+  temp = ((uint64_t) (IMM8)\n+          * (uint64_t)State.regs[srcreg]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2287,14 +2287,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)(signed8)EXTEND8 (IMM8)\n-          * (signed64)(signed8)State.regs[srcreg] & 0xff);\n+  temp = ((int64_t)(int8_t)EXTEND8 (IMM8)\n+          * (int64_t)(int8_t)State.regs[srcreg] & 0xff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2315,14 +2315,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (IMM8)\n-          * (unsigned64)State.regs[srcreg] & 0xff);\n+  temp = ((uint64_t) (IMM8)\n+          * (uint64_t)State.regs[srcreg] & 0xff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2343,14 +2343,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)(signed16)EXTEND8 (IMM8)\n-          * (signed64)(signed16)State.regs[srcreg] & 0xffff);\n+  temp = ((int64_t)(int16_t)EXTEND8 (IMM8)\n+          * (int64_t)(int16_t)State.regs[srcreg] & 0xffff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2371,14 +2371,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (IMM8)\n-          * (unsigned64)State.regs[srcreg] & 0xffff);\n+  temp = ((uint64_t) (IMM8)\n+          * (uint64_t)State.regs[srcreg] & 0xffff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -2409,7 +2409,7 @@\n   /* 32bit saturation.  */\n   if (IMM8 == 0x20)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -2425,7 +2425,7 @@\n   /* 16bit saturation */\n   else if (IMM8 == 0x10)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -2441,7 +2441,7 @@\n   /* 8 bit saturation */\n   else if (IMM8 == 0x8)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -2457,7 +2457,7 @@\n   /* 9 bit saturation */\n   else if (IMM8 == 0x9)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -2473,7 +2473,7 @@\n   /* 9 bit saturation */\n   else if (IMM8 == 0x30)\n     {\n-      signed64 tmp;\n+      int64_t tmp;\n \n       tmp = State.regs[REG_MCRH];\n       tmp <<= 32;\n@@ -2496,7 +2496,7 @@\n *am33_2\n {\n   int z, c, n, v;\n-  unsigned32 sum, source1, source2;\n+  uint32_t sum, source1, source2;\n   int srcreg1, srcreg2, dstreg;\n \n   PC = cia;\n@@ -2527,7 +2527,7 @@\n *am33_2\n {\n   int z, c, n, v;\n-  unsigned32 sum, source1, source2;\n+  uint32_t sum, source1, source2;\n   int srcreg1, srcreg2, dstreg;\n \n   PC = cia;\n@@ -2558,7 +2558,7 @@\n *am33_2\n {\n   int z, c, n, v;\n-  unsigned32 difference, source1, source2;\n+  uint32_t difference, source1, source2;\n   int srcreg1, srcreg2, dstreg;\n \n   PC = cia;\n@@ -2589,7 +2589,7 @@\n *am33_2\n {\n   int z, c, n, v;\n-  unsigned32 difference, source1, source2;\n+  uint32_t difference, source1, source2;\n   int srcreg1, srcreg2, dstreg;\n \n   PC = cia;\n@@ -2689,7 +2689,7 @@\n *am33_2\n {\n   int z, c, n;\n-  signed32 temp;\n+  int32_t temp;\n   int srcreg1, srcreg2, dstreg;\n \n   PC = cia;\n@@ -2763,7 +2763,7 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n+  int64_t temp;\n   int n, z;\n \n   PC = cia;\n@@ -2772,8 +2772,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((signed64)(signed32)State.regs[srcreg1]\n-          *  (signed64)(signed32)State.regs[srcreg2]);\n+  temp = ((int64_t)(int32_t)State.regs[srcreg1]\n+          *  (int64_t)(int32_t)State.regs[srcreg2]);\n   State.regs[dstreg2] = temp & 0xffffffff;\n   State.regs[dstreg1] = (temp & 0xffffffff00000000LL) >> 32;\n \n@@ -2791,7 +2791,7 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n+  int64_t temp;\n   int n, z;\n \n   PC = cia;\n@@ -2800,8 +2800,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((unsigned64)State.regs[srcreg1]\n-          *  (unsigned64)State.regs[srcreg2]);\n+  temp = ((uint64_t)State.regs[srcreg1]\n+          *  (uint64_t)State.regs[srcreg2]);\n   State.regs[dstreg2] = temp & 0xffffffff;\n   State.regs[dstreg1] = (temp & 0xffffffff00000000LL) >> 32;\n \n@@ -2987,8 +2987,8 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n-  unsigned32 sum;\n+  int64_t temp;\n+  uint32_t sum;\n   int c, v;\n \n   PC = cia;\n@@ -2997,8 +2997,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((signed64)(signed32)State.regs[srcreg1]\n-          *  (signed64)(signed32)State.regs[srcreg2]);\n+  temp = ((int64_t)(int32_t)State.regs[srcreg1]\n+          *  (int64_t)(int32_t)State.regs[srcreg2]);\n \n   sum = State.regs[dstreg2] + (temp & 0xffffffff);\n   c = (sum < State.regs[dstreg2]) || (sum < (temp & 0xffffffff));\n@@ -3024,8 +3024,8 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n-  unsigned32 sum;\n+  int64_t temp;\n+  uint32_t sum;\n   int c, v;\n \n   PC = cia;\n@@ -3034,8 +3034,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((unsigned64)State.regs[srcreg1]\n-          * (unsigned64)State.regs[srcreg2]);\n+  temp = ((uint64_t)State.regs[srcreg1]\n+          * (uint64_t)State.regs[srcreg2]);\n \n   sum = State.regs[dstreg2] + (temp & 0xffffffff);\n   c = (sum < State.regs[dstreg2]) || (sum < (temp & 0xffffffff));\n@@ -3061,16 +3061,16 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg = translate_rreg (SD_, RD0);\n \n-  temp = ((signed32)(State.regs[srcreg2] & 0xff)\n-          * (signed32)(State.regs[srcreg1] & 0xff));\n+  temp = ((int32_t)(State.regs[srcreg2] & 0xff)\n+          * (int32_t)(State.regs[srcreg1] & 0xff));\n   sum = State.regs[dstreg] + temp;\n   v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -3090,16 +3090,16 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg = translate_rreg (SD_, RD0);\n \n-  temp = ((unsigned32)(State.regs[srcreg2] & 0xff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xff));\n+  temp = ((uint32_t)(State.regs[srcreg2] & 0xff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xff));\n   sum = State.regs[dstreg] + temp;\n   v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -3119,7 +3119,7 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int v;\n \n   PC = cia;\n@@ -3128,8 +3128,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD0);\n \n-  temp = ((signed32)(State.regs[srcreg2] & 0xffff)\n-          * (signed32)(State.regs[srcreg1] & 0xffff));\n+  temp = ((int32_t)(State.regs[srcreg2] & 0xffff)\n+          * (int32_t)(State.regs[srcreg1] & 0xffff));\n   State.regs[dstreg2] += (temp & 0xffffffff);\n   sum = State.regs[dstreg1] + ((temp >> 32) & 0xffffffff);\n   v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)\n@@ -3150,7 +3150,7 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int v;\n \n   PC = cia;\n@@ -3159,8 +3159,8 @@\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD0);\n \n-  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg2] & 0xffff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xffff));\n   State.regs[dstreg2] += (temp & 0xffffffff);\n   sum = State.regs[dstreg1] + ((temp >> 32) & 0xffffffff);\n   v = ((State.regs[dstreg1] & 0x80000000) == (temp & 0x80000000)\n@@ -3181,18 +3181,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg = translate_rreg (SD_, RD0);\n \n-  temp = ((signed32)(State.regs[srcreg2] & 0xffff)\n-          * (signed32)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)((State.regs[srcreg1] >> 16) & 0xffff)\n-\t   * (signed32)((State.regs[srcreg2] >> 16) & 0xffff));\n+  temp = ((int32_t)(State.regs[srcreg2] & 0xffff)\n+          * (int32_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+\t   * (int32_t)((State.regs[srcreg2] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[dstreg];\n   v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -3212,18 +3212,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg = translate_rreg (SD_, RD0);\n \n-  temp = ((unsigned32)(State.regs[srcreg2] & 0xffff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)\n-\t   * (unsigned32)((State.regs[srcreg2] >> 16) & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg2] & 0xffff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((uint32_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+\t   * (uint32_t)((State.regs[srcreg2] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[dstreg];\n   v = ((State.regs[dstreg] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -3243,19 +3243,19 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n+  int64_t temp;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((signed32)(State.regs[srcreg1] & 0xffff)\n-          * (signed32)(State.regs[srcreg1] & 0xffff));\n+  temp = ((int32_t)(State.regs[srcreg1] & 0xffff)\n+          * (int32_t)(State.regs[srcreg1] & 0xffff));\n   State.regs[dstreg2] = temp;\n-  temp = ((signed32)((State.regs[srcreg1] >> 16) & 0xffff)\n-          * (signed32)((State.regs[srcreg1] >>16) & 0xffff));\n+  temp = ((int32_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+          * (int32_t)((State.regs[srcreg1] >>16) & 0xffff));\n   State.regs[dstreg1] = temp;\n }\n \n@@ -3266,19 +3266,19 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed64 temp;\n+  int64_t temp;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM2);\n   srcreg2 = translate_rreg (SD_, RN0);\n   dstreg1 = translate_rreg (SD_, RD0);\n   dstreg2 = translate_rreg (SD_, RD2);\n \n-  temp = ((unsigned32)(State.regs[srcreg1] & 0xffff)\n-          * (unsigned32)(State.regs[srcreg1] & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg1] & 0xffff)\n+          * (uint32_t)(State.regs[srcreg1] & 0xffff));\n   State.regs[dstreg2] = temp;\n-  temp = ((unsigned32)((State.regs[srcreg1] >> 16) & 0xffff)\n-          * (unsigned32)((State.regs[srcreg1] >>16) & 0xffff));\n+  temp = ((uint32_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+          * (uint32_t)((State.regs[srcreg1] >>16) & 0xffff));\n   State.regs[dstreg1] = temp;\n }\n \n@@ -3396,7 +3396,7 @@\n *am33_2\n {\n   int dstreg, z, n, c, v;\n-  unsigned32 sum, imm, reg2;\n+  uint32_t sum, imm, reg2;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -3437,7 +3437,7 @@\n *am33_2\n {\n   int dstreg, z, n, c, v;\n-  unsigned32 difference, imm, reg2;\n+  uint32_t difference, imm, reg2;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n@@ -3549,7 +3549,7 @@\n *am33_2\n {\n   int dstreg;\n-  signed32 temp;\n+  int32_t temp;\n   int c, z, n;\n \n   PC = cia;\n@@ -3612,14 +3612,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((signed64)(signed32)State.regs[dstreg]\n-          *  (signed64)(signed32)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));\n+  temp = ((int64_t)(int32_t)State.regs[dstreg]\n+          *  (int64_t)(int32_t)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -3635,14 +3635,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)State.regs[dstreg]\n-          *  (unsigned64)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));\n+  temp = ((uint64_t)State.regs[dstreg]\n+          *  (uint64_t)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C)));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -3909,14 +3909,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C))\n-          * (signed64)State.regs[srcreg]);\n+  temp = ((int64_t)EXTEND24 (FETCH24 (IMM24A, IMM24B, IMM24C))\n+          * (int64_t)State.regs[srcreg]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -3937,14 +3937,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C))\n-          * (unsigned64)State.regs[srcreg]);\n+  temp = ((uint64_t) (FETCH24 (IMM24A, IMM24B, IMM24C))\n+          * (uint64_t)State.regs[srcreg]);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -3965,14 +3965,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)EXTEND8 (FETCH24 (IMM24A, IMM24B, IMM24C))\n-          * (signed64)State.regs[srcreg] & 0xff);\n+  temp = ((int64_t)EXTEND8 (FETCH24 (IMM24A, IMM24B, IMM24C))\n+          * (int64_t)State.regs[srcreg] & 0xff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -3993,14 +3993,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C))\n-          * (unsigned64)State.regs[srcreg] & 0xff);\n+  temp = ((uint64_t) (FETCH24 (IMM24A, IMM24B, IMM24C))\n+          * (uint64_t)State.regs[srcreg] & 0xff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -4021,14 +4021,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((signed64)EXTEND16 (FETCH24 (IMM24A, IMM24B, IMM24C))\n-          * (signed64)State.regs[srcreg] & 0xffff);\n+  temp = ((int64_t)EXTEND16 (FETCH24 (IMM24A, IMM24B, IMM24C))\n+          * (int64_t)State.regs[srcreg] & 0xffff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -4049,14 +4049,14 @@\n *am33_2\n {\n   int srcreg;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN2);\n \n-  temp = ((unsigned64) (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffff)\n-          * (unsigned64)State.regs[srcreg] & 0xffff);\n+  temp = ((uint64_t) (FETCH24 (IMM24A, IMM24B, IMM24C) & 0xffff)\n+          * (uint64_t)State.regs[srcreg] & 0xffff);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -4197,7 +4197,7 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned32 imm, reg2, sum;\n+  uint32_t imm, reg2, sum;\n   int z, n, c, v;\n \n   PC = cia;\n@@ -4239,7 +4239,7 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned32 imm, reg2, difference;\n+  uint32_t imm, reg2, difference;\n   int z, n, c, v;\n \n   PC = cia;\n@@ -4352,7 +4352,7 @@\n *am33_2\n {\n   int dstreg;\n-  signed32 temp;\n+  int32_t temp;\n   int c, z, n;\n \n   PC = cia;\n@@ -4414,14 +4414,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((signed64)(signed32)State.regs[dstreg]\n-          *  (signed64)(signed32)(FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));\n+  temp = ((int64_t)(int32_t)State.regs[dstreg]\n+          *  (int64_t)(int32_t)(FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -4437,14 +4437,14 @@\n *am33_2\n {\n   int dstreg;\n-  unsigned64 temp;\n+  uint64_t temp;\n   int z, n;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n \n-  temp = ((unsigned64)State.regs[dstreg]\n-          *  (unsigned64) (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));\n+  temp = ((uint64_t)State.regs[dstreg]\n+          *  (uint64_t) (FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D)));\n   State.regs[dstreg] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[dstreg] == 0);\n@@ -4710,15 +4710,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((signed64)(signed32)State.regs[srcreg]\n-          * (signed64)(signed32)imm);\n+  temp = ((int64_t)(int32_t)State.regs[srcreg]\n+          * (int64_t)(int32_t)imm);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -4739,15 +4739,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed64 temp, sum;\n+  int64_t temp, sum;\n   int c, v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((unsigned64)State.regs[srcreg]\n-          * (unsigned64)imm);\n+  temp = ((uint64_t)State.regs[srcreg]\n+          * (uint64_t)imm);\n   sum = State.regs[REG_MCRL] + (temp & 0xffffffff);\n   c = (sum < State.regs[REG_MCRL]) || (sum < (temp & 0xffffffff));\n   State.regs[REG_MCRL] = sum;\n@@ -4768,15 +4768,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((signed32)(signed8)(State.regs[srcreg] & 0xff)\n-          * (signed32)(signed8)(imm & 0xff));\n+  temp = ((int32_t)(int8_t)(State.regs[srcreg] & 0xff)\n+          * (int32_t)(int8_t)(imm & 0xff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4792,15 +4792,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((unsigned32)(State.regs[srcreg] & 0xff)\n-          * (unsigned32)(imm & 0xff));\n+  temp = ((uint32_t)(State.regs[srcreg] & 0xff)\n+          * (uint32_t)(imm & 0xff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4816,15 +4816,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((signed32)(signed16)(State.regs[srcreg] & 0xffff)\n-          * (signed32)(signed16)(imm & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[srcreg] & 0xffff)\n+          * (int32_t)(int16_t)(imm & 0xffff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4840,15 +4840,15 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, sum;\n+  int32_t temp, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((unsigned32)(State.regs[srcreg] & 0xffff)\n-          * (unsigned32)(imm & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg] & 0xffff)\n+          * (uint32_t)(imm & 0xffff));\n   sum = State.regs[REG_MCRL] + temp;\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4864,17 +4864,17 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((signed32)(signed16)(State.regs[srcreg] & 0xffff)\n-          * (signed32)(signed16)(imm & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg] >> 16) & 0xffff)\n-\t   * (signed32)(signed16)((imm >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[srcreg] & 0xffff)\n+          * (int32_t)(int16_t)(imm & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg] >> 16) & 0xffff)\n+\t   * (int32_t)(int16_t)((imm >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4890,17 +4890,17 @@\n *am33_2\n {\n   int srcreg, imm;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n   int v;\n \n   PC = cia;\n   srcreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((unsigned32)(State.regs[srcreg] & 0xffff)\n-          * (unsigned32)(imm & 0xffff));\n-  temp2 = ((unsigned32)((State.regs[srcreg] >> 16) & 0xffff)\n-\t   * (unsigned32)((imm >> 16) & 0xffff));\n+  temp = ((uint32_t)(State.regs[srcreg] & 0xffff)\n+          * (uint32_t)(imm & 0xffff));\n+  temp2 = ((uint32_t)((State.regs[srcreg] >> 16) & 0xffff)\n+\t   * (uint32_t)((imm >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n   v = ((State.regs[REG_MCRL] & 0x80000000) == (temp & 0x80000000)\n         && (temp & 0x80000000) != (sum & 0x80000000));\n@@ -4916,17 +4916,17 @@\n *am33_2\n {\n   int imm, dstreg;\n-  signed32 temp;\n+  int32_t temp;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg] & 0xffff)\n-          * (signed32)(signed16)(imm & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg] & 0xffff)\n+          * (int32_t)(int16_t)(imm & 0xffff));\n   State.regs[REG_MDRQ] = temp;\n-  temp = ((signed32)(signed16)((State.regs[dstreg] >> 16) & 0xffff)\n-          * (signed32)(signed16)((imm>>16) & 0xffff));\n+  temp = ((int32_t)(int16_t)((State.regs[dstreg] >> 16) & 0xffff)\n+          * (int32_t)(int16_t)((imm>>16) & 0xffff));\n   State.regs[dstreg] = temp;\n }\n \n@@ -4937,17 +4937,17 @@\n *am33_2\n {\n   int imm, dstreg;\n-  signed32 temp;\n+  int32_t temp;\n \n   PC = cia;\n   dstreg = translate_rreg (SD_, RN0);\n   imm = FETCH32 (IMM32A, IMM32B, IMM32C, IMM32D);\n \n-  temp = ((unsigned32)(State.regs[dstreg] & 0xffff)\n-          * (unsigned32)(imm & 0xffff));\n+  temp = ((uint32_t)(State.regs[dstreg] & 0xffff)\n+          * (uint32_t)(imm & 0xffff));\n   State.regs[REG_MDRQ] = temp;\n-  temp = ((unsigned32)((State.regs[dstreg] >> 16) & 0xffff)\n-          * (unsigned32)((imm >>16) & 0xffff));\n+  temp = ((uint32_t)((State.regs[dstreg] >> 16) & 0xffff)\n+          * (uint32_t)((imm >>16) & 0xffff));\n   State.regs[dstreg] = temp;\n }\n \n@@ -7348,18 +7348,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] += State.regs[srcreg2];\n@@ -7373,17 +7373,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] += EXTEND4 (IMM4);\n@@ -7397,18 +7397,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] -= State.regs[srcreg2];\n@@ -7422,17 +7422,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] -= EXTEND4 (IMM4);\n@@ -7446,18 +7446,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   genericCmp (State.regs[srcreg2], State.regs[dstreg2]);\n@@ -7471,17 +7471,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   genericCmp (EXTEND4 (IMM4), State.regs[dstreg2]);\n@@ -7495,18 +7495,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] = State.regs[srcreg2];\n@@ -7520,17 +7520,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] = EXTEND4 (IMM4);\n@@ -7544,18 +7544,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   temp = State.regs[dstreg2];\n@@ -7571,17 +7571,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   temp = State.regs[dstreg2];\n@@ -7597,18 +7597,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] >>= State.regs[srcreg2];\n@@ -7622,17 +7622,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] >>= IMM4;\n@@ -7647,18 +7647,18 @@\n *am33_2\n {\n   int srcreg1, srcreg2, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   srcreg2 = translate_rreg (SD_, RM2);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] <<= State.regs[srcreg2];\n@@ -7672,17 +7672,17 @@\n *am33_2\n {\n   int srcreg1, dstreg1, dstreg2;\n-  signed32 temp, temp2, sum;\n+  int32_t temp, temp2, sum;\n \n   PC = cia;\n   srcreg1 = translate_rreg (SD_, RM1);\n   dstreg1 = translate_rreg (SD_, RN1);\n   dstreg2 = translate_rreg (SD_, RN2);\n \n-  temp = ((signed32)(signed16)(State.regs[dstreg1] & 0xffff)\n-          * (signed32)(signed16)(State.regs[srcreg1] & 0xffff));\n-  temp2 = ((signed32)(signed16)((State.regs[srcreg1] >> 16) & 0xffff)\n-           * (signed32)(signed16)((State.regs[dstreg1] >> 16) & 0xffff));\n+  temp = ((int32_t)(int16_t)(State.regs[dstreg1] & 0xffff)\n+          * (int32_t)(int16_t)(State.regs[srcreg1] & 0xffff));\n+  temp2 = ((int32_t)(int16_t)((State.regs[srcreg1] >> 16) & 0xffff)\n+           * (int32_t)(int16_t)((State.regs[dstreg1] >> 16) & 0xffff));\n   sum = temp + temp2 + State.regs[REG_MCRL];\n \n   State.regs[dstreg2] <<= IMM4;"
    },
    {
      "sha": "b3640b93dacf164403026cdc3ea6201b00eff56c",
      "filename": "sim/mn10300/dv-mn103cpu.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103cpu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103cpu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/dv-mn103cpu.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -113,9 +113,9 @@ struct mn103cpu {\n   int pending_nmi;\n   int pending_reset;\n   /* the visible registers */\n-  unsigned16 interrupt_vector[NR_VECTORS];\n-  unsigned16 internal_memory_control;\n-  unsigned16 cpu_mode;\n+  uint16_t interrupt_vector[NR_VECTORS];\n+  uint16_t internal_memory_control;\n+  uint16_t cpu_mode;\n };\n \n \n@@ -357,7 +357,7 @@ mn103cpu_io_read_buffer (struct hw *me,\n \t\t\t unsigned nr_bytes)\n {\n   struct mn103cpu *controller = hw_data (me);\n-  unsigned16 val = 0;\n+  uint16_t val = 0;\n   enum mn103cpu_regs reg = decode_mn103cpu_addr (me, controller, base);\n \n   switch (reg)\n@@ -383,7 +383,7 @@ mn103cpu_io_read_buffer (struct hw *me,\n     }\n \n   if (nr_bytes == 2)\n-    *(unsigned16*) dest = H2LE_2 (val);\n+    *(uint16_t*) dest = H2LE_2 (val);\n \n   return nr_bytes;\n }     \n@@ -396,14 +396,14 @@ mn103cpu_io_write_buffer (struct hw *me,\n \t\t\t  unsigned nr_bytes)\n {\n   struct mn103cpu *controller = hw_data (me);\n-  unsigned16 val;\n+  uint16_t val;\n   enum mn103cpu_regs reg;\n \n   if (nr_bytes != 2)\n     hw_abort (me, \"must be two byte write\");\n \n   reg = decode_mn103cpu_addr (me, controller, base);\n-  val = LE2H_2 (* (unsigned16 *) source);\n+  val = LE2H_2 (* (uint16_t *) source);\n \n   switch (reg)\n     {"
    },
    {
      "sha": "071d7e5389c7a0efb3fe90a9d96233dfeaae72cc",
      "filename": "sim/mn10300/dv-mn103int.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103int.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103int.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/dv-mn103int.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -517,14 +517,14 @@ decode_group (struct hw *me,\n   return &controller->group[gid];\n }\n \n-static unsigned8\n+static uint8_t\n read_icr (struct hw *me,\n \t  struct mn103int *controller,\n \t  unsigned_word base)\n {\n   unsigned_word offset;\n   struct mn103int_group *group = decode_group (me, controller, base, &offset);\n-  unsigned8 val = 0;\n+  uint8_t val = 0;\n   switch (group->type)\n     {\n \n@@ -571,7 +571,7 @@ static void\n write_icr (struct hw *me,\n \t   struct mn103int *controller,\n \t   unsigned_word base,\n-\t   unsigned8 val)\n+\t   uint8_t val)\n {\n   unsigned_word offset;\n   struct mn103int_group *group = decode_group (me, controller, base, &offset);\n@@ -632,12 +632,12 @@ write_icr (struct hw *me,\n \n /* Read the IAGR (Interrupt accepted group register) */\n \n-static unsigned8\n+static uint8_t\n read_iagr (struct hw *me,\n \t   struct mn103int *controller,\n \t   unsigned_word offset)\n {\n-  unsigned8 val;\n+  uint8_t val;\n   switch (offset)\n     {\n     case 0:\n@@ -687,13 +687,13 @@ external_group (struct mn103int *controller,\n     }\n }\n \n-static unsigned8\n+static uint8_t\n read_extmd (struct hw *me,\n \t    struct mn103int *controller,\n \t    unsigned_word offset)\n {\n   int gid;\n-  unsigned8 val = 0;\n+  uint8_t val = 0;\n   struct mn103int_group *group = external_group (controller, offset);\n   if (group != NULL)\n     {\n@@ -710,7 +710,7 @@ static void\n write_extmd (struct hw *me,\n \t     struct mn103int *controller,\n \t     unsigned_word offset,\n-\t     unsigned8 val)\n+\t     uint8_t val)\n {\n   int gid;\n   struct mn103int_group *group = external_group (controller, offset);\n@@ -756,7 +756,7 @@ mn103int_io_read_buffer (struct hw *me,\n \t\t\t unsigned nr_bytes)\n {\n   struct mn103int *controller = hw_data (me);\n-  unsigned8 *buf = dest;\n+  uint8_t *buf = dest;\n   unsigned byte;\n   /* HW_TRACE ((me, \"read 0x%08lx %d\", (long) base, (int) nr_bytes)); */\n   for (byte = 0; byte < nr_bytes; byte++)\n@@ -789,7 +789,7 @@ mn103int_io_write_buffer (struct hw *me,\n \t\t\t  unsigned nr_bytes)\n {\n   struct mn103int *controller = hw_data (me);\n-  const unsigned8 *buf = source;\n+  const uint8_t *buf = source;\n   unsigned byte;\n   /* HW_TRACE ((me, \"write 0x%08lx %d\", (long) base, (int) nr_bytes)); */\n   for (byte = 0; byte < nr_bytes; byte++)"
    },
    {
      "sha": "515b977b08b25c7e56b5205c2a7e89291473bbc9",
      "filename": "sim/mn10300/dv-mn103iop.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103iop.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103iop.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/dv-mn103iop.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -87,7 +87,7 @@ enum {\n };\n \n typedef struct _mn10300_ioport {\n-  unsigned8 output, output_mode, control, pin;\n+  uint8_t output, output_mode, control, pin;\n   struct hw_event *event;\n } mn10300_ioport;\n \n@@ -96,7 +96,7 @@ typedef struct _mn10300_ioport {\n struct mn103iop {\n   struct mn103iop_block block[NR_BLOCKS];\n   mn10300_ioport port[NR_PORTS];\n-  unsigned8      p2ss, p4ss;\n+  uint8_t      p2ss, p4ss;\n };\n \n \n@@ -215,7 +215,7 @@ read_output_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = io_port->port[io_port_reg].output;\n+      *(uint8_t *)dest = io_port->port[io_port_reg].output;\n     }\n   else\n     {\n@@ -236,7 +236,7 @@ read_output_mode_reg (struct hw *me,\n     {\n       /* check if there are fields which can't be written and\n \t take appropriate action depending what bits are set */\n-      *(unsigned8 *)dest = io_port->port[io_port_reg].output_mode;\n+      *(uint8_t *)dest = io_port->port[io_port_reg].output_mode;\n     }\n   else\n     {\n@@ -255,7 +255,7 @@ read_control_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = io_port->port[io_port_reg].control;\n+      *(uint8_t *)dest = io_port->port[io_port_reg].control;\n     }\n   else\n     {\n@@ -274,7 +274,7 @@ read_pin_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = io_port->port[io_port_reg].pin;\n+      *(uint8_t *)dest = io_port->port[io_port_reg].pin;\n     }\n   else\n     {\n@@ -296,11 +296,11 @@ read_dedicated_control_reg (struct hw *me,\n       /* select on io_port_reg: */\n       if ( io_port_reg == P2SS )\n \t{\n-\t  *(unsigned8 *)dest = io_port->p2ss;\n+\t  *(uint8_t *)dest = io_port->p2ss;\n \t}\n       else\n \t{\n-\t  *(unsigned8 *)dest = io_port->p4ss;\n+\t  *(uint8_t *)dest = io_port->p4ss;\n \t}\n     }\n   else\n@@ -375,7 +375,7 @@ write_output_reg (struct hw *me,\n \t\t  const void *source,\n \t\t  unsigned  nr_bytes)\n {\n-  unsigned8 buf = *(unsigned8 *)source;\n+  uint8_t buf = *(uint8_t *)source;\n   if ( nr_bytes == 1 )\n     {\n       if ( io_port_reg == 3 && (buf & 0xfc) != 0 )\n@@ -402,7 +402,7 @@ write_output_mode_reg (struct hw *me,\n \t\t       const void *source,\n \t\t       unsigned  nr_bytes)\n {\n-  unsigned8 buf = *(unsigned8 *)source;\n+  uint8_t buf = *(uint8_t *)source;\n   if ( nr_bytes == 1 )\n     {\n       /* check if there are fields which can't be written and\n@@ -432,7 +432,7 @@ write_control_reg (struct hw *me,\n \t\t   const void *source,\n \t\t   unsigned  nr_bytes)\n {\n-  unsigned8 buf = *(unsigned8 *)source;\n+  uint8_t buf = *(uint8_t *)source;\n   if ( nr_bytes == 1 )\n     {\n       if ( io_port_reg == 3 && (buf & 0xfc) != 0 )\n@@ -459,7 +459,7 @@ write_dedicated_control_reg (struct hw *me,\n \t\t\t     const void *source,\n \t\t\t     unsigned  nr_bytes)\n {\n-  unsigned8 buf = *(unsigned8 *)source;\n+  uint8_t buf = *(uint8_t *)source;\n   if ( nr_bytes == 1 )\n     {\n       /* select on io_port_reg: */"
    },
    {
      "sha": "c1a61c9798eb70e063e5a60a96f87a9694ef8479",
      "filename": "sim/mn10300/dv-mn103ser.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103ser.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103ser.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/dv-mn103ser.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -81,8 +81,8 @@ enum serial_register_types {\n #define SIO_STAT_RRDY 0x0010\n \n typedef struct _mn10300_serial {\n-  unsigned16 status, control;\n-  unsigned8  txb, rxb, intmode;\n+  uint16_t status, control;\n+  uint8_t  txb, rxb, intmode;\n   struct hw_event *event;\n } mn10300_serial;\n \n@@ -91,7 +91,7 @@ typedef struct _mn10300_serial {\n struct mn103ser {\n   struct mn103ser_block block;\n   mn10300_serial device[NR_SERIAL_DEVS];\n-  unsigned8      serial2_timer_reg;\n+  uint8_t      serial2_timer_reg;\n   do_hw_poll_read_method *reader;\n };\n \n@@ -294,7 +294,7 @@ read_control_reg (struct hw *me,\n   /* really allow 1 byte read, too */\n   if ( nr_bytes == 2 )\n     {\n-      *(unsigned16 *)dest = H2LE_2 (serial->device[serial_reg].control);\n+      *(uint16_t *)dest = H2LE_2 (serial->device[serial_reg].control);\n     }\n   else\n     {\n@@ -313,7 +313,7 @@ read_intmode_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = serial->device[serial_reg].intmode;\n+      *(uint8_t *)dest = serial->device[serial_reg].intmode;\n     }\n   else\n     {\n@@ -332,7 +332,7 @@ read_txb (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = serial->device[serial_reg].txb;\n+      *(uint8_t *)dest = serial->device[serial_reg].txb;\n     }\n   else\n     {\n@@ -351,7 +351,7 @@ read_rxb (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = serial->device[serial_reg].rxb;\n+      *(uint8_t *)dest = serial->device[serial_reg].rxb;\n       /* Reception buffer is now empty. */\n       serial->device[serial_reg].status &= ~SIO_STAT_RRDY;\n     }\n@@ -429,11 +429,11 @@ read_status_reg (struct hw *me,\n \n   if ( nr_bytes == 1 )\n     {\n-      *(unsigned8 *)dest = (unsigned8)serial->device[serial_reg].status;\n+      *(uint8_t *)dest = (uint8_t)serial->device[serial_reg].status;\n     }\n   else if ( nr_bytes == 2 && serial_reg != SC2STR )\n     {\n-      *(unsigned16 *)dest = H2LE_2 (serial->device[serial_reg].status);\n+      *(uint16_t *)dest = H2LE_2 (serial->device[serial_reg].status);\n     }\n   else\n     {\n@@ -451,7 +451,7 @@ read_serial2_timer_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      * (unsigned8 *) dest = (unsigned8) serial->serial2_timer_reg;\n+      * (uint8_t *) dest = (uint8_t) serial->serial2_timer_reg;\n     }\n   else\n     {\n@@ -480,7 +480,7 @@ mn103ser_io_read_buffer (struct hw *me,\n     case SC2CTR:\n       read_control_reg(me, serial, serial_reg-SC0CTR, dest, nr_bytes);\n       HW_TRACE ((me, \"read - ctrl reg%d has 0x%x\\n\", serial_reg-SC0CTR,\n-\t\t *(unsigned8 *)dest));\n+\t\t *(uint8_t *)dest));\n       break;\n \n     /* interrupt mode registers */\n@@ -489,7 +489,7 @@ mn103ser_io_read_buffer (struct hw *me,\n     case SC2ICR:\n       read_intmode_reg(me, serial, serial_reg-SC0ICR, dest, nr_bytes);\n       HW_TRACE ((me, \"read - intmode reg%d has 0x%x\\n\", serial_reg-SC0ICR,\n-\t\t *(unsigned8 *)dest));\n+\t\t *(uint8_t *)dest));\n       break;\n \n     /* transmission buffers */\n@@ -516,12 +516,12 @@ mn103ser_io_read_buffer (struct hw *me,\n     case SC2STR: \n       read_status_reg(me, serial, serial_reg-SC0STR, dest, nr_bytes);\n       HW_TRACE ((me, \"read - status reg%d has 0x%x\\n\", serial_reg-SC0STR,\n-\t\t *(unsigned8 *)dest));\n+\t\t *(uint8_t *)dest));\n       break;\n \n     case SC2TIM:\n       read_serial2_timer_reg(me, serial, dest, nr_bytes);\n-      HW_TRACE ((me, \"read - serial2 timer reg %d\\n\", *(unsigned8 *)dest));\n+      HW_TRACE ((me, \"read - serial2 timer reg %d\\n\", *(uint8_t *)dest));\n       break;\n \n     default:\n@@ -539,7 +539,7 @@ write_control_reg (struct hw *me,\n \t\t   const void *source,\n \t\t   unsigned  nr_bytes)\n {\n-  unsigned16 val = LE2H_2 (*(unsigned16 *)source);\n+  uint16_t val = LE2H_2 (*(uint16_t *)source);\n \n   /* really allow 1 byte write, too */\n   if ( nr_bytes == 2 )\n@@ -568,7 +568,7 @@ write_intmode_reg (struct hw *me,\n \t\t   const void *source,\n \t\t   unsigned  nr_bytes)\n {\n-unsigned8 val = *(unsigned8 *)source;\n+uint8_t val = *(uint8_t *)source;\n \n   if ( nr_bytes == 1 )\n     {\n@@ -604,7 +604,7 @@ write_txb (struct hw *me,\n       SIM_DESC sd = hw_system (me);\n       int status;\n \n-      serial->device[serial_reg].txb = *(unsigned8 *)source;\n+      serial->device[serial_reg].txb = *(uint8_t *)source;\n \n       status = dv_sockser_status (sd);\n       if (!(status & DV_SOCKSER_DISCONNECTED))\n@@ -635,7 +635,7 @@ write_serial2_timer_reg (struct hw *me,\n {\n   if ( nr_bytes == 1 )\n     {\n-      serial->serial2_timer_reg = *(unsigned8 *)source;\n+      serial->serial2_timer_reg = *(uint8_t *)source;\n     }\n   else\n     {\n@@ -663,7 +663,7 @@ mn103ser_io_write_buffer (struct hw *me,\n     case SC1CTR:\n     case SC2CTR:\n       HW_TRACE ((me, \"write - ctrl reg%d has 0x%x, nrbytes=%d.\\n\",\n-\t\t serial_reg-SC0CTR, *(unsigned8 *)source, nr_bytes));\n+\t\t serial_reg-SC0CTR, *(uint8_t *)source, nr_bytes));\n       write_control_reg(me, serial, serial_reg-SC0CTR, source, nr_bytes);\n       break;\n \n@@ -672,7 +672,7 @@ mn103ser_io_write_buffer (struct hw *me,\n     case SC1ICR:\n     case SC2ICR:\n       HW_TRACE ((me, \"write - intmode reg%d has 0x%x, nrbytes=%d.\\n\",\n-\t\t serial_reg-SC0ICR, *(unsigned8 *)source, nr_bytes));\n+\t\t serial_reg-SC0ICR, *(uint8_t *)source, nr_bytes));\n       write_intmode_reg(me, serial, serial_reg-SC0ICR, source, nr_bytes);\n       break;\n \n@@ -701,7 +701,7 @@ mn103ser_io_write_buffer (struct hw *me,\n \n     case SC2TIM:\n       HW_TRACE ((me, \"read - serial2 timer reg %d (nrbytes=%d)\\n\",\n-\t\t *(unsigned8 *)source, nr_bytes));\n+\t\t *(uint8_t *)source, nr_bytes));\n       write_serial2_timer_reg(me, serial, source, nr_bytes);\n       break;\n "
    },
    {
      "sha": "bfda142fd6e8999410ae651fa2181f264bdc21bb",
      "filename": "sim/mn10300/dv-mn103tim.c",
      "status": "modified",
      "additions": 47,
      "deletions": 47,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103tim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/dv-mn103tim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/dv-mn103tim.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -97,12 +97,12 @@ enum timer_register_types {\n #define NR_TIMERS 7\n \n typedef struct _mn10300_timer_regs {\n-  unsigned32 base;\n-  unsigned8  mode;\n+  uint32_t base;\n+  uint8_t  mode;\n } mn10300_timer_regs;\n \n typedef struct _mn10300_timer {\n-  unsigned32 div_ratio, start;\n+  uint32_t div_ratio, start;\n   struct hw_event *event;\n } mn10300_timer;\n \n@@ -113,8 +113,8 @@ struct mn103tim {\n   mn10300_timer timer[NR_TIMERS];\n \n   /* treat timer 6 registers specially. */\n-  unsigned16   tm6md0, tm6md1, tm6bc, tm6ca, tm6cb; \n-  unsigned8  tm6mda, tm6mdb;  /* compare/capture mode regs for timer 6 */\n+  uint16_t   tm6md0, tm6md1, tm6bc, tm6ca, tm6cb; \n+  uint8_t  tm6mda, tm6mdb;  /* compare/capture mode regs for timer 6 */\n };\n \n /* output port ID's */\n@@ -287,33 +287,33 @@ read_mode_reg (struct hw *me,\n \t       void *dest,\n \t       unsigned nr_bytes)\n {\n-  unsigned16 val16;\n-  unsigned32 val32;\n+  uint16_t val16;\n+  uint32_t val32;\n \n   switch ( nr_bytes )\n     {\n     case 1:\n       /* Accessing 1 byte is ok for all mode registers. */\n       if ( timer_nr == 6 )\n \t{\n-\t  *(unsigned8*)dest = timers->tm6md0;\n+\t  *(uint8_t*)dest = timers->tm6md0;\n \t}\n       else\n \t{\n-\t  *(unsigned8*)dest = timers->reg[timer_nr].mode;\n+\t  *(uint8_t*)dest = timers->reg[timer_nr].mode;\n \t}\n       break;\n \n     case 2:\n       if ( timer_nr == 6 )\n \t{\n-\t  *(unsigned16 *)dest = (timers->tm6md0 << 8) | timers->tm6md1;\n+\t  *(uint16_t *)dest = (timers->tm6md0 << 8) | timers->tm6md1;\n \t}\n       else if ( timer_nr == 0 || timer_nr == 2 )\n \t{\n \t  val16 = (timers->reg[timer_nr].mode << 8)\n \t    | timers->reg[timer_nr+1].mode;\n-\t  *(unsigned16*)dest = val16;\n+\t  *(uint16_t*)dest = val16;\n \t}\n       else\n \t{\n@@ -328,7 +328,7 @@ read_mode_reg (struct hw *me,\n \t    | (timers->reg[1].mode << 16)\n \t    | (timers->reg[2].mode << 8)\n \t    | timers->reg[3].mode;\n-\t  *(unsigned32*)dest = val32;\n+\t  *(uint32_t*)dest = val32;\n \t}\n       else\n \t{\n@@ -350,8 +350,8 @@ read_base_reg (struct hw *me,\n \t       void *dest,\n \t       unsigned  nr_bytes)\n {\n-  unsigned16 val16;\n-  unsigned32 val32;\n+  uint16_t val16;\n+  uint32_t val32;\n \n   /* Check nr_bytes: accesses of 1, 2 and 4 bytes allowed depending on timer. */\n   switch ( nr_bytes )\n@@ -360,7 +360,7 @@ read_base_reg (struct hw *me,\n       /* Reading 1 byte is ok for all registers. */\n       if ( timer_nr < NR_8BIT_TIMERS )\n \t{\n-\t  *(unsigned8*)dest = timers->reg[timer_nr].base;\n+\t  *(uint8_t*)dest = timers->reg[timer_nr].base;\n \t}\n       break;\n \n@@ -380,7 +380,7 @@ read_base_reg (struct hw *me,\n \t    {\n \t      val16 = timers->reg[timer_nr].base;\n \t    }\n-\t  *(unsigned16*)dest = val16;\n+\t  *(uint16_t*)dest = val16;\n \t}\n       break;\n \n@@ -389,12 +389,12 @@ read_base_reg (struct hw *me,\n \t{\n \t  val32 = (timers->reg[0].base << 24) | (timers->reg[1].base << 16)\n \t    | (timers->reg[2].base << 8) | timers->reg[3].base;\n-\t  *(unsigned32*)dest = val32;\n+\t  *(uint32_t*)dest = val32;\n \t}\n       else if ( timer_nr == 4 ) \n \t{\n \t  val32 = (timers->reg[4].base << 16) | timers->reg[5].base;\n-\t  *(unsigned32*)dest = val32;\n+\t  *(uint32_t*)dest = val32;\n \t}\n       else\n \t{\n@@ -416,7 +416,7 @@ read_counter (struct hw *me,\n \t      void *dest,\n \t      unsigned  nr_bytes)\n {\n-  unsigned32 val;\n+  uint32_t val;\n \n   if ( NULL == timers->timer[timer_nr].event )\n     {\n@@ -449,15 +449,15 @@ read_counter (struct hw *me,\n \n   switch (nr_bytes) {\n   case 1:\n-    *(unsigned8 *)dest = val;\n+    *(uint8_t *)dest = val;\n     break;\n     \n   case 2:\n-    *(unsigned16 *)dest = val;\n+    *(uint16_t *)dest = val;\n     break;\n \n   case 4:\n-    *(unsigned32 *)dest = val;\n+    *(uint32_t *)dest = val;\n     break;\n \n   default:\n@@ -474,26 +474,26 @@ read_special_timer6_reg (struct hw *me,\n \t\t\t void *dest,\n \t\t\t unsigned  nr_bytes)\n {\n-  unsigned32 val;\n+  uint32_t val;\n \n   switch (nr_bytes) {\n   case 1:\n     {\n       switch ( timer_nr ) {\n       case TM6MDA:\n-\t*(unsigned8 *)dest = timers->tm6mda;\n+\t*(uint8_t *)dest = timers->tm6mda;\n \tbreak;\n     \n       case TM6MDB:\n-\t*(unsigned8 *)dest = timers->tm6mdb;\n+\t*(uint8_t *)dest = timers->tm6mdb;\n \tbreak;\n     \n       case TM6CA:\n-\t*(unsigned8 *)dest = timers->tm6ca;\n+\t*(uint8_t *)dest = timers->tm6ca;\n \tbreak;\n     \n       case TM6CB:\n-\t*(unsigned8 *)dest = timers->tm6cb;\n+\t*(uint8_t *)dest = timers->tm6cb;\n \tbreak;\n       \n       default:\n@@ -505,11 +505,11 @@ read_special_timer6_reg (struct hw *me,\n   case 2:\n     if ( timer_nr == TM6CA )\n       {\n-\t*(unsigned16 *)dest = timers->tm6ca;\n+\t*(uint16_t *)dest = timers->tm6ca;\n       }\n     else if ( timer_nr == TM6CB )\n       {\n-\t*(unsigned16 *)dest = timers->tm6cb;\n+\t*(uint16_t *)dest = timers->tm6cb;\n       }\n     else\n       {\n@@ -642,8 +642,8 @@ write_base_reg (struct hw *me,\n \t\tunsigned  nr_bytes)\n {\n   unsigned i;\n-  const unsigned8 *buf8 = source;\n-  const unsigned16 *buf16 = source;\n+  const uint8_t *buf8 = source;\n+  const uint16_t *buf16 = source;\n \n   /* If TMnCNE == 0 (counting is off),  writing to the base register\n      (TMnBR) causes a simultaneous write to the counter reg (TMnBC).\n@@ -713,16 +713,16 @@ write_mode_reg (struct hw *me,\n      /* for timers 0 to 5 */\n {\n   unsigned i;\n-  unsigned8 mode_val, next_mode_val;\n-  unsigned32 div_ratio;\n+  uint8_t mode_val, next_mode_val;\n+  uint32_t div_ratio;\n \n   if ( nr_bytes != 1 )\n     {\n       hw_abort (me, \"bad write size of %d bytes to TM%ldMD.\", nr_bytes,\n \t\ttimer_nr);\n     }\n \n-  mode_val = *(unsigned8 *)source;\n+  mode_val = *(uint8_t *)source;\n   timers->reg[timer_nr].mode = mode_val;\n       \n   if ( ( mode_val & count_and_load_mask ) == count_and_load_mask )\n@@ -840,8 +840,8 @@ write_tm6md (struct hw *me,\n \t     const void *source,\n \t     unsigned nr_bytes)\n {\n-  unsigned8 mode_val0 = 0x00, mode_val1 = 0x00;\n-  unsigned32 div_ratio;\n+  uint8_t mode_val0 = 0x00, mode_val1 = 0x00;\n+  uint32_t div_ratio;\n   long timer_nr = 6;\n \n   unsigned_word offset = address - timers->block[0].base;\n@@ -854,7 +854,7 @@ write_tm6md (struct hw *me,\n   if ( offset == 0x84 )  /* address of TM6MD */\n     {\n       /*  Fill in first byte of mode */\n-      mode_val0 = *(unsigned8 *)source;\n+      mode_val0 = *(uint8_t *)source;\n       timers->tm6md0 = mode_val0;\n     \n       if ( ( mode_val0 & 0x26 ) != 0 )\n@@ -868,11 +868,11 @@ write_tm6md (struct hw *me,\n       /*  Fill in second byte of mode */\n       if ( nr_bytes == 2 )\n \t{\n-\t  mode_val1 = *(unsigned8 *)source+1;\n+\t  mode_val1 = *(uint8_t *)source+1;\n \t}\n       else\n \t{\n-\t  mode_val1 = *(unsigned8 *)source;\n+\t  mode_val1 = *(uint8_t *)source;\n \t}\n \n       timers->tm6md1 = mode_val1;\n@@ -931,26 +931,26 @@ write_special_timer6_reg (struct hw *me,\n \t\t\t  const void *source,\n \t\t\t  unsigned  nr_bytes)\n {\n-  unsigned32 val;\n+  uint32_t val;\n \n   switch (nr_bytes) {\n   case 1:\n     {\n       switch ( timer_nr ) {\n       case TM6MDA:\n-\ttimers->tm6mda = *(unsigned8 *)source;\n+\ttimers->tm6mda = *(uint8_t *)source;\n \tbreak;\n     \n       case TM6MDB:\n-\ttimers->tm6mdb = *(unsigned8 *)source;\n+\ttimers->tm6mdb = *(uint8_t *)source;\n \tbreak;\n     \n       case TM6CA:\n-\ttimers->tm6ca = *(unsigned8 *)source;\n+\ttimers->tm6ca = *(uint8_t *)source;\n \tbreak;\n     \n       case TM6CB:\n-\ttimers->tm6cb = *(unsigned8 *)source;\n+\ttimers->tm6cb = *(uint8_t *)source;\n \tbreak;\n       \n       default:\n@@ -962,11 +962,11 @@ write_special_timer6_reg (struct hw *me,\n   case 2:\n     if ( timer_nr == TM6CA )\n       {\n-\ttimers->tm6ca = *(unsigned16 *)source;\n+\ttimers->tm6ca = *(uint16_t *)source;\n       }\n     else if ( timer_nr == TM6CB )\n       {\n-\ttimers->tm6cb = *(unsigned16 *)source;\n+\ttimers->tm6cb = *(uint16_t *)source;\n       }\n     else\n       {\n@@ -992,7 +992,7 @@ mn103tim_io_write_buffer (struct hw *me,\n   enum timer_register_types timer_reg;\n \n   HW_TRACE ((me, \"write to 0x%08lx length %d with 0x%x\", (long) base,\n-\t     (int) nr_bytes, *(unsigned32 *)source));\n+\t     (int) nr_bytes, *(uint32_t *)source));\n \n   timer_reg = decode_addr (me, timers, base);\n "
    },
    {
      "sha": "2e7fd1630479802d03e3d3c42e1623cbf34f619f",
      "filename": "sim/mn10300/interp.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/interp.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -320,7 +320,7 @@ sim_create_inferior (SIM_DESC sd,\n   } else {\n     PC = 0;\n   }\n-  CPU_PC_SET (STATE_CPU (sd, 0), (unsigned64) PC);\n+  CPU_PC_SET (STATE_CPU (sd, 0), (uint64_t) PC);\n \n   if (STATE_ARCHITECTURE (sd)->mach == bfd_mach_am33_2)\n     PSW |= PSW_FE;\n@@ -335,7 +335,7 @@ static int\n mn10300_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n {\n   reg_t reg = State.regs[rn];\n-  uint8 *a = memory;\n+  uint8_t *a = memory;\n   a[0] = reg;\n   a[1] = reg >> 8;\n   a[2] = reg >> 16;\n@@ -346,7 +346,7 @@ mn10300_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n static int\n mn10300_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n {\n-  uint8 *a = memory;\n+  uint8_t *a = memory;\n   State.regs[rn] = (a[3] << 24) + (a[2] << 16) + (a[1] << 8) + a[0];\n   return length;\n }"
    },
    {
      "sha": "6330d6f0090a873c14c33de502e3df75d4caed07",
      "filename": "sim/mn10300/mn10300.igen",
      "status": "modified",
      "additions": 76,
      "deletions": 76,
      "changes": 152,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/mn10300.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/mn10300.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/mn10300.igen?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -21,7 +21,7 @@\n *am33_2\n {\n   /*  OP_8000 (); */\n-  signed32 immed = EXTEND8 (IMM8);\n+  int32_t immed = EXTEND8 (IMM8);\n   State.regs[REG_D0+DN0] = immed;\n   PC = cia;\n }\n@@ -776,7 +776,7 @@\n \n {\n   /* OP_2C0000 (); */\n-  unsigned32 value;\n+  uint32_t value;\n \n   PC = cia;\n   value = EXTEND16 (FETCH16(IMM16A, IMM16B));\n@@ -794,7 +794,7 @@\n \n {\n   /* OP_FCCC0000 (); */\n-  unsigned32 value;\n+  uint32_t value;\n \n   PC = cia;\n   value = FETCH32(IMM32A, IMM32B, IMM32C, IMM32D);\n@@ -812,7 +812,7 @@\n \n {\n   /* OP_240000 (); */\n-  unsigned32 value;\n+  uint32_t value;\n \n   PC = cia;\n   value = FETCH16(IMM16A, IMM16B);\n@@ -1734,7 +1734,7 @@\n \n {\n   /* OP_F8FE00 (); */\n-  unsigned32 imm;\n+  uint32_t imm;\n \n   /* Note: no PSW changes. */\n   PC = cia;\n@@ -1753,7 +1753,7 @@\n \n {\n   /* OP_FAFE0000 (); */\n-  unsigned32 imm;\n+  uint32_t imm;\n \n   /* Note: no PSW changes. */\n   PC = cia;\n@@ -1772,7 +1772,7 @@\n \n {\n   /* OP_FCFE0000 (); */\n-  unsigned32 imm;\n+  uint32_t imm;\n \n   /* Note: no PSW changes. */\n   PC = cia;\n@@ -1792,7 +1792,7 @@\n {\n   /* OP_F140 (); */\n   int z, c, n, v;\n-  unsigned32 reg1, reg2, sum;\n+  uint32_t reg1, reg2, sum;\n \n   PC = cia;\n   reg1 = State.regs[REG_D0 + DM1];\n@@ -1912,7 +1912,7 @@\n {\n   /* OP_F180 (); */\n   int z, c, n, v;\n-  unsigned32 reg1, reg2, difference;\n+  uint32_t reg1, reg2, difference;\n \n   PC = cia;\n   reg1 = State.regs[REG_D0 + DM1];\n@@ -1942,12 +1942,12 @@\n \n {\n   /* OP_F240 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]\n-          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);\n+  temp = ((int64_t)(int32_t)State.regs[REG_D0 + DN0]\n+          *  (int64_t)(int32_t)State.regs[REG_D0 + DM1]);\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -1967,12 +1967,12 @@\n \n {\n   /* OP_F250 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((unsigned64)State.regs[REG_D0 + DN0]\n-          * (unsigned64)State.regs[REG_D0 + DM1]);\n+  temp = ((uint64_t)State.regs[REG_D0 + DN0]\n+          * (uint64_t)State.regs[REG_D0 + DM1]);\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDR] = (temp & 0xffffffff00000000LL) >> 32;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -1992,20 +1992,20 @@\n \n {\n   /* OP_F260 (); */\n-  signed64 temp;\n-  signed32 denom;\n+  int64_t temp;\n+  int32_t denom;\n   int n, z, v;\n \n   PC = cia;\n-  denom = (signed32)State.regs[REG_D0 + DM1];\n+  denom = (int32_t)State.regs[REG_D0 + DM1];\n \n   temp = State.regs[REG_MDR];\n   temp <<= 32;\n   temp |= State.regs[REG_D0 + DN0];\n   if ( !(v = (0 == denom)) )\n     {\n-      State.regs[REG_MDR] = temp % (signed32)State.regs[REG_D0 + DM1];\n-      temp /= (signed32)State.regs[REG_D0 + DM1];\n+      State.regs[REG_MDR] = temp % (int32_t)State.regs[REG_D0 + DM1];\n+      temp /= (int32_t)State.regs[REG_D0 + DM1];\n       State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n     }\n   else\n@@ -2030,12 +2030,12 @@\n \n {\n   /* OP_F270 (); */\n-  unsigned64 temp;\n-  unsigned32 denom;\n+  uint64_t temp;\n+  uint32_t denom;\n   int n, z, v;\n \n   PC = cia;\n-  denom = (unsigned32)State.regs[REG_D0 + DM1];\n+  denom = (uint32_t)State.regs[REG_D0 + DM1];\n   temp = State.regs[REG_MDR];\n   temp <<= 32;\n   temp |= State.regs[REG_D0 + DN0];\n@@ -2067,7 +2067,7 @@\n \n {\n   /* OP_40 (); */\n-  unsigned32 imm;\n+  uint32_t imm;\n \n   PC = cia;\n   imm = 1;\n@@ -2591,7 +2591,7 @@\n \n {\n   /* OP_F080 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2615,7 +2615,7 @@\n \n {\n   /* OP_FE000000 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2639,7 +2639,7 @@\n \n {\n   /* OP_FAF00000 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2662,7 +2662,7 @@\n \n {\n   /* OP_F090 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2686,7 +2686,7 @@\n \n {\n   /* OP_FE010000 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2710,7 +2710,7 @@\n \n {\n   /* OP_FAF40000 (); */\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z;\n \n   PC = cia;\n@@ -2733,7 +2733,7 @@\n \n {\n   /* OP_F2B0 (); */\n-  signed32 temp;\n+  int32_t temp;\n   int z, n, c;\n \n   PC = cia;\n@@ -2758,7 +2758,7 @@\n \n {\n   /* OP_F8C800 (); */\n-  signed32 temp;\n+  int32_t temp;\n   int z, n, c;\n \n   PC = cia;\n@@ -2892,7 +2892,7 @@\n \n {\n   /* OP_F284 (); */\n-  unsigned32 value;\n+  uint32_t value;\n   int c,n,z;\n \n   PC = cia;\n@@ -2919,7 +2919,7 @@\n \n {\n   /* OP_F280 (); */\n-  unsigned32 value;\n+  uint32_t value;\n   int c,n,z;\n \n   PC = cia;\n@@ -3499,7 +3499,7 @@\n \n {\n   /* OP_F0F0 (); */\n-  unsigned32 next_pc, sp;\n+  uint32_t next_pc, sp;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -3521,7 +3521,7 @@\n \n {\n   /* OP_FAFF0000 (); */\n-  unsigned32 next_pc, sp;\n+  uint32_t next_pc, sp;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -3543,7 +3543,7 @@\n \n {\n   /* OP_FCFF0000 (); */\n-  unsigned32 next_pc, sp;\n+  uint32_t next_pc, sp;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -3565,7 +3565,7 @@\n \n {\n   /* OP_F0FC (); */\n-  unsigned32 sp;\n+  uint32_t sp;\n \n   sp = State.regs[REG_SP];\n   State.regs[REG_PC] = load_word(sp);\n@@ -3583,7 +3583,7 @@\n \n {\n   /* OP_F0FD (); */\n-  unsigned32 sp;\n+  uint32_t sp;\n \n   sp = State.regs[REG_SP];\n   PSW = load_half(sp);\n@@ -3603,7 +3603,7 @@\n \n {\n   /* OP_F0FE (); */\n-  unsigned32 sp, next_pc;\n+  uint32_t sp, next_pc;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -3685,12 +3685,12 @@\n \n {\n   /* OP_F600 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]\n-          *  (signed64)(signed32)State.regs[REG_D0 + DM1]);\n+  temp = ((int64_t)(int32_t)State.regs[REG_D0 + DN0]\n+          *  (int64_t)(int32_t)State.regs[REG_D0 + DM1]);\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3710,12 +3710,12 @@\n \n {\n   /* OP_F90000 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]\n-          * (signed64)(signed32)EXTEND8 (IMM8));\n+  temp = ((int64_t)(int32_t)State.regs[REG_D0 + DN0]\n+          * (int64_t)(int32_t)EXTEND8 (IMM8));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3735,12 +3735,12 @@\n \n {\n   /* OP_FB000000 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]\n-          * (signed64)(signed32)EXTEND16 (FETCH16(IMM16A, IMM16B)));\n+  temp = ((int64_t)(int32_t)State.regs[REG_D0 + DN0]\n+          * (int64_t)(int32_t)EXTEND16 (FETCH16(IMM16A, IMM16B)));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3760,12 +3760,12 @@\n \n {\n   /* OP_FD000000 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((signed64)(signed32)State.regs[REG_D0 + DN0]\n-          * (signed64)(signed32)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));\n+  temp = ((int64_t)(int32_t)State.regs[REG_D0 + DN0]\n+          * (int64_t)(int32_t)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3785,12 +3785,12 @@\n \n {\n   /* OP_F610 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((unsigned64) State.regs[REG_D0 + DN0]\n-\t  * (unsigned64) State.regs[REG_D0 + DM1]);\n+  temp = ((uint64_t) State.regs[REG_D0 + DN0]\n+\t  * (uint64_t) State.regs[REG_D0 + DM1]);\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3810,12 +3810,12 @@\n \n {\n   /* OP_F91400 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((unsigned64)State.regs[REG_D0 + DN0]\n-\t  * (unsigned64)EXTEND8 (IMM8));\n+  temp = ((uint64_t)State.regs[REG_D0 + DN0]\n+\t  * (uint64_t)EXTEND8 (IMM8));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3835,12 +3835,12 @@\n \n {\n   /* OP_FB140000 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((unsigned64)State.regs[REG_D0 + DN0]\n-\t  * (unsigned64) EXTEND16 (FETCH16(IMM16A, IMM16B)));\n+  temp = ((uint64_t)State.regs[REG_D0 + DN0]\n+\t  * (uint64_t) EXTEND16 (FETCH16(IMM16A, IMM16B)));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3860,12 +3860,12 @@\n \n {\n   /* OP_FD140000 (); */\n-  unsigned64 temp;\n+  uint64_t temp;\n   int n, z;\n \n   PC = cia;\n-  temp = ((unsigned64)State.regs[REG_D0 + DN0]\n-          * (unsigned64)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));\n+  temp = ((uint64_t)State.regs[REG_D0 + DN0]\n+          * (uint64_t)(FETCH32(IMM32A, IMM32B, IMM32C, IMM32D)));\n   State.regs[REG_D0 + DN0] = temp & 0xffffffff;\n   State.regs[REG_MDRQ] = (temp & 0xffffffff00000000LL) >> 32;;\n   z = (State.regs[REG_D0 + DN0] == 0);\n@@ -3975,8 +3975,8 @@\n \n {\n   /* OP_CE00 (); */\n-  unsigned32 sp = State.regs[REG_SP];\n-  unsigned32 mask;\n+  uint32_t sp = State.regs[REG_SP];\n+  uint32_t mask;\n \n   PC = cia;\n   mask = REGS;\n@@ -4074,8 +4074,8 @@\n \n {\n   /* OP_CF00 (); */\n-  unsigned32 sp = State.regs[REG_SP];\n-  unsigned32 mask;\n+  uint32_t sp = State.regs[REG_SP];\n+  uint32_t mask;\n \n   PC = cia;\n   mask = REGS;\n@@ -4173,8 +4173,8 @@\n \n {\n   /* OP_CD000000 (); */\n-  unsigned32 next_pc, sp;\n-  unsigned32 mask;\n+  uint32_t next_pc, sp;\n+  uint32_t mask;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -4282,8 +4282,8 @@\n \n {\n   /* OP_DD000000 (); */\n-  unsigned32 next_pc, sp;\n-  unsigned32 mask;\n+  uint32_t next_pc, sp;\n+  uint32_t mask;\n \n   PC = cia;\n   sp = State.regs[REG_SP];\n@@ -4391,8 +4391,8 @@\n \n {\n   /* OP_DF0000 (); */\n-  unsigned32 sp, offset;\n-  unsigned32 mask;\n+  uint32_t sp, offset;\n+  uint32_t mask;\n \n   PC = cia;\n   State.regs[REG_SP] += IMM8;\n@@ -4496,8 +4496,8 @@\n \n {\n   /* OP_DE0000 (); */\n-  unsigned32 sp, offset;\n-  unsigned32 mask;\n+  uint32_t sp, offset;\n+  uint32_t mask;\n \n   PC = cia;\n   State.regs[REG_SP] += IMM8;"
    },
    {
      "sha": "f1ab23ffe4fb2c7c4f55c7b06542fa6e0ecd599a",
      "filename": "sim/mn10300/mn10300_sim.h",
      "status": "modified",
      "additions": 13,
      "deletions": 20,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/mn10300_sim.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/mn10300_sim.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/mn10300_sim.h?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -11,18 +11,11 @@\n \n extern SIM_DESC simulator;\n \n-typedef unsigned8 uint8;\n-typedef signed8 int8;\n-typedef unsigned16 uint16;\n-typedef signed16 int16;\n-typedef unsigned32 uint32;\n-typedef signed32 int32;\n-\n typedef struct\n {\n-  uint32 low, high;\n+  uint32_t low, high;\n } dword;\n-typedef uint32 reg_t;\n+typedef uint32_t reg_t;\n \n struct simops \n {\n@@ -160,12 +153,12 @@ u642dw (sim_core_read_unaligned_8 (STATE_CPU (simulator, 0), \\\n \t\t\t\t   PC, read_map, (ADDR)))\n \n static INLINE2 dword\n-u642dw (unsigned64 dw)\n+u642dw (uint64_t dw)\n {\n   dword r;\n \n-  r.low = (unsigned32)dw;\n-  r.high = (unsigned32)(dw >> 32);\n+  r.low = (uint32_t)dw;\n+  r.high = (uint32_t)(dw >> 32);\n   return r;\n }\n \n@@ -186,20 +179,20 @@ sim_core_write_unaligned_4 (STATE_CPU (simulator, 0), \\\n sim_core_write_unaligned_8 (STATE_CPU (simulator, 0), \\\n \t\t\t    PC, write_map, (ADDR), dw2u64 (DATA))\n \n-static INLINE2 unsigned64\n+static INLINE2 uint64_t\n dw2u64 (dword data)\n {\n-  return data.low | (((unsigned64)data.high) << 32);\n+  return data.low | (((uint64_t)data.high) << 32);\n }\n \n /* Function declarations.  */\n \n-INLINE_SIM_MAIN (void) genericAdd (unsigned32 source, unsigned32 destReg);\n-INLINE_SIM_MAIN (void) genericSub (unsigned32 source, unsigned32 destReg);\n-INLINE_SIM_MAIN (void) genericCmp (unsigned32 leftOpnd, unsigned32 rightOpnd);\n-INLINE_SIM_MAIN (void) genericOr (unsigned32 source, unsigned32 destReg);\n-INLINE_SIM_MAIN (void) genericXor (unsigned32 source, unsigned32 destReg);\n-INLINE_SIM_MAIN (void) genericBtst (unsigned32 leftOpnd, unsigned32 rightOpnd);\n+INLINE_SIM_MAIN (void) genericAdd (uint32_t source, uint32_t destReg);\n+INLINE_SIM_MAIN (void) genericSub (uint32_t source, uint32_t destReg);\n+INLINE_SIM_MAIN (void) genericCmp (uint32_t leftOpnd, uint32_t rightOpnd);\n+INLINE_SIM_MAIN (void) genericOr (uint32_t source, uint32_t destReg);\n+INLINE_SIM_MAIN (void) genericXor (uint32_t source, uint32_t destReg);\n+INLINE_SIM_MAIN (void) genericBtst (uint32_t leftOpnd, uint32_t rightOpnd);\n INLINE_SIM_MAIN (void) do_syscall (SIM_DESC sd);\n void program_interrupt (SIM_DESC sd, sim_cpu *cpu, sim_cia cia, SIM_SIGNAL sig);\n "
    },
    {
      "sha": "2fccf2da207fd58ec6af70ac15ac17665501a404",
      "filename": "sim/mn10300/op_utils.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/op_utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74ccc978200bc96b48ef52385cadf5ddb131dc21/sim/mn10300/op_utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mn10300/op_utils.c?ref=74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "patch": "@@ -25,10 +25,10 @@\n \n \n INLINE_SIM_MAIN (void)\n-genericAdd(unsigned32 source, unsigned32 destReg)\n+genericAdd(uint32_t source, uint32_t destReg)\n {\n   int z, c, n, v;\n-  unsigned32 dest, sum;\n+  uint32_t dest, sum;\n \n   dest = State.regs[destReg];\n   sum = source + dest;\n@@ -49,10 +49,10 @@ genericAdd(unsigned32 source, unsigned32 destReg)\n \n \n INLINE_SIM_MAIN (void)\n-genericSub(unsigned32 source, unsigned32 destReg)\n+genericSub(uint32_t source, uint32_t destReg)\n {\n   int z, c, n, v;\n-  unsigned32 dest, difference;\n+  uint32_t dest, difference;\n \n   dest = State.regs[destReg];\n   difference = dest - source;\n@@ -70,10 +70,10 @@ genericSub(unsigned32 source, unsigned32 destReg)\n }\n \n INLINE_SIM_MAIN (void)\n-genericCmp(unsigned32 leftOpnd, unsigned32 rightOpnd)\n+genericCmp(uint32_t leftOpnd, uint32_t rightOpnd)\n {\n   int z, c, n, v;\n-  unsigned32 value;\n+  uint32_t value;\n \n   value = rightOpnd - leftOpnd;\n \n@@ -90,7 +90,7 @@ genericCmp(unsigned32 leftOpnd, unsigned32 rightOpnd)\n \n \n INLINE_SIM_MAIN (void)\n-genericOr(unsigned32 source, unsigned32 destReg)\n+genericOr(uint32_t source, uint32_t destReg)\n {\n   int n, z;\n \n@@ -103,7 +103,7 @@ genericOr(unsigned32 source, unsigned32 destReg)\n \n \n INLINE_SIM_MAIN (void)\n-genericXor(unsigned32 source, unsigned32 destReg)\n+genericXor(uint32_t source, uint32_t destReg)\n {\n   int n, z;\n \n@@ -116,9 +116,9 @@ genericXor(unsigned32 source, unsigned32 destReg)\n \n \n INLINE_SIM_MAIN (void)\n-genericBtst(unsigned32 leftOpnd, unsigned32 rightOpnd)\n+genericBtst(uint32_t leftOpnd, uint32_t rightOpnd)\n {\n-  unsigned32 temp;\n+  uint32_t temp;\n   int z, n;\n \n   temp = rightOpnd;"
    }
  ]
}