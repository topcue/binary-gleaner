{
  "sha": "d0ce17d8537fb51583891073abe18d5bb60c0c24",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDBjZTE3ZDg1MzdmYjUxNTgzODkxMDczYWJlMThkNWJiNjBjMGMyNA==",
  "commit": {
    "author": {
      "name": "Caroline Tice",
      "email": "cmtice@google.com",
      "date": "2020-07-01T19:39:08Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-07-16T15:37:15Z"
    },
    "message": "gdb: fix issues with handling DWARF v5 rnglists & .dwo files.\n\nWhile experimenting with GDB on DWARF 5 with split debug (dwo files),\nI discovered that GDB was not reading the rnglist index\nproperly (it needed to be reprocessed in the same way the loclist\nindex does), and that there was no code for reading rnglists out of\ndwo files at all.  Also, the rnglist address reading function\n(dwarf2_rnglists_process) was adding the base address to all rnglist\nentries, when it's only supposed to add it to the DW_RLE_offset_pair\nentries (http://dwarfstd.org/doc/DWARF5.pdf, p. 53), and was not\nhandling several entry types.\n\n- Added 'reprocessing' for reading rnglist index (as is done for loclist\n  index).\n- Added code for reading rnglists out of .dwo files.\n- Added several missing rnglist forms to dwarf2_rnglists_process.\n- Fixed bug that was alwayas adding base address for rnglists (only\n  one form needs that).\n- Updated dwarf2_rnglists_process to read rnglist out of dwo file when\n  appropriate.\n- Added new functions cu_debug_rnglist_section & read_rnglist_index.\n- Added new testcase, dw5-rnglist-test.{cc,exp}\n\nSpecial note about the new testcase:\n\nIn order for the test case to test anything meaningful, it must be\ncompiled with clang, not GCC.  The way to do this is as follows:\n\n$ make check RUNTESTFLAGS=\"CC_FOR_TARGET=/path/to/clang CXX_FOR_TARGET=/path/to/clang++ dw5-rnglist-test.exp\"\n\nThis following version of clang was used for this testing:\n\nclang version 9.0.1-11\nTarget: x86_64-pc-linux-gnu\nThread model: posix\nInstalledDir: /usr/bin\n\nChange-Id: I3053c5ddc345720b8ed81e23a88fe537ab38748d",
    "tree": {
      "sha": "4997f10db6c2b90a0e0c9694b66f902e03116f76",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4997f10db6c2b90a0e0c9694b66f902e03116f76"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d0ce17d8537fb51583891073abe18d5bb60c0c24",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d0ce17d8537fb51583891073abe18d5bb60c0c24",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d0ce17d8537fb51583891073abe18d5bb60c0c24",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d0ce17d8537fb51583891073abe18d5bb60c0c24/comments",
  "author": {
    "login": "cmtice",
    "id": 5561162,
    "node_id": "MDQ6VXNlcjU1NjExNjI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5561162?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cmtice",
    "html_url": "https://github.com/cmtice",
    "followers_url": "https://api.github.com/users/cmtice/followers",
    "following_url": "https://api.github.com/users/cmtice/following{/other_user}",
    "gists_url": "https://api.github.com/users/cmtice/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cmtice/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cmtice/subscriptions",
    "organizations_url": "https://api.github.com/users/cmtice/orgs",
    "repos_url": "https://api.github.com/users/cmtice/repos",
    "events_url": "https://api.github.com/users/cmtice/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cmtice/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "853772cc1874a858406ad9b02cdb14cc8b88392a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/853772cc1874a858406ad9b02cdb14cc8b88392a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/853772cc1874a858406ad9b02cdb14cc8b88392a"
    }
  ],
  "stats": {
    "total": 446,
    "additions": 398,
    "deletions": 48
  },
  "files": [
    {
      "sha": "bafb68e35b7c901981b0a6f286546f2999564dd0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d0ce17d8537fb51583891073abe18d5bb60c0c24",
      "patch": "@@ -1,3 +1,46 @@\n+2020-07-16  Caroline Tice  <cmtice@google.com>\n+\n+\t* dwarf2/read.c (RNGLIST_HEADER_SIZE32) New constant definition.\n+\t(RNGLIST_HEADER_SIZE64): New constant definition.\n+\t(struct dwop_section_names): Add rnglists_dwo.\n+\t(dwop_section_names): Add .debug_rnglists.dwo, .zdebug_rnglists.dwo.\n+\t(struct loclist_header): Rename to 'loclists_rnglists_header'.\n+\t(struct dwo_sections): Add rnglists field.\n+\t(read_attribut_reprocess): Add tag parameter.\n+\t(dwarf2_ranges_read): Add tag parameter & remove forward function decl.\n+\t(cu_debug_rnglists_section): New function (decl & definition).\n+\t(dwarf2_locate_dwo_sections): Add code to read rnglists_dwo section.\n+\t(dwarf2_rnglists_process): Add a dwarf_tag parameter, for the kind of\n+\tdie whose range is being checked; get rnglist section from\n+\tcu_debug_rnglists_section, to get from either objfile or dwo file as\n+\tappropriate.  Add cases for DW_RLE_base_addressx,\n+\tDW_RLE_startx_length, DW_RLE_startx_endx.  Also, update to only add\n+\tthe base address to DW_RLE_offset_pairs (not to all ranges), moving\n+\ttest inside if-condition and updating complaint message.\n+\t(dwarf2_ranges_process): Add dwarf tag parameter and pass it to\n+\tdwarf2_rnglists_process.\n+\t(dwarf2_ranges_read): Add dwarf tag parameter and pass it to\n+\tdwarf2_ranges_process.\n+\t(dwarf2_get_pc_bounds): Check for DW_FORM_rnglistx when setting\n+\tneed_ranges_base and update comment appropriately.  Also pass die tag\n+\tto dwarf2_ranges_read.\n+\t(dwarf2_record_block_ranges): Check for DW_FORM_rnglistx when setting\n+\tneed_ranges_base and update comment appropriately.  Also pass die tag\n+\tto dwarf2_ranges_process.\n+\t(read_full_die_1): Add code to read DW_AT_rnglists_base and assign to\n+\tcu->ranges_base.  Also pass die tag to read_attribute_reprocess.\n+\t(partial_die_info::read): Check for DW_FORM_rnglistx when setting\n+\tneed_ranges_base and update comment appropriately.  Also pass die tag\n+\tto read_attribute_reprocess and dwarf2_ranges_read.\n+\t(read_loclist_header): Rename function to read_loclists_rnglists_header,\n+\tand update function comment appropriately.\n+\t(read_loclist_index): Call read_loclists_rnglists_header instead of\n+\tread_loclist_header.\n+\t(read_rnglist_index): New function.\n+\t(read_attribute_reprocess):  Add tag parameter. Add code for\n+\tDW_FORM_rnglistx, passing tag to read_rnglist_index.\n+\t(read_attribute_value): Mark DW_FORM_rnglistx with need_reprocess.\n+\n 2020-07-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-typeprint.c (f_type_print_base): Allow for dynamic types not"
    },
    {
      "sha": "39ed455def5dc7838de4283e52eb6632a83fba7d",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 213,
      "deletions": 48,
      "changes": 261,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=d0ce17d8537fb51583891073abe18d5bb60c0c24",
      "patch": "@@ -132,6 +132,12 @@ static int dwarf2_loclist_block_index;\n /* Size of .debug_loclists section header for 64-bit DWARF format.  */\n #define LOCLIST_HEADER_SIZE64 20\n \n+/* Size of .debug_rnglists section header for 32-bit DWARF format.  */\n+#define RNGLIST_HEADER_SIZE32 12\n+\n+/* Size of .debug_rnglists section header for 64-bit DWARF format.  */\n+#define RNGLIST_HEADER_SIZE64 20\n+\n /* An index into a (C++) symbol name component in a symbol name as\n    recorded in the mapped_index's symbol table.  For each C++ symbol\n    in the symbol table, we record one entry for the start of each\n@@ -340,6 +346,7 @@ static const struct dwop_section_names\n   struct dwarf2_section_names loclists_dwo;\n   struct dwarf2_section_names macinfo_dwo;\n   struct dwarf2_section_names macro_dwo;\n+  struct dwarf2_section_names rnglists_dwo;\n   struct dwarf2_section_names str_dwo;\n   struct dwarf2_section_names str_offsets_dwo;\n   struct dwarf2_section_names types_dwo;\n@@ -355,6 +362,7 @@ dwop_section_names =\n   { \".debug_loclists.dwo\", \".zdebug_loclists.dwo\" },\n   { \".debug_macinfo.dwo\", \".zdebug_macinfo.dwo\" },\n   { \".debug_macro.dwo\", \".zdebug_macro.dwo\" },\n+  { \".debug_rnglists.dwo\", \".zdebug_rnglists.dwo\" },\n   { \".debug_str.dwo\", \".zdebug_str.dwo\" },\n   { \".debug_str_offsets.dwo\", \".zdebug_str_offsets.dwo\" },\n   { \".debug_types.dwo\", \".zdebug_types.dwo\" },\n@@ -364,9 +372,9 @@ dwop_section_names =\n \n /* local data types */\n \n-/* The location list section (.debug_loclists) begins with a header,\n-   which contains the following information.  */\n-struct loclist_header\n+/* The location list and range list sections (.debug_loclists & .debug_rnglists)\n+   begin with a header,  which contains the following information.  */\n+struct loclists_rnglists_header\n {\n   /* A 4-byte or 12-byte length containing the length of the\n      set of entries for this compilation unit, not including the\n@@ -650,6 +658,7 @@ struct dwo_sections\n   struct dwarf2_section_info loclists;\n   struct dwarf2_section_info macinfo;\n   struct dwarf2_section_info macro;\n+  struct dwarf2_section_info rnglists;\n   struct dwarf2_section_info str;\n   struct dwarf2_section_info str_offsets;\n   /* In the case of a virtual DWO file, these two are unused.  */\n@@ -1274,7 +1283,7 @@ static const gdb_byte *read_attribute (const struct die_reader_specs *,\n \t\t\t\t       const gdb_byte *, bool *need_reprocess);\n \n static void read_attribute_reprocess (const struct die_reader_specs *reader,\n-\t\t\t\t      struct attribute *attr);\n+\t\t\t\t      struct attribute *attr, dwarf_tag tag);\n \n static CORE_ADDR read_addr_index (struct dwarf2_cu *cu, unsigned int addr_index);\n \n@@ -1378,12 +1387,13 @@ static void read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu);\n \n static void read_variable (struct die_info *die, struct dwarf2_cu *cu);\n \n-static int dwarf2_ranges_read (unsigned, CORE_ADDR *, CORE_ADDR *,\n-\t\t\t       struct dwarf2_cu *, dwarf2_psymtab *);\n-\n /* Return the .debug_loclists section to use for cu.  */\n static struct dwarf2_section_info *cu_debug_loc_section (struct dwarf2_cu *cu);\n \n+/* Return the .debug_rnglists section to use for cu.  */\n+static struct dwarf2_section_info *cu_debug_rnglists_section\n+  (struct dwarf2_cu *cu, dwarf_tag tag);\n+\n /* How dwarf2_get_pc_bounds constructed its *LOWPC and *HIGHPC return\n    values.  Keep the items ordered with increasing constraints compliance.  */\n enum pc_bounds_kind\n@@ -12447,6 +12457,11 @@ dwarf2_locate_dwo_sections (bfd *abfd, asection *sectp, void *dwo_sections_ptr)\n       dwo_sections->macro.s.section = sectp;\n       dwo_sections->macro.size = bfd_section_size (sectp);\n     }\n+  else if (section_is_p (sectp->name, &names->rnglists_dwo))\n+    {\n+      dwo_sections->rnglists.s.section = sectp;\n+      dwo_sections->rnglists.size = bfd_section_size (sectp);\n+    }\n   else if (section_is_p (sectp->name, &names->str_dwo))\n     {\n       dwo_sections->str.s.section = sectp;\n@@ -13791,7 +13806,7 @@ read_variable (struct die_info *die, struct dwarf2_cu *cu)\n template <typename Callback>\n static bool\n dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n-\t\t\t Callback &&callback)\n+\t\t\t dwarf_tag tag, Callback &&callback)\n {\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n   struct objfile *objfile = per_objfile->objfile;\n@@ -13801,26 +13816,29 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n   const gdb_byte *buffer;\n   CORE_ADDR baseaddr;\n   bool overflow = false;\n+  ULONGEST addr_index;\n+  struct dwarf2_section_info *rnglists_section;\n \n   base = cu->base_address;\n+  rnglists_section = cu_debug_rnglists_section (cu, tag);\n+  rnglists_section->read (objfile);\n \n-  per_objfile->per_bfd->rnglists.read (objfile);\n-  if (offset >= per_objfile->per_bfd->rnglists.size)\n+  if (offset >= rnglists_section->size)\n     {\n       complaint (_(\"Offset %d out of bounds for DW_AT_ranges attribute\"),\n \t\t offset);\n       return false;\n     }\n-  buffer = per_objfile->per_bfd->rnglists.buffer + offset;\n+  buffer = rnglists_section->buffer + offset;\n \n   baseaddr = objfile->text_section_offset ();\n \n   while (1)\n     {\n       /* Initialize it due to a false compiler warning.  */\n       CORE_ADDR range_beginning = 0, range_end = 0;\n-      const gdb_byte *buf_end = (per_objfile->per_bfd->rnglists.buffer\n-\t\t\t\t + per_objfile->per_bfd->rnglists.size);\n+      const gdb_byte *buf_end = (rnglists_section->buffer\n+\t\t\t\t + rnglists_section->size);\n       unsigned int bytes_read;\n \n       if (buffer == buf_end)\n@@ -13842,6 +13860,11 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t  base = cu->header.read_address (obfd, buffer, &bytes_read);\n \t  buffer += bytes_read;\n \t  break;\n+        case DW_RLE_base_addressx:\n+          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+          buffer += bytes_read;\n+          base = read_addr_index (cu, addr_index);\n+          break;\n \tcase DW_RLE_start_length:\n \t  if (buffer + cu->header.addr_size > buf_end)\n \t    {\n@@ -13860,6 +13883,19 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t      break;\n \t    }\n \t  break;\n+\tcase DW_RLE_startx_length:\n+          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+          buffer += bytes_read;\n+          range_beginning = read_addr_index (cu, addr_index);\n+          if (buffer > buf_end)\n+            {\n+              overflow = true;\n+              break;\n+            }\n+          range_end = (range_beginning\n+                       + read_unsigned_leb128 (obfd, buffer, &bytes_read));\n+          buffer += bytes_read;\n+          break;\n \tcase DW_RLE_offset_pair:\n \t  range_beginning = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n \t  buffer += bytes_read;\n@@ -13888,6 +13924,19 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \t  range_end = cu->header.read_address (obfd, buffer, &bytes_read);\n \t  buffer += bytes_read;\n \t  break;\n+\tcase DW_RLE_startx_endx:\n+          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+          buffer += bytes_read;\n+          range_beginning = read_addr_index (cu, addr_index);\n+          if (buffer > buf_end)\n+            {\n+              overflow = true;\n+              break;\n+            }\n+          addr_index = read_unsigned_leb128 (obfd, buffer, &bytes_read);\n+          buffer += bytes_read;\n+          range_end = read_addr_index (cu, addr_index);\n+          break;\n \tdefault:\n \t  complaint (_(\"Invalid .debug_rnglists data (no base address)\"));\n \t  return false;\n@@ -13897,14 +13946,6 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n       if (rlet == DW_RLE_base_address)\n \tcontinue;\n \n-      if (!base.has_value ())\n-\t{\n-\t  /* We have no valid base address for the ranges\n-\t     data.  */\n-\t  complaint (_(\"Invalid .debug_rnglists data (no base address)\"));\n-\t  return false;\n-\t}\n-\n       if (range_beginning > range_end)\n \t{\n \t  /* Inverted range entries are invalid.  */\n@@ -13916,8 +13957,20 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n       if (range_beginning == range_end)\n \tcontinue;\n \n-      range_beginning += *base;\n-      range_end += *base;\n+      /* Only DW_RLE_offset_pair needs the base address added.  */\n+      if (rlet == DW_RLE_offset_pair)\n+\t{\n+\t  if (!base.has_value ())\n+\t    {\n+\t      /* We have no valid base address for the DW_RLE_offset_pair.  */\n+\t      complaint (_(\"Invalid .debug_rnglists data (no base address for \"\n+\t\t\t   \"DW_RLE_offset_pair)\"));\n+\t      return false;\n+\t    }\n+\n+\t  range_beginning += *base;\n+\t  range_end += *base;\n+\t}\n \n       /* A not-uncommon case of bad debug info.\n \t Don't pollute the addrmap with bad data.  */\n@@ -13950,7 +14003,7 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \n template <typename Callback>\n static int\n-dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n+dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu, dwarf_tag tag,\n \t\t       Callback &&callback)\n {\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n@@ -13966,7 +14019,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n   CORE_ADDR baseaddr;\n \n   if (cu_header->version >= 5)\n-    return dwarf2_rnglists_process (offset, cu, callback);\n+    return dwarf2_rnglists_process (offset, cu, tag, callback);\n \n   base = cu->base_address;\n \n@@ -14052,7 +14105,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n static int\n dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,\n \t\t    CORE_ADDR *high_return, struct dwarf2_cu *cu,\n-\t\t    dwarf2_psymtab *ranges_pst)\n+\t\t    dwarf2_psymtab *ranges_pst, dwarf_tag tag)\n {\n   struct objfile *objfile = cu->per_objfile->objfile;\n   struct gdbarch *gdbarch = objfile->arch ();\n@@ -14062,7 +14115,7 @@ dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,\n   CORE_ADDR high = 0;\n   int retval;\n \n-  retval = dwarf2_ranges_process (offset, cu,\n+  retval = dwarf2_ranges_process (offset, cu, tag,\n     [&] (CORE_ADDR range_beginning, CORE_ADDR range_end)\n     {\n       if (ranges_pst != NULL)\n@@ -14154,16 +14207,23 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n \t{\n \t  /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t     We take advantage of the fact that DW_AT_ranges does not appear\n-\t     in DW_TAG_compile_unit of DWO files.  */\n-\t  int need_ranges_base = die->tag != DW_TAG_compile_unit;\n+\t     in DW_TAG_compile_unit of DWO files.\n+\n+\t     Attributes of the form DW_FORM_rnglistx have already had their\n+\t     value changed by read_rnglist_index and already include\n+\t     DW_AT_rnglists_base, so don't need to add the ranges base,\n+\t     either.  */\n+\t  int need_ranges_base = (die->tag != DW_TAG_compile_unit\n+\t\t\t\t  && attr->form != DW_FORM_rnglistx);\n \t  unsigned int ranges_offset = (DW_UNSND (attr)\n \t\t\t\t\t+ (need_ranges_base\n \t\t\t\t\t   ? cu->ranges_base\n \t\t\t\t\t   : 0));\n \n \t  /* Value of the DW_AT_ranges attribute is the offset in the\n \t     .debug_ranges section.  */\n-\t  if (!dwarf2_ranges_read (ranges_offset, &low, &high, cu, pst))\n+\t  if (!dwarf2_ranges_read (ranges_offset, &low, &high, cu, pst,\n+\t\t\t\t   die->tag))\n \t    return PC_BOUNDS_INVALID;\n \t  /* Found discontinuous range of addresses.  */\n \t  ret = PC_BOUNDS_RANGES;\n@@ -14325,16 +14385,22 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n     {\n       /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t We take advantage of the fact that DW_AT_ranges does not appear\n-\t in DW_TAG_compile_unit of DWO files.  */\n-      int need_ranges_base = die->tag != DW_TAG_compile_unit;\n+\t in DW_TAG_compile_unit of DWO files.\n+\n+\t Attributes of the form DW_FORM_rnglistx have already had their\n+\t value changed by read_rnglist_index and already include\n+\t DW_AT_rnglists_base, so don't need to add the ranges base,\n+\t either.  */\n+      int need_ranges_base = (die->tag != DW_TAG_compile_unit\n+\t\t\t      && attr->form != DW_FORM_rnglistx);\n \n       /* The value of the DW_AT_ranges attribute is the offset of the\n          address range list in the .debug_ranges section.  */\n       unsigned long offset = (DW_UNSND (attr)\n \t\t\t      + (need_ranges_base ? cu->ranges_base : 0));\n \n       std::vector<blockrange> blockvec;\n-      dwarf2_ranges_process (offset, cu,\n+      dwarf2_ranges_process (offset, cu, die->tag,\n \t[&] (CORE_ADDR start, CORE_ADDR end)\n \t{\n \t  start += baseaddr;\n@@ -18154,8 +18220,13 @@ read_full_die_1 (const struct die_reader_specs *reader,\n   auto maybe_addr_base = die->addr_base ();\n   if (maybe_addr_base.has_value ())\n     cu->addr_base = *maybe_addr_base;\n+\n+  attr = die->attr (DW_AT_rnglists_base);\n+  if (attr != nullptr)\n+    cu->ranges_base = DW_UNSND (attr);\n+\n   for (int index : indexes_that_need_reprocess)\n-    read_attribute_reprocess (reader, &die->attrs[index]);\n+    read_attribute_reprocess (reader, &die->attrs[index], die->tag);\n   *diep = die;\n   return info_ptr;\n }\n@@ -18524,7 +18595,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n          already been read at this point, so there is no need to wait until\n \t the loop terminates to do the reprocessing.  */\n       if (need_reprocess)\n-\tread_attribute_reprocess (reader, &attr);\n+\tread_attribute_reprocess (reader, &attr, tag);\n       /* Store the data if it is of an attribute we want to keep in a\n          partial symbol table.  */\n       switch (attr.name)\n@@ -18670,10 +18741,16 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \n \tcase DW_AT_ranges:\n \t  {\n-\t    /* It would be nice to reuse dwarf2_get_pc_bounds here,\n-\t       but that requires a full DIE, so instead we just\n-\t       reimplement it.  */\n-\t    int need_ranges_base = tag != DW_TAG_compile_unit;\n+\t    /* DW_AT_rnglists_base does not apply to DIEs from the DWO\n+\t       skeleton.  We take advantage of the fact the DW_AT_ranges\n+\t       does not appear in DW_TAG_compile_unit of DWO files.\n+\n+\t       Attributes of the form DW_FORM_rnglistx have already had\n+               their value changed by read_rnglist_index and already\n+\t       include DW_AT_rnglists_base, so don't need to add the ranges\n+\t       base, either.  */\n+\t    int need_ranges_base = (tag != DW_TAG_compile_unit\n+\t\t\t\t    && attr.form != DW_FORM_rnglistx);\n \t    unsigned int ranges_offset = (DW_UNSND (&attr)\n \t\t\t\t\t  + (need_ranges_base\n \t\t\t\t\t     ? cu->ranges_base\n@@ -18682,7 +18759,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t    /* Value of the DW_AT_ranges attribute is the offset in the\n \t       .debug_ranges section.  */\n \t    if (dwarf2_ranges_read (ranges_offset, &lowpc, &highpc, cu,\n-\t\t\t\t    nullptr))\n+\t\t\t\t    nullptr, tag))\n \t      has_pc_info = 1;\n \t  }\n \t  break;\n@@ -19006,11 +19083,11 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n   fixup_called = 1;\n }\n \n-/* Read the .debug_loclists header contents from the given SECTION in the\n-   HEADER.  */\n+/* Read the .debug_loclists or .debug_rnglists header (they are the same format)\n+   contents from the given SECTION in the HEADER.  */\n static void\n-read_loclist_header (struct loclist_header *header,\n-\t\t      struct dwarf2_section_info *section)\n+read_loclists_rnglists_header (struct loclists_rnglists_header *header,\n+\t\t\t       struct dwarf2_section_info *section)\n {\n   unsigned int bytes_read;\n   bfd *abfd = section->get_bfd_owner ();\n@@ -19063,8 +19140,8 @@ read_loclist_index (struct dwarf2_cu *cu, ULONGEST loclist_index)\n   if (section->buffer == NULL)\n     complaint (_(\"DW_FORM_loclistx used without .debug_loclists \"\n \t        \"section [in module %s]\"), objfile_name (objfile));\n-  struct loclist_header header;\n-  read_loclist_header (&header, section);\n+  struct loclists_rnglists_header header;\n+  read_loclists_rnglists_header (&header, section);\n   if (loclist_index >= header.offset_entry_count)\n     complaint (_(\"DW_FORM_loclistx pointing outside of \"\n \t        \".debug_loclists offset array [in module %s]\"),\n@@ -19083,13 +19160,68 @@ read_loclist_index (struct dwarf2_cu *cu, ULONGEST loclist_index)\n     return bfd_get_64 (abfd, info_ptr) + loclist_base;\n }\n \n+/* Given a DW_FORM_rnglistx value RNGLIST_INDEX, fetch the offset from the\n+   array of offsets in the .debug_rnglists section.  */\n+static CORE_ADDR\n+read_rnglist_index (struct dwarf2_cu *cu, ULONGEST rnglist_index,\n+\t\t    dwarf_tag tag)\n+{\n+  struct dwarf2_per_objfile *dwarf2_per_objfile = cu->per_objfile;\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n+  bfd *abfd = objfile->obfd;\n+  ULONGEST rnglist_header_size =\n+    (cu->header.initial_length_size == 4 ? RNGLIST_HEADER_SIZE32\n+     : RNGLIST_HEADER_SIZE64);\n+  ULONGEST rnglist_base =\n+      (cu->dwo_unit != nullptr) ? rnglist_header_size : cu->ranges_base;\n+  ULONGEST start_offset =\n+    rnglist_base + rnglist_index * cu->header.offset_size;\n+\n+  /* Get rnglists section.  */\n+  struct dwarf2_section_info *section = cu_debug_rnglists_section (cu, tag);\n+\n+  /* Read the rnglists section content.  */\n+  section->read (objfile);\n+  if (section->buffer == nullptr)\n+    error (_(\"DW_FORM_rnglistx used without .debug_rnglists section \"\n+\t     \"[in module %s]\"),\n+\t   objfile_name (objfile));\n+\n+  /* Verify the rnglist index is valid.  */\n+  struct loclists_rnglists_header header;\n+  read_loclists_rnglists_header (&header, section);\n+  if (rnglist_index >= header.offset_entry_count)\n+    error (_(\"DW_FORM_rnglistx index pointing outside of \"\n+\t     \".debug_rnglists offset array [in module %s]\"),\n+\t   objfile_name (objfile));\n+\n+  /* Validate that the offset is within the section's range.  */\n+  if (start_offset >= section->size)\n+    error (_(\"DW_FORM_rnglistx pointing outside of \"\n+             \".debug_rnglists section [in module %s]\"),\n+\t   objfile_name (objfile));\n+\n+  /* Validate that reading won't go beyond the end of the section.  */\n+  if (start_offset + cu->header.offset_size > rnglist_base + section->size)\n+    error (_(\"Reading DW_FORM_rnglistx index beyond end of\"\n+\t     \".debug_rnglists section [in module %s]\"),\n+\t   objfile_name (objfile));\n+\n+  const gdb_byte *info_ptr = section->buffer + start_offset;\n+\n+  if (cu->header.offset_size == 4)\n+    return read_4_bytes (abfd, info_ptr) + rnglist_base;\n+  else\n+    return read_8_bytes (abfd, info_ptr) + rnglist_base;\n+}\n+\n /* Process the attributes that had to be skipped in the first round. These\n    attributes are the ones that need str_offsets_base or addr_base attributes.\n    They could not have been processed in the first round, because at the time\n    the values of str_offsets_base or addr_base may not have been known.  */\n static void\n read_attribute_reprocess (const struct die_reader_specs *reader,\n-\t\t\t  struct attribute *attr)\n+\t\t\t  struct attribute *attr, dwarf_tag tag)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   switch (attr->form)\n@@ -19101,6 +19233,9 @@ read_attribute_reprocess (const struct die_reader_specs *reader,\n       case DW_FORM_loclistx:\n \t DW_UNSND (attr) = read_loclist_index (cu, DW_UNSND (attr));\n \t break;\n+      case DW_FORM_rnglistx:\n+        DW_UNSND (attr) = read_rnglist_index (cu, DW_UNSND (attr), tag);\n+        break;\n       case DW_FORM_strx:\n       case DW_FORM_strx1:\n       case DW_FORM_strx2:\n@@ -19282,8 +19417,10 @@ read_attribute_value (const struct die_reader_specs *reader,\n       DW_SND (attr) = read_signed_leb128 (abfd, info_ptr, &bytes_read);\n       info_ptr += bytes_read;\n       break;\n-    case DW_FORM_udata:\n     case DW_FORM_rnglistx:\n+      *need_reprocess = true;\n+      /* FALLTHROUGH */\n+    case DW_FORM_udata:\n       DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n       info_ptr += bytes_read;\n       break;\n@@ -23372,6 +23509,34 @@ cu_debug_loc_section (struct dwarf2_cu *cu)\n \t\t\t\t  : &per_objfile->per_bfd->loc);\n }\n \n+/* Return the .debug_rnglists section to use for CU.  */\n+static struct dwarf2_section_info *\n+cu_debug_rnglists_section (struct dwarf2_cu *cu, dwarf_tag tag)\n+{\n+  if (cu->header.version < 5)\n+    error (_(\".debug_rnglists section cannot be used in DWARF %d\"),\n+\t   cu->header.version);\n+  struct dwarf2_per_objfile *dwarf2_per_objfile = cu->per_objfile;\n+\n+  /* Make sure we read the .debug_rnglists section from the file that\n+     contains the DW_AT_ranges attribute we are reading.  Normally that\n+     would be the .dwo file, if there is one.  However for DW_TAG_compile_unit\n+     or DW_TAG_skeleton unit, we always want to read from objfile/linked\n+     program.  */\n+  if (cu->dwo_unit != nullptr\n+      && tag != DW_TAG_compile_unit\n+      && tag != DW_TAG_skeleton_unit)\n+    {\n+      struct dwo_sections *sections = &cu->dwo_unit->dwo_file->sections;\n+\n+      if (sections->rnglists.size > 0)\n+\treturn &sections->rnglists;\n+      else\n+\terror (_(\".debug_rnglists section is missing from .dwo file.\"));\n+    }\n+  return &dwarf2_per_objfile->per_bfd->rnglists;\n+}\n+\n /* A helper function that fills in a dwarf2_loclist_baton.  */\n \n static void"
    },
    {
      "sha": "5eb9847b3e086ecc02f23889669bbbba206bcaae",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d0ce17d8537fb51583891073abe18d5bb60c0c24",
      "patch": "@@ -1,3 +1,8 @@\n+2020-07-16  Caroline Tice  <cmtice@google.com>\n+\n+\t* gdb.dwarf2/dw5-rnglist-test.cc: New file.\n+\t* gdb.dwarf2/dw5-rnglist-test.exp: New file.\n+\n 2020-07-16  Tom de Vries  <tdevries@suse.de>\n \n \t* lib/dwarf.exp (program): Initialize _line."
    },
    {
      "sha": "81693f569d921346d1b4b5c020e1a47199e56fe4",
      "filename": "gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.cc",
      "status": "added",
      "additions": 97,
      "deletions": 0,
      "changes": 97,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.cc?ref=d0ce17d8537fb51583891073abe18d5bb60c0c24",
      "patch": "@@ -0,0 +1,97 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <iostream>\n+#include <vector>\n+\n+struct node {\n+  int id;\n+  node *left;\n+  node *right;\n+  bool visited;\n+};\n+\n+node  node_array[50];\n+unsigned int CUR_IDX = 0;\n+\n+node *\n+make_node (int val)\n+{\n+  node *new_node = &(node_array[CUR_IDX++]);\n+  new_node->left = NULL;\n+  new_node->right = NULL;\n+  new_node->id = val;\n+  new_node->visited = false;\n+\n+  return new_node;\n+}\n+\n+void\n+tree_insert (node *root, int val)\n+{\n+  if (val < root->id)\n+    {\n+      if (root->left)\n+        tree_insert (root->left, val);\n+      else\n+        root->left = make_node(val);\n+    }\n+  else if (val > root->id)\n+    {\n+      if (root->right)\n+        tree_insert (root->right, val);\n+      else\n+        root->right = make_node(val);\n+    }\n+}\n+\n+void\n+inorder (node *root)\n+{\n+  std::vector<node *> todo;\n+  todo.push_back (root);\n+  while (!todo.empty())\n+    {\n+      node *curr = todo.back();\n+      todo.pop_back(); /* break-here */\n+      if (curr->visited)\n+        std::cout << curr->id << \" \";\n+      else\n+        {\n+          curr->visited = true;\n+          if (curr->right)\n+            todo.push_back (curr->right);\n+          todo.push_back (curr);\n+          if (curr->left)\n+            todo.push_back (curr->left);\n+        }\n+    }\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  node *root = make_node (35);\n+\n+  tree_insert (root, 28);\n+  tree_insert (root, 20);\n+  tree_insert (root, 60);\n+\n+  inorder (root);\n+\n+  return 0;\n+}"
    },
    {
      "sha": "af6c34b5ddb79cff65799c98a1aa276dfe917934",
      "filename": "gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.exp",
      "status": "added",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0ce17d8537fb51583891073abe18d5bb60c0c24/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw5-rnglist-test.exp?ref=d0ce17d8537fb51583891073abe18d5bb60c0c24",
      "patch": "@@ -0,0 +1,40 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Check that GDB can find the variables in a lexical block with a\n+# DW_FORM_rnglistx DW_AT_ranges field.  This test is intended for DWARF-5,\n+# compiled with clang++.\n+\n+standard_testfile .cc\n+\n+# This test is intended for targets which support DWARF-5.\n+# Since we pass an explicit -gdwarf-5 to the compiler,\n+# we let that be the test of whether the target supports it.\n+\n+if { [prepare_for_testing \"failed to prepare\" \"${testfile}\" \\\n+          $srcfile {debug c++ additional_flags=-gdwarf-5 \\\n+                        additional_flags=-O0}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+gdb_breakpoint [gdb_get_line_number \"break-here\"]\n+gdb_continue_to_breakpoint \"break-here\" \".* break-here .*\"\n+\n+gdb_test \"print curr\" \"\\\\\\(node \\\\\\*\\\\\\) $hex <node_array>\"\n+gdb_test \"print *curr\" \"= {id = 35, left = $hex <node_array\\\\+$decimal>, right = $hex <node_array\\\\+$decimal>, visited = false}\""
    }
  ]
}