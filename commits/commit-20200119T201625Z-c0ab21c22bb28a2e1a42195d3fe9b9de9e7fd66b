{
  "sha": "c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzBhYjIxYzIyYmIyOGEyZTFhNDIxOTVkM2ZlOWI5ZGU5ZTdmZDY2Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-01-11T22:56:10Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-01-19T20:16:25Z"
    },
    "message": "Replace init_cutu_and_read_dies with a class\n\ninit_cutu_and_read_dies takes a callback function, which I've always\nfound somewhat difficult to follow.  This patch replaces this function\nwith a class, and changes the callers to use it.  In some cases this\nallows for the removal of a helper struct and helper function as well.\n\ngdb/ChangeLog\n2020-01-19  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.c (abbrev_table_up): Move typedef earlier.\n\t(die_reader_func_ftype): Remove.\n\t(cutu_reader): New class.\n\t(dw2_get_file_names_reader): Remove \"data\" parameter.\n\t(dw2_get_file_names): Use cutu_reader.\n\t(create_debug_type_hash_table): Update.\n\t(read_cutu_die_from_dwo): Update comment.\n\t(lookup_dwo_unit): Add dwo_name parameter.\n\t(cutu_reader::init_tu_and_read_dwo_dies): Now a method.  Remove\n\tdie_reader_func_ftype and data parameters.\n\t(cutu_reader::cutu_reader): Rename from init_cutu_and_read_dies.\n\tRemove die_reader_func_ftype and data parameters.\n\t(~cutu_reader): New; from init_cutu_and_read_dies.\n\t(cutu_reader::cutu_reader): Rename from\n\tinit_cutu_and_read_dies_no_follow.  Remove die_reader_func_ftype\n\tand data parameters.\n\t(init_cutu_and_read_dies_simple): Remove.\n\t(struct process_psymtab_comp_unit_data): Remove.\n\t(process_psymtab_comp_unit_reader): Remove data parameter; add\n\twant_partial_unit and pretend_language parameters.\n\t(process_psymtab_comp_unit): Use cutu_reader.\n\t(build_type_psymtabs_reader): Remove data parameter.\n\t(build_type_psymtabs_1): Use cutu_reader.\n\t(process_skeletonless_type_unit): Likewise.\n\t(load_partial_comp_unit_reader): Remove.\n\t(load_partial_comp_unit): Use cutu_reader.\n\t(load_full_comp_unit_reader): Remove.\n\t(load_full_comp_unit): Use cutu_reader.\n\t(struct create_dwo_cu_data): Remove.\n\t(create_dwo_cu_reader): Remove datap parameter; add dwo_file and\n\tdwo_unit parameters.\n\t(create_cus_hash_table): Use cutu_reader.\n\t(struct dwarf2_read_addr_index_data): Remove.\n\t(dwarf2_read_addr_index_reader): Remove.\n\t(dwarf2_read_addr_index): Use cutu_reader.\n\t(read_signatured_type_reader): Remove.\n\t(read_signatured_type): Use cutu_reader.\n\nChange-Id: I4ef2f29e73108ce94bfe97799f8f638ed272212d",
    "tree": {
      "sha": "a7c688040054921aeec232d5dda6c6ac6f9f386c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a7c688040054921aeec232d5dda6c6ac6f9f386c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "45bbae5c4b34ef6336cc2a3951f1edf191ff3733",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/45bbae5c4b34ef6336cc2a3951f1edf191ff3733",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/45bbae5c4b34ef6336cc2a3951f1edf191ff3733"
    }
  ],
  "stats": {
    "total": 590,
    "additions": 267,
    "deletions": 323
  },
  "files": [
    {
      "sha": "0fd5dffc820be59250fb4eb97eec4f8027f78eb1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
      "patch": "@@ -1,3 +1,43 @@\n+2020-01-19  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.c (abbrev_table_up): Move typedef earlier.\n+\t(die_reader_func_ftype): Remove.\n+\t(cutu_reader): New class.\n+\t(dw2_get_file_names_reader): Remove \"data\" parameter.\n+\t(dw2_get_file_names): Use cutu_reader.\n+\t(create_debug_type_hash_table): Update.\n+\t(read_cutu_die_from_dwo): Update comment.\n+\t(lookup_dwo_unit): Add dwo_name parameter.\n+\t(cutu_reader::init_tu_and_read_dwo_dies): Now a method.  Remove\n+\tdie_reader_func_ftype and data parameters.\n+\t(cutu_reader::cutu_reader): Rename from init_cutu_and_read_dies.\n+\tRemove die_reader_func_ftype and data parameters.\n+\t(~cutu_reader): New; from init_cutu_and_read_dies.\n+\t(cutu_reader::cutu_reader): Rename from\n+\tinit_cutu_and_read_dies_no_follow.  Remove die_reader_func_ftype\n+\tand data parameters.\n+\t(init_cutu_and_read_dies_simple): Remove.\n+\t(struct process_psymtab_comp_unit_data): Remove.\n+\t(process_psymtab_comp_unit_reader): Remove data parameter; add\n+\twant_partial_unit and pretend_language parameters.\n+\t(process_psymtab_comp_unit): Use cutu_reader.\n+\t(build_type_psymtabs_reader): Remove data parameter.\n+\t(build_type_psymtabs_1): Use cutu_reader.\n+\t(process_skeletonless_type_unit): Likewise.\n+\t(load_partial_comp_unit_reader): Remove.\n+\t(load_partial_comp_unit): Use cutu_reader.\n+\t(load_full_comp_unit_reader): Remove.\n+\t(load_full_comp_unit): Use cutu_reader.\n+\t(struct create_dwo_cu_data): Remove.\n+\t(create_dwo_cu_reader): Remove datap parameter; add dwo_file and\n+\tdwo_unit parameters.\n+\t(create_cus_hash_table): Use cutu_reader.\n+\t(struct dwarf2_read_addr_index_data): Remove.\n+\t(dwarf2_read_addr_index_reader): Remove.\n+\t(dwarf2_read_addr_index): Use cutu_reader.\n+\t(read_signatured_type_reader): Remove.\n+\t(read_signatured_type): Use cutu_reader.\n+\n 2020-01-19  Tom Tromey  <tom@tromey.com>\n \n \t* tui/tui.c (tui_show_assembly): Use tui_suppress_output."
    },
    {
      "sha": "dfa2f91d450aff627f4c1adfc4964100df443d8a",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 227,
      "deletions": 323,
      "changes": 550,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=c0ab21c22bb28a2e1a42195d3fe9b9de9e7fd66b",
      "patch": "@@ -874,6 +874,9 @@ struct dwp_file\n   asection **elf_sections = nullptr;\n };\n \n+struct abbrev_table;\n+typedef std::unique_ptr<struct abbrev_table> abbrev_table_up;\n+\n /* Struct used to pass misc. parameters to read_die_and_children, et\n    al.  which are used for both .debug_info and .debug_types dies.\n    All parameters here are unchanging for the life of the call.  This\n@@ -907,12 +910,45 @@ struct die_reader_specs\n   struct abbrev_table *abbrev_table;\n };\n \n-/* Type of function passed to init_cutu_and_read_dies, et.al.  */\n-typedef void (die_reader_func_ftype) (const struct die_reader_specs *reader,\n-\t\t\t\t      const gdb_byte *info_ptr,\n-\t\t\t\t      struct die_info *comp_unit_die,\n-\t\t\t\t      int has_children,\n-\t\t\t\t      void *data);\n+/* A subclass of die_reader_specs that holds storage and has complex\n+   constructor and destructor behavior.  */\n+\n+class cutu_reader : public die_reader_specs\n+{\n+public:\n+\n+  cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+\t       struct abbrev_table *abbrev_table,\n+\t       int use_existing_cu, int keep,\n+\t       bool skip_partial);\n+\n+  explicit cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+\t\t\tstruct dwarf2_cu *parent_cu = nullptr,\n+\t\t\tstruct dwo_file *dwo_file = nullptr);\n+\n+  ~cutu_reader ();\n+\n+  DISABLE_COPY_AND_ASSIGN (cutu_reader);\n+\n+  const gdb_byte *info_ptr = nullptr;\n+  struct die_info *comp_unit_die = nullptr;\n+  int has_children = 0;\n+  bool dummy_p = false;\n+\n+private:\n+  void init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n+\t\t\t\t  int use_existing_cu, int keep);\n+\n+  struct dwarf2_per_cu_data *m_this_cu;\n+  int m_keep = 0;\n+  std::unique_ptr<dwarf2_cu> m_new_cu;\n+\n+  /* The ordinary abbreviation table.  */\n+  abbrev_table_up m_abbrev_table_holder;\n+\n+  /* The DWO abbreviation table.  */\n+  abbrev_table_up m_dwo_abbrev_table;\n+};\n \n /* dir_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5 and\n    later.  */\n@@ -1264,8 +1300,6 @@ struct abbrev_table\n   struct abbrev_info **m_abbrevs;\n };\n \n-typedef std::unique_ptr<struct abbrev_table> abbrev_table_up;\n-\n /* Attributes have a name and a value.  */\n struct attribute\n   {\n@@ -1452,7 +1486,7 @@ static struct partial_symtab *create_partial_symtab\n static void build_type_psymtabs_reader (const struct die_reader_specs *reader,\n \t\t\t\t\tconst gdb_byte *info_ptr,\n \t\t\t\t\tstruct die_info *type_unit_die,\n-\t\t\t\t\tint has_children, void *data);\n+\t\t\t\t\tint has_children);\n \n static void dwarf2_build_psymtabs_hard\n   (struct dwarf2_per_objfile *dwarf2_per_objfile);\n@@ -1990,15 +2024,6 @@ static const gdb_byte *read_and_check_comp_unit_head\n    struct dwarf2_section_info *abbrev_section, const gdb_byte *info_ptr,\n    rcuh_kind section_kind);\n \n-static void init_cutu_and_read_dies\n-  (struct dwarf2_per_cu_data *this_cu, struct abbrev_table *abbrev_table,\n-   int use_existing_cu, int keep, bool skip_partial,\n-   die_reader_func_ftype *die_reader_func, void *data);\n-\n-static void init_cutu_and_read_dies_simple\n-  (struct dwarf2_per_cu_data *this_cu,\n-   die_reader_func_ftype *die_reader_func, void *data);\n-\n static htab_t allocate_signatured_type_table (struct objfile *objfile);\n \n static htab_t allocate_dwo_unit_table (struct objfile *objfile);\n@@ -3663,8 +3688,7 @@ static void\n dw2_get_file_names_reader (const struct die_reader_specs *reader,\n \t\t\t   const gdb_byte *info_ptr,\n \t\t\t   struct die_info *comp_unit_die,\n-\t\t\t   int has_children,\n-\t\t\t   void *data)\n+\t\t\t   int has_children)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   struct dwarf2_per_cu_data *this_cu = cu->per_cu;\n@@ -3760,7 +3784,10 @@ dw2_get_file_names (struct dwarf2_per_cu_data *this_cu)\n   if (this_cu->v.quick->no_file_data)\n     return NULL;\n \n-  init_cutu_and_read_dies_simple (this_cu, dw2_get_file_names_reader, NULL);\n+  cutu_reader reader (this_cu);\n+  if (!reader.dummy_p)\n+    dw2_get_file_names_reader (&reader, reader.info_ptr, reader.comp_unit_die,\n+\t\t\t       reader.has_children);\n \n   if (this_cu->v.quick->no_file_data)\n     return NULL;\n@@ -6795,9 +6822,8 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n      not present, in which case the bfd is unknown.  */\n   abfd = get_section_bfd_owner (section);\n \n-  /* We don't use init_cutu_and_read_dies_simple, or some such, here\n-     because we don't need to read any dies: the signature is in the\n-     header.  */\n+  /* We don't use cutu_reader here because we don't need to read\n+     any dies: the signature is in the header.  */\n \n   end_ptr = info_ptr + section->size;\n   while (info_ptr < end_ptr)\n@@ -7240,9 +7266,9 @@ init_cu_die_reader (struct die_reader_specs *reader,\n   reader->abbrev_table = abbrev_table;\n }\n \n-/* Subroutine of init_cutu_and_read_dies to simplify it.\n+/* Subroutine of cutu_reader to simplify it.\n    Read in the rest of a CU/TU top level DIE from DWO_UNIT.\n-   There's just a lot of work to do, and init_cutu_and_read_dies is big enough\n+   There's just a lot of work to do, and cutu_reader is big enough\n    already.\n \n    STUB_COMP_UNIT_DIE is for the stub DIE, we copy over certain attributes\n@@ -7449,17 +7475,18 @@ lookup_dwo_id (struct dwarf2_cu *cu, struct die_info* comp_unit_die)\n   return DW_UNSND (attr);\n }\n \n-/* Subroutine of init_cutu_and_read_dies to simplify it.\n+/* Subroutine of cutu_reader to simplify it.\n    Look up the DWO unit specified by COMP_UNIT_DIE of THIS_CU.\n    Returns NULL if the specified DWO unit cannot be found.  */\n \n static struct dwo_unit *\n lookup_dwo_unit (struct dwarf2_per_cu_data *this_cu,\n-\t\t struct die_info *comp_unit_die)\n+\t\t struct die_info *comp_unit_die,\n+\t\t const char *dwo_name)\n {\n   struct dwarf2_cu *cu = this_cu->cu;\n   struct dwo_unit *dwo_unit;\n-  const char *comp_dir, *dwo_name;\n+  const char *comp_dir;\n \n   gdb_assert (cu != NULL);\n \n@@ -7490,23 +7517,16 @@ lookup_dwo_unit (struct dwarf2_per_cu_data *this_cu,\n   return dwo_unit;\n }\n \n-/* Subroutine of init_cutu_and_read_dies to simplify it.\n+/* Subroutine of cutu_reader to simplify it.\n    See it for a description of the parameters.\n    Read a TU directly from a DWO file, bypassing the stub.  */\n \n-static void\n-init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t   int use_existing_cu, int keep,\n-\t\t\t   die_reader_func_ftype *die_reader_func,\n-\t\t\t   void *data)\n+void\n+cutu_reader::init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n+\t\t\t\t\tint use_existing_cu, int keep)\n {\n-  std::unique_ptr<dwarf2_cu> new_cu;\n   struct signatured_type *sig_type;\n   struct die_reader_specs reader;\n-  const gdb_byte *info_ptr;\n-  struct die_info *comp_unit_die;\n-  int has_children;\n-  struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n \n   /* Verify we can do the following downcast, and that we have the\n      data we need.  */\n@@ -7518,48 +7538,28 @@ init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n     {\n       gdb_assert (this_cu->cu->dwo_unit == sig_type->dwo_unit);\n       /* There's no need to do the rereading_dwo_cu handling that\n-\t init_cutu_and_read_dies does since we don't read the stub.  */\n+\t cutu_reader does since we don't read the stub.  */\n     }\n   else\n     {\n       /* If !use_existing_cu, this_cu->cu must be NULL.  */\n       gdb_assert (this_cu->cu == NULL);\n-      new_cu.reset (new dwarf2_cu (this_cu));\n+      m_new_cu.reset (new dwarf2_cu (this_cu));\n     }\n \n   /* A future optimization, if needed, would be to use an existing\n      abbrev table.  When reading DWOs with skeletonless TUs, all the TUs\n      could share abbrev tables.  */\n \n-  /* The abbreviation table used by READER, this must live at least as long as\n-     READER.  */\n-  abbrev_table_up dwo_abbrev_table;\n-\n   if (read_cutu_die_from_dwo (this_cu, sig_type->dwo_unit,\n \t\t\t      NULL /* stub_comp_unit_die */,\n \t\t\t      sig_type->dwo_unit->dwo_file->comp_dir,\n \t\t\t      &reader, &info_ptr,\n \t\t\t      &comp_unit_die, &has_children,\n-\t\t\t      &dwo_abbrev_table) == 0)\n+\t\t\t      &m_dwo_abbrev_table) == 0)\n     {\n       /* Dummy die.  */\n-      return;\n-    }\n-\n-  /* All the \"real\" work is done here.  */\n-  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);\n-\n-  /* This duplicates the code in init_cutu_and_read_dies,\n-     but the alternative is making the latter more complex.\n-     This function is only for the special case of using DWO files directly:\n-     no point in overly complicating the general case just to handle this.  */\n-  if (new_cu != NULL && keep)\n-    {\n-      /* Link this CU into read_in_chain.  */\n-      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;\n-      dwarf2_per_objfile->read_in_chain = this_cu;\n-      /* The chain owns it now.  */\n-      new_cu.release ();\n+      dummy_p = true;\n     }\n }\n \n@@ -7574,28 +7574,23 @@ init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu,\n    Otherwise, a new CU is allocated with xmalloc.\n \n    If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to\n-   read_in_chain.  Otherwise the dwarf2_cu data is freed at the end.\n-\n-   WARNING: If THIS_CU is a \"dummy CU\" (used as filler by the incremental\n-   linker) then DIE_READER_FUNC will not get called.  */\n+   read_in_chain.  Otherwise the dwarf2_cu data is freed at the\n+   end.  */\n \n-static void\n-init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t struct abbrev_table *abbrev_table,\n-\t\t\t int use_existing_cu, int keep,\n-\t\t\t bool skip_partial,\n-\t\t\t die_reader_func_ftype *die_reader_func,\n-\t\t\t void *data)\n+cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+\t\t\t  struct abbrev_table *abbrev_table,\n+\t\t\t  int use_existing_cu, int keep,\n+\t\t\t  bool skip_partial)\n+  : die_reader_specs {},\n+    m_this_cu (this_cu),\n+    m_keep (keep)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n   bfd *abfd = get_section_bfd_owner (section);\n   struct dwarf2_cu *cu;\n-  const gdb_byte *begin_info_ptr, *info_ptr;\n-  struct die_reader_specs reader;\n-  struct die_info *comp_unit_die;\n-  int has_children;\n+  const gdb_byte *begin_info_ptr;\n   struct signatured_type *sig_type = NULL;\n   struct dwarf2_section_info *abbrev_section;\n   /* Non-zero if CU currently points to a DWO file and we need to\n@@ -7618,8 +7613,7 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n       /* Narrow down the scope of possibilities to have to understand.  */\n       gdb_assert (this_cu->is_debug_types);\n       gdb_assert (abbrev_table == NULL);\n-      init_tu_and_read_dwo_dies (this_cu, use_existing_cu, keep,\n-\t\t\t\t die_reader_func, data);\n+      init_tu_and_read_dwo_dies (this_cu, use_existing_cu, keep);\n       return;\n     }\n \n@@ -7630,7 +7624,6 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n \n   abbrev_section = get_abbrev_section_for_cu (this_cu);\n \n-  std::unique_ptr<dwarf2_cu> new_cu;\n   if (use_existing_cu && this_cu->cu != NULL)\n     {\n       cu = this_cu->cu;\n@@ -7647,8 +7640,8 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n     {\n       /* If !use_existing_cu, this_cu->cu must be NULL.  */\n       gdb_assert (this_cu->cu == NULL);\n-      new_cu.reset (new dwarf2_cu (this_cu));\n-      cu = new_cu.get ();\n+      m_new_cu.reset (new dwarf2_cu (this_cu));\n+      cu = m_new_cu.get ();\n     }\n \n   /* Get the header.  */\n@@ -7701,28 +7694,33 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n   /* Skip dummy compilation units.  */\n   if (info_ptr >= begin_info_ptr + this_cu->length\n       || peek_abbrev_code (abfd, info_ptr) == 0)\n-    return;\n+    {\n+      dummy_p = true;\n+      return;\n+    }\n \n   /* If we don't have them yet, read the abbrevs for this compilation unit.\n      And if we need to read them now, make sure they're freed when we're\n-     done (own the table through ABBREV_TABLE_HOLDER).  */\n-  abbrev_table_up abbrev_table_holder;\n+     done.  */\n   if (abbrev_table != NULL)\n     gdb_assert (cu->header.abbrev_sect_off == abbrev_table->sect_off);\n   else\n     {\n-      abbrev_table_holder\n+      m_abbrev_table_holder\n \t= abbrev_table_read_table (dwarf2_per_objfile, abbrev_section,\n \t\t\t\t   cu->header.abbrev_sect_off);\n-      abbrev_table = abbrev_table_holder.get ();\n+      abbrev_table = m_abbrev_table_holder.get ();\n     }\n \n   /* Read the top level CU/TU die.  */\n-  init_cu_die_reader (&reader, cu, section, NULL, abbrev_table);\n-  info_ptr = read_full_die (&reader, &comp_unit_die, info_ptr, &has_children);\n+  init_cu_die_reader (this, cu, section, NULL, abbrev_table);\n+  info_ptr = read_full_die (this, &comp_unit_die, info_ptr, &has_children);\n \n   if (skip_partial && comp_unit_die->tag == DW_TAG_partial_unit)\n-    return;\n+    {\n+      dummy_p = true;\n+      return;\n+    }\n \n   /* If we are in a DWO stub, process it and then read in the \"real\" CU/TU\n      from the DWO file.  read_cutu_die_from_dwo will allocate the abbreviation\n@@ -7733,7 +7731,6 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n      Note that if USE_EXISTING_OK != 0, and THIS_CU->cu already contains a\n      DWO CU, that this test will fail (the attribute will not be present).  */\n   const char *dwo_name = dwarf2_dwo_name (comp_unit_die, cu);\n-  abbrev_table_up dwo_abbrev_table;\n   if (dwo_name != nullptr)\n     {\n       struct dwo_unit *dwo_unit;\n@@ -7746,16 +7743,17 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n \t\t     sect_offset_str (this_cu->sect_off),\n \t\t     bfd_get_filename (abfd));\n \t}\n-      dwo_unit = lookup_dwo_unit (this_cu, comp_unit_die);\n+      dwo_unit = lookup_dwo_unit (this_cu, comp_unit_die, dwo_name);\n       if (dwo_unit != NULL)\n \t{\n \t  if (read_cutu_die_from_dwo (this_cu, dwo_unit,\n \t\t\t\t      comp_unit_die, NULL,\n-\t\t\t\t      &reader, &info_ptr,\n+\t\t\t\t      this, &info_ptr,\n \t\t\t\t      &dwo_comp_unit_die, &has_children,\n-\t\t\t\t      &dwo_abbrev_table) == 0)\n+\t\t\t\t      &m_dwo_abbrev_table) == 0)\n \t    {\n \t      /* Dummy die.  */\n+\t      dummy_p = true;\n \t      return;\n \t    }\n \t  comp_unit_die = dwo_comp_unit_die;\n@@ -7769,18 +7767,20 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n \t     debug info.  */\n \t}\n     }\n+}\n \n-  /* All of the above is setup for this call.  Yikes.  */\n-  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);\n-\n+cutu_reader::~cutu_reader ()\n+{\n   /* Done, clean up.  */\n-  if (new_cu != NULL && keep)\n+  if (m_new_cu != NULL && m_keep && !dummy_p)\n     {\n+      struct dwarf2_per_objfile *dwarf2_per_objfile\n+\t= m_this_cu->dwarf2_per_objfile;\n       /* Link this CU into read_in_chain.  */\n-      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;\n-      dwarf2_per_objfile->read_in_chain = this_cu;\n+      m_this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;\n+      dwarf2_per_objfile->read_in_chain = m_this_cu;\n       /* The chain owns it now.  */\n-      new_cu.release ();\n+      m_new_cu.release ();\n     }\n }\n \n@@ -7793,31 +7793,25 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n \n    We fill in THIS_CU->length.\n \n-   WARNING: If THIS_CU is a \"dummy CU\" (used as filler by the incremental\n-   linker) then DIE_READER_FUNC will not get called.\n-\n    THIS_CU->cu is always freed when done.\n    This is done in order to not leave THIS_CU->cu in a state where we have\n    to care whether it refers to the \"main\" CU or the DWO CU.\n \n    When parent_cu is passed, it is used to provide a default value for\n    str_offsets_base and addr_base from the parent.  */\n \n-static void\n-init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t\t   struct dwarf2_cu *parent_cu,\n-\t\t\t\t   struct dwo_file *dwo_file,\n-\t\t\t\t   die_reader_func_ftype *die_reader_func,\n-\t\t\t\t   void *data)\n+cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+\t\t\t  struct dwarf2_cu *parent_cu,\n+\t\t\t  struct dwo_file *dwo_file)\n+  : die_reader_specs {},\n+    m_this_cu (this_cu)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n   bfd *abfd = get_section_bfd_owner (section);\n   struct dwarf2_section_info *abbrev_section;\n   const gdb_byte *begin_info_ptr, *info_ptr;\n-  struct die_reader_specs reader;\n-  struct die_info *comp_unit_die;\n   int has_children;\n \n   if (dwarf_die_debug)\n@@ -7834,54 +7828,40 @@ init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,\n   /* This is cheap if the section is already read in.  */\n   dwarf2_read_section (objfile, section);\n \n-  struct dwarf2_cu cu (this_cu);\n+  m_new_cu.reset (new dwarf2_cu (this_cu));\n \n   begin_info_ptr = info_ptr = section->buffer + to_underlying (this_cu->sect_off);\n   info_ptr = read_and_check_comp_unit_head (dwarf2_per_objfile,\n-\t\t\t\t\t    &cu.header, section,\n+\t\t\t\t\t    &m_new_cu->header, section,\n \t\t\t\t\t    abbrev_section, info_ptr,\n \t\t\t\t\t    (this_cu->is_debug_types\n \t\t\t\t\t     ? rcuh_kind::TYPE\n \t\t\t\t\t     : rcuh_kind::COMPILE));\n \n   if (parent_cu != nullptr)\n     {\n-      cu.str_offsets_base = parent_cu->str_offsets_base;\n-      cu.addr_base = parent_cu->addr_base;\n+      m_new_cu->str_offsets_base = parent_cu->str_offsets_base;\n+      m_new_cu->addr_base = parent_cu->addr_base;\n     }\n-  this_cu->length = get_cu_length (&cu.header);\n+  this_cu->length = get_cu_length (&m_new_cu->header);\n \n   /* Skip dummy compilation units.  */\n   if (info_ptr >= begin_info_ptr + this_cu->length\n       || peek_abbrev_code (abfd, info_ptr) == 0)\n-    return;\n+    {\n+      dummy_p = true;\n+      return;\n+    }\n \n-  abbrev_table_up abbrev_table\n+  m_abbrev_table_holder\n     = abbrev_table_read_table (dwarf2_per_objfile, abbrev_section,\n-\t\t\t       cu.header.abbrev_sect_off);\n-\n-  init_cu_die_reader (&reader, &cu, section, dwo_file, abbrev_table.get ());\n-  info_ptr = read_full_die (&reader, &comp_unit_die, info_ptr, &has_children);\n+\t\t\t       m_new_cu->header.abbrev_sect_off);\n \n-  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);\n+  init_cu_die_reader (this, m_new_cu.get (), section, dwo_file,\n+\t\t      m_abbrev_table_holder.get ());\n+  info_ptr = read_full_die (this, &comp_unit_die, info_ptr, &has_children);\n }\n \n-/* Read a CU/TU, except that this does not look for DW_AT_GNU_dwo_name\n-   (DW_AT_dwo_name) and does not lookup the specified DWO file.\n-   This cannot be used to read DWO files.\n-\n-   THIS_CU->cu is always freed when done.\n-   This is done in order to not leave THIS_CU->cu in a state where we have\n-   to care whether it refers to the \"main\" CU or the DWO CU.\n-   We can revisit this if the data shows there's a performance issue.  */\n-\n-static void\n-init_cutu_and_read_dies_simple (struct dwarf2_per_cu_data *this_cu,\n-\t\t\t\tdie_reader_func_ftype *die_reader_func,\n-\t\t\t\tvoid *data)\n-{\n-  init_cutu_and_read_dies_no_follow (this_cu, NULL, NULL, die_reader_func, data);\n-}\n \f\n /* Type Unit Groups.\n \n@@ -8059,29 +8039,15 @@ create_partial_symtab (struct dwarf2_per_cu_data *per_cu, const char *name)\n   return pst;\n }\n \n-/* The DATA object passed to process_psymtab_comp_unit_reader has this\n-   type.  */\n-\n-struct process_psymtab_comp_unit_data\n-{\n-  /* True if we are reading a DW_TAG_partial_unit.  */\n-\n-  int want_partial_unit;\n-\n-  /* The \"pretend\" language that is used if the CU doesn't declare a\n-     language.  */\n-\n-  enum language pretend_language;\n-};\n-\n-/* die_reader_func for process_psymtab_comp_unit.  */\n+/* DIE reader function for process_psymtab_comp_unit.  */\n \n static void\n process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n \t\t\t\t  const gdb_byte *info_ptr,\n \t\t\t\t  struct die_info *comp_unit_die,\n \t\t\t\t  int has_children,\n-\t\t\t\t  void *data)\n+\t\t\t\t  int want_partial_unit,\n+\t\t\t\t  enum language pretend_language)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n@@ -8092,15 +8058,13 @@ process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n   struct partial_symtab *pst;\n   enum pc_bounds_kind cu_bounds_kind;\n   const char *filename;\n-  struct process_psymtab_comp_unit_data *info\n-    = (struct process_psymtab_comp_unit_data *) data;\n \n-  if (comp_unit_die->tag == DW_TAG_partial_unit && !info->want_partial_unit)\n+  if (comp_unit_die->tag == DW_TAG_partial_unit && !want_partial_unit)\n     return;\n \n   gdb_assert (! per_cu->is_debug_types);\n \n-  prepare_one_comp_unit (cu, comp_unit_die, info->pretend_language);\n+  prepare_one_comp_unit (cu, comp_unit_die, pretend_language);\n \n   /* Allocate a new partial symbol table structure.  */\n   filename = dwarf2_string_attr (comp_unit_die, DW_AT_name, cu);\n@@ -8222,17 +8186,21 @@ process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,\n   if (this_cu->cu != NULL)\n     free_one_cached_comp_unit (this_cu);\n \n-  if (this_cu->is_debug_types)\n-    init_cutu_and_read_dies (this_cu, NULL, 0, 0, false,\n-\t\t\t     build_type_psymtabs_reader, NULL);\n-  else\n+  cutu_reader reader (this_cu, NULL, 0, 0, false);\n+\n+  if (reader.dummy_p)\n     {\n-      process_psymtab_comp_unit_data info;\n-      info.want_partial_unit = want_partial_unit;\n-      info.pretend_language = pretend_language;\n-      init_cutu_and_read_dies (this_cu, NULL, 0, 0, false,\n-\t\t\t       process_psymtab_comp_unit_reader, &info);\n+      /* Nothing.  */\n     }\n+  else if (this_cu->is_debug_types)\n+    build_type_psymtabs_reader (&reader, reader.info_ptr, reader.comp_unit_die,\n+\t\t\t\treader.has_children);\n+  else\n+    process_psymtab_comp_unit_reader (&reader, reader.info_ptr,\n+\t\t\t\t      reader.comp_unit_die,\n+\t\t\t\t      reader.has_children,\n+\t\t\t\t      want_partial_unit,\n+\t\t\t\t      pretend_language);\n \n   /* Age out any secondary CUs.  */\n   age_cached_comp_units (this_cu->dwarf2_per_objfile);\n@@ -8244,8 +8212,7 @@ static void\n build_type_psymtabs_reader (const struct die_reader_specs *reader,\n \t\t\t    const gdb_byte *info_ptr,\n \t\t\t    struct die_info *type_unit_die,\n-\t\t\t    int has_children,\n-\t\t\t    void *data)\n+\t\t\t    int has_children)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = reader->cu->per_cu->dwarf2_per_objfile;\n@@ -8259,7 +8226,6 @@ build_type_psymtabs_reader (const struct die_reader_specs *reader,\n   CORE_ADDR lowpc, highpc;\n   struct partial_symtab *pst;\n \n-  gdb_assert (data == NULL);\n   gdb_assert (per_cu->is_debug_types);\n   sig_type = (struct signatured_type *) per_cu;\n \n@@ -8390,8 +8356,12 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t  ++tu_stats->nr_uniq_abbrev_tables;\n \t}\n \n-      init_cutu_and_read_dies (&tu.sig_type->per_cu, abbrev_table.get (),\n-\t\t\t       0, 0, false, build_type_psymtabs_reader, NULL);\n+      cutu_reader reader (&tu.sig_type->per_cu, abbrev_table.get (),\n+\t\t\t  0, 0, false);\n+      if (!reader.dummy_p)\n+\tbuild_type_psymtabs_reader (&reader, reader.info_ptr,\n+\t\t\t\t    reader.comp_unit_die,\n+\t\t\t\t    reader.has_children);\n     }\n }\n \n@@ -8496,8 +8466,10 @@ process_skeletonless_type_unit (void **slot, void *info)\n   *slot = entry;\n \n   /* This does the job that build_type_psymtabs_1 would have done.  */\n-  init_cutu_and_read_dies (&entry->per_cu, NULL, 0, 0, false,\n-\t\t\t   build_type_psymtabs_reader, NULL);\n+  cutu_reader reader (&entry->per_cu, NULL, 0, 0, false);\n+  if (!reader.dummy_p)\n+    build_type_psymtabs_reader (&reader, reader.info_ptr,\n+\t\t\t\treader.comp_unit_die, reader.has_children);\n \n   return 1;\n }\n@@ -8619,34 +8591,25 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t\t\tobjfile_name (objfile));\n }\n \n-/* die_reader_func for load_partial_comp_unit.  */\n-\n-static void\n-load_partial_comp_unit_reader (const struct die_reader_specs *reader,\n-\t\t\t       const gdb_byte *info_ptr,\n-\t\t\t       struct die_info *comp_unit_die,\n-\t\t\t       int has_children,\n-\t\t\t       void *data)\n-{\n-  struct dwarf2_cu *cu = reader->cu;\n-\n-  prepare_one_comp_unit (cu, comp_unit_die, language_minimal);\n-\n-  /* Check if comp unit has_children.\n-     If so, read the rest of the partial symbols from this comp unit.\n-     If not, there's no more debug_info for this comp unit.  */\n-  if (has_children)\n-    load_partial_dies (reader, info_ptr, 0);\n-}\n-\n /* Load the partial DIEs for a secondary CU into memory.\n    This is also used when rereading a primary CU with load_all_dies.  */\n \n static void\n load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)\n {\n-  init_cutu_and_read_dies (this_cu, NULL, 1, 1, false,\n-\t\t\t   load_partial_comp_unit_reader, NULL);\n+  cutu_reader reader (this_cu, NULL, 1, 1, false);\n+\n+  if (!reader.dummy_p)\n+    {\n+      prepare_one_comp_unit (reader.cu, reader.comp_unit_die,\n+\t\t\t     language_minimal);\n+\n+      /* Check if comp unit has_children.\n+\t If so, read the rest of the partial symbols from this comp unit.\n+\t If not, there's no more debug_info for this comp unit.  */\n+      if (reader.has_children)\n+\tload_partial_dies (&reader, reader.info_ptr, 0);\n+    }\n }\n \n static void\n@@ -9787,19 +9750,21 @@ die_eq (const void *item_lhs, const void *item_rhs)\n   return die_lhs->sect_off == die_rhs->sect_off;\n }\n \n-/* die_reader_func for load_full_comp_unit.\n-   This is identical to read_signatured_type_reader,\n-   but is kept separate for now.  */\n+/* Load the DIEs associated with PER_CU into memory.  */\n \n static void\n-load_full_comp_unit_reader (const struct die_reader_specs *reader,\n-\t\t\t    const gdb_byte *info_ptr,\n-\t\t\t    struct die_info *comp_unit_die,\n-\t\t\t    int has_children,\n-\t\t\t    void *data)\n+load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,\n+\t\t     bool skip_partial,\n+\t\t     enum language pretend_language)\n {\n-  struct dwarf2_cu *cu = reader->cu;\n-  enum language *language_ptr = (enum language *) data;\n+  gdb_assert (! this_cu->is_debug_types);\n+\n+  cutu_reader reader (this_cu, NULL, 1, 1, skip_partial);\n+  if (reader.dummy_p)\n+    return;\n+\n+  struct dwarf2_cu *cu = reader.cu;\n+  const gdb_byte *info_ptr = reader.info_ptr;\n \n   gdb_assert (cu->die_hash == NULL);\n   cu->die_hash =\n@@ -9811,10 +9776,11 @@ load_full_comp_unit_reader (const struct die_reader_specs *reader,\n \t\t\t  hashtab_obstack_allocate,\n \t\t\t  dummy_obstack_deallocate);\n \n-  if (has_children)\n-    comp_unit_die->child = read_die_and_siblings (reader, info_ptr,\n-\t\t\t\t\t\t  &info_ptr, comp_unit_die);\n-  cu->dies = comp_unit_die;\n+  if (reader.has_children)\n+    reader.comp_unit_die->child\n+      = read_die_and_siblings (&reader, reader.info_ptr,\n+\t\t\t       &info_ptr, reader.comp_unit_die);\n+  cu->dies = reader.comp_unit_die;\n   /* comp_unit_die is not stored in die_hash, no need.  */\n \n   /* We try not to read any attributes in this function, because not\n@@ -9823,20 +9789,7 @@ load_full_comp_unit_reader (const struct die_reader_specs *reader,\n      or we won't be able to build types correctly.\n      Similarly, if we do not read the producer, we can not apply\n      producer-specific interpretation.  */\n-  prepare_one_comp_unit (cu, cu->dies, *language_ptr);\n-}\n-\n-/* Load the DIEs associated with PER_CU into memory.  */\n-\n-static void\n-load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,\n-\t\t     bool skip_partial,\n-\t\t     enum language pretend_language)\n-{\n-  gdb_assert (! this_cu->is_debug_types);\n-\n-  init_cutu_and_read_dies (this_cu, NULL, 1, 1, skip_partial,\n-\t\t\t   load_full_comp_unit_reader, &pretend_language);\n+  prepare_one_comp_unit (cu, cu->dies, pretend_language);\n }\n \n /* Add a DIE to the delayed physname list.  */\n@@ -11973,29 +11926,19 @@ allocate_dwo_unit_table (struct objfile *objfile)\n \t\t\t       dummy_obstack_deallocate);\n }\n \n-/* Structure used to pass data to create_dwo_debug_info_hash_table_reader.  */\n-\n-struct create_dwo_cu_data\n-{\n-  struct dwo_file *dwo_file;\n-  struct dwo_unit dwo_unit;\n-};\n-\n /* die_reader_func for create_dwo_cu.  */\n \n static void\n create_dwo_cu_reader (const struct die_reader_specs *reader,\n \t\t      const gdb_byte *info_ptr,\n \t\t      struct die_info *comp_unit_die,\n \t\t      int has_children,\n-\t\t      void *datap)\n+\t\t      struct dwo_file *dwo_file,\n+\t\t      struct dwo_unit *dwo_unit)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   sect_offset sect_off = cu->per_cu->sect_off;\n   struct dwarf2_section_info *section = cu->per_cu->section;\n-  struct create_dwo_cu_data *data = (struct create_dwo_cu_data *) datap;\n-  struct dwo_file *dwo_file = data->dwo_file;\n-  struct dwo_unit *dwo_unit = &data->dwo_unit;\n \n   gdb::optional<ULONGEST> signature = lookup_dwo_id (cu, comp_unit_die);\n   if (!signature.has_value ())\n@@ -12046,33 +11989,32 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   while (info_ptr < end_ptr)\n     {\n       struct dwarf2_per_cu_data per_cu;\n-      struct create_dwo_cu_data create_dwo_cu_data;\n+      struct dwo_unit read_unit {};\n       struct dwo_unit *dwo_unit;\n       void **slot;\n       sect_offset sect_off = (sect_offset) (info_ptr - section.buffer);\n \n-      memset (&create_dwo_cu_data.dwo_unit, 0,\n-\t      sizeof (create_dwo_cu_data.dwo_unit));\n       memset (&per_cu, 0, sizeof (per_cu));\n       per_cu.dwarf2_per_objfile = dwarf2_per_objfile;\n       per_cu.is_debug_types = 0;\n       per_cu.sect_off = sect_offset (info_ptr - section.buffer);\n       per_cu.section = &section;\n-      create_dwo_cu_data.dwo_file = &dwo_file;\n \n-      init_cutu_and_read_dies_no_follow (\n-\t  &per_cu, cu, &dwo_file, create_dwo_cu_reader, &create_dwo_cu_data);\n+      cutu_reader reader (&per_cu, cu, &dwo_file);\n+      if (!reader.dummy_p)\n+\tcreate_dwo_cu_reader (&reader, reader.info_ptr, reader.comp_unit_die,\n+\t\t\t      reader.has_children, &dwo_file, &read_unit);\n       info_ptr += per_cu.length;\n \n       // If the unit could not be parsed, skip it.\n-      if (create_dwo_cu_data.dwo_unit.dwo_file == NULL)\n+      if (read_unit.dwo_file == NULL)\n \tcontinue;\n \n       if (cus_htab == NULL)\n \tcus_htab = allocate_dwo_unit_table (objfile);\n \n       dwo_unit = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_unit);\n-      *dwo_unit = create_dwo_cu_data.dwo_unit;\n+      *dwo_unit = read_unit;\n       slot = htab_find_slot (cus_htab, dwo_unit, INSERT);\n       gdb_assert (slot != NULL);\n       if (*slot != NULL)\n@@ -20263,32 +20205,6 @@ read_addr_index_from_leb128 (struct dwarf2_cu *cu, const gdb_byte *info_ptr,\n   return read_addr_index (cu, addr_index);\n }\n \n-/* Data structure to pass results from dwarf2_read_addr_index_reader\n-   back to dwarf2_read_addr_index.  */\n-\n-struct dwarf2_read_addr_index_data\n-{\n-  gdb::optional<ULONGEST> addr_base;\n-  int addr_size;\n-};\n-\n-/* die_reader_func for dwarf2_read_addr_index.  */\n-\n-static void\n-dwarf2_read_addr_index_reader (const struct die_reader_specs *reader,\n-\t\t\t       const gdb_byte *info_ptr,\n-\t\t\t       struct die_info *comp_unit_die,\n-\t\t\t       int has_children,\n-\t\t\t       void *data)\n-{\n-  struct dwarf2_cu *cu = reader->cu;\n-  struct dwarf2_read_addr_index_data *aidata =\n-    (struct dwarf2_read_addr_index_data *) data;\n-\n-  aidata->addr_base = cu->addr_base;\n-  aidata->addr_size = cu->header.addr_size;\n-}\n-\n /* Given an index in .debug_addr, fetch the value.\n    NOTE: This can be called during dwarf expression evaluation,\n    long after the debug information has been read, and thus per_cu->cu\n@@ -20326,14 +20242,9 @@ dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,\n     }\n   else\n     {\n-      struct dwarf2_read_addr_index_data aidata;\n-\n-      /* Note: We can't use init_cutu_and_read_dies_simple here,\n-\t we need addr_base.  */\n-      init_cutu_and_read_dies (per_cu, NULL, 0, 0, false,\n-\t\t\t       dwarf2_read_addr_index_reader, &aidata);\n-      addr_base = aidata.addr_base;\n-      addr_size = aidata.addr_size;\n+      cutu_reader reader (per_cu, NULL, 0, 0, false);\n+      addr_base = reader.cu->addr_base;\n+      addr_size = reader.cu->header.addr_size;\n     }\n \n   return read_addr_index_1 (dwarf2_per_objfile, addr_index, addr_base,\n@@ -24211,44 +24122,6 @@ load_full_type_unit (struct dwarf2_per_cu_data *per_cu)\n   gdb_assert (per_cu->cu != NULL);\n }\n \n-/* die_reader_func for read_signatured_type.\n-   This is identical to load_full_comp_unit_reader,\n-   but is kept separate for now.  */\n-\n-static void\n-read_signatured_type_reader (const struct die_reader_specs *reader,\n-\t\t\t     const gdb_byte *info_ptr,\n-\t\t\t     struct die_info *comp_unit_die,\n-\t\t\t     int has_children,\n-\t\t\t     void *data)\n-{\n-  struct dwarf2_cu *cu = reader->cu;\n-\n-  gdb_assert (cu->die_hash == NULL);\n-  cu->die_hash =\n-    htab_create_alloc_ex (cu->header.length / 12,\n-\t\t\t  die_hash,\n-\t\t\t  die_eq,\n-\t\t\t  NULL,\n-\t\t\t  &cu->comp_unit_obstack,\n-\t\t\t  hashtab_obstack_allocate,\n-\t\t\t  dummy_obstack_deallocate);\n-\n-  if (has_children)\n-    comp_unit_die->child = read_die_and_siblings (reader, info_ptr,\n-\t\t\t\t\t\t  &info_ptr, comp_unit_die);\n-  cu->dies = comp_unit_die;\n-  /* comp_unit_die is not stored in die_hash, no need.  */\n-\n-  /* We try not to read any attributes in this function, because not\n-     all CUs needed for references have been loaded yet, and symbol\n-     table processing isn't initialized.  But we have to set the CU language,\n-     or we won't be able to build types correctly.\n-     Similarly, if we do not read the producer, we can not apply\n-     producer-specific interpretation.  */\n-  prepare_one_comp_unit (cu, cu->dies, language_minimal);\n-}\n-\n /* Read in a signatured type and build its CU and DIEs.\n    If the type is a stub for the real type in a DWO file,\n    read in the real type from the DWO file as well.  */\n@@ -24261,8 +24134,39 @@ read_signatured_type (struct signatured_type *sig_type)\n   gdb_assert (per_cu->is_debug_types);\n   gdb_assert (per_cu->cu == NULL);\n \n-  init_cutu_and_read_dies (per_cu, NULL, 0, 1, false,\n-\t\t\t   read_signatured_type_reader, NULL);\n+  cutu_reader reader (per_cu, NULL, 0, 1, false);\n+\n+  if (!reader.dummy_p)\n+    {\n+      struct dwarf2_cu *cu = reader.cu;\n+      const gdb_byte *info_ptr = reader.info_ptr;\n+\n+      gdb_assert (cu->die_hash == NULL);\n+      cu->die_hash =\n+\thtab_create_alloc_ex (cu->header.length / 12,\n+\t\t\t      die_hash,\n+\t\t\t      die_eq,\n+\t\t\t      NULL,\n+\t\t\t      &cu->comp_unit_obstack,\n+\t\t\t      hashtab_obstack_allocate,\n+\t\t\t      dummy_obstack_deallocate);\n+\n+      if (reader.has_children)\n+\treader.comp_unit_die->child\n+\t  = read_die_and_siblings (&reader, info_ptr, &info_ptr,\n+\t\t\t\t   reader.comp_unit_die);\n+      cu->dies = reader.comp_unit_die;\n+      /* comp_unit_die is not stored in die_hash, no need.  */\n+\n+      /* We try not to read any attributes in this function, because\n+\t not all CUs needed for references have been loaded yet, and\n+\t symbol table processing isn't initialized.  But we have to\n+\t set the CU language, or we won't be able to build types\n+\t correctly.  Similarly, if we do not read the producer, we can\n+\t not apply producer-specific interpretation.  */\n+      prepare_one_comp_unit (cu, cu->dies, language_minimal);\n+    }\n+\n   sig_type->per_cu.tu_read = 1;\n }\n "
    }
  ]
}