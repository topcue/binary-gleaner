{
  "sha": "bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmIyYTY3NzczYzVlMDY1NDVjMzlhNjM3M2JlNzIwYzdkM2Q5ZWViNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-12T21:53:16Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-13T02:18:47Z"
    },
    "message": "Use a std::vector in target_section_table\n\nThis changes target_section_table to wrap a std::vector.  This\nsimplifies some code, and also enables the simplifications coming in\nthe subsequent patches.\n\nNote that for solib, I chose to have it use a pointer to a\ntarget_section_table.  This is more convoluted than would be ideal,\nbut I didn't want to convert solib to new/delete as a prerequisite for\nthis series.\n\ngdb/ChangeLog\n2020-10-12  Tom Tromey  <tom@tromey.com>\n\n\t* target.c (target_section_by_addr, memory_xfer_partial_1):\n\tUpdate.\n\t* target-section.h (struct target_section_table): Use\n\tstd::vector.\n\t* symfile.h (build_section_addr_info_from_section_table): Take a\n\ttarget_section_table.\n\t* symfile.c (build_section_addr_info_from_section_table): Take a\n\ttarget_section_table.\n\t* solist.h (struct so_list) <sections>: Change type.\n\t<sections_end>: Remove.\n\t* solib.c (solib_map_sections, clear_so, solib_read_symbols)\n\t(solib_contains_address_p): Update.\n\t* solib-svr4.c (scan_dyntag): Update.\n\t* solib-dsbt.c (scan_dyntag): Update.\n\t* remote.c (remote_target::remote_xfer_live_readonly_partial):\n\tUpdate.\n\t* record-full.c (record_full_core_start, record_full_core_end):\n\tRemove.\n\t(record_full_core_sections): New global.\n\t(record_full_core_open_1, record_full_core_target::xfer_partial):\n\tUpdate.\n\t* exec.h (build_section_table, section_table_xfer_memory_partial)\n\t(add_target_sections): Take a target_section_table.\n\t* exec.c (exec_file_attach, clear_section_table): Update.\n\t(resize_section_table): Remove.\n\t(build_section_table, add_target_sections): Take a\n\ttarget_section_table.\n\t(add_target_sections_of_objfile, remove_target_sections)\n\t(exec_on_vfork): Update.\n\t(section_table_available_memory): Take a target_section_table.\n\t(section_table_read_available_memory): Update.\n\t(section_table_xfer_memory_partial): Take a target_section_table.\n\t(print_section_info, set_section_command)\n\t(exec_set_section_address, exec_target::has_memory): Update.\n\t* corelow.c (class core_target) <m_core_section_table,\n\tm_core_file_mappings>: Remove braces.\n\t<~core_target>: Remove.\n\t(core_target::core_target): Update.\n\t(core_target::~core_target): Remove.\n\t(core_target::build_file_mappings)\n\t(core_target::xfer_memory_via_mappings)\n\t(core_target::xfer_partial, core_target::info_proc_mappings):\n\tUpdate.\n\t* bfd-target.c (target_bfd::xfer_partial): Update.\n\t(target_bfd::target_bfd): Update.\n\t(target_bfd::~target_bfd): Remove.",
    "tree": {
      "sha": "2745316e9eb79ec610ed9e9950d56323be0bbf7d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2745316e9eb79ec610ed9e9950d56323be0bbf7d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7b466b10241f3971ab628ace1e75cf1166209af5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b466b10241f3971ab628ace1e75cf1166209af5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7b466b10241f3971ab628ace1e75cf1166209af5"
    }
  ],
  "stats": {
    "total": 531,
    "additions": 230,
    "deletions": 301
  },
  "files": [
    {
      "sha": "4097647767db8d935238d262898b9e080d67a5a7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -1,3 +1,52 @@\n+2020-10-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* target.c (target_section_by_addr, memory_xfer_partial_1):\n+\tUpdate.\n+\t* target-section.h (struct target_section_table): Use\n+\tstd::vector.\n+\t* symfile.h (build_section_addr_info_from_section_table): Take a\n+\ttarget_section_table.\n+\t* symfile.c (build_section_addr_info_from_section_table): Take a\n+\ttarget_section_table.\n+\t* solist.h (struct so_list) <sections>: Change type.\n+\t<sections_end>: Remove.\n+\t* solib.c (solib_map_sections, clear_so, solib_read_symbols)\n+\t(solib_contains_address_p): Update.\n+\t* solib-svr4.c (scan_dyntag): Update.\n+\t* solib-dsbt.c (scan_dyntag): Update.\n+\t* remote.c (remote_target::remote_xfer_live_readonly_partial):\n+\tUpdate.\n+\t* record-full.c (record_full_core_start, record_full_core_end):\n+\tRemove.\n+\t(record_full_core_sections): New global.\n+\t(record_full_core_open_1, record_full_core_target::xfer_partial):\n+\tUpdate.\n+\t* exec.h (build_section_table, section_table_xfer_memory_partial)\n+\t(add_target_sections): Take a target_section_table.\n+\t* exec.c (exec_file_attach, clear_section_table): Update.\n+\t(resize_section_table): Remove.\n+\t(build_section_table, add_target_sections): Take a\n+\ttarget_section_table.\n+\t(add_target_sections_of_objfile, remove_target_sections)\n+\t(exec_on_vfork): Update.\n+\t(section_table_available_memory): Take a target_section_table.\n+\t(section_table_read_available_memory): Update.\n+\t(section_table_xfer_memory_partial): Take a target_section_table.\n+\t(print_section_info, set_section_command)\n+\t(exec_set_section_address, exec_target::has_memory): Update.\n+\t* corelow.c (class core_target) <m_core_section_table,\n+\tm_core_file_mappings>: Remove braces.\n+\t<~core_target>: Remove.\n+\t(core_target::core_target): Update.\n+\t(core_target::~core_target): Remove.\n+\t(core_target::build_file_mappings)\n+\t(core_target::xfer_memory_via_mappings)\n+\t(core_target::xfer_partial, core_target::info_proc_mappings):\n+\tUpdate.\n+\t* bfd-target.c (target_bfd::xfer_partial): Update.\n+\t(target_bfd::target_bfd): Update.\n+\t(target_bfd::~target_bfd): Remove.\n+\n 2020-10-12  Tom Tromey  <tom@tromey.com>\n \n \t* target.h (struct target_section, struct target_section_table):"
    },
    {
      "sha": "8a58e92eb1cc5ac05fa3c24e1099e2f4049dce8e",
      "filename": "gdb/bfd-target.c",
      "status": "modified",
      "additions": 2,
      "deletions": 11,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/bfd-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/bfd-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfd-target.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -35,7 +35,6 @@ class target_bfd : public target_ops\n {\n public:\n   explicit target_bfd (struct bfd *bfd);\n-  ~target_bfd () override;\n \n   const target_info &info () const override\n   { return target_bfd_target_info; }\n@@ -76,8 +75,7 @@ target_bfd::xfer_partial (target_object object,\n       {\n \treturn section_table_xfer_memory_partial (readbuf, writebuf,\n \t\t\t\t\t\t  offset, len, xfered_len,\n-\t\t\t\t\t\t  m_table.sections,\n-\t\t\t\t\t\t  m_table.sections_end);\n+\t\t\t\t\t\t  m_table);\n       }\n     default:\n       return TARGET_XFER_E_IO;\n@@ -93,14 +91,7 @@ target_bfd::get_section_table ()\n target_bfd::target_bfd (struct bfd *abfd)\n   : m_bfd (gdb_bfd_ref_ptr::new_reference (abfd))\n {\n-  m_table.sections = NULL;\n-  m_table.sections_end = NULL;\n-  build_section_table (abfd, &m_table.sections, &m_table.sections_end);\n-}\n-\n-target_bfd::~target_bfd ()\n-{\n-  xfree (m_table.sections);\n+  build_section_table (abfd, &m_table);\n }\n \n target_ops *"
    },
    {
      "sha": "554561dbb36273c1fdb99b6b62b8bf6aa23671ce",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 21,
      "deletions": 37,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -67,7 +67,6 @@ class core_target final : public process_stratum_target\n {\n public:\n   core_target ();\n-  ~core_target () override;\n \n   const target_info &info () const override\n   { return core_target_info; }\n@@ -126,11 +125,11 @@ class core_target final : public process_stratum_target\n      shared library bfds.  The core bfd sections are an implementation\n      detail of the core target, just like ptrace is for unix child\n      targets.  */\n-  target_section_table m_core_section_table {};\n+  target_section_table m_core_section_table;\n \n   /* File-backed address space mappings: some core files include\n      information about memory mapped files.  */\n-  target_section_table m_core_file_mappings {};\n+  target_section_table m_core_file_mappings;\n \n   /* Unavailable mappings.  These correspond to pathnames which either\n      weren't found or could not be opened.  Knowing these addresses can\n@@ -162,21 +161,13 @@ core_target::core_target ()\n \t   bfd_get_filename (core_bfd));\n \n   /* Find the data section */\n-  if (build_section_table (core_bfd,\n-\t\t\t   &m_core_section_table.sections,\n-\t\t\t   &m_core_section_table.sections_end))\n+  if (build_section_table (core_bfd, &m_core_section_table))\n     error (_(\"\\\"%s\\\": Can't find sections: %s\"),\n \t   bfd_get_filename (core_bfd), bfd_errmsg (bfd_get_error ()));\n \n   build_file_mappings ();\n }\n \n-core_target::~core_target ()\n-{\n-  xfree (m_core_section_table.sections);\n-  xfree (m_core_file_mappings.sections);\n-}\n-\n /* Construct the target_section_table for file-backed mappings if\n    they exist.\n \n@@ -202,12 +193,9 @@ core_target::build_file_mappings ()\n   gdbarch_read_core_file_mappings (m_core_gdbarch, core_bfd,\n \n     /* After determining the number of mappings, read_core_file_mappings\n-       will invoke this lambda which allocates target_section storage for\n-       the mappings.  */\n-    [&] (ULONGEST count)\n+       will invoke this lambda.  */\n+    [&] (ULONGEST)\n       {\n-\tm_core_file_mappings.sections = XNEWVEC (struct target_section, count);\n-\tm_core_file_mappings.sections_end = m_core_file_mappings.sections;\n       },\n \n     /* read_core_file_mappings will invoke this lambda for each mapping\n@@ -280,11 +268,12 @@ core_target::build_file_mappings ()\n \tbfd_set_section_alignment (sec, 2);\n \n \t/* Set target_section fields.  */\n-\tstruct target_section *ts = m_core_file_mappings.sections_end++;\n-\tts->addr = start;\n-\tts->endaddr = end;\n-\tts->owner = nullptr;\n-\tts->the_bfd_section = sec;\n+\tm_core_file_mappings.sections.emplace_back ();\n+\ttarget_section &ts = m_core_file_mappings.sections.back ();\n+\tts.addr = start;\n+\tts.endaddr = end;\n+\tts.owner = nullptr;\n+\tts.the_bfd_section = sec;\n       });\n \n   normalize_mem_ranges (&m_core_unavailable_mappings);\n@@ -759,8 +748,7 @@ core_target::xfer_memory_via_mappings (gdb_byte *readbuf,\n   xfer_status = (section_table_xfer_memory_partial\n \t\t   (readbuf, writebuf,\n \t\t    offset, len, xfered_len,\n-\t\t    m_core_file_mappings.sections,\n-\t\t    m_core_file_mappings.sections_end));\n+\t\t    m_core_file_mappings));\n \n   if (xfer_status == TARGET_XFER_OK || m_core_unavailable_mappings.empty ())\n     return xfer_status;\n@@ -818,8 +806,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \txfer_status = section_table_xfer_memory_partial\n \t\t\t(readbuf, writebuf,\n \t\t\t offset, len, xfered_len,\n-\t\t\t m_core_section_table.sections,\n-\t\t\t m_core_section_table.sections_end,\n+\t\t\t m_core_section_table,\n \t\t\t has_contents_cb);\n \tif (xfer_status == TARGET_XFER_OK)\n \t  return TARGET_XFER_OK;\n@@ -829,7 +816,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t   or the like) as this should provide a more accurate\n \t   result.  If not, check the stratum beneath us, which should\n \t   be the file stratum.  */\n-\tif (m_core_file_mappings.sections != nullptr)\n+\tif (!m_core_file_mappings.sections.empty ())\n \t  xfer_status = xfer_memory_via_mappings (readbuf, writebuf, offset,\n \t\t\t\t\t\t  len, xfered_len);\n \telse\n@@ -848,8 +835,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \txfer_status = section_table_xfer_memory_partial\n \t\t\t(readbuf, writebuf,\n \t\t\t offset, len, xfered_len,\n-\t\t\t m_core_section_table.sections,\n-\t\t\t m_core_section_table.sections_end,\n+\t\t\t m_core_section_table,\n \t\t\t no_contents_cb);\n \n \treturn xfer_status;\n@@ -1114,7 +1100,7 @@ get_current_core_target ()\n void\n core_target::info_proc_mappings (struct gdbarch *gdbarch)\n {\n-  if (m_core_file_mappings.sections != m_core_file_mappings.sections_end)\n+  if (!m_core_file_mappings.sections.empty ())\n     {\n       printf_filtered (_(\"Mapped address spaces:\\n\\n\"));\n       if (gdbarch_addr_bit (gdbarch) == 32)\n@@ -1133,14 +1119,12 @@ core_target::info_proc_mappings (struct gdbarch *gdbarch)\n \t}\n     }\n \n-  for (const struct target_section *tsp = m_core_file_mappings.sections;\n-       tsp < m_core_file_mappings.sections_end;\n-       tsp++)\n+  for (const target_section &tsp : m_core_file_mappings.sections)\n     {\n-      ULONGEST start = tsp->addr;\n-      ULONGEST end = tsp->endaddr;\n-      ULONGEST file_ofs = tsp->the_bfd_section->filepos;\n-      const char *filename = bfd_get_filename (tsp->the_bfd_section->owner);\n+      ULONGEST start = tsp.addr;\n+      ULONGEST end = tsp.endaddr;\n+      ULONGEST file_ofs = tsp.the_bfd_section->filepos;\n+      const char *filename = bfd_get_filename (tsp.the_bfd_section->owner);\n \n       if (gdbarch_addr_bit (gdbarch) == 32)\n \tprintf_filtered (\"\\t%10s %10s %10s %10s %s\\n\","
    },
    {
      "sha": "e3e515fedec526036fe13bac977772e663380fe8",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 88,
      "deletions": 159,
      "changes": 247,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -413,7 +413,7 @@ exec_file_attach (const char *filename, int from_tty)\n       int load_via_target = 0;\n       const char *scratch_pathname, *canonical_pathname;\n       int scratch_chan;\n-      struct target_section *sections = NULL, *sections_end = NULL;\n+      target_section_table sections;\n       char **matching;\n \n       if (is_target_filename (filename))\n@@ -503,7 +503,7 @@ exec_file_attach (const char *filename, int from_tty)\n \t\t gdb_bfd_errmsg (bfd_get_error (), matching).c_str ());\n \t}\n \n-      if (build_section_table (exec_bfd, &sections, &sections_end))\n+      if (build_section_table (exec_bfd, &sections))\n \t{\n \t  /* Make sure to close exec_bfd, or else \"run\" might try to use\n \t     it.  */\n@@ -522,8 +522,7 @@ exec_file_attach (const char *filename, int from_tty)\n       /* Add the executable's sections to the current address spaces'\n \t list of sections.  This possibly pushes the exec_ops\n \t target.  */\n-      add_target_sections (&exec_bfd, sections, sections_end);\n-      xfree (sections);\n+      add_target_sections (&exec_bfd, sections);\n \n       /* Tell display code (if any) about the changed file name.  */\n       if (deprecated_exec_file_display_hook)\n@@ -592,50 +591,16 @@ file_command (const char *arg, int from_tty)\n void\n clear_section_table (struct target_section_table *table)\n {\n-  xfree (table->sections);\n-  table->sections = table->sections_end = NULL;\n+  table->sections.clear ();\n }\n \n-/* Resize section table TABLE by ADJUSTMENT.\n-   ADJUSTMENT may be negative, in which case the caller must have already\n-   removed the sections being deleted.\n-   Returns the old size.  */\n-\n-static int\n-resize_section_table (struct target_section_table *table, int adjustment)\n-{\n-  int old_count;\n-  int new_count;\n-\n-  old_count = table->sections_end - table->sections;\n-\n-  new_count = adjustment + old_count;\n-\n-  if (new_count)\n-    {\n-      table->sections = XRESIZEVEC (struct target_section, table->sections,\n-\t\t\t\t    new_count);\n-      table->sections_end = table->sections + new_count;\n-    }\n-  else\n-    clear_section_table (table);\n-\n-  return old_count;\n-}\n-\n-/* Builds a section table, given args BFD, SECTABLE_PTR, SECEND_PTR.\n+/* Builds a section table, given args BFD, TABLE.\n    Returns 0 if OK, 1 on error.  */\n \n int\n-build_section_table (struct bfd *some_bfd, struct target_section **start,\n-\t\t     struct target_section **end)\n+build_section_table (struct bfd *some_bfd, target_section_table *table)\n {\n-  unsigned count;\n-\n-  count = bfd_count_sections (some_bfd);\n-  xfree (*start);\n-  *start = XNEWVEC (struct target_section, count);\n-  *end = *start;\n+  table->sections.clear ();\n   for (asection *asect : gdb_bfd_sections (some_bfd))\n     {\n       flagword aflag;\n@@ -650,15 +615,14 @@ build_section_table (struct bfd *some_bfd, struct target_section **start,\n       if (!(aflag & SEC_ALLOC))\n \tcontinue;\n \n-      (*end)->owner = NULL;\n-      (*end)->the_bfd_section = asect;\n-      (*end)->addr = bfd_section_vma (asect);\n-      (*end)->endaddr = (*end)->addr + bfd_section_size (asect);\n-      (*end)++;\n+      table->sections.emplace_back ();\n+      target_section &sect = table->sections.back ();\n+      sect.owner = NULL;\n+      sect.the_bfd_section = asect;\n+      sect.addr = bfd_section_vma (asect);\n+      sect.endaddr = sect.addr + bfd_section_size (asect);\n     }\n \n-  gdb_assert (*end <= *start + count);\n-\n   /* We could realloc the table, but it probably loses for most files.  */\n   return 0;\n }\n@@ -668,23 +632,16 @@ build_section_table (struct bfd *some_bfd, struct target_section **start,\n \n void\n add_target_sections (void *owner,\n-\t\t     struct target_section *sections,\n-\t\t     struct target_section *sections_end)\n+\t\t     const target_section_table &sections)\n {\n-  int count;\n   struct target_section_table *table = current_target_sections;\n \n-  count = sections_end - sections;\n-\n-  if (count > 0)\n+  if (!sections.sections.empty ())\n     {\n-      int space = resize_section_table (table, count);\n-      int i;\n-\n-      for (i = 0; i < count; ++i)\n+      for (const target_section &s : sections.sections)\n \t{\n-\t  table->sections[space + i] = sections[i];\n-\t  table->sections[space + i].owner = owner;\n+\t  table->sections.push_back (s);\n+\t  table->sections.back ().owner = owner;\n \t}\n \n       scoped_restore_current_pspace_and_thread restore_pspace_thread;\n@@ -714,9 +671,7 @@ add_target_sections_of_objfile (struct objfile *objfile)\n {\n   struct target_section_table *table = current_target_sections;\n   struct obj_section *osect;\n-  int space;\n   unsigned count = 0;\n-  struct target_section *ts;\n \n   if (objfile == NULL)\n     return;\n@@ -732,23 +687,17 @@ add_target_sections_of_objfile (struct objfile *objfile)\n   if (count == 0)\n     return;\n \n-  space = resize_section_table (table, count);\n-\n-  ts = table->sections + space;\n-\n   ALL_OBJFILE_OSECTIONS (objfile, osect)\n     {\n       if (bfd_section_size (osect->the_bfd_section) == 0)\n \tcontinue;\n \n-      gdb_assert (ts < table->sections + space + count);\n-\n-      ts->addr = obj_section_addr (osect);\n-      ts->endaddr = obj_section_endaddr (osect);\n-      ts->the_bfd_section = osect->the_bfd_section;\n-      ts->owner = (void *) objfile;\n-\n-      ts++;\n+      table->sections.emplace_back ();\n+      target_section &ts = table->sections.back ();\n+      ts.addr = obj_section_addr (osect);\n+      ts.endaddr = obj_section_endaddr (osect);\n+      ts.the_bfd_section = osect->the_bfd_section;\n+      ts.owner = (void *) objfile;\n     }\n }\n \n@@ -758,48 +707,36 @@ add_target_sections_of_objfile (struct objfile *objfile)\n void\n remove_target_sections (void *owner)\n {\n-  struct target_section *src, *dest;\n   struct target_section_table *table = current_target_sections;\n \n   gdb_assert (owner != NULL);\n \n-  dest = table->sections;\n-  for (src = table->sections; src < table->sections_end; src++)\n-    if (src->owner != owner)\n-      {\n-\t/* Keep this section.  */\n-\tif (dest < src)\n-\t  *dest = *src;\n-\tdest++;\n-      }\n-\n-  /* If we've dropped any sections, resize the section table.  */\n-  if (dest < src)\n+  auto it = std::remove_if (table->sections.begin (),\n+\t\t\t    table->sections.end (),\n+\t\t\t    [&] (target_section &sect)\n+\t\t\t    {\n+\t\t\t      return sect.owner == owner;\n+\t\t\t    });\n+  table->sections.erase (it, table->sections.end ());\n+\n+  /* If we don't have any more sections to read memory from,\n+     remove the file_stratum target from the stack of each\n+     inferior sharing the program space.  */\n+  if (table->sections.empty ())\n     {\n-      int old_count;\n-\n-      old_count = resize_section_table (table, dest - src);\n+      scoped_restore_current_pspace_and_thread restore_pspace_thread;\n+      program_space *curr_pspace = current_program_space;\n \n-      /* If we don't have any more sections to read memory from,\n-\t remove the file_stratum target from the stack of each\n-\t inferior sharing the program space.  */\n-      if (old_count + (dest - src) == 0)\n+      for (inferior *inf : all_inferiors ())\n \t{\n-\t  scoped_restore_current_pspace_and_thread restore_pspace_thread;\n-\t  program_space *curr_pspace = current_program_space;\n-\n-\t  for (inferior *inf : all_inferiors ())\n-\t    {\n-\t      if (inf->pspace != curr_pspace)\n-\t\tcontinue;\n+\t  if (inf->pspace != curr_pspace)\n+\t    continue;\n \n-\t      if (inf->pspace->target_sections.sections\n-\t\t  != inf->pspace->target_sections.sections_end)\n-\t\tcontinue;\n+\t  if (!inf->pspace->target_sections.sections.empty ())\n+\t    continue;\n \n-\t      switch_to_inferior_no_thread (inf);\n-\t      unpush_target (&exec_ops);\n-\t    }\n+\t  switch_to_inferior_no_thread (inf);\n+\t  unpush_target (&exec_ops);\n \t}\n     }\n }\n@@ -809,8 +746,7 @@ remove_target_sections (void *owner)\n void\n exec_on_vfork ()\n {\n-  if (current_program_space->target_sections.sections\n-      != current_program_space->target_sections.sections_end)\n+  if (!current_program_space->target_sections.sections.empty ())\n     push_target (&exec_ops);\n }\n \n@@ -869,26 +805,25 @@ exec_read_partial_read_only (gdb_byte *readbuf, ULONGEST offset,\n \n static std::vector<mem_range>\n section_table_available_memory (CORE_ADDR memaddr, ULONGEST len,\n-\t\t\t\tstruct target_section *sections,\n-\t\t\t\tstruct target_section *sections_end)\n+\t\t\t\tconst target_section_table &sections)\n {\n   std::vector<mem_range> memory;\n \n-  for (target_section *p = sections; p < sections_end; p++)\n+  for (const target_section &p : sections.sections)\n     {\n-      if ((bfd_section_flags (p->the_bfd_section) & SEC_READONLY) == 0)\n+      if ((bfd_section_flags (p.the_bfd_section) & SEC_READONLY) == 0)\n \tcontinue;\n \n       /* Copy the meta-data, adjusted.  */\n-      if (mem_ranges_overlap (p->addr, p->endaddr - p->addr, memaddr, len))\n+      if (mem_ranges_overlap (p.addr, p.endaddr - p.addr, memaddr, len))\n \t{\n \t  ULONGEST lo1, hi1, lo2, hi2;\n \n \t  lo1 = memaddr;\n \t  hi1 = memaddr + len;\n \n-\t  lo2 = p->addr;\n-\t  hi2 = p->endaddr;\n+\t  lo2 = p.addr;\n+\t  hi2 = p.endaddr;\n \n \t  CORE_ADDR start = std::max (lo1, lo2);\n \t  int length = std::min (hi1, hi2) - start;\n@@ -906,8 +841,7 @@ section_table_read_available_memory (gdb_byte *readbuf, ULONGEST offset,\n {\n   target_section_table *table = target_get_section_table (&exec_ops);\n   std::vector<mem_range> available_memory\n-    = section_table_available_memory (offset, len,\n-\t\t\t\t      table->sections, table->sections_end);\n+    = section_table_available_memory (offset, len, *table);\n \n   normalize_mem_ranges (&available_memory);\n \n@@ -944,37 +878,35 @@ enum target_xfer_status\n section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n \t\t\t\t   ULONGEST offset, ULONGEST len,\n \t\t\t\t   ULONGEST *xfered_len,\n-\t\t\t\t   struct target_section *sections,\n-\t\t\t\t   struct target_section *sections_end,\n+\t\t\t\t   const target_section_table &sections,\n \t\t\t\t   gdb::function_view<bool\n \t\t\t\t     (const struct target_section *)> match_cb)\n {\n   int res;\n-  struct target_section *p;\n   ULONGEST memaddr = offset;\n   ULONGEST memend = memaddr + len;\n \n   gdb_assert (len != 0);\n \n-  for (p = sections; p < sections_end; p++)\n+  for (const target_section &p : sections.sections)\n     {\n-      struct bfd_section *asect = p->the_bfd_section;\n+      struct bfd_section *asect = p.the_bfd_section;\n       bfd *abfd = asect->owner;\n \n-      if (match_cb != nullptr && !match_cb (p))\n+      if (match_cb != nullptr && !match_cb (&p))\n \tcontinue;\t\t/* not the section we need.  */\n-      if (memaddr >= p->addr)\n+      if (memaddr >= p.addr)\n         {\n-\t  if (memend <= p->endaddr)\n+\t  if (memend <= p.endaddr)\n \t    {\n \t      /* Entire transfer is within this section.  */\n \t      if (writebuf)\n \t\tres = bfd_set_section_contents (abfd, asect,\n-\t\t\t\t\t\twritebuf, memaddr - p->addr,\n+\t\t\t\t\t\twritebuf, memaddr - p.addr,\n \t\t\t\t\t\tlen);\n \t      else\n \t\tres = bfd_get_section_contents (abfd, asect,\n-\t\t\t\t\t\treadbuf, memaddr - p->addr,\n+\t\t\t\t\t\treadbuf, memaddr - p.addr,\n \t\t\t\t\t\tlen);\n \n \t      if (res != 0)\n@@ -985,22 +917,22 @@ section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n \t      else\n \t\treturn TARGET_XFER_EOF;\n \t    }\n-\t  else if (memaddr >= p->endaddr)\n+\t  else if (memaddr >= p.endaddr)\n \t    {\n \t      /* This section ends before the transfer starts.  */\n \t      continue;\n \t    }\n \t  else\n \t    {\n \t      /* This section overlaps the transfer.  Just do half.  */\n-\t      len = p->endaddr - memaddr;\n+\t      len = p.endaddr - memaddr;\n \t      if (writebuf)\n \t\tres = bfd_set_section_contents (abfd, asect,\n-\t\t\t\t\t\twritebuf, memaddr - p->addr,\n+\t\t\t\t\t\twritebuf, memaddr - p.addr,\n \t\t\t\t\t\tlen);\n \t      else\n \t\tres = bfd_get_section_contents (abfd, asect,\n-\t\t\t\t\t\treadbuf, memaddr - p->addr,\n+\t\t\t\t\t\treadbuf, memaddr - p.addr,\n \t\t\t\t\t\tlen);\n \t      if (res != 0)\n \t\t{\n@@ -1033,8 +965,7 @@ exec_target::xfer_partial (enum target_object object,\n   if (object == TARGET_OBJECT_MEMORY)\n     return section_table_xfer_memory_partial (readbuf, writebuf,\n \t\t\t\t\t      offset, len, xfered_len,\n-\t\t\t\t\t      table->sections,\n-\t\t\t\t\t      table->sections_end);\n+\t\t\t\t\t      *table);\n   else\n     return TARGET_XFER_E_IO;\n }\n@@ -1044,7 +975,6 @@ void\n print_section_info (struct target_section_table *t, bfd *abfd)\n {\n   struct gdbarch *gdbarch = gdbarch_from_bfd (abfd);\n-  struct target_section *p;\n   /* FIXME: 16 is not wide enough when gdbarch_addr_bit > 64.  */\n   int wid = gdbarch_addr_bit (gdbarch) <= 32 ? 8 : 16;\n \n@@ -1059,10 +989,11 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n \t <p == t->sections_end>.  */\n       bfd_vma displacement = 0;\n       bfd_vma entry_point;\n+      bool found = false;\n \n-      for (p = t->sections; p < t->sections_end; p++)\n+      for (const target_section &p : t->sections)\n \t{\n-\t  struct bfd_section *psect = p->the_bfd_section;\n+\t  struct bfd_section *psect = p.the_bfd_section;\n \n \t  if ((bfd_section_flags (psect) & (SEC_ALLOC | SEC_LOAD))\n \t      != (SEC_ALLOC | SEC_LOAD))\n@@ -1072,11 +1003,12 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n \t      && abfd->start_address < (bfd_section_vma (psect)\n \t\t\t\t\t+ bfd_section_size (psect)))\n \t    {\n-\t      displacement = p->addr - bfd_section_vma (psect);\n+\t      displacement = p.addr - bfd_section_vma (psect);\n+\t      found = true;\n \t      break;\n \t    }\n \t}\n-      if (p == t->sections_end)\n+      if (!found)\n \twarning (_(\"Cannot find section for the entry point of %ps.\"),\n \t\t styled_string (file_name_style.style (),\n \t\t\t\tbfd_get_filename (abfd)));\n@@ -1087,13 +1019,13 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n       printf_filtered (_(\"\\tEntry point: %s\\n\"),\n \t\t       paddress (gdbarch, entry_point));\n     }\n-  for (p = t->sections; p < t->sections_end; p++)\n+  for (const target_section &p : t->sections)\n     {\n-      struct bfd_section *psect = p->the_bfd_section;\n+      struct bfd_section *psect = p.the_bfd_section;\n       bfd *pbfd = psect->owner;\n \n-      printf_filtered (\"\\t%s\", hex_string_custom (p->addr, wid));\n-      printf_filtered (\" - %s\", hex_string_custom (p->endaddr, wid));\n+      printf_filtered (\"\\t%s\", hex_string_custom (p.addr, wid));\n+      printf_filtered (\" - %s\", hex_string_custom (p.endaddr, wid));\n \n       /* FIXME: A format of \"08l\" is not wide enough for file offsets\n \t larger than 4GB.  OTOH, making it \"016l\" isn't desirable either\n@@ -1125,7 +1057,6 @@ exec_target::files_info ()\n static void\n set_section_command (const char *args, int from_tty)\n {\n-  struct target_section *p;\n   const char *secname;\n   unsigned seclen;\n   unsigned long secaddr;\n@@ -1144,14 +1075,14 @@ set_section_command (const char *args, int from_tty)\n   secaddr = parse_and_eval_address (args);\n \n   table = current_target_sections;\n-  for (p = table->sections; p < table->sections_end; p++)\n+  for (target_section &p : table->sections)\n     {\n-      if (!strncmp (secname, bfd_section_name (p->the_bfd_section), seclen)\n-\t  && bfd_section_name (p->the_bfd_section)[seclen] == '\\0')\n+      if (!strncmp (secname, bfd_section_name (p.the_bfd_section), seclen)\n+\t  && bfd_section_name (p.the_bfd_section)[seclen] == '\\0')\n \t{\n-\t  offset = secaddr - p->addr;\n-\t  p->addr += offset;\n-\t  p->endaddr += offset;\n+\t  offset = secaddr - p.addr;\n+\t  p.addr += offset;\n+\t  p.endaddr += offset;\n \t  if (from_tty)\n \t    exec_ops.files_info ();\n \t  return;\n@@ -1170,18 +1101,17 @@ set_section_command (const char *args, int from_tty)\n void\n exec_set_section_address (const char *filename, int index, CORE_ADDR address)\n {\n-  struct target_section *p;\n   struct target_section_table *table;\n \n   table = current_target_sections;\n-  for (p = table->sections; p < table->sections_end; p++)\n+  for (target_section &p : table->sections)\n     {\n       if (filename_cmp (filename,\n-\t\t\tbfd_get_filename (p->the_bfd_section->owner)) == 0\n-\t  && index == p->the_bfd_section->index)\n+\t\t\tbfd_get_filename (p.the_bfd_section->owner)) == 0\n+\t  && index == p.the_bfd_section->index)\n \t{\n-\t  p->endaddr += address - p->addr;\n-\t  p->addr = address;\n+\t  p.endaddr += address - p.addr;\n+\t  p.addr = address;\n \t}\n     }\n }\n@@ -1191,8 +1121,7 @@ exec_target::has_memory ()\n {\n   /* We can provide memory if we have any file/target sections to read\n      from.  */\n-  return (current_target_sections->sections\n-\t  != current_target_sections->sections_end);\n+  return !current_target_sections->sections.empty ();\n }\n \n char *"
    },
    {
      "sha": "d26eba492367f2a8ebac7825c4679aa0f126ee53",
      "filename": "gdb/exec.h",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/exec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/exec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.h?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -37,8 +37,7 @@ struct objfile;\n /* Builds a section table, given args BFD, SECTABLE_PTR, SECEND_PTR.\n    Returns 0 if OK, 1 on error.  */\n \n-extern int build_section_table (struct bfd *, struct target_section **,\n-\t\t\t\tstruct target_section **);\n+extern int build_section_table (struct bfd *, struct target_section_table *);\n \n /* Remove all entries from TABLE.  */\n \n@@ -86,8 +85,7 @@ extern enum target_xfer_status\n   section_table_xfer_memory_partial (gdb_byte *,\n \t\t\t\t     const gdb_byte *,\n \t\t\t\t     ULONGEST, ULONGEST, ULONGEST *,\n-\t\t\t\t     struct target_section *,\n-\t\t\t\t     struct target_section *,\n+\t\t\t\t     const target_section_table &,\n \t\t\t\t     gdb::function_view<bool\n \t\t\t\t       (const struct target_section *)> match_cb\n \t\t\t\t         = nullptr);\n@@ -111,8 +109,7 @@ extern void remove_target_sections (void *owner);\n    current set of target sections.  */\n \n extern void add_target_sections (void *owner,\n-\t\t\t\t struct target_section *sections,\n-\t\t\t\t struct target_section *sections_end);\n+\t\t\t\t const target_section_table &sections);\n \n /* Add the sections of OBJFILE to the current set of target sections.\n  * OBJFILE owns the new target sections.  */"
    },
    {
      "sha": "5dcb42d2f4e637b3a4a513090961020e3d8af323",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 14,
      "deletions": 19,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -171,8 +171,7 @@ struct record_full_core_buf_entry\n \n /* Record buf with core target.  */\n static detached_regcache *record_full_core_regbuf = NULL;\n-static struct target_section *record_full_core_start;\n-static struct target_section *record_full_core_end;\n+static target_section_table record_full_core_sections;\n static struct record_full_core_buf_entry *record_full_core_buf_list = NULL;\n \n /* The following variables are used for managing the linked list that\n@@ -924,9 +923,7 @@ record_full_core_open_1 (const char *name, int from_tty)\n   for (i = 0; i < regnum; i ++)\n     record_full_core_regbuf->raw_supply (i, *regcache);\n \n-  /* Get record_full_core_start and record_full_core_end.  */\n-  if (build_section_table (core_bfd, &record_full_core_start,\n-\t\t\t   &record_full_core_end))\n+  if (build_section_table (core_bfd, &record_full_core_sections))\n     {\n       delete record_full_core_regbuf;\n       record_full_core_regbuf = NULL;\n@@ -2147,27 +2144,25 @@ record_full_core_target::xfer_partial (enum target_object object,\n     {\n       if (record_full_gdb_operation_disable || !writebuf)\n \t{\n-\t  struct target_section *p;\n-\n-\t  for (p = record_full_core_start; p < record_full_core_end; p++)\n+\t  for (target_section &p : record_full_core_sections.sections)\n \t    {\n-\t      if (offset >= p->addr)\n+\t      if (offset >= p.addr)\n \t\t{\n \t\t  struct record_full_core_buf_entry *entry;\n \t\t  ULONGEST sec_offset;\n \n-\t\t  if (offset >= p->endaddr)\n+\t\t  if (offset >= p.endaddr)\n \t\t    continue;\n \n-\t\t  if (offset + len > p->endaddr)\n-\t\t    len = p->endaddr - offset;\n+\t\t  if (offset + len > p.endaddr)\n+\t\t    len = p.endaddr - offset;\n \n-\t\t  sec_offset = offset - p->addr;\n+\t\t  sec_offset = offset - p.addr;\n \n \t\t  /* Read readbuf or write writebuf p, offset, len.  */\n \t\t  /* Check flags.  */\n-\t\t  if (p->the_bfd_section->flags & SEC_CONSTRUCTOR\n-\t\t      || (p->the_bfd_section->flags & SEC_HAS_CONTENTS) == 0)\n+\t\t  if (p.the_bfd_section->flags & SEC_CONSTRUCTOR\n+\t\t      || (p.the_bfd_section->flags & SEC_HAS_CONTENTS) == 0)\n \t\t    {\n \t\t      if (readbuf)\n \t\t\tmemset (readbuf, 0, len);\n@@ -2178,18 +2173,18 @@ record_full_core_target::xfer_partial (enum target_object object,\n \t\t  /* Get record_full_core_buf_entry.  */\n \t\t  for (entry = record_full_core_buf_list; entry;\n \t\t       entry = entry->prev)\n-\t\t    if (entry->p == p)\n+\t\t    if (entry->p == &p)\n \t\t      break;\n \t\t  if (writebuf)\n \t\t    {\n \t\t      if (!entry)\n \t\t\t{\n \t\t\t  /* Add a new entry.  */\n \t\t\t  entry = XNEW (struct record_full_core_buf_entry);\n-\t\t\t  entry->p = p;\n+\t\t\t  entry->p = &p;\n \t\t\t  if (!bfd_malloc_and_get_section\n-\t\t\t        (p->the_bfd_section->owner,\n-\t\t\t\t p->the_bfd_section,\n+\t\t\t        (p.the_bfd_section->owner,\n+\t\t\t\t p.the_bfd_section,\n \t\t\t\t &entry->buf))\n \t\t\t    {\n \t\t\t      xfree (entry);"
    },
    {
      "sha": "15884fcd94192720322a587d0cc80402155a0277",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -8896,30 +8896,29 @@ remote_target::remote_xfer_live_readonly_partial (gdb_byte *readbuf,\n   if (secp != NULL\n       && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n     {\n-      struct target_section *p;\n       ULONGEST memend = memaddr + len;\n \n       table = target_get_section_table (this);\n \n-      for (p = table->sections; p < table->sections_end; p++)\n+      for (target_section &p : table->sections)\n \t{\n-\t  if (memaddr >= p->addr)\n+\t  if (memaddr >= p.addr)\n \t    {\n-\t      if (memend <= p->endaddr)\n+\t      if (memend <= p.endaddr)\n \t\t{\n \t\t  /* Entire transfer is within this section.  */\n \t\t  return remote_read_bytes_1 (memaddr, readbuf, len, unit_size,\n \t\t\t\t\t      xfered_len);\n \t\t}\n-\t      else if (memaddr >= p->endaddr)\n+\t      else if (memaddr >= p.endaddr)\n \t\t{\n \t\t  /* This section ends before the transfer starts.  */\n \t\t  continue;\n \t\t}\n \t      else\n \t\t{\n \t\t  /* This section overlaps the transfer.  Just do half.  */\n-\t\t  len = p->endaddr - memaddr;\n+\t\t  len = p.endaddr - memaddr;\n \t\t  return remote_read_bytes_1 (memaddr, readbuf, len, unit_size,\n \t\t\t\t\t      xfered_len);\n \t\t}"
    },
    {
      "sha": "5908921631463e4648aac3aa7f5f99f5e9ca7b1e",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -407,7 +407,6 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)\n   Elf32_External_Dyn *x_dynp_32;\n   Elf64_External_Dyn *x_dynp_64;\n   struct bfd_section *sect;\n-  struct target_section *target_section;\n \n   if (abfd == NULL)\n     return 0;\n@@ -424,14 +423,15 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)\n   if (sect == NULL)\n     return 0;\n \n-  for (target_section = current_target_sections->sections;\n-       target_section < current_target_sections->sections_end;\n-       target_section++)\n-    if (sect == target_section->the_bfd_section)\n-      break;\n-  if (target_section < current_target_sections->sections_end)\n-    dyn_addr = target_section->addr;\n-  else\n+  bool found = false;\n+  for (target_section &target_section : current_target_sections->sections)\n+    if (sect == target_section.the_bfd_section)\n+      {\n+\tdyn_addr = target_section.addr;\n+\tfound = true;\n+\tbreak;\n+      }\n+  if (!found)\n     {\n       /* ABFD may come from OBJFILE acting only as a symbol file without being\n \t loaded into the target (see add_symbol_file_command).  This case is"
    },
    {
      "sha": "9bb728ae9b9303158e0bc008eb385db5b47550bf",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -591,7 +591,6 @@ scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n   Elf32_External_Dyn *x_dynp_32;\n   Elf64_External_Dyn *x_dynp_64;\n   struct bfd_section *sect;\n-  struct target_section *target_section;\n \n   if (abfd == NULL)\n     return 0;\n@@ -608,14 +607,15 @@ scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n   if (sect == NULL)\n     return 0;\n \n-  for (target_section = current_target_sections->sections;\n-       target_section < current_target_sections->sections_end;\n-       target_section++)\n-    if (sect == target_section->the_bfd_section)\n-      break;\n-  if (target_section < current_target_sections->sections_end)\n-    dyn_addr = target_section->addr;\n-  else\n+  bool found = false;\n+  for (target_section &target_section : current_target_sections->sections)\n+    if (sect == target_section.the_bfd_section)\n+      {\n+\tdyn_addr = target_section.addr;\n+\tfound = true;\n+\tbreak;\n+      }\n+  if (!found)\n     {\n       /* ABFD may come from OBJFILE acting only as a symbol file without being\n \t loaded into the target (see add_symbol_file_command).  This case is"
    },
    {
      "sha": "906e1788c49b02db261c17b5d39244dce8074dc8",
      "filename": "gdb/solib.c",
      "status": "modified",
      "additions": 14,
      "deletions": 19,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -532,7 +532,6 @@ static int\n solib_map_sections (struct so_list *so)\n {\n   const struct target_so_ops *ops = solib_ops (target_gdbarch ());\n-  struct target_section *p;\n \n   gdb::unique_xmalloc_ptr<char> filename (tilde_expand (so->so_name));\n   gdb_bfd_ref_ptr abfd (ops->bfd_open (filename.get ()));\n@@ -553,35 +552,37 @@ solib_map_sections (struct so_list *so)\n     error (_(\"Shared library file name is too long.\"));\n   strcpy (so->so_name, bfd_get_filename (so->abfd));\n \n-  if (build_section_table (so->abfd, &so->sections, &so->sections_end))\n+  if (so->sections == nullptr)\n+    so->sections = new target_section_table;\n+  if (build_section_table (so->abfd, so->sections))\n     {\n       error (_(\"Can't find the file sections in `%s': %s\"),\n \t     bfd_get_filename (so->abfd), bfd_errmsg (bfd_get_error ()));\n     }\n \n-  for (p = so->sections; p < so->sections_end; p++)\n+  for (target_section &p : so->sections->sections)\n     {\n       /* Relocate the section binding addresses as recorded in the shared\n          object's file by the base address to which the object was actually\n          mapped.  */\n-      ops->relocate_section_addresses (so, p);\n+      ops->relocate_section_addresses (so, &p);\n \n       /* If the target didn't provide information about the address\n \t range of the shared object, assume we want the location of\n \t the .text section.  */\n       if (so->addr_low == 0 && so->addr_high == 0\n-\t  && strcmp (p->the_bfd_section->name, \".text\") == 0)\n+\t  && strcmp (p.the_bfd_section->name, \".text\") == 0)\n \t{\n-\t  so->addr_low = p->addr;\n-\t  so->addr_high = p->endaddr;\n+\t  so->addr_low = p.addr;\n+\t  so->addr_high = p.endaddr;\n \t}\n     }\n \n   /* Add the shared object's sections to the current set of file\n      section tables.  Do this immediately after mapping the object so\n      that later nodes in the list can query this object, as is needed\n      in solib-osf.c.  */\n-  add_target_sections (so, so->sections, so->sections_end);\n+  add_target_sections (so, *so->sections);\n \n   return 1;\n }\n@@ -600,11 +601,8 @@ clear_so (struct so_list *so)\n {\n   const struct target_so_ops *ops = solib_ops (target_gdbarch ());\n \n-  if (so->sections)\n-    {\n-      xfree (so->sections);\n-      so->sections = so->sections_end = NULL;\n-    }\n+  delete so->sections;\n+  so->sections = NULL;\n \n   gdb_bfd_unref (so->abfd);\n   so->abfd = NULL;\n@@ -683,8 +681,7 @@ solib_read_symbols (struct so_list *so, symfile_add_flags flags)\n \t  if (so->objfile == NULL)\n \t    {\n \t      section_addr_info sap\n-\t\t= build_section_addr_info_from_section_table (so->sections,\n-\t\t\t\t\t\t\t      so->sections_end);\n+\t\t= build_section_addr_info_from_section_table (*so->sections);\n \t      so->objfile = symbol_file_add_from_bfd (so->abfd, so->so_name,\n \t\t\t\t\t\t      flags, &sap,\n \t\t\t\t\t\t      OBJF_SHARED, NULL);\n@@ -1120,10 +1117,8 @@ bool\n solib_contains_address_p (const struct so_list *const solib,\n \t\t\t  CORE_ADDR address)\n {\n-  struct target_section *p;\n-\n-  for (p = solib->sections; p < solib->sections_end; p++)\n-    if (p->addr <= address && address < p->endaddr)\n+  for (target_section &p : solib->sections->sections)\n+    if (p.addr <= address && address < p.endaddr)\n       return true;\n \n   return false;"
    },
    {
      "sha": "1de797cc14b333ab39c54c17a648bec99e589b81",
      "filename": "gdb/solist.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solist.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/solist.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solist.h?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -23,6 +23,7 @@\n /* For domain_enum domain.  */\n #include \"symtab.h\"\n #include \"gdb_bfd.h\"\n+#include \"target-section.h\"\n \n /* Base class for target-specific link map information.  */\n \n@@ -71,8 +72,7 @@ struct so_list\n      the file cannot be found or after the command \"nosharedlibrary\".  */\n   struct objfile *objfile;\n \n-  struct target_section *sections;\n-  struct target_section *sections_end;\n+  target_section_table *sections;\n \n   /* Record the range of addresses belonging to this shared library.\n      There may not be just one (e.g. if two segments are relocated"
    },
    {
      "sha": "f4acec50ccaf6d8303d35d5eb2a78c20b5197f8f",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -212,21 +212,18 @@ find_lowest_section (asection *sect, asection **lowest)\n    an existing section table.  */\n \n section_addr_info\n-build_section_addr_info_from_section_table (const struct target_section *start,\n-                                            const struct target_section *end)\n+build_section_addr_info_from_section_table (const target_section_table &table)\n {\n-  const struct target_section *stp;\n-\n   section_addr_info sap;\n \n-  for (stp = start; stp != end; stp++)\n+  for (const target_section &stp : table.sections)\n     {\n-      struct bfd_section *asect = stp->the_bfd_section;\n+      struct bfd_section *asect = stp.the_bfd_section;\n       bfd *abfd = asect->owner;\n \n       if (bfd_section_flags (asect) & (SEC_ALLOC | SEC_LOAD)\n-\t  && sap.size () < end - start)\n-\tsap.emplace_back (stp->addr,\n+\t  && sap.size () < table.sections.size ())\n+\tsap.emplace_back (stp.addr,\n \t\t\t  bfd_section_name (asect),\n \t\t\t  gdb_bfd_section_index (abfd, asect));\n     }"
    },
    {
      "sha": "df646f0736f4fb0468d6c9880946f721e8e4ce71",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -27,6 +27,7 @@\n #include \"objfile-flags.h\"\n #include \"gdb_bfd.h\"\n #include \"gdbsupport/function-view.h\"\n+#include \"target-section.h\"\n \n /* Opaque declarations.  */\n struct target_section;\n@@ -451,10 +452,7 @@ extern std::string find_separate_debug_file_by_debuglink (struct objfile *);\n    existing section table.  */\n \n extern section_addr_info\n-   build_section_addr_info_from_section_table (const struct target_section\n-\t\t\t\t\t       *start,\n-\t\t\t\t\t       const struct target_section\n-\t\t\t\t\t       *end);\n+    build_section_addr_info_from_section_table (const target_section_table &table);\n \n \t\t\t/*   Variables   */\n "
    },
    {
      "sha": "97d9f4028a556f3bcd876cc51cca8a12146f5838",
      "filename": "gdb/target-section.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/target-section.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/target-section.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-section.h?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -42,12 +42,11 @@ struct target_section\n   void *owner;\n };\n \n-/* Holds an array of target sections.  Defined by [SECTIONS..SECTIONS_END[.  */\n+/* Holds an array of target sections.  */\n \n struct target_section_table\n {\n-  struct target_section *sections;\n-  struct target_section *sections_end;\n+  std::vector<struct target_section> sections;\n };\n \n #endif /* GDB_TARGET_SECTION_H */"
    },
    {
      "sha": "0f3f745c13f5f20c8c0a1536d80d5572cacfa18e",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb2a67773c5e06545c39a6373be720c7d3d9eeb5/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=bb2a67773c5e06545c39a6373be720c7d3d9eeb5",
      "patch": "@@ -824,15 +824,14 @@ struct target_section *\n target_section_by_addr (struct target_ops *target, CORE_ADDR addr)\n {\n   struct target_section_table *table = target_get_section_table (target);\n-  struct target_section *secp;\n \n   if (table == NULL)\n     return NULL;\n \n-  for (secp = table->sections; secp < table->sections_end; secp++)\n+  for (target_section &secp : table->sections)\n     {\n-      if (addr >= secp->addr && addr < secp->endaddr)\n-\treturn secp;\n+      if (addr >= secp.addr && addr < secp.endaddr)\n+\treturn &secp;\n     }\n   return NULL;\n }\n@@ -979,9 +978,7 @@ memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,\n \n \t  return section_table_xfer_memory_partial (readbuf, writebuf,\n \t\t\t\t\t\t    memaddr, len, xfered_len,\n-\t\t\t\t\t\t    table->sections,\n-\t\t\t\t\t\t    table->sections_end,\n-\t\t\t\t\t\t    match_cb);\n+\t\t\t\t\t\t    *table, match_cb);\n \t}\n     }\n \n@@ -998,8 +995,7 @@ memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,\n \t  table = target_get_section_table (ops);\n \t  return section_table_xfer_memory_partial (readbuf, writebuf,\n \t\t\t\t\t\t    memaddr, len, xfered_len,\n-\t\t\t\t\t\t    table->sections,\n-\t\t\t\t\t\t    table->sections_end);\n+\t\t\t\t\t\t    *table);\n \t}\n     }\n "
    }
  ]
}