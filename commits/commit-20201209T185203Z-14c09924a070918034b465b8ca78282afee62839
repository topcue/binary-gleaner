{
  "sha": "14c09924a070918034b465b8ca78282afee62839",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTRjMDk5MjRhMDcwOTE4MDM0YjQ2NWI4Y2E3ODI4MmFmZWU2MjgzOQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-09T18:52:03Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-12-09T18:52:03Z"
    },
    "message": "gdb: split get_discrete_bounds in two\n\nget_discrete_bounds is not flexible for ranges (TYPE_CODE_RANGE), in the\nsense that it returns true (success) only if both bounds are present and\nconstant values.\n\nThis is a problem for code that only needs to know the low bound and\nfails unnecessarily if the high bound is unknown.\n\nSplit the function in two, get_discrete_low_bound and\nget_discrete_high_bound, that both return an optional.  Provide a new\nimplementation of get_discrete_bounds based on the two others, so the\ncallers don't have to be changed.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.c (get_discrete_bounds): Implement with\n\tget_discrete_low_bound and get_discrete_high_bound.\n\t(get_discrete_low_bound): New.\n\t(get_discrete_high_bound): New.\n\nChange-Id: I986b5e9c0dd969800e3fb9546af9c827d52e80d0",
    "tree": {
      "sha": "711442c723f5afabb4985e2d5e6afaa6fa4e5403",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/711442c723f5afabb4985e2d5e6afaa6fa4e5403"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/14c09924a070918034b465b8ca78282afee62839",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14c09924a070918034b465b8ca78282afee62839",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/14c09924a070918034b465b8ca78282afee62839",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14c09924a070918034b465b8ca78282afee62839/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1f8d2881175920d389078852bb1ff0799d744599",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f8d2881175920d389078852bb1ff0799d744599",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1f8d2881175920d389078852bb1ff0799d744599"
    }
  ],
  "stats": {
    "total": 194,
    "additions": 137,
    "deletions": 57
  },
  "files": [
    {
      "sha": "3b022c1813fef8d425292d7e13aa25c4fc833716",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14c09924a070918034b465b8ca78282afee62839/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14c09924a070918034b465b8ca78282afee62839/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=14c09924a070918034b465b8ca78282afee62839",
      "patch": "@@ -1,3 +1,10 @@\n+2020-12-09  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.c (get_discrete_bounds): Implement with\n+\tget_discrete_low_bound and get_discrete_high_bound.\n+\t(get_discrete_low_bound): New.\n+\t(get_discrete_high_bound): New.\n+\n 2020-12-09  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (get_discrete_bounds): Return bool, adjust all"
    },
    {
      "sha": "367ca5f311c8319dd69577452358eaf74f39550e",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 130,
      "deletions": 57,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14c09924a070918034b465b8ca78282afee62839/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14c09924a070918034b465b8ca78282afee62839/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=14c09924a070918034b465b8ca78282afee62839",
      "patch": "@@ -1036,97 +1036,170 @@ has_static_range (const struct range_bounds *bounds)\n \t  && bounds->stride.kind () == PROP_CONST);\n }\n \n-/* See gdbtypes.h.  */\n+/* If TYPE's low bound is a known constant, return it, else return nullopt.  */\n \n-bool\n-get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n+static gdb::optional<LONGEST>\n+get_discrete_low_bound (struct type *type)\n {\n   type = check_typedef (type);\n   switch (type->code ())\n     {\n     case TYPE_CODE_RANGE:\n-      /* This function currently only works for ranges with two defined,\n-\t constant bounds.  */\n-      if (type->bounds ()->low.kind () != PROP_CONST\n-\t  || type->bounds ()->high.kind () != PROP_CONST)\n+      {\n+\t/* This function only works for ranges with a constant low bound.  */\n+\tif (type->bounds ()->low.kind () != PROP_CONST)\n+\t  return {};\n+\n+\tLONGEST low = type->bounds ()->low.const_val ();\n+\n+\tif (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM)\n+\t  {\n+\t    gdb::optional<LONGEST> low_pos\n+\t      = discrete_position (TYPE_TARGET_TYPE (type), low);\n+\n+\t    if (low_pos.has_value ())\n+\t      low = *low_pos;\n+\t  }\n+\n+\treturn low;\n+      }\n+\n+    case TYPE_CODE_ENUM:\n+      {\n+\tif (type->num_fields () > 0)\n+\t  {\n+\t    /* The enums may not be sorted by value, so search all\n+\t       entries.  */\n+\t    LONGEST low = TYPE_FIELD_ENUMVAL (type, 0);\n+\n+\t    for (int i = 0; i < type->num_fields (); i++)\n+\t      {\n+\t\tif (TYPE_FIELD_ENUMVAL (type, i) < low)\n+\t\t  low = TYPE_FIELD_ENUMVAL (type, i);\n+\t      }\n+\n+\t    /* Set unsigned indicator if warranted.  */\n+\t    if (low >= 0)\n+\t      type->set_is_unsigned (true);\n+\n+\t    return low;\n+\t  }\n+\telse\n+\t  return 0;\n+      }\n+\n+    case TYPE_CODE_BOOL:\n+      return 0;\n+\n+    case TYPE_CODE_INT:\n+      if (TYPE_LENGTH (type) > sizeof (LONGEST))\t/* Too big */\n \treturn false;\n \n-      *lowp = type->bounds ()->low.const_val ();\n-      *highp = type->bounds ()->high.const_val ();\n+      if (!type->is_unsigned ())\n+\treturn -(1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1));\n \n-      if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM)\n-\t{\n-\t  gdb::optional<LONGEST> low_pos\n-\t    = discrete_position (TYPE_TARGET_TYPE (type), *lowp);\n+      /* fall through */\n+    case TYPE_CODE_CHAR:\n+      return 0;\n \n-\t  if (low_pos.has_value ())\n-\t    *lowp = *low_pos;\n+    default:\n+      return false;\n+    }\n+}\n \n-\t  gdb::optional<LONGEST> high_pos\n-\t    = discrete_position (TYPE_TARGET_TYPE (type), *highp);\n+/* If TYPE's high bound is a known constant, return it, else return nullopt.  */\n \n-\t  if (high_pos.has_value ())\n-\t    *highp = *high_pos;\n-\t}\n-      return true;\n+static gdb::optional<LONGEST>\n+get_discrete_high_bound (struct type *type)\n+{\n+  type = check_typedef (type);\n+  switch (type->code ())\n+    {\n+    case TYPE_CODE_RANGE:\n+      {\n+\t/* This function only works for ranges with a constant high bound.  */\n+\tif (type->bounds ()->high.kind () != PROP_CONST)\n+\t  return {};\n+\n+\tLONGEST high = type->bounds ()->high.const_val ();\n+\n+\tif (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM)\n+\t  {\n+\t    gdb::optional<LONGEST> high_pos\n+\t      = discrete_position (TYPE_TARGET_TYPE (type), high);\n+\n+\t    if (high_pos.has_value ())\n+\t      high = *high_pos;\n+\t  }\n+\n+\treturn high;\n+      }\n \n     case TYPE_CODE_ENUM:\n-      if (type->num_fields () > 0)\n-\t{\n-\t  /* The enums may not be sorted by value, so search all\n-\t     entries.  */\n-\t  int i;\n+      {\n+\tif (type->num_fields () > 0)\n+\t  {\n+\t    /* The enums may not be sorted by value, so search all\n+\t       entries.  */\n+\t    LONGEST high = TYPE_FIELD_ENUMVAL (type, 0);\n \n-\t  *lowp = *highp = TYPE_FIELD_ENUMVAL (type, 0);\n-\t  for (i = 0; i < type->num_fields (); i++)\n-\t    {\n-\t      if (TYPE_FIELD_ENUMVAL (type, i) < *lowp)\n-\t\t*lowp = TYPE_FIELD_ENUMVAL (type, i);\n-\t      if (TYPE_FIELD_ENUMVAL (type, i) > *highp)\n-\t\t*highp = TYPE_FIELD_ENUMVAL (type, i);\n-\t    }\n+\t    for (int i = 0; i < type->num_fields (); i++)\n+\t      {\n+\t\tif (TYPE_FIELD_ENUMVAL (type, i) > high)\n+\t\t  high = TYPE_FIELD_ENUMVAL (type, i);\n+\t      }\n \n-\t  /* Set unsigned indicator if warranted.  */\n-\t  if (*lowp >= 0)\n-\t    type->set_is_unsigned (true);\n-\t}\n-      else\n-\t{\n-\t  *lowp = 0;\n-\t  *highp = -1;\n-\t}\n-      return true;\n+\t    return high;\n+\t  }\n+\telse\n+\t  return -1;\n+      }\n \n     case TYPE_CODE_BOOL:\n-      *lowp = 0;\n-      *highp = 1;\n-      return true;\n+      return 1;\n \n     case TYPE_CODE_INT:\n       if (TYPE_LENGTH (type) > sizeof (LONGEST))\t/* Too big */\n \treturn false;\n \n       if (!type->is_unsigned ())\n \t{\n-\t  *lowp = -(1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1));\n-\t  *highp = -*lowp - 1;\n-\t  return true;\n+\t  LONGEST low = -(1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1));\n+\t  return -low - 1;\n \t}\n+\n       /* fall through */\n     case TYPE_CODE_CHAR:\n-      *lowp = 0;\n-      /* This round-about calculation is to avoid shifting by\n-\t TYPE_LENGTH (type) * TARGET_CHAR_BIT, which will not work\n-\t if TYPE_LENGTH (type) == sizeof (LONGEST).  */\n-      *highp = 1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1);\n-      *highp = (*highp - 1) | *highp;\n-      return true;\n+      {\n+\t/* This round-about calculation is to avoid shifting by\n+\t   TYPE_LENGTH (type) * TARGET_CHAR_BIT, which will not work\n+\t   if TYPE_LENGTH (type) == sizeof (LONGEST).  */\n+\tLONGEST high = 1 << (TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1);\n+\treturn (high - 1) | high;\n+      }\n \n     default:\n       return false;\n     }\n }\n \n+/* See gdbtypes.h.  */\n+\n+bool\n+get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n+{\n+  gdb::optional<LONGEST> low = get_discrete_low_bound (type);\n+  gdb::optional<LONGEST> high = get_discrete_high_bound (type);\n+\n+  if (!low.has_value () || !high.has_value ())\n+    return false;\n+\n+  *lowp = *low;\n+  *highp = *high;\n+\n+  return true;\n+}\n+\n /* See gdbtypes.h  */\n \n bool"
    }
  ]
}