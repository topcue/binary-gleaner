{
  "sha": "c893ce360a81bed57b9256f9d065541c2f8175c0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yzg5M2NlMzYwYTgxYmVkNTdiOTI1NmY5ZDA2NTU0MWMyZjgxNzVjMA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-24T01:22:03Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-24T02:05:05Z"
    },
    "message": "vms buffer overflows and large memory allocation\n\n\t* vms-lib.c (struct carsym_mem): Add limit.\n\t(vms_add_index): Heed limit.\n\t(vms_traverse_index): Catch buffer overflows.  Remove outdated fixme.\n\t(vms_lib_read_index): Set up limit.  Catch 32-bit overflow.\n\tAlways return actual number read.\n\t(_bfd_vms_lib_archive_p): Catch buffer overflows.  Replace\n\tassertion with error exit.",
    "tree": {
      "sha": "043d6f5c61b8f144ffc063c8b68a6f343b2f461f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/043d6f5c61b8f144ffc063c8b68a6f343b2f461f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c893ce360a81bed57b9256f9d065541c2f8175c0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c893ce360a81bed57b9256f9d065541c2f8175c0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c893ce360a81bed57b9256f9d065541c2f8175c0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c893ce360a81bed57b9256f9d065541c2f8175c0/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "23c4ec6f0279d424899dbdab26d05426aebeba80",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/23c4ec6f0279d424899dbdab26d05426aebeba80",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/23c4ec6f0279d424899dbdab26d05426aebeba80"
    }
  ],
  "stats": {
    "total": 107,
    "additions": 82,
    "deletions": 25
  },
  "files": [
    {
      "sha": "58b560d1aaca3f2942585b966537c5f1740ea37c",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c893ce360a81bed57b9256f9d065541c2f8175c0/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c893ce360a81bed57b9256f9d065541c2f8175c0/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=c893ce360a81bed57b9256f9d065541c2f8175c0",
      "patch": "@@ -1,3 +1,13 @@\n+2020-02-24  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-lib.c (struct carsym_mem): Add limit.\n+\t(vms_add_index): Heed limit.\n+\t(vms_traverse_index): Catch buffer overflows.  Remove outdated fixme.\n+\t(vms_lib_read_index): Set up limit.  Catch 32-bit overflow.\n+\tAlways return actual number read.\n+\t(_bfd_vms_lib_archive_p): Catch buffer overflows.  Replace\n+\tassertion with error exit.\n+\n 2020-02-22  Alan Modra  <amodra@gmail.com>\n \n \tPR 25585"
    },
    {
      "sha": "3b42857aa9ce7e89d1e5c66da7c1a2e55eb24f42",
      "filename": "bfd/vms-lib.c",
      "status": "modified",
      "additions": 72,
      "deletions": 25,
      "changes": 97,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c893ce360a81bed57b9256f9d065541c2f8175c0/bfd/vms-lib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c893ce360a81bed57b9256f9d065541c2f8175c0/bfd/vms-lib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-lib.c?ref=c893ce360a81bed57b9256f9d065541c2f8175c0",
      "patch": "@@ -120,6 +120,9 @@ struct carsym_mem\n   /* Maximum number of entries.  */\n   unsigned int max;\n \n+  /* Do not allocate more that this number of entries.  */\n+  unsigned int limit;\n+\n   /* If true, the table was reallocated on the heap.  If false, it is still\n      in the BFD's objalloc.  */\n   bfd_boolean realloced;\n@@ -136,12 +139,14 @@ vms_add_index (struct carsym_mem *cs, char *name,\n       struct carsym *n;\n       size_t amt;\n \n-      if (cs->max > -33u / 2)\n+      if (cs->max > -33u / 2 || cs->max >= cs->limit)\n \t{\n \t  bfd_set_error (bfd_error_file_too_big);\n \t  return FALSE;\n \t}\n       cs->max = 2 * cs->max + 32;\n+      if (cs->max > cs->limit)\n+\tcs->max = cs->limit;\n       if (_bfd_mul_overflow (cs->max, sizeof (struct carsym), &amt))\n \t{\n \t  bfd_set_error (bfd_error_file_too_big);\n@@ -243,6 +248,7 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs)\n   file_ptr off;\n   unsigned char *p;\n   unsigned char *endp;\n+  unsigned int n;\n \n   /* Read the index block.  */\n   BFD_ASSERT (sizeof (indexdef) == VMS_BLOCK_SIZE);\n@@ -251,7 +257,10 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs)\n \n   /* Traverse it.  */\n   p = &indexdef.keys[0];\n-  endp = p + bfd_getl16 (indexdef.used);\n+  n = bfd_getl16 (indexdef.used);\n+  if (n > sizeof (indexdef.keys))\n+    return FALSE;\n+  endp = p + n;\n   while (p < endp)\n     {\n       unsigned int idx_vbn;\n@@ -292,6 +301,8 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs)\n \n       /* Point to the next index entry.  */\n       p = keyname + keylen;\n+      if (p > endp)\n+\treturn FALSE;\n \n       if (idx_off == RFADEF__C_INDEX)\n \t{\n@@ -333,11 +344,17 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs)\n \n \t\t  if (!vms_read_block (abfd, kvbn, kblk))\n \t\t    return FALSE;\n+\t\t  if (koff > sizeof (kblk) - sizeof (struct vms_kbn))\n+\t\t    return FALSE;\n \t\t  kbn = (struct vms_kbn *)(kblk + koff);\n \t\t  klen = bfd_getl16 (kbn->keylen);\n+\t\t  if (klen > sizeof (kblk) - koff)\n+\t\t    return FALSE;\n \t\t  kvbn = bfd_getl32 (kbn->rfa.vbn);\n \t\t  koff = bfd_getl16 (kbn->rfa.offset);\n \n+\t\t  if (noff + klen > keylen)\n+\t\t    return FALSE;\n \t\t  memcpy (name + noff, kbn + 1, klen);\n \t\t  noff += klen;\n \t\t}\n@@ -368,7 +385,7 @@ vms_traverse_index (bfd *abfd, unsigned int vbn, struct carsym_mem *cs)\n \t\t  || bfd_bread (&lhs, sizeof (lhs), abfd) != sizeof (lhs))\n \t\treturn FALSE;\n \n-\t      /* FIXME: this adds extra entries that were not accounted.  */\n+\t      /* These extra entries may cause reallocation of CS.  */\n \t      if (!vms_add_indexes_from_list (abfd, cs, name, &lhs.ng_g_rfa))\n \t\treturn FALSE;\n \t      if (!vms_add_indexes_from_list (abfd, cs, name, &lhs.ng_wk_rfa))\n@@ -397,7 +414,8 @@ vms_lib_read_index (bfd *abfd, int idx, unsigned int *nbrel)\n   struct vms_idd idd;\n   unsigned int flags;\n   unsigned int vbn;\n-  struct carsym *csbuf;\n+  ufile_ptr filesize;\n+  size_t amt;\n   struct carsym_mem csm;\n \n   /* Read index desription.  */\n@@ -411,14 +429,27 @@ vms_lib_read_index (bfd *abfd, int idx, unsigned int *nbrel)\n       || !(flags & IDD__FLAGS_VARLENIDX))\n     return NULL;\n \n-  csbuf = bfd_alloc (abfd, *nbrel * sizeof (struct carsym));\n-  if (csbuf == NULL)\n-    return NULL;\n-\n-  csm.max = *nbrel;\n+  filesize = bfd_get_file_size (abfd);\n   csm.nbr = 0;\n+  csm.max = *nbrel;\n+  csm.limit = -1u;\n   csm.realloced = FALSE;\n-  csm.idx = csbuf;\n+  if (filesize != 0)\n+    {\n+      /* Put an upper bound based on a file full of single char keys.\n+\t This is to prevent fuzzed binary silliness.  It is easily\n+\t possible to set up loops over file blocks that add syms\n+\t without end.  */\n+      if (filesize / (sizeof (struct vms_rfa) + 2) <= -1u)\n+\tcsm.limit = filesize / (sizeof (struct vms_rfa) + 2);\n+    }\n+  if (csm.max > csm.limit)\n+    csm.max = csm.limit;\n+  if (_bfd_mul_overflow (csm.max, sizeof (struct carsym), &amt))\n+    return NULL;\n+  csm.idx = bfd_alloc (abfd, amt);\n+  if (csm.idx == NULL)\n+    return NULL;\n \n   /* Note: if the index is empty, there is no block to traverse.  */\n   vbn = bfd_getl32 (idd.vbn);\n@@ -429,22 +460,24 @@ vms_lib_read_index (bfd *abfd, int idx, unsigned int *nbrel)\n \n       /* Note: in case of error, we can free what was allocated on the\n \t BFD's objalloc.  */\n-      bfd_release (abfd, csbuf);\n+      bfd_release (abfd, csm.idx);\n       return NULL;\n     }\n \n   if (csm.realloced)\n     {\n       /* There are more entries than the first estimate.  Allocate on\n \t the BFD's objalloc.  */\n+      struct carsym *csbuf;\n       csbuf = bfd_alloc (abfd, csm.nbr * sizeof (struct carsym));\n       if (csbuf == NULL)\n \treturn NULL;\n       memcpy (csbuf, csm.idx, csm.nbr * sizeof (struct carsym));\n       free (csm.idx);\n-      *nbrel = csm.nbr;\n+      csm.idx = csbuf;\n     }\n-  return csbuf;\n+  *nbrel = csm.nbr;\n+  return csm.idx;\n }\n \n /* Standard function.  */\n@@ -568,6 +601,8 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)\n \t  != sizeof (buf_reclen))\n \tgoto err;\n       reclen = bfd_getl32 (buf_reclen);\n+      if (reclen < sizeof (struct vms_dcxmap))\n+\tgoto err;\n       buf = _bfd_malloc_and_read (abfd, reclen, reclen);\n       if (buf == NULL)\n \tgoto err;\n@@ -578,39 +613,51 @@ _bfd_vms_lib_archive_p (bfd *abfd, enum vms_lib_kind kind)\n \t(abfd, tdata->nbr_dcxsbm * sizeof (struct dcxsbm_desc));\n       for (i = 0; i < tdata->nbr_dcxsbm; i++)\n \t{\n-\t  struct vms_dcxsbm *sbm = (struct vms_dcxsbm *) (buf + sbm_off);\n+\t  struct vms_dcxsbm *sbm;\n \t  struct dcxsbm_desc *sbmdesc = &tdata->dcxsbm[i];\n \t  unsigned int sbm_len;\n \t  unsigned int sbm_sz;\n \t  unsigned int off;\n-\t  unsigned char *data = (unsigned char *)sbm;\n \t  unsigned char *buf1;\n \t  unsigned int l, j;\n \n+\t  if (sbm_off > reclen\n+\t      || reclen - sbm_off < sizeof (struct vms_dcxsbm))\n+\t    goto err;\n+\t  sbm = (struct vms_dcxsbm *) (buf + sbm_off);\n \t  sbm_sz = bfd_getl16 (sbm->size);\n \t  sbm_off += sbm_sz;\n-\t  BFD_ASSERT (sbm_off <= reclen);\n \n \t  sbmdesc->min_char = sbm->min_char;\n \t  BFD_ASSERT (sbmdesc->min_char == 0);\n \t  sbmdesc->max_char = sbm->max_char;\n \t  sbm_len = sbmdesc->max_char - sbmdesc->min_char + 1;\n \t  l = (2 * sbm_len + 7) / 8;\n-\t  BFD_ASSERT\n-\t    (sbm_sz >= sizeof (struct vms_dcxsbm) + l + 3 * sbm_len\n-\t     || (tdata->nbr_dcxsbm == 1\n-\t\t && sbm_sz >= sizeof (struct vms_dcxsbm) + l + sbm_len));\n+\t  if (sbm_sz < sizeof (struct vms_dcxsbm) + l + sbm_len\n+\t      || (tdata->nbr_dcxsbm > 1\n+\t\t  && sbm_sz < sizeof (struct vms_dcxsbm) + l + 3 * sbm_len))\n+\t    goto err;\n \t  sbmdesc->flags = (unsigned char *)bfd_alloc (abfd, l);\n-\t  memcpy (sbmdesc->flags, data + bfd_getl16 (sbm->flags), l);\n+\t  off = bfd_getl16 (sbm->flags);\n+\t  if (off > reclen - sbm_off\n+\t      || reclen - sbm_off - off < l)\n+\t    goto err;\n+\t  memcpy (sbmdesc->flags, (bfd_byte *) sbm + off, l);\n \t  sbmdesc->nodes = (unsigned char *)bfd_alloc (abfd, 2 * sbm_len);\n-\t  memcpy (sbmdesc->nodes, data + bfd_getl16 (sbm->nodes), 2 * sbm_len);\n+\t  off = bfd_getl16 (sbm->nodes);\n+\t  if (off > reclen - sbm_off\n+\t      || reclen - sbm_off - off < 2 * sbm_len)\n+\t    goto err;\n+\t  memcpy (sbmdesc->nodes, (bfd_byte *) sbm + off, 2 * sbm_len);\n \t  off = bfd_getl16 (sbm->next);\n \t  if (off != 0)\n \t    {\n+\t      if (off > reclen - sbm_off\n+\t\t  || reclen - sbm_off - off < 2 * sbm_len)\n+\t\tgoto err;\n \t      /* Read the 'next' array.  */\n-\t      sbmdesc->next = (unsigned short *)bfd_alloc\n-\t\t(abfd, sbm_len * sizeof (unsigned short));\n-\t      buf1 = data + off;\n+\t      sbmdesc->next = (unsigned short *) bfd_alloc (abfd, 2 * sbm_len);\n+\t      buf1 = (bfd_byte *) sbm + off;\n \t      for (j = 0; j < sbm_len; j++)\n \t\tsbmdesc->next[j] = bfd_getl16 (buf1 + j * 2);\n \t    }"
    }
  ]
}