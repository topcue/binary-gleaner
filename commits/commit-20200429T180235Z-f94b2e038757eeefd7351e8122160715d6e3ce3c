{
  "sha": "f94b2e038757eeefd7351e8122160715d6e3ce3c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Zjk0YjJlMDM4NzU3ZWVlZmQ3MzUxZTgxMjIxNjA3MTVkNmUzY2UzYw==",
  "commit": {
    "author": {
      "name": "Kamil Rytarowski",
      "email": "n54@gmx.com",
      "date": "2020-04-28T23:57:38Z"
    },
    "committer": {
      "name": "Kamil Rytarowski",
      "email": "n54@gmx.com",
      "date": "2020-04-29T18:02:35Z"
    },
    "message": "Add basic event handling in the NetBSD target\n\nImplement the following events:\n - single step (TRAP_TRACE)\n - software breakpoint (TRAP_DBREG)\n - exec() (TRAP_EXEC)\n - syscall entry/exit (TRAP_SCE / TRAP_SCX)\n\nAdd support for NetBSD specific ::wait () and ::resume ().\n\nInstruct the generic code that exec and syscall events are supported.\n\nDefine an empty nbsd_get_syscall_number as it is prerequisite for\ncatching syscall entry and exit events, even if it is unused.\nThis function is used to detect whether the gdbarch supports the\n'catch syscall' feature.\n\ngdb/ChangeLog:\n\n       * nbsd-nat.c: Include \"sys/wait.h\".\n       (nbsd_resume, nbsd_nat_target::resume, nbsd_wait)\n       (nbsd_nat_target::wait, nbsd_nat_target::insert_exec_catchpoint)\n       (nbsd_nat_target::remove_exec_catchpoint)\n       (nbsd_nat_target::set_syscall_catchpoint): Add.\n       * nbsd-nat.h (nbsd_nat_target::resume, nbsd_nat_target::wait)\n       (nbsd_nat_target::insert_exec_catchpoint)\n       (nbsd_nat_target::remove_exec_catchpoint)\n       (nbsd_nat_target::set_syscall_catchpoint): Add.\n       * nbsd-tdep.c (nbsd_get_syscall_number): Add.\n       (nbsd_init_abi): Call `set_gdbarch_get_syscall_number' and pass\n       `nbsd_get_syscall_number'.",
    "tree": {
      "sha": "9143a58e046373060e481ea9b4ff24b430cca76d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9143a58e046373060e481ea9b4ff24b430cca76d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f94b2e038757eeefd7351e8122160715d6e3ce3c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f94b2e038757eeefd7351e8122160715d6e3ce3c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f94b2e038757eeefd7351e8122160715d6e3ce3c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f94b2e038757eeefd7351e8122160715d6e3ce3c/comments",
  "author": {
    "login": "krytarowski",
    "id": 6665730,
    "node_id": "MDQ6VXNlcjY2NjU3MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6665730?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/krytarowski",
    "html_url": "https://github.com/krytarowski",
    "followers_url": "https://api.github.com/users/krytarowski/followers",
    "following_url": "https://api.github.com/users/krytarowski/following{/other_user}",
    "gists_url": "https://api.github.com/users/krytarowski/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/krytarowski/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/krytarowski/subscriptions",
    "organizations_url": "https://api.github.com/users/krytarowski/orgs",
    "repos_url": "https://api.github.com/users/krytarowski/repos",
    "events_url": "https://api.github.com/users/krytarowski/events{/privacy}",
    "received_events_url": "https://api.github.com/users/krytarowski/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "krytarowski",
    "id": 6665730,
    "node_id": "MDQ6VXNlcjY2NjU3MzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6665730?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/krytarowski",
    "html_url": "https://github.com/krytarowski",
    "followers_url": "https://api.github.com/users/krytarowski/followers",
    "following_url": "https://api.github.com/users/krytarowski/following{/other_user}",
    "gists_url": "https://api.github.com/users/krytarowski/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/krytarowski/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/krytarowski/subscriptions",
    "organizations_url": "https://api.github.com/users/krytarowski/orgs",
    "repos_url": "https://api.github.com/users/krytarowski/repos",
    "events_url": "https://api.github.com/users/krytarowski/events{/privacy}",
    "received_events_url": "https://api.github.com/users/krytarowski/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cb4c35cfbe460c51fa13df42a56a4f811082f7eb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cb4c35cfbe460c51fa13df42a56a4f811082f7eb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cb4c35cfbe460c51fa13df42a56a4f811082f7eb"
    }
  ],
  "stats": {
    "total": 264,
    "additions": 264,
    "deletions": 0
  },
  "files": [
    {
      "sha": "f3593d6f8f0c0ee3e45d8d9ecdf85a830aeff484",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f94b2e038757eeefd7351e8122160715d6e3ce3c",
      "patch": "@@ -1,3 +1,18 @@\n+2020-04-29  Kamil Rytarowski  <n54@gmx.com>\n+\n+\t* nbsd-nat.c: Include \"sys/wait.h\".\n+\t(nbsd_resume, nbsd_nat_target::resume, nbsd_wait)\n+\t(nbsd_nat_target::wait, nbsd_nat_target::insert_exec_catchpoint)\n+\t(nbsd_nat_target::remove_exec_catchpoint)\n+\t(nbsd_nat_target::set_syscall_catchpoint): Add.\n+\t* nbsd-nat.h (nbsd_nat_target::resume, nbsd_nat_target::wait)\n+\t(nbsd_nat_target::insert_exec_catchpoint)\n+\t(nbsd_nat_target::remove_exec_catchpoint)\n+\t(nbsd_nat_target::set_syscall_catchpoint): Add.\n+\t* nbsd-tdep.c (nbsd_get_syscall_number): Add.\n+\t(nbsd_init_abi): Call `set_gdbarch_get_syscall_number' and pass\n+\t`nbsd_get_syscall_number'.\n+\n 2020-04-29  Tom Tromey  <tom@tromey.com>\n \n \t* stack.c (print_block_frame_labels): Remove."
    },
    {
      "sha": "b04e634b54911efe2fd570c800e281bc20c9cd17",
      "filename": "gdb/nbsd-nat.c",
      "status": "modified",
      "additions": 222,
      "deletions": 0,
      "changes": 222,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nbsd-nat.c?ref=f94b2e038757eeefd7351e8122160715d6e3ce3c",
      "patch": "@@ -28,6 +28,7 @@\n #include <sys/types.h>\n #include <sys/ptrace.h>\n #include <sys/sysctl.h>\n+#include <sys/wait.h>\n \n /* Return the name of a file that can be opened to get the symbols for\n    the child process identified by PID.  */\n@@ -539,3 +540,224 @@ nbsd_nat_target::info_proc (const char *args, enum info_proc_what what)\n \n   return true;\n }\n+\n+/* Resume execution of a specified PTID, that points to a process or a thread\n+   within a process.  If one thread is specified, all other threads are\n+   suspended.  If STEP is nonzero, single-step it.  If SIGNAL is nonzero,\n+   give it that signal.  */\n+\n+static void\n+nbsd_resume(nbsd_nat_target *target, ptid_t ptid, int step,\n+\t    enum gdb_signal signal)\n+{\n+  int request;\n+\n+  gdb_assert (minus_one_ptid != ptid);\n+\n+  if (ptid.lwp_p ())\n+    {\n+      /* If ptid is a specific LWP, suspend all other LWPs in the process.  */\n+      inferior *inf = find_inferior_ptid (target, ptid);\n+\n+      for (thread_info *tp : inf->non_exited_threads ())\n+        {\n+          if (tp->ptid.lwp () == ptid.lwp ())\n+            request = PT_RESUME;\n+          else\n+            request = PT_SUSPEND;\n+\n+          if (ptrace (request, tp->ptid.pid (), NULL, tp->ptid.lwp ()) == -1)\n+            perror_with_name ((\"ptrace\"));\n+        }\n+    }\n+  else\n+    {\n+      /* If ptid is a wildcard, resume all matching threads (they won't run\n+         until the process is continued however).  */\n+      for (thread_info *tp : all_non_exited_threads (target, ptid))\n+        if (ptrace (PT_RESUME, tp->ptid.pid (), NULL, tp->ptid.lwp ()) == -1)\n+          perror_with_name ((\"ptrace\"));\n+    }\n+\n+  if (step)\n+    {\n+      for (thread_info *tp : all_non_exited_threads (target, ptid))\n+\tif (ptrace (PT_SETSTEP, tp->ptid.pid (), NULL, tp->ptid.lwp ()) == -1)\n+\t  perror_with_name ((\"ptrace\"));\n+    }\n+  else\n+    {\n+      for (thread_info *tp : all_non_exited_threads (target, ptid))\n+\tif (ptrace (PT_CLEARSTEP, tp->ptid.pid (), NULL, tp->ptid.lwp ()) == -1)\n+\t  perror_with_name ((\"ptrace\"));\n+    }\n+\n+  if (catch_syscall_enabled () > 0)\n+    request = PT_SYSCALL;\n+  else\n+    request = PT_CONTINUE;\n+\n+  /* An address of (void *)1 tells ptrace to continue from\n+     where it was.  If GDB wanted it to start some other way, we have\n+     already written a new program counter value to the child.  */\n+  if (ptrace (request, ptid.pid (), (void *)1, gdb_signal_to_host (signal)) == -1)\n+    perror_with_name ((\"ptrace\"));\n+}\n+\n+/* Resume execution of thread PTID, or all threads of all inferiors\n+   if PTID is -1.  If STEP is nonzero, single-step it.  If SIGNAL is nonzero,\n+   give it that signal.  */\n+\n+void\n+nbsd_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n+{\n+  if (minus_one_ptid != ptid)\n+    nbsd_resume (this, ptid, step, signal);\n+  else\n+    {\n+      for (inferior *inf : all_non_exited_inferiors (this))\n+\tnbsd_resume (this, ptid_t (inf->pid, 0, 0), step, signal);\n+    }\n+}\n+\n+/* Implement a safe wrapper around waitpid().  */\n+\n+static pid_t\n+nbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int options)\n+{\n+  pid_t pid;\n+  int status;\n+\n+  set_sigint_trap ();\n+\n+  do\n+    {\n+      /* The common code passes WNOHANG that leads to crashes, overwrite it.  */\n+      pid = waitpid (ptid.pid (), &status, 0);\n+    }\n+  while (pid == -1 && errno == EINTR);\n+\n+  clear_sigint_trap ();\n+\n+  if (pid == -1)\n+    perror_with_name (_(\"Child process unexpectedly missing\"));\n+\n+  store_waitstatus (ourstatus, status);\n+  return pid;\n+}\n+\n+/* Wait for the child specified by PTID to do something.  Return the\n+   process ID of the child, or MINUS_ONE_PTID in case of error; store\n+   the status in *OURSTATUS.  */\n+\n+ptid_t\n+nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n+\t\t       int target_options)\n+{\n+  pid_t pid = nbsd_wait (ptid, ourstatus, target_options);\n+  ptid_t wptid = ptid_t (pid);\n+\n+  /* If the child stopped, keep investigating its status.  */\n+  if (ourstatus->kind != TARGET_WAITKIND_STOPPED)\n+    return wptid;\n+\n+  /* Extract the event and thread that received a signal.  */\n+  ptrace_siginfo_t psi;\n+  if (ptrace (PT_GET_SIGINFO, pid, &psi, sizeof (psi)) == -1)\n+    perror_with_name ((\"ptrace\"));\n+\n+  /* Pick child's siginfo_t.  */\n+  siginfo_t *si = &psi.psi_siginfo;\n+\n+  int lwp = psi.psi_lwpid;\n+\n+  int signo = si->si_signo;\n+  const int code = si->si_code;\n+\n+  /* Construct PTID with a specified thread that received the event.\n+     If a signal was targeted to the whole process, lwp is 0.  */\n+  wptid = ptid_t (pid, lwp, 0);\n+\n+  /* Bail out on non-debugger oriented signals..  */\n+  if (signo != SIGTRAP)\n+    return wptid;\n+\n+  /* Stop examining non-debugger oriented SIGTRAP codes.  */\n+  if (code <= SI_USER || code == SI_NOINFO)\n+    return wptid;\n+\n+  if (in_thread_list (this, ptid_t (pid)))\n+      thread_change_ptid (this, ptid_t (pid), wptid);\n+\n+  if (code == TRAP_EXEC)\n+    {\n+      ourstatus->kind = TARGET_WAITKIND_EXECD;\n+      ourstatus->value.execd_pathname = xstrdup (pid_to_exec_file (pid));\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_TRACE)\n+    {\n+      /* Unhandled at this level.  */\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_SCE || code == TRAP_SCX)\n+    {\n+      int sysnum = si->si_sysnum;\n+\n+      if (!catch_syscall_enabled () || !catching_syscall_number (sysnum))\n+\t{\n+\t  /* If the core isn't interested in this event, ignore it.  */\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  return wptid;\n+\t}\n+\n+      ourstatus->kind =\n+\t(code == TRAP_SCE) ? TARGET_WAITKIND_SYSCALL_ENTRY :\n+\tTARGET_WAITKIND_SYSCALL_RETURN;\n+      ourstatus->value.syscall_number = sysnum;\n+      return wptid;\n+    }\n+\n+  if (code == TRAP_BRKPT)\n+    {\n+      /* Unhandled at this level.  */\n+      return wptid;\n+    }\n+\n+  /* Unclassified SIGTRAP event.  */\n+  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  return wptid;\n+}\n+\n+/* Implement the \"insert_exec_catchpoint\" target_ops method.  */\n+\n+int\n+nbsd_nat_target::insert_exec_catchpoint (int pid)\n+{\n+  /* Nothing to do.  */\n+  return 0;\n+}\n+\n+/* Implement the \"remove_exec_catchpoint\" target_ops method.  */\n+\n+int\n+nbsd_nat_target::remove_exec_catchpoint (int pid)\n+{\n+  /* Nothing to do.  */\n+  return 0;\n+}\n+\n+/* Implement the \"set_syscall_catchpoint\" target_ops method.  */\n+\n+int\n+nbsd_nat_target::set_syscall_catchpoint (int pid, bool needed,\n+                                         int any_count,\n+                                         gdb::array_view<const int> syscall_counts)\n+{\n+  /* Ignore the arguments.  inf-ptrace.c will use PT_SYSCALL which\n+     will catch all system call entries and exits.  The system calls\n+     are filtered by GDB rather than the kernel.  */\n+  return 0;\n+}"
    },
    {
      "sha": "6e14cbb889d4060148f1e392794bf0b307de92d8",
      "filename": "gdb/nbsd-nat.h",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nbsd-nat.h?ref=f94b2e038757eeefd7351e8122160715d6e3ce3c",
      "patch": "@@ -38,6 +38,15 @@ struct nbsd_nat_target : public inf_ptrace_target\n \n   int find_memory_regions (find_memory_region_ftype func, void *data) override;\n   bool info_proc (const char *, enum info_proc_what) override;\n+\n+  void resume (ptid_t, int, enum gdb_signal) override;\n+  ptid_t wait (ptid_t, struct target_waitstatus *, int) override;\n+  int insert_exec_catchpoint (int pid) override;\n+  int remove_exec_catchpoint (int pid) override;\n+  int set_syscall_catchpoint (int pid, bool needed, int any_count,\n+\t\t\t      gdb::array_view<const int> syscall_counts)\n+    override;\n+\n };\n \n #endif /* nbsd-nat.h */"
    },
    {
      "sha": "2ed16f6faf613035ef94de35e9eddaf1cc1953b6",
      "filename": "gdb/nbsd-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f94b2e038757eeefd7351e8122160715d6e3ce3c/gdb/nbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nbsd-tdep.c?ref=f94b2e038757eeefd7351e8122160715d6e3ce3c",
      "patch": "@@ -444,6 +444,21 @@ nbsd_info_proc_mappings_entry (int addr_bit, ULONGEST kve_start,\n     }\n }\n \n+/* Implement the \"get_syscall_number\" gdbarch method.  */\n+\n+static LONGEST\n+nbsd_get_syscall_number (struct gdbarch *gdbarch, thread_info *thread)\n+{\n+\n+  /* NetBSD doesn't use gdbarch_get_syscall_number since NetBSD\n+     native targets fetch the system call number from the\n+     'si_sysnum' member of siginfo_t in nbsd_nat_target::wait.\n+     However, system call catching requires this function to be\n+     set.  */\n+\n+  internal_error (__FILE__, __LINE__, _(\"nbsd_get_sycall_number called\"));\n+}\n+\n /* See nbsd-tdep.h.  */\n \n void\n@@ -453,4 +468,7 @@ nbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_gdb_signal_to_target (gdbarch, nbsd_gdb_signal_to_target);\n   set_gdbarch_skip_solib_resolver (gdbarch, nbsd_skip_solib_resolver);\n   set_gdbarch_auxv_parse (gdbarch, svr4_auxv_parse);\n+\n+  /* `catch syscall' */\n+  set_gdbarch_get_syscall_number (gdbarch, nbsd_get_syscall_number);\n }"
    }
  ]
}