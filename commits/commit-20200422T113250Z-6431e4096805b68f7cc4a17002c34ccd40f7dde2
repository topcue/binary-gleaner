{
  "sha": "6431e4096805b68f7cc4a17002c34ccd40f7dde2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjQzMWU0MDk2ODA1YjY4ZjdjYzRhMTcwMDJjMzRjY2Q0MGY3ZGRlMg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-22T05:09:53Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-22T11:32:50Z"
    },
    "message": "readelf: cmdline data\n\nDon't use a struct filedata for cmdline, which only needs two of the\nfiledata fields.\n\n\t* readelf.c (struct dump_data): New, used..\n\t(cmdline): ..here, and..\n\t(struct filedata): ..here.  Adjust all uses.\n\t(request_dump_bynumber, request_dump, parse_args): Pass in a\n\tstruct dump_data* rather than Filedata*.  Adjust callers.\n\t(main): Don't set cmdline.file_name.",
    "tree": {
      "sha": "ade01eb664e99b873bf73a9fdea1242cc9df8d40",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ade01eb664e99b873bf73a9fdea1242cc9df8d40"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6431e4096805b68f7cc4a17002c34ccd40f7dde2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6431e4096805b68f7cc4a17002c34ccd40f7dde2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6431e4096805b68f7cc4a17002c34ccd40f7dde2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6431e4096805b68f7cc4a17002c34ccd40f7dde2/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "714534e1b88608f92b6946d8e5a24ea51a40e363",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/714534e1b88608f92b6946d8e5a24ea51a40e363",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/714534e1b88608f92b6946d8e5a24ea51a40e363"
    }
  ],
  "stats": {
    "total": 114,
    "additions": 64,
    "deletions": 50
  },
  "files": [
    {
      "sha": "3e102229f2907434a4f044f3e14eb4390b4bb821",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6431e4096805b68f7cc4a17002c34ccd40f7dde2/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6431e4096805b68f7cc4a17002c34ccd40f7dde2/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=6431e4096805b68f7cc4a17002c34ccd40f7dde2",
      "patch": "@@ -1,3 +1,12 @@\n+2020-04-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* readelf.c (struct dump_data): New, used..\n+\t(cmdline): ..here, and..\n+\t(struct filedata): ..here.  Adjust all uses.\n+\t(request_dump_bynumber, request_dump, parse_args): Pass in a\n+\tstruct dump_data* rather than Filedata*.  Adjust callers.\n+\t(main): Don't set cmdline.file_name.\n+\n 2020-04-20  Alan Modra  <amodra@gmail.com>\n \n \t* readelf.c (process_symbol_table): Clear ngnuchains, ngnubuckets"
    },
    {
      "sha": "ff034cda0bd90d06955b85a62340bbc8cd1e9897",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 55,
      "deletions": 50,
      "changes": 105,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6431e4096805b68f7cc4a17002c34ccd40f7dde2/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6431e4096805b68f7cc4a17002c34ccd40f7dde2/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=6431e4096805b68f7cc4a17002c34ccd40f7dde2",
      "patch": "@@ -197,6 +197,17 @@ struct dump_list_entry\n   struct dump_list_entry *  next;\n };\n \n+/* A dynamic array of flags indicating for which sections a dump\n+   has been requested via command line switches.  */\n+struct dump_data {\n+  dump_type *          dump_sects;\n+  unsigned int         num_dump_sects;\n+};\n+\n+static struct dump_data cmdline;\n+\n+static struct dump_list_entry * dump_sects_byname;\n+\n typedef struct filedata\n {\n   const char *         file_name;\n@@ -212,8 +223,7 @@ typedef struct filedata\n      basis and then initialised from the cmdline_dump_sects array,\n      the results of interpreting the -w switch, and the\n      dump_sects_byname list.  */\n-  dump_type *          dump_sects;\n-  unsigned int         num_dump_sects;\n+  struct dump_data     dump;\n } Filedata;\n \n char * program_name = \"readelf\";\n@@ -290,12 +300,6 @@ static size_t           group_count;\n static struct group *   section_groups;\n static struct group **  section_headers_groups;\n \n-/* A dynamic array of flags indicating for which sections a dump\n-   has been requested via command line switches.  */\n-static Filedata         cmdline;\n-\n-static struct dump_list_entry * dump_sects_byname;\n-\n /* How to print a vma value.  */\n typedef enum print_mode\n {\n@@ -4578,9 +4582,10 @@ usage (FILE * stream)\n    the first time.  */\n \n static void\n-request_dump_bynumber (Filedata * filedata, unsigned int section, dump_type type)\n+request_dump_bynumber (struct dump_data *dumpdata,\n+\t\t       unsigned int section, dump_type type)\n {\n-  if (section >= filedata->num_dump_sects)\n+  if (section >= dumpdata->num_dump_sects)\n     {\n       dump_type * new_dump_sects;\n \n@@ -4591,22 +4596,22 @@ request_dump_bynumber (Filedata * filedata, unsigned int section, dump_type type\n \terror (_(\"Out of memory allocating dump request table.\\n\"));\n       else\n \t{\n-\t  if (filedata->dump_sects)\n+\t  if (dumpdata->dump_sects)\n \t    {\n \t      /* Copy current flag settings.  */\n-\t      memcpy (new_dump_sects, filedata->dump_sects,\n-\t\t      filedata->num_dump_sects * sizeof (* new_dump_sects));\n+\t      memcpy (new_dump_sects, dumpdata->dump_sects,\n+\t\t      dumpdata->num_dump_sects * sizeof (* new_dump_sects));\n \n-\t      free (filedata->dump_sects);\n+\t      free (dumpdata->dump_sects);\n \t    }\n \n-\t  filedata->dump_sects = new_dump_sects;\n-\t  filedata->num_dump_sects = section + 1;\n+\t  dumpdata->dump_sects = new_dump_sects;\n+\t  dumpdata->num_dump_sects = section + 1;\n \t}\n     }\n \n-  if (filedata->dump_sects)\n-    filedata->dump_sects[section] |= type;\n+  if (dumpdata->dump_sects)\n+    dumpdata->dump_sects[section] |= type;\n }\n \n /* Request a dump by section name.  */\n@@ -4632,7 +4637,7 @@ request_dump_byname (const char * section, dump_type type)\n }\n \n static inline void\n-request_dump (Filedata * filedata, dump_type type)\n+request_dump (struct dump_data *dumpdata, dump_type type)\n {\n   int section;\n   char * cp;\n@@ -4641,13 +4646,13 @@ request_dump (Filedata * filedata, dump_type type)\n   section = strtoul (optarg, & cp, 0);\n \n   if (! *cp && section >= 0)\n-    request_dump_bynumber (filedata, section, type);\n+    request_dump_bynumber (dumpdata, section, type);\n   else\n     request_dump_byname (optarg, type);\n }\n \n static void\n-parse_args (Filedata * filedata, int argc, char ** argv)\n+parse_args (struct dump_data *dumpdata, int argc, char ** argv)\n {\n   int c;\n \n@@ -4730,13 +4735,13 @@ parse_args (Filedata * filedata, int argc, char ** argv)\n \t  do_archive_index = TRUE;\n \t  break;\n \tcase 'x':\n-\t  request_dump (filedata, HEX_DUMP);\n+\t  request_dump (dumpdata, HEX_DUMP);\n \t  break;\n \tcase 'p':\n-\t  request_dump (filedata, STRING_DUMP);\n+\t  request_dump (dumpdata, STRING_DUMP);\n \t  break;\n \tcase 'R':\n-\t  request_dump (filedata, RELOC_DUMP);\n+\t  request_dump (dumpdata, RELOC_DUMP);\n \t  break;\n \tcase 'z':\n \t  decompress_dumps = TRUE;\n@@ -4783,7 +4788,7 @@ parse_args (Filedata * filedata, int argc, char ** argv)\n \t  break;\n \tcase OPTION_CTF_DUMP:\n \t  do_ctf = TRUE;\n-\t  request_dump (filedata, CTF_DUMP);\n+\t  request_dump (dumpdata, CTF_DUMP);\n \t  break;\n \tcase OPTION_CTF_SYMBOLS:\n \t  dump_ctf_symtab_name = strdup (optarg);\n@@ -4799,7 +4804,7 @@ parse_args (Filedata * filedata, int argc, char ** argv)\n \t  break;\n #ifdef SUPPORT_DISASSEMBLY\n \tcase 'i':\n-\t  request_dump (filedata, DISASS_DUMP);\n+\t  request_dump (dumpdata, DISASS_DUMP);\n \t  break;\n #endif\n \tcase 'v':\n@@ -6353,17 +6358,17 @@ process_section_headers (Filedata * filedata)\n \t      || (do_debug_cu_index && const_strneq (name, \"cu_index\"))\n \t      || (do_debug_cu_index && const_strneq (name, \"tu_index\"))\n \t      )\n-\t    request_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\t    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n \t}\n       /* Linkonce section to be combined with .debug_info at link time.  */\n       else if ((do_debugging || do_debug_info)\n \t       && const_strneq (name, \".gnu.linkonce.wi.\"))\n-\trequest_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\trequest_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n       else if (do_debug_frames && streq (name, \".eh_frame\"))\n-\trequest_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\trequest_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n       else if (do_gdb_index && (streq (name, \".gdb_index\")\n \t\t\t\t|| streq (name, \".debug_names\")))\n-\trequest_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\trequest_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n       /* Trace sections for Itanium VMS.  */\n       else if ((do_debugging || do_trace_info || do_trace_abbrevs\n                 || do_trace_aranges)\n@@ -6376,12 +6381,12 @@ process_section_headers (Filedata * filedata)\n \t      || (do_trace_abbrevs  && streq (name, \"abbrev\"))\n \t      || (do_trace_aranges  && streq (name, \"aranges\"))\n \t      )\n-\t    request_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\t    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n \t}\n       else if ((do_debugging || do_debug_links)\n \t       && (const_strneq (name, \".gnu_debuglink\")\n \t\t   || const_strneq (name, \".gnu_debugaltlink\")))\n-\trequest_dump_bynumber (filedata, i, DEBUG_DUMP);\n+\trequest_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);\n     }\n \n   if (! do_sections)\n@@ -14635,7 +14640,7 @@ initialise_dumps_byname (Filedata * filedata)\n       for (i = 0; i < filedata->file_header.e_shnum; i++)\n \tif (streq (SECTION_NAME (filedata->section_headers + i), cur->name))\n \t  {\n-\t    request_dump_bynumber (filedata, i, cur->type);\n+\t    request_dump_bynumber (&filedata->dump, i, cur->type);\n \t    any = TRUE;\n \t  }\n \n@@ -14658,10 +14663,10 @@ process_section_contents (Filedata * filedata)\n   initialise_dumps_byname (filedata);\n \n   for (i = 0, section = filedata->section_headers;\n-       i < filedata->file_header.e_shnum && i < filedata->num_dump_sects;\n+       i < filedata->file_header.e_shnum && i < filedata->dump.num_dump_sects;\n        i++, section++)\n     {\n-      dump_type dump = filedata->dump_sects[i];\n+      dump_type dump = filedata->dump.dump_sects[i];\n \n #ifdef SUPPORT_DISASSEMBLY\n       if (dump & DISASS_DUMP)\n@@ -14703,9 +14708,9 @@ process_section_contents (Filedata * filedata)\n \n   /* Check to see if the user requested a\n      dump of a section that does not exist.  */\n-  while (i < filedata->num_dump_sects)\n+  while (i < filedata->dump.num_dump_sects)\n     {\n-      if (filedata->dump_sects[i])\n+      if (filedata->dump.dump_sects[i])\n \t{\n \t  warn (_(\"Section %d was not dumped because it does not exist!\\n\"), i);\n \t  res = FALSE;\n@@ -20084,18 +20089,19 @@ process_object (Filedata * filedata)\n      Note we do this even if cmdline_dump_sects is empty because we\n      must make sure that the dump_sets array is zeroed out before each\n      object file is processed.  */\n-  if (filedata->num_dump_sects > cmdline.num_dump_sects)\n-    memset (filedata->dump_sects, 0, filedata->num_dump_sects * sizeof (* filedata->dump_sects));\n+  if (filedata->dump.num_dump_sects > cmdline.num_dump_sects)\n+    memset (filedata->dump.dump_sects, 0,\n+\t    filedata->dump.num_dump_sects * sizeof (*filedata->dump.dump_sects));\n \n   if (cmdline.num_dump_sects > 0)\n     {\n-      if (filedata->num_dump_sects == 0)\n+      if (filedata->dump.num_dump_sects == 0)\n \t/* A sneaky way of allocating the dump_sects array.  */\n-\trequest_dump_bynumber (filedata, cmdline.num_dump_sects, 0);\n+\trequest_dump_bynumber (&filedata->dump, cmdline.num_dump_sects, 0);\n \n-      assert (filedata->num_dump_sects >= cmdline.num_dump_sects);\n-      memcpy (filedata->dump_sects, cmdline.dump_sects,\n-\t      cmdline.num_dump_sects * sizeof (* filedata->dump_sects));\n+      assert (filedata->dump.num_dump_sects >= cmdline.num_dump_sects);\n+      memcpy (filedata->dump.dump_sects, cmdline.dump_sects,\n+\t      cmdline.num_dump_sects * sizeof (*filedata->dump.dump_sects));\n     }\n \n   if (! process_file_header (filedata))\n@@ -20176,11 +20182,11 @@ process_object (Filedata * filedata)\n   filedata->string_table = NULL;\n   filedata->string_table_length = 0;\n \n-  if (filedata->dump_sects != NULL)\n+  if (filedata->dump.dump_sects != NULL)\n     {\n-      free (filedata->dump_sects);\n-      filedata->dump_sects = NULL;\n-      filedata->num_dump_sects = 0;\n+      free (filedata->dump.dump_sects);\n+      filedata->dump.dump_sects = NULL;\n+      filedata->dump.num_dump_sects = 0;\n     }\n \n   if (dynamic_strings)\n@@ -20611,7 +20617,7 @@ process_file (char * file_name)\n   free (filedata->section_headers);\n   free (filedata->program_headers);\n   free (filedata->string_table);\n-  free (filedata->dump_sects);\n+  free (filedata->dump.dump_sects);\n   free (filedata);\n \n   free (ba_cache.strtab);\n@@ -20659,7 +20665,6 @@ main (int argc, char ** argv)\n \n   expandargv (&argc, &argv);\n \n-  cmdline.file_name = \"<cmdline>\";\n   parse_args (& cmdline, argc, argv);\n \n   if (optind < (argc - 1))"
    }
  ]
}