{
  "sha": "a05a883fbaba69d0f80806e46a9457727fcbe74c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTA1YTg4M2ZiYWJhNjlkMGY4MDgwNmU0NmE5NDU3NzI3ZmNiZTc0Yw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-06-29T16:03:50Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-06-29T16:03:50Z"
    },
    "message": "gdb: introduce frame_debug_printf\n\nIntroduce frame_debug_printf, to convert the \"frame\" debug messages to\nthe new system.  Replace fprint_frame with a frame_info::to_string\nmethod that returns a string, like what was done with\nframe_id::to_string.  This makes it easier to use with\nframe_debug_printf.\n\ngdb/ChangeLog:\n\n\t* frame.h (frame_debug_printf): New.\n\t* frame.c: Use frame_debug_printf throughout when printing frame\n\tdebug messages.\n\t* amd64-windows-tdep.c: Likewise.\n\t* value.c: Likewise.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.dwarf2/dw2-reg-undefined.exp: Update regexp.\n\nChange-Id: I3c230b0814ea81c23af3e1aca1aac8d4ba91d726",
    "tree": {
      "sha": "bf42b4af7d2b766c0424514e269a41e8ffc162f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bf42b4af7d2b766c0424514e269a41e8ffc162f6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a05a883fbaba69d0f80806e46a9457727fcbe74c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a05a883fbaba69d0f80806e46a9457727fcbe74c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a05a883fbaba69d0f80806e46a9457727fcbe74c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a05a883fbaba69d0f80806e46a9457727fcbe74c/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dd4f75f2b6f0be9cb45204aacb3e22462d3c7cd5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd4f75f2b6f0be9cb45204aacb3e22462d3c7cd5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dd4f75f2b6f0be9cb45204aacb3e22462d3c7cd5"
    }
  ],
  "stats": {
    "total": 428,
    "additions": 177,
    "deletions": 251
  },
  "files": [
    {
      "sha": "3cda05433ce11f73533eb309401bdb86ffa5c233",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -1,3 +1,11 @@\n+2021-06-29  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* frame.h (frame_debug_printf): New.\n+\t* frame.c: Use frame_debug_printf throughout when printing frame\n+\tdebug messages.\n+\t* amd64-windows-tdep.c: Likewise.\n+\t* value.c: Likewise.\n+\n 2021-06-29  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* frame.h (frame_debug): Change type to bool."
    },
    {
      "sha": "5442e527653981a49059a295c7e1eb3c7eac9c4f",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 30,
      "deletions": 45,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -756,14 +756,10 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n \t\t\t      (gdb_byte *) &ex_ui, sizeof (ex_ui)) != 0)\n \treturn;\n \n-      if (frame_debug)\n-\tfprintf_unfiltered\n-\t  (gdb_stdlog,\n-\t   \"amd64_windows_frame_decodes_insn: \"\n-\t   \"%s: ver: %02x, plgsz: %02x, cnt: %02x, frame: %02x\\n\",\n-\t   paddress (gdbarch, unwind_info),\n-\t   ex_ui.Version_Flags, ex_ui.SizeOfPrologue,\n-\t   ex_ui.CountOfCodes, ex_ui.FrameRegisterOffset);\n+      frame_debug_printf (\"%s: ver: %02x, plgsz: %02x, cnt: %02x, frame: %02x\",\n+\t\t\t  paddress (gdbarch, unwind_info),\n+\t\t\t  ex_ui.Version_Flags, ex_ui.SizeOfPrologue,\n+\t\t\t  ex_ui.CountOfCodes, ex_ui.FrameRegisterOffset);\n \n       /* Check version.  */\n       if (PEX64_UWI_VERSION (ex_ui.Version_Flags) != 1\n@@ -801,10 +797,9 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n \t  get_frame_register (this_frame, frreg, buf);\n \t  save_addr = extract_unsigned_integer (buf, 8, byte_order);\n \n-\t  if (frame_debug)\n-\t    fprintf_unfiltered (gdb_stdlog, \"   frame_reg=%s, val=%s\\n\",\n-\t\t\t\tgdbarch_register_name (gdbarch, frreg),\n-\t\t\t\tpaddress (gdbarch, save_addr));\n+\t  frame_debug_printf (\"   frame_reg=%s, val=%s\",\n+\t\t\t      gdbarch_register_name (gdbarch, frreg),\n+\t\t\t      paddress (gdbarch, save_addr));\n \t}\n \n       /* Read opcodes.  */\n@@ -835,10 +830,8 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n \t     prologue has been fully executed.  */\n \t  if (cache->pc >= start + p[0] || cache->pc < start)\n \t    {\n-\t      if (frame_debug)\n-\t\tfprintf_unfiltered\n-\t\t  (gdb_stdlog, \"   op #%u: off=0x%02x, insn=0x%02x\\n\",\n-\t\t   (unsigned) (p - insns), p[0], p[1]);\n+\t      frame_debug_printf (\"   op #%u: off=0x%02x, insn=0x%02x\",\n+\t\t\t\t  (unsigned) (p - insns), p[0], p[1]);\n \n \t      /* If there is no frame registers defined, the current value of\n \t\t rsp is used instead.  */\n@@ -912,11 +905,11 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n \t\t}\n \n \t      /* Display address where the register was saved.  */\n-\t      if (frame_debug && reg >= 0)\n-\t\tfprintf_unfiltered\n-\t\t  (gdb_stdlog, \"     [reg %s at %s]\\n\",\n-\t\t   gdbarch_register_name (gdbarch, reg),\n-\t\t   paddress (gdbarch, cache->prev_reg_addr[reg]));\n+\t      if (reg >= 0)\n+\t\tframe_debug_printf (\"     [reg %s at %s]\",\n+\t\t\t\t    gdbarch_register_name (gdbarch, reg),\n+\t\t\t\t    paddress (gdbarch,\n+\t\t\t\t\t      cache->prev_reg_addr[reg]));\n \t    }\n \n \t  /* Adjust with the length of the opcode.  */\n@@ -978,14 +971,11 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n \t  unwind_info =\n \t    extract_unsigned_integer (d.rva_UnwindData, 4, byte_order);\n \n-\t  if (frame_debug)\n-\t    fprintf_unfiltered\n-\t      (gdb_stdlog,\n-\t       \"amd64_windows_frame_decodes_insn (next in chain):\"\n-\t       \" unwind_data=%s, start_rva=%s, end_rva=%s\\n\",\n-\t       paddress (gdbarch, unwind_info),\n-\t       paddress (gdbarch, cache->start_rva),\n-\t       paddress (gdbarch, cache->end_rva));\n+\t  frame_debug_printf (\"next in chain: unwind_data=%s, start_rva=%s, \"\n+\t\t\t      \"end_rva=%s\",\n+\t\t\t      paddress (gdbarch, unwind_info),\n+\t\t\t      paddress (gdbarch, cache->start_rva),\n+\t\t\t      paddress (gdbarch, cache->end_rva));\n \t}\n \n       /* Allow the user to break this loop.  */\n@@ -996,10 +986,9 @@ amd64_windows_frame_decode_insns (struct frame_info *this_frame,\n     cache->prev_rip_addr = cur_sp;\n   cache->prev_sp = cur_sp + 8;\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"   prev_sp: %s, prev_pc @%s\\n\",\n-\t\t\tpaddress (gdbarch, cache->prev_sp),\n-\t\t\tpaddress (gdbarch, cache->prev_rip_addr));\n+  frame_debug_printf (\"   prev_sp: %s, prev_pc @%s\",\n+\t\t      paddress (gdbarch, cache->prev_sp),\n+\t\t      paddress (gdbarch, cache->prev_rip_addr));\n }\n \n /* Find SEH unwind info for PC, returning 0 on success.\n@@ -1073,11 +1062,9 @@ amd64_windows_find_unwind_info (struct gdbarch *gdbarch, CORE_ADDR pc,\n \tbreak;\n     }\n \n-  if (frame_debug)\n-    fprintf_unfiltered\n-      (gdb_stdlog,\n-       \"amd64_windows_find_unwind_data:  image_base=%s, unwind_data=%s\\n\",\n-       paddress (gdbarch, base), paddress (gdbarch, *unwind_info));\n+  frame_debug_printf (\"image_base=%s, unwind_data=%s\",\n+\t\t      paddress (gdbarch, base),\n+\t\t      paddress (gdbarch, *unwind_info));\n \n   return 0;\n }\n@@ -1139,11 +1126,9 @@ amd64_windows_frame_prev_register (struct frame_info *this_frame,\n     amd64_windows_frame_cache (this_frame, this_cache);\n   CORE_ADDR prev;\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"amd64_windows_frame_prev_register %s for sp=%s\\n\",\n-\t\t\tgdbarch_register_name (gdbarch, regnum),\n-\t\t\tpaddress (gdbarch, cache->prev_sp));\n+  frame_debug_printf (\"%s for sp=%s\",\n+\t\t      gdbarch_register_name (gdbarch, regnum),\n+\t\t      paddress (gdbarch, cache->prev_sp));\n \n   if (regnum >= AMD64_XMM0_REGNUM && regnum <= AMD64_XMM0_REGNUM + 15)\n       prev = cache->prev_xmm_addr[regnum - AMD64_XMM0_REGNUM];\n@@ -1160,8 +1145,8 @@ amd64_windows_frame_prev_register (struct frame_info *this_frame,\n   else\n     prev = 0;\n \n-  if (prev && frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"  -> at %s\\n\", paddress (gdbarch, prev));\n+  if (prev != 0)\n+    frame_debug_printf (\"  -> at %s\", paddress (gdbarch, prev));\n \n   if (prev)\n     {"
    },
    {
      "sha": "7b459680313ab223c3e7ea13e2d709914dc6990e",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 112,
      "deletions": 191,
      "changes": 303,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -111,6 +111,9 @@ enum class frame_id_status\n \n struct frame_info\n {\n+  /* Return a string representation of this frame.  */\n+  std::string to_string () const;\n+\n   /* Level of this frame.  The inner-most (youngest) frame is at level\n      0.  As you move towards the outer-most (oldest) frame, the level\n      increases.  This is a cached value.  It could just as easily be\n@@ -414,95 +417,85 @@ frame_id::to_string () const\n   return res;\n }\n \n-static void\n-fprint_frame_type (struct ui_file *file, enum frame_type type)\n+/* Return a string representation of TYPE.  */\n+\n+static const char *\n+frame_type_str (frame_type type)\n {\n   switch (type)\n     {\n     case NORMAL_FRAME:\n-      fprintf_unfiltered (file, \"NORMAL_FRAME\");\n-      return;\n+      return \"NORMAL_FRAME\";\n+\n     case DUMMY_FRAME:\n-      fprintf_unfiltered (file, \"DUMMY_FRAME\");\n-      return;\n+      return \"DUMMY_FRAME\";\n+\n     case INLINE_FRAME:\n-      fprintf_unfiltered (file, \"INLINE_FRAME\");\n-      return;\n+      return \"INLINE_FRAME\";\n+\n     case TAILCALL_FRAME:\n-      fprintf_unfiltered (file, \"TAILCALL_FRAME\");\n-      return;\n+      return \"TAILCALL_FRAME\";\n+\n     case SIGTRAMP_FRAME:\n-      fprintf_unfiltered (file, \"SIGTRAMP_FRAME\");\n-      return;\n+      return \"SIGTRAMP_FRAME\";\n+\n     case ARCH_FRAME:\n-      fprintf_unfiltered (file, \"ARCH_FRAME\");\n-      return;\n+      return \"ARCH_FRAME\";\n+\n     case SENTINEL_FRAME:\n-      fprintf_unfiltered (file, \"SENTINEL_FRAME\");\n-      return;\n+      return \"SENTINEL_FRAME\";\n+\n     default:\n-      fprintf_unfiltered (file, \"<unknown type>\");\n-      return;\n+      return \"<unknown type>\";\n     };\n }\n \n-static void\n-fprint_frame (struct ui_file *file, struct frame_info *fi)\n+ /* See struct frame_info.  */\n+\n+std::string\n+frame_info::to_string () const\n {\n-  if (fi == NULL)\n-    {\n-      fprintf_unfiltered (file, \"<NULL frame>\");\n-      return;\n-    }\n+  const frame_info *fi = this;\n+\n+  std::string res;\n \n-  fprintf_unfiltered (file, \"{\");\n-  fprintf_unfiltered (file, \"level=%d\", fi->level);\n-  fprintf_unfiltered (file, \",\");\n+  res += string_printf (\"{level=%d,\", fi->level);\n \n-  fprintf_unfiltered (file, \"type=\");\n   if (fi->unwind != NULL)\n-    fprint_frame_type (file, fi->unwind->type);\n+    res += string_printf (\"type=%s,\", frame_type_str (fi->unwind->type));\n   else\n-    fprintf_unfiltered (file, \"<unknown>\");\n-  fprintf_unfiltered (file, \",\");\n+    res += \"type=<unknown>,\";\n \n-  fprintf_unfiltered (file, \"unwind=\");\n   if (fi->unwind != NULL)\n-    gdb_print_host_address (fi->unwind, file);\n+    res += string_printf (\"unwind=%p,\", host_address_to_string (fi->unwind));\n   else\n-    fprintf_unfiltered (file, \"<unknown>\");\n-  fprintf_unfiltered (file, \",\");\n+    res += \"unwind=<unknown>,\";\n \n-  fprintf_unfiltered (file, \"pc=\");\n   if (fi->next == NULL || fi->next->prev_pc.status == CC_UNKNOWN)\n-    fprintf_unfiltered (file, \"<unknown>\");\n+    res += \"pc=<unknown>,\";\n   else if (fi->next->prev_pc.status == CC_VALUE)\n-    {\n-      fprintf_unfiltered (file, \"%s\", hex_string (fi->next->prev_pc.value));\n-      if (fi->next->prev_pc.masked)\n-\tfprintf_unfiltered (file, \"[PAC]\");\n-    }\n+    res += string_printf (\"pc=%s%s,\", hex_string (fi->next->prev_pc.value),\n+\t\t\t  fi->next->prev_pc.masked ? \"[PAC]\" : \"\");\n   else if (fi->next->prev_pc.status == CC_NOT_SAVED)\n-    val_print_not_saved (file);\n+    res += \"pc=<not saved>,\";\n   else if (fi->next->prev_pc.status == CC_UNAVAILABLE)\n-    val_print_unavailable (file);\n-  fprintf_unfiltered (file, \",\");\n+    res += \"pc=<unavailable>,\";\n \n-  fprintf_unfiltered (file, \"id=\");\n   if (fi->this_id.p == frame_id_status::NOT_COMPUTED)\n-    fprintf_unfiltered (file, \"<not computed>\");\n+    res += \"id=<not computed>,\";\n   else if (fi->this_id.p == frame_id_status::COMPUTING)\n-    fprintf_unfiltered (file, \"<computing>\");\n+    res += \"id=<computing>,\";\n   else\n-    fprintf_unfiltered (file, \"%s\", fi->this_id.value.to_string ().c_str ());\n-  fprintf_unfiltered (file, \",\");\n+    res += string_printf (\"id=%s,\", fi->this_id.value.to_string ().c_str ());\n \n-  fprintf_unfiltered (file, \"func=\");\n   if (fi->next != NULL && fi->next->prev_func.status == CC_VALUE)\n-    fprintf_unfiltered (file, \"%s\", hex_string (fi->next->prev_func.addr));\n+    res += string_printf (\"func=%s\", hex_string (fi->next->prev_func.addr));\n   else\n-    fprintf_unfiltered (file, \"<unknown>\");\n-  fprintf_unfiltered (file, \"}\");\n+    res += \"func=<unknown>\";\n+\n+  res += \"}\";\n+\n+  return res;\n }\n \n /* Given FRAME, return the enclosing frame as found in real frames read-in from\n@@ -576,9 +569,7 @@ compute_frame_id (struct frame_info *fi)\n       /* Mark this frame's id as \"being computed.  */\n       fi->this_id.p = frame_id_status::COMPUTING;\n \n-      if (frame_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"{ compute_frame_id (fi=%d) \",\n-\t\t\t    fi->level);\n+      frame_debug_printf (\"fi=%d\", fi->level);\n \n       /* Find the unwinder.  */\n       if (fi->unwind == NULL)\n@@ -593,9 +584,7 @@ compute_frame_id (struct frame_info *fi)\n       /* Mark this frame's id as \"computed\".  */\n       fi->this_id.p = frame_id_status::COMPUTED;\n \n-      if (frame_debug)\n-\tfprintf_unfiltered (gdb_stdlog, \"-> %s }\\n\",\n-\t\t\t    fi->this_id.value.to_string ().c_str ());\n+      frame_debug_printf (\"  -> %s\", fi->this_id.value.to_string ().c_str ());\n     }\n   catch (const gdb_exception &ex)\n     {\n@@ -746,9 +735,7 @@ frame_id_p (frame_id l)\n   /* The frame is valid iff it has a valid stack address.  */\n   bool p = l.stack_status != FID_STACK_INVALID;\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"{ frame_id_p (l=%s) -> %d }\\n\",\n-\t\t\tl.to_string ().c_str (), p);\n+  frame_debug_printf (\"l=%s -> %d\", l.to_string ().c_str (), p);\n \n   return p;\n }\n@@ -791,9 +778,8 @@ frame_id_eq (frame_id l, frame_id r)\n     /* Frames are equal.  */\n     eq = true;\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"{ frame_id_eq (l=%s,r=%s) -> %d }\\n\",\n-\t\t\tl.to_string ().c_str (), r.to_string ().c_str (), eq);\n+  frame_debug_printf (\"l=%s, r=%s -> %d\",\n+\t\t      l.to_string ().c_str (), r.to_string ().c_str (), eq);\n \n   return eq;\n }\n@@ -869,10 +855,9 @@ frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)\n        different .code and/or .special address).  */\n     inner = gdbarch_inner_than (gdbarch, l.stack_addr, r.stack_addr);\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"{ frame_id_inner (l=%s,r=%s) -> %d }\\n\",\n-\t\t\tl.to_string ().c_str (), r.to_string ().c_str (),\n-\t\t\tinner);\n+  frame_debug_printf (\"is l=%s inner than r=%s? %d\",\n+\t\t      l.to_string ().c_str (), r.to_string ().c_str (),\n+\t\t      inner);\n \n   return inner;\n }\n@@ -967,21 +952,15 @@ frame_unwind_pc (struct frame_info *this_frame)\n \t    {\n \t      this_frame->prev_pc.status = CC_UNAVAILABLE;\n \n-\t      if (frame_debug)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"{ frame_unwind_pc (this_frame=%d)\"\n-\t\t\t\t    \" -> <unavailable> }\\n\",\n-\t\t\t\t    this_frame->level);\n+\t      frame_debug_printf (\"this_frame=%d -> <unavailable>\",\n+\t\t\t\t  this_frame->level);\n \t    }\n \t  else if (ex.error == OPTIMIZED_OUT_ERROR)\n \t    {\n \t      this_frame->prev_pc.status = CC_NOT_SAVED;\n \n-\t      if (frame_debug)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"{ frame_unwind_pc (this_frame=%d)\"\n-\t\t\t\t    \" -> <not saved> }\\n\",\n-\t\t\t\t    this_frame->level);\n+\t      frame_debug_printf (\"this_frame=%d -> <not saved>\",\n+\t\t\t\t  this_frame->level);\n \t    }\n \t  else\n \t    throw;\n@@ -991,12 +970,10 @@ frame_unwind_pc (struct frame_info *this_frame)\n \t{\n \t  this_frame->prev_pc.value = pc;\n \t  this_frame->prev_pc.status = CC_VALUE;\n-\t  if (frame_debug)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"{ frame_unwind_pc (this_frame=%d) \"\n-\t\t\t\t\"-> %s }\\n\",\n-\t\t\t\tthis_frame->level,\n-\t\t\t\thex_string (this_frame->prev_pc.value));\n+\n+\t  frame_debug_printf (\"this_frame=%d -> %s\",\n+\t\t\t      this_frame->level,\n+\t\t\t      hex_string (this_frame->prev_pc.value));\n \t}\n     }\n \n@@ -1039,21 +1016,18 @@ get_frame_func_if_available (frame_info *this_frame, CORE_ADDR *pc)\n       if (!get_frame_address_in_block_if_available (this_frame, &addr_in_block))\n \t{\n \t  next_frame->prev_func.status = CC_UNAVAILABLE;\n-\t  if (frame_debug)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"{ get_frame_func (this_frame=%d)\"\n-\t\t\t\t\" -> unavailable }\\n\",\n-\t\t\t\tthis_frame->level);\n+\n+\t  frame_debug_printf (\"this_frame=%d -> unavailable\",\n+\t\t\t      this_frame->level);\n \t}\n       else\n \t{\n \t  next_frame->prev_func.status = CC_VALUE;\n \t  next_frame->prev_func.addr = get_pc_function_start (addr_in_block);\n-\t  if (frame_debug)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"{ get_frame_func (this_frame=%d) -> %s }\\n\",\n-\t\t\t\tthis_frame->level,\n-\t\t\t\thex_string (next_frame->prev_func.addr));\n+\n+\t  frame_debug_printf (\"this_frame=%d -> %s\",\n+\t\t\t      this_frame->level,\n+\t\t\t      hex_string (next_frame->prev_func.addr));\n \t}\n     }\n \n@@ -1247,14 +1221,9 @@ frame_unwind_register_value (frame_info *next_frame, int regnum)\n   gdb_assert (next_frame != NULL);\n   gdbarch = frame_unwind_arch (next_frame);\n \n-  if (frame_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"{ frame_unwind_register_value \"\n-\t\t\t  \"(frame=%d,regnum=%d(%s),...) \",\n-\t\t\t  next_frame->level, regnum,\n-\t\t\t  user_reg_map_regnum_to_name (gdbarch, regnum));\n-    }\n+  frame_debug_printf (\"frame=%d, regnum=%d(%s)\",\n+\t\t      next_frame->level, regnum,\n+\t\t      user_reg_map_regnum_to_name (gdbarch, regnum));\n \n   /* Find the unwinder.  */\n   if (next_frame->unwind == NULL)\n@@ -1267,40 +1236,42 @@ frame_unwind_register_value (frame_info *next_frame, int regnum)\n \n   if (frame_debug)\n     {\n-      fprintf_unfiltered (gdb_stdlog, \"->\");\n+      string_file debug_file;\n+\n+      fprintf_unfiltered (&debug_file, \"  ->\");\n       if (value_optimized_out (value))\n \t{\n-\t  fprintf_unfiltered (gdb_stdlog, \" \");\n-\t  val_print_not_saved (gdb_stdlog);\n+\t  fprintf_unfiltered (&debug_file, \" \");\n+\t  val_print_not_saved (&debug_file);\n \t}\n       else\n \t{\n \t  if (VALUE_LVAL (value) == lval_register)\n-\t    fprintf_unfiltered (gdb_stdlog, \" register=%d\",\n+\t    fprintf_unfiltered (&debug_file, \" register=%d\",\n \t\t\t\tVALUE_REGNUM (value));\n \t  else if (VALUE_LVAL (value) == lval_memory)\n-\t    fprintf_unfiltered (gdb_stdlog, \" address=%s\",\n+\t    fprintf_unfiltered (&debug_file, \" address=%s\",\n \t\t\t\tpaddress (gdbarch,\n \t\t\t\t\t  value_address (value)));\n \t  else\n-\t    fprintf_unfiltered (gdb_stdlog, \" computed\");\n+\t    fprintf_unfiltered (&debug_file, \" computed\");\n \n \t  if (value_lazy (value))\n-\t    fprintf_unfiltered (gdb_stdlog, \" lazy\");\n+\t    fprintf_unfiltered (&debug_file, \" lazy\");\n \t  else\n \t    {\n \t      int i;\n \t      const gdb_byte *buf = value_contents (value);\n \n-\t      fprintf_unfiltered (gdb_stdlog, \" bytes=\");\n-\t      fprintf_unfiltered (gdb_stdlog, \"[\");\n+\t      fprintf_unfiltered (&debug_file, \" bytes=\");\n+\t      fprintf_unfiltered (&debug_file, \"[\");\n \t      for (i = 0; i < register_size (gdbarch, regnum); i++)\n-\t\tfprintf_unfiltered (gdb_stdlog, \"%02x\", buf[i]);\n-\t      fprintf_unfiltered (gdb_stdlog, \"]\");\n+\t\tfprintf_unfiltered (&debug_file, \"%02x\", buf[i]);\n+\t      fprintf_unfiltered (&debug_file, \"]\");\n \t    }\n \t}\n \n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n+      frame_debug_printf (\"%s\", debug_file.c_str ());\n     }\n \n   return value;\n@@ -1610,12 +1581,9 @@ create_sentinel_frame (struct program_space *pspace, struct regcache *regcache)\n   /* The sentinel frame has a special ID.  */\n   frame->this_id.p = frame_id_status::COMPUTED;\n   frame->this_id.value = sentinel_frame_id;\n-  if (frame_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog, \"{ create_sentinel_frame (...) -> \");\n-      fprint_frame (gdb_stdlog, frame);\n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n-    }\n+\n+  frame_debug_printf (\"  -> %s\", frame->to_string ().c_str ());\n+\n   return frame;\n }\n \n@@ -1939,12 +1907,7 @@ create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n {\n   struct frame_info *fi;\n \n-  if (frame_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"{ create_new_frame (addr=%s, pc=%s) \",\n-\t\t\t  hex_string (addr), hex_string (pc));\n-    }\n+  frame_debug_printf (\"addr=%s, pc=%s\", hex_string (addr), hex_string (pc));\n \n   fi = FRAME_OBSTACK_ZALLOC (struct frame_info);\n \n@@ -1969,12 +1932,7 @@ create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n   fi->this_id.p = frame_id_status::COMPUTED;\n   fi->this_id.value = frame_id_build (addr, pc);\n \n-  if (frame_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-      fprint_frame (gdb_stdlog, fi);\n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n-    }\n+  frame_debug_printf (\"  -> %s\", fi->to_string ().c_str ());\n \n   return fi;\n }\n@@ -2047,8 +2005,8 @@ reinit_frame_cache (void)\n   sentinel_frame = NULL;\t\t/* Invalidate cache */\n   select_frame (NULL);\n   frame_stash_invalidate ();\n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"{ reinit_frame_cache () }\\n\");\n+\n+  frame_debug_printf (\"generation=%d\", frame_cache_generation);\n }\n \n /* Find where a register is saved (in memory or another register).\n@@ -2116,12 +2074,8 @@ get_prev_frame_if_no_cycle (struct frame_info *this_frame)\n \t{\n \t  /* Another frame with the same id was already in the stash.  We just\n \t     detected a cycle.  */\n-\t  if (frame_debug)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-\t      fprint_frame (gdb_stdlog, NULL);\n-\t      fprintf_unfiltered (gdb_stdlog, \" // this frame has same ID }\\n\");\n-\t    }\n+\t  frame_debug_printf (\"  -> nullptr // this frame has same ID\");\n+\n \t  this_frame->stop_reason = UNWIND_SAME_ID;\n \t  /* Unlink.  */\n \t  prev_frame->next = NULL;\n@@ -2157,23 +2111,17 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n \n   if (frame_debug)\n     {\n-      fprintf_unfiltered (gdb_stdlog, \"{ get_prev_frame_always (this_frame=\");\n       if (this_frame != NULL)\n-\tfprintf_unfiltered (gdb_stdlog, \"%d\", this_frame->level);\n+\tframe_debug_printf (\"this_frame=%d\", this_frame->level);\n       else\n-\tfprintf_unfiltered (gdb_stdlog, \"<NULL>\");\n-      fprintf_unfiltered (gdb_stdlog, \") \");\n+\tframe_debug_printf (\"this_frame=nullptr\");\n     }\n \n   /* Only try to do the unwind once.  */\n   if (this_frame->prev_p)\n     {\n-      if (frame_debug)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog, \"-> \");\n-\t  fprint_frame (gdb_stdlog, this_frame->prev);\n-\t  fprintf_unfiltered (gdb_stdlog, \" // cached \\n\");\n-\t}\n+      frame_debug_printf (\"  -> %s // cached\",\n+\t\t\t  this_frame->prev->to_string ().c_str ());\n       return this_frame->prev;\n     }\n \n@@ -2220,15 +2168,9 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n \n   if (this_frame->stop_reason != UNWIND_NO_REASON)\n     {\n-      if (frame_debug)\n-\t{\n-\t  enum unwind_stop_reason reason = this_frame->stop_reason;\n-\n-\t  fprintf_unfiltered (gdb_stdlog, \"-> \");\n-\t  fprint_frame (gdb_stdlog, NULL);\n-\t  fprintf_unfiltered (gdb_stdlog, \" // %s }\\n\",\n-\t\t\t      frame_stop_reason_symbol_string (reason));\n-\t}\n+      frame_debug_printf\n+\t(\"  -> nullptr // %s\",\n+\t frame_stop_reason_symbol_string (this_frame->stop_reason));\n       return NULL;\n     }\n \n@@ -2253,13 +2195,7 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n \tmorestack_name = morestack_msym->linkage_name ();\n       if (!morestack_name || strcmp (morestack_name, \"__morestack\") != 0)\n \t{\n-\t  if (frame_debug)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-\t      fprint_frame (gdb_stdlog, NULL);\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \" // this frame ID is inner }\\n\");\n-\t    }\n+\t  frame_debug_printf (\"  -> nullptr // this frame ID is inner\");\n \t  this_frame->stop_reason = UNWIND_INNER_ID;\n \t  return NULL;\n \t}\n@@ -2299,13 +2235,7 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n       if ((lval == lval_memory && lval == nlval && addr == naddr)\n \t  || (lval == lval_register && lval == nlval && realnum == nrealnum))\n \t{\n-\t  if (frame_debug)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-\t      fprint_frame (gdb_stdlog, NULL);\n-\t      fprintf_unfiltered (gdb_stdlog, \" // no saved PC }\\n\");\n-\t    }\n-\n+\t  frame_debug_printf (\"  -> nullptr // no saved PC\");\n \t  this_frame->stop_reason = UNWIND_NO_SAVED_PC;\n \t  this_frame->prev = NULL;\n \t  return NULL;\n@@ -2407,12 +2337,7 @@ get_prev_frame_raw (struct frame_info *this_frame)\n   this_frame->prev = prev_frame;\n   prev_frame->next = this_frame;\n \n-  if (frame_debug)\n-    {\n-      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-      fprint_frame (gdb_stdlog, prev_frame);\n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n-    }\n+  frame_debug_printf (\"  -> %s\", prev_frame->to_string ().c_str ());\n \n   return prev_frame;\n }\n@@ -2425,12 +2350,10 @@ frame_debug_got_null_frame (struct frame_info *this_frame,\n {\n   if (frame_debug)\n     {\n-      fprintf_unfiltered (gdb_stdlog, \"{ get_prev_frame (this_frame=\");\n       if (this_frame != NULL)\n-\tfprintf_unfiltered (gdb_stdlog, \"%d\", this_frame->level);\n+\tframe_debug_printf (\"this_frame=%d -> %s\", this_frame->level, reason);\n       else\n-\tfprintf_unfiltered (gdb_stdlog, \"<NULL>\");\n-      fprintf_unfiltered (gdb_stdlog, \") -> // %s}\\n\", reason);\n+\tframe_debug_printf (\"this_frame=nullptr -> %s\", reason);\n     }\n }\n \n@@ -2944,11 +2867,9 @@ frame_unwind_arch (struct frame_info *next_frame)\n \n       next_frame->prev_arch.arch = arch;\n       next_frame->prev_arch.p = true;\n-      if (frame_debug)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"{ frame_unwind_arch (next_frame=%d) -> %s }\\n\",\n-\t\t\t    next_frame->level,\n-\t\t\t    gdbarch_bfd_arch_info (arch)->printable_name);\n+      frame_debug_printf (\"next_frame=%d -> %s\",\n+\t\t\t  next_frame->level,\n+\t\t\t  gdbarch_bfd_arch_info (arch)->printable_name);\n     }\n \n   return next_frame->prev_arch.arch;"
    },
    {
      "sha": "f8314ad66ceb7ead2f0de1f4a71e574c9a15687f",
      "filename": "gdb/frame.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.h?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -216,6 +216,11 @@ extern const struct frame_id outer_frame_id;\n \n extern bool frame_debug;\n \n+/* Print a \"frame\" debug statement.  */\n+\n+#define frame_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (frame_debug, \"frame\", fmt, ##__VA_ARGS__)\n+\n /* Construct a frame ID.  The first parameter is the frame's constant\n    stack address (typically the outer-bound), and the second the\n    frame's constant code address (typically the entry point)."
    },
    {
      "sha": "38d8bbccd6ccf519a1027a9fe1c295d2cf114e8f",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -1,3 +1,7 @@\n+2021-06-29  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* gdb.dwarf2/dw2-reg-undefined.exp: Update regexp.\n+\n 2021-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.base/info_sources_2-header.h: New file."
    },
    {
      "sha": "2473a41a0de080359950fbc1dad1892f84e03a4b",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.exp",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-reg-undefined.exp?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -78,7 +78,10 @@ for {set f 0} {$f < 3} {incr f} {\n # Test that the debug log statement in frame_unwind_register_value produces\n # \"not saved\" and not \"optimized out\".\n gdb_test \"set debug frame 1\"\n-gdb_test {print $rax} {frame_unwind_register_value[^\\r\\n]+rax[^\\r\\n]+not saved.*}\n+gdb_test {print $rax} [multi_line \\\n+\t\t\t{\\[frame\\] frame_unwind_register_value: frame=0, regnum=0\\(rax\\)} \\\n+\t\t\t{\\[frame\\] frame_unwind_register_value:   -> <not saved>} \\\n+\t\t\t{.*}]\n gdb_test \"set debug frame 0\"\n \n # Test that history values show \"not saved\" and not \"optimized out\"."
    },
    {
      "sha": "6a07495d32bcbb6035f8c1200f39237b31a45e9e",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a05a883fbaba69d0f80806e46a9457727fcbe74c/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=a05a883fbaba69d0f80806e46a9457727fcbe74c",
      "patch": "@@ -3956,41 +3956,41 @@ value_fetch_lazy_register (struct value *val)\n       regnum = VALUE_REGNUM (val);\n       gdbarch = get_frame_arch (frame);\n \n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"{ value_fetch_lazy \"\n-\t\t\t  \"(frame=%d,regnum=%d(%s),...) \",\n+      string_file debug_file;\n+      fprintf_unfiltered (&debug_file,\n+\t\t\t  \"(frame=%d, regnum=%d(%s), ...) \",\n \t\t\t  frame_relative_level (frame), regnum,\n \t\t\t  user_reg_map_regnum_to_name (gdbarch, regnum));\n \n-      fprintf_unfiltered (gdb_stdlog, \"->\");\n+      fprintf_unfiltered (&debug_file, \"->\");\n       if (value_optimized_out (new_val))\n \t{\n-\t  fprintf_unfiltered (gdb_stdlog, \" \");\n-\t  val_print_optimized_out (new_val, gdb_stdlog);\n+\t  fprintf_unfiltered (&debug_file, \" \");\n+\t  val_print_optimized_out (new_val, &debug_file);\n \t}\n       else\n \t{\n \t  int i;\n \t  const gdb_byte *buf = value_contents (new_val);\n \n \t  if (VALUE_LVAL (new_val) == lval_register)\n-\t    fprintf_unfiltered (gdb_stdlog, \" register=%d\",\n+\t    fprintf_unfiltered (&debug_file, \" register=%d\",\n \t\t\t\tVALUE_REGNUM (new_val));\n \t  else if (VALUE_LVAL (new_val) == lval_memory)\n-\t    fprintf_unfiltered (gdb_stdlog, \" address=%s\",\n+\t    fprintf_unfiltered (&debug_file, \" address=%s\",\n \t\t\t\tpaddress (gdbarch,\n \t\t\t\t\t  value_address (new_val)));\n \t  else\n-\t    fprintf_unfiltered (gdb_stdlog, \" computed\");\n+\t    fprintf_unfiltered (&debug_file, \" computed\");\n \n-\t  fprintf_unfiltered (gdb_stdlog, \" bytes=\");\n-\t  fprintf_unfiltered (gdb_stdlog, \"[\");\n+\t  fprintf_unfiltered (&debug_file, \" bytes=\");\n+\t  fprintf_unfiltered (&debug_file, \"[\");\n \t  for (i = 0; i < register_size (gdbarch, regnum); i++)\n-\t    fprintf_unfiltered (gdb_stdlog, \"%02x\", buf[i]);\n-\t  fprintf_unfiltered (gdb_stdlog, \"]\");\n+\t    fprintf_unfiltered (&debug_file, \"%02x\", buf[i]);\n+\t  fprintf_unfiltered (&debug_file, \"]\");\n \t}\n \n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n+      frame_debug_printf (\"%s\", debug_file.c_str ());\n     }\n \n   /* Dispose of the intermediate values.  This prevents"
    }
  ]
}