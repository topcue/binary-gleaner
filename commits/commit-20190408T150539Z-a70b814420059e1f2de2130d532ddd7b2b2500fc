{
  "sha": "a70b814420059e1f2de2130d532ddd7b2b2500fc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTcwYjgxNDQyMDA1OWUxZjJkZTIxMzBkNTMyZGRkN2IyYjI1MDBmYw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-03T22:02:42Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-08T15:05:39Z"
    },
    "message": "Rewrite TRY/CATCH\n\nThis rewrites gdb's TRY/CATCH to plain C++ try/catch.  The patch was\nlargely written by script, though one change (to a comment in\ncommon-exceptions.h) was reverted by hand.\n\ngdb/ChangeLog\n2019-04-08  Tom Tromey  <tom@tromey.com>\n\n\t* xml-support.c: Use C++ exception handling.\n\t* x86-linux-nat.c: Use C++ exception handling.\n\t* windows-nat.c: Use C++ exception handling.\n\t* varobj.c: Use C++ exception handling.\n\t* value.c: Use C++ exception handling.\n\t* valprint.c: Use C++ exception handling.\n\t* valops.c: Use C++ exception handling.\n\t* unittests/parse-connection-spec-selftests.c: Use C++ exception\n\thandling.\n\t* unittests/cli-utils-selftests.c: Use C++ exception handling.\n\t* typeprint.c: Use C++ exception handling.\n\t* tui/tui.c: Use C++ exception handling.\n\t* tracefile-tfile.c: Use C++ exception handling.\n\t* top.c: Use C++ exception handling.\n\t* thread.c: Use C++ exception handling.\n\t* target.c: Use C++ exception handling.\n\t* symmisc.c: Use C++ exception handling.\n\t* symfile-mem.c: Use C++ exception handling.\n\t* stack.c: Use C++ exception handling.\n\t* sparc64-linux-tdep.c: Use C++ exception handling.\n\t* solib.c: Use C++ exception handling.\n\t* solib-svr4.c: Use C++ exception handling.\n\t* solib-spu.c: Use C++ exception handling.\n\t* solib-frv.c: Use C++ exception handling.\n\t* solib-dsbt.c: Use C++ exception handling.\n\t* selftest-arch.c: Use C++ exception handling.\n\t* s390-tdep.c: Use C++ exception handling.\n\t* rust-lang.c: Use C++ exception handling.\n\t* rust-exp.y: Use C++ exception handling.\n\t* rs6000-tdep.c: Use C++ exception handling.\n\t* rs6000-aix-tdep.c: Use C++ exception handling.\n\t* riscv-tdep.c: Use C++ exception handling.\n\t* remote.c: Use C++ exception handling.\n\t* remote-fileio.c: Use C++ exception handling.\n\t* record-full.c: Use C++ exception handling.\n\t* record-btrace.c: Use C++ exception handling.\n\t* python/python.c: Use C++ exception handling.\n\t* python/py-value.c: Use C++ exception handling.\n\t* python/py-utils.c: Use C++ exception handling.\n\t* python/py-unwind.c: Use C++ exception handling.\n\t* python/py-type.c: Use C++ exception handling.\n\t* python/py-symbol.c: Use C++ exception handling.\n\t* python/py-record.c: Use C++ exception handling.\n\t* python/py-record-btrace.c: Use C++ exception handling.\n\t* python/py-progspace.c: Use C++ exception handling.\n\t* python/py-prettyprint.c: Use C++ exception handling.\n\t* python/py-param.c: Use C++ exception handling.\n\t* python/py-objfile.c: Use C++ exception handling.\n\t* python/py-linetable.c: Use C++ exception handling.\n\t* python/py-lazy-string.c: Use C++ exception handling.\n\t* python/py-infthread.c: Use C++ exception handling.\n\t* python/py-inferior.c: Use C++ exception handling.\n\t* python/py-gdb-readline.c: Use C++ exception handling.\n\t* python/py-framefilter.c: Use C++ exception handling.\n\t* python/py-frame.c: Use C++ exception handling.\n\t* python/py-finishbreakpoint.c: Use C++ exception handling.\n\t* python/py-cmd.c: Use C++ exception handling.\n\t* python/py-breakpoint.c: Use C++ exception handling.\n\t* python/py-arch.c: Use C++ exception handling.\n\t* printcmd.c: Use C++ exception handling.\n\t* ppc-linux-tdep.c: Use C++ exception handling.\n\t* parse.c: Use C++ exception handling.\n\t* p-valprint.c: Use C++ exception handling.\n\t* objc-lang.c: Use C++ exception handling.\n\t* mi/mi-main.c: Use C++ exception handling.\n\t* mi/mi-interp.c: Use C++ exception handling.\n\t* mi/mi-cmd-stack.c: Use C++ exception handling.\n\t* mi/mi-cmd-break.c: Use C++ exception handling.\n\t* main.c: Use C++ exception handling.\n\t* linux-thread-db.c: Use C++ exception handling.\n\t* linux-tdep.c: Use C++ exception handling.\n\t* linux-nat.c: Use C++ exception handling.\n\t* linux-fork.c: Use C++ exception handling.\n\t* linespec.c: Use C++ exception handling.\n\t* language.c: Use C++ exception handling.\n\t* jit.c: Use C++ exception handling.\n\t* infrun.c: Use C++ exception handling.\n\t* infcmd.c: Use C++ exception handling.\n\t* infcall.c: Use C++ exception handling.\n\t* inf-loop.c: Use C++ exception handling.\n\t* i386-tdep.c: Use C++ exception handling.\n\t* i386-linux-tdep.c: Use C++ exception handling.\n\t* guile/scm-value.c: Use C++ exception handling.\n\t* guile/scm-type.c: Use C++ exception handling.\n\t* guile/scm-symtab.c: Use C++ exception handling.\n\t* guile/scm-symbol.c: Use C++ exception handling.\n\t* guile/scm-pretty-print.c: Use C++ exception handling.\n\t* guile/scm-ports.c: Use C++ exception handling.\n\t* guile/scm-param.c: Use C++ exception handling.\n\t* guile/scm-math.c: Use C++ exception handling.\n\t* guile/scm-lazy-string.c: Use C++ exception handling.\n\t* guile/scm-frame.c: Use C++ exception handling.\n\t* guile/scm-disasm.c: Use C++ exception handling.\n\t* guile/scm-cmd.c: Use C++ exception handling.\n\t* guile/scm-breakpoint.c: Use C++ exception handling.\n\t* guile/scm-block.c: Use C++ exception handling.\n\t* guile/guile-internal.h: Use C++ exception handling.\n\t* gnu-v3-abi.c: Use C++ exception handling.\n\t* gdbtypes.c: Use C++ exception handling.\n\t* frame.c: Use C++ exception handling.\n\t* frame-unwind.c: Use C++ exception handling.\n\t* fbsd-tdep.c: Use C++ exception handling.\n\t* f-valprint.c: Use C++ exception handling.\n\t* exec.c: Use C++ exception handling.\n\t* event-top.c: Use C++ exception handling.\n\t* event-loop.c: Use C++ exception handling.\n\t* eval.c: Use C++ exception handling.\n\t* dwarf2read.c: Use C++ exception handling.\n\t* dwarf2loc.c: Use C++ exception handling.\n\t* dwarf2-frame.c: Use C++ exception handling.\n\t* dwarf2-frame-tailcall.c: Use C++ exception handling.\n\t* dwarf-index-write.c: Use C++ exception handling.\n\t* dwarf-index-cache.c: Use C++ exception handling.\n\t* dtrace-probe.c: Use C++ exception handling.\n\t* disasm-selftests.c: Use C++ exception handling.\n\t* darwin-nat.c: Use C++ exception handling.\n\t* cp-valprint.c: Use C++ exception handling.\n\t* cp-support.c: Use C++ exception handling.\n\t* cp-abi.c: Use C++ exception handling.\n\t* corelow.c: Use C++ exception handling.\n\t* completer.c: Use C++ exception handling.\n\t* compile/compile-object-run.c: Use C++ exception handling.\n\t* compile/compile-object-load.c: Use C++ exception handling.\n\t* compile/compile-cplus-symbols.c: Use C++ exception handling.\n\t* compile/compile-c-symbols.c: Use C++ exception handling.\n\t* common/selftest.c: Use C++ exception handling.\n\t* common/new-op.c: Use C++ exception handling.\n\t* cli/cli-script.c: Use C++ exception handling.\n\t* cli/cli-interp.c: Use C++ exception handling.\n\t* cli/cli-cmds.c: Use C++ exception handling.\n\t* c-varobj.c: Use C++ exception handling.\n\t* btrace.c: Use C++ exception handling.\n\t* breakpoint.c: Use C++ exception handling.\n\t* break-catch-throw.c: Use C++ exception handling.\n\t* arch-utils.c: Use C++ exception handling.\n\t* amd64-tdep.c: Use C++ exception handling.\n\t* ada-valprint.c: Use C++ exception handling.\n\t* ada-typeprint.c: Use C++ exception handling.\n\t* ada-lang.c: Use C++ exception handling.\n\t* aarch64-tdep.c: Use C++ exception handling.\n\ngdb/gdbserver/ChangeLog\n2019-04-08  Tom Tromey  <tom@tromey.com>\n\n\t* server.c: Use C++ exception handling.\n\t* linux-low.c: Use C++ exception handling.\n\t* gdbreplay.c: Use C++ exception handling.",
    "tree": {
      "sha": "ce50952af2443675e67a60508a10c8fd5ab0715c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ce50952af2443675e67a60508a10c8fd5ab0715c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a70b814420059e1f2de2130d532ddd7b2b2500fc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a70b814420059e1f2de2130d532ddd7b2b2500fc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a70b814420059e1f2de2130d532ddd7b2b2500fc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a70b814420059e1f2de2130d532ddd7b2b2500fc/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3d6e9d2336c9ffcedb10f89631981a23dd518e8e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3d6e9d2336c9ffcedb10f89631981a23dd518e8e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3d6e9d2336c9ffcedb10f89631981a23dd518e8e"
    }
  ],
  "stats": {
    "total": 2359,
    "additions": 1033,
    "deletions": 1326
  },
  "files": [
    {
      "sha": "19ae18a228adc37791cfcf9478a6a03a1695269f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 143,
      "deletions": 0,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1,3 +1,146 @@\n+2019-04-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* xml-support.c: Use C++ exception handling.\n+\t* x86-linux-nat.c: Use C++ exception handling.\n+\t* windows-nat.c: Use C++ exception handling.\n+\t* varobj.c: Use C++ exception handling.\n+\t* value.c: Use C++ exception handling.\n+\t* valprint.c: Use C++ exception handling.\n+\t* valops.c: Use C++ exception handling.\n+\t* unittests/parse-connection-spec-selftests.c: Use C++ exception\n+\thandling.\n+\t* unittests/cli-utils-selftests.c: Use C++ exception handling.\n+\t* typeprint.c: Use C++ exception handling.\n+\t* tui/tui.c: Use C++ exception handling.\n+\t* tracefile-tfile.c: Use C++ exception handling.\n+\t* top.c: Use C++ exception handling.\n+\t* thread.c: Use C++ exception handling.\n+\t* target.c: Use C++ exception handling.\n+\t* symmisc.c: Use C++ exception handling.\n+\t* symfile-mem.c: Use C++ exception handling.\n+\t* stack.c: Use C++ exception handling.\n+\t* sparc64-linux-tdep.c: Use C++ exception handling.\n+\t* solib.c: Use C++ exception handling.\n+\t* solib-svr4.c: Use C++ exception handling.\n+\t* solib-spu.c: Use C++ exception handling.\n+\t* solib-frv.c: Use C++ exception handling.\n+\t* solib-dsbt.c: Use C++ exception handling.\n+\t* selftest-arch.c: Use C++ exception handling.\n+\t* s390-tdep.c: Use C++ exception handling.\n+\t* rust-lang.c: Use C++ exception handling.\n+\t* rust-exp.y: Use C++ exception handling.\n+\t* rs6000-tdep.c: Use C++ exception handling.\n+\t* rs6000-aix-tdep.c: Use C++ exception handling.\n+\t* riscv-tdep.c: Use C++ exception handling.\n+\t* remote.c: Use C++ exception handling.\n+\t* remote-fileio.c: Use C++ exception handling.\n+\t* record-full.c: Use C++ exception handling.\n+\t* record-btrace.c: Use C++ exception handling.\n+\t* python/python.c: Use C++ exception handling.\n+\t* python/py-value.c: Use C++ exception handling.\n+\t* python/py-utils.c: Use C++ exception handling.\n+\t* python/py-unwind.c: Use C++ exception handling.\n+\t* python/py-type.c: Use C++ exception handling.\n+\t* python/py-symbol.c: Use C++ exception handling.\n+\t* python/py-record.c: Use C++ exception handling.\n+\t* python/py-record-btrace.c: Use C++ exception handling.\n+\t* python/py-progspace.c: Use C++ exception handling.\n+\t* python/py-prettyprint.c: Use C++ exception handling.\n+\t* python/py-param.c: Use C++ exception handling.\n+\t* python/py-objfile.c: Use C++ exception handling.\n+\t* python/py-linetable.c: Use C++ exception handling.\n+\t* python/py-lazy-string.c: Use C++ exception handling.\n+\t* python/py-infthread.c: Use C++ exception handling.\n+\t* python/py-inferior.c: Use C++ exception handling.\n+\t* python/py-gdb-readline.c: Use C++ exception handling.\n+\t* python/py-framefilter.c: Use C++ exception handling.\n+\t* python/py-frame.c: Use C++ exception handling.\n+\t* python/py-finishbreakpoint.c: Use C++ exception handling.\n+\t* python/py-cmd.c: Use C++ exception handling.\n+\t* python/py-breakpoint.c: Use C++ exception handling.\n+\t* python/py-arch.c: Use C++ exception handling.\n+\t* printcmd.c: Use C++ exception handling.\n+\t* ppc-linux-tdep.c: Use C++ exception handling.\n+\t* parse.c: Use C++ exception handling.\n+\t* p-valprint.c: Use C++ exception handling.\n+\t* objc-lang.c: Use C++ exception handling.\n+\t* mi/mi-main.c: Use C++ exception handling.\n+\t* mi/mi-interp.c: Use C++ exception handling.\n+\t* mi/mi-cmd-stack.c: Use C++ exception handling.\n+\t* mi/mi-cmd-break.c: Use C++ exception handling.\n+\t* main.c: Use C++ exception handling.\n+\t* linux-thread-db.c: Use C++ exception handling.\n+\t* linux-tdep.c: Use C++ exception handling.\n+\t* linux-nat.c: Use C++ exception handling.\n+\t* linux-fork.c: Use C++ exception handling.\n+\t* linespec.c: Use C++ exception handling.\n+\t* language.c: Use C++ exception handling.\n+\t* jit.c: Use C++ exception handling.\n+\t* infrun.c: Use C++ exception handling.\n+\t* infcmd.c: Use C++ exception handling.\n+\t* infcall.c: Use C++ exception handling.\n+\t* inf-loop.c: Use C++ exception handling.\n+\t* i386-tdep.c: Use C++ exception handling.\n+\t* i386-linux-tdep.c: Use C++ exception handling.\n+\t* guile/scm-value.c: Use C++ exception handling.\n+\t* guile/scm-type.c: Use C++ exception handling.\n+\t* guile/scm-symtab.c: Use C++ exception handling.\n+\t* guile/scm-symbol.c: Use C++ exception handling.\n+\t* guile/scm-pretty-print.c: Use C++ exception handling.\n+\t* guile/scm-ports.c: Use C++ exception handling.\n+\t* guile/scm-param.c: Use C++ exception handling.\n+\t* guile/scm-math.c: Use C++ exception handling.\n+\t* guile/scm-lazy-string.c: Use C++ exception handling.\n+\t* guile/scm-frame.c: Use C++ exception handling.\n+\t* guile/scm-disasm.c: Use C++ exception handling.\n+\t* guile/scm-cmd.c: Use C++ exception handling.\n+\t* guile/scm-breakpoint.c: Use C++ exception handling.\n+\t* guile/scm-block.c: Use C++ exception handling.\n+\t* guile/guile-internal.h: Use C++ exception handling.\n+\t* gnu-v3-abi.c: Use C++ exception handling.\n+\t* gdbtypes.c: Use C++ exception handling.\n+\t* frame.c: Use C++ exception handling.\n+\t* frame-unwind.c: Use C++ exception handling.\n+\t* fbsd-tdep.c: Use C++ exception handling.\n+\t* f-valprint.c: Use C++ exception handling.\n+\t* exec.c: Use C++ exception handling.\n+\t* event-top.c: Use C++ exception handling.\n+\t* event-loop.c: Use C++ exception handling.\n+\t* eval.c: Use C++ exception handling.\n+\t* dwarf2read.c: Use C++ exception handling.\n+\t* dwarf2loc.c: Use C++ exception handling.\n+\t* dwarf2-frame.c: Use C++ exception handling.\n+\t* dwarf2-frame-tailcall.c: Use C++ exception handling.\n+\t* dwarf-index-write.c: Use C++ exception handling.\n+\t* dwarf-index-cache.c: Use C++ exception handling.\n+\t* dtrace-probe.c: Use C++ exception handling.\n+\t* disasm-selftests.c: Use C++ exception handling.\n+\t* darwin-nat.c: Use C++ exception handling.\n+\t* cp-valprint.c: Use C++ exception handling.\n+\t* cp-support.c: Use C++ exception handling.\n+\t* cp-abi.c: Use C++ exception handling.\n+\t* corelow.c: Use C++ exception handling.\n+\t* completer.c: Use C++ exception handling.\n+\t* compile/compile-object-run.c: Use C++ exception handling.\n+\t* compile/compile-object-load.c: Use C++ exception handling.\n+\t* compile/compile-cplus-symbols.c: Use C++ exception handling.\n+\t* compile/compile-c-symbols.c: Use C++ exception handling.\n+\t* common/selftest.c: Use C++ exception handling.\n+\t* common/new-op.c: Use C++ exception handling.\n+\t* cli/cli-script.c: Use C++ exception handling.\n+\t* cli/cli-interp.c: Use C++ exception handling.\n+\t* cli/cli-cmds.c: Use C++ exception handling.\n+\t* c-varobj.c: Use C++ exception handling.\n+\t* btrace.c: Use C++ exception handling.\n+\t* breakpoint.c: Use C++ exception handling.\n+\t* break-catch-throw.c: Use C++ exception handling.\n+\t* arch-utils.c: Use C++ exception handling.\n+\t* amd64-tdep.c: Use C++ exception handling.\n+\t* ada-valprint.c: Use C++ exception handling.\n+\t* ada-typeprint.c: Use C++ exception handling.\n+\t* ada-lang.c: Use C++ exception handling.\n+\t* aarch64-tdep.c: Use C++ exception handling.\n+\n 2019-04-08  Tom Tromey  <tom@tromey.com>\n \n \t* xml-support.c (gdb_xml_parser::parse): Update."
    },
    {
      "sha": "bd04a67247904ca8c9f92d7e566a2fce14019471",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -874,16 +874,15 @@ aarch64_make_prologue_cache (struct frame_info *this_frame, void **this_cache)\n   cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       aarch64_make_prologue_cache_1 (this_frame, cache);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }\n@@ -1006,19 +1005,18 @@ aarch64_make_stub_cache (struct frame_info *this_frame, void **this_cache)\n   cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       cache->prev_sp = get_frame_register_unsigned (this_frame,\n \t\t\t\t\t\t    AARCH64_SP_REGNUM);\n       cache->prev_pc = get_frame_pc (this_frame);\n       cache->available_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }"
    },
    {
      "sha": "4b51ef1939a7dd40d7f80dcd481b4e9e358d1766",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 14,
      "deletions": 21,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -6723,16 +6723,15 @@ ada_tag_value_at_base_address (struct value *obj)\n      see ada_tag_name for more details.  We do not print the error\n      message for the same reason.  */\n \n-  TRY\n+  try\n     {\n       offset_to_top = value_as_long (value_ind (value_ptradd (val, -2)));\n     }\n \n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       return obj;\n     }\n-  END_CATCH\n \n   /* If offset is null, nothing to do.  */\n \n@@ -6869,17 +6868,16 @@ ada_tag_name (struct value *tag)\n      We also do not print the error message either (which often is very\n      low-level (Eg: \"Cannot read memory at 0x[...]\"), but instead let\n      the caller print a more meaningful message if necessary.  */\n-  TRY\n+  try\n     {\n       struct value *tsd = ada_get_tsd_from_tag (tag);\n \n       if (tsd != NULL)\n \tname = ada_tag_name_from_tsd (tsd);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n     }\n-  END_CATCH\n \n   return name;\n }\n@@ -9054,11 +9052,11 @@ ada_to_fixed_type_1 (struct type *type, const gdb_byte *valaddr,\n             LONGEST size;\n \n             xsnprintf (xvz_name, strlen (name) + 7, \"%s___XVZ\", name);\n-\t    TRY\n+\t    try\n \t      {\n \t\txvz_found = get_int_var_value (xvz_name, size);\n \t      }\n-\t    CATCH (except, RETURN_MASK_ERROR)\n+\t    catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t      {\n \t\t/* We found the variable, but somehow failed to read\n \t\t   its value.  Rethrow the same error, but with a little\n@@ -9069,7 +9067,6 @@ ada_to_fixed_type_1 (struct type *type, const gdb_byte *valaddr,\n \t\t\t     _(\"unable to read value of %s (%s)\"),\n \t\t\t     xvz_name, except.what ());\n \t      }\n-\t    END_CATCH\n \n             if (xvz_found && TYPE_LENGTH (fixed_record_type) != size)\n               {\n@@ -12346,15 +12343,14 @@ ada_exception_message (void)\n {\n   gdb::unique_xmalloc_ptr<char> e_msg;\n \n-  TRY\n+  try\n     {\n       e_msg = ada_exception_message_1 ();\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       e_msg.reset (nullptr);\n     }\n-  END_CATCH\n \n   return e_msg;\n }\n@@ -12370,17 +12366,16 @@ ada_exception_name_addr (enum ada_exception_catchpoint_kind ex,\n {\n   CORE_ADDR result = 0;\n \n-  TRY\n+  try\n     {\n       result = ada_exception_name_addr_1 (ex, b);\n     }\n \n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       warning (_(\"failed to get exception name: %s\"), e.what ());\n       return 0;\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -12461,19 +12456,18 @@ create_excep_cond_exprs (struct ada_catchpoint *c,\n \t  const char *s;\n \n \t  s = cond_string.c_str ();\n-\t  TRY\n+\t  try\n \t    {\n \t      exp = parse_exp_1 (&s, bl->address,\n \t\t\t\t block_for_pc (bl->address),\n \t\t\t\t 0);\n \t    }\n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t      warning (_(\"failed to reevaluate internal exception condition \"\n \t\t\t \"for catchpoint %d: %s\"),\n \t\t       c->number, e.what ());\n \t    }\n-\t  END_CATCH\n \t}\n \n       ada_loc->excep_cond_expr = std::move (exp);\n@@ -12531,20 +12525,19 @@ should_stop_exception (const struct bp_location *bl)\n     }\n \n   stop = 1;\n-  TRY\n+  try\n     {\n       struct value *mark;\n \n       mark = value_mark ();\n       stop = value_true (evaluate_expression (ada_loc->excep_cond_expr.get ()));\n       value_free_to_mark (mark);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_fprintf (gdb_stderr, ex,\n \t\t\t _(\"Error in testing exception condition:\\n\"));\n     }\n-  END_CATCH\n \n   return stop;\n }"
    },
    {
      "sha": "8b71524cd12c5669f587e82c33ad59f09c5553b5",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -163,12 +163,12 @@ print_range (struct type *type, struct ui_file *stream,\n \tLONGEST lo = 0, hi = 0; /* init for gcc -Wall */\n \tint got_error = 0;\n \n-\tTRY\n+\ttry\n \t  {\n \t    lo = ada_discrete_type_low_bound (type);\n \t    hi = ada_discrete_type_high_bound (type);\n \t  }\n-\tCATCH (e, RETURN_MASK_ERROR)\n+\tcatch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t  {\n \t    /* This can happen when the range is dynamic.  Sometimes,\n \t       resolving dynamic property values requires us to have\n@@ -178,7 +178,6 @@ print_range (struct type *type, struct ui_file *stream,\n \t    fprintf_filtered (stream, \"<>\");\n \t    got_error = 1;\n \t  }\n-\tEND_CATCH\n \n \tif (!got_error)\n \t  {"
    },
    {
      "sha": "5349e93dd0251a0943a2ff7df41294780dc823ae",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1203,18 +1203,17 @@ ada_val_print (struct type *type,\n \t       struct value *val,\n \t       const struct value_print_options *options)\n {\n-  TRY\n+  try\n     {\n       ada_val_print_1 (type, embedded_offset, address,\n \t\t       stream, recurse, val, options,\n \t\t       current_language);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       fprintf_filtered (stream, _(\"<error reading variable: %s>\"),\n \t\t\texcept.what ());\n     }\n-  END_CATCH\n }\n \n void"
    },
    {
      "sha": "dca3c4fbb4402cd40854d06d14badfb3c955c072",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2581,16 +2581,15 @@ amd64_frame_cache (struct frame_info *this_frame, void **this_cache)\n   cache = amd64_alloc_frame_cache ();\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       amd64_frame_cache_1 (this_frame, cache);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }\n@@ -2699,7 +2698,7 @@ amd64_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n   cache = amd64_alloc_frame_cache ();\n \n-  TRY\n+  try\n     {\n       get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);\n       cache->base = extract_unsigned_integer (buf, 8, byte_order) - 8;\n@@ -2713,12 +2712,11 @@ amd64_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n       cache->base_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   *this_cache = cache;\n   return cache;\n@@ -2876,7 +2874,7 @@ amd64_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n   cache = amd64_alloc_frame_cache ();\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       /* Cache base will be %esp plus cache->sp_offset (-8).  */\n       get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);\n@@ -2894,12 +2892,11 @@ amd64_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n       cache->base_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }"
    },
    {
      "sha": "7623aacc8d13c5e6ea1a8d48dd600930eb651d43",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -969,13 +969,12 @@ gdbarch_skip_prologue_noexcept (gdbarch *gdbarch, CORE_ADDR pc) noexcept\n {\n   CORE_ADDR new_pc = pc;\n \n-  TRY\n+  try\n     {\n       new_pc = gdbarch_skip_prologue (gdbarch, pc);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {}\n-  END_CATCH\n \n   return new_pc;\n }"
    },
    {
      "sha": "f9f468478d80ad3d66c66bcb9dc294395eaf1495",
      "filename": "gdb/break-catch-throw.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/break-catch-throw.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/break-catch-throw.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-throw.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -154,7 +154,7 @@ check_status_exception_catchpoint (struct bpstats *bs)\n   if (self->pattern == NULL)\n     return;\n \n-  TRY\n+  try\n     {\n       struct value *typeinfo_arg;\n       std::string canon;\n@@ -166,11 +166,10 @@ check_status_exception_catchpoint (struct bpstats *bs)\n       if (!canon.empty ())\n \tstd::swap (type_name, canon);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       exception_print (gdb_stderr, e);\n     }\n-  END_CATCH\n \n   if (!type_name.empty ())\n     {\n@@ -189,17 +188,17 @@ re_set_exception_catchpoint (struct breakpoint *self)\n   struct program_space *filter_pspace = current_program_space;\n \n   /* We first try to use the probe interface.  */\n-  TRY\n+  try\n     {\n       event_location_up location\n \t= new_probe_location (exception_functions[kind].probe);\n       sals = parse_probes (location.get (), filter_pspace, NULL);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       /* Using the probe interface failed.  Let's fallback to the normal\n \t catchpoint mode.  */\n-      TRY\n+      try\n \t{\n \t  struct explicit_location explicit_loc;\n \n@@ -210,16 +209,14 @@ re_set_exception_catchpoint (struct breakpoint *self)\n \t  sals = self->ops->decode_location (self, location.get (),\n \t\t\t\t\t     filter_pspace);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  /* NOT_FOUND_ERROR just means the breakpoint will be\n \t     pending, so let it through.  */\n \t  if (ex.error != NOT_FOUND_ERROR)\n \t    throw_exception (ex);\n \t}\n-      END_CATCH\n     }\n-  END_CATCH\n \n   update_breakpoint_locations (self, filter_pspace, sals, {});\n }"
    },
    {
      "sha": "8dfbb113a32ff22cb1b06103cb0cb44799112208",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 28,
      "deletions": 42,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2097,18 +2097,17 @@ parse_cond_to_aexpr (CORE_ADDR scope, struct expression *cond)\n \n   /* We don't want to stop processing, so catch any errors\n      that may show up.  */\n-  TRY\n+  try\n     {\n       aexpr = gen_eval_for_expr (scope, cond);\n     }\n \n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* If we got here, it means the condition could not be parsed to a valid\n \t bytecode expression and thus can't be evaluated on the target's side.\n \t It's no use iterating through the conditions.  */\n     }\n-  END_CATCH\n \n   /* We have a valid agent expression.  */\n   return aexpr;\n@@ -2272,19 +2271,18 @@ parse_cmd_to_aexpr (CORE_ADDR scope, char *cmd)\n \n   /* We don't want to stop processing, so catch any errors\n      that may show up.  */\n-  TRY\n+  try\n     {\n       aexpr = gen_printf (scope, gdbarch, 0, 0,\n \t\t\t  format_start, format_end - format_start,\n \t\t\t  argvec.size (), argvec.data ());\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* If we got here, it means the command could not be parsed to a valid\n \t bytecode expression and thus can't be evaluated on the target's side.\n \t It's no use iterating through the other commands.  */\n     }\n-  END_CATCH\n \n   /* We have a valid agent expression, return it.  */\n   return aexpr;\n@@ -2539,19 +2537,18 @@ insert_bp_location (struct bp_location *bl,\n \t  || !(section_is_overlay (bl->section)))\n \t{\n \t  /* No overlay handling: just set the breakpoint.  */\n-\t  TRY\n+\t  try\n \t    {\n \t      int val;\n \n \t      val = bl->owner->ops->insert_location (bl);\n \t      if (val)\n \t\tbp_excpt = gdb_exception {RETURN_ERROR, GENERIC_ERROR};\n \t    }\n-\t  CATCH (e, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &e)\n \t    {\n \t      bp_excpt = e;\n \t    }\n-\t  END_CATCH\n \t}\n       else\n \t{\n@@ -2574,7 +2571,7 @@ insert_bp_location (struct bp_location *bl,\n \t\t  bl->overlay_target_info.reqstd_address = addr;\n \n \t\t  /* No overlay handling: just set the breakpoint.  */\n-\t\t  TRY\n+\t\t  try\n \t\t    {\n \t\t      int val;\n \n@@ -2587,11 +2584,10 @@ insert_bp_location (struct bp_location *bl,\n \t\t\tbp_excpt\n \t\t\t  = gdb_exception {RETURN_ERROR, GENERIC_ERROR};\n \t\t    }\n-\t\t  CATCH (e, RETURN_MASK_ALL)\n+\t\t  catch (const gdb_exception_RETURN_MASK_ALL &e)\n \t\t    {\n \t\t      bp_excpt = e;\n \t\t    }\n-\t\t  END_CATCH\n \n \t\t  if (bp_excpt.reason != 0)\n \t\t    fprintf_unfiltered (tmp_error_stream,\n@@ -2604,19 +2600,18 @@ insert_bp_location (struct bp_location *bl,\n \t  if (section_is_mapped (bl->section))\n \t    {\n \t      /* Yes.  This overlay section is mapped into memory.  */\n-\t      TRY\n+\t      try\n \t        {\n \t\t  int val;\n \n \t          val = bl->owner->ops->insert_location (bl);\n \t\t  if (val)\n \t\t    bp_excpt = gdb_exception {RETURN_ERROR, GENERIC_ERROR};\n \t        }\n-\t      CATCH (e, RETURN_MASK_ALL)\n+\t      catch (const gdb_exception_RETURN_MASK_ALL &e)\n \t        {\n \t\t  bp_excpt = e;\n \t        }\n-\t      END_CATCH\n \t    }\n \t  else\n \t    {\n@@ -5017,11 +5012,11 @@ bpstat_check_watchpoint (bpstat bs)\n \t{\n \t  wp_check_result e;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      e = watchpoint_check (bs);\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t    {\n \t      exception_fprintf (gdb_stderr, ex,\n \t\t\t\t \"Error evaluating expression \"\n@@ -5036,7 +5031,6 @@ bpstat_check_watchpoint (bpstat bs)\n \t      watchpoint_del_at_next_stop (b);\n \t      e = WP_DELETED;\n \t    }\n-\t  END_CATCH\n \n \t  switch (e)\n \t    {\n@@ -5255,16 +5249,15 @@ bpstat_check_breakpoint_conditions (bpstat bs, thread_info *thread)\n \t}\n       if (within_current_scope)\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      condition_result = breakpoint_cond_eval (cond);\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t    {\n \t      exception_fprintf (gdb_stderr, ex,\n \t\t\t\t \"Error in testing breakpoint condition:\\n\");\n \t    }\n-\t  END_CATCH\n \t}\n       else\n \t{\n@@ -9246,11 +9239,11 @@ create_breakpoint (struct gdbarch *gdbarch,\n   if (extra_string != NULL && *extra_string == '\\0')\n     extra_string = NULL;\n \n-  TRY\n+  try\n     {\n       ops->create_sals_from_location (location, &canonical, type_wanted);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       /* If caller is interested in rc value from parse, set\n \t value.  */\n@@ -9280,7 +9273,6 @@ create_breakpoint (struct gdbarch *gdbarch,\n       else\n \tthrow_exception (e);\n     }\n-  END_CATCH\n \n   if (!pending && canonical.lsals.empty ())\n     return 0;\n@@ -12060,14 +12052,13 @@ static void\n update_global_location_list_nothrow (enum ugll_insert_mode insert_mode)\n {\n \n-  TRY\n+  try\n     {\n       update_global_location_list (insert_mode);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n     }\n-  END_CATCH\n }\n \n /* Clear BKP from a BPS.  */\n@@ -13529,20 +13520,19 @@ update_breakpoint_locations (struct breakpoint *b,\n \t  const char *s;\n \n \t  s = b->cond_string;\n-\t  TRY\n+\t  try\n \t    {\n \t      new_loc->cond = parse_exp_1 (&s, sal.pc,\n \t\t\t\t\t   block_for_pc (sal.pc),\n \t\t\t\t\t   0);\n \t    }\n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t      warning (_(\"failed to reevaluate condition \"\n \t\t\t \"for breakpoint %d: %s\"), \n \t\t       b->number, e.what ());\n \t      new_loc->enabled = 0;\n \t    }\n-\t  END_CATCH\n \t}\n \n       if (!sals_end.empty ())\n@@ -13609,11 +13599,11 @@ location_to_sals (struct breakpoint *b, struct event_location *location,\n \n   std::vector<symtab_and_line> sals;\n \n-  TRY\n+  try\n     {\n       sals = b->ops->decode_location (b, location, search_pspace);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       int not_found_and_ok = 0;\n \n@@ -13648,7 +13638,6 @@ location_to_sals (struct breakpoint *b, struct event_location *location,\n \t  throw_exception (e);\n \t}\n     }\n-  END_CATCH\n \n   if (exception.reason == 0 || exception.error != NOT_FOUND_ERROR)\n     {\n@@ -13820,17 +13809,16 @@ breakpoint_re_set (void)\n \n     ALL_BREAKPOINTS_SAFE (b, b_tmp)\n       {\n-\tTRY\n+\ttry\n \t  {\n \t    breakpoint_re_set_one (b);\n \t  }\n-\tCATCH (ex, RETURN_MASK_ALL)\n+\tcatch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t  {\n \t    exception_fprintf (gdb_stderr, ex,\n \t\t\t       \"Error in re-setting breakpoint %d: \",\n \t\t\t       b->number);\n \t  }\n-\tEND_CATCH\n       }\n \n     jit_breakpoint_re_set ();\n@@ -14297,22 +14285,21 @@ enable_breakpoint_disp (struct breakpoint *bpt, enum bpdisp disposition,\n       /* Initialize it just to avoid a GCC false warning.  */\n       enum enable_state orig_enable_state = bp_disabled;\n \n-      TRY\n+      try\n \t{\n \t  struct watchpoint *w = (struct watchpoint *) bpt;\n \n \t  orig_enable_state = bpt->enable_state;\n \t  bpt->enable_state = bp_enabled;\n \t  update_watchpoint (w, 1 /* reparse */);\n \t}\n-      CATCH (e, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &e)\n \t{\n \t  bpt->enable_state = orig_enable_state;\n \t  exception_fprintf (gdb_stderr, e, _(\"Cannot enable watchpoint %d: \"),\n \t\t\t     bpt->number);\n \t  return;\n \t}\n-      END_CATCH\n     }\n \n   bpt->enable_state = bp_enabled;\n@@ -15040,16 +15027,15 @@ save_breakpoints (const char *filename, int from_tty,\n \tfp.puts (\"  commands\\n\");\n \t\n \tcurrent_uiout->redirect (&fp);\n-\tTRY\n+\ttry\n \t  {\n \t    print_command_lines (current_uiout, tp->commands.get (), 2);\n \t  }\n-\tCATCH (ex, RETURN_MASK_ALL)\n+\tcatch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t  {\n \t  current_uiout->redirect (NULL);\n \t    throw_exception (ex);\n \t  }\n-\tEND_CATCH\n \n \tcurrent_uiout->redirect (NULL);\n \tfp.puts (\"  end\\n\");"
    },
    {
      "sha": "3bfd1c84e1bb360ae9fc4aeccb3672e4fa1182c9",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 14,
      "deletions": 21,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -678,7 +678,7 @@ ftrace_classify_insn (struct gdbarch *gdbarch, CORE_ADDR pc)\n   enum btrace_insn_class iclass;\n \n   iclass = BTRACE_INSN_OTHER;\n-  TRY\n+  try\n     {\n       if (gdbarch_insn_is_call (gdbarch, pc))\n \ticlass = BTRACE_INSN_CALL;\n@@ -687,10 +687,9 @@ ftrace_classify_insn (struct gdbarch *gdbarch, CORE_ADDR pc)\n       else if (gdbarch_insn_is_jump (gdbarch, pc))\n \ticlass = BTRACE_INSN_JUMP;\n     }\n-  CATCH (error, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &error)\n     {\n     }\n-  END_CATCH\n \n   return iclass;\n }\n@@ -1103,14 +1102,13 @@ btrace_compute_ftrace_bts (struct thread_info *tp,\n \t    level = std::min (level, bfun->level);\n \n \t  size = 0;\n-\t  TRY\n+\t  try\n \t    {\n \t      size = gdb_insn_length (gdbarch, pc);\n \t    }\n-\t  CATCH (error, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &error)\n \t    {\n \t    }\n-\t  END_CATCH\n \n \t  insn.pc = pc;\n \t  insn.size = size;\n@@ -1370,17 +1368,16 @@ btrace_pt_readmem_callback (gdb_byte *buffer, size_t size,\n   int result, errcode;\n \n   result = (int) size;\n-  TRY\n+  try\n     {\n       errcode = target_read_code ((CORE_ADDR) pc, buffer, size);\n       if (errcode != 0)\n \tresult = -pte_nomap;\n     }\n-  CATCH (error, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &error)\n     {\n       result = -pte_nomap;\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -1464,7 +1461,7 @@ btrace_compute_ftrace_pt (struct thread_info *tp,\n   if (decoder == NULL)\n     error (_(\"Failed to allocate the Intel Processor Trace decoder.\"));\n \n-  TRY\n+  try\n     {\n       struct pt_image *image;\n \n@@ -1479,7 +1476,7 @@ btrace_compute_ftrace_pt (struct thread_info *tp,\n \n       ftrace_add_pt (btinfo, decoder, &level, gaps);\n     }\n-  CATCH (error, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &error)\n     {\n       /* Indicate a gap in the trace if we quit trace processing.  */\n       if (error.reason == RETURN_QUIT && !btinfo->functions.empty ())\n@@ -1489,7 +1486,6 @@ btrace_compute_ftrace_pt (struct thread_info *tp,\n \n       throw_exception (error);\n     }\n-  END_CATCH\n \n   btrace_finalize_ftrace_pt (decoder, tp, level);\n }\n@@ -1556,17 +1552,16 @@ btrace_compute_ftrace (struct thread_info *tp, struct btrace_data *btrace,\n {\n   std::vector<unsigned int> gaps;\n \n-  TRY\n+  try\n     {\n       btrace_compute_ftrace_1 (tp, btrace, cpu, gaps);\n     }\n-  CATCH (error, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &error)\n     {\n       btrace_finalize_ftrace (tp, gaps);\n \n       throw_exception (error);\n     }\n-  END_CATCH\n \n   btrace_finalize_ftrace (tp, gaps);\n }\n@@ -1617,7 +1612,7 @@ btrace_enable (struct thread_info *tp, const struct btrace_config *conf)\n     return;\n \n   /* We need to undo the enable in case of errors.  */\n-  TRY\n+  try\n     {\n       /* Add an entry for the current PC so we start tracing from where we\n \t enabled it.\n@@ -1632,13 +1627,12 @@ btrace_enable (struct thread_info *tp, const struct btrace_config *conf)\n \t  && can_access_registers_thread (tp))\n \tbtrace_add_pc (tp);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       btrace_disable (tp);\n \n       throw_exception (exception);\n     }\n-  END_CATCH\n }\n \n /* See btrace.h.  */\n@@ -3062,18 +3056,17 @@ btrace_maint_update_pt_packets (struct btrace_thread_info *btinfo)\n   if (decoder == NULL)\n     error (_(\"Failed to allocate the Intel Processor Trace decoder.\"));\n \n-  TRY\n+  try\n     {\n       btrace_maint_decode_pt (&btinfo->maint, decoder);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       pt_pkt_free_decoder (decoder);\n \n       if (except.reason < 0)\n \tthrow_exception (except);\n     }\n-  END_CATCH\n \n   pt_pkt_free_decoder (decoder);\n }"
    },
    {
      "sha": "36290dda2e23928337197074759ca7b19489d0d3",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -92,16 +92,15 @@ adjust_value_for_child_access (struct value **value,\n \t  if (value && *value)\n \t    {\n \n-\t      TRY\n+\t      try\n \t\t{\n \t\t  *value = value_ind (*value);\n \t\t}\n \n-\t      CATCH (except, RETURN_MASK_ERROR)\n+\t      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t\t{\n \t\t  *value = NULL;\n \t\t}\n-\t      END_CATCH\n \t    }\n \t  *type = target_type;\n \t  if (was_ptr)\n@@ -253,18 +252,17 @@ value_struct_element_index (struct value *value, int type_index)\n   gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT\n \t      || TYPE_CODE (type) == TYPE_CODE_UNION);\n \n-  TRY\n+  try\n     {\n       if (field_is_static (&TYPE_FIELD (type, type_index)))\n \tresult = value_static_field (type, type_index);\n       else\n \tresult = value_primitive_field (value, 0, type_index, type);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       return NULL;\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -316,14 +314,13 @@ c_describe_child (const struct varobj *parent, int index,\n \t{\n \t  int real_index = index + TYPE_LOW_BOUND (TYPE_INDEX_TYPE (type));\n \n-\t  TRY\n+\t  try\n \t    {\n \t      *cvalue = value_subscript (value, real_index);\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t    }\n-\t  END_CATCH\n \t}\n \n       if (ctype)\n@@ -393,16 +390,15 @@ c_describe_child (const struct varobj *parent, int index,\n \n       if (cvalue && value)\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      *cvalue = value_ind (value);\n \t    }\n \n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      *cvalue = NULL;\n \t    }\n-\t  END_CATCH\n \t}\n \n       /* Don't use get_target_type because it calls"
    },
    {
      "sha": "1dc82b3a875ec7a28969b96579a4ad9ac504015d",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -250,7 +250,7 @@ complete_command (const char *arg, int from_tty)\n   int quote_char = '\\0';\n   const char *word;\n \n-  TRY\n+  try\n     {\n       word = completion_find_completion_word (tracker_handle_brkchars,\n \t\t\t\t\t      arg, &quote_char);\n@@ -267,11 +267,10 @@ complete_command (const char *arg, int from_tty)\n \t  tracker = &tracker_handle_completions;\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       return;\n     }\n-  END_CATCH\n \n   std::string arg_prefix (arg, word - arg);\n "
    },
    {
      "sha": "c8cc1b4657c98528a53510d2af4fe9e8e0cc4f44",
      "filename": "gdb/cli/cli-interp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-interp.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -363,15 +363,14 @@ safe_execute_command (struct ui_out *command_uiout, const char *command,\n   scoped_restore saved_uiout = make_scoped_restore (&current_uiout,\n \t\t\t\t\t\t    command_uiout);\n \n-  TRY\n+  try\n     {\n       execute_command (command, from_tty);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       e = exception;\n     }\n-  END_CATCH\n \n   /* FIXME: cagney/2005-01-13: This shouldn't be needed.  Instead the\n      caller should print the exception.  */"
    },
    {
      "sha": "49645537fe32e00b318995f88c24ee5961423535",
      "filename": "gdb/cli/cli-script.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-script.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cli/cli-script.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-script.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1050,16 +1050,15 @@ process_next_line (const char *p, struct command_line **command,\n \n   if (validator)\n     {\n-      TRY\n+      try\n \t{\n \t  validator ((*command)->line);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  free_command_lines (command);\n \t  throw_exception (ex);\n \t}\n-      END_CATCH\n     }\n \n   /* Nothing special.  */\n@@ -1540,11 +1539,11 @@ script_from_file (FILE *stream, const char *file)\n \n   scoped_restore save_async = make_scoped_restore (&current_ui->async, 0);\n \n-  TRY\n+  try\n     {\n       read_command_file (stream);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       /* Re-throw the error, but with the file name information\n \t prepended.  */\n@@ -1553,7 +1552,6 @@ script_from_file (FILE *stream, const char *file)\n \t\t   source_file_name.c_str (), source_line_number,\n \t\t   e.what ());\n     }\n-  END_CATCH\n }\n \n /* Print the definition of user command C to STREAM.  Or, if C is a"
    },
    {
      "sha": "c358b802fa4b1e777d73f3d3d73011838ebcbe6b",
      "filename": "gdb/common/new-op.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/common/new-op.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/common/new-op.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/common/new-op.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -60,15 +60,14 @@ operator new (std::size_t sz)\n \t QUIT gdb_exception.  This is necessary because operator new\n \t can only ever throw std::bad_alloc, or something that extends\n \t it.  */\n-      TRY\n+      try\n \t{\n \t  malloc_failure (sz);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  throw gdb_quit_bad_alloc (ex);\n \t}\n-      END_CATCH\n     }\n   return p;\n }"
    },
    {
      "sha": "3f3ff744a312f569a393cddb6be908cae014e7f3",
      "filename": "gdb/common/selftest.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/common/selftest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/common/selftest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/common/selftest.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -81,18 +81,17 @@ run_tests (const char *filter)\n \t  && name.find (filter) == std::string::npos)\n \tcontinue;\n \n-      TRY\n+      try\n \t{\n \t  debug_printf (_(\"Running selftest %s.\\n\"), name.c_str ());\n \t  ++ran;\n \t  (*test) ();\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  ++failed;\n \t  debug_printf (\"Self test failed: %s\\n\", ex.what ());\n \t}\n-      END_CATCH\n \n       reset ();\n     }"
    },
    {
      "sha": "7e76db33d76023f4673c2b8a33dbeb859c870f97",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -344,7 +344,7 @@ gcc_convert_symbol (void *datum,\n \n   /* We can't allow exceptions to escape out of this callback.  Safest\n      is to simply emit a gcc error.  */\n-  TRY\n+  try\n     {\n       struct block_symbol sym;\n \n@@ -367,11 +367,10 @@ gcc_convert_symbol (void *datum,\n \t}\n     }\n \n-  CATCH (e, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &e)\n     {\n       context->plugin ().error (e.what ());\n     }\n-  END_CATCH\n \n   if (compile_debug && !found)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -393,7 +392,7 @@ gcc_symbol_address (void *datum, struct gcc_c_context *gcc_context,\n \n   /* We can't allow exceptions to escape out of this callback.  Safest\n      is to simply emit a gcc error.  */\n-  TRY\n+  try\n     {\n       struct symbol *sym;\n \n@@ -430,11 +429,10 @@ gcc_symbol_address (void *datum, struct gcc_c_context *gcc_context,\n \t}\n     }\n \n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       context->plugin ().error (e.what ());\n     }\n-  END_CATCH\n \n   if (compile_debug && !found)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -548,7 +546,7 @@ generate_c_for_for_one_variable (compile_instance *compiler,\n \t\t\t\t struct symbol *sym)\n {\n \n-  TRY\n+  try\n     {\n       if (is_dynamic_type (SYMBOL_TYPE (sym)))\n \t{\n@@ -600,11 +598,10 @@ generate_c_for_for_one_variable (compile_instance *compiler,\n \t}\n     }\n \n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       compiler->insert_symbol_error (sym, e.what ());\n     }\n-  END_CATCH\n }\n \n /* See compile-c.h.  */"
    },
    {
      "sha": "1bb3a6ffbfdba4c9b6c9f83cefd0800d2a5ffbca",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -343,7 +343,7 @@ gcc_cplus_convert_symbol (void *datum,\n   bool found = false;\n   compile_cplus_instance *instance = (compile_cplus_instance *) datum;\n \n-  TRY\n+  try\n     {\n       /* Symbol searching is a three part process unfortunately.  */\n \n@@ -388,13 +388,12 @@ gcc_cplus_convert_symbol (void *datum,\n \t    }\n \t}\n     }\n-  CATCH (e, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &e)\n     {\n       /* We can't allow exceptions to escape out of this callback.  Safest\n \t is to simply emit a gcc error.  */\n       instance->plugin ().error (e.what ());\n     }\n-  END_CATCH\n \n   if (compile_debug && !found)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -431,7 +430,7 @@ gcc_cplus_symbol_address (void *datum, struct gcc_cp_context *gcc_context,\n \n   /* We can't allow exceptions to escape out of this callback.  Safest\n      is to simply emit a gcc error.  */\n-  TRY\n+  try\n     {\n       struct symbol *sym\n \t= lookup_symbol (identifier, nullptr, VAR_DOMAIN, nullptr).symbol;\n@@ -467,11 +466,10 @@ gcc_cplus_symbol_address (void *datum, struct gcc_cp_context *gcc_context,\n \t}\n     }\n \n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       instance->plugin ().error (e.what ());\n     }\n-  END_CATCH\n \n   if (compile_debug && !found)\n     fprintf_unfiltered (gdb_stdlog,"
    },
    {
      "sha": "29542e744ee45335df2c79bf1da7e8e0f692db6a",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -50,16 +50,15 @@ munmap_list::~munmap_list ()\n {\n   for (auto &item : items)\n     {\n-      TRY\n+      try\n \t{\n \t  gdbarch_infcall_munmap (target_gdbarch (), item.addr, item.size);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  /* There's not much the user can do, so just ignore\n \t     this.  */\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "1c4dd2014f096e9b3dcf3248883ea895455cf697",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -137,7 +137,7 @@ compile_object_run (struct compile_module *module)\n   xfree (module);\n   module = NULL;\n \n-  TRY\n+  try\n     {\n       struct type *func_type = SYMBOL_TYPE (func_sym);\n       htab_t copied_types;\n@@ -173,7 +173,7 @@ compile_object_run (struct compile_module *module)\n       call_function_by_hand_dummy (func_val, NULL, args,\n \t\t\t\t   do_module_cleanup, data);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* In the case of DTOR_FOUND or in the case of EXECUTED nothing\n \t needs to be done.  */\n@@ -185,7 +185,6 @@ compile_object_run (struct compile_module *module)\n \tdo_module_cleanup (data, 0);\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   dtor_found = find_dummy_frame_dtor (do_module_cleanup, data);\n   gdb_assert (!dtor_found && executed);"
    },
    {
      "sha": "6d87174253c5461a80b57b09462cdd611e6e53b1",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1021,15 +1021,14 @@ complete_expression (completion_tracker &tracker,\n \n   /* Perform a tentative parse of the expression, to see whether a\n      field completion is required.  */\n-  TRY\n+  try\n     {\n       type = parse_expression_for_completion (text, &fieldname, &code);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       return;\n     }\n-  END_CATCH\n \n   if (fieldname != nullptr && type)\n     {\n@@ -1445,16 +1444,15 @@ complete_line_internal (completion_tracker &tracker,\n \t\t\tconst char *line_buffer, int point,\n \t\t\tcomplete_line_internal_reason reason)\n {\n-  TRY\n+  try\n     {\n       complete_line_internal_1 (tracker, text, line_buffer, point, reason);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (except.error != MAX_COMPLETIONS_REACHED_ERROR)\n \tthrow_exception (except);\n     }\n-  END_CATCH\n }\n \n /* See completer.h.  */\n@@ -1859,17 +1857,16 @@ gdb_completion_word_break_characters ()\n   /* New completion starting.  */\n   current_completion.aborted = false;\n \n-  TRY\n+  try\n     {\n       return gdb_completion_word_break_characters_throw ();\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* Set this to that gdb_rl_attempted_completion_function knows\n \t to abort early.  */\n       current_completion.aborted = true;\n     }\n-  END_CATCH\n \n   return NULL;\n }\n@@ -2207,14 +2204,13 @@ gdb_rl_attempted_completion_function (const char *text, int start, int end)\n   if (current_completion.aborted)\n     return NULL;\n \n-  TRY\n+  try\n     {\n       return gdb_rl_attempted_completion_function_throw (text, start, end);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n     }\n-  END_CATCH\n \n   return NULL;\n }"
    },
    {
      "sha": "a0fab140a149ca5748f2ac410f76accc558c5ee2",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -461,16 +461,15 @@ core_target_open (const char *arg, int from_tty)\n      may be a thread_stratum target loaded on top of target core by\n      now.  The layer above should claim threads found in the BFD\n      sections.  */\n-  TRY\n+  try\n     {\n       target_update_thread_list ();\n     }\n \n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       exception_print (gdb_stderr, except);\n     }\n-  END_CATCH\n \n   p = bfd_core_file_failing_command (core_bfd);\n   if (p)\n@@ -517,15 +516,14 @@ core_target_open (const char *arg, int from_tty)\n      anything about threads.  That is why the test is >= 2.  */\n   if (thread_count () >= 2)\n     {\n-      TRY\n+      try\n \t{\n \t  thread_command (NULL, from_tty);\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  exception_print (gdb_stderr, except);\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "f82da4b1636d15344d00b342ba9ca7e43e3cce06",
      "filename": "gdb/cp-abi.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-abi.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -73,13 +73,13 @@ baseclass_offset (struct type *type, int index, const gdb_byte *valaddr,\n \n   gdb_assert (current_cp_abi.baseclass_offset != NULL);\n \n-  TRY\n+  try\n     {\n       res = (*current_cp_abi.baseclass_offset) (type, index, valaddr,\n \t\t\t\t\t\tembedded_offset,\n \t\t\t\t\t\taddress, val);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n@@ -88,7 +88,6 @@ baseclass_offset (struct type *type, int index, const gdb_byte *valaddr,\n \t\t   _(\"Cannot determine virtual baseclass offset \"\n \t\t     \"of incomplete object\"));\n     }\n-  END_CATCH\n \n   return res;\n }\n@@ -112,15 +111,14 @@ value_rtti_type (struct value *v, int *full,\n \n   if ((current_cp_abi.rtti_type) == NULL)\n     return NULL;\n-  TRY\n+  try\n     {\n       ret = (*current_cp_abi.rtti_type) (v, full, top, using_enc);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       return NULL;\n     }\n-  END_CATCH\n \n   return ret;\n }"
    },
    {
      "sha": "07265ef88db9f2a8291ca0055dd71bb4649e8635",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -151,15 +151,14 @@ inspect_type (struct demangle_parse_info *info,\n \n   sym = NULL;\n \n-  TRY\n+  try\n     {\n       sym = lookup_symbol (name, 0, VAR_DOMAIN, 0).symbol;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       return 0;\n     }\n-  END_CATCH\n \n   if (sym != NULL)\n     {\n@@ -223,17 +222,16 @@ inspect_type (struct demangle_parse_info *info,\n \t    }\n \n \t  string_file buf;\n-\t  TRY\n+\t  try\n \t    {\n \t      type_print (type, \"\", &buf, -1);\n \t    }\n \t  /* If type_print threw an exception, there is little point\n \t     in continuing, so just bow out gracefully.  */\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      return 0;\n \t    }\n-\t  END_CATCH\n \n \t  len = buf.size ();\n \t  name = (char *) obstack_copy0 (&info->obstack, buf.c_str (), len);\n@@ -424,15 +422,14 @@ replace_typedefs (struct demangle_parse_info *info,\n \t      struct symbol *sym = NULL;\n \n \t      sym = NULL;\n-\t      TRY\n+\t      try\n \t\t{\n \t\t  sym = lookup_symbol (local_name.get (), 0,\n \t\t\t\t       VAR_DOMAIN, 0).symbol;\n \t\t}\n-\t      CATCH (except, RETURN_MASK_ALL)\n+\t      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t\t{\n \t\t}\n-\t      END_CATCH\n \n \t      if (sym != NULL)\n \t\t{"
    },
    {
      "sha": "f45bacc1f18c1d7b1e998e1e50723cea979cd69d",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -320,18 +320,17 @@ cp_print_value_fields (struct type *type, struct type *real_type,\n \t\t{\n \t\t  struct value *v = NULL;\n \n-\t\t  TRY\n+\t\t  try\n \t\t    {\n \t\t      v = value_static_field (type, i);\n \t\t    }\n \n-\t\t  CATCH (ex, RETURN_MASK_ERROR)\n+\t\t  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t\t    {\n \t\t      fprintf_filtered (stream,\n \t\t\t\t\t_(\"<error reading variable: %s>\"),\n \t\t\t\t\tex.what ());\n \t\t    }\n-\t\t  END_CATCH\n \n \t\t  cp_print_static_field (TYPE_FIELD_TYPE (type, i),\n \t\t\t\t\t v, stream, recurse + 1,\n@@ -509,18 +508,17 @@ cp_print_value (struct type *type, struct type *real_type,\n       thisoffset = offset;\n       thistype = real_type;\n \n-      TRY\n+      try\n \t{\n \t  boffset = baseclass_offset (type, i, valaddr, offset, address, val);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  if (ex.error == NOT_AVAILABLE_ERROR)\n \t    skip = -1;\n \t  else\n \t    skip = 1;\n \t}\n-      END_CATCH\n \n       if (skip == 0)\n \t{"
    },
    {
      "sha": "caa4fd1882718ac384a8e3745d857d3e20ceac75",
      "filename": "gdb/darwin-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/darwin-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/darwin-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1611,7 +1611,7 @@ darwin_attach_pid (struct inferior *inf)\n   darwin_inferior *priv = new darwin_inferior;\n   inf->priv.reset (priv);\n \n-  TRY\n+  try\n     {\n       kret = task_for_pid (gdb_task, inf->pid, &priv->task);\n       if (kret != KERN_SUCCESS)\n@@ -1688,14 +1688,13 @@ darwin_attach_pid (struct inferior *inf)\n \n       darwin_setup_exceptions (inf);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exit_inferior (inf);\n       inferior_ptid = null_ptid;\n \n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   target_ops *darwin_ops = get_native_target ();\n   if (!target_is_pushed (darwin_ops))\n@@ -1949,11 +1948,11 @@ The error was: %s\"),\n   /* Maybe it was cached by some earlier gdb.  */\n   if (stat (new_name.c_str (), &sb) != 0 || !S_ISREG (sb.st_mode))\n     {\n-      TRY\n+      try\n \t{\n \t  copy_shell_to_cache (shell, new_name);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  warning (_(\"This version of macOS has System Integrity Protection.\\n\\\n Because `startup-with-shell' is enabled, gdb tried to work around SIP by\\n\\\n@@ -1965,7 +1964,6 @@ you \\\"run\\\".  To prevent these attempts, you can use:\\n\\\n \t\t   ex.what ());\n \t  return false;\n \t}\n-      END_CATCH\n \n       printf_filtered (_(\"Note: this version of macOS has System Integrity Protection.\\n\\\n Because `startup-with-shell' is enabled, gdb has worked around this by\\n\\"
    },
    {
      "sha": "aa4d499206a970122e2d16ab99f391fbb5416680",
      "filename": "gdb/disasm-selftests.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/disasm-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/disasm-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/disasm-selftests.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -192,16 +192,15 @@ memory_error_test (struct gdbarch *gdbarch)\n   gdb_disassembler_test di (gdbarch);\n   bool saw_memory_error = false;\n \n-  TRY\n+  try\n     {\n       di.print_insn (0);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == MEMORY_ERROR)\n \tsaw_memory_error = true;\n     }\n-  END_CATCH\n \n   /* Expect MEMORY_ERROR.  */\n   SELF_CHECK (saw_memory_error);"
    },
    {
      "sha": "92fda24a3f7dc1d500d1652ee595ac102fe6c9bd",
      "filename": "gdb/dtrace-probe.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dtrace-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dtrace-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dtrace-probe.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -484,15 +484,14 @@ dtrace_process_dof_probe (struct objfile *objfile,\n \t     int'.  */\n           struct type *type = builtin_type (gdbarch)->builtin_long;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      expr = parse_expression_with_language (type_str.c_str (),\n \t\t\t\t\t\t     language_c);\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t    {\n \t    }\n-\t  END_CATCH\n \n \t  if (expr != NULL && expr.get ()->elts[0].opcode == OP_TYPE)\n \t    type = expr.get ()->elts[1].type;"
    },
    {
      "sha": "e03bbfc9f6fc44a4768fbb336ec7387ea7c226ce",
      "filename": "gdb/dwarf-index-cache.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf-index-cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf-index-cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-cache.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -110,7 +110,7 @@ index_cache::store (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n   std::string build_id_str = build_id_to_string (build_id);\n \n-  TRY\n+  try\n     {\n       /* Try to create the containing directory.  */\n       if (!mkdir_recursive (m_dir.c_str ()))\n@@ -129,13 +129,12 @@ index_cache::store (struct dwarf2_per_objfile *dwarf2_per_objfile)\n       write_psymtabs_to_index (dwarf2_per_objfile, m_dir.c_str (),\n \t\t\t       build_id_str.c_str (), dw_index_kind::GDB_INDEX);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (debug_index_cache)\n \tprintf_unfiltered (\"index cache: couldn't store index cache for objfile \"\n \t\t\t   \"%s: %s\", objfile_name (obj), except.what ());\n     }\n-  END_CATCH\n }\n \n #if HAVE_SYS_MMAN_H\n@@ -172,7 +171,7 @@ index_cache::lookup_gdb_index (const bfd_build_id *build_id,\n   /* Compute where we would expect a gdb index file for this build id to be.  */\n   std::string filename = make_index_filename (build_id, INDEX4_SUFFIX);\n \n-  TRY\n+  try\n     {\n       if (debug_index_cache)\n         printf_unfiltered (\"index cache: trying to read %s\\n\",\n@@ -189,13 +188,12 @@ index_cache::lookup_gdb_index (const bfd_build_id *build_id,\n \t  ((const gdb_byte *) mmap_resource->mapping.get (),\n \t   mmap_resource->mapping.size ());\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (debug_index_cache)\n \tprintf_unfiltered (\"index cache: couldn't read %s: %s\\n\",\n \t\t\t   filename.c_str (), except.what ());\n     }\n-  END_CATCH\n \n   return {};\n }"
    },
    {
      "sha": "531256f2d58d05989271fc5edf505b34faf64329",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1675,19 +1675,18 @@ save_gdb_index_command (const char *arg, int from_tty)\n \n       if (dwarf2_per_objfile != NULL)\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      const char *basename = lbasename (objfile_name (objfile));\n \t      write_psymtabs_to_index (dwarf2_per_objfile, arg, basename,\n \t\t\t\t       index_kind);\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      exception_fprintf (gdb_stderr, except,\n \t\t\t\t _(\"Error while writing index for `%s': \"),\n \t\t\t\t objfile_name (objfile));\n \t    }\n-\t  END_CATCH\n \t    }\n \n     }"
    },
    {
      "sha": "178a65c3be44e2dccb32039432fbd0f6a0d246c2",
      "filename": "gdb/dwarf2-frame-tailcall.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2-frame-tailcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2-frame-tailcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame-tailcall.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -377,7 +377,7 @@ dwarf2_tailcall_sniffer_first (struct frame_info *this_frame,\n   this_pc = get_frame_address_in_block (this_frame);\n \n   /* Catch any unwinding errors.  */\n-  TRY\n+  try\n     {\n       int sp_regnum;\n \n@@ -399,13 +399,12 @@ dwarf2_tailcall_sniffer_first (struct frame_info *this_frame,\n \t    }\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (entry_values_debug)\n \texception_print (gdb_stdout, except);\n       return;\n     }\n-  END_CATCH\n \n   /* Ambiguous unwind or unambiguous unwind verified as matching.  */\n   if (chain == NULL || chain->length == 0)"
    },
    {
      "sha": "2274d67201a17fae34f2d36fb6b678a32ed9af0f",
      "filename": "gdb/dwarf2-frame.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1044,7 +1044,7 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n   execute_cfa_program (fde, instr, fde->end, gdbarch,\n \t\t       get_frame_address_in_block (this_frame), &fs);\n \n-  TRY\n+  try\n     {\n       /* Calculate the CFA.  */\n       switch (fs.regs.cfa_how)\n@@ -1068,7 +1068,7 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n \t  internal_error (__FILE__, __LINE__, _(\"Unknown CFA rule.\"));\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n \t{\n@@ -1078,7 +1078,6 @@ dwarf2_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   /* Initialize the register state.  */\n   {\n@@ -2245,7 +2244,7 @@ dwarf2_build_frame_info (struct objfile *objfile)\n           if (txt)\n             unit->tbase = txt->vma;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      frame_ptr = unit->dwarf_frame_buffer;\n \t      while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)\n@@ -2254,7 +2253,7 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t\t\t\t\t\tEH_CIE_OR_FDE_TYPE_ID);\n \t    }\n \n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t      warning (_(\"skipping .eh_frame info of %s: %s\"),\n \t\t       objfile_name (objfile), e.what ());\n@@ -2267,7 +2266,6 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t\t}\n \t      /* The cie_table is discarded by the next if.  */\n \t    }\n-\t  END_CATCH\n \n           if (cie_table.num_entries != 0)\n             {\n@@ -2287,15 +2285,15 @@ dwarf2_build_frame_info (struct objfile *objfile)\n     {\n       int num_old_fde_entries = fde_table.num_entries;\n \n-      TRY\n+      try\n \t{\n \t  frame_ptr = unit->dwarf_frame_buffer;\n \t  while (frame_ptr < unit->dwarf_frame_buffer + unit->dwarf_frame_size)\n \t    frame_ptr = decode_frame_entry (unit, frame_ptr, 0,\n \t\t\t\t\t    &cie_table, &fde_table,\n \t\t\t\t\t    EH_CIE_OR_FDE_TYPE_ID);\n \t}\n-      CATCH (e, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t{\n \t  warning (_(\"skipping .debug_frame info of %s: %s\"),\n \t\t   objfile_name (objfile), e.what ());\n@@ -2318,7 +2316,6 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t  fde_table.num_entries = num_old_fde_entries;\n \t  /* The cie_table is discarded by the next if.  */\n \t}\n-      END_CATCH\n     }\n \n   /* Discard the cie_table, it is no longer needed.  */"
    },
    {
      "sha": "d712c29a7c268e49acd87a9d2dbc90cceab29f57",
      "filename": "gdb/dwarf2loc.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2loc.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1195,11 +1195,11 @@ call_site_find_chain (struct gdbarch *gdbarch, CORE_ADDR caller_pc,\n {\n   struct call_site_chain *retval = NULL;\n \n-  TRY\n+  try\n     {\n       retval = call_site_find_chain_1 (gdbarch, caller_pc, callee_pc);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       if (e.error == NO_ENTRY_VALUE_ERROR)\n \t{\n@@ -1211,7 +1211,6 @@ call_site_find_chain (struct gdbarch *gdbarch, CORE_ADDR caller_pc,\n       else\n \tthrow_exception (e);\n     }\n-  END_CATCH\n \n   return retval;\n }\n@@ -2164,11 +2163,11 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   ctx.ref_addr_size = dwarf2_per_cu_ref_addr_size (per_cu);\n   ctx.offset = dwarf2_per_cu_text_offset (per_cu);\n \n-  TRY\n+  try\n     {\n       ctx.eval (data, size);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n \t{\n@@ -2188,7 +2187,6 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n       else\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   if (ctx.pieces.size () > 0)\n     {\n@@ -2382,11 +2380,11 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   ctx.ref_addr_size = dwarf2_per_cu_ref_addr_size (dlbaton->per_cu);\n   ctx.offset = dwarf2_per_cu_text_offset (dlbaton->per_cu);\n \n-  TRY\n+  try\n     {\n       ctx.eval (dlbaton->data, dlbaton->size);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n \t{\n@@ -2401,7 +2399,6 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n       else\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   switch (ctx.location)\n     {"
    },
    {
      "sha": "6453e4a28279b0ba6a159a2bb838d42583973c8a",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -6332,7 +6332,7 @@ dwarf2_build_psymtabs (struct objfile *objfile)\n \n   init_psymbol_list (objfile, 1024);\n \n-  TRY\n+  try\n     {\n       /* This isn't really ideal: all the data we allocate on the\n \t objfile's obstack is still uselessly kept around.  However,\n@@ -6344,11 +6344,10 @@ dwarf2_build_psymtabs (struct objfile *objfile)\n       /* (maybe) store an index in the cache.  */\n       global_index_cache.store (dwarf2_per_objfile);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       exception_print (gdb_stderr, except);\n     }\n-  END_CATCH\n }\n \n /* Return the total length of the CU described by HEADER.  */"
    },
    {
      "sha": "fa65fb1ed765299cee03558c47051c90a74a78c3",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -201,11 +201,11 @@ fetch_subexp_value (struct expression *exp, int *pc, struct value **valp,\n   mark = value_mark ();\n   result = NULL;\n \n-  TRY\n+  try\n     {\n       result = evaluate_subexp (NULL_TYPE, exp, pc, EVAL_NORMAL);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* Ignore memory errors if we want watchpoints pointing at\n \t inaccessible memory to still be created; otherwise, throw the\n@@ -221,7 +221,6 @@ fetch_subexp_value (struct expression *exp, int *pc, struct value **valp,\n \t  break;\n \t}\n     }\n-  END_CATCH\n \n   new_mark = value_mark ();\n   if (mark == new_mark)\n@@ -238,15 +237,14 @@ fetch_subexp_value (struct expression *exp, int *pc, struct value **valp,\n       else\n \t{\n \n-\t  TRY\n+\t  try\n \t    {\n \t      value_fetch_lazy (result);\n \t      *valp = result;\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t    }\n-\t  END_CATCH\n \t}\n     }\n \n@@ -716,19 +714,18 @@ evaluate_var_value (enum noside noside, const block *blk, symbol *var)\n \n   struct value *ret = NULL;\n \n-  TRY\n+  try\n     {\n       ret = value_of_variable (var, blk);\n     }\n \n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (noside != EVAL_AVOID_SIDE_EFFECTS)\n \tthrow_exception (except);\n \n       ret = value_zero (SYMBOL_TYPE (var), not_lval);\n     }\n-  END_CATCH\n \n   return ret;\n }\n@@ -957,19 +954,18 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t  while (unop_user_defined_p (op, arg2))\n \t    {\n \t      struct value *value = NULL;\n-\t      TRY\n+\t      try\n \t\t{\n \t\t  value = value_x_unop (arg2, op, noside);\n \t\t}\n \n-\t      CATCH (except, RETURN_MASK_ERROR)\n+\t      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t\t{\n \t\t  if (except.error == NOT_FOUND_ERROR)\n \t\t    break;\n \t\t  else\n \t\t    throw_exception (except);\n \t\t}\n-\t      END_CATCH\n \n \t\targ2 = value;\n \t    }\n@@ -2047,19 +2043,18 @@ evaluate_subexp_standard (struct type *expect_type,\n       while (unop_user_defined_p (op, arg1))\n \t{\n \t  struct value *value = NULL;\n-\t  TRY\n+\t  try\n \t    {\n \t      value = value_x_unop (arg1, op, noside);\n \t    }\n \n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      if (except.error == NOT_FOUND_ERROR)\n \t\tbreak;\n \t      else\n \t\tthrow_exception (except);\n \t    }\n-\t  END_CATCH\n \n \t  arg1 = value;\n \t}"
    },
    {
      "sha": "0219578bb12e48d5633189059380a6da530b71b2",
      "filename": "gdb/event-loop.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/event-loop.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/event-loop.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-loop.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -366,11 +366,11 @@ start_event_loop (void)\n     {\n       int result = 0;\n \n-      TRY\n+      try\n \t{\n \t  result = gdb_do_one_event ();\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  exception_print (gdb_stderr, ex);\n \n@@ -394,7 +394,6 @@ start_event_loop (void)\n \t  /* Maybe better to set a flag to be checked somewhere as to\n \t     whether display the prompt or not.  */\n \t}\n-      END_CATCH\n \n       if (result < 0)\n \tbreak;"
    },
    {
      "sha": "2d6dda37735f9bfac1c5b37e52c3474956eef44e",
      "filename": "gdb/event-top.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/event-top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/event-top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-top.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -208,15 +208,14 @@ gdb_rl_callback_handler (char *rl) noexcept\n   struct gdb_exception gdb_rl_expt = exception_none;\n   struct ui *ui = current_ui;\n \n-  TRY\n+  try\n     {\n       ui->input_handler (gdb::unique_xmalloc_ptr<char> (rl));\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       gdb_rl_expt = ex;\n     }\n-  END_CATCH\n \n   /* If we caught a GDB exception, longjmp out of the readline\n      callback.  There's no other way for the callback to signal to\n@@ -1082,27 +1081,25 @@ static void\n async_disconnect (gdb_client_data arg)\n {\n \n-  TRY\n+  try\n     {\n       quit_cover ();\n     }\n \n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       fputs_filtered (\"Could not kill the program being debugged\",\n \t\t      gdb_stderr);\n       exception_print (gdb_stderr, exception);\n     }\n-  END_CATCH\n \n-  TRY\n+  try\n     {\n       pop_all_targets ();\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n     }\n-  END_CATCH\n \n   signal (SIGHUP, SIG_DFL);\t/*FIXME: ???????????  */\n   raise (SIGHUP);"
    },
    {
      "sha": "6a9f9194d005eb74e955e2ebd69097c3be9f18eb",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -161,33 +161,31 @@ try_open_exec_file (const char *exec_file_host, struct inferior *inf,\n      Even without a symbol file, the remote-based debugging session should\n      continue normally instead of ending abruptly.  Hence we catch thrown\n      errors/exceptions in the following code.  */\n-  TRY\n+  try\n     {\n       /* We must do this step even if exec_file_host is NULL, so that\n \t exec_file_attach will clear state.  */\n       exec_file_attach (exec_file_host, add_flags & SYMFILE_VERBOSE);\n     }\n-  CATCH (err, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &err)\n     {\n       if (err.message != NULL)\n \twarning (\"%s\", err.what ());\n \n       prev_err = err;\n     }\n-  END_CATCH\n \n   if (exec_file_host != NULL)\n     {\n-      TRY\n+      try\n \t{\n \t  symbol_file_add_main (exec_file_host, add_flags);\n \t}\n-      CATCH (err, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &err)\n \t{\n \t  if (!exception_print_same (prev_err, err))\n \t    warning (\"%s\", err.what ());\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "8d9dd16f7553f925b7692acffd963108cc9cf7f0",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -407,18 +407,17 @@ info_common_command_for_block (const struct block *block, const char *comname,\n \t    printf_filtered (\"%s = \",\n \t\t\t     SYMBOL_PRINT_NAME (common->contents[index]));\n \n-\t    TRY\n+\t    try\n \t      {\n \t\tval = value_of_variable (common->contents[index], block);\n \t\tvalue_print (val, gdb_stdout, &opts);\n \t      }\n \n-\t    CATCH (except, RETURN_MASK_ERROR)\n+\t    catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t      {\n \t\tprintf_filtered (\"<error reading variable: %s>\",\n \t\t\t\t except.what ());\n \t      }\n-\t    END_CATCH\n \n \t    putchar_filtered ('\\n');\n \t  }"
    },
    {
      "sha": "4c5dacab9ce8fbfc99fab405885a8621a3034401",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -746,15 +746,14 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n     }\n \n   /* Thread register information.  */\n-  TRY\n+  try\n     {\n       update_thread_list ();\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       exception_print (gdb_stderr, e);\n     }\n-  END_CATCH\n \n   /* Like the kernel, prefer dumping the signalled thread first.\n      \"First thread\" is what tools use to infer the signalled thread.\n@@ -1985,7 +1984,7 @@ fbsd_read_integer_by_name (struct gdbarch *gdbarch, const char *name)\n static void\n fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)\n {\n-  TRY\n+  try\n     {\n       /* Fetch offsets from debug symbols in rtld.  */\n       struct symbol *obj_entry_sym\n@@ -2000,13 +1999,12 @@ fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)\n       data->rtld_offsets_valid = true;\n       return;\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       data->off_linkmap = -1;\n     }\n-  END_CATCH\n \n-  TRY\n+  try\n     {\n       /* Fetch offsets from global variables in libthr.  Note that\n \t this does not work for single-threaded processes that are not\n@@ -2018,11 +2016,10 @@ fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)\n       data->rtld_offsets_valid = true;\n       return;\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       data->off_linkmap = -1;\n     }\n-  END_CATCH\n }\n \n /* Helper function to read the TLS index of an object file associated"
    },
    {
      "sha": "18e157950a047535cc36578bf2020032ce67473e",
      "filename": "gdb/frame-unwind.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/frame-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/frame-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame-unwind.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -101,11 +101,11 @@ frame_unwind_try_unwinder (struct frame_info *this_frame, void **this_cache,\n \n   frame_prepare_for_sniffer (this_frame, unwinder);\n \n-  TRY\n+  try\n     {\n       res = unwinder->sniffer (unwinder, this_frame, this_cache);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* Catch all exceptions, caused by either interrupt or error.\n \t Reset *THIS_CACHE.  */\n@@ -122,7 +122,6 @@ frame_unwind_try_unwinder (struct frame_info *this_frame, void **this_cache,\n \t}\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   if (res)\n     return 1;"
    },
    {
      "sha": "1fe465a73752ffc5fdcbf1187e9a78b83c938cd4",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -894,12 +894,12 @@ frame_unwind_pc (struct frame_info *this_frame)\n \t different ways that a PC could be unwound.  */\n       prev_gdbarch = frame_unwind_arch (this_frame);\n \n-      TRY\n+      try\n \t{\n \t  pc = gdbarch_unwind_pc (prev_gdbarch, this_frame);\n \t  pc_p = 1;\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  if (ex.error == NOT_AVAILABLE_ERROR)\n \t    {\n@@ -924,7 +924,6 @@ frame_unwind_pc (struct frame_info *this_frame)\n \t  else\n \t    throw_exception (ex);\n \t}\n-      END_CATCH\n \n       if (pc_p)\n \t{\n@@ -1894,7 +1893,7 @@ get_prev_frame_if_no_cycle (struct frame_info *this_frame)\n   if (prev_frame->level == 0)\n     return prev_frame;\n \n-  TRY\n+  try\n     {\n       compute_frame_id (prev_frame);\n       if (!frame_stash_add (prev_frame))\n@@ -1914,14 +1913,13 @@ get_prev_frame_if_no_cycle (struct frame_info *this_frame)\n \t  prev_frame = NULL;\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       prev_frame->next = NULL;\n       this_frame->prev = NULL;\n \n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   return prev_frame;\n }\n@@ -2092,11 +2090,11 @@ get_prev_frame_always (struct frame_info *this_frame)\n {\n   struct frame_info *prev_frame = NULL;\n \n-  TRY\n+  try\n     {\n       prev_frame = get_prev_frame_always_1 (this_frame);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == MEMORY_ERROR)\n \t{\n@@ -2120,7 +2118,6 @@ get_prev_frame_always (struct frame_info *this_frame)\n       else\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return prev_frame;\n }\n@@ -2379,18 +2376,17 @@ get_frame_pc_if_available (struct frame_info *frame, CORE_ADDR *pc)\n \n   gdb_assert (frame->next != NULL);\n \n-  TRY\n+  try\n     {\n       *pc = frame_unwind_pc (frame->next);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n \treturn 0;\n       else\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return 1;\n }\n@@ -2462,17 +2458,16 @@ get_frame_address_in_block_if_available (struct frame_info *this_frame,\n \t\t\t\t\t CORE_ADDR *pc)\n {\n \n-  TRY\n+  try\n     {\n       *pc = get_frame_address_in_block (this_frame);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n \treturn 0;\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   return 1;\n }\n@@ -2747,17 +2742,16 @@ get_frame_language (struct frame_info *frame)\n        a PC that is guaranteed to be inside the frame's code\n        block.  */\n \n-  TRY\n+  try\n     {\n       pc = get_frame_address_in_block (frame);\n       pc_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   if (pc_p)\n     {"
    },
    {
      "sha": "00312e69cd8d61e0ac1d5b226f4a2bc5d3dc89dd",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1,3 +1,9 @@\n+2019-04-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* server.c: Use C++ exception handling.\n+\t* linux-low.c: Use C++ exception handling.\n+\t* gdbreplay.c: Use C++ exception handling.\n+\n 2019-04-08  Tom Tromey  <tom@tromey.com>\n \n \t* server.c (handle_btrace_general_set, handle_qxfer_btrace)"
    },
    {
      "sha": "bf566ab79422800d71f33e0415d1086c43d3cbd2",
      "filename": "gdb/gdbserver/gdbreplay.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/gdbreplay.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/gdbreplay.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/gdbreplay.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -528,11 +528,11 @@ captured_main (int argc, char *argv[])\n int\n main (int argc, char *argv[])\n {\n-  TRY\n+  try\n     {\n       captured_main (argc, argv);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       if (exception.reason == RETURN_ERROR)\n \t{\n@@ -542,7 +542,6 @@ main (int argc, char *argv[])\n \n       exit (1);\n     }\n-  END_CATCH\n \n   gdb_assert_not_reached (\"captured_main should never return\");\n }"
    },
    {
      "sha": "6ca79d5f527135f10f665842226e54bb98fac73a",
      "filename": "gdb/gdbserver/linux-low.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/linux-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/linux-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-low.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1531,7 +1531,7 @@ linux_detach_one_lwp (struct lwp_info *lwp)\n   /* Preparing to resume may try to write registers, and fail if the\n      lwp is zombie.  If that happens, ignore the error.  We'll handle\n      it below, when detach fails with ESRCH.  */\n-  TRY\n+  try\n     {\n       /* Flush any pending changes to the process's registers.  */\n       regcache_invalidate_thread (thread);\n@@ -1540,12 +1540,11 @@ linux_detach_one_lwp (struct lwp_info *lwp)\n       if (the_low_target.prepare_to_resume != NULL)\n \tthe_low_target.prepare_to_resume (lwp);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (!check_ptrace_stopped_lwp_gone (lwp))\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   lwpid = lwpid_of (thread);\n   if (ptrace (PTRACE_DETACH, lwpid, (PTRACE_TYPE_ARG3) 0,\n@@ -4508,16 +4507,15 @@ static void\n linux_resume_one_lwp (struct lwp_info *lwp,\n \t\t      int step, int signal, siginfo_t *info)\n {\n-  TRY\n+  try\n     {\n       linux_resume_one_lwp_throw (lwp, step, signal, info);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (!check_ptrace_stopped_lwp_gone (lwp))\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n }\n \n /* This function is called once per thread via for_each_thread."
    },
    {
      "sha": "99ce21e2cc7a906b9c42ab8950b09b8b151fcba1",
      "filename": "gdb/gdbserver/server.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/server.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbserver/server.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/server.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -459,7 +459,7 @@ handle_btrace_general_set (char *own_buf)\n       return -1;\n     }\n \n-  TRY\n+  try\n     {\n       if (strcmp (op, \"bts\") == 0)\n \thandle_btrace_enable_bts (thread);\n@@ -472,11 +472,10 @@ handle_btrace_general_set (char *own_buf)\n \n       write_ok (own_buf);\n     }\n-  CATCH (exception, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n     {\n       sprintf (own_buf, \"E.%s\", exception.what ());\n     }\n-  END_CATCH\n \n   return 1;\n }\n@@ -1876,18 +1875,17 @@ handle_qxfer_btrace (const char *annex,\n     {\n       buffer_free (&cache);\n \n-      TRY\n+      try\n \t{\n \t  result = target_read_btrace (thread->btrace, &cache, type);\n \t  if (result != 0)\n \t    memcpy (cs.own_buf, cache.buffer, cache.used_size);\n \t}\n-      CATCH (exception, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n \t{\n \t  sprintf (cs.own_buf, \"E.%s\", exception.what ());\n \t  result = -1;\n \t}\n-      END_CATCH\n \n       if (result != 0)\n \treturn -3;\n@@ -1948,18 +1946,17 @@ handle_qxfer_btrace_conf (const char *annex,\n     {\n       buffer_free (&cache);\n \n-      TRY\n+      try\n \t{\n \t  result = target_read_btrace_conf (thread->btrace, &cache);\n \t  if (result != 0)\n \t    memcpy (cs.own_buf, cache.buffer, cache.used_size);\n \t}\n-      CATCH (exception, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n \t{\n \t  sprintf (cs.own_buf, \"E.%s\", exception.what ());\n \t  result = -1;\n \t}\n-      END_CATCH\n \n       if (result != 0)\n \treturn -3;\n@@ -3552,18 +3549,17 @@ static int exit_code;\n static void\n detach_or_kill_for_exit_cleanup ()\n {\n-  TRY\n+  try\n     {\n       detach_or_kill_for_exit ();\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       fflush (stdout);\n       fprintf (stderr, \"Detach or kill failed: %s\\n\",\n \t       exception.what ());\n       exit_code = 1;\n     }\n-  END_CATCH\n }\n \n /* Main function.  This is called by the real \"main\" function,\n@@ -3866,7 +3862,7 @@ captured_main (int argc, char *argv[])\n \n       remote_open (port);\n \n-      TRY\n+      try\n \t{\n \t  /* Wait for events.  This will return when all event sources\n \t     are removed from the event loop.  */\n@@ -3931,7 +3927,7 @@ captured_main (int argc, char *argv[])\n \t\t}\n \t    }\n \t}\n-      CATCH (exception, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n \t{\n \t  fflush (stdout);\n \t  fprintf (stderr, \"gdbserver: %s\\n\", exception.what ());\n@@ -3945,7 +3941,6 @@ captured_main (int argc, char *argv[])\n \t  if (run_once)\n \t    throw_quit (\"Quit\");\n \t}\n-      END_CATCH\n     }\n }\n \n@@ -3955,11 +3950,11 @@ int\n main (int argc, char *argv[])\n {\n \n-  TRY\n+  try\n     {\n       captured_main (argc, argv);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       if (exception.reason == RETURN_ERROR)\n \t{\n@@ -3971,7 +3966,6 @@ main (int argc, char *argv[])\n \n       exit (exit_code);\n     }\n-  END_CATCH\n \n   gdb_assert_not_reached (\"captured_main should never return\");\n }"
    },
    {
      "sha": "373b30a423d4cb7ca536e253e171fb517bc36d2f",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2571,15 +2571,14 @@ safe_parse_type (struct gdbarch *gdbarch, char *p, int length)\n   gdb_stderr = &null_stream;\n \n   /* Call parse_and_eval_type() without fear of longjmp()s.  */\n-  TRY\n+  try\n     {\n       type = parse_and_eval_type (p, length);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       type = builtin_type (gdbarch)->builtin_void;\n     }\n-  END_CATCH\n \n   /* Stop suppressing error messages.  */\n   gdb_stderr = saved_gdb_stderr;"
    },
    {
      "sha": "01bb82bf6642680054d93a8f0020f8ab8f2468b0",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -906,16 +906,15 @@ print_one_vtable (struct gdbarch *gdbarch, struct value *value,\n       if (gdbarch_vtable_function_descriptors (gdbarch))\n \tvfn = value_addr (vfn);\n \n-      TRY\n+      try\n \t{\n \t  addr = value_as_address (vfn);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  printf_filtered (_(\"<error: %s>\"), ex.what ());\n \t  got_error = 1;\n \t}\n-      END_CATCH\n \n       if (!got_error)\n \tprint_function_pointer_address (opts, gdbarch, addr, gdb_stdout);"
    },
    {
      "sha": "0a24325ac34b242df9fedc44ced0165c9b437c72",
      "filename": "gdb/guile/guile-internal.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/guile-internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/guile-internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/guile-internal.h?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -677,15 +677,14 @@ gdbscm_wrap (Function &&func, Args &&... args)\n {\n   SCM result = SCM_BOOL_F;\n \n-  TRY\n+  try\n     {\n       result = func (std::forward<Args> (args)...);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (gdbscm_is_exception (result))\n     gdbscm_throw (result);"
    },
    {
      "sha": "6f91f88d65b7323932f9d920f0a210c68364a6bb",
      "filename": "gdb/guile/scm-block.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-block.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -680,18 +680,17 @@ gdbscm_lookup_block (SCM pc_scm)\n \n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, NULL, \"U\", pc_scm, &pc);\n \n-  TRY\n+  try\n     {\n       cust = find_pc_compunit_symtab (pc);\n \n       if (cust != NULL && COMPUNIT_OBJFILE (cust) != NULL)\n \tblock = block_for_pc (pc);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (cust == NULL || COMPUNIT_OBJFILE (cust) == NULL)\n     {"
    },
    {
      "sha": "356abca9124631a7f77d59eaa91e5ed5373329e5",
      "filename": "gdb/guile/scm-breakpoint.c",
      "status": "modified",
      "additions": 16,
      "deletions": 24,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-breakpoint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -429,7 +429,7 @@ gdbscm_register_breakpoint_x (SCM self)\n \t\t\t\t      current_language,\n \t\t\t\t      symbol_name_match_type::WILD);\n \n-  TRY\n+  try\n     {\n       int internal = bp_smob->spec.is_internal;\n \n@@ -465,11 +465,10 @@ gdbscm_register_breakpoint_x (SCM self)\n \t  gdb_assert_not_reached (\"invalid breakpoint type\");\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   /* Ensure this gets reset, even if there's an error.  */\n   pending_breakpoint_scm = SCM_BOOL_F;\n@@ -490,15 +489,14 @@ gdbscm_delete_breakpoint_x (SCM self)\n   breakpoint_smob *bp_smob\n     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       delete_breakpoint (bp_smob->bp);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return SCM_UNSPECIFIED;\n }\n@@ -588,18 +586,17 @@ gdbscm_set_breakpoint_enabled_x (SCM self, SCM newvalue)\n   SCM_ASSERT_TYPE (gdbscm_is_bool (newvalue), newvalue, SCM_ARG2, FUNC_NAME,\n \t\t   _(\"boolean\"));\n \n-  TRY\n+  try\n     {\n       if (gdbscm_is_true (newvalue))\n \tenable_breakpoint (bp_smob->bp);\n       else\n \tdisable_breakpoint (bp_smob->bp);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return SCM_UNSPECIFIED;\n }\n@@ -626,15 +623,14 @@ gdbscm_set_breakpoint_silent_x (SCM self, SCM newvalue)\n   SCM_ASSERT_TYPE (gdbscm_is_bool (newvalue), newvalue, SCM_ARG2, FUNC_NAME,\n \t\t   _(\"boolean\"));\n \n-  TRY\n+  try\n     {\n       breakpoint_set_silent (bp_smob->bp, gdbscm_is_true (newvalue));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return SCM_UNSPECIFIED;\n }\n@@ -667,15 +663,14 @@ gdbscm_set_breakpoint_ignore_count_x (SCM self, SCM newvalue)\n   if (value < 0)\n     value = 0;\n \n-  TRY\n+  try\n     {\n       set_ignore_count (bp_smob->number, (int) value, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return SCM_UNSPECIFIED;\n }\n@@ -788,15 +783,14 @@ gdbscm_set_breakpoint_task_x (SCM self, SCM newvalue)\n     {\n       id = scm_to_long (newvalue);\n \n-      TRY\n+      try\n \t{\n \t  valid_id = valid_task_id (id);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n \t}\n-      END_CATCH\n \n       if (! valid_id)\n \t{\n@@ -809,15 +803,14 @@ gdbscm_set_breakpoint_task_x (SCM self, SCM newvalue)\n   else\n     SCM_ASSERT_TYPE (0, newvalue, SCM_ARG2, FUNC_NAME, _(\"integer or #f\"));\n \n-  TRY\n+  try\n     {\n       breakpoint_set_task (bp_smob->bp, id);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return SCM_UNSPECIFIED;\n }\n@@ -975,16 +968,15 @@ gdbscm_breakpoint_commands (SCM self)\n   string_file buf;\n \n   current_uiout->redirect (&buf);\n-  TRY\n+  try\n     {\n       print_command_lines (current_uiout, breakpoint_commands (bp), 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       current_uiout->redirect (NULL);\n       gdbscm_throw_gdb_exception (except);\n     }\n-  END_CATCH\n \n   current_uiout->redirect (NULL);\n   result = gdbscm_scm_from_c_string (buf.c_str ());"
    },
    {
      "sha": "a89650b2627f7b7f7c5684e2129f77da71b0ecb9",
      "filename": "gdb/guile/scm-cmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-cmd.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -758,7 +758,7 @@ gdbscm_register_command_x (SCM self)\n   c_smob->cmd_name = gdbscm_gc_xstrdup (cmd_name);\n   xfree (cmd_name);\n \n-  TRY\n+  try\n     {\n       if (c_smob->is_prefix)\n \t{\n@@ -776,11 +776,10 @@ gdbscm_register_command_x (SCM self)\n \t\t\t c_smob->doc, cmd_list);\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* Note: At this point the command exists in gdb.\n      So no more errors after this point.  */"
    },
    {
      "sha": "584de378f531e30a7d8e0bc5bf63851b00579c2a",
      "filename": "gdb/guile/scm-disasm.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-disasm.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -247,7 +247,7 @@ gdbscm_arch_disassemble (SCM self, SCM start_scm, SCM rest)\n       int insn_len = 0;\n       string_file buf;\n \n-      TRY\n+      try\n \t{\n \t  if (using_port)\n \t    {\n@@ -257,11 +257,10 @@ gdbscm_arch_disassemble (SCM self, SCM start_scm, SCM rest)\n \t  else\n \t    insn_len = gdb_print_insn (gdbarch, pc, &buf, NULL);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n \t}\n-      END_CATCH\n \n       result = scm_cons (dascm_make_insn (pc, buf.c_str (), insn_len),\n \t\t\t result);"
    },
    {
      "sha": "9360bb90cc53267f306819996001273d982089b7",
      "filename": "gdb/guile/scm-frame.c",
      "status": "modified",
      "additions": 38,
      "deletions": 57,
      "changes": 95,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-frame.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -229,7 +229,7 @@ frscm_scm_from_frame (struct frame_info *frame, struct inferior *inferior)\n   if (*slot != NULL)\n     return (*slot)->containing_scm;\n \n-  TRY\n+  try\n     {\n       /* Try to get the previous frame, to determine if this is the last frame\n \t in a corrupt stack.  If so, we need to store the frame_id of the next\n@@ -248,11 +248,10 @@ frscm_scm_from_frame (struct frame_info *frame, struct inferior *inferior)\n \t}\n       gdbarch = get_frame_arch (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       return gdbscm_scm_from_gdb_exception (except);\n     }\n-  END_CATCH\n \n   f_scm = frscm_make_frame_smob ();\n   f_smob = (frame_smob *) SCM_SMOB_DATA (f_scm);\n@@ -397,15 +396,14 @@ gdbscm_frame_valid_p (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return scm_from_bool (frame != NULL);\n }\n@@ -425,17 +423,16 @@ gdbscm_frame_name (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tname = find_frame_funname (frame, &lang, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -463,17 +460,16 @@ gdbscm_frame_type (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \ttype = get_frame_type (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -495,15 +491,14 @@ gdbscm_frame_arch (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -526,15 +521,14 @@ gdbscm_frame_unwind_stop_reason (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -559,17 +553,16 @@ gdbscm_frame_pc (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tpc = get_frame_pc (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -592,17 +585,16 @@ gdbscm_frame_block (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tblock = get_frame_block (frame, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -643,17 +635,16 @@ gdbscm_frame_function (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tsym = find_pc_function (get_frame_address_in_block (frame));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -680,17 +671,16 @@ gdbscm_frame_older (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tprev = get_prev_frame (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -717,17 +707,16 @@ gdbscm_frame_newer (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tnext = get_next_frame (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -753,17 +742,16 @@ gdbscm_frame_sal (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tsal = find_frame_sal (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -791,7 +779,7 @@ gdbscm_frame_read_register (SCM self, SCM register_scm)\n \n   struct gdb_exception except = exception_none;\n \n-  TRY\n+  try\n     {\n       int regnum;\n \n@@ -805,11 +793,10 @@ gdbscm_frame_read_register (SCM self, SCM register_scm)\n \t    value = value_of_register (regnum, frame);\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   xfree (register_str);\n   GDBSCM_HANDLE_GDB_EXCEPTION (except);\n@@ -851,15 +838,14 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -897,7 +883,7 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \t/* N.B. Between here and the end of the scope, don't do anything\n \t   to cause a Scheme exception.  */\n \n-\tTRY\n+\ttry\n \t  {\n \t    struct block_symbol lookup_sym;\n \n@@ -908,11 +894,10 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \t    var = lookup_sym.symbol;\n \t    block = lookup_sym.block;\n \t  }\n-\tCATCH (ex, RETURN_MASK_ALL)\n+\tcatch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t  {\n \t    except = ex;\n \t  }\n-\tEND_CATCH\n       }\n \n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n@@ -928,15 +913,14 @@ gdbscm_frame_read_var (SCM self, SCM symbol_scm, SCM rest)\n \t\t       _(\"gdb:symbol or string\"));\n     }\n \n-  TRY\n+  try\n     {\n       value = read_var_value (var, block, frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return vlscm_scm_from_value (value);\n }\n@@ -952,17 +936,16 @@ gdbscm_frame_select (SCM self)\n \n   f_smob = frscm_get_frame_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n \n-  TRY\n+  try\n     {\n       frame = frscm_frame_smob_to_frame (f_smob);\n       if (frame != NULL)\n \tselect_frame (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     {\n@@ -981,15 +964,14 @@ gdbscm_newest_frame (void)\n {\n   struct frame_info *frame = NULL;\n \n-  TRY\n+  try\n     {\n       frame = get_current_frame ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return frscm_scm_from_frame_unsafe (frame, current_inferior ());\n }\n@@ -1002,15 +984,14 @@ gdbscm_selected_frame (void)\n {\n   struct frame_info *frame = NULL;\n \n-  TRY\n+  try\n     {\n       frame = get_selected_frame (_(\"No frame is currently selected\"));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return frscm_scm_from_frame_unsafe (frame, current_inferior ());\n }"
    },
    {
      "sha": "5dd386a8ab2d31f8249f63b3a5c45f38e828703b",
      "filename": "gdb/guile/scm-lazy-string.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-lazy-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-lazy-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-lazy-string.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -309,7 +309,7 @@ lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       struct type *type = tyscm_scm_to_type (ls_smob->type);\n       struct type *realtype = check_typedef (type);\n@@ -336,12 +336,11 @@ lsscm_safe_lazy_string_to_value (SCM string, int arg_pos,\n \t  break;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       *except_scmp = gdbscm_scm_from_gdb_exception (except);\n       return NULL;\n     }\n-  END_CATCH\n \n   return value;\n }"
    },
    {
      "sha": "3be9fb63158703262fd301406a3cd91bffbfd750",
      "filename": "gdb/guile/scm-math.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-math.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-math.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-math.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -723,7 +723,7 @@ vlscm_convert_typed_value_from_scheme (const char *func_name,\n \n   *except_scmp = SCM_BOOL_F;\n \n-  TRY\n+  try\n     {\n       if (vlscm_is_value (obj))\n \t{\n@@ -824,11 +824,10 @@ vlscm_convert_typed_value_from_scheme (const char *func_name,\n \t  value = NULL;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       except_scm = gdbscm_scm_from_gdb_exception (except);\n     }\n-  END_CATCH\n \n   if (gdbscm_is_true (except_scm))\n     {"
    },
    {
      "sha": "ee2971222980f95a52879fc6d1be3ed6c4333a4e",
      "filename": "gdb/guile/scm-param.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-param.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1006,7 +1006,7 @@ gdbscm_register_parameter_x (SCM self)\n \t\t_(\"parameter exists, \\\"show\\\" command is already defined\"));\n     }\n \n-  TRY\n+  try\n     {\n       add_setshow_generic (p_smob->type, p_smob->cmd_class,\n \t\t\t   p_smob->cmd_name, p_smob,\n@@ -1018,11 +1018,10 @@ gdbscm_register_parameter_x (SCM self)\n \t\t\t   set_list, show_list,\n \t\t\t   &p_smob->set_command, &p_smob->show_command);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* Note: At this point the parameter exists in gdb.\n      So no more errors after this point.  */\n@@ -1064,15 +1063,14 @@ gdbscm_parameter_value (SCM self)\n       if (name == NULL)\n \tgdbscm_throw (except_scm);\n       newarg = concat (\"show \", name.get (), (char *) NULL);\n-      TRY\n+      try\n \t{\n \t  found = lookup_cmd_composition (newarg, &alias, &prefix, &cmd);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  except = ex;\n \t}\n-      END_CATCH\n \n       xfree (newarg);\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);"
    },
    {
      "sha": "20557f8233ad993625db611aa5bbef02a8efeeb6",
      "filename": "gdb/guile/scm-ports.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-ports.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-ports.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-ports.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -272,18 +272,17 @@ ioscm_write (SCM port, const void *data, size_t size)\n   if (scm_is_eq (port, input_port_scm))\n     return;\n \n-  TRY\n+  try\n     {\n       if (scm_is_eq (port, error_port_scm))\n \tfputsn_filtered ((const char *) data, size, gdb_stderr);\n       else\n \tfputsn_filtered ((const char *) data, size, gdb_stdout);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n }\n \n /* Flush gdb's stdout or stderr.  */"
    },
    {
      "sha": "6706f826852f12545f9dd5cdfebf55f871b2785f",
      "filename": "gdb/guile/scm-pretty-print.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-pretty-print.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-pretty-print.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-pretty-print.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -524,7 +524,7 @@ ppscm_pretty_print_one_value (SCM printer, struct value **out_value,\n   SCM result = SCM_BOOL_F;\n \n   *out_value = NULL;\n-  TRY\n+  try\n     {\n       pretty_printer_worker_smob *w_smob\n \t= (pretty_printer_worker_smob *) SCM_SMOB_DATA (printer);\n@@ -558,10 +558,9 @@ ppscm_pretty_print_one_value (SCM printer, struct value **out_value,\n \t    (_(\"invalid result from pretty-printer to-string\"), result);\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n     }\n-  END_CATCH\n \n   return result;\n }"
    },
    {
      "sha": "65eb1014758c8ee3696b4576dfe019468c7578db",
      "filename": "gdb/guile/scm-symbol.c",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symbol.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -486,15 +486,14 @@ gdbscm_symbol_needs_frame_p (SCM self)\n   struct symbol *symbol = s_smob->symbol;\n   int result = 0;\n \n-  TRY\n+  try\n     {\n       result = symbol_read_needs_frame (symbol);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return scm_from_bool (result);\n }\n@@ -539,7 +538,7 @@ gdbscm_symbol_value (SCM self, SCM rest)\n \t\t\t\t _(\"cannot get the value of a typedef\"));\n     }\n \n-  TRY\n+  try\n     {\n       if (f_smob != NULL)\n \t{\n@@ -557,11 +556,10 @@ gdbscm_symbol_value (SCM self, SCM rest)\n \t can happen with nested functions).  */\n       value = read_var_value (symbol, NULL, frame_info);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return vlscm_scm_from_value (value);\n }\n@@ -604,30 +602,28 @@ gdbscm_lookup_symbol (SCM name_scm, SCM rest)\n     {\n       struct frame_info *selected_frame;\n \n-      TRY\n+      try\n \t{\n \t  selected_frame = get_selected_frame (_(\"no frame selected\"));\n \t  block = get_frame_block (selected_frame, NULL);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  xfree (name);\n \t  GDBSCM_HANDLE_GDB_EXCEPTION (ex);\n \t}\n-      END_CATCH\n     }\n \n   struct gdb_exception except = exception_none;\n-  TRY\n+  try\n     {\n       symbol = lookup_symbol (name, block, (domain_enum) domain,\n \t\t\t      &is_a_field_of_this).symbol;\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   xfree (name);\n   GDBSCM_HANDLE_GDB_EXCEPTION (except);\n@@ -656,15 +652,14 @@ gdbscm_lookup_global_symbol (SCM name_scm, SCM rest)\n \t\t\t      name_scm, &name, rest,\n \t\t\t      &domain_arg_pos, &domain);\n \n-  TRY\n+  try\n     {\n       symbol = lookup_global_symbol (name, NULL, (domain_enum) domain).symbol;\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   xfree (name);\n   GDBSCM_HANDLE_GDB_EXCEPTION (except);"
    },
    {
      "sha": "8879c321423ecb25e66fb434117d5889b999e69b",
      "filename": "gdb/guile/scm-symtab.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symtab.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -591,17 +591,16 @@ gdbscm_find_pc_line (SCM pc_scm)\n \n   gdbscm_parse_function_args (FUNC_NAME, SCM_ARG1, NULL, \"U\", pc_scm, &pc_ull);\n \n-  TRY\n+  try\n     {\n       CORE_ADDR pc = (CORE_ADDR) pc_ull;\n \n       sal = find_pc_line (pc, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return stscm_scm_from_sal (sal);\n }"
    },
    {
      "sha": "ee0bfa7e1a358bb32c02180d3120b99b8644e59d",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 24,
      "deletions": 36,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -105,19 +105,18 @@ tyscm_type_smob_type (type_smob *t_smob)\n static std::string\n tyscm_type_name (struct type *type)\n {\n-  TRY\n+  try\n     {\n       string_file stb;\n \n       LA_PRINT_TYPE (type, \"\", &stb, -1, 0, &type_print_raw_options);\n       return std::move (stb.string ());\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       SCM excp = gdbscm_scm_from_gdb_exception (except);\n       gdbscm_throw (excp);\n     }\n-  END_CATCH\n \n   gdb_assert_not_reached (\"no way to get here\");\n }\n@@ -235,15 +234,14 @@ tyscm_equal_p_type_smob (SCM type1_scm, SCM type2_scm)\n   type1 = type1_smob->type;\n   type2 = type2_smob->type;\n \n-  TRY\n+  try\n     {\n       result = types_deeply_equal (type1, type2);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return scm_from_bool (result);\n }\n@@ -629,14 +627,13 @@ gdbscm_type_sizeof (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n     }\n-  END_CATCH\n \n   /* Ignore exceptions.  */\n \n@@ -653,15 +650,14 @@ gdbscm_type_strip_typedefs (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -675,15 +671,14 @@ tyscm_get_composite (struct type *type)\n \n   for (;;)\n     {\n-      TRY\n+      try\n \t{\n \t  type = check_typedef (type);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDBSCM_HANDLE_GDB_EXCEPTION (except);\n \t}\n-      END_CATCH\n \n       if (TYPE_CODE (type) != TYPE_CODE_PTR\n \t  && TYPE_CODE (type) != TYPE_CODE_REF)\n@@ -730,17 +725,16 @@ tyscm_array_1 (SCM self, SCM n1_scm, SCM n2_scm, int is_vector,\n \t\t\t\t _(\"Array length must not be negative\"));\n     }\n \n-  TRY\n+  try\n     {\n       array = lookup_array_range_type (type, n1, n2);\n       if (is_vector)\n \tmake_vector_type (array);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (array);\n }\n@@ -787,15 +781,14 @@ gdbscm_type_pointer (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = lookup_pointer_type (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -849,15 +842,14 @@ gdbscm_type_reference (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = lookup_lvalue_reference_type (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -887,15 +879,14 @@ gdbscm_type_const (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (1, 0, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -910,15 +901,14 @@ gdbscm_type_volatile (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (0, 1, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -933,15 +923,14 @@ gdbscm_type_unqualified (SCM self)\n     = tyscm_get_type_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct type *type = t_smob->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (0, 0, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return tyscm_scm_from_type (type);\n }\n@@ -1230,7 +1219,7 @@ tyscm_lookup_typename (const char *type_name, const struct block *block)\n {\n   struct type *type = NULL;\n \n-  TRY\n+  try\n     {\n       if (startswith (type_name, \"struct \"))\n \ttype = lookup_struct (type_name + 7, NULL);\n@@ -1242,11 +1231,10 @@ tyscm_lookup_typename (const char *type_name, const struct block *block)\n \ttype = lookup_typename (current_language, get_current_arch (),\n \t\t\t\ttype_name, block, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       return NULL;\n     }\n-  END_CATCH\n \n   return type;\n }"
    },
    {
      "sha": "7f119a202ed8e84c11cf0f00c88eeafa6bc5397e",
      "filename": "gdb/guile/scm-value.c",
      "status": "modified",
      "additions": 30,
      "deletions": 45,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/guile/scm-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-value.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -156,18 +156,17 @@ vlscm_print_value_smob (SCM self, SCM port, scm_print_state *pstate)\n      instead of writingp.  */\n   opts.raw = !!pstate->writingp;\n \n-  TRY\n+  try\n     {\n       string_file stb;\n \n       common_val_print (v_smob->value, &stb, 0, &opts, current_language);\n       scm_puts (stb.c_str (), port);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (pstate->writingp)\n     scm_puts (\">\", port);\n@@ -187,15 +186,14 @@ vlscm_equal_p_value_smob (SCM v1, SCM v2)\n   const value_smob *v2_smob = (value_smob *) SCM_SMOB_DATA (v2);\n   int result = 0;\n \n-  TRY\n+  try\n     {\n       result = value_equal (v1_smob->value, v2_smob->value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return scm_from_bool (result);\n }\n@@ -392,14 +390,13 @@ gdbscm_value_address (SCM self)\n \n \t  SCM address = SCM_BOOL_F;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      address = vlscm_scm_from_value (value_addr (value));\n \t    }\n-\t  CATCH (except, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t    {\n \t    }\n-\t  END_CATCH\n \n \t  if (gdbscm_is_exception (address))\n \t    return address;\n@@ -496,7 +493,7 @@ gdbscm_value_dynamic_type (SCM self)\n   if (! SCM_UNBNDP (v_smob->dynamic_type))\n     return v_smob->dynamic_type;\n \n-  TRY\n+  try\n     {\n       scoped_value_mark free_values;\n \n@@ -532,11 +529,10 @@ gdbscm_value_dynamic_type (SCM self)\n \t  type = NULL;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (type == NULL)\n     v_smob->dynamic_type = gdbscm_value_type (self);\n@@ -684,15 +680,14 @@ gdbscm_value_call (SCM self, SCM args)\n   long args_count;\n   struct value **vargs = NULL;\n \n-  TRY\n+  try\n     {\n       ftype = check_typedef (value_type (function));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   SCM_ASSERT_TYPE (TYPE_CODE (ftype) == TYPE_CODE_FUNC, self,\n \t\t   SCM_ARG1, FUNC_NAME,\n@@ -751,17 +746,16 @@ gdbscm_value_to_bytevector (SCM self)\n \n   type = value_type (value);\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n       length = TYPE_LENGTH (type);\n       contents = value_contents (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   bv = scm_c_make_bytevector (length);\n   memcpy (SCM_BYTEVECTOR_CONTENTS (bv), contents, length);\n@@ -795,31 +789,29 @@ gdbscm_value_to_bool (SCM self)\n \n   type = value_type (value);\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   SCM_ASSERT_TYPE (is_intlike (type, 1), self, SCM_ARG1, FUNC_NAME,\n \t\t   _(\"integer-like gdb value\"));\n \n-  TRY\n+  try\n     {\n       if (TYPE_CODE (type) == TYPE_CODE_PTR)\n \tl = value_as_address (value);\n       else\n \tl = value_as_long (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return scm_from_bool (l != 0);\n }\n@@ -838,31 +830,29 @@ gdbscm_value_to_integer (SCM self)\n \n   type = value_type (value);\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   SCM_ASSERT_TYPE (is_intlike (type, 1), self, SCM_ARG1, FUNC_NAME,\n \t\t   _(\"integer-like gdb value\"));\n \n-  TRY\n+  try\n     {\n       if (TYPE_CODE (type) == TYPE_CODE_PTR)\n \tl = value_as_address (value);\n       else\n \tl = value_as_long (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (TYPE_UNSIGNED (type))\n     return gdbscm_scm_from_ulongest (l);\n@@ -885,20 +875,19 @@ gdbscm_value_to_real (SCM self)\n \n   type = value_type (value);\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   SCM_ASSERT_TYPE (is_intlike (type, 0) || TYPE_CODE (type) == TYPE_CODE_FLT,\n \t\t   self, SCM_ARG1, FUNC_NAME, _(\"number\"));\n \n-  TRY\n+  try\n     {\n       if (is_floating_value (value))\n \t{\n@@ -916,11 +905,10 @@ gdbscm_value_to_real (SCM self)\n \t  check = value_from_longest (type, (LONGEST) d);\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* TODO: Is there a better way to check if the value fits?  */\n   if (!value_equal (value, check))\n@@ -1004,18 +992,17 @@ gdbscm_value_to_string (SCM self, SCM rest)\n   /* We don't assume anything about the result of scm_port_conversion_strategy.\n      From this point on, if errors is not 'errors, use 'substitute.  */\n \n-  TRY\n+  try\n     {\n       gdb::unique_xmalloc_ptr<gdb_byte> buffer;\n       LA_GET_STRING (value, &buffer, &length, &char_type, &la_encoding);\n       buffer_contents = buffer.release ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       xfree (encoding);\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* If errors is \"error\", scm_from_stringn may throw a Scheme exception.\n      Make sure we don't leak.  This is done via scm_dynwind_begin, et.al.  */\n@@ -1077,7 +1064,7 @@ gdbscm_value_to_lazy_string (SCM self, SCM rest)\n \t\t\t\t _(\"invalid length\"));\n     }\n \n-  TRY\n+  try\n     {\n       scoped_value_mark free_values;\n \n@@ -1132,11 +1119,10 @@ gdbscm_value_to_lazy_string (SCM self, SCM rest)\n \n       result = lsscm_make_lazy_string (addr, length, encoding, type);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   xfree (encoding);\n   GDBSCM_HANDLE_GDB_EXCEPTION (except);\n@@ -1191,15 +1177,14 @@ gdbscm_value_print (SCM self)\n \n   string_file stb;\n \n-  TRY\n+  try\n     {\n       common_val_print (value, &stb, 0, &opts, current_language);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDBSCM_HANDLE_GDB_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* Use SCM_FAILED_CONVERSION_QUESTION_MARK to ensure this doesn't\n      throw an error if the encoding fails."
    },
    {
      "sha": "01bfb2c4c20c8bb5aafeaca58566c18a91df36f4",
      "filename": "gdb/i386-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/i386-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/i386-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -402,7 +402,7 @@ i386_linux_handle_segmentation_fault (struct gdbarch *gdbarch,\n   if (!i386_mpx_enabled ())\n     return;\n \n-  TRY\n+  try\n     {\n       /* Sigcode evaluates if the actual segfault is a boundary violation.  */\n       sig_code = parse_and_eval_long (\"$_siginfo.si_code\\n\");\n@@ -414,11 +414,10 @@ i386_linux_handle_segmentation_fault (struct gdbarch *gdbarch,\n       access\n         = parse_and_eval_long (\"$_siginfo._sifields._sigfault.si_addr\");\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       return;\n     }\n-  END_CATCH\n \n   /* If this is not a boundary violation just return.  */\n   if (sig_code != SIG_CODE_BONDARY_FAULT)"
    },
    {
      "sha": "27f2edf97b552fc8211c6f3cf9cbba3c2d36d5d3",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2082,16 +2082,15 @@ i386_frame_cache (struct frame_info *this_frame, void **this_cache)\n   cache = i386_alloc_frame_cache ();\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       i386_frame_cache_1 (this_frame, cache);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }\n@@ -2252,7 +2251,7 @@ i386_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n   cache = i386_alloc_frame_cache ();\n   *this_cache = cache;\n \n-  TRY\n+  try\n     {\n       cache->pc = get_frame_func (this_frame);\n \n@@ -2266,12 +2265,11 @@ i386_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n       cache->base_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }\n@@ -2438,7 +2436,7 @@ i386_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n   cache = i386_alloc_frame_cache ();\n \n-  TRY\n+  try\n     {\n       get_frame_register (this_frame, I386_ESP_REGNUM, buf);\n       cache->base = extract_unsigned_integer (buf, 4, byte_order) - 4;\n@@ -2462,12 +2460,11 @@ i386_sigtramp_frame_cache (struct frame_info *this_frame, void **this_cache)\n \n       cache->base_p = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   *this_cache = cache;\n   return cache;"
    },
    {
      "sha": "0aca863490a687c96136f028e26b909b8641d559",
      "filename": "gdb/inf-loop.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/inf-loop.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/inf-loop.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-loop.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -67,11 +67,11 @@ inferior_event_handler (enum inferior_event_type event_type,\n \t  /* Don't propagate breakpoint commands errors.  Either we're\n \t     stopping or some command resumes the inferior.  The user will\n \t     be informed.  */\n-\t  TRY\n+\t  try\n \t    {\n \t      bpstat_do_actions ();\n \t    }\n-\t  CATCH (e, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &e)\n \t    {\n \t      /* If the user was running a foreground execution\n \t\t command, then propagate the error so that the prompt\n@@ -83,7 +83,6 @@ inferior_event_handler (enum inferior_event_type event_type,\n \t      else\n \t\texception_print (gdb_stderr, e);\n \t    }\n-\t  END_CATCH\n \t}\n       break;\n "
    },
    {
      "sha": "0e5b6aa13270c866fa1cce5a5bdb1a4311d66e70",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -597,19 +597,18 @@ run_inferior_call (struct call_thread_fsm *sm,\n   /* We want to print return value, please...  */\n   call_thread->control.proceed_to_finish = 1;\n \n-  TRY\n+  try\n     {\n       proceed (real_pc, GDB_SIGNAL_0);\n \n       /* Inferior function calls are always synchronous, even if the\n \t target supports asynchronous execution.  */\n       wait_sync_command_done ();\n     }\n-  CATCH (e, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &e)\n     {\n       caught_error = e;\n     }\n-  END_CATCH\n \n   /* If GDB has the prompt blocked before, then ensure that it remains\n      so.  normal_stop calls async_enable_stdin, so reset the prompt"
    },
    {
      "sha": "2b24fae86df39a4acdd18baef71a4297c0687c43",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -447,16 +447,15 @@ post_create_inferior (struct target_ops *target, int from_tty)\n   thread_info *thr = inferior_thread ();\n \n   thr->suspend.stop_pc = 0;\n-  TRY\n+  try\n     {\n       thr->suspend.stop_pc = regcache_read_pc (get_current_regcache ());\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   if (exec_bfd)\n     {\n@@ -1646,18 +1645,17 @@ print_return_value (struct ui_out *uiout, struct return_value_info *rv)\n       || TYPE_CODE (check_typedef (rv->type)) == TYPE_CODE_VOID)\n     return;\n \n-  TRY\n+  try\n     {\n       /* print_return_value_1 can throw an exception in some\n \t circumstances.  We need to catch this so that we still\n \t delete the breakpoint.  */\n       print_return_value_1 (uiout, rv);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stdout, ex);\n     }\n-  END_CATCH\n }\n \n /* Data for the FSM that manages the finish command.  */"
    },
    {
      "sha": "9bda7fca81d0b961a52d67fe22dc71bd122eccb3",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 14,
      "deletions": 21,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1776,11 +1776,11 @@ displaced_step_prepare (thread_info *thread)\n {\n   int prepared = -1;\n \n-  TRY\n+  try\n     {\n       prepared = displaced_step_prepare_throw (thread);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       struct displaced_step_inferior_state *displaced_state;\n \n@@ -1808,7 +1808,6 @@ displaced_step_prepare (thread_info *thread)\n \t= get_displaced_stepping_state (thread->inf);\n       displaced_state->failed_before = 1;\n     }\n-  END_CATCH\n \n   return prepared;\n }\n@@ -2612,11 +2611,11 @@ resume_1 (enum gdb_signal sig)\n static void\n resume (gdb_signal sig)\n {\n-  TRY\n+  try\n     {\n       resume_1 (sig);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* If resuming is being aborted for any reason, delete any\n \t single-step breakpoint resume_1 may have created, to avoid\n@@ -2627,7 +2626,6 @@ resume (gdb_signal sig)\n \tdelete_single_step_breakpoints (inferior_thread ());\n       throw_exception (ex);\n     }\n-  END_CATCH\n }\n \n \f\n@@ -7270,7 +7268,7 @@ insert_exception_resume_breakpoint (struct thread_info *tp,\n \t\t\t\t    struct frame_info *frame,\n \t\t\t\t    struct symbol *sym)\n {\n-  TRY\n+  try\n     {\n       struct block_symbol vsym;\n       struct value *value;\n@@ -7301,11 +7299,10 @@ insert_exception_resume_breakpoint (struct thread_info *tp,\n \t  inferior_thread ()->control.exception_resume_breakpoint = bp;\n \t}\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       /* We want to ignore errors here.  */\n     }\n-  END_CATCH\n }\n \n /* A helper for check_exception_resume that sets an\n@@ -7364,7 +7361,7 @@ check_exception_resume (struct execution_control_state *ecs,\n   if (!func)\n     return;\n \n-  TRY\n+  try\n     {\n       const struct block *b;\n       struct block_iterator iter;\n@@ -7401,10 +7398,9 @@ check_exception_resume (struct execution_control_state *ecs,\n \t    }\n \t}\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n     }\n-  END_CATCH\n }\n \n static void\n@@ -7531,18 +7527,17 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \tstop_all_threads ();\n \n       /* Stop stepping if inserting breakpoints fails.  */\n-      TRY\n+      try\n \t{\n \t  insert_breakpoints ();\n \t}\n-      CATCH (e, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t{\n \t  exception_print (gdb_stderr, e);\n \t  stop_waiting (ecs);\n \t  clear_step_over_info ();\n \t  return;\n \t}\n-      END_CATCH\n \n       ecs->event_thread->control.trap_expected = (remove_bp || remove_wps);\n \n@@ -8064,16 +8059,15 @@ normal_stop (void)\n     {\n       stop_context saved_context;\n \n-      TRY\n+      try\n \t{\n \t  execute_cmd_pre_hook (stop_command);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  exception_fprintf (gdb_stderr, ex,\n \t\t\t     \"Error while running hook_stop:\\n\");\n \t}\n-      END_CATCH\n \n       /* If the stop hook resumes the target, then there's no point in\n \t trying to notify about the previous stop; its context is\n@@ -8770,19 +8764,18 @@ restore_infcall_control_state (struct infcall_control_state *inf_status)\n       /* The point of the try/catch is that if the stack is clobbered,\n          walking the stack might encounter a garbage pointer and\n          error() trying to dereference it.  */\n-      TRY\n+      try\n \t{\n \t  restore_selected_frame (inf_status->selected_frame_id);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  exception_fprintf (gdb_stderr, ex,\n \t\t\t     \"Unable to restore previously selected frame:\\n\");\n \t  /* Error in restoring the selected frame.  Select the\n \t     innermost frame.  */\n \t  select_frame (get_current_frame ());\n \t}\n-      END_CATCH\n     }\n \n   delete inf_status;"
    },
    {
      "sha": "1b78a93653c734baca0f23a003146a5b9134d250",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -849,17 +849,16 @@ jit_reader_try_read_symtab (struct jit_code_entry *code_entry,\n   gdb_mem = (gdb_byte *) xmalloc (code_entry->symfile_size);\n \n   status = 1;\n-  TRY\n+  try\n     {\n       if (target_read_memory (code_entry->symfile_addr, gdb_mem,\n \t\t\t      code_entry->symfile_size))\n \tstatus = 0;\n     }\n-  CATCH (e, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &e)\n     {\n       status = 0;\n     }\n-  END_CATCH\n \n   if (status)\n     {"
    },
    {
      "sha": "0dc4cb301190e88ce74430ea37dd397eeac2fc56",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -172,18 +172,17 @@ set_language_command (const char *ignore,\n \t      /* Enter auto mode.  Set to the current frame's language, if\n                  known, or fallback to the initial language.  */\n \t      language_mode = language_mode_auto;\n-\t      TRY\n+\t      try\n \t\t{\n \t\t  struct frame_info *frame;\n \n \t\t  frame = get_selected_frame (NULL);\n \t\t  flang = get_frame_language (frame);\n \t\t}\n-\t      CATCH (ex, RETURN_MASK_ERROR)\n+\t      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t\t{\n \t\t  flang = language_unknown;\n \t\t}\n-\t      END_CATCH\n \n \t      if (flang != language_unknown)\n \t\tset_language (flang);"
    },
    {
      "sha": "04eb93857152b0dc1140d263a4985603fd016867",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2383,16 +2383,15 @@ convert_explicit_location_to_linespec (struct linespec_state *self,\n \n   if (source_filename != NULL)\n     {\n-      TRY\n+      try\n \t{\n \t  *result->file_symtabs\n \t    = symtabs_from_filename (source_filename, self->search_pspace);\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  source_file_not_found_error (source_filename);\n \t}\n-      END_CATCH\n       result->explicit_loc.source_filename = xstrdup (source_filename);\n     }\n   else\n@@ -2608,17 +2607,16 @@ parse_linespec (linespec_parser *parser, const char *arg,\n       gdb::unique_xmalloc_ptr<char> user_filename = copy_token_string (token);\n \n       /* Check if the input is a filename.  */\n-      TRY\n+      try\n \t{\n \t  *PARSER_RESULT (parser)->file_symtabs\n \t    = symtabs_from_filename (user_filename.get (),\n \t\t\t\t     PARSER_STATE (parser)->search_pspace);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  file_exception = ex;\n \t}\n-      END_CATCH\n \n       if (file_exception.reason >= 0)\n \t{\n@@ -2923,7 +2921,7 @@ linespec_complete_label (completion_tracker &tracker,\n \n   line_offset unknown_offset = { 0, LINE_OFFSET_UNKNOWN };\n \n-  TRY\n+  try\n     {\n       convert_explicit_location_to_linespec (PARSER_STATE (&parser),\n \t\t\t\t\t     PARSER_RESULT (&parser),\n@@ -2932,11 +2930,10 @@ linespec_complete_label (completion_tracker &tracker,\n \t\t\t\t\t     func_name_match_type,\n \t\t\t\t\t     NULL, unknown_offset);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       return;\n     }\n-  END_CATCH\n \n   complete_label (tracker, &parser, label_name);\n }\n@@ -2959,14 +2956,13 @@ linespec_complete (completion_tracker &tracker, const char *text,\n \n   /* Parse as much as possible.  parser.completion_word will hold\n      furthest completion point we managed to parse to.  */\n-  TRY\n+  try\n     {\n       parse_linespec (&parser, text, match_type);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n     }\n-  END_CATCH\n \n   if (parser.completion_quote_char != '\\0'\n       && parser.completion_quote_end != NULL\n@@ -3148,17 +3144,16 @@ event_location_to_sals (linespec_parser *parser,\n     case LINESPEC_LOCATION:\n       {\n \tPARSER_STATE (parser)->is_linespec = 1;\n-\tTRY\n+\ttry\n \t  {\n \t    const linespec_location *ls = get_linespec_location (location);\n \t    result = parse_linespec (parser,\n \t\t\t\t     ls->spec_string, ls->match_type);\n \t  }\n-\tCATCH (except, RETURN_MASK_ERROR)\n+\tcatch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t  {\n \t    throw_exception (except);\n \t  }\n-\tEND_CATCH\n       }\n       break;\n \n@@ -3959,7 +3954,7 @@ find_linespec_symbols (struct linespec_state *state,\n       if (!classes.empty ())\n \t{\n \t  /* Now locate a list of suitable methods named METHOD.  */\n-\t  TRY\n+\t  try\n \t    {\n \t      find_method (state, file_symtabs,\n \t\t\t   klass.c_str (), method.c_str (),\n@@ -3968,12 +3963,11 @@ find_linespec_symbols (struct linespec_state *state,\n \n \t  /* If successful, we're done.  If NOT_FOUND_ERROR\n \t     was not thrown, rethrow the exception that we did get.  */\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      if (except.error != NOT_FOUND_ERROR)\n \t\tthrow_exception (except);\n \t    }\n-\t  END_CATCH\n \t}\n     }\n }"
    },
    {
      "sha": "229f660eb919320440d68e9648019125f5bb348b",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -427,19 +427,18 @@ class scoped_switch_fork_info\n     if (m_oldfp != nullptr)\n       {\n \t/* Switch back to inferior_ptid.  */\n-\tTRY\n+\ttry\n \t  {\n \t    remove_breakpoints ();\n \t    fork_load_infrun_state (m_oldfp);\n \t    insert_breakpoints ();\n \t  }\n-\tCATCH (ex, RETURN_MASK_ALL)\n+\tcatch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t  {\n \t    warning (_(\"Couldn't restore checkpoint state in %s: %s\"),\n \t\t     target_pid_to_str (m_oldfp->ptid).c_str (),\n \t\t     ex.what ());\n \t  }\n-\tEND_CATCH\n       }\n   }\n "
    },
    {
      "sha": "c2eb55f7d86c535690c5f5acd5cbff94f63538be",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1188,11 +1188,11 @@ linux_nat_target::attach (const char *args, int from_tty)\n   /* Make sure we report all signals during attach.  */\n   pass_signals ({});\n \n-  TRY\n+  try\n     {\n       inf_ptrace_target::attach (args, from_tty);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       pid_t pid = parse_pid_to_attach (args);\n       std::string reason = linux_ptrace_attach_fail_reason (pid);\n@@ -1203,7 +1203,6 @@ linux_nat_target::attach (const char *args, int from_tty)\n       else\n \tthrow_error (ex.error, \"%s\", ex.what ());\n     }\n-  END_CATCH\n \n   /* The ptrace base target adds the main thread with (pid,0,0)\n      format.  Decorate it with lwp info.  */\n@@ -1402,16 +1401,15 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n   /* Preparing to resume may try to write registers, and fail if the\n      lwp is zombie.  If that happens, ignore the error.  We'll handle\n      it below, when detach fails with ESRCH.  */\n-  TRY\n+  try\n     {\n       linux_target->low_prepare_to_resume (lp);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (!check_ptrace_stopped_lwp_gone (lp))\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   if (ptrace (PTRACE_DETACH, lwpid, 0, signo) < 0)\n     {\n@@ -1585,16 +1583,15 @@ check_ptrace_stopped_lwp_gone (struct lwp_info *lp)\n static void\n linux_resume_one_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n {\n-  TRY\n+  try\n     {\n       linux_resume_one_lwp_throw (lp, step, signo);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (!check_ptrace_stopped_lwp_gone (lp))\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n }\n \n /* Resume LP.  */\n@@ -3526,7 +3523,7 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n       struct regcache *regcache = get_thread_regcache (lp->ptid);\n       struct gdbarch *gdbarch = regcache->arch ();\n \n-      TRY\n+      try\n \t{\n \t  CORE_ADDR pc = regcache_read_pc (regcache);\n \t  int leave_stopped = 0;\n@@ -3552,12 +3549,11 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n \t      linux_resume_one_lwp_throw (lp, lp->step, GDB_SIGNAL_0);\n \t    }\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  if (!check_ptrace_stopped_lwp_gone (lp))\n \t    throw_exception (ex);\n \t}\n-      END_CATCH\n     }\n \n   return 0;"
    },
    {
      "sha": "ccc5d17015c6d5db31274a475f6d0659a1639d35",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1926,15 +1926,14 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n     }\n \n   /* Thread register information.  */\n-  TRY\n+  try\n     {\n       update_thread_list ();\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n       exception_print (gdb_stderr, e);\n     }\n-  END_CATCH\n \n   /* Like the kernel, prefer dumping the signalled thread first.\n      \"First thread\" is what tools use to infer the signalled thread."
    },
    {
      "sha": "e1b2ae6f4b811d03f4f6dbea3e27eb4523165c6c",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -497,12 +497,12 @@ static int\n thread_db_find_new_threads_silently (thread_info *stopped)\n {\n \n-  TRY\n+  try\n     {\n       thread_db_find_new_threads_2 (stopped, true);\n     }\n \n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (libthread_db_debug)\n \texception_fprintf (gdb_stdlog, except,\n@@ -532,7 +532,6 @@ thread_db_find_new_threads_silently (thread_info *stopped)\n \t  return 1;\n \t}\n     }\n-  END_CATCH\n \n   return 0;\n }\n@@ -757,7 +756,7 @@ check_thread_db (struct thread_db_info *info, bool log_progress)\n      fail.  */\n   linux_stop_and_wait_all_lwps ();\n \n-  TRY\n+  try\n     {\n       td_err_e err = td_ta_thr_iter_p (info->thread_agent,\n \t\t\t\t       check_thread_db_callback,\n@@ -773,7 +772,7 @@ check_thread_db (struct thread_db_info *info, bool log_progress)\n       if (!tdb_testinfo->threads_seen)\n \terror (_(\"no threads seen\"));\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (warning_pre_print)\n \tfputs_unfiltered (warning_pre_print, gdb_stderr);\n@@ -783,7 +782,6 @@ check_thread_db (struct thread_db_info *info, bool log_progress)\n \n       test_passed = false;\n     }\n-  END_CATCH\n \n   if (test_passed && log_progress)\n     debug_printf (_(\"libthread_db integrity checks passed.\\n\"));\n@@ -1509,7 +1507,7 @@ find_new_threads_once (struct thread_db_info *info, int iteration,\n   /* See comment in thread_db_update_thread_list.  */\n   gdb_assert (info->td_ta_thr_iter_p != NULL);\n \n-  TRY\n+  try\n     {\n       /* Iterate over all user-space threads to discover new threads.  */\n       err = info->td_ta_thr_iter_p (info->thread_agent,\n@@ -1520,15 +1518,14 @@ find_new_threads_once (struct thread_db_info *info, int iteration,\n \t\t\t\t    TD_SIGNO_MASK,\n \t\t\t\t    TD_THR_ANY_USER_FLAGS);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       if (libthread_db_debug)\n \t{\n \t  exception_fprintf (gdb_stdlog, except,\n \t\t\t     \"Warning: find_new_threads_once: \");\n \t}\n     }\n-  END_CATCH\n \n   if (libthread_db_debug)\n     {"
    },
    {
      "sha": "8abd9defac58515e8187aecda85f72fe4aa074d3",
      "filename": "gdb/main.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/main.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -365,19 +365,18 @@ static int\n catch_command_errors (catch_command_errors_const_ftype command,\n \t\t      const char *arg, int from_tty)\n {\n-  TRY\n+  try\n     {\n       int was_sync = current_ui->prompt_state == PROMPT_BLOCKED;\n \n       command (arg, from_tty);\n \n       maybe_wait_sync_command_done (was_sync);\n     }\n-  CATCH (e, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &e)\n     {\n       return handle_command_errors (e);\n     }\n-  END_CATCH\n \n   return 1;\n }\n@@ -1169,31 +1168,29 @@ captured_main (void *data)\n      change - SET_TOP_LEVEL() - has been eliminated.  */\n   while (1)\n     {\n-      TRY\n+      try\n \t{\n \t  captured_command_loop ();\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  exception_print (gdb_stderr, ex);\n \t}\n-      END_CATCH\n     }\n   /* No exit -- exit is through quit_command.  */\n }\n \n int\n gdb_main (struct captured_main_args *args)\n {\n-  TRY\n+  try\n     {\n       captured_main (args);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   /* The only way to end up here is by an error (normal exit is\n      handled by quit_force()), hence always return an error status.  */"
    },
    {
      "sha": "bf35891589431a1dab508036ca12599d6396fdf0",
      "filename": "gdb/mi/mi-cmd-break.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-cmd-break.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-cmd-break.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-break.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -54,15 +54,14 @@ breakpoint_notify (struct breakpoint *b)\n {\n   if (mi_can_breakpoint_notify)\n     {\n-      TRY\n+      try\n \t{\n \t  print_breakpoint (b);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  exception_print (gdb_stderr, ex);\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "c689d49d230ecabfb6e0d910b98fd1595555e056",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -531,7 +531,7 @@ list_arg_or_local (const struct frame_arg *arg, enum what_to_list what,\n \tstb.printf (_(\"<error reading variable: %s>\"), arg->error);\n       else\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      struct value_print_options opts;\n \n@@ -540,12 +540,11 @@ list_arg_or_local (const struct frame_arg *arg, enum what_to_list what,\n \t      common_val_print (arg->val, &stb, 0, &opts,\n \t\t\t\tlanguage_def (SYMBOL_LANGUAGE (arg->sym)));\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      stb.printf (_(\"<error reading variable: %s>\"),\n \t\t\t  except.what ());\n \t    }\n-\t  END_CATCH\n \t}\n       uiout->field_stream (\"value\", stb);\n     }"
    },
    {
      "sha": "26dfc4a5385766ed6637401f29e8e1eaed05c8d4",
      "filename": "gdb/mi/mi-interp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-interp.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -823,18 +823,17 @@ mi_print_breakpoint_for_event (struct mi_interp *mi, breakpoint *bp)\n      ui_out_redirect.  */\n   mi_uiout->redirect (mi->event_channel);\n \n-  TRY\n+  try\n     {\n       scoped_restore restore_uiout\n \t= make_scoped_restore (&current_uiout, mi_uiout);\n \n       print_breakpoint (bp);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   mi_uiout->redirect (NULL);\n }"
    },
    {
      "sha": "33cd1f89c42dbe887b397b72477fc7d569d179d2",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1938,16 +1938,15 @@ mi_execute_command (const char *cmd, int from_tty)\n \n   target_log_command (cmd);\n \n-  TRY\n+  try\n     {\n       command = mi_parse (cmd, &token);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       mi_print_exception (token, exception);\n       xfree (token);\n     }\n-  END_CATCH\n \n   if (command != NULL)\n     {\n@@ -1966,11 +1965,11 @@ mi_execute_command (const char *cmd, int from_tty)\n \t  timestamp (command->cmd_start);\n \t}\n \n-      TRY\n+      try\n \t{\n \t  captured_mi_execute_command (current_uiout, command.get ());\n \t}\n-      CATCH (result, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &result)\n \t{\n \t  /* Like in start_event_loop, enable input and force display\n \t     of the prompt.  Otherwise, any command that calls\n@@ -1984,7 +1983,6 @@ mi_execute_command (const char *cmd, int from_tty)\n \t  mi_print_exception (command->token, result);\n \t  mi_out_rewind (current_uiout);\n \t}\n-      END_CATCH\n \n       bpstat_do_actions ();\n "
    },
    {
      "sha": "20e279020841b1a3d56c9f0efb09cd468ef5ade7",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1297,18 +1297,17 @@ find_objc_msgcall_submethod (int (*f) (CORE_ADDR, CORE_ADDR *),\n \t\t\t     CORE_ADDR pc, \n \t\t\t     CORE_ADDR *new_pc)\n {\n-  TRY\n+  try\n     {\n       if (f (pc, new_pc) == 0)\n \treturn 1;\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_fprintf (gdb_stderr, ex,\n \t\t\t \"Unable to determine target of \"\n \t\t\t \"Objective-C method call (ignoring):\\n\");\n     }\n-  END_CATCH\n \n   return 0;\n }"
    },
    {
      "sha": "5b0b9dcf9aab473585a90e944454f519ac14bda5",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -751,18 +751,17 @@ pascal_object_print_value (struct type *type, const gdb_byte *valaddr,\n \n       thisoffset = offset;\n \n-      TRY\n+      try\n \t{\n \t  boffset = baseclass_offset (type, i, valaddr, offset, address, val);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  if (ex.error == NOT_AVAILABLE_ERROR)\n \t    skip = -1;\n \t  else\n \t    skip = 1;\n \t}\n-      END_CATCH\n \n       if (skip == 0)\n \t{"
    },
    {
      "sha": "5ae1cb96a97b392d8605bc06ca11a147400864ed",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1137,19 +1137,18 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n   scoped_restore_current_language lang_saver;\n   set_language (lang->la_language);\n \n-  TRY\n+  try\n     {\n       lang->la_parser (&ps);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       /* If parsing for completion, allow this to succeed; but if no\n \t expression elements have been written, then there's nothing\n \t to do, so fail.  */\n       if (! ps.parse_completion || ps.expout_ptr == 0)\n \tthrow_exception (except);\n     }\n-  END_CATCH\n \n   /* We have to operate on an \"expression *\", due to la_post_parser,\n      which explains this funny-looking double release.  */\n@@ -1224,16 +1223,15 @@ parse_expression_for_completion (const char *string,\n   int subexp;\n   expr_completion_state cstate;\n \n-  TRY\n+  try\n     {\n       exp = parse_exp_in_context (&string, 0, 0, 0, 0, &subexp,\n \t\t\t\t  nullptr, &cstate);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       /* Nothing, EXP remains NULL.  */\n     }\n-  END_CATCH\n \n   if (exp == NULL)\n     return NULL;"
    },
    {
      "sha": "e2ead9d97b0a8f82fff29b89dbb0e23966f1a8c1",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1827,7 +1827,7 @@ ppc_linux_spe_context (int wordsize, enum bfd_endian byte_order,\n     {\n       struct target_ops *target = current_top_target ();\n \n-      TRY\n+      try\n \t{\n \t  /* We do not call target_translate_tls_address here, because\n \t     svr4_fetch_objfile_link_map may invalidate the frame chain,\n@@ -1842,11 +1842,10 @@ ppc_linux_spe_context (int wordsize, enum bfd_endian byte_order,\n \t  spe_context_cache_ptid = inferior_ptid;\n \t}\n \n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  return 0;\n \t}\n-      END_CATCH\n     }\n \n   /* Read variable value.  */"
    },
    {
      "sha": "8b6f1ca0323ee3ace1840f7039d3f38fe6da6b13",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1881,21 +1881,20 @@ do_one_display (struct display *d)\n   if (d->exp == NULL)\n     {\n \n-      TRY\n+      try\n \t{\n \t  innermost_block_tracker tracker;\n \t  d->exp = parse_expression (d->exp_string, &tracker);\n \t  d->block = tracker.block ();\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  /* Can't re-parse the expression.  Disable this display item.  */\n \t  d->enabled_p = 0;\n \t  warning (_(\"Unable to display \\\"%s\\\": %s\"),\n \t\t   d->exp_string, ex.what ());\n \t  return;\n \t}\n-      END_CATCH\n     }\n \n   if (d->block)\n@@ -1942,7 +1941,7 @@ do_one_display (struct display *d)\n \n       annotate_display_value ();\n \n-      TRY\n+      try\n         {\n \t  struct value *val;\n \t  CORE_ADDR addr;\n@@ -1953,12 +1952,11 @@ do_one_display (struct display *d)\n \t    addr = gdbarch_addr_bits_remove (d->exp->gdbarch, addr);\n \t  do_examine (d->format, d->exp->gdbarch, addr);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  fprintf_filtered (gdb_stdout, _(\"<error: %s>\\n\"),\n \t\t\t    ex.what ());\n \t}\n-      END_CATCH\n     }\n   else\n     {\n@@ -1981,18 +1979,17 @@ do_one_display (struct display *d)\n       get_formatted_print_options (&opts, d->format.format);\n       opts.raw = d->format.raw;\n \n-      TRY\n+      try\n         {\n \t  struct value *val;\n \n \t  val = evaluate_expression (d->exp.get ());\n \t  print_formatted (val, d->format.size, &opts, gdb_stdout);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  fprintf_filtered (gdb_stdout, _(\"<error: %s>\"), ex.what ());\n \t}\n-      END_CATCH\n \n       printf_filtered (\"\\n\");\n     }\n@@ -2174,7 +2171,7 @@ print_variable_and_value (const char *name, struct symbol *var,\n   fputs_styled (name, variable_name_style.style (), stream);\n   fputs_filtered (\" = \", stream);\n \n-  TRY\n+  try\n     {\n       struct value *val;\n       struct value_print_options opts;\n@@ -2192,12 +2189,11 @@ print_variable_and_value (const char *name, struct symbol *var,\n \t function.  */\n       frame = NULL;\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       fprintf_filtered (stream, \"<error reading variable %s (%s)>\", name,\n \t\t\texcept.what ());\n     }\n-  END_CATCH\n \n   fprintf_filtered (stream, \"\\n\");\n }"
    },
    {
      "sha": "c7c6faea5cd437570bd292f33ce218983f435dda",
      "filename": "gdb/python/py-arch.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-arch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-arch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-arch.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -199,16 +199,15 @@ archpy_disassemble (PyObject *self, PyObject *args, PyObject *kw)\n \n       string_file stb;\n \n-      TRY\n+      try\n         {\n           insn_len = gdb_print_insn (gdbarch, pc, &stb, NULL);\n         }\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n         {\n \t  gdbpy_convert_exception (except);\n \t  return NULL;\n         }\n-      END_CATCH\n \n       if (PyDict_SetItemString (insn_dict.get (), \"addr\",\n                                 gdb_py_long_from_ulongest (pc))"
    },
    {
      "sha": "16c717c5bb4d2dd7508574b8ea30756476310a57",
      "filename": "gdb/python/py-breakpoint.c",
      "status": "modified",
      "additions": 16,
      "deletions": 24,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-breakpoint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -138,18 +138,17 @@ bppy_set_enabled (PyObject *self, PyObject *newvalue, void *closure)\n   if (cmp < 0)\n     return -1;\n \n-  TRY\n+  try\n     {\n       if (cmp == 1)\n \tenable_breakpoint (self_bp->bp);\n       else\n \tdisable_breakpoint (self_bp->bp);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_SET_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return 0;\n }\n@@ -247,15 +246,14 @@ bppy_set_task (PyObject *self, PyObject *newvalue, void *closure)\n       if (! gdb_py_int_as_long (newvalue, &id))\n \treturn -1;\n \n-      TRY\n+      try\n \t{\n \t  valid_id = valid_task_id (id);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDB_PY_SET_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n \n       if (! valid_id)\n \t{\n@@ -290,15 +288,14 @@ bppy_delete_breakpoint (PyObject *self, PyObject *args)\n \n   BPPY_REQUIRE_VALID (self_bp);\n \n-  TRY\n+  try\n     {\n       delete_breakpoint (self_bp->bp);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }\n@@ -332,15 +329,14 @@ bppy_set_ignore_count (PyObject *self, PyObject *newvalue, void *closure)\n   if (value < 0)\n     value = 0;\n \n-  TRY\n+  try\n     {\n       set_ignore_count (self_bp->number, (int) value, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_SET_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return 0;\n }\n@@ -469,15 +465,14 @@ bppy_set_condition (PyObject *self, PyObject *newvalue, void *closure)\n       exp = exp_holder.get ();\n     }\n \n-  TRY\n+  try\n     {\n       set_breakpoint_condition (self_bp->bp, exp, 0);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   GDB_PY_SET_HANDLE_EXCEPTION (except);\n \n@@ -499,17 +494,16 @@ bppy_get_commands (PyObject *self, void *closure)\n   string_file stb;\n \n   current_uiout->redirect (&stb);\n-  TRY\n+  try\n     {\n       print_command_lines (current_uiout, breakpoint_commands (bp), 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       current_uiout->redirect (NULL);\n       gdbpy_convert_exception (except);\n       return NULL;\n     }\n-  END_CATCH\n \n   current_uiout->redirect (NULL);\n   return host_string_to_python_string (stb.c_str ()).release ();\n@@ -530,7 +524,7 @@ bppy_set_commands (PyObject *self, PyObject *newvalue, void *closure)\n   if (commands == nullptr)\n     return -1;\n \n-  TRY\n+  try\n     {\n       bool first = true;\n       char *save_ptr = nullptr;\n@@ -546,11 +540,10 @@ bppy_set_commands (PyObject *self, PyObject *newvalue, void *closure)\n       counted_command_line lines = read_command_lines_1 (reader, 1, nullptr);\n       breakpoint_set_commands (self_bp->bp, std::move (lines));\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   GDB_PY_SET_HANDLE_EXCEPTION (except);\n \n@@ -801,7 +794,7 @@ bppy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n   bppy_pending_object->number = -1;\n   bppy_pending_object->bp = NULL;\n \n-  TRY\n+  try\n     {\n       switch (type)\n \t{\n@@ -871,13 +864,12 @@ bppy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t  error(_(\"Do not understand breakpoint type to set.\"));\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       bppy_pending_object = NULL;\n       gdbpy_convert_exception (except);\n       return -1;\n     }\n-  END_CATCH\n \n   BPPY_SET_REQUIRE_VALID ((gdbpy_breakpoint_object *) self);\n   return 0;"
    },
    {
      "sha": "24321278b79e8ad0368d4be36db39bffb86c4ab2",
      "filename": "gdb/python/py-cmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-cmd.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -541,7 +541,7 @@ cmdpy_init (PyObject *self, PyObject *args, PyObject *kw)\n \n   gdbpy_ref<> self_ref = gdbpy_ref<>::new_reference (self);\n \n-  TRY\n+  try\n     {\n       struct cmd_list_element *cmd;\n \n@@ -572,15 +572,14 @@ cmdpy_init (PyObject *self, PyObject *args, PyObject *kw)\n \tset_cmd_completer_handle_brkchars (cmd,\n \t\t\t\t\t   cmdpy_completer_handle_brkchars);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       xfree (cmd_name);\n       xfree (docstring);\n       xfree (pfx_name);\n       gdbpy_convert_exception (except);\n       return -1;\n     }\n-  END_CATCH\n \n   return 0;\n }"
    },
    {
      "sha": "6faffd2e86f36a4602d11da11b51812de53c8a49",
      "filename": "gdb/python/py-finishbreakpoint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-finishbreakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-finishbreakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-finishbreakpoint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -101,7 +101,7 @@ bpfinishpy_pre_stop_hook (struct gdbpy_breakpoint_object *bp_obj)\n   if (!self_finishbp->return_type)\n     return;\n \n-  TRY\n+  try\n     {\n       struct value *function =\n         value_object_to_value (self_finishbp->function_value);\n@@ -121,12 +121,11 @@ bpfinishpy_pre_stop_hook (struct gdbpy_breakpoint_object *bp_obj)\n           self_finishbp->return_value = Py_None;\n         }\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       gdbpy_print_stack ();\n     }\n-  END_CATCH\n }\n \n /* Triggered when gdbpy_should_stop has triggered the `stop' callback\n@@ -136,18 +135,17 @@ void\n bpfinishpy_post_stop_hook (struct gdbpy_breakpoint_object *bp_obj)\n {\n \n-  TRY\n+  try\n     {\n       /* Can't delete it here, but it will be removed at the next stop.  */\n       disable_breakpoint (bp_obj->bp);\n       gdb_assert (bp_obj->bp->disposition == disp_del);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       gdbpy_print_stack ();\n     }\n-  END_CATCH\n }\n \n /* Python function to create a new breakpoint.  */\n@@ -172,7 +170,7 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t\t\t\t\t&frame_obj, &internal))\n     return -1;\n \n-  TRY\n+  try\n     {\n       /* Default frame to newest frame if necessary.  */\n       if (frame_obj == NULL)\n@@ -210,12 +208,11 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t    }\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       return -1;\n     }\n-  END_CATCH\n \n   if (PyErr_Occurred ())\n     return -1;\n@@ -244,7 +241,7 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n   self_bpfinish->return_type = NULL;\n   self_bpfinish->function_value = NULL;\n \n-  TRY\n+  try\n     {\n       if (get_frame_pc_if_available (frame, &pc))\n         {\n@@ -270,12 +267,11 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n             }\n         }\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       /* Just swallow.  Either the return type or the function value\n \t remain NULL.  */\n     }\n-  END_CATCH\n \n   if (self_bpfinish->return_type == NULL || self_bpfinish->function_value == NULL)\n     {\n@@ -291,7 +287,7 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n   bppy_pending_object->number = -1;\n   bppy_pending_object->bp = NULL;\n \n-  TRY\n+  try\n     {\n       /* Set a breakpoint on the return address.  */\n       event_location_up location\n@@ -306,11 +302,10 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n                          &bkpt_breakpoint_ops,\n                          0, 1, internal_bp, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_SET_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   self_bpfinish->py_bp.bp->frame_id = frame_id;\n   self_bpfinish->py_bp.is_finish_bp = 1;\n@@ -362,19 +357,18 @@ bpfinishpy_detect_out_scope_cb (struct breakpoint *b, void *args)\n       /* Check scope if not currently stopped at the FinishBreakpoint.  */\n       if (b != bp_stopped)\n         {\n-          TRY\n+          try\n             {\n               if (b->pspace == current_inferior ()->pspace\n                   && (!target_has_registers\n                       || frame_find_by_id (b->frame_id) == NULL))\n                 bpfinishpy_out_of_scope (finish_bp);\n             }\n-          CATCH (except, RETURN_MASK_ALL)\n+          catch (const gdb_exception_RETURN_MASK_ALL &except)\n             {\n               gdbpy_convert_exception (except);\n               gdbpy_print_stack ();\n             }\n-\t  END_CATCH\n         }\n     }\n "
    },
    {
      "sha": "9066f6096e6e1a63208bb548c5fe76489e326211",
      "filename": "gdb/python/py-frame.c",
      "status": "modified",
      "additions": 36,
      "deletions": 54,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-frame.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -95,15 +95,14 @@ frapy_is_valid (PyObject *self, PyObject *args)\n {\n   struct frame_info *frame = NULL;\n \n-  TRY\n+  try\n     {\n       frame = frame_object_to_frame_info (self);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (frame == NULL)\n     Py_RETURN_FALSE;\n@@ -122,17 +121,16 @@ frapy_name (PyObject *self, PyObject *args)\n   enum language lang;\n   PyObject *result;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       name = find_frame_funname (frame, &lang, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (name)\n     {\n@@ -157,17 +155,16 @@ frapy_type (PyObject *self, PyObject *args)\n   struct frame_info *frame;\n   enum frame_type type = NORMAL_FRAME;/* Initialize to appease gcc warning.  */\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       type = get_frame_type (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyInt_FromLong (type);\n }\n@@ -181,15 +178,14 @@ frapy_arch (PyObject *self, PyObject *args)\n   struct frame_info *frame = NULL;    /* Initialize to appease gcc warning.  */\n   frame_object *obj = (frame_object *) self;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return gdbarch_to_arch_object (obj->gdbarch);\n }\n@@ -203,15 +199,14 @@ frapy_unwind_stop_reason (PyObject *self, PyObject *args)\n   struct frame_info *frame = NULL;    /* Initialize to appease gcc warning.  */\n   enum unwind_stop_reason stop_reason;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   stop_reason = get_frame_unwind_stop_reason (frame);\n \n@@ -227,17 +222,16 @@ frapy_pc (PyObject *self, PyObject *args)\n   CORE_ADDR pc = 0;\t      /* Initialize to appease gcc warning.  */\n   struct frame_info *frame;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       pc = get_frame_pc (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return gdb_py_long_from_ulongest (pc);\n }\n@@ -254,7 +248,7 @@ frapy_read_register (PyObject *self, PyObject *args)\n   if (!PyArg_ParseTuple (args, \"s\", &regnum_str))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       struct frame_info *frame;\n       int regnum;\n@@ -270,11 +264,10 @@ frapy_read_register (PyObject *self, PyObject *args)\n       if (val == NULL)\n         PyErr_SetString (PyExc_ValueError, _(\"Unknown register.\"));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return val == NULL ? NULL : value_to_value_object (val);\n }\n@@ -288,16 +281,15 @@ frapy_block (PyObject *self, PyObject *args)\n   struct frame_info *frame;\n   const struct block *block = NULL, *fn_block;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n       block = get_frame_block (frame, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   for (fn_block = block;\n        fn_block != NULL && BLOCK_FUNCTION (fn_block) == NULL;\n@@ -330,7 +322,7 @@ frapy_function (PyObject *self, PyObject *args)\n   struct symbol *sym = NULL;\n   struct frame_info *frame;\n \n-  TRY\n+  try\n     {\n       enum language funlang;\n \n@@ -339,11 +331,10 @@ frapy_function (PyObject *self, PyObject *args)\n       gdb::unique_xmalloc_ptr<char> funname\n \t= find_frame_funname (frame, &funlang, &sym);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (sym)\n     return symbol_to_symbol_object (sym);\n@@ -362,7 +353,7 @@ frame_info_to_frame_object (struct frame_info *frame)\n   if (frame_obj == NULL)\n     return NULL;\n \n-  TRY\n+  try\n     {\n \n       /* Try to get the previous frame, to determine if this is the last frame\n@@ -382,12 +373,11 @@ frame_info_to_frame_object (struct frame_info *frame)\n \t}\n       frame_obj->gdbarch = get_frame_arch (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       return NULL;\n     }\n-  END_CATCH\n \n   return (PyObject *) frame_obj.release ();\n }\n@@ -402,17 +392,16 @@ frapy_older (PyObject *self, PyObject *args)\n   struct frame_info *frame, *prev = NULL;\n   PyObject *prev_obj = NULL;   /* Initialize to appease gcc warning.  */\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       prev = get_prev_frame (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (prev)\n     prev_obj = frame_info_to_frame_object (prev);\n@@ -435,17 +424,16 @@ frapy_newer (PyObject *self, PyObject *args)\n   struct frame_info *frame, *next = NULL;\n   PyObject *next_obj = NULL;   /* Initialize to appease gcc warning.  */\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       next = get_next_frame (frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (next)\n     next_obj = frame_info_to_frame_object (next);\n@@ -467,18 +455,17 @@ frapy_find_sal (PyObject *self, PyObject *args)\n   struct frame_info *frame;\n   PyObject *sal_obj = NULL;   /* Initialize to appease gcc warning.  */\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       symtab_and_line sal = find_frame_sal (frame);\n       sal_obj = symtab_and_line_to_sal_object (sal);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return sal_obj;\n }\n@@ -523,7 +510,7 @@ frapy_read_var (PyObject *self, PyObject *args)\n \t    }\n \t}\n \n-      TRY\n+      try\n \t{\n \t  struct block_symbol lookup_sym;\n \t  FRAPY_REQUIRE_VALID (self, frame);\n@@ -534,12 +521,11 @@ frapy_read_var (PyObject *self, PyObject *args)\n \t  var = lookup_sym.symbol;\n \t  block = lookup_sym.block;\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  gdbpy_convert_exception (except);\n \t  return NULL;\n \t}\n-      END_CATCH\n \n       if (!var)\n \t{\n@@ -556,17 +542,16 @@ frapy_read_var (PyObject *self, PyObject *args)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, frame);\n \n       val = read_var_value (var, block, frame);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (val);\n }\n@@ -578,17 +563,16 @@ frapy_select (PyObject *self, PyObject *args)\n {\n   struct frame_info *fi;\n \n-  TRY\n+  try\n     {\n       FRAPY_REQUIRE_VALID (self, fi);\n \n       select_frame (fi);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }\n@@ -601,15 +585,14 @@ gdbpy_newest_frame (PyObject *self, PyObject *args)\n {\n   struct frame_info *frame = NULL;\n \n-  TRY\n+  try\n     {\n       frame = get_current_frame ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return frame_info_to_frame_object (frame);\n }\n@@ -622,15 +605,14 @@ gdbpy_selected_frame (PyObject *self, PyObject *args)\n {\n   struct frame_info *frame = NULL;\n \n-  TRY\n+  try\n     {\n       frame = get_selected_frame (\"No frame is currently selected.\");\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return frame_info_to_frame_object (frame);\n }"
    },
    {
      "sha": "deb4a8f1c8b9352b53db526b539a1b1145a8ccd6",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1081,16 +1081,15 @@ gdbpy_apply_frame_filter (const struct extension_language_defn *extlang,\n   if (!gdb_python_initialized)\n     return EXT_LANG_BT_NO_FILTERS;\n \n-  TRY\n+  try\n     {\n       gdbarch = get_frame_arch (frame);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       /* Let gdb try to print the stack trace.  */\n       return EXT_LANG_BT_NO_FILTERS;\n     }\n-  END_CATCH\n \n   gdbpy_enter enter_py (gdbarch, current_language);\n \n@@ -1166,17 +1165,16 @@ gdbpy_apply_frame_filter (const struct extension_language_defn *extlang,\n \t    }\n \t}\n \n-      TRY\n+      try\n \t{\n \t  success = py_print_frame (item.get (), flags, args_type, out, 0,\n \t\t\t\t    levels_printed.get ());\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  gdbpy_convert_exception (except);\n \t  success = EXT_LANG_BT_ERROR;\n \t}\n-      END_CATCH\n \n       /* Do not exit on error printing a single frame.  Print the\n \t error and continue with other frames.  */"
    },
    {
      "sha": "51ec6d814ae1e00935599401d1837ce46c8aaed9",
      "filename": "gdb/python/py-gdb-readline.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-gdb-readline.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-gdb-readline.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-gdb-readline.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -39,12 +39,12 @@ gdbpy_readline_wrapper (FILE *sys_stdin, FILE *sys_stdout,\n   int n;\n   char *p = NULL, *q;\n \n-  TRY\n+  try\n     {\n       p = command_line_input (prompt, \"python\");\n     }\n   /* Handle errors by raising Python exceptions.  */\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       /* Detect user interrupt (Ctrl-C).  */\n       if (except.reason == RETURN_QUIT)\n@@ -59,7 +59,6 @@ gdbpy_readline_wrapper (FILE *sys_stdin, FILE *sys_stdout,\n       PyEval_SaveThread ();\n       return NULL;\n     }\n-  END_CATCH\n \n   /* Detect EOF (Ctrl-D).  */\n   if (p == NULL)"
    },
    {
      "sha": "fee6b301c0a955ee1bdb7dd689d9448b25c2a0f3",
      "filename": "gdb/python/py-inferior.c",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-inferior.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -389,15 +389,14 @@ infpy_threads (PyObject *self, PyObject *args)\n \n   INFPY_REQUIRE_VALID (inf_obj);\n \n-  TRY\n+  try\n     {\n       update_thread_list ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   tuple = PyTuple_New (inf_obj->nthreads);\n   if (!tuple)\n@@ -508,17 +507,16 @@ infpy_read_memory (PyObject *self, PyObject *args, PyObject *kw)\n       || get_addr_from_python (length_obj, &length) < 0)\n     return NULL;\n \n-  TRY\n+  try\n     {\n       buffer.reset ((gdb_byte *) xmalloc (length));\n \n       read_memory (addr, buffer.get (), length);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   gdbpy_ref<membuf_object> membuf_obj (PyObject_New (membuf_object,\n \t\t\t\t\t\t     &membuf_object_type));\n@@ -572,15 +570,14 @@ infpy_write_memory (PyObject *self, PyObject *args, PyObject *kw)\n   else if (get_addr_from_python (length_obj, &length) < 0)\n     return nullptr;\n \n-  TRY\n+  try\n     {\n       write_memory_with_notification (addr, buffer, length);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   GDB_PY_HANDLE_EXCEPTION (except);\n \n@@ -725,17 +722,16 @@ infpy_search_memory (PyObject *self, PyObject *args, PyObject *kw)\n       return nullptr;\n     }\n \n-  TRY\n+  try\n     {\n       found = target_search_memory (start_addr, length,\n \t\t\t\t    buffer, pattern_size,\n \t\t\t\t    &found_addr);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   GDB_PY_HANDLE_EXCEPTION (except);\n \n@@ -782,7 +778,7 @@ infpy_thread_from_thread_handle (PyObject *self, PyObject *args, PyObject *kw)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       struct thread_info *thread_info;\n       struct value *val = value_object_to_value (handle_obj);\n@@ -791,11 +787,10 @@ infpy_thread_from_thread_handle (PyObject *self, PyObject *args, PyObject *kw)\n       if (thread_info != NULL)\n \treturn thread_to_thread_object (thread_info).release ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "3c6d147f48a2c2a575c0b35b79f904ded88796fe",
      "filename": "gdb/python/py-infthread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-infthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-infthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-infthread.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -181,15 +181,14 @@ thpy_switch (PyObject *self, PyObject *args)\n \n   THPY_REQUIRE_VALID (thread_obj);\n \n-  TRY\n+  try\n     {\n       switch_to_thread (thread_obj->thread);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "61722d929d1c3823e87289add6b4dd4666cedf46",
      "filename": "gdb/python/py-lazy-string.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-lazy-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-lazy-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-lazy-string.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -113,7 +113,7 @@ stpy_convert_to_value (PyObject *self, PyObject *args)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       struct type *type = type_object_to_type (self_string->type);\n       struct type *realtype;\n@@ -142,11 +142,10 @@ stpy_convert_to_value (PyObject *self, PyObject *args)\n \t  break;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (val);\n }"
    },
    {
      "sha": "813b2d92eaad51b672436c38b35da84d8c1a5c94",
      "filename": "gdb/python/py-linetable.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-linetable.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-linetable.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-linetable.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -164,15 +164,14 @@ ltpy_get_pcs_for_line (PyObject *self, PyObject *args)\n   if (! PyArg_ParseTuple (args, GDB_PY_LL_ARG, &py_line))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       pcs = find_pcs_for_symtab_line (symtab, py_line, &best_entry);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return build_line_table_tuple_from_pcs (py_line, pcs);\n }"
    },
    {
      "sha": "75ccc18406b6dbdf0eff8e53e3521581442b1fe7",
      "filename": "gdb/python/py-objfile.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-objfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-objfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-objfile.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -130,15 +130,14 @@ objfpy_get_build_id (PyObject *self, void *closure)\n \n   OBJFPY_REQUIRE_VALID (obj);\n \n-  TRY\n+  try\n     {\n       build_id = build_id_bfd_get (objfile->obfd);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (build_id != NULL)\n     {\n@@ -421,17 +420,16 @@ objfpy_add_separate_debug_file (PyObject *self, PyObject *args, PyObject *kw)\n   if (!gdb_PyArg_ParseTupleAndKeywords (args, kw, \"s\", keywords, &file_name))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       gdb_bfd_ref_ptr abfd (symfile_bfd_open (file_name));\n \n       symbol_file_add_separate (abfd.get (), file_name, 0, obj->objfile);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "c211d477ea42f9290936f2efe840ddbcf2da8750",
      "filename": "gdb/python/py-param.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-param.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -726,21 +726,20 @@ parmpy_init (PyObject *self, PyObject *args, PyObject *kwds)\n \n   Py_INCREF (self);\n \n-  TRY\n+  try\n     {\n       add_setshow_generic (parmclass, (enum command_class) cmdtype,\n \t\t\t   cmd_name, obj,\n \t\t\t   set_doc.get (), show_doc.get (),\n \t\t\t   doc.get (), set_list, show_list);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       xfree (cmd_name);\n       Py_DECREF (self);\n       gdbpy_convert_exception (except);\n       return -1;\n     }\n-  END_CATCH\n \n   return 0;\n }"
    },
    {
      "sha": "a02965da400e88164f04b49353d482c718fb3169",
      "filename": "gdb/python/py-prettyprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-prettyprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-prettyprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-prettyprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -190,7 +190,7 @@ pretty_print_one_value (PyObject *printer, struct value **out_value)\n   gdbpy_ref<> result;\n \n   *out_value = NULL;\n-  TRY\n+  try\n     {\n       if (!PyObject_HasAttr (printer, gdbpy_to_string_cst))\n \tresult = gdbpy_ref<>::new_reference (Py_None);\n@@ -212,10 +212,9 @@ pretty_print_one_value (PyObject *printer, struct value **out_value)\n \t    }\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -637,15 +636,14 @@ apply_varobj_pretty_printer (PyObject *printer_obj,\n gdbpy_ref<>\n gdbpy_get_varobj_pretty_printer (struct value *value)\n {\n-  TRY\n+  try\n     {\n       value = value_copy (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   gdbpy_ref<> val_obj (value_to_value_object (value));\n   if (val_obj == NULL)"
    },
    {
      "sha": "eb6acb29dd41ce227a5ba6f5db90ab806695f4fd",
      "filename": "gdb/python/py-progspace.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-progspace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-progspace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-progspace.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -381,7 +381,7 @@ pspy_block_for_pc (PyObject *o, PyObject *args)\n   if (!PyArg_ParseTuple (args, GDB_PY_LLU_ARG, &pc))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       scoped_restore_current_program_space saver;\n \n@@ -391,11 +391,10 @@ pspy_block_for_pc (PyObject *o, PyObject *args)\n       if (cust != NULL && COMPUNIT_OBJFILE (cust) != NULL)\n \tblock = block_for_pc (pc);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (cust == NULL || COMPUNIT_OBJFILE (cust) == NULL)\n     {\n@@ -425,7 +424,7 @@ pspy_find_pc_line (PyObject *o, PyObject *args)\n   if (!PyArg_ParseTuple (args, GDB_PY_LLU_ARG, &pc_llu))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       struct symtab_and_line sal;\n       CORE_ADDR pc;\n@@ -437,11 +436,10 @@ pspy_find_pc_line (PyObject *o, PyObject *args)\n       sal = find_pc_line (pc, 0);\n       result = symtab_and_line_to_sal_object (sal);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }"
    },
    {
      "sha": "64b25fa51244f81f1dd4e7b8b8546fafe8992967",
      "filename": "gdb/python/py-record-btrace.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-record-btrace.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -208,15 +208,14 @@ recpy_bt_insn_sal (PyObject *self, void *closure)\n   if (insn == NULL)\n     return NULL;\n \n-  TRY\n+  try\n     {\n       result = symtab_and_line_to_sal_object (find_pc_line (insn->pc, 0));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -279,16 +278,15 @@ recpy_bt_insn_data (PyObject *self, void *closure)\n   if (insn == NULL)\n     return NULL;\n \n-  TRY\n+  try\n     {\n       buffer.resize (insn->size);\n       read_memory (insn->pc, buffer.data (), insn->size);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   object = PyBytes_FromStringAndSize ((const char *) buffer.data (),\n \t\t\t\t      insn->size);\n@@ -316,16 +314,15 @@ recpy_bt_insn_decoded (PyObject *self, void *closure)\n   if (insn == NULL)\n     return NULL;\n \n-  TRY\n+  try\n     {\n       gdb_print_insn (target_gdbarch (), insn->pc, &strfile, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       return NULL;\n     }\n-  END_CATCH\n \n \n   return PyBytes_FromString (strfile.string ().c_str ());\n@@ -787,7 +784,7 @@ recpy_bt_goto (PyObject *self, PyObject *args)\n     return PyErr_Format (PyExc_TypeError, _(\"Argument must be instruction.\"));\n   obj = (const recpy_element_object *) parse_obj;\n \n-  TRY\n+  try\n     {\n       struct btrace_insn_iterator iter;\n \n@@ -798,11 +795,10 @@ recpy_bt_goto (PyObject *self, PyObject *args)\n       else\n \ttarget_goto_record (obj->number);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "66fa8bf3f5ee26863f463cd28239a2c9d8c03a48",
      "filename": "gdb/python/py-record.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-record.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-record.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-record.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -602,16 +602,15 @@ gdbpy_start_recording (PyObject *self, PyObject *args)\n   if (!PyArg_ParseTuple (args, \"|ss\", &method, &format))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       record_start (method, format, 0);\n       ret = gdbpy_current_recording (self, args);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n     }\n-  END_CATCH\n \n   return ret;\n }\n@@ -638,15 +637,14 @@ gdbpy_current_recording (PyObject *self, PyObject *args)\n PyObject *\n gdbpy_stop_recording (PyObject *self, PyObject *args)\n {\n-  TRY\n+  try\n     {\n       record_stop (0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "63d8ab16aa1681681b1d1e68f9e09523608624a5",
      "filename": "gdb/python/py-symbol.c",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-symbol.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -196,15 +196,14 @@ sympy_needs_frame (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  TRY\n+  try\n     {\n       result = symbol_read_needs_frame (symbol);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (result)\n     Py_RETURN_TRUE;\n@@ -266,7 +265,7 @@ sympy_value (PyObject *self, PyObject *args)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       if (frame_obj != NULL)\n \t{\n@@ -284,11 +283,10 @@ sympy_value (PyObject *self, PyObject *args)\n \t can happen with nested functions).  */\n       value = read_var_value (symbol, NULL, frame_info);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (value);\n }\n@@ -388,28 +386,26 @@ gdbpy_lookup_symbol (PyObject *self, PyObject *args, PyObject *kw)\n     {\n       struct frame_info *selected_frame;\n \n-      TRY\n+      try\n \t{\n \t  selected_frame = get_selected_frame (_(\"No frame selected.\"));\n \t  block = get_frame_block (selected_frame, NULL);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDB_PY_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n     }\n \n-  TRY\n+  try\n     {\n       symbol = lookup_symbol (name, block, (domain_enum) domain,\n \t\t\t      &is_a_field_of_this).symbol;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   gdbpy_ref<> ret_tuple (PyTuple_New (2));\n   if (ret_tuple == NULL)\n@@ -451,15 +447,14 @@ gdbpy_lookup_global_symbol (PyObject *self, PyObject *args, PyObject *kw)\n \t\t\t\t\t&domain))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       symbol = lookup_global_symbol (name, NULL, (domain_enum) domain).symbol;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (symbol)\n     {"
    },
    {
      "sha": "d918fc0d68ecc8b9d8716ef69866724229b6e39b",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 36,
      "deletions": 54,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -312,15 +312,14 @@ typy_fields_items (PyObject *self, enum gdbpy_iter_kind kind)\n   struct type *type = ((type_object *) py_type)->type;\n   struct type *checked_type = type;\n \n-  TRY\n+  try\n     {\n       checked_type = check_typedef (checked_type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   gdbpy_ref<> type_holder;\n   if (checked_type != type)\n@@ -420,15 +419,14 @@ typy_strip_typedefs (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -442,15 +440,14 @@ typy_get_composite (struct type *type)\n \n   for (;;)\n     {\n-      TRY\n+      try\n \t{\n \t  type = check_typedef (type);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDB_PY_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n \n       if (TYPE_CODE (type) != TYPE_CODE_PTR && !TYPE_IS_REFERENCE (type))\n \tbreak;\n@@ -510,17 +507,16 @@ typy_array_1 (PyObject *self, PyObject *args, int is_vector)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       array = lookup_array_range_type (type, n1, n2);\n       if (is_vector)\n \tmake_vector_type (array);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (array);\n }\n@@ -547,15 +543,14 @@ typy_pointer (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = lookup_pointer_type (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -616,15 +611,14 @@ typy_reference (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = lookup_lvalue_reference_type (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -651,15 +645,14 @@ typy_const (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (1, 0, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -670,15 +663,14 @@ typy_volatile (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (0, 1, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -689,15 +681,14 @@ typy_unqualified (PyObject *self, PyObject *args)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       type = make_cv_type (0, 0, type, NULL);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type_to_type_object (type);\n }\n@@ -708,14 +699,13 @@ typy_get_sizeof (PyObject *self, void *closure)\n {\n   struct type *type = ((type_object *) self)->type;\n \n-  TRY\n+  try\n     {\n       check_typedef (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n     }\n-  END_CATCH\n \n   /* Ignore exceptions.  */\n \n@@ -729,15 +719,14 @@ typy_get_alignof (PyObject *self, void *closure)\n   struct type *type = ((type_object *) self)->type;\n \n   ULONGEST align = 0;\n-  TRY\n+  try\n     {\n       align = type_align (type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       align = 0;\n     }\n-  END_CATCH\n \n   /* Ignore exceptions.  */\n \n@@ -749,7 +738,7 @@ typy_lookup_typename (const char *type_name, const struct block *block)\n {\n   struct type *type = NULL;\n \n-  TRY\n+  try\n     {\n       if (startswith (type_name, \"struct \"))\n \ttype = lookup_struct (type_name + 7, NULL);\n@@ -761,11 +750,10 @@ typy_lookup_typename (const char *type_name, const struct block *block)\n \ttype = lookup_typename (python_language, python_gdbarch,\n \t\t\t\ttype_name, block, 0);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return type;\n }\n@@ -791,7 +779,7 @@ typy_lookup_type (struct demangle_component *demangled,\n       if (! type)\n \treturn NULL;\n \n-      TRY\n+      try\n \t{\n \t  /* If the demangled_type matches with one of the types\n \t     below, run the corresponding function and save the type\n@@ -816,11 +804,10 @@ typy_lookup_type (struct demangle_component *demangled,\n \t      break;\n \t    }\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDB_PY_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n     }\n \n   /* If we have a type from the switch statement above, just return\n@@ -854,16 +841,15 @@ typy_legacy_template_argument (struct type *type, const struct block *block,\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       /* Note -- this is not thread-safe.  */\n       info = cp_demangled_name_to_comp (TYPE_NAME (type), &err);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (! info)\n     {\n@@ -934,17 +920,16 @@ typy_template_argument (PyObject *self, PyObject *args)\n \t}\n     }\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n       if (TYPE_IS_REFERENCE (type))\n \ttype = check_typedef (TYPE_TARGET_TYPE (type));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* We might not have DW_TAG_template_*, so try to parse the type's\n      name.  This is inefficient if we do not have a template type --\n@@ -969,15 +954,14 @@ typy_template_argument (PyObject *self, PyObject *args)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       val = value_of_variable (sym, block);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (val);\n }\n@@ -987,16 +971,15 @@ typy_str (PyObject *self)\n {\n   string_file thetype;\n \n-  TRY\n+  try\n     {\n       LA_PRINT_TYPE (type_object_to_type (self), \"\", &thetype, -1, 0,\n \t\t     &type_print_raw_options);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyUnicode_Decode (thetype.c_str (), thetype.size (),\n \t\t\t   host_charset (), NULL);\n@@ -1023,17 +1006,16 @@ typy_richcompare (PyObject *self, PyObject *other, int op)\n     result = true;\n   else\n     {\n-      TRY\n+      try\n \t{\n \t  result = types_deeply_equal (type1, type2);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  /* If there is a GDB exception, a comparison is not capable\n \t     (or trusted), so exit.  */\n \t  GDB_PY_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n     }\n \n   if (op == (result ? Py_EQ : Py_NE))"
    },
    {
      "sha": "e506ec01396767fa592bfe9a85b540650ebf91c3",
      "filename": "gdb/python/py-unwind.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-unwind.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -141,7 +141,7 @@ pyuw_value_obj_to_pointer (PyObject *pyo_value, CORE_ADDR *addr)\n   int rc = 0;\n   struct value *value;\n \n-  TRY\n+  try\n     {\n       if ((value = value_object_to_value (pyo_value)) != NULL)\n         {\n@@ -150,11 +150,10 @@ pyuw_value_obj_to_pointer (PyObject *pyo_value, CORE_ADDR *addr)\n           rc = 1;\n         }\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n     }\n-  END_CATCH\n   return rc;\n }\n \n@@ -211,16 +210,15 @@ unwind_infopy_str (PyObject *self)\n         stb.printf (\"%s(%d, \", sep, reg.number);\n         if (value != NULL)\n           {\n-            TRY\n+            try\n               {\n                 value_print (value, &stb, &opts);\n                 stb.puts (\")\");\n               }\n-            CATCH (except, RETURN_MASK_ALL)\n+            catch (const gdb_exception_RETURN_MASK_ALL &except)\n               {\n                 GDB_PY_HANDLE_EXCEPTION (except);\n               }\n-            END_CATCH\n           }\n         else\n           stb.puts (\"<BAD>)\");\n@@ -346,16 +344,15 @@ pending_framepy_str (PyObject *self)\n \n   if (frame == NULL)\n     return PyString_FromString (\"Stale PendingFrame instance\");\n-  TRY\n+  try\n     {\n       sp_str = core_addr_to_string_nz (get_frame_sp (frame));\n       pc_str = core_addr_to_string_nz (get_frame_pc (frame));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyString_FromFormat (\"SP=%s,PC=%s\", sp_str, pc_str);\n }\n@@ -385,7 +382,7 @@ pending_framepy_read_register (PyObject *self, PyObject *args)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       /* Fetch the value associated with a register, whether it's\n \t a real register or a so called \"user\" register, like \"pc\",\n@@ -398,11 +395,10 @@ pending_framepy_read_register (PyObject *self, PyObject *args)\n                       \"Cannot read register %d from frame.\",\n                       regnum);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return val == NULL ? NULL : value_to_value_object (val);\n }"
    },
    {
      "sha": "76b5ac04e9cdeb08f6d4f719d4154f754300fe97",
      "filename": "gdb/python/py-utils.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-utils.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -254,15 +254,14 @@ get_addr_from_python (PyObject *obj, CORE_ADDR *addr)\n   if (gdbpy_is_value_object (obj))\n     {\n \n-      TRY\n+      try\n \t{\n \t  *addr = value_as_address (value_object_to_value (obj));\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  GDB_PY_SET_HANDLE_EXCEPTION (except);\n \t}\n-      END_CATCH\n     }\n   else\n     {"
    },
    {
      "sha": "a761b1e53032d29cb667558081afb355952da173",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 62,
      "deletions": 93,
      "changes": 155,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -216,19 +216,18 @@ valpy_dereference (PyObject *self, PyObject *args)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       struct value *res_val;\n       scoped_value_mark free_values;\n \n       res_val = value_ind (((value_object *) self)->value);\n       result = value_to_value_object (res_val);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -246,7 +245,7 @@ valpy_referenced_value (PyObject *self, PyObject *args)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       struct value *self_val, *res_val;\n       scoped_value_mark free_values;\n@@ -268,11 +267,10 @@ valpy_referenced_value (PyObject *self, PyObject *args)\n \n       result = value_to_value_object (res_val);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -284,19 +282,18 @@ valpy_reference_value (PyObject *self, PyObject *args, enum type_code refcode)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       struct value *self_val;\n       scoped_value_mark free_values;\n \n       self_val = ((value_object *) self)->value;\n       result = value_to_value_object (value_ref (self_val, refcode));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -320,7 +317,7 @@ valpy_const_value (PyObject *self, PyObject *args)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       struct value *self_val, *res_val;\n       scoped_value_mark free_values;\n@@ -329,11 +326,10 @@ valpy_const_value (PyObject *self, PyObject *args)\n       res_val = make_cv_value (1, 0, self_val);\n       result = value_to_value_object (res_val);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -346,20 +342,19 @@ valpy_get_address (PyObject *self, void *closure)\n \n   if (!val_obj->address)\n     {\n-      TRY\n+      try\n \t{\n \t  struct value *res_val;\n \t  scoped_value_mark free_values;\n \n \t  res_val = value_addr (val_obj->value);\n \t  val_obj->address = value_to_value_object (res_val);\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t  val_obj->address = Py_None;\n \t  Py_INCREF (Py_None);\n \t}\n-      END_CATCH\n     }\n \n   Py_XINCREF (val_obj->address);\n@@ -397,7 +392,7 @@ valpy_get_dynamic_type (PyObject *self, void *closure)\n       return obj->dynamic_type;\n     }\n \n-  TRY\n+  try\n     {\n       struct value *val = obj->value;\n       scoped_value_mark free_values;\n@@ -433,11 +428,10 @@ valpy_get_dynamic_type (PyObject *self, void *closure)\n \t  type = NULL;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (type == NULL)\n     obj->dynamic_type = valpy_get_type (self, NULL);\n@@ -485,7 +479,7 @@ valpy_lazy_string (PyObject *self, PyObject *args, PyObject *kw)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       scoped_value_mark free_values;\n       struct type *type, *realtype;\n@@ -540,11 +534,10 @@ valpy_lazy_string (PyObject *self, PyObject *args, PyObject *kw)\n       str_obj = gdbpy_create_lazy_string_object (addr, length, user_encoding,\n \t\t\t\t\t\t type);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return str_obj;\n }\n@@ -572,15 +565,14 @@ valpy_string (PyObject *self, PyObject *args, PyObject *kw)\n \t\t\t\t\t&user_encoding, &errors, &length))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       LA_GET_STRING (value, &buffer, &length, &char_type, &la_encoding);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   encoding = (user_encoding && *user_encoding) ? user_encoding : la_encoding;\n   return PyUnicode_Decode ((const char *) buffer.get (),\n@@ -733,16 +725,15 @@ valpy_format_string (PyObject *self, PyObject *args, PyObject *kw)\n \n   string_file stb;\n \n-  TRY\n+  try\n     {\n       common_val_print (((value_object *) self)->value, &stb, 0,\n \t\t\t&opts, python_language);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyUnicode_Decode (stb.c_str (), stb.size (), host_charset (), NULL);\n }\n@@ -766,7 +757,7 @@ valpy_do_cast (PyObject *self, PyObject *args, enum exp_opcode op)\n       return NULL;\n     }\n \n-  TRY\n+  try\n     {\n       struct value *val = ((value_object *) self)->value;\n       struct value *res_val;\n@@ -784,11 +775,10 @@ valpy_do_cast (PyObject *self, PyObject *args, enum exp_opcode op)\n \n       result = value_to_value_object (res_val);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -849,7 +839,7 @@ value_has_field (struct value *v, PyObject *field)\n       return -1;\n     }\n \n-  TRY\n+  try\n     {\n       val_type = value_type (v);\n       val_type = check_typedef (val_type);\n@@ -863,11 +853,10 @@ value_has_field (struct value *v, PyObject *field)\n       else\n \thas_field = 0;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_SET_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return has_field;\n }\n@@ -988,7 +977,7 @@ valpy_getitem (PyObject *self, PyObject *key)\n \t}\n     }\n \n-  TRY\n+  try\n     {\n       struct value *tmp = self_value->value;\n       struct value *res_val = NULL;\n@@ -1042,11 +1031,10 @@ valpy_getitem (PyObject *self, PyObject *key)\n       if (res_val)\n \tresult = value_to_value_object (res_val);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   GDB_PY_HANDLE_EXCEPTION (except);\n \n@@ -1072,15 +1060,14 @@ valpy_call (PyObject *self, PyObject *args, PyObject *keywords)\n   struct type *ftype = NULL;\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       ftype = check_typedef (value_type (function));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (TYPE_CODE (ftype) != TYPE_CODE_FUNC)\n     {\n@@ -1115,7 +1102,7 @@ valpy_call (PyObject *self, PyObject *args, PyObject *keywords)\n \t}\n     }\n \n-  TRY\n+  try\n     {\n       scoped_value_mark free_values;\n \n@@ -1124,11 +1111,10 @@ valpy_call (PyObject *self, PyObject *args, PyObject *keywords)\n \t\t\t\t gdb::make_array_view (vargs, args_count));\n       result = value_to_value_object (return_value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -1145,16 +1131,15 @@ valpy_str (PyObject *self)\n \n   string_file stb;\n \n-  TRY\n+  try\n     {\n       common_val_print (((value_object *) self)->value, &stb, 0,\n \t\t\t&opts, python_language);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyUnicode_Decode (stb.c_str (), stb.size (), host_charset (), NULL);\n }\n@@ -1166,15 +1151,14 @@ valpy_get_is_optimized_out (PyObject *self, void *closure)\n   struct value *value = ((value_object *) self)->value;\n   int opt = 0;\n \n-  TRY\n+  try\n     {\n       opt = value_optimized_out (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (opt)\n     Py_RETURN_TRUE;\n@@ -1189,15 +1173,14 @@ valpy_get_is_lazy (PyObject *self, void *closure)\n   struct value *value = ((value_object *) self)->value;\n   int opt = 0;\n \n-  TRY\n+  try\n     {\n       opt = value_lazy (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (opt)\n     Py_RETURN_TRUE;\n@@ -1211,16 +1194,15 @@ valpy_fetch_lazy (PyObject *self, PyObject *args)\n {\n   struct value *value = ((value_object *) self)->value;\n \n-  TRY\n+  try\n     {\n       if (value_lazy (value))\n \tvalue_fetch_lazy (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }\n@@ -1384,15 +1366,14 @@ valpy_binop (enum valpy_opcode opcode, PyObject *self, PyObject *other)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       result = valpy_binop_throw (opcode, self, other);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -1448,7 +1429,7 @@ valpy_negative (PyObject *self)\n {\n   PyObject *result = NULL;\n \n-  TRY\n+  try\n     {\n       /* Perhaps overkill, but consistency has some virtue.  */\n       scoped_value_mark free_values;\n@@ -1457,11 +1438,10 @@ valpy_negative (PyObject *self)\n       val = value_neg (((value_object *) self)->value);\n       result = value_to_value_object (val);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return result;\n }\n@@ -1478,18 +1458,17 @@ valpy_absolute (PyObject *self)\n   struct value *value = ((value_object *) self)->value;\n   int isabs = 1;\n \n-  TRY\n+  try\n     {\n       scoped_value_mark free_values;\n \n       if (value_less (value, value_zero (value_type (value), not_lval)))\n \tisabs = 0;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (isabs)\n     return valpy_positive (self);\n@@ -1506,7 +1485,7 @@ valpy_nonzero (PyObject *self)\n   struct type *type;\n   int nonzero = 0; /* Appease GCC warning.  */\n \n-  TRY\n+  try\n     {\n       type = check_typedef (value_type (self_value->value));\n \n@@ -1519,11 +1498,10 @@ valpy_nonzero (PyObject *self)\n \t/* All other values are True.  */\n \tnonzero = 1;\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       except = ex;\n     }\n-  END_CATCH\n \n   /* This is not documented in the Python documentation, but if this\n      function fails, return -1 as slot_nb_nonzero does (the default\n@@ -1539,15 +1517,14 @@ valpy_invert (PyObject *self)\n {\n   struct value *val = NULL;\n \n-  TRY\n+  try\n     {\n       val = value_complement (((value_object *) self)->value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (val);\n }\n@@ -1667,15 +1644,14 @@ valpy_richcompare (PyObject *self, PyObject *other, int op)\n \treturn NULL;\n     }\n \n-  TRY\n+  try\n     {\n       result = valpy_richcompare_throw (self, other, op);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   /* In this case, the Python exception has already been set.  */\n   if (result < 0)\n@@ -1696,7 +1672,7 @@ valpy_int (PyObject *self)\n   struct type *type = value_type (value);\n   LONGEST l = 0;\n \n-  TRY\n+  try\n     {\n       if (is_floating_value (value))\n \t{\n@@ -1710,11 +1686,10 @@ valpy_int (PyObject *self)\n \n       l = value_as_long (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (TYPE_UNSIGNED (type))\n     return gdb_py_object_from_ulongest (l).release ();\n@@ -1731,7 +1706,7 @@ valpy_long (PyObject *self)\n   struct type *type = value_type (value);\n   LONGEST l = 0;\n \n-  TRY\n+  try\n     {\n       if (is_floating_value (value))\n \t{\n@@ -1747,11 +1722,10 @@ valpy_long (PyObject *self)\n \n       l = value_as_long (value);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (TYPE_UNSIGNED (type))\n     return gdb_py_long_from_ulongest (l);\n@@ -1767,7 +1741,7 @@ valpy_float (PyObject *self)\n   struct type *type = value_type (value);\n   double d = 0;\n \n-  TRY\n+  try\n     {\n       type = check_typedef (type);\n \n@@ -1783,11 +1757,10 @@ valpy_float (PyObject *self)\n       else\n \terror (_(\"Cannot convert value to float.\"));\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return PyFloat_FromDouble (d);\n }\n@@ -1837,7 +1810,7 @@ convert_value_from_python (PyObject *obj)\n \n   gdb_assert (obj != NULL);\n \n-  TRY\n+  try\n     {\n       if (PyBool_Check (obj))\n \t{\n@@ -1927,12 +1900,11 @@ convert_value_from_python (PyObject *obj)\n \t\t      PyString_AsString (PyObject_Str (obj)));\n #endif\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       gdbpy_convert_exception (except);\n       return NULL;\n     }\n-  END_CATCH\n \n   return value;\n }\n@@ -1947,15 +1919,14 @@ gdbpy_history (PyObject *self, PyObject *args)\n   if (!PyArg_ParseTuple (args, \"i\", &i))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       res_val = access_value_history (i);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (res_val);\n }\n@@ -1970,7 +1941,7 @@ gdbpy_convenience_variable (PyObject *self, PyObject *args)\n   if (!PyArg_ParseTuple (args, \"s\", &varname))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       struct internalvar *var = lookup_only_internalvar (varname);\n \n@@ -1981,11 +1952,10 @@ gdbpy_convenience_variable (PyObject *self, PyObject *args)\n \t    res_val = NULL;\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (res_val == NULL)\n     Py_RETURN_NONE;\n@@ -2012,7 +1982,7 @@ gdbpy_set_convenience_variable (PyObject *self, PyObject *args)\n \treturn NULL;\n     }\n \n-  TRY\n+  try\n     {\n       if (value == NULL)\n \t{\n@@ -2028,11 +1998,10 @@ gdbpy_set_convenience_variable (PyObject *self, PyObject *args)\n \t  set_internalvar (var, value);\n \t}\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "503639ed764ada6e161f525a98d9b6c35aab9a69",
      "filename": "gdb/python/python.c",
      "status": "modified",
      "additions": 14,
      "deletions": 21,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/python.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/python/python.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -497,15 +497,14 @@ gdbpy_parameter (PyObject *self, PyObject *args)\n \n   std::string newarg = std::string (\"show \") + arg;\n \n-  TRY\n+  try\n     {\n       found = lookup_cmd_composition (newarg.c_str (), &alias, &prefix, &cmd);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       GDB_PY_HANDLE_EXCEPTION (ex);\n     }\n-  END_CATCH\n \n   if (!found)\n     return PyErr_Format (PyExc_RuntimeError,\n@@ -574,7 +573,7 @@ execute_gdb_command (PyObject *self, PyObject *args, PyObject *kw)\n \n   scoped_restore preventer = prevent_dont_repeat ();\n \n-  TRY\n+  try\n     {\n       gdbpy_allow_threads allow_threads;\n \n@@ -615,11 +614,10 @@ execute_gdb_command (PyObject *self, PyObject *args, PyObject *kw)\n       /* Do any commands attached to breakpoint we stopped at.  */\n       bpstat_do_actions ();\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   if (to_string)\n     return PyString_FromString (to_string_res.c_str ());\n@@ -830,7 +828,7 @@ gdbpy_decode_line (PyObject *self, PyObject *args)\n   std::vector<symtab_and_line> decoded_sals;\n   symtab_and_line def_sal;\n   gdb::array_view<symtab_and_line> sals;\n-  TRY\n+  try\n     {\n       if (location != NULL)\n \t{\n@@ -844,13 +842,12 @@ gdbpy_decode_line (PyObject *self, PyObject *args)\n \t  sals = def_sal;\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* We know this will always throw.  */\n       gdbpy_convert_exception (ex);\n       return NULL;\n     }\n-  END_CATCH\n \n   if (!sals.empty ())\n     {\n@@ -898,16 +895,15 @@ gdbpy_parse_and_eval (PyObject *self, PyObject *args)\n   if (!PyArg_ParseTuple (args, \"s\", &expr_str))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       gdbpy_allow_threads allow_threads;\n       result = parse_and_eval (expr_str);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   return value_to_value_object (result);\n }\n@@ -1136,7 +1132,7 @@ gdbpy_write (PyObject *self, PyObject *args, PyObject *kw)\n \t\t\t\t\t&stream_type))\n     return NULL;\n \n-  TRY\n+  try\n     {\n       switch (stream_type)\n         {\n@@ -1154,11 +1150,10 @@ gdbpy_write (PyObject *self, PyObject *args, PyObject *kw)\n           fprintf_filtered (gdb_stdout, \"%s\", arg);\n         }\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       GDB_PY_HANDLE_EXCEPTION (except);\n     }\n-  END_CATCH\n \n   Py_RETURN_NONE;\n }\n@@ -1224,14 +1219,13 @@ gdbpy_print_stack (void)\n       /* PyErr_Print doesn't necessarily end output with a newline.\n \t This works because Python's stdout/stderr is fed through\n \t printf_filtered.  */\n-      TRY\n+      try\n \t{\n \t  begin_line ();\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t}\n-      END_CATCH\n     }\n   /* Print \"message\", just error print message.  */\n   else\n@@ -1245,7 +1239,7 @@ gdbpy_print_stack (void)\n       if (msg != NULL)\n \ttype = fetched_error.type_to_string ();\n \n-      TRY\n+      try\n \t{\n \t  if (msg == NULL || type == NULL)\n \t    {\n@@ -1260,10 +1254,9 @@ gdbpy_print_stack (void)\n \t    fprintf_filtered (gdb_stderr, \"Python Exception %s %s: \\n\",\n \t\t\t      type.get (), msg.get ());\n \t}\n-      CATCH (except, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &except)\n \t{\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "add89698c050d17e782b01b374f5f104075272d0",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 18,
      "deletions": 27,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -282,15 +282,14 @@ require_btrace (void)\n static void\n record_btrace_enable_warn (struct thread_info *tp)\n {\n-  TRY\n+  try\n     {\n       btrace_enable (tp, &record_btrace_conf);\n     }\n-  CATCH (error, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &error)\n     {\n       warning (\"%s\", error.what ());\n     }\n-  END_CATCH\n }\n \n /* Enable automatic tracing of new threads.  */\n@@ -1479,16 +1478,15 @@ record_btrace_target::insert_breakpoint (struct gdbarch *gdbarch,\n   replay_memory_access = replay_memory_access_read_write;\n \n   ret = 0;\n-  TRY\n+  try\n     {\n       ret = this->beneath ()->insert_breakpoint (gdbarch, bp_tgt);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       replay_memory_access = old;\n       throw_exception (except);\n     }\n-  END_CATCH\n   replay_memory_access = old;\n \n   return ret;\n@@ -1510,16 +1508,15 @@ record_btrace_target::remove_breakpoint (struct gdbarch *gdbarch,\n   replay_memory_access = replay_memory_access_read_write;\n \n   ret = 0;\n-  TRY\n+  try\n     {\n       ret = this->beneath ()->remove_breakpoint (gdbarch, bp_tgt, reason);\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       replay_memory_access = old;\n       throw_exception (except);\n     }\n-  END_CATCH\n   replay_memory_access = old;\n \n   return ret;\n@@ -1988,18 +1985,17 @@ get_thread_current_frame_id (struct thread_info *tp)\n   set_executing (inferior_ptid, false);\n \n   id = null_frame_id;\n-  TRY\n+  try\n     {\n       id = get_frame_id (get_current_frame ());\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       /* Restore the previous execution state.  */\n       set_executing (inferior_ptid, executing);\n \n       throw_exception (except);\n     }\n-  END_CATCH\n \n   /* Restore the previous execution state.  */\n   set_executing (inferior_ptid, executing);\n@@ -2027,7 +2023,7 @@ record_btrace_start_replaying (struct thread_info *tp)\n      Since frames are computed differently when we're replaying, we need to\n      recompute those stored frames and fix them up so we can still detect\n      subroutines after we started replaying.  */\n-  TRY\n+  try\n     {\n       struct frame_id frame_id;\n       int upd_step_frame_id, upd_step_stack_frame_id;\n@@ -2072,7 +2068,7 @@ record_btrace_start_replaying (struct thread_info *tp)\n       if (upd_step_stack_frame_id)\n \ttp->control.step_stack_frame_id = frame_id;\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n       xfree (btinfo->replay);\n       btinfo->replay = NULL;\n@@ -2081,7 +2077,6 @@ record_btrace_start_replaying (struct thread_info *tp)\n \n       throw_exception (except);\n     }\n-  END_CATCH\n \n   return replay;\n }\n@@ -2894,16 +2889,15 @@ cmd_record_btrace_bts_start (const char *args, int from_tty)\n \n   record_btrace_conf.format = BTRACE_FORMAT_BTS;\n \n-  TRY\n+  try\n     {\n       execute_command (\"target record-btrace\", from_tty);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       record_btrace_conf.format = BTRACE_FORMAT_NONE;\n       throw_exception (exception);\n     }\n-  END_CATCH\n }\n \n /* Start recording in Intel Processor Trace format.  */\n@@ -2916,16 +2910,15 @@ cmd_record_btrace_pt_start (const char *args, int from_tty)\n \n   record_btrace_conf.format = BTRACE_FORMAT_PT;\n \n-  TRY\n+  try\n     {\n       execute_command (\"target record-btrace\", from_tty);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       record_btrace_conf.format = BTRACE_FORMAT_NONE;\n       throw_exception (exception);\n     }\n-  END_CATCH\n }\n \n /* Alias for \"target record\".  */\n@@ -2938,26 +2931,24 @@ cmd_record_btrace_start (const char *args, int from_tty)\n \n   record_btrace_conf.format = BTRACE_FORMAT_PT;\n \n-  TRY\n+  try\n     {\n       execute_command (\"target record-btrace\", from_tty);\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       record_btrace_conf.format = BTRACE_FORMAT_BTS;\n \n-      TRY\n+      try\n \t{\n \t  execute_command (\"target record-btrace\", from_tty);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  record_btrace_conf.format = BTRACE_FORMAT_NONE;\n \t  throw_exception (ex);\n \t}\n-      END_CATCH\n     }\n-  END_CATCH\n }\n \n /* The \"set record btrace\" command.  */"
    },
    {
      "sha": "ce3f67fc74b3632b884d890c54c2a5923a50174c",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -708,7 +708,7 @@ record_full_message (struct regcache *regcache, enum gdb_signal signal)\n   int ret;\n   struct gdbarch *gdbarch = regcache->arch ();\n \n-  TRY\n+  try\n     {\n       record_full_arch_list_head = NULL;\n       record_full_arch_list_tail = NULL;\n@@ -761,12 +761,11 @@ record_full_message (struct regcache *regcache, enum gdb_signal signal)\n       if (ret < 0)\n \terror (_(\"Process record: failed to record execution log.\"));\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       record_full_list_release (record_full_arch_list_tail);\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   record_full_list->next = record_full_arch_list_head;\n   record_full_arch_list_head->prev = record_full_list;\n@@ -782,16 +781,15 @@ static bool\n record_full_message_wrapper_safe (struct regcache *regcache,\n \t\t\t\t  enum gdb_signal signal)\n {\n-  TRY\n+  try\n     {\n       record_full_message (regcache, signal);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n       return false;\n     }\n-  END_CATCH\n \n   return true;\n }\n@@ -1293,7 +1291,7 @@ record_full_wait_1 (struct target_ops *ops,\n       int continue_flag = 1;\n       int first_record_full_end = 1;\n \n-      TRY\n+      try\n \t{\n \t  CORE_ADDR tmp_pc;\n \n@@ -1436,7 +1434,7 @@ record_full_wait_1 (struct target_ops *ops,\n \t  else\n \t    status->value.sig = GDB_SIGNAL_TRAP;\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  if (execution_direction == EXEC_REVERSE)\n \t    {\n@@ -1448,7 +1446,6 @@ record_full_wait_1 (struct target_ops *ops,\n \n \t  throw_exception (ex);\n \t}\n-      END_CATCH\n     }\n \n   signal (SIGINT, handle_sigint);\n@@ -2374,7 +2371,7 @@ record_full_restore (void)\n   record_full_arch_list_tail = NULL;\n   record_full_insn_num = 0;\n \n-  TRY\n+  try\n     {\n       regcache = get_current_regcache ();\n \n@@ -2476,12 +2473,11 @@ record_full_restore (void)\n \t  record_full_arch_list_add (rec);\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       record_full_list_release (record_full_arch_list_tail);\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   /* Add record_full_arch_list_head to the end of record list.  */\n   record_full_first.next = record_full_arch_list_head;"
    },
    {
      "sha": "6887a6aac18be128cf5bf91c830dd9f7c5048d76",
      "filename": "gdb/remote-fileio.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/remote-fileio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/remote-fileio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-fileio.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1185,18 +1185,17 @@ remote_fileio_request (remote_target *remote, char *buf, int ctrlc_pending_p)\n     }\n   else\n     {\n-      TRY\n+      try\n \t{\n \t  do_remote_fileio_request (remote, buf);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  if (ex.reason == RETURN_QUIT)\n \t    remote_fileio_reply (remote, -1, FILEIO_EINTR);\n \t  else\n \t    remote_fileio_reply (remote, -1, FILEIO_EIO);\n \t}\n-      END_CATCH\n     }\n \n   quit_handler = remote_fileio_o_quit_handler;"
    },
    {
      "sha": "0424ea4ef1ee7b38e3ff677779dc007131bd1280",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 10,
      "deletions": 15,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1146,12 +1146,12 @@ remote_target::remote_get_noisy_reply ()\n \n \t  org_to = to;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      gdbarch_relocate_instruction (target_gdbarch (), &to, from);\n \t      relocated = 1;\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t    {\n \t      if (ex.error == MEMORY_ERROR)\n \t\t{\n@@ -1170,7 +1170,6 @@ remote_target::remote_get_noisy_reply ()\n \t\t}\n \t      putpkt (\"E01\");\n \t    }\n-\t  END_CATCH\n \n \t  if (relocated)\n \t    {\n@@ -5602,19 +5601,18 @@ remote_target::open_1 (const char *name, int from_tty, int extended_p)\n      function.  See cli-dump.c.  */\n   {\n \n-    TRY\n+    try\n       {\n \tremote->start_remote (from_tty, extended_p);\n       }\n-    CATCH (ex, RETURN_MASK_ALL)\n+    catch (const gdb_exception_RETURN_MASK_ALL &ex)\n       {\n \t/* Pop the partially set up target - unless something else did\n \t   already before throwing the exception.  */\n \tif (ex.error != TARGET_CLOSE_ERROR)\n \t  remote_unpush_target ();\n \tthrow_exception (ex);\n       }\n-    END_CATCH\n   }\n \n   remote_btrace_reset (rs);\n@@ -9766,11 +9764,11 @@ remote_target::remote_kill_k ()\n {\n   /* Catch errors so the user can quit from gdb even when we\n      aren't on speaking terms with the remote system.  */\n-  TRY\n+  try\n     {\n       putpkt (\"k\");\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error == TARGET_CLOSE_ERROR)\n \t{\n@@ -9788,7 +9786,6 @@ remote_target::remote_kill_k ()\n \t user or higher layers decide what to do.  */\n       throw_exception (ex);\n     }\n-  END_CATCH\n }\n \n void\n@@ -13135,11 +13132,11 @@ remote_target::get_trace_status (struct trace_status *ts)\n \n   putpkt (\"qTStatus\");\n \n-  TRY\n+  try\n     {\n       p = remote_get_noisy_reply ();\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != TARGET_CLOSE_ERROR)\n \t{\n@@ -13148,7 +13145,6 @@ remote_target::get_trace_status (struct trace_status *ts)\n \t}\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   result = packet_ok (p, &remote_protocol_packets[PACKET_qTStatus]);\n \n@@ -13790,16 +13786,15 @@ remote_target::enable_btrace (ptid_t ptid, const struct btrace_config *conf)\n \n   /* If we fail to read the configuration, we lose some information, but the\n      tracing itself is not impacted.  */\n-  TRY\n+  try\n     {\n       btrace_read_config (&tinfo->conf);\n     }\n-  CATCH (err, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &err)\n     {\n       if (err.message != NULL)\n \twarning (\"%s\", err.what ());\n     }\n-  END_CATCH\n \n   return tinfo;\n }"
    },
    {
      "sha": "3cd9ba44d3df17b5493f8e198ef88cd0d57333ff",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -651,19 +651,18 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n   fputs_filtered (name, file);\n   print_spaces_filtered (value_column_1 - strlen (name), file);\n \n-  TRY\n+  try\n     {\n       val = value_of_register (regnum, frame);\n       regtype = value_type (val);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* Handle failure to read a register without interrupting the entire\n          'info registers' flow.  */\n       fprintf_filtered (file, \"%s\\n\", ex.what ());\n       return;\n     }\n-  END_CATCH\n \n   print_raw_format = (value_entirely_available (val)\n \t\t      && !value_optimized_out (val));\n@@ -2802,17 +2801,16 @@ riscv_frame_this_id (struct frame_info *this_frame,\n {\n   struct riscv_unwind_cache *cache;\n \n-  TRY\n+  try\n     {\n       cache = riscv_frame_cache (this_frame, prologue_cache);\n       *this_id = cache->this_id;\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* Ignore errors, this leaves the frame id as the predefined outer\n          frame id which terminates the backtrace at this point.  */\n     }\n-  END_CATCH\n }\n \n /* Implement the prev_register callback for RiscV frame unwinder.  */"
    },
    {
      "sha": "0c0f026be4f2ea8a40bab522cd73e2239e1ecced",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -670,18 +670,17 @@ rs6000_convert_from_func_ptr_addr (struct gdbarch *gdbarch,\n       CORE_ADDR pc = 0;\n       struct obj_section *pc_section;\n \n-      TRY\n+      try\n         {\n           pc = read_memory_unsigned_integer (addr, tdep->wordsize, byte_order);\n         }\n-      CATCH (e, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &e)\n         {\n           /* An error occured during reading.  Probably a memory error\n              due to the section not being loaded yet.  This address\n              cannot be a function descriptor.  */\n           return addr;\n         }\n-      END_CATCH\n \n       pc_section = find_pc_section (pc);\n "
    },
    {
      "sha": "2f08e0f54c025f860ab9c49d5aee1a24b4bd08f4",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -3451,7 +3451,7 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n   cache->pc = 0;\n   cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n \n-  TRY\n+  try\n     {\n       func = get_frame_func (this_frame);\n       cache->pc = func;\n@@ -3468,13 +3468,12 @@ rs6000_frame_cache (struct frame_info *this_frame, void **this_cache)\n       cache->base = get_frame_register_unsigned\n \t(this_frame, gdbarch_sp_regnum (gdbarch));\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n       return (struct rs6000_frame_cache *) (*this_cache);\n     }\n-  END_CATCH\n \n   /* If the function appears to be frameless, check a couple of likely\n      indicators that we have simply failed to find the frame setup.\n@@ -3683,7 +3682,7 @@ rs6000_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n   (*this_cache) = cache;\n   cache->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n \n-  TRY\n+  try\n     {\n       /* At this point the stack looks as if we just entered the\n \t function, and the return address is stored in LR.  */\n@@ -3698,12 +3697,11 @@ rs6000_epilogue_frame_cache (struct frame_info *this_frame, void **this_cache)\n       trad_frame_set_value (cache->saved_regs,\n \t\t\t    gdbarch_pc_regnum (gdbarch), lr);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return cache;\n }"
    },
    {
      "sha": "4aed05c0a954824b9ca4ece3d7fd3a433c0e969c",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2615,17 +2615,16 @@ static void\n rust_lex_exception_test (rust_parser *parser, const char *input,\n \t\t\t const char *err)\n {\n-  TRY\n+  try\n     {\n       /* The \"kind\" doesn't matter.  */\n       rust_lex_test_one (parser, input, DECIMAL_INTEGER);\n       SELF_CHECK (0);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       SELF_CHECK (strcmp (except.what (), err) == 0);\n     }\n-  END_CATCH\n }\n \n /* Test that INPUT lexes as the identifier, string, or byte-string"
    },
    {
      "sha": "c14b45b0a2848a308934687f3d68435ae74b8d68",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1743,18 +1743,17 @@ tuple structs, and tuple-like enum variants\"));\n \t\t       field_name, TYPE_NAME (outer_type),\n \t\t       rust_last_path_segment (TYPE_NAME (type)));\n \n-\t    TRY\n+\t    try\n \t      {\n \t\tresult = value_struct_elt (&lhs, NULL, field_name,\n \t\t\t\t\t   NULL, \"structure\");\n \t      }\n-\t    CATCH (except, RETURN_MASK_ERROR)\n+\t    catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t      {\n \t\terror (_(\"Could not find field %s of struct variant %s::%s\"),\n \t\t       field_name, TYPE_NAME (outer_type),\n \t\t       rust_last_path_segment (TYPE_NAME (type)));\n \t      }\n-\t    END_CATCH\n \t  }\n \telse\n \t  result = value_struct_elt (&lhs, NULL, field_name, NULL, \"structure\");"
    },
    {
      "sha": "d44c10869bd7880639a9117a8909ac58d9a06dbf",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -2547,19 +2547,18 @@ s390_frame_unwind_cache (struct frame_info *this_frame,\n   info->frame_base = -1;\n   info->local_base = -1;\n \n-  TRY\n+  try\n     {\n       /* Try to use prologue analysis to fill the unwind cache.\n \t If this fails, fall back to reading the stack backchain.  */\n       if (!s390_prologue_frame_unwind_cache (this_frame, info))\n \ts390_backchain_frame_unwind_cache (this_frame, info);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (ex.error != NOT_AVAILABLE_ERROR)\n \tthrow_exception (ex);\n     }\n-  END_CATCH\n \n   return info;\n }"
    },
    {
      "sha": "340056e73e000c966764b3971c5f01285f987f92",
      "filename": "gdb/selftest-arch.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/selftest-arch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/selftest-arch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/selftest-arch.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -60,7 +60,7 @@ struct gdbarch_selftest : public selftest\n \n \tQUIT;\n \n-\tTRY\n+\ttry\n \t  {\n \t    struct gdbarch_info info;\n \n@@ -72,13 +72,12 @@ struct gdbarch_selftest : public selftest\n \n \t    function (gdbarch);\n \t  }\n-\tCATCH (ex, RETURN_MASK_ERROR)\n+\tcatch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t  {\n \t    pass = false;\n \t    exception_fprintf (gdb_stderr, ex,\n \t\t\t       _(\"Self test failed: arch %s: \"), arches[i]);\n \t  }\n-\tEND_CATCH\n \n \treset ();\n       }"
    },
    {
      "sha": "4cd8a6997937fbbed419b78cc5df9f419a8d6fdd",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -830,14 +830,13 @@ enable_break (void)\n \t in the dynamic linker itself.  */\n \n       gdb_bfd_ref_ptr tmp_bfd;\n-      TRY\n+      try\n \t{\n \t  tmp_bfd = solib_bfd_open (buf);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t}\n-      END_CATCH\n \n       if (tmp_bfd == NULL)\n \t{"
    },
    {
      "sha": "63edd41cddcf6b994e36cbb17d72088b01aec4d2",
      "filename": "gdb/solib-frv.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-frv.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -561,14 +561,13 @@ enable_break2 (void)\n          mechanism to find the dynamic linker's base address.  */\n \n       gdb_bfd_ref_ptr tmp_bfd;\n-      TRY\n+      try\n         {\n           tmp_bfd = solib_bfd_open (buf);\n         }\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t}\n-      END_CATCH\n \n       if (tmp_bfd == NULL)\n \t{"
    },
    {
      "sha": "832da23b266c603060ca73c14bfdc4badb3bcf34",
      "filename": "gdb/solib-spu.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-spu.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -110,7 +110,7 @@ append_ocl_sos (struct so_list **link_ptr)\n         {\n \t  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd)?\n \t\t\t\t\t BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-\t  TRY\n+\t  try\n \t    {\n \t      CORE_ADDR data =\n \t\tread_memory_unsigned_integer (*ocl_program_addr_base,\n@@ -133,7 +133,7 @@ append_ocl_sos (struct so_list **link_ptr)\n \t\t  link_ptr = &newobj->next;\n \t\t}\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t    {\n \t      /* Ignore memory errors.  */\n \t      switch (ex.error)\n@@ -145,7 +145,6 @@ append_ocl_sos (struct so_list **link_ptr)\n \t\t  break;\n \t\t}\n \t    }\n-\t  END_CATCH\n \t}\n     }\n }"
    },
    {
      "sha": "53d5db864e0c0dbb54a131f3cd9364588944954f",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -869,16 +869,15 @@ solib_svr4_r_map (struct svr4_info *info)\n   struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n   CORE_ADDR addr = 0;\n \n-  TRY\n+  try\n     {\n       addr = read_memory_typed_address (info->debug_base + lmo->r_map_offset,\n                                         ptr_type);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   return addr;\n }\n@@ -906,19 +905,18 @@ solib_svr4_r_ldsomap (struct svr4_info *info)\n   enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n   ULONGEST version = 0;\n \n-  TRY\n+  try\n     {\n       /* Check version, and return zero if `struct r_debug' doesn't have\n \t the r_ldsomap member.  */\n       version\n \t= read_memory_unsigned_integer (info->debug_base + lmo->r_version_offset,\n \t\t\t\t\tlmo->r_version_size, byte_order);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   if (version < 2 || lmo->r_ldsomap_offset == -1)\n     return 0;\n@@ -1732,16 +1730,15 @@ solib_event_probe_action (struct probe_and_action *pa)\n        arg0: Lmid_t lmid (mandatory)\n        arg1: struct r_debug *debug_base (mandatory)\n        arg2: struct link_map *new (optional, for incremental updates)  */\n-  TRY\n+  try\n     {\n       probe_argc = pa->prob->get_argument_count (frame);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       exception_print (gdb_stderr, ex);\n       probe_argc = 0;\n     }\n-  END_CATCH\n \n   /* If get_argument_count throws an exception, probe_argc will be set\n      to zero.  However, if pa->prob does not have arguments, then\n@@ -1896,16 +1893,15 @@ svr4_handle_solib_event (void)\n     scoped_restore inhibit_updates\n       = inhibit_section_map_updates (current_program_space);\n \n-    TRY\n+    try\n       {\n \tval = pa->prob->evaluate_argument (1, frame);\n       }\n-    CATCH (ex, RETURN_MASK_ERROR)\n+    catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n       {\n \texception_print (gdb_stderr, ex);\n \tval = NULL;\n       }\n-    END_CATCH\n \n     if (val == NULL)\n       return;\n@@ -1928,16 +1924,15 @@ svr4_handle_solib_event (void)\n \n     if (action == UPDATE_OR_RELOAD)\n       {\n-\tTRY\n+\ttry\n \t  {\n \t    val = pa->prob->evaluate_argument (2, frame);\n \t  }\n-\tCATCH (ex, RETURN_MASK_ERROR)\n+\tcatch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t  {\n \t    exception_print (gdb_stderr, ex);\n \t    return;\n \t  }\n-\tEND_CATCH\n \n \tif (val != NULL)\n \t  lm = value_as_address (val);\n@@ -2279,14 +2274,13 @@ enable_break (struct svr4_info *info, int from_tty)\n          mechanism to find the dynamic linker's base address.  */\n \n       gdb_bfd_ref_ptr tmp_bfd;\n-      TRY\n+      try\n         {\n \t  tmp_bfd = solib_bfd_open (interp_name);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t}\n-      END_CATCH\n \n       if (tmp_bfd == NULL)\n \tgoto bkpt_at_symbol;"
    },
    {
      "sha": "75897ac55ad1850bfcc9c36c4e9ff937a7dda66f",
      "filename": "gdb/solib.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -674,7 +674,7 @@ solib_read_symbols (struct so_list *so, symfile_add_flags flags)\n \n       flags |= current_inferior ()->symfile_flags;\n \n-      TRY\n+      try\n \t{\n \t  /* Have we already loaded this shared object?  */\n \t  so->objfile = nullptr;\n@@ -700,13 +700,12 @@ solib_read_symbols (struct so_list *so, symfile_add_flags flags)\n \n \t  so->symbols_loaded = 1;\n \t}\n-      CATCH (e, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t{\n \t  exception_fprintf (gdb_stderr, e, _(\"Error while reading shared\"\n \t\t\t\t\t      \" library symbols for %s:\\n\"),\n \t\t\t     so->so_name);\n \t}\n-      END_CATCH\n \n       return 1;\n     }\n@@ -748,17 +747,16 @@ update_solib_list (int from_tty)\n \t symbols now!  */\n       if (inf->attach_flag && symfile_objfile == NULL)\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      ops->open_symbol_file_object (from_tty);\n \t    }\n-\t  CATCH (ex, RETURN_MASK_ALL)\n+\t  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t    {\n \t      exception_fprintf (gdb_stderr, ex,\n \t\t\t\t \"Error reading attached \"\n \t\t\t\t \"process's symbol file.\\n\");\n \t    }\n-\t  END_CATCH\n \t}\n     }\n \n@@ -868,7 +866,7 @@ update_solib_list (int from_tty)\n \t  i->pspace = current_program_space;\n \t  current_program_space->added_solibs.push_back (i);\n \n-\t  TRY\n+\t  try\n \t    {\n \t      /* Fill in the rest of the `struct so_list' node.  */\n \t      if (!solib_map_sections (i))\n@@ -879,13 +877,12 @@ update_solib_list (int from_tty)\n \t\t}\n \t    }\n \n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t      exception_fprintf (gdb_stderr, e,\n \t\t\t\t _(\"Error while mapping shared \"\n \t\t\t\t   \"library sections:\\n\"));\n \t    }\n-\t  END_CATCH\n \n \t  /* Notify any observer that the shared object has been\n \t     loaded now that we've added it to GDB's tables.  */\n@@ -1333,19 +1330,18 @@ reload_shared_libraries_1 (int from_tty)\n \t{\n \t  int got_error = 0;\n \n-\t  TRY\n+\t  try\n \t    {\n \t      solib_map_sections (so);\n \t    }\n \n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t      exception_fprintf (gdb_stderr, e,\n \t\t\t\t _(\"Error while mapping \"\n \t\t\t\t   \"shared library sections:\\n\"));\n \t      got_error = 1;\n \t    }\n-\t  END_CATCH\n \n \t    if (!got_error\n \t\t&& (auto_solib_add || was_loaded || libpthread_solib_p (so)))"
    },
    {
      "sha": "6f2b10f058fb8e4b0e2c832c88390e1fb570e7d6",
      "filename": "gdb/sparc64-linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/sparc64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/sparc64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-linux-tdep.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -130,19 +130,18 @@ sparc64_linux_handle_segmentation_fault (struct gdbarch *gdbarch,\n   CORE_ADDR addr = 0;\n   long si_code = 0;\n \n-  TRY\n+  try\n     {\n       /* Evaluate si_code to see if the segfault is ADI related.  */\n       si_code = parse_and_eval_long (\"$_siginfo.si_code\\n\");\n \n       if (si_code >= SEGV_ACCADI && si_code <= SEGV_ADIPERR)\n         addr = parse_and_eval_long (\"$_siginfo._sifields._sigfault.si_addr\");\n     }\n-  CATCH (exception, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &exception)\n     {\n       return;\n     }\n-  END_CATCH\n \n   /* Print out ADI event based on sig_code value */\n   switch (si_code)"
    },
    {
      "sha": "87588e10fcfed5c76b6809ddd43254d99e1e5e7e",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 22,
      "deletions": 33,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -175,17 +175,16 @@ print_stack_frame (struct frame_info *frame, int print_level,\n   if (current_uiout->is_mi_like_p ())\n     print_what = LOC_AND_ADDRESS;\n \n-  TRY\n+  try\n     {\n       print_frame_info (frame, print_level, print_what, 1 /* print_args */,\n \t\t\tset_current_sal);\n       if (set_current_sal)\n \tset_current_sal_from_frame (frame);\n     }\n-  CATCH (e, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n     {\n     }\n-  END_CATCH\n }\n \n /* Print nameless arguments of frame FRAME on STREAM, where START is\n@@ -267,7 +266,7 @@ print_frame_arg (const struct frame_arg *arg)\n \tstb.printf (_(\"<error reading variable: %s>\"), arg->error);\n       else\n \t{\n-\t  TRY\n+\t  try\n \t    {\n \t      const struct language_defn *language;\n \t      struct value_print_options opts;\n@@ -296,12 +295,11 @@ print_frame_arg (const struct frame_arg *arg)\n \n \t      common_val_print (arg->val, &stb, 2, &opts, language);\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      stb.printf (_(\"<error reading variable: %s>\"),\n \t\t\t  except.what ());\n \t    }\n-\t  END_CATCH\n \t}\n     }\n \n@@ -320,15 +318,14 @@ read_frame_local (struct symbol *sym, struct frame_info *frame,\n   argp->val = NULL;\n   argp->error = NULL;\n \n-  TRY\n+  try\n     {\n       argp->val = read_var_value (sym, NULL, frame);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       argp->error = xstrdup (except.what ());\n     }\n-  END_CATCH\n }\n \n /* Read in inferior function parameter SYM at FRAME into ARGP.  Caller is\n@@ -346,16 +343,15 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n   if (print_entry_values != print_entry_values_only\n       && print_entry_values != print_entry_values_preferred)\n     {\n-      TRY\n+      try\n \t{\n \t  val = read_var_value (sym, NULL, frame);\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  val_error = (char *) alloca (except.message->size () + 1);\n \t  strcpy (val_error, except.what ());\n \t}\n-      END_CATCH\n     }\n \n   if (SYMBOL_COMPUTED_OPS (sym) != NULL\n@@ -364,22 +360,21 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n       && (print_entry_values != print_entry_values_if_needed\n \t  || !val || value_optimized_out (val)))\n     {\n-      TRY\n+      try\n \t{\n \t  const struct symbol_computed_ops *ops;\n \n \t  ops = SYMBOL_COMPUTED_OPS (sym);\n \t  entryval = ops->read_variable_at_entry (sym, frame);\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  if (except.error != NO_ENTRY_VALUE_ERROR)\n \t    {\n \t      entryval_error = (char *) alloca (except.message->size () + 1);\n \t      strcpy (entryval_error, except.what ());\n \t    }\n \t}\n-      END_CATCH\n \n       if (entryval != NULL && value_optimized_out (entryval))\n \tentryval = NULL;\n@@ -407,7 +402,7 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n \t\t     value.  If it is a reference still try to verify if\n \t\t     dereferenced DW_AT_call_data_value does not differ.  */\n \n-\t\t  TRY\n+\t\t  try\n \t\t    {\n \t\t      struct type *type_deref;\n \n@@ -428,7 +423,7 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n \t\t\t\t\t\tTYPE_LENGTH (type_deref)))\n \t\t\tval_equal = 1;\n \t\t    }\n-\t\t  CATCH (except, RETURN_MASK_ERROR)\n+\t\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t\t    {\n \t\t      /* If the dereferenced content could not be\n \t\t\t fetched do not display anything.  */\n@@ -441,7 +436,6 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n \t\t\t  strcpy (entryval_error, except.what ());\n \t\t\t}\n \t\t    }\n-\t\t  END_CATCH\n \n \t\t  /* Value was not a reference; and its content matches.  */\n \t\t  if (val == val_deref)\n@@ -473,16 +467,15 @@ read_frame_arg (struct symbol *sym, struct frame_info *frame,\n \t{\n \t  gdb_assert (val == NULL);\n \n-\t  TRY\n+\t  try\n \t    {\n \t      val = read_var_value (sym, NULL, frame);\n \t    }\n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      val_error = (char *) alloca (except.message->size () + 1);\n \t      strcpy (val_error, except.what ());\n \t    }\n-\t  END_CATCH\n \t}\n       if (print_entry_values == print_entry_values_only\n \t  || print_entry_values == print_entry_values_both\n@@ -759,19 +752,18 @@ do_gdb_disassembly (struct gdbarch *gdbarch,\n \t\t    int how_many, CORE_ADDR low, CORE_ADDR high)\n {\n \n-  TRY\n+  try\n     {\n       gdb_disassembly (gdbarch, current_uiout,\n \t\t       DISASSEMBLY_RAW_INSN, how_many,\n \t\t       low, high);\n     }\n-  CATCH (exception, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n     {\n       /* If an exception was thrown while doing the disassembly, print\n \t the error message, to give the user a clue of what happened.  */\n       exception_print (gdb_stderr, exception);\n     }\n-  END_CATCH\n }\n \n /* Print information about frame FRAME.  The output is format according\n@@ -1204,14 +1196,13 @@ print_frame (struct frame_info *frame, int print_level,\n     \n \t{\n \t  ui_out_emit_list list_emitter (uiout, \"args\");\n-\t  TRY\n+\t  try\n \t    {\n \t      print_frame_args (func, frame, numargs, gdb_stdout);\n \t    }\n-\t  CATCH (e, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &e)\n \t    {\n \t    }\n-\t  END_CATCH\n \n \t    /* FIXME: ARGS must be a list.  If one argument is a string it\n \t       will have \" that will not be properly escaped.  */\n@@ -1393,12 +1384,12 @@ info_frame_command_core (struct frame_info *fi, bool selected_frame_p)\n     val_print_not_saved (gdb_stdout);\n   else\n     {\n-      TRY\n+      try\n \t{\n \t  caller_pc = frame_unwind_caller_pc (fi);\n \t  caller_pc_p = 1;\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  switch (ex.error)\n \t    {\n@@ -1414,7 +1405,6 @@ info_frame_command_core (struct frame_info *fi, bool selected_frame_p)\n \t      break;\n \t    }\n \t}\n-      END_CATCH\n     }\n \n   if (caller_pc_p)\n@@ -2694,7 +2684,7 @@ frame_apply_command_count (const char *which_command,\n       QUIT;\n \n       select_frame (fi);\n-      TRY\n+      try\n \t{\n \t  std::string cmd_result;\n \t  {\n@@ -2714,7 +2704,7 @@ frame_apply_command_count (const char *which_command,\n \t      printf_filtered (\"%s\", cmd_result.c_str ());\n \t    }\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  fi = get_selected_frame (_(\"frame apply \"\n \t\t\t\t     \"unable to get selected frame.\"));\n@@ -2728,7 +2718,6 @@ frame_apply_command_count (const char *which_command,\n \t\tthrow_exception (ex);\n \t    }\n \t}\n-      END_CATCH;\n     }\n }\n "
    },
    {
      "sha": "118f28987a311ffabcc067c7da8e927bde220706",
      "filename": "gdb/symfile-mem.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/symfile-mem.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/symfile-mem.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile-mem.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -187,7 +187,7 @@ add_vsyscall_page (struct target_ops *target, int from_tty)\n \n       char *name = xstrprintf (\"system-supplied DSO at %s\",\n \t\t\t       paddress (target_gdbarch (), vsyscall_range.start));\n-      TRY\n+      try\n \t{\n \t  /* Pass zero for FROM_TTY, because the action of loading the\n \t     vsyscall DSO was not triggered by the user, even if the\n@@ -198,11 +198,10 @@ add_vsyscall_page (struct target_ops *target, int from_tty)\n \t\t\t\t       name,\n \t\t\t\t       0 /* from_tty */);\n \t}\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  exception_print (gdb_stderr, ex);\n \t}\n-      END_CATCH\n     }\n }\n "
    },
    {
      "sha": "8867ba75d0fce3995b06536807cdc335f74d2773",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -349,16 +349,15 @@ dump_symtab_1 (struct symtab *symtab, struct ui_file *outfile)\n \t     block, not any blocks from included symtabs.  */\n \t  ALL_DICT_SYMBOLS (BLOCK_MULTIDICT (b), miter, sym)\n \t    {\n-\t      TRY\n+\t      try\n \t\t{\n \t\t  print_symbol (gdbarch, sym, depth + 1, outfile);\n \t\t}\n-\t      CATCH (ex, RETURN_MASK_ERROR)\n+\t      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t\t{\n \t\t  exception_fprintf (gdb_stderr, ex,\n \t\t\t\t     \"Error printing symbol:\\n\");\n \t\t}\n-\t      END_CATCH\n \t    }\n \t}\n       fprintf_filtered (outfile, \"\\n\");"
    },
    {
      "sha": "9b777ea8a07e0b65480270435889667620545cb2",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -704,7 +704,7 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)\n     {\n       ptid_t ptid = inferior_ptid;\n \n-      TRY\n+      try\n \t{\n \t  CORE_ADDR lm_addr;\n \t  \n@@ -720,7 +720,7 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)\n \t}\n       /* If an error occurred, print TLS related messages here.  Otherwise,\n          throw the error to some higher catcher.  */\n-      CATCH (ex, RETURN_MASK_ALL)\n+      catch (const gdb_exception_RETURN_MASK_ALL &ex)\n \t{\n \t  int objfile_is_library = (objfile->flags & OBJF_SHARED);\n \n@@ -771,7 +771,6 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)\n \t      break;\n \t    }\n \t}\n-      END_CATCH\n     }\n   else\n     error (_(\"Cannot find thread-local variables on this target\"));"
    },
    {
      "sha": "cde7c34df692741127da848b306be02edd43b142",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1459,7 +1459,7 @@ thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n \t\t   const qcs_flags &flags)\n {\n   switch_to_thread (thr);\n-  TRY\n+  try\n     {\n       std::string cmd_result = execute_command_to_string (cmd, from_tty);\n       if (!flags.silent || cmd_result.length () > 0)\n@@ -1471,7 +1471,7 @@ thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n \t  printf_filtered (\"%s\", cmd_result.c_str ());\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       if (!flags.silent)\n \t{\n@@ -1485,7 +1485,6 @@ thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n \t    throw_exception (ex);\n \t}\n     }\n-  END_CATCH;\n }\n \n /* Apply a GDB command to a list of threads.  List syntax is a whitespace"
    },
    {
      "sha": "829b5340f37514406f6e1c66a302ddc2a34f4c21",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 8,
      "deletions": 12,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1621,31 +1621,29 @@ quit_force (int *exit_arg, int from_tty)\n   /* We want to handle any quit errors and exit regardless.  */\n \n   /* Get out of tfind mode, and kill or detach all inferiors.  */\n-  TRY\n+  try\n     {\n       disconnect_tracing ();\n       iterate_over_inferiors (kill_or_detach, &qt);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   /* Give all pushed targets a chance to do minimal cleanup, and pop\n      them all out.  */\n-  TRY\n+  try\n     {\n       pop_all_targets ();\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   /* Save the history information if it is appropriate to do so.  */\n-  TRY\n+  try\n     {\n       if (write_history_p && history_filename)\n \t{\n@@ -1667,11 +1665,10 @@ quit_force (int *exit_arg, int from_tty)\n \t    gdb_safe_append_history ();\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   /* Destroy any values currently allocated now instead of leaving it\n      to global destructors, because that may be too late.  For\n@@ -1680,15 +1677,14 @@ quit_force (int *exit_arg, int from_tty)\n   finalize_values ();\n \n   /* Do any final cleanups before exiting.  */\n-  TRY\n+  try\n     {\n       do_final_cleanups ();\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n \n   exit (exit_code);\n }"
    },
    {
      "sha": "6581cb133dcc1375e9cfd36bd2b02d2b3994033b",
      "filename": "gdb/tracefile-tfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/tracefile-tfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/tracefile-tfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracefile-tfile.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -511,7 +511,7 @@ tfile_target_open (const char *arg, int from_tty)\n   ts->disconnected_tracing = 0;\n   ts->circular_buffer = 0;\n \n-  TRY\n+  try\n     {\n       /* Read through a section of newline-terminated lines that\n \t define things like tracepoints.  */\n@@ -547,13 +547,12 @@ tfile_target_open (const char *arg, int from_tty)\n       if (trace_regblock_size == 0)\n \terror (_(\"No register block size recorded in trace file\"));\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       /* Remove the partially set up target.  */\n       unpush_target (&tfile_ops);\n       throw_exception (ex);\n     }\n-  END_CATCH\n \n   inferior_appeared (current_inferior (), TFILE_PID);\n   inferior_ptid = ptid_t (TFILE_PID);"
    },
    {
      "sha": "533b7bc8ab8adb8f3079bff18a69d34874c88db1",
      "filename": "gdb/tui/tui.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/tui/tui.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/tui/tui.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -96,7 +96,7 @@ tui_rl_switch_mode (int notused1, int notused2)\n \n   /* Don't let exceptions escape.  We're in the middle of a readline\n      callback that isn't prepared for that.  */\n-  TRY\n+  try\n     {\n       if (tui_active)\n \t{\n@@ -110,14 +110,13 @@ tui_rl_switch_mode (int notused1, int notused2)\n \t  tui_enable ();\n \t}\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n \n       if (!tui_active)\n \trl_prep_terminal (0);\n     }\n-  END_CATCH\n \n   /* Clear the readline in case switching occurred in middle of\n      something.  */"
    },
    {
      "sha": "91ce29b1b28dc6cc2eb57fb5afb900c48a44efc2",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -413,17 +413,16 @@ type_print (struct type *type, const char *varstring, struct ui_file *stream,\n std::string\n type_to_string (struct type *type)\n {\n-  TRY\n+  try\n     {\n       string_file stb;\n \n       type_print (type, \"\", &stb, -1);\n       return std::move (stb.string ());\n     }\n-  CATCH (except, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &except)\n     {\n     }\n-  END_CATCH\n \n   return {};\n }"
    },
    {
      "sha": "6b0efe53decd2709bff4d8f48c64031f945385e1",
      "filename": "gdb/unittests/cli-utils-selftests.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/unittests/cli-utils-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/unittests/cli-utils-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/cli-utils-selftests.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -78,19 +78,18 @@ test_number_or_range_parser ()\n     number_or_range_parser minus_one (\"-1\");\n \n     SELF_CHECK (!minus_one.finished ());\n-    TRY\n+    try\n       {\n \tminus_one.get_number ();\n \tSELF_CHECK (false);\n       }\n-    CATCH (ex, RETURN_MASK_ERROR)\n+    catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n       {\n \tSELF_CHECK (ex.reason == RETURN_ERROR);\n \tSELF_CHECK (ex.error == GENERIC_ERROR);\n \tSELF_CHECK (strcmp (ex.what (), \"negative value\") == 0);\n \tSELF_CHECK (strcmp (minus_one.cur_tok (), \"-1\") == 0);\n       }\n-    END_CATCH;\n   }\n \n   /* Test that a - followed by not a number does not give an error.  */\n@@ -209,7 +208,7 @@ test_parse_flags_qcs ()\n     const char *t4 = \"-c -s non flags args\";\n     qcs_flags flags;\n \n-    TRY\n+    try\n       {\n \tSELF_CHECK (parse_flags_qcs (\"test_parse_flags_qcs.t4.cs\",\n \t\t\t\t     &t4,\n@@ -220,7 +219,7 @@ test_parse_flags_qcs ()\n \t\t\t\t&flags);\n \tSELF_CHECK (false);\n       }\n-    CATCH (ex, RETURN_MASK_ERROR)\n+    catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n       {\n \tSELF_CHECK (ex.reason == RETURN_ERROR);\n \tSELF_CHECK (ex.error == GENERIC_ERROR);\n@@ -229,7 +228,6 @@ test_parse_flags_qcs ()\n \t\t   \"test_parse_flags_qcs.t4.cs: \"\n \t\t   \"-c and -s are mutually exclusive\") == 0);\n       }\n-    END_CATCH;\n   }\n \n }"
    },
    {
      "sha": "a33b3d8de6de2e52a4c2cbeb7d8e82bb2efaee33",
      "filename": "gdb/unittests/parse-connection-spec-selftests.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/unittests/parse-connection-spec-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/unittests/parse-connection-spec-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/parse-connection-spec-selftests.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -212,18 +212,17 @@ test_conn (const parse_conn_test &c)\n \n   memset (&hint, 0, sizeof (hint));\n \n-  TRY\n+  try\n     {\n       ret = parse_connection_spec (c.connspec, &hint);\n     }\n-  CATCH (ex, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n     {\n       /* If we caught an error, we should check if this connection\n \t spec was supposed to fail.  */\n       SELF_CHECK (c.should_fail);\n       return;\n     }\n-  END_CATCH\n \n   SELF_CHECK (!c.should_fail);\n   SELF_CHECK (ret.host_str == c.expected_result.host_str);"
    },
    {
      "sha": "69da319ea7d70ea9d9c4dddea133fa4878599795",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -3621,11 +3621,11 @@ value_rtti_indirect_type (struct value *v, int *full,\n   else if (TYPE_CODE (type) == TYPE_CODE_PTR)\n     {\n \n-      TRY\n+      try\n         {\n \t  target = value_ind (v);\n         }\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  if (except.error == MEMORY_ERROR)\n \t    {\n@@ -3636,7 +3636,6 @@ value_rtti_indirect_type (struct value *v, int *full,\n \t    }\n \t  throw_exception (except);\n \t}\n-      END_CATCH\n     }\n   else\n     return NULL;\n@@ -3774,14 +3773,13 @@ value_of_this_silent (const struct language_defn *lang)\n {\n   struct value *ret = NULL;\n \n-  TRY\n+  try\n     {\n       ret = value_of_this (lang);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n     }\n-  END_CATCH\n \n   return ret;\n }"
    },
    {
      "sha": "755473038f80210f43fe97377ee47f533d88da95",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1054,17 +1054,16 @@ val_print (struct type *type, LONGEST embedded_offset,\n       return;\n     }\n \n-  TRY\n+  try\n     {\n       language->la_val_print (type, embedded_offset, address,\n \t\t\t      stream, recurse, val,\n \t\t\t      &local_opts);\n     }\n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       fprintf_filtered (stream, _(\"<error reading variable>\"));\n     }\n-  END_CATCH\n }\n \n /* Check whether the value VAL is printable.  Return 1 if it is;"
    },
    {
      "sha": "99a27b5e7b346f1fab0bda196fc01e1d5299091d",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -1405,15 +1405,14 @@ value_optimized_out (struct value *value)\n      fetch it.  */\n   if (value->optimized_out.empty () && value->lazy)\n     {\n-      TRY\n+      try\n \t{\n \t  value_fetch_lazy (value);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  /* Fall back to checking value->optimized_out.  */\n \t}\n-      END_CATCH\n     }\n \n   return !value->optimized_out.empty ();\n@@ -2535,18 +2534,17 @@ show_convenience (const char *ignore, int from_tty)\n \t}\n       printf_filtered ((\"$%s = \"), var->name);\n \n-      TRY\n+      try\n \t{\n \t  struct value *val;\n \n \t  val = value_of_internalvar (gdbarch, var);\n \t  value_print (val, gdb_stdout, &opts);\n \t}\n-      CATCH (ex, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &ex)\n \t{\n \t  fprintf_filtered (gdb_stdout, _(\"<error: %s>\"), ex.what ());\n \t}\n-      END_CATCH\n \n       printf_filtered ((\"\\n\"));\n     }"
    },
    {
      "sha": "54b0943d2ea7c440e10cbdb09ec2c2cfc72d0275",
      "filename": "gdb/varobj.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/varobj.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -314,16 +314,15 @@ varobj_create (const char *objname,\n \t\t\t\t       | INNERMOST_BLOCK_FOR_REGISTERS);\n       /* Wrap the call to parse expression, so we can \n          return a sensible error.  */\n-      TRY\n+      try\n \t{\n \t  var->root->exp = parse_exp_1 (&p, pc, block, 0, &tracker);\n \t}\n \n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  return NULL;\n \t}\n-      END_CATCH\n \n       /* Don't allow variables to be created for types.  */\n       if (var->root->exp->elts[0].opcode == OP_TYPE\n@@ -364,19 +363,18 @@ varobj_create (const char *objname,\n       /* We definitely need to catch errors here.\n          If evaluate_expression succeeds we got the value we wanted.\n          But if it fails, we still go on with a call to evaluate_type().  */\n-      TRY\n+      try\n \t{\n \t  value = evaluate_expression (var->root->exp.get ());\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t  /* Error getting the value.  Try to at least get the\n \t     right type.  */\n \t  struct value *type_only_value = evaluate_type (var->root->exp.get ());\n \n \t  var->type = value_type (type_only_value);\n \t}\n-      END_CATCH\n \n       if (value != NULL)\n \t{\n@@ -1034,17 +1032,16 @@ varobj_set_value (struct varobj *var, const char *expression)\n \n   input_radix = 10;\t\t/* ALWAYS reset to decimal temporarily.  */\n   expression_up exp = parse_exp_1 (&s, 0, 0, 0);\n-  TRY\n+  try\n     {\n       value = evaluate_expression (exp.get ());\n     }\n \n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       /* We cannot proceed without a valid expression.  */\n       return false;\n     }\n-  END_CATCH\n \n   /* All types that are editable must also be changeable.  */\n   gdb_assert (varobj_value_is_changeable_p (var));\n@@ -1063,16 +1060,15 @@ varobj_set_value (struct varobj *var, const char *expression)\n \n   /* The new value may be lazy.  value_assign, or\n      rather value_contents, will take care of this.  */\n-  TRY\n+  try\n     {\n       val = value_assign (var->value.get (), value);\n     }\n \n-  CATCH (except, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n     {\n       return false;\n     }\n-  END_CATCH\n \n   /* If the value has changed, record it, so that next -var-update can\n      report this change.  If a variable had a value of '1', we've set it\n@@ -1311,19 +1307,18 @@ install_new_value (struct varobj *var, struct value *value, bool initial)\n       else\n \t{\n \n-\t  TRY\n+\t  try\n \t    {\n \t      value_fetch_lazy (value);\n \t    }\n \n-\t  CATCH (except, RETURN_MASK_ERROR)\n+\t  catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t    {\n \t      /* Set the value to NULL, so that for the next -var-update,\n \t\t we don't try to compare the new value with this value,\n \t\t that we couldn't even read.  */\n \t      value = NULL;\n \t    }\n-\t  END_CATCH\n \t}\n     }\n \n@@ -2139,14 +2134,13 @@ value_of_root_1 (struct varobj **var_handle)\n \n       /* We need to catch errors here, because if evaluate\n          expression fails we want to just return NULL.  */\n-      TRY\n+      try\n \t{\n \t  new_val = evaluate_expression (var->root->exp.get ());\n \t}\n-      CATCH (except, RETURN_MASK_ERROR)\n+      catch (const gdb_exception_RETURN_MASK_ERROR &except)\n \t{\n \t}\n-      END_CATCH\n     }\n \n   return new_val;"
    },
    {
      "sha": "0df9e312d33c866b0b3942354895f427a33dcc7f",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -943,15 +943,14 @@ handle_unload_dll ()\n static void\n catch_errors (void (*func) ())\n {\n-  TRY\n+  try\n     {\n       func ();\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       exception_print (gdb_stderr, ex);\n     }\n-  END_CATCH\n }\n \n /* Clear list of loaded DLLs.  */"
    },
    {
      "sha": "1aa491ac3732ad0270e85d868edfccd7e547ce0e",
      "filename": "gdb/x86-linux-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/x86-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/x86-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/x86-linux-nat.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -217,16 +217,15 @@ x86_linux_nat_target::enable_btrace (ptid_t ptid,\n \t\t\t\t     const struct btrace_config *conf)\n {\n   struct btrace_target_info *tinfo = nullptr;\n-  TRY\n+  try\n     {\n       tinfo = linux_enable_btrace (ptid, conf);\n     }\n-  CATCH (exception, RETURN_MASK_ERROR)\n+  catch (const gdb_exception_RETURN_MASK_ERROR &exception)\n     {\n       error (_(\"Could not enable branch tracing for %s: %s\"),\n \t     target_pid_to_str (ptid).c_str (), exception.what ());\n     }\n-  END_CATCH\n \n   return tinfo;\n }"
    },
    {
      "sha": "1a89213ab8ff45af988105c547b18dd9b3cbf433",
      "filename": "gdb/xml-support.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/xml-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a70b814420059e1f2de2130d532ddd7b2b2500fc/gdb/xml-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xml-support.c?ref=a70b814420059e1f2de2130d532ddd7b2b2500fc",
      "patch": "@@ -383,15 +383,14 @@ gdb_xml_start_element_wrapper (void *data, const XML_Char *name,\n {\n   struct gdb_xml_parser *parser = (struct gdb_xml_parser *) data;\n \n-  TRY\n+  try\n     {\n       parser->start_element (name, attrs);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       parser->set_error (ex);\n     }\n-  END_CATCH\n }\n \n /* Handle the end of an element.  NAME is the current element.  */\n@@ -456,15 +455,14 @@ gdb_xml_end_element_wrapper (void *data, const XML_Char *name)\n {\n   struct gdb_xml_parser *parser = (struct gdb_xml_parser *) data;\n \n-  TRY\n+  try\n     {\n       parser->end_element (name);\n     }\n-  CATCH (ex, RETURN_MASK_ALL)\n+  catch (const gdb_exception_RETURN_MASK_ALL &ex)\n     {\n       parser->set_error (ex);\n     }\n-  END_CATCH\n }\n \n /* Free a parser and all its associated state.  */"
    }
  ]
}