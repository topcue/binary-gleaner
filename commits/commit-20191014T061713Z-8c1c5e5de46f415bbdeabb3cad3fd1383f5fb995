{
  "sha": "8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGMxYzVlNWRlNDZmNDE1YmJkZWFiYjNjYWQzZmQxMzgzZjVmYjk5NQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-14T03:19:34Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-14T06:17:13Z"
    },
    "message": "qsort: SHF_LINK_ORDER section sort\n\nThe linker SHF_LINK_ORDER section sorting had a number of defects.\n1) The ordering was by VMA, which won't work with overlays.  LMA is\n   better.\n2) Zero size sections can result in two sections at the same LMA/VMA.\n   When only one of the two sections at the same LMA is zero size,\n   that one must be first.\n3) Warnings given by elf_get_linked_section_vma won't ever be emitted\n   since elf_object_p warns and excludes objects with zero sh_link on\n   a SHF_LINK_ORDER section.\n4) Section offset was adjusted down rather than up by section\n   alignment, possibly creating overlapping sections.\n5) Finding the linked section did so the hard way, rather than simply\n   using elf_linked_to_section.\n\n\t* elflink.c (elf_get_linked_section_vma): Delete.\n\t(compare_link_order): Use elf_linked_to_section and sort by lma,\n\tsize, and id.\n\t(elf_fixup_link_order): Use size_t variables where appropriate.\n\tMake use of elf_linked_to_section.  Formatting.  Properly align\n\tsections.",
    "tree": {
      "sha": "f8065506654e5d7d4329be4629e253e8692ecfa3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f8065506654e5d7d4329be4629e253e8692ecfa3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dcea6a95d78370c8b4ac3c0033d9f15aaabf31bf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dcea6a95d78370c8b4ac3c0033d9f15aaabf31bf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dcea6a95d78370c8b4ac3c0033d9f15aaabf31bf"
    }
  ],
  "stats": {
    "total": 112,
    "additions": 51,
    "deletions": 61
  },
  "files": [
    {
      "sha": "e9c17584a46912bbc0bdd87e1a0ebbb6d1f34e46",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
      "patch": "@@ -1,3 +1,12 @@\n+2019-10-14  Alan Modra  <amodra@gmail.com>\n+\n+\t* elflink.c (elf_get_linked_section_vma): Delete.\n+\t(compare_link_order): Use elf_linked_to_section and sort by lma,\n+\tsize, and id.\n+\t(elf_fixup_link_order): Use size_t variables where appropriate.\n+\tMake use of elf_linked_to_section.  Formatting.  Properly align\n+\tsections.\n+\n 2019-10-14  Alan Modra  <amodra@gmail.com>\n \n \t* elf-strtab.c (strrevcmp): Comment."
    },
    {
      "sha": "fedaf4b5a1f44efec32bf6be2d4591614caae66b",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 42,
      "deletions": 61,
      "changes": 103,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
      "patch": "@@ -11478,56 +11478,43 @@ elf_reloc_link_order (bfd *output_bfd,\n }\n \n \n-/* Get the output vma of the section pointed to by the sh_link field.  */\n-\n-static bfd_vma\n-elf_get_linked_section_vma (struct bfd_link_order *p)\n-{\n-  Elf_Internal_Shdr **elf_shdrp;\n-  asection *s;\n-  int elfsec;\n-\n-  s = p->u.indirect.section;\n-  elf_shdrp = elf_elfsections (s->owner);\n-  elfsec = _bfd_elf_section_from_bfd_section (s->owner, s);\n-  elfsec = elf_shdrp[elfsec]->sh_link;\n-  /* PR 290:\n-     The Intel C compiler generates SHT_IA_64_UNWIND with\n-     SHF_LINK_ORDER.  But it doesn't set the sh_link or\n-     sh_info fields.  Hence we could get the situation\n-     where elfsec is 0.  */\n-  if (elfsec == 0)\n-    {\n-      const struct elf_backend_data *bed\n-\t= get_elf_backend_data (s->owner);\n-      if (bed->link_order_error_handler)\n-\tbed->link_order_error_handler\n-\t  /* xgettext:c-format */\n-\t  (_(\"%pB: warning: sh_link not set for section `%pA'\"), s->owner, s);\n-      return 0;\n-    }\n-  else\n-    {\n-      s = elf_shdrp[elfsec]->bfd_section;\n-      return s->output_section->vma + s->output_offset;\n-    }\n-}\n-\n-\n /* Compare two sections based on the locations of the sections they are\n    linked to.  Used by elf_fixup_link_order.  */\n \n static int\n-compare_link_order (const void * a, const void * b)\n+compare_link_order (const void *a, const void *b)\n {\n-  bfd_vma apos;\n-  bfd_vma bpos;\n+  const struct bfd_link_order *alo = *(const struct bfd_link_order **) a;\n+  const struct bfd_link_order *blo = *(const struct bfd_link_order **) b;\n+  asection *asec = elf_linked_to_section (alo->u.indirect.section);\n+  asection *bsec = elf_linked_to_section (blo->u.indirect.section);\n+  bfd_vma apos = asec->output_section->lma + asec->output_offset;\n+  bfd_vma bpos = bsec->output_section->lma + bsec->output_offset;\n \n-  apos = elf_get_linked_section_vma (*(struct bfd_link_order **)a);\n-  bpos = elf_get_linked_section_vma (*(struct bfd_link_order **)b);\n   if (apos < bpos)\n     return -1;\n-  return apos > bpos;\n+  if (apos > bpos)\n+    return 1;\n+\n+  /* The only way we should get matching LMAs is when the first of two\n+     sections has zero size.  */\n+  if (asec->size < bsec->size)\n+    return -1;\n+  if (asec->size > bsec->size)\n+    return 1;\n+\n+  /* If they are both zero size then they almost certainly have the same\n+     VMA and thus are not ordered with respect to each other.  Test VMA\n+     anyway, and fall back to id to make the result reproducible across\n+     qsort implementations.  */\n+  apos = asec->output_section->vma + asec->output_offset;\n+  bpos = bsec->output_section->vma + bsec->output_offset;\n+  if (apos < bpos)\n+    return -1;\n+  if (apos > bpos)\n+    return 1;\n+\n+  return asec->id - bsec->id;\n }\n \n \n@@ -11539,13 +11526,11 @@ compare_link_order (const void * a, const void * b)\n static bfd_boolean\n elf_fixup_link_order (bfd *abfd, asection *o)\n {\n-  int seen_linkorder;\n-  int seen_other;\n-  int n;\n+  size_t seen_linkorder;\n+  size_t seen_other;\n+  size_t n;\n   struct bfd_link_order *p;\n   bfd *sub;\n-  const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n-  unsigned elfsec;\n   struct bfd_link_order **sections;\n   asection *s, *other_sec, *linkorder_sec;\n   bfd_vma offset;\n@@ -11562,11 +11547,8 @@ elf_fixup_link_order (bfd *abfd, asection *o)\n \t  sub = s->owner;\n \t  if ((s->flags & SEC_LINKER_CREATED) == 0\n \t      && bfd_get_flavour (sub) == bfd_target_elf_flavour\n-\t      && elf_elfheader (sub)->e_ident[EI_CLASS] == bed->s->elfclass\n-\t      && (elfsec = _bfd_elf_section_from_bfd_section (sub, s))\n-\t      && elfsec < elf_numsections (sub)\n-\t      && elf_elfsections (sub)[elfsec]->sh_flags & SHF_LINK_ORDER\n-\t      && elf_elfsections (sub)[elfsec]->sh_link < elf_numsections (sub))\n+\t      && elf_section_data (s) != NULL\n+\t      && elf_linked_to_section (s) != NULL)\n \t    {\n \t      seen_linkorder++;\n \t      linkorder_sec = s;\n@@ -11600,26 +11582,25 @@ elf_fixup_link_order (bfd *abfd, asection *o)\n   if (!seen_linkorder)\n     return TRUE;\n \n-  sections = (struct bfd_link_order **)\n-    bfd_malloc (seen_linkorder * sizeof (struct bfd_link_order *));\n+  sections = bfd_malloc (seen_linkorder * sizeof (*sections));\n   if (sections == NULL)\n     return FALSE;\n-  seen_linkorder = 0;\n \n+  seen_linkorder = 0;\n   for (p = o->map_head.link_order; p != NULL; p = p->next)\n-    {\n-      sections[seen_linkorder++] = p;\n-    }\n+    sections[seen_linkorder++] = p;\n+\n   /* Sort the input sections in the order of their linked section.  */\n-  qsort (sections, seen_linkorder, sizeof (struct bfd_link_order *),\n-\t compare_link_order);\n+  qsort (sections, seen_linkorder, sizeof (*sections), compare_link_order);\n \n   /* Change the offsets of the sections.  */\n   offset = 0;\n   for (n = 0; n < seen_linkorder; n++)\n     {\n+      bfd_vma mask;\n       s = sections[n]->u.indirect.section;\n-      offset &= ~(bfd_vma) 0 << s->alignment_power;\n+      mask = ~(bfd_vma) 0 << s->alignment_power;\n+      offset = (offset + ~mask) & mask;\n       s->output_offset = offset / bfd_octets_per_byte (abfd);\n       sections[n]->offset = offset;\n       offset += sections[n]->size;"
    }
  ]
}