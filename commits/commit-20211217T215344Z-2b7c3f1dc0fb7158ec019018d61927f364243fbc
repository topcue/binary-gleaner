{
  "sha": "2b7c3f1dc0fb7158ec019018d61927f364243fbc",
  "node_id": "C_kwDOANOeidoAKDJiN2MzZjFkYzBmYjcxNThlYzAxOTAxOGQ2MTkyN2YzNjQyNDNmYmM",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-14T23:48:45Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T21:53:44Z"
    },
    "message": "Split gdbarch.h into two files\n\nThis patch splits gdbarch.h into two files -- gdbarch.h now is\neditable and hand-maintained, and the new gdbarch-gen.h file is the\nonly thing generated by gdbarch.sh.  This lets us avoid maintaining\nboilerplate in the gdbarch.sh file.\n\nNote that gdbarch.sh still generates gdbarch.h after this patch.  This\nmakes it easier to re-run when rebasing.  This code is removed in a\nsubsequent patch.",
    "tree": {
      "sha": "1b209bfe3cde34918f38ab974bfeabbec0d7570e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1b209bfe3cde34918f38ab974bfeabbec0d7570e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2b7c3f1dc0fb7158ec019018d61927f364243fbc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b7c3f1dc0fb7158ec019018d61927f364243fbc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2b7c3f1dc0fb7158ec019018d61927f364243fbc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b7c3f1dc0fb7158ec019018d61927f364243fbc/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "74fcd19c514f7beb24ab842381453efb74a8ac58",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74fcd19c514f7beb24ab842381453efb74a8ac58",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/74fcd19c514f7beb24ab842381453efb74a8ac58"
    }
  ],
  "stats": {
    "total": 3331,
    "additions": 1681,
    "deletions": 1650
  },
  "files": [
    {
      "sha": "3edf9708d0641b3fb9b6a1986d5e70a3aacf82b5",
      "filename": "gdb/gdbarch-gen.h",
      "status": "added",
      "additions": 1608,
      "deletions": 0,
      "changes": 1608,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch-gen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch-gen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch-gen.h?ref=2b7c3f1dc0fb7158ec019018d61927f364243fbc",
      "patch": "@@ -0,0 +1,1608 @@\n+/* *INDENT-OFF* */ /* THIS FILE IS GENERATED -*- buffer-read-only: t -*- */\n+/* vi:set ro: */\n+\n+/* Dynamic architecture support for GDB, the GNU debugger.\n+\n+   Copyright (C) 1998-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file was created with the aid of ``gdbarch.sh''.  */\n+\n+\n+\n+/* The following are pre-initialized by GDBARCH.  */\n+\n+extern const struct bfd_arch_info * gdbarch_bfd_arch_info (struct gdbarch *gdbarch);\n+/* set_gdbarch_bfd_arch_info() - not applicable - pre-initialized.  */\n+\n+extern enum bfd_endian gdbarch_byte_order (struct gdbarch *gdbarch);\n+/* set_gdbarch_byte_order() - not applicable - pre-initialized.  */\n+\n+extern enum bfd_endian gdbarch_byte_order_for_code (struct gdbarch *gdbarch);\n+/* set_gdbarch_byte_order_for_code() - not applicable - pre-initialized.  */\n+\n+extern enum gdb_osabi gdbarch_osabi (struct gdbarch *gdbarch);\n+/* set_gdbarch_osabi() - not applicable - pre-initialized.  */\n+\n+extern const struct target_desc * gdbarch_target_desc (struct gdbarch *gdbarch);\n+/* set_gdbarch_target_desc() - not applicable - pre-initialized.  */\n+\n+\n+/* The following are initialized by the target dependent code.  */\n+\n+/* Number of bits in a short or unsigned short for the target machine. */\n+\n+extern int gdbarch_short_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_short_bit (struct gdbarch *gdbarch, int short_bit);\n+\n+/* Number of bits in an int or unsigned int for the target machine. */\n+\n+extern int gdbarch_int_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_int_bit (struct gdbarch *gdbarch, int int_bit);\n+\n+/* Number of bits in a long or unsigned long for the target machine. */\n+\n+extern int gdbarch_long_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_long_bit (struct gdbarch *gdbarch, int long_bit);\n+\n+/* Number of bits in a long long or unsigned long long for the target\n+   machine. */\n+\n+extern int gdbarch_long_long_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_long_long_bit (struct gdbarch *gdbarch, int long_long_bit);\n+\n+/* The ABI default bit-size and format for \"bfloat16\", \"half\", \"float\", \"double\", and\n+   \"long double\".  These bit/format pairs should eventually be combined\n+   into a single object.  For the moment, just initialize them as a pair.\n+   Each format describes both the big and little endian layouts (if\n+   useful). */\n+\n+extern int gdbarch_bfloat16_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_bfloat16_bit (struct gdbarch *gdbarch, int bfloat16_bit);\n+\n+extern const struct floatformat ** gdbarch_bfloat16_format (struct gdbarch *gdbarch);\n+extern void set_gdbarch_bfloat16_format (struct gdbarch *gdbarch, const struct floatformat ** bfloat16_format);\n+\n+extern int gdbarch_half_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_half_bit (struct gdbarch *gdbarch, int half_bit);\n+\n+extern const struct floatformat ** gdbarch_half_format (struct gdbarch *gdbarch);\n+extern void set_gdbarch_half_format (struct gdbarch *gdbarch, const struct floatformat ** half_format);\n+\n+extern int gdbarch_float_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_float_bit (struct gdbarch *gdbarch, int float_bit);\n+\n+extern const struct floatformat ** gdbarch_float_format (struct gdbarch *gdbarch);\n+extern void set_gdbarch_float_format (struct gdbarch *gdbarch, const struct floatformat ** float_format);\n+\n+extern int gdbarch_double_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_double_bit (struct gdbarch *gdbarch, int double_bit);\n+\n+extern const struct floatformat ** gdbarch_double_format (struct gdbarch *gdbarch);\n+extern void set_gdbarch_double_format (struct gdbarch *gdbarch, const struct floatformat ** double_format);\n+\n+extern int gdbarch_long_double_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_long_double_bit (struct gdbarch *gdbarch, int long_double_bit);\n+\n+extern const struct floatformat ** gdbarch_long_double_format (struct gdbarch *gdbarch);\n+extern void set_gdbarch_long_double_format (struct gdbarch *gdbarch, const struct floatformat ** long_double_format);\n+\n+/* The ABI default bit-size for \"wchar_t\".  wchar_t is a built-in type\n+   starting with C++11. */\n+\n+extern int gdbarch_wchar_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_wchar_bit (struct gdbarch *gdbarch, int wchar_bit);\n+\n+/* One if `wchar_t' is signed, zero if unsigned. */\n+\n+extern int gdbarch_wchar_signed (struct gdbarch *gdbarch);\n+extern void set_gdbarch_wchar_signed (struct gdbarch *gdbarch, int wchar_signed);\n+\n+/* Returns the floating-point format to be used for values of length LENGTH.\n+   NAME, if non-NULL, is the type name, which may be used to distinguish\n+   different target formats of the same length. */\n+\n+typedef const struct floatformat ** (gdbarch_floatformat_for_type_ftype) (struct gdbarch *gdbarch, const char *name, int length);\n+extern const struct floatformat ** gdbarch_floatformat_for_type (struct gdbarch *gdbarch, const char *name, int length);\n+extern void set_gdbarch_floatformat_for_type (struct gdbarch *gdbarch, gdbarch_floatformat_for_type_ftype *floatformat_for_type);\n+\n+/* For most targets, a pointer on the target and its representation as an\n+   address in GDB have the same size and \"look the same\".  For such a\n+   target, you need only set gdbarch_ptr_bit and gdbarch_addr_bit\n+   / addr_bit will be set from it.\n+  \n+   If gdbarch_ptr_bit and gdbarch_addr_bit are different, you'll probably\n+   also need to set gdbarch_dwarf2_addr_size, gdbarch_pointer_to_address and\n+   gdbarch_address_to_pointer as well.\n+  \n+   ptr_bit is the size of a pointer on the target */\n+\n+extern int gdbarch_ptr_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_ptr_bit (struct gdbarch *gdbarch, int ptr_bit);\n+\n+/* addr_bit is the size of a target address as represented in gdb */\n+\n+extern int gdbarch_addr_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_addr_bit (struct gdbarch *gdbarch, int addr_bit);\n+\n+/* dwarf2_addr_size is the target address size as used in the Dwarf debug\n+   info.  For .debug_frame FDEs, this is supposed to be the target address\n+   size from the associated CU header, and which is equivalent to the\n+   DWARF2_ADDR_SIZE as defined by the target specific GCC back-end.\n+   Unfortunately there is no good way to determine this value.  Therefore\n+   dwarf2_addr_size simply defaults to the target pointer size.\n+  \n+   dwarf2_addr_size is not used for .eh_frame FDEs, which are generally\n+   defined using the target's pointer size so far.\n+  \n+   Note that dwarf2_addr_size only needs to be redefined by a target if the\n+   GCC back-end defines a DWARF2_ADDR_SIZE other than the target pointer size,\n+   and if Dwarf versions < 4 need to be supported. */\n+\n+extern int gdbarch_dwarf2_addr_size (struct gdbarch *gdbarch);\n+extern void set_gdbarch_dwarf2_addr_size (struct gdbarch *gdbarch, int dwarf2_addr_size);\n+\n+/* One if `char' acts like `signed char', zero if `unsigned char'. */\n+\n+extern int gdbarch_char_signed (struct gdbarch *gdbarch);\n+extern void set_gdbarch_char_signed (struct gdbarch *gdbarch, int char_signed);\n+\n+extern bool gdbarch_read_pc_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_read_pc_ftype) (readable_regcache *regcache);\n+extern CORE_ADDR gdbarch_read_pc (struct gdbarch *gdbarch, readable_regcache *regcache);\n+extern void set_gdbarch_read_pc (struct gdbarch *gdbarch, gdbarch_read_pc_ftype *read_pc);\n+\n+extern bool gdbarch_write_pc_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_write_pc_ftype) (struct regcache *regcache, CORE_ADDR val);\n+extern void gdbarch_write_pc (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR val);\n+extern void set_gdbarch_write_pc (struct gdbarch *gdbarch, gdbarch_write_pc_ftype *write_pc);\n+\n+/* Function for getting target's idea of a frame pointer.  FIXME: GDB's\n+   whole scheme for dealing with \"frames\" and \"frame pointers\" needs a\n+   serious shakedown. */\n+\n+typedef void (gdbarch_virtual_frame_pointer_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc, int *frame_regnum, LONGEST *frame_offset);\n+extern void gdbarch_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc, int *frame_regnum, LONGEST *frame_offset);\n+extern void set_gdbarch_virtual_frame_pointer (struct gdbarch *gdbarch, gdbarch_virtual_frame_pointer_ftype *virtual_frame_pointer);\n+\n+extern bool gdbarch_pseudo_register_read_p (struct gdbarch *gdbarch);\n+\n+typedef enum register_status (gdbarch_pseudo_register_read_ftype) (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum, gdb_byte *buf);\n+extern enum register_status gdbarch_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum, gdb_byte *buf);\n+extern void set_gdbarch_pseudo_register_read (struct gdbarch *gdbarch, gdbarch_pseudo_register_read_ftype *pseudo_register_read);\n+\n+/* Read a register into a new struct value.  If the register is wholly\n+   or partly unavailable, this should call mark_value_bytes_unavailable\n+   as appropriate.  If this is defined, then pseudo_register_read will\n+   never be called. */\n+\n+extern bool gdbarch_pseudo_register_read_value_p (struct gdbarch *gdbarch);\n+\n+typedef struct value * (gdbarch_pseudo_register_read_value_ftype) (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum);\n+extern struct value * gdbarch_pseudo_register_read_value (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum);\n+extern void set_gdbarch_pseudo_register_read_value (struct gdbarch *gdbarch, gdbarch_pseudo_register_read_value_ftype *pseudo_register_read_value);\n+\n+extern bool gdbarch_pseudo_register_write_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_pseudo_register_write_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, int cookednum, const gdb_byte *buf);\n+extern void gdbarch_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache, int cookednum, const gdb_byte *buf);\n+extern void set_gdbarch_pseudo_register_write (struct gdbarch *gdbarch, gdbarch_pseudo_register_write_ftype *pseudo_register_write);\n+\n+extern int gdbarch_num_regs (struct gdbarch *gdbarch);\n+extern void set_gdbarch_num_regs (struct gdbarch *gdbarch, int num_regs);\n+\n+/* This macro gives the number of pseudo-registers that live in the\n+   register namespace but do not get fetched or stored on the target.\n+   These pseudo-registers may be aliases for other registers,\n+   combinations of other registers, or they may be computed by GDB. */\n+\n+extern int gdbarch_num_pseudo_regs (struct gdbarch *gdbarch);\n+extern void set_gdbarch_num_pseudo_regs (struct gdbarch *gdbarch, int num_pseudo_regs);\n+\n+/* Assemble agent expression bytecode to collect pseudo-register REG.\n+   Return -1 if something goes wrong, 0 otherwise. */\n+\n+extern bool gdbarch_ax_pseudo_register_collect_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_ax_pseudo_register_collect_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n+extern int gdbarch_ax_pseudo_register_collect (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n+extern void set_gdbarch_ax_pseudo_register_collect (struct gdbarch *gdbarch, gdbarch_ax_pseudo_register_collect_ftype *ax_pseudo_register_collect);\n+\n+/* Assemble agent expression bytecode to push the value of pseudo-register\n+   REG on the interpreter stack.\n+   Return -1 if something goes wrong, 0 otherwise. */\n+\n+extern bool gdbarch_ax_pseudo_register_push_stack_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_ax_pseudo_register_push_stack_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n+extern int gdbarch_ax_pseudo_register_push_stack (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n+extern void set_gdbarch_ax_pseudo_register_push_stack (struct gdbarch *gdbarch, gdbarch_ax_pseudo_register_push_stack_ftype *ax_pseudo_register_push_stack);\n+\n+/* Some architectures can display additional information for specific\n+   signals.\n+   UIOUT is the output stream where the handler will place information. */\n+\n+extern bool gdbarch_report_signal_info_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_report_signal_info_ftype) (struct gdbarch *gdbarch, struct ui_out *uiout, enum gdb_signal siggnal);\n+extern void gdbarch_report_signal_info (struct gdbarch *gdbarch, struct ui_out *uiout, enum gdb_signal siggnal);\n+extern void set_gdbarch_report_signal_info (struct gdbarch *gdbarch, gdbarch_report_signal_info_ftype *report_signal_info);\n+\n+/* GDB's standard (or well known) register numbers.  These can map onto\n+   a real register or a pseudo (computed) register or not be defined at\n+   all (-1).\n+   gdbarch_sp_regnum will hopefully be replaced by UNWIND_SP. */\n+\n+extern int gdbarch_sp_regnum (struct gdbarch *gdbarch);\n+extern void set_gdbarch_sp_regnum (struct gdbarch *gdbarch, int sp_regnum);\n+\n+extern int gdbarch_pc_regnum (struct gdbarch *gdbarch);\n+extern void set_gdbarch_pc_regnum (struct gdbarch *gdbarch, int pc_regnum);\n+\n+extern int gdbarch_ps_regnum (struct gdbarch *gdbarch);\n+extern void set_gdbarch_ps_regnum (struct gdbarch *gdbarch, int ps_regnum);\n+\n+extern int gdbarch_fp0_regnum (struct gdbarch *gdbarch);\n+extern void set_gdbarch_fp0_regnum (struct gdbarch *gdbarch, int fp0_regnum);\n+\n+/* Convert stab register number (from `r' declaration) to a gdb REGNUM. */\n+\n+typedef int (gdbarch_stab_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int stab_regnr);\n+extern int gdbarch_stab_reg_to_regnum (struct gdbarch *gdbarch, int stab_regnr);\n+extern void set_gdbarch_stab_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_stab_reg_to_regnum_ftype *stab_reg_to_regnum);\n+\n+/* Provide a default mapping from a ecoff register number to a gdb REGNUM. */\n+\n+typedef int (gdbarch_ecoff_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int ecoff_regnr);\n+extern int gdbarch_ecoff_reg_to_regnum (struct gdbarch *gdbarch, int ecoff_regnr);\n+extern void set_gdbarch_ecoff_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_ecoff_reg_to_regnum_ftype *ecoff_reg_to_regnum);\n+\n+/* Convert from an sdb register number to an internal gdb register number. */\n+\n+typedef int (gdbarch_sdb_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int sdb_regnr);\n+extern int gdbarch_sdb_reg_to_regnum (struct gdbarch *gdbarch, int sdb_regnr);\n+extern void set_gdbarch_sdb_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_sdb_reg_to_regnum_ftype *sdb_reg_to_regnum);\n+\n+/* Provide a default mapping from a DWARF2 register number to a gdb REGNUM.\n+   Return -1 for bad REGNUM.  Note: Several targets get this wrong. */\n+\n+typedef int (gdbarch_dwarf2_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int dwarf2_regnr);\n+extern int gdbarch_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int dwarf2_regnr);\n+extern void set_gdbarch_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_dwarf2_reg_to_regnum_ftype *dwarf2_reg_to_regnum);\n+\n+typedef const char * (gdbarch_register_name_ftype) (struct gdbarch *gdbarch, int regnr);\n+extern const char * gdbarch_register_name (struct gdbarch *gdbarch, int regnr);\n+extern void set_gdbarch_register_name (struct gdbarch *gdbarch, gdbarch_register_name_ftype *register_name);\n+\n+/* Return the type of a register specified by the architecture.  Only\n+   the register cache should call this function directly; others should\n+   use \"register_type\". */\n+\n+extern bool gdbarch_register_type_p (struct gdbarch *gdbarch);\n+\n+typedef struct type * (gdbarch_register_type_ftype) (struct gdbarch *gdbarch, int reg_nr);\n+extern struct type * gdbarch_register_type (struct gdbarch *gdbarch, int reg_nr);\n+extern void set_gdbarch_register_type (struct gdbarch *gdbarch, gdbarch_register_type_ftype *register_type);\n+\n+/* Generate a dummy frame_id for THIS_FRAME assuming that the frame is\n+   a dummy frame.  A dummy frame is created before an inferior call,\n+   the frame_id returned here must match the frame_id that was built\n+   for the inferior call.  Usually this means the returned frame_id's\n+   stack address should match the address returned by\n+   gdbarch_push_dummy_call, and the returned frame_id's code address\n+   should match the address at which the breakpoint was set in the dummy\n+   frame. */\n+\n+typedef struct frame_id (gdbarch_dummy_id_ftype) (struct gdbarch *gdbarch, struct frame_info *this_frame);\n+extern struct frame_id gdbarch_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame);\n+extern void set_gdbarch_dummy_id (struct gdbarch *gdbarch, gdbarch_dummy_id_ftype *dummy_id);\n+\n+/* Implement DUMMY_ID and PUSH_DUMMY_CALL, then delete\n+   deprecated_fp_regnum. */\n+\n+extern int gdbarch_deprecated_fp_regnum (struct gdbarch *gdbarch);\n+extern void set_gdbarch_deprecated_fp_regnum (struct gdbarch *gdbarch, int deprecated_fp_regnum);\n+\n+extern bool gdbarch_push_dummy_call_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_push_dummy_call_ftype) (struct gdbarch *gdbarch, struct value *function, struct regcache *regcache, CORE_ADDR bp_addr, int nargs, struct value **args, CORE_ADDR sp, function_call_return_method return_method, CORE_ADDR struct_addr);\n+extern CORE_ADDR gdbarch_push_dummy_call (struct gdbarch *gdbarch, struct value *function, struct regcache *regcache, CORE_ADDR bp_addr, int nargs, struct value **args, CORE_ADDR sp, function_call_return_method return_method, CORE_ADDR struct_addr);\n+extern void set_gdbarch_push_dummy_call (struct gdbarch *gdbarch, gdbarch_push_dummy_call_ftype *push_dummy_call);\n+\n+extern int gdbarch_call_dummy_location (struct gdbarch *gdbarch);\n+extern void set_gdbarch_call_dummy_location (struct gdbarch *gdbarch, int call_dummy_location);\n+\n+extern bool gdbarch_push_dummy_code_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_push_dummy_code_ftype) (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr, struct value **args, int nargs, struct type *value_type, CORE_ADDR *real_pc, CORE_ADDR *bp_addr, struct regcache *regcache);\n+extern CORE_ADDR gdbarch_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr, struct value **args, int nargs, struct type *value_type, CORE_ADDR *real_pc, CORE_ADDR *bp_addr, struct regcache *regcache);\n+extern void set_gdbarch_push_dummy_code (struct gdbarch *gdbarch, gdbarch_push_dummy_code_ftype *push_dummy_code);\n+\n+/* Return true if the code of FRAME is writable. */\n+\n+typedef int (gdbarch_code_of_frame_writable_ftype) (struct gdbarch *gdbarch, struct frame_info *frame);\n+extern int gdbarch_code_of_frame_writable (struct gdbarch *gdbarch, struct frame_info *frame);\n+extern void set_gdbarch_code_of_frame_writable (struct gdbarch *gdbarch, gdbarch_code_of_frame_writable_ftype *code_of_frame_writable);\n+\n+typedef void (gdbarch_print_registers_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, int regnum, int all);\n+extern void gdbarch_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, int regnum, int all);\n+extern void set_gdbarch_print_registers_info (struct gdbarch *gdbarch, gdbarch_print_registers_info_ftype *print_registers_info);\n+\n+typedef void (gdbarch_print_float_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n+extern void gdbarch_print_float_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n+extern void set_gdbarch_print_float_info (struct gdbarch *gdbarch, gdbarch_print_float_info_ftype *print_float_info);\n+\n+extern bool gdbarch_print_vector_info_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_print_vector_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n+extern void gdbarch_print_vector_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n+extern void set_gdbarch_print_vector_info (struct gdbarch *gdbarch, gdbarch_print_vector_info_ftype *print_vector_info);\n+\n+/* MAP a GDB RAW register number onto a simulator register number.  See\n+   also include/...-sim.h. */\n+\n+typedef int (gdbarch_register_sim_regno_ftype) (struct gdbarch *gdbarch, int reg_nr);\n+extern int gdbarch_register_sim_regno (struct gdbarch *gdbarch, int reg_nr);\n+extern void set_gdbarch_register_sim_regno (struct gdbarch *gdbarch, gdbarch_register_sim_regno_ftype *register_sim_regno);\n+\n+typedef int (gdbarch_cannot_fetch_register_ftype) (struct gdbarch *gdbarch, int regnum);\n+extern int gdbarch_cannot_fetch_register (struct gdbarch *gdbarch, int regnum);\n+extern void set_gdbarch_cannot_fetch_register (struct gdbarch *gdbarch, gdbarch_cannot_fetch_register_ftype *cannot_fetch_register);\n+\n+typedef int (gdbarch_cannot_store_register_ftype) (struct gdbarch *gdbarch, int regnum);\n+extern int gdbarch_cannot_store_register (struct gdbarch *gdbarch, int regnum);\n+extern void set_gdbarch_cannot_store_register (struct gdbarch *gdbarch, gdbarch_cannot_store_register_ftype *cannot_store_register);\n+\n+/* Determine the address where a longjmp will land and save this address\n+   in PC.  Return nonzero on success.\n+  \n+   FRAME corresponds to the longjmp frame. */\n+\n+extern bool gdbarch_get_longjmp_target_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_get_longjmp_target_ftype) (struct frame_info *frame, CORE_ADDR *pc);\n+extern int gdbarch_get_longjmp_target (struct gdbarch *gdbarch, struct frame_info *frame, CORE_ADDR *pc);\n+extern void set_gdbarch_get_longjmp_target (struct gdbarch *gdbarch, gdbarch_get_longjmp_target_ftype *get_longjmp_target);\n+\n+extern int gdbarch_believe_pcc_promotion (struct gdbarch *gdbarch);\n+extern void set_gdbarch_believe_pcc_promotion (struct gdbarch *gdbarch, int believe_pcc_promotion);\n+\n+typedef int (gdbarch_convert_register_p_ftype) (struct gdbarch *gdbarch, int regnum, struct type *type);\n+extern int gdbarch_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type);\n+extern void set_gdbarch_convert_register_p (struct gdbarch *gdbarch, gdbarch_convert_register_p_ftype *convert_register_p);\n+\n+typedef int (gdbarch_register_to_value_ftype) (struct frame_info *frame, int regnum, struct type *type, gdb_byte *buf, int *optimizedp, int *unavailablep);\n+extern int gdbarch_register_to_value (struct gdbarch *gdbarch, struct frame_info *frame, int regnum, struct type *type, gdb_byte *buf, int *optimizedp, int *unavailablep);\n+extern void set_gdbarch_register_to_value (struct gdbarch *gdbarch, gdbarch_register_to_value_ftype *register_to_value);\n+\n+typedef void (gdbarch_value_to_register_ftype) (struct frame_info *frame, int regnum, struct type *type, const gdb_byte *buf);\n+extern void gdbarch_value_to_register (struct gdbarch *gdbarch, struct frame_info *frame, int regnum, struct type *type, const gdb_byte *buf);\n+extern void set_gdbarch_value_to_register (struct gdbarch *gdbarch, gdbarch_value_to_register_ftype *value_to_register);\n+\n+/* Construct a value representing the contents of register REGNUM in\n+   frame FRAME_ID, interpreted as type TYPE.  The routine needs to\n+   allocate and return a struct value with all value attributes\n+   (but not the value contents) filled in. */\n+\n+typedef struct value * (gdbarch_value_from_register_ftype) (struct gdbarch *gdbarch, struct type *type, int regnum, struct frame_id frame_id);\n+extern struct value * gdbarch_value_from_register (struct gdbarch *gdbarch, struct type *type, int regnum, struct frame_id frame_id);\n+extern void set_gdbarch_value_from_register (struct gdbarch *gdbarch, gdbarch_value_from_register_ftype *value_from_register);\n+\n+typedef CORE_ADDR (gdbarch_pointer_to_address_ftype) (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n+extern CORE_ADDR gdbarch_pointer_to_address (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n+extern void set_gdbarch_pointer_to_address (struct gdbarch *gdbarch, gdbarch_pointer_to_address_ftype *pointer_to_address);\n+\n+typedef void (gdbarch_address_to_pointer_ftype) (struct gdbarch *gdbarch, struct type *type, gdb_byte *buf, CORE_ADDR addr);\n+extern void gdbarch_address_to_pointer (struct gdbarch *gdbarch, struct type *type, gdb_byte *buf, CORE_ADDR addr);\n+extern void set_gdbarch_address_to_pointer (struct gdbarch *gdbarch, gdbarch_address_to_pointer_ftype *address_to_pointer);\n+\n+extern bool gdbarch_integer_to_address_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_integer_to_address_ftype) (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n+extern CORE_ADDR gdbarch_integer_to_address (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n+extern void set_gdbarch_integer_to_address (struct gdbarch *gdbarch, gdbarch_integer_to_address_ftype *integer_to_address);\n+\n+/* Return the return-value convention that will be used by FUNCTION\n+   to return a value of type VALTYPE.  FUNCTION may be NULL in which\n+   case the return convention is computed based only on VALTYPE.\n+  \n+   If READBUF is not NULL, extract the return value and save it in this buffer.\n+  \n+   If WRITEBUF is not NULL, it contains a return value which will be\n+   stored into the appropriate register.  This can be used when we want\n+   to force the value returned by a function (see the \"return\" command\n+   for instance). */\n+\n+extern bool gdbarch_return_value_p (struct gdbarch *gdbarch);\n+\n+typedef enum return_value_convention (gdbarch_return_value_ftype) (struct gdbarch *gdbarch, struct value *function, struct type *valtype, struct regcache *regcache, gdb_byte *readbuf, const gdb_byte *writebuf);\n+extern enum return_value_convention gdbarch_return_value (struct gdbarch *gdbarch, struct value *function, struct type *valtype, struct regcache *regcache, gdb_byte *readbuf, const gdb_byte *writebuf);\n+extern void set_gdbarch_return_value (struct gdbarch *gdbarch, gdbarch_return_value_ftype *return_value);\n+\n+/* Return true if the return value of function is stored in the first hidden\n+   parameter.  In theory, this feature should be language-dependent, specified\n+   by language and its ABI, such as C++.  Unfortunately, compiler may\n+   implement it to a target-dependent feature.  So that we need such hook here\n+   to be aware of this in GDB. */\n+\n+typedef int (gdbarch_return_in_first_hidden_param_p_ftype) (struct gdbarch *gdbarch, struct type *type);\n+extern int gdbarch_return_in_first_hidden_param_p (struct gdbarch *gdbarch, struct type *type);\n+extern void set_gdbarch_return_in_first_hidden_param_p (struct gdbarch *gdbarch, gdbarch_return_in_first_hidden_param_p_ftype *return_in_first_hidden_param_p);\n+\n+typedef CORE_ADDR (gdbarch_skip_prologue_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern CORE_ADDR gdbarch_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern void set_gdbarch_skip_prologue (struct gdbarch *gdbarch, gdbarch_skip_prologue_ftype *skip_prologue);\n+\n+extern bool gdbarch_skip_main_prologue_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_skip_main_prologue_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern CORE_ADDR gdbarch_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern void set_gdbarch_skip_main_prologue (struct gdbarch *gdbarch, gdbarch_skip_main_prologue_ftype *skip_main_prologue);\n+\n+/* On some platforms, a single function may provide multiple entry points,\n+   e.g. one that is used for function-pointer calls and a different one\n+   that is used for direct function calls.\n+   In order to ensure that breakpoints set on the function will trigger\n+   no matter via which entry point the function is entered, a platform\n+   may provide the skip_entrypoint callback.  It is called with IP set\n+   to the main entry point of a function (as determined by the symbol table),\n+   and should return the address of the innermost entry point, where the\n+   actual breakpoint needs to be set.  Note that skip_entrypoint is used\n+   by GDB common code even when debugging optimized code, where skip_prologue\n+   is not used. */\n+\n+extern bool gdbarch_skip_entrypoint_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_skip_entrypoint_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern CORE_ADDR gdbarch_skip_entrypoint (struct gdbarch *gdbarch, CORE_ADDR ip);\n+extern void set_gdbarch_skip_entrypoint (struct gdbarch *gdbarch, gdbarch_skip_entrypoint_ftype *skip_entrypoint);\n+\n+typedef int (gdbarch_inner_than_ftype) (CORE_ADDR lhs, CORE_ADDR rhs);\n+extern int gdbarch_inner_than (struct gdbarch *gdbarch, CORE_ADDR lhs, CORE_ADDR rhs);\n+extern void set_gdbarch_inner_than (struct gdbarch *gdbarch, gdbarch_inner_than_ftype *inner_than);\n+\n+typedef const gdb_byte * (gdbarch_breakpoint_from_pc_ftype) (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr);\n+extern const gdb_byte * gdbarch_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr);\n+extern void set_gdbarch_breakpoint_from_pc (struct gdbarch *gdbarch, gdbarch_breakpoint_from_pc_ftype *breakpoint_from_pc);\n+\n+/* Return the breakpoint kind for this target based on *PCPTR. */\n+\n+typedef int (gdbarch_breakpoint_kind_from_pc_ftype) (struct gdbarch *gdbarch, CORE_ADDR *pcptr);\n+extern int gdbarch_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr);\n+extern void set_gdbarch_breakpoint_kind_from_pc (struct gdbarch *gdbarch, gdbarch_breakpoint_kind_from_pc_ftype *breakpoint_kind_from_pc);\n+\n+/* Return the software breakpoint from KIND.  KIND can have target\n+   specific meaning like the Z0 kind parameter.\n+   SIZE is set to the software breakpoint's length in memory. */\n+\n+typedef const gdb_byte * (gdbarch_sw_breakpoint_from_kind_ftype) (struct gdbarch *gdbarch, int kind, int *size);\n+extern const gdb_byte * gdbarch_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size);\n+extern void set_gdbarch_sw_breakpoint_from_kind (struct gdbarch *gdbarch, gdbarch_sw_breakpoint_from_kind_ftype *sw_breakpoint_from_kind);\n+\n+/* Return the breakpoint kind for this target based on the current\n+   processor state (e.g. the current instruction mode on ARM) and the\n+   *PCPTR.  In default, it is gdbarch->breakpoint_kind_from_pc. */\n+\n+typedef int (gdbarch_breakpoint_kind_from_current_state_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR *pcptr);\n+extern int gdbarch_breakpoint_kind_from_current_state (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR *pcptr);\n+extern void set_gdbarch_breakpoint_kind_from_current_state (struct gdbarch *gdbarch, gdbarch_breakpoint_kind_from_current_state_ftype *breakpoint_kind_from_current_state);\n+\n+extern bool gdbarch_adjust_breakpoint_address_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_adjust_breakpoint_address_ftype) (struct gdbarch *gdbarch, CORE_ADDR bpaddr);\n+extern CORE_ADDR gdbarch_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr);\n+extern void set_gdbarch_adjust_breakpoint_address (struct gdbarch *gdbarch, gdbarch_adjust_breakpoint_address_ftype *adjust_breakpoint_address);\n+\n+typedef int (gdbarch_memory_insert_breakpoint_ftype) (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n+extern int gdbarch_memory_insert_breakpoint (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n+extern void set_gdbarch_memory_insert_breakpoint (struct gdbarch *gdbarch, gdbarch_memory_insert_breakpoint_ftype *memory_insert_breakpoint);\n+\n+typedef int (gdbarch_memory_remove_breakpoint_ftype) (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n+extern int gdbarch_memory_remove_breakpoint (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n+extern void set_gdbarch_memory_remove_breakpoint (struct gdbarch *gdbarch, gdbarch_memory_remove_breakpoint_ftype *memory_remove_breakpoint);\n+\n+extern CORE_ADDR gdbarch_decr_pc_after_break (struct gdbarch *gdbarch);\n+extern void set_gdbarch_decr_pc_after_break (struct gdbarch *gdbarch, CORE_ADDR decr_pc_after_break);\n+\n+/* A function can be addressed by either it's \"pointer\" (possibly a\n+   descriptor address) or \"entry point\" (first executable instruction).\n+   The method \"convert_from_func_ptr_addr\" converting the former to the\n+   latter.  gdbarch_deprecated_function_start_offset is being used to implement\n+   a simplified subset of that functionality - the function's address\n+   corresponds to the \"function pointer\" and the function's start\n+   corresponds to the \"function entry point\" - and hence is redundant. */\n+\n+extern CORE_ADDR gdbarch_deprecated_function_start_offset (struct gdbarch *gdbarch);\n+extern void set_gdbarch_deprecated_function_start_offset (struct gdbarch *gdbarch, CORE_ADDR deprecated_function_start_offset);\n+\n+/* Return the remote protocol register number associated with this\n+   register.  Normally the identity mapping. */\n+\n+typedef int (gdbarch_remote_register_number_ftype) (struct gdbarch *gdbarch, int regno);\n+extern int gdbarch_remote_register_number (struct gdbarch *gdbarch, int regno);\n+extern void set_gdbarch_remote_register_number (struct gdbarch *gdbarch, gdbarch_remote_register_number_ftype *remote_register_number);\n+\n+/* Fetch the target specific address used to represent a load module. */\n+\n+extern bool gdbarch_fetch_tls_load_module_address_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_fetch_tls_load_module_address_ftype) (struct objfile *objfile);\n+extern CORE_ADDR gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, struct objfile *objfile);\n+extern void set_gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, gdbarch_fetch_tls_load_module_address_ftype *fetch_tls_load_module_address);\n+\n+/* Return the thread-local address at OFFSET in the thread-local\n+   storage for the thread PTID and the shared library or executable\n+   file given by LM_ADDR.  If that block of thread-local storage hasn't\n+   been allocated yet, this function may throw an error.  LM_ADDR may\n+   be zero for statically linked multithreaded inferiors. */\n+\n+extern bool gdbarch_get_thread_local_address_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_get_thread_local_address_ftype) (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);\n+extern CORE_ADDR gdbarch_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);\n+extern void set_gdbarch_get_thread_local_address (struct gdbarch *gdbarch, gdbarch_get_thread_local_address_ftype *get_thread_local_address);\n+\n+extern CORE_ADDR gdbarch_frame_args_skip (struct gdbarch *gdbarch);\n+extern void set_gdbarch_frame_args_skip (struct gdbarch *gdbarch, CORE_ADDR frame_args_skip);\n+\n+typedef CORE_ADDR (gdbarch_unwind_pc_ftype) (struct gdbarch *gdbarch, struct frame_info *next_frame);\n+extern CORE_ADDR gdbarch_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame);\n+extern void set_gdbarch_unwind_pc (struct gdbarch *gdbarch, gdbarch_unwind_pc_ftype *unwind_pc);\n+\n+typedef CORE_ADDR (gdbarch_unwind_sp_ftype) (struct gdbarch *gdbarch, struct frame_info *next_frame);\n+extern CORE_ADDR gdbarch_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame);\n+extern void set_gdbarch_unwind_sp (struct gdbarch *gdbarch, gdbarch_unwind_sp_ftype *unwind_sp);\n+\n+/* DEPRECATED_FRAME_LOCALS_ADDRESS as been replaced by the per-frame\n+   frame-base.  Enable frame-base before frame-unwind. */\n+\n+extern bool gdbarch_frame_num_args_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_frame_num_args_ftype) (struct frame_info *frame);\n+extern int gdbarch_frame_num_args (struct gdbarch *gdbarch, struct frame_info *frame);\n+extern void set_gdbarch_frame_num_args (struct gdbarch *gdbarch, gdbarch_frame_num_args_ftype *frame_num_args);\n+\n+extern bool gdbarch_frame_align_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_frame_align_ftype) (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern CORE_ADDR gdbarch_frame_align (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern void set_gdbarch_frame_align (struct gdbarch *gdbarch, gdbarch_frame_align_ftype *frame_align);\n+\n+typedef int (gdbarch_stabs_argument_has_addr_ftype) (struct gdbarch *gdbarch, struct type *type);\n+extern int gdbarch_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type);\n+extern void set_gdbarch_stabs_argument_has_addr (struct gdbarch *gdbarch, gdbarch_stabs_argument_has_addr_ftype *stabs_argument_has_addr);\n+\n+extern int gdbarch_frame_red_zone_size (struct gdbarch *gdbarch);\n+extern void set_gdbarch_frame_red_zone_size (struct gdbarch *gdbarch, int frame_red_zone_size);\n+\n+typedef CORE_ADDR (gdbarch_convert_from_func_ptr_addr_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr, struct target_ops *targ);\n+extern CORE_ADDR gdbarch_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr, struct target_ops *targ);\n+extern void set_gdbarch_convert_from_func_ptr_addr (struct gdbarch *gdbarch, gdbarch_convert_from_func_ptr_addr_ftype *convert_from_func_ptr_addr);\n+\n+/* On some machines there are bits in addresses which are not really\n+   part of the address, but are used by the kernel, the hardware, etc.\n+   for special purposes.  gdbarch_addr_bits_remove takes out any such bits so\n+   we get a \"real\" address such as one would find in a symbol table.\n+   This is used only for addresses of instructions, and even then I'm\n+   not sure it's used in all contexts.  It exists to deal with there\n+   being a few stray bits in the PC which would mislead us, not as some\n+   sort of generic thing to handle alignment or segmentation (it's\n+   possible it should be in TARGET_READ_PC instead). */\n+\n+typedef CORE_ADDR (gdbarch_addr_bits_remove_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern CORE_ADDR gdbarch_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_addr_bits_remove (struct gdbarch *gdbarch, gdbarch_addr_bits_remove_ftype *addr_bits_remove);\n+\n+/* On some machines, not all bits of an address word are significant.\n+   For example, on AArch64, the top bits of an address known as the \"tag\"\n+   are ignored by the kernel, the hardware, etc. and can be regarded as\n+   additional data associated with the address. */\n+\n+extern int gdbarch_significant_addr_bit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_significant_addr_bit (struct gdbarch *gdbarch, int significant_addr_bit);\n+\n+/* Return a string representation of the memory tag TAG. */\n+\n+typedef std::string (gdbarch_memtag_to_string_ftype) (struct gdbarch *gdbarch, struct value *tag);\n+extern std::string gdbarch_memtag_to_string (struct gdbarch *gdbarch, struct value *tag);\n+extern void set_gdbarch_memtag_to_string (struct gdbarch *gdbarch, gdbarch_memtag_to_string_ftype *memtag_to_string);\n+\n+/* Return true if ADDRESS contains a tag and false otherwise.  ADDRESS\n+   must be either a pointer or a reference type. */\n+\n+typedef bool (gdbarch_tagged_address_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n+extern bool gdbarch_tagged_address_p (struct gdbarch *gdbarch, struct value *address);\n+extern void set_gdbarch_tagged_address_p (struct gdbarch *gdbarch, gdbarch_tagged_address_p_ftype *tagged_address_p);\n+\n+/* Return true if the tag from ADDRESS matches the memory tag for that\n+   particular address.  Return false otherwise. */\n+\n+typedef bool (gdbarch_memtag_matches_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n+extern bool gdbarch_memtag_matches_p (struct gdbarch *gdbarch, struct value *address);\n+extern void set_gdbarch_memtag_matches_p (struct gdbarch *gdbarch, gdbarch_memtag_matches_p_ftype *memtag_matches_p);\n+\n+/* Set the tags of type TAG_TYPE, for the memory address range\n+   [ADDRESS, ADDRESS + LENGTH) to TAGS.\n+   Return true if successful and false otherwise. */\n+\n+typedef bool (gdbarch_set_memtags_ftype) (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n+extern bool gdbarch_set_memtags (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n+extern void set_gdbarch_set_memtags (struct gdbarch *gdbarch, gdbarch_set_memtags_ftype *set_memtags);\n+\n+/* Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n+   assuming ADDRESS is tagged. */\n+\n+typedef struct value * (gdbarch_get_memtag_ftype) (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n+extern struct value * gdbarch_get_memtag (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n+extern void set_gdbarch_get_memtag (struct gdbarch *gdbarch, gdbarch_get_memtag_ftype *get_memtag);\n+\n+/* memtag_granule_size is the size of the allocation tag granule, for\n+   architectures that support memory tagging.\n+   This is 0 for architectures that do not support memory tagging.\n+   For a non-zero value, this represents the number of bytes of memory per tag. */\n+\n+extern CORE_ADDR gdbarch_memtag_granule_size (struct gdbarch *gdbarch);\n+extern void set_gdbarch_memtag_granule_size (struct gdbarch *gdbarch, CORE_ADDR memtag_granule_size);\n+\n+/* FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n+   indicates if the target needs software single step.  An ISA method to\n+   implement it.\n+  \n+   FIXME/cagney/2001-01-18: The logic is backwards.  It should be asking if the\n+   target can single step.  If not, then implement single step using breakpoints.\n+  \n+   Return a vector of addresses on which the software single step\n+   breakpoints should be inserted.  NULL means software single step is\n+   not used.\n+   Multiple breakpoints may be inserted for some instructions such as\n+   conditional branch.  However, each implementation must always evaluate\n+   the condition and only put the breakpoint at the branch destination if\n+   the condition is true, so that we ensure forward progress when stepping\n+   past a conditional branch to self. */\n+\n+extern bool gdbarch_software_single_step_p (struct gdbarch *gdbarch);\n+\n+typedef std::vector<CORE_ADDR> (gdbarch_software_single_step_ftype) (struct regcache *regcache);\n+extern std::vector<CORE_ADDR> gdbarch_software_single_step (struct gdbarch *gdbarch, struct regcache *regcache);\n+extern void set_gdbarch_software_single_step (struct gdbarch *gdbarch, gdbarch_software_single_step_ftype *software_single_step);\n+\n+/* Return non-zero if the processor is executing a delay slot and a\n+   further single-step is needed before the instruction finishes. */\n+\n+extern bool gdbarch_single_step_through_delay_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_single_step_through_delay_ftype) (struct gdbarch *gdbarch, struct frame_info *frame);\n+extern int gdbarch_single_step_through_delay (struct gdbarch *gdbarch, struct frame_info *frame);\n+extern void set_gdbarch_single_step_through_delay (struct gdbarch *gdbarch, gdbarch_single_step_through_delay_ftype *single_step_through_delay);\n+\n+/* FIXME: cagney/2003-08-28: Need to find a better way of selecting the\n+   disassembler.  Perhaps objdump can handle it? */\n+\n+typedef int (gdbarch_print_insn_ftype) (bfd_vma vma, struct disassemble_info *info);\n+extern int gdbarch_print_insn (struct gdbarch *gdbarch, bfd_vma vma, struct disassemble_info *info);\n+extern void set_gdbarch_print_insn (struct gdbarch *gdbarch, gdbarch_print_insn_ftype *print_insn);\n+\n+typedef CORE_ADDR (gdbarch_skip_trampoline_code_ftype) (struct frame_info *frame, CORE_ADDR pc);\n+extern CORE_ADDR gdbarch_skip_trampoline_code (struct gdbarch *gdbarch, struct frame_info *frame, CORE_ADDR pc);\n+extern void set_gdbarch_skip_trampoline_code (struct gdbarch *gdbarch, gdbarch_skip_trampoline_code_ftype *skip_trampoline_code);\n+\n+/* If in_solib_dynsym_resolve_code() returns true, and SKIP_SOLIB_RESOLVER\n+   evaluates non-zero, this is the address where the debugger will place\n+   a step-resume breakpoint to get us past the dynamic linker. */\n+\n+typedef CORE_ADDR (gdbarch_skip_solib_resolver_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc);\n+extern CORE_ADDR gdbarch_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc);\n+extern void set_gdbarch_skip_solib_resolver (struct gdbarch *gdbarch, gdbarch_skip_solib_resolver_ftype *skip_solib_resolver);\n+\n+/* Some systems also have trampoline code for returning from shared libs. */\n+\n+typedef int (gdbarch_in_solib_return_trampoline_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc, const char *name);\n+extern int gdbarch_in_solib_return_trampoline (struct gdbarch *gdbarch, CORE_ADDR pc, const char *name);\n+extern void set_gdbarch_in_solib_return_trampoline (struct gdbarch *gdbarch, gdbarch_in_solib_return_trampoline_ftype *in_solib_return_trampoline);\n+\n+/* Return true if PC lies inside an indirect branch thunk. */\n+\n+typedef bool (gdbarch_in_indirect_branch_thunk_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc);\n+extern bool gdbarch_in_indirect_branch_thunk (struct gdbarch *gdbarch, CORE_ADDR pc);\n+extern void set_gdbarch_in_indirect_branch_thunk (struct gdbarch *gdbarch, gdbarch_in_indirect_branch_thunk_ftype *in_indirect_branch_thunk);\n+\n+/* A target might have problems with watchpoints as soon as the stack\n+   frame of the current function has been destroyed.  This mostly happens\n+   as the first action in a function's epilogue.  stack_frame_destroyed_p()\n+   is defined to return a non-zero value if either the given addr is one\n+   instruction after the stack destroying instruction up to the trailing\n+   return instruction or if we can figure out that the stack frame has\n+   already been invalidated regardless of the value of addr.  Targets\n+   which don't suffer from that problem could just let this functionality\n+   untouched. */\n+\n+typedef int (gdbarch_stack_frame_destroyed_p_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern int gdbarch_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_stack_frame_destroyed_p (struct gdbarch *gdbarch, gdbarch_stack_frame_destroyed_p_ftype *stack_frame_destroyed_p);\n+\n+/* Process an ELF symbol in the minimal symbol table in a backend-specific\n+   way.  Normally this hook is supposed to do nothing, however if required,\n+   then this hook can be used to apply tranformations to symbols that are\n+   considered special in some way.  For example the MIPS backend uses it\n+   to interpret `st_other' information to mark compressed code symbols so\n+   that they can be treated in the appropriate manner in the processing of\n+   the main symbol table and DWARF-2 records. */\n+\n+extern bool gdbarch_elf_make_msymbol_special_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_elf_make_msymbol_special_ftype) (asymbol *sym, struct minimal_symbol *msym);\n+extern void gdbarch_elf_make_msymbol_special (struct gdbarch *gdbarch, asymbol *sym, struct minimal_symbol *msym);\n+extern void set_gdbarch_elf_make_msymbol_special (struct gdbarch *gdbarch, gdbarch_elf_make_msymbol_special_ftype *elf_make_msymbol_special);\n+\n+typedef void (gdbarch_coff_make_msymbol_special_ftype) (int val, struct minimal_symbol *msym);\n+extern void gdbarch_coff_make_msymbol_special (struct gdbarch *gdbarch, int val, struct minimal_symbol *msym);\n+extern void set_gdbarch_coff_make_msymbol_special (struct gdbarch *gdbarch, gdbarch_coff_make_msymbol_special_ftype *coff_make_msymbol_special);\n+\n+/* Process a symbol in the main symbol table in a backend-specific way.\n+   Normally this hook is supposed to do nothing, however if required,\n+   then this hook can be used to apply tranformations to symbols that\n+   are considered special in some way.  This is currently used by the\n+   MIPS backend to make sure compressed code symbols have the ISA bit\n+   set.  This in turn is needed for symbol values seen in GDB to match\n+   the values used at the runtime by the program itself, for function\n+   and label references. */\n+\n+typedef void (gdbarch_make_symbol_special_ftype) (struct symbol *sym, struct objfile *objfile);\n+extern void gdbarch_make_symbol_special (struct gdbarch *gdbarch, struct symbol *sym, struct objfile *objfile);\n+extern void set_gdbarch_make_symbol_special (struct gdbarch *gdbarch, gdbarch_make_symbol_special_ftype *make_symbol_special);\n+\n+/* Adjust the address retrieved from a DWARF-2 record other than a line\n+   entry in a backend-specific way.  Normally this hook is supposed to\n+   return the address passed unchanged, however if that is incorrect for\n+   any reason, then this hook can be used to fix the address up in the\n+   required manner.  This is currently used by the MIPS backend to make\n+   sure addresses in FDE, range records, etc. referring to compressed\n+   code have the ISA bit set, matching line information and the symbol\n+   table. */\n+\n+typedef CORE_ADDR (gdbarch_adjust_dwarf2_addr_ftype) (CORE_ADDR pc);\n+extern CORE_ADDR gdbarch_adjust_dwarf2_addr (struct gdbarch *gdbarch, CORE_ADDR pc);\n+extern void set_gdbarch_adjust_dwarf2_addr (struct gdbarch *gdbarch, gdbarch_adjust_dwarf2_addr_ftype *adjust_dwarf2_addr);\n+\n+/* Adjust the address updated by a line entry in a backend-specific way.\n+   Normally this hook is supposed to return the address passed unchanged,\n+   however in the case of inconsistencies in these records, this hook can\n+   be used to fix them up in the required manner.  This is currently used\n+   by the MIPS backend to make sure all line addresses in compressed code\n+   are presented with the ISA bit set, which is not always the case.  This\n+   in turn ensures breakpoint addresses are correctly matched against the\n+   stop PC. */\n+\n+typedef CORE_ADDR (gdbarch_adjust_dwarf2_line_ftype) (CORE_ADDR addr, int rel);\n+extern CORE_ADDR gdbarch_adjust_dwarf2_line (struct gdbarch *gdbarch, CORE_ADDR addr, int rel);\n+extern void set_gdbarch_adjust_dwarf2_line (struct gdbarch *gdbarch, gdbarch_adjust_dwarf2_line_ftype *adjust_dwarf2_line);\n+\n+extern int gdbarch_cannot_step_breakpoint (struct gdbarch *gdbarch);\n+extern void set_gdbarch_cannot_step_breakpoint (struct gdbarch *gdbarch, int cannot_step_breakpoint);\n+\n+/* See comment in target.h about continuable, steppable and\n+   non-steppable watchpoints. */\n+\n+extern int gdbarch_have_nonsteppable_watchpoint (struct gdbarch *gdbarch);\n+extern void set_gdbarch_have_nonsteppable_watchpoint (struct gdbarch *gdbarch, int have_nonsteppable_watchpoint);\n+\n+extern bool gdbarch_address_class_type_flags_p (struct gdbarch *gdbarch);\n+\n+typedef type_instance_flags (gdbarch_address_class_type_flags_ftype) (int byte_size, int dwarf2_addr_class);\n+extern type_instance_flags gdbarch_address_class_type_flags (struct gdbarch *gdbarch, int byte_size, int dwarf2_addr_class);\n+extern void set_gdbarch_address_class_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_ftype *address_class_type_flags);\n+\n+extern bool gdbarch_address_class_type_flags_to_name_p (struct gdbarch *gdbarch);\n+\n+typedef const char * (gdbarch_address_class_type_flags_to_name_ftype) (struct gdbarch *gdbarch, type_instance_flags type_flags);\n+extern const char * gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, type_instance_flags type_flags);\n+extern void set_gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_to_name_ftype *address_class_type_flags_to_name);\n+\n+/* Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n+   FS are passed from the generic execute_cfa_program function. */\n+\n+typedef bool (gdbarch_execute_dwarf_cfa_vendor_op_ftype) (struct gdbarch *gdbarch, gdb_byte op, struct dwarf2_frame_state *fs);\n+extern bool gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_byte op, struct dwarf2_frame_state *fs);\n+extern void set_gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdbarch_execute_dwarf_cfa_vendor_op_ftype *execute_dwarf_cfa_vendor_op);\n+\n+/* Return the appropriate type_flags for the supplied address class.\n+   This function should return true if the address class was recognized and\n+   type_flags was set, false otherwise. */\n+\n+extern bool gdbarch_address_class_name_to_type_flags_p (struct gdbarch *gdbarch);\n+\n+typedef bool (gdbarch_address_class_name_to_type_flags_ftype) (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n+extern bool gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n+extern void set_gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_name_to_type_flags_ftype *address_class_name_to_type_flags);\n+\n+/* Is a register in a group */\n+\n+typedef int (gdbarch_register_reggroup_p_ftype) (struct gdbarch *gdbarch, int regnum, struct reggroup *reggroup);\n+extern int gdbarch_register_reggroup_p (struct gdbarch *gdbarch, int regnum, struct reggroup *reggroup);\n+extern void set_gdbarch_register_reggroup_p (struct gdbarch *gdbarch, gdbarch_register_reggroup_p_ftype *register_reggroup_p);\n+\n+/* Fetch the pointer to the ith function argument. */\n+\n+extern bool gdbarch_fetch_pointer_argument_p (struct gdbarch *gdbarch);\n+\n+typedef CORE_ADDR (gdbarch_fetch_pointer_argument_ftype) (struct frame_info *frame, int argi, struct type *type);\n+extern CORE_ADDR gdbarch_fetch_pointer_argument (struct gdbarch *gdbarch, struct frame_info *frame, int argi, struct type *type);\n+extern void set_gdbarch_fetch_pointer_argument (struct gdbarch *gdbarch, gdbarch_fetch_pointer_argument_ftype *fetch_pointer_argument);\n+\n+/* Iterate over all supported register notes in a core file.  For each\n+   supported register note section, the iterator must call CB and pass\n+   CB_DATA unchanged.  If REGCACHE is not NULL, the iterator can limit\n+   the supported register note sections based on the current register\n+   values.  Otherwise it should enumerate all supported register note\n+   sections. */\n+\n+extern bool gdbarch_iterate_over_regset_sections_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_iterate_over_regset_sections_ftype) (struct gdbarch *gdbarch, iterate_over_regset_sections_cb *cb, void *cb_data, const struct regcache *regcache);\n+extern void gdbarch_iterate_over_regset_sections (struct gdbarch *gdbarch, iterate_over_regset_sections_cb *cb, void *cb_data, const struct regcache *regcache);\n+extern void set_gdbarch_iterate_over_regset_sections (struct gdbarch *gdbarch, gdbarch_iterate_over_regset_sections_ftype *iterate_over_regset_sections);\n+\n+/* Create core file notes */\n+\n+extern bool gdbarch_make_corefile_notes_p (struct gdbarch *gdbarch);\n+\n+typedef gdb::unique_xmalloc_ptr<char> (gdbarch_make_corefile_notes_ftype) (struct gdbarch *gdbarch, bfd *obfd, int *note_size);\n+extern gdb::unique_xmalloc_ptr<char> gdbarch_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size);\n+extern void set_gdbarch_make_corefile_notes (struct gdbarch *gdbarch, gdbarch_make_corefile_notes_ftype *make_corefile_notes);\n+\n+/* Find core file memory regions */\n+\n+extern bool gdbarch_find_memory_regions_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_find_memory_regions_ftype) (struct gdbarch *gdbarch, find_memory_region_ftype func, void *data);\n+extern int gdbarch_find_memory_regions (struct gdbarch *gdbarch, find_memory_region_ftype func, void *data);\n+extern void set_gdbarch_find_memory_regions (struct gdbarch *gdbarch, gdbarch_find_memory_regions_ftype *find_memory_regions);\n+\n+/* Read offset OFFSET of TARGET_OBJECT_LIBRARIES formatted shared libraries list from\n+   core file into buffer READBUF with length LEN.  Return the number of bytes read\n+   (zero indicates failure).\n+   failed, otherwise, return the red length of READBUF. */\n+\n+extern bool gdbarch_core_xfer_shared_libraries_p (struct gdbarch *gdbarch);\n+\n+typedef ULONGEST (gdbarch_core_xfer_shared_libraries_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern ULONGEST gdbarch_core_xfer_shared_libraries (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern void set_gdbarch_core_xfer_shared_libraries (struct gdbarch *gdbarch, gdbarch_core_xfer_shared_libraries_ftype *core_xfer_shared_libraries);\n+\n+/* Read offset OFFSET of TARGET_OBJECT_LIBRARIES_AIX formatted shared\n+   libraries list from core file into buffer READBUF with length LEN.\n+   Return the number of bytes read (zero indicates failure). */\n+\n+extern bool gdbarch_core_xfer_shared_libraries_aix_p (struct gdbarch *gdbarch);\n+\n+typedef ULONGEST (gdbarch_core_xfer_shared_libraries_aix_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern ULONGEST gdbarch_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern void set_gdbarch_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch, gdbarch_core_xfer_shared_libraries_aix_ftype *core_xfer_shared_libraries_aix);\n+\n+/* How the core target converts a PTID from a core file to a string. */\n+\n+extern bool gdbarch_core_pid_to_str_p (struct gdbarch *gdbarch);\n+\n+typedef std::string (gdbarch_core_pid_to_str_ftype) (struct gdbarch *gdbarch, ptid_t ptid);\n+extern std::string gdbarch_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n+extern void set_gdbarch_core_pid_to_str (struct gdbarch *gdbarch, gdbarch_core_pid_to_str_ftype *core_pid_to_str);\n+\n+/* How the core target extracts the name of a thread from a core file. */\n+\n+extern bool gdbarch_core_thread_name_p (struct gdbarch *gdbarch);\n+\n+typedef const char * (gdbarch_core_thread_name_ftype) (struct gdbarch *gdbarch, struct thread_info *thr);\n+extern const char * gdbarch_core_thread_name (struct gdbarch *gdbarch, struct thread_info *thr);\n+extern void set_gdbarch_core_thread_name (struct gdbarch *gdbarch, gdbarch_core_thread_name_ftype *core_thread_name);\n+\n+/* Read offset OFFSET of TARGET_OBJECT_SIGNAL_INFO signal information\n+   from core file into buffer READBUF with length LEN.  Return the number\n+   of bytes read (zero indicates EOF, a negative value indicates failure). */\n+\n+extern bool gdbarch_core_xfer_siginfo_p (struct gdbarch *gdbarch);\n+\n+typedef LONGEST (gdbarch_core_xfer_siginfo_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern LONGEST gdbarch_core_xfer_siginfo (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n+extern void set_gdbarch_core_xfer_siginfo (struct gdbarch *gdbarch, gdbarch_core_xfer_siginfo_ftype *core_xfer_siginfo);\n+\n+/* BFD target to use when generating a core file. */\n+\n+extern bool gdbarch_gcore_bfd_target_p (struct gdbarch *gdbarch);\n+\n+extern const char * gdbarch_gcore_bfd_target (struct gdbarch *gdbarch);\n+extern void set_gdbarch_gcore_bfd_target (struct gdbarch *gdbarch, const char * gcore_bfd_target);\n+\n+/* If the elements of C++ vtables are in-place function descriptors rather\n+   than normal function pointers (which may point to code or a descriptor),\n+   set this to one. */\n+\n+extern int gdbarch_vtable_function_descriptors (struct gdbarch *gdbarch);\n+extern void set_gdbarch_vtable_function_descriptors (struct gdbarch *gdbarch, int vtable_function_descriptors);\n+\n+/* Set if the least significant bit of the delta is used instead of the least\n+   significant bit of the pfn for pointers to virtual member functions. */\n+\n+extern int gdbarch_vbit_in_delta (struct gdbarch *gdbarch);\n+extern void set_gdbarch_vbit_in_delta (struct gdbarch *gdbarch, int vbit_in_delta);\n+\n+/* Advance PC to next instruction in order to skip a permanent breakpoint. */\n+\n+typedef void (gdbarch_skip_permanent_breakpoint_ftype) (struct regcache *regcache);\n+extern void gdbarch_skip_permanent_breakpoint (struct gdbarch *gdbarch, struct regcache *regcache);\n+extern void set_gdbarch_skip_permanent_breakpoint (struct gdbarch *gdbarch, gdbarch_skip_permanent_breakpoint_ftype *skip_permanent_breakpoint);\n+\n+/* The maximum length of an instruction on this architecture in bytes. */\n+\n+extern bool gdbarch_max_insn_length_p (struct gdbarch *gdbarch);\n+\n+extern ULONGEST gdbarch_max_insn_length (struct gdbarch *gdbarch);\n+extern void set_gdbarch_max_insn_length (struct gdbarch *gdbarch, ULONGEST max_insn_length);\n+\n+/* Copy the instruction at FROM to TO, and make any adjustments\n+   necessary to single-step it at that address.\n+  \n+   REGS holds the state the thread's registers will have before\n+   executing the copied instruction; the PC in REGS will refer to FROM,\n+   not the copy at TO.  The caller should update it to point at TO later.\n+  \n+   Return a pointer to data of the architecture's choice to be passed\n+   to gdbarch_displaced_step_fixup.\n+  \n+   For a general explanation of displaced stepping and how GDB uses it,\n+   see the comments in infrun.c.\n+  \n+   The TO area is only guaranteed to have space for\n+   gdbarch_max_insn_length (arch) bytes, so this function must not\n+   write more bytes than that to that area.\n+  \n+   If you do not provide this function, GDB assumes that the\n+   architecture does not support displaced stepping.\n+  \n+   If the instruction cannot execute out of line, return NULL.  The\n+   core falls back to stepping past the instruction in-line instead in\n+   that case. */\n+\n+extern bool gdbarch_displaced_step_copy_insn_p (struct gdbarch *gdbarch);\n+\n+typedef displaced_step_copy_insn_closure_up (gdbarch_displaced_step_copy_insn_ftype) (struct gdbarch *gdbarch, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n+extern displaced_step_copy_insn_closure_up gdbarch_displaced_step_copy_insn (struct gdbarch *gdbarch, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n+extern void set_gdbarch_displaced_step_copy_insn (struct gdbarch *gdbarch, gdbarch_displaced_step_copy_insn_ftype *displaced_step_copy_insn);\n+\n+/* Return true if GDB should use hardware single-stepping to execute a displaced\n+   step instruction.  If false, GDB will simply restart execution at the\n+   displaced instruction location, and it is up to the target to ensure GDB will\n+   receive control again (e.g. by placing a software breakpoint instruction into\n+   the displaced instruction buffer).\n+  \n+   The default implementation returns false on all targets that provide a\n+   gdbarch_software_single_step routine, and true otherwise. */\n+\n+typedef bool (gdbarch_displaced_step_hw_singlestep_ftype) (struct gdbarch *gdbarch);\n+extern bool gdbarch_displaced_step_hw_singlestep (struct gdbarch *gdbarch);\n+extern void set_gdbarch_displaced_step_hw_singlestep (struct gdbarch *gdbarch, gdbarch_displaced_step_hw_singlestep_ftype *displaced_step_hw_singlestep);\n+\n+/* Fix up the state resulting from successfully single-stepping a\n+   displaced instruction, to give the result we would have gotten from\n+   stepping the instruction in its original location.\n+  \n+   REGS is the register state resulting from single-stepping the\n+   displaced instruction.\n+  \n+   CLOSURE is the result from the matching call to\n+   gdbarch_displaced_step_copy_insn.\n+  \n+   If you provide gdbarch_displaced_step_copy_insn.but not this\n+   function, then GDB assumes that no fixup is needed after\n+   single-stepping the instruction.\n+  \n+   For a general explanation of displaced stepping and how GDB uses it,\n+   see the comments in infrun.c. */\n+\n+extern bool gdbarch_displaced_step_fixup_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_displaced_step_fixup_ftype) (struct gdbarch *gdbarch, struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n+extern void gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n+extern void set_gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, gdbarch_displaced_step_fixup_ftype *displaced_step_fixup);\n+\n+/* Prepare THREAD for it to displaced step the instruction at its current PC.\n+  \n+   Throw an exception if any unexpected error happens. */\n+\n+extern bool gdbarch_displaced_step_prepare_p (struct gdbarch *gdbarch);\n+\n+typedef displaced_step_prepare_status (gdbarch_displaced_step_prepare_ftype) (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n+extern displaced_step_prepare_status gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n+extern void set_gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, gdbarch_displaced_step_prepare_ftype *displaced_step_prepare);\n+\n+/* Clean up after a displaced step of THREAD. */\n+\n+typedef displaced_step_finish_status (gdbarch_displaced_step_finish_ftype) (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n+extern displaced_step_finish_status gdbarch_displaced_step_finish (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n+extern void set_gdbarch_displaced_step_finish (struct gdbarch *gdbarch, gdbarch_displaced_step_finish_ftype *displaced_step_finish);\n+\n+/* Return the closure associated to the displaced step buffer that is at ADDR. */\n+\n+extern bool gdbarch_displaced_step_copy_insn_closure_by_addr_p (struct gdbarch *gdbarch);\n+\n+typedef const displaced_step_copy_insn_closure * (gdbarch_displaced_step_copy_insn_closure_by_addr_ftype) (inferior *inf, CORE_ADDR addr);\n+extern const displaced_step_copy_insn_closure * gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, inferior *inf, CORE_ADDR addr);\n+extern void set_gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, gdbarch_displaced_step_copy_insn_closure_by_addr_ftype *displaced_step_copy_insn_closure_by_addr);\n+\n+/* PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n+   contents of all displaced step buffers in the child's address space. */\n+\n+typedef void (gdbarch_displaced_step_restore_all_in_ptid_ftype) (inferior *parent_inf, ptid_t child_ptid);\n+extern void gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, inferior *parent_inf, ptid_t child_ptid);\n+extern void set_gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, gdbarch_displaced_step_restore_all_in_ptid_ftype *displaced_step_restore_all_in_ptid);\n+\n+/* Relocate an instruction to execute at a different address.  OLDLOC\n+   is the address in the inferior memory where the instruction to\n+   relocate is currently at.  On input, TO points to the destination\n+   where we want the instruction to be copied (and possibly adjusted)\n+   to.  On output, it points to one past the end of the resulting\n+   instruction(s).  The effect of executing the instruction at TO shall\n+   be the same as if executing it at FROM.  For example, call\n+   instructions that implicitly push the return address on the stack\n+   should be adjusted to return to the instruction after OLDLOC;\n+   relative branches, and other PC-relative instructions need the\n+   offset adjusted; etc. */\n+\n+extern bool gdbarch_relocate_instruction_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_relocate_instruction_ftype) (struct gdbarch *gdbarch, CORE_ADDR *to, CORE_ADDR from);\n+extern void gdbarch_relocate_instruction (struct gdbarch *gdbarch, CORE_ADDR *to, CORE_ADDR from);\n+extern void set_gdbarch_relocate_instruction (struct gdbarch *gdbarch, gdbarch_relocate_instruction_ftype *relocate_instruction);\n+\n+/* Refresh overlay mapped state for section OSECT. */\n+\n+extern bool gdbarch_overlay_update_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_overlay_update_ftype) (struct obj_section *osect);\n+extern void gdbarch_overlay_update (struct gdbarch *gdbarch, struct obj_section *osect);\n+extern void set_gdbarch_overlay_update (struct gdbarch *gdbarch, gdbarch_overlay_update_ftype *overlay_update);\n+\n+extern bool gdbarch_core_read_description_p (struct gdbarch *gdbarch);\n+\n+typedef const struct target_desc * (gdbarch_core_read_description_ftype) (struct gdbarch *gdbarch, struct target_ops *target, bfd *abfd);\n+extern const struct target_desc * gdbarch_core_read_description (struct gdbarch *gdbarch, struct target_ops *target, bfd *abfd);\n+extern void set_gdbarch_core_read_description (struct gdbarch *gdbarch, gdbarch_core_read_description_ftype *core_read_description);\n+\n+/* Set if the address in N_SO or N_FUN stabs may be zero. */\n+\n+extern int gdbarch_sofun_address_maybe_missing (struct gdbarch *gdbarch);\n+extern void set_gdbarch_sofun_address_maybe_missing (struct gdbarch *gdbarch, int sofun_address_maybe_missing);\n+\n+/* Parse the instruction at ADDR storing in the record execution log\n+   the registers REGCACHE and memory ranges that will be affected when\n+   the instruction executes, along with their current values.\n+   Return -1 if something goes wrong, 0 otherwise. */\n+\n+extern bool gdbarch_process_record_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_process_record_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n+extern int gdbarch_process_record (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n+extern void set_gdbarch_process_record (struct gdbarch *gdbarch, gdbarch_process_record_ftype *process_record);\n+\n+/* Save process state after a signal.\n+   Return -1 if something goes wrong, 0 otherwise. */\n+\n+extern bool gdbarch_process_record_signal_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_process_record_signal_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, enum gdb_signal signal);\n+extern int gdbarch_process_record_signal (struct gdbarch *gdbarch, struct regcache *regcache, enum gdb_signal signal);\n+extern void set_gdbarch_process_record_signal (struct gdbarch *gdbarch, gdbarch_process_record_signal_ftype *process_record_signal);\n+\n+/* Signal translation: translate inferior's signal (target's) number\n+   into GDB's representation.  The implementation of this method must\n+   be host independent.  IOW, don't rely on symbols of the NAT_FILE\n+   header (the nm-*.h files), the host <signal.h> header, or similar\n+   headers.  This is mainly used when cross-debugging core files ---\n+   \"Live\" targets hide the translation behind the target interface\n+   (target_wait, target_resume, etc.). */\n+\n+extern bool gdbarch_gdb_signal_from_target_p (struct gdbarch *gdbarch);\n+\n+typedef enum gdb_signal (gdbarch_gdb_signal_from_target_ftype) (struct gdbarch *gdbarch, int signo);\n+extern enum gdb_signal gdbarch_gdb_signal_from_target (struct gdbarch *gdbarch, int signo);\n+extern void set_gdbarch_gdb_signal_from_target (struct gdbarch *gdbarch, gdbarch_gdb_signal_from_target_ftype *gdb_signal_from_target);\n+\n+/* Signal translation: translate the GDB's internal signal number into\n+   the inferior's signal (target's) representation.  The implementation\n+   of this method must be host independent.  IOW, don't rely on symbols\n+   of the NAT_FILE header (the nm-*.h files), the host <signal.h>\n+   header, or similar headers.\n+   Return the target signal number if found, or -1 if the GDB internal\n+   signal number is invalid. */\n+\n+extern bool gdbarch_gdb_signal_to_target_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_gdb_signal_to_target_ftype) (struct gdbarch *gdbarch, enum gdb_signal signal);\n+extern int gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, enum gdb_signal signal);\n+extern void set_gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, gdbarch_gdb_signal_to_target_ftype *gdb_signal_to_target);\n+\n+/* Extra signal info inspection.\n+  \n+   Return a type suitable to inspect extra signal information. */\n+\n+extern bool gdbarch_get_siginfo_type_p (struct gdbarch *gdbarch);\n+\n+typedef struct type * (gdbarch_get_siginfo_type_ftype) (struct gdbarch *gdbarch);\n+extern struct type * gdbarch_get_siginfo_type (struct gdbarch *gdbarch);\n+extern void set_gdbarch_get_siginfo_type (struct gdbarch *gdbarch, gdbarch_get_siginfo_type_ftype *get_siginfo_type);\n+\n+/* Record architecture-specific information from the symbol table. */\n+\n+extern bool gdbarch_record_special_symbol_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_record_special_symbol_ftype) (struct gdbarch *gdbarch, struct objfile *objfile, asymbol *sym);\n+extern void gdbarch_record_special_symbol (struct gdbarch *gdbarch, struct objfile *objfile, asymbol *sym);\n+extern void set_gdbarch_record_special_symbol (struct gdbarch *gdbarch, gdbarch_record_special_symbol_ftype *record_special_symbol);\n+\n+/* Function for the 'catch syscall' feature.\n+   Get architecture-specific system calls information from registers. */\n+\n+extern bool gdbarch_get_syscall_number_p (struct gdbarch *gdbarch);\n+\n+typedef LONGEST (gdbarch_get_syscall_number_ftype) (struct gdbarch *gdbarch, thread_info *thread);\n+extern LONGEST gdbarch_get_syscall_number (struct gdbarch *gdbarch, thread_info *thread);\n+extern void set_gdbarch_get_syscall_number (struct gdbarch *gdbarch, gdbarch_get_syscall_number_ftype *get_syscall_number);\n+\n+/* The filename of the XML syscall for this architecture. */\n+\n+extern const char * gdbarch_xml_syscall_file (struct gdbarch *gdbarch);\n+extern void set_gdbarch_xml_syscall_file (struct gdbarch *gdbarch, const char * xml_syscall_file);\n+\n+/* Information about system calls from this architecture */\n+\n+extern struct syscalls_info * gdbarch_syscalls_info (struct gdbarch *gdbarch);\n+extern void set_gdbarch_syscalls_info (struct gdbarch *gdbarch, struct syscalls_info * syscalls_info);\n+\n+/* SystemTap related fields and functions.\n+   A NULL-terminated array of prefixes used to mark an integer constant\n+   on the architecture's assembly.\n+   For example, on x86 integer constants are written as:\n+  \n+    $10 ;; integer constant 10\n+  \n+   in this case, this prefix would be the character `$'. */\n+\n+extern const char *const * gdbarch_stap_integer_prefixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_integer_prefixes (struct gdbarch *gdbarch, const char *const * stap_integer_prefixes);\n+\n+/* A NULL-terminated array of suffixes used to mark an integer constant\n+   on the architecture's assembly. */\n+\n+extern const char *const * gdbarch_stap_integer_suffixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_integer_suffixes (struct gdbarch *gdbarch, const char *const * stap_integer_suffixes);\n+\n+/* A NULL-terminated array of prefixes used to mark a register name on\n+   the architecture's assembly.\n+   For example, on x86 the register name is written as:\n+  \n+    %eax ;; register eax\n+  \n+   in this case, this prefix would be the character `%'. */\n+\n+extern const char *const * gdbarch_stap_register_prefixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_register_prefixes (struct gdbarch *gdbarch, const char *const * stap_register_prefixes);\n+\n+/* A NULL-terminated array of suffixes used to mark a register name on\n+   the architecture's assembly. */\n+\n+extern const char *const * gdbarch_stap_register_suffixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_register_suffixes (struct gdbarch *gdbarch, const char *const * stap_register_suffixes);\n+\n+/* A NULL-terminated array of prefixes used to mark a register\n+   indirection on the architecture's assembly.\n+   For example, on x86 the register indirection is written as:\n+  \n+    (%eax) ;; indirecting eax\n+  \n+   in this case, this prefix would be the charater `('.\n+  \n+   Please note that we use the indirection prefix also for register\n+   displacement, e.g., `4(%eax)' on x86. */\n+\n+extern const char *const * gdbarch_stap_register_indirection_prefixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_register_indirection_prefixes (struct gdbarch *gdbarch, const char *const * stap_register_indirection_prefixes);\n+\n+/* A NULL-terminated array of suffixes used to mark a register\n+   indirection on the architecture's assembly.\n+   For example, on x86 the register indirection is written as:\n+  \n+    (%eax) ;; indirecting eax\n+  \n+   in this case, this prefix would be the charater `)'.\n+  \n+   Please note that we use the indirection suffix also for register\n+   displacement, e.g., `4(%eax)' on x86. */\n+\n+extern const char *const * gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch, const char *const * stap_register_indirection_suffixes);\n+\n+/* Prefix(es) used to name a register using GDB's nomenclature.\n+  \n+   For example, on PPC a register is represented by a number in the assembly\n+   language (e.g., `10' is the 10th general-purpose register).  However,\n+   inside GDB this same register has an `r' appended to its name, so the 10th\n+   register would be represented as `r10' internally. */\n+\n+extern const char * gdbarch_stap_gdb_register_prefix (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_gdb_register_prefix (struct gdbarch *gdbarch, const char * stap_gdb_register_prefix);\n+\n+/* Suffix used to name a register using GDB's nomenclature. */\n+\n+extern const char * gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch);\n+extern void set_gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch, const char * stap_gdb_register_suffix);\n+\n+/* Check if S is a single operand.\n+  \n+   Single operands can be:\n+    - Literal integers, e.g. `$10' on x86\n+    - Register access, e.g. `%eax' on x86\n+    - Register indirection, e.g. `(%eax)' on x86\n+    - Register displacement, e.g. `4(%eax)' on x86\n+  \n+   This function should check for these patterns on the string\n+   and return 1 if some were found, or zero otherwise.  Please try to match\n+   as much info as you can from the string, i.e., if you have to match\n+   something like `(%', do not match just the `('. */\n+\n+extern bool gdbarch_stap_is_single_operand_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_stap_is_single_operand_ftype) (struct gdbarch *gdbarch, const char *s);\n+extern int gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, const char *s);\n+extern void set_gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, gdbarch_stap_is_single_operand_ftype *stap_is_single_operand);\n+\n+/* Function used to handle a \"special case\" in the parser.\n+  \n+   A \"special case\" is considered to be an unknown token, i.e., a token\n+   that the parser does not know how to parse.  A good example of special\n+   case would be ARM's register displacement syntax:\n+  \n+    [R0, #4]  ;; displacing R0 by 4\n+  \n+   Since the parser assumes that a register displacement is of the form:\n+  \n+    <number> <indirection_prefix> <register_name> <indirection_suffix>\n+  \n+   it means that it will not be able to recognize and parse this odd syntax.\n+   Therefore, we should add a special case function that will handle this token.\n+  \n+   This function should generate the proper expression form of the expression\n+   using GDB's internal expression mechanism (e.g., `write_exp_elt_opcode'\n+   and so on).  It should also return 1 if the parsing was successful, or zero\n+   if the token was not recognized as a special token (in this case, returning\n+   zero means that the special parser is deferring the parsing to the generic\n+   parser), and should advance the buffer pointer (p->arg). */\n+\n+extern bool gdbarch_stap_parse_special_token_p (struct gdbarch *gdbarch);\n+\n+typedef expr::operation_up (gdbarch_stap_parse_special_token_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p);\n+extern expr::operation_up gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, struct stap_parse_info *p);\n+extern void set_gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, gdbarch_stap_parse_special_token_ftype *stap_parse_special_token);\n+\n+/* Perform arch-dependent adjustments to a register name.\n+  \n+   In very specific situations, it may be necessary for the register\n+   name present in a SystemTap probe's argument to be handled in a\n+   special way.  For example, on i386, GCC may over-optimize the\n+   register allocation and use smaller registers than necessary.  In\n+   such cases, the client that is reading and evaluating the SystemTap\n+   probe (ourselves) will need to actually fetch values from the wider\n+   version of the register in question.\n+  \n+   To illustrate the example, consider the following probe argument\n+   (i386):\n+  \n+      4@%ax\n+  \n+   This argument says that its value can be found at the %ax register,\n+   which is a 16-bit register.  However, the argument's prefix says\n+   that its type is \"uint32_t\", which is 32-bit in size.  Therefore, in\n+   this case, GDB should actually fetch the probe's value from register\n+   %eax, not %ax.  In this scenario, this function would actually\n+   replace the register name from %ax to %eax.\n+  \n+   The rationale for this can be found at PR breakpoints/24541. */\n+\n+extern bool gdbarch_stap_adjust_register_p (struct gdbarch *gdbarch);\n+\n+typedef std::string (gdbarch_stap_adjust_register_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p, const std::string &regname, int regnum);\n+extern std::string gdbarch_stap_adjust_register (struct gdbarch *gdbarch, struct stap_parse_info *p, const std::string &regname, int regnum);\n+extern void set_gdbarch_stap_adjust_register (struct gdbarch *gdbarch, gdbarch_stap_adjust_register_ftype *stap_adjust_register);\n+\n+/* DTrace related functions.\n+   The expression to compute the NARTGth+1 argument to a DTrace USDT probe.\n+   NARG must be >= 0. */\n+\n+extern bool gdbarch_dtrace_parse_probe_argument_p (struct gdbarch *gdbarch);\n+\n+typedef expr::operation_up (gdbarch_dtrace_parse_probe_argument_ftype) (struct gdbarch *gdbarch, int narg);\n+extern expr::operation_up gdbarch_dtrace_parse_probe_argument (struct gdbarch *gdbarch, int narg);\n+extern void set_gdbarch_dtrace_parse_probe_argument (struct gdbarch *gdbarch, gdbarch_dtrace_parse_probe_argument_ftype *dtrace_parse_probe_argument);\n+\n+/* True if the given ADDR does not contain the instruction sequence\n+   corresponding to a disabled DTrace is-enabled probe. */\n+\n+extern bool gdbarch_dtrace_probe_is_enabled_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_dtrace_probe_is_enabled_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern int gdbarch_dtrace_probe_is_enabled (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_dtrace_probe_is_enabled (struct gdbarch *gdbarch, gdbarch_dtrace_probe_is_enabled_ftype *dtrace_probe_is_enabled);\n+\n+/* Enable a DTrace is-enabled probe at ADDR. */\n+\n+extern bool gdbarch_dtrace_enable_probe_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_dtrace_enable_probe_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void gdbarch_dtrace_enable_probe (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_dtrace_enable_probe (struct gdbarch *gdbarch, gdbarch_dtrace_enable_probe_ftype *dtrace_enable_probe);\n+\n+/* Disable a DTrace is-enabled probe at ADDR. */\n+\n+extern bool gdbarch_dtrace_disable_probe_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_dtrace_disable_probe_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void gdbarch_dtrace_disable_probe (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_dtrace_disable_probe (struct gdbarch *gdbarch, gdbarch_dtrace_disable_probe_ftype *dtrace_disable_probe);\n+\n+/* True if the list of shared libraries is one and only for all\n+   processes, as opposed to a list of shared libraries per inferior.\n+   This usually means that all processes, although may or may not share\n+   an address space, will see the same set of symbols at the same\n+   addresses. */\n+\n+extern int gdbarch_has_global_solist (struct gdbarch *gdbarch);\n+extern void set_gdbarch_has_global_solist (struct gdbarch *gdbarch, int has_global_solist);\n+\n+/* On some targets, even though each inferior has its own private\n+   address space, the debug interface takes care of making breakpoints\n+   visible to all address spaces automatically.  For such cases,\n+   this property should be set to true. */\n+\n+extern int gdbarch_has_global_breakpoints (struct gdbarch *gdbarch);\n+extern void set_gdbarch_has_global_breakpoints (struct gdbarch *gdbarch, int has_global_breakpoints);\n+\n+/* True if inferiors share an address space (e.g., uClinux). */\n+\n+typedef int (gdbarch_has_shared_address_space_ftype) (struct gdbarch *gdbarch);\n+extern int gdbarch_has_shared_address_space (struct gdbarch *gdbarch);\n+extern void set_gdbarch_has_shared_address_space (struct gdbarch *gdbarch, gdbarch_has_shared_address_space_ftype *has_shared_address_space);\n+\n+/* True if a fast tracepoint can be set at an address. */\n+\n+typedef int (gdbarch_fast_tracepoint_valid_at_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr, std::string *msg);\n+extern int gdbarch_fast_tracepoint_valid_at (struct gdbarch *gdbarch, CORE_ADDR addr, std::string *msg);\n+extern void set_gdbarch_fast_tracepoint_valid_at (struct gdbarch *gdbarch, gdbarch_fast_tracepoint_valid_at_ftype *fast_tracepoint_valid_at);\n+\n+/* Guess register state based on tracepoint location.  Used for tracepoints\n+   where no registers have been collected, but there's only one location,\n+   allowing us to guess the PC value, and perhaps some other registers.\n+   On entry, regcache has all registers marked as unavailable. */\n+\n+typedef void (gdbarch_guess_tracepoint_registers_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n+extern void gdbarch_guess_tracepoint_registers (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n+extern void set_gdbarch_guess_tracepoint_registers (struct gdbarch *gdbarch, gdbarch_guess_tracepoint_registers_ftype *guess_tracepoint_registers);\n+\n+/* Return the \"auto\" target charset. */\n+\n+typedef const char * (gdbarch_auto_charset_ftype) (void);\n+extern const char * gdbarch_auto_charset (struct gdbarch *gdbarch);\n+extern void set_gdbarch_auto_charset (struct gdbarch *gdbarch, gdbarch_auto_charset_ftype *auto_charset);\n+\n+/* Return the \"auto\" target wide charset. */\n+\n+typedef const char * (gdbarch_auto_wide_charset_ftype) (void);\n+extern const char * gdbarch_auto_wide_charset (struct gdbarch *gdbarch);\n+extern void set_gdbarch_auto_wide_charset (struct gdbarch *gdbarch, gdbarch_auto_wide_charset_ftype *auto_wide_charset);\n+\n+/* If non-empty, this is a file extension that will be opened in place\n+   of the file extension reported by the shared library list.\n+  \n+   This is most useful for toolchains that use a post-linker tool,\n+   where the names of the files run on the target differ in extension\n+   compared to the names of the files GDB should load for debug info. */\n+\n+extern const char * gdbarch_solib_symbols_extension (struct gdbarch *gdbarch);\n+extern void set_gdbarch_solib_symbols_extension (struct gdbarch *gdbarch, const char * solib_symbols_extension);\n+\n+/* If true, the target OS has DOS-based file system semantics.  That\n+   is, absolute paths include a drive name, and the backslash is\n+   considered a directory separator. */\n+\n+extern int gdbarch_has_dos_based_file_system (struct gdbarch *gdbarch);\n+extern void set_gdbarch_has_dos_based_file_system (struct gdbarch *gdbarch, int has_dos_based_file_system);\n+\n+/* Generate bytecodes to collect the return address in a frame.\n+   Since the bytecodes run on the target, possibly with GDB not even\n+   connected, the full unwinding machinery is not available, and\n+   typically this function will issue bytecodes for one or more likely\n+   places that the return address may be found. */\n+\n+typedef void (gdbarch_gen_return_address_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, struct axs_value *value, CORE_ADDR scope);\n+extern void gdbarch_gen_return_address (struct gdbarch *gdbarch, struct agent_expr *ax, struct axs_value *value, CORE_ADDR scope);\n+extern void set_gdbarch_gen_return_address (struct gdbarch *gdbarch, gdbarch_gen_return_address_ftype *gen_return_address);\n+\n+/* Implement the \"info proc\" command. */\n+\n+extern bool gdbarch_info_proc_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_info_proc_ftype) (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n+extern void gdbarch_info_proc (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n+extern void set_gdbarch_info_proc (struct gdbarch *gdbarch, gdbarch_info_proc_ftype *info_proc);\n+\n+/* Implement the \"info proc\" command for core files.  Noe that there\n+   are two \"info_proc\"-like methods on gdbarch -- one for core files,\n+   one for live targets. */\n+\n+extern bool gdbarch_core_info_proc_p (struct gdbarch *gdbarch);\n+\n+typedef void (gdbarch_core_info_proc_ftype) (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n+extern void gdbarch_core_info_proc (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n+extern void set_gdbarch_core_info_proc (struct gdbarch *gdbarch, gdbarch_core_info_proc_ftype *core_info_proc);\n+\n+/* Iterate over all objfiles in the order that makes the most sense\n+   for the architecture to make global symbol searches.\n+  \n+   CB is a callback function where OBJFILE is the objfile to be searched,\n+   and CB_DATA a pointer to user-defined data (the same data that is passed\n+   when calling this gdbarch method).  The iteration stops if this function\n+   returns nonzero.\n+  \n+   CB_DATA is a pointer to some user-defined data to be passed to\n+   the callback.\n+  \n+   If not NULL, CURRENT_OBJFILE corresponds to the objfile being\n+   inspected when the symbol search was requested. */\n+\n+typedef void (gdbarch_iterate_over_objfiles_in_search_order_ftype) (struct gdbarch *gdbarch, iterate_over_objfiles_in_search_order_cb_ftype *cb, void *cb_data, struct objfile *current_objfile);\n+extern void gdbarch_iterate_over_objfiles_in_search_order (struct gdbarch *gdbarch, iterate_over_objfiles_in_search_order_cb_ftype *cb, void *cb_data, struct objfile *current_objfile);\n+extern void set_gdbarch_iterate_over_objfiles_in_search_order (struct gdbarch *gdbarch, gdbarch_iterate_over_objfiles_in_search_order_ftype *iterate_over_objfiles_in_search_order);\n+\n+/* Ravenscar arch-dependent ops. */\n+\n+extern struct ravenscar_arch_ops * gdbarch_ravenscar_ops (struct gdbarch *gdbarch);\n+extern void set_gdbarch_ravenscar_ops (struct gdbarch *gdbarch, struct ravenscar_arch_ops * ravenscar_ops);\n+\n+/* Return non-zero if the instruction at ADDR is a call; zero otherwise. */\n+\n+typedef int (gdbarch_insn_is_call_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern int gdbarch_insn_is_call (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_insn_is_call (struct gdbarch *gdbarch, gdbarch_insn_is_call_ftype *insn_is_call);\n+\n+/* Return non-zero if the instruction at ADDR is a return; zero otherwise. */\n+\n+typedef int (gdbarch_insn_is_ret_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern int gdbarch_insn_is_ret (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_insn_is_ret (struct gdbarch *gdbarch, gdbarch_insn_is_ret_ftype *insn_is_ret);\n+\n+/* Return non-zero if the instruction at ADDR is a jump; zero otherwise. */\n+\n+typedef int (gdbarch_insn_is_jump_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern int gdbarch_insn_is_jump (struct gdbarch *gdbarch, CORE_ADDR addr);\n+extern void set_gdbarch_insn_is_jump (struct gdbarch *gdbarch, gdbarch_insn_is_jump_ftype *insn_is_jump);\n+\n+/* Return true if there's a program/permanent breakpoint planted in\n+   memory at ADDRESS, return false otherwise. */\n+\n+typedef bool (gdbarch_program_breakpoint_here_p_ftype) (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern bool gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address);\n+extern void set_gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, gdbarch_program_breakpoint_here_p_ftype *program_breakpoint_here_p);\n+\n+/* Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n+   Return 0 if *READPTR is already at the end of the buffer.\n+   Return -1 if there is insufficient buffer for a whole entry.\n+   Return 1 if an entry was read into *TYPEP and *VALP. */\n+\n+extern bool gdbarch_auxv_parse_p (struct gdbarch *gdbarch);\n+\n+typedef int (gdbarch_auxv_parse_ftype) (struct gdbarch *gdbarch, gdb_byte **readptr, gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp);\n+extern int gdbarch_auxv_parse (struct gdbarch *gdbarch, gdb_byte **readptr, gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp);\n+extern void set_gdbarch_auxv_parse (struct gdbarch *gdbarch, gdbarch_auxv_parse_ftype *auxv_parse);\n+\n+/* Print the description of a single auxv entry described by TYPE and VAL\n+   to FILE. */\n+\n+typedef void (gdbarch_print_auxv_entry_ftype) (struct gdbarch *gdbarch, struct ui_file *file, CORE_ADDR type, CORE_ADDR val);\n+extern void gdbarch_print_auxv_entry (struct gdbarch *gdbarch, struct ui_file *file, CORE_ADDR type, CORE_ADDR val);\n+extern void set_gdbarch_print_auxv_entry (struct gdbarch *gdbarch, gdbarch_print_auxv_entry_ftype *print_auxv_entry);\n+\n+/* Find the address range of the current inferior's vsyscall/vDSO, and\n+   write it to *RANGE.  If the vsyscall's length can't be determined, a\n+   range with zero length is returned.  Returns true if the vsyscall is\n+   found, false otherwise. */\n+\n+typedef int (gdbarch_vsyscall_range_ftype) (struct gdbarch *gdbarch, struct mem_range *range);\n+extern int gdbarch_vsyscall_range (struct gdbarch *gdbarch, struct mem_range *range);\n+extern void set_gdbarch_vsyscall_range (struct gdbarch *gdbarch, gdbarch_vsyscall_range_ftype *vsyscall_range);\n+\n+/* Allocate SIZE bytes of PROT protected page aligned memory in inferior.\n+   PROT has GDB_MMAP_PROT_* bitmask format.\n+   Throw an error if it is not possible.  Returned address is always valid. */\n+\n+typedef CORE_ADDR (gdbarch_infcall_mmap_ftype) (CORE_ADDR size, unsigned prot);\n+extern CORE_ADDR gdbarch_infcall_mmap (struct gdbarch *gdbarch, CORE_ADDR size, unsigned prot);\n+extern void set_gdbarch_infcall_mmap (struct gdbarch *gdbarch, gdbarch_infcall_mmap_ftype *infcall_mmap);\n+\n+/* Deallocate SIZE bytes of memory at ADDR in inferior from gdbarch_infcall_mmap.\n+   Print a warning if it is not possible. */\n+\n+typedef void (gdbarch_infcall_munmap_ftype) (CORE_ADDR addr, CORE_ADDR size);\n+extern void gdbarch_infcall_munmap (struct gdbarch *gdbarch, CORE_ADDR addr, CORE_ADDR size);\n+extern void set_gdbarch_infcall_munmap (struct gdbarch *gdbarch, gdbarch_infcall_munmap_ftype *infcall_munmap);\n+\n+/* Return string (caller has to use xfree for it) with options for GCC\n+   to produce code for this target, typically \"-m64\", \"-m32\" or \"-m31\".\n+   These options are put before CU's DW_AT_producer compilation options so that\n+   they can override it. */\n+\n+typedef std::string (gdbarch_gcc_target_options_ftype) (struct gdbarch *gdbarch);\n+extern std::string gdbarch_gcc_target_options (struct gdbarch *gdbarch);\n+extern void set_gdbarch_gcc_target_options (struct gdbarch *gdbarch, gdbarch_gcc_target_options_ftype *gcc_target_options);\n+\n+/* Return a regular expression that matches names used by this\n+   architecture in GNU configury triplets.  The result is statically\n+   allocated and must not be freed.  The default implementation simply\n+   returns the BFD architecture name, which is correct in nearly every\n+   case. */\n+\n+typedef const char * (gdbarch_gnu_triplet_regexp_ftype) (struct gdbarch *gdbarch);\n+extern const char * gdbarch_gnu_triplet_regexp (struct gdbarch *gdbarch);\n+extern void set_gdbarch_gnu_triplet_regexp (struct gdbarch *gdbarch, gdbarch_gnu_triplet_regexp_ftype *gnu_triplet_regexp);\n+\n+/* Return the size in 8-bit bytes of an addressable memory unit on this\n+   architecture.  This corresponds to the number of 8-bit bytes associated to\n+   each address in memory. */\n+\n+typedef int (gdbarch_addressable_memory_unit_size_ftype) (struct gdbarch *gdbarch);\n+extern int gdbarch_addressable_memory_unit_size (struct gdbarch *gdbarch);\n+extern void set_gdbarch_addressable_memory_unit_size (struct gdbarch *gdbarch, gdbarch_addressable_memory_unit_size_ftype *addressable_memory_unit_size);\n+\n+/* Functions for allowing a target to modify its disassembler options. */\n+\n+extern const char * gdbarch_disassembler_options_implicit (struct gdbarch *gdbarch);\n+extern void set_gdbarch_disassembler_options_implicit (struct gdbarch *gdbarch, const char * disassembler_options_implicit);\n+\n+extern char ** gdbarch_disassembler_options (struct gdbarch *gdbarch);\n+extern void set_gdbarch_disassembler_options (struct gdbarch *gdbarch, char ** disassembler_options);\n+\n+extern const disasm_options_and_args_t * gdbarch_valid_disassembler_options (struct gdbarch *gdbarch);\n+extern void set_gdbarch_valid_disassembler_options (struct gdbarch *gdbarch, const disasm_options_and_args_t * valid_disassembler_options);\n+\n+/* Type alignment override method.  Return the architecture specific\n+   alignment required for TYPE.  If there is no special handling\n+   required for TYPE then return the value 0, GDB will then apply the\n+   default rules as laid out in gdbtypes.c:type_align. */\n+\n+typedef ULONGEST (gdbarch_type_align_ftype) (struct gdbarch *gdbarch, struct type *type);\n+extern ULONGEST gdbarch_type_align (struct gdbarch *gdbarch, struct type *type);\n+extern void set_gdbarch_type_align (struct gdbarch *gdbarch, gdbarch_type_align_ftype *type_align);\n+\n+/* Return a string containing any flags for the given PC in the given FRAME. */\n+\n+typedef std::string (gdbarch_get_pc_address_flags_ftype) (frame_info *frame, CORE_ADDR pc);\n+extern std::string gdbarch_get_pc_address_flags (struct gdbarch *gdbarch, frame_info *frame, CORE_ADDR pc);\n+extern void set_gdbarch_get_pc_address_flags (struct gdbarch *gdbarch, gdbarch_get_pc_address_flags_ftype *get_pc_address_flags);\n+\n+/* Read core file mappings */\n+\n+typedef void (gdbarch_read_core_file_mappings_ftype) (struct gdbarch *gdbarch, struct bfd *cbfd, read_core_file_mappings_pre_loop_ftype pre_loop_cb, read_core_file_mappings_loop_ftype loop_cb);\n+extern void gdbarch_read_core_file_mappings (struct gdbarch *gdbarch, struct bfd *cbfd, read_core_file_mappings_pre_loop_ftype pre_loop_cb, read_core_file_mappings_loop_ftype loop_cb);\n+extern void set_gdbarch_read_core_file_mappings (struct gdbarch *gdbarch, gdbarch_read_core_file_mappings_ftype *read_core_file_mappings);"
    },
    {
      "sha": "c2fad6ff7353071e78e951c1260525c47aa3aac1",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1587,
      "changes": 1588,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=2b7c3f1dc0fb7158ec019018d61927f364243fbc",
      "patch": "@@ -1,6 +1,3 @@\n-/* *INDENT-OFF* */ /* THIS FILE IS GENERATED -*- buffer-read-only: t -*- */\n-/* vi:set ro: */\n-\n /* Dynamic architecture support for GDB, the GNU debugger.\n \n    Copyright (C) 1998-2021 Free Software Foundation, Inc.\n@@ -20,7 +17,6 @@\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n-/* This file was created with the aid of ``gdbarch.sh''.  */\n \n #ifndef GDBARCH_H\n #define GDBARCH_H\n@@ -144,1589 +140,7 @@ using read_core_file_mappings_loop_ftype =\n \t\t\t   const char *filename,\n \t\t\t   const bfd_build_id *build_id)>;\n \n-\n-/* The following are pre-initialized by GDBARCH.  */\n-\n-extern const struct bfd_arch_info * gdbarch_bfd_arch_info (struct gdbarch *gdbarch);\n-/* set_gdbarch_bfd_arch_info() - not applicable - pre-initialized.  */\n-\n-extern enum bfd_endian gdbarch_byte_order (struct gdbarch *gdbarch);\n-/* set_gdbarch_byte_order() - not applicable - pre-initialized.  */\n-\n-extern enum bfd_endian gdbarch_byte_order_for_code (struct gdbarch *gdbarch);\n-/* set_gdbarch_byte_order_for_code() - not applicable - pre-initialized.  */\n-\n-extern enum gdb_osabi gdbarch_osabi (struct gdbarch *gdbarch);\n-/* set_gdbarch_osabi() - not applicable - pre-initialized.  */\n-\n-extern const struct target_desc * gdbarch_target_desc (struct gdbarch *gdbarch);\n-/* set_gdbarch_target_desc() - not applicable - pre-initialized.  */\n-\n-\n-/* The following are initialized by the target dependent code.  */\n-\n-/* Number of bits in a short or unsigned short for the target machine. */\n-\n-extern int gdbarch_short_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_short_bit (struct gdbarch *gdbarch, int short_bit);\n-\n-/* Number of bits in an int or unsigned int for the target machine. */\n-\n-extern int gdbarch_int_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_int_bit (struct gdbarch *gdbarch, int int_bit);\n-\n-/* Number of bits in a long or unsigned long for the target machine. */\n-\n-extern int gdbarch_long_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_long_bit (struct gdbarch *gdbarch, int long_bit);\n-\n-/* Number of bits in a long long or unsigned long long for the target\n-   machine. */\n-\n-extern int gdbarch_long_long_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_long_long_bit (struct gdbarch *gdbarch, int long_long_bit);\n-\n-/* The ABI default bit-size and format for \"bfloat16\", \"half\", \"float\", \"double\", and\n-   \"long double\".  These bit/format pairs should eventually be combined\n-   into a single object.  For the moment, just initialize them as a pair.\n-   Each format describes both the big and little endian layouts (if\n-   useful). */\n-\n-extern int gdbarch_bfloat16_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_bfloat16_bit (struct gdbarch *gdbarch, int bfloat16_bit);\n-\n-extern const struct floatformat ** gdbarch_bfloat16_format (struct gdbarch *gdbarch);\n-extern void set_gdbarch_bfloat16_format (struct gdbarch *gdbarch, const struct floatformat ** bfloat16_format);\n-\n-extern int gdbarch_half_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_half_bit (struct gdbarch *gdbarch, int half_bit);\n-\n-extern const struct floatformat ** gdbarch_half_format (struct gdbarch *gdbarch);\n-extern void set_gdbarch_half_format (struct gdbarch *gdbarch, const struct floatformat ** half_format);\n-\n-extern int gdbarch_float_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_float_bit (struct gdbarch *gdbarch, int float_bit);\n-\n-extern const struct floatformat ** gdbarch_float_format (struct gdbarch *gdbarch);\n-extern void set_gdbarch_float_format (struct gdbarch *gdbarch, const struct floatformat ** float_format);\n-\n-extern int gdbarch_double_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_double_bit (struct gdbarch *gdbarch, int double_bit);\n-\n-extern const struct floatformat ** gdbarch_double_format (struct gdbarch *gdbarch);\n-extern void set_gdbarch_double_format (struct gdbarch *gdbarch, const struct floatformat ** double_format);\n-\n-extern int gdbarch_long_double_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_long_double_bit (struct gdbarch *gdbarch, int long_double_bit);\n-\n-extern const struct floatformat ** gdbarch_long_double_format (struct gdbarch *gdbarch);\n-extern void set_gdbarch_long_double_format (struct gdbarch *gdbarch, const struct floatformat ** long_double_format);\n-\n-/* The ABI default bit-size for \"wchar_t\".  wchar_t is a built-in type\n-   starting with C++11. */\n-\n-extern int gdbarch_wchar_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_wchar_bit (struct gdbarch *gdbarch, int wchar_bit);\n-\n-/* One if `wchar_t' is signed, zero if unsigned. */\n-\n-extern int gdbarch_wchar_signed (struct gdbarch *gdbarch);\n-extern void set_gdbarch_wchar_signed (struct gdbarch *gdbarch, int wchar_signed);\n-\n-/* Returns the floating-point format to be used for values of length LENGTH.\n-   NAME, if non-NULL, is the type name, which may be used to distinguish\n-   different target formats of the same length. */\n-\n-typedef const struct floatformat ** (gdbarch_floatformat_for_type_ftype) (struct gdbarch *gdbarch, const char *name, int length);\n-extern const struct floatformat ** gdbarch_floatformat_for_type (struct gdbarch *gdbarch, const char *name, int length);\n-extern void set_gdbarch_floatformat_for_type (struct gdbarch *gdbarch, gdbarch_floatformat_for_type_ftype *floatformat_for_type);\n-\n-/* For most targets, a pointer on the target and its representation as an\n-   address in GDB have the same size and \"look the same\".  For such a\n-   target, you need only set gdbarch_ptr_bit and gdbarch_addr_bit\n-   / addr_bit will be set from it.\n-  \n-   If gdbarch_ptr_bit and gdbarch_addr_bit are different, you'll probably\n-   also need to set gdbarch_dwarf2_addr_size, gdbarch_pointer_to_address and\n-   gdbarch_address_to_pointer as well.\n-  \n-   ptr_bit is the size of a pointer on the target */\n-\n-extern int gdbarch_ptr_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_ptr_bit (struct gdbarch *gdbarch, int ptr_bit);\n-\n-/* addr_bit is the size of a target address as represented in gdb */\n-\n-extern int gdbarch_addr_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_addr_bit (struct gdbarch *gdbarch, int addr_bit);\n-\n-/* dwarf2_addr_size is the target address size as used in the Dwarf debug\n-   info.  For .debug_frame FDEs, this is supposed to be the target address\n-   size from the associated CU header, and which is equivalent to the\n-   DWARF2_ADDR_SIZE as defined by the target specific GCC back-end.\n-   Unfortunately there is no good way to determine this value.  Therefore\n-   dwarf2_addr_size simply defaults to the target pointer size.\n-  \n-   dwarf2_addr_size is not used for .eh_frame FDEs, which are generally\n-   defined using the target's pointer size so far.\n-  \n-   Note that dwarf2_addr_size only needs to be redefined by a target if the\n-   GCC back-end defines a DWARF2_ADDR_SIZE other than the target pointer size,\n-   and if Dwarf versions < 4 need to be supported. */\n-\n-extern int gdbarch_dwarf2_addr_size (struct gdbarch *gdbarch);\n-extern void set_gdbarch_dwarf2_addr_size (struct gdbarch *gdbarch, int dwarf2_addr_size);\n-\n-/* One if `char' acts like `signed char', zero if `unsigned char'. */\n-\n-extern int gdbarch_char_signed (struct gdbarch *gdbarch);\n-extern void set_gdbarch_char_signed (struct gdbarch *gdbarch, int char_signed);\n-\n-extern bool gdbarch_read_pc_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_read_pc_ftype) (readable_regcache *regcache);\n-extern CORE_ADDR gdbarch_read_pc (struct gdbarch *gdbarch, readable_regcache *regcache);\n-extern void set_gdbarch_read_pc (struct gdbarch *gdbarch, gdbarch_read_pc_ftype *read_pc);\n-\n-extern bool gdbarch_write_pc_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_write_pc_ftype) (struct regcache *regcache, CORE_ADDR val);\n-extern void gdbarch_write_pc (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR val);\n-extern void set_gdbarch_write_pc (struct gdbarch *gdbarch, gdbarch_write_pc_ftype *write_pc);\n-\n-/* Function for getting target's idea of a frame pointer.  FIXME: GDB's\n-   whole scheme for dealing with \"frames\" and \"frame pointers\" needs a\n-   serious shakedown. */\n-\n-typedef void (gdbarch_virtual_frame_pointer_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc, int *frame_regnum, LONGEST *frame_offset);\n-extern void gdbarch_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc, int *frame_regnum, LONGEST *frame_offset);\n-extern void set_gdbarch_virtual_frame_pointer (struct gdbarch *gdbarch, gdbarch_virtual_frame_pointer_ftype *virtual_frame_pointer);\n-\n-extern bool gdbarch_pseudo_register_read_p (struct gdbarch *gdbarch);\n-\n-typedef enum register_status (gdbarch_pseudo_register_read_ftype) (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum, gdb_byte *buf);\n-extern enum register_status gdbarch_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum, gdb_byte *buf);\n-extern void set_gdbarch_pseudo_register_read (struct gdbarch *gdbarch, gdbarch_pseudo_register_read_ftype *pseudo_register_read);\n-\n-/* Read a register into a new struct value.  If the register is wholly\n-   or partly unavailable, this should call mark_value_bytes_unavailable\n-   as appropriate.  If this is defined, then pseudo_register_read will\n-   never be called. */\n-\n-extern bool gdbarch_pseudo_register_read_value_p (struct gdbarch *gdbarch);\n-\n-typedef struct value * (gdbarch_pseudo_register_read_value_ftype) (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum);\n-extern struct value * gdbarch_pseudo_register_read_value (struct gdbarch *gdbarch, readable_regcache *regcache, int cookednum);\n-extern void set_gdbarch_pseudo_register_read_value (struct gdbarch *gdbarch, gdbarch_pseudo_register_read_value_ftype *pseudo_register_read_value);\n-\n-extern bool gdbarch_pseudo_register_write_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_pseudo_register_write_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, int cookednum, const gdb_byte *buf);\n-extern void gdbarch_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache, int cookednum, const gdb_byte *buf);\n-extern void set_gdbarch_pseudo_register_write (struct gdbarch *gdbarch, gdbarch_pseudo_register_write_ftype *pseudo_register_write);\n-\n-extern int gdbarch_num_regs (struct gdbarch *gdbarch);\n-extern void set_gdbarch_num_regs (struct gdbarch *gdbarch, int num_regs);\n-\n-/* This macro gives the number of pseudo-registers that live in the\n-   register namespace but do not get fetched or stored on the target.\n-   These pseudo-registers may be aliases for other registers,\n-   combinations of other registers, or they may be computed by GDB. */\n-\n-extern int gdbarch_num_pseudo_regs (struct gdbarch *gdbarch);\n-extern void set_gdbarch_num_pseudo_regs (struct gdbarch *gdbarch, int num_pseudo_regs);\n-\n-/* Assemble agent expression bytecode to collect pseudo-register REG.\n-   Return -1 if something goes wrong, 0 otherwise. */\n-\n-extern bool gdbarch_ax_pseudo_register_collect_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_ax_pseudo_register_collect_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n-extern int gdbarch_ax_pseudo_register_collect (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n-extern void set_gdbarch_ax_pseudo_register_collect (struct gdbarch *gdbarch, gdbarch_ax_pseudo_register_collect_ftype *ax_pseudo_register_collect);\n-\n-/* Assemble agent expression bytecode to push the value of pseudo-register\n-   REG on the interpreter stack.\n-   Return -1 if something goes wrong, 0 otherwise. */\n-\n-extern bool gdbarch_ax_pseudo_register_push_stack_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_ax_pseudo_register_push_stack_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n-extern int gdbarch_ax_pseudo_register_push_stack (struct gdbarch *gdbarch, struct agent_expr *ax, int reg);\n-extern void set_gdbarch_ax_pseudo_register_push_stack (struct gdbarch *gdbarch, gdbarch_ax_pseudo_register_push_stack_ftype *ax_pseudo_register_push_stack);\n-\n-/* Some architectures can display additional information for specific\n-   signals.\n-   UIOUT is the output stream where the handler will place information. */\n-\n-extern bool gdbarch_report_signal_info_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_report_signal_info_ftype) (struct gdbarch *gdbarch, struct ui_out *uiout, enum gdb_signal siggnal);\n-extern void gdbarch_report_signal_info (struct gdbarch *gdbarch, struct ui_out *uiout, enum gdb_signal siggnal);\n-extern void set_gdbarch_report_signal_info (struct gdbarch *gdbarch, gdbarch_report_signal_info_ftype *report_signal_info);\n-\n-/* GDB's standard (or well known) register numbers.  These can map onto\n-   a real register or a pseudo (computed) register or not be defined at\n-   all (-1).\n-   gdbarch_sp_regnum will hopefully be replaced by UNWIND_SP. */\n-\n-extern int gdbarch_sp_regnum (struct gdbarch *gdbarch);\n-extern void set_gdbarch_sp_regnum (struct gdbarch *gdbarch, int sp_regnum);\n-\n-extern int gdbarch_pc_regnum (struct gdbarch *gdbarch);\n-extern void set_gdbarch_pc_regnum (struct gdbarch *gdbarch, int pc_regnum);\n-\n-extern int gdbarch_ps_regnum (struct gdbarch *gdbarch);\n-extern void set_gdbarch_ps_regnum (struct gdbarch *gdbarch, int ps_regnum);\n-\n-extern int gdbarch_fp0_regnum (struct gdbarch *gdbarch);\n-extern void set_gdbarch_fp0_regnum (struct gdbarch *gdbarch, int fp0_regnum);\n-\n-/* Convert stab register number (from `r' declaration) to a gdb REGNUM. */\n-\n-typedef int (gdbarch_stab_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int stab_regnr);\n-extern int gdbarch_stab_reg_to_regnum (struct gdbarch *gdbarch, int stab_regnr);\n-extern void set_gdbarch_stab_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_stab_reg_to_regnum_ftype *stab_reg_to_regnum);\n-\n-/* Provide a default mapping from a ecoff register number to a gdb REGNUM. */\n-\n-typedef int (gdbarch_ecoff_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int ecoff_regnr);\n-extern int gdbarch_ecoff_reg_to_regnum (struct gdbarch *gdbarch, int ecoff_regnr);\n-extern void set_gdbarch_ecoff_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_ecoff_reg_to_regnum_ftype *ecoff_reg_to_regnum);\n-\n-/* Convert from an sdb register number to an internal gdb register number. */\n-\n-typedef int (gdbarch_sdb_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int sdb_regnr);\n-extern int gdbarch_sdb_reg_to_regnum (struct gdbarch *gdbarch, int sdb_regnr);\n-extern void set_gdbarch_sdb_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_sdb_reg_to_regnum_ftype *sdb_reg_to_regnum);\n-\n-/* Provide a default mapping from a DWARF2 register number to a gdb REGNUM.\n-   Return -1 for bad REGNUM.  Note: Several targets get this wrong. */\n-\n-typedef int (gdbarch_dwarf2_reg_to_regnum_ftype) (struct gdbarch *gdbarch, int dwarf2_regnr);\n-extern int gdbarch_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int dwarf2_regnr);\n-extern void set_gdbarch_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, gdbarch_dwarf2_reg_to_regnum_ftype *dwarf2_reg_to_regnum);\n-\n-typedef const char * (gdbarch_register_name_ftype) (struct gdbarch *gdbarch, int regnr);\n-extern const char * gdbarch_register_name (struct gdbarch *gdbarch, int regnr);\n-extern void set_gdbarch_register_name (struct gdbarch *gdbarch, gdbarch_register_name_ftype *register_name);\n-\n-/* Return the type of a register specified by the architecture.  Only\n-   the register cache should call this function directly; others should\n-   use \"register_type\". */\n-\n-extern bool gdbarch_register_type_p (struct gdbarch *gdbarch);\n-\n-typedef struct type * (gdbarch_register_type_ftype) (struct gdbarch *gdbarch, int reg_nr);\n-extern struct type * gdbarch_register_type (struct gdbarch *gdbarch, int reg_nr);\n-extern void set_gdbarch_register_type (struct gdbarch *gdbarch, gdbarch_register_type_ftype *register_type);\n-\n-/* Generate a dummy frame_id for THIS_FRAME assuming that the frame is\n-   a dummy frame.  A dummy frame is created before an inferior call,\n-   the frame_id returned here must match the frame_id that was built\n-   for the inferior call.  Usually this means the returned frame_id's\n-   stack address should match the address returned by\n-   gdbarch_push_dummy_call, and the returned frame_id's code address\n-   should match the address at which the breakpoint was set in the dummy\n-   frame. */\n-\n-typedef struct frame_id (gdbarch_dummy_id_ftype) (struct gdbarch *gdbarch, struct frame_info *this_frame);\n-extern struct frame_id gdbarch_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame);\n-extern void set_gdbarch_dummy_id (struct gdbarch *gdbarch, gdbarch_dummy_id_ftype *dummy_id);\n-\n-/* Implement DUMMY_ID and PUSH_DUMMY_CALL, then delete\n-   deprecated_fp_regnum. */\n-\n-extern int gdbarch_deprecated_fp_regnum (struct gdbarch *gdbarch);\n-extern void set_gdbarch_deprecated_fp_regnum (struct gdbarch *gdbarch, int deprecated_fp_regnum);\n-\n-extern bool gdbarch_push_dummy_call_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_push_dummy_call_ftype) (struct gdbarch *gdbarch, struct value *function, struct regcache *regcache, CORE_ADDR bp_addr, int nargs, struct value **args, CORE_ADDR sp, function_call_return_method return_method, CORE_ADDR struct_addr);\n-extern CORE_ADDR gdbarch_push_dummy_call (struct gdbarch *gdbarch, struct value *function, struct regcache *regcache, CORE_ADDR bp_addr, int nargs, struct value **args, CORE_ADDR sp, function_call_return_method return_method, CORE_ADDR struct_addr);\n-extern void set_gdbarch_push_dummy_call (struct gdbarch *gdbarch, gdbarch_push_dummy_call_ftype *push_dummy_call);\n-\n-extern int gdbarch_call_dummy_location (struct gdbarch *gdbarch);\n-extern void set_gdbarch_call_dummy_location (struct gdbarch *gdbarch, int call_dummy_location);\n-\n-extern bool gdbarch_push_dummy_code_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_push_dummy_code_ftype) (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr, struct value **args, int nargs, struct type *value_type, CORE_ADDR *real_pc, CORE_ADDR *bp_addr, struct regcache *regcache);\n-extern CORE_ADDR gdbarch_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr, struct value **args, int nargs, struct type *value_type, CORE_ADDR *real_pc, CORE_ADDR *bp_addr, struct regcache *regcache);\n-extern void set_gdbarch_push_dummy_code (struct gdbarch *gdbarch, gdbarch_push_dummy_code_ftype *push_dummy_code);\n-\n-/* Return true if the code of FRAME is writable. */\n-\n-typedef int (gdbarch_code_of_frame_writable_ftype) (struct gdbarch *gdbarch, struct frame_info *frame);\n-extern int gdbarch_code_of_frame_writable (struct gdbarch *gdbarch, struct frame_info *frame);\n-extern void set_gdbarch_code_of_frame_writable (struct gdbarch *gdbarch, gdbarch_code_of_frame_writable_ftype *code_of_frame_writable);\n-\n-typedef void (gdbarch_print_registers_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, int regnum, int all);\n-extern void gdbarch_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, int regnum, int all);\n-extern void set_gdbarch_print_registers_info (struct gdbarch *gdbarch, gdbarch_print_registers_info_ftype *print_registers_info);\n-\n-typedef void (gdbarch_print_float_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n-extern void gdbarch_print_float_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n-extern void set_gdbarch_print_float_info (struct gdbarch *gdbarch, gdbarch_print_float_info_ftype *print_float_info);\n-\n-extern bool gdbarch_print_vector_info_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_print_vector_info_ftype) (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n-extern void gdbarch_print_vector_info (struct gdbarch *gdbarch, struct ui_file *file, struct frame_info *frame, const char *args);\n-extern void set_gdbarch_print_vector_info (struct gdbarch *gdbarch, gdbarch_print_vector_info_ftype *print_vector_info);\n-\n-/* MAP a GDB RAW register number onto a simulator register number.  See\n-   also include/...-sim.h. */\n-\n-typedef int (gdbarch_register_sim_regno_ftype) (struct gdbarch *gdbarch, int reg_nr);\n-extern int gdbarch_register_sim_regno (struct gdbarch *gdbarch, int reg_nr);\n-extern void set_gdbarch_register_sim_regno (struct gdbarch *gdbarch, gdbarch_register_sim_regno_ftype *register_sim_regno);\n-\n-typedef int (gdbarch_cannot_fetch_register_ftype) (struct gdbarch *gdbarch, int regnum);\n-extern int gdbarch_cannot_fetch_register (struct gdbarch *gdbarch, int regnum);\n-extern void set_gdbarch_cannot_fetch_register (struct gdbarch *gdbarch, gdbarch_cannot_fetch_register_ftype *cannot_fetch_register);\n-\n-typedef int (gdbarch_cannot_store_register_ftype) (struct gdbarch *gdbarch, int regnum);\n-extern int gdbarch_cannot_store_register (struct gdbarch *gdbarch, int regnum);\n-extern void set_gdbarch_cannot_store_register (struct gdbarch *gdbarch, gdbarch_cannot_store_register_ftype *cannot_store_register);\n-\n-/* Determine the address where a longjmp will land and save this address\n-   in PC.  Return nonzero on success.\n-  \n-   FRAME corresponds to the longjmp frame. */\n-\n-extern bool gdbarch_get_longjmp_target_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_get_longjmp_target_ftype) (struct frame_info *frame, CORE_ADDR *pc);\n-extern int gdbarch_get_longjmp_target (struct gdbarch *gdbarch, struct frame_info *frame, CORE_ADDR *pc);\n-extern void set_gdbarch_get_longjmp_target (struct gdbarch *gdbarch, gdbarch_get_longjmp_target_ftype *get_longjmp_target);\n-\n-extern int gdbarch_believe_pcc_promotion (struct gdbarch *gdbarch);\n-extern void set_gdbarch_believe_pcc_promotion (struct gdbarch *gdbarch, int believe_pcc_promotion);\n-\n-typedef int (gdbarch_convert_register_p_ftype) (struct gdbarch *gdbarch, int regnum, struct type *type);\n-extern int gdbarch_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type);\n-extern void set_gdbarch_convert_register_p (struct gdbarch *gdbarch, gdbarch_convert_register_p_ftype *convert_register_p);\n-\n-typedef int (gdbarch_register_to_value_ftype) (struct frame_info *frame, int regnum, struct type *type, gdb_byte *buf, int *optimizedp, int *unavailablep);\n-extern int gdbarch_register_to_value (struct gdbarch *gdbarch, struct frame_info *frame, int regnum, struct type *type, gdb_byte *buf, int *optimizedp, int *unavailablep);\n-extern void set_gdbarch_register_to_value (struct gdbarch *gdbarch, gdbarch_register_to_value_ftype *register_to_value);\n-\n-typedef void (gdbarch_value_to_register_ftype) (struct frame_info *frame, int regnum, struct type *type, const gdb_byte *buf);\n-extern void gdbarch_value_to_register (struct gdbarch *gdbarch, struct frame_info *frame, int regnum, struct type *type, const gdb_byte *buf);\n-extern void set_gdbarch_value_to_register (struct gdbarch *gdbarch, gdbarch_value_to_register_ftype *value_to_register);\n-\n-/* Construct a value representing the contents of register REGNUM in\n-   frame FRAME_ID, interpreted as type TYPE.  The routine needs to\n-   allocate and return a struct value with all value attributes\n-   (but not the value contents) filled in. */\n-\n-typedef struct value * (gdbarch_value_from_register_ftype) (struct gdbarch *gdbarch, struct type *type, int regnum, struct frame_id frame_id);\n-extern struct value * gdbarch_value_from_register (struct gdbarch *gdbarch, struct type *type, int regnum, struct frame_id frame_id);\n-extern void set_gdbarch_value_from_register (struct gdbarch *gdbarch, gdbarch_value_from_register_ftype *value_from_register);\n-\n-typedef CORE_ADDR (gdbarch_pointer_to_address_ftype) (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n-extern CORE_ADDR gdbarch_pointer_to_address (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n-extern void set_gdbarch_pointer_to_address (struct gdbarch *gdbarch, gdbarch_pointer_to_address_ftype *pointer_to_address);\n-\n-typedef void (gdbarch_address_to_pointer_ftype) (struct gdbarch *gdbarch, struct type *type, gdb_byte *buf, CORE_ADDR addr);\n-extern void gdbarch_address_to_pointer (struct gdbarch *gdbarch, struct type *type, gdb_byte *buf, CORE_ADDR addr);\n-extern void set_gdbarch_address_to_pointer (struct gdbarch *gdbarch, gdbarch_address_to_pointer_ftype *address_to_pointer);\n-\n-extern bool gdbarch_integer_to_address_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_integer_to_address_ftype) (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n-extern CORE_ADDR gdbarch_integer_to_address (struct gdbarch *gdbarch, struct type *type, const gdb_byte *buf);\n-extern void set_gdbarch_integer_to_address (struct gdbarch *gdbarch, gdbarch_integer_to_address_ftype *integer_to_address);\n-\n-/* Return the return-value convention that will be used by FUNCTION\n-   to return a value of type VALTYPE.  FUNCTION may be NULL in which\n-   case the return convention is computed based only on VALTYPE.\n-  \n-   If READBUF is not NULL, extract the return value and save it in this buffer.\n-  \n-   If WRITEBUF is not NULL, it contains a return value which will be\n-   stored into the appropriate register.  This can be used when we want\n-   to force the value returned by a function (see the \"return\" command\n-   for instance). */\n-\n-extern bool gdbarch_return_value_p (struct gdbarch *gdbarch);\n-\n-typedef enum return_value_convention (gdbarch_return_value_ftype) (struct gdbarch *gdbarch, struct value *function, struct type *valtype, struct regcache *regcache, gdb_byte *readbuf, const gdb_byte *writebuf);\n-extern enum return_value_convention gdbarch_return_value (struct gdbarch *gdbarch, struct value *function, struct type *valtype, struct regcache *regcache, gdb_byte *readbuf, const gdb_byte *writebuf);\n-extern void set_gdbarch_return_value (struct gdbarch *gdbarch, gdbarch_return_value_ftype *return_value);\n-\n-/* Return true if the return value of function is stored in the first hidden\n-   parameter.  In theory, this feature should be language-dependent, specified\n-   by language and its ABI, such as C++.  Unfortunately, compiler may\n-   implement it to a target-dependent feature.  So that we need such hook here\n-   to be aware of this in GDB. */\n-\n-typedef int (gdbarch_return_in_first_hidden_param_p_ftype) (struct gdbarch *gdbarch, struct type *type);\n-extern int gdbarch_return_in_first_hidden_param_p (struct gdbarch *gdbarch, struct type *type);\n-extern void set_gdbarch_return_in_first_hidden_param_p (struct gdbarch *gdbarch, gdbarch_return_in_first_hidden_param_p_ftype *return_in_first_hidden_param_p);\n-\n-typedef CORE_ADDR (gdbarch_skip_prologue_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern CORE_ADDR gdbarch_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern void set_gdbarch_skip_prologue (struct gdbarch *gdbarch, gdbarch_skip_prologue_ftype *skip_prologue);\n-\n-extern bool gdbarch_skip_main_prologue_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_skip_main_prologue_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern CORE_ADDR gdbarch_skip_main_prologue (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern void set_gdbarch_skip_main_prologue (struct gdbarch *gdbarch, gdbarch_skip_main_prologue_ftype *skip_main_prologue);\n-\n-/* On some platforms, a single function may provide multiple entry points,\n-   e.g. one that is used for function-pointer calls and a different one\n-   that is used for direct function calls.\n-   In order to ensure that breakpoints set on the function will trigger\n-   no matter via which entry point the function is entered, a platform\n-   may provide the skip_entrypoint callback.  It is called with IP set\n-   to the main entry point of a function (as determined by the symbol table),\n-   and should return the address of the innermost entry point, where the\n-   actual breakpoint needs to be set.  Note that skip_entrypoint is used\n-   by GDB common code even when debugging optimized code, where skip_prologue\n-   is not used. */\n-\n-extern bool gdbarch_skip_entrypoint_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_skip_entrypoint_ftype) (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern CORE_ADDR gdbarch_skip_entrypoint (struct gdbarch *gdbarch, CORE_ADDR ip);\n-extern void set_gdbarch_skip_entrypoint (struct gdbarch *gdbarch, gdbarch_skip_entrypoint_ftype *skip_entrypoint);\n-\n-typedef int (gdbarch_inner_than_ftype) (CORE_ADDR lhs, CORE_ADDR rhs);\n-extern int gdbarch_inner_than (struct gdbarch *gdbarch, CORE_ADDR lhs, CORE_ADDR rhs);\n-extern void set_gdbarch_inner_than (struct gdbarch *gdbarch, gdbarch_inner_than_ftype *inner_than);\n-\n-typedef const gdb_byte * (gdbarch_breakpoint_from_pc_ftype) (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr);\n-extern const gdb_byte * gdbarch_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr);\n-extern void set_gdbarch_breakpoint_from_pc (struct gdbarch *gdbarch, gdbarch_breakpoint_from_pc_ftype *breakpoint_from_pc);\n-\n-/* Return the breakpoint kind for this target based on *PCPTR. */\n-\n-typedef int (gdbarch_breakpoint_kind_from_pc_ftype) (struct gdbarch *gdbarch, CORE_ADDR *pcptr);\n-extern int gdbarch_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr);\n-extern void set_gdbarch_breakpoint_kind_from_pc (struct gdbarch *gdbarch, gdbarch_breakpoint_kind_from_pc_ftype *breakpoint_kind_from_pc);\n-\n-/* Return the software breakpoint from KIND.  KIND can have target\n-   specific meaning like the Z0 kind parameter.\n-   SIZE is set to the software breakpoint's length in memory. */\n-\n-typedef const gdb_byte * (gdbarch_sw_breakpoint_from_kind_ftype) (struct gdbarch *gdbarch, int kind, int *size);\n-extern const gdb_byte * gdbarch_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size);\n-extern void set_gdbarch_sw_breakpoint_from_kind (struct gdbarch *gdbarch, gdbarch_sw_breakpoint_from_kind_ftype *sw_breakpoint_from_kind);\n-\n-/* Return the breakpoint kind for this target based on the current\n-   processor state (e.g. the current instruction mode on ARM) and the\n-   *PCPTR.  In default, it is gdbarch->breakpoint_kind_from_pc. */\n-\n-typedef int (gdbarch_breakpoint_kind_from_current_state_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR *pcptr);\n-extern int gdbarch_breakpoint_kind_from_current_state (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR *pcptr);\n-extern void set_gdbarch_breakpoint_kind_from_current_state (struct gdbarch *gdbarch, gdbarch_breakpoint_kind_from_current_state_ftype *breakpoint_kind_from_current_state);\n-\n-extern bool gdbarch_adjust_breakpoint_address_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_adjust_breakpoint_address_ftype) (struct gdbarch *gdbarch, CORE_ADDR bpaddr);\n-extern CORE_ADDR gdbarch_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr);\n-extern void set_gdbarch_adjust_breakpoint_address (struct gdbarch *gdbarch, gdbarch_adjust_breakpoint_address_ftype *adjust_breakpoint_address);\n-\n-typedef int (gdbarch_memory_insert_breakpoint_ftype) (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n-extern int gdbarch_memory_insert_breakpoint (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n-extern void set_gdbarch_memory_insert_breakpoint (struct gdbarch *gdbarch, gdbarch_memory_insert_breakpoint_ftype *memory_insert_breakpoint);\n-\n-typedef int (gdbarch_memory_remove_breakpoint_ftype) (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n-extern int gdbarch_memory_remove_breakpoint (struct gdbarch *gdbarch, struct bp_target_info *bp_tgt);\n-extern void set_gdbarch_memory_remove_breakpoint (struct gdbarch *gdbarch, gdbarch_memory_remove_breakpoint_ftype *memory_remove_breakpoint);\n-\n-extern CORE_ADDR gdbarch_decr_pc_after_break (struct gdbarch *gdbarch);\n-extern void set_gdbarch_decr_pc_after_break (struct gdbarch *gdbarch, CORE_ADDR decr_pc_after_break);\n-\n-/* A function can be addressed by either it's \"pointer\" (possibly a\n-   descriptor address) or \"entry point\" (first executable instruction).\n-   The method \"convert_from_func_ptr_addr\" converting the former to the\n-   latter.  gdbarch_deprecated_function_start_offset is being used to implement\n-   a simplified subset of that functionality - the function's address\n-   corresponds to the \"function pointer\" and the function's start\n-   corresponds to the \"function entry point\" - and hence is redundant. */\n-\n-extern CORE_ADDR gdbarch_deprecated_function_start_offset (struct gdbarch *gdbarch);\n-extern void set_gdbarch_deprecated_function_start_offset (struct gdbarch *gdbarch, CORE_ADDR deprecated_function_start_offset);\n-\n-/* Return the remote protocol register number associated with this\n-   register.  Normally the identity mapping. */\n-\n-typedef int (gdbarch_remote_register_number_ftype) (struct gdbarch *gdbarch, int regno);\n-extern int gdbarch_remote_register_number (struct gdbarch *gdbarch, int regno);\n-extern void set_gdbarch_remote_register_number (struct gdbarch *gdbarch, gdbarch_remote_register_number_ftype *remote_register_number);\n-\n-/* Fetch the target specific address used to represent a load module. */\n-\n-extern bool gdbarch_fetch_tls_load_module_address_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_fetch_tls_load_module_address_ftype) (struct objfile *objfile);\n-extern CORE_ADDR gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, struct objfile *objfile);\n-extern void set_gdbarch_fetch_tls_load_module_address (struct gdbarch *gdbarch, gdbarch_fetch_tls_load_module_address_ftype *fetch_tls_load_module_address);\n-\n-/* Return the thread-local address at OFFSET in the thread-local\n-   storage for the thread PTID and the shared library or executable\n-   file given by LM_ADDR.  If that block of thread-local storage hasn't\n-   been allocated yet, this function may throw an error.  LM_ADDR may\n-   be zero for statically linked multithreaded inferiors. */\n-\n-extern bool gdbarch_get_thread_local_address_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_get_thread_local_address_ftype) (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);\n-extern CORE_ADDR gdbarch_get_thread_local_address (struct gdbarch *gdbarch, ptid_t ptid, CORE_ADDR lm_addr, CORE_ADDR offset);\n-extern void set_gdbarch_get_thread_local_address (struct gdbarch *gdbarch, gdbarch_get_thread_local_address_ftype *get_thread_local_address);\n-\n-extern CORE_ADDR gdbarch_frame_args_skip (struct gdbarch *gdbarch);\n-extern void set_gdbarch_frame_args_skip (struct gdbarch *gdbarch, CORE_ADDR frame_args_skip);\n-\n-typedef CORE_ADDR (gdbarch_unwind_pc_ftype) (struct gdbarch *gdbarch, struct frame_info *next_frame);\n-extern CORE_ADDR gdbarch_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame);\n-extern void set_gdbarch_unwind_pc (struct gdbarch *gdbarch, gdbarch_unwind_pc_ftype *unwind_pc);\n-\n-typedef CORE_ADDR (gdbarch_unwind_sp_ftype) (struct gdbarch *gdbarch, struct frame_info *next_frame);\n-extern CORE_ADDR gdbarch_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame);\n-extern void set_gdbarch_unwind_sp (struct gdbarch *gdbarch, gdbarch_unwind_sp_ftype *unwind_sp);\n-\n-/* DEPRECATED_FRAME_LOCALS_ADDRESS as been replaced by the per-frame\n-   frame-base.  Enable frame-base before frame-unwind. */\n-\n-extern bool gdbarch_frame_num_args_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_frame_num_args_ftype) (struct frame_info *frame);\n-extern int gdbarch_frame_num_args (struct gdbarch *gdbarch, struct frame_info *frame);\n-extern void set_gdbarch_frame_num_args (struct gdbarch *gdbarch, gdbarch_frame_num_args_ftype *frame_num_args);\n-\n-extern bool gdbarch_frame_align_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_frame_align_ftype) (struct gdbarch *gdbarch, CORE_ADDR address);\n-extern CORE_ADDR gdbarch_frame_align (struct gdbarch *gdbarch, CORE_ADDR address);\n-extern void set_gdbarch_frame_align (struct gdbarch *gdbarch, gdbarch_frame_align_ftype *frame_align);\n-\n-typedef int (gdbarch_stabs_argument_has_addr_ftype) (struct gdbarch *gdbarch, struct type *type);\n-extern int gdbarch_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type);\n-extern void set_gdbarch_stabs_argument_has_addr (struct gdbarch *gdbarch, gdbarch_stabs_argument_has_addr_ftype *stabs_argument_has_addr);\n-\n-extern int gdbarch_frame_red_zone_size (struct gdbarch *gdbarch);\n-extern void set_gdbarch_frame_red_zone_size (struct gdbarch *gdbarch, int frame_red_zone_size);\n-\n-typedef CORE_ADDR (gdbarch_convert_from_func_ptr_addr_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr, struct target_ops *targ);\n-extern CORE_ADDR gdbarch_convert_from_func_ptr_addr (struct gdbarch *gdbarch, CORE_ADDR addr, struct target_ops *targ);\n-extern void set_gdbarch_convert_from_func_ptr_addr (struct gdbarch *gdbarch, gdbarch_convert_from_func_ptr_addr_ftype *convert_from_func_ptr_addr);\n-\n-/* On some machines there are bits in addresses which are not really\n-   part of the address, but are used by the kernel, the hardware, etc.\n-   for special purposes.  gdbarch_addr_bits_remove takes out any such bits so\n-   we get a \"real\" address such as one would find in a symbol table.\n-   This is used only for addresses of instructions, and even then I'm\n-   not sure it's used in all contexts.  It exists to deal with there\n-   being a few stray bits in the PC which would mislead us, not as some\n-   sort of generic thing to handle alignment or segmentation (it's\n-   possible it should be in TARGET_READ_PC instead). */\n-\n-typedef CORE_ADDR (gdbarch_addr_bits_remove_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern CORE_ADDR gdbarch_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_addr_bits_remove (struct gdbarch *gdbarch, gdbarch_addr_bits_remove_ftype *addr_bits_remove);\n-\n-/* On some machines, not all bits of an address word are significant.\n-   For example, on AArch64, the top bits of an address known as the \"tag\"\n-   are ignored by the kernel, the hardware, etc. and can be regarded as\n-   additional data associated with the address. */\n-\n-extern int gdbarch_significant_addr_bit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_significant_addr_bit (struct gdbarch *gdbarch, int significant_addr_bit);\n-\n-/* Return a string representation of the memory tag TAG. */\n-\n-typedef std::string (gdbarch_memtag_to_string_ftype) (struct gdbarch *gdbarch, struct value *tag);\n-extern std::string gdbarch_memtag_to_string (struct gdbarch *gdbarch, struct value *tag);\n-extern void set_gdbarch_memtag_to_string (struct gdbarch *gdbarch, gdbarch_memtag_to_string_ftype *memtag_to_string);\n-\n-/* Return true if ADDRESS contains a tag and false otherwise.  ADDRESS\n-   must be either a pointer or a reference type. */\n-\n-typedef bool (gdbarch_tagged_address_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n-extern bool gdbarch_tagged_address_p (struct gdbarch *gdbarch, struct value *address);\n-extern void set_gdbarch_tagged_address_p (struct gdbarch *gdbarch, gdbarch_tagged_address_p_ftype *tagged_address_p);\n-\n-/* Return true if the tag from ADDRESS matches the memory tag for that\n-   particular address.  Return false otherwise. */\n-\n-typedef bool (gdbarch_memtag_matches_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n-extern bool gdbarch_memtag_matches_p (struct gdbarch *gdbarch, struct value *address);\n-extern void set_gdbarch_memtag_matches_p (struct gdbarch *gdbarch, gdbarch_memtag_matches_p_ftype *memtag_matches_p);\n-\n-/* Set the tags of type TAG_TYPE, for the memory address range\n-   [ADDRESS, ADDRESS + LENGTH) to TAGS.\n-   Return true if successful and false otherwise. */\n-\n-typedef bool (gdbarch_set_memtags_ftype) (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n-extern bool gdbarch_set_memtags (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n-extern void set_gdbarch_set_memtags (struct gdbarch *gdbarch, gdbarch_set_memtags_ftype *set_memtags);\n-\n-/* Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n-   assuming ADDRESS is tagged. */\n-\n-typedef struct value * (gdbarch_get_memtag_ftype) (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n-extern struct value * gdbarch_get_memtag (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n-extern void set_gdbarch_get_memtag (struct gdbarch *gdbarch, gdbarch_get_memtag_ftype *get_memtag);\n-\n-/* memtag_granule_size is the size of the allocation tag granule, for\n-   architectures that support memory tagging.\n-   This is 0 for architectures that do not support memory tagging.\n-   For a non-zero value, this represents the number of bytes of memory per tag. */\n-\n-extern CORE_ADDR gdbarch_memtag_granule_size (struct gdbarch *gdbarch);\n-extern void set_gdbarch_memtag_granule_size (struct gdbarch *gdbarch, CORE_ADDR memtag_granule_size);\n-\n-/* FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n-   indicates if the target needs software single step.  An ISA method to\n-   implement it.\n-  \n-   FIXME/cagney/2001-01-18: The logic is backwards.  It should be asking if the\n-   target can single step.  If not, then implement single step using breakpoints.\n-  \n-   Return a vector of addresses on which the software single step\n-   breakpoints should be inserted.  NULL means software single step is\n-   not used.\n-   Multiple breakpoints may be inserted for some instructions such as\n-   conditional branch.  However, each implementation must always evaluate\n-   the condition and only put the breakpoint at the branch destination if\n-   the condition is true, so that we ensure forward progress when stepping\n-   past a conditional branch to self. */\n-\n-extern bool gdbarch_software_single_step_p (struct gdbarch *gdbarch);\n-\n-typedef std::vector<CORE_ADDR> (gdbarch_software_single_step_ftype) (struct regcache *regcache);\n-extern std::vector<CORE_ADDR> gdbarch_software_single_step (struct gdbarch *gdbarch, struct regcache *regcache);\n-extern void set_gdbarch_software_single_step (struct gdbarch *gdbarch, gdbarch_software_single_step_ftype *software_single_step);\n-\n-/* Return non-zero if the processor is executing a delay slot and a\n-   further single-step is needed before the instruction finishes. */\n-\n-extern bool gdbarch_single_step_through_delay_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_single_step_through_delay_ftype) (struct gdbarch *gdbarch, struct frame_info *frame);\n-extern int gdbarch_single_step_through_delay (struct gdbarch *gdbarch, struct frame_info *frame);\n-extern void set_gdbarch_single_step_through_delay (struct gdbarch *gdbarch, gdbarch_single_step_through_delay_ftype *single_step_through_delay);\n-\n-/* FIXME: cagney/2003-08-28: Need to find a better way of selecting the\n-   disassembler.  Perhaps objdump can handle it? */\n-\n-typedef int (gdbarch_print_insn_ftype) (bfd_vma vma, struct disassemble_info *info);\n-extern int gdbarch_print_insn (struct gdbarch *gdbarch, bfd_vma vma, struct disassemble_info *info);\n-extern void set_gdbarch_print_insn (struct gdbarch *gdbarch, gdbarch_print_insn_ftype *print_insn);\n-\n-typedef CORE_ADDR (gdbarch_skip_trampoline_code_ftype) (struct frame_info *frame, CORE_ADDR pc);\n-extern CORE_ADDR gdbarch_skip_trampoline_code (struct gdbarch *gdbarch, struct frame_info *frame, CORE_ADDR pc);\n-extern void set_gdbarch_skip_trampoline_code (struct gdbarch *gdbarch, gdbarch_skip_trampoline_code_ftype *skip_trampoline_code);\n-\n-/* If in_solib_dynsym_resolve_code() returns true, and SKIP_SOLIB_RESOLVER\n-   evaluates non-zero, this is the address where the debugger will place\n-   a step-resume breakpoint to get us past the dynamic linker. */\n-\n-typedef CORE_ADDR (gdbarch_skip_solib_resolver_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc);\n-extern CORE_ADDR gdbarch_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc);\n-extern void set_gdbarch_skip_solib_resolver (struct gdbarch *gdbarch, gdbarch_skip_solib_resolver_ftype *skip_solib_resolver);\n-\n-/* Some systems also have trampoline code for returning from shared libs. */\n-\n-typedef int (gdbarch_in_solib_return_trampoline_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc, const char *name);\n-extern int gdbarch_in_solib_return_trampoline (struct gdbarch *gdbarch, CORE_ADDR pc, const char *name);\n-extern void set_gdbarch_in_solib_return_trampoline (struct gdbarch *gdbarch, gdbarch_in_solib_return_trampoline_ftype *in_solib_return_trampoline);\n-\n-/* Return true if PC lies inside an indirect branch thunk. */\n-\n-typedef bool (gdbarch_in_indirect_branch_thunk_ftype) (struct gdbarch *gdbarch, CORE_ADDR pc);\n-extern bool gdbarch_in_indirect_branch_thunk (struct gdbarch *gdbarch, CORE_ADDR pc);\n-extern void set_gdbarch_in_indirect_branch_thunk (struct gdbarch *gdbarch, gdbarch_in_indirect_branch_thunk_ftype *in_indirect_branch_thunk);\n-\n-/* A target might have problems with watchpoints as soon as the stack\n-   frame of the current function has been destroyed.  This mostly happens\n-   as the first action in a function's epilogue.  stack_frame_destroyed_p()\n-   is defined to return a non-zero value if either the given addr is one\n-   instruction after the stack destroying instruction up to the trailing\n-   return instruction or if we can figure out that the stack frame has\n-   already been invalidated regardless of the value of addr.  Targets\n-   which don't suffer from that problem could just let this functionality\n-   untouched. */\n-\n-typedef int (gdbarch_stack_frame_destroyed_p_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern int gdbarch_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_stack_frame_destroyed_p (struct gdbarch *gdbarch, gdbarch_stack_frame_destroyed_p_ftype *stack_frame_destroyed_p);\n-\n-/* Process an ELF symbol in the minimal symbol table in a backend-specific\n-   way.  Normally this hook is supposed to do nothing, however if required,\n-   then this hook can be used to apply tranformations to symbols that are\n-   considered special in some way.  For example the MIPS backend uses it\n-   to interpret `st_other' information to mark compressed code symbols so\n-   that they can be treated in the appropriate manner in the processing of\n-   the main symbol table and DWARF-2 records. */\n-\n-extern bool gdbarch_elf_make_msymbol_special_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_elf_make_msymbol_special_ftype) (asymbol *sym, struct minimal_symbol *msym);\n-extern void gdbarch_elf_make_msymbol_special (struct gdbarch *gdbarch, asymbol *sym, struct minimal_symbol *msym);\n-extern void set_gdbarch_elf_make_msymbol_special (struct gdbarch *gdbarch, gdbarch_elf_make_msymbol_special_ftype *elf_make_msymbol_special);\n-\n-typedef void (gdbarch_coff_make_msymbol_special_ftype) (int val, struct minimal_symbol *msym);\n-extern void gdbarch_coff_make_msymbol_special (struct gdbarch *gdbarch, int val, struct minimal_symbol *msym);\n-extern void set_gdbarch_coff_make_msymbol_special (struct gdbarch *gdbarch, gdbarch_coff_make_msymbol_special_ftype *coff_make_msymbol_special);\n-\n-/* Process a symbol in the main symbol table in a backend-specific way.\n-   Normally this hook is supposed to do nothing, however if required,\n-   then this hook can be used to apply tranformations to symbols that\n-   are considered special in some way.  This is currently used by the\n-   MIPS backend to make sure compressed code symbols have the ISA bit\n-   set.  This in turn is needed for symbol values seen in GDB to match\n-   the values used at the runtime by the program itself, for function\n-   and label references. */\n-\n-typedef void (gdbarch_make_symbol_special_ftype) (struct symbol *sym, struct objfile *objfile);\n-extern void gdbarch_make_symbol_special (struct gdbarch *gdbarch, struct symbol *sym, struct objfile *objfile);\n-extern void set_gdbarch_make_symbol_special (struct gdbarch *gdbarch, gdbarch_make_symbol_special_ftype *make_symbol_special);\n-\n-/* Adjust the address retrieved from a DWARF-2 record other than a line\n-   entry in a backend-specific way.  Normally this hook is supposed to\n-   return the address passed unchanged, however if that is incorrect for\n-   any reason, then this hook can be used to fix the address up in the\n-   required manner.  This is currently used by the MIPS backend to make\n-   sure addresses in FDE, range records, etc. referring to compressed\n-   code have the ISA bit set, matching line information and the symbol\n-   table. */\n-\n-typedef CORE_ADDR (gdbarch_adjust_dwarf2_addr_ftype) (CORE_ADDR pc);\n-extern CORE_ADDR gdbarch_adjust_dwarf2_addr (struct gdbarch *gdbarch, CORE_ADDR pc);\n-extern void set_gdbarch_adjust_dwarf2_addr (struct gdbarch *gdbarch, gdbarch_adjust_dwarf2_addr_ftype *adjust_dwarf2_addr);\n-\n-/* Adjust the address updated by a line entry in a backend-specific way.\n-   Normally this hook is supposed to return the address passed unchanged,\n-   however in the case of inconsistencies in these records, this hook can\n-   be used to fix them up in the required manner.  This is currently used\n-   by the MIPS backend to make sure all line addresses in compressed code\n-   are presented with the ISA bit set, which is not always the case.  This\n-   in turn ensures breakpoint addresses are correctly matched against the\n-   stop PC. */\n-\n-typedef CORE_ADDR (gdbarch_adjust_dwarf2_line_ftype) (CORE_ADDR addr, int rel);\n-extern CORE_ADDR gdbarch_adjust_dwarf2_line (struct gdbarch *gdbarch, CORE_ADDR addr, int rel);\n-extern void set_gdbarch_adjust_dwarf2_line (struct gdbarch *gdbarch, gdbarch_adjust_dwarf2_line_ftype *adjust_dwarf2_line);\n-\n-extern int gdbarch_cannot_step_breakpoint (struct gdbarch *gdbarch);\n-extern void set_gdbarch_cannot_step_breakpoint (struct gdbarch *gdbarch, int cannot_step_breakpoint);\n-\n-/* See comment in target.h about continuable, steppable and\n-   non-steppable watchpoints. */\n-\n-extern int gdbarch_have_nonsteppable_watchpoint (struct gdbarch *gdbarch);\n-extern void set_gdbarch_have_nonsteppable_watchpoint (struct gdbarch *gdbarch, int have_nonsteppable_watchpoint);\n-\n-extern bool gdbarch_address_class_type_flags_p (struct gdbarch *gdbarch);\n-\n-typedef type_instance_flags (gdbarch_address_class_type_flags_ftype) (int byte_size, int dwarf2_addr_class);\n-extern type_instance_flags gdbarch_address_class_type_flags (struct gdbarch *gdbarch, int byte_size, int dwarf2_addr_class);\n-extern void set_gdbarch_address_class_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_ftype *address_class_type_flags);\n-\n-extern bool gdbarch_address_class_type_flags_to_name_p (struct gdbarch *gdbarch);\n-\n-typedef const char * (gdbarch_address_class_type_flags_to_name_ftype) (struct gdbarch *gdbarch, type_instance_flags type_flags);\n-extern const char * gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, type_instance_flags type_flags);\n-extern void set_gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_to_name_ftype *address_class_type_flags_to_name);\n-\n-/* Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n-   FS are passed from the generic execute_cfa_program function. */\n-\n-typedef bool (gdbarch_execute_dwarf_cfa_vendor_op_ftype) (struct gdbarch *gdbarch, gdb_byte op, struct dwarf2_frame_state *fs);\n-extern bool gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_byte op, struct dwarf2_frame_state *fs);\n-extern void set_gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdbarch_execute_dwarf_cfa_vendor_op_ftype *execute_dwarf_cfa_vendor_op);\n-\n-/* Return the appropriate type_flags for the supplied address class.\n-   This function should return true if the address class was recognized and\n-   type_flags was set, false otherwise. */\n-\n-extern bool gdbarch_address_class_name_to_type_flags_p (struct gdbarch *gdbarch);\n-\n-typedef bool (gdbarch_address_class_name_to_type_flags_ftype) (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n-extern bool gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n-extern void set_gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_name_to_type_flags_ftype *address_class_name_to_type_flags);\n-\n-/* Is a register in a group */\n-\n-typedef int (gdbarch_register_reggroup_p_ftype) (struct gdbarch *gdbarch, int regnum, struct reggroup *reggroup);\n-extern int gdbarch_register_reggroup_p (struct gdbarch *gdbarch, int regnum, struct reggroup *reggroup);\n-extern void set_gdbarch_register_reggroup_p (struct gdbarch *gdbarch, gdbarch_register_reggroup_p_ftype *register_reggroup_p);\n-\n-/* Fetch the pointer to the ith function argument. */\n-\n-extern bool gdbarch_fetch_pointer_argument_p (struct gdbarch *gdbarch);\n-\n-typedef CORE_ADDR (gdbarch_fetch_pointer_argument_ftype) (struct frame_info *frame, int argi, struct type *type);\n-extern CORE_ADDR gdbarch_fetch_pointer_argument (struct gdbarch *gdbarch, struct frame_info *frame, int argi, struct type *type);\n-extern void set_gdbarch_fetch_pointer_argument (struct gdbarch *gdbarch, gdbarch_fetch_pointer_argument_ftype *fetch_pointer_argument);\n-\n-/* Iterate over all supported register notes in a core file.  For each\n-   supported register note section, the iterator must call CB and pass\n-   CB_DATA unchanged.  If REGCACHE is not NULL, the iterator can limit\n-   the supported register note sections based on the current register\n-   values.  Otherwise it should enumerate all supported register note\n-   sections. */\n-\n-extern bool gdbarch_iterate_over_regset_sections_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_iterate_over_regset_sections_ftype) (struct gdbarch *gdbarch, iterate_over_regset_sections_cb *cb, void *cb_data, const struct regcache *regcache);\n-extern void gdbarch_iterate_over_regset_sections (struct gdbarch *gdbarch, iterate_over_regset_sections_cb *cb, void *cb_data, const struct regcache *regcache);\n-extern void set_gdbarch_iterate_over_regset_sections (struct gdbarch *gdbarch, gdbarch_iterate_over_regset_sections_ftype *iterate_over_regset_sections);\n-\n-/* Create core file notes */\n-\n-extern bool gdbarch_make_corefile_notes_p (struct gdbarch *gdbarch);\n-\n-typedef gdb::unique_xmalloc_ptr<char> (gdbarch_make_corefile_notes_ftype) (struct gdbarch *gdbarch, bfd *obfd, int *note_size);\n-extern gdb::unique_xmalloc_ptr<char> gdbarch_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size);\n-extern void set_gdbarch_make_corefile_notes (struct gdbarch *gdbarch, gdbarch_make_corefile_notes_ftype *make_corefile_notes);\n-\n-/* Find core file memory regions */\n-\n-extern bool gdbarch_find_memory_regions_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_find_memory_regions_ftype) (struct gdbarch *gdbarch, find_memory_region_ftype func, void *data);\n-extern int gdbarch_find_memory_regions (struct gdbarch *gdbarch, find_memory_region_ftype func, void *data);\n-extern void set_gdbarch_find_memory_regions (struct gdbarch *gdbarch, gdbarch_find_memory_regions_ftype *find_memory_regions);\n-\n-/* Read offset OFFSET of TARGET_OBJECT_LIBRARIES formatted shared libraries list from\n-   core file into buffer READBUF with length LEN.  Return the number of bytes read\n-   (zero indicates failure).\n-   failed, otherwise, return the red length of READBUF. */\n-\n-extern bool gdbarch_core_xfer_shared_libraries_p (struct gdbarch *gdbarch);\n-\n-typedef ULONGEST (gdbarch_core_xfer_shared_libraries_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern ULONGEST gdbarch_core_xfer_shared_libraries (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern void set_gdbarch_core_xfer_shared_libraries (struct gdbarch *gdbarch, gdbarch_core_xfer_shared_libraries_ftype *core_xfer_shared_libraries);\n-\n-/* Read offset OFFSET of TARGET_OBJECT_LIBRARIES_AIX formatted shared\n-   libraries list from core file into buffer READBUF with length LEN.\n-   Return the number of bytes read (zero indicates failure). */\n-\n-extern bool gdbarch_core_xfer_shared_libraries_aix_p (struct gdbarch *gdbarch);\n-\n-typedef ULONGEST (gdbarch_core_xfer_shared_libraries_aix_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern ULONGEST gdbarch_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern void set_gdbarch_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch, gdbarch_core_xfer_shared_libraries_aix_ftype *core_xfer_shared_libraries_aix);\n-\n-/* How the core target converts a PTID from a core file to a string. */\n-\n-extern bool gdbarch_core_pid_to_str_p (struct gdbarch *gdbarch);\n-\n-typedef std::string (gdbarch_core_pid_to_str_ftype) (struct gdbarch *gdbarch, ptid_t ptid);\n-extern std::string gdbarch_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n-extern void set_gdbarch_core_pid_to_str (struct gdbarch *gdbarch, gdbarch_core_pid_to_str_ftype *core_pid_to_str);\n-\n-/* How the core target extracts the name of a thread from a core file. */\n-\n-extern bool gdbarch_core_thread_name_p (struct gdbarch *gdbarch);\n-\n-typedef const char * (gdbarch_core_thread_name_ftype) (struct gdbarch *gdbarch, struct thread_info *thr);\n-extern const char * gdbarch_core_thread_name (struct gdbarch *gdbarch, struct thread_info *thr);\n-extern void set_gdbarch_core_thread_name (struct gdbarch *gdbarch, gdbarch_core_thread_name_ftype *core_thread_name);\n-\n-/* Read offset OFFSET of TARGET_OBJECT_SIGNAL_INFO signal information\n-   from core file into buffer READBUF with length LEN.  Return the number\n-   of bytes read (zero indicates EOF, a negative value indicates failure). */\n-\n-extern bool gdbarch_core_xfer_siginfo_p (struct gdbarch *gdbarch);\n-\n-typedef LONGEST (gdbarch_core_xfer_siginfo_ftype) (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern LONGEST gdbarch_core_xfer_siginfo (struct gdbarch *gdbarch, gdb_byte *readbuf, ULONGEST offset, ULONGEST len);\n-extern void set_gdbarch_core_xfer_siginfo (struct gdbarch *gdbarch, gdbarch_core_xfer_siginfo_ftype *core_xfer_siginfo);\n-\n-/* BFD target to use when generating a core file. */\n-\n-extern bool gdbarch_gcore_bfd_target_p (struct gdbarch *gdbarch);\n-\n-extern const char * gdbarch_gcore_bfd_target (struct gdbarch *gdbarch);\n-extern void set_gdbarch_gcore_bfd_target (struct gdbarch *gdbarch, const char * gcore_bfd_target);\n-\n-/* If the elements of C++ vtables are in-place function descriptors rather\n-   than normal function pointers (which may point to code or a descriptor),\n-   set this to one. */\n-\n-extern int gdbarch_vtable_function_descriptors (struct gdbarch *gdbarch);\n-extern void set_gdbarch_vtable_function_descriptors (struct gdbarch *gdbarch, int vtable_function_descriptors);\n-\n-/* Set if the least significant bit of the delta is used instead of the least\n-   significant bit of the pfn for pointers to virtual member functions. */\n-\n-extern int gdbarch_vbit_in_delta (struct gdbarch *gdbarch);\n-extern void set_gdbarch_vbit_in_delta (struct gdbarch *gdbarch, int vbit_in_delta);\n-\n-/* Advance PC to next instruction in order to skip a permanent breakpoint. */\n-\n-typedef void (gdbarch_skip_permanent_breakpoint_ftype) (struct regcache *regcache);\n-extern void gdbarch_skip_permanent_breakpoint (struct gdbarch *gdbarch, struct regcache *regcache);\n-extern void set_gdbarch_skip_permanent_breakpoint (struct gdbarch *gdbarch, gdbarch_skip_permanent_breakpoint_ftype *skip_permanent_breakpoint);\n-\n-/* The maximum length of an instruction on this architecture in bytes. */\n-\n-extern bool gdbarch_max_insn_length_p (struct gdbarch *gdbarch);\n-\n-extern ULONGEST gdbarch_max_insn_length (struct gdbarch *gdbarch);\n-extern void set_gdbarch_max_insn_length (struct gdbarch *gdbarch, ULONGEST max_insn_length);\n-\n-/* Copy the instruction at FROM to TO, and make any adjustments\n-   necessary to single-step it at that address.\n-  \n-   REGS holds the state the thread's registers will have before\n-   executing the copied instruction; the PC in REGS will refer to FROM,\n-   not the copy at TO.  The caller should update it to point at TO later.\n-  \n-   Return a pointer to data of the architecture's choice to be passed\n-   to gdbarch_displaced_step_fixup.\n-  \n-   For a general explanation of displaced stepping and how GDB uses it,\n-   see the comments in infrun.c.\n-  \n-   The TO area is only guaranteed to have space for\n-   gdbarch_max_insn_length (arch) bytes, so this function must not\n-   write more bytes than that to that area.\n-  \n-   If you do not provide this function, GDB assumes that the\n-   architecture does not support displaced stepping.\n-  \n-   If the instruction cannot execute out of line, return NULL.  The\n-   core falls back to stepping past the instruction in-line instead in\n-   that case. */\n-\n-extern bool gdbarch_displaced_step_copy_insn_p (struct gdbarch *gdbarch);\n-\n-typedef displaced_step_copy_insn_closure_up (gdbarch_displaced_step_copy_insn_ftype) (struct gdbarch *gdbarch, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n-extern displaced_step_copy_insn_closure_up gdbarch_displaced_step_copy_insn (struct gdbarch *gdbarch, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n-extern void set_gdbarch_displaced_step_copy_insn (struct gdbarch *gdbarch, gdbarch_displaced_step_copy_insn_ftype *displaced_step_copy_insn);\n-\n-/* Return true if GDB should use hardware single-stepping to execute a displaced\n-   step instruction.  If false, GDB will simply restart execution at the\n-   displaced instruction location, and it is up to the target to ensure GDB will\n-   receive control again (e.g. by placing a software breakpoint instruction into\n-   the displaced instruction buffer).\n-  \n-   The default implementation returns false on all targets that provide a\n-   gdbarch_software_single_step routine, and true otherwise. */\n-\n-typedef bool (gdbarch_displaced_step_hw_singlestep_ftype) (struct gdbarch *gdbarch);\n-extern bool gdbarch_displaced_step_hw_singlestep (struct gdbarch *gdbarch);\n-extern void set_gdbarch_displaced_step_hw_singlestep (struct gdbarch *gdbarch, gdbarch_displaced_step_hw_singlestep_ftype *displaced_step_hw_singlestep);\n-\n-/* Fix up the state resulting from successfully single-stepping a\n-   displaced instruction, to give the result we would have gotten from\n-   stepping the instruction in its original location.\n-  \n-   REGS is the register state resulting from single-stepping the\n-   displaced instruction.\n-  \n-   CLOSURE is the result from the matching call to\n-   gdbarch_displaced_step_copy_insn.\n-  \n-   If you provide gdbarch_displaced_step_copy_insn.but not this\n-   function, then GDB assumes that no fixup is needed after\n-   single-stepping the instruction.\n-  \n-   For a general explanation of displaced stepping and how GDB uses it,\n-   see the comments in infrun.c. */\n-\n-extern bool gdbarch_displaced_step_fixup_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_displaced_step_fixup_ftype) (struct gdbarch *gdbarch, struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n-extern void gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n-extern void set_gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, gdbarch_displaced_step_fixup_ftype *displaced_step_fixup);\n-\n-/* Prepare THREAD for it to displaced step the instruction at its current PC.\n-  \n-   Throw an exception if any unexpected error happens. */\n-\n-extern bool gdbarch_displaced_step_prepare_p (struct gdbarch *gdbarch);\n-\n-typedef displaced_step_prepare_status (gdbarch_displaced_step_prepare_ftype) (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n-extern displaced_step_prepare_status gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n-extern void set_gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, gdbarch_displaced_step_prepare_ftype *displaced_step_prepare);\n-\n-/* Clean up after a displaced step of THREAD. */\n-\n-typedef displaced_step_finish_status (gdbarch_displaced_step_finish_ftype) (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n-extern displaced_step_finish_status gdbarch_displaced_step_finish (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n-extern void set_gdbarch_displaced_step_finish (struct gdbarch *gdbarch, gdbarch_displaced_step_finish_ftype *displaced_step_finish);\n-\n-/* Return the closure associated to the displaced step buffer that is at ADDR. */\n-\n-extern bool gdbarch_displaced_step_copy_insn_closure_by_addr_p (struct gdbarch *gdbarch);\n-\n-typedef const displaced_step_copy_insn_closure * (gdbarch_displaced_step_copy_insn_closure_by_addr_ftype) (inferior *inf, CORE_ADDR addr);\n-extern const displaced_step_copy_insn_closure * gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, inferior *inf, CORE_ADDR addr);\n-extern void set_gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, gdbarch_displaced_step_copy_insn_closure_by_addr_ftype *displaced_step_copy_insn_closure_by_addr);\n-\n-/* PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n-   contents of all displaced step buffers in the child's address space. */\n-\n-typedef void (gdbarch_displaced_step_restore_all_in_ptid_ftype) (inferior *parent_inf, ptid_t child_ptid);\n-extern void gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, inferior *parent_inf, ptid_t child_ptid);\n-extern void set_gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, gdbarch_displaced_step_restore_all_in_ptid_ftype *displaced_step_restore_all_in_ptid);\n-\n-/* Relocate an instruction to execute at a different address.  OLDLOC\n-   is the address in the inferior memory where the instruction to\n-   relocate is currently at.  On input, TO points to the destination\n-   where we want the instruction to be copied (and possibly adjusted)\n-   to.  On output, it points to one past the end of the resulting\n-   instruction(s).  The effect of executing the instruction at TO shall\n-   be the same as if executing it at FROM.  For example, call\n-   instructions that implicitly push the return address on the stack\n-   should be adjusted to return to the instruction after OLDLOC;\n-   relative branches, and other PC-relative instructions need the\n-   offset adjusted; etc. */\n-\n-extern bool gdbarch_relocate_instruction_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_relocate_instruction_ftype) (struct gdbarch *gdbarch, CORE_ADDR *to, CORE_ADDR from);\n-extern void gdbarch_relocate_instruction (struct gdbarch *gdbarch, CORE_ADDR *to, CORE_ADDR from);\n-extern void set_gdbarch_relocate_instruction (struct gdbarch *gdbarch, gdbarch_relocate_instruction_ftype *relocate_instruction);\n-\n-/* Refresh overlay mapped state for section OSECT. */\n-\n-extern bool gdbarch_overlay_update_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_overlay_update_ftype) (struct obj_section *osect);\n-extern void gdbarch_overlay_update (struct gdbarch *gdbarch, struct obj_section *osect);\n-extern void set_gdbarch_overlay_update (struct gdbarch *gdbarch, gdbarch_overlay_update_ftype *overlay_update);\n-\n-extern bool gdbarch_core_read_description_p (struct gdbarch *gdbarch);\n-\n-typedef const struct target_desc * (gdbarch_core_read_description_ftype) (struct gdbarch *gdbarch, struct target_ops *target, bfd *abfd);\n-extern const struct target_desc * gdbarch_core_read_description (struct gdbarch *gdbarch, struct target_ops *target, bfd *abfd);\n-extern void set_gdbarch_core_read_description (struct gdbarch *gdbarch, gdbarch_core_read_description_ftype *core_read_description);\n-\n-/* Set if the address in N_SO or N_FUN stabs may be zero. */\n-\n-extern int gdbarch_sofun_address_maybe_missing (struct gdbarch *gdbarch);\n-extern void set_gdbarch_sofun_address_maybe_missing (struct gdbarch *gdbarch, int sofun_address_maybe_missing);\n-\n-/* Parse the instruction at ADDR storing in the record execution log\n-   the registers REGCACHE and memory ranges that will be affected when\n-   the instruction executes, along with their current values.\n-   Return -1 if something goes wrong, 0 otherwise. */\n-\n-extern bool gdbarch_process_record_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_process_record_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n-extern int gdbarch_process_record (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n-extern void set_gdbarch_process_record (struct gdbarch *gdbarch, gdbarch_process_record_ftype *process_record);\n-\n-/* Save process state after a signal.\n-   Return -1 if something goes wrong, 0 otherwise. */\n-\n-extern bool gdbarch_process_record_signal_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_process_record_signal_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, enum gdb_signal signal);\n-extern int gdbarch_process_record_signal (struct gdbarch *gdbarch, struct regcache *regcache, enum gdb_signal signal);\n-extern void set_gdbarch_process_record_signal (struct gdbarch *gdbarch, gdbarch_process_record_signal_ftype *process_record_signal);\n-\n-/* Signal translation: translate inferior's signal (target's) number\n-   into GDB's representation.  The implementation of this method must\n-   be host independent.  IOW, don't rely on symbols of the NAT_FILE\n-   header (the nm-*.h files), the host <signal.h> header, or similar\n-   headers.  This is mainly used when cross-debugging core files ---\n-   \"Live\" targets hide the translation behind the target interface\n-   (target_wait, target_resume, etc.). */\n-\n-extern bool gdbarch_gdb_signal_from_target_p (struct gdbarch *gdbarch);\n-\n-typedef enum gdb_signal (gdbarch_gdb_signal_from_target_ftype) (struct gdbarch *gdbarch, int signo);\n-extern enum gdb_signal gdbarch_gdb_signal_from_target (struct gdbarch *gdbarch, int signo);\n-extern void set_gdbarch_gdb_signal_from_target (struct gdbarch *gdbarch, gdbarch_gdb_signal_from_target_ftype *gdb_signal_from_target);\n-\n-/* Signal translation: translate the GDB's internal signal number into\n-   the inferior's signal (target's) representation.  The implementation\n-   of this method must be host independent.  IOW, don't rely on symbols\n-   of the NAT_FILE header (the nm-*.h files), the host <signal.h>\n-   header, or similar headers.\n-   Return the target signal number if found, or -1 if the GDB internal\n-   signal number is invalid. */\n-\n-extern bool gdbarch_gdb_signal_to_target_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_gdb_signal_to_target_ftype) (struct gdbarch *gdbarch, enum gdb_signal signal);\n-extern int gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, enum gdb_signal signal);\n-extern void set_gdbarch_gdb_signal_to_target (struct gdbarch *gdbarch, gdbarch_gdb_signal_to_target_ftype *gdb_signal_to_target);\n-\n-/* Extra signal info inspection.\n-  \n-   Return a type suitable to inspect extra signal information. */\n-\n-extern bool gdbarch_get_siginfo_type_p (struct gdbarch *gdbarch);\n-\n-typedef struct type * (gdbarch_get_siginfo_type_ftype) (struct gdbarch *gdbarch);\n-extern struct type * gdbarch_get_siginfo_type (struct gdbarch *gdbarch);\n-extern void set_gdbarch_get_siginfo_type (struct gdbarch *gdbarch, gdbarch_get_siginfo_type_ftype *get_siginfo_type);\n-\n-/* Record architecture-specific information from the symbol table. */\n-\n-extern bool gdbarch_record_special_symbol_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_record_special_symbol_ftype) (struct gdbarch *gdbarch, struct objfile *objfile, asymbol *sym);\n-extern void gdbarch_record_special_symbol (struct gdbarch *gdbarch, struct objfile *objfile, asymbol *sym);\n-extern void set_gdbarch_record_special_symbol (struct gdbarch *gdbarch, gdbarch_record_special_symbol_ftype *record_special_symbol);\n-\n-/* Function for the 'catch syscall' feature.\n-   Get architecture-specific system calls information from registers. */\n-\n-extern bool gdbarch_get_syscall_number_p (struct gdbarch *gdbarch);\n-\n-typedef LONGEST (gdbarch_get_syscall_number_ftype) (struct gdbarch *gdbarch, thread_info *thread);\n-extern LONGEST gdbarch_get_syscall_number (struct gdbarch *gdbarch, thread_info *thread);\n-extern void set_gdbarch_get_syscall_number (struct gdbarch *gdbarch, gdbarch_get_syscall_number_ftype *get_syscall_number);\n-\n-/* The filename of the XML syscall for this architecture. */\n-\n-extern const char * gdbarch_xml_syscall_file (struct gdbarch *gdbarch);\n-extern void set_gdbarch_xml_syscall_file (struct gdbarch *gdbarch, const char * xml_syscall_file);\n-\n-/* Information about system calls from this architecture */\n-\n-extern struct syscalls_info * gdbarch_syscalls_info (struct gdbarch *gdbarch);\n-extern void set_gdbarch_syscalls_info (struct gdbarch *gdbarch, struct syscalls_info * syscalls_info);\n-\n-/* SystemTap related fields and functions.\n-   A NULL-terminated array of prefixes used to mark an integer constant\n-   on the architecture's assembly.\n-   For example, on x86 integer constants are written as:\n-  \n-    $10 ;; integer constant 10\n-  \n-   in this case, this prefix would be the character `$'. */\n-\n-extern const char *const * gdbarch_stap_integer_prefixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_integer_prefixes (struct gdbarch *gdbarch, const char *const * stap_integer_prefixes);\n-\n-/* A NULL-terminated array of suffixes used to mark an integer constant\n-   on the architecture's assembly. */\n-\n-extern const char *const * gdbarch_stap_integer_suffixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_integer_suffixes (struct gdbarch *gdbarch, const char *const * stap_integer_suffixes);\n-\n-/* A NULL-terminated array of prefixes used to mark a register name on\n-   the architecture's assembly.\n-   For example, on x86 the register name is written as:\n-  \n-    %eax ;; register eax\n-  \n-   in this case, this prefix would be the character `%'. */\n-\n-extern const char *const * gdbarch_stap_register_prefixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_register_prefixes (struct gdbarch *gdbarch, const char *const * stap_register_prefixes);\n-\n-/* A NULL-terminated array of suffixes used to mark a register name on\n-   the architecture's assembly. */\n-\n-extern const char *const * gdbarch_stap_register_suffixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_register_suffixes (struct gdbarch *gdbarch, const char *const * stap_register_suffixes);\n-\n-/* A NULL-terminated array of prefixes used to mark a register\n-   indirection on the architecture's assembly.\n-   For example, on x86 the register indirection is written as:\n-  \n-    (%eax) ;; indirecting eax\n-  \n-   in this case, this prefix would be the charater `('.\n-  \n-   Please note that we use the indirection prefix also for register\n-   displacement, e.g., `4(%eax)' on x86. */\n-\n-extern const char *const * gdbarch_stap_register_indirection_prefixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_register_indirection_prefixes (struct gdbarch *gdbarch, const char *const * stap_register_indirection_prefixes);\n-\n-/* A NULL-terminated array of suffixes used to mark a register\n-   indirection on the architecture's assembly.\n-   For example, on x86 the register indirection is written as:\n-  \n-    (%eax) ;; indirecting eax\n-  \n-   in this case, this prefix would be the charater `)'.\n-  \n-   Please note that we use the indirection suffix also for register\n-   displacement, e.g., `4(%eax)' on x86. */\n-\n-extern const char *const * gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_register_indirection_suffixes (struct gdbarch *gdbarch, const char *const * stap_register_indirection_suffixes);\n-\n-/* Prefix(es) used to name a register using GDB's nomenclature.\n-  \n-   For example, on PPC a register is represented by a number in the assembly\n-   language (e.g., `10' is the 10th general-purpose register).  However,\n-   inside GDB this same register has an `r' appended to its name, so the 10th\n-   register would be represented as `r10' internally. */\n-\n-extern const char * gdbarch_stap_gdb_register_prefix (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_gdb_register_prefix (struct gdbarch *gdbarch, const char * stap_gdb_register_prefix);\n-\n-/* Suffix used to name a register using GDB's nomenclature. */\n-\n-extern const char * gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch);\n-extern void set_gdbarch_stap_gdb_register_suffix (struct gdbarch *gdbarch, const char * stap_gdb_register_suffix);\n-\n-/* Check if S is a single operand.\n-  \n-   Single operands can be:\n-    - Literal integers, e.g. `$10' on x86\n-    - Register access, e.g. `%eax' on x86\n-    - Register indirection, e.g. `(%eax)' on x86\n-    - Register displacement, e.g. `4(%eax)' on x86\n-  \n-   This function should check for these patterns on the string\n-   and return 1 if some were found, or zero otherwise.  Please try to match\n-   as much info as you can from the string, i.e., if you have to match\n-   something like `(%', do not match just the `('. */\n-\n-extern bool gdbarch_stap_is_single_operand_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_stap_is_single_operand_ftype) (struct gdbarch *gdbarch, const char *s);\n-extern int gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, const char *s);\n-extern void set_gdbarch_stap_is_single_operand (struct gdbarch *gdbarch, gdbarch_stap_is_single_operand_ftype *stap_is_single_operand);\n-\n-/* Function used to handle a \"special case\" in the parser.\n-  \n-   A \"special case\" is considered to be an unknown token, i.e., a token\n-   that the parser does not know how to parse.  A good example of special\n-   case would be ARM's register displacement syntax:\n-  \n-    [R0, #4]  ;; displacing R0 by 4\n-  \n-   Since the parser assumes that a register displacement is of the form:\n-  \n-    <number> <indirection_prefix> <register_name> <indirection_suffix>\n-  \n-   it means that it will not be able to recognize and parse this odd syntax.\n-   Therefore, we should add a special case function that will handle this token.\n-  \n-   This function should generate the proper expression form of the expression\n-   using GDB's internal expression mechanism (e.g., `write_exp_elt_opcode'\n-   and so on).  It should also return 1 if the parsing was successful, or zero\n-   if the token was not recognized as a special token (in this case, returning\n-   zero means that the special parser is deferring the parsing to the generic\n-   parser), and should advance the buffer pointer (p->arg). */\n-\n-extern bool gdbarch_stap_parse_special_token_p (struct gdbarch *gdbarch);\n-\n-typedef expr::operation_up (gdbarch_stap_parse_special_token_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p);\n-extern expr::operation_up gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, struct stap_parse_info *p);\n-extern void set_gdbarch_stap_parse_special_token (struct gdbarch *gdbarch, gdbarch_stap_parse_special_token_ftype *stap_parse_special_token);\n-\n-/* Perform arch-dependent adjustments to a register name.\n-  \n-   In very specific situations, it may be necessary for the register\n-   name present in a SystemTap probe's argument to be handled in a\n-   special way.  For example, on i386, GCC may over-optimize the\n-   register allocation and use smaller registers than necessary.  In\n-   such cases, the client that is reading and evaluating the SystemTap\n-   probe (ourselves) will need to actually fetch values from the wider\n-   version of the register in question.\n-  \n-   To illustrate the example, consider the following probe argument\n-   (i386):\n-  \n-      4@%ax\n-  \n-   This argument says that its value can be found at the %ax register,\n-   which is a 16-bit register.  However, the argument's prefix says\n-   that its type is \"uint32_t\", which is 32-bit in size.  Therefore, in\n-   this case, GDB should actually fetch the probe's value from register\n-   %eax, not %ax.  In this scenario, this function would actually\n-   replace the register name from %ax to %eax.\n-  \n-   The rationale for this can be found at PR breakpoints/24541. */\n-\n-extern bool gdbarch_stap_adjust_register_p (struct gdbarch *gdbarch);\n-\n-typedef std::string (gdbarch_stap_adjust_register_ftype) (struct gdbarch *gdbarch, struct stap_parse_info *p, const std::string &regname, int regnum);\n-extern std::string gdbarch_stap_adjust_register (struct gdbarch *gdbarch, struct stap_parse_info *p, const std::string &regname, int regnum);\n-extern void set_gdbarch_stap_adjust_register (struct gdbarch *gdbarch, gdbarch_stap_adjust_register_ftype *stap_adjust_register);\n-\n-/* DTrace related functions.\n-   The expression to compute the NARTGth+1 argument to a DTrace USDT probe.\n-   NARG must be >= 0. */\n-\n-extern bool gdbarch_dtrace_parse_probe_argument_p (struct gdbarch *gdbarch);\n-\n-typedef expr::operation_up (gdbarch_dtrace_parse_probe_argument_ftype) (struct gdbarch *gdbarch, int narg);\n-extern expr::operation_up gdbarch_dtrace_parse_probe_argument (struct gdbarch *gdbarch, int narg);\n-extern void set_gdbarch_dtrace_parse_probe_argument (struct gdbarch *gdbarch, gdbarch_dtrace_parse_probe_argument_ftype *dtrace_parse_probe_argument);\n-\n-/* True if the given ADDR does not contain the instruction sequence\n-   corresponding to a disabled DTrace is-enabled probe. */\n-\n-extern bool gdbarch_dtrace_probe_is_enabled_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_dtrace_probe_is_enabled_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern int gdbarch_dtrace_probe_is_enabled (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_dtrace_probe_is_enabled (struct gdbarch *gdbarch, gdbarch_dtrace_probe_is_enabled_ftype *dtrace_probe_is_enabled);\n-\n-/* Enable a DTrace is-enabled probe at ADDR. */\n-\n-extern bool gdbarch_dtrace_enable_probe_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_dtrace_enable_probe_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void gdbarch_dtrace_enable_probe (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_dtrace_enable_probe (struct gdbarch *gdbarch, gdbarch_dtrace_enable_probe_ftype *dtrace_enable_probe);\n-\n-/* Disable a DTrace is-enabled probe at ADDR. */\n-\n-extern bool gdbarch_dtrace_disable_probe_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_dtrace_disable_probe_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void gdbarch_dtrace_disable_probe (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_dtrace_disable_probe (struct gdbarch *gdbarch, gdbarch_dtrace_disable_probe_ftype *dtrace_disable_probe);\n-\n-/* True if the list of shared libraries is one and only for all\n-   processes, as opposed to a list of shared libraries per inferior.\n-   This usually means that all processes, although may or may not share\n-   an address space, will see the same set of symbols at the same\n-   addresses. */\n-\n-extern int gdbarch_has_global_solist (struct gdbarch *gdbarch);\n-extern void set_gdbarch_has_global_solist (struct gdbarch *gdbarch, int has_global_solist);\n-\n-/* On some targets, even though each inferior has its own private\n-   address space, the debug interface takes care of making breakpoints\n-   visible to all address spaces automatically.  For such cases,\n-   this property should be set to true. */\n-\n-extern int gdbarch_has_global_breakpoints (struct gdbarch *gdbarch);\n-extern void set_gdbarch_has_global_breakpoints (struct gdbarch *gdbarch, int has_global_breakpoints);\n-\n-/* True if inferiors share an address space (e.g., uClinux). */\n-\n-typedef int (gdbarch_has_shared_address_space_ftype) (struct gdbarch *gdbarch);\n-extern int gdbarch_has_shared_address_space (struct gdbarch *gdbarch);\n-extern void set_gdbarch_has_shared_address_space (struct gdbarch *gdbarch, gdbarch_has_shared_address_space_ftype *has_shared_address_space);\n-\n-/* True if a fast tracepoint can be set at an address. */\n-\n-typedef int (gdbarch_fast_tracepoint_valid_at_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr, std::string *msg);\n-extern int gdbarch_fast_tracepoint_valid_at (struct gdbarch *gdbarch, CORE_ADDR addr, std::string *msg);\n-extern void set_gdbarch_fast_tracepoint_valid_at (struct gdbarch *gdbarch, gdbarch_fast_tracepoint_valid_at_ftype *fast_tracepoint_valid_at);\n-\n-/* Guess register state based on tracepoint location.  Used for tracepoints\n-   where no registers have been collected, but there's only one location,\n-   allowing us to guess the PC value, and perhaps some other registers.\n-   On entry, regcache has all registers marked as unavailable. */\n-\n-typedef void (gdbarch_guess_tracepoint_registers_ftype) (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n-extern void gdbarch_guess_tracepoint_registers (struct gdbarch *gdbarch, struct regcache *regcache, CORE_ADDR addr);\n-extern void set_gdbarch_guess_tracepoint_registers (struct gdbarch *gdbarch, gdbarch_guess_tracepoint_registers_ftype *guess_tracepoint_registers);\n-\n-/* Return the \"auto\" target charset. */\n-\n-typedef const char * (gdbarch_auto_charset_ftype) (void);\n-extern const char * gdbarch_auto_charset (struct gdbarch *gdbarch);\n-extern void set_gdbarch_auto_charset (struct gdbarch *gdbarch, gdbarch_auto_charset_ftype *auto_charset);\n-\n-/* Return the \"auto\" target wide charset. */\n-\n-typedef const char * (gdbarch_auto_wide_charset_ftype) (void);\n-extern const char * gdbarch_auto_wide_charset (struct gdbarch *gdbarch);\n-extern void set_gdbarch_auto_wide_charset (struct gdbarch *gdbarch, gdbarch_auto_wide_charset_ftype *auto_wide_charset);\n-\n-/* If non-empty, this is a file extension that will be opened in place\n-   of the file extension reported by the shared library list.\n-  \n-   This is most useful for toolchains that use a post-linker tool,\n-   where the names of the files run on the target differ in extension\n-   compared to the names of the files GDB should load for debug info. */\n-\n-extern const char * gdbarch_solib_symbols_extension (struct gdbarch *gdbarch);\n-extern void set_gdbarch_solib_symbols_extension (struct gdbarch *gdbarch, const char * solib_symbols_extension);\n-\n-/* If true, the target OS has DOS-based file system semantics.  That\n-   is, absolute paths include a drive name, and the backslash is\n-   considered a directory separator. */\n-\n-extern int gdbarch_has_dos_based_file_system (struct gdbarch *gdbarch);\n-extern void set_gdbarch_has_dos_based_file_system (struct gdbarch *gdbarch, int has_dos_based_file_system);\n-\n-/* Generate bytecodes to collect the return address in a frame.\n-   Since the bytecodes run on the target, possibly with GDB not even\n-   connected, the full unwinding machinery is not available, and\n-   typically this function will issue bytecodes for one or more likely\n-   places that the return address may be found. */\n-\n-typedef void (gdbarch_gen_return_address_ftype) (struct gdbarch *gdbarch, struct agent_expr *ax, struct axs_value *value, CORE_ADDR scope);\n-extern void gdbarch_gen_return_address (struct gdbarch *gdbarch, struct agent_expr *ax, struct axs_value *value, CORE_ADDR scope);\n-extern void set_gdbarch_gen_return_address (struct gdbarch *gdbarch, gdbarch_gen_return_address_ftype *gen_return_address);\n-\n-/* Implement the \"info proc\" command. */\n-\n-extern bool gdbarch_info_proc_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_info_proc_ftype) (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n-extern void gdbarch_info_proc (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n-extern void set_gdbarch_info_proc (struct gdbarch *gdbarch, gdbarch_info_proc_ftype *info_proc);\n-\n-/* Implement the \"info proc\" command for core files.  Noe that there\n-   are two \"info_proc\"-like methods on gdbarch -- one for core files,\n-   one for live targets. */\n-\n-extern bool gdbarch_core_info_proc_p (struct gdbarch *gdbarch);\n-\n-typedef void (gdbarch_core_info_proc_ftype) (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n-extern void gdbarch_core_info_proc (struct gdbarch *gdbarch, const char *args, enum info_proc_what what);\n-extern void set_gdbarch_core_info_proc (struct gdbarch *gdbarch, gdbarch_core_info_proc_ftype *core_info_proc);\n-\n-/* Iterate over all objfiles in the order that makes the most sense\n-   for the architecture to make global symbol searches.\n-  \n-   CB is a callback function where OBJFILE is the objfile to be searched,\n-   and CB_DATA a pointer to user-defined data (the same data that is passed\n-   when calling this gdbarch method).  The iteration stops if this function\n-   returns nonzero.\n-  \n-   CB_DATA is a pointer to some user-defined data to be passed to\n-   the callback.\n-  \n-   If not NULL, CURRENT_OBJFILE corresponds to the objfile being\n-   inspected when the symbol search was requested. */\n-\n-typedef void (gdbarch_iterate_over_objfiles_in_search_order_ftype) (struct gdbarch *gdbarch, iterate_over_objfiles_in_search_order_cb_ftype *cb, void *cb_data, struct objfile *current_objfile);\n-extern void gdbarch_iterate_over_objfiles_in_search_order (struct gdbarch *gdbarch, iterate_over_objfiles_in_search_order_cb_ftype *cb, void *cb_data, struct objfile *current_objfile);\n-extern void set_gdbarch_iterate_over_objfiles_in_search_order (struct gdbarch *gdbarch, gdbarch_iterate_over_objfiles_in_search_order_ftype *iterate_over_objfiles_in_search_order);\n-\n-/* Ravenscar arch-dependent ops. */\n-\n-extern struct ravenscar_arch_ops * gdbarch_ravenscar_ops (struct gdbarch *gdbarch);\n-extern void set_gdbarch_ravenscar_ops (struct gdbarch *gdbarch, struct ravenscar_arch_ops * ravenscar_ops);\n-\n-/* Return non-zero if the instruction at ADDR is a call; zero otherwise. */\n-\n-typedef int (gdbarch_insn_is_call_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern int gdbarch_insn_is_call (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_insn_is_call (struct gdbarch *gdbarch, gdbarch_insn_is_call_ftype *insn_is_call);\n-\n-/* Return non-zero if the instruction at ADDR is a return; zero otherwise. */\n-\n-typedef int (gdbarch_insn_is_ret_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern int gdbarch_insn_is_ret (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_insn_is_ret (struct gdbarch *gdbarch, gdbarch_insn_is_ret_ftype *insn_is_ret);\n-\n-/* Return non-zero if the instruction at ADDR is a jump; zero otherwise. */\n-\n-typedef int (gdbarch_insn_is_jump_ftype) (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern int gdbarch_insn_is_jump (struct gdbarch *gdbarch, CORE_ADDR addr);\n-extern void set_gdbarch_insn_is_jump (struct gdbarch *gdbarch, gdbarch_insn_is_jump_ftype *insn_is_jump);\n-\n-/* Return true if there's a program/permanent breakpoint planted in\n-   memory at ADDRESS, return false otherwise. */\n-\n-typedef bool (gdbarch_program_breakpoint_here_p_ftype) (struct gdbarch *gdbarch, CORE_ADDR address);\n-extern bool gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, CORE_ADDR address);\n-extern void set_gdbarch_program_breakpoint_here_p (struct gdbarch *gdbarch, gdbarch_program_breakpoint_here_p_ftype *program_breakpoint_here_p);\n-\n-/* Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n-   Return 0 if *READPTR is already at the end of the buffer.\n-   Return -1 if there is insufficient buffer for a whole entry.\n-   Return 1 if an entry was read into *TYPEP and *VALP. */\n-\n-extern bool gdbarch_auxv_parse_p (struct gdbarch *gdbarch);\n-\n-typedef int (gdbarch_auxv_parse_ftype) (struct gdbarch *gdbarch, gdb_byte **readptr, gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp);\n-extern int gdbarch_auxv_parse (struct gdbarch *gdbarch, gdb_byte **readptr, gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp);\n-extern void set_gdbarch_auxv_parse (struct gdbarch *gdbarch, gdbarch_auxv_parse_ftype *auxv_parse);\n-\n-/* Print the description of a single auxv entry described by TYPE and VAL\n-   to FILE. */\n-\n-typedef void (gdbarch_print_auxv_entry_ftype) (struct gdbarch *gdbarch, struct ui_file *file, CORE_ADDR type, CORE_ADDR val);\n-extern void gdbarch_print_auxv_entry (struct gdbarch *gdbarch, struct ui_file *file, CORE_ADDR type, CORE_ADDR val);\n-extern void set_gdbarch_print_auxv_entry (struct gdbarch *gdbarch, gdbarch_print_auxv_entry_ftype *print_auxv_entry);\n-\n-/* Find the address range of the current inferior's vsyscall/vDSO, and\n-   write it to *RANGE.  If the vsyscall's length can't be determined, a\n-   range with zero length is returned.  Returns true if the vsyscall is\n-   found, false otherwise. */\n-\n-typedef int (gdbarch_vsyscall_range_ftype) (struct gdbarch *gdbarch, struct mem_range *range);\n-extern int gdbarch_vsyscall_range (struct gdbarch *gdbarch, struct mem_range *range);\n-extern void set_gdbarch_vsyscall_range (struct gdbarch *gdbarch, gdbarch_vsyscall_range_ftype *vsyscall_range);\n-\n-/* Allocate SIZE bytes of PROT protected page aligned memory in inferior.\n-   PROT has GDB_MMAP_PROT_* bitmask format.\n-   Throw an error if it is not possible.  Returned address is always valid. */\n-\n-typedef CORE_ADDR (gdbarch_infcall_mmap_ftype) (CORE_ADDR size, unsigned prot);\n-extern CORE_ADDR gdbarch_infcall_mmap (struct gdbarch *gdbarch, CORE_ADDR size, unsigned prot);\n-extern void set_gdbarch_infcall_mmap (struct gdbarch *gdbarch, gdbarch_infcall_mmap_ftype *infcall_mmap);\n-\n-/* Deallocate SIZE bytes of memory at ADDR in inferior from gdbarch_infcall_mmap.\n-   Print a warning if it is not possible. */\n-\n-typedef void (gdbarch_infcall_munmap_ftype) (CORE_ADDR addr, CORE_ADDR size);\n-extern void gdbarch_infcall_munmap (struct gdbarch *gdbarch, CORE_ADDR addr, CORE_ADDR size);\n-extern void set_gdbarch_infcall_munmap (struct gdbarch *gdbarch, gdbarch_infcall_munmap_ftype *infcall_munmap);\n-\n-/* Return string (caller has to use xfree for it) with options for GCC\n-   to produce code for this target, typically \"-m64\", \"-m32\" or \"-m31\".\n-   These options are put before CU's DW_AT_producer compilation options so that\n-   they can override it. */\n-\n-typedef std::string (gdbarch_gcc_target_options_ftype) (struct gdbarch *gdbarch);\n-extern std::string gdbarch_gcc_target_options (struct gdbarch *gdbarch);\n-extern void set_gdbarch_gcc_target_options (struct gdbarch *gdbarch, gdbarch_gcc_target_options_ftype *gcc_target_options);\n-\n-/* Return a regular expression that matches names used by this\n-   architecture in GNU configury triplets.  The result is statically\n-   allocated and must not be freed.  The default implementation simply\n-   returns the BFD architecture name, which is correct in nearly every\n-   case. */\n-\n-typedef const char * (gdbarch_gnu_triplet_regexp_ftype) (struct gdbarch *gdbarch);\n-extern const char * gdbarch_gnu_triplet_regexp (struct gdbarch *gdbarch);\n-extern void set_gdbarch_gnu_triplet_regexp (struct gdbarch *gdbarch, gdbarch_gnu_triplet_regexp_ftype *gnu_triplet_regexp);\n-\n-/* Return the size in 8-bit bytes of an addressable memory unit on this\n-   architecture.  This corresponds to the number of 8-bit bytes associated to\n-   each address in memory. */\n-\n-typedef int (gdbarch_addressable_memory_unit_size_ftype) (struct gdbarch *gdbarch);\n-extern int gdbarch_addressable_memory_unit_size (struct gdbarch *gdbarch);\n-extern void set_gdbarch_addressable_memory_unit_size (struct gdbarch *gdbarch, gdbarch_addressable_memory_unit_size_ftype *addressable_memory_unit_size);\n-\n-/* Functions for allowing a target to modify its disassembler options. */\n-\n-extern const char * gdbarch_disassembler_options_implicit (struct gdbarch *gdbarch);\n-extern void set_gdbarch_disassembler_options_implicit (struct gdbarch *gdbarch, const char * disassembler_options_implicit);\n-\n-extern char ** gdbarch_disassembler_options (struct gdbarch *gdbarch);\n-extern void set_gdbarch_disassembler_options (struct gdbarch *gdbarch, char ** disassembler_options);\n-\n-extern const disasm_options_and_args_t * gdbarch_valid_disassembler_options (struct gdbarch *gdbarch);\n-extern void set_gdbarch_valid_disassembler_options (struct gdbarch *gdbarch, const disasm_options_and_args_t * valid_disassembler_options);\n-\n-/* Type alignment override method.  Return the architecture specific\n-   alignment required for TYPE.  If there is no special handling\n-   required for TYPE then return the value 0, GDB will then apply the\n-   default rules as laid out in gdbtypes.c:type_align. */\n-\n-typedef ULONGEST (gdbarch_type_align_ftype) (struct gdbarch *gdbarch, struct type *type);\n-extern ULONGEST gdbarch_type_align (struct gdbarch *gdbarch, struct type *type);\n-extern void set_gdbarch_type_align (struct gdbarch *gdbarch, gdbarch_type_align_ftype *type_align);\n-\n-/* Return a string containing any flags for the given PC in the given FRAME. */\n-\n-typedef std::string (gdbarch_get_pc_address_flags_ftype) (frame_info *frame, CORE_ADDR pc);\n-extern std::string gdbarch_get_pc_address_flags (struct gdbarch *gdbarch, frame_info *frame, CORE_ADDR pc);\n-extern void set_gdbarch_get_pc_address_flags (struct gdbarch *gdbarch, gdbarch_get_pc_address_flags_ftype *get_pc_address_flags);\n-\n-/* Read core file mappings */\n-\n-typedef void (gdbarch_read_core_file_mappings_ftype) (struct gdbarch *gdbarch, struct bfd *cbfd, read_core_file_mappings_pre_loop_ftype pre_loop_cb, read_core_file_mappings_loop_ftype loop_cb);\n-extern void gdbarch_read_core_file_mappings (struct gdbarch *gdbarch, struct bfd *cbfd, read_core_file_mappings_pre_loop_ftype pre_loop_cb, read_core_file_mappings_loop_ftype loop_cb);\n-extern void set_gdbarch_read_core_file_mappings (struct gdbarch *gdbarch, gdbarch_read_core_file_mappings_ftype *read_core_file_mappings);\n+#include \"gdbarch-gen.h\"\n \n extern struct gdbarch_tdep *gdbarch_tdep (struct gdbarch *gdbarch);\n "
    },
    {
      "sha": "c970c7ae7f1930c8cf82e778036d1f4efbf8ffef",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 72,
      "deletions": 63,
      "changes": 135,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b7c3f1dc0fb7158ec019018d61927f364243fbc/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=2b7c3f1dc0fb7158ec019018d61927f364243fbc",
      "patch": "@@ -1291,7 +1291,7 @@ EOF\n #\n \n exec > new-gdbarch.h\n-copyright\n+copyright | sed 1,3d | grep -v 'was created'\n cat <<EOF\n #ifndef GDBARCH_H\n #define GDBARCH_H\n@@ -1415,71 +1415,11 @@ using read_core_file_mappings_loop_ftype =\n \t\t\t   const char *filename,\n \t\t\t   const bfd_build_id *build_id)>;\n EOF\n-\n-# function typedef's\n-printf \"\\n\"\n-printf \"\\n\"\n-printf \"/* The following are pre-initialized by GDBARCH.  */\\n\"\n-function_list | while do_read\n-do\n-    if class_is_info_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\tprintf \"/* set_gdbarch_%s() - not applicable - pre-initialized.  */\\n\" \"$function\"\n-    fi\n-done\n-\n-# function typedef's\n-printf \"\\n\"\n-printf \"\\n\"\n-printf \"/* The following are initialized by the target dependent code.  */\\n\"\n-function_list | while do_read\n-do\n-    if [ -n \"${comment}\" ]\n-    then\n-\techo \"${comment}\" | sed \\\n-\t    -e '2 s,#,/*,' \\\n-\t    -e '3,$ s,#,  ,' \\\n-\t    -e '$ s,$, */,'\n-    fi\n-\n-    if class_is_predicate_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern bool gdbarch_%s_p (struct gdbarch *gdbarch);\\n\" \"$function\"\n-    fi\n-    if class_is_variable_p\n-    then\n-\tprintf \"\\n\"\n-\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, %s %s);\\n\" \"$function\" \"$returntype\" \"$function\"\n-    fi\n-    if class_is_function_p\n-    then\n-\tprintf \"\\n\"\n-\tif [ \"x${formal}\" = \"xvoid\" ] && class_is_multiarch_p\n-\tthen\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\telif class_is_multiarch_p\n-\tthen\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\telse\n-\t    printf \"typedef %s (gdbarch_%s_ftype) (%s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\tfi\n-\tif [ \"x${formal}\" = \"xvoid\" ]\n-\tthen\n-\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n-\telse\n-\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n-\tfi\n-\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, gdbarch_%s_ftype *%s);\\n\" \"$function\" \"$function\" \"$function\"\n-    fi\n-done\n-\n # close it off\n cat <<EOF\n \n+#include \"gdbarch-gen.h\"\n+\n extern struct gdbarch_tdep *gdbarch_tdep (struct gdbarch *gdbarch);\n \n \n@@ -1718,10 +1658,79 @@ gdbarch_num_cooked_regs (gdbarch *arch)\n \n #endif\n EOF\n+\n exec 1>&2\n ../move-if-change new-gdbarch.h gdbarch.h\n rm -f new-gdbarch.h\n \n+exec > new-gdbarch-gen.h\n+copyright\n+\n+# function typedef's\n+printf \"\\n\"\n+printf \"\\n\"\n+printf \"/* The following are pre-initialized by GDBARCH.  */\\n\"\n+function_list | while do_read\n+do\n+    if class_is_info_p\n+    then\n+\tprintf \"\\n\"\n+\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n+\tprintf \"/* set_gdbarch_%s() - not applicable - pre-initialized.  */\\n\" \"$function\"\n+    fi\n+done\n+\n+# function typedef's\n+printf \"\\n\"\n+printf \"\\n\"\n+printf \"/* The following are initialized by the target dependent code.  */\\n\"\n+function_list | while do_read\n+do\n+    if [ -n \"${comment}\" ]\n+    then\n+\techo \"${comment}\" | sed \\\n+\t    -e '2 s,#,/*,' \\\n+\t    -e '3,$ s,#,  ,' \\\n+\t    -e '$ s,$, */,'\n+    fi\n+\n+    if class_is_predicate_p\n+    then\n+\tprintf \"\\n\"\n+\tprintf \"extern bool gdbarch_%s_p (struct gdbarch *gdbarch);\\n\" \"$function\"\n+    fi\n+    if class_is_variable_p\n+    then\n+\tprintf \"\\n\"\n+\tprintf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n+\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, %s %s);\\n\" \"$function\" \"$returntype\" \"$function\"\n+    fi\n+    if class_is_function_p\n+    then\n+\tprintf \"\\n\"\n+\tif [ \"x${formal}\" = \"xvoid\" ] && class_is_multiarch_p\n+\tthen\n+\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n+\telif class_is_multiarch_p\n+\tthen\n+\t    printf \"typedef %s (gdbarch_%s_ftype) (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n+\telse\n+\t    printf \"typedef %s (gdbarch_%s_ftype) (%s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n+\tfi\n+\tif [ \"x${formal}\" = \"xvoid\" ]\n+\tthen\n+\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch);\\n\" \"$returntype\" \"$function\"\n+\telse\n+\t  printf \"extern %s gdbarch_%s (struct gdbarch *gdbarch, %s);\\n\" \"$returntype\" \"$function\" \"$formal\"\n+\tfi\n+\tprintf \"extern void set_gdbarch_%s (struct gdbarch *gdbarch, gdbarch_%s_ftype *%s);\\n\" \"$function\" \"$function\" \"$function\"\n+    fi\n+done\n+\n+exec 1>&2\n+../move-if-change new-gdbarch-gen.h gdbarch-gen.h\n+rm -f new-gdbarch-gen.h\n+\n \n #\n # C file"
    }
  ]
}