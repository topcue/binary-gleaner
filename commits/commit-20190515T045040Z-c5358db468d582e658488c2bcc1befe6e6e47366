{
  "sha": "c5358db468d582e658488c2bcc1befe6e6e47366",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzUzNThkYjQ2OGQ1ODJlNjU4NDg4YzJiY2MxYmVmZTZlNmU0NzM2Ng==",
  "commit": {
    "author": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-05-15T04:47:16Z"
    },
    "committer": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-05-15T04:50:40Z"
    },
    "message": "GDB (s12z): Improve reliability of the stack unwinder.\n\nPreviously, the stack unwinder searched through consecutive bytes for values\nwhich it thought might be the start of a stack mutating operation.\nThis was error prone, because such bytes could also be the operands of other\ninstructions.  This change uses the opcodes api to interpret the code in each\nframe.\n\ngdb/ChangeLog:\n\t* s12z-tdep.c (push_pull_get_stack_adjustment): New function.\n\t(advance, posn, abstract_read_memory): New functions.\n\t[struct mem_read_abstraction]: New struct.\n\t(s12z_frame_cache): Use opcodes API to interpret stack frame code.",
    "tree": {
      "sha": "c7ace12b2a6359748e31601ff78edbc7a485b9a9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c7ace12b2a6359748e31601ff78edbc7a485b9a9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c5358db468d582e658488c2bcc1befe6e6e47366",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c5358db468d582e658488c2bcc1befe6e6e47366",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c5358db468d582e658488c2bcc1befe6e6e47366",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c5358db468d582e658488c2bcc1befe6e6e47366/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e48371ffd5f89a9ceecd6e814b69e26609fd8402",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e48371ffd5f89a9ceecd6e814b69e26609fd8402",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e48371ffd5f89a9ceecd6e814b69e26609fd8402"
    }
  ],
  "stats": {
    "total": 241,
    "additions": 178,
    "deletions": 63
  },
  "files": [
    {
      "sha": "6c23281d259f3ff5467f87f920d4db032d0033ff",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c5358db468d582e658488c2bcc1befe6e6e47366/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c5358db468d582e658488c2bcc1befe6e6e47366/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c5358db468d582e658488c2bcc1befe6e6e47366",
      "patch": "@@ -1,3 +1,10 @@\n+2019-05-15  John Darrington <john@darrington.wattle.id.au>\n+\n+\t* s12z-tdep.c (push_pull_get_stack_adjustment): New function.\n+\t(advance, posn, abstract_read_memory): New functions.\n+\t[struct mem_read_abstraction]: New struct.\n+\t(s12z_frame_cache): Use opcodes API to interpret stack frame code.\n+\n 2019-05-14  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (coerce_unspec_val_to_type): Only set address when"
    },
    {
      "sha": "b549862e8425969081907872d347756c791076b4",
      "filename": "gdb/s12z-tdep.c",
      "status": "modified",
      "additions": 171,
      "deletions": 63,
      "changes": 234,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c5358db468d582e658488c2bcc1befe6e6e47366/gdb/s12z-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c5358db468d582e658488c2bcc1befe6e6e47366/gdb/s12z-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s12z-tdep.c?ref=c5358db468d582e658488c2bcc1befe6e6e47366",
      "patch": "@@ -30,6 +30,7 @@\n #include \"opcode/s12z.h\"\n #include \"trad-frame.h\"\n #include \"remote.h\"\n+#include \"opcodes/s12z-opc.h\"\n \n /* Two of the registers included in S12Z_N_REGISTERS are\n    the CCH and CCL \"registers\" which are just views into\n@@ -162,6 +163,104 @@ s12z_disassemble_info (struct gdbarch *gdbarch)\n   return di;\n }\n \n+\n+/* A struct (based on mem_read_abstraction_base) to read memory\n+   through the disassemble_info API.  */\n+struct mem_read_abstraction\n+{\n+  struct mem_read_abstraction_base base; /* The parent struct.  */\n+  bfd_vma memaddr;                  /* Where to read from.  */\n+  struct disassemble_info* info;  /* The disassember  to use for reading.  */\n+};\n+\n+/* Advance the reader by one byte.  */\n+static void\n+advance (struct mem_read_abstraction_base *b)\n+{\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n+  mra->memaddr++;\n+}\n+\n+/* Return the current position of the reader.  */\n+static bfd_vma\n+posn (struct mem_read_abstraction_base *b)\n+{\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n+  return mra->memaddr;\n+}\n+\n+/* Read the N bytes at OFFSET  using B.  The bytes read are stored in BYTES.\n+   It is the caller's responsibility to ensure that this is of at least N\n+   in size.  */\n+static int\n+abstract_read_memory (struct mem_read_abstraction_base *b,\n+\t\t      int offset,\n+\t\t      size_t n, bfd_byte *bytes)\n+{\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n+\n+  int status =\n+    (*mra->info->read_memory_func) (mra->memaddr + offset,\n+\t\t\t\t    bytes, n, mra->info);\n+\n+  if (status != 0)\n+    {\n+      (*mra->info->memory_error_func) (status, mra->memaddr, mra->info);\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+\n+/* Return the stack adjustment caused by a push or pull instruction.  */\n+static int\n+push_pull_get_stack_adjustment (int n_operands,\n+\t\t\t\tstruct operand *const *operands)\n+{\n+  int stack_adjustment = 0;\n+  gdb_assert (n_operands > 0);\n+  if (operands[0]->cl == OPND_CL_REGISTER_ALL)\n+    stack_adjustment = 26;  /* All the regs are involved.  */\n+  else if (operands[0]->cl == OPND_CL_REGISTER_ALL16)\n+    stack_adjustment = 4 * 2; /* All four 16 bit regs are involved.  */\n+  else\n+    for (int i = 0; i < n_operands; ++i)\n+      {\n+\tif (operands[i]->cl != OPND_CL_REGISTER)\n+\t  continue; /* I don't think this can ever happen.  */\n+\tconst struct register_operand *op\n+\t  = (const struct register_operand *) operands[i];\n+\tswitch (op->reg)\n+\t  {\n+\t  case REG_X:\n+\t  case REG_Y:\n+\t    stack_adjustment += 3;\n+\t    break;\n+\t  case REG_D7:\n+\t  case REG_D6:\n+\t    stack_adjustment += 4;\n+\t    break;\n+\t  case REG_D2:\n+\t  case REG_D3:\n+\t  case REG_D4:\n+\t  case REG_D5:\n+\t    stack_adjustment += 2;\n+\t    break;\n+\t  case REG_D0:\n+\t  case REG_D1:\n+\t  case REG_CCL:\n+\t  case REG_CCH:\n+\t    stack_adjustment += 1;\n+\t    break;\n+\t  default:\n+\t    gdb_assert_not_reached (\"Invalid register in push/pull operation.\");\n+\t    break;\n+\t  }\n+      }\n+  return stack_adjustment;\n+}\n+\n /* Initialize a prologue cache.  */\n \n static struct trad_frame_cache *\n@@ -234,73 +333,82 @@ s12z_frame_cache (struct frame_info *this_frame, void **prologue_cache)\n   CORE_ADDR addr = start_addr; /* Where we have got to?  */\n   int frame_size = 0;\n   int saved_frame_size = 0;\n-  while (this_pc > addr)\n-    {\n-      struct disassemble_info di = s12z_disassemble_info (gdbarch);\n-\n-      /* No instruction can be more than 11 bytes long, I think.  */\n-      gdb_byte buf[11];\n \n-      int nb = print_insn_s12z (addr, &di);\n-      gdb_assert (nb <= 11);\n+  struct disassemble_info di = s12z_disassemble_info (gdbarch);\n \n-      if (0 != target_read_code (addr, buf, nb))\n-        memory_error (TARGET_XFER_E_IO, addr);\n \n-      if (buf[0] == 0x05)        /* RTS */\n-        {\n-          frame_size = saved_frame_size;\n-        }\n-      /* Conditional Branches.   If any of these are encountered, then\n-         it is likely that a RTS will terminate it.  So we need to save\n-         the frame size so it can be restored.  */\n-      else if ( (buf[0] == 0x02)      /* BRSET */\n-                || (buf[0] == 0x0B)   /* DBcc / TBcc */\n-                || (buf[0] == 0x03))  /* BRCLR */\n-        {\n-          saved_frame_size = frame_size;\n-        }\n-      else if (buf[0] == 0x04)        /* PUL/ PSH .. */\n-        {\n-          bool pull = buf[1] & 0x80;\n-          int stack_adjustment = 0;\n-          if (buf[1] & 0x40)\n-            {\n-              if (buf[1] & 0x01) stack_adjustment += 3;  /* Y */\n-              if (buf[1] & 0x02) stack_adjustment += 3;  /* X */\n-              if (buf[1] & 0x04) stack_adjustment += 4;  /* D7 */\n-              if (buf[1] & 0x08) stack_adjustment += 4;  /* D6 */\n-              if (buf[1] & 0x10) stack_adjustment += 2;  /* D5 */\n-              if (buf[1] & 0x20) stack_adjustment += 2;  /* D4 */\n-            }\n-          else\n-            {\n-              if (buf[1] & 0x01) stack_adjustment += 2;  /* D3 */\n-              if (buf[1] & 0x02) stack_adjustment += 2;  /* D2 */\n-              if (buf[1] & 0x04) stack_adjustment += 1;  /* D1 */\n-              if (buf[1] & 0x08) stack_adjustment += 1;  /* D0 */\n-              if (buf[1] & 0x10) stack_adjustment += 1;  /* CCL */\n-              if (buf[1] & 0x20) stack_adjustment += 1;  /* CCH */\n-            }\n+  struct mem_read_abstraction mra;\n+  mra.base.read = (int (*)(mem_read_abstraction_base*,\n+\t\t\t   int, size_t, bfd_byte*)) abstract_read_memory;\n+  mra.base.advance = advance ;\n+  mra.base.posn = posn;\n+  mra.info = &di;\n \n-          if (!pull)\n-            stack_adjustment = -stack_adjustment;\n-          frame_size -= stack_adjustment;\n-        }\n-      else if (buf[0] == 0x0a)   /* LEA S, (xxx, S) */\n-        {\n-          if (0x06 == (buf[1] >> 4))\n-            {\n-              int simm = (signed char) (buf[1] & 0x0F);\n-              frame_size -= simm;\n-            }\n-        }\n-      else if (buf[0] == 0x1a)   /* LEA S, (S, xxxx) */\n-        {\n-\t  int simm = (signed char) buf[1];\n-\t  frame_size -= simm;\n-        }\n-      addr += nb;\n+  while (this_pc > addr)\n+    {\n+      enum optr optr = OP_INVALID;\n+      short osize;\n+      int n_operands = 0;\n+      struct operand *operands[6];\n+      mra.memaddr = addr;\n+      int n_bytes =\n+\tdecode_s12z (&optr, &osize, &n_operands, operands,\n+\t\t     (mem_read_abstraction_base *) &mra);\n+\n+      switch (optr)\n+\t{\n+\tcase OP_tbNE:\n+\tcase OP_tbPL:\n+\tcase OP_tbMI:\n+\tcase OP_tbGT:\n+\tcase OP_tbLE:\n+\tcase OP_dbNE:\n+\tcase OP_dbEQ:\n+\tcase OP_dbPL:\n+\tcase OP_dbMI:\n+\tcase OP_dbGT:\n+\tcase OP_dbLE:\n+\t  /* Conditional Branches.   If any of these are encountered, then\n+\t     it is likely that a RTS will terminate it.  So we need to save\n+\t     the frame size so it can be restored.  */\n+\t  saved_frame_size = frame_size;\n+\t  break;\n+\tcase OP_rts:\n+\t  /* Restore the frame size from a previously saved value.  */\n+\t  frame_size = saved_frame_size;\n+\t  break;\n+\tcase OP_push:\n+\t  frame_size += push_pull_get_stack_adjustment (n_operands, operands);\n+\t  break;\n+\tcase OP_pull:\n+\t  frame_size -= push_pull_get_stack_adjustment (n_operands, operands);\n+\t  break;\n+\tcase OP_lea:\n+\t  if (operands[0]->cl == OPND_CL_REGISTER)\n+\t    {\n+\t      int reg = ((struct register_operand *) (operands[0]))->reg;\n+\t      if ((reg == REG_S) && (operands[1]->cl == OPND_CL_MEMORY))\n+\t\t{\n+\t\t  const struct memory_operand *mo\n+\t\t    = (const struct memory_operand * ) operands[1];\n+\t\t  if (mo->n_regs == 1 && !mo->indirect\n+\t\t      && mo->regs[0] == REG_S\n+\t\t      && mo->mutation == OPND_RM_NONE)\n+\t\t    {\n+\t\t      /* LEA S, (xxx, S) -- Decrement the stack.   This is\n+\t\t\t almost certainly the start of a frame.  */\n+\t\t      int simm = (signed char)  mo->base_offset;\n+\t\t      frame_size -= simm;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+      addr += n_bytes;\n+      for (int o = 0; o < n_operands; ++o)\n+\tfree (operands[o]);\n     }\n \n   /* If the PC has not actually got to this point, then the frame"
    }
  ]
}