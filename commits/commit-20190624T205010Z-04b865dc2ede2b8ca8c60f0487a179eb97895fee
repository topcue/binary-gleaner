{
  "sha": "04b865dc2ede2b8ca8c60f0487a179eb97895fee",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDRiODY1ZGMyZWRlMmI4Y2E4YzYwZjA0ODdhMTc5ZWI5Nzg5NWZlZQ==",
  "commit": {
    "author": {
      "name": "Jim Wilson",
      "email": "jimw@sifive.com",
      "date": "2019-06-24T20:50:10Z"
    },
    "committer": {
      "name": "Jim Wilson",
      "email": "jimw@sifive.com",
      "date": "2019-06-24T20:50:10Z"
    },
    "message": "RISC-V: Enable lui relaxation for CODE and MERGE sections.\n\n\t2019-06-24  Ilia Diachkov  <ilia.diachkov@optimitech.com>\n\tbfd/\n\t* elfnn-riscv.c (_bfd_riscv_relax_lui): Delete early exit when\n\tSEC_MERGE or SEC_CODE flags are set.\n\t(_bfd_riscv_relax_section): New local symtype.  Set sym_sec and\n\tsymtype consistently.  Don't include sec_addr (sym_sec) in symval.\n\tAdd check for SEC_INFO_TYPE_MERGE and call _bfd_merged_section_offset.\n\tAdd sec_addr (sym_sec) after handling merge sections.",
    "tree": {
      "sha": "90ea8e2ea5857832e6b39f1bbc65a6bba0a07664",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/90ea8e2ea5857832e6b39f1bbc65a6bba0a07664"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/04b865dc2ede2b8ca8c60f0487a179eb97895fee",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04b865dc2ede2b8ca8c60f0487a179eb97895fee",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/04b865dc2ede2b8ca8c60f0487a179eb97895fee",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04b865dc2ede2b8ca8c60f0487a179eb97895fee/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "f93ab3a0b8039a1667a666f013cca50b03d67f9b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f93ab3a0b8039a1667a666f013cca50b03d67f9b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f93ab3a0b8039a1667a666f013cca50b03d67f9b"
    }
  ],
  "stats": {
    "total": 65,
    "additions": 55,
    "deletions": 10
  },
  "files": [
    {
      "sha": "d8cbef1bd1acaf9646f69b843b3a87040b06961e",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04b865dc2ede2b8ca8c60f0487a179eb97895fee/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04b865dc2ede2b8ca8c60f0487a179eb97895fee/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=04b865dc2ede2b8ca8c60f0487a179eb97895fee",
      "patch": "@@ -1,3 +1,12 @@\n+2019-06-24  Ilia Diachkov  <ilia.diachkov@optimitech.com>\n+\n+\t* elfnn-riscv.c (_bfd_riscv_relax_lui): Delete early exit when\n+\tSEC_MERGE or SEC_CODE flags are set.\n+\t(_bfd_riscv_relax_section): New local symtype.  Set sym_sec and\n+\tsymtype consistently.  Don't include sec_addr (sym_sec) in symval.\n+\tAdd check for SEC_INFO_TYPE_MERGE and call _bfd_merged_section_offset.\n+\tAdd sec_addr (sym_sec) after handling merge sections.\n+\n 2019-06-24  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/24721"
    },
    {
      "sha": "003b4f868d99211d9c6c32c85bb567ed6978e273",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 46,
      "deletions": 10,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04b865dc2ede2b8ca8c60f0487a179eb97895fee/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04b865dc2ede2b8ca8c60f0487a179eb97895fee/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=04b865dc2ede2b8ca8c60f0487a179eb97895fee",
      "patch": "@@ -3517,10 +3517,6 @@ _bfd_riscv_relax_lui (bfd *abfd,\n   bfd_vma gp = riscv_global_pointer_value (link_info);\n   int use_rvc = elf_elfheader (abfd)->e_flags & EF_RISCV_RVC;\n \n-  /* Mergeable symbols and code might later move out of range.  */\n-  if (sym_sec->flags & (SEC_MERGE | SEC_CODE))\n-    return TRUE;\n-\n   BFD_ASSERT (rel->r_offset + 4 <= sec->size);\n \n   if (gp)\n@@ -3881,6 +3877,7 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n       relax_func_t relax_func;\n       int type = ELFNN_R_TYPE (rel->r_info);\n       bfd_vma symval;\n+      char symtype;\n \n       relax_func = NULL;\n       if (info->relax_pass == 0)\n@@ -3946,7 +3943,7 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n \t    ? 0 : isym->st_size - rel->r_addend;\n \n \t  if (isym->st_shndx == SHN_UNDEF)\n-\t    sym_sec = sec, symval = sec_addr (sec) + rel->r_offset;\n+\t    sym_sec = sec, symval = rel->r_offset;\n \t  else\n \t    {\n \t      BFD_ASSERT (isym->st_shndx < elf_numsections (abfd));\n@@ -3959,8 +3956,9 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n \t      if (sec_addr (sym_sec) == 0)\n \t\tcontinue;\n #endif\n-\t      symval = sec_addr (sym_sec) + isym->st_value;\n+\t      symval = isym->st_value;\n \t    }\n+\t  symtype = ELF_ST_TYPE (isym->st_info);\n \t}\n       else\n \t{\n@@ -3975,21 +3973,59 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n \t    h = (struct elf_link_hash_entry *) h->root.u.i.link;\n \n \t  if (h->plt.offset != MINUS_ONE)\n-\t    symval = sec_addr (htab->elf.splt) + h->plt.offset;\n+\t    {\n+\t      sym_sec = htab->elf.splt;\n+\t      symval = h->plt.offset;\n+\t    }\n \t  else if (h->root.u.def.section->output_section == NULL\n \t\t   || (h->root.type != bfd_link_hash_defined\n \t\t       && h->root.type != bfd_link_hash_defweak))\n \t    continue;\n \t  else\n-\t    symval = sec_addr (h->root.u.def.section) + h->root.u.def.value;\n+\t    {\n+\t      symval = h->root.u.def.value;\n+\t      sym_sec = h->root.u.def.section;\n+\t    }\n \n \t  if (h->type != STT_FUNC)\n \t    reserve_size =\n \t      (h->size - rel->r_addend) > h->size ? 0 : h->size - rel->r_addend;\n-\t  sym_sec = h->root.u.def.section;\n+\t  symtype = h->type;\n \t}\n \n-      symval += rel->r_addend;\n+      if (sym_sec->sec_info_type == SEC_INFO_TYPE_MERGE\n+          && (sym_sec->flags & SEC_MERGE))\n+\t{\n+\t  /* At this stage in linking, no SEC_MERGE symbol has been\n+\t     adjusted, so all references to such symbols need to be\n+\t     passed through _bfd_merged_section_offset.  (Later, in\n+\t     relocate_section, all SEC_MERGE symbols *except* for\n+\t     section symbols have been adjusted.)\n+\n+\t     gas may reduce relocations against symbols in SEC_MERGE\n+\t     sections to a relocation against the section symbol when\n+\t     the original addend was zero.  When the reloc is against\n+\t     a section symbol we should include the addend in the\n+\t     offset passed to _bfd_merged_section_offset, since the\n+\t     location of interest is the original symbol.  On the\n+\t     other hand, an access to \"sym+addend\" where \"sym\" is not\n+\t     a section symbol should not include the addend;  Such an\n+\t     access is presumed to be an offset from \"sym\";  The\n+\t     location of interest is just \"sym\".  */\n+\t   if (symtype == STT_SECTION)\n+\t     symval += rel->r_addend;\n+\n+\t   symval = _bfd_merged_section_offset (abfd, &sym_sec,\n+\t\t\t\t\t\telf_section_data (sym_sec)->sec_info,\n+\t\t\t\t\t\tsymval);\n+\n+\t   if (symtype != STT_SECTION)\n+\t     symval += rel->r_addend;\n+\t}\n+      else\n+\tsymval += rel->r_addend;\n+\n+      symval += sec_addr (sym_sec);\n \n       if (!relax_func (abfd, sec, sym_sec, info, rel, symval,\n \t\t       max_alignment, reserve_size, again,"
    }
  ]
}