{
  "sha": "abf516c6931af1683d1e51203de1ca01467f9f85",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWJmNTE2YzY5MzFhZjE2ODNkMWU1MTIwM2RlMWNhMDE0NjdmOWY4NQ==",
  "commit": {
    "author": {
      "name": "Ulrich Weigand",
      "email": "ulrich.weigand@de.ibm.com",
      "date": "2019-09-20T21:06:57Z"
    },
    "committer": {
      "name": "Ulrich Weigand",
      "email": "ulrich.weigand@de.ibm.com",
      "date": "2019-09-20T21:06:57Z"
    },
    "message": "Remove Cell Broadband Engine debugging support\n\nThis patch implements removal of Cell/B.E. support, including\n- Support for the spu-*-* target\n- Support for native stand-alone SPU debugging\n- Support for integrated debugging of combined PPU/SPU applications\n- Remote debugging (gdbserver) support for all the above.\n\nThe patch also removes the TARGET_OBJECT_SPU target object type,\nas this is available only on Cell/B.E. targets, including\n- Native Linux support\n- Core file support (including core file generation)\n- Remote target support, including removal of the qXfer:spu:read\n  and qXfer:spu:write remote protocal packets and associated\n  support in gdbserver.\n\ngdb/ChangeLog\n2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* NEWS: Mention that Cell/B.E. debugging support was removed.\n\t* MAINTAINERS: Remove spu target.\n\n\t* config/djgpp/fnchange.lst: Remove entries for removed files.\n\n\t* Makefile.in (ALL_TARGET_OBS): Remove solib-spu.o,\n\tspu-multiarch.o, and spu-tdep.o.\n\t(HFILES_NO_SRCDIR): Remove solib-spu.h and spu-tdep.h.\n\t(ALLDEPFILES): Remove solib-spu.c, spu-linux-nat.c,\n\tspu-multiarch.c, and spu-tdep.c.\n\t* spu-linux-nat.c: Remove file.\n\t* spu-multiarch.c: Remove file.\n\t* spu-tdep.c: Remove file.\n\t* spu-tdep.h: Remove file.\n\t* solib-spu.c: Remove file.\n\t* solib-spu.h: Remove file.\n\n\t* configure.host (powerpc64*-*-linux*): Remove Cell/B.E. support.\n\t* configure.nat (spu-linux): Remove.\n\t* configure.tgt (powerpc*-*-linux*): Remove solib-spu.o and\n\tsolib-multiarch.o from gdb_target_obs.\n\t(spu*-*-*): Remove.\n\n\t* arch/ppc-linux-common.h (struct ppc_linux_features): Remove \"cell\"\n\tfeature flag.\n\t(ppc_linux_no_features): Update.\n\t* arch/ppc-linux-common.c (ppc_linux_match_description): Remove\n\tCell/B.E. support.\n\t* arch/ppc-linux-tdesc.h (tdesc_powerpc_cell32l): Remove declaration.\n\t(tdesc_powerpc_cell64l): Likewise.\n\t* nat/ppc-linux.h (PPC_FEATURE_CELL): Remove.\n\t* ppc-linux-nat.c (ppc_linux_nat_target::read_description): Remove\n\tCell/B.E. support.\n\t* ppc-linux-tdep.h: Do not include \"solib-spu.h\" or \"spu-tdep.h\".\n\tDo not include \"features/rs6000/powerpc-cell32l.c\" or\n\t\"features/rs6000/powerpc-cell64l.c\".\n\t(ppc_linux_spu_section): Remove.\n\t(ppc_linux_core_read_description): Remove Cell/B.E. support.\n\t(spe_context_objfile, spe_context_lm_addr, spe_context_offset,\n\tspe_context_cache_ptid, spe_context_cache_ptid): Remove.\n\t(ppc_linux_spe_context_lookup): Remove.\n\t(ppc_linux_spe_context_inferior_created): Remove.\n\t(ppc_linux_spe_context_solib_loaded): Remove.\n\t(ppc_linux_spe_context_solib_unloaded): Remove.\n\t(ppc_linux_spe_context): Remove.\n\t(struct ppu2spu_cache): Remove.\n\t(ppu2spu_prev_arch, ppu2spu_this_id, ppu2spu_prev_register): Remove.\n\t(struct ppu2spu_data): Remove.\n\t(ppu2spu_unwind_register, ppu2spu_sniffer, ppu2spu_dealloc_cache,\n\tppu2spu_unwind): Remove.\n\t(ppc_linux_init_abi): Remove Cell/B.E. support.\n\t* rs6000-tdep.h (rs6000_gdbarch_init): Remove Cell/B.E. support.\n\n\t* features/Makefile (rs6000/powerpc-cell32l-expedite): Remove.\n\t(rs6000/powerpc-cell64l-expedite): Likewise\n\t(WHICH): Remove rs6000/powerpc-cell32l and rs6000/powerpc-cell64l.\n\t(XMLTOC): Remove rs6000/powerpc-cell32l.xml and\n\trs6000/powerpc-cell64l.xml.\n\t* features/rs6000/powerpc-cell32l.xml: Remove.\n\t* features/rs6000/powerpc-cell64l.xml: Likewise.\n\t* features/rs6000/powerpc-cell32l.c: Remove generated file.\n\t* features/rs6000/powerpc-cell64l.c: Likewise.\n\t* regformats/rs6000/powerpc-cell32l.dat: Remove generated file.\n\t* regformats/rs6000/powerpc-cell64l.dat: Likewise.\n\t* regformats/reg-spu.dat: Remove.\n\n\t* target.h (enum target_object): Remove TARGET_OBJECT_SPU.\n\t* corelow.c (struct spuid_list): Remove.\n\t(add_to_spuid_list): Remove.\n\t(core_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n\t* remote.c (PACKET_qXfer_spu_read, PACKET_qXfer_spu_write): Remove.\n\t(remote_protocol_features): Remove associated entries.\n\t(_initialize_remote): No longer initialize them.\n\t(remote_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n\t* linux-nat.c (SPUFS_MAGIC): Remove.\n\t(linux_proc_xfer_spu): Remove.\n\t(spu_enumerate_spu_ids): Remove.\n\t(linux_nat_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n\t* linux-tdep.c (-linux_spu_make_corefile_notes): Remove.\n\t(linux_make_corefile_notes): No longer call it.\n\n\t* regcache.c (cooked_read_test): Remove bfd_arch_spu special case.\n\t(cooked_write_test): Likewise.\n\ngdb/doc/ChangeLog\n2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* doc/gdb.texinfo (Remote Configuration): Remove documentation for\n\tqXfer:spu:read and qXfer:spu:write.\n\t(General Query Packets): Likewise.\n\t(Cell Broadband Engine SPU architecture): Remove subsection.\n\ngdb/gdbserver/ChangeLog\n2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* configure.srv (ipa_ppc_linux_regobj): Remove powerpc-cell32l-ipa.o\n\tand powerpc-cell64l-ipa.o.\n\t(powerpc*-*-linux*): Remove powerpc-cell32l.o and powerpc-cell64l.o\n\tfrom srv_regobj.  Remove rs6000/powerpc-cell32l.xml and\n\trs6000/powerpc-cell64l.xml from srv_xmlfiles.\n\t(spu*-*-*): Remove.\n\n\t* spu-low.c: Remove file.\n\n\t* linux-ppc-low.c (INSTR_SC, NR_spu_run): Remove.\n\t(parse_spufs_run): Remove.\n\t(ppc_get_pc): Remove Cell/B.E. support.\n\t(ppc_set_pc): Likewise.\n\t(ppc_breakpoint_at): Likewise.\n\t(ppc_arch_setup): Likewise.\n\t(ppc_get_ipa_tdesc_idx): Do not handle tdesc_powerpc_cell64l or\n\ttdesc_powerpc_cell32l.\n\t(initialize_low_arch): Do not call init_registers_powerpc_cell64l\n\tor init_registers_powerpc_cell32l.\n\t* linux-ppc-ipa.c (get_ipa_tdesc): Do not handle PPC_TDESC_CELL.\n\t(initialize_low_tracepoint): Do not call init_registers_powerpc_cell64l\n\tor init_registers_powerpc_cell32l.\n\t* linux-ppc-tdesc-init.h (PPC_TDESC_CELL): Mark as unused.\n\t(init_registers_powerpc_cell32l): Remove prototype.\n\t(init_registers_powerpc_cell64l): Likewise.\n\n\t* target.h (struct target_ops): Remove qxfer_spu member.\n\t* server.c (handle_qxfer_spu): Remove.\n\t(qxfer_packets): Remove entry for \"spu\".\n\t(handle_query): No longer support qXfer:spu:read or qXfer:spu:write.\n\t* linux-low.c (SPUFS_MAGIC): Remove.\n\t(spu_enumerate_spu_ids): Remove.\n\t(linux_qxfer_spu): Remove.\n\t(linux_target_ops): Remove qxfer_spu member.\n\t* lynx-low.c (lynx_target_ops): Remove qxfer_spu member.\n\t* nto-low.c (nto_target_ops): Remove qxfer_spu member.\n\t* win32-low.c (win32_target_ops): Remove qxfer_spu member.\n\ngdb/testsuite/ChangeLog\n2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n\n\t* gdb.arch/spu-info.exp: Remove file.\n\t* gdb.arch/spu-info.c: Remove file.\n\t* gdb.arch/spu-ls.exp: Remove file.\n\t* gdb.arch/spu-ls.c: Remove file.\n\n\t* gdb.asm/asm-source.exp: Remove support for spu*-*-*.\n\t* gdb.asm/spu.inc: Remove file.\n\n\t* gdb.base/dump.exp: Remove support for spu*-*-*.\n\t* gdb.base/stack-checking.exp: Likewise.\n\t* gdb.base/overlays.exp: Likewise.\n\t* gdb.base/ovlymgr.c: Likewise.\n\t* gdb.base/spu.ld: Remove file.\n\n\t* gdb.cp/bs15503.exp: Remove support for spu*-*-*.\n\t* gdb.cp/cpexprs.exp: Likewise.\n\t* gdb.cp/exception.exp: Likewise.\n\t* gdb.cp/gdb2495.exp: Likewise.\n\t* gdb.cp/mb-templates.exp: Likewise.\n\t* gdb.cp/pr9167.exp: Likewise.\n\t* gdb.cp/userdef.exp: Likewise.\n\n\t* gdb.xml/tdesc-regs.exp: Remove support for spu*-*-*.\n\n\t* gdb.cell: Remove directory.\n\t* lib/cell.exp: Remove file.",
    "tree": {
      "sha": "f2d4e09a3840ac22f5af5584348fbdf97e0c8aca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f2d4e09a3840ac22f5af5584348fbdf97e0c8aca"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/abf516c6931af1683d1e51203de1ca01467f9f85",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abf516c6931af1683d1e51203de1ca01467f9f85",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/abf516c6931af1683d1e51203de1ca01467f9f85",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abf516c6931af1683d1e51203de1ca01467f9f85/comments",
  "author": {
    "login": "uweigand",
    "id": 4154057,
    "node_id": "MDQ6VXNlcjQxNTQwNTc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4154057?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/uweigand",
    "html_url": "https://github.com/uweigand",
    "followers_url": "https://api.github.com/users/uweigand/followers",
    "following_url": "https://api.github.com/users/uweigand/following{/other_user}",
    "gists_url": "https://api.github.com/users/uweigand/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/uweigand/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/uweigand/subscriptions",
    "organizations_url": "https://api.github.com/users/uweigand/orgs",
    "repos_url": "https://api.github.com/users/uweigand/repos",
    "events_url": "https://api.github.com/users/uweigand/events{/privacy}",
    "received_events_url": "https://api.github.com/users/uweigand/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "uweigand",
    "id": 4154057,
    "node_id": "MDQ6VXNlcjQxNTQwNTc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4154057?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/uweigand",
    "html_url": "https://github.com/uweigand",
    "followers_url": "https://api.github.com/users/uweigand/followers",
    "following_url": "https://api.github.com/users/uweigand/following{/other_user}",
    "gists_url": "https://api.github.com/users/uweigand/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/uweigand/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/uweigand/subscriptions",
    "organizations_url": "https://api.github.com/users/uweigand/orgs",
    "repos_url": "https://api.github.com/users/uweigand/repos",
    "events_url": "https://api.github.com/users/uweigand/events{/privacy}",
    "received_events_url": "https://api.github.com/users/uweigand/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a"
    }
  ],
  "stats": {
    "total": 11474,
    "additions": 189,
    "deletions": 11285
  },
  "files": [
    {
      "sha": "9c8cebaf6fdec9690ecb65fd83cc0d4ebbae34ae",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1,3 +1,89 @@\n+2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* NEWS: Mention that Cell/B.E. debugging support was removed.\n+\t* MAINTAINERS: Remove spu target.\n+\n+\t* config/djgpp/fnchange.lst: Remove entries for removed files.\n+\n+\t* Makefile.in (ALL_TARGET_OBS): Remove solib-spu.o,\n+\tspu-multiarch.o, and spu-tdep.o.\n+\t(HFILES_NO_SRCDIR): Remove solib-spu.h and spu-tdep.h.\n+\t(ALLDEPFILES): Remove solib-spu.c, spu-linux-nat.c,\n+\tspu-multiarch.c, and spu-tdep.c.\n+\t* spu-linux-nat.c: Remove file.\n+\t* spu-multiarch.c: Remove file.\n+\t* spu-tdep.c: Remove file.\n+\t* spu-tdep.h: Remove file.\n+\t* solib-spu.c: Remove file.\n+\t* solib-spu.h: Remove file.\n+\n+\t* configure.host (powerpc64*-*-linux*): Remove Cell/B.E. support.\n+\t* configure.nat (spu-linux): Remove.\n+\t* configure.tgt (powerpc*-*-linux*): Remove solib-spu.o and\n+\tsolib-multiarch.o from gdb_target_obs.\n+\t(spu*-*-*): Remove.\n+\n+\t* arch/ppc-linux-common.h (struct ppc_linux_features): Remove \"cell\"\n+\tfeature flag.\n+\t(ppc_linux_no_features): Update.\n+\t* arch/ppc-linux-common.c (ppc_linux_match_description): Remove\n+\tCell/B.E. support.\n+\t* arch/ppc-linux-tdesc.h (tdesc_powerpc_cell32l): Remove declaration.\n+\t(tdesc_powerpc_cell64l): Likewise.\n+\t* nat/ppc-linux.h (PPC_FEATURE_CELL): Remove.\n+\t* ppc-linux-nat.c (ppc_linux_nat_target::read_description): Remove\n+\tCell/B.E. support.\n+\t* ppc-linux-tdep.h: Do not include \"solib-spu.h\" or \"spu-tdep.h\".\n+\tDo not include \"features/rs6000/powerpc-cell32l.c\" or\n+\t\"features/rs6000/powerpc-cell64l.c\".\n+\t(ppc_linux_spu_section): Remove.\n+\t(ppc_linux_core_read_description): Remove Cell/B.E. support.\n+\t(spe_context_objfile, spe_context_lm_addr, spe_context_offset,\n+\tspe_context_cache_ptid, spe_context_cache_ptid): Remove.\n+\t(ppc_linux_spe_context_lookup): Remove.\n+\t(ppc_linux_spe_context_inferior_created): Remove.\n+\t(ppc_linux_spe_context_solib_loaded): Remove.\n+\t(ppc_linux_spe_context_solib_unloaded): Remove.\n+\t(ppc_linux_spe_context): Remove.\n+\t(struct ppu2spu_cache): Remove.\n+\t(ppu2spu_prev_arch, ppu2spu_this_id, ppu2spu_prev_register): Remove.\n+\t(struct ppu2spu_data): Remove.\n+\t(ppu2spu_unwind_register, ppu2spu_sniffer, ppu2spu_dealloc_cache,\n+\tppu2spu_unwind): Remove.\n+\t(ppc_linux_init_abi): Remove Cell/B.E. support.\n+\t* rs6000-tdep.h (rs6000_gdbarch_init): Remove Cell/B.E. support.\n+\n+\t* features/Makefile (rs6000/powerpc-cell32l-expedite): Remove.\n+\t(rs6000/powerpc-cell64l-expedite): Likewise\n+\t(WHICH): Remove rs6000/powerpc-cell32l and rs6000/powerpc-cell64l.\n+\t(XMLTOC): Remove rs6000/powerpc-cell32l.xml and\n+\trs6000/powerpc-cell64l.xml.\n+\t* features/rs6000/powerpc-cell32l.xml: Remove.\n+\t* features/rs6000/powerpc-cell64l.xml: Likewise.\n+\t* features/rs6000/powerpc-cell32l.c: Remove generated file.\n+\t* features/rs6000/powerpc-cell64l.c: Likewise.\n+\t* regformats/rs6000/powerpc-cell32l.dat: Remove generated file.\n+\t* regformats/rs6000/powerpc-cell64l.dat: Likewise.\n+\t* regformats/reg-spu.dat: Remove.\n+\n+\t* target.h (enum target_object): Remove TARGET_OBJECT_SPU.\n+\t* corelow.c (struct spuid_list): Remove.\n+\t(add_to_spuid_list): Remove.\n+\t(core_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n+\t* remote.c (PACKET_qXfer_spu_read, PACKET_qXfer_spu_write): Remove.\n+\t(remote_protocol_features): Remove associated entries.\n+\t(_initialize_remote): No longer initialize them.\n+\t(remote_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n+\t* linux-nat.c (SPUFS_MAGIC): Remove.\n+\t(linux_proc_xfer_spu): Remove.\n+\t(spu_enumerate_spu_ids): Remove.\n+\t(linux_nat_target::xfer_partial): Remove support for TARGET_OBJECT_SPU.\n+\t* linux-tdep.c (-linux_spu_make_corefile_notes): Remove.\n+\t(linux_make_corefile_notes): No longer call it.\n+\n+\t* regcache.c (cooked_read_test): Remove bfd_arch_spu special case.\n+\t(cooked_write_test): Likewise.\n+\n 2019-09-20  Tom Tromey  <tom@tromey.com>\n \n \t* NEWS: Mention case-sensitivity of TUI commands."
    },
    {
      "sha": "3efcb714707142eb313e98eb98934a6098ed23e4",
      "filename": "gdb/MAINTAINERS",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/MAINTAINERS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/MAINTAINERS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/MAINTAINERS?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -319,9 +319,6 @@ the native maintainer when resolving ABI issues.\n \tsparc\t\t--target=sparc64-solaris2.10 ,-Werror\n \t\t\t(--target=sparc-elf broken)\n \n-\tspu\t\t--target=spu-elf ,-Werror\n-\t\t\tUlrich Weigand\t\tuweigand@de.ibm.com\n-\n \ttic6x\t\t--target=tic6x-elf ,-Werror\n \t\t\tYao Qi\t\t\tqiyao@sourceware.org\n "
    },
    {
      "sha": "877a9ccd6bd727056d6288e1c277af0fea5ea3f3",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -776,16 +776,13 @@ ALL_TARGET_OBS = \\\n \tsolib-darwin.o \\\n \tsolib-dsbt.o \\\n \tsolib-frv.o \\\n-\tsolib-spu.o \\\n \tsolib-svr4.o \\\n \tsparc-linux-tdep.o \\\n \tsparc-nbsd-tdep.o \\\n \tsparc-obsd-tdep.o \\\n \tsparc-ravenscar-thread.o \\\n \tsparc-sol2-tdep.o \\\n \tsparc-tdep.o \\\n-\tspu-multiarch.o \\\n-\tspu-tdep.o \\\n \tsymfile-mem.o \\\n \ttic6x-linux-tdep.o \\\n \ttic6x-tdep.o \\\n@@ -1382,7 +1379,6 @@ HFILES_NO_SRCDIR = \\\n \tsolib.h \\\n \tsolib-aix.h \\\n \tsolib-darwin.h \\\n-\tsolib-spu.h \\\n \tsolib-svr4.h \\\n \tsolib-target.h \\\n \tsolist.h \\\n@@ -1392,7 +1388,6 @@ HFILES_NO_SRCDIR = \\\n \tsparc-ravenscar-thread.h \\\n \tsparc-tdep.h \\\n \tsparc64-tdep.h \\\n-\tspu-tdep.h \\\n \tstabsread.h \\\n \tstack.h \\\n \tstap-probe.h \\\n@@ -2304,7 +2299,6 @@ ALLDEPFILES = \\\n \tsh-tdep.c \\\n \tsol2-tdep.c \\\n \tsolib-aix.c \\\n-\tsolib-spu.c \\\n \tsolib-svr4.c \\\n \tsparc-linux-nat.c \\\n \tsparc-linux-tdep.c \\\n@@ -2327,9 +2321,6 @@ ALLDEPFILES = \\\n \tsparc64-obsd-tdep.c \\\n \tsparc64-sol2-tdep.c \\\n \tsparc64-tdep.c \\\n-\tspu-linux-nat.c \\\n-\tspu-multiarch.c \\\n-\tspu-tdep.c \\\n \ttilegx-linux-nat.c \\\n \ttilegx-linux-tdep.c \\\n \ttilegx-tdep.c \\"
    },
    {
      "sha": "35b48d9cb3013d3d9e92611bcfd9fed8c426abb9",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -330,6 +330,12 @@ focus, winheight, +, -, >, <\n   from .inputrc to bind keys in this keymap.  This feature is only\n   available when gdb is built against GNU readline 8.0 or later.\n \n+* Removed targets and native configurations\n+\n+  GDB no longer supports debugging the Cell Broadband Engine.  This includes\n+  both debugging standalone Cell/B.E. SPU applications and integrated debugging\n+  of Cell/B.E. applications that use both the PPU and SPU architectures.\n+\n *** Changes in GDB 8.3\n \n * GDB and GDBserver now support access to additional registers on"
    },
    {
      "sha": "20b35807460ce5428e1ca6e2971026e7844a427b",
      "filename": "gdb/arch/ppc-linux-common.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-common.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-common.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/ppc-linux-common.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -50,9 +50,7 @@ ppc_linux_match_description (struct ppc_linux_features features)\n \n   if (features.wordsize == 8)\n     {\n-      if (features.cell)\n-\ttdesc = tdesc_powerpc_cell64l;\n-      else if (features.vsx)\n+      if (features.vsx)\n \ttdesc = (features.htm? tdesc_powerpc_isa207_htm_vsx64l\n \t\t : features.isa207? tdesc_powerpc_isa207_vsx64l\n \t\t : features.ppr_dscr? tdesc_powerpc_isa205_ppr_dscr_vsx64l\n@@ -69,9 +67,7 @@ ppc_linux_match_description (struct ppc_linux_features features)\n     {\n       gdb_assert (features.wordsize == 4);\n \n-      if (features.cell)\n-\ttdesc = tdesc_powerpc_cell32l;\n-      else if (features.vsx)\n+      if (features.vsx)\n \ttdesc = (features.htm? tdesc_powerpc_isa207_htm_vsx32l\n \t\t : features.isa207? tdesc_powerpc_isa207_vsx32l\n \t\t : features.ppr_dscr? tdesc_powerpc_isa205_ppr_dscr_vsx32l"
    },
    {
      "sha": "1f91ff0576ea669a648f9ade556c25663ef48a5b",
      "filename": "gdb/arch/ppc-linux-common.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-common.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-common.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/ppc-linux-common.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -58,7 +58,6 @@ struct ppc_linux_features\n   bool ppr_dscr;\n   bool isa207;\n   bool htm;\n-  bool cell;\n };\n \n /* Base value for ppc_linux_features variables.  */\n@@ -70,7 +69,6 @@ const struct ppc_linux_features ppc_linux_no_features = {\n   false,\n   false,\n   false,\n-  false,\n };\n \n /* Return a target description that matches FEATURES.  */"
    },
    {
      "sha": "5014131b6e7ca3c0d444c76bd7b1b3e963005774",
      "filename": "gdb/arch/ppc-linux-tdesc.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-tdesc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/arch/ppc-linux-tdesc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/ppc-linux-tdesc.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -24,7 +24,6 @@ struct target_desc;\n \n extern struct target_desc *tdesc_powerpc_32l;\n extern struct target_desc *tdesc_powerpc_altivec32l;\n-extern struct target_desc *tdesc_powerpc_cell32l;\n extern struct target_desc *tdesc_powerpc_vsx32l;\n extern struct target_desc *tdesc_powerpc_isa205_32l;\n extern struct target_desc *tdesc_powerpc_isa205_altivec32l;\n@@ -36,7 +35,6 @@ extern struct target_desc *tdesc_powerpc_e500l;\n \n extern struct target_desc *tdesc_powerpc_64l;\n extern struct target_desc *tdesc_powerpc_altivec64l;\n-extern struct target_desc *tdesc_powerpc_cell64l;\n extern struct target_desc *tdesc_powerpc_vsx64l;\n extern struct target_desc *tdesc_powerpc_isa205_64l;\n extern struct target_desc *tdesc_powerpc_isa205_altivec64l;"
    },
    {
      "sha": "7608218dbc1c933b1d0376b7368e72aa236d12d3",
      "filename": "gdb/config/djgpp/fnchange.lst",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/config/djgpp/fnchange.lst",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/config/djgpp/fnchange.lst",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/config/djgpp/fnchange.lst?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -199,8 +199,6 @@\n @V@/gdb/features/rs6000/powerpc-vsx32l.c @V@/gdb/features/rs6000/ppc-v32l.c\n @V@/gdb/features/rs6000/powerpc-vsx64.c @V@/gdb/features/rs6000/ppc-v64.c\n @V@/gdb/features/rs6000/powerpc-vsx64l.c @V@/gdb/features/rs6000/ppc-v64l.c\n-@V@/gdb/features/rs6000/powerpc-cell32l.c @V@/gdb/features/rs6000/ppc-c32l.c\n-@V@/gdb/features/rs6000/powerpc-cell64l.c @V@/gdb/features/rs6000/ppc-c64l.c\n @V@/gdb/features/rs6000/powerpc-32.xml @V@/gdb/features/rs6000/ppc-32.xml\n @V@/gdb/features/rs6000/powerpc-32l.xml @V@/gdb/features/rs6000/ppc-32l.xml\n @V@/gdb/features/rs6000/powerpc-403.xml @V@/gdb/features/rs6000/ppc-403.xml\n@@ -231,8 +229,6 @@\n @V@/gdb/features/rs6000/powerpc-vsx32l.xml @V@/gdb/features/rs6000/ppc-v32l.xml\n @V@/gdb/features/rs6000/powerpc-vsx64.xml @V@/gdb/features/rs6000/ppc-v64.xml\n @V@/gdb/features/rs6000/powerpc-vsx64l.xml @V@/gdb/features/rs6000/ppc-v64l.xml\n-@V@/gdb/features/rs6000/powerpc-cell32l.xml @V@/gdb/features/rs6000/ppc-c32l.xml\n-@V@/gdb/features/rs6000/powerpc-cell64l.xml @V@/gdb/features/rs6000/ppc-c64l.xml\n @V@/gdb/features/i386/amd64-avx-linux.c @V@/gdb/features/i386/a64-al.c\n @V@/gdb/features/i386/amd64-avx.c @V@/gdb/features/i386/a64-a.c\n @V@/gdb/features/i386/amd64-avx-linux.xml @V@/gdb/features/i386/a64-al.xml\n@@ -356,8 +352,6 @@\n @V@/gdb/regformats/rs6000/powerpc-isa205-vsx64l.dat @V@/gdb/regformats/rs6000/ppciv64l.dat\n @V@/gdb/regformats/rs6000/powerpc-vsx32l.dat @V@/gdb/regformats/rs6000/ppc-v32l.dat\n @V@/gdb/regformats/rs6000/powerpc-vsx64l.dat @V@/gdb/regformats/rs6000/ppc-v64l.dat\n-@V@/gdb/regformats/rs6000/powerpc-cell32l.dat @V@/gdb/regformats/rs6000/ppc-c32l.dat\n-@V@/gdb/regformats/rs6000/powerpc-cell64l.dat @V@/gdb/regformats/rs6000/ppc-c64l.dat\n @V@/gdb/regformats/tic6x-c62x.dat @V@/gdb/regformats/c6x-62x.dat\n @V@/gdb/regformats/tic6x-c64x.dat @V@/gdb/regformats/c6x-64x.dat\n @V@/gdb/regformats/tic6x-c64xp.dat @V@/gdb/regformats/c6xc64xp.dat\n@@ -452,9 +446,6 @@\n @V@/gdb/testsuite/gdb.base/watchpoint-cond-gone.exp @V@/gdb/testsuite/gdb.base/wpcondg.exp\n @V@/gdb/testsuite/gdb.base/watchpoint-cond-gone.c @V@/gdb/testsuite/gdb.base/wpcondg.c\n @V@/gdb/testsuite/gdb.base/watchpoint-cond-gone-stripped.c @V@/gdb/testsuite/gdb.base/wpcondgs.c\n-@V@/gdb/testsuite/gdb.cell/coremaker-spu.c @V@/gdb/testsuite/gdb.cell/core-spu.c\n-@V@/gdb/testsuite/gdb.cell/ea-cache-spu.c @V@/gdb/testsuite/gdb.cell/ea-spu.c\n-@V@/gdb/testsuite/gdb.cell/mem-access-spu.c @V@/gdb/testsuite/gdb.cell/mem-spu.c\n @V@/gdb/testsuite/gdb.cp/m-static1.cc @V@/gdb/testsuite/gdb.cp/m-stat1.cc\n @V@/gdb/testsuite/gdb.cp/namespace1.cc @V@/gdb/testsuite/gdb.cp/namesp1.cc\n @V@/gdb/testsuite/gdb.cp/namespace-nested-import.cc @V@/gdb/testsuite/gdb.cp/nnested.cc"
    },
    {
      "sha": "f382cad1a84393cb6b8bf27abe6cc9b0b76e7e01",
      "filename": "gdb/configure.host",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.host",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.host",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.host?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -140,13 +140,7 @@ powerpc-*-netbsd* | powerpc-*-knetbsd*-gnu)\n \t\t\tgdb_host=nbsd ;;\n powerpc-*-openbsd*)\tgdb_host=obsd ;;\n \n-powerpc64*-*-linux*)\tgdb_host=ppc64-linux\n-                        # Support 'pseudo-native' debugging on the Cell BE\n-                        if test \"${target_cpu}\" = \"spu\"; then\n-\t\t\t\tgdb_host=spu-linux\n-\t\t\t\tgdb_native=yes\n-                        fi\n-\t\t\t;;\n+powerpc64*-*-linux*)\tgdb_host=ppc64-linux ;;\n powerpc*-*-linux*)\tgdb_host=linux ;;\n \n riscv*-*-freebsd*)\tgdb_host=fbsd ;;"
    },
    {
      "sha": "77a2ee80839d04ea8a3fbc6fc6dc077d586d4203",
      "filename": "gdb/configure.nat",
      "status": "modified",
      "additions": 0,
      "deletions": 17,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.nat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.nat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.nat?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -484,21 +484,4 @@ case ${gdb_host} in\n \t\t;;\n \tesac\n \t;;\n-    spu-linux)\n-\tcase ${gdb_host_cpu} in\n-\t    powerpc)\n-\t\t# Target: Cell BE (PowerPC64 + SPU)\n-\t\t# This implements a 'pseudo-native' GDB running on the\n-\t\t# PPU side of the Cell BE and debugging the SPU side.\n-\t\tNAT_FILE=\n-\t\tNAT_CDEPS=\n-\t\tLOADLIBES=\n-\t\tNATDEPFILES='spu-linux-nat.o \\\n-\t\t      inf-ptrace.o fork-child.o nat/fork-inferior.o \\\n-\t\t      nat/linux-procfs.o nat/linux-ptrace.o \\\n-\t\t      nat/linux-waitpid.o \\\n-\t\t      nat/linux-personality.o nat/linux-namespaces.o'\n-\t\t;;\n-\tesac\n-\t;;\n esac"
    },
    {
      "sha": "2edfe3bfb5ecf3ca07ff7b79d7e5d4688ade6985",
      "filename": "gdb/configure.tgt",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.tgt?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -514,8 +514,7 @@ powerpc-*-aix* | rs6000-*-* | powerpc64-*-aix*)\n powerpc*-*-linux*)\n \t# Target: PowerPC running Linux\n \tgdb_target_obs=\"rs6000-tdep.o ppc-linux-tdep.o ppc-sysv-tdep.o \\\n-\t\t\tppc64-tdep.o solib-svr4.o solib-spu.o \\\n-\t\t\tspu-multiarch.o \\\n+\t\t\tppc64-tdep.o solib-svr4.o \\\n \t\t\tglibc-tdep.o symfile-mem.o linux-tdep.o \\\n \t\t\travenscar-thread.o ppc-ravenscar-thread.o \\\n \t\t\tlinux-record.o \\\n@@ -668,12 +667,6 @@ sparc64-*-*)\n \t\t\travenscar-thread.o sparc-ravenscar-thread.o\"\n \t;;\n \n-spu*-*-*)\n-\t# Target: Cell BE SPU\n-\tgdb_target_obs=\"spu-tdep.o\"\n-\tbuild_gdbserver=yes\n-\t;;\n-\n s12z-*-*)\n \t# Target: Freescale S12z\n \tgdb_target_obs=\"s12z-tdep.o\""
    },
    {
      "sha": "cea9210a52039ebc753b969e761d1d0adf14b0d0",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 0,
      "deletions": 88,
      "changes": 88,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -709,36 +709,6 @@ core_target::files_info ()\n   print_section_info (&m_core_section_table, core_bfd);\n }\n \f\n-struct spuid_list\n-{\n-  gdb_byte *buf;\n-  ULONGEST offset;\n-  LONGEST len;\n-  ULONGEST pos;\n-  ULONGEST written;\n-};\n-\n-static void\n-add_to_spuid_list (bfd *abfd, asection *asect, void *list_p)\n-{\n-  struct spuid_list *list = (struct spuid_list *) list_p;\n-  enum bfd_endian byte_order\n-    = bfd_big_endian (abfd) ? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-  int fd, pos = 0;\n-\n-  sscanf (bfd_section_name (asect), \"SPU/%d/regs%n\", &fd, &pos);\n-  if (pos == 0)\n-    return;\n-\n-  if (list->pos >= list->offset && list->pos + 4 <= list->offset + list->len)\n-    {\n-      store_unsigned_integer (list->buf + list->pos - list->offset,\n-\t\t\t      4, byte_order, fd);\n-      list->written += 4;\n-    }\n-  list->pos += 4;\n-}\n-\n enum target_xfer_status\n core_target::xfer_partial (enum target_object object, const char *annex,\n \t\t\t   gdb_byte *readbuf, const gdb_byte *writebuf,\n@@ -865,64 +835,6 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t}\n       /* FALL THROUGH */\n \n-    case TARGET_OBJECT_SPU:\n-      if (readbuf && annex)\n-\t{\n-\t  /* When the SPU contexts are stored in a core file, BFD\n-\t     represents this with a fake section called\n-\t     \"SPU/<annex>\".  */\n-\n-\t  struct bfd_section *section;\n-\t  bfd_size_type size;\n-\t  char sectionstr[100];\n-\n-\t  xsnprintf (sectionstr, sizeof sectionstr, \"SPU/%s\", annex);\n-\n-\t  section = bfd_get_section_by_name (core_bfd, sectionstr);\n-\t  if (section == NULL)\n-\t    return TARGET_XFER_E_IO;\n-\n-\t  size = bfd_section_size (section);\n-\t  if (offset >= size)\n-\t    return TARGET_XFER_EOF;\n-\t  size -= offset;\n-\t  if (size > len)\n-\t    size = len;\n-\n-\t  if (size == 0)\n-\t    return TARGET_XFER_EOF;\n-\t  if (!bfd_get_section_contents (core_bfd, section, readbuf,\n-\t\t\t\t\t (file_ptr) offset, size))\n-\t    {\n-\t      warning (_(\"Couldn't read SPU section in core file.\"));\n-\t      return TARGET_XFER_E_IO;\n-\t    }\n-\n-\t  *xfered_len = (ULONGEST) size;\n-\t  return TARGET_XFER_OK;\n-\t}\n-      else if (readbuf)\n-\t{\n-\t  /* NULL annex requests list of all present spuids.  */\n-\t  struct spuid_list list;\n-\n-\t  list.buf = readbuf;\n-\t  list.offset = offset;\n-\t  list.len = len;\n-\t  list.pos = 0;\n-\t  list.written = 0;\n-\t  bfd_map_over_sections (core_bfd, add_to_spuid_list, &list);\n-\n-\t  if (list.written == 0)\n-\t    return TARGET_XFER_EOF;\n-\t  else\n-\t    {\n-\t      *xfered_len = (ULONGEST) list.written;\n-\t      return TARGET_XFER_OK;\n-\t    }\n-\t}\n-      return TARGET_XFER_E_IO;\n-\n     case TARGET_OBJECT_SIGNAL_INFO:\n       if (readbuf)\n \t{"
    },
    {
      "sha": "0a10fa3fade7b0d911b1188e954a8c64e8cf557d",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1,3 +1,10 @@\n+2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* doc/gdb.texinfo (Remote Configuration): Remove documentation for\n+\tqXfer:spu:read and qXfer:spu:write.\n+\t(General Query Packets): Likewise.\n+\t(Cell Broadband Engine SPU architecture): Remove subsection.\n+\n 2019-09-18  Tom Tromey  <tom@tromey.com>\n \n \t* gdb.texinfo (Editing): Document readline application name."
    },
    {
      "sha": "f2713c03960dbe3bf4cc15714fc2bd68794db26e",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 0,
      "deletions": 113,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -22563,14 +22563,6 @@ are:\n @tab @code{qXfer:sdata:read}\n @tab @code{print $_sdata}\n \n-@item @code{read-spu-object}\n-@tab @code{qXfer:spu:read}\n-@tab @code{info spu}\n-\n-@item @code{write-spu-object}\n-@tab @code{qXfer:spu:write}\n-@tab @code{info spu}\n-\n @item @code{read-siginfo-object}\n @tab @code{qXfer:siginfo:read}\n @tab @code{print $_siginfo}\n@@ -24438,7 +24430,6 @@ all uses of @value{GDBN} with the architecture, both native and cross.\n * Alpha::\n * MIPS::\n * HPPA::               HP PA architecture\n-* SPU::                Cell Broadband Engine SPU architecture\n * PowerPC::\n * Nios II::\n * Sparc64::\n@@ -24753,69 +24744,6 @@ given @var{address}.\n @end table\n \n \n-@node SPU\n-@subsection Cell Broadband Engine SPU architecture\n-@cindex Cell Broadband Engine\n-@cindex SPU\n-\n-When @value{GDBN} is debugging the Cell Broadband Engine SPU architecture,\n-it provides the following special commands:\n-\n-@table @code\n-@item info spu event\n-@kindex info spu\n-Display SPU event facility status.  Shows current event mask\n-and pending event status.\n-\n-@item info spu signal\n-Display SPU signal notification facility status.  Shows pending\n-signal-control word and signal notification mode of both signal\n-notification channels.\n-\n-@item info spu mailbox\n-Display SPU mailbox facility status.  Shows all pending entries,\n-in order of processing, in each of the SPU Write Outbound,\n-SPU Write Outbound Interrupt, and SPU Read Inbound mailboxes.\n-\n-@item info spu dma\n-Display MFC DMA status.  Shows all pending commands in the MFC\n-DMA queue.  For each entry, opcode, tag, class IDs, effective\n-and local store addresses and transfer size are shown.\n-\n-@item info spu proxydma\n-Display MFC Proxy-DMA status.  Shows all pending commands in the MFC\n-Proxy-DMA queue.  For each entry, opcode, tag, class IDs, effective\n-and local store addresses and transfer size are shown.\n-\n-@end table\n- \n-When @value{GDBN} is debugging a combined PowerPC/SPU application\n-on the Cell Broadband Engine, it provides in addition the following\n-special commands:\n-\n-@table @code\n-@item set spu stop-on-load @var{arg}\n-@kindex set spu\n-Set whether to stop for new SPE threads.  When set to @code{on}, @value{GDBN}\n-will give control to the user when a new SPE thread enters its @code{main}\n-function.  The default is @code{off}.\n-\n-@item show spu stop-on-load\n-@kindex show spu\n-Show whether to stop for new SPE threads.\n-\n-@item set spu auto-flush-cache @var{arg}\n-Set whether to automatically flush the software-managed cache.  When set to\n-@code{on}, @value{GDBN} will automatically cause the SPE software-managed\n-cache to be flushed whenever SPE execution stops.  This provides a consistent\n-view of PowerPC memory that is accessed via the cache.  If an application\n-does not use the software-managed cache, this option has no effect.\n-\n-@item show spu auto-flush-cache\n-Show whether to automatically flush the software-managed cache.\n-\n-@end table\n-\n @node PowerPC\n @subsection PowerPC\n @cindex PowerPC architecture\n@@ -40110,16 +40038,6 @@ These are the currently defined stub features and their properties:\n @tab @samp{-}\n @tab Yes\n \n-@item @samp{qXfer:spu:read}\n-@tab No\n-@tab @samp{-}\n-@tab Yes\n-\n-@item @samp{qXfer:spu:write}\n-@tab No\n-@tab @samp{-}\n-@tab Yes\n-\n @item @samp{qXfer:siginfo:read}\n @tab No\n @tab @samp{-}\n@@ -40352,14 +40270,6 @@ The remote stub understands the @samp{qXfer:memory-map:read} packet\n The remote stub understands the @samp{qXfer:sdata:read} packet\n (@pxref{qXfer sdata read}).\n \n-@item qXfer:spu:read\n-The remote stub understands the @samp{qXfer:spu:read} packet\n-(@pxref{qXfer spu read}).\n-\n-@item qXfer:spu:write\n-The remote stub understands the @samp{qXfer:spu:write} packet\n-(@pxref{qXfer spu write}).\n-\n @item qXfer:siginfo:read\n The remote stub understands the @samp{qXfer:siginfo:read} packet\n (@pxref{qXfer siginfo read}).\n@@ -40805,18 +40715,6 @@ This packet is not probed by default; the remote stub must request it,\n by supplying an appropriate @samp{qSupported} response\n (@pxref{qSupported}).\n \n-@item qXfer:spu:read:@var{annex}:@var{offset},@var{length}\n-@anchor{qXfer spu read}\n-Read contents of an @code{spufs} file on the target system.  The\n-annex specifies which file to read; it must be of the form \n-@file{@var{id}/@var{name}}, where @var{id} specifies an SPU context ID\n-in the target process, and @var{name} identifes the @code{spufs} file\n-in that context to be accessed.\n-\n-This packet is not probed by default; the remote stub must request it,\n-by supplying an appropriate @samp{qSupported} response\n-(@pxref{qSupported}).\n-\n @item qXfer:threads:read::@var{offset},@var{length}\n @anchor{qXfer threads read}\n Access the list of threads on target.  @xref{Thread List Format}.  The\n@@ -40902,17 +40800,6 @@ empty (@pxref{qXfer write}).\n This packet is not probed by default; the remote stub must request it,\n by supplying an appropriate @samp{qSupported} response\n (@pxref{qSupported}).\n-\n-@item qXfer:spu:write:@var{annex}:@var{offset}:@var{data}@dots{}\n-@anchor{qXfer spu write}\n-Write @var{data} to an @code{spufs} file on the target system.  The\n-annex specifies which file to write; it must be of the form\n-@file{@var{id}/@var{name}}, where @var{id} specifies an SPU context ID\n-in the target process, and @var{name} identifes the @code{spufs} file\n-in that context to be accessed.\n-\n-This packet is not probed by default; the remote stub must request it,\n-by supplying an appropriate @samp{qSupported} response (@pxref{qSupported}).\n @end table\n \n @item qXfer:@var{object}:@var{operation}:@dots{}"
    },
    {
      "sha": "52318d4c06bd99e4e8a0d9d770b36e606a1faa69",
      "filename": "gdb/features/Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/features/Makefile",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/features/Makefile",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/Makefile?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -53,7 +53,7 @@ WHICH = arm/arm-with-iwmmxt arm/arm-with-vfpv2 arm/arm-with-vfpv3 \\\n \trs6000/powerpc-32 \\\n \trs6000/powerpc-32l rs6000/powerpc-altivec32l rs6000/powerpc-e500l \\\n \trs6000/powerpc-64l rs6000/powerpc-altivec64l rs6000/powerpc-vsx32l \\\n-\trs6000/powerpc-vsx64l rs6000/powerpc-cell32l rs6000/powerpc-cell64l \\\n+\trs6000/powerpc-vsx64l \\\n \trs6000/powerpc-isa205-32l rs6000/powerpc-isa205-64l \\\n \trs6000/powerpc-isa205-altivec32l rs6000/powerpc-isa205-altivec64l \\\n \trs6000/powerpc-isa205-vsx32l rs6000/powerpc-isa205-vsx64l \\\n@@ -84,8 +84,6 @@ microblaze-expedite = r1,rpc\n nios2-linux-expedite = sp,pc\n or1k-expedite = r1,npc\n powerpc-expedite = r1,pc\n-rs6000/powerpc-cell32l-expedite = r1,pc,r0,orig_r3,r4\n-rs6000/powerpc-cell64l-expedite = r1,pc,r0,orig_r3,r4\n s390-linux32-expedite = r14,r15,pswa\n s390-linux32v1-expedite = r14,r15,pswa\n s390-linux32v2-expedite = r14,r15,pswa\n@@ -140,8 +138,6 @@ XMLTOC = \\\n \trs6000/powerpc-altivec32l.xml \\\n \trs6000/powerpc-altivec64.xml \\\n \trs6000/powerpc-altivec64l.xml \\\n-\trs6000/powerpc-cell32l.xml \\\n-\trs6000/powerpc-cell64l.xml \\\n \trs6000/powerpc-e500.xml \\\n \trs6000/powerpc-e500l.xml \\\n \trs6000/powerpc-isa205-32l.xml \\"
    },
    {
      "sha": "74c42f94bcb482db8cd220e8df4b19a7a5f74cd6",
      "filename": "gdb/features/rs6000/powerpc-cell32l.c",
      "status": "removed",
      "additions": 0,
      "deletions": 162,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell32l.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell32l.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/rs6000/powerpc-cell32l.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,162 +0,0 @@\n-/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:\n-  Original: powerpc-cell32l.xml */\n-\n-#include \"defs.h\"\n-#include \"osabi.h\"\n-#include \"target-descriptions.h\"\n-\n-struct target_desc *tdesc_powerpc_cell32l;\n-static void\n-initialize_tdesc_powerpc_cell32l (void)\n-{\n-  struct target_desc *result = allocate_target_description ();\n-  set_tdesc_architecture (result, bfd_scan_arch (\"powerpc:common\"));\n-\n-  tdesc_add_compatible (result, bfd_scan_arch (\"spu:256K\"));\n-\n-  struct tdesc_feature *feature;\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.core\");\n-  tdesc_create_reg (feature, \"r0\", 0, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r1\", 1, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r2\", 2, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r3\", 3, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r4\", 4, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r5\", 5, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r6\", 6, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r7\", 7, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r8\", 8, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r9\", 9, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r10\", 10, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r11\", 11, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r12\", 12, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r13\", 13, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r14\", 14, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r15\", 15, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r16\", 16, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r17\", 17, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r18\", 18, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r19\", 19, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r20\", 20, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r21\", 21, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r22\", 22, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r23\", 23, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r24\", 24, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r25\", 25, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r26\", 26, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r27\", 27, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r28\", 28, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r29\", 29, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r30\", 30, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"r31\", 31, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"pc\", 64, 1, NULL, 32, \"code_ptr\");\n-  tdesc_create_reg (feature, \"msr\", 65, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"cr\", 66, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"lr\", 67, 1, NULL, 32, \"code_ptr\");\n-  tdesc_create_reg (feature, \"ctr\", 68, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"xer\", 69, 1, NULL, 32, \"uint32\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.fpu\");\n-  tdesc_create_reg (feature, \"f0\", 32, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f1\", 33, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f2\", 34, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f3\", 35, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f4\", 36, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f5\", 37, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f6\", 38, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f7\", 39, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f8\", 40, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f9\", 41, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f10\", 42, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f11\", 43, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f12\", 44, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f13\", 45, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f14\", 46, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f15\", 47, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f16\", 48, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f17\", 49, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f18\", 50, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f19\", 51, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f20\", 52, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f21\", 53, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f22\", 54, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f23\", 55, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f24\", 56, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f25\", 57, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f26\", 58, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f27\", 59, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f28\", 60, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f29\", 61, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f30\", 62, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f31\", 63, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"fpscr\", 70, 1, \"float\", 32, \"int\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.linux\");\n-  tdesc_create_reg (feature, \"orig_r3\", 71, 1, NULL, 32, \"int\");\n-  tdesc_create_reg (feature, \"trap\", 72, 1, NULL, 32, \"int\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.altivec\");\n-  tdesc_type *element_type;\n-  element_type = tdesc_named_type (feature, \"ieee_single\");\n-  tdesc_create_vector (feature, \"v4f\", element_type, 4);\n-\n-  element_type = tdesc_named_type (feature, \"int32\");\n-  tdesc_create_vector (feature, \"v4i32\", element_type, 4);\n-\n-  element_type = tdesc_named_type (feature, \"int16\");\n-  tdesc_create_vector (feature, \"v8i16\", element_type, 8);\n-\n-  element_type = tdesc_named_type (feature, \"int8\");\n-  tdesc_create_vector (feature, \"v16i8\", element_type, 16);\n-\n-  tdesc_type_with_fields *type_with_fields;\n-  type_with_fields = tdesc_create_union (feature, \"vec128\");\n-  tdesc_type *field_type;\n-  field_type = tdesc_named_type (feature, \"uint128\");\n-  tdesc_add_field (type_with_fields, \"uint128\", field_type);\n-  field_type = tdesc_named_type (feature, \"v4f\");\n-  tdesc_add_field (type_with_fields, \"v4_float\", field_type);\n-  field_type = tdesc_named_type (feature, \"v4i32\");\n-  tdesc_add_field (type_with_fields, \"v4_int32\", field_type);\n-  field_type = tdesc_named_type (feature, \"v8i16\");\n-  tdesc_add_field (type_with_fields, \"v8_int16\", field_type);\n-  field_type = tdesc_named_type (feature, \"v16i8\");\n-  tdesc_add_field (type_with_fields, \"v16_int8\", field_type);\n-\n-  tdesc_create_reg (feature, \"vr0\", 73, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr1\", 74, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr2\", 75, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr3\", 76, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr4\", 77, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr5\", 78, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr6\", 79, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr7\", 80, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr8\", 81, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr9\", 82, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr10\", 83, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr11\", 84, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr12\", 85, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr13\", 86, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr14\", 87, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr15\", 88, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr16\", 89, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr17\", 90, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr18\", 91, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr19\", 92, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr20\", 93, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr21\", 94, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr22\", 95, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr23\", 96, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr24\", 97, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr25\", 98, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr26\", 99, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr27\", 100, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr28\", 101, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr29\", 102, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr30\", 103, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr31\", 104, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vscr\", 105, 1, \"vector\", 32, \"int\");\n-  tdesc_create_reg (feature, \"vrsave\", 106, 1, \"vector\", 32, \"int\");\n-\n-  tdesc_powerpc_cell32l = result;\n-}"
    },
    {
      "sha": "57b4806947b7dae7961669bf485c518b22f78495",
      "filename": "gdb/features/rs6000/powerpc-cell32l.xml",
      "status": "removed",
      "additions": 0,
      "deletions": 19,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell32l.xml",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell32l.xml",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/rs6000/powerpc-cell32l.xml?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,19 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!-- Copyright (C) 2009-2019 Free Software Foundation, Inc.\n-\n-     Copying and distribution of this file, with or without modification,\n-     are permitted in any medium without royalty provided the copyright\n-     notice and this notice are preserved.  -->\n-\n-<!-- Cell/B.E. architecture.  Identical to the PowerPC 32-bit Linux UISA,\n-     but adds support for the SPU as compatible architecture.  -->\n-\n-<!DOCTYPE target SYSTEM \"gdb-target.dtd\">\n-<target>\n-  <architecture>powerpc:common</architecture>\n-  <compatible>spu</compatible>\n-  <xi:include href=\"power-core.xml\"/>\n-  <xi:include href=\"power-fpu.xml\"/>\n-  <xi:include href=\"power-linux.xml\"/>\n-  <xi:include href=\"power-altivec.xml\"/>\n-</target>"
    },
    {
      "sha": "cbfda4c50ab90b48516000455d8711cd55a3cd76",
      "filename": "gdb/features/rs6000/powerpc-cell64l.c",
      "status": "removed",
      "additions": 0,
      "deletions": 162,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell64l.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell64l.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/rs6000/powerpc-cell64l.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,162 +0,0 @@\n-/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:\n-  Original: powerpc-cell64l.xml */\n-\n-#include \"defs.h\"\n-#include \"osabi.h\"\n-#include \"target-descriptions.h\"\n-\n-struct target_desc *tdesc_powerpc_cell64l;\n-static void\n-initialize_tdesc_powerpc_cell64l (void)\n-{\n-  struct target_desc *result = allocate_target_description ();\n-  set_tdesc_architecture (result, bfd_scan_arch (\"powerpc:common64\"));\n-\n-  tdesc_add_compatible (result, bfd_scan_arch (\"spu:256K\"));\n-\n-  struct tdesc_feature *feature;\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.core\");\n-  tdesc_create_reg (feature, \"r0\", 0, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r1\", 1, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r2\", 2, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r3\", 3, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r4\", 4, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r5\", 5, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r6\", 6, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r7\", 7, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r8\", 8, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r9\", 9, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r10\", 10, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r11\", 11, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r12\", 12, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r13\", 13, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r14\", 14, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r15\", 15, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r16\", 16, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r17\", 17, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r18\", 18, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r19\", 19, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r20\", 20, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r21\", 21, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r22\", 22, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r23\", 23, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r24\", 24, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r25\", 25, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r26\", 26, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r27\", 27, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r28\", 28, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r29\", 29, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r30\", 30, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"r31\", 31, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"pc\", 64, 1, NULL, 64, \"code_ptr\");\n-  tdesc_create_reg (feature, \"msr\", 65, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"cr\", 66, 1, NULL, 32, \"uint32\");\n-  tdesc_create_reg (feature, \"lr\", 67, 1, NULL, 64, \"code_ptr\");\n-  tdesc_create_reg (feature, \"ctr\", 68, 1, NULL, 64, \"uint64\");\n-  tdesc_create_reg (feature, \"xer\", 69, 1, NULL, 32, \"uint32\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.fpu\");\n-  tdesc_create_reg (feature, \"f0\", 32, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f1\", 33, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f2\", 34, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f3\", 35, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f4\", 36, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f5\", 37, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f6\", 38, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f7\", 39, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f8\", 40, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f9\", 41, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f10\", 42, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f11\", 43, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f12\", 44, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f13\", 45, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f14\", 46, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f15\", 47, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f16\", 48, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f17\", 49, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f18\", 50, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f19\", 51, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f20\", 52, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f21\", 53, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f22\", 54, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f23\", 55, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f24\", 56, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f25\", 57, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f26\", 58, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f27\", 59, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f28\", 60, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f29\", 61, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f30\", 62, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"f31\", 63, 1, NULL, 64, \"ieee_double\");\n-  tdesc_create_reg (feature, \"fpscr\", 70, 1, \"float\", 32, \"int\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.linux\");\n-  tdesc_create_reg (feature, \"orig_r3\", 71, 1, NULL, 64, \"int\");\n-  tdesc_create_reg (feature, \"trap\", 72, 1, NULL, 64, \"int\");\n-\n-  feature = tdesc_create_feature (result, \"org.gnu.gdb.power.altivec\");\n-  tdesc_type *element_type;\n-  element_type = tdesc_named_type (feature, \"ieee_single\");\n-  tdesc_create_vector (feature, \"v4f\", element_type, 4);\n-\n-  element_type = tdesc_named_type (feature, \"int32\");\n-  tdesc_create_vector (feature, \"v4i32\", element_type, 4);\n-\n-  element_type = tdesc_named_type (feature, \"int16\");\n-  tdesc_create_vector (feature, \"v8i16\", element_type, 8);\n-\n-  element_type = tdesc_named_type (feature, \"int8\");\n-  tdesc_create_vector (feature, \"v16i8\", element_type, 16);\n-\n-  tdesc_type_with_fields *type_with_fields;\n-  type_with_fields = tdesc_create_union (feature, \"vec128\");\n-  tdesc_type *field_type;\n-  field_type = tdesc_named_type (feature, \"uint128\");\n-  tdesc_add_field (type_with_fields, \"uint128\", field_type);\n-  field_type = tdesc_named_type (feature, \"v4f\");\n-  tdesc_add_field (type_with_fields, \"v4_float\", field_type);\n-  field_type = tdesc_named_type (feature, \"v4i32\");\n-  tdesc_add_field (type_with_fields, \"v4_int32\", field_type);\n-  field_type = tdesc_named_type (feature, \"v8i16\");\n-  tdesc_add_field (type_with_fields, \"v8_int16\", field_type);\n-  field_type = tdesc_named_type (feature, \"v16i8\");\n-  tdesc_add_field (type_with_fields, \"v16_int8\", field_type);\n-\n-  tdesc_create_reg (feature, \"vr0\", 73, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr1\", 74, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr2\", 75, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr3\", 76, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr4\", 77, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr5\", 78, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr6\", 79, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr7\", 80, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr8\", 81, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr9\", 82, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr10\", 83, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr11\", 84, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr12\", 85, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr13\", 86, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr14\", 87, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr15\", 88, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr16\", 89, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr17\", 90, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr18\", 91, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr19\", 92, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr20\", 93, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr21\", 94, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr22\", 95, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr23\", 96, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr24\", 97, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr25\", 98, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr26\", 99, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr27\", 100, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr28\", 101, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr29\", 102, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr30\", 103, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vr31\", 104, 1, NULL, 128, \"vec128\");\n-  tdesc_create_reg (feature, \"vscr\", 105, 1, \"vector\", 32, \"int\");\n-  tdesc_create_reg (feature, \"vrsave\", 106, 1, \"vector\", 32, \"int\");\n-\n-  tdesc_powerpc_cell64l = result;\n-}"
    },
    {
      "sha": "c2add44b45ff68aae77ab4acc2ff829e189dd1d7",
      "filename": "gdb/features/rs6000/powerpc-cell64l.xml",
      "status": "removed",
      "additions": 0,
      "deletions": 19,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell64l.xml",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/features/rs6000/powerpc-cell64l.xml",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/rs6000/powerpc-cell64l.xml?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,19 +0,0 @@\n-<?xml version=\"1.0\"?>\n-<!-- Copyright (C) 2009-2019 Free Software Foundation, Inc.\n-\n-     Copying and distribution of this file, with or without modification,\n-     are permitted in any medium without royalty provided the copyright\n-     notice and this notice are preserved.  -->\n-\n-<!-- Cell/B.E. architecture.  Identical to the PowerPC 64-bit Linux UISA,\n-     but adds support for the SPU as compatible architecture.  -->\n-\n-<!DOCTYPE target SYSTEM \"gdb-target.dtd\">\n-<target>\n-  <architecture>powerpc:common64</architecture>\n-  <compatible>spu</compatible>\n-  <xi:include href=\"power64-core.xml\"/>\n-  <xi:include href=\"power-fpu.xml\"/>\n-  <xi:include href=\"power64-linux.xml\"/>\n-  <xi:include href=\"power-altivec.xml\"/>\n-</target>"
    },
    {
      "sha": "5c761670145930effdd396425602e6e72fa1d54d",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1,3 +1,43 @@\n+2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.srv (ipa_ppc_linux_regobj): Remove powerpc-cell32l-ipa.o\n+\tand powerpc-cell64l-ipa.o.\n+\t(powerpc*-*-linux*): Remove powerpc-cell32l.o and powerpc-cell64l.o\n+\tfrom srv_regobj.  Remove rs6000/powerpc-cell32l.xml and\n+\trs6000/powerpc-cell64l.xml from srv_xmlfiles.\n+\t(spu*-*-*): Remove.\n+\n+\t* spu-low.c: Remove file.\n+\n+\t* linux-ppc-low.c (INSTR_SC, NR_spu_run): Remove.\n+\t(parse_spufs_run): Remove.\n+\t(ppc_get_pc): Remove Cell/B.E. support.\n+\t(ppc_set_pc): Likewise.\n+\t(ppc_breakpoint_at): Likewise.\n+\t(ppc_arch_setup): Likewise.\n+\t(ppc_get_ipa_tdesc_idx): Do not handle tdesc_powerpc_cell64l or\n+\ttdesc_powerpc_cell32l.\n+\t(initialize_low_arch): Do not call init_registers_powerpc_cell64l\n+\tor init_registers_powerpc_cell32l.\n+\t* linux-ppc-ipa.c (get_ipa_tdesc): Do not handle PPC_TDESC_CELL.\n+\t(initialize_low_tracepoint): Do not call init_registers_powerpc_cell64l\n+\tor init_registers_powerpc_cell32l.\n+\t* linux-ppc-tdesc-init.h (PPC_TDESC_CELL): Mark as unused.\n+\t(init_registers_powerpc_cell32l): Remove prototype.\n+\t(init_registers_powerpc_cell64l): Likewise.\n+\n+\t* target.h (struct target_ops): Remove qxfer_spu member.\n+\t* server.c (handle_qxfer_spu): Remove.\n+\t(qxfer_packets): Remove entry for \"spu\".\n+\t(handle_query): No longer support qXfer:spu:read or qXfer:spu:write.\n+\t* linux-low.c (SPUFS_MAGIC): Remove.\n+\t(spu_enumerate_spu_ids): Remove.\n+\t(linux_qxfer_spu): Remove.\n+\t(linux_target_ops): Remove qxfer_spu member.\n+\t* lynx-low.c (lynx_target_ops): Remove qxfer_spu member.\n+\t* nto-low.c (nto_target_ops): Remove qxfer_spu member.\n+\t* win32-low.c (win32_target_ops): Remove qxfer_spu member.\n+\n 2019-08-23  Sergio Durigan Junior  <sergiodj@redhat.com>\n \n \t* Makefile.in (SFILES): Add 'gdbsupport/gdb-dlfcn.c'."
    },
    {
      "sha": "1a4ab8e3361c0dbee0b3e038018086ce854ff424",
      "filename": "gdb/gdbserver/configure.srv",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/configure.srv?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -24,7 +24,7 @@\n # Default hostio_last_error implementation\n srv_hostio_err_objs=\"hostio-errno.o\"\n \n-ipa_ppc_linux_regobj=\"powerpc-32l-ipa.o powerpc-altivec32l-ipa.o powerpc-cell32l-ipa.o powerpc-vsx32l-ipa.o powerpc-isa205-32l-ipa.o powerpc-isa205-altivec32l-ipa.o powerpc-isa205-vsx32l-ipa.o powerpc-isa205-ppr-dscr-vsx32l-ipa.o powerpc-isa207-vsx32l-ipa.o powerpc-isa207-htm-vsx32l-ipa.o powerpc-e500l-ipa.o powerpc-64l-ipa.o powerpc-altivec64l-ipa.o powerpc-cell64l-ipa.o powerpc-vsx64l-ipa.o powerpc-isa205-64l-ipa.o powerpc-isa205-altivec64l-ipa.o powerpc-isa205-vsx64l-ipa.o powerpc-isa205-ppr-dscr-vsx64l-ipa.o powerpc-isa207-vsx64l-ipa.o powerpc-isa207-htm-vsx64l-ipa.o\"\n+ipa_ppc_linux_regobj=\"powerpc-32l-ipa.o powerpc-altivec32l-ipa.o powerpc-vsx32l-ipa.o powerpc-isa205-32l-ipa.o powerpc-isa205-altivec32l-ipa.o powerpc-isa205-vsx32l-ipa.o powerpc-isa205-ppr-dscr-vsx32l-ipa.o powerpc-isa207-vsx32l-ipa.o powerpc-isa207-htm-vsx32l-ipa.o powerpc-e500l-ipa.o powerpc-64l-ipa.o powerpc-altivec64l-ipa.o powerpc-vsx64l-ipa.o powerpc-isa205-64l-ipa.o powerpc-isa205-altivec64l-ipa.o powerpc-isa205-vsx64l-ipa.o powerpc-isa205-ppr-dscr-vsx64l-ipa.o powerpc-isa207-vsx64l-ipa.o powerpc-isa207-htm-vsx64l-ipa.o\"\n \n # Linux object files.  This is so we don't have to repeat\n # these files over and over again.\n@@ -186,7 +186,6 @@ case \"${target}\" in\n \t\t\t;;\n   powerpc*-*-linux*)\tsrv_regobj=\"powerpc-32l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-altivec32l.o\"\n-\t\t\tsrv_regobj=\"${srv_regobj} powerpc-cell32l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-vsx32l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-isa205-32l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-isa205-altivec32l.o\"\n@@ -197,7 +196,6 @@ case \"${target}\" in\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-e500l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-64l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-altivec64l.o\"\n-\t\t\tsrv_regobj=\"${srv_regobj} powerpc-cell64l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-vsx64l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-isa205-64l.o\"\n \t\t\tsrv_regobj=\"${srv_regobj} powerpc-isa205-altivec64l.o\"\n@@ -209,7 +207,6 @@ case \"${target}\" in\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/ppc-linux-common.o\"\n \t\t\tsrv_xmlfiles=\"rs6000/powerpc-32l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-altivec32l.xml\"\n-\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-cell32l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-vsx32l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-isa205-32l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-isa205-altivec32l.xml\"\n@@ -240,7 +237,6 @@ case \"${target}\" in\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/power-spe.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-64l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-altivec64l.xml\"\n-\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-cell64l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-vsx64l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-isa205-64l.xml\"\n \t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/powerpc-isa205-altivec64l.xml\"\n@@ -340,9 +336,6 @@ case \"${target}\" in\n \t\t\tsrv_linux_regsets=yes\n \t\t\tsrv_linux_thread_db=yes\n \t\t\t;;\n-  spu*-*-*)\t\tsrv_regobj=reg-spu.o\n-\t\t\tsrv_tgtobj=\"spu-low.o fork-child.o fork-inferior.o\"\n-\t\t\t;;\n   tic6x-*-uclinux)\tif $development; then\n \t\t\t  srv_regobj=\"tic6x-c64xp-linux.o\"\n \t\t\t  srv_regobj=\"${srv_regobj} tic6x-c64x-linux.o\""
    },
    {
      "sha": "d64c3641ffb12412945593815c8ce9e51acfa3b5",
      "filename": "gdb/gdbserver/linux-low.c",
      "status": "modified",
      "additions": 0,
      "deletions": 98,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-low.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -60,10 +60,6 @@\n #endif\n #include \"nat/linux-namespaces.h\"\n \n-#ifndef SPUFS_MAGIC\n-#define SPUFS_MAGIC 0x23c9b64e\n-#endif\n-\n #ifdef HAVE_PERSONALITY\n # include <sys/personality.h>\n # if !HAVE_DECL_ADDR_NO_RANDOMIZE\n@@ -6358,99 +6354,6 @@ linux_supports_range_stepping (void)\n   return (*the_low_target.supports_range_stepping) ();\n }\n \n-/* Enumerate spufs IDs for process PID.  */\n-static int\n-spu_enumerate_spu_ids (long pid, unsigned char *buf, CORE_ADDR offset, int len)\n-{\n-  int pos = 0;\n-  int written = 0;\n-  char path[128];\n-  DIR *dir;\n-  struct dirent *entry;\n-\n-  sprintf (path, \"/proc/%ld/fd\", pid);\n-  dir = opendir (path);\n-  if (!dir)\n-    return -1;\n-\n-  rewinddir (dir);\n-  while ((entry = readdir (dir)) != NULL)\n-    {\n-      struct stat st;\n-      struct statfs stfs;\n-      int fd;\n-\n-      fd = atoi (entry->d_name);\n-      if (!fd)\n-        continue;\n-\n-      sprintf (path, \"/proc/%ld/fd/%d\", pid, fd);\n-      if (stat (path, &st) != 0)\n-        continue;\n-      if (!S_ISDIR (st.st_mode))\n-        continue;\n-\n-      if (statfs (path, &stfs) != 0)\n-        continue;\n-      if (stfs.f_type != SPUFS_MAGIC)\n-        continue;\n-\n-      if (pos >= offset && pos + 4 <= offset + len)\n-        {\n-          *(unsigned int *)(buf + pos - offset) = fd;\n-          written += 4;\n-        }\n-      pos += 4;\n-    }\n-\n-  closedir (dir);\n-  return written;\n-}\n-\n-/* Implements the to_xfer_partial interface for the TARGET_OBJECT_SPU\n-   object type, using the /proc file system.  */\n-static int\n-linux_qxfer_spu (const char *annex, unsigned char *readbuf,\n-\t\t unsigned const char *writebuf,\n-\t\t CORE_ADDR offset, int len)\n-{\n-  long pid = lwpid_of (current_thread);\n-  char buf[128];\n-  int fd = 0;\n-  int ret = 0;\n-\n-  if (!writebuf && !readbuf)\n-    return -1;\n-\n-  if (!*annex)\n-    {\n-      if (!readbuf)\n-\treturn -1;\n-      else\n-\treturn spu_enumerate_spu_ids (pid, readbuf, offset, len);\n-    }\n-\n-  sprintf (buf, \"/proc/%ld/fd/%s\", pid, annex);\n-  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);\n-  if (fd <= 0)\n-    return -1;\n-\n-  if (offset != 0\n-      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)\n-    {\n-      close (fd);\n-      return 0;\n-    }\n-\n-  if (writebuf)\n-    ret = write (fd, writebuf, (size_t) len);\n-  else\n-    ret = read (fd, readbuf, (size_t) len);\n-\n-  close (fd);\n-  return ret;\n-}\n-\n #if defined PT_GETDSBT || defined PTRACE_GETFDPIC\n struct target_loadseg\n {\n@@ -7496,7 +7399,6 @@ static struct target_ops linux_target_ops = {\n #else\n   NULL,\n #endif\n-  linux_qxfer_spu,\n   hostio_last_error_from_errno,\n   linux_qxfer_osdata,\n   linux_xfer_siginfo,"
    },
    {
      "sha": "f9df02236afaed281a4b7f6baa510d55455513af",
      "filename": "gdb/gdbserver/linux-ppc-ipa.c",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-ipa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-ipa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-ppc-ipa.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -181,8 +181,6 @@ get_ipa_tdesc (int idx)\n       return tdesc_powerpc_64l;\n     case PPC_TDESC_ALTIVEC:\n       return tdesc_powerpc_altivec64l;\n-    case PPC_TDESC_CELL:\n-      return tdesc_powerpc_cell64l;\n     case PPC_TDESC_VSX:\n       return tdesc_powerpc_vsx64l;\n     case PPC_TDESC_ISA205:\n@@ -202,8 +200,6 @@ get_ipa_tdesc (int idx)\n       return tdesc_powerpc_32l;\n     case PPC_TDESC_ALTIVEC:\n       return tdesc_powerpc_altivec32l;\n-    case PPC_TDESC_CELL:\n-      return tdesc_powerpc_cell32l;\n     case PPC_TDESC_VSX:\n       return tdesc_powerpc_vsx32l;\n     case PPC_TDESC_ISA205:\n@@ -241,7 +237,6 @@ initialize_low_tracepoint (void)\n #ifdef __powerpc64__\n   init_registers_powerpc_64l ();\n   init_registers_powerpc_altivec64l ();\n-  init_registers_powerpc_cell64l ();\n   init_registers_powerpc_vsx64l ();\n   init_registers_powerpc_isa205_64l ();\n   init_registers_powerpc_isa205_altivec64l ();\n@@ -252,7 +247,6 @@ initialize_low_tracepoint (void)\n #else\n   init_registers_powerpc_32l ();\n   init_registers_powerpc_altivec32l ();\n-  init_registers_powerpc_cell32l ();\n   init_registers_powerpc_vsx32l ();\n   init_registers_powerpc_isa205_32l ();\n   init_registers_powerpc_isa205_altivec32l ();"
    },
    {
      "sha": "c0622825ad057db7f29999533c4f8df33bfa633b",
      "filename": "gdb/gdbserver/linux-ppc-low.c",
      "status": "modified",
      "additions": 7,
      "deletions": 99,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-ppc-low.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -220,73 +220,10 @@ ppc_supply_ptrace_register (struct regcache *regcache,\n     perror_with_name (\"Unexpected byte order\");\n }\n \n-\n-#define INSTR_SC        0x44000002\n-#define NR_spu_run      0x0116\n-\n-/* If the PPU thread is currently stopped on a spu_run system call,\n-   return to FD and ADDR the file handle and NPC parameter address\n-   used with the system call.  Return non-zero if successful.  */\n-static int\n-parse_spufs_run (struct regcache *regcache, int *fd, CORE_ADDR *addr)\n-{\n-  CORE_ADDR curr_pc;\n-  int curr_insn;\n-  int curr_r0;\n-\n-  if (register_size (regcache->tdesc, 0) == 4)\n-    {\n-      unsigned int pc, r0, r3, r4;\n-      collect_register_by_name (regcache, \"pc\", &pc);\n-      collect_register_by_name (regcache, \"r0\", &r0);\n-      collect_register_by_name (regcache, \"orig_r3\", &r3);\n-      collect_register_by_name (regcache, \"r4\", &r4);\n-      curr_pc = (CORE_ADDR) pc;\n-      curr_r0 = (int) r0;\n-      *fd = (int) r3;\n-      *addr = (CORE_ADDR) r4;\n-    }\n-  else\n-    {\n-      unsigned long pc, r0, r3, r4;\n-      collect_register_by_name (regcache, \"pc\", &pc);\n-      collect_register_by_name (regcache, \"r0\", &r0);\n-      collect_register_by_name (regcache, \"orig_r3\", &r3);\n-      collect_register_by_name (regcache, \"r4\", &r4);\n-      curr_pc = (CORE_ADDR) pc;\n-      curr_r0 = (int) r0;\n-      *fd = (int) r3;\n-      *addr = (CORE_ADDR) r4;\n-    }\n-\n-  /* Fetch instruction preceding current NIP.  */\n-  if ((*the_target->read_memory) (curr_pc - 4,\n-\t\t\t\t  (unsigned char *) &curr_insn, 4) != 0)\n-    return 0;\n-  /* It should be a \"sc\" instruction.  */\n-  if (curr_insn != INSTR_SC)\n-    return 0;\n-  /* System call number should be NR_spu_run.  */\n-  if (curr_r0 != NR_spu_run)\n-    return 0;\n-\n-  return 1;\n-}\n-\n static CORE_ADDR\n ppc_get_pc (struct regcache *regcache)\n {\n-  CORE_ADDR addr;\n-  int fd;\n-\n-  if (parse_spufs_run (regcache, &fd, &addr))\n-    {\n-      unsigned int pc;\n-      (*the_target->read_memory) (addr, (unsigned char *) &pc, 4);\n-      return ((CORE_ADDR)1 << 63)\n-\t| ((CORE_ADDR)fd << 32) | (CORE_ADDR) (pc - 4);\n-    }\n-  else if (register_size (regcache->tdesc, 0) == 4)\n+  if (register_size (regcache->tdesc, 0) == 4)\n     {\n       unsigned int pc;\n       collect_register_by_name (regcache, \"pc\", &pc);\n@@ -303,15 +240,7 @@ ppc_get_pc (struct regcache *regcache)\n static void\n ppc_set_pc (struct regcache *regcache, CORE_ADDR pc)\n {\n-  CORE_ADDR addr;\n-  int fd;\n-\n-  if (parse_spufs_run (regcache, &fd, &addr))\n-    {\n-      unsigned int newpc = pc;\n-      (*the_target->write_memory) (addr, (unsigned char *) &newpc, 4);\n-    }\n-  else if (register_size (regcache->tdesc, 0) == 4)\n+  if (register_size (regcache->tdesc, 0) == 4)\n     {\n       unsigned int newpc = pc;\n       supply_register_by_name (regcache, \"pc\", &newpc);\n@@ -348,23 +277,11 @@ ppc_breakpoint_at (CORE_ADDR where)\n {\n   unsigned int insn;\n \n-  if (where & ((CORE_ADDR)1 << 63))\n-    {\n-      char mem_annex[32];\n-      sprintf (mem_annex, \"%d/mem\", (int)((where >> 32) & 0x7fffffff));\n-      (*the_target->qxfer_spu) (mem_annex, (unsigned char *) &insn,\n-\t\t\t\tNULL, where & 0xffffffff, 4);\n-      if (insn == 0x3fff)\n-\treturn 1;\n-    }\n-  else\n-    {\n-      (*the_target->read_memory) (where, (unsigned char *) &insn, 4);\n-      if (insn == ppc_breakpoint)\n-\treturn 1;\n-      /* If necessary, recognize more trap instructions here.  GDB only uses\n-\t the one.  */\n-    }\n+  (*the_target->read_memory) (where, (unsigned char *) &insn, 4);\n+  if (insn == ppc_breakpoint)\n+    return 1;\n+  /* If necessary, recognize more trap instructions here.  GDB only uses\n+     the one.  */\n \n   return 0;\n }\n@@ -941,9 +858,6 @@ ppc_arch_setup (void)\n \t}\n     }\n \n-  if (ppc_hwcap & PPC_FEATURE_CELL)\n-    features.cell = true;\n-\n   tdesc = ppc_linux_match_description (features);\n \n   /* On 32-bit machines, check for SPE registers.\n@@ -3416,8 +3330,6 @@ ppc_get_ipa_tdesc_idx (void)\n     return PPC_TDESC_BASE;\n   if (tdesc == tdesc_powerpc_altivec64l)\n     return PPC_TDESC_ALTIVEC;\n-  if (tdesc == tdesc_powerpc_cell64l)\n-    return PPC_TDESC_CELL;\n   if (tdesc == tdesc_powerpc_vsx64l)\n     return PPC_TDESC_VSX;\n   if (tdesc == tdesc_powerpc_isa205_64l)\n@@ -3438,8 +3350,6 @@ ppc_get_ipa_tdesc_idx (void)\n     return PPC_TDESC_BASE;\n   if (tdesc == tdesc_powerpc_altivec32l)\n     return PPC_TDESC_ALTIVEC;\n-  if (tdesc == tdesc_powerpc_cell32l)\n-    return PPC_TDESC_CELL;\n   if (tdesc == tdesc_powerpc_vsx32l)\n     return PPC_TDESC_VSX;\n   if (tdesc == tdesc_powerpc_isa205_32l)\n@@ -3507,7 +3417,6 @@ initialize_low_arch (void)\n \n   init_registers_powerpc_32l ();\n   init_registers_powerpc_altivec32l ();\n-  init_registers_powerpc_cell32l ();\n   init_registers_powerpc_vsx32l ();\n   init_registers_powerpc_isa205_32l ();\n   init_registers_powerpc_isa205_altivec32l ();\n@@ -3519,7 +3428,6 @@ initialize_low_arch (void)\n #if __powerpc64__\n   init_registers_powerpc_64l ();\n   init_registers_powerpc_altivec64l ();\n-  init_registers_powerpc_cell64l ();\n   init_registers_powerpc_vsx64l ();\n   init_registers_powerpc_isa205_64l ();\n   init_registers_powerpc_isa205_altivec64l ();"
    },
    {
      "sha": "299b3ce36332c87657f5ab1d0b076fe7be5dcf76",
      "filename": "gdb/gdbserver/linux-ppc-tdesc-init.h",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-tdesc-init.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/linux-ppc-tdesc-init.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-ppc-tdesc-init.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -27,7 +27,7 @@\n enum ppc_linux_tdesc {\n   PPC_TDESC_BASE,\n   PPC_TDESC_ALTIVEC,\n-  PPC_TDESC_CELL,\n+  PPC_TDESC_CELL,  /* No longer used, but kept to avoid ABI changes.  */\n   PPC_TDESC_VSX,\n   PPC_TDESC_ISA205,\n   PPC_TDESC_ISA205_ALTIVEC,\n@@ -46,9 +46,6 @@ void init_registers_powerpc_32l (void);\n /* Defined in auto-generated file powerpc-altivec32l.c.  */\n void init_registers_powerpc_altivec32l (void);\n \n-/* Defined in auto-generated file powerpc-cell32l.c.  */\n-void init_registers_powerpc_cell32l (void);\n-\n /* Defined in auto-generated file powerpc-vsx32l.c.  */\n void init_registers_powerpc_vsx32l (void);\n \n@@ -83,9 +80,6 @@ void init_registers_powerpc_64l (void);\n /* Defined in auto-generated file powerpc-altivec64l.c.  */\n void init_registers_powerpc_altivec64l (void);\n \n-/* Defined in auto-generated file powerpc-cell64l.c.  */\n-void init_registers_powerpc_cell64l (void);\n-\n /* Defined in auto-generated file powerpc-vsx64l.c.  */\n void init_registers_powerpc_vsx64l (void);\n "
    },
    {
      "sha": "2bd24e7cee05e3ac186af0bf8f25abd86674058f",
      "filename": "gdb/gdbserver/lynx-low.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/lynx-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/lynx-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/lynx-low.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -753,7 +753,6 @@ static struct target_ops lynx_target_ops = {\n   NULL,  /* stopped_data_address */\n   NULL,  /* read_offsets */\n   NULL,  /* get_tls_address */\n-  NULL,  /* qxfer_spu */\n   NULL,  /* hostio_last_error */\n   NULL,  /* qxfer_osdata */\n   NULL,  /* qxfer_siginfo */"
    },
    {
      "sha": "3c1130680f25b22d3f447757a3664e50a24aa752",
      "filename": "gdb/gdbserver/nto-low.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/nto-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/nto-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/nto-low.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -963,7 +963,6 @@ static struct target_ops nto_target_ops = {\n   nto_stopped_data_address,\n   NULL, /* nto_read_offsets */\n   NULL, /* thread_db_set_tls_address */\n-  NULL,\n   hostio_last_error_from_errno,\n   NULL, /* nto_qxfer_osdata */\n   NULL, /* xfer_siginfo */"
    },
    {
      "sha": "67e8e3e54de363ffa77547b79d9ed01f0a4981df",
      "filename": "gdb/gdbserver/server.c",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/server.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/server.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/server.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1613,22 +1613,6 @@ handle_qxfer_siginfo (const char *annex,\n   return (*the_target->qxfer_siginfo) (annex, readbuf, writebuf, offset, len);\n }\n \n-/* Handle qXfer:spu:read and qXfer:spu:write.  */\n-\n-static int\n-handle_qxfer_spu (const char *annex,\n-\t\t  gdb_byte *readbuf, const gdb_byte *writebuf,\n-\t\t  ULONGEST offset, LONGEST len)\n-{\n-  if (the_target->qxfer_spu == NULL)\n-    return -2;\n-\n-  if (current_thread == NULL)\n-    return -1;\n-\n-  return (*the_target->qxfer_spu) (annex, readbuf, writebuf, offset, len);\n-}\n-\n /* Handle qXfer:statictrace:read.  */\n \n static int\n@@ -1985,7 +1969,6 @@ static const struct qxfer qxfer_packets[] =\n     { \"libraries-svr4\", handle_qxfer_libraries_svr4 },\n     { \"osdata\", handle_qxfer_osdata },\n     { \"siginfo\", handle_qxfer_siginfo },\n-    { \"spu\", handle_qxfer_spu },\n     { \"statictrace\", handle_qxfer_statictrace },\n     { \"threads\", handle_qxfer_threads },\n     { \"traceframe-info\", handle_qxfer_traceframe_info },\n@@ -2397,9 +2380,6 @@ handle_query (char *own_buf, int packet_len, int *new_packet_len_p)\n       if (the_target->read_auxv != NULL)\n \tstrcat (own_buf, \";qXfer:auxv:read+\");\n \n-      if (the_target->qxfer_spu != NULL)\n-\tstrcat (own_buf, \";qXfer:spu:read+;qXfer:spu:write+\");\n-\n       if (the_target->qxfer_siginfo != NULL)\n \tstrcat (own_buf, \";qXfer:siginfo:read+;qXfer:siginfo:write+\");\n "
    },
    {
      "sha": "4930c59d73005a83df52f6c435fa62b50b5eedf4",
      "filename": "gdb/gdbserver/spu-low.c",
      "status": "removed",
      "additions": 0,
      "deletions": 732,
      "changes": 732,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/gdbserver/spu-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/gdbserver/spu-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/spu-low.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,732 +0,0 @@\n-/* Low level interface to SPUs, for the remote server for GDB.\n-   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-\n-#include \"gdbsupport/gdb_wait.h\"\n-#include <sys/ptrace.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-#include <sys/syscall.h>\n-#include \"gdbsupport/filestuff.h\"\n-#include \"hostio.h\"\n-#include \"nat/fork-inferior.h\"\n-\n-/* Some older glibc versions do not define this.  */\n-#ifndef __WNOTHREAD\n-#define __WNOTHREAD     0x20000000      /* Don't wait on children of other\n-\t\t\t\t\t   threads in this group */\n-#endif\n-\n-#define PTRACE_TYPE_RET long\n-#define PTRACE_TYPE_ARG3 long\n-\n-/* Number of registers.  */\n-#define SPU_NUM_REGS         130\n-#define SPU_NUM_CORE_REGS    128\n-\n-/* Special registers.  */\n-#define SPU_ID_REGNUM        128\n-#define SPU_PC_REGNUM        129\n-\n-/* PPU side system calls.  */\n-#define INSTR_SC\t0x44000002\n-#define NR_spu_run\t0x0116\n-\n-/* These are used in remote-utils.c.  */\n-int using_threads = 0;\n-\n-/* Defined in auto-generated file reg-spu.c.  */\n-void init_registers_spu (void);\n-extern const struct target_desc *tdesc_spu;\n-\n-/* Software breakpoint instruction.  */\n-static const gdb_byte breakpoint[] = { 0x00, 0x00, 0x3f, 0xff };\n-\n-/* Fetch PPU register REGNO.  */\n-static CORE_ADDR\n-fetch_ppc_register (int regno)\n-{\n-  PTRACE_TYPE_RET res;\n-\n-  int tid = current_ptid.lwp ();\n-\n-#ifndef __powerpc64__\n-  /* If running as a 32-bit process on a 64-bit system, we attempt\n-     to get the full 64-bit register content of the target process.\n-     If the PPC special ptrace call fails, we're on a 32-bit system;\n-     just fall through to the regular ptrace call in that case.  */\n-  {\n-    char buf[8];\n-\n-    errno = 0;\n-    ptrace ((PTRACE_TYPE_ARG1) PPC_PTRACE_PEEKUSR_3264, tid,\n-\t    (PTRACE_TYPE_ARG3) (regno * 8), buf);\n-    if (errno == 0)\n-      ptrace ((PTRACE_TYPE_ARG1) PPC_PTRACE_PEEKUSR_3264, tid,\n-\t      (PTRACE_TYPE_ARG3) (regno * 8 + 4), buf + 4);\n-    if (errno == 0)\n-      return (CORE_ADDR) *(unsigned long long *)buf;\n-  }\n-#endif\n-\n-  errno = 0;\n-  res = ptrace (PT_READ_U, tid,\n-\t\t(PTRACE_TYPE_ARG3) (regno * sizeof (PTRACE_TYPE_RET)), 0);\n-  if (errno != 0)\n-    {\n-      char mess[128];\n-      sprintf (mess, \"reading PPC register #%d\", regno);\n-      perror_with_name (mess);\n-    }\n-\n-  return (CORE_ADDR) (unsigned long) res;\n-}\n-\n-/* Fetch WORD from PPU memory at (aligned) MEMADDR in thread TID.  */\n-static int\n-fetch_ppc_memory_1 (int tid, CORE_ADDR memaddr, PTRACE_TYPE_RET *word)\n-{\n-  errno = 0;\n-\n-#ifndef __powerpc64__\n-  if (memaddr >> 32)\n-    {\n-      unsigned long long addr_8 = (unsigned long long) memaddr;\n-      ptrace ((PTRACE_TYPE_ARG1) PPC_PTRACE_PEEKTEXT_3264, tid,\n-\t      (PTRACE_TYPE_ARG3) &addr_8, word);\n-    }\n-  else\n-#endif\n-    *word = ptrace (PT_READ_I, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, 0);\n-\n-  return errno;\n-}\n-\n-/* Store WORD into PPU memory at (aligned) MEMADDR in thread TID.  */\n-static int\n-store_ppc_memory_1 (int tid, CORE_ADDR memaddr, PTRACE_TYPE_RET word)\n-{\n-  errno = 0;\n-\n-#ifndef __powerpc64__\n-  if (memaddr >> 32)\n-    {\n-      unsigned long long addr_8 = (unsigned long long) memaddr;\n-      ptrace ((PTRACE_TYPE_ARG1) PPC_PTRACE_POKEDATA_3264, tid,\n-\t      (PTRACE_TYPE_ARG3) &addr_8, word);\n-    }\n-  else\n-#endif\n-    ptrace (PT_WRITE_D, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, word);\n-\n-  return errno;\n-}\n-\n-/* Fetch LEN bytes of PPU memory at MEMADDR to MYADDR.  */\n-static int\n-fetch_ppc_memory (CORE_ADDR memaddr, char *myaddr, int len)\n-{\n-  int i, ret;\n-\n-  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);\n-  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)\n-\t       / sizeof (PTRACE_TYPE_RET));\n-  PTRACE_TYPE_RET *buffer;\n-\n-  int tid = current_ptid.lwp ();\n-\n-  buffer = XALLOCAVEC (PTRACE_TYPE_RET, count);\n-  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))\n-    if ((ret = fetch_ppc_memory_1 (tid, addr, &buffer[i])) != 0)\n-      return ret;\n-\n-  memcpy (myaddr,\n-\t  (char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),\n-\t  len);\n-\n-  return 0;\n-}\n-\n-/* Store LEN bytes from MYADDR to PPU memory at MEMADDR.  */\n-static int\n-store_ppc_memory (CORE_ADDR memaddr, char *myaddr, int len)\n-{\n-  int i, ret;\n-\n-  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);\n-  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)\n-\t       / sizeof (PTRACE_TYPE_RET));\n-  PTRACE_TYPE_RET *buffer;\n-\n-  int tid = current_ptid.lwp ();\n-\n-  buffer = XALLOCAVEC (PTRACE_TYPE_RET, count);\n-\n-  if (addr != memaddr || len < (int) sizeof (PTRACE_TYPE_RET))\n-    if ((ret = fetch_ppc_memory_1 (tid, addr, &buffer[0])) != 0)\n-      return ret;\n-\n-  if (count > 1)\n-    if ((ret = fetch_ppc_memory_1 (tid, addr + (count - 1)\n-\t\t\t\t\t       * sizeof (PTRACE_TYPE_RET),\n-\t\t\t\t   &buffer[count - 1])) != 0)\n-      return ret;\n-\n-  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),\n-\t  myaddr, len);\n-\n-  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))\n-    if ((ret = store_ppc_memory_1 (tid, addr, buffer[i])) != 0)\n-      return ret;\n-\n-  return 0;\n-}\n-\n-\n-/* If the PPU thread is currently stopped on a spu_run system call,\n-   return to FD and ADDR the file handle and NPC parameter address\n-   used with the system call.  Return non-zero if successful.  */\n-static int\n-parse_spufs_run (int *fd, CORE_ADDR *addr)\n-{\n-  unsigned int insn;\n-  CORE_ADDR pc = fetch_ppc_register (32);  /* nip */\n-\n-  /* Fetch instruction preceding current NIP.  */\n-  if (fetch_ppc_memory (pc-4, (char *) &insn, 4) != 0)\n-    return 0;\n-  /* It should be a \"sc\" instruction.  */\n-  if (insn != INSTR_SC)\n-    return 0;\n-  /* System call number should be NR_spu_run.  */\n-  if (fetch_ppc_register (0) != NR_spu_run)\n-    return 0;\n-\n-  /* Register 3 contains fd, register 4 the NPC param pointer.  */\n-  *fd = fetch_ppc_register (34);  /* orig_gpr3 */\n-  *addr = fetch_ppc_register (4);\n-  return 1;\n-}\n-\n-\n-/* Copy LEN bytes at OFFSET in spufs file ANNEX into/from READBUF or WRITEBUF,\n-   using the /proc file system.  */\n-static int\n-spu_proc_xfer_spu (const char *annex, unsigned char *readbuf,\n-\t\t   const unsigned char *writebuf,\n-\t\t   CORE_ADDR offset, int len)\n-{\n-  char buf[128];\n-  int fd = 0;\n-  int ret = -1;\n-\n-  if (!annex)\n-    return 0;\n-\n-  sprintf (buf, \"/proc/%ld/fd/%s\", current_ptid.lwp (), annex);\n-  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);\n-  if (fd <= 0)\n-    return -1;\n-\n-  if (offset != 0\n-      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)\n-    {\n-      close (fd);\n-      return 0;\n-    }\n-\n-  if (writebuf)\n-    ret = write (fd, writebuf, (size_t) len);\n-  else if (readbuf)\n-    ret = read (fd, readbuf, (size_t) len);\n-\n-  close (fd);\n-  return ret;\n-}\n-\n-/* Callback to be used when calling fork_inferior, responsible for\n-   actually initiating the tracing of the inferior.  */\n-\n-static void\n-spu_ptrace_fun ()\n-{\n-  if (ptrace (PTRACE_TRACEME, 0, 0, 0) < 0)\n-    trace_start_error_with_name (\"ptrace\");\n-  if (setpgid (0, 0) < 0)\n-    trace_start_error_with_name (\"setpgid\");\n-}\n-\n-/* Start an inferior process and returns its pid.\n-   PROGRAM is the name of the program to be started, and PROGRAM_ARGS\n-   are its arguments.  */\n-\n-static int\n-spu_create_inferior (const char *program,\n-\t\t     const std::vector<char *> &program_args)\n-{\n-  int pid;\n-  ptid_t ptid;\n-  struct process_info *proc;\n-  std::string str_program_args = stringify_argv (program_args);\n-\n-  pid = fork_inferior (program,\n-\t\t       str_program_args.c_str (),\n-\t\t       get_environ ()->envp (), spu_ptrace_fun,\n-\t\t       NULL, NULL, NULL, NULL);\n-\n-  post_fork_inferior (pid, program);\n-\n-  proc = add_process (pid, 0);\n-  proc->tdesc = tdesc_spu;\n-\n-  ptid = ptid_t (pid, pid, 0);\n-  add_thread (ptid, NULL);\n-  return pid;\n-}\n-\n-/* Attach to an inferior process.  */\n-int\n-spu_attach (unsigned long  pid)\n-{\n-  ptid_t ptid;\n-  struct process_info *proc;\n-\n-  if (ptrace (PTRACE_ATTACH, pid, 0, 0) != 0)\n-    {\n-      fprintf (stderr, \"Cannot attach to process %ld: %s (%d)\\n\", pid,\n-\t       strerror (errno), errno);\n-      fflush (stderr);\n-      _exit (0177);\n-    }\n-\n-  proc = add_process (pid, 1);\n-  proc->tdesc = tdesc_spu;\n-  ptid = ptid_t (pid, pid, 0);\n-  add_thread (ptid, NULL);\n-  return 0;\n-}\n-\n-/* Kill the inferior process.  */\n-static int\n-spu_kill (process_info *process)\n-{\n-  int status, ret;\n-  int pid = process->pid;\n-\n-  ptrace (PTRACE_KILL, pid, 0, 0);\n-\n-  do {\n-    ret = waitpid (pid, &status, 0);\n-    if (WIFEXITED (status) || WIFSIGNALED (status))\n-      break;\n-  } while (ret != -1 || errno != ECHILD);\n-\n-  clear_inferiors ();\n-  remove_process (process);\n-  return 0;\n-}\n-\n-/* Detach from inferior process.  */\n-static int\n-spu_detach (process_info *process)\n-{\n-  ptrace (PTRACE_DETACH, process->pid, 0, 0);\n-\n-  clear_inferiors ();\n-  remove_process (process);\n-  return 0;\n-}\n-\n-static void\n-spu_mourn (struct process_info *process)\n-{\n-  remove_process (process);\n-}\n-\n-static void\n-spu_join (int pid)\n-{\n-  int status, ret;\n-\n-  do {\n-    ret = waitpid (pid, &status, 0);\n-    if (WIFEXITED (status) || WIFSIGNALED (status))\n-      break;\n-  } while (ret != -1 || errno != ECHILD);\n-}\n-\n-/* Return nonzero if the given thread is still alive.  */\n-static int\n-spu_thread_alive (ptid_t ptid)\n-{\n-  return ptid == current_ptid;\n-}\n-\n-/* Resume process.  */\n-static void\n-spu_resume (struct thread_resume *resume_info, size_t n)\n-{\n-  struct thread_info *thr = get_first_thread ();\n-  size_t i;\n-\n-  for (i = 0; i < n; i++)\n-    if (resume_info[i].thread == minus_one_ptid\n-\t|| resume_info[i].thread == ptid_of (thr))\n-      break;\n-\n-  if (i == n)\n-    return;\n-\n-  /* We don't support hardware single-stepping right now, assume\n-     GDB knows to use software single-stepping.  */\n-  if (resume_info[i].kind == resume_step)\n-    fprintf (stderr, \"Hardware single-step not supported.\\n\");\n-\n-  regcache_invalidate ();\n-\n-  errno = 0;\n-  ptrace (PTRACE_CONT, ptid_of (thr).lwp (), 0, resume_info[i].sig);\n-  if (errno)\n-    perror_with_name (\"ptrace\");\n-}\n-\n-/* Wait for process, returns status.  */\n-static ptid_t\n-spu_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int options)\n-{\n-  int pid = ptid.pid ();\n-  int w;\n-  int ret;\n-\n-  while (1)\n-    {\n-      ret = waitpid (pid, &w, WNOHANG | __WALL | __WNOTHREAD);\n-\n-      if (ret == -1)\n-\t{\n-\t  if (errno != ECHILD)\n-\t    perror_with_name (\"waitpid\");\n-\t}\n-      else if (ret > 0)\n-\tbreak;\n-\n-      usleep (1000);\n-    }\n-\n-  /* On the first wait, continue running the inferior until we are\n-     blocked inside an spu_run system call.  */\n-  if (!server_waiting)\n-    {\n-      int fd;\n-      CORE_ADDR addr;\n-\n-      while (!parse_spufs_run (&fd, &addr))\n-\t{\n-\t  ptrace (PT_SYSCALL, pid, (PTRACE_TYPE_ARG3) 0, 0);\n-\t  waitpid (pid, NULL, __WALL | __WNOTHREAD);\n-\t}\n-    }\n-\n-  if (WIFEXITED (w))\n-    {\n-      fprintf (stderr, \"\\nChild exited with retcode = %x \\n\", WEXITSTATUS (w));\n-      ourstatus->kind =  TARGET_WAITKIND_EXITED;\n-      ourstatus->value.integer = WEXITSTATUS (w);\n-      clear_inferiors ();\n-      return ptid_t (ret);\n-    }\n-  else if (!WIFSTOPPED (w))\n-    {\n-      fprintf (stderr, \"\\nChild terminated with signal = %x \\n\", WTERMSIG (w));\n-      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (w));\n-      clear_inferiors ();\n-      return ptid_t (ret);\n-    }\n-\n-  /* After attach, we may have received a SIGSTOP.  Do not return this\n-     as signal to GDB, or else it will try to continue with SIGSTOP ...  */\n-  if (!server_waiting)\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_0;\n-      return ptid_t (ret, ret, 0);\n-    }\n-\n-  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-  ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));\n-  return ptid_t (ret, ret, 0);\n-}\n-\n-/* Fetch inferior registers.  */\n-static void\n-spu_fetch_registers (struct regcache *regcache, int regno)\n-{\n-  int fd;\n-  CORE_ADDR addr;\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return;\n-\n-  /* The ID register holds the spufs file handle.  */\n-  if (regno == -1 || regno == SPU_ID_REGNUM)\n-    supply_register (regcache, SPU_ID_REGNUM, (char *)&fd);\n-\n-  /* The NPC register is found at ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      char buf[4];\n-      if (fetch_ppc_memory (addr, buf, 4) == 0)\n-\tsupply_register (regcache, SPU_PC_REGNUM, buf);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_CORE_REGS))\n-    {\n-      unsigned char buf[16*SPU_NUM_CORE_REGS];\n-      char annex[32];\n-      int i;\n-\n-      sprintf (annex, \"%d/regs\", fd);\n-      if (spu_proc_xfer_spu (annex, buf, NULL, 0, sizeof buf) == sizeof buf)\n-\tfor (i = 0; i < SPU_NUM_CORE_REGS; i++)\n-\t  supply_register (regcache, i, buf + i*16);\n-    }\n-}\n-\n-/* Store inferior registers.  */\n-static void\n-spu_store_registers (struct regcache *regcache, int regno)\n-{\n-  int fd;\n-  CORE_ADDR addr;\n-\n-  /* ??? Some callers use 0 to mean all registers.  */\n-  if (regno == 0)\n-    regno = -1;\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return;\n-\n-  /* The NPC register is found at ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      char buf[4];\n-      collect_register (regcache, SPU_PC_REGNUM, buf);\n-      store_ppc_memory (addr, buf, 4);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_CORE_REGS))\n-    {\n-      unsigned char buf[16*SPU_NUM_CORE_REGS];\n-      char annex[32];\n-      int i;\n-\n-      for (i = 0; i < SPU_NUM_CORE_REGS; i++)\n-\tcollect_register (regcache, i, buf + i*16);\n-\n-      sprintf (annex, \"%d/regs\", fd);\n-      spu_proc_xfer_spu (annex, NULL, buf, 0, sizeof buf);\n-    }\n-}\n-\n-/* Copy LEN bytes from inferior's memory starting at MEMADDR\n-   to debugger memory starting at MYADDR.  */\n-static int\n-spu_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)\n-{\n-  int fd, ret;\n-  CORE_ADDR addr;\n-  char annex[32], lslr_annex[32], buf[32];\n-  CORE_ADDR lslr;\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return 0;\n-\n-  /* Use the \"mem\" spufs file to access SPU local store.  */\n-  sprintf (annex, \"%d/mem\", fd);\n-  ret = spu_proc_xfer_spu (annex, myaddr, NULL, memaddr, len);\n-  if (ret > 0)\n-    return ret == len ? 0 : EIO;\n-\n-  /* SPU local store access wraps the address around at the\n-     local store limit.  We emulate this here.  To avoid needing\n-     an extra access to retrieve the LSLR, we only do that after\n-     trying the original address first, and getting end-of-file.  */\n-  sprintf (lslr_annex, \"%d/lslr\", fd);\n-  memset (buf, 0, sizeof buf);\n-  if (spu_proc_xfer_spu (lslr_annex, (unsigned char *)buf, NULL,\n-\t\t\t 0, sizeof buf) <= 0)\n-    return ret;\n-\n-  lslr = strtoul (buf, NULL, 16);\n-  ret = spu_proc_xfer_spu (annex, myaddr, NULL, memaddr & lslr, len);\n-\n-  return ret == len ? 0 : EIO;\n-}\n-\n-/* Copy LEN bytes of data from debugger memory at MYADDR\n-   to inferior's memory at MEMADDR.\n-   On failure (cannot write the inferior)\n-   returns the value of errno.  */\n-static int\n-spu_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)\n-{\n-  int fd, ret;\n-  CORE_ADDR addr;\n-  char annex[32], lslr_annex[32], buf[32];\n-  CORE_ADDR lslr;\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return 0;\n-\n-  /* Use the \"mem\" spufs file to access SPU local store.  */\n-  sprintf (annex, \"%d/mem\", fd);\n-  ret = spu_proc_xfer_spu (annex, NULL, myaddr, memaddr, len);\n-  if (ret > 0)\n-    return ret == len ? 0 : EIO;\n-\n-  /* SPU local store access wraps the address around at the\n-     local store limit.  We emulate this here.  To avoid needing\n-     an extra access to retrieve the LSLR, we only do that after\n-     trying the original address first, and getting end-of-file.  */\n-  sprintf (lslr_annex, \"%d/lslr\", fd);\n-  memset (buf, 0, sizeof buf);\n-  if (spu_proc_xfer_spu (lslr_annex, (unsigned char *)buf, NULL,\n-\t\t\t 0, sizeof buf) <= 0)\n-    return ret;\n-\n-  lslr = strtoul (buf, NULL, 16);\n-  ret = spu_proc_xfer_spu (annex, NULL, myaddr, memaddr & lslr, len);\n-\n-  return ret == len ? 0 : EIO;\n-}\n-\n-/* Look up special symbols -- unneded here.  */\n-static void\n-spu_look_up_symbols (void)\n-{\n-}\n-\n-/* Send signal to inferior.  */\n-static void\n-spu_request_interrupt (void)\n-{\n-  struct thread_info *thr = get_first_thread ();\n-\n-  syscall (SYS_tkill, lwpid_of (thr), SIGINT);\n-}\n-\n-/* Implementation of the target_ops method \"sw_breakpoint_from_kind\".  */\n-\n-static const gdb_byte *\n-spu_sw_breakpoint_from_kind (int kind, int *size)\n-{\n-  *size = sizeof breakpoint;\n-  return breakpoint;\n-}\n-\n-static struct target_ops spu_target_ops = {\n-  spu_create_inferior,\n-  NULL,  /* post_create_inferior */\n-  spu_attach,\n-  spu_kill,\n-  spu_detach,\n-  spu_mourn,\n-  spu_join,\n-  spu_thread_alive,\n-  spu_resume,\n-  spu_wait,\n-  spu_fetch_registers,\n-  spu_store_registers,\n-  NULL, /* prepare_to_access_memory */\n-  NULL, /* done_accessing_memory */\n-  spu_read_memory,\n-  spu_write_memory,\n-  spu_look_up_symbols,\n-  spu_request_interrupt,\n-  NULL,\n-  NULL,  /* supports_z_point_type */\n-  NULL,\n-  NULL,\n-  NULL, /* stopped_by_sw_breakpoint */\n-  NULL, /* supports_stopped_by_sw_breakpoint */\n-  NULL, /* stopped_by_hw_breakpoint */\n-  NULL, /* supports_stopped_by_hw_breakpoint */\n-  NULL, /* supports_hardware_single_step */\n-  NULL,\n-  NULL,\n-  NULL,\n-  NULL,\n-  spu_proc_xfer_spu,\n-  hostio_last_error_from_errno,\n-  NULL, /* qxfer_osdata */\n-  NULL, /* qxfer_siginfo */\n-  NULL, /* supports_non_stop */\n-  NULL, /* async */\n-  NULL, /* start_non_stop */\n-  NULL, /* supports_multi_process */\n-  NULL, /* supports_fork_events */\n-  NULL, /* supports_vfork_events */\n-  NULL, /* supports_exec_events */\n-  NULL, /* handle_new_gdb_connection */\n-  NULL, /* handle_monitor_command */\n-  NULL, /* core_of_thread */\n-  NULL, /* read_loadmap */\n-  NULL, /* process_qsupported */\n-  NULL, /* supports_tracepoints */\n-  NULL, /* read_pc */\n-  NULL, /* write_pc */\n-  NULL, /* thread_stopped */\n-  NULL, /* get_tib_address */\n-  NULL, /* pause_all */\n-  NULL, /* unpause_all */\n-  NULL, /* stabilize_threads */\n-  NULL, /* install_fast_tracepoint_jump_pad */\n-  NULL, /* emit_ops */\n-  NULL, /* supports_disable_randomization */\n-  NULL, /* get_min_fast_tracepoint_insn_len */\n-  NULL, /* qxfer_libraries_svr4 */\n-  NULL, /* support_agent */\n-  NULL, /* enable_btrace */\n-  NULL, /* disable_btrace */\n-  NULL, /* read_btrace */\n-  NULL, /* read_btrace_conf */\n-  NULL, /* supports_range_stepping */\n-  NULL, /* pid_to_exec_file */\n-  NULL, /* multifs_open */\n-  NULL, /* multifs_unlink */\n-  NULL, /* multifs_readlink */\n-  NULL, /* breakpoint_kind_from_pc */\n-  spu_sw_breakpoint_from_kind,\n-};\n-\n-void\n-initialize_low (void)\n-{\n-  set_target_ops (&spu_target_ops);\n-  init_registers_spu ();\n-}"
    },
    {
      "sha": "2df135a7696c0800f483365add1973203d086f97",
      "filename": "gdb/gdbserver/target.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/target.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -256,10 +256,6 @@ struct target_ops\n   int (*get_tls_address) (struct thread_info *thread, CORE_ADDR offset,\n \t\t\t  CORE_ADDR load_module, CORE_ADDR *address);\n \n-   /* Read/Write from/to spufs using qXfer packets.  */\n-  int (*qxfer_spu) (const char *annex, unsigned char *readbuf,\n-\t\t    unsigned const char *writebuf, CORE_ADDR offset, int len);\n-\n   /* Fill BUF with an hostio error packet representing the last hostio\n      error.  */\n   void (*hostio_last_error) (char *buf);"
    },
    {
      "sha": "7088ba4dd17d846af7d09f0ac0a1501955782116",
      "filename": "gdb/gdbserver/win32-low.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/win32-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/gdbserver/win32-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/win32-low.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1809,7 +1809,6 @@ static struct target_ops win32_target_ops = {\n   win32_stopped_data_address,\n   NULL, /* read_offsets */\n   NULL, /* get_tls_address */\n-  NULL, /* qxfer_spu */\n #ifdef _WIN32_WCE\n   wince_hostio_last_error,\n #else"
    },
    {
      "sha": "cd5cf1830d3fdc1ed4f48b7571f30538cb35dc4e",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 129,
      "changes": 129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -68,10 +68,6 @@\n #include \"gdbsupport/fileio.h\"\n #include \"gdbsupport/scope-exit.h\"\n \n-#ifndef SPUFS_MAGIC\n-#define SPUFS_MAGIC 0x23c9b64e\n-#endif\n-\n /* This comment documents high-level logic of this file.\n \n Waiting for events in sync mode\n@@ -3841,12 +3837,6 @@ linux_nat_xfer_osdata (enum target_object object,\n \t\t       const gdb_byte *writebuf, ULONGEST offset, ULONGEST len,\n \t\t       ULONGEST *xfered_len);\n \n-static enum target_xfer_status\n-linux_proc_xfer_spu (enum target_object object,\n-\t\t     const char *annex, gdb_byte *readbuf,\n-\t\t     const gdb_byte *writebuf,\n-\t\t     ULONGEST offset, ULONGEST len, ULONGEST *xfered_len);\n-\n static enum target_xfer_status\n linux_proc_xfer_partial (enum target_object object,\n \t\t\t const char *annex, gdb_byte *readbuf,\n@@ -3879,10 +3869,6 @@ linux_nat_target::xfer_partial (enum target_object object,\n     return linux_nat_xfer_osdata (object, annex, readbuf, writebuf,\n \t\t\t\t  offset, len, xfered_len);\n \n-  if (object == TARGET_OBJECT_SPU)\n-    return linux_proc_xfer_spu (object, annex, readbuf, writebuf,\n-\t\t\t\toffset, len, xfered_len);\n-\n   /* GDB calculates all addresses in the largest possible address\n      width.\n      The address width must be masked before its final use - either by\n@@ -4020,121 +4006,6 @@ linux_proc_xfer_partial (enum target_object object,\n }\n \n \n-/* Enumerate spufs IDs for process PID.  */\n-static LONGEST\n-spu_enumerate_spu_ids (int pid, gdb_byte *buf, ULONGEST offset, ULONGEST len)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-  LONGEST pos = 0;\n-  LONGEST written = 0;\n-  char path[128];\n-  DIR *dir;\n-  struct dirent *entry;\n-\n-  xsnprintf (path, sizeof path, \"/proc/%d/fd\", pid);\n-  dir = opendir (path);\n-  if (!dir)\n-    return -1;\n-\n-  rewinddir (dir);\n-  while ((entry = readdir (dir)) != NULL)\n-    {\n-      struct stat st;\n-      struct statfs stfs;\n-      int fd;\n-\n-      fd = atoi (entry->d_name);\n-      if (!fd)\n-\tcontinue;\n-\n-      xsnprintf (path, sizeof path, \"/proc/%d/fd/%d\", pid, fd);\n-      if (stat (path, &st) != 0)\n-\tcontinue;\n-      if (!S_ISDIR (st.st_mode))\n-\tcontinue;\n-\n-      if (statfs (path, &stfs) != 0)\n-\tcontinue;\n-      if (stfs.f_type != SPUFS_MAGIC)\n-\tcontinue;\n-\n-      if (pos >= offset && pos + 4 <= offset + len)\n-\t{\n-\t  store_unsigned_integer (buf + pos - offset, 4, byte_order, fd);\n-\t  written += 4;\n-\t}\n-      pos += 4;\n-    }\n-\n-  closedir (dir);\n-  return written;\n-}\n-\n-/* Implement the to_xfer_partial interface for the TARGET_OBJECT_SPU\n-   object type, using the /proc file system.  */\n-\n-static enum target_xfer_status\n-linux_proc_xfer_spu (enum target_object object,\n-\t\t     const char *annex, gdb_byte *readbuf,\n-\t\t     const gdb_byte *writebuf,\n-\t\t     ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)\n-{\n-  char buf[128];\n-  int fd = 0;\n-  int ret = -1;\n-  int pid = inferior_ptid.lwp ();\n-\n-  if (!annex)\n-    {\n-      if (!readbuf)\n-\treturn TARGET_XFER_E_IO;\n-      else\n-\t{\n-\t  LONGEST l = spu_enumerate_spu_ids (pid, readbuf, offset, len);\n-\n-\t  if (l < 0)\n-\t    return TARGET_XFER_E_IO;\n-\t  else if (l == 0)\n-\t    return TARGET_XFER_EOF;\n-\t  else\n-\t    {\n-\t      *xfered_len = (ULONGEST) l;\n-\t      return TARGET_XFER_OK;\n-\t    }\n-\t}\n-    }\n-\n-  xsnprintf (buf, sizeof buf, \"/proc/%d/fd/%s\", pid, annex);\n-  fd = gdb_open_cloexec (buf, writebuf? O_WRONLY : O_RDONLY, 0);\n-  if (fd <= 0)\n-    return TARGET_XFER_E_IO;\n-\n-  if (offset != 0\n-      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)\n-    {\n-      close (fd);\n-      return TARGET_XFER_EOF;\n-    }\n-\n-  if (writebuf)\n-    ret = write (fd, writebuf, (size_t) len);\n-  else if (readbuf)\n-    ret = read (fd, readbuf, (size_t) len);\n-\n-  close (fd);\n-\n-  if (ret < 0)\n-    return TARGET_XFER_E_IO;\n-  else if (ret == 0)\n-    return TARGET_XFER_EOF;\n-  else\n-    {\n-      *xfered_len = (ULONGEST) ret;\n-      return TARGET_XFER_OK;\n-    }\n-}\n-\n-\n /* Parse LINE as a signal set and add its set bits to SIGS.  */\n \n static void"
    },
    {
      "sha": "567b01c5d15cf1b9576f370a6548f06824b8bc4a",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 72,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1413,73 +1413,6 @@ find_signalled_thread (struct thread_info *info, void *data)\n   return 0;\n }\n \n-/* Generate corefile notes for SPU contexts.  */\n-\n-static char *\n-linux_spu_make_corefile_notes (bfd *obfd, char *note_data, int *note_size)\n-{\n-  static const char *spu_files[] =\n-    {\n-      \"object-id\",\n-      \"mem\",\n-      \"regs\",\n-      \"fpcr\",\n-      \"lslr\",\n-      \"decr\",\n-      \"decr_status\",\n-      \"signal1\",\n-      \"signal1_type\",\n-      \"signal2\",\n-      \"signal2_type\",\n-      \"event_mask\",\n-      \"event_status\",\n-      \"mbox_info\",\n-      \"ibox_info\",\n-      \"wbox_info\",\n-      \"dma_info\",\n-      \"proxydma_info\",\n-   };\n-\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-\n-  /* Determine list of SPU ids.  */\n-  gdb::optional<gdb::byte_vector>\n-    spu_ids = target_read_alloc (current_top_target (),\n-\t\t\t\t TARGET_OBJECT_SPU, NULL);\n-\n-  if (!spu_ids)\n-    return note_data;\n-\n-  /* Generate corefile notes for each SPU file.  */\n-  for (size_t i = 0; i < spu_ids->size (); i += 4)\n-    {\n-      int fd = extract_unsigned_integer (spu_ids->data () + i, 4, byte_order);\n-\n-      for (size_t j = 0; j < sizeof (spu_files) / sizeof (spu_files[0]); j++)\n-\t{\n-\t  char annex[32], note_name[32];\n-\n-\t  xsnprintf (annex, sizeof annex, \"%d/%s\", fd, spu_files[j]);\n-\t  gdb::optional<gdb::byte_vector> spu_data\n-\t    = target_read_alloc (current_top_target (), TARGET_OBJECT_SPU, annex);\n-\n-\t  if (spu_data && !spu_data->empty ())\n-\t    {\n-\t      xsnprintf (note_name, sizeof note_name, \"SPU/%s\", annex);\n-\t      note_data = elfcore_write_note (obfd, note_data, note_size,\n-\t\t\t\t\t      note_name, NT_SPU,\n-\t\t\t\t\t      spu_data->data (),\n-\t\t\t\t\t      spu_data->size ());\n-\n-\t      if (!note_data)\n-\t\treturn nullptr;\n-\t    }\n-\t}\n-    }\n-\n-  return note_data;\n-}\n-\n /* This is used to pass information from\n    linux_make_mappings_corefile_notes through\n    linux_find_memory_regions_full.  */\n@@ -2008,11 +1941,6 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \treturn NULL;\n     }\n \n-  /* SPU information.  */\n-  note_data = linux_spu_make_corefile_notes (obfd, note_data, note_size);\n-  if (!note_data)\n-    return NULL;\n-\n   /* File mappings.  */\n   note_data = linux_make_mappings_corefile_notes (gdbarch, obfd,\n \t\t\t\t\t\t  note_data, note_size);"
    },
    {
      "sha": "508395cdb2d6a0071d9c2cf3667a3087bc8523d1",
      "filename": "gdb/nat/ppc-linux.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/nat/ppc-linux.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/nat/ppc-linux.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/ppc-linux.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -33,9 +33,6 @@\n    If they aren't, we can provide them ourselves (their values are fixed\n    because they are part of the kernel ABI).  They are used in the AT_HWCAP\n    entry of the AUXV.  */\n-#ifndef PPC_FEATURE_CELL\n-#define PPC_FEATURE_CELL 0x00010000\n-#endif\n #ifndef PPC_FEATURE_BOOKE\n #define PPC_FEATURE_BOOKE 0x00008000\n #endif"
    },
    {
      "sha": "53406f61c8ed806c926503b8c56e44ea492577f2",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -2646,9 +2646,6 @@ ppc_linux_nat_target::read_description ()\n \tperror_with_name (_(\"Unable to fetch AltiVec registers\"));\n     }\n \n-  if (hwcap & PPC_FEATURE_CELL)\n-    features.cell = true;\n-\n   features.isa205 = ppc_linux_has_isa205 (hwcap);\n \n   if ((hwcap2 & PPC_FEATURE2_DSCR)"
    },
    {
      "sha": "ce3c727371f07f7e7d79751001ca32337ae20334",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 317,
      "changes": 317,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -31,7 +31,6 @@\n #include \"osabi.h\"\n #include \"regset.h\"\n #include \"solib-svr4.h\"\n-#include \"solib-spu.h\"\n #include \"solib.h\"\n #include \"solist.h\"\n #include \"ppc-tdep.h\"\n@@ -48,7 +47,6 @@\n #include \"elf/common.h\"\n #include \"elf/ppc64.h\"\n #include \"arch-utils.h\"\n-#include \"spu-tdep.h\"\n #include \"xml-syscall.h\"\n #include \"linux-tdep.h\"\n #include \"linux-record.h\"\n@@ -66,7 +64,6 @@\n \n #include \"features/rs6000/powerpc-32l.c\"\n #include \"features/rs6000/powerpc-altivec32l.c\"\n-#include \"features/rs6000/powerpc-cell32l.c\"\n #include \"features/rs6000/powerpc-vsx32l.c\"\n #include \"features/rs6000/powerpc-isa205-32l.c\"\n #include \"features/rs6000/powerpc-isa205-altivec32l.c\"\n@@ -76,7 +73,6 @@\n #include \"features/rs6000/powerpc-isa207-htm-vsx32l.c\"\n #include \"features/rs6000/powerpc-64l.c\"\n #include \"features/rs6000/powerpc-altivec64l.c\"\n-#include \"features/rs6000/powerpc-cell64l.c\"\n #include \"features/rs6000/powerpc-vsx64l.c\"\n #include \"features/rs6000/powerpc-isa205-64l.c\"\n #include \"features/rs6000/powerpc-isa205-altivec64l.c\"\n@@ -1555,19 +1551,12 @@ ppc_linux_write_pc (struct regcache *regcache, CORE_ADDR pc)\n     regcache_cooked_write_unsigned (regcache, PPC_TRAP_REGNUM, -1);\n }\n \n-static int\n-ppc_linux_spu_section (bfd *abfd, asection *asect, void *user_data)\n-{\n-  return startswith (bfd_section_name (asect), \"SPU/\");\n-}\n-\n static const struct target_desc *\n ppc_linux_core_read_description (struct gdbarch *gdbarch,\n \t\t\t\t struct target_ops *target,\n \t\t\t\t bfd *abfd)\n {\n   struct ppc_linux_features features = ppc_linux_no_features;\n-  asection *cell = bfd_sections_find_if (abfd, ppc_linux_spu_section, NULL);\n   asection *altivec = bfd_get_section_by_name (abfd, \".reg-ppc-vmx\");\n   asection *vsx = bfd_get_section_by_name (abfd, \".reg-ppc-vsx\");\n   asection *section = bfd_get_section_by_name (abfd, \".reg\");\n@@ -1592,9 +1581,6 @@ ppc_linux_core_read_description (struct gdbarch *gdbarch,\n       return NULL;\n     }\n \n-  if (cell)\n-    features.cell = true;\n-\n   if (altivec)\n     features.altivec = true;\n \n@@ -1743,287 +1729,6 @@ ppc_stap_parse_special_token (struct gdbarch *gdbarch,\n   return 1;\n }\n \n-/* Cell/B.E. active SPE context tracking support.  */\n-\n-static struct objfile *spe_context_objfile = NULL;\n-static CORE_ADDR spe_context_lm_addr = 0;\n-static CORE_ADDR spe_context_offset = 0;\n-\n-static ptid_t spe_context_cache_ptid;\n-static CORE_ADDR spe_context_cache_address;\n-\n-/* Hook into inferior_created, solib_loaded, and solib_unloaded observers\n-   to track whether we've loaded a version of libspe2 (as static or dynamic\n-   library) that provides the __spe_current_active_context variable.  */\n-static void\n-ppc_linux_spe_context_lookup (struct objfile *objfile)\n-{\n-  struct bound_minimal_symbol sym;\n-\n-  if (!objfile)\n-    {\n-      spe_context_objfile = NULL;\n-      spe_context_lm_addr = 0;\n-      spe_context_offset = 0;\n-      spe_context_cache_ptid = minus_one_ptid;\n-      spe_context_cache_address = 0;\n-      return;\n-    }\n-\n-  sym = lookup_minimal_symbol (\"__spe_current_active_context\", NULL, objfile);\n-  if (sym.minsym)\n-    {\n-      spe_context_objfile = objfile;\n-      spe_context_lm_addr = svr4_fetch_objfile_link_map (objfile);\n-      spe_context_offset = MSYMBOL_VALUE_RAW_ADDRESS (sym.minsym);\n-      spe_context_cache_ptid = minus_one_ptid;\n-      spe_context_cache_address = 0;\n-      return;\n-    }\n-}\n-\n-static void\n-ppc_linux_spe_context_inferior_created (struct target_ops *t, int from_tty)\n-{\n-  ppc_linux_spe_context_lookup (NULL);\n-  for (objfile *objfile : current_program_space->objfiles ())\n-    ppc_linux_spe_context_lookup (objfile);\n-}\n-\n-static void\n-ppc_linux_spe_context_solib_loaded (struct so_list *so)\n-{\n-  if (strstr (so->so_original_name, \"/libspe\") != NULL)\n-    {\n-      solib_read_symbols (so, 0);\n-      ppc_linux_spe_context_lookup (so->objfile);\n-    }\n-}\n-\n-static void\n-ppc_linux_spe_context_solib_unloaded (struct so_list *so)\n-{\n-  if (so->objfile == spe_context_objfile)\n-    ppc_linux_spe_context_lookup (NULL);\n-}\n-\n-/* Retrieve contents of the N'th element in the current thread's\n-   linked SPE context list into ID and NPC.  Return the address of\n-   said context element, or 0 if not found.  */\n-static CORE_ADDR\n-ppc_linux_spe_context (int wordsize, enum bfd_endian byte_order,\n-\t\t       int n, int *id, unsigned int *npc)\n-{\n-  CORE_ADDR spe_context = 0;\n-  gdb_byte buf[16];\n-  int i;\n-\n-  /* Quick exit if we have not found __spe_current_active_context.  */\n-  if (!spe_context_objfile)\n-    return 0;\n-\n-  /* Look up cached address of thread-local variable.  */\n-  if (spe_context_cache_ptid != inferior_ptid)\n-    {\n-      struct target_ops *target = current_top_target ();\n-\n-      try\n-\t{\n-\t  /* We do not call target_translate_tls_address here, because\n-\t     svr4_fetch_objfile_link_map may invalidate the frame chain,\n-\t     which must not do while inside a frame sniffer.\n-\n-\t     Instead, we have cached the lm_addr value, and use that to\n-\t     directly call the target's to_get_thread_local_address.  */\n-\t  spe_context_cache_address\n-\t    = target->get_thread_local_address (inferior_ptid,\n-\t\t\t\t\t\tspe_context_lm_addr,\n-\t\t\t\t\t\tspe_context_offset);\n-\t  spe_context_cache_ptid = inferior_ptid;\n-\t}\n-\n-      catch (const gdb_exception_error &ex)\n-\t{\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* Read variable value.  */\n-  if (target_read_memory (spe_context_cache_address, buf, wordsize) == 0)\n-    spe_context = extract_unsigned_integer (buf, wordsize, byte_order);\n-\n-  /* Cyle through to N'th linked list element.  */\n-  for (i = 0; i < n && spe_context; i++)\n-    if (target_read_memory (spe_context + align_up (12, wordsize),\n-\t\t\t    buf, wordsize) == 0)\n-      spe_context = extract_unsigned_integer (buf, wordsize, byte_order);\n-    else\n-      spe_context = 0;\n-\n-  /* Read current context.  */\n-  if (spe_context\n-      && target_read_memory (spe_context, buf, 12) != 0)\n-    spe_context = 0;\n-\n-  /* Extract data elements.  */\n-  if (spe_context)\n-    {\n-      if (id)\n-\t*id = extract_signed_integer (buf, 4, byte_order);\n-      if (npc)\n-\t*npc = extract_unsigned_integer (buf + 4, 4, byte_order);\n-    }\n-\n-  return spe_context;\n-}\n-\n-\n-/* Cell/B.E. cross-architecture unwinder support.  */\n-\n-struct ppu2spu_cache\n-{\n-  struct frame_id frame_id;\n-  readonly_detached_regcache *regcache;\n-};\n-\n-static struct gdbarch *\n-ppu2spu_prev_arch (struct frame_info *this_frame, void **this_cache)\n-{\n-  struct ppu2spu_cache *cache = (struct ppu2spu_cache *) *this_cache;\n-  return cache->regcache->arch ();\n-}\n-\n-static void\n-ppu2spu_this_id (struct frame_info *this_frame,\n-\t\t void **this_cache, struct frame_id *this_id)\n-{\n-  struct ppu2spu_cache *cache = (struct ppu2spu_cache *) *this_cache;\n-  *this_id = cache->frame_id;\n-}\n-\n-static struct value *\n-ppu2spu_prev_register (struct frame_info *this_frame,\n-\t\t       void **this_cache, int regnum)\n-{\n-  struct ppu2spu_cache *cache = (struct ppu2spu_cache *) *this_cache;\n-  struct gdbarch *gdbarch = cache->regcache->arch ();\n-  gdb_byte *buf;\n-\n-  buf = (gdb_byte *) alloca (register_size (gdbarch, regnum));\n-\n-  cache->regcache->cooked_read (regnum, buf);\n-  return frame_unwind_got_bytes (this_frame, regnum, buf);\n-}\n-\n-struct ppu2spu_data\n-{\n-  struct gdbarch *gdbarch;\n-  int id;\n-  unsigned int npc;\n-  gdb_byte gprs[128*16];\n-};\n-\n-static enum register_status\n-ppu2spu_unwind_register (ppu2spu_data *data, int regnum, gdb_byte *buf)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (data->gdbarch);\n-\n-  if (regnum >= 0 && regnum < SPU_NUM_GPRS)\n-    memcpy (buf, data->gprs + 16*regnum, 16);\n-  else if (regnum == SPU_ID_REGNUM)\n-    store_unsigned_integer (buf, 4, byte_order, data->id);\n-  else if (regnum == SPU_PC_REGNUM)\n-    store_unsigned_integer (buf, 4, byte_order, data->npc);\n-  else\n-    return REG_UNAVAILABLE;\n-\n-  return REG_VALID;\n-}\n-\n-static int\n-ppu2spu_sniffer (const struct frame_unwind *self,\n-\t\t struct frame_info *this_frame, void **this_prologue_cache)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct ppu2spu_data data;\n-  struct frame_info *fi;\n-  CORE_ADDR base, func, backchain, spe_context;\n-  gdb_byte buf[8];\n-  int n = 0;\n-\n-  /* Count the number of SPU contexts already in the frame chain.  */\n-  for (fi = get_next_frame (this_frame); fi; fi = get_next_frame (fi))\n-    if (get_frame_type (fi) == ARCH_FRAME\n-\t&& gdbarch_bfd_arch_info (get_frame_arch (fi))->arch == bfd_arch_spu)\n-      n++;\n-\n-  base = get_frame_sp (this_frame);\n-  func = get_frame_pc (this_frame);\n-  if (target_read_memory (base, buf, tdep->wordsize))\n-    return 0;\n-  backchain = extract_unsigned_integer (buf, tdep->wordsize, byte_order);\n-\n-  spe_context = ppc_linux_spe_context (tdep->wordsize, byte_order,\n-\t\t\t\t       n, &data.id, &data.npc);\n-  if (spe_context && base <= spe_context && spe_context < backchain)\n-    {\n-      char annex[32];\n-\n-      /* Find gdbarch for SPU.  */\n-      struct gdbarch_info info;\n-      gdbarch_info_init (&info);\n-      info.bfd_arch_info = bfd_lookup_arch (bfd_arch_spu, bfd_mach_spu);\n-      info.byte_order = BFD_ENDIAN_BIG;\n-      info.osabi = GDB_OSABI_LINUX;\n-      info.id = &data.id;\n-      data.gdbarch = gdbarch_find_by_info (info);\n-      if (!data.gdbarch)\n-\treturn 0;\n-\n-      xsnprintf (annex, sizeof annex, \"%d/regs\", data.id);\n-      if (target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t       data.gprs, 0, sizeof data.gprs)\n-\t  == sizeof data.gprs)\n-\t{\n-\t  auto cooked_read = [&data] (int regnum, gdb_byte *out_buf)\n-\t    {\n-\t      return ppu2spu_unwind_register (&data, regnum, out_buf);\n-\t    };\n-\t  struct ppu2spu_cache *cache\n-\t    = FRAME_OBSTACK_CALLOC (1, struct ppu2spu_cache);\n-\t  std::unique_ptr<readonly_detached_regcache> regcache\n-\t    (new readonly_detached_regcache (data.gdbarch, cooked_read));\n-\n-\t  cache->frame_id = frame_id_build (base, func);\n-\t  cache->regcache = regcache.release ();\n-\t  *this_prologue_cache = cache;\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-static void\n-ppu2spu_dealloc_cache (struct frame_info *self, void *this_cache)\n-{\n-  struct ppu2spu_cache *cache = (struct ppu2spu_cache *) this_cache;\n-  delete cache->regcache;\n-}\n-\n-static const struct frame_unwind ppu2spu_unwind = {\n-  ARCH_FRAME,\n-  default_frame_unwind_stop_reason,\n-  ppu2spu_this_id,\n-  ppu2spu_prev_register,\n-  NULL,\n-  ppu2spu_sniffer,\n-  ppu2spu_dealloc_cache,\n-  ppu2spu_prev_arch,\n-};\n-\n /* Initialize linux_record_tdep if not initialized yet.\n    WORDSIZE is 4 or 8 for 32- or 64-bit PowerPC Linux respectively.\n    Sizes of data structures are initialized accordingly.  */\n@@ -2439,21 +2144,6 @@ ppc_linux_init_abi (struct gdbarch_info info,\n \t}\n     }\n \n-  /* Enable Cell/B.E. if supported by the target.  */\n-  if (tdesc_compatible_p (info.target_desc,\n-\t\t\t  bfd_lookup_arch (bfd_arch_spu, bfd_mach_spu)))\n-    {\n-      /* Cell/B.E. multi-architecture support.  */\n-      set_spu_solib_ops (gdbarch);\n-\n-      /* Cell/B.E. cross-architecture unwinder support.  */\n-      frame_unwind_prepend_unwinder (gdbarch, &ppu2spu_unwind);\n-\n-      /* We need to support more than \"addr_bit\" significant address bits\n-         in order to support SPUADDR_ADDR encoded values.  */\n-      set_gdbarch_significant_addr_bit (gdbarch, 64);\n-    }\n-\n   set_gdbarch_displaced_step_location (gdbarch,\n \t\t\t\t       linux_displaced_step_location);\n \n@@ -2478,15 +2168,9 @@ _initialize_ppc_linux_tdep (void)\n   gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,\n                          ppc_linux_init_abi);\n \n-  /* Attach to observers to track __spe_current_active_context.  */\n-  gdb::observers::inferior_created.attach (ppc_linux_spe_context_inferior_created);\n-  gdb::observers::solib_loaded.attach (ppc_linux_spe_context_solib_loaded);\n-  gdb::observers::solib_unloaded.attach (ppc_linux_spe_context_solib_unloaded);\n-\n   /* Initialize the Linux target descriptions.  */\n   initialize_tdesc_powerpc_32l ();\n   initialize_tdesc_powerpc_altivec32l ();\n-  initialize_tdesc_powerpc_cell32l ();\n   initialize_tdesc_powerpc_vsx32l ();\n   initialize_tdesc_powerpc_isa205_32l ();\n   initialize_tdesc_powerpc_isa205_altivec32l ();\n@@ -2496,7 +2180,6 @@ _initialize_ppc_linux_tdep (void)\n   initialize_tdesc_powerpc_isa207_htm_vsx32l ();\n   initialize_tdesc_powerpc_64l ();\n   initialize_tdesc_powerpc_altivec64l ();\n-  initialize_tdesc_powerpc_cell64l ();\n   initialize_tdesc_powerpc_vsx64l ();\n   initialize_tdesc_powerpc_isa205_64l ();\n   initialize_tdesc_powerpc_isa205_altivec64l ();"
    },
    {
      "sha": "2e8b52ee751e2e80025b4f1880326415ce737e19",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 7,
      "deletions": 14,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1605,10 +1605,7 @@ cooked_read_test (struct gdbarch *gdbarch)\n \n       SELF_CHECK (mock_target.fetch_registers_called == 0);\n       SELF_CHECK (mock_target.store_registers_called == 0);\n-\n-      /* Some SPU pseudo registers are got via TARGET_OBJECT_SPU.  */\n-      if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-\tSELF_CHECK (mock_target.xfer_partial_called == 0);\n+      SELF_CHECK (mock_target.xfer_partial_called == 0);\n \n       mock_target.reset ();\n     }\n@@ -1724,16 +1721,12 @@ cooked_write_test (struct gdbarch *gdbarch)\n \n       auto bfd_arch = gdbarch_bfd_arch_info (gdbarch)->arch;\n \n-      if ((bfd_arch == bfd_arch_sparc\n-\t   /* SPARC64_CWP_REGNUM, SPARC64_PSTATE_REGNUM,\n-\t      SPARC64_ASI_REGNUM and SPARC64_CCR_REGNUM are hard to test.  */\n-\t   && gdbarch_ptr_bit (gdbarch) == 64\n-\t   && (regnum >= gdbarch_num_regs (gdbarch)\n-\t       && regnum <= gdbarch_num_regs (gdbarch) + 4))\n-\t  || (bfd_arch == bfd_arch_spu\n-\t      /* SPU pseudo registers except SPU_SP_REGNUM are got by\n-\t\t TARGET_OBJECT_SPU.  */\n-\t      && regnum >= gdbarch_num_regs (gdbarch) && regnum != 130))\n+      if (bfd_arch == bfd_arch_sparc\n+\t  /* SPARC64_CWP_REGNUM, SPARC64_PSTATE_REGNUM,\n+\t     SPARC64_ASI_REGNUM and SPARC64_CCR_REGNUM are hard to test.  */\n+\t  && gdbarch_ptr_bit (gdbarch) == 64\n+\t  && (regnum >= gdbarch_num_regs (gdbarch)\n+\t      && regnum <= gdbarch_num_regs (gdbarch) + 4))\n \tcontinue;\n \n       std::vector<gdb_byte> expected (register_size (gdbarch, regnum), 0);"
    },
    {
      "sha": "fb69119cc614d5ea3cddc8902e05cbedb1fadb21",
      "filename": "gdb/regformats/reg-spu.dat",
      "status": "removed",
      "additions": 0,
      "deletions": 133,
      "changes": 133,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/reg-spu.dat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/reg-spu.dat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regformats/reg-spu.dat?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,133 +0,0 @@\n-name:spu\n-xmlarch:spu\n-expedite:r0,r1,npc\n-128:r0\n-128:r1\n-128:r2\n-128:r3\n-128:r4\n-128:r5\n-128:r6\n-128:r7\n-128:r8\n-128:r9\n-128:r10\n-128:r11\n-128:r12\n-128:r13\n-128:r14\n-128:r15\n-128:r16\n-128:r17\n-128:r18\n-128:r19\n-128:r20\n-128:r21\n-128:r22\n-128:r23\n-128:r24\n-128:r25\n-128:r26\n-128:r27\n-128:r28\n-128:r29\n-128:r30\n-128:r31\n-128:r32\n-128:r33\n-128:r34\n-128:r35\n-128:r36\n-128:r37\n-128:r38\n-128:r39\n-128:r40\n-128:r41\n-128:r42\n-128:r43\n-128:r44\n-128:r45\n-128:r46\n-128:r47\n-128:r48\n-128:r49\n-128:r50\n-128:r51\n-128:r52\n-128:r53\n-128:r54\n-128:r55\n-128:r56\n-128:r57\n-128:r58\n-128:r59\n-128:r60\n-128:r61\n-128:r62\n-128:r63\n-128:r64\n-128:r65\n-128:r66\n-128:r67\n-128:r68\n-128:r69\n-128:r70\n-128:r71\n-128:r72\n-128:r73\n-128:r74\n-128:r75\n-128:r76\n-128:r77\n-128:r78\n-128:r79\n-128:r80\n-128:r81\n-128:r82\n-128:r83\n-128:r84\n-128:r85\n-128:r86\n-128:r87\n-128:r88\n-128:r89\n-128:r90\n-128:r91\n-128:r92\n-128:r93\n-128:r94\n-128:r95\n-128:r96\n-128:r97\n-128:r98\n-128:r99\n-128:r100\n-128:r101\n-128:r102\n-128:r103\n-128:r104\n-128:r105\n-128:r106\n-128:r107\n-128:r108\n-128:r109\n-128:r110\n-128:r111\n-128:r112\n-128:r113\n-128:r114\n-128:r115\n-128:r116\n-128:r117\n-128:r118\n-128:r119\n-128:r120\n-128:r121\n-128:r122\n-128:r123\n-128:r124\n-128:r125\n-128:r126\n-128:r127\n-32:id\n-32:npc"
    },
    {
      "sha": "bd285054958360a13dfe3cc0424b2b70132f8be7",
      "filename": "gdb/regformats/rs6000/powerpc-cell32l.dat",
      "status": "removed",
      "additions": 0,
      "deletions": 112,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/rs6000/powerpc-cell32l.dat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/rs6000/powerpc-cell32l.dat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regformats/rs6000/powerpc-cell32l.dat?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,112 +0,0 @@\n-# THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi :set ro:\n-# Generated from: rs6000/powerpc-cell32l.xml\n-name:powerpc_cell32l\n-xmltarget:powerpc-cell32l.xml\n-expedite:r1,pc,r0,orig_r3,r4\n-32:r0\n-32:r1\n-32:r2\n-32:r3\n-32:r4\n-32:r5\n-32:r6\n-32:r7\n-32:r8\n-32:r9\n-32:r10\n-32:r11\n-32:r12\n-32:r13\n-32:r14\n-32:r15\n-32:r16\n-32:r17\n-32:r18\n-32:r19\n-32:r20\n-32:r21\n-32:r22\n-32:r23\n-32:r24\n-32:r25\n-32:r26\n-32:r27\n-32:r28\n-32:r29\n-32:r30\n-32:r31\n-64:f0\n-64:f1\n-64:f2\n-64:f3\n-64:f4\n-64:f5\n-64:f6\n-64:f7\n-64:f8\n-64:f9\n-64:f10\n-64:f11\n-64:f12\n-64:f13\n-64:f14\n-64:f15\n-64:f16\n-64:f17\n-64:f18\n-64:f19\n-64:f20\n-64:f21\n-64:f22\n-64:f23\n-64:f24\n-64:f25\n-64:f26\n-64:f27\n-64:f28\n-64:f29\n-64:f30\n-64:f31\n-32:pc\n-32:msr\n-32:cr\n-32:lr\n-32:ctr\n-32:xer\n-32:fpscr\n-32:orig_r3\n-32:trap\n-128:vr0\n-128:vr1\n-128:vr2\n-128:vr3\n-128:vr4\n-128:vr5\n-128:vr6\n-128:vr7\n-128:vr8\n-128:vr9\n-128:vr10\n-128:vr11\n-128:vr12\n-128:vr13\n-128:vr14\n-128:vr15\n-128:vr16\n-128:vr17\n-128:vr18\n-128:vr19\n-128:vr20\n-128:vr21\n-128:vr22\n-128:vr23\n-128:vr24\n-128:vr25\n-128:vr26\n-128:vr27\n-128:vr28\n-128:vr29\n-128:vr30\n-128:vr31\n-32:vscr\n-32:vrsave"
    },
    {
      "sha": "b5b162eced28b8b369765d72cde58828bfc7209b",
      "filename": "gdb/regformats/rs6000/powerpc-cell64l.dat",
      "status": "removed",
      "additions": 0,
      "deletions": 112,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/rs6000/powerpc-cell64l.dat",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/regformats/rs6000/powerpc-cell64l.dat",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regformats/rs6000/powerpc-cell64l.dat?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,112 +0,0 @@\n-# THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi :set ro:\n-# Generated from: rs6000/powerpc-cell64l.xml\n-name:powerpc_cell64l\n-xmltarget:powerpc-cell64l.xml\n-expedite:r1,pc,r0,orig_r3,r4\n-64:r0\n-64:r1\n-64:r2\n-64:r3\n-64:r4\n-64:r5\n-64:r6\n-64:r7\n-64:r8\n-64:r9\n-64:r10\n-64:r11\n-64:r12\n-64:r13\n-64:r14\n-64:r15\n-64:r16\n-64:r17\n-64:r18\n-64:r19\n-64:r20\n-64:r21\n-64:r22\n-64:r23\n-64:r24\n-64:r25\n-64:r26\n-64:r27\n-64:r28\n-64:r29\n-64:r30\n-64:r31\n-64:f0\n-64:f1\n-64:f2\n-64:f3\n-64:f4\n-64:f5\n-64:f6\n-64:f7\n-64:f8\n-64:f9\n-64:f10\n-64:f11\n-64:f12\n-64:f13\n-64:f14\n-64:f15\n-64:f16\n-64:f17\n-64:f18\n-64:f19\n-64:f20\n-64:f21\n-64:f22\n-64:f23\n-64:f24\n-64:f25\n-64:f26\n-64:f27\n-64:f28\n-64:f29\n-64:f30\n-64:f31\n-64:pc\n-64:msr\n-32:cr\n-64:lr\n-64:ctr\n-32:xer\n-32:fpscr\n-64:orig_r3\n-64:trap\n-128:vr0\n-128:vr1\n-128:vr2\n-128:vr3\n-128:vr4\n-128:vr5\n-128:vr6\n-128:vr7\n-128:vr8\n-128:vr9\n-128:vr10\n-128:vr11\n-128:vr12\n-128:vr13\n-128:vr14\n-128:vr15\n-128:vr16\n-128:vr17\n-128:vr18\n-128:vr19\n-128:vr20\n-128:vr21\n-128:vr22\n-128:vr23\n-128:vr24\n-128:vr25\n-128:vr26\n-128:vr27\n-128:vr28\n-128:vr29\n-128:vr30\n-128:vr31\n-32:vscr\n-32:vrsave"
    },
    {
      "sha": "21160e13acc4b57743c69f164810da74032daa62",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 0,
      "deletions": 25,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1970,8 +1970,6 @@ enum {\n   PACKET_qXfer_libraries,\n   PACKET_qXfer_libraries_svr4,\n   PACKET_qXfer_memory_map,\n-  PACKET_qXfer_spu_read,\n-  PACKET_qXfer_spu_write,\n   PACKET_qXfer_osdata,\n   PACKET_qXfer_threads,\n   PACKET_qXfer_statictrace_read,\n@@ -5083,10 +5081,6 @@ static const struct protocol_feature remote_protocol_features[] = {\n     remote_supported_packet, PACKET_augmented_libraries_svr4_read_feature },\n   { \"qXfer:memory-map:read\", PACKET_DISABLE, remote_supported_packet,\n     PACKET_qXfer_memory_map },\n-  { \"qXfer:spu:read\", PACKET_DISABLE, remote_supported_packet,\n-    PACKET_qXfer_spu_read },\n-  { \"qXfer:spu:write\", PACKET_DISABLE, remote_supported_packet,\n-    PACKET_qXfer_spu_write },\n   { \"qXfer:osdata:read\", PACKET_DISABLE, remote_supported_packet,\n     PACKET_qXfer_osdata },\n   { \"qXfer:threads:read\", PACKET_DISABLE, remote_supported_packet,\n@@ -10858,19 +10852,6 @@ remote_target::xfer_partial (enum target_object object,\n \t\t\t\t  xfered_len);\n     }\n \n-  /* Handle SPU memory using qxfer packets.  */\n-  if (object == TARGET_OBJECT_SPU)\n-    {\n-      if (readbuf)\n-\treturn remote_read_qxfer (\"spu\", annex, readbuf, offset, len,\n-\t\t\t\t  xfered_len, &remote_protocol_packets\n-\t\t\t\t  [PACKET_qXfer_spu_read]);\n-      else\n-\treturn remote_write_qxfer (\"spu\", annex, writebuf, offset, len,\n-\t\t\t\t   xfered_len, &remote_protocol_packets\n-\t\t\t\t   [PACKET_qXfer_spu_write]);\n-    }\n-\n   /* Handle extra signal info using qxfer packets.  */\n   if (object == TARGET_OBJECT_SIGNAL_INFO)\n     {\n@@ -14481,12 +14462,6 @@ Show the maximum size of the address (in bits) in a memory packet.\"), NULL,\n   add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_memory_map],\n \t\t\t \"qXfer:memory-map:read\", \"memory-map\", 0);\n \n-  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_spu_read],\n-                         \"qXfer:spu:read\", \"read-spu-object\", 0);\n-\n-  add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_spu_write],\n-                         \"qXfer:spu:write\", \"write-spu-object\", 0);\n-\n   add_packet_config_cmd (&remote_protocol_packets[PACKET_qXfer_osdata],\n                         \"qXfer:osdata:read\", \"osdata\", 0);\n "
    },
    {
      "sha": "9123a3dc33ac88642d4525dd444fd85925c73ca2",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -6141,16 +6141,6 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   int num_pseudoregs = 0;\n   int cur_reg;\n \n-  /* INFO may refer to a binary that is not of the PowerPC architecture,\n-     e.g. when debugging a stand-alone SPE executable on a Cell/B.E. system.\n-     In this case, we must not attempt to infer properties of the (PowerPC\n-     side) of the target system from properties of that executable.  Trust\n-     the target description instead.  */\n-  if (info.abfd\n-      && bfd_get_arch (info.abfd) != bfd_arch_powerpc\n-      && bfd_get_arch (info.abfd) != bfd_arch_rs6000)\n-    info.abfd = NULL;\n-\n   from_xcoff_exec = info.abfd && info.abfd->format == bfd_object &&\n     bfd_get_flavour (info.abfd) == bfd_target_xcoff_flavour;\n "
    },
    {
      "sha": "49e470adb62dadb4c4e3849899f8819cc78c885a",
      "filename": "gdb/solib-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 547,
      "changes": 547,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/solib-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/solib-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,547 +0,0 @@\n-/* Cell SPU GNU/Linux support -- shared library handling.\n-   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"defs.h\"\n-#include \"solib-spu.h\"\n-#include \"gdbcore.h\"\n-#include <sys/stat.h>\n-#include \"arch-utils.h\"\n-#include \"bfd.h\"\n-#include \"symtab.h\"\n-#include \"solib.h\"\n-#include \"solib-svr4.h\"\n-#include \"solist.h\"\n-#include \"inferior.h\"\n-#include \"objfiles.h\"\n-#include \"observable.h\"\n-#include \"breakpoint.h\"\n-#include \"gdbthread.h\"\n-#include \"gdb_bfd.h\"\n-\n-#include \"spu-tdep.h\"\n-\n-/* Highest SPE id (file handle) the inferior may have.  */\n-#define MAX_SPE_FD 1024\n-\n-/* Stand-alone SPE executable?  */\n-#define spu_standalone_p() \\\n-  (symfile_objfile && symfile_objfile->obfd \\\n-   && bfd_get_arch (symfile_objfile->obfd) == bfd_arch_spu)\n-\n-\n-/* Relocate main SPE executable.  */\n-static void\n-spu_relocate_main_executable (int spufs_fd)\n-{\n-  struct section_offsets *new_offsets;\n-  int i;\n-\n-  if (symfile_objfile == NULL)\n-    return;\n-\n-  new_offsets = XALLOCAVEC (struct section_offsets,\n-\t\t\t    symfile_objfile->num_sections);\n-\n-  for (i = 0; i < symfile_objfile->num_sections; i++)\n-    new_offsets->offsets[i] = SPUADDR (spufs_fd, 0);\n-\n-  objfile_relocate (symfile_objfile, new_offsets);\n-}\n-\n-/* When running a stand-alone SPE executable, we may need to skip one more\n-   exec event on startup, to get past the binfmt_misc loader.  */\n-static void\n-spu_skip_standalone_loader (void)\n-{\n-  if (target_has_execution && !current_inferior ()->attach_flag)\n-    {\n-      struct target_waitstatus ws;\n-\n-      /* Only some kernels report an extra SIGTRAP with the binfmt_misc\n-\t loader; others do not.  In addition, if we have attached to an\n-\t already running inferior instead of starting a new one, we will\n-\t not see the extra SIGTRAP -- and we cannot readily distinguish\n-\t the two cases, in particular with the extended-remote target.\n-\n-\t Thus we issue a single-step here.  If no extra SIGTRAP was pending,\n-\t this will step past the first instruction of the stand-alone SPE\n-\t executable loader, but we don't care about that.  */\n-\n-      inferior_thread ()->control.in_infcall = 1; /* Suppress MI messages.  */\n-\n-      target_resume (inferior_ptid, 1, GDB_SIGNAL_0);\n-      target_wait (minus_one_ptid, &ws, 0);\n-      set_executing (minus_one_ptid, 0);\n-\n-      inferior_thread ()->control.in_infcall = 0;\n-    }\n-}\n-\n-static objfile_key<CORE_ADDR, gdb::noop_deleter<CORE_ADDR>>\n-  ocl_program_data_key;\n-\n-/* Appends OpenCL programs to the list of `struct so_list' objects.  */\n-static void\n-append_ocl_sos (struct so_list **link_ptr)\n-{\n-  CORE_ADDR *ocl_program_addr_base;\n-\n-  for (objfile *objfile : current_program_space->objfiles ())\n-    {\n-      ocl_program_addr_base = ocl_program_data_key.get (objfile);\n-      if (ocl_program_addr_base != NULL)\n-        {\n-\t  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd)?\n-\t\t\t\t\t BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-\t  try\n-\t    {\n-\t      CORE_ADDR data =\n-\t\tread_memory_unsigned_integer (*ocl_program_addr_base,\n-\t\t\t\t\t      sizeof (CORE_ADDR),\n-\t\t\t\t\t      byte_order);\n-\t      if (data != 0x0)\n-\t\t{\n-\t\t  struct so_list *newobj;\n-\n-\t\t  /* Allocate so_list structure.  */\n-\t\t  newobj = XCNEW (struct so_list);\n-\n-\t\t  /* Encode FD and object ID in path name.  */\n-\t\t  xsnprintf (newobj->so_name, sizeof newobj->so_name, \"@%s <%d>\",\n-\t\t\t     hex_string (data),\n-\t\t\t     SPUADDR_SPU (*ocl_program_addr_base));\n-\t\t  strcpy (newobj->so_original_name, newobj->so_name);\n-\n-\t\t  *link_ptr = newobj;\n-\t\t  link_ptr = &newobj->next;\n-\t\t}\n-\t    }\n-\t  catch (const gdb_exception &ex)\n-\t    {\n-\t      /* Ignore memory errors.  */\n-\t      switch (ex.error)\n-\t\t{\n-\t\tcase MEMORY_ERROR:\n-\t\t  break;\n-\t\tdefault:\n-\t\t  throw;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Build a list of `struct so_list' objects describing the shared\n-   objects currently loaded in the inferior.  */\n-static struct so_list *\n-spu_current_sos (void)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-  struct so_list *head;\n-  struct so_list **link_ptr;\n-\n-  gdb_byte buf[MAX_SPE_FD * 4];\n-  int i, size;\n-\n-  /* First, retrieve the SVR4 shared library list.  */\n-  head = svr4_so_ops.current_sos ();\n-\n-  /* Append our libraries to the end of the list.  */\n-  for (link_ptr = &head; *link_ptr; link_ptr = &(*link_ptr)->next)\n-    ;\n-\n-  /* Determine list of SPU ids.  */\n-  size = target_read (current_top_target (), TARGET_OBJECT_SPU, NULL,\n-\t\t      buf, 0, sizeof buf);\n-\n-  /* Do not add stand-alone SPE executable context as shared library,\n-     but relocate main SPE executable objfile.  */\n-  if (spu_standalone_p ())\n-    {\n-      if (size == 4)\n-\t{\n-\t  int fd = extract_unsigned_integer (buf, 4, byte_order);\n-\n-\t  spu_relocate_main_executable (fd);\n-\n-\t  /* Re-enable breakpoints after main SPU context was established;\n-\t     see also comments in spu_solib_create_inferior_hook.  */\n-\t  enable_breakpoints_after_startup ();\n-\t}\n-\n-      return head;\n-    }\n-\n-  /* Create an so_list entry for each SPU id.  */\n-  for (i = 0; i < size; i += 4)\n-    {\n-      int fd = extract_unsigned_integer (buf + i, 4, byte_order);\n-      struct so_list *newobj;\n-\n-      unsigned long long addr;\n-      char annex[32], id[100];\n-      int len;\n-\n-      /* Read object ID.  There's a race window where the inferior may have\n-\t already created the SPE context, but not installed the object-id\n-\t yet.  Skip such entries; we'll be back for them later.  */\n-      xsnprintf (annex, sizeof annex, \"%d/object-id\", fd);\n-      len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t\t (gdb_byte *) id, 0, sizeof id);\n-      if (len <= 0 || len >= sizeof id)\n-\tcontinue;\n-      id[len] = 0;\n-      if (sscanf (id, \"0x%llx\", &addr) != 1 || !addr)\n-\tcontinue;\n-\n-      /* Allocate so_list structure.  */\n-      newobj = XCNEW (struct so_list);\n-\n-      /* Encode FD and object ID in path name.  Choose the name so as not\n-\t to conflict with any (normal) SVR4 library path name.  */\n-      xsnprintf (newobj->so_name, sizeof newobj->so_name, \"@%s <%d>\",\n-\t\t hex_string (addr), fd);\n-      strcpy (newobj->so_original_name, newobj->so_name);\n-\n-      *link_ptr = newobj;\n-      link_ptr = &newobj->next;\n-    }\n-\n-  /* Append OpenCL sos.  */\n-  append_ocl_sos (link_ptr);\n-\n-  return head;\n-}\n-\n-/* Free so_list information.  */\n-static void\n-spu_free_so (struct so_list *so)\n-{\n-  if (so->so_original_name[0] != '@')\n-    svr4_so_ops.free_so (so);\n-}\n-\n-/* Relocate section addresses.  */\n-static void\n-spu_relocate_section_addresses (struct so_list *so,\n-\t\t\t\tstruct target_section *sec)\n-{\n-  if (so->so_original_name[0] != '@')\n-    svr4_so_ops.relocate_section_addresses (so, sec);\n-  else\n-    {\n-      unsigned long long addr;\n-      int fd;\n-\n-      /* Set addr_low/high to just LS offset for display.  */\n-      if (so->addr_low == 0 && so->addr_high == 0\n-          && strcmp (sec->the_bfd_section->name, \".text\") == 0)\n-        {\n-          so->addr_low = sec->addr;\n-          so->addr_high = sec->endaddr;\n-        }\n-\n-      /* Decode object ID.  */\n-      if (sscanf (so->so_original_name, \"@0x%llx <%d>\", &addr, &fd) != 2)\n-\tinternal_error (__FILE__, __LINE__, \"bad object ID\");\n-\n-      sec->addr = SPUADDR (fd, sec->addr);\n-      sec->endaddr = SPUADDR (fd, sec->endaddr);\n-    }\n-}\n-\n-\n-/* Inferior memory should contain an SPE executable image at location ADDR.\n-   Allocate a BFD representing that executable.  Return NULL on error.  */\n-\n-static void *\n-spu_bfd_iovec_open (bfd *nbfd, void *open_closure)\n-{\n-  return open_closure;\n-}\n-\n-static int\n-spu_bfd_iovec_close (bfd *nbfd, void *stream)\n-{\n-  xfree (stream);\n-\n-  /* Zero means success.  */\n-  return 0;\n-}\n-\n-static file_ptr\n-spu_bfd_iovec_pread (bfd *abfd, void *stream, void *buf,\n-                     file_ptr nbytes, file_ptr offset)\n-{\n-  CORE_ADDR addr = *(CORE_ADDR *)stream;\n-  int ret;\n-\n-  ret = target_read_memory (addr + offset, (gdb_byte *) buf, nbytes);\n-  if (ret != 0)\n-    {\n-      bfd_set_error (bfd_error_invalid_operation);\n-      return -1;\n-    }\n-\n-  return nbytes;\n-}\n-\n-static int\n-spu_bfd_iovec_stat (bfd *abfd, void *stream, struct stat *sb)\n-{\n-  /* We don't have an easy way of finding the size of embedded spu\n-     images.  We could parse the in-memory ELF header and section\n-     table to find the extent of the last section but that seems\n-     pointless when the size is needed only for checks of other\n-     parsed values in dbxread.c.  */\n-  memset (sb, 0, sizeof (struct stat));\n-  sb->st_size = INT_MAX;\n-  return 0;\n-}\n-\n-static gdb_bfd_ref_ptr\n-spu_bfd_fopen (const char *name, CORE_ADDR addr)\n-{\n-  CORE_ADDR *open_closure = XNEW (CORE_ADDR);\n-\n-  *open_closure = addr;\n-\n-  gdb_bfd_ref_ptr nbfd (gdb_bfd_openr_iovec (name, \"elf32-spu\",\n-\t\t\t\t\t     spu_bfd_iovec_open, open_closure,\n-\t\t\t\t\t     spu_bfd_iovec_pread,\n-\t\t\t\t\t     spu_bfd_iovec_close,\n-\t\t\t\t\t     spu_bfd_iovec_stat));\n-  if (nbfd == NULL)\n-    return NULL;\n-\n-  if (!bfd_check_format (nbfd.get (), bfd_object))\n-    return NULL;\n-\n-  return nbfd;\n-}\n-\n-/* Open shared library BFD.  */\n-static gdb_bfd_ref_ptr\n-spu_bfd_open (const char *pathname)\n-{\n-  const char *original_name = strrchr (pathname, '@');\n-  asection *spu_name;\n-  unsigned long long addr;\n-  int fd;\n-\n-  /* Handle regular SVR4 libraries.  */\n-  if (!original_name)\n-    return svr4_so_ops.bfd_open (pathname);\n-\n-  /* Decode object ID.  */\n-  if (sscanf (original_name, \"@0x%llx <%d>\", &addr, &fd) != 2)\n-    internal_error (__FILE__, __LINE__, \"bad object ID\");\n-\n-  /* Open BFD representing SPE executable.  */\n-  gdb_bfd_ref_ptr abfd (spu_bfd_fopen (original_name, (CORE_ADDR) addr));\n-  if (abfd == NULL)\n-    error (_(\"Cannot read SPE executable at %s\"), original_name);\n-\n-  /* Retrieve SPU name note.  */\n-  spu_name = bfd_get_section_by_name (abfd.get (), \".note.spu_name\");\n-  if (spu_name)\n-    {\n-      int sect_size = bfd_section_size (spu_name);\n-\n-      if (sect_size > 20)\n-\t{\n-\t  char *buf\n-\t    = (char *) alloca (sect_size - 20 + strlen (original_name) + 1);\n-\n-\t  bfd_get_section_contents (abfd.get (), spu_name, buf, 20,\n-\t\t\t\t    sect_size - 20);\n-\t  buf[sect_size - 20] = '\\0';\n-\n-\t  strcat (buf, original_name);\n-\n-\t  bfd_set_filename (abfd.get (), xstrdup (buf));\n-\t}\n-    }\n-\n-  return abfd;\n-}\n-\n-/* Lookup global symbol in a SPE executable.  */\n-static struct block_symbol\n-spu_lookup_lib_symbol (struct objfile *objfile,\n-\t\t       const char *name,\n-\t\t       const domain_enum domain)\n-{\n-  if (bfd_get_arch (objfile->obfd) == bfd_arch_spu)\n-    return lookup_global_symbol_from_objfile (objfile, GLOBAL_BLOCK, name,\n-\t\t\t\t\t      domain);\n-\n-  if (svr4_so_ops.lookup_lib_global_symbol != NULL)\n-    return svr4_so_ops.lookup_lib_global_symbol (objfile, name, domain);\n-  return {};\n-}\n-\n-/* Enable shared library breakpoint.  */\n-static int\n-spu_enable_break (struct objfile *objfile)\n-{\n-  struct bound_minimal_symbol spe_event_sym;\n-\n-  /* The libspe library will call __spe_context_update_event whenever any\n-     SPE context is allocated or destroyed.  */\n-  spe_event_sym = lookup_minimal_symbol (\"__spe_context_update_event\",\n-\t\t\t\t\t NULL, objfile);\n-\n-  /* Place a solib_event breakpoint on the symbol.  */\n-  if (spe_event_sym.minsym)\n-    {\n-      CORE_ADDR addr = BMSYMBOL_VALUE_ADDRESS (spe_event_sym);\n-\n-      addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (), addr,\n-\t\t\t\t\t\t current_top_target ());\n-      create_solib_event_breakpoint (target_gdbarch (), addr);\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Enable shared library breakpoint for the\n-   OpenCL runtime running on the SPU.  */\n-static void\n-ocl_enable_break (struct objfile *objfile)\n-{\n-  struct bound_minimal_symbol event_sym;\n-  struct bound_minimal_symbol addr_sym;\n-\n-  /* The OpenCL runtime on the SPU will call __opencl_program_update_event\n-     whenever an OpenCL program is loaded.  */\n-  event_sym = lookup_minimal_symbol (\"__opencl_program_update_event\", NULL,\n-\t\t\t\t     objfile);\n-  /* The PPU address of the OpenCL program can be found\n-     at opencl_elf_image_address.  */\n-  addr_sym = lookup_minimal_symbol (\"opencl_elf_image_address\", NULL, objfile);\n-\n-  if (event_sym.minsym && addr_sym.minsym)\n-    {\n-      /* Place a solib_event breakpoint on the symbol.  */\n-      CORE_ADDR event_addr = BMSYMBOL_VALUE_ADDRESS (event_sym);\n-      create_solib_event_breakpoint (get_objfile_arch (objfile), event_addr);\n-\n-      /* Store the address of the symbol that will point to OpenCL program\n-         using the per-objfile private data mechanism.  */\n-      if (ocl_program_data_key.get (objfile) == NULL)\n-        {\n-          CORE_ADDR *ocl_program_addr_base = OBSTACK_CALLOC (\n-\t\t  &objfile->objfile_obstack,\n-\t\t  objfile->sections_end - objfile->sections,\n-\t\t  CORE_ADDR);\n-\t  *ocl_program_addr_base = BMSYMBOL_VALUE_ADDRESS (addr_sym);\n-\t  ocl_program_data_key.set (objfile, ocl_program_addr_base);\n-        }\n-    }\n-}\n-\n-/* Create inferior hook.  */\n-static void\n-spu_solib_create_inferior_hook (int from_tty)\n-{\n-  /* Handle SPE stand-alone executables.  */\n-  if (spu_standalone_p ())\n-    {\n-      /* After an SPE stand-alone executable was loaded, we'll receive\n-\t an additional trap due to the binfmt_misc handler.  Make sure\n-\t to skip that trap.  */\n-      spu_skip_standalone_loader ();\n-\n-      /* If the user established breakpoints before starting the inferior, GDB\n-\t would attempt to insert those now.  This would fail because the SPU\n-\t context has not yet been created and the SPU executable has not yet\n-\t been loaded.  To prevent such failures, we disable all user-created\n-\t breakpoints now; they will be re-enabled in spu_current_sos once the\n-\t main SPU context has been detected.  */\n-      disable_breakpoints_before_startup ();\n-\n-      /* A special case arises when re-starting an executable, because at\n-\t this point it still resides at the relocated address range that was\n-\t determined during its last execution.  We need to undo the relocation\n-\t so that that multi-architecture target recognizes the stand-alone\n-\t initialization special case.  */\n-      spu_relocate_main_executable (-1);\n-    }\n-\n-  /* Call SVR4 hook -- this will re-insert the SVR4 solib breakpoints.  */\n-  svr4_so_ops.solib_create_inferior_hook (from_tty);\n-\n-  /* If the inferior is statically linked against libspe, we need to install\n-     our own solib breakpoint right now.  Otherwise, it will be installed by\n-     the solib_loaded observer below as soon as libspe is loaded.  */\n-  spu_enable_break (NULL);\n-}\n-\n-/* Install SPE \"shared library\" handling.  This is called by -tdep code\n-   that wants to support SPU as a secondary architecture.  */\n-void\n-set_spu_solib_ops (struct gdbarch *gdbarch)\n-{\n-  static struct target_so_ops spu_so_ops;\n-\n-  /* Initialize this lazily, to avoid an initialization order\n-     dependency on solib-svr4.c's _initialize routine.  */\n-  if (spu_so_ops.current_sos == NULL)\n-    {\n-      spu_so_ops = svr4_so_ops;\n-      spu_so_ops.solib_create_inferior_hook = spu_solib_create_inferior_hook;\n-      spu_so_ops.relocate_section_addresses = spu_relocate_section_addresses;\n-      spu_so_ops.free_so = spu_free_so;\n-      spu_so_ops.current_sos = spu_current_sos;\n-      spu_so_ops.bfd_open = spu_bfd_open;\n-      spu_so_ops.lookup_lib_global_symbol = spu_lookup_lib_symbol;\n-    }\n-\n-  set_solib_ops (gdbarch, &spu_so_ops);\n-}\n-\n-/* Observer for the solib_loaded event.  Used to install our breakpoint\n-   if libspe is a shared library.  */\n-static void\n-spu_solib_loaded (struct so_list *so)\n-{\n-  if (strstr (so->so_original_name, \"/libspe\") != NULL)\n-    {\n-      solib_read_symbols (so, 0);\n-      spu_enable_break (so->objfile);\n-    }\n-  /* In case the OpenCL runtime is loaded we install a breakpoint\n-     to get notified whenever an OpenCL program gets loaded.  */\n-  if (strstr (so->so_name, \"CLRuntimeAccelCellSPU@\") != NULL)\n-    {\n-      solib_read_symbols (so, 0);\n-      ocl_enable_break (so->objfile);\n-    }\n-}\n-\n-void\n-_initialize_spu_solib (void)\n-{\n-  gdb::observers::solib_loaded.attach (spu_solib_loaded);\n-}\n-"
    },
    {
      "sha": "a7a65336f820cf4cabd94e2c18568f89441ec276",
      "filename": "gdb/solib-spu.h",
      "status": "removed",
      "additions": 0,
      "deletions": 25,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/solib-spu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/solib-spu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-spu.h?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,25 +0,0 @@\n-/* Cell SPU GNU/Linux support -- shared library handling.\n-\n-   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef SOLIB_SPU_H\n-#define SOLIB_SPU_H\n-\n-extern void set_spu_solib_ops (struct gdbarch *gdbarch);\n-\n-#endif"
    },
    {
      "sha": "635366b4f1d4ccbbe8d53f4861dd2a43d4f0c975",
      "filename": "gdb/spu-linux-nat.c",
      "status": "removed",
      "additions": 0,
      "deletions": 661,
      "changes": 661,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-linux-nat.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,661 +0,0 @@\n-/* SPU native-dependent code for GDB, the GNU debugger.\n-   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"defs.h\"\n-#include \"gdbcore.h\"\n-#include \"target.h\"\n-#include \"inferior.h\"\n-#include \"inf-child.h\"\n-#include \"inf-ptrace.h\"\n-#include \"regcache.h\"\n-#include \"symfile.h\"\n-#include \"gdbsupport/gdb_wait.h\"\n-#include \"gdbthread.h\"\n-#include \"gdb_bfd.h\"\n-\n-#include \"nat/gdb_ptrace.h\"\n-#include <asm/ptrace.h>\n-#include <sys/types.h>\n-\n-#include \"spu-tdep.h\"\n-\n-/* PPU side system calls.  */\n-#define INSTR_SC\t0x44000002\n-#define NR_spu_run\t0x0116\n-\n-class spu_linux_nat_target final : public inf_ptrace_target\n-{\n-public:\n-  void fetch_registers (struct regcache *regcache, int regnum) override;\n-  void store_registers (struct regcache *regcache, int regnum) override;\n-\n-  void post_attach (int) override;\n-  void post_startup_inferior (ptid_t) override;\n-\n-  ptid_t wait (ptid_t, struct target_waitstatus *, int options) override;\n-\n-  enum target_xfer_status xfer_partial (enum target_object object,\n-\t\t\t\t\tconst char *annex,\n-\t\t\t\t\tgdb_byte *readbuf,\n-\t\t\t\t\tconst gdb_byte *writebuf,\n-\t\t\t\t\tULONGEST offset, ULONGEST len,\n-\t\t\t\t\tULONGEST *xfered_len) override;\n-\n-  int can_use_hw_breakpoint (enum bptype, int, int) override;\n-};\n-\n-static spu_linux_nat_target the_spu_linux_nat_target;\n-\n-/* Fetch PPU register REGNO.  */\n-static ULONGEST\n-fetch_ppc_register (int regno)\n-{\n-  PTRACE_TYPE_RET res;\n-\n-  int tid = inferior_ptid.lwp ();\n-  if (tid == 0)\n-    tid = inferior_ptid.pid ();\n-\n-#ifndef __powerpc64__\n-  /* If running as a 32-bit process on a 64-bit system, we attempt\n-     to get the full 64-bit register content of the target process.\n-     If the PPC special ptrace call fails, we're on a 32-bit system;\n-     just fall through to the regular ptrace call in that case.  */\n-  {\n-    gdb_byte buf[8];\n-\n-    errno = 0;\n-    ptrace (PPC_PTRACE_PEEKUSR_3264, tid,\n-\t    (PTRACE_TYPE_ARG3) (regno * 8), buf);\n-    if (errno == 0)\n-      ptrace (PPC_PTRACE_PEEKUSR_3264, tid,\n-\t      (PTRACE_TYPE_ARG3) (regno * 8 + 4), buf + 4);\n-    if (errno == 0)\n-      return (ULONGEST) *(uint64_t *)buf;\n-  }\n-#endif\n-\n-  errno = 0;\n-  res = ptrace (PT_READ_U, tid,\n-\t \t(PTRACE_TYPE_ARG3) (regno * sizeof (PTRACE_TYPE_RET)), 0);\n-  if (errno != 0)\n-    {\n-      char mess[128];\n-      xsnprintf (mess, sizeof mess, \"reading PPC register #%d\", regno);\n-      perror_with_name (_(mess));\n-    }\n-\n-  return (ULONGEST) (unsigned long) res;\n-}\n-\n-/* Fetch WORD from PPU memory at (aligned) MEMADDR in thread TID.  */\n-static int\n-fetch_ppc_memory_1 (int tid, ULONGEST memaddr, PTRACE_TYPE_RET *word)\n-{\n-  errno = 0;\n-\n-#ifndef __powerpc64__\n-  if (memaddr >> 32)\n-    {\n-      uint64_t addr_8 = (uint64_t) memaddr;\n-      ptrace (PPC_PTRACE_PEEKTEXT_3264, tid, (PTRACE_TYPE_ARG3) &addr_8, word);\n-    }\n-  else\n-#endif\n-    *word = ptrace (PT_READ_I, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, 0);\n-\n-  return errno;\n-}\n-\n-/* Store WORD into PPU memory at (aligned) MEMADDR in thread TID.  */\n-static int\n-store_ppc_memory_1 (int tid, ULONGEST memaddr, PTRACE_TYPE_RET word)\n-{\n-  errno = 0;\n-\n-#ifndef __powerpc64__\n-  if (memaddr >> 32)\n-    {\n-      uint64_t addr_8 = (uint64_t) memaddr;\n-      ptrace (PPC_PTRACE_POKEDATA_3264, tid, (PTRACE_TYPE_ARG3) &addr_8, word);\n-    }\n-  else\n-#endif\n-    ptrace (PT_WRITE_D, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, word);\n-\n-  return errno;\n-}\n-\n-/* Fetch LEN bytes of PPU memory at MEMADDR to MYADDR.  */\n-static int\n-fetch_ppc_memory (ULONGEST memaddr, gdb_byte *myaddr, int len)\n-{\n-  int i, ret;\n-\n-  ULONGEST addr = memaddr & -(ULONGEST) sizeof (PTRACE_TYPE_RET);\n-  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)\n-\t       / sizeof (PTRACE_TYPE_RET));\n-  PTRACE_TYPE_RET *buffer;\n-\n-  int tid = inferior_ptid.lwp ();\n-  if (tid == 0)\n-    tid = inferior_ptid.pid ();\n-\n-  buffer = (PTRACE_TYPE_RET *) alloca (count * sizeof (PTRACE_TYPE_RET));\n-  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))\n-    {\n-      ret = fetch_ppc_memory_1 (tid, addr, &buffer[i]);\n-      if (ret)\n-\treturn ret;\n-    }\n-\n-  memcpy (myaddr,\n-\t  (char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),\n-\t  len);\n-\n-  return 0;\n-}\n-\n-/* Store LEN bytes from MYADDR to PPU memory at MEMADDR.  */\n-static int\n-store_ppc_memory (ULONGEST memaddr, const gdb_byte *myaddr, int len)\n-{\n-  int i, ret;\n-\n-  ULONGEST addr = memaddr & -(ULONGEST) sizeof (PTRACE_TYPE_RET);\n-  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)\n-\t       / sizeof (PTRACE_TYPE_RET));\n-  PTRACE_TYPE_RET *buffer;\n-\n-  int tid = inferior_ptid.lwp ();\n-  if (tid == 0)\n-    tid = inferior_ptid.pid ();\n-\n-  buffer = (PTRACE_TYPE_RET *) alloca (count * sizeof (PTRACE_TYPE_RET));\n-\n-  if (addr != memaddr || len < (int) sizeof (PTRACE_TYPE_RET))\n-    {\n-      ret = fetch_ppc_memory_1 (tid, addr, &buffer[0]);\n-      if (ret)\n-\treturn ret;\n-    }\n-\n-  if (count > 1)\n-    {\n-      ret = fetch_ppc_memory_1 (tid, addr + (count - 1)\n-\t\t\t\t\t       * sizeof (PTRACE_TYPE_RET),\n-\t\t\t\t&buffer[count - 1]);\n-      if (ret)\n-\treturn ret;\n-    }\n-\n-  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),\n-          myaddr, len);\n-\n-  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))\n-    {\n-      ret = store_ppc_memory_1 (tid, addr, buffer[i]);\n-      if (ret)\n-\treturn ret;\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* If the PPU thread is currently stopped on a spu_run system call,\n-   return to FD and ADDR the file handle and NPC parameter address\n-   used with the system call.  Return non-zero if successful.  */\n-static int \n-parse_spufs_run (int *fd, ULONGEST *addr)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-  gdb_byte buf[4];\n-  ULONGEST pc = fetch_ppc_register (32);  /* nip */\n-\n-  /* Fetch instruction preceding current NIP.  */\n-  if (fetch_ppc_memory (pc-4, buf, 4) != 0)\n-    return 0;\n-  /* It should be a \"sc\" instruction.  */\n-  if (extract_unsigned_integer (buf, 4, byte_order) != INSTR_SC)\n-    return 0;\n-  /* System call number should be NR_spu_run.  */\n-  if (fetch_ppc_register (0) != NR_spu_run)\n-    return 0;\n-\n-  /* Register 3 contains fd, register 4 the NPC param pointer.  */\n-  *fd = fetch_ppc_register (34);  /* orig_gpr3 */\n-  *addr = fetch_ppc_register (4);\n-  return 1;\n-}\n-\n-\n-/* Implement the to_xfer_partial target_ops method for TARGET_OBJECT_SPU.\n-   Copy LEN bytes at OFFSET in spufs file ANNEX into/from READBUF or WRITEBUF,\n-   using the /proc file system.  */\n-\n-static enum target_xfer_status\n-spu_proc_xfer_spu (const char *annex, gdb_byte *readbuf,\n-\t\t   const gdb_byte *writebuf,\n-\t\t   ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)\n-{\n-  char buf[128];\n-  int fd = 0;\n-  int ret = -1;\n-  int pid = inferior_ptid.pid ();\n-\n-  if (!annex)\n-    return TARGET_XFER_EOF;\n-\n-  xsnprintf (buf, sizeof buf, \"/proc/%d/fd/%s\", pid, annex);\n-  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);\n-  if (fd <= 0)\n-    return TARGET_XFER_E_IO;\n-\n-  if (offset != 0\n-      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)\n-    {\n-      close (fd);\n-      return TARGET_XFER_EOF;\n-    }\n-\n-  if (writebuf)\n-    ret = write (fd, writebuf, (size_t) len);\n-  else if (readbuf)\n-    ret = read (fd, readbuf, (size_t) len);\n-\n-  close (fd);\n-  if (ret < 0)\n-    return TARGET_XFER_E_IO;\n-  else if (ret == 0)\n-    return TARGET_XFER_EOF;\n-  else\n-    {\n-      *xfered_len = (ULONGEST) ret;\n-      return TARGET_XFER_OK;\n-    }\n-}\n-\n-\n-/* Inferior memory should contain an SPE executable image at location ADDR.\n-   Allocate a BFD representing that executable.  Return NULL on error.  */\n-\n-static void *\n-spu_bfd_iovec_open (struct bfd *nbfd, void *open_closure)\n-{\n-  return open_closure;\n-}\n-\n-static int\n-spu_bfd_iovec_close (struct bfd *nbfd, void *stream)\n-{\n-  xfree (stream);\n-\n-  /* Zero means success.  */\n-  return 0;\n-}\n-\n-static file_ptr\n-spu_bfd_iovec_pread (struct bfd *abfd, void *stream, void *buf,\n-\t             file_ptr nbytes, file_ptr offset)\n-{\n-  ULONGEST addr = *(ULONGEST *)stream;\n-\n-  if (fetch_ppc_memory (addr + offset, (gdb_byte *)buf, nbytes) != 0)\n-    {\n-      bfd_set_error (bfd_error_invalid_operation);\n-      return -1;\n-    }\n-\n-  return nbytes;\n-}\n-\n-static int\n-spu_bfd_iovec_stat (struct bfd *abfd, void *stream, struct stat *sb)\n-{\n-  /* We don't have an easy way of finding the size of embedded spu\n-     images.  We could parse the in-memory ELF header and section\n-     table to find the extent of the last section but that seems\n-     pointless when the size is needed only for checks of other\n-     parsed values in dbxread.c.  */\n-  memset (sb, 0, sizeof (struct stat));\n-  sb->st_size = INT_MAX;\n-  return 0;\n-}\n-\n-static gdb_bfd_ref_ptr\n-spu_bfd_open (ULONGEST addr)\n-{\n-  asection *spu_name;\n-\n-  ULONGEST *open_closure = XNEW (ULONGEST);\n-  *open_closure = addr;\n-\n-  gdb_bfd_ref_ptr nbfd (gdb_bfd_openr_iovec (\"<in-memory>\", \"elf32-spu\",\n-\t\t\t\t\t     spu_bfd_iovec_open, open_closure,\n-\t\t\t\t\t     spu_bfd_iovec_pread,\n-\t\t\t\t\t     spu_bfd_iovec_close,\n-\t\t\t\t\t     spu_bfd_iovec_stat));\n-  if (nbfd == NULL)\n-    return NULL;\n-\n-  if (!bfd_check_format (nbfd.get (), bfd_object))\n-    return NULL;\n-\n-  /* Retrieve SPU name note and update BFD name.  */\n-  spu_name = bfd_get_section_by_name (nbfd.get (), \".note.spu_name\");\n-  if (spu_name)\n-    {\n-      int sect_size = bfd_section_size (spu_name);\n-      if (sect_size > 20)\n-\t{\n-\t  char *buf = (char *)alloca (sect_size - 20 + 1);\n-\t  bfd_get_section_contents (nbfd.get (), spu_name, buf, 20,\n-\t\t\t\t    sect_size - 20);\n-\t  buf[sect_size - 20] = '\\0';\n-\n-\t  bfd_set_filename (nbfd.get (), xstrdup (buf));\n-\t}\n-    }\n-\n-  return nbfd;\n-}\n-\n-/* INFERIOR_FD is a file handle passed by the inferior to the\n-   spu_run system call.  Assuming the SPE context was allocated\n-   by the libspe library, try to retrieve the main SPE executable\n-   file from its copy within the target process.  */\n-static void\n-spu_symbol_file_add_from_memory (int inferior_fd)\n-{\n-  ULONGEST addr;\n-\n-  gdb_byte id[128];\n-  char annex[32];\n-  ULONGEST len;\n-  enum target_xfer_status status;\n-\n-  /* Read object ID.  */\n-  xsnprintf (annex, sizeof annex, \"%d/object-id\", inferior_fd);\n-  status = spu_proc_xfer_spu (annex, id, NULL, 0, sizeof id, &len);\n-  if (status != TARGET_XFER_OK || len >= sizeof id)\n-    return;\n-  id[len] = 0;\n-  addr = strtoulst ((const char *) id, NULL, 16);\n-  if (!addr)\n-    return;\n-\n-  /* Open BFD representing SPE executable and read its symbols.  */\n-  gdb_bfd_ref_ptr nbfd (spu_bfd_open (addr));\n-  if (nbfd != NULL)\n-    {\n-      symbol_file_add_from_bfd (nbfd.get (), bfd_get_filename (nbfd),\n-\t\t\t\tSYMFILE_VERBOSE | SYMFILE_MAINLINE,\n-\t\t\t\tNULL, 0, NULL);\n-    }\n-}\n-\n-\n-/* Override the post_startup_inferior routine to continue running\n-   the inferior until the first spu_run system call.  */\n-void\n-spu_linux_nat_target::post_startup_inferior (ptid_t ptid)\n-{\n-  int fd;\n-  ULONGEST addr;\n-\n-  int tid = ptid.lwp ();\n-  if (tid == 0)\n-    tid = ptid.pid ();\n-  \n-  while (!parse_spufs_run (&fd, &addr))\n-    {\n-      ptrace (PT_SYSCALL, tid, (PTRACE_TYPE_ARG3) 0, 0);\n-      waitpid (tid, NULL, __WALL | __WNOTHREAD);\n-    }\n-}\n-\n-/* Override the post_attach routine to try load the SPE executable\n-   file image from its copy inside the target process.  */\n-void\n-spu_linux_nat_target::post_attach (int pid)\n-{\n-  int fd;\n-  ULONGEST addr;\n-\n-  /* Like child_post_startup_inferior, if we happened to attach to\n-     the inferior while it wasn't currently in spu_run, continue \n-     running it until we get back there.  */\n-  while (!parse_spufs_run (&fd, &addr))\n-    {\n-      ptrace (PT_SYSCALL, pid, (PTRACE_TYPE_ARG3) 0, 0);\n-      waitpid (pid, NULL, __WALL | __WNOTHREAD);\n-    }\n-\n-  /* If the user has not provided an executable file, try to extract\n-     the image from inside the target process.  */\n-  if (!get_exec_file (0))\n-    spu_symbol_file_add_from_memory (fd);\n-}\n-\n-/* Wait for child PTID to do something.  Return id of the child,\n-   minus_one_ptid in case of error; store status into *OURSTATUS.  */\n-ptid_t\n-spu_linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n-\t\t\t    int options)\n-{\n-  int save_errno;\n-  int status;\n-  pid_t pid;\n-\n-  do\n-    {\n-      set_sigint_trap ();\t/* Causes SIGINT to be passed on to the\n-\t\t\t\t   attached process.  */\n-\n-      pid = waitpid (ptid.pid (), &status, 0);\n-      if (pid == -1 && errno == ECHILD)\n-\t/* Try again with __WCLONE to check cloned processes.  */\n-\tpid = waitpid (ptid.pid (), &status, __WCLONE);\n-\n-      save_errno = errno;\n-\n-      /* Make sure we don't report an event for the exit of the\n-         original program, if we've detached from it.  */\n-      if (pid != -1 && !WIFSTOPPED (status)\n-\t  && pid != inferior_ptid.pid ())\n-\t{\n-\t  pid = -1;\n-\t  save_errno = EINTR;\n-\t}\n-\n-      clear_sigint_trap ();\n-    }\n-  while (pid == -1 && save_errno == EINTR);\n-\n-  if (pid == -1)\n-    {\n-      warning (_(\"Child process unexpectedly missing: %s\"),\n-\t       safe_strerror (save_errno));\n-\n-      /* Claim it exited with unknown signal.  */\n-      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n-      return inferior_ptid;\n-    }\n-\n-  store_waitstatus (ourstatus, status);\n-  return ptid_t (pid);\n-}\n-\n-/* Override the fetch_inferior_register routine.  */\n-void\n-spu_linux_nat_target::fetch_registers (struct regcache *regcache, int regno)\n-{\n-  int fd;\n-  ULONGEST addr;\n-\n-  /* Since we use functions that rely on inferior_ptid, we need to set and\n-     restore it.  */\n-  scoped_restore save_ptid\n-    = make_scoped_restore (&inferior_ptid, regcache->ptid ());\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return;\n-\n-  /* The ID register holds the spufs file handle.  */\n-  if (regno == -1 || regno == SPU_ID_REGNUM)\n-    {\n-      struct gdbarch *gdbarch = regcache->arch ();\n-      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-      gdb_byte buf[4];\n-      store_unsigned_integer (buf, 4, byte_order, fd);\n-      regcache->raw_supply (SPU_ID_REGNUM, buf);\n-    }\n-\n-  /* The NPC register is found at ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      gdb_byte buf[4];\n-      if (fetch_ppc_memory (addr, buf, 4) == 0)\n-\tregcache->raw_supply (SPU_PC_REGNUM, buf);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_GPRS))\n-    {\n-      gdb_byte buf[16 * SPU_NUM_GPRS];\n-      char annex[32];\n-      int i;\n-      ULONGEST len;\n-\n-      xsnprintf (annex, sizeof annex, \"%d/regs\", fd);\n-      if ((spu_proc_xfer_spu (annex, buf, NULL, 0, sizeof buf, &len)\n-\t   == TARGET_XFER_OK)\n-\t  && len == sizeof buf)\n-\tfor (i = 0; i < SPU_NUM_GPRS; i++)\n-\t  regcache->raw_supply (i, buf + i*16);\n-    }\n-}\n-\n-/* Override the store_inferior_register routine.  */\n-void\n-spu_linux_nat_target::store_registers (struct regcache *regcache, int regno)\n-{\n-  int fd;\n-  ULONGEST addr;\n-\n-  /* Since we use functions that rely on inferior_ptid, we need to set and\n-     restore it.  */\n-  scoped_restore save_ptid\n-    = make_scoped_restore (&inferior_ptid, regcache->ptid ());\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (&fd, &addr))\n-    return;\n-\n-  /* The NPC register is found at ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      gdb_byte buf[4];\n-      regcache->raw_collect (SPU_PC_REGNUM, buf);\n-      store_ppc_memory (addr, buf, 4);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_GPRS))\n-    {\n-      gdb_byte buf[16 * SPU_NUM_GPRS];\n-      char annex[32];\n-      int i;\n-      ULONGEST len;\n-\n-      for (i = 0; i < SPU_NUM_GPRS; i++)\n-\tregcache->raw_collect (i, buf + i*16);\n-\n-      xsnprintf (annex, sizeof annex, \"%d/regs\", fd);\n-      spu_proc_xfer_spu (annex, NULL, buf, 0, sizeof buf, &len);\n-    }\n-}\n-\n-/* Override the to_xfer_partial routine.  */\n-enum target_xfer_status\n-spu_linux_nat_target::xfer_partial (enum target_object object, const char *annex,\n-\t\t\t\t    gdb_byte *readbuf, const gdb_byte *writebuf,\n-\t\t\t\t    ULONGEST offset, ULONGEST len,\n-\t\t\t\t    ULONGEST *xfered_len)\n-{\n-  if (object == TARGET_OBJECT_SPU)\n-    return spu_proc_xfer_spu (annex, readbuf, writebuf, offset, len,\n-\t\t\t      xfered_len);\n-\n-  if (object == TARGET_OBJECT_MEMORY)\n-    {\n-      int fd;\n-      ULONGEST addr;\n-      char mem_annex[32], lslr_annex[32];\n-      gdb_byte buf[32];\n-      ULONGEST lslr;\n-      enum target_xfer_status ret;\n-\n-      /* We must be stopped on a spu_run system call.  */\n-      if (!parse_spufs_run (&fd, &addr))\n-\treturn TARGET_XFER_EOF;\n-\n-      /* Use the \"mem\" spufs file to access SPU local store.  */\n-      xsnprintf (mem_annex, sizeof mem_annex, \"%d/mem\", fd);\n-      ret = spu_proc_xfer_spu (mem_annex, readbuf, writebuf, offset, len,\n-\t\t\t       xfered_len);\n-      if (ret == TARGET_XFER_OK)\n-\treturn ret;\n-\n-      /* SPU local store access wraps the address around at the\n-\t local store limit.  We emulate this here.  To avoid needing\n-\t an extra access to retrieve the LSLR, we only do that after\n-\t trying the original address first, and getting end-of-file.  */\n-      xsnprintf (lslr_annex, sizeof lslr_annex, \"%d/lslr\", fd);\n-      memset (buf, 0, sizeof buf);\n-      if (spu_proc_xfer_spu (lslr_annex, buf, NULL, 0, sizeof buf, xfered_len)\n-\t  != TARGET_XFER_OK)\n-\treturn ret;\n-\n-      lslr = strtoulst ((const char *) buf, NULL, 16);\n-      return spu_proc_xfer_spu (mem_annex, readbuf, writebuf,\n-\t\t\t\toffset & lslr, len, xfered_len);\n-    }\n-\n-  return TARGET_XFER_E_IO;\n-}\n-\n-/* Override the to_can_use_hw_breakpoint routine.  */\n-int\n-spu_linux_nat_target::can_use_hw_breakpoint (enum bptype type,\n-\t\t\t\t\t     int cnt, int othertype)\n-{\n-  return 0;\n-}\n-\n-/* Initialize SPU native target.  */\n-void \n-_initialize_spu_nat (void)\n-{\n-  add_inf_child_target (&the_spu_linux_nat_target);\n-}"
    },
    {
      "sha": "88ad291dbd64839071479e20710698fab75de846",
      "filename": "gdb/spu-multiarch.c",
      "status": "removed",
      "additions": 0,
      "deletions": 417,
      "changes": 417,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-multiarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-multiarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-multiarch.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,417 +0,0 @@\n-/* Cell SPU GNU/Linux multi-architecture debugging support.\n-   Copyright (C) 2009-2019 Free Software Foundation, Inc.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"defs.h\"\n-#include \"gdbcore.h\"\n-#include \"gdbcmd.h\"\n-#include \"arch-utils.h\"\n-#include \"observable.h\"\n-#include \"inferior.h\"\n-#include \"regcache.h\"\n-#include \"symfile.h\"\n-#include \"objfiles.h\"\n-#include \"solib.h\"\n-#include \"solist.h\"\n-\n-#include \"ppc-tdep.h\"\n-#include \"ppc-linux-tdep.h\"\n-#include \"spu-tdep.h\"\n-\n-/* The SPU multi-architecture support target.  */\n-\n-static const target_info spu_multiarch_target_info = {\n-  \"spu\",\n-  N_(\"SPU multi-architecture support.\"),\n-  N_(\"SPU multi-architecture support.\")\n-};\n-\n-struct spu_multiarch_target final : public target_ops\n-{\n-  const target_info &info () const override\n-  { return spu_multiarch_target_info; }\n-\n-  strata stratum () const override { return arch_stratum; }\n-\n-  void mourn_inferior () override;\n-\n-  void fetch_registers (struct regcache *, int) override;\n-  void store_registers (struct regcache *, int) override;\n-\n-  enum target_xfer_status xfer_partial (enum target_object object,\n-\t\t\t\t\tconst char *annex,\n-\t\t\t\t\tgdb_byte *readbuf,\n-\t\t\t\t\tconst gdb_byte *writebuf,\n-\t\t\t\t\tULONGEST offset, ULONGEST len,\n-\t\t\t\t\tULONGEST *xfered_len) override;\n-\n-  int search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n-\t\t     const gdb_byte *pattern, ULONGEST pattern_len,\n-\t\t     CORE_ADDR *found_addrp) override;\n-\n-  int region_ok_for_hw_watchpoint (CORE_ADDR, int) override;\n-\n-  struct gdbarch *thread_architecture (ptid_t) override;\n-};\n-\n-static spu_multiarch_target spu_ops;\n-\n-/* Number of SPE objects loaded into the current inferior.  */\n-static int spu_nr_solib;\n-\n-/* Stand-alone SPE executable?  */\n-#define spu_standalone_p() \\\n-  (symfile_objfile && symfile_objfile->obfd \\\n-   && bfd_get_arch (symfile_objfile->obfd) == bfd_arch_spu)\n-\n-/* PPU side system calls.  */\n-#define INSTR_SC\t0x44000002\n-#define NR_spu_run\t0x0116\n-\n-/* If the PPU thread is currently stopped on a spu_run system call,\n-   return to FD and ADDR the file handle and NPC parameter address\n-   used with the system call.  Return non-zero if successful.  */\n-static int\n-parse_spufs_run (ptid_t ptid, int *fd, CORE_ADDR *addr)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n-  struct gdbarch_tdep *tdep;\n-  struct regcache *regcache;\n-  gdb_byte buf[4];\n-  ULONGEST regval;\n-\n-  /* If we're not on PPU, there's nothing to detect.  */\n-  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch != bfd_arch_powerpc)\n-    return 0;\n-\n-  /* If we're called too early (e.g. after fork), we cannot\n-     access the inferior yet.  */\n-  if (find_inferior_ptid (ptid) == NULL)\n-    return 0;\n-\n-  /* Get PPU-side registers.  */\n-  regcache = get_thread_arch_regcache (ptid, target_gdbarch ());\n-  tdep = gdbarch_tdep (target_gdbarch ());\n-\n-  /* Fetch instruction preceding current NIP.  */\n-  {\n-    scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n-    inferior_ptid = ptid;\n-    regval = target_read_memory (regcache_read_pc (regcache) - 4, buf, 4);\n-  }\n-  if (regval != 0)\n-    return 0;\n-  /* It should be a \"sc\" instruction.  */\n-  if (extract_unsigned_integer (buf, 4, byte_order) != INSTR_SC)\n-    return 0;\n-  /* System call number should be NR_spu_run.  */\n-  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum, &regval);\n-  if (regval != NR_spu_run)\n-    return 0;\n-\n-  /* Register 3 contains fd, register 4 the NPC param pointer.  */\n-  regcache_cooked_read_unsigned (regcache, PPC_ORIG_R3_REGNUM, &regval);\n-  *fd = (int) regval;\n-  regcache_cooked_read_unsigned (regcache, tdep->ppc_gp0_regnum + 4, &regval);\n-  *addr = (CORE_ADDR) regval;\n-  return 1;\n-}\n-\n-/* Find gdbarch for SPU context SPUFS_FD.  */\n-static struct gdbarch *\n-spu_gdbarch (int spufs_fd)\n-{\n-  struct gdbarch_info info;\n-  gdbarch_info_init (&info);\n-  info.bfd_arch_info = bfd_lookup_arch (bfd_arch_spu, bfd_mach_spu);\n-  info.byte_order = BFD_ENDIAN_BIG;\n-  info.osabi = GDB_OSABI_LINUX;\n-  info.id = &spufs_fd;\n-  return gdbarch_find_by_info (info);\n-}\n-\n-/* Override the to_thread_architecture routine.  */\n-struct gdbarch *\n-spu_multiarch_target::thread_architecture (ptid_t ptid)\n-{\n-  int spufs_fd;\n-  CORE_ADDR spufs_addr;\n-\n-  if (parse_spufs_run (ptid, &spufs_fd, &spufs_addr))\n-    return spu_gdbarch (spufs_fd);\n-\n-  return beneath ()->thread_architecture (ptid);\n-}\n-\n-/* Override the to_region_ok_for_hw_watchpoint routine.  */\n-\n-int\n-spu_multiarch_target::region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n-{\n-  /* We cannot watch SPU local store.  */\n-  if (SPUADDR_SPU (addr) != -1)\n-    return 0;\n-\n-  return beneath ()->region_ok_for_hw_watchpoint (addr, len);\n-}\n-\n-/* Override the to_fetch_registers routine.  */\n-\n-void\n-spu_multiarch_target::fetch_registers (struct regcache *regcache, int regno)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  int spufs_fd;\n-  CORE_ADDR spufs_addr;\n-\n-  /* Since we use functions that rely on inferior_ptid, we need to set and\n-     restore it.  */\n-  scoped_restore save_ptid\n-    = make_scoped_restore (&inferior_ptid, regcache->ptid ());\n-\n-  /* This version applies only if we're currently in spu_run.  */\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    {\n-      beneath ()->fetch_registers (regcache, regno);\n-      return;\n-    }\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (inferior_ptid, &spufs_fd, &spufs_addr))\n-    return;\n-\n-  /* The ID register holds the spufs file handle.  */\n-  if (regno == -1 || regno == SPU_ID_REGNUM)\n-    {\n-      gdb_byte buf[4];\n-      store_unsigned_integer (buf, 4, byte_order, spufs_fd);\n-      regcache->raw_supply (SPU_ID_REGNUM, buf);\n-    }\n-\n-  /* The NPC register is found in PPC memory at SPUFS_ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      gdb_byte buf[4];\n-\n-      if (target_read (beneath (), TARGET_OBJECT_MEMORY, NULL,\n-\t\t       buf, spufs_addr, sizeof buf) == sizeof buf)\n-\tregcache->raw_supply (SPU_PC_REGNUM, buf);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_GPRS))\n-    {\n-      gdb_byte buf[16 * SPU_NUM_GPRS];\n-      char annex[32];\n-      int i;\n-\n-      xsnprintf (annex, sizeof annex, \"%d/regs\", spufs_fd);\n-      if (target_read (beneath (), TARGET_OBJECT_SPU, annex,\n-\t\t       buf, 0, sizeof buf) == sizeof buf)\n-\tfor (i = 0; i < SPU_NUM_GPRS; i++)\n-\t  regcache->raw_supply (i, buf + i*16);\n-    }\n-}\n-\n-/* Override the to_store_registers routine.  */\n-\n-void\n-spu_multiarch_target::store_registers (struct regcache *regcache, int regno)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  int spufs_fd;\n-  CORE_ADDR spufs_addr;\n-\n-  /* Since we use functions that rely on inferior_ptid, we need to set and\n-     restore it.  */\n-  scoped_restore save_ptid\n-    = make_scoped_restore (&inferior_ptid, regcache->ptid ());\n-\n-  /* This version applies only if we're currently in spu_run.  */\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    {\n-      beneath ()->store_registers (regcache, regno);\n-      return;\n-    }\n-\n-  /* We must be stopped on a spu_run system call.  */\n-  if (!parse_spufs_run (inferior_ptid, &spufs_fd, &spufs_addr))\n-    return;\n-\n-  /* The NPC register is found in PPC memory at SPUFS_ADDR.  */\n-  if (regno == -1 || regno == SPU_PC_REGNUM)\n-    {\n-      gdb_byte buf[4];\n-      regcache->raw_collect (SPU_PC_REGNUM, buf);\n-\n-      target_write (beneath (), TARGET_OBJECT_MEMORY, NULL,\n-\t\t    buf, spufs_addr, sizeof buf);\n-    }\n-\n-  /* The GPRs are found in the \"regs\" spufs file.  */\n-  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_GPRS))\n-    {\n-      gdb_byte buf[16 * SPU_NUM_GPRS];\n-      char annex[32];\n-      int i;\n-\n-      for (i = 0; i < SPU_NUM_GPRS; i++)\n-\tregcache->raw_collect (i, buf + i*16);\n-\n-      xsnprintf (annex, sizeof annex, \"%d/regs\", spufs_fd);\n-      target_write (beneath (), TARGET_OBJECT_SPU, annex,\n-\t\t    buf, 0, sizeof buf);\n-    }\n-}\n-\n-/* Override the to_xfer_partial routine.  */\n-\n-enum target_xfer_status\n-spu_multiarch_target::xfer_partial (enum target_object object,\n-\t\t\t\t    const char *annex, gdb_byte *readbuf,\n-\t\t\t\t    const gdb_byte *writebuf, ULONGEST offset, ULONGEST len,\n-\t\t\t\t    ULONGEST *xfered_len)\n-{\n-  struct target_ops *ops_beneath = this->beneath ();\n-\n-  /* Use the \"mem\" spufs file to access SPU local store.  */\n-  if (object == TARGET_OBJECT_MEMORY)\n-    {\n-      int fd = SPUADDR_SPU (offset);\n-      CORE_ADDR addr = SPUADDR_ADDR (offset);\n-      char mem_annex[32], lslr_annex[32];\n-      gdb_byte buf[32];\n-      ULONGEST lslr;\n-      enum target_xfer_status ret;\n-\n-      if (fd >= 0)\n-\t{\n-\t  xsnprintf (mem_annex, sizeof mem_annex, \"%d/mem\", fd);\n-\t  ret = ops_beneath->xfer_partial (TARGET_OBJECT_SPU,\n-\t\t\t\t\t   mem_annex, readbuf, writebuf,\n-\t\t\t\t\t   addr, len, xfered_len);\n-\t  if (ret == TARGET_XFER_OK)\n-\t    return ret;\n-\n-\t  /* SPU local store access wraps the address around at the\n-\t     local store limit.  We emulate this here.  To avoid needing\n-\t     an extra access to retrieve the LSLR, we only do that after\n-\t     trying the original address first, and getting end-of-file.  */\n-\t  xsnprintf (lslr_annex, sizeof lslr_annex, \"%d/lslr\", fd);\n-\t  memset (buf, 0, sizeof buf);\n-\t  if (ops_beneath->xfer_partial (TARGET_OBJECT_SPU,\n-\t\t\t\t\t lslr_annex, buf, NULL,\n-\t\t\t\t\t 0, sizeof buf, xfered_len)\n-\t      != TARGET_XFER_OK)\n-\t    return ret;\n-\n-\t  lslr = strtoulst ((char *) buf, NULL, 16);\n-\t  return ops_beneath->xfer_partial (TARGET_OBJECT_SPU,\n-\t\t\t\t\t    mem_annex, readbuf, writebuf,\n-\t\t\t\t\t    addr & lslr, len, xfered_len);\n-\t}\n-    }\n-\n-  return ops_beneath->xfer_partial (object, annex,\n-\t\t\t\t    readbuf, writebuf, offset, len, xfered_len);\n-}\n-\n-/* Override the to_search_memory routine.  */\n-int\n-spu_multiarch_target::search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n-\t\t\t\t     const gdb_byte *pattern, ULONGEST pattern_len,\n-\t\t\t\t     CORE_ADDR *found_addrp)\n-{\n-  /* For SPU local store, always fall back to the simple method.  */\n-  if (SPUADDR_SPU (start_addr) >= 0)\n-    return simple_search_memory (this, start_addr, search_space_len,\n-\t\t\t\t pattern, pattern_len, found_addrp);\n-\n-  return beneath ()->search_memory (start_addr, search_space_len,\n-\t\t\t\t    pattern, pattern_len, found_addrp);\n-}\n-\n-\n-/* Push and pop the SPU multi-architecture support target.  */\n-\n-static void\n-spu_multiarch_activate (void)\n-{\n-  /* If GDB was configured without SPU architecture support,\n-     we cannot install SPU multi-architecture support either.  */\n-  if (spu_gdbarch (-1) == NULL)\n-    return;\n-\n-  push_target (&spu_ops);\n-\n-  /* Make sure the thread architecture is re-evaluated.  */\n-  registers_changed ();\n-}\n-\n-static void\n-spu_multiarch_deactivate (void)\n-{\n-  unpush_target (&spu_ops);\n-\n-  /* Make sure the thread architecture is re-evaluated.  */\n-  registers_changed ();\n-}\n-\n-static void\n-spu_multiarch_inferior_created (struct target_ops *ops, int from_tty)\n-{\n-  if (spu_standalone_p ())\n-    spu_multiarch_activate ();\n-}\n-\n-static void\n-spu_multiarch_solib_loaded (struct so_list *so)\n-{\n-  if (!spu_standalone_p ())\n-    if (so->abfd && bfd_get_arch (so->abfd) == bfd_arch_spu)\n-      if (spu_nr_solib++ == 0)\n-\tspu_multiarch_activate ();\n-}\n-\n-static void\n-spu_multiarch_solib_unloaded (struct so_list *so)\n-{\n-  if (!spu_standalone_p ())\n-    if (so->abfd && bfd_get_arch (so->abfd) == bfd_arch_spu)\n-      if (--spu_nr_solib == 0)\n-\tspu_multiarch_deactivate ();\n-}\n-\n-void\n-spu_multiarch_target::mourn_inferior ()\n-{\n-  beneath ()->mourn_inferior ();\n-  spu_multiarch_deactivate ();\n-}\n-\n-void\n-_initialize_spu_multiarch (void)\n-{\n-  /* Install observers to watch for SPU objects.  */\n-  gdb::observers::inferior_created.attach (spu_multiarch_inferior_created);\n-  gdb::observers::solib_loaded.attach (spu_multiarch_solib_loaded);\n-  gdb::observers::solib_unloaded.attach (spu_multiarch_solib_unloaded);\n-}\n-"
    },
    {
      "sha": "5360efb12f7da299f9dcf4f3f71b7992f8e0feaf",
      "filename": "gdb/spu-tdep.c",
      "status": "removed",
      "additions": 0,
      "deletions": 2835,
      "changes": 2835,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-tdep.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,2835 +0,0 @@\n-/* SPU target-dependent code for GDB, the GNU debugger.\n-   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-   Based on a port by Sid Manning <sid@us.ibm.com>.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"defs.h\"\n-#include \"arch-utils.h\"\n-#include \"gdbtypes.h\"\n-#include \"gdbcmd.h\"\n-#include \"gdbcore.h\"\n-#include \"frame.h\"\n-#include \"frame-unwind.h\"\n-#include \"frame-base.h\"\n-#include \"trad-frame.h\"\n-#include \"symtab.h\"\n-#include \"symfile.h\"\n-#include \"value.h\"\n-#include \"inferior.h\"\n-#include \"dis-asm.h\"\n-#include \"disasm.h\"\n-#include \"objfiles.h\"\n-#include \"language.h\"\n-#include \"regcache.h\"\n-#include \"reggroups.h\"\n-#include \"block.h\"\n-#include \"observable.h\"\n-#include \"infcall.h\"\n-#include \"dwarf2.h\"\n-#include \"dwarf2-frame.h\"\n-#include \"ax.h\"\n-#include \"spu-tdep.h\"\n-#include \"location.h\"\n-\n-/* The list of available \"set spu \" and \"show spu \" commands.  */\n-static struct cmd_list_element *setspucmdlist = NULL;\n-static struct cmd_list_element *showspucmdlist = NULL;\n-\n-/* Whether to stop for new SPE contexts.  */\n-static bool spu_stop_on_load_p = false;\n-/* Whether to automatically flush the SW-managed cache.  */\n-static bool spu_auto_flush_cache_p = true;\n-\n-\n-/* The tdep structure.  */\n-struct gdbarch_tdep\n-{\n-  /* The spufs ID identifying our address space.  */\n-  int id;\n-\n-  /* SPU-specific vector type.  */\n-  struct type *spu_builtin_type_vec128;\n-};\n-\n-\n-/* SPU-specific vector type.  */\n-static struct type *\n-spu_builtin_type_vec128 (struct gdbarch *gdbarch)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-\n-  if (!tdep->spu_builtin_type_vec128)\n-    {\n-      const struct builtin_type *bt = builtin_type (gdbarch);\n-      struct type *t;\n-\n-      t = arch_composite_type (gdbarch,\n-\t\t\t       \"__spu_builtin_type_vec128\", TYPE_CODE_UNION);\n-      append_composite_type_field (t, \"uint128\", bt->builtin_int128);\n-      append_composite_type_field (t, \"v2_int64\",\n-\t\t\t\t   init_vector_type (bt->builtin_int64, 2));\n-      append_composite_type_field (t, \"v4_int32\",\n-\t\t\t\t   init_vector_type (bt->builtin_int32, 4));\n-      append_composite_type_field (t, \"v8_int16\",\n-\t\t\t\t   init_vector_type (bt->builtin_int16, 8));\n-      append_composite_type_field (t, \"v16_int8\",\n-\t\t\t\t   init_vector_type (bt->builtin_int8, 16));\n-      append_composite_type_field (t, \"v2_double\",\n-\t\t\t\t   init_vector_type (bt->builtin_double, 2));\n-      append_composite_type_field (t, \"v4_float\",\n-\t\t\t\t   init_vector_type (bt->builtin_float, 4));\n-\n-      TYPE_VECTOR (t) = 1;\n-      TYPE_NAME (t) = \"spu_builtin_type_vec128\";\n-\n-      tdep->spu_builtin_type_vec128 = t;\n-    }\n-\n-  return tdep->spu_builtin_type_vec128;\n-}\n-\n-\n-/* The list of available \"info spu \" commands.  */\n-static struct cmd_list_element *infospucmdlist = NULL;\n-\n-/* Registers.  */\n-\n-static const char *\n-spu_register_name (struct gdbarch *gdbarch, int reg_nr)\n-{\n-  static const char *register_names[] =\n-    {\n-      \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\n-      \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n-      \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n-      \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\n-      \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\n-      \"r40\", \"r41\", \"r42\", \"r43\", \"r44\", \"r45\", \"r46\", \"r47\",\n-      \"r48\", \"r49\", \"r50\", \"r51\", \"r52\", \"r53\", \"r54\", \"r55\",\n-      \"r56\", \"r57\", \"r58\", \"r59\", \"r60\", \"r61\", \"r62\", \"r63\",\n-      \"r64\", \"r65\", \"r66\", \"r67\", \"r68\", \"r69\", \"r70\", \"r71\",\n-      \"r72\", \"r73\", \"r74\", \"r75\", \"r76\", \"r77\", \"r78\", \"r79\",\n-      \"r80\", \"r81\", \"r82\", \"r83\", \"r84\", \"r85\", \"r86\", \"r87\",\n-      \"r88\", \"r89\", \"r90\", \"r91\", \"r92\", \"r93\", \"r94\", \"r95\",\n-      \"r96\", \"r97\", \"r98\", \"r99\", \"r100\", \"r101\", \"r102\", \"r103\",\n-      \"r104\", \"r105\", \"r106\", \"r107\", \"r108\", \"r109\", \"r110\", \"r111\",\n-      \"r112\", \"r113\", \"r114\", \"r115\", \"r116\", \"r117\", \"r118\", \"r119\",\n-      \"r120\", \"r121\", \"r122\", \"r123\", \"r124\", \"r125\", \"r126\", \"r127\",\n-      \"id\", \"pc\", \"sp\", \"fpscr\", \"srr0\", \"lslr\", \"decr\", \"decr_status\"\n-    };\n-\n-  if (reg_nr < 0)\n-    return NULL;\n-  if (reg_nr >= sizeof register_names / sizeof *register_names)\n-    return NULL;\n-\n-  return register_names[reg_nr];\n-}\n-\n-static struct type *\n-spu_register_type (struct gdbarch *gdbarch, int reg_nr)\n-{\n-  if (reg_nr < SPU_NUM_GPRS)\n-    return spu_builtin_type_vec128 (gdbarch);\n-\n-  switch (reg_nr)\n-    {\n-    case SPU_ID_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint32;\n-\n-    case SPU_PC_REGNUM:\n-      return builtin_type (gdbarch)->builtin_func_ptr;\n-\n-    case SPU_SP_REGNUM:\n-      return builtin_type (gdbarch)->builtin_data_ptr;\n-\n-    case SPU_FPSCR_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint128;\n-\n-    case SPU_SRR0_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint32;\n-\n-    case SPU_LSLR_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint32;\n-\n-    case SPU_DECR_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint32;\n-\n-    case SPU_DECR_STATUS_REGNUM:\n-      return builtin_type (gdbarch)->builtin_uint32;\n-\n-    default:\n-      internal_error (__FILE__, __LINE__, _(\"invalid regnum\"));\n-    }\n-}\n-\n-/* Pseudo registers for preferred slots - stack pointer.  */\n-\n-static enum register_status\n-spu_pseudo_register_read_spu (readable_regcache *regcache, const char *regname,\n-\t\t\t      gdb_byte *buf)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  enum register_status status;\n-  gdb_byte reg[32];\n-  char annex[32];\n-  ULONGEST id;\n-  ULONGEST ul;\n-\n-  status = regcache->raw_read (SPU_ID_REGNUM, &id);\n-  if (status != REG_VALID)\n-    return status;\n-  xsnprintf (annex, sizeof annex, \"%d/%s\", (int) id, regname);\n-  memset (reg, 0, sizeof reg);\n-  target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t       reg, 0, sizeof reg);\n-\n-  ul = strtoulst ((char *) reg, NULL, 16);\n-  store_unsigned_integer (buf, 4, byte_order, ul);\n-  return REG_VALID;\n-}\n-\n-static enum register_status\n-spu_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n-                          int regnum, gdb_byte *buf)\n-{\n-  gdb_byte reg[16];\n-  char annex[32];\n-  ULONGEST id;\n-  enum register_status status;\n-\n-  switch (regnum)\n-    {\n-    case SPU_SP_REGNUM:\n-      status = regcache->raw_read (SPU_RAW_SP_REGNUM, reg);\n-      if (status != REG_VALID)\n-\treturn status;\n-      memcpy (buf, reg, 4);\n-      return status;\n-\n-    case SPU_FPSCR_REGNUM:\n-      status = regcache->raw_read (SPU_ID_REGNUM, &id);\n-      if (status != REG_VALID)\n-\treturn status;\n-      xsnprintf (annex, sizeof annex, \"%d/fpcr\", (int) id);\n-      target_read (current_top_target (), TARGET_OBJECT_SPU, annex, buf, 0, 16);\n-      return status;\n-\n-    case SPU_SRR0_REGNUM:\n-      return spu_pseudo_register_read_spu (regcache, \"srr0\", buf);\n-\n-    case SPU_LSLR_REGNUM:\n-      return spu_pseudo_register_read_spu (regcache, \"lslr\", buf);\n-\n-    case SPU_DECR_REGNUM:\n-      return spu_pseudo_register_read_spu (regcache, \"decr\", buf);\n-\n-    case SPU_DECR_STATUS_REGNUM:\n-      return spu_pseudo_register_read_spu (regcache, \"decr_status\", buf);\n-\n-    default:\n-      internal_error (__FILE__, __LINE__, _(\"invalid regnum\"));\n-    }\n-}\n-\n-static void\n-spu_pseudo_register_write_spu (struct regcache *regcache, const char *regname,\n-\t\t\t       const gdb_byte *buf)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  char reg[32];\n-  char annex[32];\n-  ULONGEST id;\n-\n-  regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);\n-  xsnprintf (annex, sizeof annex, \"%d/%s\", (int) id, regname);\n-  xsnprintf (reg, sizeof reg, \"0x%s\",\n-\t     phex_nz (extract_unsigned_integer (buf, 4, byte_order), 4));\n-  target_write (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t(gdb_byte *) reg, 0, strlen (reg));\n-}\n-\n-static void\n-spu_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n-                           int regnum, const gdb_byte *buf)\n-{\n-  gdb_byte reg[16];\n-  char annex[32];\n-  ULONGEST id;\n-\n-  switch (regnum)\n-    {\n-    case SPU_SP_REGNUM:\n-      regcache->raw_read (SPU_RAW_SP_REGNUM, reg);\n-      memcpy (reg, buf, 4);\n-      regcache->raw_write (SPU_RAW_SP_REGNUM, reg);\n-      break;\n-\n-    case SPU_FPSCR_REGNUM:\n-      regcache_raw_read_unsigned (regcache, SPU_ID_REGNUM, &id);\n-      xsnprintf (annex, sizeof annex, \"%d/fpcr\", (int) id);\n-      target_write (current_top_target (), TARGET_OBJECT_SPU, annex, buf, 0, 16);\n-      break;\n-\n-    case SPU_SRR0_REGNUM:\n-      spu_pseudo_register_write_spu (regcache, \"srr0\", buf);\n-      break;\n-\n-    case SPU_LSLR_REGNUM:\n-      spu_pseudo_register_write_spu (regcache, \"lslr\", buf);\n-      break;\n-\n-    case SPU_DECR_REGNUM:\n-      spu_pseudo_register_write_spu (regcache, \"decr\", buf);\n-      break;\n-\n-    case SPU_DECR_STATUS_REGNUM:\n-      spu_pseudo_register_write_spu (regcache, \"decr_status\", buf);\n-      break;\n-\n-    default:\n-      internal_error (__FILE__, __LINE__, _(\"invalid regnum\"));\n-    }\n-}\n-\n-static int\n-spu_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n-\t\t\t\tstruct agent_expr *ax, int regnum)\n-{\n-  switch (regnum)\n-    {\n-    case SPU_SP_REGNUM:\n-      ax_reg_mask (ax, SPU_RAW_SP_REGNUM);\n-      return 0;\n-\n-    case SPU_FPSCR_REGNUM:\n-    case SPU_SRR0_REGNUM:\n-    case SPU_LSLR_REGNUM:\n-    case SPU_DECR_REGNUM:\n-    case SPU_DECR_STATUS_REGNUM:\n-      return -1;\n-\n-    default:\n-      internal_error (__FILE__, __LINE__, _(\"invalid regnum\"));\n-    }\n-}\n-\n-static int\n-spu_ax_pseudo_register_push_stack (struct gdbarch *gdbarch,\n-\t\t\t\t   struct agent_expr *ax, int regnum)\n-{\n-  switch (regnum)\n-    {\n-    case SPU_SP_REGNUM:\n-      ax_reg (ax, SPU_RAW_SP_REGNUM);\n-      return 0;\n-\n-    case SPU_FPSCR_REGNUM:\n-    case SPU_SRR0_REGNUM:\n-    case SPU_LSLR_REGNUM:\n-    case SPU_DECR_REGNUM:\n-    case SPU_DECR_STATUS_REGNUM:\n-      return -1;\n-\n-    default:\n-      internal_error (__FILE__, __LINE__, _(\"invalid regnum\"));\n-    }\n-}\n-\n-\n-/* Value conversion -- access scalar values at the preferred slot.  */\n-\n-static struct value *\n-spu_value_from_register (struct gdbarch *gdbarch, struct type *type,\n-\t\t\t int regnum, struct frame_id frame_id)\n-{\n-  struct value *value = default_value_from_register (gdbarch, type,\n-\t\t\t\t\t\t     regnum, frame_id);\n-  LONGEST len = TYPE_LENGTH (type);\n-\n-  if (regnum < SPU_NUM_GPRS && len < 16)\n-    {\n-      int preferred_slot = len < 4 ? 4 - len : 0;\n-      set_value_offset (value, preferred_slot);\n-    }\n-\n-  return value;\n-}\n-\n-/* Register groups.  */\n-\n-static int\n-spu_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n-\t\t\t struct reggroup *group)\n-{\n-  /* Registers displayed via 'info regs'.  */\n-  if (group == general_reggroup)\n-    return 1;\n-\n-  /* Registers displayed via 'info float'.  */\n-  if (group == float_reggroup)\n-    return 0;\n-\n-  /* Registers that need to be saved/restored in order to\n-     push or pop frames.  */\n-  if (group == save_reggroup || group == restore_reggroup)\n-    return 1;\n-\n-  return default_register_reggroup_p (gdbarch, regnum, group);\n-}\n-\n-/* DWARF-2 register numbers.  */\n-\n-static int\n-spu_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n-{\n-  /* Use cooked instead of raw SP.  */\n-  return (reg == SPU_RAW_SP_REGNUM)? SPU_SP_REGNUM : reg;\n-}\n-\n-\n-/* Address handling.  */\n-\n-static int\n-spu_gdbarch_id (struct gdbarch *gdbarch)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  int id = tdep->id;\n-\n-  /* The objfile architecture of a standalone SPU executable does not\n-     provide an SPU ID.  Retrieve it from the objfile's relocated\n-     address range in this special case.  */\n-  if (id == -1\n-      && symfile_objfile && symfile_objfile->obfd\n-      && bfd_get_arch (symfile_objfile->obfd) == bfd_arch_spu\n-      && symfile_objfile->sections != symfile_objfile->sections_end)\n-    id = SPUADDR_SPU (obj_section_addr (symfile_objfile->sections));\n-\n-  return id;\n-}\n-\n-static int\n-spu_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n-{\n-  if (dwarf2_addr_class == 1)\n-    return TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;\n-  else\n-    return 0;\n-}\n-\n-static const char *\n-spu_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n-{\n-  if (type_flags & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)\n-    return \"__ea\";\n-  else\n-    return NULL;\n-}\n-\n-static int\n-spu_address_class_name_to_type_flags (struct gdbarch *gdbarch,\n-\t\t\t\t      const char *name, int *type_flags_ptr)\n-{\n-  if (strcmp (name, \"__ea\") == 0)\n-    {\n-      *type_flags_ptr = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;\n-      return 1;\n-    }\n-  else\n-   return 0;\n-}\n-\n-static void\n-spu_address_to_pointer (struct gdbarch *gdbarch,\n-\t\t\tstruct type *type, gdb_byte *buf, CORE_ADDR addr)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  store_unsigned_integer (buf, TYPE_LENGTH (type), byte_order,\n-\t\t\t  SPUADDR_ADDR (addr));\n-}\n-\n-static CORE_ADDR\n-spu_pointer_to_address (struct gdbarch *gdbarch,\n-\t\t\tstruct type *type, const gdb_byte *buf)\n-{\n-  int id = spu_gdbarch_id (gdbarch);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  ULONGEST addr\n-    = extract_unsigned_integer (buf, TYPE_LENGTH (type), byte_order);\n-\n-  /* Do not convert __ea pointers.  */\n-  if (TYPE_ADDRESS_CLASS_1 (type))\n-    return addr;\n-\n-  return addr? SPUADDR (id, addr) : 0;\n-}\n-\n-static CORE_ADDR\n-spu_integer_to_address (struct gdbarch *gdbarch,\n-\t\t\tstruct type *type, const gdb_byte *buf)\n-{\n-  int id = spu_gdbarch_id (gdbarch);\n-  ULONGEST addr = unpack_long (type, buf);\n-\n-  return SPUADDR (id, addr);\n-}\n-\n-\n-/* Decoding SPU instructions.  */\n-\n-enum\n-  {\n-    op_lqd   = 0x34,\n-    op_lqx   = 0x3c4,\n-    op_lqa   = 0x61,\n-    op_lqr   = 0x67,\n-    op_stqd  = 0x24,\n-    op_stqx  = 0x144,\n-    op_stqa  = 0x41,\n-    op_stqr  = 0x47,\n-\n-    op_il    = 0x081,\n-    op_ila   = 0x21,\n-    op_a     = 0x0c0,\n-    op_ai    = 0x1c,\n-\n-    op_selb  = 0x8,\n-\n-    op_br    = 0x64,\n-    op_bra   = 0x60,\n-    op_brsl  = 0x66,\n-    op_brasl = 0x62,\n-    op_brnz  = 0x42,\n-    op_brz   = 0x40,\n-    op_brhnz = 0x46,\n-    op_brhz  = 0x44,\n-    op_bi    = 0x1a8,\n-    op_bisl  = 0x1a9,\n-    op_biz   = 0x128,\n-    op_binz  = 0x129,\n-    op_bihz  = 0x12a,\n-    op_bihnz = 0x12b,\n-  };\n-\n-static int\n-is_rr (unsigned int insn, int op, int *rt, int *ra, int *rb)\n-{\n-  if ((insn >> 21) == op)\n-    {\n-      *rt = insn & 127;\n-      *ra = (insn >> 7) & 127;\n-      *rb = (insn >> 14) & 127;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_rrr (unsigned int insn, int op, int *rt, int *ra, int *rb, int *rc)\n-{\n-  if ((insn >> 28) == op)\n-    {\n-      *rt = (insn >> 21) & 127;\n-      *ra = (insn >> 7) & 127;\n-      *rb = (insn >> 14) & 127;\n-      *rc = insn & 127;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_ri7 (unsigned int insn, int op, int *rt, int *ra, int *i7)\n-{\n-  if ((insn >> 21) == op)\n-    {\n-      *rt = insn & 127;\n-      *ra = (insn >> 7) & 127;\n-      *i7 = (((insn >> 14) & 127) ^ 0x40) - 0x40;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_ri10 (unsigned int insn, int op, int *rt, int *ra, int *i10)\n-{\n-  if ((insn >> 24) == op)\n-    {\n-      *rt = insn & 127;\n-      *ra = (insn >> 7) & 127;\n-      *i10 = (((insn >> 14) & 0x3ff) ^ 0x200) - 0x200;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_ri16 (unsigned int insn, int op, int *rt, int *i16)\n-{\n-  if ((insn >> 23) == op)\n-    {\n-      *rt = insn & 127;\n-      *i16 = (((insn >> 7) & 0xffff) ^ 0x8000) - 0x8000;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_ri18 (unsigned int insn, int op, int *rt, int *i18)\n-{\n-  if ((insn >> 25) == op)\n-    {\n-      *rt = insn & 127;\n-      *i18 = (((insn >> 7) & 0x3ffff) ^ 0x20000) - 0x20000;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-static int\n-is_branch (unsigned int insn, int *offset, int *reg)\n-{\n-  int rt, i7, i16;\n-\n-  if (is_ri16 (insn, op_br, &rt, &i16)\n-      || is_ri16 (insn, op_brsl, &rt, &i16)\n-      || is_ri16 (insn, op_brnz, &rt, &i16)\n-      || is_ri16 (insn, op_brz, &rt, &i16)\n-      || is_ri16 (insn, op_brhnz, &rt, &i16)\n-      || is_ri16 (insn, op_brhz, &rt, &i16))\n-    {\n-      *reg = SPU_PC_REGNUM;\n-      *offset = i16 << 2;\n-      return 1;\n-    }\n-\n-  if (is_ri16 (insn, op_bra, &rt, &i16)\n-      || is_ri16 (insn, op_brasl, &rt, &i16))\n-    {\n-      *reg = -1;\n-      *offset = i16 << 2;\n-      return 1;\n-    }\n-\n-  if (is_ri7 (insn, op_bi, &rt, reg, &i7)\n-      || is_ri7 (insn, op_bisl, &rt, reg, &i7)\n-      || is_ri7 (insn, op_biz, &rt, reg, &i7)\n-      || is_ri7 (insn, op_binz, &rt, reg, &i7)\n-      || is_ri7 (insn, op_bihz, &rt, reg, &i7)\n-      || is_ri7 (insn, op_bihnz, &rt, reg, &i7))\n-    {\n-      *offset = 0;\n-      return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Prolog parsing.  */\n-\n-struct spu_prologue_data\n-  {\n-    /* Stack frame size.  -1 if analysis was unsuccessful.  */\n-    int size;\n-\n-    /* How to find the CFA.  The CFA is equal to SP at function entry.  */\n-    int cfa_reg;\n-    int cfa_offset;\n-\n-    /* Offset relative to CFA where a register is saved.  -1 if invalid.  */\n-    int reg_offset[SPU_NUM_GPRS];\n-  };\n-\n-static CORE_ADDR\n-spu_analyze_prologue (struct gdbarch *gdbarch,\n-\t\t      CORE_ADDR start_pc, CORE_ADDR end_pc,\n-                      struct spu_prologue_data *data)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  int found_sp = 0;\n-  int found_fp = 0;\n-  int found_lr = 0;\n-  int found_bc = 0;\n-  int reg_immed[SPU_NUM_GPRS];\n-  gdb_byte buf[16];\n-  CORE_ADDR prolog_pc = start_pc;\n-  CORE_ADDR pc;\n-  int i;\n-\n-\n-  /* Initialize DATA to default values.  */\n-  data->size = -1;\n-\n-  data->cfa_reg = SPU_RAW_SP_REGNUM;\n-  data->cfa_offset = 0;\n-\n-  for (i = 0; i < SPU_NUM_GPRS; i++)\n-    data->reg_offset[i] = -1;\n-\n-  /* Set up REG_IMMED array.  This is non-zero for a register if we know its\n-     preferred slot currently holds this immediate value.  */\n-  for (i = 0; i < SPU_NUM_GPRS; i++)\n-      reg_immed[i] = 0;\n-\n-  /* Scan instructions until the first branch.\n-\n-     The following instructions are important prolog components:\n-\n-\t- The first instruction to set up the stack pointer.\n-\t- The first instruction to set up the frame pointer.\n-\t- The first instruction to save the link register.\n-\t- The first instruction to save the backchain.\n-\n-     We return the instruction after the latest of these four,\n-     or the incoming PC if none is found.  The first instruction\n-     to set up the stack pointer also defines the frame size.\n-\n-     Note that instructions saving incoming arguments to their stack\n-     slots are not counted as important, because they are hard to\n-     identify with certainty.  This should not matter much, because\n-     arguments are relevant only in code compiled with debug data,\n-     and in such code the GDB core will advance until the first source\n-     line anyway, using SAL data.\n-\n-     For purposes of stack unwinding, we analyze the following types\n-     of instructions in addition:\n-\n-      - Any instruction adding to the current frame pointer.\n-      - Any instruction loading an immediate constant into a register.\n-      - Any instruction storing a register onto the stack.\n-\n-     These are used to compute the CFA and REG_OFFSET output.  */\n-\n-  for (pc = start_pc; pc < end_pc; pc += 4)\n-    {\n-      unsigned int insn;\n-      int rt, ra, rb, rc, immed;\n-\n-      if (target_read_memory (pc, buf, 4))\n-\tbreak;\n-      insn = extract_unsigned_integer (buf, 4, byte_order);\n-\n-      /* AI is the typical instruction to set up a stack frame.\n-         It is also used to initialize the frame pointer.  */\n-      if (is_ri10 (insn, op_ai, &rt, &ra, &immed))\n-\t{\n-\t  if (rt == data->cfa_reg && ra == data->cfa_reg)\n-\t    data->cfa_offset -= immed;\n-\n-\t  if (rt == SPU_RAW_SP_REGNUM && ra == SPU_RAW_SP_REGNUM\n-\t      && !found_sp)\n-\t    {\n-\t      found_sp = 1;\n-\t      prolog_pc = pc + 4;\n-\n-\t      data->size = -immed;\n-\t    }\n-\t  else if (rt == SPU_FP_REGNUM && ra == SPU_RAW_SP_REGNUM\n-\t\t   && !found_fp)\n-\t    {\n-\t      found_fp = 1;\n-\t      prolog_pc = pc + 4;\n-\n-\t      data->cfa_reg = SPU_FP_REGNUM;\n-\t      data->cfa_offset -= immed;\n-\t    }\n-\t}\n-\n-      /* A is used to set up stack frames of size >= 512 bytes.\n-         If we have tracked the contents of the addend register,\n-         we can handle this as well.  */\n-      else if (is_rr (insn, op_a, &rt, &ra, &rb))\n-\t{\n-\t  if (rt == data->cfa_reg && ra == data->cfa_reg)\n-\t    {\n-\t      if (reg_immed[rb] != 0)\n-\t\tdata->cfa_offset -= reg_immed[rb];\n-\t      else\n-\t\tdata->cfa_reg = -1;  /* We don't know the CFA any more.  */\n-\t    }\n-\n-\t  if (rt == SPU_RAW_SP_REGNUM && ra == SPU_RAW_SP_REGNUM\n-\t      && !found_sp)\n-\t    {\n-\t      found_sp = 1;\n-\t      prolog_pc = pc + 4;\n-\n-\t      if (reg_immed[rb] != 0)\n-\t\tdata->size = -reg_immed[rb];\n-\t    }\n-\t}\n-\n-      /* We need to track IL and ILA used to load immediate constants\n-         in case they are later used as input to an A instruction.  */\n-      else if (is_ri16 (insn, op_il, &rt, &immed))\n-\t{\n-\t  reg_immed[rt] = immed;\n-\n-\t  if (rt == SPU_RAW_SP_REGNUM && !found_sp)\n-\t    found_sp = 1;\n-\t}\n-\n-      else if (is_ri18 (insn, op_ila, &rt, &immed))\n-\t{\n-\t  reg_immed[rt] = immed & 0x3ffff;\n-\n-\t  if (rt == SPU_RAW_SP_REGNUM && !found_sp)\n-\t    found_sp = 1;\n-\t}\n-\n-      /* STQD is used to save registers to the stack.  */\n-      else if (is_ri10 (insn, op_stqd, &rt, &ra, &immed))\n-\t{\n-\t  if (ra == data->cfa_reg)\n-\t    data->reg_offset[rt] = data->cfa_offset - (immed << 4);\n-\n-\t  if (ra == data->cfa_reg && rt == SPU_LR_REGNUM\n-              && !found_lr)\n-\t    {\n-\t      found_lr = 1;\n-\t      prolog_pc = pc + 4;\n-\t    }\n-\n-\t  if (ra == SPU_RAW_SP_REGNUM\n-\t      && (found_sp? immed == 0 : rt == SPU_RAW_SP_REGNUM)\n-\t      && !found_bc)\n-\t    {\n-\t      found_bc = 1;\n-\t      prolog_pc = pc + 4;\n-\t    }\n-\t}\n-\n-      /* _start uses SELB to set up the stack pointer.  */\n-      else if (is_rrr (insn, op_selb, &rt, &ra, &rb, &rc))\n-\t{\n-\t  if (rt == SPU_RAW_SP_REGNUM && !found_sp)\n-\t    found_sp = 1;\n-\t}\n-\n-      /* We terminate if we find a branch.  */\n-      else if (is_branch (insn, &immed, &ra))\n-\tbreak;\n-    }\n-\n-\n-  /* If we successfully parsed until here, and didn't find any instruction\n-     modifying SP, we assume we have a frameless function.  */\n-  if (!found_sp)\n-    data->size = 0;\n-\n-  /* Return cooked instead of raw SP.  */\n-  if (data->cfa_reg == SPU_RAW_SP_REGNUM)\n-    data->cfa_reg = SPU_SP_REGNUM;\n-\n-  return prolog_pc;\n-}\n-\n-/* Return the first instruction after the prologue starting at PC.  */\n-static CORE_ADDR\n-spu_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n-{\n-  struct spu_prologue_data data;\n-  return spu_analyze_prologue (gdbarch, pc, (CORE_ADDR)-1, &data);\n-}\n-\n-/* Return the frame pointer in use at address PC.  */\n-static void\n-spu_virtual_frame_pointer (struct gdbarch *gdbarch, CORE_ADDR pc,\n-\t\t\t   int *reg, LONGEST *offset)\n-{\n-  struct spu_prologue_data data;\n-  spu_analyze_prologue (gdbarch, pc, (CORE_ADDR)-1, &data);\n-\n-  if (data.size != -1 && data.cfa_reg != -1)\n-    {\n-      /* The 'frame pointer' address is CFA minus frame size.  */\n-      *reg = data.cfa_reg;\n-      *offset = data.cfa_offset - data.size;\n-    }\n-  else\n-    {\n-      /* ??? We don't really know ...  */\n-      *reg = SPU_SP_REGNUM;\n-      *offset = 0;\n-    }\n-}\n-\n-/* Implement the stack_frame_destroyed_p gdbarch method.\n-\n-   1) scan forward from the point of execution:\n-       a) If you find an instruction that modifies the stack pointer\n-          or transfers control (except a return), execution is not in\n-          an epilogue, return.\n-       b) Stop scanning if you find a return instruction or reach the\n-          end of the function or reach the hard limit for the size of\n-          an epilogue.\n-   2) scan backward from the point of execution:\n-        a) If you find an instruction that modifies the stack pointer,\n-            execution *is* in an epilogue, return.\n-        b) Stop scanning if you reach an instruction that transfers\n-           control or the beginning of the function or reach the hard\n-           limit for the size of an epilogue.  */\n-\n-static int\n-spu_stack_frame_destroyed_p (struct gdbarch *gdbarch, CORE_ADDR pc)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  CORE_ADDR scan_pc, func_start, func_end, epilogue_start, epilogue_end;\n-  bfd_byte buf[4];\n-  unsigned int insn;\n-  int rt, ra, rb, immed;\n-\n-  /* Find the search limits based on function boundaries and hard limit.\n-     We assume the epilogue can be up to 64 instructions long.  */\n-\n-  const int spu_max_epilogue_size = 64 * 4;\n-\n-  if (!find_pc_partial_function (pc, NULL, &func_start, &func_end))\n-    return 0;\n-\n-  if (pc - func_start < spu_max_epilogue_size)\n-    epilogue_start = func_start;\n-  else\n-    epilogue_start = pc - spu_max_epilogue_size;\n-\n-  if (func_end - pc < spu_max_epilogue_size)\n-    epilogue_end = func_end;\n-  else\n-    epilogue_end = pc + spu_max_epilogue_size;\n-\n-  /* Scan forward until next 'bi $0'.  */\n-\n-  for (scan_pc = pc; scan_pc < epilogue_end; scan_pc += 4)\n-    {\n-      if (target_read_memory (scan_pc, buf, 4))\n-\treturn 0;\n-      insn = extract_unsigned_integer (buf, 4, byte_order);\n-\n-      if (is_branch (insn, &immed, &ra))\n-\t{\n-\t  if (immed == 0 && ra == SPU_LR_REGNUM)\n-\t    break;\n-\n-\t  return 0;\n-\t}\n-\n-      if (is_ri10 (insn, op_ai, &rt, &ra, &immed)\n-\t  || is_rr (insn, op_a, &rt, &ra, &rb)\n-\t  || is_ri10 (insn, op_lqd, &rt, &ra, &immed))\n-\t{\n-\t  if (rt == SPU_RAW_SP_REGNUM)\n-\t    return 0;\n-\t}\n-    }\n-\n-  if (scan_pc >= epilogue_end)\n-    return 0;\n-\n-  /* Scan backward until adjustment to stack pointer (R1).  */\n-\n-  for (scan_pc = pc - 4; scan_pc >= epilogue_start; scan_pc -= 4)\n-    {\n-      if (target_read_memory (scan_pc, buf, 4))\n-\treturn 0;\n-      insn = extract_unsigned_integer (buf, 4, byte_order);\n-\n-      if (is_branch (insn, &immed, &ra))\n-\treturn 0;\n-\n-      if (is_ri10 (insn, op_ai, &rt, &ra, &immed)\n-\t  || is_rr (insn, op_a, &rt, &ra, &rb)\n-\t  || is_ri10 (insn, op_lqd, &rt, &ra, &immed))\n-\t{\n-\t  if (rt == SPU_RAW_SP_REGNUM)\n-\t    return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Normal stack frames.  */\n-\n-struct spu_unwind_cache\n-{\n-  CORE_ADDR func;\n-  CORE_ADDR frame_base;\n-  CORE_ADDR local_base;\n-\n-  struct trad_frame_saved_reg *saved_regs;\n-};\n-\n-static struct spu_unwind_cache *\n-spu_frame_unwind_cache (struct frame_info *this_frame,\n-\t\t\tvoid **this_prologue_cache)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct spu_unwind_cache *info;\n-  struct spu_prologue_data data;\n-  CORE_ADDR id = tdep->id;\n-  gdb_byte buf[16];\n-\n-  if (*this_prologue_cache)\n-    return (struct spu_unwind_cache *) *this_prologue_cache;\n-\n-  info = FRAME_OBSTACK_ZALLOC (struct spu_unwind_cache);\n-  *this_prologue_cache = info;\n-  info->saved_regs = trad_frame_alloc_saved_regs (this_frame);\n-  info->frame_base = 0;\n-  info->local_base = 0;\n-\n-  /* Find the start of the current function, and analyze its prologue.  */\n-  info->func = get_frame_func (this_frame);\n-  if (info->func == 0)\n-    {\n-      /* Fall back to using the current PC as frame ID.  */\n-      info->func = get_frame_pc (this_frame);\n-      data.size = -1;\n-    }\n-  else\n-    spu_analyze_prologue (gdbarch, info->func, get_frame_pc (this_frame),\n-\t\t\t  &data);\n-\n-  /* If successful, use prologue analysis data.  */\n-  if (data.size != -1 && data.cfa_reg != -1)\n-    {\n-      CORE_ADDR cfa;\n-      int i;\n-\n-      /* Determine CFA via unwound CFA_REG plus CFA_OFFSET.  */\n-      get_frame_register (this_frame, data.cfa_reg, buf);\n-      cfa = extract_unsigned_integer (buf, 4, byte_order) + data.cfa_offset;\n-      cfa = SPUADDR (id, cfa);\n-\n-      /* Call-saved register slots.  */\n-      for (i = 0; i < SPU_NUM_GPRS; i++)\n-\tif (i == SPU_LR_REGNUM\n-\t    || (i >= SPU_SAVED1_REGNUM && i <= SPU_SAVEDN_REGNUM))\n-\t  if (data.reg_offset[i] != -1)\n-\t    info->saved_regs[i].addr = cfa - data.reg_offset[i];\n-\n-      /* Frame bases.  */\n-      info->frame_base = cfa;\n-      info->local_base = cfa - data.size;\n-    }\n-\n-  /* Otherwise, fall back to reading the backchain link.  */\n-  else\n-    {\n-      CORE_ADDR reg;\n-      LONGEST backchain;\n-      ULONGEST lslr;\n-      int status;\n-\n-      /* Get local store limit.  */\n-      lslr = get_frame_register_unsigned (this_frame, SPU_LSLR_REGNUM);\n-      if (!lslr)\n-\tlslr = (ULONGEST) -1;\n-\n-      /* Get the backchain.  */\n-      reg = get_frame_register_unsigned (this_frame, SPU_SP_REGNUM);\n-      status = safe_read_memory_integer (SPUADDR (id, reg), 4, byte_order,\n-\t\t\t\t\t &backchain);\n-\n-      /* A zero backchain terminates the frame chain.  Also, sanity\n-         check against the local store size limit.  */\n-      if (status && backchain > 0 && backchain <= lslr)\n-\t{\n-\t  /* Assume the link register is saved into its slot.  */\n-\t  if (backchain + 16 <= lslr)\n-\t    info->saved_regs[SPU_LR_REGNUM].addr = SPUADDR (id,\n-\t\t\t\t\t\t\t    backchain + 16);\n-\n-          /* Frame bases.  */\n-\t  info->frame_base = SPUADDR (id, backchain);\n-\t  info->local_base = SPUADDR (id, reg);\n-\t}\n-    }\n-\n-  /* If we didn't find a frame, we cannot determine SP / return address.  */\n-  if (info->frame_base == 0)\n-    return info;\n-\n-  /* The previous SP is equal to the CFA.  */\n-  trad_frame_set_value (info->saved_regs, SPU_SP_REGNUM,\n-\t\t\tSPUADDR_ADDR (info->frame_base));\n-\n-  /* Read full contents of the unwound link register in order to\n-     be able to determine the return address.  */\n-  if (trad_frame_addr_p (info->saved_regs, SPU_LR_REGNUM))\n-    target_read_memory (info->saved_regs[SPU_LR_REGNUM].addr, buf, 16);\n-  else\n-    get_frame_register (this_frame, SPU_LR_REGNUM, buf);\n-\n-  /* Normally, the return address is contained in the slot 0 of the\n-     link register, and slots 1-3 are zero.  For an overlay return,\n-     slot 0 contains the address of the overlay manager return stub,\n-     slot 1 contains the partition number of the overlay section to\n-     be returned to, and slot 2 contains the return address within\n-     that section.  Return the latter address in that case.  */\n-  if (extract_unsigned_integer (buf + 8, 4, byte_order) != 0)\n-    trad_frame_set_value (info->saved_regs, SPU_PC_REGNUM,\n-\t\t\t  extract_unsigned_integer (buf + 8, 4, byte_order));\n-  else\n-    trad_frame_set_value (info->saved_regs, SPU_PC_REGNUM,\n-\t\t\t  extract_unsigned_integer (buf, 4, byte_order));\n- \n-  return info;\n-}\n-\n-static void\n-spu_frame_this_id (struct frame_info *this_frame,\n-\t\t   void **this_prologue_cache, struct frame_id *this_id)\n-{\n-  struct spu_unwind_cache *info =\n-    spu_frame_unwind_cache (this_frame, this_prologue_cache);\n-\n-  if (info->frame_base == 0)\n-    return;\n-\n-  *this_id = frame_id_build (info->frame_base, info->func);\n-}\n-\n-static struct value *\n-spu_frame_prev_register (struct frame_info *this_frame,\n-\t\t\t void **this_prologue_cache, int regnum)\n-{\n-  struct spu_unwind_cache *info\n-    = spu_frame_unwind_cache (this_frame, this_prologue_cache);\n-\n-  /* Special-case the stack pointer.  */\n-  if (regnum == SPU_RAW_SP_REGNUM)\n-    regnum = SPU_SP_REGNUM;\n-\n-  return trad_frame_get_prev_register (this_frame, info->saved_regs, regnum);\n-}\n-\n-static const struct frame_unwind spu_frame_unwind = {\n-  NORMAL_FRAME,\n-  default_frame_unwind_stop_reason,\n-  spu_frame_this_id,\n-  spu_frame_prev_register,\n-  NULL,\n-  default_frame_sniffer\n-};\n-\n-static CORE_ADDR\n-spu_frame_base_address (struct frame_info *this_frame, void **this_cache)\n-{\n-  struct spu_unwind_cache *info\n-    = spu_frame_unwind_cache (this_frame, this_cache);\n-  return info->local_base;\n-}\n-\n-static const struct frame_base spu_frame_base = {\n-  &spu_frame_unwind,\n-  spu_frame_base_address,\n-  spu_frame_base_address,\n-  spu_frame_base_address\n-};\n-\n-static CORE_ADDR\n-spu_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  CORE_ADDR pc = frame_unwind_register_unsigned (next_frame, SPU_PC_REGNUM);\n-  /* Mask off interrupt enable bit.  */\n-  return SPUADDR (tdep->id, pc & -4);\n-}\n-\n-static CORE_ADDR\n-spu_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  CORE_ADDR sp = frame_unwind_register_unsigned (next_frame, SPU_SP_REGNUM);\n-  return SPUADDR (tdep->id, sp);\n-}\n-\n-static CORE_ADDR\n-spu_read_pc (readable_regcache *regcache)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (regcache->arch ());\n-  ULONGEST pc;\n-\n-  regcache->cooked_read (SPU_PC_REGNUM, &pc);\n-  /* Mask off interrupt enable bit.  */\n-  return SPUADDR (tdep->id, pc & -4);\n-}\n-\n-static void\n-spu_write_pc (struct regcache *regcache, CORE_ADDR pc)\n-{\n-  /* Keep interrupt enabled state unchanged.  */\n-  ULONGEST old_pc;\n-\n-  regcache_cooked_read_unsigned (regcache, SPU_PC_REGNUM, &old_pc);\n-  regcache_cooked_write_unsigned (regcache, SPU_PC_REGNUM,\n-\t\t\t\t  (SPUADDR_ADDR (pc) & -4) | (old_pc & 3));\n-}\n-\n-\n-/* Cell/B.E. cross-architecture unwinder support.  */\n-\n-struct spu2ppu_cache\n-{\n-  struct frame_id frame_id;\n-  readonly_detached_regcache *regcache;\n-};\n-\n-static struct gdbarch *\n-spu2ppu_prev_arch (struct frame_info *this_frame, void **this_cache)\n-{\n-  struct spu2ppu_cache *cache = (struct spu2ppu_cache *) *this_cache;\n-  return cache->regcache->arch ();\n-}\n-\n-static void\n-spu2ppu_this_id (struct frame_info *this_frame,\n-\t\t void **this_cache, struct frame_id *this_id)\n-{\n-  struct spu2ppu_cache *cache = (struct spu2ppu_cache *) *this_cache;\n-  *this_id = cache->frame_id;\n-}\n-\n-static struct value *\n-spu2ppu_prev_register (struct frame_info *this_frame,\n-\t\t       void **this_cache, int regnum)\n-{\n-  struct spu2ppu_cache *cache = (struct spu2ppu_cache *) *this_cache;\n-  struct gdbarch *gdbarch = cache->regcache->arch ();\n-  gdb_byte *buf;\n-\n-  buf = (gdb_byte *) alloca (register_size (gdbarch, regnum));\n-  cache->regcache->cooked_read (regnum, buf);\n-  return frame_unwind_got_bytes (this_frame, regnum, buf);\n-}\n-\n-static int\n-spu2ppu_sniffer (const struct frame_unwind *self,\n-\t\t struct frame_info *this_frame, void **this_prologue_cache)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  CORE_ADDR base, func, backchain;\n-  gdb_byte buf[4];\n-\n-  if (gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_spu)\n-    return 0;\n-\n-  base = get_frame_sp (this_frame);\n-  func = get_frame_pc (this_frame);\n-  if (target_read_memory (base, buf, 4))\n-    return 0;\n-  backchain = extract_unsigned_integer (buf, 4, byte_order);\n-\n-  if (!backchain)\n-    {\n-      struct frame_info *fi;\n-\n-      struct spu2ppu_cache *cache\n-\t= FRAME_OBSTACK_CALLOC (1, struct spu2ppu_cache);\n-\n-      cache->frame_id = frame_id_build (base + 16, func);\n-\n-      for (fi = get_next_frame (this_frame); fi; fi = get_next_frame (fi))\n-\tif (gdbarch_bfd_arch_info (get_frame_arch (fi))->arch != bfd_arch_spu)\n-\t  break;\n-\n-      if (fi)\n-\t{\n-\t  cache->regcache = frame_save_as_regcache (fi).release ();\n-\t  *this_prologue_cache = cache;\n-\t  return 1;\n-\t}\n-      else\n-\t{\n-\t  struct regcache *regcache;\n-\t  regcache = get_thread_arch_regcache (inferior_ptid, target_gdbarch ());\n-\t  cache->regcache = new readonly_detached_regcache (*regcache);\n-\t  *this_prologue_cache = cache;\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-static void\n-spu2ppu_dealloc_cache (struct frame_info *self, void *this_cache)\n-{\n-  struct spu2ppu_cache *cache = (struct spu2ppu_cache *) this_cache;\n-  delete cache->regcache;\n-}\n-\n-static const struct frame_unwind spu2ppu_unwind = {\n-  ARCH_FRAME,\n-  default_frame_unwind_stop_reason,\n-  spu2ppu_this_id,\n-  spu2ppu_prev_register,\n-  NULL,\n-  spu2ppu_sniffer,\n-  spu2ppu_dealloc_cache,\n-  spu2ppu_prev_arch,\n-};\n-\n-\n-/* Function calling convention.  */\n-\n-static CORE_ADDR\n-spu_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)\n-{\n-  return sp & ~15;\n-}\n-\n-static CORE_ADDR\n-spu_push_dummy_code (struct gdbarch *gdbarch, CORE_ADDR sp, CORE_ADDR funaddr,\n-\t\t     struct value **args, int nargs, struct type *value_type,\n-\t\t     CORE_ADDR *real_pc, CORE_ADDR *bp_addr,\n-\t\t     struct regcache *regcache)\n-{\n-  /* Allocate space sufficient for a breakpoint, keeping the stack aligned.  */\n-  sp = (sp - 4) & ~15;\n-  /* Store the address of that breakpoint */\n-  *bp_addr = sp;\n-  /* The call starts at the callee's entry point.  */\n-  *real_pc = funaddr;\n-\n-  return sp;\n-}\n-\n-static int\n-spu_scalar_value_p (struct type *type)\n-{\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_INT:\n-    case TYPE_CODE_ENUM:\n-    case TYPE_CODE_RANGE:\n-    case TYPE_CODE_CHAR:\n-    case TYPE_CODE_BOOL:\n-    case TYPE_CODE_PTR:\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_RVALUE_REF:\n-      return TYPE_LENGTH (type) <= 16;\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-static void\n-spu_value_to_regcache (struct regcache *regcache, int regnum,\n-\t\t       struct type *type, const gdb_byte *in)\n-{\n-  int len = TYPE_LENGTH (type);\n-\n-  if (spu_scalar_value_p (type))\n-    {\n-      int preferred_slot = len < 4 ? 4 - len : 0;\n-      regcache->cooked_write_part (regnum, preferred_slot, len, in);\n-    }\n-  else\n-    {\n-      while (len >= 16)\n-\t{\n-\t  regcache->cooked_write (regnum++, in);\n-\t  in += 16;\n-\t  len -= 16;\n-\t}\n-\n-      if (len > 0)\n-\tregcache->cooked_write_part (regnum, 0, len, in);\n-    }\n-}\n-\n-static void\n-spu_regcache_to_value (struct regcache *regcache, int regnum,\n-\t\t       struct type *type, gdb_byte *out)\n-{\n-  int len = TYPE_LENGTH (type);\n-\n-  if (spu_scalar_value_p (type))\n-    {\n-      int preferred_slot = len < 4 ? 4 - len : 0;\n-      regcache->cooked_read_part (regnum, preferred_slot, len, out);\n-    }\n-  else\n-    {\n-      while (len >= 16)\n-\t{\n-\t  regcache->cooked_read (regnum++, out);\n-\t  out += 16;\n-\t  len -= 16;\n-\t}\n-\n-      if (len > 0)\n-\tregcache->cooked_read_part (regnum, 0, len, out);\n-    }\n-}\n-\n-static CORE_ADDR\n-spu_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n-\t\t     struct regcache *regcache, CORE_ADDR bp_addr,\n-\t\t     int nargs, struct value **args, CORE_ADDR sp,\n-\t\t     function_call_return_method return_method,\n-\t\t     CORE_ADDR struct_addr)\n-{\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  CORE_ADDR sp_delta;\n-  int i;\n-  int regnum = SPU_ARG1_REGNUM;\n-  int stack_arg = -1;\n-  gdb_byte buf[16];\n-\n-  /* Set the return address.  */\n-  memset (buf, 0, sizeof buf);\n-  store_unsigned_integer (buf, 4, byte_order, SPUADDR_ADDR (bp_addr));\n-  regcache->cooked_write (SPU_LR_REGNUM, buf);\n-\n-  /* If STRUCT_RETURN is true, then the struct return address (in\n-     STRUCT_ADDR) will consume the first argument-passing register.\n-     Both adjust the register count and store that value.  */\n-  if (return_method == return_method_struct)\n-    {\n-      memset (buf, 0, sizeof buf);\n-      store_unsigned_integer (buf, 4, byte_order, SPUADDR_ADDR (struct_addr));\n-      regcache->cooked_write (regnum++, buf);\n-    }\n-\n-  /* Fill in argument registers.  */\n-  for (i = 0; i < nargs; i++)\n-    {\n-      struct value *arg = args[i];\n-      struct type *type = check_typedef (value_type (arg));\n-      const gdb_byte *contents = value_contents (arg);\n-      int n_regs = align_up (TYPE_LENGTH (type), 16) / 16;\n-\n-      /* If the argument doesn't wholly fit into registers, it and\n-\t all subsequent arguments go to the stack.  */\n-      if (regnum + n_regs - 1 > SPU_ARGN_REGNUM)\n-\t{\n-\t  stack_arg = i;\n-\t  break;\n-\t}\n-\n-      spu_value_to_regcache (regcache, regnum, type, contents);\n-      regnum += n_regs;\n-    }\n-\n-  /* Overflow arguments go to the stack.  */\n-  if (stack_arg != -1)\n-    {\n-      CORE_ADDR ap;\n-\n-      /* Allocate all required stack size.  */\n-      for (i = stack_arg; i < nargs; i++)\n-\t{\n-\t  struct type *type = check_typedef (value_type (args[i]));\n-\t  sp -= align_up (TYPE_LENGTH (type), 16);\n-\t}\n-\n-      /* Fill in stack arguments.  */\n-      ap = sp;\n-      for (i = stack_arg; i < nargs; i++)\n-\t{\n-\t  struct value *arg = args[i];\n-\t  struct type *type = check_typedef (value_type (arg));\n-\t  int len = TYPE_LENGTH (type);\n-\t  int preferred_slot;\n-\t  \n-\t  if (spu_scalar_value_p (type))\n-\t    preferred_slot = len < 4 ? 4 - len : 0;\n-\t  else\n-\t    preferred_slot = 0;\n-\n-\t  target_write_memory (ap + preferred_slot, value_contents (arg), len);\n-\t  ap += align_up (TYPE_LENGTH (type), 16);\n-\t}\n-    }\n-\n-  /* Allocate stack frame header.  */\n-  sp -= 32;\n-\n-  /* Store stack back chain.  */\n-  regcache->cooked_read (SPU_RAW_SP_REGNUM, buf);\n-  target_write_memory (sp, buf, 16);\n-\n-  /* Finally, update all slots of the SP register.  */\n-  sp_delta = sp - extract_unsigned_integer (buf, 4, byte_order);\n-  for (i = 0; i < 4; i++)\n-    {\n-      CORE_ADDR sp_slot = extract_unsigned_integer (buf + 4*i, 4, byte_order);\n-      store_unsigned_integer (buf + 4*i, 4, byte_order, sp_slot + sp_delta);\n-    }\n-  regcache->cooked_write (SPU_RAW_SP_REGNUM, buf);\n-\n-  return sp;\n-}\n-\n-static struct frame_id\n-spu_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)\n-{\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  CORE_ADDR pc = get_frame_register_unsigned (this_frame, SPU_PC_REGNUM);\n-  CORE_ADDR sp = get_frame_register_unsigned (this_frame, SPU_SP_REGNUM);\n-  return frame_id_build (SPUADDR (tdep->id, sp), SPUADDR (tdep->id, pc & -4));\n-}\n-\n-/* Function return value access.  */\n-\n-static enum return_value_convention\n-spu_return_value (struct gdbarch *gdbarch, struct value *function,\n-\t\t  struct type *type, struct regcache *regcache,\n-\t\t  gdb_byte *out, const gdb_byte *in)\n-{\n-  struct type *func_type = function ? value_type (function) : NULL;\n-  enum return_value_convention rvc;\n-  int opencl_vector = 0;\n-\n-  if (func_type)\n-    {\n-      func_type = check_typedef (func_type);\n-\n-      if (TYPE_CODE (func_type) == TYPE_CODE_PTR)\n-\tfunc_type = check_typedef (TYPE_TARGET_TYPE (func_type));\n-\n-      if (TYPE_CODE (func_type) == TYPE_CODE_FUNC\n-\t  && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GDB_IBM_OpenCL\n-\t  && TYPE_CODE (type) == TYPE_CODE_ARRAY\n-\t  && TYPE_VECTOR (type))\n-\topencl_vector = 1;\n-    }\n-\n-  if (TYPE_LENGTH (type) <= (SPU_ARGN_REGNUM - SPU_ARG1_REGNUM + 1) * 16)\n-    rvc = RETURN_VALUE_REGISTER_CONVENTION;\n-  else\n-    rvc = RETURN_VALUE_STRUCT_CONVENTION;\n-\n-  if (in)\n-    {\n-      switch (rvc)\n-\t{\n-\tcase RETURN_VALUE_REGISTER_CONVENTION:\n-\t  if (opencl_vector && TYPE_LENGTH (type) == 2)\n-\t    regcache->cooked_write_part (SPU_ARG1_REGNUM, 2, 2, in);\n-\t  else\n-\t    spu_value_to_regcache (regcache, SPU_ARG1_REGNUM, type, in);\n-\t  break;\n-\n-\tcase RETURN_VALUE_STRUCT_CONVENTION:\n-\t  error (_(\"Cannot set function return value.\"));\n-\t  break;\n-\t}\n-    }\n-  else if (out)\n-    {\n-      switch (rvc)\n-\t{\n-\tcase RETURN_VALUE_REGISTER_CONVENTION:\n-\t  if (opencl_vector && TYPE_LENGTH (type) == 2)\n-\t    regcache->cooked_read_part (SPU_ARG1_REGNUM, 2, 2, out);\n-\t  else\n-\t    spu_regcache_to_value (regcache, SPU_ARG1_REGNUM, type, out);\n-\t  break;\n-\n-\tcase RETURN_VALUE_STRUCT_CONVENTION:\n-\t  error (_(\"Function return value unknown.\"));\n-\t  break;\n-\t}\n-    }\n-\n-  return rvc;\n-}\n-\n-\n-/* Breakpoints.  */\n-constexpr gdb_byte spu_break_insn[] = { 0x00, 0x00, 0x3f, 0xff };\n-\n-typedef BP_MANIPULATION (spu_break_insn) spu_breakpoint;\n-\n-static int\n-spu_memory_remove_breakpoint (struct gdbarch *gdbarch,\n-\t\t\t      struct bp_target_info *bp_tgt)\n-{\n-  /* We work around a problem in combined Cell/B.E. debugging here.  Consider\n-     that in a combined application, we have some breakpoints inserted in SPU\n-     code, and now the application forks (on the PPU side).  GDB common code\n-     will assume that the fork system call copied all breakpoints into the new\n-     process' address space, and that all those copies now need to be removed\n-     (see breakpoint.c:detach_breakpoints).\n-\n-     While this is certainly true for PPU side breakpoints, it is not true\n-     for SPU side breakpoints.  fork will clone the SPU context file\n-     descriptors, so that all the existing SPU contexts are in accessible\n-     in the new process.  However, the contents of the SPU contexts themselves\n-     are *not* cloned.  Therefore the effect of detach_breakpoints is to\n-     remove SPU breakpoints from the *original* SPU context's local store\n-     -- this is not the correct behaviour.\n-\n-     The workaround is to check whether the PID we are asked to remove this\n-     breakpoint from (i.e. inferior_ptid.pid ()) is different from the\n-     PID of the current inferior (i.e. current_inferior ()->pid).  This is only\n-     true in the context of detach_breakpoints.  If so, we simply do nothing.\n-     [ Note that for the fork child process, it does not matter if breakpoints\n-     remain inserted, because those SPU contexts are not runnable anyway --\n-     the Linux kernel allows only the original process to invoke spu_run.  */\n-\n-  if (inferior_ptid.pid () != current_inferior ()->pid) \n-    return 0;\n-\n-  return default_memory_remove_breakpoint (gdbarch, bp_tgt);\n-}\n-\n-\n-/* Software single-stepping support.  */\n-\n-static std::vector<CORE_ADDR>\n-spu_software_single_step (struct regcache *regcache)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  CORE_ADDR pc, next_pc;\n-  unsigned int insn;\n-  int offset, reg;\n-  gdb_byte buf[4];\n-  ULONGEST lslr;\n-  std::vector<CORE_ADDR> next_pcs;\n-\n-  pc = regcache_read_pc (regcache);\n-\n-  if (target_read_memory (pc, buf, 4))\n-    throw_error (MEMORY_ERROR, _(\"Could not read instruction at %s.\"),\n-\t\t paddress (gdbarch, pc));\n-\n-  insn = extract_unsigned_integer (buf, 4, byte_order);\n-\n-  /* Get local store limit.  */\n-  if ((regcache_cooked_read_unsigned (regcache, SPU_LSLR_REGNUM, &lslr)\n-       != REG_VALID) || !lslr)\n-    lslr = (ULONGEST) -1;\n-\n-  /* Next sequential instruction is at PC + 4, except if the current\n-     instruction is a PPE-assisted call, in which case it is at PC + 8.\n-     Wrap around LS limit to be on the safe side.  */\n-  if ((insn & 0xffffff00) == 0x00002100)\n-    next_pc = (SPUADDR_ADDR (pc) + 8) & lslr;\n-  else\n-    next_pc = (SPUADDR_ADDR (pc) + 4) & lslr;\n-\n-  next_pcs.push_back (SPUADDR (SPUADDR_SPU (pc), next_pc));\n-\n-  if (is_branch (insn, &offset, &reg))\n-    {\n-      CORE_ADDR target = offset;\n-\n-      if (reg == SPU_PC_REGNUM)\n-\ttarget += SPUADDR_ADDR (pc);\n-      else if (reg != -1)\n-      {\n-\tregcache->raw_read_part (reg, 0, 4, buf);\n-\ttarget += extract_unsigned_integer (buf, 4, byte_order) & -4;\n-      }\n-\n-      target = target & lslr;\n-      if (target != next_pc)\n-\tnext_pcs.push_back (SPUADDR (SPUADDR_SPU (pc), target));\n-    }\n-\n-  return next_pcs;\n-}\n-\n-\n-/* Longjmp support.  */\n-\n-static int\n-spu_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  gdb_byte buf[4];\n-  CORE_ADDR jb_addr;\n-  int optim, unavail;\n-\n-  /* Jump buffer is pointed to by the argument register $r3.  */\n-  if (!get_frame_register_bytes (frame, SPU_ARG1_REGNUM, 0, 4, buf,\n-\t\t\t\t &optim, &unavail))\n-    return 0;\n-\n-  jb_addr = extract_unsigned_integer (buf, 4, byte_order);\n-  if (target_read_memory (SPUADDR (tdep->id, jb_addr), buf, 4))\n-    return 0;\n-\n-  *pc = extract_unsigned_integer (buf, 4, byte_order);\n-  *pc = SPUADDR (tdep->id, *pc);\n-  return 1;\n-}\n-\n-\n-/* Disassembler.  */\n-\n-struct spu_dis_asm_info : disassemble_info\n-{\n-  int id;\n-};\n-\n-static void\n-spu_dis_asm_print_address (bfd_vma addr, struct disassemble_info *info)\n-{\n-  struct spu_dis_asm_info *data = (struct spu_dis_asm_info *) info;\n-  gdb_disassembler *di\n-    = static_cast<gdb_disassembler *>(info->application_data);\n-\n-  print_address (di->arch (), SPUADDR (data->id, addr),\n-\t\t (struct ui_file *) info->stream);\n-}\n-\n-static int\n-gdb_print_insn_spu (bfd_vma memaddr, struct disassemble_info *info)\n-{\n-  /* The opcodes disassembler does 18-bit address arithmetic.  Make\n-     sure the SPU ID encoded in the high bits is added back when we\n-     call print_address.  */\n-  struct spu_dis_asm_info spu_info;\n-\n-  memcpy (&spu_info, info, sizeof (*info));\n-  spu_info.id = SPUADDR_SPU (memaddr);\n-  spu_info.print_address_func = spu_dis_asm_print_address;\n-  return default_print_insn (memaddr, &spu_info);\n-}\n-\n-\n-/* Target overlays for the SPU overlay manager.\n-\n-   See the documentation of simple_overlay_update for how the\n-   interface is supposed to work.\n-\n-   Data structures used by the overlay manager:\n-\n-   struct ovly_table\n-     {\n-        u32 vma;\n-        u32 size;\n-        u32 pos;\n-        u32 buf;\n-     } _ovly_table[];   -- one entry per overlay section\n-\n-   struct ovly_buf_table\n-     {\n-        u32 mapped;\n-     } _ovly_buf_table[];  -- one entry per overlay buffer\n-\n-   _ovly_table should never change.\n-\n-   Both tables are aligned to a 16-byte boundary, the symbols\n-   _ovly_table and _ovly_buf_table are of type STT_OBJECT and their\n-   size set to the size of the respective array. buf in _ovly_table is\n-   an index into _ovly_buf_table.\n-\n-   mapped is an index into _ovly_table.  Both the mapped and buf indices start\n-   from one to reference the first entry in their respective tables.  */\n-\n-/* Using the per-objfile private data mechanism, we store for each\n-   objfile an array of \"struct spu_overlay_table\" structures, one\n-   for each obj_section of the objfile.  This structure holds two\n-   fields, MAPPED_PTR and MAPPED_VAL.  If MAPPED_PTR is zero, this\n-   is *not* an overlay section.  If it is non-zero, it represents\n-   a target address.  The overlay section is mapped iff the target\n-   integer at this location equals MAPPED_VAL.  */\n-\n-struct spu_overlay_table\n-  {\n-    CORE_ADDR mapped_ptr;\n-    CORE_ADDR mapped_val;\n-  };\n-\n-static objfile_key<spu_overlay_table,\n-\t\t   gdb::noop_deleter<spu_overlay_table>> spu_overlay_data;\n-\n-/* Retrieve the overlay table for OBJFILE.  If not already cached, read\n-   the _ovly_table data structure from the target and initialize the\n-   spu_overlay_table data structure from it.  */\n-static struct spu_overlay_table *\n-spu_get_overlay_table (struct objfile *objfile)\n-{\n-  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd)?\n-\t\t   BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-  struct bound_minimal_symbol ovly_table_msym, ovly_buf_table_msym;\n-  CORE_ADDR ovly_table_base, ovly_buf_table_base;\n-  unsigned ovly_table_size, ovly_buf_table_size;\n-  struct spu_overlay_table *tbl;\n-  struct obj_section *osect;\n-  gdb_byte *ovly_table;\n-  int i;\n-\n-  tbl = spu_overlay_data.get (objfile);\n-  if (tbl)\n-    return tbl;\n-\n-  ovly_table_msym = lookup_minimal_symbol (\"_ovly_table\", NULL, objfile);\n-  if (!ovly_table_msym.minsym)\n-    return NULL;\n-\n-  ovly_buf_table_msym = lookup_minimal_symbol (\"_ovly_buf_table\",\n-\t\t\t\t\t       NULL, objfile);\n-  if (!ovly_buf_table_msym.minsym)\n-    return NULL;\n-\n-  ovly_table_base = BMSYMBOL_VALUE_ADDRESS (ovly_table_msym);\n-  ovly_table_size = MSYMBOL_SIZE (ovly_table_msym.minsym);\n-\n-  ovly_buf_table_base = BMSYMBOL_VALUE_ADDRESS (ovly_buf_table_msym);\n-  ovly_buf_table_size = MSYMBOL_SIZE (ovly_buf_table_msym.minsym);\n-\n-  ovly_table = (gdb_byte *) xmalloc (ovly_table_size);\n-  read_memory (ovly_table_base, ovly_table, ovly_table_size);\n-\n-  tbl = OBSTACK_CALLOC (&objfile->objfile_obstack,\n-\t\t\tobjfile->sections_end - objfile->sections,\n-\t\t\tstruct spu_overlay_table);\n-\n-  for (i = 0; i < ovly_table_size / 16; i++)\n-    {\n-      CORE_ADDR vma  = extract_unsigned_integer (ovly_table + 16*i + 0,\n-\t\t\t\t\t\t 4, byte_order);\n-      /* Note that this skips the \"size\" entry, which is at offset\n-\t 4.  */\n-      CORE_ADDR pos  = extract_unsigned_integer (ovly_table + 16*i + 8,\n-\t\t\t\t\t\t 4, byte_order);\n-      CORE_ADDR buf  = extract_unsigned_integer (ovly_table + 16*i + 12,\n-\t\t\t\t\t\t 4, byte_order);\n-\n-      if (buf == 0 || (buf - 1) * 4 >= ovly_buf_table_size)\n-\tcontinue;\n-\n-      ALL_OBJFILE_OSECTIONS (objfile, osect)\n-\tif (vma == bfd_section_vma (osect->the_bfd_section)\n-\t    && pos == osect->the_bfd_section->filepos)\n-\t  {\n-\t    int ndx = osect - objfile->sections;\n-\t    tbl[ndx].mapped_ptr = ovly_buf_table_base + (buf - 1) * 4;\n-\t    tbl[ndx].mapped_val = i + 1;\n-\t    break;\n-\t  }\n-    }\n-\n-  xfree (ovly_table);\n-  spu_overlay_data.set (objfile, tbl);\n-  return tbl;\n-}\n-\n-/* Read _ovly_buf_table entry from the target to dermine whether\n-   OSECT is currently mapped, and update the mapped state.  */\n-static void\n-spu_overlay_update_osect (struct obj_section *osect)\n-{\n-  enum bfd_endian byte_order = bfd_big_endian (osect->objfile->obfd)?\n-\t\t   BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;\n-  struct spu_overlay_table *ovly_table;\n-  CORE_ADDR id, val;\n-\n-  ovly_table = spu_get_overlay_table (osect->objfile);\n-  if (!ovly_table)\n-    return;\n-\n-  ovly_table += osect - osect->objfile->sections;\n-  if (ovly_table->mapped_ptr == 0)\n-    return;\n-\n-  id = SPUADDR_SPU (obj_section_addr (osect));\n-  val = read_memory_unsigned_integer (SPUADDR (id, ovly_table->mapped_ptr),\n-\t\t\t\t      4, byte_order);\n-  osect->ovly_mapped = (val == ovly_table->mapped_val);\n-}\n-\n-/* If OSECT is NULL, then update all sections' mapped state.\n-   If OSECT is non-NULL, then update only OSECT's mapped state.  */\n-static void\n-spu_overlay_update (struct obj_section *osect)\n-{\n-  /* Just one section.  */\n-  if (osect)\n-    spu_overlay_update_osect (osect);\n-\n-  /* All sections.  */\n-  else\n-    {\n-      for (objfile *objfile : current_program_space->objfiles ())\n-\tALL_OBJFILE_OSECTIONS (objfile, osect)\n-\t  if (section_is_overlay (osect))\n-\t    spu_overlay_update_osect (osect);\n-    }\n-}\n-\n-/* Whenever a new objfile is loaded, read the target's _ovly_table.\n-   If there is one, go through all sections and make sure for non-\n-   overlay sections LMA equals VMA, while for overlay sections LMA\n-   is larger than SPU_OVERLAY_LMA.  */\n-static void\n-spu_overlay_new_objfile (struct objfile *objfile)\n-{\n-  struct spu_overlay_table *ovly_table;\n-  struct obj_section *osect;\n-\n-  /* If we've already touched this file, do nothing.  */\n-  if (!objfile || spu_overlay_data.get (objfile) != NULL)\n-    return;\n-\n-  /* Consider only SPU objfiles.  */\n-  if (bfd_get_arch (objfile->obfd) != bfd_arch_spu)\n-    return;\n-\n-  /* Check if this objfile has overlays.  */\n-  ovly_table = spu_get_overlay_table (objfile);\n-  if (!ovly_table)\n-    return;\n-\n-  /* Now go and fiddle with all the LMAs.  */\n-  ALL_OBJFILE_OSECTIONS (objfile, osect)\n-    {\n-      asection *bsect = osect->the_bfd_section;\n-      int ndx = osect - objfile->sections;\n-\n-      if (ovly_table[ndx].mapped_ptr == 0)\n-\tbfd_set_section_lma (bsect, bfd_section_vma (bsect));\n-      else\n-\tbfd_set_section_lma (bsect, SPU_OVERLAY_LMA + bsect->filepos);\n-    }\n-}\n-\n-\n-/* Insert temporary breakpoint on \"main\" function of newly loaded\n-   SPE context OBJFILE.  */\n-static void\n-spu_catch_start (struct objfile *objfile)\n-{\n-  struct bound_minimal_symbol minsym;\n-  struct compunit_symtab *cust;\n-  CORE_ADDR pc;\n-\n-  /* Do this only if requested by \"set spu stop-on-load on\".  */\n-  if (!spu_stop_on_load_p)\n-    return;\n-\n-  /* Consider only SPU objfiles.  */\n-  if (!objfile || bfd_get_arch (objfile->obfd) != bfd_arch_spu)\n-    return;\n-\n-  /* The main objfile is handled differently.  */\n-  if (objfile == symfile_objfile)\n-    return;\n-\n-  /* There can be multiple symbols named \"main\".  Search for the\n-     \"main\" in *this* objfile.  */\n-  minsym = lookup_minimal_symbol (\"main\", NULL, objfile);\n-  if (!minsym.minsym)\n-    return;\n-\n-  /* If we have debugging information, try to use it -- this\n-     will allow us to properly skip the prologue.  */\n-  pc = BMSYMBOL_VALUE_ADDRESS (minsym);\n-  cust\n-    = find_pc_sect_compunit_symtab (pc, MSYMBOL_OBJ_SECTION (minsym.objfile,\n-\t\t\t\t\t\t\t     minsym.minsym));\n-  if (cust != NULL)\n-    {\n-      const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (cust);\n-      const struct block *block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n-      struct symbol *sym;\n-      struct symtab_and_line sal;\n-\n-      sym = block_lookup_symbol (block, \"main\",\n-\t\t\t\t symbol_name_match_type::SEARCH_NAME,\n-\t\t\t\t VAR_DOMAIN);\n-      if (sym)\n-\t{\n-\t  fixup_symbol_section (sym, objfile);\n-\t  sal = find_function_start_sal (sym, 1);\n-\t  pc = sal.pc;\n-\t}\n-    }\n-\n-  /* Use a numerical address for the set_breakpoint command to avoid having\n-     the breakpoint re-set incorrectly.  */\n-  event_location_up location = new_address_location (pc, NULL, 0);\n-  create_breakpoint (get_objfile_arch (objfile), location.get (),\n-\t\t     NULL /* cond_string */, -1 /* thread */,\n-\t\t     NULL /* extra_string */,\n-\t\t     0 /* parse_condition_and_thread */, 1 /* tempflag */,\n-\t\t     bp_breakpoint /* type_wanted */,\n-\t\t     0 /* ignore_count */,\n-\t\t     AUTO_BOOLEAN_FALSE /* pending_break_support */,\n-\t\t     &bkpt_breakpoint_ops /* ops */, 0 /* from_tty */,\n-\t\t     1 /* enabled */, 0 /* internal  */, 0);\n-}\n-\n-\n-/* Look up OBJFILE loaded into FRAME's SPU context.  */\n-static struct objfile *\n-spu_objfile_from_frame (struct frame_info *frame)\n-{\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    return NULL;\n-\n-  for (objfile *obj : current_program_space->objfiles ())\n-    {\n-      if (obj->sections != obj->sections_end\n-\t  && SPUADDR_SPU (obj_section_addr (obj->sections)) == tdep->id)\n-\treturn obj;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Flush cache for ea pointer access if available.  */\n-static void\n-flush_ea_cache (void)\n-{\n-  struct bound_minimal_symbol msymbol;\n-  struct objfile *obj;\n-\n-  if (!has_stack_frames ())\n-    return;\n-\n-  obj = spu_objfile_from_frame (get_current_frame ());\n-  if (obj == NULL)\n-    return;\n-\n-  /* Lookup inferior function __cache_flush.  */\n-  msymbol = lookup_minimal_symbol (\"__cache_flush\", NULL, obj);\n-  if (msymbol.minsym != NULL)\n-    {\n-      struct type *type;\n-      CORE_ADDR addr;\n-\n-      type = objfile_type (obj)->builtin_void;\n-      type = lookup_function_type (type);\n-      type = lookup_pointer_type (type);\n-      addr = BMSYMBOL_VALUE_ADDRESS (msymbol);\n-\n-      call_function_by_hand (value_from_pointer (type, addr), NULL, {});\n-    }\n-}\n-\n-/* This handler is called when the inferior has stopped.  If it is stopped in\n-   SPU architecture then flush the ea cache if used.  */\n-static void\n-spu_attach_normal_stop (struct bpstats *bs, int print_frame)\n-{\n-  if (!spu_auto_flush_cache_p)\n-    return;\n-\n-  /* Temporarily reset spu_auto_flush_cache_p to avoid recursively\n-     re-entering this function when __cache_flush stops.  */\n-  spu_auto_flush_cache_p = 0;\n-  flush_ea_cache ();\n-  spu_auto_flush_cache_p = 1;\n-}\n-\n-\n-/* \"info spu\" commands.  */\n-\n-static void\n-info_spu_event_command (const char *args, int from_tty)\n-{\n-  struct frame_info *frame = get_selected_frame (NULL);\n-  ULONGEST event_status = 0;\n-  ULONGEST event_mask = 0;\n-  gdb_byte buf[100];\n-  char annex[32];\n-  LONGEST len;\n-  int id;\n-\n-  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)\n-    error (_(\"\\\"info spu\\\" is only supported on the SPU architecture.\"));\n-\n-  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);\n-\n-  xsnprintf (annex, sizeof annex, \"%d/event_status\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, (sizeof (buf) - 1));\n-  if (len <= 0)\n-    error (_(\"Could not read event_status.\"));\n-  buf[len] = '\\0';\n-  event_status = strtoulst ((char *) buf, NULL, 16);\n- \n-  xsnprintf (annex, sizeof annex, \"%d/event_mask\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, (sizeof (buf) - 1));\n-  if (len <= 0)\n-    error (_(\"Could not read event_mask.\"));\n-  buf[len] = '\\0';\n-  event_mask = strtoulst ((char *) buf, NULL, 16);\n- \n-  ui_out_emit_tuple tuple_emitter (current_uiout, \"SPUInfoEvent\");\n-\n-  current_uiout->text (_(\"Event Status \"));\n-  current_uiout->field_fmt (\"event_status\", \"0x%s\", phex (event_status, 4));\n-  current_uiout->text (\"\\n\");\n-  current_uiout->text (_(\"Event Mask   \"));\n-  current_uiout->field_fmt (\"event_mask\", \"0x%s\", phex (event_mask, 4));\n-  current_uiout->text (\"\\n\");\n-}\n-\n-static void\n-info_spu_signal_command (const char *args, int from_tty)\n-{\n-  struct frame_info *frame = get_selected_frame (NULL);\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  ULONGEST signal1 = 0;\n-  ULONGEST signal1_type = 0;\n-  int signal1_pending = 0;\n-  ULONGEST signal2 = 0;\n-  ULONGEST signal2_type = 0;\n-  int signal2_pending = 0;\n-  char annex[32];\n-  gdb_byte buf[100];\n-  LONGEST len;\n-  int id;\n-\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    error (_(\"\\\"info spu\\\" is only supported on the SPU architecture.\"));\n-\n-  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);\n-\n-  xsnprintf (annex, sizeof annex, \"%d/signal1\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU,\n-\t\t     annex, buf, 0, 4);\n-  if (len < 0)\n-    error (_(\"Could not read signal1.\"));\n-  else if (len == 4)\n-    {\n-      signal1 = extract_unsigned_integer (buf, 4, byte_order);\n-      signal1_pending = 1;\n-    }\n-    \n-  xsnprintf (annex, sizeof annex, \"%d/signal1_type\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, (sizeof (buf) - 1));\n-  if (len <= 0)\n-    error (_(\"Could not read signal1_type.\"));\n-  buf[len] = '\\0';\n-  signal1_type = strtoulst ((char *) buf, NULL, 16);\n-\n-  xsnprintf (annex, sizeof annex, \"%d/signal2\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU,\n-\t\t     annex, buf, 0, 4);\n-  if (len < 0)\n-    error (_(\"Could not read signal2.\"));\n-  else if (len == 4)\n-    {\n-      signal2 = extract_unsigned_integer (buf, 4, byte_order);\n-      signal2_pending = 1;\n-    }\n-    \n-  xsnprintf (annex, sizeof annex, \"%d/signal2_type\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, (sizeof (buf) - 1));\n-  if (len <= 0)\n-    error (_(\"Could not read signal2_type.\"));\n-  buf[len] = '\\0';\n-  signal2_type = strtoulst ((char *) buf, NULL, 16);\n-\n-  ui_out_emit_tuple tuple_emitter (current_uiout, \"SPUInfoSignal\");\n-\n-  if (current_uiout->is_mi_like_p ())\n-    {\n-      current_uiout->field_signed (\"signal1_pending\", signal1_pending);\n-      current_uiout->field_fmt (\"signal1\", \"0x%s\", phex_nz (signal1, 4));\n-      current_uiout->field_signed (\"signal1_type\", signal1_type);\n-      current_uiout->field_signed (\"signal2_pending\", signal2_pending);\n-      current_uiout->field_fmt (\"signal2\", \"0x%s\", phex_nz (signal2, 4));\n-      current_uiout->field_signed (\"signal2_type\", signal2_type);\n-    }\n-  else\n-    {\n-      if (signal1_pending)\n-\tprintf_filtered (_(\"Signal 1 control word 0x%s \"), phex (signal1, 4));\n-      else\n-\tprintf_filtered (_(\"Signal 1 not pending \"));\n-\n-      if (signal1_type)\n-\tprintf_filtered (_(\"(Type Or)\\n\"));\n-      else\n-\tprintf_filtered (_(\"(Type Overwrite)\\n\"));\n-\n-      if (signal2_pending)\n-\tprintf_filtered (_(\"Signal 2 control word 0x%s \"), phex (signal2, 4));\n-      else\n-\tprintf_filtered (_(\"Signal 2 not pending \"));\n-\n-      if (signal2_type)\n-\tprintf_filtered (_(\"(Type Or)\\n\"));\n-      else\n-\tprintf_filtered (_(\"(Type Overwrite)\\n\"));\n-    }\n-}\n-\n-static void\n-info_spu_mailbox_list (gdb_byte *buf, int nr, enum bfd_endian byte_order,\n-\t\t       const char *field, const char *msg)\n-{\n-  int i;\n-\n-  if (nr <= 0)\n-    return;\n-\n-  ui_out_emit_table table_emitter (current_uiout, 1, nr, \"mbox\");\n-\n-  current_uiout->table_header (32, ui_left, field, msg);\n-  current_uiout->table_body ();\n-\n-  for (i = 0; i < nr; i++)\n-    {\n-      {\n-\tULONGEST val;\n-\tui_out_emit_tuple tuple_emitter (current_uiout, \"mbox\");\n-\tval = extract_unsigned_integer (buf + 4*i, 4, byte_order);\n-\tcurrent_uiout->field_fmt (field, \"0x%s\", phex (val, 4));\n-      }\n-\n-      current_uiout->text (\"\\n\");\n-    }\n-}\n-\n-static void\n-info_spu_mailbox_command (const char *args, int from_tty)\n-{\n-  struct frame_info *frame = get_selected_frame (NULL);\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  char annex[32];\n-  gdb_byte buf[1024];\n-  LONGEST len;\n-  int id;\n-\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    error (_(\"\\\"info spu\\\" is only supported on the SPU architecture.\"));\n-\n-  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);\n-\n-  ui_out_emit_tuple tuple_emitter (current_uiout, \"SPUInfoMailbox\");\n-\n-  xsnprintf (annex, sizeof annex, \"%d/mbox_info\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, sizeof buf);\n-  if (len < 0)\n-    error (_(\"Could not read mbox_info.\"));\n-\n-  info_spu_mailbox_list (buf, len / 4, byte_order,\n-\t\t\t \"mbox\", \"SPU Outbound Mailbox\");\n-\n-  xsnprintf (annex, sizeof annex, \"%d/ibox_info\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, sizeof buf);\n-  if (len < 0)\n-    error (_(\"Could not read ibox_info.\"));\n-\n-  info_spu_mailbox_list (buf, len / 4, byte_order,\n-\t\t\t \"ibox\", \"SPU Outbound Interrupt Mailbox\");\n-\n-  xsnprintf (annex, sizeof annex, \"%d/wbox_info\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, sizeof buf);\n-  if (len < 0)\n-    error (_(\"Could not read wbox_info.\"));\n-\n-  info_spu_mailbox_list (buf, len / 4, byte_order,\n-\t\t\t \"wbox\", \"SPU Inbound Mailbox\");\n-}\n-\n-static ULONGEST\n-spu_mfc_get_bitfield (ULONGEST word, int first, int last)\n-{\n-  ULONGEST mask = ~(~(ULONGEST)0 << (last - first + 1));\n-  return (word >> (63 - last)) & mask;\n-}\n-\n-static void\n-info_spu_dma_cmdlist (gdb_byte *buf, int nr, enum bfd_endian byte_order)\n-{\n-  static const char *spu_mfc_opcode[256] =\n-    {\n-    /* 00 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 10 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 20 */ \"put\", \"putb\", \"putf\", NULL, \"putl\", \"putlb\", \"putlf\", NULL,\n-             \"puts\", \"putbs\", \"putfs\", NULL, NULL, NULL, NULL, NULL,\n-    /* 30 */ \"putr\", \"putrb\", \"putrf\", NULL, \"putrl\", \"putrlb\", \"putrlf\", NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 40 */ \"get\", \"getb\", \"getf\", NULL, \"getl\", \"getlb\", \"getlf\", NULL,\n-             \"gets\", \"getbs\", \"getfs\", NULL, NULL, NULL, NULL, NULL,\n-    /* 50 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 60 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 70 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* 80 */ \"sdcrt\", \"sdcrtst\", NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, \"sdcrz\", NULL, NULL, NULL, \"sdcrst\", NULL, \"sdcrf\",\n-    /* 90 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* a0 */ \"sndsig\", \"sndsigb\", \"sndsigf\", NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* b0 */ \"putlluc\", NULL, NULL, NULL, \"putllc\", NULL, NULL, NULL,\n-             \"putqlluc\", NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* c0 */ \"barrier\", NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             \"mfceieio\", NULL, NULL, NULL, \"mfcsync\", NULL, NULL, NULL,\n-    /* d0 */ \"getllar\", NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* e0 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    /* f0 */ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-             NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,\n-    };\n-\n-  int *seq = XALLOCAVEC (int, nr);\n-  int done = 0;\n-  int i, j;\n-\n-\n-  /* Determine sequence in which to display (valid) entries.  */\n-  for (i = 0; i < nr; i++)\n-    {\n-      /* Search for the first valid entry all of whose\n-\t dependencies are met.  */\n-      for (j = 0; j < nr; j++)\n-\t{\n-          ULONGEST mfc_cq_dw3;\n-\t  ULONGEST dependencies;\n-\n-\t  if (done & (1 << (nr - 1 - j)))\n-\t    continue;\n-\n-\t  mfc_cq_dw3\n-\t    = extract_unsigned_integer (buf + 32*j + 24,8, byte_order);\n-\t  if (!spu_mfc_get_bitfield (mfc_cq_dw3, 16, 16))\n-\t    continue;\n-\n-\t  dependencies = spu_mfc_get_bitfield (mfc_cq_dw3, 0, nr - 1);\n-\t  if ((dependencies & done) != dependencies)\n-\t    continue;\n-\n-\t  seq[i] = j;\n-\t  done |= 1 << (nr - 1 - j);\n-\t  break;\n-\t}\n-\n-      if (j == nr)\n-\tbreak;\n-    }\n-\n-  nr = i;\n-\n-\n-  ui_out_emit_table table_emitter (current_uiout, 10, nr, \"dma_cmd\");\n-\n-  current_uiout->table_header (7, ui_left, \"opcode\", \"Opcode\");\n-  current_uiout->table_header (3, ui_left, \"tag\", \"Tag\");\n-  current_uiout->table_header (3, ui_left, \"tid\", \"TId\");\n-  current_uiout->table_header (3, ui_left, \"rid\", \"RId\");\n-  current_uiout->table_header (18, ui_left, \"ea\", \"EA\");\n-  current_uiout->table_header (7, ui_left, \"lsa\", \"LSA\");\n-  current_uiout->table_header (7, ui_left, \"size\", \"Size\");\n-  current_uiout->table_header (7, ui_left, \"lstaddr\", \"LstAddr\");\n-  current_uiout->table_header (7, ui_left, \"lstsize\", \"LstSize\");\n-  current_uiout->table_header (1, ui_left, \"error_p\", \"E\");\n-\n-  current_uiout->table_body ();\n-\n-  for (i = 0; i < nr; i++)\n-    {\n-      ULONGEST mfc_cq_dw0;\n-      ULONGEST mfc_cq_dw1;\n-      ULONGEST mfc_cq_dw2;\n-      int mfc_cmd_opcode, mfc_cmd_tag, rclass_id, tclass_id;\n-      int list_lsa, list_size, mfc_lsa, mfc_size;\n-      ULONGEST mfc_ea;\n-      int list_valid_p, qw_valid_p, ea_valid_p, cmd_error_p;\n-\n-      /* Decode contents of MFC Command Queue Context Save/Restore Registers.\n-\t See \"Cell Broadband Engine Registers V1.3\", section 3.3.2.1.  */\n-\n-      mfc_cq_dw0\n-\t= extract_unsigned_integer (buf + 32*seq[i], 8, byte_order);\n-      mfc_cq_dw1\n-\t= extract_unsigned_integer (buf + 32*seq[i] + 8, 8, byte_order);\n-      mfc_cq_dw2\n-\t= extract_unsigned_integer (buf + 32*seq[i] + 16, 8, byte_order);\n-\n-      list_lsa = spu_mfc_get_bitfield (mfc_cq_dw0, 0, 14);\n-      list_size = spu_mfc_get_bitfield (mfc_cq_dw0, 15, 26);\n-      mfc_cmd_opcode = spu_mfc_get_bitfield (mfc_cq_dw0, 27, 34);\n-      mfc_cmd_tag = spu_mfc_get_bitfield (mfc_cq_dw0, 35, 39);\n-      list_valid_p = spu_mfc_get_bitfield (mfc_cq_dw0, 40, 40);\n-      rclass_id = spu_mfc_get_bitfield (mfc_cq_dw0, 41, 43);\n-      tclass_id = spu_mfc_get_bitfield (mfc_cq_dw0, 44, 46);\n-\n-      mfc_ea = spu_mfc_get_bitfield (mfc_cq_dw1, 0, 51) << 12\n-\t\t| spu_mfc_get_bitfield (mfc_cq_dw2, 25, 36);\n-\n-      mfc_lsa = spu_mfc_get_bitfield (mfc_cq_dw2, 0, 13);\n-      mfc_size = spu_mfc_get_bitfield (mfc_cq_dw2, 14, 24);\n-      qw_valid_p = spu_mfc_get_bitfield (mfc_cq_dw2, 38, 38);\n-      ea_valid_p = spu_mfc_get_bitfield (mfc_cq_dw2, 39, 39);\n-      cmd_error_p = spu_mfc_get_bitfield (mfc_cq_dw2, 40, 40);\n-\n-      {\n-\tui_out_emit_tuple tuple_emitter (current_uiout, \"cmd\");\n-\n-\tif (spu_mfc_opcode[mfc_cmd_opcode])\n-\t  current_uiout->field_string (\"opcode\", spu_mfc_opcode[mfc_cmd_opcode]);\n-\telse\n-\t  current_uiout->field_signed (\"opcode\", mfc_cmd_opcode);\n-\n-\tcurrent_uiout->field_signed (\"tag\", mfc_cmd_tag);\n-\tcurrent_uiout->field_signed (\"tid\", tclass_id);\n-\tcurrent_uiout->field_signed (\"rid\", rclass_id);\n-\n-\tif (ea_valid_p)\n-\t  current_uiout->field_fmt (\"ea\", \"0x%s\", phex (mfc_ea, 8));\n-\telse\n-\t  current_uiout->field_skip (\"ea\");\n-\n-\tcurrent_uiout->field_fmt (\"lsa\", \"0x%05x\", mfc_lsa << 4);\n-\tif (qw_valid_p)\n-\t  current_uiout->field_fmt (\"size\", \"0x%05x\", mfc_size << 4);\n-\telse\n-\t  current_uiout->field_fmt (\"size\", \"0x%05x\", mfc_size);\n-\n-\tif (list_valid_p)\n-\t  {\n-\t    current_uiout->field_fmt (\"lstaddr\", \"0x%05x\", list_lsa << 3);\n-\t    current_uiout->field_fmt (\"lstsize\", \"0x%05x\", list_size << 3);\n-\t  }\n-\telse\n-\t  {\n-\t    current_uiout->field_skip (\"lstaddr\");\n-\t    current_uiout->field_skip (\"lstsize\");\n-\t  }\n-\n-\tif (cmd_error_p)\n-\t  current_uiout->field_string (\"error_p\", \"*\");\n-\telse\n-\t  current_uiout->field_skip (\"error_p\");\n-      }\n-\n-      current_uiout->text (\"\\n\");\n-    }\n-}\n-\n-static void\n-info_spu_dma_command (const char *args, int from_tty)\n-{\n-  struct frame_info *frame = get_selected_frame (NULL);\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  ULONGEST dma_info_type;\n-  ULONGEST dma_info_mask;\n-  ULONGEST dma_info_status;\n-  ULONGEST dma_info_stall_and_notify;\n-  ULONGEST dma_info_atomic_command_status;\n-  char annex[32];\n-  gdb_byte buf[1024];\n-  LONGEST len;\n-  int id;\n-\n-  if (gdbarch_bfd_arch_info (get_frame_arch (frame))->arch != bfd_arch_spu)\n-    error (_(\"\\\"info spu\\\" is only supported on the SPU architecture.\"));\n-\n-  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);\n-\n-  xsnprintf (annex, sizeof annex, \"%d/dma_info\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, 40 + 16 * 32);\n-  if (len <= 0)\n-    error (_(\"Could not read dma_info.\"));\n-\n-  dma_info_type\n-    = extract_unsigned_integer (buf, 8, byte_order);\n-  dma_info_mask\n-    = extract_unsigned_integer (buf + 8, 8, byte_order);\n-  dma_info_status\n-    = extract_unsigned_integer (buf + 16, 8, byte_order);\n-  dma_info_stall_and_notify\n-    = extract_unsigned_integer (buf + 24, 8, byte_order);\n-  dma_info_atomic_command_status\n-    = extract_unsigned_integer (buf + 32, 8, byte_order);\n-  \n-  ui_out_emit_tuple tuple_emitter (current_uiout, \"SPUInfoDMA\");\n-\n-  if (current_uiout->is_mi_like_p ())\n-    {\n-      current_uiout->field_fmt (\"dma_info_type\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_type, 4));\n-      current_uiout->field_fmt (\"dma_info_mask\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_mask, 4));\n-      current_uiout->field_fmt (\"dma_info_status\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_status, 4));\n-      current_uiout->field_fmt (\"dma_info_stall_and_notify\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_stall_and_notify, 4));\n-      current_uiout->field_fmt (\"dma_info_atomic_command_status\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_atomic_command_status, 4));\n-    }\n-  else\n-    {\n-      const char *query_msg = _(\"no query pending\");\n-\n-      if (dma_info_type & 4)\n-\tswitch (dma_info_type & 3)\n-\t  {\n-\t    case 1: query_msg = _(\"'any' query pending\"); break;\n-\t    case 2: query_msg = _(\"'all' query pending\"); break;\n-\t    default: query_msg = _(\"undefined query type\"); break;\n-\t  }\n-\n-      printf_filtered (_(\"Tag-Group Status  0x%s\\n\"),\n-\t\t       phex (dma_info_status, 4));\n-      printf_filtered (_(\"Tag-Group Mask    0x%s (%s)\\n\"),\n-\t\t       phex (dma_info_mask, 4), query_msg);\n-      printf_filtered (_(\"Stall-and-Notify  0x%s\\n\"),\n-\t\t       phex (dma_info_stall_and_notify, 4));\n-      printf_filtered (_(\"Atomic Cmd Status 0x%s\\n\"),\n-\t\t       phex (dma_info_atomic_command_status, 4));\n-      printf_filtered (\"\\n\");\n-    }\n-\n-  info_spu_dma_cmdlist (buf + 40, 16, byte_order);\n-}\n-\n-static void\n-info_spu_proxydma_command (const char *args, int from_tty)\n-{\n-  struct frame_info *frame = get_selected_frame (NULL);\n-  struct gdbarch *gdbarch = get_frame_arch (frame);\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  ULONGEST dma_info_type;\n-  ULONGEST dma_info_mask;\n-  ULONGEST dma_info_status;\n-  char annex[32];\n-  gdb_byte buf[1024];\n-  LONGEST len;\n-  int id;\n-\n-  if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n-    error (_(\"\\\"info spu\\\" is only supported on the SPU architecture.\"));\n-\n-  id = get_frame_register_unsigned (frame, SPU_ID_REGNUM);\n-\n-  xsnprintf (annex, sizeof annex, \"%d/proxydma_info\", id);\n-  len = target_read (current_top_target (), TARGET_OBJECT_SPU, annex,\n-\t\t     buf, 0, 24 + 8 * 32);\n-  if (len <= 0)\n-    error (_(\"Could not read proxydma_info.\"));\n-\n-  dma_info_type = extract_unsigned_integer (buf, 8, byte_order);\n-  dma_info_mask = extract_unsigned_integer (buf + 8, 8, byte_order);\n-  dma_info_status = extract_unsigned_integer (buf + 16, 8, byte_order);\n-  \n-  ui_out_emit_tuple tuple_emitter (current_uiout, \"SPUInfoProxyDMA\");\n-\n-  if (current_uiout->is_mi_like_p ())\n-    {\n-      current_uiout->field_fmt (\"proxydma_info_type\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_type, 4));\n-      current_uiout->field_fmt (\"proxydma_info_mask\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_mask, 4));\n-      current_uiout->field_fmt (\"proxydma_info_status\", \"0x%s\",\n-\t\t\t\tphex_nz (dma_info_status, 4));\n-    }\n-  else\n-    {\n-      const char *query_msg;\n-\n-      switch (dma_info_type & 3)\n-\t{\n-\tcase 0: query_msg = _(\"no query pending\"); break;\n-\tcase 1: query_msg = _(\"'any' query pending\"); break;\n-\tcase 2: query_msg = _(\"'all' query pending\"); break;\n-\tdefault: query_msg = _(\"undefined query type\"); break;\n-\t}\n-\n-      printf_filtered (_(\"Tag-Group Status  0x%s\\n\"),\n-\t\t       phex (dma_info_status, 4));\n-      printf_filtered (_(\"Tag-Group Mask    0x%s (%s)\\n\"),\n-\t\t       phex (dma_info_mask, 4), query_msg);\n-      printf_filtered (\"\\n\");\n-    }\n-\n-  info_spu_dma_cmdlist (buf + 24, 8, byte_order);\n-}\n-\n-static void\n-info_spu_command (const char *args, int from_tty)\n-{\n-  printf_unfiltered (_(\"\\\"info spu\\\" must be followed by \"\n-\t\t       \"the name of an SPU facility.\\n\"));\n-  help_list (infospucmdlist, \"info spu \", all_commands, gdb_stdout);\n-}\n-\n-\n-/* Root of all \"set spu \"/\"show spu \" commands.  */\n-\n-static void\n-show_spu_command (const char *args, int from_tty)\n-{\n-  help_list (showspucmdlist, \"show spu \", all_commands, gdb_stdout);\n-}\n-\n-static void\n-set_spu_command (const char *args, int from_tty)\n-{\n-  help_list (setspucmdlist, \"set spu \", all_commands, gdb_stdout);\n-}\n-\n-static void\n-show_spu_stop_on_load (struct ui_file *file, int from_tty,\n-                       struct cmd_list_element *c, const char *value)\n-{\n-  fprintf_filtered (file, _(\"Stopping for new SPE threads is %s.\\n\"),\n-                    value);\n-}\n-\n-static void\n-show_spu_auto_flush_cache (struct ui_file *file, int from_tty,\n-\t\t\t   struct cmd_list_element *c, const char *value)\n-{\n-  fprintf_filtered (file, _(\"Automatic software-cache flush is %s.\\n\"),\n-                    value);\n-}\n-\n-\n-/* Set up gdbarch struct.  */\n-\n-static struct gdbarch *\n-spu_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n-{\n-  struct gdbarch *gdbarch;\n-  struct gdbarch_tdep *tdep;\n-  int id = -1;\n-\n-  /* Which spufs ID was requested as address space?  */\n-  if (info.id)\n-    id = *info.id;\n-  /* For objfile architectures of SPU solibs, decode the ID from the name.\n-     This assumes the filename convention employed by solib-spu.c.  */\n-  else if (info.abfd)\n-    {\n-      const char *name = strrchr (info.abfd->filename, '@');\n-      if (name)\n-\tsscanf (name, \"@0x%*x <%d>\", &id);\n-    }\n-\n-  /* Find a candidate among extant architectures.  */\n-  for (arches = gdbarch_list_lookup_by_info (arches, &info);\n-       arches != NULL;\n-       arches = gdbarch_list_lookup_by_info (arches->next, &info))\n-    {\n-      tdep = gdbarch_tdep (arches->gdbarch);\n-      if (tdep && tdep->id == id)\n-\treturn arches->gdbarch;\n-    }\n-\n-  /* None found, so create a new architecture.  */\n-  tdep = XCNEW (struct gdbarch_tdep);\n-  tdep->id = id;\n-  gdbarch = gdbarch_alloc (&info, tdep);\n-\n-  /* Disassembler.  */\n-  set_gdbarch_print_insn (gdbarch, gdb_print_insn_spu);\n-\n-  /* Registers.  */\n-  set_gdbarch_num_regs (gdbarch, SPU_NUM_REGS);\n-  set_gdbarch_num_pseudo_regs (gdbarch, SPU_NUM_PSEUDO_REGS);\n-  set_gdbarch_sp_regnum (gdbarch, SPU_SP_REGNUM);\n-  set_gdbarch_pc_regnum (gdbarch, SPU_PC_REGNUM);\n-  set_gdbarch_read_pc (gdbarch, spu_read_pc);\n-  set_gdbarch_write_pc (gdbarch, spu_write_pc);\n-  set_gdbarch_register_name (gdbarch, spu_register_name);\n-  set_gdbarch_register_type (gdbarch, spu_register_type);\n-  set_gdbarch_pseudo_register_read (gdbarch, spu_pseudo_register_read);\n-  set_gdbarch_pseudo_register_write (gdbarch, spu_pseudo_register_write);\n-  set_gdbarch_value_from_register (gdbarch, spu_value_from_register);\n-  set_gdbarch_register_reggroup_p (gdbarch, spu_register_reggroup_p);\n-  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, spu_dwarf_reg_to_regnum);\n-  set_gdbarch_ax_pseudo_register_collect\n-    (gdbarch, spu_ax_pseudo_register_collect);\n-  set_gdbarch_ax_pseudo_register_push_stack\n-    (gdbarch, spu_ax_pseudo_register_push_stack);\n-\n-  /* Data types.  */\n-  set_gdbarch_char_signed (gdbarch, 0);\n-  set_gdbarch_ptr_bit (gdbarch, 32);\n-  set_gdbarch_addr_bit (gdbarch, 32);\n-  set_gdbarch_short_bit (gdbarch, 16);\n-  set_gdbarch_int_bit (gdbarch, 32);\n-  set_gdbarch_long_bit (gdbarch, 32);\n-  set_gdbarch_long_long_bit (gdbarch, 64);\n-  set_gdbarch_float_bit (gdbarch, 32);\n-  set_gdbarch_double_bit (gdbarch, 64);\n-  set_gdbarch_long_double_bit (gdbarch, 64);\n-  set_gdbarch_float_format (gdbarch, floatformats_ieee_single);\n-  set_gdbarch_double_format (gdbarch, floatformats_ieee_double);\n-  set_gdbarch_long_double_format (gdbarch, floatformats_ieee_double);\n-\n-  /* Address handling.  */\n-  set_gdbarch_address_to_pointer (gdbarch, spu_address_to_pointer);\n-  set_gdbarch_pointer_to_address (gdbarch, spu_pointer_to_address);\n-  set_gdbarch_integer_to_address (gdbarch, spu_integer_to_address);\n-  set_gdbarch_address_class_type_flags (gdbarch, spu_address_class_type_flags);\n-  set_gdbarch_address_class_type_flags_to_name\n-    (gdbarch, spu_address_class_type_flags_to_name);\n-  set_gdbarch_address_class_name_to_type_flags\n-    (gdbarch, spu_address_class_name_to_type_flags);\n-\n-  /* We need to support more than \"addr_bit\" significant address bits\n-     in order to support SPUADDR_ADDR encoded values.  */\n-  set_gdbarch_significant_addr_bit (gdbarch, 64);\n-\n-  /* Inferior function calls.  */\n-  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);\n-  set_gdbarch_frame_align (gdbarch, spu_frame_align);\n-  set_gdbarch_frame_red_zone_size (gdbarch, 2000);\n-  set_gdbarch_push_dummy_code (gdbarch, spu_push_dummy_code);\n-  set_gdbarch_push_dummy_call (gdbarch, spu_push_dummy_call);\n-  set_gdbarch_dummy_id (gdbarch, spu_dummy_id);\n-  set_gdbarch_return_value (gdbarch, spu_return_value);\n-\n-  /* Frame handling.  */\n-  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);\n-  dwarf2_append_unwinders (gdbarch);\n-  frame_unwind_append_unwinder (gdbarch, &spu_frame_unwind);\n-  frame_base_set_default (gdbarch, &spu_frame_base);\n-  set_gdbarch_unwind_pc (gdbarch, spu_unwind_pc);\n-  set_gdbarch_unwind_sp (gdbarch, spu_unwind_sp);\n-  set_gdbarch_virtual_frame_pointer (gdbarch, spu_virtual_frame_pointer);\n-  set_gdbarch_frame_args_skip (gdbarch, 0);\n-  set_gdbarch_skip_prologue (gdbarch, spu_skip_prologue);\n-  set_gdbarch_stack_frame_destroyed_p (gdbarch, spu_stack_frame_destroyed_p);\n-\n-  /* Cell/B.E. cross-architecture unwinder support.  */\n-  frame_unwind_prepend_unwinder (gdbarch, &spu2ppu_unwind);\n-\n-  /* Breakpoints.  */\n-  set_gdbarch_decr_pc_after_break (gdbarch, 4);\n-  set_gdbarch_breakpoint_kind_from_pc (gdbarch, spu_breakpoint::kind_from_pc);\n-  set_gdbarch_sw_breakpoint_from_kind (gdbarch, spu_breakpoint::bp_from_kind);\n-  set_gdbarch_memory_remove_breakpoint (gdbarch, spu_memory_remove_breakpoint);\n-  set_gdbarch_software_single_step (gdbarch, spu_software_single_step);\n-  set_gdbarch_get_longjmp_target (gdbarch, spu_get_longjmp_target);\n-\n-  /* Overlays.  */\n-  set_gdbarch_overlay_update (gdbarch, spu_overlay_update);\n-\n-  return gdbarch;\n-}\n-\n-void\n-_initialize_spu_tdep (void)\n-{\n-  register_gdbarch_init (bfd_arch_spu, spu_gdbarch_init);\n-\n-  /* Add ourselves to objfile event chain.  */\n-  gdb::observers::new_objfile.attach (spu_overlay_new_objfile);\n-\n-  /* Install spu stop-on-load handler.  */\n-  gdb::observers::new_objfile.attach (spu_catch_start);\n-\n-  /* Add ourselves to normal_stop event chain.  */\n-  gdb::observers::normal_stop.attach (spu_attach_normal_stop);\n-\n-  /* Add root prefix command for all \"set spu\"/\"show spu\" commands.  */\n-  add_prefix_cmd (\"spu\", no_class, set_spu_command,\n-\t\t  _(\"Various SPU specific commands.\"),\n-\t\t  &setspucmdlist, \"set spu \", 0, &setlist);\n-  add_prefix_cmd (\"spu\", no_class, show_spu_command,\n-\t\t  _(\"Various SPU specific commands.\"),\n-\t\t  &showspucmdlist, \"show spu \", 0, &showlist);\n-\n-  /* Toggle whether or not to add a temporary breakpoint at the \"main\"\n-     function of new SPE contexts.  */\n-  add_setshow_boolean_cmd (\"stop-on-load\", class_support,\n-                          &spu_stop_on_load_p, _(\"\\\n-Set whether to stop for new SPE threads.\"),\n-                           _(\"\\\n-Show whether to stop for new SPE threads.\"),\n-                           _(\"\\\n-Use \\\"on\\\" to give control to the user when a new SPE thread\\n\\\n-enters its \\\"main\\\" function.\\n\\\n-Use \\\"off\\\" to disable stopping for new SPE threads.\"),\n-                          NULL,\n-                          show_spu_stop_on_load,\n-                          &setspucmdlist, &showspucmdlist);\n-\n-  /* Toggle whether or not to automatically flush the software-managed\n-     cache whenever SPE execution stops.  */\n-  add_setshow_boolean_cmd (\"auto-flush-cache\", class_support,\n-                          &spu_auto_flush_cache_p, _(\"\\\n-Set whether to automatically flush the software-managed cache.\"),\n-                           _(\"\\\n-Show whether to automatically flush the software-managed cache.\"),\n-                           _(\"\\\n-Use \\\"on\\\" to automatically flush the software-managed cache\\n\\\n-whenever SPE execution stops.\\n\\\n-Use \\\"off\\\" to never automatically flush the software-managed cache.\"),\n-                          NULL,\n-                          show_spu_auto_flush_cache,\n-                          &setspucmdlist, &showspucmdlist);\n-\n-  /* Add root prefix command for all \"info spu\" commands.  */\n-  add_prefix_cmd (\"spu\", class_info, info_spu_command,\n-\t\t  _(\"Various SPU specific commands.\"),\n-\t\t  &infospucmdlist, \"info spu \", 0, &infolist);\n-\n-  /* Add various \"info spu\" commands.  */\n-  add_cmd (\"event\", class_info, info_spu_event_command,\n-\t   _(\"Display SPU event facility status.\"),\n-\t   &infospucmdlist);\n-  add_cmd (\"signal\", class_info, info_spu_signal_command,\n-\t   _(\"Display SPU signal notification facility status.\"),\n-\t   &infospucmdlist);\n-  add_cmd (\"mailbox\", class_info, info_spu_mailbox_command,\n-\t   _(\"Display SPU mailbox facility status.\"),\n-\t   &infospucmdlist);\n-  add_cmd (\"dma\", class_info, info_spu_dma_command,\n-\t   _(\"Display MFC DMA status.\"),\n-\t   &infospucmdlist);\n-  add_cmd (\"proxydma\", class_info, info_spu_proxydma_command,\n-\t   _(\"Display MFC Proxy-DMA status.\"),\n-\t   &infospucmdlist);\n-}"
    },
    {
      "sha": "255be2ed5acbf7c284fc781d5316121c8a5b8fe7",
      "filename": "gdb/spu-tdep.h",
      "status": "removed",
      "additions": 0,
      "deletions": 117,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/spu-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-tdep.h?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,117 +0,0 @@\n-/* SPU target-dependent code for GDB, the GNU debugger.\n-   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef SPU_TDEP_H\n-#define SPU_TDEP_H\n-\n-/* Number of registers.  */\n-#define SPU_NUM_REGS         130\n-#define SPU_NUM_PSEUDO_REGS  6\n-#define SPU_NUM_GPRS\t     128\n-\n-/* Register numbers of various important registers.  */\n-enum spu_regnum\n-{\n-  /* SPU calling convention.  */\n-  SPU_LR_REGNUM = 0,\t\t/* Link register.  */\n-  SPU_RAW_SP_REGNUM = 1,\t/* Stack pointer (full register).  */\n-  SPU_ARG1_REGNUM = 3,\t\t/* First argument register.  */\n-  SPU_ARGN_REGNUM = 74,\t\t/* Last argument register.  */\n-  SPU_SAVED1_REGNUM = 80,\t/* First call-saved register.  */\n-  SPU_SAVEDN_REGNUM = 127,\t/* Last call-saved register.  */\n-  SPU_FP_REGNUM = 127,\t\t/* Frame pointer.  */\n-\n-  /* Special registers.  */\n-  SPU_ID_REGNUM = 128,\t\t/* SPU ID register.  */\n-  SPU_PC_REGNUM = 129,\t\t/* Next program counter.  */\n-  SPU_SP_REGNUM = 130,\t\t/* Stack pointer (preferred slot).  */\n-  SPU_FPSCR_REGNUM = 131,\t/* Floating point status/control register.  */\n-  SPU_SRR0_REGNUM = 132,\t/* SRR0 register.  */\n-  SPU_LSLR_REGNUM = 133,\t/* Local store limit register.  */\n-  SPU_DECR_REGNUM = 134,\t/* Decrementer value.  */\n-  SPU_DECR_STATUS_REGNUM = 135\t/* Decrementer status.  */\n-};\n-\n-/* Address conversions.\n-\n-   In a combined PPU/SPU debugging session, we have to consider multiple\n-   address spaces: the PPU 32- or 64-bit address space, and the 32-bit\n-   local store address space for each SPU context.  As it is currently\n-   not yet possible to use the program_space / address_space mechanism\n-   to represent this, we encode all those addresses into one single\n-   64-bit address for the whole process.  For SPU programs using overlays,\n-   this address space must also include separate ranges reserved for the\n-   LMA of overlay sections.\n-\n-\n-   The following combinations are supported for combined debugging:\n-\n-   PPU address (this relies on the fact that PPC 64-bit user space\n-   addresses can never have the highest-most bit set):\n-\n-      +-+---------------------------------+\n-      |0|              ADDR [63]          |\n-      +-+---------------------------------+\n-\n-   SPU address for SPU context with id SPU (this assumes that SPU\n-   IDs, which are file descriptors, are never larger than 2^30):\n-\n-      +-+-+--------------+----------------+\n-      |1|0|    SPU [30]  |    ADDR [32]   |\n-      +-+-+--------------+----------------+\n-\n-   SPU overlay section LMA for SPU context with id SPU:\n-\n-      +-+-+--------------+----------------+\n-      |1|1|    SPU [30]  |    ADDR [32]   |\n-      +-+-+--------------+----------------+\n-\n-\n-   In SPU stand-alone debugging mode (using spu-linux-nat.c),\n-   the following combinations are supported:\n-\n-   SPU address:\n-\n-      +-+-+--------------+----------------+\n-      |0|0|     0        |    ADDR [32]   |\n-      +-+-+--------------+----------------+\n-\n-   SPU overlay section LMA:\n-\n-      +-+-+--------------+----------------+\n-      |0|1|     0        |    ADDR [32]   |\n-      +-+-+--------------+----------------+\n-\n-\n-   The following macros allow manipulation of addresses in the\n-   above formats.  */\n-\n-#define SPUADDR(spu, addr) \\\n-  ((spu) != -1? (ULONGEST)1 << 63 | (ULONGEST)(spu) << 32 | (addr) : (addr))\n-\n-#define SPUADDR_SPU(addr) \\\n-  (((addr) & (ULONGEST)1 << 63) \\\n-   ? (int) ((ULONGEST)(addr) >> 32 & 0x3fffffff) \\\n-   : -1)\n-\n-#define SPUADDR_ADDR(addr) \\\n-  (((addr) & (ULONGEST)1 << 63)? (ULONGEST)(addr) & 0xffffffff : (addr))\n-\n-#define SPU_OVERLAY_LMA ((ULONGEST)1 << 62)\n-\n-#endif"
    },
    {
      "sha": "8dbd2d62dc4b727a0d743fb20c4c31125edbc179",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -137,8 +137,6 @@ enum target_object\n {\n   /* AVR target specific transfer.  See \"avr-tdep.c\" and \"remote.c\".  */\n   TARGET_OBJECT_AVR,\n-  /* SPU target specific transfer.  See \"spu-tdep.c\".  */\n-  TARGET_OBJECT_SPU,\n   /* Transfer up-to LEN bytes of memory starting at OFFSET.  */\n   TARGET_OBJECT_MEMORY,\n   /* Memory, avoiding GDB's data cache and trusting the executable."
    },
    {
      "sha": "64c7d388619a05ec8b29509105bd915489bdd2e8",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -1,3 +1,32 @@\n+2019-09-20  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* gdb.arch/spu-info.exp: Remove file.\n+\t* gdb.arch/spu-info.c: Remove file.\n+\t* gdb.arch/spu-ls.exp: Remove file.\n+\t* gdb.arch/spu-ls.c: Remove file.\n+\n+\t* gdb.asm/asm-source.exp: Remove support for spu*-*-*.\n+\t* gdb.asm/spu.inc: Remove file.\n+\n+\t* gdb.base/dump.exp: Remove support for spu*-*-*.\n+\t* gdb.base/stack-checking.exp: Likewise.\n+\t* gdb.base/overlays.exp: Likewise.\n+\t* gdb.base/ovlymgr.c: Likewise.\n+\t* gdb.base/spu.ld: Remove file.\n+\n+\t* gdb.cp/bs15503.exp: Remove support for spu*-*-*.\n+\t* gdb.cp/cpexprs.exp: Likewise.\n+\t* gdb.cp/exception.exp: Likewise.\n+\t* gdb.cp/gdb2495.exp: Likewise.\n+\t* gdb.cp/mb-templates.exp: Likewise.\n+\t* gdb.cp/pr9167.exp: Likewise.\n+\t* gdb.cp/userdef.exp: Likewise.\n+\n+\t* gdb.xml/tdesc-regs.exp: Remove support for spu*-*-*.\n+\n+\t* gdb.cell: Remove directory.\n+\t* lib/cell.exp: Remove file.\n+\n 2019-09-19  Tom de Vries  <tdevries@suse.de>\n \n \t* lib/gdb.exp (gdb_test): Eliminate \"^FOOBAR$\" pattern."
    },
    {
      "sha": "3046525c9e63c7e4c15a37a499226a3aa9ba2246",
      "filename": "gdb/testsuite/gdb.arch/spu-info.c",
      "status": "removed",
      "additions": 0,
      "deletions": 235,
      "changes": 235,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-info.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-info.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/spu-info.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,235 +0,0 @@\n-/* Copyright 2007-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   This file is part of the gdb testsuite.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>.\n-   Tests for 'info spu' commands.  */\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <fcntl.h>\n-#include <unistd.h>\n-#include <spu_mfcio.h>\n-\n-\n-/* PPE-assisted call interface.  */\n-void\n-send_to_ppe (unsigned int signalcode, unsigned int opcode, void *data)\n-{\n-  __vector unsigned int stopfunc =\n-    {\n-      signalcode,     /* stop */\n-      (opcode << 24) | (unsigned int) data,\n-      0x4020007f,     /* nop */\n-      0x35000000      /* bi $0 */\n-    };\n-\n-  void (*f) (void) = (void *) &stopfunc;\n-  asm (\"sync\");\n-  f ();\n-}\n-\n-/* PPE-assisted call to mmap from SPU.  */\n-unsigned long long\n-mmap_ea (unsigned long long start, size_t length,\n-         int prot, int flags, int fd, off_t offset)\n-{\n-  struct mmap_args\n-    {\n-      unsigned long long start __attribute__ ((aligned (16)));\n-      size_t length __attribute__ ((aligned (16)));\n-      int prot __attribute__ ((aligned (16)));\n-      int flags __attribute__ ((aligned (16)));\n-      int fd __attribute__ ((aligned (16)));\n-      off_t offset __attribute__ ((aligned (16)));\n-    } args;\n-\n-  args.start = start;\n-  args.length = length;\n-  args.prot = prot;\n-  args.flags = flags;\n-  args.fd = fd;\n-  args.offset = offset;\n-\n-  send_to_ppe (0x2101, 11, &args);\n-  return args.start;\n-}\n-\n-/* This works only in a Linux environment with <= 1024 open\n-   file descriptors for one process. Result is the file\n-   descriptor for the current context if available.  */\n-int\n-find_context_fd (void)\n-{\n-  int dir_fd = -1;\n-  int i;\n-\n-  for (i = 0; i < 1024; i++)\n-    {\n-      struct stat stat;\n-\n-      if (fstat (i, &stat) < 0)\n-        break;\n-      if (S_ISDIR (stat.st_mode))\n-        dir_fd = dir_fd == -1 ? i : -2;\n-    }\n-  return dir_fd < 0 ? -1 : dir_fd;\n-}\n-\n-/* Open the context file and return the file handler.  */\n-int\n-open_context_file (int context_fd, char *name, int flags)\n-{\n-  char buf[128];\n-\n-  if (context_fd < 0)\n-    return -1;\n-\n-  sprintf (buf, \"/proc/self/fd/%d/%s\", context_fd, name);\n-  return open (buf, flags);\n-}\n-\n-\n-int\n-do_event_test ()\n-{\n-  spu_write_event_mask (MFC_MULTI_SRC_SYNC_EVENT); /* 0x1000 */  /* Marker Event */\n-  spu_write_event_mask (MFC_PRIV_ATTN_EVENT); /* 0x0800 */\n-  spu_write_event_mask (MFC_LLR_LOST_EVENT); /* 0x0400 */\n-  spu_write_event_mask (MFC_SIGNAL_NOTIFY_1_EVENT); /* 0x0200 */\n-  spu_write_event_mask (MFC_SIGNAL_NOTIFY_2_EVENT); /* 0x0100 */\n-  spu_write_event_mask (MFC_OUT_MBOX_AVAILABLE_EVENT); /* 0x0080 */\n-  spu_write_event_mask (MFC_OUT_INTR_MBOX_AVAILABLE_EVENT); /* 0x0040 */\n-  spu_write_event_mask (MFC_DECREMENTER_EVENT); /* 0x0020 */\n-  spu_write_event_mask (MFC_IN_MBOX_AVAILABLE_EVENT); /* 0x0010 */\n-  spu_write_event_mask (MFC_COMMAND_QUEUE_AVAILABLE_EVENT); /* 0x0008 */\n-  spu_write_event_mask (MFC_LIST_STALL_NOTIFY_EVENT); /* 0x0002 */\n-  spu_write_event_mask (MFC_TAG_STATUS_UPDATE_EVENT); /* 0x0001 */\n-\n-  return 0;\n-}\n-\n-int\n-do_dma_test ()\n-{\n-  #define MAP_FAILED      (-1ULL)\n-  #define PROT_READ       0x1\n-  #define MAP_PRIVATE     0x002\n-  #define BSIZE 128\n-  static char buf[BSIZE] __attribute__ ((aligned (128)));\n-  char *file = \"/var/tmp/tmp_buf\";\n-  struct stat fdstat;\n-  int fd, cnt;\n-  unsigned long long src;\n-\n-  /* Create a file and fill it with some bytes.  */\n-  fd = open (file, O_CREAT | O_RDWR | O_TRUNC, 0777);\n-  if (fd == -1)\n-    return -1;\n-  memset ((void *)buf, '1', BSIZE);\n-  write (fd, buf, BSIZE);\n-  write (fd, buf, BSIZE);\n-  memset ((void *)buf, 0, BSIZE);\n-\n-  if (fstat (fd, &fdstat) != 0\n-      || !fdstat.st_size)\n-    return -2;\n-\n-  src = mmap_ea(0ULL, fdstat.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n-  if (src == MAP_FAILED)\n-    return -3;\n-\n-  /* Copy some data via DMA.  */\n-  mfc_get (&buf, src, BSIZE, 5, 0, 0);   /* Marker DMA */\n-  mfc_write_tag_mask (1<<5);   /* Marker DMAWait */\n-  spu_mfcstat (MFC_TAG_UPDATE_ALL);\n-\n-  /* Close the file.  */\n-  close (fd);\n-\n-  return cnt;\n-}\n-\n-int\n-do_mailbox_test ()\n-{\n-  /* Write to SPU Outbound Mailbox.  */\n-  if (spu_stat_out_mbox ())            /* Marker Mbox */\n-    spu_write_out_mbox (0x12345678);\n-\n-  /* Write to SPU Outbound Interrupt Mailbox.  */\n-  if (spu_stat_out_intr_mbox ())\n-    spu_write_out_intr_mbox (0x12345678);\n-\n-  return 0;       /* Marker MboxEnd */\n-}\n-\n-int\n-do_signal_test ()\n-{\n-  struct stat fdstat;\n-  int context_fd = find_context_fd ();\n-  int ret, buf, fd;\n-\n-  buf = 23;    /* Marker Signal */\n-  /* Write to signal1.  */\n-  fd = open_context_file (context_fd, \"signal1\", O_RDWR);\n-  if (fstat (fd, &fdstat) != 0)\n-    return -1;\n-  ret = write (fd, &buf, sizeof (int));\n-  close (fd);  /* Marker Signal1 */\n-\n-  /* Write to signal2.  */\n-  fd = open_context_file (context_fd, \"signal2\", O_RDWR);\n-  if (fstat (fd, &fdstat) != 0)\n-    return -1;\n-  ret = write (fd, &buf, sizeof (int));\n-  close (fd);  /* Marker Signal2 */\n-\n-  /* Read signal1.  */\n-  if (spu_stat_signal1 ())\n-    ret = spu_read_signal1 ();\n-\n-  /* Read signal2.  */\n-  if (spu_stat_signal2 ())\n-    ret = spu_read_signal2 ();   /* Marker SignalRead */\n-\n-  return 0;\n-}\n-\n-int\n-main (unsigned long long speid, unsigned long long argp, \n-      unsigned long long envp)\n-{\n-  int res;\n-\n-  /* info spu event  */\n-  res = do_event_test ();\n-\n-  /* info spu dma  */\n-  res = do_dma_test ();\n-\n-  /* info spu mailbox  */\n-  res = do_mailbox_test ();\n-\n-  /* info spu signal  */\n-  res = do_signal_test ();\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "f840251c31da33cce1c1af27a5995fce6972ca8c",
      "filename": "gdb/testsuite/gdb.arch/spu-info.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 241,
      "changes": 241,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-info.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-info.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/spu-info.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,241 +0,0 @@\n-# Copyright 2007-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# This file is part of the gdb testsuite.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-# Tests for 'info spu' commands.\n-\n-\n-if { ![istarget \"spu-*-elf\"] } then {\n-  verbose \"Skipping SPU-only testcase\"\n-  return\n-}\n-\n-standard_testfile\n-\n-if { [prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug}] } {\n-  fail \"cannot compile test program\"\n-  return -1\n-}\n-\n-\n-# Continue to MARKER\n-proc c_to { marker } {\n-  global srcfile\n-  set line [gdb_get_line_number $marker]\n-  gdb_test \"break $line\" \\\n-\t   \"Breakpoint.*at.*file.*$srcfile.*line $line.*\" \\\n-\t   \"break $line\"\n-  gdb_test \"continue\" \\\n-\t   \"Continuing.*Breakpoint.*at.*$srcfile.*$line.*\" \\\n-\t   \"continue to $line\"\n-}\n-\n-\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Check the help.\n-gdb_test \"info spu\" \\\n-\t \".*info spu.* must be followed by the name of an SPU facility.*\" \\\n-\t \"info spu\"\n-gdb_test \"help info spu\" \\\n-\t \"Various SPU specific commands.*List of info spu subcommands.*\" \\\n-\t \"help info spu\"\n-\n-gdb_test \"help info spu dma\" \\\n-\t \"Display MFC DMA status.\" \\\n-\t \"help info spu dma\"\n-gdb_test \"help info spu event\" \\\n-\t \"Display SPU event facility status.\" \\\n-\t \"help info spu event\"\n-gdb_test \"help info spu mailbox\" \\\n-\t \"Display SPU mailbox facility status.\" \\\n-\t \"help info spu mailbox\"\n-gdb_test \"help info spu proxydma\" \\\n-\t \"Display MFC Proxy-DMA status.\" \\\n-\t \"help info spu proxydma\"\n-gdb_test \"help info spu signal\" \\\n-\t \"Display SPU signal notification facility status.\" \\\n-\t \"help info spu signal\"\n-\n-\n-# architecture should be spu:256K.\n-gdb_test \"show architecture\" \\\n-\t \"The target architecture is set automatically.*currently spu:256K.*\" \\\n-\t \"architecture = spu256K\"\n-\n-# 'info spu event'.\n-gdb_test \"info spu event\" \\\n-\t \"Event Status.*Event Mask.*\" \\\n-\t \"info spu event\"\n-\n-# 'info spu signal'.\n-gdb_test \"info spu signal\" \\\n-\t \"Signal 1 not pending.*\\(Type.*\\).*Signal 2 not pending.*\\(Type.*\\).*\" \\\n-\t \"info spu signal\"\n-\n-# 'info spu mailbox'.\n-gdb_test \"info spu mailbox\" \\\n-\t \"\" \\\n-\t \"info spu mailbox\"\n-\n-# 'info spu dma'.\n-gdb_test \"info spu dma\" \\\n-\t \"Tag-Group Status.*Tag-Group Mask.*Stall-and-Notify .*Atomic Cmd Status.*\" \\\n-\t \"info spu dma\"\n-\n-# 'info spu proxydma'.\n-gdb_test \"info spu proxydma\" \\\n-\t \"Tag-Group Status.*Tag-Group Mask.*\" \\\n-\t  \"info spu proxydma\"\n-\n-# Event tests.\n-c_to \"Marker Event\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x00000000.*Event Mask   0x00000000.*\" \\\n-\t\"empty event status\"\n-\n-# MFC_MULTI_SRC_SYNC_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00001000.*\" \\\n-\t\"event mask 0x1000\"\n-# MFC_PRIV_ATTN_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000800.*\" \\\n-\t\"event mask 0x0800\"\n-# MFC_LLR_LOST_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000400.*\" \\\n-\t\"event mask 0x0400\"\n-# MFC_SIGNAL_NOTIFY_1_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000200.*\" \\\n-\t\"event mask 0x0200\"\n-# MFC_SIGNAL_NOTIFY_2_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000100.*\" \\\n-\t\"event mask 0x0100\"\n-# MFC_OUT_MBOX_AVAILABLE_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000080.*\" \\\n-\t\"event mask 0x0080\"\n-# MFC_OUT_INTR_MBOX_AVAILABLE_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000040.*\" \\\n-\t\"event mask 0x0040\"\n-# MFC_DECREMENTER_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000020.*\" \\\n-\t\"event mask 0x0020\"\n-# MFC_IN_MBOX_AVAILABLE_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000010.*\" \\\n-\t\"event mask 0x0010\"\n-# MFC_COMMAND_QUEUE_AVAILABLE_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000008.*\" \\\n-\t\"event mask 0x0008\"\n-# MFC_LIST_STALL_NOTIFY_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000002.*\" \\\n-\t\"event mask 0x0002\"\n-# MFC_TAG_STATUS_UPDATE_EVENT.\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu event\" \\\n-\t\"Event Status 0x0000.*Event Mask   0x00000001.*\" \\\n-\t\"event mask 0x0001\"\n-\n-\n-# DMA tests.\n-# 'info spu dma' should be empty.\n-c_to \"Marker DMA\"\n-gdb_test \"info spu dma\" \\\n-\t \"Tag-Group Status.*0x00000000.*Tag-Group Mask.*0x00000000.*Stall-and-Notify.*0x00000000.*Atomic Cmd Status.*0x00000000\\[\\r\\n\\]+\" \\\n-\t \"info spu dma (empty)\"\n-\n-# 'info spu dma' should be filled with some data.\n-c_to \"Marker DMAWait\"\n-gdb_test \"next\" \"\" \"next\"\n-gdb_test \"info spu dma\" \\\n-\t \"Tag-Group Status.*0x00000000.*Tag-Group Mask.*0x00000020.*Stall-and-Notify.*0x00000000.*Atomic Cmd Status.*0x00000000.*Opcode.*Tag.*TId.*RId.*EA.*LSA.*Size.*LstAddr.*LstSize.*E.*get.*5.*0.*0.*0x00080\\[ \\r\\n\\]+\" \\\n-\t \"info spu dma (non-empty)\"\n-gdb_test \"finish\" \"\" \"finish\"\n-\n-# Mailbox Test\n-# 'info spu mailbox' should be empty.\n-c_to \"Marker Mbox\"\n-set msg \"info spu mailbox\"\n-gdb_test_multiple \"info spu mailbox\" $msg {\n-    -re \"$gdb_prompt $\" {\n-      pass $msg\n-    }\n-    -re \"SPU Outbound Mailbox.*0x.*SPU Outbound Interrupt Mailbox.*0x.*$gdb_prompt $\" {\n-      # Older kernels had a bug that caused them to return arbitrary values\n-      # when attempting to read from an empty mailbox via spufs.\n-      xfail $msg\n-    }\n-}\n-\n-# 'info spu mailbox' should now contain data.\n-c_to \"Marker MboxEnd\"\n-gdb_test \"info spu mailbox\" \\\n-\t \"SPU Outbound Mailbox.*0x12345678.*SPU Outbound Interrupt Mailbox.*0x12345678.*\" \\\n-\t \"info spu mailbox\"\n-\n-# Signal Test\n-# 'info spu signal'.\n-c_to \"Marker Signal\"\n-gdb_test \"info spu signal\" \\\n-\t \"Signal 1 not pending.*\\(Type.*\\).*Signal 2 not pending.*\\(Type.*\\).*\" \\\n-\t \"info spu signal\"\n-\n-# 'info spu signal' with signal1 pending.\n-c_to \"Marker Signal1\"\n-gdb_test \"info spu signal\" \\\n-\t \"Signal 1 control word 0x00000017.*Signal 2 not pending.*\\(Type.*\\).*\" \\\n-\t \"info spu signal\"\n-\n-# 'info spu signal' with signal1 and signal2 pending.\n-c_to \"Marker Signal2\"\n-gdb_test \"info spu signal\" \\\n-\t \"Signal 1 control word 0x00000017.*Signal 2 control word 0x00000017.*\" \\\n-\t \"info spu signal\"\n-\n-# Read signal1. Only signal2 is pending.\n-c_to \"Marker SignalRead\"\n-gdb_test \"info spu signal\" \\\n-\t \"Signal 1 not pending.*Signal 2 control word 0x00000017.*\" \\\n-\t \"info spu signal\"\n-\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "f1a20491f0f8e6b26af8fc57a212db3f1ecd1194",
      "filename": "gdb/testsuite/gdb.arch/spu-ls.c",
      "status": "removed",
      "additions": 0,
      "deletions": 31,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-ls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-ls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/spu-ls.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,31 +0,0 @@\n-/* Copyright 2010-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   This file is part of the gdb testsuite.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-   Tests for SPU local-store access.  */\n-\n-char *ptr = (char *)0x12345678;\n-\n-char array[256];\n-\n-int\n-main (unsigned long long speid, unsigned long long argp, \n-      unsigned long long envp)\n-{\n-  return 0;\n-}\n-"
    },
    {
      "sha": "af0b1acec808b9ebc7842aa637012677fe51f175",
      "filename": "gdb/testsuite/gdb.arch/spu-ls.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 47,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-ls.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.arch/spu-ls.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/spu-ls.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,47 +0,0 @@\n-# Copyright 2010-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# This file is part of the gdb testsuite.\n-#\n-# Contributed by Ulrich Weigand  <uweigand@de.ibm.com>.\n-# Tests for SPU local-store access.\n-\n-if { ![istarget \"spu-*-elf\"] } then {\n-  verbose \"Skipping SPU-only testcase\"\n-  return\n-}\n-\n-standard_testfile\n-\n-if { [prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug}] } {\n-  fail \"cannot compile test program\"\n-  return -1\n-}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-gdb_test \"print ptr\" \" = 0x12345678 \\\".*\\\"\" \"print ptr\"\n-gdb_test_no_output \"set ptr = array + \\$lslr + 1\" \"set ptr = array + \\$lslr + 1\"\n-gdb_test_no_output \"set array\\[0\\] = 1\" \"set array\\[0\\] = 1\"\n-gdb_test \"print *ptr\" \" = 1 '\\\\\\\\001'\" \"print *ptr\"\n-gdb_test_no_output \"set *ptr = 2\" \"set *ptr = 2\"\n-gdb_test \"print array\\[0\\]\" \" = 2 '\\\\\\\\002'\" \"print array\\[0\\]\"\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "b10ee1702fcf5c7ca43c2a4746f2b67310515d5d",
      "filename": "gdb/testsuite/gdb.asm/asm-source.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.asm/asm-source.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.asm/asm-source.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.asm/asm-source.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -128,11 +128,6 @@ switch -glob -- [istarget] {\n         set asm-flags \"-xarch=v9 -I${srcdir}/${subdir} $obj_include\"\n \tset debug-flags \"-gdwarf-2\"\n     }\n-    \"spu*-*-*\" {\n-       set asm-arch spu\n-       set asm-flags \"-I${srcdir}/${subdir} $obj_include --no-warn\"\n-       set debug-flags \"-gdwarf-2\"\n-    }\n     \"xstormy16-*-*\" {\n         set asm-arch xstormy16\n \tset debug-flags \"-gdwarf-2\""
    },
    {
      "sha": "aabceb845d24ffb10c9305b36b3d8e3ad2022479",
      "filename": "gdb/testsuite/gdb.asm/spu.inc",
      "status": "removed",
      "additions": 0,
      "deletions": 42,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.asm/spu.inc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.asm/spu.inc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.asm/spu.inc?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,42 +0,0 @@\n-\tcomment \"subroutine prologue\"\n-\t.macro gdbasm_enter\n-\tstqd    $lr, 16($sp)\n-\tstqd    $sp, -32($sp)\n-\tai      $sp, $sp, -32\n-\t.endm\n-\n-\tcomment \"subroutine epilogue\"\n-\t.macro gdbasm_leave\n-\tai\t$sp, $sp, 32\n-\tlqd     $lr, 16($sp)\n-\tbi\t$lr\t\n-\t.endm\n-\n-\t.macro gdbasm_call subr\n-\tbrsl\t$lr, \\subr\n-\t.endm\n-\n-\t.macro gdbasm_several_nops\n-\tnop\n-\tnop\n-\tnop\n-\tnop\n-\t.endm\n-\n-\tcomment \"exit (0)\"\n-\t.macro gdbasm_exit0\n-\tstop\t0x2000\n-\tstop \n-\tstop \n-\tstop \n-\t.endm\n-\n-\tcomment \"startup\"\n-\t.macro gdbasm_startup\n-\til\t$0, 0\n-\tila\t$sp, 16368\n-\tstqd\t$0, 0($sp)\n-\tstqd\t$sp, -32($sp)\n-\tai\t$sp, $sp, -32\n-\tstqd\t$0, 16($sp)\n-\t.endm"
    },
    {
      "sha": "77db17936eb1b238cbfc3696bcc9abd644120ea7",
      "filename": "gdb/testsuite/gdb.base/dump.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/dump.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/dump.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/dump.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -30,12 +30,6 @@ if [istarget \"alpha*-*-*\"] then {\n     lappend options \"additional_flags=-Wl,-taso\"\n }\n \n-if {[istarget \"spu*-*-*\"]} then {\n-    # The internal address format used for the combined Cell/B.E.\n-    # debugger requires 64-bit.\n-    set is64bitonly \"yes\"\n-}\n-\n # Debian9/Ubuntu16.10 onwards default to PIE enabled. Ensure it is disabled as\n # this causes addresses to be out of range for IHEX.\n lappend options {nopie}"
    },
    {
      "sha": "388b87f0269d6cd55da6ec85009907b0c263491f",
      "filename": "gdb/testsuite/gdb.base/overlays.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/overlays.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/overlays.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/overlays.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -24,9 +24,6 @@ set data_overlays 1\n \n if [istarget \"m32r-*-*\"] then {\n     set linker_script \"${srcdir}/${subdir}/m32r.ld\"\n-} elseif [istarget \"spu-*-*\"] then {\n-    set linker_script \"${srcdir}/${subdir}/spu.ld\"\n-    set data_overlays 0\n } else {\n     verbose \"Skipping overlay test -- not implemented for this target.\"\n     return "
    },
    {
      "sha": "f4958ed14a372ff634ff93e9e770bc9cb8336813",
      "filename": "gdb/testsuite/gdb.base/ovlymgr.c",
      "status": "modified",
      "additions": 0,
      "deletions": 13,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/ovlymgr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/ovlymgr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ovlymgr.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -5,18 +5,6 @@\n \n #include \"ovlymgr.h\"\n \n-#ifdef __SPU__\n-/* SPU tool chain provides its own overlay manager.  */\n-bool\n-OverlayLoad (unsigned long ovlyno)\n-{\n-}\n-bool\n-OverlayUnload (unsigned long ovlyno)\n-{\n-}\n-#else /* __SPU__ */\n-\n /* Local functions and data: */\n \n extern unsigned long _ovly_table[][4];\n@@ -243,4 +231,3 @@ ovly_copy (unsigned long dst, unsigned long src, long size)\n   return;\n }\n \n-#endif /* __SPU__ */"
    },
    {
      "sha": "0cd5a8540539c915677ccc4c8786f33e0c05e821",
      "filename": "gdb/testsuite/gdb.base/spu.ld",
      "status": "removed",
      "additions": 0,
      "deletions": 202,
      "changes": 202,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.base/spu.ld",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.base/spu.ld",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/spu.ld?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,202 +0,0 @@\n-/* Script for -z combreloc: combine and sort reloc sections */\n-OUTPUT_FORMAT(\"elf32-spu\", \"elf32-spu\",\n-\t      \"elf32-spu\")\n-OUTPUT_ARCH(spu)\n-ENTRY(_start)\n-SEARCH_DIR(\"/usr/spu/lib\");\n-/* Do we need any of these for elf?\n-   __DYNAMIC = 0;    */\n-SECTIONS\n-{\n-  /* Read-only sections, merged into text segment: */\n-  PROVIDE (__executable_start = 0); . = 0;\n-  .interrupt : { KEEP(*(.interrupt)) }\n-  .interp         : { *(.interp) }\n-  .hash           : { *(.hash) }\n-  .dynsym         : { *(.dynsym) }\n-  .dynstr         : { *(.dynstr) }\n-  .gnu.version    : { *(.gnu.version) }\n-  .gnu.version_d  : { *(.gnu.version_d) }\n-  .gnu.version_r  : { *(.gnu.version_r) }\n-  .rel.dyn        :\n-    {\n-      *(.rel.init)\n-      *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)\n-      *(.rel.fini)\n-      *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)\n-      *(.rel.data.rel.ro*)\n-      *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)\n-      *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)\n-      *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)\n-      *(.rel.ctors)\n-      *(.rel.dtors)\n-      *(.rel.got)\n-      *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)\n-    }\n-  .rela.dyn       :\n-    {\n-      *(.rela.init)\n-      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)\n-      *(.rela.fini)\n-      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)\n-      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)\n-      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)\n-      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)\n-      *(.rela.ctors)\n-      *(.rela.dtors)\n-      *(.rela.got)\n-      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)\n-    }\n-  .rel.plt        : { *(.rel.plt) }\n-  .rela.plt       : { *(.rela.plt) }\n-  .init           :\n-  {\n-    KEEP (*(.init))\n-  } =0\n-  .plt            : { *(.plt) }\n-  .text           :\n-  {\n-    *(EXCLUDE_FILE (foo.o bar.o baz.o grbx.o) .text .stub .text.* .gnu.linkonce.t.*)\n-    KEEP (*(.text.*personality*))\n-    *(.spu.elf)\n-    /* .gnu.warning sections are handled specially by elf32.em.  */\n-    *(.gnu.warning)\n-  } =0\n-  .fini           :\n-  {\n-    KEEP (*(.fini))\n-  } =0\n-  PROVIDE (__etext = .);\n-  PROVIDE (_etext = .);\n-  PROVIDE (etext = .);\n-  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }\n-  .rodata1        : { *(.rodata1) }\n-  .eh_frame_hdr : { *(.eh_frame_hdr) }\n-  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }\n-  .gcc_except_table   : ONLY_IF_RO { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }\n-  /* Adjust the address for the data segment.  We want to adjust up to\n-     the same address within the page on the next page up.  */\n-  . = ALIGN(0x80);\n-  /* Exception handling  */\n-  .eh_frame       : ONLY_IF_RW { KEEP (*(.eh_frame)) }\n-  .gcc_except_table   : ONLY_IF_RW { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }\n-  /* Thread Local Storage sections  */\n-  .tdata\t  : { *(.tdata .tdata.* .gnu.linkonce.td.*) }\n-  .tbss\t\t  : { *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon) }\n-  /* Ensure the __preinit_array_start label is properly aligned.  We\n-     could instead move the label definition inside the section, but\n-     the linker would then create the section even if it turns out to\n-     be empty, which isn't pretty.  */\n-  . = ALIGN(16);\n-  PROVIDE (__preinit_array_start = .);\n-  .preinit_array     : { KEEP (*(.preinit_array)) }\n-  PROVIDE (__preinit_array_end = .);\n-  PROVIDE (__init_array_start = .);\n-  .init_array     : { KEEP (*(.init_array)) }\n-  PROVIDE (__init_array_end = .);\n-  PROVIDE (__fini_array_start = .);\n-  .fini_array     : { KEEP (*(.fini_array)) }\n-  PROVIDE (__fini_array_end = .);\n-  .ctors          :\n-  {\n-    /* gcc uses crtbegin.o to find the start of\n-       the constructors, so we make sure it is\n-       first.  Because this is a wildcard, it\n-       doesn't matter if the user does not\n-       actually link against crtbegin.o; the\n-       linker won't look for a file to match a\n-       wildcard.  The wildcard also means that it\n-       doesn't matter which directory crtbegin.o\n-       is in.  */\n-    KEEP (*crtbegin*.o(.ctors))\n-    /* We don't want to include the .ctor section from\n-       from the crtend.o file until after the sorted ctors.\n-       The .ctor section from the crtend file contains the\n-       end of ctors marker and it must be last */\n-    KEEP (*(EXCLUDE_FILE (*crtend*.o ) .ctors))\n-    KEEP (*(SORT(.ctors.*)))\n-    KEEP (*(.ctors))\n-  }\n-  .dtors          :\n-  {\n-    KEEP (*crtbegin*.o(.dtors))\n-    KEEP (*(EXCLUDE_FILE (*crtend*.o ) .dtors))\n-    KEEP (*(SORT(.dtors.*)))\n-    KEEP (*(.dtors))\n-  }\n-  .jcr            : { KEEP (*(.jcr)) }\n-  .data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro*) }\n-  .dynamic        : { *(.dynamic) }\n-  .got            : { *(.got.plt) *(.got) }\n-  .data           :\n-  {\n-    *(.data .data.* .gnu.linkonce.d.*)\n-    KEEP (*(.gnu.linkonce.d.*personality*))\n-    SORT(CONSTRUCTORS)\n-  }\n-  .data1          : { *(.data1) }\n-  _edata = .;\n-  PROVIDE (edata = .);\n-  __bss_start = .;\n-  .bss            :\n-  {\n-   *(.dynbss)\n-   *(.bss .bss.* .gnu.linkonce.b.*)\n-   *(COMMON)\n-   /* Align here to ensure that the .bss section occupies space up to\n-      _end.  Align after .bss to ensure correct alignment even if the\n-      .bss section disappears because there are no input sections.  */\n-   . = ALIGN(16);\n-  }\n-  .toe ALIGN(128) : { *(.toe) } = 0\n-  . = ALIGN(16);\n-  OVERLAY :\n-    {\n-      .ovly0 { foo.o(.text) }\n-      .ovly1 { bar.o(.text) }\n-    }\n-  OVERLAY :\n-    {\n-      .ovly2 { baz.o(.text) }\n-      .ovly3 { grbx.o(.text) }\n-    }\n-  _end = .;\n-  PROVIDE (end = .);\n-  /* Stabs debugging sections.  */\n-  .stab          0 : { *(.stab) }\n-  .stabstr       0 : { *(.stabstr) }\n-  .stab.excl     0 : { *(.stab.excl) }\n-  .stab.exclstr  0 : { *(.stab.exclstr) }\n-  .stab.index    0 : { *(.stab.index) }\n-  .stab.indexstr 0 : { *(.stab.indexstr) }\n-  .comment       0 : { *(.comment) }\n-  /* DWARF debug sections.\n-     Symbols in the DWARF debugging sections are relative to the beginning\n-     of the section so we begin them at 0.  */\n-  /* DWARF 1 */\n-  .debug          0 : { *(.debug) }\n-  .line           0 : { *(.line) }\n-  /* GNU DWARF 1 extensions */\n-  .debug_srcinfo  0 : { *(.debug_srcinfo) }\n-  .debug_sfnames  0 : { *(.debug_sfnames) }\n-  /* DWARF 1.1 and DWARF 2 */\n-  .debug_aranges  0 : { *(.debug_aranges) }\n-  .debug_pubnames 0 : { *(.debug_pubnames) }\n-  /* DWARF 2 */\n-  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }\n-  .debug_abbrev   0 : { *(.debug_abbrev) }\n-  .debug_line     0 : { *(.debug_line) }\n-  .debug_frame    0 : { *(.debug_frame) }\n-  .debug_str      0 : { *(.debug_str) }\n-  .debug_loc      0 : { *(.debug_loc) }\n-  .debug_macinfo  0 : { *(.debug_macinfo) }\n-  /* SGI/MIPS DWARF 2 extensions */\n-  .debug_weaknames 0 : { *(.debug_weaknames) }\n-  .debug_funcnames 0 : { *(.debug_funcnames) }\n-  .debug_typenames 0 : { *(.debug_typenames) }\n-  .debug_varnames  0 : { *(.debug_varnames) }\n-  .note.spu_name 0 : { *(.note.spu_name) }\n-  PROVIDE (__stack = 0x3fff0);\n-  /DISCARD/ : { *(.note.GNU-stack) }\n-}\n-"
    },
    {
      "sha": "8f6dedbceca0b80ada0e9d392e2820af48c0d40f",
      "filename": "gdb/testsuite/gdb.base/stack-checking.c",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/stack-checking.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.base/stack-checking.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/stack-checking.c?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -36,11 +36,7 @@ void medium_frame ()\n \n void big_frame ()\n {\n-#ifdef __SPU__\n-  char S [131072];\n-#else\n   char S [524188];\n-#endif\n   small_frame ();\n }\n "
    },
    {
      "sha": "dbfb20c379130fccb15172510fba17f91fdd5a52",
      "filename": "gdb/testsuite/gdb.cell/arch.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 116,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/arch.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/arch.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/arch.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,116 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcase checks if the \"show architecture\" command works properly.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-# No programm running, default architecture should be powerpc:common.\n-gdb_test \"show architecture\" \\\n-\t \"The target architecture is set automatically.*currently powerpc:common.*\" \\\n-\t \"startup architecture is powerpc:common\"\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# In PPU thread, architecture should be powerpc:common.\n-gdb_test \"show architecture\" \\\n-\t \"The target architecture is set automatically.*currently powerpc:common.*\" \\\n-\t \"ppu architecture is powerpc:common\"\n-\n-# Switch to SPU thread.\n-cont_spu_main\n-check_spu_arch \"\"\n-\n-# Remember thread ID of first thread to hit SPU main.\n-send_gdb \"thread\\n\"\n-gdb_expect 10 {\n-    -re \"Current thread is (\\[0-9\\]*) .*\\r\\n$gdb_prompt $\" {\n-\tpass \"retrieve current thread\"\n-\tset thread_id $expect_out(1,string)\n-    }\n-    -re \"$gdb_prompt $\" {\n-\tfail \"retrieve current thread\"\n-\treturn 0\n-    }\n-    timeout {\n-\tfail \"retrieve current thread (timed out)\"\n-\treturn 0\n-    }\n-}\n-\n-# Stress Test: Switching from PPU- to SPU-Thread and back 'rep' times.\n-set rep 100\n-for {set i 0} {$i < $rep} {incr i} {\n-  # Switch to PPU Thread.\n-  gdb_test \"t 1\" \\\n-\t   \"Switching to thread 1.*\" \\\n-\t   \"switch back to thread 1 (PPU) #$i\"\n-  # In PPU Thread, architecture should again be powerpc:common.\n-  gdb_test \"show architecture\" \\\n-\t   \"The target architecture is set automatically.*currently powerpc:common.*\" \\\n-\t   \"ppu architecture is powerpc:common again #$i\"\n-  # Thread switching to SPU.\n-  gdb_test \"t $thread_id\" \\\n-\t   \"Switching to thread $thread_id.*at.*$spu_file.c.*\" \\\n-\t   \"switch back to thread $thread_id (spu) #$i\"\n-  # Standing in SPU thread again, architecture should be spu:256K again.\n-  check_spu_arch \"spu architecture is spu256K again #$i\"\n-}\n-# End of Stress Test loop\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "f28a843c04d5d4336cfd09981b36269d096cbec3",
      "filename": "gdb/testsuite/gdb.cell/break-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 43,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/break-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,43 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-\n-void foo (void);\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  int i;\n-\n-  printf (\"Hello World! from spu\\n\");\n-\n-  i = 5;\n-  foo ();\n-  printf (\"i = %d\\n\", i);\n-\n-  return 0;\n-}\n-\n-void\n-foo (void)\n-{\n-  printf (\"in foo\\n\");\n-}"
    },
    {
      "sha": "95108d7d5079b8edd6e915436b812822660eaab3",
      "filename": "gdb/testsuite/gdb.cell/break.c",
      "status": "removed",
      "additions": 0,
      "deletions": 71,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/break.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,71 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t break_spu;\n-#define nr_t 5\n-\n-void *\n-spe_thread (void * arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &break_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-  int value = 1;\n-  int cnt;\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    {\n-      ctx[cnt] = spe_context_create (0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], NULL, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    pthread_join (pts[cnt], NULL);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_context_destroy (ctx[cnt]);\n-\n-  return 0;\n-}\n-\n-void\n-foo ()\n-{\n-  printf (\"foo in break\\n\");\n-  return;\n-}"
    },
    {
      "sha": "73e60ad4c15cd0d7475fbfa7d58343ac0ee048f5",
      "filename": "gdb/testsuite/gdb.cell/break.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 103,
      "changes": 103,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/break.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/break.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,103 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests setting and deleting breakpoints on PPU and SPU.\n-\n-load_lib cell.exp\n-\n-set testfile \"break\"\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-# Delete breakpoints before starting the application. The debugger\n-# shouldn't prompt for anything.\n-gdb_test \"delete breakpoints\" \\\n-\t \"\" \\\n-\t \"no prompt when deleting non-existing breakpoints\"\n-\n-gdb_test \"break main\" \\\n-\t \"Breakpoint.*at.* file .*$testfile.c, line.*\" \\\n-\t \"breakpoint main in ppu\"\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-delete_breakpoints\n-\n-# Re-set breakpoint at main in PPU binary.\n-gdb_test \"break main\" \\\n-\t \"Breakpoint.*at.* file .*$testfile.c, line.*\" \\\n-\t \"breakpoint function\"\n-\n-# Set breakpoint in SPU binary.\n-send_gdb \"break $spu_file.c:10\\n\"\n-gdb_expect {\n-  -re \".*$spu_file.c.*Make breakpoint pending.*y or \\\\\\[n\\\\\\]. $\" {\n-    gdb_test \"y\" \"Breakpoint.*$spu_file.*pending.\" \"set pending breakpoint\"\n-  }\n-  timeout { fail \"timeout while setting breakpoint in spu binary\" }\n-}\n-\n-# Check breakpoints.\n-gdb_test \"info break\" \\\n-\t \"Num\\[ \\]+Type\\[ \\]+Disp\\[ \\]+Enb\\[ \\]+Address\\[ \\]+What.*\n-\\[0-9\\]+\\[\\t \\]+breakpoint     keep y.*in main at.*$testfile.c.*\n-\\[0-9\\]+\\[\\t \\]+breakpoint     keep y.*PENDING.*$spu_file.c:10.*\" \\\n-\t \"breakpoint info\"\n-\n-gdb_test \"continue\" \\\n-\t \"Continuing.*Switching to Thread.*Breakpoint.*main.*at.*$spu_file.c.*\" \\\n-\t \"continuing to spu thread\"\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "6e83361cd329e839488822d8e9ced083c4862ef7",
      "filename": "gdb/testsuite/gdb.cell/bt-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 30,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/bt-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,30 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <sys/syscall.h>\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  __send_to_ppe (0x2111, 0, NULL);\n-  return 0;\n-}\n-"
    },
    {
      "sha": "31fb4ea86494a724908ea1b5a796e6f335e05e23",
      "filename": "gdb/testsuite/gdb.cell/bt.c",
      "status": "removed",
      "additions": 0,
      "deletions": 101,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/bt.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,101 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t bt_spu;\n-extern spe_program_handle_t bt2_spu;\n-#define nr_t 5\n-\n-void *\n-spe_thread (void * arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &bt_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-indirect_handler (unsigned char *base, unsigned long offset)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t ctx = spe_context_create (0, NULL);\n-\n-  spe_program_load (ctx, &bt2_spu);\n-  spe_context_run (ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  return 0;\n-}\n-\n-static pthread_mutex_t crash_mutex = PTHREAD_MUTEX_INITIALIZER;\n-static int crash_count = 0;\n-\n-int\n-crash_handler (unsigned char *base, unsigned long offset)\n-{\n-  int count;\n-\n-  pthread_mutex_lock (&crash_mutex);\n-  count = ++crash_count;\n-  pthread_mutex_unlock (&crash_mutex);\n-\n-  while (count < nr_t)\n-    ;\n-\n-  abort ();\n-}\n-\n-int\n-main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-  int value = 1;\n-  int cnt;\n-\n-  spe_callback_handler_register (indirect_handler, 0x11, SPE_CALLBACK_NEW);\n-  spe_callback_handler_register (crash_handler, 0x12, SPE_CALLBACK_NEW);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    {\n-      ctx[cnt] = spe_context_create (0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], NULL, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    pthread_join (pts[cnt], NULL);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_context_destroy (ctx[cnt]);\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "cacf7c203591bbf3da3c7625e363bd88869c0f27",
      "filename": "gdb/testsuite/gdb.cell/bt.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 91,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/bt.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,91 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests mixed-architecture backtrace support\n-\n-load_lib cell.exp\n-\n-set testfile \"bt\"\n-set ppu_file \"bt\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"bt-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-set spu2_file \"bt2-spu\"\n-set spu2_src ${srcdir}/${subdir}/${spu2_file}.c\n-set spu2_bin [standard_output_file ${spu2_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binaries.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_spu $spu2_src $spu2_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_cell_embedspu $spu2_bin $spu2_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o $spu2_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-delete_breakpoints\n-gdb_test \"continue\" \".*received signal SIGABRT, Aborted.*\"\n-\n-gdb_test \"backtrace\" \".*abort.*crash_handler.*base.*offset.*<cross-architecture call>.*main.*speid.*argp.*envp.*at.*$spu2_file.c.*<cross-architecture call>.*spe_context_run.*indirect_handler.*base.*offset.*<cross-architecture call>.*main.*speid.*argp.*envp.*at.*$spu_file.c.*<cross-architecture call>.*spe_context_run.*spe_thread.*at.*$ppu_file.c.*\"\n-\n-for {set thread_id 2} {$thread_id < 7} {incr thread_id} {\n-  gdb_test \"t $thread_id\" \\\n-           \"Switching to thread $thread_id.*\" \\\n-           \"switch to thread $thread_id\"\n-  gdb_test \"backtrace\" \\\n-\t   \".*crash_handler.*base.*offset.*<cross-architecture call>.*main.*speid.*argp.*envp.*at.*$spu2_file.c.*<cross-architecture call>.*spe_context_run.*indirect_handler.*base.*offset.*<cross-architecture call>.*main.*speid.*argp.*envp.*at.*$spu_file.c.*<cross-architecture call>.*spe_context_run.*spe_thread.*at.*$ppu_file.c.*\" \\\n-\t   \"backtrace in thread $thread_id\"\n-}\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "67ed34c36488148240c55a4d9175ca67e2be2d70",
      "filename": "gdb/testsuite/gdb.cell/bt2-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 30,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt2-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/bt2-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/bt2-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,30 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <sys/syscall.h>\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  __send_to_ppe (0x2112, 0, NULL);\n-  return 0;\n-}\n-"
    },
    {
      "sha": "2de75629263186863e0ce2239af35f654f7955b8",
      "filename": "gdb/testsuite/gdb.cell/core.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 105,
      "changes": 105,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/core.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/core.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/core.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,105 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests mixed-architecture core file support\n-\n-load_lib cell.exp\n-\n-set testfile \"coremaker\"\n-set ppu_file \"coremaker\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"coremaker-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {![isnative]} then {\n-    return 0\n-}\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-# Run program to generate a core file -- see gdb.base/corefile.exp\n-set found 0\n-set coredir \"${objdir}/${subdir}/coredir.[getpid]\"\n-file mkdir $coredir\n-catch \"system \\\"(cd ${coredir}; ulimit -c unlimited; ${ppu_bin}; true) >/dev/null 2>&1\\\"\"\n-set names [glob -nocomplain -directory $coredir core.*]\n-if {[llength $names] == 1} {\n-    set corefile [file join $coredir [lindex $names 0]]\n-    remote_exec build \"mv $corefile ${objdir}/${subdir}/corefile\"\n-    set found 1\n-}\n-remote_exec build \"rmdir $coredir\"\n-if { $found == 0  } {\n-    warning \"can't generate a core file - core tests suppressed - check ulimit -c\"\n-    return 0\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-send_gdb \"core-file $objdir/$subdir/corefile\\n\"\n-gdb_expect {\n-    -re \"Core was generated by .*coremaker.*\\r\\n\\#0  .*\\(\\).*\\r\\n$gdb_prompt $\" {\n-\tpass \"core-file command\"\n-    }\n-    -re \"Core was generated by .*\\r\\n\\#0  .*\\(\\).*\\r\\n$gdb_prompt $\" {\n-\tpass \"core-file command (with bad program name)\"\n-    }\n-    -re \".*$gdb_prompt $\"\t{ fail \"core-file command\" }\n-    timeout\t\t\t{ fail \"(timeout) core-file command\" }\n-}\n-\n-gdb_test \"backtrace\" \".*abort.*main.*at.*$ppu_file.c.*\"\n-\n-for {set thread_id 2} {$thread_id < 7} {incr thread_id} {\n-  gdb_test \"t $thread_id\" \\\n-           \"Switching to thread $thread_id.*\" \\\n-           \"switch to thread $thread_id\"\n-  gdb_test \"backtrace\" \\\n-\t   \".*terminal_func.*factorial_func.*value=1.*factorial_func.*value=2.*factorial_func.*value=3.*factorial_func.*value=4.*factorial_func.*value=5.*factorial_func.*value=6.*main.*speid.*argp.*envp.*at.*$spu_file.c.*<cross-architecture call>.*spe_context_run.*spe_thread.*at.*$ppu_file.c.*\" \\\n-\t   \"backtrace in thread $thread_id\"\n-}\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "472660d629dfda82b86de0cb5cab7e2ed42c9344",
      "filename": "gdb/testsuite/gdb.cell/coremaker-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 46,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/coremaker-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/coremaker-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/coremaker-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,46 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <spu_mfcio.h>\n-\n-void\n-terminal_func ()\n-{\n-  spu_write_out_intr_mbox (0);\n-  spu_read_in_mbox ();\n-}\n-\n-int\n-factorial_func (int value)\n-{\n-  if (value > 1)\n-    value *= factorial_func (value - 1);\n-\n-  terminal_func ();\n-  return value;\n-}\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  factorial_func (6);\n-  return 0;\n-}\n-"
    },
    {
      "sha": "741e9483b4340d62d5402f7fe3885e1924c53c20",
      "filename": "gdb/testsuite/gdb.cell/coremaker.c",
      "status": "removed",
      "additions": 0,
      "deletions": 70,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/coremaker.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/coremaker.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/coremaker.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,70 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t coremaker_spu;\n-#define nr_t 5\n-\n-void *\n-spe_thread (void * arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &coremaker_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_attr_t attr;\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-  unsigned int value;\n-  int cnt;\n-\n-  /* Use small thread stacks to speed up writing out core file.  */\n-  pthread_attr_init (&attr);\n-  pthread_attr_setstacksize (&attr, 2*PTHREAD_STACK_MIN);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    {\n-      ctx[cnt] = spe_context_create (0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], &attr, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  pthread_attr_destroy (&attr);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_out_intr_mbox_read (ctx[cnt], &value, 1, SPE_MBOX_ALL_BLOCKING);\n-\n-  abort ();\n-}\n-"
    },
    {
      "sha": "56efbbcc635070c507a4d603b43d0dab863b97f7",
      "filename": "gdb/testsuite/gdb.cell/data-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/data-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,36 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  char var_char = 'c';\n-  short var_short = 7;\n-  int var_int = 1337;\n-  long var_long = 123456;\n-  long long var_longlong = 123456789;\n-  float var_float = 1.23;\n-  double var_double = 2.3456;\n-  long double var_longdouble = 3.45678;\n-  return 0; /* Marker SPU End */\n-}\n-"
    },
    {
      "sha": "7c38461181175c2c618a0d3755c37a29aad9d104",
      "filename": "gdb/testsuite/gdb.cell/data.c",
      "status": "removed",
      "additions": 0,
      "deletions": 72,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/data.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,72 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t data_spu;\n-#define nr_t 1\n-\n-void *\n-spe_thread (void *arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &data_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-\n-  int cnt;\n-\n-  char var_char = 'c';\n-  short var_short = 7;\n-  int var_int = 1337;\n-  long var_long = 123456;\n-  long long var_longlong = 123456789;\n-  float var_float = 1.23;\n-  double var_double = 2.3456;\n-  long double var_longdouble = 3.45678;\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    {\n-      ctx[cnt] = spe_context_create(0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], NULL, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    pthread_join (pts[cnt], NULL);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_context_destroy (ctx[cnt]);\n-\n-  return 0;\n-}"
    },
    {
      "sha": "f5c0d2078803f10609a746b63a5fca91ce748f3d",
      "filename": "gdb/testsuite/gdb.cell/data.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 125,
      "changes": 125,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/data.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/data.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,125 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tries to read variables of each kind both on PPU and SPU.\n-\n-load_lib cell.exp\n-\n-set testfile \"data\"\n-set ppu_file \"data\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"data-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-proc check_var { name value } {\n-  gdb_test \"print $name\" \\\n-\t   \".*=.*$value\" \\\n-\t   \"check_var $name = $value\"\n-}\n-\n-proc set_var { name value } {\n-  gdb_test \"set var $name = $value\" \\\n-\t   \"\" \\\n-\t   \"set var $name = $value\"\n-}\n-\n-proc dotest { name value } {\n-  set_var $name $value\n-  check_var $name $value\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Set values.\n-dotest var_char 'z'\n-dotest var_short 8\n-dotest var_int 321\n-dotest var_long 523442\n-dotest var_longlong 235354533\n-xfail \"dotest var_float 33.2113\"\n-xfail \"dotest var_double 2.3456\"\n-xfail \"dotest var_longdouble 3.456789\"\n-\n-gdb_test \"break 55\" \\\n-\t \"Breakpoint.*at.*file.*$testfile.c, line 55.*\" \\\n-\t \"set breakpoint\"\n-gdb_test \"continue\" \\\n-\t \"Breakpoint.*at.*$testfile.c.*55.*\" \\\n-\t \"continue to bp at line 55\"\n-\n-# Lookup variables.\n-check_var var_char 'c'\n-check_var var_short 7\n-check_var var_int 1337\n-check_var var_long 123456\n-check_var var_longlong 123456789\n-xfail \"check_var var_float 1.23\"\n-xfail \"check_var var_double 2.3456\"\n-xfail \"check_var var_longdouble 3.456789\"\n-\n-cont_spu_main\n-c_to \"Marker SPU End\" $spu_file.c\n-\n-# In SPU Thread, arch should now be spu:256K.\n-check_spu_arch \"\"\n-\n-# Lookup variables.\n-check_var var_char 'c'\n-check_var var_short 7\n-check_var var_int 1337\n-check_var var_long 123456\n-check_var var_longlong 123456789\n-xfail \"check_var var_float 1.23\"\n-xfail \"check_var var_double 2.3456\"\n-xfail \"check_var var_longdouble 3.456789\"\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "543da3d78d39653b8bd84963c070f610cdaf5c8f",
      "filename": "gdb/testsuite/gdb.cell/dwarfaddr.S",
      "status": "removed",
      "additions": 0,
      "deletions": 190,
      "changes": 190,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/dwarfaddr.S",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/dwarfaddr.S",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/dwarfaddr.S?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,190 +0,0 @@\n-/* Copyright 2010-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   This file is part of the gdb testsuite.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-   Tests for SPU addresses resulting from complex DWARF expressions.  */\n-\n-\t.text\n-main:\n-.Ltext_s:\n-.LFB1:\n-\tstqd        $1,-240($1)\n-\tai          $1,$1,-240\n-\tai          $2,$1,32\n-\tai          $2,$2,127\n-\til          $3,127\n-\tandc        $3,$2,$3\n-\til          $2,1\n-\tlqd         $4,0($3)\n-\tcwd         $5,0($3)\n-\tshufb       $2,$2,$4,$5\n-\tstqd        $2,0($3)\n-\tlqd         $1,0($1)\n-\tbi          $0\n-.LFE1:\n-\t.global main\n-\t.type\tmain,@function\n-\t.size\tmain,.LFE1-.LFB1\n-.Ltext_e:\n-\n-\t.section\t.debug_info,\"\",@progbits\n-.Ldebug_info_s:\n-\t.int\t.debug_info_size-4\n-\t.short\t0x2\n-\t.int\t.Ldebug_abbrev_s\n-\t.byte\t0x4\n-.Ldie0:\n-\t.uleb128\t0x1\n-\t.string\t\"test.c\"\n-\t.int\t.Ltext_s\n-\t.int\t.Ltext_e\n-\t.byte\t0x1\n-.Ldie1:\n-\t.uleb128\t0x2\n-\t.string\t\"int\"\n-\t.byte\t0x4\n-\t.byte\t0x5\n-.Ldie2:\n-\t.uleb128\t0x3\n-\t.int\t.Ldie4-.Ldebug_info_s\n-\t.int\t.Ldie1-.Ldebug_info_s\n-.Ldie3:\n-\t.uleb128\t0x4\n-\t.byte\t0\n-\t.byte\t0xf\n-\t.uleb128\t0\n-.Ldie4:\n-\t.uleb128\t0x5\n-\t.string\t\"main\"\n-\t.int\t.LFB1\n-\t.int\t.LFE1\n-\t.byte\t0x1\n-\t.byte\t0x1\n-\t.byte\t0x3\n-\t.byte\t0x1\n-\t.byte\t0x1\n-\t.byte\t0x51\n-.Ldie5:\n-\t.uleb128\t0x6\n-\t.byte\t0xe\n-\t.byte\t0x91\n-\t.sleb128\t0x20\n-\t.byte\t0xd\n-\t.int\t0x7f\n-\t.byte\t0x22\n-\t.byte\t0xd\n-\t.int\t0xffffff80\n-\t.byte\t0x1a\n-\t.string\t\"x\"\n-\t.byte\t0x1\n-\t.byte\t0\n-\t.int\t.Ldie2-.Ldebug_info_s\n-\t.uleb128\t0\n-\t.uleb128\t0\n-.Ldebug_info_e:\n-\t.set\t.debug_info_size,.Ldebug_info_e-.Ldebug_info_s\n-\n-\n-\t.section\t.debug_abbrev,\"\",@progbits\n-.Ldebug_abbrev_s:\n-\t.uleb128\t0x1\n-\t.uleb128\t0x11\n-\t.byte\t0x1\n-\t.uleb128\t0x3\n-\t.uleb128\t0x8\n-\t.uleb128\t0x11\n-\t.uleb128\t0x1\n-\t.uleb128\t0x12\n-\t.uleb128\t0x1\n-\t.uleb128\t0x13\n-\t.uleb128\t0xb\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\n-\t.uleb128\t0x2\n-\t.uleb128\t0x24\n-\t.byte\t0\n-\t.uleb128\t0x3\n-\t.uleb128\t0x8\n-\t.uleb128\t0xb\n-\t.uleb128\t0xb\n-\t.uleb128\t0x3e\n-\t.uleb128\t0xb\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\n-\t.uleb128\t0x3\n-\t.uleb128\t0x1\n-\t.byte\t0x1\n-\t.uleb128\t0x1\n-\t.uleb128\t0x13\n-\t.uleb128\t0x49\n-\t.uleb128\t0x13\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\n-\t.uleb128\t0x4\n-\t.uleb128\t0x21\n-\t.byte\t0\n-\t.uleb128\t0x22\n-\t.uleb128\t0xb\n-\t.uleb128\t0x2f\n-\t.uleb128\t0xb\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\n-\t.uleb128\t0x5\n-\t.uleb128\t0x2e\n-\t.byte\t0x1\n-\t.uleb128\t0x3\n-\t.uleb128\t0x8\n-\t.uleb128\t0x11\n-\t.uleb128\t0x1\n-\t.uleb128\t0x12\n-\t.uleb128\t0x1\n-\t.uleb128\t0x27\n-\t.uleb128\t0xc\n-\t.uleb128\t0x3a\n-\t.uleb128\t0xb\n-\t.uleb128\t0x3b\n-\t.uleb128\t0xb\n-\t.uleb128\t0x3f\n-\t.uleb128\t0xc\n-\t.uleb128\t0x40\n-\t.uleb128\t0xa\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\n-\t.uleb128\t0x6\n-\t.uleb128\t0x34\n-\t.byte\t0\n-\t.uleb128\t0x2\n-\t.uleb128\t0xa\n-\t.uleb128\t0x3\n-\t.uleb128\t0x8\n-\t.uleb128\t0x3a\n-\t.uleb128\t0xb\n-\t.uleb128\t0x3b\n-\t.uleb128\t0xb\n-\t.uleb128\t0x49\n-\t.uleb128\t0x13\n-\t.uleb128\t0\n-\t.uleb128\t0\n-\t.uleb128\t0\n-.Ldebug_abbrev_e:\n-\t.set\t.debug_abbrev_size,.Ldebug_abbrev_e-.Ldebug_abbrev_s\n-"
    },
    {
      "sha": "b61cd53c2e17a90c6783c01b962fafb9ffef7ad7",
      "filename": "gdb/testsuite/gdb.cell/dwarfaddr.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 53,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/dwarfaddr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/dwarfaddr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/dwarfaddr.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,53 +0,0 @@\n-# Copyright 2010-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# This file is part of the gdb testsuite.\n-#\n-# Contributed by Ulrich Weigand  <uweigand@de.ibm.com>.\n-# Tests for SPU addresses resulting from complex DWARF expressions.\n-\n-load_lib cell.exp\n-\n-set testfile \"dwarfaddr\"\n-set srcfile ${srcdir}/${subdir}/${testfile}.S\n-set binary [standard_output_file ${testfile}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $srcfile $binary executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${binary}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-gdb_test \"print x\" \" = \\\\{0 <repeats 16 times>\\\\}\" \"print x\"\n-gdb_test \"print &x\" \" = \\\\(int \\\\(\\\\*\\\\)\\\\\\[16\\\\\\]\\\\) 0x\\[0-9a-f\\]*\" \"print &x\"\n-gdb_test \"info address x\" \"Symbol \\\"x\\\" is a complex DWARF expression.*DW_OP_and\\[\\r\\n\\]+\\.\" \"info address x\"\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "07b11c18d304f1686866b6202b0d250e45ba1804",
      "filename": "gdb/testsuite/gdb.cell/ea-cache-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 41,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-cache-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,41 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <spu_mfcio.h>\n-\n-__ea int *ppe_int_ptr;\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  printf (\"spe.c | argp = 0x%llx\\n\", argp);\n-\n-#ifdef __EA32__\n-  ppe_int_ptr = (__ea int *)(unsigned long)argp;\n-#else\n-  ppe_int_ptr = (__ea int *)argp;\n-#endif\n-  printf (\"spe.c | value = %d\\n\", *ppe_int_ptr);\n-  *ppe_int_ptr = 42; /* Marker SPUEA */\n-  printf (\"spe.c | value = %d\\n\", *ppe_int_ptr);\n-\n-  return 0;\n-}"
    },
    {
      "sha": "a0a828b017b30b939df4c00acce403cf7b476bce",
      "filename": "gdb/testsuite/gdb.cell/ea-cache.c",
      "status": "removed",
      "additions": 0,
      "deletions": 64,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-cache.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,64 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t ea_cache_spu;\n-int int_var = 23;\n-\n-void *\n-spe_thread (void *arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &ea_cache_spu);\n-  spe_context_run (*ctx, &entry, flags, &int_var, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  spe_context_ptr_t ctx;\n-  pthread_t pts;\n-  int thread_id;\n-\n-  printf (\"ppe.c | int_var vor %d | adr int_var %p\\n\", int_var, &int_var);\n-\n-  /* Create SPE context and pthread.  */\n-  ctx = spe_context_create (0, NULL);\n-  thread_id = pthread_create (&pts, NULL, &spe_thread, &ctx);\n-\n-  /* Join the pthread.  */\n-  pthread_join (pts, NULL);\n-\n-  /* Destroy the SPE context.  */\n-  spe_context_destroy (ctx);\n-\n-  printf (\"ppe.c | int_var nach %d\\n\", int_var);\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "e9bb7091552803405f49d8e4a9cc29bc53088351",
      "filename": "gdb/testsuite/gdb.cell/ea-cache.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 90,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-cache.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-cache.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,90 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Testcase for ea software managed cache.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"ea-cache\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"ea-cache-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Set breakpoint in SPU binary.\n-cont_spu_main\n-c_to \"Marker SPUEA\" $spu_file.c\n-\n-gdb_test \"p *ppe_int_ptr\" \\\n-\t \".*=.*23.*\" \\\n-\t \"p *ppe_int_ptr\"\n-\n-gdb_test \"set *ppe_int_ptr=42\" \"\" \"\"\n-\n-gdb_test \"p *ppe_int_ptr\" \\\n-\t \".*=.*42.*\" \\\n-\t \"p *ppe_int_ptr\"\n-\n-# Now switch to thread 1 (PPU) and look at int_var.  ppe_int_ptr points to\n-# int_var and should now also contain 42 (ea cache has been flushed).\n-gdb_test \"t 1\" \\\n-\t \".*Switching to thread 1.*\" \\\n-\t \"switch to thread 1\"\n-\n-gdb_test \"p int_var\" \\\n-\t \".*=.*42.*\" \\\n-\t \"p int_var on ppu\"\n-\n-gdb_exit\n-return 0\n-\n-"
    },
    {
      "sha": "20b9af3316f6a9651e517b7d7f9ebf960280a5f2",
      "filename": "gdb/testsuite/gdb.cell/ea-standalone.c",
      "status": "removed",
      "additions": 0,
      "deletions": 34,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-standalone.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-standalone.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-standalone.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,34 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <ea.h>\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  int a;\n-  __ea int *myarray = malloc_ea (3 * sizeof (int));\n-\n-  memset_ea (myarray, 0, 3 * sizeof (int));\n-  a = ++myarray[0]; /* Marker SPUEA1  */\n-  printf(\"a: %d, myarray[0]: %d\\n\", a, myarray[0]); /* Marker SPUEA2  */\n-  return 0;\n-}"
    },
    {
      "sha": "cae8e98cdf8fc75dc0986565b7cbfbca527ed2ad",
      "filename": "gdb/testsuite/gdb.cell/ea-standalone.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 64,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-standalone.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-standalone.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-standalone.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,64 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Testcase for ea software managed cache in a standalone binary.\n-\n-load_lib cell.exp\n-\n-set testfile \"ea-standalone\"\n-set srcfile ${srcdir}/${subdir}/${testfile}.c\n-set binary [standard_output_file ${testfile}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $srcfile $binary executable {debug}]  != \"\" } {\n-  unsupported \"failed to compile\"\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${binary}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-c_to \"Marker SPUEA1\" $testfile.c\n-gdb_test \"p myarray\\[0\\]\" \\\n-\t \".*= 0\" \\\n-\t \"p myarray\\[0\\]\"\n-\n-c_to \"Marker SPUEA2\" $testfile.c\n-gdb_test \"p myarray\\[0\\]\" \\\n-\t \".*= 1\" \\\n-\t \"p myarray\\[0\\]\"\n-gdb_test \"call __cache_flush()\" \"\" \"call cache_flush()\"\n-gdb_test \"p myarray\\[0\\]\" \\\n-\t \".*= 1\" \\\n-\t \"p myarray\\[0\\]\"\n-\n-gdb_exit\n-return 0\n-\n-"
    },
    {
      "sha": "efe49c541862d61b8fcc2693946aeb28cb2866cc",
      "filename": "gdb/testsuite/gdb.cell/ea-test.c",
      "status": "removed",
      "additions": 0,
      "deletions": 33,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-test.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-test.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-test.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,33 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-\n-__ea int *ppe_pointer;\n-int *normal_pointer;\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  static __ea int *local_ppe_pointer;\n-  static int *local_normal_pointer;\n-  return 0;\n-}\n-"
    },
    {
      "sha": "cbb02f120abdc5e10301a899b819af4f975803ff",
      "filename": "gdb/testsuite/gdb.cell/ea-test.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 124,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-test.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ea-test.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ea-test.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,124 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Testcase for __ea pointer\n-\n-load_lib cell.exp\n-\n-set testfile \"ea-test\"\n-set source ${srcdir}/${subdir}/${testfile}.c\n-set binary [standard_output_file ${testfile}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $source $binary executable {debug}]  != \"\" } {\n-  unsupported \"failed to compile\"\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${binary}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# p\n-gdb_test \"p ppe_pointer\" \\\n-\t \"(int.*@__ea).*0x0.*\" \\\n-\t \"p ppe_pointer\"\n-\n-gdb_test \"p normal_pointer\" \\\n-\t \"(int.*).*0x0.*\" \\\n-\t \"p normal_pointer\"\n-\n-gdb_test \"p local_ppe_pointer\" \\\n-\t \"(int.*@__ea).*0x0.*\" \\\n-\t \"p local_ppe_pointer\"\n-\n-gdb_test \"p local_normal_pointer\" \\\n-\t \"(int.*).*0x0.*\" \\\n-\t \"p local_normal_pointer\"\n-\n-# ptype\n-gdb_test \"ptype ppe_pointer\" \\\n-\t \"type = int.*@__ea\" \\\n-\t \"ptype ppe_pointer\"\n-\n-gdb_test \"ptype normal_pointer\" \\\n-\t \"type = int.*\" \\\n-\t \"ptype normal_pointer\"\n-\n-gdb_test \"ptype local_ppe_pointer\" \\\n-\t \"type = int.*@__ea\" \\\n-\t \"ptype local_ppe_pointer\"\n-\n-gdb_test \"ptype local_normal_pointer\" \\\n-\t \"type = int.*\" \\\n-\t \"ptype local_normal_pointer\"\n-\n-# info locals\n-gdb_test \"info locals\" \\\n-\t \".*local_ppe_pointer =.*0x0.*local_normal_pointer =.*0x0.*\" \\\n-\t \"info locals\"\n-\n-# p &\n-gdb_test \"p &ppe_pointer\" \\\n-\t \".*=.*(int.*@__ea.*).*0x.*\" \\\n-\t \"p &ppe_pointer\"\n-\n-gdb_test \"p &normal_pointer\" \\\n-\t \".*=.*(int.*).*0x.*\" \\\n-\t \"p &normal_pointer\"\n-\n-gdb_test \"p &local_ppe_pointer\" \\\n-\t \".*=.*(int.*@__ea.*).*0x.*\" \\\n-\t \"p &local_ppe_pointer\"\n-\n-gdb_test \"p &local_normal_pointer\" \\\n-\t \".*=.*(int.*).*0x.*\" \\\n-\t \"p &local_normal_pointer\"\n-\n-# ptype *\n-gdb_test \"ptype *ppe_pointer\" \\\n-\t \"type = int\" \\\n-\t \"ptype *ppe_pointer\"\n-\n-gdb_test \"ptype *normal_pointer\" \\\n-\t \"type = int\" \\\n-\t \"ptype *normal_pointer\"\n-\n-gdb_test \"ptype *local_ppe_pointer\" \\\n-\t \"type = int\" \\\n-\t \"ptype *local_ppe_pointer\"\n-\n-gdb_test \"ptype *local_normal_pointer\" \\\n-\t \"type = int\" \\\n-\t \"ptype *local_normal_pointer\"\n-\n-gdb_exit\n-\n-return 0\n-\n-"
    },
    {
      "sha": "a37c77afe5e93c19450bb826f6c16eec66dbcc14",
      "filename": "gdb/testsuite/gdb.cell/f-regs.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 89,
      "changes": 89,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/f-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/f-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/f-regs.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,89 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcase tests access to SPU vector registers while language is fortran.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-proc check_vector_regs {} {\n-  for {set check_reg 0} {$check_reg < 128} {incr check_reg} {\n-\n-    gdb_test \"p \\$r$check_reg\" \\\n-\t     \"r$check_reg.*=.*\\(.*\\).*\" \\\n-\t     \"p \\$r$check_reg\"\n-\n-    gdb_test \"ptype \\$r$check_reg\" \\\n-\t     \"type = Type,.*C_Union :: __spu_builtin_type_vec128.*int128_t :: uint128.*int64_t :: v2_int64.*int32_t :: v4_int32\\(.*\\).*int16_t :: v8_int16\\(.*\\).*int8_t :: v16_int8\\(.*\\).*double :: v2_double\\(.*\\).*float :: v4_float\\(.*\\).*End Type __spu_builtin_type_vec128.*\" \\\n-\t     \"ptype \\$r$check_reg\"\n-  }\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-# No programm running, no registers should be available.\n-gdb_test \"info all-registers\" \\\n-         \"The program has no registers now.\" \\\n-         \"info all-registers\"\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-cont_spu_main\n-gdb_test \"set language fortran\" \\\n-\t \"Warning: the current language does not match this frame.*\" \\\n-\t \"set language fortran\"\n-check_vector_regs\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "7777165d9745c8e748366a44072aca7dd1dbb752",
      "filename": "gdb/testsuite/gdb.cell/fork-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 47,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/fork-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,47 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2010-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>  */\n-\n-#include <spu_mfcio.h>\n-\n-int var;\n-\n-void\n-func (void)\n-{\n-}\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  /* Signal to PPU side that it should fork now.  */\n-  spu_write_out_intr_mbox (0);\n-\n-  /* Wait until fork completed.  */\n-  spu_read_in_mbox ();\n-\n-  /* Trigger watchpoint.  */\n-  var = 1;\n-\n-  /* Now call some function to trigger breakpoint.  */\n-  func ();\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "240af47089b8f348864d71136f8ad263d425eebc",
      "filename": "gdb/testsuite/gdb.cell/fork.c",
      "status": "removed",
      "additions": 0,
      "deletions": 77,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/fork.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,77 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2010-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Ulrich Weigand <uweigand@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/types.h>\n-#include <sys/wait.h>\n-#include <unistd.h>\n-\n-extern spe_program_handle_t fork_spu;\n-\n-void *\n-spe_thread (void * arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &fork_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  pthread_t pts;\n-  spe_context_ptr_t ctx;\n-  unsigned int value;\n-  unsigned int pid;\n-\n-  ctx = spe_context_create (0, NULL);\n-  pthread_create (&pts, NULL, &spe_thread, &ctx);\n-\n-  /* Wait until the SPU thread is running.  */\n-  spe_out_intr_mbox_read (ctx, &value, 1, SPE_MBOX_ALL_BLOCKING);\n-\n-  pid = fork ();\n-  if (pid == 0)\n-    {\n-      /* This is the child.  Just exit immediately.  */\n-      exit (0);\n-    }\n-  else\n-    {\n-      /* This is the parent.  Wait for the child to exit.  */\n-      waitpid (pid, NULL, 0);\n-    }\n-\n-  /* Tell SPU to continue.  */\n-  spe_in_mbox_write (ctx, &value, 1, SPE_MBOX_ALL_BLOCKING);\n-  \n-  pthread_join (pts, NULL);\n-  spe_context_destroy (ctx);\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "009219180fdd3a57b2367e0e1274145b57d8bbfa",
      "filename": "gdb/testsuite/gdb.cell/fork.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 86,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/fork.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/fork.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,86 +0,0 @@\n-# Copyright 2010-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Ulrich Weigand <uweigand@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests support for PPU-side fork during SPU debugging\n-\n-load_lib cell.exp\n-\n-set testfile \"fork\"\n-set ppu_file \"fork\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"fork-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-delete_breakpoints\n-\n-gdb_test_no_output \"set spu stop-on-load\" \"set spu stop-on-load\"\n-\n-gdb_test \"continue\" \"Continuing\\\\..*Temporary breakpoint \\[0-9\\]+, main \\\\(speid=.*, argp=.*, envp=.*\\\\) at .*$spu_file\\\\.c:.*spu_write_out_intr_mbox.*\" \\\n-\t \"run until SPU main\"\n-\n-gdb_test \"break func\" \"Breakpoint \\[0-9\\]+ at.* file .*$spu_file.c, line \\[0-9\\]+\\\\.\" \"break func\"\n-gdb_test \"watch var\" \"Watchpoint \\[0-9\\]+: var\" \"watch var\"\n-\n-gdb_test \"continue\" \"Continuing\\\\..*Watchpoint.*Old value = 0.*New value = 1.*\" \\\n-\t \"run until watchpoint hit\"\n-\n-gdb_test_no_output \"delete \\$bpnum\" \"delete watchpoint\"\n-\n-gdb_test \"continue\" \"Continuing\\\\..*Breakpoint \\[0-9\\]+, func \\\\(\\\\) at .*$spu_file.c:.*\" \\\n-\t \"run until breakpoint hit\"\n-\n-gdb_continue_to_end \"\" continue 1\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "f586b7553aabb380805ca31649c46eb519180cdf",
      "filename": "gdb/testsuite/gdb.cell/gcore.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 108,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/gcore.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/gcore.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/gcore.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,108 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests mixed-architecture core file support\n-\n-load_lib cell.exp\n-\n-set testfile \"coremaker\"\n-set ppu_file \"coremaker\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"coremaker-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {![isnative]} then {\n-    return 0\n-}\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-delete_breakpoints\n-\n-gdb_test \"continue\" \".*Aborted.*\"\n-\n-if {![gdb_gcore_cmd \"${objdir}/${subdir}/gcore.test\" \\\n-\t  \"save a corefile\"]} {\n-    return -1\n-}\n-\n-# Now restart gdb and load the corefile.\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-send_gdb \"core-file $objdir/$subdir/gcore.test\\n\"\n-gdb_expect {\n-    -re \"Core was generated by .*coremaker.*\\r\\n\\#0  .*\\(\\).*\\r\\n$gdb_prompt $\" {\n-\tpass \"core-file command\"\n-    }\n-    -re \"Core was generated by .*\\r\\n\\#0  .*\\(\\).*\\r\\n$gdb_prompt $\" {\n-\tpass \"core-file command (with bad program name)\"\n-    }\n-    -re \".*$gdb_prompt $\"\t{ fail \"core-file command\" }\n-    timeout\t\t\t{ fail \"(timeout) core-file command\" }\n-}\n-\n-gdb_test \"backtrace\" \".*abort.*main.*at.*$ppu_file.c.*\"\n-\n-for {set thread_id 2} {$thread_id < 7} {incr thread_id} {\n-  gdb_test \"t $thread_id\" \\\n-           \"Switching to thread $thread_id.*\" \\\n-           \"switch to thread $thread_id\"\n-  gdb_test \"backtrace\" \\\n-\t   \".*terminal_func.*factorial_func.*value=1.*factorial_func.*value=2.*factorial_func.*value=3.*factorial_func.*value=4.*factorial_func.*value=5.*factorial_func.*value=6.*main.*speid.*argp.*envp.*at.*$spu_file.c.*<cross-architecture call>.*spe_context_run.*spe_thread.*at.*$ppu_file.c.*\" \\\n-\t   \"backtrace in thread $thread_id\"\n-}\n-\n-gdb_exit\n-\n-return 0"
    },
    {
      "sha": "3baa3a2cc115dede0b1b2bd0027b811be1411146",
      "filename": "gdb/testsuite/gdb.cell/mem-access-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/mem-access-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,36 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  int i;\n-  static int test_var;\n-\n-  printf (\"Hello World! from spu\\n\");\n-\n-  test_var = 5;\n-  i = 5; /* Marker SPUEA */\n-  printf (\"i = %d\\n\", i);\n-\n-  return 0;\n-}"
    },
    {
      "sha": "442e8a245d49a0a4be7c6413336504e64aaa32bf",
      "filename": "gdb/testsuite/gdb.cell/mem-access.c",
      "status": "removed",
      "additions": 0,
      "deletions": 67,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/mem-access.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,67 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t mem_access_spu;\n-#define nr_t 1\n-\n-void *\n-spe_thread (void *arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &mem_access_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-  int value = 1;\n-  int cnt;\n-  static int test_var;\n-\n-  test_var = 5;\n-  for (cnt = 0; cnt < nr_t; cnt++) /* Marker PPUEA */\n-    {\n-      ctx[cnt] = spe_context_create (0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], NULL, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    pthread_join (pts[cnt], NULL);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_context_destroy (ctx[cnt]);\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "86d22941ac9a387cd25c0dad96b686ceb30a9f15",
      "filename": "gdb/testsuite/gdb.cell/mem-access.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 170,
      "changes": 170,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/mem-access.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/mem-access.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,170 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcases tests on PPU and SPU if variables and registers are accessible\n-# via print and set by using names and adresses.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"mem-access\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"mem-access-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-# Get the adress to symbol name. If $reg\n-# is set to 1, get address from a register.\n-proc get_adress_from_name { name reg } {\n-  global gdb_prompt\n-  set adr \"\"\n-\n-  if { $reg == 1 } {\n-    set q \"x/x $name\"\n-  } else {\n-    set q \"x/x &$name\"\n-  }\n-\n-  gdb_test_multiple $q \"get address from $name\" {\n-    -re \"(0x.....):.*$gdb_prompt $\" { # Registers.\n-      set adr $expect_out(1,string)\n-      pass \"get adress from $name = $adr\"\n-    }\n-    -re \"(0x........) <.*$gdb_prompt $\" { # PPU address.\n-      set adr $expect_out(1,string)\n-      pass \"get adress from $name = $adr\"\n-    }\n-    -re \"(0x....) <.*$gdb_prompt $\" { # SPU address.\n-      set adr $expect_out(1,string)\n-      pass \"get adress from $name = $adr\"\n-    }\n-    -re \"(0x...) <.*$gdb_prompt $\" { # SPU address.\n-      set adr $expect_out(1,string)\n-      pass \"get adress from $name = $adr\"\n-    }\n-  }\n-\n-  return ${adr}\n-}\n-\n-# Try to set a $value at adress $adr.\n-proc set_adr_content { adr value } {\n-  gdb_test \"set *$adr=$value\" \\\n-\t   \"\" \\\n-\t   \"set *$adr=$value\"\n-}\n-\n-# Try to set a $value for $symbol.\n-proc set_symbol_content { symbol value } {\n-  gdb_test \"set $symbol=$value\" \\\n-\t   \"\" \\\n-\t   \"set *$symbol=$value\"\n-}\n-\n-# Check if $value is at *adr\n-proc test_adr_content { adr value } {\n-  gdb_test \"p *$adr\" \\\n-           \".*=.*$value.*\" \\\n-           \"(ptr) *$adr==$value\"\n-}\n-\n-proc test_symbol_content { symbol value } {\n-  gdb_test \"p $symbol\" \\\n-\t   \".*=.*$value.*\" \\\n-\t   \"(symbol) $symbol==$value\"\n-}\n-\n-# Check VARNAME. Check if it has the inital\n-# value INITIALVALUE. Set it to NEWVALUE.\n-# Check if set properly. Do it via symbols and\n-# pointers.\n-proc check_var { varname initalvalue newvalue } {\n-\n-  # Initial value should be $initalvalue.\n-  test_symbol_content $varname $initalvalue\n-\n-  # Get pointer to symbol and check if the\n-  # initial value is found.\n-  set adr [get_adress_from_name $varname 0]\n-  test_adr_content $adr $initalvalue\n-\n-  # Re-set value using the pointer.\n-  set_adr_content $adr $newvalue\n-\n-  # Test values by pointer and by symbol.\n-  test_adr_content $adr $newvalue\n-  test_symbol_content $varname $newvalue\n-\n-  # Set value back to initalvalue using symbol\n-  # name and check it.\n-  set_symbol_content $varname $initalvalue\n-  test_adr_content $adr $initalvalue\n-  test_symbol_content $varname $initalvalue\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Check in PPU thread.\n-c_to \"Marker PPUEA\" $ppu_file.c\n-check_var \"test_var\" 5 7\n-\n-# Go to SPU thread.\n-cont_spu_main\n-c_to \"Marker SPUEA\" $spu_file.c\n-check_spu_arch \"\"\n-\n-# Check in SPU thread.\n-check_var \"test_var\" 5 7\n-# Check $sp register.\n-set adr [get_adress_from_name \"\\$sp\" 1]\n-set_adr_content $adr 8\n-test_adr_content $adr 8\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "39311e78d9bdbcea6e30bc117981cdd51bc1a6c9",
      "filename": "gdb/testsuite/gdb.cell/ptype.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 145,
      "changes": 145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ptype.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/ptype.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/ptype.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,145 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Test ptype and print/set of SPU-side registers.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Continue to SPU\n-cont_spu_main\n-\n-gdb_test \"info registers r2\"  \\\n-\t \"r2.*\\{uint128 =.*v2_int64 =.*v4_int32 =.*v8_int16 =.*v16_int8 =.*v2_double =.*v4_float =.*\\}.*\" \\\n-\t \"info registers r2\"\n-\n-for {set check_reg 10} {$check_reg < 12} {incr check_reg} {\n-  gdb_test \"print \\$r$check_reg\\.v4_int32\" \\\n-\t   \".*= \\{.*,.*,.*,.*\\}\" \\\n-\t   \"print \\$r$check_reg\\.v4_int32\"\n-\n-  gdb_test \"ptype \\$r$check_reg\" \\\n-\t   \"type = union __spu_builtin_type_vec128.*\\{.*int128_t uint128.* \\\n-\t    int64_t v2_int64.*int32_t v4_int32.*int16_t v8_int16.* \\\n-\t    int8_t v16_int8.*double v2_double.*float v4_float.*\\}\" \\\n-\t   \"ptype \\$r$check_reg\"\n-\n-  gdb_test \"set \\$r$check_reg\\.v4_int32 = {1,2,3,4}\" \\\n-\t   \"\" \\\n-\t   \"set \\$r$check_reg\\.v4_int32 = {1,2,3,4}\"\n-\n-  gdb_test \"print \\$r$check_reg\\.v4_int32\" \\\n-\t   \".*= \\{.*1, 2, 3, 4.*\\}\" \\\n-\t   \"print \\$r$check_reg\\.v4_int32\"\n-\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[0\\]\" \\\n-\t   \".*= 1.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[0\\]\"\n-\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[1\\]\" \\\n-\t   \".*= 2.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[1\\]\"\n-\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[2\\]\" \\\n-\t   \".*= 3.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[2\\]\"\n-\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[3\\]\" \\\n-\t   \".*= 4.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[3\\]\"\n-\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[4\\]\" \\\n-\t   \"no such vector element\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[4\\]\"\n-\n-  # Set single array elements to other values and check the results.\n-  gdb_test \"set \\$r$check_reg\\.v4_int32\\[0\\] = 5\" \\\n-\t   \"\" \\\n-\t   \"set \\$r$check_reg\\.v4_int32\\[0\\] = 5\"\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[0\\]\" \\\n-\t   \".*= 5.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[0\\]\"\n-\n-  gdb_test \"set \\$r$check_reg\\.v4_int32\\[1\\] = 6\" \\\n-\t   \"\" \\\n-\t   \"set \\$r$check_reg\\.v4_int32\\[1\\] = 6\"\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[1\\]\" \\\n-\t   \".*= 6.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[1\\]\"\n-\n-  gdb_test \"set \\$r$check_reg\\.v4_int32\\[2\\] = 7\" \\\n-\t   \"\" \\\n-\t   \"set \\$r$check_reg\\.v4_int32\\[2\\] = 7\"\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[2\\]\" \\\n-\t   \".*= 7.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[2\\]\"\n-\n-  gdb_test \"set \\$r$check_reg\\.v4_int32\\[3\\] = 8\" \\\n-\t   \"\" \\\n-\t   \"set \\$r$check_reg\\.v4_int32\\[3\\] = 8\"\n-  gdb_test \"print \\$r$check_reg.v4_int32\\[3\\]\" \\\n-\t   \".*= 8.*\" \\\n-\t   \"print \\$r$check_reg.v4_int32\\[3\\]\"\n-\n-  # Now there should be {5, 6, 7, 8} in that array.\n-  gdb_test \"print \\$r$check_reg\\.v4_int32\" \\\n-\t   \".*= \\{.*5, 6, 7, 8.*\\}\" \\\n-\t   \"print \\$r$check_reg\\.v4_int32\"\n-}\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "c4d271098bf35e2ab100a892258234aee2609379",
      "filename": "gdb/testsuite/gdb.cell/registers.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 106,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/registers.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/registers.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/registers.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,106 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcase tests registers on PPU and SPU.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-# No programm running, no registers should be available.\n-gdb_test \"info all-registers\" \\\n-\t  \"The program has no registers now.\" \\\n-\t  \"info all-registers\"\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Check registers in PPU thread.\n-gdb_test \"info reg r0\" \"r0.*\" \"info register r0\"\n-gdb_test \"info reg r31\" \"r31.*\" \"info register r31\"\n-gdb_test \"info reg r32\" \"Invalid register.*r32.*\" \"(invalid) info register r32\"\n-gdb_test \"info reg pc\" \"pc.*\" \"info register pc\"\n-gdb_test \"info reg cr\" \"cr.*\" \"info register cr\"\n-gdb_test \"info reg lr\" \"lr.*\" \"info register lr\"\n-gdb_test \"info reg ctr\" \"ctr.*\" \"info register ctr\"\n-gdb_test \"info reg xer\" \"xer.*\" \"info register xer\"\n-\n-# Continue to SPU thread.\n-cont_spu_main\n-\n-# In SPU thread, check SPU registers.\n-for {set check_reg 0} {$check_reg < 128} {incr check_reg} {\n-  gdb_test \"info reg r$check_reg\" \\\n-\t   \"r$check_reg.*uint128.*=.*v2\\_int64.*v4\\_int32.*v8\\_int16.*v16\\_int8.*v2\\_double.*v4\\_float.*\" \\\n-\t   \"info register r$check_reg\"\n-}\n-gdb_test \"info reg r128\" \\\n-\t \"Invalid register.*r128.*\" \\\n-\t \"(invalid) info register r128\"\n-\n-gdb_test \"info reg pc\" \"pc.*main.*\" \"info register pc\"\n-gdb_test \"info reg id\" \"id.*\" \"info register id\"\n-gdb_test \"info reg sp\" \"sp.*\" \"info register sp\"\n-gdb_test \"info reg fpscr\" \"fpscr.*\" \"info register fpscr\"\n-gdb_test \"info reg srr0\" \"srr0.*\" \"info register srr0\"\n-gdb_test \"info reg lslr\" \"lslr.*\" \"info register lslr\"\n-gdb_test \"info reg decr\" \"decr.*\" \"info register decr\"\n-gdb_test \"info reg decr_status\" \"decr_status.*\" \"info register decr-status\"\n-\n-gdb_test \"info reg cr\" \"Invalid register.*cr.*\" \"info register cr\"\n-gdb_test \"info reg lr\" \"Invalid register.*lr.*\" \"info register lr\"\n-gdb_test \"info reg ctr\" \"Invalid register.*ctr.*\" \"info register ctr\"\n-gdb_test \"info reg xer\" \"Invalid register.*xer.*\" \"info register xer\"\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "4d8b8815e8e27b5bc10eaaba2d18834a2c9c7eb6",
      "filename": "gdb/testsuite/gdb.cell/size-spu.c",
      "status": "removed",
      "additions": 0,
      "deletions": 53,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/size-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/size-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/size-spu.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,53 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-\n-\n-int\n-main (unsigned long long speid, unsigned long long argp,\n-      unsigned long long envp)\n-{\n-  int c  = sizeof (char); /* Break here.  */\n-  printf (\"sizeof(char)=%d\\n\", c);\n-\n-  int s  = sizeof (short);\n-  printf (\"sizeof(short)=%d\\n\", s);\n-\n-  int i  = sizeof (int);\n-  printf (\"sizeof(int)=%d\\n\", i);\n-\n-  int l  = sizeof (long);\n-  printf (\"sizeof(long)=%d\\n\", l);\n-\n-  int ll = sizeof (long long);\n-  printf (\"sizeof(long long)=%d\\n\", ll);\n-\n-  int f  = sizeof (float);\n-  printf (\"sizeof(float)=%d\\n\", f);\n-\n-  int d  = sizeof (double);\n-  printf (\"sizeof(double)=%d\\n\", d);\n-\n-  int ld = sizeof (long double);\n-  printf (\"sizeof(long double)=%d\\n\", ld);\n-\n-  return 0;\n-}\n-"
    },
    {
      "sha": "be9c8d33b25cb457ab0fa88b6c5e5ddd353374d2",
      "filename": "gdb/testsuite/gdb.cell/size.c",
      "status": "removed",
      "additions": 0,
      "deletions": 87,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/size.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/size.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/size.c?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,87 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2009-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-\n-   Contributed by Markus Deuling <deuling@de.ibm.com>  */\n-\n-#include <stdio.h>\n-#include <libspe2.h>\n-#include <pthread.h>\n-#include <sys/wait.h>\n-\n-extern spe_program_handle_t size_spu;\n-#define nr_t 1\n-\n-void *\n-spe_thread (void *arg)\n-{\n-  int flags = 0;\n-  unsigned int entry = SPE_DEFAULT_ENTRY;\n-  spe_context_ptr_t *ctx = (spe_context_ptr_t *) arg;\n-\n-  spe_program_load (*ctx, &size_spu);\n-  spe_context_run (*ctx, &entry, flags, NULL, NULL, NULL);\n-\n-  pthread_exit (NULL);\n-}\n-\n-int\n-main (void)\n-{\n-  int thread_id[nr_t];\n-  pthread_t pts[nr_t];\n-  spe_context_ptr_t ctx[nr_t];\n-  int cnt;\n-\n-  int c  = sizeof (char);\n-  printf (\"sizeof(char)=%d\\n\", c);\n-\n-  int s  = sizeof (short);\n-  printf (\"sizeof(short)=%d\\n\", s);\n-\n-  int i  = sizeof (int);\n-  printf (\"sizeof(int)=%d\\n\", i);\n-\n-  int l  = sizeof (long);\n-  printf (\"sizeof(long)=%d\\n\", l);\n-\n-  int ll = sizeof (long long);\n-  printf (\"sizeof(long long)=%d\\n\", ll);\n-\n-  int f  = sizeof (float);\n-  printf (\"sizeof(float)=%d\\n\", f);\n-\n-  int d  = sizeof (double);\n-  printf (\"sizeof(double)=%d\\n\", d);\n-\n-  int ld = sizeof (long double);\n-  printf (\"sizeof(long double)=%d\\n\", ld);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    {\n-      ctx[cnt] = spe_context_create (0, NULL);\n-      thread_id[cnt]\n-\t= pthread_create (&pts[cnt], NULL, &spe_thread, &ctx[cnt]);\n-    }\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    pthread_join (pts[cnt], NULL);\n-\n-  for (cnt = 0; cnt < nr_t; cnt++)\n-    spe_context_destroy (ctx[cnt]);\n-\n-  return 0;\n-}"
    },
    {
      "sha": "8ea69e67fa764743bfd2d07e58c37ac8f39a11a8",
      "filename": "gdb/testsuite/gdb.cell/sizeof.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 120,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/sizeof.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/sizeof.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/sizeof.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,120 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Check size of data types both on PPU and SPU.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"size\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"size-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-\n-# Ask GDB about the sizes of data types.  This has\n-# to be done in PPU thread and SPU thread.\n-proc get_gdb_size { type } {\n-  global gdb_prompt\n-\n-  set val \"0\"\n-  gdb_test_multiple \"print/d sizeof(${type})\" \"get sizeof(${type})\" {\n-    -re \"\\\\$\\[0-9\\]* = (\\[-\\]*\\[0-9\\]*).*$gdb_prompt $\" {\n-\tset val $expect_out(1,string)\n-\tpass \"get sizeof ($type) = $val\"\n-    }\n-  }\n-  return ${val}\n-}\n-\n-# Compare sizes from GDB and sizeof().\n-proc size_compare { type gdb_size } {\n-  set expr [string_to_regexp \"sizeof(${type})=${gdb_size}\"]\n-  gdb_test \"next\" \\\n-           \".*\" \\\n-           \"next\"\n-  # Checks against string_to_regexp fails in remote testing.\n-  if ![is_remote target] {\n-    gdb_test \"next\" \\\n-             \"${expr}.*\" \\\n-             \"check sizeof \\\"$type\\\" \\\"$gdb_size\\\" \"\n-  } else {\n-    gdb_test \"next\" \".*\" \"check sizeof deactivate in remote testing\"\n-  }\n-}\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Compare sizes.\n-size_compare \"char\" [get_gdb_size \"char\"]\n-size_compare \"short\" [get_gdb_size \"short\"]\n-size_compare \"int\" [get_gdb_size \"int\"]\n-size_compare \"long\" [get_gdb_size \"long\"]\n-size_compare \"long long\" [get_gdb_size \"long long\"]\n-size_compare \"float\" [get_gdb_size \"float\"]\n-size_compare \"double\" [get_gdb_size \"double\"]\n-size_compare \"long double\" [get_gdb_size \"long double\"]\n-\n-# Continue to SPU thread.\n-cont_spu_main\n-check_spu_arch \"\"\n-\n-# Compare sizes in SPU thread.\n-size_compare \"char\" [get_gdb_size \"char\"]\n-size_compare \"short\" [get_gdb_size \"short\"]\n-size_compare \"int\" [get_gdb_size \"int\"]\n-size_compare \"long\" [get_gdb_size \"long\"]\n-size_compare \"long long\" [get_gdb_size \"long long\"]\n-size_compare \"float\" [get_gdb_size \"float\"]\n-size_compare \"double\" [get_gdb_size \"double\"]\n-size_compare \"long double\" [get_gdb_size \"long double\"]\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "685ccf5c14a705be0a15f6b108af114bcbb2745e",
      "filename": "gdb/testsuite/gdb.cell/solib-symbol.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 79,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/solib-symbol.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/solib-symbol.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/solib-symbol.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,79 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# Testcase for multiple symbol disambiguation patch.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Symbol resolved in PPU thread.\n-gdb_test \"info symbol foo\" \\\n-\t \"foo in section \\.text of .*$ppu_file\\[\\r\\n\\]+.*\" \\\n-\t \"info symbol foo in break\"\n-\n-# Continue to SPU\n-cont_spu_main\n-check_spu_arch \"\"\n-\n-# Symbol resolved in SPU thread.\n-gdb_test \"info symbol foo\" \\\n-\t \"foo in section \\.text of .*$spu_file@.*\" \\\n-\t \"info symbol foo in break-spu\"\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "d6ed65daf2a2b3b6971d3ae8d52d5d38457ec848",
      "filename": "gdb/testsuite/gdb.cell/solib.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 86,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/solib.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/gdb.cell/solib.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cell/solib.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,86 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Testsuite for Cell Broadband Engine combined debugger\n-# This testcase checks 'info sharedlibrary ' command.\n-\n-load_lib cell.exp\n-\n-set ppu_file \"break\"\n-set ppu_src ${srcdir}/${subdir}/${ppu_file}.c\n-set ppu_bin [standard_output_file ${ppu_file}]\n-set spu_file \"break-spu\"\n-set spu_src ${srcdir}/${subdir}/${spu_file}.c\n-set spu_bin [standard_output_file ${spu_file}]\n-\n-if {[skip_cell_tests]} {\n-    return 0\n-}\n-\n-# Compile SPU binary.\n-if { [gdb_compile_cell_spu $spu_src $spu_bin executable {debug}]  != \"\" } {\n-  unsupported \"compiling spu binary failed.\"\n-  return -1\n-}\n-# Compile PPU binary.\n-if { [gdb_cell_embedspu $spu_bin $spu_bin-embed.o {debug}]  != \"\" } {\n-  unsupported \"embedding spu binary failed.\"\n-  return -1\n-}\n-if { [gdb_compile_cell_ppu [list $ppu_src $spu_bin-embed.o] $ppu_bin executable {debug}] != \"\" } {\n-  unsupported \"compiling ppu binary failed.\"\n-  return -1\n-}\n-\n-if [get_compiler_info] {\n-  return -1\n-}\n-\n-\n-gdb_exit\n-gdb_start\n-gdb_reinitialize_dir $srcdir/$subdir\n-gdb_load ${ppu_bin}\n-\n-# No programm running, no libraries should be loaded.\n-gdb_test \"info sharedlibrary\" \\\n-\t \"No shared libraries loaded at this time.\" \\\n-\t \"no shared library is loaded\"\n-\n-if ![runto_main] then {\n-  fail \"can't run to main\"\n-  return 0\n-}\n-\n-# Standing in PPU thread, now some libs should be loaded\n-# including libspe library.\n-gdb_test \"info sharedlibrary\" \\\n-\t \"From.*To.*Syms Read.*Shared Object Library.*libspe.*\" \\\n-\t \"binary started, some libraries loaded\"\n-\n-# Continue to SPU\n-cont_spu_main\n-check_spu_arch \"\"\n-\n-# In SPU thread now, the SPU binary should now appear in the list\n-# of shared libraries.\n-gdb_test \"info sharedlibrary\" \\\n-\t \"From.*To.*Syms Read.*Shared Object Library.*libspe.*$spu_bin.*@.*x.*\" \\\n-\t \"spu thread, spu binary as shared library\"\n-\n-gdb_exit\n-return 0"
    },
    {
      "sha": "f238f5188af4809a6bf95954e6706052ea0fabfc",
      "filename": "gdb/testsuite/gdb.cp/bs15503.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/bs15503.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/bs15503.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/bs15503.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -19,11 +19,6 @@\n \n if { [skip_stl_tests] } { continue }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n standard_testfile .cc\n \n if [get_compiler_info] {"
    },
    {
      "sha": "d7decaf542694a6ab570c03fb0faa43f54049007",
      "filename": "gdb/testsuite/gdb.cp/cpexprs.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/cpexprs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/cpexprs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/cpexprs.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -681,11 +681,6 @@ add {policyd5::function} \\\n # Start the test\n if {[skip_cplus_tests]} { continue }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n #\n # test running programs\n #"
    },
    {
      "sha": "13631df1290ba988821f005da602b84e6d1b0e8a",
      "filename": "gdb/testsuite/gdb.cp/exception.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/exception.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/exception.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/exception.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -35,11 +35,6 @@ set nl\t\"\\[\\r\\n\\]+\"\n \n if { [skip_stl_tests] } { continue }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n standard_testfile .cc\n  \n if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug c++}]} {"
    },
    {
      "sha": "a7de2ccbc2a0c596c1ffbeabd57b007e6a7bd027",
      "filename": "gdb/testsuite/gdb.cp/gdb2495.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/gdb2495.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/gdb2495.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/gdb2495.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -38,11 +38,6 @@ if [target_info exists gdb,nosignals] {\n     continue\n }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n standard_testfile .cc\n \n # Create and source the file that provides information about the compiler"
    },
    {
      "sha": "5946c0b25cb1988d6fc51ac860be4a63eb51cde6",
      "filename": "gdb/testsuite/gdb.cp/mb-templates.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/mb-templates.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/mb-templates.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/mb-templates.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -18,11 +18,6 @@\n \n if { [skip_stl_tests] } { continue }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n \n standard_testfile .cc\n "
    },
    {
      "sha": "214225233af1a5f00bf3090989ba288839534bda",
      "filename": "gdb/testsuite/gdb.cp/pr9167.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/pr9167.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/pr9167.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/pr9167.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -13,11 +13,6 @@\n # You should have received a copy of the GNU General Public License\n # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n standard_testfile .cc\n \n if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug c++}]} {"
    },
    {
      "sha": "7907593ec3010807d4691325745b8ed59678f345",
      "filename": "gdb/testsuite/gdb.cp/userdef.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/userdef.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.cp/userdef.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/userdef.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -21,11 +21,6 @@\n \n if { [skip_stl_tests] } { continue }\n \n-# On SPU this test fails because the executable exceeds local storage size.\n-if { [istarget \"spu*-*-*\"] } {\n-        return 0\n-}\n-\n standard_testfile .cc\n \n if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug c++}]} {"
    },
    {
      "sha": "efd2227dd543224e229ef7f4dc263d1b0dec3139",
      "filename": "gdb/testsuite/gdb.xml/tdesc-regs.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.xml/tdesc-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abf516c6931af1683d1e51203de1ca01467f9f85/gdb/testsuite/gdb.xml/tdesc-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.xml/tdesc-regs.exp?ref=abf516c6931af1683d1e51203de1ca01467f9f85",
      "patch": "@@ -69,16 +69,6 @@ switch -glob -- [istarget] {\n \tset regdir \"sparc/\"\n         set core-regs {sparc64-cpu.xml sparc64-fpu.xml sparc64-cp0.xml}\n     }\n-    \"spu*-*-*\" {\n-\t# This may be either the spu-linux-nat target, or the Cell/B.E.\n-\t# multi-architecture debugger in SPU standalone executable mode.\n-\t# We do not support XML register sets on SPU in either case.\n-\t# However, the multi-arch debugger will accept XML registers sets\n-\t# (on the PowerPC side), hence the test below would fail.\n-\t# Simply return unconditionally here.\n-\tunsupported \"register tests\"\n-\treturn 0\n-    }\n     \"tic6x-*-*\" {\n \tset core-regs {tic6x-core.xml}\n     }"
    },
    {
      "sha": "4a32805ead1f5c9211ae567d5e79b5ef5c996f2e",
      "filename": "gdb/testsuite/lib/cell.exp",
      "status": "removed",
      "additions": 0,
      "deletions": 181,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/lib/cell.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a/gdb/testsuite/lib/cell.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/cell.exp?ref=78e8cb91cd1374ac59cc8bf6509fa70bde74ff1a",
      "patch": "@@ -1,181 +0,0 @@\n-# Copyright 2009-2019 Free Software Foundation, Inc.\n-#\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-#\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-#\n-# Contributed by Markus Deuling <deuling@de.ibm.com>.\n-#\n-# Support library for testing the combined debugger for Linux\n-# on the Cell Broadband Engine.\n-\n-# Compile SPU objects.\n-proc gdb_compile_cell_spu {source dest type options} {\n-  global board\n-\n-  # Save and unset multilib flags; these are not appropriate\n-  # for the SPU compiler.\n-  set board [target_info name]\n-  set save_multilib_flag [board_info $board multilib_flags]\n-  unset_board_info \"multilib_flags\"\n-\n-  set options_spu [concat $options [list compiler=spu-gcc]]\n-  set ccout [gdb_compile $source $dest $type $options_spu]\n-\n-  set_board_info multilib_flags $save_multilib_flag\n-  return $ccout\n-}\n-\n-# Compile PPU objects.  This is just like gdb_compile_pthreads, except that we\n-# always add the libspe2 library for compiling Cell/B.E. programs.\n-proc gdb_compile_cell_ppu {source dest type options} {\n-    # We do not need to try multiple names for the pthread library\n-    # -lpthread works on all Cell/B.E. systems\n-    set lib \"-lspe2 -lpthread\"\n-    set options_ppu [concat $options [list libs=$lib]]\n-    return [gdb_compile $source $dest $type $options_ppu]\n-}\n-\n-# Embed SPU executable into a PPU object.\n-proc gdb_cell_embedspu {source dest options} {\n-    global CC_FOR_TARGET\n-\n-    if [info exists CC_FOR_TARGET] {\n-        set compiler $CC_FOR_TARGET\n-    } else {\n-\tset compiler [board_info [target_info name] compiler]\n-    }\n-\n-    # We assume the PPU compiler is called gcc or ppu-gcc,\n-    # and find the appropriate embedspu based on that.\n-    regsub gcc \"$compiler\" embedspu embedspu\n-\n-    # Determine default embedded symbol name from source filename.\n-    set path [split \"$source\" /]\n-    set filename [lindex $path [expr [llength $path] - 1]]\n-    regsub -all -- \"\\[-\\.\\]\" \"$filename\" \"_\" symbol\n-\n-    set options_embed [concat $options [list compiler=$embedspu]]\n-    return [gdb_compile \"$symbol $source $dest\" \"\" none $options_embed]\n-}\n-\n-# Run a test on the target to see if it supports Cell/B.E. hardware.\n-# Return 0 if so, 1 if it does not.\n-gdb_caching_proc skip_cell_tests {\n-    global srcdir subdir gdb_prompt inferior_exited_re\n-\n-    set me \"skip_cell_tests\"\n-\n-    # Set up, compile, and execute a combined Cell/B.E. test program.\n-    # Include the current process ID in the file names to prevent conflicts\n-    # with invocations for multiple testsuites.\n-    set src [standard_temp_file cell[pid].c]\n-    set exe [standard_temp_file cell[pid].x]\n-    set src_spu [standard_temp_file cell[pid]-spu.c]\n-    set exe_spu [standard_temp_file cell[pid]-spu.x]\n-\n-    set f [open $src \"w\"]\n-    puts $f \"#include <libspe2.h>\"\n-    puts $f \"extern spe_program_handle_t cell[pid]_spu_x;\"\n-    puts $f \"int main (void) {\"\n-    puts $f \"unsigned int entry = SPE_DEFAULT_ENTRY;\"\n-    puts $f \"spe_context_ptr_t ctx = spe_context_create (0, NULL);\"\n-    puts $f \"spe_program_load (ctx, &cell[pid]_spu_x);\"\n-    puts $f \"return spe_context_run (ctx, &entry, 0, NULL, NULL, NULL); }\"\n-    close $f\n-\n-    set f [open $src_spu \"w\"]\n-    puts $f \"int main (void) { return 0; }\"\n-    close $f\n-\n-    verbose \"$me:  compiling testfile $src\" 2\n-    set compile_flags {debug nowarnings quiet}\n-\n-    set skip 0\n-    if { [gdb_compile_cell_spu $src_spu $exe_spu executable $compile_flags] != \"\" } {\n-        verbose \"$me:  compiling spu binary failed, returning 1\" 2\n-\tset skip 1\n-    }\n-    if { ! $skip && [gdb_cell_embedspu $exe_spu $exe_spu-embed.o $compile_flags]  != \"\" } {\n-        verbose \"$me:  embedding spu binary failed, returning 1\" 2\n-\tset skip 1\n-    }\n-    if { ! $skip && [gdb_compile_cell_ppu [list $src $exe_spu-embed.o] $exe executable $compile_flags] != \"\" } {\n-        verbose \"$me:  compiling ppu binary failed, returning 1\" 2\n-\tset skip 1\n-    }\n-    file delete $src\n-    file delete $src_spu\n-    file delete $exe_spu\n-    file delete $exe_spu-embed.o\n-\n-    if { $skip } {\n-        return 1\n-    }\n-\n-    # Compilation succeeded so now run it via gdb.\n-\n-    gdb_exit\n-    gdb_start\n-    gdb_reinitialize_dir $srcdir/$subdir\n-    gdb_load \"$exe\"\n-    gdb_run_cmd\n-    gdb_expect {\n-        -re \".*$inferior_exited_re normally.*${gdb_prompt} $\" {\n-            verbose -log \"\\n$me: Cell/B.E. hardware detected\"\n-            set result 0\n-        }\n-        -re \".*$inferior_exited_re with code.*${gdb_prompt} $\" {\n-            verbose -log \"\\n$me: Cell/B.E. hardware not detected\"\n-            set result 1\n-        }\n-        default {\n-            unresolved \"$me: unexpected failure\"\n-            set result 1\n-        }\n-    }\n-    gdb_exit\n-    remote_file build delete $exe\n-\n-    verbose \"$me:  returning $result\" 2\n-    return $result\n-}\n-\n-# Delete all breakpoints and stop on the next new SPU thread\n-proc cont_spu_main { } {\n-  delete_breakpoints\n-  gdb_test \"set spu stop-on-load on\"\n-  gdb_test \"continue\" \\\n-           \"Continuing.*Temporary breakpoint .*main .*\" \\\n-           \"continue to SPU main\"\n-}\n-\n-# Continue to MARKER\n-proc c_to { marker srcfile } {\n-  set line [gdb_get_line_number $marker $srcfile]\n-  gdb_test \"break $line\" \\\n-\t   \"Breakpoint.*at.*file.*$srcfile.*line $line.*\" \\\n-\t   \"break $line\"\n-  gdb_test \"continue\" \\\n-\t   \"Continuing.*Breakpoint.*at.*$srcfile.*$line.*\" \\\n-\t   \"continue to $line\"\n-}\n-\n-# Check if the current thread has SPU architecture\n-proc check_spu_arch { msg } {\n-  if { $msg == \"\" } {\n-    set msg \"spu architecture is spu256K\"\n-  }\n-  gdb_test \"show architecture\" \\\n-\t   \"The target architecture is set automatically.*currently spu:256K.*\" \\\n-\t   $msg\n-}"
    }
  ]
}