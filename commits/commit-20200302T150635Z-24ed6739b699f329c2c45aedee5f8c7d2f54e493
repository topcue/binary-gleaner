{
  "sha": "24ed6739b699f329c2c45aedee5f8c7d2f54e493",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjRlZDY3MzliNjk5ZjMyOWMyYzQ1YWVkZWU1ZjhjN2QyZjU0ZTQ5Mw==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-01-30T14:35:40Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-03-02T15:06:35Z"
    },
    "message": "gdb/remote: Restore support for 'S' stop reply packet\n\nWith this commit:\n\n  commit 5b6d1e4fa4fc6827c7b3f0e99ff120dfa14d65d2\n  Date:   Fri Jan 10 20:06:08 2020 +0000\n\n      Multi-target support\n\nThere was a regression in GDB's support for older aspects of the\nremote protocol.  Specifically, when a target sends the 'S' stop reply\npacket (which doesn't include a thread-id) then GDB has to figure out\nwhich thread actually stopped.\n\nBefore the above commit GDB figured this out by using inferior_ptid in\nprocess_stop_reply, which contained the ptid of the current\nprocess/thread.  This would be fine for single threaded\ntargets (which is the only place using an S packet makes sense), but\nin the general case, relying on inferior_ptid for processing a stop is\nwrong - there's no reason to believe that what was GDB's current\nthread will be the same thread that just stopped in the target.\n\nWith the above commit the inferior_ptid now has the value null_ptid\ninside process_stop_reply, this can be seen in do_target_wait, where\nwe call switch_to_inferior_no_thread before calling do_target_wait_1.\n\nThe problem this causes can be seen in the new test that runs\ngdbserver using the flag --disable-packet=T, and causes GDB to throw\nthis assertion:\n\n  inferior.c:279: internal-error: inferior* find_inferior_pid(process_stratum_target*, int): Assertion `pid != 0' failed.\n\nA similar problem was fixed in this commit:\n\n  commit 3cada74087687907311b52781354ff551e10a0ed\n  Date:   Thu Jan 11 00:23:04 2018 +0000\n\n      Fix backwards compatibility with old GDBservers (PR remote/22597)\n\nHowever, this commit deals with the case where the T packet doesn't\ninclude a thread-id, not the S packet case.  This commit solves the\nproblem providing a thread-id at the GDB side if the remote target\ndoesn't provide one.  The thread-id provided comes from\nremote_state::general_thread, however, though this does work, I don't\nthink it is the ideal solution.\n\nThe remote_state tracks two threads, the continue_thread and the\ngeneral_thread, these are updated when GDB asks the remote target to\nswitch threads.  The general_thread is set before performing things\nlike register or memory accesses, and the continue_thread is set\nbefore things like continue or step commands.  Further, the\ngeneral_thread is updated after a target stops to reference the thread\nthat stopped.\n\nThe first thing to note from the above description is that we have a\ncycle of dependency, when a T packet arrives without a thread-id we\nfill in the thread-id from the general_thread data.  The thread-id\nfrom the stop event is then used to set the general_thread.  This in\nitself feels a little weird.\n\nThe second question is why use the general_thread at all? You'd think\ngiven how they are originally set that the continue thread would be a\nbetter choice.  The problem with this is that the continue_thread, if\nthe user just does \"continue\", will be set to the minus_one_ptid, in\nthe remote protocol this means all threads.  When the stop arrives\nwith no thread-id and we use continue_thread we end up with a very\nsimilar assertion to before because we now end up trying to lookup a\nthread using the minus_one_ptid.  By contrast, once GDB has connected\nto a remote target the general_thread will be set to a valid\nthread-id, after which, if the target is single threaded, and stop\nevents arrive without a thread-id, everything works fine.\n\nThere is one slight weirdness with the above behaviour though.  When\nGDB first connects to the remote target inferior_ptid is null_ptid,\nhowever, upon connecting we query the remote for its threads.  As the\nthread information arrives GDB adds the threads to its internal\ndatabase, and this process involves setting inferior_ptid to the id of\neach new thread in turn.  Once we know about all the threads we wait\nfor a stop event from the remote target to indicate that GDB is now in\ncontrol of the target.\n\nThe problem is that after adding the new threads we don't reset\ninferior_ptid, and the code path we use to wait for a stop event from\nthe target also doesn't reset inferior_ptid, so it turns out that\nduring the initial connection inferior_ptid is not null_ptid.  This is\nlucky, because during the initial connection the general_thread\nvariable _is_ set to null_ptid.\n\nSo, during the initial connection, if the first stop event is missing\na thread-id then we \"provide\" a thead-id from general_thread.  This\nturns out to be null_ptid meaning no thread-id is known, and then\nduring process_stop_reply we fill in the missing thread-id using\ninferior_ptid.\n\nThis was all discussed on the mailing list here:\n\n  https://sourceware.org/ml/gdb-patches/2020-02/msg01011.html\n\nMy proposal for a fix then is:\n\n 1. Move the call to switch_to_inferior_no_thread into\n do_target_wait_1, this means that in all cases where we are waiting\n for an inferior the inferior_ptid will be set to null_ptid.  This is\n good as no wait code should rely on inferior_ptid.\n\n 2. Remove the use of general_thread from the 'T' packet processing.\n The general_thread read here was only ever correct by chance, and we\n shouldn't be using it this way.\n\n 3. Remove use of inferior_ptid from process_stop_event as this is\n wrong, and will always be null_ptid now anyway.\n\n 4. When a stop_event has null_ptid due to a lack of thread-id (either\n from a T packet or an S packet) then pick the first non exited thread\n in the target and use that.  This will be fine for single threaded\n targets.  A multi-thread or multi-inferior aware remote target\n should be using T packets with a thread-id, so we give a warning if\n the target is multi-threaded, and we are still missing a thread-id.\n\n 5. Extend the existing test that covered the T packet with missing\n thread-id to also cover the S packet.\n\ngdb/ChangeLog:\n\n\t* remote.c (remote_target::remote_parse_stop_reply): Don't use the\n\tgeneral_thread if the stop reply is missing a thread-id.\n\t(remote_target::process_stop_reply): Use the first non-exited\n\tthread if the target didn't pass a thread-id.\n\t* infrun.c (do_target_wait): Move call to\n\tswitch_to_inferior_no_thread to ....\n\t(do_target_wait_1): ... here.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.server/stop-reply-no-thread.exp: Add test where T packet is\n\tdisabled.",
    "tree": {
      "sha": "ec71a1c2699493d4f1707eaf026f1b31d1001d71",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ec71a1c2699493d4f1707eaf026f1b31d1001d71"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/24ed6739b699f329c2c45aedee5f8c7d2f54e493",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24ed6739b699f329c2c45aedee5f8c7d2f54e493",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/24ed6739b699f329c2c45aedee5f8c7d2f54e493",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24ed6739b699f329c2c45aedee5f8c7d2f54e493/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "442131c1bec1a2ff0b3a5e5d1d91a116ce869dee",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/442131c1bec1a2ff0b3a5e5d1d91a116ce869dee",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/442131c1bec1a2ff0b3a5e5d1d91a116ce869dee"
    }
  ],
  "stats": {
    "total": 146,
    "additions": 101,
    "deletions": 45
  },
  "files": [
    {
      "sha": "47481bdc08e11561aa2b0e24a10b3ea0b3887a67",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=24ed6739b699f329c2c45aedee5f8c7d2f54e493",
      "patch": "@@ -1,3 +1,13 @@\n+2020-03-02  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* remote.c (remote_target::remote_parse_stop_reply): Don't use the\n+\tgeneral_thread if the stop reply is missing a thread-id.\n+\t(remote_target::process_stop_reply): Use the first non-exited\n+\tthread if the target didn't pass a thread-id.\n+\t* infrun.c (do_target_wait): Move call to\n+\tswitch_to_inferior_no_thread to ....\n+\t(do_target_wait_1): ... here.\n+\n 2020-02-29  Jon Turney  <jon.turney@dronecode.org.uk>\n \n \t* debuginfod-support.c: Include defs.h first."
    },
    {
      "sha": "0f2b9a541259c741cc315f39710e9b201ba6d22d",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 6,
      "deletions": 2,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=24ed6739b699f329c2c45aedee5f8c7d2f54e493",
      "patch": "@@ -3456,6 +3456,12 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n   ptid_t event_ptid;\n   struct thread_info *tp;\n \n+  /* We know that we are looking for an event in the target of inferior\n+     INF, but we don't know which thread the event might come from.  As\n+     such we want to make sure that INFERIOR_PTID is reset so that none of\n+     the wait code relies on it - doing so is always a mistake.  */\n+  switch_to_inferior_no_thread (inf);\n+\n   /* First check if there is a resumed thread with a wait status\n      pending.  */\n   if (ptid == minus_one_ptid || ptid.is_pid ())\n@@ -3651,8 +3657,6 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n \n   auto do_wait = [&] (inferior *inf)\n   {\n-    switch_to_inferior_no_thread (inf);\n-\n     ecs->ptid = do_target_wait_1 (inf, wait_ptid, &ecs->ws, options);\n     ecs->target = inf->process_target ();\n     return (ecs->ws.kind != TARGET_WAITKIND_IGNORE);"
    },
    {
      "sha": "9b73faf9a3459ef28dbc6789e552dc5abf54dae1",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 32,
      "deletions": 11,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=24ed6739b699f329c2c45aedee5f8c7d2f54e493",
      "patch": "@@ -7402,18 +7402,14 @@ Packet: '%s'\\n\"),\n \t\t     reported expedited registers.  */\n \t\t  if (event->ptid == null_ptid)\n \t\t    {\n+\t\t      /* If there is no thread-id information then leave\n+\t\t\t the event->ptid as null_ptid.  Later in\n+\t\t\t process_stop_reply we will pick a suitable\n+\t\t\t thread.  */\n \t\t      const char *thr = strstr (p1 + 1, \";thread:\");\n \t\t      if (thr != NULL)\n \t\t\tevent->ptid = read_ptid (thr + strlen (\";thread:\"),\n \t\t\t\t\t\t NULL);\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* Either the current thread hasn't changed,\n-\t\t\t     or the inferior is not multi-threaded.\n-\t\t\t     The event must be for the thread we last\n-\t\t\t     set as (or learned as being) current.  */\n-\t\t\t  event->ptid = event->rs->general_thread;\n-\t\t\t}\n \t\t    }\n \n \t\t  if (rsa == NULL)\n@@ -7668,10 +7664,35 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n   *status = stop_reply->ws;\n   ptid = stop_reply->ptid;\n \n-  /* If no thread/process was reported by the stub, assume the current\n-     inferior.  */\n+  /* If no thread/process was reported by the stub then use the first\n+     non-exited thread in the current target.  */\n   if (ptid == null_ptid)\n-    ptid = inferior_ptid;\n+    {\n+      for (thread_info *thr : all_non_exited_threads (this))\n+\t{\n+\t  if (ptid != null_ptid)\n+\t    {\n+\t      static bool warned = false;\n+\n+\t      if (!warned)\n+\t\t{\n+\t\t  /* If you are seeing this warning then the remote target\n+\t\t     has multiple threads and either sent an 'S' stop\n+\t\t     packet, or a 'T' stop packet without a thread-id.  In\n+\t\t     both of these cases GDB is unable to know which thread\n+\t\t     just stopped and is now having to guess.  The correct\n+\t\t     action is to fix the remote target to send the correct\n+\t\t     packet (a 'T' packet and include a thread-id).  */\n+\t\t  warning (_(\"multi-threaded target stopped without sending \"\n+\t\t\t     \"a thread-id, using first non-exited thread\"));\n+\t\t  warned = true;\n+\t\t}\n+\t      break;\n+\t    }\n+\t  ptid = thr->ptid;\n+\t}\n+      gdb_assert (ptid != null_ptid);\n+    }\n \n   if (status->kind != TARGET_WAITKIND_EXITED\n       && status->kind != TARGET_WAITKIND_SIGNALLED"
    },
    {
      "sha": "488a3280215d1301fff7fb96c9b2aa4f2a9954e1",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=24ed6739b699f329c2c45aedee5f8c7d2f54e493",
      "patch": "@@ -1,3 +1,8 @@\n+2020-03-02  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.server/stop-reply-no-thread.exp: Add test where T packet is\n+\tdisabled.\n+\n 2020-03-02  Pedro Alves  <palves@redhat.com>\n \t      Tom de Vries  <tdevries@suse.de>\n "
    },
    {
      "sha": "ffc1c27dcb4be85742b9eeb3ef46bedc58016ad4",
      "filename": "gdb/testsuite/gdb.server/stop-reply-no-thread.exp",
      "status": "modified",
      "additions": 48,
      "deletions": 32,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/testsuite/gdb.server/stop-reply-no-thread.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24ed6739b699f329c2c45aedee5f8c7d2f54e493/gdb/testsuite/gdb.server/stop-reply-no-thread.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.server/stop-reply-no-thread.exp?ref=24ed6739b699f329c2c45aedee5f8c7d2f54e493",
      "patch": "@@ -32,43 +32,59 @@ if [prepare_for_testing \"failed to prepare\" $testfile $srcfile] {\n     return -1\n }\n \n-# Make sure we're disconnected, in case we're testing with an\n-# extended-remote board, therefore already connected.\n-gdb_test \"disconnect\" \".*\"\n+# Run the tests with different features of GDBserver disabled.\n+proc run_test { disable_feature } {\n+    global binfile gdb_prompt decimal\n \n-# Start GDBserver, with \";thread:NNN\" in T stop replies disabled,\n-# emulating old gdbservers when debugging single-threaded programs.\n-set res [gdbserver_start \"--disable-packet=Tthread\" $binfile]\n-set gdbserver_protocol [lindex $res 0]\n-set gdbserver_gdbport [lindex $res 1]\n+    clean_restart ${binfile}\n \n-# Disable XML-based thread listing, and multi-process extensions.\n-gdb_test_no_output \"set remote threads-packet off\"\n-gdb_test_no_output \"set remote multiprocess-feature-packet off\"\n+    # Make sure we're disconnected, in case we're testing with an\n+    # extended-remote board, therefore already connected.\n+    gdb_test \"disconnect\" \".*\"\n \n-set res [gdb_target_cmd $gdbserver_protocol $gdbserver_gdbport]\n-if ![gdb_assert {$res == 0} \"connect\"] {\n-    return\n-}\n+    set res [gdbserver_start \"--disable-packet=${disable_feature}\" $binfile]\n+    set gdbserver_protocol [lindex $res 0]\n+    set gdbserver_gdbport [lindex $res 1]\n \n-# There should be only one thread listed.\n-set test \"info threads\"\n-gdb_test_multiple $test $test {\n-    -re \"2 Thread.*$gdb_prompt $\" {\n-\tfail $test\n-    }\n-    -re \"has terminated.*$gdb_prompt $\" {\n-\tfail $test\n+    # Disable XML-based thread listing, and multi-process extensions.\n+    gdb_test_no_output \"set remote threads-packet off\"\n+    gdb_test_no_output \"set remote multiprocess-feature-packet off\"\n+\n+    set res [gdb_target_cmd $gdbserver_protocol $gdbserver_gdbport]\n+    if ![gdb_assert {$res == 0} \"connect\"] {\n+\treturn\n     }\n-    -re \"\\\\\\* 1\\[\\t \\]*Thread\\[^\\r\\n\\]*\\r\\n$gdb_prompt $\" {\n-\tpass $test\n+\n+    # There should be only one thread listed.\n+    set test \"info threads\"\n+    gdb_test_multiple $test $test {\n+\t-re \"2 Thread.*$gdb_prompt $\" {\n+\t    fail $test\n+\t}\n+\t-re \"has terminated.*$gdb_prompt $\" {\n+\t    fail $test\n+\t}\n+\t-re \"\\\\\\* 1\\[\\t \\]*Thread\\[^\\r\\n\\]*\\r\\n$gdb_prompt $\" {\n+\t    pass $test\n+\t}\n     }\n-}\n \n-gdb_breakpoint \"main\"\n+    gdb_breakpoint \"main\"\n \n-# Bad GDB behaved like this:\n-#  (gdb) c\n-#  Cannot execute this command without a live selected thread.\n-#  (gdb)\n-gdb_test \"c\" \"Breakpoint $decimal, main.*\" \"continue to main\"\n+    # Bad GDB behaved like this:\n+    #  (gdb) c\n+    #  Cannot execute this command without a live selected thread.\n+    #  (gdb)\n+    gdb_test \"c\" \"Breakpoint $decimal, main.*\" \"continue to main\"\n+}\n+\n+# Disable different features within gdbserver:\n+#\n+# Tthread: Start GDBserver, with \";thread:NNN\" in T stop replies disabled,\n+#          emulating old gdbservers when debugging single-threaded programs.\n+#\n+# T: Start GDBserver with the entire 'T' stop reply packet disabled,\n+#    GDBserver will instead send the 'S' stop reply.\n+foreach_with_prefix to_disable { Tthread T } {\n+    run_test $to_disable\n+}"
    }
  ]
}