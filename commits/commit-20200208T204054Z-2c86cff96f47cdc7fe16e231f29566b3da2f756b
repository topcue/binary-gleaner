{
  "sha": "2c86cff96f47cdc7fe16e231f29566b3da2f756b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmM4NmNmZjk2ZjQ3Y2RjN2ZlMTZlMjMxZjI5NTY2YjNkYTJmNzU2Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "message": "Create dwarf2/section.[ch]\n\nThis moves some section-handling code from dwarf2read.c into new\nfiles, dwarf2/section.[ch].\n\ngdb/ChangeLog\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2read.h (struct dwarf2_section_info, dwarf2_read_section):\n\tMove to dwarf2/section.h.\n\t* dwarf2read.c (get_containing_section, get_section_bfd_owner)\n\t(get_section_bfd_section, get_section_name)\n\t(get_section_file_name, get_section_id, get_section_flags)\n\t(dwarf2_section_empty_p, dwarf2_read_section): Moe to\n\tdwarf2/section.c.\n\t* dwarf2/section.h: New file.\n\t* dwarf2/section.c: New file, from dwarf2read.c.\n\t* Makefile.in (COMMON_SFILES): Add dwarf2/section.c.\n\nChange-Id: I9f8498094cf99d9521e9481622ce8adbd453daf4",
    "tree": {
      "sha": "80e4735af6f2854022c346154fff18a13f5d01be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/80e4735af6f2854022c346154fff18a13f5d01be"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2c86cff96f47cdc7fe16e231f29566b3da2f756b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c86cff96f47cdc7fe16e231f29566b3da2f756b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2c86cff96f47cdc7fe16e231f29566b3da2f756b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c86cff96f47cdc7fe16e231f29566b3da2f756b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f4382c45a4de31b654c063d1ae70d932bde1c2f2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4382c45a4de31b654c063d1ae70d932bde1c2f2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f4382c45a4de31b654c063d1ae70d932bde1c2f2"
    }
  ],
  "stats": {
    "total": 538,
    "additions": 315,
    "deletions": 223
  },
  "files": [
    {
      "sha": "82dce8907767227c838f2d48ada2dda753a83f9a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -1,3 +1,16 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2read.h (struct dwarf2_section_info, dwarf2_read_section):\n+\tMove to dwarf2/section.h.\n+\t* dwarf2read.c (get_containing_section, get_section_bfd_owner)\n+\t(get_section_bfd_section, get_section_name)\n+\t(get_section_file_name, get_section_id, get_section_flags)\n+\t(dwarf2_section_empty_p, dwarf2_read_section): Moe to\n+\tdwarf2/section.c.\n+\t* dwarf2/section.h: New file.\n+\t* dwarf2/section.c: New file, from dwarf2read.c.\n+\t* Makefile.in (COMMON_SFILES): Add dwarf2/section.c.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2read.h (read_unsigned_leb128): Don't declare."
    },
    {
      "sha": "f560f1bd136af7c8ba6ae36251a8557f894b6f3b",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -1003,6 +1003,7 @@ COMMON_SFILES = \\\n \tdwarf2loc.c \\\n \tdwarf2read.c \\\n \tdwarf2/leb.c \\\n+\tdwarf2/section.c \\\n \teval.c \\\n \tevent-loop.c \\\n \tevent-top.c \\"
    },
    {
      "sha": "618ab9adf1215206a9913fc25d87fe8a9b1372c4",
      "filename": "gdb/dwarf2/section.c",
      "status": "added",
      "additions": 179,
      "deletions": 0,
      "changes": 179,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2/section.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2/section.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/section.c?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -0,0 +1,179 @@\n+/* DWARF 2 low-level section code\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"dwarf2/section.h\"\n+#include \"gdb_bfd.h\"\n+#include \"objfiles.h\"\n+\n+struct dwarf2_section_info *\n+get_containing_section (const struct dwarf2_section_info *section)\n+{\n+  gdb_assert (section->is_virtual);\n+  return section->s.containing_section;\n+}\n+\n+struct bfd *\n+get_section_bfd_owner (const struct dwarf2_section_info *section)\n+{\n+  if (section->is_virtual)\n+    {\n+      section = get_containing_section (section);\n+      gdb_assert (!section->is_virtual);\n+    }\n+  return section->s.section->owner;\n+}\n+\n+asection *\n+get_section_bfd_section (const struct dwarf2_section_info *section)\n+{\n+  if (section->is_virtual)\n+    {\n+      section = get_containing_section (section);\n+      gdb_assert (!section->is_virtual);\n+    }\n+  return section->s.section;\n+}\n+\n+const char *\n+get_section_name (const struct dwarf2_section_info *section)\n+{\n+  asection *sectp = get_section_bfd_section (section);\n+\n+  gdb_assert (sectp != NULL);\n+  return bfd_section_name (sectp);\n+}\n+\n+const char *\n+get_section_file_name (const struct dwarf2_section_info *section)\n+{\n+  bfd *abfd = get_section_bfd_owner (section);\n+\n+  return bfd_get_filename (abfd);\n+}\n+\n+int\n+get_section_id (const struct dwarf2_section_info *section)\n+{\n+  asection *sectp = get_section_bfd_section (section);\n+\n+  if (sectp == NULL)\n+    return 0;\n+  return sectp->id;\n+}\n+\n+int\n+get_section_flags (const struct dwarf2_section_info *section)\n+{\n+  asection *sectp = get_section_bfd_section (section);\n+\n+  gdb_assert (sectp != NULL);\n+  return bfd_section_flags (sectp);\n+}\n+\n+int\n+dwarf2_section_empty_p (const struct dwarf2_section_info *section)\n+{\n+  if (section->is_virtual)\n+    return section->size == 0;\n+  return section->s.section == NULL || section->size == 0;\n+}\n+\n+void\n+dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info)\n+{\n+  asection *sectp;\n+  bfd *abfd;\n+  gdb_byte *buf, *retbuf;\n+\n+  if (info->readin)\n+    return;\n+  info->buffer = NULL;\n+  info->readin = true;\n+\n+  if (dwarf2_section_empty_p (info))\n+    return;\n+\n+  sectp = get_section_bfd_section (info);\n+\n+  /* If this is a virtual section we need to read in the real one first.  */\n+  if (info->is_virtual)\n+    {\n+      struct dwarf2_section_info *containing_section =\n+\tget_containing_section (info);\n+\n+      gdb_assert (sectp != NULL);\n+      if ((sectp->flags & SEC_RELOC) != 0)\n+\t{\n+\t  error (_(\"Dwarf Error: DWP format V2 with relocations is not\"\n+\t\t   \" supported in section %s [in module %s]\"),\n+\t\t get_section_name (info), get_section_file_name (info));\n+\t}\n+      dwarf2_read_section (objfile, containing_section);\n+      /* Other code should have already caught virtual sections that don't\n+\t fit.  */\n+      gdb_assert (info->virtual_offset + info->size\n+\t\t  <= containing_section->size);\n+      /* If the real section is empty or there was a problem reading the\n+\t section we shouldn't get here.  */\n+      gdb_assert (containing_section->buffer != NULL);\n+      info->buffer = containing_section->buffer + info->virtual_offset;\n+      return;\n+    }\n+\n+  /* If the section has relocations, we must read it ourselves.\n+     Otherwise we attach it to the BFD.  */\n+  if ((sectp->flags & SEC_RELOC) == 0)\n+    {\n+      info->buffer = gdb_bfd_map_section (sectp, &info->size);\n+      return;\n+    }\n+\n+  buf = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, info->size);\n+  info->buffer = buf;\n+\n+  /* When debugging .o files, we may need to apply relocations; see\n+     http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .\n+     We never compress sections in .o files, so we only need to\n+     try this when the section is not compressed.  */\n+  retbuf = symfile_relocate_debug_section (objfile, sectp, buf);\n+  if (retbuf != NULL)\n+    {\n+      info->buffer = retbuf;\n+      return;\n+    }\n+\n+  abfd = get_section_bfd_owner (info);\n+  gdb_assert (abfd != NULL);\n+\n+  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0\n+      || bfd_bread (buf, info->size, abfd) != info->size)\n+    {\n+      error (_(\"Dwarf Error: Can't read DWARF data\"\n+\t       \" in section %s [in module %s]\"),\n+\t     bfd_section_name (sectp), bfd_get_filename (abfd));\n+    }\n+}"
    },
    {
      "sha": "a1acc5f9e6653e3972378df5699a52676c518b3f",
      "filename": "gdb/dwarf2/section.h",
      "status": "added",
      "additions": 121,
      "deletions": 0,
      "changes": 121,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2/section.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2/section.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/section.h?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -0,0 +1,121 @@\n+/* DWARF 2 low-level section code\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_SECTION_H\n+#define GDB_DWARF2_SECTION_H\n+\n+/* A descriptor for dwarf sections.\n+\n+   S.ASECTION, SIZE are typically initialized when the objfile is first\n+   scanned.  BUFFER, READIN are filled in later when the section is read.\n+   If the section contained compressed data then SIZE is updated to record\n+   the uncompressed size of the section.\n+\n+   DWP file format V2 introduces a wrinkle that is easiest to handle by\n+   creating the concept of virtual sections contained within a real section.\n+   In DWP V2 the sections of the input DWO files are concatenated together\n+   into one section, but section offsets are kept relative to the original\n+   input section.\n+   If this is a virtual dwp-v2 section, S.CONTAINING_SECTION is a backlink to\n+   the real section this \"virtual\" section is contained in, and BUFFER,SIZE\n+   describe the virtual section.  */\n+\n+struct dwarf2_section_info\n+{\n+  union\n+  {\n+    /* If this is a real section, the bfd section.  */\n+    asection *section;\n+    /* If this is a virtual section, pointer to the containing (\"real\")\n+       section.  */\n+    struct dwarf2_section_info *containing_section;\n+  } s;\n+  /* Pointer to section data, only valid if readin.  */\n+  const gdb_byte *buffer;\n+  /* The size of the section, real or virtual.  */\n+  bfd_size_type size;\n+  /* If this is a virtual section, the offset in the real section.\n+     Only valid if is_virtual.  */\n+  bfd_size_type virtual_offset;\n+  /* True if we have tried to read this section.  */\n+  bool readin;\n+  /* True if this is a virtual section, False otherwise.\n+     This specifies which of s.section and s.containing_section to use.  */\n+  bool is_virtual;\n+};\n+\n+/* Read the contents of the section INFO.\n+   OBJFILE is the main object file, but not necessarily the file where\n+   the section comes from.  E.g., for DWO files the bfd of INFO is the bfd\n+   of the DWO file.\n+   If the section is compressed, uncompress it before returning.  */\n+\n+extern void dwarf2_read_section (struct objfile *objfile,\n+\t\t\t\t dwarf2_section_info *info);\n+\n+extern const char *get_section_name (const struct dwarf2_section_info *);\n+\n+extern const char *get_section_file_name (const struct dwarf2_section_info *);\n+\n+/* Return the containing section of virtual section SECTION.  */\n+\n+extern struct dwarf2_section_info *get_containing_section\n+  (const struct dwarf2_section_info *section);\n+\n+/* Return the bfd owner of SECTION.  */\n+\n+extern struct bfd *get_section_bfd_owner\n+  (const struct dwarf2_section_info *section);\n+\n+/* Return the bfd section of SECTION.\n+   Returns NULL if the section is not present.  */\n+\n+extern asection *get_section_bfd_section\n+  (const struct dwarf2_section_info *section);\n+\n+/* Return the name of SECTION.  */\n+\n+extern const char *get_section_name\n+  (const struct dwarf2_section_info *section);\n+\n+/* Return the name of the file SECTION is in.  */\n+\n+extern const char *get_section_file_name\n+  (const struct dwarf2_section_info *section);\n+\n+/* Return the id of SECTION.\n+   Returns 0 if SECTION doesn't exist.  */\n+\n+extern int get_section_id (const struct dwarf2_section_info *section);\n+\n+/* Return the flags of SECTION.\n+   SECTION (or containing section if this is a virtual section) must exist.  */\n+\n+extern int get_section_flags (const struct dwarf2_section_info *section);\n+\n+extern int dwarf2_section_empty_p (const struct dwarf2_section_info *section);\n+\n+#endif /* GDB_DWARF2_SECTION_H */"
    },
    {
      "sha": "760e129073164a895d14813a06f73c1f08ced899",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 0,
      "deletions": 175,
      "changes": 175,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -1474,10 +1474,6 @@ show_dwarf_max_cache_age (struct ui_file *file, int from_tty,\n \f\n /* local function prototypes */\n \n-static const char *get_section_name (const struct dwarf2_section_info *);\n-\n-static const char *get_section_file_name (const struct dwarf2_section_info *);\n-\n static void dwarf2_find_base_address (struct die_info *die,\n \t\t\t\t      struct dwarf2_cu *cu);\n \n@@ -2264,88 +2260,6 @@ dwarf2_has_info (struct objfile *objfile,\n \t  && dwarf2_per_objfile->abbrev.s.section != NULL);\n }\n \n-/* Return the containing section of virtual section SECTION.  */\n-\n-static struct dwarf2_section_info *\n-get_containing_section (const struct dwarf2_section_info *section)\n-{\n-  gdb_assert (section->is_virtual);\n-  return section->s.containing_section;\n-}\n-\n-/* Return the bfd owner of SECTION.  */\n-\n-static struct bfd *\n-get_section_bfd_owner (const struct dwarf2_section_info *section)\n-{\n-  if (section->is_virtual)\n-    {\n-      section = get_containing_section (section);\n-      gdb_assert (!section->is_virtual);\n-    }\n-  return section->s.section->owner;\n-}\n-\n-/* Return the bfd section of SECTION.\n-   Returns NULL if the section is not present.  */\n-\n-static asection *\n-get_section_bfd_section (const struct dwarf2_section_info *section)\n-{\n-  if (section->is_virtual)\n-    {\n-      section = get_containing_section (section);\n-      gdb_assert (!section->is_virtual);\n-    }\n-  return section->s.section;\n-}\n-\n-/* Return the name of SECTION.  */\n-\n-static const char *\n-get_section_name (const struct dwarf2_section_info *section)\n-{\n-  asection *sectp = get_section_bfd_section (section);\n-\n-  gdb_assert (sectp != NULL);\n-  return bfd_section_name (sectp);\n-}\n-\n-/* Return the name of the file SECTION is in.  */\n-\n-static const char *\n-get_section_file_name (const struct dwarf2_section_info *section)\n-{\n-  bfd *abfd = get_section_bfd_owner (section);\n-\n-  return bfd_get_filename (abfd);\n-}\n-\n-/* Return the id of SECTION.\n-   Returns 0 if SECTION doesn't exist.  */\n-\n-static int\n-get_section_id (const struct dwarf2_section_info *section)\n-{\n-  asection *sectp = get_section_bfd_section (section);\n-\n-  if (sectp == NULL)\n-    return 0;\n-  return sectp->id;\n-}\n-\n-/* Return the flags of SECTION.\n-   SECTION (or containing section if this is a virtual section) must exist.  */\n-\n-static int\n-get_section_flags (const struct dwarf2_section_info *section)\n-{\n-  asection *sectp = get_section_bfd_section (section);\n-\n-  gdb_assert (sectp != NULL);\n-  return bfd_section_flags (sectp);\n-}\n-\n /* When loading sections, we look either for uncompressed section or for\n    compressed section names.  */\n \n@@ -2488,95 +2402,6 @@ dwarf2_per_objfile::locate_sections (bfd *abfd, asection *sectp,\n     this->has_section_at_zero = true;\n }\n \n-/* A helper function that decides whether a section is empty,\n-   or not present.  */\n-\n-static int\n-dwarf2_section_empty_p (const struct dwarf2_section_info *section)\n-{\n-  if (section->is_virtual)\n-    return section->size == 0;\n-  return section->s.section == NULL || section->size == 0;\n-}\n-\n-/* See dwarf2read.h.  */\n-\n-void\n-dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info)\n-{\n-  asection *sectp;\n-  bfd *abfd;\n-  gdb_byte *buf, *retbuf;\n-\n-  if (info->readin)\n-    return;\n-  info->buffer = NULL;\n-  info->readin = true;\n-\n-  if (dwarf2_section_empty_p (info))\n-    return;\n-\n-  sectp = get_section_bfd_section (info);\n-\n-  /* If this is a virtual section we need to read in the real one first.  */\n-  if (info->is_virtual)\n-    {\n-      struct dwarf2_section_info *containing_section =\n-\tget_containing_section (info);\n-\n-      gdb_assert (sectp != NULL);\n-      if ((sectp->flags & SEC_RELOC) != 0)\n-\t{\n-\t  error (_(\"Dwarf Error: DWP format V2 with relocations is not\"\n-\t\t   \" supported in section %s [in module %s]\"),\n-\t\t get_section_name (info), get_section_file_name (info));\n-\t}\n-      dwarf2_read_section (objfile, containing_section);\n-      /* Other code should have already caught virtual sections that don't\n-\t fit.  */\n-      gdb_assert (info->virtual_offset + info->size\n-\t\t  <= containing_section->size);\n-      /* If the real section is empty or there was a problem reading the\n-\t section we shouldn't get here.  */\n-      gdb_assert (containing_section->buffer != NULL);\n-      info->buffer = containing_section->buffer + info->virtual_offset;\n-      return;\n-    }\n-\n-  /* If the section has relocations, we must read it ourselves.\n-     Otherwise we attach it to the BFD.  */\n-  if ((sectp->flags & SEC_RELOC) == 0)\n-    {\n-      info->buffer = gdb_bfd_map_section (sectp, &info->size);\n-      return;\n-    }\n-\n-  buf = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, info->size);\n-  info->buffer = buf;\n-\n-  /* When debugging .o files, we may need to apply relocations; see\n-     http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .\n-     We never compress sections in .o files, so we only need to\n-     try this when the section is not compressed.  */\n-  retbuf = symfile_relocate_debug_section (objfile, sectp, buf);\n-  if (retbuf != NULL)\n-    {\n-      info->buffer = retbuf;\n-      return;\n-    }\n-\n-  abfd = get_section_bfd_owner (info);\n-  gdb_assert (abfd != NULL);\n-\n-  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0\n-      || bfd_bread (buf, info->size, abfd) != info->size)\n-    {\n-      error (_(\"Dwarf Error: Can't read DWARF data\"\n-\t       \" in section %s [in module %s]\"),\n-\t     bfd_section_name (sectp), bfd_get_filename (abfd));\n-    }\n-}\n-\n /* A helper function that returns the size of a section in a safe way.\n    If you are positive that the section has been read before using the\n    size, then it is safe to refer to the dwarf2_section_info object's"
    },
    {
      "sha": "62a7600a7992c13a4951394005e3a1b477512e16",
      "filename": "gdb/dwarf2read.h",
      "status": "modified",
      "additions": 1,
      "deletions": 48,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c86cff96f47cdc7fe16e231f29566b3da2f756b/gdb/dwarf2read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.h?ref=2c86cff96f47cdc7fe16e231f29566b3da2f756b",
      "patch": "@@ -22,6 +22,7 @@\n \n #include <unordered_map>\n #include \"dwarf-index-cache.h\"\n+#include \"dwarf2/section.h\"\n #include \"filename-seen-cache.h\"\n #include \"gdb_obstack.h\"\n #include \"gdbsupport/hash_enum.h\"\n@@ -33,54 +34,6 @@ extern struct cmd_list_element *show_dwarf_cmdlist;\n \n extern bool dwarf_always_disassemble;\n \n-/* A descriptor for dwarf sections.\n-\n-   S.ASECTION, SIZE are typically initialized when the objfile is first\n-   scanned.  BUFFER, READIN are filled in later when the section is read.\n-   If the section contained compressed data then SIZE is updated to record\n-   the uncompressed size of the section.\n-\n-   DWP file format V2 introduces a wrinkle that is easiest to handle by\n-   creating the concept of virtual sections contained within a real section.\n-   In DWP V2 the sections of the input DWO files are concatenated together\n-   into one section, but section offsets are kept relative to the original\n-   input section.\n-   If this is a virtual dwp-v2 section, S.CONTAINING_SECTION is a backlink to\n-   the real section this \"virtual\" section is contained in, and BUFFER,SIZE\n-   describe the virtual section.  */\n-\n-struct dwarf2_section_info\n-{\n-  union\n-  {\n-    /* If this is a real section, the bfd section.  */\n-    asection *section;\n-    /* If this is a virtual section, pointer to the containing (\"real\")\n-       section.  */\n-    struct dwarf2_section_info *containing_section;\n-  } s;\n-  /* Pointer to section data, only valid if readin.  */\n-  const gdb_byte *buffer;\n-  /* The size of the section, real or virtual.  */\n-  bfd_size_type size;\n-  /* If this is a virtual section, the offset in the real section.\n-     Only valid if is_virtual.  */\n-  bfd_size_type virtual_offset;\n-  /* True if we have tried to read this section.  */\n-  bool readin;\n-  /* True if this is a virtual section, False otherwise.\n-     This specifies which of s.section and s.containing_section to use.  */\n-  bool is_virtual;\n-};\n-\n-/* Read the contents of the section INFO.\n-   OBJFILE is the main object file, but not necessarily the file where\n-   the section comes from.  E.g., for DWO files the bfd of INFO is the bfd\n-   of the DWO file.\n-   If the section is compressed, uncompress it before returning.  */\n-\n-void dwarf2_read_section (struct objfile *objfile, dwarf2_section_info *info);\n-\n struct tu_stats\n {\n   int nr_uniq_abbrev_tables;"
    }
  ]
}