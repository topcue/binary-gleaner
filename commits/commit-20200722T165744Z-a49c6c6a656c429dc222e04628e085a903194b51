{
  "sha": "a49c6c6a656c429dc222e04628e085a903194b51",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTQ5YzZjNmE2NTZjNDI5ZGMyMjJlMDQ2MjhlMDg1YTkwMzE5NGI1MQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-02T21:00:14Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:44Z"
    },
    "message": "libctf, hash: save per-item space when no key/item freeing function\n\nThe libctf dynhash hashtab abstraction supports per-hashtab arbitrary\nkey/item freeing functions -- but it also has a constant slot type that\nholds both key and value requested by the user, so it needs to use its\nown freeing function to free that -- and it has nowhere to store the\nfreeing functions the caller requested.\n\nSo it copies them into every hash item, bloating every slot, even though\nall items in a given hash table must have the same key and value freeing\nfunctions.\n\nSo point back to the owner using a back-pointer, but don't even spend\nspace in the item or the hashtab allocating those freeing functions\nunless necessary: if none are needed, we can simply arrange to not pass\nin ctf_dynhash_item_free as a del_f to hashtab_create_alloc, and none of\nthose fields will ever be accessed.\n\nThe only downside is that this makes the code sensitive to the order of\nfields in the ctf_helem_t and ctf_hashtab_t: but the deduplicator\nallocates so many hash tables that doing this alone cuts memory usage\nduring deduplication by about 10%.  (libiberty hashtab itself has a lot\nof per-hashtab bloat: in the future we might trim that down, or make a\ntrimmer version.)\n\nlibctf/\n\t* ctf-hash.c (ctf_helem_t) <key_free>: Remove.\n\t<value_free>: Likewise.\n\t<owner>: New.\n\t(ctf_dynhash_item_free): Indirect through the owner.\n\t(ctf_dynhash_create): Only pass in ctf_dynhash_item_free and\n\tallocate space for the key_free and value_free fields fields\n\tif necessary.\n\t(ctf_hashtab_insert): Likewise.  Fix OOM errno value.\n\t(ctf_dynhash_insert): Only access ctf_hashtab's key_free and\n\tvalue_free if they will exist.  Set the slot's owner, but only\n\tif it exists.\n\t(ctf_dynhash_remove): Adjust.",
    "tree": {
      "sha": "c2d5bb380ddfbf7745db6619f6aa69fa21a1a2e5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c2d5bb380ddfbf7745db6619f6aa69fa21a1a2e5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a49c6c6a656c429dc222e04628e085a903194b51",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a49c6c6a656c429dc222e04628e085a903194b51",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a49c6c6a656c429dc222e04628e085a903194b51",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a49c6c6a656c429dc222e04628e085a903194b51/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5ceee3dba3422bc8de49768c0c2d8f2608672fe7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ceee3dba3422bc8de49768c0c2d8f2608672fe7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5ceee3dba3422bc8de49768c0c2d8f2608672fe7"
    }
  ],
  "stats": {
    "total": 83,
    "additions": 62,
    "deletions": 21
  },
  "files": [
    {
      "sha": "27987f2784d009585d5162db4a4472db14daaf96",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a49c6c6a656c429dc222e04628e085a903194b51/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a49c6c6a656c429dc222e04628e085a903194b51/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=a49c6c6a656c429dc222e04628e085a903194b51",
      "patch": "@@ -1,3 +1,18 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-hash.c (ctf_helem_t) <key_free>: Remove.\n+\t<value_free>: Likewise.\n+\t<owner>: New.\n+\t(ctf_dynhash_item_free): Indirect through the owner.\n+\t(ctf_dynhash_create): Only pass in ctf_dynhash_item_free and\n+\tallocate space for the key_free and value_free fields fields\n+\tif necessary.\n+\t(ctf_hashtab_insert): Likewise.  Fix OOM errno value.\n+\t(ctf_dynhash_insert): Only access ctf_hashtab's key_free and\n+\tvalue_free if they will exist.  Set the slot's owner, but only\n+\tif it exists.\n+\t(ctf_dynhash_remove): Adjust.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-hash.c (ctf_hashtab_insert): Free the key passed in if"
    },
    {
      "sha": "caefd99c37f97068ee7a268691a1c809094b1229",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 47,
      "deletions": 21,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a49c6c6a656c429dc222e04628e085a903194b51/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a49c6c6a656c429dc222e04628e085a903194b51/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=a49c6c6a656c429dc222e04628e085a903194b51",
      "patch": "@@ -31,14 +31,19 @@\n    not support removal.  These can be implemented by the same underlying hashmap\n    if you wish.  */\n \n+/* The helem is used for general key/value mappings in both the ctf_hash and\n+   ctf_dynhash: the owner may not have space allocated for it, and will be\n+   garbage (not NULL!) in that case.  */\n+\n typedef struct ctf_helem\n {\n   void *key;\t\t\t /* Either a pointer, or a coerced ctf_id_t.  */\n   void *value;\t\t\t /* The value (possibly a coerced int).  */\n-  ctf_hash_free_fun key_free;\n-  ctf_hash_free_fun value_free;\n+  ctf_dynhash_t *owner;          /* The hash that owns us.  */\n } ctf_helem_t;\n \n+/* Equally, the key_free and value_free may not exist.  */\n+\n struct ctf_dynhash\n {\n   struct htab *htab;\n@@ -106,17 +111,17 @@ ctf_hash_eq_type_mapping_key (const void *a, const void *b)\n \n /* The dynhash, used for hashes whose size is not known at creation time. */\n \n-/* Free a single ctf_helem.  */\n+/* Free a single ctf_helem with arbitrary key/value functions.  */\n \n static void\n ctf_dynhash_item_free (void *item)\n {\n   ctf_helem_t *helem = item;\n \n-  if (helem->key_free && helem->key)\n-    helem->key_free (helem->key);\n-  if (helem->value_free && helem->value)\n-    helem->value_free (helem->value);\n+  if (helem->owner->key_free && helem->key)\n+    helem->owner->key_free (helem->key);\n+  if (helem->owner->value_free && helem->value)\n+    helem->owner->value_free (helem->value);\n   free (helem);\n }\n \n@@ -125,21 +130,31 @@ ctf_dynhash_create (ctf_hash_fun hash_fun, ctf_hash_eq_fun eq_fun,\n                     ctf_hash_free_fun key_free, ctf_hash_free_fun value_free)\n {\n   ctf_dynhash_t *dynhash;\n+  htab_del del = ctf_dynhash_item_free;\n \n-  dynhash = malloc (sizeof (ctf_dynhash_t));\n+  if (key_free || value_free)\n+    dynhash = malloc (sizeof (ctf_dynhash_t));\n+  else\n+    dynhash = malloc (offsetof (ctf_dynhash_t, key_free));\n   if (!dynhash)\n     return NULL;\n \n-  /* 7 is arbitrary and untested for now..  */\n+  if (key_free == NULL && value_free == NULL)\n+    del = free;\n+\n+  /* 7 is arbitrary and untested for now.  */\n   if ((dynhash->htab = htab_create_alloc (7, (htab_hash) hash_fun, eq_fun,\n-                                          ctf_dynhash_item_free, xcalloc, free)) == NULL)\n+\t\t\t\t\t  del, xcalloc, free)) == NULL)\n     {\n       free (dynhash);\n       return NULL;\n     }\n \n-  dynhash->key_free = key_free;\n-  dynhash->value_free = value_free;\n+  if (key_free || value_free)\n+    {\n+      dynhash->key_free = key_free;\n+      dynhash->value_free = value_free;\n+    }\n \n   return dynhash;\n }\n@@ -162,13 +177,18 @@ ctf_hashtab_insert (struct htab *htab, void *key, void *value,\n \n   if (!slot)\n     {\n-      errno = -ENOMEM;\n+      errno = ENOMEM;\n       return NULL;\n     }\n \n   if (!*slot)\n     {\n-      *slot = malloc (sizeof (ctf_helem_t));\n+      /* Only spend space on the owner if we're going to use it: if there is a\n+\t key or value freeing function.  */\n+      if (key_free || value_free)\n+\t*slot = malloc (sizeof (ctf_helem_t));\n+      else\n+\t*slot = malloc (offsetof (ctf_helem_t, owner));\n       if (!*slot)\n \treturn NULL;\n       (*slot)->key = key;\n@@ -188,27 +208,33 @@ int\n ctf_dynhash_insert (ctf_dynhash_t *hp, void *key, void *value)\n {\n   ctf_helem_t *slot;\n+  ctf_hash_free_fun key_free = NULL, value_free = NULL;\n \n+  if (hp->htab->del_f == ctf_dynhash_item_free)\n+    {\n+      key_free = hp->key_free;\n+      value_free = hp->value_free;\n+    }\n   slot = ctf_hashtab_insert (hp->htab, key, value,\n-\t\t\t     hp->key_free, hp->value_free);\n+\t\t\t     key_free, value_free);\n \n   if (!slot)\n     return errno;\n \n-  /* We need to keep the key_free and value_free around in each item because the\n-     del function has no visibility into the hash as a whole, only into the\n-     individual items.  */\n+  /* Keep track of the owner, so that the del function can get at the key_free\n+     and value_free functions.  Only do this if one of those functions is set:\n+     if not, the owner is not even present in the helem.  */\n \n-  slot->key_free = hp->key_free;\n-  slot->value_free = hp->value_free;\n+  if (key_free || value_free)\n+    slot->owner = hp;\n \n   return 0;\n }\n \n void\n ctf_dynhash_remove (ctf_dynhash_t *hp, const void *key)\n {\n-  ctf_helem_t hep = { (void *) key, NULL, NULL, NULL };\n+  ctf_helem_t hep = { (void *) key, NULL, NULL };\n   htab_remove_elt (hp->htab, &hep);\n }\n "
    }
  ]
}