{
  "sha": "1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWNiN2Q4YjFhZmM3YzcxY2ZhY2ZlMDE3ZTA2OTJjOTA2NGJmOTgxOA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-18T23:40:32Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-19T01:52:32Z"
    },
    "message": "readelf leak in process_archive\n\n\t* readelf.c (process_archive): Always return via path freeing\n\tmemory.  Formatting.",
    "tree": {
      "sha": "ad842a547e6b525ca7493db7ac3c1cdd01519b97",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ad842a547e6b525ca7493db7ac3c1cdd01519b97"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b966f55ffa570a05081b2030577b2158e8116c5a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b966f55ffa570a05081b2030577b2158e8116c5a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b966f55ffa570a05081b2030577b2158e8116c5a"
    }
  ],
  "stats": {
    "total": 171,
    "additions": 95,
    "deletions": 76
  },
  "files": [
    {
      "sha": "e52a14f836069d32a35020d933e833b7e990ace1",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
      "patch": "@@ -1,3 +1,8 @@\n+2020-03-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* readelf.c (process_archive): Always return via path freeing\n+\tmemory.  Formatting.\n+\n 2020-03-19  Alan Modra  <amodra@gmail.com>\n \n \t* readelf.c (process_netbsd_elf_note): Validate descsz before"
    },
    {
      "sha": "f76b9f6d8e6baa98d5888893c18e912093af4b8c",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 90,
      "deletions": 76,
      "changes": 166,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1cb7d8b1afc7c71cfacfe017e0692c9064bf9818/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=1cb7d8b1afc7c71cfacfe017e0692c9064bf9818",
      "patch": "@@ -20256,49 +20256,58 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n   if (do_archive_index)\n     {\n       if (arch.sym_table == NULL)\n-\terror (_(\"%s: unable to dump the index as none was found\\n\"), filedata->file_name);\n+\terror (_(\"%s: unable to dump the index as none was found\\n\"),\n+\t       filedata->file_name);\n       else\n \t{\n \t  unsigned long i, l;\n \t  unsigned long current_pos;\n \n-\t  printf (_(\"Index of archive %s: (%lu entries, 0x%lx bytes in the symbol table)\\n\"),\n-\t\t  filedata->file_name, (unsigned long) arch.index_num, arch.sym_size);\n+\t  printf (_(\"Index of archive %s: (%lu entries, 0x%lx bytes \"\n+\t\t    \"in the symbol table)\\n\"),\n+\t\t  filedata->file_name, (unsigned long) arch.index_num,\n+\t\t  arch.sym_size);\n \n \t  current_pos = ftell (filedata->handle);\n \n \t  for (i = l = 0; i < arch.index_num; i++)\n \t    {\n-\t      if ((i == 0) || ((i > 0) && (arch.index_array[i] != arch.index_array[i - 1])))\n-\t        {\n-\t          char * member_name;\n-\n-\t\t  member_name = get_archive_member_name_at (&arch, arch.index_array[i], &nested_arch);\n+\t      if (i == 0\n+\t\t  || (i > 0 && arch.index_array[i] != arch.index_array[i - 1]))\n+\t\t{\n+\t\t  char * member_name\n+\t\t    = get_archive_member_name_at (&arch, arch.index_array[i],\n+\t\t\t\t\t\t  &nested_arch);\n \n-                  if (member_name != NULL)\n-                    {\n-\t              char * qualified_name = make_qualified_name (&arch, &nested_arch, member_name);\n+\t\t  if (member_name != NULL)\n+\t\t    {\n+\t\t      char * qualified_name\n+\t\t\t= make_qualified_name (&arch, &nested_arch,\n+\t\t\t\t\t       member_name);\n \n-                      if (qualified_name != NULL)\n-                        {\n-\t\t          printf (_(\"Contents of binary %s at offset \"), qualified_name);\n+\t\t      if (qualified_name != NULL)\n+\t\t\t{\n+\t\t\t  printf (_(\"Contents of binary %s at offset \"),\n+\t\t\t\t  qualified_name);\n \t\t\t  (void) print_vma (arch.index_array[i], PREFIX_HEX);\n \t\t\t  putchar ('\\n');\n-\t\t          free (qualified_name);\n-\t\t        }\n+\t\t\t  free (qualified_name);\n+\t\t\t}\n \t\t      free (member_name);\n \t\t    }\n \t\t}\n \n \t      if (l >= arch.sym_size)\n \t\t{\n-\t\t  error (_(\"%s: end of the symbol table reached before the end of the index\\n\"),\n+\t\t  error (_(\"%s: end of the symbol table reached \"\n+\t\t\t   \"before the end of the index\\n\"),\n \t\t\t filedata->file_name);\n \t\t  ret = FALSE;\n \t\t  break;\n \t\t}\n \t      /* PR 17531: file: 0b6630b2.  */\n-\t      printf (\"\\t%.*s\\n\", (int) (arch.sym_size - l), arch.sym_table + l);\n+\t      printf (\"\\t%.*s\\n\",\n+\t\t      (int) (arch.sym_size - l), arch.sym_table + l);\n \t      l += strnlen (arch.sym_table + l, arch.sym_size - l) + 1;\n \t    }\n \n@@ -20322,7 +20331,8 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \n \t  if (fseek (filedata->handle, current_pos, SEEK_SET) != 0)\n \t    {\n-\t      error (_(\"%s: failed to seek back to start of object files in the archive\\n\"),\n+\t      error (_(\"%s: failed to seek back to start of object files \"\n+\t\t       \"in the archive\\n\"),\n \t\t     filedata->file_name);\n \t      ret = FALSE;\n \t      goto out;\n@@ -20347,34 +20357,37 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \n       /* Read the next archive header.  */\n       if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)\n-        {\n-          error (_(\"%s: failed to seek to next archive header\\n\"), arch.file_name);\n-          return FALSE;\n-        }\n+\t{\n+\t  error (_(\"%s: failed to seek to next archive header\\n\"),\n+\t\t arch.file_name);\n+\t  ret = FALSE;\n+\t  break;\n+\t}\n       got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);\n       if (got != sizeof arch.arhdr)\n-        {\n-          if (got == 0)\n+\t{\n+\t  if (got == 0)\n \t    break;\n \t  /* PR 24049 - we cannot use filedata->file_name as this will\n \t     have already been freed.  */\n \t  error (_(\"%s: failed to read archive header\\n\"), arch.file_name);\n \n-          ret = FALSE;\n-          break;\n-        }\n+\t  ret = FALSE;\n+\t  break;\n+\t}\n       if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)\n-        {\n-          error (_(\"%s: did not find a valid archive header\\n\"), arch.file_name);\n-          ret = FALSE;\n-          break;\n-        }\n+\t{\n+\t  error (_(\"%s: did not find a valid archive header\\n\"),\n+\t\t arch.file_name);\n+\t  ret = FALSE;\n+\t  break;\n+\t}\n \n       arch.next_arhdr_offset += sizeof arch.arhdr;\n \n       archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);\n       if (archive_file_size & 01)\n-        ++archive_file_size;\n+\t++archive_file_size;\n \n       name = get_archive_member_name (&arch, &nested_arch);\n       if (name == NULL)\n@@ -20395,45 +20408,45 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t}\n \n       if (is_thin_archive && arch.nested_member_origin == 0)\n-        {\n-          /* This is a proxy for an external member of a thin archive.  */\n-          Filedata * member_filedata;\n-          char * member_file_name = adjust_relative_path\n+\t{\n+\t  /* This is a proxy for an external member of a thin archive.  */\n+\t  Filedata * member_filedata;\n+\t  char * member_file_name = adjust_relative_path\n \t    (filedata->file_name, name, namelen);\n \n \t  free (name);\n-          if (member_file_name == NULL)\n-            {\n+\t  if (member_file_name == NULL)\n+\t    {\n \t      free (qualified_name);\n-              ret = FALSE;\n-              break;\n-            }\n+\t      ret = FALSE;\n+\t      break;\n+\t    }\n \n-          member_filedata = open_file (member_file_name);\n-          if (member_filedata == NULL)\n-            {\n-              error (_(\"Input file '%s' is not readable.\\n\"), member_file_name);\n-              free (member_file_name);\n+\t  member_filedata = open_file (member_file_name);\n+\t  if (member_filedata == NULL)\n+\t    {\n+\t      error (_(\"Input file '%s' is not readable.\\n\"), member_file_name);\n+\t      free (member_file_name);\n \t      free (qualified_name);\n-              ret = FALSE;\n-              break;\n-            }\n+\t      ret = FALSE;\n+\t      break;\n+\t    }\n \n-          archive_file_offset = arch.nested_member_origin;\n+\t  archive_file_offset = arch.nested_member_origin;\n \t  member_filedata->file_name = qualified_name;\n \n-          if (! process_object (member_filedata))\n+\t  if (! process_object (member_filedata))\n \t    ret = FALSE;\n \n-          close_file (member_filedata);\n-          free (member_file_name);\n+\t  close_file (member_filedata);\n+\t  free (member_file_name);\n \t  free (qualified_name);\n-        }\n+\t}\n       else if (is_thin_archive)\n-        {\n-          Filedata thin_filedata;\n+\t{\n+\t  Filedata thin_filedata;\n \n-          memset (&thin_filedata, 0, sizeof (thin_filedata));\n+\t  memset (&thin_filedata, 0, sizeof (thin_filedata));\n \n \t  /* PR 15140: Allow for corrupt thin archives.  */\n \t  if (nested_arch.file == NULL)\n@@ -20447,35 +20460,36 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t    }\n \t  free (name);\n \n-          /* This is a proxy for a member of a nested archive.  */\n-          archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;\n+\t  /* This is a proxy for a member of a nested archive.  */\n+\t  archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;\n \n-          /* The nested archive file will have been opened and setup by\n-             get_archive_member_name.  */\n-          if (fseek (nested_arch.file, archive_file_offset, SEEK_SET) != 0)\n-            {\n-              error (_(\"%s: failed to seek to archive member.\\n\"), nested_arch.file_name);\n+\t  /* The nested archive file will have been opened and setup by\n+\t     get_archive_member_name.  */\n+\t  if (fseek (nested_arch.file, archive_file_offset, SEEK_SET) != 0)\n+\t    {\n+\t      error (_(\"%s: failed to seek to archive member.\\n\"),\n+\t\t     nested_arch.file_name);\n \t      free (qualified_name);\n-              ret = FALSE;\n-              break;\n-            }\n+\t      ret = FALSE;\n+\t      break;\n+\t    }\n \n \t  thin_filedata.handle = nested_arch.file;\n \t  thin_filedata.file_name = qualified_name;\n \n-          if (! process_object (& thin_filedata))\n+\t  if (! process_object (& thin_filedata))\n \t    ret = FALSE;\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  free (name);\n-          archive_file_offset = arch.next_arhdr_offset;\n-          arch.next_arhdr_offset += archive_file_size;\n+\t  archive_file_offset = arch.next_arhdr_offset;\n+\t  arch.next_arhdr_offset += archive_file_size;\n \n \t  filedata->file_name = qualified_name;\n-          if (! process_object (filedata))\n+\t  if (! process_object (filedata))\n \t    ret = FALSE;\n-        }\n+\t}\n \n       free (qualified_name);\n     }"
    }
  ]
}