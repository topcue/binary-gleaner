{
  "sha": "389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mzg5ZDAwYTVlNWIxZmE2ZmNkOWVkYTc0N2IxN2VmNzNmNThlYjY5Mw==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-29T10:02:50Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2021-03-29T10:02:50Z"
    },
    "message": "x86: derive opcode encoding space attribute from base opcode\n\nJust like is already done for VEX/XOP/EVEX encoded insns, record the\nencoding space information in the respective opcode modifier field. Do\nthis again without changing the source table, but rather by deriving the\nvalues from their existing source representation.",
    "tree": {
      "sha": "60328fd218e7998c30d91455df475d835272214e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/60328fd218e7998c30d91455df475d835272214e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "63b4cc53dc41c755f8b30d85edf29c153f76eba3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/63b4cc53dc41c755f8b30d85edf29c153f76eba3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/63b4cc53dc41c755f8b30d85edf29c153f76eba3"
    }
  ],
  "stats": {
    "total": 3535,
    "additions": 1814,
    "deletions": 1721
  },
  "files": [
    {
      "sha": "01ab2e8b8c36ce776eba77e3cf7b52f0afa63022",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
      "patch": "@@ -1,3 +1,26 @@\n+2021-03-29  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (optimize_encoding): Replace VEX-encoding\n+\tchecks by opcodespace ones.\n+\t(insert_lfence_before): Likewise.\n+\t(maybe_fused_with_jcc_p): Likewise.\n+\t(add_branch_padding_frag_p): Likewise.\n+\t(output_disp): Likewise.\n+\t(load_insn_p): Re-arrange checks to key applicable ones off of\n+\tan opcodespace check.\n+\t(md_assemble): Adjust opcode checks.\n+\t(check_byte_reg): Likewise.\n+\t(process_operands): Likewise.\n+\t(i386_index_check): Likewise.\n+\t(process_suffix): Likewise. New local variable is_movx. Adjust\n+\tmovsx/movzx and crc32 handling.\n+\t(output_insn): Adjust opcode checks. Drop no longer reachable\n+\tcase labels. Output legacy encoding prefixes in addition to the\n+\tbase_opcode byte(s). Rework counting of prefixes for extended\n+\topcode maps.\n+\t* config/tc-i386-intel.c (i386_intel_simplify_register): Adjust\n+\topcode checks.\n+\n 2021-03-29  Alan Modra  <amodra@gmail.com>\n \n \t* atof-generic.c (FALSE, TRUE): Don't define."
    },
    {
      "sha": "4c9f0b705203c52de632545b16d601b708e69012",
      "filename": "gas/config/tc-i386-intel.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/config/tc-i386-intel.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/config/tc-i386-intel.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386-intel.c?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
      "patch": "@@ -318,9 +318,11 @@ i386_intel_simplify_register (expressionS *e)\n \n       if (intel_state.in_scale\n \t  || (t->opcode_modifier.opcodeprefix == PREFIX_0XF3\n-\t      && t->base_opcode == 0x0f1b /* bndmk */)\n+\t      && t->opcode_modifier.opcodespace == SPACE_0F\n+\t      && t->base_opcode == 0x1b /* bndmk */)\n \t  || (t->opcode_modifier.opcodeprefix == PREFIX_NONE\n-\t      && (t->base_opcode & ~1) == 0x0f1a /* bnd{ld,st}x */)\n+\t      && t->opcode_modifier.opcodespace == SPACE_0F\n+\t      && (t->base_opcode & ~1) == 0x1a /* bnd{ld,st}x */)\n \t  || i386_regtab[reg_num].reg_type.bitfield.baseindex)\n \tintel_state.index = i386_regtab + reg_num;\n       else"
    },
    {
      "sha": "02106a2b3371aae75ecdff3f3c66f580ff875ce6",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 146,
      "deletions": 118,
      "changes": 264,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
      "patch": "@@ -4040,7 +4040,7 @@ optimize_encoding (void)\n   unsigned int j;\n \n   if (optimize_for_space\n-      && !is_any_vex_encoding (&i.tm)\n+      && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n       && i.reg_operands == 1\n       && i.imm_operands == 1\n       && !i.types[1].bitfield.byte\n@@ -4072,7 +4072,7 @@ optimize_encoding (void)\n \t}\n     }\n   else if (flag_code == CODE_64BIT\n-\t   && !is_any_vex_encoding (&i.tm)\n+\t   && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n \t   && ((i.types[1].bitfield.qword\n \t\t&& i.reg_operands == 1\n \t\t&& i.imm_operands == 1\n@@ -4138,7 +4138,7 @@ optimize_encoding (void)\n     }\n   else if (optimize > 1\n \t   && !optimize_for_space\n-\t   && !is_any_vex_encoding (&i.tm)\n+\t   && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n \t   && i.reg_operands == 2\n \t   && i.op[0].regs == i.op[1].regs\n \t   && ((i.tm.base_opcode & ~(Opcode_D | 1)) == 0x8\n@@ -4343,9 +4343,15 @@ load_insn_p (void)\n       if (i.tm.opcode_modifier.anysize)\n \treturn 0;\n \n-      /* pop, popf, popa.   */\n-      if (strcmp (i.tm.name, \"pop\") == 0\n-\t  || i.tm.base_opcode == 0x9d\n+      /* pop.   */\n+      if (strcmp (i.tm.name, \"pop\") == 0)\n+\treturn 1;\n+    }\n+\n+  if (i.tm.opcode_modifier.opcodespace == SPACE_BASE)\n+    {\n+      /* popf, popa.   */\n+      if (i.tm.base_opcode == 0x9d\n \t  || i.tm.base_opcode == 0x61)\n \treturn 1;\n \n@@ -4375,7 +4381,7 @@ load_insn_p (void)\n \t  && i.tm.extension_opcode == 2)\n \treturn 1;\n     }\n-  else\n+  else if (i.tm.opcode_modifier.opcodespace == SPACE_BASE)\n     {\n       /* test, not, neg, mul, imul, div, idiv.  */\n       if ((i.tm.base_opcode == 0xf6 || i.tm.base_opcode == 0xf7)\n@@ -4390,40 +4396,14 @@ load_insn_p (void)\n       if (i.tm.base_opcode >= 0x80 && i.tm.base_opcode <= 0x83)\n \treturn 1;\n \n-      /* bt, bts, btr, btc.  */\n-      if (i.tm.base_opcode == 0xfba\n-\t  && (i.tm.extension_opcode >= 4 && i.tm.extension_opcode <= 7))\n-\treturn 1;\n-\n       /* rol, ror, rcl, rcr, shl/sal, shr, sar. */\n       if ((base_opcode == 0xc1\n \t   || (i.tm.base_opcode >= 0xd0 && i.tm.base_opcode <= 0xd3))\n \t  && i.tm.extension_opcode != 6)\n \treturn 1;\n \n-      /* cmpxchg8b, cmpxchg16b, xrstors, vmptrld.  */\n-      if (i.tm.base_opcode == 0xfc7\n-\t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_NONE\n-\t  && (i.tm.extension_opcode == 1 || i.tm.extension_opcode == 3\n-\t      || i.tm.extension_opcode == 6))\n-\treturn 1;\n-\n-      /* fxrstor, ldmxcsr, xrstor.  */\n-      if (i.tm.base_opcode == 0xfae\n-\t  && (i.tm.extension_opcode == 1\n-\t      || i.tm.extension_opcode == 2\n-\t      || i.tm.extension_opcode == 5))\n-\treturn 1;\n-\n-      /* lgdt, lidt, lmsw.  */\n-      if (i.tm.base_opcode == 0xf01\n-\t  && (i.tm.extension_opcode == 2\n-\t      || i.tm.extension_opcode == 3\n-\t      || i.tm.extension_opcode == 6))\n-\treturn 1;\n-\n       /* Check for x87 instructions.  */\n-      if (i.tm.base_opcode >= 0xd8 && i.tm.base_opcode <= 0xdf)\n+      if (base_opcode >= 0xd8 && base_opcode <= 0xdf)\n \t{\n \t  /* Skip fst, fstp, fstenv, fstcw.  */\n \t  if (i.tm.base_opcode == 0xd9\n@@ -4462,6 +4442,34 @@ load_insn_p (void)\n \t  return 1;\n \t}\n     }\n+  else if (i.tm.opcode_modifier.opcodespace == SPACE_0F)\n+    {\n+      /* bt, bts, btr, btc.  */\n+      if (i.tm.base_opcode == 0xba\n+\t  && (i.tm.extension_opcode >= 4 && i.tm.extension_opcode <= 7))\n+\treturn 1;\n+\n+      /* cmpxchg8b, cmpxchg16b, xrstors, vmptrld.  */\n+      if (i.tm.base_opcode == 0xc7\n+\t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_NONE\n+\t  && (i.tm.extension_opcode == 1 || i.tm.extension_opcode == 3\n+\t      || i.tm.extension_opcode == 6))\n+\treturn 1;\n+\n+      /* fxrstor, ldmxcsr, xrstor.  */\n+      if (i.tm.base_opcode == 0xae\n+\t  && (i.tm.extension_opcode == 1\n+\t      || i.tm.extension_opcode == 2\n+\t      || i.tm.extension_opcode == 5))\n+\treturn 1;\n+\n+      /* lgdt, lidt, lmsw.  */\n+      if (i.tm.base_opcode == 0x01\n+\t  && (i.tm.extension_opcode == 2\n+\t      || i.tm.extension_opcode == 3\n+\t      || i.tm.extension_opcode == 6))\n+\treturn 1;\n+    }\n \n   dest = i.operands - 1;\n \n@@ -4471,8 +4479,8 @@ load_insn_p (void)\n       && i.types[dest].bitfield.imm8)\n     dest--;\n \n-  /* add, or, adc, sbb, and, sub, xor, cmp, test, xchg, xadd  */\n-  if (!any_vex_p\n+  /* add, or, adc, sbb, and, sub, xor, cmp, test, xchg.  */\n+  if (i.tm.opcode_modifier.opcodespace == SPACE_BASE\n       && (base_opcode == 0x1\n \t  || base_opcode == 0x9\n \t  || base_opcode == 0x11\n@@ -4481,8 +4489,12 @@ load_insn_p (void)\n \t  || base_opcode == 0x29\n \t  || base_opcode == 0x31\n \t  || base_opcode == 0x39\n-\t  || (i.tm.base_opcode >= 0x84 && i.tm.base_opcode <= 0x87)\n-\t  || base_opcode == 0xfc1))\n+\t  || (base_opcode | 2) == 0x87))\n+    return 1;\n+\n+  /* xadd.  */\n+  if (i.tm.opcode_modifier.opcodespace == SPACE_0F\n+      && base_opcode == 0xc1)\n     return 1;\n \n   /* Check for load instruction.  */\n@@ -4527,7 +4539,7 @@ insert_lfence_before (void)\n {\n   char *p;\n \n-  if (is_any_vex_encoding (&i.tm))\n+  if (i.tm.opcode_modifier.opcodespace != SPACE_BASE)\n     return;\n \n   if (i.tm.base_opcode == 0xff\n@@ -4908,7 +4920,8 @@ md_assemble (char *line)\n   /* Handle conversion of 'int $3' --> special int3 insn.  XOP or FMA4\n      instructions may define INT_OPCODE as well, so avoid this corner\n      case for those instructions that use MODRM.  */\n-  if (i.tm.base_opcode == INT_OPCODE\n+  if (i.tm.opcode_modifier.opcodespace == SPACE_BASE\n+      && i.tm.base_opcode == INT_OPCODE\n       && !i.tm.opcode_modifier.modrm\n       && i.op[0].imms->X_add_number == 3)\n     {\n@@ -6289,7 +6302,8 @@ match_template (char mnem_suffix)\n       j = i.imm_operands + (t->operands > i.imm_operands + 1);\n       if (((i.suffix == QWORD_MNEM_SUFFIX\n \t    && flag_code != CODE_64BIT\n-\t    && !(t->base_opcode == 0xfc7\n+\t    && !(t->opcode_modifier.opcodespace == SPACE_0F\n+\t\t && t->base_opcode == 0xc7\n \t\t && t->opcode_modifier.opcodeprefix == PREFIX_NONE\n \t\t && t->extension_opcode == 1) /* cmpxchg8b */)\n \t   || (i.suffix == LONG_MNEM_SUFFIX\n@@ -6740,7 +6754,7 @@ check_string (void)\n static int\n process_suffix (void)\n {\n-  bfd_boolean is_crc32 = FALSE;\n+  bfd_boolean is_crc32 = FALSE, is_movx = FALSE;\n \n   /* If matched instruction specifies an explicit instruction mnemonic\n      suffix, use it.  */\n@@ -6755,17 +6769,23 @@ process_suffix (void)\n \t   && !i.tm.opcode_modifier.addrprefixopreg)\n     {\n       unsigned int numop = i.operands;\n+\n+      /* MOVSX/MOVZX */\n+      is_movx = (i.tm.opcode_modifier.opcodespace == SPACE_0F\n+\t\t && (i.tm.base_opcode | 8) == 0xbe)\n+\t\t|| (i.tm.opcode_modifier.opcodespace == SPACE_BASE\n+\t\t    && i.tm.base_opcode == 0x63\n+\t\t    && i.tm.cpu_flags.bitfield.cpu64);\n+\n       /* CRC32 */\n-      is_crc32 = (i.tm.base_opcode == 0xf38f0\n+      is_crc32 = (i.tm.base_opcode == 0xf0\n+\t\t  && i.tm.opcode_modifier.opcodespace == SPACE_0F38\n \t\t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_0XF2);\n \n       /* movsx/movzx want only their source operand considered here, for the\n \t ambiguity checking below.  The suffix will be replaced afterwards\n \t to represent the destination (register).  */\n-      if (((i.tm.base_opcode | 8) == 0xfbe && i.tm.opcode_modifier.w)\n-\t  || (i.tm.base_opcode == 0x63\n-\t      && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n-\t      && i.tm.cpu_flags.bitfield.cpu64))\n+      if (is_movx && (i.tm.opcode_modifier.w || i.tm.base_opcode == 0x63))\n \t--i.operands;\n \n       /* crc32 needs REX.W set regardless of suffix / source operand size.  */\n@@ -6803,8 +6823,7 @@ process_suffix (void)\n \n \t  /* As an exception, movsx/movzx silently default to a byte source\n \t     in AT&T mode.  */\n-\t  if ((i.tm.base_opcode | 8) == 0xfbe && i.tm.opcode_modifier.w\n-\t      && !i.suffix && !intel_syntax)\n+\t  if (is_movx && i.tm.opcode_modifier.w && !i.suffix && !intel_syntax)\n \t    i.suffix = BYTE_MNEM_SUFFIX;\n \t}\n       else if (i.suffix == BYTE_MNEM_SUFFIX)\n@@ -6883,7 +6902,8 @@ process_suffix (void)\n \t   && (i.tm.opcode_modifier.jump == JUMP_ABSOLUTE\n \t       || i.tm.opcode_modifier.jump == JUMP_BYTE\n \t       || i.tm.opcode_modifier.jump == JUMP_INTERSEGMENT\n-\t       || (i.tm.base_opcode == 0x0f01 /* [ls][gi]dt */\n+\t       || (i.tm.opcode_modifier.opcodespace == SPACE_0F\n+\t\t   && i.tm.base_opcode == 0x01 /* [ls][gi]dt */\n \t\t   && i.tm.extension_opcode <= 3)))\n     {\n       switch (flag_code)\n@@ -7011,10 +7031,7 @@ process_suffix (void)\n \n \t  if (i.tm.opcode_modifier.floatmf)\n \t    i.suffix = SHORT_MNEM_SUFFIX;\n-\t  else if ((i.tm.base_opcode | 8) == 0xfbe\n-\t\t   || (i.tm.base_opcode == 0x63\n-\t\t       && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n-\t\t       && i.tm.cpu_flags.bitfield.cpu64))\n+\t  else if (is_movx)\n \t    /* handled below */;\n \t  else if (evex)\n \t    i.tm.opcode_modifier.evex = evex;\n@@ -7027,10 +7044,7 @@ process_suffix (void)\n \t}\n     }\n \n-  if ((i.tm.base_opcode | 8) == 0xfbe\n-      || (i.tm.base_opcode == 0x63\n-\t  && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n-\t  && i.tm.cpu_flags.bitfield.cpu64))\n+  if (is_movx)\n     {\n       /* In Intel syntax, movsx/movzx must have a \"suffix\" (checked above).\n \t In AT&T syntax, if there is no suffix (warned about above), the default\n@@ -7252,7 +7266,8 @@ check_byte_reg (void)\n \tcontinue;\n \n       /* crc32 only wants its source operand checked here.  */\n-      if (i.tm.base_opcode == 0xf38f0\n+      if (i.tm.base_opcode == 0xf0\n+\t  && i.tm.opcode_modifier.opcodespace == SPACE_0F38\n \t  && i.tm.opcode_modifier.opcodeprefix == PREFIX_0XF2\n \t  && op != 0)\n \tcontinue;\n@@ -7678,21 +7693,23 @@ process_operands (void)\n       if (flag_code != CODE_64BIT\n \t  ? i.tm.base_opcode == POP_SEG_SHORT\n \t    && i.op[0].regs->reg_num == 1\n-\t  : (i.tm.base_opcode | 1) == POP_SEG386_SHORT\n+\t  : (i.tm.base_opcode | 1) == (POP_SEG386_SHORT & 0xff)\n \t    && i.op[0].regs->reg_num < 4)\n \t{\n \t  as_bad (_(\"you can't `%s %s%s'\"),\n \t\t  i.tm.name, register_prefix, i.op[0].regs->reg_name);\n \t  return 0;\n \t}\n-      if ( i.op[0].regs->reg_num > 3 && i.opcode_length == 1 )\n+      if (i.op[0].regs->reg_num > 3\n+\t  && i.tm.opcode_modifier.opcodespace == SPACE_BASE )\n \t{\n-\t  i.tm.base_opcode ^= POP_SEG_SHORT ^ POP_SEG386_SHORT;\n-\t  i.opcode_length = 2;\n+\t  i.tm.base_opcode ^= (POP_SEG_SHORT ^ POP_SEG386_SHORT) & 0xff;\n+\t  i.tm.opcode_modifier.opcodespace = SPACE_0F;\n \t}\n       i.tm.base_opcode |= (i.op[0].regs->reg_num << 3);\n     }\n-  else if ((i.tm.base_opcode & ~0x3) == MOV_AX_DISP32)\n+  else if (i.tm.opcode_modifier.opcodespace == SPACE_BASE\n+\t   && (i.tm.base_opcode & ~3) == MOV_AX_DISP32)\n     {\n       default_seg = &ds;\n     }\n@@ -8949,8 +8966,8 @@ maybe_fused_with_jcc_p (enum mf_cmp_kind* mf_cmp_p)\n   if (i.base_reg && i.base_reg->reg_num == RegIP)\n     return 0;\n \n-  /* No VEX/EVEX encoding.  */\n-  if (is_any_vex_encoding (&i.tm))\n+  /* No opcodes outside of base encoding space.  */\n+  if (i.tm.opcode_modifier.opcodespace != SPACE_BASE)\n     return 0;\n \n   /* add, sub without add/sub m, imm.  */\n@@ -9073,7 +9090,8 @@ add_branch_padding_frag_p (enum align_branch_kind *branch_p,\n   /* NB: Don't work with COND_JUMP86 without i386.  */\n   if (!align_branch_power\n       || now_seg == absolute_section\n-      || !cpu_arch_flags.bitfield.cpui386)\n+      || !cpu_arch_flags.bitfield.cpui386\n+      || i.tm.opcode_modifier.opcodespace != SPACE_BASE)\n     return 0;\n \n   add_padding = 0;\n@@ -9096,8 +9114,6 @@ add_branch_padding_frag_p (enum align_branch_kind *branch_p,\n \t    add_padding = 1;\n \t}\n     }\n-  else if (is_any_vex_encoding (&i.tm))\n-    return 0;\n   else if ((i.tm.base_opcode | 1) == 0xc3)\n     {\n       /* Near ret.  */\n@@ -9181,8 +9197,10 @@ output_insn (void)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_X87;\n \n       if ((i.xstate & xstate_mmx)\n-\t  || i.tm.base_opcode == 0xf77 /* emms */\n-\t  || i.tm.base_opcode == 0xf0e /* femms */)\n+\t  || (i.tm.opcode_modifier.opcodespace == SPACE_0F\n+\t      && !is_any_vex_encoding (&i.tm)\n+\t      && (i.tm.base_opcode == 0x77 /* emms */\n+\t\t  || i.tm.base_opcode == 0x0e /* femms */)))\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_MMX;\n \n       if (i.index_reg)\n@@ -9200,10 +9218,10 @@ output_insn (void)\n \ti.xstate |= xstate_ymm;\n \n       if ((i.xstate & xstate_xmm)\n-\t  /* ldmxcsr / stmxcsr */\n-\t  || (i.tm.base_opcode == 0xfae && i.tm.cpu_flags.bitfield.cpusse)\n-\t  /* vldmxcsr / vstmxcsr */\n-\t  || (i.tm.base_opcode == 0xae && i.tm.cpu_flags.bitfield.cpuavx)\n+\t  /* ldmxcsr / stmxcsr / vldmxcsr / vstmxcsr */\n+\t  || (i.tm.base_opcode == 0xae\n+\t      && (i.tm.cpu_flags.bitfield.cpusse\n+\t\t  || i.tm.cpu_flags.bitfield.cpuavx))\n \t  || i.tm.cpu_flags.bitfield.cpuwidekl\n \t  || i.tm.cpu_flags.bitfield.cpukl)\n \tx86_feature_2_used |= GNU_PROPERTY_X86_FEATURE_2_XMM;\n@@ -9226,7 +9244,8 @@ output_insn (void)\n       if (x86_feature_2_used\n \t  || i.tm.cpu_flags.bitfield.cpucmov\n \t  || i.tm.cpu_flags.bitfield.cpusyscall\n-\t  || (i.tm.base_opcode == 0xfc7\n+\t  || (i.tm.opcode_modifier.opcodespace == SPACE_0F\n+\t      && i.tm.base_opcode == 0xc7\n \t      && i.tm.opcode_modifier.opcodeprefix == PREFIX_NONE\n \t      && i.tm.extension_opcode == 1) /* cmpxchg8b */)\n \tx86_isa_1_used |= GNU_PROPERTY_X86_ISA_1_BASELINE;\n@@ -9327,9 +9346,9 @@ output_insn (void)\n       enum mf_cmp_kind mf_cmp;\n \n       if (avoid_fence\n-\t  && (i.tm.base_opcode == 0xfaee8\n-\t      || i.tm.base_opcode == 0xfaef0\n-\t      || i.tm.base_opcode == 0xfaef8))\n+\t  && (i.tm.base_opcode == 0xaee8\n+\t      || i.tm.base_opcode == 0xaef0\n+\t      || i.tm.base_opcode == 0xaef8))\n \t{\n \t  /* Encode lfence, mfence, and sfence as\n \t     f0 83 04 24 00   lock addl $0x0, (%{re}sp).  */\n@@ -9411,7 +9430,6 @@ output_insn (void)\n \t    case PREFIX_NONE:\n \t      switch (i.opcode_length)\n \t\t{\n-\t\tcase 3:\n \t\tcase 2:\n \t\t  break;\n \t\tcase 1:\n@@ -9482,36 +9500,55 @@ output_insn (void)\n \t}\n \n       /* Now the opcode; be careful about word order here!  */\n+      j = i.opcode_length;\n+      if (!i.vex.length)\n+\tswitch (i.tm.opcode_modifier.opcodespace)\n+\t  {\n+\t  case SPACE_BASE:\n+\t    break;\n+\t  case SPACE_0F:\n+\t    ++j;\n+\t    break;\n+\t  case SPACE_0F38:\n+\t  case SPACE_0F3A:\n+\t    j += 2;\n+\t    break;\n+\t  default:\n+\t    abort ();\n+\t  }\n+\n       if (now_seg == absolute_section)\n-\tabs_section_offset += i.opcode_length;\n-      else if (i.opcode_length == 1)\n+\tabs_section_offset += j;\n+      else if (j == 1)\n \t{\n \t  FRAG_APPEND_1_CHAR (i.tm.base_opcode);\n \t}\n       else\n \t{\n+\t  p = frag_more (j);\n+\t  if (!i.vex.length\n+\t      && i.tm.opcode_modifier.opcodespace != SPACE_BASE)\n+\t    {\n+\t      *p++ = 0x0f;\n+\t      if (i.tm.opcode_modifier.opcodespace != SPACE_0F)\n+\t\t*p++ = i.tm.opcode_modifier.opcodespace == SPACE_0F38\n+\t\t       ? 0x38 : 0x3a;\n+\t    }\n+\n \t  switch (i.opcode_length)\n \t    {\n-\t    case 4:\n-\t      p = frag_more (4);\n-\t      *p++ = (i.tm.base_opcode >> 24) & 0xff;\n-\t      *p++ = (i.tm.base_opcode >> 16) & 0xff;\n-\t      break;\n-\t    case 3:\n-\t      p = frag_more (3);\n-\t      *p++ = (i.tm.base_opcode >> 16) & 0xff;\n-\t      break;\n \t    case 2:\n-\t      p = frag_more (2);\n+\t      /* Put out high byte first: can't use md_number_to_chars!  */\n+\t      *p++ = (i.tm.base_opcode >> 8) & 0xff;\n+\t      /* Fall through.  */\n+\t    case 1:\n+\t      *p = i.tm.base_opcode & 0xff;\n \t      break;\n \t    default:\n \t      abort ();\n \t      break;\n \t    }\n \n-\t  /* Put out high byte first: can't use md_number_to_chars!  */\n-\t  *p++ = (i.tm.base_opcode >> 8) & 0xff;\n-\t  *p = i.tm.base_opcode & 0xff;\n \t}\n \n       /* Now the modrm byte and sib byte (if present).  */\n@@ -9566,28 +9603,16 @@ output_insn (void)\n \n \t      /* Count prefixes for extended opcode maps.  */\n \t      if (!i.vex.length)\n-\t\tswitch (i.opcode_length)\n+\t\tswitch (i.tm.opcode_modifier.opcodespace)\n \t\t  {\n-\t\t  case 3:\n-\t\t    if (((i.tm.base_opcode >> 16) & 0xff) == 0xf)\n-\t\t      {\n-\t\t\tcount++;\n-\t\t\tswitch ((i.tm.base_opcode >> 8) & 0xff)\n-\t\t\t  {\n-\t\t\t  case 0x38:\n-\t\t\t  case 0x3a:\n-\t\t\t    count++;\n-\t\t\t    break;\n-\t\t\t  default:\n-\t\t\t    break;\n-\t\t\t  }\n-\t\t      }\n+\t\t  case SPACE_BASE:\n \t\t    break;\n-\t\t  case 2:\n-\t\t    if (((i.tm.base_opcode >> 8) & 0xff) == 0xf)\n-\t\t      count++;\n+\t\t  case SPACE_0F:\n+\t\t    count++;\n \t\t    break;\n-\t\t  case 1:\n+\t\t  case SPACE_0F38:\n+\t\t  case SPACE_0F3A:\n+\t\t    count += 2;\n \t\t    break;\n \t\t  default:\n \t\t    abort ();\n@@ -9807,7 +9832,7 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t\t  && i.rm.regmem == 5))\n \t\t  && (i.rm.mode == 2\n \t\t      || (i.rm.mode == 0 && i.rm.regmem == 5))\n-\t\t  && !is_any_vex_encoding(&i.tm)\n+\t\t  && i.tm.opcode_modifier.opcodespace == SPACE_BASE\n \t\t  && ((i.operands == 1\n \t\t       && i.tm.base_opcode == 0xff\n \t\t       && (i.rm.reg == 2 || i.rm.reg == 4))\n@@ -11103,9 +11128,11 @@ i386_index_check (const char *operand_string)\n \n \t  /* bndmk, bndldx, bndstx and mandatory non-vector SIB have special restrictions. */\n \t  if ((t->opcode_modifier.opcodeprefix == PREFIX_0XF3\n-\t       && t->base_opcode == 0x0f1b)\n+\t       && t->opcode_modifier.opcodespace == SPACE_0F\n+\t       && t->base_opcode == 0x1b)\n \t      || (t->opcode_modifier.opcodeprefix == PREFIX_NONE\n-\t\t  && (t->base_opcode & ~1) == 0x0f1a)\n+\t\t  && t->opcode_modifier.opcodespace == SPACE_0F\n+\t\t  && (t->base_opcode & ~1) == 0x1a)\n \t      || t->opcode_modifier.sib == SIBMEM)\n \t    {\n \t      /* They cannot use RIP-relative addressing. */\n@@ -11117,7 +11144,8 @@ i386_index_check (const char *operand_string)\n \n \t      /* bndldx and bndstx ignore their scale factor. */\n \t      if (t->opcode_modifier.opcodeprefix == PREFIX_NONE\n-\t\t  && (t->base_opcode & ~1) == 0x0f1a\n+\t\t  && t->opcode_modifier.opcodespace == SPACE_0F\n+\t\t  && (t->base_opcode & ~1) == 0x1a\n \t\t  && i.log2_scale_factor)\n \t\tas_warn (_(\"register scaling is being ignored here\"));\n \t    }"
    },
    {
      "sha": "82a1c5cdb927579fe72e5c79475d03b3ef77b155",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-29  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-gen.c (process_i386_opcode_modifier): New parameter\n+\t\"space\". \n+\t(output_i386_opcode): New local variable \"space\". Adjust\n+\tprocess_i386_opcode_modifier() invocation.\n+\t(process_i386_opcodes): Adjust process_i386_opcode_modifier()\n+\tinvocation.\n+\t* i386-tbl.h: Re-generate.\n+\n 2021-03-29  Alan Modra  <amodra@gmail.com>\n \n \t* aarch64-opc.c (vector_qualifier_p): Simplify boolean expression."
    },
    {
      "sha": "f514135b0d167dec9c103b3a5c637b51ff3439f9",
      "filename": "opcodes/i386-gen.c",
      "status": "modified",
      "additions": 35,
      "deletions": 5,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/i386-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/i386-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-gen.c?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693",
      "patch": "@@ -1176,8 +1176,8 @@ adjust_broadcast_modifier (char **opnd)\n }\n \n static void\n-process_i386_opcode_modifier (FILE *table, char *mod, unsigned int prefix,\n-\t\t\t      char **opnd, int lineno)\n+process_i386_opcode_modifier (FILE *table, char *mod, unsigned int space,\n+\t\t\t      unsigned int prefix, char **opnd, int lineno)\n {\n   char *str, *next, *last;\n   bitfield modifiers [ARRAY_SIZE (opcode_modifiers)];\n@@ -1220,6 +1220,19 @@ process_i386_opcode_modifier (FILE *table, char *mod, unsigned int prefix,\n \t    }\n \t}\n \n+      if (space)\n+\t{\n+\t  if (!modifiers[OpcodeSpace].value)\n+\t    modifiers[OpcodeSpace].value = space;\n+\t  else if (modifiers[OpcodeSpace].value != space)\n+\t    fail (_(\"%s:%d: Conflicting opcode space specifications\\n\"),\n+\t\t  filename, lineno);\n+\t  else\n+\t    fprintf (stderr,\n+\t\t     _(\"%s:%d: Warning: redundant opcode space specification\\n\"),\n+\t\t     filename, lineno);\n+\t}\n+\n       if (prefix)\n \t{\n \t  if (!modifiers[OpcodePrefix].value)\n@@ -1355,7 +1368,7 @@ static void\n output_i386_opcode (FILE *table, const char *name, char *str,\n \t\t    char *last, int lineno)\n {\n-  unsigned int i, length, prefix = 0;\n+  unsigned int i, length, prefix = 0, space = 0;\n   char *base_opcode, *extension_opcode, *end;\n   char *cpu_flags, *opcode_modifier, *operand_types [MAX_OPERANDS];\n   unsigned long int opcode;\n@@ -1427,10 +1440,27 @@ output_i386_opcode (FILE *table, const char *name, char *str,\n \topcode &= (1UL << (8 * --length)) - 1;\n     }\n \n+  /* Transform opcode space encoded in the opcode into opcode modifier\n+     representation.  */\n+  if (length > 1 && (opcode >> (8 * length - 8)) == 0xf)\n+    {\n+      switch ((opcode >> (8 * length - 16)) & 0xff)\n+\t{\n+\tdefault:   space = SPACE_0F;   break;\n+\tcase 0x38: space = SPACE_0F38; break;\n+\tcase 0x3A: space = SPACE_0F3A; break;\n+\t}\n+\n+      if (space != SPACE_0F && --length == 1)\n+\tfail (_(\"%s:%d: %s: unrecognized opcode encoding space\\n\"),\n+\t      filename, lineno, name);\n+      opcode &= (1UL << (8 * --length)) - 1;\n+    }\n+\n   fprintf (table, \"  { \\\"%s\\\", 0x%0*lx%s, %s, %lu,\\n\",\n \t   name, 2 * (int)length, opcode, end, extension_opcode, i);\n \n-  process_i386_opcode_modifier (table, opcode_modifier, prefix,\n+  process_i386_opcode_modifier (table, opcode_modifier, space, prefix,\n \t\t\t\toperand_types, lineno);\n \n   process_i386_cpu_flag (table, cpu_flags, 0, \",\", \"    \", lineno);\n@@ -1822,7 +1852,7 @@ process_i386_opcodes (FILE *table)\n \n   fprintf (table, \"  { NULL, 0, 0, 0,\\n\");\n \n-  process_i386_opcode_modifier (table, \"0\", 0, NULL, -1);\n+  process_i386_opcode_modifier (table, \"0\", 0, 0, NULL, -1);\n \n   process_i386_cpu_flag (table, \"0\", 0, \",\", \"    \", -1);\n "
    },
    {
      "sha": "c1cf77cbdc12d64a3c613cd3899b6c240082429b",
      "filename": "opcodes/i386-tbl.h",
      "status": "modified",
      "additions": 1596,
      "deletions": 1596,
      "changes": 3192,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/i386-tbl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389d00a5e5b1fa6fcd9eda747b17ef73f58eb693/opcodes/i386-tbl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-tbl.h?ref=389d00a5e5b1fa6fcd9eda747b17ef73f58eb693"
    }
  ]
}