{
  "sha": "216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjE2YTdlNmI5ZTVkMmIyNzkyNzZmM2JkOGMxMTE0NWE3ZDliNTlhYw==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-11-29T00:14:35Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-01T22:31:32Z"
    },
    "message": "gdb: Dynamic string length support\n\nAdd support for strings with dynamic length using the DWARF attribute\nDW_AT_string_length.\n\nCurrently gFortran generates DWARF for some strings that make use of\nDW_AT_string_length like this:\n\n <1><2cc>: Abbrev Number: 20 (DW_TAG_string_type)\n    <2cd>   DW_AT_string_length: 5 byte block: 99 bd 1 0 0      (DW_OP_call4: <0x1bd>)\n    <2d3>   DW_AT_byte_size   : 4\n    <2d4>   DW_AT_sibling     : <0x2e2>\n\nIn this type entry the DW_AT_string_length attribute references a\nsecond DW_TAG_formal_parameter that contains the string length.  The\nDW_AT_byte_size indicates that the length is a 4-byte value.\n\nThis commit extends GDB's DWARF parsing for strings so that we can\ncreate dynamic types as well as static types, based on the attribute\nthe DWARF contains.\n\nI then extend the dynamic type resolution code in gdbtypes.c to add\nsupport for resolving dynamic strings.\n\ngdb/ChangeLog:\n\n\t* dwarf2read.c (read_tag_string_type): Read the fields required to\n\tmake a dynamic string, and possibly create a dynamic range for the\n\tstring.\n\t(attr_to_dynamic_prop): Setup is_reference based on the type of\n\tattribute being processed.\n\t* gdbtypes.c (is_dynamic_type_internal): Handle TYPE_CODE_STRING.\n\t(resolve_dynamic_array): Rename to...\n\t(resolve_dynamic_array_or_string): ...this, update header comment,\n\tand accept TYPE_CODE_STRING.\n\t(resolve_dynamic_type_internal): Handle TYPE_CODE_STRING.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/array-slices.exp: Add test for dynamic strings.\n\nChange-Id: I03f2d181b26156f48f27a03c8a59f9bd4d71ac17",
    "tree": {
      "sha": "9138bacbc1bf655ff3d28324a4831f89ab505acc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9138bacbc1bf655ff3d28324a4831f89ab505acc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "11a8b1641e310f3d47173125b62ee2e2147e74f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/11a8b1641e310f3d47173125b62ee2e2147e74f3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/11a8b1641e310f3d47173125b62ee2e2147e74f3"
    }
  ],
  "stats": {
    "total": 152,
    "additions": 128,
    "deletions": 24
  },
  "files": [
    {
      "sha": "1465c756abc9b6510ba572ec49f4e67f5025ea32",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
      "patch": "@@ -1,3 +1,16 @@\n+2019-12-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* dwarf2read.c (read_tag_string_type): Read the fields required to\n+\tmake a dynamic string, and possibly create a dynamic range for the\n+\tstring.\n+\t(attr_to_dynamic_prop): Setup is_reference based on the type of\n+\tattribute being processed.\n+\t* gdbtypes.c (is_dynamic_type_internal): Handle TYPE_CODE_STRING.\n+\t(resolve_dynamic_array): Rename to...\n+\t(resolve_dynamic_array_or_string): ...this, update header comment,\n+\tand accept TYPE_CODE_STRING.\n+\t(resolve_dynamic_type_internal): Handle TYPE_CODE_STRING.\n+\n 2019-12-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* dwarf2read.c (dwarf2_per_cu_int_type): New function, takes most"
    },
    {
      "sha": "327837cc3c83434291590f1c18e983b561d73d46",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 84,
      "deletions": 15,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
      "patch": "@@ -17323,29 +17323,90 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n   struct type *type, *range_type, *index_type, *char_type;\n   struct attribute *attr;\n-  unsigned int length;\n+  struct dynamic_prop prop;\n+  bool length_is_constant = true;\n+  LONGEST length;\n+\n+  /* There are a couple of places where bit sizes might be made use of\n+     when parsing a DW_TAG_string_type, however, no producer that we know\n+     of make use of these.  Handling bit sizes that are a multiple of the\n+     byte size is easy enough, but what about other bit sizes?  Lets deal\n+     with that problem when we have to.  Warn about these attributes being\n+     unsupported, then parse the type and ignore them like we always\n+     have.  */\n+  if (dwarf2_attr (die, DW_AT_bit_size, cu) != nullptr\n+      || dwarf2_attr (die, DW_AT_string_length_bit_size, cu) != nullptr)\n+    {\n+      static bool warning_printed = false;\n+      if (!warning_printed)\n+\t{\n+\t  warning (_(\"DW_AT_bit_size and DW_AT_string_length_bit_size not \"\n+\t\t     \"currently supported on DW_TAG_string_type.\"));\n+\t  warning_printed = true;\n+\t}\n+    }\n \n   attr = dwarf2_attr (die, DW_AT_string_length, cu);\n-  if (attr != nullptr)\n+  if (attr != nullptr && !attr_form_is_constant (attr))\n+    {\n+      /* The string length describes the location at which the length of\n+\t the string can be found.  The size of the length field can be\n+\t specified with one of the attributes below.  */\n+      struct type *prop_type;\n+      struct attribute *len\n+\t= dwarf2_attr (die, DW_AT_string_length_byte_size, cu);\n+      if (len == nullptr)\n+\tlen = dwarf2_attr (die, DW_AT_byte_size, cu);\n+      if (len != nullptr && attr_form_is_constant (len))\n+\t{\n+\t  /* Pass 0 as the default as we know this attribute is constant\n+\t     and the default value will not be returned.  */\n+\t  LONGEST sz = dwarf2_get_attr_constant_value (len, 0);\n+\t  prop_type = dwarf2_per_cu_int_type (cu->per_cu, sz, true);\n+\t}\n+      else\n+\t{\n+\t  /* If the size is not specified then we assume it is the size of\n+\t     an address on this target.  */\n+\t  prop_type = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, true);\n+\t}\n+\n+      /* Convert the attribute into a dynamic property.  */\n+      if (!attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n+\tlength = 1;\n+      else\n+\tlength_is_constant = false;\n+    }\n+  else if (attr != nullptr)\n+    {\n+      /* This DW_AT_string_length just contains the length with no\n+\t indirection.  There's no need to create a dynamic property in this\n+\t case.  Pass 0 for the default value as we know it will not be\n+\t returned in this case.  */\n+      length = dwarf2_get_attr_constant_value (attr, 0);\n+    }\n+  else if ((attr = dwarf2_attr (die, DW_AT_byte_size, cu)) != nullptr)\n     {\n-      length = DW_UNSND (attr);\n+      /* We don't currently support non-constant byte sizes for strings.  */\n+      length = dwarf2_get_attr_constant_value (attr, 1);\n     }\n   else\n     {\n-      /* Check for the DW_AT_byte_size attribute.  */\n-      attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-      if (attr != nullptr)\n-        {\n-          length = DW_UNSND (attr);\n-        }\n-      else\n-        {\n-          length = 1;\n-        }\n+      /* Use 1 as a fallback length if we have nothing else.  */\n+      length = 1;\n     }\n \n   index_type = objfile_type (objfile)->builtin_int;\n-  range_type = create_static_range_type (NULL, index_type, 1, length);\n+  if (length_is_constant)\n+    range_type = create_static_range_type (NULL, index_type, 1, length);\n+  else\n+    {\n+      struct dynamic_prop low_bound;\n+\n+      low_bound.kind = PROP_CONST;\n+      low_bound.data.const_val = 1;\n+      range_type = create_range_type (NULL, index_type, &low_bound, &prop, 0);\n+    }\n   char_type = language_string_char_type (cu->language_defn, gdbarch);\n   type = create_string_type (NULL, char_type, range_type);\n \n@@ -17806,7 +17867,15 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n       baton->locexpr.per_cu = cu->per_cu;\n       baton->locexpr.size = DW_BLOCK (attr)->size;\n       baton->locexpr.data = DW_BLOCK (attr)->data;\n-      baton->locexpr.is_reference = false;\n+      switch (attr->name)\n+\t{\n+\tcase DW_AT_string_length:\n+\t  baton->locexpr.is_reference = true;\n+\t  break;\n+\tdefault:\n+\t  baton->locexpr.is_reference = false;\n+\t  break;\n+\t}\n       prop->data.baton = baton;\n       prop->kind = PROP_LOCEXPR;\n       gdb_assert (prop->data.baton != NULL);"
    },
    {
      "sha": "f10f65d0dab5897d53d27ea9d6008045119c9c28",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 17,
      "deletions": 8,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
      "patch": "@@ -1967,6 +1967,9 @@ is_dynamic_type_internal (struct type *type, int top_level)\n \t\t|| is_dynamic_type_internal (TYPE_TARGET_TYPE (type), 0));\n       }\n \n+    case TYPE_CODE_STRING:\n+      /* Strings are very much like an array of characters, and can be\n+\t treated as one here.  */\n     case TYPE_CODE_ARRAY:\n       {\n \tgdb_assert (TYPE_NFIELDS (type) == 1);\n@@ -2088,13 +2091,13 @@ resolve_dynamic_range (struct type *dyn_range_type,\n   return static_range_type;\n }\n \n-/* Resolves dynamic bound values of an array type TYPE to static ones.\n-   ADDR_STACK is a stack of struct property_addr_info to be used\n-   if needed during the dynamic resolution.  */\n+/* Resolves dynamic bound values of an array or string type TYPE to static\n+   ones.  ADDR_STACK is a stack of struct property_addr_info to be used if\n+   needed during the dynamic resolution.  */\n \n static struct type *\n-resolve_dynamic_array (struct type *type,\n-\t\t       struct property_addr_info *addr_stack)\n+resolve_dynamic_array_or_string (struct type *type,\n+\t\t\t\t struct property_addr_info *addr_stack)\n {\n   CORE_ADDR value;\n   struct type *elt_type;\n@@ -2103,7 +2106,10 @@ resolve_dynamic_array (struct type *type,\n   struct dynamic_prop *prop;\n   unsigned int bit_stride = 0;\n \n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY);\n+  /* For dynamic type resolution strings can be treated like arrays of\n+     characters.  */\n+  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t      || TYPE_CODE (type) == TYPE_CODE_STRING);\n \n   type = copy_type (type);\n \n@@ -2129,7 +2135,7 @@ resolve_dynamic_array (struct type *type,\n   ary_dim = check_typedef (TYPE_TARGET_TYPE (elt_type));\n \n   if (ary_dim != NULL && TYPE_CODE (ary_dim) == TYPE_CODE_ARRAY)\n-    elt_type = resolve_dynamic_array (ary_dim, addr_stack);\n+    elt_type = resolve_dynamic_array_or_string (ary_dim, addr_stack);\n   else\n     elt_type = TYPE_TARGET_TYPE (type);\n \n@@ -2332,8 +2338,11 @@ resolve_dynamic_type_internal (struct type *type,\n \t    break;\n \t  }\n \n+\tcase TYPE_CODE_STRING:\n+\t  /* Strings are very much like an array of characters, and can be\n+\t     treated as one here.  */\n \tcase TYPE_CODE_ARRAY:\n-\t  resolved_type = resolve_dynamic_array (type, addr_stack);\n+\t  resolved_type = resolve_dynamic_array_or_string (type, addr_stack);\n \t  break;\n \n \tcase TYPE_CODE_RANGE:"
    },
    {
      "sha": "a4d2556c90a4d79ab3256432a16ce966d2340aba",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
      "patch": "@@ -1,3 +1,7 @@\n+2019-12-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/array-slices.exp: Add test for dynamic strings.\n+\n 2019-12-01  Richard Bunt  <richard.bunt@arm.com>\n \t    Andrew Burgess  <andrew.burgess@embecosm.com>\n "
    },
    {
      "sha": "7a7baf76d2826a7ae1092a79a9068b26f2fa9217",
      "filename": "gdb/testsuite/gdb.fortran/array-slices.exp",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/testsuite/gdb.fortran/array-slices.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac/gdb/testsuite/gdb.fortran/array-slices.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-slices.exp?ref=216a7e6b9e5d2b279276f3bd8c11145a7d9b59ac",
      "patch": "@@ -46,12 +46,21 @@ set array_contents \\\n \t \" = \\\\(\\\\( -26, -25, -24, -23, -22, -21\\\\) \\\\( -19, -18, -17, -16, -15, -14\\\\) \\\\( -12, -11, -10, -9, -8, -7\\\\) \\\\)\" \\\n \t \" = \\\\(\\\\( -26, -24, -22, -20, -18\\\\) \\\\( -5, -3, -1, 1, 3\\\\) \\\\( 16, 18, 20, 22, 24\\\\) \\\\( 37, 39, 41, 43, 45\\\\) \\\\)\" ]\n \n+set message_strings \\\n+    [list \\\n+\t \" = 'array'\" \\\n+\t \" = 'array \\\\(1:5,1:5\\\\)'\" \\\n+\t \" = 'array \\\\(1:10:2,1:10:2\\\\)'\" \\\n+\t \" = 'array \\\\(1:10:3,1:10:2\\\\)'\" \\\n+\t \" = 'array \\\\(1:10:5,1:10:3\\\\)'\" ]\n+\n set i 0\n-foreach result $array_contents {\n+foreach result $array_contents msg $message_strings {\n     incr i\n     with_test_prefix \"test $i\" {\n \tgdb_continue_to_breakpoint \"show\"\n \tgdb_test \"p array\" $result\n+\tgdb_test \"p message\" \"$msg\"\n     }\n }\n "
    }
  ]
}