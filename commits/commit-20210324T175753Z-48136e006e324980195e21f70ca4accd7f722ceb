{
  "sha": "48136e006e324980195e21f70ca4accd7f722ceb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDgxMzZlMDA2ZTMyNDk4MDE5NWUyMWY3MGNhNGFjY2Q3ZjcyMmNlYg==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T18:49:37Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:57:53Z"
    },
    "message": "New memory-tag commands\n\nAdd new commands under the \"memory-tag\" prefix to allow users to inspect,\nmodify and check memory tags in different ways.\n\nThe available subcommands are the following:\n\n- memory-tag print-logical-tag <expression>: Prints the logical tag for a\n  particular address.\n\n- memory-tag withltag <expression> <tag>: Prints the address tagged with the\n  logical tag <tag>.\n\n- memory-tag print-allocation-tag <expression>: Prints the allocation tag for\n  a particular address.\n\n- memory-tag setatag <expression> <length> <tags>: Sets one or more allocation\n  tags to the specified tags.\n\n- memory-tag check <expression>: Checks if the logical tag in <address>\n  matches its allocation tag.\n\nThese commands make use of the memory tagging gdbarch methods, and are still\navailable, but disabled, when memory tagging is not supported by the\narchitecture.\n\nI've pondered about a way to make these commands invisible when memory tagging\nis not available, but given the check is at runtime (and support may come and go\nbased on a process' configuration), that is a bit too late in the process to\neither not include the commands or get rid of them.\n\nIdeas are welcome.\n\ngdb/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* printcmd.c: Include gdbsupport/rsp-low.h.\n\t(memory_tag_list): New static global.\n\t(process_print_command_args): Factored out of\n\tprint_command_1.\n\t(print_command_1): Use process_print_command_args.\n\t(show_addr_not_tagged, show_memory_tagging_unsupported)\n\t(memory_tag_command, memory_tag_print_tag_command)\n\t(memory_tag_print_logical_tag_command)\n\t(memory_tag_print_allocation_tag_command, parse_with_logical_tag_input)\n\t(memory_tag_with_logical_tag_command, parse_set_allocation_tag_input)\n\t(memory_tag_set_allocation_tag_command, memory_tag_check_command): New\n\tfunctions.\n\t(_initialize_printcmd): Add \"memory-tag\" prefix and subcommands.\n\ngdbsupport/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* rsp-low.cc (fromhex, hex2bin): Move to ...\n\t* common-utils.cc: ... here.\n\t(fromhex) Change error message text to not be RSP-specific.\n\t* rsp-low.h (fromhex, hex2bin): Move to ...\n\t* common-utils.h: ... here.",
    "tree": {
      "sha": "c01722116f1c614606212f84c31c0991b85ab092",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c01722116f1c614606212f84c31c0991b85ab092"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/48136e006e324980195e21f70ca4accd7f722ceb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48136e006e324980195e21f70ca4accd7f722ceb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/48136e006e324980195e21f70ca4accd7f722ceb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48136e006e324980195e21f70ca4accd7f722ceb/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ffcc2a15499644040a4c6a80828cf1795d9bc54b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ffcc2a15499644040a4c6a80828cf1795d9bc54b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ffcc2a15499644040a4c6a80828cf1795d9bc54b"
    }
  ],
  "stats": {
    "total": 537,
    "additions": 457,
    "deletions": 80
  },
  "files": [
    {
      "sha": "189884bcb02463846540dea8ce593b28f2f36250",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -1,3 +1,19 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* printcmd.c: Include gdbsupport/rsp-low.h.\n+\t(memory_tag_list): New static global.\n+\t(process_print_command_args): Factored out of\n+\tprint_command_1.\n+\t(print_command_1): Use process_print_command_args.\n+\t(show_addr_not_tagged, show_memory_tagging_unsupported)\n+\t(memory_tag_command, memory_tag_print_tag_command)\n+\t(memory_tag_print_logical_tag_command)\n+\t(memory_tag_print_allocation_tag_command, parse_with_logical_tag_input)\n+\t(memory_tag_with_logical_tag_command, parse_set_allocation_tag_input)\n+\t(memory_tag_set_allocation_tag_command, memory_tag_check_command): New\n+\tfunctions.\n+\t(_initialize_printcmd): Add \"memory-tag\" prefix and subcommands.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* aarch64-linux-tdep.c"
    },
    {
      "sha": "9200e66db39a0859bcabdd0a46638b7ddafb320b",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 369,
      "deletions": 12,
      "changes": 381,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -54,6 +54,11 @@\n #include \"gdbsupport/byte-vector.h\"\n #include \"gdbsupport/gdb_optional.h\"\n #include \"safe-ctype.h\"\n+#include \"gdbsupport/rsp-low.h\"\n+\n+/* Chain containing all defined memory-tag subcommands.  */\n+\n+static struct cmd_list_element *memory_tag_list;\n \n /* Last specified output format.  */\n \n@@ -1203,21 +1208,19 @@ print_value (value *val, const value_print_options &opts)\n   annotate_value_history_end ();\n }\n \n-/* Implementation of the \"print\" and \"call\" commands.  */\n+/* Helper for parsing arguments for print_command_1.  */\n \n-static void\n-print_command_1 (const char *args, bool voidprint)\n+static struct value *\n+process_print_command_args (const char *args, value_print_options *print_opts,\n+\t\t\t    bool voidprint)\n {\n-  struct value *val;\n-  value_print_options print_opts;\n-\n-  get_user_print_options (&print_opts);\n+  get_user_print_options (print_opts);\n   /* Override global settings with explicit options, if any.  */\n-  auto group = make_value_print_options_def_group (&print_opts);\n+  auto group = make_value_print_options_def_group (print_opts);\n   gdb::option::process_options\n     (&args, gdb::option::PROCESS_OPTIONS_REQUIRE_DELIMITER, group);\n \n-  print_command_parse_format (&args, \"print\", &print_opts);\n+  print_command_parse_format (&args, \"print\", print_opts);\n \n   const char *exp = args;\n \n@@ -1226,10 +1229,20 @@ print_command_1 (const char *args, bool voidprint)\n       /* VOIDPRINT is true to indicate that we do want to print a void\n \t value, so invert it for parse_expression.  */\n       expression_up expr = parse_expression (exp, nullptr, !voidprint);\n-      val = evaluate_expression (expr.get ());\n+      return evaluate_expression (expr.get ());\n     }\n-  else\n-    val = access_value_history (0);\n+\n+  return access_value_history (0);\n+}\n+\n+/* Implementation of the \"print\" and \"call\" commands.  */\n+\n+static void\n+print_command_1 (const char *args, int voidprint)\n+{\n+  value_print_options print_opts;\n+\n+  struct value *val = process_print_command_args (args, &print_opts, voidprint);\n \n   if (voidprint || (val && value_type (val) &&\n \t\t    value_type (val)->code () != TYPE_CODE_VOID))\n@@ -2778,6 +2791,293 @@ eval_command (const char *arg, int from_tty)\n   execute_command (expanded.c_str (), from_tty);\n }\n \n+/* Convenience function for error checking in memory-tag commands.  */\n+\n+static void\n+show_addr_not_tagged (CORE_ADDR address)\n+{\n+  error (_(\"Address %s not in a region mapped with a memory tagging flag.\"),\n+\t paddress (target_gdbarch (), address));\n+}\n+\n+/* Convenience function for error checking in memory-tag commands.  */\n+\n+static void\n+show_memory_tagging_unsupported (void)\n+{\n+  error (_(\"Memory tagging not supported or disabled by the current\"\n+\t   \" architecture.\"));\n+}\n+\n+/* Implement the \"memory-tag\" prefix command.  */\n+\n+static void\n+memory_tag_command (const char *arg, int from_tty)\n+{\n+  help_list (memory_tag_list, \"memory-tag \", all_commands, gdb_stdout);\n+}\n+\n+/* Helper for print-logical-tag and print-allocation-tag.  */\n+\n+static void\n+memory_tag_print_tag_command (const char *args, enum memtag_type tag_type)\n+{\n+  if (args == nullptr)\n+    error_no_arg (_(\"address or pointer\"));\n+\n+  /* Parse args into a value.  If the value is a pointer or an address,\n+     then fetch the logical or allocation tag.  */\n+  value_print_options print_opts;\n+\n+  struct value *val = process_print_command_args (args, &print_opts, true);\n+\n+  /* If the address is not in a region memory mapped with a memory tagging\n+     flag, it is no use trying to access/manipulate its allocation tag.\n+\n+     It is OK to manipulate the logical tag though.  */\n+  if (tag_type == memtag_type::allocation\n+      && !gdbarch_tagged_address_p (target_gdbarch (), val))\n+    show_addr_not_tagged (value_as_address (val));\n+\n+  struct value *tag_value\n+    = gdbarch_get_memtag (target_gdbarch (), val, tag_type);\n+  std::string tag = gdbarch_memtag_to_string (target_gdbarch (), tag_value);\n+\n+  if (tag.empty ())\n+    printf_filtered (_(\"%s tag unavailable.\\n\"),\n+\t\t     tag_type\n+\t\t       == memtag_type::logical? \"Logical\" : \"Allocation\");\n+\n+  struct value *v_tag = process_print_command_args (tag.c_str (),\n+\t\t\t\t\t\t    &print_opts,\n+\t\t\t\t\t\t    true);\n+  print_opts.output_format = 'x';\n+  print_value (v_tag, print_opts);\n+}\n+\n+/* Implement the \"memory-tag print-logical-tag\" command.  */\n+\n+static void\n+memory_tag_print_logical_tag_command (const char *args, int from_tty)\n+{\n+  if (!target_supports_memory_tagging ())\n+    show_memory_tagging_unsupported ();\n+\n+  memory_tag_print_tag_command (args, memtag_type::logical);\n+}\n+\n+/* Implement the \"memory-tag print-allocation-tag\" command.  */\n+\n+static void\n+memory_tag_print_allocation_tag_command (const char *args, int from_tty)\n+{\n+  if (!target_supports_memory_tagging ())\n+    show_memory_tagging_unsupported ();\n+\n+  memory_tag_print_tag_command (args, memtag_type::allocation);\n+}\n+\n+/* Parse ARGS and extract ADDR and TAG.\n+   ARGS should have format <expression> <tag bytes>.  */\n+\n+static void\n+parse_with_logical_tag_input (const char *args, struct value **val,\n+\t\t\t      gdb::byte_vector &tags,\n+\t\t\t      value_print_options *print_opts)\n+{\n+  /* Fetch the address.  */\n+  std::string address_string = extract_string_maybe_quoted (&args);\n+\n+  /* Parse the address into a value.  */\n+  *val = process_print_command_args (address_string.c_str (), print_opts,\n+\t\t\t\t     true);\n+\n+  /* Fetch the tag bytes.  */\n+  std::string tag_string = extract_string_maybe_quoted (&args);\n+\n+  /* Validate the input.  */\n+  if (address_string.empty () || tag_string.empty ())\n+    error (_(\"Missing arguments.\"));\n+\n+  if (tag_string.length () != 2)\n+    error (_(\"Error parsing tags argument. The tag should be 2 digits.\"));\n+\n+  tags = hex2bin (tag_string.c_str ());\n+}\n+\n+/* Implement the \"memory-tag with-logical-tag\" command.  */\n+\n+static void\n+memory_tag_with_logical_tag_command (const char *args, int from_tty)\n+{\n+  if (!target_supports_memory_tagging ())\n+    show_memory_tagging_unsupported ();\n+\n+  if (args == nullptr)\n+    error_no_arg (_(\"<address> <tag>\"));\n+\n+  gdb::byte_vector tags;\n+  struct value *val;\n+  value_print_options print_opts;\n+\n+  /* Parse the input.  */\n+  parse_with_logical_tag_input (args, &val, tags, &print_opts);\n+\n+  /* Setting the logical tag is just a local operation that does not touch\n+     any memory from the target.  Given an input value, we modify the value\n+     to include the appropriate tag.\n+\n+     For this reason we need to cast the argument value to a\n+     (void *) pointer.  This is so we have the right type for the gdbarch\n+     hook to manipulate the value and insert the tag.\n+\n+     Otherwise, this would fail if, for example, GDB parsed the argument value\n+     into an int-sized value and the pointer value has a type of greater\n+     length.  */\n+\n+  /* Cast to (void *).  */\n+  val = value_cast (builtin_type (target_gdbarch ())->builtin_data_ptr,\n+\t\t    val);\n+\n+  /* Length doesn't matter for a logical tag.  Pass 0.  */\n+  if (!gdbarch_set_memtags (target_gdbarch (), val, 0, tags,\n+\t\t\t    memtag_type::logical))\n+    printf_filtered (_(\"Could not update the logical tag data.\\n\"));\n+  else\n+    {\n+      /* Always print it in hex format.  */\n+      print_opts.output_format = 'x';\n+      print_value (val, print_opts);\n+    }\n+}\n+\n+/* Parse ARGS and extract ADDR, LENGTH and TAGS.  */\n+\n+static void\n+parse_set_allocation_tag_input (const char *args, struct value **val,\n+\t\t\t\tsize_t *length, gdb::byte_vector &tags)\n+{\n+  /* Fetch the address.  */\n+  std::string address_string = extract_string_maybe_quoted (&args);\n+\n+  /* Parse the address into a value.  */\n+  value_print_options print_opts;\n+  *val = process_print_command_args (address_string.c_str (), &print_opts,\n+\t\t\t\t     true);\n+\n+  /* Fetch the length.  */\n+  std::string length_string = extract_string_maybe_quoted (&args);\n+\n+  /* Fetch the tag bytes.  */\n+  std::string tags_string = extract_string_maybe_quoted (&args);\n+\n+  /* Validate the input.  */\n+  if (address_string.empty () || length_string.empty () || tags_string.empty ())\n+    error (_(\"Missing arguments.\"));\n+\n+  errno = 0;\n+  const char *trailer = nullptr;\n+  LONGEST parsed_length = strtoulst (length_string.c_str (), &trailer, 10);\n+\n+  if (errno != 0 || (trailer != nullptr && trailer[0] != '\\0'))\n+    error (_(\"Error parsing length argument.\"));\n+\n+  if (parsed_length <= 0)\n+    error (_(\"Invalid zero or negative length.\"));\n+\n+  *length = parsed_length;\n+\n+  if (tags_string.length () % 2)\n+    error (_(\"Error parsing tags argument. Tags should be 2 digits per byte.\"));\n+\n+  tags = hex2bin (tags_string.c_str ());\n+\n+  /* If the address is not in a region memory mapped with a memory tagging\n+     flag, it is no use trying to access/manipulate its allocation tag.  */\n+  if (!gdbarch_tagged_address_p (target_gdbarch (), *val))\n+    show_addr_not_tagged (value_as_address (*val));\n+}\n+\n+/* Implement the \"memory-tag set-allocation-tag\" command.\n+   ARGS should be in the format <address> <length> <tags>.  */\n+\n+static void\n+memory_tag_set_allocation_tag_command (const char *args, int from_tty)\n+{\n+  if (!target_supports_memory_tagging ())\n+    show_memory_tagging_unsupported ();\n+\n+  if (args == nullptr)\n+    error_no_arg (_(\"<starting address> <length> <tag bytes>\"));\n+\n+  gdb::byte_vector tags;\n+  size_t length = 0;\n+  struct value *val;\n+\n+  /* Parse the input.  */\n+  parse_set_allocation_tag_input (args, &val, &length, tags);\n+\n+  if (!gdbarch_set_memtags (target_gdbarch (), val, length, tags,\n+\t\t\t    memtag_type::allocation))\n+    printf_filtered (_(\"Could not update the allocation tag(s).\\n\"));\n+  else\n+    printf_filtered (_(\"Allocation tag(s) updated successfully.\\n\"));\n+}\n+\n+/* Implement the \"memory-tag check\" command.  */\n+\n+static void\n+memory_tag_check_command (const char *args, int from_tty)\n+{\n+  if (!target_supports_memory_tagging ())\n+    show_memory_tagging_unsupported ();\n+\n+  if (args == nullptr)\n+    error (_(\"Argument required (address or pointer)\"));\n+\n+  /* Parse the expression into a value.  If the value is an address or\n+     pointer, then check its logical tag against the allocation tag.  */\n+  value_print_options print_opts;\n+\n+  struct value *val = process_print_command_args (args, &print_opts, true);\n+\n+  /* If the address is not in a region memory mapped with a memory tagging\n+     flag, it is no use trying to access/manipulate its allocation tag.  */\n+  if (!gdbarch_tagged_address_p (target_gdbarch (), val))\n+    show_addr_not_tagged (value_as_address (val));\n+\n+  CORE_ADDR addr = value_as_address (val);\n+\n+  /* Check if the tag is valid.  */\n+  if (!gdbarch_memtag_matches_p (target_gdbarch (), val))\n+    {\n+      struct value *tag\n+\t= gdbarch_get_memtag (target_gdbarch (), val, memtag_type::logical);\n+      std::string ltag\n+\t= gdbarch_memtag_to_string (target_gdbarch (), tag);\n+\n+      tag = gdbarch_get_memtag (target_gdbarch (), val,\n+\t\t\t\tmemtag_type::allocation);\n+      std::string atag\n+\t= gdbarch_memtag_to_string (target_gdbarch (), tag);\n+\n+      printf_filtered (_(\"Logical tag (%s) does not match\"\n+\t\t\t \" the allocation tag (%s) for address %s.\\n\"),\n+\t\t       ltag.c_str (), atag.c_str (),\n+\t\t       paddress (target_gdbarch (), addr));\n+    }\n+  else\n+    {\n+      struct value *tag\n+\t= gdbarch_get_memtag (target_gdbarch (), val, memtag_type::logical);\n+      std::string ltag\n+\t= gdbarch_memtag_to_string (target_gdbarch (), tag);\n+\n+      printf_filtered (_(\"Memory tags for address %s match (%s).\\n\"),\n+\t\t       paddress (target_gdbarch (), addr), ltag.c_str ());\n+    }\n+}\n+\n void _initialize_printcmd ();\n void\n _initialize_printcmd ()\n@@ -2980,4 +3280,61 @@ Construct a GDB command and then evaluate it.\\n\\\n Usage: eval \\\"format string\\\", ARG1, ARG2, ARG3, ..., ARGN\\n\\\n Convert the arguments to a string as \\\"printf\\\" would, but then\\n\\\n treat this string as a command line, and evaluate it.\"));\n+\n+  /* Memory tagging commands.  */\n+  add_prefix_cmd (\"memory-tag\", class_vars, memory_tag_command, _(\"\\\n+Generic command for printing and manipulating memory tag properties.\"),\n+\t\t  &memory_tag_list, \"memory-tag \", 0, &cmdlist);\n+  add_cmd (\"print-logical-tag\", class_vars,\n+\t   memory_tag_print_logical_tag_command,\n+\t   (\"Print the logical tag from POINTER.\\n\\\n+Usage: memory-tag print-logical-tag <POINTER>.\\n\\\n+<POINTER> is an expression that evaluates to a pointer.\\n\\\n+Print the logical tag contained in POINTER.  The tag interpretation is\\n\\\n+architecture-specific.\"),\n+\t   &memory_tag_list);\n+  add_cmd (\"print-allocation-tag\", class_vars,\n+\t   memory_tag_print_allocation_tag_command,\n+\t   _(\"Print the allocation tag for ADDRESS.\\n\\\n+Usage: memory-tag print-allocation-tag <ADDRESS>.\\n\\\n+<ADDRESS> is an expression that evaluates to a memory address.\\n\\\n+Print the allocation tag associated with the memory address ADDRESS.\\n\\\n+The tag interpretation is architecture-specific.\"),\n+\t   &memory_tag_list);\n+  add_cmd (\"with-logical-tag\", class_vars, memory_tag_with_logical_tag_command,\n+\t   _(\"Print a POINTER with a specific logical TAG.\\n\\\n+Usage: memory-tag with-logical-tag <POINTER> <TAG>\\n\\\n+<POINTER> is an expression that evaluates to a pointer.\\n\\\n+<TAG> is a sequence of hex bytes that is interpreted by the architecture\\n\\\n+as a single memory tag.\"),\n+\t   &memory_tag_list);\n+  add_cmd (\"set-allocation-tag\", class_vars,\n+\t   memory_tag_set_allocation_tag_command,\n+\t   _(\"Set the allocation tag(s) for a memory range.\\n\\\n+Usage: memory-tag set-allocation-tag <ADDRESS> <LENGTH> <TAG_BYTES>\\n\\\n+<ADDRESS> is an expression that evaluates to a memory address\\n\\\n+<LENGTH> is the number of bytes that is added to <ADDRESS> to calculate\\n\\\n+the memory range.\\n\\\n+<TAG_BYTES> is a sequence of hex bytes that is interpreted by the\\n\\\n+architecture as one or more memory tags.\\n\\\n+Sets the tags of the memory range [ADDRESS, ADDRESS + LENGTH)\\n\\\n+to TAG_BYTES.\\n\\\n+\\n\\\n+If the number of tags is greater than or equal to the number of tag granules\\n\\\n+in the [ADDRESS, ADDRESS + LENGTH) range, only the tags up to the\\n\\\n+number of tag granules are updated.\\n\\\n+\\n\\\n+If the number of tags is less than the number of tag granules, then the\\n\\\n+command is a fill operation.  The TAG_BYTES are interpreted as a pattern\\n\\\n+that gets repeated until the number of tag granules in the memory range\\n\\\n+[ADDRESS, ADDRESS + LENGTH) is updated.\"),\n+\t   &memory_tag_list);\n+  add_cmd (\"check\", class_vars, memory_tag_check_command,\n+\t   _(\"Validate a pointer's logical tag against the allocation tag.\\n\\\n+Usage: memory-tag check <POINTER>\\n\\\n+<POINTER> is an expression that evaluates to a pointer\\n\\\n+Fetch the logical and allocation tags for POINTER and compare them\\n\\\n+for equality.  If the tags do not match, print additional information about\\n\\\n+the tag mismatch.\"),\n+\t   &memory_tag_list);\n }"
    },
    {
      "sha": "cf275a49947796ab0cfe84ff1672dd6568b8e518",
      "filename": "gdbsupport/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/ChangeLog?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -1,3 +1,11 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* rsp-low.cc (fromhex, hex2bin): Move to ...\n+\t* common-utils.cc: ... here.\n+\t(fromhex) Change error message text to not be RSP-specific.\n+\t* rsp-low.h (fromhex, hex2bin): Move to ...\n+\t* common-utils.h: ... here.\n+\n 2021-03-21  Alan Modra  <amodra@gmail.com>\n \n \t* common-utils.h (startswith): Delete version now supplied by bfd.h."
    },
    {
      "sha": "8ce839a54ae72217d35b0965f72b38393dcb4bf2",
      "filename": "gdbsupport/common-utils.cc",
      "status": "modified",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/common-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/common-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/common-utils.cc?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -392,3 +392,52 @@ align_down (ULONGEST v, int n)\n   gdb_assert (n && (n & (n-1)) == 0);\n   return (v & -n);\n }\n+\n+/* See gdbsupport/common-utils.h.  */\n+\n+int\n+fromhex (int a)\n+{\n+  if (a >= '0' && a <= '9')\n+    return a - '0';\n+  else if (a >= 'a' && a <= 'f')\n+    return a - 'a' + 10;\n+  else if (a >= 'A' && a <= 'F')\n+    return a - 'A' + 10;\n+  else\n+    error (_(\"Invalid hex digit %d\"), a);\n+}\n+\n+/* See gdbsupport/common-utils.h.  */\n+\n+int\n+hex2bin (const char *hex, gdb_byte *bin, int count)\n+{\n+  int i;\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      if (hex[0] == 0 || hex[1] == 0)\n+\t{\n+\t  /* Hex string is short, or of uneven length.\n+\t     Return the count that has been converted so far.  */\n+\t  return i;\n+\t}\n+      *bin++ = fromhex (hex[0]) * 16 + fromhex (hex[1]);\n+      hex += 2;\n+    }\n+  return i;\n+}\n+\n+/* See gdbsupport/common-utils.h.  */\n+\n+gdb::byte_vector\n+hex2bin (const char *hex)\n+{\n+  size_t bin_len = strlen (hex) / 2;\n+  gdb::byte_vector bin (bin_len);\n+\n+  hex2bin (hex, bin.data (), bin_len);\n+\n+  return bin;\n+}"
    },
    {
      "sha": "224e1f3122268b49e598f76158a5c5e84cc6ed5b",
      "filename": "gdbsupport/common-utils.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/common-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/common-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/common-utils.h?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -22,6 +22,7 @@\n \n #include <string>\n #include <vector>\n+#include \"gdbsupport/byte-vector.h\"\n \n #include \"poison.h\"\n \n@@ -191,4 +192,18 @@ in_inclusive_range (T value, T low, T high)\n extern ULONGEST align_up (ULONGEST v, int n);\n extern ULONGEST align_down (ULONGEST v, int n);\n \n+/* Convert hex digit A to a number, or throw an exception.  */\n+extern int fromhex (int a);\n+\n+/* HEX is a string of characters representing hexadecimal digits.\n+   Convert pairs of hex digits to bytes and store sequentially into\n+   BIN.  COUNT is the maximum number of characters to convert.  This\n+   will convert fewer characters if the number of hex characters\n+   actually seen is odd, or if HEX terminates before COUNT characters.\n+   Returns the number of characters actually converted.  */\n+extern int hex2bin (const char *hex, gdb_byte *bin, int count);\n+\n+/* Like the above, but return a gdb::byte_vector.  */\n+gdb::byte_vector hex2bin (const char *hex);\n+\n #endif /* COMMON_COMMON_UTILS_H */"
    },
    {
      "sha": "8900ed4fc04927a873056ff4f0cb80ed904d3585",
      "filename": "gdbsupport/rsp-low.cc",
      "status": "modified",
      "additions": 0,
      "deletions": 49,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/rsp-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/rsp-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/rsp-low.cc?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -22,21 +22,6 @@\n \n /* See rsp-low.h.  */\n \n-int\n-fromhex (int a)\n-{\n-  if (a >= '0' && a <= '9')\n-    return a - '0';\n-  else if (a >= 'a' && a <= 'f')\n-    return a - 'a' + 10;\n-  else if (a >= 'A' && a <= 'F')\n-    return a - 'A' + 10;\n-  else\n-    error (_(\"Reply contains invalid hex digit %d\"), a);\n-}\n-\n-/* See rsp-low.h.  */\n-\n int\n tohex (int nib)\n {\n@@ -111,40 +96,6 @@ unpack_varlen_hex (const char *buff,\t/* packet to parse */\n \n /* See rsp-low.h.  */\n \n-int\n-hex2bin (const char *hex, gdb_byte *bin, int count)\n-{\n-  int i;\n-\n-  for (i = 0; i < count; i++)\n-    {\n-      if (hex[0] == 0 || hex[1] == 0)\n-\t{\n-\t  /* Hex string is short, or of uneven length.\n-\t     Return the count that has been converted so far.  */\n-\t  return i;\n-\t}\n-      *bin++ = fromhex (hex[0]) * 16 + fromhex (hex[1]);\n-      hex += 2;\n-    }\n-  return i;\n-}\n-\n-/* See rsp-low.h.  */\n-\n-gdb::byte_vector\n-hex2bin (const char *hex)\n-{\n-  size_t bin_len = strlen (hex) / 2;\n-  gdb::byte_vector bin (bin_len);\n-\n-  hex2bin (hex, bin.data (), bin_len);\n-\n-  return bin;\n-}\n-\n-/* See rsp-low.h.  */\n-\n std::string\n hex2str (const char *hex)\n {"
    },
    {
      "sha": "6ef4b36a1d4c072bbfda27b2f75c4b8c70f81577",
      "filename": "gdbsupport/rsp-low.h",
      "status": "modified",
      "additions": 0,
      "deletions": 19,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/rsp-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48136e006e324980195e21f70ca4accd7f722ceb/gdbsupport/rsp-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/rsp-low.h?ref=48136e006e324980195e21f70ca4accd7f722ceb",
      "patch": "@@ -20,12 +20,6 @@\n #ifndef COMMON_RSP_LOW_H\n #define COMMON_RSP_LOW_H\n \n-#include \"gdbsupport/byte-vector.h\"\n-\n-/* Convert hex digit A to a number, or throw an exception.  */\n-\n-extern int fromhex (int a);\n-\n /* Convert number NIB to a hex digit.  */\n \n extern int tohex (int nib);\n@@ -45,19 +39,6 @@ extern char *pack_hex_byte (char *pkt, int byte);\n \n extern const char *unpack_varlen_hex (const char *buff, ULONGEST *result);\n \n-/* HEX is a string of characters representing hexadecimal digits.\n-   Convert pairs of hex digits to bytes and store sequentially into\n-   BIN.  COUNT is the maximum number of characters to convert.  This\n-   will convert fewer characters if the number of hex characters\n-   actually seen is odd, or if HEX terminates before COUNT characters.\n-   Returns the number of characters actually converted.  */\n-\n-extern int hex2bin (const char *hex, gdb_byte *bin, int count);\n-\n-/* Like the above, but return a gdb::byte_vector.  */\n-\n-gdb::byte_vector hex2bin (const char *hex);\n-\n /* Like hex2bin, but return a std::string.  */\n \n extern std::string hex2str (const char *hex);"
    }
  ]
}