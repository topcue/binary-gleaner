{
  "sha": "8dbb13755bd15eea33df1dec1c6171f745d9f501",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGRiYjEzNzU1YmQxNWVlYTMzZGYxZGVjMWM2MTcxZjc0NWQ5ZjUwMQ==",
  "commit": {
    "author": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-05-01T12:01:02Z"
    },
    "committer": {
      "name": "Hannes Domani",
      "email": "ssbssa@yahoo.de",
      "date": "2020-05-01T13:32:17Z"
    },
    "message": "Fix size recalculation of fortran arrays\n\nMy recent change regarding size calculation of arrays of stubbed types\ndidn't take array strides and associated/allocated type properties into\naccount, which basically broke fortran arrays.\n\nFixed by refactoring the array size calculation of\ncreate_array_type_with_stride into a new function, and also use it for\nthe stubbed array size recalculation.\n\ngdb/ChangeLog:\n\n2020-05-01  Hannes Domani  <ssbssa@yahoo.de>\n\n\t* gdbtypes.c (update_static_array_size): New function.\n\t(create_array_type_with_stride): Use update_static_array_size.\n\t(check_typedef): Likewise.",
    "tree": {
      "sha": "55374ea4b75fb81efac2bb4a05bac36ff1c27549",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/55374ea4b75fb81efac2bb4a05bac36ff1c27549"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8dbb13755bd15eea33df1dec1c6171f745d9f501",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8dbb13755bd15eea33df1dec1c6171f745d9f501",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8dbb13755bd15eea33df1dec1c6171f745d9f501",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8dbb13755bd15eea33df1dec1c6171f745d9f501/comments",
  "author": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ssbssa",
    "id": 40947,
    "node_id": "MDQ6VXNlcjQwOTQ3",
    "avatar_url": "https://avatars.githubusercontent.com/u/40947?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ssbssa",
    "html_url": "https://github.com/ssbssa",
    "followers_url": "https://api.github.com/users/ssbssa/followers",
    "following_url": "https://api.github.com/users/ssbssa/following{/other_user}",
    "gists_url": "https://api.github.com/users/ssbssa/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ssbssa/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ssbssa/subscriptions",
    "organizations_url": "https://api.github.com/users/ssbssa/orgs",
    "repos_url": "https://api.github.com/users/ssbssa/repos",
    "events_url": "https://api.github.com/users/ssbssa/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ssbssa/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "53ae0aa9c65bc41b6f67f52a657b9f5339a331be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/53ae0aa9c65bc41b6f67f52a657b9f5339a331be",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/53ae0aa9c65bc41b6f67f52a657b9f5339a331be"
    }
  ],
  "stats": {
    "total": 132,
    "additions": 70,
    "deletions": 62
  },
  "files": [
    {
      "sha": "93ef8774a915469a01c06a8ac6fe8243981f0e25",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 70,
      "deletions": 62,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8dbb13755bd15eea33df1dec1c6171f745d9f501/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8dbb13755bd15eea33df1dec1c6171f745d9f501/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=8dbb13755bd15eea33df1dec1c6171f745d9f501",
      "patch": "@@ -1177,6 +1177,64 @@ discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n     }\n }\n \n+/* If the array TYPE has static bounds calculate and update its\n+   size, then return true.  Otherwise return false and leave TYPE\n+   unchanged.  */\n+\n+static bool\n+update_static_array_size (struct type *type)\n+{\n+  gdb_assert (TYPE_CODE (type) == TYPE_CODE_ARRAY);\n+\n+  struct type *range_type = TYPE_INDEX_TYPE (type);\n+\n+  if (get_dyn_prop (DYN_PROP_BYTE_STRIDE, type) == nullptr\n+      && has_static_range (TYPE_RANGE_DATA (range_type))\n+      && (!type_not_associated (type)\n+\t  && !type_not_allocated (type)))\n+    {\n+      LONGEST low_bound, high_bound;\n+      int stride;\n+      struct type *element_type;\n+\n+      /* If the array itself doesn't provide a stride value then take\n+\t whatever stride the range provides.  Don't update BIT_STRIDE as\n+\t we don't want to place the stride value from the range into this\n+\t arrays bit size field.  */\n+      stride = TYPE_FIELD_BITSIZE (type, 0);\n+      if (stride == 0)\n+\tstride = TYPE_BIT_STRIDE (range_type);\n+\n+      if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n+\tlow_bound = high_bound = 0;\n+      element_type = check_typedef (TYPE_TARGET_TYPE (type));\n+      /* Be careful when setting the array length.  Ada arrays can be\n+\t empty arrays with the high_bound being smaller than the low_bound.\n+\t In such cases, the array length should be zero.  */\n+      if (high_bound < low_bound)\n+\tTYPE_LENGTH (type) = 0;\n+      else if (stride != 0)\n+\t{\n+\t  /* Ensure that the type length is always positive, even in the\n+\t     case where (for example in Fortran) we have a negative\n+\t     stride.  It is possible to have a single element array with a\n+\t     negative stride in Fortran (this doesn't mean anything\n+\t     special, it's still just a single element array) so do\n+\t     consider that case when touching this code.  */\n+\t  LONGEST element_count = std::abs (high_bound - low_bound + 1);\n+\t  TYPE_LENGTH (type)\n+\t    = ((std::abs (stride) * element_count) + 7) / 8;\n+\t}\n+      else\n+\tTYPE_LENGTH (type) =\n+\t  TYPE_LENGTH (element_type) * (high_bound - low_bound + 1);\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Create an array type using either a blank type supplied in\n    RESULT_TYPE, or creating a new type, inheriting the objfile from\n    RANGE_TYPE.\n@@ -1222,47 +1280,17 @@ create_array_type_with_stride (struct type *result_type,\n \n   TYPE_CODE (result_type) = TYPE_CODE_ARRAY;\n   TYPE_TARGET_TYPE (result_type) = element_type;\n-  if (byte_stride_prop == NULL\n-      && has_static_range (TYPE_RANGE_DATA (range_type))\n-      && (!type_not_associated (result_type)\n-\t  && !type_not_allocated (result_type)))\n-    {\n-      LONGEST low_bound, high_bound;\n-      int stride;\n \n-      /* If the array itself doesn't provide a stride value then take\n-\t whatever stride the range provides.  Don't update BIT_STRIDE as\n-\t we don't want to place the stride value from the range into this\n-\t arrays bit size field.  */\n-      stride = bit_stride;\n-      if (stride == 0)\n-\tstride = TYPE_BIT_STRIDE (range_type);\n+  TYPE_NFIELDS (result_type) = 1;\n+  TYPE_FIELDS (result_type) =\n+    (struct field *) TYPE_ZALLOC (result_type, sizeof (struct field));\n+  TYPE_INDEX_TYPE (result_type) = range_type;\n+  if (byte_stride_prop != NULL)\n+    add_dyn_prop (DYN_PROP_BYTE_STRIDE, *byte_stride_prop, result_type);\n+  else if (bit_stride > 0)\n+    TYPE_FIELD_BITSIZE (result_type, 0) = bit_stride;\n \n-      if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n-\tlow_bound = high_bound = 0;\n-      element_type = check_typedef (element_type);\n-      /* Be careful when setting the array length.  Ada arrays can be\n-\t empty arrays with the high_bound being smaller than the low_bound.\n-\t In such cases, the array length should be zero.  */\n-      if (high_bound < low_bound)\n-\tTYPE_LENGTH (result_type) = 0;\n-      else if (stride != 0)\n-\t{\n-\t  /* Ensure that the type length is always positive, even in the\n-\t     case where (for example in Fortran) we have a negative\n-\t     stride.  It is possible to have a single element array with a\n-\t     negative stride in Fortran (this doesn't mean anything\n-\t     special, it's still just a single element array) so do\n-\t     consider that case when touching this code.  */\n-\t  LONGEST element_count = std::abs (high_bound - low_bound + 1);\n-\t  TYPE_LENGTH (result_type)\n-\t    = ((std::abs (stride) * element_count) + 7) / 8;\n-\t}\n-      else\n-\tTYPE_LENGTH (result_type) =\n-\t  TYPE_LENGTH (element_type) * (high_bound - low_bound + 1);\n-    }\n-  else\n+  if (!update_static_array_size (result_type))\n     {\n       /* This type is dynamic and its length needs to be computed\n          on demand.  In the meantime, avoid leaving the TYPE_LENGTH\n@@ -1273,15 +1301,6 @@ create_array_type_with_stride (struct type *result_type,\n       TYPE_LENGTH (result_type) = 0;\n     }\n \n-  TYPE_NFIELDS (result_type) = 1;\n-  TYPE_FIELDS (result_type) =\n-    (struct field *) TYPE_ZALLOC (result_type, sizeof (struct field));\n-  TYPE_INDEX_TYPE (result_type) = range_type;\n-  if (byte_stride_prop != NULL)\n-    add_dyn_prop (DYN_PROP_BYTE_STRIDE, *byte_stride_prop, result_type);\n-  else if (bit_stride > 0)\n-    TYPE_FIELD_BITSIZE (result_type, 0) = bit_stride;\n-\n   /* TYPE_TARGET_STUB will take care of zero length arrays.  */\n   if (TYPE_LENGTH (result_type) == 0)\n     TYPE_TARGET_STUB (result_type) = 1;\n@@ -2873,20 +2892,9 @@ check_typedef (struct type *type)\n \t  TYPE_LENGTH (type) = TYPE_LENGTH (target_type);\n \t  TYPE_TARGET_STUB (type) = 0;\n \t}\n-      else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)\n-\t{\n-\t  struct type *range_type = check_typedef (TYPE_INDEX_TYPE (type));\n-\t  if (has_static_range (TYPE_RANGE_DATA (range_type)))\n-\t    {\n-\t      ULONGEST len = 0;\n-\t      LONGEST low_bound = TYPE_LOW_BOUND (range_type);\n-\t      LONGEST high_bound = TYPE_HIGH_BOUND (range_type);\n-\t      if (high_bound >= low_bound)\n-\t\tlen = (high_bound - low_bound + 1) * TYPE_LENGTH (target_type);\n-\t      TYPE_LENGTH (type) = len;\n-\t      TYPE_TARGET_STUB (type) = 0;\n-\t    }\n-\t}\n+      else if (TYPE_CODE (type) == TYPE_CODE_ARRAY\n+\t       && update_static_array_size (type))\n+\tTYPE_TARGET_STUB (type) = 0;\n     }\n \n   type = make_qualified_type (type, instance_flags, NULL);"
    }
  ]
}