{
  "sha": "64c350f2b7930050b869fd3268547452316a19ac",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjRjMzUwZjJiNzkzMDA1MGI4NjlmZDMyNjg1NDc0NTIzMTZhMTlhYw==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:10:22Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:37:35Z"
    },
    "message": "[PATCH, GAS, Arm] Refactor check_simd_pred_availability\n\ngas/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/tc-arm.c (check_simd_pred_availability): Refactor.\n\t(do_neon_dyadic_i_su): Refactor use of check_simd_pred_availability.\n\t(do_neon_dyadic_i64_su): Likewise.\n\t(do_neon_shl): Likewise.\n\t(do_neon_qshl): Likewise.\n\t(do_neon_rshl): Likewise.\n\t(do_neon_logic): Likewise.\n\t(do_neon_dyadic_if_su): Likewise.\n\t(do_neon_addsub_if_i): Likewise.\n\t(do_neon_mac_maybe_scalar): Likewise.\n\t(do_neon_fmac): Likewise.\n\t(do_neon_mul): Likewise.\n\t(do_neon_qdmulh): Likewise.\n\t(do_neon_qrdmlah): Likewise.\n\t(do_neon_abs_neg): Likewise.\n\t(do_neon_sli): Likewise.\n\t(do_neon_sri): Likewise.\n\t(do_neon_qshlu_imm): Likewise.\n\t(do_neon_cvt_1): Likewise.\n\t(do_neon_cvttb_1): Likewise.\n\t(do_neon_mvn): Likewise.\n\t(do_neon_rev): Likewise.\n\t(do_neon_dup): Likewise.\n\t(do_neon_mov): Likewise.\n\t(do_neon_rshift_round_imm): Likewise.\n\t(do_neon_sat_abs_neg): Likewise.\n\t(do_neon_cls): Likewise.\n\t(do_neon_clz): Likewise.\n\t(do_vmaxnm): Likewise.\n\t(do_vrint_1): Likewise.\n\t(do_vcmla): Likewise.\n\t(do_vcadd): Likewise.",
    "tree": {
      "sha": "ac4a161c05d62bd7c35fe001168b1251f27f56aa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ac4a161c05d62bd7c35fe001168b1251f27f56aa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/64c350f2b7930050b869fd3268547452316a19ac",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64c350f2b7930050b869fd3268547452316a19ac",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/64c350f2b7930050b869fd3268547452316a19ac",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64c350f2b7930050b869fd3268547452316a19ac/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "514bbb0fd96e0742bdef8c6c706e5a030323d198",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/514bbb0fd96e0742bdef8c6c706e5a030323d198",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/514bbb0fd96e0742bdef8c6c706e5a030323d198"
    }
  ],
  "stats": {
    "total": 146,
    "additions": 96,
    "deletions": 50
  },
  "files": [
    {
      "sha": "e91e0132c8714449608e08f09378a682738847f9",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64c350f2b7930050b869fd3268547452316a19ac/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64c350f2b7930050b869fd3268547452316a19ac/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=64c350f2b7930050b869fd3268547452316a19ac",
      "patch": "@@ -1,3 +1,38 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/tc-arm.c (check_simd_pred_availability): Refactor.\n+\t(do_neon_dyadic_i_su): Refactor use of check_simd_pred_availability.\n+\t(do_neon_dyadic_i64_su): Likewise.\n+\t(do_neon_shl): Likewise.\n+\t(do_neon_qshl): Likewise.\n+\t(do_neon_rshl): Likewise.\n+\t(do_neon_logic): Likewise.\n+\t(do_neon_dyadic_if_su): Likewise.\n+\t(do_neon_addsub_if_i): Likewise.\n+\t(do_neon_mac_maybe_scalar): Likewise.\n+\t(do_neon_fmac): Likewise.\n+\t(do_neon_mul): Likewise.\n+\t(do_neon_qdmulh): Likewise.\n+\t(do_neon_qrdmlah): Likewise.\n+\t(do_neon_abs_neg): Likewise.\n+\t(do_neon_sli): Likewise.\n+\t(do_neon_sri): Likewise.\n+\t(do_neon_qshlu_imm): Likewise.\n+\t(do_neon_cvt_1): Likewise.\n+\t(do_neon_cvttb_1): Likewise.\n+\t(do_neon_mvn): Likewise.\n+\t(do_neon_rev): Likewise.\n+\t(do_neon_dup): Likewise.\n+\t(do_neon_mov): Likewise.\n+\t(do_neon_rshift_round_imm): Likewise.\n+\t(do_neon_sat_abs_neg): Likewise.\n+\t(do_neon_cls): Likewise.\n+\t(do_neon_clz): Likewise.\n+\t(do_vmaxnm): Likewise.\n+\t(do_vrint_1): Likewise.\n+\t(do_vcmla): Likewise.\n+\t(do_vcadd): Likewise.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* NEWS: Mention Armv8.1-M Mainline and MVE."
    },
    {
      "sha": "ff7f9ad33dfe7010ea1762a37feda2199eda0e7e",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 61,
      "deletions": 50,
      "changes": 111,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/64c350f2b7930050b869fd3268547452316a19ac/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/64c350f2b7930050b869fd3268547452316a19ac/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=64c350f2b7930050b869fd3268547452316a19ac",
      "patch": "@@ -16380,15 +16380,21 @@ if (!thumb_mode && (check & NEON_CHECK_CC))\n return SUCCESS;\n }\n \n-static int\n+\n+/* Return TRUE if the SIMD instruction is available for the current\n+   cpu_variant.  FP is set to TRUE if this is a SIMD floating-point\n+   instruction.  CHECK contains th.  CHECK contains the set of bits to pass to\n+   vfp_or_neon_is_neon for the NEON specific checks.  */\n+\n+static bfd_boolean\n check_simd_pred_availability (int fp, unsigned check)\n {\n if (inst.cond > COND_ALWAYS)\n   {\n     if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n       {\n \tinst.error = BAD_FPU;\n-\treturn 1;\n+\treturn FALSE;\n       }\n     inst.pred_insn_type = INSIDE_VPT_INSN;\n   }\n@@ -16397,26 +16403,26 @@ else if (inst.cond < COND_ALWAYS)\n     if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n       inst.pred_insn_type = MVE_OUTSIDE_PRED_INSN;\n     else if (vfp_or_neon_is_neon (check) == FAIL)\n-      return 2;\n+      return FALSE;\n   }\n else\n   {\n     if (!ARM_CPU_HAS_FEATURE (cpu_variant, fp ? mve_fp_ext : mve_ext)\n \t&& vfp_or_neon_is_neon (check) == FAIL)\n-      return 3;\n+      return FALSE;\n \n     if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n       inst.pred_insn_type = MVE_OUTSIDE_PRED_INSN;\n   }\n-return 0;\n+return TRUE;\n }\n \n /* Neon instruction encoders, in approximate order of appearance.  */\n \n static void\n do_neon_dyadic_i_su (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   enum neon_shape rs;\n@@ -16438,7 +16444,7 @@ do_neon_dyadic_i_su (void)\n static void\n do_neon_dyadic_i64_su (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n   enum neon_shape rs;\n   struct neon_type_el et;\n@@ -16480,7 +16486,7 @@ neon_imm_shift (int write_ubit, int uval, int isquad, struct neon_type_el et,\n static void\n do_neon_shl (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   if (!inst.operands[2].isreg)\n@@ -16560,7 +16566,7 @@ do_neon_shl (void)\n static void\n do_neon_qshl (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   if (!inst.operands[2].isreg)\n@@ -16634,7 +16640,7 @@ do_neon_qshl (void)\n static void\n do_neon_rshl (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   enum neon_shape rs;\n@@ -16748,8 +16754,8 @@ do_neon_logic (void)\n     {\n       enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);\n       if (rs == NS_QQQ\n-\t  && check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC)\n-\t  == FAIL)\n+\t  && !check_simd_pred_availability (FALSE,\n+\t\t\t\t\t    NEON_CHECK_ARCH | NEON_CHECK_CC))\n \treturn;\n       else if (rs != NS_QQQ\n \t       && !ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1))\n@@ -16771,8 +16777,8 @@ do_neon_logic (void)\n       /* Because neon_select_shape makes the second operand a copy of the first\n \t if the second operand is not present.  */\n       if (rs == NS_QQI\n-\t  && check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC)\n-\t  == FAIL)\n+\t  && !check_simd_pred_availability (FALSE,\n+\t\t\t\t\t    NEON_CHECK_ARCH | NEON_CHECK_CC))\n \treturn;\n       else if (rs != NS_QQI\n \t       && !ARM_CPU_HAS_FEATURE (cpu_variant, fpu_neon_ext_v1))\n@@ -17215,8 +17221,8 @@ do_neon_dyadic_if_su (void)\n \t      && et.type == NT_float\n \t      && !ARM_CPU_HAS_FEATURE (cpu_variant,fpu_neon_ext_v1), BAD_FPU);\n \n-  if (check_simd_pred_availability (et.type == NT_float,\n-\t\t\t\t    NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t     NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);\n@@ -17240,8 +17246,8 @@ do_neon_addsub_if_i (void)\n      they are predicated or not.  */\n   if ((rs == NS_QQQ || rs == NS_QQR) && et.size != 64)\n     {\n-      if (check_simd_pred_availability (et.type == NT_float,\n-\t\t\t\t\tNEON_CHECK_ARCH | NEON_CHECK_CC))\n+      if (!check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t\t NEON_CHECK_ARCH | NEON_CHECK_CC))\n \treturn;\n     }\n   else\n@@ -17402,7 +17408,7 @@ do_neon_mac_maybe_scalar (void)\n   if (try_vfp_nsyn (3, do_vfp_nsyn_mla_mls) == SUCCESS)\n     return;\n \n-  if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n \n   if (inst.operands[2].isscalar)\n@@ -17439,7 +17445,7 @@ do_neon_fmac (void)\n       && try_vfp_nsyn (3, do_vfp_nsyn_fma_fms) == SUCCESS)\n     return;\n \n-  if (check_simd_pred_availability (1, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (TRUE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n \n   if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_fp_ext))\n@@ -17493,7 +17499,7 @@ do_neon_mul (void)\n   if (try_vfp_nsyn (3, do_vfp_nsyn_mul) == SUCCESS)\n     return;\n \n-  if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n \n   if (inst.operands[2].isscalar)\n@@ -17526,7 +17532,7 @@ do_neon_mul (void)\n static void\n do_neon_qdmulh (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   if (inst.operands[2].isscalar)\n@@ -17963,7 +17969,7 @@ do_mve_vmaxv (void)\n static void\n do_neon_qrdmlah (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n   if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n     {\n@@ -18043,8 +18049,8 @@ do_neon_abs_neg (void)\n   rs = neon_select_shape (NS_DD, NS_QQ, NS_NULL);\n   et = neon_check_type (2, rs, N_EQK, N_S_32 | N_F_16_32 | N_KEY);\n \n-  if (check_simd_pred_availability (et.type == NT_float,\n-\t\t\t\t    NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t     NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   inst.instruction |= LOW4 (inst.operands[0].reg) << 12;\n@@ -18061,7 +18067,7 @@ do_neon_abs_neg (void)\n static void\n do_neon_sli (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   enum neon_shape rs;\n@@ -18087,7 +18093,7 @@ do_neon_sli (void)\n static void\n do_neon_sri (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   enum neon_shape rs;\n@@ -18112,7 +18118,7 @@ do_neon_sri (void)\n static void\n do_neon_qshlu_imm (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   enum neon_shape rs;\n@@ -18585,7 +18591,8 @@ do_neon_cvt_1 (enum neon_cvt_mode mode)\n \t      || flavour == neon_cvt_flavour_s32_f32\n \t      || flavour == neon_cvt_flavour_u32_f32))\n \t{\n-\t  if (check_simd_pred_availability (1, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+\t  if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t\t     NEON_CHECK_CC | NEON_CHECK_ARCH))\n \t    return;\n \t}\n       else if (mode == neon_cvt_mode_n)\n@@ -18672,8 +18679,8 @@ do_neon_cvt_1 (enum neon_cvt_mode mode)\n \t      || flavour == neon_cvt_flavour_s32_f32\n \t      || flavour == neon_cvt_flavour_u32_f32))\n \t{\n-\t  if (check_simd_pred_availability (1,\n-\t\t\t\t\t    NEON_CHECK_CC | NEON_CHECK_ARCH8))\n+\t  if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t\t     NEON_CHECK_CC | NEON_CHECK_ARCH8))\n \t    return;\n \t}\n       else if (mode == neon_cvt_mode_z\n@@ -18686,8 +18693,8 @@ do_neon_cvt_1 (enum neon_cvt_mode mode)\n \t\t   || flavour == neon_cvt_flavour_s32_f32\n \t\t   || flavour == neon_cvt_flavour_u32_f32))\n \t{\n-\t  if (check_simd_pred_availability (1,\n-\t\t\t\t\t    NEON_CHECK_CC | NEON_CHECK_ARCH))\n+\t  if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t\t     NEON_CHECK_CC | NEON_CHECK_ARCH))\n \t    return;\n \t}\n       /* fall through.  */\n@@ -18696,8 +18703,8 @@ do_neon_cvt_1 (enum neon_cvt_mode mode)\n \t{\n \n \t  NEON_ENCODE (FLOAT, inst);\n-\t  if (check_simd_pred_availability (1,\n-\t\t\t\t\t    NEON_CHECK_CC | NEON_CHECK_ARCH8))\n+\t  if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t\t     NEON_CHECK_CC | NEON_CHECK_ARCH8))\n \t    return;\n \n \t  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;\n@@ -18857,7 +18864,7 @@ do_neon_cvttb_1 (bfd_boolean t)\n   else if (rs == NS_QQ || rs == NS_QQI)\n     {\n       int single_to_half = 0;\n-      if (check_simd_pred_availability (1, NEON_CHECK_ARCH))\n+      if (!check_simd_pred_availability (TRUE, NEON_CHECK_ARCH))\n \treturn;\n \n       enum neon_cvt_flavour flavour = get_neon_cvt_flavour (rs);\n@@ -18997,7 +19004,7 @@ neon_move_immediate (void)\n static void\n do_neon_mvn (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n \n   if (inst.operands[1].isreg)\n@@ -19341,7 +19348,7 @@ do_neon_ext (void)\n static void\n do_neon_rev (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   enum neon_shape rs;\n@@ -19406,7 +19413,7 @@ do_neon_dup (void)\n \tN_8 | N_16 | N_32 | N_KEY, N_EQK);\n       if (rs == NS_QR)\n \t{\n-\t  if (check_simd_pred_availability (0, NEON_CHECK_ARCH))\n+\t  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH))\n \t    return;\n \t}\n       else\n@@ -19572,7 +19579,8 @@ do_neon_mov (void)\n \n     case NS_QQ:  /* case 0/1.  */\n       {\n-\tif (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+\tif (!check_simd_pred_availability (FALSE,\n+\t\t\t\t\t   NEON_CHECK_CC | NEON_CHECK_ARCH))\n \t  return;\n \t/* The architecture manual I have doesn't explicitly state which\n \t   value the U bit should have for register->register moves, but\n@@ -19602,7 +19610,8 @@ do_neon_mov (void)\n       /* fall through.  */\n \n     case NS_QI:  /* case 2/3.  */\n-      if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+      if (!check_simd_pred_availability (FALSE,\n+\t\t\t\t\t NEON_CHECK_CC | NEON_CHECK_ARCH))\n \treturn;\n       inst.instruction = 0x0800010;\n       neon_move_immediate ();\n@@ -19907,7 +19916,7 @@ do_mve_movl (void)\n static void\n do_neon_rshift_round_imm (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n    return;\n \n   enum neon_shape rs;\n@@ -20004,7 +20013,7 @@ do_neon_zip_uzp (void)\n static void\n do_neon_sat_abs_neg (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_CC | NEON_CHECK_ARCH))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_CC | NEON_CHECK_ARCH))\n     return;\n \n   enum neon_shape rs;\n@@ -20040,7 +20049,7 @@ do_neon_recip_est (void)\n static void\n do_neon_cls (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   enum neon_shape rs;\n@@ -20057,7 +20066,7 @@ do_neon_cls (void)\n static void\n do_neon_clz (void)\n {\n-  if (check_simd_pred_availability (0, NEON_CHECK_ARCH | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (FALSE, NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n   enum neon_shape rs;\n@@ -20610,7 +20619,7 @@ do_vmaxnm (void)\n   if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) == SUCCESS)\n     return;\n \n-  if (check_simd_pred_availability (1, NEON_CHECK_CC | NEON_CHECK_ARCH8))\n+  if (!check_simd_pred_availability (TRUE, NEON_CHECK_CC | NEON_CHECK_ARCH8))\n     return;\n \n   neon_dyadic_misc (NT_untyped, N_F_16_32, 0);\n@@ -20674,7 +20683,8 @@ do_vrint_1 (enum neon_cvt_mode mode)\n       if (et.type == NT_invtype)\n \treturn;\n \n-      if (check_simd_pred_availability (1, NEON_CHECK_CC | NEON_CHECK_ARCH8))\n+      if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t\t NEON_CHECK_CC | NEON_CHECK_ARCH8))\n \treturn;\n \n       NEON_ENCODE (FLOAT, inst);\n@@ -20777,7 +20787,8 @@ do_vcmla (void)\n \t      _(\"immediate out of range\"));\n   rot /= 90;\n \n-  if (check_simd_pred_availability (1, NEON_CHECK_ARCH8 | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (TRUE,\n+\t\t\t\t     NEON_CHECK_ARCH8 | NEON_CHECK_CC))\n     return;\n \n   if (inst.operands[2].isscalar)\n@@ -20854,8 +20865,8 @@ do_vcadd (void)\n   if (et.type == NT_invtype)\n     return;\n \n-  if (check_simd_pred_availability (et.type == NT_float, NEON_CHECK_ARCH8\n-\t\t\t\t    | NEON_CHECK_CC))\n+  if (!check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t     NEON_CHECK_ARCH8 | NEON_CHECK_CC))\n     return;\n \n   if (et.type == NT_float)"
    }
  ]
}