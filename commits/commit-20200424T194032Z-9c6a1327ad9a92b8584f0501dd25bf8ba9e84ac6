{
  "sha": "9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWM2YTEzMjdhZDlhOTJiODU4NGYwNTAxZGQyNWJmOGJhOWU4NGFjNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:31Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:32Z"
    },
    "message": "Rewrite the existing variant part code\n\nThis rewrites the existing variant part code to follow the new model\nimplemented in the previous patch.  The old variant part code is\nremoved.\n\nThis only affects Rust for the moment.  I tested this using various\nversion of the Rust compiler, including one that emits old-style enum\ndebuginfo, exercising the quirks code.\n\ngdb/ChangeLog\n2020-04-24  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.c (struct variant_field): Rewrite.\n\t(struct variant_part_builder): New.\n\t(struct nextfield): Remove \"variant\" field.  Add \"offset\".\n\t(struct field_info): Add \"current_variant_part\" and\n\t\"variant_parts\".\n\t(alloc_discriminant_info): Remove.\n\t(alloc_rust_variant): New function.\n\t(quirk_rust_enum): Update.\n\t(dwarf2_add_field): Set \"offset\" member.  Don't handle\n\tDW_TAG_variant_part.\n\t(offset_map_type): New typedef.\n\t(convert_variant_range, create_one_variant)\n\t(create_one_variant_part, create_variant_parts)\n\t(add_variant_property): New functions.\n\t(dwarf2_attach_fields_to_type): Call add_variant_property.\n\t(read_structure_type): Don't handle DW_TAG_variant_part.\n\t(handle_variant_part, handle_variant): New functions.\n\t(handle_struct_member_die): Use them.\n\t(process_structure_scope): Don't handle variant parts.\n\t* gdbtypes.h (TYPE_FLAG_DISCRIMINATED_UNION): Remove.\n\t(struct discriminant_info): Remove.\n\t(enum dynamic_prop_node_kind) <DYN_PROP_DISCRIMINATED>: Remove.\n\t(struct main_type) <flag_discriminated_union>: Remove.\n\t* rust-lang.c (rust_enum_p, rust_empty_enum_p): Rewrite.\n\t(rust_enum_variant): Return int.  Remove \"contents\".  Rewrite.\n\t(rust_print_enum, rust_print_struct_def, rust_evaluate_subexp):\n\tUpdate.\n\t* valops.c (value_union_variant): Remove.\n\t* value.h (value_union_variant): Don't declare.",
    "tree": {
      "sha": "14dec82099b255fd009a7400d2cbbe0c34ab1e80",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/14dec82099b255fd009a7400d2cbbe0c34ab1e80"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b249d2c2c01775fb015b38b272389b8693e414f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b249d2c2c01775fb015b38b272389b8693e414f6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b249d2c2c01775fb015b38b272389b8693e414f6"
    }
  ],
  "stats": {
    "total": 973,
    "additions": 558,
    "deletions": 415
  },
  "files": [
    {
      "sha": "962c997bc9509dace3ba406a72db139c7134bfee",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -1,3 +1,35 @@\n+2020-04-24  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.c (struct variant_field): Rewrite.\n+\t(struct variant_part_builder): New.\n+\t(struct nextfield): Remove \"variant\" field.  Add \"offset\".\n+\t(struct field_info): Add \"current_variant_part\" and\n+\t\"variant_parts\".\n+\t(alloc_discriminant_info): Remove.\n+\t(alloc_rust_variant): New function.\n+\t(quirk_rust_enum): Update.\n+\t(dwarf2_add_field): Set \"offset\" member.  Don't handle\n+\tDW_TAG_variant_part.\n+\t(offset_map_type): New typedef.\n+\t(convert_variant_range, create_one_variant)\n+\t(create_one_variant_part, create_variant_parts)\n+\t(add_variant_property): New functions.\n+\t(dwarf2_attach_fields_to_type): Call add_variant_property.\n+\t(read_structure_type): Don't handle DW_TAG_variant_part.\n+\t(handle_variant_part, handle_variant): New functions.\n+\t(handle_struct_member_die): Use them.\n+\t(process_structure_scope): Don't handle variant parts.\n+\t* gdbtypes.h (TYPE_FLAG_DISCRIMINATED_UNION): Remove.\n+\t(struct discriminant_info): Remove.\n+\t(enum dynamic_prop_node_kind) <DYN_PROP_DISCRIMINATED>: Remove.\n+\t(struct main_type) <flag_discriminated_union>: Remove.\n+\t* rust-lang.c (rust_enum_p, rust_empty_enum_p): Rewrite.\n+\t(rust_enum_variant): Return int.  Remove \"contents\".  Rewrite.\n+\t(rust_print_enum, rust_print_struct_def, rust_evaluate_subexp):\n+\tUpdate.\n+\t* valops.c (value_union_variant): Remove.\n+\t* value.h (value_union_variant): Don't declare.\n+\n 2020-04-24  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (ada_discrete_type_high_bound, ada_discrete_type_low)"
    },
    {
      "sha": "dd808e08e21bc2393dbe9eb9f7dab2693c286462",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 481,
      "deletions": 242,
      "changes": 723,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -1082,29 +1082,52 @@ struct partial_die_info : public allocate_on_obstack\n    and friends.  */\n static int bits_per_byte = 8;\n \n-/* When reading a variant or variant part, we track a bit more\n-   information about the field, and store it in an object of this\n-   type.  */\n+struct variant_part_builder;\n+\n+/* When reading a variant, we track a bit more information about the\n+   field, and store it in an object of this type.  */\n \n struct variant_field\n {\n-  /* If we see a DW_TAG_variant, then this will be the discriminant\n-     value.  */\n-  ULONGEST discriminant_value;\n+  int first_field = -1;\n+  int last_field = -1;\n+\n+  /* A variant can contain other variant parts.  */\n+  std::vector<variant_part_builder> variant_parts;\n+\n   /* If we see a DW_TAG_variant, then this will be set if this is the\n      default branch.  */\n-  bool default_branch;\n-  /* While reading a DW_TAG_variant_part, this will be set if this\n-     field is the discriminant.  */\n-  bool is_discriminant;\n+  bool default_branch = false;\n+  /* If we see a DW_AT_discr_value, then this will be the discriminant\n+     value.  */\n+  ULONGEST discriminant_value = 0;\n+  /* If we see a DW_AT_discr_list, then this is a pointer to the list\n+     data.  */\n+  struct dwarf_block *discr_list_data = nullptr;\n+};\n+\n+/* This represents a DW_TAG_variant_part.  */\n+\n+struct variant_part_builder\n+{\n+  /* The offset of the discriminant field.  */\n+  sect_offset discriminant_offset {};\n+\n+  /* Variants that are direct children of this variant part.  */\n+  std::vector<variant_field> variants;\n+\n+  /* True if we're currently reading a variant.  */\n+  bool processing_variant = false;\n };\n \n struct nextfield\n {\n   int accessibility = 0;\n   int virtuality = 0;\n-  /* Extra information to describe a variant or variant part.  */\n-  struct variant_field variant {};\n+  /* Variant parts need to find the discriminant, which is a DIE\n+     reference.  We track the section offset of each field to make\n+     this link.  */\n+  sect_offset offset;\n   struct field field {};\n };\n \n@@ -1139,6 +1162,13 @@ struct field_info\n        list.  */\n     std::vector<struct decl_field> nested_types_list;\n \n+    /* If non-null, this is the variant part we are currently\n+       reading.  */\n+    variant_part_builder *current_variant_part = nullptr;\n+    /* This holds all the top-level variant parts attached to the type\n+       we're reading.  */\n+    std::vector<variant_part_builder> variant_parts;\n+\n     /* Return the total number of fields (including baseclasses).  */\n     int nfields () const\n     {\n@@ -9116,37 +9146,72 @@ rust_fully_qualify (struct obstack *obstack, const char *p1, const char *p2)\n   return obconcat (obstack, p1, \"::\", p2, (char *) NULL);\n }\n \n-/* A helper that allocates a struct discriminant_info to attach to a\n-   union type.  */\n+/* A helper that allocates a variant part to attach to a Rust enum\n+   type.  OBSTACK is where the results should be allocated.  TYPE is\n+   the type we're processing.  DISCRIMINANT_INDEX is the index of the\n+   discriminant.  It must be the index of one of the fields of TYPE.\n+   DEFAULT_INDEX is the index of the default field; or -1 if there is\n+   no default.  RANGES is indexed by \"effective\" field number (the\n+   field index, but omitting the discriminant and default fields) and\n+   must hold the discriminant values used by the variants.  Note that\n+   RANGES must have a lifetime at least as long as OBSTACK -- either\n+   already allocated on it, or static.  */\n \n-static struct discriminant_info *\n-alloc_discriminant_info (struct type *type, int discriminant_index,\n-\t\t\t int default_index)\n-{\n-  gdb_assert (TYPE_CODE (type) == TYPE_CODE_UNION);\n-  gdb_assert (discriminant_index == -1\n-\t      || (discriminant_index >= 0\n-\t\t  && discriminant_index < TYPE_NFIELDS (type)));\n+static void\n+alloc_rust_variant (struct obstack *obstack, struct type *type,\n+\t\t    int discriminant_index, int default_index,\n+\t\t    gdb::array_view<discriminant_range> ranges)\n+{\n+  /* When DISCRIMINANT_INDEX == -1, we have a univariant enum.  Those\n+     must be handled by the caller.  */\n+  gdb_assert (discriminant_index >= 0\n+\t      && discriminant_index < TYPE_NFIELDS (type));\n   gdb_assert (default_index == -1\n \t      || (default_index >= 0 && default_index < TYPE_NFIELDS (type)));\n \n-  TYPE_FLAG_DISCRIMINATED_UNION (type) = 1;\n+  /* We have one variant for each non-discriminant field.  */\n+  int n_variants = TYPE_NFIELDS (type) - 1;\n \n-  struct discriminant_info *disc\n-    = ((struct discriminant_info *)\n-       TYPE_ZALLOC (type,\n-\t\t    offsetof (struct discriminant_info, discriminants)\n-\t\t    + TYPE_NFIELDS (type) * sizeof (disc->discriminants[0])));\n-  disc->default_index = default_index;\n-  disc->discriminant_index = discriminant_index;\n+  variant *variants = new (obstack) variant[n_variants];\n+  int var_idx = 0;\n+  int range_idx = 0;\n+  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+    {\n+      if (i == discriminant_index)\n+\tcontinue;\n \n-  struct dynamic_prop prop;\n-  prop.kind = PROP_UNDEFINED;\n-  prop.data.baton = disc;\n+      variants[var_idx].first_field = i;\n+      variants[var_idx].last_field = i + 1;\n+\n+      /* The default field does not need a range, but other fields do.\n+\t We skipped the discriminant above.  */\n+      if (i != default_index)\n+\t{\n+\t  variants[var_idx].discriminants = ranges.slice (range_idx, 1);\n+\t  ++range_idx;\n+\t}\n+\n+      ++var_idx;\n+    }\n+\n+  gdb_assert (range_idx == ranges.size ());\n+  gdb_assert (var_idx == n_variants);\n \n-  add_dyn_prop (DYN_PROP_DISCRIMINATED, prop, type);\n+  variant_part *part = new (obstack) variant_part;\n+  part->discriminant_index = discriminant_index;\n+  part->is_unsigned = TYPE_UNSIGNED (TYPE_FIELD_TYPE (type,\n+\t\t\t\t\t\t      discriminant_index));\n+  part->variants = gdb::array_view<variant> (variants, n_variants);\n \n-  return disc;\n+  void *storage = obstack_alloc (obstack, sizeof (gdb::array_view<variant_part>));\n+  gdb::array_view<variant_part> *prop_value\n+    = new (storage) gdb::array_view<variant_part> (part, 1);\n+\n+  struct dynamic_prop prop;\n+  prop.kind = PROP_VARIANT_PARTS;\n+  prop.data.variant_parts = prop_value;\n+\n+  add_dyn_prop (DYN_PROP_VARIANT_PARTS, prop, type);\n }\n \n /* Some versions of rustc emitted enums in an unusual way.\n@@ -9210,55 +9275,44 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  field_type = TYPE_FIELD_TYPE (field_type, index);\n \t}\n \n-      /* Make a union to hold the variants.  */\n-      struct type *union_type = alloc_type (objfile);\n-      TYPE_CODE (union_type) = TYPE_CODE_UNION;\n-      TYPE_NFIELDS (union_type) = 3;\n-      TYPE_FIELDS (union_type)\n+      /* Smash this type to be a structure type.  We have to do this\n+\t because the type has already been recorded.  */\n+      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      TYPE_NFIELDS (type) = 3;\n+      /* Save the field we care about.  */\n+      struct field saved_field = TYPE_FIELD (type, 0);\n+      TYPE_FIELDS (type)\n \t= (struct field *) TYPE_ZALLOC (type, 3 * sizeof (struct field));\n-      TYPE_LENGTH (union_type) = TYPE_LENGTH (type);\n-      set_type_align (union_type, TYPE_RAW_ALIGN (type));\n \n-      /* Put the discriminant must at index 0.  */\n-      TYPE_FIELD_TYPE (union_type, 0) = field_type;\n-      TYPE_FIELD_ARTIFICIAL (union_type, 0) = 1;\n-      TYPE_FIELD_NAME (union_type, 0) = \"<<discriminant>>\";\n-      SET_FIELD_BITPOS (TYPE_FIELD (union_type, 0), bit_offset);\n+      /* Put the discriminant at index 0.  */\n+      TYPE_FIELD_TYPE (type, 0) = field_type;\n+      TYPE_FIELD_ARTIFICIAL (type, 0) = 1;\n+      TYPE_FIELD_NAME (type, 0) = \"<<discriminant>>\";\n+      SET_FIELD_BITPOS (TYPE_FIELD (type, 0), bit_offset);\n \n       /* The order of fields doesn't really matter, so put the real\n \t field at index 1 and the data-less field at index 2.  */\n-      struct discriminant_info *disc\n-\t= alloc_discriminant_info (union_type, 0, 1);\n-      TYPE_FIELD (union_type, 1) = TYPE_FIELD (type, 0);\n-      TYPE_FIELD_NAME (union_type, 1)\n-\t= rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (union_type, 1)));\n-      TYPE_NAME (TYPE_FIELD_TYPE (union_type, 1))\n+      TYPE_FIELD (type, 1) = saved_field;\n+      TYPE_FIELD_NAME (type, 1)\n+\t= rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (type, 1)));\n+      TYPE_NAME (TYPE_FIELD_TYPE (type, 1))\n \t= rust_fully_qualify (&objfile->objfile_obstack, TYPE_NAME (type),\n-\t\t\t      TYPE_FIELD_NAME (union_type, 1));\n+\t\t\t      TYPE_FIELD_NAME (type, 1));\n \n       const char *dataless_name\n \t= rust_fully_qualify (&objfile->objfile_obstack, TYPE_NAME (type),\n \t\t\t      name);\n       struct type *dataless_type = init_type (objfile, TYPE_CODE_VOID, 0,\n \t\t\t\t\t      dataless_name);\n-      TYPE_FIELD_TYPE (union_type, 2) = dataless_type;\n+      TYPE_FIELD_TYPE (type, 2) = dataless_type;\n       /* NAME points into the original discriminant name, which\n \t already has the correct lifetime.  */\n-      TYPE_FIELD_NAME (union_type, 2) = name;\n-      SET_FIELD_BITPOS (TYPE_FIELD (union_type, 2), 0);\n-      disc->discriminants[2] = 0;\n-\n-      /* Smash this type to be a structure type.  We have to do this\n-\t because the type has already been recorded.  */\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n-      TYPE_NFIELDS (type) = 1;\n-      TYPE_FIELDS (type)\n-\t= (struct field *) TYPE_ZALLOC (type, sizeof (struct field));\n+      TYPE_FIELD_NAME (type, 2) = name;\n+      SET_FIELD_BITPOS (TYPE_FIELD (type, 2), 0);\n \n-      /* Install the variant part.  */\n-      TYPE_FIELD_TYPE (type, 0) = union_type;\n-      SET_FIELD_BITPOS (TYPE_FIELD (type, 0), 0);\n-      TYPE_FIELD_NAME (type, 0) = \"<<variants>>\";\n+      /* Indicate that this is a variant type.  */\n+      static discriminant_range ranges[1] = { { 0, 0 } };\n+      alloc_rust_variant (&objfile->objfile_obstack, type, 0, 1, ranges);\n     }\n   /* A union with a single anonymous field is probably an old-style\n      univariant enum.  */\n@@ -9268,31 +9322,13 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t because the type has already been recorded.  */\n       TYPE_CODE (type) = TYPE_CODE_STRUCT;\n \n-      /* Make a union to hold the variants.  */\n-      struct type *union_type = alloc_type (objfile);\n-      TYPE_CODE (union_type) = TYPE_CODE_UNION;\n-      TYPE_NFIELDS (union_type) = TYPE_NFIELDS (type);\n-      TYPE_LENGTH (union_type) = TYPE_LENGTH (type);\n-      set_type_align (union_type, TYPE_RAW_ALIGN (type));\n-      TYPE_FIELDS (union_type) = TYPE_FIELDS (type);\n-\n-      struct type *field_type = TYPE_FIELD_TYPE (union_type, 0);\n+      struct type *field_type = TYPE_FIELD_TYPE (type, 0);\n       const char *variant_name\n \t= rust_last_path_segment (TYPE_NAME (field_type));\n-      TYPE_FIELD_NAME (union_type, 0) = variant_name;\n+      TYPE_FIELD_NAME (type, 0) = variant_name;\n       TYPE_NAME (field_type)\n \t= rust_fully_qualify (&objfile->objfile_obstack,\n \t\t\t      TYPE_NAME (type), variant_name);\n-\n-      /* Install the union in the outer struct type.  */\n-      TYPE_NFIELDS (type) = 1;\n-      TYPE_FIELDS (type)\n-\t= (struct field *) TYPE_ZALLOC (union_type, sizeof (struct field));\n-      TYPE_FIELD_TYPE (type, 0) = union_type;\n-      TYPE_FIELD_NAME (type, 0) = \"<<variants>>\";\n-      SET_FIELD_BITPOS (TYPE_FIELD (type, 0), 0);\n-\n-      alloc_discriminant_info (union_type, -1, 0);\n     }\n   else\n     {\n@@ -9333,33 +9369,20 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t because the type has already been recorded.  */\n       TYPE_CODE (type) = TYPE_CODE_STRUCT;\n \n-      /* Make a union to hold the variants.  */\n+      /* Make space for the discriminant field.  */\n       struct field *disr_field = &TYPE_FIELD (disr_type, 0);\n-      struct type *union_type = alloc_type (objfile);\n-      TYPE_CODE (union_type) = TYPE_CODE_UNION;\n-      TYPE_NFIELDS (union_type) = 1 + TYPE_NFIELDS (type);\n-      TYPE_LENGTH (union_type) = TYPE_LENGTH (type);\n-      set_type_align (union_type, TYPE_RAW_ALIGN (type));\n-      TYPE_FIELDS (union_type)\n-\t= (struct field *) TYPE_ZALLOC (union_type,\n-\t\t\t\t\t(TYPE_NFIELDS (union_type)\n-\t\t\t\t\t * sizeof (struct field)));\n-\n-      memcpy (TYPE_FIELDS (union_type) + 1, TYPE_FIELDS (type),\n+      field *new_fields\n+\t= (struct field *) TYPE_ZALLOC (type, (TYPE_NFIELDS (type)\n+\t\t\t\t\t       * sizeof (struct field)));\n+      memcpy (new_fields + 1, TYPE_FIELDS (type),\n \t      TYPE_NFIELDS (type) * sizeof (struct field));\n+      TYPE_FIELDS (type) = new_fields;\n+      TYPE_NFIELDS (type) = TYPE_NFIELDS (type) + 1;\n \n       /* Install the discriminant at index 0 in the union.  */\n-      TYPE_FIELD (union_type, 0) = *disr_field;\n-      TYPE_FIELD_ARTIFICIAL (union_type, 0) = 1;\n-      TYPE_FIELD_NAME (union_type, 0) = \"<<discriminant>>\";\n-\n-      /* Install the union in the outer struct type.  */\n-      TYPE_FIELD_TYPE (type, 0) = union_type;\n-      TYPE_FIELD_NAME (type, 0) = \"<<variants>>\";\n-      TYPE_NFIELDS (type) = 1;\n-\n-      /* Set the size and offset of the union type.  */\n-      SET_FIELD_BITPOS (TYPE_FIELD (type, 0), 0);\n+      TYPE_FIELD (type, 0) = *disr_field;\n+      TYPE_FIELD_ARTIFICIAL (type, 0) = 1;\n+      TYPE_FIELD_NAME (type, 0) = \"<<discriminant>>\";\n \n       /* We need a way to find the correct discriminant given a\n \t variant name.  For convenience we build a map here.  */\n@@ -9375,35 +9398,46 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t    }\n \t}\n \n-      int n_fields = TYPE_NFIELDS (union_type);\n-      struct discriminant_info *disc\n-\t= alloc_discriminant_info (union_type, 0, -1);\n+      int n_fields = TYPE_NFIELDS (type);\n+      /* We don't need a range entry for the discriminant, but we do\n+\t need one for every other field, as there is no default\n+\t variant.  */\n+      discriminant_range *ranges = XOBNEWVEC (&objfile->objfile_obstack,\n+\t\t\t\t\t      discriminant_range,\n+\t\t\t\t\t      n_fields - 1);\n       /* Skip the discriminant here.  */\n       for (int i = 1; i < n_fields; ++i)\n \t{\n \t  /* Find the final word in the name of this variant's type.\n \t     That name can be used to look up the correct\n \t     discriminant.  */\n \t  const char *variant_name\n-\t    = rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (union_type,\n-\t\t\t\t\t\t\t\t  i)));\n+\t    = rust_last_path_segment (TYPE_NAME (TYPE_FIELD_TYPE (type, i)));\n \n \t  auto iter = discriminant_map.find (variant_name);\n \t  if (iter != discriminant_map.end ())\n-\t    disc->discriminants[i] = iter->second;\n+\t    {\n+\t      ranges[i].low = iter->second;\n+\t      ranges[i].high = iter->second;\n+\t    }\n \n \t  /* Remove the discriminant field, if it exists.  */\n-\t  struct type *sub_type = TYPE_FIELD_TYPE (union_type, i);\n+\t  struct type *sub_type = TYPE_FIELD_TYPE (type, i);\n \t  if (TYPE_NFIELDS (sub_type) > 0)\n \t    {\n \t      --TYPE_NFIELDS (sub_type);\n \t      ++TYPE_FIELDS (sub_type);\n \t    }\n-\t  TYPE_FIELD_NAME (union_type, i) = variant_name;\n+\t  TYPE_FIELD_NAME (type, i) = variant_name;\n \t  TYPE_NAME (sub_type)\n \t    = rust_fully_qualify (&objfile->objfile_obstack,\n \t\t\t\t  TYPE_NAME (type), variant_name);\n \t}\n+\n+      /* Indicate that this is a variant type.  */\n+      alloc_rust_variant (&objfile->objfile_obstack, type, 0, 1,\n+\t\t\t  gdb::array_view<discriminant_range> (ranges,\n+\t\t\t\t\t\t\t       n_fields - 1));\n     }\n }\n \n@@ -14202,6 +14236,8 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       new_field = &fip->fields.back ();\n     }\n \n+  new_field->offset = die->sect_off;\n+\n   attr = dwarf2_attr (die, DW_AT_accessibility, cu);\n   if (attr != nullptr)\n     new_field->accessibility = DW_UNSND (attr);\n@@ -14360,35 +14396,6 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       FIELD_TYPE (*fp) = die_type (die, cu);\n       FIELD_NAME (*fp) = TYPE_NAME (fp->type);\n     }\n-  else if (die->tag == DW_TAG_variant_part)\n-    {\n-      /* process_structure_scope will treat this DIE as a union.  */\n-      process_structure_scope (die, cu);\n-\n-      /* The variant part is relative to the start of the enclosing\n-\t structure.  */\n-      SET_FIELD_BITPOS (*fp, 0);\n-      fp->type = get_die_type (die, cu);\n-      fp->artificial = 1;\n-      fp->name = \"<<variant>>\";\n-\n-      /* Normally a DW_TAG_variant_part won't have a size, but our\n-\t representation requires one, so set it to the maximum of the\n-\t child sizes, being sure to account for the offset at which\n-\t each child is seen.  */\n-      if (TYPE_LENGTH (fp->type) == 0)\n-\t{\n-\t  unsigned max = 0;\n-\t  for (int i = 0; i < TYPE_NFIELDS (fp->type); ++i)\n-\t    {\n-\t      unsigned len = ((TYPE_FIELD_BITPOS (fp->type, i) + 7) / 8\n-\t\t\t      + TYPE_LENGTH (TYPE_FIELD_TYPE (fp->type, i)));\n-\t      if (len > max)\n-\t\tmax = len;\n-\t    }\n-\t  TYPE_LENGTH (fp->type) = max;\n-\t}\n-    }\n   else\n     gdb_assert_not_reached (\"missing case in dwarf2_add_field\");\n }\n@@ -14455,6 +14462,201 @@ dwarf2_add_type_defn (struct field_info *fip, struct die_info *die,\n     fip->nested_types_list.push_back (fp);\n }\n \n+/* A convenience typedef that's used when finding the discriminant\n+   field for a variant part.  */\n+typedef std::unordered_map<sect_offset, int> offset_map_type;\n+\n+/* Compute the discriminant range for a given variant.  OBSTACK is\n+   where the results will be stored.  VARIANT is the variant to\n+   process.  IS_UNSIGNED indicates whether the discriminant is signed\n+   or unsigned.  */\n+\n+static const gdb::array_view<discriminant_range>\n+convert_variant_range (struct obstack *obstack, const variant_field &variant,\n+\t\t       bool is_unsigned)\n+{\n+  std::vector<discriminant_range> ranges;\n+\n+  if (variant.default_branch)\n+    return {};\n+\n+  if (variant.discr_list_data == nullptr)\n+    {\n+      discriminant_range r\n+\t= {variant.discriminant_value, variant.discriminant_value};\n+      ranges.push_back (r);\n+    }\n+  else\n+    {\n+      gdb::array_view<const gdb_byte> data (variant.discr_list_data->data,\n+\t\t\t\t\t    variant.discr_list_data->size);\n+      while (!data.empty ())\n+\t{\n+\t  if (data[0] != DW_DSC_range && data[0] != DW_DSC_label)\n+\t    {\n+\t      complaint (_(\"invalid discriminant marker: %d\"), data[0]);\n+\t      break;\n+\t    }\n+\t  bool is_range = data[0] == DW_DSC_range;\n+\t  data = data.slice (1);\n+\n+\t  ULONGEST low, high;\n+\t  unsigned int bytes_read;\n+\n+\t  if (data.empty ())\n+\t    {\n+\t      complaint (_(\"DW_AT_discr_list missing low value\"));\n+\t      break;\n+\t    }\n+\t  if (is_unsigned)\n+\t    low = read_unsigned_leb128 (nullptr, data.data (), &bytes_read);\n+\t  else\n+\t    low = (ULONGEST) read_signed_leb128 (nullptr, data.data (),\n+\t\t\t\t\t\t &bytes_read);\n+\t  data = data.slice (bytes_read);\n+\n+\t  if (is_range)\n+\t    {\n+\t      if (data.empty ())\n+\t\t{\n+\t\t  complaint (_(\"DW_AT_discr_list missing high value\"));\n+\t\t  break;\n+\t\t}\n+\t      if (is_unsigned)\n+\t\thigh = read_unsigned_leb128 (nullptr, data.data (),\n+\t\t\t\t\t     &bytes_read);\n+\t      else\n+\t\thigh = (LONGEST) read_signed_leb128 (nullptr, data.data (),\n+\t\t\t\t\t\t     &bytes_read);\n+\t      data = data.slice (bytes_read);\n+\t    }\n+\t  else\n+\t    high = low;\n+\n+\t  ranges.push_back ({ low, high });\n+\t}\n+    }\n+\n+  discriminant_range *result = XOBNEWVEC (obstack, discriminant_range,\n+\t\t\t\t\t  ranges.size ());\n+  std::copy (ranges.begin (), ranges.end (), result);\n+  return gdb::array_view<discriminant_range> (result, ranges.size ());\n+}\n+\n+static const gdb::array_view<variant_part> create_variant_parts\n+  (struct obstack *obstack,\n+   const offset_map_type &offset_map,\n+   struct field_info *fi,\n+   const std::vector<variant_part_builder> &variant_parts);\n+\n+/* Fill in a \"struct variant\" for a given variant field.  RESULT is\n+   the variant to fill in.  OBSTACK is where any needed allocations\n+   will be done.  OFFSET_MAP holds the mapping from section offsets to\n+   fields for the type.  FI describes the fields of the type we're\n+   processing.  FIELD is the variant field we're converting.  */\n+\n+static void\n+create_one_variant (variant &result, struct obstack *obstack,\n+\t\t    const offset_map_type &offset_map,\n+\t\t    struct field_info *fi, const variant_field &field)\n+{\n+  result.discriminants = convert_variant_range (obstack, field, false);\n+  result.first_field = field.first_field + fi->baseclasses.size ();\n+  result.last_field = field.last_field + fi->baseclasses.size ();\n+  result.parts = create_variant_parts (obstack, offset_map, fi,\n+\t\t\t\t       field.variant_parts);\n+}\n+\n+/* Fill in a \"struct variant_part\" for a given variant part.  RESULT\n+   is the variant part to fill in.  OBSTACK is where any needed\n+   allocations will be done.  OFFSET_MAP holds the mapping from\n+   section offsets to fields for the type.  FI describes the fields of\n+   the type we're processing.  BUILDER is the variant part to be\n+   converted.  */\n+\n+static void\n+create_one_variant_part (variant_part &result,\n+\t\t\t struct obstack *obstack,\n+\t\t\t const offset_map_type &offset_map,\n+\t\t\t struct field_info *fi,\n+\t\t\t const variant_part_builder &builder)\n+{\n+  auto iter = offset_map.find (builder.discriminant_offset);\n+  if (iter == offset_map.end ())\n+    {\n+      result.discriminant_index = -1;\n+      /* Doesn't matter.  */\n+      result.is_unsigned = false;\n+    }\n+  else\n+    {\n+      result.discriminant_index = iter->second;\n+      result.is_unsigned\n+\t= TYPE_UNSIGNED (FIELD_TYPE\n+\t\t\t (fi->fields[result.discriminant_index].field));\n+    }\n+\n+  size_t n = builder.variants.size ();\n+  variant *output = new (obstack) variant[n];\n+  for (size_t i = 0; i < n; ++i)\n+    create_one_variant (output[i], obstack, offset_map, fi,\n+\t\t\tbuilder.variants[i]);\n+\n+  result.variants = gdb::array_view<variant> (output, n);\n+}\n+\n+/* Create a vector of variant parts that can be attached to a type.\n+   OBSTACK is where any needed allocations will be done.  OFFSET_MAP\n+   holds the mapping from section offsets to fields for the type.  FI\n+   describes the fields of the type we're processing.  VARIANT_PARTS\n+   is the vector to convert.  */\n+\n+static const gdb::array_view<variant_part>\n+create_variant_parts (struct obstack *obstack,\n+\t\t      const offset_map_type &offset_map,\n+\t\t      struct field_info *fi,\n+\t\t      const std::vector<variant_part_builder> &variant_parts)\n+{\n+  if (variant_parts.empty ())\n+    return {};\n+\n+  size_t n = variant_parts.size ();\n+  variant_part *result = new (obstack) variant_part[n];\n+  for (size_t i = 0; i < n; ++i)\n+    create_one_variant_part (result[i], obstack, offset_map, fi,\n+\t\t\t     variant_parts[i]);\n+\n+  return gdb::array_view<variant_part> (result, n);\n+}\n+\n+/* Compute the variant part vector for FIP, attaching it to TYPE when\n+   done.  */\n+\n+static void\n+add_variant_property (struct field_info *fip, struct type *type,\n+\t\t      struct dwarf2_cu *cu)\n+{\n+  /* Map section offsets of fields to their field index.  Note the\n+     field index here does not take the number of baseclasses into\n+     account.  */\n+  offset_map_type offset_map;\n+  for (int i = 0; i < fip->fields.size (); ++i)\n+    offset_map[fip->fields[i].offset] = i;\n+\n+  struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n+  gdb::array_view<variant_part> parts\n+    = create_variant_parts (&objfile->objfile_obstack, offset_map, fip,\n+\t\t\t    fip->variant_parts);\n+\n+  struct dynamic_prop prop;\n+  prop.kind = PROP_VARIANT_PARTS;\n+  prop.data.variant_parts\n+    = ((gdb::array_view<variant_part> *)\n+       obstack_copy (&objfile->objfile_obstack, &parts, sizeof (parts)));\n+\n+  add_dyn_prop (DYN_PROP_VARIANT_PARTS, prop, type);\n+}\n+\n /* Create the vector of fields, and attach it to the type.  */\n \n static void\n@@ -14500,22 +14702,8 @@ dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,\n       TYPE_N_BASECLASSES (type) = fip->baseclasses.size ();\n     }\n \n-  if (TYPE_FLAG_DISCRIMINATED_UNION (type))\n-    {\n-      struct discriminant_info *di = alloc_discriminant_info (type, -1, -1);\n-\n-      for (int index = 0; index < nfields; ++index)\n-\t{\n-\t  struct nextfield &field = fip->fields[index];\n-\n-\t  if (field.variant.is_discriminant)\n-\t    di->discriminant_index = index;\n-\t  else if (field.variant.default_branch)\n-\t    di->default_index = index;\n-\t  else\n-\t    di->discriminants[index] = field.variant.discriminant_value;\n-\t}\n-    }\n+  if (!fip->variant_parts.empty ())\n+    add_variant_property (fip, type, cu);\n \n   /* Copy the saved-up fields into the field vector.  */\n   for (int i = 0; i < nfields; ++i)\n@@ -15085,11 +15273,6 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       TYPE_CODE (type) = TYPE_CODE_UNION;\n     }\n-  else if (die->tag == DW_TAG_variant_part)\n-    {\n-      TYPE_CODE (type) = TYPE_CODE_UNION;\n-      TYPE_FLAG_DISCRIMINATED_UNION (type) = 1;\n-    }\n   else\n     {\n       TYPE_CODE (type) = TYPE_CODE_STRUCT;\n@@ -15163,6 +15346,130 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n   return type;\n }\n \n+static void handle_struct_member_die\n+  (struct die_info *child_die,\n+   struct type *type,\n+   struct field_info *fi,\n+   std::vector<struct symbol *> *template_args,\n+   struct dwarf2_cu *cu);\n+\n+/* A helper for handle_struct_member_die that handles\n+   DW_TAG_variant_part.  */\n+\n+static void\n+handle_variant_part (struct die_info *die, struct type *type,\n+\t\t     struct field_info *fi,\n+\t\t     std::vector<struct symbol *> *template_args,\n+\t\t     struct dwarf2_cu *cu)\n+{\n+  variant_part_builder *new_part;\n+  if (fi->current_variant_part == nullptr)\n+    {\n+      fi->variant_parts.emplace_back ();\n+      new_part = &fi->variant_parts.back ();\n+    }\n+  else if (!fi->current_variant_part->processing_variant)\n+    {\n+      complaint (_(\"nested DW_TAG_variant_part seen \"\n+\t\t   \"- DIE at %s [in module %s]\"),\n+\t\t sect_offset_str (die->sect_off),\n+\t\t objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n+      return;\n+    }\n+  else\n+    {\n+      variant_field &current = fi->current_variant_part->variants.back ();\n+      current.variant_parts.emplace_back ();\n+      new_part = &current.variant_parts.back ();\n+    }\n+\n+  /* When we recurse, we want callees to add to this new variant\n+     part.  */\n+  scoped_restore save_current_variant_part\n+    = make_scoped_restore (&fi->current_variant_part, new_part);\n+\n+  struct attribute *discr = dwarf2_attr (die, DW_AT_discr, cu);\n+  if (discr == NULL)\n+    {\n+      /* It's a univariant form, an extension we support.  */\n+    }\n+  else if (discr->form_is_ref ())\n+    {\n+      struct dwarf2_cu *target_cu = cu;\n+      struct die_info *target_die = follow_die_ref (die, discr, &target_cu);\n+\n+      new_part->discriminant_offset = target_die->sect_off;\n+    }\n+  else\n+    {\n+      complaint (_(\"DW_AT_discr does not have DIE reference form\"\n+\t\t   \" - DIE at %s [in module %s]\"),\n+\t\t sect_offset_str (die->sect_off),\n+\t\t objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n+    }\n+\n+  for (die_info *child_die = die->child;\n+       child_die != NULL;\n+       child_die = child_die->sibling)\n+    handle_struct_member_die (child_die, type, fi, template_args, cu);\n+}\n+\n+/* A helper for handle_struct_member_die that handles\n+   DW_TAG_variant.  */\n+\n+static void\n+handle_variant (struct die_info *die, struct type *type,\n+\t\tstruct field_info *fi,\n+\t\tstd::vector<struct symbol *> *template_args,\n+\t\tstruct dwarf2_cu *cu)\n+{\n+  if (fi->current_variant_part == nullptr)\n+    {\n+      complaint (_(\"saw DW_TAG_variant outside DW_TAG_variant_part \"\n+\t\t   \"- DIE at %s [in module %s]\"),\n+\t\t sect_offset_str (die->sect_off),\n+\t\t objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n+      return;\n+    }\n+  if (fi->current_variant_part->processing_variant)\n+    {\n+      complaint (_(\"nested DW_TAG_variant seen \"\n+\t\t   \"- DIE at %s [in module %s]\"),\n+\t\t sect_offset_str (die->sect_off),\n+\t\t objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n+      return;\n+    }\n+\n+  scoped_restore save_processing_variant\n+    = make_scoped_restore (&fi->current_variant_part->processing_variant,\n+\t\t\t   true);\n+\n+  fi->current_variant_part->variants.emplace_back ();\n+  variant_field &variant = fi->current_variant_part->variants.back ();\n+  variant.first_field = fi->fields.size ();\n+\n+  /* In a variant we want to get the discriminant and also add a\n+     field for our sole member child.  */\n+  struct attribute *discr = dwarf2_attr (die, DW_AT_discr_value, cu);\n+  if (discr == nullptr)\n+    {\n+      discr = dwarf2_attr (die, DW_AT_discr_list, cu);\n+      if (discr == nullptr || DW_BLOCK (discr)->size == 0)\n+\tvariant.default_branch = true;\n+      else\n+\tvariant.discr_list_data = DW_BLOCK (discr);\n+    }\n+  else\n+    variant.discriminant_value = DW_UNSND (discr);\n+\n+  for (die_info *variant_child = die->child;\n+       variant_child != NULL;\n+       variant_child = variant_child->sibling)\n+    handle_struct_member_die (variant_child, type, fi, template_args, cu);\n+\n+  variant.last_field = fi->fields.size ();\n+}\n+\n /* A helper for process_structure_scope that handles a single member\n    DIE.  */\n \n@@ -15173,8 +15480,7 @@ handle_struct_member_die (struct die_info *child_die, struct type *type,\n \t\t\t  struct dwarf2_cu *cu)\n {\n   if (child_die->tag == DW_TAG_member\n-      || child_die->tag == DW_TAG_variable\n-      || child_die->tag == DW_TAG_variant_part)\n+      || child_die->tag == DW_TAG_variable)\n     {\n       /* NOTE: carlton/2002-11-05: A C++ static data member\n \t should be a DW_TAG_member that is a declaration, but\n@@ -15211,41 +15517,10 @@ handle_struct_member_die (struct die_info *child_die, struct type *type,\n       if (arg != NULL)\n \ttemplate_args->push_back (arg);\n     }\n+  else if (child_die->tag == DW_TAG_variant_part)\n+    handle_variant_part (child_die, type, fi, template_args, cu);\n   else if (child_die->tag == DW_TAG_variant)\n-    {\n-      /* In a variant we want to get the discriminant and also add a\n-\t field for our sole member child.  */\n-      struct attribute *discr = dwarf2_attr (child_die, DW_AT_discr_value, cu);\n-\n-      for (die_info *variant_child = child_die->child;\n-\t   variant_child != NULL;\n-\t   variant_child = variant_child->sibling)\n-\t{\n-\t  if (variant_child->tag == DW_TAG_member)\n-\t    {\n-\t      handle_struct_member_die (variant_child, type, fi,\n-\t\t\t\t\ttemplate_args, cu);\n-\t      /* Only handle the one.  */\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* We don't handle this but we might as well report it if we see\n-\t it.  */\n-      if (dwarf2_attr (child_die, DW_AT_discr_list, cu) != nullptr)\n-\t  complaint (_(\"DW_AT_discr_list is not supported yet\"\n-\t\t       \" - DIE at %s [in module %s]\"),\n-\t\t     sect_offset_str (child_die->sect_off),\n-\t\t     objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n-\n-      /* The first field was just added, so we can stash the\n-\t discriminant there.  */\n-      gdb_assert (!fi->fields.empty ());\n-      if (discr == NULL)\n-\tfi->fields.back ().variant.default_branch = true;\n-      else\n-\tfi->fields.back ().variant.discriminant_value = DW_UNSND (discr);\n-    }\n+    handle_variant (child_die, type, fi, template_args, cu);\n }\n \n /* Finish creating a structure or union type, including filling in\n@@ -15262,39 +15537,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n   if (type == NULL)\n     type = read_structure_type (die, cu);\n \n-  /* When reading a DW_TAG_variant_part, we need to notice when we\n-     read the discriminant member, so we can record it later in the\n-     discriminant_info.  */\n-  bool is_variant_part = TYPE_FLAG_DISCRIMINATED_UNION (type);\n-  sect_offset discr_offset {};\n   bool has_template_parameters = false;\n-\n-  if (is_variant_part)\n-    {\n-      struct attribute *discr = dwarf2_attr (die, DW_AT_discr, cu);\n-      if (discr == NULL)\n-\t{\n-\t  /* Maybe it's a univariant form, an extension we support.\n-\t     In this case arrange not to check the offset.  */\n-\t  is_variant_part = false;\n-\t}\n-      else if (discr->form_is_ref ())\n-\t{\n-\t  struct dwarf2_cu *target_cu = cu;\n-\t  struct die_info *target_die = follow_die_ref (die, discr, &target_cu);\n-\n-\t  discr_offset = target_die->sect_off;\n-\t}\n-      else\n-\t{\n-\t  complaint (_(\"DW_AT_discr does not have DIE reference form\"\n-\t\t       \" - DIE at %s [in module %s]\"),\n-\t\t     sect_offset_str (die->sect_off),\n-\t\t     objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n-\t  is_variant_part = false;\n-\t}\n-    }\n-\n   if (die->child != NULL && ! die_is_declaration (die, cu))\n     {\n       struct field_info fi;\n@@ -15305,10 +15548,6 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n       while (child_die && child_die->tag)\n \t{\n \t  handle_struct_member_die (child_die, type, &fi, &template_args, cu);\n-\n-\t  if (is_variant_part && discr_offset == child_die->sect_off)\n-\t    fi.fields.back ().variant.is_discriminant = true;\n-\n \t  child_die = child_die->sibling;\n \t}\n "
    },
    {
      "sha": "134515845f21405f78a9366a26e66d4599924c49",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 0,
      "deletions": 51,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -319,14 +319,6 @@ DEF_ENUM_FLAGS_TYPE (enum type_instance_flag_value, type_instance_flags);\n \n #define TYPE_FLAG_ENUM(t) (TYPE_MAIN_TYPE (t)->flag_flag_enum)\n \n-/* * True if this type is a discriminated union type.  Only valid for\n-   TYPE_CODE_UNION.  A discriminated union stores a reference to the\n-   discriminant field along with the discriminator values in a dynamic\n-   property.  */\n-\n-#define TYPE_FLAG_DISCRIMINATED_UNION(t) \\\n-  (TYPE_MAIN_TYPE (t)->flag_discriminated_union)\n-\n /* * Constant type.  If this is set, the corresponding type has a\n    const modifier.  */\n \n@@ -482,39 +474,6 @@ struct variant_part : allocate_on_obstack\n };\n \n \n-/* * Information needed for a discriminated union.  A discriminated\n-   union is handled somewhat differently from an ordinary union.\n-\n-   One field is designated as the discriminant.  Only one other field\n-   is active at a time; which one depends on the value of the\n-   discriminant and the data in this structure.\n-\n-   Additionally, it is possible to have a univariant discriminated\n-   union.  In this case, the union has just a single field, which is\n-   assumed to be the only active variant -- in this case no\n-   discriminant is provided.  */\n-\n-struct discriminant_info\n-{\n-  /* * The index of the discriminant field.  If -1, then this union\n-     must have just a single field.  */\n-\n-  int discriminant_index;\n-\n-  /* * The index of the default branch of the union.  If -1, then\n-     there is no default branch.  */\n-\n-  int default_index;\n-\n-  /* * The discriminant values corresponding to each branch.  This has\n-     a number of entries equal to the number of fields in this union.\n-     If discriminant_index is not -1, then that entry in this array is\n-     not used.  If default_index is not -1, then that entry in this\n-     array is not used.  */\n-\n-  ULONGEST discriminants[1];\n-};\n-\n enum dynamic_prop_kind\n {\n   PROP_UNDEFINED, /* Not defined.  */\n@@ -591,9 +550,6 @@ enum dynamic_prop_node_kind\n   /* A property providing an array's byte stride.  */\n   DYN_PROP_BYTE_STRIDE,\n \n-  /* A property holding information about a discriminated union.  */\n-  DYN_PROP_DISCRIMINATED,\n-\n   /* A property holding variant parts.  */\n   DYN_PROP_VARIANT_PARTS,\n };\n@@ -831,13 +787,6 @@ struct main_type\n \n   unsigned int flag_flag_enum : 1;\n \n-  /* * True if this type is a discriminated union type.  Only valid\n-     for TYPE_CODE_UNION.  A discriminated union stores a reference to\n-     the discriminant field along with the discriminator values in a\n-     dynamic property.  */\n-\n-  unsigned int flag_discriminated_union : 1;\n-\n   /* * A discriminant telling us which field of the type_specific\n      union is being used for this type, if any.  */\n "
    },
    {
      "sha": "20661e48d96a44d2f2f9ff03793fdb2c33ca88da",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 45,
      "deletions": 70,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -68,38 +68,37 @@ rust_crate_for_block (const struct block *block)\n    enum.  */\n \n static bool\n-rust_enum_p (const struct type *type)\n+rust_enum_p (struct type *type)\n {\n-  return (TYPE_CODE (type) == TYPE_CODE_STRUCT\n-\t  && TYPE_NFIELDS (type) == 1\n-\t  && TYPE_FLAG_DISCRIMINATED_UNION (TYPE_FIELD_TYPE (type, 0)));\n+  /* is_dynamic_type will return true if any field has a dynamic\n+     attribute -- but we only want to check the top level.  */\n+  return TYPE_HAS_VARIANT_PARTS (type);\n }\n \n-/* Return true if TYPE, which must be an enum type, has no\n-   variants.  */\n+/* Return true if TYPE, which must be an already-resolved enum type,\n+   has no variants.  */\n \n static bool\n rust_empty_enum_p (const struct type *type)\n {\n-  gdb_assert (rust_enum_p (type));\n-  /* In Rust the enum always fills the containing structure.  */\n-  gdb_assert (TYPE_FIELD_BITPOS (type, 0) == 0);\n-\n-  return TYPE_NFIELDS (TYPE_FIELD_TYPE (type, 0)) == 0;\n+  return TYPE_NFIELDS (type) == 0;\n }\n \n-/* Given an enum type and contents, find which variant is active.  */\n+/* Given an already-resolved enum type and contents, find which\n+   variant is active.  */\n \n-static struct field *\n-rust_enum_variant (struct type *type, const gdb_byte *contents)\n+static int\n+rust_enum_variant (struct type *type)\n {\n-  /* In Rust the enum always fills the containing structure.  */\n-  gdb_assert (TYPE_FIELD_BITPOS (type, 0) == 0);\n-\n-  struct type *union_type = TYPE_FIELD_TYPE (type, 0);\n+  /* The active variant is simply the first non-artificial field.  */\n+  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+    if (!TYPE_FIELD_ARTIFICIAL (type, i))\n+      return i;\n \n-  int fieldno = value_union_variant (union_type, contents);\n-  return &TYPE_FIELD (union_type, fieldno);\n+  /* Perhaps we could get here by trying to print an Ada variant\n+     record in Rust mode.  Unlikely, but an error is safer than an\n+     assert.  */\n+  error (_(\"Could not find active enum variant\"));\n }\n \n /* See rust-lang.h.  */\n@@ -471,6 +470,11 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n \n   opts.deref_ref = 0;\n \n+  gdb_assert (rust_enum_p (type));\n+  gdb::array_view<const gdb_byte> view (value_contents_for_printing (val),\n+\t\t\t\t\tTYPE_LENGTH (value_type (val)));\n+  type = resolve_dynamic_type (type, view, value_address (val));\n+\n   if (rust_empty_enum_p (type))\n     {\n       /* Print the enum type name here to be more clear.  */\n@@ -480,9 +484,9 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n       return;\n     }\n \n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n-  struct field *variant_field = rust_enum_variant (type, valaddr);\n-  struct type *variant_type = FIELD_TYPE (*variant_field);\n+  int variant_fieldno = rust_enum_variant (type);\n+  val = value_field (val, variant_fieldno);\n+  struct type *variant_type = TYPE_FIELD_TYPE (type, variant_fieldno);\n \n   int nfields = TYPE_NFIELDS (variant_type);\n \n@@ -505,10 +509,6 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n       fprintf_filtered (stream, \"{\");\n     }\n \n-  struct value *union_value = value_field (val, 0);\n-  int fieldno = (variant_field - &TYPE_FIELD (value_type (union_value), 0));\n-  val = value_field (union_value, fieldno);\n-\n   bool first_field = true;\n   for (int j = 0; j < TYPE_NFIELDS (variant_type); j++)\n     {\n@@ -698,8 +698,6 @@ rust_print_struct_def (struct type *type, const char *varstring,\n   bool is_tuple = rust_tuple_type_p (type);\n   bool is_enum = rust_enum_p (type);\n \n-  int enum_discriminant_index = -1;\n-\n   if (for_rust_enum)\n     {\n       /* Already printing an outer enum, so nothing to print here.  */\n@@ -710,25 +708,10 @@ rust_print_struct_def (struct type *type, const char *varstring,\n       if (is_enum)\n \t{\n \t  fputs_filtered (\"enum \", stream);\n-\n-\t  if (rust_empty_enum_p (type))\n-\t    {\n-\t      if (tagname != NULL)\n-\t\t{\n-\t\t  fputs_filtered (tagname, stream);\n-\t\t  fputs_filtered (\" \", stream);\n-\t\t}\n-\t      fputs_filtered (\"{}\", stream);\n-\t      return;\n-\t    }\n-\n-\t  type = TYPE_FIELD_TYPE (type, 0);\n-\n-\t  struct dynamic_prop *discriminant_prop\n-\t    = get_dyn_prop (DYN_PROP_DISCRIMINATED, type);\n-\t  struct discriminant_info *info\n-\t    = (struct discriminant_info *) discriminant_prop->data.baton;\n-\t  enum_discriminant_index = info->discriminant_index;\n+\t  struct dynamic_prop *prop = get_dyn_prop (DYN_PROP_VARIANT_PARTS,\n+\t\t\t\t\t\t    type);\n+\t  if (prop != nullptr && prop->kind == PROP_TYPE)\n+\t    type = prop->data.original_type;\n \t}\n       else if (TYPE_CODE (type) == TYPE_CODE_STRUCT)\n \tfputs_filtered (\"struct \", stream);\n@@ -755,7 +738,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n     {\n       if (field_is_static (&TYPE_FIELD (type, i)))\n \tcontinue;\n-      if (is_enum && i == enum_discriminant_index)\n+      if (is_enum && TYPE_FIELD_ARTIFICIAL (type, i))\n \tcontinue;\n       fields.push_back (i);\n     }\n@@ -772,7 +755,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n       QUIT;\n \n       gdb_assert (!field_is_static (&TYPE_FIELD (type, i)));\n-      gdb_assert (! (is_enum && i == enum_discriminant_index));\n+      gdb_assert (! (is_enum && TYPE_FIELD_ARTIFICIAL (type, i)));\n \n       if (flags->print_offsets)\n \tpodata->update (type, i, stream);\n@@ -1679,20 +1662,16 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n \t    if (rust_enum_p (type))\n \t      {\n+\t\tgdb::array_view<const gdb_byte> view (value_contents (lhs),\n+\t\t\t\t\t\t      TYPE_LENGTH (type));\n+\t\ttype = resolve_dynamic_type (type, view, value_address (lhs));\n+\n \t\tif (rust_empty_enum_p (type))\n \t\t  error (_(\"Cannot access field %d of empty enum %s\"),\n \t\t\t field_number, TYPE_NAME (type));\n \n-\t\tconst gdb_byte *valaddr = value_contents (lhs);\n-\t\tstruct field *variant_field = rust_enum_variant (type, valaddr);\n-\n-\t\tstruct value *union_value = value_primitive_field (lhs, 0, 0,\n-\t\t\t\t\t\t\t\t   type);\n-\n-\t\tint fieldno = (variant_field\n-\t\t\t       - &TYPE_FIELD (value_type (union_value), 0));\n-\t\tlhs = value_primitive_field (union_value, 0, fieldno,\n-\t\t\t\t\t     value_type (union_value));\n+\t\tint fieldno = rust_enum_variant (type);\n+\t\tlhs = value_primitive_field (lhs, 0, fieldno, type);\n \t\touter_type = type;\n \t\ttype = value_type (lhs);\n \t      }\n@@ -1751,20 +1730,16 @@ tuple structs, and tuple-like enum variants\"));\n         type = value_type (lhs);\n         if (TYPE_CODE (type) == TYPE_CODE_STRUCT && rust_enum_p (type))\n \t  {\n+\t    gdb::array_view<const gdb_byte> view (value_contents (lhs),\n+\t\t\t\t\t\t  TYPE_LENGTH (type));\n+\t    type = resolve_dynamic_type (type, view, value_address (lhs));\n+\n \t    if (rust_empty_enum_p (type))\n \t      error (_(\"Cannot access field %s of empty enum %s\"),\n \t\t     field_name, TYPE_NAME (type));\n \n-\t    const gdb_byte *valaddr = value_contents (lhs);\n-\t    struct field *variant_field = rust_enum_variant (type, valaddr);\n-\n-\t    struct value *union_value = value_primitive_field (lhs, 0, 0,\n-\t\t\t\t\t\t\t       type);\n-\n-\t    int fieldno = (variant_field\n-\t\t\t   - &TYPE_FIELD (value_type (union_value), 0));\n-\t    lhs = value_primitive_field (union_value, 0, fieldno,\n-\t\t\t\t\t value_type (union_value));\n+\t    int fieldno = rust_enum_variant (type);\n+\t    lhs = value_primitive_field (lhs, 0, fieldno, type);\n \n \t    struct type *outer_type = type;\n \t    type = value_type (lhs);"
    },
    {
      "sha": "aa995e6eecd1a834df516926d1f1d50f46b406f0",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 0,
      "deletions": 44,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -2233,50 +2233,6 @@ value_struct_elt_bitpos (struct value **argp, int bitpos, struct type *ftype,\n   return NULL;\n }\n \n-/* See value.h.  */\n-\n-int\n-value_union_variant (struct type *union_type, const gdb_byte *contents)\n-{\n-  gdb_assert (TYPE_CODE (union_type) == TYPE_CODE_UNION\n-\t      && TYPE_FLAG_DISCRIMINATED_UNION (union_type));\n-\n-  struct dynamic_prop *discriminant_prop\n-    = get_dyn_prop (DYN_PROP_DISCRIMINATED, union_type);\n-  gdb_assert (discriminant_prop != nullptr);\n-\n-  struct discriminant_info *info\n-    = (struct discriminant_info *) discriminant_prop->data.baton;\n-  gdb_assert (info != nullptr);\n-\n-  /* If this is a univariant union, just return the sole field.  */\n-  if (TYPE_NFIELDS (union_type) == 1)\n-    return 0;\n-  /* This should only happen for univariants, which we already dealt\n-     with.  */\n-  gdb_assert (info->discriminant_index != -1);\n-\n-  /* Compute the discriminant.  Note that unpack_field_as_long handles\n-     sign extension when necessary, as does the DWARF reader -- so\n-     signed discriminants will be handled correctly despite the use of\n-     an unsigned type here.  */\n-  ULONGEST discriminant = unpack_field_as_long (union_type, contents,\n-\t\t\t\t\t\tinfo->discriminant_index);\n-\n-  for (int i = 0; i < TYPE_NFIELDS (union_type); ++i)\n-    {\n-      if (i != info->default_index\n-\t  && i != info->discriminant_index\n-\t  && discriminant == info->discriminants[i])\n-\treturn i;\n-    }\n-\n-  if (info->default_index == -1)\n-    error (_(\"Could not find variant corresponding to discriminant %s\"),\n-\t   pulongest (discriminant));\n-  return info->default_index;\n-}\n-\n /* Search through the methods of an object (and its bases) to find a\n    specified method.  Return a reference to the fn_field list METHODS of\n    overloaded instances defined in the source language.  If available"
    },
    {
      "sha": "ae859ca7224849664a2814a4a9241a8a5c645a8c",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=9c6a1327ad9a92b8584f0501dd25bf8ba9e84ac6",
      "patch": "@@ -1226,14 +1226,6 @@ extern struct type *result_type_of_xmethod (struct value *method,\n extern struct value *call_xmethod (struct value *method,\n \t\t\t\t   gdb::array_view<value *> argv);\n \n-/* Given a discriminated union type and some corresponding value\n-   contents, this will return the field index of the currently active\n-   variant.  This will throw an exception if no active variant can be\n-   found.  */\n-\n-extern int value_union_variant (struct type *union_type,\n-\t\t\t\tconst gdb_byte *contents);\n-\n /* Destroy the values currently allocated.  This is called when GDB is\n    exiting (e.g., on quit_force).  */\n extern void finalize_values ();"
    }
  ]
}