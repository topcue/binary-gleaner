{
  "sha": "c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yzc3ODJlNTBiMTNiNGNhNTIyZGQ2ZGEyYzdjMjI3NjBjOTYwM2U2YQ==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-19T20:37:33Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:55:14Z"
    },
    "message": "AArch64: Implement the memory tagging gdbarch hooks\n\nThis patch implements the memory tagging gdbarch hooks for AArch64, for\nthe MTE feature.\n\ngdb/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* aarch64-linux-tdep.c: Include target.h, arch-utils.h, value.h.\n\t(aarch64_mte_get_atag, aarch64_linux_tagged_address_p)\n\t(aarch64_linux_memtag_mismatch_p, aarch64_linux_set_memtags)\n\t(aarch64_linux_get_memtag, aarch64_linux_memtag_to_string): New\n\tfunctions.\n\t(aarch64_linux_init_abi): Initialize MTE-related gdbarch hooks.\n\t* arch/aarch64-mte-linux.c (aarch64_mte_make_ltag_bits)\n\t(aarch64_mte_make_ltag, aarch64_linux_set_ltag)\n\t(aarch64_linux_get_ltag): New functions.\n\t* arch/aarch64-mte-linux.h (AARCH64_MTE_LOGICAL_TAG_START_BIT)\n\t(AARCH64_MTE_LOGICAL_MAX_VALUE): Define.\n\t(aarch64_mte_make_ltag_bits, aarch64_mte_make_ltag)\n\t(aarch64_mte_set_ltag, aarch64_mte_get_ltag): New prototypes.",
    "tree": {
      "sha": "9565f890c9d345299d95e98a398781fd6fe427cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9565f890c9d345299d95e98a398781fd6fe427cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1e735120b95236b1f0fd8c383e64b02b64909d7c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e735120b95236b1f0fd8c383e64b02b64909d7c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1e735120b95236b1f0fd8c383e64b02b64909d7c"
    }
  ],
  "stats": {
    "total": 277,
    "additions": 277,
    "deletions": 0
  },
  "files": [
    {
      "sha": "03cbd5cf0e161f98ed72afc65b603eefdfd16825",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
      "patch": "@@ -1,3 +1,19 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* aarch64-linux-tdep.c: Include target.h, arch-utils.h, value.h.\n+\t(aarch64_mte_get_atag, aarch64_linux_tagged_address_p)\n+\t(aarch64_linux_memtag_mismatch_p, aarch64_linux_set_memtags)\n+\t(aarch64_linux_get_memtag, aarch64_linux_memtag_to_string): New\n+\tfunctions.\n+\t(aarch64_linux_init_abi): Initialize MTE-related gdbarch hooks.\n+\t* arch/aarch64-mte-linux.c (aarch64_mte_make_ltag_bits)\n+\t(aarch64_mte_make_ltag, aarch64_linux_set_ltag)\n+\t(aarch64_linux_get_ltag): New functions.\n+\t* arch/aarch64-mte-linux.h (AARCH64_MTE_LOGICAL_TAG_START_BIT)\n+\t(AARCH64_MTE_LOGICAL_MAX_VALUE): Define.\n+\t(aarch64_mte_make_ltag_bits, aarch64_mte_make_ltag)\n+\t(aarch64_mte_set_ltag, aarch64_mte_get_ltag): New prototypes.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* linux-tdep.c (struct smaps_vmflags) <memory_tagging>: New flag"
    },
    {
      "sha": "d573f06436a6c53f7f9d5b2208dcfde1b418b47b",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 205,
      "deletions": 0,
      "changes": 205,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
      "patch": "@@ -30,6 +30,7 @@\n #include \"symtab.h\"\n #include \"tramp-frame.h\"\n #include \"trad-frame.h\"\n+#include \"target.h\"\n #include \"target/target.h\"\n #include \"expop.h\"\n \n@@ -47,6 +48,9 @@\n \n #include \"arch/aarch64-mte-linux.h\"\n \n+#include \"arch-utils.h\"\n+#include \"value.h\"\n+\n /* Signal frame handling.\n \n       +------------+  ^\n@@ -1503,6 +1507,182 @@ aarch64_linux_gcc_target_options (struct gdbarch *gdbarch)\n   return {};\n }\n \n+/* Helper to get the allocation tag from a 64-bit ADDRESS.\n+\n+   Return the allocation tag if successful and nullopt otherwise.  */\n+\n+static gdb::optional<CORE_ADDR>\n+aarch64_mte_get_atag (CORE_ADDR address)\n+{\n+  gdb::byte_vector tags;\n+\n+  /* Attempt to fetch the allocation tag.  */\n+  if (!target_fetch_memtags (address, 1, tags,\n+\t\t\t     static_cast<int> (memtag_type::allocation)))\n+    return {};\n+\n+  /* Only one tag should've been returned.  Make sure we got exactly that.  */\n+  if (tags.size () != 1)\n+    error (_(\"Target returned an unexpected number of tags.\"));\n+\n+  /* Although our tags are 4 bits in size, they are stored in a\n+     byte.  */\n+  return tags[0];\n+}\n+\n+/* Implement the tagged_address_p gdbarch method.  */\n+\n+static bool\n+aarch64_linux_tagged_address_p (struct gdbarch *gdbarch, struct value *address)\n+{\n+  gdb_assert (address != nullptr);\n+\n+  CORE_ADDR addr = value_as_address (address);\n+\n+  /* Remove the top byte for the memory range check.  */\n+  addr = address_significant (gdbarch, addr);\n+\n+  /* Check if the page that contains ADDRESS is mapped with PROT_MTE.  */\n+  if (!linux_address_in_memtag_page (addr))\n+    return false;\n+\n+  /* We have a valid tag in the top byte of the 64-bit address.  */\n+  return true;\n+}\n+\n+/* Implement the memtag_matches_p gdbarch method.  */\n+\n+static bool\n+aarch64_linux_memtag_matches_p (struct gdbarch *gdbarch,\n+\t\t\t\tstruct value *address)\n+{\n+  gdb_assert (address != nullptr);\n+\n+  /* Make sure we are dealing with a tagged address to begin with.  */\n+  if (!aarch64_linux_tagged_address_p (gdbarch, address))\n+    return true;\n+\n+  CORE_ADDR addr = value_as_address (address);\n+\n+  /* Fetch the allocation tag for ADDRESS.  */\n+  gdb::optional<CORE_ADDR> atag = aarch64_mte_get_atag (addr);\n+\n+  if (!atag.has_value ())\n+    return true;\n+\n+  /* Fetch the logical tag for ADDRESS.  */\n+  gdb_byte ltag = aarch64_mte_get_ltag (addr);\n+\n+  /* Are the tags the same?  */\n+  return ltag == *atag;\n+}\n+\n+/* Implement the set_memtags gdbarch method.  */\n+\n+static bool\n+aarch64_linux_set_memtags (struct gdbarch *gdbarch, struct value *address,\n+\t\t\t   size_t length, const gdb::byte_vector &tags,\n+\t\t\t   memtag_type tag_type)\n+{\n+  gdb_assert (!tags.empty ());\n+  gdb_assert (address != nullptr);\n+\n+  CORE_ADDR addr = value_as_address (address);\n+\n+  /* Set the logical tag or the allocation tag.  */\n+  if (tag_type == memtag_type::logical)\n+    {\n+      /* When setting logical tags, we don't care about the length, since\n+\t we are only setting a single logical tag.  */\n+      addr = aarch64_mte_set_ltag (addr, tags[0]);\n+\n+      /* Update the value's content with the tag.  */\n+      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+      gdb_byte *srcbuf = value_contents_raw (address);\n+      store_unsigned_integer (srcbuf, sizeof (addr), byte_order, addr);\n+    }\n+  else\n+    {\n+      /* Make sure we are dealing with a tagged address to begin with.  */\n+      if (!aarch64_linux_tagged_address_p (gdbarch, address))\n+\treturn false;\n+\n+      /* With G being the number of tag granules and N the number of tags\n+\t passed in, we can have the following cases:\n+\n+\t 1 - G == N: Store all the N tags to memory.\n+\n+\t 2 - G < N : Warn about having more tags than granules, but write G\n+\t\t     tags.\n+\n+\t 3 - G > N : This is a \"fill tags\" operation.  We should use the tags\n+\t\t     as a pattern to fill the granules repeatedly until we have\n+\t\t     written G tags to memory.\n+      */\n+\n+      size_t g = aarch64_mte_get_tag_granules (addr, length,\n+\t\t\t\t\t       AARCH64_MTE_GRANULE_SIZE);\n+      size_t n = tags.size ();\n+\n+      if (g < n)\n+\twarning (_(\"Got more tags than memory granules.  Tags will be \"\n+\t\t   \"truncated.\"));\n+      else if (g > n)\n+\twarning (_(\"Using tag pattern to fill memory range.\"));\n+\n+      if (!target_store_memtags (addr, length, tags,\n+\t\t\t\t static_cast<int> (memtag_type::allocation)))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+/* Implement the get_memtag gdbarch method.  */\n+\n+static struct value *\n+aarch64_linux_get_memtag (struct gdbarch *gdbarch, struct value *address,\n+\t\t\t  memtag_type tag_type)\n+{\n+  gdb_assert (address != nullptr);\n+\n+  CORE_ADDR addr = value_as_address (address);\n+  CORE_ADDR tag = 0;\n+\n+  /* Get the logical tag or the allocation tag.  */\n+  if (tag_type == memtag_type::logical)\n+    tag = aarch64_mte_get_ltag (addr);\n+  else\n+    {\n+      /* Make sure we are dealing with a tagged address to begin with.  */\n+      if (!aarch64_linux_tagged_address_p (gdbarch, address))\n+\treturn nullptr;\n+\n+      gdb::optional<CORE_ADDR> atag = aarch64_mte_get_atag (addr);\n+\n+      if (!atag.has_value ())\n+\treturn nullptr;\n+\n+      tag = *atag;\n+    }\n+\n+  /* Convert the tag to a value.  */\n+  return value_from_ulongest (builtin_type (gdbarch)->builtin_unsigned_int,\n+\t\t\t      tag);\n+}\n+\n+/* Implement the memtag_to_string gdbarch method.  */\n+\n+static std::string\n+aarch64_linux_memtag_to_string (struct gdbarch *gdbarch, struct value *tag_value)\n+{\n+  if (tag_value == nullptr)\n+    return \"\";\n+\n+  CORE_ADDR tag = value_as_address (tag_value);\n+\n+  return string_printf (\"0x%s\", phex_nz (tag, sizeof (tag)));\n+}\n+\n static void\n aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n@@ -1560,6 +1740,31 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n      data associated with the address.  */\n   set_gdbarch_significant_addr_bit (gdbarch, 56);\n \n+  /* MTE-specific settings and hooks.  */\n+  if (tdep->has_mte ())\n+    {\n+      /* Register a hook for checking if an address is tagged or not.  */\n+      set_gdbarch_tagged_address_p (gdbarch, aarch64_linux_tagged_address_p);\n+\n+      /* Register a hook for checking if there is a memory tag match.  */\n+      set_gdbarch_memtag_matches_p (gdbarch,\n+\t\t\t\t    aarch64_linux_memtag_matches_p);\n+\n+      /* Register a hook for setting the logical/allocation tags for\n+\t a range of addresses.  */\n+      set_gdbarch_set_memtags (gdbarch, aarch64_linux_set_memtags);\n+\n+      /* Register a hook for extracting the logical/allocation tag from an\n+\t address.  */\n+      set_gdbarch_get_memtag (gdbarch, aarch64_linux_get_memtag);\n+\n+      /* Set the allocation tag granule size to 16 bytes.  */\n+      set_gdbarch_memtag_granule_size (gdbarch, AARCH64_MTE_GRANULE_SIZE);\n+\n+      /* Register a hook for converting a memory tag to a string.  */\n+      set_gdbarch_memtag_to_string (gdbarch, aarch64_linux_memtag_to_string);\n+    }\n+\n   /* Initialize the aarch64_linux_record_tdep.  */\n   /* These values are the size of the type that will be used in a system\n      call.  They are obtained from Linux Kernel source.  */"
    },
    {
      "sha": "959c0247ed5dbc7a61ce630fa35f9d5d769f2d80",
      "filename": "gdb/arch/aarch64-mte-linux.c",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/arch/aarch64-mte-linux.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/arch/aarch64-mte-linux.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/aarch64-mte-linux.c?ref=c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
      "patch": "@@ -36,3 +36,41 @@ aarch64_mte_get_tag_granules (CORE_ADDR addr, size_t len, size_t granule_size)\n   /* We always have at least 1 granule.  */\n   return 1 + (e_addr - s_addr) / granule_size;\n }\n+\n+/* See arch/aarch64-mte-linux.h */\n+\n+CORE_ADDR\n+aarch64_mte_make_ltag_bits (CORE_ADDR value)\n+{\n+  return value & AARCH64_MTE_LOGICAL_MAX_VALUE;\n+}\n+\n+/* See arch/aarch64-mte-linux.h */\n+\n+CORE_ADDR\n+aarch64_mte_make_ltag (CORE_ADDR value)\n+{\n+  return (aarch64_mte_make_ltag_bits (value)\n+\t  << AARCH64_MTE_LOGICAL_TAG_START_BIT);\n+}\n+\n+/* See arch/aarch64-mte-linux.h */\n+\n+CORE_ADDR\n+aarch64_mte_set_ltag (CORE_ADDR address, CORE_ADDR tag)\n+{\n+  /* Remove the existing tag.  */\n+  address &= ~aarch64_mte_make_ltag (AARCH64_MTE_LOGICAL_MAX_VALUE);\n+\n+  /* Return the new tagged address.  */\n+  return address | aarch64_mte_make_ltag (tag);\n+}\n+\n+/* See arch/aarch64-mte-linux.h */\n+\n+CORE_ADDR\n+aarch64_mte_get_ltag (CORE_ADDR address)\n+{\n+  CORE_ADDR ltag_addr = address >> AARCH64_MTE_LOGICAL_TAG_START_BIT;\n+  return aarch64_mte_make_ltag_bits (ltag_addr);\n+}"
    },
    {
      "sha": "f517638831cabedd454d9a62fb4981f621f3842b",
      "filename": "gdb/arch/aarch64-mte-linux.h",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/arch/aarch64-mte-linux.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7782e50b13b4ca522dd6da2c7c22760c9603e6a/gdb/arch/aarch64-mte-linux.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/aarch64-mte-linux.h?ref=c7782e50b13b4ca522dd6da2c7c22760c9603e6a",
      "patch": "@@ -32,6 +32,8 @@\n \n /* We have one tag per 16 bytes of memory.  */\n #define AARCH64_MTE_GRANULE_SIZE 16\n+#define AARCH64_MTE_LOGICAL_TAG_START_BIT 56\n+#define AARCH64_MTE_LOGICAL_MAX_VALUE 0xf\n \n /* Memory tag types for AArch64.  */\n enum class aarch64_memtag_type\n@@ -47,4 +49,20 @@ enum class aarch64_memtag_type\n extern size_t aarch64_mte_get_tag_granules (CORE_ADDR addr, size_t len,\n \t\t\t\t\t    size_t granule_size);\n \n+/* Return the 4-bit tag made from VALUE.  */\n+extern CORE_ADDR aarch64_mte_make_ltag_bits (CORE_ADDR value);\n+\n+/* Return the 4-bit tag that can be OR-ed to an address.  */\n+extern CORE_ADDR aarch64_mte_make_ltag (CORE_ADDR value);\n+\n+/* Helper to set the logical TAG for a 64-bit ADDRESS.\n+\n+   It is always possible to set the logical tag.  */\n+extern CORE_ADDR aarch64_mte_set_ltag (CORE_ADDR address, CORE_ADDR tag);\n+\n+/* Helper to get the logical tag from a 64-bit ADDRESS.\n+\n+   It is always possible to get the logical tag.  */\n+extern CORE_ADDR aarch64_mte_get_ltag (CORE_ADDR address);\n+\n #endif /* ARCH_AARCH64_LINUX_H */"
    }
  ]
}