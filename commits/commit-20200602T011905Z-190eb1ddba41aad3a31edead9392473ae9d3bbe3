{
  "sha": "190eb1ddba41aad3a31edead9392473ae9d3bbe3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTkwZWIxZGRiYTQxYWFkM2EzMWVkZWFkOTM5MjQ3M2FlOWQzYmJlMw==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-02T01:18:43Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-02T01:19:05Z"
    },
    "message": "ELF: Move dyn_relocs to struct elf_link_hash_entry\n\nAll ELF backends with shared library support have\n\n  /* Track dynamic relocs copied for this symbol.  */\n  struct elf_dyn_relocs *dyn_relocs;\n\nin symbol hash entry.  Move dyn_relocs to struct elf_link_hash_entry\nto reduce code duplication.\n\n\tPR ld/26067\n\t* elf-bfd.h (elf_link_hash_entry): Add dyn_relocs after size.\n\t* elf-s390-common.c (s390_elf_allocate_ifunc_dyn_relocs):\n\tUpdated.\n\t* elf32-arc.c (elf_arc_link_hash_entry): Remove dyn_relocs.\n\t(elf_arc_link_hash_newfunc): Updated.\n\t* elf32-arm.c (elf32_arm_link_hash_entry): Remove dyn_relocs.\n\t(elf32_arm_link_hash_newfunc): Updated.\n\t(elf32_arm_copy_indirect_symbol): Likewise.\n\t(elf32_arm_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs_for_symbol): Likewise.\n\t* elf32-csky.c (csky_elf_link_hash_entry): Remove dyn_relocs.\n\t(csky_elf_link_hash_newfunc): Updated.\n\t(csky_allocate_dynrelocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(csky_elf_copy_indirect_symbol): Likewise.\n\t* elf32-hppa.c (elf32_hppa_link_hash_entry): Remove dyn_relocs.\n\t(hppa_link_hash_newfunc): Updated.\n\t(elf32_hppa_copy_indirect_symbol): Likewise.\n\t(elf32_hppa_hide_symbol): Likewise.\n\t(elf32_hppa_adjust_dynamic_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(elf32_hppa_relocate_section): Likewise.\n\t* elf32-i386.c (elf_i386_check_relocs): Likewise.\n\t* elf32-lm32.c (elf_lm32_link_hash_entry): Removed.\n\t(lm32_elf_link_hash_newfunc): Likewise.\n\t(lm32_elf_link_hash_table_create): Updated.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(lm32_elf_copy_indirect_symbol): Likewise.\n\t* elf32-m32r.c (elf_m32r_link_hash_entry): Removed.\n\t(m32r_elf_link_hash_newfunc): Likewise.\n\t(m32r_elf_link_hash_table_create): Updated.\n\t(m32r_elf_copy_indirect_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf32-metag.c (elf_metag_link_hash_entry): Remove dyn_relocs.\n\t(metag_link_hash_newfunc): Updated.\n\t(elf_metag_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf32-microblaze.c (elf32_mb_link_hash_entry): Remove\n\tdyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(microblaze_elf_check_relocs): Likewise.\n\t(microblaze_elf_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf32-nds32.c (elf_nds32_link_hash_entry): Remove dyn_relocs.\n\t(nds32_elf_link_hash_newfunc): Updated.\n\t(nds32_elf_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(nds32_elf_check_relocs): Likewise.\n\t* elf32-nios2.c (elf32_nios2_link_hash_entry): Remove dyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(nios2_elf32_copy_indirect_symbol): Likewise.\n\t(nios2_elf32_check_relocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf32-or1k.c (elf_or1k_link_hash_entry): Remove dyn_relocs.\n\t(or1k_elf_link_hash_newfunc): Updated.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(or1k_elf_copy_indirect_symbol): Likewise.\n\t* elf32-ppc.c (ppc_elf_link_hash_entry): Remove dyn_relocs.\n\t(ppc_elf_link_hash_newfunc): Updated.\n\t(ppc_elf_copy_indirect_symbol): Likewise.\n\t(ppc_elf_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(ppc_elf_relocate_section): Likewise.\n\t* elf32-s390.c (elf_s390_link_hash_entry): Remove dyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(elf_s390_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(elf_s390_adjust_dynamic_symbol): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf32-sh.c (elf_sh_link_hash_entry): Remove dyn_relocs.\n\t(sh_elf_link_hash_newfunc): Updated.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(sh_elf_copy_indirect_symbol): Likewise.\n\t(sh_elf_check_relocs): Likewise.\n\t* elf32-tic6x.c (elf32_tic6x_link_hash_entry): Removed.\n\t(elf32_tic6x_link_hash_newfunc): Likewise.\n\t(elf32_tic6x_link_hash_table_create): Updated.\n\t(readonly_dynrelocs): Likewise.\n\t(elf32_tic6x_check_relocs): Likewise.\n\t(elf32_tic6x_allocate_dynrelocs): Likewise.\n\t* elf32-tilepro.c (tilepro_elf_link_hash_entry): Remove\n\tdyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(tilepro_elf_copy_indirect_symbol): Likewise.\n\t(tilepro_elf_check_relocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf64-ppc.c (ppc_link_hash_entry): Remove dyn_relocs.\n\t(ppc64_elf_copy_indirect_symbol): Updated.\n\t(ppc64_elf_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(ppc64_elf_adjust_dynamic_symbol): Likewise.\n\t(dec_dynrel_count): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(ppc64_elf_relocate_section): Likewise.\n\t* elf64-s390.c (elf_s390_link_hash_entry): Remove dyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(elf_s390_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.\n\t* elfnn-aarch64.c (elf_aarch64_link_hash_entry): Remove\n\tdyn_relocs.\n\t(elfNN_aarch64_link_hash_newfunc): Updated.\n\t(elfNN_aarch64_copy_indirect_symbol): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(need_copy_relocation_p): Likewise.\n\t(elfNN_aarch64_allocate_dynrelocs): Likewise.\n\t(elfNN_aarch64_allocate_ifunc_dynrelocs): Likewise.\n\t* elfnn-riscv.c (riscv_elf_link_hash_entry): Remove dyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(riscv_elf_copy_indirect_symbol): Likewise.\n\t(riscv_elf_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elfxx-sparc.c (_bfd_sparc_elf_link_hash_entry): Remove\n\tdyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(_bfd_sparc_elf_copy_indirect_symbol): Likewise.\n\t(_bfd_sparc_elf_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elfxx-tilegx.c (tilegx_elf_link_hash_entry): Remove dyn_relocs.\n\t(link_hash_newfunc): Updated.\n\t(tilegx_elf_copy_indirect_symbol): Likewise.\n\t(tilegx_elf_check_relocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Likewise.\n\t(readonly_dynrelocs): Likewise.\n\t(_bfd_x86_elf_copy_indirect_symbol): Likewise.\n\t* elfxx-x86.h (elf_x86_link_hash_entry): Remove dyn_relocs.",
    "tree": {
      "sha": "3e91583aa4021f3aa2d2ab0ef9ca351a9d5a2be3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3e91583aa4021f3aa2d2ab0ef9ca351a9d5a2be3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/190eb1ddba41aad3a31edead9392473ae9d3bbe3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/190eb1ddba41aad3a31edead9392473ae9d3bbe3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/190eb1ddba41aad3a31edead9392473ae9d3bbe3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/190eb1ddba41aad3a31edead9392473ae9d3bbe3/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b1d12b40da7b0c5a5c834cd6d4c56e8fb61460bf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b1d12b40da7b0c5a5c834cd6d4c56e8fb61460bf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b1d12b40da7b0c5a5c834cd6d4c56e8fb61460bf"
    }
  ],
  "stats": {
    "total": 1154,
    "additions": 520,
    "deletions": 634
  },
  "files": [
    {
      "sha": "a3e777e990dc8f3c5937b181c4ce874a8543561f",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 144,
      "deletions": 0,
      "changes": 144,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -1,3 +1,147 @@\n+2020-06-01  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR ld/26067\n+\t* elf-bfd.h (elf_link_hash_entry): Add dyn_relocs after size.\n+\t* elf-s390-common.c (s390_elf_allocate_ifunc_dyn_relocs):\n+\tUpdated.\n+\t* elf32-arc.c (elf_arc_link_hash_entry): Remove dyn_relocs.\n+\t(elf_arc_link_hash_newfunc): Updated.\n+\t* elf32-arm.c (elf32_arm_link_hash_entry): Remove dyn_relocs.\n+\t(elf32_arm_link_hash_newfunc): Updated.\n+\t(elf32_arm_copy_indirect_symbol): Likewise.\n+\t(elf32_arm_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs_for_symbol): Likewise.\n+\t* elf32-csky.c (csky_elf_link_hash_entry): Remove dyn_relocs.\n+\t(csky_elf_link_hash_newfunc): Updated.\n+\t(csky_allocate_dynrelocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(csky_elf_copy_indirect_symbol): Likewise.\n+\t* elf32-hppa.c (elf32_hppa_link_hash_entry): Remove dyn_relocs.\n+\t(hppa_link_hash_newfunc): Updated.\n+\t(elf32_hppa_copy_indirect_symbol): Likewise.\n+\t(elf32_hppa_hide_symbol): Likewise.\n+\t(elf32_hppa_adjust_dynamic_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(elf32_hppa_relocate_section): Likewise.\n+\t* elf32-i386.c (elf_i386_check_relocs): Likewise.\n+\t* elf32-lm32.c (elf_lm32_link_hash_entry): Removed.\n+\t(lm32_elf_link_hash_newfunc): Likewise.\n+\t(lm32_elf_link_hash_table_create): Updated.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(lm32_elf_copy_indirect_symbol): Likewise.\n+\t* elf32-m32r.c (elf_m32r_link_hash_entry): Removed.\n+\t(m32r_elf_link_hash_newfunc): Likewise.\n+\t(m32r_elf_link_hash_table_create): Updated.\n+\t(m32r_elf_copy_indirect_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf32-metag.c (elf_metag_link_hash_entry): Remove dyn_relocs.\n+\t(metag_link_hash_newfunc): Updated.\n+\t(elf_metag_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf32-microblaze.c (elf32_mb_link_hash_entry): Remove\n+\tdyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(microblaze_elf_check_relocs): Likewise.\n+\t(microblaze_elf_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf32-nds32.c (elf_nds32_link_hash_entry): Remove dyn_relocs.\n+\t(nds32_elf_link_hash_newfunc): Updated.\n+\t(nds32_elf_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(nds32_elf_check_relocs): Likewise.\n+\t* elf32-nios2.c (elf32_nios2_link_hash_entry): Remove dyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(nios2_elf32_copy_indirect_symbol): Likewise.\n+\t(nios2_elf32_check_relocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf32-or1k.c (elf_or1k_link_hash_entry): Remove dyn_relocs.\n+\t(or1k_elf_link_hash_newfunc): Updated.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(or1k_elf_copy_indirect_symbol): Likewise.\n+\t* elf32-ppc.c (ppc_elf_link_hash_entry): Remove dyn_relocs.\n+\t(ppc_elf_link_hash_newfunc): Updated.\n+\t(ppc_elf_copy_indirect_symbol): Likewise.\n+\t(ppc_elf_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(ppc_elf_relocate_section): Likewise.\n+\t* elf32-s390.c (elf_s390_link_hash_entry): Remove dyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(elf_s390_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(elf_s390_adjust_dynamic_symbol): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf32-sh.c (elf_sh_link_hash_entry): Remove dyn_relocs.\n+\t(sh_elf_link_hash_newfunc): Updated.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(sh_elf_copy_indirect_symbol): Likewise.\n+\t(sh_elf_check_relocs): Likewise.\n+\t* elf32-tic6x.c (elf32_tic6x_link_hash_entry): Removed.\n+\t(elf32_tic6x_link_hash_newfunc): Likewise.\n+\t(elf32_tic6x_link_hash_table_create): Updated.\n+\t(readonly_dynrelocs): Likewise.\n+\t(elf32_tic6x_check_relocs): Likewise.\n+\t(elf32_tic6x_allocate_dynrelocs): Likewise.\n+\t* elf32-tilepro.c (tilepro_elf_link_hash_entry): Remove\n+\tdyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(tilepro_elf_copy_indirect_symbol): Likewise.\n+\t(tilepro_elf_check_relocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf64-ppc.c (ppc_link_hash_entry): Remove dyn_relocs.\n+\t(ppc64_elf_copy_indirect_symbol): Updated.\n+\t(ppc64_elf_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(ppc64_elf_adjust_dynamic_symbol): Likewise.\n+\t(dec_dynrel_count): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(ppc64_elf_relocate_section): Likewise.\n+\t* elf64-s390.c (elf_s390_link_hash_entry): Remove dyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(elf_s390_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.\n+\t* elfnn-aarch64.c (elf_aarch64_link_hash_entry): Remove\n+\tdyn_relocs.\n+\t(elfNN_aarch64_link_hash_newfunc): Updated.\n+\t(elfNN_aarch64_copy_indirect_symbol): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(need_copy_relocation_p): Likewise.\n+\t(elfNN_aarch64_allocate_dynrelocs): Likewise.\n+\t(elfNN_aarch64_allocate_ifunc_dynrelocs): Likewise.\n+\t* elfnn-riscv.c (riscv_elf_link_hash_entry): Remove dyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(riscv_elf_copy_indirect_symbol): Likewise.\n+\t(riscv_elf_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elfxx-sparc.c (_bfd_sparc_elf_link_hash_entry): Remove\n+\tdyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(_bfd_sparc_elf_copy_indirect_symbol): Likewise.\n+\t(_bfd_sparc_elf_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elfxx-tilegx.c (tilegx_elf_link_hash_entry): Remove dyn_relocs.\n+\t(link_hash_newfunc): Updated.\n+\t(tilegx_elf_copy_indirect_symbol): Likewise.\n+\t(tilegx_elf_check_relocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Likewise.\n+\t(readonly_dynrelocs): Likewise.\n+\t(_bfd_x86_elf_copy_indirect_symbol): Likewise.\n+\t* elfxx-x86.h (elf_x86_link_hash_entry): Remove dyn_relocs.\n+\n 2020-06-01  Alan Modra  <amodra@gmail.com>\n \n \t* vms-alpha.c (_bfd_vms_slurp_etir): Check bound for the current"
    },
    {
      "sha": "a979ad3f7b6e5e889a9631d0a1f1d7d9861cd184",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -156,9 +156,13 @@ struct elf_link_hash_entry\n   /* Same, but tracks a procedure linkage table entry.  */\n   union gotplt_union plt;\n \n-  /* Symbol size.  */\n+  /* Symbol size.  NB: All fields starting from here are cleared by\n+    _bfd_elf_link_hash_newfunc.  */\n   bfd_size_type size;\n \n+  /* Track dynamic relocs copied for this symbol.  */\n+  struct elf_dyn_relocs *dyn_relocs;\n+\n   /* Symbol type (STT_NOTYPE, STT_OBJECT, etc.).  */\n   unsigned int type : 8;\n "
    },
    {
      "sha": "ebe881fcb6e587c299927aac741413272ea0225e",
      "filename": "bfd/elf-s390-common.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf-s390-common.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf-s390-common.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-s390-common.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -170,7 +170,7 @@ s390_elf_allocate_ifunc_dyn_relocs (struct bfd_link_info *info,\n   struct elf_dyn_relocs *p;\n   struct elf_link_hash_table *htab;\n   struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry*)h;\n-  struct elf_dyn_relocs **head = &eh->dyn_relocs;\n+  struct elf_dyn_relocs **head = &h->dyn_relocs;\n \n   htab = elf_hash_table (info);\n   eh->ifunc_resolver_address = h->root.u.def.value;"
    },
    {
      "sha": "774d3e793db2b5ec24d98561b054b40811f58088",
      "filename": "bfd/elf32-arc.c",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arc.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -184,9 +184,6 @@ struct elf_arc_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   struct got_entry *got_ents;\n };\n \n@@ -340,7 +337,6 @@ elf_arc_link_hash_newfunc (struct bfd_hash_entry *entry,\n \t\t\t\t     table, string));\n   if (ret != NULL)\n     {\n-      ret->dyn_relocs = NULL;\n       ret->got_ents = NULL;\n     }\n "
    },
    {
      "sha": "f31eb8c9c70ed09a06ba4783e80d89b04c79632f",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 16,
      "deletions": 20,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -3215,9 +3215,6 @@ struct elf32_arm_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* ARM-specific PLT information.  */\n   struct arm_plt_info plt;\n \n@@ -3582,7 +3579,6 @@ elf32_arm_link_hash_newfunc (struct bfd_hash_entry * entry,\n \t\t\t\t     table, string));\n   if (ret != NULL)\n     {\n-      ret->dyn_relocs = NULL;\n       ret->tls_type = GOT_UNKNOWN;\n       ret->tlsdesc_got = (bfd_vma) -1;\n       ret->plt.thumb_refcount = 0;\n@@ -4032,20 +4028,20 @@ elf32_arm_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf32_arm_link_hash_entry *) dir;\n   eind = (struct elf32_arm_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -4056,11 +4052,11 @@ elf32_arm_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect)\n@@ -15714,7 +15710,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t  /* If this is a global symbol, count the number of\n \t     relocations we need for this symbol.  */\n \t  if (h != NULL)\n-\t    head = &((struct elf32_arm_link_hash_entry *) h)->dyn_relocs;\n+\t    head = &h->dyn_relocs;\n \t  else\n \t    {\n \t      head = elf32_arm_get_local_dynreloc_list (abfd, r_symndx, isym);\n@@ -16100,7 +16096,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf32_arm_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -16595,7 +16591,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n       h->root.u.def.value = th->root.u.def.value & ~1;\n     }\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -16616,7 +16612,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -16631,7 +16627,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      if (strcmp (p->sec->output_section->name, \".tls_vars\") == 0)\n \t\t*pp = p->next;\n@@ -16642,12 +16638,12 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -16698,13 +16694,13 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n "
    },
    {
      "sha": "4be7ea8aa60304a230cf51a93f44e132ed6f9db3",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 17,
      "deletions": 20,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -1163,8 +1163,6 @@ struct csky_elf_link_hash_entry\n   int plt_refcount;\n   /* For sub jsri2bsr relocs count.  */\n   int jsri2bsr_refcount;\n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n \n #define GOT_UNKNOWN     0\n #define GOT_NORMAL      1\n@@ -1429,7 +1427,6 @@ csky_elf_link_hash_newfunc (struct bfd_hash_entry * entry,\n       struct csky_elf_link_hash_entry *eh;\n \n       eh = (struct csky_elf_link_hash_entry *) ret;\n-      eh->dyn_relocs = NULL;\n       eh->plt_refcount = 0;\n       eh->jsri2bsr_refcount = 0;\n       eh->tls_type = GOT_NORMAL;\n@@ -1804,7 +1801,7 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n     h->got.offset = (bfd_vma) -1;\n \n   eh = (struct csky_elf_link_hash_entry *) h;\n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -1819,7 +1816,7 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -1832,17 +1829,17 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \n       if (eh->jsri2bsr_refcount\n \t  && h->root.type == bfd_link_hash_defined\n-\t  && eh->dyn_relocs != NULL)\n-\teh->dyn_relocs->count -= eh->jsri2bsr_refcount;\n+\t  && h->dyn_relocs != NULL)\n+\th->dyn_relocs->count -= eh->jsri2bsr_refcount;\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -1881,13 +1878,13 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n       keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *srelgot = htab->elf.srelgot;\n       srelgot->size += p->count * sizeof (Elf32_External_Rela);\n@@ -1901,7 +1898,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = csky_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2465,20 +2462,20 @@ csky_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct csky_elf_link_hash_entry *) dir;\n   eind = (struct csky_elf_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -2489,10 +2486,10 @@ csky_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n   if (ind->root.type == bfd_link_hash_indirect\n       && dir->got.refcount <= 0)\n@@ -2687,7 +2684,7 @@ csky_elf_check_relocs (bfd * abfd,\n \t\t      || (ELF32_R_TYPE (rel->r_info)\n \t\t\t  == R_CKCORE_PCREL_JSR_IMM11BY2))\n \t\t    eh->jsri2bsr_refcount += 1;\n-\t\t  head = &eh->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t}\n \t      else\n \t\t{"
    },
    {
      "sha": "ef32ba75cde142cfe9d805859e6178f1231642fe",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 22,
      "deletions": 29,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -231,10 +231,6 @@ struct elf32_hppa_link_hash_entry\n      symbol.  */\n   struct elf32_hppa_stub_hash_entry *hsh_cache;\n \n-  /* Used to count relocations for delayed sizing of relocation\n-     sections.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   ENUM_BITFIELD (_tls_type) tls_type : 8;\n \n   /* Set if this symbol is used by a plabel reloc.  */\n@@ -390,7 +386,6 @@ hppa_link_hash_newfunc (struct bfd_hash_entry *entry,\n       /* Initialize the local fields.  */\n       hh = hppa_elf_hash_entry (entry);\n       hh->hsh_cache = NULL;\n-      hh->dyn_relocs = NULL;\n       hh->plabel = 0;\n       hh->tls_type = GOT_UNKNOWN;\n     }\n@@ -1045,21 +1040,21 @@ elf32_hppa_copy_indirect_symbol (struct bfd_link_info *info,\n   hh_dir = hppa_elf_hash_entry (eh_dir);\n   hh_ind = hppa_elf_hash_entry (eh_ind);\n \n-  if (hh_ind->dyn_relocs != NULL\n+  if (eh_ind->dyn_relocs != NULL\n       && eh_ind->root.type == bfd_link_hash_indirect)\n     {\n-      if (hh_dir->dyn_relocs != NULL)\n+      if (eh_dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **hdh_pp;\n \t  struct elf_dyn_relocs *hdh_p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (hdh_pp = &hh_ind->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n+\t  for (hdh_pp = &eh_ind->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *hdh_q;\n \n-\t      for (hdh_q = hh_dir->dyn_relocs;\n+\t      for (hdh_q = eh_dir->dyn_relocs;\n \t\t   hdh_q != NULL;\n \t\t   hdh_q = hdh_q->next)\n \t\tif (hdh_q->sec == hdh_p->sec)\n@@ -1074,11 +1069,11 @@ elf32_hppa_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (hdh_q == NULL)\n \t\thdh_pp = &hdh_p->next;\n \t    }\n-\t  *hdh_pp = hh_dir->dyn_relocs;\n+\t  *hdh_pp = eh_dir->dyn_relocs;\n \t}\n \n-      hh_dir->dyn_relocs = hh_ind->dyn_relocs;\n-      hh_ind->dyn_relocs = NULL;\n+      eh_dir->dyn_relocs = eh_ind->dyn_relocs;\n+      eh_ind->dyn_relocs = NULL;\n     }\n \n   if (eh_ind->root.type == bfd_link_hash_indirect)\n@@ -1494,7 +1489,7 @@ elf32_hppa_check_relocs (bfd *abfd,\n \t\t relocations we need for this symbol.  */\n \t      if (hh != NULL)\n \t\t{\n-\t\t  hdh_head = &hh->dyn_relocs;\n+\t\t  hdh_head = &hh->eh.dyn_relocs;\n \t\t}\n \t      else\n \t\t{\n@@ -1664,11 +1659,9 @@ elf32_hppa_hide_symbol (struct bfd_link_info *info,\n static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *eh)\n {\n-  struct elf32_hppa_link_hash_entry *hh;\n   struct elf_dyn_relocs *hdh_p;\n \n-  hh = hppa_elf_hash_entry (eh);\n-  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n+  for (hdh_p = eh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n     {\n       asection *sec = hdh_p->sec->output_section;\n \n@@ -1719,7 +1712,7 @@ elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,\n       /* Discard dyn_relocs when non-pic if we've decided that a\n \t function symbol is local.  */\n       if (!bfd_link_pic (info) && local)\n-\thppa_elf_hash_entry (eh)->dyn_relocs = NULL;\n+\teh->dyn_relocs = NULL;\n \n       /* If the symbol is used by a plabel, we must allocate a PLT slot.\n \t The refcounts are not reliable when it has been hidden since\n@@ -1769,7 +1762,7 @@ elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,\n       eh->root.u.def.value = def->root.u.def.value;\n       if (def->root.u.def.section == htab->etab.sdynbss\n \t  || def->root.u.def.section == htab->etab.sdynrelro)\n-\thppa_elf_hash_entry (eh)->dyn_relocs = NULL;\n+\teh->dyn_relocs = NULL;\n       return TRUE;\n     }\n \n@@ -1827,7 +1820,7 @@ elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,\n     }\n \n   /* We no longer want dyn_relocs.  */\n-  hppa_elf_hash_entry (eh)->dyn_relocs = NULL;\n+  eh->dyn_relocs = NULL;\n   return _bfd_elf_adjust_dynamic_copy (info, eh, sec);\n }\n \n@@ -2012,15 +2005,15 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \n   /* If no dynamic sections we can't have dynamic relocs.  */\n   if (!htab->etab.dynamic_sections_created)\n-    hh->dyn_relocs = NULL;\n+    eh->dyn_relocs = NULL;\n \n   /* Discard relocs on undefined syms with non-default visibility.  */\n   else if ((eh->root.type == bfd_link_hash_undefined\n \t    && ELF_ST_VISIBILITY (eh->other) != STV_DEFAULT)\n \t   || UNDEFWEAK_NO_DYNAMIC_RELOC (info, eh))\n-    hh->dyn_relocs = NULL;\n+    eh->dyn_relocs = NULL;\n \n-  if (hh->dyn_relocs == NULL)\n+  if (eh->dyn_relocs == NULL)\n     return TRUE;\n \n   /* If this is a -Bsymbolic shared link, then we need to discard all\n@@ -2035,7 +2028,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \t{\n \t  struct elf_dyn_relocs **hdh_pp;\n \n-\t  for (hdh_pp = &hh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n+\t  for (hdh_pp = &eh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n \t    {\n \t      hdh_p->count -= hdh_p->pc_count;\n \t      hdh_p->pc_count = 0;\n@@ -2047,7 +2040,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \t}\n #endif\n \n-      if (hh->dyn_relocs != NULL)\n+      if (eh->dyn_relocs != NULL)\n \t{\n \t  if (!ensure_undef_dynamic (info, eh))\n \t    return FALSE;\n@@ -2067,14 +2060,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \t    return FALSE;\n \n \t  if (eh->dynindx == -1)\n-\t    hh->dyn_relocs = NULL;\n+\t    eh->dyn_relocs = NULL;\n \t}\n       else\n-\thh->dyn_relocs = NULL;\n+\teh->dyn_relocs = NULL;\n     }\n \n   /* Finally, allocate space.  */\n-  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n+  for (hdh_p = eh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n     {\n       asection *sreloc = elf_section_data (hdh_p->sec)->sreloc;\n       sreloc->size += hdh_p->count * sizeof (Elf32_External_Rela);\n@@ -3909,11 +3902,11 @@ elf32_hppa_relocate_section (bfd *output_bfd,\n \n \t  if (bfd_link_pic (info)\n \t      ? ((hh == NULL\n-\t\t  || hh->dyn_relocs != NULL)\n+\t\t  || hh->eh.dyn_relocs != NULL)\n \t\t && ((hh != NULL && pc_dynrelocs (hh))\n \t\t     || IS_ABSOLUTE_RELOC (r_type)))\n \t      : (hh != NULL\n-\t\t && hh->dyn_relocs != NULL))\n+\t\t && hh->eh.dyn_relocs != NULL))\n \t    {\n \t      Elf_Internal_Rela outrel;\n \t      bfd_boolean skip;"
    },
    {
      "sha": "544b9315521ef9ea46f72d2388cea0df68b7c0b7",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -1867,7 +1867,7 @@ elf_i386_check_relocs (bfd *abfd,\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n \t\t{\n-\t\t  head = &eh->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t}\n \t      else\n \t\t{"
    },
    {
      "sha": "0fe09bf44a0dd6b3252857b79b1afb72c6c7375d",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 16,
      "deletions": 69,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -50,16 +50,6 @@ extern const bfd_target lm32_elf32_fdpic_vec;\n static bfd_reloc_status_type lm32_elf_gprel_reloc\n   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n \n-/* lm32 ELF linker hash entry.  */\n-\n-struct elf_lm32_link_hash_entry\n-{\n-  struct elf_link_hash_entry root;\n-\n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-};\n-\n /* lm32 ELF linker hash table.  */\n \n struct elf_lm32_link_hash_table\n@@ -93,39 +83,6 @@ struct weak_symbol_list\n   struct weak_symbol_list *next;\n };\n \n-/* Create an entry in an lm32 ELF linker hash table.  */\n-\n-static struct bfd_hash_entry *\n-lm32_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n-\t\t\t    struct bfd_hash_table *table,\n-\t\t\t    const char *string)\n-{\n-  struct elf_lm32_link_hash_entry *ret =\n-    (struct elf_lm32_link_hash_entry *) entry;\n-\n-  /* Allocate the structure if it has not already been allocated by a\n-     subclass.  */\n-  if (ret == NULL)\n-    ret = bfd_hash_allocate (table,\n-\t\t\t     sizeof (struct elf_lm32_link_hash_entry));\n-  if (ret == NULL)\n-    return NULL;\n-\n-  /* Call the allocation method of the superclass.  */\n-  ret = ((struct elf_lm32_link_hash_entry *)\n-\t _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,\n-\t\t\t\t     table, string));\n-  if (ret != NULL)\n-    {\n-      struct elf_lm32_link_hash_entry *eh;\n-\n-      eh = (struct elf_lm32_link_hash_entry *) ret;\n-      eh->dyn_relocs = NULL;\n-    }\n-\n-  return (struct bfd_hash_entry *) ret;\n-}\n-\n /* Create an lm32 ELF linker hash table.  */\n \n static struct bfd_link_hash_table *\n@@ -139,8 +96,8 @@ lm32_elf_link_hash_table_create (bfd *abfd)\n     return NULL;\n \n   if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,\n-\t\t\t\t      lm32_elf_link_hash_newfunc,\n-\t\t\t\t      sizeof (struct elf_lm32_link_hash_entry),\n+\t\t\t\t      _bfd_elf_link_hash_newfunc,\n+\t\t\t\t      sizeof (struct elf_link_hash_entry),\n \t\t\t\t      LM32_ELF_DATA))\n     {\n       free (ret);\n@@ -1648,9 +1605,8 @@ static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n-  struct elf_lm32_link_hash_entry *eh = (struct elf_lm32_link_hash_entry *) h;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -1794,7 +1750,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n {\n   struct bfd_link_info *info;\n   struct elf_lm32_link_hash_table *htab;\n-  struct elf_lm32_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1805,8 +1760,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   if (htab == NULL)\n     return FALSE;\n \n-  eh = (struct elf_lm32_link_hash_entry *) h;\n-\n   if (htab->root.dynamic_sections_created\n       && h->plt.refcount > 0)\n     {\n@@ -1889,7 +1842,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -1906,7 +1859,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -1919,11 +1872,11 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -1963,13 +1916,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);\n@@ -2461,26 +2414,20 @@ lm32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t\t\t       struct elf_link_hash_entry *dir,\n \t\t\t       struct elf_link_hash_entry *ind)\n {\n-  struct elf_lm32_link_hash_entry * edir;\n-  struct elf_lm32_link_hash_entry * eind;\n-\n-  edir = (struct elf_lm32_link_hash_entry *) dir;\n-  eind = (struct elf_lm32_link_hash_entry *) ind;\n-\n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -2491,11 +2438,11 @@ lm32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   _bfd_elf_link_hash_copy_indirect (info, dir, ind);"
    },
    {
      "sha": "c147b713de360e73293a5fb0974ff037ec34b2f6",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 17,
      "deletions": 70,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -1498,16 +1498,6 @@ struct elf_m32r_pcrel_relocs_copied\n   bfd_size_type count;\n };\n \n-/* m32r ELF linker hash entry.  */\n-\n-struct elf_m32r_link_hash_entry\n-{\n-  struct elf_link_hash_entry root;\n-\n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-};\n-\n /* m32r ELF linker hash table.  */\n \n struct elf_m32r_link_hash_table\n@@ -1536,39 +1526,6 @@ struct elf_m32r_link_hash_table\n   (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \\\n   == M32R_ELF_DATA ? ((struct elf_m32r_link_hash_table *) ((p)->hash)) : NULL)\n \n-/* Create an entry in an m32r ELF linker hash table.  */\n-\n-static struct bfd_hash_entry *\n-m32r_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n-\t\t\t    struct bfd_hash_table *table,\n-\t\t\t    const char *string)\n-{\n-  struct elf_m32r_link_hash_entry *ret =\n-    (struct elf_m32r_link_hash_entry *) entry;\n-\n-  /* Allocate the structure if it has not already been allocated by a\n-     subclass.  */\n-  if (ret == NULL)\n-    ret = bfd_hash_allocate (table,\n-\t\t\t     sizeof (struct elf_m32r_link_hash_entry));\n-  if (ret == NULL)\n-    return NULL;\n-\n-  /* Call the allocation method of the superclass.  */\n-  ret = ((struct elf_m32r_link_hash_entry *)\n-\t _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,\n-\t\t\t\t     table, string));\n-  if (ret != NULL)\n-    {\n-      struct elf_m32r_link_hash_entry *eh;\n-\n-      eh = (struct elf_m32r_link_hash_entry *) ret;\n-      eh->dyn_relocs = NULL;\n-    }\n-\n-  return (struct bfd_hash_entry *) ret;\n-}\n-\n /* Create an m32r ELF linker hash table.  */\n \n static struct bfd_link_hash_table *\n@@ -1582,8 +1539,8 @@ m32r_elf_link_hash_table_create (bfd *abfd)\n     return NULL;\n \n   if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,\n-\t\t\t\t      m32r_elf_link_hash_newfunc,\n-\t\t\t\t      sizeof (struct elf_m32r_link_hash_entry),\n+\t\t\t\t      _bfd_elf_link_hash_newfunc,\n+\t\t\t\t      sizeof (struct elf_link_hash_entry),\n \t\t\t\t      M32R_ELF_DATA))\n     {\n       free (ret);\n@@ -1708,26 +1665,20 @@ m32r_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t\t\t       struct elf_link_hash_entry *dir,\n \t\t\t       struct elf_link_hash_entry *ind)\n {\n-  struct elf_m32r_link_hash_entry * edir;\n-  struct elf_m32r_link_hash_entry * eind;\n-\n-  edir = (struct elf_m32r_link_hash_entry *) dir;\n-  eind = (struct elf_m32r_link_hash_entry *) ind;\n-\n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -1738,11 +1689,11 @@ m32r_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   _bfd_elf_link_hash_copy_indirect (info, dir, ind);\n@@ -1755,9 +1706,8 @@ static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n-  struct elf_m32r_link_hash_entry *eh = (struct elf_m32r_link_hash_entry *) h;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -1905,7 +1855,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n {\n   struct bfd_link_info *info;\n   struct elf_m32r_link_hash_table *htab;\n-  struct elf_m32r_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1916,8 +1865,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   if (htab == NULL)\n     return FALSE;\n \n-  eh = (struct elf_m32r_link_hash_entry *) h;\n-\n   if (htab->root.dynamic_sections_created\n       && h->plt.refcount > 0)\n     {\n@@ -2000,7 +1947,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2017,7 +1964,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2030,11 +1977,11 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2074,13 +2021,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);\n@@ -3751,7 +3698,7 @@ m32r_elf_check_relocs (bfd *abfd,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct elf_m32r_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.  */"
    },
    {
      "sha": "bfd4b24f5f20311f0c921911386cbea321f15f21",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 15,
      "deletions": 22,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -785,10 +785,6 @@ struct elf_metag_link_hash_entry\n      symbol.  */\n   struct elf_metag_stub_hash_entry *hsh_cache;\n \n-  /* Used to count relocations for delayed sizing of relocation\n-     sections.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   enum\n     {\n       GOT_UNKNOWN = 0, GOT_NORMAL = 1, GOT_TLS_IE = 2, GOT_TLS_LDM = 4, GOT_TLS_GD = 8\n@@ -994,7 +990,6 @@ metag_link_hash_newfunc (struct bfd_hash_entry *entry,\n       /* Initialize the local fields.  */\n       hh = (struct elf_metag_link_hash_entry *) entry;\n       hh->hsh_cache = NULL;\n-      hh->dyn_relocs = NULL;\n       hh->tls_type = GOT_UNKNOWN;\n     }\n \n@@ -2328,7 +2323,7 @@ elf_metag_check_relocs (bfd *abfd,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (hh != NULL)\n-\t\thdh_head = &((struct elf_metag_link_hash_entry *) hh)->dyn_relocs;\n+\t\thdh_head = &hh->eh.dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.  */\n@@ -2395,9 +2390,9 @@ elf_metag_copy_indirect_symbol (struct bfd_link_info *info,\n   hh_dir = metag_elf_hash_entry (eh_dir);\n   hh_ind = metag_elf_hash_entry (eh_ind);\n \n-  if (hh_ind->dyn_relocs != NULL)\n+  if (eh_ind->dyn_relocs != NULL)\n     {\n-      if (hh_dir->dyn_relocs != NULL)\n+      if (eh_dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **hdh_pp;\n \t  struct elf_dyn_relocs *hdh_p;\n@@ -2407,11 +2402,11 @@ elf_metag_copy_indirect_symbol (struct bfd_link_info *info,\n \n \t  /* Add reloc counts against the weak sym to the strong sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (hdh_pp = &hh_ind->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n+\t  for (hdh_pp = &eh_ind->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *hdh_q;\n \n-\t      for (hdh_q = hh_dir->dyn_relocs; hdh_q != NULL;\n+\t      for (hdh_q = eh_dir->dyn_relocs; hdh_q != NULL;\n \t\t   hdh_q = hdh_q->next)\n \t\tif (hdh_q->sec == hdh_p->sec)\n \t\t  {\n@@ -2423,11 +2418,11 @@ elf_metag_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (hdh_q == NULL)\n \t\thdh_pp = &hdh_p->next;\n \t    }\n-\t  *hdh_pp = hh_dir->dyn_relocs;\n+\t  *hdh_pp = eh_dir->dyn_relocs;\n \t}\n \n-      hh_dir->dyn_relocs = hh_ind->dyn_relocs;\n-      hh_ind->dyn_relocs = NULL;\n+      eh_dir->dyn_relocs = eh_ind->dyn_relocs;\n+      eh_ind->dyn_relocs = NULL;\n     }\n \n   if (eh_ind->root.type == bfd_link_hash_indirect\n@@ -2447,7 +2442,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = metag_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2580,7 +2575,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n {\n   struct bfd_link_info *info;\n   struct elf_metag_link_hash_table *htab;\n-  struct elf_metag_link_hash_entry *hh;\n   struct elf_dyn_relocs *hdh_p;\n \n   if (eh->root.type == bfd_link_hash_indirect)\n@@ -2687,8 +2681,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n   else\n     eh->got.offset = (bfd_vma) -1;\n \n-  hh = (struct elf_metag_link_hash_entry *) eh;\n-  if (hh->dyn_relocs == NULL)\n+  if (eh->dyn_relocs == NULL)\n     return TRUE;\n \n   /* If this is a -Bsymbolic shared link, then we need to discard all\n@@ -2702,7 +2695,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \t{\n \t  struct elf_dyn_relocs **hdh_pp;\n \n-\t  for (hdh_pp = &hh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n+\t  for (hdh_pp = &eh->dyn_relocs; (hdh_p = *hdh_pp) != NULL; )\n \t    {\n \t      hdh_p->count -= hdh_p->pc_count;\n \t      hdh_p->pc_count = 0;\n@@ -2715,11 +2708,11 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (hh->dyn_relocs != NULL\n+      if (eh->dyn_relocs != NULL\n \t  && eh->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (eh->other) != STV_DEFAULT)\n-\t    hh->dyn_relocs = NULL;\n+\t    eh->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2758,14 +2751,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n \t    goto keep;\n \t}\n \n-      hh->dyn_relocs = NULL;\n+      eh->dyn_relocs = NULL;\n       return TRUE;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (hdh_p = hh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n+  for (hdh_p = eh->dyn_relocs; hdh_p != NULL; hdh_p = hdh_p->next)\n     {\n       asection *sreloc = elf_section_data (hdh_p->sec)->sreloc;\n       sreloc->size += hdh_p->count * sizeof (Elf32_External_Rela);"
    },
    {
      "sha": "928098d2be20460e6abada66f9c880f5b65c5c71",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 14,
      "deletions": 18,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -721,9 +721,6 @@ struct elf32_mb_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* TLS Reference Types for the symbol; Updated by check_relocs */\n #define TLS_GD     1  /* GD reloc. */\n #define TLS_LD     2  /* LD reloc. */\n@@ -790,7 +787,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct elf32_mb_link_hash_entry *eh;\n \n       eh = (struct elf32_mb_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->tls_mask = 0;\n     }\n \n@@ -2516,7 +2512,7 @@ microblaze_elf_check_relocs (bfd * abfd,\n \t\t/* If this is a global symbol, we count the number of\n \t\t   relocations we need for this symbol.  */\n \t\tif (h != NULL)\n-\t\t  head = &((struct elf32_mb_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\telse\n \t\t  {\n \t\t    /* Track dynamic relocs needed for local syms too.\n@@ -2579,9 +2575,9 @@ microblaze_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf32_mb_link_hash_entry *) dir;\n   eind = (struct elf32_mb_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n@@ -2591,11 +2587,11 @@ microblaze_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \n \t  /* Add reloc counts against the weak sym to the strong sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -2606,11 +2602,11 @@ microblaze_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   edir->tls_mask |= eind->tls_mask;\n@@ -2625,7 +2621,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf32_mb_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2898,7 +2894,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2915,7 +2911,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2926,7 +2922,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)\n \t    }\n \t}\n       else if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\teh->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n     }\n   else\n     {\n@@ -2956,13 +2952,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);"
    },
    {
      "sha": "ee4eea7372ffc98989953c64ae86ce770962f7ab",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 13,
      "deletions": 22,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -199,9 +199,6 @@ struct elf_nds32_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* For checking relocation type.  */\n   enum elf_nds32_tls_type tls_type;\n \n@@ -3669,7 +3666,6 @@ nds32_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct elf_nds32_link_hash_entry *eh;\n \n       eh = (struct elf_nds32_link_hash_entry *) ret;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n       eh->offset_to_gp = 0;\n     }\n@@ -3878,9 +3874,9 @@ nds32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_nds32_link_hash_entry *) dir;\n   eind = (struct elf_nds32_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n@@ -3890,11 +3886,11 @@ nds32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \n \t  /* Add reloc counts against the weak sym to the strong sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -3905,11 +3901,11 @@ nds32_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect)\n@@ -3932,7 +3928,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf32_nds32_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -4094,7 +4090,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   struct bfd_link_info *info;\n   struct elf_link_hash_table *ehtab;\n   struct elf_nds32_link_hash_table *htab;\n-  struct elf_nds32_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -4106,16 +4101,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   if (h->root.type == bfd_link_hash_warning)\n     h = (struct elf_link_hash_entry *) h->root.u.i.link;\n \n-  eh = (struct elf_nds32_link_hash_entry *) h;\n-\n   info = (struct bfd_link_info *) inf;\n   ehtab = elf_hash_table (info);\n   htab = nds32_elf_hash_table (info);\n   if (htab == NULL)\n     return FALSE;\n \n-  eh = (struct elf_nds32_link_hash_entry *) h;\n-\n   if ((htab->root.dynamic_sections_created || h->type == STT_GNU_IFUNC)\n       && h->plt.refcount > 0\n       && !(bfd_link_pie (info) && h->def_regular))\n@@ -4227,7 +4218,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma)-1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -4242,7 +4233,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -4279,13 +4270,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep:;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);\n@@ -7423,7 +7414,7 @@ nds32_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct elf_nds32_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  asection *s;"
    },
    {
      "sha": "6b4b092e2df5fa20e62e74a806946c8ffc88b0df",
      "filename": "bfd/elf32-nios2.c",
      "status": "modified",
      "additions": 14,
      "deletions": 18,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -1737,9 +1737,6 @@ struct elf32_nios2_link_hash_entry\n      symbol.  */\n   struct elf32_nios2_stub_hash_entry *hsh_cache;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n #define GOT_UNKNOWN\t0\n #define GOT_NORMAL\t1\n #define GOT_TLS_GD\t2\n@@ -2039,7 +2036,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n \n       eh = (struct elf32_nios2_link_hash_entry *) entry;\n       eh->hsh_cache = NULL;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n       eh->got_types_used = 0;\n     }\n@@ -4641,20 +4637,20 @@ nios2_elf32_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf32_nios2_link_hash_entry *) dir;\n   eind = (struct elf32_nios2_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -4665,11 +4661,11 @@ nios2_elf32_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -4926,7 +4922,7 @@ nios2_elf32_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct elf32_nios2_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n@@ -5631,7 +5627,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -5647,7 +5643,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -5660,12 +5656,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -5700,13 +5696,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);"
    },
    {
      "sha": "7afde7a59a6201c3fa325f796c899bf8215098ca",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 15,
      "deletions": 23,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -892,9 +892,6 @@ struct elf_or1k_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Track type of TLS access.  */\n   unsigned char tls_type;\n };\n@@ -964,7 +961,6 @@ or1k_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct elf_or1k_link_hash_entry *eh;\n \n       eh = (struct elf_or1k_link_hash_entry *) ret;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = TLS_UNKNOWN;\n     }\n \n@@ -2153,7 +2149,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\t/* If this is a global symbol, we count the number of\n \t\t   relocations we need for this symbol.  */\n \t\tif (h != NULL)\n-\t\t  head = &((struct elf_or1k_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\telse\n \t\t  {\n \t\t    /* Track dynamic relocs needed for local syms too.\n@@ -2557,9 +2553,8 @@ static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *sec_relocs;\n-  struct elf_or1k_link_hash_entry *eh = (struct elf_or1k_link_hash_entry *) h;\n \n-  for (sec_relocs = eh->dyn_relocs;\n+  for (sec_relocs = h->dyn_relocs;\n        sec_relocs != NULL;\n        sec_relocs = sec_relocs->next)\n     {\n@@ -2758,7 +2753,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n {\n   struct bfd_link_info *info;\n   struct elf_or1k_link_hash_table *htab;\n-  struct elf_or1k_link_hash_entry *eh;\n   struct elf_dyn_relocs *sec_relocs;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -2769,8 +2763,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   if (htab == NULL)\n     return FALSE;\n \n-  eh = (struct elf_or1k_link_hash_entry *) h;\n-\n   if (htab->root.dynamic_sections_created\n       && h->plt.refcount > 0)\n     {\n@@ -2857,7 +2849,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2872,7 +2864,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (sec_relocs = *pp) != NULL;)\n+\t  for (pp = &h->dyn_relocs; (sec_relocs = *pp) != NULL;)\n \t    {\n \t      sec_relocs->count -= sec_relocs->pc_count;\n \t      sec_relocs->pc_count = 0;\n@@ -2885,11 +2877,11 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2929,13 +2921,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (sec_relocs = eh->dyn_relocs;\n+  for (sec_relocs = h->dyn_relocs;\n        sec_relocs != NULL;\n        sec_relocs = sec_relocs->next)\n     {\n@@ -3204,20 +3196,20 @@ or1k_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_or1k_link_hash_entry *) dir;\n   eind = (struct elf_or1k_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -3228,11 +3220,11 @@ or1k_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect)"
    },
    {
      "sha": "eecb15f0bc1cf1d340127b7fe30e6eb7c1c0a033",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 26,
      "deletions": 30,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -2116,9 +2116,6 @@ struct ppc_elf_link_hash_entry\n      from the beginning of the section.  */\n   elf_linker_section_pointers_t *linker_section_pointer;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Contexts in which symbol is used in the GOT.\n      Bits are or'd into the mask as the corresponding relocs are\n      encountered during check_relocs, with TLS_TLS being set when any\n@@ -2264,7 +2261,6 @@ ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n   if (entry != NULL)\n     {\n       ppc_elf_hash_entry (entry)->linker_section_pointer = NULL;\n-      ppc_elf_hash_entry (entry)->dyn_relocs = NULL;\n       ppc_elf_hash_entry (entry)->tls_mask = 0;\n       ppc_elf_hash_entry (entry)->has_sda_refs = 0;\n     }\n@@ -2538,20 +2534,20 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   if (eind->elf.root.type != bfd_link_hash_indirect)\n     return;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -2562,11 +2558,11 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   /* Copy over the GOT refcount entries that we may have already seen to\n@@ -3482,7 +3478,7 @@ ppc_elf_check_relocs (bfd *abfd,\n \t\t  struct elf_dyn_relocs *p;\n \t\t  struct elf_dyn_relocs **rel_head;\n \n-\t\t  rel_head = &ppc_elf_hash_entry (h)->dyn_relocs;\n+\t\t  rel_head = &h->dyn_relocs;\n \t\t  p = *rel_head;\n \t\t  if (p == NULL || p->sec != sec)\n \t\t    {\n@@ -4705,7 +4701,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -4740,7 +4736,7 @@ pc_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     if (p->pc_count != 0)\n       return TRUE;\n   return FALSE;\n@@ -4784,7 +4780,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       /* Discard dyn_relocs when non-pic if we've decided that a\n \t function symbol is local.  */\n       if (!bfd_link_pic (info) && local)\n-\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n \n       /* Clear procedure linkage table information for any symbol that\n \t won't need a .plt entry.  */\n@@ -4841,7 +4837,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t  else if (!bfd_link_pic (info))\n \t    /* We are going to be defining the function symbol on the\n \t       plt stub, so no dyn_relocs needed when non-pic.  */\n-\t    ppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \t}\n       h->protected_def = 0;\n       /* Function symbols can't have copy relocs.  */\n@@ -4862,7 +4858,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       if (def->root.u.def.section == htab->elf.sdynbss\n \t  || def->root.u.def.section == htab->elf.sdynrelro\n \t  || def->root.u.def.section == htab->dynsbss)\n-\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n       return TRUE;\n     }\n \n@@ -4958,7 +4954,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     }\n \n   /* We no longer want dyn_relocs.  */\n-  ppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+  h->dyn_relocs = NULL;\n   return _bfd_elf_adjust_dynamic_copy (info, h, s);\n }\n \f\n@@ -5168,19 +5164,19 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n      IFUNCs which are handled even in static executables.  */\n   if (!htab->elf.dynamic_sections_created\n       && h->type != STT_GNU_IFUNC)\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n   /* Discard relocs on undefined symbols that must be local.  */\n   else if (h->root.type == bfd_link_hash_undefined\n \t   && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n   /* Also discard relocs on undefined weak syms with non-default\n      visibility, or when dynamic_undefined_weak says so.  */\n   else if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     ;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -5200,7 +5196,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -5215,7 +5211,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      if (strcmp (p->sec->output_section->name, \".tls_vars\") == 0)\n \t\t*pp = p->next;\n@@ -5224,7 +5220,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    }\n \t}\n \n-      if (eh->dyn_relocs != NULL)\n+      if (h->dyn_relocs != NULL)\n \t{\n \t  /* Make sure this symbol is output as a dynamic symbol.  */\n \t  if (!ensure_undef_dynamic (info, h))\n@@ -5249,14 +5245,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    return FALSE;\n \n \t  if (h->dynindx == -1)\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \t}\n       else\n-\teh->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n     }\n \n   /* Allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       if (eh->elf.type == STT_GNU_IFUNC)\n@@ -8111,11 +8107,11 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \t  if (bfd_link_pic (info)\n \t      ? ((h == NULL\n-\t\t  || ppc_elf_hash_entry (h)->dyn_relocs != NULL)\n+\t\t  || h->dyn_relocs != NULL)\n \t\t && ((h != NULL && pc_dynrelocs (h))\n \t\t     || must_be_dyn_reloc (info, r_type)))\n \t      : (h != NULL\n-\t\t && ppc_elf_hash_entry (h)->dyn_relocs != NULL))\n+\t\t && h->dyn_relocs != NULL))\n \t    {\n \t      int skip;\n \t      bfd_byte *loc;"
    },
    {
      "sha": "c42ce5e83f559dc1dc7c42627849adcff8c5e98c",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 16,
      "deletions": 23,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -654,9 +654,6 @@ struct elf_s390_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Number of GOTPLT references for a function.  */\n   bfd_signed_vma gotplt_refcount;\n \n@@ -787,7 +784,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct elf_s390_link_hash_entry *eh;\n \n       eh = (struct elf_s390_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->gotplt_refcount = 0;\n       eh->tls_type = GOT_UNKNOWN;\n       eh->ifunc_resolver_address = 0;\n@@ -832,20 +828,20 @@ elf_s390_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_s390_link_hash_entry *) dir;\n   eind = (struct elf_s390_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -856,11 +852,11 @@ elf_s390_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -1306,7 +1302,7 @@ elf_s390_check_relocs (bfd *abfd,\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n \t\t{\n-\t\t  head = &((struct elf_s390_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t}\n \t      else\n \t\t{\n@@ -1428,7 +1424,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf_s390_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -1460,11 +1456,9 @@ elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t{\n \t  bfd_size_type pc_count = 0, count = 0;\n \t  struct elf_dyn_relocs **pp;\n-\t  struct elf_s390_link_hash_entry *eh;\n \t  struct elf_dyn_relocs *p;\n \n-\t  eh = (struct elf_s390_link_hash_entry *) h;\n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      pc_count += p->pc_count;\n \t      p->count -= p->pc_count;\n@@ -1612,7 +1606,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n {\n   struct bfd_link_info *info;\n   struct elf_s390_link_hash_table *htab;\n-  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry *)h;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1743,7 +1736,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -1758,7 +1751,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -1771,12 +1764,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -1816,13 +1809,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n "
    },
    {
      "sha": "ebce61c017ce68864dc1474c2fcc29cf06991638",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 16,
      "deletions": 20,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -2095,9 +2095,6 @@ struct elf_sh_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   bfd_signed_vma gotplt_refcount;\n \n   /* A local function descriptor, for FDPIC.  The refcount counts\n@@ -2231,7 +2228,6 @@ sh_elf_link_hash_newfunc (struct bfd_hash_entry *entry,\n \t\t\t\t     table, string));\n   if (ret != (struct elf_sh_link_hash_entry *) NULL)\n     {\n-      ret->dyn_relocs = NULL;\n       ret->gotplt_refcount = 0;\n       ret->funcdesc.refcount = 0;\n       ret->abs_funcdesc_refcount = 0;\n@@ -2487,7 +2483,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = sh_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2842,7 +2838,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \thtab->srelfuncdesc->size += sizeof (Elf32_External_Rela);\n     }\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2857,7 +2853,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2872,7 +2868,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      if (strcmp (p->sec->output_section->name, \".tls_vars\") == 0)\n \t\t*pp = p->next;\n@@ -2883,12 +2879,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2928,13 +2924,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf32_External_Rela);\n@@ -5324,20 +5320,20 @@ sh_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_sh_link_hash_entry *) dir;\n   eind = (struct elf_sh_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -5348,11 +5344,11 @@ sh_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n   edir->gotplt_refcount = eind->gotplt_refcount;\n   eind->gotplt_refcount = 0;\n@@ -5812,7 +5808,7 @@ sh_elf_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct elf_sh_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.  */"
    },
    {
      "sha": "5e0a7d04b7092854014147743b3f663290916d82",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 9,
      "deletions": 53,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -61,16 +61,6 @@ struct elf32_tic6x_link_hash_table\n #define elf32_tic6x_hash_table(p) \\\n   ((struct elf32_tic6x_link_hash_table *) ((p)->hash))\n \n-/* TI C6X ELF linker hash entry.  */\n-\n-struct elf32_tic6x_link_hash_entry\n-{\n-  struct elf_link_hash_entry elf;\n-\n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-};\n-\n typedef enum\n {\n   DELETE_EXIDX_ENTRY,\n@@ -1559,36 +1549,6 @@ elf32_tic6x_set_use_rela_p (bfd *abfd, bfd_boolean use_rela_p)\n   elf32_tic6x_tdata (abfd)->use_rela_p = use_rela_p;\n }\n \n-/* Create an entry in a C6X ELF linker hash table.  */\n-\n-static struct bfd_hash_entry *\n-elf32_tic6x_link_hash_newfunc (struct bfd_hash_entry *entry,\n-\t\t\t    struct bfd_hash_table *table,\n-\t\t\t    const char *string)\n-{\n-  /* Allocate the structure if it has not already been allocated by a\n-     subclass.  */\n-  if (entry == NULL)\n-    {\n-      entry = bfd_hash_allocate (table,\n-\t\t\t\t sizeof (struct elf32_tic6x_link_hash_entry));\n-      if (entry == NULL)\n-\treturn entry;\n-    }\n-\n-  /* Call the allocation method of the superclass.  */\n-  entry = _bfd_elf_link_hash_newfunc (entry, table, string);\n-  if (entry != NULL)\n-    {\n-      struct elf32_tic6x_link_hash_entry *eh;\n-\n-      eh = (struct elf32_tic6x_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n-    }\n-\n-  return entry;\n-}\n-\n /* Create a C6X ELF linker hash table.  */\n \n static struct bfd_link_hash_table *\n@@ -1602,8 +1562,8 @@ elf32_tic6x_link_hash_table_create (bfd *abfd)\n     return NULL;\n \n   if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,\n-\t\t\t\t      elf32_tic6x_link_hash_newfunc,\n-\t\t\t\t      sizeof (struct elf32_tic6x_link_hash_entry),\n+\t\t\t\t      _bfd_elf_link_hash_newfunc,\n+\t\t\t\t      sizeof (struct elf_link_hash_entry),\n \t\t\t\t      TIC6X_ELF_DATA))\n     {\n       free (ret);\n@@ -2009,10 +1969,8 @@ static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n-  struct elf32_tic6x_link_hash_entry *eh\n-    = (struct elf32_tic6x_link_hash_entry *) h;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2924,7 +2882,7 @@ elf32_tic6x_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n \t\t{\n-\t\t  head = &((struct elf32_tic6x_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t}\n \t      else\n \t\t{\n@@ -3089,13 +3047,11 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info;\n   struct elf32_tic6x_link_hash_table *htab;\n-  struct elf32_tic6x_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n \n-  eh = (struct elf32_tic6x_link_hash_entry *) h;\n   info = (struct bfd_link_info *) inf;\n   htab = elf32_tic6x_hash_table (info);\n \n@@ -3176,7 +3132,7 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* Discard relocs on undefined weak syms with non-default\n@@ -3189,7 +3145,7 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -3200,11 +3156,11 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    }\n \t}\n \n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -3218,7 +3174,7 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc;\n "
    },
    {
      "sha": "4b7446fa40c94d962d39e92e61a0b9b2c5138e75",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 15,
      "deletions": 22,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -685,9 +685,6 @@ struct tilepro_elf_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n #define GOT_UNKNOWN     0\n #define GOT_NORMAL      1\n #define GOT_TLS_GD      2\n@@ -1176,7 +1173,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct tilepro_elf_link_hash_entry *eh;\n \n       eh = (struct tilepro_elf_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n     }\n \n@@ -1296,20 +1292,20 @@ tilepro_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct tilepro_elf_link_hash_entry *) dir;\n   eind = (struct tilepro_elf_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -1320,11 +1316,11 @@ tilepro_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -1760,8 +1756,7 @@ tilepro_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead =\n-\t\t  &((struct tilepro_elf_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n@@ -1883,7 +1878,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = tilepro_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2025,7 +2020,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info;\n   struct tilepro_elf_link_hash_table *htab;\n-  struct tilepro_elf_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -2134,8 +2128,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  eh = (struct tilepro_elf_link_hash_entry *) h;\n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2150,7 +2143,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2163,12 +2156,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2208,13 +2201,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * TILEPRO_ELF_RELA_BYTES;"
    },
    {
      "sha": "5903217077d5ca3afaad6a8a1bab7d6585c59e9a",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 26,
      "deletions": 30,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -3075,9 +3075,6 @@ struct ppc_link_hash_entry\n     struct ppc_link_hash_entry *next_dot_sym;\n   } u;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Link between function code and descriptor symbols.  */\n   struct ppc_link_hash_entry *oh;\n \n@@ -3906,20 +3903,20 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,\n     return;\n \n   /* Copy over any dynamic relocs we may have on the indirect sym.  */\n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -3930,11 +3927,11 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   /* Copy over got entries that we may have already seen to the\n@@ -5165,7 +5162,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  struct elf_dyn_relocs *p;\n \t\t  struct elf_dyn_relocs **head;\n \n-\t\t  head = &ppc_elf_hash_entry (h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t  p = *head;\n \t\t  if (p == NULL || p->sec != sec)\n \t\t    {\n@@ -6364,10 +6361,9 @@ ppc64_elf_func_desc_adjust (bfd *obfd ATTRIBUTE_UNUSED,\n static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n-  struct ppc_link_hash_entry *eh = ppc_elf_hash_entry (h);\n   struct elf_dyn_relocs *p;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -6403,7 +6399,7 @@ pc_dynrelocs (struct ppc_link_hash_entry *eh)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = eh->elf.dyn_relocs; p != NULL; p = p->next)\n     if (p->pc_count != 0)\n       return TRUE;\n   return FALSE;\n@@ -6466,7 +6462,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       if (!bfd_link_pic (info)\n \t  && h->type != STT_GNU_IFUNC\n \t  && local)\n-\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n \n       /* Clear procedure linkage table information for any symbol that\n \t won't need a .plt entry.  */\n@@ -6507,7 +6503,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t      else if (!bfd_link_pic (info))\n \t\t/* We are going to be defining the function symbol on the\n \t\t   plt stub, so no dyn_relocs needed when non-pic.  */\n-\t\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\t\th->dyn_relocs = NULL;\n \t    }\n \n \t  /* ELFv2 function symbols can't have copy relocs.  */\n@@ -6537,7 +6533,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       h->root.u.def.value = def->root.u.def.value;\n       if (def->root.u.def.section == htab->elf.sdynbss\n \t  || def->root.u.def.section == htab->elf.sdynrelro)\n-\tppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+\th->dyn_relocs = NULL;\n       return TRUE;\n     }\n \n@@ -6627,7 +6623,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     }\n \n   /* We no longer want dyn_relocs.  */\n-  ppc_elf_hash_entry (h)->dyn_relocs = NULL;\n+  h->dyn_relocs = NULL;\n   return _bfd_elf_adjust_dynamic_copy (info, h, s);\n }\n \n@@ -7049,7 +7045,7 @@ dec_dynrel_count (bfd_vma r_info,\n     {\n       struct elf_dyn_relocs *p;\n       struct elf_dyn_relocs **pp;\n-      pp = &ppc_elf_hash_entry (h)->dyn_relocs;\n+      pp = &h->dyn_relocs;\n \n       /* elf_gc_sweep may have already removed all dyn relocs associated\n \t with local syms for a given section.  Also, symbol flags are\n@@ -9630,19 +9626,19 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n      IFUNCs which are handled even in static executables.  */\n   if (!htab->elf.dynamic_sections_created\n       && h->type != STT_GNU_IFUNC)\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n   /* Discard relocs on undefined symbols that must be local.  */\n   else if (h->root.type == bfd_link_hash_undefined\n \t   && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n   /* Also discard relocs on undefined weak syms with non-default\n      visibility, or when dynamic_undefined_weak says so.  */\n   else if (UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-    eh->dyn_relocs = NULL;\n+    h->dyn_relocs = NULL;\n \n-  if (eh->dyn_relocs != NULL)\n+  if (h->dyn_relocs != NULL)\n     {\n       struct elf_dyn_relocs *p, **pp;\n \n@@ -9662,7 +9658,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t     avoid writing weird assembly.  */\n \t  if (SYMBOL_CALLS_LOCAL (info, h))\n \t    {\n-\t      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t      for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t\t{\n \t\t  p->count -= p->pc_count;\n \t\t  p->pc_count = 0;\n@@ -9673,7 +9669,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t}\n \t    }\n \n-\t  if (eh->dyn_relocs != NULL)\n+\t  if (h->dyn_relocs != NULL)\n \t    {\n \t      /* Ensure we catch all the cases where this symbol\n \t\t should be made dynamic.  */\n@@ -9697,14 +9693,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n \t      /* But if that didn't work out, discard dynamic relocs.  */\n \t      if (h->dynindx == -1)\n-\t\teh->dyn_relocs = NULL;\n+\t\th->dyn_relocs = NULL;\n \t    }\n \t  else\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \t}\n \n       /* Finally, allocate space.  */\n-      for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+      for (p = h->dyn_relocs; p != NULL; p = p->next)\n \t{\n \t  asection *sreloc = elf_section_data (p->sec)->sreloc;\n \t  if (eh->elf.type == STT_GNU_IFUNC)\n@@ -16510,11 +16506,11 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \n \t  if (bfd_link_pic (info)\n \t      ? ((h == NULL\n-\t\t  || h->dyn_relocs != NULL)\n+\t\t  || h->elf.dyn_relocs != NULL)\n \t\t && ((h != NULL && pc_dynrelocs (h))\n \t\t     || must_be_dyn_reloc (info, r_type)))\n \t      : (h != NULL\n-\t\t ? h->dyn_relocs != NULL\n+\t\t ? h->elf.dyn_relocs != NULL\n \t\t : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC))\n \t    {\n \t      bfd_boolean skip, relocate;"
    },
    {
      "sha": "ec070ce4a332db2abd7b31da5955857c8742d222",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 16,
      "deletions": 23,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -571,9 +571,6 @@ struct elf_s390_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Number of GOTPLT references for a function.  */\n   bfd_signed_vma gotplt_refcount;\n \n@@ -706,7 +703,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct elf_s390_link_hash_entry *eh;\n \n       eh = (struct elf_s390_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->gotplt_refcount = 0;\n       eh->tls_type = GOT_UNKNOWN;\n       eh->ifunc_resolver_address = 0;\n@@ -751,20 +747,20 @@ elf_s390_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_s390_link_hash_entry *) dir;\n   eind = (struct elf_s390_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -775,11 +771,11 @@ elf_s390_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -1241,7 +1237,7 @@ elf_s390_check_relocs (bfd *abfd,\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n \t\t{\n-\t\t  head = &((struct elf_s390_link_hash_entry *) h)->dyn_relocs;\n+\t\t  head = &h->dyn_relocs;\n \t\t}\n \t      else\n \t\t{\n@@ -1363,7 +1359,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf_s390_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -1395,11 +1391,9 @@ elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t{\n \t  bfd_size_type pc_count = 0, count = 0;\n \t  struct elf_dyn_relocs **pp;\n-\t  struct elf_s390_link_hash_entry *eh;\n \t  struct elf_dyn_relocs *p;\n \n-\t  eh = (struct elf_s390_link_hash_entry *) h;\n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      pc_count += p->pc_count;\n \t      p->count -= p->pc_count;\n@@ -1549,7 +1543,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n {\n   struct bfd_link_info *info;\n   struct elf_s390_link_hash_table *htab;\n-  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry *)h;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1680,7 +1673,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -1695,7 +1688,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -1708,12 +1701,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -1753,13 +1746,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (Elf64_External_Rela);"
    },
    {
      "sha": "183c8083464efee694695f6ed5d9695255326bb4",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -2315,7 +2315,7 @@ elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &eh->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too."
    },
    {
      "sha": "cbf10deaa4b937039546da08c3b9f2cd00f8d339",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 17,
      "deletions": 26,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -2570,9 +2570,6 @@ struct elf_aarch64_link_hash_entry\n {\n   struct elf_link_hash_entry root;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   /* Since PLT entries have variable size, we need to record the\n      index into .got.plt instead of recomputing it from the PLT\n      offset.  */\n@@ -2728,7 +2725,6 @@ elfNN_aarch64_link_hash_newfunc (struct bfd_hash_entry *entry,\n \t\t\t\t     table, string));\n   if (ret != NULL)\n     {\n-      ret->dyn_relocs = NULL;\n       ret->got_type = GOT_UNKNOWN;\n       ret->plt_got_offset = (bfd_vma) - 1;\n       ret->stub_cache = NULL;\n@@ -2855,20 +2851,20 @@ elfNN_aarch64_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_aarch64_link_hash_entry *) dir;\n   eind = (struct elf_aarch64_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -2879,11 +2875,11 @@ elfNN_aarch64_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect)\n@@ -7392,7 +7388,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf_aarch64_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -7410,7 +7406,7 @@ need_copy_relocation_p (struct elf_aarch64_link_hash_entry *eh)\n   struct elf_dyn_relocs *p;\n   asection *s;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = eh->root.dyn_relocs; p != NULL; p = p->next)\n     {\n       /* If there is any pc-relative reference, we need to keep copy relocation\n \t to avoid propagating the relocation into runtime that current glibc\n@@ -7889,9 +7885,7 @@ elfNN_aarch64_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t       relocations we need for this symbol.  */\n \t    if (h != NULL)\n \t      {\n-\t\tstruct elf_aarch64_link_hash_entry *eh;\n-\t\teh = (struct elf_aarch64_link_hash_entry *) h;\n-\t\thead = &eh->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      }\n \t    else\n \t      {\n@@ -8752,7 +8746,7 @@ elfNN_aarch64_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n       h->got.offset = (bfd_vma) - 1;\n     }\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -8773,7 +8767,7 @@ elfNN_aarch64_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL;)\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -8786,11 +8780,11 @@ elfNN_aarch64_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL && h->root.type == bfd_link_hash_undefweak)\n+      if (h->dyn_relocs != NULL && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -8829,13 +8823,13 @@ elfNN_aarch64_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep:;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc;\n \n@@ -8858,7 +8852,6 @@ elfNN_aarch64_allocate_ifunc_dynrelocs (struct elf_link_hash_entry *h,\n {\n   struct bfd_link_info *info;\n   struct elf_aarch64_link_hash_table *htab;\n-  struct elf_aarch64_link_hash_entry *eh;\n \n   /* An example of a bfd_link_hash_indirect symbol is versioned\n      symbol. For example: __gxx_personality_v0(bfd_link_hash_indirect)\n@@ -8878,14 +8871,12 @@ elfNN_aarch64_allocate_ifunc_dynrelocs (struct elf_link_hash_entry *h,\n   info = (struct bfd_link_info *) inf;\n   htab = elf_aarch64_hash_table (info);\n \n-  eh = (struct elf_aarch64_link_hash_entry *) h;\n-\n   /* Since STT_GNU_IFUNC symbol must go through PLT, we handle it\n      here if it is defined and referenced in a non-shared object.  */\n   if (h->type == STT_GNU_IFUNC\n       && h->def_regular)\n     return _bfd_elf_allocate_ifunc_dyn_relocs (info, h,\n-\t\t\t\t\t       &eh->dyn_relocs,\n+\t\t\t\t\t       &h->dyn_relocs,\n \t\t\t\t\t       NULL,\n \t\t\t\t\t       htab->plt_entry_size,\n \t\t\t\t\t       htab->plt_header_size,"
    },
    {
      "sha": "f6c92b80282b58313dbc2c70c6dac72a8ca3a128",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 15,
      "deletions": 21,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -61,9 +61,6 @@ struct riscv_elf_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n #define GOT_UNKNOWN     0\n #define GOT_NORMAL      1\n #define GOT_TLS_GD      2\n@@ -264,7 +261,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct riscv_elf_link_hash_entry *eh;\n \n       eh = (struct riscv_elf_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n     }\n \n@@ -419,20 +415,20 @@ riscv_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct riscv_elf_link_hash_entry *) dir;\n   eind = (struct riscv_elf_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -443,11 +439,11 @@ riscv_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -705,7 +701,7 @@ riscv_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct riscv_elf_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n@@ -793,7 +789,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = riscv_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -944,7 +940,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info;\n   struct riscv_elf_link_hash_table *htab;\n-  struct riscv_elf_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -1053,8 +1048,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  eh = (struct riscv_elf_link_hash_entry *) h;\n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -1069,7 +1063,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -1082,12 +1076,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -1127,13 +1121,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * sizeof (ElfNN_External_Rela);"
    },
    {
      "sha": "d6e3b6d437ef03948671cc02ea73a34c3f676ccb",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 18,
      "deletions": 22,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -690,9 +690,6 @@ struct _bfd_sparc_elf_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n #define GOT_UNKNOWN     0\n #define GOT_NORMAL      1\n #define GOT_TLS_GD      2\n@@ -1028,7 +1025,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct _bfd_sparc_elf_link_hash_entry *eh;\n \n       eh = (struct _bfd_sparc_elf_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n       eh->has_got_reloc = 0;\n       eh->has_non_got_reloc = 0;\n@@ -1289,20 +1285,20 @@ _bfd_sparc_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct _bfd_sparc_elf_link_hash_entry *) dir;\n   eind = (struct _bfd_sparc_elf_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -1313,11 +1309,11 @@ _bfd_sparc_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect && dir->got.refcount <= 0)\n@@ -1790,7 +1786,7 @@ _bfd_sparc_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead = &((struct _bfd_sparc_elf_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n@@ -1930,7 +1926,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = _bfd_sparc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2257,7 +2253,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2272,7 +2268,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2287,7 +2283,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      if (strcmp (p->sec->output_section->name, \".tls_vars\") == 0)\n \t\t*pp = p->next;\n@@ -2298,7 +2294,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility or in PIE.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  /* An undefined weak symbol is never\n@@ -2313,7 +2309,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t\t     can branch to 0 without PLT.  */\n \t\t  struct elf_dyn_relocs **pp;\n \n-\t\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL;)\n \t\t    if (p->pc_count == 0)\n \t\t      *pp = p->next;\n \t\t    else\n@@ -2323,7 +2319,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t\t\tpp = &p->next;\n \t\t      }\n \n-\t\t  if (eh->dyn_relocs != NULL)\n+\t\t  if (h->dyn_relocs != NULL)\n \t\t    {\n \t\t      /* Make sure undefined weak symbols are output\n \t\t\t as dynamic symbols in PIEs for dynamic non-GOT\n@@ -2333,7 +2329,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t\t    }\n \t\t}\n \t      else\n-\t\teh->dyn_relocs = NULL;\n+\t\th->dyn_relocs = NULL;\n \t    }\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n@@ -2377,13 +2373,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * SPARC_ELF_RELA_BYTES (htab);"
    },
    {
      "sha": "3e73e0b18eb499d0c4d26780717f0cbdadeb8636",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 15,
      "deletions": 22,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -785,9 +785,6 @@ struct tilegx_elf_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n #define GOT_UNKNOWN     0\n #define GOT_NORMAL      1\n #define GOT_TLS_GD      2\n@@ -1356,7 +1353,6 @@ link_hash_newfunc (struct bfd_hash_entry *entry,\n       struct tilegx_elf_link_hash_entry *eh;\n \n       eh = (struct tilegx_elf_link_hash_entry *) entry;\n-      eh->dyn_relocs = NULL;\n       eh->tls_type = GOT_UNKNOWN;\n     }\n \n@@ -1505,20 +1501,20 @@ tilegx_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct tilegx_elf_link_hash_entry *) dir;\n   eind = (struct tilegx_elf_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -1529,11 +1525,11 @@ tilegx_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -2003,8 +1999,7 @@ tilegx_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      /* If this is a global symbol, we count the number of\n \t\t relocations we need for this symbol.  */\n \t      if (h != NULL)\n-\t\thead =\n-\t\t  &((struct tilegx_elf_link_hash_entry *) h)->dyn_relocs;\n+\t\thead = &h->dyn_relocs;\n \t      else\n \t\t{\n \t\t  /* Track dynamic relocs needed for local syms too.\n@@ -2126,7 +2121,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = tilegx_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -2271,7 +2266,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n {\n   struct bfd_link_info *info;\n   struct tilegx_elf_link_hash_table *htab;\n-  struct tilegx_elf_link_hash_entry *eh;\n   struct elf_dyn_relocs *p;\n \n   if (h->root.type == bfd_link_hash_indirect)\n@@ -2380,8 +2374,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  eh = (struct tilegx_elf_link_hash_entry *) h;\n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -2396,7 +2389,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -2409,12 +2402,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility.  */\n-      if (eh->dyn_relocs != NULL\n+      if (h->dyn_relocs != NULL\n \t  && h->root.type == bfd_link_hash_undefweak)\n \t{\n \t  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT\n \t      || UNDEFWEAK_NO_DYNAMIC_RELOC (info, h))\n-\t    eh->dyn_relocs = NULL;\n+\t    h->dyn_relocs = NULL;\n \n \t  /* Make sure undefined weak symbols are output as a dynamic\n \t     symbol in PIEs.  */\n@@ -2454,13 +2447,13 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc = elf_section_data (p->sec)->sreloc;\n       sreloc->size += p->count * TILEGX_ELF_RELA_BYTES (htab);"
    },
    {
      "sha": "e385ddb539127bb0ec7c4238788a8c992fe9ad37",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -131,7 +131,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   if (h->type == STT_GNU_IFUNC\n       && h->def_regular)\n     {\n-      if (_bfd_elf_allocate_ifunc_dyn_relocs (info, h, &eh->dyn_relocs,\n+      if (_bfd_elf_allocate_ifunc_dyn_relocs (info, h, &h->dyn_relocs,\n \t\t\t\t\t      &htab->readonly_dynrelocs_against_ifunc,\n \t\t\t\t\t      plt_entry_size,\n \t\t\t\t\t      (htab->plt.has_plt0\n@@ -375,7 +375,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   else\n     h->got.offset = (bfd_vma) -1;\n \n-  if (eh->dyn_relocs == NULL)\n+  if (h->dyn_relocs == NULL)\n     return TRUE;\n \n   /* In the shared -Bsymbolic case, discard space allocated for\n@@ -396,7 +396,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      p->count -= p->pc_count;\n \t      p->pc_count = 0;\n@@ -410,7 +410,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n       if (htab->target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      if (strcmp (p->sec->output_section->name, \".tls_vars\") == 0)\n \t\t*pp = p->next;\n@@ -421,7 +421,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n       /* Also discard relocs on undefined weak syms with non-default\n \t visibility or in PIE.  */\n-      if (eh->dyn_relocs != NULL)\n+      if (h->dyn_relocs != NULL)\n \t{\n \t  if (h->root.type == bfd_link_hash_undefweak)\n \t    {\n@@ -437,7 +437,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t\t that we can branch to 0 without PLT.  */\n \t\t      struct elf_dyn_relocs **pp;\n \n-\t\t      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t\t      for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t\t\tif (p->pc_count == 0)\n \t\t\t  *pp = p->next;\n \t\t\telse\n@@ -450,12 +450,12 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t      /* Make sure undefined weak symbols are output\n \t\t\t as dynamic symbols in PIEs for dynamic non-GOT\n \t\t\t non-PLT reloations.  */\n-\t\t      if (eh->dyn_relocs != NULL\n+\t\t      if (h->dyn_relocs != NULL\n \t\t\t  && !bfd_elf_link_record_dynamic_symbol (info, h))\n \t\t\treturn FALSE;\n \t\t    }\n \t\t  else\n-\t\t    eh->dyn_relocs = NULL;\n+\t\t    h->dyn_relocs = NULL;\n \t\t}\n \t      else if (h->dynindx == -1\n \t\t       && !h->forced_local\n@@ -472,7 +472,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t which turn out to need copy relocs.  */\n \t      struct elf_dyn_relocs **pp;\n \n-\t      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t      for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t\t{\n \t\t  if (p->pc_count != 0)\n \t\t    *pp = p->next;\n@@ -513,13 +513,13 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    goto keep;\n \t}\n \n-      eh->dyn_relocs = NULL;\n+      h->dyn_relocs = NULL;\n \n     keep: ;\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *sreloc;\n \n@@ -539,7 +539,7 @@ readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n   struct elf_dyn_relocs *p;\n \n-  for (p = elf_x86_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)\n+  for (p = h->dyn_relocs; p != NULL; p = p->next)\n     {\n       asection *s = p->sec->output_section;\n \n@@ -1783,20 +1783,20 @@ _bfd_x86_elf_copy_indirect_symbol (struct bfd_link_info *info,\n   edir = (struct elf_x86_link_hash_entry *) dir;\n   eind = (struct elf_x86_link_hash_entry *) ind;\n \n-  if (eind->dyn_relocs != NULL)\n+  if (ind->dyn_relocs != NULL)\n     {\n-      if (edir->dyn_relocs != NULL)\n+      if (dir->dyn_relocs != NULL)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  struct elf_dyn_relocs *p;\n \n \t  /* Add reloc counts against the indirect sym to the direct sym\n \t     list.  Merge any entries against the same section.  */\n-\t  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &ind->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      struct elf_dyn_relocs *q;\n \n-\t      for (q = edir->dyn_relocs; q != NULL; q = q->next)\n+\t      for (q = dir->dyn_relocs; q != NULL; q = q->next)\n \t\tif (q->sec == p->sec)\n \t\t  {\n \t\t    q->pc_count += p->pc_count;\n@@ -1807,11 +1807,11 @@ _bfd_x86_elf_copy_indirect_symbol (struct bfd_link_info *info,\n \t      if (q == NULL)\n \t\tpp = &p->next;\n \t    }\n-\t  *pp = edir->dyn_relocs;\n+\t  *pp = dir->dyn_relocs;\n \t}\n \n-      edir->dyn_relocs = eind->dyn_relocs;\n-      eind->dyn_relocs = NULL;\n+      dir->dyn_relocs = ind->dyn_relocs;\n+      ind->dyn_relocs = NULL;\n     }\n \n   if (ind->root.type == bfd_link_hash_indirect\n@@ -1950,7 +1950,7 @@ _bfd_x86_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t  struct elf_dyn_relocs **pp;\n \n \t  eh = (struct elf_x86_link_hash_entry *) h;\n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )\n+\t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n \t    {\n \t      pc_count += p->pc_count;\n \t      p->count -= p->pc_count;"
    },
    {
      "sha": "b64c41390aceb93a7d5b88a219bcc955d50b951b",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/190eb1ddba41aad3a31edead9392473ae9d3bbe3/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=190eb1ddba41aad3a31edead9392473ae9d3bbe3",
      "patch": "@@ -250,9 +250,6 @@ struct elf_x86_link_hash_entry\n {\n   struct elf_link_hash_entry elf;\n \n-  /* Track dynamic relocs copied for this symbol.  */\n-  struct elf_dyn_relocs *dyn_relocs;\n-\n   unsigned char tls_type;\n \n   /* Bit 0: Symbol has no GOT nor PLT relocations."
    }
  ]
}