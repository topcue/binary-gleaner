{
  "sha": "f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjQwMGM4ZDI3ZTExNDc3ZDc5YmE2N2NhOTMwY2E3ZTc1MTFiOWVlNQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-13T07:50:10Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-13T13:16:54Z"
    },
    "message": "ld lexer tidy, possibly break the world\n\nThis tidies the states in which ld lexer rules are enabled.\nThis change will quite likely trip over issues similar to those\nmentioned in the new ldlex.l comments, so please test it out.\n\n\t* ldgram.y (wildcard_name): Remove now unnecessary components.\n\t* ldlex.l: Restrict many rules' states.  Remove -l expression\n\tstate rule.  Comment on lookahead state madness and need for\n\t/DISCARD/ in expression state.",
    "tree": {
      "sha": "fbd9c16ee72af6d80da8fc283a63b2379d129295",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fbd9c16ee72af6d80da8fc283a63b2379d129295"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f400c8d27e11477d79ba67ca930ca7e7511b9ee5/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b325429b2fcc53f5823d5b4a1974597c11b8dcf9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b325429b2fcc53f5823d5b4a1974597c11b8dcf9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b325429b2fcc53f5823d5b4a1974597c11b8dcf9"
    }
  ],
  "stats": {
    "total": 269,
    "additions": 140,
    "deletions": 129
  },
  "files": [
    {
      "sha": "1f6c44a073ca69692bca164f81c459579fb6a113",
      "filename": "ld/ldgram.y",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f400c8d27e11477d79ba67ca930ca7e7511b9ee5/ld/ldgram.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f400c8d27e11477d79ba67ca930ca7e7511b9ee5/ld/ldgram.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldgram.y?ref=f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
      "patch": "@@ -421,21 +421,11 @@ statement_anywhere:\n \t\t  lang_add_assignment (exp_assert ($4, $6)); }\n \t;\n \n-/* The '*' and '?' cases are there because the lexer returns them as\n-   separate tokens rather than as NAME.  */\n wildcard_name:\n \t\tNAME\n \t\t\t{\n \t\t\t  $$ = $1;\n \t\t\t}\n-\t|\t'*'\n-\t\t\t{\n-\t\t\t  $$ = \"*\";\n-\t\t\t}\n-\t|\t'?'\n-\t\t\t{\n-\t\t\t  $$ = \"?\";\n-\t\t\t}\n \t;\n \n wildcard_maybe_exclude:"
    },
    {
      "sha": "6aeba6de6567fe5cb22a5bbda8416d02561cc53d",
      "filename": "ld/ldlex.l",
      "status": "modified",
      "additions": 140,
      "deletions": 119,
      "changes": 259,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f400c8d27e11477d79ba67ca930ca7e7511b9ee5/ld/ldlex.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f400c8d27e11477d79ba67ca930ca7e7511b9ee5/ld/ldlex.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlex.l?ref=f400c8d27e11477d79ba67ca930ca7e7511b9ee5",
      "patch": "@@ -192,132 +192,155 @@ V_IDENTIFIER [*?.$_a-zA-Z\\[\\]\\-\\!\\^\\\\]([*?.$_a-zA-Z0-9\\[\\]\\-\\!\\^\\\\]|::)*\n \t\t\t\t    }\n \t\t\t\t  return INT;\n \t\t\t\t}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"]\"\t\t{ RTOKEN(']');}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"[\"\t\t{ RTOKEN('[');}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"<<=\"\t{ RTOKEN(LSHIFTEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\">>=\"\t{ RTOKEN(RSHIFTEQ);}\n-<SCRIPT,EXPRESSION,MRI>\"||\"\t\t{ RTOKEN(OROR);}\n-<SCRIPT,EXPRESSION,MRI>\"==\"\t\t{ RTOKEN(EQ);}\n-<SCRIPT,EXPRESSION,MRI>\"!=\"\t\t{ RTOKEN(NE);}\n-<SCRIPT,EXPRESSION,MRI>\">=\"\t\t{ RTOKEN(GE);}\n-<SCRIPT,EXPRESSION,MRI>\"<=\"\t\t{ RTOKEN(LE);}\n-<SCRIPT,EXPRESSION,MRI>\"<<\"\t\t{ RTOKEN(LSHIFT);}\n-<SCRIPT,EXPRESSION,MRI>\">>\"\t\t{ RTOKEN(RSHIFT);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"+=\"\t{ RTOKEN(PLUSEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"-=\"\t{ RTOKEN(MINUSEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"*=\"\t{ RTOKEN(MULTEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"/=\"\t{ RTOKEN(DIVEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"&=\"\t{ RTOKEN(ANDEQ);}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"|=\"\t{ RTOKEN(OREQ);}\n-<SCRIPT,EXPRESSION,MRI>\"&&\"\t\t{ RTOKEN(ANDAND);}\n-<SCRIPT,EXPRESSION,MRI>\">\"\t\t{ RTOKEN('>');}\n-<SCRIPT,EXPRESSION,MRI,INPUTLIST>\",\"\t{ RTOKEN(',');}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"&\"\t\t{ RTOKEN('&');}\n-<SCRIPT,EXPRESSION,MRI>\"|\"\t\t{ RTOKEN('|');}\n-<SCRIPT,EXPRESSION,MRI>\"~\"\t\t{ RTOKEN('~');}\n-<SCRIPT,EXPRESSION,MRI>\"!\"\t\t{ RTOKEN('!');}\n-<SCRIPT,EXPRESSION,MRI>\"?\"\t\t{ RTOKEN('?');}\n-<SCRIPT,EXPRESSION,MRI>\"*\"\t\t{ RTOKEN('*');}\n-<SCRIPT,EXPRESSION,MRI>\"+\"\t\t{ RTOKEN('+');}\n-<SCRIPT,EXPRESSION,MRI>\"-\"\t\t{ RTOKEN('-');}\n-<SCRIPT,EXPRESSION,MRI>\"/\"\t\t{ RTOKEN('/');}\n-<SCRIPT,EXPRESSION,MRI>\"%\"\t\t{ RTOKEN('%');}\n-<SCRIPT,EXPRESSION,MRI>\"<\"\t\t{ RTOKEN('<');}\n-<SCRIPT,EXPRESSION,MRI,WILD>\"=\"\t\t{ RTOKEN('=');}\n+\n+  /* Some tokens that only appear in expressions must be enabled for\n+     states other than EXPRESSION, since parser lookahead means they\n+     must be recognised before the parser switches the lexer out of\n+     SCRIPT or WILD state into EXPRESSION state.\n+\n+     This sort of thing happens for example with NAME in ldgram.y\n+     \"section\" rule, which is immediately followed by ldlex_expression.\n+     However, if you follow the grammar from \"sec_or_group_p1\" you see\n+     \"assignment\" appearing in \"statement_anywhere\".  Now,\n+     \"assignment\" also has NAME as its first token, just like\n+     \"section\".  So the parser can't know whether it is in the\n+     \"section\" or the \"assignment\" rule until it has scanned the next\n+     token to find an assignment operator.  Thus the next token after\n+     NAME in the \"section\" rule may be lexed before the lexer is\n+     switched to EXPRESSION state, and there are quite a number of\n+     optional components.  The first token in all those components\n+     must be able to be lexed in SCRIPT state, as well as the\n+     assignment operators.  In fact, due to \"opt_exp_with_type\",\n+     anything that can appear on the left hand side of \"exp\" might\n+     need to be lexed in SCRIPT state.\n+\n+     MRI mode tends to cover everything in MRI scripts.\n+  */\n+<MRI,WILD>\"]\"\t\t\t\t{ RTOKEN(']'); }\n+<MRI,WILD>\"[\"\t\t\t\t{ RTOKEN('['); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"<<=\"\t{ RTOKEN(LSHIFTEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\">>=\"\t{ RTOKEN(RSHIFTEQ); }\n+<EXPRESSION,MRI>\"||\"\t\t\t{ RTOKEN(OROR); }\n+<EXPRESSION,MRI>\"==\"\t\t\t{ RTOKEN(EQ); }\n+<EXPRESSION,MRI>\"!=\"\t\t\t{ RTOKEN(NE); }\n+<EXPRESSION,MRI>\">=\"\t\t\t{ RTOKEN(GE); }\n+<EXPRESSION,MRI>\"<=\"\t\t\t{ RTOKEN(LE); }\n+<EXPRESSION,MRI>\"<<\"\t\t\t{ RTOKEN(LSHIFT); }\n+<EXPRESSION,MRI>\">>\"\t\t\t{ RTOKEN(RSHIFT); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"+=\"\t{ RTOKEN(PLUSEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"-=\"\t{ RTOKEN(MINUSEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"*=\"\t{ RTOKEN(MULTEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"/=\"\t{ RTOKEN(DIVEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"&=\"\t{ RTOKEN(ANDEQ); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"|=\"\t{ RTOKEN(OREQ); }\n+<EXPRESSION,MRI>\"&&\"\t\t\t{ RTOKEN(ANDAND); }\n+<SCRIPT,EXPRESSION,MRI>\">\"\t\t{ RTOKEN('>'); }\n+<SCRIPT,EXPRESSION,MRI,INPUTLIST>\",\"\t{ RTOKEN(','); }\n+<EXPRESSION,MRI,WILD>\"&\"\t\t{ RTOKEN('&'); }\n+<EXPRESSION,MRI>\"|\"\t\t\t{ RTOKEN('|'); }\n+<SCRIPT,EXPRESSION,MRI>\"~\"\t\t{ RTOKEN('~'); }\n+<SCRIPT,EXPRESSION,MRI>\"!\"\t\t{ RTOKEN('!'); }\n+<EXPRESSION,MRI>\"?\"\t\t\t{ RTOKEN('?'); }\n+<EXPRESSION,MRI>\"*\"\t\t\t{ RTOKEN('*'); }\n+<SCRIPT,EXPRESSION,MRI>\"+\"\t\t{ RTOKEN('+'); }\n+<SCRIPT,EXPRESSION,MRI>\"-\"\t\t{ RTOKEN('-'); }\n+<EXPRESSION,MRI>\"/\"\t\t\t{ RTOKEN('/'); }\n+<EXPRESSION,MRI>\"%\"\t\t\t{ RTOKEN('%'); }\n+<EXPRESSION,MRI>\"<\"\t\t\t{ RTOKEN('<'); }\n+<SCRIPT,EXPRESSION,MRI,WILD>\"=\"\t\t{ RTOKEN('='); }\n <SCRIPT,EXPRESSION,MRI,WILD>\"}\"\t\t{ RTOKEN('}'); }\n <SCRIPT,EXPRESSION,MRI,WILD>\"{\"\t\t{ RTOKEN('{'); }\n-<SCRIPT,EXPRESSION,MRI,WILD,INPUTLIST>\")\" { RTOKEN(')');}\n-<SCRIPT,EXPRESSION,MRI,WILD,INPUTLIST>\"(\" { RTOKEN('(');}\n+<SCRIPT,EXPRESSION,MRI,WILD,INPUTLIST>\")\" { RTOKEN(')'); }\n+<SCRIPT,EXPRESSION,MRI,WILD,INPUTLIST>\"(\" { RTOKEN('('); }\n <SCRIPT,EXPRESSION,MRI>\":\"\t\t{ RTOKEN(':'); }\n-<SCRIPT,EXPRESSION,MRI,WILD>\";\"\t\t{ RTOKEN(';');}\n-<SCRIPT>\"MEMORY\"\t\t\t{ RTOKEN(MEMORY);}\n-<SCRIPT>\"REGION_ALIAS\"\t\t\t{ RTOKEN(REGION_ALIAS);}\n-<SCRIPT>\"LD_FEATURE\"\t\t\t{ RTOKEN(LD_FEATURE);}\n-<SCRIPT,EXPRESSION>\"ORIGIN\"\t\t{ RTOKEN(ORIGIN);}\n-<SCRIPT>\"VERSION\"\t\t\t{ RTOKEN(VERSIONK);}\n-<SCRIPT,EXPRESSION>\"BLOCK\"\t\t{ RTOKEN(BLOCK);}\n-<SCRIPT,EXPRESSION>\"BIND\"\t\t{ RTOKEN(BIND);}\n-<SCRIPT,EXPRESSION>\"LENGTH\"\t\t{ RTOKEN(LENGTH);}\n-<SCRIPT,EXPRESSION>\"ALIGN\"\t\t{ RTOKEN(ALIGN_K);}\n-<SCRIPT,EXPRESSION>\"DATA_SEGMENT_ALIGN\"\t{ RTOKEN(DATA_SEGMENT_ALIGN);}\n-<SCRIPT,EXPRESSION>\"DATA_SEGMENT_RELRO_END\" { RTOKEN(DATA_SEGMENT_RELRO_END);}\n-<SCRIPT,EXPRESSION>\"DATA_SEGMENT_END\"\t{ RTOKEN(DATA_SEGMENT_END);}\n-<SCRIPT,EXPRESSION>\"ADDR\"\t\t{ RTOKEN(ADDR);}\n-<SCRIPT,EXPRESSION>\"LOADADDR\"\t\t{ RTOKEN(LOADADDR);}\n+<SCRIPT,EXPRESSION,MRI,WILD>\";\"\t\t{ RTOKEN(';'); }\n+<SCRIPT>\"MEMORY\"\t\t\t{ RTOKEN(MEMORY); }\n+<SCRIPT>\"REGION_ALIAS\"\t\t\t{ RTOKEN(REGION_ALIAS); }\n+<SCRIPT>\"LD_FEATURE\"\t\t\t{ RTOKEN(LD_FEATURE); }\n+<SCRIPT,EXPRESSION>\"ORIGIN\"\t\t{ RTOKEN(ORIGIN); }\n+<SCRIPT>\"VERSION\"\t\t\t{ RTOKEN(VERSIONK); }\n+<SCRIPT,EXPRESSION>\"BLOCK\"\t\t{ RTOKEN(BLOCK); }\n+<SCRIPT,EXPRESSION>\"BIND\"\t\t{ RTOKEN(BIND); }\n+<SCRIPT,EXPRESSION>\"LENGTH\"\t\t{ RTOKEN(LENGTH); }\n+<SCRIPT,EXPRESSION>\"ALIGN\"\t\t{ RTOKEN(ALIGN_K); }\n+<SCRIPT,EXPRESSION>\"DATA_SEGMENT_ALIGN\"\t{ RTOKEN(DATA_SEGMENT_ALIGN); }\n+<SCRIPT,EXPRESSION>\"DATA_SEGMENT_RELRO_END\" { RTOKEN(DATA_SEGMENT_RELRO_END); }\n+<SCRIPT,EXPRESSION>\"DATA_SEGMENT_END\"\t{ RTOKEN(DATA_SEGMENT_END); }\n+<SCRIPT,EXPRESSION>\"ADDR\"\t\t{ RTOKEN(ADDR); }\n+<SCRIPT,EXPRESSION>\"LOADADDR\"\t\t{ RTOKEN(LOADADDR); }\n <SCRIPT,EXPRESSION>\"ALIGNOF\"\t\t{ RTOKEN(ALIGNOF); }\n <SCRIPT,EXPRESSION>\"ABSOLUTE\"\t\t{ RTOKEN(ABSOLUTE); }\n-<EXPRESSION>\"MAX\"\t\t\t{ RTOKEN(MAX_K); }\n-<EXPRESSION>\"MIN\"\t\t\t{ RTOKEN(MIN_K); }\n-<EXPRESSION>\"LOG2CEIL\"\t\t\t{ RTOKEN(LOG2CEIL); }\n+<SCRIPT,EXPRESSION>\"MAX\"\t\t{ RTOKEN(MAX_K); }\n+<SCRIPT,EXPRESSION>\"MIN\"\t\t{ RTOKEN(MIN_K); }\n+<SCRIPT,EXPRESSION>\"LOG2CEIL\"\t\t{ RTOKEN(LOG2CEIL); }\n <SCRIPT,EXPRESSION,WILD>\"ASSERT\"\t{ RTOKEN(ASSERT_K); }\n-<SCRIPT,WILD>\"ENTRY\"\t\t\t{ RTOKEN(ENTRY);}\n-<SCRIPT,MRI>\"EXTERN\"\t\t\t{ RTOKEN(EXTERN);}\n-<SCRIPT,EXPRESSION>\"NEXT\"\t\t{ RTOKEN(NEXT);}\n-<SCRIPT,EXPRESSION>\"SIZEOF_HEADERS\"\t{ RTOKEN(SIZEOF_HEADERS);}\n-<SCRIPT,EXPRESSION>\"SEGMENT_START\"\t{ RTOKEN(SEGMENT_START);}\n-<SCRIPT>\"MAP\"\t\t\t\t{ RTOKEN(MAP);}\n-<SCRIPT,EXPRESSION>\"SIZEOF\"\t\t{ RTOKEN(SIZEOF);}\n-<SCRIPT>\"TARGET\"\t\t\t{ RTOKEN(TARGET_K);}\n-<SCRIPT>\"SEARCH_DIR\"\t\t\t{ RTOKEN(SEARCH_DIR);}\n-<SCRIPT>\"OUTPUT\"\t\t\t{ RTOKEN(OUTPUT);}\n-<SCRIPT>\"INPUT\"\t\t\t\t{ RTOKEN(INPUT);}\n-<SCRIPT,EXPRESSION,WILD>\"GROUP\"\t\t{ RTOKEN(GROUP);}\n-<SCRIPT,EXPRESSION,INPUTLIST>\"AS_NEEDED\" { RTOKEN(AS_NEEDED);}\n-<SCRIPT,EXPRESSION>\"DEFINED\"\t\t{ RTOKEN(DEFINED);}\n-<SCRIPT,WILD>\"CREATE_OBJECT_SYMBOLS\"\t{ RTOKEN(CREATE_OBJECT_SYMBOLS);}\n-<SCRIPT,WILD>\"CONSTRUCTORS\"\t\t{ RTOKEN(CONSTRUCTORS);}\n-<SCRIPT>\"FORCE_COMMON_ALLOCATION\"\t{ RTOKEN(FORCE_COMMON_ALLOCATION);}\n-<SCRIPT>\"FORCE_GROUP_ALLOCATION\"\t{ RTOKEN(FORCE_GROUP_ALLOCATION);}\n-<SCRIPT>\"INHIBIT_COMMON_ALLOCATION\"\t{ RTOKEN(INHIBIT_COMMON_ALLOCATION);}\n-<SCRIPT>\"SECTIONS\"\t\t\t{ RTOKEN(SECTIONS);}\n-<SCRIPT>\"INSERT\"\t\t\t{ RTOKEN(INSERT_K);}\n-<SCRIPT>\"AFTER\"\t\t\t\t{ RTOKEN(AFTER);}\n-<SCRIPT>\"BEFORE\"\t\t\t{ RTOKEN(BEFORE);}\n-<SCRIPT,WILD>\"FILL\"\t\t\t{ RTOKEN(FILL);}\n-<SCRIPT>\"STARTUP\"\t\t\t{ RTOKEN(STARTUP);}\n-<SCRIPT>\"OUTPUT_FORMAT\"\t\t\t{ RTOKEN(OUTPUT_FORMAT);}\n-<SCRIPT>\"OUTPUT_ARCH\"\t\t\t{ RTOKEN(OUTPUT_ARCH);}\n-<SCRIPT>\"HLL\"\t\t\t\t{ RTOKEN(HLL);}\n-<SCRIPT>\"SYSLIB\"\t\t\t{ RTOKEN(SYSLIB);}\n-<SCRIPT>\"FLOAT\"\t\t\t\t{ RTOKEN(FLOAT);}\n-<SCRIPT,WILD>\"QUAD\"\t\t\t{ RTOKEN( QUAD);}\n-<SCRIPT,WILD>\"SQUAD\"\t\t\t{ RTOKEN( SQUAD);}\n-<SCRIPT,WILD>\"LONG\"\t\t\t{ RTOKEN( LONG);}\n-<SCRIPT,WILD>\"SHORT\"\t\t\t{ RTOKEN( SHORT);}\n-<SCRIPT,WILD>\"BYTE\"\t\t\t{ RTOKEN( BYTE);}\n-<SCRIPT>\"NOFLOAT\"\t\t\t{ RTOKEN(NOFLOAT);}\n-<SCRIPT,EXPRESSION>\"NOCROSSREFS\"\t{ RTOKEN(NOCROSSREFS);}\n-<SCRIPT,EXPRESSION>\"NOCROSSREFS_TO\"\t{ RTOKEN(NOCROSSREFS_TO);}\n-<SCRIPT>\"OVERLAY\"\t\t\t{ RTOKEN(OVERLAY); }\n-<SCRIPT,WILD>\"SORT_BY_NAME\"\t\t{ RTOKEN(SORT_BY_NAME); }\n-<SCRIPT,WILD>\"SORT_BY_ALIGNMENT\"\t{ RTOKEN(SORT_BY_ALIGNMENT); }\n-<SCRIPT,WILD>\"SORT\"\t\t\t{ RTOKEN(SORT_BY_NAME); }\n-<SCRIPT,WILD>\"SORT_BY_INIT_PRIORITY\"\t{ RTOKEN(SORT_BY_INIT_PRIORITY); }\n-<SCRIPT,WILD>\"SORT_NONE\"\t\t{ RTOKEN(SORT_NONE); }\n-<SCRIPT,EXPRESSION>\"NOLOAD\"\t\t{ RTOKEN(NOLOAD);}\n-<SCRIPT,EXPRESSION>\"READONLY\"\t\t{ RTOKEN(READONLY);}\n-<SCRIPT,EXPRESSION>\"DSECT\"\t\t{ RTOKEN(DSECT);}\n-<SCRIPT,EXPRESSION>\"COPY\"\t\t{ RTOKEN(COPY);}\n-<SCRIPT,EXPRESSION>\"INFO\"\t\t{ RTOKEN(INFO);}\n-<SCRIPT,EXPRESSION>\"OVERLAY\"\t\t{ RTOKEN(OVERLAY);}\n-<EXPRESSION>\"ONLY_IF_RO\"\t\t{ RTOKEN(ONLY_IF_RO); }\n-<EXPRESSION>\"ONLY_IF_RW\"\t\t{ RTOKEN(ONLY_IF_RW); }\n-<EXPRESSION>\"SPECIAL\"\t\t\t{ RTOKEN(SPECIAL); }\n-<SCRIPT>\"o\"\t\t\t\t{ RTOKEN(ORIGIN);}\n-<SCRIPT>\"org\"\t\t\t\t{ RTOKEN(ORIGIN);}\n-<SCRIPT>\"l\"\t\t\t\t{ RTOKEN( LENGTH);}\n-<SCRIPT>\"len\"\t\t\t\t{ RTOKEN( LENGTH);}\n-<SCRIPT,EXPRESSION,WILD>\"INPUT_SECTION_FLAGS\" { RTOKEN(INPUT_SECTION_FLAGS); }\n-<SCRIPT,EXPRESSION,WILD>\"INCLUDE\"\t{ RTOKEN(INCLUDE);}\n-<SCRIPT>\"PHDRS\"\t\t\t\t{ RTOKEN (PHDRS); }\n+<SCRIPT>\"ENTRY\"\t\t\t\t{ RTOKEN(ENTRY); }\n+<SCRIPT,MRI>\"EXTERN\"\t\t\t{ RTOKEN(EXTERN); }\n+<SCRIPT,EXPRESSION>\"NEXT\"\t\t{ RTOKEN(NEXT); }\n+<SCRIPT,EXPRESSION>\"SIZEOF_HEADERS\"\t{ RTOKEN(SIZEOF_HEADERS); }\n+<SCRIPT,EXPRESSION>\"SEGMENT_START\"\t{ RTOKEN(SEGMENT_START); }\n+<SCRIPT>\"MAP\"\t\t\t\t{ RTOKEN(MAP); }\n+<SCRIPT,EXPRESSION>\"SIZEOF\"\t\t{ RTOKEN(SIZEOF); }\n+<SCRIPT>\"TARGET\"\t\t\t{ RTOKEN(TARGET_K); }\n+<SCRIPT>\"SEARCH_DIR\"\t\t\t{ RTOKEN(SEARCH_DIR); }\n+<SCRIPT>\"OUTPUT\"\t\t\t{ RTOKEN(OUTPUT); }\n+<SCRIPT>\"INPUT\"\t\t\t\t{ RTOKEN(INPUT); }\n+<SCRIPT>\"GROUP\"\t\t\t\t{ RTOKEN(GROUP); }\n+<INPUTLIST>\"AS_NEEDED\"\t\t\t{ RTOKEN(AS_NEEDED); }\n+<SCRIPT,EXPRESSION>\"DEFINED\"\t\t{ RTOKEN(DEFINED); }\n+<WILD>\"CREATE_OBJECT_SYMBOLS\"\t\t{ RTOKEN(CREATE_OBJECT_SYMBOLS); }\n+<WILD>\"CONSTRUCTORS\"\t\t\t{ RTOKEN(CONSTRUCTORS); }\n+<SCRIPT>\"FORCE_COMMON_ALLOCATION\"\t{ RTOKEN(FORCE_COMMON_ALLOCATION); }\n+<SCRIPT>\"FORCE_GROUP_ALLOCATION\"\t{ RTOKEN(FORCE_GROUP_ALLOCATION); }\n+<SCRIPT>\"INHIBIT_COMMON_ALLOCATION\"\t{ RTOKEN(INHIBIT_COMMON_ALLOCATION); }\n+<SCRIPT>\"SECTIONS\"\t\t\t{ RTOKEN(SECTIONS); }\n+<SCRIPT>\"INSERT\"\t\t\t{ RTOKEN(INSERT_K); }\n+<SCRIPT>\"AFTER\"\t\t\t\t{ RTOKEN(AFTER); }\n+<SCRIPT>\"BEFORE\"\t\t\t{ RTOKEN(BEFORE); }\n+<WILD>\"FILL\"\t\t\t\t{ RTOKEN(FILL); }\n+<SCRIPT>\"STARTUP\"\t\t\t{ RTOKEN(STARTUP); }\n+<SCRIPT>\"OUTPUT_FORMAT\"\t\t\t{ RTOKEN(OUTPUT_FORMAT); }\n+<SCRIPT>\"OUTPUT_ARCH\"\t\t\t{ RTOKEN(OUTPUT_ARCH); }\n+<SCRIPT>\"HLL\"\t\t\t\t{ RTOKEN(HLL); }\n+<SCRIPT>\"SYSLIB\"\t\t\t{ RTOKEN(SYSLIB); }\n+<SCRIPT>\"FLOAT\"\t\t\t\t{ RTOKEN(FLOAT); }\n+<WILD>\"QUAD\"\t\t\t\t{ RTOKEN(QUAD); }\n+<WILD>\"SQUAD\"\t\t\t\t{ RTOKEN(SQUAD); }\n+<WILD>\"LONG\"\t\t\t\t{ RTOKEN(LONG); }\n+<WILD>\"SHORT\"\t\t\t\t{ RTOKEN(SHORT); }\n+<WILD>\"BYTE\"\t\t\t\t{ RTOKEN(BYTE); }\n+<SCRIPT>\"NOFLOAT\"\t\t\t{ RTOKEN(NOFLOAT); }\n+<SCRIPT,EXPRESSION>\"NOCROSSREFS\"\t{ RTOKEN(NOCROSSREFS); }\n+<SCRIPT,EXPRESSION>\"NOCROSSREFS_TO\"\t{ RTOKEN(NOCROSSREFS_TO); }\n+<SCRIPT,EXPRESSION>\"OVERLAY\"\t\t{ RTOKEN(OVERLAY); }\n+<WILD>\"SORT_BY_NAME\"\t\t\t{ RTOKEN(SORT_BY_NAME); }\n+<WILD>\"SORT_BY_ALIGNMENT\"\t\t{ RTOKEN(SORT_BY_ALIGNMENT); }\n+<WILD>\"SORT\"\t\t\t\t{ RTOKEN(SORT_BY_NAME); }\n+<WILD>\"SORT_BY_INIT_PRIORITY\"\t\t{ RTOKEN(SORT_BY_INIT_PRIORITY); }\n+<WILD>\"SORT_NONE\"\t\t\t{ RTOKEN(SORT_NONE); }\n+<EXPRESSION>\"NOLOAD\"\t\t\t{ RTOKEN(NOLOAD); }\n+<EXPRESSION>\"READONLY\"\t\t\t{ RTOKEN(READONLY); }\n+<EXPRESSION>\"DSECT\"\t\t\t{ RTOKEN(DSECT); }\n+<EXPRESSION>\"COPY\"\t\t\t{ RTOKEN(COPY); }\n+<EXPRESSION>\"INFO\"\t\t\t{ RTOKEN(INFO); }\n+<SCRIPT,EXPRESSION>\"ONLY_IF_RO\"\t\t{ RTOKEN(ONLY_IF_RO); }\n+<SCRIPT,EXPRESSION>\"ONLY_IF_RW\"\t\t{ RTOKEN(ONLY_IF_RW); }\n+<SCRIPT,EXPRESSION>\"SPECIAL\"\t\t{ RTOKEN(SPECIAL); }\n+<SCRIPT>\"o\"\t\t\t\t{ RTOKEN(ORIGIN); }\n+<SCRIPT>\"org\"\t\t\t\t{ RTOKEN(ORIGIN); }\n+<SCRIPT>\"l\"\t\t\t\t{ RTOKEN(LENGTH); }\n+<SCRIPT>\"len\"\t\t\t\t{ RTOKEN(LENGTH); }\n+<WILD>\"INPUT_SECTION_FLAGS\"\t\t{ RTOKEN(INPUT_SECTION_FLAGS); }\n+<SCRIPT,EXPRESSION,WILD,MRI>\"INCLUDE\"\t{ RTOKEN(INCLUDE);}\n+<SCRIPT>\"PHDRS\"\t\t\t\t{ RTOKEN(PHDRS); }\n <SCRIPT,EXPRESSION,WILD>\"AT\"\t\t{ RTOKEN(AT);}\n <SCRIPT,EXPRESSION>\"ALIGN_WITH_INPUT\"\t{ RTOKEN(ALIGN_WITH_INPUT);}\n <SCRIPT,EXPRESSION>\"SUBALIGN\"\t\t{ RTOKEN(SUBALIGN);}\n <SCRIPT,EXPRESSION,WILD>\"HIDDEN\"\t{ RTOKEN(HIDDEN); }\n <SCRIPT,EXPRESSION,WILD>\"PROVIDE\"\t{ RTOKEN(PROVIDE); }\n <SCRIPT,EXPRESSION,WILD>\"PROVIDE_HIDDEN\" { RTOKEN(PROVIDE_HIDDEN); }\n-<SCRIPT,EXPRESSION,WILD>\"KEEP\"\t\t{ RTOKEN(KEEP); }\n-<SCRIPT,EXPRESSION,WILD>\"EXCLUDE_FILE\"\t{ RTOKEN(EXCLUDE_FILE); }\n+<WILD>\"KEEP\"\t\t\t\t{ RTOKEN(KEEP); }\n+<WILD>\"EXCLUDE_FILE\"\t\t\t{ RTOKEN(EXCLUDE_FILE); }\n <SCRIPT,EXPRESSION>\"CONSTANT\"\t\t{ RTOKEN(CONSTANT);}\n \n <MRI>\"#\".*\\n?\t\t\t{ ++ lineno; }\n@@ -384,14 +407,12 @@ V_IDENTIFIER [*?.$_a-zA-Z\\[\\]\\-\\!\\^\\\\]([*?.$_a-zA-Z0-9\\[\\]\\-\\!\\^\\\\]|::)*\n \t\t\t\t  yylval.name = xstrdup (yytext);\n \t\t\t\t  return NAME;\n \t\t\t\t}\n+  /* The following rule is to prevent a fill expression on the output\n+     section before /DISCARD/ interpreting the '/' as a divide.  */\n <EXPRESSION>\"/DISCARD/\"\t\t{\n \t\t\t\t  yylval.name = xstrdup (yytext);\n \t\t\t\t  return NAME;\n \t\t\t\t}\n-<EXPRESSION>\"-l\"{NOCFILENAMECHAR}+ {\n-\t\t\t\t  yylval.name = xstrdup (yytext + 2);\n-\t\t\t\t  return LNAME;\n-\t\t\t\t}\n <WILD>{WILDCHAR}* {\n \t\t/* Annoyingly, this pattern can match comments, and we have\n \t\t   longest match issues to consider.  So if the first two\n@@ -473,7 +494,7 @@ V_IDENTIFIER [*?.$_a-zA-Z\\[\\]\\-\\!\\^\\\\]([*?.$_a-zA-Z0-9\\[\\]\\-\\!\\^\\\\]|::)*\n   return END;\n }\n \n-<SCRIPT,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.\tlex_warn_invalid (\" in script\", yytext);\n+<SCRIPT,WILD,MRI,VERS_START,VERS_SCRIPT,VERS_NODE>.\tlex_warn_invalid (\" in script\", yytext);\n <EXPRESSION>.\tlex_warn_invalid (\" in expression\", yytext);\n \n %%"
    }
  ]
}