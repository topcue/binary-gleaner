{
  "sha": "9a6e099f43a13efb0ee274002de689c2cb1b7e23",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWE2ZTA5OWY0M2ExM2VmYjBlZTI3NDAwMmRlNjg5YzJjYjFiN2UyMw==",
  "commit": {
    "author": {
      "name": "Michael Weghorn",
      "email": "m.weghorn@posteo.de",
      "date": "2021-04-27T13:55:27Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-04-27T15:22:32Z"
    },
    "message": "gdbsupport: allow to specify dependencies between observers\n\nPreviously, the observers attached to an observable were always notified\nin the order in which they had been attached.  That order is not easily\ncontrolled, because observers are typically attached in _initialize_*\nfunctions, which are called in an undefined order.\n\nHowever, an observer may require that another observer attached only\nlater is called before itself is.\n\nTherefore, extend the 'observable' class to allow explicitly specifying\ndependencies when attaching observers, by adding the possibility to\nspecify tokens for observers that it depends on.\n\nTo make sure dependencies are notified before observers depending on\nthem, the vector holding the observers is sorted in a way that\ndependencies come before observers depending on them.  The current\nimplementation for sorting uses the depth-first search algorithm for\ntopological sorting as described at [1].\n\nExtend the observable unit tests to cover this case as well.  Check that\nthis works for a few different orders in which the observers are\nattached.\n\nThis newly introduced mechanism to explicitly specify dependencies will\nbe used in a follow-up commit.\n\n[1] https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n\nTested on x86_64-linux (Debian testing).\n\ngdb/ChangeLog:\n\n\t* unittests/observable-selftests.c (dependency_test_counters):\n\tNew.\n\t(observer_token0, observer_token1, observer_token2,\n\tobserver_token3, observer_token4, observer_token5): New.\n\t(struct dependency_observer_data): New struct.\n\t(observer_dependency_test_callback): New function.\n\t(test_observers): New.\n\t(run_dependency_test): New function.\n\t(test_dependency): New.\n\t(_initialize_observer_selftest): Register dependency test.\n\ngdbsupport/ChangeLog:\n\n\t* observable.h (class observable): Extend to allow specifying\n\tdependencies between observers, keep vector holding observers\n\tsorted so that dependencies are notified before observers\n\tdepending on them.\n\nChange-Id: I5399def1eeb69ca99e28c9f1fdf321d78b530bdb",
    "tree": {
      "sha": "b403ea072bd3178cd60673deac400a29eaedd295",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b403ea072bd3178cd60673deac400a29eaedd295"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9a6e099f43a13efb0ee274002de689c2cb1b7e23",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9a6e099f43a13efb0ee274002de689c2cb1b7e23",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9a6e099f43a13efb0ee274002de689c2cb1b7e23",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9a6e099f43a13efb0ee274002de689c2cb1b7e23/comments",
  "author": {
    "login": "michaelweghorn",
    "id": 6560939,
    "node_id": "MDQ6VXNlcjY1NjA5Mzk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6560939?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/michaelweghorn",
    "html_url": "https://github.com/michaelweghorn",
    "followers_url": "https://api.github.com/users/michaelweghorn/followers",
    "following_url": "https://api.github.com/users/michaelweghorn/following{/other_user}",
    "gists_url": "https://api.github.com/users/michaelweghorn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/michaelweghorn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/michaelweghorn/subscriptions",
    "organizations_url": "https://api.github.com/users/michaelweghorn/orgs",
    "repos_url": "https://api.github.com/users/michaelweghorn/repos",
    "events_url": "https://api.github.com/users/michaelweghorn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/michaelweghorn/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "60cfa10c36668e3298bab35e9dc86624f3ddf61a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/60cfa10c36668e3298bab35e9dc86624f3ddf61a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/60cfa10c36668e3298bab35e9dc86624f3ddf61a"
    }
  ],
  "stats": {
    "total": 251,
    "additions": 235,
    "deletions": 16
  },
  "files": [
    {
      "sha": "cdad68a72547d7364c4bc07c6931127868b9c0ad",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9a6e099f43a13efb0ee274002de689c2cb1b7e23",
      "patch": "@@ -1,3 +1,17 @@\n+2021-04-27  Michael Weghorn  <m.weghorn@posteo.de>\n+\t    Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* unittests/observable-selftests.c (dependency_test_counters):\n+\tNew.\n+\t(observer_token0, observer_token1, observer_token2,\n+\tobserver_token3, observer_token4, observer_token5): New.\n+\t(struct dependency_observer_data): New struct.\n+\t(observer_dependency_test_callback): New function.\n+\t(test_observers): New.\n+\t(run_dependency_test): New function.\n+\t(test_dependency): New.\n+\t(_initialize_observer_selftest): Register dependency test.\n+\n 2021-04-26  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \tPR gdb/27773"
    },
    {
      "sha": "b41a01ef843d754ee6388b1277093e818c2457c2",
      "filename": "gdb/unittests/observable-selftests.c",
      "status": "modified",
      "additions": 113,
      "deletions": 0,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdb/unittests/observable-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdb/unittests/observable-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/observable-selftests.c?ref=9a6e099f43a13efb0ee274002de689c2cb1b7e23",
      "patch": "@@ -30,6 +30,60 @@ static int test_first_observer = 0;\n static int test_second_observer = 0;\n static int test_third_observer = 0;\n \n+/* Counters for observers used for dependency tests.  */\n+static std::vector<int> dependency_test_counters;\n+\n+/* Tokens for observers used for dependency tests.  */\n+static gdb::observers::token observer_token0;\n+static gdb::observers::token observer_token1;\n+static gdb::observers::token observer_token2;\n+static gdb::observers::token observer_token3;\n+static gdb::observers::token observer_token4;\n+static gdb::observers::token observer_token5;\n+\n+/* Data for one observer used for checking that dependencies work as expected;\n+   dependencies are specified using their indices into the 'test_observers'\n+   vector here for simplicity and mapped to corresponding tokens later.  */\n+struct dependency_observer_data\n+{\n+  gdb::observers::token *token;\n+\n+  /* Name of the observer to use on attach.  */\n+  const char *name;\n+\n+  /* Indices of observers that this one directly depends on.  */\n+  std::vector<int> direct_dependencies;\n+\n+  /* Indices for all dependencies, including transitive ones.  */\n+  std::vector<int> all_dependencies;\n+\n+  /* Function to attach to the observable for this observer.  */\n+  std::function<void (int)> callback;\n+};\n+\n+static void observer_dependency_test_callback (size_t index);\n+\n+/* Data for observers to use for dependency tests, using some sample\n+   dependencies between the observers.  */\n+static std::vector<dependency_observer_data> test_observers = {\n+  {&observer_token0, \"test0\", {}, {},\n+   [] (int) { observer_dependency_test_callback (0); }},\n+  {&observer_token1, \"test1\", {0}, {0},\n+   [] (int) { observer_dependency_test_callback (1); }},\n+  {&observer_token2, \"test2\", {1}, {0, 1},\n+   [] (int) { observer_dependency_test_callback (2); }},\n+  {&observer_token3, \"test3\", {1}, {0, 1},\n+   [] (int) { observer_dependency_test_callback (3); }},\n+  {&observer_token4, \"test4\", {2, 3, 5}, {0, 1, 2, 3, 5},\n+   [] (int) { observer_dependency_test_callback (4); }},\n+  {&observer_token5, \"test5\", {0}, {0},\n+   [] (int) { observer_dependency_test_callback (5); }},\n+  {nullptr, \"test6\", {4}, {0, 1, 2, 3, 4, 5},\n+   [] (int) { observer_dependency_test_callback (6); }},\n+  {nullptr, \"test7\", {0}, {0},\n+   [] (int) { observer_dependency_test_callback (7); }},\n+};\n+\n static void\n test_first_notification_function (int arg)\n {\n@@ -63,6 +117,63 @@ notify_check_counters (int one, int two, int three)\n   SELF_CHECK (three == test_third_observer);\n }\n \n+/* Function for each observer to run when being notified during the dependency\n+   tests.  Verify that the observer's dependencies have been notified before the\n+   observer itself by checking their counters, then increase the observer's own\n+   counter.  */\n+static void\n+observer_dependency_test_callback (size_t index)\n+{\n+  /* Check that dependencies have already been notified.  */\n+  for (int i : test_observers[index].all_dependencies)\n+    SELF_CHECK (dependency_test_counters[i] == 1);\n+\n+  /* Increase own counter.  */\n+  dependency_test_counters[index]++;\n+}\n+\n+/* Run a dependency test by attaching the observers in the specified order\n+   then notifying them.  */\n+static void\n+run_dependency_test (std::vector<int> insertion_order)\n+{\n+  gdb::observers::observable<int> dependency_test_notification\n+    (\"dependency_test_notification\");\n+\n+  /* Reset counters.  */\n+  dependency_test_counters = std::vector<int> (test_observers.size (), 0);\n+\n+  /* Attach all observers in the given order, specifying dependencies.  */\n+  for (int i : insertion_order)\n+    {\n+      const dependency_observer_data &o = test_observers[i];\n+\n+      /* Get tokens for dependencies using their indices.  */\n+      std::vector<const gdb::observers::token *> dependency_tokens;\n+      for (int index : o.all_dependencies)\n+\tdependency_tokens.emplace_back (test_observers[index].token);\n+\n+      if (o.token != nullptr)\n+\tdependency_test_notification.attach\n+\t  (o.callback, *o.token, o.name, dependency_tokens);\n+      else\n+\tdependency_test_notification.attach (o.callback, o.name,\n+\t\t\t\t\t     dependency_tokens);\n+    }\n+\n+  /* Notify observers, they check that their dependencies were notified.  */\n+  dependency_test_notification.notify (1);\n+}\n+\n+static void\n+test_dependency ()\n+{\n+  /* Run dependency tests with different insertion orders.  */\n+  run_dependency_test ({0, 1, 2, 3, 4, 5, 6, 7});\n+  run_dependency_test ({7, 6, 5, 4, 3, 2, 1, 0});\n+  run_dependency_test ({0, 3, 2, 1, 7, 6, 4, 5});\n+}\n+\n static void\n run_tests ()\n {\n@@ -133,4 +244,6 @@ _initialize_observer_selftest ()\n {\n   selftests::register_test (\"gdb::observers\",\n \t\t\t    selftests::observers::run_tests);\n+  selftests::register_test (\"gdb::observers dependency\",\n+\t\t\t    selftests::observers::test_dependency);\n }"
    },
    {
      "sha": "2b575ea3118f4a77b934909e589421088a3e61bd",
      "filename": "gdbsupport/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdbsupport/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdbsupport/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/ChangeLog?ref=9a6e099f43a13efb0ee274002de689c2cb1b7e23",
      "patch": "@@ -1,3 +1,11 @@\n+2021-04-27  Michael Weghorn  <m.weghorn@posteo.de>\n+\t    Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* observable.h (class observable): Extend to allow specifying\n+\tdependencies between observers, keep vector holding observers\n+\tsorted so that dependencies are notified before observers\n+\tdepending on them.\n+\n 2021-04-24  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* observable.h (observer_debug_printf,"
    },
    {
      "sha": "8ed56612ad065d1c0ed22534ce6c73c3c64b9a1f",
      "filename": "gdbsupport/observable.h",
      "status": "modified",
      "additions": 100,
      "deletions": 16,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdbsupport/observable.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a6e099f43a13efb0ee274002de689c2cb1b7e23/gdbsupport/observable.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/observable.h?ref=9a6e099f43a13efb0ee274002de689c2cb1b7e23",
      "patch": "@@ -71,13 +71,15 @@ class observable\n private:\n   struct observer\n   {\n-    observer (const struct token *token, func_type func, const char *name)\n-      : token (token), func (func), name (name)\n+    observer (const struct token *token, func_type func, const char *name,\n+\t      const std::vector<const struct token *> &dependencies)\n+      : token (token), func (func), name (name), dependencies (dependencies)\n     {}\n \n     const struct token *token;\n     func_type func;\n     const char *name;\n+    std::vector<const struct token *> dependencies;\n   };\n \n public:\n@@ -88,30 +90,34 @@ class observable\n \n   DISABLE_COPY_AND_ASSIGN (observable);\n \n-  /* Attach F as an observer to this observable.  F cannot be\n-     detached.\n+  /* Attach F as an observer to this observable.  F cannot be detached or\n+     specified as a dependency.\n+\n+     DEPENDENCIES is a list of tokens of observers to be notified before this\n+     one.\n \n      NAME is the name of the observer, used for debug output purposes.  Its\n      lifetime must be at least as long as the observer is attached.  */\n-  void attach (const func_type &f, const char *name)\n+  void attach (const func_type &f, const char *name,\n+\t       const std::vector<const struct token *> &dependencies = {})\n   {\n-    observer_debug_printf (\"Attaching observable %s to observer %s\",\n-\t\t\t   name, m_name);\n-\n-    m_observers.emplace_back (nullptr, f, name);\n+    attach (f, nullptr, name, dependencies);\n   }\n \n-  /* Attach F as an observer to this observable.  T is a reference to\n-     a token that can be used to later remove F.\n+  /* Attach F as an observer to this observable.\n+\n+     T is a reference to a token that can be used to later remove F or specify F\n+     as a dependency of another observer.\n+\n+     DEPENDENCIES is a list of tokens of observers to be notified before this\n+     one.\n \n      NAME is the name of the observer, used for debug output purposes.  Its\n      lifetime must be at least as long as the observer is attached.  */\n-  void attach (const func_type &f, const token &t, const char *name)\n+  void attach (const func_type &f, const token &t, const char *name,\n+\t       const std::vector<const struct token *> &dependencies = {})\n   {\n-    observer_debug_printf (\"Attaching observable %s to observer %s\",\n-\t\t\t   name, m_name);\n-\n-    m_observers.emplace_back (&t, f, name);\n+    attach (f, &t, name, dependencies);\n   }\n \n   /* Remove observers associated with T from this observable.  T is\n@@ -149,6 +155,84 @@ class observable\n \n   std::vector<observer> m_observers;\n   const char *m_name;\n+\n+  /* Use for sorting algorithm, to indicate which observer we have visited.  */\n+  enum class visit_state\n+  {\n+    NOT_VISITED,\n+    VISITING,\n+    VISITED,\n+  };\n+\n+  /* Helper method for topological sort using depth-first search algorithm.\n+\n+     Visit all dependencies of observer at INDEX in M_OBSERVERS (later referred\n+     to as \"the observer\").  Then append the observer to SORTED_OBSERVERS.\n+\n+     If the observer is already visited, do nothing.  */\n+  void visit_for_sorting (std::vector<observer> &sorted_observers,\n+                          std::vector<visit_state> &visit_states, int index)\n+  {\n+    if (visit_states[index] == visit_state::VISITED)\n+      return;\n+\n+    /* If we are already visiting this observer, it means there's a cycle.  */\n+    gdb_assert (visit_states[index] != visit_state::VISITING);\n+\n+    visit_states[index] = visit_state::VISITING;\n+\n+    /* For each dependency of this observer...  */\n+    for (const token *dep : m_observers[index].dependencies)\n+      {\n+\t/* ... find the observer that has token DEP.  If found, visit it.  */\n+        auto it_dep\n+            = std::find_if (m_observers.begin (), m_observers.end (),\n+                            [&] (observer o) { return o.token == dep; });\n+        if (it_dep != m_observers.end ())\n+          {\n+            int i = std::distance (m_observers.begin (), it_dep);\n+            visit_for_sorting (sorted_observers, visit_states, i);\n+          }\n+      }\n+\n+    visit_states[index] = visit_state::VISITED;\n+    sorted_observers.push_back (m_observers[index]);\n+  }\n+\n+  /* Sort the observers, so that dependencies come before observers\n+     depending on them.\n+\n+     Uses depth-first search algorithm for topological sorting, see\n+     https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search .  */\n+  void sort_observers ()\n+  {\n+    std::vector<observer> sorted_observers;\n+    std::vector<visit_state> visit_states (m_observers.size (),\n+\t\t\t\t\t   visit_state::NOT_VISITED);\n+\n+    for (size_t i = 0; i < m_observers.size (); i++)\n+      visit_for_sorting (sorted_observers, visit_states, i);\n+\n+    m_observers = std::move (sorted_observers);\n+  }\n+\n+  void attach (const func_type &f, const token *t, const char *name,\n+               const std::vector<const struct token *> &dependencies)\n+  {\n+\n+    observer_debug_printf (\"Attaching observable %s to observer %s\",\n+                           name, m_name);\n+\n+    m_observers.emplace_back (t, f, name, dependencies);\n+\n+    /* The observer has been inserted at the end of the vector, so it will be\n+       after any of its potential dependencies attached earlier.  If the\n+       observer has a token, it means that other observers can specify it as\n+       a dependency, so sorting is necessary to ensure those will be after the\n+       newly inserted observer afterwards.  */\n+    if (t != nullptr)\n+      sort_observers ();\n+  };\n };\n \n } /* namespace observers */"
    }
  ]
}