{
  "sha": "3163898ec86b30d022a7ebf5bdec286c23cebd45",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzE2Mzg5OGVjODZiMzBkMDIyYTdlYmY1YmRlYzI4NmMyM2NlYmQ0NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:39Z"
    },
    "message": "Convert p-exp.y to use operations\n\nThis converts the Pascal parser to generate operations rather than\nexp_elements.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* p-exp.y: Create operations.\n\t(pascal_language::parser): Update.",
    "tree": {
      "sha": "286e900462959476025f10cd9e1f1adf7703ccc5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/286e900462959476025f10cd9e1f1adf7703ccc5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3163898ec86b30d022a7ebf5bdec286c23cebd45",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3163898ec86b30d022a7ebf5bdec286c23cebd45",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3163898ec86b30d022a7ebf5bdec286c23cebd45",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3163898ec86b30d022a7ebf5bdec286c23cebd45/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a"
    }
  ],
  "stats": {
    "total": 272,
    "additions": 130,
    "deletions": 142
  },
  "files": [
    {
      "sha": "5852e58598993a2018b1e6d7c04f0e47e1acb81f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3163898ec86b30d022a7ebf5bdec286c23cebd45/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3163898ec86b30d022a7ebf5bdec286c23cebd45/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3163898ec86b30d022a7ebf5bdec286c23cebd45",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* p-exp.y: Create operations.\n+\t(pascal_language::parser): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* d-exp.y: Create operations."
    },
    {
      "sha": "fc9984c996a28720e9823a97093380c0f4bdf6fa",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 125,
      "deletions": 142,
      "changes": 267,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3163898ec86b30d022a7ebf5bdec286c23cebd45/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3163898ec86b30d022a7ebf5bdec286c23cebd45/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=3163898ec86b30d022a7ebf5bdec286c23cebd45",
      "patch": "@@ -55,6 +55,7 @@\n #include \"objfiles.h\" /* For have_full_symbols and have_partial_symbols.  */\n #include \"block.h\"\n #include \"completer.h\"\n+#include \"expop.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -78,6 +79,8 @@ static int yylex (void);\n static void yyerror (const char *);\n \n static char *uptok (const char *, int);\n+\n+using namespace expr;\n %}\n \n /* Although the yacc \"value\" of an expression is not used,\n@@ -203,44 +206,43 @@ normal_start\t:\n \t;\n \n type_exp:\ttype\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n+\t\t\t{\n+\t\t\t  pstate->push_new<type_operation> ($1);\n \t\t\t  current_type = $1; } ;\n \n /* Expressions, including the comma operator.  */\n exp1\t:\texp\n \t|\texp1 ',' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_COMMA); }\n+\t\t\t{ pstate->wrap2<comma_operation> (); }\n \t;\n \n /* Expressions, not including the comma operator.  */\n exp\t:\texp '^'   %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND);\n+\t\t\t{ pstate->wrap<unop_ind_operation> ();\n \t\t\t  if (current_type)\n \t\t\t    current_type = TYPE_TARGET_TYPE (current_type); }\n \t;\n \n exp\t:\t'@' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR);\n+\t\t\t{ pstate->wrap<unop_addr_operation> ();\n \t\t\t  if (current_type)\n \t\t\t    current_type = TYPE_POINTER_TYPE (current_type); }\n \t;\n \n exp\t:\t'-' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t{ pstate->wrap<unary_neg_operation> (); }\n \t;\n \n exp\t:\tNOT exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{ pstate->wrap<unary_logical_not_operation> (); }\n \t;\n \n exp\t:\tINCREMENT '(' exp ')'   %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREINCREMENT); }\n+\t\t\t{ pstate->wrap<preinc_operation> (); }\n \t;\n \n exp\t:\tDECREMENT  '(' exp ')'   %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREDECREMENT); }\n+\t\t\t{ pstate->wrap<predec_operation> (); }\n \t;\n \n \n@@ -249,9 +251,9 @@ field_exp\t:\texp '.'\t%prec UNARY\n \t;\n \n exp\t:\tfield_exp FIELDNAME\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), copy_name ($2));\n \t\t\t  search_field = 0;\n \t\t\t  if (current_type)\n \t\t\t    {\n@@ -267,9 +269,9 @@ exp\t:\tfield_exp FIELDNAME\n \n \n exp\t:\tfield_exp name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), copy_name ($2));\n \t\t\t  search_field = 0;\n \t\t\t  if (current_type)\n \t\t\t    {\n@@ -283,19 +285,21 @@ exp\t:\tfield_exp name\n \t\t\t}\n \t;\n exp\t:\tfield_exp  name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_ptr_operation (pstate->pop (),\n+\t\t\t\t\t\t\t  copy_name ($2));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n exp\t:\tfield_exp COMPLETE\n-\t\t\t{ struct stoken s;\n-\t\t\t  pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  s.ptr = \"\";\n-\t\t\t  s.length = 0;\n-\t\t\t  write_exp_string (pstate, s);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_ptr_operation (pstate->pop (), \"\");\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '['\n@@ -306,24 +310,16 @@ exp\t:\texp '['\n \t\t\t\t\t\t     NULL, NULL, &arrayname);\n \t\t\t  if (arrayfieldindex)\n \t\t\t    {\n-\t\t\t      struct stoken stringsval;\n-\t\t\t      char *buf;\n-\n-\t\t\t      buf = (char *) alloca (strlen (arrayname) + 1);\n-\t\t\t      stringsval.ptr = buf;\n-\t\t\t      stringsval.length = strlen (arrayname);\n-\t\t\t      strcpy (buf, arrayname);\n \t\t\t      current_type\n \t\t\t\t= (current_type\n \t\t\t\t   ->field (arrayfieldindex - 1).type ());\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t      write_exp_string (pstate, stringsval);\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n+\t\t\t      pstate->push_new<structop_operation>\n+\t\t\t\t(pstate->pop (), arrayname);\n \t\t\t    }\n \t\t\t  push_current_type ();  }\n \t\texp1 ']'\n \t\t\t{ pop_current_type ();\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT);\n+\t\t\t  pstate->wrap2<subscript_operation> ();\n \t\t\t  if (current_type)\n \t\t\t    current_type = TYPE_TARGET_TYPE (current_type); }\n \t;\n@@ -334,10 +330,11 @@ exp\t:\texp '('\n \t\t\t{ push_current_type ();\n \t\t\t  pstate->start_arglist (); }\n \t\targlist ')'\t%prec ARROW\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<funcall_operation>\n+\t\t\t    (pstate->pop (), std::move (args));\n \t\t\t  pop_current_type ();\n \t\t\t  if (current_type)\n  \t  \t\t    current_type = TYPE_TARGET_TYPE (current_type);\n@@ -358,11 +355,10 @@ exp\t:\ttype '(' exp ')' %prec UNARY\n \t\t\t      if ((current_type->code () == TYPE_CODE_PTR)\n \t\t\t\t  && (TYPE_TARGET_TYPE (current_type)->code () == TYPE_CODE_STRUCT)\n \t\t\t\t  && (($1)->code () == TYPE_CODE_STRUCT))\n-\t\t\t\twrite_exp_elt_opcode (pstate, UNOP_IND);\n+\t\t\t\tpstate->wrap<unop_ind_operation> ();\n \t\t\t    }\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST);\n+\t\t\t  pstate->push_new<unop_cast_operation>\n+\t\t\t    (pstate->pop (), $1);\n \t\t\t  current_type = $1; }\n \t;\n \n@@ -373,7 +369,7 @@ exp\t:\t'(' exp1 ')'\n /* Binary operators in order of decreasing precedence.  */\n \n exp\t:\texp '*' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ pstate->wrap2<mul_operation> (); }\n \t;\n \n exp\t:\texp '/' {\n@@ -385,146 +381,149 @@ exp\t:\texp '/' {\n \t\t\t  if (leftdiv_is_integer && current_type\n \t\t\t      && is_integral_type (current_type))\n \t\t\t    {\n-\t\t\t      write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t      write_exp_elt_type (pstate,\n-\t\t\t\t\t\t  parse_type (pstate)\n-\t\t\t\t\t\t  ->builtin_long_double);\n+\t\t\t      pstate->push_new<unop_cast_operation>\n+\t\t\t\t(pstate->pop (),\n+\t\t\t\t parse_type (pstate)->builtin_long_double);\n \t\t\t      current_type\n \t\t\t\t= parse_type (pstate)->builtin_long_double;\n-\t\t\t      write_exp_elt_opcode (pstate, UNOP_CAST);\n \t\t\t      leftdiv_is_integer = 0;\n \t\t\t    }\n \n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_DIV);\n+\t\t\t  pstate->wrap2<div_operation> ();\n \t\t\t}\n \t;\n \n exp\t:\texp DIV exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_INTDIV); }\n+\t\t\t{ pstate->wrap2<intdiv_operation> (); }\n \t;\n \n exp\t:\texp MOD exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t\t{ pstate->wrap2<rem_operation> (); }\n \t;\n \n exp\t:\texp '+' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ pstate->wrap2<add_operation> (); }\n \t;\n \n exp\t:\texp '-' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ pstate->wrap2<sub_operation> (); }\n \t;\n \n exp\t:\texp LSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LSH); }\n+\t\t\t{ pstate->wrap2<lsh_operation> (); }\n \t;\n \n exp\t:\texp RSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_RSH); }\n+\t\t\t{ pstate->wrap2<rsh_operation> (); }\n \t;\n \n exp\t:\texp '=' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<equal_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp NOTEQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<notequal_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp LEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<leq_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp GEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<geq_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp '<' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<less_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp '>' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR);\n+\t\t\t{\n+\t\t\t  pstate->wrap2<gtr_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n \t\t\t}\n \t;\n \n exp\t:\texp ANDAND exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ pstate->wrap2<bitwise_and_operation> (); }\n \t;\n \n exp\t:\texp XOR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ pstate->wrap2<bitwise_xor_operation> (); }\n \t;\n \n exp\t:\texp OR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ pstate->wrap2<bitwise_ior_operation> (); }\n \t;\n \n exp\t:\texp ASSIGN exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{ pstate->wrap2<assign_operation> (); }\n \t;\n \n exp\t:\tTRUEKEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n+\t\t\t{\n+\t\t\t  pstate->push_new<bool_operation> ($1);\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t}\n \t;\n \n exp\t:\tFALSEKEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n+\t\t\t{\n+\t\t\t  pstate->push_new<bool_operation> ($1);\n \t\t\t  current_type = parse_type (pstate)->builtin_bool;\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t}\n \t;\n \n exp\t:\tINT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    ($1.type, $1.val);\n \t\t\t  current_type = $1.type;\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST)($1.val));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t}\n \t;\n \n exp\t:\tNAME_OR_INT\n \t\t\t{ YYSTYPE val;\n \t\t\t  parse_number (pstate, $1.stoken.ptr,\n \t\t\t\t\t$1.stoken.length, 0, &val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, val.typed_val_int.type);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (val.typed_val_int.type,\n+\t\t\t     val.typed_val_int.val);\n \t\t\t  current_type = val.typed_val_int.type;\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST)\n-\t\t\t\t\t\t val.typed_val_int.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n \t\t\t}\n \t;\n \n \n exp\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  current_type = $1.type;\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation> ($1.type, data);\n+\t\t\t}\n \t;\n \n exp\t:\tvariable\n \t;\n \n exp\t:\tDOLLAR_VARIABLE\n \t\t\t{\n-\t\t\t  write_dollar_variable (pstate, $1);\n+\t\t\t  pstate->push_dollar ($1);\n \n \t\t\t  /* $ is the normal prefix for pascal\n \t\t\t     hexadecimal values but this conflicts\n@@ -549,18 +548,16 @@ exp\t:\tDOLLAR_VARIABLE\n  \t;\n \n exp\t:\tSIZEOF '(' type ')'\t%prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t    parse_type (pstate)->builtin_int);\n+\t\t\t{\n \t\t\t  current_type = parse_type (pstate)->builtin_int;\n \t\t\t  $3 = check_typedef ($3);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) TYPE_LENGTH ($3));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_type (pstate)->builtin_int,\n+\t\t\t     TYPE_LENGTH ($3)); }\n \t;\n \n exp\t:\tSIZEOF  '(' exp ')'      %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF);\n+\t\t\t{ pstate->wrap<unop_sizeof_operation> ();\n \t\t\t  current_type = parse_type (pstate)->builtin_int; }\n \n exp\t:\tSTRING\n@@ -571,36 +568,25 @@ exp\t:\tSTRING\n \t\t\t     string.  */\n \t\t\t  const char *sp = $1.ptr; int count = $1.length;\n \n-\t\t\t  while (count-- > 0)\n-\t\t\t    {\n-\t\t\t      write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t      write_exp_elt_type (pstate,\n-\t\t\t\t\t\t  parse_type (pstate)\n-\t\t\t\t\t\t  ->builtin_char);\n-\t\t\t      write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t     (LONGEST) (*sp++));\n-\t\t\t      write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t    }\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_type (pstate)\n-\t\t\t\t\t      ->builtin_char);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST)'\\0');\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ARRAY);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) ($1.length));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ARRAY); }\n+\t\t\t  std::vector<operation_up> args (count + 1);\n+\t\t\t  for (int i = 0; i < count; ++i)\n+\t\t\t    args[i] = (make_operation<long_const_operation>\n+\t\t\t\t       (parse_type (pstate)->builtin_char,\n+\t\t\t\t\t*sp++));\n+\t\t\t  args[count] = (make_operation<long_const_operation>\n+\t\t\t\t\t (parse_type (pstate)->builtin_char,\n+\t\t\t\t\t  '\\0'));\n+\t\t\t  pstate->push_new<array_operation>\n+\t\t\t    (0, $1.length, std::move (args));\n+\t\t\t}\n \t;\n \n /* Object pascal  */\n exp\t:\tTHIS\n \t\t\t{\n \t\t\t  struct value * this_val;\n \t\t\t  struct type * this_type;\n-\t\t\t  write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_THIS);\n+\t\t\t  pstate->push_new<op_this_operation> ();\n \t\t\t  /* We need type of this.  */\n \t\t\t  this_val\n \t\t\t    = value_of_this_silent (pstate->language ());\n@@ -613,7 +599,7 @@ exp\t:\tTHIS\n \t\t\t      if (this_type->code () == TYPE_CODE_PTR)\n \t\t\t\t{\n \t\t\t\t  this_type = TYPE_TARGET_TYPE (this_type);\n-\t\t\t\t  write_exp_elt_opcode (pstate, UNOP_IND);\n+\t\t\t\t  pstate->wrap<unop_ind_operation> ();\n \t\t\t\t}\n \t\t\t    }\n \n@@ -665,10 +651,9 @@ variable:\tblock COLONCOLON name\n \t\t\t    error (_(\"No symbol \\\"%s\\\" in specified context.\"),\n \t\t\t\t   copy.c_str ());\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t  write_exp_elt_block (pstate, sym.block);\n-\t\t\t  write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE); }\n+\t\t\t  pstate->push_new<var_value_operation>\n+\t\t\t    (sym.symbol, sym.block);\n+\t\t\t}\n \t;\n \n qualified_name:\ttypebase COLONCOLON name\n@@ -680,10 +665,8 @@ qualified_name:\ttypebase COLONCOLON name\n \t\t\t    error (_(\"`%s' is not defined as an aggregate type.\"),\n \t\t\t\t   type->name ());\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n-\t\t\t  write_exp_elt_type (pstate, type);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n+\t\t\t  pstate->push_new<scope_operation>\n+\t\t\t    (type, copy_name ($3));\n \t\t\t}\n \t;\n \n@@ -695,8 +678,7 @@ variable:\tqualified_name\n \t\t\t  struct block_symbol sym\n \t\t\t    = lookup_symbol (name.c_str (), nullptr,\n \t\t\t\t\t     VAR_DOMAIN, nullptr);\n-\t\t\t  write_exp_symbol_reference (pstate, name.c_str (),\n-\t\t\t\t\t\t      sym);\n+\t\t\t  pstate->push_symbol (name.c_str (), sym);\n \t\t\t}\n \t;\n \n@@ -708,10 +690,8 @@ variable:\tname_not_typename\n \t\t\t      if (symbol_read_needs_frame (sym.symbol))\n \t\t\t\tpstate->block_tracker->update (sym);\n \n-\t\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t      write_exp_elt_block (pstate, sym.block);\n-\t\t\t      write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n+\t\t\t      pstate->push_new<var_value_operation>\n+\t\t\t\t(sym.symbol, sym.block);\n \t\t\t      current_type = sym.symbol->type; }\n \t\t\t  else if ($1.is_a_field_of_this)\n \t\t\t    {\n@@ -721,11 +701,10 @@ variable:\tname_not_typename\n \t\t\t\t not inadvertently convert from a method call\n \t\t\t\t to data ref.  */\n \t\t\t      pstate->block_tracker->update (sym);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t      write_exp_string (pstate, $1.stoken);\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n+\t\t\t      operation_up thisop\n+\t\t\t\t= make_operation<op_this_operation> ();\n+\t\t\t      pstate->push_new<structop_operation>\n+\t\t\t\t(std::move (thisop), copy_name ($1.stoken));\n \t\t\t      /* We need type of this.  */\n \t\t\t      this_val\n \t\t\t\t= value_of_this_silent (pstate->language ());\n@@ -748,7 +727,8 @@ variable:\tname_not_typename\n \t\t\t      msymbol =\n \t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n-\t\t\t\twrite_exp_msymbol (pstate, msymbol);\n+\t\t\t\tpstate->push_new<var_msym_value_operation>\n+\t\t\t\t  (msymbol.minsym, msymbol.objfile);\n \t\t\t      else if (!have_full_symbols ()\n \t\t\t\t       && !have_partial_symbols ())\n \t\t\t\terror (_(\"No symbol table is loaded.  \"\n@@ -1716,7 +1696,10 @@ pascal_language::parser (struct parser_state *par_state) const\n   pstate = par_state;\n   paren_depth = 0;\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n static void"
    }
  ]
}