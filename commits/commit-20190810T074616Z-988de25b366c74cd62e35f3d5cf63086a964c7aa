{
  "sha": "988de25b366c74cd62e35f3d5cf63086a964c7aa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTg4ZGUyNWIzNjZjNzRjZDYyZTM1ZjNkNWNmNjMwODZhOTY0YzdhYQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-10T02:58:31Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-10T07:46:16Z"
    },
    "message": "stat_alloc casts\n\nCasts from a void* just clutter the source.\n\n\t* ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop, exp_trinop),\n\t(exp_unop, exp_nameop, exp_assop, exp_assert): Remove casts of\n\tstat_alloc return value.\n\t* ldlang.c (new_statement, new_afile, sort_def_symbol),\n\t(lang_memory_region_lookup, lang_memory_region_alias),\n\t(ldlang_add_undef, ldlang_add_require_defined, insert_pad),\n\t(lang_add_gc_name, lang_new_phdr): Likewise.\n\t* lexsup.c (set_segment_start): Likewise.",
    "tree": {
      "sha": "a1ec5980fb59bb8b0ed849284da047a7a28ba9f0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a1ec5980fb59bb8b0ed849284da047a7a28ba9f0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/988de25b366c74cd62e35f3d5cf63086a964c7aa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/988de25b366c74cd62e35f3d5cf63086a964c7aa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/988de25b366c74cd62e35f3d5cf63086a964c7aa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/988de25b366c74cd62e35f3d5cf63086a964c7aa/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "36983a93bb338b7cdd6f7d6f9f91dc9ce9815b4e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/36983a93bb338b7cdd6f7d6f9f91dc9ce9815b4e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/36983a93bb338b7cdd6f7d6f9f91dc9ce9815b4e"
    }
  ],
  "stats": {
    "total": 64,
    "additions": 36,
    "deletions": 28
  },
  "files": [
    {
      "sha": "d4eb3fb44a4a2acdf3e21537a0da3aff908b3cb4",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=988de25b366c74cd62e35f3d5cf63086a964c7aa",
      "patch": "@@ -1,3 +1,14 @@\n+2019-08-10  Alan Modra  <amodra@gmail.com>\n+\n+\t* ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop, exp_trinop),\n+\t(exp_unop, exp_nameop, exp_assop, exp_assert): Remove casts of\n+\tstat_alloc return value.\n+\t* ldlang.c (new_statement, new_afile, sort_def_symbol),\n+\t(lang_memory_region_lookup, lang_memory_region_alias),\n+\t(ldlang_add_undef, ldlang_add_require_defined, insert_pad),\n+\t(lang_add_gc_name, lang_new_phdr): Likewise.\n+\t* lexsup.c (set_segment_start): Likewise.\n+\n 2019-08-10  Alan Modra  <amodra@gmail.com>\n \n \t* ldlang.h (lang_input_statement_type): Make next"
    },
    {
      "sha": "d7d253eee12b50df8ab201d7a69316fca922ee29",
      "filename": "ld/ldexp.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ldexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ldexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.c?ref=988de25b366c74cd62e35f3d5cf63086a964c7aa",
      "patch": "@@ -198,7 +198,7 @@ new_abs (bfd_vma value)\n etree_type *\n exp_intop (bfd_vma value)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->value));\n+  etree_type *new_e = stat_alloc (sizeof (new_e->value));\n   new_e->type.node_code = INT;\n   new_e->type.filename = ldlex_filename ();\n   new_e->type.lineno = lineno;\n@@ -211,7 +211,7 @@ exp_intop (bfd_vma value)\n etree_type *\n exp_bigintop (bfd_vma value, char *str)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->value));\n+  etree_type *new_e = stat_alloc (sizeof (new_e->value));\n   new_e->type.node_code = INT;\n   new_e->type.filename = ldlex_filename ();\n   new_e->type.lineno = lineno;\n@@ -226,7 +226,7 @@ exp_bigintop (bfd_vma value, char *str)\n etree_type *\n exp_relop (asection *section, bfd_vma value)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->rel));\n+  etree_type *new_e = stat_alloc (sizeof (new_e->rel));\n   new_e->type.node_code = REL;\n   new_e->type.filename = ldlex_filename ();\n   new_e->type.lineno = lineno;\n@@ -1277,8 +1277,8 @@ exp_value_fold (etree_type *tree)\n etree_type *\n exp_binop (int code, etree_type *lhs, etree_type *rhs)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (MAX (sizeof (new_e->binary),\n-\t\t\t\t\t\t      sizeof (new_e->value)));\n+  etree_type *new_e = stat_alloc (MAX (sizeof (new_e->binary),\n+\t\t\t\t       sizeof (new_e->value)));\n   new_e->type.node_code = code;\n   new_e->type.filename = lhs->type.filename;\n   new_e->type.lineno = lhs->type.lineno;\n@@ -1297,8 +1297,8 @@ exp_binop (int code, etree_type *lhs, etree_type *rhs)\n etree_type *\n exp_trinop (int code, etree_type *cond, etree_type *lhs, etree_type *rhs)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (MAX (sizeof (new_e->trinary),\n-\t\t\t\t\t\t      sizeof (new_e->value)));\n+  etree_type *new_e = stat_alloc (MAX (sizeof (new_e->trinary),\n+\t\t\t\t       sizeof (new_e->value)));\n   new_e->type.node_code = code;\n   new_e->type.filename = cond->type.filename;\n   new_e->type.lineno = cond->type.lineno;\n@@ -1316,8 +1316,8 @@ exp_trinop (int code, etree_type *cond, etree_type *lhs, etree_type *rhs)\n etree_type *\n exp_unop (int code, etree_type *child)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (MAX (sizeof (new_e->unary),\n-\t\t\t\t\t\t      sizeof (new_e->value)));\n+  etree_type *new_e = stat_alloc (MAX (sizeof (new_e->unary),\n+\t\t\t\t       sizeof (new_e->value)));\n   new_e->unary.type.node_code = code;\n   new_e->unary.type.filename = child->type.filename;\n   new_e->unary.type.lineno = child->type.lineno;\n@@ -1335,7 +1335,7 @@ exp_unop (int code, etree_type *child)\n etree_type *\n exp_nameop (int code, const char *name)\n {\n-  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->name));\n+  etree_type *new_e = stat_alloc (sizeof (new_e->name));\n \n   new_e->name.type.node_code = code;\n   new_e->name.type.filename = ldlex_filename ();\n@@ -1354,7 +1354,7 @@ exp_assop (const char *dst,\n {\n   etree_type *n;\n \n-  n = (etree_type *) stat_alloc (sizeof (n->assign));\n+  n = stat_alloc (sizeof (n->assign));\n   n->assign.type.node_code = '=';\n   n->assign.type.filename = src->type.filename;\n   n->assign.type.lineno = src->type.lineno;\n@@ -1396,7 +1396,7 @@ exp_assert (etree_type *exp, const char *message)\n {\n   etree_type *n;\n \n-  n = (etree_type *) stat_alloc (sizeof (n->assert_s));\n+  n = stat_alloc (sizeof (n->assert_s));\n   n->assert_s.type.node_code = '!';\n   n->assert_s.type.filename = exp->type.filename;\n   n->assert_s.type.lineno = exp->type.lineno;"
    },
    {
      "sha": "303aa674353db3dc368cc8caad52c003f3576b3b",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 12,
      "deletions": 15,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=988de25b366c74cd62e35f3d5cf63086a964c7aa",
      "patch": "@@ -1061,7 +1061,7 @@ new_statement (enum statement_enum type,\n {\n   lang_statement_union_type *new_stmt;\n \n-  new_stmt = (lang_statement_union_type *) stat_alloc (size);\n+  new_stmt = stat_alloc (size);\n   new_stmt->header.type = type;\n   new_stmt->header.next = NULL;\n   lang_statement_append (list, new_stmt, &new_stmt->header.next);\n@@ -1088,11 +1088,10 @@ new_afile (const char *name,\n   lang_has_input_file = TRUE;\n \n   if (add_to_list)\n-    p = (lang_input_statement_type *) new_stat (lang_input_statement, stat_ptr);\n+    p = new_stat (lang_input_statement, stat_ptr);\n   else\n     {\n-      p = (lang_input_statement_type *)\n-\t  stat_alloc (sizeof (lang_input_statement_type));\n+      p = stat_alloc (sizeof (lang_input_statement_type));\n       p->header.type = lang_input_statement_enum;\n       p->header.next = NULL;\n     }\n@@ -1345,8 +1344,7 @@ lang_memory_region_lookup (const char *const name, bfd_boolean create)\n     einfo (_(\"%P:%pS: warning: memory region `%s' not declared\\n\"),\n \t   NULL, name);\n \n-  new_region = (lang_memory_region_type *)\n-      stat_alloc (sizeof (lang_memory_region_type));\n+  new_region = stat_alloc (sizeof (lang_memory_region_type));\n \n   new_region->name_list.name = xstrdup (name);\n   new_region->name_list.next = NULL;\n@@ -1402,7 +1400,7 @@ lang_memory_region_alias (const char *alias, const char *region_name)\n \t   NULL, region_name, alias);\n \n   /* Add alias to region name list.  */\n-  n = (lang_memory_region_name *) stat_alloc (sizeof (lang_memory_region_name));\n+  n = stat_alloc (sizeof (lang_memory_region_name));\n   n->name = xstrdup (alias);\n   n->next = region->name_list.next;\n   region->name_list.next = n;\n@@ -2341,7 +2339,7 @@ sort_def_symbol (struct bfd_link_hash_entry *hash_entry,\n \t    get_userdata (hash_entry->u.def.section));\n       if (!ud)\n \t{\n-\t  ud = (input_section_userdata_type *) stat_alloc (sizeof (*ud));\n+\t  ud = stat_alloc (sizeof (*ud));\n \t  get_userdata (hash_entry->u.def.section) = ud;\n \t  ud->map_symbol_def_tail = &ud->map_symbol_def_head;\n \t  ud->map_symbol_def_count = 0;\n@@ -3606,7 +3604,7 @@ ldlang_add_undef (const char *const name, bfd_boolean cmdline)\n   ldlang_undef_chain_list_type *new_undef;\n \n   undef_from_cmdline = undef_from_cmdline || cmdline;\n-  new_undef = (ldlang_undef_chain_list_type *) stat_alloc (sizeof (*new_undef));\n+  new_undef = stat_alloc (sizeof (*new_undef));\n   new_undef->next = ldlang_undef_chain_list_head;\n   ldlang_undef_chain_list_head = new_undef;\n \n@@ -3672,7 +3670,7 @@ ldlang_add_require_defined (const char *const name)\n   struct require_defined_symbol *ptr;\n \n   ldlang_add_undef (name, TRUE);\n-  ptr = (struct require_defined_symbol *) stat_alloc (sizeof (*ptr));\n+  ptr = stat_alloc (sizeof (*ptr));\n   ptr->next = require_defined_symbol_list;\n   ptr->name = strdup (name);\n   require_defined_symbol_list = ptr;\n@@ -3706,7 +3704,7 @@ check_input_sections\n   (lang_statement_union_type *s,\n    lang_output_section_statement_type *output_section_statement)\n {\n-  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)\n+  for (; s != NULL; s = s->header.next)\n     {\n       switch (s->header.type)\n \t{\n@@ -4894,8 +4892,7 @@ insert_pad (lang_statement_union_type **ptr,\n   else\n     {\n       /* Make a new padding statement, linked into existing chain.  */\n-      pad = (lang_statement_union_type *)\n-\t  stat_alloc (sizeof (lang_padding_statement_type));\n+      pad = stat_alloc (sizeof (lang_padding_statement_type));\n       pad->header.next = *ptr;\n       *ptr = pad;\n       pad->header.type = lang_padding_statement_enum;\n@@ -7373,7 +7370,7 @@ lang_add_gc_name (const char *name)\n   if (name == NULL)\n     return;\n \n-  sym = (struct bfd_sym_chain *) stat_alloc (sizeof (*sym));\n+  sym = stat_alloc (sizeof (*sym));\n \n   sym->next = link_info.gc_sym_list;\n   sym->name = name;\n@@ -8030,7 +8027,7 @@ lang_new_phdr (const char *name,\n   struct lang_phdr *n, **pp;\n   bfd_boolean hdrs;\n \n-  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));\n+  n = stat_alloc (sizeof (struct lang_phdr));\n   n->next = NULL;\n   n->name = name;\n   n->type = exp_get_vma (type, 0, \"program header type\");"
    },
    {
      "sha": "1c15ac29c0c825fcebe513f49e81ce733207519d",
      "filename": "ld/lexsup.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/lexsup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/988de25b366c74cd62e35f3d5cf63086a964c7aa/ld/lexsup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/lexsup.c?ref=988de25b366c74cd62e35f3d5cf63086a964c7aa",
      "patch": "@@ -1734,7 +1734,7 @@ set_segment_start (const char *section, char *valstr)\n       }\n   /* There was no existing value so we must create a new segment\n      entry.  */\n-  seg = (segment_type *) stat_alloc (sizeof (*seg));\n+  seg = stat_alloc (sizeof (*seg));\n   seg->name = name;\n   seg->value = val;\n   seg->used = FALSE;"
    }
  ]
}