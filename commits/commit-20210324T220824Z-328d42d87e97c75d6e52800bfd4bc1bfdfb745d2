{
  "sha": "328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzI4ZDQyZDg3ZTk3Yzc1ZDZlNTI4MDBiZmQ0YmMxYmZkZmI3NDVkMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-03-24T22:08:12Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-03-24T22:08:24Z"
    },
    "message": "gdb: remove current_top_target function\n\nThe current_top_target function is a hidden dependency on the current\ninferior.  Since I'd like to slowly move towards reducing our dependency\non the global current state, remove this function and make callers use\n\n  current_inferior ()->top_target ()\n\nThere is no expected change in behavior, but this one step towards\nmaking those callers use the inferior from their context, rather than\nrefer to the global current inferior.\n\ngdb/ChangeLog:\n\n\t* target.h (current_top_target): Remove, make callers use the\n\tcurrent inferior instead.\n\t* target.c (current_top_target): Remove.\n\nChange-Id: Iccd457036f84466cdaa3865aa3f9339a24ea001d",
    "tree": {
      "sha": "4dee500fe0bf6acd7dcb8153aabebaa27936c564",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4dee500fe0bf6acd7dcb8153aabebaa27936c564"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d777bf0df22f1048fd24999ae563e30abcbcfbe7"
    }
  ],
  "stats": {
    "total": 783,
    "additions": 454,
    "deletions": 329
  },
  "files": [
    {
      "sha": "a548c58e8f721d21eae65a8647bf3f60c8680cf7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1,3 +1,9 @@\n+2021-03-24  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* target.h (current_top_target): Remove, make callers use the\n+\tcurrent inferior instead.\n+\t* target.c (current_top_target): Remove.\n+\n 2021-03-24  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* target.h (target_shortname): Change to function declaration."
    },
    {
      "sha": "6507df192e56dfbd83fdf8136c45ba9eee005a5c",
      "filename": "gdb/auxv.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/auxv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/auxv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/auxv.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -320,7 +320,8 @@ target_auxv_parse (gdb_byte **readptr,\n   if (gdbarch_auxv_parse_p (gdbarch))\n     return gdbarch_auxv_parse (gdbarch, readptr, endptr, typep, valp);\n \n-  return current_top_target ()->auxv_parse (readptr, endptr, typep, valp);\n+  return current_inferior ()->top_target ()->auxv_parse (readptr, endptr,\n+\t\t\t\t\t\t\t typep, valp);\n }\n \n \n@@ -580,7 +581,8 @@ info_auxv_command (const char *cmd, int from_tty)\n     error (_(\"The program has no auxiliary information now.\"));\n   else\n     {\n-      int ents = fprint_target_auxv (gdb_stdout, current_top_target ());\n+      int ents = fprint_target_auxv (gdb_stdout,\n+\t\t\t\t     current_inferior ()->top_target ());\n \n       if (ents < 0)\n \terror (_(\"No auxiliary vector found, or failed reading it.\"));"
    },
    {
      "sha": "018b18f3dfd31bf289a15d0e8667dfee75d06749",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1561,7 +1561,8 @@ avr_io_reg_read_command (const char *args, int from_tty)\n \n   /* Find out how many io registers the target has.  */\n   gdb::optional<gdb::byte_vector> buf\n-    = target_read_alloc (current_top_target (), TARGET_OBJECT_AVR, \"avr.io_reg\");\n+    = target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t TARGET_OBJECT_AVR, \"avr.io_reg\");\n \n   if (!buf)\n     {\n@@ -1595,7 +1596,8 @@ avr_io_reg_read_command (const char *args, int from_tty)\n \tj = nreg - i;           /* last block is less than 8 registers */\n \n       snprintf (query, sizeof (query) - 1, \"avr.io_reg:%x,%x\", i, j);\n-      buf = target_read_alloc (current_top_target (), TARGET_OBJECT_AVR, query);\n+      buf = target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t       TARGET_OBJECT_AVR, query);\n \n       if (!buf)\n \t{"
    },
    {
      "sha": "16cf7977b62a41ea04858c4b7488a1a6986f0aaf",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -3598,8 +3598,8 @@ create_exception_master_breakpoint_hook (objfile *objfile)\n     }\n \n   addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->exception_msym);\n-  addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,\n-\t\t\t\t\t     current_top_target ());\n+  addr = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, addr, current_inferior ()->top_target ());\n   b = create_internal_breakpoint (gdbarch, addr, bp_exception_master,\n \t\t\t\t  &internal_breakpoint_ops);\n   initialize_explicit_location (&explicit_loc);\n@@ -4869,7 +4869,7 @@ watchpoints_triggered (struct target_waitstatus *ws)\n       return 0;\n     }\n \n-  if (!target_stopped_data_address (current_top_target (), &addr))\n+  if (!target_stopped_data_address (current_inferior ()->top_target (), &addr))\n     {\n       /* We were stopped by a watchpoint, but we don't know where.\n \t Mark all watchpoints as unknown.  */\n@@ -4909,9 +4909,9 @@ watchpoints_triggered (struct target_waitstatus *ws)\n \t\t  }\n \t      }\n \t    /* Exact match not required.  Within range is sufficient.  */\n-\t    else if (target_watchpoint_addr_within_range (current_top_target (),\n-\t\t\t\t\t\t\t addr, loc->address,\n-\t\t\t\t\t\t\t loc->length))\n+\t    else if (target_watchpoint_addr_within_range\n+\t\t       (current_inferior ()->top_target (), addr, loc->address,\n+\t\t\tloc->length))\n \t      {\n \t\tw->watchpoint_triggered = watch_triggered_yes;\n \t\tbreak;"
    },
    {
      "sha": "30960c129fdad77be0ccdaea02c2d7ad25cec838",
      "filename": "gdb/corefile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corefile.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -218,8 +218,8 @@ read_memory_object (enum target_object object, CORE_ADDR memaddr,\n       enum target_xfer_status status;\n       ULONGEST xfered_len;\n \n-      status = target_xfer_partial (current_top_target (), object, NULL,\n-\t\t\t\t    myaddr + xfered, NULL,\n+      status = target_xfer_partial (current_inferior ()->top_target (), object,\n+\t\t\t\t    NULL, myaddr + xfered, NULL,\n \t\t\t\t    memaddr + xfered, len - xfered,\n \t\t\t\t    &xfered_len);\n "
    },
    {
      "sha": "49bbbec663e8a12d3c612566786c4d89fb6d9d17",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -863,8 +863,8 @@ elf_gnu_ifunc_resolve_by_got (const char *name, CORE_ADDR *addr_p)\n       if (target_read_memory (pointer_address, buf, ptr_size) != 0)\n \tcontinue;\n       addr = extract_typed_address (buf, ptr_type);\n-      addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,\n-\t\t\t\t\t\t current_top_target ());\n+      addr = gdbarch_convert_from_func_ptr_addr\n+\t(gdbarch, addr, current_inferior ()->top_target ());\n       addr = gdbarch_addr_bits_remove (gdbarch, addr);\n \n       if (elf_gnu_ifunc_record_cache (name, addr))\n@@ -931,12 +931,13 @@ elf_gnu_ifunc_resolve_addr (struct gdbarch *gdbarch, CORE_ADDR pc)\n      parameter.  FUNCTION is the function entry address.  ADDRESS may be a\n      function descriptor.  */\n \n-  target_auxv_search (current_top_target (), AT_HWCAP, &hwcap);\n+  target_auxv_search (current_inferior ()->top_target (), AT_HWCAP, &hwcap);\n   hwcap_val = value_from_longest (builtin_type (gdbarch)\n \t\t\t\t  ->builtin_unsigned_long, hwcap);\n   address_val = call_function_by_hand (function, NULL, hwcap_val);\n   address = value_as_address (address_val);\n-  address = gdbarch_convert_from_func_ptr_addr (gdbarch, address, current_top_target ());\n+  address = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, address, current_inferior ()->top_target ());\n   address = gdbarch_addr_bits_remove (gdbarch, address);\n \n   if (name_at_pc)\n@@ -1042,9 +1043,8 @@ elf_gnu_ifunc_resolver_return_stop (struct breakpoint *b)\n   gdbarch_return_value (gdbarch, func_func, value_type, regcache,\n \t\t\tvalue_contents_raw (value), NULL);\n   resolved_address = value_as_address (value);\n-  resolved_pc = gdbarch_convert_from_func_ptr_addr (gdbarch,\n-\t\t\t\t\t\t    resolved_address,\n-\t\t\t\t\t\t    current_top_target ());\n+  resolved_pc = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, resolved_address, current_inferior ()->top_target ());\n   resolved_pc = gdbarch_addr_bits_remove (gdbarch, resolved_pc);\n \n   gdb_assert (current_program_space == b->pspace || b->pspace == NULL);"
    },
    {
      "sha": "363ab4fa4af962cc409b474602785fa52a171209",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -42,6 +42,7 @@\n #include <ctype.h>\n #include \"expop.h\"\n #include \"c-exp.h\"\n+#include \"inferior.h\"\n \n \f\n /* Parse the string EXP as a C expression, evaluate it,\n@@ -1964,8 +1965,8 @@ eval_op_objc_msgcall (struct type *expect_type, struct expression *exp,\n \n       /* The address might point to a function descriptor;\n \t resolve it to the actual code address instead.  */\n-      addr = gdbarch_convert_from_func_ptr_addr (exp->gdbarch, addr,\n-\t\t\t\t\t\t current_top_target ());\n+      addr = gdbarch_convert_from_func_ptr_addr\n+\t(exp->gdbarch, addr, current_inferior ()->top_target ());\n \n       /* Is it a high_level symbol?  */\n       sym = find_pc_function (addr);"
    },
    {
      "sha": "ff0db82a69b9a1222093cce543ad2d8f2e0f5027",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -775,7 +775,7 @@ section_table_read_available_memory (gdb_byte *readbuf, ULONGEST offset,\n \t\t\t\t     ULONGEST len, ULONGEST *xfered_len)\n {\n   const target_section_table *table\n-    = target_get_section_table (current_top_target ());\n+    = target_get_section_table (current_inferior ()->top_target ());\n   std::vector<mem_range> available_memory\n     = section_table_available_memory (offset, len, *table);\n "
    },
    {
      "sha": "6cab31dde82a66f7f38bd0611bc95e943f0b1f69",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -593,7 +593,7 @@ static gdb::optional<gdb::byte_vector>\n fbsd_make_note_desc (enum target_object object, uint32_t structsize)\n {\n   gdb::optional<gdb::byte_vector> buf =\n-    target_read_alloc (current_top_target (), object, NULL);\n+    target_read_alloc (current_inferior ()->top_target (), object, NULL);\n   if (!buf || buf->empty ())\n     return {};\n "
    },
    {
      "sha": "dc9fdd41646fbb52463ec8bbc73d670011ed6448",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -2478,9 +2478,8 @@ inside_main_func (frame_info *this_frame)\n \n   /* Convert any function descriptor addresses into the actual function\n      code address.  */\n-  sym_addr\n-    = gdbarch_convert_from_func_ptr_addr (get_frame_arch (this_frame),\n-\t\t\t\t\t  sym_addr, current_top_target ());\n+  sym_addr = gdbarch_convert_from_func_ptr_addr\n+    (get_frame_arch (this_frame), sym_addr, current_inferior ()->top_target ());\n \n   return sym_addr == get_frame_func (this_frame);\n }"
    },
    {
      "sha": "45e57c210cbfafea723a27e7fe3b46db6733f460",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -31,6 +31,7 @@\n #include <algorithm>\n #include \"cli/cli-style.h\"\n #include \"dwarf2/loc.h\"\n+#include \"inferior.h\"\n \n static struct cp_abi_ops gnu_v3_abi_ops;\n \n@@ -1243,8 +1244,8 @@ gnuv3_skip_trampoline (struct frame_info *frame, CORE_ADDR stop_pc)\n      (powerpc 64 for example).  Make sure to retrieve the address\n      of the real function from the function descriptor before passing on\n      the address to other layers of GDB.  */\n-  func_addr = gdbarch_convert_from_func_ptr_addr (gdbarch, method_stop_pc,\n-\t\t\t\t\t\t  current_top_target ());\n+  func_addr = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, method_stop_pc, current_inferior ()->top_target ());\n   if (func_addr != 0)\n     method_stop_pc = func_addr;\n "
    },
    {
      "sha": "1c4fc4cca47ad7270ae7d3ff7c6c3d5400187f49",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -2653,8 +2653,8 @@ getunwind_table ()\n      we should find a way to override the corefile layer's\n      xfer_partial method.  */\n \n-  return target_read_alloc (current_top_target (), TARGET_OBJECT_UNWIND_TABLE,\n-\t\t\t    NULL);\n+  return target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_UNWIND_TABLE, NULL);\n }\n \n /* Get the kernel unwind table.  */\t\t\t\t "
    },
    {
      "sha": "cc8e191427485a93fb4fdc579f4e733fd8b3e922",
      "filename": "gdb/ia64-vms-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ia64-vms-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ia64-vms-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-vms-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -41,7 +41,8 @@ ia64_vms_find_proc_info_x (unw_addr_space_t as, unw_word_t ip,\n   CORE_ADDR table_addr;\n   unsigned int info_len;\n \n-  res = target_read (current_top_target (), TARGET_OBJECT_OPENVMS_UIB,\n+  res = target_read (current_inferior ()->top_target (),\n+\t\t     TARGET_OBJECT_OPENVMS_UIB,\n \t\t     annex + 2, buf, 0, sizeof (buf));\n \n   if (res != sizeof (buf))"
    },
    {
      "sha": "ca3347fbb9dec1852856c03b6f3dca4e5638112e",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -269,8 +269,8 @@ find_function_addr (struct value *function,\n       ftype = check_typedef (TYPE_TARGET_TYPE (ftype));\n       if (ftype->code () == TYPE_CODE_FUNC\n \t  || ftype->code () == TYPE_CODE_METHOD)\n-\tfunaddr = gdbarch_convert_from_func_ptr_addr (gdbarch, funaddr,\n-\t\t\t\t\t\t      current_top_target ());\n+\tfunaddr = gdbarch_convert_from_func_ptr_addr\n+\t  (gdbarch, funaddr, current_inferior ()->top_target());\n     }\n   if (ftype->code () == TYPE_CODE_FUNC\n       || ftype->code () == TYPE_CODE_METHOD)\n@@ -321,9 +321,8 @@ find_function_addr (struct value *function,\n \n \t      funaddr = value_as_address (value_addr (function));\n \t      nfunaddr = funaddr;\n-\t      funaddr\n-\t\t= gdbarch_convert_from_func_ptr_addr (gdbarch, funaddr,\n-\t\t\t\t\t\t      current_top_target ());\n+\t      funaddr = gdbarch_convert_from_func_ptr_addr\n+\t\t(gdbarch, funaddr, current_inferior ()->top_target ());\n \t      if (funaddr != nfunaddr)\n \t\tfound_descriptor = 1;\n \t    }"
    },
    {
      "sha": "a6e9572fc7fd95969fb28611ac1882ae7a0a86fd",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -759,7 +759,7 @@ continue_command (const char *args, int from_tty)\n       ensure_not_running ();\n     }\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   if (from_tty)\n     printf_filtered (_(\"Continuing.\\n\"));\n@@ -877,7 +877,7 @@ step_1 (int skip_subroutines, int single_inst, const char *count_string)\n     = strip_bg_char (count_string, &async_exec);\n   count_string = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   count = count_string ? parse_and_eval_long (count_string) : 1;\n \n@@ -1075,7 +1075,7 @@ jump_command (const char *arg, int from_tty)\n   gdb::unique_xmalloc_ptr<char> stripped = strip_bg_char (arg, &async_exec);\n   arg = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   if (!arg)\n     error_no_arg (_(\"starting address\"));\n@@ -1155,7 +1155,7 @@ signal_command (const char *signum_exp, int from_tty)\n     = strip_bg_char (signum_exp, &async_exec);\n   signum_exp = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   if (!signum_exp)\n     error_no_arg (_(\"signal number\"));\n@@ -1400,7 +1400,7 @@ until_command (const char *arg, int from_tty)\n   gdb::unique_xmalloc_ptr<char> stripped = strip_bg_char (arg, &async_exec);\n   arg = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   if (arg)\n     until_break_command (arg, from_tty, 0);\n@@ -1425,7 +1425,7 @@ advance_command (const char *arg, int from_tty)\n   gdb::unique_xmalloc_ptr<char> stripped = strip_bg_char (arg, &async_exec);\n   arg = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   until_break_command (arg, from_tty, 1);\n }\n@@ -1772,7 +1772,7 @@ finish_command (const char *arg, int from_tty)\n   gdb::unique_xmalloc_ptr<char> stripped = strip_bg_char (arg, &async_exec);\n   arg = stripped.get ();\n \n-  prepare_execution_command (current_top_target (), async_exec);\n+  prepare_execution_command (current_inferior ()->top_target (), async_exec);\n \n   if (arg)\n     error (_(\"The \\\"finish\\\" command does not take any arguments.\"));"
    },
    {
      "sha": "9188f72e35d2a10f7c094fbdb1fac7549d018362",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -507,7 +507,7 @@ print_inferior (struct ui_out *uiout, const char *requested_inferiors)\n \n       uiout->field_signed (\"number\", inf->num);\n \n-      /* Because target_pid_to_str uses current_top_target,\n+      /* Because target_pid_to_str uses the current inferior,\n \t switch the inferior.  */\n       switch_to_inferior_no_thread (inf);\n "
    },
    {
      "sha": "20035a0f5e8567741ff87caacff7f54492b5ebdd",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 10,
      "deletions": 6,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1777,7 +1777,7 @@ displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n   /* Fixup may need to read memory/registers.  Switch to the thread\n      that we're fixing up.  Also, target_stopped_by_watchpoint checks\n      the current thread, and displaced_step_restore performs ptid-dependent\n-     memory accesses using current_inferior() and current_top_target().  */\n+     memory accesses using current_inferior().  */\n   switch_to_thread (event_thread);\n \n   displaced_step_reset_cleanup cleanup (displaced);\n@@ -5813,7 +5813,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n \t  infrun_debug_printf (\"stopped by watchpoint\");\n \n-\t  if (target_stopped_data_address (current_top_target (), &addr))\n+\t  if (target_stopped_data_address (current_inferior ()->top_target (),\n+\t\t\t\t\t   &addr))\n \t    infrun_debug_printf (\"stopped data address=%s\",\n \t\t\t\t paddress (reg_gdbarch, addr));\n \t  else\n@@ -8835,7 +8836,8 @@ siginfo_value_read (struct value *v)\n   validate_registers_access ();\n \n   transferred =\n-    target_read (current_top_target (), TARGET_OBJECT_SIGNAL_INFO,\n+    target_read (current_inferior ()->top_target (),\n+\t\t TARGET_OBJECT_SIGNAL_INFO,\n \t\t NULL,\n \t\t value_contents_all_raw (v),\n \t\t value_offset (v),\n@@ -8857,7 +8859,7 @@ siginfo_value_write (struct value *v, struct value *fromval)\n      vice versa.  */\n   validate_registers_access ();\n \n-  transferred = target_write (current_top_target (),\n+  transferred = target_write (current_inferior ()->top_target (),\n \t\t\t      TARGET_OBJECT_SIGNAL_INFO,\n \t\t\t      NULL,\n \t\t\t      value_contents_all_raw (fromval),\n@@ -8921,7 +8923,8 @@ class infcall_suspend_state\n \n \tsiginfo_data.reset ((gdb_byte *) xmalloc (len));\n \n-\tif (target_read (current_top_target (), TARGET_OBJECT_SIGNAL_INFO, NULL,\n+\tif (target_read (current_inferior ()->top_target (),\n+\t\t\t TARGET_OBJECT_SIGNAL_INFO, NULL,\n \t\t\t siginfo_data.get (), 0, len) != len)\n \t  {\n \t    /* Errors ignored.  */\n@@ -8956,7 +8959,8 @@ class infcall_suspend_state\n \tstruct type *type = gdbarch_get_siginfo_type (gdbarch);\n \n \t/* Errors ignored.  */\n-\ttarget_write (current_top_target (), TARGET_OBJECT_SIGNAL_INFO, NULL,\n+\ttarget_write (current_inferior ()->top_target (),\n+\t\t      TARGET_OBJECT_SIGNAL_INFO, NULL,\n \t\t      m_siginfo_data.get (), 0, TYPE_LENGTH (type));\n       }\n "
    },
    {
      "sha": "4034bbab8a0d35ac2513c1bd5cf25128ecd4d194",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -47,6 +47,7 @@\n #include \"gdbsupport/function-view.h\"\n #include \"gdbsupport/def-vector.h\"\n #include <algorithm>\n+#include \"inferior.h\"\n \n /* An enumeration of the various things a user might attempt to\n    complete for a linespec location.  */\n@@ -2314,7 +2315,7 @@ convert_linespec_to_sals (struct linespec_state *state, linespec_p ls)\n \t\t\t\t= (gdbarch_convert_from_func_ptr_addr\n \t\t\t\t   (gdbarch,\n \t\t\t\t    msym_addr,\n-\t\t\t\t    current_top_target ()));\n+\t\t\t\t    current_inferior ()->top_target ()));\n \t\t\t    }\n \n \t\t\t  if (msym_addr == addr)"
    },
    {
      "sha": "19604b5ff9a3feb17783dab3d0ac7b5f8105e9ca",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 13,
      "deletions": 8,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -410,9 +410,10 @@ int\n linux_is_uclinux (void)\n {\n   CORE_ADDR dummy;\n+  target_ops *target = current_inferior ()->top_target ();\n \n-  return (target_auxv_search (current_top_target (), AT_NULL, &dummy) > 0\n-\t  && target_auxv_search (current_top_target (), AT_PAGESZ, &dummy) == 0);\n+  return (target_auxv_search (target, AT_NULL, &dummy) > 0\n+\t  && target_auxv_search (target, AT_PAGESZ, &dummy) == 0);\n }\n \n static int\n@@ -1735,7 +1736,8 @@ linux_get_siginfo_data (thread_info *thread, struct gdbarch *gdbarch)\n \n   gdb::byte_vector buf (TYPE_LENGTH (siginfo_type));\n \n-  bytes_read = target_read (current_top_target (), TARGET_OBJECT_SIGNAL_INFO, NULL,\n+  bytes_read = target_read (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_SIGNAL_INFO, NULL,\n \t\t\t    buf.data (), 0, TYPE_LENGTH (siginfo_type));\n   if (bytes_read != TYPE_LENGTH (siginfo_type))\n     buf.clear ();\n@@ -2037,7 +2039,8 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \n   /* Auxillary vector.  */\n   gdb::optional<gdb::byte_vector> auxv =\n-    target_read_alloc (current_top_target (), TARGET_OBJECT_AUXV, NULL);\n+    target_read_alloc (current_inferior ()->top_target (),\n+\t\t       TARGET_OBJECT_AUXV, NULL);\n   if (auxv && !auxv->empty ())\n     {\n       note_data.reset (elfcore_write_note (obfd, note_data.release (),\n@@ -2317,7 +2320,8 @@ linux_vsyscall_range_raw (struct gdbarch *gdbarch, struct mem_range *range)\n   char filename[100];\n   long pid;\n \n-  if (target_auxv_search (current_top_target (), AT_SYSINFO_EHDR, &range->start) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_SYSINFO_EHDR, &range->start) <= 0)\n     return 0;\n \n   /* It doesn't make sense to access the host's /proc when debugging a\n@@ -2507,14 +2511,15 @@ linux_displaced_step_location (struct gdbarch *gdbarch)\n      local-store address and is thus not usable as displaced stepping\n      location.  The auxiliary vector gets us the PowerPC-side entry\n      point address instead.  */\n-  if (target_auxv_search (current_top_target (), AT_ENTRY, &addr) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_ENTRY, &addr) <= 0)\n     throw_error (NOT_SUPPORTED_ERROR,\n \t\t _(\"Cannot find AT_ENTRY auxiliary vector entry.\"));\n \n   /* Make certain that the address points at real code, and not a\n      function descriptor.  */\n-  addr = gdbarch_convert_from_func_ptr_addr (gdbarch, addr,\n-\t\t\t\t\t     current_top_target ());\n+  addr = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, addr, current_inferior ()->top_target ());\n \n   /* Inferior calls also use the entry point as a breakpoint location.\n      We don't want displaced stepping to interfere with those"
    },
    {
      "sha": "7f505d07a6994d7f096044337a3c75c8597affc3",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -40,6 +40,7 @@\n #include \"top.h\"\n #include \"maint.h\"\n #include \"gdbsupport/selftest.h\"\n+#include \"inferior.h\"\n \n #include \"cli/cli-decode.h\"\n #include \"cli/cli-utils.h\"\n@@ -472,7 +473,7 @@ maintenance_info_target_sections (const char *arg, int from_tty)\n   bfd *abfd = nullptr;\n   int digits = 0;\n   const target_section_table *table\n-    = target_get_section_table (current_top_target ());\n+    = target_get_section_table (current_inferior ()->top_target ());\n   if (table == nullptr)\n     return;\n "
    },
    {
      "sha": "c6f1ab4e3f0fbbea520304181bcdb1a77d3cfef5",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -264,7 +264,7 @@ proceed_thread_callback (struct thread_info *thread, void *arg)\n static void\n exec_continue (char **argv, int argc)\n {\n-  prepare_execution_command (current_top_target (), mi_async_p ());\n+  prepare_execution_command (current_inferior ()->top_target (), mi_async_p ());\n \n   if (non_stop)\n     {\n@@ -1328,7 +1328,8 @@ mi_cmd_data_read_memory (const char *command, char **argv, int argc)\n \n   gdb::byte_vector mbuf (total_bytes);\n \n-  nr_bytes = target_read (current_top_target (), TARGET_OBJECT_MEMORY, NULL,\n+  nr_bytes = target_read (current_inferior ()->top_target (),\n+\t\t\t  TARGET_OBJECT_MEMORY, NULL,\n \t\t\t  mbuf.data (), addr, total_bytes);\n   if (nr_bytes <= 0)\n     error (_(\"Unable to read memory.\"));\n@@ -1448,7 +1449,7 @@ mi_cmd_data_read_memory_bytes (const char *command, char **argv, int argc)\n   length = atol (argv[1]);\n \n   std::vector<memory_read_result> result\n-    = read_memory_robust (current_top_target (), addr, length);\n+    = read_memory_robust (current_inferior ()->top_target (), addr, length);\n \n   if (result.size () == 0)\n     error (_(\"Unable to read memory.\"));"
    },
    {
      "sha": "8ffd90761249722699a5c508c441f024c0f33c74",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -54,6 +54,7 @@\n #include <algorithm>\n #include \"safe-ctype.h\"\n #include \"gdbsupport/parallel-for.h\"\n+#include \"inferior.h\"\n \n #if CXX_STD_THREAD\n #include <mutex>\n@@ -78,9 +79,8 @@ msymbol_is_function (struct objfile *objfile, minimal_symbol *minsym,\n     case mst_data_gnu_ifunc:\n       {\n \tstruct gdbarch *gdbarch = objfile->arch ();\n-\tCORE_ADDR pc\n-\t  = gdbarch_convert_from_func_ptr_addr (gdbarch, msym_addr,\n-\t\t\t\t\t\tcurrent_top_target ());\n+\tCORE_ADDR pc = gdbarch_convert_from_func_ptr_addr\n+\t  (gdbarch, msym_addr, current_inferior ()->top_target ());\n \tif (pc != msym_addr)\n \t  {\n \t    if (func_address_p != NULL)"
    },
    {
      "sha": "171f5b386fa8d3848d0875372cb7a18689a61874",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 12,
      "deletions": 7,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1967,8 +1967,8 @@ ppc_linux_nat_target::read_description ()\n \n   features.wordsize = ppc_linux_target_wordsize (tid);\n \n-  CORE_ADDR hwcap = linux_get_hwcap (current_top_target ());\n-  CORE_ADDR hwcap2 = linux_get_hwcap2 (current_top_target ());\n+  CORE_ADDR hwcap = linux_get_hwcap (current_inferior ()->top_target ());\n+  CORE_ADDR hwcap2 = linux_get_hwcap2 (current_inferior ()->top_target ());\n \n   if (have_ptrace_getsetvsxregs\n       && (hwcap & PPC_FEATURE_HAS_VSX))\n@@ -2125,7 +2125,8 @@ ppc_linux_nat_target::region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n \t takes two hardware watchpoints though.  */\n       if (len > 1\n \t  && hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE\n-\t  && linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+\t  && (linux_get_hwcap (current_inferior ()->top_target ())\n+\t      & PPC_FEATURE_BOOKE))\n \treturn 2;\n       /* Check if the processor provides DAWR interface.  */\n       if (hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_DAWR)\n@@ -2153,7 +2154,8 @@ ppc_linux_nat_target::region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n     {\n       gdb_assert (m_dreg_interface.debugreg_p ());\n \n-      if (((linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+      if (((linux_get_hwcap (current_inferior ()->top_target ())\n+\t    & PPC_FEATURE_BOOKE)\n \t   && (addr + len) > (addr & ~3) + 4)\n \t  || (addr + len) > (addr & ~7) + 8)\n \treturn 0;\n@@ -2640,7 +2642,8 @@ ppc_linux_nat_target::insert_watchpoint (CORE_ADDR addr, int len,\n       long wp_value;\n       long read_mode, write_mode;\n \n-      if (linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+      if (linux_get_hwcap (current_inferior ()->top_target ())\n+\t  & PPC_FEATURE_BOOKE)\n \t{\n \t  /* PowerPC 440 requires only the read/write flags to be passed\n \t     to the kernel.  */\n@@ -3013,9 +3016,11 @@ ppc_linux_nat_target::watchpoint_addr_within_range (CORE_ADDR addr,\n   int mask;\n \n   if (m_dreg_interface.hwdebug_p ()\n-      && linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+      && (linux_get_hwcap (current_inferior ()->top_target ())\n+\t  & PPC_FEATURE_BOOKE))\n     return start <= addr && start + length >= addr;\n-  else if (linux_get_hwcap (current_top_target ()) & PPC_FEATURE_BOOKE)\n+  else if (linux_get_hwcap (current_inferior ()->top_target ())\n+\t   & PPC_FEATURE_BOOKE)\n     mask = 3;\n   else\n     mask = 7;"
    },
    {
      "sha": "eb703cf43b70d1b621dedb21ea21149199259648",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -3643,7 +3643,8 @@ procfs_target::make_corefile_notes (bfd *obfd, int *note_size)\n \t\t\t     &thread_args);\n \n   gdb::optional<gdb::byte_vector> auxv =\n-    target_read_alloc (current_top_target (), TARGET_OBJECT_AUXV, NULL);\n+    target_read_alloc (current_inferior ()->top_target (),\n+\t\t       TARGET_OBJECT_AUXV, NULL);\n   if (auxv && !auxv->empty ())\n     note_data.reset (elfcore_write_note (obfd, note_data.release (), note_size,\n \t\t\t\t\t \"CORE\", NT_AUXV, auxv->data (),"
    },
    {
      "sha": "bf3c6f43e6af89fc65d020232015f62b887179c3",
      "filename": "gdb/regcache.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/regcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/regcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/regcache.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1916,7 +1916,7 @@ cooked_write_test (struct gdbarch *gdbarch)\n {\n   /* Error out if debugging something, because we're going to push the\n      test target, which would pop any existing target.  */\n-  if (current_top_target ()->stratum () >= process_stratum)\n+  if (current_inferior ()->top_target ()->stratum () >= process_stratum)\n     error (_(\"target already pushed\"));\n \n   /* Create a mock environment.  A process_stratum target pushed.  */"
    },
    {
      "sha": "ff1366ebc40fcd5312385fd060500ccc1cbee066",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 11,
      "deletions": 8,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -5079,9 +5079,8 @@ remote_target::remote_check_symbols ()\n \n \t  /* If this is a function address, return the start of code\n \t     instead of any data function descriptor.  */\n-\t  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n-\t\t\t\t\t\t\t sym_addr,\n-\t\t\t\t\t\t\t current_top_target ());\n+\t  sym_addr = gdbarch_convert_from_func_ptr_addr\n+\t    (target_gdbarch (), sym_addr, current_inferior ()->top_target ());\n \n \t  xsnprintf (msg.data (), get_remote_packet_size (), \"qSymbol:%s:%s\",\n \t\t     phex_nz (sym_addr, addr_size), &reply[8]);\n@@ -11463,7 +11462,8 @@ remote_target::memory_map ()\n {\n   std::vector<mem_region> result;\n   gdb::optional<gdb::char_vector> text\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_MEMORY_MAP, NULL);\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_MEMORY_MAP, NULL);\n \n   if (text)\n     result = parse_memory_map (text->data ());\n@@ -13694,7 +13694,8 @@ traceframe_info_up\n remote_target::traceframe_info ()\n {\n   gdb::optional<gdb::char_vector> text\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_TRACEFRAME_INFO,\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_TRACEFRAME_INFO,\n \t\t\t    NULL);\n   if (text)\n     return parse_traceframe_info (text->data ());\n@@ -13923,7 +13924,8 @@ static void\n btrace_read_config (struct btrace_config *conf)\n {\n   gdb::optional<gdb::char_vector> xml\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_BTRACE_CONF, \"\");\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_BTRACE_CONF, \"\");\n   if (xml)\n     parse_xml_btrace_conf (conf, xml->data ());\n }\n@@ -14124,7 +14126,8 @@ remote_target::read_btrace (struct btrace_data *btrace,\n     }\n \n   gdb::optional<gdb::char_vector> xml\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_BTRACE, annex);\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_BTRACE, annex);\n   if (!xml)\n     return BTRACE_ERR_UNKNOWN;\n \n@@ -14180,7 +14183,7 @@ remote_target::pid_to_exec_file (int pid)\n       xsnprintf (annex, annex_size, \"%x\", pid);\n     }\n \n-  filename = target_read_stralloc (current_top_target (),\n+  filename = target_read_stralloc (current_inferior ()->top_target (),\n \t\t\t\t   TARGET_OBJECT_EXEC_FILE, annex);\n \n   return filename ? filename->data () : nullptr;"
    },
    {
      "sha": "cb06cd952a708224b2148d2fcdff95e2588f52f4",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -5077,7 +5077,8 @@ ppc_process_record_op31 (struct gdbarch *gdbarch, struct regcache *regcache,\n       return 0;\n \n     case 1014:\t\t/* Data Cache Block set to Zero */\n-      if (target_auxv_search (current_top_target (), AT_DCACHEBSIZE, &at_dcsz) <= 0\n+      if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t      AT_DCACHEBSIZE, &at_dcsz) <= 0\n \t  || at_dcsz == 0)\n \tat_dcsz = 128; /* Assume 128-byte cache line size (POWER8)  */\n "
    },
    {
      "sha": "41b50ce4800346bdbc301d1114ab1f4976f413c2",
      "filename": "gdb/s390-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/s390-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/s390-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-nat.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1002,7 +1002,7 @@ s390_linux_nat_target::read_description ()\n      that mode, report s390 architecture with 64-bit GPRs.  */\n #ifdef __s390x__\n   {\n-    CORE_ADDR hwcap = linux_get_hwcap (current_top_target ());\n+    CORE_ADDR hwcap = linux_get_hwcap (current_inferior ()->top_target ());\n \n     have_regset_tdb = (hwcap & HWCAP_S390_TE)\n       && check_regset (tid, NT_S390_TDB, s390_sizeof_tdbregset);"
    },
    {
      "sha": "1bd770a3cc3d6bff4f5d5171d86ac3c34db441e3",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -39,6 +39,7 @@\n #include \"target-descriptions.h\"\n #include \"trad-frame.h\"\n #include \"value.h\"\n+#include \"inferior.h\"\n \n #include \"features/s390-linux32.c\"\n #include \"features/s390x-linux64.c\"\n@@ -685,7 +686,7 @@ s390_load (struct s390_prologue_data *data,\n   if (pv_is_constant (addr))\n     {\n       const struct target_section *secp\n-\t= target_section_by_addr (current_top_target (), addr.k);\n+\t= target_section_by_addr (current_inferior ()->top_target (), addr.k);\n       if (secp != NULL\n \t  && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n \treturn pv_constant (read_memory_integer (addr.k, size,"
    },
    {
      "sha": "faccf299899b6623d7f7b75e7bf12ff3d3de7392",
      "filename": "gdb/solib-aix.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-aix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-aix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-aix.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -246,7 +246,8 @@ solib_aix_get_library_list (struct inferior *inf, const char *warning_msg)\n     return data->library_list;\n \n   gdb::optional<gdb::char_vector> library_document\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_LIBRARIES_AIX,\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_LIBRARIES_AIX,\n \t\t\t    NULL);\n   if (!library_document && warning_msg != NULL)\n     {"
    },
    {
      "sha": "152afc21b9df93e389a1e2ed266203d86ac2406e",
      "filename": "gdb/solib-darwin.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-darwin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-darwin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-darwin.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -488,7 +488,8 @@ darwin_solib_read_all_image_info_addr (struct darwin_info *info)\n   if (TYPE_LENGTH (ptr_type) > sizeof (buf))\n     return;\n \n-  len = target_read (current_top_target (), TARGET_OBJECT_DARWIN_DYLD_INFO,\n+  len = target_read (current_inferior ()->top_target (),\n+\t\t     TARGET_OBJECT_DARWIN_DYLD_INFO,\n \t\t     NULL, buf, 0, TYPE_LENGTH (ptr_type));\n   if (len <= 0)\n     return;"
    },
    {
      "sha": "c279435c89a1e5a43b1d7cd0f418e51f0bd66dfe",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -280,7 +280,8 @@ dsbt_get_initial_loadmaps (void)\n {\n   struct dsbt_info *info = get_dsbt_info ();\n   gdb::optional<gdb::byte_vector> buf\n-    = target_read_alloc (current_top_target (), TARGET_OBJECT_FDPIC, \"exec\");\n+    = target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t TARGET_OBJECT_FDPIC, \"exec\");\n \n   if (!buf || buf->empty ())\n     {\n@@ -291,7 +292,8 @@ dsbt_get_initial_loadmaps (void)\n   if (solib_dsbt_debug)\n     dsbt_print_loadmap (info->exec_loadmap);\n \n-  buf = target_read_alloc (current_top_target (), TARGET_OBJECT_FDPIC, \"exec\");\n+  buf = target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t   TARGET_OBJECT_FDPIC, \"exec\");\n   if (!buf || buf->empty ())\n     {\n       info->interp_loadmap = NULL;"
    },
    {
      "sha": "531469484e546ed33a037abc3d9d0fafa3de559e",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 19,
      "deletions": 15,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -428,11 +428,14 @@ read_program_header (int type, int *p_arch_size, CORE_ADDR *base_addr)\n   int pt_phdr_p = 0;\n \n   /* Get required auxv elements from target.  */\n-  if (target_auxv_search (current_top_target (), AT_PHDR, &at_phdr) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_PHDR, &at_phdr) <= 0)\n     return {};\n-  if (target_auxv_search (current_top_target (), AT_PHENT, &at_phent) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_PHENT, &at_phent) <= 0)\n     return {};\n-  if (target_auxv_search (current_top_target (), AT_PHNUM, &at_phnum) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_PHNUM, &at_phnum) <= 0)\n     return {};\n   if (!at_phdr || !at_phnum)\n     return {};\n@@ -1239,7 +1242,8 @@ svr4_current_sos_via_xfer_libraries (struct svr4_library_list *list,\n \n   /* Fetch the list of shared libraries.  */\n   gdb::optional<gdb::char_vector> svr4_library_document\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_LIBRARIES_SVR4,\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_LIBRARIES_SVR4,\n \t\t\t    annex);\n   if (!svr4_library_document)\n     return 0;\n@@ -2242,9 +2246,8 @@ enable_break (struct svr4_info *info, int from_tty)\n \n       sym_addr = gdbarch_addr_bits_remove\n \t(target_gdbarch (),\n-\t gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n-\t\t\t\t\t     sym_addr,\n-\t\t\t\t\t     current_top_target ()));\n+\t gdbarch_convert_from_func_ptr_addr\n+\t   (target_gdbarch (), sym_addr, current_inferior ()->top_target ()));\n \n       /* On at least some versions of Solaris there's a dynamic relocation\n \t on _r_debug.r_brk and SYM_ADDR may not be relocated yet, e.g., if\n@@ -2353,7 +2356,8 @@ enable_break (struct svr4_info *info, int from_tty)\n       /* If we were not able to find the base address of the loader\n \t from our so_list, then try using the AT_BASE auxilliary entry.  */\n       if (!load_addr_found)\n-\tif (target_auxv_search (current_top_target (), AT_BASE, &load_addr) > 0)\n+\tif (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t\tAT_BASE, &load_addr) > 0)\n \t  {\n \t    int addr_bit = gdbarch_addr_bit (target_gdbarch ());\n \n@@ -2474,9 +2478,8 @@ enable_break (struct svr4_info *info, int from_tty)\n \t  && (BMSYMBOL_VALUE_ADDRESS (msymbol) != 0))\n \t{\n \t  sym_addr = BMSYMBOL_VALUE_ADDRESS (msymbol);\n-\t  sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n-\t\t\t\t\t\t\t sym_addr,\n-\t\t\t\t\t\t\t current_top_target ());\n+\t  sym_addr = gdbarch_convert_from_func_ptr_addr\n+\t    (target_gdbarch (), sym_addr, current_inferior ()->top_target ());\n \t  svr4_create_solib_event_breakpoints (info, target_gdbarch (),\n \t\t\t\t\t       sym_addr);\n \t  return 1;\n@@ -2492,9 +2495,9 @@ enable_break (struct svr4_info *info, int from_tty)\n \t      && (BMSYMBOL_VALUE_ADDRESS (msymbol) != 0))\n \t    {\n \t      sym_addr = BMSYMBOL_VALUE_ADDRESS (msymbol);\n-\t      sym_addr = gdbarch_convert_from_func_ptr_addr (target_gdbarch (),\n-\t\t\t\t\t\t\t     sym_addr,\n-\t\t\t\t\t\t\t     current_top_target ());\n+\t      sym_addr = gdbarch_convert_from_func_ptr_addr\n+\t\t(target_gdbarch (), sym_addr,\n+\t\t current_inferior ()->top_target ());\n \t      svr4_create_solib_event_breakpoints (info, target_gdbarch (),\n \t\t\t\t\t\t   sym_addr);\n \t      return 1;\n@@ -2582,7 +2585,8 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n   if ((bfd_get_file_flags (current_program_space->exec_bfd ()) & DYNAMIC) == 0)\n     return 0;\n \n-  if (target_auxv_search (current_top_target (), AT_ENTRY, &entry_point) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_ENTRY, &entry_point) <= 0)\n     return 0;\n \n   exec_displacement"
    },
    {
      "sha": "1e010c52221a65768956725e566ed19e3bf48680",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -25,6 +25,7 @@\n #include \"target.h\"\n #include \"solib-target.h\"\n #include <vector>\n+#include \"inferior.h\"\n \n /* Private data for each loaded library.  */\n struct lm_info_target : public lm_info_base\n@@ -233,8 +234,8 @@ solib_target_current_sos (void)\n \n   /* Fetch the list of shared libraries.  */\n   gdb::optional<gdb::char_vector> library_document\n-    = target_read_stralloc (current_top_target (), TARGET_OBJECT_LIBRARIES,\n-\t\t\t    NULL);\n+    = target_read_stralloc (current_inferior ()->top_target (),\n+\t\t\t    TARGET_OBJECT_LIBRARIES, NULL);\n   if (!library_document)\n     return NULL;\n "
    },
    {
      "sha": "a6df0fcb58b47132619ea59e1bd53198c1ba184a",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -189,7 +189,7 @@ ULONGEST\n sparc_fetch_wcookie (struct gdbarch *gdbarch)\n {\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  struct target_ops *ops = current_top_target ();\n+  struct target_ops *ops = current_inferior ()->top_target ();\n   gdb_byte buf[8];\n   int len;\n "
    },
    {
      "sha": "3609794419ab549797f08d12581ff05e73ba7e35",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -214,10 +214,12 @@ adi_available (void)\n     return proc->stat.is_avail;\n \n   proc->stat.checked_avail = true;\n-  if (target_auxv_search (current_top_target (), AT_ADI_BLKSZ, &value) <= 0)\n+  if (target_auxv_search (current_inferior ()->top_target (),\n+\t\t\t  AT_ADI_BLKSZ, &value) <= 0)\n     return false;\n   proc->stat.blksize = value;\n-  target_auxv_search (current_top_target (), AT_ADI_NBITS, &value);\n+  target_auxv_search (current_inferior ()->top_target (),\n+\t\t      AT_ADI_NBITS, &value);\n   proc->stat.nbits = value;\n   proc->stat.max_version = (1 << proc->stat.nbits) - 2;\n   proc->stat.is_avail = true;"
    },
    {
      "sha": "e417878031db8b7bb8cc52463475ed83b0632408",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -838,10 +838,8 @@ init_entry_point_info (struct objfile *objfile)\n \n       /* Make certain that the address points at real code, and not a\n \t function descriptor.  */\n-      entry_point\n-\t= gdbarch_convert_from_func_ptr_addr (objfile->arch (),\n-\t\t\t\t\t      entry_point,\n-\t\t\t\t\t      current_top_target ());\n+      entry_point = gdbarch_convert_from_func_ptr_addr\n+\t(objfile->arch (), entry_point, current_inferior ()->top_target ());\n \n       /* Remove any ISA markers, so that this matches entries in the\n \t symbol table.  */"
    },
    {
      "sha": "122fdf0b1d3ea908c47069fc60b20dcbf2508a8c",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -5564,10 +5564,8 @@ find_gnu_ifunc (const symbol *sym)\n \t  if (MSYMBOL_TYPE (minsym) == mst_data_gnu_ifunc)\n \t    {\n \t      struct gdbarch *gdbarch = objfile->arch ();\n-\t      msym_addr\n-\t\t= gdbarch_convert_from_func_ptr_addr (gdbarch,\n-\t\t\t\t\t\t      msym_addr,\n-\t\t\t\t\t\t      current_top_target ());\n+\t      msym_addr = gdbarch_convert_from_func_ptr_addr\n+\t\t(gdbarch, msym_addr, current_inferior ()->top_target ());\n \t    }\n \t  if (msym_addr == address)\n \t    {"
    },
    {
      "sha": "c0e798a3530a33f03dc94af6f751ec2bc035921d",
      "filename": "gdb/target-descriptions.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target-descriptions.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target-descriptions.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -553,11 +553,13 @@ target_find_description (void)\n   /* Next try to read the description from the current target using\n      target objects.  */\n   if (current_target_desc == NULL)\n-    current_target_desc = target_read_description_xml (current_top_target ());\n+    current_target_desc = target_read_description_xml\n+      (current_inferior ()->top_target ());\n \n   /* If that failed try a target-specific hook.  */\n   if (current_target_desc == NULL)\n-    current_target_desc = target_read_description (current_top_target ());\n+    current_target_desc = target_read_description\n+      (current_inferior ()->top_target ());\n \n   /* If a non-NULL description was returned, then update the current\n      architecture.  */"
    },
    {
      "sha": "877f6c3e94636fa885cebeaaa5301397be89fe95",
      "filename": "gdb/target-memory.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target-memory.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target-memory.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-memory.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -21,6 +21,7 @@\n #include \"defs.h\"\n #include \"target.h\"\n #include \"memory-map.h\"\n+#include \"inferior.h\"\n \n #include \"gdbsupport/gdb_sys_time.h\"\n #include <algorithm>\n@@ -335,7 +336,7 @@ target_write_memory_blocks (const std::vector<memory_write_request> &requests,\n     {\n       LONGEST len;\n \n-      len = target_write_with_progress (current_top_target (),\n+      len = target_write_with_progress (current_inferior ()->top_target (),\n \t\t\t\t\tTARGET_OBJECT_MEMORY, NULL,\n \t\t\t\t\titer.data, iter.begin,\n \t\t\t\t\titer.end - iter.begin,\n@@ -358,7 +359,7 @@ target_write_memory_blocks (const std::vector<memory_write_request> &requests,\n \t{\n \t  LONGEST len;\n \n-\t  len = target_write_with_progress (current_top_target (),\n+\t  len = target_write_with_progress (current_inferior ()->top_target (),\n \t\t\t\t\t    TARGET_OBJECT_FLASH, NULL,\n \t\t\t\t\t    iter.data, iter.begin,\n \t\t\t\t\t    iter.end - iter.begin,"
    },
    {
      "sha": "3653a7a98f805091fc7fedbc087b60a4ca88bc9e",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 275,
      "deletions": 193,
      "changes": 468,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -110,16 +110,6 @@ static std::unordered_map<const target_info *, target_open_ftype *>\n \n static struct target_ops *the_debug_target;\n \n-/* Top of target stack.  */\n-/* The target structure we are currently using to talk to a process\n-   or file or whatever \"inferior\" we have.  */\n-\n-target_ops *\n-current_top_target ()\n-{\n-  return current_inferior ()->top_target ();\n-}\n-\n /* Command list for target.  */\n \n static struct cmd_list_element *targetlist = NULL;\n@@ -173,7 +163,9 @@ show_targetdebug (struct ui_file *file, int from_tty,\n int\n target_has_memory ()\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     if (t->has_memory ())\n       return 1;\n \n@@ -183,7 +175,9 @@ target_has_memory ()\n int\n target_has_stack ()\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     if (t->has_stack ())\n       return 1;\n \n@@ -193,7 +187,9 @@ target_has_stack ()\n int\n target_has_registers ()\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     if (t->has_registers ())\n       return 1;\n \n@@ -218,141 +214,145 @@ target_has_execution (inferior *inf)\n const char *\n target_shortname ()\n {\n-  return current_top_target ()->shortname ();\n+  return current_inferior ()->top_target ()->shortname ();\n }\n \n /* See target.h.  */\n \n bool\n target_attach_no_wait ()\n {\n-  return current_top_target ()->attach_no_wait ();\n+  return current_inferior ()->top_target ()->attach_no_wait ();\n }\n \n /* See target.h.  */\n \n void\n target_post_attach (int pid)\n {\n-  return current_top_target ()->post_attach (pid);\n+  return current_inferior ()->top_target ()->post_attach (pid);\n }\n \n /* See target.h.  */\n \n void\n target_prepare_to_store (regcache *regcache)\n {\n-  return current_top_target ()->prepare_to_store (regcache);\n+  return current_inferior ()->top_target ()->prepare_to_store (regcache);\n }\n \n /* See target.h.  */\n \n bool\n target_supports_enable_disable_tracepoint ()\n {\n-  return current_top_target ()->supports_enable_disable_tracepoint ();\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->supports_enable_disable_tracepoint ();\n }\n \n bool\n target_supports_string_tracing ()\n {\n-  return current_top_target ()->supports_string_tracing ();\n+  return current_inferior ()->top_target ()->supports_string_tracing ();\n }\n \n /* See target.h.  */\n \n bool\n target_supports_evaluation_of_breakpoint_conditions ()\n {\n-  return current_top_target ()->supports_evaluation_of_breakpoint_conditions ();\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->supports_evaluation_of_breakpoint_conditions ();\n }\n \n /* See target.h.  */\n \n bool\n target_supports_dumpcore ()\n {\n-  return current_top_target ()->supports_dumpcore ();\n+  return current_inferior ()->top_target ()->supports_dumpcore ();\n }\n \n /* See target.h.  */\n \n void\n target_dumpcore (const char *filename)\n {\n-  return current_top_target ()->dumpcore (filename);\n+  return current_inferior ()->top_target ()->dumpcore (filename);\n }\n \n /* See target.h.  */\n \n bool\n target_can_run_breakpoint_commands ()\n {\n-  return current_top_target ()->can_run_breakpoint_commands ();\n+  return current_inferior ()->top_target ()->can_run_breakpoint_commands ();\n }\n \n /* See target.h.  */\n \n void\n target_files_info ()\n {\n-  return current_top_target ()->files_info ();\n+  return current_inferior ()->top_target ()->files_info ();\n }\n \n /* See target.h.  */\n \n void\n target_post_startup_inferior (ptid_t ptid)\n {\n-  return current_top_target ()->post_startup_inferior (ptid);\n+  return current_inferior ()->top_target ()->post_startup_inferior (ptid);\n }\n \n /* See target.h.  */\n \n int\n target_insert_fork_catchpoint (int pid)\n {\n-  return current_top_target ()->insert_fork_catchpoint (pid);\n+  return current_inferior ()->top_target ()->insert_fork_catchpoint (pid);\n }\n \n /* See target.h.  */\n \n int\n target_remove_fork_catchpoint (int pid)\n {\n-  return current_top_target ()->remove_fork_catchpoint (pid);\n+  return current_inferior ()->top_target ()->remove_fork_catchpoint (pid);\n }\n \n /* See target.h.  */\n \n int\n target_insert_vfork_catchpoint (int pid)\n {\n-  return current_top_target ()->insert_vfork_catchpoint (pid);\n+  return current_inferior ()->top_target ()->insert_vfork_catchpoint (pid);\n }\n \n /* See target.h.  */\n \n int\n target_remove_vfork_catchpoint (int pid)\n {\n-  return current_top_target ()->remove_vfork_catchpoint (pid);\n+  return current_inferior ()->top_target ()->remove_vfork_catchpoint (pid);\n }\n \n /* See target.h.  */\n \n int\n target_insert_exec_catchpoint (int pid)\n {\n-  return current_top_target ()->insert_exec_catchpoint (pid);\n+  return current_inferior ()->top_target ()->insert_exec_catchpoint (pid);\n }\n \n /* See target.h.  */\n \n int\n target_remove_exec_catchpoint (int pid)\n {\n-  return current_top_target ()->remove_exec_catchpoint (pid);\n+  return current_inferior ()->top_target ()->remove_exec_catchpoint (pid);\n }\n \n /* See target.h.  */\n@@ -361,164 +361,175 @@ int\n target_set_syscall_catchpoint (int pid, bool needed, int any_count,\n \t\t\t       gdb::array_view<const int> syscall_counts)\n {\n-  return current_top_target ()->set_syscall_catchpoint (pid, needed, any_count,\n-\t\t\t\t\t\t\tsyscall_counts);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->set_syscall_catchpoint (pid, needed, any_count,\n+\t\t\t\t\t syscall_counts);\n }\n \n /* See target.h.  */\n \n void\n target_rcmd (const char *command, struct ui_file *outbuf)\n {\n-  return current_top_target ()->rcmd (command, outbuf);\n+  return current_inferior ()->top_target ()->rcmd (command, outbuf);\n }\n \n /* See target.h.  */\n \n bool\n target_can_lock_scheduler ()\n {\n-  return (current_top_target ()->get_thread_control_capabilities ()\n-\t  & tc_schedlock) != 0;\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return (target->get_thread_control_capabilities ()& tc_schedlock) != 0;\n }\n \n /* See target.h.  */\n \n bool\n target_can_async_p ()\n {\n-  return current_top_target ()->can_async_p ();\n+  return current_inferior ()->top_target ()->can_async_p ();\n }\n \n /* See target.h.  */\n \n bool\n target_is_async_p ()\n {\n-  return current_top_target ()->is_async_p ();\n+  return current_inferior ()->top_target ()->is_async_p ();\n }\n \n exec_direction_kind\n target_execution_direction ()\n {\n-  return current_top_target ()->execution_direction ();\n+  return current_inferior ()->top_target ()->execution_direction ();\n }\n \n /* See target.h.  */\n \n const char *\n target_extra_thread_info (thread_info *tp)\n {\n-  return current_top_target ()->extra_thread_info (tp);\n+  return current_inferior ()->top_target ()->extra_thread_info (tp);\n }\n \n /* See target.h.  */\n \n char *\n target_pid_to_exec_file (int pid)\n {\n-  return current_top_target ()->pid_to_exec_file (pid);\n+  return current_inferior ()->top_target ()->pid_to_exec_file (pid);\n }\n \n /* See target.h.  */\n \n gdbarch *\n target_thread_architecture (ptid_t ptid)\n {\n-  return current_top_target ()->thread_architecture (ptid);\n+  return current_inferior ()->top_target ()->thread_architecture (ptid);\n }\n \n /* See target.h.  */\n \n int\n target_find_memory_regions (find_memory_region_ftype func, void *data)\n {\n-  return current_top_target ()->find_memory_regions (func, data);\n+  return current_inferior ()->top_target ()->find_memory_regions (func, data);\n }\n \n /* See target.h.  */\n \n gdb::unique_xmalloc_ptr<char>\n target_make_corefile_notes (bfd *bfd, int *size_p)\n {\n-  return current_top_target ()->make_corefile_notes (bfd, size_p);\n+  return current_inferior ()->top_target ()->make_corefile_notes (bfd, size_p);\n }\n \n gdb_byte *\n target_get_bookmark (const char *args, int from_tty)\n {\n-  return current_top_target ()->get_bookmark (args, from_tty);\n+  return current_inferior ()->top_target ()->get_bookmark (args, from_tty);\n }\n \n void\n target_goto_bookmark (const gdb_byte *arg, int from_tty)\n {\n-  return current_top_target ()->goto_bookmark (arg, from_tty);\n+  return current_inferior ()->top_target ()->goto_bookmark (arg, from_tty);\n }\n \n /* See target.h.  */\n \n bool\n target_stopped_by_watchpoint ()\n {\n-  return current_top_target ()->stopped_by_watchpoint ();\n+  return current_inferior ()->top_target ()->stopped_by_watchpoint ();\n }\n \n /* See target.h.  */\n \n bool\n target_stopped_by_sw_breakpoint ()\n {\n-  return current_top_target ()->stopped_by_sw_breakpoint ();\n+  return current_inferior ()->top_target ()->stopped_by_sw_breakpoint ();\n }\n \n bool\n target_supports_stopped_by_sw_breakpoint ()\n {\n-  return current_top_target ()->supports_stopped_by_sw_breakpoint ();\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->supports_stopped_by_sw_breakpoint ();\n }\n \n bool\n target_stopped_by_hw_breakpoint ()\n {\n-  return current_top_target ()->stopped_by_hw_breakpoint ();\n+  return current_inferior ()->top_target ()->stopped_by_hw_breakpoint ();\n }\n \n bool\n target_supports_stopped_by_hw_breakpoint ()\n {\n-  return current_top_target ()->supports_stopped_by_hw_breakpoint ();\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->supports_stopped_by_hw_breakpoint ();\n }\n \n /* See target.h.  */\n \n bool\n target_have_steppable_watchpoint ()\n {\n-  return current_top_target ()->have_steppable_watchpoint ();\n+  return current_inferior ()->top_target ()->have_steppable_watchpoint ();\n }\n \n /* See target.h.  */\n \n int\n target_can_use_hardware_watchpoint (bptype type, int cnt, int othertype)\n {\n-  return current_top_target ()->can_use_hw_breakpoint (type, cnt, othertype);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->can_use_hw_breakpoint (type, cnt, othertype);\n }\n \n /* See target.h.  */\n \n int\n target_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n {\n-  return current_top_target ()->region_ok_for_hw_watchpoint (addr, len);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->region_ok_for_hw_watchpoint (addr, len);\n }\n \n \n int\n target_can_do_single_step ()\n {\n-  return current_top_target ()->can_do_single_step ();\n+  return current_inferior ()->top_target ()->can_do_single_step ();\n }\n \n /* See target.h.  */\n@@ -527,7 +538,9 @@ int\n target_insert_watchpoint (CORE_ADDR addr, int len, target_hw_bp_type type,\n \t\t\t  expression *cond)\n {\n-  return current_top_target ()->insert_watchpoint (addr, len, type, cond);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->insert_watchpoint (addr, len, type, cond);\n }\n \n /* See target.h.  */\n@@ -536,23 +549,29 @@ int\n target_remove_watchpoint (CORE_ADDR addr, int len, target_hw_bp_type type,\n \t\t\t  expression *cond)\n {\n-  return current_top_target ()->remove_watchpoint (addr, len, type, cond);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->remove_watchpoint (addr, len, type, cond);\n }\n \n /* See target.h.  */\n \n int\n target_insert_hw_breakpoint (gdbarch *gdbarch, bp_target_info *bp_tgt)\n {\n-  return current_top_target ()->insert_hw_breakpoint (gdbarch, bp_tgt);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->insert_hw_breakpoint (gdbarch, bp_tgt);\n }\n \n /* See target.h.  */\n \n int\n target_remove_hw_breakpoint (gdbarch *gdbarch, bp_target_info *bp_tgt)\n {\n-  return current_top_target ()->remove_hw_breakpoint (gdbarch, bp_tgt);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->remove_hw_breakpoint (gdbarch, bp_tgt);\n }\n \n /* See target.h.  */\n@@ -561,236 +580,256 @@ bool\n target_can_accel_watchpoint_condition (CORE_ADDR addr, int len, int type,\n \t\t\t\t       expression *cond)\n {\n-  return current_top_target ()->can_accel_watchpoint_condition (addr, len, type, cond);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->can_accel_watchpoint_condition (addr, len, type, cond);\n }\n \n /* See target.h.  */\n \n bool\n target_can_execute_reverse ()\n {\n-  return current_top_target ()->can_execute_reverse ();\n+  return current_inferior ()->top_target ()->can_execute_reverse ();\n }\n \n ptid_t\n target_get_ada_task_ptid (long lwp, long tid)\n {\n-  return current_top_target ()->get_ada_task_ptid (lwp, tid);\n+  return current_inferior ()->top_target ()->get_ada_task_ptid (lwp, tid);\n }\n \n bool\n target_filesystem_is_local ()\n {\n-  return current_top_target ()->filesystem_is_local ();\n+  return current_inferior ()->top_target ()->filesystem_is_local ();\n }\n \n void\n target_trace_init ()\n {\n-  return current_top_target ()->trace_init ();\n+  return current_inferior ()->top_target ()->trace_init ();\n }\n \n void\n target_download_tracepoint (bp_location *location)\n {\n-  return current_top_target ()->download_tracepoint (location);\n+  return current_inferior ()->top_target ()->download_tracepoint (location);\n }\n \n bool\n target_can_download_tracepoint ()\n {\n-  return current_top_target ()->can_download_tracepoint ();\n+  return current_inferior ()->top_target ()->can_download_tracepoint ();\n }\n \n void\n target_download_trace_state_variable (const trace_state_variable &tsv)\n {\n-  return current_top_target ()->download_trace_state_variable (tsv);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->download_trace_state_variable (tsv);\n }\n \n void\n target_enable_tracepoint (bp_location *loc)\n {\n-  return current_top_target ()->enable_tracepoint (loc);\n+  return current_inferior ()->top_target ()->enable_tracepoint (loc);\n }\n \n void\n target_disable_tracepoint (bp_location *loc)\n {\n-  return current_top_target ()->disable_tracepoint (loc);\n+  return current_inferior ()->top_target ()->disable_tracepoint (loc);\n }\n \n void\n target_trace_start ()\n {\n-  return current_top_target ()->trace_start ();\n+  return current_inferior ()->top_target ()->trace_start ();\n }\n \n void\n target_trace_set_readonly_regions ()\n {\n-  current_top_target ()->trace_set_readonly_regions ();\n+  return current_inferior ()->top_target ()->trace_set_readonly_regions ();\n }\n \n int\n target_get_trace_status (trace_status *ts)\n {\n-  return current_top_target ()->get_trace_status (ts);\n+  return current_inferior ()->top_target ()->get_trace_status (ts);\n }\n \n void\n target_get_tracepoint_status (breakpoint *tp, uploaded_tp *utp)\n {\n-  return current_top_target ()->get_tracepoint_status (tp, utp);\n+  return current_inferior ()->top_target ()->get_tracepoint_status (tp, utp);\n }\n \n void\n target_trace_stop ()\n {\n-  return current_top_target ()->trace_stop ();\n+  return current_inferior ()->top_target ()->trace_stop ();\n }\n \n int\n target_trace_find (trace_find_type type, int num,\n \t\t   CORE_ADDR addr1, CORE_ADDR addr2, int *tpp)\n {\n-  return current_top_target ()->trace_find (type, num, addr1, addr2, tpp);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->trace_find (type, num, addr1, addr2, tpp);\n }\n \n bool\n target_get_trace_state_variable_value (int tsv, LONGEST *val)\n {\n-  return current_top_target ()->get_trace_state_variable_value (tsv, val);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->get_trace_state_variable_value (tsv, val);\n }\n \n int\n target_save_trace_data (const char *filename)\n {\n-  return current_top_target ()->save_trace_data (filename);\n+  return current_inferior ()->top_target ()->save_trace_data (filename);\n }\n \n int\n target_upload_tracepoints (uploaded_tp **utpp)\n {\n-  return current_top_target ()->upload_tracepoints (utpp);\n+  return current_inferior ()->top_target ()->upload_tracepoints (utpp);\n }\n \n int\n target_upload_trace_state_variables (uploaded_tsv **utsvp)\n {\n-  return current_top_target ()->upload_trace_state_variables (utsvp);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->upload_trace_state_variables (utsvp);\n }\n \n LONGEST\n target_get_raw_trace_data (gdb_byte *buf, ULONGEST offset, LONGEST len)\n {\n-  return current_top_target ()->get_raw_trace_data (buf, offset, len);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->get_raw_trace_data (buf, offset, len);\n }\n \n int\n target_get_min_fast_tracepoint_insn_len ()\n {\n-  return current_top_target ()->get_min_fast_tracepoint_insn_len ();\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->get_min_fast_tracepoint_insn_len ();\n }\n \n void\n target_set_disconnected_tracing (int val)\n {\n-  return current_top_target ()->set_disconnected_tracing (val);\n+  return current_inferior ()->top_target ()->set_disconnected_tracing (val);\n }\n \n void\n target_set_circular_trace_buffer (int val)\n {\n-  return current_top_target ()->set_circular_trace_buffer (val);\n+  return current_inferior ()->top_target ()->set_circular_trace_buffer (val);\n }\n \n void\n target_set_trace_buffer_size (LONGEST val)\n {\n-  return current_top_target ()->set_trace_buffer_size (val);\n+  return current_inferior ()->top_target ()->set_trace_buffer_size (val);\n }\n \n bool\n target_set_trace_notes (const char *user, const char *notes,\n \t\t\tconst char *stopnotes)\n {\n-  return current_top_target ()->set_trace_notes (user, notes, stopnotes);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->set_trace_notes (user, notes, stopnotes);\n }\n \n bool\n target_get_tib_address (ptid_t ptid, CORE_ADDR *addr)\n {\n-  return current_top_target ()->get_tib_address (ptid, addr);\n+  return current_inferior ()->top_target ()->get_tib_address (ptid, addr);\n }\n \n void\n target_set_permissions ()\n {\n-  return current_top_target ()->set_permissions ();\n+  return current_inferior ()->top_target ()->set_permissions ();\n }\n \n bool\n target_static_tracepoint_marker_at (CORE_ADDR addr,\n \t\t\t\t    static_tracepoint_marker *marker)\n {\n-  return current_top_target ()->static_tracepoint_marker_at (addr, marker);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->static_tracepoint_marker_at (addr, marker);\n }\n \n std::vector<static_tracepoint_marker>\n target_static_tracepoint_markers_by_strid (const char *marker_id)\n {\n-  return current_top_target ()->static_tracepoint_markers_by_strid (marker_id);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->static_tracepoint_markers_by_strid (marker_id);\n }\n \n traceframe_info_up\n target_traceframe_info ()\n {\n-  return current_top_target ()->traceframe_info ();\n+  return current_inferior ()->top_target ()->traceframe_info ();\n }\n \n bool\n target_use_agent (bool use)\n {\n-  return current_top_target ()->use_agent (use);\n+  return current_inferior ()->top_target ()->use_agent (use);\n }\n \n bool\n target_can_use_agent ()\n {\n-  return current_top_target ()->can_use_agent ();\n+  return current_inferior ()->top_target ()->can_use_agent ();\n }\n \n bool\n target_augmented_libraries_svr4_read ()\n {\n-  return current_top_target ()->augmented_libraries_svr4_read ();\n+  return current_inferior ()->top_target ()->augmented_libraries_svr4_read ();\n }\n \n bool\n target_supports_memory_tagging ()\n {\n-  return current_top_target ()->supports_memory_tagging ();\n+  return current_inferior ()->top_target ()->supports_memory_tagging ();\n }\n \n bool\n target_fetch_memtags (CORE_ADDR address, size_t len, gdb::byte_vector &tags,\n \t\t      int type)\n {\n-  return current_top_target ()->fetch_memtags (address, len, tags, type);\n+  return current_inferior ()->top_target ()->fetch_memtags (address, len, tags, type);\n }\n \n bool\n target_store_memtags (CORE_ADDR address, size_t len,\n \t\t      const gdb::byte_vector &tags, int type)\n {\n-  return current_top_target ()->store_memtags (address, len, tags, type);\n+  return current_inferior ()->top_target ()->store_memtags (address, len, tags, type);\n }\n \n void\n target_log_command (const char *p)\n {\n-  return current_top_target ()->log_command (p);\n+  return current_inferior ()->top_target ()->log_command (p);\n }\n \n /* This is used to implement the various target commands.  */\n@@ -863,14 +902,14 @@ add_deprecated_target_alias (const target_info &tinfo, const char *alias)\n void\n target_kill (void)\n {\n-  current_top_target ()->kill ();\n+  current_inferior ()->top_target ()->kill ();\n }\n \n void\n target_load (const char *arg, int from_tty)\n {\n   target_dcache_invalidate ();\n-  current_top_target ()->load (arg, from_tty);\n+  current_inferior ()->top_target ()->load (arg, from_tty);\n }\n \n /* Define it.  */\n@@ -883,7 +922,7 @@ target_terminal_state target_terminal::m_terminal_state\n void\n target_terminal::init (void)\n {\n-  current_top_target ()->terminal_init ();\n+  current_inferior ()->top_target ()->terminal_init ();\n \n   m_terminal_state = target_terminal_state::is_ours;\n }\n@@ -914,7 +953,7 @@ target_terminal::inferior (void)\n \n   if (inf->terminal_state != target_terminal_state::is_inferior)\n     {\n-      current_top_target ()->terminal_inferior ();\n+      current_inferior ()->top_target ()->terminal_inferior ();\n       inf->terminal_state = target_terminal_state::is_inferior;\n     }\n \n@@ -949,7 +988,7 @@ target_terminal::restore_inferior (void)\n \tif (inf->terminal_state == target_terminal_state::is_ours_for_output)\n \t  {\n \t    set_current_inferior (inf);\n-\t    current_top_target ()->terminal_inferior ();\n+\t    current_inferior ()->top_target ()->terminal_inferior ();\n \t    inf->terminal_state = target_terminal_state::is_inferior;\n \t  }\n       }\n@@ -981,7 +1020,7 @@ target_terminal_is_ours_kind (target_terminal_state desired_state)\n       if (inf->terminal_state == target_terminal_state::is_inferior)\n \t{\n \t  set_current_inferior (inf);\n-\t  current_top_target ()->terminal_save_inferior ();\n+\t  current_inferior ()->top_target ()->terminal_save_inferior ();\n \t}\n     }\n \n@@ -996,9 +1035,9 @@ target_terminal_is_ours_kind (target_terminal_state desired_state)\n \t{\n \t  set_current_inferior (inf);\n \t  if (desired_state == target_terminal_state::is_ours)\n-\t    current_top_target ()->terminal_ours ();\n+\t    current_inferior ()->top_target ()->terminal_ours ();\n \t  else if (desired_state == target_terminal_state::is_ours_for_output)\n-\t    current_top_target ()->terminal_ours_for_output ();\n+\t    current_inferior ()->top_target ()->terminal_ours_for_output ();\n \t  else\n \t    gdb_assert_not_reached (\"unhandled desired state\");\n \t  inf->terminal_state = desired_state;\n@@ -1047,7 +1086,7 @@ target_terminal::ours_for_output ()\n void\n target_terminal::info (const char *arg, int from_tty)\n {\n-  current_top_target ()->terminal_info (arg, from_tty);\n+  current_inferior ()->top_target ()->terminal_info (arg, from_tty);\n }\n \n /* See target.h.  */\n@@ -1071,7 +1110,7 @@ static void\n tcomplain (void)\n {\n   error (_(\"You can't do that when your target is `%s'\"),\n-\t current_top_target ()->shortname ());\n+\t current_inferior ()->top_target ()->shortname ());\n }\n \n void\n@@ -1206,17 +1245,19 @@ unpush_target_and_assert (struct target_ops *target)\n void\n pop_all_targets_above (enum strata above_stratum)\n {\n-  while ((int) (current_top_target ()->stratum ()) > (int) above_stratum)\n-    unpush_target_and_assert (current_top_target ());\n+  while ((int) (current_inferior ()->top_target ()->stratum ())\n+\t > (int) above_stratum)\n+    unpush_target_and_assert (current_inferior ()->top_target ());\n }\n \n /* See target.h.  */\n \n void\n pop_all_targets_at_and_above (enum strata stratum)\n {\n-  while ((int) (current_top_target ()->stratum ()) >= (int) stratum)\n-    unpush_target_and_assert (current_top_target ());\n+  while ((int) (current_inferior ()->top_target ()->stratum ())\n+\t >= (int) stratum)\n+    unpush_target_and_assert (current_inferior ()->top_target ());\n }\n \n void\n@@ -1246,7 +1287,7 @@ CORE_ADDR\n target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)\n {\n   volatile CORE_ADDR addr = 0;\n-  struct target_ops *target = current_top_target ();\n+  struct target_ops *target = current_inferior ()->top_target ();\n   struct gdbarch *gdbarch = target_gdbarch ();\n \n   if (gdbarch_fetch_tls_load_module_address_p (gdbarch))\n@@ -1765,7 +1806,8 @@ target_xfer_partial (struct target_ops *ops,\n int\n target_read_memory (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_read (current_top_target (), TARGET_OBJECT_MEMORY, NULL,\n+  if (target_read (current_inferior ()->top_target (),\n+\t\t   TARGET_OBJECT_MEMORY, NULL,\n \t\t   myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1795,7 +1837,8 @@ target_read_uint32 (CORE_ADDR memaddr, uint32_t *result)\n int\n target_read_raw_memory (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_read (current_top_target (), TARGET_OBJECT_RAW_MEMORY, NULL,\n+  if (target_read (current_inferior ()->top_target (),\n+\t\t   TARGET_OBJECT_RAW_MEMORY, NULL,\n \t\t   myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1808,7 +1851,8 @@ target_read_raw_memory (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n int\n target_read_stack (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_read (current_top_target (), TARGET_OBJECT_STACK_MEMORY, NULL,\n+  if (target_read (current_inferior ()->top_target (),\n+\t\t   TARGET_OBJECT_STACK_MEMORY, NULL,\n \t\t   myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1821,7 +1865,8 @@ target_read_stack (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n int\n target_read_code (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_read (current_top_target (), TARGET_OBJECT_CODE_MEMORY, NULL,\n+  if (target_read (current_inferior ()->top_target (),\n+\t\t   TARGET_OBJECT_CODE_MEMORY, NULL,\n \t\t   myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1837,7 +1882,8 @@ target_read_code (CORE_ADDR memaddr, gdb_byte *myaddr, ssize_t len)\n int\n target_write_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_write (current_top_target (), TARGET_OBJECT_MEMORY, NULL,\n+  if (target_write (current_inferior ()->top_target (),\n+\t\t    TARGET_OBJECT_MEMORY, NULL,\n \t\t    myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1853,7 +1899,8 @@ target_write_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)\n int\n target_write_raw_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)\n {\n-  if (target_write (current_top_target (), TARGET_OBJECT_RAW_MEMORY, NULL,\n+  if (target_write (current_inferior ()->top_target (),\n+\t\t    TARGET_OBJECT_RAW_MEMORY, NULL,\n \t\t    myaddr, memaddr, len) == len)\n     return 0;\n   else\n@@ -1865,7 +1912,8 @@ target_write_raw_memory (CORE_ADDR memaddr, const gdb_byte *myaddr, ssize_t len)\n std::vector<mem_region>\n target_memory_map (void)\n {\n-  std::vector<mem_region> result = current_top_target ()->memory_map ();\n+  target_ops *target = current_inferior ()->top_target ();\n+  std::vector<mem_region> result = target->memory_map ();\n   if (result.empty ())\n     return result;\n \n@@ -1895,13 +1943,13 @@ target_memory_map (void)\n void\n target_flash_erase (ULONGEST address, LONGEST length)\n {\n-  current_top_target ()->flash_erase (address, length);\n+  current_inferior ()->top_target ()->flash_erase (address, length);\n }\n \n void\n target_flash_done (void)\n {\n-  current_top_target ()->flash_done ();\n+  current_inferior ()->top_target ()->flash_done ();\n }\n \n static void\n@@ -2356,7 +2404,9 @@ target_insert_breakpoint (struct gdbarch *gdbarch,\n       return 1;\n     }\n \n-  return current_top_target ()->insert_breakpoint (gdbarch, bp_tgt);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->insert_breakpoint (gdbarch, bp_tgt);\n }\n \n /* See target.h.  */\n@@ -2376,7 +2426,9 @@ target_remove_breakpoint (struct gdbarch *gdbarch,\n       return 1;\n     }\n \n-  return current_top_target ()->remove_breakpoint (gdbarch, bp_tgt, reason);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->remove_breakpoint (gdbarch, bp_tgt, reason);\n }\n \n static void\n@@ -2391,7 +2443,9 @@ info_target_command (const char *args, int from_tty)\n \t\t\t objfile_name (objf));\n     }\n \n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       if (!t->has_memory ())\n \tcontinue;\n@@ -2511,7 +2565,7 @@ target_detach (inferior *inf, int from_tty)\n      target.  */\n   auto proc_target_ref = target_ops_ref::new_reference (inf->process_target ());\n \n-  current_top_target ()->detach (inf, from_tty);\n+  current_inferior ()->top_target ()->detach (inf, from_tty);\n \n   process_stratum_target *proc_target\n     = as_process_stratum_target (proc_target_ref.get ());\n@@ -2533,7 +2587,7 @@ target_disconnect (const char *args, int from_tty)\n      disconnecting.  */\n   remove_breakpoints ();\n \n-  current_top_target ()->disconnect (args, from_tty);\n+  current_inferior ()->top_target ()->disconnect (args, from_tty);\n }\n \n /* See target/target.h.  */\n@@ -2542,7 +2596,7 @@ ptid_t\n target_wait (ptid_t ptid, struct target_waitstatus *status,\n \t     target_wait_flags options)\n {\n-  target_ops *target = current_top_target ();\n+  target_ops *target = current_inferior ()->top_target ();\n \n   if (!target->can_async_p ())\n     gdb_assert ((options & TARGET_WNOHANG) == 0);\n@@ -2564,32 +2618,35 @@ default_target_wait (struct target_ops *ops,\n std::string\n target_pid_to_str (ptid_t ptid)\n {\n-  return current_top_target ()->pid_to_str (ptid);\n+  return current_inferior ()->top_target ()->pid_to_str (ptid);\n }\n \n const char *\n target_thread_name (struct thread_info *info)\n {\n   gdb_assert (info->inf == current_inferior ());\n \n-  return current_top_target ()->thread_name (info);\n+  return current_inferior ()->top_target ()->thread_name (info);\n }\n \n struct thread_info *\n target_thread_handle_to_thread_info (const gdb_byte *thread_handle,\n \t\t\t\t     int handle_len,\n \t\t\t\t     struct inferior *inf)\n {\n-  return current_top_target ()->thread_handle_to_thread_info (thread_handle,\n-\t\t\t\t\t\t     handle_len, inf);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->thread_handle_to_thread_info (thread_handle, handle_len, inf);\n }\n \n /* See target.h.  */\n \n gdb::byte_vector\n target_thread_info_to_thread_handle (struct thread_info *tip)\n {\n-  return current_top_target ()->thread_info_to_thread_handle (tip);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->thread_info_to_thread_handle (tip);\n }\n \n void\n@@ -2599,7 +2656,7 @@ target_resume (ptid_t ptid, int step, enum gdb_signal signal)\n \n   target_dcache_invalidate ();\n \n-  current_top_target ()->resume (ptid, step, signal);\n+  current_inferior ()->top_target ()->resume (ptid, step, signal);\n \n   registers_changed_ptid (curr_target, ptid);\n   /* We only set the internal executing state here.  The user/frontend\n@@ -2620,7 +2677,7 @@ target_commit_resume (void)\n   if (defer_target_commit_resume)\n     return;\n \n-  current_top_target ()->commit_resume ();\n+  current_inferior ()->top_target ()->commit_resume ();\n }\n \n /* See target.h.  */\n@@ -2634,13 +2691,13 @@ make_scoped_defer_target_commit_resume ()\n void\n target_pass_signals (gdb::array_view<const unsigned char> pass_signals)\n {\n-  current_top_target ()->pass_signals (pass_signals);\n+  current_inferior ()->top_target ()->pass_signals (pass_signals);\n }\n \n void\n target_program_signals (gdb::array_view<const unsigned char> program_signals)\n {\n-  current_top_target ()->program_signals (program_signals);\n+  current_inferior ()->top_target ()->program_signals (program_signals);\n }\n \n static bool\n@@ -2658,15 +2715,17 @@ default_follow_fork (struct target_ops *self, bool follow_child,\n bool\n target_follow_fork (bool follow_child, bool detach_fork)\n {\n-  return current_top_target ()->follow_fork (follow_child, detach_fork);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->follow_fork (follow_child, detach_fork);\n }\n \n /* Target wrapper for follow exec hook.  */\n \n void\n target_follow_exec (struct inferior *inf, const char *execd_pathname)\n {\n-  current_top_target ()->follow_exec (inf, execd_pathname);\n+  current_inferior ()->top_target ()->follow_exec (inf, execd_pathname);\n }\n \n static void\n@@ -2680,7 +2739,7 @@ void\n target_mourn_inferior (ptid_t ptid)\n {\n   gdb_assert (ptid.pid () == inferior_ptid.pid ());\n-  current_top_target ()->mourn_inferior ();\n+  current_inferior ()->top_target ()->mourn_inferior ();\n \n   /* We no longer need to keep handles on any of the object files.\n      Make sure to release them to avoid unnecessarily locking any\n@@ -2708,7 +2767,8 @@ default_search_memory (struct target_ops *self,\n {\n   auto read_memory = [=] (CORE_ADDR addr, gdb_byte *result, size_t len)\n     {\n-      return target_read (current_top_target (), TARGET_OBJECT_MEMORY, NULL,\n+      return target_read (current_inferior ()->top_target (),\n+\t\t\t  TARGET_OBJECT_MEMORY, NULL,\n \t\t\t  result, addr, len) == len;\n     };\n \n@@ -2729,8 +2789,10 @@ target_search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n \t\t      const gdb_byte *pattern, ULONGEST pattern_len,\n \t\t      CORE_ADDR *found_addrp)\n {\n-  return current_top_target ()->search_memory (start_addr, search_space_len,\n-\t\t\t\t      pattern, pattern_len, found_addrp);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->search_memory (start_addr, search_space_len, pattern,\n+\t\t\t\tpattern_len, found_addrp);\n }\n \n /* Look through the currently pushed targets.  If none of them will\n@@ -2740,7 +2802,9 @@ target_search_memory (CORE_ADDR start_addr, ULONGEST search_space_len,\n void\n target_require_runnable (void)\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       /* If this target knows how to create a new program, then\n \t assume we will still be able to after killing the current\n@@ -2830,7 +2894,9 @@ struct target_ops *\n find_attach_target (void)\n {\n   /* If a target on the current stack can attach, use it.  */\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       if (t->can_attach ())\n \treturn t;\n@@ -2846,7 +2912,9 @@ struct target_ops *\n find_run_target (void)\n {\n   /* If a target on the current stack can run, use it.  */\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       if (t->can_create_inferior ())\n \treturn t;\n@@ -2905,15 +2973,15 @@ find_default_supports_disable_randomization (struct target_ops *self)\n int\n target_supports_disable_randomization (void)\n {\n-  return current_top_target ()->supports_disable_randomization ();\n+  return current_inferior ()->top_target ()->supports_disable_randomization ();\n }\n \n /* See target/target.h.  */\n \n int\n target_supports_multi_process (void)\n {\n-  return current_top_target ()->supports_multi_process ();\n+  return current_inferior ()->top_target ()->supports_multi_process ();\n }\n \n /* See target.h.  */\n@@ -2943,7 +3011,7 @@ target_thread_address_space (ptid_t ptid)\n {\n   struct address_space *aspace;\n \n-  aspace = current_top_target ()->thread_address_space (ptid);\n+  aspace = current_inferior ()->top_target ()->thread_address_space (ptid);\n   gdb_assert (aspace != NULL);\n \n   return aspace;\n@@ -2996,7 +3064,9 @@ target_ops::can_run ()\n int\n target_can_run ()\n {\n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       if (t->can_run ())\n \treturn 1;\n@@ -3679,13 +3749,13 @@ target_close (struct target_ops *targ)\n int\n target_thread_alive (ptid_t ptid)\n {\n-  return current_top_target ()->thread_alive (ptid);\n+  return current_inferior ()->top_target ()->thread_alive (ptid);\n }\n \n void\n target_update_thread_list (void)\n {\n-  current_top_target ()->update_thread_list ();\n+  current_inferior ()->top_target ()->update_thread_list ();\n }\n \n void\n@@ -3697,7 +3767,7 @@ target_stop (ptid_t ptid)\n       return;\n     }\n \n-  current_top_target ()->stop (ptid);\n+  current_inferior ()->top_target ()->stop (ptid);\n }\n \n void\n@@ -3709,7 +3779,7 @@ target_interrupt ()\n       return;\n     }\n \n-  current_top_target ()->interrupt ();\n+  current_inferior ()->top_target ()->interrupt ();\n }\n \n /* See target.h.  */\n@@ -3739,7 +3809,7 @@ target_pass_ctrlc (void)\n \t\t through the target_stack.  */\n \t      scoped_restore_current_inferior restore_inferior;\n \t      set_current_inferior (inf);\n-\t      current_top_target ()->pass_ctrlc ();\n+\t      current_inferior ()->top_target ()->pass_ctrlc ();\n \t      return;\n \t    }\n \t}\n@@ -3834,7 +3904,7 @@ target_options_to_string (target_wait_flags target_options)\n void\n target_fetch_registers (struct regcache *regcache, int regno)\n {\n-  current_top_target ()->fetch_registers (regcache, regno);\n+  current_inferior ()->top_target ()->fetch_registers (regcache, regno);\n   if (targetdebug)\n     regcache->debug_print_register (\"target_fetch_registers\", regno);\n }\n@@ -3845,7 +3915,7 @@ target_store_registers (struct regcache *regcache, int regno)\n   if (!may_write_registers)\n     error (_(\"Writing to registers is not allowed (regno %d)\"), regno);\n \n-  current_top_target ()->store_registers (regcache, regno);\n+  current_inferior ()->top_target ()->store_registers (regcache, regno);\n   if (targetdebug)\n     {\n       regcache->debug_print_register (\"target_store_registers\", regno);\n@@ -3855,7 +3925,7 @@ target_store_registers (struct regcache *regcache, int regno)\n int\n target_core_of_thread (ptid_t ptid)\n {\n-  return current_top_target ()->core_of_thread (ptid);\n+  return current_inferior ()->top_target ()->core_of_thread (ptid);\n }\n \n int\n@@ -3893,14 +3963,16 @@ default_verify_memory (struct target_ops *self,\n \t\t       const gdb_byte *data, CORE_ADDR memaddr, ULONGEST size)\n {\n   /* Start over from the top of the target stack.  */\n-  return simple_verify_memory (current_top_target (),\n+  return simple_verify_memory (current_inferior ()->top_target (),\n \t\t\t       data, memaddr, size);\n }\n \n int\n target_verify_memory (const gdb_byte *data, CORE_ADDR memaddr, ULONGEST size)\n {\n-  return current_top_target ()->verify_memory (data, memaddr, size);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->verify_memory (data, memaddr, size);\n }\n \n /* The documentation for this function is in its prototype declaration in\n@@ -3910,7 +3982,9 @@ int\n target_insert_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask,\n \t\t\t       enum target_hw_bp_type rw)\n {\n-  return current_top_target ()->insert_mask_watchpoint (addr, mask, rw);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->insert_mask_watchpoint (addr, mask, rw);\n }\n \n /* The documentation for this function is in its prototype declaration in\n@@ -3920,7 +3994,9 @@ int\n target_remove_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask,\n \t\t\t       enum target_hw_bp_type rw)\n {\n-  return current_top_target ()->remove_mask_watchpoint (addr, mask, rw);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->remove_mask_watchpoint (addr, mask, rw);\n }\n \n /* The documentation for this function is in its prototype declaration\n@@ -3929,7 +4005,9 @@ target_remove_mask_watchpoint (CORE_ADDR addr, CORE_ADDR mask,\n int\n target_masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask)\n {\n-  return current_top_target ()->masked_watch_num_registers (addr, mask);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->masked_watch_num_registers (addr, mask);\n }\n \n /* The documentation for this function is in its prototype declaration\n@@ -3938,31 +4016,31 @@ target_masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask)\n int\n target_ranged_break_num_registers (void)\n {\n-  return current_top_target ()->ranged_break_num_registers ();\n+  return current_inferior ()->top_target ()->ranged_break_num_registers ();\n }\n \n /* See target.h.  */\n \n struct btrace_target_info *\n target_enable_btrace (ptid_t ptid, const struct btrace_config *conf)\n {\n-  return current_top_target ()->enable_btrace (ptid, conf);\n+  return current_inferior ()->top_target ()->enable_btrace (ptid, conf);\n }\n \n /* See target.h.  */\n \n void\n target_disable_btrace (struct btrace_target_info *btinfo)\n {\n-  current_top_target ()->disable_btrace (btinfo);\n+  current_inferior ()->top_target ()->disable_btrace (btinfo);\n }\n \n /* See target.h.  */\n \n void\n target_teardown_btrace (struct btrace_target_info *btinfo)\n {\n-  current_top_target ()->teardown_btrace (btinfo);\n+  current_inferior ()->top_target ()->teardown_btrace (btinfo);\n }\n \n /* See target.h.  */\n@@ -3972,111 +4050,113 @@ target_read_btrace (struct btrace_data *btrace,\n \t\t    struct btrace_target_info *btinfo,\n \t\t    enum btrace_read_type type)\n {\n-  return current_top_target ()->read_btrace (btrace, btinfo, type);\n+  target_ops *target = current_inferior ()->top_target ();\n+\n+  return target->read_btrace (btrace, btinfo, type);\n }\n \n /* See target.h.  */\n \n const struct btrace_config *\n target_btrace_conf (const struct btrace_target_info *btinfo)\n {\n-  return current_top_target ()->btrace_conf (btinfo);\n+  return current_inferior ()->top_target ()->btrace_conf (btinfo);\n }\n \n /* See target.h.  */\n \n void\n target_stop_recording (void)\n {\n-  current_top_target ()->stop_recording ();\n+  current_inferior ()->top_target ()->stop_recording ();\n }\n \n /* See target.h.  */\n \n void\n target_save_record (const char *filename)\n {\n-  current_top_target ()->save_record (filename);\n+  current_inferior ()->top_target ()->save_record (filename);\n }\n \n /* See target.h.  */\n \n int\n target_supports_delete_record ()\n {\n-  return current_top_target ()->supports_delete_record ();\n+  return current_inferior ()->top_target ()->supports_delete_record ();\n }\n \n /* See target.h.  */\n \n void\n target_delete_record (void)\n {\n-  current_top_target ()->delete_record ();\n+  current_inferior ()->top_target ()->delete_record ();\n }\n \n /* See target.h.  */\n \n enum record_method\n target_record_method (ptid_t ptid)\n {\n-  return current_top_target ()->record_method (ptid);\n+  return current_inferior ()->top_target ()->record_method (ptid);\n }\n \n /* See target.h.  */\n \n int\n target_record_is_replaying (ptid_t ptid)\n {\n-  return current_top_target ()->record_is_replaying (ptid);\n+  return current_inferior ()->top_target ()->record_is_replaying (ptid);\n }\n \n /* See target.h.  */\n \n int\n target_record_will_replay (ptid_t ptid, int dir)\n {\n-  return current_top_target ()->record_will_replay (ptid, dir);\n+  return current_inferior ()->top_target ()->record_will_replay (ptid, dir);\n }\n \n /* See target.h.  */\n \n void\n target_record_stop_replaying (void)\n {\n-  current_top_target ()->record_stop_replaying ();\n+  current_inferior ()->top_target ()->record_stop_replaying ();\n }\n \n /* See target.h.  */\n \n void\n target_goto_record_begin (void)\n {\n-  current_top_target ()->goto_record_begin ();\n+  current_inferior ()->top_target ()->goto_record_begin ();\n }\n \n /* See target.h.  */\n \n void\n target_goto_record_end (void)\n {\n-  current_top_target ()->goto_record_end ();\n+  current_inferior ()->top_target ()->goto_record_end ();\n }\n \n /* See target.h.  */\n \n void\n target_goto_record (ULONGEST insn)\n {\n-  current_top_target ()->goto_record (insn);\n+  current_inferior ()->top_target ()->goto_record (insn);\n }\n \n /* See target.h.  */\n \n void\n target_insn_history (int size, gdb_disassembly_flags flags)\n {\n-  current_top_target ()->insn_history (size, flags);\n+  current_inferior ()->top_target ()->insn_history (size, flags);\n }\n \n /* See target.h.  */\n@@ -4085,7 +4165,7 @@ void\n target_insn_history_from (ULONGEST from, int size,\n \t\t\t  gdb_disassembly_flags flags)\n {\n-  current_top_target ()->insn_history_from (from, size, flags);\n+  current_inferior ()->top_target ()->insn_history_from (from, size, flags);\n }\n \n /* See target.h.  */\n@@ -4094,63 +4174,63 @@ void\n target_insn_history_range (ULONGEST begin, ULONGEST end,\n \t\t\t   gdb_disassembly_flags flags)\n {\n-  current_top_target ()->insn_history_range (begin, end, flags);\n+  current_inferior ()->top_target ()->insn_history_range (begin, end, flags);\n }\n \n /* See target.h.  */\n \n void\n target_call_history (int size, record_print_flags flags)\n {\n-  current_top_target ()->call_history (size, flags);\n+  current_inferior ()->top_target ()->call_history (size, flags);\n }\n \n /* See target.h.  */\n \n void\n target_call_history_from (ULONGEST begin, int size, record_print_flags flags)\n {\n-  current_top_target ()->call_history_from (begin, size, flags);\n+  current_inferior ()->top_target ()->call_history_from (begin, size, flags);\n }\n \n /* See target.h.  */\n \n void\n target_call_history_range (ULONGEST begin, ULONGEST end, record_print_flags flags)\n {\n-  current_top_target ()->call_history_range (begin, end, flags);\n+  current_inferior ()->top_target ()->call_history_range (begin, end, flags);\n }\n \n /* See target.h.  */\n \n const struct frame_unwind *\n target_get_unwinder (void)\n {\n-  return current_top_target ()->get_unwinder ();\n+  return current_inferior ()->top_target ()->get_unwinder ();\n }\n \n /* See target.h.  */\n \n const struct frame_unwind *\n target_get_tailcall_unwinder (void)\n {\n-  return current_top_target ()->get_tailcall_unwinder ();\n+  return current_inferior ()->top_target ()->get_tailcall_unwinder ();\n }\n \n /* See target.h.  */\n \n void\n target_prepare_to_generate_core (void)\n {\n-  current_top_target ()->prepare_to_generate_core ();\n+  current_inferior ()->top_target ()->prepare_to_generate_core ();\n }\n \n /* See target.h.  */\n \n void\n target_done_generating_core (void)\n {\n-  current_top_target ()->done_generating_core ();\n+  current_inferior ()->top_target ()->done_generating_core ();\n }\n \n \f\n@@ -4218,7 +4298,9 @@ maintenance_print_target_stack (const char *cmd, int from_tty)\n {\n   printf_filtered (_(\"The current target stack is:\\n\"));\n \n-  for (target_ops *t = current_top_target (); t != NULL; t = t->beneath ())\n+  for (target_ops *t = current_inferior ()->top_target ();\n+       t != NULL;\n+       t = t->beneath ())\n     {\n       if (t->stratum () == debug_stratum)\n \tcontinue;\n@@ -4232,15 +4314,15 @@ void\n target_async (int enable)\n {\n   infrun_async (enable);\n-  current_top_target ()->async (enable);\n+  current_inferior ()->top_target ()->async (enable);\n }\n \n /* See target.h.  */\n \n void\n target_thread_events (int enable)\n {\n-  current_top_target ()->thread_events (enable);\n+  current_inferior ()->top_target ()->thread_events (enable);\n }\n \n /* Controls if targets can report that they can/are async.  This is\n@@ -4280,7 +4362,7 @@ maint_show_target_async_command (struct ui_file *file, int from_tty,\n static int\n target_always_non_stop_p (void)\n {\n-  return current_top_target ()->always_non_stop_p ();\n+  return current_inferior ()->top_target ()->always_non_stop_p ();\n }\n \n /* See target.h.  */"
    },
    {
      "sha": "5d14edb9f4c7452ba9e2ae3b41cf3ab4f0dca5f1",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1385,11 +1385,6 @@ class target_stack\n   target_ops *m_stack[(int) debug_stratum + 1] {};\n };\n \n-/* The ops structure for our \"current\" target process.  This should\n-   never be NULL.  If there is no target, it points to the dummy_target.  */\n-\n-extern target_ops *current_top_target ();\n-\n /* Return the dummy target.  */\n extern target_ops *get_dummy_target ();\n "
    },
    {
      "sha": "33ce86bbe2389a7098b2b4bf098b10df6471069f",
      "filename": "gdb/tracefile-tfile.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/tracefile-tfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/tracefile-tfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracefile-tfile.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -310,7 +310,7 @@ tfile_write_tdesc (struct trace_file_writer *self)\n     = (struct tfile_trace_file_writer *) self;\n \n   gdb::optional<std::string> tdesc\n-    = target_fetch_description_xml (current_top_target ());\n+    = target_fetch_description_xml (current_inferior ()->top_target ());\n \n   if (!tdesc)\n     return;"
    },
    {
      "sha": "48d72d6a1f280bf17d2c97d50e6464354c3708f1",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -3812,7 +3812,8 @@ sdata_make_value (struct gdbarch *gdbarch, struct internalvar *var,\n {\n   /* We need to read the whole object before we know its size.  */\n   gdb::optional<gdb::byte_vector> buf\n-    = target_read_alloc (current_top_target (), TARGET_OBJECT_STATIC_TRACE_DATA,\n+    = target_read_alloc (current_inferior ()->top_target (),\n+\t\t\t TARGET_OBJECT_STATIC_TRACE_DATA,\n \t\t\t NULL);\n   if (buf)\n     {"
    },
    {
      "sha": "f86c98180584b830a4877de27ecdcc6c5203519e",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -1040,7 +1040,7 @@ read_value_memory (struct value *val, LONGEST bit_offset,\n       enum target_xfer_status status;\n       ULONGEST xfered_partial;\n \n-      status = target_xfer_partial (current_top_target (),\n+      status = target_xfer_partial (current_inferior ()->top_target (),\n \t\t\t\t    object, NULL,\n \t\t\t\t    buffer + xfered_total * unit_size, NULL,\n \t\t\t\t    memaddr + xfered_total,\n@@ -1286,7 +1286,8 @@ value_assign (struct value *toval, struct value *fromval)\n     case lval_register:\n     case lval_computed:\n \n-      gdb::observers::target_changed.notify (current_top_target ());\n+      gdb::observers::target_changed.notify\n+\t(current_inferior ()->top_target ());\n \n       /* Having destroyed the frame cache, restore the selected\n \t frame.  */"
    },
    {
      "sha": "baf50f76b60043c3632c696cafb712ae05f5c3a5",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -42,6 +42,7 @@\n #include \"count-one-bits.h\"\n #include \"c-lang.h\"\n #include \"cp-abi.h\"\n+#include \"inferior.h\"\n \n /* Maximum number of wchars returned from wchar_iterate.  */\n #define MAX_WCHARS 4\n@@ -1848,9 +1849,8 @@ print_function_pointer_address (const struct value_print_options *options,\n \t\t\t\tCORE_ADDR address,\n \t\t\t\tstruct ui_file *stream)\n {\n-  CORE_ADDR func_addr\n-    = gdbarch_convert_from_func_ptr_addr (gdbarch, address,\n-\t\t\t\t\t  current_top_target ());\n+  CORE_ADDR func_addr = gdbarch_convert_from_func_ptr_addr\n+    (gdbarch, address, current_inferior ()->top_target ());\n \n   /* If the function pointer is represented by a description, print\n      the address of the description.  */"
    },
    {
      "sha": "3bd81e76007c4795faadf85241e9ea6496a57026",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -45,6 +45,7 @@\n #include \"gdbsupport/array-view.h\"\n #include \"cli/cli-style.h\"\n #include \"expop.h\"\n+#include \"inferior.h\"\n \n /* Definition of a user function.  */\n struct internal_function\n@@ -3159,7 +3160,8 @@ value_fn_field (struct value **arg1p, struct fn_field *f,\n \n       set_value_address (v,\n \tgdbarch_convert_from_func_ptr_addr\n-\t   (gdbarch, BMSYMBOL_VALUE_ADDRESS (msym), current_top_target ()));\n+\t   (gdbarch, BMSYMBOL_VALUE_ADDRESS (msym),\n+\t    current_inferior ()->top_target ()));\n     }\n \n   if (arg1p)"
    },
    {
      "sha": "97aa3da6e777e625a9574bb2925a0dea1758e981",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/328d42d87e97c75d6e52800bfd4bc1bfdfb745d2/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=328d42d87e97c75d6e52800bfd4bc1bfdfb745d2",
      "patch": "@@ -487,7 +487,7 @@ display_one_tib (ptid_t ptid)\n       return -1;\n     }\n \n-  if (target_read (current_top_target (), TARGET_OBJECT_MEMORY,\n+  if (target_read (current_inferior ()->top_target (), TARGET_OBJECT_MEMORY,\n \t\t   NULL, tib, thread_local_base, tib_size) != tib_size)\n     {\n       printf_filtered (_(\"Unable to read thread information \""
    }
  ]
}