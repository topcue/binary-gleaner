{
  "sha": "bb4e0574881009bea97136968f92003e9a4aa46e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmI0ZTA1NzQ4ODEwMDliZWE5NzEzNjk2OGY5MjAwM2U5YTRhYTQ2ZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:38Z"
    },
    "message": "Convert go-exp.y to use operations\n\nThis converts the Go parser to generate operations rather than\nexp_elements.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* go-exp.y: Create operations.\n\t(go_language::parser): Update.",
    "tree": {
      "sha": "db6f82e675b27d2b96a42de3419492399fb1dcab",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db6f82e675b27d2b96a42de3419492399fb1dcab"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bb4e0574881009bea97136968f92003e9a4aa46e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb4e0574881009bea97136968f92003e9a4aa46e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bb4e0574881009bea97136968f92003e9a4aa46e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb4e0574881009bea97136968f92003e9a4aa46e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d182f2797922a305fbd1ef6a483cc39a56b43e02"
    }
  ],
  "stats": {
    "total": 218,
    "additions": 117,
    "deletions": 101
  },
  "files": [
    {
      "sha": "6262ade1435b8d3bdb35b9910bdd4bc2d38d00f0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb4e0574881009bea97136968f92003e9a4aa46e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb4e0574881009bea97136968f92003e9a4aa46e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=bb4e0574881009bea97136968f92003e9a4aa46e",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* go-exp.y: Create operations.\n+\t(go_language::parser): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* objc-lang.c (end_msglist): Create operations."
    },
    {
      "sha": "6e070a7f4ffc5a6c883d9e18189d7e9fe7a33956",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 112,
      "deletions": 101,
      "changes": 213,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb4e0574881009bea97136968f92003e9a4aa46e/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb4e0574881009bea97136968f92003e9a4aa46e/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=bb4e0574881009bea97136968f92003e9a4aa46e",
      "patch": "@@ -64,6 +64,7 @@\n #include \"objfiles.h\" /* For have_full_symbols and have_partial_symbols */\n #include \"charset.h\"\n #include \"block.h\"\n+#include \"expop.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -115,6 +116,8 @@ static void yyerror (const char *);\n /* YYSTYPE gets defined by %union.  */\n static int parse_number (struct parser_state *,\n \t\t\t const char *, int, int, YYSTYPE *);\n+\n+using namespace expr;\n %}\n \n %type <voidval> exp exp1 type_exp start variable lcurly\n@@ -193,88 +196,91 @@ start   :\texp1\n \t;\n \n type_exp:\ttype\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n+\t\t\t{ pstate->push_new<type_operation> ($1); }\n \t;\n \n /* Expressions, including the comma operator.  */\n exp1\t:\texp\n \t|\texp1 ',' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_COMMA); }\n+\t\t\t{ pstate->wrap2<comma_operation> (); }\n \t;\n \n /* Expressions, not including the comma operator.  */\n exp\t:\t'*' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ pstate->wrap<unop_ind_operation> (); }\n \t;\n \n exp\t:\t'&' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t\t{ pstate->wrap<unop_addr_operation> (); }\n \t;\n \n exp\t:\t'-' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t{ pstate->wrap<unary_neg_operation> (); }\n \t;\n \n exp\t:\t'+' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PLUS); }\n+\t\t\t{ pstate->wrap<unary_plus_operation> (); }\n \t;\n \n exp\t:\t'!' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{ pstate->wrap<unary_logical_not_operation> (); }\n \t;\n \n exp\t:\t'^' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_COMPLEMENT); }\n+\t\t\t{ pstate->wrap<unary_complement_operation> (); }\n \t;\n \n exp\t:\texp INCREMENT    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTINCREMENT); }\n+\t\t\t{ pstate->wrap<postinc_operation> (); }\n \t;\n \n exp\t:\texp DECREMENT    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTDECREMENT); }\n+\t\t\t{ pstate->wrap<postdec_operation> (); }\n \t;\n \n /* foo->bar is not in Go.  May want as a gdb extension.  Later.  */\n \n exp\t:\texp '.' name_not_typename\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3.stoken);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), copy_name ($3.stoken));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' name_not_typename COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3.stoken);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (),\n+\t\t\t\t\t\t      copy_name ($3.stoken));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' COMPLETE\n-\t\t\t{ struct stoken s;\n-\t\t\t  pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  s.ptr = \"\";\n-\t\t\t  s.length = 0;\n-\t\t\t  write_exp_string (pstate, s);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (), \"\");\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '[' exp1 ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT); }\n+\t\t\t{ pstate->wrap2<subscript_operation> (); }\n \t;\n \n exp\t:\texp '('\n \t\t\t/* This is to save the value of arglist_len\n \t\t\t   being accumulated by an outer function call.  */\n \t\t\t{ pstate->start_arglist (); }\n \t\targlist ')'\t%prec LEFT_ARROW\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL); }\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<funcall_operation>\n+\t\t\t    (pstate->pop (), std::move (args));\n+\t\t\t}\n \t;\n \n lcurly\t:\t'{'\n@@ -297,15 +303,17 @@ rcurly\t:\t'}'\n \t;\n \n exp\t:\tlcurly type rcurly exp  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_MEMVAL);\n-\t\t\t  write_exp_elt_type (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MEMVAL); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<unop_memval_operation>\n+\t\t\t    (pstate->pop (), $2);\n+\t\t\t}\n \t;\n \n exp\t:\ttype '(' exp ')'  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<unop_cast_operation>\n+\t\t\t    (pstate->pop (), $1);\n+\t\t\t}\n \t;\n \n exp\t:\t'(' exp1 ')'\n@@ -315,159 +323,166 @@ exp\t:\t'(' exp1 ')'\n /* Binary operators in order of decreasing precedence.  */\n \n exp\t:\texp '@' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REPEAT); }\n+\t\t\t{ pstate->wrap2<repeat_operation> (); }\n \t;\n \n exp\t:\texp '*' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ pstate->wrap2<mul_operation> (); }\n \t;\n \n exp\t:\texp '/' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t\t{ pstate->wrap2<div_operation> (); }\n \t;\n \n exp\t:\texp '%' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t\t{ pstate->wrap2<rem_operation> (); }\n \t;\n \n exp\t:\texp '+' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ pstate->wrap2<add_operation> (); }\n \t;\n \n exp\t:\texp '-' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ pstate->wrap2<sub_operation> (); }\n \t;\n \n exp\t:\texp LSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LSH); }\n+\t\t\t{ pstate->wrap2<lsh_operation> (); }\n \t;\n \n exp\t:\texp RSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_RSH); }\n+\t\t\t{ pstate->wrap2<rsh_operation> (); }\n \t;\n \n exp\t:\texp EQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t\t{ pstate->wrap2<equal_operation> (); }\n \t;\n \n exp\t:\texp NOTEQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{ pstate->wrap2<notequal_operation> (); }\n \t;\n \n exp\t:\texp LEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t\t{ pstate->wrap2<leq_operation> (); }\n \t;\n \n exp\t:\texp GEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t\t{ pstate->wrap2<geq_operation> (); }\n \t;\n \n exp\t:\texp '<' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t\t{ pstate->wrap2<less_operation> (); }\n \t;\n \n exp\t:\texp '>' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t\t{ pstate->wrap2<gtr_operation> (); }\n \t;\n \n exp\t:\texp '&' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ pstate->wrap2<bitwise_and_operation> (); }\n \t;\n \n exp\t:\texp '^' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ pstate->wrap2<bitwise_xor_operation> (); }\n \t;\n \n exp\t:\texp '|' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ pstate->wrap2<bitwise_ior_operation> (); }\n \t;\n \n exp\t:\texp ANDAND exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{ pstate->wrap2<logical_and_operation> (); }\n \t;\n \n exp\t:\texp OROR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{ pstate->wrap2<logical_or_operation> (); }\n \t;\n \n exp\t:\texp '?' exp ':' exp\t%prec '?'\n-\t\t\t{ write_exp_elt_opcode (pstate, TERNOP_COND); }\n+\t\t\t{\n+\t\t\t  operation_up last = pstate->pop ();\n+\t\t\t  operation_up mid = pstate->pop ();\n+\t\t\t  operation_up first = pstate->pop ();\n+\t\t\t  pstate->push_new<ternop_cond_operation>\n+\t\t\t    (std::move (first), std::move (mid),\n+\t\t\t     std::move (last));\n+\t\t\t}\n \t;\n \n exp\t:\texp '=' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{ pstate->wrap2<assign_operation> (); }\n \t;\n \n exp\t:\texp ASSIGN_MODIFY exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t\t  write_exp_elt_opcode (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<assign_modify_operation>\n+\t\t\t    ($2, std::move (lhs), std::move (rhs));\n+\t\t\t}\n \t;\n \n exp\t:\tINT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST)($1.val));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    ($1.type, $1.val);\n+\t\t\t}\n \t;\n \n exp\t:\tCHAR\n \t\t\t{\n \t\t\t  struct stoken_vector vec;\n \t\t\t  vec.len = 1;\n \t\t\t  vec.tokens = &$1;\n-\t\t\t  write_exp_string_vector (pstate, $1.type, &vec);\n+\t\t\t  pstate->push_c_string ($1.type, &vec);\n \t\t\t}\n \t;\n \n exp\t:\tNAME_OR_INT\n \t\t\t{ YYSTYPE val;\n \t\t\t  parse_number (pstate, $1.stoken.ptr,\n \t\t\t\t\t$1.stoken.length, 0, &val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, val.typed_val_int.type);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST)\n-\t\t\t\t\t\t val.typed_val_int.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (val.typed_val_int.type,\n+\t\t\t     val.typed_val_int.val);\n \t\t\t}\n \t;\n \n \n exp\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation> ($1.type, data);\n+\t\t\t}\n \t;\n \n exp\t:\tvariable\n \t;\n \n exp\t:\tDOLLAR_VARIABLE\n \t\t\t{\n-\t\t\t  write_dollar_variable (pstate, $1);\n+\t\t\t  pstate->push_dollar ($1);\n \t\t\t}\n \t;\n \n exp\t:\tSIZEOF_KEYWORD '(' type ')'  %prec UNARY\n \t\t\t{\n \t\t\t  /* TODO(dje): Go objects in structs.  */\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n \t\t\t  /* TODO(dje): What's the right type here?  */\n-\t\t\t  write_exp_elt_type\n-\t\t\t    (pstate,\n-\t\t\t     parse_type (pstate)->builtin_unsigned_int);\n+\t\t\t  struct type *size_type\n+\t\t\t    = parse_type (pstate)->builtin_unsigned_int;\n \t\t\t  $3 = check_typedef ($3);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) TYPE_LENGTH ($3));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (size_type, (LONGEST) TYPE_LENGTH ($3));\n \t\t\t}\n \t;\n \n exp\t:\tSIZEOF_KEYWORD  '(' exp ')'  %prec UNARY\n \t\t\t{\n \t\t\t  /* TODO(dje): Go objects in structs.  */\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_SIZEOF);\n+\t\t\t  pstate->wrap<unop_sizeof_operation> ();\n \t\t\t}\n \n string_exp:\n@@ -510,24 +525,20 @@ exp\t:\tstring_exp  %prec ABOVE_COMMA\n \t\t\t{\n \t\t\t  int i;\n \n-\t\t\t  write_exp_string_vector (pstate, 0 /*always utf8*/,\n-\t\t\t\t\t\t   &$1);\n+\t\t\t  /* Always utf8.  */\n+\t\t\t  pstate->push_c_string (0, &$1);\n \t\t\t  for (i = 0; i < $1.len; ++i)\n \t\t\t    free ($1.tokens[i].ptr);\n \t\t\t  free ($1.tokens);\n \t\t\t}\n \t;\n \n exp\t:\tTRUE_KEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t{ pstate->push_new<bool_operation> ($1); }\n \t;\n \n exp\t:\tFALSE_KEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t\t{ pstate->push_new<bool_operation> ($1); }\n \t;\n \n variable:\tname_not_typename ENTRY\n@@ -540,9 +551,7 @@ variable:\tname_not_typename ENTRY\n \t\t\t\t     \"parameters, not for \\\"%s\\\"\"),\n \t\t\t\t   copy_name ($1.stoken).c_str ());\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n-\t\t\t  write_exp_elt_sym (pstate, sym);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n+\t\t\t  pstate->push_new<var_entry_value_operation> (sym);\n \t\t\t}\n \t;\n \n@@ -554,10 +563,8 @@ variable:\tname_not_typename\n \t\t\t      if (symbol_read_needs_frame (sym.symbol))\n \t\t\t\tpstate->block_tracker->update (sym);\n \n-\t\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t      write_exp_elt_block (pstate, sym.block);\n-\t\t\t      write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n+\t\t\t      pstate->push_new<var_value_operation>\n+\t\t\t\t(sym.symbol, sym.block);\n \t\t\t    }\n \t\t\t  else if ($1.is_a_field_of_this)\n \t\t\t    {\n@@ -573,7 +580,8 @@ variable:\tname_not_typename\n \t\t\t      msymbol =\n \t\t\t\tlookup_bound_minimal_symbol (arg.c_str ());\n \t\t\t      if (msymbol.minsym != NULL)\n-\t\t\t\twrite_exp_msymbol (pstate, msymbol);\n+\t\t\t\tpstate->push_new<var_msym_value_operation>\n+\t\t\t\t  (msymbol.minsym, msymbol.objfile);\n \t\t\t      else if (!have_full_symbols ()\n \t\t\t\t       && !have_partial_symbols ())\n \t\t\t\terror (_(\"No symbol table is loaded.  \"\n@@ -1572,7 +1580,10 @@ go_language::parser (struct parser_state *par_state) const\n   popping = 0;\n   name_obstack.clear ();\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n static void"
    }
  ]
}