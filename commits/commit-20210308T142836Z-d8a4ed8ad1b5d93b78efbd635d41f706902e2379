{
  "sha": "d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDhhNGVkOGFkMWI1ZDkzYjc4ZWZiZDYzNWQ0MWY3MDY5MDJlMjM3OQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:36Z"
    },
    "message": "Implement Ada resolution\n\nAda has a parser post-pass that implements \"resolution\".  This process\nreplaces some opcodes with function calls.  For example, a \"+\"\noperation might be replaced with a call to the appropriate overloaded\nfunction.\n\nThis differs from the approach taken for the same problem in C++.\nHowever, in this series I chose not to try to make changes outside of\nrewrite the expression data structure.  So, resolution remains.\n\nThe new approach to resolution is to introduce an interface class,\nthat some concrete operations implement.  Then, the Ada code will use\nthis to resolve the expression tree.  Because new-style expressions\nare built as ordinary objects, and don't require rewriting the data\nstructure in place, in the new code this processing will be done in\nthe parser.  By the end of the series, some special cases in this area\nthat exist only for Ada will be removed.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_var_value_operation::resolve)\n\t(ada_funcall_operation::resolve)\n\t(ada_ternop_slice_operation::resolve): New methods.\n\t* ada-exp.h (struct ada_resolvable): New.\n\t(class ada_var_value_operation): Derive from ada_resolvable.\n\t<get_block, resolve>: New methods.\n\t(class ada_funcall_operation): Derive from ada_resolvable.\n\t<resolve>: New method.\n\t(class ada_ternop_slice_operation): Derive from ada_resolvable.\n\t<resolve>: New method.",
    "tree": {
      "sha": "bba8f223a7390235a5cfe7abdad40deb36219f0e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bba8f223a7390235a5cfe7abdad40deb36219f0e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "efe3af2f9a6da088a00961d579318213eeb266d4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efe3af2f9a6da088a00961d579318213eeb266d4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/efe3af2f9a6da088a00961d579318213eeb266d4"
    }
  ],
  "stats": {
    "total": 139,
    "additions": 136,
    "deletions": 3
  },
  "files": [
    {
      "sha": "c770a0dd106d5c747b665d4006661b477a5fd775",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_var_value_operation::resolve)\n+\t(ada_funcall_operation::resolve)\n+\t(ada_ternop_slice_operation::resolve): New methods.\n+\t* ada-exp.h (struct ada_resolvable): New.\n+\t(class ada_var_value_operation): Derive from ada_resolvable.\n+\t<get_block, resolve>: New methods.\n+\t(class ada_funcall_operation): Derive from ada_resolvable.\n+\t<resolve>: New method.\n+\t(class ada_ternop_slice_operation): Derive from ada_resolvable.\n+\t<resolve>: New method.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_funcall_operation::evaluate): New method."
    },
    {
      "sha": "456aa89c67d84878038e29283d93fd0fbc1c462f",
      "filename": "gdb/ada-exp.h",
      "status": "modified",
      "additions": 44,
      "deletions": 3,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ada-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ada-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.h?ref=d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
      "patch": "@@ -79,6 +79,24 @@ extern struct value *ada_binop_exp (struct type *expect_type,\n namespace expr\n {\n \n+/* The base class for Ada type resolution.  Ada operations that want\n+   to participate in resolution implement this interface.  */\n+struct ada_resolvable\n+{\n+  /* Resolve this object.  EXP is the expression being resolved.\n+     DEPROCEDURE_P is true if a symbol that refers to a zero-argument\n+     function may be turned into a function call.  PARSE_COMPLETION\n+     and TRACKER are passed in from the parser context.  CONTEXT_TYPE\n+     is the expected type of the expression, or nullptr if none is\n+     known.  This method should return true if the operation should be\n+     replaced by a function call with this object as the callee.  */\n+  virtual bool resolve (struct expression *exp,\n+\t\t\tbool deprocedure_p,\n+\t\t\tbool parse_completion,\n+\t\t\tinnermost_block_tracker *tracker,\n+\t\t\tstruct type *context_type) = 0;\n+};\n+\n /* In Ada, some generic operations must be wrapped with a handler that\n    handles some Ada-specific type conversions.  */\n class ada_wrapped_operation\n@@ -246,7 +264,8 @@ using ada_bitwise_xor_operation = ada_bitwise_operation<BINOP_BITWISE_XOR>;\n \n /* Ada array- or string-slice operation.  */\n class ada_ternop_slice_operation\n-  : public maybe_constant_operation<operation_up, operation_up, operation_up>\n+  : public maybe_constant_operation<operation_up, operation_up, operation_up>,\n+    public ada_resolvable\n {\n public:\n \n@@ -264,6 +283,12 @@ class ada_ternop_slice_operation\n \n   enum exp_opcode opcode () const override\n   { return TERNOP_SLICE; }\n+\n+  bool resolve (struct expression *exp,\n+\t\tbool deprocedure_p,\n+\t\tbool parse_completion,\n+\t\tinnermost_block_tracker *tracker,\n+\t\tstruct type *context_type) override;\n };\n \n /* Implement BINOP_IN_BOUNDS for Ada.  */\n@@ -306,7 +331,7 @@ class ada_unop_atr_operation\n \n /* Variant of var_value_operation for Ada.  */\n class ada_var_value_operation\n-  : public var_value_operation\n+  : public var_value_operation, public ada_resolvable\n {\n public:\n \n@@ -323,6 +348,15 @@ class ada_var_value_operation\n   symbol *get_symbol () const\n   { return std::get<0> (m_storage); }\n \n+  const block *get_block () const\n+  { return std::get<1> (m_storage); }\n+\n+  bool resolve (struct expression *exp,\n+\t\tbool deprocedure_p,\n+\t\tbool parse_completion,\n+\t\tinnermost_block_tracker *tracker,\n+\t\tstruct type *context_type) override;\n+\n protected:\n \n   using operation::do_generate_ax;\n@@ -392,7 +426,8 @@ class ada_structop_operation\n \n /* Function calls for Ada.  */\n class ada_funcall_operation\n-  : public tuple_holding_operation<operation_up, std::vector<operation_up>>\n+  : public tuple_holding_operation<operation_up, std::vector<operation_up>>,\n+    public ada_resolvable\n {\n public:\n \n@@ -402,6 +437,12 @@ class ada_funcall_operation\n \t\t   struct expression *exp,\n \t\t   enum noside noside) override;\n \n+  bool resolve (struct expression *exp,\n+\t\tbool deprocedure_p,\n+\t\tbool parse_completion,\n+\t\tinnermost_block_tracker *tracker,\n+\t\tstruct type *context_type) override;\n+\n   enum exp_opcode opcode () const override\n   { return OP_FUNCALL; }\n };"
    },
    {
      "sha": "261c9176b626339bf32b204c382bfc7397a6670b",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8a4ed8ad1b5d93b78efbd635d41f706902e2379/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d8a4ed8ad1b5d93b78efbd635d41f706902e2379",
      "patch": "@@ -10694,6 +10694,31 @@ ada_var_value_operation::evaluate (struct type *expect_type,\n   return ada_to_fixed_value (arg1);\n }\n \n+bool\n+ada_var_value_operation::resolve (struct expression *exp,\n+\t\t\t\t  bool deprocedure_p,\n+\t\t\t\t  bool parse_completion,\n+\t\t\t\t  innermost_block_tracker *tracker,\n+\t\t\t\t  struct type *context_type)\n+{\n+  symbol *sym = std::get<0> (m_storage);\n+  if (SYMBOL_DOMAIN (sym) == UNDEF_DOMAIN)\n+    {\n+      block_symbol resolved\n+\t= ada_resolve_variable (sym, std::get<1> (m_storage),\n+\t\t\t\tcontext_type, parse_completion,\n+\t\t\t\tdeprocedure_p, tracker);\n+      std::get<0> (m_storage) = resolved.symbol;\n+      std::get<1> (m_storage) = resolved.block;\n+    }\n+\n+  if (deprocedure_p\n+      && SYMBOL_TYPE (std::get<0> (m_storage))->code () == TYPE_CODE_FUNC)\n+    return true;\n+\n+  return false;\n+}\n+\n value *\n ada_atr_val_operation::evaluate (struct type *expect_type,\n \t\t\t\t struct expression *exp,\n@@ -10972,6 +10997,60 @@ ada_funcall_operation::evaluate (struct type *expect_type,\n     }\n }\n \n+bool\n+ada_funcall_operation::resolve (struct expression *exp,\n+\t\t\t\tbool deprocedure_p,\n+\t\t\t\tbool parse_completion,\n+\t\t\t\tinnermost_block_tracker *tracker,\n+\t\t\t\tstruct type *context_type)\n+{\n+  operation_up &callee_op = std::get<0> (m_storage);\n+\n+  ada_var_value_operation *avv\n+    = dynamic_cast<ada_var_value_operation *> (callee_op.get ());\n+  if (avv == nullptr)\n+    return false;\n+\n+  symbol *sym = avv->get_symbol ();\n+  if (SYMBOL_DOMAIN (sym) != UNDEF_DOMAIN)\n+    return false;\n+\n+  const std::vector<operation_up> &args_up = std::get<1> (m_storage);\n+  int nargs = args_up.size ();\n+  std::vector<value *> argvec (nargs);\n+\n+  for (int i = 0; i < args_up.size (); ++i)\n+    argvec[i] = args_up[i]->evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n+\n+  const block *block = avv->get_block ();\n+  block_symbol resolved\n+    = ada_resolve_funcall (sym, block,\n+\t\t\t   context_type, parse_completion,\n+\t\t\t   nargs, argvec.data (),\n+\t\t\t   tracker);\n+\n+  std::get<0> (m_storage)\n+    = make_operation<ada_var_value_operation> (resolved.symbol,\n+\t\t\t\t\t       resolved.block);\n+  return false;\n+}\n+\n+bool\n+ada_ternop_slice_operation::resolve (struct expression *exp,\n+\t\t\t\t     bool deprocedure_p,\n+\t\t\t\t     bool parse_completion,\n+\t\t\t\t     innermost_block_tracker *tracker,\n+\t\t\t\t     struct type *context_type)\n+{\n+  /* Historically this check was done during resolution, so we\n+     continue that here.  */\n+  value *v = std::get<0> (m_storage)->evaluate (context_type, exp,\n+\t\t\t\t\t\tEVAL_AVOID_SIDE_EFFECTS);\n+  if (ada_is_any_packed_array_type (value_type (v)))\n+    error (_(\"cannot slice a packed array\"));\n+  return false;\n+}\n+\n }\n \n /* Implement the evaluate_exp routine in the exp_descriptor structure"
    }
  ]
}