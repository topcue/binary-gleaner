{
  "sha": "2c78e92523a650c9cbd68130ce8a766570457cd6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmM3OGU5MjUyM2E2NTBjOWNiZDY4MTMwY2U4YTc2NjU3MDQ1N2NkNg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:04Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:11Z"
    },
    "message": "libctf, include: CTF-archive-wide symbol lookup\n\nCTF archives may contain multiple dicts, each of which contain many\ntypes and possibly a bunch of symtypetab entries relating to those\ntypes: each symtypetab entry is going to appear in exactly one dict,\nwith the corresponding entries in the other dicts empty (either pads, or\nindexed symtypetabs that do not mention that symbol).  But users of\nlibctf usually want to get back the type associated with a symbol\nwithout having to dig around to find out which dict that type might be\nin.\n\nThis adds machinery to do that -- and since you probably want to do it\nrepeatedly, it adds internal caching to the ctf-archive machinery so\nthat iteration over archives via ctf_archive_next and repeated symbol\nlookups do not have to repeatedly reopen the archive.  (Iteration using\nctf_archive_iter will gain caching soon.)\n\nTwo new API functions:\n\nctf_dict_t *\nctf_arc_lookup_symbol (ctf_archive_t *arc, unsigned long symidx,\n\t\t       ctf_id_t *typep, int *errp);\n\nThis looks up the symbol with index SYMIDX in the archive ARC, returning\nthe dictionary in which it resides and optionally the type index as\nwell.  Errors are returned in ERRP.  The dict should be\nctf_dict_close()d when done, but is also cached inside the ctf_archive\nso that the open cost is only paid once.  The result of the symbol\nlookup is also cached internally, so repeated lookups of the same symbol\nare nearly free.\n\nvoid ctf_arc_flush_caches (ctf_archive_t *arc);\n\nFlush all the caches. Done at close time, but also available as an API\nfunction if users want to do it by hand.\n\ninclude/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (ctf_arc_lookup_symbol): New.\n\t(ctf_arc_flush_caches): Likewise.\n\t* ctf.h: Document new auto-ctf_import behaviour.\n\nlibctf/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (struct ctf_archive_internal) <ctfi_dicts>: New, dicts\n\tthe archive machinery has opened and cached.\n\t<ctfi_symdicts>: New, cache of dicts containing symbols looked up.\n\t<ctfi_syms>: New, cache of types of symbols looked up.\n\t* ctf-archive.c (ctf_arc_close): Free them on close.\n\t(enosym): New, flag entry for 'symbol not present'.\n\t(ctf_arc_import_parent): New, automatically import the parent from\n\t\".ctf\" if this is a child in an archive and \".ctf\" is present.\n\t(ctf_dict_open_sections): Use it.\n\t(ctf_archive_iter_internal): Likewise.\n\t(ctf_cached_dict_close): New, thunk around ctf_dict_close.\n\t(ctf_dict_open_cached): New, open and cache a dict.\n\t(ctf_arc_flush_caches): New, flush the caches.\n\t(ctf_arc_lookup_symbol): New, look up a symbol in (all members of)\n\tan archive, and cache the lookup.\n\t(ctf_archive_iter): Note the new caching behaviour.\n\t(ctf_archive_next): Use ctf_dict_open_cached.\n\t* libctf.ver: Add ctf_arc_lookup_symbol and ctf_arc_flush_caches.",
    "tree": {
      "sha": "6733095bc7e3c14c32cebda4235f3756123e7e7a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6733095bc7e3c14c32cebda4235f3756123e7e7a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2c78e92523a650c9cbd68130ce8a766570457cd6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c78e92523a650c9cbd68130ce8a766570457cd6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2c78e92523a650c9cbd68130ce8a766570457cd6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c78e92523a650c9cbd68130ce8a766570457cd6/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0e28ade476e20bd8af917e01a3f1429a34cc1d83",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0e28ade476e20bd8af917e01a3f1429a34cc1d83",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0e28ade476e20bd8af917e01a3f1429a34cc1d83"
    }
  ],
  "stats": {
    "total": 293,
    "additions": 275,
    "deletions": 18
  },
  "files": [
    {
      "sha": "1d4eac95ad6ae6ad328567809915e682afbfbca8",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -1,3 +1,9 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_arc_lookup_symbol): New.\n+\t(ctf_arc_flush_caches): Likewise.\n+\t* ctf.h: Document new auto-ctf_import behaviour.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_symbol_next): New."
    },
    {
      "sha": "f0c00c01a89cf08d72dd94c18172d4b368af72ea",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -109,7 +109,9 @@ typedef enum ctf_sect_names\n    CTF_SECT_HEADER,\n    CTF_SECT_LABEL,\n    CTF_SECT_OBJT,\n+   CTF_SECT_OBJTIDX = CTF_SECT_OBJT,\n    CTF_SECT_FUNC,\n+   CTF_SECT_FUNCIDX = CTF_SECT_FUNC,\n    CTF_SECT_VAR,\n    CTF_SECT_TYPE,\n    CTF_SECT_STR\n@@ -312,6 +314,10 @@ extern ctf_archive_t *ctf_arc_bufopen (const ctf_sect_t *,\n \t\t\t\t       const ctf_sect_t *,\n \t\t\t\t       int *);\n extern void ctf_arc_close (ctf_archive_t *);\n+extern ctf_dict_t *ctf_arc_lookup_symbol (ctf_archive_t *,\n+\t\t\t\t\t  unsigned long symidx,\n+\t\t\t\t\t  ctf_id_t *, int *errp);\n+extern void ctf_arc_flush_caches (ctf_archive_t *);\n extern ctf_dict_t *ctf_dict_open (const ctf_archive_t *,\n \t\t\t\t  const char *, int *);\n extern ctf_dict_t *ctf_dict_open_sections (const ctf_archive_t *,"
    },
    {
      "sha": "08002875bf91cf21bb6b5e4c95be8131ee05b27d",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -116,9 +116,12 @@ extern \"C\"\n    and libctf library are responsible for connecting the appropriate objects\n    together so that the full set of types can be explored and manipulated.\n \n-   This connection is done purely using the ctf_import() function.  There is no\n-   notation anywhere in the child CTF file indicating which parent it is\n-   connected to: it is the debugger's responsibility to track this.  */\n+   This connection is done purely using the ctf_import() function.  The\n+   ctf_archive machinery (and thus ctf_open et al) automatically imports archive\n+   members named \".ctf\" into child dicts if available in the same archive, to\n+   match the relationship set up by the linker, but callers can call ctf_import\n+   themselves as well if need be, if they know a different relationship is in\n+   force.  */\n \n #define CTF_MAX_TYPE\t0xfffffffe\t/* Max type identifier value.  */\n #define CTF_MAX_PTYPE\t0x7fffffff\t/* Max parent type identifier value.  */"
    },
    {
      "sha": "deca027786dc7b028aa1b703ef189968ba6b3937",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -1,3 +1,24 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (struct ctf_archive_internal) <ctfi_dicts>: New, dicts\n+\tthe archive machinery has opened and cached.\n+\t<ctfi_symdicts>: New, cache of dicts containing symbols looked up.\n+\t<ctfi_syms>: New, cache of types of symbols looked up.\n+\t* ctf-archive.c (ctf_arc_close): Free them on close.\n+\t(enosym): New, flag entry for 'symbol not present'.\n+\t(ctf_arc_import_parent): New, automatically import the parent from\n+\t\".ctf\" if this is a child in an archive and \".ctf\" is present.\n+\t(ctf_dict_open_sections): Use it.\n+\t(ctf_archive_iter_internal): Likewise.\n+\t(ctf_cached_dict_close): New, thunk around ctf_dict_close.\n+\t(ctf_dict_open_cached): New, open and cache a dict.\n+\t(ctf_arc_flush_caches): New, flush the caches.\n+\t(ctf_arc_lookup_symbol): New, look up a symbol in (all members of)\n+\tan archive, and cache the lookup.\n+\t(ctf_archive_iter): Note the new caching behaviour.\n+\t(ctf_archive_next): Use ctf_dict_open_cached.\n+\t* libctf.ver: Add ctf_arc_lookup_symbol and ctf_arc_flush_caches.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-dedup.c (ctf_dedup_rhash_type): Null out the names of nameless"
    },
    {
      "sha": "dc312d3fd68367d24d7c8405efbc04a7ae240dc2",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 229,
      "deletions": 14,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -43,6 +43,11 @@ static void *arc_mmap_file (int fd, size_t size);\n static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n \t\t\t      const char **errmsg);\n static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);\n+static void ctf_arc_import_parent (const ctf_archive_t *arc, ctf_dict_t *fp);\n+\n+/* Flag to indicate \"symbol not present\" in\n+   ctf_archive_internal.ctfi_symdicts.  Never initialized.  */\n+static ctf_dict_t enosym;\n \n /* Write out a CTF archive to the start of the file referenced by the passed-in\n    fd.  The entries in CTF_DICTS are referenced by name: the names are passed in\n@@ -512,6 +517,9 @@ ctf_arc_close (ctf_archive_t *arc)\n     }\n   else\n     ctf_dict_close (arc->ctfi_dict);\n+  free (arc->ctfi_syms);\n+  free (arc->ctfi_symdicts);\n+  ctf_dynhash_destroy (arc->ctfi_dicts);\n   if (arc->ctfi_free_symsect)\n     free ((void *) arc->ctfi_symsect.cts_data);\n   if (arc->ctfi_free_strsect)\n@@ -578,7 +586,10 @@ ctf_dict_open_sections (const ctf_archive_t *arc,\n       ret = ctf_dict_open_internal (arc->ctfi_archive, symsect, strsect,\n \t\t\t\t    name, errp);\n       if (ret)\n-\tret->ctf_archive = (ctf_archive_t *) arc;\n+\t{\n+\t  ret->ctf_archive = (ctf_archive_t *) arc;\n+\t  ctf_arc_import_parent (arc, ret);\n+\t}\n       return ret;\n     }\n \n@@ -613,6 +624,67 @@ ctf_dict_open (const ctf_archive_t *arc, const char *name, int *errp)\n   return ctf_dict_open_sections (arc, symsect, strsect, name, errp);\n }\n \n+static void\n+ctf_cached_dict_close (void *fp)\n+{\n+  ctf_dict_close ((ctf_dict_t *) fp);\n+}\n+\n+/* Return the ctf_dict_t with the given name and cache it in the\n+   archive's ctfi_dicts.  */\n+static ctf_dict_t *\n+ctf_dict_open_cached (ctf_archive_t *arc, const char *name, int *errp)\n+{\n+  ctf_dict_t *fp;\n+  char *dupname;\n+\n+  /* Just return from the cache if possible.  */\n+  if (arc->ctfi_dicts\n+      && ((fp = ctf_dynhash_lookup (arc->ctfi_dicts, name)) != NULL))\n+    {\n+      fp->ctf_refcnt++;\n+      return fp;\n+    }\n+\n+  /* Not yet cached: open it.  */\n+  fp = ctf_dict_open (arc, name, errp);\n+  dupname = strdup (name);\n+\n+  if (!fp || !dupname)\n+    goto oom;\n+\n+  if (arc->ctfi_dicts == NULL)\n+    if ((arc->ctfi_dicts\n+\t = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t       free, ctf_cached_dict_close)) == NULL)\n+      goto oom;\n+\n+  if (ctf_dynhash_insert (arc->ctfi_dicts, dupname, fp) < 0)\n+    goto oom;\n+  fp->ctf_refcnt++;\n+\n+  return fp;\n+\n+ oom:\n+  ctf_dict_close (fp);\n+  free (dupname);\n+  if (errp)\n+    *errp = ENOMEM;\n+  return NULL;\n+}\n+\n+/* Flush any caches the CTF archive may have open.  */\n+void\n+ctf_arc_flush_caches (ctf_archive_t *wrapper)\n+{\n+  free (wrapper->ctfi_symdicts);\n+  free (wrapper->ctfi_syms);\n+  ctf_dynhash_destroy (wrapper->ctfi_dicts);\n+  wrapper->ctfi_symdicts = NULL;\n+  wrapper->ctfi_syms = NULL;\n+  wrapper->ctfi_dicts = NULL;\n+}\n+\n /* Return the ctf_dict_t at the given ctfa_ctfs-relative offset, or NULL if\n    none, setting 'err' if non-NULL.  */\n static ctf_dict_t *\n@@ -658,6 +730,25 @@ ctf_arc_open_by_name_sections (const ctf_archive_t *arc,\n   return ctf_dict_open_sections (arc, symsect, strsect, name, errp);\n }\n \n+/* Import the parent into a ctf archive, if this is a child, the parent is not\n+   already set, and a suitable archive member exists.  No error is raised if\n+   this is not possible: this is just a best-effort helper operation to give\n+   people useful dicts to start with.  */\n+static void\n+ctf_arc_import_parent (const ctf_archive_t *arc, ctf_dict_t *fp)\n+{\n+  if ((fp->ctf_flags & LCTF_CHILD) && fp->ctf_parname && !fp->ctf_parent)\n+    {\n+      ctf_dict_t *parent = ctf_dict_open_cached ((ctf_archive_t *) arc,\n+\t\t\t\t\t\t fp->ctf_parname, NULL);\n+      if (parent)\n+\t{\n+\t  ctf_import (fp, parent);\n+\t  ctf_dict_close (parent);\n+\t}\n+    }\n+}\n+\n /* Return the number of members in an archive.  */\n size_t\n ctf_archive_count (const ctf_archive_t *wrapper)\n@@ -668,6 +759,139 @@ ctf_archive_count (const ctf_archive_t *wrapper)\n   return wrapper->ctfi_archive->ctfa_ndicts;\n }\n \n+/* Look up a symbol in an archive.  Return the dict in the archive that the\n+   symbol is found in, and (optionally) the ctf_id_t of the symbol in that dict\n+   (so you don't have to look it up yourself).  The dict and mapping are both\n+   cached, so repeated lookups are nearly free.\n+\n+   As usual, you should ctf_dict_close() the returned dict once you are done\n+   with it.\n+\n+   Returns NULL on error, and an error in errp (if set).  */\n+\n+ctf_dict_t *\n+ctf_arc_lookup_symbol (ctf_archive_t *wrapper, unsigned long symidx,\n+\t\t       ctf_id_t *typep, int *errp)\n+{\n+  ctf_dict_t *fp;\n+  ctf_id_t type;\n+\n+  /* The usual non-archive-transparent-wrapper special case.  */\n+  if (!wrapper->ctfi_is_archive)\n+    {\n+      if ((type = ctf_lookup_by_symbol (wrapper->ctfi_dict, symidx)) == CTF_ERR)\n+\t{\n+\t  if (errp)\n+\t    *errp = ctf_errno (wrapper->ctfi_dict);\n+\t  return NULL;\n+\t}\n+      if (typep)\n+\t*typep = type;\n+      wrapper->ctfi_dict->ctf_refcnt++;\n+      return wrapper->ctfi_dict;\n+    }\n+\n+  if (wrapper->ctfi_symsect.cts_name == NULL\n+      || wrapper->ctfi_symsect.cts_data == NULL\n+      || wrapper->ctfi_symsect.cts_size == 0\n+      || wrapper->ctfi_symsect.cts_entsize == 0)\n+    {\n+      if (errp)\n+\t*errp = ECTF_NOSYMTAB;\n+      return NULL;\n+    }\n+\n+  /* Make enough space for all possible symbols, if not already done.\n+     We cache both the ctf_id_t and the originating dictionary of all symbols.\n+     The dict links are weak, to the dictionaries cached in ctfi_dicts: their\n+     refcnts are *not* bumped.  */\n+\n+  if (!wrapper->ctfi_syms)\n+    {\n+      if ((wrapper->ctfi_syms = calloc (wrapper->ctfi_symsect.cts_size\n+\t\t\t\t\t/ wrapper->ctfi_symsect.cts_entsize,\n+\t\t\t\t\tsizeof (ctf_id_t))) == NULL)\n+\t{\n+\t  if (errp)\n+\t    *errp = ENOMEM;\n+\t  return NULL;\n+\t}\n+    }\n+  if (!wrapper->ctfi_symdicts)\n+    {\n+      if ((wrapper->ctfi_symdicts = calloc (wrapper->ctfi_symsect.cts_size\n+\t\t\t\t\t    / wrapper->ctfi_symsect.cts_entsize,\n+\t\t\t\t\t    sizeof (ctf_dict_t *))) == NULL)\n+\t{\n+\t  if (errp)\n+\t    *errp = ENOMEM;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  /* Perhaps it's cached.  */\n+  if (wrapper->ctfi_symdicts[symidx] != NULL)\n+    {\n+      if (wrapper->ctfi_symdicts[symidx] == &enosym)\n+\t{\n+\t  if (errp)\n+\t    *errp = ECTF_NOTYPEDAT;\n+\t  if (typep)\n+\t    *typep = CTF_ERR;\n+\t  return NULL;\n+\t}\n+\n+      if (typep)\n+\t*typep = wrapper->ctfi_syms[symidx];\n+      wrapper->ctfi_symdicts[symidx]->ctf_refcnt++;\n+      return wrapper->ctfi_symdicts[symidx];\n+    }\n+\n+  /* Not cached: find it and cache it.  We must track open errors ourselves even\n+     if our caller doesn't, to be able to distinguish no-error end-of-iteration\n+     from open errors.  */\n+\n+  int local_err;\n+  int *local_errp;\n+  ctf_next_t *i = NULL;\n+  const char *name;\n+\n+  if (errp)\n+    local_errp = errp;\n+  else\n+    local_errp = &local_err;\n+\n+  while ((fp = ctf_archive_next (wrapper, &i, &name, 0, local_errp)) != NULL)\n+    {\n+      if ((type = ctf_lookup_by_symbol (fp, symidx)) != CTF_ERR)\n+\t{\n+\t  wrapper->ctfi_syms[symidx] = type;\n+\t  wrapper->ctfi_symdicts[symidx] = fp;\n+\t  ctf_next_destroy (i);\n+\n+\t  if (typep)\n+\t    *typep = type;\n+\t  return fp;\n+\t}\n+      ctf_dict_close (fp);\n+    }\n+  if (*local_errp != ECTF_NEXT_END)\n+    {\n+      ctf_next_destroy (i);\n+      return NULL;\n+    }\n+  /* Don't leak end-of-iteration to the caller.  */\n+  *local_errp = 0;\n+\n+  wrapper->ctfi_symdicts[symidx] = &enosym;\n+\n+  if (errp)\n+    *errp = ECTF_NOTYPEDAT;\n+  if (typep)\n+    *typep = CTF_ERR;\n+  return NULL;\n+}\n+\n /* Raw iteration over all CTF files in an archive.  We pass the raw data for all\n    CTF files in turn to the specified callback function.  */\n static int\n@@ -741,6 +965,7 @@ ctf_archive_iter_internal (const ctf_archive_t *wrapper,\n \treturn rc;\n \n       f->ctf_archive = (ctf_archive_t *) wrapper;\n+      ctf_arc_import_parent (wrapper, f);\n       if ((rc = func (f, name, data)) != 0)\n \t{\n \t  ctf_dict_close (f);\n@@ -779,6 +1004,8 @@ ctf_archive_iter (const ctf_archive_t *arc, ctf_archive_member_f *func,\n    whether they are skipped or not, the caller must ctf_import the parent if\n    need be.\n \n+   The archive member is cached for rapid return on future calls.\n+\n    We identify parents by name rather than by flag value: for now, with the\n    linker only emitting parents named _CTF_SECTION, this works well enough.  */\n \n@@ -841,9 +1068,6 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n      is the parent (i.e. at most two iterations, but possibly an early return if\n      *all* we have is a parent).  */\n \n-  const ctf_sect_t *symsect;\n-  const ctf_sect_t *strsect;\n-\n   do\n     {\n       if ((!wrapper->ctfi_is_archive) || (i->ctn_n >= le64toh (arc->ctfa_ndicts)))\n@@ -855,14 +1079,6 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n \t  return NULL;\n \t}\n \n-      symsect = &wrapper->ctfi_symsect;\n-      strsect = &wrapper->ctfi_strsect;\n-\n-      if (symsect->cts_name == NULL)\n-\tsymsect = NULL;\n-      if (strsect->cts_name == NULL)\n-\tstrsect = NULL;\n-\n       modent = (ctf_archive_modent_t *) ((char *) arc\n \t\t\t\t\t + sizeof (struct ctf_archive));\n       nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n@@ -874,8 +1090,7 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n   if (name)\n     *name = name_;\n \n-  f = ctf_dict_open_internal (arc, symsect, strsect, name_, errp);\n-  f->ctf_archive = (ctf_archive_t *) wrapper;\n+  f = ctf_dict_open_cached ((ctf_archive_t *) wrapper, name_, errp);\n   return f;\n }\n "
    },
    {
      "sha": "a9f7245ae2d6a57bfe05334cdb051b8f38fab131",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -502,12 +502,15 @@ struct ctf_archive_internal\n   int ctfi_unmap_on_close;\n   ctf_dict_t *ctfi_dict;\n   struct ctf_archive *ctfi_archive;\n+  ctf_dynhash_t *ctfi_dicts;\t  /* Dicts we have opened and cached.  */\n+  ctf_dict_t **ctfi_symdicts;\t  /* Array of index -> ctf_dict_t *.  */\n+  ctf_id_t *ctfi_syms;\t\t  /* Array of index -> ctf_id_t.  */\n   ctf_sect_t ctfi_symsect;\n   ctf_sect_t ctfi_strsect;\n   int ctfi_free_symsect;\n   int ctfi_free_strsect;\n   void *ctfi_data;\n-  bfd *ctfi_abfd;\t\t    /* Optional source of section data.  */\n+  bfd *ctfi_abfd;\t\t  /* Optional source of section data.  */\n   void (*ctfi_bfd_close) (struct ctf_archive_internal *);\n };\n "
    },
    {
      "sha": "f0633f26c4cd688bcae4ca7b7025c5e96b97f66d",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c78e92523a650c9cbd68130ce8a766570457cd6/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=2c78e92523a650c9cbd68130ce8a766570457cd6",
      "patch": "@@ -187,4 +187,7 @@ LIBCTF_1.1 {\n \tctf_add_func_sym;\n \n \tctf_link_add_linker_symbol;\n+\n+\tctf_arc_lookup_symbol;\n+\tctf_arc_flush_caches;\n } LIBCTF_1.0;"
    }
  ]
}