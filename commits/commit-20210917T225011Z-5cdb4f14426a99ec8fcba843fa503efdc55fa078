{
  "sha": "5cdb4f14426a99ec8fcba843fa503efdc55fa078",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWNkYjRmMTQ0MjZhOTllYzhmY2JhODQzZmE1MDNlZmRjNTVmYTA3OA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-26T02:47:51Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-09-17T22:50:11Z"
    },
    "message": "[GOLD] PowerPC64 support for sym+addend GOT entries\n\nPass addends to all the GOT handling functions, plus remove some\nextraneous asserts.\n\n\tPR 28192\n\t* powerpc.cc (Output_data_got_powerpc): Add addend parameter to\n\tall methods creating got entries.\n\t(Target_powerpc::Scan::local): Pass reloc addend to got handling\n\tfunctions, and when creating dynamic got relocations.\n\t(Target_powerpc::Scan::global): Likewise.\n\t(Target_powerpc::Relocate::relocate): Likewise.  Remove extraneous\n\tassertions.",
    "tree": {
      "sha": "a3f47ff28cc2d40165b4f61a2e06cebe919990b1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a3f47ff28cc2d40165b4f61a2e06cebe919990b1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5cdb4f14426a99ec8fcba843fa503efdc55fa078",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5cdb4f14426a99ec8fcba843fa503efdc55fa078",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5cdb4f14426a99ec8fcba843fa503efdc55fa078",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5cdb4f14426a99ec8fcba843fa503efdc55fa078/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e4d49a0f908415edb7a7e718ef2008a96dd43f9b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e4d49a0f908415edb7a7e718ef2008a96dd43f9b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e4d49a0f908415edb7a7e718ef2008a96dd43f9b"
    }
  ],
  "stats": {
    "total": 148,
    "additions": 74,
    "deletions": 74
  },
  "files": [
    {
      "sha": "0cee975f8bd573abe532fd513106ee73480606f3",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 74,
      "deletions": 74,
      "changes": 148,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cdb4f14426a99ec8fcba843fa503efdc55fa078/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cdb4f14426a99ec8fcba843fa503efdc55fa078/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=5cdb4f14426a99ec8fcba843fa503efdc55fa078",
      "patch": "@@ -2970,77 +2970,85 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n   // Override all the Output_data_got methods we use so as to first call\n   // reserve_ent().\n   bool\n-  add_global(Symbol* gsym, unsigned int got_type)\n+  add_global(Symbol* gsym, unsigned int got_type, uint64_t addend)\n   {\n     this->reserve_ent();\n-    return Output_data_got<size, big_endian>::add_global(gsym, got_type);\n+    return Output_data_got<size, big_endian>::add_global(gsym, got_type,\n+\t\t\t\t\t\t\t addend);\n   }\n \n   bool\n-  add_global_plt(Symbol* gsym, unsigned int got_type)\n+  add_global_plt(Symbol* gsym, unsigned int got_type, uint64_t addend)\n   {\n     this->reserve_ent();\n-    return Output_data_got<size, big_endian>::add_global_plt(gsym, got_type);\n+    return Output_data_got<size, big_endian>::add_global_plt(gsym, got_type,\n+\t\t\t\t\t\t\t     addend);\n   }\n \n   bool\n-  add_global_tls(Symbol* gsym, unsigned int got_type)\n-  { return this->add_global_plt(gsym, got_type); }\n+  add_global_tls(Symbol* gsym, unsigned int got_type, uint64_t addend)\n+  { return this->add_global_plt(gsym, got_type, addend); }\n \n   void\n   add_global_with_rel(Symbol* gsym, unsigned int got_type,\n-\t\t      Output_data_reloc_generic* rel_dyn, unsigned int r_type)\n+\t\t      Output_data_reloc_generic* rel_dyn,\n+\t\t      unsigned int r_type, uint64_t addend)\n   {\n     this->reserve_ent();\n     Output_data_got<size, big_endian>::\n-      add_global_with_rel(gsym, got_type, rel_dyn, r_type);\n+      add_global_with_rel(gsym, got_type, rel_dyn, r_type, addend);\n   }\n \n   void\n   add_global_pair_with_rel(Symbol* gsym, unsigned int got_type,\n \t\t\t   Output_data_reloc_generic* rel_dyn,\n-\t\t\t   unsigned int r_type_1, unsigned int r_type_2)\n+\t\t\t   unsigned int r_type_1, unsigned int r_type_2,\n+\t\t\t   uint64_t addend)\n   {\n     if (gsym->has_got_offset(got_type))\n       return;\n \n     this->reserve_ent(2);\n     Output_data_got<size, big_endian>::\n-      add_global_pair_with_rel(gsym, got_type, rel_dyn, r_type_1, r_type_2);\n+      add_global_pair_with_rel(gsym, got_type, rel_dyn, r_type_1, r_type_2,\n+\t\t\t       addend);\n   }\n \n   bool\n-  add_local(Relobj* object, unsigned int sym_index, unsigned int got_type)\n+  add_local(Relobj* object, unsigned int sym_index, unsigned int got_type,\n+\t    uint64_t addend)\n   {\n     this->reserve_ent();\n     return Output_data_got<size, big_endian>::add_local(object, sym_index,\n-\t\t\t\t\t\t\tgot_type);\n+\t\t\t\t\t\t\tgot_type, addend);\n   }\n \n   bool\n-  add_local_plt(Relobj* object, unsigned int sym_index, unsigned int got_type)\n+  add_local_plt(Relobj* object, unsigned int sym_index,\n+\t\tunsigned int got_type, uint64_t addend)\n   {\n     this->reserve_ent();\n     return Output_data_got<size, big_endian>::add_local_plt(object, sym_index,\n-\t\t\t\t\t\t\t    got_type);\n+\t\t\t\t\t\t\t    got_type, addend);\n   }\n \n   bool\n-  add_local_tls(Relobj* object, unsigned int sym_index, unsigned int got_type)\n-  { return this->add_local_plt(object, sym_index, got_type); }\n+  add_local_tls(Relobj* object, unsigned int sym_index,\n+\t\tunsigned int got_type, uint64_t addend)\n+  { return this->add_local_plt(object, sym_index, got_type, addend); }\n \n   void\n   add_local_tls_pair(Relobj* object, unsigned int sym_index,\n \t\t     unsigned int got_type,\n \t\t     Output_data_reloc_generic* rel_dyn,\n-\t\t     unsigned int r_type)\n+\t\t     unsigned int r_type, uint64_t addend)\n   {\n-    if (object->local_has_got_offset(sym_index, got_type))\n+    if (object->local_has_got_offset(sym_index, got_type, addend))\n       return;\n \n     this->reserve_ent(2);\n     Output_data_got<size, big_endian>::\n-      add_local_tls_pair(object, sym_index, got_type, rel_dyn, r_type);\n+      add_local_tls_pair(object, sym_index, got_type, rel_dyn, r_type, addend);\n   }\n \n   unsigned int\n@@ -8195,29 +8203,30 @@ Target_powerpc<size, big_endian>::Scan::local(\n \tOutput_data_got_powerpc<size, big_endian>* got\n \t  = target->got_section(symtab, layout);\n \tunsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n+\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \n \tif (!parameters->options().output_is_position_independent())\n \t  {\n \t    if (is_ifunc\n \t\t&& (size == 32 || target->abiversion() >= 2))\n-\t      got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD);\n+\t      got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD, addend);\n \t    else\n-\t      got->add_local(object, r_sym, GOT_TYPE_STANDARD);\n+\t      got->add_local(object, r_sym, GOT_TYPE_STANDARD, addend);\n \t  }\n-\telse if (!object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD))\n+\telse if (!object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD, addend))\n \t  {\n \t    // If we are generating a shared object or a pie, this\n \t    // symbol's GOT entry will be set by a dynamic relocation.\n \t    unsigned int off;\n \t    off = got->add_constant(0);\n-\t    object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off);\n+\t    object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off, addend);\n \n \t    Reloc_section* rela_dyn = target->rela_dyn_section(symtab, layout,\n \t\t\t\t\t\t\t       is_ifunc);\n \t    unsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE\n \t\t\t\t   : elfcpp::R_POWERPC_RELATIVE);\n \t    rela_dyn->add_local_relative(object, r_sym, dynrel,\n-\t\t\t\t\t got, off, 0, false);\n+\t\t\t\t\t got, off, addend, false);\n \t  }\n       }\n       break;\n@@ -8246,9 +8255,11 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t    Output_data_got_powerpc<size, big_endian>* got\n \t      = target->got_section(symtab, layout);\n \t    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n+\t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t    got->add_local_tls_pair(object, r_sym, GOT_TYPE_TLSGD,\n-\t\t\t\t    rela_dyn, elfcpp::R_POWERPC_DTPMOD);\n+\t\t\t\t    rela_dyn, elfcpp::R_POWERPC_DTPMOD,\n+\t\t\t\t    addend);\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n \t  {\n@@ -8296,7 +8307,8 @@ Target_powerpc<size, big_endian>::Scan::local(\n \tOutput_data_got_powerpc<size, big_endian>* got\n \t  = target->got_section(symtab, layout);\n \tunsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n-\tgot->add_local_tls(object, r_sym, GOT_TYPE_DTPREL);\n+\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n+\tgot->add_local_tls(object, r_sym, GOT_TYPE_DTPREL, addend);\n       }\n       break;\n \n@@ -8310,17 +8322,18 @@ Target_powerpc<size, big_endian>::Scan::local(\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n-\t    if (!object->local_has_got_offset(r_sym, GOT_TYPE_TPREL))\n+\t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n+\t    if (!object->local_has_got_offset(r_sym, GOT_TYPE_TPREL, addend))\n \t      {\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n \t\t  = target->got_section(symtab, layout);\n \t\tunsigned int off = got->add_constant(0);\n-\t\tobject->set_local_got_offset(r_sym, GOT_TYPE_TPREL, off);\n+\t\tobject->set_local_got_offset(r_sym, GOT_TYPE_TPREL, off, addend);\n \n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t\trela_dyn->add_symbolless_local_addend(object, r_sym,\n \t\t\t\t\t\t      elfcpp::R_POWERPC_TPREL,\n-\t\t\t\t\t\t      got, off, 0);\n+\t\t\t\t\t\t      got, off, addend);\n \t      }\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n@@ -8980,22 +8993,23 @@ Target_powerpc<size, big_endian>::Scan::global(\n       {\n \t// The symbol requires a GOT entry.\n \tOutput_data_got_powerpc<size, big_endian>* got;\n+\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \n \tgot = target->got_section(symtab, layout);\n \tif (gsym->final_value_is_known())\n \t  {\n \t    if (is_ifunc\n \t\t&& (size == 32 || target->abiversion() >= 2))\n-\t      got->add_global_plt(gsym, GOT_TYPE_STANDARD);\n+\t      got->add_global_plt(gsym, GOT_TYPE_STANDARD, addend);\n \t    else\n-\t      got->add_global(gsym, GOT_TYPE_STANDARD);\n+\t      got->add_global(gsym, GOT_TYPE_STANDARD, addend);\n \t  }\n-\telse if (!gsym->has_got_offset(GOT_TYPE_STANDARD))\n+\telse if (!gsym->has_got_offset(GOT_TYPE_STANDARD, addend))\n \t  {\n \t    // If we are generating a shared object or a pie, this\n \t    // symbol's GOT entry will be set by a dynamic relocation.\n \t    unsigned int off = got->add_constant(0);\n-\t    gsym->set_got_offset(GOT_TYPE_STANDARD, off);\n+\t    gsym->set_got_offset(GOT_TYPE_STANDARD, off, addend);\n \n \t    Reloc_section* rela_dyn\n \t      = target->rela_dyn_section(symtab, layout, is_ifunc);\n@@ -9008,12 +9022,13 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t      {\n \t\tunsigned int dynrel = (is_ifunc ? elfcpp::R_POWERPC_IRELATIVE\n \t\t\t\t       : elfcpp::R_POWERPC_RELATIVE);\n-\t\trela_dyn->add_global_relative(gsym, dynrel, got, off, 0, false);\n+\t\trela_dyn->add_global_relative(gsym, dynrel, got, off,\n+\t\t\t\t\t      addend, false);\n \t      }\n \t    else\n \t      {\n \t\tunsigned int dynrel = elfcpp::R_POWERPC_GLOB_DAT;\n-\t\trela_dyn->add_global(gsym, dynrel, got, off, 0);\n+\t\trela_dyn->add_global(gsym, dynrel, got, off, addend);\n \t      }\n \t  }\n       }\n@@ -9046,9 +9061,11 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t    Output_data_got_powerpc<size, big_endian>* got\n \t      = target->got_section(symtab, layout);\n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n+\t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t    got->add_global_pair_with_rel(gsym, GOT_TYPE_TLSGD, rela_dyn,\n \t\t\t\t\t  elfcpp::R_POWERPC_DTPMOD,\n-\t\t\t\t\t  elfcpp::R_POWERPC_DTPREL);\n+\t\t\t\t\t  elfcpp::R_POWERPC_DTPREL,\n+\t\t\t\t\t  addend);\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_IE)\n \t  {\n@@ -9057,19 +9074,20 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n \t\t  = target->got_section(symtab, layout);\n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n+\t\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t\tif (gsym->is_undefined()\n \t\t    || gsym->is_from_dynobj())\n \t\t  {\n \t\t    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,\n-\t\t\t\t\t     elfcpp::R_POWERPC_TPREL);\n+\t\t\t\t\t     elfcpp::R_POWERPC_TPREL, addend);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    unsigned int off = got->add_constant(0);\n \t\t    gsym->set_got_offset(GOT_TYPE_TPREL, off);\n \t\t    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;\n \t\t    rela_dyn->add_symbolless_global_addend(gsym, dynrel,\n-\t\t\t\t\t\t\t   got, off, 0);\n+\t\t\t\t\t\t\t   got, off, addend);\n \t\t  }\n \t      }\n \t    ppc_object->set_tls_marker();\n@@ -9119,15 +9137,16 @@ Target_powerpc<size, big_endian>::Scan::global(\n       {\n \tOutput_data_got_powerpc<size, big_endian>* got\n \t  = target->got_section(symtab, layout);\n+\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \tif (!gsym->final_value_is_known()\n \t    && (gsym->is_from_dynobj()\n \t\t|| gsym->is_undefined()\n \t\t|| gsym->is_preemptible()))\n \t  got->add_global_with_rel(gsym, GOT_TYPE_DTPREL,\n \t\t\t\t   target->rela_dyn_section(layout),\n-\t\t\t\t   elfcpp::R_POWERPC_DTPREL);\n+\t\t\t\t   elfcpp::R_POWERPC_DTPREL, addend);\n \telse\n-\t  got->add_global_tls(gsym, GOT_TYPE_DTPREL);\n+\t  got->add_global_tls(gsym, GOT_TYPE_DTPREL, addend);\n       }\n       break;\n \n@@ -9146,19 +9165,20 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n \t\t  = target->got_section(symtab, layout);\n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n+\t\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t\tif (gsym->is_undefined()\n \t\t    || gsym->is_from_dynobj())\n \t\t  {\n \t\t    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,\n-\t\t\t\t\t     elfcpp::R_POWERPC_TPREL);\n+\t\t\t\t\t     elfcpp::R_POWERPC_TPREL, addend);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    unsigned int off = got->add_constant(0);\n \t\t    gsym->set_got_offset(GOT_TYPE_TPREL, off);\n \t\t    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;\n \t\t    rela_dyn->add_symbolless_global_addend(gsym, dynrel,\n-\t\t\t\t\t\t\t   got, off, 0);\n+\t\t\t\t\t\t\t   got, off, addend);\n \t\t  }\n \t      }\n \t  }\n@@ -10655,16 +10675,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     }\n   else if (is_got_reloc(r_type))\n     {\n+      uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n       if (gsym != NULL)\n-\t{\n-\t  gold_assert(gsym->has_got_offset(GOT_TYPE_STANDARD));\n-\t  value = gsym->got_offset(GOT_TYPE_STANDARD);\n-\t}\n+\tvalue = gsym->got_offset(GOT_TYPE_STANDARD, addend);\n       else\n-\t{\n-\t  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD));\n-\t  value = object->local_got_offset(r_sym, GOT_TYPE_STANDARD);\n-\t}\n+\tvalue = object->local_got_offset(r_sym, GOT_TYPE_STANDARD, addend);\n       if (r_type == elfcpp::R_PPC64_GOT_PCREL34)\n \tvalue += target->got_section()->address();\n       else\n@@ -10764,16 +10779,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \tgot_type = GOT_TYPE_TPREL;\n       if (got_type != GOT_TYPE_STANDARD)\n \t{\n+\t  uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n \t  if (gsym != NULL)\n-\t    {\n-\t      gold_assert(gsym->has_got_offset(got_type));\n-\t      value = gsym->got_offset(got_type);\n-\t    }\n+\t    value = gsym->got_offset(got_type, addend);\n \t  else\n-\t    {\n-\t      gold_assert(object->local_has_got_offset(r_sym, got_type));\n-\t      value = object->local_got_offset(r_sym, got_type);\n-\t    }\n+\t    value = object->local_got_offset(r_sym, got_type, addend);\n \t  if (r_type == elfcpp::R_PPC64_GOT_TLSGD_PCREL34)\n \t    value += target->got_section()->address();\n \t  else\n@@ -10920,16 +10930,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     {\n       // Accesses relative to a local dynamic sequence address,\n       // no optimisation here.\n+      uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n       if (gsym != NULL)\n-\t{\n-\t  gold_assert(gsym->has_got_offset(GOT_TYPE_DTPREL));\n-\t  value = gsym->got_offset(GOT_TYPE_DTPREL);\n-\t}\n+\tvalue = gsym->got_offset(GOT_TYPE_DTPREL, addend);\n       else\n-\t{\n-\t  gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_DTPREL));\n-\t  value = object->local_got_offset(r_sym, GOT_TYPE_DTPREL);\n-\t}\n+\tvalue = object->local_got_offset(r_sym, GOT_TYPE_DTPREL, addend);\n       if (r_type == elfcpp::R_PPC64_GOT_DTPREL_PCREL34)\n \tvalue += target->got_section()->address();\n       else\n@@ -10946,16 +10951,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       tls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n       if (tls_type == tls::TLSOPT_NONE)\n \t{\n+\t  uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n \t  if (gsym != NULL)\n-\t    {\n-\t      gold_assert(gsym->has_got_offset(GOT_TYPE_TPREL));\n-\t      value = gsym->got_offset(GOT_TYPE_TPREL);\n-\t    }\n+\t    value = gsym->got_offset(GOT_TYPE_TPREL, addend);\n \t  else\n-\t    {\n-\t      gold_assert(object->local_has_got_offset(r_sym, GOT_TYPE_TPREL));\n-\t      value = object->local_got_offset(r_sym, GOT_TYPE_TPREL);\n-\t    }\n+\t    value = object->local_got_offset(r_sym, GOT_TYPE_TPREL, addend);\n \t  if (r_type == elfcpp::R_PPC64_GOT_TPREL_PCREL34)\n \t    value += target->got_section()->address();\n \t  else"
    }
  ]
}