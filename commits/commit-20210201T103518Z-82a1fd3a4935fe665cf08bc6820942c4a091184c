{
  "sha": "82a1fd3a4935fe665cf08bc6820942c4a091184c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODJhMWZkM2E0OTM1ZmU2NjVjZjA4YmM2ODIwOTQyYzRhMDkxMTg0Yw==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-01-18T16:00:38Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-01T10:35:18Z"
    },
    "message": "gdb: unify parts of the Linux and FreeBSD core dumping code\n\nWhile reviewing the Linux and FreeBSD core dumping code within GDB for\nanother patch series, I noticed that the code that collects the\nregisters for each thread and writes these into ELF note format is\nbasically identical between Linux and FreeBSD.\n\nThis commit merges this code and moves it into the gcore.c file,\nwhich seemed like the right place for generic writing a core file\ncode.\n\nThe function find_signalled_thread is moved from linux-tdep.c despite\nnot being shared.  A later commit will make use of this function.\n\nThere are a couple of minor changes to the FreeBSD target after this\ncommit, but I believe that these are changes for the better:\n\n(1) For FreeBSD we always used to record the thread-id in the core file by\nusing ptid_t.lwp ().  In contrast the Linux code did this:\n\n    /* For remote targets the LWP may not be available, so use the TID.  */\n    long lwp = ptid.lwp ();\n    if (lwp == 0)\n      lwp = ptid.tid ();\n\nBoth target now do this:\n\n    /* The LWP is often not available for bare metal target, in which case\n       use the tid instead.  */\n    if (ptid.lwp_p ())\n      lwp = ptid.lwp ();\n    else\n      lwp = ptid.tid ();\n\nWhich is equivalent for Linux, but is a change for FreeBSD.  I think\nthat all this means is that in some cases where GDB might have\npreviously recorded a thread-id of 0 for each thread, we might now get\nsomething more useful.\n\n(2) When collecting the registers for Linux we collected into a zero\ninitialised buffer.  By contrast on FreeBSD the buffer is left\nuninitialised.  In the new code the buffer is always zero initialised.\nI suspect once the registers are copied into the buffer there's\nprobably no gaps left so this makes no difference, but if it does then\nusing zeros rather than random bits of GDB's memory is probably a good\nthing.\n\nOtherwise, there should be no other user visible changes after this\ncommit.\n\nTested this on x86-64/GNU-Linux and x86-64/FreeBSD-12.2 with no\nregressions.\n\ngdb/ChangeLog:\n\n\t* Makefile.in (HFILES_NO_SRCDIR): Add corefile.h.\n\t* gcore.c (struct gcore_collect_regset_section_cb_data): Moved\n\there from linux-tdep.c and given a new name.  Minor cleanups.\n\t(gcore_collect_regset_section_cb): Likewise.\n\t(gcore_collect_thread_registers): Likewise.\n\t(gcore_build_thread_register_notes): Likewise.\n\t(gcore_find_signalled_thread): Likewise.\n\t* gcore.h (gcore_build_thread_register_notes): Declare.\n\t(gcore_find_signalled_thread): Declare.\n\t* fbsd-tdep.c: Add 'gcore.h' include.\n\t(struct fbsd_collect_regset_section_cb_data): Delete.\n\t(fbsd_collect_regset_section_cb): Delete.\n\t(fbsd_collect_thread_registers): Delete.\n\t(struct fbsd_corefile_thread_data): Delete.\n\t(fbsd_corefile_thread): Delete.\n\t(fbsd_make_corefile_notes): Call\n\tgcore_build_thread_register_notes instead of the now deleted\n\tFreeBSD code.\n\t* linux-tdep.c: Add 'gcore.h' include.\n\t(struct linux_collect_regset_section_cb_data): Delete.\n\t(linux_collect_regset_section_cb): Delete.\n\t(linux_collect_thread_registers): Delete.\n\t(linux_corefile_thread): Call\n\tgcore_build_thread_register_notes.\n\t(find_signalled_thread): Delete.\n\t(linux_make_corefile_notes): Call gcore_find_signalled_thread.",
    "tree": {
      "sha": "e3b60b40dfa329387c96a226dc6c8a585e71ecb7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e3b60b40dfa329387c96a226dc6c8a585e71ecb7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/82a1fd3a4935fe665cf08bc6820942c4a091184c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82a1fd3a4935fe665cf08bc6820942c4a091184c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/82a1fd3a4935fe665cf08bc6820942c4a091184c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82a1fd3a4935fe665cf08bc6820942c4a091184c/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a5f92c675662a7ed5353fcd0b23b69fdbd6ecf43",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5f92c675662a7ed5353fcd0b23b69fdbd6ecf43",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a5f92c675662a7ed5353fcd0b23b69fdbd6ecf43"
    }
  ],
  "stats": {
    "total": 461,
    "additions": 199,
    "deletions": 262
  },
  "files": [
    {
      "sha": "7323a13e0f279b7f7e803274ccf122135145e463",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=82a1fd3a4935fe665cf08bc6820942c4a091184c",
      "patch": "@@ -1,3 +1,32 @@\n+2021-02-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* Makefile.in (HFILES_NO_SRCDIR): Add corefile.h.\n+\t* gcore.c (struct gcore_collect_regset_section_cb_data): Moved\n+\there from linux-tdep.c and given a new name.  Minor cleanups.\n+\t(gcore_collect_regset_section_cb): Likewise.\n+\t(gcore_collect_thread_registers): Likewise.\n+\t(gcore_build_thread_register_notes): Likewise.\n+\t(gcore_find_signalled_thread): Likewise.\n+\t* gcore.h (gcore_build_thread_register_notes): Declare.\n+\t(gcore_find_signalled_thread): Declare.\n+\t* fbsd-tdep.c: Add 'gcore.h' include.\n+\t(struct fbsd_collect_regset_section_cb_data): Delete.\n+\t(fbsd_collect_regset_section_cb): Delete.\n+\t(fbsd_collect_thread_registers): Delete.\n+\t(struct fbsd_corefile_thread_data): Delete.\n+\t(fbsd_corefile_thread): Delete.\n+\t(fbsd_make_corefile_notes): Call\n+\tgcore_build_thread_register_notes instead of the now deleted\n+\tFreeBSD code.\n+\t* linux-tdep.c: Add 'gcore.h' include.\n+\t(struct linux_collect_regset_section_cb_data): Delete.\n+\t(linux_collect_regset_section_cb): Delete.\n+\t(linux_collect_thread_registers): Delete.\n+\t(linux_corefile_thread): Call\n+\tgcore_build_thread_register_notes.\n+\t(find_signalled_thread): Delete.\n+\t(linux_make_corefile_notes): Call gcore_find_signalled_thread.\n+\n 2021-01-29  Tom de Vries  <tdevries@suse.de>\n \n \tPR breakpoints/26063"
    },
    {
      "sha": "edd3edc422093feb063936c7122b995c3922e120",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 128,
      "changes": 135,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=82a1fd3a4935fe665cf08bc6820942c4a091184c",
      "patch": "@@ -32,6 +32,7 @@\n \n #include \"elf-bfd.h\"\n #include \"fbsd-tdep.h\"\n+#include \"gcore.h\"\n \n /* This enum is derived from FreeBSD's <sys/signal.h>.  */\n \n@@ -583,129 +584,6 @@ find_signalled_thread (struct thread_info *info, void *data)\n   return 0;\n }\n \n-/* Structure for passing information from\n-   fbsd_collect_thread_registers via an iterator to\n-   fbsd_collect_regset_section_cb. */\n-\n-struct fbsd_collect_regset_section_cb_data\n-{\n-  fbsd_collect_regset_section_cb_data (const struct regcache *regcache,\n-\t\t\t\t       bfd *obfd,\n-\t\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\t       int *note_size,\n-\t\t\t\t       unsigned long lwp,\n-\t\t\t\t       gdb_signal stop_signal)\n-    : regcache (regcache),\n-      obfd (obfd),\n-      note_data (note_data),\n-      note_size (note_size),\n-      lwp (lwp),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  const struct regcache *regcache;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  unsigned long lwp;\n-  enum gdb_signal stop_signal;\n-  bool abort_iteration = false;\n-};\n-\n-static void\n-fbsd_collect_regset_section_cb (const char *sect_name, int supply_size,\n-\t\t\t\tint collect_size, const struct regset *regset,\n-\t\t\t\tconst char *human_name, void *cb_data)\n-{\n-  char *buf;\n-  struct fbsd_collect_regset_section_cb_data *data\n-    = (struct fbsd_collect_regset_section_cb_data *) cb_data;\n-\n-  if (data->abort_iteration)\n-    return;\n-\n-  gdb_assert (regset->collect_regset);\n-\n-  buf = (char *) xmalloc (collect_size);\n-  regset->collect_regset (regset, data->regcache, -1, buf, collect_size);\n-\n-  /* PRSTATUS still needs to be treated specially.  */\n-  if (strcmp (sect_name, \".reg\") == 0)\n-    data->note_data.reset (elfcore_write_prstatus\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, data->lwp,\n-\t\t\t      gdb_signal_to_host (data->stop_signal),\n-\t\t\t      buf));\n-  else\n-    data->note_data.reset (elfcore_write_register_note\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, sect_name, buf,\n-\t\t\t      collect_size));\n-  xfree (buf);\n-\n-  if (data->note_data == NULL)\n-    data->abort_iteration = true;\n-}\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-fbsd_collect_thread_registers (const struct regcache *regcache,\n-\t\t\t       ptid_t ptid, bfd *obfd,\n-\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t       int *note_size,\n-\t\t\t       enum gdb_signal stop_signal)\n-{\n-  fbsd_collect_regset_section_cb_data data (regcache, obfd, note_data,\n-\t\t\t\t\t    note_size, ptid.lwp (),\n-\t\t\t\t\t    stop_signal);\n-\n-  gdbarch_iterate_over_regset_sections (regcache->arch (),\n-\t\t\t\t\tfbsd_collect_regset_section_cb,\n-\t\t\t\t\t&data, regcache);\n-}\n-\n-struct fbsd_corefile_thread_data\n-{\n-  fbsd_corefile_thread_data (struct gdbarch *gdbarch,\n-\t\t\t     bfd *obfd,\n-\t\t\t     gdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t     int *note_size,\n-\t\t\t     gdb_signal stop_signal)\n-    : gdbarch (gdbarch),\n-      obfd (obfd),\n-      note_data (note_data),\n-      note_size (note_size),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  struct gdbarch *gdbarch;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  enum gdb_signal stop_signal;\n-};\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-fbsd_corefile_thread (struct thread_info *info,\n-\t\t      struct fbsd_corefile_thread_data *args)\n-{\n-  struct regcache *regcache;\n-\n-  regcache = get_thread_arch_regcache (info->inf->process_target (),\n-\t\t\t\t       info->ptid, args->gdbarch);\n-\n-  target_fetch_registers (regcache, -1);\n-\n-  fbsd_collect_thread_registers (regcache, info->ptid, args->obfd,\n-\t\t\t\t args->note_data, args->note_size,\n-\t\t\t\t args->stop_signal);\n-}\n-\n /* Return a byte_vector containing the contents of a core dump note\n    for the target object of type OBJECT.  If STRUCTSIZE is non-zero,\n    the data is prefixed with a 32-bit integer size to match the format\n@@ -782,16 +660,17 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \tsignalled_thr = curr_thr;\n     }\n \n-  fbsd_corefile_thread_data thread_args (gdbarch, obfd, note_data, note_size,\n-\t\t\t\t\t signalled_thr->suspend.stop_signal);\n-\n-  fbsd_corefile_thread (signalled_thr, &thread_args);\n+  gcore_build_thread_register_notes (gdbarch, signalled_thr,\n+\t\t\t\t     signalled_thr->suspend.stop_signal,\n+\t\t\t\t     obfd, &note_data, note_size);\n   for (thread_info *thr : current_inferior ()->non_exited_threads ())\n     {\n       if (thr == signalled_thr)\n \tcontinue;\n \n-      fbsd_corefile_thread (thr, &thread_args);\n+      gcore_build_thread_register_notes (gdbarch, thr,\n+\t\t\t\t\t signalled_thr->suspend.stop_signal,\n+\t\t\t\t\t obfd, &note_data, note_size);\n     }\n \n   /* Auxiliary vector.  */"
    },
    {
      "sha": "d62aa3a710972ed438fc7012a6d80a63b8b61bdc",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 136,
      "deletions": 0,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=82a1fd3a4935fe665cf08bc6820942c4a091184c",
      "patch": "@@ -579,6 +579,142 @@ gcore_memory_sections (bfd *obfd)\n   return 1;\n }\n \n+/* Structure for passing information from GCORE_COLLECT_THREAD_REGISTERS\n+   via an iterator to GCORE_COLLECT_REGSET_SECTION_CB. */\n+\n+struct gcore_collect_regset_section_cb_data\n+{\n+  gcore_collect_regset_section_cb_data (struct gdbarch *gdbarch,\n+\t\t\t\t\tconst struct regcache *regcache,\n+\t\t\t\t\tbfd *obfd, ptid_t ptid,\n+\t\t\t\t\tgdb_signal stop_signal,\n+\t\t\t\t\tgdb::unique_xmalloc_ptr<char> *note_data,\n+\t\t\t\t\tint *note_size)\n+\n+    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n+      note_data (note_data), note_size (note_size),\n+      stop_signal (stop_signal)\n+  {\n+    /* The LWP is often not available for bare metal target, in which case\n+       use the tid instead.  */\n+    if (ptid.lwp_p ())\n+      lwp = ptid.lwp ();\n+    else\n+      lwp = ptid.tid ();\n+  }\n+\n+  struct gdbarch *gdbarch;\n+  const struct regcache *regcache;\n+  bfd *obfd;\n+  gdb::unique_xmalloc_ptr<char> *note_data;\n+  int *note_size;\n+  unsigned long lwp;\n+  enum gdb_signal stop_signal;\n+  bool abort_iteration = false;\n+};\n+\n+/* Callback for ITERATE_OVER_REGSET_SECTIONS that records a single\n+   regset in the core file note section.  */\n+\n+static void\n+gcore_collect_regset_section_cb (const char *sect_name, int supply_size,\n+\t\t\t\t int collect_size,\n+\t\t\t\t const struct regset *regset,\n+\t\t\t\t const char *human_name, void *cb_data)\n+{\n+  struct gcore_collect_regset_section_cb_data *data\n+    = (struct gcore_collect_regset_section_cb_data *) cb_data;\n+  bool variable_size_section = (regset != NULL\n+\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n+\n+  gdb_assert (variable_size_section || supply_size == collect_size);\n+\n+  if (data->abort_iteration)\n+    return;\n+\n+  gdb_assert (regset != nullptr && regset->collect_regset != nullptr);\n+\n+  /* This is intentionally zero-initialized by using std::vector, so\n+     that any padding bytes in the core file will show as 0.  */\n+  std::vector<gdb_byte> buf (collect_size);\n+\n+  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n+\t\t\t  collect_size);\n+\n+  /* PRSTATUS still needs to be treated specially.  */\n+  if (strcmp (sect_name, \".reg\") == 0)\n+    data->note_data->reset (elfcore_write_prstatus\n+\t\t\t    (data->obfd, data->note_data->release (),\n+\t\t\t     data->note_size, data->lwp,\n+\t\t\t     gdb_signal_to_host (data->stop_signal),\n+\t\t\t     buf.data ()));\n+  else\n+    data->note_data->reset (elfcore_write_register_note\n+\t\t\t    (data->obfd, data->note_data->release (),\n+\t\t\t     data->note_size, sect_name, buf.data (),\n+\t\t\t     collect_size));\n+\n+  if (data->note_data == nullptr)\n+    data->abort_iteration = true;\n+}\n+\n+/* Records the register state of thread PTID out of REGCACHE into the note\n+   buffer represented by *NOTE_DATA and NOTE_SIZE.  OBFD is the bfd into\n+   which the core file is being created, and STOP_SIGNAL is the signal that\n+   cause thread PTID to stop.  */\n+\n+static void\n+gcore_collect_thread_registers (const struct regcache *regcache,\n+\t\t\t\tptid_t ptid, bfd *obfd,\n+\t\t\t\tgdb::unique_xmalloc_ptr<char> *note_data,\n+\t\t\t\tint *note_size,\n+\t\t\t\tenum gdb_signal stop_signal)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+  gcore_collect_regset_section_cb_data data (gdbarch, regcache, obfd, ptid,\n+\t\t\t\t\t     stop_signal, note_data,\n+\t\t\t\t\t     note_size);\n+  gdbarch_iterate_over_regset_sections (gdbarch,\n+\t\t\t\t\tgcore_collect_regset_section_cb,\n+\t\t\t\t\t&data, regcache);\n+}\n+\n+/* See gcore.h.  */\n+\n+void\n+gcore_build_thread_register_notes\n+  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n+   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size)\n+{\n+  struct regcache *regcache\n+    = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\tinfo->ptid, gdbarch);\n+  target_fetch_registers (regcache, -1);\n+  gcore_collect_thread_registers (regcache, info->ptid, obfd, note_data,\n+\t\t\t\t  note_size, stop_signal);\n+}\n+\n+/* See gcore.h.  */\n+\n+thread_info *\n+gcore_find_signalled_thread ()\n+{\n+  thread_info *curr_thr = inferior_thread ();\n+  if (curr_thr->state != THREAD_EXITED\n+      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+    return curr_thr;\n+\n+  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n+    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n+      return thr;\n+\n+  /* Default to the current thread, unless it has exited.  */\n+  if (curr_thr->state != THREAD_EXITED)\n+    return curr_thr;\n+\n+  return nullptr;\n+}\n+\n void _initialize_gcore ();\n void\n _initialize_gcore ()"
    },
    {
      "sha": "ce60841c1a55ae338ccfee645ffd0168afb0e786",
      "filename": "gdb/gcore.h",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/gcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/gcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.h?ref=82a1fd3a4935fe665cf08bc6820942c4a091184c",
      "patch": "@@ -21,11 +21,31 @@\n #define GCORE_H 1\n \n #include \"gdb_bfd.h\"\n+#include \"gdbsupport/gdb_signals.h\"\n+\n+struct gdbarch;\n+struct thread_info;\n \n extern gdb_bfd_ref_ptr create_gcore_bfd (const char *filename);\n extern void write_gcore_file (bfd *obfd);\n extern int objfile_find_memory_regions (struct target_ops *self,\n \t\t\t\t\tfind_memory_region_ftype func,\n \t\t\t\t\tvoid *obfd);\n \n+/* Add content to *NOTE_DATA (and update *NOTE_SIZE) to describe the\n+   registers of thread INFO.  Report the thread as having stopped with\n+   STOP_SIGNAL.  The core file is being written to OFD, and GDBARCH is the\n+   architecture for which the core file is being generated.  */\n+\n+extern void gcore_build_thread_register_notes\n+  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n+   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size);\n+\n+/* Find the signalled thread.  In case there's more than one signalled\n+   thread, prefer the current thread, if it is signalled.  If no thread was\n+   signalled, default to the current thread, unless it has exited, in which\n+   case return NULL.  */\n+\n+extern thread_info *gcore_find_signalled_thread ();\n+\n #endif /* GCORE_H */"
    },
    {
      "sha": "3db4d31de377a40c07dddd7aef22a971cac6a11d",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 134,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a1fd3a4935fe665cf08bc6820942c4a091184c/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=82a1fd3a4935fe665cf08bc6820942c4a091184c",
      "patch": "@@ -39,6 +39,7 @@\n #include \"gdb_regex.h\"\n #include \"gdbsupport/enum-flags.h\"\n #include \"gdbsupport/gdb_optional.h\"\n+#include \"gcore.h\"\n \n #include <ctype.h>\n \n@@ -1597,104 +1598,6 @@ linux_make_mappings_corefile_notes (struct gdbarch *gdbarch, bfd *obfd,\n     }\n }\n \n-/* Structure for passing information from\n-   linux_collect_thread_registers via an iterator to\n-   linux_collect_regset_section_cb. */\n-\n-struct linux_collect_regset_section_cb_data\n-{\n-  linux_collect_regset_section_cb_data (struct gdbarch *gdbarch,\n-\t\t\t\t\tconst struct regcache *regcache,\n-\t\t\t\t\tbfd *obfd,\n-\t\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\t\tint *note_size,\n-\t\t\t\t\tunsigned long lwp,\n-\t\t\t\t\tgdb_signal stop_signal)\n-    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n-      note_data (note_data), note_size (note_size), lwp (lwp),\n-      stop_signal (stop_signal)\n-  {}\n-\n-  struct gdbarch *gdbarch;\n-  const struct regcache *regcache;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> &note_data;\n-  int *note_size;\n-  unsigned long lwp;\n-  enum gdb_signal stop_signal;\n-  bool abort_iteration = false;\n-};\n-\n-/* Callback for iterate_over_regset_sections that records a single\n-   regset in the corefile note section.  */\n-\n-static void\n-linux_collect_regset_section_cb (const char *sect_name, int supply_size,\n-\t\t\t\t int collect_size, const struct regset *regset,\n-\t\t\t\t const char *human_name, void *cb_data)\n-{\n-  struct linux_collect_regset_section_cb_data *data\n-    = (struct linux_collect_regset_section_cb_data *) cb_data;\n-  bool variable_size_section = (regset != NULL\n-\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n-\n-  if (!variable_size_section)\n-    gdb_assert (supply_size == collect_size);\n-\n-  if (data->abort_iteration)\n-    return;\n-\n-  gdb_assert (regset && regset->collect_regset);\n-\n-  /* This is intentionally zero-initialized by using std::vector, so\n-     that any padding bytes in the core file will show as 0.  */\n-  std::vector<gdb_byte> buf (collect_size);\n-\n-  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n-\t\t\t  collect_size);\n-\n-  /* PRSTATUS still needs to be treated specially.  */\n-  if (strcmp (sect_name, \".reg\") == 0)\n-    data->note_data.reset (elfcore_write_prstatus\n-\t\t\t     (data->obfd, data->note_data.release (),\n-\t\t\t      data->note_size, data->lwp,\n-\t\t\t      gdb_signal_to_host (data->stop_signal),\n-\t\t\t      buf.data ()));\n-  else\n-    data->note_data.reset (elfcore_write_register_note\n-\t\t\t   (data->obfd, data->note_data.release (),\n-\t\t\t    data->note_size, sect_name, buf.data (),\n-\t\t\t    collect_size));\n-\n-  if (data->note_data == NULL)\n-    data->abort_iteration = true;\n-}\n-\n-/* Records the thread's register state for the corefile note\n-   section.  */\n-\n-static void\n-linux_collect_thread_registers (const struct regcache *regcache,\n-\t\t\t\tptid_t ptid, bfd *obfd,\n-\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n-\t\t\t\tint *note_size,\n-\t\t\t\tenum gdb_signal stop_signal)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-\n-  /* For remote targets the LWP may not be available, so use the TID.  */\n-  long lwp = ptid.lwp ();\n-  if (lwp == 0)\n-    lwp = ptid.tid ();\n-\n-  linux_collect_regset_section_cb_data data (gdbarch, regcache, obfd, note_data,\n-\t\t\t\t\t     note_size, lwp, stop_signal);\n-\n-  gdbarch_iterate_over_regset_sections (gdbarch,\n-\t\t\t\t\tlinux_collect_regset_section_cb,\n-\t\t\t\t\t&data, regcache);\n-}\n-\n /* Fetch the siginfo data for the specified thread, if it exists.  If\n    there is no data, or we could not read it, return an empty\n    buffer.  */\n@@ -1746,22 +1649,16 @@ static void\n linux_corefile_thread (struct thread_info *info,\n \t\t       struct linux_corefile_thread_data *args)\n {\n-  struct regcache *regcache;\n-\n-  regcache = get_thread_arch_regcache (info->inf->process_target (),\n-\t\t\t\t       info->ptid, args->gdbarch);\n-\n-  target_fetch_registers (regcache, -1);\n-  gdb::byte_vector siginfo_data = linux_get_siginfo_data (info, args->gdbarch);\n-\n-  linux_collect_thread_registers (regcache, info->ptid, args->obfd,\n-\t\t\t\t  args->note_data, args->note_size,\n-\t\t\t\t  args->stop_signal);\n+  gcore_build_thread_register_notes (args->gdbarch, info, args->stop_signal,\n+\t\t\t\t     args->obfd, &args->note_data,\n+\t\t\t\t     args->note_size);\n \n   /* Don't return anything if we got no register information above,\n      such a core file is useless.  */\n   if (args->note_data != NULL)\n     {\n+      gdb::byte_vector siginfo_data\n+\t= linux_get_siginfo_data (info, args->gdbarch);\n       if (!siginfo_data.empty ())\n \targs->note_data.reset (elfcore_write_note (args->obfd,\n \t\t\t\t\t\t   args->note_data.release (),\n@@ -1960,30 +1857,6 @@ linux_fill_prpsinfo (struct elf_internal_linux_prpsinfo *p)\n   return 1;\n }\n \n-/* Find the signalled thread.  In case there's more than one signalled\n-   thread, prefer the current thread, if it is signalled.  If no\n-   thread was signalled, default to the current thread, unless it has\n-   exited, in which case return NULL.  */\n-\n-static thread_info *\n-find_signalled_thread ()\n-{\n-  thread_info *curr_thr = inferior_thread ();\n-  if (curr_thr->state != THREAD_EXITED\n-      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n-    return curr_thr;\n-\n-  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n-    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n-      return thr;\n-\n-  /* Default to the current thread, unless it has exited.  */\n-  if (curr_thr->state != THREAD_EXITED)\n-    return curr_thr;\n-\n-  return nullptr;\n-}\n-\n /* Build the note section for a corefile, and return it in a malloc\n    buffer.  */\n \n@@ -2021,7 +1894,7 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n   /* Like the kernel, prefer dumping the signalled thread first.\n      \"First thread\" is what tools use to infer the signalled\n      thread.  */\n-  thread_info *signalled_thr = find_signalled_thread ();\n+  thread_info *signalled_thr = gcore_find_signalled_thread ();\n   gdb_signal stop_signal;\n   if (signalled_thr != nullptr)\n     stop_signal = signalled_thr->suspend.stop_signal;"
    }
  ]
}