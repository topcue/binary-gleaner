{
  "sha": "ff77083572522d805e631b287b4b9db68f596503",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmY3NzA4MzU3MjUyMmQ4MDVlNjMxYjI4N2I0YjlkYjY4ZjU5NjUwMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-04-06T18:31:50Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-15T03:18:24Z"
    },
    "message": "gdb: call post_create_inferior at end of follow_fork_inferior\n\nGDB doesn't handle well the case of an inferior using the JIT interface\nto register JIT-ed objfiles and forking.  If an inferior registers a\ncode object using the JIT interface and then forks, the child process\nconceptually has the same code object loaded, so GDB should look it up\nand learn about it (it currently doesn't).\n\nTo achieve this, I think it would make sense to have the\ninferior_created observable called when an inferior is created due to a\nfork in follow_fork_inferior.  The inferior_created observable is\ncurrently called both after starting a new inferior and after attaching\nto an inferior, allowing various sub-components to learn about that new\nexecuting inferior.  We can see handling a fork child just like\nattaching to it, so any work done when attaching should also be done in\nthe case of a fork child.\n\nInstead of just calling the inferior_created observable, this patch\nmakes follow_fork_inferior call the whole post_create_inferior function.\nThis way, the attach and follow-fork code code paths are more alike.\n\nGiven that post_create_inferior calls solib_create_inferior_hook,\nfollow_fork_inferior doesn't need to do it itself, so those calls to\nsolib_create_inferior_hook are removed.\n\nOne question you may have: why not just call post_create_inferior at the\nplaces where solib_create_inferior_hook is currently called, instead of\nafter target_follow_fork?\n\n - there's something fishy for the second solib_create_inferior_hook\n   call site: at this point we have switched the current program space\n   to the child's, but not the current inferior nor the current thread.\n   So solib_create_inferior_hook (and everything under, including\n   check_for_thread_db, for example) is called with inferior 1 as the\n   current inferior and inferior 2's program space as the current\n   program space.  I think that's wrong, because at this point we are\n   setting up inferior 2, and all that code relies on the current\n   inferior.  We could just add a switch_to_thread call before it to\n   make inferior 2 the current one, but there are other problems (see\n   below).\n\n - solib_create_inferior_hook is currently not called on the\n   `follow_child && detach_fork` path.  I think we need to call it,\n   because we still get a new inferior in that case (even though we\n   detach the parent).  If we only call post_create_inferior where\n   solib_create_inferior_hook used to be called, then the JIT\n   subcomponent doesn't get informed about the new inferior, and that\n   introduces a failure in the new gdb.base/jit-elf-fork.exp test.\n\n - if we try to put the post_create_inferior just after the\n   switch_to_thread that was originally at line 662, or just before the\n   call to target_follow_fork, we introduce a subtle failure in\n   gdb.threads/fork-thread-pending.exp.  What happens then is that\n   libthread_db gets loaded (somewhere under post_create_inferior)\n   before the linux-nat target learns about the LWPs (which happens in\n   linux_nat_target::follow_fork).  As a result, the ALL_LWPS loop in\n   try_thread_db_load_1 doesn't see the child LWP, and the thread-db\n   target doesn't have the chance to fill in thread_info::priv.  A bit\n   later, when the test does \"info threads\", and\n   thread_db_target::pid_to_str is called, the thread-db target doesn't\n   recognize the thread as one of its own, and delegates the request to\n   the target below.  Because the pid_to_str output is not the expected\n   one, the test fails.\n\n   This tells me that we need to call the process target's follow_fork\n   first, to make the process target create the necessary LWP and thread\n   structures.  Then, we can call post_create_inferior to let the other\n   components of GDB do their thing.\n\n   But then you may ask: check_for_thread_db is already called today,\n   somewhere under solib_create_inferior_hook, and that is before\n   target_follow_fork, why don't we see this ordering problem!?  Well,\n   because of the first bullet point: when check_for_thread_db /\n   thread_db_load are called, the current inferior is (erroneously)\n   inferior 1, the parent.  Because libthread_db is already loaded for\n   the parent, thread_db_load early returns.  check_for_thread_db later\n   gets called by linux_nat_target::follow_fork.  At this point, the\n   current inferior is the correct one and the child's LWP exists, so\n   all is well.\n\nSince we now call post_create_inferior after target_follow_fork, which\ncalls the inferior_created observable, which calls check_for_thread_db,\nI don't think linux_nat_target needs to explicitly call\ncheck_for_thread_db itself, so that is removed.\n\nIn terms of testing, this patch adds a new gdb.base/jit-elf-fork.exp\ntest.  It makes an inferior register a JIT code object and then fork.\nIt then verifies that whatever the detach-on-fork and follow-fork-child\nparameters are, GDB knows about the JIT code object in all the inferiors\nthat survive the fork.  It verifies that the inferiors can unload that\ncode object.\n\nThere isn't currently a way to get visibility into GDB's idea of the JIT\ncode objects for each inferior.  For the purpose of this test, add the\n\"maintenance info jit\" command.  There isn't much we can print about the\nJIT code objects except their load address.  So the output looks a bit\nbare, but it's good enough for the test.\n\ngdb/ChangeLog:\n\n\t* NEWS: Mention \"maint info jit\" command.\n\t* infrun.c (follow_fork_inferior): Don't call\n\tsolib_create_inferior_hook, call post_create_inferior if a new\n\tinferior was created.\n\t* jit.c (maint_info_jit_cmd): New.\n\t(_initialize_jit): Register new command.\n\t* linux-nat.c (linux_nat_target::follow_fork): Don't call\n\tcheck_for_thread_db.\n\t* linux-nat.h (check_for_thread_db): Remove declaration.\n\t* linux-thread-db.c (check_thread_signals): Make static.\n\ngdb/doc/ChangeLog:\n\n\t* gdb.texinfo (Maintenance Commands): Mention \"maint info jit\".\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/jit-elf-fork-main.c: New test.\n\t* gdb.base/jit-elf-fork-solib.c: New test.\n\t* gdb.base/jit-elf-fork.exp: New test.\n\nChange-Id: I9a192e55b8a451c00e88100669283fc9ca60de5c",
    "tree": {
      "sha": "0f6314756383c923d2fb2f79b3ad5abe84233818",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0f6314756383c923d2fb2f79b3ad5abe84233818"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ff77083572522d805e631b287b4b9db68f596503",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ff77083572522d805e631b287b4b9db68f596503",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ff77083572522d805e631b287b4b9db68f596503",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ff77083572522d805e631b287b4b9db68f596503/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e22be21285391a557dafa4d9e6ff01288eca216a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e22be21285391a557dafa4d9e6ff01288eca216a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e22be21285391a557dafa4d9e6ff01288eca216a"
    }
  ],
  "stats": {
    "total": 433,
    "additions": 391,
    "deletions": 42
  },
  "files": [
    {
      "sha": "44b8bbc88eed3bfb3194a300f62ab8a0b3a1d8c6",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -145,6 +145,9 @@ maintenance flush dcache\n maintenance info target-sections\n   Print GDB's internal target sections table.\n \n+maintenance info jit\n+  Print the JIT code objects in the inferior known to GDB.\n+\n memory-tag show-logical-tag POINTER\n   Print the logical tag for POINTER.\n memory-tag with-logical-tag POINTER TAG"
    },
    {
      "sha": "386cef7bd4e9626071c741511b71f5d4c80c4ddd",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -39074,6 +39074,10 @@ buffer.\n Control whether @value{GDBN} will skip PAD packets when computing the\n packet history.\n \n+@kindex maint info jit\n+@item maint info jit\n+Print information about JIT code objects loaded in the current inferior.\n+\n @kindex set displaced-stepping\n @kindex show displaced-stepping\n @cindex displaced stepping support"
    },
    {
      "sha": "04206b3c629878f069418333b2982fb2629cdefd",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 15,
      "deletions": 23,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -429,6 +429,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n       return true;\n     }\n \n+  thread_info *child_thr = nullptr;\n+\n   if (!follow_child)\n     {\n       /* Detach new forked process?  */\n@@ -478,8 +480,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t  switch_to_no_thread ();\n \t  child_inf->symfile_flags = SYMFILE_NO_READ;\n \t  child_inf->push_target (parent_inf->process_target ());\n-\t  thread_info *child_thr\n-\t    = add_thread_silent (child_inf->process_target (), child_ptid);\n+\t  child_thr = add_thread_silent (child_inf->process_target (),\n+\t\t\t\t\t child_ptid);\n \n \t  /* If this is a vfork child, then the address-space is\n \t     shared with the parent.  */\n@@ -514,17 +516,6 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      /* solib_create_inferior_hook relies on the current\n \t\t thread.  */\n \t      switch_to_thread (child_thr);\n-\n-\t      /* Let the shared library layer (e.g., solib-svr4) learn\n-\t\t about this new process, relocate the cloned exec, pull\n-\t\t in shared libraries, and install the solib event\n-\t\t breakpoint.  If a \"cloned-VM\" event was propagated\n-\t\t better throughout the core, this wouldn't be\n-\t\t required.  */\n-\t      scoped_restore restore_in_initial_library_scan\n-\t\t= make_scoped_restore (&child_inf->in_initial_library_scan,\n-\t\t\t\t       true);\n-\t      solib_create_inferior_hook (0);\n \t    }\n \t}\n \n@@ -633,7 +624,7 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \tchild_inf->push_target (target);\n       }\n \n-      thread_info *child_thr = add_thread_silent (target, child_ptid);\n+      child_thr = add_thread_silent (target, child_ptid);\n \n       /* If this is a vfork child, then the address-space is shared\n \t with the parent.  If we detached from the parent, then we can\n@@ -653,22 +644,23 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t  child_inf->symfile_flags = SYMFILE_NO_READ;\n \t  set_current_program_space (child_inf->pspace);\n \t  clone_program_space (child_inf->pspace, parent_pspace);\n-\n-\t  /* Let the shared library layer (e.g., solib-svr4) learn\n-\t     about this new process, relocate the cloned exec, pull in\n-\t     shared libraries, and install the solib event breakpoint.\n-\t     If a \"cloned-VM\" event was propagated better throughout\n-\t     the core, this wouldn't be required.  */\n-\t  scoped_restore restore_in_initial_library_scan\n-\t    = make_scoped_restore (&child_inf->in_initial_library_scan, true);\n-\t  solib_create_inferior_hook (0);\n \t}\n \n       switch_to_thread (child_thr);\n     }\n \n   target_follow_fork (follow_child, detach_fork);\n \n+  /* If we ended up creating a new inferior, call post_create_inferior to inform\n+     the various subcomponents.  */\n+  if (child_thr != nullptr)\n+    {\n+      scoped_restore_current_thread restore;\n+      switch_to_thread (child_thr);\n+\n+      post_create_inferior (0);\n+    }\n+\n   return false;\n }\n "
    },
    {
      "sha": "666262e2a05229b6e55dfbcff8d7b15449335291",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -74,6 +74,30 @@ show_jit_debug (struct ui_file *file, int from_tty,\n   fprintf_filtered (file, _(\"JIT debugging is %s.\\n\"), value);\n }\n \n+/* Implementation of the \"maintenance info jit\" command.  */\n+\n+static void\n+maint_info_jit_cmd (const char *args, int from_tty)\n+{\n+  inferior *inf = current_inferior ();\n+  bool printed_header = false;\n+\n+  /* Print a line for each JIT-ed objfile.  */\n+  for (objfile *obj : inf->pspace->objfiles ())\n+    {\n+      if (obj->jited_data == nullptr)\n+\tcontinue;\n+\n+      if (!printed_header)\n+\t{\n+\t  printf_filtered (\"Base address of known JIT-ed objfiles:\\n\");\n+\t  printed_header = true;\n+\t}\n+\n+      printf_filtered (\"  %s\\n\", paddress (obj->arch (), obj->jited_data->addr));\n+    }\n+}\n+\n struct jit_reader\n {\n   jit_reader (struct gdb_reader_funcs *f, gdb_dlhandle_up &&h)\n@@ -1248,6 +1272,10 @@ _initialize_jit ()\n \t\t\t   show_jit_debug,\n \t\t\t   &setdebuglist, &showdebuglist);\n \n+  add_cmd (\"jit\", class_maintenance, maint_info_jit_cmd,\n+\t   _(\"Print information about JIT-ed code objects.\"),\n+\t   &maintenanceinfolist);\n+\n   gdb::observers::inferior_created.attach (jit_inferior_created_hook, \"jit\");\n   gdb::observers::inferior_execd.attach (jit_inferior_created_hook, \"jit\");\n   gdb::observers::inferior_exit.attach (jit_inferior_exit_hook, \"jit\");"
    },
    {
      "sha": "2b52dbd5f055df7dac74f809eab7195288562edd",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 15,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -521,18 +521,6 @@ linux_nat_target::follow_fork (bool follow_child, bool detach_fork)\n \t      ptrace (PTRACE_DETACH, child_pid, 0, signo);\n \t    }\n \t}\n-      else\n-\t{\n-\t  /* Switching inferior_ptid is not enough, because then\n-\t     inferior_thread () would crash by not finding the thread\n-\t     in the current inferior.  */\n-\t  scoped_restore_current_thread restore_current_thread;\n-\t  thread_info *child = find_thread_ptid (this, child_ptid);\n-\t  switch_to_thread (child);\n-\n-\t  /* Let the thread_db layer learn about this new process.  */\n-\t  check_for_thread_db ();\n-\t}\n \n       if (has_vforked)\n \t{\n@@ -609,9 +597,6 @@ linux_nat_target::follow_fork (bool follow_child, bool detach_fork)\n       child_lp = add_lwp (inferior_ptid);\n       child_lp->stopped = 1;\n       child_lp->last_resume_kind = resume_stop;\n-\n-      /* Let the thread_db layer learn about this new process.  */\n-      check_for_thread_db ();\n     }\n }\n "
    },
    {
      "sha": "feeaddafe9912856f6df0b0d0a685661ad25d271",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -294,9 +294,6 @@ extern enum tribool have_ptrace_getregset;\n        (LP) != NULL;\t\t\t\t\t\t\t\\\n        (LP) = (LP)->next)\n \n-/* Attempt to initialize libthread_db.  */\n-void check_for_thread_db (void);\n-\n /* Called from the LWP layer to inform the thread_db layer that PARENT\n    spawned CHILD.  Both LWPs are currently stopped.  This function\n    does whatever is required to have the child LWP under the"
    },
    {
      "sha": "eb2aa5ac409a61ee3cd1f793c21c62a75303ce78",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -1272,7 +1272,7 @@ check_thread_signals (void)\n    an inferior is created (or otherwise acquired, e.g. attached to)\n    and when new shared libraries are loaded into a running process.  */\n \n-void\n+static void\n check_for_thread_db (void)\n {\n   /* Do nothing if we couldn't load libthread_db.so.1.  */"
    },
    {
      "sha": "7431200b05b2e9a6805b0be247fecd39d5cbb8f6",
      "filename": "gdb/testsuite/gdb.base/jit-elf-fork-main.c",
      "status": "added",
      "additions": 129,
      "deletions": 0,
      "changes": 129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/jit-elf-fork-main.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -0,0 +1,129 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2011-2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Simulate loading of JIT code.  */\n+\n+#include <elf.h>\n+#include <link.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n+\n+#include \"jit-protocol.h\"\n+#include \"jit-elf-util.h\"\n+\n+static void\n+usage (void)\n+{\n+  fprintf (stderr, \"Usage: jit-elf-main libraries...\\n\");\n+  exit (1);\n+}\n+\n+/* Must be defined by .exp file when compiling to know\n+   what address to map the ELF binary to.  */\n+#ifndef LOAD_ADDRESS\n+#error \"Must define LOAD_ADDRESS\"\n+#endif\n+#ifndef LOAD_INCREMENT\n+#error \"Must define LOAD_INCREMENT\"\n+#endif\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int i;\n+  alarm (300);\n+  /* Used as backing storage for GDB to populate argv.  */\n+  char *fake_argv[10];\n+\n+  if (argc < 2)\n+    {\n+      usage ();\n+      exit (1);\n+    }\n+\n+  for (i = 1; i < argc; ++i)\n+    {\n+      size_t obj_size;\n+      void *load_addr = (void *) (size_t) (LOAD_ADDRESS + (i - 1) * LOAD_INCREMENT);\n+      printf (\"Loading %s as JIT at %p\\n\", argv[i], load_addr);\n+      void *addr = load_elf (argv[i], &obj_size, load_addr);\n+\n+      char name[32];\n+      sprintf (name, \"jit_function_%04d\", i);\n+      int (*jit_function) (void) = (int (*) (void)) load_symbol (addr, name);\n+\n+      /* Link entry at the end of the list.  */\n+      struct jit_code_entry *const entry = calloc (1, sizeof (*entry));\n+      entry->symfile_addr = (const char *)addr;\n+      entry->symfile_size = obj_size;\n+      entry->prev_entry = __jit_debug_descriptor.relevant_entry;\n+      __jit_debug_descriptor.relevant_entry = entry;\n+\n+      if (entry->prev_entry != NULL)\n+\tentry->prev_entry->next_entry = entry;\n+      else\n+\t__jit_debug_descriptor.first_entry = entry;\n+\n+      /* Notify GDB.  */\n+      __jit_debug_descriptor.action_flag = JIT_REGISTER;\n+      __jit_debug_register_code ();\n+\n+      if (jit_function () != 42)\n+\t{\n+\t  fprintf (stderr, \"unexpected return value\\n\");\n+\t  exit (1);\n+\t}\n+    }\n+\n+  i = 0;  /* break before fork */\n+\n+  fork ();\n+\n+  i = 0;  /* break after fork */\n+\n+  /* Now unregister them all in reverse order.  */\n+  while (__jit_debug_descriptor.relevant_entry != NULL)\n+    {\n+      struct jit_code_entry *const entry =\n+\t__jit_debug_descriptor.relevant_entry;\n+      struct jit_code_entry *const prev_entry = entry->prev_entry;\n+\n+      if (prev_entry != NULL)\n+\t{\n+\t  prev_entry->next_entry = NULL;\n+\t  entry->prev_entry = NULL;\n+\t}\n+      else\n+\t__jit_debug_descriptor.first_entry = NULL;\n+\n+      /* Notify GDB.  */\n+      __jit_debug_descriptor.action_flag = JIT_UNREGISTER;\n+      __jit_debug_register_code ();\n+\n+      __jit_debug_descriptor.relevant_entry = prev_entry;\n+      free (entry);\n+    }\n+\n+  return 0;  /* break before return  */\n+}"
    },
    {
      "sha": "4215b2dce582d54bb924c36a3505ebf84e9f3bbe",
      "filename": "gdb/testsuite/gdb.base/jit-elf-fork-solib.c",
      "status": "added",
      "additions": 25,
      "deletions": 0,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork-solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork-solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/jit-elf-fork-solib.c?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -0,0 +1,25 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2011-2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This simulates a JIT library.  The function name is supplied during\n+   compilation as a macro.  */\n+\n+#ifndef FUNCTION_NAME\n+#error \"Must define the FUNCTION_NAME macro to set a jited function name\"\n+#endif\n+\n+int FUNCTION_NAME() { return 42; }"
    },
    {
      "sha": "18eed27d5ac1850e838677a89eea4851e3d5abd6",
      "filename": "gdb/testsuite/gdb.base/jit-elf-fork.exp",
      "status": "added",
      "additions": 186,
      "deletions": 0,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ff77083572522d805e631b287b4b9db68f596503/gdb/testsuite/gdb.base/jit-elf-fork.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/jit-elf-fork.exp?ref=ff77083572522d805e631b287b4b9db68f596503",
      "patch": "@@ -0,0 +1,186 @@\n+# Copyright 2011-2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test fork handling of an inferior that has JIT-ed objfiles.\n+\n+if {[skip_shlib_tests]} {\n+    untested \"skipping shared library tests\"\n+    return -1\n+}\n+\n+if {[get_compiler_info]} {\n+    untested \"could not get compiler info\"\n+    return 1\n+}\n+\n+load_lib jit-elf-helpers.exp\n+\n+# The main code that loads and registers JIT objects.\n+set main_basename \"jit-elf-fork-main\"\n+set main_srcfile ${srcdir}/${subdir}/${main_basename}.c\n+set main_binfile [standard_output_file ${main_basename}]\n+\n+# The shared library that gets loaded as JIT objects.\n+set jit_solib_basename jit-elf-fork-solib\n+set jit_solib_srcfile ${srcdir}/${subdir}/${jit_solib_basename}.c\n+\n+# Compile a shared library to use as JIT objects.\n+set jit_solibs_target [compile_and_download_n_jit_so \\\n+\t\t       $jit_solib_basename $jit_solib_srcfile 1]\n+if { $jit_solibs_target == -1 } {\n+    return\n+}\n+\n+# Compile the main code (which loads the JIT objects).\n+if { [compile_jit_main ${main_srcfile} ${main_binfile} {}] != 0 } {\n+    return\n+}\n+\n+# Set up for the tests.\n+#\n+# detach-on-fork and follow-fork-mode are the values to use for the GDB\n+# parameters of the same names.\n+#\n+# Upon return, execution is stopped at the breakpoint just after fork.  Which\n+# inferiors exist and which inferior is the current one depends on the\n+# parameter.\n+#\n+# The only breakpoint left is one just before the return statement in main, so\n+# that the callers can continue execution until there.\n+\n+proc do_setup { detach-on-fork follow-fork-mode } {\n+\tclean_restart ${::main_binfile}\n+\n+\tgdb_test_no_output \"set detach-on-fork ${detach-on-fork}\"\n+\tgdb_test_no_output \"set follow-fork-mode ${follow-fork-mode}\"\n+\n+\tif { ![runto_main] } {\n+\t\tfail \"can't run to main\"\n+\t\treturn -1\n+\t}\n+\n+\t# Poke desired values directly into inferior.\n+\tgdb_test_no_output \"set var argc=2\" \"forging argc\"\n+\tgdb_test_no_output \"set var argv=fake_argv\" \"forging argv\"\n+\tset jit_solib_target [lindex $::jit_solibs_target 0]\n+\tgdb_test_no_output \"set var argv\\[1]=\\\"${jit_solib_target}\\\"\" {forging argv[1]}\n+\n+\t# Put a breakpoint before the fork, continue there.\n+\tgdb_breakpoint [gdb_get_line_number \"break before fork\" $::main_srcfile]\n+\tgdb_continue_to_breakpoint \"continue to before fork\" \".*break before fork.*\"\n+\n+\t# We should have one JIT object loaded.\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfiles before fork\"\n+\n+\t# Put a breakpoint just after the fork, continue there.\n+\tgdb_breakpoint [gdb_get_line_number \"break after fork\" $::main_srcfile]\n+\tgdb_continue_to_breakpoint \"continue to after fork\" \".*break after fork.*\"\n+\n+\t# We should still have one JIT object loaded in whatever inferior we are\n+\t# currently stopped in, regardless of the mode.\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfiles after fork\"\n+\n+\t# Delete our breakpoints.\n+\tdelete_breakpoints\n+\n+\t# Put a breakpoint before return, for the convenience of our callers.\n+\tgdb_breakpoint [gdb_get_line_number \"break before return\" $::main_srcfile]\n+}\n+\n+proc_with_prefix test_detach_on_fork_off_follow_fork_mode_parent { } {\n+\tif { [do_setup off parent] == -1 } {\n+\t\treturn -1\n+\t}\n+\n+\t# We are stopped in the parent.\n+\tgdb_test \"inferior\" \"Current inferior is 1.*\" \"current inferior is parent\"\n+\n+\t# Switch to the child, verify there is a JIT-ed objfile.\n+\tgdb_test \"inferior 2\" \"Switching to inferior 2.*\"\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfile in child\"\n+\n+\t# Continue child past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return - child\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles in child\"\n+\n+\t# Go back to parent, the JIT-ed objfile should still be there.\n+\tgdb_test \"inferior 1\" \"Switching to inferior 1.*\"\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfile in parent\"\n+\n+\t# Continue parent past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return - parent\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles in parent\"\n+}\n+\n+proc_with_prefix test_detach_on_fork_off_follow_fork_mode_child { } {\n+\tif { [do_setup off child] == -1 } {\n+\t\treturn -1\n+\t}\n+\n+\t# We are stopped in the child.  This is the exact same thing as\n+\t# test_detach_on_fork_off_follow_fork_mode_parent, except that we are\n+\t# stopped in the child.\n+\tgdb_test \"inferior\" \"Current inferior is 2.*\" \"current inferior is child\"\n+\n+\t# Switch to the parent, verify there is a JIT-ed objfile.\n+\tgdb_test \"inferior 1\" \"Switching to inferior 1.*\"\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfile in parent\"\n+\n+\t# Continue parent past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return - parent\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles in parent\"\n+\n+\t# Go back to child, the JIT-ed objfile should still be there.\n+\tgdb_test \"inferior 2\" \"Switching to inferior 2.*\"\n+\tgdb_test \"maint info jit\" \"  ${::hex}\" \"jit-ed objfile in child\"\n+\n+\t# Continue child past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return - child\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles in child\"\n+}\n+\n+proc_with_prefix test_detach_on_fork_on_follow_fork_mode_parent { } {\n+\tif { [do_setup on parent] == -1 } {\n+\t\treturn -1\n+\t}\n+\n+\t# We are stopped in the parent, child is detached.\n+\tgdb_test \"inferior\" \"Current inferior is 1.*\" \"current inferior is parent\"\n+\tgdb_test \"inferior 2\" \"Inferior ID 2 not known.\" \"no inferior 2\"\n+\n+\t# Continue past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles\"\n+}\n+\n+proc_with_prefix test_detach_on_fork_on_follow_fork_mode_child { } {\n+\tif { [do_setup on child] == -1 } {\n+\t\treturn -1\n+\t}\n+\n+\t# We are stopped in the child, parent is detached.\n+\tgdb_test \"inferior\" \"Current inferior is 2.*\" \"current inferior is child\"\n+\tgdb_test \"inferior 1\" \"Switching to inferior 1 \\\\\\[<null>\\\\\\].*\"\n+\tgdb_test \"inferior 2\" \"Switching to inferior 2.*\"\n+\n+\t# Continue past JIT unload, verify there are no more JIT-ed objfiles.\n+\tgdb_continue_to_breakpoint \"continue to before return\" \".*break before return.*\"\n+\tgdb_test_no_output \"maint info jit\" \"no more jit-ed objfiles\"\n+}\n+\n+test_detach_on_fork_off_follow_fork_mode_parent\n+test_detach_on_fork_off_follow_fork_mode_child\n+test_detach_on_fork_on_follow_fork_mode_parent\n+test_detach_on_fork_on_follow_fork_mode_child"
    }
  ]
}