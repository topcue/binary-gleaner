{
  "sha": "c3786b3aa311e7fba247623a98135d63d1d51c99",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzM3ODZiM2FhMzExZTdmYmEyNDc2MjNhOTgxMzVkNjNkMWQ1MWM5OQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-07-01T22:01:58Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-07-28T03:08:32Z"
    },
    "message": "A virtual terminal for the test suite\n\nThis patch implements a simple ANSI terminal emulator for the test\nsuite.  It is still quite basic, but it is good enough to allow some\nsimple TUI testing to be done.\n\ngdb/testsuite/ChangeLog\n2019-07-27  Tom Tromey  <tom@tromey.com>\n\n\t* lib/tuiterm.exp: New file.\n\t* gdb.tui/basic.exp: New file.",
    "tree": {
      "sha": "c1e9bccecce50041bba8fcfd254fd5df7eb8d851",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c1e9bccecce50041bba8fcfd254fd5df7eb8d851"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c3786b3aa311e7fba247623a98135d63d1d51c99",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c3786b3aa311e7fba247623a98135d63d1d51c99",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c3786b3aa311e7fba247623a98135d63d1d51c99",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c3786b3aa311e7fba247623a98135d63d1d51c99/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1c316af29ff2db118796de1486bf4e9673ac2922",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c316af29ff2db118796de1486bf4e9673ac2922",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1c316af29ff2db118796de1486bf4e9673ac2922"
    }
  ],
  "stats": {
    "total": 572,
    "additions": 572,
    "deletions": 0
  },
  "files": [
    {
      "sha": "f4c2d30fc06976bc668d4b7a22b6a98689d66492",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=c3786b3aa311e7fba247623a98135d63d1d51c99",
      "patch": "@@ -1,3 +1,8 @@\n+2019-07-27  Tom Tromey  <tom@tromey.com>\n+\n+\t* lib/tuiterm.exp: New file.\n+\t* gdb.tui/basic.exp: New file.\n+\n 2019-07-27  Kevin Buettner  <kevinb@redhat.com>\n \n \t* gdb.dwarf2/dw2-ranges-func.exp (enable_foo_cold_stepping):"
    },
    {
      "sha": "61dcacb7353c7f4b920ff44a8a88ab2a2b466d2d",
      "filename": "gdb/testsuite/gdb.tui/basic.exp",
      "status": "added",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/gdb.tui/basic.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/gdb.tui/basic.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.tui/basic.exp?ref=c3786b3aa311e7fba247623a98135d63d1d51c99",
      "patch": "@@ -0,0 +1,41 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Basic TUI tests.\n+\n+load_lib \"tuiterm.exp\"\n+\n+standard_testfile tui-layout.c\n+\n+if {[build_executable \"failed to prepare\" ${testfile} ${srcfile}] == -1} {\n+    return -1\n+}\n+\n+Term::clean_restart 24 80 $testfile\n+if {![Term::enter_tui]} {\n+    unsupported \"TUI not supported\"\n+}\n+\n+set text [Term::get_all_lines]\n+gdb_assert {![string match \"No Source Available\" $text]} \\\n+    \"initial source listing\"\n+\n+Term::command \"list main\"\n+Term::check_contents \"list main\" \"21 *return 0\"\n+\n+# This check fails because the file name in the title overwrites the\n+# box.\n+setup_xfail *-*-*\n+Term::check_box \"source box\" 3 0 77 15"
    },
    {
      "sha": "18772ea1112c69c1aaaa441d4c25e28f3e60e3a1",
      "filename": "gdb/testsuite/lib/tuiterm.exp",
      "status": "added",
      "additions": 526,
      "deletions": 0,
      "changes": 526,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/lib/tuiterm.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c3786b3aa311e7fba247623a98135d63d1d51c99/gdb/testsuite/lib/tuiterm.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/tuiterm.exp?ref=c3786b3aa311e7fba247623a98135d63d1d51c99",
      "patch": "@@ -0,0 +1,526 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# An ANSI terminal emulator for expect.\n+\n+namespace eval Term {\n+    variable _rows\n+    variable _cols\n+    variable _chars\n+\n+    variable _cur_x\n+    variable _cur_y\n+\n+    variable _attrs\n+\n+    variable _last_char\n+\n+    # If ARG is empty, return DEF: otherwise ARG.  This is useful for\n+    # defaulting arguments in CSIs.\n+    proc _default {arg def} {\n+\tif {$arg == \"\"} {\n+\t    return $def\n+\t}\n+\treturn $arg\n+    }\n+\n+    # Erase in the line Y from SX to just before EX.\n+    proc _clear_in_line {sx ex y} {\n+\tvariable _attrs\n+\tvariable _chars\n+\tset lattr [array get _attrs]\n+\twhile {$sx < $ex} {\n+\t    set _chars($sx,$y) [list \" \" $lattr]\n+\t    incr sx\n+\t}\n+    }\n+\n+    # Erase the lines from SY to just before EY.\n+    proc _clear_lines {sy ey} {\n+\tvariable _cols\n+\twhile {$sy < $ey} {\n+\t    _clear_in_line 0 $_cols $sy\n+\t    incr sy\n+\t}\n+    }\n+\n+    # Beep.\n+    proc _ctl_0x07 {} {\n+    }\n+\n+    # Backspace.\n+    proc _ctl_0x08 {} {\n+\tvariable _cur_x\n+\tincr _cur_x -1\n+\tif {$_cur_x < 0} {\n+\t    variable _cur_y\n+\t    variable _cols\n+\t    set _cur_x [expr {$_cols - 1}]\n+\t    incr _cur_y -1\n+\t    if {$_cur_y < 0} {\n+\t\tset _cur_y 0\n+\t    }\n+\t}\n+    }\n+\n+    # Linefeed.\n+    proc _ctl_0x0a {} {\n+\tvariable _cur_y\n+\tvariable _rows\n+\tincr _cur_y 1\n+\tif {$_cur_y >= $_rows} {\n+\t    error \"FIXME scroll\"\n+\t}\n+    }\n+\n+    # Carriage return.\n+    proc _ctl_0x0d {} {\n+\tvariable _cur_x\n+\tset _cur_x 0\n+    }\n+\n+    # Cursor Up.\n+    proc _csi_A {args} {\n+\tvariable _cur_y\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_y [expr {max ($_cur_y - $arg, 0)}]\n+    }\n+\n+    # Cursor Down.\n+    proc _csi_B {args} {\n+\tvariable _cur_y\n+\tvariable _rows\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_y [expr {min ($_cur_y + $arg, $_rows)}]\n+    }\n+\n+    # Cursor Forward.\n+    proc _csi_C {args} {\n+\tvariable _cur_x\n+\tvariable _cols\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_x [expr {min ($_cur_x + $arg, $_cols)}]\n+    }\n+\n+    # Cursor Back.\n+    proc _csi_D {args} {\n+\tvariable _cur_x\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_x [expr {max ($_cur_x - $arg, 0)}]\n+    }\n+\n+    # Cursor Next Line.\n+    proc _csi_E {args} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _rows\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_x 0\n+\tset _cur_y [expr {min ($_cur_y + $arg, $_rows)}]\n+    }\n+\n+    # Cursor Previous Line.\n+    proc _csi_F {args} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _rows\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_x 0\n+\tset _cur_y [expr {max ($_cur_y - $arg, 0)}]\n+    }\n+\n+    # Cursor Horizontal Absolute.\n+    proc _csi_G {args} {\n+\tvariable _cur_x\n+\tvariable _cols\n+\tset arg [_default [lindex $args 0] 1]\n+\tset _cur_x [expr {min ($arg - 1, $_cols)}]\n+    }\n+\n+    # Move cursor (don't know the official name of this one).\n+    proc _csi_H {args} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tset _cur_y [expr {[_default [lindex $args 0] 1] - 1}]\n+\tset _cur_x [expr {[_default [lindex $args 1] 1] - 1}]\n+    }\n+\n+    # Cursor Forward Tabulation.\n+    proc _csi_I {args} {\n+\tset n [_default [lindex $args 0] 1]\n+\tvariable _cur_x\n+\tvariable _cols\n+\tincr _cur_x [expr {$n * 8 - $_cur_x % 8}]\n+\tif {$_cur_x >= $_cols} {\n+\t    set _cur_x [expr {$_cols - 1}]\n+\t}\n+    }\n+\n+    # Erase.\n+    proc _csi_J {args} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _rows\n+\tvariable _cols\n+\tset arg [_default [lindex $args 0] 0]\n+\tif {$arg == 0} {\n+\t    _clear_in_line $_cur_x $_cols $_cur_y\n+\t    _clear_lines [expr {$_cur_y + 1}] $_rows\n+\t} elseif {$arg == 1} {\n+\t    _clear_lines 0 [expr {$_cur_y - 1}]\n+\t    _clear_in_line 0 $_cur_x $_cur_y\n+\t} elseif {$arg == 2} {\n+\t    _clear_lines 0 $_rows\n+\t}\n+    }\n+\n+    # Erase Line.\n+    proc _csi_K {args} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _cols\n+\tset arg [_default [lindex $args 0] 0]\n+\tif {$arg == 0} {\n+\t    # From cursor to end.\n+\t    _clear_in_line $_cur_x $_cols $_cur_y\n+\t} elseif {$arg == 1} {\n+\t    _clear_in_line 0 $_cur_x $_cur_y\n+\t} elseif {$arg == 2} {\n+\t    _clear_in_line 0 $_cols $_cur_y\n+\t}\n+    }\n+\n+    # Delete lines.\n+    proc _csi_M {args} {\n+\tvariable _cur_y\n+\tvariable _rows\n+\tvariable _cols\n+\tvariable _chars\n+\tset count [_default [lindex $args 0] 1]\n+\tset y $_cur_y\n+\tset next_y [expr {$y + 1}]\n+\twhile {$count > 0 && $next_y < $_rows} {\n+\t    for {set x 0} {$x < $_cols} {incr x} {\n+\t\tset _chars($x,$y) $_chars($x,$next_y)\n+\t    }\n+\t    incr y\n+\t    incr next_y\n+\t    incr count -1\n+\t}\n+\t_clear_lines $next_y $_rows\n+    }\n+\n+    # Erase chars.\n+    proc _csi_X {args} {\n+\tset n [_default [lindex $args 0] 1]\n+\t_insert [string repeat \" \" $n]\n+    }\n+\n+    # Repeat.\n+    proc _csi_b {args} {\n+\tvariable _last_char\n+\tset n [_default [lindex $args 0] 1]\n+\t_insert [string repeat $_last_char $n]\n+    }\n+\n+    # Line Position Absolute.\n+    proc _csi_d {args} {\n+\tvariable _cur_y\n+\tset _cur_y [expr {[_default [lindex $args 0] 1] - 1}]\n+    }\n+\n+    # Select Graphic Rendition.\n+    proc _csi_m {args} {\n+\tvariable _attrs\n+\tforeach item $args {\n+\t    switch -exact -- $item {\n+\t\t\"\" - 0 {\n+\t\t    set _attrs(intensity) normal\n+\t\t    set _attrs(fg) default\n+\t\t    set _attrs(bg) default\n+\t\t    set _attrs(underline) 0\n+\t\t    set _attrs(reverse) 0\n+\t\t}\n+\t\t1 {\n+\t\t    set _attrs(intensity) bold\n+\t\t}\n+\t\t2 {\n+\t\t    set _attrs(intensity) dim\n+\t\t}\n+\t\t4 {\n+\t\t    set _attrs(underline) 1\n+\t\t}\n+\t\t7 {\n+\t\t    set _attrs(reverse) 1\n+\t\t}\n+\t\t22 {\n+\t\t    set _attrs(intensity) normal\n+\t\t}\n+\t\t24 {\n+\t\t    set _attrs(underline) 0\n+\t\t}\n+\t\t27 {\n+\t\t    set _attrs(reverse) 1\n+\t\t}\n+\t\t30 - 31 - 32 - 33 - 34 - 35 - 36 - 37 {\n+\t\t    set _attrs(fg) $item\n+\t\t}\n+\t\t39 {\n+\t\t    set _attrs(fg) default\n+\t\t}\n+\t\t40 - 41 - 42 - 43 - 44 - 45 - 46 - 47 {\n+\t\t    set _attrs(bg) $item\n+\t\t}\n+\t\t49 {\n+\t\t    set _attrs(bg) default\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    # Insert string at the cursor location.\n+    proc _insert {str} {\n+\tverbose \"INSERT <<$str>>\"\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _rows\n+\tvariable _cols\n+\tvariable _attrs\n+\tvariable _chars\n+\tset lattr [array get _attrs]\n+\tforeach char [split $str {}] {\n+\t    set _chars($_cur_x,$_cur_y) [list $char $lattr]\n+\t    incr _cur_x\n+\t    if {$_cur_x >= $_cols} {\n+\t\tset _cur_x 0\n+\t\tincr _cur_y\n+\t\tif {$_cur_y >= $_rows} {\n+\t\t    error \"FIXME scroll\"\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    # Initialize.\n+    proc _setup {rows cols} {\n+\tglobal stty_init\n+\tset stty_init \"rows $rows columns $cols\"\n+\n+\tvariable _rows\n+\tvariable _cols\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\tvariable _attrs\n+\n+\tset _rows $rows\n+\tset _cols $cols\n+\tset _cur_x 0\n+\tset _cur_y 0\n+\tarray set _attrs {\n+\t    intensity normal\n+\t    fg default\n+\t    bg default\n+\t    underline 0\n+\t    reverse 0\n+\t}\n+\n+\t_clear_lines 0 $_rows\n+    }\n+\n+    # Accept some output from gdb and update the screen.\n+    proc _accept {} {\n+\tglobal expect_out\n+\tgdb_expect {\n+\t    -re \"^\\[\\x07\\x08\\x0a\\x0d\\]\" {\n+\t\tscan $expect_out(0,string) %c val\n+\t\tset hexval [format \"%02x\" $val]\n+\t\tverbose \"+++ _ctl_0x${hexval}\"\n+\t\t_ctl_0x${hexval}\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\x1b(\\[0-9a-zA-Z\\])\" {\n+\t\tverbose \"+++ unsupported escape\"\n+\t\terror \"unsupported escape\"\n+\t    }\n+\t    -re \"^\\x1b\\\\\\[(\\[0-9;\\]*)(\\[0-9a-zA-Z@\\])\" {\n+\t\tset cmd $expect_out(2,string)\n+\t\tset params [split $expect_out(1,string) \";\"]\n+\t\tverbose \"+++ _csi_$cmd <<<$expect_out(1,string)>>>\"\n+\t\teval _csi_$cmd $params\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\[^\\x07\\x08\\x0a\\x0d\\x1b\\]+\" {\n+\t\t_insert $expect_out(0,string)\n+\t\tvariable _last_char\n+\t\tset _last_char [string index $expect_out(0,string) end]\n+\t\t# If the prompt was just inserted, return.\n+\t\tvariable _cur_x\n+\t\tvariable _cur_y\n+\t\tglobal gdb_prompt\n+\t\tset prev [get_line $_cur_y $_cur_x]\n+\t\tif {![regexp -- \"$gdb_prompt \\$\" $prev]} {\n+\t\t    exp_continue\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+    # Like ::clean_restart, but ensures that gdb starts in an\n+    # environment where the TUI can work.  ROWS and COLS are the size\n+    # of the terminal.  EXECUTABLE is passed to clean_restart.\n+    proc clean_restart {rows cols executable} {\n+\tglobal env stty_init\n+\tsave_vars {env(TERM) stty_init} {\n+\t    setenv TERM ansi\n+\t    _setup $rows $cols\n+\t    ::clean_restart $executable\n+\t}\n+    }\n+\n+    # Start the TUI.  Returns 1 on success, 0 if TUI tests should be\n+    # skipped.\n+    proc enter_tui {} {\n+\tif {[skip_tui_tests]} {\n+\t    return 0\n+\t}\n+\n+\tgdb_test_no_output \"set tui border-kind ascii\"\n+\tcommand \"tui enable\"\n+\treturn 1\n+    }\n+\n+    # Send the command CMD to gdb, then wait for a gdb prompt to be\n+    # seen in the TUI.  CMD should not end with a newline -- that will\n+    # be supplied by this function.\n+    proc command {cmd} {\n+\tsend_gdb \"$cmd\\n\"\n+\t_accept\n+    }\n+\n+    # Return the text of screen line N, without attributes.  Lines are\n+    # 0-based.  If C is given, stop before column C.  Columns are also\n+    # zero-based.\n+    proc get_line {n {c \"\"}} {\n+\tset result \"\"\n+\tvariable _cols\n+\tvariable _chars\n+\tset c [_default $c $_cols]\n+\tset x 0\n+\twhile {$x < $c} {\n+\t    append result [lindex $_chars($x,$n) 0]\n+\t    incr x\n+\t}\n+\treturn $result\n+    }\n+\n+    # Get just the character at (X, Y).\n+    proc get_char {x y} {\n+\tvariable _chars\n+\treturn [lindex $_chars($x,$y) 0]\n+    }\n+\n+    # Get the entire screen as a string.\n+    proc get_all_lines {} {\n+\tvariable _rows\n+\tvariable _cols\n+\tvariable _chars\n+\n+\tset result \"\"\n+\tfor {set y 0} {$y < $_rows} {incr y} {\n+\t    for {set x 0} {$x < $_cols} {incr x} {\n+\t\tappend result [lindex $_chars($x,$y) 0]\n+\t    }\n+\t    append result \"\\n\"\n+\t}\n+\n+\treturn $result\n+    }\n+\n+    # Get the text just before the cursor.\n+    proc get_current_line {} {\n+\tvariable _cur_x\n+\tvariable _cur_y\n+\treturn [get_line $_cur_y $_cur_x]\n+    }\n+\n+    # Helper function for check_box.  Returns empty string if the box\n+    # is found, description of why not otherwise.\n+    proc _check_box {x y width height} {\n+\tset x2 [expr {$x + $width - 1}]\n+\tset y2 [expr {$y + $height - 1}]\n+\n+\tif {[get_char $x $y] != \"+\"} {\n+\t    return \"ul corner\"\n+\t}\n+\tif {[get_char $x $y2] != \"+\"} {\n+\t    return \"ll corner\"\n+\t}\n+\tif {[get_char $x2 $y] != \"+\"} {\n+\t    return \"ur corner\"\n+\t}\n+\tif {[get_char $x2 $y2] != \"+\"} {\n+\t    return \"lr corner\"\n+\t}\n+\n+\tfor {set i [expr {$x + 1}]} {$i < $x2 - 1} {incr i} {\n+\t    # Note we do not check the top border of the box, because\n+\t    # it will contain a title.\n+\t    if {[get_char $i $y2] != \"-\"} {\n+\t\treturn \"bottom border $i\"\n+\t    }\n+\t}\n+\tfor {set i [expr {$y + 1}]} {$i < $y2 - 1} {incr i} {\n+\t    if {[get_char $x $i] != \"|\"} {\n+\t\treturn \"left side $i\"\n+\t    }\n+\t    if {[get_char $x2 $i] != \"|\"} {\n+\t\treturn \"right side $i\"\n+\t    }\n+\t}\n+\n+\treturn \"\"\n+    }\n+\n+    # Check for a box at the given coordinates.\n+    proc check_box {test_name x y width height} {\n+\tset why [_check_box $x $y $width $height]\n+\tif {$why == \"\"} {\n+\t    pass $test_name\n+\t} else {\n+\t    dump_screen\n+\t    fail \"$test_name ($why)\"\n+\t}\n+    }\n+\n+    # Check whether the text contents of the terminal match the\n+    # regular expression.  Note that text styling is not considered.\n+    proc check_contents {test_name regexp} {\n+\tset contents [get_all_lines]\n+\tif {![gdb_assert {[regexp -- $regexp $contents]} $test_name]} {\n+\t    dump_screen\n+\t}\n+    }\n+\n+    # A debugging function to dump the current screen, with line\n+    # numbers.\n+    proc dump_screen {} {\n+\tvariable _rows\n+\tverbose \"Screen Dump:\"\n+\tfor {set y 0} {$y < $_rows} {incr y} {\n+\t    set fmt [format %5d $y]\n+\t    verbose \"$fmt [get_line $y]\"\n+\t}\n+    }\n+}"
    }
  ]
}