{
  "sha": "629310abec8811510177101f3c7992dfd4be24dd",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjI5MzEwYWJlYzg4MTE1MTAxNzcxMDFmM2M3OTkyZGZkNGJlMjRkZA==",
  "commit": {
    "author": {
      "name": "Martin Liska",
      "email": "mliska@suse.cz",
      "date": "2020-08-18T08:57:21Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-20T01:26:07Z"
    },
    "message": "Port gas/config/* to str_htab.\n\n\t* config/obj-coff-seh.c (seh_hash_insert): Port to use new\n\tstr_htab type.\n\t(seh_hash_find): Likewise.\n\t(seh_hash_find_or_make): Likewise.\n\t* config/obj-coff.c (tag_init): Likewise.\n\t(tag_insert): Likewise.\n\t(tag_find): Likewise.\n\t* config/obj-elf.c (struct group_list): Likewise.\n\t(build_additional_section_info): Likewise.\n\t(free_section_idx): Likewise.\n\t(elf_adjust_symtab): Likewise.\n\t(elf_frob_file_after_relocs): Likewise.\n\t* config/tc-aarch64.c (INSN_SIZE): Likewise.\n\t(parse_reg): Likewise.\n\t(insert_reg_alias): Likewise.\n\t(create_register_alias): Likewise.\n\t(s_unreq): Likewise.\n\t(parse_shift): Likewise.\n\t(parse_pldop): Likewise.\n\t(parse_barrier): Likewise.\n\t(parse_barrier_psb): Likewise.\n\t(parse_bti_operand): Likewise.\n\t(parse_sys_reg): Likewise.\n\t(parse_sys_ins_reg): Likewise.\n\t(lookup_mnemonic): Likewise.\n\t(opcode_lookup): Likewise.\n\t(parse_operands): Likewise.\n\t(checked_hash_insert): Likewise.\n\t(sysreg_hash_insert): Likewise.\n\t(fill_instruction_hash_table): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-alpha.c (struct alpha_reloc_tag): Likewise.\n\t(get_alpha_reloc_tag): Likewise.\n\t(assemble_tokens_to_insn): Likewise.\n\t(assemble_tokens): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-arc.c (arc_find_opcode): Likewise.\n\t(arc_insert_opcode): Likewise.\n\t(find_opcode_match): Likewise.\n\t(declare_register): Likewise.\n\t(declare_addrtype): Likewise.\n\t(md_begin): Likewise.\n\t(arc_parse_name): Likewise.\n\t(tc_arc_regname_to_dw2regnum): Likewise.\n\t(arc_extcorereg): Likewise.\n\t* config/tc-arm.c (MVE_BAD_QREG): Likewise.\n\t(arm_reg_parse_multi): Likewise.\n\t(parse_reloc): Likewise.\n\t(insert_reg_alias): Likewise.\n\t(create_register_alias): Likewise.\n\t(s_unreq): Likewise.\n\t(parse_shift): Likewise.\n\t(parse_psr): Likewise.\n\t(parse_cond): Likewise.\n\t(parse_barrier): Likewise.\n\t(do_vfp_nsyn_opcode): Likewise.\n\t(opcode_lookup): Likewise.\n\t(arm_tc_equal_in_insn): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-avr.c (md_begin): Likewise.\n\t(avr_ldi_expression): Likewise.\n\t(md_assemble): Likewise.\n\t(avr_update_gccisr): Likewise.\n\t(avr_emit_insn): Likewise.\n\t* config/tc-cr16.c (get_register): Likewise.\n\t(get_register_pair): Likewise.\n\t(get_index_register): Likewise.\n\t(get_index_register_pair): Likewise.\n\t(get_pregister): Likewise.\n\t(get_pregisterp): Likewise.\n\t(initialise_reg_hash_table): Likewise.\n\t(md_begin): Likewise.\n\t(cr16_assemble): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-cris.c (cris_insn_first_word_frag): Likewise.\n\t(md_begin): Likewise.\n\t(cris_process_instruction): Likewise.\n\t* config/tc-crx.c (get_register): Likewise.\n\t(get_copregister): Likewise.\n\t(md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-csky.c (md_begin): Likewise.\n\t(parse_opcode): Likewise.\n\t(get_operand_value): Likewise.\n\t(v1_work_jbsr): Likewise.\n\t(v2_work_rotlc): Likewise.\n\t(v2_work_bgeni): Likewise.\n\t(v2_work_not): Likewise.\n\t* config/tc-d10v.c (sizeof): Likewise.\n\t(md_begin): Likewise.\n\t(do_assemble): Likewise.\n\t(md_apply_fix): Likewise.\n\t* config/tc-d30v.c (sizeof): Likewise.\n\t(md_begin): Likewise.\n\t(do_assemble): Likewise.\n\t* config/tc-dlx.c (RELOC_DLX_VTENTRY): Likewise.\n\t(md_begin): Likewise.\n\t(machine_ip): Likewise.\n\t* config/tc-ft32.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-h8300.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-hppa.c (pa_ip): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-i386.c (md_begin): Likewise.\n\t(i386_print_statistics): Likewise.\n\t(parse_insn): Likewise.\n\t(process_operands): Likewise.\n\t(i386_index_check): Likewise.\n\t(parse_real_register): Likewise.\n\t* config/tc-ia64.c (dot_rot): Likewise.\n\t(dot_entry): Likewise.\n\t(declare_register): Likewise.\n\t(md_begin): Likewise.\n\t(ia64_parse_name): Likewise.\n\t(md_assemble): Likewise.\n\t(dot_alias): Likewise.\n\t(do_alias): Likewise.\n\t(ia64_adjust_symtab): Likewise.\n\t(do_secalias): Likewise.\n\t(ia64_frob_file): Likewise.\n\t* config/tc-m68hc11.c (m68hc11_print_statistics): Likewise.\n\t(md_begin): Likewise.\n\t(print_insn_format): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-m68k.c (tc_gen_reloc): Likewise.\n\t(m68k_ip): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-mcore.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-microblaze.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t(md_apply_fix): Likewise.\n\t* config/tc-mips.c (nopic_need_relax): Likewise.\n\t(md_begin): Likewise.\n\t(macro_build): Likewise.\n\t(mips16_macro_build): Likewise.\n\t(mips_lookup_insn): Likewise.\n\t(mips_ip): Likewise.\n\t(mips16_ip): Likewise.\n\t* config/tc-mmix.c (sizeof): Likewise.\n\t(mmix_md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-mn10200.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-mn10300.c (HAVE_AM30): Likewise.\n\t(md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-moxie.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-msp430.c (md_begin): Likewise.\n\t(msp430_operands): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-nds32.c (PV_DONT_CARE): Likewise.\n\t(builtin_isreg): Likewise.\n\t(builtin_regnum): Likewise.\n\t(nds32_init_nds32_pseudo_opcodes): Likewise.\n\t(nds32_lookup_pseudo_opcode): Likewise.\n\t(nds32_relax_hint): Likewise.\n\t(md_begin): Likewise.\n\t(nds32_find_reloc_table): Likewise.\n\t(nds32_elf_append_relax_relocs_traverse): Likewise.\n\t(nds32_relax_branch_instructions): Likewise.\n\t(md_convert_frag): Likewise.\n\t(nds32_elf_analysis_relax_hint): Likewise.\n\t(tc_nds32_regname_to_dw2regnum): Likewise.\n\t* config/tc-nios2.c (nios2_opcode_lookup): Likewise.\n\t(nios2_reg_lookup): Likewise.\n\t(nios2_ps_lookup): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-ns32k.c (struct hash_control): Likewise.\n\t(parse): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-pdp11.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-pj.c (fake_opcode): Likewise.\n\t(alias): Likewise.\n\t(md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-ppc.c (ppc_setup_opcodes): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-pru.c (pru_opcode_lookup): Likewise.\n\t(pru_reg_lookup): Likewise.\n\t(md_begin): Likewise.\n\t(md_end): Likewise.\n\t* config/tc-riscv.c (init_ext_version_hash): Likewise.\n\t(riscv_get_default_ext_version): Likewise.\n\t(riscv_set_arch): Likewise.\n\t(init_opcode_names_hash): Likewise.\n\t(opcode_name_lookup): Likewise.\n\t(enum reg_class): Likewise.\n\t(hash_reg_name): Likewise.\n\t(riscv_init_csr_hash): Likewise.\n\t(reg_csr_lookup_internal): Likewise.\n\t(reg_lookup_internal): Likewise.\n\t(init_opcode_hash): Likewise.\n\t(md_begin): Likewise.\n\t(DECLARE_CSR): Likewise.\n\t(macro_build): Likewise.\n\t(riscv_ip): Likewise.\n\t* config/tc-s390.c (register_name): Likewise.\n\t(s390_setup_opcodes): Likewise.\n\t(md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t(s390_insn): Likewise.\n\t* config/tc-score.c (struct s3_reg_map): Likewise.\n\t(s3_score_reg_parse): Likewise.\n\t(s3_dependency_type_from_insn): Likewise.\n\t(s3_parse_16_32_inst): Likewise.\n\t(s3_parse_48_inst): Likewise.\n\t(s3_insert_reg): Likewise.\n\t(s3_build_reg_hsh): Likewise.\n\t(s3_build_score_ops_hsh): Likewise.\n\t(s3_build_dependency_insn_hsh): Likewise.\n\t(s3_begin): Likewise.\n\t* config/tc-score7.c (struct s7_reg_map): Likewise.\n\t(s7_score_reg_parse): Likewise.\n\t(s7_dependency_type_from_insn): Likewise.\n\t(s7_parse_16_32_inst): Likewise.\n\t(s7_build_score_ops_hsh): Likewise.\n\t(s7_build_dependency_insn_hsh): Likewise.\n\t(s7_insert_reg): Likewise.\n\t(s7_build_reg_hsh): Likewise.\n\t(s7_begin): Likewise.\n\t* config/tc-sh.c (EMPTY): Likewise.\n\t(md_begin): Likewise.\n\t(find_cooked_opcode): Likewise.\n\t* config/tc-sparc.c (md_begin): Likewise.\n\t(sparc_ip): Likewise.\n\t* config/tc-spu.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-tic30.c (md_begin): Likewise.\n\t(tic30_operand): Likewise.\n\t(tic30_parallel_insn): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-tic4x.c (TIC4X_ALT_SYNTAX): Likewise.\n\t(tic4x_asg): Likewise.\n\t(tic4x_inst_insert): Likewise.\n\t(tic4x_inst_add): Likewise.\n\t(md_begin): Likewise.\n\t(tic4x_operand_parse): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-tic54x.c (MAX_SUBSYM_HASH): Likewise.\n\t(stag_add_field_symbols): Likewise.\n\t(tic54x_endstruct): Likewise.\n\t(tic54x_tag): Likewise.\n\t(tic54x_remove_local_label): Likewise.\n\t(tic54x_clear_local_labels): Likewise.\n\t(tic54x_var): Likewise.\n\t(tic54x_macro_start): Likewise.\n\t(tic54x_macro_info): Likewise.\n\t(tic54x_macro_end): Likewise.\n\t(subsym_isreg): Likewise.\n\t(subsym_structsz): Likewise.\n\t(md_begin): Likewise.\n\t(is_mmreg): Likewise.\n\t(is_type): Likewise.\n\t(encode_condition): Likewise.\n\t(encode_cc3): Likewise.\n\t(encode_cc2): Likewise.\n\t(encode_operand): Likewise.\n\t(tic54x_parse_insn): Likewise.\n\t(tic54x_parse_parallel_insn_firstline): Likewise.\n\t(subsym_create_or_replace): Likewise.\n\t(subsym_lookup): Likewise.\n\t(subsym_substitute): Likewise.\n\t(tic54x_undefined_symbol): Likewise.\n\t* config/tc-tic6x.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-tilegx.c (O_hw2_last_plt): Likewise.\n\t(INSERT_SPECIAL_OP): Likewise.\n\t(md_begin): Likewise.\n\t(tilegx_parse_name): Likewise.\n\t(parse_reg_expression): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-tilepro.c (O_tls_ie_load): Likewise.\n\t(INSERT_SPECIAL_OP): Likewise.\n\t(tilepro_parse_name): Likewise.\n\t(parse_reg_expression): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-v850.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-vax.c (md_ri_to_chars): Likewise.\n\t(vip_begin): Likewise.\n\t(vip): Likewise.\n\t(main): Likewise.\n\t(md_begin): Likewise.\n\t* config/tc-wasm32.c (md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-xgate.c (xgate_parse_operand): Likewise.\n\t(md_begin): Likewise.\n\t(md_assemble): Likewise.\n\t* config/tc-z8k.c (md_begin): Likewise.\n\t(md_assemble): Likewise.",
    "tree": {
      "sha": "d8de5773b66f877c3f8a7ddb9a4bd27d1a4705fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d8de5773b66f877c3f8a7ddb9a4bd27d1a4705fa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/629310abec8811510177101f3c7992dfd4be24dd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/629310abec8811510177101f3c7992dfd4be24dd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/629310abec8811510177101f3c7992dfd4be24dd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/629310abec8811510177101f3c7992dfd4be24dd/comments",
  "author": {
    "login": "marxin",
    "id": 2658545,
    "node_id": "MDQ6VXNlcjI2NTg1NDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/marxin",
    "html_url": "https://github.com/marxin",
    "followers_url": "https://api.github.com/users/marxin/followers",
    "following_url": "https://api.github.com/users/marxin/following{/other_user}",
    "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/marxin/subscriptions",
    "organizations_url": "https://api.github.com/users/marxin/orgs",
    "repos_url": "https://api.github.com/users/marxin/repos",
    "events_url": "https://api.github.com/users/marxin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/marxin/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "494b2fc8078502f84a2ff2a3402a5989b221526d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/494b2fc8078502f84a2ff2a3402a5989b221526d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/494b2fc8078502f84a2ff2a3402a5989b221526d"
    }
  ],
  "stats": {
    "total": 2328,
    "additions": 1114,
    "deletions": 1214
  },
  "files": [
    {
      "sha": "b2c8b983db2dcc47d9675e3a2be38afb1bd39506",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 297,
      "deletions": 0,
      "changes": 297,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -1,3 +1,300 @@\n+2020-08-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* config/obj-coff-seh.c (seh_hash_insert): Port to use new\n+\tstr_htab type.\n+\t(seh_hash_find): Likewise.\n+\t(seh_hash_find_or_make): Likewise.\n+\t* config/obj-coff.c (tag_init): Likewise.\n+\t(tag_insert): Likewise.\n+\t(tag_find): Likewise.\n+\t* config/obj-elf.c (struct group_list): Likewise.\n+\t(build_additional_section_info): Likewise.\n+\t(free_section_idx): Likewise.\n+\t(elf_adjust_symtab): Likewise.\n+\t(elf_frob_file_after_relocs): Likewise.\n+\t* config/tc-aarch64.c (INSN_SIZE): Likewise.\n+\t(parse_reg): Likewise.\n+\t(insert_reg_alias): Likewise.\n+\t(create_register_alias): Likewise.\n+\t(s_unreq): Likewise.\n+\t(parse_shift): Likewise.\n+\t(parse_pldop): Likewise.\n+\t(parse_barrier): Likewise.\n+\t(parse_barrier_psb): Likewise.\n+\t(parse_bti_operand): Likewise.\n+\t(parse_sys_reg): Likewise.\n+\t(parse_sys_ins_reg): Likewise.\n+\t(lookup_mnemonic): Likewise.\n+\t(opcode_lookup): Likewise.\n+\t(parse_operands): Likewise.\n+\t(checked_hash_insert): Likewise.\n+\t(sysreg_hash_insert): Likewise.\n+\t(fill_instruction_hash_table): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-alpha.c (struct alpha_reloc_tag): Likewise.\n+\t(get_alpha_reloc_tag): Likewise.\n+\t(assemble_tokens_to_insn): Likewise.\n+\t(assemble_tokens): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-arc.c (arc_find_opcode): Likewise.\n+\t(arc_insert_opcode): Likewise.\n+\t(find_opcode_match): Likewise.\n+\t(declare_register): Likewise.\n+\t(declare_addrtype): Likewise.\n+\t(md_begin): Likewise.\n+\t(arc_parse_name): Likewise.\n+\t(tc_arc_regname_to_dw2regnum): Likewise.\n+\t(arc_extcorereg): Likewise.\n+\t* config/tc-arm.c (MVE_BAD_QREG): Likewise.\n+\t(arm_reg_parse_multi): Likewise.\n+\t(parse_reloc): Likewise.\n+\t(insert_reg_alias): Likewise.\n+\t(create_register_alias): Likewise.\n+\t(s_unreq): Likewise.\n+\t(parse_shift): Likewise.\n+\t(parse_psr): Likewise.\n+\t(parse_cond): Likewise.\n+\t(parse_barrier): Likewise.\n+\t(do_vfp_nsyn_opcode): Likewise.\n+\t(opcode_lookup): Likewise.\n+\t(arm_tc_equal_in_insn): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-avr.c (md_begin): Likewise.\n+\t(avr_ldi_expression): Likewise.\n+\t(md_assemble): Likewise.\n+\t(avr_update_gccisr): Likewise.\n+\t(avr_emit_insn): Likewise.\n+\t* config/tc-cr16.c (get_register): Likewise.\n+\t(get_register_pair): Likewise.\n+\t(get_index_register): Likewise.\n+\t(get_index_register_pair): Likewise.\n+\t(get_pregister): Likewise.\n+\t(get_pregisterp): Likewise.\n+\t(initialise_reg_hash_table): Likewise.\n+\t(md_begin): Likewise.\n+\t(cr16_assemble): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-cris.c (cris_insn_first_word_frag): Likewise.\n+\t(md_begin): Likewise.\n+\t(cris_process_instruction): Likewise.\n+\t* config/tc-crx.c (get_register): Likewise.\n+\t(get_copregister): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-csky.c (md_begin): Likewise.\n+\t(parse_opcode): Likewise.\n+\t(get_operand_value): Likewise.\n+\t(v1_work_jbsr): Likewise.\n+\t(v2_work_rotlc): Likewise.\n+\t(v2_work_bgeni): Likewise.\n+\t(v2_work_not): Likewise.\n+\t* config/tc-d10v.c (sizeof): Likewise.\n+\t(md_begin): Likewise.\n+\t(do_assemble): Likewise.\n+\t(md_apply_fix): Likewise.\n+\t* config/tc-d30v.c (sizeof): Likewise.\n+\t(md_begin): Likewise.\n+\t(do_assemble): Likewise.\n+\t* config/tc-dlx.c (RELOC_DLX_VTENTRY): Likewise.\n+\t(md_begin): Likewise.\n+\t(machine_ip): Likewise.\n+\t* config/tc-ft32.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-h8300.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-hppa.c (pa_ip): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-i386.c (md_begin): Likewise.\n+\t(i386_print_statistics): Likewise.\n+\t(parse_insn): Likewise.\n+\t(process_operands): Likewise.\n+\t(i386_index_check): Likewise.\n+\t(parse_real_register): Likewise.\n+\t* config/tc-ia64.c (dot_rot): Likewise.\n+\t(dot_entry): Likewise.\n+\t(declare_register): Likewise.\n+\t(md_begin): Likewise.\n+\t(ia64_parse_name): Likewise.\n+\t(md_assemble): Likewise.\n+\t(dot_alias): Likewise.\n+\t(do_alias): Likewise.\n+\t(ia64_adjust_symtab): Likewise.\n+\t(do_secalias): Likewise.\n+\t(ia64_frob_file): Likewise.\n+\t* config/tc-m68hc11.c (m68hc11_print_statistics): Likewise.\n+\t(md_begin): Likewise.\n+\t(print_insn_format): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-m68k.c (tc_gen_reloc): Likewise.\n+\t(m68k_ip): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-mcore.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-microblaze.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t(md_apply_fix): Likewise.\n+\t* config/tc-mips.c (nopic_need_relax): Likewise.\n+\t(md_begin): Likewise.\n+\t(macro_build): Likewise.\n+\t(mips16_macro_build): Likewise.\n+\t(mips_lookup_insn): Likewise.\n+\t(mips_ip): Likewise.\n+\t(mips16_ip): Likewise.\n+\t* config/tc-mmix.c (sizeof): Likewise.\n+\t(mmix_md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-mn10200.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-mn10300.c (HAVE_AM30): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-moxie.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-msp430.c (md_begin): Likewise.\n+\t(msp430_operands): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-nds32.c (PV_DONT_CARE): Likewise.\n+\t(builtin_isreg): Likewise.\n+\t(builtin_regnum): Likewise.\n+\t(nds32_init_nds32_pseudo_opcodes): Likewise.\n+\t(nds32_lookup_pseudo_opcode): Likewise.\n+\t(nds32_relax_hint): Likewise.\n+\t(md_begin): Likewise.\n+\t(nds32_find_reloc_table): Likewise.\n+\t(nds32_elf_append_relax_relocs_traverse): Likewise.\n+\t(nds32_relax_branch_instructions): Likewise.\n+\t(md_convert_frag): Likewise.\n+\t(nds32_elf_analysis_relax_hint): Likewise.\n+\t(tc_nds32_regname_to_dw2regnum): Likewise.\n+\t* config/tc-nios2.c (nios2_opcode_lookup): Likewise.\n+\t(nios2_reg_lookup): Likewise.\n+\t(nios2_ps_lookup): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-ns32k.c (struct hash_control): Likewise.\n+\t(parse): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-pdp11.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-pj.c (fake_opcode): Likewise.\n+\t(alias): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-ppc.c (ppc_setup_opcodes): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-pru.c (pru_opcode_lookup): Likewise.\n+\t(pru_reg_lookup): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_end): Likewise.\n+\t* config/tc-riscv.c (init_ext_version_hash): Likewise.\n+\t(riscv_get_default_ext_version): Likewise.\n+\t(riscv_set_arch): Likewise.\n+\t(init_opcode_names_hash): Likewise.\n+\t(opcode_name_lookup): Likewise.\n+\t(enum reg_class): Likewise.\n+\t(hash_reg_name): Likewise.\n+\t(riscv_init_csr_hash): Likewise.\n+\t(reg_csr_lookup_internal): Likewise.\n+\t(reg_lookup_internal): Likewise.\n+\t(init_opcode_hash): Likewise.\n+\t(md_begin): Likewise.\n+\t(DECLARE_CSR): Likewise.\n+\t(macro_build): Likewise.\n+\t(riscv_ip): Likewise.\n+\t* config/tc-s390.c (register_name): Likewise.\n+\t(s390_setup_opcodes): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t(s390_insn): Likewise.\n+\t* config/tc-score.c (struct s3_reg_map): Likewise.\n+\t(s3_score_reg_parse): Likewise.\n+\t(s3_dependency_type_from_insn): Likewise.\n+\t(s3_parse_16_32_inst): Likewise.\n+\t(s3_parse_48_inst): Likewise.\n+\t(s3_insert_reg): Likewise.\n+\t(s3_build_reg_hsh): Likewise.\n+\t(s3_build_score_ops_hsh): Likewise.\n+\t(s3_build_dependency_insn_hsh): Likewise.\n+\t(s3_begin): Likewise.\n+\t* config/tc-score7.c (struct s7_reg_map): Likewise.\n+\t(s7_score_reg_parse): Likewise.\n+\t(s7_dependency_type_from_insn): Likewise.\n+\t(s7_parse_16_32_inst): Likewise.\n+\t(s7_build_score_ops_hsh): Likewise.\n+\t(s7_build_dependency_insn_hsh): Likewise.\n+\t(s7_insert_reg): Likewise.\n+\t(s7_build_reg_hsh): Likewise.\n+\t(s7_begin): Likewise.\n+\t* config/tc-sh.c (EMPTY): Likewise.\n+\t(md_begin): Likewise.\n+\t(find_cooked_opcode): Likewise.\n+\t* config/tc-sparc.c (md_begin): Likewise.\n+\t(sparc_ip): Likewise.\n+\t* config/tc-spu.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-tic30.c (md_begin): Likewise.\n+\t(tic30_operand): Likewise.\n+\t(tic30_parallel_insn): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-tic4x.c (TIC4X_ALT_SYNTAX): Likewise.\n+\t(tic4x_asg): Likewise.\n+\t(tic4x_inst_insert): Likewise.\n+\t(tic4x_inst_add): Likewise.\n+\t(md_begin): Likewise.\n+\t(tic4x_operand_parse): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-tic54x.c (MAX_SUBSYM_HASH): Likewise.\n+\t(stag_add_field_symbols): Likewise.\n+\t(tic54x_endstruct): Likewise.\n+\t(tic54x_tag): Likewise.\n+\t(tic54x_remove_local_label): Likewise.\n+\t(tic54x_clear_local_labels): Likewise.\n+\t(tic54x_var): Likewise.\n+\t(tic54x_macro_start): Likewise.\n+\t(tic54x_macro_info): Likewise.\n+\t(tic54x_macro_end): Likewise.\n+\t(subsym_isreg): Likewise.\n+\t(subsym_structsz): Likewise.\n+\t(md_begin): Likewise.\n+\t(is_mmreg): Likewise.\n+\t(is_type): Likewise.\n+\t(encode_condition): Likewise.\n+\t(encode_cc3): Likewise.\n+\t(encode_cc2): Likewise.\n+\t(encode_operand): Likewise.\n+\t(tic54x_parse_insn): Likewise.\n+\t(tic54x_parse_parallel_insn_firstline): Likewise.\n+\t(subsym_create_or_replace): Likewise.\n+\t(subsym_lookup): Likewise.\n+\t(subsym_substitute): Likewise.\n+\t(tic54x_undefined_symbol): Likewise.\n+\t* config/tc-tic6x.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-tilegx.c (O_hw2_last_plt): Likewise.\n+\t(INSERT_SPECIAL_OP): Likewise.\n+\t(md_begin): Likewise.\n+\t(tilegx_parse_name): Likewise.\n+\t(parse_reg_expression): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-tilepro.c (O_tls_ie_load): Likewise.\n+\t(INSERT_SPECIAL_OP): Likewise.\n+\t(tilepro_parse_name): Likewise.\n+\t(parse_reg_expression): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-v850.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-vax.c (md_ri_to_chars): Likewise.\n+\t(vip_begin): Likewise.\n+\t(vip): Likewise.\n+\t(main): Likewise.\n+\t(md_begin): Likewise.\n+\t* config/tc-wasm32.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-xgate.c (xgate_parse_operand): Likewise.\n+\t(md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\t* config/tc-z8k.c (md_begin): Likewise.\n+\t(md_assemble): Likewise.\n+\n 2020-08-20  Martin Liska  <mliska@suse.cz>\n \n \t* dw2gencfi.c (dwcfi_hash_insert): Use htab_t and str_hash_*"
    },
    {
      "sha": "6a7ea9c69eb9fc6b07a0664d4d792f520d90056a",
      "filename": "gas/config/obj-coff-seh.c",
      "status": "modified",
      "additions": 4,
      "deletions": 8,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-coff-seh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-coff-seh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff-seh.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -31,7 +31,7 @@ struct seh_seg_list {\n /* Local data.  */\n static seh_context *seh_ctx_cur = NULL;\n \n-static struct hash_control *seh_hash;\n+static htab_t seh_hash;\n \n static struct seh_seg_list *x_segcur = NULL;\n static struct seh_seg_list *p_segcur = NULL;\n@@ -116,17 +116,13 @@ make_pxdata_seg (segT cseg, char *name)\n static void\n seh_hash_insert (const char *name, struct seh_seg_list *item)\n {\n-  const char *error_string;\n-\n-  if ((error_string = hash_jam (seh_hash, name, (char *) item)))\n-    as_fatal (_(\"Inserting \\\"%s\\\" into structure table failed: %s\"),\n-\t      name, error_string);\n+  str_hash_insert (seh_hash, name, (char *) item);\n }\n \n static struct seh_seg_list *\n seh_hash_find (char *name)\n {\n-  return (struct seh_seg_list *) hash_find (seh_hash, name);\n+  return (struct seh_seg_list *) str_hash_find (seh_hash, name);\n }\n \n static struct seh_seg_list *\n@@ -137,7 +133,7 @@ seh_hash_find_or_make (segT cseg, const char *base_name)\n \n   /* Initialize seh_hash once.  */\n   if (!seh_hash)\n-    seh_hash = hash_new ();\n+    seh_hash = str_htab_create ();\n \n   name = get_pxdata_name (cseg, base_name);\n "
    },
    {
      "sha": "d0d128f30016e1b34e74837306a0e3fc1977acf4",
      "filename": "gas/config/obj-coff.c",
      "status": "modified",
      "additions": 4,
      "deletions": 8,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-coff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-coff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -117,28 +117,24 @@ stack_pop (stack *st)\n \f\n /* Maintain a list of the tagnames of the structures.  */\n \n-static struct hash_control *tag_hash;\n+static htab_t tag_hash;\n \n static void\n tag_init (void)\n {\n-  tag_hash = hash_new ();\n+  tag_hash = str_htab_create ();\n }\n \n static void\n tag_insert (const char *name, symbolS *symbolP)\n {\n-  const char *error_string;\n-\n-  if ((error_string = hash_jam (tag_hash, name, (char *) symbolP)))\n-    as_fatal (_(\"Inserting \\\"%s\\\" into structure table failed: %s\"),\n-\t      name, error_string);\n+  str_hash_insert (tag_hash, name, (char *) symbolP);\n }\n \n static symbolS *\n tag_find (char *name)\n {\n-  return (symbolS *) hash_find (tag_hash, name);\n+  return (symbolS *) str_hash_find (tag_hash, name);\n }\n \n static symbolS *"
    },
    {
      "sha": "ba93770ac1a7e5d6e2cecc293795d7f615f8baf7",
      "filename": "gas/config/obj-elf.c",
      "status": "modified",
      "additions": 11,
      "deletions": 8,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/obj-elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-elf.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -2594,7 +2594,7 @@ struct group_list\n {\n   asection **head;\t\t/* Section lists.  */\n   unsigned int num_group;\t/* Number of lists.  */\n-  struct hash_control *indexes; /* Maps group name to index in head array.  */\n+  htab_t indexes; /* Maps group name to index in head array.  */\n };\n \n static struct group_list groups;\n@@ -2632,7 +2632,7 @@ build_additional_section_info (bfd *abfd ATTRIBUTE_UNUSED,\n \n   /* If this group already has a list, add the section to the head of\n      the list.  */\n-  elem_idx = (unsigned int *) hash_find (list->indexes, group_name);\n+  elem_idx = (unsigned int *) str_hash_find (list->indexes, group_name);\n   if (elem_idx != NULL)\n     {\n       elf_next_in_group (sec) = list->head[*elem_idx];\n@@ -2654,12 +2654,15 @@ build_additional_section_info (bfd *abfd ATTRIBUTE_UNUSED,\n   /* Add index to hash.  */\n   idx_ptr = XNEW (unsigned int);\n   *idx_ptr = i;\n-  hash_insert (list->indexes, group_name, idx_ptr);\n+  str_hash_insert (list->indexes, group_name, (char *)idx_ptr);\n }\n \n-static void free_section_idx (const char *key ATTRIBUTE_UNUSED, void *val)\n+static int\n+free_section_idx (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n-  free ((unsigned int *) val);\n+  string_tuple_t *tuple = *((string_tuple_t **) slot);\n+  free ((char *)tuple->value);\n+  return 1;\n }\n \n /* Create symbols for group signature.  */\n@@ -2672,7 +2675,7 @@ elf_adjust_symtab (void)\n   /* Go find section groups.  */\n   groups.num_group = 0;\n   groups.head = NULL;\n-  groups.indexes = hash_new ();\n+  groups.indexes = str_htab_create ();\n   bfd_map_over_sections (stdoutput, build_additional_section_info,\n \t\t\t &groups);\n \n@@ -2844,8 +2847,8 @@ elf_frob_file_after_relocs (void)\n     }\n \n   /* Cleanup hash.  */\n-  hash_traverse (groups.indexes, free_section_idx);\n-  hash_die (groups.indexes);\n+  htab_traverse (groups.indexes, free_section_idx, NULL);\n+  htab_delete (groups.indexes);\n \n #ifdef NEED_ECOFF_DEBUG\n   if (ECOFF_DEBUGGING)"
    },
    {
      "sha": "301b499a7446babc609588718f558ababdf539e7",
      "filename": "gas/config/tc-aarch64.c",
      "status": "modified",
      "additions": 57,
      "deletions": 62,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-aarch64.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -451,21 +451,21 @@ get_reg_expected_msg (aarch64_reg_type reg_type)\n /* Instructions take 4 bytes in the object file.  */\n #define INSN_SIZE\t4\n \n-static struct hash_control *aarch64_ops_hsh;\n-static struct hash_control *aarch64_cond_hsh;\n-static struct hash_control *aarch64_shift_hsh;\n-static struct hash_control *aarch64_sys_regs_hsh;\n-static struct hash_control *aarch64_pstatefield_hsh;\n-static struct hash_control *aarch64_sys_regs_ic_hsh;\n-static struct hash_control *aarch64_sys_regs_dc_hsh;\n-static struct hash_control *aarch64_sys_regs_at_hsh;\n-static struct hash_control *aarch64_sys_regs_tlbi_hsh;\n-static struct hash_control *aarch64_sys_regs_sr_hsh;\n-static struct hash_control *aarch64_reg_hsh;\n-static struct hash_control *aarch64_barrier_opt_hsh;\n-static struct hash_control *aarch64_nzcv_hsh;\n-static struct hash_control *aarch64_pldop_hsh;\n-static struct hash_control *aarch64_hint_opt_hsh;\n+static htab_t aarch64_ops_hsh;\n+static htab_t aarch64_cond_hsh;\n+static htab_t aarch64_shift_hsh;\n+static htab_t aarch64_sys_regs_hsh;\n+static htab_t aarch64_pstatefield_hsh;\n+static htab_t aarch64_sys_regs_ic_hsh;\n+static htab_t aarch64_sys_regs_dc_hsh;\n+static htab_t aarch64_sys_regs_at_hsh;\n+static htab_t aarch64_sys_regs_tlbi_hsh;\n+static htab_t aarch64_sys_regs_sr_hsh;\n+static htab_t aarch64_reg_hsh;\n+static htab_t aarch64_barrier_opt_hsh;\n+static htab_t aarch64_nzcv_hsh;\n+static htab_t aarch64_pldop_hsh;\n+static htab_t aarch64_hint_opt_hsh;\n \n /* Stuff needed to resolve the label ambiguity\n    As:\n@@ -764,7 +764,7 @@ parse_reg (char **ccp)\n     p++;\n   while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');\n \n-  reg = (reg_entry *) hash_find_n (aarch64_reg_hsh, start, p - start);\n+  reg = (reg_entry *) str_hash_find_n (aarch64_reg_hsh, start, p - start);\n \n   if (!reg)\n     return NULL;\n@@ -1315,7 +1315,7 @@ insert_reg_alias (char *str, int number, aarch64_reg_type type)\n   reg_entry *new;\n   const char *name;\n \n-  if ((new = hash_find (aarch64_reg_hsh, str)) != 0)\n+  if ((new = str_hash_find (aarch64_reg_hsh, str)) != 0)\n     {\n       if (new->builtin)\n \tas_warn (_(\"ignoring attempt to redefine built-in register '%s'\"),\n@@ -1337,8 +1337,7 @@ insert_reg_alias (char *str, int number, aarch64_reg_type type)\n   new->type = type;\n   new->builtin = FALSE;\n \n-  if (hash_insert (aarch64_reg_hsh, name, (void *) new))\n-    abort ();\n+  str_hash_insert (aarch64_reg_hsh, name, (void *) new);\n \n   return new;\n }\n@@ -1367,7 +1366,7 @@ create_register_alias (char *newname, char *p)\n   if (*oldname == '\\0')\n     return FALSE;\n \n-  old = hash_find (aarch64_reg_hsh, oldname);\n+  old = str_hash_find (aarch64_reg_hsh, oldname);\n   if (!old)\n     {\n       as_warn (_(\"unknown register '%s' -- .req ignored\"), oldname);\n@@ -1456,7 +1455,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n     as_bad (_(\"invalid syntax for .unreq directive\"));\n   else\n     {\n-      reg_entry *reg = hash_find (aarch64_reg_hsh, name);\n+      reg_entry *reg = str_hash_find (aarch64_reg_hsh, name);\n \n       if (!reg)\n \tas_bad (_(\"unknown register alias '%s'\"), name);\n@@ -1468,7 +1467,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n \t  char *p;\n \t  char *nbuf;\n \n-\t  hash_delete (aarch64_reg_hsh, name, FALSE);\n+\t  str_hash_delete (aarch64_reg_hsh, name);\n \t  free ((char *) reg->name);\n \t  free (reg);\n \n@@ -1479,20 +1478,20 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n \t  nbuf = strdup (name);\n \t  for (p = nbuf; *p; p++)\n \t    *p = TOUPPER (*p);\n-\t  reg = hash_find (aarch64_reg_hsh, nbuf);\n+\t  reg = str_hash_find (aarch64_reg_hsh, nbuf);\n \t  if (reg)\n \t    {\n-\t      hash_delete (aarch64_reg_hsh, nbuf, FALSE);\n+\t      str_hash_delete (aarch64_reg_hsh, nbuf);\n \t      free ((char *) reg->name);\n \t      free (reg);\n \t    }\n \n \t  for (p = nbuf; *p; p++)\n \t    *p = TOLOWER (*p);\n-\t  reg = hash_find (aarch64_reg_hsh, nbuf);\n+\t  reg = str_hash_find (aarch64_reg_hsh, nbuf);\n \t  if (reg)\n \t    {\n-\t      hash_delete (aarch64_reg_hsh, nbuf, FALSE);\n+\t      str_hash_delete (aarch64_reg_hsh, nbuf);\n \t      free ((char *) reg->name);\n \t      free (reg);\n \t    }\n@@ -3122,7 +3121,7 @@ parse_shift (char **str, aarch64_opnd_info *operand, enum parse_shift_mode mode)\n       return FALSE;\n     }\n \n-  shift_op = hash_find_n (aarch64_shift_hsh, *str, p - *str);\n+  shift_op = str_hash_find_n (aarch64_shift_hsh, *str, p - *str);\n \n   if (shift_op == NULL)\n     {\n@@ -3979,7 +3978,7 @@ parse_pldop (char **str)\n   while (ISALNUM (*q))\n     q++;\n \n-  o = hash_find_n (aarch64_pldop_hsh, p, q - p);\n+  o = str_hash_find_n (aarch64_pldop_hsh, p, q - p);\n   if (!o)\n     return PARSE_FAIL;\n \n@@ -4000,7 +3999,7 @@ parse_barrier (char **str)\n   while (ISALPHA (*q))\n     q++;\n \n-  o = hash_find_n (aarch64_barrier_opt_hsh, p, q - p);\n+  o = str_hash_find_n (aarch64_barrier_opt_hsh, p, q - p);\n   if (!o)\n     return PARSE_FAIL;\n \n@@ -4022,7 +4021,7 @@ parse_barrier_psb (char **str,\n   while (ISALPHA (*q))\n     q++;\n \n-  o = hash_find_n (aarch64_hint_opt_hsh, p, q - p);\n+  o = str_hash_find_n (aarch64_hint_opt_hsh, p, q - p);\n   if (!o)\n     {\n       set_fatal_syntax_error\n@@ -4057,7 +4056,7 @@ parse_bti_operand (char **str,\n   while (ISALPHA (*q))\n     q++;\n \n-  o = hash_find_n (aarch64_hint_opt_hsh, p, q - p);\n+  o = str_hash_find_n (aarch64_hint_opt_hsh, p, q - p);\n   if (!o)\n     {\n       set_fatal_syntax_error\n@@ -4095,7 +4094,7 @@ parse_bti_operand (char **str,\n */\n \n static int\n-parse_sys_reg (char **str, struct hash_control *sys_regs,\n+parse_sys_reg (char **str, htab_t sys_regs,\n \t       int imple_defined_p, int pstatefield_p,\n \t       uint32_t* flags)\n {\n@@ -4116,7 +4115,7 @@ parse_sys_reg (char **str, struct hash_control *sys_regs,\n   if (p - buf != q - *str)\n     return PARSE_FAIL;\n \n-  o = hash_find (sys_regs, buf);\n+  o = str_hash_find (sys_regs, buf);\n   if (!o)\n     {\n       if (!imple_defined_p)\n@@ -4162,7 +4161,7 @@ parse_sys_reg (char **str, struct hash_control *sys_regs,\n    for the option, or NULL.  */\n \n static const aarch64_sys_ins_reg *\n-parse_sys_ins_reg (char **str, struct hash_control *sys_ins_regs)\n+parse_sys_ins_reg (char **str, htab_t sys_ins_regs)\n {\n   char *p, *q;\n   char buf[AARCH64_MAX_SYSREG_NAME_LEN];\n@@ -4180,7 +4179,7 @@ parse_sys_ins_reg (char **str, struct hash_control *sys_ins_regs)\n   if (p - buf != q - *str)\n     return NULL;\n \n-  o = hash_find (sys_ins_regs, buf);\n+  o = str_hash_find (sys_ins_regs, buf);\n   if (!o)\n     return NULL;\n \n@@ -5096,7 +5095,7 @@ lookup_mnemonic (const char *start, int len)\n {\n   templates *templ = NULL;\n \n-  templ = hash_find_n (aarch64_ops_hsh, start, len);\n+  templ = str_hash_find_n (aarch64_ops_hsh, start, len);\n   return templ;\n }\n \n@@ -5127,7 +5126,7 @@ opcode_lookup (char **str)\n   /* Handle a possible condition.  */\n   if (dot)\n     {\n-      cond = hash_find_n (aarch64_cond_hsh, dot + 1, end - dot - 1);\n+      cond = str_hash_find_n (aarch64_cond_hsh, dot + 1, end - dot - 1);\n       if (cond)\n \t{\n \t  inst.cond = cond->value;\n@@ -6178,7 +6177,7 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \n \tcase AARCH64_OPND_NZCV:\n \t  {\n-\t    const asm_nzcv *nzcv = hash_find_n (aarch64_nzcv_hsh, str, 4);\n+\t    const asm_nzcv *nzcv = str_hash_find_n (aarch64_nzcv_hsh, str, 4);\n \t    if (nzcv != NULL)\n \t      {\n \t\tstr += 4;\n@@ -6197,7 +6196,7 @@ parse_operands (char *str, const aarch64_opcode *opcode)\n \t    do\n \t      str++;\n \t    while (ISALPHA (*str));\n-\t    info->cond = hash_find_n (aarch64_cond_hsh, start, str - start);\n+\t    info->cond = str_hash_find_n (aarch64_cond_hsh, start, str - start);\n \t    if (info->cond == NULL)\n \t      {\n \t\tset_syntax_error (_(\"invalid condition\"));\n@@ -8621,17 +8620,13 @@ aarch64_adjust_symtab (void)\n }\n \n static void\n-checked_hash_insert (struct hash_control *table, const char *key, void *value)\n+checked_hash_insert (htab_t table, const char *key, void *value)\n {\n-  const char *hash_err;\n-\n-  hash_err = hash_insert (table, key, value);\n-  if (hash_err)\n-    printf (\"Internal Error:  Can't hash %s\\n\", key);\n+  str_hash_insert (table, key, value);\n }\n \n static void\n-sysreg_hash_insert (struct hash_control *table, const char *key, void *value)\n+sysreg_hash_insert (htab_t table, const char *key, void *value)\n {\n   gas_assert (strlen (key) < AARCH64_MAX_SYSREG_NAME_LEN);\n   checked_hash_insert (table, key, value);\n@@ -8645,7 +8640,7 @@ fill_instruction_hash_table (void)\n   while (opcode->name != NULL)\n     {\n       templates *templ, *new_templ;\n-      templ = hash_find (aarch64_ops_hsh, opcode->name);\n+      templ = str_hash_find (aarch64_ops_hsh, opcode->name);\n \n       new_templ = XNEW (templates);\n       new_templ->opcode = opcode;\n@@ -8691,21 +8686,21 @@ md_begin (void)\n   unsigned mach;\n   unsigned int i;\n \n-  if ((aarch64_ops_hsh = hash_new ()) == NULL\n-      || (aarch64_cond_hsh = hash_new ()) == NULL\n-      || (aarch64_shift_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_hsh = hash_new ()) == NULL\n-      || (aarch64_pstatefield_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_ic_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_dc_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_at_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_tlbi_hsh = hash_new ()) == NULL\n-      || (aarch64_sys_regs_sr_hsh = hash_new ()) == NULL\n-      || (aarch64_reg_hsh = hash_new ()) == NULL\n-      || (aarch64_barrier_opt_hsh = hash_new ()) == NULL\n-      || (aarch64_nzcv_hsh = hash_new ()) == NULL\n-      || (aarch64_pldop_hsh = hash_new ()) == NULL\n-      || (aarch64_hint_opt_hsh = hash_new ()) == NULL)\n+  if ((aarch64_ops_hsh = str_htab_create ()) == NULL\n+      || (aarch64_cond_hsh = str_htab_create ()) == NULL\n+      || (aarch64_shift_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_hsh = str_htab_create ()) == NULL\n+      || (aarch64_pstatefield_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_ic_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_dc_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_at_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_tlbi_hsh = str_htab_create ()) == NULL\n+      || (aarch64_sys_regs_sr_hsh = str_htab_create ()) == NULL\n+      || (aarch64_reg_hsh = str_htab_create ()) == NULL\n+      || (aarch64_barrier_opt_hsh = str_htab_create ()) == NULL\n+      || (aarch64_nzcv_hsh = str_htab_create ()) == NULL\n+      || (aarch64_pldop_hsh = str_htab_create ()) == NULL\n+      || (aarch64_hint_opt_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   fill_instruction_hash_table ();"
    },
    {
      "sha": "d844fcf2cd7ca25f969f377dcf2db13adbf06177",
      "filename": "gas/config/tc-alpha.c",
      "status": "modified",
      "additions": 16,
      "deletions": 25,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-alpha.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -297,10 +297,10 @@ static unsigned alpha_target = AXP_OPCODE_BASE;\n static const char *alpha_target_name = \"<all>\";\n \n /* The hash table of instruction opcodes.  */\n-static struct hash_control *alpha_opcode_hash;\n+static htab_t alpha_opcode_hash;\n \n /* The hash table of macro opcodes.  */\n-static struct hash_control *alpha_macro_hash;\n+static htab_t alpha_macro_hash;\n \n #ifdef OBJ_ECOFF\n /* The $gp relocation symbol.  */\n@@ -514,7 +514,7 @@ struct alpha_reloc_tag\n };\n \n /* Hash table to link up literals with the appropriate lituse.  */\n-static struct hash_control *alpha_literal_hash;\n+static htab_t alpha_literal_hash;\n \n /* Sequence numbers for internal use by macros.  */\n static long next_sequence_num = -1;\n@@ -589,21 +589,18 @@ get_alpha_reloc_tag (long sequence)\n \n   sprintf (buffer, \"!%ld\", sequence);\n \n-  info = (struct alpha_reloc_tag *) hash_find (alpha_literal_hash, buffer);\n+  info = (struct alpha_reloc_tag *) str_hash_find (alpha_literal_hash, buffer);\n   if (! info)\n     {\n       size_t len = strlen (buffer);\n-      const char *errmsg;\n \n       info = (struct alpha_reloc_tag *)\n           xcalloc (sizeof (struct alpha_reloc_tag) + len, 1);\n \n       info->segment = now_seg;\n       info->sequence = sequence;\n       strcpy (info->string, buffer);\n-      errmsg = hash_insert (alpha_literal_hash, info->string, (void *) info);\n-      if (errmsg)\n-\tas_fatal (\"%s\", errmsg);\n+      str_hash_insert (alpha_literal_hash, info->string, (void *) info);\n #ifdef OBJ_EVAX\n       info->sym = 0;\n       info->psym = 0;\n@@ -1171,7 +1168,7 @@ assemble_tokens_to_insn (const char *opname,\n   const struct alpha_opcode *opcode;\n \n   /* Search opcodes.  */\n-  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);\n+  opcode = (const struct alpha_opcode *) str_hash_find (alpha_opcode_hash, opname);\n   if (opcode)\n     {\n       int cpumatch;\n@@ -3319,7 +3316,7 @@ assemble_tokens (const char *opname,\n   if (local_macros_on)\n     {\n       macro = ((const struct alpha_macro *)\n-\t       hash_find (alpha_macro_hash, opname));\n+\t       str_hash_find (alpha_macro_hash, opname));\n       if (macro)\n \t{\n \t  found_something = 1;\n@@ -3333,7 +3330,7 @@ assemble_tokens (const char *opname,\n     }\n \n   /* Search opcodes.  */\n-  opcode = (const struct alpha_opcode *) hash_find (alpha_opcode_hash, opname);\n+  opcode = (const struct alpha_opcode *) str_hash_find (alpha_opcode_hash, opname);\n   if (opcode)\n     {\n       found_something = 1;\n@@ -5419,17 +5416,14 @@ md_begin (void)\n   }\n \n   /* Create the opcode hash table.  */\n-  alpha_opcode_hash = hash_new ();\n+  alpha_opcode_hash = str_htab_create ();\n \n   for (i = 0; i < alpha_num_opcodes;)\n     {\n-      const char *name, *retval, *slash;\n+      const char *name, *slash;\n \n       name = alpha_opcodes[i].name;\n-      retval = hash_insert (alpha_opcode_hash, name, (void *) &alpha_opcodes[i]);\n-      if (retval)\n-\tas_fatal (_(\"internal error: can't hash opcode `%s': %s\"),\n-\t\t  name, retval);\n+      str_hash_insert (alpha_opcode_hash, name, (void *) &alpha_opcodes[i]);\n \n       /* Some opcodes include modifiers of various sorts with a \"/mod\"\n \t syntax, like the architecture manual suggests.  However, for\n@@ -5443,7 +5437,7 @@ md_begin (void)\n \t  memcpy (p, name, slash - name);\n \t  strcpy (p + (slash - name), slash + 1);\n \n-\t  (void) hash_insert (alpha_opcode_hash, p, (void *) &alpha_opcodes[i]);\n+\t  (void) str_hash_insert (alpha_opcode_hash, p, (void *) &alpha_opcodes[i]);\n \t  /* Ignore failures -- the opcode table does duplicate some\n \t     variants in different forms, like \"hw_stq\" and \"hw_st/q\".  */\n \t}\n@@ -5455,17 +5449,14 @@ md_begin (void)\n     }\n \n   /* Create the macro hash table.  */\n-  alpha_macro_hash = hash_new ();\n+  alpha_macro_hash = str_htab_create ();\n \n   for (i = 0; i < alpha_num_macros;)\n     {\n-      const char *name, *retval;\n+      const char *name;\n \n       name = alpha_macros[i].name;\n-      retval = hash_insert (alpha_macro_hash, name, (void *) &alpha_macros[i]);\n-      if (retval)\n-\tas_fatal (_(\"internal error: can't hash macro `%s': %s\"),\n-\t\t  name, retval);\n+      str_hash_insert (alpha_macro_hash, name, (void *) &alpha_macros[i]);\n \n       while (++i < alpha_num_macros\n \t     && (alpha_macros[i].name == name\n@@ -5520,7 +5511,7 @@ md_begin (void)\n #endif\n \n   /* Create literal lookup hash table.  */\n-  alpha_literal_hash = hash_new ();\n+  alpha_literal_hash = str_htab_create ();\n \n   subseg_set (text_section, 0);\n }"
    },
    {
      "sha": "5fa0ccb1fe0eb59bdd9e26caa6e17c07e1b151fb",
      "filename": "gas/config/tc-arc.c",
      "status": "modified",
      "additions": 21,
      "deletions": 41,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arc.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -428,16 +428,16 @@ enum mach_selection_type\n static enum mach_selection_type mach_selection_mode = MACH_SELECTION_NONE;\n \n /* The hash table of instruction opcodes.  */\n-static struct hash_control *arc_opcode_hash;\n+static htab_t arc_opcode_hash;\n \n /* The hash table of register symbols.  */\n-static struct hash_control *arc_reg_hash;\n+static htab_t arc_reg_hash;\n \n /* The hash table of aux register symbols.  */\n-static struct hash_control *arc_aux_hash;\n+static htab_t arc_aux_hash;\n \n /* The hash table of address types.  */\n-static struct hash_control *arc_addrtype_hash;\n+static htab_t arc_addrtype_hash;\n \n #define ARC_CPU_TYPE_A6xx(NAME,EXTRA)\t\t\t\\\n   { #NAME, ARC_OPCODE_ARC600, bfd_mach_arc_arc600,\t\\\n@@ -704,7 +704,7 @@ arc_find_opcode (const char *name)\n {\n   const struct arc_opcode_hash_entry *entry;\n \n-  entry = hash_find (arc_opcode_hash, name);\n+  entry = str_hash_find (arc_opcode_hash, name);\n   return entry;\n }\n \n@@ -754,21 +754,18 @@ arc_opcode_hash_entry_iterator_next (const struct arc_opcode_hash_entry *entry,\n static void\n arc_insert_opcode (const struct arc_opcode *opcode)\n {\n-  const char *name, *retval;\n+  const char *name;\n   struct arc_opcode_hash_entry *entry;\n   name = opcode->name;\n \n-  entry = hash_find (arc_opcode_hash, name);\n+  entry = str_hash_find (arc_opcode_hash, name);\n   if (entry == NULL)\n     {\n       entry = XNEW (struct arc_opcode_hash_entry);\n       entry->count = 0;\n       entry->opcode = NULL;\n \n-      retval = hash_insert (arc_opcode_hash, name, (void *) entry);\n-      if (retval)\n-\tas_fatal (_(\"internal error: can't hash opcode '%s': %s\"),\n-\t\t  name, retval);\n+      str_hash_insert (arc_opcode_hash, name, (void *) entry);\n     }\n \n   entry->opcode = XRESIZEVEC (const struct arc_opcode *, entry->opcode,\n@@ -1921,7 +1918,7 @@ find_opcode_match (const struct arc_opcode_hash_entry *entry,\n \t\t    tmpp = strdup (p);\n \t\t    for (pp = tmpp; *pp; ++pp) *pp = TOLOWER (*pp);\n \n-\t\t    auxr = hash_find (arc_aux_hash, tmpp);\n+\t\t    auxr = str_hash_find (arc_aux_hash, tmpp);\n \t\t    if (auxr)\n \t\t      {\n \t\t\t/* We modify the token array here, safe in the\n@@ -2552,14 +2549,10 @@ md_assemble (char *str)\n static void\n declare_register (const char *name, int number)\n {\n-  const char *err;\n   symbolS *regS = symbol_create (name, reg_section,\n \t\t\t\t number, &zero_address_frag);\n \n-  err = hash_insert (arc_reg_hash, S_GET_NAME (regS), (void *) regS);\n-  if (err)\n-    as_fatal (_(\"Inserting \\\"%s\\\" into register table failed: %s\"),\n-\t      name, err);\n+  str_hash_insert (arc_reg_hash, S_GET_NAME (regS), (void *) regS);\n }\n \n /* Construct symbols for each of the general registers.  */\n@@ -2587,15 +2580,11 @@ declare_register_set (void)\n static void\n declare_addrtype (const char *name, int number)\n {\n-  const char *err;\n   symbolS *addrtypeS = symbol_create (name, undefined_section,\n                                       number, &zero_address_frag);\n \n-  err = hash_insert (arc_addrtype_hash, S_GET_NAME (addrtypeS),\n-                     (void *) addrtypeS);\n-  if (err)\n-    as_fatal (_(\"Inserting \\\"%s\\\" into address type table failed: %s\"),\n-              name, err);\n+  str_hash_insert (arc_addrtype_hash, S_GET_NAME (addrtypeS),\n+\t\t   (void *) addrtypeS);\n }\n \n /* Port-specific assembler initialization.  This function is called\n@@ -2619,7 +2608,7 @@ md_begin (void)\n   bfd_set_private_flags (stdoutput, selected_cpu.eflags);\n \n   /* Set up a hash table for the instructions.  */\n-  arc_opcode_hash = hash_new ();\n+  arc_opcode_hash = str_htab_create ();\n   if (arc_opcode_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n@@ -2637,7 +2626,7 @@ md_begin (void)\n     }while (opcode->name);\n \n   /* Register declaration.  */\n-  arc_reg_hash = hash_new ();\n+  arc_reg_hash = str_htab_create ();\n   if (arc_reg_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n@@ -2690,31 +2679,26 @@ md_begin (void)\n   memset (&arc_last_insns[0], 0, sizeof (arc_last_insns));\n \n   /* Aux register declaration.  */\n-  arc_aux_hash = hash_new ();\n+  arc_aux_hash = str_htab_create ();\n   if (arc_aux_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   const struct arc_aux_reg *auxr = &arc_aux_regs[0];\n   unsigned int i;\n   for (i = 0; i < arc_num_aux_regs; i++, auxr++)\n     {\n-      const char *retval;\n-\n       if (!(auxr->cpu & selected_cpu.flags))\n \tcontinue;\n \n       if ((auxr->subclass != NONE)\n \t  && !check_cpu_feature (auxr->subclass))\n \tcontinue;\n \n-      retval = hash_insert (arc_aux_hash, auxr->name, (void *) auxr);\n-      if (retval)\n-\tas_fatal (_(\"internal error: can't hash aux register '%s': %s\"),\n-\t\t  auxr->name, retval);\n+      str_hash_insert (arc_aux_hash, auxr->name, (void *) auxr);\n     }\n \n   /* Address type declaration.  */\n-  arc_addrtype_hash = hash_new ();\n+  arc_addrtype_hash = str_htab_create ();\n   if (arc_addrtype_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n@@ -3420,15 +3404,15 @@ arc_parse_name (const char *name,\n       && e->X_md == O_absent)\n     return FALSE;\n \n-  sym = hash_find (arc_reg_hash, name);\n+  sym = str_hash_find (arc_reg_hash, name);\n   if (sym)\n     {\n       e->X_op = O_register;\n       e->X_add_number = S_GET_VALUE (sym);\n       return TRUE;\n     }\n \n-  sym = hash_find (arc_addrtype_hash, name);\n+  sym = str_hash_find (arc_addrtype_hash, name);\n   if (sym)\n     {\n       e->X_op = O_addrtype;\n@@ -4393,7 +4377,7 @@ tc_arc_regname_to_dw2regnum (char *regname)\n {\n   struct symbol *sym;\n \n-  sym = hash_find (arc_reg_hash, regname);\n+  sym = str_hash_find (arc_reg_hash, regname);\n   if (sym)\n     return S_GET_VALUE (sym);\n \n@@ -4883,7 +4867,6 @@ arc_extcorereg (int opertype)\n {\n   extRegister_t ereg;\n   struct arc_aux_reg *auxr;\n-  const char *retval;\n   struct arc_flag_operand *ccode;\n \n   memset (&ereg, 0, sizeof (ereg));\n@@ -4906,10 +4889,7 @@ arc_extcorereg (int opertype)\n       auxr->cpu = selected_cpu.flags;\n       auxr->subclass = NONE;\n       auxr->address = ereg.number;\n-      retval = hash_insert (arc_aux_hash, auxr->name, (void *) auxr);\n-      if (retval)\n-\tas_fatal (_(\"internal error: can't hash aux register '%s': %s\"),\n-\t\t  auxr->name, retval);\n+      str_hash_insert (arc_aux_hash, auxr->name, (void *) auxr);\n       break;\n     case EXT_COND_CODE:\n       /* Condition code.  */"
    },
    {
      "sha": "3b17e20d4d397fe3085bd7aa9ff5a318a9fa3f15",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 62,
      "deletions": 59,
      "changes": 121,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -945,15 +945,15 @@ struct asm_opcode\n #define BAD_EL_TYPE\t_(\"bad element type for instruction\")\n #define MVE_BAD_QREG\t_(\"MVE vector register Q[0..7] expected\")\n \n-static struct hash_control * arm_ops_hsh;\n-static struct hash_control * arm_cond_hsh;\n-static struct hash_control * arm_vcond_hsh;\n-static struct hash_control * arm_shift_hsh;\n-static struct hash_control * arm_psr_hsh;\n-static struct hash_control * arm_v7m_psr_hsh;\n-static struct hash_control * arm_reg_hsh;\n-static struct hash_control * arm_reloc_hsh;\n-static struct hash_control * arm_barrier_opt_hsh;\n+static htab_t  arm_ops_hsh;\n+static htab_t  arm_cond_hsh;\n+static htab_t  arm_vcond_hsh;\n+static htab_t  arm_shift_hsh;\n+static htab_t  arm_psr_hsh;\n+static htab_t  arm_v7m_psr_hsh;\n+static htab_t  arm_reg_hsh;\n+static htab_t  arm_reloc_hsh;\n+static htab_t  arm_barrier_opt_hsh;\n \n /* Stuff needed to resolve the label ambiguity\n    As:\n@@ -1427,7 +1427,7 @@ arm_reg_parse_multi (char **ccp)\n     p++;\n   while (ISALPHA (*p) || ISDIGIT (*p) || *p == '_');\n \n-  reg = (struct reg_entry *) hash_find_n (arm_reg_hsh, start, p - start);\n+  reg = (struct reg_entry *) str_hash_find_n (arm_reg_hsh, start, p - start);\n \n   if (!reg)\n     return NULL;\n@@ -2546,7 +2546,7 @@ parse_reloc (char **str)\n     return -1;\n \n   if ((r = (struct reloc_entry *)\n-       hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)\n+       str_hash_find_n (arm_reloc_hsh, p, q - p)) == NULL)\n     return -1;\n \n   *str = q + 1;\n@@ -2561,7 +2561,7 @@ insert_reg_alias (char *str, unsigned number, int type)\n   struct reg_entry *new_reg;\n   const char *name;\n \n-  if ((new_reg = (struct reg_entry *) hash_find (arm_reg_hsh, str)) != 0)\n+  if ((new_reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, str)) != 0)\n     {\n       if (new_reg->builtin)\n \tas_warn (_(\"ignoring attempt to redefine built-in register '%s'\"), str);\n@@ -2583,8 +2583,7 @@ insert_reg_alias (char *str, unsigned number, int type)\n   new_reg->builtin = FALSE;\n   new_reg->neon = NULL;\n \n-  if (hash_insert (arm_reg_hsh, name, (void *) new_reg))\n-    abort ();\n+  str_hash_insert (arm_reg_hsh, name, new_reg);\n \n   return new_reg;\n }\n@@ -2632,7 +2631,7 @@ create_register_alias (char * newname, char *p)\n   if (*oldname == '\\0')\n     return FALSE;\n \n-  old = (struct reg_entry *) hash_find (arm_reg_hsh, oldname);\n+  old = (struct reg_entry *) str_hash_find (arm_reg_hsh, oldname);\n   if (!old)\n     {\n       as_warn (_(\"unknown register '%s' -- .req ignored\"), oldname);\n@@ -2884,7 +2883,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n     as_bad (_(\"invalid syntax for .unreq directive\"));\n   else\n     {\n-      struct reg_entry *reg = (struct reg_entry *) hash_find (arm_reg_hsh,\n+      struct reg_entry *reg = (struct reg_entry *) str_hash_find (arm_reg_hsh,\n \t\t\t\t\t\t\t      name);\n \n       if (!reg)\n@@ -2897,7 +2896,7 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n \t  char * p;\n \t  char * nbuf;\n \n-\t  hash_delete (arm_reg_hsh, name, FALSE);\n+\t  str_hash_delete (arm_reg_hsh, name);\n \t  free ((char *) reg->name);\n \t  free (reg->neon);\n \t  free (reg);\n@@ -2909,21 +2908,21 @@ s_unreq (int a ATTRIBUTE_UNUSED)\n \t  nbuf = strdup (name);\n \t  for (p = nbuf; *p; p++)\n \t    *p = TOUPPER (*p);\n-\t  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);\n+\t  reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, nbuf);\n \t  if (reg)\n \t    {\n-\t      hash_delete (arm_reg_hsh, nbuf, FALSE);\n+\t      str_hash_delete (arm_reg_hsh, nbuf);\n \t      free ((char *) reg->name);\n \t      free (reg->neon);\n \t      free (reg);\n \t    }\n \n \t  for (p = nbuf; *p; p++)\n \t    *p = TOLOWER (*p);\n-\t  reg = (struct reg_entry *) hash_find (arm_reg_hsh, nbuf);\n+\t  reg = (struct reg_entry *) str_hash_find (arm_reg_hsh, nbuf);\n \t  if (reg)\n \t    {\n-\t      hash_delete (arm_reg_hsh, nbuf, FALSE);\n+\t      str_hash_delete (arm_reg_hsh, nbuf);\n \t      free ((char *) reg->name);\n \t      free (reg->neon);\n \t      free (reg);\n@@ -5537,7 +5536,7 @@ parse_shift (char **str, int i, enum parse_shift_mode mode)\n       return FAIL;\n     }\n \n-  shift_name = (const struct asm_shift_name *) hash_find_n (arm_shift_hsh, *str,\n+  shift_name = (const struct asm_shift_name *) str_hash_find_n (arm_shift_hsh, *str,\n \t\t\t\t\t\t\t    p - *str);\n \n   if (shift_name == NULL)\n@@ -6338,7 +6337,7 @@ parse_psr (char **str, bfd_boolean lhs)\n \t  || strncasecmp (start, \"psr\", 3) == 0)\n \tp = start + strcspn (start, \"rR\") + 1;\n \n-      psr = (const struct asm_psr *) hash_find_n (arm_v7m_psr_hsh, start,\n+      psr = (const struct asm_psr *) str_hash_find_n (arm_v7m_psr_hsh, start,\n \t\t\t\t\t\t  p - start);\n \n       if (!psr)\n@@ -6441,7 +6440,7 @@ parse_psr (char **str, bfd_boolean lhs)\n \t}\n       else\n \t{\n-\t  psr = (const struct asm_psr *) hash_find_n (arm_psr_hsh, start,\n+\t  psr = (const struct asm_psr *) str_hash_find_n (arm_psr_hsh, start,\n \t\t\t\t\t\t      p - start);\n \t  if (!psr)\n \t    goto error;\n@@ -6633,7 +6632,7 @@ parse_cond (char **str)\n       n++;\n     }\n \n-  c = (const struct asm_cond *) hash_find_n (arm_cond_hsh, cond, n);\n+  c = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, cond, n);\n   if (!c)\n     {\n       inst.error = _(\"condition required\");\n@@ -6656,7 +6655,7 @@ parse_barrier (char **str)\n   while (ISALPHA (*q))\n     q++;\n \n-  o = (const struct asm_barrier_opt *) hash_find_n (arm_barrier_opt_hsh, p,\n+  o = (const struct asm_barrier_opt *) str_hash_find_n (arm_barrier_opt_hsh, p,\n \t\t\t\t\t\t    q - p);\n   if (!o)\n     return FAIL;\n@@ -15606,7 +15605,7 @@ do_vfp_nsyn_opcode (const char *opname)\n {\n   const struct asm_opcode *opcode;\n \n-  opcode = (const struct asm_opcode *) hash_find (arm_ops_hsh, opname);\n+  opcode = (const struct asm_opcode *) str_hash_find (arm_ops_hsh, opname);\n \n   if (!opcode)\n     abort ();\n@@ -22620,7 +22619,7 @@ opcode_lookup (char **str)\n     *str = end;\n \n   /* Look for unaffixed or special-case affixed mnemonic.  */\n-  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+  opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,\n \t\t\t\t\t\t    end - base);\n   if (opcode)\n     {\n@@ -22634,7 +22633,7 @@ opcode_lookup (char **str)\n       if (warn_on_deprecated && unified_syntax)\n \tas_tsktsk (_(\"conditional infixes are deprecated in unified syntax\"));\n       affix = base + (opcode->tag - OT_odd_infix_0);\n-      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);\n+      cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);\n       gas_assert (cond);\n \n       inst.cond = cond->value;\n@@ -22647,8 +22646,8 @@ opcode_lookup (char **str)\n     if (end - base < 2)\n       return NULL;\n      affix = end - 1;\n-     cond = (const struct asm_cond *) hash_find_n (arm_vcond_hsh, affix, 1);\n-     opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+     cond = (const struct asm_cond *) str_hash_find_n (arm_vcond_hsh, affix, 1);\n+     opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,\n \t\t\t\t\t\t      affix - base);\n      /* If this opcode can not be vector predicated then don't accept it with a\n \tvector predication code.  */\n@@ -22664,8 +22663,8 @@ opcode_lookup (char **str)\n \n       /* Look for suffixed mnemonic.  */\n       affix = end - 2;\n-      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);\n-      opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+      cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);\n+      opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,\n \t\t\t\t\t\t\taffix - base);\n     }\n \n@@ -22715,13 +22714,13 @@ opcode_lookup (char **str)\n \n   /* Look for infixed mnemonic in the usual position.  */\n   affix = base + 3;\n-  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);\n+  cond = (const struct asm_cond *) str_hash_find_n (arm_cond_hsh, affix, 2);\n   if (!cond)\n     return NULL;\n \n   memcpy (save, affix, 2);\n   memmove (affix, affix + 2, (end - affix) - 2);\n-  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+  opcode = (const struct asm_opcode *) str_hash_find_n (arm_ops_hsh, base,\n \t\t\t\t\t\t    (end - base) - 2);\n   memmove (affix + 2, affix, (end - affix) - 2);\n   memcpy (affix, save, 2);\n@@ -27989,16 +27988,19 @@ arm_tc_equal_in_insn (int c ATTRIBUTE_UNUSED, char * name)\n \n       for (p = nbuf; *p; p++)\n \t*p = TOLOWER (*p);\n-      if (hash_find (arm_ops_hsh, nbuf) != NULL)\n+      if (str_hash_find (arm_ops_hsh, nbuf) != NULL)\n \t{\n-\t  static struct hash_control * already_warned = NULL;\n+\t  static htab_t  already_warned = NULL;\n \n \t  if (already_warned == NULL)\n-\t    already_warned = hash_new ();\n+\t    already_warned = str_htab_create ();\n \t  /* Only warn about the symbol once.  To keep the code\n-\t     simple we let hash_insert do the lookup for us.  */\n-\t  if (hash_insert (already_warned, nbuf, NULL) == NULL)\n-\t    as_warn (_(\"[-mwarn-syms]: Assignment makes a symbol match an ARM instruction: %s\"), name);\n+\t     simple we let str_hash_insert do the lookup for us.  */\n+\t  if (str_hash_find (already_warned, nbuf) == NULL)\n+\t    {\n+\t      as_warn (_(\"[-mwarn-syms]: Assignment makes a symbol match an ARM instruction: %s\"), name);\n+\t      str_hash_insert (already_warned, nbuf, NULL);\n+\t    }\n \t}\n       else\n \tfree (nbuf);\n@@ -30716,36 +30718,37 @@ md_begin (void)\n   unsigned mach;\n   unsigned int i;\n \n-  if (\t (arm_ops_hsh = hash_new ()) == NULL\n-      || (arm_cond_hsh = hash_new ()) == NULL\n-      || (arm_vcond_hsh = hash_new ()) == NULL\n-      || (arm_shift_hsh = hash_new ()) == NULL\n-      || (arm_psr_hsh = hash_new ()) == NULL\n-      || (arm_v7m_psr_hsh = hash_new ()) == NULL\n-      || (arm_reg_hsh = hash_new ()) == NULL\n-      || (arm_reloc_hsh = hash_new ()) == NULL\n-      || (arm_barrier_opt_hsh = hash_new ()) == NULL)\n+  if (\t (arm_ops_hsh = str_htab_create ()) == NULL\n+      || (arm_cond_hsh = str_htab_create ()) == NULL\n+      || (arm_vcond_hsh = str_htab_create ()) == NULL\n+      || (arm_shift_hsh = str_htab_create ()) == NULL\n+      || (arm_psr_hsh = str_htab_create ()) == NULL\n+      || (arm_v7m_psr_hsh = str_htab_create ()) == NULL\n+      || (arm_reg_hsh = str_htab_create ()) == NULL\n+      || (arm_reloc_hsh = str_htab_create ()) == NULL\n+      || (arm_barrier_opt_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   for (i = 0; i < sizeof (insns) / sizeof (struct asm_opcode); i++)\n-    hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));\n+    if (str_hash_find (arm_ops_hsh, insns[i].template_name) == NULL)\n+      str_hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));\n   for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)\n-    hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));\n+    str_hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));\n   for (i = 0; i < sizeof (vconds) / sizeof (struct asm_cond); i++)\n-    hash_insert (arm_vcond_hsh, vconds[i].template_name, (void *) (vconds + i));\n+    str_hash_insert (arm_vcond_hsh, vconds[i].template_name, (void *) (vconds + i));\n   for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)\n-    hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));\n+    str_hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));\n   for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)\n-    hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));\n+    str_hash_insert (arm_psr_hsh, psrs[i].template_name, (void *) (psrs + i));\n   for (i = 0; i < sizeof (v7m_psrs) / sizeof (struct asm_psr); i++)\n-    hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,\n+    str_hash_insert (arm_v7m_psr_hsh, v7m_psrs[i].template_name,\n \t\t (void *) (v7m_psrs + i));\n   for (i = 0; i < sizeof (reg_names) / sizeof (struct reg_entry); i++)\n-    hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));\n+    str_hash_insert (arm_reg_hsh, reg_names[i].name, (void *) (reg_names + i));\n   for (i = 0;\n        i < sizeof (barrier_opt_names) / sizeof (struct asm_barrier_opt);\n        i++)\n-    hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,\n+    str_hash_insert (arm_barrier_opt_hsh, barrier_opt_names[i].template_name,\n \t\t (void *) (barrier_opt_names + i));\n #ifdef OBJ_ELF\n   for (i = 0; i < ARRAY_SIZE (reloc_names); i++)\n@@ -30756,7 +30759,7 @@ md_begin (void)\n \t/* This makes encode_branch() use the EABI versions of this relocation.  */\n \tentry->reloc = BFD_RELOC_UNUSED;\n \n-      hash_insert (arm_reloc_hsh, entry->name, (void *) entry);\n+      str_hash_insert (arm_reloc_hsh, entry->name, (void *) entry);\n     }\n #endif\n "
    },
    {
      "sha": "ae0672775a586ac600bf2bb5b60312ae787854bb",
      "filename": "gas/config/tc-avr.c",
      "status": "modified",
      "additions": 17,
      "deletions": 15,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-avr.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -524,13 +524,13 @@ typedef union\n } mod_index;\n \n /* Opcode hash table.  */\n-static struct hash_control *avr_hash;\n+static htab_t avr_hash;\n \n /* Reloc modifiers hash control (hh8,hi8,lo8,pm_xx).  */\n-static struct hash_control *avr_mod_hash;\n+static htab_t avr_mod_hash;\n \n /* Whether some opcode does not change SREG.  */\n-static struct hash_control *avr_no_sreg_hash;\n+static htab_t avr_no_sreg_hash;\n \n static const char* const avr_no_sreg[] =\n   {\n@@ -808,33 +808,35 @@ md_begin (void)\n   unsigned int i;\n   struct avr_opcodes_s *opcode;\n \n-  avr_hash = hash_new ();\n+  avr_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  This hash table then provides a\n      quick index to the first opcode with a particular name in the opcode\n      table.  */\n   for (opcode = avr_opcodes; opcode->name; opcode++)\n-    hash_insert (avr_hash, opcode->name, (char *) opcode);\n+    if (str_hash_find (avr_hash, opcode->name) == NULL)\n+      str_hash_insert (avr_hash, opcode->name, (char *) opcode);\n \n-  avr_mod_hash = hash_new ();\n+  avr_mod_hash = str_htab_create ();\n \n   for (i = 0; i < ARRAY_SIZE (exp_mod); ++i)\n     {\n       mod_index m;\n \n       m.index = i + 10;\n-      hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);\n+      str_hash_find (avr_mod_hash, EXP_MOD_NAME (i));\n+      str_hash_insert (avr_mod_hash, EXP_MOD_NAME (i), m.ptr);\n     }\n \n-  avr_no_sreg_hash = hash_new ();\n+  avr_no_sreg_hash = str_htab_create ();\n \n   for (i = 0; i < ARRAY_SIZE (avr_no_sreg); ++i)\n     {\n-      gas_assert (hash_find (avr_hash, avr_no_sreg[i]));\n-      hash_insert (avr_no_sreg_hash, avr_no_sreg[i], (char*) 4 /* dummy */);\n+      gas_assert (str_hash_find (avr_hash, avr_no_sreg[i]));\n+      str_hash_insert (avr_no_sreg_hash, avr_no_sreg[i], (char*) 4 /* dummy */);\n     }\n \n-  avr_gccisr_opcode = (struct avr_opcodes_s*) hash_find (avr_hash, \"__gcc_isr\");\n+  avr_gccisr_opcode = (struct avr_opcodes_s*) str_hash_find (avr_hash, \"__gcc_isr\");\n   gas_assert (avr_gccisr_opcode);\n \n   bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);\n@@ -923,7 +925,7 @@ avr_ldi_expression (expressionS *exp)\n     {\n       mod_index m;\n \n-      m.ptr = hash_find (avr_mod_hash, op);\n+      m.ptr = str_hash_find (avr_mod_hash, op);\n       mod = m.index;\n \n       if (mod)\n@@ -1874,7 +1876,7 @@ md_assemble (char *str)\n   if (!op[0])\n     as_bad (_(\"can't find opcode \"));\n \n-  opcode = (struct avr_opcodes_s *) hash_find (avr_hash, op);\n+  opcode = (struct avr_opcodes_s *) str_hash_find (avr_hash, op);\n \n   if (opcode && !avr_opt.all_opcodes)\n     {\n@@ -2453,7 +2455,7 @@ avr_update_gccisr (struct avr_opcodes_s *opcode, int reg1, int reg2)\n   /* SREG: Look up instructions that don't clobber SREG.  */\n \n   if (!avr_isr.need_sreg\n-      && !hash_find (avr_no_sreg_hash, opcode->name))\n+      && !str_hash_find (avr_no_sreg_hash, opcode->name))\n     {\n       avr_isr.need_sreg = 1;\n     }\n@@ -2497,7 +2499,7 @@ avr_emit_insn (const char *insn, int reg, char **pwhere)\n   const int sreg = 0x3f;\n   unsigned bin = 0;\n   const struct avr_opcodes_s *op\n-    = (struct avr_opcodes_s*) hash_find (avr_hash, insn);\n+    = (struct avr_opcodes_s*) str_hash_find (avr_hash, insn);\n \n   /* We only have to deal with: IN, OUT, PUSH, POP, CLR, LDI 0.  All of\n      these deal with at least one Reg and are 1-word instructions.  */"
    },
    {
      "sha": "c95d724bbbaca7d84fa02d5ad6fed5ff745f4e28",
      "filename": "gas/config/tc-cr16.c",
      "status": "modified",
      "additions": 20,
      "deletions": 33,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-cr16.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -53,15 +53,15 @@ typedef enum\n op_err;\n \n /* Opcode mnemonics hash table.  */\n-static struct hash_control *cr16_inst_hash;\n+static htab_t cr16_inst_hash;\n /* CR16 registers hash table.  */\n-static struct hash_control *reg_hash;\n+static htab_t reg_hash;\n /* CR16 register pair hash table.  */\n-static struct hash_control *regp_hash;\n+static htab_t regp_hash;\n /* CR16 processor registers hash table.  */\n-static struct hash_control *preg_hash;\n+static htab_t preg_hash;\n /* CR16 processor registers 32 bit hash table.  */\n-static struct hash_control *pregp_hash;\n+static htab_t pregp_hash;\n /* Current instruction we're assembling.  */\n const inst *instruction;\n \n@@ -324,7 +324,7 @@ get_register (char *reg_name)\n {\n   const reg_entry *rreg;\n \n-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);\n+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);\n \n   if (rreg != NULL)\n     return rreg->value.reg_val;\n@@ -345,10 +345,10 @@ get_register_pair (char *reg_name)\n       tmp_rp[0] = '(';\n       strcat (tmp_rp, reg_name);\n       strcat (tmp_rp,\")\");\n-      rreg = (const reg_entry *) hash_find (regp_hash, tmp_rp);\n+      rreg = (const reg_entry *) str_hash_find (regp_hash, tmp_rp);\n     }\n   else\n-    rreg = (const reg_entry *) hash_find (regp_hash, reg_name);\n+    rreg = (const reg_entry *) str_hash_find (regp_hash, reg_name);\n \n   if (rreg != NULL)\n     return rreg->value.reg_val;\n@@ -363,7 +363,7 @@ get_index_register (char *reg_name)\n {\n   const reg_entry *rreg;\n \n-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);\n+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);\n \n   if ((rreg != NULL)\n       && ((rreg->value.reg_val == 12) || (rreg->value.reg_val == 13)))\n@@ -378,7 +378,7 @@ get_index_register_pair (char *reg_name)\n {\n   const reg_entry *rreg;\n \n-  rreg = (const reg_entry *) hash_find (regp_hash, reg_name);\n+  rreg = (const reg_entry *) str_hash_find (regp_hash, reg_name);\n \n   if (rreg != NULL)\n     {\n@@ -399,7 +399,7 @@ get_pregister (char *preg_name)\n {\n   const reg_entry *prreg;\n \n-  prreg = (const reg_entry *) hash_find (preg_hash, preg_name);\n+  prreg = (const reg_entry *) str_hash_find (preg_hash, preg_name);\n \n   if (prreg != NULL)\n     return prreg->value.preg_val;\n@@ -414,7 +414,7 @@ get_pregisterp (char *preg_name)\n {\n   const reg_entry *prreg;\n \n-  prreg = (const reg_entry *) hash_find (pregp_hash, preg_name);\n+  prreg = (const reg_entry *) str_hash_find (pregp_hash, preg_name);\n \n   if (prreg != NULL)\n     return prreg->value.preg_val;\n@@ -794,25 +794,18 @@ md_pcrel_from (fixS *fixp)\n }\n \n static void\n-initialise_reg_hash_table (struct hash_control ** hash_table,\n+initialise_reg_hash_table (htab_t * hash_table,\n                            const reg_entry * register_table,\n                            const unsigned int num_entries)\n {\n   const reg_entry * rreg;\n-  const char *hashret;\n-\n-  if ((* hash_table = hash_new ()) == NULL)\n+  if ((* hash_table = str_htab_create ()) == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   for (rreg = register_table;\n        rreg < (register_table + num_entries);\n        rreg++)\n-    {\n-      hashret = hash_insert (* hash_table, rreg->name, (char *) rreg);\n-      if (hashret)\n-        as_fatal (_(\"Internal Error:  Can't hash %s: %s\"),\n-                  rreg->name, hashret);\n-    }\n+    str_hash_insert (* hash_table, rreg->name, (char *) rreg);\n }\n \n /* This function is called once, at assembler startup time.  This should\n@@ -824,21 +817,15 @@ md_begin (void)\n   int i = 0;\n \n   /* Set up a hash table for the instructions.  */\n-  if ((cr16_inst_hash = hash_new ()) == NULL)\n+  if ((cr16_inst_hash = str_htab_create ()) == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   while (cr16_instruction[i].mnemonic != NULL)\n     {\n-      const char *hashret;\n       const char *mnemonic = cr16_instruction[i].mnemonic;\n \n-      hashret = hash_insert (cr16_inst_hash, mnemonic,\n-                             (char *)(cr16_instruction + i));\n-\n-      if (hashret != NULL && *hashret != '\\0')\n-        as_fatal (_(\"Can't hash `%s': %s\\n\"), cr16_instruction[i].mnemonic,\n-                  *hashret == 0 ? _(\"(unknown reason)\") : hashret);\n-\n+      str_hash_insert (cr16_inst_hash, mnemonic,\n+\t\t       (char *)(cr16_instruction + i));\n       /* Insert unique names into hash table.  The CR16 instruction set\n          has many identical opcode names that have different opcodes based\n          on the operands.  This hash table then provides a quick index to\n@@ -2505,7 +2492,7 @@ cr16_assemble (const char *op, char *param)\n   ins cr16_ins;\n \n   /* Find the instruction.  */\n-  instruction = (const inst *) hash_find (cr16_inst_hash, op);\n+  instruction = (const inst *) str_hash_find (cr16_inst_hash, op);\n   if (instruction == NULL)\n     {\n       as_bad (_(\"Unknown opcode: `%s'\"), op);\n@@ -2575,7 +2562,7 @@ md_assemble (char *op)\n     {\n       strcpy (param1, param);\n       /* Find the instruction.  */\n-      instruction = (const inst *) hash_find (cr16_inst_hash, op);\n+      instruction = (const inst *) str_hash_find (cr16_inst_hash, op);\n        parse_operands (&cr16_ins, param1);\n       if (((&cr16_ins)->arg[0].type == arg_ic)\n           && ((&cr16_ins)->arg[0].constant >= 0))"
    },
    {
      "sha": "ea8890f488bda47153bb93bb7b336db1cbeb8996",
      "filename": "gas/config/tc-cris.c",
      "status": "modified",
      "additions": 5,
      "deletions": 10,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-cris.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -160,7 +160,7 @@ static void cris_sym_no_leading_underscore (void);\n static char *cris_insn_first_word_frag (void);\n \n /* Handle to the opcode hash table.  */\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n /* If we target cris-axis-linux-gnu (as opposed to generic cris-axis-elf),\n    we default to no underscore and required register-prefixes.  The\n@@ -1186,11 +1186,10 @@ cris_insn_first_word_frag (void)\n void\n md_begin (void)\n {\n-  const char *hashret = NULL;\n   int i = 0;\n \n   /* Set up a hash table for the instructions.  */\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n   if (op_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n@@ -1222,12 +1221,8 @@ md_begin (void)\n \t  continue;\n \t}\n \n-      /* Need to cast to get rid of \"const\".  FIXME: Fix hash_insert instead.  */\n-      hashret = hash_insert (op_hash, name, (void *) &cris_opcodes[i]);\n-\n-      if (hashret != NULL && *hashret != '\\0')\n-\tas_fatal (_(\"Can't hash `%s': %s\\n\"), cris_opcodes[i].name,\n-\t\t  *hashret == 0 ? _(\"(unknown reason)\") : hashret);\n+      /* Need to cast to get rid of \"const\".  FIXME: Fix str_hash_insert instead.  */\n+      str_hash_insert (op_hash, name, (void *) &cris_opcodes[i]);\n       do\n \t{\n \t  if (cris_opcodes[i].match & cris_opcodes[i].lose)\n@@ -1558,7 +1553,7 @@ cris_process_instruction (char *insn_text, struct cris_instruction *out_insnp,\n     }\n \n   /* Find the instruction.  */\n-  instruction = (struct cris_opcode *) hash_find (op_hash, insn_text);\n+  instruction = (struct cris_opcode *) str_hash_find (op_hash, insn_text);\n   if (instruction == NULL)\n     {\n       as_bad (_(\"Unknown opcode: `%s'\"), insn_text);"
    },
    {
      "sha": "2757db8f33d1e27972daf938b3afaa155f22ef5a",
      "filename": "gas/config/tc-crx.c",
      "status": "modified",
      "additions": 13,
      "deletions": 30,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-crx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-crx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-crx.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -63,11 +63,11 @@ typedef enum\n op_err;\n \n /* Opcode mnemonics hash table.  */\n-static struct hash_control *crx_inst_hash;\n+static htab_t crx_inst_hash;\n /* CRX registers hash table.  */\n-static struct hash_control *reg_hash;\n+static htab_t reg_hash;\n /* CRX coprocessor registers hash table.  */\n-static struct hash_control *copreg_hash;\n+static htab_t copreg_hash;\n /* Current instruction we're assembling.  */\n static const inst *instruction;\n \n@@ -208,7 +208,7 @@ get_register (char *reg_name)\n {\n   const reg_entry *rreg;\n \n-  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);\n+  rreg = (const reg_entry *) str_hash_find (reg_hash, reg_name);\n \n   if (rreg != NULL)\n     return rreg->value.reg_val;\n@@ -223,7 +223,7 @@ get_copregister (char *copreg_name)\n {\n   const reg_entry *coreg;\n \n-  coreg = (const reg_entry *) hash_find (copreg_hash, copreg_name);\n+  coreg = (const reg_entry *) str_hash_find (copreg_hash, copreg_name);\n \n   if (coreg != NULL)\n     return coreg->value.copreg_val;\n@@ -527,24 +527,19 @@ md_pcrel_from (fixS *fixp)\n void\n md_begin (void)\n {\n-  const char *hashret = NULL;\n   int i = 0;\n \n   /* Set up a hash table for the instructions.  */\n-  if ((crx_inst_hash = hash_new ()) == NULL)\n+  if ((crx_inst_hash = str_htab_create ()) == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   while (crx_instruction[i].mnemonic != NULL)\n     {\n       const char *mnemonic = crx_instruction[i].mnemonic;\n \n-      hashret = hash_insert (crx_inst_hash, mnemonic,\n+      str_hash_insert (crx_inst_hash, mnemonic,\n \t\t\t     (void *) &crx_instruction[i]);\n \n-      if (hashret != NULL && *hashret != '\\0')\n-\tas_fatal (_(\"Can't hash `%s': %s\\n\"), crx_instruction[i].mnemonic,\n-\t\t  *hashret == 0 ? _(\"(unknown reason)\") : hashret);\n-\n       /* Insert unique names into hash table.  The CRX instruction set\n \t has many identical opcode names that have different opcodes based\n \t on the operands.  This hash table then provides a quick index to\n@@ -558,40 +553,28 @@ md_begin (void)\n     }\n \n   /* Initialize reg_hash hash table.  */\n-  if ((reg_hash = hash_new ()) == NULL)\n+  if ((reg_hash = str_htab_create ()) == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   {\n     const reg_entry *regtab;\n \n     for (regtab = crx_regtab;\n \t regtab < (crx_regtab + NUMREGS); regtab++)\n-      {\n-\thashret = hash_insert (reg_hash, regtab->name, (void *) regtab);\n-\tif (hashret)\n-\t  as_fatal (_(\"Internal error: Can't hash %s: %s\"),\n-\t\t    regtab->name,\n-\t\t    hashret);\n-      }\n+      str_hash_insert (reg_hash, regtab->name, (void *) regtab);\n   }\n \n   /* Initialize copreg_hash hash table.  */\n-  if ((copreg_hash = hash_new ()) == NULL)\n+  if ((copreg_hash = str_htab_create ()) == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   {\n     const reg_entry *copregtab;\n \n     for (copregtab = crx_copregtab; copregtab < (crx_copregtab + NUMCOPREGS);\n \t copregtab++)\n-      {\n-\thashret = hash_insert (copreg_hash, copregtab->name,\n-\t\t\t       (void *) copregtab);\n-\tif (hashret)\n-\t  as_fatal (_(\"Internal error: Can't hash %s: %s\"),\n-\t\t    copregtab->name,\n-\t\t    hashret);\n-      }\n+      str_hash_insert (copreg_hash, copregtab->name,\n+\t\t       (void *) copregtab);\n   }\n   /*  Set linkrelax here to avoid fixups in most sections.  */\n   linkrelax = 1;\n@@ -1989,7 +1972,7 @@ md_assemble (char *op)\n   *param++ = '\\0';\n \n   /* Find the instruction.  */\n-  instruction = (const inst *) hash_find (crx_inst_hash, op);\n+  instruction = (const inst *) str_hash_find (crx_inst_hash, op);\n   if (instruction == NULL)\n     {\n       as_bad (_(\"Unknown opcode: `%s'\"), op);"
    },
    {
      "sha": "d56bcc222a3afd999269ecfb8b5ec9f93d466e2f",
      "filename": "gas/config/tc-csky.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-csky.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -754,8 +754,8 @@ size_t md_longopts_size = sizeof (md_longopts);\n \n static struct csky_insn_info csky_insn;\n \n-static struct hash_control *csky_opcodes_hash;\n-static struct hash_control *csky_macros_hash;\n+static htab_t csky_opcodes_hash;\n+static htab_t csky_macros_hash;\n \n static struct csky_macro_info v1_macros_table[] =\n {\n@@ -1356,16 +1356,16 @@ md_begin (void)\n     }\n \n   /* Establish hash table for opcodes and macros.  */\n-  csky_macros_hash = hash_new ();\n-  csky_opcodes_hash = hash_new ();\n+  csky_macros_hash = str_htab_create ();\n+  csky_opcodes_hash = str_htab_create ();\n   for ( ; opcode->mnemonic != NULL; opcode++)\n     if ((isa_flag & (opcode->isa_flag16 | opcode->isa_flag32)) != 0)\n-      hash_insert (csky_opcodes_hash, opcode->mnemonic, (char *)opcode);\n+      str_hash_insert (csky_opcodes_hash, opcode->mnemonic, (char *)opcode);\n   for ( ; macro->name != NULL; macro++)\n     if ((isa_flag & macro->isa_flag) != 0)\n-      hash_insert (csky_macros_hash, macro->name, (char *)macro);\n+      str_hash_insert (csky_macros_hash, macro->name, (char *)macro);\n   if (do_nolrw && (isa_flag & CSKYV2_ISA_1E2) != 0)\n-    hash_insert (csky_macros_hash,\n+    str_hash_insert (csky_macros_hash,\n \t\t v2_lrw_macro_opcode.name,\n \t\t (char *)&v2_lrw_macro_opcode);\n   /* Set e_flag to ELF Head.  */\n@@ -2933,9 +2933,9 @@ parse_opcode (char *str)\n   csky_insn.number = csky_count_operands (opcode_end);\n \n   /* Find hash by name in csky_macros_hash and csky_opcodes_hash.  */\n-  csky_insn.macro = (struct csky_macro_info *) hash_find (csky_macros_hash,\n+  csky_insn.macro = (struct csky_macro_info *) str_hash_find (csky_macros_hash,\n \t\t\t\t\t\t\t  macro_name);\n-  csky_insn.opcode = (struct csky_opcode *) hash_find (csky_opcodes_hash,\n+  csky_insn.opcode = (struct csky_opcode *) str_hash_find (csky_opcodes_hash,\n \t\t\t\t\t\t\tname);\n \n   if (csky_insn.macro == NULL && csky_insn.opcode == NULL)\n@@ -3157,7 +3157,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t    {\n \t      const char *name = \"movi\";\n \t      csky_insn.opcode = (struct csky_opcode *)\n-\t\thash_find (csky_opcodes_hash, name);\n+\t\tstr_hash_find (csky_opcodes_hash, name);\n \t      csky_insn.val[csky_insn.idx - 1] = 1 << val;\n \t    }\n \t  return TRUE;\n@@ -3191,7 +3191,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t      {\n \t\tconst char *name = \"movi\";\n \t\tcsky_insn.opcode = (struct csky_opcode *)\n-\t\t  hash_find (csky_opcodes_hash, name);\n+\t\t  str_hash_find (csky_opcodes_hash, name);\n \t\tas_warn (_(\"translating mgeni to movi\"));\n \t      }\n \t    else\n@@ -3225,7 +3225,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t    {\n \t      const char *op_movi = \"movi\";\n \t      csky_insn.opcode = (struct csky_opcode *)\n-\t\thash_find (csky_opcodes_hash, op_movi);\n+\t\tstr_hash_find (csky_opcodes_hash, op_movi);\n \t      if (csky_insn.opcode == NULL)\n \t\treturn FALSE;\n \t      csky_insn.val[csky_insn.idx - 1] = (1 << mask_val) - 1;\n@@ -3275,7 +3275,7 @@ get_operand_value (struct csky_opcode_info *op,\n \t    {\n \t      const char *op_movi = \"movi\";\n \t      csky_insn.opcode = (struct csky_opcode *)\n-\t\thash_find (csky_opcodes_hash, op_movi);\n+\t\tstr_hash_find (csky_opcodes_hash, op_movi);\n \t      if (csky_insn.opcode == NULL)\n \t\treturn FALSE;\n \t      csky_insn.val[csky_insn.idx - 1] = (1 << (mask_val + 1)) - 1;\n@@ -5955,7 +5955,7 @@ v1_work_jbsr (void)\n       /* Using jsri instruction.  */\n       const char *name = \"jsri\";\n       csky_insn.opcode = (struct csky_opcode *)\n-\thash_find (csky_opcodes_hash, name);\n+\tstr_hash_find (csky_opcodes_hash, name);\n       csky_insn.opcode_idx = 0;\n       csky_insn.isize = 2;\n \n@@ -6293,7 +6293,7 @@ v2_work_rotlc (void)\n {\n   const char *name = \"addc\";\n   csky_insn.opcode\n-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);\n+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);\n   csky_insn.opcode_idx = 0;\n   if (csky_insn.isize == 2)\n     {\n@@ -6331,7 +6331,7 @@ v2_work_bgeni (void)\n       val >>= 16;\n     }\n   csky_insn.opcode\n-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);\n+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);\n   csky_insn.opcode_idx = 0;\n   csky_insn.val[1] = val;\n \n@@ -6349,7 +6349,7 @@ v2_work_not (void)\n {\n   const char *name = \"nor\";\n   csky_insn.opcode\n-    = (struct csky_opcode *) hash_find (csky_opcodes_hash, name);\n+    = (struct csky_opcode *) str_hash_find (csky_opcodes_hash, name);\n   csky_insn.opcode_idx = 0;\n   if (csky_insn.number == 1)\n     {"
    },
    {
      "sha": "bc87dc637d2739d2e613b3b68be32b6a94b48503",
      "filename": "gas/config/tc-d10v.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d10v.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -101,7 +101,7 @@ struct option md_longopts[] =\n size_t md_longopts_size = sizeof (md_longopts);\n \n /* Opcode hash table.  */\n-static struct hash_control *d10v_hash;\n+static htab_t d10v_hash;\n \n /* Do a binary search of the d10v_predefined_registers array to see if\n    NAME is a valid register name.  Return the register number from the\n@@ -277,7 +277,7 @@ md_begin (void)\n {\n   const char *prev_name = \"\";\n   struct d10v_opcode *opcode;\n-  d10v_hash = hash_new ();\n+  d10v_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  The D10v instruction set\n      has many identical opcode names that have different opcodes based\n@@ -289,7 +289,7 @@ md_begin (void)\n       if (strcmp (prev_name, opcode->name))\n \t{\n \t  prev_name = (char *) opcode->name;\n-\t  hash_insert (d10v_hash, opcode->name, (char *) opcode);\n+\t  str_hash_insert (d10v_hash, opcode->name, (char *) opcode);\n \t}\n     }\n \n@@ -1430,7 +1430,7 @@ do_assemble (char *str, struct d10v_opcode **opcode)\n     return -1;\n \n   /* Find the first opcode with the proper name.  */\n-  *opcode = (struct d10v_opcode *) hash_find (d10v_hash, name);\n+  *opcode = (struct d10v_opcode *) str_hash_find (d10v_hash, name);\n   if (*opcode == NULL)\n     return -1;\n \n@@ -1558,8 +1558,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)\n \t{\n \t  struct d10v_opcode *rep, *repi;\n \n-\t  rep = (struct d10v_opcode *) hash_find (d10v_hash, \"rep\");\n-\t  repi = (struct d10v_opcode *) hash_find (d10v_hash, \"repi\");\n+\t  rep = (struct d10v_opcode *) str_hash_find (d10v_hash, \"rep\");\n+\t  repi = (struct d10v_opcode *) str_hash_find (d10v_hash, \"repi\");\n \t  if ((insn & FM11) == FM11\n \t      && ((repi != NULL\n \t\t   && (insn & repi->mask) == (unsigned) repi->opcode)"
    },
    {
      "sha": "1e06bea582abc4178793561890980a40105fd026",
      "filename": "gas/config/tc-d30v.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-d30v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-d30v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-d30v.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -118,7 +118,7 @@ struct option md_longopts[] =\n size_t md_longopts_size = sizeof (md_longopts);\n \n /* Opcode hash table.  */\n-static struct hash_control *d30v_hash;\n+static htab_t d30v_hash;\n \n /* Do a binary search of the pre_defined_registers array to see if\n    NAME is a valid register name.  Return the register number from the\n@@ -310,11 +310,11 @@ void\n md_begin (void)\n {\n   struct d30v_opcode *opcode;\n-  d30v_hash = hash_new ();\n+  d30v_hash = str_htab_create ();\n \n   /* Insert opcode names into a hash table.  */\n   for (opcode = (struct d30v_opcode *) d30v_opcode_table; opcode->name; opcode++)\n-      hash_insert (d30v_hash, opcode->name, (char *) opcode);\n+      str_hash_insert (d30v_hash, opcode->name, (char *) opcode);\n \n   fixups = &FixUps[0];\n   FixUps[0].next = &FixUps[1];\n@@ -1390,7 +1390,7 @@ do_assemble (char *str,\n     }\n \n   /* Find the first opcode with the proper name.  */\n-  opcode->op = (struct d30v_opcode *) hash_find (d30v_hash, name);\n+  opcode->op = (struct d30v_opcode *) str_hash_find (d30v_hash, name);\n   if (opcode->op == NULL)\n     {\n       as_bad (_(\"unknown opcode: %s\"), name);"
    },
    {
      "sha": "f08f44228728cbb64be383584f9ecf78d5e6be2f",
      "filename": "gas/config/tc-dlx.c",
      "status": "modified",
      "additions": 4,
      "deletions": 17,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-dlx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-dlx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-dlx.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -43,7 +43,7 @@\n #define RELOC_DLX_VTENTRY   BFD_RELOC_VTABLE_ENTRY\n \n /* handle of the OPCODE hash table */\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n struct machine_it\n {\n@@ -276,31 +276,18 @@ s_proc (int end_p)\n void\n md_begin (void)\n {\n-  const char *retval = NULL;\n-  int lose = 0;\n   unsigned int i;\n \n   /* Create a new hash table.  */\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   /* Hash up all the opcodes for fast use later.  */\n   for (i = 0; i < num_dlx_opcodes; i++)\n     {\n       const char *name = machine_opcodes[i].name;\n-\n-      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);\n-\n-      if (retval != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   machine_opcodes[i].name, retval);\n-\t  lose = 1;\n-\t}\n+      str_hash_insert (op_hash, name, (void *) &machine_opcodes[i]);\n     }\n \n-  if (lose)\n-    as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\n   define_some_regs ();\n }\n \n@@ -694,7 +681,7 @@ machine_ip (char *str)\n     }\n \n   /* Hash the opcode, insn will have the string from opcode table.  */\n-  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)\n+  if ((insn = (struct machine_opcode *) str_hash_find (op_hash, str)) == NULL)\n     {\n       /* Handle the ret and return macro here.  */\n       if ((strcmp (str, \"ret\") == 0) || (strcmp (str, \"return\") == 0))"
    },
    {
      "sha": "fc3b18111d65889bb3ed11ca19ca825d4ec603a2",
      "filename": "gas/config/tc-ft32.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ft32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ft32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ft32.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -34,7 +34,7 @@ const char line_separator_chars[] = \";\";\n const char line_comment_chars[]   = \"#\";\n \n static int pending_reloc;\n-static struct hash_control *opcode_hash_control;\n+static htab_t opcode_hash_control;\n \n static valueT md_chars_to_number (char * buf, int n);\n \n@@ -54,11 +54,11 @@ void\n md_begin (void)\n {\n   const ft32_opc_info_t *opcode;\n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert names into hash table.  */\n   for (opcode = ft32_opc_info; opcode->name; opcode++)\n-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n \n   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);\n   if (!norelax)\n@@ -231,7 +231,7 @@ md_assemble (char *str)\n   if (nlen == 0)\n     as_bad (_(\"can't find opcode \"));\n \n-  opcode = (ft32_opc_info_t *) hash_find (opcode_hash_control, op_start);\n+  opcode = (ft32_opc_info_t *) str_hash_find (opcode_hash_control, op_start);\n   *op_end = pend;\n \n   if (opcode == NULL)"
    },
    {
      "sha": "cbde92ee8559ed656db41af626b21a5e8893f466",
      "filename": "gas/config/tc-h8300.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-h8300.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -224,7 +224,7 @@ const char EXP_CHARS[] = \"eE\";\n    or    0d1.2345e12.  */\n const char FLT_CHARS[] = \"rRsSfFdDxXpP\";\n \n-static struct hash_control *opcode_hash_control;\t/* Opcode mnemonics.  */\n+static htab_t opcode_hash_control;\t/* Opcode mnemonics.  */\n \n /* This function is called once, at assembler startup time.  This\n    should set up all the tables, etc. that the MD part of the assembler\n@@ -242,7 +242,7 @@ md_begin (void)\n   if (!bfd_set_arch_mach (stdoutput, bfd_arch_h8300, default_mach))\n     as_warn (_(\"could not set architecture and machine\"));\n \n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n   prev_buffer[0] = 0;\n \n   nopcodes = sizeof (h8_opcodes) / sizeof (struct h8_opcode);\n@@ -283,7 +283,7 @@ md_begin (void)\n       len = dst - buffer;\n       if (cmplen == 0)\n \tcmplen = len;\n-      hash_insert (opcode_hash_control, buffer, (char *) pi);\n+      str_hash_insert (opcode_hash_control, buffer, (char *) pi);\n       strcpy (prev_buffer, buffer);\n       idx++;\n \n@@ -1940,7 +1940,7 @@ md_assemble (char *str)\n       *slash = TOLOWER (*slash);\n \n   instruction = (const struct h8_instruction *)\n-    hash_find (opcode_hash_control, op_start);\n+    str_hash_find (opcode_hash_control, op_start);\n \n   if (instruction == NULL)\n     {"
    },
    {
      "sha": "272605b26f8b4697961ab26ffed33091e6092239",
      "filename": "gas/config/tc-hppa.c",
      "status": "modified",
      "additions": 4,
      "deletions": 10,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-hppa.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -550,7 +550,7 @@ static struct call_info *last_call_info;\n static struct call_desc last_call_desc;\n \n /* handle of the OPCODE hash table */\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n /* These characters can be suffixes of opcode names and they may be\n    followed by meaningful whitespace.  We don't include `,' and `!'\n@@ -3214,7 +3214,7 @@ pa_ip (char *str)\n     }\n \n   /* Look up the opcode in the hash table.  */\n-  if ((insn = (struct pa_opcode *) hash_find (op_hash, str)) == NULL)\n+  if ((insn = (struct pa_opcode *) str_hash_find (op_hash, str)) == NULL)\n     {\n       as_bad (_(\"Unknown opcode: `%s'\"), str);\n       return;\n@@ -8215,7 +8215,6 @@ pa_lsym (int unused ATTRIBUTE_UNUSED)\n void\n md_begin (void)\n {\n-  const char *retval = NULL;\n   int lose = 0;\n   unsigned int i = 0;\n \n@@ -8238,18 +8237,13 @@ md_begin (void)\n   pa_spaces_begin ();\n #endif\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   while (i < NUMOPCODES)\n     {\n       const char *name = pa_opcodes[i].name;\n \n-      retval = hash_insert (op_hash, name, (struct pa_opcode *) &pa_opcodes[i]);\n-      if (retval != NULL && *retval != '\\0')\n-\t{\n-\t  as_fatal (_(\"Internal error: can't hash `%s': %s\\n\"), name, retval);\n-\t  lose = 1;\n-\t}\n+      str_hash_insert (op_hash, name, (void *)&pa_opcodes[i]);\n \n       do\n \t{"
    },
    {
      "sha": "752a98b4ef1e33e7c9adfc285c3e9f1fa0fb54e9",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 18,
      "deletions": 34,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -1376,10 +1376,10 @@ const pseudo_typeS md_pseudo_table[] =\n extern char *input_line_pointer;\n \n /* Hash table for instruction mnemonic lookup.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \n /* Hash table for register lookup.  */\n-static struct hash_control *reg_hash;\n+static htab_t reg_hash;\n \f\n   /* Various efficient no-op patterns for aligning code labels.\n      Note: Don't try to assemble the instructions in the comments.\n@@ -3026,13 +3026,11 @@ i386_mach (void)\n void\n md_begin (void)\n {\n-  const char *hash_err;\n-\n   /* Support pseudo prefixes like {disp32}.  */\n   lex_type ['{'] = LEX_BEGIN_NAME;\n \n   /* Initialize op_hash hash table.  */\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   {\n     const insn_template *optab;\n@@ -3052,15 +3050,7 @@ md_begin (void)\n \t    /* different name --> ship out current template list;\n \t       add to hash table; & begin anew.  */\n \t    core_optab->end = optab;\n-\t    hash_err = hash_insert (op_hash,\n-\t\t\t\t    (optab - 1)->name,\n-\t\t\t\t    (void *) core_optab);\n-\t    if (hash_err)\n-\t      {\n-\t\tas_fatal (_(\"can't hash %s: %s\"),\n-\t\t\t  (optab - 1)->name,\n-\t\t\t  hash_err);\n-\t      }\n+\t    str_hash_insert (op_hash, (optab - 1)->name, (void *) core_optab);\n \t    if (optab->name == NULL)\n \t      break;\n \t    core_optab = XNEW (templates);\n@@ -3070,19 +3060,13 @@ md_begin (void)\n   }\n \n   /* Initialize reg_hash hash table.  */\n-  reg_hash = hash_new ();\n+  reg_hash = str_htab_create ();\n   {\n     const reg_entry *regtab;\n     unsigned int regtab_size = i386_regtab_size;\n \n     for (regtab = i386_regtab; regtab_size--; regtab++)\n-      {\n-\thash_err = hash_insert (reg_hash, regtab->reg_name, (void *) regtab);\n-\tif (hash_err)\n-\t  as_fatal (_(\"can't hash %s: %s\"),\n-\t\t    regtab->reg_name,\n-\t\t    hash_err);\n-      }\n+      str_hash_insert (reg_hash, regtab->reg_name, (void *) regtab);\n   }\n \n   /* Fill in lexical tables:  mnemonic_chars, operand_chars.  */\n@@ -3173,8 +3157,8 @@ md_begin (void)\n void\n i386_print_statistics (FILE *file)\n {\n-  hash_print_statistics (file, \"i386 opcode\", op_hash);\n-  hash_print_statistics (file, \"i386 register\", reg_hash);\n+  htab_print_statistics (file, \"i386 opcode\", op_hash);\n+  htab_print_statistics (file, \"i386 register\", reg_hash);\n }\n \f\n #ifdef DEBUG386\n@@ -5088,7 +5072,7 @@ parse_insn (char *line, char *mnemonic)\n \t}\n \n       /* Look up instruction (or prefix) via hash table.  */\n-      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n+      current_templates = (const templates *) str_hash_find (op_hash, mnemonic);\n \n       if (*l != END_OF_INSN\n \t  && (!is_space_char (*l) || l[1] != END_OF_INSN)\n@@ -5214,7 +5198,7 @@ parse_insn (char *line, char *mnemonic)\n \tgoto check_suffix;\n       mnem_p = dot_p;\n       *dot_p = '\\0';\n-      current_templates = (const templates *) hash_find (op_hash, mnemonic);\n+      current_templates = (const templates *) str_hash_find (op_hash, mnemonic);\n     }\n \n   if (!current_templates)\n@@ -5234,7 +5218,7 @@ parse_insn (char *line, char *mnemonic)\n \t      case QWORD_MNEM_SUFFIX:\n \t\ti.suffix = mnem_p[-1];\n \t      mnem_p[-1] = '\\0';\n-\t      current_templates = (const templates *) hash_find (op_hash,\n+\t      current_templates = (const templates *) str_hash_find (op_hash,\n \t\t\t\t\t\t\t\t mnemonic);\n \t      break;\n \t    case SHORT_MNEM_SUFFIX:\n@@ -5243,7 +5227,7 @@ parse_insn (char *line, char *mnemonic)\n \t\t{\n \t\t  i.suffix = mnem_p[-1];\n \t\t  mnem_p[-1] = '\\0';\n-\t\t  current_templates = (const templates *) hash_find (op_hash,\n+\t\t  current_templates = (const templates *) str_hash_find (op_hash,\n \t\t\t\t\t\t\t\t     mnemonic);\n \t\t}\n \t      break;\n@@ -5257,7 +5241,7 @@ parse_insn (char *line, char *mnemonic)\n \t\t  else\n \t\t    i.suffix = LONG_MNEM_SUFFIX;\n \t\t  mnem_p[-1] = '\\0';\n-\t\t  current_templates = (const templates *) hash_find (op_hash,\n+\t\t  current_templates = (const templates *) str_hash_find (op_hash,\n \t\t\t\t\t\t\t\t     mnemonic);\n \t\t}\n \t      break;\n@@ -7564,7 +7548,7 @@ process_operands (void)\n \t      i.flags[j] = i.flags[j - 1];\n \t    }\n \t  i.op[0].regs\n-\t    = (const reg_entry *) hash_find (reg_hash, \"xmm0\");\n+\t    = (const reg_entry *) str_hash_find (reg_hash, \"xmm0\");\n \t  i.types[0] = regxmm;\n \t  i.tm.operand_types[0] = regxmm;\n \n@@ -10984,10 +10968,10 @@ i386_index_check (const char *operand_string)\n \t\t  && current_templates->end[-1].operand_types[1]\n \t\t     .bitfield.baseindex))\n \t    op = 1;\n-\t  expected_reg = hash_find (reg_hash, di_si[addr_mode][op == es_op]);\n+\t  expected_reg = (const reg_entry *)str_hash_find (reg_hash, di_si[addr_mode][op == es_op]);\n \t}\n       else\n-\texpected_reg = hash_find (reg_hash, bx[addr_mode]);\n+\texpected_reg = (const reg_entry *)str_hash_find (reg_hash, bx[addr_mode]);\n \n       if (i.base_reg != expected_reg\n \t  || i.index_reg\n@@ -12638,7 +12622,7 @@ parse_real_register (char *reg_string, char **end_op)\n \n   *end_op = s;\n \n-  r = (const reg_entry *) hash_find (reg_hash, reg_name_given);\n+  r = (const reg_entry *) str_hash_find (reg_hash, reg_name_given);\n \n   /* Handle floating point regs, allowing spaces in the (i) part.  */\n   if (r == i386_regtab /* %st is first entry of table  */)\n@@ -12665,7 +12649,7 @@ parse_real_register (char *reg_string, char **end_op)\n \t      if (*s == ')')\n \t\t{\n \t\t  *end_op = s + 1;\n-\t\t  r = (const reg_entry *) hash_find (reg_hash, \"st(0)\");\n+\t\t  r = (const reg_entry *) str_hash_find (reg_hash, \"st(0)\");\n \t\t  know (r);\n \t\t  return r + fpr;\n \t\t}"
    },
    {
      "sha": "1686579b1b5037a561bf16f084166f3960398b20",
      "filename": "gas/config/tc-ia64.c",
      "status": "modified",
      "additions": 60,
      "deletions": 89,
      "changes": 149,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ia64.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -185,10 +185,10 @@ static void ia64_float_to_chars_littleendian (char *, LITTLENUM_TYPE *, int);\n \n static void (*ia64_float_to_chars) (char *, LITTLENUM_TYPE *, int);\n \n-static struct hash_control *alias_hash;\n-static struct hash_control *alias_name_hash;\n-static struct hash_control *secalias_hash;\n-static struct hash_control *secalias_name_hash;\n+static htab_t alias_hash;\n+static htab_t alias_name_hash;\n+static htab_t secalias_hash;\n+static htab_t secalias_name_hash;\n \n /* List of chars besides those in app.c:symbol_chars that can start an\n    operand.  Used to prevent the scrubber eating vital white-space.  */\n@@ -228,11 +228,11 @@ size_t md_longopts_size = sizeof (md_longopts);\n \n static struct\n   {\n-    struct hash_control *pseudo_hash;\t/* pseudo opcode hash table */\n-    struct hash_control *reg_hash;\t/* register name hash table */\n-    struct hash_control *dynreg_hash;\t/* dynamic register hash table */\n-    struct hash_control *const_hash;\t/* constant hash table */\n-    struct hash_control *entry_hash;    /* code entry hint hash table */\n+    htab_t pseudo_hash;\t/* pseudo opcode hash table */\n+    htab_t reg_hash;\t/* register name hash table */\n+    htab_t dynreg_hash;\t/* dynamic register hash table */\n+    htab_t const_hash;\t/* constant hash table */\n+    htab_t entry_hash;    /* code entry hint hash table */\n \n     /* If X_op is != O_absent, the register name for the instruction's\n        qualifying predicate.  If NULL, p0 is assumed for instructions\n@@ -4602,7 +4602,7 @@ dot_rot (int type)\n   /* First, remove existing names from hash table.  */\n   for (dr = md.dynreg[type]; dr && dr->num_regs; dr = dr->next)\n     {\n-      hash_delete (md.dynreg_hash, dr->name, FALSE);\n+      str_hash_delete (md.dynreg_hash, dr->name);\n       /* FIXME: Free dr->name.  */\n       dr->num_regs = 0;\n     }\n@@ -4683,12 +4683,7 @@ dot_rot (int type)\n       drpp = &dr->next;\n       base_reg += num_regs;\n \n-      if (hash_insert (md.dynreg_hash, name, dr))\n-\t{\n-\t  as_bad (_(\"Attempt to redefine register set `%s'\"), name);\n-\t  obstack_free (&notes, name);\n-\t  goto err;\n-\t}\n+      str_hash_insert (md.dynreg_hash, name, dr);\n \n       if (*input_line_pointer != ',')\n \tbreak;\n@@ -5166,7 +5161,6 @@ dot_pred_rel (int type)\n static void\n dot_entry (int dummy ATTRIBUTE_UNUSED)\n {\n-  const char *err;\n   char *name;\n   int c;\n   symbolS *symbolP;\n@@ -5176,10 +5170,7 @@ dot_entry (int dummy ATTRIBUTE_UNUSED)\n       c = get_symbol_name (&name);\n       symbolP = symbol_find_or_make (name);\n \n-      err = hash_insert (md.entry_hash, S_GET_NAME (symbolP), (void *) symbolP);\n-      if (err)\n-\tas_fatal (_(\"Inserting \\\"%s\\\" into entry hint table failed: %s\"),\n-\t\t  name, err);\n+      str_hash_insert (md.entry_hash, S_GET_NAME (symbolP), (void *) symbolP);\n \n       *input_line_pointer = c;\n       SKIP_WHITESPACE_AFTER_NAME ();\n@@ -5378,15 +5369,11 @@ pseudo_opcode[] =\n static symbolS *\n declare_register (const char *name, unsigned int regnum)\n {\n-  const char *err;\n   symbolS *sym;\n \n   sym = symbol_create (name, reg_section, regnum, &zero_address_frag);\n \n-  err = hash_insert (md.reg_hash, S_GET_NAME (sym), (void *) sym);\n-  if (err)\n-    as_fatal (\"Inserting \\\"%s\\\" into register table failed: %s\",\n-\t      name, err);\n+  str_hash_insert (md.reg_hash, S_GET_NAME (sym), (void *) sym);\n \n   return sym;\n }\n@@ -7241,8 +7228,6 @@ void\n md_begin (void)\n {\n   int i, j, k, t, goodness, best, ok;\n-  const char *err;\n-  char name[8];\n \n   md.auto_align = 1;\n   md.explicit_mode = md.default_explicit_mode;\n@@ -7253,10 +7238,10 @@ md_begin (void)\n   target_big_endian = -1;\n   dot_byteorder (default_big_endian);\n \n-  alias_hash = hash_new ();\n-  alias_name_hash = hash_new ();\n-  secalias_hash = hash_new ();\n-  secalias_name_hash = hash_new ();\n+  alias_hash = str_htab_create ();\n+  alias_name_hash = str_htab_create ();\n+  secalias_hash = str_htab_create ();\n+  secalias_name_hash = str_htab_create ();\n \n   pseudo_func[FUNC_DTP_MODULE].u.sym =\n     symbol_new (\".<dtpmod>\", undefined_section, FUNC_DTP_MODULE,\n@@ -7405,20 +7390,15 @@ md_begin (void)\n   for (i = 0; i < NUM_SLOTS; ++i)\n     md.slot[i].user_template = -1;\n \n-  md.pseudo_hash = hash_new ();\n+  md.pseudo_hash = str_htab_create ();\n   for (i = 0; i < NELEMS (pseudo_opcode); ++i)\n-    {\n-      err = hash_insert (md.pseudo_hash, pseudo_opcode[i].name,\n-\t\t\t (void *) (pseudo_opcode + i));\n-      if (err)\n-\tas_fatal (_(\"ia64.md_begin: can't hash `%s': %s\"),\n-\t\t  pseudo_opcode[i].name, err);\n-    }\n+    str_hash_insert (md.pseudo_hash, pseudo_opcode[i].name,\n+\t\t     (void *) (pseudo_opcode + i));\n \n-  md.reg_hash = hash_new ();\n-  md.dynreg_hash = hash_new ();\n-  md.const_hash = hash_new ();\n-  md.entry_hash = hash_new ();\n+  md.reg_hash = str_htab_create ();\n+  md.dynreg_hash = str_htab_create ();\n+  md.const_hash = str_htab_create ();\n+  md.entry_hash = str_htab_create ();\n \n   /* general registers:  */\n   declare_register_set (\"r\", 128, REG_GR);\n@@ -7471,13 +7451,8 @@ md_begin (void)\n   declare_register (\"psp\", REG_PSP);\n \n   for (i = 0; i < NELEMS (const_bits); ++i)\n-    {\n-      err = hash_insert (md.const_hash, const_bits[i].name,\n-\t\t\t (void *) (const_bits + i));\n-      if (err)\n-\tas_fatal (_(\"Inserting \\\"%s\\\" into constant hash table failed: %s\"),\n-\t\t  name, err);\n-    }\n+    str_hash_insert (md.const_hash, const_bits[i].name,\n+\t\t     (void *) (const_bits + i));\n \n   /* Set the architecture and machine depending on defaults and command line\n      options.  */\n@@ -7980,15 +7955,15 @@ ia64_parse_name (char *name, expressionS *e, char *nextcharP)\n     }\n \n   /* first see if NAME is a known register name:  */\n-  sym = hash_find (md.reg_hash, name);\n+  sym = str_hash_find (md.reg_hash, name);\n   if (sym)\n     {\n       e->X_op = O_register;\n       e->X_add_number = S_GET_VALUE (sym);\n       return 1;\n     }\n \n-  cdesc = hash_find (md.const_hash, name);\n+  cdesc = str_hash_find (md.const_hash, name);\n   if (cdesc)\n     {\n       e->X_op = O_constant;\n@@ -8054,7 +8029,7 @@ ia64_parse_name (char *name, expressionS *e, char *nextcharP)\n \n   end = xstrdup (name);\n   name = ia64_canonicalize_symbol_name (end);\n-  if ((dr = hash_find (md.dynreg_hash, name)))\n+  if ((dr = str_hash_find (md.dynreg_hash, name)))\n     {\n       /* We've got ourselves the name of a rotating register set.\n \t Store the base register number in the low 16 bits of\n@@ -10675,7 +10650,7 @@ md_assemble (char *str)\n \n   ch = get_symbol_name (&temp);\n   mnemonic = temp;\n-  pdesc = (struct pseudo_opcode *) hash_find (md.pseudo_hash, mnemonic);\n+  pdesc = (struct pseudo_opcode *) str_hash_find (md.pseudo_hash, mnemonic);\n   if (pdesc)\n     {\n       (void) restore_line_pointer (ch);\n@@ -11750,10 +11725,9 @@ dot_alias (int section)\n   char delim;\n   char *end_name;\n   int len;\n-  const char *error_string;\n   struct alias *h;\n   const char *a;\n-  struct hash_control *ahash, *nhash;\n+  htab_t ahash, nhash;\n   const char *kind;\n \n   delim = get_symbol_name (&name);\n@@ -11810,54 +11784,46 @@ dot_alias (int section)\n     }\n \n   /* Check if alias has been used before.  */\n-  h = (struct alias *) hash_find (ahash, alias);\n+\n+  h = (struct alias *) str_hash_find (ahash, alias);\n   if (h)\n     {\n       if (strcmp (h->name, name))\n \tas_bad (_(\"`%s' is already the alias of %s `%s'\"),\n \t\talias, kind, h->name);\n+      obstack_free (&notes, name);\n+      obstack_free (&notes, alias);\n       goto out;\n     }\n \n   /* Check if name already has an alias.  */\n-  a = (const char *) hash_find (nhash, name);\n+  a = (const char *) str_hash_find (nhash, name);\n   if (a)\n     {\n       if (strcmp (a, alias))\n \tas_bad (_(\"%s `%s' already has an alias `%s'\"), kind, name, a);\n+      obstack_free (&notes, name);\n+      obstack_free (&notes, alias);\n       goto out;\n     }\n \n   h = XNEW (struct alias);\n   h->file = as_where (&h->line);\n   h->name = name;\n \n-  error_string = hash_jam (ahash, alias, (void *) h);\n-  if (error_string)\n-    {\n-      as_fatal (_(\"inserting \\\"%s\\\" into %s alias hash table failed: %s\"),\n-\t\talias, kind, error_string);\n-      goto out;\n-    }\n-\n-  error_string = hash_jam (nhash, name, (void *) alias);\n-  if (error_string)\n-    {\n-      as_fatal (_(\"inserting \\\"%s\\\" into %s name hash table failed: %s\"),\n-\t\talias, kind, error_string);\n-    out:\n-      obstack_free (&notes, name);\n-      obstack_free (&notes, alias);\n-    }\n+  str_hash_insert (ahash, alias, (void *) h);\n+  str_hash_insert (nhash, name, (void *) alias);\n \n+out:\n   demand_empty_rest_of_line ();\n }\n \n /* It renames the original symbol name to its alias.  */\n-static void\n-do_alias (const char *alias, void *value)\n+static int\n+do_alias (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n-  struct alias *h = (struct alias *) value;\n+  string_tuple_t *tuple = *((string_tuple_t **) slot);\n+  struct alias *h = (struct alias *) tuple->value;\n   symbolS *sym = symbol_find (h->name);\n \n   if (sym == NULL)\n@@ -11866,43 +11832,48 @@ do_alias (const char *alias, void *value)\n       /* Uses .alias extensively to alias CRTL functions to same with\n \t decc$ prefix. Sometimes function gets optimized away and a\n \t warning results, which should be suppressed.  */\n-      if (strncmp (alias, \"decc$\", 5) != 0)\n+      if (strncmp (tuple->key, \"decc$\", 5) != 0)\n #endif\n \tas_warn_where (h->file, h->line,\n \t\t       _(\"symbol `%s' aliased to `%s' is not used\"),\n-\t\t       h->name, alias);\n+\t\t       h->name, tuple->key);\n     }\n     else\n-      S_SET_NAME (sym, (char *) alias);\n+      S_SET_NAME (sym, (char *) tuple->key);\n+\n+  return 1;\n }\n \n /* Called from write_object_file.  */\n void\n ia64_adjust_symtab (void)\n {\n-  hash_traverse (alias_hash, do_alias);\n+  htab_traverse (alias_hash, do_alias, NULL);\n }\n \n /* It renames the original section name to its alias.  */\n-static void\n-do_secalias (const char *alias, void *value)\n+static int\n+do_secalias (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n-  struct alias *h = (struct alias *) value;\n+  string_tuple_t *tuple = *((string_tuple_t **) slot);\n+  struct alias *h = (struct alias *) tuple->value;\n   segT sec = bfd_get_section_by_name (stdoutput, h->name);\n \n   if (sec == NULL)\n     as_warn_where (h->file, h->line,\n \t\t   _(\"section `%s' aliased to `%s' is not used\"),\n-\t\t   h->name, alias);\n+\t\t   h->name, tuple->key);\n   else\n-    sec->name = alias;\n+    sec->name = tuple->key;\n+\n+  return 1;\n }\n \n /* Called from write_object_file.  */\n void\n ia64_frob_file (void)\n {\n-  hash_traverse (secalias_hash, do_secalias);\n+  htab_traverse (secalias_hash, do_secalias, NULL);\n }\n \n #ifdef TE_VMS"
    },
    {
      "sha": "0956e7a96a6d2ec14a99626bcf88ca8ca4b86e3b",
      "filename": "gas/config/tc-m68hc11.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m68hc11.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -263,7 +263,7 @@ static short flag_print_insn_syntax = 0;\n static short flag_print_opcodes = 0;\n \n /* Opcode hash table.  */\n-static struct hash_control *m68hc11_hash;\n+static htab_t m68hc11_hash;\n \n /* Current cpu (either cpu6811 or cpu6812).  This is determined automagically\n    by 'get_default_target' by looking at default BFD vector.  This is overridden\n@@ -472,7 +472,7 @@ m68hc11_print_statistics (FILE *file)\n   int i;\n   struct m68hc11_opcode_def *opc;\n \n-  hash_print_statistics (file, \"opcode table\", m68hc11_hash);\n+  htab_print_statistics (file, \"opcode table\", m68hc11_hash);\n \n   opc = m68hc11_opcode_defs;\n   if (opc == 0 || m68hc11_nb_opcode_defs == 0)\n@@ -610,7 +610,7 @@ md_begin (void)\n \n   get_default_target ();\n \n-  m68hc11_hash = hash_new ();\n+  m68hc11_hash = str_htab_create ();\n \n   /* Get a writable copy of the opcode table and sort it on the names.  */\n   opcodes = XNEWVEC (struct m68hc11_opcode, m68hc11_num_opcodes);\n@@ -664,7 +664,7 @@ md_begin (void)\n \t  opc->nb_modes = 0;\n \t  opc->opcode = opcodes;\n \t  opc->used = 0;\n-\t  hash_insert (m68hc11_hash, opcodes->name, opc);\n+\t  str_hash_insert (m68hc11_hash, opcodes->name, opc);\n \t}\n       opc->nb_modes++;\n       opc->format |= opcodes->format;\n@@ -1010,7 +1010,7 @@ print_insn_format (char *name)\n   struct m68hc11_opcode *opcode;\n   char buf[128];\n \n-  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);\n+  opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);\n   if (opc == NULL)\n     {\n       as_bad (_(\"Instruction `%s' is not recognized.\"), name);\n@@ -2848,7 +2848,7 @@ md_assemble (char *str)\n   if (current_architecture == cpuxgate)\n     {\n       /* Find the opcode definition given its name.  */\n-      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);\n+      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);\n       if (opc == NULL)\n         {\n           as_bad (_(\"Opcode `%s' is not recognized.\"), name);\n@@ -3469,15 +3469,15 @@ md_assemble (char *str)\n     }\n \n   /* Find the opcode definition given its name.  */\n-  opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, name);\n+  opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, name);\n \n   /* If it's not recognized, look for 'jbsr' and 'jbxx'.  These are\n      pseudo insns for relative branch.  For these branches, we always\n      optimize them (turned into absolute branches) even if --short-branches\n      is given.  */\n   if (opc == NULL && name[0] == 'j' && name[1] == 'b')\n     {\n-      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash, &name[1]);\n+      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash, &name[1]);\n       if (opc\n \t  && (!(opc->format & M6811_OP_JUMP_REL)\n \t      || (opc->format & M6811_OP_BITMASK)))\n@@ -3508,7 +3508,7 @@ md_assemble (char *str)\n \t    {\n \t      name[nlen++] = TOLOWER (*op_end++);\n \t      name[nlen] = 0;\n-\t      opc = (struct m68hc11_opcode_def *) hash_find (m68hc11_hash,\n+\t      opc = (struct m68hc11_opcode_def *) str_hash_find (m68hc11_hash,\n \t\t\t\t\t\t\t     name);\n \t    }\n \t}"
    },
    {
      "sha": "6542d273997fec609c891741cd62aae69253f882",
      "filename": "gas/config/tc-m68k.c",
      "status": "modified",
      "additions": 9,
      "deletions": 16,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-m68k.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -1320,7 +1320,7 @@ tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)\n \n /* Handle of the OPCODE hash table.  NULL means any use before\n    m68k_ip_begin() will crash.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \f\n /* Assemble an m68k instruction.  */\n \n@@ -1375,7 +1375,7 @@ m68k_ip (char *instring)\n \n   c = *p;\n   *p = '\\0';\n-  opcode = (const struct m68k_incant *) hash_find (op_hash, instring);\n+  opcode = (const struct m68k_incant *) str_hash_find (op_hash, instring);\n   *p = c;\n \n   if (pdot != NULL)\n@@ -4496,7 +4496,6 @@ md_begin (void)\n {\n   const struct m68k_opcode *ins;\n   struct m68k_incant *hack, *slak;\n-  const char *retval = 0;\t/* Empty string, or error msg text.  */\n   int i;\n \n   /* Set up hash tables with 68000 instructions.\n@@ -4527,7 +4526,7 @@ md_begin (void)\n   qsort (m68k_sorted_opcodes, m68k_numopcodes,\n \t sizeof (m68k_sorted_opcodes[0]), m68k_compare_opcode);\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   obstack_begin (&robyn, 4000);\n   for (i = 0; i < m68k_numopcodes; i++)\n@@ -4571,22 +4570,18 @@ md_begin (void)\n \t}\n       while (slak);\n \n-      retval = hash_insert (op_hash, ins->name, (char *) hack);\n-      if (retval)\n-\tas_fatal (_(\"Internal Error:  Can't hash %s: %s\"), ins->name, retval);\n+      str_hash_insert (op_hash, ins->name, (char *) hack);\n     }\n \n   for (i = 0; i < m68k_numaliases; i++)\n     {\n       const char *name = m68k_opcode_aliases[i].primary;\n       const char *alias = m68k_opcode_aliases[i].alias;\n-      void *val = hash_find (op_hash, name);\n+      void *val = (void *)str_hash_find (op_hash, name);\n \n       if (!val)\n \tas_fatal (_(\"Internal Error: Can't find %s in hash table\"), name);\n-      retval = hash_insert (op_hash, alias, val);\n-      if (retval)\n-\tas_fatal (_(\"Internal Error: Can't hash %s: %s\"), alias, retval);\n+      str_hash_insert (op_hash, alias, val);\n     }\n \n   /* In MRI mode, all unsized branches are variable sized.  Normally,\n@@ -4619,13 +4614,11 @@ md_begin (void)\n \t{\n \t  const char *name = mri_aliases[i].primary;\n \t  const char *alias = mri_aliases[i].alias;\n-\t  void *val = hash_find (op_hash, name);\n+\t  void *val = (void *)str_hash_find (op_hash, name);\n \n \t  if (!val)\n \t    as_fatal (_(\"Internal Error: Can't find %s in hash table\"), name);\n-\t  retval = hash_jam (op_hash, alias, val);\n-\t  if (retval)\n-\t    as_fatal (_(\"Internal Error: Can't hash %s: %s\"), alias, retval);\n+\t  str_hash_insert (op_hash, alias, val);\n \t}\n     }\n \n@@ -4680,7 +4673,7 @@ md_begin (void)\n     while (mote_pseudo_table[n].poc_name)\n       {\n \thack = XOBNEW (&robyn, struct m68k_incant);\n-\thash_insert (op_hash,\n+\tstr_hash_insert (op_hash,\n \t\t     mote_pseudo_table[n].poc_name, (char *) hack);\n \thack->m_operands = 0;\n \thack->m_opnum = n;"
    },
    {
      "sha": "a0927dbfc0bcd7411dedcc1f7c14b0d4ba470822",
      "filename": "gas/config/tc-mcore.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mcore.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -135,7 +135,7 @@ static unsigned long poolspan;\n #define SPANEXIT\t(600)\n static symbolS * poolsym;\t\t/* Label for current pool.  */\n static char poolname[8];\n-static struct hash_control * opcode_hash_control;\t/* Opcode mnemonics.  */\n+static htab_t  opcode_hash_control;\t/* Opcode mnemonics.  */\n \n #define POOL_END_LABEL   \".LE\"\n #define POOL_START_LABEL \".LS\"\n@@ -457,15 +457,15 @@ md_begin (void)\n   const char * prev_name = \"\";\n   unsigned int i;\n \n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert unique names into hash table.  */\n   for (i = 0; i < ARRAY_SIZE (mcore_table); i++)\n     {\n       if (! streq (prev_name, mcore_table[i].name))\n \t{\n \t  prev_name = mcore_table[i].name;\n-\t  hash_insert (opcode_hash_control, mcore_table[i].name, (char *) &mcore_table[i]);\n+\t  str_hash_insert (opcode_hash_control, mcore_table[i].name, (char *) &mcore_table[i]);\n \t}\n     }\n }\n@@ -881,7 +881,7 @@ md_assemble (char * str)\n       return;\n     }\n \n-  opcode = (mcore_opcode_info *) hash_find (opcode_hash_control, name);\n+  opcode = (mcore_opcode_info *) str_hash_find (opcode_hash_control, name);\n   if (opcode == NULL)\n     {\n       as_bad (_(\"unknown opcode \\\"%s\\\"\"), name);"
    },
    {
      "sha": "fe0c770ab2920489f373a2d9695252d44fac2d52",
      "filename": "gas/config/tc-microblaze.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-microblaze.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -114,7 +114,7 @@ const relax_typeS md_relax_table[] =\n   { 0x7fffffff, 0x80000000, INST_WORD_SIZE*2, 0 }   /* 18: TEXT_PC_OFFSET.  */\n };\n \n-static struct hash_control * opcode_hash_control;\t/* Opcode mnemonics.  */\n+static htab_t  opcode_hash_control;\t/* Opcode mnemonics.  */\n \n static segT sbss_segment = 0; \t/* Small bss section.  */\n static segT sbss2_segment = 0; \t/* Section not used.  */\n@@ -413,11 +413,11 @@ md_begin (void)\n {\n   struct op_code_struct * opcode;\n \n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert unique names into hash table.  */\n   for (opcode = opcodes; opcode->name; opcode ++)\n-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n }\n \n /* Try to parse a reg name.  */\n@@ -942,7 +942,7 @@ md_assemble (char * str)\n       return;\n     }\n \n-  opcode = (struct op_code_struct *) hash_find (opcode_hash_control, name);\n+  opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, name);\n   if (opcode == NULL)\n     {\n       as_bad (_(\"unknown opcode \\\"%s\\\"\"), name);\n@@ -1072,9 +1072,9 @@ md_assemble (char * str)\n \n           count = 32 - reg1;\n           if (streq (name, \"lmi\"))\n-            opcode = (struct op_code_struct *) hash_find (opcode_hash_control, \"lwi\");\n+            opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"lwi\");\n           else\n-            opcode = (struct op_code_struct *) hash_find (opcode_hash_control, \"swi\");\n+            opcode = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"swi\");\n           if (opcode == NULL)\n             {\n               as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"lwi\");\n@@ -1106,7 +1106,7 @@ md_assemble (char * str)\n           if ((temp != 0) && (temp != 0xFFFF8000))\n \t    {\n               /* Needs an immediate inst.  */\n-              opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+              opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n               if (opcode1 == NULL)\n                 {\n                   as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");\n@@ -1559,7 +1559,7 @@ md_assemble (char * str)\n       if ((temp != 0) && (temp != 0xFFFF8000))\n \t{\n           /* Needs an immediate inst.  */\n-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n           if (opcode1 == NULL)\n             {\n               as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");\n@@ -1625,7 +1625,7 @@ md_assemble (char * str)\n       if ((temp != 0) && (temp != 0xFFFF8000))\n \t{\n           /* Needs an immediate inst.  */\n-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n           if (opcode1 == NULL)\n             {\n               as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");\n@@ -1698,7 +1698,7 @@ md_assemble (char * str)\n       if ((temp != 0) && (temp != 0xFFFF8000))\n \t{\n           /* Needs an immediate inst.  */\n-          opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+          opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n           if (opcode1 == NULL)\n             {\n               as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");\n@@ -2119,7 +2119,7 @@ md_apply_fix (fixS *   fixP,\n \tbuf[i + INST_WORD_SIZE] = buf[i];\n \n       /* Generate the imm instruction.  */\n-      opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+      opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n       if (opcode1 == NULL)\n \t{\n \t  as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");\n@@ -2167,7 +2167,7 @@ md_apply_fix (fixS *   fixP,\n \tbuf[i + INST_WORD_SIZE] = buf[i];\n \n       /* Generate the imm instruction.  */\n-      opcode1 = (struct op_code_struct *) hash_find (opcode_hash_control, \"imm\");\n+      opcode1 = (struct op_code_struct *) str_hash_find (opcode_hash_control, \"imm\");\n       if (opcode1 == NULL)\n \t{\n \t  as_bad (_(\"unknown opcode \\\"%s\\\"\"), \"imm\");"
    },
    {
      "sha": "f521d48a43fadf032f38e4583759875b12988981",
      "filename": "gas/config/tc-mips.c",
      "status": "modified",
      "additions": 18,
      "deletions": 32,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mips.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -675,13 +675,13 @@ static int g_switch_seen = 0;\n static int nopic_need_relax (symbolS *, int);\n \n /* Handle of the OPCODE hash table.  */\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n /* The opcode hash table we use for the mips16.  */\n-static struct hash_control *mips16_op_hash = NULL;\n+static htab_t mips16_op_hash = NULL;\n \n /* The opcode hash table we use for the microMIPS ASE.  */\n-static struct hash_control *micromips_op_hash = NULL;\n+static htab_t micromips_op_hash = NULL;\n \n /* This array holds the chars that always start a comment.  If the\n     pre-processor is disabled, these aren't very useful.  */\n@@ -3668,7 +3668,6 @@ validate_micromips_insn (const struct mips_opcode *opc,\n void\n md_begin (void)\n {\n-  const char *retval = NULL;\n   int i = 0;\n   int broken = 0;\n \n@@ -3688,21 +3687,14 @@ md_begin (void)\n   if (! bfd_set_arch_mach (stdoutput, bfd_arch_mips, file_mips_opts.arch))\n     as_warn (_(\"could not set architecture and machine\"));\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   mips_operands = XCNEWVEC (struct mips_operand_array, NUMOPCODES);\n   for (i = 0; i < NUMOPCODES;)\n     {\n       const char *name = mips_opcodes[i].name;\n \n-      retval = hash_insert (op_hash, name, (void *) &mips_opcodes[i]);\n-      if (retval != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   mips_opcodes[i].name, retval);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"broken assembler, no assembly attempted\"));\n-\t}\n+      str_hash_insert (op_hash, name, (void *) &mips_opcodes[i]);\n       do\n \t{\n \t  if (!validate_mips_insn (&mips_opcodes[i], 0xffffffff,\n@@ -3725,7 +3717,7 @@ md_begin (void)\n       while ((i < NUMOPCODES) && !strcmp (mips_opcodes[i].name, name));\n     }\n \n-  mips16_op_hash = hash_new ();\n+  mips16_op_hash = str_htab_create ();\n   mips16_operands = XCNEWVEC (struct mips_operand_array,\n \t\t\t      bfd_mips16_num_opcodes);\n \n@@ -3734,10 +3726,7 @@ md_begin (void)\n     {\n       const char *name = mips16_opcodes[i].name;\n \n-      retval = hash_insert (mips16_op_hash, name, (void *) &mips16_opcodes[i]);\n-      if (retval != NULL)\n-\tas_fatal (_(\"internal: can't hash `%s': %s\"),\n-\t\t  mips16_opcodes[i].name, retval);\n+      str_hash_insert (mips16_op_hash, name, (void *) &mips16_opcodes[i]);\n       do\n \t{\n \t  if (!validate_mips16_insn (&mips16_opcodes[i], &mips16_operands[i]))\n@@ -3753,7 +3742,7 @@ md_begin (void)\n \t     && strcmp (mips16_opcodes[i].name, name) == 0);\n     }\n \n-  micromips_op_hash = hash_new ();\n+  micromips_op_hash = str_htab_create ();\n   micromips_operands = XCNEWVEC (struct mips_operand_array,\n \t\t\t\t bfd_micromips_num_opcodes);\n \n@@ -3762,11 +3751,8 @@ md_begin (void)\n     {\n       const char *name = micromips_opcodes[i].name;\n \n-      retval = hash_insert (micromips_op_hash, name,\n+      str_hash_insert (micromips_op_hash, name,\n \t\t\t    (void *) &micromips_opcodes[i]);\n-      if (retval != NULL)\n-\tas_fatal (_(\"internal: can't hash `%s': %s\"),\n-\t\t  micromips_opcodes[i].name, retval);\n       do\n \t{\n \t  struct mips_cl_insn *micromips_nop_insn;\n@@ -9022,7 +9008,7 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n   bfd_reloc_code_real_type r[3];\n   const struct mips_opcode *amo;\n   const struct mips_operand *operand;\n-  struct hash_control *hash;\n+  htab_t hash;\n   struct mips_cl_insn insn;\n   va_list args;\n   unsigned int uval;\n@@ -9040,7 +9026,7 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n   r[1] = BFD_RELOC_UNUSED;\n   r[2] = BFD_RELOC_UNUSED;\n   hash = mips_opts.micromips ? micromips_op_hash : op_hash;\n-  amo = (struct mips_opcode *) hash_find (hash, name);\n+  amo = (struct mips_opcode *) str_hash_find (hash, name);\n   gas_assert (amo);\n   gas_assert (strcmp (name, amo->name) == 0);\n \n@@ -9198,7 +9184,7 @@ mips16_macro_build (expressionS *ep, const char *name, const char *fmt,\n   bfd_reloc_code_real_type r[3]\n     = {BFD_RELOC_UNUSED, BFD_RELOC_UNUSED, BFD_RELOC_UNUSED};\n \n-  mo = (struct mips_opcode *) hash_find (mips16_op_hash, name);\n+  mo = (struct mips_opcode *) str_hash_find (mips16_op_hash, name);\n   gas_assert (mo);\n   gas_assert (strcmp (name, mo->name) == 0);\n \n@@ -14258,7 +14244,7 @@ mips16_macro (struct mips_cl_insn *ip)\n    opcode bits in *OPCODE_EXTRA.  */\n \n static struct mips_opcode *\n-mips_lookup_insn (struct hash_control *hash, const char *start,\n+mips_lookup_insn (htab_t hash, const char *start,\n \t\t  ssize_t length, unsigned int *opcode_extra)\n {\n   char *name, *dot, *p;\n@@ -14270,7 +14256,7 @@ mips_lookup_insn (struct hash_control *hash, const char *start,\n   name = xstrndup (start, length);\n \n   /* Look up the instruction as-is.  */\n-  insn = (struct mips_opcode *) hash_find (hash, name);\n+  insn = (struct mips_opcode *) str_hash_find (hash, name);\n   if (insn)\n     goto end;\n \n@@ -14282,7 +14268,7 @@ mips_lookup_insn (struct hash_control *hash, const char *start,\n       if (*p == 0 && mask != 0)\n \t{\n \t  *dot = 0;\n-\t  insn = (struct mips_opcode *) hash_find (hash, name);\n+\t  insn = (struct mips_opcode *) str_hash_find (hash, name);\n \t  *dot = '.';\n \t  if (insn && (insn->pinfo2 & INSN2_VU0_CHANNEL_SUFFIX) != 0)\n \t    {\n@@ -14308,7 +14294,7 @@ mips_lookup_insn (struct hash_control *hash, const char *start,\n       if (suffix)\n \t{\n \t  memmove (name + opend - 2, name + opend, length - opend + 1);\n-\t  insn = (struct mips_opcode *) hash_find (hash, name);\n+\t  insn = (struct mips_opcode *) str_hash_find (hash, name);\n \t  if (insn)\n \t    {\n \t      forced_insn_length = suffix;\n@@ -14333,7 +14319,7 @@ static void\n mips_ip (char *str, struct mips_cl_insn *insn)\n {\n   const struct mips_opcode *first, *past;\n-  struct hash_control *hash;\n+  htab_t hash;\n   char format;\n   size_t end;\n   struct mips_operand_token *tokens;\n@@ -14429,7 +14415,7 @@ mips16_ip (char *str, struct mips_cl_insn *insn)\n   forced_insn_length = l;\n \n   *end = 0;\n-  first = (struct mips_opcode *) hash_find (mips16_op_hash, str);\n+  first = (struct mips_opcode *) str_hash_find (mips16_op_hash, str);\n   *end = c;\n \n   if (!first)"
    },
    {
      "sha": "fb1f3d279200b4a3f54a609439f8154d3840884e",
      "filename": "gas/config/tc-mmix.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mmix.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -217,7 +217,7 @@ struct option md_longopts[] =\n \n size_t md_longopts_size = sizeof (md_longopts);\n \n-static struct hash_control *mmix_opcode_hash;\n+static htab_t mmix_opcode_hash;\n \n /* We use these when implementing the PREFIX pseudo.  */\n char *mmix_current_prefix;\n@@ -769,13 +769,13 @@ mmix_md_begin (void)\n      only way to make ':' part of a name, and a name beginner.  */\n   lex_type[':'] = (LEX_NAME | LEX_BEGIN_NAME);\n \n-  mmix_opcode_hash = hash_new ();\n+  mmix_opcode_hash = str_htab_create ();\n \n   real_reg_section\n     = bfd_make_section_old_way (stdoutput, MMIX_REG_SECTION_NAME);\n \n   for (opcode = mmix_opcodes; opcode->name; opcode++)\n-    hash_insert (mmix_opcode_hash, opcode->name, (char *) opcode);\n+    str_hash_insert (mmix_opcode_hash, opcode->name, (char *) opcode);\n \n   /* We always insert the ordinary registers 0..255 as registers.  */\n   for (i = 0; i < 256; i++)\n@@ -843,7 +843,7 @@ md_assemble (char *str)\n       *operands++ = '\\0';\n     }\n \n-  instruction = (struct mmix_opcode *) hash_find (mmix_opcode_hash, str);\n+  instruction = (struct mmix_opcode *) str_hash_find (mmix_opcode_hash, str);\n   if (instruction == NULL)\n     {\n       as_bad (_(\"unknown opcode: `%s'\"), str);"
    },
    {
      "sha": "6ce1c59e103a198e69d5f34560b813f47596761e",
      "filename": "gas/config/tc-mn10200.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mn10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mn10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10200.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -101,7 +101,7 @@ const pseudo_typeS md_pseudo_table[] =\n };\n \n /* Opcode hash table.  */\n-static struct hash_control *mn10200_hash;\n+static htab_t mn10200_hash;\n \n /* This table is sorted. Suitable for searching by a binary search.  */\n static const struct reg_name data_registers[] =\n@@ -685,7 +685,7 @@ md_begin (void)\n   const char *prev_name = \"\";\n   const struct mn10200_opcode *op;\n \n-  mn10200_hash = hash_new ();\n+  mn10200_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  The MN10200 instruction set\n      has many identical opcode names that have different opcodes based\n@@ -698,7 +698,7 @@ md_begin (void)\n       if (strcmp (prev_name, op->name))\n \t{\n \t  prev_name = (char *) op->name;\n-\t  hash_insert (mn10200_hash, op->name, (char *) op);\n+\t  str_hash_insert (mn10200_hash, op->name, (char *) op);\n \t}\n       op++;\n     }\n@@ -890,7 +890,7 @@ md_assemble (char *str)\n     *s++ = '\\0';\n \n   /* Find the first opcode with the proper name.  */\n-  opcode = (struct mn10200_opcode *) hash_find (mn10200_hash, str);\n+  opcode = (struct mn10200_opcode *) str_hash_find (mn10200_hash, str);\n   if (opcode == NULL)\n     {\n       as_bad (_(\"Unrecognized opcode: `%s'\"), str);"
    },
    {
      "sha": "bcd76cc5444d8ba3533fadc2660bedf9f523a3ca",
      "filename": "gas/config/tc-mn10300.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mn10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-mn10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-mn10300.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -121,7 +121,7 @@ size_t md_longopts_size = sizeof (md_longopts);\n #define HAVE_AM30   (current_machine == AM30)\n \n /* Opcode hash table.  */\n-static struct hash_control *mn10300_hash;\n+static htab_t mn10300_hash;\n \n /* This table is sorted. Suitable for searching by a binary search.  */\n static const struct reg_name data_registers[] =\n@@ -911,7 +911,7 @@ md_begin (void)\n   const char *prev_name = \"\";\n   const struct mn10300_opcode *op;\n \n-  mn10300_hash = hash_new ();\n+  mn10300_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  The MN10300 instruction set\n      has many identical opcode names that have different opcodes based\n@@ -924,7 +924,7 @@ md_begin (void)\n       if (strcmp (prev_name, op->name))\n \t{\n \t  prev_name = (char *) op->name;\n-\t  hash_insert (mn10300_hash, op->name, (char *) op);\n+\t  str_hash_insert (mn10300_hash, op->name, (char *) op);\n \t}\n       op++;\n     }\n@@ -1247,7 +1247,7 @@ md_assemble (char *str)\n     *s++ = '\\0';\n \n   /* Find the first opcode with the proper name.  */\n-  opcode = (struct mn10300_opcode *) hash_find (mn10300_hash, str);\n+  opcode = (struct mn10300_opcode *) str_hash_find (mn10300_hash, str);\n   if (opcode == NULL)\n     {\n       as_bad (_(\"Unrecognized opcode: `%s'\"), str);"
    },
    {
      "sha": "580b6a4a4ecf3f9dd4b2cb9d8ed31fcb78c687bd",
      "filename": "gas/config/tc-moxie.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-moxie.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-moxie.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-moxie.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -32,7 +32,7 @@ const char line_separator_chars[] = \";\";\n const char line_comment_chars[]   = \"#\";\n \n static int pending_reloc;\n-static struct hash_control *opcode_hash_control;\n+static htab_t opcode_hash_control;\n \n const pseudo_typeS md_pseudo_table[] =\n {\n@@ -62,17 +62,17 @@ md_begin (void)\n {\n   int count;\n   const moxie_opc_info_t *opcode;\n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert names into hash table.  */\n   for (count = 0, opcode = moxie_form1_opc_info; count++ < 64; opcode++)\n-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n \n   for (count = 0, opcode = moxie_form2_opc_info; count++ < 4; opcode++)\n-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n \n   for (count = 0, opcode = moxie_form3_opc_info; count++ < 10; opcode++)\n-    hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n \n   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);\n }\n@@ -178,7 +178,7 @@ md_assemble (char *str)\n \n   if (nlen == 0)\n     as_bad (_(\"can't find opcode \"));\n-  opcode = (moxie_opc_info_t *) hash_find (opcode_hash_control, op_start);\n+  opcode = (moxie_opc_info_t *) str_hash_find (opcode_hash_control, op_start);\n   *op_end = pend;\n \n   if (opcode == NULL)"
    },
    {
      "sha": "92ede74c08ce7e013128bb07cb4e0fe6a0c2798b",
      "filename": "gas/config/tc-msp430.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-msp430.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -194,7 +194,7 @@ const char FLT_CHARS[] = \"dD\";\n /* Handle  long expressions.  */\n extern LITTLENUM_TYPE generic_bignum[];\n \n-static struct hash_control *msp430_hash;\n+static htab_t msp430_hash;\n \n /* Relaxations.  */\n #define STATE_UNCOND_BRANCH\t1\t/* jump */\n@@ -1825,10 +1825,11 @@ void\n md_begin (void)\n {\n   struct msp430_opcode_s * opcode;\n-  msp430_hash = hash_new ();\n+  msp430_hash = str_htab_create ();\n \n   for (opcode = msp430_opcodes; opcode->name; opcode++)\n-    hash_insert (msp430_hash, opcode->name, (char *) opcode);\n+    if (str_hash_find (msp430_hash, opcode->name) == NULL)\n+      str_hash_insert (msp430_hash, opcode->name, (char *) opcode);\n \n   bfd_set_arch_mach (stdoutput, TARGET_ARCH,\n \t\t     target_is_430x () ? bfd_mach_msp430x : bfd_mach_msp11);\n@@ -2862,7 +2863,7 @@ msp430_operands (struct msp430_opcode_s * opcode, char * line)\n       char real_name[32];\n \n       sprintf (real_name, \"%sa\", old_name);\n-      opcode = hash_find (msp430_hash, real_name);\n+      opcode = str_hash_find (msp430_hash, real_name);\n       if (opcode == NULL)\n \t{\n \t  as_bad (_(\"instruction %s.a does not exist\"), old_name);\n@@ -4346,7 +4347,7 @@ md_assemble (char * str)\n       return;\n     }\n \n-  opcode = (struct msp430_opcode_s *) hash_find (msp430_hash, cmd);\n+  opcode = (struct msp430_opcode_s *) str_hash_find (msp430_hash, cmd);\n \n   if (opcode == NULL)\n     {"
    },
    {
      "sha": "cda673fcc8838d0fb078b0acea33ebd4c4d86fe5",
      "filename": "gas/config/tc-nds32.c",
      "status": "modified",
      "additions": 32,
      "deletions": 23,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nds32.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -82,8 +82,8 @@ static int vec_size = 0;\n    \".flag verbatim\" at beginning of the content.  We have\n    'nds32_flag' to parse it and set this field to be non-zero.  */\n static int verbatim = 0;\n-static struct hash_control *nds32_gprs_hash;\n-static struct hash_control *nds32_hint_hash;\n+static htab_t nds32_gprs_hash;\n+static htab_t nds32_hint_hash;\n #define TLS_REG \"$r27\"\n #define GOT_NAME \"_GLOBAL_OFFSET_TABLE_\"\n \n@@ -109,7 +109,7 @@ enum ict_option {\n static enum ict_option ict_flag = ICT_NONE;\n \f\n \n-static struct hash_control *nds32_relax_info_hash;\n+static htab_t nds32_relax_info_hash;\n \n /* Branch patterns.  */\n static relax_info_t relax_table[] =\n@@ -2569,12 +2569,12 @@ struct nds32_pseudo_opcode\n };\n #define PV_DONT_CARE 0\n \n-static struct hash_control *nds32_pseudo_opcode_hash = NULL;\n+static htab_t nds32_pseudo_opcode_hash = NULL;\n \n static int\n builtin_isreg (const char *s, const char *x ATTRIBUTE_UNUSED)\n {\n-  if (s [0] == '$' && hash_find (nds32_gprs_hash, (s + 1)))\n+  if (s [0] == '$' && str_hash_find (nds32_gprs_hash, (s + 1)))\n     return 1;\n   return 0;\n }\n@@ -2586,7 +2586,7 @@ builtin_regnum (const char *s, const char *x ATTRIBUTE_UNUSED)\n   if (*s != '$')\n     return -1;\n   s++;\n-  k = hash_find (nds32_gprs_hash, s);\n+  k = str_hash_find (nds32_gprs_hash, s);\n \n   if (k == NULL)\n     return -1;\n@@ -3434,18 +3434,18 @@ nds32_init_nds32_pseudo_opcodes (void)\n {\n   struct nds32_pseudo_opcode *opcode = nds32_pseudo_opcode_table;\n \n-  nds32_pseudo_opcode_hash = hash_new ();\n+  nds32_pseudo_opcode_hash = str_htab_create ();\n   for ( ; opcode->opcode; opcode++)\n     {\n       void *op;\n \n-      op = hash_find (nds32_pseudo_opcode_hash, opcode->opcode);\n+      op = str_hash_find (nds32_pseudo_opcode_hash, opcode->opcode);\n       if (op != NULL)\n \t{\n \t  as_warn (_(\"Duplicated pseudo-opcode %s.\"), opcode->opcode);\n \t  continue;\n \t}\n-      hash_insert (nds32_pseudo_opcode_hash, opcode->opcode, opcode);\n+      str_hash_insert (nds32_pseudo_opcode_hash, opcode->opcode, opcode);\n     }\n }\n \n@@ -3466,7 +3466,7 @@ nds32_lookup_pseudo_opcode (const char *str)\n     }\n   op[i] = '\\0';\n \n-  result = hash_find (nds32_pseudo_opcode_hash, op);\n+  result = str_hash_find (nds32_pseudo_opcode_hash, op);\n   free (op);\n   return result;\n }\n@@ -4291,12 +4291,12 @@ nds32_relax_hint (int mode ATTRIBUTE_UNUSED)\n \n   /* Find relax hint entry for next instruction, and all member will be\n      initialized at that time.  */\n-  relocs = hash_find (nds32_hint_hash, name);\n+  relocs = str_hash_find (nds32_hint_hash, name);\n   if (relocs == NULL)\n     {\n       relocs = XNEW (struct nds32_relocs_pattern);\n       memset (relocs, 0, sizeof (struct nds32_relocs_pattern));\n-      hash_insert (nds32_hint_hash, name, relocs);\n+      str_hash_insert (nds32_hint_hash, name, relocs);\n     }\n   else\n     {\n@@ -4623,17 +4623,17 @@ md_begin (void)\n   nds32_asm_init (&asm_desc, flags);\n \n   /* Initial general purpose registers hash table.  */\n-  nds32_gprs_hash = hash_new ();\n+  nds32_gprs_hash = str_htab_create ();\n   for (k = keyword_gpr; k->name; k++)\n-    hash_insert (nds32_gprs_hash, k->name, k);\n+    str_hash_insert (nds32_gprs_hash, k->name, k);\n \n   /* Initial branch hash table.  */\n-  nds32_relax_info_hash = hash_new ();\n+  nds32_relax_info_hash = str_htab_create ();\n   for (relax_info = relax_table; relax_info->opcode; relax_info++)\n-    hash_insert (nds32_relax_info_hash, relax_info->opcode, relax_info);\n+    str_hash_insert (nds32_relax_info_hash, relax_info->opcode, relax_info);\n \n   /* Initial relax hint hash table.  */\n-  nds32_hint_hash = hash_new ();\n+  nds32_hint_hash = str_htab_create ();\n   enable_16bit = nds32_16bit_ext;\n }\n \n@@ -5813,7 +5813,7 @@ nds32_find_reloc_table (struct nds32_relocs_pattern *relocs_pattern,\n   if (opc)\n     {\n       /* Branch relax pattern.  */\n-      relax_info = hash_find (nds32_relax_info_hash, opc);\n+      relax_info = str_hash_find (nds32_relax_info_hash, opc);\n       if (!relax_info)\n \treturn FALSE;\n       fixup_info = relax_info->relax_fixup[range];\n@@ -6272,6 +6272,15 @@ nds32_elf_append_relax_relocs (const char *key, void *value)\n   frchain_now = frchain_bak;\n }\n \n+static int\n+nds32_elf_append_relax_relocs_traverse (void **slot, void *arg ATTRIBUTE_UNUSED)\n+{\n+  string_tuple_t *tuple = *((string_tuple_t **) slot);\n+  nds32_elf_append_relax_relocs (tuple->key, tuple->value);\n+  return 1;\n+}\n+\n+\n static void\n nds32_str_tolower (const char *src, char *dest)\n {\n@@ -6757,7 +6766,7 @@ nds32_relax_branch_instructions (segT segment, fragS *fragP,\n \treturn 0;\n     }\n \n-  relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);\n+  relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);\n \n   if (relax_info == NULL)\n     return adjust;\n@@ -7046,7 +7055,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec, fragS *fragP)\n \n   if (fragP->tc_frag_data.flag & NDS32_FRAG_RELAXABLE_BRANCH)\n     {\n-      relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);\n+      relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);\n \n       if (relax_info == NULL)\n \treturn;\n@@ -7106,7 +7115,7 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec, fragS *fragP)\n   else if (fragP->tc_frag_data.flag & NDS32_FRAG_BRANCH)\n     {\n       /* Branch instruction adjust and append relocations.  */\n-      relax_info = hash_find (nds32_relax_info_hash, opcode->opcode);\n+      relax_info = str_hash_find (nds32_relax_info_hash, opcode->opcode);\n \n       if (relax_info == NULL)\n \treturn;\n@@ -7481,7 +7490,7 @@ nds32_insert_relax_entry (bfd *abfd ATTRIBUTE_UNUSED, asection *sec,\n static void\n nds32_elf_analysis_relax_hint (void)\n {\n-  hash_traverse (nds32_hint_hash, nds32_elf_append_relax_relocs);\n+  htab_traverse (nds32_hint_hash, nds32_elf_append_relax_relocs_traverse, NULL);\n }\n \n static void\n@@ -7966,7 +7975,7 @@ nds32_parse_name (char const *name, expressionS *exprP,\n int\n tc_nds32_regname_to_dw2regnum (char *regname)\n {\n-  struct nds32_keyword *sym = hash_find (nds32_gprs_hash, regname);\n+  struct nds32_keyword *sym = str_hash_find (nds32_gprs_hash, regname);\n \n   if (!sym)\n     return -1;"
    },
    {
      "sha": "eb7a1a585b4b65829b02ee34f53af461fc3258b5",
      "filename": "gas/config/tc-nios2.c",
      "status": "modified",
      "additions": 15,
      "deletions": 47,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-nios2.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -184,20 +184,20 @@ typedef struct nios2_ps_insn_info\n } nios2_ps_insn_infoS;\n \n /* Opcode hash table.  */\n-static struct hash_control *nios2_opcode_hash = NULL;\n+static htab_t nios2_opcode_hash = NULL;\n #define nios2_opcode_lookup(NAME) \\\n-  ((struct nios2_opcode *) hash_find (nios2_opcode_hash, (NAME)))\n+  ((struct nios2_opcode *) str_hash_find (nios2_opcode_hash, (NAME)))\n \n /* Register hash table.  */\n-static struct hash_control *nios2_reg_hash = NULL;\n+static htab_t nios2_reg_hash = NULL;\n #define nios2_reg_lookup(NAME) \\\n-  ((struct nios2_reg *) hash_find (nios2_reg_hash, (NAME)))\n+  ((struct nios2_reg *) str_hash_find (nios2_reg_hash, (NAME)))\n \n \n /* Pseudo-op hash table.  */\n-static struct hash_control *nios2_ps_hash = NULL;\n+static htab_t nios2_ps_hash = NULL;\n #define nios2_ps_lookup(NAME) \\\n-  ((nios2_ps_insn_infoS *) hash_find (nios2_ps_hash, (NAME)))\n+  ((nios2_ps_insn_infoS *) str_hash_find (nios2_ps_hash, (NAME)))\n \n /* The known current alignment of the current section.  */\n static int nios2_current_align;\n@@ -3603,7 +3603,6 @@ void\n md_begin (void)\n {\n   int i;\n-  const char *inserted;\n \n   switch (nios2_architecture)\n     {\n@@ -3620,52 +3619,21 @@ md_begin (void)\n \n   /* Create and fill a hashtable for the Nios II opcodes, registers and\n      arguments.  */\n-  nios2_opcode_hash = hash_new ();\n-  nios2_reg_hash = hash_new ();\n-  nios2_ps_hash = hash_new ();\n+  nios2_opcode_hash = str_htab_create ();\n+  nios2_reg_hash = str_htab_create ();\n+  nios2_ps_hash = str_htab_create ();\n \n   for (i = 0; i < nios2_num_opcodes; ++i)\n-    {\n-      inserted\n-\t= hash_insert (nios2_opcode_hash, nios2_opcodes[i].name,\n-\t\t       (PTR) & nios2_opcodes[i]);\n-      if (inserted != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   nios2_opcodes[i].name, inserted);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n-    }\n+    str_hash_insert (nios2_opcode_hash, nios2_opcodes[i].name,\n+\t\t     (PTR) & nios2_opcodes[i]);\n \n   for (i = 0; i < nios2_num_regs; ++i)\n-    {\n-      inserted\n-\t= hash_insert (nios2_reg_hash, nios2_regs[i].name,\n-\t\t       (PTR) & nios2_regs[i]);\n-      if (inserted != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   nios2_regs[i].name, inserted);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n-\n-    }\n+    str_hash_insert (nios2_reg_hash, nios2_regs[i].name,\n+\t\t     (PTR) & nios2_regs[i]);\n \n   for (i = 0; i < nios2_num_ps_insn_info_structs; ++i)\n-    {\n-      inserted\n-\t= hash_insert (nios2_ps_hash, nios2_ps_insn_info_structs[i].pseudo_insn,\n-\t\t       (PTR) & nios2_ps_insn_info_structs[i]);\n-      if (inserted != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   nios2_ps_insn_info_structs[i].pseudo_insn, inserted);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n-    }\n+    str_hash_insert (nios2_ps_hash, nios2_ps_insn_info_structs[i].pseudo_insn,\n+\t\t     (PTR) & nios2_ps_insn_info_structs[i]);\n \n   /* Assembler option defaults.  */\n   nios2_as_options.noat = FALSE;"
    },
    {
      "sha": "dfa8b426585e70e37c1986f7019153673c0b5f30",
      "filename": "gas/config/tc-ns32k.c",
      "status": "modified",
      "additions": 4,
      "deletions": 9,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ns32k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ns32k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ns32k.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -84,7 +84,7 @@ struct addr_mode\n typedef struct addr_mode addr_modeS;\n \n char *freeptr, *freeptr_static;\t/* Points at some number of free bytes.  */\n-struct hash_control *inst_hash_handle;\n+htab_t inst_hash_handle;\n \n struct ns32k_opcode *desc;\t/* Pointer at description of instruction.  */\n addr_modeS addr_modeP;\n@@ -1103,7 +1103,7 @@ parse (const char *line, int recursive_level)\n       c = *lineptr;\n       *(char *) lineptr = '\\0';\n \n-      if (!(desc = (struct ns32k_opcode *) hash_find (inst_hash_handle, line)))\n+      if (!(desc = (struct ns32k_opcode *) str_hash_find (inst_hash_handle, line)))\n \tas_fatal (_(\"No such opcode\"));\n \n       *(char *) lineptr = c;\n@@ -1895,18 +1895,13 @@ md_begin (void)\n {\n   /* Build a hashtable of the instructions.  */\n   const struct ns32k_opcode *ptr;\n-  const char *status;\n   const struct ns32k_opcode *endop;\n \n-  inst_hash_handle = hash_new ();\n+  inst_hash_handle = str_htab_create ();\n \n   endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);\n   for (ptr = ns32k_opcodes; ptr < endop; ptr++)\n-    {\n-      if ((status = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))\n-\t/* Fatal.  */\n-\tas_fatal (_(\"Can't hash %s: %s\"), ptr->name, status);\n-    }\n+    str_hash_insert (inst_hash_handle, ptr->name, (char *) ptr);\n \n   /* Some private space please!  */\n   freeptr_static = XNEWVEC (char, PRIVATE_SIZE);"
    },
    {
      "sha": "1818d2fe401aa859bfddb5a7e5c236868ec778c6",
      "filename": "gas/config/tc-pdp11.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pdp11.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -82,7 +82,7 @@ const pseudo_typeS md_pseudo_table[] =\n   { 0, 0, 0 },\n };\n \n-static struct hash_control *insn_hash = NULL;\n+static htab_t insn_hash = NULL;\n \f\n static int\n set_option (const char *arg)\n@@ -188,14 +188,14 @@ md_begin (void)\n \n   init_defaults ();\n \n-  insn_hash = hash_new ();\n+  insn_hash = str_htab_create ();\n   if (insn_hash == NULL)\n     as_fatal (_(\"Virtual memory exhausted\"));\n \n   for (i = 0; i < pdp11_num_opcodes; i++)\n-    hash_insert (insn_hash, pdp11_opcodes[i].name, (void *) (pdp11_opcodes + i));\n+    str_hash_insert (insn_hash, pdp11_opcodes[i].name, (void *) (pdp11_opcodes + i));\n   for (i = 0; i < pdp11_num_aliases; i++)\n-    hash_insert (insn_hash, pdp11_aliases[i].name, (void *) (pdp11_aliases + i));\n+    str_hash_insert (insn_hash, pdp11_aliases[i].name, (void *) (pdp11_aliases + i));\n }\n \n void\n@@ -713,7 +713,7 @@ md_assemble (char *instruction_string)\n \n   c = *p;\n   *p = '\\0';\n-  op = (struct pdp11_opcode *)hash_find (insn_hash, str);\n+  op = (struct pdp11_opcode *)str_hash_find (insn_hash, str);\n   *p = c;\n   if (op == 0)\n     {"
    },
    {
      "sha": "5c992484075c71e54b4eda7c48c0600729dd12c5",
      "filename": "gas/config/tc-pj.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pj.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -31,7 +31,7 @@ const char line_separator_chars[] = \";\";\n const char line_comment_chars[]   = \"/!#\";\n \n static int pending_reloc;\n-static struct hash_control *opcode_hash_control;\n+static htab_t opcode_hash_control;\n \n static void\n little (int ignore ATTRIBUTE_UNUSED)\n@@ -176,7 +176,7 @@ fake_opcode (const char *name,\n   fake->opcode = -1;\n   fake->opcode_next = -1;\n   fake->u.func = func;\n-  hash_insert (opcode_hash_control, name, (char *) fake);\n+  str_hash_insert (opcode_hash_control, name, (char *) fake);\n }\n \n /* Enter another entry into the opcode hash table so the same opcode\n@@ -185,8 +185,8 @@ fake_opcode (const char *name,\n static void\n alias (const char *new_name, const char *old)\n {\n-  hash_insert (opcode_hash_control, new_name,\n-\t       (char *) hash_find (opcode_hash_control, old));\n+  str_hash_insert (opcode_hash_control, new_name,\n+\t       (char *) str_hash_find (opcode_hash_control, old));\n }\n \n /* This function is called once, at assembler startup time.  It sets\n@@ -197,11 +197,11 @@ void\n md_begin (void)\n {\n   const pj_opc_info_t *opcode;\n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert names into hash table.  */\n   for (opcode = pj_opc_info; opcode->u.name; opcode++)\n-    hash_insert (opcode_hash_control, opcode->u.name, (char *) opcode);\n+    str_hash_insert (opcode_hash_control, opcode->u.name, (char *) opcode);\n \n   /* Insert the only fake opcode.  */\n   fake_opcode (\"ipush\", ipush_code);\n@@ -252,7 +252,7 @@ md_assemble (char *str)\n   if (nlen == 0)\n     as_bad (_(\"can't find opcode \"));\n \n-  opcode = (pj_opc_info_t *) hash_find (opcode_hash_control, op_start);\n+  opcode = (pj_opc_info_t *) str_hash_find (opcode_hash_control, op_start);\n   *op_end = pend;\n \n   if (opcode == NULL)"
    },
    {
      "sha": "9149e71e6195695536d9713f4305a83965534439",
      "filename": "gas/config/tc-ppc.c",
      "status": "modified",
      "additions": 16,
      "deletions": 65,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -966,10 +966,10 @@ ppc_optimize_expr (expressionS *left, operatorT op, expressionS *right)\n static unsigned int ppc_obj64 = BFD_DEFAULT_TARGET_SIZE == 64;\n \n /* Opcode hash table.  */\n-static struct hash_control *ppc_hash;\n+static htab_t ppc_hash;\n \n /* Macro hash table.  */\n-static struct hash_control *ppc_macro_hash;\n+static htab_t ppc_macro_hash;\n \n #ifdef OBJ_ELF\n /* What type of shared library support to use.  */\n@@ -1601,12 +1601,12 @@ ppc_setup_opcodes (void)\n   bfd_boolean bad_insn = FALSE;\n \n   if (ppc_hash != NULL)\n-    hash_die (ppc_hash);\n+    htab_delete (ppc_hash);\n   if (ppc_macro_hash != NULL)\n-    hash_die (ppc_macro_hash);\n+    htab_delete (ppc_macro_hash);\n \n   /* Insert the opcodes into a hash table.  */\n-  ppc_hash = hash_new ();\n+  ppc_hash = str_htab_create ();\n \n   if (ENABLE_CHECKING)\n     {\n@@ -1683,22 +1683,12 @@ ppc_setup_opcodes (void)\n \n       if ((ppc_cpu & op->flags) != 0\n \t  && !(ppc_cpu & op->deprecated))\n-\t{\n-\t  const char *retval;\n-\n-\t  retval = hash_insert (ppc_hash, op->name, (void *) op);\n-\t  if (retval != NULL)\n-\t    {\n-\t      as_bad (_(\"duplicate instruction %s\"),\n-\t\t      op->name);\n-\t      bad_insn = TRUE;\n-\t    }\n-\t}\n+\tstr_hash_insert (ppc_hash, op->name, (void *) op);\n     }\n \n   if ((ppc_cpu & PPC_OPCODE_ANY) != 0)\n     for (op = powerpc_opcodes; op < op_end; op++)\n-      hash_insert (ppc_hash, op->name, (void *) op);\n+      str_hash_insert (ppc_hash, op->name, (void *) op);\n \n   op_end = prefix_opcodes + prefix_num_opcodes;\n   for (op = prefix_opcodes; op < op_end; op++)\n@@ -1727,22 +1717,12 @@ ppc_setup_opcodes (void)\n \n       if ((ppc_cpu & op->flags) != 0\n \t  && !(ppc_cpu & op->deprecated))\n-\t{\n-\t  const char *retval;\n-\n-\t  retval = hash_insert (ppc_hash, op->name, (void *) op);\n-\t  if (retval != NULL)\n-\t    {\n-\t      as_bad (_(\"duplicate instruction %s\"),\n-\t\t      op->name);\n-\t      bad_insn = TRUE;\n-\t    }\n-\t}\n+\tstr_hash_insert (ppc_hash, op->name, (void *) op);\n     }\n \n   if ((ppc_cpu & PPC_OPCODE_ANY) != 0)\n     for (op = prefix_opcodes; op < op_end; op++)\n-      hash_insert (ppc_hash, op->name, (void *) op);\n+      str_hash_insert (ppc_hash, op->name, (void *) op);\n \n   op_end = vle_opcodes + vle_num_opcodes;\n   for (op = vle_opcodes; op < op_end; op++)\n@@ -1772,17 +1752,7 @@ ppc_setup_opcodes (void)\n \n       if ((ppc_cpu & op->flags) != 0\n \t  && !(ppc_cpu & op->deprecated))\n-\t{\n-\t  const char *retval;\n-\n-\t  retval = hash_insert (ppc_hash, op->name, (void *) op);\n-\t  if (retval != NULL)\n-\t    {\n-\t      as_bad (_(\"duplicate instruction %s\"),\n-\t\t      op->name);\n-\t      bad_insn = TRUE;\n-\t    }\n-\t}\n+\tstr_hash_insert (ppc_hash, op->name, (void *) op);\n     }\n \n   /* SPE2 instructions */\n@@ -1816,40 +1786,21 @@ ppc_setup_opcodes (void)\n \t    }\n \n \t  if ((ppc_cpu & op->flags) != 0 && !(ppc_cpu & op->deprecated))\n-\t    {\n-\t      const char *retval;\n-\n-\t      retval = hash_insert (ppc_hash, op->name, (void *) op);\n-\t      if (retval != NULL)\n-\t\t{\n-\t\t  as_bad (_(\"duplicate instruction %s\"),\n-\t\t\t  op->name);\n-\t\t  bad_insn = TRUE;\n-\t\t}\n-\t    }\n+\t    str_hash_insert (ppc_hash, op->name, (void *) op);\n \t}\n \n       for (op = spe2_opcodes; op < op_end; op++)\n-\thash_insert (ppc_hash, op->name, (void *) op);\n+\tstr_hash_insert (ppc_hash, op->name, (void *) op);\n     }\n \n   /* Insert the macros into a hash table.  */\n-  ppc_macro_hash = hash_new ();\n+  ppc_macro_hash = str_htab_create ();\n \n   macro_end = powerpc_macros + powerpc_num_macros;\n   for (macro = powerpc_macros; macro < macro_end; macro++)\n     {\n       if ((macro->flags & ppc_cpu) != 0 || (ppc_cpu & PPC_OPCODE_ANY) != 0)\n-\t{\n-\t  const char *retval;\n-\n-\t  retval = hash_insert (ppc_macro_hash, macro->name, (void *) macro);\n-\t  if (retval != (const char *) NULL)\n-\t    {\n-\t      as_bad (_(\"duplicate macro %s\"), macro->name);\n-\t      bad_insn = TRUE;\n-\t    }\n-\t}\n+\tstr_hash_insert (ppc_macro_hash, macro->name, (void *) macro);\n     }\n \n   if (bad_insn)\n@@ -3160,12 +3111,12 @@ md_assemble (char *str)\n     *s++ = '\\0';\n \n   /* Look up the opcode in the hash table.  */\n-  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, str);\n+  opcode = (const struct powerpc_opcode *) str_hash_find (ppc_hash, str);\n   if (opcode == (const struct powerpc_opcode *) NULL)\n     {\n       const struct powerpc_macro *macro;\n \n-      macro = (const struct powerpc_macro *) hash_find (ppc_macro_hash, str);\n+      macro = (const struct powerpc_macro *) str_hash_find (ppc_macro_hash, str);\n       if (macro == (const struct powerpc_macro *) NULL)\n \tas_bad (_(\"unrecognized opcode: `%s'\"), str);\n       else"
    },
    {
      "sha": "9ec01e6405a9ec41af363d93aa68c978d3fd9f60",
      "filename": "gas/config/tc-pru.c",
      "status": "modified",
      "additions": 12,
      "deletions": 34,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-pru.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -132,14 +132,14 @@ typedef struct pru_insn_info\n } pru_insn_infoS;\n \n /* Opcode hash table.  */\n-static struct hash_control *pru_opcode_hash = NULL;\n+static htab_t pru_opcode_hash = NULL;\n #define pru_opcode_lookup(NAME) \\\n-  ((struct pru_opcode *) hash_find (pru_opcode_hash, (NAME)))\n+  ((struct pru_opcode *) str_hash_find (pru_opcode_hash, (NAME)))\n \n /* Register hash table.  */\n-static struct hash_control *pru_reg_hash = NULL;\n+static htab_t pru_reg_hash = NULL;\n #define pru_reg_lookup(NAME) \\\n-  ((struct pru_reg *) hash_find (pru_reg_hash, (NAME)))\n+  ((struct pru_reg *) str_hash_find (pru_reg_hash, (NAME)))\n \n /* The known current alignment of the current section.  */\n static int pru_current_align;\n@@ -1557,41 +1557,19 @@ void\n md_begin (void)\n {\n   int i;\n-  const char *inserted;\n \n   /* Create and fill a hashtable for the PRU opcodes, registers and\n      arguments.  */\n-  pru_opcode_hash = hash_new ();\n-  pru_reg_hash = hash_new ();\n+  pru_opcode_hash = str_htab_create ();\n+  pru_reg_hash = str_htab_create ();\n \n   for (i = 0; i < NUMOPCODES; ++i)\n-    {\n-      inserted\n-\t= hash_insert (pru_opcode_hash, pru_opcodes[i].name,\n-\t\t       (PTR) & pru_opcodes[i]);\n-      if (inserted != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   pru_opcodes[i].name, inserted);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n-    }\n+    str_hash_insert (pru_opcode_hash, pru_opcodes[i].name,\n+\t\t     (PTR) & pru_opcodes[i]);\n \n   for (i = 0; i < pru_num_regs; ++i)\n-    {\n-      inserted\n-\t= hash_insert (pru_reg_hash, pru_regs[i].name,\n-\t\t       (PTR) & pru_regs[i]);\n-      if (inserted != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   pru_regs[i].name, inserted);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n-\n-    }\n+    str_hash_insert (pru_reg_hash, pru_regs[i].name,\n+\t\t     (PTR) & pru_regs[i]);\n \n   linkrelax = pru_opt.link_relax;\n   /* Initialize the alignment data.  */\n@@ -1811,8 +1789,8 @@ md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)\n void\n md_end (void)\n {\n-  hash_die (pru_opcode_hash);\n-  hash_die (pru_reg_hash);\n+  htab_delete (pru_opcode_hash);\n+  htab_delete (pru_reg_hash);\n }\n \n symbolS *"
    },
    {
      "sha": "c575c0753ffc42f22246f493a9fe7d1a40948d12",
      "filename": "gas/config/tc-riscv.c",
      "status": "modified",
      "additions": 27,
      "deletions": 66,
      "changes": 93,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -242,28 +242,18 @@ riscv_multi_subset_supports (enum riscv_insn_class insn_class)\n }\n \n /* Handle of the extension with version hash table.  */\n-static struct hash_control *ext_version_hash = NULL;\n+static htab_t ext_version_hash = NULL;\n \n-static struct hash_control *\n+static htab_t\n init_ext_version_hash (const struct riscv_ext_version *table)\n {\n   int i = 0;\n-  struct hash_control *hash = hash_new ();\n+  htab_t hash = str_htab_create ();\n \n   while (table[i].name)\n     {\n       const char *name = table[i].name;\n-      const char *hash_error =\n-       hash_insert (hash, name, (void *) &table[i]);\n-\n-      if (hash_error != NULL)\n-       {\n-         fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-                  table[i].name, hash_error);\n-         /* Probably a memory allocation problem?  Give up now.  */\n-         as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-         return NULL;\n-       }\n+      str_hash_insert (hash, name, (void *) &table[i]);\n \n       i++;\n       while (table[i].name\n@@ -287,7 +277,7 @@ riscv_get_default_ext_version (const char *name,\n   if (name == NULL || default_isa_spec == ISA_SPEC_CLASS_NONE)\n     return;\n \n-  ext = (struct riscv_ext_version *) hash_find (ext_version_hash, name);\n+  ext = (struct riscv_ext_version *) str_hash_find (ext_version_hash, name);\n   while (ext\n         && ext->name\n         && strcmp (ext->name, name) == 0)\n@@ -321,10 +311,10 @@ riscv_set_arch (const char *s)\n }\n \n /* Handle of the OPCODE hash table.  */\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n /* Handle of the type of .insn hash table.  */\n-static struct hash_control *insn_type_hash = NULL;\n+static htab_t insn_type_hash = NULL;\n \n /* This array holds the chars that always start a comment.  If the\n     pre-processor is disabled, these aren't very useful */\n@@ -559,23 +549,16 @@ static const struct opcode_name_t opcode_name_list[] =\n };\n \n /* Hash table for lookup opcode name.  */\n-static struct hash_control *opcode_names_hash = NULL;\n+static htab_t opcode_names_hash = NULL;\n \n /* Initialization for hash table of opcode name.  */\n static void\n init_opcode_names_hash (void)\n {\n-  const char *retval;\n   const struct opcode_name_t *opcode;\n \n   for (opcode = &opcode_name_list[0]; opcode->name != NULL; ++opcode)\n-    {\n-      retval = hash_insert (opcode_names_hash, opcode->name, (void *)opcode);\n-\n-      if (retval != NULL)\n-\tas_fatal (_(\"internal error: can't hash `%s': %s\"),\n-\t\t  opcode->name, retval);\n-    }\n+    str_hash_insert (opcode_names_hash, opcode->name, (void *)opcode);\n }\n \n /* Find `s` is a valid opcode name or not,\n@@ -598,7 +581,7 @@ opcode_name_lookup (char **s)\n   save_c = *e;\n   *e = '\\0';\n \n-  o = (struct opcode_name_t *) hash_find (opcode_names_hash, *s);\n+  o = (struct opcode_name_t *) str_hash_find (opcode_names_hash, *s);\n \n   /* Advance to next token if one was recognized.  */\n   if (o)\n@@ -619,8 +602,8 @@ enum reg_class\n   RCLASS_CSR\n };\n \n-static struct hash_control *reg_names_hash = NULL;\n-static struct hash_control *csr_extra_hash = NULL;\n+static htab_t reg_names_hash = NULL;\n+static htab_t csr_extra_hash = NULL;\n \n #define ENCODE_REG_HASH(cls, n) \\\n   ((void *)(uintptr_t)((n) * RCLASS_MAX + (cls) + 1))\n@@ -631,10 +614,7 @@ static void\n hash_reg_name (enum reg_class class, const char *name, unsigned n)\n {\n   void *hash = ENCODE_REG_HASH (class, n);\n-  const char *retval = hash_insert (reg_names_hash, name, hash);\n-\n-  if (retval != NULL)\n-    as_fatal (_(\"internal error: can't hash `%s': %s\"), name, retval);\n+  str_hash_insert (reg_names_hash, name, hash);\n }\n \n static void\n@@ -655,11 +635,10 @@ riscv_init_csr_hash (const char *name,\n                     enum riscv_priv_spec_class abort_version)\n {\n   struct riscv_csr_extra *entry, *pre_entry;\n-  const char *hash_error = NULL;\n   bfd_boolean need_enrty = TRUE;\n \n   pre_entry = NULL;\n-  entry = (struct riscv_csr_extra *) hash_find (csr_extra_hash, name);\n+  entry = (struct riscv_csr_extra *) str_hash_find (csr_extra_hash, name);\n   while (need_enrty && entry != NULL)\n     {\n       if (entry->csr_class == class\n@@ -686,16 +665,7 @@ riscv_init_csr_hash (const char *name,\n      Otherwise, attach the extra information to the entry which is already\n      in the hash table.  */\n   if (pre_entry == NULL)\n-    {\n-      hash_error = hash_insert (csr_extra_hash, name, (void *) entry);\n-      if (hash_error != NULL)\n-       {\n-         fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-                  name, hash_error);\n-         /* Probably a memory allocation problem?  Give up now.  */\n-         as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-       }\n-    }\n+    str_hash_insert (csr_extra_hash, name, (void *) entry);\n   else\n     pre_entry->next = entry;\n }\n@@ -772,7 +742,7 @@ static unsigned int\n reg_csr_lookup_internal (const char *s)\n {\n   struct riscv_csr_extra *r =\n-    (struct riscv_csr_extra *) hash_find (csr_extra_hash, s);\n+    (struct riscv_csr_extra *) str_hash_find (csr_extra_hash, s);\n \n   if (r == NULL)\n     return -1U;\n@@ -794,7 +764,7 @@ reg_lookup_internal (const char *s, enum reg_class class)\n   if (class == RCLASS_CSR)\n     return reg_csr_lookup_internal (s);\n \n-  r = hash_find (reg_names_hash, s);\n+  r = str_hash_find (reg_names_hash, s);\n   if (r == NULL || DECODE_REG_CLASS (r) != class)\n     return -1;\n \n@@ -1018,26 +988,17 @@ struct percent_op_match\n \n /* Common hash table initialization function for\n    instruction and .insn directive.  */\n-static struct hash_control *\n+static htab_t\n init_opcode_hash (const struct riscv_opcode *opcodes,\n \t\t  bfd_boolean insn_directive_p)\n {\n   int i = 0;\n   int length;\n-  struct hash_control *hash = hash_new ();\n+  htab_t hash = str_htab_create ();\n   while (opcodes[i].name)\n     {\n       const char *name = opcodes[i].name;\n-      const char *hash_error =\n-\thash_insert (hash, name, (void *) &opcodes[i]);\n-\n-      if (hash_error != NULL)\n-\t{\n-\t  fprintf (stderr, _(\"internal error: can't hash `%s': %s\\n\"),\n-\t\t   opcodes[i].name, hash_error);\n-\t  /* Probably a memory allocation problem?  Give up now.  */\n-\t  as_fatal (_(\"Broken assembler.  No assembly attempted.\"));\n-\t}\n+      str_hash_insert (hash, name, (void *) &opcodes[i]);\n \n       do\n \t{\n@@ -1074,7 +1035,7 @@ md_begin (void)\n   op_hash = init_opcode_hash (riscv_opcodes, FALSE);\n   insn_type_hash = init_opcode_hash (riscv_insn_types, TRUE);\n \n-  reg_names_hash = hash_new ();\n+  reg_names_hash = str_htab_create ();\n   hash_reg_names (RCLASS_GPR, riscv_gpr_names_numeric, NGPR);\n   hash_reg_names (RCLASS_GPR, riscv_gpr_names_abi, NGPR);\n   hash_reg_names (RCLASS_FPR, riscv_fpr_names_numeric, NFPR);\n@@ -1083,15 +1044,15 @@ md_begin (void)\n   hash_reg_name (RCLASS_GPR, \"fp\", 8);\n \n   /* Create and insert CSR hash tables.  */\n-  csr_extra_hash = hash_new ();\n+  csr_extra_hash = str_htab_create ();\n #define DECLARE_CSR(name, num, class, define_version, abort_version) \\\n   riscv_init_csr_hash (#name, num, class, define_version, abort_version);\n #define DECLARE_CSR_ALIAS(name, num, class, define_version, abort_version) \\\n   DECLARE_CSR(name, num, class, define_version, abort_version);\n #include \"opcode/riscv-opc.h\"\n #undef DECLARE_CSR\n \n-  opcode_names_hash = hash_new ();\n+  opcode_names_hash = str_htab_create ();\n   init_opcode_names_hash ();\n \n   /* Set the default alignment for the text section.  */\n@@ -1196,7 +1157,7 @@ macro_build (expressionS *ep, const char *name, const char *fmt, ...)\n   va_start (args, fmt);\n \n   r = BFD_RELOC_UNUSED;\n-  mo = (struct riscv_opcode *) hash_find (op_hash, name);\n+  mo = (struct riscv_opcode *) str_hash_find (op_hash, name);\n   gas_assert (mo);\n \n   /* Find a non-RVC variant of the instruction.  append_insn will compress\n@@ -1796,7 +1757,7 @@ riscv_is_priv_insn (insn_t insn)\n \n static const char *\n riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n-\t  bfd_reloc_code_real_type *imm_reloc, struct hash_control *hash)\n+\t  bfd_reloc_code_real_type *imm_reloc, htab_t hash)\n {\n   char *s;\n   const char *args;\n@@ -1812,7 +1773,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n   bfd_boolean insn_with_csr = FALSE;\n \n   /* Parse the name of the instruction.  Terminate the string if whitespace\n-     is found so that hash_find only sees the name part of the string.  */\n+     is found so that str_hash_find only sees the name part of the string.  */\n   for (s = str; *s != '\\0'; ++s)\n     if (ISSPACE (*s))\n       {\n@@ -1821,7 +1782,7 @@ riscv_ip (char *str, struct riscv_cl_insn *ip, expressionS *imm_expr,\n \tbreak;\n       }\n \n-  insn = (struct riscv_opcode *) hash_find (hash, str);\n+  insn = (struct riscv_opcode *) str_hash_find (hash, str);\n \n   argsStart = s;\n   for ( ; insn && insn->name && strcmp (insn->name, str) == 0; insn++)"
    },
    {
      "sha": "7e84212b226eb2756c025f813c0b470b09133a63",
      "filename": "gas/config/tc-s390.c",
      "status": "modified",
      "additions": 9,
      "deletions": 24,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-s390.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -197,10 +197,10 @@ register_name (expressionS *expressionP)\n /* Local variables.  */\n \n /* Opformat hash table.  */\n-static struct hash_control *s390_opformat_hash;\n+static htab_t s390_opformat_hash;\n \n /* Opcode hash table.  */\n-static struct hash_control *s390_opcode_hash = NULL;\n+static htab_t s390_opcode_hash = NULL;\n \n /* Flags to set in the elf header */\n static flagword s390_flags = 0;\n@@ -494,13 +494,12 @@ s390_setup_opcodes (void)\n   const struct s390_opcode *op;\n   const struct s390_opcode *op_end;\n   bfd_boolean dup_insn = FALSE;\n-  const char *retval;\n \n   if (s390_opcode_hash != NULL)\n-    hash_die (s390_opcode_hash);\n+    htab_delete (s390_opcode_hash);\n \n   /* Insert the opcodes into a hash table.  */\n-  s390_opcode_hash = hash_new ();\n+  s390_opcode_hash = str_htab_create ();\n \n   op_end = s390_opcodes + s390_num_opcodes;\n   for (op = s390_opcodes; op < op_end; op++)\n@@ -532,15 +531,7 @@ s390_setup_opcodes (void)\n \t  use_opcode = ((f & current_flags) == f);\n \t}\n       if (use_opcode)\n-\t{\n-\t  retval = hash_insert (s390_opcode_hash, op->name, (void *) op);\n-\t  if (retval != (const char *) NULL)\n-\t    {\n-\t      as_bad (_(\"Internal assembler error for instruction %s\"),\n-\t\t      op->name);\n-\t      dup_insn = TRUE;\n-\t    }\n-\t}\n+\tstr_hash_insert (s390_opcode_hash, op->name, (void *) op);\n \n       while (op < op_end - 1 && strcmp (op->name, op[1].name) == 0)\n \top++;\n@@ -559,7 +550,6 @@ md_begin (void)\n {\n   const struct s390_opcode *op;\n   const struct s390_opcode *op_end;\n-  const char *retval;\n \n   /* Give a warning if the combination -m64-bit and -Aesa is used.  */\n   if (s390_arch_size == 64 && current_cpu < S390_OPCODE_Z900)\n@@ -572,16 +562,11 @@ md_begin (void)\n     bfd_set_private_flags (stdoutput, s390_flags);\n \n   /* Insert the opcode formats into a hash table.  */\n-  s390_opformat_hash = hash_new ();\n+  s390_opformat_hash = str_htab_create ();\n \n   op_end = s390_opformats + s390_num_opformats;\n   for (op = s390_opformats; op < op_end; op++)\n-    {\n-      retval = hash_insert (s390_opformat_hash, op->name, (void *) op);\n-      if (retval != (const char *) NULL)\n-\tas_bad (_(\"Internal assembler error for instruction format %s\"),\n-\t\top->name);\n-    }\n+    str_hash_insert (s390_opformat_hash, op->name, (void *) op);\n \n   s390_setup_opcodes ();\n \n@@ -1693,7 +1678,7 @@ md_assemble (char *str)\n     *s++ = '\\0';\n \n   /* Look up the opcode in the hash table.  */\n-  opcode = (struct s390_opcode *) hash_find (s390_opcode_hash, str);\n+  opcode = (struct s390_opcode *) str_hash_find (s390_opcode_hash, str);\n   if (opcode == (const struct s390_opcode *) NULL)\n     {\n       as_bad (_(\"Unrecognized opcode: `%s'\"), str);\n@@ -1761,7 +1746,7 @@ s390_insn (int ignore ATTRIBUTE_UNUSED)\n \n   /* Look up the opcode in the hash table.  */\n   opformat = (struct s390_opcode *)\n-    hash_find (s390_opformat_hash, input_line_pointer);\n+    str_hash_find (s390_opformat_hash, input_line_pointer);\n   if (opformat == (const struct s390_opcode *) NULL)\n     {\n       as_bad (_(\"Unrecognized opcode format: `%s'\"), input_line_pointer);"
    },
    {
      "sha": "380d636361465d3e91e5bbeb55d74815650e1003",
      "filename": "gas/config/tc-score.c",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -459,7 +459,7 @@ struct s3_reg_map\n {\n   const struct s3_reg_entry *names;\n   int max_regno;\n-  struct hash_control *htab;\n+  htab_t htab;\n   const char *expected;\n };\n \n@@ -470,8 +470,8 @@ static struct s3_reg_map s3_all_reg_maps[] =\n   {s3_score_crn_table, 31, NULL, N_(\"S+core co-processor register expected\")},\n };\n \n-static struct hash_control *s3_score_ops_hsh = NULL;\n-static struct hash_control *s3_dependency_insn_hsh = NULL;\n+static htab_t s3_score_ops_hsh = NULL;\n+static htab_t s3_dependency_insn_hsh = NULL;\n \n \n struct s3_datafield_range\n@@ -1027,7 +1027,7 @@ s3_end_of_line (char *str)\n }\n \n static int\n-s3_score_reg_parse (char **ccp, struct hash_control *htab)\n+s3_score_reg_parse (char **ccp, htab_t htab)\n {\n   char *start = *ccp;\n   char c;\n@@ -1044,7 +1044,7 @@ s3_score_reg_parse (char **ccp, struct hash_control *htab)\n     c = *p++;\n \n   *--p = 0;\n-  reg = (struct s3_reg_entry *) hash_find (htab, start);\n+  reg = (struct s3_reg_entry *) str_hash_find (htab, start);\n   *p = c;\n \n   if (reg)\n@@ -2203,7 +2203,7 @@ s3_dependency_type_from_insn (char *insn_name)\n   const struct s3_insn_to_dependency *tmp;\n \n   strcpy (name, insn_name);\n-  tmp = (const struct s3_insn_to_dependency *) hash_find (s3_dependency_insn_hsh, name);\n+  tmp = (const struct s3_insn_to_dependency *) str_hash_find (s3_dependency_insn_hsh, name);\n \n   if (tmp)\n     return tmp->type;\n@@ -2662,7 +2662,7 @@ s3_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n   c = *p;\n   *p = '\\0';\n \n-  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);\n+  opcode = (const struct s3_asm_opcode *) str_hash_find (s3_score_ops_hsh, operator);\n   *p = c;\n \n   memset (&s3_inst, '\\0', sizeof (s3_inst));\n@@ -2708,7 +2708,7 @@ s3_parse_48_inst (char *insnstr, bfd_boolean gen_frag_p)\n   c = *p;\n   *p = '\\0';\n \n-  opcode = (const struct s3_asm_opcode *) hash_find (s3_score_ops_hsh, operator);\n+  opcode = (const struct s3_asm_opcode *) str_hash_find (s3_score_ops_hsh, operator);\n   *p = c;\n \n   memset (&s3_inst, '\\0', sizeof (s3_inst));\n@@ -6251,7 +6251,7 @@ s3_s_score_lcomm (int bytes_p)\n }\n \n static void\n-s3_insert_reg (const struct s3_reg_entry *r, struct hash_control *htab)\n+s3_insert_reg (const struct s3_reg_entry *r, htab_t htab)\n {\n   int i = 0;\n   int len = strlen (r->name) + 2;\n@@ -6265,16 +6265,16 @@ s3_insert_reg (const struct s3_reg_entry *r, struct hash_control *htab)\n     }\n   buf2[i] = '\\0';\n \n-  hash_insert (htab, buf, (void *) r);\n-  hash_insert (htab, buf2, (void *) r);\n+  str_hash_insert (htab, buf, (void *) r);\n+  str_hash_insert (htab, buf2, (void *) r);\n }\n \n static void\n s3_build_reg_hsh (struct s3_reg_map *map)\n {\n   const struct s3_reg_entry *r;\n \n-  if ((map->htab = hash_new ()) == NULL)\n+  if ((map->htab = str_htab_create ()) == NULL)\n     {\n       as_fatal (_(\"virtual memory exhausted\"));\n     }\n@@ -6309,7 +6309,7 @@ s3_build_score_ops_hsh (void)\n       new_opcode->relax_value = insn->relax_value;\n       new_opcode->type = insn->type;\n       new_opcode->bitmask = insn->bitmask;\n-      hash_insert (s3_score_ops_hsh, new_opcode->template_name,\n+      str_hash_insert (s3_score_ops_hsh, new_opcode->template_name,\n                    (void *) new_opcode);\n     }\n }\n@@ -6336,7 +6336,7 @@ s3_build_dependency_insn_hsh (void)\n       strcpy (buf, tmp->insn_name);\n       new_i2n->insn_name = buf;\n       new_i2n->type = tmp->type;\n-      hash_insert (s3_dependency_insn_hsh, new_i2n->insn_name,\n+      str_hash_insert (s3_dependency_insn_hsh, new_i2n->insn_name,\n                    (void *) new_i2n);\n     }\n }\n@@ -6505,12 +6505,12 @@ s3_begin (void)\n   segT seg;\n   subsegT subseg;\n \n-  if ((s3_score_ops_hsh = hash_new ()) == NULL)\n+  if ((s3_score_ops_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   s3_build_score_ops_hsh ();\n \n-  if ((s3_dependency_insn_hsh = hash_new ()) == NULL)\n+  if ((s3_dependency_insn_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   s3_build_dependency_insn_hsh ();"
    },
    {
      "sha": "2c77d30b7c8327bcfbba878c749bf100e2eeeaec",
      "filename": "gas/config/tc-score7.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-score7.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-score7.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-score7.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -520,7 +520,7 @@ struct s7_reg_map\n {\n   const struct s7_reg_entry *names;\n   int max_regno;\n-  struct hash_control *htab;\n+  htab_t htab;\n   const char *expected;\n };\n \n@@ -531,8 +531,8 @@ static struct s7_reg_map s7_all_reg_maps[] =\n   {s7_score_crn_table, 31, NULL, N_(\"S+core co-processor register expected\")},\n };\n \n-static struct hash_control *s7_score_ops_hsh = NULL;\n-static struct hash_control *s7_dependency_insn_hsh = NULL;\n+static htab_t s7_score_ops_hsh = NULL;\n+static htab_t s7_dependency_insn_hsh = NULL;\n \n \f\n struct s7_datafield_range\n@@ -1112,7 +1112,7 @@ s7_end_of_line (char *str)\n }\n \n static int\n-s7_score_reg_parse (char **ccp, struct hash_control *htab)\n+s7_score_reg_parse (char **ccp, htab_t htab)\n {\n   char *start = *ccp;\n   char c;\n@@ -1129,7 +1129,7 @@ s7_score_reg_parse (char **ccp, struct hash_control *htab)\n     c = *p++;\n \n   *--p = 0;\n-  reg = (struct s7_reg_entry *) hash_find (htab, start);\n+  reg = (struct s7_reg_entry *) str_hash_find (htab, start);\n   *p = c;\n \n   if (reg)\n@@ -2321,7 +2321,7 @@ s7_dependency_type_from_insn (char *insn_name)\n   const struct s7_insn_to_dependency *tmp;\n \n   strcpy (name, insn_name);\n-  tmp = (const struct s7_insn_to_dependency *) hash_find (s7_dependency_insn_hsh, name);\n+  tmp = (const struct s7_insn_to_dependency *) str_hash_find (s7_dependency_insn_hsh, name);\n \n   if (tmp)\n     return tmp->type;\n@@ -2789,7 +2789,7 @@ s7_parse_16_32_inst (char *insnstr, bfd_boolean gen_frag_p)\n   c = *p;\n   *p = '\\0';\n \n-  opcode = (const struct s7_asm_opcode *) hash_find (s7_score_ops_hsh, operator);\n+  opcode = (const struct s7_asm_opcode *) str_hash_find (s7_score_ops_hsh, operator);\n   *p = c;\n \n   memset (&s7_inst, '\\0', sizeof (s7_inst));\n@@ -5103,7 +5103,7 @@ s7_build_score_ops_hsh (void)\n       new_opcode->relax_value = insn->relax_value;\n       new_opcode->type = insn->type;\n       new_opcode->bitmask = insn->bitmask;\n-      hash_insert (s7_score_ops_hsh, new_opcode->template_name,\n+      str_hash_insert (s7_score_ops_hsh, new_opcode->template_name,\n                    (void *) new_opcode);\n     }\n }\n@@ -5130,7 +5130,7 @@ s7_build_dependency_insn_hsh (void)\n       strcpy (insn_name, tmp->insn_name);\n       new_i2d->insn_name = insn_name;\n       new_i2d->type = tmp->type;\n-      hash_insert (s7_dependency_insn_hsh, new_i2d->insn_name,\n+      str_hash_insert (s7_dependency_insn_hsh, new_i2d->insn_name,\n                    (void *) new_i2d);\n     }\n }\n@@ -5345,7 +5345,7 @@ s7_parse_pce_inst (char *insnstr)\n \f\n \n static void\n-s7_insert_reg (const struct s7_reg_entry *r, struct hash_control *htab)\n+s7_insert_reg (const struct s7_reg_entry *r, htab_t htab)\n {\n   int i = 0;\n   int len = strlen (r->name) + 2;\n@@ -5359,16 +5359,16 @@ s7_insert_reg (const struct s7_reg_entry *r, struct hash_control *htab)\n     }\n   buf2[i] = '\\0';\n \n-  hash_insert (htab, buf, (void *) r);\n-  hash_insert (htab, buf2, (void *) r);\n+  str_hash_insert (htab, buf, (void *) r);\n+  str_hash_insert (htab, buf2, (void *) r);\n }\n \n static void\n s7_build_reg_hsh (struct s7_reg_map *map)\n {\n   const struct s7_reg_entry *r;\n \n-  if ((map->htab = hash_new ()) == NULL)\n+  if ((map->htab = str_htab_create ()) == NULL)\n     {\n       as_fatal (_(\"virtual memory exhausted\"));\n     }\n@@ -6115,12 +6115,12 @@ s7_begin (void)\n   segT seg;\n   subsegT subseg;\n \n-  if ((s7_score_ops_hsh = hash_new ()) == NULL)\n+  if ((s7_score_ops_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   s7_build_score_ops_hsh ();\n \n-  if ((s7_dependency_insn_hsh = hash_new ()) == NULL)\n+  if ((s7_dependency_insn_hsh = str_htab_create ()) == NULL)\n     as_fatal (_(\"virtual memory exhausted\"));\n \n   s7_build_dependency_insn_hsh ();"
    },
    {
      "sha": "e9274101aae9a479d3ebefa9910928bac6e7feea",
      "filename": "gas/config/tc-sh.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sh.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -240,7 +240,7 @@ const relax_typeS md_relax_table[C (END, 0)] = {\n \n #undef EMPTY\n \n-static struct hash_control *opcode_hash_control;\t/* Opcode mnemonics */\n+static htab_t opcode_hash_control;\t/* Opcode mnemonics */\n \n \f\n #ifdef OBJ_ELF\n@@ -564,7 +564,7 @@ md_begin (void)\n     = preset_target_arch ? preset_target_arch : arch_sh_up & ~arch_sh_has_dsp;\n   valid_arch = target_arch;\n \n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   /* Insert unique names into hash table.  */\n   for (opcode = sh_table; opcode->name; opcode++)\n@@ -574,7 +574,7 @@ md_begin (void)\n \t  if (!SH_MERGE_ARCH_SET_VALID (opcode->arch, target_arch))\n \t    continue;\n \t  prev_name = opcode->name;\n-\t  hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+\t  str_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n \t}\n     }\n }\n@@ -2196,7 +2196,7 @@ find_cooked_opcode (char **str_p)\n   if (nlen == 0)\n     as_bad (_(\"can't find opcode \"));\n \n-  return (sh_opcode_info *) hash_find (opcode_hash_control, name);\n+  return (sh_opcode_info *) str_hash_find (opcode_hash_control, name);\n }\n \n /* Assemble a parallel processing insn.  */"
    },
    {
      "sha": "58254c33163d8798ac3c4f83b01f3b9b31ed9412",
      "filename": "gas/config/tc-sparc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 22,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-sparc.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -126,7 +126,7 @@ int sparc_cie_data_alignment;\n #endif\n \n /* Handle of the OPCODE hash table.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \n static void s_data1 (void);\n static void s_seg (int);\n@@ -941,7 +941,6 @@ cmp_perc_entry (const void *parg, const void *qarg)\n void\n md_begin (void)\n {\n-  const char *retval = NULL;\n   int lose = 0;\n   unsigned int i = 0;\n \n@@ -952,18 +951,12 @@ md_begin (void)\n     init_default_arch ();\n \n   sparc_cie_data_alignment = sparc_arch_size == 64 ? -8 : -4;\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   while (i < (unsigned int) sparc_num_opcodes)\n     {\n       const char *name = sparc_opcodes[i].name;\n-      retval = hash_insert (op_hash, name, (void *) &sparc_opcodes[i]);\n-      if (retval != NULL)\n-\t{\n-\t  as_bad (_(\"Internal error: can't hash `%s': %s\\n\"),\n-\t\t  sparc_opcodes[i].name, retval);\n-\t  lose = 1;\n-\t}\n+      str_hash_insert (op_hash, name, (void *) &sparc_opcodes[i]);\n       do\n \t{\n \t  if (sparc_opcodes[i].match & sparc_opcodes[i].lose)\n@@ -984,24 +977,16 @@ md_begin (void)\n       const char *name = ((sparc_arch_size == 32)\n \t\t    ? native_op_table[i].name32\n \t\t    : native_op_table[i].name64);\n-      insn = (struct sparc_opcode *) hash_find (op_hash, name);\n+      insn = (struct sparc_opcode *) str_hash_find (op_hash, name);\n       if (insn == NULL)\n \t{\n \t  as_bad (_(\"Internal error: can't find opcode `%s' for `%s'\\n\"),\n \t\t  name, native_op_table[i].name);\n \t  lose = 1;\n \t}\n       else\n-\t{\n-\t  retval = hash_insert (op_hash, native_op_table[i].name,\n-\t\t\t\t(void *) insn);\n-\t  if (retval != NULL)\n-\t    {\n-\t      as_bad (_(\"Internal error: can't hash `%s': %s\\n\"),\n-\t\t      sparc_opcodes[i].name, retval);\n-\t      lose = 1;\n-\t    }\n-\t}\n+\tstr_hash_insert (op_hash, native_op_table[i].name,\n+\t\t\t (void *) insn);\n     }\n \n   if (lose)\n@@ -1759,7 +1744,7 @@ sparc_ip (char *str, const struct sparc_opcode **pinsn)\n       *pinsn = NULL;\n       return special_case;\n     }\n-  insn = (struct sparc_opcode *) hash_find (op_hash, str);\n+  insn = (struct sparc_opcode *) str_hash_find (op_hash, str);\n   *pinsn = insn;\n   if (insn == NULL)\n     {"
    },
    {
      "sha": "d50bd33bc2ccc384c82446e242b97dc079d9e544",
      "filename": "gas/config/tc-spu.c",
      "status": "modified",
      "additions": 7,
      "deletions": 14,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-spu.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -57,7 +57,7 @@ static void spu_brinfo (int);\n static void spu_cons (int);\n \n extern char *myname;\n-static struct hash_control *op_hash = NULL;\n+static htab_t op_hash = NULL;\n \n /* These bits should be turned off in the first address of every segment */\n int md_seg_align = 7;\n@@ -110,26 +110,19 @@ unsigned int brinfo;\n void\n md_begin (void)\n {\n-  const char *retval = NULL;\n   int i;\n \n   /* initialize hash table */\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   /* loop until you see the end of the list */\n \n   for (i = 0; i < spu_num_opcodes; i++)\n-    {\n-      /* hash each mnemonic and record its position */\n-\n-      retval = hash_insert (op_hash, spu_opcodes[i].mnemonic,\n-\t\t\t    (void *) &spu_opcodes[i]);\n-\n-      if (retval != NULL && strcmp (retval, \"exists\") != 0)\n-\tas_fatal (_(\"Can't hash instruction '%s':%s\"),\n-\t\t  spu_opcodes[i].mnemonic, retval);\n-    }\n+    /* hash each mnemonic and record its position */\n+    if (str_hash_find (op_hash, spu_opcodes[i].mnemonic) == NULL)\n+      str_hash_insert (op_hash, spu_opcodes[i].mnemonic,\n+\t\t       (void *) &spu_opcodes[i]);\n }\n \f\n const char *md_shortopts = \"\";\n@@ -285,7 +278,7 @@ md_assemble (char *op)\n \n   /* try to find the instruction in the hash table */\n \n-  if ((format = (struct spu_opcode *) hash_find (op_hash, op)) == NULL)\n+  if ((format = (struct spu_opcode *) str_hash_find (op_hash, op)) == NULL)\n     {\n       as_bad (_(\"Invalid mnemonic '%s'\"), op);\n       return;"
    },
    {
      "sha": "1d8c3709b3f8949981ee6e7b2bd63259408172d6",
      "filename": "gas/config/tc-tic30.c",
      "status": "modified",
      "additions": 22,
      "deletions": 44,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic30.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -99,78 +99,56 @@ debug (const char *string, ...)\n }\n \n /* Hash table for opcode lookup.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n /* Hash table for parallel opcode lookup.  */\n-static struct hash_control *parop_hash;\n+static htab_t parop_hash;\n /* Hash table for register lookup.  */\n-static struct hash_control *reg_hash;\n+static htab_t reg_hash;\n /* Hash table for indirect addressing lookup.  */\n-static struct hash_control *ind_hash;\n+static htab_t ind_hash;\n \n void\n md_begin (void)\n {\n-  const char *hash_err;\n-\n   debug (\"In md_begin()\\n\");\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n   {\n     const insn_template *current_optab = tic30_optab;\n \n     for (; current_optab < tic30_optab_end; current_optab++)\n-      {\n-\thash_err = hash_insert (op_hash, current_optab->name,\n-\t\t\t\t(char *) current_optab);\n-\tif (hash_err)\n-\t  as_fatal (\"Internal Error: Can't Hash %s: %s\",\n-\t\t    current_optab->name, hash_err);\n-      }\n+      str_hash_insert (op_hash, current_optab->name,\n+\t\t       (char *) current_optab);\n   }\n \n-  parop_hash = hash_new ();\n+  parop_hash = str_htab_create ();\n \n   {\n     const partemplate *current_parop = tic30_paroptab;\n \n     for (; current_parop < tic30_paroptab_end; current_parop++)\n-      {\n-\thash_err = hash_insert (parop_hash, current_parop->name,\n-\t\t\t\t(char *) current_parop);\n-\tif (hash_err)\n-\t  as_fatal (\"Internal Error: Can't Hash %s: %s\",\n-\t\t    current_parop->name, hash_err);\n-      }\n+      str_hash_insert (parop_hash, current_parop->name,\n+\t\t       (char *) current_parop);\n   }\n \n-  reg_hash = hash_new ();\n+  reg_hash = str_htab_create ();\n \n   {\n     const reg *current_reg = tic30_regtab;\n \n     for (; current_reg < tic30_regtab_end; current_reg++)\n-      {\n-\thash_err = hash_insert (reg_hash, current_reg->name,\n-\t\t\t\t(char *) current_reg);\n-\tif (hash_err)\n-\t  as_fatal (\"Internal Error: Can't Hash %s: %s\",\n-\t\t    current_reg->name, hash_err);\n-      }\n+      str_hash_insert (reg_hash, current_reg->name,\n+\t\t       (char *) current_reg);\n   }\n \n-  ind_hash = hash_new ();\n+  ind_hash = str_htab_create ();\n \n   {\n     const ind_addr_type *current_ind = tic30_indaddr_tab;\n \n     for (; current_ind < tic30_indaddrtab_end; current_ind++)\n-      {\n-\thash_err = hash_insert (ind_hash, current_ind->syntax,\n-\t\t\t\t(char *) current_ind);\n-\tif (hash_err)\n-\t  as_fatal (\"Internal Error: Can't Hash %s: %s\",\n-\t\t    current_ind->syntax, hash_err);\n-      }\n+      str_hash_insert (ind_hash, current_ind->syntax,\n+\t\t       (char *) current_ind);\n   }\n \n   /* Fill in lexical tables:  opcode_chars, operand_chars, space_chars.  */\n@@ -476,7 +454,7 @@ tic30_operand (char *token)\n \t      && (*(token + count) == 'r' || *(token + count) == 'R'))\n \t    {\n \t      /* AR reference is found, so get its number and remove\n-\t\t it from the buffer so it can pass through hash_find().  */\n+\t\t it from the buffer so it can pass through str_hash_find().  */\n \t      if (found_ar)\n \t\t{\n \t\t  as_bad (_(\"More than one AR register found in indirect reference\"));\n@@ -538,7 +516,7 @@ tic30_operand (char *token)\n \t  return NULL;\n \t}\n \n-      ind_addr_op = (ind_addr_type *) hash_find (ind_hash, ind_buffer);\n+      ind_addr_op = (ind_addr_type *) str_hash_find (ind_hash, ind_buffer);\n       if (ind_addr_op)\n \t{\n \t  debug (\"Found indirect reference: %s\\n\", ind_addr_op->syntax);\n@@ -577,7 +555,7 @@ tic30_operand (char *token)\n     }\n   else\n     {\n-      reg *regop = (reg *) hash_find (reg_hash, token);\n+      reg *regop = (reg *) str_hash_find (reg_hash, token);\n \n       if (regop)\n \t{\n@@ -674,7 +652,7 @@ tic30_parallel_insn (char *token)\n     /* Find instruction.  */\n     save_char = *current_posn;\n     *current_posn = '\\0';\n-    p_opcode = (partemplate *) hash_find (parop_hash, token);\n+    p_opcode = (partemplate *) str_hash_find (parop_hash, token);\n     if (p_opcode)\n       {\n \tdebug (\"Found instruction %s\\n\", p_opcode->name);\n@@ -719,7 +697,7 @@ tic30_parallel_insn (char *token)\n \tdebug (\"first_opcode = %s\\n\", first_opcode);\n \tdebug (\"second_opcode = %s\\n\", second_opcode);\n \tsprintf (token, \"q_%s_%s\", second_opcode, first_opcode);\n-\tp_opcode = (partemplate *) hash_find (parop_hash, token);\n+\tp_opcode = (partemplate *) str_hash_find (parop_hash, token);\n \n \tif (p_opcode)\n \t  {\n@@ -1466,7 +1444,7 @@ md_assemble (char *line)\n     /* Find instruction.  */\n     save_char = *current_posn;\n     *current_posn = '\\0';\n-    op = (insn_template *) hash_find (op_hash, token_start);\n+    op = (insn_template *) str_hash_find (op_hash, token_start);\n     if (op)\n       {\n \tdebug (\"Found instruction %s\\n\", op->name);"
    },
    {
      "sha": "5a2673dbf6825d2a6c7d247e1e6a752c650a250c",
      "filename": "gas/config/tc-tic4x.c",
      "status": "modified",
      "additions": 22,
      "deletions": 37,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic4x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic4x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic4x.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -53,10 +53,10 @@\n #define TIC4X_ALT_SYNTAX\n \n /* Handle of the inst mnemonic hash table.  */\n-static struct hash_control *tic4x_op_hash = NULL;\n+static htab_t tic4x_op_hash = NULL;\n \n /* Handle asg pseudo.  */\n-static struct hash_control *tic4x_asg_hash = NULL;\n+static htab_t tic4x_asg_hash = NULL;\n \n static unsigned int tic4x_cpu = 0;        /* Default to TMS320C40.  */\n static unsigned int tic4x_revision = 0;   /* CPU revision */\n@@ -727,10 +727,7 @@ tic4x_asg (int x ATTRIBUTE_UNUSED)\n   c = get_symbol_name (&name);\t/* Get terminator.  */\n   str = xstrdup (str);\n   name = xstrdup (name);\n-  if (hash_find (tic4x_asg_hash, name))\n-    hash_replace (tic4x_asg_hash, name, (void *) str);\n-  else\n-    hash_insert (tic4x_asg_hash, name, (void *) str);\n+  str_hash_insert (tic4x_asg_hash, name, str);\n   (void) restore_line_pointer (c);\n   demand_empty_rest_of_line ();\n }\n@@ -1209,23 +1206,17 @@ tic4x_init_symbols (void)\n }\n \n /* Insert a new instruction template into hash table.  */\n-static int\n+static void\n tic4x_inst_insert (const tic4x_inst_t *inst)\n {\n   static char prev_name[16];\n-  const char *retval = NULL;\n \n   /* Only insert the first name if have several similar entries.  */\n   if (!strcmp (inst->name, prev_name) || inst->name[0] == '\\0')\n-    return 1;\n+    return;\n \n-  retval = hash_insert (tic4x_op_hash, inst->name, (void *) inst);\n-  if (retval != NULL)\n-    fprintf (stderr, \"internal error: can't hash `%s': %s\\n\",\n-\t     inst->name, retval);\n-  else\n-    strcpy (prev_name, inst->name);\n-  return retval == NULL;\n+  str_hash_insert (tic4x_op_hash, inst->name, (void *) inst);\n+  strcpy (prev_name, inst->name);\n }\n \n /* Make a new instruction template.  */\n@@ -1258,21 +1249,20 @@ tic4x_inst_make (const char *name, unsigned long opcode, const char *args)\n }\n \n /* Add instruction template, creating dynamic templates as required.  */\n-static int\n+static void\n tic4x_inst_add (const tic4x_inst_t *insts)\n {\n   const char *s = insts->name;\n   char *d;\n   unsigned int i;\n-  int ok = 1;\n   char name[16];\n \n   d = name;\n \n   /* We do not care about INSNs that is not a part of our\n      oplevel setting.  */\n   if ((insts->oplevel & tic4x_oplevel) == 0)\n-    return ok;\n+    return;\n \n   while (1)\n     {\n@@ -1296,8 +1286,8 @@ tic4x_inst_add (const tic4x_inst_t *insts)\n \t      *e = '\\0';\n \n \t      /* If instruction found then have already processed it.  */\n-\t      if (hash_find (tic4x_op_hash, name))\n-\t\treturn 1;\n+\t      if (str_hash_find (tic4x_op_hash, name))\n+\t\treturn;\n \n \t      do\n \t\t{\n@@ -1306,18 +1296,17 @@ tic4x_inst_add (const tic4x_inst_t *insts)\n \t\t\t\t\t (*s == 'B' ? 16 : 23)),\n \t\t\t\t\tinsts[k].args);\n \t\t  if (k == 0)\t/* Save strcmp() with following func.  */\n-\t\t    ok &= tic4x_inst_insert (inst);\n+\t\t    tic4x_inst_insert (inst);\n \t\t  k++;\n \t\t}\n \t      while (!strcmp (insts->name,\n \t\t\t      insts[k].name));\n \t    }\n-\t  return ok;\n-\t  break;\n+\t  return;\n \n \tcase '\\0':\n-\t  return tic4x_inst_insert (insts);\n-\t  break;\n+\t  tic4x_inst_insert (insts);\n+\t  return;\n \n \tdefault:\n \t  *d++ = *s++;\n@@ -1332,7 +1321,6 @@ tic4x_inst_add (const tic4x_inst_t *insts)\n void\n md_begin (void)\n {\n-  int ok = 1;\n   unsigned int i;\n \n   /* Setup the proper opcode level according to the\n@@ -1364,21 +1352,18 @@ md_begin (void)\n     tic4x_oplevel |= OP_IDLE2;\n \n   /* Create hash table for mnemonics.  */\n-  tic4x_op_hash = hash_new ();\n+  tic4x_op_hash = str_htab_create ();\n \n   /* Create hash table for asg pseudo.  */\n-  tic4x_asg_hash = hash_new ();\n+  tic4x_asg_hash = str_htab_create ();\n \n   /* Add mnemonics to hash table, expanding conditional mnemonics on fly.  */\n   for (i = 0; i < tic4x_num_insts; i++)\n-    ok &= tic4x_inst_add (tic4x_insts + i);\n+    tic4x_inst_add (tic4x_insts + i);\n \n   /* Create dummy inst to avoid errors accessing end of table.  */\n   tic4x_inst_make (\"\", 0, \"\");\n \n-  if (!ok)\n-    as_fatal (\"Broken assembler.  No assembly attempted.\");\n-\n   /* Add registers to symbol table.  */\n   tic4x_init_regtable ();\n \n@@ -1509,7 +1494,7 @@ tic4x_operand_parse (char *s, tic4x_operand_t *operand)\n \n   c = get_symbol_name (&str);\t/* Get terminator.  */\n   new_pointer = input_line_pointer;\n-  if (strlen (str) && (entry = hash_find (tic4x_asg_hash, str)) != NULL)\n+  if (strlen (str) && (entry = str_hash_find (tic4x_asg_hash, str)) != NULL)\n     {\n       (void) restore_line_pointer (c);\n       input_line_pointer = (char *) entry;\n@@ -2444,7 +2429,7 @@ md_assemble (char *str)\n       /* Skip past instruction mnemonic.  */\n       while (*s && *s != ' ')\n \ts++;\n-      if (*s)\t\t\t/* Null terminate for hash_find.  */\n+      if (*s)\t\t\t/* Null terminate for str_hash_find.  */\n \t*s++ = '\\0';\t\t/* and skip past null.  */\n       len = strlen (insn->name);\n       snprintf (insn->name + len, TIC4X_NAME_MAX - len, \"_%s\", str);\n@@ -2465,7 +2450,7 @@ md_assemble (char *str)\n   if (insn->in_use)\n     {\n       if ((insn->inst = (struct tic4x_inst *)\n-\t   hash_find (tic4x_op_hash, insn->name)) == NULL)\n+\t   str_hash_find (tic4x_op_hash, insn->name)) == NULL)\n \t{\n \t  as_bad (_(\"Unknown opcode `%s'.\"), insn->name);\n \t  insn->parallel = 0;\n@@ -2508,7 +2493,7 @@ md_assemble (char *str)\n       s = str;\n       while (*s && *s != ' ')\t/* Skip past instruction mnemonic.  */\n \ts++;\n-      if (*s)\t\t\t/* Null terminate for hash_find.  */\n+      if (*s)\t\t\t/* Null terminate for str_hash_find.  */\n \t*s++ = '\\0';\t\t/* and skip past null.  */\n       strncpy (insn->name, str, TIC4X_NAME_MAX - 1);\n       insn->name[TIC4X_NAME_MAX - 1] = '\\0';"
    },
    {
      "sha": "93586b376a2c2084f94d28b4b75b7a24a88f11e2",
      "filename": "gas/config/tc-tic54x.c",
      "status": "modified",
      "additions": 94,
      "deletions": 107,
      "changes": 201,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic54x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic54x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic54x.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -181,12 +181,12 @@ static symbolS *last_label_seen = NULL;\n /* This ensures that all new labels are unique.  */\n static int local_label_id;\n \n-static struct hash_control *subsym_recurse_hash; /* Prevent infinite recurse.  */\n-static struct hash_control *math_hash; /* Built-in math functions.  */\n+static htab_t subsym_recurse_hash; /* Prevent infinite recurse.  */\n+static htab_t math_hash; /* Built-in math functions.  */\n /* Allow maximum levels of macro nesting; level 0 is the main substitution\n    symbol table.  The other assembler only does 32 levels, so there!  */\n #define MAX_SUBSYM_HASH 100\n-static struct hash_control *subsym_hash[MAX_SUBSYM_HASH];\n+static htab_t subsym_hash[MAX_SUBSYM_HASH];\n \n /* Keep track of local labels so we can substitute them before GAS sees them\n    since macros use their own 'namespace' for local labels, use a separate hash\n@@ -197,18 +197,18 @@ static struct hash_control *subsym_hash[MAX_SUBSYM_HASH];\n    We use our own macro nesting counter, since GAS overloads it when expanding\n    other things (like conditionals and repeat loops).  */\n static int macro_level = 0;\n-static struct hash_control *local_label_hash[100];\n+static htab_t local_label_hash[100];\n /* Keep track of struct/union tags.  */\n-static struct hash_control *stag_hash;\n-static struct hash_control *op_hash;\n-static struct hash_control *parop_hash;\n-static struct hash_control *reg_hash;\n-static struct hash_control *mmreg_hash;\n-static struct hash_control *cc_hash;\n-static struct hash_control *cc2_hash;\n-static struct hash_control *cc3_hash;\n-static struct hash_control *sbit_hash;\n-static struct hash_control *misc_symbol_hash;\n+static htab_t stag_hash;\n+static htab_t op_hash;\n+static htab_t parop_hash;\n+static htab_t reg_hash;\n+static htab_t mmreg_hash;\n+static htab_t cc_hash;\n+static htab_t cc2_hash;\n+static htab_t cc3_hash;\n+static htab_t sbit_hash;\n+static htab_t misc_symbol_hash;\n \n /* Only word (et al.), align, or conditionals are allowed within\n    .struct/.union.  */\n@@ -569,7 +569,7 @@ stag_add_field_symbols (struct stag *stag,\n \n \t  replacement = concat (S_GET_NAME (rootsym), \"+\", root_stag_name,\n \t\t\t\tname + strlen (S_GET_NAME (rootsym)), NULL);\n-\t  hash_insert (subsym_hash[0], name, replacement);\n+\t  str_hash_insert (subsym_hash[0], name, replacement);\n \t}\n \n       /* Recurse if the field is a structure.\n@@ -740,7 +740,7 @@ tic54x_endstruct (int is_union)\n   /* Nested .structs don't get put in the stag table.  */\n   if (current_stag->outer == NULL)\n     {\n-      hash_insert (stag_hash, current_stag->name, current_stag);\n+      str_hash_insert (stag_hash, current_stag->name, current_stag);\n       stag_add_field_symbols (current_stag, path,\n \t\t\t      S_GET_VALUE (current_stag->sym),\n \t\t\t      NULL, NULL);\n@@ -770,7 +770,7 @@ tic54x_tag (int ignore ATTRIBUTE_UNUSED)\n {\n   char *name;\n   int c = get_symbol_name (&name);\n-  struct stag *stag = (struct stag *) hash_find (stag_hash, name);\n+  struct stag *stag = (struct stag *) str_hash_find (stag_hash, name);\n \n   if (!stag)\n     {\n@@ -1117,19 +1117,22 @@ tic54x_global (int type)\n \n /* Remove the symbol from the local label hash lookup.  */\n \n-static void\n-tic54x_remove_local_label (const char *key, void *value ATTRIBUTE_UNUSED)\n+static int\n+tic54x_remove_local_label (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n-  void *elem = hash_delete (local_label_hash[macro_level], key, FALSE);\n+  string_tuple_t *tuple = *((string_tuple_t **) slot);\n+  void *elem = str_hash_find (local_label_hash[macro_level], tuple->key);\n+  str_hash_delete (local_label_hash[macro_level], tuple->key);\n   free (elem);\n+  return 0;\n }\n \n /* Reset all local labels.  */\n \n static void\n tic54x_clear_local_labels (int ignored ATTRIBUTE_UNUSED)\n {\n-  hash_traverse (local_label_hash[macro_level], tic54x_remove_local_label);\n+  htab_traverse (local_label_hash[macro_level], tic54x_remove_local_label, NULL);\n }\n \n /* .text\n@@ -2235,7 +2238,7 @@ tic54x_var (int ignore ATTRIBUTE_UNUSED)\n       c = get_symbol_name (&name);\n       /* .var symbols start out with a null string.  */\n       name = xstrdup (name);\n-      hash_insert (subsym_hash[macro_level], name, empty);\n+      str_hash_insert (subsym_hash[macro_level], name, empty);\n       c = restore_line_pointer (c);\n       if (c == ',')\n \t{\n@@ -2503,8 +2506,8 @@ tic54x_macro_start (void)\n       as_fatal (_(\"Macro nesting is too deep\"));\n       return;\n     }\n-  subsym_hash[macro_level] = hash_new ();\n-  local_label_hash[macro_level] = hash_new ();\n+  subsym_hash[macro_level] = str_htab_create ();\n+  local_label_hash[macro_level] = str_htab_create ();\n }\n \n void\n@@ -2520,7 +2523,7 @@ tic54x_macro_info (const macro_entry *macro)\n \n       name[entry->name.len] = '\\0';\n       value[entry->actual.len] = '\\0';\n-      hash_insert (subsym_hash[macro_level], name, value);\n+      str_hash_insert (subsym_hash[macro_level], name, value);\n     }\n }\n \n@@ -2529,9 +2532,9 @@ tic54x_macro_info (const macro_entry *macro)\n void\n tic54x_macro_end (void)\n {\n-  hash_die (subsym_hash[macro_level]);\n+  htab_delete (subsym_hash[macro_level]);\n   subsym_hash[macro_level] = NULL;\n-  hash_die (local_label_hash[macro_level]);\n+  htab_delete (local_label_hash[macro_level]);\n   local_label_hash[macro_level] = NULL;\n   --macro_level;\n }\n@@ -2685,9 +2688,9 @@ subsym_isname (char *a, char *ignore ATTRIBUTE_UNUSED)\n static int\n subsym_isreg (char *a, char *ignore ATTRIBUTE_UNUSED)\n {\n-  if (hash_find (reg_hash, a))\n+  if (str_hash_find (reg_hash, a))\n     return 1;\n-  if (hash_find (mmreg_hash, a))\n+  if (str_hash_find (mmreg_hash, a))\n     return 1;\n   return 0;\n }\n@@ -2697,7 +2700,7 @@ subsym_isreg (char *a, char *ignore ATTRIBUTE_UNUSED)\n static int\n subsym_structsz (char *name, char *ignore ATTRIBUTE_UNUSED)\n {\n-  struct stag *stag = (struct stag *) hash_find (stag_hash, name);\n+  struct stag *stag = (struct stag *) str_hash_find (stag_hash, name);\n \n   if (stag)\n     return stag->size;\n@@ -2965,7 +2968,6 @@ md_begin (void)\n   tic54x_symbol *sym;\n   const subsym_proc_entry *subsym_proc;\n   const math_proc_entry *math_proc;\n-  const char *hash_err;\n   char **symname;\n   char *TIC54X_DIR = getenv (\"TIC54X_DIR\");\n   char *A_DIR = TIC54X_DIR ? TIC54X_DIR : getenv (\"A_DIR\");\n@@ -2989,82 +2991,76 @@ md_begin (void)\n       while (tmp != NULL);\n     }\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n   for (tm = (insn_template *) tic54x_optab; tm->name; tm++)\n     {\n-      if (hash_find (op_hash, tm->name))\n+      if (str_hash_find (op_hash, tm->name))\n \tcontinue;\n-      hash_err = hash_insert (op_hash, tm->name, (char *) tm);\n-      if (hash_err)\n-\tas_fatal (\"Internal Error: Can't hash %s: %s\",\n-\t\t  tm->name, hash_err);\n+      str_hash_insert (op_hash, tm->name, (char *) tm);\n     }\n-  parop_hash = hash_new ();\n+  parop_hash = str_htab_create ();\n   for (tm = (insn_template *) tic54x_paroptab; tm->name; tm++)\n     {\n-      if (hash_find (parop_hash, tm->name))\n+      if (str_hash_find (parop_hash, tm->name))\n \tcontinue;\n-      hash_err = hash_insert (parop_hash, tm->name, (char *) tm);\n-      if (hash_err)\n-\tas_fatal (\"Internal Error: Can't hash %s: %s\",\n-\t\t  tm->name, hash_err);\n+      str_hash_insert (parop_hash, tm->name, (char *) tm);\n     }\n-  reg_hash = hash_new ();\n+  reg_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) regs; sym->name; sym++)\n     {\n       /* Add basic registers to the symbol table.  */\n       symbolS *symbolP = symbol_new (sym->name, absolute_section,\n \t\t\t\t     (valueT) sym->value, &zero_address_frag);\n       SF_SET_LOCAL (symbolP);\n       symbol_table_insert (symbolP);\n-      hash_err = hash_insert (reg_hash, sym->name, (char *) sym);\n+      str_hash_insert (reg_hash, sym->name, (char *) sym);\n     }\n   for (sym = (tic54x_symbol *) mmregs; sym->name; sym++)\n-    hash_err = hash_insert (reg_hash, sym->name, (char *) sym);\n-  mmreg_hash = hash_new ();\n+    str_hash_insert (reg_hash, sym->name, (char *) sym);\n+  mmreg_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) mmregs; sym->name; sym++)\n-    hash_err = hash_insert (mmreg_hash, sym->name, (char *) sym);\n+    str_hash_insert (mmreg_hash, sym->name, (char *) sym);\n \n-  cc_hash = hash_new ();\n+  cc_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) condition_codes; sym->name; sym++)\n-    hash_err = hash_insert (cc_hash, sym->name, (char *) sym);\n+    str_hash_insert (cc_hash, sym->name, (char *) sym);\n \n-  cc2_hash = hash_new ();\n+  cc2_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) cc2_codes; sym->name; sym++)\n-    hash_err = hash_insert (cc2_hash, sym->name, (char *) sym);\n+    str_hash_insert (cc2_hash, sym->name, (char *) sym);\n \n-  cc3_hash = hash_new ();\n+  cc3_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) cc3_codes; sym->name; sym++)\n-    hash_err = hash_insert (cc3_hash, sym->name, (char *) sym);\n+    str_hash_insert (cc3_hash, sym->name, (char *) sym);\n \n-  sbit_hash = hash_new ();\n+  sbit_hash = str_htab_create ();\n   for (sym = (tic54x_symbol *) status_bits; sym->name; sym++)\n-    hash_err = hash_insert (sbit_hash, sym->name, (char *) sym);\n+    str_hash_insert (sbit_hash, sym->name, (char *) sym);\n \n-  misc_symbol_hash = hash_new ();\n+  misc_symbol_hash = str_htab_create ();\n   for (symname = (char **) misc_symbols; *symname; symname++)\n-    hash_err = hash_insert (misc_symbol_hash, *symname, *symname);\n+    str_hash_insert (misc_symbol_hash, *symname, *symname);\n \n   /* Only the base substitution table and local label table are initialized;\n      the others (for local macro substitution) get instantiated as needed.  */\n-  local_label_hash[0] = hash_new ();\n-  subsym_hash[0] = hash_new ();\n+  local_label_hash[0] = str_htab_create ();\n+  subsym_hash[0] = str_htab_create ();\n   for (subsym_proc = subsym_procs; subsym_proc->name; subsym_proc++)\n-    hash_err = hash_insert (subsym_hash[0], subsym_proc->name,\n-\t\t\t    (char *) subsym_proc);\n+    str_hash_insert (subsym_hash[0], subsym_proc->name,\n+\t\t     (char *) subsym_proc);\n \n-  math_hash = hash_new ();\n+  math_hash = str_htab_create ();\n   for (math_proc = math_procs; math_proc->name; math_proc++)\n     {\n       /* Insert into the main subsym hash for recognition; insert into\n \t the math hash to actually store information.  */\n-      hash_err = hash_insert (subsym_hash[0], math_proc->name,\n-\t\t\t      (char *) math_proc);\n-      hash_err = hash_insert (math_hash, math_proc->name,\n-\t\t\t      (char *) math_proc);\n+      str_hash_insert (subsym_hash[0], math_proc->name,\n+\t\t       (char *) math_proc);\n+      str_hash_insert (math_hash, math_proc->name,\n+\t\t       (char *) math_proc);\n     }\n-  subsym_recurse_hash = hash_new ();\n-  stag_hash = hash_new ();\n+  subsym_recurse_hash = str_htab_create ();\n+  stag_hash = str_htab_create ();\n }\n \n static int\n@@ -3257,7 +3253,7 @@ is_mmreg (struct opstruct *operand)\n {\n   return (is_absolute (operand)\n \t  || is_immediate (operand)\n-\t  || hash_find (mmreg_hash, operand->buf) != 0);\n+\t  || str_hash_find (mmreg_hash, operand->buf) != 0);\n }\n \n static int\n@@ -3301,13 +3297,13 @@ is_type (struct opstruct *operand, enum optype type)\n       return strncasecmp (\"ar\", operand->buf, 2) == 0\n \t&& ISDIGIT (operand->buf[2]);\n     case OP_SBIT:\n-      return hash_find (sbit_hash, operand->buf) != 0 || is_absolute (operand);\n+      return str_hash_find (sbit_hash, operand->buf) != 0 || is_absolute (operand);\n     case OP_CC:\n-      return hash_find (cc_hash, operand->buf) != 0;\n+      return str_hash_find (cc_hash, operand->buf) != 0;\n     case OP_CC2:\n-      return hash_find (cc2_hash, operand->buf) != 0;\n+      return str_hash_find (cc2_hash, operand->buf) != 0;\n     case OP_CC3:\n-      return hash_find (cc3_hash, operand->buf) != 0\n+      return str_hash_find (cc3_hash, operand->buf) != 0\n \t|| is_immediate (operand) || is_absolute (operand);\n     case OP_16:\n       return (is_immediate (operand) || is_absolute (operand))\n@@ -3649,7 +3645,7 @@ encode_integer (tic54x_insn *insn,\n static int\n encode_condition (tic54x_insn *insn, struct opstruct *operand)\n {\n-  tic54x_symbol *cc = (tic54x_symbol *) hash_find (cc_hash, operand->buf);\n+  tic54x_symbol *cc = (tic54x_symbol *) str_hash_find (cc_hash, operand->buf);\n   if (!cc)\n     {\n       as_bad (_(\"Unrecognized condition code \\\"%s\\\"\"), operand->buf);\n@@ -3709,7 +3705,7 @@ encode_condition (tic54x_insn *insn, struct opstruct *operand)\n static int\n encode_cc3 (tic54x_insn *insn, struct opstruct *operand)\n {\n-  tic54x_symbol *cc3 = (tic54x_symbol *) hash_find (cc3_hash, operand->buf);\n+  tic54x_symbol *cc3 = (tic54x_symbol *) str_hash_find (cc3_hash, operand->buf);\n   int value = cc3 ? cc3->value : operand->exp.X_add_number << 8;\n \n   if ((value & 0x0300) != value)\n@@ -3738,7 +3734,7 @@ encode_arx (tic54x_insn *insn, struct opstruct *operand)\n static int\n encode_cc2 (tic54x_insn *insn, struct opstruct *operand)\n {\n-  tic54x_symbol *cc2 = (tic54x_symbol *) hash_find (cc2_hash, operand->buf);\n+  tic54x_symbol *cc2 = (tic54x_symbol *) str_hash_find (cc2_hash, operand->buf);\n \n   if (!cc2)\n     {\n@@ -3898,7 +3894,7 @@ encode_operand (tic54x_insn *insn, enum optype type, struct opstruct *operand)\n     case OP_SBIT:\n       {\n \ttic54x_symbol *sbit = (tic54x_symbol *)\n-\t  hash_find (sbit_hash, operand->buf);\n+\t  str_hash_find (sbit_hash, operand->buf);\n \tint value = is_absolute (operand) ?\n \t  operand->exp.X_add_number : (sbit ? sbit->value : -1);\n \tint reg = 0;\n@@ -3912,7 +3908,7 @@ encode_operand (tic54x_insn *insn, enum optype type, struct opstruct *operand)\n \t      }\n \t    /* Guess the register based on the status bit; \"ovb\" is the last\n \t       status bit defined for st0.  */\n-\t    if (sbit > (tic54x_symbol *) hash_find (sbit_hash, \"ovb\"))\n+\t    if (sbit > (tic54x_symbol *) str_hash_find (sbit_hash, \"ovb\"))\n \t      reg = 1;\n \t  }\n \tif (value == -1)\n@@ -4152,7 +4148,7 @@ optimize_insn (tic54x_insn *insn)\n static int\n tic54x_parse_insn (tic54x_insn *insn, char *line)\n {\n-  insn->tm = (insn_template *) hash_find (op_hash, insn->mnemonic);\n+  insn->tm = (insn_template *) str_hash_find (op_hash, insn->mnemonic);\n   if (!insn->tm)\n     {\n       as_bad (_(\"Unrecognized instruction \\\"%s\\\"\"), insn->mnemonic);\n@@ -4175,7 +4171,7 @@ tic54x_parse_insn (tic54x_insn *insn, char *line)\n \t  /* SUCCESS! now try some optimizations.  */\n \t  if (optimize_insn (insn))\n \t    {\n-\t      insn->tm = (insn_template *) hash_find (op_hash,\n+\t      insn->tm = (insn_template *) str_hash_find (op_hash,\n                                                       insn->mnemonic);\n \t      continue;\n \t    }\n@@ -4210,7 +4206,7 @@ next_line_shows_parallel (char *next_line)\n static int\n tic54x_parse_parallel_insn_firstline (tic54x_insn *insn, char *line)\n {\n-  insn->tm = (insn_template *) hash_find (parop_hash, insn->mnemonic);\n+  insn->tm = (insn_template *) str_hash_find (parop_hash, insn->mnemonic);\n   if (!insn->tm)\n     {\n       as_bad (_(\"Unrecognized parallel instruction \\\"%s\\\"\"),\n@@ -4341,17 +4337,8 @@ subsym_create_or_replace (char *name, char *value)\n   int i;\n \n   for (i = macro_level; i > 0; i--)\n-    {\n-      if (hash_find (subsym_hash[i], name))\n-\t{\n-\t  hash_replace (subsym_hash[i], name, value);\n-\t  return;\n-\t}\n-    }\n-  if (hash_find (subsym_hash[0], name))\n-    hash_replace (subsym_hash[0], name, value);\n-  else\n-    hash_insert (subsym_hash[0], name, value);\n+    str_hash_insert (subsym_hash[i], name, value);\n+  str_hash_insert (subsym_hash[0], name, value);\n }\n \n /* Look up the substitution string replacement for the given symbol.\n@@ -4361,7 +4348,7 @@ subsym_create_or_replace (char *name, char *value)\n static char *\n subsym_lookup (char *name, int nest_level)\n {\n-  char *value = hash_find (subsym_hash[nest_level], name);\n+  char *value = str_hash_find (subsym_hash[nest_level], name);\n \n   if (value || nest_level == 0)\n     return value;\n@@ -4482,7 +4469,7 @@ subsym_substitute (char *line, int forced)\n \t    }\n \t  /* Avoid infinite recursion; if a symbol shows up a second time for\n \t     substitution, leave it as is.  */\n-\t  if (hash_find (subsym_recurse_hash, name) == NULL)\n+\t  if (str_hash_find (subsym_recurse_hash, name) == NULL)\n \t    value = subsym_lookup (name, macro_level);\n \t  else\n \t    as_warn (_(\"%s symbol recursion stopped at \"\n@@ -4498,7 +4485,7 @@ subsym_substitute (char *line, int forced)\n \t    {\n \t      /* Use an existing identifier for that label if, available, or\n \t\t create a new, unique identifier.  */\n-\t      value = hash_find (local_label_hash[macro_level], name);\n+\t      value = str_hash_find (local_label_hash[macro_level], name);\n \t      if (value == NULL)\n \t\t{\n \t\t  char digit[11];\n@@ -4510,7 +4497,7 @@ subsym_substitute (char *line, int forced)\n \t\t    value[strlen (value) - 1] = '\\0';\n \t\t  sprintf (digit, \".%d\", local_label_id++);\n \t\t  strcat (value, digit);\n-\t\t  hash_insert (local_label_hash[macro_level], namecopy, value);\n+\t\t  str_hash_insert (local_label_hash[macro_level], namecopy, value);\n \t\t}\n \t      /* Indicate where to continue looking for substitutions.  */\n \t      ptr = tail;\n@@ -4519,7 +4506,7 @@ subsym_substitute (char *line, int forced)\n \t  else if (value != NULL && *name == '$')\n \t    {\n \t      subsym_proc_entry *entry = (subsym_proc_entry *) value;\n-\t      math_proc_entry *math_entry = hash_find (math_hash, name);\n+\t      math_proc_entry *math_entry = str_hash_find (math_hash, name);\n \t      char *arg1, *arg2 = NULL;\n \n \t      *ptr = c;\n@@ -4631,9 +4618,9 @@ subsym_substitute (char *line, int forced)\n \t\t try to replace a symbol once.  */\n \t      if (recurse)\n \t\t{\n-\t\t  hash_insert (subsym_recurse_hash, name, name);\n+\t\t  str_hash_insert (subsym_recurse_hash, name, name);\n \t\t  value = subsym_substitute (value, macro_level > 0);\n-\t\t  hash_delete (subsym_recurse_hash, name, FALSE);\n+\t\t  str_hash_delete (subsym_recurse_hash, name);\n \t\t}\n \n \t      /* Temporarily zero-terminate where the symbol started.  */\n@@ -5022,19 +5009,19 @@ tic54x_undefined_symbol (char *name)\n   tic54x_symbol *sym;\n \n   /* Not sure how to handle predefined symbols.  */\n-  if ((sym = (tic54x_symbol *) hash_find (cc_hash, name)) != NULL ||\n-      (sym = (tic54x_symbol *) hash_find (cc2_hash, name)) != NULL ||\n-      (sym = (tic54x_symbol *) hash_find (cc3_hash, name)) != NULL ||\n-      (sym = (tic54x_symbol *) hash_find (misc_symbol_hash, name)) != NULL ||\n-      (sym = (tic54x_symbol *) hash_find (sbit_hash, name)) != NULL)\n+  if ((sym = (tic54x_symbol *) str_hash_find (cc_hash, name)) != NULL ||\n+      (sym = (tic54x_symbol *) str_hash_find (cc2_hash, name)) != NULL ||\n+      (sym = (tic54x_symbol *) str_hash_find (cc3_hash, name)) != NULL ||\n+      (sym = (tic54x_symbol *) str_hash_find (misc_symbol_hash, name)) != NULL ||\n+      (sym = (tic54x_symbol *) str_hash_find (sbit_hash, name)) != NULL)\n     {\n       return symbol_new (name, reg_section,\n \t\t\t (valueT) sym->value,\n \t\t\t &zero_address_frag);\n     }\n \n-  if ((sym = (tic54x_symbol *) hash_find (reg_hash, name)) != NULL ||\n-      (sym = (tic54x_symbol *) hash_find (mmreg_hash, name)) != NULL ||\n+  if ((sym = (tic54x_symbol *) str_hash_find (reg_hash, name)) != NULL ||\n+      (sym = (tic54x_symbol *) str_hash_find (mmreg_hash, name)) != NULL ||\n       !strcasecmp (name, \"a\") || !strcasecmp (name, \"b\"))\n     {\n       return symbol_new (name, reg_section,"
    },
    {
      "sha": "fa54f87fbec51aa3c9c84a28f5c24c8425e47a9f",
      "filename": "gas/config/tc-tic6x.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tic6x.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -742,7 +742,7 @@ const pseudo_typeS md_pseudo_table[] =\n /* Hash table of opcodes.  For each opcode name, this stores a pointer\n    to a tic6x_opcode_list listing (in an arbitrary order) all opcode\n    table entries with that name.  */\n-static struct hash_control *opcode_hash;\n+static htab_t opcode_hash;\n \n /* Initialize the assembler (called once at assembler startup).  */\n \n@@ -757,17 +757,14 @@ md_begin (void)\n   bfd_set_arch_mach (stdoutput, TARGET_ARCH, 0);\n \n   /* Insert opcodes into the hash table.  */\n-  opcode_hash = hash_new ();\n+  opcode_hash = str_htab_create ();\n   for (id = 0; id < tic6x_opcode_max; id++)\n     {\n-      const char *errmsg;\n       tic6x_opcode_list *opc = XNEW (tic6x_opcode_list);\n \n       opc->id = id;\n-      opc->next = hash_find (opcode_hash, tic6x_opcode_table[id].name);\n-      if ((errmsg = hash_jam (opcode_hash, tic6x_opcode_table[id].name, opc))\n-\t  != NULL)\n-\tas_fatal (\"%s\", _(errmsg));\n+      opc->next = str_hash_find (opcode_hash, tic6x_opcode_table[id].name);\n+      str_hash_insert (opcode_hash, tic6x_opcode_table[id].name, opc);\n     }\n \n   /* Save the current subseg so we can restore it [it's the default one and\n@@ -3187,7 +3184,7 @@ md_assemble (char *str)\n   this_insn_label_list = seginfo->tc_segment_info_data.label_list;\n   seginfo->tc_segment_info_data.label_list = NULL;\n \n-  opc_list = hash_find_n (opcode_hash, str, p - str);\n+  opc_list = str_hash_find_n (opcode_hash, str, p - str);\n   if (opc_list == NULL)\n     {\n       char c = *p;"
    },
    {
      "sha": "2220af4696771a4291876712a3d6ddf37a78a558",
      "filename": "gas/config/tc-tilegx.c",
      "status": "modified",
      "additions": 18,
      "deletions": 22,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilegx.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -177,13 +177,13 @@ md_show_usage (FILE *stream)\n #define O_hw1_last_plt\t\tO_md27\n #define O_hw2_last_plt\t\tO_md28\n \n-static struct hash_control *special_operator_hash;\n+static htab_t special_operator_hash;\n \n /* Hash tables for instruction mnemonic lookup.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \n /* Hash table for spr lookup.  */\n-static struct hash_control *spr_hash;\n+static htab_t spr_hash;\n \n /* True temporarily while parsing an SPR expression. This changes the\n  * namespace to include SPR names.  */\n@@ -231,7 +231,7 @@ static int allow_suspicious_bundles;\n    for that register (e.g. r63 instead of zero), so we should generate\n    a warning. The attempted register number can be found by clearing\n    NONCANONICAL_REG_NAME_FLAG.  */\n-static struct hash_control *main_reg_hash;\n+static htab_t main_reg_hash;\n \n \n /* We cannot unambiguously store a 0 in a hash table and look it up,\n@@ -273,9 +273,9 @@ md_begin (void)\n   tilegx_cie_data_alignment = (tilegx_arch_size == 64 ? -8 : -4);\n \n   /* Initialize special operator hash table.  */\n-  special_operator_hash = hash_new ();\n+  special_operator_hash = str_htab_create ();\n #define INSERT_SPECIAL_OP(name)\t\t\t\t\t\\\n-  hash_insert (special_operator_hash, #name, (void *)O_##name)\n+  str_hash_insert (special_operator_hash, #name, (void *)O_##name)\n \n   INSERT_SPECIAL_OP (hw0);\n   INSERT_SPECIAL_OP (hw1);\n@@ -285,7 +285,7 @@ md_begin (void)\n   INSERT_SPECIAL_OP (hw1_last);\n   INSERT_SPECIAL_OP (hw2_last);\n   /* hw3_last is a convenience alias for the equivalent hw3.  */\n-  hash_insert (special_operator_hash, \"hw3_last\", (void*)O_hw3);\n+  str_hash_insert (special_operator_hash, \"hw3_last\", (void*)O_hw3);\n   INSERT_SPECIAL_OP (hw0_got);\n   INSERT_SPECIAL_OP (hw0_last_got);\n   INSERT_SPECIAL_OP (hw1_last_got);\n@@ -310,36 +310,32 @@ md_begin (void)\n #undef INSERT_SPECIAL_OP\n \n   /* Initialize op_hash hash table.  */\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n   for (op = &tilegx_opcodes[0]; op->name != NULL; op++)\n-    {\n-      const char *hash_err = hash_insert (op_hash, op->name, (void *)op);\n-      if (hash_err != NULL)\n-\tas_fatal (_(\"Internal Error:  Can't hash %s: %s\"), op->name, hash_err);\n-    }\n+    str_hash_insert (op_hash, op->name, (void *)op);\n \n   /* Initialize the spr hash table.  */\n   parsing_spr = 0;\n-  spr_hash = hash_new ();\n+  spr_hash = str_htab_create ();\n   for (i = 0; i < tilegx_num_sprs; i++)\n-    hash_insert (spr_hash, tilegx_sprs[i].name,\n+    str_hash_insert (spr_hash, tilegx_sprs[i].name,\n                  (void *) &tilegx_sprs[i]);\n \n   /* Set up the main_reg_hash table. We use this instead of\n      creating a symbol in the register section to avoid ambiguities\n      with labels that have the same names as registers.  */\n-  main_reg_hash = hash_new ();\n+  main_reg_hash = str_htab_create ();\n   for (i = 0; i < TILEGX_NUM_REGISTERS; i++)\n     {\n       char buf[64];\n \n-      hash_insert (main_reg_hash, tilegx_register_names[i],\n+      str_hash_insert (main_reg_hash, tilegx_register_names[i],\n \t\t   (void *) (long) (i | CANONICAL_REG_NAME_FLAG));\n \n       /* See if we should insert a noncanonical alias, like r63.  */\n       sprintf (buf, \"r%d\", i);\n       if (strcmp (buf, tilegx_register_names[i]) != 0)\n-\thash_insert (main_reg_hash, xstrdup (buf),\n+\tstr_hash_insert (main_reg_hash, xstrdup (buf),\n \t\t     (void *) (long) (i | NONCANONICAL_REG_NAME_FLAG));\n     }\n }\n@@ -1013,7 +1009,7 @@ tilegx_parse_name (char *name, expressionS *e, char *nextcharP)\n \n   if (parsing_spr)\n     {\n-      void* val = hash_find (spr_hash, name);\n+      void* val = str_hash_find (spr_hash, name);\n       if (val == NULL)\n \treturn 0;\n \n@@ -1031,7 +1027,7 @@ tilegx_parse_name (char *name, expressionS *e, char *nextcharP)\n   else\n     {\n       /* Look up the operator in our table.  */\n-      void* val = hash_find (special_operator_hash, name);\n+      void* val = str_hash_find (special_operator_hash, name);\n       if (val == 0)\n \treturn 0;\n       op = (operatorT)(long)val;\n@@ -1098,7 +1094,7 @@ parse_reg_expression (expressionS* expression)\n \n   terminating_char = get_symbol_name (&regname);\n \n-  pval = hash_find (main_reg_hash, regname);\n+  pval = str_hash_find (main_reg_hash, regname);\n   if (pval == NULL)\n     as_bad (_(\"Expected register, got '%s'.\"), regname);\n \n@@ -1243,7 +1239,7 @@ md_assemble (char *str)\n   old_char = str[opname_len];\n   str[opname_len] = '\\0';\n \n-  op = hash_find(op_hash, str);\n+  op = str_hash_find(op_hash, str);\n   str[opname_len] = old_char;\n   if (op == NULL)\n     {"
    },
    {
      "sha": "cf44ad1374295a691ae86240dc8233c48a7d5208",
      "filename": "gas/config/tc-tilepro.c",
      "status": "modified",
      "additions": 23,
      "deletions": 30,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-tilepro.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -126,13 +126,13 @@ md_show_usage (FILE *stream)\n #define O_tls_gd_add  O_md22\n #define O_tls_ie_load O_md23\n \n-static struct hash_control *special_operator_hash;\n+static htab_t special_operator_hash;\n \n /* Hash tables for instruction mnemonic lookup.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \n /* Hash table for spr lookup.  */\n-static struct hash_control *spr_hash;\n+static htab_t spr_hash;\n \n /* True temporarily while parsing an SPR expression. This changes the\n  * namespace to include SPR names.  */\n@@ -181,7 +181,7 @@ static int allow_suspicious_bundles;\n    for that register (e.g. r63 instead of zero), so we should generate\n    a warning. The attempted register number can be found by clearing\n    NONCANONICAL_REG_NAME_FLAG.  */\n-static struct hash_control *main_reg_hash;\n+static htab_t main_reg_hash;\n \n \n /* We cannot unambiguously store a 0 in a hash table and look it up,\n@@ -216,9 +216,9 @@ md_begin (void)\n   inside_bundle = 0;\n \n   /* Initialize special operator hash table.  */\n-  special_operator_hash = hash_new ();\n+  special_operator_hash = str_htab_create ();\n #define INSERT_SPECIAL_OP(name)\t\t\t\t\t\\\n-  hash_insert (special_operator_hash, #name, (void *)O_##name)\n+  str_hash_insert (special_operator_hash, #name, (void *)O_##name)\n \n   INSERT_SPECIAL_OP(lo16);\n   INSERT_SPECIAL_OP(hi16);\n@@ -246,54 +246,47 @@ md_begin (void)\n #undef INSERT_SPECIAL_OP\n \n   /* Initialize op_hash hash table.  */\n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n   for (op = &tilepro_opcodes[0]; op->name != NULL; op++)\n-    {\n-      const char *hash_err = hash_insert (op_hash, op->name, (void *)op);\n-      if (hash_err != NULL)\n-\t{\n-\t  as_fatal (_(\"Internal Error:  Can't hash %s: %s\"),\n-\t\t    op->name, hash_err);\n-\t}\n-    }\n+    str_hash_insert (op_hash, op->name, (void *)op);\n \n   /* Initialize the spr hash table.  */\n   parsing_spr = 0;\n-  spr_hash = hash_new ();\n+  spr_hash = str_htab_create ();\n   for (i = 0; i < tilepro_num_sprs; i++)\n-    hash_insert (spr_hash, tilepro_sprs[i].name,\n+    str_hash_insert (spr_hash, tilepro_sprs[i].name,\n                  (void *) &tilepro_sprs[i]);\n \n   /* Set up the main_reg_hash table. We use this instead of\n    * creating a symbol in the register section to avoid ambiguities\n    * with labels that have the same names as registers.  */\n-  main_reg_hash = hash_new ();\n+  main_reg_hash = str_htab_create ();\n   for (i = 0; i < TILEPRO_NUM_REGISTERS; i++)\n     {\n       char buf[64];\n \n-      hash_insert (main_reg_hash, tilepro_register_names[i],\n+      str_hash_insert (main_reg_hash, tilepro_register_names[i],\n \t\t   (void *) (long)(i | CANONICAL_REG_NAME_FLAG));\n \n       /* See if we should insert a noncanonical alias, like r63.  */\n       sprintf (buf, \"r%d\", i);\n       if (strcmp (buf, tilepro_register_names[i]) != 0)\n-\thash_insert (main_reg_hash, xstrdup (buf),\n+\tstr_hash_insert (main_reg_hash, xstrdup (buf),\n \t\t     (void *) (long)(i | NONCANONICAL_REG_NAME_FLAG));\n     }\n \n   /* Insert obsolete backwards-compatibility register names.  */\n-  hash_insert (main_reg_hash, \"io0\",\n+  str_hash_insert (main_reg_hash, \"io0\",\n                (void *) (long) (TREG_IDN0 | CANONICAL_REG_NAME_FLAG));\n-  hash_insert (main_reg_hash, \"io1\",\n+  str_hash_insert (main_reg_hash, \"io1\",\n                (void *) (long) (TREG_IDN1 | CANONICAL_REG_NAME_FLAG));\n-  hash_insert (main_reg_hash, \"us0\",\n+  str_hash_insert (main_reg_hash, \"us0\",\n                (void *) (long) (TREG_UDN0 | CANONICAL_REG_NAME_FLAG));\n-  hash_insert (main_reg_hash, \"us1\",\n+  str_hash_insert (main_reg_hash, \"us1\",\n                (void *) (long) (TREG_UDN1 | CANONICAL_REG_NAME_FLAG));\n-  hash_insert (main_reg_hash, \"us2\",\n+  str_hash_insert (main_reg_hash, \"us2\",\n                (void *) (long) (TREG_UDN2 | CANONICAL_REG_NAME_FLAG));\n-  hash_insert (main_reg_hash, \"us3\",\n+  str_hash_insert (main_reg_hash, \"us3\",\n                (void *) (long) (TREG_UDN3 | CANONICAL_REG_NAME_FLAG));\n \n }\n@@ -903,7 +896,7 @@ tilepro_parse_name (char *name, expressionS *e, char *nextcharP)\n \n   if (parsing_spr)\n     {\n-      void *val = hash_find (spr_hash, name);\n+      void *val = str_hash_find (spr_hash, name);\n       if (val == NULL)\n \treturn 0;\n \n@@ -922,7 +915,7 @@ tilepro_parse_name (char *name, expressionS *e, char *nextcharP)\n   else\n     {\n       /* Look up the operator in our table.  */\n-      void *val = hash_find (special_operator_hash, name);\n+      void *val = str_hash_find (special_operator_hash, name);\n       if (val == 0)\n \treturn 0;\n       op = (operatorT)(long)val;\n@@ -984,7 +977,7 @@ parse_reg_expression (expressionS* expression)\n   char *regname;\n   char terminating_char = get_symbol_name (&regname);\n \n-  void* pval = hash_find (main_reg_hash, regname);\n+  void* pval = str_hash_find (main_reg_hash, regname);\n \n   if (pval == NULL)\n     as_bad (_(\"Expected register, got '%s'.\"), regname);\n@@ -1128,7 +1121,7 @@ md_assemble (char *str)\n   old_char = str[opname_len];\n   str[opname_len] = '\\0';\n \n-  op = hash_find(op_hash, str);\n+  op = str_hash_find(op_hash, str);\n   str[opname_len] = old_char;\n   if (op == NULL)\n     {"
    },
    {
      "sha": "cd5badaa3a32811df3fdb7bd69fdf6061336d008",
      "filename": "gas/config/tc-v850.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-v850.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -599,7 +599,7 @@ const pseudo_typeS md_pseudo_table[] =\n };\n \n /* Opcode hash table.  */\n-static struct hash_control *v850_hash;\n+static htab_t v850_hash;\n \n /* This table is sorted.  Suitable for searching by a binary search.  */\n static const struct reg_name pre_defined_registers[] =\n@@ -1952,7 +1952,7 @@ md_begin (void)\n   if (soft_float == -1)\n     soft_float = machine < bfd_mach_v850e2v3;\n \n-  v850_hash = hash_new ();\n+  v850_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  The V850 instruction set\n      has many identical opcode names that have different opcodes based\n@@ -1964,7 +1964,8 @@ md_begin (void)\n       if (strcmp (prev_name, op->name))\n \t{\n \t  prev_name = (char *) op->name;\n-\t  hash_insert (v850_hash, op->name, (char *) op);\n+\t  if (str_hash_find (v850_hash, op->name) == NULL)\n+\t    str_hash_insert (v850_hash, op->name, (char *) op);\n \t}\n       op++;\n     }\n@@ -2321,7 +2322,7 @@ md_assemble (char *str)\n     *s++ = '\\0';\n \n   /* Find the first opcode with the proper name.  */\n-  opcode = (struct v850_opcode *) hash_find (v850_hash, str);\n+  opcode = (struct v850_opcode *) str_hash_find (v850_hash, str);\n   if (opcode == NULL)\n     {\n       /* xgettext:c-format  */"
    },
    {
      "sha": "04a955f62bd19dc4c202193f0a5634eb0e72d276",
      "filename": "gas/config/tc-vax.c",
      "status": "modified",
      "additions": 10,
      "deletions": 16,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-vax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-vax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-vax.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -736,7 +736,7 @@ md_ri_to_chars (char *the_bytes, struct reloc_info_generic ri)\n   \tsource file, and changed the makefile.  */\n \n /* Handle of the OPCODE hash table.  */\n-static struct hash_control *op_hash;\n+static htab_t op_hash;\n \n /* In:\t1 character, from \"bdfghloqpw\" being the data-type of an operand\n   \tof a vax instruction.\n@@ -950,29 +950,26 @@ vip_op_defaults (const char *immediate, const char *indirect, const char *disple\n    instruction table.\n    You must nominate metacharacters for eg DEC's \"#\", \"@\", \"^\".  */\n \n-static const char *\n+static void\n vip_begin (int synthetic_too,\t\t/* 1 means include jXXX op-codes.  */\n \t   const char *immediate,\n \t   const char *indirect,\n \t   const char *displen)\n {\n   const struct vot *vP;\t\t/* scan votstrs */\n-  const char *retval = 0;\t/* error text */\n \n-  op_hash = hash_new ();\n+  op_hash = str_htab_create ();\n \n-  for (vP = votstrs; *vP->vot_name && !retval; vP++)\n-    retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);\n+  for (vP = votstrs; *vP->vot_name; vP++)\n+    str_hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);\n \n   if (synthetic_too)\n-    for (vP = synthetic_votstrs; *vP->vot_name && !retval; vP++)\n-      retval = hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);\n+    for (vP = synthetic_votstrs; *vP->vot_name; vP++)\n+      str_hash_insert (op_hash, vP->vot_name, (void *) &vP->vot_detail);\n \n #ifndef CONST_TABLE\n   vip_op_defaults (immediate, indirect, displen);\n #endif\n-\n-  return retval;\n }\n \n /* Take 3 char.s, the last of which may be `\\0` (non-existent)\n@@ -1887,7 +1884,7 @@ vip (struct vit *vitP,\t\t/* We build an exploded instruction here.  */\n       /* Here with instring pointing to what better be an op-name, and p\n          pointing to character just past that.\n          We trust instring points to an op-name, with no whitespace.  */\n-      vwP = (struct vot_wot *) hash_find (op_hash, instring);\n+      vwP = (struct vot_wot *) str_hash_find (op_hash, instring);\n       /* Restore char after op-code.  */\n       *p = c;\n       if (vwP == 0)\n@@ -1986,8 +1983,7 @@ main (void)\n   printf (\"enter displen symbols   eg enter ^   \");\n   gets (my_displen);\n \n-  if (p = vip_begin (mysynth, my_immediate, my_indirect, my_displen))\n-    error (\"vip_begin=%s\", p);\n+  vip_begin (mysynth, my_immediate, my_indirect, my_displen)\n \n   printf (\"An empty input line will quit you from the vax instruction parser\\n\");\n   for (;;)\n@@ -3256,12 +3252,10 @@ md_assemble (char *instruction_string)\n void\n md_begin (void)\n {\n-  const char *errtxt;\n   FLONUM_TYPE *fP;\n   int i;\n \n-  if ((errtxt = vip_begin (1, \"$\", \"*\", \"`\")) != 0)\n-    as_fatal (_(\"VIP_BEGIN error:%s\"), errtxt);\n+  vip_begin (1, \"$\", \"*\", \"`\");\n \n   for (i = 0, fP = float_operand;\n        fP < float_operand + VIT_MAX_OPERANDS;"
    },
    {
      "sha": "fce12a9310a21d9d4ae9b6e09a8ad3a8c1553033",
      "filename": "gas/config/tc-wasm32.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-wasm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-wasm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-wasm32.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -92,7 +92,7 @@ const pseudo_typeS md_pseudo_table[] =\n \n /* Opcode hash table.  */\n \n-static struct hash_control *wasm32_hash;\n+static htab_t wasm32_hash;\n \n struct option md_longopts[] =\n {\n@@ -158,13 +158,13 @@ md_begin (void)\n {\n   struct wasm32_opcode_s *opcode;\n \n-  wasm32_hash = hash_new ();\n+  wasm32_hash = str_htab_create ();\n \n   /* Insert unique names into hash table.  This hash table then\n      provides a quick index to the first opcode with a particular name\n      in the opcode table.  */\n   for (opcode = wasm32_opcodes; opcode->name; opcode++)\n-    hash_insert (wasm32_hash, opcode->name, (char *) opcode);\n+    str_hash_insert (wasm32_hash, opcode->name, (char *) opcode);\n \n   linkrelax = 0;\n   flag_sectname_subst = 1;\n@@ -746,7 +746,7 @@ md_assemble (char *str)\n   if (!op[0])\n     as_bad (_(\"can't find opcode \"));\n \n-  opcode = (struct wasm32_opcode_s *) hash_find (wasm32_hash, op);\n+  opcode = (struct wasm32_opcode_s *) str_hash_find (wasm32_hash, op);\n \n   if (opcode == NULL)\n     {"
    },
    {
      "sha": "4b9adf3378d9a002f6643cce3c2e104b13b7233d",
      "filename": "gas/config/tc-xgate.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-xgate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-xgate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xgate.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -113,7 +113,7 @@ static void xgate_scan_operands (struct xgate_opcode *opcode, s_operand []);\n static unsigned int xgate_parse_operand (struct xgate_opcode *, int *, int,\n \t\t\t\t\t char **, s_operand);\n \n-static struct hash_control *xgate_hash;\n+static htab_t xgate_hash;\n \n /* Previous opcode.  */\n static unsigned int prev = 0;\n@@ -324,7 +324,7 @@ md_begin (void)\n   op_handles = XNEWVEC (struct xgate_opcode_handle, number_of_op_handles);\n \n   /* Insert unique opcode names into hash table, aliasing duplicates.  */\n-  xgate_hash = hash_new ();\n+  xgate_hash = str_htab_create ();\n \n   prev_op_name = \"\";\n   for (xgate_opcode_ptr = xgate_op_table, i = 0, j = 0; i < xgate_num_opcodes;\n@@ -342,7 +342,7 @@ md_begin (void)\n \t    j++;\n \t  op_handles[j].name = xgate_opcode_ptr->name;\n \t  op_handles[j].opc0[0] = xgate_opcode_ptr;\n-\t  hash_insert (xgate_hash, (char *) op_handles[j].name,\n+\t  str_hash_insert (xgate_hash, (char *) op_handles[j].name,\n \t\t       (char *) &(op_handles[j]));\n \t}\n       op_handles[j].number_of_modes = handle_enum;\n@@ -492,7 +492,7 @@ md_assemble (char *input_line)\n   if (!op_name[0])\n     as_bad (_(\"opcode missing or not found on input line\"));\n \n-  if (!(opcode_handle = (struct xgate_opcode_handle *) hash_find (xgate_hash,\n+  if (!(opcode_handle = (struct xgate_opcode_handle *) str_hash_find (xgate_hash,\n \t\t\t\t\t\t\t\t  op_name)))\n     {\n       as_bad (_(\"opcode %s not found in opcode hash table\"), op_name);\n@@ -544,7 +544,7 @@ md_assemble (char *input_line)\n \t      p = extract_word (p, op_name, 10);\n \n \t      if (!(opcode_handle = (struct xgate_opcode_handle *)\n-\t\t    hash_find (xgate_hash, op_name)))\n+\t\t    str_hash_find (xgate_hash, op_name)))\n \t\t{\n \t\t  as_bad (_(\": processing macro, real opcode handle\"\n \t\t\t    \" not found in hash\"));"
    },
    {
      "sha": "188604316285d18c9d296054b7be69a0373810ff",
      "filename": "gas/config/tc-z8k.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-z8k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/629310abec8811510177101f3c7992dfd4be24dd/gas/config/tc-z8k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-z8k.c?ref=629310abec8811510177101f3c7992dfd4be24dd",
      "patch": "@@ -137,21 +137,21 @@ const char EXP_CHARS[] = \"eE\";\n const char FLT_CHARS[] = \"rRsSfFdDxXpP\";\n \n /* Opcode mnemonics.  */\n-static struct hash_control *opcode_hash_control;\n+static htab_t opcode_hash_control;\n \n void\n md_begin (void)\n {\n   const opcode_entry_type *opcode;\n   unsigned int idx = -1u;\n \n-  opcode_hash_control = hash_new ();\n+  opcode_hash_control = str_htab_create ();\n \n   for (opcode = z8k_table; opcode->name; opcode++)\n     {\n       /* Only enter unique codes into the table.  */\n       if (idx != opcode->idx)\n-\thash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n+\tstr_hash_insert (opcode_hash_control, opcode->name, (char *) opcode);\n       idx = opcode->idx;\n     }\n \n@@ -166,7 +166,7 @@ md_begin (void)\n       fake_opcode->name = md_pseudo_table[idx].poc_name;\n       fake_opcode->func = (void *) (md_pseudo_table + idx);\n       fake_opcode->opcode = 250;\n-      hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);\n+      str_hash_insert (opcode_hash_control, fake_opcode->name, fake_opcode);\n     }\n }\n \n@@ -1224,9 +1224,9 @@ md_assemble (char *str)\n     }\n   c = *op_end;\n \n-  *op_end = 0;  /* Zero-terminate op code string for hash_find() call.  */\n+  *op_end = 0;  /* Zero-terminate op code string for str_hash_find() call.  */\n \n-  opcode = (opcode_entry_type *) hash_find (opcode_hash_control, op_start);\n+  opcode = (opcode_entry_type *) str_hash_find (opcode_hash_control, op_start);\n \n   if (opcode == NULL)\n     {"
    }
  ]
}