{
  "sha": "7606e1a3904368d942ad886c110dc34581e98c42",
  "node_id": "C_kwDOANOeidoAKDc2MDZlMWEzOTA0MzY4ZDk0MmFkODg2YzExMGRjMzQ1ODFlOThjNDI",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-05T17:26:29Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:37Z"
    },
    "message": "sim: m68hc11: migrate to standard uintXX_t types\n\nThis old port setup its own uintXX types, but since we require C11\nnow, we can assume the standard uintXX_t types exist and use them.\n\nAlso migrate off the sim-specific unsignedXX types.",
    "tree": {
      "sha": "fa2cfb9f0421c4818324ffcf55b4a5028e42acc0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fa2cfb9f0421c4818324ffcf55b4a5028e42acc0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7606e1a3904368d942ad886c110dc34581e98c42",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7606e1a3904368d942ad886c110dc34581e98c42",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7606e1a3904368d942ad886c110dc34581e98c42",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7606e1a3904368d942ad886c110dc34581e98c42/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "eae126cb7e10fd2107f4457af929eda96447f728",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eae126cb7e10fd2107f4457af929eda96447f728",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eae126cb7e10fd2107f4457af929eda96447f728"
    }
  ],
  "stats": {
    "total": 538,
    "additions": 265,
    "deletions": 273
  },
  "files": [
    {
      "sha": "cdcc9f8eb918ae9f0c2b3bf3c980537779c88b22",
      "filename": "sim/m68hc11/dv-m68hc11.c",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-m68hc11.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -122,14 +122,14 @@ static const OPTION m68hc11_options[] =\n \n struct input_osc\n {\n-  signed64         on_time;\n-  signed64         off_time;\n-  signed64         repeat;\n+  int64_t         on_time;\n+  int64_t         off_time;\n+  int64_t         repeat;\n   struct hw_event *event;\n   const char      *name;\n-  uint8            mask;\n-  uint8            value;\n-  uint16           addr;\n+  uint8_t            mask;\n+  uint8_t            value;\n+  uint16_t           addr;\n };\n \n #define NR_PORT_A_OSC (4)\n@@ -209,7 +209,7 @@ static hw_ioctl_method m68hc11_ioctl;\n static hw_port_event_method m68hc11cpu_port_event;\n \n static void make_oscillator (struct m68hc11cpu *controller,\n-                             const char *id, uint16 addr, uint8 mask);\n+                             const char *id, uint16_t addr, uint8_t mask);\n static struct input_osc *find_oscillator (struct m68hc11cpu *controller,\n                                           const char *id);\n static void reset_oscillators (struct hw *me);\n@@ -412,7 +412,7 @@ deliver_m68hc11cpu_interrupt (struct hw *me, void *data)\n \n static void\n make_oscillator (struct m68hc11cpu *controller, const char *name,\n-                 uint16 addr, uint8 mask)\n+                 uint16_t addr, uint8_t mask)\n {\n   struct input_osc *osc;\n \n@@ -445,8 +445,8 @@ oscillator_handler (struct hw *me, void *data)\n   struct input_osc *osc = (struct input_osc*) data;\n   SIM_DESC sd;\n   sim_cpu *cpu;\n-  signed64 dt;\n-  uint8 val;\n+  int64_t dt;\n+  uint8_t val;\n \n   sd = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n@@ -593,10 +593,10 @@ static void\n m68hc11_info (struct hw *me)\n {\n   SIM_DESC sd;\n-  uint16 base = 0;\n+  uint16_t base = 0;\n   sim_cpu *cpu;\n   struct m68hc11sio *controller;\n-  uint8 val;\n+  uint8_t val;\n   \n   sd = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n@@ -634,8 +634,8 @@ m68hc11_info (struct hw *me)\n   val = cpu->ios[M6811_INIT];\n   print_io_byte (sd, \"INIT  \", 0, val, base + M6811_INIT);\n   sim_io_printf (sd, \"Ram = 0x%04x IO = 0x%04x\\n\",\n-\t\t (((uint16) (val & 0xF0)) << 8),\n-\t\t (((uint16) (val & 0x0F)) << 12));\n+\t\t (((uint16_t) (val & 0xF0)) << 8),\n+\t\t (((uint16_t) (val & 0x0F)) << 12));\n \n \n   cpu_info (sd, cpu);\n@@ -662,7 +662,7 @@ m68hc11_ioctl (struct hw *me,\n    stops.  */\n int\n m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,\n-                           double ton, double toff, signed64 repeat)\n+                           double ton, double toff, int64_t repeat)\n {\n   sim_cpu *cpu;\n   struct input_osc *osc;\n@@ -677,13 +677,13 @@ m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,\n \n   /* Compute the ON time in cpu cycles.  */\n   f = (double) (cpu->cpu_frequency) * ton;\n-  osc->on_time = (signed64) (f / 4.0);\n+  osc->on_time = (int64_t) (f / 4.0);\n   if (osc->on_time < 1)\n     osc->on_time = 1;\n \n   /* Compute the OFF time in cpu cycles.  */\n   f = (double) (cpu->cpu_frequency) * toff;\n-  osc->off_time = (signed64) (f / 4.0);\n+  osc->off_time = (int64_t) (f / 4.0);\n   if (osc->off_time < 1)\n     osc->off_time = 1;\n \n@@ -777,7 +777,7 @@ m68hc11_option_handler (SIM_DESC sd, sim_cpu *cpu,\n     case OPTION_OSC_INFO:\n       for (i = 0; i < controller->last_oscillator; i++)\n         {\n-          signed64 t;\n+          int64_t t;\n           struct input_osc *osc;\n \n           osc = &controller->oscillators[i];\n@@ -878,10 +878,10 @@ m68hc11cpu_io_read_buffer (struct hw *me,\n \n void\n m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,\n-                     unsigned addr, uint8 val)\n+                     unsigned addr, uint8_t val)\n {\n-  uint8 mask;\n-  uint8 delta;\n+  uint8_t mask;\n+  uint8_t delta;\n   int check_interrupts = 0;\n   int i;\n   \n@@ -925,11 +925,11 @@ m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,\n       /* Scan IC3, IC2 and IC1.  Bit number is 3 - i.  */\n       for (i = 0; i < 3; i++)\n         {\n-          uint8 mask = (1 << i);\n+          uint8_t mask = (1 << i);\n           \n           if (delta & mask)\n             {\n-              uint8 edge;\n+              uint8_t edge;\n               int captured;\n \n               edge = cpu->ios[M6811_TCTL2];\n@@ -983,7 +983,7 @@ m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,\n \n static void\n m68hc11cpu_io_write (struct hw *me, sim_cpu *cpu,\n-                     unsigned_word addr, uint8 val)\n+                     unsigned_word addr, uint8_t val)\n {\n   switch (addr)\n     {\n@@ -1022,7 +1022,7 @@ m68hc11cpu_io_write (struct hw *me, sim_cpu *cpu,\n       /* Change the RAM and I/O mapping.  */\n     case M6811_INIT:\n       {\n-\tuint8 old_bank = cpu->ios[M6811_INIT];\n+\tuint8_t old_bank = cpu->ios[M6811_INIT];\n \t\n \tcpu->ios[M6811_INIT] = val;\n \n@@ -1111,11 +1111,11 @@ m68hc11cpu_io_write_buffer (struct hw *me,\n   byte = 0;\n   while (nr_bytes)\n     {\n-      uint8 val;\n+      uint8_t val;\n       if (base >= controller->attach_size)\n \tbreak;\n \n-      val = *((uint8*) source);\n+      val = *((uint8_t*) source);\n       m68hc11cpu_io_write (me, cpu, base, val);\n       source = (char*) source + 1;\n       base++;"
    },
    {
      "sha": "6d620e474e891ec79651a32ce8eab7b030ca10d3",
      "filename": "sim/m68hc11/dv-m68hc11eepr.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11eepr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11eepr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-m68hc11eepr.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -112,11 +112,11 @@ struct m68hc11eepr\n      located at the end of the EEPROM (eeprom size + 1).  It is not mapped\n      in memory but it's saved in the EEPROM file.  */\n   unsigned long\t\teeprom_wcycle;\n-  uint16\t\teeprom_waddr;\n-  uint8\t\t\teeprom_wbyte;\n-  uint8\t\t\teeprom_wmode;\n+  uint16_t\t\teeprom_waddr;\n+  uint8_t\t\t\teeprom_wbyte;\n+  uint8_t\t\t\teeprom_wmode;\n \n-  uint8*\t\teeprom;\n+  uint8_t*\t\teeprom;\n   \n   /* Minimum time in CPU cycles for programming the EEPROM.  */\n   unsigned long         eeprom_min_cycles;\n@@ -339,10 +339,10 @@ static void\n m68hc11eepr_info (struct hw *me)\n {\n   SIM_DESC sd;\n-  uint16 base = 0;\n+  uint16_t base = 0;\n   sim_cpu *cpu;\n   struct m68hc11eepr *controller;\n-  uint8 val;\n+  uint8_t val;\n   \n   sd         = hw_system (me);\n   cpu        = STATE_CPU (sd, 0);\n@@ -418,13 +418,13 @@ m68hc11eepr_io_read_buffer (struct hw *me,\n             {\n             case M6811_PPROG:\n             case M6811_CONFIG:\n-              *((uint8*) dest) = cpu->ios[base];\n+              *((uint8_t*) dest) = cpu->ios[base];\n               break;\n \n             default:\n               hw_abort (me, \"reading wrong register 0x%04x\", base);\n             }\n-          dest = (uint8*) (dest) + 1;\n+          dest = (uint8_t*) (dest) + 1;\n           base++;\n           nr_bytes--;\n           cnt++;\n@@ -456,7 +456,7 @@ m68hc11eepr_io_write_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11eepr *controller;\n   sim_cpu *cpu;\n-  uint8 val;\n+  uint8_t val;\n \n   HW_TRACE ((me, \"write 0x%08lx %d\", (long) base, (int) nr_bytes));\n \n@@ -475,13 +475,13 @@ m68hc11eepr_io_write_buffer (struct hw *me,\n   if (nr_bytes != 1)\n     hw_abort (me, \"Cannot write more than 1 byte to EEPROM device at a time\");\n \n-  val = *((const uint8*) source);\n+  val = *((const uint8_t*) source);\n \n   /* Write to the EEPROM control register.  */\n   if (space == io_map && base == M6811_PPROG)\n     {\n-      uint8 wrong_bits;\n-      uint16 addr;\n+      uint8_t wrong_bits;\n+      uint16_t addr;\n       \n       addr = base + cpu_get_io_base (cpu);\n "
    },
    {
      "sha": "82629713b97ed463cdeaf9ee6b589ab77b384b2f",
      "filename": "sim/m68hc11/dv-m68hc11sio.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11sio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11sio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-m68hc11sio.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -184,7 +184,7 @@ m68hc11sio_port_event (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11sio *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n   \n   controller = hw_data (me);\n   sd         = hw_system (me);\n@@ -421,10 +421,10 @@ static void\n m68hc11sio_info (struct hw *me)\n {\n   SIM_DESC sd;\n-  uint16 base = 0;\n+  uint16_t base = 0;\n   sim_cpu *cpu;\n   struct m68hc11sio *controller;\n-  uint8 val;\n+  uint8_t val;\n   long clock_cycle;\n   \n   sd = hw_system (me);\n@@ -457,7 +457,7 @@ m68hc11sio_info (struct hw *me)\n   \n   if (controller->tx_poll_event)\n     {\n-      signed64 t;\n+      int64_t t;\n       int n;\n \n       t = hw_event_remain_time (me, controller->tx_poll_event);\n@@ -469,7 +469,7 @@ m68hc11sio_info (struct hw *me)\n     }\n   if (controller->rx_poll_event)\n     {\n-      signed64 t;\n+      int64_t t;\n \n       t = hw_event_remain_time (me, controller->rx_poll_event);\n       sim_io_printf (sd, \"  Receive finished in %s\\n\",\n@@ -499,7 +499,7 @@ m68hc11sio_io_read_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11sio *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n   \n   HW_TRACE ((me, \"read 0x%08lx %d\", (long) base, (int) nr_bytes));\n \n@@ -530,7 +530,7 @@ m68hc11sio_io_read_buffer (struct hw *me,\n     default:\n       return 0;\n     }\n-  *((unsigned8*) dest) = val;\n+  *((uint8_t*) dest) = val;\n   return 1;\n }\n \n@@ -544,15 +544,15 @@ m68hc11sio_io_write_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11sio *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n \n   HW_TRACE ((me, \"write 0x%08lx %d\", (long) base, (int) nr_bytes));\n \n   sd  = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n   controller = hw_data (me);\n   \n-  val = *((const unsigned8*) source);\n+  val = *((const uint8_t*) source);\n   switch (base)\n     {\n     case M6811_BAUD:"
    },
    {
      "sha": "d587411692a574b1c1e9ecf31f5637e66e74eb95",
      "filename": "sim/m68hc11/dv-m68hc11spi.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11spi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11spi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-m68hc11spi.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -159,7 +159,7 @@ m68hc11spi_port_event (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11spi *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n   \n   controller = hw_data (me);\n   sd         = hw_system (me);\n@@ -193,7 +193,7 @@ m68hc11spi_port_event (struct hw *me,\n static void\n set_bit_port (struct hw *me, sim_cpu *cpu, int port, int mask, int value)\n {\n-  uint8 val;\n+  uint8_t val;\n   \n   if (value)\n     val = cpu->ios[port] | mask;\n@@ -330,10 +330,10 @@ static void\n m68hc11spi_info (struct hw *me)\n {\n   SIM_DESC sd;\n-  uint16 base = 0;\n+  uint16_t base = 0;\n   sim_cpu *cpu;\n   struct m68hc11spi *controller;\n-  uint8 val;\n+  uint8_t val;\n   \n   sd = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n@@ -353,7 +353,7 @@ m68hc11spi_info (struct hw *me)\n \n   if (controller->spi_event)\n     {\n-      signed64 t;\n+      int64_t t;\n \n       sim_io_printf (sd, \"  SPI has %d bits to send\\n\",\n                      controller->tx_bit + 1);\n@@ -388,7 +388,7 @@ m68hc11spi_io_read_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11spi *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n   \n   HW_TRACE ((me, \"read 0x%08lx %d\", (long) base, (int) nr_bytes));\n \n@@ -419,7 +419,7 @@ m68hc11spi_io_read_buffer (struct hw *me,\n     default:\n       return 0;\n     }\n-  *((unsigned8*) dest) = val;\n+  *((uint8_t*) dest) = val;\n   return 1;\n }\n \n@@ -433,15 +433,15 @@ m68hc11spi_io_write_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11spi *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n \n   HW_TRACE ((me, \"write 0x%08lx %d\", (long) base, (int) nr_bytes));\n \n   sd  = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n   controller = hw_data (me);\n   \n-  val = *((const unsigned8*) source);\n+  val = *((const uint8_t*) source);\n   switch (base)\n     {\n     case M6811_SPCR:"
    },
    {
      "sha": "a2a6603e79a31599a59e958a272c247b2362dce9",
      "filename": "sim/m68hc11/dv-m68hc11tim.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11tim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-m68hc11tim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-m68hc11tim.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -84,10 +84,10 @@ struct m68hc11tim\n   unsigned long cop_delay;\n   unsigned long rti_delay;\n   unsigned long ovf_delay;\n-  signed64      clock_prescaler;\n-  signed64      tcnt_adjust;\n-  signed64      cop_prev_interrupt;\n-  signed64      rti_prev_interrupt;\n+  int64_t      clock_prescaler;\n+  int64_t      tcnt_adjust;\n+  int64_t      cop_prev_interrupt;\n+  int64_t      rti_prev_interrupt;\n \n   /* Periodic timers.  */\n   struct hw_event *rti_timer_event;\n@@ -158,8 +158,8 @@ m68hc11tim_port_event (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11tim *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n-  unsigned16 tcnt;\n+  uint8_t val;\n+  uint16_t tcnt;\n \n   controller = hw_data (me);\n   sd         = hw_system (me);\n@@ -207,7 +207,7 @@ m68hc11tim_port_event (struct hw *me,\n       }\n \n     case CAPTURE:\n-      tcnt = (uint16) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n+      tcnt = (uint16_t) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n                        / controller->clock_prescaler);\n       switch (level)\n         {\n@@ -252,8 +252,8 @@ m68hc11tim_timer_event (struct hw *me, void *data)\n   unsigned flags;\n   unsigned long tcnt_internal;\n   unsigned long tcnt, tcnt_prev;\n-  signed64 tcnt_insn_end;\n-  signed64 tcnt_insn_start;\n+  int64_t tcnt_insn_end;\n+  int64_t tcnt_insn_start;\n   int i;\n   sim_events *events;\n   \n@@ -471,13 +471,13 @@ io_reg_desc pactl_desc[] = {\n };\n \n static double\n-to_realtime (sim_cpu *cpu, signed64 t)\n+to_realtime (sim_cpu *cpu, int64_t t)\n {\n   return (double) (t) / (double) (cpu->cpu_frequency / 4);\n }\n \n const char*\n-cycle_to_string (sim_cpu *cpu, signed64 t, int flags)\n+cycle_to_string (sim_cpu *cpu, int64_t t, int flags)\n {\n   char time_buf[32];\n   char cycle_buf[32];\n@@ -520,7 +520,7 @@ m68hc11tim_print_timer (struct hw *me, const char *name,\n     }\n   else\n     {\n-      signed64 t;\n+      int64_t t;\n       sim_cpu *cpu;\n \n       cpu = STATE_CPU (sd, 0);\n@@ -535,11 +535,11 @@ static void\n m68hc11tim_info (struct hw *me)\n {\n   SIM_DESC sd;\n-  uint16 base = 0;\n+  uint16_t base = 0;\n   sim_cpu *cpu;\n   struct m68hc11tim *controller;\n-  uint8 val;\n-  uint16 val16;\n+  uint8_t val;\n+  uint16_t val16;\n   \n   sd = hw_system (me);\n   cpu = STATE_CPU (sd, 0);\n@@ -643,7 +643,7 @@ m68hc11tim_io_read_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11tim *controller;\n   sim_cpu *cpu;\n-  unsigned8 val;\n+  uint8_t val;\n   unsigned cnt = 0;\n   \n   HW_TRACE ((me, \"read 0x%08lx %d\", (long) base, (int) nr_bytes));\n@@ -660,20 +660,20 @@ m68hc11tim_io_read_buffer (struct hw *me,\n              Reading in a 16-bit register will be split in two accesses\n              but this will be atomic within the simulator.  */\n         case M6811_TCTN_H:\n-          val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n+          val = (uint8_t) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n                          / (controller->clock_prescaler * 256));\n           break;\n \n         case M6811_TCTN_L:\n-          val = (uint8) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n+          val = (uint8_t) ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n                          / controller->clock_prescaler);\n           break;\n \n         default:\n           val = cpu->ios[base];\n           break;\n         }\n-      *((unsigned8*) dest) = val;\n+      *((uint8_t*) dest) = val;\n       dest = (char*) dest + 1;\n       base++;\n       nr_bytes--;\n@@ -692,8 +692,8 @@ m68hc11tim_io_write_buffer (struct hw *me,\n   SIM_DESC sd;\n   struct m68hc11tim *controller;\n   sim_cpu *cpu;\n-  unsigned8 val, n;\n-  signed64 adj;\n+  uint8_t val, n;\n+  int64_t adj;\n   int reset_compare = 0;\n   int reset_overflow = 0;\n   int cnt = 0;\n@@ -706,7 +706,7 @@ m68hc11tim_io_write_buffer (struct hw *me,\n \n   while (nr_bytes)\n     {\n-      val = *((const unsigned8*) source);\n+      val = *((const uint8_t*) source);\n       switch (base)\n         {\n           /* Set the timer counter low part, trying to preserve the low part.\n@@ -715,10 +715,10 @@ m68hc11tim_io_write_buffer (struct hw *me,\n              in 64-bit to avoid overflow problems.  */\n         case M6811_TCTN_L:\n           adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n-                 / (controller->clock_prescaler * (signed64) 256)) & 0x0FF;\n+                 / (controller->clock_prescaler * (int64_t) 256)) & 0x0FF;\n           adj = cpu->cpu_absolute_cycle\n-            - (adj * controller->clock_prescaler * (signed64) 256)\n-            - ((signed64) adj * controller->clock_prescaler);\n+            - (adj * controller->clock_prescaler * (int64_t) 256)\n+            - ((int64_t) adj * controller->clock_prescaler);\n           controller->tcnt_adjust = adj;\n           reset_compare = 1;\n           reset_overflow = 1;\n@@ -728,7 +728,7 @@ m68hc11tim_io_write_buffer (struct hw *me,\n           adj = ((cpu->cpu_absolute_cycle - controller->tcnt_adjust)\n                  / controller->clock_prescaler) & 0x0ff;\n           adj = cpu->cpu_absolute_cycle\n-            - ((signed64) val * controller->clock_prescaler * (signed64) 256)\n+            - ((int64_t) val * controller->clock_prescaler * (int64_t) 256)\n             - (adj * controller->clock_prescaler);\n           controller->tcnt_adjust = adj;\n           reset_compare = 1;"
    },
    {
      "sha": "f02160833047a8d6cdab68b4022033dbfba80978",
      "filename": "sim/m68hc11/dv-nvram.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-nvram.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/dv-nvram.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/dv-nvram.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -106,7 +106,7 @@ struct nvram\n {\n   address_word    base_address; /* Base address of ram.  */\n   unsigned        size;         /* Size of ram.  */\n-  unsigned8       *data;        /* Pointer to ram memory.  */\n+  uint8_t       *data;        /* Pointer to ram memory.  */\n   const char      *file_name;   /* Path of ram file.  */\n   int             fd;           /* File description of opened ram file.  */\n   enum nvram_mode mode;         /* How load/save ram file.  */"
    },
    {
      "sha": "b66117503c1d558c742d3af52615555b1a9a6fba",
      "filename": "sim/m68hc11/emulos.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/emulos.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/emulos.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/emulos.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -107,7 +107,7 @@ emul_write (sim_cpu *cpu)\n   cpu->cpu_running = 0;\n   while (size)\n     {\n-      uint8 val = memory_read8 (cpu, addr);\n+      uint8_t val = memory_read8 (cpu, addr);\n \n       if (write (0, &val, 1) != 1)\n \tprintf (\"write failed: %s\\n\", strerror (errno));"
    },
    {
      "sha": "fcc4b05b6ac54877cdf336c32fb01986698c39e3",
      "filename": "sim/m68hc11/gencode.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/gencode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/gencode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/gencode.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -134,7 +134,7 @@ struct m6811_opcode_pattern m6811_opcode_patterns[] = {\n   { \"rts11\",  \"addr = cpu_m68hc11_pop_uint16 (cpu); cpu_set_pc (cpu, addr); cpu_return (cpu)\" },\n   { \"rts12\",  \"addr = cpu_m68hc12_pop_uint16 (cpu); cpu_set_pc (cpu, addr); cpu_return (cpu)\" },\n \n-  { \"mul16\", \"dst16 = ((uint16) src8 & 0x0FF) * ((uint16) dst8 & 0x0FF)\",\n+  { \"mul16\", \"dst16 = ((uint16_t) src8 & 0x0FF) * ((uint16_t) dst8 & 0x0FF)\",\n     \"cpu_set_ccr_C (cpu, src8 & 0x80)\" },\n   { \"neg8\", \"dst8 = - src8\",\n     \"cpu_set_ccr_C (cpu, src8 == 0); cpu_ccr_update_tst8 (cpu, dst8)\" },\n@@ -227,7 +227,7 @@ dst16 = dst16 + src16\", 0 },\n   { \"txys16\", \"dst16 = src16 - 1;\"},\n \n   /* Add b to X or Y with an unsigned extension 8->16.\tFlags not changed.  */\n-  { \"abxy16\",\"dst16 = dst16 + (uint16) src8\"},\n+  { \"abxy16\",\"dst16 = dst16 + (uint16_t) src8\"},\n \n   /* After 'daa', the Z flag is undefined. Mark it as changed.\t*/\n   { \"daa8\",  \"cpu_special (cpu, M6811_DAA)\" },\n@@ -256,8 +256,8 @@ cpu_set_ccr_V (cpu, 1);\\n\\\n cpu_set_ccr_C (cpu, dst16 == 0);\\n\\\n }\\nelse\\n{\\n\\\n unsigned long l = (unsigned long) (dst16) << 16;\\n\\\n-cpu_set_d (cpu, (uint16) (l % (unsigned long) (src16)));\\n\\\n-dst16 = (uint16) (l / (unsigned long) (src16));\\n\\\n+cpu_set_d (cpu, (uint16_t) (l % (unsigned long) (src16)));\\n\\\n+dst16 = (uint16_t) (l / (unsigned long) (src16));\\n\\\n cpu_set_ccr_V (cpu, 0);\\n\\\n cpu_set_ccr_C (cpu, 0);\\n\\\n cpu_set_ccr_Z (cpu, dst16 == 0);\\n\\\n@@ -289,8 +289,8 @@ cpu_set_ccr_Z (cpu, dst16 == 0);\\n\\\n   { \"call_ind\", \"cpu_special (cpu, M6812_CALL_INDIRECT)\" },\n   { \"dbcc8\", \"cpu_dbcc (cpu)\" },\n   { \"ediv\",  \"cpu_special (cpu, M6812_EDIV)\" },\n-  { \"emul\",  \"{ uint32 src1 = (uint32) cpu_get_d (cpu);\\\n-  uint32 src2 = (uint32) cpu_get_y (cpu);\\\n+  { \"emul\",  \"{ uint32_t src1 = (uint32_t) cpu_get_d (cpu);\\\n+  uint32_t src2 = (uint32_t) cpu_get_y (cpu);\\\n   src1 *= src2;\\\n   cpu_set_d (cpu, src1);\\\n   cpu_set_y (cpu, src1 >> 16);\\\n@@ -1284,9 +1284,9 @@ print (FILE *fp, int col, const char *msg, ...)\n    -\tEnd of input operands.\n   \n    Example:\n-       (x),a->a\t      addr = x + (uint16) (fetch8 (cpu));\n+       (x),a->a\t      addr = x + (uint16_t) (fetch8 (cpu));\n \t\t      src8 = a\n-       *,#,r\t      addr = (uint16) (fetch8 (cpu))  <- Temporary 'addr'\n+       *,#,r\t      addr = (uint16_t) (fetch8 (cpu))  <- Temporary 'addr'\n \t\t      src8 = read_mem8 (cpu, addr)\n \t\t      dst8 = fetch8 (cpu)\n \t\t      addr = fetch_relbranch (cpu)    <- Final 'addr'\n@@ -1357,7 +1357,7 @@ gen_fetch_operands (FILE *fp, int col,\n \t  \n \t  addr_set = 1;\n \t  current_insn_size += 1;\n-\t  print (fp, col, \"addr = (uint16) cpu_fetch8 (cpu);\");\n+\t  print (fp, col, \"addr = (uint16_t) cpu_fetch8 (cpu);\");\n \t  print (fp, col, \"%s%s = memory_read%s (cpu, addr);\",\n \t\t vars[cur_var], operand_size, operand_size);\n \t  break;\n@@ -1370,13 +1370,13 @@ gen_fetch_operands (FILE *fp, int col,\n \t  if (strncmp (operands, \"(x)\", 3) == 0)\n \t    {\n \t      current_insn_size += 1;\n-\t      print (fp, col, \"addr = cpu_get_x (cpu) + (uint16) cpu_fetch8 (cpu);\");\n+\t      print (fp, col, \"addr = cpu_get_x (cpu) + (uint16_t) cpu_fetch8 (cpu);\");\n \t      operands += 3;\n \t    }\n \t  else if (strncmp (operands, \"(y)\", 3) == 0)\n \t    {\n \t      current_insn_size += 1;\n-\t      print (fp, col, \"addr = cpu_get_y (cpu) + (uint16) cpu_fetch8 (cpu);\");\n+\t      print (fp, col, \"addr = cpu_get_y (cpu) + (uint16_t) cpu_fetch8 (cpu);\");\n \t      operands += 3;\n \t    }\n \t  else if (strncmp (operands, \"()\", 2) == 0)\n@@ -1408,7 +1408,7 @@ gen_fetch_operands (FILE *fp, int col,\n \t    {\n \t      addr_set = 1;\n \t      current_insn_size += 1;\n-\t      print (fp, col, \"addr = cpu_get_x (cpu) + (uint16) cpu_fetch8 (cpu);\");\n+\t      print (fp, col, \"addr = cpu_get_x (cpu) + (uint16_t) cpu_fetch8 (cpu);\");\n \t      print (fp, col, \"%s%s = memory_read%s (cpu, addr);\",\n \t\t     vars[cur_var], operand_size, operand_size);\n \t      operands += 2;\n@@ -1417,7 +1417,7 @@ gen_fetch_operands (FILE *fp, int col,\n \t    {\n \t      addr_set = 1;\n \t      current_insn_size += 1;\n-\t      print (fp, col, \"addr = cpu_get_y (cpu) + (uint16) cpu_fetch8 (cpu);\");\n+\t      print (fp, col, \"addr = cpu_get_y (cpu) + (uint16_t) cpu_fetch8 (cpu);\");\n \t      print (fp, col, \"%s%s = memory_read%s (cpu, addr);\",\n \t\t     vars[cur_var], operand_size, operand_size);\n \t      operands += 2;\n@@ -1668,7 +1668,7 @@ gen_save_result (FILE *fp, int col,\n       if (addr_set == 0)\n \t{\n \t  current_insn_size += 1;\n-\t  print (fp, col, \"addr = (uint16) cpu_fetch8 (cpu);\");\n+\t  print (fp, col, \"addr = (uint16_t) cpu_fetch8 (cpu);\");\n \t}\n       result_size = operand_size;\n       print (fp, col, \"memory_write%s (cpu, addr, dst%s);\",\n@@ -1995,11 +1995,11 @@ gen_function_entry (FILE *fp, const char *name, int locals)\n \n   /* Interpretor local variables.  */\n   print (fp, indent_level, \"unsigned char op;\");\n-  print (fp, indent_level, \"uint16 addr, src16, dst16;\");\n+  print (fp, indent_level, \"uint16_t addr, src16, dst16;\");\n   if (locals & USE_SRC8)\n-    print (fp, indent_level, \"uint8 src8;\\n\");\n+    print (fp, indent_level, \"uint8_t src8;\\n\");\n   if (locals & USE_DST8)\n-    print (fp, indent_level, \"uint8 dst8;\\n\");\n+    print (fp, indent_level, \"uint8_t dst8;\\n\");\n }\n \n void"
    },
    {
      "sha": "ab3c5a8e8619f99889cec7492c30b59e6d5c61e0",
      "filename": "sim/m68hc11/interp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/interp.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -533,7 +533,7 @@ sim_create_inferior (SIM_DESC sd, struct bfd *abfd,\n static int\n m68hc11_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n {\n-  uint16 val;\n+  uint16_t val;\n   int size = 2;\n \n   switch (rn)\n@@ -597,7 +597,7 @@ m68hc11_reg_fetch (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n static int\n m68hc11_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n {\n-  uint16 val;\n+  uint16_t val;\n \n   val = *memory++;\n   if (length == 2)"
    },
    {
      "sha": "4e2a16af53fd6b8acbfd5a94acd0a64fb49b258e",
      "filename": "sim/m68hc11/interrupts.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interrupts.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interrupts.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/interrupts.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -95,7 +95,7 @@ struct interrupt_def idefs[] = {\n #endif\n };\n \n-#define CYCLES_MAX ((((signed64) 1) << 62) - 1)\n+#define CYCLES_MAX ((((int64_t) 1) << 62) - 1)\n \n enum\n {\n@@ -174,7 +174,7 @@ interrupts_reset (struct interrupts *interrupts)\n   if (interrupts->cpu->cpu_mode == M6811_SMOD)\n     {\n       bfd_vma addr = interrupts->vectors_addr;\n-      uint16 vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);\n+      uint16_t vector = 0x0100 - 3 * (M6811_INT_NUMBER - 1);\n       for (i = 0; i < M6811_INT_NUMBER; i++)\n         {\n           memory_write16 (interrupts->cpu, addr, vector);\n@@ -285,7 +285,7 @@ void\n interrupts_update_pending (struct interrupts *interrupts)\n {\n   int i;\n-  uint8 *ioregs;\n+  uint8_t *ioregs;\n   unsigned long clear_mask;\n   unsigned long set_mask;\n \n@@ -296,7 +296,7 @@ interrupts_update_pending (struct interrupts *interrupts)\n   for (i = 0; i < ARRAY_SIZE (idefs); i++)\n     {\n       struct interrupt_def *idef = &idefs[i];\n-      uint8 data;\n+      uint8_t data;\n       \n       /* Look if the interrupt is enabled.  */\n       if (idef->enable_paddr)\n@@ -332,7 +332,7 @@ interrupts_update_pending (struct interrupts *interrupts)\n      Also implements the breakpoint-on-interrupt.  */\n   if (set_mask)\n     {\n-      signed64 cycle = cpu_current_cycle (interrupts->cpu);\n+      int64_t cycle = cpu_current_cycle (interrupts->cpu);\n       int must_stop = 0;\n       \n       for (i = 0; i < M6811_INT_NUMBER; i++)\n@@ -427,7 +427,7 @@ int\n interrupts_process (struct interrupts *interrupts)\n {\n   int id;\n-  uint8 ccr;\n+  uint8_t ccr;\n \n   /* See if interrupts are enabled/disabled and keep track of the\n      number of cycles the interrupts are masked.  Such information is\n@@ -441,7 +441,7 @@ interrupts_process (struct interrupts *interrupts)\n   else if (interrupts->start_mask_cycle >= 0\n            && (ccr & M6811_I_BIT) == 0)\n     {\n-      signed64 t = cpu_current_cycle (interrupts->cpu);\n+      int64_t t = cpu_current_cycle (interrupts->cpu);\n \n       t -= interrupts->start_mask_cycle;\n       if (t < interrupts->min_mask_cycles)\n@@ -460,7 +460,7 @@ interrupts_process (struct interrupts *interrupts)\n   else if (interrupts->xirq_start_mask_cycle >= 0\n            && (ccr & M6811_X_BIT) == 0)\n     {\n-      signed64 t = cpu_current_cycle (interrupts->cpu);\n+      int64_t t = cpu_current_cycle (interrupts->cpu);\n \n       t -= interrupts->xirq_start_mask_cycle;\n       if (t < interrupts->xirq_min_mask_cycles)\n@@ -474,7 +474,7 @@ interrupts_process (struct interrupts *interrupts)\n   id = interrupts_get_current (interrupts);\n   if (id >= 0)\n     {\n-      uint16 addr;\n+      uint16_t addr;\n       struct interrupt_history *h;\n \n       /* Implement the breakpoint-on-interrupt.  */\n@@ -533,7 +533,7 @@ interrupts_raise (struct interrupts *interrupts, enum M6811_INT number)\n void\n interrupts_info (SIM_DESC sd, struct interrupts *interrupts)\n {\n-  signed64 t, prev_interrupt;\n+  int64_t t, prev_interrupt;\n   int i;\n   \n   sim_io_printf (sd, \"Interrupts Info:\\n\");\n@@ -621,7 +621,7 @@ interrupts_info (SIM_DESC sd, struct interrupts *interrupts)\n     {\n       int which;\n       struct interrupt_history *h;\n-      signed64 dt;\n+      int64_t dt;\n \n       which = interrupts->history_index - i - 1;\n       if (which < 0)"
    },
    {
      "sha": "d66fefbbb3f4592e588e17cb57459de1419cb8e3",
      "filename": "sim/m68hc11/interrupts.h",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interrupts.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/interrupts.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/interrupts.h?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -88,10 +88,10 @@ struct interrupt_history\n   enum M6811_INT   type;\n \n   /* CPU cycle when interrupt handler is called.  */\n-  signed64         taken_cycle;   \n+  int64_t         taken_cycle;   \n \n   /* CPU cycle when the interrupt is first raised by the device.  */\n-  signed64         raised_cycle;\n+  int64_t         raised_cycle;\n };\n \n #define SIM_STOP_WHEN_RAISED 1\n@@ -101,7 +101,7 @@ struct interrupt_history\n struct interrupt\n {\n   /* CPU cycle when the interrupt is raised by the device.  */\n-  signed64         cpu_cycle;\n+  int64_t         cpu_cycle;\n \n   /* Number of times the interrupt was raised.  */\n   unsigned long    raised_count;\n@@ -129,7 +129,7 @@ struct interrupts {\n \n   /* Address of vector table.  This is set depending on the\n      68hc11 init mode.  */\n-  uint16            vectors_addr;\n+  uint16_t            vectors_addr;\n \n   /* Priority order of interrupts.  This is controlled by setting the HPRIO\n      IO register.  */\n@@ -139,16 +139,16 @@ struct interrupts {\n   /* Simulator statistics to report useful debug information to users.  */\n \n   /* - Max/Min number of CPU cycles executed with interrupts masked.  */\n-  signed64          start_mask_cycle;\n-  signed64          min_mask_cycles;\n-  signed64          max_mask_cycles;\n-  signed64          last_mask_cycles;\n+  int64_t          start_mask_cycle;\n+  int64_t          min_mask_cycles;\n+  int64_t          max_mask_cycles;\n+  int64_t          last_mask_cycles;\n \n   /* - Same for XIRQ.  */\n-  signed64          xirq_start_mask_cycle;\n-  signed64          xirq_min_mask_cycles;\n-  signed64          xirq_max_mask_cycles;\n-  signed64          xirq_last_mask_cycles;\n+  int64_t          xirq_start_mask_cycle;\n+  int64_t          xirq_min_mask_cycles;\n+  int64_t          xirq_max_mask_cycles;\n+  int64_t          xirq_last_mask_cycles;\n \n   /* - Total number of interrupts raised.  */\n   unsigned long     nb_interrupts_raised;"
    },
    {
      "sha": "6ec45f7820627dee933dca5c1466d0b506f4d88e",
      "filename": "sim/m68hc11/m68hc11_sim.c",
      "status": "modified",
      "additions": 68,
      "deletions": 68,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/m68hc11_sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/m68hc11_sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/m68hc11_sim.c?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -101,7 +101,7 @@ cpu_option_handler (SIM_DESC sd, sim_cpu *cpu,\n \n     \n void\n-cpu_call (sim_cpu *cpu, uint16 addr)\n+cpu_call (sim_cpu *cpu, uint16_t addr)\n {\n \n   cpu_set_pc (cpu, addr);\n@@ -114,13 +114,13 @@ cpu_return (sim_cpu *cpu)\n \n /* Set the stack pointer and re-compute the current frame.  */\n void\n-cpu_set_sp (sim_cpu *cpu, uint16 val)\n+cpu_set_sp (sim_cpu *cpu, uint16_t val)\n {\n   cpu->cpu_regs.sp = val;\n }\n \n-static uint16\n-cpu_get_reg (sim_cpu *cpu, uint8 reg)\n+static uint16_t\n+cpu_get_reg (sim_cpu *cpu, uint8_t reg)\n {\n   switch (reg)\n     {\n@@ -141,8 +141,8 @@ cpu_get_reg (sim_cpu *cpu, uint8 reg)\n     }\n }\n \n-static uint16\n-cpu_get_src_reg (sim_cpu *cpu, uint8 reg)\n+static uint16_t\n+cpu_get_src_reg (sim_cpu *cpu, uint8_t reg)\n {\n   switch (reg)\n     {\n@@ -176,7 +176,7 @@ cpu_get_src_reg (sim_cpu *cpu, uint8 reg)\n }\n \n static void\n-cpu_set_dst_reg (sim_cpu *cpu, uint8 reg, uint16 val)\n+cpu_set_dst_reg (sim_cpu *cpu, uint8_t reg, uint16_t val)\n {\n   switch (reg)\n     {\n@@ -218,7 +218,7 @@ cpu_set_dst_reg (sim_cpu *cpu, uint8 reg, uint16 val)\n }\n \n static void\n-cpu_set_reg (sim_cpu *cpu, uint8 reg, uint16 val)\n+cpu_set_reg (sim_cpu *cpu, uint8_t reg, uint16_t val)\n {\n   switch (reg)\n     {\n@@ -245,13 +245,13 @@ cpu_set_reg (sim_cpu *cpu, uint8 reg, uint16 val)\n \n /* Returns the address of a 68HC12 indexed operand.\n    Pre and post modifications are handled on the source register.  */\n-uint16\n+uint16_t\n cpu_get_indexed_operand_addr (sim_cpu *cpu, int restricted)\n {\n-  uint8 reg;\n-  uint16 sval;\n-  uint16 addr;\n-  uint8 code;\n+  uint8_t reg;\n+  uint16_t sval;\n+  uint16_t addr;\n+  uint8_t code;\n \n   code = cpu_fetch8 (cpu);\n \n@@ -350,29 +350,29 @@ cpu_get_indexed_operand_addr (sim_cpu *cpu, int restricted)\n   return addr;\n }\n \n-static uint8\n+static uint8_t\n cpu_get_indexed_operand8 (sim_cpu *cpu, int restricted)\n {\n-  uint16 addr;\n+  uint16_t addr;\n \n   addr = cpu_get_indexed_operand_addr (cpu, restricted);\n   return memory_read8 (cpu, addr);\n }\n \n-static uint16\n+static uint16_t\n cpu_get_indexed_operand16 (sim_cpu *cpu, int restricted)\n {\n-  uint16 addr;\n+  uint16_t addr;\n \n   addr = cpu_get_indexed_operand_addr (cpu, restricted);\n   return memory_read16 (cpu, addr);\n }\n \n void\n-cpu_move8 (sim_cpu *cpu, uint8 code)\n+cpu_move8 (sim_cpu *cpu, uint8_t code)\n {\n-  uint8 src;\n-  uint16 addr;\n+  uint8_t src;\n+  uint16_t addr;\n \n   switch (code)\n     {\n@@ -416,10 +416,10 @@ cpu_move8 (sim_cpu *cpu, uint8 code)\n }\n \n void\n-cpu_move16 (sim_cpu *cpu, uint8 code)\n+cpu_move16 (sim_cpu *cpu, uint8_t code)\n {\n-  uint16 src;\n-  uint16 addr;\n+  uint16_t src;\n+  uint16_t addr;\n \n   switch (code)\n     {\n@@ -530,7 +530,7 @@ cpu_reset (sim_cpu *cpu)\n int\n cpu_restart (sim_cpu *cpu)\n {\n-  uint16 addr;\n+  uint16_t addr;\n \n   /* Get CPU starting address depending on the CPU mode.  */\n   if (cpu->cpu_use_elf_start == 0)\n@@ -591,7 +591,7 @@ print_io_reg_desc (SIM_DESC sd, io_reg_desc *desc, int val, int mode)\n \n void\n print_io_byte (SIM_DESC sd, const char *name, io_reg_desc *desc,\n-\t       uint8 val, uint16 addr)\n+\t       uint8_t val, uint16_t addr)\n {\n   sim_io_printf (sd, \"  %-9.9s @ 0x%04x 0x%02x \", name, addr, val);\n   if (desc)\n@@ -600,26 +600,26 @@ print_io_byte (SIM_DESC sd, const char *name, io_reg_desc *desc,\n \n void\n print_io_word (SIM_DESC sd, const char *name, io_reg_desc *desc,\n-\t       uint16 val, uint16 addr)\n+\t       uint16_t val, uint16_t addr)\n {\n   sim_io_printf (sd, \"  %-9.9s @ 0x%04x 0x%04x \", name, addr, val);\n   if (desc)\n     print_io_reg_desc (sd, desc, val, 0);\n }\n \n void\n-cpu_ccr_update_tst8 (sim_cpu *cpu, uint8 val)\n+cpu_ccr_update_tst8 (sim_cpu *cpu, uint8_t val)\n {\n   cpu_set_ccr_V (cpu, 0);\n   cpu_set_ccr_N (cpu, val & 0x80 ? 1 : 0);\n   cpu_set_ccr_Z (cpu, val == 0 ? 1 : 0);\n }\n \n \n-uint16\n+uint16_t\n cpu_fetch_relbranch (sim_cpu *cpu)\n {\n-  uint16 addr = (uint16) cpu_fetch8 (cpu);\n+  uint16_t addr = (uint16_t) cpu_fetch8 (cpu);\n \n   if (addr & 0x0080)\n     {\n@@ -629,10 +629,10 @@ cpu_fetch_relbranch (sim_cpu *cpu)\n   return addr;\n }\n \n-uint16\n+uint16_t\n cpu_fetch_relbranch16 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu_fetch16 (cpu);\n+  uint16_t addr = cpu_fetch16 (cpu);\n \n   addr += cpu->cpu_regs.pc;\n   return addr;\n@@ -664,10 +664,10 @@ cpu_push_all (sim_cpu *cpu)\n void\n cpu_dbcc (sim_cpu *cpu)\n {\n-  uint8 code;\n-  uint16 addr;\n-  uint16 inc;\n-  uint16 reg;\n+  uint8_t code;\n+  uint16_t addr;\n+  uint16_t inc;\n+  uint16_t reg;\n   \n   code = cpu_fetch8 (cpu);\n   switch (code & 0xc0)\n@@ -703,11 +703,11 @@ cpu_dbcc (sim_cpu *cpu)\n }\n \n void\n-cpu_exg (sim_cpu *cpu, uint8 code)\n+cpu_exg (sim_cpu *cpu, uint8_t code)\n {\n-  uint8 r1, r2;\n-  uint16 src1;\n-  uint16 src2;\n+  uint8_t r1, r2;\n+  uint16_t src1;\n+  uint16_t src2;\n \n   r1 = (code >> 4) & 0x07;\n   r2 = code & 0x07;\n@@ -741,7 +741,7 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n     {\n     case M6811_RTI:\n       {\n-        uint8 ccr;\n+        uint8_t ccr;\n \n         ccr = cpu_m68hc11_pop_uint8 (cpu);\n         cpu_set_ccr (cpu, ccr);\n@@ -755,7 +755,7 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_RTI:\n       {\n-        uint8 ccr;\n+        uint8_t ccr;\n \n         ccr = cpu_m68hc12_pop_uint8 (cpu);\n         cpu_set_ccr (cpu, ccr);\n@@ -791,7 +791,7 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n     case M6811_ILLEGAL:\n       if (cpu->cpu_emul_syscall)\n         {\n-          uint8 op = memory_read8 (cpu,\n+          uint8_t op = memory_read8 (cpu,\n                                    cpu_get_pc (cpu) - 1);\n           if (op == 0x41)\n             {\n@@ -833,8 +833,8 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_IDIVS:\n       {\n-        int32 src1 = (int16) cpu_get_d (cpu);\n-        int32 src2 = (int16) cpu_get_x (cpu);\n+        int32_t src1 = (int16_t) cpu_get_d (cpu);\n+        int32_t src2 = (int16_t) cpu_get_x (cpu);\n \n         if (src2 == 0)\n           {\n@@ -855,9 +855,9 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n       \n     case M6812_EDIV:\n       {\n-        uint32 src1 = (uint32) cpu_get_x (cpu);\n-        uint32 src2 = (uint32) (cpu_get_y (cpu) << 16)\n-          | (uint32) (cpu_get_d (cpu));\n+        uint32_t src1 = (uint32_t) cpu_get_x (cpu);\n+        uint32_t src2 = (uint32_t) (cpu_get_y (cpu) << 16)\n+          | (uint32_t) (cpu_get_d (cpu));\n \n         if (src1 == 0)\n           {\n@@ -878,9 +878,9 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n       \n     case M6812_EDIVS:\n       {\n-        int32 src1 = (int16) cpu_get_x (cpu);\n-        int32 src2 = (uint32) (cpu_get_y (cpu) << 16)\n-          | (uint32) (cpu_get_d (cpu));\n+        int32_t src1 = (int16_t) cpu_get_x (cpu);\n+        int32_t src2 = (uint32_t) (cpu_get_y (cpu) << 16)\n+          | (uint32_t) (cpu_get_d (cpu));\n \n         if (src1 == 0)\n           {\n@@ -901,10 +901,10 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_EMULS:\n       {\n-        int32 src1, src2;\n+        int32_t src1, src2;\n \n-        src1 = (int16) cpu_get_d (cpu);\n-        src2 = (int16) cpu_get_y (cpu);\n+        src1 = (int16_t) cpu_get_d (cpu);\n+        src2 = (int16_t) cpu_get_y (cpu);\n         src1 = src1 * src2;\n         cpu_set_d (cpu, src1 & 0x0ffff);\n         cpu_set_y (cpu, src1 >> 16);\n@@ -916,15 +916,15 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n       \n     case M6812_EMACS:\n       {\n-        int32 src1, src2;\n-        uint16 addr;\n+        int32_t src1, src2;\n+        uint16_t addr;\n         \n         addr = cpu_fetch16 (cpu);\n-        src1 = (int16) memory_read16 (cpu, cpu_get_x (cpu));\n-        src2 = (int16) memory_read16 (cpu, cpu_get_y (cpu));\n+        src1 = (int16_t) memory_read16 (cpu, cpu_get_x (cpu));\n+        src2 = (int16_t) memory_read16 (cpu, cpu_get_y (cpu));\n         src1 = src1 * src2;\n-        src2 = (((uint32) memory_read16 (cpu, addr)) << 16)\n-          | (uint32) memory_read16 (cpu, addr + 2);\n+        src2 = (((uint32_t) memory_read16 (cpu, addr)) << 16)\n+          | (uint32_t) memory_read16 (cpu, addr + 2);\n \n         memory_write16 (cpu, addr, (src1 + src2) >> 16);\n         memory_write16 (cpu, addr + 2, (src1 + src2));\n@@ -935,8 +935,8 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_CALL:\n       {\n-        uint8 page;\n-        uint16 addr;\n+        uint8_t page;\n+        uint16_t addr;\n \n         addr = cpu_fetch16 (cpu);\n         page = cpu_fetch8 (cpu);\n@@ -951,9 +951,9 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_CALL_INDIRECT:\n       {\n-        uint8 code;\n-        uint16 addr;\n-        uint8 page;\n+        uint8_t code;\n+        uint16_t addr;\n+        uint8_t page;\n \n         code = memory_read8 (cpu, cpu_get_pc (cpu));\n         /* Indirect addressing call has the page specified in the\n@@ -979,8 +979,8 @@ cpu_special (sim_cpu *cpu, enum M6811_Special special)\n \n     case M6812_RTC:\n       {\n-        uint8 page = cpu_m68hc12_pop_uint8 (cpu);\n-        uint16 addr = cpu_m68hc12_pop_uint16 (cpu);\n+        uint8_t page = cpu_m68hc12_pop_uint8 (cpu);\n+        uint16_t addr = cpu_m68hc12_pop_uint16 (cpu);\n \n         cpu_set_page (cpu, page);\n         cpu_set_pc (cpu, addr);\n@@ -1019,7 +1019,7 @@ cpu_single_step (sim_cpu *cpu)\n /* VARARGS */\n void\n sim_memory_error (sim_cpu *cpu, SIM_SIGNAL excep,\n-\t\t  uint16 addr, const char *message, ...)\n+\t\t  uint16_t addr, const char *message, ...)\n {\n   char buf[1024];\n   va_list args;\n@@ -1035,7 +1035,7 @@ sim_memory_error (sim_cpu *cpu, SIM_SIGNAL excep,\n \n void\n cpu_memory_exception (sim_cpu *cpu, SIM_SIGNAL excep,\n-                      uint16 addr, const char *message)\n+                      uint16_t addr, const char *message)\n {\n   if (cpu->cpu_running == 0)\n     return;"
    },
    {
      "sha": "e667c33a70555f65fb7c1c444559ce07f377358b",
      "filename": "sim/m68hc11/sim-main.h",
      "status": "modified",
      "additions": 70,
      "deletions": 78,
      "changes": 148,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7606e1a3904368d942ad886c110dc34581e98c42/sim/m68hc11/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m68hc11/sim-main.h?ref=7606e1a3904368d942ad886c110dc34581e98c42",
      "patch": "@@ -32,14 +32,6 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n #include \"sim-signal.h\"\n #include \"sim-types.h\"\n \n-typedef unsigned8 uint8;\n-typedef unsigned16 uint16;\n-typedef signed16 int16;\n-typedef unsigned32 uint32;\n-typedef signed32 int32;\n-typedef unsigned64 uint64;\n-typedef signed64 int64;\n-\n struct _sim_cpu;\n \n #include \"interrupts.h\"\n@@ -98,9 +90,9 @@ typedef struct io_reg_desc io_reg_desc;\n extern void print_io_reg_desc (SIM_DESC sd, io_reg_desc *desc, int val,\n \t\t\t       int mode);\n extern void print_io_byte (SIM_DESC sd, const char *name,\n-\t\t\t   io_reg_desc *desc, uint8 val, uint16 addr);\n+\t\t\t   io_reg_desc *desc, uint8_t val, uint16_t addr);\n extern void print_io_word (SIM_DESC sd, const char *name,\n-\t\t\t   io_reg_desc *desc, uint16 val, uint16 addr);\n+\t\t\t   io_reg_desc *desc, uint16_t val, uint16_t addr);\n \n \n /* List of special 68HC11&68HC12 instructions that are not handled by the\n@@ -161,11 +153,11 @@ struct _sim_cpu {\n   /* CPU absolute cycle time.  The cycle time is updated after\n      each instruction, by the number of cycles taken by the instruction.\n      It is cleared only when reset occurs.  */\n-  signed64              cpu_absolute_cycle;\n+  int64_t              cpu_absolute_cycle;\n \n   /* Number of cycles to increment after the current instruction.\n      This is also the number of ticks for the generic event scheduler.  */\n-  uint8                 cpu_current_cycle;\n+  uint8_t                 cpu_current_cycle;\n   int                   cpu_emul_syscall;\n   int                   cpu_is_initialized;\n   int                   cpu_running;\n@@ -182,7 +174,7 @@ struct _sim_cpu {\n   /* The starting address specified in ELF header.  */\n   int                   cpu_elf_start;\n   \n-  uint16                cpu_insn_pc;\n+  uint16_t                cpu_insn_pc;\n \n   /* CPU frequency.  This is the quartz frequency.  It is divided by 4 to\n      get the cycle time.  This is used for the timer rate and for the baud\n@@ -197,15 +189,15 @@ struct _sim_cpu {\n   enum cpu_type         cpu_type;\n   \n   /* Initial value of the CONFIG register.  */\n-  uint8                 cpu_config;\n-  uint8                 cpu_use_local_config;\n+  uint8_t                 cpu_config;\n+  uint8_t                 cpu_use_local_config;\n   \n-  uint8                 ios[MAX_PORTS];\n+  uint8_t                 ios[MAX_PORTS];\n \n   /* Memory bank parameters which describe how the memory bank window\n      is mapped in memory and how to convert it in virtual address.  */\n-  uint16                bank_start;\n-  uint16                bank_end;\n+  uint16_t                bank_start;\n+  uint16_t                bank_end;\n   address_word          bank_virtual;\n   unsigned              bank_shift;\n   \n@@ -219,14 +211,14 @@ struct _sim_cpu {\n /* Returns the cpu absolute cycle time (A virtual counter incremented\n    at each 68HC11 E clock).  */\n #define cpu_current_cycle(cpu)    ((cpu)->cpu_absolute_cycle)\n-#define cpu_add_cycles(cpu, T)    ((cpu)->cpu_current_cycle += (signed64) (T))\n+#define cpu_add_cycles(cpu, T)    ((cpu)->cpu_current_cycle += (int64_t) (T))\n #define cpu_is_running(cpu)       ((cpu)->cpu_running)\n \n /* Get the IO/RAM base addresses depending on the M6811_INIT register.  */\n #define cpu_get_io_base(cpu) \\\n-  (((uint16)(((cpu)->ios[M6811_INIT]) & 0x0F)) << 12)\n+  (((uint16_t)(((cpu)->ios[M6811_INIT]) & 0x0F)) << 12)\n #define cpu_get_reg_base(cpu) \\\n-  (((uint16)(((cpu)->ios[M6811_INIT]) & 0xF0)) << 8)\n+  (((uint16_t)(((cpu)->ios[M6811_INIT]) & 0xF0)) << 8)\n \n /* Returns the different CPU registers.  */\n #define cpu_get_ccr(cpu)          ((cpu)->cpu_regs.ccr)\n@@ -288,7 +280,7 @@ struct _sim_cpu {\n \n extern void cpu_memory_exception (sim_cpu *cpu,\n                                   SIM_SIGNAL excep,\n-                                  uint16 addr,\n+                                  uint16_t addr,\n                                   const char *message);\n \n STATIC_INLINE UNUSED address_word\n@@ -302,10 +294,10 @@ phys_to_virt (sim_cpu *cpu, address_word addr)\n     return (address_word) (addr);\n }\n \n-STATIC_INLINE UNUSED uint8\n-memory_read8 (sim_cpu *cpu, uint16 addr)\n+STATIC_INLINE UNUSED uint8_t\n+memory_read8 (sim_cpu *cpu, uint16_t addr)\n {\n-  uint8 val;\n+  uint8_t val;\n \n   if (sim_core_read_buffer (CPU_STATE (cpu), cpu, 0, &val, addr, 1) != 1)\n     {\n@@ -316,7 +308,7 @@ memory_read8 (sim_cpu *cpu, uint16 addr)\n }\n \n STATIC_INLINE UNUSED void\n-memory_write8 (sim_cpu *cpu, uint16 addr, uint8 val)\n+memory_write8 (sim_cpu *cpu, uint16_t addr, uint8_t val)\n {\n   if (sim_core_write_buffer (CPU_STATE (cpu), cpu, 0, &val, addr, 1) != 1)\n     {\n@@ -325,23 +317,23 @@ memory_write8 (sim_cpu *cpu, uint16 addr, uint8 val)\n     }\n }\n \n-STATIC_INLINE UNUSED uint16\n-memory_read16 (sim_cpu *cpu, uint16 addr)\n+STATIC_INLINE UNUSED uint16_t\n+memory_read16 (sim_cpu *cpu, uint16_t addr)\n {\n-  uint8 b[2];\n+  uint8_t b[2];\n \n   if (sim_core_read_buffer (CPU_STATE (cpu), cpu, 0, b, addr, 2) != 2)\n     {\n       cpu_memory_exception (cpu, SIM_SIGSEGV, addr,\n                             \"Read error\");\n     }\n-  return (((uint16) (b[0])) << 8) | ((uint16) b[1]);\n+  return (((uint16_t) (b[0])) << 8) | ((uint16_t) b[1]);\n }\n \n STATIC_INLINE UNUSED void\n-memory_write16 (sim_cpu *cpu, uint16 addr, uint16 val)\n+memory_write16 (sim_cpu *cpu, uint16_t addr, uint16_t val)\n {\n-  uint8 b[2];\n+  uint8_t b[2];\n \n   b[0] = val >> 8;\n   b[1] = val;\n@@ -352,34 +344,34 @@ memory_write16 (sim_cpu *cpu, uint16 addr, uint16 val)\n     }\n }\n extern void\n-cpu_ccr_update_tst8 (sim_cpu *cpu, uint8 val);\n+cpu_ccr_update_tst8 (sim_cpu *cpu, uint8_t val);\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_tst16 (sim_cpu *cpu, uint16 val)\n+cpu_ccr_update_tst16 (sim_cpu *cpu, uint16_t val)\n {\n   cpu_set_ccr_V (cpu, 0);\n   cpu_set_ccr_N (cpu, val & 0x8000 ? 1 : 0);\n   cpu_set_ccr_Z (cpu, val == 0 ? 1 : 0);\n }\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_shift8 (sim_cpu *cpu, uint8 val)\n+cpu_ccr_update_shift8 (sim_cpu *cpu, uint8_t val)\n {\n   cpu_set_ccr_N (cpu, val & 0x80 ? 1 : 0);\n   cpu_set_ccr_Z (cpu, val == 0 ? 1 : 0);\n   cpu_set_ccr_V (cpu, cpu_get_ccr_N (cpu) ^ cpu_get_ccr_C (cpu));\n }\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_shift16 (sim_cpu *cpu, uint16 val)\n+cpu_ccr_update_shift16 (sim_cpu *cpu, uint16_t val)\n {\n   cpu_set_ccr_N (cpu, val & 0x8000 ? 1 : 0);\n   cpu_set_ccr_Z (cpu, val == 0 ? 1 : 0);\n   cpu_set_ccr_V (cpu, cpu_get_ccr_N (cpu) ^ cpu_get_ccr_C (cpu));\n }\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_add8 (sim_cpu *cpu, uint8 r, uint8 a, uint8 b)\n+cpu_ccr_update_add8 (sim_cpu *cpu, uint8_t r, uint8_t a, uint8_t b)\n {\n   cpu_set_ccr_C (cpu, ((a & b) | (b & ~r) | (a & ~r)) & 0x80 ? 1 : 0);\n   cpu_set_ccr_V (cpu, ((a & b & ~r) | (~a & ~b & r)) & 0x80 ? 1 : 0);\n@@ -389,7 +381,7 @@ cpu_ccr_update_add8 (sim_cpu *cpu, uint8 r, uint8 a, uint8 b)\n \n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_sub8 (sim_cpu *cpu, uint8 r, uint8 a, uint8 b)\n+cpu_ccr_update_sub8 (sim_cpu *cpu, uint8_t r, uint8_t a, uint8_t b)\n {\n   cpu_set_ccr_C (cpu, ((~a & b) | (b & r) | (~a & r)) & 0x80 ? 1 : 0);\n   cpu_set_ccr_V (cpu, ((a & ~b & ~r) | (~a & b & r)) & 0x80 ? 1 : 0);\n@@ -398,7 +390,7 @@ cpu_ccr_update_sub8 (sim_cpu *cpu, uint8 r, uint8 a, uint8 b)\n }\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_add16 (sim_cpu *cpu, uint16 r, uint16 a, uint16 b)\n+cpu_ccr_update_add16 (sim_cpu *cpu, uint16_t r, uint16_t a, uint16_t b)\n {\n   cpu_set_ccr_C (cpu, ((a & b) | (b & ~r) | (a & ~r)) & 0x8000 ? 1 : 0);\n   cpu_set_ccr_V (cpu, ((a & b & ~r) | (~a & ~b & r)) & 0x8000 ? 1 : 0);\n@@ -407,7 +399,7 @@ cpu_ccr_update_add16 (sim_cpu *cpu, uint16 r, uint16 a, uint16 b)\n }\n \n STATIC_INLINE UNUSED void\n-cpu_ccr_update_sub16 (sim_cpu *cpu, uint16 r, uint16 a, uint16 b)\n+cpu_ccr_update_sub16 (sim_cpu *cpu, uint16_t r, uint16_t a, uint16_t b)\n {\n   cpu_set_ccr_C (cpu, ((~a & b) | (b & r) | (~a & r)) & 0x8000 ? 1 : 0);\n   cpu_set_ccr_V (cpu, ((a & ~b & ~r) | (~a & b & r)) & 0x8000 ? 1 : 0);\n@@ -417,39 +409,39 @@ cpu_ccr_update_sub16 (sim_cpu *cpu, uint16 r, uint16 a, uint16 b)\n \n /* Push and pop instructions for 68HC11 (next-available stack mode).  */\n STATIC_INLINE UNUSED void\n-cpu_m68hc11_push_uint8 (sim_cpu *cpu, uint8 val)\n+cpu_m68hc11_push_uint8 (sim_cpu *cpu, uint8_t val)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n+  uint16_t addr = cpu->cpu_regs.sp;\n \n   memory_write8 (cpu, addr, val);\n   cpu->cpu_regs.sp = addr - 1;\n }\n \n STATIC_INLINE UNUSED void\n-cpu_m68hc11_push_uint16 (sim_cpu *cpu, uint16 val)\n+cpu_m68hc11_push_uint16 (sim_cpu *cpu, uint16_t val)\n {\n-  uint16 addr = cpu->cpu_regs.sp - 1;\n+  uint16_t addr = cpu->cpu_regs.sp - 1;\n \n   memory_write16 (cpu, addr, val);\n   cpu->cpu_regs.sp = addr - 1;\n }\n \n-STATIC_INLINE UNUSED uint8\n+STATIC_INLINE UNUSED uint8_t\n cpu_m68hc11_pop_uint8 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n-  uint8 val;\n+  uint16_t addr = cpu->cpu_regs.sp;\n+  uint8_t val;\n   \n   val = memory_read8 (cpu, addr + 1);\n   cpu->cpu_regs.sp = addr + 1;\n   return val;\n }\n \n-STATIC_INLINE UNUSED uint16\n+STATIC_INLINE UNUSED uint16_t\n cpu_m68hc11_pop_uint16 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n-  uint16 val;\n+  uint16_t addr = cpu->cpu_regs.sp;\n+  uint16_t val;\n   \n   val = memory_read16 (cpu, addr + 1);\n   cpu->cpu_regs.sp = addr + 2;\n@@ -458,79 +450,79 @@ cpu_m68hc11_pop_uint16 (sim_cpu *cpu)\n \n /* Push and pop instructions for 68HC12 (last-used stack mode).  */\n STATIC_INLINE UNUSED void\n-cpu_m68hc12_push_uint8 (sim_cpu *cpu, uint8 val)\n+cpu_m68hc12_push_uint8 (sim_cpu *cpu, uint8_t val)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n+  uint16_t addr = cpu->cpu_regs.sp;\n \n   addr --;\n   memory_write8 (cpu, addr, val);\n   cpu->cpu_regs.sp = addr;\n }\n \n STATIC_INLINE UNUSED void\n-cpu_m68hc12_push_uint16 (sim_cpu *cpu, uint16 val)\n+cpu_m68hc12_push_uint16 (sim_cpu *cpu, uint16_t val)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n+  uint16_t addr = cpu->cpu_regs.sp;\n \n   addr -= 2;\n   memory_write16 (cpu, addr, val);\n   cpu->cpu_regs.sp = addr;\n }\n \n-STATIC_INLINE UNUSED uint8\n+STATIC_INLINE UNUSED uint8_t\n cpu_m68hc12_pop_uint8 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n-  uint8 val;\n+  uint16_t addr = cpu->cpu_regs.sp;\n+  uint8_t val;\n   \n   val = memory_read8 (cpu, addr);\n   cpu->cpu_regs.sp = addr + 1;\n   return val;\n }\n \n-STATIC_INLINE UNUSED uint16\n+STATIC_INLINE UNUSED uint16_t\n cpu_m68hc12_pop_uint16 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.sp;\n-  uint16 val;\n+  uint16_t addr = cpu->cpu_regs.sp;\n+  uint16_t val;\n   \n   val = memory_read16 (cpu, addr);\n   cpu->cpu_regs.sp = addr + 2;\n   return val;\n }\n \n /* Fetch a 8/16 bit value and update the PC.  */\n-STATIC_INLINE UNUSED uint8\n+STATIC_INLINE UNUSED uint8_t\n cpu_fetch8 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.pc;\n-  uint8 val;\n+  uint16_t addr = cpu->cpu_regs.pc;\n+  uint8_t val;\n   \n   val = memory_read8 (cpu, addr);\n   cpu->cpu_regs.pc = addr + 1;\n   return val;\n }\n \n-STATIC_INLINE UNUSED uint16\n+STATIC_INLINE UNUSED uint16_t\n cpu_fetch16 (sim_cpu *cpu)\n {\n-  uint16 addr = cpu->cpu_regs.pc;\n-  uint16 val;\n+  uint16_t addr = cpu->cpu_regs.pc;\n+  uint16_t val;\n   \n   val = memory_read16 (cpu, addr);\n   cpu->cpu_regs.pc = addr + 2;\n   return val;\n }\n \n-extern void cpu_call (sim_cpu *cpu, uint16 addr);\n-extern void cpu_exg (sim_cpu *cpu, uint8 code);\n+extern void cpu_call (sim_cpu *cpu, uint16_t addr);\n+extern void cpu_exg (sim_cpu *cpu, uint8_t code);\n extern void cpu_dbcc (sim_cpu *cpu);\n extern void cpu_special (sim_cpu *cpu, enum M6811_Special special);\n-extern void cpu_move8 (sim_cpu *cpu, uint8 op);\n-extern void cpu_move16 (sim_cpu *cpu, uint8 op);\n+extern void cpu_move8 (sim_cpu *cpu, uint8_t op);\n+extern void cpu_move16 (sim_cpu *cpu, uint8_t op);\n \n-extern uint16 cpu_fetch_relbranch (sim_cpu *cpu);\n-extern uint16 cpu_fetch_relbranch16 (sim_cpu *cpu);\n+extern uint16_t cpu_fetch_relbranch (sim_cpu *cpu);\n+extern uint16_t cpu_fetch_relbranch16 (sim_cpu *cpu);\n extern void cpu_push_all (sim_cpu *cpu);\n extern void cpu_single_step (sim_cpu *cpu);\n \n@@ -540,30 +532,30 @@ extern int cpu_initialize (SIM_DESC sd, sim_cpu *cpu);\n \n /* Returns the address of a 68HC12 indexed operand.\n    Pre and post modifications are handled on the source register.  */\n-extern uint16 cpu_get_indexed_operand_addr (sim_cpu *cpu, int restricted);\n+extern uint16_t cpu_get_indexed_operand_addr (sim_cpu *cpu, int restricted);\n \n extern void cpu_return (sim_cpu *cpu);\n-extern void cpu_set_sp (sim_cpu *cpu, uint16 val);\n+extern void cpu_set_sp (sim_cpu *cpu, uint16_t val);\n extern int cpu_reset (sim_cpu *cpu);\n extern int cpu_restart (sim_cpu *cpu);\n extern void sim_memory_error (sim_cpu *cpu, SIM_SIGNAL excep,\n-                              uint16 addr, const char *message, ...);\n+                              uint16_t addr, const char *message, ...);\n extern void emul_os (int op, sim_cpu *cpu);\n extern void cpu_interp_m6811 (sim_cpu *cpu);\n extern void cpu_interp_m6812 (sim_cpu *cpu);\n \n extern int m68hc11cpu_set_oscillator (SIM_DESC sd, const char *port,\n \t\t\t\t      double ton, double toff,\n-\t\t\t\t      signed64 repeat);\n+\t\t\t\t      int64_t repeat);\n extern int m68hc11cpu_clear_oscillator (SIM_DESC sd, const char *port);\n extern void m68hc11cpu_set_port (struct hw *me, sim_cpu *cpu,\n-\t\t\t\t unsigned addr, uint8 val);\n+\t\t\t\t unsigned addr, uint8_t val);\n \n extern void sim_board_reset (SIM_DESC sd);\n \n #define PRINT_TIME  0x01\n #define PRINT_CYCLE 0x02\n-extern const char *cycle_to_string (sim_cpu *cpu, signed64 t, int flags);\n+extern const char *cycle_to_string (sim_cpu *cpu, int64_t t, int flags);\n \n #endif\n "
    }
  ]
}