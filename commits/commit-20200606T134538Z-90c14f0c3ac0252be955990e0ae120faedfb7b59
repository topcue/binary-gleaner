{
  "sha": "90c14f0c3ac0252be955990e0ae120faedfb7b59",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTBjMTRmMGMzYWMwMjUyYmU5NTU5OTBlMGFlMTIwZmFlZGZiN2I1OQ==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-06T13:45:23Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-06T13:45:38Z"
    },
    "message": "ELF: Add target_os to elf_link_hash_table/elf_backend_data\n\nAdd target_os to elf_backend_data to identify target OS.  Add target_os,\nto elf_link_hash_table to identify target OS for linker output.\n\n\t* elf-bfd.h (elf_target_os): New.\n\t(elf_link_hash_table): Add target_os.\n\t(elf_backend_data): Add target_os.\n\t* elf32-arm.c (elf32_arm_link_hash_table): Remove vxworks_p,\n\tsymbian_p and nacl_p.\n\t(create_got_section): Updated.\n\t(elf32_arm_create_dynamic_sections): Likewise.\n\t(arm_type_of_stub): Likewise.\n\t(elf32_arm_create_or_find_stub_sec): Likewise.\n\t(elf32_arm_allocate_plt_entry): Likewise.\n\t(elf32_arm_populate_plt_entry): Likewise.\n\t(elf32_arm_final_link_relocate): Likewise.\n\t(elf32_arm_check_relocs): Likewise.\n\t(allocate_dynrelocs_for_symbol): Likewise.\n\t(elf32_arm_finish_dynamic_symbol): Likewise.\n\t(elf32_arm_finish_dynamic_sections): Likewise.\n\t(elf32_arm_output_plt_map_1): Likewise.\n\t(elf32_arm_output_arch_local_syms): Likewise.\n\t(elf32_arm_add_symbol_hook): Likewise.\n\t(elf32_arm_nacl_link_hash_table_create): Likewise.\n\t(elf32_arm_vxworks_link_hash_table_create): Likewise.\n\t(elf32_arm_symbian_link_hash_table_create): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elf32-i386.c (elf_i386_arch_bed): Removed.\n\t(elf_backend_arch_data): Likewise.\n\t(elf_i386_solaris_arch_bed): Likewise.\n\t(elf_i386_nacl_arch_bed): Likewise.\n\t(elf_i386_vxworks_arch_bed): Likewise.\n\t(elf_i386_relocate_section): Updated.\n\t(elf_i386_finish_dynamic_sections): Likewise.\n\t(elf_i386_get_synthetic_symtab): Likewise.\n\t(elf_i386_link_setup_gnu_properties): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elf32-mips.c (ELF_TARGET_OS): New.\n\t* elf32-ppc.c (ppc_elf_link_hash_table): Remove is_vxworks.\n\t(ppc_elf_create_got): Updated.\n\t(ppc_elf_create_dynamic_sections): Likewise.\n\t(ppc_elf_check_relocs): Likewise.\n\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n\t(ppc_elf_size_dynamic_sections): Likewise.\n\t(ppc_elf_relocate_section): Likewise.\n\t(ppc_elf_finish_dynamic_sections): Likewise.\n\t(ppc_elf_vxworks_link_hash_table_create): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elf32-sh.c (elf_sh_link_hash_table): Remove vxworks_p.\n\t(sh_elf_link_hash_table_create): Updated.\n\t(sh_elf_create_dynamic_sections): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(sh_elf_size_dynamic_sections): Likewise.\n\t(sh_elf_relocate_section): Likewise.\n\t(sh_elf_finish_dynamic_symbol): Likewise.\n\t(sh_elf_finish_dynamic_sections): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elf32-sparc.c (elf32_sparc_vxworks_link_hash_table_create):\n\tRemoved.\n\t(bfd_elf32_bfd_link_hash_table_create): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elf64-x86-64.c (elf_x86_64_arch_bed): Removed.\n\t(elf_x86_64_solaris_arch_bed): Likewise.\n\t(elf_x86_64_nacl_arch_bed): Likewise.\n\t(elf_x86_64_finish_dynamic_sections): Updated.\n\t(elf_x86_64_get_synthetic_symtab): Likewise.\n\t(elf_x86_64_link_setup_gnu_properties): Likewise.\n\t(ELF_TARGET_OS): New.\n\t* elflink.c (_bfd_elf_link_hash_table_init): Initialize\n\ttarget_o.\n\t* elfxx-mips.c (mips_elf_link_hash_table): Remove is_vxworks.\n\t(MIPS_ELF_REL_DYN_NAME): Updated.\n\t(ELF_MIPS_GP_OFFSET): Likewise.\n\t(mips_elf_create_local_got_entry): Likewise.\n\t(mips_elf_allocate_dynamic_relocations): Likewise.\n\t(mips_elf_count_got_symbols): Likewise.\n\t(is_gott_symbol): Likewise.\n\t(mips_elf_calculate_relocation): Likewise.\n\t(mips_elf_create_dynamic_relocation): Likewise.\n\t(_bfd_mips_elf_check_relocs): Likewise.\n\t(allocate_dynrelocs): Likewise.\n\t(_bfd_mips_elf_adjust_dynamic_symbol): Likewise.\n\t(mips_elf_lay_out_got): Likewise.\n\t(mips_elf_set_plt_sym_value): Likewise.\n\t(_bfd_mips_elf_size_dynamic_sections): Likewise.\n\t(_bfd_mips_elf_finish_dynamic_symbol): Likewise.\n\t(_bfd_mips_elf_finish_dynamic_sections): Likewise.\n\t(_bfd_mips_elf_final_link): Likewise.\n\t(_bfd_mips_init_file_header): Likewise.\n\t* elfxx-sparc.c (_bfd_sparc_elf_create_dynamic_sections):\n\tLikewise.\n\t(allocate_dynrelocs): Likewise.\n\t(_bfd_sparc_elf_size_dynamic_sections): Likewise.\n\t(_bfd_sparc_elf_relocate_section): Likewise.\n\t(_bfd_sparc_elf_finish_dynamic_symbol): Likewise.\n\t(sparc_finish_dyn): Likewise.\n\t(_bfd_sparc_elf_finish_dynamic_sections): Likewise.\n\t* elfxx-target.h (ELF_TARGET_OS): New.\n\t(elfNN_bed): Add ELF_TARGET_OS.\n\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Updated.\n\t(_bfd_x86_elf_link_hash_table_create): Likewise.\n\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n\t(_bfd_x86_elf_finish_dynamic_sections): Likewise.\n\t(_bfd_x86_elf_adjust_dynamic_symbol): Likewise.\n\t(_bfd_x86_elf_link_setup_gnu_properties): Likewise.\n\t* elfxx-x86.h (elf_x86_target_os): Removed.\n\t(elf_x86_backend_data): Likewise.\n\t(get_elf_x86_backend_data): Likewise.\n\t(elf_x86_link_hash_table): Remove target_os.",
    "tree": {
      "sha": "1766e3cb8fa1058b0f2e6fc98c0f29dd68dacac5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1766e3cb8fa1058b0f2e6fc98c0f29dd68dacac5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/90c14f0c3ac0252be955990e0ae120faedfb7b59",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/90c14f0c3ac0252be955990e0ae120faedfb7b59",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/90c14f0c3ac0252be955990e0ae120faedfb7b59",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/90c14f0c3ac0252be955990e0ae120faedfb7b59/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1424c35d071e7d49a4a219c7dee8c88ffd60ddca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1424c35d071e7d49a4a219c7dee8c88ffd60ddca",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1424c35d071e7d49a4a219c7dee8c88ffd60ddca"
    }
  ],
  "stats": {
    "total": 609,
    "additions": 338,
    "deletions": 271
  },
  "files": [
    {
      "sha": "0fb6637a762219726c85f938ae34a9316a6a64fc",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 108,
      "deletions": 0,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -1,3 +1,111 @@\n+2020-06-06  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* elf-bfd.h (elf_target_os): New.\n+\t(elf_link_hash_table): Add target_os.\n+\t(elf_backend_data): Add target_os.\n+\t* elf32-arm.c (elf32_arm_link_hash_table): Remove vxworks_p,\n+\tsymbian_p and nacl_p.\n+\t(create_got_section): Updated.\n+\t(elf32_arm_create_dynamic_sections): Likewise.\n+\t(arm_type_of_stub): Likewise.\n+\t(elf32_arm_create_or_find_stub_sec): Likewise.\n+\t(elf32_arm_allocate_plt_entry): Likewise.\n+\t(elf32_arm_populate_plt_entry): Likewise.\n+\t(elf32_arm_final_link_relocate): Likewise.\n+\t(elf32_arm_check_relocs): Likewise.\n+\t(allocate_dynrelocs_for_symbol): Likewise.\n+\t(elf32_arm_finish_dynamic_symbol): Likewise.\n+\t(elf32_arm_finish_dynamic_sections): Likewise.\n+\t(elf32_arm_output_plt_map_1): Likewise.\n+\t(elf32_arm_output_arch_local_syms): Likewise.\n+\t(elf32_arm_add_symbol_hook): Likewise.\n+\t(elf32_arm_nacl_link_hash_table_create): Likewise.\n+\t(elf32_arm_vxworks_link_hash_table_create): Likewise.\n+\t(elf32_arm_symbian_link_hash_table_create): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elf32-i386.c (elf_i386_arch_bed): Removed.\n+\t(elf_backend_arch_data): Likewise.\n+\t(elf_i386_solaris_arch_bed): Likewise.\n+\t(elf_i386_nacl_arch_bed): Likewise.\n+\t(elf_i386_vxworks_arch_bed): Likewise.\n+\t(elf_i386_relocate_section): Updated.\n+\t(elf_i386_finish_dynamic_sections): Likewise.\n+\t(elf_i386_get_synthetic_symtab): Likewise.\n+\t(elf_i386_link_setup_gnu_properties): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elf32-mips.c (ELF_TARGET_OS): New.\n+\t* elf32-ppc.c (ppc_elf_link_hash_table): Remove is_vxworks.\n+\t(ppc_elf_create_got): Updated.\n+\t(ppc_elf_create_dynamic_sections): Likewise.\n+\t(ppc_elf_check_relocs): Likewise.\n+\t(ppc_elf_adjust_dynamic_symbol): Likewise.\n+\t(ppc_elf_size_dynamic_sections): Likewise.\n+\t(ppc_elf_relocate_section): Likewise.\n+\t(ppc_elf_finish_dynamic_sections): Likewise.\n+\t(ppc_elf_vxworks_link_hash_table_create): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elf32-sh.c (elf_sh_link_hash_table): Remove vxworks_p.\n+\t(sh_elf_link_hash_table_create): Updated.\n+\t(sh_elf_create_dynamic_sections): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(sh_elf_size_dynamic_sections): Likewise.\n+\t(sh_elf_relocate_section): Likewise.\n+\t(sh_elf_finish_dynamic_symbol): Likewise.\n+\t(sh_elf_finish_dynamic_sections): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elf32-sparc.c (elf32_sparc_vxworks_link_hash_table_create):\n+\tRemoved.\n+\t(bfd_elf32_bfd_link_hash_table_create): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elf64-x86-64.c (elf_x86_64_arch_bed): Removed.\n+\t(elf_x86_64_solaris_arch_bed): Likewise.\n+\t(elf_x86_64_nacl_arch_bed): Likewise.\n+\t(elf_x86_64_finish_dynamic_sections): Updated.\n+\t(elf_x86_64_get_synthetic_symtab): Likewise.\n+\t(elf_x86_64_link_setup_gnu_properties): Likewise.\n+\t(ELF_TARGET_OS): New.\n+\t* elflink.c (_bfd_elf_link_hash_table_init): Initialize\n+\ttarget_o.\n+\t* elfxx-mips.c (mips_elf_link_hash_table): Remove is_vxworks.\n+\t(MIPS_ELF_REL_DYN_NAME): Updated.\n+\t(ELF_MIPS_GP_OFFSET): Likewise.\n+\t(mips_elf_create_local_got_entry): Likewise.\n+\t(mips_elf_allocate_dynamic_relocations): Likewise.\n+\t(mips_elf_count_got_symbols): Likewise.\n+\t(is_gott_symbol): Likewise.\n+\t(mips_elf_calculate_relocation): Likewise.\n+\t(mips_elf_create_dynamic_relocation): Likewise.\n+\t(_bfd_mips_elf_check_relocs): Likewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(_bfd_mips_elf_adjust_dynamic_symbol): Likewise.\n+\t(mips_elf_lay_out_got): Likewise.\n+\t(mips_elf_set_plt_sym_value): Likewise.\n+\t(_bfd_mips_elf_size_dynamic_sections): Likewise.\n+\t(_bfd_mips_elf_finish_dynamic_symbol): Likewise.\n+\t(_bfd_mips_elf_finish_dynamic_sections): Likewise.\n+\t(_bfd_mips_elf_final_link): Likewise.\n+\t(_bfd_mips_init_file_header): Likewise.\n+\t* elfxx-sparc.c (_bfd_sparc_elf_create_dynamic_sections):\n+\tLikewise.\n+\t(allocate_dynrelocs): Likewise.\n+\t(_bfd_sparc_elf_size_dynamic_sections): Likewise.\n+\t(_bfd_sparc_elf_relocate_section): Likewise.\n+\t(_bfd_sparc_elf_finish_dynamic_symbol): Likewise.\n+\t(sparc_finish_dyn): Likewise.\n+\t(_bfd_sparc_elf_finish_dynamic_sections): Likewise.\n+\t* elfxx-target.h (ELF_TARGET_OS): New.\n+\t(elfNN_bed): Add ELF_TARGET_OS.\n+\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Updated.\n+\t(_bfd_x86_elf_link_hash_table_create): Likewise.\n+\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n+\t(_bfd_x86_elf_finish_dynamic_sections): Likewise.\n+\t(_bfd_x86_elf_adjust_dynamic_symbol): Likewise.\n+\t(_bfd_x86_elf_link_setup_gnu_properties): Likewise.\n+\t* elfxx-x86.h (elf_x86_target_os): Removed.\n+\t(elf_x86_backend_data): Likewise.\n+\t(get_elf_x86_backend_data): Likewise.\n+\t(elf_x86_link_hash_table): Remove target_os.\n+\n 2020-06-06  Alan Modra  <amodra@gmail.com>\n \n \t* reloc.c: Rename"
    },
    {
      "sha": "3736ba6c7d646d8552676c352b3cae08b54cf667",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -540,6 +540,15 @@ struct bfd_link_needed_list\n   const char *name;\n };\n \n+enum elf_target_os\n+{\n+  is_normal,\n+  is_symbian,\t/* Symbian OS.  */\n+  is_solaris,\t/* Solaris.  */\n+  is_vxworks,\t/* VxWorks.  */\n+  is_nacl\t/* Native Client.  */\n+};\n+\n /* ELF linker hash table.  */\n \n struct elf_link_hash_table\n@@ -641,6 +650,9 @@ struct elf_link_hash_table\n   asection *tls_sec;\n   bfd_size_type tls_size;  /* Bytes.  */\n \n+  /* Target OS for linker output.  */\n+  enum elf_target_os target_os;\n+\n   /* A linked list of dynamic BFD's loaded in the link.  */\n   struct elf_link_loaded_list *dyn_loaded;\n \n@@ -861,6 +873,9 @@ struct elf_backend_data\n      extensions to elf_obj_tdata and elf_link_hash_table structures.  */\n   enum elf_target_id target_id;\n \n+  /* Target OS.  */\n+  enum elf_target_os target_os;\n+\n   /* The ELF machine code (EM_xxxx) for this backend.  */\n   int elf_machine_code;\n "
    },
    {
      "sha": "f2ac094acd6659ec90c148252bf3224361027c1a",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 55,
      "deletions": 54,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -3360,15 +3360,6 @@ struct elf32_arm_link_hash_table\n   /* The number of bytes in the subsequent PLT etries.  */\n   bfd_size_type plt_entry_size;\n \n-  /* True if the target system is VxWorks.  */\n-  int vxworks_p;\n-\n-  /* True if the target system is Symbian OS.  */\n-  int symbian_p;\n-\n-  /* True if the target system is Native Client.  */\n-  int nacl_p;\n-\n   /* True if the target uses REL relocations.  */\n   bfd_boolean use_rel;\n \n@@ -3803,7 +3794,7 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)\n     return FALSE;\n \n   /* BPABI objects never have a GOT, or associated sections.  */\n-  if (htab->symbian_p)\n+  if (htab->root.target_os == is_symbian)\n     return TRUE;\n \n   if (! _bfd_elf_create_got_section (dynobj, info))\n@@ -3960,7 +3951,7 @@ elf32_arm_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)\n   if (!_bfd_elf_create_dynamic_sections (dynobj, info))\n     return FALSE;\n \n-  if (htab->vxworks_p)\n+  if (htab->root.target_os == is_vxworks)\n     {\n       if (!elf_vxworks_create_dynamic_sections (dynobj, info, &htab->srelplt2))\n \treturn FALSE;\n@@ -4483,11 +4474,11 @@ arm_type_of_stub (struct bfd_link_info *info,\n \t\t? (r_type == R_ARM_TLS_CALL\n \t\t   /* TLS PIC Stub.  */\n \t\t   ? arm_stub_long_branch_any_tls_pic\n-\t\t   : (globals->nacl_p\n+\t\t   : (globals->root.target_os == is_nacl\n \t\t      ? arm_stub_long_branch_arm_nacl_pic\n \t\t      : arm_stub_long_branch_any_arm_pic))\n \t\t/* non-PIC stubs.  */\n-\t\t: (globals->nacl_p\n+\t\t: (globals->root.target_os == is_nacl\n \t\t   ? arm_stub_long_branch_arm_nacl\n \t\t   : arm_stub_long_branch_any_any);\n \t    }\n@@ -4752,7 +4743,7 @@ elf32_arm_create_or_find_stub_sec (asection **link_sec_p, asection *section,\n \tstub_sec_p = &htab->stub_group[link_sec->id].stub_sec;\n       stub_sec_prefix = link_sec->name;\n       out_sec = link_sec->output_section;\n-      align = htab->nacl_p ? 4 : 3;\n+      align = htab->root.target_os == is_nacl ? 4 : 3;\n     }\n \n   if (*stub_sec_p == NULL)\n@@ -9524,7 +9515,7 @@ elf32_arm_allocate_plt_entry (struct bfd_link_info *info,\n       sgotplt = htab->root.igotplt;\n \n       /* NaCl uses a special first entry in .iplt too.  */\n-      if (htab->nacl_p && splt->size == 0)\n+      if (htab->root.target_os == is_nacl && splt->size == 0)\n \tsplt->size += htab->plt_header_size;\n \n       /* Allocate room for an R_ARM_IRELATIVE relocation in .rel.iplt.  */\n@@ -9566,7 +9557,7 @@ elf32_arm_allocate_plt_entry (struct bfd_link_info *info,\n   root_plt->offset = splt->size;\n   splt->size += htab->plt_entry_size;\n \n-  if (!htab->symbian_p)\n+  if (htab->root.target_os != is_symbian)\n     {\n       /* We also need to make an entry in the .got.plt section, which\n \t will be placed in the .got section by the linker script.  */\n@@ -9647,7 +9638,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n   BFD_ASSERT (splt != NULL && srel != NULL);\n \n   /* Fill in the entry in the procedure linkage table.  */\n-  if (htab->symbian_p)\n+  if (htab->root.target_os == is_symbian)\n     {\n       BFD_ASSERT (dynindx >= 0);\n       put_arm_insn (htab, output_bfd,\n@@ -9704,7 +9695,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t\t     + root_plt->offset);\n \n       ptr = splt->contents + root_plt->offset;\n-      if (htab->vxworks_p && bfd_link_pic (info))\n+      if (htab->root.target_os == is_vxworks && bfd_link_pic (info))\n \t{\n \t  unsigned int i;\n \t  bfd_vma val;\n@@ -9722,7 +9713,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t\tput_arm_insn (htab, output_bfd, val, ptr);\n \t    }\n \t}\n-      else if (htab->vxworks_p)\n+      else if (htab->root.target_os == is_vxworks)\n \t{\n \t  unsigned int i;\n \t  bfd_vma val;\n@@ -9760,7 +9751,7 @@ elf32_arm_populate_plt_entry (bfd *output_bfd, struct bfd_link_info *info,\n \t  rel.r_addend = 0;\n \t  SWAP_RELOC_OUT (htab) (output_bfd, &rel, loc);\n \t}\n-      else if (htab->nacl_p)\n+      else if (htab->root.target_os == is_nacl)\n \t{\n \t  /* Calculate the displacement between the PLT slot and the\n \t     common tail that's part of the special initial PLT slot.  */\n@@ -10465,7 +10456,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n       return bfd_reloc_ok;\n \n     case R_ARM_ABS12:\n-      if (!globals->vxworks_p)\n+      if (globals->root.target_os != is_vxworks)\n \treturn elf32_arm_abs12_reloc (input_bfd, hit_data, value + addend);\n       /* Fall through.  */\n \n@@ -10513,7 +10504,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t   || globals->root.is_relocatable_executable\n \t   || globals->fdpic_p)\n \t  && (input_section->flags & SEC_ALLOC)\n-\t  && !(globals->vxworks_p\n+\t  && !(globals->root.target_os == is_vxworks\n \t       && strcmp (input_section->output_section->name,\n \t\t\t  \".tls_vars\") == 0)\n \t  && ((r_type != R_ARM_REL32 && r_type != R_ARM_REL32_NOI)\n@@ -10590,7 +10581,7 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t      /* This symbol is local, or marked to become local.  */\n \t      BFD_ASSERT (r_type == R_ARM_ABS32 || r_type == R_ARM_ABS32_NOI\n \t\t\t  || (globals->fdpic_p && !bfd_link_pic(info)));\n-\t      if (globals->symbian_p)\n+\t      if (globals->root.target_os == is_symbian)\n \t\t{\n \t\t  asection *osec;\n \n@@ -15513,7 +15504,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t  case R_ARM_ABS12:\n \t    /* VxWorks uses dynamic R_ARM_ABS12 relocations for\n \t       ldr __GOTT_INDEX__ offsets.  */\n-\t    if (!htab->vxworks_p)\n+\t    if (htab->root.target_os != is_vxworks)\n \t      {\n \t\tmay_need_local_target_p = TRUE;\n \t\tbreak;\n@@ -15666,7 +15657,7 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\treturn FALSE;\n \n \t      /* BPABI objects never have dynamic relocations mapped.  */\n-\t      if (htab->symbian_p)\n+\t      if (htab->root.target_os == is_symbian)\n \t\t{\n \t\t  flagword flags;\n \n@@ -16270,7 +16261,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t  /* VxWorks executables have a second set of relocations for\n \t     each PLT entry.  They go in a separate relocation section,\n \t     which is processed by the kernel loader.  */\n-\t  if (htab->vxworks_p && !bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks && !bfd_link_pic (info))\n \t    {\n \t      /* There is a relocation for the initial PLT entry:\n \t\t an R_ARM_32 relocation for _GLOBAL_OFFSET_TABLE_.  */\n@@ -16314,7 +16305,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t    return FALSE;\n \t}\n \n-      if (!htab->symbian_p)\n+      if (htab->root.target_os != is_symbian)\n \t{\n \t  s = htab->root.sgot;\n \t  h->got.offset = s->size;\n@@ -16575,7 +16566,7 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n \t    }\n \t}\n \n-      if (htab->vxworks_p)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n@@ -16729,7 +16720,6 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n       bfd_size_type locsymcount;\n       Elf_Internal_Shdr *symtab_hdr;\n       asection *srel;\n-      bfd_boolean is_vxworks = htab->vxworks_p;\n       unsigned int symndx;\n       struct fdpic_local *local_fdpic_cnts;\n \n@@ -16751,7 +16741,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (is_vxworks\n+\t      else if (htab->root.target_os == is_vxworks\n \t\t       && strcmp (p->sec->output_section->name,\n \t\t\t\t  \".tls_vars\") == 0)\n \t\t{\n@@ -17122,7 +17112,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n \t    return FALSE;\n \t}\n-      if (htab->vxworks_p\n+      if (htab->root.target_os == is_vxworks\n \t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n \treturn FALSE;\n     }\n@@ -17267,7 +17257,9 @@ elf32_arm_finish_dynamic_symbol (bfd * output_bfd,\n      and for FDPIC, the _GLOBAL_OFFSET_TABLE_ symbol is not absolute:\n      it is relative to the \".got\" section.  */\n   if (h == htab->root.hdynamic\n-      || (!htab->fdpic_p && !htab->vxworks_p && h == htab->root.hgot))\n+      || (!htab->fdpic_p\n+\t  && htab->root.target_os != is_vxworks\n+\t  && h == htab->root.hgot))\n     sym->st_shndx = SHN_ABS;\n \n   return TRUE;\n@@ -17353,7 +17345,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \n       splt = htab->root.splt;\n       BFD_ASSERT (splt != NULL && sdyn != NULL);\n-      BFD_ASSERT (htab->symbian_p || sgot != NULL);\n+      BFD_ASSERT (htab->root.target_os == is_symbian || sgot != NULL);\n \n       dyncon = (Elf32_External_Dyn *) sdyn->contents;\n       dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);\n@@ -17371,7 +17363,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t      unsigned int type;\n \n \t    default:\n-\t      if (htab->vxworks_p\n+\t      if (htab->root.target_os == is_vxworks\n \t\t  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \t\tbfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n@@ -17396,7 +17388,8 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t      goto get_vma_if_bpabi;\n \n \t    case DT_PLTGOT:\n-\t      name = htab->symbian_p ? \".got\" : \".got.plt\";\n+\t      name = (htab->root.target_os == is_symbian\n+\t\t      ? \".got\" : \".got.plt\");\n \t      goto get_vma;\n \t    case DT_JMPREL:\n \t      name = RELOC_SECTION (htab, \".plt\");\n@@ -17409,7 +17402,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t\t  bfd_set_error (bfd_error_invalid_operation);\n \t\t  return FALSE;\n \t\t}\n-\t      if (!htab->symbian_p)\n+\t      if (htab->root.target_os != is_symbian)\n \t\tdyn.d_un.d_ptr = s->output_section->vma + s->output_offset;\n \t      else\n \t\t/* In the BPABI, tags in the PT_DYNAMIC section point\n@@ -17420,7 +17413,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t      break;\n \n \t    get_vma_if_bpabi:\n-\t      if (htab->symbian_p)\n+\t      if (htab->root.target_os == is_symbian)\n \t\tgoto get_vma;\n \t      break;\n \n@@ -17442,7 +17435,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t\t relocation section, since relocation sections are\n \t\t never allocated under the BPABI.  PLT relocs are also\n \t\t included.  */\n-\t      if (htab->symbian_p)\n+\t      if (htab->root.target_os == is_symbian)\n \t\t{\n \t\t  unsigned int i;\n \t\t  type = ((dyn.d_tag == DT_REL || dyn.d_tag == DT_RELSZ)\n@@ -17518,7 +17511,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t  got_address = sgot->output_section->vma + sgot->output_offset;\n \t  plt_address = splt->output_section->vma + splt->output_offset;\n \n-\t  if (htab->vxworks_p)\n+\t  if (htab->root.target_os == is_vxworks)\n \t    {\n \t      /* The VxWorks GOT is relocated by the dynamic linker.\n \t\t Therefore, we must emit relocations rather than simply\n@@ -17541,7 +17534,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t      SWAP_RELOC_OUT (htab) (output_bfd, &rel,\n \t\t\t\t     htab->srelplt2->contents);\n \t    }\n-\t  else if (htab->nacl_p)\n+\t  else if (htab->root.target_os == is_nacl)\n \t    arm_nacl_put_plt0 (htab, output_bfd, splt,\n \t\t\t       got_address + 8 - (plt_address + 16));\n \t  else if (using_thumb_only (htab))\n@@ -17622,7 +17615,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n #endif\n \t}\n \n-      if (htab->vxworks_p\n+      if (htab->root.target_os == is_vxworks\n \t  && !bfd_link_pic (info)\n \t  && htab->root.splt->size > 0)\n \t{\n@@ -17652,7 +17645,9 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t}\n     }\n \n-  if (htab->nacl_p && htab->root.iplt != NULL && htab->root.iplt->size > 0)\n+  if (htab->root.target_os == is_nacl\n+      && htab->root.iplt != NULL\n+      && htab->root.iplt->size > 0)\n     /* NaCl uses a special first entry in .iplt too.  */\n     arm_nacl_put_plt0 (htab, output_bfd, htab->root.iplt, 0);\n \n@@ -17929,14 +17924,14 @@ elf32_arm_output_plt_map_1 (output_arch_syminfo *osi,\n \t\t    (osi->info->output_bfd, osi->sec->output_section));\n \n   addr = root_plt->offset & -2;\n-  if (htab->symbian_p)\n+  if (htab->root.target_os == is_symbian)\n     {\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))\n \treturn FALSE;\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 4))\n \treturn FALSE;\n     }\n-  else if (htab->vxworks_p)\n+  else if (htab->root.target_os == is_vxworks)\n     {\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))\n \treturn FALSE;\n@@ -17947,7 +17942,7 @@ elf32_arm_output_plt_map_1 (output_arch_syminfo *osi,\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_DATA, addr + 20))\n \treturn FALSE;\n     }\n-  else if (htab->nacl_p)\n+  else if (htab->root.target_os == is_nacl)\n     {\n       if (!elf32_arm_output_map_sym (osi, ARM_MAP_ARM, addr))\n \treturn FALSE;\n@@ -18309,7 +18304,7 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n \n       /* Output mapping symbols for the plt header.  SymbianOS does not have a\n \t plt header.  */\n-      if (htab->vxworks_p)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  /* VxWorks shared libraries have no PLT header.  */\n \t  if (!bfd_link_pic (info))\n@@ -18320,7 +18315,7 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n \t\treturn FALSE;\n \t    }\n \t}\n-      else if (htab->nacl_p)\n+      else if (htab->root.target_os == is_nacl)\n \t{\n \t  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))\n \t    return FALSE;\n@@ -18334,7 +18329,7 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n \t  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_THUMB, 16))\n \t    return FALSE;\n \t}\n-      else if (!htab->symbian_p && !htab->fdpic_p)\n+      else if (htab->root.target_os != is_symbian && !htab->fdpic_p)\n \t{\n \t  if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, 0))\n \t    return FALSE;\n@@ -18344,7 +18339,9 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n #endif\n \t}\n     }\n-  if (htab->nacl_p && htab->root.iplt && htab->root.iplt->size > 0)\n+  if (htab->root.target_os == is_nacl\n+      && htab->root.iplt\n+      && htab->root.iplt->size > 0)\n     {\n       /* NaCl uses a special first entry in .iplt too.  */\n       osi.sec = htab->root.iplt;\n@@ -19916,7 +19913,7 @@ elf32_arm_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,\n   if (elf32_arm_hash_table (info) == NULL)\n     return FALSE;\n \n-  if (elf32_arm_hash_table (info)->vxworks_p\n+  if (elf32_arm_hash_table (info)->root.target_os == is_vxworks\n       && !elf_vxworks_add_symbol_hook (abfd, info, sym, namep,\n \t\t\t\t       flagsp, secp, valp))\n     return FALSE;\n@@ -20428,8 +20425,6 @@ elf32_arm_nacl_link_hash_table_create (bfd *abfd)\n       struct elf32_arm_link_hash_table *htab\n \t= (struct elf32_arm_link_hash_table *) ret;\n \n-      htab->nacl_p = 1;\n-\n       htab->plt_header_size = 4 * ARRAY_SIZE (elf32_arm_nacl_plt0_entry);\n       htab->plt_entry_size = 4 * ARRAY_SIZE (elf32_arm_nacl_plt_entry);\n     }\n@@ -20484,6 +20479,8 @@ elf32_arm_nacl_plt_sym_val (bfd_vma i, const asection *plt,\n #undef\tELF_MINPAGESIZE\n #undef\tELF_COMMONPAGESIZE\n \n+#undef ELF_TARGET_OS\n+#define ELF_TARGET_OS\t\t\t\tis_nacl\n \n #include \"elf32-target.h\"\n \n@@ -20566,6 +20563,8 @@ elf32_arm_fdpic_omit_section_dynsym (bfd *output_bfd ATTRIBUTE_UNUSED,\n #undef elf_backend_omit_section_dynsym\n #define elf_backend_omit_section_dynsym\t\telf32_arm_fdpic_omit_section_dynsym\n \n+#undef ELF_TARGET_OS\n+\n #include \"elf32-target.h\"\n \n #undef elf_match_priority\n@@ -20597,7 +20596,6 @@ elf32_arm_vxworks_link_hash_table_create (bfd *abfd)\n       struct elf32_arm_link_hash_table *htab\n \t= (struct elf32_arm_link_hash_table *) ret;\n       htab->use_rel = 0;\n-      htab->vxworks_p = 1;\n     }\n   return ret;\n }\n@@ -20629,6 +20627,8 @@ elf32_arm_vxworks_final_write_processing (bfd *abfd)\n #define elf_backend_want_plt_sym\t1\n #undef  ELF_MAXPAGESIZE\n #define ELF_MAXPAGESIZE\t\t\t0x1000\n+#undef ELF_TARGET_OS\n+#define ELF_TARGET_OS\t\t\tis_vxworks\n \n #include \"elf32-target.h\"\n \n@@ -20885,7 +20885,6 @@ elf32_arm_symbian_link_hash_table_create (bfd *abfd)\n       htab->plt_header_size = 0;\n       /* The PLT entries are each one instruction and one word.  */\n       htab->plt_entry_size = 4 * ARRAY_SIZE (elf32_arm_symbian_plt_entry);\n-      htab->symbian_p = 1;\n       /* Symbian uses armv5t or above, so use_blx is always true.  */\n       htab->use_blx = 1;\n       htab->root.is_relocatable_executable = 1;\n@@ -21016,5 +21015,7 @@ elf32_arm_symbian_plt_sym_val (bfd_vma i, const asection *plt,\n #define elf_backend_dtrel_excludes_plt\t0\n #undef  ELF_MAXPAGESIZE\n #define ELF_MAXPAGESIZE\t\t\t0x8000\n+#undef ELF_TARGET_OS\n+#define ELF_TARGET_OS\t\t\tis_symbian\n \n #include \"elf32-target.h\""
    },
    {
      "sha": "6f4f7f47186ce5cef8078b44313c1d183755c2d6",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 17,
      "deletions": 38,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -843,14 +843,6 @@ static const struct elf_x86_non_lazy_plt_layout elf_i386_non_lazy_ibt_plt =\n #define PLTRESOLVE_RELOCS 2\n #define PLT_NON_JUMP_SLOT_RELOCS 2\n \n-/* These are the standard parameters.  */\n-static const struct elf_x86_backend_data elf_i386_arch_bed =\n-  {\n-    is_normal\t\t\t\t/* os */\n-  };\n-\n-#define\telf_backend_arch_data\t&elf_i386_arch_bed\n-\n /* Return TRUE if the TLS access code sequence support transition\n    from R_TYPE.  */\n \n@@ -2043,7 +2035,7 @@ elf_i386_relocate_section (bfd *output_bfd,\n   local_tlsdesc_gotents = elf_x86_local_tlsdesc_gotent (input_bfd);\n   /* We have to handle relocations in vxworks .tls_vars sections\n      specially, because the dynamic loader is 'weird'.  */\n-  is_vxworks_tls = (htab->target_os == is_vxworks\n+  is_vxworks_tls = (htab->elf.target_os == is_vxworks\n \t\t    && bfd_link_pic (info)\n \t\t    && !strcmp (input_section->output_section->name,\n \t\t\t\t\".tls_vars\"));\n@@ -3597,7 +3589,7 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,\n \t\t      resolved_plt->contents + plt_offset\n \t\t      + htab->plt.plt_got_offset);\n \n-\t  if (htab->target_os == is_vxworks)\n+\t  if (htab->elf.target_os == is_vxworks)\n \t    {\n \t      int s, k, reloc_index;\n \n@@ -4015,7 +4007,7 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,\n \t\t\t  htab->elf.splt->contents\n \t\t\t  + htab->lazy_plt->plt0_got2_offset);\n \n-\t      if (htab->target_os == is_vxworks)\n+\t      if (htab->elf.target_os == is_vxworks)\n \t\t{\n \t\t  Elf_Internal_Rela rel;\n \t\t  int num_plts = (htab->elf.splt->size\n@@ -4156,7 +4148,7 @@ elf_i386_get_synthetic_symtab (bfd *abfd,\n   lazy_plt = NULL;\n   non_lazy_ibt_plt = NULL;\n   lazy_ibt_plt = NULL;\n-  switch (get_elf_x86_backend_data (abfd)->target_os)\n+  switch (get_elf_backend_data (abfd)->target_os)\n     {\n     case is_normal:\n     case is_solaris:\n@@ -4170,6 +4162,8 @@ elf_i386_get_synthetic_symtab (bfd *abfd,\n     case is_nacl:\n       lazy_plt = &elf_i386_nacl_plt;\n       break;\n+    default:\n+      abort ();\n     }\n \n   got_addr = 0;\n@@ -4316,7 +4310,7 @@ elf_i386_link_setup_gnu_properties (struct bfd_link_info *info)\n {\n   struct elf_x86_init_table init_table;\n \n-  switch (get_elf_x86_backend_data (info->output_bfd)->target_os)\n+  switch (get_elf_backend_data (info->output_bfd)->target_os)\n     {\n     case is_normal:\n     case is_solaris:\n@@ -4340,6 +4334,8 @@ elf_i386_link_setup_gnu_properties (struct bfd_link_info *info)\n       init_table.lazy_ibt_plt = NULL;\n       init_table.non_lazy_ibt_plt = NULL;\n       break;\n+    default:\n+      abort ();\n     }\n \n   init_table.r_info = elf32_r_info;\n@@ -4443,13 +4439,8 @@ elf_i386_fbsd_init_file_header (bfd *abfd, struct bfd_link_info *info)\n #undef\tTARGET_LITTLE_NAME\n #define\tTARGET_LITTLE_NAME\t\t\"elf32-i386-sol2\"\n \n-static const struct elf_x86_backend_data elf_i386_solaris_arch_bed =\n-  {\n-    is_solaris\t\t\t\t/* os */\n-  };\n-\n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t\t&elf_i386_solaris_arch_bed\n+#undef\tELF_TARGET_OS\n+#define\tELF_TARGET_OS\t\t\tis_solaris\n \n /* Restore default: we cannot use ELFOSABI_SOLARIS, otherwise ELFOSABI_NONE\n    objects won't be recognized.  */\n@@ -4575,9 +4566,7 @@ elf32_iamcu_elf_object_p (bfd *abfd)\n #undef\tELF_MACHINE_CODE\n #define\tELF_MACHINE_CODE\t\tEM_IAMCU\n \n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t\t&elf_i386_arch_bed\n-\n+#undef\tELF_TARGET_OS\n #undef\tELF_OSABI\n \n #undef  elf32_bed\n@@ -4704,7 +4693,7 @@ static const bfd_byte elf_i386_nacl_eh_frame_plt[] =\n      || PLT_FDE_LENGTH != 36\t\t\t\t\\\n      || PLT_FDE_START_OFFSET != 4 + PLT_CIE_LENGTH + 8\t\\\n      || PLT_FDE_LEN_OFFSET != 4 + PLT_CIE_LENGTH + 12)\n-# error \"Need elf_x86_backend_data parameters for eh_frame_plt offsets!\"\n+# error \"Need PLT_CIE_LENGTH parameters for eh_frame_plt offsets!\"\n #endif\n     PLT_CIE_LENGTH, 0, 0, 0,\t\t/* CIE length */\n     0, 0, 0, 0,\t\t\t\t/* CIE ID */\n@@ -4764,11 +4753,6 @@ static const struct elf_x86_lazy_plt_layout elf_i386_nacl_plt =\n     sizeof (elf_i386_nacl_eh_frame_plt) /* eh_frame_plt_size */\n   };\n \n-static const struct elf_x86_backend_data elf_i386_nacl_arch_bed =\n-  {\n-    is_nacl\t\t\t\t/* os */\n-  };\n-\n static bfd_boolean\n elf32_i386_nacl_elf_object_p (bfd *abfd)\n {\n@@ -4777,8 +4761,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)\n   return TRUE;\n }\n \n-#undef\telf_backend_arch_data\n-#define elf_backend_arch_data\t&elf_i386_nacl_arch_bed\n+#undef\tELF_TARGET_OS\n+#define ELF_TARGET_OS\t\tis_nacl\n \n #undef\telf_backend_object_p\n #define elf_backend_object_p\t\t\telf32_i386_nacl_elf_object_p\n@@ -4809,13 +4793,8 @@ elf32_i386_nacl_elf_object_p (bfd *abfd)\n #undef\telf_backend_plt_alignment\n #define elf_backend_plt_alignment\t4\n \n-static const struct elf_x86_backend_data elf_i386_vxworks_arch_bed =\n-  {\n-    is_vxworks\t\t\t\t/* os */\n-  };\n-\n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t&elf_i386_vxworks_arch_bed\n+#undef\tELF_TARGET_OS\n+#define ELF_TARGET_OS\t\tis_vxworks\n \n #undef elf_backend_relocs_compatible\n #undef elf_backend_add_symbol_hook"
    },
    {
      "sha": "a585e427cc5131dcd61b7d276c1cc4dcef8296d6",
      "filename": "bfd/elf32-mips.c",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mips.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -2670,6 +2670,9 @@ mips_vxworks_final_write_processing (bfd *abfd)\n #define ELF_MAXPAGESIZE\t\t\t0x1000\n #define ELF_COMMONPAGESIZE\t\t0x1000\n \n+#undef ELF_TARGET_OS\n+#define ELF_TARGET_OS\t\t\tis_vxworks\n+\n #undef elf_backend_want_got_plt\n #define elf_backend_want_got_plt\t\t1\n #undef elf_backend_want_plt_sym"
    },
    {
      "sha": "89c069b3c51f4a1c1f46978ff9af4f5f9e59e4c4",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 18,
      "deletions": 19,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -2195,9 +2195,6 @@ struct ppc_elf_link_hash_table\n   /* The type of PLT we have chosen to use.  */\n   enum ppc_elf_plt_type plt_type;\n \n-  /* True if the target system is VxWorks.  */\n-  unsigned int is_vxworks:1;\n-\n   /* Whether there exist local gnu indirect function resolvers,\n      referenced by dynamic relocations.  */\n   unsigned int local_ifunc_resolver:1;\n@@ -2335,7 +2332,7 @@ ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)\n     return FALSE;\n \n   htab = ppc_elf_hash_table (info);\n-  if (!htab->is_vxworks)\n+  if (htab->elf.target_os != is_vxworks)\n     {\n       /* The powerpc .got has a blrl instruction in it.  Mark it\n \t executable.  */\n@@ -2495,7 +2492,7 @@ ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \treturn FALSE;\n     }\n \n-  if (htab->is_vxworks\n+  if (htab->elf.target_os == is_vxworks\n       && !elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))\n     return FALSE;\n \n@@ -2953,7 +2950,7 @@ ppc_elf_check_relocs (bfd *abfd,\n       tls_type = 0;\n       r_type = ELF32_R_TYPE (rel->r_info);\n       ifunc = NULL;\n-      if (h == NULL && !htab->is_vxworks)\n+      if (h == NULL && htab->elf.target_os != is_vxworks)\n \t{\n \t  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,\n \t\t\t\t\t\t\t  abfd, r_symndx);\n@@ -2992,7 +2989,7 @@ ppc_elf_check_relocs (bfd *abfd,\n \t    }\n \t}\n \n-      if (!htab->is_vxworks\n+      if (htab->elf.target_os != is_vxworks\n \t  && is_branch_reloc (r_type)\n \t  && h != NULL\n \t  && h == tga)\n@@ -4798,7 +4795,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t       || (h->non_got_ref\n \t\t   && !h->ref_regular_nonweak\n \t\t   && !UNDEFWEAK_NO_DYNAMIC_RELOC (info, h)))\n-\t      && !htab->is_vxworks\n+\t      && htab->elf.target_os != is_vxworks\n \t      && !ppc_elf_hash_entry (h)->has_sda_refs\n \t      && !_bfd_elf_readonly_dynrelocs (h))\n \t    {\n@@ -4884,7 +4881,7 @@ ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n       executable.  */\n   if (ELIMINATE_COPY_RELOCS\n       && !ppc_elf_hash_entry (h)->has_sda_refs\n-      && !htab->is_vxworks\n+      && htab->elf.target_os != is_vxworks\n       && !h->def_regular\n       && !alias_readonly_dynrelocs (h))\n     return TRUE;\n@@ -5181,7 +5178,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    }\n \t}\n \n-      if (htab->is_vxworks)\n+      if (htab->elf.target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n@@ -5495,7 +5492,7 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (htab->is_vxworks\n+\t      else if (htab->elf.target_os == is_vxworks\n \t\t       && strcmp (p->sec->output_section->name,\n \t\t\t\t  \".tls_vars\") == 0)\n \t\t{\n@@ -5560,7 +5557,7 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n \telse\n \t  *local_got = (bfd_vma) -1;\n \n-      if (htab->is_vxworks)\n+      if (htab->elf.target_os == is_vxworks)\n \tcontinue;\n \n       /* Allocate space for calls to local STT_GNU_IFUNC syms in .iplt.  */\n@@ -5873,7 +5870,7 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n \t  if (!add_dynamic_entry (DT_TEXTREL, 0))\n \t    return FALSE;\n \t}\n-      if (htab->is_vxworks\n+      if (htab->elf.target_os == is_vxworks\n \t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n \treturn FALSE;\n    }\n@@ -6980,7 +6977,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n   sym_hashes = elf_sym_hashes (input_bfd);\n   /* We have to handle relocations in vxworks .tls_vars sections\n      specially, because the dynamic loader is 'weird'.  */\n-  is_vxworks_tls = (htab->is_vxworks && bfd_link_pic (info)\n+  is_vxworks_tls = (htab->elf.target_os == is_vxworks && bfd_link_pic (info)\n \t\t    && !strcmp (input_section->output_section->name,\n \t\t\t\t\".tls_vars\"));\n   if (input_section->sec_info_type == SEC_INFO_TYPE_TARGET)\n@@ -7512,7 +7509,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t}\n \n       ifunc = NULL;\n-      if (!htab->is_vxworks)\n+      if (htab->elf.target_os != is_vxworks)\n \t{\n \t  struct plt_entry *ent;\n \n@@ -9884,7 +9881,7 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,\n \t  switch (dyn.d_tag)\n \t    {\n \t    case DT_PLTGOT:\n-\t      if (htab->is_vxworks)\n+\t      if (htab->elf.target_os == is_vxworks)\n \t\ts = htab->elf.sgotplt;\n \t      else\n \t\ts = htab->elf.splt;\n@@ -9916,7 +9913,7 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,\n \t      continue;\n \n \t    default:\n-\t      if (htab->is_vxworks\n+\t      if (htab->elf.target_os == is_vxworks\n \t\t  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \t\tbreak;\n \t      continue;\n@@ -9968,7 +9965,7 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,\n     }\n \n   /* Fill in the first entry in the VxWorks procedure linkage table.  */\n-  if (htab->is_vxworks\n+  if (htab->elf.target_os == is_vxworks\n       && htab->elf.splt != NULL\n       && htab->elf.splt->size != 0\n       && htab->elf.splt->output_section != bfd_abs_section_ptr)\n@@ -10377,6 +10374,9 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,\n \n #undef  ELF_OSABI\n \n+#undef ELF_TARGET_OS\n+#define ELF_TARGET_OS\t\tis_vxworks\n+\n /* VxWorks uses the elf default section flags for .plt.  */\n static const struct bfd_elf_special_section *\n ppc_elf_vxworks_get_sec_type_attr (bfd *abfd, asection *sec)\n@@ -10402,7 +10402,6 @@ ppc_elf_vxworks_link_hash_table_create (bfd *abfd)\n     {\n       struct ppc_elf_link_hash_table *htab\n \t= (struct ppc_elf_link_hash_table *)ret;\n-      htab->is_vxworks = 1;\n       htab->plt_type = PLT_VXWORKS;\n       htab->plt_entry_size = VXWORKS_PLT_ENTRY_SIZE;\n       htab->plt_slot_size = VXWORKS_PLT_ENTRY_SIZE;"
    },
    {
      "sha": "84afe44f4306beb411aa079bb216579dce80bf6b",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 14,
      "deletions": 15,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -2182,9 +2182,6 @@ struct elf_sh_link_hash_table\n   /* The type of PLT to use.  */\n   const struct elf_sh_plt_info *plt_info;\n \n-  /* True if the target system is VxWorks.  */\n-  bfd_boolean vxworks_p;\n-\n   /* True if the target system uses FDPIC.  */\n   bfd_boolean fdpic_p;\n };\n@@ -2258,7 +2255,6 @@ sh_elf_link_hash_table_create (bfd *abfd)\n       return NULL;\n     }\n \n-  ret->vxworks_p = vxworks_object_p (abfd);\n   ret->fdpic_p = fdpic_object_p (abfd);\n \n   return &ret->root.root;\n@@ -2467,7 +2463,7 @@ sh_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \t}\n     }\n \n-  if (htab->vxworks_p)\n+  if (htab->root.target_os == is_vxworks)\n     {\n       if (!elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))\n \treturn FALSE;\n@@ -2688,7 +2684,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t  /* We also need to make an entry in the .rel.plt section.  */\n \t  htab->root.srelplt->size += sizeof (Elf32_External_Rela);\n \n-\t  if (htab->vxworks_p && !bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks && !bfd_link_pic (info))\n \t    {\n \t      /* VxWorks executables have a second set of relocations\n \t\t for each PLT entry.  They go in a separate relocation\n@@ -2847,7 +2843,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    }\n \t}\n \n-      if (htab->vxworks_p)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n@@ -3006,7 +3002,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (htab->vxworks_p\n+\t      else if (htab->root.target_os == is_vxworks\n \t\t       && strcmp (p->sec->output_section->name,\n \t\t\t\t  \".tls_vars\") == 0)\n \t\t{\n@@ -3250,7 +3246,7 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\treturn FALSE;\n \t    }\n \t}\n-      if (htab->vxworks_p\n+      if (htab->root.target_os == is_vxworks\n \t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n \treturn FALSE;\n     }\n@@ -3490,7 +3486,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,\n \n   /* We have to handle relocations in vxworks .tls_vars sections\n      specially, because the dynamic loader is 'weird'.  */\n-  is_vxworks_tls = (htab && htab->vxworks_p && bfd_link_pic (info)\n+  is_vxworks_tls = (htab && htab->root.target_os == is_vxworks && bfd_link_pic (info)\n \t\t    && !strcmp (input_section->output_section->name,\n \t\t\t\t\".tls_vars\"));\n \n@@ -6080,7 +6076,7 @@ sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,\n \t\t\t     (splt->contents\n \t\t\t      + h->plt.offset\n \t\t\t      + plt_info->symbol_fields.got_entry));\n-\t  if (htab->vxworks_p)\n+\t  if (htab->root.target_os == is_vxworks)\n \t    {\n \t      unsigned int reachable_plts, plts_per_4k;\n \t      int distance;\n@@ -6161,7 +6157,7 @@ sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,\n       loc = srelplt->contents + plt_index * sizeof (Elf32_External_Rela);\n       bfd_elf32_swap_reloca_out (output_bfd, &rel, loc);\n \n-      if (htab->vxworks_p && !bfd_link_pic (info))\n+      if (htab->root.target_os == is_vxworks && !bfd_link_pic (info))\n \t{\n \t  /* Create the .rela.plt.unloaded relocations for this PLT entry.\n \t     Begin by pointing LOC to the first such relocation.  */\n@@ -6284,7 +6280,7 @@ sh_elf_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,\n      _GLOBAL_OFFSET_TABLE_ is not absolute: it is relative to the\n      \".got\" section.  */\n   if (h == htab->root.hdynamic\n-      || (!htab->vxworks_p && h == htab->root.hgot))\n+      || (htab->root.target_os != is_vxworks && h == htab->root.hgot))\n     sym->st_shndx = SHN_ABS;\n \n   return TRUE;\n@@ -6325,7 +6321,7 @@ sh_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t  switch (dyn.d_tag)\n \t    {\n \t    default:\n-\t      if (htab->vxworks_p\n+\t      if (htab->root.target_os == is_vxworks\n \t\t  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \t\tbfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n@@ -6372,7 +6368,7 @@ sh_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t\t\t\t (splt->contents\n \t\t\t\t  + htab->plt_info->plt0_got_fields[i]));\n \n-\t  if (htab->vxworks_p)\n+\t  if (htab->root.target_os == is_vxworks)\n \t    {\n \t      /* Finalize the .rela.plt.unloaded contents.  */\n \t      Elf_Internal_Rela rel;\n@@ -6773,6 +6769,9 @@ sh_elf_encode_eh_address (bfd *abfd,\n #define\tELF_MAXPAGESIZE\t\t\t0x1000\n #undef\tELF_COMMONPAGESIZE\n \n+#undef\tELF_TARGET_OS\n+#define\tELF_TARGET_OS\t\t\tis_vxworks\n+\n #include \"elf32-target.h\"\n \n #endif /* not SH_TARGET_ALREADY_DEFINED */"
    },
    {
      "sha": "4be618cc554d423ea704177cad51a171898fbccf",
      "filename": "bfd/elf32-sparc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 22,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf32-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sparc.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -309,25 +309,6 @@ elf32_sparc_copy_solaris_special_section_fields (const bfd *ibfd ATTRIBUTE_UNUSE\n \n #include \"elf32-target.h\"\n \n-/* A wrapper around _bfd_sparc_elf_link_hash_table_create that identifies\n-   the target system as VxWorks.  */\n-\n-static struct bfd_link_hash_table *\n-elf32_sparc_vxworks_link_hash_table_create (bfd *abfd)\n-{\n-  struct bfd_link_hash_table *ret;\n-\n-  ret = _bfd_sparc_elf_link_hash_table_create (abfd);\n-  if (ret)\n-    {\n-      struct _bfd_sparc_elf_link_hash_table *htab;\n-\n-      htab = (struct _bfd_sparc_elf_link_hash_table *) ret;\n-      htab->is_vxworks = 1;\n-    }\n-  return ret;\n-}\n-\n /* A final_write_processing hook that does both the SPARC- and VxWorks-\n    specific handling.  */\n \n@@ -346,9 +327,8 @@ elf32_sparc_vxworks_final_write_processing (bfd *abfd)\n #undef  ELF_MINPAGESIZE\n #define ELF_MINPAGESIZE\t0x1000\n \n-#undef bfd_elf32_bfd_link_hash_table_create\n-#define bfd_elf32_bfd_link_hash_table_create \\\n-  elf32_sparc_vxworks_link_hash_table_create\n+#undef\tELF_TARGET_OS\n+#define\tELF_TARGET_OS\tis_vxworks\n \n #undef  elf_backend_want_got_plt\n #define elf_backend_want_got_plt\t\t1"
    },
    {
      "sha": "6e6c3c38eaa6a7e6eac7e05b641c138a53ca56c4",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 8,
      "deletions": 25,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -985,12 +985,6 @@ static const struct elf_x86_non_lazy_plt_layout elf_x32_non_lazy_ibt_plt =\n     sizeof (elf_x86_64_eh_frame_non_lazy_plt) /* eh_frame_plt_size */\n   };\n \n-static const struct elf_x86_backend_data elf_x86_64_arch_bed =\n-  {\n-    is_normal\t\t\t\t /* os */\n-  };\n-\n-#define\telf_backend_arch_data\t&elf_x86_64_arch_bed\n \n static bfd_boolean\n elf64_x86_64_elf_object_p (bfd *abfd)\n@@ -4797,7 +4791,7 @@ elf_x86_64_get_synthetic_symtab (bfd *abfd,\n   if (relsize <= 0)\n     return -1;\n \n-  if (get_elf_x86_backend_data (abfd)->target_os != is_nacl)\n+  if (get_elf_backend_data (abfd)->target_os != is_nacl)\n     {\n       lazy_plt = &elf_x86_64_lazy_plt;\n       non_lazy_plt = &elf_x86_64_non_lazy_plt;\n@@ -5148,7 +5142,7 @@ elf_x86_64_link_setup_gnu_properties (struct bfd_link_info *info)\n   /* This is unused for x86-64.  */\n   init_table.plt0_pad_byte = 0x90;\n \n-  if (get_elf_x86_backend_data (info->output_bfd)->target_os != is_nacl)\n+  if (get_elf_backend_data (info->output_bfd)->target_os != is_nacl)\n     {\n       const struct elf_backend_data *bed\n \t= get_elf_backend_data (info->output_bfd);\n@@ -5329,13 +5323,8 @@ elf_x86_64_special_sections[]=\n #undef  TARGET_LITTLE_NAME\n #define TARGET_LITTLE_NAME\t\t    \"elf64-x86-64-sol2\"\n \n-static const struct elf_x86_backend_data elf_x86_64_solaris_arch_bed =\n-  {\n-    is_solaris\t\t\t\t    /* os */\n-  };\n-\n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t\t    &elf_x86_64_solaris_arch_bed\n+#undef ELF_TARGET_OS\n+#define\tELF_TARGET_OS\t\t\t    is_solaris\n \n /* Restore default: we cannot use ELFOSABI_SOLARIS, otherwise ELFOSABI_NONE\n    objects won't be recognized.  */\n@@ -5465,7 +5454,7 @@ static const bfd_byte elf_x86_64_nacl_eh_frame_plt[] =\n      || PLT_FDE_LENGTH != 36\t\t\t\t\\\n      || PLT_FDE_START_OFFSET != 4 + PLT_CIE_LENGTH + 8\t\\\n      || PLT_FDE_LEN_OFFSET != 4 + PLT_CIE_LENGTH + 12)\n-# error \"Need elf_x86_backend_data parameters for eh_frame_plt offsets!\"\n+# error \"Need PLT_CIE_LENGTH parameters for eh_frame_plt offsets!\"\n #endif\n     PLT_CIE_LENGTH, 0, 0, 0,\t/* CIE length */\n     0, 0, 0, 0,\t\t\t/* CIE ID */\n@@ -5525,13 +5514,8 @@ static const struct elf_x86_lazy_plt_layout elf_x86_64_nacl_plt =\n     sizeof (elf_x86_64_nacl_eh_frame_plt)    /* eh_frame_plt_size */\n   };\n \n-static const struct elf_x86_backend_data elf_x86_64_nacl_arch_bed =\n-  {\n-    is_nacl\t\t\t\t     /* os */\n-  };\n-\n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t&elf_x86_64_nacl_arch_bed\n+#undef ELF_TARGET_OS\n+#define\tELF_TARGET_OS\t\t\t\tis_nacl\n \n #undef\telf_backend_object_p\n #define elf_backend_object_p\t\t\telf64_x86_64_nacl_elf_object_p\n@@ -5635,8 +5619,7 @@ elf64_l1om_elf_object_p (bfd *abfd)\n #define ELF_COMMONPAGESIZE\t\t0x1000\n #undef\telf_backend_plt_alignment\n #define elf_backend_plt_alignment\t4\n-#undef\telf_backend_arch_data\n-#define\telf_backend_arch_data\t&elf_x86_64_arch_bed\n+#undef ELF_TARGET_OS\n \n #include \"elf64-target.h\"\n "
    },
    {
      "sha": "60a3c2216f3f10f26c90ae3cccdb88fe65b74411",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -7804,6 +7804,7 @@ _bfd_elf_link_hash_table_init\n \n   table->root.type = bfd_link_elf_hash_table;\n   table->hash_table_id = target_id;\n+  table->target_os = get_elf_backend_data (abfd)->target_os;\n \n   return ret;\n }"
    },
    {
      "sha": "160febec94c9e8c988e7f30de6b2d6d0524f96e6",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 66,
      "deletions": 54,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -462,9 +462,6 @@ struct mips_elf_link_hash_table\n   /* True if we are targetting R6 compact branches.  */\n   bfd_boolean compact_branches;\n \n-  /* True if we're generating code for VxWorks.  */\n-  bfd_boolean is_vxworks;\n-\n   /* True if we already reported the small-data section overflow.  */\n   bfd_boolean small_data_overflow_reported;\n \n@@ -904,7 +901,8 @@ static bfd *reldyn_sorting_bfd;\n \n /* The name of the dynamic relocation section.  */\n #define MIPS_ELF_REL_DYN_NAME(INFO) \\\n-  (mips_elf_hash_table (INFO)->is_vxworks ? \".rela.dyn\" : \".rel.dyn\")\n+  (mips_elf_hash_table (INFO)->root.target_os == is_vxworks \\\n+   ? \".rela.dyn\" : \".rel.dyn\")\n \n /* In case we're on a 32-bit machine, construct a 64-bit \"-1\" value\n    from smaller values.  Start with zero, widen, *then* decrement.  */\n@@ -919,7 +917,8 @@ static bfd *reldyn_sorting_bfd;\n \n /* The offset of $gp from the beginning of the .got section.  */\n #define ELF_MIPS_GP_OFFSET(INFO) \\\n-  (mips_elf_hash_table (INFO)->is_vxworks ? 0x0 : 0x7ff0)\n+  (mips_elf_hash_table (INFO)->root.target_os == is_vxworks \\\n+   ? 0x0 : 0x7ff0)\n \n /* The maximum size of the GOT for it to be addressable using 16-bit\n    offsets from $gp.  */\n@@ -3821,7 +3820,7 @@ mips_elf_create_local_got_entry (bfd *abfd, struct bfd_link_info *info,\n   MIPS_ELF_PUT_WORD (abfd, value, htab->root.sgot->contents + entry->gotidx);\n \n   /* These GOT entries need a dynamic relocation on VxWorks.  */\n-  if (htab->is_vxworks)\n+  if (htab->root.target_os == is_vxworks)\n     {\n       Elf_Internal_Rela outrel;\n       asection *s;\n@@ -4166,7 +4165,7 @@ mips_elf_allocate_dynamic_relocations (bfd *abfd, struct bfd_link_info *info,\n   s = mips_elf_rel_dyn_section (info, FALSE);\n   BFD_ASSERT (s != NULL);\n \n-  if (htab->is_vxworks)\n+  if (htab->root.target_os == is_vxworks)\n     s->size += n * MIPS_ELF_RELA_SIZE (abfd);\n   else\n     {\n@@ -4552,7 +4551,7 @@ mips_elf_count_got_symbols (struct mips_elf_link_hash_entry *h, void *data)\n \t   entry if it was only used for relocations; those relocations\n \t   will be against the null or section symbol instead of H.  */\n \th->global_got_area = GGA_NONE;\n-      else if (htab->is_vxworks\n+      else if (htab->root.target_os == is_vxworks\n \t       && h->got_only_for_calls\n \t       && h->root.plt.plist->mips_offset != MINUS_ONE)\n \t/* On VxWorks, calls can refer directly to the .got.plt entry;\n@@ -5266,7 +5265,7 @@ mips_elf_create_got_section (bfd *abfd, struct bfd_link_info *info)\n static bfd_boolean\n is_gott_symbol (struct bfd_link_info *info, struct elf_link_hash_entry *h)\n {\n-  return (mips_elf_hash_table (info)->is_vxworks\n+  return (mips_elf_hash_table (info)->root.target_os == is_vxworks\n \t  && bfd_link_pic (info)\n \t  && (strcmp (h->root.root.string, \"__GOTT_BASE__\") == 0\n \t      || strcmp (h->root.root.string, \"__GOTT_INDEX__\") == 0));\n@@ -5904,7 +5903,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,\n \t{\n \t  /* On VxWorks, CALL relocations should refer to the .got.plt\n \t     entry, which is initialized to point at the PLT stub.  */\n-\t  if (htab->is_vxworks\n+\t  if (htab->root.target_os == is_vxworks\n \t      && (call_hi16_reloc_p (r_type)\n \t\t  || call_lo16_reloc_p (r_type)\n \t\t  || call16_reloc_p (r_type)))\n@@ -5924,7 +5923,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,\n \t\tMIPS_ELF_PUT_WORD (dynobj, symbol, htab->root.sgot->contents + g);\n \t    }\n \t}\n-      else if (!htab->is_vxworks\n+      else if (htab->root.target_os != is_vxworks\n \t       && (call16_reloc_p (r_type) || got16_reloc_p (r_type)))\n \t/* The calculation below does not involve \"g\".  */\n \tbreak;\n@@ -6206,7 +6205,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,\n     case R_MICROMIPS_CALL16:\n       /* VxWorks does not have separate local and global semantics for\n \t R_MIPS*_GOT16; every relocation evaluates to \"G\".  */\n-      if (!htab->is_vxworks && local_p)\n+      if (htab->root.target_os != is_vxworks && local_p)\n \t{\n \t  value = mips_elf_got16_entry (abfd, input_bfd, info,\n \t\t\t\t\tsymbol + addend, !was_local_p);\n@@ -6745,7 +6744,8 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,\n      in the relocation.  */\n   if (h != NULL && ! SYMBOL_REFERENCES_LOCAL (info, &h->root))\n     {\n-      BFD_ASSERT (htab->is_vxworks || h->global_got_area != GGA_NONE);\n+      BFD_ASSERT (htab->root.target_os == is_vxworks\n+\t\t  || h->global_got_area != GGA_NONE);\n       indx = h->root.dynindx;\n       if (SGI_COMPAT (output_bfd))\n \tdefined_p = h->root.def_regular;\n@@ -6804,7 +6804,7 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,\n   if (defined_p && r_type != R_MIPS_REL32)\n     *addendp += symbol;\n \n-  if (htab->is_vxworks)\n+  if (htab->root.target_os == is_vxworks)\n     /* VxWorks uses non-relative relocations for this.  */\n     outrel[0].r_info = ELF32_R_INFO (indx, R_MIPS_32);\n   else\n@@ -6850,7 +6850,7 @@ mips_elf_create_dynamic_relocation (bfd *output_bfd,\n \t (sreloc->contents\n \t  + sreloc->reloc_count * sizeof (Elf64_Mips_External_Rel)));\n     }\n-  else if (htab->is_vxworks)\n+  else if (htab->root.target_os == is_vxworks)\n     {\n       /* VxWorks uses RELA rather than REL dynamic relocations.  */\n       outrel[0].r_addend = *addendp;\n@@ -7973,7 +7973,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n \n   /* The psABI requires a read-only .dynamic section, but the VxWorks\n      EABI doesn't.  */\n-  if (!htab->is_vxworks)\n+  if (htab->root.target_os != is_vxworks)\n     {\n       s = bfd_get_linker_section (abfd, \".dynamic\");\n       if (s != NULL)\n@@ -8121,7 +8121,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)\n     return FALSE;\n \n   /* Do the usual VxWorks handling.  */\n-  if (htab->is_vxworks\n+  if (htab->root.target_os == is_vxworks\n       && !elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))\n     return FALSE;\n \n@@ -8723,7 +8723,8 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t    elf_hash_table (info)->dynobj = dynobj = abfd;\n \t  if (!mips_elf_create_got_section (dynobj, info))\n \t    return FALSE;\n-\t  if (htab->is_vxworks && !bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks\n+\t      && !bfd_link_pic (info))\n \t    {\n \t      _bfd_error_handler\n \t\t/* xgettext:c-format */\n@@ -8769,7 +8770,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t     against a read-only section.  */\n \t  if ((bfd_link_pic (info)\n \t       || (h != NULL\n-\t\t   && !htab->is_vxworks\n+\t\t   && htab->root.target_os != is_vxworks\n \t\t   && strcmp (h->root.root.string, \"__gnu_local_gp\") != 0\n \t\t   && !(!info->nocopyreloc\n \t\t\t&& !PIC_OBJECT_P (abfd)\n@@ -8811,7 +8812,8 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t relocations related to taking the function's address.\n \t\t This doesn't apply to VxWorks, where CALL relocs refer\n \t\t to a .got.plt entry instead of a normal .got entry.  */\n-\t      if (!htab->is_vxworks && (!can_make_dynamic_p || !call_reloc_p))\n+\t      if (htab->root.target_os != is_vxworks\n+\t\t  && (!can_make_dynamic_p || !call_reloc_p))\n \t\t((struct mips_elf_link_hash_entry *) h)->no_fn_stub = TRUE;\n \t    }\n \n@@ -8836,7 +8838,8 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       else if (call_lo16_reloc_p (r_type)\n \t       || got_lo16_reloc_p (r_type)\n \t       || got_disp_reloc_p (r_type)\n-\t       || (got16_reloc_p (r_type) && htab->is_vxworks))\n+\t       || (got16_reloc_p (r_type)\n+\t\t   && htab->root.target_os == is_vxworks))\n \t{\n \t  /* We may need a local GOT entry for this relocation.  We\n \t     don't count R_MIPS_GOT_PAGE because we can estimate the\n@@ -9200,7 +9203,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n   /* VxWorks executables are handled elsewhere; we only need to\n      allocate relocations in shared objects.  */\n-  if (htab->is_vxworks && !bfd_link_pic (info))\n+  if (htab->root.target_os == is_vxworks && !bfd_link_pic (info))\n     return TRUE;\n \n   /* Ignore indirect symbols.  All relocations against such symbols\n@@ -9245,7 +9248,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t     VxWorks does not enforce the same mapping between the GOT\n \t     and the symbol table, so the same requirement does not\n \t     apply there.  */\n-\t  if (!htab->is_vxworks)\n+\t  if (htab->root.target_os != is_vxworks)\n \t    {\n \t      if (hmips->global_got_area > GGA_RELOC_ONLY)\n \t\thmips->global_got_area = GGA_RELOC_ONLY;\n@@ -9312,7 +9315,9 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n      Traditional stubs are only available on SVR4 psABI-based systems;\n      VxWorks always uses PLTs instead.  */\n-  if (!htab->is_vxworks && h->needs_plt && !hmips->no_fn_stub)\n+  if (htab->root.target_os != is_vxworks\n+      && h->needs_plt\n+      && !hmips->no_fn_stub)\n     {\n       if (! elf_hash_table (info)->dynamic_sections_created)\n \treturn TRUE;\n@@ -9361,7 +9366,7 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t     entry is 16 bytes and the PLT0 entry is 32 bytes.\n \t     Encourage better cache usage by aligning.  We do this\n \t     lazily to avoid pessimizing traditional objects.  */\n-\t  if (!htab->is_vxworks\n+\t  if (htab->root.target_os != is_vxworks\n \t      && !bfd_set_section_alignment (htab->root.splt, 5))\n \t    return FALSE;\n \n@@ -9373,21 +9378,23 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \n \t  /* On non-VxWorks targets, the first two entries in .got.plt\n \t     are reserved.  */\n-\t  if (!htab->is_vxworks)\n+\t  if (htab->root.target_os != is_vxworks)\n \t    htab->plt_got_index\n \t      += (get_elf_backend_data (dynobj)->got_header_size\n \t\t  / MIPS_ELF_GOT_SIZE (dynobj));\n \n \t  /* On VxWorks, also allocate room for the header's\n \t     .rela.plt.unloaded entries.  */\n-\t  if (htab->is_vxworks && !bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks\n+\t      && !bfd_link_pic (info))\n \t    htab->srelplt2->size += 2 * sizeof (Elf32_External_Rela);\n \n \t  /* Now work out the sizes of individual PLT entries.  */\n-\t  if (htab->is_vxworks && bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks\n+\t      && bfd_link_pic (info))\n \t    htab->plt_mips_entry_size\n \t      = 4 * ARRAY_SIZE (mips_vxworks_shared_plt_entry);\n-\t  else if (htab->is_vxworks)\n+\t  else if (htab->root.target_os == is_vxworks)\n \t    htab->plt_mips_entry_size\n \t      = 4 * ARRAY_SIZE (mips_vxworks_exec_plt_entry);\n \t  else if (newabi_p)\n@@ -9430,7 +9437,7 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \t standard entry actually has to be used as the stub ends with a J\n \t instruction.  */\n       if (newabi_p\n-\t  || htab->is_vxworks\n+\t  || htab->root.target_os == is_vxworks\n \t  || hmips->call_stub\n \t  || hmips->call_fp_stub)\n \t{\n@@ -9472,12 +9479,12 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n \thmips->use_plt_entry = TRUE;\n \n       /* Make room for the R_MIPS_JUMP_SLOT relocation.  */\n-      htab->root.srelplt->size += (htab->is_vxworks\n+      htab->root.srelplt->size += (htab->root.target_os == is_vxworks\n \t\t\t\t   ? MIPS_ELF_RELA_SIZE (dynobj)\n \t\t\t\t   : MIPS_ELF_REL_SIZE (dynobj));\n \n       /* Make room for the .rela.plt.unloaded relocations.  */\n-      if (htab->is_vxworks && !bfd_link_pic (info))\n+      if (htab->root.target_os == is_vxworks && !bfd_link_pic (info))\n \thtab->srelplt2->size += 3 * sizeof (Elf32_External_Rela);\n \n       /* All relocations against this symbol that could have been made\n@@ -9542,7 +9549,7 @@ _bfd_mips_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n     }\n   if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)\n     {\n-      if (htab->is_vxworks)\n+      if (htab->root.target_os == is_vxworks)\n \tsrel->size += sizeof (Elf32_External_Rela);\n       else\n \tmips_elf_allocate_dynamic_relocations (dynobj, info, 1);\n@@ -9625,7 +9632,7 @@ mips_elf_lay_out_got (bfd *output_bfd, struct bfd_link_info *info)\n   /* Allocate room for the reserved entries.  VxWorks always reserves\n      3 entries; other objects only reserve 2 entries.  */\n   BFD_ASSERT (g->assigned_low_gotno == 0);\n-  if (htab->is_vxworks)\n+  if (htab->root.target_os == is_vxworks)\n     htab->reserved_gotno = 3;\n   else\n     htab->reserved_gotno = 2;\n@@ -9657,7 +9664,7 @@ mips_elf_lay_out_got (bfd *output_bfd, struct bfd_link_info *info)\n \t}\n     }\n \n-  if (htab->is_vxworks)\n+  if (htab->root.target_os == is_vxworks)\n     /* There's no need to allocate page entries for VxWorks; R_MIPS*_GOT16\n        relocations against local symbols evaluate to \"G\", and the EABI does\n        not include R_MIPS_GOT_PAGE.  */\n@@ -9682,7 +9689,8 @@ mips_elf_lay_out_got (bfd *output_bfd, struct bfd_link_info *info)\n   /* VxWorks does not support multiple GOTs.  It initializes $gp to\n      __GOTT_BASE__[__GOTT_INDEX__], the value of which is set by the\n      dynamic loader.  */\n-  if (!htab->is_vxworks && s->size > MIPS_ELF_GOT_MAX_SIZE (info))\n+  if (htab->root.target_os != is_vxworks\n+      && s->size > MIPS_ELF_GOT_MAX_SIZE (info))\n     {\n       if (!mips_elf_multi_got (output_bfd, info, s, page_gotno))\n \treturn FALSE;\n@@ -9708,7 +9716,7 @@ mips_elf_lay_out_got (bfd *output_bfd, struct bfd_link_info *info)\n \t\t  == g->global_gotno + g->local_gotno + g->tls_gotno);\n \n       /* Each VxWorks GOT entry needs an explicit relocation.  */\n-      if (htab->is_vxworks && bfd_link_pic (info))\n+      if (htab->root.target_os == is_vxworks && bfd_link_pic (info))\n \tg->relocs += g->global_gotno + g->local_gotno - htab->reserved_gotno;\n \n       /* Allocate room for the TLS relocations.  */\n@@ -9890,7 +9898,7 @@ mips_elf_set_plt_sym_value (struct mips_elf_link_hash_entry *h, void *data)\n       /* For VxWorks, point at the PLT load stub rather than the lazy\n \t resolution stub; this stub will become the canonical function\n \t address.  */\n-      if (htab->is_vxworks)\n+      if (htab->root.target_os == is_vxworks)\n \tval += 8;\n \n       h->root.root.u.def.section = htab->root.splt;\n@@ -9955,9 +9963,9 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \t  BFD_ASSERT (htab->root.sgotplt->size == 0);\n \t  BFD_ASSERT (htab->root.splt->size == 0);\n \n-\t  if (htab->is_vxworks && bfd_link_pic (info))\n+\t  if (htab->root.target_os == is_vxworks && bfd_link_pic (info))\n \t    size = 4 * ARRAY_SIZE (mips_vxworks_shared_plt0_entry);\n-\t  else if (htab->is_vxworks)\n+\t  else if (htab->root.target_os == is_vxworks)\n \t    size = 4 * ARRAY_SIZE (mips_vxworks_exec_plt0_entry);\n \t  else if (ABI_64_P (output_bfd))\n \t    size = 4 * ARRAY_SIZE (mips_n64_exec_plt0_entry);\n@@ -10073,7 +10081,8 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \t     room for an extra nop to fill the delay slot.  This is\n \t     for CPUs without load interlocking.  */\n \t  if (! LOAD_INTERLOCKS_P (output_bfd)\n-\t      && ! htab->is_vxworks && s->size > 0)\n+\t      && htab->root.target_os != is_vxworks\n+\t      && s->size > 0)\n \t    s->size += 4;\n \t}\n       else if (! CONST_STRNEQ (name, \".init\")\n@@ -10131,7 +10140,9 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \t  && !MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_DEBUG, 0))\n \treturn FALSE;\n \n-      if (reltext && (SGI_COMPAT (output_bfd) || htab->is_vxworks))\n+      if (reltext\n+\t  && (SGI_COMPAT (output_bfd)\n+\t      || htab->root.target_os == is_vxworks))\n \tinfo->flags |= DF_TEXTREL;\n \n       if ((info->flags & DF_TEXTREL) != 0)\n@@ -10150,7 +10161,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \treturn FALSE;\n \n       sreldyn = mips_elf_rel_dyn_section (info, FALSE);\n-      if (htab->is_vxworks)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  /* VxWorks uses .rela.dyn instead of .rel.dyn.  It does not\n \t     use any of the DT_MIPS_* tags.  */\n@@ -10230,7 +10241,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,\n \t  if (! MIPS_ELF_ADD_DYNAMIC_ENTRY (info, DT_MIPS_PLTGOT, 0))\n \t    return FALSE;\n \t}\n-      if (htab->is_vxworks\n+      if (htab->root.target_os == is_vxworks\n \t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n \treturn FALSE;\n     }\n@@ -10872,7 +10883,7 @@ _bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,\n   dynobj = elf_hash_table (info)->dynobj;\n   hmips = (struct mips_elf_link_hash_entry *) h;\n \n-  BFD_ASSERT (!htab->is_vxworks);\n+  BFD_ASSERT (htab->root.target_os != is_vxworks);\n \n   if (h->plt.plist != NULL\n       && (h->plt.plist->mips_offset != MINUS_ONE\n@@ -11808,7 +11819,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n \t      break;\n \n \t    case DT_RELAENT:\n-\t      BFD_ASSERT (htab->is_vxworks);\n+\t      BFD_ASSERT (htab->root.target_os == is_vxworks);\n \t      dyn.d_un.d_val = MIPS_ELF_RELA_SIZE (dynobj);\n \t      break;\n \n@@ -11947,7 +11958,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n \n \t    case DT_PLTREL:\n \t      BFD_ASSERT (htab->use_plts_and_copy_relocs);\n-\t      if (htab->is_vxworks)\n+\t      if (htab->root.target_os == is_vxworks)\n \t\tdyn.d_un.d_val = DT_RELA;\n \t      else\n \t\tdyn.d_un.d_val = DT_REL;\n@@ -11991,7 +12002,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n \n \t    default:\n \t      swap_out_p = FALSE;\n-\t      if (htab->is_vxworks\n+\t      if (htab->root.target_os == is_vxworks\n \t\t  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \t\tswap_out_p = TRUE;\n \t      break;\n@@ -12016,7 +12027,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n   if (sgot != NULL && sgot->size > 0\n       && !bfd_is_abs_section (sgot->output_section))\n     {\n-      if (htab->is_vxworks)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  /* The first entry of the global offset table points to the\n \t     \".dynamic\" section.  The second is initialized by the\n@@ -12179,7 +12190,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n        increasing order of r_symndx.  The VxWorks EABI doesn't require\n        this, and because the code below handles REL rather than RELA\n        relocations, using it for VxWorks would be outright harmful.  */\n-    if (!htab->is_vxworks)\n+    if (htab->root.target_os != is_vxworks)\n       {\n \ts = mips_elf_rel_dyn_section (info, FALSE);\n \tif (s != NULL\n@@ -12201,7 +12212,7 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,\n \n   if (htab->root.splt && htab->root.splt->size > 0)\n     {\n-      if (htab->is_vxworks)\n+      if (htab->root.target_os == is_vxworks)\n \t{\n \t  if (bfd_link_pic (info))\n \t    mips_vxworks_finish_shared_plt (output_bfd, info);\n@@ -14303,7 +14314,6 @@ _bfd_mips_vxworks_link_hash_table_create (bfd *abfd)\n \n       htab = (struct mips_elf_link_hash_table *) ret;\n       htab->use_plts_and_copy_relocs = TRUE;\n-      htab->is_vxworks = TRUE;\n     }\n   return ret;\n }\n@@ -14682,7 +14692,7 @@ _bfd_mips_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n \telf_gp (abfd) = (h->u.def.value\n \t\t\t + h->u.def.section->output_section->vma\n \t\t\t + h->u.def.section->output_offset);\n-      else if (htab->is_vxworks\n+      else if (htab->root.target_os == is_vxworks\n \t       && (h = bfd_link_hash_lookup (info->hash,\n \t\t\t\t\t     \"_GLOBAL_OFFSET_TABLE_\",\n \t\t\t\t\t     FALSE, FALSE, TRUE))\n@@ -16637,7 +16647,9 @@ _bfd_mips_init_file_header (bfd *abfd, struct bfd_link_info *link_info)\n       BFD_ASSERT (htab != NULL);\n     }\n \n-  if (htab != NULL && htab->use_plts_and_copy_relocs && !htab->is_vxworks)\n+  if (htab != NULL\n+      && htab->use_plts_and_copy_relocs\n+      && htab->root.target_os != is_vxworks)\n     i_ehdrp->e_ident[EI_ABIVERSION] = MIPS_LIBC_ABI_MIPS_PLT;\n \n   if (mips_elf_tdata (abfd)->abiflags.fp_abi == Val_GNU_MIPS_ABI_FP_64"
    },
    {
      "sha": "eca44c9b5f94256909360979f9d409966069cf4b",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 16,
      "deletions": 13,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -1216,7 +1216,7 @@ _bfd_sparc_elf_create_dynamic_sections (bfd *dynobj,\n   if (!_bfd_elf_create_dynamic_sections (dynobj, info))\n     return FALSE;\n \n-  if (htab->is_vxworks)\n+  if (htab->elf.target_os == is_vxworks)\n     {\n       if (!elf_vxworks_create_dynamic_sections (dynobj, info, &htab->srelplt2))\n \treturn FALSE;\n@@ -2076,7 +2076,8 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t      s->size = htab->plt_header_size;\n \n \t      /* Allocate space for the .rela.plt.unloaded relocations.  */\n-\t      if (htab->is_vxworks && !bfd_link_pic (info))\n+\t      if (htab->elf.target_os == is_vxworks\n+\t\t  && !bfd_link_pic (info))\n \t\thtab->srelplt2->size = sizeof (Elf32_External_Rela) * 2;\n \t    }\n \n@@ -2128,7 +2129,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t\thtab->elf.irelplt->size += SPARC_ELF_RELA_BYTES (htab);\n \t    }\n \n-\t  if (htab->is_vxworks)\n+\t  if (htab->elf.target_os == is_vxworks)\n \t    {\n \t      /* Allocate space for the .got.plt entry.  */\n \t      htab->elf.sgotplt->size += 4;\n@@ -2231,7 +2232,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    }\n \t}\n \n-      if (htab->is_vxworks)\n+      if (htab->elf.target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n@@ -2433,7 +2434,7 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (htab->is_vxworks\n+\t      else if (htab->elf.target_os == is_vxworks\n \t\t       && strcmp (p->sec->output_section->name,\n \t\t\t\t  \".tls_vars\") == 0)\n \t\t{\n@@ -2503,7 +2504,7 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,\n   htab_traverse (htab->loc_hash_table, allocate_local_dynrelocs, info);\n \n   if (! ABI_64_P (output_bfd)\n-      && !htab->is_vxworks\n+      && htab->elf.target_os != is_vxworks\n       && elf_hash_table (info)->dynamic_sections_created)\n     {\n       /* Make space for the trailing nop in .plt.  */\n@@ -2829,7 +2830,8 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,\n   sreloc = elf_section_data (input_section)->sreloc;\n   /* We have to handle relocations in vxworks .tls_vars sections\n      specially, because the dynamic loader is 'weird'.  */\n-  is_vxworks_tls = (htab->is_vxworks && bfd_link_pic (info)\n+  is_vxworks_tls = (htab->elf.target_os == is_vxworks\n+\t\t    && bfd_link_pic (info)\n \t\t    && !strcmp (input_section->output_section->name,\n \t\t\t\t\".tls_vars\"));\n \n@@ -4272,7 +4274,7 @@ _bfd_sparc_elf_finish_dynamic_symbol (bfd *output_bfd,\n \tabort ();\n \n       /* Fill in the entry in the .rela.plt section.  */\n-      if (htab->is_vxworks)\n+      if (htab->elf.target_os == is_vxworks)\n \t{\n \t  /* Work out the index of this PLT entry.  */\n \t  rela_index = ((h->plt.offset - htab->plt_header_size)\n@@ -4474,7 +4476,7 @@ _bfd_sparc_elf_finish_dynamic_symbol (bfd *output_bfd,\n      \".got\" section.  Likewise _PROCEDURE_LINKAGE_TABLE_ and \".plt\".  */\n   if (sym != NULL\n       && (h == htab->elf.hdynamic\n-\t  || (!htab->is_vxworks\n+\t  || (htab->elf.target_os != is_vxworks\n \t      && (h == htab->elf.hgot || h == htab->elf.hplt))))\n     sym->st_shndx = SHN_ABS;\n \n@@ -4508,7 +4510,7 @@ sparc_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,\n \n       bed->s->swap_dyn_in (dynobj, dyncon, &dyn);\n \n-      if (htab->is_vxworks && dyn.d_tag == DT_PLTGOT)\n+      if (htab->elf.target_os == is_vxworks && dyn.d_tag == DT_PLTGOT)\n \t{\n \t  /* On VxWorks, DT_PLTGOT should point to the start of the GOT,\n \t     not to the start of the PLT.  */\n@@ -4519,7 +4521,7 @@ sparc_finish_dyn (bfd *output_bfd, struct bfd_link_info *info,\n \t      bed->s->swap_dyn_out (output_bfd, &dyn, dyncon);\n \t    }\n \t}\n-      else if (htab->is_vxworks\n+      else if (htab->elf.target_os == is_vxworks\n \t       && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \tbed->s->swap_dyn_out (output_bfd, &dyn, dyncon);\n       else if (abi_64_p && dyn.d_tag == DT_SPARC_REGISTER)\n@@ -4744,7 +4746,7 @@ _bfd_sparc_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n       /* Initialize the contents of the .plt section.  */\n       if (splt->size > 0)\n \t{\n-\t  if (htab->is_vxworks)\n+\t  if (htab->elf.target_os == is_vxworks)\n \t    {\n \t      if (bfd_link_pic (info))\n \t\tsparc_vxworks_finish_shared_plt (output_bfd, info);\n@@ -4762,7 +4764,8 @@ _bfd_sparc_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *i\n \n       if (elf_section_data (splt->output_section) != NULL)\n \telf_section_data (splt->output_section)->this_hdr.sh_entsize\n-\t  = ((htab->is_vxworks || !ABI_64_P (output_bfd))\n+\t  = ((htab->elf.target_os == is_vxworks\n+\t      || !ABI_64_P (output_bfd))\n \t     ? 0 : htab->plt_entry_size);\n     }\n "
    },
    {
      "sha": "c2b828b49939aa2bfbad9056e3bce8c67746fef0",
      "filename": "bfd/elfxx-target.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-target.h?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -362,6 +362,10 @@\n #define ELF_TARGET_ID\tGENERIC_ELF_DATA\n #endif\n \n+#ifndef ELF_TARGET_OS\n+#define ELF_TARGET_OS\tis_normal\n+#endif\n+\n #ifndef ELF_OSABI\n #define ELF_OSABI ELFOSABI_NONE\n #endif\n@@ -799,6 +803,7 @@ static struct elf_backend_data elfNN_bed =\n {\n   ELF_ARCH,\t\t\t/* arch */\n   ELF_TARGET_ID,\t\t/* target_id */\n+  ELF_TARGET_OS,\t\t/* target_os */\n   ELF_MACHINE_CODE,\t\t/* elf_machine_code */\n   ELF_OSABI,\t\t\t/* elf_osabi  */\n   ELF_MAXPAGESIZE,\t\t/* maxpagesize */"
    },
    {
      "sha": "6b8e56d7a07a8e60488d45ddb6f3dd1c2ecd549c",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -260,7 +260,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t}\n \t    }\n \n-\t  if (htab->target_os == is_vxworks && !bfd_link_pic (info))\n+\t  if (htab->elf.target_os == is_vxworks && !bfd_link_pic (info))\n \t    {\n \t      /* VxWorks has a second set of relocations for each PLT entry\n \t\t in executables.  They go in a separate relocation section,\n@@ -407,7 +407,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t    }\n \t}\n \n-      if (htab->target_os == is_vxworks)\n+      if (htab->elf.target_os == is_vxworks)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \t  for (pp = &h->dyn_relocs; (p = *pp) != NULL; )\n@@ -762,7 +762,6 @@ _bfd_x86_elf_link_hash_table_create (bfd *abfd)\n \t  ret->tls_get_addr = \"___tls_get_addr\";\n \t}\n     }\n-  ret->target_os = get_elf_x86_backend_data (abfd)->target_os;\n \n   ret->loc_hash_table = htab_try_create (1024,\n \t\t\t\t\t _bfd_x86_elf_local_htab_hash,\n@@ -1045,7 +1044,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (htab->target_os == is_vxworks\n+\t      else if (htab->elf.target_os == is_vxworks\n \t\t       && strcmp (p->sec->output_section->name,\n \t\t\t\t  \".tls_vars\") == 0)\n \t\t{\n@@ -1203,7 +1202,8 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t  htab->elf.sgotplt->size = 0;\n \t  /* Solaris requires to keep _GLOBAL_OFFSET_TABLE_ even if it\n \t     isn't used.  */\n-\t  if (htab->elf.hgot != NULL && htab->target_os != is_solaris)\n+\t  if (htab->elf.hgot != NULL\n+\t      && htab->elf.target_os != is_solaris)\n \t    {\n \t      /* Remove the unused _GLOBAL_OFFSET_TABLE_ from symbol\n \t\t table. */\n@@ -1430,7 +1430,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t\treturn FALSE;\n \t    }\n \t}\n-      if (htab->target_os == is_vxworks\n+      if (htab->elf.target_os == is_vxworks\n \t  && !elf_vxworks_add_dynamic_entries (output_bfd, info))\n \treturn FALSE;\n     }\n@@ -1522,7 +1522,7 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,\n       switch (dyn.d_tag)\n \t{\n \tdefault:\n-\t  if (htab->target_os == is_vxworks\n+\t  if (htab->elf.target_os == is_vxworks\n \t      && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))\n \t    break;\n \t  continue;\n@@ -1987,7 +1987,7 @@ _bfd_x86_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n   if (ELIMINATE_COPY_RELOCS\n       && (bed->target_id == X86_64_ELF_DATA\n \t  || (!eh->gotoff_ref\n-\t      && htab->target_os != is_vxworks)))\n+\t      && htab->elf.target_os != is_vxworks)))\n     {\n       /* If we don't find any dynamic relocs in read-only sections,\n \t then we'll be keeping the dynamic relocs and avoiding the copy\n@@ -2762,7 +2762,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n      still be used with LD_AUDIT or LD_PROFILE if PLT entry is used for\n      canonical function address.  */\n   htab->plt.has_plt0 = 1;\n-  normal_target = htab->target_os == is_normal;\n+  normal_target = htab->elf.target_os == is_normal;\n \n   if (normal_target)\n     {\n@@ -2825,7 +2825,7 @@ _bfd_x86_elf_link_setup_gnu_properties\n       htab->plt.eh_frame_plt = htab->lazy_plt->eh_frame_plt;\n     }\n \n-  if (htab->target_os == is_vxworks\n+  if (htab->elf.target_os == is_vxworks\n       && !elf_vxworks_create_dynamic_sections (dynobj, info,\n \t\t\t\t\t       &htab->srelplt2))\n     {"
    },
    {
      "sha": "7cdc4323abe392935ce4b74572e7e2a0cfedb9ba",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 0,
      "deletions": 21,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/90c14f0c3ac0252be955990e0ae120faedfb7b59/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=90c14f0c3ac0252be955990e0ae120faedfb7b59",
      "patch": "@@ -436,14 +436,6 @@ struct elf_x86_plt_layout\n #define elf_x86_hash_entry(ent) \\\n   ((struct elf_x86_link_hash_entry *)(ent))\n \n-enum elf_x86_target_os\n-{\n-  is_normal,\n-  is_solaris,\n-  is_vxworks,\n-  is_nacl\n-};\n-\n /* x86 ELF linker hash table.  */\n \n struct elf_x86_link_hash_table\n@@ -531,7 +523,6 @@ struct elf_x86_link_hash_table\n   bfd_vma (*r_info) (bfd_vma, bfd_vma);\n   bfd_vma (*r_sym) (bfd_vma);\n   bfd_boolean (*is_reloc_section) (const char *);\n-  enum elf_x86_target_os target_os;\n   unsigned int sizeof_reloc;\n   unsigned int dt_reloc;\n   unsigned int dt_reloc_sz;\n@@ -546,18 +537,6 @@ struct elf_x86_link_hash_table\n   struct elf_linker_x86_params *params;\n };\n \n-/* Architecture-specific backend data for x86.  */\n-\n-struct elf_x86_backend_data\n-{\n-  /* Target system.  */\n-  enum elf_x86_target_os target_os;\n-};\n-\n-#define get_elf_x86_backend_data(abfd) \\\n-  ((const struct elf_x86_backend_data *) \\\n-   get_elf_backend_data (abfd)->arch_data)\n-\n struct elf_x86_init_table\n {\n   /* The lazy PLT layout.  */"
    }
  ]
}