{
  "sha": "014cc7f849e8209623fc99264814bce7b3b6faf2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDE0Y2M3Zjg0OWU4MjA5NjIzZmM5OTI2NDgxNGJjZTdiM2I2ZmFmMg==",
  "commit": {
    "author": {
      "name": "Siddhesh Poyarekar",
      "email": "siddhesh@gotplt.org",
      "date": "2020-12-07T15:18:33Z"
    },
    "committer": {
      "name": "Siddhesh Poyarekar",
      "email": "siddhesh@gotplt.org",
      "date": "2020-12-07T15:18:33Z"
    },
    "message": "binutils: Make smart_rename safe too\n\nsmart_rename is capable of handling symlinks by copying and it also\ntries to preserve ownership and permissions of files when they're\noverwritten during the rename.  This is useful in objcopy where the\nfile properties need to be preserved.\n\nHowever because smart_rename does this using file names, it leaves a\nrace window between renames and permission fixes.  This change removes\nthis race window by using file descriptors from the original BFDs that\nwere used to manipulate these files wherever possible.\n\nThe file that is to be renamed is also passed as a file descriptor so\nthat we use fchown/fchmod on the file descriptor, thus making sure\nthat we only modify the file we have opened to write.  Further, in\ncase the file is to be overwritten (as is the case in ar or objcopy),\nthe permissions that need to be restored are taken from the file\ndescriptor that was opened for input so that integrity of the file\nstatus is maintained all the way through to the rename.\n\nbinutils/\n\n\t* rename.c\n\t* ar.c\n\t(write_archive) [!defined (_WIN32) || defined (__CYGWIN32__)]:\n\tInitialize TARGET_STAT and OFD to pass to SMART_RENAME.\n\t* arsup.c\n\t(ar_save) [defined (_WIN32) || defined (__CYGWIN32__)]:\n\tLikewise.\n\t* bucomm.h (smart_rename): Add new arguments to declaration.\n\t* objcopy.c\n\t(strip_main)[defined (_WIN32) || defined (__CYGWIN32__)]:\n\tInitialize COPYFD and pass to SMART_RENAME.\n\t(copy_main) [defined (_WIN32) || defined (__CYGWIN32__)]:\n\tLikewise.\n\t* rename.c (try_preserve_permissions): New function.\n\t(smart_rename): Use it and add new arguments.",
    "tree": {
      "sha": "890c586d1a37643dfa2aa394935748a5e6542f51",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/890c586d1a37643dfa2aa394935748a5e6542f51"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/014cc7f849e8209623fc99264814bce7b3b6faf2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/014cc7f849e8209623fc99264814bce7b3b6faf2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/014cc7f849e8209623fc99264814bce7b3b6faf2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/014cc7f849e8209623fc99264814bce7b3b6faf2/comments",
  "author": {
    "login": "siddhesh",
    "id": 158582,
    "node_id": "MDQ6VXNlcjE1ODU4Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/siddhesh",
    "html_url": "https://github.com/siddhesh",
    "followers_url": "https://api.github.com/users/siddhesh/followers",
    "following_url": "https://api.github.com/users/siddhesh/following{/other_user}",
    "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions",
    "organizations_url": "https://api.github.com/users/siddhesh/orgs",
    "repos_url": "https://api.github.com/users/siddhesh/repos",
    "events_url": "https://api.github.com/users/siddhesh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/siddhesh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "siddhesh",
    "id": 158582,
    "node_id": "MDQ6VXNlcjE1ODU4Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/siddhesh",
    "html_url": "https://github.com/siddhesh",
    "followers_url": "https://api.github.com/users/siddhesh/followers",
    "following_url": "https://api.github.com/users/siddhesh/following{/other_user}",
    "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions",
    "organizations_url": "https://api.github.com/users/siddhesh/orgs",
    "repos_url": "https://api.github.com/users/siddhesh/repos",
    "events_url": "https://api.github.com/users/siddhesh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/siddhesh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1a1c3b4cc17687091cff5a368bd6f13742bcfdf8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1a1c3b4cc17687091cff5a368bd6f13742bcfdf8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1a1c3b4cc17687091cff5a368bd6f13742bcfdf8"
    }
  ],
  "stats": {
    "total": 190,
    "additions": 148,
    "deletions": 42
  },
  "files": [
    {
      "sha": "5f6d98f0701bf507f6be82f0a1663597d07bd3ef",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -1,3 +1,21 @@\n+2020-12-07  Siddhesh Poyarekar  <siddhesh@sourceware.org>\n+\n+\tPR 26945\n+\t* ar.c\n+\t(write_archive) [!defined (_WIN32) || defined (__CYGWIN32__)]:\n+\tInitialize TARGET_STAT and OFD to pass to SMART_RENAME.\n+\t* arsup.c\n+\t(ar_save) [defined (_WIN32) || defined (__CYGWIN32__)]:\n+\tLikewise.\n+\t* bucomm.h (smart_rename): Add new arguments to declaration.\n+\t* objcopy.c\n+\t(strip_main)[defined (_WIN32) || defined (__CYGWIN32__)]:\n+\tInitialize COPYFD and pass to SMART_RENAME.\n+\t(copy_main) [defined (_WIN32) || defined (__CYGWIN32__)]:\n+\tLikewise.\n+\t* rename.c (try_preserve_permissions): New function.\n+\t(smart_rename): Use it and add new arguments.\n+\n 2020-12-07  Siddhesh Poyarekar  <siddhesh@sourceware.org>\n \n \tPR 26945"
    },
    {
      "sha": "6598dd9012c7973cc49e0a062fed5758a47c9833",
      "filename": "binutils/ar.c",
      "status": "modified",
      "additions": 11,
      "deletions": 1,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/ar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/ar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ar.c?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -1254,6 +1254,8 @@ write_archive (bfd *iarch)\n   char *old_name, *new_name;\n   bfd *contents_head = iarch->archive_next;\n   int ofd = -1;\n+  struct stat target_stat;\n+  bfd_boolean skip_stat = FALSE;\n \n   old_name = (char *) xmalloc (strlen (bfd_get_filename (iarch)) + 1);\n   strcpy (old_name, bfd_get_filename (iarch));\n@@ -1299,6 +1301,14 @@ write_archive (bfd *iarch)\n   if (!bfd_set_archive_head (obfd, contents_head))\n     bfd_fatal (old_name);\n \n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+  ofd = dup (ofd);\n+  if (iarch == NULL || iarch->iostream == NULL)\n+    skip_stat = TRUE;\n+  else if (ofd == -1 || fstat (fileno (iarch->iostream), &target_stat) != 0)\n+    bfd_fatal (old_name);\n+#endif\n+\n   if (!bfd_close (obfd))\n     bfd_fatal (old_name);\n \n@@ -1308,7 +1318,7 @@ write_archive (bfd *iarch)\n   /* We don't care if this fails; we might be creating the archive.  */\n   bfd_close (iarch);\n \n-  if (smart_rename (new_name, old_name, 0) != 0)\n+  if (smart_rename (new_name, old_name, ofd, skip_stat ? NULL : &target_stat, 0) != 0)\n     xexit (1);\n   free (old_name);\n   free (new_name);"
    },
    {
      "sha": "8b4437ff41741f670d453a401f4ce7c0356eb3f9",
      "filename": "binutils/arsup.c",
      "status": "modified",
      "additions": 13,
      "deletions": 1,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/arsup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/arsup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/arsup.c?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -345,13 +345,25 @@ ar_save (void)\n   else\n     {\n       char *ofilename = xstrdup (bfd_get_filename (obfd));\n+      bfd_boolean skip_stat = FALSE;\n+      struct stat target_stat;\n+      int ofd = -1;\n \n       if (deterministic > 0)\n         obfd->flags |= BFD_DETERMINISTIC_OUTPUT;\n \n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+      /* It's OK to fail; at worst it will result in SMART_RENAME using a slow\n+         copy fallback to write the output.  */\n+      ofd = dup (fileno (obfd->iostream));\n+      if (lstat (real_name, &target_stat) != 0)\n+\tskip_stat = TRUE;\n+#endif\n+\n       bfd_close (obfd);\n \n-      smart_rename (ofilename, real_name, 0);\n+      smart_rename (ofilename, real_name, ofd,\n+\t\t    skip_stat ? NULL : &target_stat, 0);\n       obfd = 0;\n       free (ofilename);\n     }"
    },
    {
      "sha": "9613b922d5dda8604660461edc725b3c9b7bf8e5",
      "filename": "binutils/bucomm.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/bucomm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/bucomm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bucomm.h?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -71,7 +71,8 @@ extern void print_version (const char *);\n /* In rename.c.  */\n extern void set_times (const char *, const struct stat *);\n \n-extern int smart_rename (const char *, const char *, int);\n+extern int smart_rename (const char *, const char *, int, struct stat *, int);\n+\n \n /* In libiberty.  */\n void *xmalloc (size_t);"
    },
    {
      "sha": "04ba95ec14014d086a7669e8f6cf33f55cf2d6da",
      "filename": "binutils/objcopy.c",
      "status": "modified",
      "additions": 34,
      "deletions": 8,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/objcopy.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/objcopy.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objcopy.c?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -4815,6 +4815,7 @@ strip_main (int argc, char *argv[])\n       struct stat statbuf;\n       char *tmpname;\n       int tmpfd = -1;\n+      int copyfd = -1;\n \n       if (get_file_size (argv[i]) < 1)\n \t{\n@@ -4828,7 +4829,12 @@ strip_main (int argc, char *argv[])\n       else\n \ttmpname = output_file;\n \n-      if (tmpname == NULL)\n+      if (tmpname == NULL\n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+\t  /* Retain a copy of TMPFD since we will need it for SMART_RENAME.  */\n+\t  || (tmpfd >= 0 && (copyfd = dup (tmpfd)) == -1)\n+#endif\n+      )\n \t{\n \t  bfd_nonfatal_message (argv[i], NULL, NULL,\n \t\t\t\t_(\"could not create temporary file to hold stripped copy\"));\n@@ -4846,12 +4852,18 @@ strip_main (int argc, char *argv[])\n \t  if (output_file != tmpname)\n \t    status = (smart_rename (tmpname,\n \t\t\t\t    output_file ? output_file : argv[i],\n-\t\t\t\t    preserve_dates) != 0);\n+\t\t\t\t    copyfd, &statbuf, preserve_dates) != 0);\n \t  if (status == 0)\n \t    status = hold_status;\n \t}\n       else\n-\tunlink_if_ordinary (tmpname);\n+\t{\n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+\t  if (copyfd >= 0)\n+\t    close (copyfd);\n+#endif\n+\t  unlink_if_ordinary (tmpname);\n+\t}\n       if (output_file != tmpname)\n \tfree (tmpname);\n     }\n@@ -5059,6 +5071,7 @@ copy_main (int argc, char *argv[])\n   bfd_boolean use_globalize = FALSE;\n   bfd_boolean use_keep_global = FALSE;\n   int c, tmpfd = -1;\n+  int copyfd = -1;\n   struct stat statbuf;\n   const bfd_arch_info_type *input_arch = NULL;\n \n@@ -5903,9 +5916,16 @@ copy_main (int argc, char *argv[])\n   else\n     tmpname = output_filename;\n \n-  if (tmpname == NULL)\n-    fatal (_(\"warning: could not create temporary file whilst copying '%s', (error: %s)\"),\n-\t   input_filename, strerror (errno));\n+  if (tmpname == NULL\n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+      /* Retain a copy of TMPFD since we will need it for SMART_RENAME.  */\n+      || (tmpfd >= 0 && (copyfd = dup (tmpfd)) == -1)\n+#endif\n+  )\n+    {\n+      fatal (_(\"warning: could not create temporary file whilst copying '%s', (error: %s)\"),\n+\t     input_filename, strerror (errno));\n+    }\n \n   copy_file (input_filename, tmpname, tmpfd, &statbuf, input_target,\n \t     output_target, input_arch);\n@@ -5914,11 +5934,17 @@ copy_main (int argc, char *argv[])\n       if (preserve_dates)\n \tset_times (tmpname, &statbuf);\n       if (tmpname != output_filename)\n-\tstatus = (smart_rename (tmpname, input_filename,\n+\tstatus = (smart_rename (tmpname, input_filename, copyfd, &statbuf,\n \t\t\t\tpreserve_dates) != 0);\n     }\n   else\n-    unlink_if_ordinary (tmpname);\n+    {\n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+      if (copyfd >= 0)\n+\tclose (copyfd);\n+#endif\n+      unlink_if_ordinary (tmpname);\n+    }\n \n   if (tmpname != output_filename)\n     free (tmpname);"
    },
    {
      "sha": "6b9165ea1c908b17089c77d8e0c5cbc7944f023c",
      "filename": "binutils/rename.c",
      "status": "modified",
      "additions": 70,
      "deletions": 31,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/rename.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/014cc7f849e8209623fc99264814bce7b3b6faf2/binutils/rename.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rename.c?ref=014cc7f849e8209623fc99264814bce7b3b6faf2",
      "patch": "@@ -131,17 +131,55 @@ set_times (const char *destination, const struct stat *statbuf)\n #endif\n #endif\n \n-/* Rename FROM to TO, copying if TO is a link.\n-   Return 0 if ok, -1 if error.  */\n+#if !defined (_WIN32) || defined (__CYGWIN32__)\n+/* Try to preserve the permission bits and ownership of an existing file when\n+   rename overwrites it.  FD is the file being renamed and TARGET_STAT has the\n+   status of the file that was overwritten.  */\n+static void\n+try_preserve_permissions (int fd, struct stat *target_stat)\n+{\n+  struct stat from_stat;\n+  int ret = 0;\n+\n+  if (fstat (fd, &from_stat) != 0)\n+    return;\n+\n+  int from_mode = from_stat.st_mode & 0777;\n+  int to_mode = target_stat->st_mode & 0777;\n+\n+  /* Fix up permissions before we potentially lose ownership with fchown.\n+     Clear the setxid bits because in case the fchown below fails then we don't\n+     want to end up with a sxid file owned by the invoking user.  If the user\n+     hasn't changed or if fchown succeeded, we add back the sxid bits at the\n+     end.  */\n+  if (from_mode != to_mode)\n+    fchmod (fd, to_mode);\n+\n+  /* Fix up ownership, this will clear the setxid bits.  */\n+  if (from_stat.st_uid != target_stat->st_uid\n+      || from_stat.st_gid != target_stat->st_gid)\n+    ret = fchown (fd, target_stat->st_uid, target_stat->st_gid);\n+\n+  /* Fix up the sxid bits if either the fchown wasn't needed or it\n+     succeeded.  */\n+  if (ret == 0)\n+    fchmod (fd, target_stat->st_mode & 07777);\n+}\n+#endif\n+\n+/* Rename FROM to TO, copying if TO is either a link or is not a regular file.\n+   FD is an open file descriptor pointing to FROM that we can use to safely fix\n+   up permissions of the file after renaming.  TARGET_STAT has the file status\n+   that is used to fix up permissions and timestamps after rename.  Return 0 if\n+   ok, -1 if error and FD is closed before returning.  */\n \n int\n-smart_rename (const char *from, const char *to, int preserve_dates ATTRIBUTE_UNUSED)\n+smart_rename (const char *from, const char *to, int fd ATTRIBUTE_UNUSED,\n+\t      struct stat *target_stat ATTRIBUTE_UNUSED,\n+\t      int preserve_dates ATTRIBUTE_UNUSED)\n {\n-  bfd_boolean exists;\n-  struct stat s;\n   int ret = 0;\n-\n-  exists = lstat (to, &s) == 0;\n+  bfd_boolean exists = target_stat != NULL;\n \n #if defined (_WIN32) && !defined (__CYGWIN32__)\n   /* Win32, unlike unix, will not erase `to' in `rename(from, to)' but\n@@ -158,36 +196,35 @@ smart_rename (const char *from, const char *to, int preserve_dates ATTRIBUTE_UNU\n       unlink (from);\n     }\n #else\n-  /* Use rename only if TO is not a symbolic link and has\n-     only one hard link, and we have permission to write to it.  */\n+  /* Avoid a full copy and use rename if we can fix up permissions of the\n+     file after renaming, i.e.:\n+\n+     - TO is not a symbolic link\n+     - TO is a regular file with only one hard link\n+     - We have permission to write to TO\n+     - FD is available to safely fix up permissions to be the same as the file\n+       we overwrote with the rename.\n+\n+     Note though that the actual file on disk that TARGET_STAT describes may\n+     have changed and we're only trying to preserve the status we know about.\n+     At no point do we try to interact with the new file changes, so there can\n+     only be two outcomes, i.e. either the external file change survives\n+     without knowledge of our change (if it happens after the rename syscall)\n+     or our rename and permissions fixup survive without any knowledge of the\n+     external change.  */\n   if (! exists\n-      || (!S_ISLNK (s.st_mode)\n-\t  && S_ISREG (s.st_mode)\n-\t  && (s.st_mode & S_IWUSR)\n-\t  && s.st_nlink == 1)\n+      || (fd >= 0\n+\t  && !S_ISLNK (target_stat->st_mode)\n+\t  && S_ISREG (target_stat->st_mode)\n+\t  && (target_stat->st_mode & S_IWUSR)\n+\t  && target_stat->st_nlink == 1)\n       )\n     {\n       ret = rename (from, to);\n       if (ret == 0)\n \t{\n \t  if (exists)\n-\t    {\n-\t      /* Try to preserve the permission bits and ownership of\n-\t\t TO.  First get the mode right except for the setuid\n-\t\t bit.  Then change the ownership.  Then fix the setuid\n-\t\t bit.  We do the chmod before the chown because if the\n-\t\t chown succeeds, and we are a normal user, we won't be\n-\t\t able to do the chmod afterward.  We don't bother to\n-\t\t fix the setuid bit first because that might introduce\n-\t\t a fleeting security problem, and because the chown\n-\t\t will clear the setuid bit anyhow.  We only fix the\n-\t\t setuid bit if the chown succeeds, because we don't\n-\t\t want to introduce an unexpected setuid file owned by\n-\t\t the user running objcopy.  */\n-\t      chmod (to, s.st_mode & 0777);\n-\t      if (chown (to, s.st_uid, s.st_gid) >= 0)\n-\t\tchmod (to, s.st_mode & 07777);\n-\t    }\n+\t    try_preserve_permissions (fd, target_stat);\n \t}\n       else\n \t{\n@@ -203,9 +240,11 @@ smart_rename (const char *from, const char *to, int preserve_dates ATTRIBUTE_UNU\n \tnon_fatal (_(\"unable to copy file '%s'; reason: %s\"), to, strerror (errno));\n \n       if (preserve_dates)\n-\tset_times (to, &s);\n+\tset_times (to, target_stat);\n       unlink (from);\n     }\n+  if (fd >= 0)\n+    close (fd);\n #endif /* _WIN32 && !__CYGWIN32__ */\n \n   return ret;"
    }
  ]
}