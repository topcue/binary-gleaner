{
  "sha": "53651de80f811495262a5b17b774a486dd37b326",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTM2NTFkZTgwZjgxMTQ5NTI2MmE1YjE3Yjc3NGE0ODZkZDM3YjMyNg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-23T21:17:44Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-25T19:11:35Z"
    },
    "message": "libctf, include: support foreign-endianness symtabs with CTF\n\nThe CTF symbol lookup machinery added recently has one deficit: it\nassumes the symtab is in the machine's native endianness.  This is\nalways true when the linker is writing out symtabs (because cross\nlinkers byteswap symbols only after libctf has been called on them), but\nmay be untrue in the cross case when the linker or another tool\n(objdump, etc) is reading them.\n\nUnfortunately the easy way to model this to the caller, as an endianness\nfield in the ctf_sect_t, is precluded because doing so would change the\nsize of the ctf_sect_t, which would be an ABI break.  So, instead, allow\nthe endianness of the symtab to be set after open time, by calling one\nof the two new API functions ctf_symsect_endianness (for ctf_dict_t's)\nor ctf_arc_symsect_endianness (for entire ctf_archive_t's).  libctf\ncalls these functions automatically for objects opened via any of the\nBFD-aware mechanisms (ctf_bfdopen, ctf_bfdopen_ctfsect, ctf_fdopen,\nctf_open, or ctf_arc_open), but the various mechanisms that just take\nraw ctf_sect_t's will assume the symtab is in native endianness and need\na later call to ctf_*symsect_endianness to adjust it if needed.  (This\ncall is basically free if the endianness is actually native: it only\ncosts anything if the symtab endianness was previously guessed wrong,\nand there is a symtab, and we are using it directly rather than using\nsymtab indexing.)\n\nObviously, calling ctf_lookup_by_symbol or ctf_symbol_next before the\nsymtab endianness is correctly set will probably give wrong answers --\nbut you can set it at any time as long as it is before then.\n\ninclude/ChangeLog\n2020-11-23  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h: Style nit: remove () on function names in comments.\n\t(ctf_sect_t): Mention endianness concerns.\n\t(ctf_symsect_endianness): New declaration.\n\t(ctf_arc_symsect_endianness): Likewise.\n\nlibctf/ChangeLog\n2020-11-23  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_dict_t) <ctf_symtab_little_endian>: New.\n\t(struct ctf_archive_internal) <ctfi_symsect_little_endian>: Likewise.\n\t* ctf-create.c (ctf_serialize): Adjust for new field.\n\t* ctf-open.c (init_symtab): Note the semantics of repeated calls.\n\t(ctf_symsect_endianness): New.\n\t(ctf_bufopen_internal): Set ctf_symtab_little_endian suitably for\n\tthe native endianness.\n\t(_Static_assert): Moved...\n\t(swap_thing): ... with this...\n\t* swap.h: ... to here.\n\t* ctf-util.c (ctf_elf32_to_link_sym): Use it, byteswapping the\n\tElf32_Sym if the ctf_symtab_little_endian demands it.\n\t(ctf_elf64_to_link_sym): Likewise swap the Elf64_Sym if needed.\n\t* ctf-archive.c (ctf_arc_symsect_endianness): New, set the\n\tendianness of the symtab used by the dicts in an archive.\n\t(ctf_archive_iter_internal): Initialize to unknown (assumed native,\n\tdo not call ctf_symsect_endianness).\n\t(ctf_dict_open_by_offset): Call ctf_symsect_endianness if need be.\n\t(ctf_dict_open_internal): Propagate the endianness down.\n\t(ctf_dict_open_sections): Likewise.\n\t* ctf-open-bfd.c (ctf_bfdopen_ctfsect): Get the endianness from the\n\tstruct bfd and pass it down to the archive.\n\t* libctf.ver: Add ctf_symsect_endianness and\n\tctf_arc_symsect_endianness.",
    "tree": {
      "sha": "597993b81493a294506b5b721204adebf995b0d9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/597993b81493a294506b5b721204adebf995b0d9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/53651de80f811495262a5b17b774a486dd37b326",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/53651de80f811495262a5b17b774a486dd37b326",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/53651de80f811495262a5b17b774a486dd37b326",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/53651de80f811495262a5b17b774a486dd37b326/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cbfa382abb360307c0c6b750e4c550a0d2b702d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cbfa382abb360307c0c6b750e4c550a0d2b702d6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cbfa382abb360307c0c6b750e4c550a0d2b702d6"
    }
  ],
  "stats": {
    "total": 253,
    "additions": 197,
    "deletions": 56
  },
  "files": [
    {
      "sha": "281612918804c5ca0611ebda55120fb3625a7ddd",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -1,3 +1,10 @@\n+2020-11-23  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h: Style nit: remove () on function names in comments.\n+\t(ctf_sect_t): Mention endianness concerns.\n+\t(ctf_symsect_endianness): New declaration.\n+\t(ctf_arc_symsect_endianness): Likewise.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_getsymsect): New."
    },
    {
      "sha": "9dd0592ab8a3c73ab600bdb834a082d17b735422",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 17,
      "deletions": 13,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -51,10 +51,12 @@ struct bfd;\n \n /* If the debugger needs to provide the CTF library with a set of raw buffers\n    for use as the CTF data, symbol table, and string table, it can do so by\n-   filling in ctf_sect_t structures and passing them to ctf_bufopen().\n+   filling in ctf_sect_t structures and passing them to ctf_bufopen.\n \n-   The contents of this structure must always be in native endianness (no\n-   byteswapping is performed).  */\n+   The contents of this structure must always be in native endianness.  At read\n+   time, the symbol table endianness is derived from the BFD target (if BFD is\n+   in use): if a BFD target is not in use, please call ctf_symsect_endianness or\n+   ctf_arc_symsect_endianness.  */\n \n typedef struct ctf_sect\n {\n@@ -67,12 +69,12 @@ typedef struct ctf_sect\n /* A minimal symbol extracted from a linker's internal symbol table\n    representation.  The symbol name can be given either via st_name or via a\n    strtab offset in st_nameidx, which corresponds to one of the string offsets\n-   communicated via the ctf_link_add_strtab callback.  */\n+   communicated via the ctf_link_add_strtab callback.   */\n \n typedef struct ctf_link_sym\n {\n   /* The st_name and st_nameidx will not be accessed outside the call to\n-     ctf_link_shuffle_syms().  If you set st_nameidx to offset zero, make sure\n+     ctf_link_shuffle_syms.  If you set st_nameidx to offset zero, make sure\n      to set st_nameidx_set as well.  */\n \n   const char *st_name;\n@@ -118,7 +120,7 @@ typedef enum ctf_sect_names\n   } ctf_sect_names_t;\n \n /* Encoding information for integers, floating-point values, and certain other\n-   intrinsics can be obtained by calling ctf_type_encoding(), below.  The flags\n+   intrinsics can be obtained by calling ctf_type_encoding, below.  The flags\n    field will contain values appropriate for the type defined in <ctf.h>.  */\n \n typedef struct ctf_encoding\n@@ -162,8 +164,8 @@ typedef struct ctf_snapshot_id\n #define\tCTF_FUNC_VARARG\t0x1\t/* Function arguments end with varargs.  */\n \n /* Functions that return a ctf_id_t use the following value to indicate failure.\n-   ctf_errno() can be used to obtain an error code.  Functions that return\n-   a straight integral -1 also use ctf_errno().  */\n+   ctf_errno can be used to obtain an error code.  Functions that return\n+   a straight integral -1 also use ctf_errno.  */\n #define\tCTF_ERR\t((ctf_id_t) -1L)\n \n /* This macro holds information about all the available ctf errors.\n@@ -244,7 +246,7 @@ _CTF_ERRORS\n #define ECTF_NERR (ECTF_NEEDSBFD - ECTF_BASE + 1) /* Count of CTF errors.  */\n \n /* The CTF data model is inferred to be the caller's data model or the data\n-   model of the given object, unless ctf_setmodel() is explicitly called.  */\n+   model of the given object, unless ctf_setmodel is explicitly called.  */\n #define\tCTF_MODEL_ILP32 1\t/* Object data model is ILP32.  */\n #define\tCTF_MODEL_LP64  2\t/* Object data model is LP64.  */\n #ifdef _LP64\n@@ -253,7 +255,7 @@ _CTF_ERRORS\n # define CTF_MODEL_NATIVE CTF_MODEL_ILP32\n #endif\n \n-/* Dynamic CTF containers can be created using ctf_create().  The ctf_add_*\n+/* Dynamic CTF containers can be created using ctf_create.  The ctf_add_*\n    routines can be used to add new definitions to the dynamic container.\n    New types are labeled as root or non-root to determine whether they are\n    visible at the top-level program scope when subsequently doing a lookup.  */\n@@ -283,9 +285,9 @@ typedef char *ctf_dump_decorate_f (ctf_sect_names_t sect,\n \n typedef struct ctf_dump_state ctf_dump_state_t;\n \n-/* Iteration state for the _next() functions, and allocators/copiers/freers for\n+/* Iteration state for the _next functions, and allocators/copiers/freers for\n    it.  (None of these are needed for the simple case of iterating to the end:\n-   the _next() function allocate and free the iterators for you.)  */\n+   the _next function allocate and free the iterators for you.)  */\n \n typedef struct ctf_next ctf_next_t;\n extern ctf_next_t *ctf_next_create (void);\n@@ -295,7 +297,7 @@ extern ctf_next_t *ctf_next_copy (ctf_next_t *);\n /* Opening.  These mostly return an abstraction over both CTF files and CTF\n    archives: so they can be used to open both.  CTF files will appear to be an\n    archive with one member named '.ctf'.  The low-level functions\n-   ctf_simple_open() and ctf_bufopen() return ctf_dict_t's directly, and cannot\n+   ctf_simple_open and ctf_bufopen return ctf_dict_t's directly, and cannot\n    be used on CTF archives.  */\n \n extern ctf_archive_t *ctf_bfdopen (struct bfd *, int *);\n@@ -309,12 +311,14 @@ extern void ctf_close (ctf_archive_t *);\n extern ctf_sect_t ctf_getdatasect (const ctf_dict_t *);\n extern ctf_sect_t ctf_getsymsect (const ctf_dict_t *);\n extern ctf_sect_t ctf_getstrsect (const ctf_dict_t *);\n+extern void ctf_symsect_endianness (ctf_dict_t *, int little_endian);\n extern ctf_archive_t *ctf_get_arc (const ctf_dict_t *);\n extern ctf_archive_t *ctf_arc_open (const char *, int *);\n extern ctf_archive_t *ctf_arc_bufopen (const ctf_sect_t *,\n \t\t\t\t       const ctf_sect_t *,\n \t\t\t\t       const ctf_sect_t *,\n \t\t\t\t       int *);\n+extern void ctf_arc_symsect_endianness (ctf_archive_t *, int little_endian);\n extern void ctf_arc_close (ctf_archive_t *);\n extern ctf_dict_t *ctf_arc_lookup_symbol (ctf_archive_t *,\n \t\t\t\t\t  unsigned long symidx,"
    },
    {
      "sha": "adeedeb9249ab25f60b88282724d5b4abc10fe2c",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -1,3 +1,30 @@\n+2020-11-23  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_dict_t) <ctf_symtab_little_endian>: New.\n+\t(struct ctf_archive_internal) <ctfi_symsect_little_endian>: Likewise.\n+\t* ctf-create.c (ctf_serialize): Adjust for new field.\n+\t* ctf-open.c (init_symtab): Note the semantics of repeated calls.\n+\t(ctf_symsect_endianness): New.\n+\t(ctf_bufopen_internal): Set ctf_symtab_little_endian suitably for\n+\tthe native endianness.\n+\t(_Static_assert): Moved...\n+\t(swap_thing): ... with this...\n+\t* swap.h: ... to here.\n+\t* ctf-util.c (ctf_elf32_to_link_sym): Use it, byteswapping the\n+\tElf32_Sym if the ctf_symtab_little_endian demands it.\n+\t(ctf_elf64_to_link_sym): Likewise swap the Elf64_Sym if needed.\n+\t* ctf-archive.c (ctf_arc_symsect_endianness): New, set the\n+\tendianness of the symtab used by the dicts in an archive.\n+\t(ctf_archive_iter_internal): Initialize to unknown (assumed native,\n+\tdo not call ctf_symsect_endianness).\n+\t(ctf_dict_open_by_offset): Call ctf_symsect_endianness if need be.\n+\t(ctf_dict_open_internal): Propagate the endianness down.\n+\t(ctf_dict_open_sections): Likewise.\n+\t* ctf-open-bfd.c (ctf_bfdopen_ctfsect): Get the endianness from the\n+\tstruct bfd and pass it down to the archive.\n+\t* libctf.ver: Add ctf_symsect_endianness and\n+\tctf_arc_symsect_endianness.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c (ctf_link_deduplicating): Clean up the ctf_link_outputs"
    },
    {
      "sha": "a74ab47040e94c3f81f0bb08686e43f03280bde1",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 28,
      "deletions": 7,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -36,7 +36,8 @@ static off_t arc_write_one_ctf (ctf_dict_t * f, int fd, size_t threshold);\n static ctf_dict_t *ctf_dict_open_by_offset (const struct ctf_archive *arc,\n \t\t\t\t\t    const ctf_sect_t *symsect,\n \t\t\t\t\t    const ctf_sect_t *strsect,\n-\t\t\t\t\t    size_t offset, int *errp);\n+\t\t\t\t\t    size_t offset, int little_endian,\n+\t\t\t\t\t    int *errp);\n static int sort_modent_by_name (const void *one, const void *two, void *n);\n static void *arc_mmap_header (int fd, size_t headersz);\n static void *arc_mmap_file (int fd, size_t size);\n@@ -378,10 +379,21 @@ ctf_new_archive_internal (int is_archive, int unmap_on_close,\n   arci->ctfi_free_symsect = 0;\n   arci->ctfi_free_strsect = 0;\n   arci->ctfi_unmap_on_close = unmap_on_close;\n+  arci->ctfi_symsect_little_endian = -1;\n \n   return arci;\n }\n \n+/* Set the symbol-table endianness of an archive (defaulting the symtab\n+   endianness of all ctf_file_t's opened from that archive).  */\n+void\n+ctf_arc_symsect_endianness (ctf_archive_t *arc, int little_endian)\n+{\n+  arc->ctfi_symsect_little_endian = !!little_endian;\n+  if (!arc->ctfi_is_archive)\n+    ctf_symsect_endianness (arc->ctfi_dict, arc->ctfi_symsect_little_endian);\n+}\n+\n /* Get the CTF preamble from data in a buffer, which may be either an archive or\n    a CTF dict.  If multiple dicts are present in an archive, the preamble comes\n    from an arbitrary dict.  The preamble is a pointer into the ctfsect passed\n@@ -536,7 +548,8 @@ static ctf_dict_t *\n ctf_dict_open_internal (const struct ctf_archive *arc,\n \t\t\tconst ctf_sect_t *symsect,\n \t\t\tconst ctf_sect_t *strsect,\n-\t\t\tconst char *name, int *errp)\n+\t\t\tconst char *name, int little_endian,\n+\t\t\tint *errp)\n {\n   struct ctf_archive_modent *modent;\n   const char *search_nametbl;\n@@ -564,7 +577,8 @@ ctf_dict_open_internal (const struct ctf_archive *arc,\n     }\n \n   return ctf_dict_open_by_offset (arc, symsect, strsect,\n-\t\t\t\t  le64toh (modent->ctf_offset), errp);\n+\t\t\t\t  le64toh (modent->ctf_offset),\n+\t\t\t\t  little_endian, errp);\n }\n \n /* Return the ctf_dict_t with the given name, or NULL if none, setting 'err' if\n@@ -584,7 +598,8 @@ ctf_dict_open_sections (const ctf_archive_t *arc,\n     {\n       ctf_dict_t *ret;\n       ret = ctf_dict_open_internal (arc->ctfi_archive, symsect, strsect,\n-\t\t\t\t    name, errp);\n+\t\t\t\t    name, arc->ctfi_symsect_little_endian,\n+\t\t\t\t    errp);\n       if (ret)\n \t{\n \t  ret->ctf_archive = (ctf_archive_t *) arc;\n@@ -691,7 +706,7 @@ static ctf_dict_t *\n ctf_dict_open_by_offset (const struct ctf_archive *arc,\n \t\t\t const ctf_sect_t *symsect,\n \t\t\t const ctf_sect_t *strsect, size_t offset,\n-\t\t\t int *errp)\n+\t\t\t int little_endian, int *errp)\n {\n   ctf_sect_t ctfsect;\n   ctf_dict_t *fp;\n@@ -708,7 +723,11 @@ ctf_dict_open_by_offset (const struct ctf_archive *arc,\n   ctfsect.cts_data = (void *) ((char *) arc + offset + sizeof (uint64_t));\n   fp = ctf_bufopen (&ctfsect, symsect, strsect, errp);\n   if (fp)\n-    ctf_setmodel (fp, le64toh (arc->ctfa_model));\n+    {\n+      ctf_setmodel (fp, le64toh (arc->ctfa_model));\n+      if (little_endian >= 0)\n+\tctf_symsect_endianness (fp, little_endian);\n+    }\n   return fp;\n }\n \n@@ -961,7 +980,9 @@ ctf_archive_iter_internal (const ctf_archive_t *wrapper,\n \n       name = &nametbl[le64toh (modent[i].name_offset)];\n       if ((f = ctf_dict_open_internal (arc, symsect, strsect,\n-\t\t\t\t    name, &rc)) == NULL)\n+\t\t\t\t       name,\n+\t\t\t\t       wrapper->ctfi_symsect_little_endian,\n+\t\t\t\t       &rc)) == NULL)\n \treturn rc;\n \n       f->ctf_archive = (ctf_archive_t *) wrapper;"
    },
    {
      "sha": "e03a04683dd1307c1e6db369622fb9ed5791c3a6",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -1162,6 +1162,7 @@ ctf_serialize (ctf_dict_t *fp)\n   nfp->ctf_link_memb_name_changer_arg = fp->ctf_link_memb_name_changer_arg;\n   nfp->ctf_link_variable_filter = fp->ctf_link_variable_filter;\n   nfp->ctf_link_variable_filter_arg = fp->ctf_link_variable_filter_arg;\n+  nfp->ctf_symsect_little_endian = fp->ctf_symsect_little_endian;\n   nfp->ctf_link_flags = fp->ctf_link_flags;\n   nfp->ctf_dedup_atoms = fp->ctf_dedup_atoms;\n   nfp->ctf_dedup_atoms_alloc = fp->ctf_dedup_atoms_alloc;"
    },
    {
      "sha": "84460ea2da45b8e37c06647acd6ba17de767ed86",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -381,6 +381,7 @@ struct ctf_dict\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n+  int ctf_symsect_little_endian;    /* Endianness of the ctf_symtab.  */\n   ctf_dynhash_t *ctf_prov_strtab;   /* Maps provisional-strtab offsets\n \t\t\t\t       to names.  */\n   ctf_dynhash_t *ctf_syn_ext_strtab; /* Maps ext-strtab offsets to names.  */\n@@ -506,6 +507,7 @@ struct ctf_archive_internal\n   ctf_dict_t **ctfi_symdicts;\t  /* Array of index -> ctf_dict_t *.  */\n   ctf_id_t *ctfi_syms;\t\t  /* Array of index -> ctf_id_t.  */\n   ctf_sect_t ctfi_symsect;\n+  int ctfi_symsect_little_endian; /* -1 for unknown / do not set.  */\n   ctf_sect_t ctfi_strsect;\n   int ctfi_free_symsect;\n   int ctfi_free_strsect;"
    },
    {
      "sha": "1a00cb674268e854ef21fb18bcafff32cee9223d",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -97,6 +97,7 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n   ctf_sect_t *strsectp = NULL;\n   const char *bfderrstr = NULL;\n   char *strtab_alloc = NULL;\n+  int symsect_endianness = -1;\n \n #ifdef HAVE_BFD_ELF\n   ctf_sect_t symsect, strsect;\n@@ -206,6 +207,8 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n       symsect.cts_data = symtab;\n       symsectp = &symsect;\n     }\n+\n+  symsect_endianness = bfd_little_endian (abfd);\n #endif\n \n   arci = ctf_arc_bufopen (ctfsect, symsectp, strsectp, errp);\n@@ -215,6 +218,10 @@ ctf_bfdopen_ctfsect (struct bfd *abfd _libctf_unused_,\n       arci->ctfi_free_symsect = 1;\n       if (strtab_alloc)\n \tarci->ctfi_free_strsect = 1;\n+\n+      /* Get the endianness right.  */\n+      if (symsect_endianness > -1)\n+\tctf_arc_symsect_endianness (arci, symsect_endianness);\n       return arci;\n     }\n #ifdef HAVE_BFD_ELF"
    },
    {
      "sha": "7816fd0af102ccbfa1963fd9b0ce225bc08f1f06",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 31,
      "deletions": 25,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -22,7 +22,6 @@\n #include <string.h>\n #include <sys/types.h>\n #include <elf.h>\n-#include <assert.h>\n #include \"swap.h\"\n #include <bfd.h>\n #include <zlib.h>\n@@ -227,7 +226,10 @@ static const ctf_dictops_t ctf_dictops[] = {\n    symtypetabs come from the compiler, and all the linker does is iteration over\n    all entries, which doesn't need this initialization.)\n \n-   The SP symbol table section may be NULL if there is no symtab.  */\n+   The SP symbol table section may be NULL if there is no symtab.\n+\n+   If init_symtab works on one call, it cannot fail on future calls to the same\n+   fp: ctf_symsect_endianness relies on this.  */\n \n static int\n init_symtab (ctf_dict_t *fp, const ctf_header_t *hp, const ctf_sect_t *sp)\n@@ -290,6 +292,10 @@ init_symtab (ctf_dict_t *fp, const ctf_header_t *hp, const ctf_sect_t *sp)\n \t  return ECTF_SYMTAB;\n \t}\n \n+      /* This call may be led astray if our idea of the symtab's endianness is\n+\t wrong, but when this is fixed by a call to ctf_symsect_endianness,\n+\t init_symtab will be called again with the right endianness in\n+\t force.  */\n       if (ctf_symtab_skippable (&sym))\n \t{\n \t  *xp = -1u;\n@@ -974,28 +980,6 @@ init_types (ctf_dict_t *fp, ctf_header_t *cth)\n    We flip everything, mindlessly, even 1-byte entities, so that future\n    expansions do not require changes to this code.  */\n \n-/* < C11? define away static assertions.  */\n-\n-#if !defined (__STDC_VERSION__) || __STDC_VERSION__ < 201112L\n-#define _Static_assert(cond, err)\n-#endif\n-\n-/* Swap the endianness of something.  */\n-\n-#define swap_thing(x)\t\t\t\t\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    _Static_assert (sizeof (x) == 1 || (sizeof (x) % 2 == 0\t\t\\\n-\t\t\t\t\t&& sizeof (x) <= 8),\t\t\\\n-\t\t    \"Invalid size, update endianness code\");\t\t\\\n-    switch (sizeof (x)) {\t\t\t\t\t\t\\\n-    case 2: x = bswap_16 (x); break;\t\t\t\t\t\\\n-    case 4: x = bswap_32 (x); break;\t\t\t\t\t\\\n-    case 8: x = bswap_64 (x); break;\t\t\t\t\t\\\n-    case 1: /* Nothing needs doing */\t\t\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  } while (0);\n-\n /* Flip the endianness of the CTF header.  */\n \n static void\n@@ -1652,7 +1636,13 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n      large for the actual size of the object and function info sections: if so,\n      ctf_nsyms will be adjusted and the excess will never be used.  It's\n      possible to do indexed symbol lookups even without a symbol table, so check\n-     even in that case.  */\n+     even in that case.  Initially, we assume the symtab is native-endian: if it\n+     isn't, the caller will inform us later by calling ctf_symsect_endianness.  */\n+#ifdef WORDS_BIGENDIAN\n+  fp->ctf_symsect_little_endian = 0;\n+#else\n+  fp->ctf_symsect_little_endian = 1;\n+#endif\n \n   if (symsect != NULL)\n     {\n@@ -1866,6 +1856,22 @@ ctf_getstrsect (const ctf_dict_t *fp)\n   return fp->ctf_strtab;\n }\n \n+/* Set the endianness of the symbol table attached to FP.  */\n+void\n+ctf_symsect_endianness (ctf_dict_t *fp, int little_endian)\n+{\n+  int old_endianness = fp->ctf_symsect_little_endian;\n+\n+  fp->ctf_symsect_little_endian = !!little_endian;\n+\n+  /* If we already have a symtab translation table, we need to repopulate it if\n+     our idea of the endianness has changed.  */\n+\n+  if (old_endianness != fp->ctf_symsect_little_endian\n+      && fp->ctf_sxlate != NULL && fp->ctf_symtab.cts_data != NULL)\n+    assert (init_symtab (fp, fp->ctf_header, &fp->ctf_symtab) == 0);\n+}\n+\n /* Return the CTF handle for the parent CTF dict, if one exists.  Otherwise\n    return NULL to indicate this dict has no imported parent.  */\n ctf_dict_t *"
    },
    {
      "sha": "ab34bc0732eef95ae53642f63afa609a2949f39e",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 51,
      "deletions": 11,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -19,6 +19,7 @@\n \n #include <ctf-impl.h>\n #include <string.h>\n+#include \"ctf-endian.h\"\n \n /* Simple doubly-linked list append routine.  This implementation assumes that\n    each list element contains an embedded ctf_list_t as the first member.\n@@ -114,16 +115,35 @@ ctf_link_sym_t *\n ctf_elf32_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst, const Elf32_Sym *src,\n \t\t       uint32_t symidx)\n {\n+  Elf32_Sym tmp;\n+  int needs_flipping = 0;\n+\n+#ifdef WORDS_BIGENDIAN\n+  if (fp->ctf_symsect_little_endian)\n+    needs_flipping = 1;\n+#else\n+  if (!fp->ctf_symsect_little_endian)\n+    needs_flipping = 1;\n+#endif\n+\n+  memcpy (&tmp, src, sizeof (Elf32_Sym));\n+  if (needs_flipping)\n+    {\n+      swap_thing (tmp.st_name);\n+      swap_thing (tmp.st_size);\n+      swap_thing (tmp.st_shndx);\n+      swap_thing (tmp.st_value);\n+    }\n   /* The name must be in the external string table.  */\n-  if (src->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n-    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + src->st_name;\n+  if (tmp.st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n+    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + tmp.st_name;\n   else\n     dst->st_name = _CTF_NULLSTR;\n   dst->st_nameidx_set = 0;\n   dst->st_symidx = symidx;\n-  dst->st_shndx = src->st_shndx;\n-  dst->st_type = ELF32_ST_TYPE (src->st_info);\n-  dst->st_value = src->st_value;\n+  dst->st_shndx = tmp.st_shndx;\n+  dst->st_type = ELF32_ST_TYPE (tmp.st_info);\n+  dst->st_value = tmp.st_value;\n \n   return dst;\n }\n@@ -134,22 +154,42 @@ ctf_link_sym_t *\n ctf_elf64_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst, const Elf64_Sym *src,\n \t\t       uint32_t symidx)\n {\n+  Elf64_Sym tmp;\n+  int needs_flipping = 0;\n+\n+#ifdef WORDS_BIGENDIAN\n+  if (fp->ctf_symsect_little_endian)\n+    needs_flipping = 1;\n+#else\n+  if (!fp->ctf_symsect_little_endian)\n+    needs_flipping = 1;\n+#endif\n+\n+  memcpy (&tmp, src, sizeof (Elf64_Sym));\n+  if (needs_flipping)\n+    {\n+      swap_thing (tmp.st_name);\n+      swap_thing (tmp.st_size);\n+      swap_thing (tmp.st_shndx);\n+      swap_thing (tmp.st_value);\n+    }\n+\n   /* The name must be in the external string table.  */\n-  if (src->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n-    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + src->st_name;\n+  if (tmp.st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n+    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + tmp.st_name;\n   else\n     dst->st_name = _CTF_NULLSTR;\n   dst->st_nameidx_set = 0;\n   dst->st_symidx = symidx;\n-  dst->st_shndx = src->st_shndx;\n-  dst->st_type = ELF32_ST_TYPE (src->st_info);\n+  dst->st_shndx = tmp.st_shndx;\n+  dst->st_type = ELF32_ST_TYPE (tmp.st_info);\n \n   /* We only care if the value is zero, so avoid nonzeroes turning into\n      zeroes.  */\n-  if (_libctf_unlikely_ (src->st_value != 0 && ((uint32_t) src->st_value == 0)))\n+  if (_libctf_unlikely_ (tmp.st_value != 0 && ((uint32_t) tmp.st_value == 0)))\n     dst->st_value = 1;\n   else\n-    dst->st_value = (uint32_t) src->st_value;\n+    dst->st_value = (uint32_t) tmp.st_value;\n \n   return dst;\n }"
    },
    {
      "sha": "3286e6009e987c8dd5933c76ec910358eb380938",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -193,4 +193,6 @@ LIBCTF_1.1 {\n \n \tctf_getsymsect;\n \tctf_getstrsect;\n+\tctf_symsect_endianness;\n+\tctf_arc_symsect_endianness;\n } LIBCTF_1.0;"
    },
    {
      "sha": "413f0ce865414fff3bbcc6e55532fb8311416f63",
      "filename": "libctf/swap.h",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/53651de80f811495262a5b17b774a486dd37b326/libctf/swap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/53651de80f811495262a5b17b774a486dd37b326/libctf/swap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/swap.h?ref=53651de80f811495262a5b17b774a486dd37b326",
      "patch": "@@ -22,6 +22,7 @@\n \n #include \"config.h\"\n #include <stdint.h>\n+#include <assert.h>\n \n #ifdef HAVE_BYTESWAP_H\n #include <byteswap.h>\n@@ -63,4 +64,27 @@ bswap_64 (uint64_t v)\n }\n #endif /* !HAVE_DECL_BSWAP64 */\n \n+/* < C11? define away static assertions.  */\n+\n+#if !defined (__STDC_VERSION__) || __STDC_VERSION__ < 201112L\n+#define _Static_assert(cond, err)\n+#endif\n+\n+/* Swap the endianness of something.  */\n+\n+#define swap_thing(x)\t\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _Static_assert (sizeof (x) == 1 || (sizeof (x) % 2 == 0\t\t\\\n+\t\t\t\t\t&& sizeof (x) <= 8),\t\t\\\n+\t\t    \"Invalid size, update endianness code\");\t\t\\\n+    switch (sizeof (x)) {\t\t\t\t\t\t\\\n+    case 2: x = bswap_16 (x); break;\t\t\t\t\t\\\n+    case 4: x = bswap_32 (x); break;\t\t\t\t\t\\\n+    case 8: x = bswap_64 (x); break;\t\t\t\t\t\\\n+    case 1: /* Nothing needs doing */\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  } while (0);\n+\n+\n #endif /* !defined(_CTF_SWAP_H) */"
    }
  ]
}