{
  "sha": "9f0272f8548164b024ff9fd151686b2b904a5d59",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWYwMjcyZjg1NDgxNjRiMDI0ZmY5ZmQxNTE2ODZiMmI5MDRhNWQ1OQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-04-05T12:50:19Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-04-11T22:37:45Z"
    },
    "message": "gdb/riscv: Handle empty C++ structs during argument passing\n\nThis commit resolves a large number of failures in the test script\ngdb.base/infcall-nested-structs.exp which were caused by GDB (for\nRISC-V) incorrectly handling empty C++ structures when preparing\narguments for a dummy call, or collecting a return value.\n\nThe issue is further complicated in that there was a bug in GCC, such\nthat in some cases GCC would generate incorrect code when passing a\nsmall structure that contained empty sub-structures.  This was fixed\nin GCC trunk on 5-March-2019, so in order to see the best results with\nthis patch you'll need a recent version of GCC.\n\nAnything that used to work should continue to work after this patch,\nregardless of GCC version being used.\n\nThe fix in this commit is that GDB now pays more attention to the\noffset of fields within a structure when preparing arguments as in C++\nan empty structure has a non-zero size, this is an example:\n\n  struct s1 { struct s2 { } empty; int f; };\n\nWe previously assumed that 'f' was at offset 0 inside type 's1',\nhowever this is not the case in C++ as 's2' has size 1, and with\nalignment 'f' is likely at some even bigger offset inside 's1'.\n\ngdb/ChangeLog:\n\n\t* riscv-tdep.c (riscv_call_arg_complex_float): Fix offset of first\n\tcomponent to 0.\n\t(riscv_struct_info::riscv_struct_info): Initialise m_offsets\n\tmember.\n\t(riscv_struct_info::analyse): New implementation using new\n\tanalyse_inner member function.\n\t(riscv_struct_info::field_offset): New member function.\n\t(riscv_struct_info::m_offsets): New member variable.\n\t(riscv_struct_info::analyse_inner): New private member function,\n\ttakes the old implementation of riscv_struct_info::analyse but\n\textended to track field offsets.\n\t(riscv_call_arg_struct): Update the struct folding special cases\n\tto handle cases where empty C++ structs, which are non-zero\n\tlength, are found.\n\t(riscv_arg_location): Initialise the length of each location, a\n\tnon-zero length now indicates the location is in use.\n\t(riscv_push_dummy_call): Allow for the first location having a\n\tnon-zero offset when setting up arguments.\n\t(riscv_return_value): Likewise, but for return values.",
    "tree": {
      "sha": "0d23c89b0c26d8f0259e823c218e7ed6931fc5cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0d23c89b0c26d8f0259e823c218e7ed6931fc5cd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9f0272f8548164b024ff9fd151686b2b904a5d59",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f0272f8548164b024ff9fd151686b2b904a5d59",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9f0272f8548164b024ff9fd151686b2b904a5d59",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f0272f8548164b024ff9fd151686b2b904a5d59/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "02cf60c7a42710ee0364698c436b6ca5e771374b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/02cf60c7a42710ee0364698c436b6ca5e771374b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/02cf60c7a42710ee0364698c436b6ca5e771374b"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 132,
    "deletions": 43
  },
  "files": [
    {
      "sha": "0be7538f6f2d3629c6d34958494aadad2209401f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9f0272f8548164b024ff9fd151686b2b904a5d59/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9f0272f8548164b024ff9fd151686b2b904a5d59/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9f0272f8548164b024ff9fd151686b2b904a5d59",
      "patch": "@@ -1,3 +1,25 @@\n+2019-04-11  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* riscv-tdep.c (riscv_call_arg_complex_float): Fix offset of first\n+\tcomponent to 0.\n+\t(riscv_struct_info::riscv_struct_info): Initialise m_offsets\n+\tmember.\n+\t(riscv_struct_info::analyse): New implementation using new\n+\tanalyse_inner member function.\n+\t(riscv_struct_info::field_offset): New member function.\n+\t(riscv_struct_info::m_offsets): New member variable.\n+\t(riscv_struct_info::analyse_inner): New private member function,\n+\ttakes the old implementation of riscv_struct_info::analyse but\n+\textended to track field offsets.\n+\t(riscv_call_arg_struct): Update the struct folding special cases\n+\tto handle cases where empty C++ structs, which are non-zero\n+\tlength, are found.\n+\t(riscv_arg_location): Initialise the length of each location, a\n+\tnon-zero length now indicates the location is in use.\n+\t(riscv_push_dummy_call): Allow for the first location having a\n+\tnon-zero offset when setting up arguments.\n+\t(riscv_return_value): Likewise, but for return values.\n+\n 2019-04-11  Tom Tromey  <tromey@adacore.com>\n \n \t* utils.c (internal_vproblem): Make \"msg\" const."
    },
    {
      "sha": "fbf89ab25c9e0ef87118adc84415f79f942ddaff",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 110,
      "deletions": 43,
      "changes": 153,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9f0272f8548164b024ff9fd151686b2b904a5d59/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9f0272f8548164b024ff9fd151686b2b904a5d59/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=9f0272f8548164b024ff9fd151686b2b904a5d59",
      "patch": "@@ -1993,7 +1993,7 @@ riscv_call_arg_complex_float (struct riscv_arg_info *ainfo,\n       int len = ainfo->length / 2;\n \n       result = riscv_assign_reg_location (&ainfo->argloc[0],\n-\t\t\t\t\t  &cinfo->float_regs, len, len);\n+\t\t\t\t\t  &cinfo->float_regs, len, 0);\n       gdb_assert (result);\n \n       result = riscv_assign_reg_location (&ainfo->argloc[1],\n@@ -2014,14 +2014,18 @@ class riscv_struct_info\n public:\n   riscv_struct_info ()\n     : m_number_of_fields (0),\n-      m_types { nullptr, nullptr }\n+      m_types { nullptr, nullptr },\n+      m_offsets { 0, 0 }\n   {\n     /* Nothing.  */\n   }\n \n   /* Analyse TYPE descending into nested structures, count the number of\n      scalar fields and record the types of the first two fields found.  */\n-  void analyse (struct type *type);\n+  void analyse (struct type *type)\n+  {\n+    analyse_inner (type, 0);\n+  }\n \n   /* The number of scalar fields found in the analysed type.  This is\n      currently only accurate if the value returned is 0, 1, or 2 as the\n@@ -2041,6 +2045,16 @@ class riscv_struct_info\n     return m_types[index];\n   }\n \n+  /* Return the offset of scalar field INDEX within the analysed type. Will\n+     return 0 if there is no field at that index.  Only INDEX values 0 and\n+     1 can be requested as the RiscV ABI only has special cases for\n+     structures with 1 or 2 fields.  */\n+  int field_offset (int index) const\n+  {\n+    gdb_assert (index < (sizeof (m_offsets) / sizeof (m_offsets[0])));\n+    return m_offsets[index];\n+  }\n+\n private:\n   /* The number of scalar fields found within the structure after recursing\n      into nested structures.  */\n@@ -2049,13 +2063,20 @@ class riscv_struct_info\n   /* The types of the first two scalar fields found within the structure\n      after recursing into nested structures.  */\n   struct type *m_types[2];\n+\n+  /* The offsets of the first two scalar fields found within the structure\n+     after recursing into nested structures.  */\n+  int m_offsets[2];\n+\n+  /* Recursive core for ANALYSE, the OFFSET parameter tracks the byte\n+     offset from the start of the top level structure being analysed.  */\n+  void analyse_inner (struct type *type, int offset);\n };\n \n-/* Analyse TYPE descending into nested structures, count the number of\n-   scalar fields and record the types of the first two fields found.  */\n+/* See description in class declaration.  */\n \n void\n-riscv_struct_info::analyse (struct type *type)\n+riscv_struct_info::analyse_inner (struct type *type, int offset)\n {\n   unsigned int count = TYPE_NFIELDS (type);\n   unsigned int i;\n@@ -2067,11 +2088,13 @@ riscv_struct_info::analyse (struct type *type)\n \n       struct type *field_type = TYPE_FIELD_TYPE (type, i);\n       field_type = check_typedef (field_type);\n+      int field_offset\n+\t= offset + TYPE_FIELD_BITPOS (type, i) / TARGET_CHAR_BIT;\n \n       switch (TYPE_CODE (field_type))\n \t{\n \tcase TYPE_CODE_STRUCT:\n-\t  analyse (field_type);\n+\t  analyse_inner (field_type, field_offset);\n \t  break;\n \n \tdefault:\n@@ -2081,7 +2104,10 @@ riscv_struct_info::analyse (struct type *type)\n \t     structure we can special case, and pass the structure in\n \t     memory.  */\n \t  if (m_number_of_fields < 2)\n-\t    m_types[m_number_of_fields] = field_type;\n+\t    {\n+\t      m_types[m_number_of_fields] = field_type;\n+\t      m_offsets[m_number_of_fields] = field_offset;\n+\t    }\n \t  m_number_of_fields++;\n \t  break;\n \t}\n@@ -2114,17 +2140,54 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n       if (sinfo.number_of_fields () == 1\n \t  && TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_COMPLEX)\n \t{\n-\t  gdb_assert (TYPE_LENGTH (ainfo->type)\n-\t\t      == TYPE_LENGTH (sinfo.field_type (0)));\n-\t  return riscv_call_arg_complex_float (ainfo, cinfo);\n+\t  /* The following is similar to RISCV_CALL_ARG_COMPLEX_FLOAT,\n+\t     except we use the type of the complex field instead of the\n+\t     type from AINFO, and the first location might be at a non-zero\n+\t     offset.  */\n+\t  if (TYPE_LENGTH (sinfo.field_type (0)) <= (2 * cinfo->flen)\n+\t      && riscv_arg_regs_available (&cinfo->float_regs) >= 2\n+\t      && !ainfo->is_unnamed)\n+\t    {\n+\t      bool result;\n+\t      int len = TYPE_LENGTH (sinfo.field_type (0)) / 2;\n+\t      int offset = sinfo.field_offset (0);\n+\n+\t      result = riscv_assign_reg_location (&ainfo->argloc[0],\n+\t\t\t\t\t\t  &cinfo->float_regs, len,\n+\t\t\t\t\t\t  offset);\n+\t      gdb_assert (result);\n+\n+\t      result = riscv_assign_reg_location (&ainfo->argloc[1],\n+\t\t\t\t\t\t  &cinfo->float_regs, len,\n+\t\t\t\t\t\t  (offset + len));\n+\t      gdb_assert (result);\n+\t    }\n+\t  else\n+\t    riscv_call_arg_scalar_int (ainfo, cinfo);\n+\t  return;\n \t}\n \n       if (sinfo.number_of_fields () == 1\n \t  && TYPE_CODE (sinfo.field_type (0)) == TYPE_CODE_FLT)\n \t{\n-\t  gdb_assert (TYPE_LENGTH (ainfo->type)\n-\t\t      == TYPE_LENGTH (sinfo.field_type (0)));\n-\t  return riscv_call_arg_scalar_float (ainfo, cinfo);\n+\t  /* The following is similar to RISCV_CALL_ARG_SCALAR_FLOAT,\n+\t     except we use the type of the first scalar field instead of\n+\t     the type from AINFO.  Also the location might be at a non-zero\n+\t     offset.  */\n+\t  if (TYPE_LENGTH (sinfo.field_type (0)) > cinfo->flen\n+\t      || ainfo->is_unnamed)\n+\t    riscv_call_arg_scalar_int (ainfo, cinfo);\n+\t  else\n+\t    {\n+\t      int offset = sinfo.field_offset (0);\n+\t      int len = TYPE_LENGTH (sinfo.field_type (0));\n+\n+\t      if (!riscv_assign_reg_location (&ainfo->argloc[0],\n+\t\t\t\t\t      &cinfo->float_regs,\n+\t\t\t\t\t      len, offset))\n+\t\triscv_call_arg_scalar_int (ainfo, cinfo);\n+\t    }\n+\t  return;\n \t}\n \n       if (sinfo.number_of_fields () == 2\n@@ -2134,17 +2197,14 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t  && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->flen\n \t  && riscv_arg_regs_available (&cinfo->float_regs) >= 2)\n \t{\n-\t  int len0, len1, offset;\n-\n-\t  gdb_assert (TYPE_LENGTH (ainfo->type) <= (2 * cinfo->flen));\n-\n-\t  len0 = TYPE_LENGTH (sinfo.field_type (0));\n+\t  int len0 = TYPE_LENGTH (sinfo.field_type (0));\n+\t  int offset = sinfo.field_offset (0);\n \t  if (!riscv_assign_reg_location (&ainfo->argloc[0],\n-\t\t\t\t\t  &cinfo->float_regs, len0, 0))\n+\t\t\t\t\t  &cinfo->float_regs, len0, offset))\n \t    error (_(\"failed during argument setup\"));\n \n-\t  len1 = TYPE_LENGTH (sinfo.field_type (1));\n-\t  offset = align_up (len0, riscv_type_alignment (sinfo.field_type (1)));\n+\t  int len1 = TYPE_LENGTH (sinfo.field_type (1));\n+\t  offset = sinfo.field_offset (1);\n \t  gdb_assert (len1 <= (TYPE_LENGTH (ainfo->type)\n \t\t\t       - TYPE_LENGTH (sinfo.field_type (0))));\n \n@@ -2162,15 +2222,14 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t      && is_integral_type (sinfo.field_type (1))\n \t      && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->xlen))\n \t{\n-\t  int len0, len1, offset;\n-\n-\t  len0 = TYPE_LENGTH (sinfo.field_type (0));\n+\t  int  len0 = TYPE_LENGTH (sinfo.field_type (0));\n+\t  int offset = sinfo.field_offset (0);\n \t  if (!riscv_assign_reg_location (&ainfo->argloc[0],\n-\t\t\t\t\t  &cinfo->float_regs, len0, 0))\n+\t\t\t\t\t  &cinfo->float_regs, len0, offset))\n \t    error (_(\"failed during argument setup\"));\n \n-\t  len1 = TYPE_LENGTH (sinfo.field_type (1));\n-\t  offset = align_up (len0, riscv_type_alignment (sinfo.field_type (1)));\n+\t  int len1 = TYPE_LENGTH (sinfo.field_type (1));\n+\t  offset = sinfo.field_offset (1);\n \t  gdb_assert (len1 <= cinfo->xlen);\n \t  if (!riscv_assign_reg_location (&ainfo->argloc[1],\n \t\t\t\t\t  &cinfo->int_regs, len1, offset))\n@@ -2185,19 +2244,18 @@ riscv_call_arg_struct (struct riscv_arg_info *ainfo,\n \t      && TYPE_CODE (sinfo.field_type (1)) == TYPE_CODE_FLT\n \t      && TYPE_LENGTH (sinfo.field_type (1)) <= cinfo->flen))\n \t{\n-\t  int len0, len1, offset;\n-\n-\t  len0 = TYPE_LENGTH (sinfo.field_type (0));\n-\t  len1 = TYPE_LENGTH (sinfo.field_type (1));\n-\t  offset = align_up (len0, riscv_type_alignment (sinfo.field_type (1)));\n+\t  int len0 = TYPE_LENGTH (sinfo.field_type (0));\n+\t  int len1 = TYPE_LENGTH (sinfo.field_type (1));\n \n \t  gdb_assert (len0 <= cinfo->xlen);\n \t  gdb_assert (len1 <= cinfo->flen);\n \n+\t  int offset = sinfo.field_offset (0);\n \t  if (!riscv_assign_reg_location (&ainfo->argloc[0],\n-\t\t\t\t\t  &cinfo->int_regs, len0, 0))\n+\t\t\t\t\t  &cinfo->int_regs, len0, offset))\n \t    error (_(\"failed during argument setup\"));\n \n+\t  offset = sinfo.field_offset (1);\n \t  if (!riscv_assign_reg_location (&ainfo->argloc[1],\n \t\t\t\t\t  &cinfo->float_regs,\n \t\t\t\t\t  len1, offset))\n@@ -2233,6 +2291,8 @@ riscv_arg_location (struct gdbarch *gdbarch,\n   ainfo->align = riscv_type_alignment (ainfo->type);\n   ainfo->is_unnamed = is_unnamed;\n   ainfo->contents = nullptr;\n+  ainfo->argloc[0].c_length = 0;\n+  ainfo->argloc[1].c_length = 0;\n \n   switch (TYPE_CODE (ainfo->type))\n     {\n@@ -2474,10 +2534,11 @@ riscv_push_dummy_call (struct gdbarch *gdbarch,\n \t      memset (tmp, -1, sizeof (tmp));\n \t    else\n \t      memset (tmp, 0, sizeof (tmp));\n-\t    memcpy (tmp, info->contents, info->argloc[0].c_length);\n+\t    memcpy (tmp, (info->contents + info->argloc[0].c_offset),\n+\t\t    info->argloc[0].c_length);\n \t    regcache->cooked_write (info->argloc[0].loc_data.regno, tmp);\n \t    second_arg_length =\n-\t      ((info->argloc[0].c_length < info->length)\n+\t      (((info->argloc[0].c_length + info->argloc[0].c_offset) < info->length)\n \t       ? info->argloc[1].c_length : 0);\n \t    second_arg_data = info->contents + info->argloc[1].c_offset;\n \t  }\n@@ -2629,18 +2690,24 @@ riscv_return_value (struct gdbarch  *gdbarch,\n \t\t\t  <= register_size (gdbarch, regnum));\n \n \t      if (readbuf)\n-\t\tregcache->cooked_read_part (regnum, 0,\n-\t\t\t\t\t    info.argloc[0].c_length,\n-\t\t\t\t\t    readbuf);\n+\t\t{\n+\t\t  gdb_byte *ptr = readbuf + info.argloc[0].c_offset;\n+\t\t  regcache->cooked_read_part (regnum, 0,\n+\t\t\t\t\t      info.argloc[0].c_length,\n+\t\t\t\t\t      ptr);\n+\t\t}\n \n \t      if (writebuf)\n-\t\tregcache->cooked_write_part (regnum, 0,\n-\t\t\t\t\t     info.argloc[0].c_length,\n-\t\t\t\t\t     writebuf);\n+\t\t{\n+\t\t  const gdb_byte *ptr = writebuf + info.argloc[0].c_offset;\n+\t\t  regcache->cooked_write_part (regnum, 0,\n+\t\t\t\t\t       info.argloc[0].c_length,\n+\t\t\t\t\t       ptr);\n+\t\t}\n \n \t      /* A return value in register can have a second part in a\n \t\t second register.  */\n-\t      if (info.argloc[0].c_length < info.length)\n+\t      if (info.argloc[1].c_length > 0)\n \t\t{\n \t\t  switch (info.argloc[1].loc_type)\n \t\t    {"
    }
  ]
}