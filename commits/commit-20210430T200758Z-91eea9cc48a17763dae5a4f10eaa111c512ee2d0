{
  "sha": "91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTFlZWE5Y2M0OGExNzc2M2RhZTVhNGYxMGVhYTExMWM1MTJlZTJkMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-30T20:07:58Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-30T20:07:58Z"
    },
    "message": "Remove dwarf2_per_bfd::all_type_units\n\nI don't think there is any deep reason to separate CUs and TUs in\ndwarf2_per_bfd.  This patch removes all_type_units and unifies these\ntwo containers.  Some minor tweaks are needed to the index writers,\nbecause both forms of index keep CUs and TUs separate;\n\nRegression tested on x86-63 Fedora 32.\n\ngdb/ChangeLog\n2021-04-30  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.h (struct tu_stats) <nr_tus>: New member.\n\t(struct dwarf2_per_bfd) <get_cutu, get_tu>: Remove\n\t<get_cu>: Now inline.\n\t<all_type_units>: Remove.\n\t* dwarf2/read.c (dwarf2_per_bfd::~dwarf2_per_bfd): Update.\n\t(dwarf2_per_bfd::get_cutu, dwarf2_per_bfd::get_cu)\n\t(dwarf2_per_bfd::get_tu): Remove.\n\t(dwarf2_per_bfd::allocate_signatured_type): Update nr_tus.\n\t(create_signatured_type_table_from_index)\n\t(create_signatured_type_table_from_debug_names)\n\t(dw2_symtab_iter_next, dwarf2_base_index_functions::print_stats)\n\t(dwarf2_base_index_functions::expand_all_symtabs)\n\t(dw2_expand_marked_cus, dw_expand_symtabs_matching_file_matcher)\n\t(dwarf2_base_index_functions::map_symbol_filenames)\n\t(dw2_debug_names_iterator::next, dwarf2_initialize_objfile)\n\t(add_signatured_type_cu_to_table, create_all_type_units)\n\t(add_type_unit, build_type_psymtabs_1, print_tu_stats)\n\t(create_all_comp_units): Update.\n\t* dwarf2/index-write.c (check_dwarf64_offsets, write_gdbindex)\n\t(write_debug_names): Update.",
    "tree": {
      "sha": "22e069d7bba326a0e9500e7d4ebcaaf8ae850382",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/22e069d7bba326a0e9500e7d4ebcaaf8ae850382"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0d305d5c67e38a65f227e6604c0812797471ace6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d305d5c67e38a65f227e6604c0812797471ace6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0d305d5c67e38a65f227e6604c0812797471ace6"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 87,
    "deletions": 123
  },
  "files": [
    {
      "sha": "fb82dbed51ddc6165b21f9f02d5138fe90ff1f9e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
      "patch": "@@ -1,3 +1,26 @@\n+2021-04-30  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.h (struct tu_stats) <nr_tus>: New member.\n+\t(struct dwarf2_per_bfd) <get_cutu, get_tu>: Remove\n+\t<get_cu>: Now inline.\n+\t<all_type_units>: Remove.\n+\t* dwarf2/read.c (dwarf2_per_bfd::~dwarf2_per_bfd): Update.\n+\t(dwarf2_per_bfd::get_cutu, dwarf2_per_bfd::get_cu)\n+\t(dwarf2_per_bfd::get_tu): Remove.\n+\t(dwarf2_per_bfd::allocate_signatured_type): Update nr_tus.\n+\t(create_signatured_type_table_from_index)\n+\t(create_signatured_type_table_from_debug_names)\n+\t(dw2_symtab_iter_next, dwarf2_base_index_functions::print_stats)\n+\t(dwarf2_base_index_functions::expand_all_symtabs)\n+\t(dw2_expand_marked_cus, dw_expand_symtabs_matching_file_matcher)\n+\t(dwarf2_base_index_functions::map_symbol_filenames)\n+\t(dw2_debug_names_iterator::next, dwarf2_initialize_objfile)\n+\t(add_signatured_type_cu_to_table, create_all_type_units)\n+\t(add_type_unit, build_type_psymtabs_1, print_tu_stats)\n+\t(create_all_comp_units): Update.\n+\t* dwarf2/index-write.c (check_dwarf64_offsets, write_gdbindex)\n+\t(write_debug_names): Update.\n+\n 2021-04-30  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.h (struct dwarf2_per_bfd) <allocate_per_cu,"
    },
    {
      "sha": "8cdfac7980592c934c33492d92bb6337b7eeb83d",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 18,
      "deletions": 11,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
      "patch": "@@ -1318,12 +1318,6 @@ check_dwarf64_offsets (dwarf2_per_objfile *per_objfile)\n \t  >= (static_cast<uint64_t> (1) << 32))\n \treturn true;\n     }\n-  for (const auto &sigtype : per_objfile->per_bfd->all_type_units)\n-    {\n-      if (to_underlying (sigtype->sect_off)\n-\t  >= (static_cast<uint64_t> (1) << 32))\n-\treturn true;\n-    }\n   return false;\n }\n \n@@ -1438,10 +1432,14 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n \n   std::unordered_set<partial_symbol *> psyms_seen\n     (psyms_seen_size (per_objfile));\n+  int counter = 0;\n   for (int i = 0; i < per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n       dwarf2_per_cu_data *per_cu\n \t= per_objfile->per_bfd->all_comp_units[i].get ();\n+      if (per_cu->is_debug_types)\n+\tcontinue;\n+\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       if (psymtab != NULL)\n@@ -1450,7 +1448,7 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n \t    recursively_write_psymbols (objfile, psymtab, &symtab,\n \t\t\t\t\tpsyms_seen, i);\n \n-\t  const auto insertpair = cu_index_htab.emplace (psymtab, i);\n+\t  const auto insertpair = cu_index_htab.emplace (psymtab, counter);\n \t  gdb_assert (insertpair.second);\n \t}\n \n@@ -1461,6 +1459,7 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n       cu_list.append_uint (8, BFD_ENDIAN_LITTLE,\n \t\t\t   to_underlying (per_cu->sect_off));\n       cu_list.append_uint (8, BFD_ENDIAN_LITTLE, per_cu->length);\n+      ++counter;\n     }\n \n   /* Dump the address map.  */\n@@ -1476,7 +1475,8 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n \n       sig_data.objfile = objfile;\n       sig_data.symtab = &symtab;\n-      sig_data.cu_index = per_objfile->per_bfd->all_comp_units.size ();\n+      sig_data.cu_index = (per_objfile->per_bfd->all_comp_units.size ()\n+\t\t\t   - per_objfile->per_bfd->tu_stats.nr_tus);\n       htab_traverse_noresize (per_objfile->per_bfd->signatured_types.get (),\n \t\t\t      write_one_signatured_type, &sig_data);\n     }\n@@ -1520,10 +1520,14 @@ write_debug_names (dwarf2_per_objfile *per_objfile,\n   debug_names nametable (per_objfile, dwarf5_is_dwarf64, dwarf5_byte_order);\n   std::unordered_set<partial_symbol *>\n     psyms_seen (psyms_seen_size (per_objfile));\n+  int counter = 0;\n   for (int i = 0; i < per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n       const dwarf2_per_cu_data *per_cu\n \t= per_objfile->per_bfd->all_comp_units[i].get ();\n+      if (per_cu->is_debug_types)\n+\tcontinue;\n+\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       /* CU of a shared file from 'dwz -m' may be unused by this main\n@@ -1533,10 +1537,12 @@ write_debug_names (dwarf2_per_objfile *per_objfile,\n \tcontinue;\n \n       if (psymtab->user == NULL)\n-\tnametable.recursively_write_psymbols (objfile, psymtab, psyms_seen, i);\n+\tnametable.recursively_write_psymbols (objfile, psymtab, psyms_seen,\n+\t\t\t\t\t      counter);\n \n       cu_list.append_uint (nametable.dwarf5_offset_size (), dwarf5_byte_order,\n \t\t\t   to_underlying (per_cu->sect_off));\n+      ++counter;\n     }\n \n   /* Write out the .debug_type entries, if any.  */\n@@ -1590,12 +1596,13 @@ write_debug_names (dwarf2_per_objfile *per_objfile,\n \n   /* comp_unit_count - The number of CUs in the CU list.  */\n   header.append_uint (4, dwarf5_byte_order,\n-\t\t      per_objfile->per_bfd->all_comp_units.size ());\n+\t\t      per_objfile->per_bfd->all_comp_units.size ()\n+\t\t      - per_objfile->per_bfd->tu_stats.nr_tus);\n \n   /* local_type_unit_count - The number of TUs in the local TU\n      list.  */\n   header.append_uint (4, dwarf5_byte_order,\n-\t\t      per_objfile->per_bfd->all_type_units.size ());\n+\t\t      per_objfile->per_bfd->tu_stats.nr_tus);\n \n   /* foreign_type_unit_count - The number of TUs in the foreign TU\n      list.  */"
    },
    {
      "sha": "f3c413a89932b7c3d3f0207a39e5477e807a9f2d",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 40,
      "deletions": 86,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
      "patch": "@@ -1900,9 +1900,6 @@ dwarf2_per_bfd::~dwarf2_per_bfd ()\n   for (auto &per_cu : all_comp_units)\n     per_cu->imported_symtabs_free ();\n \n-  for (auto &sig_type : all_type_units)\n-    sig_type->imported_symtabs_free ();\n-\n   /* Everything else should be on this->obstack.  */\n }\n \n@@ -2525,41 +2522,6 @@ dw2_instantiate_symtab (dwarf2_per_cu_data *per_cu,\n   return per_objfile->get_symtab (per_cu);\n }\n \n-/* See declaration.  */\n-\n-dwarf2_per_cu_data *\n-dwarf2_per_bfd::get_cutu (int index)\n-{\n-  if (index >= this->all_comp_units.size ())\n-    {\n-      index -= this->all_comp_units.size ();\n-      gdb_assert (index < this->all_type_units.size ());\n-      return this->all_type_units[index].get ();\n-    }\n-\n-  return this->all_comp_units[index].get ();\n-}\n-\n-/* See declaration.  */\n-\n-dwarf2_per_cu_data *\n-dwarf2_per_bfd::get_cu (int index)\n-{\n-  gdb_assert (index >= 0 && index < this->all_comp_units.size ());\n-\n-  return this->all_comp_units[index].get ();\n-}\n-\n-/* See declaration.  */\n-\n-signatured_type *\n-dwarf2_per_bfd::get_tu (int index)\n-{\n-  gdb_assert (index >= 0 && index < this->all_type_units.size ());\n-\n-  return this->all_type_units[index].get ();\n-}\n-\n /* See read.h.  */\n \n std::unique_ptr<dwarf2_per_cu_data>\n@@ -2579,6 +2541,7 @@ dwarf2_per_bfd::allocate_signatured_type ()\n   std::unique_ptr<signatured_type> result (new signatured_type);\n   result->per_bfd = this;\n   result->index = m_num_psymtabs++;\n+  tu_stats.nr_tus++;\n   return result;\n }\n \n@@ -2655,9 +2618,6 @@ create_signatured_type_table_from_index\n   (dwarf2_per_bfd *per_bfd, struct dwarf2_section_info *section,\n    const gdb_byte *bytes, offset_type elements)\n {\n-  gdb_assert (per_bfd->all_type_units.empty ());\n-  per_bfd->all_type_units.reserve (elements / 3);\n-\n   htab_up sig_types_hash = allocate_signatured_type_table ();\n \n   for (offset_type i = 0; i < elements; i += 3)\n@@ -2689,7 +2649,7 @@ create_signatured_type_table_from_index\n       slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n       *slot = sig_type.get ();\n \n-      per_bfd->all_type_units.push_back (std::move (sig_type));\n+      per_bfd->all_comp_units.push_back (std::move (sig_type));\n     }\n \n   per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -2709,9 +2669,6 @@ create_signatured_type_table_from_debug_names\n   section->read (objfile);\n   abbrev_section->read (objfile);\n \n-  gdb_assert (per_objfile->per_bfd->all_type_units.empty ());\n-  per_objfile->per_bfd->all_type_units.reserve (map.tu_count);\n-\n   htab_up sig_types_hash = allocate_signatured_type_table ();\n \n   for (uint32_t i = 0; i < map.tu_count; ++i)\n@@ -2744,7 +2701,7 @@ create_signatured_type_table_from_debug_names\n       slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n       *slot = sig_type.get ();\n \n-      per_objfile->per_bfd->all_type_units.push_back (std::move (sig_type));\n+      per_objfile->per_bfd->all_comp_units.push_back (std::move (sig_type));\n     }\n \n   per_objfile->per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -3421,15 +3378,14 @@ dw2_symtab_iter_next (struct dw2_symtab_iterator *iter)\n \t && symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);\n \n       /* Don't crash on bad data.  */\n-      if (cu_index >= (per_objfile->per_bfd->all_comp_units.size ()\n-\t\t       + per_objfile->per_bfd->all_type_units.size ()))\n+      if (cu_index >= per_objfile->per_bfd->all_comp_units.size ())\n \t{\n \t  complaint (_(\".gdb_index entry has bad CU index\"\n \t\t       \" [in module %s]\"), objfile_name (per_objfile->objfile));\n \t  continue;\n \t}\n \n-      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cutu (cu_index);\n+      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cu (cu_index);\n \n       /* Skip if already read in.  */\n       if (per_objfile->symtab_set_p (per_cu))\n@@ -3503,13 +3459,12 @@ dwarf2_base_index_functions::print_stats (struct objfile *objfile,\n     return;\n \n   dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n-  int total = (per_objfile->per_bfd->all_comp_units.size ()\n-\t       + per_objfile->per_bfd->all_type_units.size ());\n+  int total = per_objfile->per_bfd->all_comp_units.size ();\n   int count = 0;\n \n   for (int i = 0; i < total; ++i)\n     {\n-      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cutu (i);\n+      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cu (i);\n \n       if (!per_objfile->symtab_set_p (per_cu))\n \t++count;\n@@ -3544,12 +3499,11 @@ void\n dwarf2_base_index_functions::expand_all_symtabs (struct objfile *objfile)\n {\n   dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n-  int total_units = (per_objfile->per_bfd->all_comp_units.size ()\n-\t\t     + per_objfile->per_bfd->all_type_units.size ());\n+  int total_units = per_objfile->per_bfd->all_comp_units.size ();\n \n   for (int i = 0; i < total_units; ++i)\n     {\n-      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cutu (i);\n+      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cu (i);\n \n       /* We don't want to directly expand a partial CU, because if we\n \t read it with the wrong language, then assertion failures can\n@@ -4498,15 +4452,14 @@ dw2_expand_marked_cus\n \t}\n \n       /* Don't crash on bad data.  */\n-      if (cu_index >= (per_objfile->per_bfd->all_comp_units.size ()\n-\t\t       + per_objfile->per_bfd->all_type_units.size ()))\n+      if (cu_index >= per_objfile->per_bfd->all_comp_units.size ())\n \t{\n \t  complaint (_(\".gdb_index entry has bad CU index\"\n \t\t       \" [in module %s]\"), objfile_name (per_objfile->objfile));\n \t  continue;\n \t}\n \n-      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cutu (cu_index);\n+      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->get_cu (cu_index);\n       if (!dw2_expand_symtabs_matching_one (per_cu, per_objfile, file_matcher,\n \t\t\t\t\t    expansion_notify))\n \treturn false;\n@@ -4541,6 +4494,8 @@ dw_expand_symtabs_matching_file_matcher\n     {\n       QUIT;\n \n+      if (per_cu->is_debug_types)\n+\tcontinue;\n       per_cu->v.quick->mark = 0;\n \n       /* We only need to look at symtabs not already expanded.  */\n@@ -5353,19 +5308,19 @@ dw2_debug_names_iterator::next ()\n \t\t\t objfile_name (objfile));\n \t      continue;\n \t    }\n-\t  per_cu = per_bfd->get_cutu (ull);\n+\t  per_cu = per_bfd->get_cu (ull);\n \t  break;\n \tcase DW_IDX_type_unit:\n \t  /* Don't crash on bad data.  */\n-\t  if (ull >= per_bfd->all_type_units.size ())\n+\t  if (ull >= per_bfd->tu_stats.nr_tus)\n \t    {\n \t      complaint (_(\".debug_names entry has bad TU index %s\"\n \t\t\t   \" [in module %s]\"),\n \t\t\t pulongest (ull),\n \t\t\t objfile_name (objfile));\n \t      continue;\n \t    }\n-\t  per_cu = per_bfd->get_tu (ull);\n+\t  per_cu = per_bfd->get_cu (ull + per_bfd->tu_stats.nr_tus);\n \t  break;\n \tcase DW_IDX_die_offset:\n \t  /* In a per-CU index (as opposed to a per-module index), index\n@@ -5706,10 +5661,9 @@ dwarf2_initialize_objfile (struct objfile *objfile)\n \t= create_quick_file_names_table (per_bfd->all_comp_units.size ());\n       per_objfile->resize_symtabs ();\n \n-      for (int i = 0; i < (per_bfd->all_comp_units.size ()\n-\t\t\t   + per_bfd->all_type_units.size ()); ++i)\n+      for (int i = 0; i < per_bfd->all_comp_units.size (); ++i)\n \t{\n-\t  dwarf2_per_cu_data *per_cu = per_bfd->get_cutu (i);\n+\t  dwarf2_per_cu_data *per_cu = per_bfd->get_cu (i);\n \n \t  per_cu->v.quick = OBSTACK_ZALLOC (&per_bfd->obstack,\n \t\t\t\t\t    struct dwarf2_per_cu_quick_data);\n@@ -6054,10 +6008,10 @@ static int\n add_signatured_type_cu_to_table (void **slot, void *datum)\n {\n   struct signatured_type *sigt = (struct signatured_type *) *slot;\n-  std::vector<std::unique_ptr<signatured_type>> *all_type_units\n-    = (std::vector<std::unique_ptr<signatured_type>> *) datum;\n+  std::vector<std::unique_ptr<dwarf2_per_cu_data>> *all_comp_units\n+    = (std::vector<std::unique_ptr<dwarf2_per_cu_data>> *) datum;\n \n-  all_type_units->emplace_back (sigt);\n+  all_comp_units->emplace_back (sigt);\n \n   return 1;\n }\n@@ -6225,7 +6179,7 @@ create_debug_types_hash_table (dwarf2_per_objfile *per_objfile,\n }\n \n /* Create the hash table of all entries in the .debug_types section,\n-   and initialize all_type_units.\n+   and update all_comp_units.\n    The result is zero if there is an error (e.g. missing .debug_types section),\n    otherwise non-zero.\t*/\n \n@@ -6246,13 +6200,9 @@ create_all_type_units (dwarf2_per_objfile *per_objfile)\n \n   per_objfile->per_bfd->signatured_types = std::move (types_htab);\n \n-  gdb_assert (per_objfile->per_bfd->all_type_units.empty ());\n-  per_objfile->per_bfd->all_type_units.reserve\n-    (htab_elements (per_objfile->per_bfd->signatured_types.get ()));\n-\n   htab_traverse_noresize (per_objfile->per_bfd->signatured_types.get (),\n \t\t\t  add_signatured_type_cu_to_table,\n-\t\t\t  &per_objfile->per_bfd->all_type_units);\n+\t\t\t  &per_objfile->per_bfd->all_comp_units);\n \n   return 1;\n }\n@@ -6264,8 +6214,8 @@ create_all_type_units (dwarf2_per_objfile *per_objfile)\n static struct signatured_type *\n add_type_unit (dwarf2_per_objfile *per_objfile, ULONGEST sig, void **slot)\n {\n-  if (per_objfile->per_bfd->all_type_units.size ()\n-      == per_objfile->per_bfd->all_type_units.capacity ())\n+  if (per_objfile->per_bfd->all_comp_units.size ()\n+      == per_objfile->per_bfd->all_comp_units.capacity ())\n     ++per_objfile->per_bfd->tu_stats.nr_all_type_units_reallocs;\n \n   std::unique_ptr<signatured_type> sig_type_holder\n@@ -6274,7 +6224,7 @@ add_type_unit (dwarf2_per_objfile *per_objfile, ULONGEST sig, void **slot)\n \n   per_objfile->resize_symtabs ();\n \n-  per_objfile->per_bfd->all_type_units.push_back (std::move (sig_type_holder));\n+  per_objfile->per_bfd->all_comp_units.push_back (std::move (sig_type_holder));\n   sig_type->signature = sig;\n   sig_type->is_debug_types = 1;\n   if (per_objfile->per_bfd->using_index)\n@@ -7534,7 +7484,7 @@ build_type_psymtabs_1 (dwarf2_per_objfile *per_objfile)\n   /* It's up to the caller to not call us multiple times.  */\n   gdb_assert (per_objfile->per_bfd->type_unit_groups == NULL);\n \n-  if (per_objfile->per_bfd->all_type_units.empty ())\n+  if (per_objfile->per_bfd->tu_stats.nr_tus == 0)\n     return;\n \n   /* TUs typically share abbrev tables, and there can be way more TUs than\n@@ -7558,15 +7508,21 @@ build_type_psymtabs_1 (dwarf2_per_objfile *per_objfile)\n \n   dwarf_read_debug_printf (\"Building type unit groups ...\");\n \n-  /* Sort in a separate table to maintain the order of all_type_units\n+  /* Sort in a separate table to maintain the order of all_comp_units\n      for .gdb_index: TU indices directly index all_type_units.  */\n   std::vector<tu_abbrev_offset> sorted_by_abbrev;\n-  sorted_by_abbrev.reserve (per_objfile->per_bfd->all_type_units.size ());\n+  sorted_by_abbrev.reserve (per_objfile->per_bfd->tu_stats.nr_tus);\n \n-  for (const auto &sig_type : per_objfile->per_bfd->all_type_units)\n-    sorted_by_abbrev.emplace_back\n-      (sig_type.get (), read_abbrev_offset (per_objfile, sig_type->section,\n-\t\t\t\t\t    sig_type->sect_off));\n+  for (const auto &cu : per_objfile->per_bfd->all_comp_units)\n+    {\n+      if (cu->is_debug_types)\n+\t{\n+\t  auto sig_type = static_cast<signatured_type *> (cu.get ());\n+\t  sorted_by_abbrev.emplace_back\n+\t    (sig_type, read_abbrev_offset (per_objfile, sig_type->section,\n+\t\t\t\t\t   sig_type->sect_off));\n+\t}\n+    }\n \n   std::sort (sorted_by_abbrev.begin (), sorted_by_abbrev.end (),\n \t     sort_tu_by_abbrev_offset);\n@@ -7602,8 +7558,7 @@ print_tu_stats (dwarf2_per_objfile *per_objfile)\n   struct tu_stats *tu_stats = &per_objfile->per_bfd->tu_stats;\n \n   dwarf_read_debug_printf (\"Type unit statistics:\");\n-  dwarf_read_debug_printf (\"  %zu TUs\",\n-\t\t\t   per_objfile->per_bfd->all_type_units.size ());\n+  dwarf_read_debug_printf (\"  %d TUs\", tu_stats->nr_tus);\n   dwarf_read_debug_printf (\"  %d uniq abbrev tables\",\n \t\t\t   tu_stats->nr_uniq_abbrev_tables);\n   dwarf_read_debug_printf (\"  %d symtabs from stmt_list entries\",\n@@ -7896,7 +7851,6 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n static void\n create_all_comp_units (dwarf2_per_objfile *per_objfile)\n {\n-  gdb_assert (per_objfile->per_bfd->all_comp_units.empty ());\n   read_comp_units_from_section (per_objfile, &per_objfile->per_bfd->info,\n \t\t\t\t&per_objfile->per_bfd->abbrev, 0);\n "
    },
    {
      "sha": "80f0e3ee13bb666bb7ea0e5f0afa8c5a6b0ad13f",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 6,
      "deletions": 26,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91eea9cc48a17763dae5a4f10eaa111c512ee2d0/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=91eea9cc48a17763dae5a4f10eaa111c512ee2d0",
      "patch": "@@ -42,6 +42,7 @@ struct tu_stats\n   int nr_symtab_sharers;\n   int nr_stmt_less_type_units;\n   int nr_all_type_units_reallocs;\n+  int nr_tus;\n };\n \n struct dwarf2_cu;\n@@ -93,29 +94,11 @@ struct dwarf2_per_bfd\n \n   DISABLE_COPY_AND_ASSIGN (dwarf2_per_bfd);\n \n-  /* Return the CU/TU given its index.\n-\n-     This is intended for loops like:\n-\n-     for (i = 0; i < (dwarf2_per_bfd->n_comp_units\n-\t\t      + dwarf2_per_bfd->n_type_units); ++i)\n-       {\n-\t dwarf2_per_cu_data *per_cu = dwarf2_per_bfd->get_cutu (i);\n-\n-\t ...;\n-       }\n-  */\n-  dwarf2_per_cu_data *get_cutu (int index);\n-\n-  /* Return the CU given its index.\n-     This differs from get_cutu in that it's for when you know INDEX refers to a\n-     CU.  */\n-  dwarf2_per_cu_data *get_cu (int index);\n-\n-  /* Return the TU given its index.\n-     This differs from get_cutu in that it's for when you know INDEX refers to a\n-     TU.  */\n-  signatured_type *get_tu (int index);\n+  /* Return the CU given its index.  */\n+  dwarf2_per_cu_data *get_cu (int index) const\n+  {\n+    return this->all_comp_units[index].get ();\n+  }\n \n   /* A convenience function to allocate a dwarf2_per_cu_data.  The\n      returned object has its \"index\" field set properly.  The object\n@@ -173,9 +156,6 @@ struct dwarf2_per_bfd\n      the target compilation unit of a particular reference.  */\n   std::vector<std::unique_ptr<dwarf2_per_cu_data>> all_comp_units;\n \n-  /* The .debug_types-related CUs (TUs).  */\n-  std::vector<std::unique_ptr<signatured_type>> all_type_units;\n-\n   /* Table of struct type_unit_group objects.\n      The hash key is the DW_AT_stmt_list value.  */\n   htab_up type_unit_groups;"
    }
  ]
}