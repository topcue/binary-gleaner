{
  "sha": "4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
  "node_id": "C_kwDOANOeidoAKDRhOTJkZWRjNTkyZmQwZDVlOGJiZjk5ODdlZDI2MDJiOTI2MDdiZWQ",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-05T17:29:43Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:38Z"
    },
    "message": "sim: erc32: migrate to standard uintXX_t types\n\nThis old port setup its own uintXX types, but since we require C11\nnow, we can assume the standard uintXX_t types exist and use them.",
    "tree": {
      "sha": "900dbb4cdaeccdbf6f51389468fdef3315bd7c45",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/900dbb4cdaeccdbf6f51389468fdef3315bd7c45"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74ccc978200bc96b48ef52385cadf5ddb131dc21",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/74ccc978200bc96b48ef52385cadf5ddb131dc21"
    }
  ],
  "stats": {
    "total": 617,
    "additions": 305,
    "deletions": 312
  },
  "files": [
    {
      "sha": "0206c02e6f0ecacf2be4041c51e7686628642eca",
      "filename": "sim/erc32/erc32.c",
      "status": "modified",
      "additions": 117,
      "deletions": 117,
      "changes": 234,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/erc32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/erc32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/erc32.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -34,8 +34,8 @@\n #include \"sim-config.h\"\n \n extern int      ctrl_c;\n-extern int32    sis_verbose;\n-extern int32    sparclite, sparclite_board;\n+extern int32_t    sis_verbose;\n+extern int32_t    sparclite, sparclite_board;\n extern int      rom8,wrp,uben;\n extern char     uart_dev1[], uart_dev2[];\n \n@@ -147,45 +147,45 @@ extern int errmec;\n /* MEC registers */\n \n static char     fname[256];\n-static int32    find = 0;\n-static uint32   mec_ssa[2];\t/* Write protection start address */\n-static uint32   mec_sea[2];\t/* Write protection end address */\n-static uint32   mec_wpr[2];\t/* Write protection control fields */\n-static uint32   mec_sfsr;\n-static uint32   mec_ffar;\n-static uint32   mec_ipr;\n-static uint32   mec_imr;\n-static uint32   mec_isr;\n-static uint32   mec_icr;\n-static uint32   mec_ifr;\n-static uint32   mec_mcr;\t/* MEC control register */\n-static uint32   mec_memcfg;\t/* Memory control register */\n-static uint32   mec_wcr;\t/* MEC waitstate register */\n-static uint32   mec_iocr;\t/* MEC IO control register */\n-static uint32   posted_irq;\n-static uint32   mec_ersr;\t/* MEC error and status register */\n-static uint32   mec_tcr;\t/* MEC test comtrol register */\n-\n-static uint32   rtc_counter;\n-static uint32   rtc_reload;\n-static uint32   rtc_scaler;\n-static uint32   rtc_scaler_start;\n-static uint32   rtc_enabled;\n-static uint32   rtc_cr;\n-static uint32   rtc_se;\n-\n-static uint32   gpt_counter;\n-static uint32   gpt_reload;\n-static uint32   gpt_scaler;\n-static uint32   gpt_scaler_start;\n-static uint32   gpt_enabled;\n-static uint32   gpt_cr;\n-static uint32   gpt_se;\n-\n-static uint32   wdog_scaler;\n-static uint32   wdog_counter;\n-static uint32   wdog_rst_delay;\n-static uint32   wdog_rston;\n+static int32_t    find = 0;\n+static uint32_t   mec_ssa[2];\t/* Write protection start address */\n+static uint32_t   mec_sea[2];\t/* Write protection end address */\n+static uint32_t   mec_wpr[2];\t/* Write protection control fields */\n+static uint32_t   mec_sfsr;\n+static uint32_t   mec_ffar;\n+static uint32_t   mec_ipr;\n+static uint32_t   mec_imr;\n+static uint32_t   mec_isr;\n+static uint32_t   mec_icr;\n+static uint32_t   mec_ifr;\n+static uint32_t   mec_mcr;\t/* MEC control register */\n+static uint32_t   mec_memcfg;\t/* Memory control register */\n+static uint32_t   mec_wcr;\t/* MEC waitstate register */\n+static uint32_t   mec_iocr;\t/* MEC IO control register */\n+static uint32_t   posted_irq;\n+static uint32_t   mec_ersr;\t/* MEC error and status register */\n+static uint32_t   mec_tcr;\t/* MEC test comtrol register */\n+\n+static uint32_t   rtc_counter;\n+static uint32_t   rtc_reload;\n+static uint32_t   rtc_scaler;\n+static uint32_t   rtc_scaler_start;\n+static uint32_t   rtc_enabled;\n+static uint32_t   rtc_cr;\n+static uint32_t   rtc_se;\n+\n+static uint32_t   gpt_counter;\n+static uint32_t   gpt_reload;\n+static uint32_t   gpt_scaler;\n+static uint32_t   gpt_scaler_start;\n+static uint32_t   gpt_enabled;\n+static uint32_t   gpt_cr;\n+static uint32_t   gpt_se;\n+\n+static uint32_t   wdog_scaler;\n+static uint32_t   wdog_counter;\n+static uint32_t   wdog_rst_delay;\n+static uint32_t   wdog_rston;\n \n enum wdog_type {\n     init, disabled, enabled, stopped\n@@ -210,29 +210,29 @@ static enum wdog_type wdog_status;\n \n /* Memory support variables */\n \n-static uint32   mem_ramr_ws;\t/* RAM read waitstates */\n-static uint32   mem_ramw_ws;\t/* RAM write waitstates */\n-static uint32   mem_romr_ws;\t/* ROM read waitstates */\n-static uint32   mem_romw_ws;\t/* ROM write waitstates */\n-static uint32\tmem_ramstart;\t/* RAM start */\n-static uint32\tmem_ramend;\t/* RAM end */\n-static uint32\tmem_rammask;\t/* RAM address mask */\n-static uint32   mem_ramsz;\t/* RAM size */\n-static uint32   mem_romsz;\t/* ROM size */\n-static uint32   mem_accprot;\t/* RAM write protection enabled */\n-static uint32   mem_blockprot;\t/* RAM block write protection enabled */\n+static uint32_t   mem_ramr_ws;\t/* RAM read waitstates */\n+static uint32_t   mem_ramw_ws;\t/* RAM write waitstates */\n+static uint32_t   mem_romr_ws;\t/* ROM read waitstates */\n+static uint32_t   mem_romw_ws;\t/* ROM write waitstates */\n+static uint32_t\tmem_ramstart;\t/* RAM start */\n+static uint32_t\tmem_ramend;\t/* RAM end */\n+static uint32_t\tmem_rammask;\t/* RAM address mask */\n+static uint32_t   mem_ramsz;\t/* RAM size */\n+static uint32_t   mem_romsz;\t/* ROM size */\n+static uint32_t   mem_accprot;\t/* RAM write protection enabled */\n+static uint32_t   mem_blockprot;\t/* RAM block write protection enabled */\n \n static unsigned char\tromb[ROM_SZ];\n static unsigned char\tramb[RAM_END - RAM_START];\n \n \n /* UART support variables */\n \n-static int32    fd1, fd2;\t/* file descriptor for input file */\n-static int32    Ucontrol;\t/* UART status register */\n+static int32_t    fd1, fd2;\t/* file descriptor for input file */\n+static int32_t    Ucontrol;\t/* UART status register */\n static unsigned char aq[UARTBUF], bq[UARTBUF];\n-static int32    anum, aind = 0;\n-static int32    bnum, bind = 0;\n+static int32_t    anum, aind = 0;\n+static int32_t    bnum, bind = 0;\n static char     wbufa[UARTBUF], wbufb[UARTBUF];\n static unsigned wnuma;\n static unsigned wnumb;\n@@ -243,8 +243,8 @@ static struct termios ioc1, ioc2, iocold1, iocold2;\n static int      f1open = 0, f2open = 0;\n \n static char     uarta_sreg, uarta_hreg, uartb_sreg, uartb_hreg;\n-static uint32   uart_stat_reg;\n-static uint32   uarta_data, uartb_data;\n+static uint32_t   uart_stat_reg;\n+static uint32_t   uarta_data, uartb_data;\n \n #ifdef ERA\n int era = 0;\n@@ -263,16 +263,16 @@ static void\tdecode_wcr (void);\n static void\tdecode_mcr (void);\n static void\tclose_port (void);\n static void\tmec_reset (void);\n-static void\tmec_intack (int32 level);\n+static void\tmec_intack (int32_t level);\n static void\tchk_irq (void);\n-static void\tmec_irq (int32 level);\n-static void\tset_sfsr (uint32 fault, uint32 addr,\n-\t\t\t  uint32 asi, uint32 read);\n-static int32\tmec_read (uint32 addr, uint32 asi, uint32 *data);\n-static int\tmec_write (uint32 addr, uint32 data);\n+static void\tmec_irq (int32_t level);\n+static void\tset_sfsr (uint32_t fault, uint32_t addr,\n+\t\t\t  uint32_t asi, uint32_t read);\n+static int32_t\tmec_read (uint32_t addr, uint32_t asi, uint32_t *data);\n+static int\tmec_write (uint32_t addr, uint32_t data);\n static void\tport_init (void);\n-static uint32\tread_uart (uint32 addr);\n-static void\twrite_uart (uint32 addr, uint32 data);\n+static uint32_t\tread_uart (uint32_t addr);\n+static void\twrite_uart (uint32_t addr, uint32_t data);\n static void\tflush_uart (void);\n static void\tuarta_tx (void);\n static void\tuartb_tx (void);\n@@ -283,18 +283,18 @@ static void\twdog_intr (void *arg);\n static void\twdog_start (void);\n static void\trtc_intr (void *arg);\n static void\trtc_start (void);\n-static uint32\trtc_counter_read (void);\n-static void\trtc_scaler_set (uint32 val);\n-static void\trtc_reload_set (uint32 val);\n+static uint32_t\trtc_counter_read (void);\n+static void\trtc_scaler_set (uint32_t val);\n+static void\trtc_reload_set (uint32_t val);\n static void\tgpt_intr (void *arg);\n static void\tgpt_start (void);\n-static uint32\tgpt_counter_read (void);\n-static void\tgpt_scaler_set (uint32 val);\n-static void\tgpt_reload_set (uint32 val);\n-static void\ttimer_ctrl (uint32 val);\n-static void *\tget_mem_ptr (uint32 addr, uint32 size);\n-static void\tstore_bytes (unsigned char *mem, uint32 waddr,\n-\t\t\tuint32 *data, int sz, int32 *ws);\n+static uint32_t\tgpt_counter_read (void);\n+static void\tgpt_scaler_set (uint32_t val);\n+static void\tgpt_reload_set (uint32_t val);\n+static void\ttimer_ctrl (uint32_t val);\n+static void *\tget_mem_ptr (uint32_t addr, uint32_t size);\n+static void\tstore_bytes (unsigned char *mem, uint32_t waddr,\n+\t\t\tuint32_t *data, int sz, int32_t *ws);\n \n extern int\text_irl;\n \n@@ -390,7 +390,7 @@ mecparerror(void)\n /* IU error mode manager */\n \n void\n-error_mode(uint32 pc)\n+error_mode(uint32_t pc)\n {\n \n     mec_ersr |= 0x1;\n@@ -551,7 +551,7 @@ mec_reset(void)\n \n \n static void\n-mec_intack(int32 level)\n+mec_intack(int32_t level)\n {\n     int             irq_test;\n \n@@ -568,8 +568,8 @@ mec_intack(int32 level)\n static void\n chk_irq(void)\n {\n-    int32           i;\n-    uint32          itmp;\n+    int32_t           i;\n+    uint32_t          itmp;\n     int\t\t    old_irl;\n \n     old_irl = ext_irl;\n@@ -591,14 +591,14 @@ chk_irq(void)\n }\n \n static void\n-mec_irq(int32 level)\n+mec_irq(int32_t level)\n {\n     mec_ipr |= (1 << level);\n     chk_irq();\n }\n \n static void\n-set_sfsr(uint32 fault, uint32 addr, uint32 asi, uint32 read)\n+set_sfsr(uint32_t fault, uint32_t addr, uint32_t asi, uint32_t read)\n {\n     if ((asi == 0xa) || (asi == 0xb)) {\n \tmec_ffar = addr;\n@@ -615,8 +615,8 @@ set_sfsr(uint32 fault, uint32 addr, uint32 asi, uint32 read)\n     }\n }\n \n-static int32\n-mec_read(uint32 addr, uint32 asi, uint32 *data)\n+static int32_t\n+mec_read(uint32_t addr, uint32_t asi, uint32_t *data)\n {\n \n     switch (addr & 0x0ff) {\n@@ -743,7 +743,7 @@ mec_read(uint32 addr, uint32 asi, uint32 *data)\n }\n \n static int\n-mec_write(uint32 addr, uint32 data)\n+mec_write(uint32_t addr, uint32_t data)\n {\n     if (sis_verbose > 1)\n \tprintf(\"MEC write a: %08x, d: %08x\\n\",addr,data);\n@@ -1039,8 +1039,8 @@ port_init(void)\n \n }\n \n-static uint32\n-read_uart(uint32 addr)\n+static uint32_t\n+read_uart(uint32_t addr)\n {\n \n     unsigned        tmp;\n@@ -1055,7 +1055,7 @@ read_uart(uint32 addr)\n \tif (aind < anum) {\n \t    if ((aind + 1) < anum)\n \t\tmec_irq(4);\n-\t    return (0x700 | (uint32) aq[aind++]);\n+\t    return (0x700 | (uint32_t) aq[aind++]);\n \t} else {\n \t    if (f1open) {\n \t        anum = DO_STDIO_READ(ifd1, aq, UARTBUF);\n@@ -1064,9 +1064,9 @@ read_uart(uint32 addr)\n \t\taind = 0;\n \t\tif ((aind + 1) < anum)\n \t\t    mec_irq(4);\n-\t\treturn (0x700 | (uint32) aq[aind++]);\n+\t\treturn (0x700 | (uint32_t) aq[aind++]);\n \t    } else {\n-\t\treturn (0x600 | (uint32) aq[aind]);\n+\t\treturn (0x600 | (uint32_t) aq[aind]);\n \t    }\n \n \t}\n@@ -1087,7 +1087,7 @@ read_uart(uint32 addr)\n \tif (bind < bnum) {\n \t    if ((bind + 1) < bnum)\n \t\tmec_irq(5);\n-\t    return (0x700 | (uint32) bq[bind++]);\n+\t    return (0x700 | (uint32_t) bq[bind++]);\n \t} else {\n \t    if (f2open) {\n \t\tbnum = DO_STDIO_READ(ifd2, bq, UARTBUF);\n@@ -1096,9 +1096,9 @@ read_uart(uint32 addr)\n \t\tbind = 0;\n \t\tif ((bind + 1) < bnum)\n \t\t    mec_irq(5);\n-\t\treturn (0x700 | (uint32) bq[bind++]);\n+\t\treturn (0x700 | (uint32_t) bq[bind++]);\n \t    } else {\n-\t\treturn (0x600 | (uint32) bq[bind]);\n+\t\treturn (0x600 | (uint32_t) bq[bind]);\n \t    }\n \n \t}\n@@ -1161,7 +1161,7 @@ read_uart(uint32 addr)\n }\n \n static void\n-write_uart(uint32 addr, uint32 data)\n+write_uart(uint32_t addr, uint32_t data)\n {\n     unsigned char   c;\n \n@@ -1278,7 +1278,7 @@ ATTRIBUTE_UNUSED\n static void\n uart_rx(void *arg)\n {\n-    int32           rsize;\n+    int32_t           rsize;\n     char            rxd;\n \n \n@@ -1411,20 +1411,20 @@ rtc_start(void)\n     rtc_enabled = 1;\n }\n \n-static uint32\n+static uint32_t\n rtc_counter_read(void)\n {\n     return rtc_counter;\n }\n \n static void\n-rtc_scaler_set(uint32 val)\n+rtc_scaler_set(uint32_t val)\n {\n     rtc_scaler = val & 0x0ff;\t/* eight-bit scaler only */\n }\n \n static void\n-rtc_reload_set(uint32 val)\n+rtc_reload_set(uint32_t val)\n {\n     rtc_reload = val;\n }\n@@ -1461,26 +1461,26 @@ gpt_start(void)\n     gpt_enabled = 1;\n }\n \n-static uint32\n+static uint32_t\n gpt_counter_read(void)\n {\n     return gpt_counter;\n }\n \n static void\n-gpt_scaler_set(uint32 val)\n+gpt_scaler_set(uint32_t val)\n {\n     gpt_scaler = val & 0x0ffff;\t/* 16-bit scaler */\n }\n \n static void\n-gpt_reload_set(uint32 val)\n+gpt_reload_set(uint32_t val)\n {\n     gpt_reload = val;\n }\n \n static void\n-timer_ctrl(uint32 val)\n+timer_ctrl(uint32_t val)\n {\n \n     rtc_cr = ((val & TCR_TCRCR) != 0);\n@@ -1512,8 +1512,8 @@ timer_ctrl(uint32 val)\n    wait-states.  */\n \n static void\n-store_bytes (unsigned char *mem, uint32 waddr, uint32 *data, int32 sz,\n-\t     int32 *ws)\n+store_bytes (unsigned char *mem, uint32_t waddr, uint32_t *data, int32_t sz,\n+\t     int32_t *ws)\n {\n     switch (sz) {\n \tcase 0:\n@@ -1543,9 +1543,9 @@ store_bytes (unsigned char *mem, uint32 waddr, uint32 *data, int32 sz,\n /* Memory emulation */\n \n int\n-memory_iread (uint32 addr, uint32 *data, uint32 *ws)\n+memory_iread (uint32_t addr, uint32_t *data, uint32_t *ws)\n {\n-    uint32          asi;\n+    uint32_t          asi;\n     if ((addr >= mem_ramstart) && (addr < (mem_ramstart + mem_ramsz))) {\n \tmemcpy (data, &ramb[addr & mem_rammask & ~3], 4);\n \t*ws = mem_ramr_ws;\n@@ -1568,9 +1568,9 @@ memory_iread (uint32 addr, uint32 *data, uint32 *ws)\n }\n \n int\n-memory_read(int32 asi, uint32 addr, void *data, int32 sz, int32 *ws)\n+memory_read(int32_t asi, uint32_t addr, void *data, int32_t sz, int32_t *ws)\n {\n-    int32           mexc;\n+    int32_t           mexc;\n \n #ifdef ERRINJ\n     if (errmec) {\n@@ -1634,13 +1634,13 @@ memory_read(int32 asi, uint32 addr, void *data, int32 sz, int32 *ws)\n }\n \n int\n-memory_write(int32 asi, uint32 addr, uint32 *data, int32 sz, int32 *ws)\n+memory_write(int32_t asi, uint32_t addr, uint32_t *data, int32_t sz, int32_t *ws)\n {\n-    uint32          byte_addr;\n-    uint32          byte_mask;\n-    uint32          waddr;\n-    uint32         *ram;\n-    int32           mexc;\n+    uint32_t          byte_addr;\n+    uint32_t          byte_mask;\n+    uint32_t          waddr;\n+    uint32_t         *ram;\n+    int32_t           mexc;\n     int             i;\n     int             wphit[2];\n \n@@ -1742,7 +1742,7 @@ memory_write(int32 asi, uint32 addr, uint32 *data, int32 sz, int32 *ws)\n }\n \n static void  *\n-get_mem_ptr(uint32 addr, uint32 size)\n+get_mem_ptr(uint32_t addr, uint32_t size)\n {\n     if ((addr + size) < ROM_SZ) {\n \treturn &romb[addr];\n@@ -1761,7 +1761,7 @@ get_mem_ptr(uint32 addr, uint32 size)\n }\n \n int\n-sis_memory_write(uint32 addr, const void *data, uint32 length)\n+sis_memory_write(uint32_t addr, const void *data, uint32_t length)\n {\n     void           *mem;\n \n@@ -1773,7 +1773,7 @@ sis_memory_write(uint32 addr, const void *data, uint32 length)\n }\n \n int\n-sis_memory_read(uint32 addr, void *data, uint32 length)\n+sis_memory_read(uint32_t addr, void *data, uint32_t length)\n {\n     char           *mem;\n "
    },
    {
      "sha": "ef93692e7a26cc35f69baa53a5a6f0a241d0dc07",
      "filename": "sim/erc32/exec.c",
      "status": "modified",
      "additions": 57,
      "deletions": 57,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/exec.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -23,7 +23,7 @@\n #include <math.h>\n #include <stdio.h>\n \n-extern int32    sis_verbose, sparclite;\n+extern int32_t    sis_verbose, sparclite;\n int ext_irl = 0;\n \n /* Load/store interlock delay */\n@@ -218,25 +218,25 @@ int ext_irl = 0;\n \n /* Forward declarations */\n \n-static uint32\tsub_cc (uint32 psr, int32 operand1, int32 operand2,\n-\t\t\tint32 result);\n-static uint32\tadd_cc (uint32 psr, int32 operand1, int32 operand2,\n-\t\t\tint32 result);\n-static void\tlog_cc (int32 result, struct pstate *sregs);\n-static int\tfpexec (uint32 op3, uint32 rd, uint32 rs1, uint32 rs2,\n+static uint32_t\tsub_cc (uint32_t psr, int32_t operand1, int32_t operand2,\n+\t\t\tint32_t result);\n+static uint32_t\tadd_cc (uint32_t psr, int32_t operand1, int32_t operand2,\n+\t\t\tint32_t result);\n+static void\tlog_cc (int32_t result, struct pstate *sregs);\n+static int\tfpexec (uint32_t op3, uint32_t rd, uint32_t rs1, uint32_t rs2,\n \t\t\tstruct pstate *sregs);\n-static int\tchk_asi (struct pstate *sregs, uint32 *asi, uint32 op3);\n+static int\tchk_asi (struct pstate *sregs, uint32_t *asi, uint32_t op3);\n \n \n extern struct estate ebase;\n-extern int32    nfp,ift;\n+extern int32_t    nfp,ift;\n \n #ifdef ERRINJ\n-extern uint32 errtt, errftt;\n+extern uint32_t errtt, errftt;\n #endif\n \n-static uint32\n-sub_cc(uint32 psr, int32 operand1, int32 operand2, int32 result)\n+static uint32_t\n+sub_cc(uint32_t psr, int32_t operand1, int32_t operand2, int32_t result)\n {\n     psr = ((psr & ~PSR_N) | ((result >> 8) & PSR_N));\n     if (result)\n@@ -250,8 +250,8 @@ sub_cc(uint32 psr, int32 operand1, int32 operand2, int32 result)\n     return psr;\n }\n \n-uint32\n-add_cc(uint32 psr, int32 operand1, int32 operand2, int32 result)\n+uint32_t\n+add_cc(uint32_t psr, int32_t operand1, int32_t operand2, int32_t result)\n {\n     psr = ((psr & ~PSR_N) | ((result >> 8) & PSR_N));\n     if (result)\n@@ -266,7 +266,7 @@ add_cc(uint32 psr, int32 operand1, int32 operand2, int32 result)\n }\n \n static void\n-log_cc(int32 result, struct pstate *sregs)\n+log_cc(int32_t result, struct pstate *sregs)\n {\n     sregs->psr &= ~(PSR_CC);\t/* Zero CC bits */\n     sregs->psr = (sregs->psr | ((result >> 8) & PSR_N));\n@@ -276,10 +276,10 @@ log_cc(int32 result, struct pstate *sregs)\n \n /* Add two unsigned 32-bit integers, and calculate the carry out. */\n \n-static uint32\n-add32 (uint32 n1, uint32 n2, int *carry)\n+static uint32_t\n+add32 (uint32_t n1, uint32_t n2, int *carry)\n {\n-  uint32 result = n1 + n2;\n+  uint32_t result = n1 + n2;\n \n   *carry = result < n1 || result < n2;\n   return result;\n@@ -288,9 +288,9 @@ add32 (uint32 n1, uint32 n2, int *carry)\n /* Multiply two 32-bit integers.  */\n \n static void\n-mul64 (uint32 n1, uint32 n2, uint32 *result_hi, uint32 *result_lo, int msigned)\n+mul64 (uint32_t n1, uint32_t n2, uint32_t *result_hi, uint32_t *result_lo, int msigned)\n {\n-  uint32 lo, mid1, mid2, hi, reg_lo, reg_hi;\n+  uint32_t lo, mid1, mid2, hi, reg_lo, reg_hi;\n   int carry;\n   int sign = 0;\n \n@@ -338,52 +338,52 @@ mul64 (uint32 n1, uint32 n2, uint32 *result_hi, uint32 *result_lo, int msigned)\n    that the host compiler supports long long operations.  */\n \n static void\n-div64 (uint32 n1_hi, uint32 n1_low, uint32 n2, uint32 *result, int msigned)\n+div64 (uint32_t n1_hi, uint32_t n1_low, uint32_t n2, uint32_t *result, int msigned)\n {\n-  uint64 n1;\n+  uint64_t n1;\n \n-  n1 = ((uint64) n1_hi) << 32;\n-  n1 |= ((uint64) n1_low) & 0xffffffff;\n+  n1 = ((uint64_t) n1_hi) << 32;\n+  n1 |= ((uint64_t) n1_low) & 0xffffffff;\n \n   if (msigned)\n     {\n-      int64 n1_s = (int64) n1;\n-      int32 n2_s = (int32) n2;\n+      int64_t n1_s = (int64_t) n1;\n+      int32_t n2_s = (int32_t) n2;\n       n1_s = n1_s / n2_s;\n-      n1 = (uint64) n1_s;\n+      n1 = (uint64_t) n1_s;\n     }\n   else\n     n1 = n1 / n2;\n \n-  *result = (uint32) (n1 & 0xffffffff);\n+  *result = (uint32_t) (n1 & 0xffffffff);\n }\n \n \n static int\n-extract_short (uint32 data, uint32 address)\n+extract_short (uint32_t data, uint32_t address)\n {\n     return ((data >> ((2 - (address & 2)) * 8)) & 0xffff);\n }\n \n static int\n-extract_short_signed (uint32 data, uint32 address)\n+extract_short_signed (uint32_t data, uint32_t address)\n {\n-    uint32 tmp = ((data >> ((2 - (address & 2)) * 8)) & 0xffff);\n+    uint32_t tmp = ((data >> ((2 - (address & 2)) * 8)) & 0xffff);\n     if (tmp & 0x8000)\n         tmp |= 0xffff0000;\n     return tmp;\n }\n \n static int\n-extract_byte (uint32 data, uint32 address)\n+extract_byte (uint32_t data, uint32_t address)\n {\n     return ((data >> ((3 - (address & 3)) * 8)) & 0xff);\n }\n \n static int\n-extract_byte_signed (uint32 data, uint32 address)\n+extract_byte_signed (uint32_t data, uint32_t address)\n {\n-    uint32 tmp = ((data >> ((3 - (address & 3)) * 8)) & 0xff);\n+    uint32_t tmp = ((data >> ((3 - (address & 3)) * 8)) & 0xff);\n     if (tmp & 0x80)\n         tmp |= 0xffffff00;\n     return tmp;\n@@ -393,13 +393,13 @@ int\n dispatch_instruction(struct pstate *sregs)\n {\n \n-    uint32          cwp, op, op2, op3, asi, rd, cond, rs1,\n+    uint32_t          cwp, op, op2, op3, asi, rd, cond, rs1,\n                     rs2;\n-    uint32          ldep, icc, data, *rdd;\n-    int32           operand1, operand2, result, eicc,\n+    uint32_t          ldep, icc, data, *rdd;\n+    int32_t           operand1, operand2, result, eicc,\n                     new_cwp;\n-    int32           pc, npc, address, ws, mexc, fcc;\n-    uint32\t    ddata[2];\n+    int32_t           pc, npc, address, ws, mexc, fcc;\n+    uint32_t\t    ddata[2];\n \n     sregs->ninst++;\n     cwp = ((sregs->psr & PSR_CWP) << 4);\n@@ -707,7 +707,7 @@ dispatch_instruction(struct pstate *sregs)\n \t    case DIVScc:\n \t\t{\n \t\t  int sign;\n-\t\t  uint32 result, remainder;\n+\t\t  uint32_t result, remainder;\n \t\t  int c0, y31;\n \n \t\t  if (!sparclite) {\n@@ -733,8 +733,8 @@ dispatch_instruction(struct pstate *sregs)\n \t\t     even in cases where the divisor is subtracted\n \t\t     from the remainder.  FIXME: get the true story\n \t\t     from Fujitsu. */\n-\t\t  c0 = result < (uint32) remainder\n-\t\t       || result < (uint32) operand2;\n+\t\t  c0 = result < (uint32_t) remainder\n+\t\t       || result < (uint32_t) operand2;\n \n \t\t  if (result & 0x80000000)\n \t\t    sregs->psr |= PSR_N;\n@@ -773,7 +773,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tbreak;\n \t    case SMULCC:\n \t\t{\n-\t\t  uint32 result;\n+\t\t  uint32_t result;\n \n \t\t  mul64 (rs1, operand2, &sregs->y, &result, 1);\n \n@@ -797,7 +797,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tbreak;\n \t    case UMULCC:\n \t\t{\n-\t\t  uint32 result;\n+\t\t  uint32_t result;\n \n \t\t  mul64 (rs1, operand2, &sregs->y, &result, 0);\n \n@@ -831,7 +831,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tbreak;\n \t    case SDIVCC:\n \t\t{\n-\t\t  uint32 result;\n+\t\t  uint32_t result;\n \n \t\t  if (sparclite) {\n \t\t     sregs->trap = TRAP_UNIMP;\n@@ -878,7 +878,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tbreak;\n \t    case UDIVCC:\n \t\t{\n-\t\t  uint32 result;\n+\t\t  uint32_t result;\n \n \t\t  if (sparclite) {\n \t\t     sregs->trap = TRAP_UNIMP;\n@@ -1168,7 +1168,7 @@ dispatch_instruction(struct pstate *sregs)\n \n \t    case SCAN:\n \t\t{\n-\t\t  uint32 result, mask;\n+\t\t  uint32_t result, mask;\n \t\t  int i;\n \n \t\t  if (!sparclite) {\n@@ -1528,7 +1528,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tif (sregs->frd == rd)\n \t\t    sregs->fhold += (sregs->ftime - ebase.simtime);\n \t    }\n-\t    mexc = memory_write(asi, address, (uint32 *)&sregs->fsi[rd], 2, &ws);\n+\t    mexc = memory_write(asi, address, (uint32_t *)&sregs->fsi[rd], 2, &ws);\n \t    sregs->hold += ws;\n \t    if (mexc) {\n \t\tsregs->trap = TRAP_DEXC;\n@@ -1548,7 +1548,7 @@ dispatch_instruction(struct pstate *sregs)\n \t\tif ((sregs->frd == rd) || (sregs->frd + 1 == rd))\n \t\t    sregs->fhold += (sregs->ftime - ebase.simtime);\n \t    }\n-\t    mexc = memory_write(asi, address, (uint32 *)&sregs->fsi[rd], 3, &ws);\n+\t    mexc = memory_write(asi, address, (uint32_t *)&sregs->fsi[rd], 3, &ws);\n \t    sregs->hold += ws;\n \t    sregs->icnt = T_STD;\n #ifdef STAT\n@@ -1662,11 +1662,11 @@ dispatch_instruction(struct pstate *sregs)\n \n \n static int\n-fpexec(uint32 op3, uint32 rd, uint32 rs1, uint32 rs2, struct pstate *sregs)\n+fpexec(uint32_t op3, uint32_t rd, uint32_t rs1, uint32_t rs2, struct pstate *sregs)\n {\n-    uint32          opf, tem, accex;\n-    int32           fcc;\n-    uint32          ldadj;\n+    uint32_t          opf, tem, accex;\n+    int32_t           fcc;\n+    uint32_t          ldadj;\n \n     if (sregs->fpstate == FP_EXC_MODE) {\n \tsregs->fsr = (sregs->fsr & ~FSR_TT) | FP_SEQ_ERR;\n@@ -1941,7 +1941,7 @@ fpexec(uint32 op3, uint32 rd, uint32 rs1, uint32 rs2, struct pstate *sregs)\n }\n \n static int\n-chk_asi(struct pstate *sregs, uint32 *asi, uint32 op3)\n+chk_asi(struct pstate *sregs, uint32_t *asi, uint32_t op3)\n {\n     if (!(sregs->psr & PSR_S)) {\n \tsregs->trap = TRAP_PRIVI;\n@@ -1957,7 +1957,7 @@ chk_asi(struct pstate *sregs, uint32 *asi, uint32 op3)\n int\n execute_trap(struct pstate *sregs)\n {\n-    int32           cwp;\n+    int32_t           cwp;\n \n     if (sregs->trap == 256) {\n \tsregs->pc = 0;\n@@ -2042,10 +2042,10 @@ init_regs(struct pstate *sregs)\n     sregs->g[0] = 0;\n #ifdef HOST_LITTLE_ENDIAN\n     sregs->fdp = (float32 *) sregs->fd;\n-    sregs->fsi = (int32 *) sregs->fs;\n+    sregs->fsi = (int32_t *) sregs->fs;\n #else\n     sregs->fs = (float32 *) sregs->fd;\n-    sregs->fsi = (int32 *) sregs->fd;\n+    sregs->fsi = (int32_t *) sregs->fd;\n #endif\n     sregs->fsr = 0;\n     sregs->fpu_pres = !nfp;"
    },
    {
      "sha": "1a0c272d64799fd5689ef20ad40cf00bc0d646d3",
      "filename": "sim/erc32/float.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/float.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/float.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/float.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -62,7 +62,7 @@ clear_accex(void)\n \n /* How to map SPARC FSR onto the host */\n void\n-set_fsr(uint32 fsr)\n+set_fsr(uint32_t fsr)\n {\n     int fround;\n "
    },
    {
      "sha": "b4f2b420e345db652ae6a0159e99a807a7d376b9",
      "filename": "sim/erc32/func.c",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/func.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/func.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/func.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -49,28 +49,28 @@ int             sparclite_board = 0;\t/* emulating SPARClite board RAM? */\n char            uart_dev1[128] = \"\";\n char            uart_dev2[128] = \"\";\n extern\tint\text_irl;\n-uint32\t\tlast_load_addr = 0;\n+uint32_t\t\tlast_load_addr = 0;\n \n #ifdef ERRINJ\n-uint32\t\terrcnt = 0;\n-uint32\t\terrper = 0;\n-uint32\t\terrtt = 0;\n-uint32\t\terrftt = 0;\n-uint32\t\terrmec = 0;\n+uint32_t\t\terrcnt = 0;\n+uint32_t\t\terrper = 0;\n+uint32_t\t\terrtt = 0;\n+uint32_t\t\terrftt = 0;\n+uint32_t\t\terrmec = 0;\n #endif\n \n /* Forward declarations */\n \n static int\tbatch (struct pstate *sregs, char *fname);\n-static void\tset_rega (struct pstate *sregs, char *reg, uint32 rval);\n+static void\tset_rega (struct pstate *sregs, char *reg, uint32_t rval);\n static void\tdisp_reg (struct pstate *sregs, char *reg);\n-static uint32\tlimcalc (float32 freq);\n-static void\tint_handler (int32 sig);\n+static uint32_t\tlimcalc (float32 freq);\n+static void\tint_handler (int32_t sig);\n static void\tinit_event (void);\n static int\tdisp_fpu (struct pstate  *sregs);\n static void\tdisp_regs (struct pstate  *sregs, int cwp);\n static void\tdisp_ctrl (struct pstate *sregs);\n-static void\tdisp_mem (uint32 addr, uint32 len);\n+static void\tdisp_mem (uint32_t addr, uint32_t len);\n \n static int \n batch(struct pstate *sregs, char *fname)\n@@ -98,9 +98,9 @@ batch(struct pstate *sregs, char *fname)\n }\n \n void\n-set_regi(struct pstate *sregs, int32 reg, uint32 rval)\n+set_regi(struct pstate *sregs, int32_t reg, uint32_t rval)\n {\n-    uint32          cwp;\n+    uint32_t          cwp;\n \n     cwp = ((sregs->psr & 0x7) << 4);\n     if ((reg > 0) && (reg < 8)) {\n@@ -139,10 +139,10 @@ set_regi(struct pstate *sregs, int32 reg, uint32 rval)\n }\n \n void\n-get_regi(struct pstate * sregs, int32 reg, unsigned char *buf)\n+get_regi(struct pstate * sregs, int32_t reg, unsigned char *buf)\n {\n-    uint32          cwp;\n-    uint32          rval = 0;\n+    uint32_t          cwp;\n+    uint32_t          rval = 0;\n \n     cwp = ((sregs->psr & 0x7) << 4);\n     if ((reg >= 0) && (reg < 8)) {\n@@ -185,10 +185,10 @@ get_regi(struct pstate * sregs, int32 reg, unsigned char *buf)\n \n \n static void\n-set_rega(struct pstate *sregs, char *reg, uint32 rval)\n+set_rega(struct pstate *sregs, char *reg, uint32_t rval)\n {\n-    uint32          cwp;\n-    int32           err = 0;\n+    uint32_t          cwp;\n+    int32_t           err = 0;\n \n     cwp = ((sregs->psr & 0x7) << 4);\n     if (strcmp(reg, \"psr\") == 0)\n@@ -329,10 +329,10 @@ errinjstart()\n \n #endif\n \n-static uint32\n+static uint32_t\n limcalc (float32 freq)\n {\n-    uint32          unit, lim;\n+    uint32_t          unit, lim;\n     double\t    flim;\n     char           *cmd1, *cmd2;\n \n@@ -348,7 +348,7 @@ limcalc (float32 freq)\n         flim = (double) lim * (double) unit * (double) freq + \n \t   (double) ebase.simtime;\n         if ((flim > ebase.simtime) && (flim < 4294967296.0)) {\n-            lim = (uint32) flim;\n+            lim = (uint32_t) flim;\n         } else  {\n             printf(\"error in expression\\n\");\n             lim = -1;\n@@ -361,9 +361,9 @@ int\n exec_cmd(struct pstate *sregs, const char *cmd)\n {\n     char           *cmd1, *cmd2;\n-    int32           stat;\n-    uint32          len, i, clen, j;\n-    static uint32   daddr = 0;\n+    int32_t           stat;\n+    uint32_t          len, i, clen, j;\n+    static uint32_t   daddr = 0;\n     char           *cmdsave, *cmdsave2 = NULL;\n \n     stat = OK;\n@@ -563,8 +563,8 @@ exec_cmd(struct pstate *sregs, const char *cmd)\n \t    sim_halt();\n \t} else if (strncmp(cmd1, \"tlimit\", clen) == 0) {\n \t   sregs->tlimit = limcalc(sregs->freq);\n-\t   if (sregs->tlimit != (uint32) -1)\n-              printf(\"simulation limit = %u (%.3f ms)\\n\",(uint32) sregs->tlimit,\n+\t   if (sregs->tlimit != (uint32_t) -1)\n+              printf(\"simulation limit = %u (%.3f ms)\\n\",(uint32_t) sregs->tlimit,\n \t\tsregs->tlimit / sregs->freq / 1000);\n \t} else if (strncmp(cmd1, \"tra\", clen) == 0) {\n \t    if ((cmd1 = strtok(NULL, \" \\t\\n\\r\")) == NULL) {\n@@ -614,8 +614,8 @@ reset_stat(struct pstate *sregs)\n void\n show_stat(struct pstate *sregs)\n {\n-    uint32          iinst;\n-    uint32          stime;\n+    uint32_t          iinst;\n+    uint32_t          stime;\n \n     if (sregs->tottime == 0.0)\n         sregs->tottime += 1E-6;\n@@ -677,7 +677,7 @@ init_bpt(struct pstate *sregs)\n }\n \n static void\n-int_handler(int32 sig)\n+int_handler(int32_t sig)\n {\n     if (sig != 2)\n \tprintf(\"\\n\\n Signal handler error  (%d)\\n\\n\", sig);\n@@ -743,7 +743,7 @@ disp_regs(struct pstate *sregs, int cwp)\n     }\n }\n \n-static void print_insn_sparc_sis(uint32 addr, struct disassemble_info *info)\n+static void print_insn_sparc_sis(uint32_t addr, struct disassemble_info *info)\n {\n     unsigned char           i[4];\n \n@@ -758,7 +758,7 @@ static void\n disp_ctrl(struct pstate *sregs)\n {\n \n-    uint32           i;\n+    uint32_t           i;\n \n     printf(\"\\n psr: %08X   wim: %08X   tbr: %08X   y: %08X\\n\",\n \t   sregs->psr, sregs->wim, sregs->tbr, sregs->y);\n@@ -774,15 +774,15 @@ disp_ctrl(struct pstate *sregs)\n }\n \n static void\n-disp_mem(uint32 addr, uint32 len)\n+disp_mem(uint32_t addr, uint32_t len)\n {\n \n-    uint32          i;\n+    uint32_t          i;\n     union {\n \t    unsigned char u8[4];\n-\t    uint32 u32;\n+\t    uint32_t u32;\n     } data;\n-    uint32          mem[4], j;\n+    uint32_t          mem[4], j;\n     char           *p;\n \n     for (i = addr & ~3; i < ((addr + len) & ~3); i += 16) {\n@@ -805,12 +805,12 @@ disp_mem(uint32 addr, uint32 len)\n }\n \n void\n-dis_mem(uint32 addr, uint32 len, struct disassemble_info *info)\n+dis_mem(uint32_t addr, uint32_t len, struct disassemble_info *info)\n {\n-    uint32          i;\n+    uint32_t          i;\n     union {\n \t    unsigned char u8[4];\n-\t    uint32 u32;\n+\t    uint32_t u32;\n     } data;\n \n     for (i = addr & -3; i < ((addr & -3) + (len << 2)); i += 4) {\n@@ -825,7 +825,7 @@ dis_mem(uint32 addr, uint32 len, struct disassemble_info *info)\n /* Add event to event queue */\n \n void\n-event(void (*cfunc) (), int32 arg, uint64 delta)\n+event(void (*cfunc) (), int32_t arg, uint64_t delta)\n {\n     struct evcell  *ev1, *evins;\n \n@@ -863,7 +863,7 @@ stop_event()\n void\n init_event(void)\n {\n-    int32           i;\n+    int32_t           i;\n \n     ebase.eq.nxt = NULL;\n     ebase.freeq = evbuf;\n@@ -874,7 +874,7 @@ init_event(void)\n }\n \n void\n-set_int(int32 level, void (*callback) (), int32 arg)\n+set_int(int32_t level, void (*callback) (), int32_t arg)\n {\n     irqarr[level & 0x0f].callback = callback;\n     irqarr[level & 0x0f].arg = arg;\n@@ -888,8 +888,8 @@ advance_time(struct pstate *sregs)\n \n     struct evcell  *evrem;\n     void            (*cfunc) ();\n-    uint32          arg;\n-    uint64          endtime;\n+    uint32_t          arg;\n+    uint64_t          endtime;\n \n #ifdef STAT\n     sregs->fholdt += sregs->fhold;\n@@ -913,7 +913,7 @@ advance_time(struct pstate *sregs)\n \n }\n \n-uint32\n+uint32_t\n now(void)\n {\n     return ebase.simtime;\n@@ -927,8 +927,8 @@ wait_for_irq(void)\n {\n     struct evcell  *evrem;\n     void            (*cfunc) ();\n-    int32           arg;\n-    uint64          endtime;\n+    int32_t           arg;\n+    uint64_t          endtime;\n \n     if (ebase.eq.nxt == NULL)\n \tprintf(\"Warning: event queue empty - power-down mode not entered\\n\");\n@@ -954,11 +954,11 @@ wait_for_irq(void)\n int\n check_bpt(struct pstate *sregs)\n {\n-    int32           i;\n+    int32_t           i;\n \n     if ((sregs->bphit) || (sregs->annul))\n \treturn 0;\n-    for (i = 0; i < (int32) sregs->bptnum; i++) {\n+    for (i = 0; i < (int32_t) sregs->bptnum; i++) {\n \tif (sregs->pc == sregs->bpts[i])\n \t    return BPT_HIT;\n     }"
    },
    {
      "sha": "d04d07c08c86e03bc896f4e5458b70dde7941f13",
      "filename": "sim/erc32/interf.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/interf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/interf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/interf.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -62,7 +62,7 @@ int             sis_gdb_break = 1;\n host_callback *sim_callback;\n \n int\n-run_sim(struct pstate *sregs, uint64 icount, int dis)\n+run_sim(struct pstate *sregs, uint64_t icount, int dis)\n {\n     int             mexc, irq;\n \n@@ -400,13 +400,13 @@ flush_windows (void)\n \n   for (win = invwin; ; win = (win - 1) & PSR_CWP)\n     {\n-      uint32 sp;\n+      uint32_t sp;\n       int i;\n \n       sp = sregs.r[(win * 16 + 14) & 0x7f];\n #if 1\n       if (sis_verbose > 2) {\n-\tuint32 fp = sregs.r[(win * 16 + 30) & 0x7f];\n+\tuint32_t fp = sregs.r[(win * 16 + 30) & 0x7f];\n \tprintf(\"flush_window: win %d, sp %x, fp %x\\n\", win, sp, fp);\n       }\n #endif"
    },
    {
      "sha": "66a27d0750644803a557bf8af678789bf920b8e8",
      "filename": "sim/erc32/sis.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/sis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/sis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/sis.c?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -60,14 +60,14 @@ extern int      sparclite;\n extern int      dumbio;\n extern char     uart_dev1[];\n extern char     uart_dev2[];\n-extern uint32   last_load_addr;\n+extern uint32_t   last_load_addr;\n \n #ifdef ERA\n extern int era;\n #endif\n \n int\n-run_sim(struct pstate *sregs, uint64 icount, int dis)\n+run_sim(struct pstate *sregs, uint64_t icount, int dis)\n {\n     int             irq, mexc, deb;\n "
    },
    {
      "sha": "33f16c77ca47b26bf2ef901f4c07fc263fcf309f",
      "filename": "sim/erc32/sis.h",
      "status": "modified",
      "additions": 77,
      "deletions": 84,
      "changes": 161,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/sis.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a92dedc592fd0d5e8bbf9987ed2602b92607bed/sim/erc32/sis.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/erc32/sis.h?ref=4a92dedc592fd0d5e8bbf9987ed2602b92607bed",
      "patch": "@@ -45,16 +45,9 @@ struct histype {\n \n /* type definitions */\n \n-typedef short int int16;\t/* 16-bit signed int */\n-typedef unsigned short int uint16;\t/* 16-bit unsigned int */\n-typedef int     int32;\t\t/* 32-bit signed int */\n-typedef unsigned int uint32;\t/* 32-bit unsigned int */\n typedef float   float32;\t/* 32-bit float */\n typedef double  float64;\t/* 64-bit float */\n \n-typedef uint64_t uint64; /* 64-bit unsigned int */\n-typedef int64_t int64;\t   /* 64-bit signed int */\n-\n struct pstate {\n \n     float64         fd[16];\t/* FPU registers */\n@@ -64,87 +57,87 @@ struct pstate {\n #else\n     float32        *fs;\n #endif\n-    int32          *fsi;\n-    uint32          fsr;\n-    int32           fpstate;\n-    uint32          fpq[FPUQN * 2];\n-    uint32          fpqn;\n-    uint32          ftime;\n-    uint32          flrd;\n-    uint32          frd;\n-    uint32          frs1;\n-    uint32          frs2;\n-    uint32          fpu_pres;\t/* FPU present (0 = No, 1 = Yes) */\n-\n-    uint32          psr;\t/* IU registers */\n-    uint32          tbr;\n-    uint32          wim;\n-    uint32          g[8];\n-    uint32          r[128];\n-    uint32          y;\n-    uint32          asr17;      /* Single vector trapping */\n-    uint32          pc, npc;\n-\n-\n-    uint32          trap;\t/* Current trap type */\n-    uint32          annul;\t/* Instruction annul */\n-    uint32          data;\t/* Loaded data\t     */\n-    uint32          inst;\t/* Current instruction */\n-    uint32          asi;\t/* Current ASI */\n-    uint32          err_mode;\t/* IU error mode */\n-    uint32          breakpoint;\n-    uint32          bptnum;\n-    uint32          bphit;\n-    uint32          bpts[BPT_MAX];\t/* Breakpoints */\n-\n-    uint32          ltime;\t/* Load interlock time */\n-    uint32          hold;\t/* IU hold cycles in current inst */\n-    uint32          fhold;\t/* FPU hold cycles in current inst */\n-    uint32          icnt;\t/* Instruction cycles in curr inst */\n-\n-    uint32          histlen;\t/* Trace history management */\n-    uint32          histind;\n+    int32_t          *fsi;\n+    uint32_t          fsr;\n+    int32_t           fpstate;\n+    uint32_t          fpq[FPUQN * 2];\n+    uint32_t          fpqn;\n+    uint32_t          ftime;\n+    uint32_t          flrd;\n+    uint32_t          frd;\n+    uint32_t          frs1;\n+    uint32_t          frs2;\n+    uint32_t          fpu_pres;\t/* FPU present (0 = No, 1 = Yes) */\n+\n+    uint32_t          psr;\t/* IU registers */\n+    uint32_t          tbr;\n+    uint32_t          wim;\n+    uint32_t          g[8];\n+    uint32_t          r[128];\n+    uint32_t          y;\n+    uint32_t          asr17;      /* Single vector trapping */\n+    uint32_t          pc, npc;\n+\n+\n+    uint32_t          trap;\t/* Current trap type */\n+    uint32_t          annul;\t/* Instruction annul */\n+    uint32_t          data;\t/* Loaded data\t     */\n+    uint32_t          inst;\t/* Current instruction */\n+    uint32_t          asi;\t/* Current ASI */\n+    uint32_t          err_mode;\t/* IU error mode */\n+    uint32_t          breakpoint;\n+    uint32_t          bptnum;\n+    uint32_t          bphit;\n+    uint32_t          bpts[BPT_MAX];\t/* Breakpoints */\n+\n+    uint32_t          ltime;\t/* Load interlock time */\n+    uint32_t          hold;\t/* IU hold cycles in current inst */\n+    uint32_t          fhold;\t/* FPU hold cycles in current inst */\n+    uint32_t          icnt;\t/* Instruction cycles in curr inst */\n+\n+    uint32_t          histlen;\t/* Trace history management */\n+    uint32_t          histind;\n     struct histype *histbuf;\n     float32         freq;\t/* Simulated processor frequency */\n \n \n     double          tottime;\n-    uint64          ninst;\n-    uint64          fholdt;\n-    uint64          holdt;\n-    uint64          icntt;\n-    uint64          finst;\n-    uint64          simstart;\n+    uint64_t          ninst;\n+    uint64_t          fholdt;\n+    uint64_t          holdt;\n+    uint64_t          icntt;\n+    uint64_t          finst;\n+    uint64_t          simstart;\n     double          starttime;\n-    uint64          tlimit;\t/* Simulation time limit */\n-    uint64          pwdtime;\t/* Cycles in power-down mode */\n-    uint64          nstore;\t/* Number of load instructions */\n-    uint64          nload;\t/* Number of store instructions */\n-    uint64          nannul;\t/* Number of annuled instructions */\n-    uint64          nbranch;\t/* Number of branch instructions */\n-    uint32          ildreg;\t/* Destination of last load instruction */\n-    uint64          ildtime;\t/* Last time point for load dependency */\n+    uint64_t          tlimit;\t/* Simulation time limit */\n+    uint64_t          pwdtime;\t/* Cycles in power-down mode */\n+    uint64_t          nstore;\t/* Number of load instructions */\n+    uint64_t          nload;\t/* Number of store instructions */\n+    uint64_t          nannul;\t/* Number of annuled instructions */\n+    uint64_t          nbranch;\t/* Number of branch instructions */\n+    uint32_t          ildreg;\t/* Destination of last load instruction */\n+    uint64_t          ildtime;\t/* Last time point for load dependency */\n \n     int             rett_err;\t/* IU in jmpl/restore error state (Rev.0) */\n     int             jmpltime;\n };\n \n struct evcell {\n     void            (*cfunc) ();\n-    int32           arg;\n-    uint64          time;\n+    int32_t           arg;\n+    uint64_t          time;\n     struct evcell  *nxt;\n };\n \n struct estate {\n     struct evcell   eq;\n     struct evcell  *freeq;\n-    uint64          simtime;\n+    uint64_t          simtime;\n };\n \n struct irqcell {\n     void            (*callback) ();\n-    int32           arg;\n+    int32_t           arg;\n };\n \n \n@@ -159,40 +152,40 @@ struct irqcell {\n /* erc32.c */\n extern void\tinit_sim (void);\n extern void\treset (void);\n-extern void\terror_mode (uint32 pc);\n+extern void\terror_mode (uint32_t pc);\n extern void\tsim_halt (void);\n extern void\texit_sim (void);\n extern void\tinit_stdio (void);\n extern void\trestore_stdio (void);\n-extern int\tmemory_iread (uint32 addr, uint32 *data, uint32 *ws);\n-extern int\tmemory_read (int32 asi, uint32 addr, void *data,\n-\t\t\t     int32 sz, int32 *ws);\n-extern int\tmemory_write (int32 asi, uint32 addr, uint32 *data,\n-\t\t\t      int32 sz, int32 *ws);\n-extern int\tsis_memory_write (uint32 addr,\n-\t\t\t\t  const void *data, uint32 length);\n-extern int\tsis_memory_read (uint32 addr, void *data,\n-\t\t\t\t uint32 length);\n+extern int\tmemory_iread (uint32_t addr, uint32_t *data, uint32_t *ws);\n+extern int\tmemory_read (int32_t asi, uint32_t addr, void *data,\n+\t\t\t     int32_t sz, int32_t *ws);\n+extern int\tmemory_write (int32_t asi, uint32_t addr, uint32_t *data,\n+\t\t\t      int32_t sz, int32_t *ws);\n+extern int\tsis_memory_write (uint32_t addr,\n+\t\t\t\t  const void *data, uint32_t length);\n+extern int\tsis_memory_read (uint32_t addr, void *data,\n+\t\t\t\t uint32_t length);\n extern void\tboot_init (void);\n \n /* func.c */\n extern struct pstate  sregs;\n-extern void\tset_regi (struct pstate *sregs, int32 reg,\n-\t\t\t  uint32 rval);\n-extern void\tget_regi (struct pstate *sregs, int32 reg, unsigned char *buf);\n+extern void\tset_regi (struct pstate *sregs, int32_t reg,\n+\t\t\t  uint32_t rval);\n+extern void\tget_regi (struct pstate *sregs, int32_t reg, unsigned char *buf);\n extern int\texec_cmd (struct pstate *sregs, const char *cmd);\n extern void\treset_stat (struct pstate  *sregs);\n extern void\tshow_stat (struct pstate  *sregs);\n extern void\tinit_bpt (struct pstate  *sregs);\n extern void\tinit_signals (void);\n \n struct disassemble_info;\n-extern void\tdis_mem (uint32 addr, uint32 len,\n+extern void\tdis_mem (uint32_t addr, uint32_t len,\n \t\t\t struct disassemble_info *info);\n-extern void\tevent (void (*cfunc) (), int32 arg, uint64 delta);\n-extern void\tset_int (int32 level, void (*callback) (), int32 arg);\n+extern void\tevent (void (*cfunc) (), int32_t arg, uint64_t delta);\n+extern void\tset_int (int32_t level, void (*callback) (), int32_t arg);\n extern void\tadvance_time (struct pstate  *sregs);\n-extern uint32\tnow (void);\n+extern uint32_t\tnow (void);\n extern int\twait_for_irq (void);\n extern int\tcheck_bpt (struct pstate *sregs);\n extern void\treset_all (void);\n@@ -209,12 +202,12 @@ extern void\tinit_regs (struct pstate *sregs);\n \n /* interf.c */\n extern int\trun_sim (struct pstate *sregs,\n-\t\t\t uint64 icount, int dis);\n+\t\t\t uint64_t icount, int dis);\n \n /* float.c */\n extern int\tget_accex (void);\n extern void\tclear_accex (void);\n-extern void\tset_fsr (uint32 fsr);\n+extern void\tset_fsr (uint32_t fsr);\n \n /* help.c */\n extern void\tusage (void);"
    }
  ]
}