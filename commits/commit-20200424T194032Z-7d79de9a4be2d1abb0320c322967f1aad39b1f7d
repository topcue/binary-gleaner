{
  "sha": "7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2Q3OWRlOWE0YmUyZDFhYmIwMzIwYzMyMjk2N2YxYWFkMzliMWY3ZA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:31Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T19:40:32Z"
    },
    "message": "Add support for variable field offsets\n\nIn Ada, a field can have a variable offset.  This patch adds support\nfor this case to gdb, using the existing dynamic type resolution code.\n\nDoing just this, though, would break C++ virtual base handling.\n\nIt turns out that virtual base handling only worked by the ugliest of\nhacks.  In particular, the DWARF reader would call decode_locdesc for\na virtual base location.  Here's an example of such an expression from\ngdb's m-static test case:\n\n    <241>   DW_AT_data_member_location: 6 byte block: 12 6 48 1c 6 22 \t(DW_OP_dup; DW_OP_deref; DW_OP_lit24; DW_OP_minus; DW_OP_deref; DW_OP_plus)\n\nWhen examining this, decode_locdesc would treat DW_OP_deref as a no-op\nand compute some answer (here, -24).  This would be stored as the\noffset.\n\nLater, in gnu-v3-abi.c, the real offset would be computed by digging\naround in the vtable.\n\nThis patch cleans up this area.  In particular, it now evaluates the\nlocation expression on demand.\n\nNote there is a new FIXME in gnu-v3-abi.c.  I think some of the\ncallers are incorrect here, and have only worked because this member\nis unused.  I will file a bug for this.  I didn't fix this problem in\nthis series because I felt it was already too complex.\n\ngdb/ChangeLog\n2020-04-24  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.c (handle_data_member_location): New overload.\n\t(dwarf2_add_field): Use it.\n\t(decode_locdesc): Add \"computed\" parameter.  Update comment.\n\t* gdbtypes.c (is_dynamic_type_internal): Also look for\n\tFIELD_LOC_KIND_DWARF_BLOCK.\n\t(resolve_dynamic_struct): Handle FIELD_LOC_KIND_DWARF_BLOCK.\n\t* gdbtypes.c (is_dynamic_type_internal): Add special case for C++\n\tvirtual base classes.\n\t* gnu-v3-abi.c (gnuv3_baseclass_offset): Handle\n\tFIELD_LOC_KIND_DWARF_BLOCK.\n\ngdb/testsuite/ChangeLog\n2020-04-24  Tom Tromey  <tromey@adacore.com>\n\n\t* gdb.ada/variant.exp: Add dynamic field offset tests.\n\t* gdb.ada/variant/pck.ads (Nested_And_Variable): New type.\n\t* gdb.ada/variant/pkg.adb: Add new variables.",
    "tree": {
      "sha": "fa576d23c30849b3b5eeda590d1ce1b8094ac791",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fa576d23c30849b3b5eeda590d1ce1b8094ac791"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f8e89861cfb6acbfa097814f5864afd5563a3011",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f8e89861cfb6acbfa097814f5864afd5563a3011",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f8e89861cfb6acbfa097814f5864afd5563a3011"
    }
  ],
  "stats": {
    "total": 263,
    "additions": 218,
    "deletions": 45
  },
  "files": [
    {
      "sha": "1f89444db73882bdc36ff56809e66cad78da49c1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -1,3 +1,16 @@\n+2020-04-24  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.c (handle_data_member_location): New overload.\n+\t(dwarf2_add_field): Use it.\n+\t(decode_locdesc): Add \"computed\" parameter.  Update comment.\n+\t* gdbtypes.c (is_dynamic_type_internal): Also look for\n+\tFIELD_LOC_KIND_DWARF_BLOCK.\n+\t(resolve_dynamic_struct): Handle FIELD_LOC_KIND_DWARF_BLOCK.\n+\t* gdbtypes.c (is_dynamic_type_internal): Add special case for C++\n+\tvirtual base classes.\n+\t* gnu-v3-abi.c (gnuv3_baseclass_offset): Handle\n+\tFIELD_LOC_KIND_DWARF_BLOCK.\n+\n 2020-04-24  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2/read.c (read_structure_type): Handle dynamic length."
    },
    {
      "sha": "14d53a20e8b6f124f36fe09bed966b08938307b3",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 102,
      "deletions": 43,
      "changes": 145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -1435,7 +1435,8 @@ static const char *namespace_name (struct die_info *die,\n \n static void process_enumeration_scope (struct die_info *, struct dwarf2_cu *);\n \n-static CORE_ADDR decode_locdesc (struct dwarf_block *, struct dwarf2_cu *);\n+static CORE_ADDR decode_locdesc (struct dwarf_block *, struct dwarf2_cu *,\n+\t\t\t\t bool * = nullptr);\n \n static enum dwarf_array_dim_ordering read_array_order (struct die_info *,\n \t\t\t\t\t\t       struct dwarf2_cu *);\n@@ -14212,6 +14213,53 @@ handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n   return 0;\n }\n \n+/* Look for DW_AT_data_member_location and store the results in FIELD.  */\n+\n+static void\n+handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,\n+\t\t\t     struct field *field)\n+{\n+  struct attribute *attr;\n+\n+  attr = dwarf2_attr (die, DW_AT_data_member_location, cu);\n+  if (attr != NULL)\n+    {\n+      if (attr->form_is_constant ())\n+\t{\n+\t  LONGEST offset = attr->constant_value (0);\n+\t  SET_FIELD_BITPOS (*field, offset * bits_per_byte);\n+\t}\n+      else if (attr->form_is_section_offset ())\n+\tdwarf2_complex_location_expr_complaint ();\n+      else if (attr->form_is_block ())\n+\t{\n+\t  bool handled;\n+\t  CORE_ADDR offset = decode_locdesc (DW_BLOCK (attr), cu, &handled);\n+\t  if (handled)\n+\t    SET_FIELD_BITPOS (*field, offset * bits_per_byte);\n+\t  else\n+\t    {\n+\t      struct objfile *objfile\n+\t\t= cu->per_cu->dwarf2_per_objfile->objfile;\n+\t      struct dwarf2_locexpr_baton *dlbaton\n+\t\t= XOBNEW (&objfile->objfile_obstack,\n+\t\t\t  struct dwarf2_locexpr_baton);\n+\t      dlbaton->data = DW_BLOCK (attr)->data;\n+\t      dlbaton->size = DW_BLOCK (attr)->size;\n+\t      /* When using this baton, we want to compute the address\n+\t\t of the field, not the value.  This is why\n+\t\t is_reference is set to false here.  */\n+\t      dlbaton->is_reference = false;\n+\t      dlbaton->per_cu = cu->per_cu;\n+\n+\t      SET_FIELD_DWARF_BLOCK (*field, dlbaton);\n+\t    }\n+\t}\n+      else\n+\tdwarf2_complex_location_expr_complaint ();\n+    }\n+}\n+\n /* Add an aggregate field to the field list.  */\n \n static void\n@@ -14256,8 +14304,6 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \n   if (die->tag == DW_TAG_member && ! die_is_declaration (die, cu))\n     {\n-      LONGEST offset;\n-\n       /* Data member other than a C++ static data member.  */\n \n       /* Get type of field.  */\n@@ -14277,8 +14323,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t}\n \n       /* Get bit offset of field.  */\n-      if (handle_data_member_location (die, cu, &offset))\n-\tSET_FIELD_BITPOS (*fp, offset * bits_per_byte);\n+      handle_data_member_location (die, cu, fp);\n       attr = dwarf2_attr (die, DW_AT_bit_offset, cu);\n       if (attr != nullptr)\n \t{\n@@ -14387,11 +14432,8 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n     }\n   else if (die->tag == DW_TAG_inheritance)\n     {\n-      LONGEST offset;\n-\n       /* C++ base class field.  */\n-      if (handle_data_member_location (die, cu, &offset))\n-\tSET_FIELD_BITPOS (*fp, offset * bits_per_byte);\n+      handle_data_member_location (die, cu, fp);\n       FIELD_BITSIZE (*fp) = 0;\n       FIELD_TYPE (*fp) = die_type (die, cu);\n       FIELD_NAME (*fp) = TYPE_NAME (fp->type);\n@@ -22657,27 +22699,13 @@ read_signatured_type (struct signatured_type *sig_type)\n \n /* Decode simple location descriptions.\n    Given a pointer to a dwarf block that defines a location, compute\n-   the location and return the value.\n-\n-   NOTE drow/2003-11-18: This function is called in two situations\n-   now: for the address of static or global variables (partial symbols\n-   only) and for offsets into structures which are expected to be\n-   (more or less) constant.  The partial symbol case should go away,\n-   and only the constant case should remain.  That will let this\n-   function complain more accurately.  A few special modes are allowed\n-   without complaint for global variables (for instance, global\n-   register values and thread-local values).\n-\n-   A location description containing no operations indicates that the\n-   object is optimized out.  The return value is 0 for that case.\n-   FIXME drow/2003-11-16: No callers check for this case any more; soon all\n-   callers will only want a very basic result and this can become a\n-   complaint.\n-\n-   Note that stack[0] is unused except as a default error return.  */\n+   the location and return the value.  If COMPUTED is non-null, it is\n+   set to true to indicate that decoding was successful, and false\n+   otherwise.  If COMPUTED is null, then this function may emit a\n+   complaint.  */\n \n static CORE_ADDR\n-decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n+decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu, bool *computed)\n {\n   struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n   size_t i;\n@@ -22688,6 +22716,9 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n   unsigned int bytes_read, unsnd;\n   gdb_byte op;\n \n+  if (computed != nullptr)\n+    *computed = false;\n+\n   i = 0;\n   stacki = 0;\n   stack[stacki] = 0;\n@@ -22767,15 +22798,25 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n \tcase DW_OP_reg31:\n \t  stack[++stacki] = op - DW_OP_reg0;\n \t  if (i < size)\n-\t    dwarf2_complex_location_expr_complaint ();\n+\t    {\n+\t      if (computed == nullptr)\n+\t\tdwarf2_complex_location_expr_complaint ();\n+\t      else\n+\t\treturn 0;\n+\t    }\n \t  break;\n \n \tcase DW_OP_regx:\n \t  unsnd = read_unsigned_leb128 (NULL, (data + i), &bytes_read);\n \t  i += bytes_read;\n \t  stack[++stacki] = unsnd;\n \t  if (i < size)\n-\t    dwarf2_complex_location_expr_complaint ();\n+\t    {\n+\t      if (computed == nullptr)\n+\t\tdwarf2_complex_location_expr_complaint ();\n+\t      else\n+\t\treturn 0;\n+\t    }\n \t  break;\n \n \tcase DW_OP_addr:\n@@ -22857,7 +22898,12 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n \t     global symbols, although the variable's address will be bogus\n \t     in the psymtab.  */\n \t  if (i < size)\n-\t    dwarf2_complex_location_expr_complaint ();\n+\t    {\n+\t      if (computed == nullptr)\n+\t\tdwarf2_complex_location_expr_complaint ();\n+\t      else\n+\t\treturn 0;\n+\t    }\n \t  break;\n \n         case DW_OP_GNU_push_tls_address:\n@@ -22871,11 +22917,18 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n \t     non-zero to not look as a variable garbage collected by linker\n \t     which have DW_OP_addr 0.  */\n \t  if (i < size)\n-\t    dwarf2_complex_location_expr_complaint ();\n+\t    {\n+\t      if (computed == nullptr)\n+\t\tdwarf2_complex_location_expr_complaint ();\n+\t      else\n+\t\treturn 0;\n+\t    }\n \t  stack[stacki]++;\n           break;\n \n \tcase DW_OP_GNU_uninit:\n+\t  if (computed != nullptr)\n+\t    return 0;\n \t  break;\n \n \tcase DW_OP_addrx:\n@@ -22887,16 +22940,17 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n \t  break;\n \n \tdefault:\n-\t  {\n-\t    const char *name = get_DW_OP_name (op);\n+\t  if (computed == nullptr)\n+\t    {\n+\t      const char *name = get_DW_OP_name (op);\n \n-\t    if (name)\n-\t      complaint (_(\"unsupported stack op: '%s'\"),\n-\t\t\t name);\n-\t    else\n-\t      complaint (_(\"unsupported stack op: '%02x'\"),\n-\t\t\t op);\n-\t  }\n+\t      if (name)\n+\t\tcomplaint (_(\"unsupported stack op: '%s'\"),\n+\t\t\t   name);\n+\t      else\n+\t\tcomplaint (_(\"unsupported stack op: '%02x'\"),\n+\t\t\t   op);\n+\t    }\n \n \t  return (stack[stacki]);\n \t}\n@@ -22905,16 +22959,21 @@ decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)\n          outside of the allocated space.  Also enforce minimum>0.  */\n       if (stacki >= ARRAY_SIZE (stack) - 1)\n \t{\n-\t  complaint (_(\"location description stack overflow\"));\n+\t  if (computed == nullptr)\n+\t    complaint (_(\"location description stack overflow\"));\n \t  return 0;\n \t}\n \n       if (stacki <= 0)\n \t{\n-\t  complaint (_(\"location description stack underflow\"));\n+\t  if (computed == nullptr)\n+\t    complaint (_(\"location description stack underflow\"));\n \t  return 0;\n \t}\n     }\n+\n+  if (computed != nullptr)\n+    *computed = true;\n   return (stack[stacki]);\n }\n "
    },
    {
      "sha": "73984357338db7e16a55336ae599b718182e082b",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 37,
      "deletions": 2,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -2015,10 +2015,27 @@ is_dynamic_type_internal (struct type *type, int top_level)\n       {\n \tint i;\n \n+\tbool is_cplus = HAVE_CPLUS_STRUCT (type);\n+\n \tfor (i = 0; i < TYPE_NFIELDS (type); ++i)\n-\t  if (!field_is_static (&TYPE_FIELD (type, i))\n-\t      && is_dynamic_type_internal (TYPE_FIELD_TYPE (type, i), 0))\n+\t  {\n+\t    /* Static fields can be ignored here.  */\n+\t    if (field_is_static (&TYPE_FIELD (type, i)))\n+\t      continue;\n+\t    /* If the field has dynamic type, then so does TYPE.  */\n+\t    if (is_dynamic_type_internal (TYPE_FIELD_TYPE (type, i), 0))\n+\t      return 1;\n+\t    /* If the field is at a fixed offset, then it is not\n+\t       dynamic.  */\n+\t    if (TYPE_FIELD_LOC_KIND (type, i) != FIELD_LOC_KIND_DWARF_BLOCK)\n+\t      continue;\n+\t    /* Do not consider C++ virtual base types to be dynamic\n+\t       due to the field's offset being dynamic; these are\n+\t       handled via other means.  */\n+\t    if (is_cplus && BASETYPE_VIA_VIRTUAL (type, i))\n+\t      continue;\n \t    return 1;\n+\t  }\n       }\n       break;\n     }\n@@ -2430,6 +2447,24 @@ resolve_dynamic_struct (struct type *type,\n       if (field_is_static (&TYPE_FIELD (resolved_type, i)))\n \tcontinue;\n \n+      if (TYPE_FIELD_LOC_KIND (resolved_type, i) == FIELD_LOC_KIND_DWARF_BLOCK)\n+\t{\n+\t  struct dwarf2_property_baton baton;\n+\t  baton.property_type\n+\t    = lookup_pointer_type (TYPE_FIELD_TYPE (resolved_type, i));\n+\t  baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (resolved_type, i);\n+\n+\t  struct dynamic_prop prop;\n+\t  prop.kind = PROP_LOCEXPR;\n+\t  prop.data.baton = &baton;\n+\n+\t  CORE_ADDR addr;\n+\t  if (dwarf2_evaluate_property (&prop, nullptr, addr_stack, &addr,\n+\t\t\t\t\ttrue))\n+\t    SET_FIELD_BITPOS (TYPE_FIELD (resolved_type, i),\n+\t\t\t      TARGET_CHAR_BIT * (addr - addr_stack->addr));\n+\t}\n+\n       /* As we know this field is not a static field, the field's\n \t field_loc_kind should be FIELD_LOC_KIND_BITPOS.  Verify\n \t this is the case, but only trigger a simple error rather"
    },
    {
      "sha": "70558437f9c6fdb728fe4516dd9b902ff250b0cc",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -30,6 +30,7 @@\n #include \"typeprint.h\"\n #include <algorithm>\n #include \"cli/cli-style.h\"\n+#include \"dwarf2/loc.h\"\n \n static struct cp_abi_ops gnu_v3_abi_ops;\n \n@@ -461,6 +462,31 @@ gnuv3_baseclass_offset (struct type *type, int index,\n   if (!BASETYPE_VIA_VIRTUAL (type, index))\n     return TYPE_BASECLASS_BITPOS (type, index) / 8;\n \n+  /* If we have a DWARF expression for the offset, evaluate it.  */\n+  if (TYPE_FIELD_LOC_KIND (type, index) == FIELD_LOC_KIND_DWARF_BLOCK)\n+    {\n+      struct dwarf2_property_baton baton;\n+      baton.property_type\n+\t= lookup_pointer_type (TYPE_FIELD_TYPE (type, index));\n+      baton.locexpr = *TYPE_FIELD_DWARF_BLOCK (type, index);\n+\n+      struct dynamic_prop prop;\n+      prop.kind = PROP_LOCEXPR;\n+      prop.data.baton = &baton;\n+\n+      struct property_addr_info addr_stack;\n+      addr_stack.type = type;\n+      /* Note that we don't set \"valaddr\" here.  Doing so causes\n+\t regressions.  FIXME.  */\n+      addr_stack.addr = address + embedded_offset;\n+      addr_stack.next = nullptr;\n+\n+      CORE_ADDR result;\n+      if (dwarf2_evaluate_property (&prop, nullptr, &addr_stack, &result,\n+\t\t\t\t    true))\n+\treturn (int) (result - addr_stack.addr);\n+    }\n+\n   /* To access a virtual base, we need to use the vbase offset stored in\n      our vtable.  Recent GCC versions provide this information.  If it isn't\n      available, we could get what we needed from RTTI, or from drawing the"
    },
    {
      "sha": "4e7dfacc4a1967dc9ec11752c3269aa93937d1a1",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -1,3 +1,9 @@\n+2020-04-24  Tom Tromey  <tromey@adacore.com>\n+\n+\t* gdb.ada/variant.exp: Add dynamic field offset tests.\n+\t* gdb.ada/variant/pck.ads (Nested_And_Variable): New type.\n+\t* gdb.ada/variant/pkg.adb: Add new variables.\n+\n 2020-04-24  Tom Tromey  <tromey@adacore.com>\n \n \t* gdb.ada/variant.exp: New file"
    },
    {
      "sha": "490956a2666fa19bd2b8f63751a9defbbd66c026",
      "filename": "gdb/testsuite/gdb.ada/variant.exp",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/variant.exp?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -37,4 +37,10 @@ foreach_with_prefix scenario {none all minimal} {\n \n     gdb_test \"print st1\" \" = \\\\(i => -4, one => 1, x => 2\\\\)\"\n     gdb_test \"print st2\" \" = \\\\(i => 99, one => 1, y => 77\\\\)\"\n+\n+    gdb_test \"print nav1\" \" = \\\\(one => 0, two => 93, str => \\\"\\\"\\\\)\"\n+    gdb_test \"print nav2\" \\\n+\t\" = \\\\(one => 3, two => 0, str => \\\"zzz\\\", onevalue => 33, str2 => \\\"\\\"\\\\)\"\n+    gdb_test \"print nav3\" \\\n+\t\" = \\\\(one => 3, two => 7, str => \\\"zzz\\\", onevalue => 33, str2 => \\\"qqqqqqq\\\", twovalue => 88\\\\)\"\n }"
    },
    {
      "sha": "3895b9c48eb6596643c2c5e4cff0d1c3693f058f",
      "filename": "gdb/testsuite/gdb.ada/variant/pck.ads",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant/pck.ads",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant/pck.ads",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/variant/pck.ads?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -34,4 +34,21 @@ package Pck is\n \t   Y : Integer;\n       end case;\n    end record;\n+\n+   type Nested_And_Variable (One, Two: Integer) is record\n+       Str : String (1 .. One);\n+       case One is\n+          when 0 =>\n+\t     null;\n+          when others =>\n+\t     OneValue : Integer;\n+             Str2 : String (1 .. Two);\n+             case Two is\n+\t        when 0 =>\n+\t\t   null;\n+\t\twhen others =>\n+\t\t   TwoValue : Integer;\n+             end case;\n+       end case;\n+   end record;\n end Pck;"
    },
    {
      "sha": "91cf080ed1dc6f7ae9823de73cf688c7f1026052",
      "filename": "gdb/testsuite/gdb.ada/variant/pkg.adb",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant/pkg.adb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d79de9a4be2d1abb0320c322967f1aad39b1f7d/gdb/testsuite/gdb.ada/variant/pkg.adb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/variant/pkg.adb?ref=7d79de9a4be2d1abb0320c322967f1aad39b1f7d",
      "patch": "@@ -22,6 +22,17 @@ procedure Pkg is\n    ST1 : constant Second_Type := (I => -4, One => 1, X => 2);\n    ST2 : constant Second_Type := (I => 99, One => 1, Y => 77);\n \n+   NAV1 : constant Nested_And_Variable := (One => 0, Two => 93,\n+                                           Str => (others => 'z'));\n+   NAV2 : constant Nested_And_Variable := (One => 3, OneValue => 33,\n+                                           Str => (others => 'z'),\n+                                           Str2 => (others => 'q'),\n+                                           Two => 0);\n+   NAV3 : constant Nested_And_Variable := (One => 3, OneValue => 33,\n+                                           Str => (others => 'z'),\n+                                           Str2 => (others => 'q'),\n+                                           Two => 7, TwoValue => 88);\n+\n begin\n    R := (C => 'd');\n    Q := (C => Character'First, X_First => 27);"
    }
  ]
}