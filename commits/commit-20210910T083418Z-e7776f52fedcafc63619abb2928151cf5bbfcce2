{
  "sha": "e7776f52fedcafc63619abb2928151cf5bbfcce2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTc3NzZmNTJmZWRjYWZjNjM2MTlhYmIyOTI4MTUxY2Y1YmJmY2NlMg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-09-09T01:29:24Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-09-10T08:34:18Z"
    },
    "message": "PowerPC, sanity check r_offset in relocate_section\n\n        * elf32-ppc.c (offset_in_range): New function.\n\t(ppc_elf_vle_split16): Sanity check r_offset before accessing\n\tsection contents.  Return status.\n        (ppc_elf_relocate_section): Sanity check r_offset before\n        accessing section contents.  Don't segfault on NULL howto.",
    "tree": {
      "sha": "98dde7dad116279f7940c348ca6ffeb419e67f52",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/98dde7dad116279f7940c348ca6ffeb419e67f52"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e7776f52fedcafc63619abb2928151cf5bbfcce2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e7776f52fedcafc63619abb2928151cf5bbfcce2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e7776f52fedcafc63619abb2928151cf5bbfcce2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e7776f52fedcafc63619abb2928151cf5bbfcce2/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9f81b99e2426d19760c20c07f8cd3ae5cd85e8df",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f81b99e2426d19760c20c07f8cd3ae5cd85e8df",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9f81b99e2426d19760c20c07f8cd3ae5cd85e8df"
    }
  ],
  "stats": {
    "total": 799,
    "additions": 442,
    "deletions": 357
  },
  "files": [
    {
      "sha": "d6b798a1c477e8283bf6fce7c4a1f07ee411b5ab",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 442,
      "deletions": 357,
      "changes": 799,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e7776f52fedcafc63619abb2928151cf5bbfcce2/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e7776f52fedcafc63619abb2928151cf5bbfcce2/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=e7776f52fedcafc63619abb2928151cf5bbfcce2",
      "patch": "@@ -2856,6 +2856,15 @@ is_plt_seq_reloc (enum elf_ppc_reloc_type r_type)\n \t  || r_type == R_PPC_PLTSEQ);\n }\n \n+/* Like bfd_reloc_offset_in_range but without a howto.  Return true\n+   iff a field of SIZE bytes at OFFSET is within SEC limits.  */\n+\n+static bool\n+offset_in_range (asection *sec, bfd_vma offset, size_t size)\n+{\n+  return offset <= sec->size && size <= sec->size - offset;\n+}\n+\n static void\n bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)\n {\n@@ -3884,7 +3893,7 @@ ppc_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n   return true;\n }\n \n-static void\n+static bfd_reloc_status_type\n ppc_elf_vle_split16 (bfd *input_bfd,\n \t\t     asection *input_section,\n \t\t     unsigned long offset,\n@@ -3895,6 +3904,8 @@ ppc_elf_vle_split16 (bfd *input_bfd,\n {\n   unsigned int insn, opcode;\n \n+  if (!offset_in_range (input_section, offset, 4))\n+    return bfd_reloc_outofrange;\n   insn = bfd_get_32 (input_bfd, loc);\n   opcode = insn & E_OPCODE_MASK;\n   if (opcode == E_OR2I_INSN\n@@ -3951,6 +3962,7 @@ ppc_elf_vle_split16 (bfd *input_bfd,\n     }\n   insn |= value & 0x7ff;\n   bfd_put_32 (input_bfd, insn, loc);\n+  return bfd_reloc_ok;\n }\n \n static void\n@@ -7132,7 +7144,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_GOT_TPREL16:\n \tcase R_PPC_GOT_TPREL16_LO:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      bfd_vma insn;\n \n@@ -7149,7 +7162,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC_TLS:\n \t  if ((tls_mask & TLS_TLS) != 0\n-\t      && (tls_mask & TLS_TPREL) == 0)\n+\t      && (tls_mask & TLS_TPREL) == 0\n+\t      && offset_in_range (input_section, rel->r_offset, 4))\n \t    {\n \t      bfd_vma insn;\n \n@@ -7170,13 +7184,15 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_GOT_TLSGD16_HI:\n \tcase R_PPC_GOT_TLSGD16_HA:\n \t  tls_gd = TLS_GDIE;\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    goto tls_gdld_hi;\n \t  break;\n \n \tcase R_PPC_GOT_TLSLD16_HI:\n \tcase R_PPC_GOT_TLSLD16_HA:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t    tls_gdld_hi:\n \t      if ((tls_mask & tls_gd) != 0)\n@@ -7195,13 +7211,15 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_GOT_TLSGD16:\n \tcase R_PPC_GOT_TLSGD16_LO:\n \t  tls_gd = TLS_GDIE;\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    goto tls_ldgd_opt;\n \t  break;\n \n \tcase R_PPC_GOT_TLSLD16:\n \tcase R_PPC_GOT_TLSLD16_LO:\n-\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)\n+\t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      unsigned int insn1, insn2;\n \t      bfd_vma offset;\n@@ -7229,7 +7247,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t\t  /* IE */\n \t\t  insn1 &= (0x1f << 21) | (0x1f << 16);\n \t\t  insn1 |= 32u << 26;\t/* lwz */\n-\t\t  if (offset != (bfd_vma) -1)\n+\t\t  if (offset != (bfd_vma) -1\n+\t\t      && offset_in_range (input_section, offset, 4))\n \t\t    {\n \t\t      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);\n \t\t      insn2 = 0x7c631214;\t/* add 3,3,2 */\n@@ -7262,7 +7281,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t\t    }\n \t\t  r_type = R_PPC_TPREL16_HA;\n \t\t  rel->r_info = ELF32_R_INFO (r_symndx, r_type);\n-\t\t  if (offset != (bfd_vma) -1)\n+\t\t  if (offset != (bfd_vma) -1\n+\t\t      && offset_in_range (input_section, offset, 4))\n \t\t    {\n \t\t      rel[1].r_info = ELF32_R_INFO (r_symndx, R_PPC_TPREL16_LO);\n \t\t      rel[1].r_offset = offset + d_offset;\n@@ -7284,7 +7304,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC_TLSGD:\n \t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0\n-\t      && rel + 1 < relend)\n+\t      && rel + 1 < relend\n+\t      && offset_in_range (input_section, rel->r_offset, 4))\n \t    {\n \t      unsigned int insn2;\n \t      bfd_vma offset = rel->r_offset;\n@@ -7319,7 +7340,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC_TLSLD:\n \t  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0\n-\t      && rel + 1 < relend)\n+\t      && rel + 1 < relend\n+\t      && offset_in_range (input_section, rel->r_offset, 4))\n \t    {\n \t      unsigned int insn2;\n \n@@ -7372,48 +7394,50 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t  /* Branch not taken prediction relocations.  */\n \tcase R_PPC_ADDR14_BRNTAKEN:\n \tcase R_PPC_REL14_BRNTAKEN:\n-\t  {\n-\t    unsigned int insn;\n+\t  if (offset_in_range (input_section, rel->r_offset, 4))\n+\t    {\n+\t      unsigned int insn;\n \n-\t    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n-\t    insn &= ~BRANCH_PREDICT_BIT;\n-\t    insn |= branch_bit;\n+\t      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n+\t      insn &= ~BRANCH_PREDICT_BIT;\n+\t      insn |= branch_bit;\n \n-\t    from = (rel->r_offset\n-\t\t    + input_section->output_offset\n-\t\t    + input_section->output_section->vma);\n+\t      from = (rel->r_offset\n+\t\t      + input_section->output_offset\n+\t\t      + input_section->output_section->vma);\n \n-\t    /* Invert 'y' bit if not the default.  */\n-\t    if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)\n-\t      insn ^= BRANCH_PREDICT_BIT;\n+\t      /* Invert 'y' bit if not the default.  */\n+\t      if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)\n+\t\tinsn ^= BRANCH_PREDICT_BIT;\n \n-\t    bfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n-\t  }\n+\t      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n+\t    }\n \t  break;\n \n \tcase R_PPC_PLT16_HA:\n-\t  {\n-\t    unsigned int insn;\n+\t  if (offset_in_range (input_section, rel->r_offset - d_offset, 4))\n+\t    {\n+\t      unsigned int insn;\n \n-\t    insn = bfd_get_32 (input_bfd,\n-\t\t\t       contents + rel->r_offset - d_offset);\n-\t    if ((insn & (0x3fu << 26)) == 15u << 26\n-\t\t&& (insn & (0x1f << 16)) != 0)\n-\t      {\n-\t\tif (!bfd_link_pic (info))\n-\t\t  {\n-\t\t    /* Convert addis to lis.  */\n-\t\t    insn &= ~(0x1f << 16);\n-\t\t    bfd_put_32 (input_bfd, insn,\n-\t\t\t\tcontents + rel->r_offset - d_offset);\n-\t\t  }\n-\t      }\n-\t    else if (bfd_link_pic (info))\n-\t      info->callbacks->einfo\n-\t\t(_(\"%P: %H: error: %s with unexpected instruction %x\\n\"),\n-\t\t input_bfd, input_section, rel->r_offset,\n-\t\t \"R_PPC_PLT16_HA\", insn);\n-\t  }\n+\t      insn = bfd_get_32 (input_bfd,\n+\t\t\t\t contents + rel->r_offset - d_offset);\n+\t      if ((insn & (0x3fu << 26)) == 15u << 26\n+\t\t  && (insn & (0x1f << 16)) != 0)\n+\t\t{\n+\t\t  if (!bfd_link_pic (info))\n+\t\t    {\n+\t\t      /* Convert addis to lis.  */\n+\t\t      insn &= ~(0x1f << 16);\n+\t\t      bfd_put_32 (input_bfd, insn,\n+\t\t\t\t  contents + rel->r_offset - d_offset);\n+\t\t    }\n+\t\t}\n+\t      else if (bfd_link_pic (info))\n+\t\tinfo->callbacks->einfo\n+\t\t  (_(\"%P: %H: error: %s with unexpected instruction %x\\n\"),\n+\t\t   input_bfd, input_section, rel->r_offset,\n+\t\t   \"R_PPC_PLT16_HA\", insn);\n+\t    }\n \t  break;\n \t}\n \n@@ -7429,7 +7453,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t     variable defined in a shared library to PIC.  */\n \t  unsigned int insn;\n \n-\t  if (r_type == R_PPC_ADDR16_HA)\n+\t  if (r_type == R_PPC_ADDR16_HA\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd,\n \t\t\t\t contents + rel->r_offset - d_offset);\n@@ -7492,7 +7517,9 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t\t   input_bfd, input_section, (uint64_t) rel->r_offset,\n \t\t   \"R_PPC_ADDR16_HA\", insn);\n \t    }\n-\t  else if (r_type == R_PPC_ADDR16_LO)\n+\t  else if (r_type == R_PPC_ADDR16_LO\n+\t\t   && offset_in_range (input_section,\n+\t\t\t\t       rel->r_offset - d_offset, 4))\n \t    {\n \t      insn = bfd_get_32 (input_bfd,\n \t\t\t\t contents + rel->r_offset - d_offset);\n@@ -7616,9 +7643,15 @@ ppc_elf_relocate_section (bfd *output_bfd,\n       switch (r_type)\n \t{\n \tdefault:\n-\t  /* xgettext:c-format */\n-\t  _bfd_error_handler (_(\"%pB: %s unsupported\"),\n-\t\t\t      input_bfd, howto->name);\n+\tde_fault:\n+\t  if (howto)\n+\t    /* xgettext:c-format */\n+\t    _bfd_error_handler (_(\"%pB: %s unsupported\"),\n+\t\t\t\tinput_bfd, howto->name);\n+\t  else\n+\t    /* xgettext:c-format */\n+\t    _bfd_error_handler (_(\"%pB: reloc %#x unsupported\"),\n+\t\t\t\tinput_bfd, r_type);\n \n \t  bfd_set_error (bfd_error_bad_value);\n \t  ret = false;\n@@ -7956,7 +7989,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_TPREL16_HA:\n \t  if (h != NULL\n \t      && h->root.type == bfd_link_hash_undefweak\n-\t      && h->dynindx == -1)\n+\t      && h->dynindx == -1\n+\t      && offset_in_range (input_section, rel->r_offset - d_offset, 4))\n \t    {\n \t      /* Make this relocation against an undefined weak symbol\n \t\t resolve to zero.  This is really just a tweak, since\n@@ -8224,66 +8258,73 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t  /* Fall through.  */\n \n \tcase R_PPC_RELAX:\n-\t  {\n-\t    const int *stub;\n-\t    size_t size;\n-\t    size_t insn_offset = rel->r_offset;\n-\t    unsigned int insn;\n-\n-\t    if (bfd_link_pic (info))\n-\t      {\n-\t\trelocation -= (input_section->output_section->vma\n-\t\t\t       + input_section->output_offset\n-\t\t\t       + rel->r_offset - 4);\n-\t\tstub = shared_stub_entry;\n-\t\tbfd_put_32 (input_bfd, stub[0], contents + insn_offset - 12);\n-\t\tbfd_put_32 (input_bfd, stub[1], contents + insn_offset - 8);\n-\t\tbfd_put_32 (input_bfd, stub[2], contents + insn_offset - 4);\n-\t\tstub += 3;\n-\t\tsize = ARRAY_SIZE (shared_stub_entry) - 3;\n-\t      }\n-\t    else\n-\t      {\n-\t\tstub = stub_entry;\n-\t\tsize = ARRAY_SIZE (stub_entry);\n-\t      }\n-\n-\t    relocation += addend;\n-\t    if (bfd_link_relocatable (info))\n-\t      relocation = 0;\n-\n-\t    /* First insn is HA, second is LO.  */\n-\t    insn = *stub++;\n-\t    insn |= ((relocation + 0x8000) >> 16) & 0xffff;\n-\t    bfd_put_32 (input_bfd, insn, contents + insn_offset);\n-\t    insn_offset += 4;\n+\t  if (bfd_link_pic (info)\n+\t      ? offset_in_range (input_section, rel->r_offset - 12,\n+\t\t\t\t ARRAY_SIZE (shared_stub_entry) * 4)\n+\t      : offset_in_range (input_section, rel->r_offset,\n+\t\t\t\t ARRAY_SIZE (stub_entry) * 4))\n+\t    {\n+\t      const int *stub;\n+\t      size_t size;\n+\t      size_t insn_offset = rel->r_offset;\n+\t      unsigned int insn;\n \n-\t    insn = *stub++;\n-\t    insn |= relocation & 0xffff;\n-\t    bfd_put_32 (input_bfd, insn, contents + insn_offset);\n-\t    insn_offset += 4;\n-\t    size -= 2;\n+\t      if (bfd_link_pic (info))\n+\t\t{\n+\t\t  relocation -= (input_section->output_section->vma\n+\t\t\t\t + input_section->output_offset\n+\t\t\t\t + rel->r_offset - 4);\n+\t\t  stub = shared_stub_entry;\n+\t\t  bfd_put_32 (input_bfd, stub[0], contents + insn_offset - 12);\n+\t\t  bfd_put_32 (input_bfd, stub[1], contents + insn_offset - 8);\n+\t\t  bfd_put_32 (input_bfd, stub[2], contents + insn_offset - 4);\n+\t\t  stub += 3;\n+\t\t  size = ARRAY_SIZE (shared_stub_entry) - 3;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  stub = stub_entry;\n+\t\t  size = ARRAY_SIZE (stub_entry);\n+\t\t}\n \n-\t    while (size != 0)\n-\t      {\n-\t\tinsn = *stub++;\n-\t\t--size;\n-\t\tbfd_put_32 (input_bfd, insn, contents + insn_offset);\n-\t\tinsn_offset += 4;\n-\t      }\n+\t      relocation += addend;\n+\t      if (bfd_link_relocatable (info))\n+\t\trelocation = 0;\n+\n+\t      /* First insn is HA, second is LO.  */\n+\t      insn = *stub++;\n+\t      insn |= ((relocation + 0x8000) >> 16) & 0xffff;\n+\t      bfd_put_32 (input_bfd, insn, contents + insn_offset);\n+\t      insn_offset += 4;\n+\n+\t      insn = *stub++;\n+\t      insn |= relocation & 0xffff;\n+\t      bfd_put_32 (input_bfd, insn, contents + insn_offset);\n+\t      insn_offset += 4;\n+\t      size -= 2;\n+\n+\t      while (size != 0)\n+\t\t{\n+\t\t  insn = *stub++;\n+\t\t  --size;\n+\t\t  bfd_put_32 (input_bfd, insn, contents + insn_offset);\n+\t\t  insn_offset += 4;\n+\t\t}\n \n-\t    /* Rewrite the reloc and convert one of the trailing nop\n-\t       relocs to describe this relocation.  */\n-\t    BFD_ASSERT (ELF32_R_TYPE (relend[-1].r_info) == R_PPC_NONE);\n-\t    /* The relocs are at the bottom 2 bytes */\n-\t    wrel->r_offset = rel->r_offset + d_offset;\n-\t    wrel->r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_HA);\n-\t    wrel->r_addend = rel->r_addend;\n-\t    memmove (wrel + 1, wrel, (relend - wrel - 1) * sizeof (*wrel));\n-\t    wrel++, rel++;\n-\t    wrel->r_offset += 4;\n-\t    wrel->r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_LO);\n-\t  }\n+\t      /* Rewrite the reloc and convert one of the trailing nop\n+\t\t relocs to describe this relocation.  */\n+\t      BFD_ASSERT (ELF32_R_TYPE (relend[-1].r_info) == R_PPC_NONE);\n+\t      /* The relocs are at the bottom 2 bytes */\n+\t      wrel->r_offset = rel->r_offset + d_offset;\n+\t      wrel->r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_HA);\n+\t      wrel->r_addend = rel->r_addend;\n+\t      memmove (wrel + 1, wrel, (relend - wrel - 1) * sizeof (*wrel));\n+\t      wrel++, rel++;\n+\t      wrel->r_offset += 4;\n+\t      wrel->r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_LO);\n+\t    }\n+\t  else\n+\t    goto de_fault;\n \t  continue;\n \n \t  /* Indirect .sdata relocation.  */\n@@ -8487,151 +8528,164 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \n \tcase R_PPC_VLE_LO16A:\n \t  relocation = relocation + addend;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16a_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16a_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_LO16D:\n \t  relocation = relocation + addend;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16d_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16d_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_HI16A:\n \t  relocation = (relocation + addend) >> 16;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16a_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16a_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_HI16D:\n \t  relocation = (relocation + addend) >> 16;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16d_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16d_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_HA16A:\n \t  relocation = (relocation + addend + 0x8000) >> 16;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16a_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16a_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_HA16D:\n \t  relocation = (relocation + addend + 0x8000) >> 16;\n-\t  ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t       contents + rel->r_offset, relocation,\n-\t\t\t       split16d_type, htab->params->vle_reloc_fixup);\n-\t  goto copy_reloc;\n+\t  r = ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n+\t\t\t\t   contents + rel->r_offset, relocation,\n+\t\t\t\t   split16d_type,\n+\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t  goto report_reloc;\n \n \t  /* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */\n \tcase R_PPC_EMB_SDA21:\n \tcase R_PPC_VLE_SDA21:\n \tcase R_PPC_EMB_RELSDA:\n \tcase R_PPC_VLE_SDA21_LO:\n-\t  {\n-\t    const char *name;\n-\t    int reg;\n-\t    unsigned int insn;\n-\t    struct elf_link_hash_entry *sda = NULL;\n+\t  if (!offset_in_range (input_section, rel->r_offset, 4))\n+\t    {\n+\t      r = bfd_reloc_outofrange;\n+\t      goto report_reloc;\n+\t    }\n+\t  else\n+\t    {\n+\t      const char *name;\n+\t      int reg;\n+\t      unsigned int insn;\n+\t      struct elf_link_hash_entry *sda = NULL;\n \n-\t    if (sec == NULL || sec->output_section == NULL)\n-\t      {\n-\t\tunresolved_reloc = true;\n-\t\tbreak;\n-\t      }\n+\t      if (sec == NULL || sec->output_section == NULL)\n+\t\t{\n+\t\t  unresolved_reloc = true;\n+\t\t  break;\n+\t\t}\n \n-\t    name = bfd_section_name (sec->output_section);\n-\t    if (strcmp (name, \".sdata\") == 0\n-\t\t|| strcmp (name, \".sbss\") == 0)\n-\t      {\n-\t\treg = 13;\n-\t\tsda = htab->sdata[0].sym;\n-\t      }\n-\t    else if (strcmp (name, \".sdata2\") == 0\n-\t\t     || strcmp (name, \".sbss2\") == 0)\n-\t      {\n-\t\treg = 2;\n-\t\tsda = htab->sdata[1].sym;\n-\t      }\n-\t    else if (strcmp (name, \".PPC.EMB.sdata0\") == 0\n-\t\t     || strcmp (name, \".PPC.EMB.sbss0\") == 0)\n-\t      {\n-\t\treg = 0;\n-\t      }\n-\t    else\n-\t      {\n-\t\t_bfd_error_handler\n-\t\t  /* xgettext:c-format */\n-\t\t  (_(\"%pB: the target (%s) of a %s relocation is \"\n-\t\t     \"in the wrong output section (%s)\"),\n-\t\t   input_bfd,\n-\t\t   sym_name,\n-\t\t   howto->name,\n-\t\t   name);\n+\t      name = bfd_section_name (sec->output_section);\n+\t      if (strcmp (name, \".sdata\") == 0\n+\t\t  || strcmp (name, \".sbss\") == 0)\n+\t\t{\n+\t\t  reg = 13;\n+\t\t  sda = htab->sdata[0].sym;\n+\t\t}\n+\t      else if (strcmp (name, \".sdata2\") == 0\n+\t\t       || strcmp (name, \".sbss2\") == 0)\n+\t\t{\n+\t\t  reg = 2;\n+\t\t  sda = htab->sdata[1].sym;\n+\t\t}\n+\t      else if (strcmp (name, \".PPC.EMB.sdata0\") == 0\n+\t\t       || strcmp (name, \".PPC.EMB.sbss0\") == 0)\n+\t\t{\n+\t\t  reg = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  _bfd_error_handler\n+\t\t    /* xgettext:c-format */\n+\t\t    (_(\"%pB: the target (%s) of a %s relocation is \"\n+\t\t       \"in the wrong output section (%s)\"),\n+\t\t     input_bfd,\n+\t\t     sym_name,\n+\t\t     howto->name,\n+\t\t     name);\n+\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t  ret = false;\n+\t\t  goto copy_reloc;\n+\t\t}\n \n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\tret = false;\n-\t\tgoto copy_reloc;\n-\t      }\n+\t      if (sda != NULL)\n+\t\t{\n+\t\t  if (!is_static_defined (sda))\n+\t\t    {\n+\t\t      unresolved_reloc = true;\n+\t\t      break;\n+\t\t    }\n+\t\t  addend -= SYM_VAL (sda);\n+\t\t}\n \n-\t    if (sda != NULL)\n-\t      {\n-\t\tif (!is_static_defined (sda))\n-\t\t  {\n-\t\t    unresolved_reloc = true;\n-\t\t    break;\n-\t\t  }\n-\t\taddend -= SYM_VAL (sda);\n-\t      }\n+\t      if (r_type == R_PPC_EMB_RELSDA)\n+\t\tbreak;\n \n-\t    if (r_type == R_PPC_EMB_RELSDA)\n-\t      break;\n+\t      /* The PowerPC Embedded Application Binary Interface\n+\t\t version 1.0 insanely chose to specify R_PPC_EMB_SDA21\n+\t\t operating on a 24-bit field at r_offset.  GNU as and\n+\t\t GNU ld have always assumed R_PPC_EMB_SDA21 operates on\n+\t\t a 32-bit bit insn at r_offset.  Cope with object file\n+\t\t producers that possibly comply with the EABI in\n+\t\t generating an odd r_offset for big-endian objects.  */\n+\t      if (r_type == R_PPC_EMB_SDA21)\n+\t\trel->r_offset &= ~1;\n \n-\t    /* The PowerPC Embedded Application Binary Interface\n-\t       version 1.0 insanely chose to specify R_PPC_EMB_SDA21\n-\t       operating on a 24-bit field at r_offset.  GNU as and\n-\t       GNU ld have always assumed R_PPC_EMB_SDA21 operates on\n-\t       a 32-bit bit insn at r_offset.  Cope with object file\n-\t       producers that possibly comply with the EABI in\n-\t       generating an odd r_offset for big-endian objects.  */\n-\t    if (r_type == R_PPC_EMB_SDA21)\n-\t      rel->r_offset &= ~1;\n-\n-\t    insn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n-\t    if (reg == 0\n-\t\t&& (r_type == R_PPC_VLE_SDA21\n-\t\t    || r_type == R_PPC_VLE_SDA21_LO))\n-\t      {\n-\t\trelocation = relocation + addend;\n-\t\taddend = 0;\n-\n-\t\t/* Force e_li insn, keeping RT from original insn.  */\n-\t\tinsn &= 0x1f << 21;\n-\t\tinsn |= 28u << 26;\n-\n-\t\t/* We have an li20 field, bits 17..20, 11..15, 21..31.  */\n-\t\t/* Top 4 bits of value to 17..20.  */\n-\t\tinsn |= (relocation & 0xf0000) >> 5;\n-\t\t/* Next 5 bits of the value to 11..15.  */\n-\t\tinsn |= (relocation & 0xf800) << 5;\n-\t\t/* And the final 11 bits of the value to bits 21 to 31.  */\n-\t\tinsn |= relocation & 0x7ff;\n-\n-\t\tbfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n-\n-\t\tif (r_type == R_PPC_VLE_SDA21\n-\t\t    && ((relocation + 0x80000) & 0xffffffff) > 0x100000)\n-\t\t  goto overflow;\n-\t\tgoto copy_reloc;\n-\t      }\n-\t    /* Fill in register field.  */\n-\t    insn = (insn & ~RA_REGISTER_MASK) | (reg << RA_REGISTER_SHIFT);\n-\t    bfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n-\t  }\n+\t      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);\n+\t      if (reg == 0\n+\t\t  && (r_type == R_PPC_VLE_SDA21\n+\t\t      || r_type == R_PPC_VLE_SDA21_LO))\n+\t\t{\n+\t\t  relocation = relocation + addend;\n+\t\t  addend = 0;\n+\n+\t\t  /* Force e_li insn, keeping RT from original insn.  */\n+\t\t  insn &= 0x1f << 21;\n+\t\t  insn |= 28u << 26;\n+\n+\t\t  /* We have an li20 field, bits 17..20, 11..15, 21..31.  */\n+\t\t  /* Top 4 bits of value to 17..20.  */\n+\t\t  insn |= (relocation & 0xf0000) >> 5;\n+\t\t  /* Next 5 bits of the value to 11..15.  */\n+\t\t  insn |= (relocation & 0xf800) << 5;\n+\t\t  /* And the final 11 bits of the value to bits 21 to 31.  */\n+\t\t  insn |= relocation & 0x7ff;\n+\n+\t\t  bfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n+\n+\t\t  r = bfd_reloc_ok;\n+\t\t  if (r_type == R_PPC_VLE_SDA21\n+\t\t      && ((relocation + 0x80000) & 0xffffffff) > 0x100000)\n+\t\t    r = bfd_reloc_overflow;\n+\t\t  goto report_reloc;\n+\t\t}\n+\t      /* Fill in register field.  */\n+\t      insn = (insn & ~RA_REGISTER_MASK) | (reg << RA_REGISTER_SHIFT);\n+\t      bfd_put_32 (input_bfd, insn, contents + rel->r_offset);\n+\t    }\n \t  break;\n \n \tcase R_PPC_VLE_SDAREL_LO16A:\n@@ -8640,95 +8694,113 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_VLE_SDAREL_HI16D:\n \tcase R_PPC_VLE_SDAREL_HA16A:\n \tcase R_PPC_VLE_SDAREL_HA16D:\n-\t  {\n-\t    bfd_vma value;\n-\t    const char *name;\n-\t    struct elf_link_hash_entry *sda = NULL;\n-\n-\t    if (sec == NULL || sec->output_section == NULL)\n-\t      {\n-\t\tunresolved_reloc = true;\n-\t\tbreak;\n-\t      }\n-\n-\t    name = bfd_section_name (sec->output_section);\n-\t    if (strcmp (name, \".sdata\") == 0\n-\t\t|| strcmp (name, \".sbss\") == 0)\n-\t      sda = htab->sdata[0].sym;\n-\t    else if (strcmp (name, \".sdata2\") == 0\n-\t\t     || strcmp (name, \".sbss2\") == 0)\n-\t      sda = htab->sdata[1].sym;\n-\t    else\n-\t      {\n-\t\t_bfd_error_handler\n-\t\t  /* xgettext:c-format */\n-\t\t  (_(\"%pB: the target (%s) of a %s relocation is \"\n-\t\t     \"in the wrong output section (%s)\"),\n-\t\t   input_bfd,\n-\t\t   sym_name,\n-\t\t   howto->name,\n-\t\t   name);\n+\t  if (!offset_in_range (input_section, rel->r_offset, 4))\n+\t    r = bfd_reloc_outofrange;\n+\t  else\n+\t    {\n+\t      bfd_vma value;\n+\t      const char *name;\n+\t      struct elf_link_hash_entry *sda = NULL;\n \n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\tret = false;\n-\t\tgoto copy_reloc;\n-\t      }\n+\t      if (sec == NULL || sec->output_section == NULL)\n+\t\t{\n+\t\t  unresolved_reloc = true;\n+\t\t  break;\n+\t\t}\n \n-\t    if (sda == NULL || !is_static_defined (sda))\n-\t      {\n-\t\tunresolved_reloc = true;\n-\t\tbreak;\n-\t      }\n-\t    value = relocation + addend - SYM_VAL (sda);\n+\t      name = bfd_section_name (sec->output_section);\n+\t      if (strcmp (name, \".sdata\") == 0\n+\t\t  || strcmp (name, \".sbss\") == 0)\n+\t\tsda = htab->sdata[0].sym;\n+\t      else if (strcmp (name, \".sdata2\") == 0\n+\t\t       || strcmp (name, \".sbss2\") == 0)\n+\t\tsda = htab->sdata[1].sym;\n+\t      else\n+\t\t{\n+\t\t  _bfd_error_handler\n+\t\t    /* xgettext:c-format */\n+\t\t    (_(\"%pB: the target (%s) of a %s relocation is \"\n+\t\t       \"in the wrong output section (%s)\"),\n+\t\t     input_bfd,\n+\t\t     sym_name,\n+\t\t     howto->name,\n+\t\t     name);\n+\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t  ret = false;\n+\t\t  goto copy_reloc;\n+\t\t}\n \n-\t    if (r_type == R_PPC_VLE_SDAREL_LO16A)\n-\t      ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t   contents + rel->r_offset, value,\n-\t\t\t\t   split16a_type,\n-\t\t\t\t   htab->params->vle_reloc_fixup);\n-\t    else if (r_type == R_PPC_VLE_SDAREL_LO16D)\n-\t      ppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t   contents + rel->r_offset, value,\n-\t\t\t\t   split16d_type,\n-\t\t\t\t   htab->params->vle_reloc_fixup);\n-\t    else if (r_type == R_PPC_VLE_SDAREL_HI16A)\n-\t      {\n-\t\tvalue = value >> 16;\n-\t\tppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t     contents + rel->r_offset, value,\n-\t\t\t\t     split16a_type,\n-\t\t\t\t     htab->params->vle_reloc_fixup);\n-\t      }\n-\t    else if (r_type == R_PPC_VLE_SDAREL_HI16D)\n-\t      {\n-\t\tvalue = value >> 16;\n-\t\tppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t     contents + rel->r_offset, value,\n-\t\t\t\t     split16d_type,\n-\t\t\t\t     htab->params->vle_reloc_fixup);\n-\t      }\n-\t    else if (r_type == R_PPC_VLE_SDAREL_HA16A)\n-\t      {\n-\t\tvalue = (value + 0x8000) >> 16;\n-\t\tppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t     contents + rel->r_offset, value,\n-\t\t\t\t     split16a_type,\n-\t\t\t\t     htab->params->vle_reloc_fixup);\n-\t      }\n-\t    else if (r_type == R_PPC_VLE_SDAREL_HA16D)\n-\t      {\n-\t\tvalue = (value + 0x8000) >> 16;\n-\t\tppc_elf_vle_split16 (input_bfd, input_section, rel->r_offset,\n-\t\t\t\t     contents + rel->r_offset, value,\n-\t\t\t\t     split16d_type,\n-\t\t\t\t     htab->params->vle_reloc_fixup);\n-\t      }\n-\t  }\n-\t  goto copy_reloc;\n+\t      if (sda == NULL || !is_static_defined (sda))\n+\t\t{\n+\t\t  unresolved_reloc = true;\n+\t\t  break;\n+\t\t}\n+\t      value = relocation + addend - SYM_VAL (sda);\n+\n+\t      if (r_type == R_PPC_VLE_SDAREL_LO16A)\n+\t\tr = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t rel->r_offset,\n+\t\t\t\t\t contents + rel->r_offset, value,\n+\t\t\t\t\t split16a_type,\n+\t\t\t\t\t htab->params->vle_reloc_fixup);\n+\t      else if (r_type == R_PPC_VLE_SDAREL_LO16D)\n+\t\tr = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t rel->r_offset,\n+\t\t\t\t\t contents + rel->r_offset, value,\n+\t\t\t\t\t split16d_type,\n+\t\t\t\t\t htab->params->vle_reloc_fixup);\n+\t      else if (r_type == R_PPC_VLE_SDAREL_HI16A)\n+\t\t{\n+\t\t  value = value >> 16;\n+\t\t  r = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t   rel->r_offset,\n+\t\t\t\t\t   contents + rel->r_offset, value,\n+\t\t\t\t\t   split16a_type,\n+\t\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t\t}\n+\t      else if (r_type == R_PPC_VLE_SDAREL_HI16D)\n+\t\t{\n+\t\t  value = value >> 16;\n+\t\t  r = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t   rel->r_offset,\n+\t\t\t\t\t   contents + rel->r_offset, value,\n+\t\t\t\t\t   split16d_type,\n+\t\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t\t}\n+\t      else if (r_type == R_PPC_VLE_SDAREL_HA16A)\n+\t\t{\n+\t\t  value = (value + 0x8000) >> 16;\n+\t\t  r = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t   rel->r_offset,\n+\t\t\t\t\t   contents + rel->r_offset, value,\n+\t\t\t\t\t   split16a_type,\n+\t\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t\t}\n+\t      else if (r_type == R_PPC_VLE_SDAREL_HA16D)\n+\t\t{\n+\t\t  value = (value + 0x8000) >> 16;\n+\t\t  r = ppc_elf_vle_split16 (input_bfd, input_section,\n+\t\t\t\t\t   rel->r_offset,\n+\t\t\t\t\t   contents + rel->r_offset, value,\n+\t\t\t\t\t   split16d_type,\n+\t\t\t\t\t   htab->params->vle_reloc_fixup);\n+\t\t}\n+\t      else\n+\t\tabort ();\n+\t    }\n+\t  goto report_reloc;\n \n \tcase R_PPC_VLE_ADDR20:\n-\t  ppc_elf_vle_split20 (output_bfd, contents + rel->r_offset, relocation);\n-\t  goto copy_reloc;\n+\t  if (!offset_in_range (input_section, rel->r_offset, 4))\n+\t    r = bfd_reloc_outofrange;\n+\t  else\n+\t    {\n+\t      ppc_elf_vle_split20 (output_bfd, contents + rel->r_offset,\n+\t\t\t\t   relocation);\n+\t      r = bfd_reloc_ok;\n+\t    }\n+\t  goto report_reloc;\n \n \t  /* Relocate against the beginning of the section.  */\n \tcase R_PPC_SECTOFF:\n@@ -8780,15 +8852,20 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \n \tcase R_PPC_TPREL16_HA:\n-\t  if (htab->do_tls_opt && relocation + addend + 0x8000 < 0x10000)\n+\t  if (htab->do_tls_opt\n+\t      && relocation + addend + 0x8000 < 0x10000\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n+\n \t    {\n \t      bfd_byte *p = contents + (rel->r_offset & ~3);\n \t      bfd_put_32 (input_bfd, NOP, p);\n \t    }\n \t  break;\n \n \tcase R_PPC_TPREL16_LO:\n-\t  if (htab->do_tls_opt && relocation + addend + 0x8000 < 0x10000)\n+\t  if (htab->do_tls_opt\n+\t      && relocation + addend + 0x8000 < 0x10000\n+\t      && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t    {\n \t      bfd_byte *p = contents + (rel->r_offset & ~3);\n \t      unsigned int insn = bfd_get_32 (input_bfd, p);\n@@ -8807,13 +8884,16 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_PLTCALL:\n \t  if (unresolved_reloc)\n \t    {\n-\t      bfd_byte *p = contents + rel->r_offset;\n-\t      unsigned int insn = bfd_get_32 (input_bfd, p);\n-\t      insn &= 1;\n-\t      bfd_put_32 (input_bfd, B | insn, p);\n-\t      unresolved_reloc = save_unresolved_reloc;\n-\t      r_type = R_PPC_REL24;\n-\t      howto = ppc_elf_howto_table[r_type];\n+\t      if (offset_in_range (input_section, rel->r_offset, 4))\n+\t\t{\n+\t\t  bfd_byte *p = contents + rel->r_offset;\n+\t\t  unsigned int insn = bfd_get_32 (input_bfd, p);\n+\t\t  insn &= 1;\n+\t\t  bfd_put_32 (input_bfd, B | insn, p);\n+\t\t  unresolved_reloc = save_unresolved_reloc;\n+\t\t  r_type = R_PPC_REL24;\n+\t\t  howto = ppc_elf_howto_table[r_type];\n+\t\t}\n \t    }\n \t  else if (htab->plt_type != PLT_NEW)\n \t    info->callbacks->einfo\n@@ -8827,11 +8907,14 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_PLT16_LO:\n \t  if (unresolved_reloc)\n \t    {\n-\t      bfd_byte *p = contents + (rel->r_offset & ~3);\n-\t      bfd_put_32 (input_bfd, NOP, p);\n-\t      unresolved_reloc = false;\n-\t      r_type = R_PPC_NONE;\n-\t      howto = ppc_elf_howto_table[r_type];\n+\t      if (offset_in_range (input_section, rel->r_offset & ~3, 4))\n+\t\t{\n+\t\t  bfd_byte *p = contents + (rel->r_offset & ~3);\n+\t\t  bfd_put_32 (input_bfd, NOP, p);\n+\t\t  unresolved_reloc = false;\n+\t\t  r_type = R_PPC_NONE;\n+\t\t  howto = ppc_elf_howto_table[r_type];\n+\t\t}\n \t    }\n \t  else if (htab->plt_type != PLT_NEW)\n \t    info->callbacks->einfo\n@@ -8893,36 +8976,37 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tcase R_PPC_GOT_DTPREL16_LO:\n \tcase R_PPC_GOT_TPREL16:\n \tcase R_PPC_GOT_TPREL16_LO:\n-\t  {\n-\t    /* The 32-bit ABI lacks proper relocations to deal with\n-\t       certain 64-bit instructions.  Prevent damage to bits\n-\t       that make up part of the insn opcode.  */\n-\t    unsigned int insn, mask, lobit;\n-\n-\t    insn = bfd_get_32 (input_bfd,\n-\t\t\t       contents + rel->r_offset - d_offset);\n-\t    mask = 0;\n-\t    if (is_insn_ds_form (insn))\n-\t      mask = 3;\n-\t    else if (is_insn_dq_form (insn))\n-\t      mask = 15;\n-\t    else\n-\t      break;\n-\t    relocation += addend;\n-\t    addend = insn & mask;\n-\t    lobit = mask & relocation;\n-\t    if (lobit != 0)\n-\t      {\n-\t\trelocation ^= lobit;\n-\t\tinfo->callbacks->einfo\n-\t\t  /* xgettext:c-format */\n-\t\t  (_(\"%H: error: %s against `%s' not a multiple of %u\\n\"),\n-\t\t   input_bfd, input_section, rel->r_offset,\n-\t\t   howto->name, sym_name, mask + 1);\n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\tret = false;\n-\t      }\n-\t  }\n+\t  if (offset_in_range (input_section, rel->r_offset - d_offset, 4))\n+\t    {\n+\t      /* The 32-bit ABI lacks proper relocations to deal with\n+\t\t certain 64-bit instructions.  Prevent damage to bits\n+\t\t that make up part of the insn opcode.  */\n+\t      unsigned int insn, mask, lobit;\n+\n+\t      insn = bfd_get_32 (input_bfd,\n+\t\t\t\t contents + rel->r_offset - d_offset);\n+\t      mask = 0;\n+\t      if (is_insn_ds_form (insn))\n+\t\tmask = 3;\n+\t      else if (is_insn_dq_form (insn))\n+\t\tmask = 15;\n+\t      else\n+\t\tbreak;\n+\t      relocation += addend;\n+\t      addend = insn & mask;\n+\t      lobit = mask & relocation;\n+\t      if (lobit != 0)\n+\t\t{\n+\t\t  relocation ^= lobit;\n+\t\t  info->callbacks->einfo\n+\t\t    /* xgettext:c-format */\n+\t\t    (_(\"%H: error: %s against `%s' not a multiple of %u\\n\"),\n+\t\t     input_bfd, input_section, rel->r_offset,\n+\t\t     howto->name, sym_name, mask + 1);\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t  ret = false;\n+\t\t}\n+\t    }\n \t  break;\n \t}\n \n@@ -8957,7 +9041,8 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \t have different reloc types.  */\n       if (howto->complain_on_overflow != complain_overflow_dont\n \t  && howto->dst_mask == 0xffff\n-\t  && (input_section->flags & SEC_CODE) != 0)\n+\t  && (input_section->flags & SEC_CODE) != 0\n+\t  && offset_in_range (input_section, rel->r_offset & ~3, 4))\n \t{\n \t  enum complain_overflow complain = complain_overflow_signed;\n \n@@ -8984,7 +9069,7 @@ ppc_elf_relocate_section (bfd *output_bfd,\n       if (r_type == R_PPC_REL16DX_HA)\n \t{\n \t  /* Split field reloc isn't handled by _bfd_final_link_relocate.  */\n-\t  if (rel->r_offset + 4 > input_section->size)\n+\t  if (offset_in_range (input_section, rel->r_offset, 4))\n \t    r = bfd_reloc_outofrange;\n \t  else\n \t    {\n@@ -9006,11 +9091,11 @@ ppc_elf_relocate_section (bfd *output_bfd,\n \tr = _bfd_final_link_relocate (howto, input_bfd, input_section, contents,\n \t\t\t\t      rel->r_offset, relocation, addend);\n \n+    report_reloc:\n       if (r != bfd_reloc_ok)\n \t{\n \t  if (r == bfd_reloc_overflow)\n \t    {\n-\t    overflow:\n \t      /* On code like \"if (foo) foo();\" don't report overflow\n \t\t on a branch to zero when foo is undefined.  */\n \t      if (!warned"
    }
  ]
}