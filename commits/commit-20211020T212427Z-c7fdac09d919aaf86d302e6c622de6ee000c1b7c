{
  "sha": "c7fdac09d919aaf86d302e6c622de6ee000c1b7c",
  "node_id": "C_kwDOANOeidoAKGM3ZmRhYzA5ZDkxOWFhZjg2ZDMwMmU2YzYyMmRlNmVlMDAwYzFiN2M",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-19T22:42:48Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-20T21:24:27Z"
    },
    "message": "Re: PR27625, powerpc64 gold __tls_get_addr calls\n\nMy previous PR27625 patch had a problem or two.  For one, the error\n\"__tls_get_addr call lacks marker reloc\" on processing some calls\nbefore hitting a call without markers typically isn't seen.  Instead a\ngold assertion fails.  Either way it would be a hard error, which\ntriggers on a file contained in libphobos.a when running the gcc\ntestsuite.  A warning isn't even appropriate since the call involved\nis one built by hand without any of the arg setup relocations that\nmight result in linker optimisation.\n\nSo this patch reverts most of commit 0af4fcc25dd5, instead entirely\nignoring the problem of mis-optimising old-style __tls_get_addr calls\nwithout marker relocs.  We can't handle them gracefully without\nanother pass over relocations before decisions are made about GOT\nentries in Scan::global or Scan::local.  That seems too costly, just\nto link object files from 2009.  What's more, there doesn't seem to be\nany way to allow the libphobos explicit __tls_get_addr call, but not\nold TLS sequences without marker relocs.  Examining instructions\nbefore the __tls_get_addr call is out of the question: program flow\nmight reach the call via a branch.  Putting an R_PPC64_TLSGD marker\nwith zero sym on the call might be a solution, but current linkers\nwill then merrily optimise away the call!\n\n\tPR gold/27625\n\t* powerpc.cc (Powerpc_relobj): Delete no_tls_marker_, tls_marker_,\n\tand tls_opt_error_ variables and accessors.  Remove all uses.",
    "tree": {
      "sha": "47897b545380188f705f62771049c1d864c05605",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/47897b545380188f705f62771049c1d864c05605"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c7fdac09d919aaf86d302e6c622de6ee000c1b7c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7fdac09d919aaf86d302e6c622de6ee000c1b7c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c7fdac09d919aaf86d302e6c622de6ee000c1b7c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7fdac09d919aaf86d302e6c622de6ee000c1b7c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "570bc7936f5aa9299eee20ba3e170b44efd6c98f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/570bc7936f5aa9299eee20ba3e170b44efd6c98f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/570bc7936f5aa9299eee20ba3e170b44efd6c98f"
    }
  ],
  "stats": {
    "total": 192,
    "additions": 36,
    "deletions": 156
  },
  "files": [
    {
      "sha": "3a6d3c6f612f671254c41214cb0e9e5fa99a7f3b",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 36,
      "deletions": 156,
      "changes": 192,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c7fdac09d919aaf86d302e6c622de6ee000c1b7c/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c7fdac09d919aaf86d302e6c622de6ee000c1b7c/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=c7fdac09d919aaf86d302e6c622de6ee000c1b7c",
      "patch": "@@ -101,7 +101,6 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n     : Sized_relobj_file<size, big_endian>(name, input_file, offset, ehdr),\n       uniq_(object_id++), special_(0), relatoc_(0), toc_(0),\n       has_small_toc_reloc_(false), opd_valid_(false),\n-      no_tls_marker_(false), tls_marker_(false), tls_opt_error_(false),\n       e_flags_(ehdr.get_e_flags()), no_toc_opt_(), opd_ent_(),\n       access_from_map_(), has14_(), stub_table_index_(), st_other_(),\n       attributes_section_data_(NULL)\n@@ -162,30 +161,6 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n     return this->no_toc_opt_[off];\n   }\n \n-  void\n-  set_no_tls_marker()\n-  {\n-    if (!this->no_tls_marker_ && this->tls_marker_)\n-      this->tls_opt_error_ = true;\n-    this->no_tls_marker_ = true;\n-  }\n-\n-  bool\n-  no_tls_marker() const\n-  { return this->no_tls_marker_; }\n-\n-  void\n-  set_tls_marker()\n-  { this->tls_marker_ = true; }\n-\n-  bool\n-  tls_marker() const\n-  { return this->tls_marker_; }\n-\n-  bool\n-  tls_opt_error() const\n-  { return this->tls_opt_error_; }\n-\n   // The .got2 section shndx.\n   unsigned int\n   got2_shndx() const\n@@ -473,19 +448,6 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n   // access_from_map_.\n   bool opd_valid_;\n \n-  // Set when finding a __tls_get_addr call without marker relocs.\n-  // Such a call disables GD and LD tls optimisations for the object file.\n-  bool no_tls_marker_;\n-\n-  // Set when finding a __tls_get_addr call with marker relocs, or\n-  // when finding a relocation that needs __tls_get_addr calls with\n-  // marker relocs.\n-  bool tls_marker_;\n-\n-  // Set when seeing a __tls_get_addr call without marker relocs after\n-  // seeing some __tls_get_addr calls with marker relocs.\n-  bool tls_opt_error_;\n-\n   // Header e_flags\n   elfcpp::Elf_Word e_flags_;\n \n@@ -7911,42 +7873,23 @@ Target_powerpc<size, big_endian>::Scan::local(\n   Powerpc_relobj<size, big_endian>* ppc_object\n     = static_cast<Powerpc_relobj<size, big_endian>*>(object);\n \n-  switch (this->maybe_skip_tls_get_addr_call(target, r_type, NULL))\n-    {\n-    case Track_tls::NOT_EXPECTED:\n-      ppc_object->set_no_tls_marker();\n-      break;\n-    default:\n-      break;\n-    }\n+  this->maybe_skip_tls_get_addr_call(target, r_type, NULL);\n \n   if ((size == 64 && r_type == elfcpp::R_PPC64_TLSGD)\n       || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))\n     {\n       this->expect_tls_get_addr_call();\n-      if (!ppc_object->no_tls_marker())\n-\t{\n-\t  tls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n-\t  if (tls_type != tls::TLSOPT_NONE)\n-\t    {\n-\t      this->skip_next_tls_get_addr_call();\n-\t      ppc_object->set_tls_marker();\n-\t    }\n-\t}\n+      tls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n+      if (tls_type != tls::TLSOPT_NONE)\n+\tthis->skip_next_tls_get_addr_call();\n     }\n   else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)\n \t   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))\n     {\n       this->expect_tls_get_addr_call();\n-      if (!ppc_object->no_tls_marker())\n-\t{\n-\t  tls::Tls_optimization tls_type = target->optimize_tls_ld();\n-\t  if (tls_type != tls::TLSOPT_NONE)\n-\t    {\n-\t      this->skip_next_tls_get_addr_call();\n-\t      ppc_object->set_tls_marker();\n-\t    }\n-\t}\n+      tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+      if (tls_type != tls::TLSOPT_NONE)\n+\tthis->skip_next_tls_get_addr_call();\n     }\n \n   if (is_discarded)\n@@ -8248,9 +8191,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HA:\n       {\n-\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\tif (!ppc_object->no_tls_marker())\n-\t  tls_type = target->optimize_tls_gd(true);\n+\ttls::Tls_optimization tls_type = target->optimize_tls_gd(true);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    Got_type got_type = ((size == 32\n@@ -8268,7 +8209,6 @@ Target_powerpc<size, big_endian>::Scan::local(\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n \t  {\n \t    // no GOT relocs needed for Local Exec.\n-\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -8281,9 +8221,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HA:\n       {\n-\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\tif (!ppc_object->no_tls_marker())\n-\t  tls_type = target->optimize_tls_ld();\n+\ttls::Tls_optimization tls_type = target->optimize_tls_ld();\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  target->tlsld_got_offset(symtab, layout, object);\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n@@ -8295,7 +8233,6 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t\tgold_assert(os != NULL);\n \t\tos->set_needs_symtab_index();\n \t      }\n-\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -8638,9 +8575,6 @@ Target_powerpc<size, big_endian>::Scan::global(\n \n   switch (this->maybe_skip_tls_get_addr_call(target, r_type, gsym))\n     {\n-    case Track_tls::NOT_EXPECTED:\n-      ppc_object->set_no_tls_marker();\n-      break;\n     case Track_tls::SKIP:\n       return;\n     default:\n@@ -8656,30 +8590,18 @@ Target_powerpc<size, big_endian>::Scan::global(\n       || (size == 32 && r_type == elfcpp::R_PPC_TLSGD))\n     {\n       this->expect_tls_get_addr_call();\n-      if (!ppc_object->no_tls_marker())\n-\t{\n-\t  bool final = gsym->final_value_is_known();\n-\t  tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n-\t  if (tls_type != tls::TLSOPT_NONE)\n-\t    {\n-\t      this->skip_next_tls_get_addr_call();\n-\t      ppc_object->set_tls_marker();\n-\t    }\n-\t}\n+      bool final = gsym->final_value_is_known();\n+      tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n+      if (tls_type != tls::TLSOPT_NONE)\n+\tthis->skip_next_tls_get_addr_call();\n     }\n   else if ((size == 64 && r_type == elfcpp::R_PPC64_TLSLD)\n \t   || (size == 32 && r_type == elfcpp::R_PPC_TLSLD))\n     {\n       this->expect_tls_get_addr_call();\n-      if (!ppc_object->no_tls_marker())\n-\t{\n-\t  tls::Tls_optimization tls_type = target->optimize_tls_ld();\n-\t  if (tls_type != tls::TLSOPT_NONE)\n-\t    {\n-\t      this->skip_next_tls_get_addr_call();\n-\t      ppc_object->set_tls_marker();\n-\t    }\n-\t}\n+      tls::Tls_optimization tls_type = target->optimize_tls_ld();\n+      if (tls_type != tls::TLSOPT_NONE)\n+\tthis->skip_next_tls_get_addr_call();\n     }\n \n   // A STT_GNU_IFUNC symbol may require a PLT entry.\n@@ -9061,12 +8983,8 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSGD16_HA:\n       {\n-\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\tif (!ppc_object->no_tls_marker())\n-\t  {\n-\t    bool final = gsym->final_value_is_known();\n-\t    tls_type = target->optimize_tls_gd(final);\n-\t  }\n+\tbool final = gsym->final_value_is_known();\n+\ttls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n \t    Got_type got_type = ((size == 32\n@@ -9107,12 +9025,10 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\t\t\t\t\t\t   got, off, addend);\n \t\t  }\n \t      }\n-\t    ppc_object->set_tls_marker();\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n \t  {\n \t    // no GOT relocs needed for Local Exec.\n-\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -9125,9 +9041,7 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HI:\n     case elfcpp::R_POWERPC_GOT_TLSLD16_HA:\n       {\n-\ttls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\tif (!ppc_object->no_tls_marker())\n-\t  tls_type = target->optimize_tls_ld();\n+\ttls::Tls_optimization tls_type = target->optimize_tls_ld();\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  target->tlsld_got_offset(symtab, layout, object);\n \telse if (tls_type == tls::TLSOPT_TO_LE)\n@@ -9139,7 +9053,6 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t\tgold_assert(os != NULL);\n \t\tos->set_needs_symtab_index();\n \t      }\n-\t    ppc_object->set_tls_marker();\n \t  }\n \telse\n \t  gold_unreachable();\n@@ -10515,20 +10428,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n   switch (this->maybe_skip_tls_get_addr_call(target, r_type, gsym))\n     {\n     case Track_tls::NOT_EXPECTED:\n-      if (!parameters->options().shared()\n-\t  && parameters->options().tls_optimize())\n-\t{\n-\t  // It is a hard error to see a __tls_get_addr call without\n-\t  // marker relocs after seeing calls with marker relocs in the\n-\t  // same object file, because dynamic relocation accounting\n-\t  // will be wrong.\n-\t  if (object->tls_opt_error())\n-\t    gold_error_at_location(relinfo, relnum, rela.get_r_offset(),\n-\t\t\t\t   _(\"__tls_get_addr call lacks marker reloc\"));\n-\t  else\n-\t    gold_warning_at_location(relinfo, relnum, rela.get_r_offset(),\n-\t\t\t\t     _(\"__tls_get_addr call lacks marker reloc\"));\n-\t}\n+      // No warning.  This will result in really old code without tls\n+      // marker relocs being mis-optimised, but there shouldn't be too\n+      // much of that code around.  The problem with warning is that\n+      // glibc and libphobos both construct direct calls to\n+      // __tls_get_addr in a way that is harmless.\n       break;\n     case Track_tls::EXPECTED:\n       // We have already complained.\n@@ -10807,12 +10711,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t   || r_type == elfcpp::R_PPC64_GOT_TLSGD_PCREL34)\n     {\n       // First instruction of a global dynamic sequence, arg setup insn.\n-      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-      if (!object->no_tls_marker())\n-\t{\n-\t  bool final = gsym == NULL || gsym->final_value_is_known();\n-\t  tls_type = target->optimize_tls_gd(final);\n-\t}\n+      bool final = gsym == NULL || gsym->final_value_is_known();\n+      tls::Tls_optimization tls_type = target->optimize_tls_gd(final);\n       Got_type got_type = ((size == 32\n \t\t\t    || r_type == elfcpp::R_POWERPC_GOT_TLSGD16)\n \t\t\t   ? GOT_TYPE_SMALL : GOT_TYPE_STANDARD);\n@@ -10914,9 +10814,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t   || r_type == elfcpp::R_PPC64_GOT_TLSLD_PCREL34)\n     {\n       // First instruction of a local dynamic sequence, arg setup insn.\n-      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-      if (!object->no_tls_marker())\n-\ttls_type = target->optimize_tls_ld();\n+      tls::Tls_optimization tls_type = target->optimize_tls_ld();\n       if (tls_type == tls::TLSOPT_NONE)\n \t{\n \t  value = target->tlsld_got_offset();\n@@ -11057,12 +10955,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       // Second instruction of a global dynamic sequence,\n       // the __tls_get_addr call\n       this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());\n-      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-      if (!object->no_tls_marker())\n-\t{\n-\t  bool final = gsym == NULL || gsym->final_value_is_known();\n-\t  tls_type = target->optimize_tls_gd(final);\n-\t}\n+      bool final = gsym == NULL || gsym->final_value_is_known();\n+      tls::Tls_optimization tls_type =  target->optimize_tls_gd(final);\n       if (tls_type != tls::TLSOPT_NONE)\n \t{\n \t  if (tls_type == tls::TLSOPT_TO_IE)\n@@ -11113,9 +11007,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       // Second instruction of a local dynamic sequence,\n       // the __tls_get_addr call\n       this->expect_tls_get_addr_call(relinfo, relnum, rela.get_r_offset());\n-      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-      if (!object->no_tls_marker())\n-\ttls_type = target->optimize_tls_ld();\n+      tls::Tls_optimization tls_type = target->optimize_tls_ld();\n       if (tls_type == tls::TLSOPT_TO_LE)\n \t{\n \t  bool is_pcrel = false;\n@@ -12605,12 +12497,8 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // First instruction of a global dynamic sequence,\n \t      // arg setup insn.\n-\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\t      if (!object->no_tls_marker())\n-\t\t{\n-\t\t  bool final = gsym == NULL || gsym->final_value_is_known();\n-\t\t  tls_type = this->optimize_tls_gd(final);\n-\t\t}\n+\t      bool final = gsym == NULL || gsym->final_value_is_known();\n+\t      tls::Tls_optimization tls_type = this->optimize_tls_gd(final);\n \t      switch (tls_type)\n \t\t{\n \t\tcase tls::TLSOPT_TO_IE:\n@@ -12638,9 +12526,7 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // First instruction of a local dynamic sequence,\n \t      // arg setup insn.\n-\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\t      if (!object->no_tls_marker())\n-\t\ttls_type = this->optimize_tls_ld();\n+\t      tls::Tls_optimization tls_type = this->optimize_tls_ld();\n \t      if (tls_type == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  if (r_type == elfcpp::R_POWERPC_GOT_TLSLD16\n@@ -12685,12 +12571,8 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // Second instruction of a global dynamic sequence,\n \t      // the __tls_get_addr call\n-\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\t      if (!object->no_tls_marker())\n-\t\t{\n-\t\t  bool final = gsym == NULL || gsym->final_value_is_known();\n-\t\t  tls_type = this->optimize_tls_gd(final);\n-\t\t}\n+\t      bool final = gsym == NULL || gsym->final_value_is_known();\n+\t      tls::Tls_optimization tls_type = this->optimize_tls_gd(final);\n \t      switch (tls_type)\n \t\t{\n \t\tcase tls::TLSOPT_TO_IE:\n@@ -12711,9 +12593,7 @@ Target_powerpc<size, big_endian>::relocate_relocs(\n \t    {\n \t      // Second instruction of a local dynamic sequence,\n \t      // the __tls_get_addr call\n-\t      tls::Tls_optimization tls_type = tls::TLSOPT_NONE;\n-\t      if (!object->no_tls_marker())\n-\t\ttls_type = this->optimize_tls_ld();\n+\t      tls::Tls_optimization tls_type = this->optimize_tls_ld();\n \t      if (tls_type == tls::TLSOPT_TO_LE)\n \t\t{\n \t\t  const Output_section* os = relinfo->layout->tls_segment()"
    }
  ]
}