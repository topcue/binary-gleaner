{
  "sha": "470c0b1c9a1d69e3c4f9281600399b1dadd40614",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDcwYzBiMWM5YTFkNjllM2M0ZjkyODE2MDAzOTliMWRhZGQ0MDYxNA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-10-10T09:48:01Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-11-27T12:01:47Z"
    },
    "message": "gdb: Introduce global_symbol_searcher\n\nIntroduce a new class to wrap up the parameters needed for the\nfunction search_symbols, which has now become a member function of\nthis new class.\n\nThe motivation is that search_symbols already takes a lot of\nparameters, and a future commit is going to add even more.  This\ncommit hopefully makes collecting the state required for a search\neasier.\n\nAs part of this conversion the list of filenames in which to search\nhas been converted to a std::vector.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* python/python.c (gdbpy_rbreak): Convert to using\n\tglobal_symbol_searcher.\n\t* symtab.c (file_matches): Convert return type to bool, change\n\tfile list to std::vector, update header comment.\n\t(search_symbols): Rename to...\n\t(global_symbol_searcher::search): ...this and update now its\n\ta member function of global_symbol_searcher.  Take account of the\n\tchanges to file_matches.\n\t(symtab_symbol_info): Convert to using global_symbol_searcher.\n\t(rbreak_command): Likewise.\n\t(search_module_symbols): Likewise.\n\t* symtab.h (enum symbol_search): Update comment.\n\t(search_symbols): Remove declaration.\n\t(class global_symbol_searcher): New class.\n\nChange-Id: I488ab292a892d9e9e84775c632c5f198b6ad3710",
    "tree": {
      "sha": "f4921dd9501d85702a5d164d042e874a25f49c73",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f4921dd9501d85702a5d164d042e874a25f49c73"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/470c0b1c9a1d69e3c4f9281600399b1dadd40614",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/470c0b1c9a1d69e3c4f9281600399b1dadd40614",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/470c0b1c9a1d69e3c4f9281600399b1dadd40614",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/470c0b1c9a1d69e3c4f9281600399b1dadd40614/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7f3bf38453acbabf7286dd7f8ce2688282e7b9cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f3bf38453acbabf7286dd7f8ce2688282e7b9cd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7f3bf38453acbabf7286dd7f8ce2688282e7b9cd"
    }
  ],
  "stats": {
    "total": 289,
    "additions": 161,
    "deletions": 128
  },
  "files": [
    {
      "sha": "56536c459ee559d4abe37523a749ea7bf57af9e1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=470c0b1c9a1d69e3c4f9281600399b1dadd40614",
      "patch": "@@ -1,3 +1,20 @@\n+2019-11-27  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* python/python.c (gdbpy_rbreak): Convert to using\n+\tglobal_symbol_searcher.\n+\t* symtab.c (file_matches): Convert return type to bool, change\n+\tfile list to std::vector, update header comment.\n+\t(search_symbols): Rename to...\n+\t(global_symbol_searcher::search): ...this and update now its\n+\ta member function of global_symbol_searcher.  Take account of the\n+\tchanges to file_matches.\n+\t(symtab_symbol_info): Convert to using global_symbol_searcher.\n+\t(rbreak_command): Likewise.\n+\t(search_module_symbols): Likewise.\n+\t* symtab.h (enum symbol_search): Update comment.\n+\t(search_symbols): Remove declaration.\n+\t(class global_symbol_searcher): New class.\n+\n 2019-11-26  Tom Tromey  <tromey@adacore.com>\n \n \t* cp-support.c (_initialize_cp_support): Conditionally initialize"
    },
    {
      "sha": "fad54e9cdb0592550ce762ebc7cd2df2337ccf15",
      "filename": "gdb/python/python.c",
      "status": "modified",
      "additions": 10,
      "deletions": 25,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/python/python.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/python/python.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/python.c?ref=470c0b1c9a1d69e3c4f9281600399b1dadd40614",
      "patch": "@@ -644,19 +644,6 @@ execute_gdb_command (PyObject *self, PyObject *args, PyObject *kw)\n static PyObject *\n gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)\n {\n-  /* A simple type to ensure clean up of a vector of allocated strings\n-     when a C interface demands a const char *array[] type\n-     interface.  */\n-  struct symtab_list_type\n-  {\n-    ~symtab_list_type ()\n-    {\n-      for (const char *elem: vec)\n-\txfree ((void *) elem);\n-    }\n-    std::vector<const char *> vec;\n-  };\n-\n   char *regex = NULL;\n   std::vector<symbol_search> symbols;\n   unsigned long count = 0;\n@@ -666,7 +653,6 @@ gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)\n   unsigned int throttle = 0;\n   static const char *keywords[] = {\"regex\",\"minsyms\", \"throttle\",\n \t\t\t\t   \"symtabs\", NULL};\n-  symtab_list_type symtab_paths;\n \n   if (!gdb_PyArg_ParseTupleAndKeywords (args, kw, \"s|O!IO\", keywords,\n \t\t\t\t\t&regex, &PyBool_Type,\n@@ -683,6 +669,12 @@ gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)\n       minsyms_p = cmp;\n     }\n \n+  global_symbol_searcher spec (FUNCTIONS_DOMAIN, regex);\n+  SCOPE_EXIT {\n+    for (const char *elem : spec.filenames)\n+      xfree ((void *) elem);\n+  };\n+\n   /* The \"symtabs\" keyword is any Python iterable object that returns\n      a gdb.Symtab on each iteration.  If specified, iterate through\n      the provided gdb.Symtabs and extract their full path.  As\n@@ -728,20 +720,13 @@ gdbpy_rbreak (PyObject *self, PyObject *args, PyObject *kw)\n \n \t  /* Make sure there is a definite place to store the value of\n \t     filename before it is released.  */\n-\t  symtab_paths.vec.push_back (nullptr);\n-\t  symtab_paths.vec.back () = filename.release ();\n+\t  spec.filenames.push_back (nullptr);\n+\t  spec.filenames.back () = filename.release ();\n \t}\n     }\n \n-  if (symtab_list)\n-    {\n-      const char **files = symtab_paths.vec.data ();\n-\n-      symbols = search_symbols (regex, FUNCTIONS_DOMAIN, NULL,\n-\t\t\t\tsymtab_paths.vec.size (), files, false);\n-    }\n-  else\n-    symbols = search_symbols (regex, FUNCTIONS_DOMAIN, NULL, 0, NULL, false);\n+  /* The search spec.  */\n+  symbols = spec.search ();\n \n   /* Count the number of symbols (both symbols and optionally minimal\n      symbols) so we can correctly check the throttle limit.  */"
    },
    {
      "sha": "e5ed42a49b6d35b7e9d027fb1f75151b1de4d47d",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 69,
      "deletions": 92,
      "changes": 161,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=470c0b1c9a1d69e3c4f9281600399b1dadd40614",
      "patch": "@@ -4347,27 +4347,24 @@ info_sources_command (const char *args, int from_tty)\n   printf_filtered (\"\\n\");\n }\n \n-/* Compare FILE against all the NFILES entries of FILES.  If BASENAMES is\n-   non-zero compare only lbasename of FILES.  */\n+/* Compare FILE against all the entries of FILENAMES.  If BASENAMES is\n+   true compare only lbasename of FILENAMES.  */\n \n-static int\n-file_matches (const char *file, const char *files[], int nfiles, int basenames)\n+static bool\n+file_matches (const char *file, const std::vector<const char *> &filenames,\n+\t      bool basenames)\n {\n-  int i;\n+  if (filenames.empty ())\n+    return true;\n \n-  if (file != NULL && nfiles != 0)\n+  for (const char *name : filenames)\n     {\n-      for (i = 0; i < nfiles; i++)\n-\t{\n-\t  if (compare_filenames_for_search (file, (basenames\n-\t\t\t\t\t\t   ? lbasename (files[i])\n-\t\t\t\t\t\t   : files[i])))\n-\t    return 1;\n-\t}\n+      name = (basenames ? lbasename (name) : name);\n+      if (compare_filenames_for_search (file, name))\n+\treturn true;\n     }\n-  else if (nfiles == 0)\n-    return 1;\n-  return 0;\n+\n+  return false;\n }\n \n /* Helper function for sort_search_symbols_remove_dups and qsort.  Can only\n@@ -4443,30 +4440,10 @@ sort_search_symbols_remove_dups (std::vector<symbol_search> *result)\n \t\t result->end ());\n }\n \n-/* Search the symbol table for matches to the regular expression REGEXP,\n-   returning the results.\n-\n-   Only symbols of KIND are searched:\n-   VARIABLES_DOMAIN - search all symbols, excluding functions, type names,\n-                      and constants (enums).\n-\t\t      if T_REGEXP is not NULL, only returns var that have\n-\t\t      a type matching regular expression T_REGEXP.\n-   FUNCTIONS_DOMAIN - search all functions\n-   TYPES_DOMAIN     - search all type names\n-   ALL_DOMAIN       - an internal error for this function\n-\n-   Within each file the results are sorted locally; each symtab's global and\n-   static blocks are separately alphabetized.\n-   Duplicate entries are removed.\n-\n-   When EXCLUDE_MINSYMS is false then matching minsyms are also returned,\n-   otherwise they are excluded.  */\n+/* See symtab.h.  */\n \n std::vector<symbol_search>\n-search_symbols (const char *regexp, enum search_domain kind,\n-\t\tconst char *t_regexp,\n-\t\tint nfiles, const char *files[],\n-\t\tbool exclude_minsyms)\n+global_symbol_searcher::search () const\n {\n   const struct blockvector *bv;\n   const struct block *b;\n@@ -4490,21 +4467,23 @@ search_symbols (const char *regexp, enum search_domain kind,\n   gdb::optional<compiled_regex> preg;\n   gdb::optional<compiled_regex> treg;\n \n-  gdb_assert (kind != ALL_DOMAIN);\n+  gdb_assert (m_kind != ALL_DOMAIN);\n \n-  ourtype = types[kind];\n-  ourtype2 = types2[kind];\n-  ourtype3 = types3[kind];\n-  ourtype4 = types4[kind];\n+  ourtype = types[m_kind];\n+  ourtype2 = types2[m_kind];\n+  ourtype3 = types3[m_kind];\n+  ourtype4 = types4[m_kind];\n \n-  if (regexp != NULL)\n+  if (m_symbol_name_regexp != NULL)\n     {\n+      const char *symbol_name_regexp = m_symbol_name_regexp;\n+\n       /* Make sure spacing is right for C++ operators.\n          This is just a courtesy to make the matching less sensitive\n          to how many spaces the user leaves between 'operator'\n          and <TYPENAME> or <OPERATOR>.  */\n       const char *opend;\n-      const char *opname = operator_chars (regexp, &opend);\n+      const char *opname = operator_chars (symbol_name_regexp, &opend);\n \n       if (*opname)\n \t{\n@@ -4529,28 +4508,30 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t      char *tmp = (char *) alloca (8 + fix + strlen (opname) + 1);\n \n \t      sprintf (tmp, \"operator%.*s%s\", fix, \" \", opname);\n-\t      regexp = tmp;\n+\t      symbol_name_regexp = tmp;\n \t    }\n \t}\n \n       int cflags = REG_NOSUB | (case_sensitivity == case_sensitive_off\n \t\t\t\t? REG_ICASE : 0);\n-      preg.emplace (regexp, cflags, _(\"Invalid regexp\"));\n+      preg.emplace (symbol_name_regexp, cflags,\n+\t\t    _(\"Invalid regexp\"));\n     }\n \n-  if (t_regexp != NULL)\n+  if (m_symbol_type_regexp != NULL)\n     {\n       int cflags = REG_NOSUB | (case_sensitivity == case_sensitive_off\n \t\t\t\t? REG_ICASE : 0);\n-      treg.emplace (t_regexp, cflags, _(\"Invalid regexp\"));\n+      treg.emplace (m_symbol_type_regexp, cflags,\n+\t\t    _(\"Invalid regexp\"));\n     }\n \n-  /* Search through the partial symtabs *first* for all symbols\n-     matching the regexp.  That way we don't have to reproduce all of\n-     the machinery below.  */\n+  /* Search through the partial symtabs *first* for all symbols matching\n+     the m_symbol_name_regexp (in preg).  That way we don't have to\n+     reproduce all of the machinery below.  */\n   expand_symtabs_matching ([&] (const char *filename, bool basenames)\n \t\t\t   {\n-\t\t\t     return file_matches (filename, files, nfiles,\n+\t\t\t     return file_matches (filename, filenames,\n \t\t\t\t\t\t  basenames);\n \t\t\t   },\n \t\t\t   lookup_name_info::match_any (),\n@@ -4561,7 +4542,7 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t\t\t\t\t    0, NULL, 0) == 0);\n \t\t\t   },\n \t\t\t   NULL,\n-\t\t\t   kind);\n+\t\t\t   m_kind);\n \n   /* Here, we search through the minimal symbol tables for functions\n      and variables that match, and force their symbols to be read.\n@@ -4579,7 +4560,8 @@ search_symbols (const char *regexp, enum search_domain kind,\n      all objfiles.  In large programs (1000s of shared libs) searching all\n      objfiles is not worth the pain.  */\n \n-  if (nfiles == 0 && (kind == VARIABLES_DOMAIN || kind == FUNCTIONS_DOMAIN))\n+  if (filenames.empty () && (m_kind == VARIABLES_DOMAIN\n+\t\t\t     || m_kind == FUNCTIONS_DOMAIN))\n     {\n       for (objfile *objfile : current_program_space->objfiles ())\n \t{\n@@ -4603,7 +4585,7 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t\t lookup functions is to expand the symbol\n \t\t\t table if msymbol is found, for the benefit of\n \t\t\t the next loop on compunits.  */\n-\t\t      if (kind == FUNCTIONS_DOMAIN\n+\t\t      if (m_kind == FUNCTIONS_DOMAIN\n \t\t\t  ? (find_pc_compunit_symtab\n \t\t\t     (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n \t\t\t     == NULL)\n@@ -4634,16 +4616,16 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t  /* Check first sole REAL_SYMTAB->FILENAME.  It does\n \t\t     not need to be a substring of symtab_to_fullname as\n \t\t     it may contain \"./\" etc.  */\n-\t\t  if ((file_matches (real_symtab->filename, files, nfiles, 0)\n+\t\t  if ((file_matches (real_symtab->filename, filenames, false)\n \t\t       || ((basenames_may_differ\n \t\t\t    || file_matches (lbasename (real_symtab->filename),\n-\t\t\t\t\t     files, nfiles, 1))\n+\t\t\t\t\t     filenames, true))\n \t\t\t   && file_matches (symtab_to_fullname (real_symtab),\n-\t\t\t\t\t    files, nfiles, 0)))\n+\t\t\t\t\t    filenames, false)))\n \t\t      && ((!preg.has_value ()\n \t\t\t   || preg->exec (sym->natural_name (), 0,\n \t\t\t\t\t  NULL, 0) == 0)\n-\t\t\t  && ((kind == VARIABLES_DOMAIN\n+\t\t\t  && ((m_kind == VARIABLES_DOMAIN\n \t\t\t       && SYMBOL_CLASS (sym) != LOC_TYPEDEF\n \t\t\t       && SYMBOL_CLASS (sym) != LOC_UNRESOLVED\n \t\t\t       && SYMBOL_CLASS (sym) != LOC_BLOCK\n@@ -4656,15 +4638,15 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t\t\t\t== TYPE_CODE_ENUM))\n \t\t\t       && (!treg.has_value ()\n \t\t\t\t   || treg_matches_sym_type_name (*treg, sym)))\n-\t\t\t      || (kind == FUNCTIONS_DOMAIN\n+\t\t\t      || (m_kind == FUNCTIONS_DOMAIN\n \t\t\t\t  && SYMBOL_CLASS (sym) == LOC_BLOCK\n \t\t\t\t  && (!treg.has_value ()\n \t\t\t\t      || treg_matches_sym_type_name (*treg,\n \t\t\t\t\t\t\t\t     sym)))\n-\t\t\t      || (kind == TYPES_DOMAIN\n+\t\t\t      || (m_kind == TYPES_DOMAIN\n \t\t\t\t  && SYMBOL_CLASS (sym) == LOC_TYPEDEF\n \t\t\t\t  && SYMBOL_DOMAIN (sym) != MODULE_DOMAIN)\n-\t\t\t      || (kind == MODULES_DOMAIN\n+\t\t\t      || (m_kind == MODULES_DOMAIN\n \t\t\t\t  && SYMBOL_DOMAIN (sym) == MODULE_DOMAIN\n \t\t\t\t  && SYMBOL_LINE (sym) != 0))))\n \t\t    {\n@@ -4679,13 +4661,13 @@ search_symbols (const char *regexp, enum search_domain kind,\n   if (!result.empty ())\n     sort_search_symbols_remove_dups (&result);\n \n-  /* If there are no eyes, avoid all contact.  I mean, if there are\n-     no debug symbols, then add matching minsyms.  But if the user wants\n-     to see symbols matching a type regexp, then never give a minimal symbol,\n-     as we assume that a minimal symbol does not have a type.  */\n+  /* If there are no debug symbols, then add matching minsyms.  But if the\n+     user wants to see symbols matching a type m_symbol_type_regexp, then\n+     never give a minimal symbol, as we assume that a minimal symbol does\n+     not have a type.  */\n \n-  if ((found_misc || (nfiles == 0 && kind != FUNCTIONS_DOMAIN))\n-      && !exclude_minsyms\n+  if ((found_misc || (filenames.empty () && m_kind != FUNCTIONS_DOMAIN))\n+      && !m_exclude_minsyms\n       && !treg.has_value ())\n     {\n       for (objfile *objfile : current_program_space->objfiles ())\n@@ -4708,7 +4690,7 @@ search_symbols (const char *regexp, enum search_domain kind,\n \t\t    {\n \t\t      /* For functions we can do a quick check of whether the\n \t\t\t symbol might be found via find_pc_symtab.  */\n-\t\t      if (kind != FUNCTIONS_DOMAIN\n+\t\t      if (m_kind != FUNCTIONS_DOMAIN\n \t\t\t  || (find_pc_compunit_symtab\n \t\t\t      (MSYMBOL_VALUE_ADDRESS (objfile, msymbol))\n \t\t\t      == NULL))\n@@ -4847,10 +4829,10 @@ symtab_symbol_info (bool quiet, bool exclude_minsyms,\n   if (regexp != nullptr && *regexp == '\\0')\n     regexp = nullptr;\n \n-  /* Must make sure that if we're interrupted, symbols gets freed.  */\n-  std::vector<symbol_search> symbols = search_symbols (regexp, kind,\n-\t\t\t\t\t\t       t_regexp, 0, NULL,\n-\t\t\t\t\t\t       exclude_minsyms);\n+  global_symbol_searcher spec (kind, regexp);\n+  spec.set_symbol_type_regexp (t_regexp);\n+  spec.set_exclude_minsyms (exclude_minsyms);\n+  std::vector<symbol_search> symbols = spec.search ();\n \n   if (!quiet)\n     {\n@@ -5081,11 +5063,9 @@ static void\n rbreak_command (const char *regexp, int from_tty)\n {\n   std::string string;\n-  const char **files = NULL;\n-  const char *file_name;\n-  int nfiles = 0;\n+  const char *file_name = nullptr;\n \n-  if (regexp)\n+  if (regexp != nullptr)\n     {\n       const char *colon = strchr (regexp, ':');\n \n@@ -5101,17 +5081,14 @@ rbreak_command (const char *regexp, int from_tty)\n \t  while (isspace (local_name[colon_index]))\n \t    local_name[colon_index--] = 0;\n \t  file_name = local_name;\n-\t  files = &file_name;\n-\t  nfiles = 1;\n \t  regexp = skip_spaces (colon + 1);\n \t}\n     }\n \n-  std::vector<symbol_search> symbols = search_symbols (regexp,\n-\t\t\t\t\t\t       FUNCTIONS_DOMAIN,\n-\t\t\t\t\t\t       NULL,\n-\t\t\t\t\t\t       nfiles, files,\n-\t\t\t\t\t\t       false);\n+  global_symbol_searcher spec (FUNCTIONS_DOMAIN, regexp);\n+  if (file_name != nullptr)\n+    spec.filenames.push_back (file_name);\n+  std::vector<symbol_search> symbols = spec.search ();\n \n   scoped_rbreak_breakpoints finalize;\n   for (const symbol_search &p : symbols)\n@@ -6345,17 +6322,17 @@ search_module_symbols (const char *module_regexp, const char *regexp,\n   std::vector<module_symbol_search> results;\n \n   /* Search for all modules matching MODULE_REGEXP.  */\n-  std::vector<symbol_search> modules = search_symbols (module_regexp,\n-\t\t\t\t\t\t       MODULES_DOMAIN,\n-\t\t\t\t\t\t       NULL, 0, NULL,\n-\t\t\t\t\t\t       true);\n+  global_symbol_searcher spec1 (MODULES_DOMAIN, module_regexp);\n+  spec1.set_exclude_minsyms (true);\n+  std::vector<symbol_search> modules = spec1.search ();\n \n   /* Now search for all symbols of the required KIND matching the required\n      regular expressions.  We figure out which ones are in which modules\n      below.  */\n-  std::vector<symbol_search> symbols = search_symbols (regexp, kind,\n-\t\t\t\t\t\t       type_regexp, 0,\n-\t\t\t\t\t\t       NULL, true);\n+  global_symbol_searcher spec2 (kind, regexp);\n+  spec2.set_symbol_type_regexp (type_regexp);\n+  spec2.set_exclude_minsyms (true);\n+  std::vector<symbol_search> symbols = spec2.search ();\n \n   /* Now iterate over all MODULES, checking to see which items from\n      SYMBOLS are in each module.  */"
    },
    {
      "sha": "680c334086b7f0435357ec4fd3e3f3c43e307283",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 65,
      "deletions": 11,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/470c0b1c9a1d69e3c4f9281600399b1dadd40614/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=470c0b1c9a1d69e3c4f9281600399b1dadd40614",
      "patch": "@@ -797,7 +797,7 @@ gdb_static_assert (NR_DOMAINS <= (1 << SYMBOL_DOMAIN_BITS));\n \n extern const char *domain_name (domain_enum);\n \n-/* Searching domains, used for `search_symbols'.  Element numbers are\n+/* Searching domains, used when searching for symbols.  Element numbers are\n    hardcoded in GDB, check all enum uses before changing it.  */\n \n enum search_domain\n@@ -2011,11 +2011,9 @@ extern struct symbol *fixup_symbol_section (struct symbol *,\n extern symbol *find_function_alias_target (bound_minimal_symbol msymbol);\n \n /* Symbol searching */\n-/* Note: struct symbol_search, search_symbols, et.al. are declared here,\n-   instead of making them local to symtab.c, for gdbtk's sake.  */\n \n-/* When using search_symbols, a vector of the following structs is\n-   returned.  */\n+/* When using the symbol_searcher struct to search for symbols, a vector of\n+   the following structs is returned.  */\n struct symbol_search\n {\n   symbol_search (int block_, struct symbol *symbol_)\n@@ -2064,12 +2062,68 @@ struct symbol_search\n \t\t\t\t  const symbol_search &sym_b);\n };\n \n-extern std::vector<symbol_search> search_symbols (const char *,\n-\t\t\t\t\t\t  enum search_domain,\n-\t\t\t\t\t\t  const char *,\n-\t\t\t\t\t\t  int,\n-\t\t\t\t\t\t  const char **,\n-\t\t\t\t\t\t  bool);\n+/* In order to search for global symbols of a particular kind matching\n+   particular regular expressions, create an instance of this structure and\n+   call the SEARCH member function.  */\n+class global_symbol_searcher\n+{\n+public:\n+\n+  /* Constructor.  */\n+  global_symbol_searcher (enum search_domain kind,\n+\t\t\t  const char *symbol_name_regexp)\n+    : m_kind (kind),\n+      m_symbol_name_regexp (symbol_name_regexp)\n+  {\n+    /* The symbol searching is designed to only find one kind of thing.  */\n+    gdb_assert (m_kind != ALL_DOMAIN);\n+  }\n+\n+  /* Set the optional regexp that matches against the symbol type.  */\n+  void set_symbol_type_regexp (const char *regexp)\n+  {\n+    m_symbol_type_regexp = regexp;\n+  }\n+\n+  /* Set the flag to exclude minsyms from the search results.  */\n+  void set_exclude_minsyms (bool exclude_minsyms)\n+  {\n+    m_exclude_minsyms = exclude_minsyms;\n+  }\n+\n+  /* Search the symbols from all objfiles in the current program space\n+     looking for matches as defined by the current state of this object.\n+\n+     Within each file the results are sorted locally; each symtab's global\n+     and static blocks are separately alphabetized.  Duplicate entries are\n+     removed.  */\n+  std::vector<symbol_search> search () const;\n+\n+  /* The set of source files to search in for matching symbols.  This is\n+     currently public so that it can be populated after this object has\n+     been constructed.  */\n+  std::vector<const char *> filenames;\n+\n+private:\n+  /* The kind of symbols are we searching for.\n+     VARIABLES_DOMAIN - Search all symbols, excluding functions, type\n+                        names, and constants (enums).\n+     FUNCTIONS_DOMAIN - Search all functions..\n+     TYPES_DOMAIN     - Search all type names.\n+     MODULES_DOMAIN   - Search all Fortran modules.\n+     ALL_DOMAIN       - Not valid for this function.  */\n+  enum search_domain m_kind;\n+\n+  /* Regular expression to match against the symbol name.  */\n+  const char *m_symbol_name_regexp = nullptr;\n+\n+  /* Regular expression to match against the symbol type.  */\n+  const char *m_symbol_type_regexp = nullptr;\n+\n+  /* When this flag is false then minsyms that match M_SYMBOL_REGEXP will\n+     be included in the results, otherwise they are excluded.  */\n+  bool m_exclude_minsyms = false;\n+};\n \n /* When searching for Fortran symbols within modules (functions/variables)\n    we return a vector of this type.  The first item in the pair is the"
    }
  ]
}