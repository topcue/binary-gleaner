{
  "sha": "2361f1c85913a0ff0955069bf3182011765a8ae8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjM2MWYxYzg1OTEzYTBmZjA5NTUwNjliZjMxODIwMTE3NjVhOGFlOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-02T19:04:24Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:21Z"
    },
    "message": "libctf, create: support addition of references to the unimplemented type\n\nThe deduplicating linker adds types from the linker inputs to the output\nvia the same API everyone else does, so it's important that we can emit\neverything that the compiler wants us to.  Unfortunately, the compiler\nmay represent the unimplemented type (used for compiler constructs that\nCTF cannot currently encode) as type zero or as a type of kind\nCTF_K_UNKNOWN, and we don't allow the addition of types that cite the\nformer.\n\nAdding this support adds a tiny bit of extra complexity: additions of\nstructure members immediately following a member of the unimplemented\ntype must be via ctf_add_member_offset or ctf_add_member_encoded, since\nwe have no idea how big members of the unimplemented type are.\n(Attempts to do otherwise return -ECTF_NONREPRESENTABLE, like other\nattempts to do forbidden things with the unimplemented type.)\n\nEven slices of the unimplemented type are permitted: this is the only\ncase in which you can slice a type that terminates in a non-integral\ntype, on the grounds that it was likely integral in the source code,\nit's just that we can't represent that sort of integral type properly\nyet.\n\nlibctf/\n\t* ctf-create.c (ctf_add_reftype): Support refs to type zero.\n\t(ctf_add_array): Support array contents of type zero.\n\t(ctf_add_function): Support arguments and return types of\n\ttype zero.\n\t(ctf_add_typedef): Support typedefs to type zero.\n\t(ctf_add_member_offset): Support members of type zero,\n\tunless added at unspecified (naturally-aligned) offset.",
    "tree": {
      "sha": "b8a2204417f250c58c0e643e2eb8976ca9f7ee9d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b8a2204417f250c58c0e643e2eb8976ca9f7ee9d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2361f1c85913a0ff0955069bf3182011765a8ae8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2361f1c85913a0ff0955069bf3182011765a8ae8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2361f1c85913a0ff0955069bf3182011765a8ae8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2361f1c85913a0ff0955069bf3182011765a8ae8/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7eea9d3bdb037a3953101eccdb05826daf2da39a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7eea9d3bdb037a3953101eccdb05826daf2da39a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7eea9d3bdb037a3953101eccdb05826daf2da39a"
    }
  ],
  "stats": {
    "total": 52,
    "additions": 44,
    "deletions": 8
  },
  "files": [
    {
      "sha": "cca704a4ec231137144f7744b00477ae2be8b522",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2361f1c85913a0ff0955069bf3182011765a8ae8/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2361f1c85913a0ff0955069bf3182011765a8ae8/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=2361f1c85913a0ff0955069bf3182011765a8ae8",
      "patch": "@@ -1,3 +1,13 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-create.c (ctf_add_reftype): Support refs to type zero.\n+\t(ctf_add_array): Support array contents of type zero.\n+\t(ctf_add_function): Support arguments and return types of\n+\ttype zero.\n+\t(ctf_add_typedef): Support typedefs to type zero.\n+\t(ctf_add_member_offset): Support members of type zero,\n+\tunless added at unspecified (naturally-aligned) offset.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-error.c: Include <stddef.h>, for offsetof."
    },
    {
      "sha": "67a3f199a961f6882cee406796b91ef80cb6bda9",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 34,
      "deletions": 8,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2361f1c85913a0ff0955069bf3182011765a8ae8/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2361f1c85913a0ff0955069bf3182011765a8ae8/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=2361f1c85913a0ff0955069bf3182011765a8ae8",
      "patch": "@@ -900,7 +900,7 @@ ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n-  if (ctf_lookup_by_id (&tmp, ref) == NULL)\n+  if (ref != 0 && ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   if ((type = ctf_add_generic (fp, flag, NULL, kind, &dtd)) == CTF_ERR)\n@@ -957,12 +957,13 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n-  if ((tp = ctf_lookup_by_id (&tmp, ref)) == NULL)\n+  if (ref != 0 && ((tp = ctf_lookup_by_id (&tmp, ref)) == NULL))\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   kind = ctf_type_kind_unsliced (tmp, ref);\n   if ((kind != CTF_K_INTEGER) && (kind != CTF_K_FLOAT) &&\n-      (kind != CTF_K_ENUM))\n+      (kind != CTF_K_ENUM)\n+      && (ref != 0))\n     return (ctf_set_errno (fp, ECTF_NOTINTFP));\n \n   if ((type = ctf_add_generic (fp, flag, NULL, CTF_K_SLICE, &dtd)) == CTF_ERR)\n@@ -1008,7 +1009,8 @@ ctf_add_array (ctf_file_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n   if (arp == NULL)\n     return (ctf_set_errno (fp, EINVAL));\n \n-  if (ctf_lookup_by_id (&tmp, arp->ctr_contents) == NULL)\n+  if (arp->ctr_contents != 0\n+      && ctf_lookup_by_id (&tmp, arp->ctr_contents) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   tmp = fp;\n@@ -1062,13 +1064,14 @@ ctf_add_function (ctf_file_t *fp, uint32_t flag,\n   if (ctc->ctc_flags & CTF_FUNC_VARARG)\n     vlen++;\t       /* Add trailing zero to indicate varargs (see below).  */\n \n-  if (ctf_lookup_by_id (&tmp, ctc->ctc_return) == NULL)\n+  if (ctc->ctc_return != 0\n+      && ctf_lookup_by_id (&tmp, ctc->ctc_return) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   for (i = 0; i < ctc->ctc_argc; i++)\n     {\n       tmp = fp;\n-      if (ctf_lookup_by_id (&tmp, argv[i]) == NULL)\n+      if (argv[i] != 0 && ctf_lookup_by_id (&tmp, argv[i]) == NULL)\n \treturn CTF_ERR;\t\t/* errno is set for us.  */\n     }\n \n@@ -1259,7 +1262,7 @@ ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n \n-  if (ctf_lookup_by_id (&tmp, ref) == NULL)\n+  if (ref != 0 && ctf_lookup_by_id (&tmp, ref) == NULL)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n   if ((type = ctf_add_generic (fp, flag, name, CTF_K_TYPEDEF,\n@@ -1387,7 +1390,20 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n \n   if ((msize = ctf_type_size (fp, type)) < 0 ||\n       (malign = ctf_type_align (fp, type)) < 0)\n-    return -1;\t\t\t/* errno is set for us.  */\n+    {\n+      /* The unimplemented type, and any type that resolves to it, has no size\n+\t and no alignment: it can correspond to any number of compiler-inserted\n+\t types.  */\n+\n+      if (ctf_errno (fp) == ECTF_NONREPRESENTABLE)\n+\t{\n+\t  msize = 0;\n+\t  malign = 0;\n+\t  ctf_set_errno (fp, 0);\n+\t}\n+      else\n+\treturn -1;\t\t/* errno is set for us.  */\n+    }\n \n   if ((dmd = malloc (sizeof (ctf_dmdef_t))) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n@@ -1415,6 +1431,16 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n \t  ctf_encoding_t linfo;\n \t  ssize_t lsize;\n \n+\t  /* Propagate any error from ctf_type_resolve.  If the last member was\n+\t     of unimplemented type, this may be -ECTF_NONREPRESENTABLE: we\n+\t     cannot insert right after such a member without explicit offset\n+\t     specification, because its alignment and size is not known.  */\n+\t  if (ltype == CTF_ERR)\n+\t    {\n+\t      free (dmd);\n+\t      return -1;\t/* errno is set for us.  */\n+\t    }\n+\n \t  if (ctf_type_encoding (fp, ltype, &linfo) == 0)\n \t    off += linfo.cte_bits;\n \t  else if ((lsize = ctf_type_size (fp, ltype)) > 0)"
    }
  ]
}