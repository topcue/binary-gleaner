{
  "sha": "25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjU0MjgwNDAyMjliMTBmNWE4YTcxYmU1MWRmYzZlZTJmYzNmNDFiOQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-11-23T18:03:32Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-12-02T18:30:42Z"
    },
    "message": "gdb/riscv: rewrite target description validation, add rv32e support\n\nThis commit started as adding rv32e support to gdb.  The rv32e\narchitecture is a cut-down rv32i, it only has 16 x-registers compared\nto the usual 32, and an rv32e target should not have any floating\npoint registers.\n\nIn order to add this I needed to adjust the target description\nvalidation checks that are performed from riscv_gdbarch_init, and I\nfinally got fed up with the current scheme of doing these checks and\nrewrote this code.\n\nUnfortunately the rv32e changes are currently mixed in with the\nrewrite of the validation scheme.  I could split these apart if anyone\nis really interested in seeing these two ideas as separate patches.\n\nThe main idea behind this change is that where previously I tried to\nhave a purely data driven approach, a set of tables one for each\nexpected feature, and then a single generic function that would\nvalidate a feature given a table, I have created a new class for each\nfeature.  Each class has its own check member function which allows\nthe logic for how to check each feature to be different.  I think the\nnew scheme is much easier to follow.\n\nThere are some other changes that I made to the validation code as\npart of this commit.\n\nI've relaxed some of the checks related to the floating point CSRs.\nPreviously the 3 CSRs fflags, frm, and fcsr all had to be present in\neither the fpu feature or the csr feature.  This requirement is now\nrelaxed, if the CSRs are not present then gdb will not reject the\ntarget description.  My thinking here is that there's no gdb\nfunctionality that specifically requires these registers, and so, if a\ntarget offers a description without these registers nothing else in\ngdb should stop working.\n\nAnd as part of the rv32e support targets now only have to provide the\nfirst 16 x-registers and $pc.  The second half of the x-registers (x16\n-> x31) are now optional.\n\ngdb/ChangeLog:\n\n\t* arch/riscv.c: Include 'rv32e-xregs.c'.\n\t(riscv_create_target_description): Update to handle rv32e.\n\t* arch/riscv.h (struct riscv_gdbarch_features) <embedded>: New\n\tmember variable.\n\t<operator==>: Update to account for new field.\n\t<hash>: Likewise.\n\t* features/Makefile (FEATURE_XMLFILES): Add riscv/rv32e-xregs.xml.\n\t* features/riscv/rv32e-xregs.c: Generated.\n\t* features/riscv/rv32e-xregs.xml: New file.\n\t* riscv-tdep.c (riscv_debug_breakpoints): Move from later in the\n\tfile.\n\t(riscv_debug_infcall): Likewise.\n\t(riscv_debug_unwinder): Likewise.\n\t(riscv_debug_gdbarch): Likewise.\n\t(enum riscv_register_required_status): Delete.\n\t(struct riscv_register_feature): Add constructor, delete default\n\tconstructor, copy, and assign constructors.\n\t(struct riscv_register_feature::register_info) <required>: Delete.\n\t<check>: Update comment and arguments.\n\t(struct riscv_register_feature) <name>: Change to member function.\n\t<prefer_first_name>: Delete.\n\t<tdesc_feature>: New member function.\n\t<registers>: Rename to...\n\t<m_registers>: ...this.\n\t<m_feature_name>: New member variable.\n\t(riscv_register_feature::register_info::check): Update arguments.\n\t(riscv_xreg_feature): Rewrite as class, create a single static\n\tinstance of the class.\n\t(riscv_freg_feature): Likewise.\n\t(riscv_virtual_feature): Likewise.\n\t(riscv_csr_feature): Likewise.\n\t(riscv_create_csr_aliases): Has become a member function inside\n\triscv_csr_feature class.\n\t(riscv_abi_embedded): New function definition.\n\t(riscv_register_name): Adjust to use new feature objects.\n\t(struct riscv_call_info) <riscv_call_info>: Check for rv32e abi,\n\tand adjust available argument registers.\n\t(riscv_features_from_gdbarch_info): Check for EF_RISCV_RVE flag.\n\t(riscv_check_tdesc_feature): Delete.\n\t(riscv_tdesc_unknown_reg): Adjust to use new feature objects.\n\t(riscv_gdbarch_init): Delete target description checking code, and\n\tinstead call to the new feature objects to perform the checks.\n\tReorder handling of no abi information case, allows small code\n\tsimplification.\n\t(_initialize_riscv_tdep): Remove call, this is now done in the\n\triscv_csr_feature constructor.\n\t* riscv-tdep.h (riscv_abi_embedded): Declare.",
    "tree": {
      "sha": "46bdacdc7d2c7af58d4ea018a151b5c4cb5dd982",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/46bdacdc7d2c7af58d4ea018a151b5c4cb5dd982"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "533b2ae07d0437d0f9ae26f2067c1eab7999c5ba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/533b2ae07d0437d0f9ae26f2067c1eab7999c5ba",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/533b2ae07d0437d0f9ae26f2067c1eab7999c5ba"
    }
  ],
  "stats": {
    "total": 852,
    "additions": 533,
    "deletions": 319
  },
  "files": [
    {
      "sha": "7c0739368ec0c779a22af1d33b5dd5997dfe378b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -1,3 +1,53 @@\n+2020-12-02  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* arch/riscv.c: Include 'rv32e-xregs.c'.\n+\t(riscv_create_target_description): Update to handle rv32e.\n+\t* arch/riscv.h (struct riscv_gdbarch_features) <embedded>: New\n+\tmember variable.\n+\t<operator==>: Update to account for new field.\n+\t<hash>: Likewise.\n+\t* features/Makefile (FEATURE_XMLFILES): Add riscv/rv32e-xregs.xml.\n+\t* features/riscv/rv32e-xregs.c: Generated.\n+\t* features/riscv/rv32e-xregs.xml: New file.\n+\t* riscv-tdep.c (riscv_debug_breakpoints): Move from later in the\n+\tfile.\n+\t(riscv_debug_infcall): Likewise.\n+\t(riscv_debug_unwinder): Likewise.\n+\t(riscv_debug_gdbarch): Likewise.\n+\t(enum riscv_register_required_status): Delete.\n+\t(struct riscv_register_feature): Add constructor, delete default\n+\tconstructor, copy, and assign constructors.\n+\t(struct riscv_register_feature::register_info) <required>: Delete.\n+\t<check>: Update comment and arguments.\n+\t(struct riscv_register_feature) <name>: Change to member function.\n+\t<prefer_first_name>: Delete.\n+\t<tdesc_feature>: New member function.\n+\t<registers>: Rename to...\n+\t<m_registers>: ...this.\n+\t<m_feature_name>: New member variable.\n+\t(riscv_register_feature::register_info::check): Update arguments.\n+\t(riscv_xreg_feature): Rewrite as class, create a single static\n+\tinstance of the class.\n+\t(riscv_freg_feature): Likewise.\n+\t(riscv_virtual_feature): Likewise.\n+\t(riscv_csr_feature): Likewise.\n+\t(riscv_create_csr_aliases): Has become a member function inside\n+\triscv_csr_feature class.\n+\t(riscv_abi_embedded): New function definition.\n+\t(riscv_register_name): Adjust to use new feature objects.\n+\t(struct riscv_call_info) <riscv_call_info>: Check for rv32e abi,\n+\tand adjust available argument registers.\n+\t(riscv_features_from_gdbarch_info): Check for EF_RISCV_RVE flag.\n+\t(riscv_check_tdesc_feature): Delete.\n+\t(riscv_tdesc_unknown_reg): Adjust to use new feature objects.\n+\t(riscv_gdbarch_init): Delete target description checking code, and\n+\tinstead call to the new feature objects to perform the checks.\n+\tReorder handling of no abi information case, allows small code\n+\tsimplification.\n+\t(_initialize_riscv_tdep): Remove call, this is now done in the\n+\triscv_csr_feature constructor.\n+\t* riscv-tdep.h (riscv_abi_embedded): Declare.\n+\n 2020-12-02  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* riscv-tdep.c (riscv_create_csr_aliases): Remove use of"
    },
    {
      "sha": "64f394035c343d0d7a40afe8647f2147f31dc085",
      "filename": "gdb/arch/riscv.c",
      "status": "modified",
      "additions": 13,
      "deletions": 2,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/arch/riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/arch/riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/riscv.c?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -24,6 +24,7 @@\n #include \"../features/riscv/64bit-cpu.c\"\n #include \"../features/riscv/32bit-fpu.c\"\n #include \"../features/riscv/64bit-fpu.c\"\n+#include \"../features/riscv/rv32e-xregs.c\"\n \n #ifndef GDBSERVER\n #define STATIC_IN_GDB static\n@@ -43,7 +44,12 @@ riscv_create_target_description (const struct riscv_gdbarch_features features)\n   std::string arch_name = \"riscv\";\n \n   if (features.xlen == 4)\n-    arch_name.append (\":rv32i\");\n+    {\n+      if (features.embedded)\n+\tarch_name.append (\":rv32e\");\n+      else\n+\tarch_name.append (\":rv32i\");\n+    }\n   else if (features.xlen == 8)\n     arch_name.append (\":rv64i\");\n   else if (features.xlen == 16)\n@@ -63,7 +69,12 @@ riscv_create_target_description (const struct riscv_gdbarch_features features)\n \n   /* For now we only support creating 32-bit or 64-bit x-registers.  */\n   if (features.xlen == 4)\n-    regnum = create_feature_riscv_32bit_cpu (tdesc.get (), regnum);\n+    {\n+      if (features.embedded)\n+\tregnum = create_feature_riscv_rv32e_xregs (tdesc.get (), regnum);\n+      else\n+\tregnum = create_feature_riscv_32bit_cpu (tdesc.get (), regnum);\n+    }\n   else if (features.xlen == 8)\n     regnum = create_feature_riscv_64bit_cpu (tdesc.get (), regnum);\n "
    },
    {
      "sha": "f91c077a00124988b55f08b08711c7285ec65d64",
      "filename": "gdb/arch/riscv.h",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/arch/riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/arch/riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/riscv.h?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -46,10 +46,13 @@ struct riscv_gdbarch_features\n      that there are no f-registers.  No other value is valid.  */\n   int flen = 0;\n \n+  /* When true this target is RV32E.  */\n+  bool embedded = false;\n+\n   /* Equality operator.  */\n   bool operator== (const struct riscv_gdbarch_features &rhs) const\n   {\n-    return (xlen == rhs.xlen && flen == rhs.flen);\n+    return (xlen == rhs.xlen && flen == rhs.flen && embedded == rhs.embedded);\n   }\n \n   /* Inequality operator.  */\n@@ -61,7 +64,9 @@ struct riscv_gdbarch_features\n   /* Used by std::unordered_map to hash feature sets.  */\n   std::size_t hash () const noexcept\n   {\n-    std::size_t val = ((xlen & 0x1f) << 5 | (flen & 0x1f) << 0);\n+    std::size_t val = ((embedded ? 1 : 0) << 10\n+\t\t       | (xlen & 0x1f) << 5\n+\t\t       | (flen & 0x1f) << 0);\n     return val;\n   }\n };"
    },
    {
      "sha": "61a4fe783f2e09d7a3358dfe52157ba0a0984757",
      "filename": "gdb/features/Makefile",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/Makefile",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/Makefile",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/Makefile?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -229,6 +229,7 @@ FEATURE_XMLFILES = aarch64-core.xml \\\n \ti386/64bit-pkeys.xml \\\n \ti386/64bit-sse.xml \\\n \ti386/x32-core.xml \\\n+\triscv/rv32e-xregs.xml \\\n \triscv/32bit-cpu.xml \\\n \triscv/32bit-fpu.xml \\\n \triscv/64bit-cpu.xml \\"
    },
    {
      "sha": "cda33195db765813a8e8d8d644c2fb96b9c45df1",
      "filename": "gdb/features/riscv/rv32e-xregs.c",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/riscv/rv32e-xregs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/riscv/rv32e-xregs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/riscv/rv32e-xregs.c?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -0,0 +1,30 @@\n+/* THIS FILE IS GENERATED.  -*- buffer-read-only: t -*- vi:set ro:\n+  Original: rv32e-xregs.xml */\n+\n+#include \"gdbsupport/tdesc.h\"\n+\n+static int\n+create_feature_riscv_rv32e_xregs (struct target_desc *result, long regnum)\n+{\n+  struct tdesc_feature *feature;\n+\n+  feature = tdesc_create_feature (result, \"org.gnu.gdb.riscv.cpu\");\n+  tdesc_create_reg (feature, \"zero\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"ra\", regnum++, 1, NULL, 32, \"code_ptr\");\n+  tdesc_create_reg (feature, \"sp\", regnum++, 1, NULL, 32, \"data_ptr\");\n+  tdesc_create_reg (feature, \"gp\", regnum++, 1, NULL, 32, \"data_ptr\");\n+  tdesc_create_reg (feature, \"tp\", regnum++, 1, NULL, 32, \"data_ptr\");\n+  tdesc_create_reg (feature, \"t0\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"t1\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"t2\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"fp\", regnum++, 1, NULL, 32, \"data_ptr\");\n+  tdesc_create_reg (feature, \"s1\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a0\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a1\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a2\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a3\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a4\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"a5\", regnum++, 1, NULL, 32, \"int\");\n+  tdesc_create_reg (feature, \"pc\", regnum++, 1, NULL, 32, \"code_ptr\");\n+  return regnum;\n+}"
    },
    {
      "sha": "8d313e871fde97a4488206b806ccb86443260d7d",
      "filename": "gdb/features/riscv/rv32e-xregs.xml",
      "status": "added",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/riscv/rv32e-xregs.xml",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/features/riscv/rv32e-xregs.xml",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/features/riscv/rv32e-xregs.xml?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -0,0 +1,31 @@\n+<?xml version=\"1.0\"?>\n+<!-- Copyright (C) 2018-2020 Free Software Foundation, Inc.\n+\n+     Copying and distribution of this file, with or without modification,\n+     are permitted in any medium without royalty provided the copyright\n+     notice and this notice are preserved.  -->\n+\n+<!-- Register numbers are hard-coded in order to maintain backward\n+     compatibility with older versions of tools that didn't use xml\n+     register descriptions.  -->\n+\n+<!DOCTYPE feature SYSTEM \"gdb-target.dtd\">\n+<feature name=\"org.gnu.gdb.riscv.cpu\">\n+  <reg name=\"zero\" bitsize=\"32\" type=\"int\" regnum=\"0\"/>\n+  <reg name=\"ra\" bitsize=\"32\" type=\"code_ptr\"/>\n+  <reg name=\"sp\" bitsize=\"32\" type=\"data_ptr\"/>\n+  <reg name=\"gp\" bitsize=\"32\" type=\"data_ptr\"/>\n+  <reg name=\"tp\" bitsize=\"32\" type=\"data_ptr\"/>\n+  <reg name=\"t0\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"t1\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"t2\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"fp\" bitsize=\"32\" type=\"data_ptr\"/>\n+  <reg name=\"s1\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a0\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a1\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a2\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a3\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a4\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"a5\" bitsize=\"32\" type=\"int\"/>\n+  <reg name=\"pc\" bitsize=\"32\" type=\"code_ptr\"/>\n+</feature>"
    },
    {
      "sha": "fcca37cc45650c8fa05f6551e75487e9e4c60739",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 396,
      "deletions": 315,
      "changes": 711,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -74,6 +74,26 @@ static inline bool is_ ## INSN_NAME ## _insn (long insn) \\\n #include \"opcode/riscv-opc.h\"\n #undef DECLARE_INSN\n \n+/* When this is set to non-zero debugging information about breakpoint\n+   kinds will be printed.  */\n+\n+static unsigned int riscv_debug_breakpoints = 0;\n+\n+/* When this is set to non-zero debugging information about inferior calls\n+   will be printed.  */\n+\n+static unsigned int riscv_debug_infcall = 0;\n+\n+/* When this is set to non-zero debugging information about stack unwinding\n+   will be printed.  */\n+\n+static unsigned int riscv_debug_unwinder = 0;\n+\n+/* When this is set to non-zero debugging information about gdbarch\n+   initialisation will be printed.  */\n+\n+static unsigned int riscv_debug_gdbarch = 0;\n+\n /* Cached information about a frame.  */\n \n struct riscv_unwind_cache\n@@ -141,31 +161,18 @@ class riscv_pending_register_alias\n   const void *m_baton;\n };\n \n-/* Registers in the RISCV_REGISTER_FEATURE lists below are either optional,\n-   or required.  For example the $pc register is always going to be a\n-   required register, you can't do much debugging without that.  In\n-   contrast, most of the CSRs are optional, GDB doesn't require them in\n-   order to have a useful debug session.  This enum models the difference\n-   between these register types.  */\n-\n-enum riscv_register_required_status\n-{\n-  /* This register is optional within this feature.  */\n-  RISCV_REG_OPTIONAL,\n-\n-  /* This register is required within this feature.  */\n-  RISCV_REG_REQUIRED,\n-\n-  /* This register is required, the register must either be in this\n-     feature, or it could appear within the CSR feature.  */\n-  RISCV_REG_REQUIRED_MAYBE_CSR\n-};\n-\n /* A set of registers that we expect to find in a tdesc_feature.  These\n    are use in RISCV_GDBARCH_INIT when processing the target description.  */\n \n struct riscv_register_feature\n {\n+  explicit riscv_register_feature (const char *feature_name)\n+    : m_feature_name (feature_name)\n+  { /* Delete.  */ }\n+\n+  riscv_register_feature () = delete;\n+  DISABLE_COPY_AND_ASSIGN (riscv_register_feature);\n+\n   /* Information for a single register.  */\n   struct register_info\n   {\n@@ -177,41 +184,39 @@ struct riscv_register_feature\n        register.  */\n     std::vector<const char *> names;\n \n-    /* Is this register required within this feature?  In some cases the\n-       register could be required, but might also be in the CSR feature.  */\n-    riscv_register_required_status required;\n-\n     /* Look in FEATURE for a register with a name from this classes names\n        list.  If the register is found then register its number with\n-       TDESC_DATA and add all its aliases to the ALIASES list.  REG_SET is\n-       used to help create the aliases.  */\n+       TDESC_DATA and add all its aliases to the ALIASES list.\n+       PREFER_FIRST_NAME_P is used when deciding which aliases to create.  */\n     bool check (struct tdesc_arch_data *tdesc_data,\n \t\tconst struct tdesc_feature *feature,\n-\t\tconst struct riscv_register_feature *reg_set,\n+\t\tbool prefer_first_name_p,\n \t\tstd::vector<riscv_pending_register_alias> *aliases) const;\n   };\n \n-  /* The name for this feature.  This is the name used to find this feature\n-     within the target description.  */\n-  const char *name;\n+  /* Return the name of this feature.  */\n+  const char *name () const\n+  { return m_feature_name; }\n \n-  /* For x-regs and f-regs we always force GDB to use the first name from\n-     the REGISTERS.NAMES vector, it is therefore important that we create\n-     user-register aliases for all of the remaining names at indexes 1+ in\n-     the names vector.\n+protected:\n \n-     For CSRs we take a different approach, we prefer whatever name the\n-     target description uses, in this case we want to create user-register\n-     aliases for any other names that aren't the target description\n-     provided name.\n-\n-     When this flag is true we are dealing with the first case, and when\n-     this is false we are dealing with the latter.  */\n-  bool prefer_first_name;\n+  /* Return a target description feature extracted from TDESC for this\n+     register feature.  Will return nullptr if there is no feature in TDESC\n+     with the name M_FEATURE_NAME.  */\n+  const struct tdesc_feature *tdesc_feature (const struct target_desc *tdesc) const\n+  {\n+    return tdesc_find_feature (tdesc, name ());\n+  }\n \n   /* List of all the registers that we expect that we might find in this\n      register set.  */\n-  std::vector<struct register_info> registers;\n+  std::vector<struct register_info> m_registers;\n+\n+private:\n+\n+  /* The name for this feature.  This is the name used to find this feature\n+     within the target description.  */\n+  const char *m_feature_name;\n };\n \n /* See description in the class declaration above.  */\n@@ -220,7 +225,7 @@ bool\n riscv_register_feature::register_info::check\n \t(struct tdesc_arch_data *tdesc_data,\n \t const struct tdesc_feature *feature,\n-\t const struct riscv_register_feature *reg_set,\n+\t bool prefer_first_name_p,\n \t std::vector<riscv_pending_register_alias> *aliases) const\n {\n   for (const char *name : this->names)\n@@ -233,12 +238,11 @@ riscv_register_feature::register_info::check\n \t     register.  In RISCV_REGISTER_NAME we ensure that GDB\n \t     always uses the first name for each register, so here we\n \t     add aliases for all of the remaining names.  */\n-\t  bool prefer_first_name = reg_set->prefer_first_name;\n-\t  int start_index = prefer_first_name ? 1 : 0;\n+\t  int start_index = prefer_first_name_p ? 1 : 0;\n \t  for (int i = start_index; i < this->names.size (); ++i)\n \t    {\n \t      const char *alias = this->names[i];\n-\t      if (alias == name && !prefer_first_name)\n+\t      if (alias == name && !prefer_first_name_p)\n \t\tcontinue;\n \t      aliases->emplace_back (alias, (void *) &this->regnum);\n \t    }\n@@ -248,136 +252,322 @@ riscv_register_feature::register_info::check\n   return false;\n }\n \n-/* The general x-registers feature set.  */\n-\n-static const struct riscv_register_feature riscv_xreg_feature =\n-{\n- \"org.gnu.gdb.riscv.cpu\", true,\n- {\n-   { RISCV_ZERO_REGNUM + 0, { \"zero\", \"x0\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 1, { \"ra\", \"x1\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 2, { \"sp\", \"x2\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 3, { \"gp\", \"x3\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 4, { \"tp\", \"x4\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 5, { \"t0\", \"x5\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 6, { \"t1\", \"x6\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 7, { \"t2\", \"x7\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 8, { \"fp\", \"x8\", \"s0\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 9, { \"s1\", \"x9\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 10, { \"a0\", \"x10\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 11, { \"a1\", \"x11\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 12, { \"a2\", \"x12\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 13, { \"a3\", \"x13\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 14, { \"a4\", \"x14\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 15, { \"a5\", \"x15\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 16, { \"a6\", \"x16\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 17, { \"a7\", \"x17\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 18, { \"s2\", \"x18\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 19, { \"s3\", \"x19\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 20, { \"s4\", \"x20\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 21, { \"s5\", \"x21\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 22, { \"s6\", \"x22\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 23, { \"s7\", \"x23\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 24, { \"s8\", \"x24\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 25, { \"s9\", \"x25\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 26, { \"s10\", \"x26\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 27, { \"s11\", \"x27\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 28, { \"t3\", \"x28\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 29, { \"t4\", \"x29\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 30, { \"t5\", \"x30\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 31, { \"t6\", \"x31\" }, RISCV_REG_REQUIRED },\n-   { RISCV_ZERO_REGNUM + 32, { \"pc\" }, RISCV_REG_REQUIRED }\n- }\n+/* Class representing the x-registers feature set.  */\n+\n+struct riscv_xreg_feature : public riscv_register_feature\n+{\n+  riscv_xreg_feature ()\n+    : riscv_register_feature (\"org.gnu.gdb.riscv.cpu\")\n+  {\n+    m_registers =  {\n+      { RISCV_ZERO_REGNUM + 0, { \"zero\", \"x0\" } },\n+      { RISCV_ZERO_REGNUM + 1, { \"ra\", \"x1\" } },\n+      { RISCV_ZERO_REGNUM + 2, { \"sp\", \"x2\" } },\n+      { RISCV_ZERO_REGNUM + 3, { \"gp\", \"x3\" } },\n+      { RISCV_ZERO_REGNUM + 4, { \"tp\", \"x4\" } },\n+      { RISCV_ZERO_REGNUM + 5, { \"t0\", \"x5\" } },\n+      { RISCV_ZERO_REGNUM + 6, { \"t1\", \"x6\" } },\n+      { RISCV_ZERO_REGNUM + 7, { \"t2\", \"x7\" } },\n+      { RISCV_ZERO_REGNUM + 8, { \"fp\", \"x8\", \"s0\" } },\n+      { RISCV_ZERO_REGNUM + 9, { \"s1\", \"x9\" } },\n+      { RISCV_ZERO_REGNUM + 10, { \"a0\", \"x10\" } },\n+      { RISCV_ZERO_REGNUM + 11, { \"a1\", \"x11\" } },\n+      { RISCV_ZERO_REGNUM + 12, { \"a2\", \"x12\" } },\n+      { RISCV_ZERO_REGNUM + 13, { \"a3\", \"x13\" } },\n+      { RISCV_ZERO_REGNUM + 14, { \"a4\", \"x14\" } },\n+      { RISCV_ZERO_REGNUM + 15, { \"a5\", \"x15\" } },\n+      { RISCV_ZERO_REGNUM + 16, { \"a6\", \"x16\" } },\n+      { RISCV_ZERO_REGNUM + 17, { \"a7\", \"x17\" } },\n+      { RISCV_ZERO_REGNUM + 18, { \"s2\", \"x18\" } },\n+      { RISCV_ZERO_REGNUM + 19, { \"s3\", \"x19\" } },\n+      { RISCV_ZERO_REGNUM + 20, { \"s4\", \"x20\" } },\n+      { RISCV_ZERO_REGNUM + 21, { \"s5\", \"x21\" } },\n+      { RISCV_ZERO_REGNUM + 22, { \"s6\", \"x22\" } },\n+      { RISCV_ZERO_REGNUM + 23, { \"s7\", \"x23\" } },\n+      { RISCV_ZERO_REGNUM + 24, { \"s8\", \"x24\" } },\n+      { RISCV_ZERO_REGNUM + 25, { \"s9\", \"x25\" } },\n+      { RISCV_ZERO_REGNUM + 26, { \"s10\", \"x26\" } },\n+      { RISCV_ZERO_REGNUM + 27, { \"s11\", \"x27\" } },\n+      { RISCV_ZERO_REGNUM + 28, { \"t3\", \"x28\" } },\n+      { RISCV_ZERO_REGNUM + 29, { \"t4\", \"x29\" } },\n+      { RISCV_ZERO_REGNUM + 30, { \"t5\", \"x30\" } },\n+      { RISCV_ZERO_REGNUM + 31, { \"t6\", \"x31\" } },\n+      { RISCV_ZERO_REGNUM + 32, { \"pc\" } }\n+    };\n+  }\n+\n+  /* Return the preferred name for the register with gdb register number\n+     REGNUM, which must be in the inclusive range RISCV_ZERO_REGNUM to\n+     RISCV_PC_REGNUM.  */\n+  const char *register_name (int regnum) const\n+  {\n+    gdb_assert (regnum >= RISCV_ZERO_REGNUM && regnum <= m_registers.size ());\n+    return m_registers[regnum].names[0];\n+  }\n+\n+  /* Check this feature within TDESC, record the registers from this\n+     feature into TDESC_DATA and update ALIASES and FEATURES.  */\n+  bool check (const struct target_desc *tdesc,\n+\t      struct tdesc_arch_data *tdesc_data,\n+\t      std::vector<riscv_pending_register_alias> *aliases,\n+\t      struct riscv_gdbarch_features *features) const\n+  {\n+    const struct tdesc_feature *feature_cpu = tdesc_feature (tdesc);\n+\n+    if (feature_cpu == nullptr)\n+      return false;\n+\n+    bool seen_an_optional_reg_p = false;\n+    for (const auto &reg : m_registers)\n+      {\n+\tbool found = reg.check (tdesc_data, feature_cpu, true, aliases);\n+\n+\tbool is_optional_reg_p = (reg.regnum >= RISCV_ZERO_REGNUM + 16\n+\t\t\t\t  && reg.regnum < RISCV_ZERO_REGNUM + 32);\n+\n+\tif (!found && (!is_optional_reg_p || seen_an_optional_reg_p))\n+\t  return false;\n+\telse if (found && is_optional_reg_p)\n+\t  seen_an_optional_reg_p = true;\n+      }\n+\n+    /* Check that all of the core cpu registers have the same bitsize.  */\n+    int xlen_bitsize = tdesc_register_bitsize (feature_cpu, \"pc\");\n+\n+    bool valid_p = true;\n+    for (auto &tdesc_reg : feature_cpu->registers)\n+      valid_p &= (tdesc_reg->bitsize == xlen_bitsize);\n+\n+    features->xlen = (xlen_bitsize / 8);\n+    features->embedded = !seen_an_optional_reg_p;\n+\n+    return valid_p;\n+  }\n };\n \n-/* The f-registers feature set.  */\n-\n-static const struct riscv_register_feature riscv_freg_feature =\n-{\n- \"org.gnu.gdb.riscv.fpu\", true,\n- {\n-   { RISCV_FIRST_FP_REGNUM + 0, { \"ft0\", \"f0\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 1, { \"ft1\", \"f1\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 2, { \"ft2\", \"f2\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 3, { \"ft3\", \"f3\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 4, { \"ft4\", \"f4\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 5, { \"ft5\", \"f5\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 6, { \"ft6\", \"f6\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 7, { \"ft7\", \"f7\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 8, { \"fs0\", \"f8\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 9, { \"fs1\", \"f9\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 10, { \"fa0\", \"f10\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 11, { \"fa1\", \"f11\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 12, { \"fa2\", \"f12\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 13, { \"fa3\", \"f13\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 14, { \"fa4\", \"f14\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 15, { \"fa5\", \"f15\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 16, { \"fa6\", \"f16\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 17, { \"fa7\", \"f17\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 18, { \"fs2\", \"f18\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 19, { \"fs3\", \"f19\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 20, { \"fs4\", \"f20\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 21, { \"fs5\", \"f21\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 22, { \"fs6\", \"f22\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 23, { \"fs7\", \"f23\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 24, { \"fs8\", \"f24\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 25, { \"fs9\", \"f25\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 26, { \"fs10\", \"f26\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 27, { \"fs11\", \"f27\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 28, { \"ft8\", \"f28\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 29, { \"ft9\", \"f29\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 30, { \"ft10\", \"f30\" }, RISCV_REG_REQUIRED },\n-   { RISCV_FIRST_FP_REGNUM + 31, { \"ft11\", \"f31\" }, RISCV_REG_REQUIRED },\n-\n-   { RISCV_CSR_FFLAGS_REGNUM, { \"fflags\", \"csr1\" }, RISCV_REG_REQUIRED_MAYBE_CSR },\n-   { RISCV_CSR_FRM_REGNUM, { \"frm\", \"csr2\" }, RISCV_REG_REQUIRED_MAYBE_CSR },\n-   { RISCV_CSR_FCSR_REGNUM, { \"fcsr\", \"csr3\" }, RISCV_REG_REQUIRED_MAYBE_CSR },\n-\n- }\n+/* An instance of the x-register feature set.  */\n+\n+static const struct riscv_xreg_feature riscv_xreg_feature;\n+\n+/* Class representing the f-registers feature set.  */\n+\n+struct riscv_freg_feature : public riscv_register_feature\n+{\n+  riscv_freg_feature ()\n+    : riscv_register_feature (\"org.gnu.gdb.riscv.fpu\")\n+  {\n+    m_registers =  {\n+      { RISCV_FIRST_FP_REGNUM + 0, { \"ft0\", \"f0\" } },\n+      { RISCV_FIRST_FP_REGNUM + 1, { \"ft1\", \"f1\" } },\n+      { RISCV_FIRST_FP_REGNUM + 2, { \"ft2\", \"f2\" } },\n+      { RISCV_FIRST_FP_REGNUM + 3, { \"ft3\", \"f3\" } },\n+      { RISCV_FIRST_FP_REGNUM + 4, { \"ft4\", \"f4\" } },\n+      { RISCV_FIRST_FP_REGNUM + 5, { \"ft5\", \"f5\" } },\n+      { RISCV_FIRST_FP_REGNUM + 6, { \"ft6\", \"f6\" } },\n+      { RISCV_FIRST_FP_REGNUM + 7, { \"ft7\", \"f7\" } },\n+      { RISCV_FIRST_FP_REGNUM + 8, { \"fs0\", \"f8\" } },\n+      { RISCV_FIRST_FP_REGNUM + 9, { \"fs1\", \"f9\" } },\n+      { RISCV_FIRST_FP_REGNUM + 10, { \"fa0\", \"f10\" } },\n+      { RISCV_FIRST_FP_REGNUM + 11, { \"fa1\", \"f11\" } },\n+      { RISCV_FIRST_FP_REGNUM + 12, { \"fa2\", \"f12\" } },\n+      { RISCV_FIRST_FP_REGNUM + 13, { \"fa3\", \"f13\" } },\n+      { RISCV_FIRST_FP_REGNUM + 14, { \"fa4\", \"f14\" } },\n+      { RISCV_FIRST_FP_REGNUM + 15, { \"fa5\", \"f15\" } },\n+      { RISCV_FIRST_FP_REGNUM + 16, { \"fa6\", \"f16\" } },\n+      { RISCV_FIRST_FP_REGNUM + 17, { \"fa7\", \"f17\" } },\n+      { RISCV_FIRST_FP_REGNUM + 18, { \"fs2\", \"f18\" } },\n+      { RISCV_FIRST_FP_REGNUM + 19, { \"fs3\", \"f19\" } },\n+      { RISCV_FIRST_FP_REGNUM + 20, { \"fs4\", \"f20\" } },\n+      { RISCV_FIRST_FP_REGNUM + 21, { \"fs5\", \"f21\" } },\n+      { RISCV_FIRST_FP_REGNUM + 22, { \"fs6\", \"f22\" } },\n+      { RISCV_FIRST_FP_REGNUM + 23, { \"fs7\", \"f23\" } },\n+      { RISCV_FIRST_FP_REGNUM + 24, { \"fs8\", \"f24\" } },\n+      { RISCV_FIRST_FP_REGNUM + 25, { \"fs9\", \"f25\" } },\n+      { RISCV_FIRST_FP_REGNUM + 26, { \"fs10\", \"f26\" } },\n+      { RISCV_FIRST_FP_REGNUM + 27, { \"fs11\", \"f27\" } },\n+      { RISCV_FIRST_FP_REGNUM + 28, { \"ft8\", \"f28\" } },\n+      { RISCV_FIRST_FP_REGNUM + 29, { \"ft9\", \"f29\" } },\n+      { RISCV_FIRST_FP_REGNUM + 30, { \"ft10\", \"f30\" } },\n+      { RISCV_FIRST_FP_REGNUM + 31, { \"ft11\", \"f31\" } },\n+      { RISCV_CSR_FFLAGS_REGNUM, { \"fflags\", \"csr1\" } },\n+      { RISCV_CSR_FRM_REGNUM, { \"frm\", \"csr2\" } },\n+      { RISCV_CSR_FCSR_REGNUM, { \"fcsr\", \"csr3\" } },\n+    };\n+  }\n+\n+  /* Return the preferred name for the register with gdb register number\n+     REGNUM, which must be in the inclusive range RISCV_FIRST_FP_REGNUM to\n+     RISCV_LAST_FP_REGNUM.  */\n+  const char *register_name (int regnum) const\n+  {\n+    gdb_static_assert (RISCV_LAST_FP_REGNUM == RISCV_FIRST_FP_REGNUM + 31);\n+    gdb_assert (regnum >= RISCV_FIRST_FP_REGNUM\n+\t\t&& regnum <= RISCV_LAST_FP_REGNUM);\n+    regnum -= RISCV_FIRST_FP_REGNUM;\n+    return m_registers[regnum].names[0];\n+  }\n+\n+  /* Check this feature within TDESC, record the registers from this\n+     feature into TDESC_DATA and update ALIASES and FEATURES.  */\n+  bool check (const struct target_desc *tdesc,\n+\t      struct tdesc_arch_data *tdesc_data,\n+\t      std::vector<riscv_pending_register_alias> *aliases,\n+\t      struct riscv_gdbarch_features *features) const\n+  {\n+    const struct tdesc_feature *feature_fpu = tdesc_feature (tdesc);\n+\n+    /* It's fine if this feature is missing.  Update the architecture\n+       feature set and return.  */\n+    if (feature_fpu == nullptr)\n+      {\n+\tfeatures->flen = 0;\n+\treturn true;\n+      }\n+\n+    /* Check all of the floating pointer registers are present.  We also\n+       check that the floating point CSRs are present too, though if these\n+       are missing this is not fatal.  */\n+    for (const auto &reg : m_registers)\n+      {\n+\tbool found = reg.check (tdesc_data, feature_fpu, true, aliases);\n+\n+\tbool is_ctrl_reg_p = reg.regnum > RISCV_LAST_FP_REGNUM;\n+\n+\tif (!found && !is_ctrl_reg_p)\n+\t  return false;\n+      }\n+\n+    /* Look through all of the floating point registers (not the FP CSRs\n+       though), and check they all have the same bitsize.  Use this bitsize\n+       to update the feature set for this gdbarch.  */\n+    int fp_bitsize = -1;\n+    for (const auto &reg : m_registers)\n+      {\n+\t/* Stop once we get to the CSRs which are at the end of the\n+\t   M_REGISTERS list.  */\n+\tif (reg.regnum > RISCV_LAST_FP_REGNUM)\n+\t  break;\n+\n+\tint reg_bitsize = -1;\n+\tfor (const char *name : reg.names)\n+\t  {\n+\t    if (tdesc_unnumbered_register (feature_fpu, name))\n+\t      {\n+\t\treg_bitsize = tdesc_register_bitsize (feature_fpu, name);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tgdb_assert (reg_bitsize != -1);\n+\tif (fp_bitsize == -1)\n+\t  fp_bitsize = reg_bitsize;\n+\telse if (fp_bitsize != reg_bitsize)\n+\t  return false;\n+      }\n+\n+    features->flen = (fp_bitsize / 8);\n+    return true;\n+  }\n };\n \n-/* Set of virtual registers.  These are not physical registers on the\n-   hardware, but might be available from the target.  These are not pseudo\n-   registers, reading these really does result in a register read from the\n-   target, it is just that there might not be a physical register backing\n-   the result.  */\n+/* An instance of the f-register feature set.  */\n+\n+static const struct riscv_freg_feature riscv_freg_feature;\n+\n+/* Class representing the virtual registers.  These are not physical\n+   registers on the hardware, but might be available from the target.\n+   These are not pseudo registers, reading these really does result in a\n+   register read from the target, it is just that there might not be a\n+   physical register backing the result.  */\n \n-static const struct riscv_register_feature riscv_virtual_feature =\n+struct riscv_virtual_feature : public riscv_register_feature\n {\n- \"org.gnu.gdb.riscv.virtual\", false,\n- {\n-   { RISCV_PRIV_REGNUM, { \"priv\" }, RISCV_REG_OPTIONAL }\n- }\n+  riscv_virtual_feature ()\n+    : riscv_register_feature (\"org.gnu.gdb.riscv.virtual\")\n+  {\n+    m_registers =  {\n+      { RISCV_PRIV_REGNUM, { \"priv\" } }\n+    };\n+  }\n+\n+  bool check (const struct target_desc *tdesc,\n+\t      struct tdesc_arch_data *tdesc_data,\n+\t      std::vector<riscv_pending_register_alias> *aliases,\n+\t      struct riscv_gdbarch_features *features) const\n+  {\n+    const struct tdesc_feature *feature_virtual = tdesc_feature (tdesc);\n+\n+    /* It's fine if this feature is missing.  */\n+    if (feature_virtual == nullptr)\n+      return true;\n+\n+    /* We don't check the return value from the call to check here, all the\n+       registers in this feature are optional.  */\n+    for (const auto &reg : m_registers)\n+      reg.check (tdesc_data, feature_virtual, true, aliases);\n+\n+    return true;\n+  }\n };\n \n-/* Feature set for CSRs.  This set is NOT constant as the register names\n-   list for each register is not complete.  The aliases are computed\n-   during RISCV_CREATE_CSR_ALIASES.  */\n+/* An instance of the virtual register feature.  */\n \n-static struct riscv_register_feature riscv_csr_feature =\n+static const struct riscv_virtual_feature riscv_virtual_feature;\n+\n+/* Class representing the CSR feature.  */\n+\n+struct riscv_csr_feature : public riscv_register_feature\n {\n- \"org.gnu.gdb.riscv.csr\", false,\n- {\n-#define DECLARE_CSR(NAME,VALUE,CLASS,DEFINE_VER,ABORT_VER) \\\n-  { RISCV_ ## VALUE ## _REGNUM, { # NAME }, RISCV_REG_OPTIONAL },\n+  riscv_csr_feature ()\n+    : riscv_register_feature (\"org.gnu.gdb.riscv.csr\")\n+  {\n+    m_registers = {\n+#define DECLARE_CSR(NAME,VALUE,CLASS,DEFINE_VER,ABORT_VER)\t\t\\\n+      { RISCV_ ## VALUE ## _REGNUM, { # NAME } },\n #include \"opcode/riscv-opc.h\"\n #undef DECLARE_CSR\n- }\n+    };\n+    riscv_create_csr_aliases ();\n+  }\n+\n+  bool check (const struct target_desc *tdesc,\n+\t      struct tdesc_arch_data *tdesc_data,\n+\t      std::vector<riscv_pending_register_alias> *aliases,\n+\t      struct riscv_gdbarch_features *features) const\n+  {\n+    const struct tdesc_feature *feature_csr = tdesc_feature (tdesc);\n+\n+    /* It's fine if this feature is missing.  */\n+    if (feature_csr == nullptr)\n+      return true;\n+\n+    /* We don't check the return value from the call to check here, all the\n+       registers in this feature are optional.  */\n+    for (const auto &reg : m_registers)\n+      reg.check (tdesc_data, feature_csr, true, aliases);\n+\n+    return true;\n+  }\n+\n+private:\n+\n+  /* Complete RISCV_CSR_FEATURE, building the CSR alias names and adding them\n+     to the name list for each register.  */\n+\n+  void\n+  riscv_create_csr_aliases ()\n+  {\n+    for (auto &reg : m_registers)\n+      {\n+\tint csr_num = reg.regnum - RISCV_FIRST_CSR_REGNUM;\n+\tconst char *alias = xstrprintf (\"csr%d\", csr_num);\n+\treg.names.push_back (alias);\n+      }\n+  }\n };\n \n-/* Complete RISCV_CSR_FEATURE, building the CSR alias names and adding them\n-   to the name list for each register.  */\n+/* An instance of the csr register feature.  */\n \n-static void\n-riscv_create_csr_aliases ()\n-{\n-  for (auto &reg : riscv_csr_feature.registers)\n-    {\n-      int csr_num = reg.regnum - RISCV_FIRST_CSR_REGNUM;\n-      const char *alias = xstrprintf (\"csr%d\", csr_num);\n-      reg.names.push_back (alias);\n-    }\n-}\n+static const struct riscv_csr_feature riscv_csr_feature;\n \n /* Controls whether we place compressed breakpoints or not.  When in auto\n    mode GDB tries to determine if the target supports compressed\n@@ -419,26 +609,6 @@ show_riscv_debug_variable (struct ui_file *file, int from_tty,\n \t\t    c->name, value);\n }\n \n-/* When this is set to non-zero debugging information about breakpoint\n-   kinds will be printed.  */\n-\n-static unsigned int riscv_debug_breakpoints = 0;\n-\n-/* When this is set to non-zero debugging information about inferior calls\n-   will be printed.  */\n-\n-static unsigned int riscv_debug_infcall = 0;\n-\n-/* When this is set to non-zero debugging information about stack unwinding\n-   will be printed.  */\n-\n-static unsigned int riscv_debug_unwinder = 0;\n-\n-/* When this is set to non-zero debugging information about gdbarch\n-   initialisation will be printed.  */\n-\n-static unsigned int riscv_debug_gdbarch = 0;\n-\n /* See riscv-tdep.h.  */\n \n int\n@@ -471,6 +641,14 @@ riscv_abi_flen (struct gdbarch *gdbarch)\n   return gdbarch_tdep (gdbarch)->abi_features.flen;\n }\n \n+/* See riscv-tdep.h.  */\n+\n+bool\n+riscv_abi_embedded (struct gdbarch *gdbarch)\n+{\n+  return gdbarch_tdep (gdbarch)->abi_features.embedded;\n+}\n+\n /* Return true if the target for GDBARCH has floating point hardware.  */\n \n static bool\n@@ -588,21 +766,14 @@ riscv_register_name (struct gdbarch *gdbarch, int regnum)\n      example we want to see 'ra' instead of 'x1' whatever the target\n      description called it.  */\n   if (regnum >= RISCV_ZERO_REGNUM && regnum < RISCV_FIRST_FP_REGNUM)\n-    {\n-      gdb_assert (regnum < riscv_xreg_feature.registers.size ());\n-      return riscv_xreg_feature.registers[regnum].names[0];\n-    }\n+    return riscv_xreg_feature.register_name (regnum);\n \n   /* Like with the x-regs we prefer the abi names for the floating point\n      registers.  */\n   if (regnum >= RISCV_FIRST_FP_REGNUM && regnum <= RISCV_LAST_FP_REGNUM)\n     {\n       if (riscv_has_fp_regs (gdbarch))\n-\t{\n-\t  regnum -= RISCV_FIRST_FP_REGNUM;\n-\t  gdb_assert (regnum < riscv_freg_feature.registers.size ());\n-\t  return riscv_freg_feature.registers[regnum].names[0];\n-\t}\n+\treturn riscv_freg_feature.register_name (regnum);\n       else\n \treturn NULL;\n     }\n@@ -1925,6 +2096,11 @@ struct riscv_call_info\n     xlen = riscv_abi_xlen (gdbarch);\n     flen = riscv_abi_flen (gdbarch);\n \n+    /* Reduce the number of integer argument registers when using the\n+       embedded abi (i.e. rv32e).  */\n+    if (riscv_abi_embedded (gdbarch))\n+      int_regs.last_regnum = RISCV_A0_REGNUM + 5;\n+\n     /* Disable use of floating point registers if needed.  */\n     if (!riscv_has_fp_abi (gdbarch))\n       float_regs.next_regnum = float_regs.last_regnum + 1;\n@@ -3073,6 +3249,16 @@ riscv_features_from_gdbarch_info (const struct gdbarch_info info)\n \tfeatures.flen = 8;\n       else if (e_flags & EF_RISCV_FLOAT_ABI_SINGLE)\n \tfeatures.flen = 4;\n+\n+      if (e_flags & EF_RISCV_RVE)\n+\t{\n+\t  if (features.xlen == 8)\n+\t    {\n+\t      warning (_(\"64-bit ELF with RV32E flag set!  Assuming 32-bit\"));\n+\t      features.xlen = 4;\n+\t    }\n+\t  features.embedded = true;\n+\t}\n     }\n \n   return features;\n@@ -3099,38 +3285,6 @@ riscv_find_default_target_description (const struct gdbarch_info info)\n   return riscv_lookup_target_description (features);\n }\n \n-/* All of the registers in REG_SET are checked for in FEATURE, TDESC_DATA\n-   is updated with the register numbers for each register as listed in\n-   REG_SET.  If any register marked as required in REG_SET is not found in\n-   FEATURE then this function returns false, otherwise, it returns true.  */\n-\n-static bool\n-riscv_check_tdesc_feature (struct tdesc_arch_data *tdesc_data,\n-\t\t\t   const struct tdesc_feature *main_feature,\n-\t\t\t   const struct tdesc_feature *csr_feature,\n-\t\t\t   const struct riscv_register_feature *reg_set,\n-\t\t\t   std::vector<riscv_pending_register_alias> *aliases)\n-{\n-  for (const auto &reg : reg_set->registers)\n-    {\n-      bool found = reg.check (tdesc_data, main_feature, reg_set, aliases);\n-\n-      if (!found && reg.required != RISCV_REG_OPTIONAL)\n-\t{\n-\t  if (reg.required == RISCV_REG_REQUIRED_MAYBE_CSR\n-\t      && csr_feature != nullptr)\n-\t    {\n-\t      gdb_assert (main_feature != csr_feature);\n-\t      found = reg.check (tdesc_data, csr_feature,  reg_set, aliases);\n-\t    }\n-\t  if (!found)\n-\t    return false;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n /* Add all the expected register sets into GDBARCH.  */\n \n static void\n@@ -3239,7 +3393,7 @@ riscv_tdesc_unknown_reg (struct gdbarch *gdbarch, tdesc_feature *feature,\n \n      To prevent these duplicates showing up in any of the register list,\n      record their register numbers here.  */\n-  if (strcmp (tdesc_feature_name (feature), riscv_freg_feature.name) == 0)\n+  if (strcmp (tdesc_feature_name (feature), riscv_freg_feature.name ()) == 0)\n     {\n       struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n       int *regnum_ptr = nullptr;\n@@ -3270,7 +3424,7 @@ riscv_tdesc_unknown_reg (struct gdbarch *gdbarch, tdesc_feature *feature,\n   /* Any unknown registers in the CSR feature are recorded within a single\n      block so we can easily identify these registers when making choices\n      about register groups in riscv_register_reggroup_p.  */\n-  if (strcmp (tdesc_feature_name (feature), riscv_csr_feature.name) == 0)\n+  if (strcmp (tdesc_feature_name (feature), riscv_csr_feature.name ()) == 0)\n     {\n       struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n       if (tdep->unknown_csrs_first_regnum == -1)\n@@ -3316,95 +3470,22 @@ riscv_gdbarch_init (struct gdbarch_info info,\n   /* Ensure we always have a target description.  */\n   if (!tdesc_has_registers (tdesc))\n     tdesc = riscv_find_default_target_description (info);\n-  gdb_assert (tdesc);\n+  gdb_assert (tdesc != nullptr);\n \n   if (riscv_debug_gdbarch)\n     fprintf_unfiltered (gdb_stdlog, \"Have got a target description\\n\");\n \n-  const struct tdesc_feature *feature_cpu\n-    = tdesc_find_feature (tdesc, riscv_xreg_feature.name);\n-  const struct tdesc_feature *feature_fpu\n-    = tdesc_find_feature (tdesc, riscv_freg_feature.name);\n-  const struct tdesc_feature *feature_virtual\n-    = tdesc_find_feature (tdesc, riscv_virtual_feature.name);\n-  const struct tdesc_feature *feature_csr\n-    = tdesc_find_feature (tdesc, riscv_csr_feature.name);\n-\n-  if (feature_cpu == NULL)\n-    return NULL;\n-\n   tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n   std::vector<riscv_pending_register_alias> pending_aliases;\n \n-  bool valid_p = riscv_check_tdesc_feature (tdesc_data.get (),\n-\t\t\t\t\t    feature_cpu, feature_csr,\n-\t\t\t\t\t    &riscv_xreg_feature,\n-\t\t\t\t\t    &pending_aliases);\n-  if (valid_p)\n-    {\n-      /* Check that all of the core cpu registers have the same bitsize.  */\n-      int xlen_bitsize = tdesc_register_bitsize (feature_cpu, \"pc\");\n-\n-      for (auto &tdesc_reg : feature_cpu->registers)\n-\tvalid_p &= (tdesc_reg->bitsize == xlen_bitsize);\n-\n-      if (riscv_debug_gdbarch)\n-\tfprintf_filtered\n-\t  (gdb_stdlog,\n-\t   \"From target-description, xlen = %d\\n\", xlen_bitsize);\n-\n-      features.xlen = (xlen_bitsize / 8);\n-    }\n-\n-  if (feature_fpu != NULL)\n-    {\n-      valid_p &= riscv_check_tdesc_feature (tdesc_data.get (), feature_fpu,\n-\t\t\t\t\t    feature_csr,\n-\t\t\t\t\t    &riscv_freg_feature,\n-\t\t\t\t\t    &pending_aliases);\n-\n-      /* Search for the first floating point register (by any alias), to\n-\t determine the bitsize.  */\n-      int bitsize = -1;\n-      const auto &fp0 = riscv_freg_feature.registers[0];\n-\n-      for (const char *name : fp0.names)\n-\t{\n-\t  if (tdesc_unnumbered_register (feature_fpu, name))\n-\t    {\n-\t      bitsize = tdesc_register_bitsize (feature_fpu, name);\n-\t      break;\n-\t    }\n-\t}\n-\n-      gdb_assert (bitsize != -1);\n-      features.flen = (bitsize / 8);\n-\n-      if (riscv_debug_gdbarch)\n-\tfprintf_filtered\n-\t  (gdb_stdlog,\n-\t   \"From target-description, flen = %d\\n\", bitsize);\n-    }\n-  else\n-    {\n-      features.flen = 0;\n-\n-      if (riscv_debug_gdbarch)\n-\tfprintf_filtered\n-\t  (gdb_stdlog,\n-\t   \"No FPU in target-description, assume soft-float ABI\\n\");\n-    }\n-\n-  if (feature_virtual)\n-    riscv_check_tdesc_feature (tdesc_data.get (), feature_virtual, feature_csr,\n-\t\t\t       &riscv_virtual_feature,\n-\t\t\t       &pending_aliases);\n-\n-  if (feature_csr)\n-    riscv_check_tdesc_feature (tdesc_data.get (), feature_csr, nullptr,\n-\t\t\t       &riscv_csr_feature,\n-\t\t\t       &pending_aliases);\n-\n+  bool valid_p = (riscv_xreg_feature.check (tdesc, tdesc_data.get (),\n+\t\t\t\t\t    &pending_aliases, &features)\n+\t\t  && riscv_freg_feature.check (tdesc, tdesc_data.get (),\n+\t\t\t\t\t       &pending_aliases, &features)\n+\t\t  && riscv_virtual_feature.check (tdesc, tdesc_data.get (),\n+\t\t\t\t\t\t  &pending_aliases, &features)\n+\t\t  && riscv_csr_feature.check (tdesc, tdesc_data.get (),\n+\t\t\t\t\t      &pending_aliases, &features));\n   if (!valid_p)\n     {\n       if (riscv_debug_gdbarch)\n@@ -3417,10 +3498,17 @@ riscv_gdbarch_init (struct gdbarch_info info,\n      providing.  */\n   struct riscv_gdbarch_features abi_features\n     = riscv_features_from_gdbarch_info (info);\n+\n+  /* If the ABI_FEATURES xlen is 0 then this indicates we got no useful abi\n+     features from the INFO object.  In this case we just treat the\n+     hardware features as defining the abi.  */\n+  if (abi_features.xlen == 0)\n+    abi_features = features;\n+\n   /* In theory a binary compiled for RV32 could run on an RV64 target,\n      however, this has not been tested in GDB yet, so for now we require\n      that the requested xlen match the targets xlen.  */\n-  if (abi_features.xlen != 0 && abi_features.xlen != features.xlen)\n+  if (abi_features.xlen != features.xlen)\n     error (_(\"bfd requires xlen %d, but target has xlen %d\"),\n \t    abi_features.xlen, features.xlen);\n   /* We do support running binaries compiled for 32-bit float on targets\n@@ -3430,12 +3518,6 @@ riscv_gdbarch_init (struct gdbarch_info info,\n     error (_(\"bfd requires flen %d, but target has flen %d\"),\n \t    abi_features.flen, features.flen);\n \n-  /* If the ABI_FEATURES xlen is 0 then this indicates we got no useful abi\n-     features from the INFO object.  In this case we assume that the xlen\n-     abi matches the hardware.  */\n-  if (abi_features.xlen == 0)\n-    abi_features.xlen = features.xlen;\n-\n   /* Find a candidate among the list of pre-declared architectures.  */\n   for (arches = gdbarch_list_lookup_by_info (arches, &info);\n        arches != NULL;\n@@ -3707,7 +3789,6 @@ void _initialize_riscv_tdep ();\n void\n _initialize_riscv_tdep ()\n {\n-  riscv_create_csr_aliases ();\n   riscv_init_reggroups ();\n \n   gdbarch_register (bfd_arch_riscv, riscv_gdbarch_init, NULL);"
    },
    {
      "sha": "42939105b088cac001a3e17204e6bfde9e17703f",
      "filename": "gdb/riscv-tdep.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/riscv-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25428040229b10f5a8a71be51dfc6ee2fc3f41b9/gdb/riscv-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.h?ref=25428040229b10f5a8a71be51dfc6ee2fc3f41b9",
      "patch": "@@ -128,6 +128,11 @@ extern int riscv_abi_xlen (struct gdbarch *gdbarch);\n    with RISCV_ISA_FLEN.  */\n extern int riscv_abi_flen (struct gdbarch *gdbarch);\n \n+/* Return true if GDBARCH is using the embedded x-regs abi, that is the\n+   target only has 16 x-registers, which includes a reduced number of\n+   argument registers.  */\n+extern bool riscv_abi_embedded (struct gdbarch *gdbarch);\n+\n /* Single step based on where the current instruction will take us.  */\n extern std::vector<CORE_ADDR> riscv_software_single_step\n   (struct regcache *regcache);"
    }
  ]
}