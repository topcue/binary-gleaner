{
  "sha": "d57cbee932f86df06251498daa93154046dc77c0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDU3Y2JlZTkzMmY4NmRmMDYyNTE0OThkYWE5MzE1NDA0NmRjNzdjMA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-03T13:18:43Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-09T13:06:05Z"
    },
    "message": "gdb/testsuite/fortran: Fix info-modules/info-types for gfortran 8+\n\nThe gdb.fortran/info-modules.exp and gdb.fortran/info-types.exp tests\nare failing on versions of gfortran after 7.3 due to the inclusion of\nextra \"system\" modules and type that were not being matched by the\ncurrent test patterns.\n\nRather than building increasingly complex patterns that would always\nbe at risk of breaking with future versions of GCC I have instead\nadded a new library that parses the output of the following commands:\n\n  info types\n  info variables\n  info functions\n  info modules\n  info module functions\n  info module variables\n\ninto a data structure, the test can than run checks against the\ncontents of this data structure.\n\nThe benefit is that we can simply ignore extra results that we don't\ncare about.\n\nThere is a small risk that a bug in GDB might allow us to start\nreporting incorrect results in such a way that the new library will\nnot spot the error.  However, I have tried to mitigate this risk by\nadding extra procedures into the test library (see check_no_entry) and\nwe can add more in future if we wanted to be even more defensive.\n\nI tested this test file with gFortran 7.3.1, 8.3.0, and 9.2.0, I now\nsee 100% pass in all cases.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/info-modules.exp: Rewrite to make use of new\n\tsym-info-cmds library.\n\t* gdb.fortran/info-types.exp: Likewise.\n\t* lib/sym-info-cmds.exp: New file.\n\nChange-Id: Iff81624f51b5afb6c95393932f3d94472d7c2970",
    "tree": {
      "sha": "dfd2c373a27874a7425bd92e3652eccf5d98b4cc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dfd2c373a27874a7425bd92e3652eccf5d98b4cc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d57cbee932f86df06251498daa93154046dc77c0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d57cbee932f86df06251498daa93154046dc77c0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d57cbee932f86df06251498daa93154046dc77c0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d57cbee932f86df06251498daa93154046dc77c0/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b1f0c0b90bc8e93eb2d8592c675cba018ac50739",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b1f0c0b90bc8e93eb2d8592c675cba018ac50739",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b1f0c0b90bc8e93eb2d8592c675cba018ac50739"
    }
  ],
  "stats": {
    "total": 788,
    "additions": 648,
    "deletions": 140
  },
  "files": [
    {
      "sha": "7d41fad6db998d39065762a4d3278a062353578e",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d57cbee932f86df06251498daa93154046dc77c0",
      "patch": "@@ -1,3 +1,10 @@\n+2019-12-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/info-modules.exp: Rewrite to make use of new\n+\tsym-info-cmds library.\n+\t* gdb.fortran/info-types.exp: Likewise.\n+\t* lib/sym-info-cmds.exp: New file.\n+\n 2019-12-08  Tom de Vries  <tdevries@suse.de>\n \n \t* gdb.dwarf2/imported-unit.exp: Fix inter-CU references."
    },
    {
      "sha": "cf20f0a54b01dd146baeb0ee828e5e43bc9fa3ee",
      "filename": "gdb/testsuite/gdb.fortran/info-modules.exp",
      "status": "modified",
      "additions": 121,
      "deletions": 140,
      "changes": 261,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/gdb.fortran/info-modules.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/gdb.fortran/info-modules.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/info-modules.exp?ref=d57cbee932f86df06251498daa93154046dc77c0",
      "patch": "@@ -17,6 +17,7 @@\n # module variables'.\n \n load_lib \"fortran.exp\"\n+load_lib \"sym-info-cmds.exp\"\n \n if { [skip_fortran_tests] } { continue }\n \n@@ -38,150 +39,130 @@ set real4 [fortran_real4]\n \n # Test 'info modules' command.\n \n-gdb_test \"info modules\" \\\n-    [multi_line \\\n-\t \"All defined modules:\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"18:\\[\\t \\]+mod2\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"16:\\[\\t \\]+mod1\" ]\n-\n-gdb_test \"info modules 1\" \\\n-    [multi_line \\\n-\t \"All modules matching regular expression \\\"1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"16:\\[\\t \\]+mod1\" ]\n-\n-gdb_test \"info modules 2\" \\\n-    [multi_line \\\n-\t \"All modules matching regular expression \\\"2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"18:\\[\\t \\]+mod2\" ]\n-\n-gdb_test \"info modules mod\" \\\n-    [multi_line \\\n-\t \"All modules matching regular expression \\\"mod\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"18:\\[\\t \\]+mod2\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"16:\\[\\t \\]+mod1\" ]\n+GDBInfoSymbols::run_command \"info modules\"\n+GDBInfoSymbols::check_header \"All defined modules:\"\n+GDBInfoSymbols::check_entry \"${srcfile2}\" \"18\" \"mod2\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"16\" \"mod1\"\n+GDBInfoSymbols::check_no_entry \"${srcfile}\"\n+GDBInfoSymbols::check_no_entry \"${srcfile2}\"\n+\n+GDBInfoSymbols::run_command \"info modules 1\"\n+GDBInfoSymbols::check_header \\\n+    \"All modules matching regular expression \\\"1\\\":\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"16\" \"mod1\"\n+GDBInfoSymbols::check_no_entry \"${srcfile}\"\n+GDBInfoSymbols::check_no_entry \"${srcfile2}\"\n+\n+GDBInfoSymbols::run_command \"info modules 2\"\n+GDBInfoSymbols::check_header \\\n+    \"All modules matching regular expression \\\"2\\\":\"\n+GDBInfoSymbols::check_entry \"${srcfile2}\" \"18\" \"mod2\"\n+GDBInfoSymbols::check_no_entry \"${srcfile}\"\n+GDBInfoSymbols::check_no_entry \"${srcfile2}\"\n+\n+GDBInfoSymbols::run_command \"info modules mod\"\n+GDBInfoSymbols::check_header \\\n+    \"All modules matching regular expression \\\"mod\\\":\"\n+GDBInfoSymbols::check_entry \"${srcfile2}\" \"18\" \"mod2\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"16\" \"mod1\"\n+GDBInfoSymbols::check_no_entry \"${srcfile}\"\n+GDBInfoSymbols::check_no_entry \"${srcfile2}\"\n \n # Test 'info module functions'.\n \n-gdb_test \"info module functions\" \\\n-    [multi_line \\\n-\t \"All functions in all modules:\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"22:\\[\\t \\]+void mod2::sub_m2_a\\\\(${integer4}, ${logical4}\\\\);\" \\\n-\t \"30:\\[\\t \\]+${logical4} mod2::sub_m2_b\\\\(${real4}\\\\);\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"35:\\[\\t \\]+void mod1::__copy_mod1_M1t1\\\\(Type m1t1, Type m1t1\\\\);\" \\\n-\t \"25:\\[\\t \\]+void mod1::sub_m1_a\\\\(${integer4}\\\\);\" \\\n-\t \"31:\\[\\t \\]+${integer4} mod1::sub_m1_b\\\\(void\\\\);\" ]\n-\n-gdb_test \"info module functions -m mod1\" \\\n-    [multi_line \\\n-\t \"All functions in all modules matching regular expression \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*:\" \\\n-\t \"35:\\[\\t \\]+void mod1::__copy_mod1_M1t1\\\\(Type m1t1, Type m1t1\\\\);\" \\\n-\t \"25:\\[\\t \\]+void mod1::sub_m1_a\\\\(${integer4}\\\\);\" \\\n-\t \"31:\\[\\t \\]+${integer4} mod1::sub_m1_b\\\\(void\\\\);\" ]\n-\n-gdb_test \"info module functions -t integer\" \\\n-    [multi_line \\\n-\t \"All functions with type matching regular expression \\\"integer\\\" in all modules:\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"22:\\[\\t \\]+void mod2::sub_m2_a\\\\(${integer4}, ${logical4}\\\\);\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"25:\\[\\t \\]+void mod1::sub_m1_a\\\\(${integer4}\\\\);\" \\\n-\t \"31:\\[\\t \\]+${integer4} mod1::sub_m1_b\\\\(void\\\\);\" ]\n+GDBInfoModuleSymbols::run_command \"info module functions\"\n+GDBInfoModuleSymbols::check_header \"All functions in all modules:\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"22\" \\\n+    \"void mod2::sub_m2_a\\\\(${integer4}, ${logical4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"30\" \\\n+    \"${logical4} mod2::sub_m2_b\\\\(${real4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"35\" \\\n+    \"void mod1::__copy_mod1_M1t1\\\\(Type m1t1, Type m1t1\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"25\" \\\n+    \"void mod1::sub_m1_a\\\\(${integer4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"31\" \\\n+    \"${integer4} mod1::sub_m1_b\\\\(void\\\\);\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module functions -m mod1\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All functions in all modules matching regular expression \\\"mod1\\\":\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"35\" \\\n+    \"void mod1::__copy_mod1_M1t1\\\\(Type m1t1, Type m1t1\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"25\" \\\n+    \"void mod1::sub_m1_a\\\\(${integer4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"31\" \\\n+    \"${integer4} mod1::sub_m1_b\\\\(void\\\\);\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module functions -t integer\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All functions with type matching regular expression \\\"integer\\\" in all modules:\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"22\" \\\n+    \"void mod2::sub_m2_a\\\\(${integer4}, ${logical4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"25\" \\\n+    \"void mod1::sub_m1_a\\\\(${integer4}\\\\);\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"31\" \\\n+    \"${integer4} mod1::sub_m1_b\\\\(void\\\\);\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n \n # Test 'info module variables'.\n \n-gdb_test \"info module variables\" \\\n-    [multi_line \\\n-\t \"All variables in all modules:\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"19:\\[\\t \\]+${integer4} mod2::mod2_var_1;\" \\\n-\t \"20:\\[\\t \\]+${real4} mod2::mod2_var_2;\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile}:\" \\\n-\t \"35:\\[\\t \\]+Type m1t1 mod1::__def_init_mod1_M1t1;\" \\\n-\t \"35:\\[\\t \\]+Type __vtype_mod1_M1t1 mod1::__vtab_mod1_M1t1;\" \\\n-\t \"21:\\[\\t \\]+${real4} mod1::mod1_var_1;\" \\\n-\t \"22:\\[\\t \\]+${integer4} mod1::mod1_var_2;\" ]\n-\n-gdb_test \"info module variables -t real\" \\\n-    [multi_line \\\n-\t \"All variables with type matching regular expression \\\"real\\\" in all modules:\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*:\" \\\n-\t \"20:\\[\\t \\]+${real4} mod2::mod2_var_2;\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*:\" \\\n-\t \"21:\\[\\t \\]+${real4} mod1::mod1_var_1;\" ]\n-\n-gdb_test \"info module variables -m mod2\" \\\n-    [multi_line \\\n-\t \"All variables in all modules matching regular expression \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"19:\\[\\t \\]+${integer4} mod2::mod2_var_1;\" \\\n-\t \"20:\\[\\t \\]+${real4} mod2::mod2_var_2;\" ]\n-\n-gdb_test \"info module variables -m mod2 -t real\" \\\n-    [multi_line \\\n-\t \"All variables with type matching regular expression \\\"real\\\"\" \\\n-\t \"\tin all modules matching regular expression \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*${srcfile2}:\" \\\n-\t \"20:\\[\\t \\]+${real4} mod2::mod2_var_2;\" ]\n-\n-gdb_test \"info module variables _1\" \\\n-    [multi_line \\\n-\t \"All variables matching regular expression \\\"_1\\\" in all modules:\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod2\\\":\" \\\n-\t \"\" \\\n-\t \"File .*:\" \\\n-\t \"19:\\[\\t \\]+${integer4} mod2::mod2_var_1;\" \\\n-\t \"\" \\\n-\t \"Module \\\"mod1\\\":\" \\\n-\t \"\" \\\n-\t \"File .*:\" \\\n-\t \"21:\\[\\t \\]+${real4} mod1::mod1_var_1;\" ]\n+GDBInfoModuleSymbols::run_command \"info module variables\"\n+GDBInfoModuleSymbols::check_header \"All variables in all modules:\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"19\" \\\n+    \"${integer4} mod2::mod2_var_1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"20\" \\\n+    \"${real4} mod2::mod2_var_2;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"35\" \\\n+    \"Type m1t1 mod1::__def_init_mod1_M1t1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"35\" \\\n+    \"Type __vtype_mod1_M1t1 mod1::__vtab_mod1_M1t1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"21\" \\\n+    \"${real4} mod1::mod1_var_1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"22\" \\\n+    \"${integer4} mod1::mod1_var_2;\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module variables -t real\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All variables with type matching regular expression \\\"real\\\" in all modules:\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"20\" \\\n+    \"${real4} mod2::mod2_var_2;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"21\" \\\n+    \"${real4} mod1::mod1_var_1;\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module variables -m mod2\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All variables in all modules matching regular expression \\\"mod2\\\":\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"19\" \\\n+    \"${integer4} mod2::mod2_var_1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"20\" \\\n+    \"${real4} mod2::mod2_var_2;\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module variables -m mod2 -t real\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All variables with type matching regular expression \\\"real\\\" in all modules matching regular expression \\\"mod2\\\":\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"20\" \\\n+    \"${real4} mod2::mod2_var_2;\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n+\n+GDBInfoModuleSymbols::run_command \"info module variables _1\"\n+GDBInfoModuleSymbols::check_header \\\n+    \"All variables matching regular expression \\\"_1\\\" in all modules:\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile2}\" \"mod2\" \"19\" \\\n+    \"${integer4} mod2::mod2_var_1;\"\n+GDBInfoModuleSymbols::check_entry \"${srcfile}\" \"mod1\" \"21\" \\\n+    \"${real4} mod1::mod1_var_1;\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile}\" \".*\"\n+GDBInfoModuleSymbols::check_no_entry \"${srcfile2}\" \".*\"\n "
    },
    {
      "sha": "a99ac84f19792ce2c13d210ab26278b09054b6b9",
      "filename": "gdb/testsuite/gdb.fortran/info-types.exp",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/gdb.fortran/info-types.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/gdb.fortran/info-types.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/info-types.exp?ref=d57cbee932f86df06251498daa93154046dc77c0",
      "patch": "@@ -16,6 +16,7 @@\n # This file tests 'info types' for some Fortran types.\n \n load_lib \"fortran.exp\"\n+load_lib \"sym-info-cmds.exp\"\n \n if { [skip_fortran_tests] } { continue }\n \n@@ -37,6 +38,18 @@ set logical4 [fortran_logical4]\n set character1 [fortran_character1]\n set real4 [fortran_real4]\n \n+GDBInfoSymbols::run_command \"info types\"\n+GDBInfoSymbols::check_header \"All defined types:\"\n+\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"\" \"${character1}\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"\" \"${integer4}\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"\" \"${logical4}\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"$decimal\" \"Type m1t1;\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"\" \"${real4}\"\n+GDBInfoSymbols::check_entry \"${srcfile}\" \"37\" \"Type s1;\"\n+\n+return 0\n+\n gdb_test \"info types\" \\\n     [multi_line \\\n \t \"All defined types:\" \\"
    },
    {
      "sha": "9c2777d3d19827bc3356719537aedf0b0d4823be",
      "filename": "gdb/testsuite/lib/sym-info-cmds.exp",
      "status": "added",
      "additions": 507,
      "deletions": 0,
      "changes": 507,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/lib/sym-info-cmds.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d57cbee932f86df06251498daa93154046dc77c0/gdb/testsuite/lib/sym-info-cmds.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/sym-info-cmds.exp?ref=d57cbee932f86df06251498daa93154046dc77c0",
      "patch": "@@ -0,0 +1,507 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Make it easier to run the 'info modules' command (using\n+# GDBInfoModules), and the 'info module ...' commands (using\n+# GDBInfoModuleContents) and process the output.\n+#\n+# The difficulty we run into is that different versions of gFortran\n+# include different helper modules which show up in the results.  The\n+# procedures in this library help process those parts of the output we\n+# actually want to check, while ignoring those parts that we don't\n+# care about.\n+#\n+# For each namespace GDBInfoModules and GDBInfoModuleContents, there's\n+# a run_command proc, use this to run a command and capture the\n+# output.  Then make calls to check_header, check_entry, and\n+# check_no_entry to ensure the output was as expected.\n+\n+namespace eval GDBInfoSymbols {\n+\n+    # A string that is the header printed by GDB immediately after the\n+    # 'info [modules|types|functions|variables]' command has been issued.\n+    variable _header\n+\n+    # A list of entries extracted from the output of the command.\n+    # Each entry is a filename, a line number, and the rest of the\n+    # text describing the entry.  If an entry has no line number then\n+    # it is replaced with the text NONE.\n+    variable _entries\n+\n+    # The string that is the complete last command run.\n+    variable _last_command\n+\n+    # Add a new entry to the _entries list.\n+    proc _add_entry { filename lineno text } {\n+\tvariable _entries\n+\n+\tset entry [list $filename $lineno $text]\n+\tlappend _entries $entry\n+    }\n+\n+    # Run the 'info modules' command, passing ARGS as extra arguments\n+    # to the command.  Process the output storing the results within\n+    # the variables in this namespace.\n+    #\n+    # The results of any previous call to run_command are discarded\n+    # when this is called.\n+    proc run_command { cmd { testname \"\" } } {\n+\tglobal gdb_prompt\n+\n+\tvariable _header\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif {![regexp -- \"^info (modules|types|variables|functions)\" $cmd]} {\n+\t    perror \"invalid command\"\n+\t}\n+\n+\tset _header \"\"\n+\tset _entries [list]\n+\tset _last_command $cmd\n+\n+\tif { $testname == \"\" } {\n+\t    set testname $cmd\n+\t}\n+\n+\tsend_gdb \"$cmd\\n\"\n+\tgdb_expect {\n+\t    -re \"^$cmd\\r\\n\" {\n+\t\t# Match the original command echoed back to us.\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tgdb_expect {\n+\t    -re \"^\\r\\n\" {\n+\t\t# Found the blank line after the header, we're done\n+\t\t# parsing the header now.\n+\t    }\n+\t    -re \"^\\[ \\t]*(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset str $expect_out(1,string)\n+\t\tif { $_header == \"\" } {\n+\t\t    set _header $str\n+\t\t} else {\n+\t\t    set _header \"$_header $str\"\n+\t\t}\n+\t\texp_continue\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tset current_file \"\"\n+\tgdb_expect {\n+\t    -re \"^File (\\[^\\r\\n\\]+):\\r\\n\" {\n+\t\tset current_file $expect_out(1,string)\n+\t\texp_continue\n+\t    }\n+\t    -re \"^(\\[0-9\\]+):\\[ \\t\\]+(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset lineno $expect_out(1,string)\n+\t\tset text $expect_out(2,string)\n+\t\tif { $current_file == \"\" } {\n+\t\t    fail \"$testname (missing filename)\"\n+\t\t    return 0\n+\t\t}\n+\t\t_add_entry $current_file $lineno $text\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\[ \\t\\]+(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset lineno \"NONE\"\n+\t\tset text $expect_out(1,string)\n+\t\tif { $current_file == \"\" } {\n+\t\t    fail \"$testname (missing filename)\"\n+\t\t    return 0\n+\t\t}\n+\t\t_add_entry $current_file $lineno $text\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\r\\n\" {\n+\t\texp_continue\n+\t    }\n+\t    -re \"^$gdb_prompt $\" {\n+\t\t# All done.\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tpass $testname\n+\treturn 1\n+    }\n+\n+    # Check that the header held in _header matches PATTERN.  Use\n+    # TESTNAME as the name of the test, or create a suitable default\n+    # test name based on the last command.\n+    proc check_header { pattern { testname \"\" } } {\n+\tvariable _header\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \"$_last_command: check header\"\n+\t}\n+\n+\tgdb_assert {[regexp -- $pattern $_header]} $testname\n+    }\n+\n+    # Check that we have an entry in _entries matching FILENAME,\n+    # LINENO, and TEXT.  If LINENO is the empty string it is replaced\n+    # with the string NONE in order to match a similarly missing line\n+    # number in the output of the command.\n+    #\n+    # TESTNAME is the name of the test, or a default will be created\n+    # based on the last command run and the arguments passed here.\n+    #\n+    # If a matching entry is found then it is removed from the\n+    # _entries list, this allows us to check for duplicates using the\n+    # check_no_entry call.\n+    proc check_entry { filename lineno text { testname \"\" } } {\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \\\n+\t\t\"$_last_command: check for entry '$filename', '$lineno', '$text'\"\n+\t}\n+\n+\tif { $lineno == \"\" } {\n+\t    set lineno \"NONE\"\n+\t}\n+\n+\tset new_entries [list]\n+\n+\tset found_match 0\n+\tforeach entry $_entries {\n+\n+\t    if {!$found_match} {\n+\t\tset f [lindex $entry 0]\n+\t\tset l [lindex $entry 1]\n+\t\tset t [lindex $entry 2]\n+\t\tif { [regexp -- $filename $f] \\\n+\t\t\t && [regexp -- $lineno $l] \\\n+\t\t\t && [regexp -- $text $t] } {\n+\t\t    set found_match 1\n+\t\t} else {\n+\t\t    lappend new_entries $entry\n+\t\t}\n+\t    } else {\n+\t\tlappend new_entries $entry\n+\t    }\n+\t}\n+\n+\tset _entries $new_entries\n+\tgdb_assert { $found_match } $testname\n+    }\n+\n+    # Check that there is no entry in the _entries list matching\n+    # FILENAME, LINENO, and TEXT.  The LINENO and TEXT are optional,\n+    # and will be replaced with '.*' if missing.\n+    #\n+    # If LINENO is the empty string then it will be replaced with the\n+    # string NONE in order to match against missing line numbers in\n+    # the output of the command.\n+    #\n+    # TESTNAME is the name of the test, or a default will be built\n+    # from the last command run and the arguments passed here.\n+    #\n+    # This can be used after a call to check_entry to ensure that\n+    # there are no further matches for a particular file in the\n+    # output.\n+    proc check_no_entry { filename { lineno \".*\" } { text \".*\" } \\\n+\t\t\t      { testname \"\" } } {\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \\\n+\t\t\"$_last_command: check no matches for '$filename', $lineno', and '$text'\"\n+\t}\n+\n+\tif { $lineno == \"\" } {\n+\t    set lineno \"NONE\"\n+\t}\n+\n+\tforeach entry $_entries {\n+\t    set f [lindex $entry 0]\n+\t    set l [lindex $entry 1]\n+\t    set t [lindex $entry 2]\n+\t    if { [regexp -- $filename $f] \\\n+\t\t     && [regexp -- $lineno $l] \\\n+\t\t     && [regexp -- $text $t] } {\n+\t\tfail $testname\n+\t    }\n+\t}\n+\n+\tpass $testname\n+    }\n+}\n+\n+\n+namespace eval GDBInfoModuleSymbols {\n+\n+    # A string that is the header printed by GDB immediately after the\n+    # 'info modules (variables|functions)' command has been issued.\n+    variable _header\n+\n+    # A list of entries extracted from the output of the command.\n+    # Each entry is a filename, a module name, a line number, and the\n+    # rest of the text describing the entry.  If an entry has no line\n+    # number then it is replaced with the text NONE.\n+    variable _entries\n+\n+    # The string that is the complete last command run.\n+    variable _last_command\n+\n+    # Add a new entry to the _entries list.\n+    proc _add_entry { filename module lineno text } {\n+\tvariable _entries\n+\n+\tset entry [list $filename $module $lineno $text]\n+\tlappend _entries $entry\n+    }\n+\n+    # Run the 'info module ....' command, passing ARGS as extra\n+    # arguments to the command.  Process the output storing the\n+    # results within the variables in this namespace.\n+    #\n+    # The results of any previous call to run_command are discarded\n+    # when this is called.\n+    proc run_command { cmd { testname \"\" } } {\n+\tglobal gdb_prompt\n+\n+\tvariable _header\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif {![regexp -- \"^info module (variables|functions)\" $cmd]} {\n+\t    perror \"invalid command: '$cmd'\"\n+\t}\n+\n+\tset _header \"\"\n+\tset _entries [list]\n+\tset _last_command $cmd\n+\n+\tif { $testname == \"\" } {\n+\t    set testname $cmd\n+\t}\n+\n+\tsend_gdb \"$cmd\\n\"\n+\tgdb_expect {\n+\t    -re \"^$cmd\\r\\n\" {\n+\t\t# Match the original command echoed back to us.\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tgdb_expect {\n+\t    -re \"^\\r\\n\" {\n+\t\t# Found the blank line after the header, we're done\n+\t\t# parsing the header now.\n+\t    }\n+\t    -re \"^\\[ \\t\\]*(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset str $expect_out(1,string)\n+\t\tif { $_header == \"\" } {\n+\t\t    set _header $str\n+\t\t} else {\n+\t\t    set _header \"$_header $str\"\n+\t\t}\n+\t\texp_continue\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tset current_module \"\"\n+\tset current_file \"\"\n+\tgdb_expect {\n+\t    -re \"^Module \\\"(\\[^\\\"\\]+)\\\":\\r\\n\" {\n+\t\tset current_module $expect_out(1,string)\n+\t\texp_continue\n+\t    }\n+\t    -re \"^File (\\[^\\r\\n\\]+):\\r\\n\" {\n+\t\tif { $current_module == \"\" } {\n+\t\t    fail \"$testname (missing module)\"\n+\t\t    return 0\n+\t\t}\n+\t\tset current_file $expect_out(1,string)\n+\t\texp_continue\n+\t    }\n+\t    -re \"^(\\[0-9\\]+):\\[ \\t\\]+(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset lineno $expect_out(1,string)\n+\t\tset text $expect_out(2,string)\n+\t\tif { $current_module == \"\" } {\n+\t\t    fail \"$testname (missing module)\"\n+\t\t    return 0\n+\t\t}\n+\t\tif { $current_file == \"\" } {\n+\t\t    fail \"$testname (missing filename)\"\n+\t\t    return 0\n+\t\t}\n+\t\t_add_entry $current_file $current_module \\\n+\t\t    $lineno $text\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\[ \\t\\]+(\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset lineno \"NONE\"\n+\t\tset text $expect_out(1,string)\n+\t\tif { $current_module == \"\" } {\n+\t\t    fail \"$testname (missing module)\"\n+\t\t    return 0\n+\t\t}\n+\t\tif { $current_file == \"\" } {\n+\t\t    fail \"$testname (missing filename)\"\n+\t\t    return 0\n+\t\t}\n+\t\t_add_entry $current_file $current_module \\\n+\t\t    $lineno $text\n+\t\texp_continue\n+\t    }\n+\t    -re \"^\\r\\n\" {\n+\t\texp_continue\n+\t    }\n+\t    -re \"^$gdb_prompt $\" {\n+\t\t# All done.\n+\t    }\n+\t    timeout {\n+\t\tfail \"$testname (timeout)\"\n+\t\treturn 0\n+\t    }\n+\t}\n+\n+\tpass $testname\n+\treturn 1\n+    }\n+\n+    # Check that the header held in _header matches PATTERN.  Use\n+    # TESTNAME as the name of the test, or create a suitable default\n+    # test name based on the last command.\n+    proc check_header { pattern { testname \"\" } } {\n+\tvariable _header\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \"$_last_command: check header\"\n+\t}\n+\n+\tgdb_assert {[regexp -- $pattern $_header]} $testname\n+    }\n+\n+    # Check that we have an entry in _entries matching FILENAME,\n+    # MODULE, LINENO, and TEXT.  If LINENO is the empty string it is\n+    # replaced with the string NONE in order to match a similarly\n+    # missing line number in the output of the command.\n+    #\n+    # TESTNAME is the name of the test, or a default will be created\n+    # based on the last command run and the arguments passed here.\n+    #\n+    # If a matching entry is found then it is removed from the\n+    # _entries list, this allows us to check for duplicates using the\n+    # check_no_entry call.\n+    proc check_entry { filename module lineno text { testname \"\" } } {\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \\\n+\t\t\"$_last_command: check for entry '$filename', '$lineno', '$text'\"\n+\t}\n+\n+\tif { $lineno == \"\" } {\n+\t    set lineno \"NONE\"\n+\t}\n+\n+\tset new_entries [list]\n+\n+\tset found_match 0\n+\tforeach entry $_entries {\n+\n+\t    if {!$found_match} {\n+\t\tset f [lindex $entry 0]\n+\t\tset m [lindex $entry 1]\n+\t\tset l [lindex $entry 2]\n+\t\tset t [lindex $entry 3]\n+\t\tif { [regexp -- $filename $f] \\\n+\t\t\t && [regexp -- $module $m] \\\n+\t\t\t && [regexp -- $lineno $l] \\\n+\t\t\t && [regexp -- $text $t] } {\n+\t\t    set found_match 1\n+\t\t} else {\n+\t\t    lappend new_entries $entry\n+\t\t}\n+\t    } else {\n+\t\tlappend new_entries $entry\n+\t    }\n+\t}\n+\n+\tset _entries $new_entries\n+\tgdb_assert { $found_match } $testname\n+    }\n+\n+    # Check that there is no entry in the _entries list matching\n+    # FILENAME, MODULE, LINENO, and TEXT.  The LINENO and TEXT are\n+    # optional, and will be replaced with '.*' if missing.\n+    #\n+    # If LINENO is the empty string then it will be replaced with the\n+    # string NONE in order to match against missing line numbers in\n+    # the output of the command.\n+    #\n+    # TESTNAME is the name of the test, or a default will be built\n+    # from the last command run and the arguments passed here.\n+    #\n+    # This can be used after a call to check_entry to ensure that\n+    # there are no further matches for a particular file in the\n+    # output.\n+    proc check_no_entry { filename module { lineno \".*\" } \\\n+\t\t\t      { text \".*\" } { testname \"\" } } {\n+\tvariable _entries\n+\tvariable _last_command\n+\n+\tif { $testname == \"\" } {\n+\t    set testname \\\n+\t\t\"$_last_command: check no matches for '$filename', $lineno', and '$text'\"\n+\t}\n+\n+\tif { $lineno == \"\" } {\n+\t    set lineno \"NONE\"\n+\t}\n+\n+\tforeach entry $_entries {\n+\t    set f [lindex $entry 0]\n+\t    set m [lindex $entry 1]\n+\t    set l [lindex $entry 2]\n+\t    set t [lindex $entry 3]\n+\t    if { [regexp -- $filename $f] \\\n+\t\t     && [regexp -- $module $m] \\\n+\t\t     && [regexp -- $lineno $l] \\\n+\t\t     && [regexp -- $text $t] } {\n+\t\tfail $testname\n+\t    }\n+\t}\n+\n+\tpass $testname\n+    }\n+}"
    }
  ]
}