{
  "sha": "f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjhhZWNmM2NjOWEzYzcxYTBmYjlhOGRkY2E4ZjEzMWRkZTY0ODI3Ng==",
  "commit": {
    "author": {
      "name": "Max Filippov",
      "email": "jcmvbkbc@gmail.com",
      "date": "2019-04-10T08:18:01Z"
    },
    "committer": {
      "name": "Max Filippov",
      "email": "jcmvbkbc@gmail.com",
      "date": "2019-04-11T18:40:52Z"
    },
    "message": "xtensa: gas: clean up literal management code\n\ngas/\n2019-04-11  Max Filippov  <jcmvbkbc@gmail.com>\n\n\t* config/tc-xtensa.c (xtensa_literal_pseudo): Drop code that has\n\tno effect.\n\t(get_literal_pool_location): Only search for the literal pool\n\twhen auto litpools is used, otherwise take one recorded in the\n\ttc_segment_info_data.\n\t(xtensa_assign_litpool_addresses): New function.\n\t(xtensa_move_literals): Don't duplicate 'literal pool location\n\trequired...' error message. Call xtensa_assign_litpool_addresses.",
    "tree": {
      "sha": "65c4eb8266a931a7a7c08f6dbadb6d25f4247366",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/65c4eb8266a931a7a7c08f6dbadb6d25f4247366"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276/comments",
  "author": {
    "login": "jcmvbkbc",
    "id": 166731,
    "node_id": "MDQ6VXNlcjE2NjczMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jcmvbkbc",
    "html_url": "https://github.com/jcmvbkbc",
    "followers_url": "https://api.github.com/users/jcmvbkbc/followers",
    "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}",
    "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions",
    "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs",
    "repos_url": "https://api.github.com/users/jcmvbkbc/repos",
    "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jcmvbkbc",
    "id": 166731,
    "node_id": "MDQ6VXNlcjE2NjczMQ==",
    "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jcmvbkbc",
    "html_url": "https://github.com/jcmvbkbc",
    "followers_url": "https://api.github.com/users/jcmvbkbc/followers",
    "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}",
    "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions",
    "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs",
    "repos_url": "https://api.github.com/users/jcmvbkbc/repos",
    "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "548791769dc737f05cb12e5ee4190b7e853beac9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/548791769dc737f05cb12e5ee4190b7e853beac9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/548791769dc737f05cb12e5ee4190b7e853beac9"
    }
  ],
  "stats": {
    "total": 125,
    "additions": 65,
    "deletions": 60
  },
  "files": [
    {
      "sha": "52dd5f32160224d690332e13fa07832fb3e7ecdd",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
      "patch": "@@ -1,3 +1,14 @@\n+2019-04-11  Max Filippov  <jcmvbkbc@gmail.com>\n+\n+\t* config/tc-xtensa.c (xtensa_literal_pseudo): Drop code that has\n+\tno effect.\n+\t(get_literal_pool_location): Only search for the literal pool\n+\twhen auto litpools is used, otherwise take one recorded in the\n+\ttc_segment_info_data.\n+\t(xtensa_assign_litpool_addresses): New function.\n+\t(xtensa_move_literals): Don't duplicate 'literal pool location\n+\trequired...' error message. Call xtensa_assign_litpool_addresses.\n+\n 2019-04-11  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* config/tc-xtensa.c (xtensa_is_init_fini): Add declaration."
    },
    {
      "sha": "458cba9bae22f328411e6a0645710f3d8a5dd4a4",
      "filename": "gas/config/tc-xtensa.c",
      "status": "modified",
      "additions": 54,
      "deletions": 60,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276/gas/config/tc-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276/gas/config/tc-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-xtensa.c?ref=f8aecf3cc9a3c71a0fb9a8ddca8f131dde648276",
      "patch": "@@ -1531,7 +1531,6 @@ xtensa_literal_pseudo (int ignored ATTRIBUTE_UNUSED)\n   emit_state state;\n   char *p, *base_name;\n   char c;\n-  segT dest_seg;\n \n   if (inside_directive (directive_literal))\n     {\n@@ -1547,21 +1546,10 @@ xtensa_literal_pseudo (int ignored ATTRIBUTE_UNUSED)\n   saved_insn_labels = insn_labels;\n   insn_labels = NULL;\n \n-  /* If we are using text-section literals, then this is the right value... */\n-  dest_seg = now_seg;\n-\n   base_name = input_line_pointer;\n \n   xtensa_switch_to_literal_fragment (&state);\n \n-  /* ...but if we aren't using text-section-literals, then we\n-     need to put them in the section we just switched to.  */\n-  if (use_literal_section || directive_state[directive_absolute_literals])\n-    dest_seg = now_seg;\n-\n-  /* FIXME, despite the previous comments, dest_seg is unused...  */\n-  (void) dest_seg;\n-\n   /* All literals are aligned to four-byte boundaries.  */\n   frag_align (2, 0, 0);\n   record_alignment (now_seg, 2);\n@@ -4902,29 +4890,32 @@ get_expanded_loop_offset (xtensa_opcode opcode)\n static fragS *\n get_literal_pool_location (segT seg)\n {\n-  struct litpool_seg *lps = litpool_seg_list.next;\n-  struct litpool_frag *lpf;\n-  for ( ; lps && lps->seg->id != seg->id; lps = lps->next)\n-    ;\n-  if (lps)\n+  if (auto_litpools)\n     {\n-      for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n-\t{ /* Skip \"candidates\" for now.  */\n-\t  if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_BEGIN &&\n-\t      lpf->priority == 1)\n-\t    return lpf->fragP;\n-\t}\n-      /* Must convert a lower-priority pool.  */\n-      for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n+      struct litpool_seg *lps = litpool_seg_list.next;\n+      struct litpool_frag *lpf;\n+      for ( ; lps && lps->seg->id != seg->id; lps = lps->next)\n+\t;\n+      if (lps)\n \t{\n-\t  if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_BEGIN)\n-\t    return lpf->fragP;\n-\t}\n-      /* Still no match -- try for a low priority pool.  */\n-      for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n-\t{\n-\t  if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_CANDIDATE_BEGIN)\n-\t    return lpf->fragP;\n+\t  for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n+\t    { /* Skip \"candidates\" for now.  */\n+\t      if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_BEGIN &&\n+\t\t  lpf->priority == 1)\n+\t\treturn lpf->fragP;\n+\t    }\n+\t  /* Must convert a lower-priority pool.  */\n+\t  for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n+\t    {\n+\t      if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_BEGIN)\n+\t\treturn lpf->fragP;\n+\t    }\n+\t  /* Still no match -- try for a low priority pool.  */\n+\t  for (lpf = lps->frag_list.prev; lpf->fragP; lpf = lpf->prev)\n+\t    {\n+\t      if (lpf->fragP->fr_subtype == RELAX_LITERAL_POOL_CANDIDATE_BEGIN)\n+\t\treturn lpf->fragP;\n+\t    }\n \t}\n     }\n   return seg_info (seg)->tc_segment_info_data.literal_pool_loc;\n@@ -11169,29 +11160,9 @@ static bfd_boolean xtensa_is_init_fini (segT seg)\n }\n \n static void\n-xtensa_move_literals (void)\n+xtensa_assign_litpool_addresses (void)\n {\n-  seg_list *segment;\n-  frchainS *frchain_from, *frchain_to;\n-  fragS *search_frag, *next_frag, *literal_pool, *insert_after;\n-  fragS **frag_splice;\n-  emit_state state;\n-  segT dest_seg;\n-  fixS *fix, *next_fix, **fix_splice;\n-  sym_list *lit;\n   struct litpool_seg *lps;\n-  const char *init_name = INIT_SECTION_NAME;\n-  const char *fini_name = FINI_SECTION_NAME;\n-  int init_name_len = strlen(init_name);\n-  int fini_name_len = strlen(fini_name);\n-\n-  mark_literal_frags (literal_head->next);\n-\n-  if (use_literal_section)\n-    return;\n-\n-  /* Assign addresses (rough estimates) to the potential literal pool locations\n-     and create new ones if the gaps are too large.  */\n \n   for (lps = litpool_seg_list.next; lps; lps = lps->next)\n     {\n@@ -11248,7 +11219,35 @@ xtensa_move_literals (void)\n \t    }\n \t}\n     }\n+}\n \n+static void\n+xtensa_move_literals (void)\n+{\n+  seg_list *segment;\n+  frchainS *frchain_from, *frchain_to;\n+  fragS *search_frag, *next_frag, *literal_pool, *insert_after;\n+  fragS **frag_splice;\n+  emit_state state;\n+  segT dest_seg;\n+  fixS *fix, *next_fix, **fix_splice;\n+  sym_list *lit;\n+  const char *init_name = INIT_SECTION_NAME;\n+  const char *fini_name = FINI_SECTION_NAME;\n+  int init_name_len = strlen(init_name);\n+  int fini_name_len = strlen(fini_name);\n+\n+  mark_literal_frags (literal_head->next);\n+\n+  if (use_literal_section)\n+    return;\n+\n+  /* Assign addresses (rough estimates) to the potential literal pool locations\n+     and create new ones if the gaps are too large.  */\n+\n+  xtensa_assign_litpool_addresses ();\n+\n+  /* Walk through the literal segments.  */\n   for (segment = literal_head->next; segment; segment = segment->next)\n     {\n       const char *seg_name = segment_name (segment->seg);\n@@ -11274,12 +11273,7 @@ xtensa_move_literals (void)\n \t}\n \n       if (!search_frag)\n-\t{\n-\t  search_frag = frchain_from->frch_root;\n-\t  as_bad_where (search_frag->fr_file, search_frag->fr_line,\n-\t\t\t_(\"literal pool location required for text-section-literals; specify with .literal_position\"));\n-\t  continue;\n-\t}\n+\tcontinue;\n \n       gas_assert (search_frag->tc_frag_data.literal_frag->fr_subtype\n \t      == RELAX_LITERAL_POOL_BEGIN);"
    }
  ]
}