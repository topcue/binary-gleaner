{
  "sha": "99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTlhM2IxZTc3YjZiZDVmZGNhNTg3NGQzMjc2YWI5NDk5MzA4YmMwOA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:34Z"
    },
    "message": "Introduce ada_var_value_operation\n\nThis adds class ada_var_value_operation, which implements OP_VAR_VALUE\nfor Ada.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_var_value_operation::evaluate_for_cast)\n\t(ada_var_value_operation::evaluate): New methods.\n\t* ada-exp.h (class ada_var_value_operation): New.",
    "tree": {
      "sha": "c5a36d4b92aaa0c2879c84923d402042629d4a04",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c5a36d4b92aaa0c2879c84923d402042629d4a04"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "60fa02ca6fdaaf3f0afef842a4eb6b13286828a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/60fa02ca6fdaaf3f0afef842a4eb6b13286828a5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/60fa02ca6fdaaf3f0afef842a4eb6b13286828a5"
    }
  ],
  "stats": {
    "total": 139,
    "additions": 139,
    "deletions": 0
  },
  "files": [
    {
      "sha": "adf910fddbdb76a7bef5337a71280176e1b7be69",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
      "patch": "@@ -1,3 +1,9 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_var_value_operation::evaluate_for_cast)\n+\t(ada_var_value_operation::evaluate): New methods.\n+\t* ada-exp.h (class ada_var_value_operation): New.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_unop_atr_operation::evaluate): New method."
    },
    {
      "sha": "0f2f62f5978ba67e877664d5cf32ef2a859c6a9d",
      "filename": "gdb/ada-exp.h",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ada-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ada-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.h?ref=99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
      "patch": "@@ -283,6 +283,27 @@ class ada_unop_atr_operation\n   { return std::get<1> (m_storage); }\n };\n \n+/* Variant of var_value_operation for Ada.  */\n+class ada_var_value_operation\n+  : public var_value_operation\n+{\n+public:\n+\n+  using var_value_operation::var_value_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+\n+  value *evaluate_for_cast (struct type *expect_type,\n+\t\t\t    struct expression *exp,\n+\t\t\t    enum noside noside) override;\n+\n+protected:\n+\n+  using operation::do_generate_ax;\n+};\n+\n } /* namespace expr */\n \n #endif /* ADA_EXP_H */"
    },
    {
      "sha": "ee8e8e12d0d1574fbc5e408818331d12d89bcea6",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 112,
      "deletions": 0,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99a3b1e77b6bd5fdca5874d3276ab9499308bc08/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=99a3b1e77b6bd5fdca5874d3276ab9499308bc08",
      "patch": "@@ -10553,6 +10553,118 @@ ada_unop_atr_operation::evaluate (struct type *expect_type,\n \t\t       val, type_arg, std::get<2> (m_storage));\n }\n \n+value *\n+ada_var_value_operation::evaluate_for_cast (struct type *expect_type,\n+\t\t\t\t\t    struct expression *exp,\n+\t\t\t\t\t    enum noside noside)\n+{\n+  value *val = evaluate_var_value (noside,\n+\t\t\t\t   std::get<1> (m_storage),\n+\t\t\t\t   std::get<0> (m_storage));\n+\n+  val = ada_value_cast (expect_type, val);\n+\n+  /* Follow the Ada language semantics that do not allow taking\n+     an address of the result of a cast (view conversion in Ada).  */\n+  if (VALUE_LVAL (val) == lval_memory)\n+    {\n+      if (value_lazy (val))\n+\tvalue_fetch_lazy (val);\n+      VALUE_LVAL (val) = not_lval;\n+    }\n+  return val;\n+}\n+\n+value *\n+ada_var_value_operation::evaluate (struct type *expect_type,\n+\t\t\t\t   struct expression *exp,\n+\t\t\t\t   enum noside noside)\n+{\n+  symbol *sym = std::get<0> (m_storage);\n+\n+  if (SYMBOL_DOMAIN (sym) == UNDEF_DOMAIN)\n+    /* Only encountered when an unresolved symbol occurs in a\n+       context other than a function call, in which case, it is\n+       invalid.  */\n+    error (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n+\t   sym->print_name ());\n+\n+  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+    {\n+      struct type *type = static_unwrap_type (SYMBOL_TYPE (sym));\n+      /* Check to see if this is a tagged type.  We also need to handle\n+\t the case where the type is a reference to a tagged type, but\n+\t we have to be careful to exclude pointers to tagged types.\n+\t The latter should be shown as usual (as a pointer), whereas\n+\t a reference should mostly be transparent to the user.  */\n+      if (ada_is_tagged_type (type, 0)\n+\t  || (type->code () == TYPE_CODE_REF\n+\t      && ada_is_tagged_type (TYPE_TARGET_TYPE (type), 0)))\n+\t{\n+\t  /* Tagged types are a little special in the fact that the real\n+\t     type is dynamic and can only be determined by inspecting the\n+\t     object's tag.  This means that we need to get the object's\n+\t     value first (EVAL_NORMAL) and then extract the actual object\n+\t     type from its tag.\n+\n+\t     Note that we cannot skip the final step where we extract\n+\t     the object type from its tag, because the EVAL_NORMAL phase\n+\t     results in dynamic components being resolved into fixed ones.\n+\t     This can cause problems when trying to print the type\n+\t     description of tagged types whose parent has a dynamic size:\n+\t     We use the type name of the \"_parent\" component in order\n+\t     to print the name of the ancestor type in the type description.\n+\t     If that component had a dynamic size, the resolution into\n+\t     a fixed type would result in the loss of that type name,\n+\t     thus preventing us from printing the name of the ancestor\n+\t     type in the type description.  */\n+\t  value *arg1 = var_value_operation::evaluate (nullptr, exp,\n+\t\t\t\t\t\t       EVAL_NORMAL);\n+\n+\t  if (type->code () != TYPE_CODE_REF)\n+\t    {\n+\t      struct type *actual_type;\n+\n+\t      actual_type = type_from_tag (ada_value_tag (arg1));\n+\t      if (actual_type == NULL)\n+\t\t/* If, for some reason, we were unable to determine\n+\t\t   the actual type from the tag, then use the static\n+\t\t   approximation that we just computed as a fallback.\n+\t\t   This can happen if the debugging information is\n+\t\t   incomplete, for instance.  */\n+\t\tactual_type = type;\n+\t      return value_zero (actual_type, not_lval);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* In the case of a ref, ada_coerce_ref takes care\n+\t\t of determining the actual type.  But the evaluation\n+\t\t should return a ref as it should be valid to ask\n+\t\t for its address; so rebuild a ref after coerce.  */\n+\t      arg1 = ada_coerce_ref (arg1);\n+\t      return value_ref (arg1, TYPE_CODE_REF);\n+\t    }\n+\t}\n+\n+      /* Records and unions for which GNAT encodings have been\n+\t generated need to be statically fixed as well.\n+\t Otherwise, non-static fixing produces a type where\n+\t all dynamic properties are removed, which prevents \"ptype\"\n+\t from being able to completely describe the type.\n+\t For instance, a case statement in a variant record would be\n+\t replaced by the relevant components based on the actual\n+\t value of the discriminants.  */\n+      if ((type->code () == TYPE_CODE_STRUCT\n+\t   && dynamic_template_type (type) != NULL)\n+\t  || (type->code () == TYPE_CODE_UNION\n+\t      && ada_find_parallel_type (type, \"___XVU\") != NULL))\n+\treturn value_zero (to_static_fixed_type (type), not_lval);\n+    }\n+\n+  value *arg1 = var_value_operation::evaluate (expect_type, exp, noside);\n+  return ada_to_fixed_value (arg1);\n+}\n+\n }\n \n /* Implement the evaluate_exp routine in the exp_descriptor structure"
    }
  ]
}