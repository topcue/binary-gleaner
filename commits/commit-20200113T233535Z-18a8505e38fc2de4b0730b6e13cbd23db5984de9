{
  "sha": "18a8505e38fc2de4b0730b6e13cbd23db5984de9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MThhODUwNWUzOGZjMmRlNGIwNzMwYjZlMTNjYmQyM2RiNTk4NGRlOQ==",
  "commit": {
    "author": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2019-12-24T03:31:24Z"
    },
    "committer": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2020-01-13T23:35:35Z"
    },
    "message": "Dwarf 5: Handle debug_str_offsets and indexed attributes that have base offsets.\n\n* Process debug_str_offsets section. Handle DW_AT_str_offsets_base attribute and\nkeep the value in dwarf2_cu.\n\n* Make addr_base field in dwarf2_cu optional to disambiguate 0 value\n(absent or present and 0).\n\n* During parsing, there is no guarantee that DW_AT_str_offsets_base and\nDW_AT_rnglists_base fields will be processed before the attributes that need\nthose values for correct computation. So make two passes, on the first one mark\nthe attributes that depend on *_base attributes and process only the others.\nOn the second pass, only process the attributes that are marked on the first\npass.\n\n* For string attributes, differentiate between addresses that directly point to\na string and those that point to an offset in debug_str_offsets section.\n\n* There are now two attributes, DW_AT_addr_base and DW_AT_GNU_addr_base to read\naddress offset base. Likewise, there are two attributes, DW_AT_rnglists_base\nand DW_AT_GNU_ranges_base to read ranges base. Since there is no guarantee which\nones the compiler will generate, create helper functions to handle all cases.\n\nTested with CC=/usr/bin/gcc (version 8.3.0) against master branch (also with\n-gsplit-dwarf and -gdwarf-4 flags) and there was no increase in the set of\ntests that fails. (gdb still cannot debug a 'hello world' program with DWARF 5,\nso for the time being, this is all we care about).\n\nThis is part of an effort to support DWARF-5 in gdb.",
    "tree": {
      "sha": "f122269b54afe1509c4e855301a489108ddb2d2c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f122269b54afe1509c4e855301a489108ddb2d2c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/18a8505e38fc2de4b0730b6e13cbd23db5984de9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/18a8505e38fc2de4b0730b6e13cbd23db5984de9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/18a8505e38fc2de4b0730b6e13cbd23db5984de9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/18a8505e38fc2de4b0730b6e13cbd23db5984de9/comments",
  "author": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0cac9354bfb07a5cf53d70dbefaa35c6afa7da0a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0cac9354bfb07a5cf53d70dbefaa35c6afa7da0a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0cac9354bfb07a5cf53d70dbefaa35c6afa7da0a"
    }
  ],
  "stats": {
    "total": 374,
    "additions": 282,
    "deletions": 92
  },
  "files": [
    {
      "sha": "7a1c81da07f9a2b4c8b3001b9fe5a3b254144b5c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=18a8505e38fc2de4b0730b6e13cbd23db5984de9",
      "patch": "@@ -1,3 +1,54 @@\n+\n+2020-01-13  Ali Tamur <tamur@google.com>\n+\n+\t* dwarf2read.c (dwarf2_debug_sections): Add debug_str_offsets sections.\n+\t(dwarf2_cu): Add str_offsets_base field.  Change the type of addr_base\n+\tto gdb::optional.  Update comments.\n+\t(dwo_file): Update comments.\n+\t(read_attribute): Update API to take an additional out parameter,\n+\tneed_reprocess.  This is used to mark attributes that need other\n+\tattributes (e.g. str_offsets_base) for correct computation which may not\n+\thave been read yet.\n+\t(read_attribute_reprocess): New function declaration.\n+\t(read_addr_index): Likewise.\n+\t(read_dwo_str_index): Likewise.\n+\t(read_stub_str_index): Likewise.\n+\t(dwarf2_per_objfile::locate_sections): Handle debug_str_offsets section.\n+\t(lookup_addr_base): New function definition.\n+\t(lookup_ranges_base): Likewise.\n+\t(read_cutu_die_from_dwo): Use the new functions: lookup_addr_base,\n+\tlookup_ranges_base.\n+\t(init_cutu_and_read_dies): Update comments.\n+\t(init_cutu_and_read_dies_no_follow): Change API to take parent compile\n+\tunit.  This is used to inherit parent's str_offsets_base and addr_base.\n+\tUpdate comments.\n+\t(init_cutu_and_read_dies_simple): Reflect API changes.\n+\t(skip_one_die): Reflect API changes.  Handle DW_FORM_rnglistx.\n+\t(create_cus_hash_table): Change API to take parent compile unit.  \n+\tReflect API changes.\n+\t(open_and_init_dwo_file): Reflect API changes.\n+\t(dwarf2_get_pc_bounds): Update comments.\n+\t(dwarf2_record_block_ranges): Likewise.\n+\t(read_full_die_1): Change implementation to reprocess attributes that\n+\tneed str_offsets_base and addr_base.\n+\t(partial_die_info::read): Likewise.\n+\t(read_attribute_reprocess): New function definition.\n+\t(read_attribute_value): Change API to take an additional out parameter,\n+\tneed_reprocess.  Handle DW_FORM_rnglistx.  No longer trigger an error\n+\twhen a non-dwo compile unit has index based attributes.\n+\t(read_attribute): Reflect API changes.\n+\t(read_addr_index_1): Reflect API changes.  Update comments.\n+\t(dwarf2_read_addr_index_data): Reflect API changes.\n+\t(dwarf2_read_addr_index): Likewise.\n+\t(read_str_index): Change API and implementation.  This becomes a helper\n+\tto be used by the new string index related methods.  Update error\n+\tmessage and comments.\n+\t(read_dwo_str_index): New function definition.\n+\t(read_stub_str_index): Likewise.\n+\t* dwarf2read.h (dwarf2_per_objfile): Add str_offsets field.\n+\t* symfile.h (dwarf2_debug_sections): Likewise.\n+\t* xcoffread.c (dwarf2_debug_sections): Likewise.\n+\n 2020-01-13  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbcore.h (struct core_fns) <core_read_registers>: Change"
    },
    {
      "sha": "d1b65b7bc37bf6908155692c90e0c8d9fa1baf8e",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 228,
      "deletions": 92,
      "changes": 320,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=18a8505e38fc2de4b0730b6e13cbd23db5984de9",
      "patch": "@@ -287,6 +287,7 @@ static const struct dwarf2_debug_sections dwarf2_elf_names =\n   { \".debug_macinfo\", \".zdebug_macinfo\" },\n   { \".debug_macro\", \".zdebug_macro\" },\n   { \".debug_str\", \".zdebug_str\" },\n+  { \".debug_str_offsets\", \".zdebug_str_offsets\" },\n   { \".debug_line_str\", \".zdebug_line_str\" },\n   { \".debug_ranges\", \".zdebug_ranges\" },\n   { \".debug_rnglists\", \".zdebug_rnglists\" },\n@@ -500,27 +501,25 @@ struct dwarf2_cu\n      There is an invariant here that is important to remember:\n      Except for attributes copied from the top level DIE in the \"main\"\n      (or \"stub\") file in preparation for reading the DWO file\n-     (e.g., DW_AT_GNU_addr_base), we KISS: there is only *one* CU.\n+     (e.g., DW_AT_addr_base), we KISS: there is only *one* CU.\n      Either there isn't a DWO file (in which case this is NULL and the point\n      is moot), or there is and either we're not going to read it (in which\n      case this is NULL) or there is and we are reading it (in which case this\n      is non-NULL).  */\n   struct dwo_unit *dwo_unit = nullptr;\n \n-  /* The DW_AT_addr_base attribute if present, zero otherwise\n-     (zero is a valid value though).\n+  /* The DW_AT_addr_base (DW_AT_GNU_addr_base) attribute if present.\n      Note this value comes from the Fission stub CU/TU's DIE.  */\n-  ULONGEST addr_base = 0;\n+  gdb::optional<ULONGEST> addr_base;\n \n-  /* The DW_AT_ranges_base attribute if present, zero otherwise\n-     (zero is a valid value though).\n+  /* The DW_AT_rnglists_base attribute if present.\n      Note this value comes from the Fission stub CU/TU's DIE.\n      Also note that the value is zero in the non-DWO case so this value can\n      be used without needing to know whether DWO files are in use or not.\n      N.B. This does not apply to DW_AT_ranges appearing in\n      DW_TAG_compile_unit dies.  This is a bit of a wart, consider if ever\n      DW_AT_ranges appeared in the DW_TAG_compile_unit of DWO DIEs: then\n-     DW_AT_ranges_base *would* have to be applied, and we'd have to care\n+     DW_AT_rnglists_base *would* have to be applied, and we'd have to care\n      whether the DW_AT_ranges attribute came from the skeleton or DWO.  */\n   ULONGEST ranges_base = 0;\n \n@@ -532,6 +531,12 @@ struct dwarf2_cu\n      all such types here and process them after expansion.  */\n   std::vector<struct type *> rust_unions;\n \n+  /* The DW_AT_str_offsets_base attribute if present.  For DWARF 4 version DWO\n+     files, the value is implicitly zero.  For DWARF 5 version DWO files, the\n+     value is often implicit and is the size of the header of\n+     .debug_str_offsets section (8 or 4, depending on the address size).  */\n+  gdb::optional<ULONGEST> str_offsets_base;\n+\n   /* Mark used when releasing cached dies.  */\n   bool mark : 1;\n \n@@ -697,7 +702,7 @@ struct dwo_file\n   dwo_file () = default;\n   DISABLE_COPY_AND_ASSIGN (dwo_file);\n \n-  /* The DW_AT_GNU_dwo_name attribute.\n+  /* The DW_AT_GNU_dwo_name or DW_AT_dwo_name attribute.\n      For virtual DWO files the name is constructed from the section offsets\n      of abbrev,line,loc,str_offsets so that we combine virtual DWO files\n      from related CU+TUs.  */\n@@ -1510,7 +1515,12 @@ static const struct cu_partial_die_info find_partial_die (sect_offset, int,\n \n static const gdb_byte *read_attribute (const struct die_reader_specs *,\n \t\t\t\t       struct attribute *, struct attr_abbrev *,\n-\t\t\t\t       const gdb_byte *);\n+\t\t\t\t       const gdb_byte *, bool *need_reprocess);\n+\n+static void read_attribute_reprocess (const struct die_reader_specs *reader,\n+\t\t\t\t      struct attribute *attr);\n+\n+static CORE_ADDR read_addr_index (struct dwarf2_cu *cu, unsigned int addr_index);\n \n static unsigned int read_1_byte (bfd *, const gdb_byte *);\n \n@@ -1569,8 +1579,11 @@ static CORE_ADDR read_addr_index_from_leb128 (struct dwarf2_cu *,\n \t\t\t\t\t      const gdb_byte *,\n \t\t\t\t\t      unsigned int *);\n \n-static const char *read_str_index (const struct die_reader_specs *reader,\n-\t\t\t\t   ULONGEST str_index);\n+static const char *read_dwo_str_index (const struct die_reader_specs *reader,\n+\t\t\t\t       ULONGEST str_index);\n+\n+static const char *read_stub_str_index (struct dwarf2_cu *cu,\n+\t\t\t\t\tULONGEST str_index);\n \n static void set_cu_language (unsigned int, struct dwarf2_cu *);\n \n@@ -2403,6 +2416,11 @@ dwarf2_per_objfile::locate_sections (bfd *abfd, asection *sectp,\n       this->str.s.section = sectp;\n       this->str.size = bfd_section_size (sectp);\n     }\n+  else if (section_is_p (sectp->name, &names.str_offsets))\n+    {\n+      this->str_offsets.s.section = sectp;\n+      this->str_offsets.size = bfd_section_size (sectp);\n+    }\n   else if (section_is_p (sectp->name, &names.line_str))\n     {\n       this->line_str.s.section = sectp;\n@@ -7171,7 +7189,35 @@ lookup_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n       return entry;\n     }\n }\n-\f\n+\n+/* Return the address base of the compile unit, which, if exists, is stored\n+   either at the attribute DW_AT_GNU_addr_base, or DW_AT_addr_base.  */\n+static gdb::optional<ULONGEST>\n+lookup_addr_base (struct die_info *comp_unit_die)\n+{\n+  struct attribute *attr;\n+  attr = dwarf2_attr_no_follow (comp_unit_die, DW_AT_addr_base);\n+  if (attr == nullptr)\n+    attr = dwarf2_attr_no_follow (comp_unit_die, DW_AT_GNU_addr_base);\n+  if (attr == nullptr)\n+    return gdb::optional<ULONGEST> ();\n+  return DW_UNSND (attr);\n+}\n+\n+/* Return range lists base of the compile unit, which, if exists, is stored\n+   either at the attribute DW_AT_rnglists_base or DW_AT_GNU_ranges_base.  */\n+static ULONGEST\n+lookup_ranges_base (struct die_info *comp_unit_die)\n+{\n+  struct attribute *attr;\n+  attr = dwarf2_attr_no_follow (comp_unit_die, DW_AT_rnglists_base);\n+  if (attr == nullptr)\n+    attr = dwarf2_attr_no_follow (comp_unit_die, DW_AT_GNU_ranges_base);\n+  if (attr == nullptr)\n+    return 0;\n+  return DW_UNSND (attr);\n+}\n+\n /* Low level DIE reading support.  */\n \n /* Initialize a die_reader_specs struct from a dwarf2_cu struct.  */\n@@ -7232,7 +7278,6 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n   struct attribute *comp_dir, *stmt_list, *low_pc, *high_pc, *ranges;\n   int i,num_extra_attrs;\n   struct dwarf2_section_info *dwo_abbrev_section;\n-  struct attribute *attr;\n   struct die_info *comp_unit_die;\n \n   /* At most one of these may be provided.  */\n@@ -7263,20 +7308,12 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n       ranges = dwarf2_attr (stub_comp_unit_die, DW_AT_ranges, cu);\n       comp_dir = dwarf2_attr (stub_comp_unit_die, DW_AT_comp_dir, cu);\n \n-      /* There should be a DW_AT_addr_base attribute here (if needed).\n-\t We need the value before we can process DW_FORM_GNU_addr_index\n-         or DW_FORM_addrx.  */\n-      cu->addr_base = 0;\n-      attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_addr_base, cu);\n-      if (attr != nullptr)\n-\tcu->addr_base = DW_UNSND (attr);\n+      cu->addr_base = lookup_addr_base (stub_comp_unit_die);\n \n-      /* There should be a DW_AT_ranges_base attribute here (if needed).\n-\t We need the value before we can process DW_AT_ranges.  */\n-      cu->ranges_base = 0;\n-      attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_ranges_base, cu);\n-      if (attr != nullptr)\n-\tcu->ranges_base = DW_UNSND (attr);\n+      /* There should be a DW_AT_rnglists_base (DW_AT_GNU_ranges_base) attribute\n+\t here (if needed). We need the value before we can process\n+\t DW_AT_ranges.  */\n+      cu->ranges_base = lookup_ranges_base (stub_comp_unit_die);\n     }\n   else if (stub_comp_dir != NULL)\n     {\n@@ -7747,9 +7784,9 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n     }\n }\n \n-/* Read CU/TU THIS_CU but do not follow DW_AT_GNU_dwo_name if present.\n-   DWO_FILE, if non-NULL, is the DWO file to read (the caller is assumed\n-   to have already done the lookup to find the DWO file).\n+/* Read CU/TU THIS_CU but do not follow DW_AT_GNU_dwo_name (DW_AT_dwo_name)\n+   if present. DWO_FILE, if non-NULL, is the DWO file to read (the caller is\n+   assumed to have already done the lookup to find the DWO file).\n \n    The caller is required to fill in THIS_CU->section, THIS_CU->offset, and\n    THIS_CU->is_debug_types, but nothing else.\n@@ -7761,10 +7798,14 @@ init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,\n \n    THIS_CU->cu is always freed when done.\n    This is done in order to not leave THIS_CU->cu in a state where we have\n-   to care whether it refers to the \"main\" CU or the DWO CU.  */\n+   to care whether it refers to the \"main\" CU or the DWO CU.\n+\n+   When parent_cu is passed, it is used to provide a default value for\n+   str_offsets_base and addr_base from the parent.  */\n \n static void\n init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,\n+\t\t\t\t   struct dwarf2_cu *parent_cu,\n \t\t\t\t   struct dwo_file *dwo_file,\n \t\t\t\t   die_reader_func_ftype *die_reader_func,\n \t\t\t\t   void *data)\n@@ -7803,6 +7844,11 @@ init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,\n \t\t\t\t\t     ? rcuh_kind::TYPE\n \t\t\t\t\t     : rcuh_kind::COMPILE));\n \n+  if (parent_cu != nullptr)\n+    {\n+      cu.str_offsets_base = parent_cu->str_offsets_base;\n+      cu.addr_base = parent_cu->addr_base;\n+    }\n   this_cu->length = get_cu_length (&cu.header);\n \n   /* Skip dummy compilation units.  */\n@@ -7820,8 +7866,8 @@ init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,\n   die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);\n }\n \n-/* Read a CU/TU, except that this does not look for DW_AT_GNU_dwo_name and\n-   does not lookup the specified DWO file.\n+/* Read a CU/TU, except that this does not look for DW_AT_GNU_dwo_name\n+   (DW_AT_dwo_name) and does not lookup the specified DWO file.\n    This cannot be used to read DWO files.\n \n    THIS_CU->cu is always freed when done.\n@@ -7834,7 +7880,7 @@ init_cutu_and_read_dies_simple (struct dwarf2_per_cu_data *this_cu,\n \t\t\t\tdie_reader_func_ftype *die_reader_func,\n \t\t\t\tvoid *data)\n {\n-  init_cutu_and_read_dies_no_follow (this_cu, NULL, die_reader_func, data);\n+  init_cutu_and_read_dies_no_follow (this_cu, NULL, NULL, die_reader_func, data);\n }\n \f\n /* Type Unit Groups.\n@@ -9337,7 +9383,9 @@ skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,\n       /* The only abbrev we care about is DW_AT_sibling.  */\n       if (abbrev->attrs[i].name == DW_AT_sibling)\n \t{\n-\t  read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr);\n+\t  bool ignored;\n+\t  read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr,\n+\t\t\t  &ignored);\n \t  if (attr.form == DW_FORM_ref_addr)\n \t    complaint (_(\"ignoring absolute DW_AT_sibling\"));\n \t  else\n@@ -9433,6 +9481,7 @@ skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,\n \tcase DW_FORM_ref_udata:\n \tcase DW_FORM_GNU_addr_index:\n \tcase DW_FORM_GNU_str_index:\n+\tcase DW_FORM_rnglistx:\n \t  info_ptr = safe_skip_leb128 (info_ptr, buffer_end);\n \t  break;\n \tcase DW_FORM_indirect:\n@@ -11974,8 +12023,8 @@ create_dwo_cu_reader (const struct die_reader_specs *reader,\n \n static void\n create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t       struct dwo_file &dwo_file, dwarf2_section_info &section,\n-\t\t       htab_t &cus_htab)\n+\t\t       dwarf2_cu *cu, struct dwo_file &dwo_file,\n+\t\t       dwarf2_section_info &section, htab_t &cus_htab)\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   const gdb_byte *info_ptr, *end_ptr;\n@@ -12012,7 +12061,7 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       create_dwo_cu_data.dwo_file = &dwo_file;\n \n       init_cutu_and_read_dies_no_follow (\n-\t  &per_cu, &dwo_file, create_dwo_cu_reader, &create_dwo_cu_data);\n+\t  &per_cu, cu, &dwo_file, create_dwo_cu_reader, &create_dwo_cu_data);\n       info_ptr += per_cu.length;\n \n       // If the unit could not be parsed, skip it.\n@@ -13045,8 +13094,8 @@ open_and_init_dwo_file (struct dwarf2_per_cu_data *per_cu,\n   bfd_map_over_sections (dwo_file->dbfd.get (), dwarf2_locate_dwo_sections,\n \t\t\t &dwo_file->sections);\n \n-  create_cus_hash_table (dwarf2_per_objfile, *dwo_file, dwo_file->sections.info,\n-\t\t\t dwo_file->cus);\n+  create_cus_hash_table (dwarf2_per_objfile, per_cu->cu, *dwo_file,\n+\t\t\t dwo_file->sections.info, dwo_file->cus);\n \n   create_debug_types_hash_table (dwarf2_per_objfile, dwo_file.get (),\n \t\t\t\t dwo_file->sections.types, dwo_file->tus);\n@@ -14706,7 +14755,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n       attr = dwarf2_attr (die, DW_AT_ranges, cu);\n       if (attr != NULL)\n \t{\n-\t  /* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.\n+\t  /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t     We take advantage of the fact that DW_AT_ranges does not appear\n \t     in DW_TAG_compile_unit of DWO files.  */\n \t  int need_ranges_base = die->tag != DW_TAG_compile_unit;\n@@ -14877,7 +14926,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n   attr = dwarf2_attr (die, DW_AT_ranges, cu);\n   if (attr != nullptr)\n     {\n-      /* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.\n+      /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n \t We take advantage of the fact that DW_AT_ranges does not appear\n \t in DW_TAG_compile_unit of DWO files.  */\n       int need_ranges_base = die->tag != DW_TAG_compile_unit;\n@@ -18448,10 +18497,26 @@ read_full_die_1 (const struct die_reader_specs *reader,\n      attributes.  */\n   die->num_attrs = abbrev->num_attrs;\n \n+  std::vector<int> indexes_that_need_reprocess;\n   for (i = 0; i < abbrev->num_attrs; ++i)\n-    info_ptr = read_attribute (reader, &die->attrs[i], &abbrev->attrs[i],\n-\t\t\t       info_ptr);\n+    {\n+      bool need_reprocess;\n+      info_ptr =\n+        read_attribute (reader, &die->attrs[i], &abbrev->attrs[i],\n+\t\t\tinfo_ptr, &need_reprocess);\n+      if (need_reprocess)\n+        indexes_that_need_reprocess.push_back (i);\n+    }\n+\n+  struct attribute *attr = dwarf2_attr_no_follow (die, DW_AT_str_offsets_base);\n+  if (attr != nullptr)\n+    cu->str_offsets_base = DW_UNSND (attr);\n \n+  auto maybe_addr_base = lookup_addr_base(die);\n+  if (maybe_addr_base.has_value ())\n+    cu->addr_base = *maybe_addr_base;\n+  for (int index : indexes_that_need_reprocess)\n+    read_attribute_reprocess (reader, &die->attrs[index]);\n   *diep = die;\n   *has_children = abbrev->has_children;\n   return info_ptr;\n@@ -18952,12 +19017,18 @@ partial_die_info::read (const struct die_reader_specs *reader,\n   int has_high_pc_attr = 0;\n   int high_pc_relative = 0;\n \n+  std::vector<struct attribute> attr_vec (abbrev.num_attrs);\n   for (i = 0; i < abbrev.num_attrs; ++i)\n     {\n-      struct attribute attr;\n-\n-      info_ptr = read_attribute (reader, &attr, &abbrev.attrs[i], info_ptr);\n-\n+      bool need_reprocess;\n+      info_ptr = read_attribute (reader, &attr_vec[i], &abbrev.attrs[i],\n+\t\t\t\t info_ptr, &need_reprocess);\n+      /* String and address offsets that need to do the reprocessing have\n+         already been read at this point, so there is no need to wait until\n+\t the loop terminates to do the reprocessing.  */\n+      if (need_reprocess)\n+\tread_attribute_reprocess (reader, &attr_vec[i]);\n+      attribute &attr = attr_vec[i];\n       /* Store the data if it is of an attribute we want to keep in a\n          partial symbol table.  */\n       switch (attr.name)\n@@ -19396,12 +19467,52 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n   fixup_called = 1;\n }\n \n+/* Process the attributes that had to be skipped in the first round. These\n+   attributes are the ones that need str_offsets_base or addr_base attributes.\n+   They could not have been processed in the first round, because at the time\n+   the values of str_offsets_base or addr_base may not have been known.  */\n+void read_attribute_reprocess (const struct die_reader_specs *reader,\n+\t\t\t       struct attribute *attr)\n+{\n+  struct dwarf2_cu *cu = reader->cu;\n+  switch (attr->form)\n+    {\n+      case DW_FORM_addrx:\n+      case DW_FORM_GNU_addr_index:\n+        DW_ADDR (attr) = read_addr_index (cu, DW_UNSND (attr));\n+        break;\n+      case DW_FORM_strx:\n+      case DW_FORM_strx1:\n+      case DW_FORM_strx2:\n+      case DW_FORM_strx3:\n+      case DW_FORM_strx4:\n+      case DW_FORM_GNU_str_index:\n+\t{\n+\t  unsigned int str_index = DW_UNSND (attr);\n+\t  if (reader->dwo_file != NULL)\n+\t    {\n+\t      DW_STRING (attr) = read_dwo_str_index (reader, str_index);\n+\t      DW_STRING_IS_CANONICAL (attr) = 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      DW_STRING (attr) = read_stub_str_index (cu, str_index);\n+\t      DW_STRING_IS_CANONICAL (attr) = 0;\n+\t    }\n+\t  break;\n+\t}\n+      default:\n+\tgdb_assert_not_reached (_(\"Unexpected DWARF form.\"));\n+    }\n+}\n+\n /* Read an attribute value described by an attribute form.  */\n \n static const gdb_byte *\n read_attribute_value (const struct die_reader_specs *reader,\n \t\t      struct attribute *attr, unsigned form,\n-\t\t      LONGEST implicit_const, const gdb_byte *info_ptr)\n+\t\t      LONGEST implicit_const, const gdb_byte *info_ptr,\n+\t\t      bool *need_reprocess)\n {\n   struct dwarf2_cu *cu = reader->cu;\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n@@ -19412,6 +19523,7 @@ read_attribute_value (const struct die_reader_specs *reader,\n   struct comp_unit_head *cu_header = &cu->header;\n   unsigned int bytes_read;\n   struct dwarf_block *blk;\n+  *need_reprocess = false;\n \n   attr->form = (enum dwarf_form) form;\n   switch (form)\n@@ -19544,6 +19656,7 @@ read_attribute_value (const struct die_reader_specs *reader,\n       info_ptr += bytes_read;\n       break;\n     case DW_FORM_udata:\n+    case DW_FORM_rnglistx:\n       DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n       info_ptr += bytes_read;\n       break;\n@@ -19585,22 +19698,15 @@ read_attribute_value (const struct die_reader_specs *reader,\n \t  info_ptr += bytes_read;\n \t}\n       info_ptr = read_attribute_value (reader, attr, form, implicit_const,\n-\t\t\t\t       info_ptr);\n+\t\t\t\t       info_ptr, need_reprocess);\n       break;\n     case DW_FORM_implicit_const:\n       DW_SND (attr) = implicit_const;\n       break;\n     case DW_FORM_addrx:\n     case DW_FORM_GNU_addr_index:\n-      if (reader->dwo_file == NULL)\n-\t{\n-\t  /* For now flag a hard error.\n-\t     Later we can turn this into a complaint.  */\n-\t  error (_(\"Dwarf Error: %s found in non-DWO CU [in module %s]\"),\n-\t\t dwarf_form_name (form),\n-\t\t bfd_get_filename (abfd));\n-\t}\n-      DW_ADDR (attr) = read_addr_index_from_leb128 (cu, info_ptr, &bytes_read);\n+      *need_reprocess = true;\n+      DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n       info_ptr += bytes_read;\n       break;\n     case DW_FORM_strx:\n@@ -19609,14 +19715,6 @@ read_attribute_value (const struct die_reader_specs *reader,\n     case DW_FORM_strx3:\n     case DW_FORM_strx4:\n     case DW_FORM_GNU_str_index:\n-      if (reader->dwo_file == NULL)\n-\t{\n-\t  /* For now flag a hard error.\n-\t     Later we can turn this into a complaint if warranted.  */\n-\t  error (_(\"Dwarf Error: %s found in non-DWO CU [in module %s]\"),\n-\t\t dwarf_form_name (form),\n-\t\t bfd_get_filename (abfd));\n-\t}\n       {\n \tULONGEST str_index;\n \tif (form == DW_FORM_strx1)\n@@ -19644,9 +19742,9 @@ read_attribute_value (const struct die_reader_specs *reader,\n \t    str_index = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n \t    info_ptr += bytes_read;\n \t  }\n-\tDW_STRING (attr) = read_str_index (reader, str_index);\n-\tDW_STRING_IS_CANONICAL (attr) = 0;\n-      }\n+\t*need_reprocess = true;\n+\t DW_UNSND (attr) = str_index;\n+\t}\n       break;\n     default:\n       error (_(\"Dwarf Error: Cannot handle %s in DWARF reader [in module %s]\"),\n@@ -19682,11 +19780,12 @@ read_attribute_value (const struct die_reader_specs *reader,\n static const gdb_byte *\n read_attribute (const struct die_reader_specs *reader,\n \t\tstruct attribute *attr, struct attr_abbrev *abbrev,\n-\t\tconst gdb_byte *info_ptr)\n+\t\tconst gdb_byte *info_ptr, bool *need_reprocess)\n {\n   attr->name = abbrev->name;\n   return read_attribute_value (reader, attr, abbrev->form,\n-\t\t\t       abbrev->implicit_const, info_ptr);\n+\t\t\t       abbrev->implicit_const, info_ptr,\n+\t\t\t       need_reprocess);\n }\n \n /* Read dwarf information from a buffer.  */\n@@ -20113,27 +20212,30 @@ read_signed_leb128 (bfd *abfd, const gdb_byte *buf,\n }\n \n /* Given index ADDR_INDEX in .debug_addr, fetch the value.\n-   ADDR_BASE is the DW_AT_GNU_addr_base attribute or zero.\n+   ADDR_BASE is the DW_AT_addr_base (DW_AT_GNU_addr_base) attribute or zero.\n    ADDR_SIZE is the size of addresses from the CU header.  */\n \n static CORE_ADDR\n read_addr_index_1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t   unsigned int addr_index, ULONGEST addr_base, int addr_size)\n+\t\t   unsigned int addr_index, gdb::optional<ULONGEST> addr_base,\n+\t\t   int addr_size)\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   bfd *abfd = objfile->obfd;\n   const gdb_byte *info_ptr;\n+  ULONGEST addr_base_or_zero = addr_base.has_value () ? *addr_base : 0;\n \n   dwarf2_read_section (objfile, &dwarf2_per_objfile->addr);\n   if (dwarf2_per_objfile->addr.buffer == NULL)\n     error (_(\"DW_FORM_addr_index used without .debug_addr section [in module %s]\"),\n \t   objfile_name (objfile));\n-  if (addr_base + addr_index * addr_size >= dwarf2_per_objfile->addr.size)\n+  if (addr_base_or_zero + addr_index * addr_size\n+      >= dwarf2_per_objfile->addr.size)\n     error (_(\"DW_FORM_addr_index pointing outside of \"\n \t     \".debug_addr section [in module %s]\"),\n \t   objfile_name (objfile));\n   info_ptr = (dwarf2_per_objfile->addr.buffer\n-\t      + addr_base + addr_index * addr_size);\n+\t      + addr_base_or_zero + addr_index * addr_size);\n   if (addr_size == 4)\n     return bfd_get_32 (abfd, info_ptr);\n   else\n@@ -20166,7 +20268,7 @@ read_addr_index_from_leb128 (struct dwarf2_cu *cu, const gdb_byte *info_ptr,\n \n struct dwarf2_read_addr_index_data\n {\n-  ULONGEST addr_base;\n+  gdb::optional<ULONGEST> addr_base;\n   int addr_size;\n };\n \n@@ -20198,7 +20300,7 @@ dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = per_cu->dwarf2_per_objfile;\n   struct dwarf2_cu *cu = per_cu->cu;\n-  ULONGEST addr_base;\n+  gdb::optional<ULONGEST> addr_base;\n   int addr_size;\n \n   /* We need addr_base and addr_size.\n@@ -20238,40 +20340,39 @@ dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,\n \t\t\t    addr_size);\n }\n \n-/* Given a DW_FORM_GNU_str_index or DW_FORM_strx, fetch the string.\n-   This is only used by the Fission support.  */\n+/* Given a DW_FORM_GNU_str_index value STR_INDEX, fetch the string.\n+   STR_SECTION, STR_OFFSETS_SECTION can be from a Fission stub or a\n+   DWO file.  */\n \n static const char *\n-read_str_index (const struct die_reader_specs *reader, ULONGEST str_index)\n+read_str_index (struct dwarf2_cu *cu,\n+\t\tstruct dwarf2_section_info *str_section,\n+\t\tstruct dwarf2_section_info *str_offsets_section,\n+\t\tULONGEST str_offsets_base, ULONGEST str_index)\n {\n-  struct dwarf2_cu *cu = reader->cu;\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = cu->per_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   const char *objf_name = objfile_name (objfile);\n   bfd *abfd = objfile->obfd;\n-  struct dwarf2_section_info *str_section = &reader->dwo_file->sections.str;\n-  struct dwarf2_section_info *str_offsets_section =\n-    &reader->dwo_file->sections.str_offsets;\n   const gdb_byte *info_ptr;\n   ULONGEST str_offset;\n   static const char form_name[] = \"DW_FORM_GNU_str_index or DW_FORM_strx\";\n \n   dwarf2_read_section (objfile, str_section);\n   dwarf2_read_section (objfile, str_offsets_section);\n   if (str_section->buffer == NULL)\n-    error (_(\"%s used without .debug_str.dwo section\"\n+    error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n-\t   form_name, sect_offset_str (cu->header.sect_off), objf_name);\n+\t   form_name, get_section_name (str_section),\n+           sect_offset_str (cu->header.sect_off), objf_name);\n   if (str_offsets_section->buffer == NULL)\n-    error (_(\"%s used without .debug_str_offsets.dwo section\"\n+    error (_(\"%s used without %s section\"\n \t     \" in CU at offset %s [in module %s]\"),\n-\t   form_name, sect_offset_str (cu->header.sect_off), objf_name);\n-  if (str_index * cu->header.offset_size >= str_offsets_section->size)\n-    error (_(\"%s pointing outside of .debug_str_offsets.dwo\"\n-\t     \" section in CU at offset %s [in module %s]\"),\n-\t   form_name, sect_offset_str (cu->header.sect_off), objf_name);\n+\t   form_name, get_section_name (str_section),\n+           sect_offset_str (cu->header.sect_off), objf_name);\n   info_ptr = (str_offsets_section->buffer\n+\t      + str_offsets_base\n \t      + str_index * cu->header.offset_size);\n   if (cu->header.offset_size == 4)\n     str_offset = bfd_get_32 (abfd, info_ptr);\n@@ -20284,6 +20385,41 @@ read_str_index (const struct die_reader_specs *reader, ULONGEST str_index)\n   return (const char *) (str_section->buffer + str_offset);\n }\n \n+/* Given a DW_FORM_GNU_str_index from a DWO file, fetch the string.  */\n+\n+static const char *\n+read_dwo_str_index (const struct die_reader_specs *reader, ULONGEST str_index)\n+{\n+  ULONGEST str_offsets_base = reader->cu->header.version >= 5\n+\t\t\t      ? reader->cu->header.addr_size : 0;\n+  return read_str_index (reader->cu,\n+\t\t\t &reader->dwo_file->sections.str,\n+\t\t\t &reader->dwo_file->sections.str_offsets,\n+\t\t\t str_offsets_base, str_index);\n+}\n+\n+/* Given a DW_FORM_GNU_str_index from a Fission stub, fetch the string.  */\n+\n+static const char *\n+read_stub_str_index (struct dwarf2_cu *cu, ULONGEST str_index)\n+{\n+  struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n+  const char *objf_name = objfile_name (objfile);\n+  static const char form_name[] = \"DW_FORM_GNU_str_index\";\n+  static const char str_offsets_attr_name[] = \"DW_AT_str_offsets\";\n+\n+  if (!cu->str_offsets_base.has_value ())\n+    error (_(\"%s used in Fission stub without %s\"\n+\t     \" in CU at offset 0x%lx [in module %s]\"),\n+\t   form_name, str_offsets_attr_name,\n+\t   (long) cu->header.offset_size, objf_name);\n+\n+  return read_str_index (cu,\n+\t\t\t &cu->per_cu->dwarf2_per_objfile->str,\n+\t\t\t &cu->per_cu->dwarf2_per_objfile->str_offsets,\n+\t\t\t *cu->str_offsets_base, str_index);\n+}\n+\n /* Return the length of an LEB128 number in BUF.  */\n \n static int"
    },
    {
      "sha": "bc8087ba4060439aa274ca67fa0bc007abd92edd",
      "filename": "gdb/dwarf2read.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/dwarf2read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/dwarf2read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.h?ref=18a8505e38fc2de4b0730b6e13cbd23db5984de9",
      "patch": "@@ -156,6 +156,7 @@ struct dwarf2_per_objfile\n   dwarf2_section_info macinfo {};\n   dwarf2_section_info macro {};\n   dwarf2_section_info str {};\n+  dwarf2_section_info str_offsets {};\n   dwarf2_section_info line_str {};\n   dwarf2_section_info ranges {};\n   dwarf2_section_info rnglists {};"
    },
    {
      "sha": "85f8e7c1558e349fb7c37bc12e6c0988736ae000",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=18a8505e38fc2de4b0730b6e13cbd23db5984de9",
      "patch": "@@ -568,6 +568,7 @@ struct dwarf2_debug_sections {\n   struct dwarf2_section_names macinfo;\n   struct dwarf2_section_names macro;\n   struct dwarf2_section_names str;\n+  struct dwarf2_section_names str_offsets;\n   struct dwarf2_section_names line_str;\n   struct dwarf2_section_names ranges;\n   struct dwarf2_section_names rnglists;"
    },
    {
      "sha": "aae2e37c90f2ff6be4bff348a61e4366b7186da3",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18a8505e38fc2de4b0730b6e13cbd23db5984de9/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=18a8505e38fc2de4b0730b6e13cbd23db5984de9",
      "patch": "@@ -166,6 +166,7 @@ static const struct dwarf2_debug_sections dwarf2_xcoff_names = {\n   { NULL, NULL },\n   { \".dwmac\", NULL },\n   { \".dwstr\", NULL },\n+  { NULL, NULL }, /* debug_str_offsets */\n   { NULL, NULL }, /* debug_line_str */\n   { \".dwrnges\", NULL },\n   { NULL, NULL }, /* debug_rnglists */"
    }
  ]
}