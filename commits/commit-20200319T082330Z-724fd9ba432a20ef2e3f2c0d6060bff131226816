{
  "sha": "724fd9ba432a20ef2e3f2c0d6060bff131226816",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzI0ZmQ5YmE0MzJhMjBlZjJlM2YyYzBkNjA2MGJmZjEzMTIyNjgxNg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-01-27T17:37:20Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-03-19T08:23:30Z"
    },
    "message": "gdb: Restructure the completion_tracker class\n\nIn this commit I rewrite how the completion tracker tracks the\ncompletions, and builds its lowest common denominator (LCD) string.\nThe LCD string is now built lazily when required, and we only track\nthe completions in one place, the hash table, rather than maintaining\na separate vector of completions.\n\nThe motivation for these changes is that the next commit will add the\nability to remove completions from the list, removing a completion\nwill invalidate the LCD string, so we need to keep hold of enough\ninformation to recompute the LCD string as needed.\n\nAdditionally, keeping the completions in a vector makes removing a\ncompletion expensive, so better to only keep the completions in the\nhash table.\n\nThis commit doesn't add any new functionality itself, and there should\nbe no user visible changes after this commit.\n\nFor testing, I ran the testsuite as usual, but I also ran some manual\ncompletion tests under valgrind, and didn't get any reports about\nleaked memory.\n\ngdb/ChangeLog:\n\n\t* completer.c (completion_tracker::completion_hash_entry): Define\n\tnew class.\n\t(advance_to_filename_complete_word_point): Call\n\trecompute_lowest_common_denominator.\n\t(completion_tracker::completion_tracker): Call discard_completions\n\tto setup the hash table.\n\t(completion_tracker::discard_completions): Allow for being called\n\tfrom the constructor, pass new equal function, and element deleter\n\twhen constructing the hash table.  Initialise new class member\n\tvariables.\n\t(completion_tracker::maybe_add_completion): Remove use of\n\tm_entries_vec, and store more information into m_entries_hash.\n\t(completion_tracker::recompute_lcd_visitor): New function, most\n\tcontent taken from...\n\t(completion_tracker::recompute_lowest_common_denominator):\n\t...here, this now just visits each item in the hash calling the\n\tabove visitor.\n\t(completion_tracker::build_completion_result): Remove use of\n\tm_entries_vec, call recompute_lowest_common_denominator.\n\t* completer.h (completion_tracker::have_completions): Remove use\n\tof m_entries_vec.\n\t(completion_tracker::completion_hash_entry): Declare new class.\n\t(completion_tracker::recompute_lowest_common_denominator): Change\n\tfunction signature.\n\t(completion_tracker::recompute_lcd_visitor): Declare new function.\n\t(completion_tracker::m_entries_vec): Delete.\n\t(completion_tracker::m_entries_hash): Initialize to NULL.\n\t(completion_tracker::m_lowest_common_denominator_valid): New\n\tmember variable.\n\t(completion_tracker::m_lowest_common_denominator_max_length): New\n\tmember variable.\n\nChange-Id: I9d1db52c489ca0041b8959ca0d53b7d3af8aea72",
    "tree": {
      "sha": "8026e92b65e594af985dfdab754a3c7867180e26",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8026e92b65e594af985dfdab754a3c7867180e26"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/724fd9ba432a20ef2e3f2c0d6060bff131226816",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/724fd9ba432a20ef2e3f2c0d6060bff131226816",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/724fd9ba432a20ef2e3f2c0d6060bff131226816",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/724fd9ba432a20ef2e3f2c0d6060bff131226816/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d8c8b84859d057c58c901c08367ecc9f8a9f09dc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8c8b84859d057c58c901c08367ecc9f8a9f09dc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d8c8b84859d057c58c901c08367ecc9f8a9f09dc"
    }
  ],
  "stats": {
    "total": 270,
    "additions": 222,
    "deletions": 48
  },
  "files": [
    {
      "sha": "bc927d4be45a4b810b5b1c3ced0622a13cd9d0cd",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=724fd9ba432a20ef2e3f2c0d6060bff131226816",
      "patch": "@@ -1,3 +1,37 @@\n+2020-03-19  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* completer.c (completion_tracker::completion_hash_entry): Define\n+\tnew class.\n+\t(advance_to_filename_complete_word_point): Call\n+\trecompute_lowest_common_denominator.\n+\t(completion_tracker::completion_tracker): Call discard_completions\n+\tto setup the hash table.\n+\t(completion_tracker::discard_completions): Allow for being called\n+\tfrom the constructor, pass new equal function, and element deleter\n+\twhen constructing the hash table.  Initialise new class member\n+\tvariables.\n+\t(completion_tracker::maybe_add_completion): Remove use of\n+\tm_entries_vec, and store more information into m_entries_hash.\n+\t(completion_tracker::recompute_lcd_visitor): New function, most\n+\tcontent taken from...\n+\t(completion_tracker::recompute_lowest_common_denominator):\n+\t...here, this now just visits each item in the hash calling the\n+\tabove visitor.\n+\t(completion_tracker::build_completion_result): Remove use of\n+\tm_entries_vec, call recompute_lowest_common_denominator.\n+\t* completer.h (completion_tracker::have_completions): Remove use\n+\tof m_entries_vec.\n+\t(completion_tracker::completion_hash_entry): Declare new class.\n+\t(completion_tracker::recompute_lowest_common_denominator): Change\n+\tfunction signature.\n+\t(completion_tracker::recompute_lcd_visitor): Declare new function.\n+\t(completion_tracker::m_entries_vec): Delete.\n+\t(completion_tracker::m_entries_hash): Initialize to NULL.\n+\t(completion_tracker::m_lowest_common_denominator_valid): New\n+\tmember variable.\n+\t(completion_tracker::m_lowest_common_denominator_max_length): New\n+\tmember variable.\n+\n 2020-03-17  Kamil Rytarowski  <n54@gmx.com>\n \n \t* regformats/regdef.h: Put reg in gdb namespace."
    },
    {
      "sha": "14c7a5799700b192ea76cf03f3536b28515f61cd",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 164,
      "deletions": 31,
      "changes": 195,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=724fd9ba432a20ef2e3f2c0d6060bff131226816",
      "patch": "@@ -45,6 +45,60 @@\n \n #include \"completer.h\"\n \n+/* See completer.h.  */\n+\n+class completion_tracker::completion_hash_entry\n+{\n+public:\n+  /* Constructor.  */\n+  completion_hash_entry (gdb::unique_xmalloc_ptr<char> name,\n+\t\t\t gdb::unique_xmalloc_ptr<char> lcd)\n+    : m_name (std::move (name)),\n+      m_lcd (std::move (lcd))\n+  {\n+    /* Nothing.  */\n+  }\n+\n+  /* Returns a pointer to the lowest common denominator string.  This\n+     string will only be valid while this hash entry is still valid as the\n+     string continues to be owned by this hash entry and will be released\n+     when this entry is deleted.  */\n+  char *get_lcd () const\n+  {\n+    return m_lcd.get ();\n+  }\n+\n+  /* Get, and release the name field from this hash entry.  This can only\n+     be called once, after which the name field is no longer valid.  This\n+     should be used to pass ownership of the name to someone else.  */\n+  char *release_name ()\n+  {\n+    return m_name.release ();\n+  }\n+\n+  /* Return true of the name in this hash entry is STR.  */\n+  bool is_name_eq (const char *str) const\n+  {\n+    return strcmp (m_name.get (), str) == 0;\n+  }\n+\n+  /* A static function that can be passed to the htab hash system to be\n+     used as a callback that deletes an item from the hash.  */\n+  static void deleter (void *arg)\n+  {\n+    completion_hash_entry *entry = (completion_hash_entry *) arg;\n+    delete entry;\n+  }\n+\n+private:\n+\n+  /* The symbol name stored in this hash entry.  */\n+  gdb::unique_xmalloc_ptr<char> m_name;\n+\n+  /* The lowest common denominator string computed for this hash entry.  */\n+  gdb::unique_xmalloc_ptr<char> m_lcd;\n+};\n+\n /* Misc state that needs to be tracked across several different\n    readline completer entry point calls, all related to a single\n    completion invocation.  */\n@@ -407,6 +461,7 @@ advance_to_filename_complete_word_point (completion_tracker &tracker,\n bool\n completion_tracker::completes_to_completion_word (const char *word)\n {\n+  recompute_lowest_common_denominator ();\n   if (m_lowest_common_denominator_unique)\n     {\n       const char *lcd = m_lowest_common_denominator;\n@@ -1512,9 +1567,7 @@ int max_completions = 200;\n \n completion_tracker::completion_tracker ()\n {\n-  m_entries_hash = htab_create_alloc (INITIAL_COMPLETION_HTAB_SIZE,\n-\t\t\t\t      htab_hash_string, streq_hash,\n-\t\t\t\t      NULL, xcalloc, xfree);\n+  discard_completions ();\n }\n \n /* See completer.h.  */\n@@ -1526,13 +1579,33 @@ completion_tracker::discard_completions ()\n   m_lowest_common_denominator = NULL;\n \n   m_lowest_common_denominator_unique = false;\n+  m_lowest_common_denominator_valid = false;\n+\n+  /* A null check here allows this function to be used from the\n+     constructor.  */\n+  if (m_entries_hash != NULL)\n+    htab_delete (m_entries_hash);\n+\n+  /* A callback used by the hash table to compare new entries with existing\n+     entries.  We can't use the standard streq_hash function here as the\n+     key to our hash is just a single string, while the values we store in\n+     the hash are a struct containing multiple strings.  */\n+  static auto entry_eq_func\n+    = [] (const void *first, const void *second) -> int\n+      {\n+\t/* The FIRST argument is the entry already in the hash table, and\n+\t   the SECOND argument is the new item being inserted.  */\n+\tconst completion_hash_entry *entry\n+\t  = (const completion_hash_entry *) first;\n+\tconst char *name_str = (const char *) second;\n \n-  m_entries_vec.clear ();\n+\treturn entry->is_name_eq (name_str);\n+      };\n \n-  htab_delete (m_entries_hash);\n   m_entries_hash = htab_create_alloc (INITIAL_COMPLETION_HTAB_SIZE,\n-\t\t\t\t      htab_hash_string, streq_hash,\n-\t\t\t\t      NULL, xcalloc, xfree);\n+\t\t\t\t      htab_hash_string, entry_eq_func,\n+\t\t\t\t      completion_hash_entry::deleter,\n+\t\t\t\t      xcalloc, xfree);\n }\n \n /* See completer.h.  */\n@@ -1559,7 +1632,8 @@ completion_tracker::maybe_add_completion\n   if (htab_elements (m_entries_hash) >= max_completions)\n     return false;\n \n-  slot = htab_find_slot (m_entries_hash, name.get (), INSERT);\n+  hashval_t hash = htab_hash_string (name.get ());\n+  slot = htab_find_slot_with_hash (m_entries_hash, name.get (), hash, INSERT);\n   if (*slot == HTAB_EMPTY_ENTRY)\n     {\n       const char *match_for_lcd_str = NULL;\n@@ -1573,10 +1647,12 @@ completion_tracker::maybe_add_completion\n       gdb::unique_xmalloc_ptr<char> lcd\n \t= make_completion_match_str (match_for_lcd_str, text, word);\n \n-      recompute_lowest_common_denominator (std::move (lcd));\n+      size_t lcd_len = strlen (lcd.get ());\n+      *slot = new completion_hash_entry (std::move (name), std::move (lcd));\n \n-      *slot = name.get ();\n-      m_entries_vec.push_back (std::move (name));\n+      m_lowest_common_denominator_valid = false;\n+      m_lowest_common_denominator_max_length\n+\t= std::max (m_lowest_common_denominator_max_length, lcd_len);\n     }\n \n   return true;\n@@ -1982,23 +2058,23 @@ completion_find_completion_word (completion_tracker &tracker, const char *text,\n /* See completer.h.  */\n \n void\n-completion_tracker::recompute_lowest_common_denominator\n-  (gdb::unique_xmalloc_ptr<char> &&new_match_up)\n+completion_tracker::recompute_lcd_visitor (completion_hash_entry *entry)\n {\n-  if (m_lowest_common_denominator == NULL)\n+  if (!m_lowest_common_denominator_valid)\n     {\n-      /* We don't have a lowest common denominator yet, so simply take\n-\t the whole NEW_MATCH_UP as being it.  */\n-      m_lowest_common_denominator = new_match_up.release ();\n+      /* This is the first lowest common denominator that we are\n+\t considering, just copy it in.  */\n+      strcpy (m_lowest_common_denominator, entry->get_lcd ());\n       m_lowest_common_denominator_unique = true;\n+      m_lowest_common_denominator_valid = true;\n     }\n   else\n     {\n-      /* Find the common denominator between the currently-known\n-\t lowest common denominator and NEW_MATCH_UP.  That becomes the\n-\t new lowest common denominator.  */\n+      /* Find the common denominator between the currently-known lowest\n+\t common denominator and NEW_MATCH_UP.  That becomes the new lowest\n+\t common denominator.  */\n       size_t i;\n-      const char *new_match = new_match_up.get ();\n+      const char *new_match = entry->get_lcd ();\n \n       for (i = 0;\n \t   (new_match[i] != '\\0'\n@@ -2015,6 +2091,35 @@ completion_tracker::recompute_lowest_common_denominator\n \n /* See completer.h.  */\n \n+void\n+completion_tracker::recompute_lowest_common_denominator ()\n+{\n+  /* We've already done this.  */\n+  if (m_lowest_common_denominator_valid)\n+    return;\n+\n+  /* Resize the storage to ensure we have enough space, the plus one gives\n+     us space for the trailing null terminator we will include.  */\n+  m_lowest_common_denominator\n+    = (char *) xrealloc (m_lowest_common_denominator,\n+\t\t\t m_lowest_common_denominator_max_length + 1);\n+\n+  /* Callback used to visit each entry in the m_entries_hash.  */\n+  auto visitor_func\n+    = [] (void **slot, void *info) -> int\n+      {\n+\tcompletion_tracker *obj = (completion_tracker *) info;\n+\tcompletion_hash_entry *entry = (completion_hash_entry *) *slot;\n+\tobj->recompute_lcd_visitor (entry);\n+\treturn 1;\n+      };\n+\n+  htab_traverse (m_entries_hash, visitor_func, this);\n+  m_lowest_common_denominator_valid = true;\n+}\n+\n+/* See completer.h.  */\n+\n void\n completion_tracker::advance_custom_word_point_by (int len)\n {\n@@ -2092,16 +2197,17 @@ completion_result\n completion_tracker::build_completion_result (const char *text,\n \t\t\t\t\t     int start, int end)\n {\n-  completion_list &list = m_entries_vec;\t/* The completions.  */\n+  size_t element_count = htab_elements (m_entries_hash);\n \n-  if (list.empty ())\n+  if (element_count == 0)\n     return {};\n \n   /* +1 for the LCD, and +1 for NULL termination.  */\n-  char **match_list = XNEWVEC (char *, 1 + list.size () + 1);\n+  char **match_list = XNEWVEC (char *, 1 + element_count + 1);\n \n   /* Build replacement word, based on the LCD.  */\n \n+  recompute_lowest_common_denominator ();\n   match_list[0]\n     = expand_preserving_ws (text, end - start,\n \t\t\t    m_lowest_common_denominator);\n@@ -2128,13 +2234,40 @@ completion_tracker::build_completion_result (const char *text,\n     }\n   else\n     {\n-      int ix;\n-\n-      for (ix = 0; ix < list.size (); ++ix)\n-\tmatch_list[ix + 1] = list[ix].release ();\n-      match_list[ix + 1] = NULL;\n-\n-      return completion_result (match_list, list.size (), false);\n+      /* State object used while building the completion list.  */\n+      struct list_builder\n+      {\n+\tlist_builder (char **ml)\n+\t  : match_list (ml),\n+\t    index (1)\n+\t{ /* Nothing.  */ }\n+\n+\t/* The list we are filling.  */\n+\tchar **match_list;\n+\n+\t/* The next index in the list to write to.  */\n+\tint index;\n+      };\n+      list_builder builder (match_list);\n+\n+      /* Visit each entry in m_entries_hash and add it to the completion\n+\t list, updating the builder state object.  */\n+      auto func\n+\t= [] (void **slot, void *info) -> int\n+\t  {\n+\t    completion_hash_entry *entry = (completion_hash_entry *) *slot;\n+\t    list_builder *state = (list_builder *) info;\n+\n+\t    state->match_list[state->index] = entry->release_name ();\n+\t    state->index++;\n+\t    return 1;\n+\t  };\n+\n+      /* Build the completion list and add a null at the end.  */\n+      htab_traverse_noresize (m_entries_hash, func, &builder);\n+      match_list[builder.index] = NULL;\n+\n+      return completion_result (match_list, builder.index - 1, false);\n     }\n }\n "
    },
    {
      "sha": "7bfe0d5814246ed086b253264e2d8e9bf40ad994",
      "filename": "gdb/completer.h",
      "status": "modified",
      "additions": 24,
      "deletions": 17,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/completer.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/724fd9ba432a20ef2e3f2c0d6060bff131226816/gdb/completer.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.h?ref=724fd9ba432a20ef2e3f2c0d6060bff131226816",
      "patch": "@@ -389,7 +389,7 @@ class completion_tracker\n \n   /* True if we have any completion match recorded.  */\n   bool have_completions () const\n-  { return !m_entries_vec.empty (); }\n+  { return htab_elements (m_entries_hash) > 0; }\n \n   /* Discard the current completion match list and the current\n      LCD.  */\n@@ -403,25 +403,25 @@ class completion_tracker\n \n private:\n \n+  /* The type that we place into the m_entries_hash hash table.  */\n+  class completion_hash_entry;\n+\n   /* Add the completion NAME to the list of generated completions if\n      it is not there already.  If false is returned, too many\n      completions were found.  */\n   bool maybe_add_completion (gdb::unique_xmalloc_ptr<char> name,\n \t\t\t     completion_match_for_lcd *match_for_lcd,\n \t\t\t     const char *text, const char *word);\n \n-  /* Given a new match, recompute the lowest common denominator (LCD)\n-     to hand over to readline.  Normally readline computes this itself\n-     based on the whole set of completion matches.  However, some\n-     completers want to override readline, in order to be able to\n-     provide a LCD that is not really a prefix of the matches, but the\n-     lowest common denominator of some relevant substring of each\n-     match.  E.g., \"b push_ba\" completes to\n-     \"std::vector<..>::push_back\", \"std::string::push_back\", etc., and\n-     in this case we want the lowest common denominator to be\n-     \"push_back\" instead of \"std::\".  */\n-  void recompute_lowest_common_denominator\n-    (gdb::unique_xmalloc_ptr<char> &&new_match);\n+  /* Ensure that the lowest common denominator held in the member variable\n+     M_LOWEST_COMMON_DENOMINATOR is valid.  This method must be called if\n+     there is any chance that new completions have been added to the\n+     tracker before the lowest common denominator is read.  */\n+  void recompute_lowest_common_denominator ();\n+\n+  /* Callback used from recompute_lowest_common_denominator, called for\n+     every entry in m_entries_hash.  */\n+  void recompute_lcd_visitor (completion_hash_entry *entry);\n \n   /* Completion match outputs returned by the symbol name matching\n      routines (see symbol_name_matcher_ftype).  These results are only\n@@ -430,16 +430,13 @@ class completion_tracker\n      symbol name matching routines.  */\n   completion_match_result m_completion_match_result;\n \n-  /* The completion matches found so far, in a vector.  */\n-  completion_list m_entries_vec;\n-\n   /* The completion matches found so far, in a hash table, for\n      duplicate elimination as entries are added.  Otherwise the user\n      is left scratching his/her head: readline and complete_command\n      will remove duplicates, and if removal of duplicates there brings\n      the total under max_completions the user may think gdb quit\n      searching too early.  */\n-  htab_t m_entries_hash;\n+  htab_t m_entries_hash = NULL;\n \n   /* If non-zero, then this is the quote char that needs to be\n      appended after completion (iff we have a unique completion).  We\n@@ -483,6 +480,16 @@ class completion_tracker\n      \"function()\", instead of showing all the possible\n      completions.  */\n   bool m_lowest_common_denominator_unique = false;\n+\n+  /* True if the value in M_LOWEST_COMMON_DENOMINATOR is correct.  This is\n+     set to true each time RECOMPUTE_LOWEST_COMMON_DENOMINATOR is called,\n+     and reset to false whenever a new completion is added.  */\n+  bool m_lowest_common_denominator_valid = false;\n+\n+  /* To avoid calls to xrealloc in RECOMPUTE_LOWEST_COMMON_DENOMINATOR, we\n+     track the maximum possible size of the lowest common denominator,\n+     which we know as each completion is added.  */\n+  size_t m_lowest_common_denominator_max_length = 0;\n };\n \n /* Return a string to hand off to readline as a completion match"
    }
  ]
}