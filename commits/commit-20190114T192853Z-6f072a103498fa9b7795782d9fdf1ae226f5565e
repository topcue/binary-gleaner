{
  "sha": "6f072a103498fa9b7795782d9fdf1ae226f5565e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmYwNzJhMTAzNDk4ZmE5Yjc3OTU3ODJkOWZkZjFhZTIyNmY1NTY1ZQ==",
  "commit": {
    "author": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2019-01-14T19:28:53Z"
    },
    "committer": {
      "name": "Pedro Franco de Carvalho",
      "email": "pedromfc@linux.ibm.com",
      "date": "2019-01-14T19:28:53Z"
    },
    "message": "[PowerPC] Aliases for vector registers\n\nThis patch defines pseudo-registers \"v0\" through \"v31\" as aliases that\nmap to the corresponding raw \"vr0\" through \"vr31\" vector registers for\nPower.\n\nThe motivation behind this is that although GDB defines these\nregisters as \"vrX\", the disassembler prints them as \"vX\", e.g. as the\noperands in instructions such as \"vaddubm v2,v1,v1\".  This can be\nconfusing to users trying to print out the values of the operands\nwhile inspecting the disassembled code.\n\nThe new aliases are made not to belong to any register group, to avoid\nduplicated values in \"info register vector\" and \"info register all\".\nThe arch-specific rs6000_pseudo_register_reggroup_p function had\npreviously been removed since the other pseudo-registers could have\ntheir groups inferred by their type.  It restored with this patch to\nhandle the aliases.  Membership for the other pseudo-registers is\nstill determined using the default function.\n\nA new tests checks that GDB prints the expected values of vector\nregisters after they are filled by the inferior, by using both the raw\nnames and the aliases.  Two other existing tests are modified to also\ntest the aliases.\n\ngdb/ChangeLog:\n2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n\n\t* ppc-tdep.h (struct gdbarch_tdep) <ppc_v0_alias_regnum>: New\n\tfield.\n\t* rs6000-tdep.c: Include reggroups.h.\n\t(IS_V_ALIAS_PSEUDOREG): Define.\n\t(rs6000_register_name): Return names for the \"vX\" aliases.\n\t(rs6000_pseudo_register_type): Return type for the \"vX\" aliases.\n\t(rs6000_pseudo_register_reggroup_p): Restore.  Handle \"vX\"\n\taliases.  Call default_register_reggroup_p for all other\n\tpseudo-registers.\n\t(v_alias_pseudo_register_read, v_alias_pseudo_register_write):\n\tNew functions.\n\t(rs6000_pseudo_register_read, rs6000_pseudo_register_write):\n\tHandle \"vX\" aliases.\n\t(v_alias_pseudo_register_collect): New function.\n\t(rs6000_ax_pseudo_register_collect): Handle \"vX\" aliases.\n\t(rs6000_gdbarch_init): Initialize \"vX\" aliases as\n\tpseudo-registers.  Restore registration of\n\trs6000_pseudo_register_reggroup_p with\n\tset_tdesc_pseudo_register_reggroup_p.\n\ngdb/testsuite/ChangeLog:\n2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n\n\t* gdb.arch/vsx-regs.exp: Add tests that use the vector register\n\taliases.\n\t* gdb.arch/altivec-regs.exp: Likewise.  Fix indentation of two\n\ttests.\n\t* gdb.arch/powerpc-vector-regs.c: New file.\n\t* gdb.arch/powerpc-vector-regs.exp: New file.\n\ngdb/doc/ChangeLog:\n2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n\n\t* gdb.texinfo (PowerPC Features): Document the alias\n\tpseudo-registers for the org.gnu.gdb.power.altivec feature.",
    "tree": {
      "sha": "db24ed766ad9899ab082fb730ee5599a5e13daa3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db24ed766ad9899ab082fb730ee5599a5e13daa3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6f072a103498fa9b7795782d9fdf1ae226f5565e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f072a103498fa9b7795782d9fdf1ae226f5565e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6f072a103498fa9b7795782d9fdf1ae226f5565e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f072a103498fa9b7795782d9fdf1ae226f5565e/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "a7b8d68257c52281b08d9d858805e15667be6606",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7b8d68257c52281b08d9d858805e15667be6606",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a7b8d68257c52281b08d9d858805e15667be6606"
    }
  ],
  "stats": {
    "total": 284,
    "additions": 279,
    "deletions": 5
  },
  "files": [
    {
      "sha": "384792c568b282a223e77dbea2f90011c5c2d37b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -1,3 +1,25 @@\n+2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n+\n+\t* ppc-tdep.h (struct gdbarch_tdep) <ppc_v0_alias_regnum>: New\n+\tfield.\n+\t* rs6000-tdep.c: Include reggroups.h.\n+\t(IS_V_ALIAS_PSEUDOREG): Define.\n+\t(rs6000_register_name): Return names for the \"vX\" aliases.\n+\t(rs6000_pseudo_register_type): Return type for the \"vX\" aliases.\n+\t(rs6000_pseudo_register_reggroup_p): Restore.  Handle \"vX\"\n+\taliases.  Call default_register_reggroup_p for all other\n+\tpseudo-registers.\n+\t(v_alias_pseudo_register_read, v_alias_pseudo_register_write):\n+\tNew functions.\n+\t(rs6000_pseudo_register_read, rs6000_pseudo_register_write):\n+\tHandle \"vX\" aliases.\n+\t(v_alias_pseudo_register_collect): New function.\n+\t(rs6000_ax_pseudo_register_collect): Handle \"vX\" aliases.\n+\t(rs6000_gdbarch_init): Initialize \"vX\" aliases as\n+\tpseudo-registers.  Restore registration of\n+\trs6000_pseudo_register_reggroup_p with\n+\tset_tdesc_pseudo_register_reggroup_p.\n+\n 2019-01-13  Max Filippov  <jcmvbkbc@gmail.com>\n \n \t* xtensa-linux-tdep.c (xtensa_linux_init_abi): Update"
    },
    {
      "sha": "eec6e3e76d6126c513c7acd11d91b6ffc405cf57",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -1,3 +1,8 @@\n+2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n+\n+\t* gdb.texinfo (PowerPC Features): Document the alias\n+\tpseudo-registers for the org.gnu.gdb.power.altivec feature.\n+\n 2019-01-09  Simon Marchi  <simon.marchi@ericsson.com>\n \n \t* gdb.texinfo (Print Settings): Remove mention of specific"
    },
    {
      "sha": "064ac90b596129f43581d80708ab53a94fa30870",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -43322,8 +43322,10 @@ The @samp{org.gnu.gdb.power.fpu} feature is optional.  It should\n contain registers @samp{f0} through @samp{f31} and @samp{fpscr}.\n \n The @samp{org.gnu.gdb.power.altivec} feature is optional.  It should\n-contain registers @samp{vr0} through @samp{vr31}, @samp{vscr},\n-and @samp{vrsave}.\n+contain registers @samp{vr0} through @samp{vr31}, @samp{vscr}, and\n+@samp{vrsave}.  @value{GDBN} will define pseudo-registers @samp{v0}\n+through @samp{v31} as aliases for the corresponding @samp{vrX}\n+registers.\n \n The @samp{org.gnu.gdb.power.vsx} feature is optional.  It should\n contain registers @samp{vs0h} through @samp{vs31h}.  @value{GDBN} will"
    },
    {
      "sha": "9297fe2b097d09e07c772fcdcb43a45388fbf4eb",
      "filename": "gdb/ppc-tdep.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/ppc-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/ppc-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-tdep.h?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -244,6 +244,10 @@ struct gdbarch_tdep\n     int ppc_vr0_regnum;\t\t/* First AltiVec register.  */\n     int ppc_vrsave_regnum;\t/* Last AltiVec register.  */\n \n+    /* Altivec pseudo-register vX aliases for the raw vrX\n+       registers.  */\n+    int ppc_v0_alias_regnum;\n+\n     /* SPE registers.  */\n     int ppc_ev0_upper_regnum;   /* First GPR upper half register.  */\n     int ppc_ev0_regnum;         /* First ev register.  */"
    },
    {
      "sha": "e875ad953663c2a8c2c05e0637740140d16c3b0d",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 107,
      "deletions": 1,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -36,6 +36,7 @@\n #include \"infcall.h\"\n #include \"sim-regno.h\"\n #include \"gdb/sim-ppc.h\"\n+#include \"reggroups.h\"\n #include \"dwarf2-frame.h\"\n #include \"target-descriptions.h\"\n #include \"user-regs.h\"\n@@ -95,6 +96,13 @@\n     && (regnum) >= (tdep)->ppc_dl0_regnum \\\n     && (regnum) < (tdep)->ppc_dl0_regnum + 16)\n \n+/* Determine if regnum is a \"vX\" alias for the raw \"vrX\" vector\n+   registers.  */\n+#define IS_V_ALIAS_PSEUDOREG(tdep, regnum) (\\\n+    (tdep)->ppc_v0_alias_regnum >= 0 \\\n+    && (regnum) >= (tdep)->ppc_v0_alias_regnum \\\n+    && (regnum) < (tdep)->ppc_v0_alias_regnum + ppc_num_vrs)\n+\n /* Determine if regnum is a POWER7 VSX register.  */\n #define IS_VSX_PSEUDOREG(tdep, regnum) ((tdep)->ppc_vsr0_regnum >= 0 \\\n     && (regnum) >= (tdep)->ppc_vsr0_regnum \\\n@@ -2370,6 +2378,18 @@ rs6000_register_name (struct gdbarch *gdbarch, int regno)\n       return dfp128_regnames[regno - tdep->ppc_dl0_regnum];\n     }\n \n+  /* Check if this is a vX alias for a raw vrX vector register.  */\n+  if (IS_V_ALIAS_PSEUDOREG (tdep, regno))\n+    {\n+      static const char *const vector_alias_regnames[] = {\n+\t\"v0\", \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\",\n+\t\"v8\", \"v9\", \"v10\", \"v11\", \"v12\", \"v13\", \"v14\", \"v15\",\n+\t\"v16\", \"v17\", \"v18\", \"v19\", \"v20\", \"v21\", \"v22\", \"v23\",\n+\t\"v24\", \"v25\", \"v26\", \"v27\", \"v28\", \"v29\", \"v30\", \"v31\"\n+      };\n+      return vector_alias_regnames[regno - tdep->ppc_v0_alias_regnum];\n+    }\n+\n   /* Check if this is a VSX pseudo-register.  */\n   if (IS_VSX_PSEUDOREG (tdep, regno))\n     {\n@@ -2460,6 +2480,11 @@ rs6000_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n \t   || IS_CDFP_PSEUDOREG (tdep, regnum))\n     /* PPC decimal128 pseudo-registers.  */\n     return builtin_type (gdbarch)->builtin_declong;\n+  else if (IS_V_ALIAS_PSEUDOREG (tdep, regnum))\n+    return gdbarch_register_type (gdbarch,\n+\t\t\t\t  tdep->ppc_vr0_regnum\n+\t\t\t\t  + (regnum\n+\t\t\t\t     - tdep->ppc_v0_alias_regnum));\n   else if (IS_VSX_PSEUDOREG (tdep, regnum)\n \t   || IS_CVSX_PSEUDOREG (tdep, regnum))\n     /* POWER7 VSX pseudo-registers.  */\n@@ -2475,6 +2500,24 @@ rs6000_pseudo_register_type (struct gdbarch *gdbarch, int regnum)\n \t\t    gdbarch_register_name (gdbarch, regnum), regnum);\n }\n \n+/* Check if REGNUM is a member of REGGROUP.  We only need to handle\n+   the vX aliases for the vector registers by always returning false\n+   to avoid duplicated information in \"info register vector/all\",\n+   since the raw vrX registers will already show in these cases.  For\n+   other pseudo-registers we use the default membership function.  */\n+\n+static int\n+rs6000_pseudo_register_reggroup_p (struct gdbarch *gdbarch, int regnum,\n+\t\t\t\t   struct reggroup *group)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  if (IS_V_ALIAS_PSEUDOREG (tdep, regnum))\n+    return 0;\n+  else\n+    return default_register_reggroup_p (gdbarch, regnum, group);\n+}\n+\n /* The register format for RS/6000 floating point registers is always\n    double, we need a conversion if the memory format is float.  */\n \n@@ -2717,6 +2760,35 @@ dfp_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,\n     }\n }\n \n+/* Read method for the vX aliases for the raw vrX registers.  */\n+\n+static enum register_status\n+v_alias_pseudo_register_read (struct gdbarch *gdbarch,\n+\t\t\t      readable_regcache *regcache, int reg_nr,\n+\t\t\t      gdb_byte *buffer)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n+\n+  return regcache->raw_read (tdep->ppc_vr0_regnum\n+\t\t\t     + (reg_nr - tdep->ppc_v0_alias_regnum),\n+\t\t\t     buffer);\n+}\n+\n+/* Write method for the vX aliases for the raw vrX registers.  */\n+\n+static void\n+v_alias_pseudo_register_write (struct gdbarch *gdbarch,\n+\t\t\t       struct regcache *regcache,\n+\t\t\t       int reg_nr, const gdb_byte *buffer)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n+\n+  regcache->raw_write (tdep->ppc_vr0_regnum\n+\t\t       + (reg_nr - tdep->ppc_v0_alias_regnum), buffer);\n+}\n+\n /* Read method for POWER7 VSX pseudo-registers.  */\n static enum register_status\n vsx_pseudo_register_read (struct gdbarch *gdbarch, readable_regcache *regcache,\n@@ -2886,6 +2958,9 @@ rs6000_pseudo_register_read (struct gdbarch *gdbarch,\n   else if (IS_DFP_PSEUDOREG (tdep, reg_nr)\n \t   || IS_CDFP_PSEUDOREG (tdep, reg_nr))\n     return dfp_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);\n+  else if (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr))\n+    return v_alias_pseudo_register_read (gdbarch, regcache, reg_nr,\n+\t\t\t\t\t buffer);\n   else if (IS_VSX_PSEUDOREG (tdep, reg_nr)\n \t   || IS_CVSX_PSEUDOREG (tdep, reg_nr))\n     return vsx_pseudo_register_read (gdbarch, regcache, reg_nr, buffer);\n@@ -2914,6 +2989,8 @@ rs6000_pseudo_register_write (struct gdbarch *gdbarch,\n   else if (IS_DFP_PSEUDOREG (tdep, reg_nr)\n \t   || IS_CDFP_PSEUDOREG (tdep, reg_nr))\n     dfp_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);\n+  else if (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr))\n+    v_alias_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);\n   else if (IS_VSX_PSEUDOREG (tdep, reg_nr)\n \t   || IS_CVSX_PSEUDOREG (tdep, reg_nr))\n     vsx_pseudo_register_write (gdbarch, regcache, reg_nr, buffer);\n@@ -2954,6 +3031,20 @@ dfp_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n   ax_reg_mask (ax, fp0 + 2 * reg_index + 1);\n }\n \n+/* Set the register mask in AX with the raw vector register that\n+   corresponds to its REG_NR alias.  */\n+\n+static void\n+v_alias_pseudo_register_collect (struct gdbarch *gdbarch,\n+\t\t\t\t struct agent_expr *ax, int reg_nr)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  gdb_assert (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr));\n+\n+  ax_reg_mask (ax, tdep->ppc_vr0_regnum\n+\t       + (reg_nr - tdep->ppc_v0_alias_regnum));\n+}\n+\n /* Set the register mask in AX with the registers that form the VSX or\n    checkpointed VSX pseudo-register REG_NR.  */\n \n@@ -3034,6 +3125,10 @@ rs6000_ax_pseudo_register_collect (struct gdbarch *gdbarch,\n     {\n       dfp_ax_pseudo_register_collect (gdbarch, ax, reg_nr);\n     }\n+  else if (IS_V_ALIAS_PSEUDOREG (tdep, reg_nr))\n+    {\n+      v_alias_pseudo_register_collect (gdbarch, ax, reg_nr);\n+    }\n   else if (IS_VSX_PSEUDOREG (tdep, reg_nr)\n \t   || IS_CVSX_PSEUDOREG (tdep, reg_nr))\n     {\n@@ -6891,7 +6986,8 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   else\n     tdep->lr_frame_offset = 4;\n \n-  if (have_spe || have_dfp || have_vsx || have_htm_fpu || have_htm_vsx)\n+  if (have_spe || have_dfp || have_altivec\n+      || have_vsx || have_htm_fpu || have_htm_vsx)\n     {\n       set_gdbarch_pseudo_register_read (gdbarch, rs6000_pseudo_register_read);\n       set_gdbarch_pseudo_register_write (gdbarch,\n@@ -6910,6 +7006,8 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     num_pseudoregs += 32;\n   if (have_dfp)\n     num_pseudoregs += 16;\n+  if (have_altivec)\n+    num_pseudoregs += 32;\n   if (have_vsx)\n     /* Include both VSX and Extended FP registers.  */\n     num_pseudoregs += 96;\n@@ -7022,6 +7120,8 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   set_tdesc_pseudo_register_type (gdbarch, rs6000_pseudo_register_type);\n+  set_tdesc_pseudo_register_reggroup_p (gdbarch,\n+\t\t\t\t\trs6000_pseudo_register_reggroup_p);\n   tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n \n   /* Override the normal target description method to make the SPE upper\n@@ -7031,6 +7131,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Choose register numbers for all supported pseudo-registers.  */\n   tdep->ppc_ev0_regnum = -1;\n   tdep->ppc_dl0_regnum = -1;\n+  tdep->ppc_v0_alias_regnum = -1;\n   tdep->ppc_vsr0_regnum = -1;\n   tdep->ppc_efpr0_regnum = -1;\n   tdep->ppc_cdl0_regnum = -1;\n@@ -7049,6 +7150,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       tdep->ppc_dl0_regnum = cur_reg;\n       cur_reg += 16;\n     }\n+  if (have_altivec)\n+    {\n+      tdep->ppc_v0_alias_regnum = cur_reg;\n+      cur_reg += 32;\n+    }\n   if (have_vsx)\n     {\n       tdep->ppc_vsr0_regnum = cur_reg;"
    },
    {
      "sha": "af132ffe04a23d094e347186d457d5bbff10373b",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -1,3 +1,12 @@\n+2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n+\n+\t* gdb.arch/vsx-regs.exp: Add tests that use the vector register\n+\taliases.\n+\t* gdb.arch/altivec-regs.exp: Likewise.  Fix indentation of two\n+\ttests.\n+\t* gdb.arch/powerpc-vector-regs.c: New file.\n+\t* gdb.arch/powerpc-vector-regs.exp: New file.\n+\n 2019-01-14  Pedro Franco de Carvalho  <pedromfc@linux.ibm.com>\n \n \t* gdb.arch/altivec-regs.exp: Fix the list passed to"
    },
    {
      "sha": "a7b2aec802a303352005b0bfa46413742fcfc045",
      "filename": "gdb/testsuite/gdb.arch/altivec-regs.exp",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/altivec-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/altivec-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/altivec-regs.exp?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -91,7 +91,8 @@ set vector_register \".uint128 = 0x1000000010000000100000001, v4_float = .0x0, 0x\n }\n \n for {set i 0} {$i < 32} {incr i 1} {\n-        gdb_test \"info reg vr$i\" \"vr$i.*$vector_register\" \"info reg vr$i\"\n+    gdb_test \"info reg vr$i\" \"vr$i.*$vector_register\" \"info reg vr$i\"\n+    gdb_test \"info reg v$i\" \"v$i.*$vector_register\" \"info reg v$i\"\n }\n \n gdb_test \"info reg vrsave\" \"vrsave.*0x1\\[ \\t\\]+1\" \"info reg vrsave\"\n@@ -110,7 +111,8 @@ if {$endianness == \"big\"} {\n }\n \n for {set i 0} {$i < 32} {incr i 1} {\n-        gdb_test \"print \\$vr$i\" \".* = $decimal_vector\" \"print vr$i\"\n+    gdb_test \"print \\$vr$i\" \".* = $decimal_vector\" \"print vr$i\"\n+    gdb_test \"print \\$v$i\" \".* = $decimal_vector\" \"print v$i\"\n }\n \n gdb_test \"print \\$vrsave\" \".* = 1\" \"print vrsave\""
    },
    {
      "sha": "925f0d7916411c4cd2c226897347f3d885bfd0fa",
      "filename": "gdb/testsuite/gdb.arch/powerpc-vector-regs.c",
      "status": "added",
      "additions": 59,
      "deletions": 0,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/powerpc-vector-regs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/powerpc-vector-regs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/powerpc-vector-regs.c?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -0,0 +1,59 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Write bytes with values ranging from 0 to 31 to each byte of each\n+   corresponding vector register.  */\n+int main (void)\n+{\n+  asm volatile (\"vspltisb 0, 0\" : : : \"v0\");\n+  asm volatile (\"vspltisb 1, 1\" : : : \"v1\");\n+\n+  asm volatile (\"vaddubm 2, 1, 1\" : : : \"v2\");\n+  asm volatile (\"vaddubm 3, 2, 1\" : : : \"v3\");\n+  asm volatile (\"vaddubm 4, 3, 1\" : : : \"v4\");\n+  asm volatile (\"vaddubm 5, 4, 1\" : : : \"v5\");\n+  asm volatile (\"vaddubm 6, 5, 1\" : : : \"v6\");\n+  asm volatile (\"vaddubm 7, 6, 1\" : : : \"v7\");\n+  asm volatile (\"vaddubm 8, 7, 1\" : : : \"v8\");\n+  asm volatile (\"vaddubm 9, 8, 1\" : : : \"v9\");\n+  asm volatile (\"vaddubm 10, 9, 1\" : : : \"v10\");\n+  asm volatile (\"vaddubm 11, 10, 1\" : : : \"v11\");\n+  asm volatile (\"vaddubm 12, 11, 1\" : : : \"v12\");\n+  asm volatile (\"vaddubm 13, 12, 1\" : : : \"v13\");\n+  asm volatile (\"vaddubm 14, 13, 1\" : : : \"v14\");\n+  asm volatile (\"vaddubm 15, 14, 1\" : : : \"v15\");\n+  asm volatile (\"vaddubm 16, 15, 1\" : : : \"v16\");\n+  asm volatile (\"vaddubm 17, 16, 1\" : : : \"v17\");\n+  asm volatile (\"vaddubm 18, 17, 1\" : : : \"v18\");\n+  asm volatile (\"vaddubm 19, 18, 1\" : : : \"v19\");\n+  asm volatile (\"vaddubm 20, 19, 1\" : : : \"v20\");\n+  asm volatile (\"vaddubm 21, 20, 1\" : : : \"v21\");\n+  asm volatile (\"vaddubm 22, 21, 1\" : : : \"v22\");\n+  asm volatile (\"vaddubm 23, 22, 1\" : : : \"v23\");\n+  asm volatile (\"vaddubm 24, 23, 1\" : : : \"v24\");\n+  asm volatile (\"vaddubm 25, 24, 1\" : : : \"v25\");\n+  asm volatile (\"vaddubm 26, 25, 1\" : : : \"v26\");\n+  asm volatile (\"vaddubm 27, 26, 1\" : : : \"v27\");\n+  asm volatile (\"vaddubm 28, 27, 1\" : : : \"v28\");\n+  asm volatile (\"vaddubm 29, 28, 1\" : : : \"v29\");\n+  asm volatile (\"vaddubm 30, 29, 1\" : : : \"v30\");\n+  asm volatile (\"vaddubm 31, 30, 1\" : : : \"v31\");\n+\n+  asm volatile (\"nop\"); // marker\n+\n+  return 0;\n+}"
    },
    {
      "sha": "fdf7c5662d94886b4a30247b111ffd2762fc664f",
      "filename": "gdb/testsuite/gdb.arch/powerpc-vector-regs.exp",
      "status": "added",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/powerpc-vector-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/powerpc-vector-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/powerpc-vector-regs.exp?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -0,0 +1,62 @@\n+# Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is part of the gdb testsuite.\n+\n+# Test vector register access on Power.  The inferior executes\n+# instructions that fill the vector registers with values ranging from\n+# 0 to 31 in each of the 16 bytes of each corresponding register, and\n+# we then check if gdb sees these same values.\n+\n+if {![istarget \"powerpc*\"] || [skip_altivec_tests]} {\n+    verbose \"Skipping PowerPC vector register tests.\"\n+    return\n+}\n+\n+standard_testfile\n+\n+if { [gdb_compile ${srcdir}/${subdir}/${srcfile} ${binfile} executable {debug}] != \"\" } {\n+    untested \"vector register tests for PowerPC\"\n+    return\n+}\n+\n+# Check if our test binary can actually run on this processor.\n+clean_restart ${binfile}\n+\n+gdb_run_cmd\n+\n+gdb_test_multiple \"\" \"wait for exit\" {\n+    -re \".*Illegal instruction.*${gdb_prompt} $\" {\n+\tunsupported \"vector register tests for PowerPC\"\n+\treturn\n+    }\n+    -re \".*$inferior_exited_re normally.*${gdb_prompt} $\" {\n+    }\n+}\n+\n+# Run the actual test.\n+clean_restart ${binfile}\n+\n+gdb_breakpoint [gdb_get_line_number \"marker\"]\n+\n+gdb_run_cmd\n+\n+# Wait for the prompt.\n+gdb_test \"\" \"Breakpoint.*at.*\" \"wait for prompt\"\n+\n+for {set i 0} {$i < 32} {incr i 1} {\n+    gdb_test \"p/z \\$vr$i.uint128\" \".* = 0x(0?[format %x $i]){16}.*\"\n+    gdb_test \"p/z \\$v$i.uint128\" \".* = 0x(0?[format %x $i]){16}.*\"\n+}"
    },
    {
      "sha": "d2fa6126995c7b9bd25e8d1921926201cee41094",
      "filename": "gdb/testsuite/gdb.arch/vsx-regs.exp",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/vsx-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f072a103498fa9b7795782d9fdf1ae226f5565e/gdb/testsuite/gdb.arch/vsx-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/vsx-regs.exp?ref=6f072a103498fa9b7795782d9fdf1ae226f5565e",
      "patch": "@@ -136,6 +136,7 @@ for {set i 32} {$i < 64} {incr i 1} {\n \n for {set i 0} {$i < 32} {incr i 1} {\n     gdb_test \"info reg vr$i\" \"vr$i.*$vector_register3_vr\" \"info reg vr$i\"\n+    gdb_test \"info reg v$i\" \"v$i.*$vector_register3_vr\" \"info reg v$i\"\n }\n \n # Create a core file.  We create the core file before the F32~F63/VR0~VR31 test\n@@ -155,6 +156,7 @@ for {set i 32} {$i < 64} {incr i 1} {\n \n for {set i 0} {$i < 32} {incr i 1} {\n     gdb_test \"info reg vr$i\" \"vr$i.*$vector_register1_vr\" \"info reg vr$i (doubleword 0)\"\n+    gdb_test \"info reg v$i\" \"v$i.*$vector_register1_vr\" \"info reg v$i (doubleword 0)\"\n }\n \n # 2: Set VR0~VR31 registers and check if it reflects on F32~F63.\n@@ -170,6 +172,7 @@ for {set i 32} {$i < 64} {incr i 1} {\n \n for {set i 0} {$i < 32} {incr i 1} {\n     gdb_test \"info reg vr$i\" \"vr$i.*$vector_register2_vr\" \"info reg vr$i (doubleword 1)\"\n+    gdb_test \"info reg v$i\" \"v$i.*$vector_register2_vr\" \"info reg v$i (doubleword 1)\"\n }\n \n # Test reading the core file."
    }
  ]
}