{
  "sha": "03cd72b8107b34e7b572f9962ee589472ff1fa1e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDNjZDcyYjgxMDdiMzRlN2I1NzJmOTk2MmVlNTg5NDcyZmYxZmExZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-19T17:54:49Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-19T17:54:53Z"
    },
    "message": "Use gdb_bfd_sections in restore_command\n\nThis changes restore_command to avoid bfd_map_over_sections, in favor\nof iteration.  A helper data structure can also be removed by this\npatch.\n\ngdb/ChangeLog\n2020-09-19  Tom Tromey  <tom@tromey.com>\n\n\t* cli/cli-dump.c (struct callback_data): Remove.\n\t(restore_one_section): Rename from restore_section_callback.\n\tChange parameters.\n\t(restore_binary_file): Change parameters.\n\t(restore_command): Use foreach.",
    "tree": {
      "sha": "6b4fcbde7c4de10c6958e0eebc12747cbb02741f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6b4fcbde7c4de10c6958e0eebc12747cbb02741f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/03cd72b8107b34e7b572f9962ee589472ff1fa1e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/03cd72b8107b34e7b572f9962ee589472ff1fa1e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/03cd72b8107b34e7b572f9962ee589472ff1fa1e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/03cd72b8107b34e7b572f9962ee589472ff1fa1e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f4f2b85fb2eab29ea981b2c3f2058c1dc04e413c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4f2b85fb2eab29ea981b2c3f2058c1dc04e413c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f4f2b85fb2eab29ea981b2c3f2058c1dc04e413c"
    }
  ],
  "stats": {
    "total": 102,
    "additions": 53,
    "deletions": 49
  },
  "files": [
    {
      "sha": "1c950448c6f18b8d029131e984a3485688ba715c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03cd72b8107b34e7b572f9962ee589472ff1fa1e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03cd72b8107b34e7b572f9962ee589472ff1fa1e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=03cd72b8107b34e7b572f9962ee589472ff1fa1e",
      "patch": "@@ -1,3 +1,11 @@\n+2020-09-19  Tom Tromey  <tom@tromey.com>\n+\n+\t* cli/cli-dump.c (struct callback_data): Remove.\n+\t(restore_one_section): Rename from restore_section_callback.\n+\tChange parameters.\n+\t(restore_binary_file): Change parameters.\n+\t(restore_command): Use foreach.\n+\n 2020-09-19  Tom Tromey  <tom@tromey.com>\n \n \t* gcore.c (make_output_phdrs): Remove 'ignored' parameter."
    },
    {
      "sha": "c8d6797ddc1fc92e663b999e8d92a4fae8721d56",
      "filename": "gdb/cli/cli-dump.c",
      "status": "modified",
      "additions": 45,
      "deletions": 49,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03cd72b8107b34e7b572f9962ee589472ff1fa1e/gdb/cli/cli-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03cd72b8107b34e7b572f9962ee589472ff1fa1e/gdb/cli/cli-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-dump.c?ref=03cd72b8107b34e7b572f9962ee589472ff1fa1e",
      "patch": "@@ -371,22 +371,14 @@ add_dump_command (const char *name,\n     c->doc = concat (\"Append \", c->doc + 6, (char *)NULL);\n }\n \n-/* Opaque data for restore_section_callback.  */\n-struct callback_data {\n-  CORE_ADDR load_offset;\n-  CORE_ADDR load_start;\n-  CORE_ADDR load_end;\n-};\n-\n-/* Function: restore_section_callback.\n-\n-   Callback function for bfd_map_over_sections.\n-   Selectively loads the sections into memory.  */\n+/* Selectively loads the sections into memory.  */\n \n static void\n-restore_section_callback (bfd *ibfd, asection *isec, void *args)\n+restore_one_section (bfd *ibfd, asection *isec,\n+\t\t     CORE_ADDR load_offset,\n+\t\t     CORE_ADDR load_start,\n+\t\t     CORE_ADDR load_end)\n {\n-  struct callback_data *data = (struct callback_data *) args;\n   bfd_vma sec_start  = bfd_section_vma (isec);\n   bfd_size_type size = bfd_section_size (isec);\n   bfd_vma sec_end    = sec_start + size;\n@@ -399,8 +391,8 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)\n     return;\n \n   /* Does the section overlap with the desired restore range? */\n-  if (sec_end <= data->load_start \n-      || (data->load_end > 0 && sec_start >= data->load_end))\n+  if (sec_end <= load_start\n+      || (load_end > 0 && sec_start >= load_end))\n     {\n       /* No, no useable data in this section.  */\n       printf_filtered (_(\"skipping section %s...\\n\"), \n@@ -411,12 +403,12 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)\n   /* Compare section address range with user-requested\n      address range (if any).  Compute where the actual\n      transfer should start and end.  */\n-  if (sec_start < data->load_start)\n-    sec_offset = data->load_start - sec_start;\n+  if (sec_start < load_start)\n+    sec_offset = load_start - sec_start;\n   /* Size of a partial transfer.  */\n   sec_load_count -= sec_offset;\n-  if (data->load_end > 0 && sec_end > data->load_end)\n-    sec_load_count -= sec_end - data->load_end;\n+  if (load_end > 0 && sec_end > load_end)\n+    sec_load_count -= sec_end - load_end;\n \n   /* Get the data.  */\n   gdb::byte_vector buf (size);\n@@ -429,26 +421,28 @@ restore_section_callback (bfd *ibfd, asection *isec, void *args)\n \t\t   (unsigned long) sec_start, \n \t\t   (unsigned long) sec_end);\n \n-  if (data->load_offset != 0 || data->load_start != 0 || data->load_end != 0)\n+  if (load_offset != 0 || load_start != 0 || load_end != 0)\n     printf_filtered (\" into memory (%s to %s)\\n\",\n \t\t     paddress (target_gdbarch (),\n \t\t\t       (unsigned long) sec_start\n-\t\t\t       + sec_offset + data->load_offset), \n+\t\t\t       + sec_offset + load_offset),\n \t\t     paddress (target_gdbarch (),\n \t\t\t       (unsigned long) sec_start + sec_offset\n-\t\t\t\t+ data->load_offset + sec_load_count));\n+\t\t\t\t+ load_offset + sec_load_count));\n   else\n     puts_filtered (\"\\n\");\n \n   /* Write the data.  */\n-  ret = target_write_memory (sec_start + sec_offset + data->load_offset, \n+  ret = target_write_memory (sec_start + sec_offset + load_offset,\n \t\t\t     &buf[sec_offset], sec_load_count);\n   if (ret != 0)\n     warning (_(\"restore: memory write failed (%s).\"), safe_strerror (ret));\n }\n \n static void\n-restore_binary_file (const char *filename, struct callback_data *data)\n+restore_binary_file (const char *filename, CORE_ADDR load_offset,\n+\t\t     CORE_ADDR load_start, CORE_ADDR load_end)\n+\n {\n   gdb_file_up file = gdb_fopen_cloexec (filename, FOPEN_RB);\n   long len;\n@@ -466,25 +460,25 @@ restore_binary_file (const char *filename, struct callback_data *data)\n   else\n     perror_with_name (filename);\n \n-  if (len <= data->load_start)\n+  if (len <= load_start)\n     error (_(\"Start address is greater than length of binary file %s.\"), \n \t   filename);\n \n   /* Chop off \"len\" if it exceeds the requested load_end addr.  */\n-  if (data->load_end != 0 && data->load_end < len)\n-    len = data->load_end;\n+  if (load_end != 0 && load_end < len)\n+    len = load_end;\n   /* Chop off \"len\" if the requested load_start addr skips some bytes.  */\n-  if (data->load_start > 0)\n-    len -= data->load_start;\n+  if (load_start > 0)\n+    len -= load_start;\n \n   printf_filtered \n     (\"Restoring binary file %s into memory (0x%lx to 0x%lx)\\n\", \n      filename, \n-     (unsigned long) (data->load_start + data->load_offset),\n-     (unsigned long) (data->load_start + data->load_offset + len));\n+     (unsigned long) (load_start + load_offset),\n+     (unsigned long) (load_start + load_offset + len));\n \n   /* Now set the file pos to the requested load start pos.  */\n-  if (fseek (file.get (), data->load_start, SEEK_SET) != 0)\n+  if (fseek (file.get (), load_start, SEEK_SET) != 0)\n     perror_with_name (filename);\n \n   /* Now allocate a buffer and read the file contents.  */\n@@ -493,24 +487,22 @@ restore_binary_file (const char *filename, struct callback_data *data)\n     perror_with_name (filename);\n \n   /* Now write the buffer into target memory.  */\n-  len = target_write_memory (data->load_start + data->load_offset,\n-\t\t\t     buf.data (), len);\n+  len = target_write_memory (load_start + load_offset, buf.data (), len);\n   if (len != 0)\n     warning (_(\"restore: memory write failed (%s).\"), safe_strerror (len));\n }\n \n static void\n restore_command (const char *args, int from_tty)\n {\n-  struct callback_data data;\n   int binary_flag = 0;\n \n   if (!target_has_execution)\n     noprocess ();\n \n-  data.load_offset = 0;\n-  data.load_start  = 0;\n-  data.load_end    = 0;\n+  CORE_ADDR load_offset = 0;\n+  CORE_ADDR load_start  = 0;\n+  CORE_ADDR load_end    = 0;\n \n   /* Parse the input arguments.  First is filename (required).  */\n   gdb::unique_xmalloc_ptr<char> filename = scan_filename (&args, NULL);\n@@ -527,41 +519,45 @@ restore_command (const char *args, int from_tty)\n \t}\n       /* Parse offset (optional).  */\n       if (args != NULL && *args != '\\0')\n-\tdata.load_offset = binary_flag ?\n-\t  parse_and_eval_address (scan_expression (&args, NULL).get ()) :\n-\t  parse_and_eval_long (scan_expression (&args, NULL).get ());\n+\tload_offset\n+\t  = (binary_flag\n+\t     ? parse_and_eval_address (scan_expression (&args, NULL).get ())\n+\t     : parse_and_eval_long (scan_expression (&args, NULL).get ()));\n       if (args != NULL && *args != '\\0')\n \t{\n \t  /* Parse start address (optional).  */\n-\t  data.load_start = \n+\t  load_start =\n \t    parse_and_eval_long (scan_expression (&args, NULL).get ());\n \t  if (args != NULL && *args != '\\0')\n \t    {\n \t      /* Parse end address (optional).  */\n-\t      data.load_end = parse_and_eval_long (args);\n-\t      if (data.load_end <= data.load_start)\n+\t      load_end = parse_and_eval_long (args);\n+\t      if (load_end <= load_start)\n \t\terror (_(\"Start must be less than end.\"));\n \t    }\n \t}\n     }\n \n   if (info_verbose)\n     printf_filtered (\"Restore file %s offset 0x%lx start 0x%lx end 0x%lx\\n\",\n-\t\t     filename.get (), (unsigned long) data.load_offset,\n-\t\t     (unsigned long) data.load_start, \n-\t\t     (unsigned long) data.load_end);\n+\t\t     filename.get (), (unsigned long) load_offset,\n+\t\t     (unsigned long) load_start,\n+\t\t     (unsigned long) load_end);\n \n   if (binary_flag)\n     {\n-      restore_binary_file (filename.get (), &data);\n+      restore_binary_file (filename.get (), load_offset, load_start,\n+\t\t\t   load_end);\n     }\n   else\n     {\n       /* Open the file for loading.  */\n       gdb_bfd_ref_ptr ibfd (bfd_openr_or_error (filename.get (), NULL));\n \n       /* Process the sections.  */\n-      bfd_map_over_sections (ibfd.get (), restore_section_callback, &data);\n+      for (asection *sect : gdb_bfd_sections (ibfd))\n+\trestore_one_section (ibfd.get (), sect, load_offset, load_start,\n+\t\t\t     load_end);\n     }\n }\n "
    }
  ]
}