{
  "sha": "b494cdff6922944383ef4dc20fcc90c4d823d315",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjQ5NGNkZmY2OTIyOTQ0MzgzZWY0ZGMyMGZjYzkwYzRkODIzZDMxNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-07T22:17:40Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-19T20:29:32Z"
    },
    "message": "Use std::list for event notifications in gdbserver\n\nThis changes gdbserver to use std::list rather than common/queue.h for\nevent notifications.\n\ngdb/gdbserver/ChangeLog\n2019-04-19  Tom Tromey  <tom@tromey.com>\n\n\t* server.c (struct vstop_notif): Derive from notif_event.\n\t<base>: Remove.\n\t(queue_stop_reply): Update.\n\t(remove_all_on_match_ptid): Change type.  Rewrite.\n\t(discard_queued_stop_replies): Rewrite.\n\t(in_queued_stop_replies_ptid): Change type.\n\t(in_queued_stop_replies): Rewrite.\n\t(notif_stop): Update.\n\t(queue_stop_reply_callback): Update.\n\t(captured_main): Don't call initialize_notif.\n\t(push_stop_notification): Update.\n\t* notif.c (notif_write_event, handle_notif_ack)\n\t(notif_event_enque, notif_push): Update.\n\t(notif_event_xfree, initialize_notif): Remove.\n\t* notif.h (struct notif_event): Include <list>, not\n\t\"common/queue.h\".\n\t(struct notif_server) <queue>: Now a std::list.\n\t(notif_event_p): Remove typedef.\n\t(initialize_notif): Don't declare.\n\t(struct notif_event): Add virtual destructor.",
    "tree": {
      "sha": "cb98e6f414bd464bc5edb3709c1554a39c30620d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cb98e6f414bd464bc5edb3709c1554a39c30620d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b494cdff6922944383ef4dc20fcc90c4d823d315",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b494cdff6922944383ef4dc20fcc90c4d823d315",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b494cdff6922944383ef4dc20fcc90c4d823d315",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b494cdff6922944383ef4dc20fcc90c4d823d315/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cf250e36790aaa255bb486e2122bb83c95c7669b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf250e36790aaa255bb486e2122bb83c95c7669b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cf250e36790aaa255bb486e2122bb83c95c7669b"
    }
  ],
  "stats": {
    "total": 157,
    "additions": 78,
    "deletions": 79
  },
  "files": [
    {
      "sha": "2985281518171c655a706c3469725dd8f868df7e",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=b494cdff6922944383ef4dc20fcc90c4d823d315",
      "patch": "@@ -1,3 +1,26 @@\n+2019-04-19  Tom Tromey  <tom@tromey.com>\n+\n+\t* server.c (struct vstop_notif): Derive from notif_event.\n+\t<base>: Remove.\n+\t(queue_stop_reply): Update.\n+\t(remove_all_on_match_ptid): Change type.  Rewrite.\n+\t(discard_queued_stop_replies): Rewrite.\n+\t(in_queued_stop_replies_ptid): Change type.\n+\t(in_queued_stop_replies): Rewrite.\n+\t(notif_stop): Update.\n+\t(queue_stop_reply_callback): Update.\n+\t(captured_main): Don't call initialize_notif.\n+\t(push_stop_notification): Update.\n+\t* notif.c (notif_write_event, handle_notif_ack)\n+\t(notif_event_enque, notif_push): Update.\n+\t(notif_event_xfree, initialize_notif): Remove.\n+\t* notif.h (struct notif_event): Include <list>, not\n+\t\"common/queue.h\".\n+\t(struct notif_server) <queue>: Now a std::list.\n+\t(notif_event_p): Remove typedef.\n+\t(initialize_notif): Don't declare.\n+\t(struct notif_event): Add virtual destructor.\n+\n 2019-04-17  Alan Hayward  <alan.hayward@arm.com>\n \n \t* ax.c (ax_vdebug): Call debug_printf."
    },
    {
      "sha": "0b526eda503e3f4dc45da2f2ed7be2e2a09aac32",
      "filename": "gdb/gdbserver/notif.c",
      "status": "modified",
      "additions": 10,
      "deletions": 27,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/notif.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/notif.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/notif.c?ref=b494cdff6922944383ef4dc20fcc90c4d823d315",
      "patch": "@@ -61,10 +61,9 @@ static struct notif_server *notifs[] =\n void\n notif_write_event (struct notif_server *notif, char *own_buf)\n {\n-  if (!QUEUE_is_empty (notif_event_p, notif->queue))\n+  if (!notif->queue.empty ())\n     {\n-      struct notif_event *event\n-\t= QUEUE_peek (notif_event_p, notif->queue);\n+      struct notif_event *event = notif->queue.front ();\n \n       notif->write (event, own_buf);\n     }\n@@ -98,16 +97,16 @@ handle_notif_ack (char *own_buf, int packet_len)\n \n   /* If we're waiting for GDB to acknowledge a pending event,\n      consider that done.  */\n-  if (!QUEUE_is_empty (notif_event_p, np->queue))\n+  if (!np->queue.empty ())\n     {\n-      struct notif_event *head\n-\t= QUEUE_deque (notif_event_p, np->queue);\n+      struct notif_event *head = np->queue.front ();\n+      np->queue.pop_front ();\n \n       if (remote_debug)\n \tdebug_printf (\"%s: acking %d\\n\", np->ack_name,\n-\t\t      QUEUE_length (notif_event_p, np->queue));\n+\t\t      (int) np->queue.size ());\n \n-      xfree (head);\n+      delete head;\n     }\n \n   notif_write_event (np, own_buf);\n@@ -121,11 +120,11 @@ void\n notif_event_enque (struct notif_server *notif,\n \t\t   struct notif_event *event)\n {\n-  QUEUE_enque (notif_event_p, notif->queue, event);\n+  notif->queue.push_back (event);\n \n   if (remote_debug)\n     debug_printf (\"pending events: %s %d\\n\", notif->notif_name,\n-\t\t  QUEUE_length (notif_event_p, notif->queue));\n+\t\t  (int) notif->queue.size ());\n \n }\n \n@@ -134,7 +133,7 @@ notif_event_enque (struct notif_server *notif,\n void\n notif_push (struct notif_server *np, struct notif_event *new_event)\n {\n-  int is_first_event = QUEUE_is_empty (notif_event_p, np->queue);\n+  bool is_first_event = np->queue.empty ();\n \n   /* Something interesting.  Tell GDB about it.  */\n   notif_event_enque (np, new_event);\n@@ -153,19 +152,3 @@ notif_push (struct notif_server *np, struct notif_event *new_event)\n       putpkt_notif (buf);\n     }\n }\n-\n-static void\n-notif_event_xfree (struct notif_event *event)\n-{\n-  xfree (event);\n-}\n-\n-void\n-initialize_notif (void)\n-{\n-  int i = 0;\n-\n-  for (i = 0; i < ARRAY_SIZE (notifs); i++)\n-    notifs[i]->queue\n-      = QUEUE_alloc (notif_event_p, notif_event_xfree);\n-}"
    },
    {
      "sha": "c0525126fdc8703c83a63ff66fa3ce25d7333f61",
      "filename": "gdb/gdbserver/notif.h",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/notif.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/notif.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/notif.h?ref=b494cdff6922944383ef4dc20fcc90c4d823d315",
      "patch": "@@ -20,19 +20,20 @@\n #define GDBSERVER_NOTIF_H\n \n #include \"target.h\"\n-#include \"common/queue.h\"\n+#include <list>\n \n /* Structure holding information related to a single event.  We\n    keep a queue of these to push to GDB.  It can be extended if\n    the event of given notification contains more information.  */\n \n-typedef struct notif_event\n+struct notif_event\n {\n-  /* C requires that a struct or union has at least one member.  */\n-  char dummy;\n-} *notif_event_p;\n+  virtual ~notif_event ()\n+  {\n+  }\n \n-DECLARE_QUEUE_P (notif_event_p);\n+  /* No payload needed.  */\n+};\n \n /* A type notification to GDB.  An object of 'struct notif_server'\n    represents a type of notification.  */\n@@ -49,7 +50,7 @@ typedef struct notif_server\n   /* A queue of events to GDB.  A new notif_event can be enque'ed\n      into QUEUE at any appropriate time, and the notif_reply is\n      deque'ed only when the ack from GDB arrives.  */\n-  QUEUE (notif_event_p) *queue;\n+  std::list<notif_event *> queue;\n \n   /* Write event EVENT to OWN_BUF.  */\n   void (*write) (struct notif_event *event, char *own_buf);\n@@ -64,6 +65,4 @@ void notif_push (struct notif_server *np, struct notif_event *event);\n void notif_event_enque (struct notif_server *notif,\n \t\t\tstruct notif_event *event);\n \n-void initialize_notif (void);\n-\n #endif /* GDBSERVER_NOTIF_H */"
    },
    {
      "sha": "fae5b2433cf0a43eba5cbb3736da2807d69828c5",
      "filename": "gdb/gdbserver/server.c",
      "status": "modified",
      "additions": 37,
      "deletions": 43,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/server.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b494cdff6922944383ef4dc20fcc90c4d823d315/gdb/gdbserver/server.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/server.c?ref=b494cdff6922944383ef4dc20fcc90c4d823d315",
      "patch": "@@ -140,10 +140,8 @@ static unsigned char *mem_buf;\n    relative to a single stop reply.  We keep a queue of these to\n    push to GDB in non-stop mode.  */\n \n-struct vstop_notif\n+struct vstop_notif : public notif_event\n {\n-  struct notif_event base;\n-\n   /* Thread or process that got the event.  */\n   ptid_t ptid;\n \n@@ -155,8 +153,6 @@ struct vstop_notif\n    btrace configuration.  */\n static struct btrace_config current_btrace_conf;\n \n-DEFINE_QUEUE_P (notif_event_p);\n-\n /* The client remote protocol state. */\n \n static client_state g_client_state;\n@@ -174,41 +170,40 @@ get_client_state ()\n static void\n queue_stop_reply (ptid_t ptid, struct target_waitstatus *status)\n {\n-  struct vstop_notif *new_notif = XNEW (struct vstop_notif);\n+  struct vstop_notif *new_notif = new struct vstop_notif;\n \n   new_notif->ptid = ptid;\n   new_notif->status = *status;\n \n-  notif_event_enque (&notif_stop, (struct notif_event *) new_notif);\n+  notif_event_enque (&notif_stop, new_notif);\n }\n \n-static int\n-remove_all_on_match_ptid (QUEUE (notif_event_p) *q,\n-\t\t\t  QUEUE_ITER (notif_event_p) *iter,\n-\t\t\t  struct notif_event *event,\n-\t\t\t  void *data)\n+static bool\n+remove_all_on_match_ptid (struct notif_event *event, ptid_t filter_ptid)\n {\n-  ptid_t filter_ptid = *(ptid_t *) data;\n   struct vstop_notif *vstop_event = (struct vstop_notif *) event;\n \n-  if (vstop_event->ptid.matches (filter_ptid))\n-    {\n-      if (q->free_func != NULL)\n-\tq->free_func (event);\n-\n-      QUEUE_remove_elem (notif_event_p, q, iter);\n-    }\n-\n-  return 1;\n+  return vstop_event->ptid.matches (filter_ptid);\n }\n \n /* See server.h.  */\n \n void\n discard_queued_stop_replies (ptid_t ptid)\n {\n-  QUEUE_iterate (notif_event_p, notif_stop.queue,\n-\t\t remove_all_on_match_ptid, &ptid);\n+  std::list<notif_event *>::iterator iter, next, end;\n+  end = notif_stop.queue.end ();\n+  for (iter = notif_stop.queue.begin (); iter != end; iter = next)\n+    {\n+      next = iter;\n+      ++next;\n+\n+      if (remove_all_on_match_ptid (*iter, ptid))\n+\t{\n+\t  delete *iter;\n+\t  notif_stop.queue.erase (iter);\n+\t}\n+    }\n }\n \n static void\n@@ -219,41 +214,42 @@ vstop_notif_reply (struct notif_event *event, char *own_buf)\n   prepare_resume_reply (own_buf, vstop->ptid, &vstop->status);\n }\n \n-/* QUEUE_iterate callback helper for in_queued_stop_replies.  */\n+/* Helper for in_queued_stop_replies.  */\n \n-static int\n-in_queued_stop_replies_ptid (QUEUE (notif_event_p) *q,\n-\t\t\t     QUEUE_ITER (notif_event_p) *iter,\n-\t\t\t     struct notif_event *event,\n-\t\t\t     void *data)\n+static bool\n+in_queued_stop_replies_ptid (struct notif_event *event, ptid_t filter_ptid)\n {\n-  ptid_t filter_ptid = *(ptid_t *) data;\n   struct vstop_notif *vstop_event = (struct vstop_notif *) event;\n \n   if (vstop_event->ptid.matches (filter_ptid))\n-    return 0;\n+    return true;\n \n   /* Don't resume fork children that GDB does not know about yet.  */\n   if ((vstop_event->status.kind == TARGET_WAITKIND_FORKED\n        || vstop_event->status.kind == TARGET_WAITKIND_VFORKED)\n       && vstop_event->status.value.related_pid.matches (filter_ptid))\n-    return 0;\n+    return true;\n \n-  return 1;\n+  return false;\n }\n \n /* See server.h.  */\n \n int\n in_queued_stop_replies (ptid_t ptid)\n {\n-  return !QUEUE_iterate (notif_event_p, notif_stop.queue,\n-\t\t\t in_queued_stop_replies_ptid, &ptid);\n+  for (notif_event *event : notif_stop.queue)\n+    {\n+      if (in_queued_stop_replies_ptid (event, ptid))\n+\treturn true;\n+    }\n+\n+  return false;\n }\n \n struct notif_server notif_stop =\n {\n-  \"vStopped\", \"Stop\", NULL, vstop_notif_reply,\n+  \"vStopped\", \"Stop\", {}, vstop_notif_reply,\n };\n \n static int\n@@ -3247,14 +3243,13 @@ queue_stop_reply_callback (thread_info *thread)\n      manage the thread's last_status field.  */\n   if (the_target->thread_stopped == NULL)\n     {\n-      struct vstop_notif *new_notif = XNEW (struct vstop_notif);\n+      struct vstop_notif *new_notif = new struct vstop_notif;\n \n       new_notif->ptid = thread->id;\n       new_notif->status = thread->last_status;\n       /* Pass the last stop reply back to GDB, but don't notify\n \t yet.  */\n-      notif_event_enque (&notif_stop,\n-\t\t\t (struct notif_event *) new_notif);\n+      notif_event_enque (&notif_stop, new_notif);\n     }\n   else\n     {\n@@ -3789,7 +3784,6 @@ captured_main (int argc, char *argv[])\n   initialize_event_loop ();\n   if (target_supports_tracepoints ())\n     initialize_tracepoint ();\n-  initialize_notif ();\n \n   mem_buf = (unsigned char *) xmalloc (PBUFSIZ);\n \n@@ -4412,12 +4406,12 @@ handle_serial_event (int err, gdb_client_data client_data)\n static void\n push_stop_notification (ptid_t ptid, struct target_waitstatus *status)\n {\n-  struct vstop_notif *vstop_notif = XNEW (struct vstop_notif);\n+  struct vstop_notif *vstop_notif = new struct vstop_notif;\n \n   vstop_notif->status = *status;\n   vstop_notif->ptid = ptid;\n   /* Push Stop notification.  */\n-  notif_push (&notif_stop, (struct notif_event *) vstop_notif);\n+  notif_push (&notif_stop, vstop_notif);\n }\n \n /* Event-loop callback for target events.  */"
    }
  ]
}