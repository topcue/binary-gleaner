{
  "sha": "36cb72375cc371b786ceaec588ec26f8c55ae2ec",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzZjYjcyMzc1Y2MzNzFiNzg2Y2VhZWM1ODhlYzI2ZjhjNTVhZTJlYw==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-01-10T17:52:38Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-01-10T17:52:38Z"
    },
    "message": "Fix leak in mdebugread.c\n\nCoverity points out that all the \"continue;\" statements in the switch\ncase in parse_partial_symbols leak STABSTRING.  This is because we\nonly release STABSTRING at the end of the scope, with:\n\n     \t     \t  if (stabstring\n\t\t    && stabstring != debug_info->ss + fh->issBase + sh.iss)\n\t\t  xfree (stabstring);\n\nbut that bit of code is skipped if a case in the switch statement ends\nwith \"continue\".\n\nFix this by using gdb::unique_xmalloc_ptr to manage the heap-allocated\nversion of 'stabsstring'.\n\nI don't know how to test this.\n\ngdb/ChangeLog:\n2019-01-10  Pedro Alves  <palves@redhat.com>\n\n\t* mdebugread.c (parse_partial_symbols): Use\n\tgdb::unique_xmalloc_ptr to manage heap-allocated 'stabsstring'.",
    "tree": {
      "sha": "c0e9803a737866f7a77956e9181a5b62bac0ed87",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c0e9803a737866f7a77956e9181a5b62bac0ed87"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/36cb72375cc371b786ceaec588ec26f8c55ae2ec",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/36cb72375cc371b786ceaec588ec26f8c55ae2ec",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/36cb72375cc371b786ceaec588ec26f8c55ae2ec",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/36cb72375cc371b786ceaec588ec26f8c55ae2ec/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "da584958006fd0a3f3dccd25a0a54fa79a0976bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/da584958006fd0a3f3dccd25a0a54fa79a0976bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/da584958006fd0a3f3dccd25a0a54fa79a0976bc"
    }
  ],
  "stats": {
    "total": 28,
    "additions": 19,
    "deletions": 9
  },
  "files": [
    {
      "sha": "b651980a3f09c11a885d3a55b315aaf31bd47e47",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/36cb72375cc371b786ceaec588ec26f8c55ae2ec/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/36cb72375cc371b786ceaec588ec26f8c55ae2ec/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=36cb72375cc371b786ceaec588ec26f8c55ae2ec",
      "patch": "@@ -1,3 +1,8 @@\n+2019-01-10  Pedro Alves  <palves@redhat.com>\n+\n+\t* mdebugread.c (parse_partial_symbols): Use\n+\tgdb::unique_xmalloc_ptr to manage heap-allocated 'stabsstring'.\n+\n 2019-01-10  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* linux-fork.c (scoped_switch_fork_info)"
    },
    {
      "sha": "63cbb3027b36ca31f3aba14ab9d44beed6e0a3c4",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 14,
      "deletions": 9,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/36cb72375cc371b786ceaec588ec26f8c55ae2ec/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/36cb72375cc371b786ceaec588ec26f8c55ae2ec/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=36cb72375cc371b786ceaec588ec26f8c55ae2ec",
      "patch": "@@ -2765,6 +2765,9 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t      /* Handle stabs continuation.  */\n \t      {\n \t\tchar *stabstring = debug_info->ss + fh->issBase + sh.iss;\n+\t\t/* If we need to heap-allocate STABSTRING, this owns\n+\t\t   it.  */\n+\t\tgdb::unique_xmalloc_ptr<char> stabstring_storage;\n \t\tint len = strlen (stabstring);\n \n \t\twhile (stabstring[len - 1] == '\\\\')\n@@ -2787,14 +2790,19 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t\t    stabstring2 = debug_info->ss + fh->issBase + sh2.iss;\n \t\t    len2 = strlen (stabstring2);\n \n-\t\t    /* Concatinate stabstring2 with stabstring1.  */\n-\t\t    if (stabstring\n-\t\t     && stabstring != debug_info->ss + fh->issBase + sh.iss)\n-\t\t      stabstring\n-\t\t\t= (char *) xrealloc (stabstring, len + len2 + 1);\n+\t\t    /* Concatenate stabstring2 with stabstring1.  */\n+\t\t    if (stabstring_storage != nullptr)\n+\t\t      {\n+\t\t\tstabstring_storage.reset\n+\t\t\t  ((char *) xrealloc (stabstring_storage.release (),\n+\t\t\t\t\t      len + len2 + 1));\n+\t\t\tstabstring = stabstring_storage.get ();\n+\t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tstabstring = (char *) xmalloc (len + len2 + 1);\n+\t\t\tstabstring_storage.reset\n+\t\t\t  ((char *) xmalloc (len + len2 + 1));\n+\t\t\tstabstring = stabstring_storage.get ();\n \t\t\tstrcpy (stabstring, stabstring1);\n \t\t      }\n \t\t    strcpy (stabstring + len, stabstring2);\n@@ -3330,9 +3338,6 @@ parse_partial_symbols (minimal_symbol_reader &reader,\n \t\t\t       hex_string (type_code)); /* CUR_SYMBOL_TYPE */\n \t\t    continue;\n \t\t  }\n-\t\tif (stabstring\n-\t\t    && stabstring != debug_info->ss + fh->issBase + sh.iss)\n-\t\t  xfree (stabstring);\n \t      }\n \t      /* end - Handle continuation */\n \t    }"
    }
  ]
}