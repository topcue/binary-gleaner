{
  "sha": "af97b4161f07a716783183f1b17fa5cac9f99a49",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWY5N2I0MTYxZjA3YTcxNjc4MzE4M2YxYjE3ZmE1Y2FjOWY5OWE0OQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-23T22:42:14Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-05-04T19:43:50Z"
    },
    "message": "Don't derive partial_symbol from general_symbol_info\n\nThis patch partly reverts commit 8a6d42345 (\"Change representation of\npsymbol to flush out accessors\"); specifically, it changes\npartial_symbol to no longer derive from general_symbol_info.\n\nThe basic problem here is that the bcache compares objects bitwise,\nand this change made it less likely that the relevant fields in the\npsymbol would be fully initialized.  This could be seen by running a\ntest under valgrind on the Fedora-i686 buildbot.\n\nI considered a simpler patch, namely just zeroing the psymbol's\n\"value\" field in add_psymbol_to_bcache.  However, it wasn't clear to\nme that this memset could not then be optimized away by the compiler.\n\nRegression tested by the buildbot.  I think this should go in 8.3 as\nwell.\n\ngdb/ChangeLog\n2019-05-04  Tom Tromey  <tom@tromey.com>\n\n\t* psymtab.c (psymbol_name_matches, match_partial_symbol)\n\t(lookup_partial_symbol, print_partial_symbols)\n\t(recursively_search_psymtabs, sort_pst_symbols, psymbol_hash)\n\t(psymbol_compare): Update.\n\t(add_psymbol_to_bcache): Clear the entire psymbol.\n\t(maintenance_check_psymtabs): Update.\n\t* psympriv.h (struct partial_symbol): Don't derive from\n\tgeneral_symbol_info.\n\t<obj_section, unrelocated_address, address,\n\tset_unrelocated_address>: Update.\n\t<ginfo>: New member.\n\t* dwarf-index-write.c (write_psymbols, debug_names::insert)\n\t(debug_names::write_psymbols): Update.",
    "tree": {
      "sha": "4afe3bc56a89346123d7ad0ab369b6da3dfe0a2e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4afe3bc56a89346123d7ad0ab369b6da3dfe0a2e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/af97b4161f07a716783183f1b17fa5cac9f99a49",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af97b4161f07a716783183f1b17fa5cac9f99a49",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/af97b4161f07a716783183f1b17fa5cac9f99a49",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/af97b4161f07a716783183f1b17fa5cac9f99a49/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9d6d4be89d12747a92629ed1bde1d423e2831de1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d6d4be89d12747a92629ed1bde1d423e2831de1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9d6d4be89d12747a92629ed1bde1d423e2831de1"
    }
  ],
  "stats": {
    "total": 118,
    "additions": 72,
    "deletions": 46
  },
  "files": [
    {
      "sha": "383b3533390ebb5ed0dd33dad0e44c1b2f2b9989",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=af97b4161f07a716783183f1b17fa5cac9f99a49",
      "patch": "@@ -1,3 +1,19 @@\n+2019-05-04  Tom Tromey  <tom@tromey.com>\n+\n+\t* psymtab.c (psymbol_name_matches, match_partial_symbol)\n+\t(lookup_partial_symbol, print_partial_symbols)\n+\t(recursively_search_psymtabs, sort_pst_symbols, psymbol_hash)\n+\t(psymbol_compare): Update.\n+\t(add_psymbol_to_bcache): Clear the entire psymbol.\n+\t(maintenance_check_psymtabs): Update.\n+\t* psympriv.h (struct partial_symbol): Don't derive from\n+\tgeneral_symbol_info.\n+\t<obj_section, unrelocated_address, address,\n+\tset_unrelocated_address>: Update.\n+\t<ginfo>: New member.\n+\t* dwarf-index-write.c (write_psymbols, debug_names::insert)\n+\t(debug_names::write_psymbols): Update.\n+\n 2019-05-04  Tom de Vries  <tdevries@suse.de>\n \n \t* contrib/cc-with-tweaks.sh: Support -n arg."
    },
    {
      "sha": "8734f99212dac7120fce2b0c1fc4bb1a2a5caef8",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=af97b4161f07a716783183f1b17fa5cac9f99a49",
      "patch": "@@ -540,15 +540,15 @@ write_psymbols (struct mapped_symtab *symtab,\n     {\n       struct partial_symbol *psym = *psymp;\n \n-      if (psym->language == language_ada)\n+      if (psym->ginfo.language == language_ada)\n \terror (_(\"Ada is not currently supported by the index\"));\n \n       /* Only add a given psymbol once.  */\n       if (psyms_seen.insert (psym).second)\n \t{\n \t  gdb_index_symbol_kind kind = symbol_kind (psym);\n \n-\t  add_index_entry (symtab, symbol_search_name (psym),\n+\t  add_index_entry (symtab, symbol_search_name (&psym->ginfo),\n \t\t\t   is_static, kind, cu_index);\n \t}\n     }\n@@ -684,7 +684,7 @@ class debug_names\n     const int dwarf_tag = psymbol_tag (psym);\n     if (dwarf_tag == 0)\n       return;\n-    const char *const name = symbol_search_name (psym);\n+    const char *const name = symbol_search_name (&psym->ginfo);\n     const auto insertpair\n       = m_name_to_value_set.emplace (c_str_view (name),\n \t\t\t\t     std::set<symbol_value> ());\n@@ -1181,7 +1181,7 @@ class debug_names\n       {\n \tstruct partial_symbol *psym = *psymp;\n \n-\tif (psym->language == language_ada)\n+\tif (psym->ginfo.language == language_ada)\n \t  error (_(\"Ada is not currently supported by the index\"));\n \n \t/* Only add a given psymbol once.  */"
    },
    {
      "sha": "61d73a316b8e107b19edd29461fc4d69eb8bb2e1",
      "filename": "gdb/psympriv.h",
      "status": "modified",
      "additions": 12,
      "deletions": 6,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/psympriv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/psympriv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psympriv.h?ref=af97b4161f07a716783183f1b17fa5cac9f99a49",
      "patch": "@@ -33,37 +33,43 @@\n /* This structure is space critical.  See space comments at the top of\n    symtab.h.  */\n \n-struct partial_symbol : public general_symbol_info\n+struct partial_symbol\n {\n   /* Return the section for this partial symbol, or nullptr if no\n      section has been set.  */\n   struct obj_section *obj_section (struct objfile *objfile) const\n   {\n-    if (section >= 0)\n-      return &objfile->sections[section];\n+    if (ginfo.section >= 0)\n+      return &objfile->sections[ginfo.section];\n     return nullptr;\n   }\n \n   /* Return the unrelocated address of this partial symbol.  */\n   CORE_ADDR unrelocated_address () const\n   {\n-    return value.address;\n+    return ginfo.value.address;\n   }\n \n   /* Return the address of this partial symbol, relocated according to\n      the offsets provided in OBJFILE.  */\n   CORE_ADDR address (const struct objfile *objfile) const\n   {\n-    return value.address + ANOFFSET (objfile->section_offsets, section);\n+    return (ginfo.value.address\n+\t    + ANOFFSET (objfile->section_offsets, ginfo.section));\n   }\n \n   /* Set the address of this partial symbol.  The address must be\n      unrelocated.  */\n   void set_unrelocated_address (CORE_ADDR addr)\n   {\n-    value.address = addr;\n+    ginfo.value.address = addr;\n   }\n \n+  /* Note that partial_symbol does not derive from general_symbol_info\n+     due to the bcache.  See add_psymbol_to_bcache.  */\n+\n+  struct general_symbol_info ginfo;\n+\n   /* Name space code.  */\n \n   ENUM_BITFIELD(domain_enum_tag) domain : SYMBOL_DOMAIN_BITS;"
    },
    {
      "sha": "78a46997ca8397f6444e591aa9ca15b728a57239",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 40,
      "deletions": 36,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/af97b4161f07a716783183f1b17fa5cac9f99a49/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=af97b4161f07a716783183f1b17fa5cac9f99a49",
      "patch": "@@ -528,10 +528,10 @@ static bool\n psymbol_name_matches (partial_symbol *psym,\n \t\t      const lookup_name_info &lookup_name)\n {\n-  const language_defn *lang = language_def (psym->language);\n+  const language_defn *lang = language_def (psym->ginfo.language);\n   symbol_name_matcher_ftype *name_match\n     = get_symbol_name_matcher (lang, lookup_name);\n-  return name_match (symbol_search_name (psym), lookup_name, NULL);\n+  return name_match (symbol_search_name (&psym->ginfo), lookup_name, NULL);\n }\n \n /* Look in PST for a symbol in DOMAIN whose name matches NAME.  Search\n@@ -581,11 +581,12 @@ match_partial_symbol (struct objfile *objfile,\n \t  center = bottom + (top - bottom) / 2;\n \t  gdb_assert (center < top);\n \n-\t  enum language lang = (*center)->language;\n+\t  enum language lang = (*center)->ginfo.language;\n \t  const char *lang_ln\n \t    = lookup_name.language_lookup_name (lang).c_str ();\n \n-\t  if (ordered_compare (symbol_search_name (*center), lang_ln) >= 0)\n+\t  if (ordered_compare (symbol_search_name (&(*center)->ginfo),\n+\t\t\t       lang_ln) >= 0)\n \t    top = center;\n \t  else\n \t    bottom = center + 1;\n@@ -595,7 +596,7 @@ match_partial_symbol (struct objfile *objfile,\n       while (top <= real_top\n \t     && psymbol_name_matches (*top, lookup_name))\n \t{\n-\t  if (symbol_matches_domain ((*top)->language,\n+\t  if (symbol_matches_domain ((*top)->ginfo.language,\n \t\t\t\t     (*top)->domain, domain))\n \t    return *top;\n \t  top++;\n@@ -609,7 +610,7 @@ match_partial_symbol (struct objfile *objfile,\n     {\n       for (psym = start; psym < start + length; psym++)\n \t{\n-\t  if (symbol_matches_domain ((*psym)->language,\n+\t  if (symbol_matches_domain ((*psym)->ginfo.language,\n \t\t\t\t     (*psym)->domain, domain)\n \t      && psymbol_name_matches (*psym, lookup_name))\n \t    return *psym;\n@@ -692,7 +693,7 @@ lookup_partial_symbol (struct objfile *objfile,\n \t  if (!(center < top))\n \t    internal_error (__FILE__, __LINE__,\n \t\t\t    _(\"failed internal consistency check\"));\n-\t  if (strcmp_iw_ordered (symbol_search_name (*center),\n+\t  if (strcmp_iw_ordered (symbol_search_name (&(*center)->ginfo),\n \t\t\t\t search_name.get ()) >= 0)\n \t    {\n \t      top = center;\n@@ -708,15 +709,17 @@ lookup_partial_symbol (struct objfile *objfile,\n \n       /* For `case_sensitivity == case_sensitive_off' strcmp_iw_ordered will\n \t search more exactly than what matches SYMBOL_MATCHES_SEARCH_NAME.  */\n-      while (top >= start && symbol_matches_search_name (*top, lookup_name))\n+      while (top >= start && symbol_matches_search_name (&(*top)->ginfo,\n+\t\t\t\t\t\t\t lookup_name))\n \ttop--;\n \n       /* Fixup to have a symbol which matches SYMBOL_MATCHES_SEARCH_NAME.  */\n       top++;\n \n-      while (top <= real_top && symbol_matches_search_name (*top, lookup_name))\n+      while (top <= real_top && symbol_matches_search_name (&(*top)->ginfo,\n+\t\t\t\t\t\t\t    lookup_name))\n \t{\n-\t  if (symbol_matches_domain ((*top)->language,\n+\t  if (symbol_matches_domain ((*top)->ginfo.language,\n \t\t\t\t     (*top)->domain, domain))\n \t    return *top;\n \t  top++;\n@@ -730,9 +733,9 @@ lookup_partial_symbol (struct objfile *objfile,\n     {\n       for (psym = start; psym < start + length; psym++)\n \t{\n-\t  if (symbol_matches_domain ((*psym)->language,\n+\t  if (symbol_matches_domain ((*psym)->ginfo.language,\n \t\t\t\t     (*psym)->domain, domain)\n-\t      && symbol_matches_search_name (*psym, lookup_name))\n+\t      && symbol_matches_search_name (&(*psym)->ginfo, lookup_name))\n \t    return *psym;\n \t}\n     }\n@@ -832,10 +835,11 @@ print_partial_symbols (struct gdbarch *gdbarch, struct objfile *objfile,\n   while (count-- > 0)\n     {\n       QUIT;\n-      fprintf_filtered (outfile, \"    `%s'\", (*p)->name);\n-      if (symbol_demangled_name (*p) != NULL)\n+      fprintf_filtered (outfile, \"    `%s'\", (*p)->ginfo.name);\n+      if (symbol_demangled_name (&(*p)->ginfo) != NULL)\n \t{\n-\t  fprintf_filtered (outfile, \"  `%s'\", symbol_demangled_name (*p));\n+\t  fprintf_filtered (outfile, \"  `%s'\",\n+\t\t\t    symbol_demangled_name (&(*p)->ginfo));\n \t}\n       fputs_filtered (\", \", outfile);\n       switch ((*p)->domain)\n@@ -1305,7 +1309,8 @@ recursively_search_psymtabs\n \t       || (domain == TYPES_DOMAIN\n \t\t   && (*psym)->aclass == LOC_TYPEDEF))\n \t      && psymbol_name_matches (*psym, lookup_name)\n-\t      && (sym_matcher == NULL || sym_matcher (symbol_search_name (*psym))))\n+\t      && (sym_matcher == NULL\n+\t\t  || sym_matcher (symbol_search_name (&(*psym)->ginfo))))\n \t    {\n \t      /* Found a match, so notify our caller.  */\n \t      result = PST_SEARCHED_AND_FOUND;\n@@ -1500,8 +1505,8 @@ sort_pst_symbols (struct objfile *objfile, struct partial_symtab *pst)\n \n   std::sort (begin, end, [] (partial_symbol *s1, partial_symbol *s2)\n     {\n-      return strcmp_iw_ordered (symbol_search_name (s1),\n-\t\t\t\tsymbol_search_name (s2)) < 0;\n+      return strcmp_iw_ordered (symbol_search_name (&s1->ginfo),\n+\t\t\t\tsymbol_search_name (&s2->ginfo)) < 0;\n     });\n }\n \n@@ -1548,18 +1553,18 @@ psymbol_hash (const void *addr, int length)\n {\n   unsigned long h = 0;\n   struct partial_symbol *psymbol = (struct partial_symbol *) addr;\n-  unsigned int lang = psymbol->language;\n+  unsigned int lang = psymbol->ginfo.language;\n   unsigned int domain = psymbol->domain;\n   unsigned int theclass = psymbol->aclass;\n \n-  h = hash_continue (&psymbol->value, sizeof (psymbol->value), h);\n+  h = hash_continue (&psymbol->ginfo.value, sizeof (psymbol->ginfo.value), h);\n   h = hash_continue (&lang, sizeof (unsigned int), h);\n   h = hash_continue (&domain, sizeof (unsigned int), h);\n   h = hash_continue (&theclass, sizeof (unsigned int), h);\n   /* Note that psymbol names are interned via symbol_set_names, so\n      there's no need to hash the contents of the name here.  */\n-  h = hash_continue (&psymbol->name,\n-\t\t     sizeof (psymbol->name), h);\n+  h = hash_continue (&psymbol->ginfo.name,\n+\t\t     sizeof (psymbol->ginfo.name), h);\n \n   return h;\n }\n@@ -1574,15 +1579,15 @@ psymbol_compare (const void *addr1, const void *addr2, int length)\n   struct partial_symbol *sym1 = (struct partial_symbol *) addr1;\n   struct partial_symbol *sym2 = (struct partial_symbol *) addr2;\n \n-  return (memcmp (&sym1->value, &sym2->value,\n-                  sizeof (sym1->value)) == 0\n-\t  && sym1->language == sym2->language\n+  return (memcmp (&sym1->ginfo.value, &sym2->ginfo.value,\n+                  sizeof (sym1->ginfo.value)) == 0\n+\t  && sym1->ginfo.language == sym2->ginfo.language\n           && sym1->domain == sym2->domain\n           && sym1->aclass == sym2->aclass\n \t  /* Note that psymbol names are interned via\n \t     symbol_set_names, so there's no need to compare the\n \t     contents of the name here.  */\n-          && sym1->name == sym2->name);\n+          && sym1->ginfo.name == sym2->ginfo.name);\n }\n \n /* Helper function, initialises partial symbol structure and stashes\n@@ -1601,17 +1606,16 @@ add_psymbol_to_bcache (const char *name, int namelength, int copy_name,\n \t\t       int *added)\n {\n   struct partial_symbol psymbol;\n+  memset (&psymbol, 0, sizeof (psymbol));\n \n   psymbol.set_unrelocated_address (coreaddr);\n-  psymbol.section = section;\n+  psymbol.ginfo.section = section;\n   psymbol.domain = domain;\n   psymbol.aclass = theclass;\n-\n-  memset (&psymbol.language_specific, 0, sizeof (psymbol.language_specific));\n-  psymbol.ada_mangled = 0;\n-  symbol_set_language (&psymbol, language,\n+  symbol_set_language (&psymbol.ginfo, language,\n \t\t       objfile->partial_symtabs->obstack ());\n-  symbol_set_names (&psymbol, name, namelength, copy_name, objfile->per_bfd);\n+  symbol_set_names (&psymbol.ginfo, name, namelength, copy_name,\n+\t\t    objfile->per_bfd);\n \n   /* Stash the partial symbol away in the cache.  */\n   return ((struct partial_symbol *)\n@@ -2133,13 +2137,13 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n \tlength = ps->n_static_syms;\n \twhile (length--)\n \t  {\n-\t    sym = block_lookup_symbol (b, symbol_search_name (*psym),\n+\t    sym = block_lookup_symbol (b, symbol_search_name (&(*psym)->ginfo),\n \t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n \t\t\t\t       (*psym)->domain);\n \t    if (!sym)\n \t      {\n \t\tprintf_filtered (\"Static symbol `\");\n-\t\tputs_filtered ((*psym)->name);\n+\t\tputs_filtered ((*psym)->ginfo.name);\n \t\tprintf_filtered (\"' only found in \");\n \t\tputs_filtered (ps->filename);\n \t\tprintf_filtered (\" psymtab\\n\");\n@@ -2151,13 +2155,13 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n \tlength = ps->n_global_syms;\n \twhile (length--)\n \t  {\n-\t    sym = block_lookup_symbol (b, symbol_search_name (*psym),\n+\t    sym = block_lookup_symbol (b, symbol_search_name (&(*psym)->ginfo),\n \t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n \t\t\t\t       (*psym)->domain);\n \t    if (!sym)\n \t      {\n \t\tprintf_filtered (\"Global symbol `\");\n-\t\tputs_filtered ((*psym)->name);\n+\t\tputs_filtered ((*psym)->ginfo.name);\n \t\tprintf_filtered (\"' only found in \");\n \t\tputs_filtered (ps->filename);\n \t\tprintf_filtered (\" psymtab\\n\");"
    }
  ]
}