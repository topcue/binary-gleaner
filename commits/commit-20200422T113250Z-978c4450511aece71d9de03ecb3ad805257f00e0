{
  "sha": "978c4450511aece71d9de03ecb3ad805257f00e0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTc4YzQ0NTA1MTFhZWNlNzFkOWRlMDNlY2IzYWQ4MDUyNTdmMDBlMA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-22T05:19:39Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-04-22T11:32:50Z"
    },
    "message": "readelf: move file related static vars to filedata\n\nThe idea here is to get rid of a lot of file related static vars used\nto pass data around, in order to not have stale data about one object\nfile persisting to the next one.\n\n\t* readelf.c (archive_file_offset, archive_file_size, dynamic_addr),\n\t(dynamic_size, dynamic_nent, dynamic_strings, dynamic_strings_length),\n\t(num_dynamic_syms, nbuckets, nchains, buckets, chains),\n\t(ngnubuckets, gnubuckets, gnuchains, mipsxlat, ngnuchains),\n\t(gnusymidx, dynamic_symbols, dynamic_syminfo, dynamic_syminfo_offset),\n\t(dynamic_syminfo_nent, program_interpreter, dynamic_info),\n\t(dynamic_info_DT_GNU_HASH, dynamic_info_DT_MIPS_XHASH, version_info),\n\t(dynamic_section, symtab_shndx_list, group_count, section_groups),\n\t(section_headers_groups): Move to struct filedata.  Update use\n\tthroughout file.",
    "tree": {
      "sha": "185e81d93ff09d9e37258fd9fee1698e184e77d2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/185e81d93ff09d9e37258fd9fee1698e184e77d2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/978c4450511aece71d9de03ecb3ad805257f00e0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/978c4450511aece71d9de03ecb3ad805257f00e0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/978c4450511aece71d9de03ecb3ad805257f00e0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/978c4450511aece71d9de03ecb3ad805257f00e0/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6431e4096805b68f7cc4a17002c34ccd40f7dde2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6431e4096805b68f7cc4a17002c34ccd40f7dde2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6431e4096805b68f7cc4a17002c34ccd40f7dde2"
    }
  ],
  "stats": {
    "total": 945,
    "additions": 504,
    "deletions": 441
  },
  "files": [
    {
      "sha": "f303633e29b8d6af25af0a2672a9ceb75b9117d9",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/978c4450511aece71d9de03ecb3ad805257f00e0/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/978c4450511aece71d9de03ecb3ad805257f00e0/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=978c4450511aece71d9de03ecb3ad805257f00e0",
      "patch": "@@ -1,3 +1,16 @@\n+2020-04-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* readelf.c (archive_file_offset, archive_file_size, dynamic_addr),\n+\t(dynamic_size, dynamic_nent, dynamic_strings, dynamic_strings_length),\n+\t(num_dynamic_syms, nbuckets, nchains, buckets, chains),\n+\t(ngnubuckets, gnubuckets, gnuchains, mipsxlat, ngnuchains),\n+\t(gnusymidx, dynamic_symbols, dynamic_syminfo, dynamic_syminfo_offset),\n+\t(dynamic_syminfo_nent, program_interpreter, dynamic_info),\n+\t(dynamic_info_DT_GNU_HASH, dynamic_info_DT_MIPS_XHASH, version_info),\n+\t(dynamic_section, symtab_shndx_list, group_count, section_groups),\n+\t(section_headers_groups): Move to struct filedata.  Update use\n+\tthroughout file.\n+\n 2020-04-22  Alan Modra  <amodra@gmail.com>\n \n \t* readelf.c (struct dump_data): New, used.."
    },
    {
      "sha": "32538634453b9952e01f74c51553f429f3f3d92e",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 491,
      "deletions": 441,
      "changes": 932,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/978c4450511aece71d9de03ecb3ad805257f00e0/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/978c4450511aece71d9de03ecb3ad805257f00e0/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=978c4450511aece71d9de03ecb3ad805257f00e0",
      "patch": "@@ -208,55 +208,8 @@ static struct dump_data cmdline;\n \n static struct dump_list_entry * dump_sects_byname;\n \n-typedef struct filedata\n-{\n-  const char *         file_name;\n-  FILE *               handle;\n-  bfd_size_type        file_size;\n-  Elf_Internal_Ehdr    file_header;\n-  Elf_Internal_Shdr *  section_headers;\n-  Elf_Internal_Phdr *  program_headers;\n-  char *               string_table;\n-  unsigned long        string_table_length;\n-  /* A dynamic array of flags indicating for which sections a dump of\n-     some kind has been requested.  It is reset on a per-object file\n-     basis and then initialised from the cmdline_dump_sects array,\n-     the results of interpreting the -w switch, and the\n-     dump_sects_byname list.  */\n-  struct dump_data     dump;\n-} Filedata;\n-\n char * program_name = \"readelf\";\n \n-static unsigned long archive_file_offset;\n-static unsigned long archive_file_size;\n-static unsigned long dynamic_addr;\n-static bfd_size_type dynamic_size;\n-static size_t dynamic_nent;\n-static char * dynamic_strings;\n-static unsigned long dynamic_strings_length;\n-static unsigned long num_dynamic_syms;\n-static bfd_size_type nbuckets;\n-static bfd_size_type nchains;\n-static bfd_vma *buckets;\n-static bfd_vma *chains;\n-static bfd_vma ngnubuckets;\n-static bfd_vma *gnubuckets;\n-static bfd_vma *gnuchains;\n-static bfd_vma *mipsxlat;\n-static bfd_size_type ngnuchains;\n-static bfd_vma gnusymidx;\n-static Elf_Internal_Sym * dynamic_symbols;\n-static Elf_Internal_Syminfo * dynamic_syminfo;\n-static unsigned long dynamic_syminfo_offset;\n-static unsigned int dynamic_syminfo_nent;\n-static char program_interpreter[PATH_MAX];\n-static bfd_vma dynamic_info[DT_ENCODING];\n-static bfd_vma dynamic_info_DT_GNU_HASH;\n-static bfd_vma dynamic_info_DT_MIPS_XHASH;\n-static bfd_vma version_info[16];\n-static Elf_Internal_Dyn *  dynamic_section;\n-static elf_section_list * symtab_shndx_list;\n static bfd_boolean show_name = FALSE;\n static bfd_boolean do_dynamic = FALSE;\n static bfd_boolean do_syms = FALSE;\n@@ -296,9 +249,55 @@ struct group\n   unsigned int         group_index;\n };\n \n-static size_t           group_count;\n-static struct group *   section_groups;\n-static struct group **  section_headers_groups;\n+typedef struct filedata\n+{\n+  const char *         file_name;\n+  FILE *               handle;\n+  bfd_size_type        file_size;\n+  Elf_Internal_Ehdr    file_header;\n+  Elf_Internal_Shdr *  section_headers;\n+  Elf_Internal_Phdr *  program_headers;\n+  char *               string_table;\n+  unsigned long        string_table_length;\n+  unsigned long        archive_file_offset;\n+  unsigned long        archive_file_size;\n+  unsigned long        dynamic_addr;\n+  bfd_size_type        dynamic_size;\n+  size_t               dynamic_nent;\n+  Elf_Internal_Dyn *   dynamic_section;\n+  char *               dynamic_strings;\n+  unsigned long        dynamic_strings_length;\n+  unsigned long        num_dynamic_syms;\n+  Elf_Internal_Sym *   dynamic_symbols;\n+  bfd_vma              version_info[16];\n+  unsigned int         dynamic_syminfo_nent;\n+  Elf_Internal_Syminfo * dynamic_syminfo;\n+  unsigned long        dynamic_syminfo_offset;\n+  bfd_size_type        nbuckets;\n+  bfd_size_type        nchains;\n+  bfd_vma *            buckets;\n+  bfd_vma *            chains;\n+  bfd_size_type        ngnubuckets;\n+  bfd_size_type        ngnuchains;\n+  bfd_vma *            gnubuckets;\n+  bfd_vma *            gnuchains;\n+  bfd_vma *            mipsxlat;\n+  bfd_vma              gnusymidx;\n+  char                 program_interpreter[PATH_MAX];\n+  bfd_vma              dynamic_info[DT_ENCODING];\n+  bfd_vma              dynamic_info_DT_GNU_HASH;\n+  bfd_vma              dynamic_info_DT_MIPS_XHASH;\n+  elf_section_list *   symtab_shndx_list;\n+  size_t               group_count;\n+  struct group *       section_groups;\n+  struct group **      section_headers_groups;\n+  /* A dynamic array of flags indicating for which sections a dump of\n+     some kind has been requested.  It is reset on a per-object file\n+     basis and then initialised from the cmdline_dump_sects array,\n+     the results of interpreting the -w switch, and the\n+     dump_sects_byname list.  */\n+  struct dump_data     dump;\n+} Filedata;\n \n /* How to print a vma value.  */\n typedef enum print_mode\n@@ -341,11 +340,13 @@ static const char * get_symbol_version_string\n \n #define VALID_SYMBOL_NAME(strtab, strtab_size, offset) \\\n    (strtab != NULL && offset < strtab_size)\n-#define VALID_DYNAMIC_NAME(offset) \\\n-  VALID_SYMBOL_NAME (dynamic_strings, dynamic_strings_length, offset)\n+#define VALID_DYNAMIC_NAME(filedata, offset) \\\n+  VALID_SYMBOL_NAME (filedata->dynamic_strings, \\\n+\t\t     filedata->dynamic_strings_length, offset)\n /* GET_DYNAMIC_NAME asssumes that VALID_DYNAMIC_NAME has\n    already been called and verified that the string exists.  */\n-#define GET_DYNAMIC_NAME(offset)\t(dynamic_strings + offset)\n+#define GET_DYNAMIC_NAME(filedata, offset) \\\n+  (filedata->dynamic_strings + offset)\n \n #define REMOVE_ARCH_BITS(ADDR)\t\t\t\\\n   do\t\t\t\t\t\t\\\n@@ -356,8 +357,8 @@ static const char * get_symbol_version_string\n   while (0)\n \n /* Get the correct GNU hash section name.  */\n-#define GNU_HASH_SECTION_NAME\t\t\t\\\n-  dynamic_info_DT_MIPS_XHASH ? \".MIPS.xhash\" : \".gnu.hash\"\n+#define GNU_HASH_SECTION_NAME(filedata)\t\t\\\n+  filedata->dynamic_info_DT_MIPS_XHASH ? \".MIPS.xhash\" : \".gnu.hash\"\n \f\n /* Print a BFD_VMA to an internal buffer, for use in error messages.\n    BFD_FMA_FMT can't be used in translated strings.  */\n@@ -431,21 +432,22 @@ get_data (void *         var,\n \n   /* Be kind to memory checkers (eg valgrind, address sanitizer) by not\n      attempting to allocate memory when the read is bound to fail.  */\n-  if (archive_file_offset > filedata->file_size\n-      || offset > filedata->file_size - archive_file_offset\n-      || amt > filedata->file_size - archive_file_offset - offset)\n+  if (filedata->archive_file_offset > filedata->file_size\n+      || offset > filedata->file_size - filedata->archive_file_offset\n+      || amt > filedata->file_size - filedata->archive_file_offset - offset)\n     {\n       if (reason)\n \terror (_(\"Reading %s bytes extends past end of file for %s\\n\"),\n \t       bfd_vmatoa (\"u\", amt), reason);\n       return NULL;\n     }\n \n-  if (fseek (filedata->handle, archive_file_offset + offset, SEEK_SET))\n+  if (fseek (filedata->handle, filedata->archive_file_offset + offset,\n+\t     SEEK_SET))\n     {\n       if (reason)\n \terror (_(\"Unable to seek to 0x%lx for %s\\n\"),\n-\t       archive_file_offset + offset, reason);\n+\t       filedata->archive_file_offset + offset, reason);\n       return NULL;\n     }\n \n@@ -5131,8 +5133,8 @@ process_program_headers (Filedata * filedata)\n   unsigned int i;\n   Elf_Internal_Phdr * previous_load = NULL;\n \n-  dynamic_addr = 0;\n-  dynamic_size = 0;\n+  filedata->dynamic_addr = 0;\n+  filedata->dynamic_size = 0;\n \n   if (filedata->file_header.e_phnum == 0)\n     {\n@@ -5309,13 +5311,13 @@ process_program_headers (Filedata * filedata)\n \t  break;\n \n \tcase PT_DYNAMIC:\n-\t  if (dynamic_addr)\n+\t  if (filedata->dynamic_addr)\n \t    error (_(\"more than one dynamic segment\\n\"));\n \n \t  /* By default, assume that the .dynamic section is the first\n \t     section in the DYNAMIC segment.  */\n-\t  dynamic_addr = segment->p_offset;\n-\t  dynamic_size = segment->p_filesz;\n+\t  filedata->dynamic_addr = segment->p_offset;\n+\t  filedata->dynamic_size = segment->p_filesz;\n \n \t  /* Try to locate the .dynamic section. If there is\n \t     a section header table, we can easily locate it.  */\n@@ -5335,18 +5337,18 @@ process_program_headers (Filedata * filedata)\n \n \t      if (sec->sh_type == SHT_NOBITS)\n \t\t{\n-\t\t  dynamic_size = 0;\n+\t\t  filedata->dynamic_size = 0;\n \t\t  break;\n \t\t}\n \n-\t      dynamic_addr = sec->sh_offset;\n-\t      dynamic_size = sec->sh_size;\n+\t      filedata->dynamic_addr = sec->sh_offset;\n+\t      filedata->dynamic_size = sec->sh_size;\n \n-\t      if (dynamic_addr < segment->p_offset\n-\t\t  || dynamic_addr > segment->p_offset + segment->p_filesz)\n+\t      if (filedata->dynamic_addr < segment->p_offset\n+\t\t  || filedata->dynamic_addr > segment->p_offset + segment->p_filesz)\n \t\twarn (_(\"the .dynamic section is not contained\"\n \t\t\t\" within the dynamic segment\\n\"));\n-\t      else if (dynamic_addr > segment->p_offset)\n+\t      else if (filedata->dynamic_addr > segment->p_offset)\n \t\twarn (_(\"the .dynamic section is not the first section\"\n \t\t\t\" in the dynamic segment.\\n\"));\n \t    }\n@@ -5355,16 +5357,18 @@ process_program_headers (Filedata * filedata)\n \t     segment.  Check this after matching against the section headers\n \t     so we don't warn on debuginfo file (which have NOBITS .dynamic\n \t     sections).  */\n-\t  if (dynamic_addr > filedata->file_size\n-\t      || dynamic_size > filedata->file_size - dynamic_addr)\n+\t  if (filedata->dynamic_addr > filedata->file_size\n+\t      || (filedata->dynamic_size\n+\t\t  > filedata->file_size - filedata->dynamic_addr))\n \t    {\n \t      error (_(\"the dynamic segment offset + size exceeds the size of the file\\n\"));\n-\t      dynamic_addr = dynamic_size = 0;\n+\t      filedata->dynamic_addr = filedata->dynamic_size = 0;\n \t    }\n \t  break;\n \n \tcase PT_INTERP:\n-\t  if (fseek (filedata->handle, archive_file_offset + (long) segment->p_offset,\n+\t  if (fseek (filedata->handle,\n+\t\t     filedata->archive_file_offset + (long) segment->p_offset,\n \t\t     SEEK_SET))\n \t    error (_(\"Unable to find program interpreter name\\n\"));\n \t  else\n@@ -5375,13 +5379,14 @@ process_program_headers (Filedata * filedata)\n \t      if (ret >= (int) sizeof (fmt) || ret < 0)\n \t\terror (_(\"Internal error: failed to create format string to display program interpreter\\n\"));\n \n-\t      program_interpreter[0] = 0;\n-\t      if (fscanf (filedata->handle, fmt, program_interpreter) <= 0)\n+\t      filedata->program_interpreter[0] = 0;\n+\t      if (fscanf (filedata->handle, fmt,\n+\t\t\t  filedata->program_interpreter) <= 0)\n \t\terror (_(\"Unable to read program interpreter name\\n\"));\n \n \t      if (do_segments)\n \t\tprintf (_(\"      [Requesting program interpreter: %s]\\n\"),\n-\t\t    program_interpreter);\n+\t\t    filedata->program_interpreter);\n \t    }\n \t  break;\n \t}\n@@ -5637,7 +5642,7 @@ get_32bit_elf_symbols (Filedata *           filedata,\n     goto exit_point;\n \n   shndx = NULL;\n-  for (entry = symtab_shndx_list; entry != NULL; entry = entry->next)\n+  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)\n     {\n       if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))\n \tcontinue;\n@@ -5754,7 +5759,7 @@ get_64bit_elf_symbols (Filedata *           filedata,\n     goto exit_point;\n \n   shndx = NULL;\n-  for (entry = symtab_shndx_list; entry != NULL; entry = entry->next)\n+  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)\n     {\n       if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))\n \tcontinue;\n@@ -6137,19 +6142,19 @@ process_section_headers (Filedata * filedata)\n \n   free (filedata->section_headers);\n   filedata->section_headers = NULL;\n-  free (dynamic_symbols);\n-  dynamic_symbols = NULL;\n-  num_dynamic_syms = 0;\n-  free (dynamic_strings);\n-  dynamic_strings = NULL;\n-  dynamic_strings_length = 0;\n-  free (dynamic_syminfo);\n-  dynamic_syminfo = NULL;\n-  while (symtab_shndx_list != NULL)\n+  free (filedata->dynamic_symbols);\n+  filedata->dynamic_symbols = NULL;\n+  filedata->num_dynamic_syms = 0;\n+  free (filedata->dynamic_strings);\n+  filedata->dynamic_strings = NULL;\n+  filedata->dynamic_strings_length = 0;\n+  free (filedata->dynamic_syminfo);\n+  filedata->dynamic_syminfo = NULL;\n+  while (filedata->symtab_shndx_list != NULL)\n     {\n-      elf_section_list *next = symtab_shndx_list->next;\n-      free (symtab_shndx_list);\n-      symtab_shndx_list = next;\n+      elf_section_list *next = filedata->symtab_shndx_list->next;\n+      free (filedata->symtab_shndx_list);\n+      filedata->symtab_shndx_list = next;\n     }\n \n   if (filedata->file_header.e_shnum == 0)\n@@ -6283,36 +6288,38 @@ process_section_headers (Filedata * filedata)\n \n       if (section->sh_type == SHT_DYNSYM)\n \t{\n-\t  if (dynamic_symbols != NULL)\n+\t  if (filedata->dynamic_symbols != NULL)\n \t    {\n \t      error (_(\"File contains multiple dynamic symbol tables\\n\"));\n \t      continue;\n \t    }\n \n \t  CHECK_ENTSIZE (section, i, Sym);\n-\t  dynamic_symbols = GET_ELF_SYMBOLS (filedata, section, & num_dynamic_syms);\n+\t  filedata->dynamic_symbols\n+\t    = GET_ELF_SYMBOLS (filedata, section, &filedata->num_dynamic_syms);\n \t}\n       else if (section->sh_type == SHT_STRTAB\n \t       && streq (name, \".dynstr\"))\n \t{\n-\t  if (dynamic_strings != NULL)\n+\t  if (filedata->dynamic_strings != NULL)\n \t    {\n \t      error (_(\"File contains multiple dynamic string tables\\n\"));\n \t      continue;\n \t    }\n \n-\t  dynamic_strings = (char *) get_data (NULL, filedata, section->sh_offset,\n-                                               1, section->sh_size,\n-                                               _(\"dynamic strings\"));\n-\t  dynamic_strings_length = dynamic_strings == NULL ? 0 : section->sh_size;\n+\t  filedata->dynamic_strings\n+\t    = (char *) get_data (NULL, filedata, section->sh_offset,\n+\t\t\t\t 1, section->sh_size, _(\"dynamic strings\"));\n+\t  filedata->dynamic_strings_length\n+\t    = filedata->dynamic_strings == NULL ? 0 : section->sh_size;\n \t}\n       else if (section->sh_type == SHT_SYMTAB_SHNDX)\n \t{\n \t  elf_section_list * entry = xmalloc (sizeof * entry);\n \n \t  entry->hdr = section;\n-\t  entry->next = symtab_shndx_list;\n-\t  symtab_shndx_list = entry;\n+\t  entry->next = filedata->symtab_shndx_list;\n+\t  filedata->symtab_shndx_list = entry;\n \t}\n       else if (section->sh_type == SHT_SYMTAB)\n \tCHECK_ENTSIZE (section, i, Sym);\n@@ -6878,38 +6885,40 @@ process_section_groups (Filedata * filedata)\n       return FALSE;\n     }\n \n-  section_headers_groups = (struct group **) calloc (filedata->file_header.e_shnum,\n-                                                     sizeof (struct group *));\n+  filedata->section_headers_groups\n+    = (struct group **) calloc (filedata->file_header.e_shnum,\n+\t\t\t\tsizeof (struct group *));\n \n-  if (section_headers_groups == NULL)\n+  if (filedata->section_headers_groups == NULL)\n     {\n       error (_(\"Out of memory reading %u section group headers\\n\"),\n \t     filedata->file_header.e_shnum);\n       return FALSE;\n     }\n \n   /* Scan the sections for the group section.  */\n-  group_count = 0;\n+  filedata->group_count = 0;\n   for (i = 0, section = filedata->section_headers;\n        i < filedata->file_header.e_shnum;\n        i++, section++)\n     if (section->sh_type == SHT_GROUP)\n-      group_count++;\n+      filedata->group_count++;\n \n-  if (group_count == 0)\n+  if (filedata->group_count == 0)\n     {\n       if (do_section_groups)\n \tprintf (_(\"\\nThere are no section groups in this file.\\n\"));\n \n       return TRUE;\n     }\n \n-  section_groups = (struct group *) calloc (group_count, sizeof (struct group));\n+  filedata->section_groups = (struct group *) calloc (filedata->group_count,\n+\t\t\t\t\t\t      sizeof (struct group));\n \n-  if (section_groups == NULL)\n+  if (filedata->section_groups == NULL)\n     {\n       error (_(\"Out of memory reading %lu groups\\n\"),\n-\t     (unsigned long) group_count);\n+\t     (unsigned long) filedata->group_count);\n       return FALSE;\n     }\n \n@@ -6919,7 +6928,7 @@ process_section_groups (Filedata * filedata)\n   num_syms = 0;\n   strtab = NULL;\n   strtab_size = 0;\n-  for (i = 0, section = filedata->section_headers, group = section_groups;\n+  for (i = 0, section = filedata->section_headers, group = filedata->section_groups;\n        i < filedata->file_header.e_shnum;\n        i++, section++)\n     {\n@@ -7059,7 +7068,7 @@ process_section_groups (Filedata * filedata)\n \t\t  continue;\n \t\t}\n \n-\t      if (section_headers_groups [entry] != NULL)\n+\t      if (filedata->section_headers_groups [entry] != NULL)\n \t\t{\n \t\t  if (entry)\n \t\t    {\n@@ -7069,7 +7078,7 @@ process_section_groups (Filedata * filedata)\n \t\t\t{\n \t\t\t  error (_(\"section [%5u] in group section [%5u] already in group section [%5u]\\n\"),\n \t\t\t\t entry, i,\n-\t\t\t\t section_headers_groups [entry]->group_index);\n+\t\t\t\t filedata->section_headers_groups [entry]->group_index);\n \t\t\t  if (num_errs == 10)\n \t\t\t    warn (_(\"Further error messages about already contained group sections suppressed\\n\"));\n \t\t\t}\n@@ -7084,13 +7093,13 @@ process_section_groups (Filedata * filedata)\n \t\t      if (!warned)\n \t\t\t{\n \t\t\t  error (_(\"section 0 in group section [%5u]\\n\"),\n-\t\t\t\t section_headers_groups [entry]->group_index);\n+\t\t\t\t filedata->section_headers_groups [entry]->group_index);\n \t\t\t  warned = TRUE;\n \t\t\t}\n \t\t    }\n \t\t}\n \n-\t      section_headers_groups [entry] = group;\n+\t      filedata->section_headers_groups [entry] = group;\n \n \t      if (do_section_groups)\n \t\t{\n@@ -7150,7 +7159,8 @@ dump_ia64_vms_dynamic_fixups (Filedata *                  filedata,\n   long i;\n   const char * lib_name;\n \n-  imfs = get_data (NULL, filedata, dynamic_addr + fixup->fixup_rela_off,\n+  imfs = get_data (NULL, filedata,\n+\t\t   filedata->dynamic_addr + fixup->fixup_rela_off,\n \t\t   sizeof (*imfs), fixup->fixup_rela_cnt,\n \t\t   _(\"dynamic section image fixups\"));\n   if (!imfs)\n@@ -7199,7 +7209,8 @@ dump_ia64_vms_dynamic_relocs (Filedata * filedata, struct ia64_vms_dynimgrela *i\n   Elf64_External_VMS_IMAGE_RELA *imrs;\n   long i;\n \n-  imrs = get_data (NULL, filedata, dynamic_addr + imgrela->img_rela_off,\n+  imrs = get_data (NULL, filedata,\n+\t\t   filedata->dynamic_addr + imgrela->img_rela_off,\n \t\t   sizeof (*imrs), imgrela->img_rela_cnt,\n \t\t   _(\"dynamic section image relocations\"));\n   if (!imrs)\n@@ -7250,8 +7261,8 @@ process_ia64_vms_dynamic_relocs (Filedata * filedata)\n   memset (&imgrela, 0, sizeof (imgrela));\n \n   /* Note: the order of the entries is specified by the OpenVMS specs.  */\n-  for (entry = dynamic_section;\n-       entry < dynamic_section + dynamic_nent;\n+  for (entry = filedata->dynamic_section;\n+       entry < filedata->dynamic_section + filedata->dynamic_nent;\n        entry++)\n     {\n       switch (entry->d_tag)\n@@ -7262,7 +7273,8 @@ process_ia64_vms_dynamic_relocs (Filedata * filedata)\n         case DT_STRSZ:\n           strtab_sz = entry->d_un.d_val;\n           if (strtab == NULL)\n-            strtab = get_data (NULL, filedata, dynamic_addr + strtab_off,\n+\t    strtab = get_data (NULL, filedata,\n+\t\t\t       filedata->dynamic_addr + strtab_off,\n                                1, strtab_sz, _(\"dynamic string section\"));\n \t  if (strtab == NULL)\n \t    strtab_sz = 0;\n@@ -7343,16 +7355,16 @@ process_relocs (Filedata * filedata)\n \t{\n \t  is_rela = dynamic_relocations [i].rela;\n \t  name = dynamic_relocations [i].name;\n-\t  rel_size = dynamic_info [dynamic_relocations [i].size];\n-\t  rel_offset = dynamic_info [dynamic_relocations [i].reloc];\n+\t  rel_size = filedata->dynamic_info[dynamic_relocations [i].size];\n+\t  rel_offset = filedata->dynamic_info[dynamic_relocations [i].reloc];\n \n \t  if (rel_size)\n \t    has_dynamic_reloc = TRUE;\n \n \t  if (is_rela == UNKNOWN)\n \t    {\n \t      if (dynamic_relocations [i].reloc == DT_JMPREL)\n-\t\tswitch (dynamic_info[DT_PLTREL])\n+\t\tswitch (filedata->dynamic_info[DT_PLTREL])\n \t\t  {\n \t\t  case DT_REL:\n \t\t    is_rela = FALSE;\n@@ -7372,8 +7384,10 @@ process_relocs (Filedata * filedata)\n \t      dump_relocations (filedata,\n \t\t\t\toffset_from_vma (filedata, rel_offset, rel_size),\n \t\t\t\trel_size,\n-\t\t\t\tdynamic_symbols, num_dynamic_syms,\n-\t\t\t\tdynamic_strings, dynamic_strings_length,\n+\t\t\t\tfiledata->dynamic_symbols,\n+\t\t\t\tfiledata->num_dynamic_syms,\n+\t\t\t\tfiledata->dynamic_strings,\n+\t\t\t\tfiledata->dynamic_strings_length,\n \t\t\t\tis_rela, TRUE /* is_dynamic */);\n \t    }\n \t}\n@@ -7462,7 +7476,7 @@ process_relocs (Filedata * filedata)\n \t  /* Users sometimes forget the -D option, so try to be helpful.  */\n \t  for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)\n \t    {\n-\t      if (dynamic_info [dynamic_relocations [i].size])\n+\t      if (filedata->dynamic_info[dynamic_relocations [i].size])\n \t\t{\n \t\t  printf (_(\"\\nThere are no static relocations in this file.\"));\n \t\t  printf (_(\"\\nTo see the dynamic relocations add --use-dynamic to the command line.\\n\"));\n@@ -7893,12 +7907,12 @@ ia64_process_unwind (Filedata * filedata)\n \t  /* We need to find which section group it is in.  */\n \t  struct group_list * g;\n \n-\t  if (section_headers_groups == NULL\n-\t      || section_headers_groups [i] == NULL)\n+\t  if (filedata->section_headers_groups == NULL\n+\t      || filedata->section_headers_groups[i] == NULL)\n \t    i = filedata->file_header.e_shnum;\n \t  else\n \t    {\n-\t      g = section_headers_groups [i]->root;\n+\t      g = filedata->section_headers_groups[i]->root;\n \n \t      for (; g != NULL; g = g->next)\n \t\t{\n@@ -9513,7 +9527,7 @@ dynamic_section_aarch64_val (Elf_Internal_Dyn * entry)\n }\n \n static void\n-dynamic_section_mips_val (Elf_Internal_Dyn * entry)\n+dynamic_section_mips_val (Filedata * filedata, Elf_Internal_Dyn * entry)\n {\n   switch (entry->d_tag)\n     {\n@@ -9543,8 +9557,9 @@ dynamic_section_mips_val (Elf_Internal_Dyn * entry)\n       break;\n \n     case DT_MIPS_IVERSION:\n-      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n-\tprintf (_(\"Interface Version: %s\"), GET_DYNAMIC_NAME (entry->d_un.d_val));\n+      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))\n+\tprintf (_(\"Interface Version: %s\"),\n+\t\tGET_DYNAMIC_NAME (filedata, entry->d_un.d_val));\n       else\n \t{\n \t  char buf[40];\n@@ -9589,8 +9604,8 @@ dynamic_section_mips_val (Elf_Internal_Dyn * entry)\n       break;\n \n     case DT_MIPS_XHASH:\n-      dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;\n-      dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n+      filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;\n+      filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n       /* Falls through.  */\n \n     default:\n@@ -9750,35 +9765,37 @@ get_32bit_dynamic_section (Filedata * filedata)\n   Elf32_External_Dyn * ext;\n   Elf_Internal_Dyn * entry;\n \n-  edyn = (Elf32_External_Dyn *) get_data (NULL, filedata, dynamic_addr, 1,\n-                                          dynamic_size, _(\"dynamic section\"));\n+  edyn = (Elf32_External_Dyn *) get_data (NULL, filedata,\n+\t\t\t\t\t  filedata->dynamic_addr, 1,\n+\t\t\t\t\t  filedata->dynamic_size,\n+\t\t\t\t\t  _(\"dynamic section\"));\n   if (!edyn)\n     return FALSE;\n \n   /* SGI's ELF has more than one section in the DYNAMIC segment, and we\n      might not have the luxury of section headers.  Look for the DT_NULL\n      terminator to determine the number of entries.  */\n-  for (ext = edyn, dynamic_nent = 0;\n-       (char *) (ext + 1) <= (char *) edyn + dynamic_size;\n+  for (ext = edyn, filedata->dynamic_nent = 0;\n+       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;\n        ext++)\n     {\n-      dynamic_nent++;\n+      filedata->dynamic_nent++;\n       if (BYTE_GET (ext->d_tag) == DT_NULL)\n \tbreak;\n     }\n \n-  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,\n-                                                  sizeof (* entry));\n-  if (dynamic_section == NULL)\n+  filedata->dynamic_section\n+    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));\n+  if (filedata->dynamic_section == NULL)\n     {\n       error (_(\"Out of memory allocating space for %lu dynamic entries\\n\"),\n-\t     (unsigned long) dynamic_nent);\n+\t     (unsigned long) filedata->dynamic_nent);\n       free (edyn);\n       return FALSE;\n     }\n \n-  for (ext = edyn, entry = dynamic_section;\n-       entry < dynamic_section + dynamic_nent;\n+  for (ext = edyn, entry = filedata->dynamic_section;\n+       entry < filedata->dynamic_section + filedata->dynamic_nent;\n        ext++, entry++)\n     {\n       entry->d_tag      = BYTE_GET (ext->d_tag);\n@@ -9798,37 +9815,39 @@ get_64bit_dynamic_section (Filedata * filedata)\n   Elf_Internal_Dyn * entry;\n \n   /* Read in the data.  */\n-  edyn = (Elf64_External_Dyn *) get_data (NULL, filedata, dynamic_addr, 1,\n-                                          dynamic_size, _(\"dynamic section\"));\n+  edyn = (Elf64_External_Dyn *) get_data (NULL, filedata,\n+\t\t\t\t\t  filedata->dynamic_addr, 1,\n+\t\t\t\t\t  filedata->dynamic_size,\n+\t\t\t\t\t  _(\"dynamic section\"));\n   if (!edyn)\n     return FALSE;\n \n   /* SGI's ELF has more than one section in the DYNAMIC segment, and we\n      might not have the luxury of section headers.  Look for the DT_NULL\n      terminator to determine the number of entries.  */\n-  for (ext = edyn, dynamic_nent = 0;\n+  for (ext = edyn, filedata->dynamic_nent = 0;\n        /* PR 17533 file: 033-67080-0.004 - do not read past end of buffer.  */\n-       (char *) (ext + 1) <= (char *) edyn + dynamic_size;\n+       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;\n        ext++)\n     {\n-      dynamic_nent++;\n+      filedata->dynamic_nent++;\n       if (BYTE_GET (ext->d_tag) == DT_NULL)\n \tbreak;\n     }\n \n-  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,\n-                                                  sizeof (* entry));\n-  if (dynamic_section == NULL)\n+  filedata->dynamic_section\n+    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));\n+  if (filedata->dynamic_section == NULL)\n     {\n       error (_(\"Out of memory allocating space for %lu dynamic entries\\n\"),\n-\t     (unsigned long) dynamic_nent);\n+\t     (unsigned long) filedata->dynamic_nent);\n       free (edyn);\n       return FALSE;\n     }\n \n   /* Convert from external to internal formats.  */\n-  for (ext = edyn, entry = dynamic_section;\n-       entry < dynamic_section + dynamic_nent;\n+  for (ext = edyn, entry = filedata->dynamic_section;\n+       entry < filedata->dynamic_section + filedata->dynamic_nent;\n        ext++, entry++)\n     {\n       entry->d_tag      = BYTE_GET (ext->d_tag);\n@@ -9937,7 +9956,7 @@ get_num_dynamic_syms (Filedata * filedata)\n   if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n     return num_of_syms;\n \n-  if (dynamic_info[DT_HASH])\n+  if (filedata->dynamic_info[DT_HASH])\n     {\n       unsigned char nb[8];\n       unsigned char nc[8];\n@@ -9950,8 +9969,8 @@ get_num_dynamic_syms (Filedata * filedata)\n \thash_ent_size = 8;\n \n       if (fseek (filedata->handle,\n-\t\t (archive_file_offset\n-\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n+\t\t (filedata->archive_file_offset\n+\t\t  + offset_from_vma (filedata, filedata->dynamic_info[DT_HASH],\n \t\t\t\t     sizeof nb + sizeof nc)),\n \t\t SEEK_SET))\n \t{\n@@ -9971,33 +9990,35 @@ get_num_dynamic_syms (Filedata * filedata)\n \t  goto no_hash;\n \t}\n \n-      nbuckets = byte_get (nb, hash_ent_size);\n-      nchains = byte_get (nc, hash_ent_size);\n+      filedata->nbuckets = byte_get (nb, hash_ent_size);\n+      filedata->nchains = byte_get (nc, hash_ent_size);\n \n-      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n-      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n+      filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,\n+\t\t\t\t\t    hash_ent_size);\n+      filedata->chains  = get_dynamic_data (filedata, filedata->nchains,\n+\t\t\t\t\t    hash_ent_size);\n \n-      if (buckets != NULL && chains != NULL)\n-\tnum_of_syms = nchains;\n+      if (filedata->buckets != NULL && filedata->chains != NULL)\n+\tnum_of_syms = filedata->nchains;\n \n     no_hash:\n       if (num_of_syms == 0)\n \t{\n-\t  if (buckets)\n+\t  if (filedata->buckets)\n \t    {\n-\t      free (buckets);\n-\t      buckets = NULL;\n+\t      free (filedata->buckets);\n+\t      filedata->buckets = NULL;\n \t    }\n-\t  if (chains)\n+\t  if (filedata->chains)\n \t    {\n-\t      free (chains);\n-\t      chains = NULL;\n+\t      free (filedata->chains);\n+\t      filedata->chains = NULL;\n \t    }\n-\t  nbuckets = 0;\n+\t  filedata->nbuckets = 0;\n \t}\n     }\n \n-  if (dynamic_info_DT_GNU_HASH)\n+  if (filedata->dynamic_info_DT_GNU_HASH)\n     {\n       unsigned char nb[16];\n       bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n@@ -10006,8 +10027,9 @@ get_num_dynamic_syms (Filedata * filedata)\n       bfd_boolean gnu_hash_error = FALSE;\n \n       if (fseek (filedata->handle,\n-\t\t (archive_file_offset\n-\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n+\t\t (filedata->archive_file_offset\n+\t\t  + offset_from_vma (filedata,\n+\t\t\t\t     filedata->dynamic_info_DT_GNU_HASH,\n \t\t\t\t     sizeof nb)),\n \t\t SEEK_SET))\n \t{\n@@ -10023,17 +10045,17 @@ get_num_dynamic_syms (Filedata * filedata)\n \t  goto no_gnu_hash;\n \t}\n \n-      ngnubuckets = byte_get (nb, 4);\n-      gnusymidx = byte_get (nb + 4, 4);\n+      filedata->ngnubuckets = byte_get (nb, 4);\n+      filedata->gnusymidx = byte_get (nb + 4, 4);\n       bitmaskwords = byte_get (nb + 8, 4);\n-      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n+      buckets_vma = filedata->dynamic_info_DT_GNU_HASH + 16;\n       if (is_32bit_elf)\n \tbuckets_vma += bitmaskwords * 4;\n       else\n \tbuckets_vma += bitmaskwords * 8;\n \n       if (fseek (filedata->handle,\n-\t\t (archive_file_offset\n+\t\t (filedata->archive_file_offset\n \t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n \t\t SEEK_SET))\n \t{\n@@ -10042,25 +10064,26 @@ get_num_dynamic_syms (Filedata * filedata)\n \t  goto no_gnu_hash;\n \t}\n \n-      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n+      filedata->gnubuckets\n+\t= get_dynamic_data (filedata, filedata->ngnubuckets, 4);\n \n-      if (gnubuckets == NULL)\n+      if (filedata->gnubuckets == NULL)\n \t{\n \t  gnu_hash_error = TRUE;\n \t  goto no_gnu_hash;\n \t}\n \n-      for (i = 0; i < ngnubuckets; i++)\n-\tif (gnubuckets[i] != 0)\n+      for (i = 0; i < filedata->ngnubuckets; i++)\n+\tif (filedata->gnubuckets[i] != 0)\n \t  {\n-\t    if (gnubuckets[i] < gnusymidx)\n+\t    if (filedata->gnubuckets[i] < filedata->gnusymidx)\n \t      {\n \t\tgnu_hash_error = TRUE;\n \t\tgoto no_gnu_hash;\n \t      }\n \n-\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n-\t      maxchain = gnubuckets[i];\n+\t    if (maxchain == 0xffffffff || filedata->gnubuckets[i] > maxchain)\n+\t      maxchain = filedata->gnubuckets[i];\n \t  }\n \n       if (maxchain == 0xffffffff)\n@@ -10069,12 +10092,14 @@ get_num_dynamic_syms (Filedata * filedata)\n \t  goto no_gnu_hash;\n \t}\n \n-      maxchain -= gnusymidx;\n+      maxchain -= filedata->gnusymidx;\n \n       if (fseek (filedata->handle,\n-\t\t (archive_file_offset\n-\t\t  + offset_from_vma (filedata, buckets_vma\n-\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n+\t\t (filedata->archive_file_offset\n+\t\t  + offset_from_vma (filedata,\n+\t\t\t\t     buckets_vma + 4 * (filedata->ngnubuckets\n+\t\t\t\t\t\t\t+ maxchain),\n+\t\t\t\t      4)),\n \t\t SEEK_SET))\n \t{\n \t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n@@ -10102,30 +10127,32 @@ get_num_dynamic_syms (Filedata * filedata)\n       while ((byte_get (nb, 4) & 1) == 0);\n \n       if (fseek (filedata->handle,\n-\t\t (archive_file_offset\n-\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n+\t\t (filedata->archive_file_offset\n+\t\t  + offset_from_vma (filedata, (buckets_vma\n+\t\t\t\t\t\t+ 4 * filedata->ngnubuckets),\n+\t\t\t\t     4)),\n \t\t SEEK_SET))\n \t{\n \t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n \t  gnu_hash_error = TRUE;\n \t  goto no_gnu_hash;\n \t}\n \n-      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n-      ngnuchains = maxchain;\n+      filedata->gnuchains = get_dynamic_data (filedata, maxchain, 4);\n+      filedata->ngnuchains = maxchain;\n \n-      if (gnuchains == NULL)\n+      if (filedata->gnuchains == NULL)\n \t{\n \t  gnu_hash_error = TRUE;\n \t  goto no_gnu_hash;\n \t}\n \n-      if (dynamic_info_DT_MIPS_XHASH)\n+      if (filedata->dynamic_info_DT_MIPS_XHASH)\n \t{\n \t  if (fseek (filedata->handle,\n-\t\t     (archive_file_offset\n+\t\t     (filedata->archive_file_offset\n \t\t      + offset_from_vma (filedata, (buckets_vma\n-\t\t\t\t\t\t    + 4 * (ngnubuckets\n+\t\t\t\t\t\t    + 4 * (filedata->ngnubuckets\n \t\t\t\t\t\t\t   + maxchain)), 4)),\n \t\t     SEEK_SET))\n \t    {\n@@ -10134,21 +10161,21 @@ get_num_dynamic_syms (Filedata * filedata)\n \t      goto no_gnu_hash;\n \t    }\n \n-\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n+\t  filedata->mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n \t}\n \n-      for (hn = 0; hn < ngnubuckets; ++hn)\n-\tif (gnubuckets[hn] != 0)\n+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)\n+\tif (filedata->gnubuckets[hn] != 0)\n \t  {\n-\t    bfd_vma si = gnubuckets[hn];\n-\t    bfd_vma off = si - gnusymidx;\n+\t    bfd_vma si = filedata->gnubuckets[hn];\n+\t    bfd_vma off = si - filedata->gnusymidx;\n \n \t    do\n \t      {\n-\t\tif (dynamic_info_DT_MIPS_XHASH)\n+\t\tif (filedata->dynamic_info_DT_MIPS_XHASH)\n \t\t  {\n-\t\t    if (mipsxlat[off] >= num_of_syms)\n-\t\t      num_of_syms = mipsxlat[off] + 1;\n+\t\t    if (filedata->mipsxlat[off] >= num_of_syms)\n+\t\t      num_of_syms = filedata->mipsxlat[off] + 1;\n \t\t  }\n \t\telse\n \t\t  {\n@@ -10157,29 +10184,30 @@ get_num_dynamic_syms (Filedata * filedata)\n \t\t  }\n \t\tsi++;\n \t      }\n-\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n+\t    while (off < filedata->ngnuchains\n+\t\t   && (filedata->gnuchains[off++] & 1) == 0);\n \t  }\n \n     no_gnu_hash:\n       if (gnu_hash_error)\n \t{\n-\t  if (mipsxlat)\n+\t  if (filedata->mipsxlat)\n \t    {\n-\t      free (mipsxlat);\n-\t      mipsxlat = NULL;\n+\t      free (filedata->mipsxlat);\n+\t      filedata->mipsxlat = NULL;\n \t    }\n-\t  if (gnuchains)\n+\t  if (filedata->gnuchains)\n \t    {\n-\t      free (gnuchains);\n-\t      gnuchains = NULL;\n+\t      free (filedata->gnuchains);\n+\t      filedata->gnuchains = NULL;\n \t    }\n-\t  if (gnubuckets)\n+\t  if (filedata->gnubuckets)\n \t    {\n-\t      free (gnubuckets);\n-\t      gnubuckets = NULL;\n+\t      free (filedata->gnubuckets);\n+\t      filedata->gnubuckets = NULL;\n \t    }\n-\t  ngnubuckets = 0;\n-\t  ngnuchains = 0;\n+\t  filedata->ngnubuckets = 0;\n+\t  filedata->ngnuchains = 0;\n \t}\n     }\n \n@@ -10193,7 +10221,7 @@ process_dynamic_section (Filedata * filedata)\n {\n   Elf_Internal_Dyn * entry;\n \n-  if (dynamic_size == 0)\n+  if (filedata->dynamic_size == 0)\n     {\n       if (do_dynamic)\n \tprintf (_(\"\\nThere is no dynamic section in this file.\\n\"));\n@@ -10213,31 +10241,32 @@ process_dynamic_section (Filedata * filedata)\n     }\n \n   /* Find the appropriate symbol table.  */\n-  if (dynamic_symbols == NULL || do_histogram)\n+  if (filedata->dynamic_symbols == NULL || do_histogram)\n     {\n-      for (entry = dynamic_section;\n-\t   entry < dynamic_section + dynamic_nent;\n+      for (entry = filedata->dynamic_section;\n+\t   entry < filedata->dynamic_section + filedata->dynamic_nent;\n \t   ++entry)\n \tif (entry->d_tag == DT_SYMTAB)\n-\t  dynamic_info[DT_SYMTAB] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[DT_SYMTAB] = entry->d_un.d_val;\n \telse if (entry->d_tag == DT_SYMENT)\n-\t  dynamic_info[DT_SYMENT] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[DT_SYMENT] = entry->d_un.d_val;\n \telse if (entry->d_tag == DT_HASH)\n-\t  dynamic_info[DT_HASH] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[DT_HASH] = entry->d_un.d_val;\n \telse if (entry->d_tag == DT_GNU_HASH)\n-\t  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n+\t  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n \telse if ((filedata->file_header.e_machine == EM_MIPS\n \t\t  || filedata->file_header.e_machine == EM_MIPS_RS3_LE)\n \t\t && entry->d_tag == DT_MIPS_XHASH)\n \t  {\n-\t    dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;\n-\t    dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n+\t    filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;\n+\t    filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n \t  }\n \n-      if (dynamic_info[DT_SYMTAB] && dynamic_info[DT_SYMENT])\n+      if (filedata->dynamic_info[DT_SYMTAB]\n+\t  && filedata->dynamic_info[DT_SYMENT])\n \t{\n \t  Elf_Internal_Phdr *seg;\n-\t    bfd_vma vma = dynamic_info[DT_SYMTAB];\n+\t    bfd_vma vma = filedata->dynamic_info[DT_SYMTAB];\n \n \t    if (! get_program_headers (filedata))\n \t      {\n@@ -10265,7 +10294,7 @@ process_dynamic_section (Filedata * filedata)\n \t\tif (vma >= (seg->p_vaddr & -seg->p_align)\n \t\t    && vma <= seg->p_vaddr + seg->p_filesz\n \t\t    && (num_of_syms = get_num_dynamic_syms (filedata)) != 0\n-\t\t    && dynamic_symbols == NULL)\n+\t\t    && filedata->dynamic_symbols == NULL)\n \t\t  {\n \t\t    /* Since we do not know how big the symbol table is,\n \t\t       we default to reading in up to the end of PT_LOAD\n@@ -10275,14 +10304,14 @@ process_dynamic_section (Filedata * filedata)\n \t\t    section.sh_offset = (vma - seg->p_vaddr\n \t\t\t\t\t + seg->p_offset);\n \t\t    section.sh_size = (num_of_syms\n-\t\t\t\t       * dynamic_info[DT_SYMENT]);\n-\t\t    section.sh_entsize = dynamic_info[DT_SYMENT];\n+\t\t\t\t       * filedata->dynamic_info[DT_SYMENT]);\n+\t\t    section.sh_entsize = filedata->dynamic_info[DT_SYMENT];\n \t\t    section.sh_name = filedata->string_table_length;\n-\t\t    dynamic_symbols = GET_ELF_SYMBOLS (filedata,\n-\t\t\t\t\t\t       &section,\n-\t\t\t\t\t\t       & num_dynamic_syms);\n-\t\t    if (dynamic_symbols == NULL\n-\t\t\t|| num_dynamic_syms != num_of_syms)\n+\t\t    filedata->dynamic_symbols\n+\t\t      = GET_ELF_SYMBOLS (filedata, &section,\n+\t\t\t\t\t &filedata->num_dynamic_syms);\n+\t\t    if (filedata->dynamic_symbols == NULL\n+\t\t\t|| filedata->num_dynamic_syms != num_of_syms)\n \t\t      {\n \t\t\terror (_(\"Corrupt DT_SYMTAB dynamic entry\\n\"));\n \t\t\treturn FALSE;\n@@ -10293,46 +10322,47 @@ process_dynamic_section (Filedata * filedata)\n       }\n \n   /* Similarly find a string table.  */\n-  if (dynamic_strings == NULL)\n-    for (entry = dynamic_section;\n-\t entry < dynamic_section + dynamic_nent;\n+  if (filedata->dynamic_strings == NULL)\n+    for (entry = filedata->dynamic_section;\n+\t entry < filedata->dynamic_section + filedata->dynamic_nent;\n \t ++entry)\n       {\n \tif (entry->d_tag == DT_STRTAB)\n-\t  dynamic_info[DT_STRTAB] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[DT_STRTAB] = entry->d_un.d_val;\n \n \tif (entry->d_tag == DT_STRSZ)\n-\t  dynamic_info[DT_STRSZ] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[DT_STRSZ] = entry->d_un.d_val;\n \n-\tif (dynamic_info[DT_STRTAB] && dynamic_info[DT_STRSZ])\n+\tif (filedata->dynamic_info[DT_STRTAB]\n+\t    && filedata->dynamic_info[DT_STRSZ])\n \t  {\n \t    unsigned long offset;\n-\t    bfd_size_type str_tab_len = dynamic_info[DT_STRSZ];\n+\t    bfd_size_type str_tab_len = filedata->dynamic_info[DT_STRSZ];\n \n \t    offset = offset_from_vma (filedata,\n-\t\t\t\t      dynamic_info[DT_STRTAB],\n+\t\t\t\t      filedata->dynamic_info[DT_STRTAB],\n \t\t\t\t      str_tab_len);\n-\t    dynamic_strings = (char *) get_data (NULL, filedata, offset, 1,\n-\t\t\t\t\t\t str_tab_len,\n-\t\t\t\t\t\t _(\"dynamic string table\"));\n-\t    if (dynamic_strings == NULL)\n+\t    filedata->dynamic_strings\n+\t      = (char *) get_data (NULL, filedata, offset, 1, str_tab_len,\n+\t\t\t\t   _(\"dynamic string table\"));\n+\t    if (filedata->dynamic_strings == NULL)\n \t      {\n \t\terror (_(\"Corrupt DT_STRTAB dynamic entry\\n\"));\n \t\tbreak;\n \t      }\n \n-\t    dynamic_strings_length = str_tab_len;\n+\t    filedata->dynamic_strings_length = str_tab_len;\n \t    break;\n \t  }\n       }\n \n   /* And find the syminfo section if available.  */\n-  if (dynamic_syminfo == NULL)\n+  if (filedata->dynamic_syminfo == NULL)\n     {\n       unsigned long syminsz = 0;\n \n-      for (entry = dynamic_section;\n-\t   entry < dynamic_section + dynamic_nent;\n+      for (entry = filedata->dynamic_section;\n+\t   entry < filedata->dynamic_section + filedata->dynamic_nent;\n \t   ++entry)\n \t{\n \t  if (entry->d_tag == DT_SYMINENT)\n@@ -10348,39 +10378,39 @@ process_dynamic_section (Filedata * filedata)\n \t  else if (entry->d_tag == DT_SYMINSZ)\n \t    syminsz = entry->d_un.d_val;\n \t  else if (entry->d_tag == DT_SYMINFO)\n-\t    dynamic_syminfo_offset = offset_from_vma (filedata, entry->d_un.d_val,\n-\t\t\t\t\t\t      syminsz);\n+\t    filedata->dynamic_syminfo_offset\n+\t      = offset_from_vma (filedata, entry->d_un.d_val, syminsz);\n \t}\n \n-      if (dynamic_syminfo_offset != 0 && syminsz != 0)\n+      if (filedata->dynamic_syminfo_offset != 0 && syminsz != 0)\n \t{\n \t  Elf_External_Syminfo * extsyminfo;\n \t  Elf_External_Syminfo * extsym;\n \t  Elf_Internal_Syminfo * syminfo;\n \n \t  /* There is a syminfo section.  Read the data.  */\n \t  extsyminfo = (Elf_External_Syminfo *)\n-              get_data (NULL, filedata, dynamic_syminfo_offset, 1, syminsz,\n-                        _(\"symbol information\"));\n+\t    get_data (NULL, filedata, filedata->dynamic_syminfo_offset,\n+\t\t      1, syminsz, _(\"symbol information\"));\n \t  if (!extsyminfo)\n \t    return FALSE;\n \n-\t  if (dynamic_syminfo != NULL)\n+\t  if (filedata->dynamic_syminfo != NULL)\n \t    {\n \t      error (_(\"Multiple dynamic symbol information sections found\\n\"));\n-\t      free (dynamic_syminfo);\n+\t      free (filedata->dynamic_syminfo);\n \t    }\n-\t  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);\n-\t  if (dynamic_syminfo == NULL)\n+\t  filedata->dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);\n+\t  if (filedata->dynamic_syminfo == NULL)\n \t    {\n \t      error (_(\"Out of memory allocating %lu byte for dynamic symbol info\\n\"),\n \t\t     (unsigned long) syminsz);\n \t      return FALSE;\n \t    }\n \n-\t  dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);\n-\t  for (syminfo = dynamic_syminfo, extsym = extsyminfo;\n-\t       syminfo < dynamic_syminfo + dynamic_syminfo_nent;\n+\t  filedata->dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);\n+\t  for (syminfo = filedata->dynamic_syminfo, extsym = extsyminfo;\n+\t       syminfo < filedata->dynamic_syminfo + filedata->dynamic_syminfo_nent;\n \t       ++syminfo, ++extsym)\n \t    {\n \t      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);\n@@ -10391,18 +10421,18 @@ process_dynamic_section (Filedata * filedata)\n \t}\n     }\n \n-  if (do_dynamic && dynamic_addr)\n+  if (do_dynamic && filedata->dynamic_addr)\n     printf (ngettext (\"\\nDynamic section at offset 0x%lx \"\n \t\t      \"contains %lu entry:\\n\",\n \t\t      \"\\nDynamic section at offset 0x%lx \"\n \t\t      \"contains %lu entries:\\n\",\n-\t\t      dynamic_nent),\n-\t    dynamic_addr, (unsigned long) dynamic_nent);\n+\t\t      filedata->dynamic_nent),\n+\t    filedata->dynamic_addr, (unsigned long) filedata->dynamic_nent);\n   if (do_dynamic)\n     printf (_(\"  Tag        Type                         Name/Value\\n\"));\n \n-  for (entry = dynamic_section;\n-       entry < dynamic_section + dynamic_nent;\n+  for (entry = filedata->dynamic_section;\n+       entry < filedata->dynamic_section + filedata->dynamic_nent;\n        entry++)\n     {\n       if (do_dynamic)\n@@ -10453,8 +10483,9 @@ process_dynamic_section (Filedata * filedata)\n \t\t  break;\n \t\t}\n \n-\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n-\t\tprintf (\": [%s]\\n\", GET_DYNAMIC_NAME (entry->d_un.d_val));\n+\t      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))\n+\t\tprintf (\": [%s]\\n\",\n+\t\t\tGET_DYNAMIC_NAME (filedata, entry->d_un.d_val));\n \t      else\n \t\t{\n \t\t  printf (\": \");\n@@ -10693,7 +10724,7 @@ process_dynamic_section (Filedata * filedata)\n \t  break;\n \n \tcase DT_PLTREL:\n-\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;\n \t  if (do_dynamic)\n \t    puts (get_dynamic_type (filedata, entry->d_un.d_val));\n \t  break;\n@@ -10715,14 +10746,14 @@ process_dynamic_section (Filedata * filedata)\n \tcase DT_TEXTREL\t:\n \tcase DT_JMPREL\t:\n \tcase DT_RUNPATH\t:\n-\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;\n \n \t  if (do_dynamic)\n \t    {\n \t      char * name;\n \n-\t      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))\n-\t\tname = GET_DYNAMIC_NAME (entry->d_un.d_val);\n+\t      if (VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))\n+\t\tname = GET_DYNAMIC_NAME (filedata, entry->d_un.d_val);\n \t      else\n \t\tname = NULL;\n \n@@ -10733,7 +10764,7 @@ process_dynamic_section (Filedata * filedata)\n \t\t    case DT_NEEDED:\n \t\t      printf (_(\"Shared library: [%s]\"), name);\n \n-\t\t      if (streq (name, program_interpreter))\n+\t\t      if (streq (name, filedata->program_interpreter))\n \t\t\tprintf (_(\" program interpreter\"));\n \t\t      break;\n \n@@ -10768,7 +10799,7 @@ process_dynamic_section (Filedata * filedata)\n \tcase DT_RELAENT\t:\n \tcase DT_SYMENT\t:\n \tcase DT_RELENT\t:\n-\t  dynamic_info[entry->d_tag] = entry->d_un.d_val;\n+\t  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;\n \t  /* Fall through.  */\n \tcase DT_PLTPADSZ:\n \tcase DT_MOVEENT\t:\n@@ -10804,9 +10835,9 @@ process_dynamic_section (Filedata * filedata)\n \t  if (do_dynamic)\n \t    {\n \t      if (entry->d_tag == DT_USED\n-\t\t  && VALID_DYNAMIC_NAME (entry->d_un.d_val))\n+\t\t  && VALID_DYNAMIC_NAME (filedata, entry->d_un.d_val))\n \t\t{\n-\t\t  char * name = GET_DYNAMIC_NAME (entry->d_un.d_val);\n+\t\t  char * name = GET_DYNAMIC_NAME (filedata, entry->d_un.d_val);\n \n \t\t  if (*name)\n \t\t    {\n@@ -10846,7 +10877,7 @@ process_dynamic_section (Filedata * filedata)\n \t  break;\n \n \tcase DT_GNU_HASH:\n-\t  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n+\t  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;\n \t  if (do_dynamic)\n \t    {\n \t      print_vma (entry->d_un.d_val, PREFIX_HEX);\n@@ -10856,8 +10887,8 @@ process_dynamic_section (Filedata * filedata)\n \n \tdefault:\n \t  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))\n-\t    version_info[DT_VERSIONTAGIDX (entry->d_tag)] =\n-\t      entry->d_un.d_val;\n+\t    filedata->version_info[DT_VERSIONTAGIDX (entry->d_tag)]\n+\t      = entry->d_un.d_val;\n \n \t  if (do_dynamic)\n \t    {\n@@ -10868,7 +10899,7 @@ process_dynamic_section (Filedata * filedata)\n \t\t  break;\n \t\tcase EM_MIPS:\n \t\tcase EM_MIPS_RS3_LE:\n-\t\t  dynamic_section_mips_val (entry);\n+\t\t  dynamic_section_mips_val (filedata, entry);\n \t\t  break;\n \t\tcase EM_PARISC:\n \t\t  dynamic_section_parisc_val (entry);\n@@ -11019,8 +11050,9 @@ process_version_sections (Filedata * filedata)\n \t\taux.vda_name = BYTE_GET (eaux->vda_name);\n \t\taux.vda_next = BYTE_GET (eaux->vda_next);\n \n-\t\tif (VALID_DYNAMIC_NAME (aux.vda_name))\n-\t\t  printf (_(\"Name: %s\\n\"), GET_DYNAMIC_NAME (aux.vda_name));\n+\t\tif (VALID_DYNAMIC_NAME (filedata, aux.vda_name))\n+\t\t  printf (_(\"Name: %s\\n\"),\n+\t\t\t  GET_DYNAMIC_NAME (filedata, aux.vda_name));\n \t\telse\n \t\t  printf (_(\"Name index: %ld\\n\"), aux.vda_name);\n \n@@ -11050,9 +11082,10 @@ process_version_sections (Filedata * filedata)\n \t\t    aux.vda_name = BYTE_GET (eaux->vda_name);\n \t\t    aux.vda_next = BYTE_GET (eaux->vda_next);\n \n-\t\t    if (VALID_DYNAMIC_NAME (aux.vda_name))\n+\t\t    if (VALID_DYNAMIC_NAME (filedata, aux.vda_name))\n \t\t      printf (_(\"  %#06lx: Parent %d: %s\\n\"),\n-\t\t\t      isum, j, GET_DYNAMIC_NAME (aux.vda_name));\n+\t\t\t      isum, j,\n+\t\t\t      GET_DYNAMIC_NAME (filedata, aux.vda_name));\n \t\t    else\n \t\t      printf (_(\"  %#06lx: Parent %d, name index: %ld\\n\"),\n \t\t\t      isum, j, aux.vda_name);\n@@ -11135,8 +11168,9 @@ process_version_sections (Filedata * filedata)\n \n \t\tprintf (_(\"  %#06lx: Version: %d\"), idx, ent.vn_version);\n \n-\t\tif (VALID_DYNAMIC_NAME (ent.vn_file))\n-\t\t  printf (_(\"  File: %s\"), GET_DYNAMIC_NAME (ent.vn_file));\n+\t\tif (VALID_DYNAMIC_NAME (filedata, ent.vn_file))\n+\t\t  printf (_(\"  File: %s\"),\n+\t\t\t  GET_DYNAMIC_NAME (filedata, ent.vn_file));\n \t\telse\n \t\t  printf (_(\"  File: %lx\"), ent.vn_file);\n \n@@ -11162,9 +11196,9 @@ process_version_sections (Filedata * filedata)\n \t\t    aux.vna_name  = BYTE_GET (eaux->vna_name);\n \t\t    aux.vna_next  = BYTE_GET (eaux->vna_next);\n \n-\t\t    if (VALID_DYNAMIC_NAME (aux.vna_name))\n+\t\t    if (VALID_DYNAMIC_NAME (filedata, aux.vna_name))\n \t\t      printf (_(\"  %#06lx:   Name: %s\"),\n-\t\t\t      isum, GET_DYNAMIC_NAME (aux.vna_name));\n+\t\t\t      isum, GET_DYNAMIC_NAME (filedata, aux.vna_name));\n \t\t    else\n \t\t      printf (_(\"  %#06lx:   Name index: %lx\"),\n \t\t\t      isum, aux.vna_name);\n@@ -11262,7 +11296,7 @@ process_version_sections (Filedata * filedata)\n \t\t    printable_section_name (filedata, link_section));\n \n \t    off = offset_from_vma (filedata,\n-\t\t\t\t   version_info[DT_VERSIONTAGIDX (DT_VERSYM)],\n+\t\t\t\t   filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],\n \t\t\t\t   total * sizeof (short));\n \t    edata = (unsigned char *) get_data (NULL, filedata, off,\n \t\t\t\t\t\tsizeof (short), total,\n@@ -11314,13 +11348,14 @@ process_version_sections (Filedata * filedata)\n \t\t\t}\n \n \t\t      name = NULL;\n-\t\t      if (version_info[DT_VERSIONTAGIDX (DT_VERNEED)])\n+\t\t      if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])\n \t\t\t{\n \t\t\t  Elf_Internal_Verneed ivn;\n \t\t\t  unsigned long offset;\n \n \t\t\t  offset = offset_from_vma\n-\t\t\t    (filedata, version_info[DT_VERSIONTAGIDX (DT_VERNEED)],\n+\t\t\t    (filedata,\n+\t\t\t     filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],\n \t\t\t     sizeof (Elf_External_Verneed));\n \n \t\t\t  do\n@@ -11375,14 +11410,15 @@ process_version_sections (Filedata * filedata)\n \t\t\t}\n \n \t\t      if (data[cnt + j] != 0x8001\n-\t\t\t  && version_info[DT_VERSIONTAGIDX (DT_VERDEF)])\n+\t\t\t  && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])\n \t\t\t{\n \t\t\t  Elf_Internal_Verdef ivd;\n \t\t\t  Elf_External_Verdef evd;\n \t\t\t  unsigned long offset;\n \n \t\t\t  offset = offset_from_vma\n-\t\t\t    (filedata, version_info[DT_VERSIONTAGIDX (DT_VERDEF)],\n+\t\t\t    (filedata,\n+\t\t\t     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],\n \t\t\t     sizeof evd);\n \n \t\t\t  do\n@@ -11794,10 +11830,11 @@ get_symbol_version_string (Filedata *                   filedata,\n   unsigned short max_vd_ndx;\n \n   if (!is_dynsym\n-      || version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0)\n+      || filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0)\n     return NULL;\n \n-  offset = offset_from_vma (filedata, version_info[DT_VERSIONTAGIDX (DT_VERSYM)],\n+  offset = offset_from_vma (filedata,\n+\t\t\t    filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],\n \t\t\t    sizeof data + si * sizeof (vers_data));\n \n   if (get_data (&data, filedata, offset + si * sizeof (vers_data),\n@@ -11823,15 +11860,15 @@ get_symbol_version_string (Filedata *                   filedata,\n \n   if (psym->st_shndx != SHN_UNDEF\n       && vers_data != 0x8001\n-      && version_info[DT_VERSIONTAGIDX (DT_VERDEF)])\n+      && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])\n     {\n       Elf_Internal_Verdef ivd;\n       Elf_Internal_Verdaux ivda;\n       Elf_External_Verdaux evda;\n       unsigned long off;\n \n       off = offset_from_vma (filedata,\n-\t\t\t     version_info[DT_VERSIONTAGIDX (DT_VERDEF)],\n+\t\t\t     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],\n \t\t\t     sizeof (Elf_External_Verdef));\n \n       do\n@@ -11881,14 +11918,14 @@ get_symbol_version_string (Filedata *                   filedata,\n \t}\n     }\n \n-  if (version_info[DT_VERSIONTAGIDX (DT_VERNEED)])\n+  if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])\n     {\n       Elf_External_Verneed evn;\n       Elf_Internal_Verneed ivn;\n       Elf_Internal_Vernaux ivna;\n \n       offset = offset_from_vma (filedata,\n-\t\t\t\tversion_info[DT_VERSIONTAGIDX (DT_VERNEED)],\n+\t\t\t\tfiledata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],\n \t\t\t\tsizeof evn);\n       do\n \t{\n@@ -12024,25 +12061,27 @@ process_symbol_table (Filedata * filedata)\n   if (!do_syms && !do_dyn_syms && !do_histogram)\n     return TRUE;\n \n-  if ((dynamic_info[DT_HASH] || dynamic_info_DT_GNU_HASH)\n+  if ((filedata->dynamic_info[DT_HASH] || filedata->dynamic_info_DT_GNU_HASH)\n       && do_syms\n       && do_using_dynamic\n-      && dynamic_strings != NULL\n-      && dynamic_symbols != NULL)\n+      && filedata->dynamic_strings != NULL\n+      && filedata->dynamic_symbols != NULL)\n     {\n       unsigned long si;\n \n       printf (ngettext (\"\\nSymbol table for image contains %lu entry:\\n\",\n \t\t\t\"\\nSymbol table for image contains %lu entries:\\n\",\n-\t\t\tnum_dynamic_syms), num_dynamic_syms);\n+\t\t\tfiledata->num_dynamic_syms),\n+\t      filedata->num_dynamic_syms);\n       if (is_32bit_elf)\n \tprintf (_(\"   Num:    Value  Size Type    Bind   Vis      Ndx Name\\n\"));\n       else\n \tprintf (_(\"   Num:    Value          Size Type    Bind   Vis      Ndx Name\\n\"));\n \n-      for (si = 0; si < num_dynamic_syms; si++)\n-\tprint_dynamic_symbol (filedata, si, dynamic_symbols, NULL,\n-\t\t\t      dynamic_strings, dynamic_strings_length);\n+      for (si = 0; si < filedata->num_dynamic_syms; si++)\n+\tprint_dynamic_symbol (filedata, si, filedata->dynamic_symbols, NULL,\n+\t\t\t      filedata->dynamic_strings,\n+\t\t\t      filedata->dynamic_strings_length);\n     }\n   else if ((do_dyn_syms || (do_syms && !do_using_dynamic))\n \t   && filedata->section_headers != NULL)\n@@ -12117,7 +12156,7 @@ process_symbol_table (Filedata * filedata)\n     printf\n       (_(\"\\nDynamic symbol information is not available for displaying symbols.\\n\"));\n \n-  if (do_histogram && buckets != NULL)\n+  if (do_histogram && filedata->buckets != NULL)\n     {\n       unsigned long * lengths;\n       unsigned long * counts;\n@@ -12132,27 +12171,28 @@ process_symbol_table (Filedata * filedata)\n \t\t\t\"(total of %lu bucket):\\n\",\n \t\t\t\"\\nHistogram for bucket list length \"\n \t\t\t\"(total of %lu buckets):\\n\",\n-\t\t\t(unsigned long) nbuckets),\n-\t      (unsigned long) nbuckets);\n+\t\t\t(unsigned long) filedata->nbuckets),\n+\t      (unsigned long) filedata->nbuckets);\n \n-      lengths = (unsigned long *) calloc (nbuckets, sizeof (*lengths));\n+      lengths = (unsigned long *) calloc (filedata->nbuckets,\n+\t\t\t\t\t  sizeof (*lengths));\n       if (lengths == NULL)\n \t{\n \t  error (_(\"Out of memory allocating space for histogram buckets\\n\"));\n \t  goto err_out;\n \t}\n-      visited = xcmalloc (nchains, 1);\n-      memset (visited, 0, nchains);\n+      visited = xcmalloc (filedata->nchains, 1);\n+      memset (visited, 0, filedata->nchains);\n \n       printf (_(\" Length  Number     %% of total  Coverage\\n\"));\n-      for (hn = 0; hn < nbuckets; ++hn)\n+      for (hn = 0; hn < filedata->nbuckets; ++hn)\n \t{\n-\t  for (si = buckets[hn]; si > 0; si = chains[si])\n+\t  for (si = filedata->buckets[hn]; si > 0; si = filedata->chains[si])\n \t    {\n \t      ++nsyms;\n \t      if (maxlength < ++lengths[hn])\n \t\t++maxlength;\n-\t      if (si >= nchains || visited[si])\n+\t      if (si >= filedata->nchains || visited[si])\n \t\t{\n \t\t  error (_(\"histogram chain is corrupt\\n\"));\n \t\t  break;\n@@ -12170,19 +12210,19 @@ process_symbol_table (Filedata * filedata)\n \t  goto err_out;\n \t}\n \n-      for (hn = 0; hn < nbuckets; ++hn)\n+      for (hn = 0; hn < filedata->nbuckets; ++hn)\n \t++counts[lengths[hn]];\n \n-      if (nbuckets > 0)\n+      if (filedata->nbuckets > 0)\n \t{\n \t  unsigned long i;\n \t  printf (\"      0  %-10lu (%5.1f%%)\\n\",\n-\t\t  counts[0], (counts[0] * 100.0) / nbuckets);\n+\t\t  counts[0], (counts[0] * 100.0) / filedata->nbuckets);\n \t  for (i = 1; i <= maxlength; ++i)\n \t    {\n \t      nzero_counts += counts[i] * i;\n \t      printf (\"%7lu  %-10lu (%5.1f%%)    %5.1f%%\\n\",\n-\t\t      i, counts[i], (counts[i] * 100.0) / nbuckets,\n+\t\t      i, counts[i], (counts[i] * 100.0) / filedata->nbuckets,\n \t\t      (nzero_counts * 100.0) / nsyms);\n \t    }\n \t}\n@@ -12191,13 +12231,13 @@ process_symbol_table (Filedata * filedata)\n       free (lengths);\n     }\n \n-  free (buckets);\n-  buckets = NULL;\n-  nbuckets = 0;\n-  free (chains);\n-  chains = NULL;\n+  free (filedata->buckets);\n+  filedata->buckets = NULL;\n+  filedata->nbuckets = 0;\n+  free (filedata->chains);\n+  filedata->chains = NULL;\n \n-  if (do_histogram && gnubuckets != NULL)\n+  if (do_histogram && filedata->gnubuckets != NULL)\n     {\n       unsigned long * lengths;\n       unsigned long * counts;\n@@ -12210,11 +12250,12 @@ process_symbol_table (Filedata * filedata)\n \t\t\t\"(total of %lu bucket):\\n\",\n \t\t\t\"\\nHistogram for `%s' bucket list length \"\n \t\t\t\"(total of %lu buckets):\\n\",\n-\t\t\t(unsigned long) ngnubuckets),\n-\t      GNU_HASH_SECTION_NAME,\n-\t      (unsigned long) ngnubuckets);\n+\t\t\t(unsigned long) filedata->ngnubuckets),\n+\t      GNU_HASH_SECTION_NAME (filedata),\n+\t      (unsigned long) filedata->ngnubuckets);\n \n-      lengths = (unsigned long *) calloc (ngnubuckets, sizeof (*lengths));\n+      lengths = (unsigned long *) calloc (filedata->ngnubuckets,\n+\t\t\t\t\t  sizeof (*lengths));\n       if (lengths == NULL)\n \t{\n \t  error (_(\"Out of memory allocating space for gnu histogram buckets\\n\"));\n@@ -12223,14 +12264,15 @@ process_symbol_table (Filedata * filedata)\n \n       printf (_(\" Length  Number     %% of total  Coverage\\n\"));\n \n-      for (hn = 0; hn < ngnubuckets; ++hn)\n-\tif (gnubuckets[hn] != 0)\n+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)\n+\tif (filedata->gnubuckets[hn] != 0)\n \t  {\n \t    bfd_vma off, length = 1;\n \n-\t    for (off = gnubuckets[hn] - gnusymidx;\n+\t    for (off = filedata->gnubuckets[hn] - filedata->gnusymidx;\n \t\t /* PR 17531 file: 010-77222-0.004.  */\n-\t\t off < ngnuchains && (gnuchains[off] & 1) == 0;\n+\t\t off < filedata->ngnuchains\n+\t\t   && (filedata->gnuchains[off] & 1) == 0;\n \t\t ++off)\n \t      ++length;\n \t    lengths[hn] = length;\n@@ -12247,50 +12289,50 @@ process_symbol_table (Filedata * filedata)\n \t  goto err_out;\n \t}\n \n-      for (hn = 0; hn < ngnubuckets; ++hn)\n+      for (hn = 0; hn < filedata->ngnubuckets; ++hn)\n \t++counts[lengths[hn]];\n \n-      if (ngnubuckets > 0)\n+      if (filedata->ngnubuckets > 0)\n \t{\n \t  unsigned long j;\n \t  printf (\"      0  %-10lu (%5.1f%%)\\n\",\n-\t\t  counts[0], (counts[0] * 100.0) / ngnubuckets);\n+\t\t  counts[0], (counts[0] * 100.0) / filedata->ngnubuckets);\n \t  for (j = 1; j <= maxlength; ++j)\n \t    {\n \t      nzero_counts += counts[j] * j;\n \t      printf (\"%7lu  %-10lu (%5.1f%%)    %5.1f%%\\n\",\n-\t\t      j, counts[j], (counts[j] * 100.0) / ngnubuckets,\n+\t\t      j, counts[j], (counts[j] * 100.0) / filedata->ngnubuckets,\n \t\t      (nzero_counts * 100.0) / nsyms);\n \t    }\n \t}\n \n       free (counts);\n       free (lengths);\n     }\n-  free (gnubuckets);\n-  gnubuckets = NULL;\n-  ngnubuckets = 0;\n-  free (gnuchains);\n-  gnuchains = NULL;\n-  ngnuchains = 0;\n-  free (mipsxlat);\n-  mipsxlat = NULL;\n+  free (filedata->gnubuckets);\n+  filedata->gnubuckets = NULL;\n+  filedata->ngnubuckets = 0;\n+  free (filedata->gnuchains);\n+  filedata->gnuchains = NULL;\n+  filedata->ngnuchains = 0;\n+  free (filedata->mipsxlat);\n+  filedata->mipsxlat = NULL;\n   return TRUE;\n \n  err_out:\n-  free (gnubuckets);\n-  gnubuckets = NULL;\n-  ngnubuckets = 0;\n-  free (gnuchains);\n-  gnuchains = NULL;\n-  ngnuchains = 0;\n-  free (mipsxlat);\n-  mipsxlat = NULL;\n-  free (buckets);\n-  buckets = NULL;\n-  nbuckets = 0;\n-  free (chains);\n-  chains = NULL;\n+  free (filedata->gnubuckets);\n+  filedata->gnubuckets = NULL;\n+  filedata->ngnubuckets = 0;\n+  free (filedata->gnuchains);\n+  filedata->gnuchains = NULL;\n+  filedata->ngnuchains = 0;\n+  free (filedata->mipsxlat);\n+  filedata->mipsxlat = NULL;\n+  free (filedata->buckets);\n+  filedata->buckets = NULL;\n+  filedata->nbuckets = 0;\n+  free (filedata->chains);\n+  filedata->chains = NULL;\n   return FALSE;\n }\n \n@@ -12299,38 +12341,39 @@ process_syminfo (Filedata * filedata ATTRIBUTE_UNUSED)\n {\n   unsigned int i;\n \n-  if (dynamic_syminfo == NULL\n+  if (filedata->dynamic_syminfo == NULL\n       || !do_dynamic)\n     /* No syminfo, this is ok.  */\n     return TRUE;\n \n   /* There better should be a dynamic symbol section.  */\n-  if (dynamic_symbols == NULL || dynamic_strings == NULL)\n+  if (filedata->dynamic_symbols == NULL || filedata->dynamic_strings == NULL)\n     return FALSE;\n \n-  if (dynamic_addr)\n+  if (filedata->dynamic_addr)\n     printf (ngettext (\"\\nDynamic info segment at offset 0x%lx \"\n \t\t      \"contains %d entry:\\n\",\n \t\t      \"\\nDynamic info segment at offset 0x%lx \"\n \t\t      \"contains %d entries:\\n\",\n-\t\t      dynamic_syminfo_nent),\n-\t    dynamic_syminfo_offset, dynamic_syminfo_nent);\n+\t\t      filedata->dynamic_syminfo_nent),\n+\t    filedata->dynamic_syminfo_offset, filedata->dynamic_syminfo_nent);\n \n   printf (_(\" Num: Name                           BoundTo     Flags\\n\"));\n-  for (i = 0; i < dynamic_syminfo_nent; ++i)\n+  for (i = 0; i < filedata->dynamic_syminfo_nent; ++i)\n     {\n-      unsigned short int flags = dynamic_syminfo[i].si_flags;\n+      unsigned short int flags = filedata->dynamic_syminfo[i].si_flags;\n \n       printf (\"%4d: \", i);\n-      if (i >= num_dynamic_syms)\n+      if (i >= filedata->num_dynamic_syms)\n \tprintf (_(\"<corrupt index>\"));\n-      else if (VALID_DYNAMIC_NAME (dynamic_symbols[i].st_name))\n-\tprint_symbol (30, GET_DYNAMIC_NAME (dynamic_symbols[i].st_name));\n+      else if (VALID_DYNAMIC_NAME (filedata, filedata->dynamic_symbols[i].st_name))\n+\tprint_symbol (30, GET_DYNAMIC_NAME (filedata,\n+\t\t\t\t\t    filedata->dynamic_symbols[i].st_name));\n       else\n-\tprintf (_(\"<corrupt: %19ld>\"), dynamic_symbols[i].st_name);\n+\tprintf (_(\"<corrupt: %19ld>\"), filedata->dynamic_symbols[i].st_name);\n       putchar (' ');\n \n-      switch (dynamic_syminfo[i].si_boundto)\n+      switch (filedata->dynamic_syminfo[i].si_boundto)\n \t{\n \tcase SYMINFO_BT_SELF:\n \t  fputs (\"SELF       \", stdout);\n@@ -12339,15 +12382,17 @@ process_syminfo (Filedata * filedata ATTRIBUTE_UNUSED)\n \t  fputs (\"PARENT     \", stdout);\n \t  break;\n \tdefault:\n-\t  if (dynamic_syminfo[i].si_boundto > 0\n-\t      && dynamic_syminfo[i].si_boundto < dynamic_nent\n-\t      && VALID_DYNAMIC_NAME (dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val))\n+\t  if (filedata->dynamic_syminfo[i].si_boundto > 0\n+\t      && filedata->dynamic_syminfo[i].si_boundto < filedata->dynamic_nent\n+\t      && VALID_DYNAMIC_NAME (filedata,\n+\t\t\t\t     filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val))\n \t    {\n-\t      print_symbol (10, GET_DYNAMIC_NAME (dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val));\n+\t      print_symbol (10, GET_DYNAMIC_NAME (filedata,\n+\t\t\t\t\t\t  filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val));\n \t      putchar (' ' );\n \t    }\n \t  else\n-\t    printf (\"%-10d \", dynamic_syminfo[i].si_boundto);\n+\t    printf (\"%-10d \", filedata->dynamic_syminfo[i].si_boundto);\n \t  break;\n \t}\n \n@@ -16564,7 +16609,7 @@ process_mips_specific (Filedata * filedata)\n     }\n \n   /* We have a lot of special sections.  Thanks SGI!  */\n-  if (dynamic_section == NULL)\n+  if (filedata->dynamic_section == NULL)\n     {\n       /* No dynamic information available.  See if there is static GOT.  */\n       sect = find_section (filedata, \".got\");\n@@ -16653,9 +16698,10 @@ process_mips_specific (Filedata * filedata)\n       return res;\n     }\n \n-  for (entry = dynamic_section;\n+  for (entry = filedata->dynamic_section;\n        /* PR 17531 file: 012-50589-0.004.  */\n-       entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL;\n+       (entry < filedata->dynamic_section + filedata->dynamic_nent\n+\t&& entry->d_tag != DT_NULL);\n        ++entry)\n     switch (entry->d_tag)\n       {\n@@ -16744,8 +16790,8 @@ process_mips_specific (Filedata * filedata)\n \t\t\ttmp->tm_hour, tmp->tm_min, tmp->tm_sec);\n \n \t      printf (\"%3lu: \", (unsigned long) cnt);\n-\t      if (VALID_DYNAMIC_NAME (liblist.l_name))\n-\t\tprint_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));\n+\t      if (VALID_DYNAMIC_NAME (filedata, liblist.l_name))\n+\t\tprint_symbol (20, GET_DYNAMIC_NAME (filedata, liblist.l_name));\n \t      else\n \t\tprintf (_(\"<corrupt: %9ld>\"), liblist.l_name);\n \t      printf (\" %s %#10lx %-7ld\", timebuf, liblist.l_checksum,\n@@ -17058,7 +17104,7 @@ process_mips_specific (Filedata * filedata)\n       Elf32_Conflict * iconf;\n       size_t cnt;\n \n-      if (dynamic_symbols == NULL)\n+      if (filedata->dynamic_symbols == NULL)\n \t{\n \t  error (_(\"conflict list found without a dynamic symbol table\\n\"));\n \t  return FALSE;\n@@ -17127,17 +17173,17 @@ process_mips_specific (Filedata * filedata)\n \t{\n \t  printf (\"%5lu: %8lu  \", (unsigned long) cnt, iconf[cnt]);\n \n-\t  if (iconf[cnt] >= num_dynamic_syms)\n+\t  if (iconf[cnt] >= filedata->num_dynamic_syms)\n \t    printf (_(\"<corrupt symbol index>\"));\n \t  else\n \t    {\n \t      Elf_Internal_Sym * psym;\n \n-\t      psym = & dynamic_symbols[iconf[cnt]];\n+\t      psym = & filedata->dynamic_symbols[iconf[cnt]];\n \t      print_vma (psym->st_value, FULL_HEX);\n \t      putchar (' ');\n-\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n-\t\tprint_symbol (25, GET_DYNAMIC_NAME (psym->st_name));\n+\t      if (VALID_DYNAMIC_NAME (filedata, psym->st_name))\n+\t\tprint_symbol (25, GET_DYNAMIC_NAME (filedata, psym->st_name));\n \t      else\n \t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n \t    }\n@@ -17250,19 +17296,20 @@ process_mips_specific (Filedata * filedata)\n \t      ent = print_mips_got_entry (data, pltgot, ent, data_end);\n \t      printf (\" \");\n \n-\t      if (dynamic_symbols == NULL)\n+\t      if (filedata->dynamic_symbols == NULL)\n \t\tprintf (_(\"<no dynamic symbols>\"));\n-\t      else if (i < num_dynamic_syms)\n+\t      else if (i < filedata->num_dynamic_syms)\n \t\t{\n-\t\t  Elf_Internal_Sym * psym = dynamic_symbols + i;\n+\t\t  Elf_Internal_Sym * psym = filedata->dynamic_symbols + i;\n \n \t\t  print_vma (psym->st_value, LONG_HEX);\n \t\t  printf (\" %-7s %3s \",\n \t\t\t  get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),\n \t\t\t  get_symbol_index_type (filedata, psym->st_shndx));\n \n-\t\t  if (VALID_DYNAMIC_NAME (psym->st_name))\n-\t\t    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n+\t\t  if (VALID_DYNAMIC_NAME (filedata, psym->st_name))\n+\t\t    print_symbol (sym_width,\n+\t\t\t\t  GET_DYNAMIC_NAME (filedata, psym->st_name));\n \t\t  else\n \t\t    printf (_(\"<corrupt: %14ld>\"), psym->st_name);\n \t\t}\n@@ -17336,18 +17383,19 @@ process_mips_specific (Filedata * filedata)\n \t  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);\n \t  printf (\" \");\n \n-\t  if (idx >= num_dynamic_syms)\n+\t  if (idx >= filedata->num_dynamic_syms)\n \t    printf (_(\"<corrupt symbol index: %lu>\"), idx);\n \t  else\n \t    {\n-\t      Elf_Internal_Sym * psym = dynamic_symbols + idx;\n+\t      Elf_Internal_Sym * psym = filedata->dynamic_symbols + idx;\n \n \t      print_vma (psym->st_value, LONG_HEX);\n \t      printf (\" %-7s %3s \",\n \t\t      get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),\n \t\t      get_symbol_index_type (filedata, psym->st_shndx));\n-\t      if (VALID_DYNAMIC_NAME (psym->st_name))\n-\t\tprint_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));\n+\t      if (VALID_DYNAMIC_NAME (filedata, psym->st_name))\n+\t\tprint_symbol (sym_width,\n+\t\t\t      GET_DYNAMIC_NAME (filedata, psym->st_name));\n \t      else\n \t\tprintf (_(\"<corrupt: %14ld>\"), psym->st_name);\n \t    }\n@@ -20073,13 +20121,13 @@ process_object (Filedata * filedata)\n     }\n \n   /* Initialise per file variables.  */\n-  for (i = ARRAY_SIZE (version_info); i--;)\n-    version_info[i] = 0;\n+  for (i = ARRAY_SIZE (filedata->version_info); i--;)\n+    filedata->version_info[i] = 0;\n \n-  for (i = ARRAY_SIZE (dynamic_info); i--;)\n-    dynamic_info[i] = 0;\n-  dynamic_info_DT_GNU_HASH = 0;\n-  dynamic_info_DT_MIPS_XHASH = 0;\n+  for (i = ARRAY_SIZE (filedata->dynamic_info); i--;)\n+    filedata->dynamic_info[i] = 0;\n+  filedata->dynamic_info_DT_GNU_HASH = 0;\n+  filedata->dynamic_info_DT_MIPS_XHASH = 0;\n \n   /* Process the file.  */\n   if (show_name)\n@@ -20189,61 +20237,61 @@ process_object (Filedata * filedata)\n       filedata->dump.num_dump_sects = 0;\n     }\n \n-  if (dynamic_strings)\n+  if (filedata->dynamic_strings)\n     {\n-      free (dynamic_strings);\n-      dynamic_strings = NULL;\n-      dynamic_strings_length = 0;\n+      free (filedata->dynamic_strings);\n+      filedata->dynamic_strings = NULL;\n+      filedata->dynamic_strings_length = 0;\n     }\n \n-  if (dynamic_symbols)\n+  if (filedata->dynamic_symbols)\n     {\n-      free (dynamic_symbols);\n-      dynamic_symbols = NULL;\n-      num_dynamic_syms = 0;\n+      free (filedata->dynamic_symbols);\n+      filedata->dynamic_symbols = NULL;\n+      filedata->num_dynamic_syms = 0;\n     }\n \n-  if (dynamic_syminfo)\n+  if (filedata->dynamic_syminfo)\n     {\n-      free (dynamic_syminfo);\n-      dynamic_syminfo = NULL;\n+      free (filedata->dynamic_syminfo);\n+      filedata->dynamic_syminfo = NULL;\n     }\n \n-  if (dynamic_section)\n+  if (filedata->dynamic_section)\n     {\n-      free (dynamic_section);\n-      dynamic_section = NULL;\n+      free (filedata->dynamic_section);\n+      filedata->dynamic_section = NULL;\n     }\n \n-  while (symtab_shndx_list != NULL)\n+  while (filedata->symtab_shndx_list != NULL)\n     {\n-      elf_section_list *next = symtab_shndx_list->next;\n-      free (symtab_shndx_list);\n-      symtab_shndx_list = next;\n+      elf_section_list *next = filedata->symtab_shndx_list->next;\n+      free (filedata->symtab_shndx_list);\n+      filedata->symtab_shndx_list = next;\n     }\n \n-  if (section_headers_groups)\n+  if (filedata->section_headers_groups)\n     {\n-      free (section_headers_groups);\n-      section_headers_groups = NULL;\n+      free (filedata->section_headers_groups);\n+      filedata->section_headers_groups = NULL;\n     }\n \n-  if (section_groups)\n+  if (filedata->section_groups)\n     {\n       struct group_list * g;\n       struct group_list * next;\n \n-      for (i = 0; i < group_count; i++)\n+      for (i = 0; i < filedata->group_count; i++)\n \t{\n-\t  for (g = section_groups [i].root; g != NULL; g = next)\n+\t  for (g = filedata->section_groups [i].root; g != NULL; g = next)\n \t    {\n \t      next = g->next;\n \t      free (g);\n \t    }\n \t}\n \n-      free (section_groups);\n-      section_groups = NULL;\n+      free (filedata->section_groups);\n+      filedata->section_groups = NULL;\n     }\n \n   free_debug_memory ();\n@@ -20421,9 +20469,9 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \n       arch.next_arhdr_offset += sizeof arch.arhdr;\n \n-      archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);\n-      if (archive_file_size & 01)\n-\t++archive_file_size;\n+      filedata->archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);\n+      if (filedata->archive_file_size & 01)\n+\t++filedata->archive_file_size;\n \n       name = get_archive_member_name (&arch, &nested_arch);\n       if (name == NULL)\n@@ -20468,7 +20516,7 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t      break;\n \t    }\n \n-\t  archive_file_offset = arch.nested_member_origin;\n+\t  filedata->archive_file_offset = arch.nested_member_origin;\n \t  member_filedata->file_name = qualified_name;\n \n \t  if (! process_object (member_filedata))\n@@ -20496,11 +20544,13 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n \t  free (name);\n \n \t  /* This is a proxy for a member of a nested archive.  */\n-\t  archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;\n+\t  filedata->archive_file_offset\n+\t    = arch.nested_member_origin + sizeof arch.arhdr;\n \n \t  /* The nested archive file will have been opened and setup by\n \t     get_archive_member_name.  */\n-\t  if (fseek (nested_arch.file, archive_file_offset, SEEK_SET) != 0)\n+\t  if (fseek (nested_arch.file, filedata->archive_file_offset,\n+\t\t     SEEK_SET) != 0)\n \t    {\n \t      error (_(\"%s: failed to seek to archive member.\\n\"),\n \t\t     nested_arch.file_name);\n@@ -20518,13 +20568,13 @@ process_archive (Filedata * filedata, bfd_boolean is_thin_archive)\n       else\n \t{\n \t  free (name);\n-\t  archive_file_offset = arch.next_arhdr_offset;\n+\t  filedata->archive_file_offset = arch.next_arhdr_offset;\n \t  filedata->file_name = qualified_name;\n \t  if (! process_object (filedata))\n \t    ret = FALSE;\n-\t  arch.next_arhdr_offset += archive_file_size;\n+\t  arch.next_arhdr_offset += filedata->archive_file_size;\n \t  /* Stop looping with \"negative\" archive_file_size.  */\n-\t  if (arch.next_arhdr_offset < archive_file_size)\n+\t  if (arch.next_arhdr_offset < filedata->archive_file_size)\n \t    arch.next_arhdr_offset = -1ul;\n \t}\n \n@@ -20607,7 +20657,7 @@ process_file (char * file_name)\n \t       file_name);\n \n       rewind (filedata->handle);\n-      archive_file_size = archive_file_offset = 0;\n+      filedata->archive_file_size = filedata->archive_file_offset = 0;\n \n       if (! process_object (filedata))\n \tret = FALSE;"
    }
  ]
}