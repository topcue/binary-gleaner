{
  "sha": "795588aec4f894206863c938bd6d716895886009",
  "node_id": "C_kwDOANOeidoAKDc5NTU4OGFlYzRmODk0MjA2ODYzYzkzOGJkNmQ3MTY4OTU4ODYwMDk",
  "commit": {
    "author": {
      "name": "Pekka Sepp\u00e4nen",
      "email": "pexu@sourceware.mail.kapsi.fi",
      "date": "2021-11-10T09:45:19Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-10T09:54:36Z"
    },
    "message": "PR28575, readelf.c and strings.c use undefined type uint\n\nSince --unicode support (commit b3aa80b45c4) both binutils/readelf.c\nand binutils/strings.c use 'uint' in a few locations.  It likely\nshould be 'unsigned int' since there isn't anything defining 'uint'\nwithin binutils (besides zlib) and AFAIK it isn't a standard type.\n\n\t* readelf.c (print_symbol): Replace uint with unsigned int.\n\t* strings.c (string_min, display_utf8_char): Likewise.\n\t(print_unicode_stream_body, print_unicode_stream): Likewise.\n\t(print_strings): Likewise.\n\t(get_unicode_byte): Wrap long line.",
    "tree": {
      "sha": "983279eda5cd402a479797577f37d5526426d5a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/983279eda5cd402a479797577f37d5526426d5a7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/795588aec4f894206863c938bd6d716895886009",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/795588aec4f894206863c938bd6d716895886009",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/795588aec4f894206863c938bd6d716895886009",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/795588aec4f894206863c938bd6d716895886009/comments",
  "author": null,
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b030ae091e65aba97e511fa9c9bb80c77cdeabad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b030ae091e65aba97e511fa9c9bb80c77cdeabad",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b030ae091e65aba97e511fa9c9bb80c77cdeabad"
    }
  ],
  "stats": {
    "total": 45,
    "additions": 24,
    "deletions": 21
  },
  "files": [
    {
      "sha": "5a87728d3e9874d4e9ef2f11f87590cd99e2a776",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/795588aec4f894206863c938bd6d716895886009/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/795588aec4f894206863c938bd6d716895886009/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=795588aec4f894206863c938bd6d716895886009",
      "patch": "@@ -702,7 +702,7 @@ print_symbol (signed int width, const char * symbol)\n \t  /* Display unicode characters as something else.  */\n \t  unsigned char bytes[4];\n \t  bool          is_utf8;\n-\t  uint          nbytes;\n+\t  unsigned int  nbytes;\n \n \t  bytes[0] = c;\n \n@@ -767,7 +767,7 @@ print_symbol (signed int width, const char * symbol)\n \n \t  if (unicode_display == unicode_hex || ! is_utf8)\n \t    {\n-\t      uint i;\n+\t      unsigned int i;\n \n \t      if (width_remaining < (nbytes * 2) + 2)\n \t\tbreak;"
    },
    {
      "sha": "13db60f57a57ceed9c021af06c504dd72493c86a",
      "filename": "binutils/strings.c",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/795588aec4f894206863c938bd6d716895886009/binutils/strings.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/795588aec4f894206863c938bd6d716895886009/binutils/strings.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/strings.c?ref=795588aec4f894206863c938bd6d716895886009",
      "patch": "@@ -57,7 +57,7 @@\n \n   --unicode={default|locale|invalid|hex|escape|highlight}\n   -u {d|l|i|x|e|h}\n-                Determine how to handle UTF-8 unicode characters.  The default\n+\t\tDetermine how to handle UTF-8 unicode characters.  The default\n \t\tis no special treatment.  All other versions of this option\n \t\tonly apply if the encoding is valid and enabling the option\n \t\timplies --encoding=S.\n@@ -123,7 +123,7 @@ extern int errno;\n static int address_radix;\n \n /* Minimum length of sequence of graphic chars to trigger output.  */\n-static uint string_min;\n+static unsigned int string_min;\n \n /* Whether or not we include all whitespace as a graphic char.   */\n static bool include_all_whitespace;\n@@ -272,7 +272,7 @@ main (int argc, char **argv)\n \n \tcase 's':\n \t  output_separator = optarg;\n-          break;\n+\t  break;\n \n \tcase 'U':\n \t  if (streq (optarg, \"default\") || streq (optarg, \"d\"))\n@@ -677,7 +677,7 @@ is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)\n \n   if ((buffer[2] & 0xc0) != 0x80)\n     return 0;\n-  \n+\n   if ((buffer[0] & 0x10) == 0)\n     return 3;\n \n@@ -694,11 +694,11 @@ is_valid_utf8 (const unsigned char * buffer, unsigned long buflen)\n    of unicode_display.  The character is known to be valid.\n    Returns the number of bytes consumed.  */\n \n-static uint\n+static unsigned int\n display_utf8_char (const unsigned char * buffer)\n {\n-  uint j;\n-  uint utf8_len;\n+  unsigned int j;\n+  unsigned int utf8_len;\n \n   switch (buffer[0] & 0x30)\n     {\n@@ -712,7 +712,7 @@ display_utf8_char (const unsigned char * buffer)\n     default:\n       utf8_len = 4;\n     }\n-      \n+\n   switch (unicode_display)\n     {\n     default:\n@@ -728,7 +728,7 @@ display_utf8_char (const unsigned char * buffer)\n \t{\n \tcase 2:\n \t  printf (\"\\\\u%02x%02x\",\n-\t\t  ((buffer[0] & 0x1c) >> 2), \n+\t\t  ((buffer[0] & 0x1c) >> 2),\n \t\t  ((buffer[0] & 0x03) << 6) | (buffer[1] & 0x3f));\n \t  break;\n \n@@ -857,7 +857,7 @@ print_unicode_buffer (const char *            filename,\n     return;\n \n   print_filename_and_address (filename, address + start_point);\n-  \n+\n   /* We have found string_min characters.  Display them and any\n      more that follow.  */\n   for (i = start_point; i < buflen; i += char_len)\n@@ -888,7 +888,10 @@ print_unicode_buffer (const char *            filename,\n }\n \n static int\n-get_unicode_byte (FILE * stream, unsigned char * putback, uint * num_putback, uint * num_read)\n+get_unicode_byte (FILE *          stream,\n+\t\t  unsigned char * putback,\n+\t\t  unsigned int *  num_putback,\n+\t\t  unsigned int *  num_read)\n {\n   if (* num_putback > 0)\n     {\n@@ -912,7 +915,7 @@ print_unicode_stream_body (const char *     filename,\n \t\t\t   file_ptr         address,\n \t\t\t   FILE *           stream,\n \t\t\t   unsigned char *  putback_buf,\n-\t\t\t   uint             num_putback,\n+\t\t\t   unsigned int     num_putback,\n \t\t\t   unsigned char *  print_buf)\n {\n   /* It would be nice if we could just read the stream into a buffer\n@@ -921,9 +924,9 @@ print_unicode_stream_body (const char *     filename,\n      we go one byte at a time...  */\n \n   file_ptr start_point = 0;\n-  uint num_read = 0;\n-  uint num_chars = 0;\n-  uint num_print = 0;\n+  unsigned int num_read = 0;\n+  unsigned int num_chars = 0;\n+  unsigned int num_print = 0;\n   int c = 0;\n \n   /* Find a series of string_min characters.  Put them into print_buf.  */\n@@ -1064,7 +1067,7 @@ print_unicode_stream_body (const char *     filename,\n \n       print_filename_and_address (filename, address + start_point);\n \n-      uint i;\n+      unsigned int i;\n       for (i = 0; i < num_print;)\n \t{\n \t  if (print_buf[i] < 127)\n@@ -1075,7 +1078,7 @@ print_unicode_stream_body (const char *     filename,\n \n       /* OK so now we have to start read unchecked bytes.  */\n \n-        /* Find a series of string_min characters.  Put them into print_buf.  */\n+      /* Find a series of string_min characters.  Put them into print_buf.  */\n       do\n \t{\n \t  c = get_unicode_byte (stream, putback_buf, & num_putback, & num_read);\n@@ -1213,7 +1216,7 @@ print_unicode_stream (const char * filename,\n   unsigned char * print_buf = xmalloc ((4 * string_min) + 1);\n   /* We should never have to put back more than 4 bytes.  */\n   unsigned char putback_buf[5];\n-  uint num_putback = 0;\n+  unsigned int num_putback = 0;\n \n   print_unicode_stream_body (filename, address, stream, putback_buf, num_putback, print_buf);\n   free (print_buf);\n@@ -1250,7 +1253,7 @@ print_strings (const char *filename, FILE *stream, file_ptr address,\n   while (1)\n     {\n       file_ptr start;\n-      uint i;\n+      unsigned int i;\n       long c;\n \n       /* See if the next `string_min' chars are all graphic chars.  */"
    }
  ]
}