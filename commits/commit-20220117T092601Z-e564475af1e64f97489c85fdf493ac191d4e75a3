{
  "sha": "e564475af1e64f97489c85fdf493ac191d4e75a3",
  "node_id": "C_kwDOANOeidoAKGU1NjQ0NzVhZjFlNjRmOTc0ODljODVmZGY0OTNhYzE5MWQ0ZTc1YTM",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2022-01-17T09:26:01Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2022-01-17T09:26:01Z"
    },
    "message": "x86: drop most Intel syntax register name arrays\n\nBy making use of, in particular, oappend_maybe_intel() there's no need\nfor this redundant set of static data.",
    "tree": {
      "sha": "065da36b5529d5d1859036fed9ce915237dfaf07",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/065da36b5529d5d1859036fed9ce915237dfaf07"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e564475af1e64f97489c85fdf493ac191d4e75a3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e564475af1e64f97489c85fdf493ac191d4e75a3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e564475af1e64f97489c85fdf493ac191d4e75a3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e564475af1e64f97489c85fdf493ac191d4e75a3/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e1f9fbb8adbbf8c46cad1e62e0d335ada1c3d308",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e1f9fbb8adbbf8c46cad1e62e0d335ada1c3d308",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e1f9fbb8adbbf8c46cad1e62e0d335ada1c3d308"
    }
  ],
  "stats": {
    "total": 349,
    "additions": 119,
    "deletions": 230
  },
  "files": [
    {
      "sha": "c2924ef27e6bce7e4d39a9261d512a943ed8ce6b",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 119,
      "deletions": 230,
      "changes": 349,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e564475af1e64f97489c85fdf493ac191d4e75a3/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e564475af1e64f97489c85fdf493ac191d4e75a3/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=e564475af1e64f97489c85fdf493ac191d4e75a3",
      "patch": "@@ -219,22 +219,7 @@ struct instr_info\n   vex;\n   unsigned char need_vex;\n \n-  const char *const *names64;\n-  const char *const *names32;\n-  const char *const *names16;\n-  const char *const *names8;\n-  const char *const *names8rex;\n-  const char *const *names_seg;\n-  const char *index64;\n-  const char *index32;\n   const char *const *index16;\n-  const char *const *names_bnd;\n-  const char *const *names_mm;\n-  const char *const *names_xmm;\n-  const char *const *names_ymm;\n-  const char *const *names_zmm;\n-  const char *const *names_tmm;\n-  const char *const *names_mask;\n \n   /* Remember if the current op is a jump instruction.  */\n   bool op_is_jump;\n@@ -2423,30 +2408,6 @@ struct op\n    need to update onebyte_has_modrm or twobyte_has_modrm.  */\n #define MODRM_CHECK  if (!ins->need_modrm) abort ()\n \n-static const char *const intel_names64[] = {\n-  \"rax\", \"rcx\", \"rdx\", \"rbx\", \"rsp\", \"rbp\", \"rsi\", \"rdi\",\n-  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\"\n-};\n-static const char *const intel_names32[] = {\n-  \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\",\n-  \"r8d\", \"r9d\", \"r10d\", \"r11d\", \"r12d\", \"r13d\", \"r14d\", \"r15d\"\n-};\n-static const char *const intel_names16[] = {\n-  \"ax\", \"cx\", \"dx\", \"bx\", \"sp\", \"bp\", \"si\", \"di\",\n-  \"r8w\", \"r9w\", \"r10w\", \"r11w\", \"r12w\", \"r13w\", \"r14w\", \"r15w\"\n-};\n-static const char *const intel_names8[] = {\n-  \"al\", \"cl\", \"dl\", \"bl\", \"ah\", \"ch\", \"dh\", \"bh\",\n-};\n-static const char *const intel_names8rex[] = {\n-  \"al\", \"cl\", \"dl\", \"bl\", \"spl\", \"bpl\", \"sil\", \"dil\",\n-  \"r8b\", \"r9b\", \"r10b\", \"r11b\", \"r12b\", \"r13b\", \"r14b\", \"r15b\"\n-};\n-static const char *const intel_names_seg[] = {\n-  \"es\", \"cs\", \"ss\", \"ds\", \"fs\", \"gs\", \"?\", \"?\",\n-};\n-static const char intel_index64[] = \"riz\";\n-static const char intel_index32[] = \"eiz\";\n static const char *const intel_index16[] = {\n   \"bx+si\", \"bx+di\", \"bp+si\", \"bp+di\", \"si\", \"di\", \"bp\", \"bx\"\n };\n@@ -2479,33 +2440,15 @@ static const char *const att_index16[] = {\n   \"%bx,%si\", \"%bx,%di\", \"%bp,%si\", \"%bp,%di\", \"%si\", \"%di\", \"%bp\", \"%bx\"\n };\n \n-static const char *const intel_names_mm[] = {\n-  \"mm0\", \"mm1\", \"mm2\", \"mm3\",\n-  \"mm4\", \"mm5\", \"mm6\", \"mm7\"\n-};\n static const char *const att_names_mm[] = {\n   \"%mm0\", \"%mm1\", \"%mm2\", \"%mm3\",\n   \"%mm4\", \"%mm5\", \"%mm6\", \"%mm7\"\n };\n \n-static const char *const intel_names_bnd[] = {\n-  \"bnd0\", \"bnd1\", \"bnd2\", \"bnd3\"\n-};\n-\n static const char *const att_names_bnd[] = {\n   \"%bnd0\", \"%bnd1\", \"%bnd2\", \"%bnd3\"\n };\n \n-static const char *const intel_names_xmm[] = {\n-  \"xmm0\", \"xmm1\", \"xmm2\", \"xmm3\",\n-  \"xmm4\", \"xmm5\", \"xmm6\", \"xmm7\",\n-  \"xmm8\", \"xmm9\", \"xmm10\", \"xmm11\",\n-  \"xmm12\", \"xmm13\", \"xmm14\", \"xmm15\",\n-  \"xmm16\", \"xmm17\", \"xmm18\", \"xmm19\",\n-  \"xmm20\", \"xmm21\", \"xmm22\", \"xmm23\",\n-  \"xmm24\", \"xmm25\", \"xmm26\", \"xmm27\",\n-  \"xmm28\", \"xmm29\", \"xmm30\", \"xmm31\"\n-};\n static const char *const att_names_xmm[] = {\n   \"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n   \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\",\n@@ -2517,16 +2460,6 @@ static const char *const att_names_xmm[] = {\n   \"%xmm28\", \"%xmm29\", \"%xmm30\", \"%xmm31\"\n };\n \n-static const char *const intel_names_ymm[] = {\n-  \"ymm0\", \"ymm1\", \"ymm2\", \"ymm3\",\n-  \"ymm4\", \"ymm5\", \"ymm6\", \"ymm7\",\n-  \"ymm8\", \"ymm9\", \"ymm10\", \"ymm11\",\n-  \"ymm12\", \"ymm13\", \"ymm14\", \"ymm15\",\n-  \"ymm16\", \"ymm17\", \"ymm18\", \"ymm19\",\n-  \"ymm20\", \"ymm21\", \"ymm22\", \"ymm23\",\n-  \"ymm24\", \"ymm25\", \"ymm26\", \"ymm27\",\n-  \"ymm28\", \"ymm29\", \"ymm30\", \"ymm31\"\n-};\n static const char *const att_names_ymm[] = {\n   \"%ymm0\", \"%ymm1\", \"%ymm2\", \"%ymm3\",\n   \"%ymm4\", \"%ymm5\", \"%ymm6\", \"%ymm7\",\n@@ -2538,16 +2471,6 @@ static const char *const att_names_ymm[] = {\n   \"%ymm28\", \"%ymm29\", \"%ymm30\", \"%ymm31\"\n };\n \n-static const char *const intel_names_zmm[] = {\n-  \"zmm0\", \"zmm1\", \"zmm2\", \"zmm3\",\n-  \"zmm4\", \"zmm5\", \"zmm6\", \"zmm7\",\n-  \"zmm8\", \"zmm9\", \"zmm10\", \"zmm11\",\n-  \"zmm12\", \"zmm13\", \"zmm14\", \"zmm15\",\n-  \"zmm16\", \"zmm17\", \"zmm18\", \"zmm19\",\n-  \"zmm20\", \"zmm21\", \"zmm22\", \"zmm23\",\n-  \"zmm24\", \"zmm25\", \"zmm26\", \"zmm27\",\n-  \"zmm28\", \"zmm29\", \"zmm30\", \"zmm31\"\n-};\n static const char *const att_names_zmm[] = {\n   \"%zmm0\", \"%zmm1\", \"%zmm2\", \"%zmm3\",\n   \"%zmm4\", \"%zmm5\", \"%zmm6\", \"%zmm7\",\n@@ -2559,18 +2482,11 @@ static const char *const att_names_zmm[] = {\n   \"%zmm28\", \"%zmm29\", \"%zmm30\", \"%zmm31\"\n };\n \n-static const char *const intel_names_tmm[] = {\n-  \"tmm0\", \"tmm1\", \"tmm2\", \"tmm3\",\n-  \"tmm4\", \"tmm5\", \"tmm6\", \"tmm7\"\n-};\n static const char *const att_names_tmm[] = {\n   \"%tmm0\", \"%tmm1\", \"%tmm2\", \"%tmm3\",\n   \"%tmm4\", \"%tmm5\", \"%tmm6\", \"%tmm7\"\n };\n \n-static const char *const intel_names_mask[] = {\n-  \"k0\", \"k1\", \"k2\", \"k3\", \"k4\", \"k5\", \"k6\", \"k7\"\n-};\n static const char *const att_names_mask[] = {\n   \"%k0\", \"%k1\", \"%k2\", \"%k3\", \"%k4\", \"%k5\", \"%k6\", \"%k7\"\n };\n@@ -9377,6 +9293,14 @@ get_sib (instr_info *ins, int sizeflag)\n     }\n }\n \n+/* Like oappend (below), but S is a string starting with '%'.\n+   In Intel syntax, the '%' is elided.  */\n+static void\n+oappend_maybe_intel (instr_info *ins, const char *s)\n+{\n+  oappend (ins, s + ins->intel_syntax);\n+}\n+\n static int\n print_insn (bfd_vma pc, instr_info *ins)\n {\n@@ -9480,21 +9404,6 @@ print_insn (bfd_vma pc, instr_info *ins)\n \n   if (ins->intel_syntax)\n     {\n-      ins->names64 = intel_names64;\n-      ins->names32 = intel_names32;\n-      ins->names16 = intel_names16;\n-      ins->names8 = intel_names8;\n-      ins->names8rex = intel_names8rex;\n-      ins->names_seg = intel_names_seg;\n-      ins->names_mm = intel_names_mm;\n-      ins->names_bnd = intel_names_bnd;\n-      ins->names_xmm = intel_names_xmm;\n-      ins->names_ymm = intel_names_ymm;\n-      ins->names_zmm = intel_names_zmm;\n-      ins->names_tmm = intel_names_tmm;\n-      ins->index64 = intel_index64;\n-      ins->index32 = intel_index32;\n-      ins->names_mask = intel_names_mask;\n       ins->index16 = intel_index16;\n       ins->open_char = '[';\n       ins->close_char = ']';\n@@ -9503,21 +9412,6 @@ print_insn (bfd_vma pc, instr_info *ins)\n     }\n   else\n     {\n-      ins->names64 = att_names64;\n-      ins->names32 = att_names32;\n-      ins->names16 = att_names16;\n-      ins->names8 = att_names8;\n-      ins->names8rex = att_names8rex;\n-      ins->names_seg = att_names_seg;\n-      ins->names_mm = att_names_mm;\n-      ins->names_bnd = att_names_bnd;\n-      ins->names_xmm = att_names_xmm;\n-      ins->names_ymm = att_names_ymm;\n-      ins->names_zmm = att_names_zmm;\n-      ins->names_tmm = att_names_tmm;\n-      ins->index64 = att_index64;\n-      ins->index32 = att_index32;\n-      ins->names_mask = att_names_mask;\n       ins->index16 = att_index16;\n       ins->open_char = '(';\n       ins->close_char =  ')';\n@@ -9673,8 +9567,9 @@ print_insn (bfd_vma pc, instr_info *ins)\n \t\t  if (ins->vex.mask_register_specifier)\n \t\t    {\n \t\t      oappend (ins, \"{\");\n-\t\t      oappend (ins,\n-\t\t\t     ins->names_mask[ins->vex.mask_register_specifier]);\n+\t\t      oappend_maybe_intel (ins,\n+\t\t\t\t\t   att_names_mask\n+\t\t\t\t\t   [ins->vex.mask_register_specifier]);\n \t\t      oappend (ins, \"}\");\n \t\t    }\n \t\t  if (ins->vex.zeroing)\n@@ -10285,7 +10180,7 @@ dofloat (instr_info *ins, int sizeflag)\n \n       /* Instruction fnstsw is only one with strange arg.  */\n       if (floatop == 0xdf && ins->codep[-1] == 0xe0)\n-\tstrcpy (ins->op_out[0], ins->names16[0]);\n+\tstrcpy (ins->op_out[0], att_names16[0] + ins->intel_syntax);\n     }\n   else\n     {\n@@ -10303,14 +10198,6 @@ dofloat (instr_info *ins, int sizeflag)\n     }\n }\n \n-/* Like oappend (below), but S is a string starting with '%'.\n-   In Intel syntax, the '%' is elided.  */\n-static void\n-oappend_maybe_intel (instr_info *ins, const char *s)\n-{\n-  oappend (ins, s + ins->intel_syntax);\n-}\n-\n static void\n OP_ST (instr_info *ins, int bytemode ATTRIBUTE_UNUSED,\n        int sizeflag ATTRIBUTE_UNUSED)\n@@ -11296,24 +11183,24 @@ print_register (instr_info *ins, unsigned int reg, unsigned int rexmask,\n       if (reg & 4)\n \tUSED_REX (0);\n       if (ins->rex)\n-\tnames = ins->names8rex;\n+\tnames = att_names8rex;\n       else\n-\tnames = ins->names8;\n+\tnames = att_names8;\n       break;\n     case w_mode:\n-      names = ins->names16;\n+      names = att_names16;\n       break;\n     case d_mode:\n     case dw_mode:\n     case db_mode:\n-      names = ins->names32;\n+      names = att_names32;\n       break;\n     case q_mode:\n-      names = ins->names64;\n+      names = att_names64;\n       break;\n     case m_mode:\n     case v_bnd_mode:\n-      names = ins->address_mode == mode_64bit ? ins->names64 : ins->names32;\n+      names = ins->address_mode == mode_64bit ? att_names64 : att_names32;\n       break;\n     case bnd_mode:\n     case bnd_swap_mode:\n@@ -11322,20 +11209,20 @@ print_register (instr_info *ins, unsigned int reg, unsigned int rexmask,\n \t  oappend (ins, \"(bad)\");\n \t  return;\n \t}\n-      names = ins->names_bnd;\n+      names = att_names_bnd;\n       break;\n     case indir_v_mode:\n       if (ins->address_mode == mode_64bit && ins->isa64 == intel64)\n \t{\n-\t  names = ins->names64;\n+\t  names = att_names64;\n \t  break;\n \t}\n       /* Fall through.  */\n     case stack_v_mode:\n       if (ins->address_mode == mode_64bit && ((sizeflag & DFLAG)\n \t\t\t\t\t      || (ins->rex & REX_W)))\n \t{\n-\t  names = ins->names64;\n+\t  names = att_names64;\n \t  break;\n \t}\n       bytemode = v_mode;\n@@ -11345,37 +11232,37 @@ print_register (instr_info *ins, unsigned int reg, unsigned int rexmask,\n     case dq_mode:\n       USED_REX (REX_W);\n       if (ins->rex & REX_W)\n-\tnames = ins->names64;\n+\tnames = att_names64;\n       else if (bytemode != v_mode && bytemode != v_swap_mode)\n-\tnames = ins->names32;\n+\tnames = att_names32;\n       else\n \t{\n \t  if (sizeflag & DFLAG)\n-\t    names = ins->names32;\n+\t    names = att_names32;\n \t  else\n-\t    names = ins->names16;\n+\t    names = att_names16;\n \t  ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n \t}\n       break;\n     case movsxd_mode:\n       if (!(sizeflag & DFLAG) && ins->isa64 == intel64)\n-\tnames = ins->names16;\n+\tnames = att_names16;\n       else\n-\tnames = ins->names32;\n+\tnames = att_names32;\n       ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n       break;\n     case va_mode:\n       names = (ins->address_mode == mode_64bit\n-\t       ? ins->names64 : ins->names32);\n+\t       ? att_names64 : att_names32);\n       if (!(ins->prefixes & PREFIX_ADDR))\n \tnames = (ins->address_mode == mode_16bit\n-\t\t     ? ins->names16 : names);\n+\t\t     ? att_names16 : names);\n       else\n \t{\n \t  /* Remove \"addr16/addr32\".  */\n \t  ins->all_prefixes[ins->last_addr_prefix] = 0;\n \t  names = (ins->address_mode != mode_32bit\n-\t\t       ? ins->names32 : ins->names16);\n+\t\t       ? att_names32 : att_names16);\n \t  ins->used_prefixes |= PREFIX_ADDR;\n \t}\n       break;\n@@ -11386,15 +11273,15 @@ print_register (instr_info *ins, unsigned int reg, unsigned int rexmask,\n \t  oappend (ins, \"(bad)\");\n \t  return;\n \t}\n-      names = ins->names_mask;\n+      names = att_names_mask;\n       break;\n     case 0:\n       return;\n     default:\n       oappend (ins, INTERNAL_DISASSEMBLER_ERROR);\n       return;\n     }\n-  oappend (ins, names[reg]);\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n static void\n@@ -11687,8 +11574,9 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t    }\n \t  *ins->obufp = '\\0';\n \t  if (havebase)\n-\t    oappend (ins, ins->address_mode == mode_64bit && !addr32flag\n-\t\t     ? ins->names64[rbase] : ins->names32[rbase]);\n+\t    oappend_maybe_intel (ins,\n+\t\t\t\t (ins->address_mode == mode_64bit && !addr32flag\n+\t\t\t\t  ? att_names64 : att_names32)[rbase]);\n \t  if (havesib)\n \t    {\n \t      /* ESP/RSP won't allow index.  If base isn't ESP/RSP,\n@@ -11711,8 +11599,10 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t\t\toappend (ins, \"(bad)\");\n \t\t    }\n \t\t  else\n-\t\t    oappend (ins, ins->address_mode == mode_64bit && !addr32flag\n-\t\t\t     ? ins->index64 : ins->index32);\n+\t\t    oappend_maybe_intel (ins,\n+\t\t\t\t\t ins->address_mode == mode_64bit\n+\t\t\t\t\t && !addr32flag ? att_index64\n+\t\t\t\t\t\t\t: att_index32);\n \n \t\t  *ins->obufp++ = ins->scale_char;\n \t\t  *ins->obufp = '\\0';\n@@ -11764,7 +11654,7 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t    {\n \t      if (!ins->active_seg_prefix)\n \t\t{\n-\t\t  oappend (ins, ins->names_seg[ds_reg - es_reg]);\n+\t\t  oappend_maybe_intel (ins, att_names_seg[ds_reg - es_reg]);\n \t\t  oappend (ins, \":\");\n \t\t}\n \t      print_operand_value (ins, ins->scratchbuf, 1, disp);\n@@ -11849,7 +11739,7 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t{\n \t  if (!ins->active_seg_prefix)\n \t    {\n-\t      oappend (ins, ins->names_seg[ds_reg - es_reg]);\n+\t      oappend_maybe_intel (ins, att_names_seg[ds_reg - es_reg]);\n \t      oappend (ins, \":\");\n \t    }\n \t  print_operand_value (ins, ins->scratchbuf, 1, disp & 0xffff);\n@@ -12065,7 +11955,7 @@ OP_REG (instr_info *ins, int code, int sizeflag)\n     {\n     case es_reg: case ss_reg: case cs_reg:\n     case ds_reg: case fs_reg: case gs_reg:\n-      oappend (ins, ins->names_seg[code - es_reg]);\n+      oappend_maybe_intel (ins, att_names_seg[code - es_reg]);\n       return;\n     }\n \n@@ -12079,23 +11969,23 @@ OP_REG (instr_info *ins, int code, int sizeflag)\n     {\n     case ax_reg: case cx_reg: case dx_reg: case bx_reg:\n     case sp_reg: case bp_reg: case si_reg: case di_reg:\n-      s = ins->names16[code - ax_reg + add];\n+      s = att_names16[code - ax_reg + add];\n       break;\n     case ah_reg: case ch_reg: case dh_reg: case bh_reg:\n       USED_REX (0);\n       /* Fall through.  */\n     case al_reg: case cl_reg: case dl_reg: case bl_reg:\n       if (ins->rex)\n-\ts = ins->names8rex[code - al_reg + add];\n+\ts = att_names8rex[code - al_reg + add];\n       else\n-\ts = ins->names8[code - al_reg];\n+\ts = att_names8[code - al_reg];\n       break;\n     case rAX_reg: case rCX_reg: case rDX_reg: case rBX_reg:\n     case rSP_reg: case rBP_reg: case rSI_reg: case rDI_reg:\n       if (ins->address_mode == mode_64bit\n \t  && ((sizeflag & DFLAG) || (ins->rex & REX_W)))\n \t{\n-\t  s = ins->names64[code - rAX_reg + add];\n+\t  s = att_names64[code - rAX_reg + add];\n \t  break;\n \t}\n       code += eAX_reg - rAX_reg;\n@@ -12104,21 +11994,21 @@ OP_REG (instr_info *ins, int code, int sizeflag)\n     case eSP_reg: case eBP_reg: case eSI_reg: case eDI_reg:\n       USED_REX (REX_W);\n       if (ins->rex & REX_W)\n-\ts = ins->names64[code - eAX_reg + add];\n+\ts = att_names64[code - eAX_reg + add];\n       else\n \t{\n \t  if (sizeflag & DFLAG)\n-\t    s = ins->names32[code - eAX_reg + add];\n+\t    s = att_names32[code - eAX_reg + add];\n \t  else\n-\t    s = ins->names16[code - eAX_reg + add];\n+\t    s = att_names16[code - eAX_reg + add];\n \t  ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n \t}\n       break;\n     default:\n-      s = INTERNAL_DISASSEMBLER_ERROR;\n-      break;\n+      oappend (ins, INTERNAL_DISASSEMBLER_ERROR);\n+      return;\n     }\n-  oappend (ins, s);\n+  oappend_maybe_intel (ins, s);\n }\n \n static void\n@@ -12129,35 +12019,37 @@ OP_IMREG (instr_info *ins, int code, int sizeflag)\n   switch (code)\n     {\n     case indir_dx_reg:\n-      if (ins->intel_syntax)\n-\ts = \"dx\";\n-      else\n-\ts = \"(%dx)\";\n+      if (!ins->intel_syntax)\n+\t{\n+\t  oappend (ins, \"(%dx)\");\n+\t  return;\n+\t}\n+      s = att_names16[dx_reg - ax_reg];\n       break;\n     case al_reg: case cl_reg:\n-      s = ins->names8[code - al_reg];\n+      s = att_names8[code - al_reg];\n       break;\n     case eAX_reg:\n       USED_REX (REX_W);\n       if (ins->rex & REX_W)\n \t{\n-\t  s = *ins->names64;\n+\t  s = *att_names64;\n \t  break;\n \t}\n       /* Fall through.  */\n     case z_mode_ax_reg:\n       if ((ins->rex & REX_W) || (sizeflag & DFLAG))\n-\ts = *ins->names32;\n+\ts = *att_names32;\n       else\n-\ts = *ins->names16;\n+\ts = *att_names16;\n       if (!(ins->rex & REX_W))\n \tins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n       break;\n     default:\n-      s = INTERNAL_DISASSEMBLER_ERROR;\n-      break;\n+      oappend (ins, INTERNAL_DISASSEMBLER_ERROR);\n+      return;\n     }\n-  oappend (ins, s);\n+  oappend_maybe_intel (ins, s);\n }\n \n static void\n@@ -12342,7 +12234,7 @@ static void\n OP_SEG (instr_info *ins, int bytemode, int sizeflag)\n {\n   if (bytemode == w_mode)\n-    oappend (ins, ins->names_seg[ins->modrm.reg]);\n+    oappend_maybe_intel (ins, att_names_seg[ins->modrm.reg]);\n   else\n     OP_E (ins, ins->modrm.mod == 3 ? bytemode : w_mode, sizeflag);\n }\n@@ -12388,7 +12280,7 @@ OP_OFF (instr_info *ins, int bytemode, int sizeflag)\n     {\n       if (!ins->active_seg_prefix)\n \t{\n-\t  oappend (ins, ins->names_seg[ds_reg - es_reg]);\n+\t  oappend_maybe_intel (ins, att_names_seg[ds_reg - es_reg]);\n \t  oappend (ins, \":\");\n \t}\n     }\n@@ -12418,7 +12310,7 @@ OP_OFF64 (instr_info *ins, int bytemode, int sizeflag)\n     {\n       if (!ins->active_seg_prefix)\n \t{\n-\t  oappend (ins, ins->names_seg[ds_reg - es_reg]);\n+\t  oappend_maybe_intel (ins, att_names_seg[ds_reg - es_reg]);\n \t  oappend (ins, \":\");\n \t}\n     }\n@@ -12436,15 +12328,15 @@ ptr_reg (instr_info *ins, int code, int sizeflag)\n   if (ins->address_mode == mode_64bit)\n     {\n       if (!(sizeflag & AFLAG))\n-\ts = ins->names32[code - eAX_reg];\n+\ts = att_names32[code - eAX_reg];\n       else\n-\ts = ins->names64[code - eAX_reg];\n+\ts = att_names64[code - eAX_reg];\n     }\n   else if (sizeflag & AFLAG)\n-    s = ins->names32[code - eAX_reg];\n+    s = att_names32[code - eAX_reg];\n   else\n-    s = ins->names16[code - eAX_reg];\n-  oappend (ins, s);\n+    s = att_names16[code - eAX_reg];\n+  oappend_maybe_intel (ins, s);\n   *ins->obufp++ = ins->close_char;\n   *ins->obufp = 0;\n }\n@@ -12557,14 +12449,14 @@ OP_MMX (instr_info *ins, int bytemode ATTRIBUTE_UNUSED,\n   ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n   if (ins->prefixes & PREFIX_DATA)\n     {\n-      names = ins->names_xmm;\n+      names = att_names_xmm;\n       USED_REX (REX_R);\n       if (ins->rex & REX_R)\n \treg += 8;\n     }\n   else\n-    names = ins->names_mm;\n-  oappend (ins, names[reg]);\n+    names = att_names_mm;\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n static void\n@@ -12580,25 +12472,25 @@ print_vector_reg (instr_info *ins, unsigned int reg, int bytemode)\n \t{\n \tcase 128:\n \tcase 256:\n-\t  names = ins->names_xmm;\n+\t  names = att_names_xmm;\n \t  break;\n \tcase 512:\n-\t  names = ins->names_ymm;\n+\t  names = att_names_ymm;\n \t  break;\n \tdefault:\n \t  abort ();\n \t}\n     }\n   else if (bytemode == ymm_mode)\n-    names = ins->names_ymm;\n+    names = att_names_ymm;\n   else if (bytemode == tmm_mode)\n     {\n       if (reg >= 8)\n \t{\n \t  oappend (ins, \"(bad)\");\n \t  return;\n \t}\n-      names = ins->names_tmm;\n+      names = att_names_tmm;\n     }\n   else if (ins->need_vex\n \t   && bytemode != xmm_mode\n@@ -12615,29 +12507,29 @@ print_vector_reg (instr_info *ins, unsigned int reg, int bytemode)\n       switch (ins->vex.length)\n \t{\n \tcase 128:\n-\t  names = ins->names_xmm;\n+\t  names = att_names_xmm;\n \t  break;\n \tcase 256:\n \t  if (ins->vex.w\n \t      || bytemode != vex_vsib_q_w_dq_mode)\n-\t    names = ins->names_ymm;\n+\t    names = att_names_ymm;\n \t  else\n-\t    names = ins->names_xmm;\n+\t    names = att_names_xmm;\n \t  break;\n \tcase 512:\n \t  if (ins->vex.w\n \t      || bytemode != vex_vsib_q_w_dq_mode)\n-\t    names = ins->names_zmm;\n+\t    names = att_names_zmm;\n \t  else\n-\t    names = ins->names_ymm;\n+\t    names = att_names_ymm;\n \t  break;\n \tdefault:\n \t  abort ();\n \t}\n     }\n   else\n-    names = ins->names_xmm;\n-  oappend (ins, names[reg]);\n+    names = att_names_xmm;\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n static void\n@@ -12690,14 +12582,14 @@ OP_EM (instr_info *ins, int bytemode, int sizeflag)\n   reg = ins->modrm.rm;\n   if (ins->prefixes & PREFIX_DATA)\n     {\n-      names = ins->names_xmm;\n+      names = att_names_xmm;\n       USED_REX (REX_B);\n       if (ins->rex & REX_B)\n \treg += 8;\n     }\n   else\n-    names = ins->names_mm;\n-  oappend (ins, names[reg]);\n+    names = att_names_mm;\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n /* cvt* are the only instructions in sse2 which have\n@@ -12723,15 +12615,15 @@ OP_EMC (instr_info *ins, int bytemode, int sizeflag)\n   MODRM_CHECK;\n   ins->codep++;\n   ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n-  oappend (ins, ins->names_mm[ins->modrm.rm]);\n+  oappend_maybe_intel (ins, att_names_mm[ins->modrm.rm]);\n }\n \n static void\n OP_MXC (instr_info *ins, int bytemode ATTRIBUTE_UNUSED,\n \tint sizeflag ATTRIBUTE_UNUSED)\n {\n   ins->used_prefixes |= (ins->prefixes & PREFIX_DATA);\n-  oappend (ins, ins->names_mm[ins->modrm.reg]);\n+  oappend_maybe_intel (ins, att_names_mm[ins->modrm.reg]);\n }\n \n static void\n@@ -13018,10 +12910,10 @@ OP_Mwait (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n   /* mwait %eax,%ecx / mwaitx %eax,%ecx,%ebx  */\n   if (!ins->intel_syntax)\n     {\n-      strcpy (ins->op_out[0], ins->names32[0]);\n-      strcpy (ins->op_out[1], ins->names32[1]);\n+      strcpy (ins->op_out[0], att_names32[0] + ins->intel_syntax);\n+      strcpy (ins->op_out[1], att_names32[1] + ins->intel_syntax);\n       if (bytemode == eBX_reg)\n-\tstrcpy (ins->op_out[2], ins->names32[3]);\n+\tstrcpy (ins->op_out[2], att_names32[3] + ins->intel_syntax);\n       ins->two_source_ops = 1;\n     }\n   /* Skip mod/rm byte.  */\n@@ -13037,21 +12929,21 @@ OP_Monitor (instr_info *ins, int bytemode ATTRIBUTE_UNUSED,\n   if (!ins->intel_syntax)\n     {\n       const char *const *names = (ins->address_mode == mode_64bit\n-\t\t\t\t  ? ins->names64 : ins->names32);\n+\t\t\t\t  ? att_names64 : att_names32);\n \n       if (ins->prefixes & PREFIX_ADDR)\n \t{\n \t  /* Remove \"addr16/addr32\".  */\n \t  ins->all_prefixes[ins->last_addr_prefix] = 0;\n \t  names = (ins->address_mode != mode_32bit\n-\t\t   ? ins->names32 : ins->names16);\n+\t\t   ? att_names32 : att_names16);\n \t  ins->used_prefixes |= PREFIX_ADDR;\n \t}\n       else if (ins->address_mode == mode_16bit)\n-\tnames = ins->names16;\n-      strcpy (ins->op_out[0], names[0]);\n-      strcpy (ins->op_out[1], ins->names32[1]);\n-      strcpy (ins->op_out[2], ins->names32[2]);\n+\tnames = att_names16;\n+      strcpy (ins->op_out[0], names[0] + ins->intel_syntax);\n+      strcpy (ins->op_out[1], att_names32[1] + ins->intel_syntax);\n+      strcpy (ins->op_out[2], att_names32[2] + ins->intel_syntax);\n       ins->two_source_ops = 1;\n     }\n   /* Skip mod/rm byte.  */\n@@ -13213,25 +13105,22 @@ CMPXCHG8B_Fixup (instr_info *ins, int bytemode, int sizeflag)\n static void\n XMM_Fixup (instr_info *ins, int reg, int sizeflag ATTRIBUTE_UNUSED)\n {\n-  const char *const *names;\n+  const char *const *names = att_names_xmm;\n \n   if (ins->need_vex)\n     {\n       switch (ins->vex.length)\n \t{\n \tcase 128:\n-\t  names = ins->names_xmm;\n \t  break;\n \tcase 256:\n-\t  names = ins->names_ymm;\n+\t  names = att_names_ymm;\n \t  break;\n \tdefault:\n \t  abort ();\n \t}\n     }\n-  else\n-    names = ins->names_xmm;\n-  oappend (ins, names[reg]);\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n static void\n@@ -13280,7 +13169,7 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n   switch (bytemode)\n     {\n     case scalar_mode:\n-      oappend (ins, ins->names_xmm[reg]);\n+      oappend_maybe_intel (ins, att_names_xmm[reg]);\n       return;\n \n     case vex_vsib_d_w_dq_mode:\n@@ -13291,9 +13180,9 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n       if (ins->vex.length == 128\n \t  || (bytemode != vex_vsib_d_w_dq_mode\n \t      && !ins->vex.w))\n-\toappend (ins, ins->names_xmm[reg]);\n+\toappend_maybe_intel (ins, att_names_xmm[reg]);\n       else\n-\toappend (ins, ins->names_ymm[reg]);\n+\toappend_maybe_intel (ins, att_names_ymm[reg]);\n \n       /* All 3 XMM/YMM registers must be distinct.  */\n       modrm_reg = ins->modrm.reg;\n@@ -13325,7 +13214,7 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n \t  /* This must be the 3rd operand.  */\n \t  if (ins->obufp != ins->op_out[2])\n \t    abort ();\n-\t  oappend (ins, ins->names_tmm[reg]);\n+\t  oappend_maybe_intel (ins, att_names_tmm[reg]);\n \t  if (reg == ins->modrm.reg || reg == ins->modrm.rm)\n \t    strcpy (ins->obufp, \"/(bad)\");\n \t}\n@@ -13350,13 +13239,13 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n       switch (bytemode)\n \t{\n \tcase x_mode:\n-\t  names = ins->names_xmm;\n+\t  names = att_names_xmm;\n \t  break;\n \tcase dq_mode:\n \t  if (ins->rex & REX_W)\n-\t    names = ins->names64;\n+\t    names = att_names64;\n \t  else\n-\t    names = ins->names32;\n+\t    names = att_names32;\n \t  break;\n \tcase mask_bd_mode:\n \tcase mask_mode:\n@@ -13365,7 +13254,7 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n \t      oappend (ins, \"(bad)\");\n \t      return;\n \t    }\n-\t  names = ins->names_mask;\n+\t  names = att_names_mask;\n \t  break;\n \tdefault:\n \t  abort ();\n@@ -13376,7 +13265,7 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n       switch (bytemode)\n \t{\n \tcase x_mode:\n-\t  names = ins->names_ymm;\n+\t  names = att_names_ymm;\n \t  break;\n \tcase mask_bd_mode:\n \tcase mask_mode:\n@@ -13385,7 +13274,7 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n \t      oappend (ins, \"(bad)\");\n \t      return;\n \t    }\n-\t  names = ins->names_mask;\n+\t  names = att_names_mask;\n \t  break;\n \tdefault:\n \t  /* See PR binutils/20893 for a reproducer.  */\n@@ -13394,13 +13283,13 @@ OP_VEX (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n \t}\n       break;\n     case 512:\n-      names = ins->names_zmm;\n+      names = att_names_zmm;\n       break;\n     default:\n       abort ();\n       break;\n     }\n-  oappend (ins, names[reg]);\n+  oappend_maybe_intel (ins, names[reg]);\n }\n \n static void\n@@ -13428,7 +13317,7 @@ static void\n OP_REG_VexI4 (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n {\n   int reg;\n-  const char *const *names = ins->names_xmm;\n+  const char *const *names = att_names_xmm;\n \n   FETCH_DATA (ins->info, ins->codep + 1);\n   reg = *ins->codep++;\n@@ -13441,9 +13330,9 @@ OP_REG_VexI4 (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n     reg &= 7;\n \n   if (bytemode == x_mode && ins->vex.length == 256)\n-    names = ins->names_ymm;\n+    names = att_names_ymm;\n \n-  oappend (ins, names[reg]);\n+  oappend_maybe_intel (ins, names[reg]);\n \n   if (ins->vex.w)\n     {"
    }
  ]
}