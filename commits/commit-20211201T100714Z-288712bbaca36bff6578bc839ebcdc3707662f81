{
  "sha": "288712bbaca36bff6578bc839ebcdc3707662f81",
  "node_id": "C_kwDOANOeidoAKDI4ODcxMmJiYWNhMzZiZmY2NTc4YmM4MzllYmNkYzM3MDc2NjJmODE",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-22T15:16:27Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-01T10:07:14Z"
    },
    "message": "gdb/remote: use scoped_restore to control starting_up flag\n\nThis commit makes use of a scoped_restore object to control the\nremote_state::starting_up flag within the remote_target::start_remote\nmethod.\n\nIdeally I would have liked to create the scoped_restore inside\nstart_remote and just leave the restore in place until the end of the\nscope, however, I'm worried that doing this would change the behaviour\nof GDB.  Specifically, in start_remote, the following code is executed\nonce the starting_up flag has been restored to its previous value:\n\n  if (breakpoints_should_be_inserted_now ())\n    insert_breakpoints ();\n\nI think (but am not 100% sure) that calling install_breakpoints could\nend up back inside remote_target::can_download_tracepoint, which does\ncheck the value of remote_state::starting_up.  And so, I'm concerned\nthat leaving the scoped_restore in place until the end of start_remote\nwill cause a possible change in behaviour.\n\nTo avoid this, and to leave things as close to the current behaviour\nas possible, I've split remote_target::start_remote into two, there's\nthe main function body which moves into remote_target::start_remote_1,\nthis function uses the scoped_restore to change the ::starting_up\nflag, then there's the old remote_target::start_remote, which now just\ncalls ::start_remote_1, and then does the insert_breakpoints call.\n\nThere should be no user visible changes after this commit, unless\nthere's a situation where the ::starting_up flag could previously have\nbeen left set, if this was the case, then this situation should no\nlonger be possible.",
    "tree": {
      "sha": "97dfaed4878cf364043250499b8957c832819c99",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/97dfaed4878cf364043250499b8957c832819c99"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/288712bbaca36bff6578bc839ebcdc3707662f81",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/288712bbaca36bff6578bc839ebcdc3707662f81",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/288712bbaca36bff6578bc839ebcdc3707662f81",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/288712bbaca36bff6578bc839ebcdc3707662f81/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "6976b5b96120ad71af4cec2891f3d8ae7869e4e0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6976b5b96120ad71af4cec2891f3d8ae7869e4e0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6976b5b96120ad71af4cec2891f3d8ae7869e4e0"
    }
  ],
  "stats": {
    "total": 44,
    "additions": 22,
    "deletions": 22
  },
  "files": [
    {
      "sha": "f53e31e126e3a9453a85b912b5483945254a5584",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/288712bbaca36bff6578bc839ebcdc3707662f81/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/288712bbaca36bff6578bc839ebcdc3707662f81/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=288712bbaca36bff6578bc839ebcdc3707662f81",
      "patch": "@@ -956,7 +956,9 @@ class remote_target : public process_stratum_target\n \n   bool vcont_r_supported ();\n \n-private: /* data fields */\n+private:\n+\n+  bool start_remote_1 (int from_tty, int extended_p);\n \n   /* The remote state.  Don't reference this directly.  Use the\n      get_remote_state method instead.  */\n@@ -4671,10 +4673,13 @@ remote_target::process_initial_stop_replies (int from_tty)\n     }\n }\n \n-/* Start the remote connection and sync state.  */\n+/* Helper for remote_target::start_remote, start the remote connection and\n+   sync state.  Return true if everything goes OK, otherwise, return false.\n+   This function exists so that the scoped_restore created within it will\n+   expire before we return to remote_target::start_remote.  */\n \n-void\n-remote_target::start_remote (int from_tty, int extended_p)\n+bool\n+remote_target::start_remote_1 (int from_tty, int extended_p)\n {\n   REMOTE_SCOPED_DEBUG_ENTER_EXIT;\n \n@@ -4687,7 +4692,8 @@ remote_target::start_remote (int from_tty, int extended_p)\n      Ctrl-C before we're connected and synced up can't interrupt the\n      target.  Instead, it offers to drop the (potentially wedged)\n      connection.  */\n-  rs->starting_up = true;\n+  scoped_restore restore_starting_up_flag\n+    = make_scoped_restore (&rs->starting_up, true);\n \n   QUIT;\n \n@@ -4825,11 +4831,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t{\n \t  if (!extended_p)\n \t    error (_(\"The target is not running (try extended-remote?)\"));\n-\n-\t  /* We're connected, but not running.  Drop out before we\n-\t     call start_remote.  */\n-\t  rs->starting_up = false;\n-\t  return;\n+\t  return false;\n \t}\n       else\n \t{\n@@ -4940,11 +4942,7 @@ remote_target::start_remote (int from_tty, int extended_p)\n \t{\n \t  if (!extended_p)\n \t    error (_(\"The target is not running (try extended-remote?)\"));\n-\n-\t  /* We're connected, but not running.  Drop out before we\n-\t     call start_remote.  */\n-\t  rs->starting_up = false;\n-\t  return;\n+\t  return false;\n \t}\n \n       /* Report all signals during attach/startup.  */\n@@ -4984,14 +4982,16 @@ remote_target::start_remote (int from_tty, int extended_p)\n      previously; find out where things are at.  */\n   remote_btrace_maybe_reopen ();\n \n-  /* The thread and inferior lists are now synchronized with the\n-     target, our symbols have been relocated, and we're merged the\n-     target's tracepoints with ours.  We're done with basic start\n-     up.  */\n-  rs->starting_up = false;\n+  return true;\n+}\n+\n+/* Start the remote connection and sync state.  */\n \n-  /* Maybe breakpoints are global and need to be inserted now.  */\n-  if (breakpoints_should_be_inserted_now ())\n+void\n+remote_target::start_remote (int from_tty, int extended_p)\n+{\n+  if (start_remote_1 (from_tty, extended_p)\n+      && breakpoints_should_be_inserted_now ())\n     insert_breakpoints ();\n }\n "
    }
  ]
}