{
  "sha": "1f4361a77b18c5ab32baf2f30fefe5e301e017be",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWY0MzYxYTc3YjE4YzVhYjMyYmFmMmYzMGZlZmU1ZTMwMWUwMTdiZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:45:06Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-19T02:45:06Z"
    },
    "message": "_bfd_mul_overflow\n\nThis patch removes the bfd_alloc2 series of memory allocation functions,\nreplacing them with __builtin_mul_overflow followed by bfd_alloc.  Why\ndo that?  Well, a followup patch will implement _bfd_alloc_and_read\nand I don't want to implement alloc2 variants as well.\n\n\t* coffcode.h (buy_and_read, coff_slurp_line_table),\n\t(coff_slurp_symbol_table, coff_slurp_reloc_table): Replace\n\tbfd_[z][m]alloc2 calls with _bfd_mul_overflow followed by the\n\tcorresponding bfd_alloc call.  Adjust variables to suit.\n\t* coffgen.c (_bfd_coff_get_external_symbols): Likewise.\n\t* ecoff.c (_bfd_ecoff_slurp_symbolic_info),\n\t(_bfd_ecoff_slurp_symbol_table, READ): Likewise.\n\t* elf.c (bfd_elf_get_elf_syms, setup_group, bfd_section_from_shdr),\n\t(swap_out_syms, _bfd_elf_slurp_version_tables): Likewise.\n\t* elf32-m32c.c (m32c_elf_relax_section): Likewise.\n\t* elf32-rl78.c (rl78_elf_relax_section): Likewise.\n\t* elf32-rx.c (elf32_rx_relax_section): Likewise.\n\t* elf64-alpha.c (READ): Likewise.\n\t* elfcode.h (elf_object_p, elf_write_relocs, elf_write_shdrs_and_ehdr),\n\t(elf_slurp_symbol_table, elf_slurp_reloc_table),\n\t(bfd_from_remote_memory): Likewise.\n\t* elfcore.h (core_find_build_id): Likewise.\n\t* elfxx-mips.c (READ): Likewise.\n\t* mach-o.c (bfd_mach_o_mangle_sections),\n\t(bfd_mach_o_read_symtab_symbols, bfd_mach_o_read_thread),\n\t(bfd_mach_o_read_dysymtab, bfd_mach_o_flatten_sections),\n\t(bfd_mach_o_scan, bfd_mach_o_fat_archive_p): Likewise.\n\t* som.c (setup_sections, som_prep_for_fixups)\n\t(som_build_and_write_symbol_table, som_slurp_symbol_table),\n\t(som_slurp_reloc_table, som_bfd_count_ar_symbols),\n\t(som_bfd_fill_in_ar_symbols, som_slurp_armap),\n\t(som_bfd_ar_write_symbol_stuff): Likewise.\n\t* vms-alpha.c (vector_grow1): Likewise.\n\t* vms-lib.c (vms_add_index): Likewise.\n\t* wasm-module.c (wasm_scan_name_function_section): Likewise.\n\t* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): Delete.\n\t* opncls.c (bfd_alloc2, bfd_zalloc2): Delete.\n\t* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2),\n\t(bfd_alloc2, bfd_zalloc2): Delete.\n\t(_bfd_mul_overflow): Define.\n\t* libbfd.h: Regenerate.",
    "tree": {
      "sha": "60d1db1d413b74073da9d11322b8d2d971106d30",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/60d1db1d413b74073da9d11322b8d2d971106d30"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1f4361a77b18c5ab32baf2f30fefe5e301e017be",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f4361a77b18c5ab32baf2f30fefe5e301e017be",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1f4361a77b18c5ab32baf2f30fefe5e301e017be",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f4361a77b18c5ab32baf2f30fefe5e301e017be/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/446f7ed5abfd2d0bed8c4442d0634b1a8bc116f4"
    }
  ],
  "stats": {
    "total": 894,
    "additions": 541,
    "deletions": 353
  },
  "files": [
    {
      "sha": "a9e3f6729c150ef94632f4aeaec9cf2018c71b7a",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -1,3 +1,42 @@\n+2020-02-19  Alan Modra  <amodra@gmail.com>\n+\n+\t* coffcode.h (buy_and_read, coff_slurp_line_table),\n+\t(coff_slurp_symbol_table, coff_slurp_reloc_table): Replace\n+\tbfd_[z][m]alloc2 calls with _bfd_mul_overflow followed by the\n+\tcorresponding bfd_alloc call.  Adjust variables to suit.\n+\t* coffgen.c (_bfd_coff_get_external_symbols): Likewise.\n+\t* ecoff.c (_bfd_ecoff_slurp_symbolic_info),\n+\t(_bfd_ecoff_slurp_symbol_table, READ): Likewise.\n+\t* elf.c (bfd_elf_get_elf_syms, setup_group, bfd_section_from_shdr),\n+\t(swap_out_syms, _bfd_elf_slurp_version_tables): Likewise.\n+\t* elf32-m32c.c (m32c_elf_relax_section): Likewise.\n+\t* elf32-rl78.c (rl78_elf_relax_section): Likewise.\n+\t* elf32-rx.c (elf32_rx_relax_section): Likewise.\n+\t* elf64-alpha.c (READ): Likewise.\n+\t* elfcode.h (elf_object_p, elf_write_relocs, elf_write_shdrs_and_ehdr),\n+\t(elf_slurp_symbol_table, elf_slurp_reloc_table),\n+\t(bfd_from_remote_memory): Likewise.\n+\t* elfcore.h (core_find_build_id): Likewise.\n+\t* elfxx-mips.c (READ): Likewise.\n+\t* mach-o.c (bfd_mach_o_mangle_sections),\n+\t(bfd_mach_o_read_symtab_symbols, bfd_mach_o_read_thread),\n+\t(bfd_mach_o_read_dysymtab, bfd_mach_o_flatten_sections),\n+\t(bfd_mach_o_scan, bfd_mach_o_fat_archive_p): Likewise.\n+\t* som.c (setup_sections, som_prep_for_fixups)\n+\t(som_build_and_write_symbol_table, som_slurp_symbol_table),\n+\t(som_slurp_reloc_table, som_bfd_count_ar_symbols),\n+\t(som_bfd_fill_in_ar_symbols, som_slurp_armap),\n+\t(som_bfd_ar_write_symbol_stuff): Likewise.\n+\t* vms-alpha.c (vector_grow1): Likewise.\n+\t* vms-lib.c (vms_add_index): Likewise.\n+\t* wasm-module.c (wasm_scan_name_function_section): Likewise.\n+\t* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): Delete.\n+\t* opncls.c (bfd_alloc2, bfd_zalloc2): Delete.\n+\t* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2),\n+\t(bfd_alloc2, bfd_zalloc2): Delete.\n+\t(_bfd_mul_overflow): Define.\n+\t* libbfd.h: Regenerate.\n+\n 2020-02-19  Alan Modra  <amodra@gmail.com>\n \n \t* elf.c (bfd_section_from_shdr): Use bfd_zalloc rather than"
    },
    {
      "sha": "551105dfb3a111936e0cdfd5c9de0b64c18a343f",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 50,
      "deletions": 20,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -4200,13 +4200,19 @@ static void *\n buy_and_read (bfd *abfd, file_ptr where,\n \t      bfd_size_type nmemb, bfd_size_type size)\n {\n-  void *area = bfd_alloc2 (abfd, nmemb, size);\n+  void *area;\n+  size_t amt;\n \n+  if (_bfd_mul_overflow (nmemb, size, &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return NULL;\n+    }\n+  area = bfd_alloc (abfd, amt);\n   if (!area)\n     return NULL;\n-  size *= nmemb;\n   if (bfd_seek (abfd, where, SEEK_SET) != 0\n-      || bfd_bread (area, size, abfd) != size)\n+      || bfd_bread (area, amt, abfd) != amt)\n     return NULL;\n   return area;\n }\n@@ -4265,6 +4271,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n   LINENO *src;\n   bfd_boolean have_func;\n   bfd_boolean ret = TRUE;\n+  size_t amt;\n \n   if (asect->lineno_count == 0)\n     return TRUE;\n@@ -4279,9 +4286,12 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n       return FALSE;\n     }\n \n-  lineno_cache = (alent *) bfd_alloc2 (abfd,\n-\t\t\t\t       (bfd_size_type) asect->lineno_count + 1,\n-\t\t\t\t       sizeof (alent));\n+  if (_bfd_mul_overflow (asect->lineno_count + 1, sizeof (alent), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  lineno_cache = (alent *) bfd_alloc (abfd, amt);\n   if (lineno_cache == NULL)\n     return FALSE;\n \n@@ -4395,8 +4405,12 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n       alent *n_lineno_cache;\n \n       /* Create a table of functions.  */\n-      func_table = (alent **) bfd_alloc2 (abfd, nbr_func, sizeof (alent *));\n-      if (func_table != NULL)\n+      if (_bfd_mul_overflow (nbr_func, sizeof (alent *), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  ret = FALSE;\n+\t}\n+      else if ((func_table = (alent **) bfd_alloc (abfd, amt)) != NULL)\n \t{\n \t  alent **p = func_table;\n \t  unsigned int i;\n@@ -4411,9 +4425,12 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t  qsort (func_table, nbr_func, sizeof (alent *), coff_sort_func_alent);\n \n \t  /* Create the new sorted table.  */\n-\t  n_lineno_cache = (alent *) bfd_alloc2 (abfd, asect->lineno_count,\n-\t\t\t\t\t\t sizeof (alent));\n-\t  if (n_lineno_cache != NULL)\n+\t  if (_bfd_mul_overflow (asect->lineno_count, sizeof (alent), &amt))\n+\t    {\n+\t      bfd_set_error (bfd_error_file_too_big);\n+\t      ret = FALSE;\n+\t    }\n+\t  else if ((n_lineno_cache = (alent *) bfd_alloc (abfd, amt)) != NULL)\n \t    {\n \t      alent *n_cache_ptr = n_lineno_cache;\n \n@@ -4459,6 +4476,7 @@ coff_slurp_symbol_table (bfd * abfd)\n   unsigned int *table_ptr;\n   unsigned int number_of_symbols = 0;\n   bfd_boolean ret = TRUE;\n+  size_t amt;\n \n   if (obj_symbols (abfd))\n     return TRUE;\n@@ -4468,15 +4486,23 @@ coff_slurp_symbol_table (bfd * abfd)\n     return FALSE;\n \n   /* Allocate enough room for all the symbols in cached form.  */\n-  cached_area = (coff_symbol_type *) bfd_alloc2 (abfd,\n-\t\t\t\t\t\t obj_raw_syment_count (abfd),\n-\t\t\t\t\t\t sizeof (coff_symbol_type));\n+  if (_bfd_mul_overflow (obj_raw_syment_count (abfd),\n+\t\t\t sizeof (*cached_area), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);\n   if (cached_area == NULL)\n     return FALSE;\n \n-  table_ptr = (unsigned int *) bfd_zalloc2 (abfd, obj_raw_syment_count (abfd),\n-\t\t\t\t\t    sizeof (unsigned int));\n-\n+  if (_bfd_mul_overflow (obj_raw_syment_count (abfd),\n+\t\t\t sizeof (*table_ptr), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  table_ptr = (unsigned int *) bfd_zalloc (abfd, amt);\n   if (table_ptr == NULL)\n     return FALSE;\n   else\n@@ -4963,6 +4989,7 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)\n   arelent *reloc_cache;\n   arelent *cache_ptr;\n   unsigned int idx;\n+  size_t amt;\n \n   if (asect->relocation)\n     return TRUE;\n@@ -4976,9 +5003,12 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)\n   native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos,\n \t\t\t\t\t  asect->reloc_count,\n \t\t\t\t\t  bfd_coff_relsz (abfd));\n-  reloc_cache = (arelent *) bfd_alloc2 (abfd, asect->reloc_count,\n-\t\t\t\t\tsizeof (arelent));\n-\n+  if (_bfd_mul_overflow (asect->reloc_count, sizeof (arelent), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  reloc_cache = (arelent *) bfd_alloc (abfd, amt);\n   if (reloc_cache == NULL || native_relocs == NULL)\n     return FALSE;\n "
    },
    {
      "sha": "20cee0a74c584281cdac0fb21617702c68d8486d",
      "filename": "bfd/coffgen.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/coffgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/coffgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffgen.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -1639,30 +1639,29 @@ copy_name (bfd *abfd, char *name, size_t maxlen)\n bfd_boolean\n _bfd_coff_get_external_symbols (bfd *abfd)\n {\n-  bfd_size_type symesz;\n-  bfd_size_type size;\n+  size_t symesz;\n+  size_t size;\n   void * syms;\n   ufile_ptr filesize;\n \n   if (obj_coff_external_syms (abfd) != NULL)\n     return TRUE;\n \n-  symesz = bfd_coff_symesz (abfd);\n-  size = obj_raw_syment_count (abfd) * symesz;\n-  if (size == 0)\n-    return TRUE;\n-\n   /* Check for integer overflow and for unreasonable symbol counts.  */\n   filesize = bfd_get_file_size (abfd);\n-  if (size < obj_raw_syment_count (abfd)\n+  symesz = bfd_coff_symesz (abfd);\n+  if (_bfd_mul_overflow (obj_raw_syment_count (abfd), symesz, &size)\n       || (filesize != 0 && size > filesize))\n-\n     {\n+      bfd_set_error (bfd_error_file_truncated);\n       _bfd_error_handler (_(\"%pB: corrupt symbol count: %#\" PRIx64 \"\"),\n \t\t\t  abfd, (uint64_t) obj_raw_syment_count (abfd));\n       return FALSE;\n     }\n \n+  if (size == 0)\n+    return TRUE;\n+\n   syms = bfd_malloc (size);\n   if (syms == NULL)\n     {"
    },
    {
      "sha": "15c18aca76d937990b387dda59d453cd38c2339b",
      "filename": "bfd/ecoff.c",
      "status": "modified",
      "additions": 42,
      "deletions": 23,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ecoff.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -514,6 +514,7 @@ _bfd_ecoff_slurp_symbolic_info (bfd *abfd,\n   bfd_size_type raw_end;\n   bfd_size_type cb_end;\n   file_ptr pos;\n+  size_t amt;\n \n   BFD_ASSERT (debug == &ecoff_data (abfd)->debug_info);\n \n@@ -615,8 +616,13 @@ _bfd_ecoff_slurp_symbolic_info (bfd *abfd,\n \n      We need to look at the fdr to deal with a lot of information in\n      the symbols, so we swap them here.  */\n-  debug->fdr = (FDR *) bfd_alloc2 (abfd, internal_symhdr->ifdMax,\n-\t\t\t\t   sizeof (struct fdr));\n+  if (_bfd_mul_overflow ((unsigned long) internal_symhdr->ifdMax,\n+\t\t\t sizeof (struct fdr), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  debug->fdr = (FDR *) bfd_alloc (abfd, amt);\n   if (debug->fdr == NULL)\n     return FALSE;\n   external_fdr_size = backend->debug_swap.external_fdr_size;\n@@ -872,6 +878,7 @@ _bfd_ecoff_slurp_symbol_table (bfd *abfd)\n   char *eraw_end;\n   FDR *fdr_ptr;\n   FDR *fdr_end;\n+  size_t amt;\n \n   /* If we've already read in the symbol table, do nothing.  */\n   if (ecoff_data (abfd)->canonical_symbols != NULL)\n@@ -884,8 +891,13 @@ _bfd_ecoff_slurp_symbol_table (bfd *abfd)\n   if (bfd_get_symcount (abfd) == 0)\n     return TRUE;\n \n-  internal = (ecoff_symbol_type *) bfd_alloc2 (abfd, bfd_get_symcount (abfd),\n-\t\t\t\t\t       sizeof (ecoff_symbol_type));\n+  if (_bfd_mul_overflow (bfd_get_symcount (abfd),\n+\t\t\t sizeof (ecoff_symbol_type), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  internal = (ecoff_symbol_type *) bfd_alloc (abfd, amt);\n   if (internal == NULL)\n     return FALSE;\n \n@@ -3745,25 +3757,32 @@ ecoff_final_link_debug_accumulate (bfd *output_bfd,\n   HDRR *symhdr = &debug->symbolic_header;\n   bfd_boolean ret;\n \n-#define READ(ptr, offset, count, size, type)\t\t\t\t \\\n-  if (symhdr->count == 0)\t\t\t\t\t\t \\\n-    debug->ptr = NULL;\t\t\t\t\t\t\t \\\n-  else\t\t\t\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      bfd_size_type amt = (bfd_size_type) size * symhdr->count;\t\t \\\n-      debug->ptr = (type) bfd_malloc (amt);\t\t\t\t \\\n-      if (debug->ptr == NULL)\t\t\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  ret = FALSE;\t\t\t\t\t\t\t \\\n-\t  goto return_something;\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      if (bfd_seek (input_bfd, (file_ptr) symhdr->offset, SEEK_SET) != 0 \\\n-\t  || bfd_bread (debug->ptr, amt, input_bfd) != amt)\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  ret = FALSE;\t\t\t\t\t\t\t \\\n-\t  goto return_something;\t\t\t\t\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-    }\n+#define READ(ptr, offset, count, size, type)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      size_t amt;\t\t\t\t\t\t\t\\\n+      debug->ptr = NULL;\t\t\t\t\t\t\\\n+      if (symhdr->count == 0)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      if (_bfd_mul_overflow (size, symhdr->count, &amt))\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  bfd_set_error (bfd_error_file_too_big);\t\t\t\\\n+\t  ret = FALSE;\t\t\t\t\t\t\t\\\n+\t  goto return_something;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      debug->ptr = (type) bfd_malloc (amt);\t\t\t\t\\\n+      if (debug->ptr == NULL)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  ret = FALSE;\t\t\t\t\t\t\t\\\n+\t  goto return_something;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bfd_seek (input_bfd, symhdr->offset, SEEK_SET) != 0\t\t\\\n+\t  || bfd_bread (debug->ptr, amt, input_bfd) != amt)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  ret = FALSE;\t\t\t\t\t\t\t\\\n+\t  goto return_something;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    } while (0)\n \n   /* If raw_syments is not NULL, then the data was already by read by\n      _bfd_ecoff_slurp_symbolic_info.  */"
    },
    {
      "sha": "a3af7ef2af7b6d93bab1ab14fde141093959ec66",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 85,
      "deletions": 59,
      "changes": 144,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -402,7 +402,7 @@ bfd_elf_get_elf_syms (bfd *ibfd,\n   Elf_Internal_Sym *isymend;\n   const struct elf_backend_data *bed;\n   size_t extsym_size;\n-  bfd_size_type amt;\n+  size_t amt;\n   file_ptr pos;\n \n   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)\n@@ -448,11 +448,16 @@ bfd_elf_get_elf_syms (bfd *ibfd,\n   alloc_intsym = NULL;\n   bed = get_elf_backend_data (ibfd);\n   extsym_size = bed->s->sizeof_sym;\n-  amt = (bfd_size_type) symcount * extsym_size;\n+  if (_bfd_mul_overflow (symcount, extsym_size, &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      intsym_buf = NULL;\n+      goto out;\n+    }\n   pos = symtab_hdr->sh_offset + symoffset * extsym_size;\n   if (extsym_buf == NULL)\n     {\n-      alloc_ext = bfd_malloc2 (symcount, extsym_size);\n+      alloc_ext = bfd_malloc (amt);\n       extsym_buf = alloc_ext;\n     }\n   if (extsym_buf == NULL\n@@ -467,12 +472,16 @@ bfd_elf_get_elf_syms (bfd *ibfd,\n     extshndx_buf = NULL;\n   else\n     {\n-      amt = (bfd_size_type) symcount * sizeof (Elf_External_Sym_Shndx);\n+      if (_bfd_mul_overflow (symcount, sizeof (Elf_External_Sym_Shndx), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  intsym_buf = NULL;\n+\t  goto out;\n+\t}\n       pos = shndx_hdr->sh_offset + symoffset * sizeof (Elf_External_Sym_Shndx);\n       if (extshndx_buf == NULL)\n \t{\n-\t  alloc_extshndx = (Elf_External_Sym_Shndx *)\n-\t      bfd_malloc2 (symcount, sizeof (Elf_External_Sym_Shndx));\n+\t  alloc_extshndx = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n \t  extshndx_buf = alloc_extshndx;\n \t}\n       if (extshndx_buf == NULL\n@@ -486,8 +495,12 @@ bfd_elf_get_elf_syms (bfd *ibfd,\n \n   if (intsym_buf == NULL)\n     {\n-      alloc_intsym = (Elf_Internal_Sym *)\n-\t  bfd_malloc2 (symcount, sizeof (Elf_Internal_Sym));\n+      if (_bfd_mul_overflow (symcount, sizeof (Elf_Internal_Sym), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto out;\n+\t}\n+      alloc_intsym = (Elf_Internal_Sym *) bfd_malloc (amt);\n       intsym_buf = alloc_intsym;\n       if (intsym_buf == NULL)\n \tgoto out;\n@@ -629,15 +642,14 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n \t{\n \t  /* We keep a list of elf section headers for group sections,\n \t     so we can find them quickly.  */\n-\t  bfd_size_type amt;\n+\t  size_t amt;\n \n \t  elf_tdata (abfd)->num_group = num_group;\n-\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n-\t      bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n+\t  amt = num_group * sizeof (Elf_Internal_Shdr *);\n+\t  elf_tdata (abfd)->group_sect_ptr\n+\t    = (Elf_Internal_Shdr **) bfd_zalloc (abfd, amt);\n \t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n \t    return FALSE;\n-\t  memset (elf_tdata (abfd)->group_sect_ptr, 0,\n-\t\t  num_group * sizeof (Elf_Internal_Shdr *));\n \t  num_group = 0;\n \n \t  for (i = 0; i < shnum; i++)\n@@ -659,24 +671,12 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n \t\t  num_group += 1;\n \n \t\t  /* Read the raw contents.  */\n-\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n-\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n-\t\t  shdr->contents = (unsigned char *)\n-\t\t    bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n-\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n-\t\t  if (shdr->contents == NULL)\n-\t\t    {\n-\t\t      _bfd_error_handler\n-\t\t\t/* xgettext:c-format */\n-\t\t\t(_(\"%pB: corrupt size field in group section\"\n-\t\t\t   \" header: %#\" PRIx64),\n-\t\t\t abfd, (uint64_t) shdr->sh_size);\n-\t\t      bfd_set_error (bfd_error_bad_value);\n-\t\t      -- num_group;\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n+\t\t  BFD_ASSERT (sizeof (*dest) >= 4 && sizeof (*dest) % 4 == 0);\n+\t\t  shdr->contents = NULL;\n+\t\t  if (_bfd_mul_overflow (shdr->sh_size,\n+\t\t\t\t\t sizeof (*dest) / 4, &amt)\n+\t\t      || (shdr->contents = bfd_alloc (abfd, amt)) == NULL\n+\t\t      || bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n \t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n \t\t\t  != shdr->sh_size))\n \t\t    {\n@@ -690,8 +690,11 @@ setup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n \t\t      /* PR 17510: If the group contents are even\n \t\t\t partially corrupt, do not allow any of the\n \t\t\t contents to be used.  */\n-\t\t      bfd_release (abfd, shdr->contents);\n-\t\t      shdr->contents = NULL;\n+\t\t      if (shdr->contents != NULL)\n+\t\t\t{\n+\t\t\t  bfd_release (abfd, shdr->contents);\n+\t\t\t  shdr->contents = NULL;\n+\t\t\t}\n \t\t      continue;\n \t\t    }\n \n@@ -8015,7 +8018,7 @@ swap_out_syms (bfd *abfd,\n \t       int relocatable_p)\n {\n   const struct elf_backend_data *bed;\n-  int symcount;\n+  unsigned int symcount;\n   asymbol **syms;\n   struct elf_strtab_hash *stt;\n   Elf_Internal_Shdr *symtab_hdr;\n@@ -8026,9 +8029,9 @@ swap_out_syms (bfd *abfd,\n   bfd_byte *outbound_shndx;\n   unsigned long outbound_syms_index;\n   unsigned long outbound_shndx_index;\n-  int idx;\n+  unsigned int idx;\n   unsigned int num_locals;\n-  bfd_size_type amt;\n+  size_t amt;\n   bfd_boolean name_local_sections;\n \n   if (!elf_map_symbols (abfd, &num_locals))\n@@ -8052,21 +8055,22 @@ swap_out_syms (bfd *abfd,\n   symstrtab_hdr->sh_type = SHT_STRTAB;\n \n   /* Allocate buffer to swap out the .strtab section.  */\n-  symstrtab = (struct elf_sym_strtab *) bfd_malloc2 (symcount + 1,\n-\t\t\t\t\t\t     sizeof (*symstrtab));\n-  if (symstrtab == NULL)\n+  if (_bfd_mul_overflow (symcount + 1, sizeof (*symstrtab), &amt)\n+      || (symstrtab = (struct elf_sym_strtab *) bfd_malloc (amt)) == NULL)\n     {\n+      bfd_set_error (bfd_error_no_memory);\n       _bfd_elf_strtab_free (stt);\n       return FALSE;\n     }\n \n-  outbound_syms = (bfd_byte *) bfd_alloc2 (abfd, 1 + symcount,\n-\t\t\t\t\t   bed->s->sizeof_sym);\n-  if (outbound_syms == NULL)\n+  if (_bfd_mul_overflow (symcount + 1, bed->s->sizeof_sym, &amt)\n+      || (outbound_syms = (bfd_byte *) bfd_alloc (abfd, amt)) == NULL)\n     {\n-error_return:\n-      _bfd_elf_strtab_free (stt);\n+    error_no_mem:\n+      bfd_set_error (bfd_error_no_memory);\n+    error_return:\n       free (symstrtab);\n+      _bfd_elf_strtab_free (stt);\n       return FALSE;\n     }\n   symtab_hdr->contents = outbound_syms;\n@@ -8080,9 +8084,10 @@ swap_out_syms (bfd *abfd,\n       symtab_shndx_hdr = & elf_symtab_shndx_list (abfd)->hdr;\n       if (symtab_shndx_hdr->sh_name != 0)\n \t{\n-\t  amt = (bfd_size_type) (1 + symcount) * sizeof (Elf_External_Sym_Shndx);\n-\t  outbound_shndx =  (bfd_byte *)\n-\t    bfd_zalloc2 (abfd, 1 + symcount, sizeof (Elf_External_Sym_Shndx));\n+\t  if (_bfd_mul_overflow (symcount + 1,\n+\t\t\t\t sizeof (Elf_External_Sym_Shndx), &amt))\n+\t    goto error_no_mem;\n+\t  outbound_shndx =  (bfd_byte *) bfd_zalloc (abfd, amt);\n \t  if (outbound_shndx == NULL)\n \t    goto error_return;\n \n@@ -8570,6 +8575,7 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n {\n   bfd_byte *contents = NULL;\n   unsigned int freeidx = 0;\n+  size_t amt;\n \n   if (elf_dynverref (abfd) != 0)\n     {\n@@ -8614,9 +8620,12 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n \t  || bfd_bread (contents, hdr->sh_size, abfd) != hdr->sh_size)\n \tgoto error_return_verref;\n \n-      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *)\n-\tbfd_alloc2 (abfd, hdr->sh_info, sizeof (Elf_Internal_Verneed));\n-\n+      if (_bfd_mul_overflow (hdr->sh_info, sizeof (Elf_Internal_Verneed), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return_verref;\n+\t}\n+      elf_tdata (abfd)->verref = (Elf_Internal_Verneed *) bfd_alloc (abfd, amt);\n       if (elf_tdata (abfd)->verref == NULL)\n \tgoto error_return_verref;\n \n@@ -8645,9 +8654,14 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n \t    iverneed->vn_auxptr = NULL;\n \t  else\n \t    {\n+\t      if (_bfd_mul_overflow (iverneed->vn_cnt,\n+\t\t\t\t     sizeof (Elf_Internal_Vernaux), &amt))\n+\t\t{\n+\t\t  bfd_set_error (bfd_error_file_too_big);\n+\t\t  goto error_return_verref;\n+\t\t}\n \t      iverneed->vn_auxptr = (struct elf_internal_vernaux *)\n-\t\t  bfd_alloc2 (abfd, iverneed->vn_cnt,\n-\t\t\t      sizeof (Elf_Internal_Vernaux));\n+\t\tbfd_alloc (abfd, amt);\n \t      if (iverneed->vn_auxptr == NULL)\n \t\tgoto error_return_verref;\n \t    }\n@@ -8779,9 +8793,12 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n \t  else\n \t    freeidx = ++maxidx;\n \t}\n-\n-      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n-\tbfd_zalloc2 (abfd, maxidx, sizeof (Elf_Internal_Verdef));\n+      if (_bfd_mul_overflow (maxidx, sizeof (Elf_Internal_Verdef), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return_verdef;\n+\t}\n+      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *) bfd_zalloc (abfd, amt);\n       if (elf_tdata (abfd)->verdef == NULL)\n \tgoto error_return_verdef;\n \n@@ -8809,9 +8826,14 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n \t    iverdef->vd_auxptr = NULL;\n \t  else\n \t    {\n+\t      if (_bfd_mul_overflow (iverdef->vd_cnt,\n+\t\t\t\t     sizeof (Elf_Internal_Verdaux), &amt))\n+\t\t{\n+\t\t  bfd_set_error (bfd_error_file_too_big);\n+\t\t  goto error_return_verdef;\n+\t\t}\n \t      iverdef->vd_auxptr = (struct elf_internal_verdaux *)\n-\t\t  bfd_alloc2 (abfd, iverdef->vd_cnt,\n-\t\t\t      sizeof (Elf_Internal_Verdaux));\n+\t\tbfd_alloc (abfd, amt);\n \t      if (iverdef->vd_auxptr == NULL)\n \t\tgoto error_return_verdef;\n \t    }\n@@ -8874,8 +8896,12 @@ _bfd_elf_slurp_version_tables (bfd *abfd, bfd_boolean default_imported_symver)\n       else\n \tfreeidx++;\n \n-      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *)\n-\t  bfd_zalloc2 (abfd, freeidx, sizeof (Elf_Internal_Verdef));\n+      if (_bfd_mul_overflow (freeidx, sizeof (Elf_Internal_Verdef), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return;\n+\t}\n+      elf_tdata (abfd)->verdef = (Elf_Internal_Verdef *) bfd_zalloc (abfd, amt);\n       if (elf_tdata (abfd)->verdef == NULL)\n \tgoto error_return;\n "
    },
    {
      "sha": "89bdccacd062cf3c1dd035f3b6058847e9154e6e",
      "filename": "bfd/elf32-m32c.c",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32c.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -1491,10 +1491,14 @@ m32c_elf_relax_section\n \n   if (shndx_hdr && shndx_hdr->sh_size != 0)\n     {\n-      bfd_size_type amt;\n+      size_t amt;\n \n-      amt = symtab_hdr->sh_info;\n-      amt *= sizeof (Elf_External_Sym_Shndx);\n+      if (_bfd_mul_overflow (symtab_hdr->sh_info,\n+\t\t\t     sizeof (Elf_External_Sym_Shndx), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return;\n+\t}\n       shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n       if (shndx_buf == NULL)\n \tgoto error_return;"
    },
    {
      "sha": "f4abf0425e8f55a7fd0300a594f9edefc76416fa",
      "filename": "bfd/elf32-rl78.c",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rl78.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -2121,10 +2121,14 @@ rl78_elf_relax_section\n \n   if (shndx_hdr && shndx_hdr->sh_size != 0)\n     {\n-      bfd_size_type amt;\n+      size_t amt;\n \n-      amt = symtab_hdr->sh_info;\n-      amt *= sizeof (Elf_External_Sym_Shndx);\n+      if (_bfd_mul_overflow (symtab_hdr->sh_info,\n+\t\t\t     sizeof (Elf_External_Sym_Shndx), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_no_memory);\n+\t  goto error_return;\n+\t}\n       shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n       if (shndx_buf == NULL)\n \tgoto error_return;"
    },
    {
      "sha": "a94aee729cfb3b8204847aa258bc98aaeb8fab6e",
      "filename": "bfd/elf32-rx.c",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf32-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rx.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -2058,10 +2058,14 @@ elf32_rx_relax_section (bfd *\t\t       abfd,\n \n   if (shndx_hdr && shndx_hdr->sh_size != 0)\n     {\n-      bfd_size_type amt;\n+      size_t amt;\n \n-      amt = symtab_hdr->sh_info;\n-      amt *= sizeof (Elf_External_Sym_Shndx);\n+      if (_bfd_mul_overflow (symtab_hdr->sh_info,\n+\t\t\t     sizeof (Elf_External_Sym_Shndx), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return;\n+\t}\n       shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);\n       if (shndx_buf == NULL)\n \tgoto error_return;"
    },
    {
      "sha": "ae4be9f07464051950724a0867d410566b2c1a38",
      "filename": "bfd/elf64-alpha.c",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf64-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elf64-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-alpha.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -1387,18 +1387,24 @@ elf64_alpha_read_ecoff_info (bfd *abfd, asection *section,\n   /* The symbolic header contains absolute file offsets and sizes to\n      read.  */\n #define READ(ptr, offset, count, size, type)\t\t\t\t\\\n-  if (symhdr->count == 0)\t\t\t\t\t\t\\\n-    debug->ptr = NULL;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      bfd_size_type amt = (bfd_size_type) size * symhdr->count;\t\t\\\n+      size_t amt;\t\t\t\t\t\t\t\\\n+      debug->ptr = NULL;\t\t\t\t\t\t\\\n+      if (symhdr->count == 0)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      if (_bfd_mul_overflow (size, symhdr->count, &amt))\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  bfd_set_error (bfd_error_file_too_big);\t\t\t\\\n+\t  goto error_return;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       debug->ptr = (type) bfd_malloc (amt);\t\t\t\t\\\n       if (debug->ptr == NULL)\t\t\t\t\t\t\\\n \tgoto error_return;\t\t\t\t\t\t\\\n       if (bfd_seek (abfd, (file_ptr) symhdr->offset, SEEK_SET) != 0\t\\\n \t  || bfd_bread (debug->ptr, amt, abfd) != amt)\t\t\t\\\n \tgoto error_return;\t\t\t\t\t\t\\\n-    }\n+    } while (0)\n \n   READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);\n   READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);"
    },
    {
      "sha": "e7dfdee95e9c7e6672dbdd14379206837df1ef26",
      "filename": "bfd/elfcode.h",
      "status": "modified",
      "additions": 43,
      "deletions": 26,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfcode.h?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -687,19 +687,18 @@ elf_object_p (bfd *abfd)\n     {\n       Elf_Internal_Shdr *shdrp;\n       unsigned int num_sec;\n+      size_t amt;\n \n-#ifndef BFD64\n-      if (i_ehdrp->e_shnum > ((bfd_size_type) -1) / sizeof (*i_shdrp))\n+      if (_bfd_mul_overflow (i_ehdrp->e_shnum, sizeof (*i_shdrp), &amt))\n \tgoto got_wrong_format_error;\n-#endif\n-      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc2 (abfd, i_ehdrp->e_shnum,\n-\t\t\t\t\t\t  sizeof (*i_shdrp));\n+      i_shdrp = (Elf_Internal_Shdr *) bfd_alloc (abfd, amt);\n       if (!i_shdrp)\n \tgoto got_no_match;\n       num_sec = i_ehdrp->e_shnum;\n       elf_numsections (abfd) = num_sec;\n-      elf_elfsections (abfd)\n-\t= (Elf_Internal_Shdr **) bfd_alloc2 (abfd, num_sec, sizeof (i_shdrp));\n+      if (_bfd_mul_overflow (num_sec, sizeof (i_shdrp), &amt))\n+\tgoto got_wrong_format_error;\n+      elf_elfsections (abfd) = (Elf_Internal_Shdr **) bfd_alloc (abfd, amt);\n       if (!elf_elfsections (abfd))\n \tgoto got_no_match;\n \n@@ -781,20 +780,18 @@ elf_object_p (bfd *abfd)\n       Elf_Internal_Phdr *i_phdr;\n       unsigned int i;\n       ufile_ptr filesize;\n+      size_t amt;\n \n-#ifndef BFD64\n-      if (i_ehdrp->e_phnum > ((bfd_size_type) -1) / sizeof (*i_phdr))\n-\tgoto got_wrong_format_error;\n-#endif\n       /* Check for a corrupt input file with an impossibly large number\n \t of program headers.  */\n       filesize = bfd_get_file_size (abfd);\n       if (filesize != 0\n \t  && i_ehdrp->e_phnum > filesize / sizeof (Elf_External_Phdr))\n \tgoto got_wrong_format_error;\n+      if (_bfd_mul_overflow (i_ehdrp->e_phnum, sizeof (*i_phdr), &amt))\n+\tgoto got_wrong_format_error;\n       elf_tdata (abfd)->phdr\n-\t= (Elf_Internal_Phdr *) bfd_alloc2 (abfd, i_ehdrp->e_phnum,\n-\t\t\t\t\t    sizeof (*i_phdr));\n+\t= (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);\n       if (elf_tdata (abfd)->phdr == NULL)\n \tgoto got_no_match;\n       if (bfd_seek (abfd, (file_ptr) i_ehdrp->e_phoff, SEEK_SET) != 0)\n@@ -881,6 +878,7 @@ elf_write_relocs (bfd *abfd, asection *sec, void *data)\n   unsigned int idx;\n   asymbol *last_sym;\n   int last_sym_idx;\n+  size_t amt;\n \n   /* If we have already failed, don't do anything.  */\n   if (*failedp)\n@@ -907,10 +905,10 @@ elf_write_relocs (bfd *abfd, asection *sec, void *data)\n     rela_hdr = elf_section_data (sec)->rel.hdr;\n \n   rela_hdr->sh_size = rela_hdr->sh_entsize * sec->reloc_count;\n-  rela_hdr->contents = (unsigned char *) bfd_alloc2 (abfd, sec->reloc_count,\n-\t\t\t\t\t\t     rela_hdr->sh_entsize);\n-  if (rela_hdr->contents == NULL)\n+  if (_bfd_mul_overflow (sec->reloc_count, rela_hdr->sh_entsize, &amt)\n+      || (rela_hdr->contents = bfd_alloc (abfd, amt)) == NULL)\n     {\n+      bfd_set_error (bfd_error_no_memory);\n       *failedp = TRUE;\n       return;\n     }\n@@ -1019,7 +1017,7 @@ elf_write_shdrs_and_ehdr (bfd *abfd)\n   Elf_External_Shdr *x_shdrp;\t/* Section header table, external form */\n   Elf_Internal_Shdr **i_shdrp;\t/* Section header table, internal form */\n   unsigned int count;\n-  bfd_size_type amt;\n+  size_t amt;\n \n   i_ehdrp = elf_elfheader (abfd);\n   i_shdrp = elf_elfsections (abfd);\n@@ -1045,8 +1043,12 @@ elf_write_shdrs_and_ehdr (bfd *abfd)\n     i_shdrp[0]->sh_link = i_ehdrp->e_shstrndx;\n \n   /* at this point we've concocted all the ELF sections...  */\n-  x_shdrp = (Elf_External_Shdr *) bfd_alloc2 (abfd, i_ehdrp->e_shnum,\n-\t\t\t\t\t      sizeof (*x_shdrp));\n+  if (_bfd_mul_overflow (i_ehdrp->e_shnum, sizeof (*x_shdrp), &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      return FALSE;\n+    }\n+  x_shdrp = (Elf_External_Shdr *) bfd_alloc (abfd, amt);\n   if (!x_shdrp)\n     return FALSE;\n \n@@ -1157,6 +1159,7 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)\n   Elf_External_Versym *xver;\n   Elf_External_Versym *xverbuf = NULL;\n   const struct elf_backend_data *ebd;\n+  size_t amt;\n \n   /* Read each raw ELF symbol, converting from external ELF form to\n      internal ELF form, and then using the information to create a\n@@ -1201,8 +1204,12 @@ elf_slurp_symbol_table (bfd *abfd, asymbol **symptrs, bfd_boolean dynamic)\n       if (isymbuf == NULL)\n \treturn -1;\n \n-      symbase = (elf_symbol_type *) bfd_zalloc2 (abfd, symcount,\n-\t\t\t\t\t\t sizeof (elf_symbol_type));\n+      if (_bfd_mul_overflow (symcount, sizeof (elf_symbol_type), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  goto error_return;\n+\t}\n+      symbase = (elf_symbol_type *) bfd_zalloc (abfd, amt);\n       if (symbase == (elf_symbol_type *) NULL)\n \tgoto error_return;\n \n@@ -1522,6 +1529,7 @@ elf_slurp_reloc_table (bfd *abfd,\n   bfd_size_type reloc_count;\n   bfd_size_type reloc_count2;\n   arelent *relents;\n+  size_t amt;\n \n   if (asect->relocation != NULL)\n     return TRUE;\n@@ -1559,8 +1567,12 @@ elf_slurp_reloc_table (bfd *abfd,\n       reloc_count2 = 0;\n     }\n \n-  relents = (arelent *) bfd_alloc2 (abfd, reloc_count + reloc_count2,\n-\t\t\t\t    sizeof (arelent));\n+  if (_bfd_mul_overflow (reloc_count + reloc_count2, sizeof (arelent), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  relents = (arelent *) bfd_alloc (abfd, amt);\n   if (relents == NULL)\n     return FALSE;\n \n@@ -1660,6 +1672,7 @@ NAME(_bfd_elf,bfd_from_remote_memory)\n   bfd_vma shdr_end;\n   bfd_vma loadbase;\n   char *filename;\n+  size_t amt;\n \n   /* Read in the ELF header in external format.  */\n   err = target_read_memory (ehdr_vma, (bfd_byte *) &x_ehdr, sizeof x_ehdr);\n@@ -1716,9 +1729,13 @@ NAME(_bfd_elf,bfd_from_remote_memory)\n       return NULL;\n     }\n \n-  x_phdrs\n-    = (Elf_External_Phdr *) bfd_malloc2 (i_ehdr.e_phnum,\n-\t\t\t\t\t sizeof (*x_phdrs) + sizeof (*i_phdrs));\n+  if (_bfd_mul_overflow (i_ehdr.e_phnum,\n+\t\t\t sizeof (*x_phdrs) + sizeof (*i_phdrs), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return NULL;\n+    }\n+  x_phdrs = (Elf_External_Phdr *) bfd_malloc (amt);\n   if (x_phdrs == NULL)\n     return NULL;\n   err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (bfd_byte *) x_phdrs,"
    },
    {
      "sha": "eaf40f24cc9b0183b5f89c646752babdf5b397dd",
      "filename": "bfd/elfcore.h",
      "status": "modified",
      "additions": 7,
      "deletions": 2,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfcore.h?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -335,6 +335,7 @@ NAME(_bfd_elf, core_find_build_id)\n   Elf_Internal_Ehdr i_ehdr;\t/* Elf file header, internal form.   */\n   Elf_Internal_Phdr *i_phdr;\n   unsigned int i;\n+  size_t amt;\n \n   /* Seek to the position of the segment at OFFSET.  */\n   if (bfd_seek (abfd, offset, SEEK_SET) != 0)\n@@ -384,8 +385,12 @@ NAME(_bfd_elf, core_find_build_id)\n     goto fail;\n \n   /* Read in program headers.  */\n-  i_phdr = (Elf_Internal_Phdr *) bfd_alloc2 (abfd, i_ehdr.e_phnum,\n-\t\t\t\t\t     sizeof (*i_phdr));\n+  if (_bfd_mul_overflow (i_ehdr.e_phnum, sizeof (*i_phdr), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto fail;\n+    }\n+  i_phdr = (Elf_Internal_Phdr *) bfd_alloc (abfd, amt);\n   if (i_phdr == NULL)\n     goto fail;\n "
    },
    {
      "sha": "81ed9b390a041d069163f0be00e84b91a686adee",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 11,
      "deletions": 5,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -1413,18 +1413,24 @@ _bfd_mips_elf_read_ecoff_info (bfd *abfd, asection *section,\n   /* The symbolic header contains absolute file offsets and sizes to\n      read.  */\n #define READ(ptr, offset, count, size, type)\t\t\t\t\\\n-  if (symhdr->count == 0)\t\t\t\t\t\t\\\n-    debug->ptr = NULL;\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      bfd_size_type amt = (bfd_size_type) size * symhdr->count;\t\t\\\n+      size_t amt;\t\t\t\t\t\t\t\\\n+      debug->ptr = NULL;\t\t\t\t\t\t\\\n+      if (symhdr->count == 0)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      if (_bfd_mul_overflow (size, symhdr->count, &amt))\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  bfd_set_error (bfd_error_file_too_big);\t\t\t\\\n+\t  goto error_return;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       debug->ptr = bfd_malloc (amt);\t\t\t\t\t\\\n       if (debug->ptr == NULL)\t\t\t\t\t\t\\\n \tgoto error_return;\t\t\t\t\t\t\\\n       if (bfd_seek (abfd, symhdr->offset, SEEK_SET) != 0\t\t\\\n \t  || bfd_bread (debug->ptr, amt, abfd) != amt)\t\t\t\\\n \tgoto error_return;\t\t\t\t\t\t\\\n-    }\n+    } while (0)\n \n   READ (line, cbLineOffset, cbLine, sizeof (unsigned char), unsigned char *);\n   READ (external_dnr, cbDnOffset, idnMax, swap->external_dnr_size, void *);"
    },
    {
      "sha": "00650c3c86d13bbd6e453fff0701e0c8b48e64ba",
      "filename": "bfd/libbfd-in.h",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd-in.h?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -116,12 +116,6 @@ extern void *bfd_realloc_or_free\n   (void *, bfd_size_type) ATTRIBUTE_HIDDEN;\n extern void *bfd_zmalloc\n   (bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_malloc2\n-  (bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_realloc2\n-  (void *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_zmalloc2\n-  (bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n \n static inline char *\n bfd_strdup (const char *str)\n@@ -134,10 +128,6 @@ bfd_strdup (const char *str)\n }\n /* These routines allocate and free things on the BFD's objalloc.  */\n \n-extern void *bfd_alloc2\n-  (bfd *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_zalloc2\n-  (bfd *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n extern void bfd_release\n   (bfd *, void *) ATTRIBUTE_HIDDEN;\n \n@@ -905,3 +895,11 @@ extern bfd_signed_vma _bfd_read_signed_leb128\n extern bfd_vma _bfd_safe_read_leb128\n   (bfd *, bfd_byte *, unsigned int *, bfd_boolean, const bfd_byte * const)\n   ATTRIBUTE_HIDDEN;\n+\n+#if GCC_VERSION >= 7000\n+#define _bfd_mul_overflow(a, b, res) __builtin_mul_overflow (a, b, res)\n+#else\n+/* Assumes unsigned values.  Careful!  Args evaluated multiple times.  */\n+#define _bfd_mul_overflow(a, b, res) \\\n+  ((*res) = (a), (*res) *= (b), (b) != 0 && (*res) / (b) != (a))\n+#endif"
    },
    {
      "sha": "cb7c3b5aba0872bf7666da5db5b054b1bdc76fc5",
      "filename": "bfd/libbfd.c",
      "status": "modified",
      "additions": 0,
      "deletions": 53,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -279,24 +279,6 @@ bfd_malloc (bfd_size_type size)\n   return ptr;\n }\n \n-/* Allocate memory using malloc, nmemb * size with overflow checking.  */\n-\n-void *\n-bfd_malloc2 (bfd_size_type nmemb, bfd_size_type size)\n-{\n-  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE\n-      && size != 0\n-      && nmemb > ~(bfd_size_type) 0 / size)\n-    {\n-      bfd_set_error (bfd_error_no_memory);\n-      return NULL;\n-    }\n-\n-  return bfd_malloc (size * nmemb);\n-}\n-\n-/* Reallocate memory using realloc.  */\n-\n void *\n bfd_realloc (void *ptr, bfd_size_type size)\n {\n@@ -322,22 +304,6 @@ bfd_realloc (void *ptr, bfd_size_type size)\n   return ret;\n }\n \n-/* Reallocate memory using realloc, nmemb * size with overflow checking.  */\n-\n-void *\n-bfd_realloc2 (void *ptr, bfd_size_type nmemb, bfd_size_type size)\n-{\n-  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE\n-      && size != 0\n-      && nmemb > ~(bfd_size_type) 0 / size)\n-    {\n-      bfd_set_error (bfd_error_no_memory);\n-      return NULL;\n-    }\n-\n-  return bfd_realloc (ptr, size * nmemb);\n-}\n-\n /* Reallocate memory using realloc.\n    If this fails the pointer is freed before returning.  */\n \n@@ -365,25 +331,6 @@ bfd_zmalloc (bfd_size_type size)\n   return ptr;\n }\n \n-/* Allocate memory using malloc (nmemb * size) with overflow checking\n-   and clear it.  */\n-\n-void *\n-bfd_zmalloc2 (bfd_size_type nmemb, bfd_size_type size)\n-{\n-  void *ptr = bfd_malloc2 (nmemb, size);\n-\n-  if (ptr != NULL)\n-    {\n-      size_t sz = nmemb * size;\n-\n-      if (sz > 0)\n-\tmemset (ptr, 0, sz);\n-    }\n-\n-  return ptr;\n-}\n-\n /*\n INTERNAL_FUNCTION\n \tbfd_write_bigendian_4byte_int"
    },
    {
      "sha": "7fcd46a38a34f1143b0f00ef464b2a7b46661215",
      "filename": "bfd/libbfd.h",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/libbfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.h?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -121,12 +121,6 @@ extern void *bfd_realloc_or_free\n   (void *, bfd_size_type) ATTRIBUTE_HIDDEN;\n extern void *bfd_zmalloc\n   (bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_malloc2\n-  (bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_realloc2\n-  (void *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_zmalloc2\n-  (bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n \n static inline char *\n bfd_strdup (const char *str)\n@@ -139,10 +133,6 @@ bfd_strdup (const char *str)\n }\n /* These routines allocate and free things on the BFD's objalloc.  */\n \n-extern void *bfd_alloc2\n-  (bfd *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n-extern void *bfd_zalloc2\n-  (bfd *, bfd_size_type, bfd_size_type) ATTRIBUTE_HIDDEN;\n extern void bfd_release\n   (bfd *, void *) ATTRIBUTE_HIDDEN;\n \n@@ -910,6 +900,14 @@ extern bfd_signed_vma _bfd_read_signed_leb128\n extern bfd_vma _bfd_safe_read_leb128\n   (bfd *, bfd_byte *, unsigned int *, bfd_boolean, const bfd_byte * const)\n   ATTRIBUTE_HIDDEN;\n+\n+#if GCC_VERSION >= 7000\n+#define _bfd_mul_overflow(a, b, res) __builtin_mul_overflow (a, b, res)\n+#else\n+/* Assumes unsigned values.  Careful!  Args evaluated multiple times.  */\n+#define _bfd_mul_overflow(a, b, res) \\\n+  ((*res) = (a), (*res) *= (b), (b) != 0 && (*res) / (b) != (a))\n+#endif\n /* Extracted from libbfd.c.  */\n bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);\n "
    },
    {
      "sha": "1cc9d432503f84eb4ae519271cf7bd92cdc390e1",
      "filename": "bfd/mach-o.c",
      "status": "modified",
      "additions": 72,
      "deletions": 19,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/mach-o.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/mach-o.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -2554,6 +2554,7 @@ bfd_mach_o_mangle_sections (bfd *abfd, bfd_mach_o_data_struct *mdata)\n   asection *sec;\n   unsigned target_index;\n   unsigned nsect;\n+  size_t amt;\n \n   nsect = bfd_count_sections (abfd);\n \n@@ -2572,8 +2573,12 @@ bfd_mach_o_mangle_sections (bfd *abfd, bfd_mach_o_data_struct *mdata)\n     }\n \n   mdata->nsects = nsect;\n-  mdata->sections = bfd_alloc2 (abfd,\n-\t\t\t\tmdata->nsects, sizeof (bfd_mach_o_section *));\n+  if (_bfd_mul_overflow (mdata->nsects, sizeof (bfd_mach_o_section *), &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      return FALSE;\n+    }\n+  mdata->sections = bfd_alloc (abfd, amt);\n   if (mdata->sections == NULL)\n     return FALSE;\n \n@@ -3923,14 +3928,16 @@ bfd_mach_o_read_symtab_symbols (bfd *abfd)\n   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);\n   bfd_mach_o_symtab_command *sym = mdata->symtab;\n   unsigned long i;\n+  size_t amt;\n \n   if (sym == NULL || sym->symbols)\n     /* Return now if there are no symbols or if already loaded.  */\n     return TRUE;\n \n-  sym->symbols = bfd_alloc2 (abfd, sym->nsyms, sizeof (bfd_mach_o_asymbol));\n-  if (sym->symbols == NULL)\n+  if (_bfd_mul_overflow (sym->nsyms, sizeof (bfd_mach_o_asymbol), &amt)\n+      || (sym->symbols = bfd_alloc (abfd, amt)) == NULL)\n     {\n+      bfd_set_error (bfd_error_no_memory);\n       _bfd_error_handler (_(\"bfd_mach_o_read_symtab_symbols: \"\n \t\t\t    \"unable to allocate memory for symbols\"));\n       sym->nsyms = 0;\n@@ -4174,6 +4181,7 @@ bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)\n   unsigned int nflavours;\n   unsigned int i;\n   struct mach_o_thread_command_external raw;\n+  size_t amt;\n \n   BFD_ASSERT ((command->type == BFD_MACH_O_LC_THREAD)\n \t      || (command->type == BFD_MACH_O_LC_UNIXTHREAD));\n@@ -4200,8 +4208,12 @@ bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)\n     return FALSE;\n \n   /* Allocate threads.  */\n-  cmd->flavours = bfd_alloc2 (abfd, nflavours,\n-\t\t\t      sizeof (bfd_mach_o_thread_flavour));\n+  if (_bfd_mul_overflow (nflavours, sizeof (bfd_mach_o_thread_flavour), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  cmd->flavours = bfd_alloc (abfd, amt);\n   if (cmd->flavours == NULL)\n     return FALSE;\n   cmd->nflavours = nflavours;\n@@ -4315,9 +4327,15 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)\n       unsigned int i;\n       int wide = bfd_mach_o_wide_p (abfd);\n       unsigned int module_len = wide ? 56 : 52;\n+      size_t amt;\n \n-      cmd->dylib_module =\n-\tbfd_alloc2 (abfd, cmd->nmodtab, sizeof (bfd_mach_o_dylib_module));\n+      if (_bfd_mul_overflow (cmd->nmodtab,\n+\t\t\t     sizeof (bfd_mach_o_dylib_module), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n+      cmd->dylib_module = bfd_alloc (abfd, amt);\n       if (cmd->dylib_module == NULL)\n \treturn FALSE;\n \n@@ -4364,9 +4382,15 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)\n   if (cmd->ntoc != 0)\n     {\n       unsigned long i;\n+      size_t amt;\n \n-      cmd->dylib_toc = bfd_alloc2\n-\t(abfd, cmd->ntoc, sizeof (bfd_mach_o_dylib_table_of_content));\n+      if (_bfd_mul_overflow (cmd->ntoc,\n+\t\t\t     sizeof (bfd_mach_o_dylib_table_of_content), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n+      cmd->dylib_toc = bfd_alloc (abfd, amt);\n       if (cmd->dylib_toc == NULL)\n \treturn FALSE;\n \n@@ -4389,9 +4413,14 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)\n   if (cmd->nindirectsyms != 0)\n     {\n       unsigned int i;\n+      size_t amt;\n \n-      cmd->indirect_syms = bfd_alloc2\n-\t(abfd, cmd->nindirectsyms, sizeof (unsigned int));\n+      if (_bfd_mul_overflow (cmd->nindirectsyms, sizeof (unsigned int), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n+      cmd->indirect_syms = bfd_alloc (abfd, amt);\n       if (cmd->indirect_syms == NULL)\n \treturn FALSE;\n \n@@ -4414,9 +4443,15 @@ bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)\n     {\n       unsigned long v;\n       unsigned int i;\n+      size_t amt;\n \n-      cmd->ext_refs = bfd_alloc2\n-\t(abfd, cmd->nextrefsyms, sizeof (bfd_mach_o_dylib_reference));\n+      if (_bfd_mul_overflow (cmd->nextrefsyms,\n+\t\t\t     sizeof (bfd_mach_o_dylib_reference), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n+      cmd->ext_refs = bfd_alloc (abfd, amt);\n       if (cmd->ext_refs == NULL)\n \treturn FALSE;\n \n@@ -5005,6 +5040,7 @@ bfd_mach_o_flatten_sections (bfd *abfd)\n   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);\n   bfd_mach_o_load_command *cmd;\n   long csect = 0;\n+  size_t amt;\n \n   /* Count total number of sections.  */\n   mdata->nsects = 0;\n@@ -5021,8 +5057,12 @@ bfd_mach_o_flatten_sections (bfd *abfd)\n     }\n \n   /* Allocate sections array.  */\n-  mdata->sections = bfd_alloc2 (abfd,\n-\t\t\t\tmdata->nsects, sizeof (bfd_mach_o_section *));\n+  if (_bfd_mul_overflow (mdata->nsects, sizeof (bfd_mach_o_section *), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  mdata->sections = bfd_alloc (abfd, amt);\n   if (mdata->sections == NULL && mdata->nsects != 0)\n     return FALSE;\n \n@@ -5195,11 +5235,18 @@ bfd_mach_o_scan (bfd *abfd,\n   if (header->ncmds != 0)\n     {\n       bfd_mach_o_load_command *cmd;\n+      size_t amt;\n \n       mdata->first_command = NULL;\n       mdata->last_command = NULL;\n \n-      cmd = bfd_alloc2 (abfd, header->ncmds, sizeof (bfd_mach_o_load_command));\n+      if (_bfd_mul_overflow (header->ncmds,\n+\t\t\t     sizeof (bfd_mach_o_load_command), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n+      cmd = bfd_alloc (abfd, amt);\n       if (cmd == NULL)\n \treturn FALSE;\n \n@@ -5418,6 +5465,7 @@ bfd_mach_o_fat_archive_p (bfd *abfd)\n   mach_o_fat_data_struct *adata = NULL;\n   struct mach_o_fat_header_external hdr;\n   unsigned long i;\n+  size_t amt;\n \n   if (bfd_seek (abfd, 0, SEEK_SET) != 0\n       || bfd_bread (&hdr, sizeof (hdr), abfd) != sizeof (hdr))\n@@ -5437,8 +5485,13 @@ bfd_mach_o_fat_archive_p (bfd *abfd)\n   if (adata->nfat_arch > 30)\n     goto error;\n \n-  adata->archentries =\n-    bfd_alloc2 (abfd, adata->nfat_arch, sizeof (mach_o_fat_archentry));\n+  if (_bfd_mul_overflow (adata->nfat_arch,\n+\t\t\t sizeof (mach_o_fat_archentry), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto error;\n+    }\n+  adata->archentries = bfd_alloc (abfd, amt);\n   if (adata->archentries == NULL)\n     goto error;\n "
    },
    {
      "sha": "99097a9e39989e377af70e9450a970b009439e70",
      "filename": "bfd/opncls.c",
      "status": "modified",
      "additions": 0,
      "deletions": 59,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/opncls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/opncls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/opncls.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -981,32 +981,6 @@ bfd_alloc (bfd *abfd, bfd_size_type size)\n   return ret;\n }\n \n-/*\n-INTERNAL_FUNCTION\n-\tbfd_alloc2\n-\n-SYNOPSIS\n-\tvoid *bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);\n-\n-DESCRIPTION\n-\tAllocate a block of @var{nmemb} elements of @var{size} bytes each\n-\tof memory attached to <<abfd>> and return a pointer to it.\n-*/\n-\n-void *\n-bfd_alloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)\n-{\n-  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE\n-      && size != 0\n-      && nmemb > ~(bfd_size_type) 0 / size)\n-    {\n-      bfd_set_error (bfd_error_no_memory);\n-      return NULL;\n-    }\n-\n-  return bfd_alloc (abfd, size * nmemb);\n-}\n-\n /*\n FUNCTION\n \tbfd_zalloc\n@@ -1030,39 +1004,6 @@ bfd_zalloc (bfd *abfd, bfd_size_type size)\n   return res;\n }\n \n-/*\n-INTERNAL_FUNCTION\n-\tbfd_zalloc2\n-\n-SYNOPSIS\n-\tvoid *bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size);\n-\n-DESCRIPTION\n-\tAllocate a block of @var{nmemb} elements of @var{size} bytes each\n-\tof zeroed memory attached to <<abfd>> and return a pointer to it.\n-*/\n-\n-void *\n-bfd_zalloc2 (bfd *abfd, bfd_size_type nmemb, bfd_size_type size)\n-{\n-  void *res;\n-\n-  if ((nmemb | size) >= HALF_BFD_SIZE_TYPE\n-      && size != 0\n-      && nmemb > ~(bfd_size_type) 0 / size)\n-    {\n-      bfd_set_error (bfd_error_no_memory);\n-      return NULL;\n-    }\n-\n-  size *= nmemb;\n-\n-  res = bfd_alloc (abfd, size);\n-  if (res)\n-    memset (res, 0, (size_t) size);\n-  return res;\n-}\n-\n /* Free a block allocated for a BFD.\n    Note:  Also frees all more recently allocated blocks!  */\n "
    },
    {
      "sha": "d7d4d8f845f37938a7aa7519ae82738a4ac82992",
      "filename": "bfd/som.c",
      "status": "modified",
      "additions": 108,
      "deletions": 39,
      "changes": 147,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/som.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/som.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/som.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -2079,17 +2079,17 @@ setup_sections (bfd *abfd,\n   unsigned int total_subspaces = 0;\n   asection **subspace_sections = NULL;\n   asection *section;\n-  bfd_size_type amt;\n+  size_t amt;\n \n   /* First, read in space names.  */\n   amt = file_hdr->space_strings_size;\n-  if (amt == (bfd_size_type) -1)\n+  if (amt == (size_t) -1)\n     {\n       bfd_set_error (bfd_error_no_memory);\n       goto error_return;\n     }\n   space_strings = bfd_malloc (amt + 1);\n-  if (space_strings == NULL && amt != 0)\n+  if (space_strings == NULL)\n     goto error_return;\n \n   if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location,\n@@ -2344,7 +2344,12 @@ setup_sections (bfd *abfd,\n     }\n   /* Now that we've read in all the subspace records, we need to assign\n      a target index to each subspace.  */\n-  subspace_sections = bfd_malloc2 (total_subspaces, sizeof (asection *));\n+  if (_bfd_mul_overflow (total_subspaces, sizeof (asection *), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto error_return;\n+    }\n+  subspace_sections = bfd_malloc (amt);\n   if (subspace_sections == NULL)\n     goto error_return;\n \n@@ -2804,6 +2809,7 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n   unsigned long i;\n   asection *section;\n   asymbol **sorted_syms;\n+  size_t amt;\n \n   /* Most SOM relocations involving a symbol have a length which is\n      dependent on the index of the symbol.  So symbols which are\n@@ -2875,7 +2881,12 @@ som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)\n \n   /* Sort a copy of the symbol table, rather than the canonical\n      output symbol table.  */\n-  sorted_syms = bfd_zalloc2 (abfd, num_syms, sizeof (asymbol *));\n+  if (_bfd_mul_overflow (num_syms, sizeof (asymbol *), &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      return FALSE;\n+    }\n+  sorted_syms = bfd_zalloc (abfd, amt);\n   if (sorted_syms == NULL)\n     return FALSE;\n   memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));\n@@ -4460,12 +4471,18 @@ som_build_and_write_symbol_table (bfd *abfd)\n   struct som_external_symbol_dictionary_record *som_symtab = NULL;\n   unsigned int i;\n   bfd_size_type symtab_size;\n+  size_t amt;\n \n   /* Compute total symbol table size and allocate a chunk of memory\n      to hold the symbol table as we build it.  */\n-  som_symtab\n-    = bfd_zmalloc2 (num_syms,\n-\t\t    sizeof (struct som_external_symbol_dictionary_record));\n+  if (_bfd_mul_overflow (num_syms,\n+\t\t\t sizeof (struct som_external_symbol_dictionary_record),\n+\t\t\t &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      return FALSE;\n+    }\n+  som_symtab = bfd_zmalloc (amt);\n   if (som_symtab == NULL && num_syms != 0)\n     goto error_return;\n \n@@ -4638,12 +4655,12 @@ bfd_section_from_som_symbol\n static unsigned int\n som_slurp_symbol_table (bfd *abfd)\n {\n-  int symbol_count = bfd_get_symcount (abfd);\n-  int symsize = sizeof (struct som_external_symbol_dictionary_record);\n+  unsigned int symbol_count = bfd_get_symcount (abfd);\n+  size_t symsize = sizeof (struct som_external_symbol_dictionary_record);\n   char *stringtab;\n   struct som_external_symbol_dictionary_record *buf = NULL, *bufp, *endbufp;\n   som_symbol_type *sym, *symbase;\n-  bfd_size_type amt;\n+  size_t amt;\n \n   /* Return saved value if it exists.  */\n   if (obj_som_symtab (abfd) != NULL)\n@@ -4658,18 +4675,26 @@ som_slurp_symbol_table (bfd *abfd)\n \n   stringtab = obj_som_stringtab (abfd);\n \n-  symbase = bfd_zmalloc2 (symbol_count, sizeof (som_symbol_type));\n+  if (_bfd_mul_overflow (symbol_count, sizeof (som_symbol_type), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto error_return;\n+    }\n+  symbase = bfd_zmalloc (amt);\n   if (symbase == NULL)\n     goto error_return;\n \n   /* Read in the external SOM representation.  */\n-  buf = bfd_malloc2 (symbol_count, symsize);\n+  if (_bfd_mul_overflow (symbol_count, symsize, &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto error_return;\n+    }\n+  buf = bfd_malloc (amt);\n   if (buf == NULL)\n     goto error_return;\n   if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) != 0)\n     goto error_return;\n-  amt = symbol_count;\n-  amt *= symsize;\n   if (bfd_bread (buf, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5259,7 +5284,7 @@ som_slurp_reloc_table (bfd *abfd,\n   unsigned int fixup_stream_size;\n   arelent *internal_relocs;\n   unsigned int num_relocs;\n-  bfd_size_type amt;\n+  size_t amt;\n \n   fixup_stream_size = som_section_data (section)->reloc_size;\n   /* If there were no relocations, then there is nothing to do.  */\n@@ -5303,7 +5328,12 @@ som_slurp_reloc_table (bfd *abfd,\n   if (section->relocation != NULL)\n     return TRUE;\n \n-  internal_relocs = bfd_zalloc2 (abfd, num_relocs, sizeof (arelent));\n+  if (_bfd_mul_overflow (num_relocs, sizeof (arelent), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  internal_relocs = bfd_zalloc (abfd, amt);\n   if (internal_relocs == NULL)\n     return FALSE;\n \n@@ -5884,12 +5914,17 @@ som_bfd_count_ar_symbols (bfd *abfd,\n {\n   unsigned int i;\n   unsigned char *hash_table;\n-  bfd_size_type amt;\n+  size_t amt;\n   file_ptr lst_filepos;\n \n   lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);\n \n-  hash_table = bfd_malloc2 (lst_header->hash_size, 4);\n+  if (_bfd_mul_overflow (lst_header->hash_size, 4, &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  hash_table = bfd_malloc (amt);\n   if (hash_table == NULL && lst_header->hash_size != 0)\n     goto error_return;\n \n@@ -5898,7 +5933,6 @@ som_bfd_count_ar_symbols (bfd *abfd,\n \n   /* Read in the hash table.  The hash table is an array of 32-bit\n      file offsets which point to the hash chains.  */\n-  amt = (bfd_size_type) lst_header->hash_size * 4;\n   if (bfd_bread ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5975,18 +6009,22 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n   carsym *set = syms[0];\n   unsigned char *hash_table;\n   struct som_external_som_entry *som_dict = NULL;\n-  bfd_size_type amt;\n+  size_t amt;\n   file_ptr lst_filepos;\n   unsigned int string_loc;\n \n   lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);\n-  hash_table = bfd_malloc2 (lst_header->hash_size, 4);\n+  if (_bfd_mul_overflow (lst_header->hash_size, 4, &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  hash_table = bfd_malloc (amt);\n   if (hash_table == NULL && lst_header->hash_size != 0)\n     goto error_return;\n \n   /* Read in the hash table.  The has table is an array of 32bit file offsets\n      which point to the hash chains.  */\n-  amt = (bfd_size_type) lst_header->hash_size * 4;\n   if (bfd_bread ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n@@ -5995,13 +6033,16 @@ som_bfd_fill_in_ar_symbols (bfd *abfd,\n   if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) != 0)\n     goto error_return;\n \n-  som_dict = bfd_malloc2 (lst_header->module_count,\n-\t\t\t  sizeof (struct som_external_som_entry));\n+  if (_bfd_mul_overflow (lst_header->module_count,\n+\t\t\t sizeof (struct som_external_som_entry), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      goto error_return;\n+    }\n+  som_dict = bfd_malloc (amt);\n   if (som_dict == NULL && lst_header->module_count != 0)\n     goto error_return;\n \n-  amt = lst_header->module_count;\n-  amt *= sizeof (struct som_external_som_entry);\n   if (bfd_bread ((void *) som_dict, amt, abfd) != amt)\n     goto error_return;\n \n@@ -6156,7 +6197,7 @@ som_slurp_armap (bfd *abfd)\n   unsigned int parsed_size;\n   struct artdata *ardata = bfd_ardata (abfd);\n   char nextname[17];\n-  bfd_size_type amt = 16;\n+  size_t amt = 16;\n   int i = bfd_bread ((void *) nextname, amt, abfd);\n \n   /* Special cases.  */\n@@ -6225,7 +6266,12 @@ som_slurp_armap (bfd *abfd)\n \n   /* Initialize the cache and allocate space for the library symbols.  */\n   ardata->cache = 0;\n-  ardata->symdefs = bfd_alloc2 (abfd, ardata->symdef_count, sizeof (carsym));\n+  if (_bfd_mul_overflow (ardata->symdef_count, sizeof (carsym), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  ardata->symdefs = bfd_alloc (abfd, amt);\n   if (!ardata->symdefs)\n     return FALSE;\n \n@@ -6352,22 +6398,39 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n   struct som_external_som_entry *som_dict = NULL;\n   struct som_external_lst_symbol_record **last_hash_entry = NULL;\n   unsigned int curr_som_offset, som_index = 0;\n-  bfd_size_type amt;\n+  size_t amt;\n   unsigned int module_count;\n   unsigned int hash_size;\n \n   hash_size = bfd_getb32 (lst.hash_size);\n-  hash_table = bfd_zmalloc2 (hash_size, 4);\n+  if (_bfd_mul_overflow (hash_size, 4, &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      return FALSE;\n+    }\n+  hash_table = bfd_zmalloc (amt);\n   if (hash_table == NULL && hash_size != 0)\n     goto error_return;\n \n   module_count = bfd_getb32 (lst.module_count);\n-  som_dict = bfd_zmalloc2 (module_count, sizeof (struct som_external_som_entry));\n+  if (_bfd_mul_overflow (module_count,\n+\t\t\t sizeof (struct som_external_som_entry), &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      goto error_return;\n+    }\n+  som_dict = bfd_zmalloc (amt);\n   if (som_dict == NULL && module_count != 0)\n     goto error_return;\n \n-  last_hash_entry\n-    = bfd_zmalloc2 (hash_size, sizeof (struct som_external_lst_symbol_record *));\n+  if (_bfd_mul_overflow (hash_size,\n+\t\t\t sizeof (struct som_external_lst_symbol_record *),\n+\t\t\t &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      goto error_return;\n+    }\n+  last_hash_entry = bfd_zmalloc (amt);\n   if (last_hash_entry == NULL && hash_size != 0)\n     goto error_return;\n \n@@ -6395,10 +6458,16 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n   curr_som_offset = (curr_som_offset + 0x1) & ~0x1;\n \n   /* FIXME should be done with buffers just like everything else...  */\n-  lst_syms = bfd_malloc2 (nsyms, sizeof (struct som_external_lst_symbol_record));\n+  if (_bfd_mul_overflow (nsyms,\n+\t\t\t sizeof (struct som_external_lst_symbol_record), &amt))\n+    {\n+      bfd_set_error (bfd_error_no_memory);\n+      goto error_return;\n+    }\n+  lst_syms = bfd_malloc (amt);\n   if (lst_syms == NULL && nsyms != 0)\n     goto error_return;\n-  strings = bfd_malloc ((bfd_size_type) string_size);\n+  strings = bfd_malloc (string_size);\n   if (strings == NULL && string_size != 0)\n     goto error_return;\n \n@@ -6543,17 +6612,17 @@ som_bfd_ar_write_symbol_stuff (bfd *abfd,\n     }\n \n   /* Now scribble out the hash table.  */\n-  amt = (bfd_size_type) hash_size * 4;\n+  amt = (size_t) hash_size * 4;\n   if (bfd_bwrite ((void *) hash_table, amt, abfd) != amt)\n     goto error_return;\n \n   /* Then the SOM dictionary.  */\n-  amt = (bfd_size_type) module_count * sizeof (struct som_external_som_entry);\n+  amt = (size_t) module_count * sizeof (struct som_external_som_entry);\n   if (bfd_bwrite ((void *) som_dict, amt, abfd) != amt)\n     goto error_return;\n \n   /* The library symbols.  */\n-  amt = (bfd_size_type) nsyms * sizeof (struct som_external_lst_symbol_record);\n+  amt = (size_t) nsyms * sizeof (struct som_external_lst_symbol_record);\n   if (bfd_bwrite ((void *) lst_syms, amt, abfd) != amt)\n     goto error_return;\n "
    },
    {
      "sha": "24842780b6d1c09da332d0b20ffbd4c43ebda294",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -2963,17 +2963,23 @@ vector_grow1 (struct vector_type *vec, size_t elsz)\n       if (vec->max_el == 0)\n \t{\n \t  vec->max_el = 16;\n-\t  vec->els = bfd_malloc2 (vec->max_el, elsz);\n+\t  vec->els = bfd_malloc (vec->max_el * elsz);\n \t}\n       else\n \t{\n+\t  size_t amt;\n \t  if (vec->max_el > -1u / 2)\n \t    {\n \t      bfd_set_error (bfd_error_file_too_big);\n \t      return NULL;\n \t    }\n \t  vec->max_el *= 2;\n-\t  vec->els = bfd_realloc2 (vec->els, vec->max_el, elsz);\n+\t  if (_bfd_mul_overflow (vec->max_el, elsz, &amt))\n+\t    {\n+\t      bfd_set_error (bfd_error_file_too_big);\n+\t      return NULL;\n+\t    }\n+\t  vec->els = bfd_realloc (vec->els, amt);\n \t}\n     }\n   if (vec->els == NULL)"
    },
    {
      "sha": "dc07e79710c39624cc93b4c7130bf6287f0cb48d",
      "filename": "bfd/vms-lib.c",
      "status": "modified",
      "additions": 13,
      "deletions": 2,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/vms-lib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/vms-lib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-lib.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -134,20 +134,31 @@ vms_add_index (struct carsym_mem *cs, char *name,\n   if (cs->nbr == cs->max)\n     {\n       struct carsym *n;\n+      size_t amt;\n \n+      if (cs->max > -33u / 2)\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n       cs->max = 2 * cs->max + 32;\n+      if (_bfd_mul_overflow (cs->max, sizeof (struct carsym), &amt))\n+\t{\n+\t  bfd_set_error (bfd_error_file_too_big);\n+\t  return FALSE;\n+\t}\n \n       if (!cs->realloced)\n \t{\n-\t  n = bfd_malloc2 (cs->max, sizeof (struct carsym));\n+\t  n = bfd_malloc (amt);\n \t  if (n == NULL)\n \t    return FALSE;\n \t  memcpy (n, cs->idx, cs->nbr * sizeof (struct carsym));\n \t  /* And unfortunately we can't free cs->idx.  */\n \t}\n       else\n \t{\n-\t  n = bfd_realloc_or_free (cs->idx, cs->nbr * sizeof (struct carsym));\n+\t  n = bfd_realloc_or_free (cs->idx, amt);\n \t  if (n == NULL)\n \t    return FALSE;\n \t}"
    },
    {
      "sha": "315d3effb8db4dd554440cd396c224216a2a2c75",
      "filename": "bfd/wasm-module.c",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/wasm-module.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f4361a77b18c5ab32baf2f30fefe5e301e017be/bfd/wasm-module.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/wasm-module.c?ref=1f4361a77b18c5ab32baf2f30fefe5e301e017be",
      "patch": "@@ -245,6 +245,7 @@ wasm_scan_name_function_section (bfd *abfd, sec_ptr asect)\n   tdata_type *tdata = abfd->tdata.any;\n   asymbol *symbols = NULL;\n   sec_ptr space_function_index;\n+  size_t amt;\n \n   p = asect->contents;\n   end = asect->contents + asect->size;\n@@ -301,7 +302,12 @@ wasm_scan_name_function_section (bfd *abfd, sec_ptr asect)\n   if (!space_function_index)\n     return FALSE;\n \n-  symbols = bfd_alloc2 (abfd, tdata->symcount, sizeof (asymbol));\n+  if (_bfd_mul_overflow (tdata->symcount, sizeof (asymbol), &amt))\n+    {\n+      bfd_set_error (bfd_error_file_too_big);\n+      return FALSE;\n+    }\n+  symbols = bfd_alloc (abfd, amt);\n   if (!symbols)\n     return FALSE;\n "
    }
  ]
}