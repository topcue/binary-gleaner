{
  "sha": "a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTk5YmU4YzE5OWMyY2JmYWUxMzdmYjVhNTQxNTFlNzgxZWNiN2VjMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:40Z"
    },
    "message": "Remove now-unused Fortran evaluator code\n\nNow that the Fortran parser has switched to the new style, there is no\nneed for the old Fortran evaluation code.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* f-lang.h (class f_language) <expresssion_ops>: Remove.\n\t<exp_descriptor_tab>: Remove.\n\t* f-lang.c (fortran_value_subarray, evaluate_subexp_f)\n\t(operator_length_f, print_unop_subexp_f, print_binop_subexp_f)\n\t(print_subexp_f, dump_subexp_body_f, operator_check_f)\n\t(f_language::exp_descriptor_tab, fortran_prepare_argument):\n\tRemove.",
    "tree": {
      "sha": "034d3afed2183ae996ded937f32bdcb431f6c5f4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/034d3afed2183ae996ded937f32bdcb431f6c5f4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "aa1da9ed50fba2474438f83e6da577bb01ed4613",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aa1da9ed50fba2474438f83e6da577bb01ed4613",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/aa1da9ed50fba2474438f83e6da577bb01ed4613"
    }
  ],
  "stats": {
    "total": 994,
    "additions": 47,
    "deletions": 947
  },
  "files": [
    {
      "sha": "f63c3612a0b6bddb32825ab1e39fb31919fe2be6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* f-lang.h (class f_language) <expresssion_ops>: Remove.\n+\t<exp_descriptor_tab>: Remove.\n+\t* f-lang.c (fortran_value_subarray, evaluate_subexp_f)\n+\t(operator_length_f, print_unop_subexp_f, print_binop_subexp_f)\n+\t(print_subexp_f, dump_subexp_body_f, operator_check_f)\n+\t(f_language::exp_descriptor_tab, fortran_prepare_argument):\n+\tRemove.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* rust-lang.h (class rust_language) <expression_ops,"
    },
    {
      "sha": "465fea26fbb1ec9c2dfafa46c419fe42cd0ac330",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 37,
      "deletions": 937,
      "changes": 974,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
      "patch": "@@ -69,10 +69,6 @@ show_fortran_array_slicing_debug (struct ui_file *file, int from_tty,\n \n /* Local functions */\n \n-static value *fortran_prepare_argument (struct expression *exp, int *pos,\n-\t\t\t\t\tint arg_num, bool is_internal_call_p,\n-\t\t\t\t\tstruct type *func_type,\n-\t\t\t\t\tenum noside noside);\n static value *fortran_prepare_argument (struct expression *exp,\n \t\t\t\t\texpr::operation *subexp,\n \t\t\t\t\tint arg_num, bool is_internal_call_p,\n@@ -375,453 +371,47 @@ class fortran_lazy_array_repacker_impl\n /* A class used by FORTRAN_VALUE_SUBARRAY when repacking Fortran array\n    slices.  This class is specialised for repacking an array slice from a\n    previously loaded (non-lazy) array value, as such it fetches the\n-   element values from the contents of the parent value.  */\n-class fortran_array_repacker_impl\n-  : public fortran_array_repacker_base_impl\n-{\n-public:\n-  /* Constructor.  TYPE is the type for the array slice within the parent\n-     value, as such it has stride values as required to find the elements\n-     within the original parent value.  ADDRESS is the address in target\n-     memory of the value matching TYPE.  BASE_OFFSET is the offset from\n-     the start of VAL's content buffer to the start of the object of TYPE,\n-     VAL is the parent object from which we are loading the value, and\n-     DEST is the value into which we are repacking.  */\n-  explicit fortran_array_repacker_impl (struct type *type, CORE_ADDR address,\n-\t\t\t\t\tLONGEST base_offset,\n-\t\t\t\t\tstruct value *val, struct value *dest)\n-    : fortran_array_repacker_base_impl (dest),\n-      m_base_offset (base_offset),\n-      m_val (val)\n-  {\n-    gdb_assert (!value_lazy (val));\n-  }\n-\n-  /* Extract an element of ELT_TYPE at offset (M_BASE_OFFSET + ELT_OFF)\n-     from the content buffer of M_VAL then copy this extracted value into\n-     the repacked destination value.  */\n-  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n-  {\n-    struct value *elt\n-      = value_from_component (m_val, elt_type, (elt_off + m_base_offset));\n-    copy_element_to_dest (elt);\n-  }\n-\n-private:\n-  /* The offset into the content buffer of M_VAL to the start of the slice\n-     being extracted.  */\n-  LONGEST m_base_offset;\n-\n-  /* The parent value from which we are extracting a slice.  */\n-  struct value *m_val;\n-};\n-\n-/* Called from evaluate_subexp_standard to perform array indexing, and\n-   sub-range extraction, for Fortran.  As well as arrays this function\n-   also handles strings as they can be treated like arrays of characters.\n-   ARRAY is the array or string being accessed.  EXP, POS, and NOSIDE are\n-   as for evaluate_subexp_standard, and NARGS is the number of arguments\n-   in this access (e.g. 'array (1,2,3)' would be NARGS 3).  */\n-\n-static struct value *\n-fortran_value_subarray (struct value *array, struct expression *exp,\n-\t\t\tint *pos, int nargs, enum noside noside)\n-{\n-  type *original_array_type = check_typedef (value_type (array));\n-  bool is_string_p = original_array_type->code () == TYPE_CODE_STRING;\n-\n-  /* Perform checks for ARRAY not being available.  The somewhat overly\n-     complex logic here is just to keep backward compatibility with the\n-     errors that we used to get before FORTRAN_VALUE_SUBARRAY was\n-     rewritten.  Maybe a future task would streamline the error messages we\n-     get here, and update all the expected test results.  */\n-  if (exp->elts[*pos].opcode != OP_RANGE)\n-    {\n-      if (type_not_associated (original_array_type))\n-\terror (_(\"no such vector element (vector not associated)\"));\n-      else if (type_not_allocated (original_array_type))\n-\terror (_(\"no such vector element (vector not allocated)\"));\n-    }\n-  else\n-    {\n-      if (type_not_associated (original_array_type))\n-\terror (_(\"array not associated\"));\n-      else if (type_not_allocated (original_array_type))\n-\terror (_(\"array not allocated\"));\n-    }\n-\n-  /* First check that the number of dimensions in the type we are slicing\n-     matches the number of arguments we were passed.  */\n-  int ndimensions = calc_f77_array_dims (original_array_type);\n-  if (nargs != ndimensions)\n-    error (_(\"Wrong number of subscripts\"));\n-\n-  /* This will be initialised below with the type of the elements held in\n-     ARRAY.  */\n-  struct type *inner_element_type;\n-\n-  /* Extract the types of each array dimension from the original array\n-     type.  We need these available so we can fill in the default upper and\n-     lower bounds if the user requested slice doesn't provide that\n-     information.  Additionally unpacking the dimensions like this gives us\n-     the inner element type.  */\n-  std::vector<struct type *> dim_types;\n-  {\n-    dim_types.reserve (ndimensions);\n-    struct type *type = original_array_type;\n-    for (int i = 0; i < ndimensions; ++i)\n-      {\n-\tdim_types.push_back (type);\n-\ttype = TYPE_TARGET_TYPE (type);\n-      }\n-    /* TYPE is now the inner element type of the array, we start the new\n-       array slice off as this type, then as we process the requested slice\n-       (from the user) we wrap new types around this to build up the final\n-       slice type.  */\n-    inner_element_type = type;\n-  }\n-\n-  /* As we analyse the new slice type we need to understand if the data\n-     being referenced is contiguous.  Do decide this we must track the size\n-     of an element at each dimension of the new slice array.  Initially the\n-     elements of the inner most dimension of the array are the same inner\n-     most elements as the original ARRAY.  */\n-  LONGEST slice_element_size = TYPE_LENGTH (inner_element_type);\n-\n-  /* Start off assuming all data is contiguous, this will be set to false\n-     if access to any dimension results in non-contiguous data.  */\n-  bool is_all_contiguous = true;\n-\n-  /* The TOTAL_OFFSET is the distance in bytes from the start of the\n-     original ARRAY to the start of the new slice.  This is calculated as\n-     we process the information from the user.  */\n-  LONGEST total_offset = 0;\n-\n-  /* A structure representing information about each dimension of the\n-     resulting slice.  */\n-  struct slice_dim\n-  {\n-    /* Constructor.  */\n-    slice_dim (LONGEST l, LONGEST h, LONGEST s, struct type *idx)\n-      : low (l),\n-\thigh (h),\n-\tstride (s),\n-\tindex (idx)\n-    { /* Nothing.  */ }\n-\n-    /* The low bound for this dimension of the slice.  */\n-    LONGEST low;\n-\n-    /* The high bound for this dimension of the slice.  */\n-    LONGEST high;\n-\n-    /* The byte stride for this dimension of the slice.  */\n-    LONGEST stride;\n-\n-    struct type *index;\n-  };\n-\n-  /* The dimensions of the resulting slice.  */\n-  std::vector<slice_dim> slice_dims;\n-\n-  /* Process the incoming arguments.   These arguments are in the reverse\n-     order to the array dimensions, that is the first argument refers to\n-     the last array dimension.  */\n-  if (fortran_array_slicing_debug)\n-    debug_printf (\"Processing array access:\\n\");\n-  for (int i = 0; i < nargs; ++i)\n-    {\n-      /* For each dimension of the array the user will have either provided\n-\t a ranged access with optional lower bound, upper bound, and\n-\t stride, or the user will have supplied a single index.  */\n-      struct type *dim_type = dim_types[ndimensions - (i + 1)];\n-      if (exp->elts[*pos].opcode == OP_RANGE)\n-\t{\n-\t  int pc = (*pos) + 1;\n-\t  enum range_flag range_flag = (enum range_flag) exp->elts[pc].longconst;\n-\t  *pos += 3;\n-\n-\t  LONGEST low, high, stride;\n-\t  low = high = stride = 0;\n-\n-\t  if ((range_flag & RANGE_LOW_BOUND_DEFAULT) == 0)\n-\t    low = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n-\t  else\n-\t    low = f77_get_lowerbound (dim_type);\n-\t  if ((range_flag & RANGE_HIGH_BOUND_DEFAULT) == 0)\n-\t    high = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n-\t  else\n-\t    high = f77_get_upperbound (dim_type);\n-\t  if ((range_flag & RANGE_HAS_STRIDE) == RANGE_HAS_STRIDE)\n-\t    stride = value_as_long (evaluate_subexp (nullptr, exp, pos, noside));\n-\t  else\n-\t    stride = 1;\n-\n-\t  if (stride == 0)\n-\t    error (_(\"stride must not be 0\"));\n-\n-\t  /* Get information about this dimension in the original ARRAY.  */\n-\t  struct type *target_type = TYPE_TARGET_TYPE (dim_type);\n-\t  struct type *index_type = dim_type->index_type ();\n-\t  LONGEST lb = f77_get_lowerbound (dim_type);\n-\t  LONGEST ub = f77_get_upperbound (dim_type);\n-\t  LONGEST sd = index_type->bit_stride ();\n-\t  if (sd == 0)\n-\t    sd = TYPE_LENGTH (target_type) * 8;\n-\n-\t  if (fortran_array_slicing_debug)\n-\t    {\n-\t      debug_printf (\"|-> Range access\\n\");\n-\t      std::string str = type_to_string (dim_type);\n-\t      debug_printf (\"|   |-> Type: %s\\n\", str.c_str ());\n-\t      debug_printf (\"|   |-> Array:\\n\");\n-\t      debug_printf (\"|   |   |-> Low bound: %s\\n\", plongest (lb));\n-\t      debug_printf (\"|   |   |-> High bound: %s\\n\", plongest (ub));\n-\t      debug_printf (\"|   |   |-> Bit stride: %s\\n\", plongest (sd));\n-\t      debug_printf (\"|   |   |-> Byte stride: %s\\n\", plongest (sd / 8));\n-\t      debug_printf (\"|   |   |-> Type size: %s\\n\",\n-\t\t\t    pulongest (TYPE_LENGTH (dim_type)));\n-\t      debug_printf (\"|   |   '-> Target type size: %s\\n\",\n-\t\t\t    pulongest (TYPE_LENGTH (target_type)));\n-\t      debug_printf (\"|   |-> Accessing:\\n\");\n-\t      debug_printf (\"|   |   |-> Low bound: %s\\n\",\n-\t\t\t    plongest (low));\n-\t      debug_printf (\"|   |   |-> High bound: %s\\n\",\n-\t\t\t    plongest (high));\n-\t      debug_printf (\"|   |   '-> Element stride: %s\\n\",\n-\t\t\t    plongest (stride));\n-\t    }\n-\n-\t  /* Check the user hasn't asked for something invalid.  */\n-\t  if (high > ub || low < lb)\n-\t    error (_(\"array subscript out of bounds\"));\n-\n-\t  /* Calculate what this dimension of the new slice array will look\n-\t     like.  OFFSET is the byte offset from the start of the\n-\t     previous (more outer) dimension to the start of this\n-\t     dimension.  E_COUNT is the number of elements in this\n-\t     dimension.  REMAINDER is the number of elements remaining\n-\t     between the last included element and the upper bound.  For\n-\t     example an access '1:6:2' will include elements 1, 3, 5 and\n-\t     have a remainder of 1 (element #6).  */\n-\t  LONGEST lowest = std::min (low, high);\n-\t  LONGEST offset = (sd / 8) * (lowest - lb);\n-\t  LONGEST e_count = std::abs (high - low) + 1;\n-\t  e_count = (e_count + (std::abs (stride) - 1)) / std::abs (stride);\n-\t  LONGEST new_low = 1;\n-\t  LONGEST new_high = new_low + e_count - 1;\n-\t  LONGEST new_stride = (sd * stride) / 8;\n-\t  LONGEST last_elem = low + ((e_count - 1) * stride);\n-\t  LONGEST remainder = high - last_elem;\n-\t  if (low > high)\n-\t    {\n-\t      offset += std::abs (remainder) * TYPE_LENGTH (target_type);\n-\t      if (stride > 0)\n-\t\terror (_(\"incorrect stride and boundary combination\"));\n-\t    }\n-\t  else if (stride < 0)\n-\t    error (_(\"incorrect stride and boundary combination\"));\n-\n-\t  /* Is the data within this dimension contiguous?  It is if the\n-\t     newly computed stride is the same size as a single element of\n-\t     this dimension.  */\n-\t  bool is_dim_contiguous = (new_stride == slice_element_size);\n-\t  is_all_contiguous &= is_dim_contiguous;\n-\n-\t  if (fortran_array_slicing_debug)\n-\t    {\n-\t      debug_printf (\"|   '-> Results:\\n\");\n-\t      debug_printf (\"|       |-> Offset = %s\\n\", plongest (offset));\n-\t      debug_printf (\"|       |-> Elements = %s\\n\", plongest (e_count));\n-\t      debug_printf (\"|       |-> Low bound = %s\\n\", plongest (new_low));\n-\t      debug_printf (\"|       |-> High bound = %s\\n\",\n-\t\t\t    plongest (new_high));\n-\t      debug_printf (\"|       |-> Byte stride = %s\\n\",\n-\t\t\t    plongest (new_stride));\n-\t      debug_printf (\"|       |-> Last element = %s\\n\",\n-\t\t\t    plongest (last_elem));\n-\t      debug_printf (\"|       |-> Remainder = %s\\n\",\n-\t\t\t    plongest (remainder));\n-\t      debug_printf (\"|       '-> Contiguous = %s\\n\",\n-\t\t\t    (is_dim_contiguous ? \"Yes\" : \"No\"));\n-\t    }\n-\n-\t  /* Figure out how big (in bytes) an element of this dimension of\n-\t     the new array slice will be.  */\n-\t  slice_element_size = std::abs (new_stride * e_count);\n-\n-\t  slice_dims.emplace_back (new_low, new_high, new_stride,\n-\t\t\t\t   index_type);\n-\n-\t  /* Update the total offset.  */\n-\t  total_offset += offset;\n-\t}\n-      else\n-\t{\n-\t  /* There is a single index for this dimension.  */\n-\t  LONGEST index\n-\t    = value_as_long (evaluate_subexp_with_coercion (exp, pos, noside));\n-\n-\t  /* Get information about this dimension in the original ARRAY.  */\n-\t  struct type *target_type = TYPE_TARGET_TYPE (dim_type);\n-\t  struct type *index_type = dim_type->index_type ();\n-\t  LONGEST lb = f77_get_lowerbound (dim_type);\n-\t  LONGEST ub = f77_get_upperbound (dim_type);\n-\t  LONGEST sd = index_type->bit_stride () / 8;\n-\t  if (sd == 0)\n-\t    sd = TYPE_LENGTH (target_type);\n-\n-\t  if (fortran_array_slicing_debug)\n-\t    {\n-\t      debug_printf (\"|-> Index access\\n\");\n-\t      std::string str = type_to_string (dim_type);\n-\t      debug_printf (\"|   |-> Type: %s\\n\", str.c_str ());\n-\t      debug_printf (\"|   |-> Array:\\n\");\n-\t      debug_printf (\"|   |   |-> Low bound: %s\\n\", plongest (lb));\n-\t      debug_printf (\"|   |   |-> High bound: %s\\n\", plongest (ub));\n-\t      debug_printf (\"|   |   |-> Byte stride: %s\\n\", plongest (sd));\n-\t      debug_printf (\"|   |   |-> Type size: %s\\n\",\n-\t\t\t    pulongest (TYPE_LENGTH (dim_type)));\n-\t      debug_printf (\"|   |   '-> Target type size: %s\\n\",\n-\t\t\t    pulongest (TYPE_LENGTH (target_type)));\n-\t      debug_printf (\"|   '-> Accessing:\\n\");\n-\t      debug_printf (\"|       '-> Index: %s\\n\",\n-\t\t\t    plongest (index));\n-\t    }\n-\n-\t  /* If the array has actual content then check the index is in\n-\t     bounds.  An array without content (an unbound array) doesn't\n-\t     have a known upper bound, so don't error check in that\n-\t     situation.  */\n-\t  if (index < lb\n-\t      || (dim_type->index_type ()->bounds ()->high.kind () != PROP_UNDEFINED\n-\t\t  && index > ub)\n-\t      || (VALUE_LVAL (array) != lval_memory\n-\t\t  && dim_type->index_type ()->bounds ()->high.kind () == PROP_UNDEFINED))\n-\t    {\n-\t      if (type_not_associated (dim_type))\n-\t\terror (_(\"no such vector element (vector not associated)\"));\n-\t      else if (type_not_allocated (dim_type))\n-\t\terror (_(\"no such vector element (vector not allocated)\"));\n-\t      else\n-\t\terror (_(\"no such vector element\"));\n-\t    }\n-\n-\t  /* Calculate using the type stride, not the target type size.  */\n-\t  LONGEST offset = sd * (index - lb);\n-\t  total_offset += offset;\n-\t}\n-    }\n-\n-  if (noside == EVAL_SKIP)\n-    return array;\n-\n-  /* Build a type that represents the new array slice in the target memory\n-     of the original ARRAY, this type makes use of strides to correctly\n-     find only those elements that are part of the new slice.  */\n-  struct type *array_slice_type = inner_element_type;\n-  for (const auto &d : slice_dims)\n-    {\n-      /* Create the range.  */\n-      dynamic_prop p_low, p_high, p_stride;\n-\n-      p_low.set_const_val (d.low);\n-      p_high.set_const_val (d.high);\n-      p_stride.set_const_val (d.stride);\n-\n-      struct type *new_range\n-\t= create_range_type_with_stride ((struct type *) NULL,\n-\t\t\t\t\t TYPE_TARGET_TYPE (d.index),\n-\t\t\t\t\t &p_low, &p_high, 0, &p_stride,\n-\t\t\t\t\t true);\n-      array_slice_type\n-\t= create_array_type (nullptr, array_slice_type, new_range);\n-    }\n-\n-  if (fortran_array_slicing_debug)\n-    {\n-      debug_printf (\"'-> Final result:\\n\");\n-      debug_printf (\"    |-> Type: %s\\n\",\n-\t\t    type_to_string (array_slice_type).c_str ());\n-      debug_printf (\"    |-> Total offset: %s\\n\",\n-\t\t    plongest (total_offset));\n-      debug_printf (\"    |-> Base address: %s\\n\",\n-\t\t    core_addr_to_string (value_address (array)));\n-      debug_printf (\"    '-> Contiguous = %s\\n\",\n-\t\t    (is_all_contiguous ? \"Yes\" : \"No\"));\n-    }\n-\n-  /* Should we repack this array slice?  */\n-  if (!is_all_contiguous && (repack_array_slices || is_string_p))\n-    {\n-      /* Build a type for the repacked slice.  */\n-      struct type *repacked_array_type = inner_element_type;\n-      for (const auto &d : slice_dims)\n-\t{\n-\t  /* Create the range.  */\n-\t  dynamic_prop p_low, p_high, p_stride;\n+   element values from the contents of the parent value.  */\n+class fortran_array_repacker_impl\n+  : public fortran_array_repacker_base_impl\n+{\n+public:\n+  /* Constructor.  TYPE is the type for the array slice within the parent\n+     value, as such it has stride values as required to find the elements\n+     within the original parent value.  ADDRESS is the address in target\n+     memory of the value matching TYPE.  BASE_OFFSET is the offset from\n+     the start of VAL's content buffer to the start of the object of TYPE,\n+     VAL is the parent object from which we are loading the value, and\n+     DEST is the value into which we are repacking.  */\n+  explicit fortran_array_repacker_impl (struct type *type, CORE_ADDR address,\n+\t\t\t\t\tLONGEST base_offset,\n+\t\t\t\t\tstruct value *val, struct value *dest)\n+    : fortran_array_repacker_base_impl (dest),\n+      m_base_offset (base_offset),\n+      m_val (val)\n+  {\n+    gdb_assert (!value_lazy (val));\n+  }\n \n-\t  p_low.set_const_val (d.low);\n-\t  p_high.set_const_val (d.high);\n-\t  p_stride.set_const_val (TYPE_LENGTH (repacked_array_type));\n+  /* Extract an element of ELT_TYPE at offset (M_BASE_OFFSET + ELT_OFF)\n+     from the content buffer of M_VAL then copy this extracted value into\n+     the repacked destination value.  */\n+  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n+  {\n+    struct value *elt\n+      = value_from_component (m_val, elt_type, (elt_off + m_base_offset));\n+    copy_element_to_dest (elt);\n+  }\n \n-\t  struct type *new_range\n-\t    = create_range_type_with_stride ((struct type *) NULL,\n-\t\t\t\t\t     TYPE_TARGET_TYPE (d.index),\n-\t\t\t\t\t     &p_low, &p_high, 0, &p_stride,\n-\t\t\t\t\t     true);\n-\t  repacked_array_type\n-\t    = create_array_type (nullptr, repacked_array_type, new_range);\n-\t}\n+private:\n+  /* The offset into the content buffer of M_VAL to the start of the slice\n+     being extracted.  */\n+  LONGEST m_base_offset;\n \n-      /* Now copy the elements from the original ARRAY into the packed\n-\t array value DEST.  */\n-      struct value *dest = allocate_value (repacked_array_type);\n-      if (value_lazy (array)\n-\t  || (total_offset + TYPE_LENGTH (array_slice_type)\n-\t      > TYPE_LENGTH (check_typedef (value_type (array)))))\n-\t{\n-\t  fortran_array_walker<fortran_lazy_array_repacker_impl> p\n-\t    (array_slice_type, value_address (array) + total_offset, dest);\n-\t  p.walk ();\n-\t}\n-      else\n-\t{\n-\t  fortran_array_walker<fortran_array_repacker_impl> p\n-\t    (array_slice_type, value_address (array) + total_offset,\n-\t     total_offset, array, dest);\n-\t  p.walk ();\n-\t}\n-      array = dest;\n-    }\n-  else\n-    {\n-      if (VALUE_LVAL (array) == lval_memory)\n-\t{\n-\t  /* If the value we're taking a slice from is not yet loaded, or\n-\t     the requested slice is outside the values content range then\n-\t     just create a new lazy value pointing at the memory where the\n-\t     contents we're looking for exist.  */\n-\t  if (value_lazy (array)\n-\t      || (total_offset + TYPE_LENGTH (array_slice_type)\n-\t\t  > TYPE_LENGTH (check_typedef (value_type (array)))))\n-\t    array = value_at_lazy (array_slice_type,\n-\t\t\t\t   value_address (array) + total_offset);\n-\t  else\n-\t    array = value_from_contents_and_address (array_slice_type,\n-\t\t\t\t\t\t     (value_contents (array)\n-\t\t\t\t\t\t      + total_offset),\n-\t\t\t\t\t\t     (value_address (array)\n-\t\t\t\t\t\t      + total_offset));\n-\t}\n-      else if (!value_lazy (array))\n-\tarray = value_from_component (array, array_slice_type, total_offset);\n-      else\n-\terror (_(\"cannot subscript arrays that are not in memory\"));\n-    }\n+  /* The parent value from which we are extracting a slice.  */\n+  struct value *m_val;\n+};\n \n-  return array;\n-}\n \n /* Evaluate FORTRAN_ASSOCIATED expressions.  Both GDBARCH and LANG are\n    extracted from the expression being evaluated.  POINTER is the required\n@@ -1223,202 +813,6 @@ eval_op_f_allocated (struct type *expect_type, struct expression *exp,\n   return value_from_longest (result_type, result_value);\n }\n \n-/* Special expression evaluation cases for Fortran.  */\n-\n-static struct value *\n-evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n-\t\t   int *pos, enum noside noside)\n-{\n-  struct value *arg1 = NULL, *arg2 = NULL;\n-  enum exp_opcode op;\n-  int pc;\n-  struct type *type;\n-\n-  pc = *pos;\n-  *pos += 1;\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    default:\n-      *pos -= 1;\n-      return evaluate_subexp_standard (expect_type, exp, pos, noside);\n-\n-    case UNOP_ABS:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_f_abs (expect_type, exp, noside, op, arg1);\n-\n-    case BINOP_MOD:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_f_mod (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case UNOP_FORTRAN_CEILING:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_f_ceil (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_FORTRAN_FLOOR:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_f_floor (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_FORTRAN_ALLOCATED:\n-      {\n-\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\tif (noside == EVAL_SKIP)\n-\t  return eval_skip_value (exp);\n-\treturn eval_op_f_allocated (expect_type, exp, noside, op, arg1);\n-      }\n-\n-    case BINOP_FORTRAN_MODULO:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_f_modulo (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case FORTRAN_LBOUND:\n-    case FORTRAN_UBOUND:\n-      {\n-\tint nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-\t(*pos) += 2;\n-\n-\t/* This assertion should be enforced by the expression parser.  */\n-\tgdb_assert (nargs == 1 || nargs == 2);\n-\n-\tbool lbound_p = op == FORTRAN_LBOUND;\n-\n-\t/* Check that the first argument is array like.  */\n-\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\tfortran_require_array (value_type (arg1), lbound_p);\n-\n-\tif (nargs == 1)\n-\t  return fortran_bounds_all_dims (lbound_p, exp->gdbarch, arg1);\n-\n-\t/* User asked for the bounds of a specific dimension of the array.  */\n-\targ2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\ttype = check_typedef (value_type (arg2));\n-\tif (type->code () != TYPE_CODE_INT)\n-\t  {\n-\t    if (lbound_p)\n-\t      error (_(\"LBOUND second argument should be an integer\"));\n-\t    else\n-\t      error (_(\"UBOUND second argument should be an integer\"));\n-\t  }\n-\n-\treturn fortran_bounds_for_dimension (lbound_p, exp->gdbarch, arg1,\n-\t\t\t\t\t     arg2);\n-      }\n-      break;\n-\n-    case FORTRAN_ASSOCIATED:\n-      {\n-\tint nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-\t(*pos) += 2;\n-\n-\t/* This assertion should be enforced by the expression parser.  */\n-\tgdb_assert (nargs == 1 || nargs == 2);\n-\n-\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\tif (nargs == 1)\n-\t  {\n-\t    if (noside == EVAL_SKIP)\n-\t      return eval_skip_value (exp);\n-\t    return fortran_associated (exp->gdbarch, exp->language_defn,\n-\t\t\t\t       arg1);\n-\t  }\n-\n-\targ2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\tif (noside == EVAL_SKIP)\n-\t  return eval_skip_value (exp);\n-\treturn fortran_associated (exp->gdbarch, exp->language_defn,\n-\t\t\t\t   arg1, arg2);\n-      }\n-      break;\n-\n-    case BINOP_FORTRAN_CMPLX:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_f_cmplx (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case UNOP_FORTRAN_KIND:\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      return eval_op_f_kind (expect_type, exp, noside, op, arg1);\n-\n-    case OP_F77_UNDETERMINED_ARGLIST:\n-      /* Remember that in F77, functions, substring ops and array subscript\n-\t operations cannot be disambiguated at parse time.  We have made\n-\t all array subscript operations, substring operations as well as\n-\t function calls come here and we now have to discover what the heck\n-\t this thing actually was.  If it is a function, we process just as\n-\t if we got an OP_FUNCALL.  */\n-      int nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 2;\n-\n-      /* First determine the type code we are dealing with.  */\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      type = check_typedef (value_type (arg1));\n-      enum type_code code = type->code ();\n-\n-      if (code == TYPE_CODE_PTR)\n-\t{\n-\t  /* Fortran always passes variable to subroutines as pointer.\n-\t     So we need to look into its target type to see if it is\n-\t     array, string or function.  If it is, we need to switch\n-\t     to the target value the original one points to.  */\n-\t  struct type *target_type = check_typedef (TYPE_TARGET_TYPE (type));\n-\n-\t  if (target_type->code () == TYPE_CODE_ARRAY\n-\t      || target_type->code () == TYPE_CODE_STRING\n-\t      || target_type->code () == TYPE_CODE_FUNC)\n-\t    {\n-\t      arg1 = value_ind (arg1);\n-\t      type = check_typedef (value_type (arg1));\n-\t      code = type->code ();\n-\t    }\n-\t}\n-\n-      switch (code)\n-\t{\n-\tcase TYPE_CODE_ARRAY:\n-\tcase TYPE_CODE_STRING:\n-\t  return fortran_value_subarray (arg1, exp, pos, nargs, noside);\n-\n-\tcase TYPE_CODE_PTR:\n-\tcase TYPE_CODE_FUNC:\n-\tcase TYPE_CODE_INTERNAL_FUNCTION:\n-\t  {\n-\t    /* It's a function call.  Allocate arg vector, including\n-\t    space for the function to be called in argvec[0] and a\n-\t    termination NULL.  */\n-\t    struct value **argvec = (struct value **)\n-\t      alloca (sizeof (struct value *) * (nargs + 2));\n-\t    argvec[0] = arg1;\n-\t    int tem = 1;\n-\t    for (; tem <= nargs; tem++)\n-\t      {\n-\t\tbool is_internal_func = (code == TYPE_CODE_INTERNAL_FUNCTION);\n-\t\targvec[tem]\n-\t\t  = fortran_prepare_argument (exp, pos, (tem - 1),\n-\t\t\t\t\t      is_internal_func,\n-\t\t\t\t\t      value_type (arg1), noside);\n-\t      }\n-\t    argvec[tem] = 0;\t/* signal end of arglist */\n-\t    if (noside == EVAL_SKIP)\n-\t      return eval_skip_value (exp);\n-\t    return evaluate_subexp_do_call (exp, noside, argvec[0],\n-\t\t\t\t\t    gdb::make_array_view (argvec + 1,\n-\t\t\t\t\t\t\t\t  nargs),\n-\t\t\t\t\t    NULL, expect_type);\n-\t  }\n-\n-\tdefault:\n-\t  error (_(\"Cannot perform substring on this type\"));\n-\t}\n-    }\n-\n-  /* Should be unreachable.  */\n-  return nullptr;\n-}\n-\n namespace expr\n {\n \n@@ -1921,247 +1315,6 @@ fortran_bound_2arg::evaluate (struct type *expect_type,\n \n } /* namespace expr */\n \n-/* Special expression lengths for Fortran.  */\n-\n-static void\n-operator_length_f (const struct expression *exp, int pc, int *oplenp,\n-\t\t   int *argsp)\n-{\n-  int oplen = 1;\n-  int args = 0;\n-\n-  switch (exp->elts[pc - 1].opcode)\n-    {\n-    default:\n-      operator_length_standard (exp, pc, oplenp, argsp);\n-      return;\n-\n-    case UNOP_FORTRAN_KIND:\n-    case UNOP_FORTRAN_FLOOR:\n-    case UNOP_FORTRAN_CEILING:\n-    case UNOP_FORTRAN_ALLOCATED:\n-      oplen = 1;\n-      args = 1;\n-      break;\n-\n-    case BINOP_FORTRAN_CMPLX:\n-    case BINOP_FORTRAN_MODULO:\n-      oplen = 1;\n-      args = 2;\n-      break;\n-\n-    case FORTRAN_ASSOCIATED:\n-    case FORTRAN_LBOUND:\n-    case FORTRAN_UBOUND:\n-      oplen = 3;\n-      args = longest_to_int (exp->elts[pc - 2].longconst);\n-      break;\n-\n-    case OP_F77_UNDETERMINED_ARGLIST:\n-      oplen = 3;\n-      args = 1 + longest_to_int (exp->elts[pc - 2].longconst);\n-      break;\n-    }\n-\n-  *oplenp = oplen;\n-  *argsp = args;\n-}\n-\n-/* Helper for PRINT_SUBEXP_F.  Arguments are as for PRINT_SUBEXP_F, except\n-   the extra argument NAME which is the text that should be printed as the\n-   name of this operation.  */\n-\n-static void\n-print_unop_subexp_f (struct expression *exp, int *pos,\n-\t\t     struct ui_file *stream, enum precedence prec,\n-\t\t     const char *name)\n-{\n-  (*pos)++;\n-  fprintf_filtered (stream, \"%s(\", name);\n-  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-  fputs_filtered (\")\", stream);\n-}\n-\n-/* Helper for PRINT_SUBEXP_F.  Arguments are as for PRINT_SUBEXP_F, except\n-   the extra argument NAME which is the text that should be printed as the\n-   name of this operation.  */\n-\n-static void\n-print_binop_subexp_f (struct expression *exp, int *pos,\n-\t\t      struct ui_file *stream, enum precedence prec,\n-\t\t      const char *name)\n-{\n-  (*pos)++;\n-  fprintf_filtered (stream, \"%s(\", name);\n-  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-  fputs_filtered (\",\", stream);\n-  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-  fputs_filtered (\")\", stream);\n-}\n-\n-/* Helper for PRINT_SUBEXP_F.  Arguments are as for PRINT_SUBEXP_F, except\n-   the extra argument NAME which is the text that should be printed as the\n-   name of this operation.  */\n-\n-static void\n-print_unop_or_binop_subexp_f (struct expression *exp, int *pos,\n-\t\t\t      struct ui_file *stream, enum precedence prec,\n-\t\t\t      const char *name)\n-{\n-  unsigned nargs = longest_to_int (exp->elts[*pos + 1].longconst);\n-  (*pos) += 3;\n-  fprintf_filtered (stream, \"%s (\", name);\n-  for (unsigned tem = 0; tem < nargs; tem++)\n-    {\n-      if (tem != 0)\n-\tfputs_filtered (\", \", stream);\n-      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-    }\n-  fputs_filtered (\")\", stream);\n-}\n-\n-/* Special expression printing for Fortran.  */\n-\n-static void\n-print_subexp_f (struct expression *exp, int *pos,\n-\t\tstruct ui_file *stream, enum precedence prec)\n-{\n-  int pc = *pos;\n-  enum exp_opcode op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    default:\n-      print_subexp_standard (exp, pos, stream, prec);\n-      return;\n-\n-    case UNOP_FORTRAN_KIND:\n-      print_unop_subexp_f (exp, pos, stream, prec, \"KIND\");\n-      return;\n-\n-    case UNOP_FORTRAN_FLOOR:\n-      print_unop_subexp_f (exp, pos, stream, prec, \"FLOOR\");\n-      return;\n-\n-    case UNOP_FORTRAN_CEILING:\n-      print_unop_subexp_f (exp, pos, stream, prec, \"CEILING\");\n-      return;\n-\n-    case UNOP_FORTRAN_ALLOCATED:\n-      print_unop_subexp_f (exp, pos, stream, prec, \"ALLOCATED\");\n-      return;\n-\n-    case BINOP_FORTRAN_CMPLX:\n-      print_binop_subexp_f (exp, pos, stream, prec, \"CMPLX\");\n-      return;\n-\n-    case BINOP_FORTRAN_MODULO:\n-      print_binop_subexp_f (exp, pos, stream, prec, \"MODULO\");\n-      return;\n-\n-    case FORTRAN_ASSOCIATED:\n-      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"ASSOCIATED\");\n-      return;\n-\n-    case FORTRAN_LBOUND:\n-      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"LBOUND\");\n-      return;\n-\n-    case FORTRAN_UBOUND:\n-      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"UBOUND\");\n-      return;\n-\n-    case OP_F77_UNDETERMINED_ARGLIST:\n-      (*pos)++;\n-      print_subexp_funcall (exp, pos, stream);\n-      return;\n-    }\n-}\n-\n-/* Special expression dumping for Fortran.  */\n-\n-static int\n-dump_subexp_body_f (struct expression *exp,\n-\t\t    struct ui_file *stream, int elt)\n-{\n-  int opcode = exp->elts[elt].opcode;\n-  int oplen, nargs, i;\n-\n-  switch (opcode)\n-    {\n-    default:\n-      return dump_subexp_body_standard (exp, stream, elt);\n-\n-    case UNOP_FORTRAN_KIND:\n-    case UNOP_FORTRAN_FLOOR:\n-    case UNOP_FORTRAN_CEILING:\n-    case UNOP_FORTRAN_ALLOCATED:\n-    case BINOP_FORTRAN_CMPLX:\n-    case BINOP_FORTRAN_MODULO:\n-      operator_length_f (exp, (elt + 1), &oplen, &nargs);\n-      break;\n-\n-    case FORTRAN_ASSOCIATED:\n-    case FORTRAN_LBOUND:\n-    case FORTRAN_UBOUND:\n-      operator_length_f (exp, (elt + 3), &oplen, &nargs);\n-      break;\n-\n-    case OP_F77_UNDETERMINED_ARGLIST:\n-      return dump_subexp_body_funcall (exp, stream, elt + 1);\n-    }\n-\n-  elt += oplen;\n-  for (i = 0; i < nargs; i += 1)\n-    elt = dump_subexp (exp, stream, elt);\n-\n-  return elt;\n-}\n-\n-/* Special expression checking for Fortran.  */\n-\n-static int\n-operator_check_f (struct expression *exp, int pos,\n-\t\t  int (*objfile_func) (struct objfile *objfile,\n-\t\t\t\t       void *data),\n-\t\t  void *data)\n-{\n-  const union exp_element *const elts = exp->elts;\n-\n-  switch (elts[pos].opcode)\n-    {\n-    case UNOP_FORTRAN_KIND:\n-    case UNOP_FORTRAN_FLOOR:\n-    case UNOP_FORTRAN_CEILING:\n-    case UNOP_FORTRAN_ALLOCATED:\n-    case BINOP_FORTRAN_CMPLX:\n-    case BINOP_FORTRAN_MODULO:\n-    case FORTRAN_ASSOCIATED:\n-    case FORTRAN_LBOUND:\n-    case FORTRAN_UBOUND:\n-      /* Any references to objfiles are held in the arguments to this\n-\t expression, not within the expression itself, so no additional\n-\t checking is required here, the outer expression iteration code\n-\t will take care of checking each argument.  */\n-      break;\n-\n-    default:\n-      return operator_check_standard (exp, pos, objfile_func, data);\n-    }\n-\n-  return 0;\n-}\n-\n-/* Expression processing for Fortran.  */\n-const struct exp_descriptor f_language::exp_descriptor_tab =\n-{\n-  print_subexp_f,\n-  operator_length_f,\n-  operator_check_f,\n-  dump_subexp_body_f,\n-  evaluate_subexp_f\n-};\n-\n /* See language.h.  */\n \n void\n@@ -2388,59 +1541,6 @@ fortran_argument_convert (struct value *value, bool is_artificial)\n     return value;\n }\n \n-/* Prepare (and return) an argument value ready for an inferior function\n-   call to a Fortran function.  EXP and POS are the expressions describing\n-   the argument to prepare.  ARG_NUM is the argument number being\n-   prepared, with 0 being the first argument and so on.  FUNC_TYPE is the\n-   type of the function being called.\n-\n-   IS_INTERNAL_CALL_P is true if this is a call to a function of type\n-   TYPE_CODE_INTERNAL_FUNCTION, otherwise this parameter is false.\n-\n-   NOSIDE has its usual meaning for expression parsing (see eval.c).\n-\n-   Arguments in Fortran are normally passed by address, we coerce the\n-   arguments here rather than in value_arg_coerce as otherwise the call to\n-   malloc (to place the non-lvalue parameters in target memory) is hit by\n-   this Fortran specific logic.  This results in malloc being called with a\n-   pointer to an integer followed by an attempt to malloc the arguments to\n-   malloc in target memory.  Infinite recursion ensues.  */\n-\n-static value *\n-fortran_prepare_argument (struct expression *exp, int *pos,\n-                         int arg_num, bool is_internal_call_p,\n-                         struct type *func_type, enum noside noside)\n-{\n-  if (is_internal_call_p)\n-    return evaluate_subexp_with_coercion (exp, pos, noside);\n-\n-  bool is_artificial = ((arg_num >= func_type->num_fields ())\n-\t\t\t? true\n-\t\t\t: TYPE_FIELD_ARTIFICIAL (func_type, arg_num));\n-\n-  /* If this is an artificial argument, then either, this is an argument\n-     beyond the end of the known arguments, or possibly, there are no known\n-     arguments (maybe missing debug info).\n-\n-     For these artificial arguments, if the user has prefixed it with '&'\n-     (for address-of), then lets always allow this to succeed, even if the\n-     argument is not actually in inferior memory.  This will allow the user\n-     to pass arguments to a Fortran function even when there's no debug\n-     information.\n-\n-     As we already pass the address of non-artificial arguments, all we\n-     need to do if skip the UNOP_ADDR operator in the expression and mark\n-     the argument as non-artificial.  */\n-  if (is_artificial && exp->elts[*pos].opcode == UNOP_ADDR)\n-    {\n-      (*pos)++;\n-      is_artificial = false;\n-    }\n-\n-  struct value *arg_val = evaluate_subexp_with_coercion (exp, pos, noside);\n-  return fortran_argument_convert (arg_val, is_artificial);\n-}\n-\n /* Prepare (and return) an argument value ready for an inferior function\n    call to a Fortran function.  EXP and POS are the expressions describing\n    the argument to prepare.  ARG_NUM is the argument number being"
    },
    {
      "sha": "03b5910213996070ce89b8ba193e79d09a3044fc",
      "filename": "gdb/f-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/f-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a99be8c199c2cbfae137fb5a54151e781ecb7ec3/gdb/f-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.h?ref=a99be8c199c2cbfae137fb5a54151e781ecb7ec3",
      "patch": "@@ -220,11 +220,6 @@ class f_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_tab; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return op_print_tab; }\n \n@@ -236,11 +231,6 @@ class f_language : public language_defn\n \t(const lookup_name_info &lookup_name) const override;\n \n private:\n-  /* Table of expression handling functions for use by EXPRESSION_OPS\n-     member function.  */\n-\n-  static const struct exp_descriptor exp_descriptor_tab;\n-\n   /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n \n   static const struct op_print op_print_tab[];"
    }
  ]
}