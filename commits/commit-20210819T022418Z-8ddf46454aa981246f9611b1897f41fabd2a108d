{
  "sha": "8ddf46454aa981246f9611b1897f41fabd2a108d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGRkZjQ2NDU0YWE5ODEyNDZmOTYxMWIxODk3ZjQxZmFiZDJhMTA4ZA==",
  "commit": {
    "author": {
      "name": "Aaron Merey",
      "email": "amerey@redhat.com",
      "date": "2021-08-11T02:05:44Z"
    },
    "committer": {
      "name": "Aaron Merey",
      "email": "amerey@redhat.com",
      "date": "2021-08-19T02:24:18Z"
    },
    "message": "gdb/solib: Refactor scan_dyntag\n\nscan_dyntag is unnecessarily duplicated in solib-svr4.c and solib-dsbt.c.\n\nMove this function to solib.c and rename it to gdb_bfd_scan_elf_dyntag.\nAlso add it to solib.h so it is included in both solib-svr4 and solib-dsbt.",
    "tree": {
      "sha": "17b1d9632a2f2e5d8627b7d50585d13690630b10",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/17b1d9632a2f2e5d8627b7d50585d13690630b10"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8ddf46454aa981246f9611b1897f41fabd2a108d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ddf46454aa981246f9611b1897f41fabd2a108d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8ddf46454aa981246f9611b1897f41fabd2a108d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ddf46454aa981246f9611b1897f41fabd2a108d/comments",
  "author": {
    "login": "aaronmerey",
    "id": 28735867,
    "node_id": "MDQ6VXNlcjI4NzM1ODY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/28735867?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aaronmerey",
    "html_url": "https://github.com/aaronmerey",
    "followers_url": "https://api.github.com/users/aaronmerey/followers",
    "following_url": "https://api.github.com/users/aaronmerey/following{/other_user}",
    "gists_url": "https://api.github.com/users/aaronmerey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aaronmerey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aaronmerey/subscriptions",
    "organizations_url": "https://api.github.com/users/aaronmerey/orgs",
    "repos_url": "https://api.github.com/users/aaronmerey/repos",
    "events_url": "https://api.github.com/users/aaronmerey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aaronmerey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "aaronmerey",
    "id": 28735867,
    "node_id": "MDQ6VXNlcjI4NzM1ODY3",
    "avatar_url": "https://avatars.githubusercontent.com/u/28735867?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/aaronmerey",
    "html_url": "https://github.com/aaronmerey",
    "followers_url": "https://api.github.com/users/aaronmerey/followers",
    "following_url": "https://api.github.com/users/aaronmerey/following{/other_user}",
    "gists_url": "https://api.github.com/users/aaronmerey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/aaronmerey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/aaronmerey/subscriptions",
    "organizations_url": "https://api.github.com/users/aaronmerey/orgs",
    "repos_url": "https://api.github.com/users/aaronmerey/repos",
    "events_url": "https://api.github.com/users/aaronmerey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/aaronmerey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "76bed1fdbd7256228847962770bdc5832c53172c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/76bed1fdbd7256228847962770bdc5832c53172c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/76bed1fdbd7256228847962770bdc5832c53172c"
    }
  ],
  "stats": {
    "total": 332,
    "additions": 122,
    "deletions": 210
  },
  "files": [
    {
      "sha": "d7f4b252eeebf5febe6c9c6b4100656985dae37a",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 3,
      "deletions": 101,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=8ddf46454aa981246f9611b1897f41fabd2a108d",
      "patch": "@@ -396,106 +396,6 @@ fetch_loadmap (CORE_ADDR ldmaddr)\n static void dsbt_relocate_main_executable (void);\n static int enable_break (void);\n \n-/* Scan for DYNTAG in .dynamic section of ABFD. If DYNTAG is found 1 is\n-   returned and the corresponding PTR is set.  */\n-\n-static int\n-scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)\n-{\n-  int arch_size, step, sect_size;\n-  long dyn_tag;\n-  CORE_ADDR dyn_ptr, dyn_addr;\n-  gdb_byte *bufend, *bufstart, *buf;\n-  Elf32_External_Dyn *x_dynp_32;\n-  Elf64_External_Dyn *x_dynp_64;\n-  struct bfd_section *sect;\n-\n-  if (abfd == NULL)\n-    return 0;\n-\n-  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return 0;\n-\n-  arch_size = bfd_get_arch_size (abfd);\n-  if (arch_size == -1)\n-    return 0;\n-\n-  /* Find the start address of the .dynamic section.  */\n-  sect = bfd_get_section_by_name (abfd, \".dynamic\");\n-  if (sect == NULL)\n-    return 0;\n-\n-  bool found = false;\n-  for (const target_section &target_section\n-\t : current_program_space->target_sections ())\n-    if (sect == target_section.the_bfd_section)\n-      {\n-\tdyn_addr = target_section.addr;\n-\tfound = true;\n-\tbreak;\n-      }\n-  if (!found)\n-    {\n-      /* ABFD may come from OBJFILE acting only as a symbol file without being\n-\t loaded into the target (see add_symbol_file_command).  This case is\n-\t such fallback to the file VMA address without the possibility of\n-\t having the section relocated to its actual in-memory address.  */\n-\n-      dyn_addr = bfd_section_vma (sect);\n-    }\n-\n-  /* Read in .dynamic from the BFD.  We will get the actual value\n-     from memory later.  */\n-  sect_size = bfd_section_size (sect);\n-  buf = bufstart = (gdb_byte *) alloca (sect_size);\n-  if (!bfd_get_section_contents (abfd, sect,\n-\t\t\t\t buf, 0, sect_size))\n-    return 0;\n-\n-  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */\n-  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)\n-\t\t\t   : sizeof (Elf64_External_Dyn);\n-  for (bufend = buf + sect_size;\n-       buf < bufend;\n-       buf += step)\n-  {\n-    if (arch_size == 32)\n-      {\n-\tx_dynp_32 = (Elf32_External_Dyn *) buf;\n-\tdyn_tag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_tag);\n-\tdyn_ptr = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_un.d_ptr);\n-      }\n-    else\n-      {\n-\tx_dynp_64 = (Elf64_External_Dyn *) buf;\n-\tdyn_tag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);\n-\tdyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);\n-      }\n-     if (dyn_tag == DT_NULL)\n-       return 0;\n-     if (dyn_tag == dyntag)\n-       {\n-\t /* If requested, try to read the runtime value of this .dynamic\n-\t    entry.  */\n-\t if (ptr)\n-\t   {\n-\t     struct type *ptr_type;\n-\t     gdb_byte ptr_buf[8];\n-\t     CORE_ADDR ptr_addr;\n-\n-\t     ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n-\t     ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;\n-\t     if (target_read_memory (ptr_addr, ptr_buf, arch_size / 8) == 0)\n-\t       dyn_ptr = extract_typed_address (ptr_buf, ptr_type);\n-\t     *ptr = dyn_ptr;\n-\t   }\n-\t return 1;\n-       }\n-  }\n-\n-  return 0;\n-}\n-\n /* See solist.h. */\n \n static int\n@@ -565,7 +465,9 @@ lm_base (void)\n \t\t\t    \"lm_base: get addr %x by _GLOBAL_OFFSET_TABLE_.\\n\",\n \t\t\t    (unsigned int) addr);\n     }\n-  else if (scan_dyntag (DT_PLTGOT, current_program_space->exec_bfd (), &addr))\n+  else if (gdb_bfd_scan_elf_dyntag (DT_PLTGOT,\n+\t\t\t\t    current_program_space->exec_bfd (),\n+\t\t\t\t    &addr, NULL))\n     {\n       struct int_elf32_dsbt_loadmap *ldm;\n "
    },
    {
      "sha": "3de1bb9c7f7fb08ec2f04f2ab1e8770ef469eb22",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 9,
      "deletions": 109,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=8ddf46454aa981246f9611b1897f41fabd2a108d",
      "patch": "@@ -582,109 +582,6 @@ find_program_interpreter (void)\n }\n \n \n-/* Scan for DESIRED_DYNTAG in .dynamic section of ABFD.  If DESIRED_DYNTAG is\n-   found, 1 is returned and the corresponding PTR is set.  */\n-\n-static int\n-scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n-\t     CORE_ADDR *ptr_addr)\n-{\n-  int arch_size, step, sect_size;\n-  long current_dyntag;\n-  CORE_ADDR dyn_ptr, dyn_addr;\n-  gdb_byte *bufend, *bufstart, *buf;\n-  Elf32_External_Dyn *x_dynp_32;\n-  Elf64_External_Dyn *x_dynp_64;\n-  struct bfd_section *sect;\n-\n-  if (abfd == NULL)\n-    return 0;\n-\n-  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return 0;\n-\n-  arch_size = bfd_get_arch_size (abfd);\n-  if (arch_size == -1)\n-    return 0;\n-\n-  /* Find the start address of the .dynamic section.  */\n-  sect = bfd_get_section_by_name (abfd, \".dynamic\");\n-  if (sect == NULL)\n-    return 0;\n-\n-  bool found = false;\n-  for (const target_section &target_section\n-\t : current_program_space->target_sections ())\n-    if (sect == target_section.the_bfd_section)\n-      {\n-\tdyn_addr = target_section.addr;\n-\tfound = true;\n-\tbreak;\n-      }\n-  if (!found)\n-    {\n-      /* ABFD may come from OBJFILE acting only as a symbol file without being\n-\t loaded into the target (see add_symbol_file_command).  This case is\n-\t such fallback to the file VMA address without the possibility of\n-\t having the section relocated to its actual in-memory address.  */\n-\n-      dyn_addr = bfd_section_vma (sect);\n-    }\n-\n-  /* Read in .dynamic from the BFD.  We will get the actual value\n-     from memory later.  */\n-  sect_size = bfd_section_size (sect);\n-  buf = bufstart = (gdb_byte *) alloca (sect_size);\n-  if (!bfd_get_section_contents (abfd, sect,\n-\t\t\t\t buf, 0, sect_size))\n-    return 0;\n-\n-  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */\n-  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)\n-\t\t\t   : sizeof (Elf64_External_Dyn);\n-  for (bufend = buf + sect_size;\n-       buf < bufend;\n-       buf += step)\n-  {\n-    if (arch_size == 32)\n-      {\n-\tx_dynp_32 = (Elf32_External_Dyn *) buf;\n-\tcurrent_dyntag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_tag);\n-\tdyn_ptr = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_un.d_ptr);\n-      }\n-    else\n-      {\n-\tx_dynp_64 = (Elf64_External_Dyn *) buf;\n-\tcurrent_dyntag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);\n-\tdyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);\n-      }\n-     if (current_dyntag == DT_NULL)\n-       return 0;\n-     if (current_dyntag == desired_dyntag)\n-       {\n-\t /* If requested, try to read the runtime value of this .dynamic\n-\t    entry.  */\n-\t if (ptr)\n-\t   {\n-\t     struct type *ptr_type;\n-\t     gdb_byte ptr_buf[8];\n-\t     CORE_ADDR ptr_addr_1;\n-\n-\t     ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n-\t     ptr_addr_1 = dyn_addr + (buf - bufstart) + arch_size / 8;\n-\t     if (target_read_memory (ptr_addr_1, ptr_buf, arch_size / 8) == 0)\n-\t       dyn_ptr = extract_typed_address (ptr_buf, ptr_type);\n-\t     *ptr = dyn_ptr;\n-\t     if (ptr_addr)\n-\t       *ptr_addr = dyn_addr + (buf - bufstart);\n-\t   }\n-\t return 1;\n-       }\n-  }\n-\n-  return 0;\n-}\n-\n /* Scan for DESIRED_DYNTAG in .dynamic section of the target's main executable,\n    found by consulting the OS auxillary vector.  If DESIRED_DYNTAG is found, 1\n    is returned and the corresponding PTR is set.  */\n@@ -768,8 +665,9 @@ elf_locate_base (void)\n   /* Look for DT_MIPS_RLD_MAP first.  MIPS executables use this\n      instead of DT_DEBUG, although they sometimes contain an unused\n      DT_DEBUG.  */\n-  if (scan_dyntag (DT_MIPS_RLD_MAP, current_program_space->exec_bfd (),\n-\t\t   &dyn_ptr, NULL)\n+  if (gdb_bfd_scan_elf_dyntag (DT_MIPS_RLD_MAP,\n+\t\t\t       current_program_space->exec_bfd (),\n+\t\t\t       &dyn_ptr, NULL)\n       || scan_dyntag_auxv (DT_MIPS_RLD_MAP, &dyn_ptr, NULL))\n     {\n       struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n@@ -787,8 +685,9 @@ elf_locate_base (void)\n   /* Then check DT_MIPS_RLD_MAP_REL.  MIPS executables now use this form\n      because of needing to support PIE.  DT_MIPS_RLD_MAP will also exist\n      in non-PIE.  */\n-  if (scan_dyntag (DT_MIPS_RLD_MAP_REL, current_program_space->exec_bfd (),\n-\t\t   &dyn_ptr, &dyn_ptr_addr)\n+  if (gdb_bfd_scan_elf_dyntag (DT_MIPS_RLD_MAP_REL,\n+\t\t\t       current_program_space->exec_bfd (),\n+\t\t\t       &dyn_ptr, &dyn_ptr_addr)\n       || scan_dyntag_auxv (DT_MIPS_RLD_MAP_REL, &dyn_ptr, &dyn_ptr_addr))\n     {\n       struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n@@ -804,7 +703,8 @@ elf_locate_base (void)\n     }\n \n   /* Find DT_DEBUG.  */\n-  if (scan_dyntag (DT_DEBUG, current_program_space->exec_bfd (), &dyn_ptr, NULL)\n+  if (gdb_bfd_scan_elf_dyntag (DT_DEBUG, current_program_space->exec_bfd (),\n+\t\t\t       &dyn_ptr, NULL)\n       || scan_dyntag_auxv (DT_DEBUG, &dyn_ptr, NULL))\n     return dyn_ptr;\n \n@@ -3258,7 +3158,7 @@ svr4_iterate_over_objfiles_in_search_order\n \tabfd = current_objfile->obfd;\n \n       if (abfd != nullptr\n-\t  && scan_dyntag (DT_SYMBOLIC, abfd, nullptr, nullptr) == 1)\n+\t  && gdb_bfd_scan_elf_dyntag (DT_SYMBOLIC, abfd, nullptr, nullptr) == 1)\n \t{\n \t  checked_current_objfile = true;\n \t  if (cb (current_objfile, cb_data) != 0)"
    },
    {
      "sha": "e30affbb7e78cff22ed57cbf8f8978143ce1cca9",
      "filename": "gdb/solib.c",
      "status": "modified",
      "additions": 104,
      "deletions": 0,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.c?ref=8ddf46454aa981246f9611b1897f41fabd2a108d",
      "patch": "@@ -35,6 +35,8 @@\n #include \"language.h\"\n #include \"gdbcmd.h\"\n #include \"completer.h\"\n+#include \"elf/external.h\"\n+#include \"elf/common.h\"\n #include \"filenames.h\"\t\t/* for DOSish file names */\n #include \"exec.h\"\n #include \"solist.h\"\n@@ -1481,6 +1483,108 @@ gdb_bfd_lookup_symbol_from_symtab (bfd *abfd,\n   return symaddr;\n }\n \n+/* See solib.h.  */\n+\n+int\n+gdb_bfd_scan_elf_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n+\t\t\t CORE_ADDR *ptr_addr)\n+{\n+  int arch_size, step, sect_size;\n+  long current_dyntag;\n+  CORE_ADDR dyn_ptr, dyn_addr;\n+  gdb_byte *bufend, *bufstart, *buf;\n+  Elf32_External_Dyn *x_dynp_32;\n+  Elf64_External_Dyn *x_dynp_64;\n+  struct bfd_section *sect;\n+\n+  if (abfd == NULL)\n+    return 0;\n+\n+  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n+    return 0;\n+\n+  arch_size = bfd_get_arch_size (abfd);\n+  if (arch_size == -1)\n+    return 0;\n+\n+  /* Find the start address of the .dynamic section.  */\n+  sect = bfd_get_section_by_name (abfd, \".dynamic\");\n+  if (sect == NULL)\n+    return 0;\n+\n+  bool found = false;\n+  for (const target_section &target_section\n+\t : current_program_space->target_sections ())\n+    if (sect == target_section.the_bfd_section)\n+      {\n+\tdyn_addr = target_section.addr;\n+\tfound = true;\n+\tbreak;\n+      }\n+  if (!found)\n+    {\n+      /* ABFD may come from OBJFILE acting only as a symbol file without being\n+\t loaded into the target (see add_symbol_file_command).  This case is\n+\t such fallback to the file VMA address without the possibility of\n+\t having the section relocated to its actual in-memory address.  */\n+\n+      dyn_addr = bfd_section_vma (sect);\n+    }\n+\n+  /* Read in .dynamic from the BFD.  We will get the actual value\n+     from memory later.  */\n+  sect_size = bfd_section_size (sect);\n+  buf = bufstart = (gdb_byte *) alloca (sect_size);\n+  if (!bfd_get_section_contents (abfd, sect,\n+\t\t\t\t buf, 0, sect_size))\n+    return 0;\n+\n+  /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */\n+  step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)\n+\t\t\t   : sizeof (Elf64_External_Dyn);\n+  for (bufend = buf + sect_size;\n+       buf < bufend;\n+       buf += step)\n+  {\n+    if (arch_size == 32)\n+      {\n+\tx_dynp_32 = (Elf32_External_Dyn *) buf;\n+\tcurrent_dyntag = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_tag);\n+\tdyn_ptr = bfd_h_get_32 (abfd, (bfd_byte *) x_dynp_32->d_un.d_ptr);\n+      }\n+    else\n+      {\n+\tx_dynp_64 = (Elf64_External_Dyn *) buf;\n+\tcurrent_dyntag = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_tag);\n+\tdyn_ptr = bfd_h_get_64 (abfd, (bfd_byte *) x_dynp_64->d_un.d_ptr);\n+      }\n+    if (current_dyntag == DT_NULL)\n+      return 0;\n+    if (current_dyntag == desired_dyntag)\n+      {\n+\t/* If requested, try to read the runtime value of this .dynamic\n+\t   entry.  */\n+\tif (ptr)\n+\t  {\n+\t    struct type *ptr_type;\n+\t    gdb_byte ptr_buf[8];\n+\t    CORE_ADDR ptr_addr_1;\n+\n+\t    ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n+\t    ptr_addr_1 = dyn_addr + (buf - bufstart) + arch_size / 8;\n+\t    if (target_read_memory (ptr_addr_1, ptr_buf, arch_size / 8) == 0)\n+\t      dyn_ptr = extract_typed_address (ptr_buf, ptr_type);\n+\t    *ptr = dyn_ptr;\n+\t    if (ptr_addr)\n+\t      *ptr_addr = dyn_addr + (buf - bufstart);\n+\t  }\n+\treturn 1;\n+      }\n+  }\n+\n+  return 0;\n+}\n+\n /* Lookup the value for a specific symbol from symbol table.  Look up symbol\n    from ABFD.  MATCH_SYM is a callback function to determine whether to pick\n    up a symbol.  DATA is the input of this callback function.  Return NULL"
    },
    {
      "sha": "c50f74e06bfa5e166200f2f18e90991c24fbe86a",
      "filename": "gdb/solib.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ddf46454aa981246f9611b1897f41fabd2a108d/gdb/solib.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.h?ref=8ddf46454aa981246f9611b1897f41fabd2a108d",
      "patch": "@@ -112,6 +112,12 @@ extern CORE_ADDR gdb_bfd_lookup_symbol_from_symtab (bfd *abfd,\n \t\t\t\t\t\t       const void *),\n \t\t\t\t\t\t    const void *data);\n \n+/* Scan for DESIRED_DYNTAG in .dynamic section of ABFD.  If DESIRED_DYNTAG is\n+   found, 1 is returned and the corresponding PTR and PTR_ADDR are set.  */\n+\n+extern int gdb_bfd_scan_elf_dyntag (const int desired_dyntag, bfd *abfd,\n+\t\t\t\t    CORE_ADDR *ptr, CORE_ADDR *ptr_addr);\n+\n /* Enable or disable optional solib event breakpoints as appropriate.  */\n \n extern void update_solib_breakpoints (void);"
    }
  ]
}