{
  "sha": "143275ea7e56baf5ad7a736698b79a90b473183a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTQzMjc1ZWE3ZTU2YmFmNWFkN2E3MzY2OThiNzlhOTBiNDczMTgzYQ==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T12:57:57Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:37:09Z"
    },
    "message": "[PATCH 39/57][Arm][OBJDUMP] Add support for MVE instructions: vpt, vpst and vcmp\n\nopcodes/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* arm-dis.c (enum mve_instructions): Add new instructions.\n\t(enum mve_unpredictable): Add new values.\n\t(mve_opcodes): Add new instructions.\n\t(vec_condnames): New array with vector conditions.\n\t(mve_predicatenames): New array with predicate suffixes.\n\t(mve_vec_sizename): New array with vector sizes.\n\t(enum vpt_pred_state): New enum with vector predication states.\n\t(struct vpt_block): New struct type for vpt blocks.\n\t(vpt_block_state): Global struct to keep track of state.\n\t(mve_extract_pred_mask): New helper function.\n\t(num_instructions_vpt_block): Likewise.\n\t(mark_outside_vpt_block): Likewise.\n\t(mark_inside_vpt_block): Likewise.\n\t(invert_next_predicate_state): Likewise.\n\t(update_next_predicate_state): Likewise.\n\t(update_vpt_block_state): Likewise.\n\t(is_vpt_instruction): Likewise.\n\t(is_mve_encoding_conflict): Add entries for new instructions.\n\t(is_mve_unpredictable): Likewise.\n\t(print_mve_unpredictable): Handle new cases.\n\t(print_instruction_predicate): Likewise.\n\t(print_mve_size): New function.\n\t(print_vec_condition): New function.\n\t(print_insn_mve): Handle vpt blocks and new print operands.",
    "tree": {
      "sha": "7c342d48f690ab50fc8ef1d2b70ba0f6f6bd8254",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7c342d48f690ab50fc8ef1d2b70ba0f6f6bd8254"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/143275ea7e56baf5ad7a736698b79a90b473183a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/143275ea7e56baf5ad7a736698b79a90b473183a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/143275ea7e56baf5ad7a736698b79a90b473183a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/143275ea7e56baf5ad7a736698b79a90b473183a/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f08d8ce3cd39f34f26dbc681d873e59a0d7e6780",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f08d8ce3cd39f34f26dbc681d873e59a0d7e6780",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f08d8ce3cd39f34f26dbc681d873e59a0d7e6780"
    }
  ],
  "stats": {
    "total": 654,
    "additions": 642,
    "deletions": 12
  },
  "files": [
    {
      "sha": "7abc8e2790d63d23ab510e5b0e72ff8ea64dbb72",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143275ea7e56baf5ad7a736698b79a90b473183a/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143275ea7e56baf5ad7a736698b79a90b473183a/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=143275ea7e56baf5ad7a736698b79a90b473183a",
      "patch": "@@ -1,3 +1,31 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* arm-dis.c (enum mve_instructions): Add new instructions.\n+\t(enum mve_unpredictable): Add new values.\n+\t(mve_opcodes): Add new instructions.\n+\t(vec_condnames): New array with vector conditions.\n+\t(mve_predicatenames): New array with predicate suffixes.\n+\t(mve_vec_sizename): New array with vector sizes.\n+\t(enum vpt_pred_state): New enum with vector predication states.\n+\t(struct vpt_block): New struct type for vpt blocks.\n+\t(vpt_block_state): Global struct to keep track of state.\n+\t(mve_extract_pred_mask): New helper function.\n+\t(num_instructions_vpt_block): Likewise.\n+\t(mark_outside_vpt_block): Likewise.\n+\t(mark_inside_vpt_block): Likewise.\n+\t(invert_next_predicate_state): Likewise.\n+\t(update_next_predicate_state): Likewise.\n+\t(update_vpt_block_state): Likewise.\n+\t(is_vpt_instruction): Likewise.\n+\t(is_mve_encoding_conflict): Add entries for new instructions.\n+\t(is_mve_unpredictable): Likewise.\n+\t(print_mve_unpredictable): Handle new cases.\n+\t(print_instruction_predicate): Likewise.\n+\t(print_mve_size): New function.\n+\t(print_vec_condition): New function.\n+\t(print_insn_mve): Handle vpt blocks and new print operands.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* arm-dis.c (print_insn_coprocessor_1): Disable the use of coprocessors"
    },
    {
      "sha": "84ee48d1f5005d16b097a4628d4d9ad252dc7ad5",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 614,
      "deletions": 12,
      "changes": 626,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143275ea7e56baf5ad7a736698b79a90b473183a/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143275ea7e56baf5ad7a736698b79a90b473183a/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=143275ea7e56baf5ad7a736698b79a90b473183a",
      "patch": "@@ -21,6 +21,7 @@\n    MA 02110-1301, USA.  */\n \n #include \"sysdep.h\"\n+#include <assert.h>\n \n #include \"disassemble.h\"\n #include \"opcode/arm.h\"\n@@ -69,13 +70,34 @@ struct arm_private_data\n \n enum mve_instructions\n {\n+  MVE_VPST,\n+  MVE_VPT_FP_T1,\n+  MVE_VPT_FP_T2,\n+  MVE_VPT_VEC_T1,\n+  MVE_VPT_VEC_T2,\n+  MVE_VPT_VEC_T3,\n+  MVE_VPT_VEC_T4,\n+  MVE_VPT_VEC_T5,\n+  MVE_VPT_VEC_T6,\n+  MVE_VCMP_FP_T1,\n+  MVE_VCMP_FP_T2,\n+  MVE_VCMP_VEC_T1,\n+  MVE_VCMP_VEC_T2,\n+  MVE_VCMP_VEC_T3,\n+  MVE_VCMP_VEC_T4,\n+  MVE_VCMP_VEC_T5,\n+  MVE_VCMP_VEC_T6,\n   MVE_NONE\n };\n \n enum mve_unpredictable\n {\n   UNPRED_IT_BLOCK,\t\t/* Unpredictable because mve insn in it block.\n \t\t\t\t */\n+  UNPRED_FCA_0_FCB_1,\t\t/* Unpredictable because fcA = 0 and\n+\t\t\t\t   fcB = 1 (vpt).  */\n+  UNPRED_R13,\t\t\t/* Unpredictable because r13 (sp) or\n+\t\t\t\t   r15 (sp) used.  */\n   UNPRED_NONE\t\t\t/* No unpredictable behavior.  */\n };\n \n@@ -1781,10 +1803,114 @@ static const struct opcode32 neon_opcodes[] =\n \n    %%\t\t\t%\n \n-   */\n+   %i\t\t\tprint MVE predicate(s) for vpt and vpst\n+   %n\t\t\tprint vector comparison code for predicated instruction\n+   %v\t\t\tprint vector predicate for instruction in predicated\n+\t\t\tblock\n+   %<bitfield>Q\t\tprint as a MVE Q register\n+   %<bitfield>Z\t\tas %<>r but r15 is ZR instead of PC and r13 is\n+\t\t\tUNPREDICTABLE\n+   %<bitfield>s\t\tprint size for vector predicate & non VMOV instructions\n+*/\n \n static const struct mopcode32 mve_opcodes[] =\n {\n+  /* MVE.  */\n+\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPST,\n+   0xfe310f4d, 0xffbf1fff,\n+   \"vpst%i\"\n+  },\n+\n+  /* Floating point VPT T1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VPT_FP_T1,\n+   0xee310f00, 0xefb10f50,\n+   \"vpt%i.f%28s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Floating point VPT T2.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VPT_FP_T2,\n+   0xee310f40, 0xefb10f50,\n+   \"vpt%i.f%28s\\t%n, %17-19Q, %0-3Z\"},\n+\n+  /* Vector VPT T1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T1,\n+   0xfe010f00, 0xff811f51,\n+   \"vpt%i.i%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VPT T2.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T2,\n+   0xfe010f01, 0xff811f51,\n+   \"vpt%i.u%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VPT T3.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T3,\n+   0xfe011f00, 0xff811f50,\n+   \"vpt%i.s%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VPT T4.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T4,\n+   0xfe010f40, 0xff811f70,\n+   \"vpt%i.i%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+  /* Vector VPT T5.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T5,\n+   0xfe010f60, 0xff811f70,\n+   \"vpt%i.u%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+  /* Vector VPT T6.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VPT_VEC_T6,\n+   0xfe011f40, 0xff811f50,\n+   \"vpt%i.s%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+\n+  /* Vector VCMP floating point T1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VCMP_FP_T1,\n+   0xee310f00, 0xeff1ef50,\n+   \"vcmp%v.f%28s\\t%n, %17-19Q, %1-3,5Q\"},\n+\n+  /* Vector VCMP floating point T2.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE_FP),\n+   MVE_VCMP_FP_T2,\n+   0xee310f40, 0xeff1ef50,\n+   \"vcmp%v.f%28s\\t%n, %17-19Q, %0-3Z\"},\n+\n+  /* Vector VCMP T1.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T1,\n+   0xfe010f00, 0xffc1ff51,\n+   \"vcmp%v.i%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VCMP T2.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T2,\n+   0xfe010f01, 0xffc1ff51,\n+   \"vcmp%v.u%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VCMP T3.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T3,\n+   0xfe011f00, 0xffc1ff50,\n+   \"vcmp%v.s%20-21s\\t%n, %17-19Q, %1-3,5Q\"},\n+  /* Vector VCMP T4.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T4,\n+   0xfe010f40, 0xffc1ff70,\n+   \"vcmp%v.i%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+  /* Vector VCMP T5.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T5,\n+   0xfe010f60, 0xffc1ff70,\n+   \"vcmp%v.u%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+  /* Vector VCMP T6.  */\n+  {ARM_FEATURE_COPROC (FPU_MVE),\n+   MVE_VCMP_VEC_T6,\n+   0xfe011f40, 0xffc1ff50,\n+   \"vcmp%v.s%20-21s\\t%n, %17-19Q, %0-3Z\"},\n+\n+  {ARM_FEATURE_CORE_LOW (0),\n+   MVE_NONE,\n+   0x00000000, 0x00000000, 0}\n };\n \n /* Opcode tables: ARM, 16-bit Thumb, 32-bit Thumb.  All three are partially\n@@ -3379,6 +3505,56 @@ static const char *const iwmmxt_cregnames[] =\n   \"wcgr0\", \"wcgr1\", \"wcgr2\", \"wcgr3\", \"reserved\", \"reserved\", \"reserved\", \"reserved\"\n };\n \n+static const char *const vec_condnames[] =\n+{ \"eq\", \"ne\", \"cs\", \"hi\", \"ge\", \"lt\", \"gt\", \"le\"\n+};\n+\n+static const char *const mve_predicatenames[] =\n+{ \"\", \"ttt\", \"tt\", \"tte\", \"t\", \"tee\", \"te\", \"tet\", \"\",\n+  \"eee\", \"ee\", \"eet\", \"e\", \"ett\", \"et\", \"ete\"\n+};\n+\n+/* Names for 2-bit size field for mve vector isntructions.  */\n+static const char *const mve_vec_sizename[] =\n+  { \"8\", \"16\", \"32\", \"64\"};\n+\n+/* Indicates whether we are processing a then predicate,\n+   else predicate or none at all.  */\n+enum vpt_pred_state\n+{\n+  PRED_NONE,\n+  PRED_THEN,\n+  PRED_ELSE\n+};\n+\n+/* Information used to process a vpt block and subsequent instructions.  */\n+struct vpt_block\n+{\n+  /* Are we in a vpt block.  */\n+  bfd_boolean in_vpt_block;\n+\n+  /* Next predicate state if in vpt block.  */\n+  enum vpt_pred_state next_pred_state;\n+\n+  /* Mask from vpt/vpst instruction.  */\n+  long predicate_mask;\n+\n+  /* Instruction number in vpt block.  */\n+  long current_insn_num;\n+\n+  /* Number of instructions in vpt block..   */\n+  long num_pred_insn;\n+};\n+\n+static struct vpt_block vpt_block_state =\n+{\n+  FALSE,\n+  PRED_NONE,\n+  0,\n+  0,\n+  0\n+};\n+\n /* Default to GCC register name set.  */\n static unsigned int regname_selected = 1;\n \n@@ -3401,6 +3577,113 @@ static bfd_vma ifthen_address;\n \n \f\n /* Functions.  */\n+/* Extract the predicate mask for a VPT or VPST instruction.\n+   The mask is composed of bits 13-15 (Mkl) and bit 22 (Mkh).  */\n+\n+static long\n+mve_extract_pred_mask (long given)\n+{\n+  return ((given & 0x00400000) >> 19) | ((given & 0xe000) >> 13);\n+}\n+\n+/* Return the number of instructions in a MVE predicate block.  */\n+static long\n+num_instructions_vpt_block (long given)\n+{\n+  long mask = mve_extract_pred_mask (given);\n+  if (mask == 0)\n+    return 0;\n+\n+  if (mask == 8)\n+    return 1;\n+\n+  if ((mask & 7) == 4)\n+    return 2;\n+\n+  if ((mask & 3) == 2)\n+    return 3;\n+\n+  if ((mask & 1) == 1)\n+    return 4;\n+\n+  return 0;\n+}\n+\n+static void\n+mark_outside_vpt_block (void)\n+{\n+  vpt_block_state.in_vpt_block = FALSE;\n+  vpt_block_state.next_pred_state = PRED_NONE;\n+  vpt_block_state.predicate_mask = 0;\n+  vpt_block_state.current_insn_num = 0;\n+  vpt_block_state.num_pred_insn = 0;\n+}\n+\n+static void\n+mark_inside_vpt_block (long given)\n+{\n+  vpt_block_state.in_vpt_block = TRUE;\n+  vpt_block_state.next_pred_state = PRED_THEN;\n+  vpt_block_state.predicate_mask = mve_extract_pred_mask (given);\n+  vpt_block_state.current_insn_num = 0;\n+  vpt_block_state.num_pred_insn = num_instructions_vpt_block (given);\n+  assert (vpt_block_state.num_pred_insn >= 1);\n+}\n+\n+static enum vpt_pred_state\n+invert_next_predicate_state (enum vpt_pred_state astate)\n+{\n+  if (astate == PRED_THEN)\n+    return PRED_ELSE;\n+  else if (astate == PRED_ELSE)\n+    return PRED_THEN;\n+  else\n+    return PRED_NONE;\n+}\n+\n+static enum vpt_pred_state\n+update_next_predicate_state (void)\n+{\n+  long pred_mask = vpt_block_state.predicate_mask;\n+  long mask_for_insn = 0;\n+\n+  switch (vpt_block_state.current_insn_num)\n+    {\n+    case 1:\n+      mask_for_insn = 8;\n+      break;\n+\n+    case 2:\n+      mask_for_insn = 4;\n+      break;\n+\n+    case 3:\n+      mask_for_insn = 2;\n+      break;\n+\n+    case 4:\n+      return PRED_NONE;\n+    }\n+\n+  if (pred_mask & mask_for_insn)\n+    return invert_next_predicate_state (vpt_block_state.next_pred_state);\n+  else\n+    return vpt_block_state.next_pred_state;\n+}\n+\n+static void\n+update_vpt_block_state (void)\n+{\n+  vpt_block_state.current_insn_num++;\n+  if (vpt_block_state.current_insn_num == vpt_block_state.num_pred_insn)\n+    {\n+      /* No more instructions to process in vpt block.  */\n+      mark_outside_vpt_block ();\n+      return;\n+    }\n+\n+  vpt_block_state.next_pred_state = update_next_predicate_state ();\n+}\n \n /* Decode a bitfield of the form matching regexp (N(-N)?,)*N(-N)?.\n    Returns pointer to following character of the format string and\n@@ -3504,6 +3787,38 @@ is_mve_architecture (struct disassemble_info *info)\n     return FALSE;\n }\n \n+static bfd_boolean\n+is_vpt_instruction (long given)\n+{\n+\n+  /* If mkh:mkl is '0000' then its not a vpt/vpst instruction.  */\n+  if ((given & 0x0040e000) == 0)\n+    return FALSE;\n+\n+  /* VPT floating point T1 variant.  */\n+  if (((given & 0xefb10f50) == 0xee310f00 && ((given & 0x1001) != 0x1))\n+  /* VPT floating point T2 variant.  */\n+      || ((given & 0xefb10f50) == 0xee310f40)\n+  /* VPT vector T1 variant.  */\n+      || ((given & 0xff811f51) == 0xfe010f00)\n+  /* VPT vector T2 variant.  */\n+      || ((given & 0xff811f51) == 0xfe010f01\n+\t  && ((given & 0x300000) != 0x300000))\n+  /* VPT vector T3 variant.  */\n+      || ((given & 0xff811f50) == 0xfe011f00)\n+  /* VPT vector T4 variant.  */\n+      || ((given & 0xff811f70) == 0xfe010f40)\n+  /* VPT vector T5 variant.  */\n+      || ((given & 0xff811f70) == 0xfe010f60)\n+  /* VPT vector T6 variant.  */\n+      || ((given & 0xff811f50) == 0xfe011f40)\n+  /* VPST vector T variant.  */\n+      || ((given & 0xffbf1fff) == 0xfe310f4d))\n+    return TRUE;\n+  else\n+    return FALSE;\n+}\n+\n /* Decode a bitfield from opcode GIVEN, with starting bitfield = START\n    and ending bitfield = END.  END must be greater than START.  */\n \n@@ -3550,7 +3865,69 @@ static bfd_boolean\n is_mve_encoding_conflict (unsigned long given,\n \t\t\t  enum mve_instructions matched_insn)\n {\n-  return FALSE;\n+  switch (matched_insn)\n+    {\n+    case MVE_VPST:\n+      if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VPT_FP_T1:\n+      if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n+\treturn TRUE;\n+      if ((arm_decode_field (given, 12, 12) == 0)\n+\t  && (arm_decode_field (given, 0, 0) == 1))\n+\treturn TRUE;\n+      return FALSE;\n+\n+    case MVE_VPT_FP_T2:\n+      if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n+\treturn TRUE;\n+      if (arm_decode_field (given, 0, 3) == 0xd)\n+\treturn TRUE;\n+      return FALSE;\n+\n+    case MVE_VPT_VEC_T1:\n+    case MVE_VPT_VEC_T2:\n+    case MVE_VPT_VEC_T3:\n+    case MVE_VPT_VEC_T4:\n+    case MVE_VPT_VEC_T5:\n+    case MVE_VPT_VEC_T6:\n+      if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n+\treturn TRUE;\n+      if (arm_decode_field (given, 20, 21) == 3)\n+\treturn TRUE;\n+      return FALSE;\n+\n+    case MVE_VCMP_FP_T1:\n+      if ((arm_decode_field (given, 12, 12) == 0)\n+\t  && (arm_decode_field (given, 0, 0) == 1))\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VCMP_FP_T2:\n+      if (arm_decode_field (given, 0, 3) == 0xd)\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n+    case MVE_VCMP_VEC_T1:\n+    case MVE_VCMP_VEC_T2:\n+    case MVE_VCMP_VEC_T3:\n+    case MVE_VCMP_VEC_T4:\n+    case MVE_VCMP_VEC_T5:\n+    case MVE_VCMP_VEC_T6:\n+      if (arm_decode_field (given, 20, 21) == 3)\n+\treturn TRUE;\n+      else\n+\treturn FALSE;\n+\n+    default:\n+      return FALSE;\n+\n+    }\n }\n \n /* Return FALSE if GIVEN is not an undefined encoding for MATCHED_INSN.\n@@ -3576,18 +3953,37 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n {\n   *unpredictable_code = UNPRED_NONE;\n \n-  return FALSE;\n-}\n+  switch (matched_insn)\n+    {\n+    case MVE_VCMP_FP_T2:\n+    case MVE_VPT_FP_T2:\n+      if ((arm_decode_field (given, 12, 12) == 0)\n+\t  && (arm_decode_field (given, 5, 5) == 1))\n+\t{\n+\t  *unpredictable_code = UNPRED_FCA_0_FCB_1;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n \n-#define W_BIT 21\n-#define I_BIT 22\n-#define U_BIT 23\n-#define P_BIT 24\n+    case MVE_VPT_VEC_T4:\n+    case MVE_VPT_VEC_T5:\n+    case MVE_VPT_VEC_T6:\n+    case MVE_VCMP_VEC_T4:\n+    case MVE_VCMP_VEC_T5:\n+    case MVE_VCMP_VEC_T6:\n+      if (arm_decode_field (given, 0, 3) == 0xd)\n+\t{\n+\t  *unpredictable_code = UNPRED_R13;\n+\t  return TRUE;\n+\t}\n+      else\n+\treturn FALSE;\n \n-#define WRITEBACK_BIT_SET   (given & (1 << W_BIT))\n-#define IMMEDIATE_BIT_SET   (given & (1 << I_BIT))\n-#define NEGATIVE_BIT_SET   ((given & (1 << U_BIT)) == 0)\n-#define PRE_BIT_SET         (given & (1 << P_BIT))\n+    default:\n+      return FALSE;\n+    }\n+}\n \n static void\n print_mve_undefined (struct disassemble_info *info,\n@@ -3621,11 +4017,154 @@ print_mve_unpredictable (struct disassemble_info *info,\n       func (stream, \"mve instruction in it block\");\n       break;\n \n+    case UNPRED_FCA_0_FCB_1:\n+      func (stream, \"condition bits, fca = 0 and fcb = 1\");\n+      break;\n+\n+    case UNPRED_R13:\n+      func (stream, \"use of r13 (sp)\");\n+      break;\n+\n     case UNPRED_NONE:\n       break;\n     }\n }\n \n+static void\n+print_instruction_predicate (struct disassemble_info *info)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  if (vpt_block_state.next_pred_state == PRED_THEN)\n+    func (stream, \"t\");\n+  else if (vpt_block_state.next_pred_state == PRED_ELSE)\n+    func (stream, \"e\");\n+}\n+\n+static void\n+print_mve_size (struct disassemble_info *info,\n+\t\tunsigned long size,\n+\t\tenum mve_instructions matched_insn)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  switch (matched_insn)\n+    {\n+    case MVE_VCMP_VEC_T1:\n+    case MVE_VCMP_VEC_T2:\n+    case MVE_VCMP_VEC_T3:\n+    case MVE_VCMP_VEC_T4:\n+    case MVE_VCMP_VEC_T5:\n+    case MVE_VCMP_VEC_T6:\n+    case MVE_VPT_VEC_T1:\n+    case MVE_VPT_VEC_T2:\n+    case MVE_VPT_VEC_T3:\n+    case MVE_VPT_VEC_T4:\n+    case MVE_VPT_VEC_T5:\n+    case MVE_VPT_VEC_T6:\n+      if (size <= 3)\n+\tfunc (stream, \"%s\", mve_vec_sizename[size]);\n+      else\n+\tfunc (stream, \"<undef size>\");\n+      break;\n+\n+    case MVE_VCMP_FP_T1:\n+    case MVE_VCMP_FP_T2:\n+    case MVE_VPT_FP_T1:\n+    case MVE_VPT_FP_T2:\n+      if (size == 0)\n+\tfunc (stream, \"32\");\n+      else if (size == 1)\n+\tfunc (stream, \"16\");\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+static void\n+print_vec_condition (struct disassemble_info *info, long given,\n+\t\t     enum mve_instructions matched_insn)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+  long vec_cond = 0;\n+\n+  switch (matched_insn)\n+    {\n+    case MVE_VPT_FP_T1:\n+    case MVE_VCMP_FP_T1:\n+      vec_cond = (((given & 0x1000) >> 10)\n+\t\t  | ((given & 1) << 1)\n+\t\t  | ((given & 0x0080) >> 7));\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_FP_T2:\n+    case MVE_VCMP_FP_T2:\n+      vec_cond = (((given & 0x1000) >> 10)\n+\t\t  | ((given & 0x0020) >> 4)\n+\t\t  | ((given & 0x0080) >> 7));\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T1:\n+    case MVE_VCMP_VEC_T1:\n+      vec_cond = (given & 0x0080) >> 7;\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T2:\n+    case MVE_VCMP_VEC_T2:\n+      vec_cond = 2 | ((given & 0x0080) >> 7);\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T3:\n+    case MVE_VCMP_VEC_T3:\n+      vec_cond = 4 | ((given & 1) << 1) | ((given & 0x0080) >> 7);\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T4:\n+    case MVE_VCMP_VEC_T4:\n+      vec_cond = (given & 0x0080) >> 7;\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T5:\n+    case MVE_VCMP_VEC_T5:\n+      vec_cond = 2 | ((given & 0x0080) >> 7);\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_VPT_VEC_T6:\n+    case MVE_VCMP_VEC_T6:\n+      vec_cond = 4 | ((given & 0x0020) >> 4) | ((given & 0x0080) >> 7);\n+      func (stream, \"%s\",vec_condnames[vec_cond]);\n+      break;\n+\n+    case MVE_NONE:\n+    case MVE_VPST:\n+    default:\n+      break;\n+    }\n+}\n+\n+#define W_BIT 21\n+#define I_BIT 22\n+#define U_BIT 23\n+#define P_BIT 24\n+\n+#define WRITEBACK_BIT_SET (given & (1 << W_BIT))\n+#define IMMEDIATE_BIT_SET (given & (1 << I_BIT))\n+#define NEGATIVE_BIT_SET  ((given & (1 << U_BIT)) == 0)\n+#define PRE_BIT_SET\t  (given & (1 << P_BIT))\n+\n+\n /* Print one coprocessor instruction on INFO->STREAM.\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised coprocessor instruction.  */\n@@ -4975,6 +5514,62 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t      func (stream, \"%%\");\n \t\t      break;\n \n+\t\t    case 'c':\n+\t\t      if (ifthen_state)\n+\t\t\tfunc (stream, \"%s\", arm_conditional[IFTHEN_COND]);\n+\t\t      break;\n+\n+\t\t    case 'i':\n+\t\t      {\n+\t\t\tlong mve_mask = mve_extract_pred_mask (given);\n+\t\t\tfunc (stream, \"%s\", mve_predicatenames[mve_mask]);\n+\t\t      }\n+\t\t      break;\n+\n+\t\t    case 'n':\n+\t\t      print_vec_condition (info, given, insn->mve_op);\n+\t\t      break;\n+\n+\t\t    case 'v':\n+\t\t      print_instruction_predicate (info);\n+\t\t      break;\n+\n+\t\t    case '0': case '1': case '2': case '3': case '4':\n+\t\t    case '5': case '6': case '7': case '8': case '9':\n+\t\t      {\n+\t\t\tint width;\n+\t\t\tunsigned long value;\n+\n+\t\t\tc = arm_decode_bitfield (c, given, &value, &width);\n+\n+\t\t\tswitch (*c)\n+\t\t\t  {\n+\t\t\t  case 'Z':\n+\t\t\t    if (value == 13)\n+\t\t\t      is_unpredictable = TRUE;\n+\t\t\t    else if (value == 15)\n+\t\t\t      func (stream, \"zr\");\n+\t\t\t    else\n+\t\t\t      func (stream, \"%s\", arm_regnames[value]);\n+\t\t\t    break;\n+\t\t\t  case 's':\n+\t\t\t    print_mve_size (info,\n+\t\t\t\t\t    value,\n+\t\t\t\t\t    insn->mve_op);\n+\t\t\t    break;\n+\t\t\t  case 'Q':\n+\t\t\t    if (value & 0x8)\n+\t\t\t      func (stream, \"<illegal reg q%ld.5>\", value);\n+\t\t\t    else\n+\t\t\t      func (stream, \"q%ld\", value);\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    abort ();\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\tabort ();\n+\t\t      }\n \t\t    }\n \t\t}\n \t      else\n@@ -4990,6 +5585,13 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t  if (is_undefined)\n \t    print_mve_undefined (info, undefined_cond);\n \n+\t  if ((vpt_block_state.in_vpt_block == FALSE)\n+\t      && !ifthen_state\n+\t      && (is_vpt_instruction (given) == TRUE))\n+\t    mark_inside_vpt_block (given);\n+\t  else if (vpt_block_state.in_vpt_block == TRUE)\n+\t    update_vpt_block_state ();\n+\n \t  return TRUE;\n \t}\n     }"
    }
  ]
}