{
  "sha": "1fd5fd5817dee816f30d0573b2d0ca1affb62836",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWZkNWZkNTgxN2RlZTgxNmYzMGQwNTczYjJkMGNhMWFmZmI2MjgzNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-07-04T19:48:33Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-07-17T17:08:18Z"
    },
    "message": "Fix file-name handling regression with DWARF index\n\nWhen run with the gdb-index or debug-names target boards, dup-psym.exp\nfails.  This came up for me because my new DWARF scanner reuses this\npart of the existing index code, and so it registers as a regression.\nThis is PR symtab/25834.\n\nLooking into this, I found that the DWARF index code here is fairly\ndifferent from the psymtab code.  I don't think there's a deep reason\nfor this, and in fact, it seemed to me that the index code could\nsimply mimic what the psymtab code already does.\n\nThat is what this patch implements.  The DW_AT_name and DW_AT_comp_dir\nare now stored in the quick file names table.  This may require\nallocating a quick file names table even when DW_AT_stmt_list does not\nexist.  Then, the functions that work with this data are changed to\nuse find_source_or_rewrite, just as the psymbol code does.  Finally,\nline_header::file_full_name is removed, as it is no longer needed.\n\nCurrently, the index maintains a hash table of \"quick file names\".\nThe hash table uses a deletion function to free the \"real name\"\ncomponents when necessary.  There's also a second such function to\nimplement the forget_cached_source_info method.\n\nThis bug fix patch will create a quick file name object even when\nthere is no DW_AT_stmt_list, meaning that the object won't be entered\nin the hash table.  So, this patch changes the memory management\napproach so that the entries are cleared when the per-BFD object is\ndestroyed.  (A dwarf2_per_cu_data destructor is not introduced,\nbecause we have been avoiding adding a vtable to that class.)\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=25834",
    "tree": {
      "sha": "9da8893dbc53ac39993041dc09b78841bfc1c3f0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9da8893dbc53ac39993041dc09b78841bfc1c3f0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1fd5fd5817dee816f30d0573b2d0ca1affb62836",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1fd5fd5817dee816f30d0573b2d0ca1affb62836",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1fd5fd5817dee816f30d0573b2d0ca1affb62836",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1fd5fd5817dee816f30d0573b2d0ca1affb62836/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "15659f0a4ea0787d2c2194a4e3712a56ac3eff84",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/15659f0a4ea0787d2c2194a4e3712a56ac3eff84",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/15659f0a4ea0787d2c2194a4e3712a56ac3eff84"
    }
  ],
  "stats": {
    "total": 168,
    "additions": 84,
    "deletions": 84
  },
  "files": [
    {
      "sha": "15195764c898e3427914039e72fc4c0ce232b029",
      "filename": "gdb/dwarf2/line-header.c",
      "status": "modified",
      "additions": 0,
      "deletions": 19,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/line-header.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/line-header.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.c?ref=1fd5fd5817dee816f30d0573b2d0ca1affb62836",
      "patch": "@@ -96,25 +96,6 @@ line_header::file_file_name (int file) const\n     }\n }\n \n-gdb::unique_xmalloc_ptr<char>\n-line_header::file_full_name (int file, const char *comp_dir) const\n-{\n-  /* Is the file number a valid index into the line header's file name\n-     table?  Remember that file numbers start with one, not zero.  */\n-  if (is_valid_file_index (file))\n-    {\n-      gdb::unique_xmalloc_ptr<char> relative = file_file_name (file);\n-\n-      if (IS_ABSOLUTE_PATH (relative.get ()) || comp_dir == NULL)\n-\treturn relative;\n-      return gdb::unique_xmalloc_ptr<char> (concat (comp_dir, SLASH_STRING,\n-\t\t\t\t\t\t    relative.get (),\n-\t\t\t\t\t\t    (char *) NULL));\n-    }\n-  else\n-    return file_file_name (file);\n-}\n-\n static void\n dwarf2_statement_list_fits_in_line_number_section_complaint (void)\n {"
    },
    {
      "sha": "4cacb8ca344963a074ca67fd09f0b74d02a7ff40",
      "filename": "gdb/dwarf2/line-header.h",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/line-header.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/line-header.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/line-header.h?ref=1fd5fd5817dee816f30d0573b2d0ca1affb62836",
      "patch": "@@ -162,13 +162,6 @@ struct line_header\n      header.  These point into dwarf2_per_objfile->line_buffer.  */\n   const gdb_byte *statement_program_start {}, *statement_program_end {};\n \n-  /* Return the full name of file number I in this object's file name\n-     table.  Use COMP_DIR as the name of the current directory of the\n-     compilation.  The result is allocated using xmalloc; the caller\n-     is responsible for freeing it.  */\n-  gdb::unique_xmalloc_ptr<char> file_full_name (int file,\n-\t\t\t\t\t\tconst char *comp_dir) const;\n-\n   /* Return file name relative to the compilation directory of file\n      number I in this object's file name table.  The result is\n      allocated using xmalloc; the caller is responsible for freeing"
    },
    {
      "sha": "029b8bfad0408d9c93b53720dc94cc6bb0b3bf72",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 81,
      "deletions": 58,
      "changes": 139,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=1fd5fd5817dee816f30d0573b2d0ca1affb62836",
      "patch": "@@ -1542,6 +1542,12 @@ struct file_and_directory\n static file_and_directory find_file_and_directory (struct die_info *die,\n \t\t\t\t\t\t   struct dwarf2_cu *cu);\n \n+static const char *compute_include_file_name\n+     (const struct line_header *lh,\n+      const file_entry &fe,\n+      const file_and_directory &cu_info,\n+      gdb::unique_xmalloc_ptr<char> *name_holder);\n+\n static htab_up allocate_signatured_type_table ();\n \n static htab_up allocate_dwo_unit_table ();\n@@ -1654,7 +1660,10 @@ dwarf2_per_bfd::dwarf2_per_bfd (bfd *obfd, const dwarf2_debug_sections *names,\n dwarf2_per_bfd::~dwarf2_per_bfd ()\n {\n   for (auto &per_cu : all_comp_units)\n-    per_cu->imported_symtabs_free ();\n+    {\n+      per_cu->imported_symtabs_free ();\n+      per_cu->free_cached_file_names ();\n+    }\n \n   /* Everything else should be on this->obstack.  */\n }\n@@ -1966,6 +1975,10 @@ struct quick_file_names\n   /* The number of entries in file_names, real_names.  */\n   unsigned int num_file_names;\n \n+  /* The CU directory, as given by DW_AT_comp_dir.  May be\n+     nullptr.  */\n+  const char *comp_dir;\n+\n   /* The file names from the line table, after being run through\n      file_full_name.  */\n   const char **file_names;\n@@ -2162,33 +2175,14 @@ eq_file_name_entry (const void *a, const void *b)\n   return eq_stmt_list_entry (&ea->hash, &eb->hash);\n }\n \n-/* Delete function for a quick_file_names.  */\n-\n-static void\n-delete_file_name_entry (void *e)\n-{\n-  struct quick_file_names *file_data = (struct quick_file_names *) e;\n-  int i;\n-\n-  for (i = 0; i < file_data->num_file_names; ++i)\n-    {\n-      xfree ((void*) file_data->file_names[i]);\n-      if (file_data->real_names)\n-\txfree ((void*) file_data->real_names[i]);\n-    }\n-\n-  /* The space for the struct itself lives on the obstack, so we don't\n-     free it here.  */\n-}\n-\n /* Create a quick_file_names hash table.  */\n \n static htab_up\n create_quick_file_names_table (unsigned int nr_initial_entries)\n {\n   return htab_up (htab_create_alloc (nr_initial_entries,\n \t\t\t\t     hash_file_name_entry, eq_file_name_entry,\n-\t\t\t\t     delete_file_name_entry, xcalloc, xfree));\n+\t\t\t\t     nullptr, xcalloc, xfree));\n }\n \n /* Read in CU (dwarf2_cu object) for PER_CU in the context of PER_OBJFILE.  This\n@@ -2930,30 +2924,50 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n \n       lh = dwarf_decode_line_header (line_offset, cu);\n     }\n-  if (lh == NULL)\n-    return;\n-\n-  qfn = XOBNEW (&per_objfile->per_bfd->obstack, struct quick_file_names);\n-  qfn->hash.dwo_unit = cu->dwo_unit;\n-  qfn->hash.line_sect_off = line_offset;\n-  gdb_assert (slot != NULL);\n-  *slot = qfn;\n \n   file_and_directory fnd = find_file_and_directory (comp_unit_die, cu);\n \n   int offset = 0;\n   if (strcmp (fnd.name, \"<unknown>\") != 0)\n     ++offset;\n+  else if (lh == nullptr)\n+    return;\n+\n+  qfn = XOBNEW (&per_objfile->per_bfd->obstack, struct quick_file_names);\n+  qfn->hash.dwo_unit = cu->dwo_unit;\n+  qfn->hash.line_sect_off = line_offset;\n+  /* There may not be a DW_AT_stmt_list.  */\n+  if (slot != nullptr)\n+    *slot = qfn;\n+\n+  std::vector<const char *> include_names;\n+  if (lh != nullptr)\n+    {\n+      for (const auto &entry : lh->file_names ())\n+\t{\n+\t  gdb::unique_xmalloc_ptr<char> name_holder;\n+\t  const char *include_name =\n+\t    compute_include_file_name (lh.get (), entry, fnd, &name_holder);\n+\t  if (include_name != nullptr)\n+\t    {\n+\t      include_name = per_objfile->objfile->intern (include_name);\n+\t      include_names.push_back (include_name);\n+\t    }\n+\t}\n+    }\n \n-  qfn->num_file_names = offset + lh->file_names_size ();\n+  qfn->num_file_names = offset + include_names.size ();\n+  qfn->comp_dir = fnd.comp_dir;\n   qfn->file_names =\n     XOBNEWVEC (&per_objfile->per_bfd->obstack, const char *,\n \t       qfn->num_file_names);\n   if (offset != 0)\n     qfn->file_names[0] = xstrdup (fnd.name);\n-  for (int i = 0; i < lh->file_names_size (); ++i)\n-    qfn->file_names[i + offset] = lh->file_full_name (i + 1,\n-\t\t\t\t\t\t      fnd.comp_dir).release ();\n+\n+  if (!include_names.empty ())\n+    memcpy (&qfn->file_names[offset], include_names.data (),\n+\t    include_names.size () * sizeof (const char *));\n+\n   qfn->real_names = NULL;\n \n   lh_cu->v.quick->file_names = qfn;\n@@ -2993,7 +3007,17 @@ dw2_get_real_path (dwarf2_per_objfile *per_objfile,\n \t\t\t\t      qfn->num_file_names, const char *);\n \n   if (qfn->real_names[index] == NULL)\n-    qfn->real_names[index] = gdb_realpath (qfn->file_names[index]).release ();\n+    {\n+      const char *dirname = nullptr;\n+\n+      if (!IS_ABSOLUTE_PATH (qfn->file_names[index]))\n+\tdirname = qfn->comp_dir;\n+\n+      gdb::unique_xmalloc_ptr<char> fullname;\n+      fullname = find_source_or_rewrite (qfn->file_names[index], dirname);\n+\n+      qfn->real_names[index] = fullname.release ();\n+    }\n \n   return qfn->real_names[index];\n }\n@@ -3012,25 +3036,23 @@ dwarf2_base_index_functions::find_last_source_symtab (struct objfile *objfile)\n   return compunit_primary_filetab (cust);\n }\n \n-/* Traversal function for dw2_forget_cached_source_info.  */\n+/* See read.h.  */\n \n-static int\n-dw2_free_cached_file_names (void **slot, void *info)\n+void\n+dwarf2_per_cu_data::free_cached_file_names ()\n {\n-  struct quick_file_names *file_data = (struct quick_file_names *) *slot;\n+  if (per_bfd == nullptr || !per_bfd->using_index || v.quick == nullptr)\n+    return;\n \n-  if (file_data->real_names)\n+  struct quick_file_names *file_data = v.quick->file_names;\n+  if (file_data != nullptr && file_data->real_names != nullptr)\n     {\n-      int i;\n-\n-      for (i = 0; i < file_data->num_file_names; ++i)\n+      for (int i = 0; i < file_data->num_file_names; ++i)\n \t{\n-\t  xfree ((void*) file_data->real_names[i]);\n-\t  file_data->real_names[i] = NULL;\n+\t  xfree ((void *) file_data->real_names[i]);\n+\t  file_data->real_names[i] = nullptr;\n \t}\n     }\n-\n-  return 1;\n }\n \n void\n@@ -3039,8 +3061,8 @@ dwarf2_base_index_functions::forget_cached_source_info\n {\n   dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n \n-  htab_traverse_noresize (per_objfile->per_bfd->quick_file_names_table.get (),\n-\t\t\t  dw2_free_cached_file_names, NULL);\n+  for (auto &per_cu : per_objfile->per_bfd->all_comp_units)\n+    per_cu->free_cached_file_names ();\n }\n \n /* Struct used to manage iterating over all CUs looking for a symbol.  */\n@@ -4444,18 +4466,19 @@ dwarf2_base_index_functions::map_symbol_filenames\n       for (int j = 0; j < file_data->num_file_names; ++j)\n \t{\n \t  const char *filename = file_data->file_names[j];\n-\t  filenames_cache.seen (filename);\n-\t}\n-    }\n+\t  const char *key = filename;\n+\t  const char *fullname = nullptr;\n \n-  filenames_cache.traverse ([&] (const char *filename)\n-    {\n-      gdb::unique_xmalloc_ptr<char> this_real_name;\n+\t  if (need_fullname)\n+\t    {\n+\t      fullname = dw2_get_real_path (per_objfile, file_data, j);\n+\t      key = fullname;\n+\t    }\n \n-      if (need_fullname)\n-\tthis_real_name = gdb_realpath (filename);\n-      fun (filename, this_real_name.get ());\n-    });\n+\t  if (!filenames_cache.seen (key))\n+\t    fun (filename, fullname);\n+\t}\n+    }\n }\n \n bool"
    },
    {
      "sha": "08ef179112cb4a90e513b3508019a322222c3414",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fd5fd5817dee816f30d0573b2d0ca1affb62836/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=1fd5fd5817dee816f30d0573b2d0ca1affb62836",
      "patch": "@@ -275,6 +275,9 @@ struct dwarf2_per_cu_data\n   {\n     return section == nullptr;\n   }\n+\n+  /* Free any cached file names.  */\n+  void free_cached_file_names ();\n };\n \n /* Entry in the signatured_types hash table.  */"
    }
  ]
}