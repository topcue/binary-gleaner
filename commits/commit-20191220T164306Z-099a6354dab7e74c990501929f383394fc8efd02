{
  "sha": "099a6354dab7e74c990501929f383394fc8efd02",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDk5YTYzNTRkYWI3ZTc0Yzk5MDUwMTkyOWYzODMzOTRmYzhlZmQwMg==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:06Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:06Z"
    },
    "message": "infcall: handle pass-by-reference arguments appropriately\n\nIf an aggregate argument is implicitly pass-by-reference, allocate a\ntemporary object on the stack, initialize it via the copy constructor\n(if exists) or trivially by memcpy'ing.  Pass the reference of the\ntemporary to the callee function.  After the callee returns, invoke\nthe destructor of the temporary.\n\ngdb/ChangeLog:\n2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\tPR gdb/25054\n\t* infcall.c (call_function_by_hand_dummy): Update the argument-\n\tpassing section for call-by-value parameters.\n\t(struct destructor_info): New struct.\n\t(call_destructors): New auxiliary function.\n\nChange-Id: I18fa5d0df814dfa0defe9e862a88a6dbf1d99d01",
    "tree": {
      "sha": "a9a1bbfc10c14ff65af9b6d9e8cdf6106a07e197",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a9a1bbfc10c14ff65af9b6d9e8cdf6106a07e197"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/099a6354dab7e74c990501929f383394fc8efd02",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/099a6354dab7e74c990501929f383394fc8efd02",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/099a6354dab7e74c990501929f383394fc8efd02",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/099a6354dab7e74c990501929f383394fc8efd02/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "62bf63d74d54482d42e9d78890ebc0dd4675e23b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62bf63d74d54482d42e9d78890ebc0dd4675e23b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/62bf63d74d54482d42e9d78890ebc0dd4675e23b"
    }
  ],
  "stats": {
    "total": 135,
    "additions": 132,
    "deletions": 3
  },
  "files": [
    {
      "sha": "c2157e44fdb9821998873ca3820820bea8bb00e4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/099a6354dab7e74c990501929f383394fc8efd02/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/099a6354dab7e74c990501929f383394fc8efd02/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=099a6354dab7e74c990501929f383394fc8efd02",
      "patch": "@@ -1,3 +1,11 @@\n+2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\tPR gdb/25054\n+\t* infcall.c (call_function_by_hand_dummy): Update the argument-\n+\tpassing section for call-by-value parameters.\n+\t(struct destructor_info): New struct.\n+\t(call_destructors): New auxiliary function.\n+\n 2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* gnu-v3-abi.c (enum definition_style): New enum type."
    },
    {
      "sha": "b6b617aa44b446ff51cd708cd4a48109bc0d1b24",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 124,
      "deletions": 3,
      "changes": 127,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/099a6354dab7e74c990501929f383394fc8efd02/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/099a6354dab7e74c990501929f383394fc8efd02/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=099a6354dab7e74c990501929f383394fc8efd02",
      "patch": "@@ -42,6 +42,7 @@\n #include \"thread-fsm.h\"\n #include <algorithm>\n #include \"gdbsupport/scope-exit.h\"\n+#include <list>\n \n /* If we can't find a function's name from its address,\n    we print this instead.  */\n@@ -704,6 +705,33 @@ reserve_stack_space (const type *values_type, CORE_ADDR &sp)\n   return addr;\n }\n \n+/* The data structure which keeps a destructor function and\n+   its implicit 'this' parameter.  */\n+\n+struct destructor_info\n+{\n+  destructor_info (struct value *function, struct value *self)\n+    : function (function), self (self) { }\n+\n+  struct value *function;\n+  struct value *self;\n+};\n+\n+\n+/* Auxiliary function that takes a list of destructor functions\n+   with their 'this' parameters, and invokes the functions.  */\n+\n+static void\n+call_destructors (const std::list<destructor_info> &dtors_to_invoke,\n+\t\t  struct type *default_return_type)\n+{\n+  for (auto vals : dtors_to_invoke)\n+    {\n+      call_function_by_hand (vals.function, default_return_type,\n+\t\t\t     gdb::make_array_view (&(vals.self), 1));\n+    }\n+}\n+\n /* See infcall.h.  */\n \n struct value *\n@@ -983,6 +1011,12 @@ call_function_by_hand_dummy (struct value *function,\n       internal_error (__FILE__, __LINE__, _(\"bad switch\"));\n     }\n \n+  /* Coerce the arguments and handle pass-by-reference.\n+     We want to remember the destruction required for pass-by-ref values.\n+     For these, store the dtor function and the 'this' argument\n+     in DTORS_TO_INVOKE.  */\n+  std::list<destructor_info> dtors_to_invoke;\n+\n   for (int i = args.size () - 1; i >= 0; i--)\n     {\n       int prototyped;\n@@ -1017,12 +1051,95 @@ call_function_by_hand_dummy (struct value *function,\n       else\n \tparam_type = NULL;\n \n+      value *original_arg = args[i];\n       args[i] = value_arg_coerce (gdbarch, args[i],\n \t\t\t\t  param_type, prototyped);\n \n-      if (param_type != NULL\n-\t  && !(language_pass_by_reference (param_type).trivially_copyable))\n-\targs[i] = value_addr (args[i]);\n+      if (param_type == NULL)\n+\tcontinue;\n+\n+      auto info = language_pass_by_reference (param_type);\n+      if (!info.copy_constructible)\n+\terror (_(\"expression cannot be evaluated because the type '%s' \"\n+\t\t \"is not copy constructible\"), TYPE_NAME (param_type));\n+\n+      if (!info.destructible)\n+\terror (_(\"expression cannot be evaluated because the type '%s' \"\n+\t\t \"is not destructible\"), TYPE_NAME (param_type));\n+\n+      if (info.trivially_copyable)\n+\tcontinue;\n+\n+      /* Make a copy of the argument on the stack.  If the argument is\n+\t trivially copy ctor'able, copy bit by bit.  Otherwise, call\n+\t the copy ctor to initialize the clone.  */\n+      CORE_ADDR addr = reserve_stack_space (param_type, sp);\n+      value *clone\n+\t= value_from_contents_and_address (param_type, nullptr, addr);\n+      push_thread_stack_temporary (call_thread.get (), clone);\n+      value *clone_ptr\n+\t= value_from_pointer (lookup_pointer_type (param_type), addr);\n+\n+      if (info.trivially_copy_constructible)\n+\t{\n+\t  int length = TYPE_LENGTH (param_type);\n+\t  write_memory (addr, value_contents (args[i]), length);\n+\t}\n+      else\n+\t{\n+\t  value *copy_ctor;\n+\t  value *cctor_args[2] = { clone_ptr, original_arg };\n+\t  find_overload_match (gdb::make_array_view (cctor_args, 2),\n+\t\t\t       TYPE_NAME (param_type), METHOD,\n+\t\t\t       &clone_ptr, nullptr, &copy_ctor, nullptr,\n+\t\t\t       nullptr, 0, EVAL_NORMAL);\n+\n+\t  if (copy_ctor == nullptr)\n+\t    error (_(\"expression cannot be evaluated because a copy \"\n+\t\t     \"constructor for the type '%s' could not be found \"\n+\t\t     \"(maybe inlined?)\"), TYPE_NAME (param_type));\n+\n+\t  call_function_by_hand (copy_ctor, default_return_type,\n+\t\t\t\t gdb::make_array_view (cctor_args, 2));\n+\t}\n+\n+      /* If the argument has a destructor, remember it so that we\n+\t invoke it after the infcall is complete.  */\n+      if (!info.trivially_destructible)\n+\t{\n+\t  /* Looking up the function via overload resolution does not\n+\t     work because the compiler (in particular, gcc) adds an\n+\t     artificial int parameter in some cases.  So we look up\n+\t     the function by using the \"~\" name.  This should be OK\n+\t     because there can be only one dtor definition.  */\n+\t  const char *dtor_name = nullptr;\n+\t  for (int fieldnum = 0;\n+\t       fieldnum < TYPE_NFN_FIELDS (param_type);\n+\t       fieldnum++)\n+\t    {\n+\t      fn_field *fn\n+\t\t= TYPE_FN_FIELDLIST1 (param_type, fieldnum);\n+\t      const char *field_name\n+\t\t= TYPE_FN_FIELDLIST_NAME (param_type, fieldnum);\n+\n+\t      if (field_name[0] == '~')\n+\t\tdtor_name = TYPE_FN_FIELD_PHYSNAME (fn, 0);\n+\t    }\n+\n+\t  if (dtor_name == nullptr)\n+\t    error (_(\"expression cannot be evaluated because a destructor \"\n+\t\t     \"for the type '%s' could not be found \"\n+\t\t     \"(maybe inlined?)\"), TYPE_NAME (param_type));\n+\n+\t  value *dtor\n+\t    = find_function_in_inferior (dtor_name, 0);\n+\n+\t  /* Insert the dtor to the front of the list to call them\n+\t     in reverse order later.  */\n+\t  dtors_to_invoke.emplace_front (dtor, clone_ptr);\n+\t}\n+\n+      args[i] = clone_ptr;\n     }\n \n   /* Reserve space for the return structure to be written on the\n@@ -1189,6 +1306,10 @@ call_function_by_hand_dummy (struct value *function,\n \t    maybe_remove_breakpoints ();\n \n \t    gdb_assert (retval != NULL);\n+\n+\t    /* Destruct the pass-by-ref argument clones.  */\n+\t    call_destructors (dtors_to_invoke, default_return_type);\n+\n \t    return retval;\n \t  }\n "
    }
  ]
}