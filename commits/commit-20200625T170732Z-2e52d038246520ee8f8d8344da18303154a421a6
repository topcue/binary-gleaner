{
  "sha": "2e52d038246520ee8f8d8344da18303154a421a6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmU1MmQwMzgyNDY1MjBlZThmOGQ4MzQ0ZGExODMwMzE1NGE0MjFhNg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-06-16T13:53:12Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-06-25T17:07:32Z"
    },
    "message": "gdb/riscv: Record information about unknown tdesc registers\n\nMaking use of the previous commit, record information about unknown\nregisters in the target description, and use this to resolve two\nissues.\n\n1. Some targets (QEMU) are reporting three register fflags, frm, and\n   fcsr, twice, once in the FPU feature, and once in the CSR feature.\n   GDB does create two registers with identical names, but this\n   is (sort of) fine, we only ever use the first one, and as both\n   registers access the same target state things basically work OK.\n   The only real problem is that the register names show up twice in\n   'info registers all' output.\n\n   In this commit we spot the duplicates of these registers and then\n   return NULL when asked for the name of these registers.  This\n   causes GDB to hide these registers from the user, fixing this\n   problem.\n\n2. Some targets (QEMU) advertise CSRs that GDB then can't read.  The\n   problem is these targets also say these CSRs are part of the\n   save/restore register groups.\n\n   This means that before an inferior call GDB tries to save all of\n   these CSRs, and a failure to read one causes the inferior call to\n   be abandoned.\n\n   We already work around this issue to some degree, known CSRs are\n   removed from the save/restore groups, despite what the target might\n   say.  However, any unknown CSRs are (currently) not removed in this\n   way.\n\n   After this commit we keep a log of the register numbers for all\n   unknown CSRs, then when asked about the register groups, we\n   override the group information for unknown CSRs, removing them from\n   the save and restore groups.\n\ngdb/ChangeLog:\n\n\t* riscv-tdep.c (riscv_register_name): Return NULL for duplicate\n\tfflags, frm, and fcsr registers.\n\t(riscv_register_reggroup_p): Remove unknown CSRs from save and\n\trestore groups.\n\t(riscv_tdesc_unknown_reg): New function.\n\t(riscv_gdbarch_init): Pass riscv_tdesc_unknown_reg to\n\ttdesc_use_registers.\n\t* riscv-tdep.h (struct gdbarch_tdep): Add\n\tunknown_csrs_first_regnum, unknown_csrs_count,\n\tduplicate_fflags_regnum, duplicate_frm_regnum, and\n\tduplicate_fcsr_regnum fields.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.arch/riscv-tdesc-regs.exp: Extend test case.",
    "tree": {
      "sha": "04e47e704e5506c1ba56b0b3d04cea3b4fdd70d4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/04e47e704e5506c1ba56b0b3d04cea3b4fdd70d4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2e52d038246520ee8f8d8344da18303154a421a6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e52d038246520ee8f8d8344da18303154a421a6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2e52d038246520ee8f8d8344da18303154a421a6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e52d038246520ee8f8d8344da18303154a421a6/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "be64fd0776f78d8285e6c27125c0558386865e2f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/be64fd0776f78d8285e6c27125c0558386865e2f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/be64fd0776f78d8285e6c27125c0558386865e2f"
    }
  ],
  "stats": {
    "total": 148,
    "additions": 145,
    "deletions": 3
  },
  "files": [
    {
      "sha": "f3ede9463f3bfb3065a3412717ec7abe93ac60ce",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e52d038246520ee8f8d8344da18303154a421a6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e52d038246520ee8f8d8344da18303154a421a6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2e52d038246520ee8f8d8344da18303154a421a6",
      "patch": "@@ -1,3 +1,17 @@\n+2020-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* riscv-tdep.c (riscv_register_name): Return NULL for duplicate\n+\tfflags, frm, and fcsr registers.\n+\t(riscv_register_reggroup_p): Remove unknown CSRs from save and\n+\trestore groups.\n+\t(riscv_tdesc_unknown_reg): New function.\n+\t(riscv_gdbarch_init): Pass riscv_tdesc_unknown_reg to\n+\ttdesc_use_registers.\n+\t* riscv-tdep.h (struct gdbarch_tdep): Add\n+\tunknown_csrs_first_regnum, unknown_csrs_count,\n+\tduplicate_fflags_regnum, duplicate_frm_regnum, and\n+\tduplicate_fcsr_regnum fields.\n+\n 2020-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* target-descriptions.c (tdesc_use_registers): Add new parameter a"
    },
    {
      "sha": "cfc45d1a7f5818c328bb122a89da87294e5cb991",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 109,
      "deletions": 1,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e52d038246520ee8f8d8344da18303154a421a6/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e52d038246520ee8f8d8344da18303154a421a6/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=2e52d038246520ee8f8d8344da18303154a421a6",
      "patch": "@@ -617,6 +617,22 @@ riscv_register_name (struct gdbarch *gdbarch, int regnum)\n         return NULL;\n     }\n \n+  /* Some targets (QEMU) are reporting these three registers twice, once\n+     in the FPU feature, and once in the CSR feature.  Both of these read\n+     the same underlying state inside the target, but naming the register\n+     twice in the target description results in GDB having two registers\n+     with the same name, only one of which can ever be accessed, but both\n+     will show up in 'info register all'.  Unless, we identify the\n+     duplicate copies of these registers (in riscv_tdesc_unknown_reg) and\n+     then hide the registers here by giving them no name.  */\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  if (tdep->duplicate_fflags_regnum == regnum)\n+    return NULL;\n+  if (tdep->duplicate_frm_regnum == regnum)\n+    return NULL;\n+  if (tdep->duplicate_fcsr_regnum == regnum)\n+    return NULL;\n+\n   /* The remaining registers are different.  For all other registers on the\n      machine we prefer to see the names that the target description\n      provides.  This is particularly important for CSRs which might be\n@@ -968,6 +984,19 @@ riscv_register_reggroup_p (struct gdbarch  *gdbarch, int regnum,\n \n   if (regnum > RISCV_LAST_REGNUM)\n     {\n+      /* Any extra registers from the CSR tdesc_feature (identified in\n+\t riscv_tdesc_unknown_reg) are removed from the save/restore groups\n+\t as some targets (QEMU) report CSRs which then can't be read.  */\n+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      if ((reggroup == restore_reggroup || reggroup == save_reggroup)\n+\t  && regnum >= tdep->unknown_csrs_first_regnum\n+\t  && regnum < (tdep->unknown_csrs_first_regnum\n+\t\t       + tdep->unknown_csrs_count))\n+\treturn 0;\n+\n+      /* This is some other unknown register from the target description.\n+\t In this case we trust whatever the target description says about\n+\t which groups this register should be in.  */\n       int ret = tdesc_register_in_reggroup_p (gdbarch, regnum, reggroup);\n       if (ret != -1)\n         return ret;\n@@ -3166,6 +3195,85 @@ riscv_gcc_target_options (struct gdbarch *gdbarch)\n   return target_options;\n }\n \n+/* Call back from tdesc_use_registers, called for each unknown register\n+   found in the target description.\n+\n+   See target-description.h (typedef tdesc_unknown_register_ftype) for a\n+   discussion of the arguments and return values.  */\n+\n+static int\n+riscv_tdesc_unknown_reg (struct gdbarch *gdbarch, tdesc_feature *feature,\n+\t\t\t const char *reg_name, int possible_regnum)\n+{\n+  /* At one point in time GDB had an incorrect default target description\n+     that duplicated the fflags, frm, and fcsr registers in both the FPU\n+     and CSR register sets.\n+\n+     Some targets (QEMU) copied these target descriptions into their source\n+     tree, and so we're currently stuck working with some targets that\n+     declare the same registers twice.\n+\n+     There's not much we can do about this any more.  Assuming the target\n+     will direct a request for either register number to the correct\n+     underlying hardware register then it doesn't matter which one GDB\n+     uses, so long as we (GDB) are consistent (so that we don't end up with\n+     invalid cache misses).\n+\n+     As we always scan the FPU registers first, then the CSRs, if the\n+     target has included the offending registers in both sets then we will\n+     always see the FPU copies here, as the CSR versions will replace them\n+     in the register list.\n+\n+     To prevent these duplicates showing up in any of the register list,\n+     record their register numbers here.  */\n+  if (strcmp (tdesc_feature_name (feature), riscv_freg_feature.name) == 0)\n+    {\n+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      int *regnum_ptr = nullptr;\n+\n+      if (strcmp (reg_name, \"fflags\") == 0)\n+\tregnum_ptr = &tdep->duplicate_fflags_regnum;\n+      else if (strcmp (reg_name, \"frm\") == 0)\n+\tregnum_ptr = &tdep->duplicate_frm_regnum;\n+      else if (strcmp (reg_name, \"fcsr\") == 0)\n+\tregnum_ptr = &tdep->duplicate_fcsr_regnum;\n+\n+      if (regnum_ptr != nullptr)\n+\t{\n+\t  /* This means the register appears more than twice in the target\n+\t     description.  Just let GDB add this as another register.\n+\t     We'll have duplicates in the register name list, but there's\n+\t     not much more we can do.  */\n+\t  if (*regnum_ptr != -1)\n+\t    return -1;\n+\n+\t  /* Record the number assigned to this register, then return the\n+\t     number (so it actually gets assigned to this register).  */\n+\t  *regnum_ptr = possible_regnum;\n+\t  return possible_regnum;\n+\t}\n+    }\n+\n+  /* Any unknown registers in the CSR feature are recorded within a single\n+     block so we can easily identify these registers when making choices\n+     about register groups in riscv_register_reggroup_p.  */\n+  if (strcmp (tdesc_feature_name (feature), riscv_csr_feature.name) == 0)\n+    {\n+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      if (tdep->unknown_csrs_first_regnum == -1)\n+\ttdep->unknown_csrs_first_regnum = possible_regnum;\n+      gdb_assert (tdep->unknown_csrs_first_regnum\n+\t\t  + tdep->unknown_csrs_count == possible_regnum);\n+      tdep->unknown_csrs_count++;\n+      return possible_regnum;\n+    }\n+\n+  /* Some other unknown register.  Don't assign this a number now, it will\n+     be assigned a number automatically later by the target description\n+     handling code.  */\n+  return -1;\n+}\n+\n /* Implement the gnu_triplet_regexp method.  A single compiler supports both\n    32-bit and 64-bit code, and may be named riscv32 or riscv64 or (not\n    recommended) riscv.  */\n@@ -3403,7 +3511,7 @@ riscv_gdbarch_init (struct gdbarch_info info,\n   set_gdbarch_print_registers_info (gdbarch, riscv_print_registers_info);\n \n   /* Finalise the target description registers.  */\n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, tdesc_data, riscv_tdesc_unknown_reg);\n \n   /* Override the register type callback setup by the target description\n      mechanism.  This allows us to provide special type for floating point"
    },
    {
      "sha": "0ff555b06321ddbc078b37711ccfa0a819391cb3",
      "filename": "gdb/riscv-tdep.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e52d038246520ee8f8d8344da18303154a421a6/gdb/riscv-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e52d038246520ee8f8d8344da18303154a421a6/gdb/riscv-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.h?ref=2e52d038246520ee8f8d8344da18303154a421a6",
      "patch": "@@ -79,6 +79,21 @@ struct gdbarch_tdep\n \n   /* ISA-specific data types.  */\n   struct type *riscv_fpreg_d_type = nullptr;\n+\n+  /* Use for tracking unknown CSRs in the target description.\n+     UNKNOWN_CSRS_FIRST_REGNUM is the number assigned to the first unknown\n+     CSR.  All other unknown CSRs will be assigned sequential numbers after\n+     this, with UNKNOWN_CSRS_COUNT being the total number of unknown CSRs.  */\n+  int unknown_csrs_first_regnum = -1;\n+  int unknown_csrs_count = 0;\n+\n+  /* Some targets (QEMU) are reporting three registers twice in the target\n+     description they send.  These three register numbers, when not set to\n+     -1, are for the duplicate copies of these registers.  */\n+  int duplicate_fflags_regnum = -1;\n+  int duplicate_frm_regnum = -1;\n+  int duplicate_fcsr_regnum = -1;\n+\n };\n \n "
    },
    {
      "sha": "00903273f1a77d9748dbdd36f8c79ae87e0ea7e4",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e52d038246520ee8f8d8344da18303154a421a6/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e52d038246520ee8f8d8344da18303154a421a6/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=2e52d038246520ee8f8d8344da18303154a421a6",
      "patch": "@@ -1,3 +1,7 @@\n+2020-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.arch/riscv-tdesc-regs.exp: Extend test case.\n+\n 2020-06-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.arch/riscv-tdesc-loading-01.xml: New file."
    },
    {
      "sha": "9feddbad07491d7f24933ab9cc251ee8e7c0b1ac",
      "filename": "gdb/testsuite/gdb.arch/riscv-tdesc-regs.exp",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e52d038246520ee8f8d8344da18303154a421a6/gdb/testsuite/gdb.arch/riscv-tdesc-regs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e52d038246520ee8f8d8344da18303154a421a6/gdb/testsuite/gdb.arch/riscv-tdesc-regs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/riscv-tdesc-regs.exp?ref=2e52d038246520ee8f8d8344da18303154a421a6",
      "patch": "@@ -100,13 +100,14 @@ foreach rgroup {all save restore} {\n \t}\n     }\n \n-    foreach reg {dscratch} {\n+    foreach reg {fflags frm fcsr unknown_csr dscratch} {\n \tif { [info exists reg_counts($reg) ] } {\n \t    set count $reg_counts($reg)\n \t} else {\n \t    set count 0\n \t}\n-\tif {$reg == \"dscratch\" && $rgroup != \"all\"} {\n+\tif {($reg == \"unknown_csr\" || $reg == \"dscratch\") \\\n+\t\t&& $rgroup != \"all\"} {\n \t    gdb_assert {$count == 0} \\\n \t\t\"register $reg not seen in reggroup $rgroup\"\n \t} else {"
    }
  ]
}