{
  "sha": "b84564fc8cecceb0d289e671169391f896382e5e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yjg0NTY0ZmM4Y2VjY2ViMGQyODllNjcxMTY5MzkxZjg5NjM4MmU1ZQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:12Z"
    },
    "message": "Split out ada_unop_atr\n\nThis splits some Ada attribute operations into a new function for\nfuture use.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_unop_atr): New function.\n\t(ada_evaluate_subexp): Use it.",
    "tree": {
      "sha": "4fec013348913fd6ff4c442eaeeffd3fa5af6ca6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4fec013348913fd6ff4c442eaeeffd3fa5af6ca6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b84564fc8cecceb0d289e671169391f896382e5e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b84564fc8cecceb0d289e671169391f896382e5e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b84564fc8cecceb0d289e671169391f896382e5e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b84564fc8cecceb0d289e671169391f896382e5e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b467efaa91d270f8d057bbae9ab915d068a90ec4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b467efaa91d270f8d057bbae9ab915d068a90ec4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b467efaa91d270f8d057bbae9ab915d068a90ec4"
    }
  ],
  "stats": {
    "total": 249,
    "additions": 133,
    "deletions": 116
  },
  "files": [
    {
      "sha": "91d8c44d7061b982058a48ecc0e6141a97a6783c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b84564fc8cecceb0d289e671169391f896382e5e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b84564fc8cecceb0d289e671169391f896382e5e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b84564fc8cecceb0d289e671169391f896382e5e",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_unop_atr): New function.\n+\t(ada_evaluate_subexp): Use it.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_binop_in_bounds): New function."
    },
    {
      "sha": "59dff43a4d74179e7e9939debe94624f858d2278",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 128,
      "deletions": 116,
      "changes": 244,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b84564fc8cecceb0d289e671169391f896382e5e/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b84564fc8cecceb0d289e671169391f896382e5e/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=b84564fc8cecceb0d289e671169391f896382e5e",
      "patch": "@@ -10218,6 +10218,133 @@ ada_binop_in_bounds (struct expression *exp, enum noside noside,\n \t\t\t\t || value_equal (arg2, arg1)));\n }\n \n+/* A helper function for some attribute operations.  */\n+\n+static value *\n+ada_unop_atr (struct expression *exp, enum noside noside, enum exp_opcode op,\n+\t      struct value *arg1, struct type *type_arg, int tem)\n+{\n+  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+    {\n+      if (type_arg == NULL)\n+\ttype_arg = value_type (arg1);\n+\n+      if (ada_is_constrained_packed_array_type (type_arg))\n+\ttype_arg = decode_constrained_packed_array_type (type_arg);\n+\n+      if (!discrete_type_p (type_arg))\n+\t{\n+\t  switch (op)\n+\t    {\n+\t    default:          /* Should never happen.  */\n+\t      error (_(\"unexpected attribute encountered\"));\n+\t    case OP_ATR_FIRST:\n+\t    case OP_ATR_LAST:\n+\t      type_arg = ada_index_type (type_arg, tem,\n+\t\t\t\t\t ada_attribute_name (op));\n+\t      break;\n+\t    case OP_ATR_LENGTH:\n+\t      type_arg = builtin_type (exp->gdbarch)->builtin_int;\n+\t      break;\n+\t    }\n+\t}\n+\n+      return value_zero (type_arg, not_lval);\n+    }\n+  else if (type_arg == NULL)\n+    {\n+      arg1 = ada_coerce_ref (arg1);\n+\n+      if (ada_is_constrained_packed_array_type (value_type (arg1)))\n+\targ1 = ada_coerce_to_simple_array (arg1);\n+\n+      struct type *type;\n+      if (op == OP_ATR_LENGTH)\n+\ttype = builtin_type (exp->gdbarch)->builtin_int;\n+      else\n+\t{\n+\t  type = ada_index_type (value_type (arg1), tem,\n+\t\t\t\t ada_attribute_name (op));\n+\t  if (type == NULL)\n+\t    type = builtin_type (exp->gdbarch)->builtin_int;\n+\t}\n+\n+      switch (op)\n+\t{\n+\tdefault:          /* Should never happen.  */\n+\t  error (_(\"unexpected attribute encountered\"));\n+\tcase OP_ATR_FIRST:\n+\t  return value_from_longest\n+\t    (type, ada_array_bound (arg1, tem, 0));\n+\tcase OP_ATR_LAST:\n+\t  return value_from_longest\n+\t    (type, ada_array_bound (arg1, tem, 1));\n+\tcase OP_ATR_LENGTH:\n+\t  return value_from_longest\n+\t    (type, ada_array_length (arg1, tem));\n+\t}\n+    }\n+  else if (discrete_type_p (type_arg))\n+    {\n+      struct type *range_type;\n+      const char *name = ada_type_name (type_arg);\n+\n+      range_type = NULL;\n+      if (name != NULL && type_arg->code () != TYPE_CODE_ENUM)\n+\trange_type = to_fixed_range_type (type_arg, NULL);\n+      if (range_type == NULL)\n+\trange_type = type_arg;\n+      switch (op)\n+\t{\n+\tdefault:\n+\t  error (_(\"unexpected attribute encountered\"));\n+\tcase OP_ATR_FIRST:\n+\t  return value_from_longest \n+\t    (range_type, ada_discrete_type_low_bound (range_type));\n+\tcase OP_ATR_LAST:\n+\t  return value_from_longest\n+\t    (range_type, ada_discrete_type_high_bound (range_type));\n+\tcase OP_ATR_LENGTH:\n+\t  error (_(\"the 'length attribute applies only to array types\"));\n+\t}\n+    }\n+  else if (type_arg->code () == TYPE_CODE_FLT)\n+    error (_(\"unimplemented type attribute\"));\n+  else\n+    {\n+      LONGEST low, high;\n+\n+      if (ada_is_constrained_packed_array_type (type_arg))\n+\ttype_arg = decode_constrained_packed_array_type (type_arg);\n+\n+      struct type *type;\n+      if (op == OP_ATR_LENGTH)\n+\ttype = builtin_type (exp->gdbarch)->builtin_int;\n+      else\n+\t{\n+\t  type = ada_index_type (type_arg, tem, ada_attribute_name (op));\n+\t  if (type == NULL)\n+\t    type = builtin_type (exp->gdbarch)->builtin_int;\n+\t}\n+\n+      switch (op)\n+\t{\n+\tdefault:\n+\t  error (_(\"unexpected attribute encountered\"));\n+\tcase OP_ATR_FIRST:\n+\t  low = ada_array_bound_from_type (type_arg, tem, 0);\n+\t  return value_from_longest (type, low);\n+\tcase OP_ATR_LAST:\n+\t  high = ada_array_bound_from_type (type_arg, tem, 1);\n+\t  return value_from_longest (type, high);\n+\tcase OP_ATR_LENGTH:\n+\t  low = ada_array_bound_from_type (type_arg, tem, 0);\n+\t  high = ada_array_bound_from_type (type_arg, tem, 1);\n+\t  return value_from_longest (type, high - low + 1);\n+\t}\n+    }\n+}\n+\n /* Implement the evaluate_exp routine in the exp_descriptor structure\n    for the Ada language.  */\n \n@@ -10717,123 +10844,8 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \n \tif (noside == EVAL_SKIP)\n \t  goto nosideret;\n-\telse if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t  {\n-\t    if (type_arg == NULL)\n-\t      type_arg = value_type (arg1);\n-\n-\t    if (ada_is_constrained_packed_array_type (type_arg))\n-\t      type_arg = decode_constrained_packed_array_type (type_arg);\n-\n-\t    if (!discrete_type_p (type_arg))\n-\t      {\n-\t\tswitch (op)\n-\t\t  {\n-\t\t  default:          /* Should never happen.  */\n-\t\t    error (_(\"unexpected attribute encountered\"));\n-\t\t  case OP_ATR_FIRST:\n-\t\t  case OP_ATR_LAST:\n-\t\t    type_arg = ada_index_type (type_arg, tem,\n-\t\t\t\t\t       ada_attribute_name (op));\n-\t\t    break;\n-\t\t  case OP_ATR_LENGTH:\n-\t\t    type_arg = builtin_type (exp->gdbarch)->builtin_int;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\n-\t    return value_zero (type_arg, not_lval);\n-\t  }\n-\telse if (type_arg == NULL)\n-\t  {\n-\t    arg1 = ada_coerce_ref (arg1);\n-\n-\t    if (ada_is_constrained_packed_array_type (value_type (arg1)))\n-\t      arg1 = ada_coerce_to_simple_array (arg1);\n-\n-\t    if (op == OP_ATR_LENGTH)\n-\t      type = builtin_type (exp->gdbarch)->builtin_int;\n-\t    else\n-\t      {\n-\t\ttype = ada_index_type (value_type (arg1), tem,\n-\t\t\t\t       ada_attribute_name (op));\n-\t\tif (type == NULL)\n-\t\t  type = builtin_type (exp->gdbarch)->builtin_int;\n-\t      }\n-\n-\t    switch (op)\n-\t      {\n-\t      default:          /* Should never happen.  */\n-\t\terror (_(\"unexpected attribute encountered\"));\n-\t      case OP_ATR_FIRST:\n-\t\treturn value_from_longest\n-\t\t\t(type, ada_array_bound (arg1, tem, 0));\n-\t      case OP_ATR_LAST:\n-\t\treturn value_from_longest\n-\t\t\t(type, ada_array_bound (arg1, tem, 1));\n-\t      case OP_ATR_LENGTH:\n-\t\treturn value_from_longest\n-\t\t\t(type, ada_array_length (arg1, tem));\n-\t      }\n-\t  }\n-\telse if (discrete_type_p (type_arg))\n-\t  {\n-\t    struct type *range_type;\n-\t    const char *name = ada_type_name (type_arg);\n-\n-\t    range_type = NULL;\n-\t    if (name != NULL && type_arg->code () != TYPE_CODE_ENUM)\n-\t      range_type = to_fixed_range_type (type_arg, NULL);\n-\t    if (range_type == NULL)\n-\t      range_type = type_arg;\n-\t    switch (op)\n-\t      {\n-\t      default:\n-\t\terror (_(\"unexpected attribute encountered\"));\n-\t      case OP_ATR_FIRST:\n-\t\treturn value_from_longest \n-\t\t  (range_type, ada_discrete_type_low_bound (range_type));\n-\t      case OP_ATR_LAST:\n-\t\treturn value_from_longest\n-\t\t  (range_type, ada_discrete_type_high_bound (range_type));\n-\t      case OP_ATR_LENGTH:\n-\t\terror (_(\"the 'length attribute applies only to array types\"));\n-\t      }\n-\t  }\n-\telse if (type_arg->code () == TYPE_CODE_FLT)\n-\t  error (_(\"unimplemented type attribute\"));\n-\telse\n-\t  {\n-\t    LONGEST low, high;\n-\n-\t    if (ada_is_constrained_packed_array_type (type_arg))\n-\t      type_arg = decode_constrained_packed_array_type (type_arg);\n-\n-\t    if (op == OP_ATR_LENGTH)\n-\t      type = builtin_type (exp->gdbarch)->builtin_int;\n-\t    else\n-\t      {\n-\t\ttype = ada_index_type (type_arg, tem, ada_attribute_name (op));\n-\t\tif (type == NULL)\n-\t\t  type = builtin_type (exp->gdbarch)->builtin_int;\n-\t      }\n \n-\t    switch (op)\n-\t      {\n-\t      default:\n-\t\terror (_(\"unexpected attribute encountered\"));\n-\t      case OP_ATR_FIRST:\n-\t\tlow = ada_array_bound_from_type (type_arg, tem, 0);\n-\t\treturn value_from_longest (type, low);\n-\t      case OP_ATR_LAST:\n-\t\thigh = ada_array_bound_from_type (type_arg, tem, 1);\n-\t\treturn value_from_longest (type, high);\n-\t      case OP_ATR_LENGTH:\n-\t\tlow = ada_array_bound_from_type (type_arg, tem, 0);\n-\t\thigh = ada_array_bound_from_type (type_arg, tem, 1);\n-\t\treturn value_from_longest (type, high - low + 1);\n-\t      }\n-\t  }\n+\treturn ada_unop_atr (exp, noside, op, arg1, type_arg, tem);\n       }\n \n     case OP_ATR_TAG:"
    }
  ]
}