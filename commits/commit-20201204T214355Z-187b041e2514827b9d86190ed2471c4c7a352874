{
  "sha": "187b041e2514827b9d86190ed2471c4c7a352874",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTg3YjA0MWUyNTE0ODI3YjlkODYxOTBlZDI0NzFjNGM3YTM1Mjg3NA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:55Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:55Z"
    },
    "message": "gdb: move displaced stepping logic to gdbarch, allow starting concurrent displaced steps\n\nToday, GDB only allows a single displaced stepping operation to happen\nper inferior at a time.  There is a single displaced stepping buffer per\ninferior, whose address is fixed (obtained with\ngdbarch_displaced_step_location), managed by infrun.c.\n\nIn the case of the AMD ROCm target [1] (in the context of which this\nwork has been done), it is typical to have thousands of threads (or\nwaves, in SMT terminology) executing the same code, hitting the same\nbreakpoint (possibly conditional) and needing to to displaced step it at\nthe same time.  The limitation of only one displaced step executing at a\nany given time becomes a real bottleneck.\n\nTo fix this bottleneck, we want to make it possible for threads of a\nsame inferior to execute multiple displaced steps in parallel.  This\npatch builds the foundation for that.\n\nIn essence, this patch moves the task of preparing a displaced step and\ncleaning up after to gdbarch functions.  This allows using different\nschemes for allocating and managing displaced stepping buffers for\ndifferent platforms.  The gdbarch decides how to assign a buffer to a\nthread that needs to execute a displaced step.\n\nOn the ROCm target, we are able to allocate one displaced stepping\nbuffer per thread, so a thread will never have to wait to execute a\ndisplaced step.\n\nOn Linux, the entry point of the executable if used as the displaced\nstepping buffer, since we assume that this code won't get used after\nstartup.  From what I saw (I checked with a binary generated against\nglibc and musl), on AMD64 we have enough space there to fit two\ndisplaced stepping buffers.  A subsequent patch makes AMD64/Linux use\ntwo buffers.\n\nIn addition to having multiple displaced stepping buffers, there is also\nthe idea of sharing displaced stepping buffers between threads.  Two\nthreads doing displaced steps for the same PC could use the same buffer\nat the same time.  Two threads stepping over the same instruction (same\nopcode) at two different PCs may also be able to share a displaced\nstepping buffer.  This is an idea for future patches, but the\narchitecture built by this patch is made to allow this.\n\nNow, the implementation details.  The main part of this patch is moving\nthe responsibility of preparing and finishing a displaced step to the\ngdbarch.  Before this patch, preparing a displaced step is driven by the\ndisplaced_step_prepare_throw function.  It does some calls to the\ngdbarch to do some low-level operations, but the high-level logic is\nthere.  The steps are roughly:\n\n- Ask the gdbarch for the displaced step buffer location\n- Save the existing bytes in the displaced step buffer\n- Ask the gdbarch to copy the instruction into the displaced step buffer\n- Set the pc of the thread to the beginning of the displaced step buffer\n\nSimilarly, the \"fixup\" phase, executed after the instruction was\nsuccessfully single-stepped, is driven by the infrun code (function\ndisplaced_step_finish).  The steps are roughly:\n\n- Restore the original bytes in the displaced stepping buffer\n- Ask the gdbarch to fixup the instruction result (adjust the target's\n  registers or memory to do as if the instruction had been executed in\n  its original location)\n\nThe displaced_step_inferior_state::step_thread field indicates which\nthread (if any) is currently using the displaced stepping buffer, so it\nis used by displaced_step_prepare_throw to check if the displaced\nstepping buffer is free to use or not.\n\nThis patch defers the whole task of preparing and cleaning up after a\ndisplaced step to the gdbarch.  Two new main gdbarch methods are added,\nwith the following semantics:\n\n  - gdbarch_displaced_step_prepare: Prepare for the given thread to\n    execute a displaced step of the instruction located at its current PC.\n    Upon return, everything should be ready for GDB to resume the thread\n    (with either a single step or continue, as indicated by\n    gdbarch_displaced_step_hw_singlestep) to make it displaced step the\n    instruction.\n\n  - gdbarch_displaced_step_finish: Called when the thread stopped after\n    having started a displaced step.  Verify if the instruction was\n    executed, if so apply any fixup required to compensate for the fact\n    that the instruction was executed at a different place than its\n    original pc.  Release any resources that were allocated for this\n    displaced step.  Upon return, everything should be ready for GDB to\n    resume the thread in its \"normal\" code path.\n\nThe displaced_step_prepare_throw function now pretty much just offloads\nto gdbarch_displaced_step_prepare and the displaced_step_finish function\noffloads to gdbarch_displaced_step_finish.\n\nThe gdbarch_displaced_step_location method is now unnecessary, so is\nremoved.  Indeed, the core of GDB doesn't know how many displaced step\nbuffers there are nor where they are.\n\nTo keep the existing behavior for existing architectures, the logic that\nwas previously implemented in infrun.c for preparing and finishing a\ndisplaced step is moved to displaced-stepping.c, to the\ndisplaced_step_buffer class.  Architectures are modified to implement\nthe new gdbarch methods using this class.  The behavior is not expected\nto change.\n\nThe other important change (which arises from the above) is that the\ncore of GDB no longer prevents concurrent displaced steps.  Before this\npatch, start_step_over walks the global step over chain and tries to\ninitiate a step over (whether it is in-line or displaced).  It follows\nthese rules:\n\n  - if an in-line step is in progress (in any inferior), don't start any\n    other step over\n  - if a displaced step is in progress for an inferior, don't start\n    another displaced step for that inferior\n\nAfter starting a displaced step for a given inferior, it won't start\nanother displaced step for that inferior.\n\nIn the new code, start_step_over simply tries to initiate step overs for\nall the threads in the list.  But because threads may be added back to\nthe global list as it iterates the global list, trying to initiate step\novers, start_step_over now starts by stealing the global queue into a\nlocal queue and iterates on the local queue.  In the typical case, each\nthread will either:\n\n  - have initiated a displaced step and be resumed\n  - have been added back by the global step over queue by\n    displaced_step_prepare_throw, because the gdbarch will have returned\n    that there aren't enough resources (i.e. buffers) to initiate a\n    displaced step for that thread\n\nLastly, if start_step_over initiates an in-line step, it stops\niterating, and moves back whatever remaining threads it had in its local\nstep over queue to the global step over queue.\n\nTwo other gdbarch methods are added, to handle some slightly annoying\ncorner cases.  They feel awkwardly specific to these cases, but I don't\nsee any way around them:\n\n  - gdbarch_displaced_step_copy_insn_closure_by_addr: in\n    arm_pc_is_thumb, arm-tdep.c wants to get the closure for a given\n    buffer address.\n\n  - gdbarch_displaced_step_restore_all_in_ptid: when a process forks\n    (at least on Linux), the address space is copied.  If some displaced\n    step buffers were in use at the time of the fork, we need to restore\n    the original bytes in the child's address space.\n\nThese two adjustments are also made in infrun.c:\n\n  - prepare_for_detach: there may be multiple threads doing displaced\n    steps when we detach, so wait until all of them are done\n\n  - handle_inferior_event: when we handle a fork event for a given\n    thread, it's possible that other threads are doing a displaced step at\n    the same time.  Make sure to restore the displaced step buffer\n    contents in the child for them.\n\n[1] https://github.com/ROCm-Developer-Tools/ROCgdb\n\ngdb/ChangeLog:\n\n\t* displaced-stepping.h (struct\n\tdisplaced_step_copy_insn_closure): Adjust comments.\n\t(struct displaced_step_inferior_state) <step_thread,\n\tstep_gdbarch, step_closure, step_original, step_copy,\n\tstep_saved_copy>: Remove fields.\n\t(struct displaced_step_thread_state): New.\n\t(struct displaced_step_buffer): New.\n\t* displaced-stepping.c (displaced_step_buffer::prepare): New.\n\t(write_memory_ptid): Move from infrun.c.\n\t(displaced_step_instruction_executed_successfully): New,\n\tfactored out of displaced_step_finish.\n\t(displaced_step_buffer::finish): New.\n\t(displaced_step_buffer::copy_insn_closure_by_addr): New.\n\t(displaced_step_buffer::restore_in_ptid): New.\n\t* gdbarch.sh (displaced_step_location): Remove.\n\t(displaced_step_prepare, displaced_step_finish,\n\tdisplaced_step_copy_insn_closure_by_addr,\n\tdisplaced_step_restore_all_in_ptid): New.\n\t* gdbarch.c: Re-generate.\n\t* gdbarch.h: Re-generate.\n\t* gdbthread.h (class thread_info) <displaced_step_state>: New\n\tfield.\n\t(thread_step_over_chain_remove): New declaration.\n\t(thread_step_over_chain_next): New declaration.\n\t(thread_step_over_chain_length): New declaration.\n\t* thread.c (thread_step_over_chain_remove): Make non-static.\n\t(thread_step_over_chain_next): New.\n\t(global_thread_step_over_chain_next): Use\n\tthread_step_over_chain_next.\n\t(thread_step_over_chain_length): New.\n\t(global_thread_step_over_chain_enqueue): Add debug print.\n\t(global_thread_step_over_chain_remove): Add debug print.\n\t* infrun.h (get_displaced_step_copy_insn_closure_by_addr):\n\tRemove.\n\t* infrun.c (get_displaced_stepping_state): New.\n\t(displaced_step_in_progress_any_inferior): Remove.\n\t(displaced_step_in_progress_thread): Adjust.\n\t(displaced_step_in_progress): Adjust.\n\t(displaced_step_in_progress_any_thread): New.\n\t(get_displaced_step_copy_insn_closure_by_addr): Remove.\n\t(gdbarch_supports_displaced_stepping): Use\n\tgdbarch_displaced_step_prepare_p.\n\t(displaced_step_reset): Change parameter from inferior to\n\tthread.\n\t(displaced_step_prepare_throw): Implement using\n\tgdbarch_displaced_step_prepare.\n\t(write_memory_ptid): Move to displaced-step.c.\n\t(displaced_step_restore): Remove.\n\t(displaced_step_finish): Implement using\n\tgdbarch_displaced_step_finish.\n\t(start_step_over): Allow starting more than one displaced step.\n\t(prepare_for_detach): Handle possibly multiple threads doing\n\tdisplaced steps.\n\t(handle_inferior_event): Handle possibility that fork event\n\thappens while another thread displaced steps.\n\t* linux-tdep.h (linux_displaced_step_prepare): New.\n\t(linux_displaced_step_finish): New.\n\t(linux_displaced_step_copy_insn_closure_by_addr): New.\n\t(linux_displaced_step_restore_all_in_ptid): New.\n\t(linux_init_abi): Add supports_displaced_step parameter.\n\t* linux-tdep.c (struct linux_info) <disp_step_buf>: New field.\n\t(linux_displaced_step_prepare): New.\n\t(linux_displaced_step_finish): New.\n\t(linux_displaced_step_copy_insn_closure_by_addr): New.\n\t(linux_displaced_step_restore_all_in_ptid): New.\n\t(linux_init_abi): Add supports_displaced_step parameter,\n\tregister displaced step methods if true.\n\t(_initialize_linux_tdep): Register inferior_execd observer.\n\t* amd64-linux-tdep.c (amd64_linux_init_abi_common): Add\n\tsupports_displaced_step parameter, adjust call to\n\tlinux_init_abi.  Remove call to\n\tset_gdbarch_displaced_step_location.\n\t(amd64_linux_init_abi): Adjust call to\n\tamd64_linux_init_abi_common.\n\t(amd64_x32_linux_init_abi): Likewise.\n\t* aarch64-linux-tdep.c (aarch64_linux_init_abi): Adjust call to\n\tlinux_init_abi.  Remove call to\n\tset_gdbarch_displaced_step_location.\n\t* arm-linux-tdep.c (arm_linux_init_abi): Likewise.\n\t* i386-linux-tdep.c (i386_linux_init_abi): Likewise.\n\t* alpha-linux-tdep.c (alpha_linux_init_abi): Adjust call to\n\tlinux_init_abi.\n\t* arc-linux-tdep.c (arc_linux_init_osabi): Likewise.\n\t* bfin-linux-tdep.c (bfin_linux_init_abi): Likewise.\n\t* cris-linux-tdep.c (cris_linux_init_abi): Likewise.\n\t* csky-linux-tdep.c (csky_linux_init_abi): Likewise.\n\t* frv-linux-tdep.c (frv_linux_init_abi): Likewise.\n\t* hppa-linux-tdep.c (hppa_linux_init_abi): Likewise.\n\t* ia64-linux-tdep.c (ia64_linux_init_abi): Likewise.\n\t* m32r-linux-tdep.c (m32r_linux_init_abi): Likewise.\n\t* m68k-linux-tdep.c (m68k_linux_init_abi): Likewise.\n\t* microblaze-linux-tdep.c (microblaze_linux_init_abi): Likewise.\n\t* mips-linux-tdep.c (mips_linux_init_abi): Likewise.\n\t* mn10300-linux-tdep.c (am33_linux_init_osabi): Likewise.\n\t* nios2-linux-tdep.c (nios2_linux_init_abi): Likewise.\n\t* or1k-linux-tdep.c (or1k_linux_init_abi): Likewise.\n\t* riscv-linux-tdep.c (riscv_linux_init_abi): Likewise.\n\t* s390-linux-tdep.c (s390_linux_init_abi_any): Likewise.\n\t* sh-linux-tdep.c (sh_linux_init_abi): Likewise.\n\t* sparc-linux-tdep.c (sparc32_linux_init_abi): Likewise.\n\t* sparc64-linux-tdep.c (sparc64_linux_init_abi): Likewise.\n\t* tic6x-linux-tdep.c (tic6x_uclinux_init_abi): Likewise.\n\t* tilegx-linux-tdep.c (tilegx_linux_init_abi): Likewise.\n\t* xtensa-linux-tdep.c (xtensa_linux_init_abi): Likewise.\n\t* ppc-linux-tdep.c (ppc_linux_init_abi): Adjust call to\n\tlinux_init_abi.  Remove call to\n\tset_gdbarch_displaced_step_location.\n\t* arm-tdep.c (arm_pc_is_thumb): Call\n\tgdbarch_displaced_step_copy_insn_closure_by_addr instead of\n\tget_displaced_step_copy_insn_closure_by_addr.\n\t* rs6000-aix-tdep.c (rs6000_aix_init_osabi): Adjust calls to\n\tclear gdbarch methods.\n\t* rs6000-tdep.c (struct ppc_inferior_data): New structure.\n\t(get_ppc_per_inferior): New function.\n\t(ppc_displaced_step_prepare): New function.\n\t(ppc_displaced_step_finish): New function.\n\t(ppc_displaced_step_restore_all_in_ptid): New function.\n\t(rs6000_gdbarch_init): Register new gdbarch methods.\n\t* s390-tdep.c (s390_gdbarch_init): Don't call\n\tset_gdbarch_displaced_step_location, set new gdbarch methods.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.arch/amd64-disp-step-avx.exp: Adjust pattern.\n\t* gdb.threads/forking-threads-plus-breakpoint.exp: Likewise.\n\t* gdb.threads/non-stop-fair-events.exp: Likewise.\n\nChange-Id: I387cd235a442d0620ec43608fd3dc0097fcbf8c8",
    "tree": {
      "sha": "5dae57529dce93a0f4ae0cc94838fd3015028ed4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5dae57529dce93a0f4ae0cc94838fd3015028ed4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/187b041e2514827b9d86190ed2471c4c7a352874",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/187b041e2514827b9d86190ed2471c4c7a352874",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/187b041e2514827b9d86190ed2471c4c7a352874",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/187b041e2514827b9d86190ed2471c4c7a352874/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c7acb87bc602c78e6cbee7a7d73f7bdfeeddeefb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c7acb87bc602c78e6cbee7a7d73f7bdfeeddeefb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c7acb87bc602c78e6cbee7a7d73f7bdfeeddeefb"
    }
  ],
  "stats": {
    "total": 1317,
    "additions": 1010,
    "deletions": 307
  },
  "files": [
    {
      "sha": "f39730fa5850b53515f0ef88b47dde12cdd2ee3c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 123,
      "deletions": 0,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1,3 +1,126 @@\n+2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* displaced-stepping.h (struct\n+\tdisplaced_step_copy_insn_closure): Adjust comments.\n+\t(struct displaced_step_inferior_state) <step_thread,\n+\tstep_gdbarch, step_closure, step_original, step_copy,\n+\tstep_saved_copy>: Remove fields.\n+\t(struct displaced_step_thread_state): New.\n+\t(struct displaced_step_buffer): New.\n+\t* displaced-stepping.c (displaced_step_buffer::prepare): New.\n+\t(write_memory_ptid): Move from infrun.c.\n+\t(displaced_step_instruction_executed_successfully): New,\n+\tfactored out of displaced_step_finish.\n+\t(displaced_step_buffer::finish): New.\n+\t(displaced_step_buffer::copy_insn_closure_by_addr): New.\n+\t(displaced_step_buffer::restore_in_ptid): New.\n+\t* gdbarch.sh (displaced_step_location): Remove.\n+\t(displaced_step_prepare, displaced_step_finish,\n+\tdisplaced_step_copy_insn_closure_by_addr,\n+\tdisplaced_step_restore_all_in_ptid): New.\n+\t* gdbarch.c: Re-generate.\n+\t* gdbarch.h: Re-generate.\n+\t* gdbthread.h (class thread_info) <displaced_step_state>: New\n+\tfield.\n+\t(thread_step_over_chain_remove): New declaration.\n+\t(thread_step_over_chain_next): New declaration.\n+\t(thread_step_over_chain_length): New declaration.\n+\t* thread.c (thread_step_over_chain_remove): Make non-static.\n+\t(thread_step_over_chain_next): New.\n+\t(global_thread_step_over_chain_next): Use\n+\tthread_step_over_chain_next.\n+\t(thread_step_over_chain_length): New.\n+\t(global_thread_step_over_chain_enqueue): Add debug print.\n+\t(global_thread_step_over_chain_remove): Add debug print.\n+\t* infrun.h (get_displaced_step_copy_insn_closure_by_addr):\n+\tRemove.\n+\t* infrun.c (get_displaced_stepping_state): New.\n+\t(displaced_step_in_progress_any_inferior): Remove.\n+\t(displaced_step_in_progress_thread): Adjust.\n+\t(displaced_step_in_progress): Adjust.\n+\t(displaced_step_in_progress_any_thread): New.\n+\t(get_displaced_step_copy_insn_closure_by_addr): Remove.\n+\t(gdbarch_supports_displaced_stepping): Use\n+\tgdbarch_displaced_step_prepare_p.\n+\t(displaced_step_reset): Change parameter from inferior to\n+\tthread.\n+\t(displaced_step_prepare_throw): Implement using\n+\tgdbarch_displaced_step_prepare.\n+\t(write_memory_ptid): Move to displaced-step.c.\n+\t(displaced_step_restore): Remove.\n+\t(displaced_step_finish): Implement using\n+\tgdbarch_displaced_step_finish.\n+\t(start_step_over): Allow starting more than one displaced step.\n+\t(prepare_for_detach): Handle possibly multiple threads doing\n+\tdisplaced steps.\n+\t(handle_inferior_event): Handle possibility that fork event\n+\thappens while another thread displaced steps.\n+\t* linux-tdep.h (linux_displaced_step_prepare): New.\n+\t(linux_displaced_step_finish): New.\n+\t(linux_displaced_step_copy_insn_closure_by_addr): New.\n+\t(linux_displaced_step_restore_all_in_ptid): New.\n+\t(linux_init_abi): Add supports_displaced_step parameter.\n+\t* linux-tdep.c (struct linux_info) <disp_step_buf>: New field.\n+\t(linux_displaced_step_prepare): New.\n+\t(linux_displaced_step_finish): New.\n+\t(linux_displaced_step_copy_insn_closure_by_addr): New.\n+\t(linux_displaced_step_restore_all_in_ptid): New.\n+\t(linux_init_abi): Add supports_displaced_step parameter,\n+\tregister displaced step methods if true.\n+\t(_initialize_linux_tdep): Register inferior_execd observer.\n+\t* amd64-linux-tdep.c (amd64_linux_init_abi_common): Add\n+\tsupports_displaced_step parameter, adjust call to\n+\tlinux_init_abi.  Remove call to\n+\tset_gdbarch_displaced_step_location.\n+\t(amd64_linux_init_abi): Adjust call to\n+\tamd64_linux_init_abi_common.\n+\t(amd64_x32_linux_init_abi): Likewise.\n+\t* aarch64-linux-tdep.c (aarch64_linux_init_abi): Adjust call to\n+\tlinux_init_abi.  Remove call to\n+\tset_gdbarch_displaced_step_location.\n+\t* arm-linux-tdep.c (arm_linux_init_abi): Likewise.\n+\t* i386-linux-tdep.c (i386_linux_init_abi): Likewise.\n+\t* alpha-linux-tdep.c (alpha_linux_init_abi): Adjust call to\n+\tlinux_init_abi.\n+\t* arc-linux-tdep.c (arc_linux_init_osabi): Likewise.\n+\t* bfin-linux-tdep.c (bfin_linux_init_abi): Likewise.\n+\t* cris-linux-tdep.c (cris_linux_init_abi): Likewise.\n+\t* csky-linux-tdep.c (csky_linux_init_abi): Likewise.\n+\t* frv-linux-tdep.c (frv_linux_init_abi): Likewise.\n+\t* hppa-linux-tdep.c (hppa_linux_init_abi): Likewise.\n+\t* ia64-linux-tdep.c (ia64_linux_init_abi): Likewise.\n+\t* m32r-linux-tdep.c (m32r_linux_init_abi): Likewise.\n+\t* m68k-linux-tdep.c (m68k_linux_init_abi): Likewise.\n+\t* microblaze-linux-tdep.c (microblaze_linux_init_abi): Likewise.\n+\t* mips-linux-tdep.c (mips_linux_init_abi): Likewise.\n+\t* mn10300-linux-tdep.c (am33_linux_init_osabi): Likewise.\n+\t* nios2-linux-tdep.c (nios2_linux_init_abi): Likewise.\n+\t* or1k-linux-tdep.c (or1k_linux_init_abi): Likewise.\n+\t* riscv-linux-tdep.c (riscv_linux_init_abi): Likewise.\n+\t* s390-linux-tdep.c (s390_linux_init_abi_any): Likewise.\n+\t* sh-linux-tdep.c (sh_linux_init_abi): Likewise.\n+\t* sparc-linux-tdep.c (sparc32_linux_init_abi): Likewise.\n+\t* sparc64-linux-tdep.c (sparc64_linux_init_abi): Likewise.\n+\t* tic6x-linux-tdep.c (tic6x_uclinux_init_abi): Likewise.\n+\t* tilegx-linux-tdep.c (tilegx_linux_init_abi): Likewise.\n+\t* xtensa-linux-tdep.c (xtensa_linux_init_abi): Likewise.\n+\t* ppc-linux-tdep.c (ppc_linux_init_abi): Adjust call to\n+\tlinux_init_abi.  Remove call to\n+\tset_gdbarch_displaced_step_location.\n+\t* arm-tdep.c (arm_pc_is_thumb): Call\n+\tgdbarch_displaced_step_copy_insn_closure_by_addr instead of\n+\tget_displaced_step_copy_insn_closure_by_addr.\n+\t* rs6000-aix-tdep.c (rs6000_aix_init_osabi): Adjust calls to\n+\tclear gdbarch methods.\n+\t* rs6000-tdep.c (struct ppc_inferior_data): New structure.\n+\t(get_ppc_per_inferior): New function.\n+\t(ppc_displaced_step_prepare): New function.\n+\t(ppc_displaced_step_finish): New function.\n+\t(ppc_displaced_step_restore_all_in_ptid): New function.\n+\t(rs6000_gdbarch_init): Register new gdbarch methods.\n+\t* s390-tdep.c (s390_gdbarch_init): Don't call\n+\tset_gdbarch_displaced_step_location, set new gdbarch methods.\n+\n 2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* Makefile.in (COMMON_SFILES): Add displaced-stepping.c."
    },
    {
      "sha": "4fe7babe59cf2ae5c9579447d3dc3ef4079ca647",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1445,7 +1445,7 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   tdep->lowest_pc = 0x8000;\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, true);\n \n   set_solib_svr4_fetch_link_map_offsets (gdbarch,\n \t\t\t\t\t svr4_lp64_fetch_link_map_offsets);\n@@ -1658,7 +1658,6 @@ aarch64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n \t\t\t\t\taarch64_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, aarch64_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch, linux_displaced_step_location);\n   set_gdbarch_displaced_step_hw_singlestep (gdbarch,\n \t\t\t\t\t    aarch64_displaced_step_hw_singlestep);\n "
    },
    {
      "sha": "a6d6b15e9fd62adef19e6a50adad0bafa22bca8b",
      "filename": "gdb/alpha-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/alpha-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/alpha-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/alpha-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -356,7 +356,7 @@ alpha_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep;\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Hook into the DWARF CFI frame unwinder.  */\n   alpha_dwarf2_init_abi (info, gdbarch);"
    },
    {
      "sha": "a81bb9039df5294bd26f429230844ef3d490cfb2",
      "filename": "gdb/amd64-linux-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/amd64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/amd64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1795,11 +1795,12 @@ amd64_dtrace_parse_probe_argument (struct gdbarch *gdbarch,\n }\n \n static void\n-amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch)\n+amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch,\n+\t\t\t    bool supports_displaced_step)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, supports_displaced_step);\n \n   tdep->sigtramp_p = amd64_linux_sigtramp_p;\n   tdep->sigcontext_addr = amd64_linux_sigcontext_addr;\n@@ -1839,8 +1840,6 @@ amd64_linux_init_abi_common(struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n \t\t\t\t\tamd64_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, amd64_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch,\n-\t\t\t\t       linux_displaced_step_location);\n \n   set_gdbarch_process_record (gdbarch, i386_process_record);\n   set_gdbarch_process_record_signal (gdbarch, amd64_linux_record_signal);\n@@ -1881,7 +1880,7 @@ amd64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   if (!valid_p)\n     return;\n \n-  amd64_linux_init_abi_common (info, gdbarch);\n+  amd64_linux_init_abi_common (info, gdbarch, true);\n \n   /* Initialize the amd64_linux_record_tdep.  */\n   /* These values are the size of the type that will be used in a system\n@@ -2096,7 +2095,7 @@ amd64_x32_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   if (!valid_p)\n     return;\n \n-  amd64_linux_init_abi_common (info, gdbarch);\n+  amd64_linux_init_abi_common (info, gdbarch, false);\n \n   /* Initialize the amd64_x32_linux_record_tdep.  */\n   /* These values are the size of the type that will be used in a system"
    },
    {
      "sha": "b919882177e6aa78d730b7b2faf62a6e97080fa4",
      "filename": "gdb/arc-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -439,7 +439,7 @@ arc_linux_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n    */\n   tdep->jb_pc = 15;\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Set up target dependent GDB architecture entries.  */\n   set_gdbarch_cannot_fetch_register (gdbarch, arc_linux_cannot_fetch_register);"
    },
    {
      "sha": "d164cff3dff7069001c46dd8f86914ef56c38e7f",
      "filename": "gdb/arm-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arm-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arm-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1721,7 +1721,7 @@ arm_linux_init_abi (struct gdbarch_info info,\n \t\t\t\t\t\t\t\t    NULL };\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, true);\n \n   tdep->lowest_pc = 0x8000;\n   if (info.byte_order_for_code == BFD_ENDIAN_BIG)\n@@ -1807,7 +1807,6 @@ arm_linux_init_abi (struct gdbarch_info info,\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n \t\t\t\t\tarm_linux_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, arm_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch, linux_displaced_step_location);\n \n   /* Reversible debugging, process record.  */\n   set_gdbarch_process_record (gdbarch, arm_process_record);"
    },
    {
      "sha": "7d96884695c4066d9b5534b5849410c7a6e1a591",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -433,9 +433,12 @@ arm_pc_is_thumb (struct gdbarch *gdbarch, CORE_ADDR memaddr)\n {\n   struct bound_minimal_symbol sym;\n   char type;\n-  arm_displaced_step_copy_insn_closure *dsc\n-    = ((arm_displaced_step_copy_insn_closure * )\n-\tget_displaced_step_copy_insn_closure_by_addr (memaddr));\n+  arm_displaced_step_copy_insn_closure *dsc = nullptr;\n+\n+  if (gdbarch_displaced_step_copy_insn_closure_by_addr_p (gdbarch))\n+    dsc = ((arm_displaced_step_copy_insn_closure * )\n+\t   gdbarch_displaced_step_copy_insn_closure_by_addr\n+\t     (gdbarch, current_inferior (), memaddr));\n \n   /* If checking the mode of displaced instruction in copy area, the mode\n      should be determined by instruction on the original address.  */"
    },
    {
      "sha": "fc2f1d9ac656ea6824493edb569398db6895b151",
      "filename": "gdb/bfin-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/bfin-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/bfin-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -150,7 +150,7 @@ bfin_linux_get_syscall_number (struct gdbarch *gdbarch,\n static void\n bfin_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Set the sigtramp frame sniffer.  */\n   tramp_frame_prepend_unwinder (gdbarch, &bfin_linux_sigframe);"
    },
    {
      "sha": "85cbf4cc0931c79b6f3fe00a887727366928a781",
      "filename": "gdb/cris-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/cris-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/cris-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cris-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -35,7 +35,7 @@ cris_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   if (tdep->cris_version == 32)\n     /* Threaded debugging is only supported on CRISv32 for now.  */"
    },
    {
      "sha": "184fa5ffb239b528b5839a46f2867910d39bc9cb",
      "filename": "gdb/csky-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/csky-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/csky-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/csky-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -233,7 +233,7 @@ csky_linux_rt_sigreturn_tramp_frame = {\n static void\n csky_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Shared library handling.  */\n   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);"
    },
    {
      "sha": "fb5d23f92c1449ce4621adea3921e3f2506b7aa7",
      "filename": "gdb/displaced-stepping.c",
      "status": "modified",
      "additions": 194,
      "deletions": 1,
      "changes": 195,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/displaced-stepping.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/displaced-stepping.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/displaced-stepping.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -19,9 +19,15 @@\n \n #include \"defs.h\"\n #include \"displaced-stepping.h\"\n-#include \"cli/cli-cmds.h\"\n \n+#include \"cli/cli-cmds.h\"\n #include \"command.h\"\n+#include \"gdbarch.h\"\n+#include \"gdbcore.h\"\n+#include \"gdbthread.h\"\n+#include \"inferior.h\"\n+#include \"regcache.h\"\n+#include \"target/target.h\"\n \n /* Default destructor for displaced_step_copy_insn_closure.  */\n \n@@ -37,6 +43,193 @@ show_debug_displaced (struct ui_file *file, int from_tty,\n   fprintf_filtered (file, _(\"Displace stepping debugging is %s.\\n\"), value);\n }\n \n+displaced_step_prepare_status\n+displaced_step_buffer::prepare (thread_info *thread, CORE_ADDR &displaced_pc)\n+{\n+  gdb_assert (!thread->displaced_step_state.in_progress ());\n+\n+  /* Is a thread currently using the buffer?  */\n+  if (m_current_thread != nullptr)\n+    {\n+      /* If so, it better not be this thread.  */\n+      gdb_assert (thread != m_current_thread);\n+      return DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE;\n+    }\n+\n+  regcache *regcache = get_thread_regcache (thread);\n+  const address_space *aspace = regcache->aspace ();\n+  gdbarch *arch = regcache->arch ();\n+  ULONGEST len = gdbarch_max_insn_length (arch);\n+\n+  if (breakpoint_in_range_p (aspace, m_addr, len))\n+    {\n+      /* There's a breakpoint set in the scratch pad location range\n+\t (which is usually around the entry point).  We'd either\n+\t install it before resuming, which would overwrite/corrupt the\n+\t scratch pad, or if it was already inserted, this displaced\n+\t step would overwrite it.  The latter is OK in the sense that\n+\t we already assume that no thread is going to execute the code\n+\t in the scratch pad range (after initial startup) anyway, but\n+\t the former is unacceptable.  Simply punt and fallback to\n+\t stepping over this breakpoint in-line.  */\n+      displaced_debug_printf (\"breakpoint set in scratch pad.  \"\n+\t\t\t      \"Stepping over breakpoint in-line instead.\");\n+\n+      return DISPLACED_STEP_PREPARE_STATUS_CANT;\n+    }\n+\n+  m_original_pc = regcache_read_pc (regcache);\n+  displaced_pc = m_addr;\n+\n+  /* Save the original contents of the displaced stepping buffer.  */\n+  m_saved_copy.resize (len);\n+\n+  int status = target_read_memory (m_addr, m_saved_copy.data (), len);\n+  if (status != 0)\n+    throw_error (MEMORY_ERROR,\n+\t\t _(\"Error accessing memory address %s (%s) for \"\n+\t\t   \"displaced-stepping scratch space.\"),\n+\t\t paddress (arch, m_addr), safe_strerror (status));\n+\n+  displaced_debug_printf (\"saved %s: %s\",\n+\t\t\t  paddress (arch, m_addr),\n+\t\t\t  displaced_step_dump_bytes\n+\t\t\t    (m_saved_copy.data (), len).c_str ());\n+\n+  /* Save this in a local variable first, so it's released if code below\n+     throws.  */\n+  displaced_step_copy_insn_closure_up copy_insn_closure\n+    = gdbarch_displaced_step_copy_insn (arch, m_original_pc, m_addr, regcache);\n+\n+  if (copy_insn_closure == nullptr)\n+    {\n+      /* The architecture doesn't know how or want to displaced step\n+        this instruction or instruction sequence.  Fallback to\n+        stepping over the breakpoint in-line.  */\n+      return DISPLACED_STEP_PREPARE_STATUS_CANT;\n+    }\n+\n+  /* Resume execution at the copy.  */\n+  regcache_write_pc (regcache, m_addr);\n+\n+  /* This marks the buffer as being in use.  */\n+  m_current_thread = thread;\n+\n+  /* Save this, now that we know everything went fine.  */\n+  m_copy_insn_closure = std::move (copy_insn_closure);\n+\n+  /* Tell infrun not to try preparing a displaced step again for this inferior.  */\n+  thread->inf->displaced_step_state.unavailable = true;\n+\n+  return DISPLACED_STEP_PREPARE_STATUS_OK;\n+}\n+\n+static void\n+write_memory_ptid (ptid_t ptid, CORE_ADDR memaddr,\n+\t\t   const gdb_byte *myaddr, int len)\n+{\n+  scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n+\n+  inferior_ptid = ptid;\n+  write_memory (memaddr, myaddr, len);\n+}\n+\n+static bool\n+displaced_step_instruction_executed_successfully (gdbarch *arch,\n+\t\t\t\t\t\t  gdb_signal signal)\n+{\n+  if (signal != GDB_SIGNAL_TRAP)\n+    return false;\n+\n+  if (target_stopped_by_watchpoint ())\n+    {\n+      if (gdbarch_have_nonsteppable_watchpoint (arch)\n+\t  || target_have_steppable_watchpoint ())\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+displaced_step_finish_status\n+displaced_step_buffer::finish (gdbarch *arch, thread_info *thread,\n+\t\t\t       gdb_signal sig)\n+{\n+  gdb_assert (thread->displaced_step_state.in_progress ());\n+  gdb_assert (thread == m_current_thread);\n+\n+  /* Move this to a local variable so it's released in case something goes\n+     wrong.  */\n+  displaced_step_copy_insn_closure_up copy_insn_closure\n+    = std::move (m_copy_insn_closure);\n+  gdb_assert (copy_insn_closure != nullptr);\n+\n+  /* Reset M_CURRENT_THREAD immediately to mark the buffer as available, in case\n+     something goes wrong below.  */\n+  m_current_thread = nullptr;\n+\n+  /* Now that a buffer gets freed, tell infrun it can ask us to prepare a displaced\n+     step again for this inferior.  Do that here in case something goes wrong\n+     below.  */\n+  thread->inf->displaced_step_state.unavailable = false;\n+\n+  ULONGEST len = gdbarch_max_insn_length (arch);\n+\n+  write_memory_ptid (thread->ptid, m_addr,\n+\t\t     m_saved_copy.data (), len);\n+\n+  displaced_debug_printf (\"restored %s %s\",\n+\t\t\t  target_pid_to_str (thread->ptid).c_str (),\n+\t\t\t  paddress (arch, m_addr));\n+\n+  regcache *rc = get_thread_regcache (thread);\n+\n+  bool instruction_executed_successfully\n+    = displaced_step_instruction_executed_successfully (arch, sig);\n+\n+  if (instruction_executed_successfully)\n+    {\n+      gdbarch_displaced_step_fixup (arch, copy_insn_closure.get (), m_original_pc,\n+\t\t\t\t    m_addr, rc);\n+      return DISPLACED_STEP_FINISH_STATUS_OK;\n+    }\n+  else\n+    {\n+      /* Since the instruction didn't complete, all we can do is relocate the\n+\t PC.  */\n+      CORE_ADDR pc = regcache_read_pc (rc);\n+      pc = m_original_pc + (pc - m_addr);\n+      regcache_write_pc (rc, pc);\n+      return DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED;\n+    }\n+}\n+\n+const displaced_step_copy_insn_closure *\n+displaced_step_buffer::copy_insn_closure_by_addr (CORE_ADDR addr)\n+{\n+  if (addr == m_addr)\n+    return m_copy_insn_closure.get ();\n+  else\n+    return nullptr;\n+}\n+\n+void\n+displaced_step_buffer::restore_in_ptid (ptid_t ptid)\n+{\n+  if (m_current_thread != nullptr)\n+    {\n+      regcache *regcache = get_thread_regcache (m_current_thread);\n+      gdbarch *arch = regcache->arch ();\n+      ULONGEST len = gdbarch_max_insn_length (arch);\n+\n+      write_memory_ptid (ptid, m_addr, m_saved_copy.data (), len);\n+\n+      displaced_debug_printf (\"restored in ptid %s %s\",\n+\t\t\t      target_pid_to_str (ptid).c_str (),\n+\t\t\t      paddress (arch, m_addr));\n+    }\n+}\n+\n void _initialize_displaced_stepping ();\n void\n _initialize_displaced_stepping ()"
    },
    {
      "sha": "a2d80aeda4f30c46da4353bc22bc1a3c1974089a",
      "filename": "gdb/displaced-stepping.h",
      "status": "modified",
      "additions": 85,
      "deletions": 22,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/displaced-stepping.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/displaced-stepping.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/displaced-stepping.h?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -22,6 +22,7 @@\n \n #include \"gdbsupport/byte-vector.h\"\n \n+struct gdbarch;\n struct thread_info;\n \n /* True if we are debugging displaced stepping.  */\n@@ -62,7 +63,8 @@ enum displaced_step_finish_status\n   DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED,\n };\n \n-/* Base class for displaced stepping closures (the arch-specific data).  */\n+/* Data returned by a gdbarch displaced_step_copy_insn method, to be passed to\n+   the matching displaced_step_fixup method.  */\n \n struct displaced_step_copy_insn_closure\n {\n@@ -80,6 +82,9 @@ struct buf_displaced_step_copy_insn_closure : displaced_step_copy_insn_closure\n   : buf (buf_size)\n   {}\n \n+  /* The content of this buffer is up to the user of the class, but typically\n+     original instruction bytes, used during fixup to determine what needs to\n+     be fixed up.  */\n   gdb::byte_vector buf;\n };\n \n@@ -95,37 +100,95 @@ struct displaced_step_inferior_state\n   /* Put this object back in its original state.  */\n   void reset ()\n   {\n-    failed_before = 0;\n-    step_thread = nullptr;\n-    step_gdbarch = nullptr;\n-    step_closure.reset ();\n-    step_original = 0;\n-    step_copy = 0;\n-    step_saved_copy.clear ();\n+    failed_before = false;\n+    in_progress_count = 0;\n+    unavailable = false;\n   }\n \n   /* True if preparing a displaced step ever failed.  If so, we won't\n      try displaced stepping for this inferior again.  */\n-  int failed_before;\n+  bool failed_before;\n \n-  /* If this is not nullptr, this is the thread carrying out a\n-     displaced single-step in process PID.  This thread's state will\n-     require fixing up once it has completed its step.  */\n-  thread_info *step_thread;\n+  /* Number of displaced steps in progress for this inferior.  */\n+  unsigned int in_progress_count;\n \n-  /* The architecture the thread had when we stepped it.  */\n-  gdbarch *step_gdbarch;\n+  /* If true, this tells GDB that it's not worth asking the gdbarch displaced\n+     stepping implementation to prepare a displaced step, because it would\n+     return UNAVAILABLE.  This is set and reset by the gdbarch in the\n+     displaced_step_prepare and displaced_step_finish methods.  */\n+  bool unavailable;\n+};\n \n-  /* The closure provided gdbarch_displaced_step_copy_insn, to be used\n-     for post-step cleanup.  */\n-  displaced_step_copy_insn_closure_up step_closure;\n+/* Per-thread displaced stepping state.  */\n \n-  /* The address of the original instruction, and the copy we\n-     made.  */\n-  CORE_ADDR step_original, step_copy;\n+struct displaced_step_thread_state\n+{\n+  /* Return true if this thread is currently executing a displaced step.  */\n+  bool in_progress () const\n+  {\n+    return m_original_gdbarch != nullptr;\n+  }\n+\n+  /* Return the gdbarch of the thread prior to the step.  */\n+  gdbarch *get_original_gdbarch () const\n+  {\n+    return m_original_gdbarch;\n+  }\n+\n+  /* Mark this thread as currently executing a displaced step.\n+\n+     ORIGINAL_GDBARCH is the current gdbarch of the thread (before the step\n+     is executed).  */\n+  void set (gdbarch *original_gdbarch)\n+  {\n+    m_original_gdbarch = original_gdbarch;\n+  }\n+\n+  /* Mark this thread as no longer executing a displaced step.  */\n+  void reset ()\n+  {\n+    m_original_gdbarch = nullptr;\n+  }\n+\n+private:\n+  gdbarch *m_original_gdbarch = nullptr;\n+};\n+\n+/* Manage access to a single displaced stepping buffer.  */\n+\n+struct displaced_step_buffer\n+{\n+  explicit displaced_step_buffer (CORE_ADDR buffer_addr)\n+    : m_addr (buffer_addr)\n+  {}\n+\n+  displaced_step_prepare_status prepare (thread_info *thread,\n+\t\t\t\t\t CORE_ADDR &displaced_pc);\n+\n+  displaced_step_finish_status finish (gdbarch *arch, thread_info *thread,\n+\t\t\t\t       gdb_signal sig);\n+\n+  const displaced_step_copy_insn_closure *\n+    copy_insn_closure_by_addr (CORE_ADDR addr);\n+\n+  void restore_in_ptid (ptid_t ptid);\n+\n+private:\n+  /* Original PC of the instruction being displaced-stepped in this buffer.  */\n+  CORE_ADDR m_original_pc = 0;\n+\n+  /* Address of the buffer.  */\n+  const CORE_ADDR m_addr;\n+\n+  /* If set, the thread currently using the buffer.  */\n+  thread_info *m_current_thread = nullptr;\n \n   /* Saved contents of copy area.  */\n-  gdb::byte_vector step_saved_copy;\n+  gdb::byte_vector m_saved_copy;\n+\n+  /* The closure provided gdbarch_displaced_step_copy_insn, to be used\n+     for post-step cleanup.  */\n+  displaced_step_copy_insn_closure_up m_copy_insn_closure;\n };\n \n #endif /* DISPLACED_STEPPING_H */"
    },
    {
      "sha": "c5ae4212ab449f0331f0d4872a26c209f66e6595",
      "filename": "gdb/frv-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/frv-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/frv-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frv-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -456,7 +456,7 @@ frv_linux_iterate_over_regset_sections (struct gdbarch *gdbarch,\n static void\n frv_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Set the sigtramp frame sniffer.  */\n   frame_unwind_append_unwinder (gdbarch, &frv_linux_sigtramp_frame_unwind); "
    },
    {
      "sha": "bf8d8bc211f329f27afbdd402e5eab7ea593a4b5",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 99,
      "deletions": 14,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -290,7 +290,10 @@ struct gdbarch\n   gdbarch_displaced_step_copy_insn_ftype *displaced_step_copy_insn;\n   gdbarch_displaced_step_hw_singlestep_ftype *displaced_step_hw_singlestep;\n   gdbarch_displaced_step_fixup_ftype *displaced_step_fixup;\n-  gdbarch_displaced_step_location_ftype *displaced_step_location;\n+  gdbarch_displaced_step_prepare_ftype *displaced_step_prepare;\n+  gdbarch_displaced_step_finish_ftype *displaced_step_finish;\n+  gdbarch_displaced_step_copy_insn_closure_by_addr_ftype *displaced_step_copy_insn_closure_by_addr;\n+  gdbarch_displaced_step_restore_all_in_ptid_ftype *displaced_step_restore_all_in_ptid;\n   gdbarch_relocate_instruction_ftype *relocate_instruction;\n   gdbarch_overlay_update_ftype *overlay_update;\n   gdbarch_core_read_description_ftype *core_read_description;\n@@ -445,7 +448,7 @@ gdbarch_alloc (const struct gdbarch_info *info,\n   gdbarch->skip_permanent_breakpoint = default_skip_permanent_breakpoint;\n   gdbarch->displaced_step_hw_singlestep = default_displaced_step_hw_singlestep;\n   gdbarch->displaced_step_fixup = NULL;\n-  gdbarch->displaced_step_location = NULL;\n+  gdbarch->displaced_step_finish = NULL;\n   gdbarch->relocate_instruction = NULL;\n   gdbarch->has_shared_address_space = default_has_shared_address_space;\n   gdbarch->fast_tracepoint_valid_at = default_fast_tracepoint_valid_at;\n@@ -660,8 +663,10 @@ verify_gdbarch (struct gdbarch *gdbarch)\n   /* Skip verify of displaced_step_copy_insn, has predicate.  */\n   /* Skip verify of displaced_step_hw_singlestep, invalid_p == 0 */\n   /* Skip verify of displaced_step_fixup, has predicate.  */\n-  if ((! gdbarch->displaced_step_location) != (! gdbarch->displaced_step_copy_insn))\n-    log.puts (\"\\n\\tdisplaced_step_location\");\n+  /* Skip verify of displaced_step_prepare, has predicate.  */\n+  if ((! gdbarch->displaced_step_finish) != (! gdbarch->displaced_step_prepare))\n+    log.puts (\"\\n\\tdisplaced_step_finish\");\n+  /* Skip verify of displaced_step_copy_insn_closure_by_addr, has predicate.  */\n   /* Skip verify of relocate_instruction, has predicate.  */\n   /* Skip verify of overlay_update, has predicate.  */\n   /* Skip verify of core_read_description, has predicate.  */\n@@ -924,6 +929,15 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: displaced_step_copy_insn = <%s>\\n\",\n                       host_address_to_string (gdbarch->displaced_step_copy_insn));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: gdbarch_displaced_step_copy_insn_closure_by_addr_p() = %d\\n\",\n+                      gdbarch_displaced_step_copy_insn_closure_by_addr_p (gdbarch));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: displaced_step_copy_insn_closure_by_addr = <%s>\\n\",\n+                      host_address_to_string (gdbarch->displaced_step_copy_insn_closure_by_addr));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: displaced_step_finish = <%s>\\n\",\n+                      host_address_to_string (gdbarch->displaced_step_finish));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: gdbarch_displaced_step_fixup_p() = %d\\n\",\n                       gdbarch_displaced_step_fixup_p (gdbarch));\n@@ -934,8 +948,14 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n                       \"gdbarch_dump: displaced_step_hw_singlestep = <%s>\\n\",\n                       host_address_to_string (gdbarch->displaced_step_hw_singlestep));\n   fprintf_unfiltered (file,\n-                      \"gdbarch_dump: displaced_step_location = <%s>\\n\",\n-                      host_address_to_string (gdbarch->displaced_step_location));\n+                      \"gdbarch_dump: gdbarch_displaced_step_prepare_p() = %d\\n\",\n+                      gdbarch_displaced_step_prepare_p (gdbarch));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: displaced_step_prepare = <%s>\\n\",\n+                      host_address_to_string (gdbarch->displaced_step_prepare));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: displaced_step_restore_all_in_ptid = <%s>\\n\",\n+                      host_address_to_string (gdbarch->displaced_step_restore_all_in_ptid));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: double_bit = %s\\n\",\n                       plongest (gdbarch->double_bit));\n@@ -4028,21 +4048,86 @@ set_gdbarch_displaced_step_fixup (struct gdbarch *gdbarch,\n   gdbarch->displaced_step_fixup = displaced_step_fixup;\n }\n \n-CORE_ADDR\n-gdbarch_displaced_step_location (struct gdbarch *gdbarch)\n+bool\n+gdbarch_displaced_step_prepare_p (struct gdbarch *gdbarch)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  return gdbarch->displaced_step_prepare != NULL;\n+}\n+\n+displaced_step_prepare_status\n+gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->displaced_step_prepare != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_displaced_step_prepare called\\n\");\n+  return gdbarch->displaced_step_prepare (gdbarch, thread, displaced_pc);\n+}\n+\n+void\n+set_gdbarch_displaced_step_prepare (struct gdbarch *gdbarch,\n+                                    gdbarch_displaced_step_prepare_ftype displaced_step_prepare)\n+{\n+  gdbarch->displaced_step_prepare = displaced_step_prepare;\n+}\n+\n+displaced_step_finish_status\n+gdbarch_displaced_step_finish (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->displaced_step_finish != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_displaced_step_finish called\\n\");\n+  return gdbarch->displaced_step_finish (gdbarch, thread, sig);\n+}\n+\n+void\n+set_gdbarch_displaced_step_finish (struct gdbarch *gdbarch,\n+                                   gdbarch_displaced_step_finish_ftype displaced_step_finish)\n+{\n+  gdbarch->displaced_step_finish = displaced_step_finish;\n+}\n+\n+bool\n+gdbarch_displaced_step_copy_insn_closure_by_addr_p (struct gdbarch *gdbarch)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  return gdbarch->displaced_step_copy_insn_closure_by_addr != NULL;\n+}\n+\n+const displaced_step_copy_insn_closure *\n+gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, inferior *inf, CORE_ADDR addr)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->displaced_step_copy_insn_closure_by_addr != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_displaced_step_copy_insn_closure_by_addr called\\n\");\n+  return gdbarch->displaced_step_copy_insn_closure_by_addr (inf, addr);\n+}\n+\n+void\n+set_gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch,\n+                                                      gdbarch_displaced_step_copy_insn_closure_by_addr_ftype displaced_step_copy_insn_closure_by_addr)\n+{\n+  gdbarch->displaced_step_copy_insn_closure_by_addr = displaced_step_copy_insn_closure_by_addr;\n+}\n+\n+void\n+gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, inferior *parent_inf, ptid_t child_ptid)\n {\n   gdb_assert (gdbarch != NULL);\n-  gdb_assert (gdbarch->displaced_step_location != NULL);\n+  gdb_assert (gdbarch->displaced_step_restore_all_in_ptid != NULL);\n   if (gdbarch_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"gdbarch_displaced_step_location called\\n\");\n-  return gdbarch->displaced_step_location (gdbarch);\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_displaced_step_restore_all_in_ptid called\\n\");\n+  gdbarch->displaced_step_restore_all_in_ptid (parent_inf, child_ptid);\n }\n \n void\n-set_gdbarch_displaced_step_location (struct gdbarch *gdbarch,\n-                                     gdbarch_displaced_step_location_ftype displaced_step_location)\n+set_gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch,\n+                                                gdbarch_displaced_step_restore_all_in_ptid_ftype displaced_step_restore_all_in_ptid)\n {\n-  gdbarch->displaced_step_location = displaced_step_location;\n+  gdbarch->displaced_step_restore_all_in_ptid = displaced_step_restore_all_in_ptid;\n }\n \n bool"
    },
    {
      "sha": "002628d8988b256afdf34fcd89ce49c14cfb27fd",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 29,
      "deletions": 9,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -58,6 +58,7 @@ struct mem_range;\n struct syscalls_info;\n struct thread_info;\n struct ui_out;\n+struct inferior;\n \n #include \"regcache.h\"\n \n@@ -1071,17 +1072,36 @@ typedef void (gdbarch_displaced_step_fixup_ftype) (struct gdbarch *gdbarch, stru\n extern void gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs);\n extern void set_gdbarch_displaced_step_fixup (struct gdbarch *gdbarch, gdbarch_displaced_step_fixup_ftype *displaced_step_fixup);\n \n-/* Return the address of an appropriate place to put displaced\n-   instructions while we step over them.  There need only be one such\n-   place, since we're only stepping one thread over a breakpoint at a\n-   time.\n+/* Prepare THREAD for it to displaced step the instruction at its current PC.\n   \n-   For a general explanation of displaced stepping and how GDB uses it,\n-   see the comments in infrun.c. */\n+   Throw an exception if any unexpected error happens. */\n+\n+extern bool gdbarch_displaced_step_prepare_p (struct gdbarch *gdbarch);\n+\n+typedef displaced_step_prepare_status (gdbarch_displaced_step_prepare_ftype) (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n+extern displaced_step_prepare_status gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, thread_info *thread, CORE_ADDR &displaced_pc);\n+extern void set_gdbarch_displaced_step_prepare (struct gdbarch *gdbarch, gdbarch_displaced_step_prepare_ftype *displaced_step_prepare);\n+\n+/* Clean up after a displaced step of THREAD. */\n+\n+typedef displaced_step_finish_status (gdbarch_displaced_step_finish_ftype) (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n+extern displaced_step_finish_status gdbarch_displaced_step_finish (struct gdbarch *gdbarch, thread_info *thread, gdb_signal sig);\n+extern void set_gdbarch_displaced_step_finish (struct gdbarch *gdbarch, gdbarch_displaced_step_finish_ftype *displaced_step_finish);\n+\n+/* Return the closure associated to the displaced step buffer that is at ADDR. */\n+\n+extern bool gdbarch_displaced_step_copy_insn_closure_by_addr_p (struct gdbarch *gdbarch);\n+\n+typedef const displaced_step_copy_insn_closure * (gdbarch_displaced_step_copy_insn_closure_by_addr_ftype) (inferior *inf, CORE_ADDR addr);\n+extern const displaced_step_copy_insn_closure * gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, inferior *inf, CORE_ADDR addr);\n+extern void set_gdbarch_displaced_step_copy_insn_closure_by_addr (struct gdbarch *gdbarch, gdbarch_displaced_step_copy_insn_closure_by_addr_ftype *displaced_step_copy_insn_closure_by_addr);\n+\n+/* PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n+   contents of all displaced step buffers in the child's address space. */\n \n-typedef CORE_ADDR (gdbarch_displaced_step_location_ftype) (struct gdbarch *gdbarch);\n-extern CORE_ADDR gdbarch_displaced_step_location (struct gdbarch *gdbarch);\n-extern void set_gdbarch_displaced_step_location (struct gdbarch *gdbarch, gdbarch_displaced_step_location_ftype *displaced_step_location);\n+typedef void (gdbarch_displaced_step_restore_all_in_ptid_ftype) (inferior *parent_inf, ptid_t child_ptid);\n+extern void gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, inferior *parent_inf, ptid_t child_ptid);\n+extern void set_gdbarch_displaced_step_restore_all_in_ptid (struct gdbarch *gdbarch, gdbarch_displaced_step_restore_all_in_ptid_ftype *displaced_step_restore_all_in_ptid);\n \n /* Relocate an instruction to execute at a different address.  OLDLOC\n    is the address in the inferior memory where the instruction to"
    },
    {
      "sha": "e90654dc5c1cbee1614936cfa1cf5b129a5e76f2",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 14,
      "deletions": 7,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -813,14 +813,20 @@ m;bool;displaced_step_hw_singlestep;void;;;default_displaced_step_hw_singlestep;\n # see the comments in infrun.c.\n M;void;displaced_step_fixup;struct displaced_step_copy_insn_closure *closure, CORE_ADDR from, CORE_ADDR to, struct regcache *regs;closure, from, to, regs;;NULL\n \n-# Return the address of an appropriate place to put displaced\n-# instructions while we step over them.  There need only be one such\n-# place, since we're only stepping one thread over a breakpoint at a\n-# time.\n+# Prepare THREAD for it to displaced step the instruction at its current PC.\n #\n-# For a general explanation of displaced stepping and how GDB uses it,\n-# see the comments in infrun.c.\n-m;CORE_ADDR;displaced_step_location;void;;;NULL;;(! gdbarch->displaced_step_location) != (! gdbarch->displaced_step_copy_insn)\n+# Throw an exception if any unexpected error happens.\n+M;displaced_step_prepare_status;displaced_step_prepare;thread_info *thread, CORE_ADDR &displaced_pc;thread, displaced_pc\n+\n+# Clean up after a displaced step of THREAD.\n+m;displaced_step_finish_status;displaced_step_finish;thread_info *thread, gdb_signal sig;thread, sig;;NULL;;(! gdbarch->displaced_step_finish) != (! gdbarch->displaced_step_prepare)\n+\n+# Return the closure associated to the displaced step buffer that is at ADDR.\n+F;const displaced_step_copy_insn_closure *;displaced_step_copy_insn_closure_by_addr;inferior *inf, CORE_ADDR addr;inf, addr\n+\n+# PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n+# contents of all displaced step buffers in the child's address space.\n+f;void;displaced_step_restore_all_in_ptid;inferior *parent_inf, ptid_t child_ptid;parent_inf, child_ptid\n \n # Relocate an instruction to execute at a different address.  OLDLOC\n # is the address in the inferior memory where the instruction to\n@@ -1297,6 +1303,7 @@ struct mem_range;\n struct syscalls_info;\n struct thread_info;\n struct ui_out;\n+struct inferior;\n \n #include \"regcache.h\"\n "
    },
    {
      "sha": "e5484ac54ca44a800aa37a8919b0c6e5eae8ccf4",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -32,6 +32,7 @@ struct symtab;\n #include \"gdbsupport/refcounted-object.h\"\n #include \"gdbsupport/common-gdbthread.h\"\n #include \"gdbsupport/forward-scope-exit.h\"\n+#include \"displaced-stepping.h\"\n \n struct inferior;\n struct process_stratum_target;\n@@ -388,6 +389,9 @@ class thread_info : public refcounted_object\n      fields point to self.  */\n   struct thread_info *step_over_prev = NULL;\n   struct thread_info *step_over_next = NULL;\n+\n+  /* Displaced-step state for this thread.  */\n+  displaced_step_thread_state displaced_step_state;\n };\n \n /* A gdb::ref_ptr pointer to a thread_info.  */\n@@ -745,10 +749,27 @@ extern bool value_in_thread_stack_temporaries (struct value *,\n \n extern void global_thread_step_over_chain_enqueue (thread_info *tp);\n \n+/* Append the thread step over chain CHAIN_HEAD to the global thread step over\n+   chain. */\n+\n+extern void global_thread_step_over_chain_enqueue_chain\n+  (thread_info *chain_head);\n+\n+/* Remove TP from step-over chain LIST_P.  */\n+\n+extern void thread_step_over_chain_remove (thread_info **list_p,\n+\t\t\t\t\t   thread_info *tp);\n+\n /* Remove TP from the global pending step-over chain.  */\n \n extern void global_thread_step_over_chain_remove (thread_info *tp);\n \n+/* Return the thread following TP in the step-over chain whose head is\n+   CHAIN_HEAD.  Return NULL if TP is the last entry in the chain.  */\n+\n+extern thread_info *thread_step_over_chain_next (thread_info *chain_head,\n+\t\t\t\t\t\t thread_info *tp);\n+\n /* Return the thread following TP in the global step-over chain, or NULL if TP\n    is the last entry in the chain.  */\n \n@@ -758,6 +779,14 @@ extern thread_info *global_thread_step_over_chain_next (thread_info *tp);\n \n extern int thread_is_in_step_over_chain (struct thread_info *tp);\n \n+/* Return the length of the the step over chain TP is in.\n+\n+   If TP is non-nullptr, the thread must be in a step over chain.\n+   TP may be nullptr, in which case it denotes an empty list, so a length of\n+   0.  */\n+\n+extern int thread_step_over_chain_length (thread_info *tp);\n+\n /* Cancel any ongoing execution command.  */\n \n extern void thread_cancel_execution_command (struct thread_info *thr);"
    },
    {
      "sha": "a171e582e595ca90108d1b0468dba4a8cc3de5c7",
      "filename": "gdb/hppa-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/hppa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/hppa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -489,7 +489,7 @@ hppa_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* GNU/Linux is always ELF.  */\n   tdep->is_elf = 1;"
    },
    {
      "sha": "1b209fd3efff7e3d1141bef4ad7085ae849b916c",
      "filename": "gdb/i386-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/i386-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/i386-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -832,7 +832,7 @@ i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   gdb_assert (tdesc_data);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, true);\n \n   /* GNU/Linux uses ELF.  */\n   i386_elf_init_abi (info, gdbarch);\n@@ -1065,8 +1065,6 @@ i386_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n \t\t\t\t\ti386_linux_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, i386_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch,\n-\t\t\t\t       linux_displaced_step_location);\n \n   /* Functions for 'catch syscall'.  */\n   set_xml_syscall_file_name (gdbarch, XML_SYSCALL_FILENAME_I386);"
    },
    {
      "sha": "d6d581ab3dda294d8022208170c2e6b507c6a627",
      "filename": "gdb/ia64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ia64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ia64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -223,7 +223,7 @@ ia64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   static const char *const stap_register_indirection_suffixes[] = { \"]\",\n \t\t\t\t\t\t\t\t    NULL };\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Set the method of obtaining the sigcontext addresses at which\n      registers are saved.  */"
    },
    {
      "sha": "e7b69ae5a5cf1a96b98fc249004050b3c137e3e6",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 143,
      "deletions": 192,
      "changes": 335,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1452,55 +1452,36 @@ step_over_info_valid_p (void)\n    displaced step operation on it.  See displaced_step_prepare and\n    displaced_step_finish for details.  */\n \n-/* Returns true if any inferior has a thread doing a displaced\n-   step.  */\n-\n-static bool\n-displaced_step_in_progress_any_inferior ()\n-{\n-  for (inferior *i : all_inferiors ())\n-    {\n-      if (i->displaced_step_state.step_thread != nullptr)\n-\treturn true;\n-    }\n-\n-  return false;\n-}\n-\n /* Return true if THREAD is doing a displaced step.  */\n \n static bool\n displaced_step_in_progress_thread (thread_info *thread)\n {\n   gdb_assert (thread != NULL);\n \n-  return thread->inf->displaced_step_state.step_thread == thread;\n+  return thread->displaced_step_state.in_progress ();\n }\n \n /* Return true if INF has a thread doing a displaced step.  */\n \n static bool\n displaced_step_in_progress (inferior *inf)\n {\n-  return inf->displaced_step_state.step_thread != nullptr;\n+  return inf->displaced_step_state.in_progress_count > 0;\n }\n \n-/* If inferior is in displaced stepping, and ADDR equals to starting address\n-   of copy area, return corresponding displaced_step_copy_insn_closure.\n-   Otherwise, return NULL.  */\n+/* Return true if any thread is doing a displaced step.  */\n \n-displaced_step_copy_insn_closure *\n-get_displaced_step_copy_insn_closure_by_addr (CORE_ADDR addr)\n+static bool\n+displaced_step_in_progress_any_thread ()\n {\n-  displaced_step_inferior_state &displaced\n-    = current_inferior ()->displaced_step_state;\n-\n-  /* If checking the mode of displaced instruction in copy area.  */\n-  if (displaced.step_thread != nullptr\n-      && displaced.step_copy == addr)\n-    return displaced.step_closure.get ();\n+  for (inferior *inf : all_non_exited_inferiors ())\n+    {\n+      if (displaced_step_in_progress (inf))\n+\treturn true;\n+    }\n \n-  return NULL;\n+  return false;\n }\n \n static void\n@@ -1512,12 +1493,15 @@ infrun_inferior_exit (struct inferior *inf)\n static void\n infrun_inferior_execd (inferior *inf)\n {\n-  /* If a thread was doing a displaced step in this inferior at the moment of\n-     the exec, it no longer exists.  Even if the exec'ing thread was the one\n+  /* If some threads where was doing a displaced step in this inferior at the\n+     moment of the exec, they no longer exist.  Even if the exec'ing thread\n      doing a displaced step, we don't want to to any fixup nor restore displaced\n      stepping buffer bytes.  */\n   inf->displaced_step_state.reset ();\n \n+  for (thread_info *thread : inf->threads ())\n+    thread->displaced_step_state.reset ();\n+\n   /* Since an in-line step is done with everything else stopped, if there was\n      one in progress at the time of the exec, it must have been the exec'ing\n      thread.  */\n@@ -1555,9 +1539,9 @@ show_can_use_displaced_stepping (struct ui_file *file, int from_tty,\n static bool\n gdbarch_supports_displaced_stepping (gdbarch *arch)\n {\n-  /* Only check for the presence of step_copy_insn.  Other required methods\n-     are checked by the gdbarch validation.  */\n-  return gdbarch_displaced_step_copy_insn_p (arch);\n+  /* Only check for the presence of `prepare`.  The gdbarch verification ensures\n+     that if `prepare` is provided, so is `finish`.  */\n+  return gdbarch_displaced_step_prepare_p (arch);\n }\n \n /* Return non-zero if displaced stepping can/should be used to step\n@@ -1595,10 +1579,10 @@ use_displaced_stepping (thread_info *tp)\n   return true;\n }\n \n-/* Simple function wrapper around displaced_step_inferior_state::reset.  */\n+/* Simple function wrapper around displaced_step_thread_state::reset.  */\n \n static void\n-displaced_step_reset (displaced_step_inferior_state *displaced)\n+displaced_step_reset (displaced_step_thread_state *displaced)\n {\n   displaced->reset ();\n }\n@@ -1649,10 +1633,8 @@ displaced_step_prepare_throw (thread_info *tp)\n {\n   regcache *regcache = get_thread_regcache (tp);\n   struct gdbarch *gdbarch = regcache->arch ();\n-  const address_space *aspace = regcache->aspace ();\n-  CORE_ADDR original, copy;\n-  ULONGEST len;\n-  int status;\n+  displaced_step_thread_state &disp_step_thread_state\n+    = tp->displaced_step_state;\n \n   /* We should never reach this function if the architecture does not\n      support displaced stepping.  */\n@@ -1667,95 +1649,69 @@ displaced_step_prepare_throw (thread_info *tp)\n      jump/branch).  */\n   tp->control.may_range_step = 0;\n \n-  /* We have to displaced step one thread at a time, as we only have\n-     access to a single scratch space per inferior.  */\n-\n-  displaced_step_inferior_state *displaced = &tp->inf->displaced_step_state;\n+  /* We are about to start a displaced step for this thread.  If one is already\n+     in progress, something's wrong.  */\n+  gdb_assert (!disp_step_thread_state.in_progress ());\n \n-  if (displaced->step_thread != nullptr)\n+  if (tp->inf->displaced_step_state.unavailable)\n     {\n-      /* Already waiting for a displaced step to finish.  Defer this\n-\t request and place in queue.  */\n+      /* The gdbarch tells us it's not worth asking to try a prepare because\n+\t it is likely that it will return unavailable, so don't bother asking.  */\n \n       displaced_debug_printf (\"deferring step of %s\",\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \n       global_thread_step_over_chain_enqueue (tp);\n       return DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE;\n     }\n-  else\n-    displaced_debug_printf (\"stepping %s now\",\n-\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \n-  displaced_step_reset (displaced);\n+  displaced_debug_printf (\"displaced-stepping %s now\",\n+\t\t\t  target_pid_to_str (tp->ptid).c_str ());\n \n   scoped_restore_current_thread restore_thread;\n \n   switch_to_thread (tp);\n \n-  original = regcache_read_pc (regcache);\n+  CORE_ADDR original_pc = regcache_read_pc (regcache);\n+  CORE_ADDR displaced_pc;\n \n-  copy = gdbarch_displaced_step_location (gdbarch);\n-  len = gdbarch_max_insn_length (gdbarch);\n+  displaced_step_prepare_status status\n+    = gdbarch_displaced_step_prepare (gdbarch, tp, displaced_pc);\n \n-  if (breakpoint_in_range_p (aspace, copy, len))\n+  if (status == DISPLACED_STEP_PREPARE_STATUS_CANT)\n     {\n-      /* There's a breakpoint set in the scratch pad location range\n-\t (which is usually around the entry point).  We'd either\n-\t install it before resuming, which would overwrite/corrupt the\n-\t scratch pad, or if it was already inserted, this displaced\n-\t step would overwrite it.  The latter is OK in the sense that\n-\t we already assume that no thread is going to execute the code\n-\t in the scratch pad range (after initial startup) anyway, but\n-\t the former is unacceptable.  Simply punt and fallback to\n-\t stepping over this breakpoint in-line.  */\n-      displaced_debug_printf (\"breakpoint set in scratch pad.  \"\n-\t\t\t      \"Stepping over breakpoint in-line instead.\");\n+      displaced_debug_printf (\"failed to prepare (%s)\",\n+\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \n       return DISPLACED_STEP_PREPARE_STATUS_CANT;\n     }\n+  else if (status == DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE)\n+    {\n+      /* Not enough displaced stepping resources available, defer this\n+\t request by placing it the queue.  */\n \n-  /* Save the original contents of the copy area.  */\n-  displaced->step_saved_copy.resize (len);\n-  status = target_read_memory (copy, displaced->step_saved_copy.data (), len);\n-  if (status != 0)\n-    throw_error (MEMORY_ERROR,\n-\t\t _(\"Error accessing memory address %s (%s) for \"\n-\t\t   \"displaced-stepping scratch space.\"),\n-\t\t paddress (gdbarch, copy), safe_strerror (status));\n+      displaced_debug_printf (\"not enough resources available, \"\n+\t\t\t      \"deferring step of %s\",\n+\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \n-  displaced_debug_printf (\"saved %s: %s\",\n-\t\t\t  paddress (gdbarch, copy),\n-\t\t\t  displaced_step_dump_bytes\n-\t\t\t    (displaced->step_saved_copy.data (), len).c_str ());\n+      global_thread_step_over_chain_enqueue (tp);\n \n-  displaced->step_closure\n-    = gdbarch_displaced_step_copy_insn (gdbarch, original, copy, regcache);\n-  if (displaced->step_closure == NULL)\n-    {\n-      /* The architecture doesn't know how or want to displaced step\n-\t this instruction or instruction sequence.  Fallback to\n-\t stepping over the breakpoint in-line.  */\n-      return DISPLACED_STEP_PREPARE_STATUS_CANT;\n+      return DISPLACED_STEP_PREPARE_STATUS_UNAVAILABLE;\n     }\n \n+  gdb_assert (status == DISPLACED_STEP_PREPARE_STATUS_OK);\n+\n   /* Save the information we need to fix things up if the step\n      succeeds.  */\n-  displaced->step_thread = tp;\n-  displaced->step_gdbarch = gdbarch;\n-  displaced->step_original = original;\n-  displaced->step_copy = copy;\n-\n-  {\n-    displaced_step_reset_cleanup cleanup (displaced);\n+  disp_step_thread_state.set (gdbarch);\n \n-    /* Resume execution at the copy.  */\n-    regcache_write_pc (regcache, copy);\n+  tp->inf->displaced_step_state.in_progress_count++;\n \n-    cleanup.release ();\n-  }\n-\n-  displaced_debug_printf (\"displaced pc to %s\", paddress (gdbarch, copy));\n+  displaced_debug_printf (\"prepared successfully thread=%s, \"\n+\t\t\t  \"original_pc=%s, displaced_pc=%s\",\n+\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t  paddress (gdbarch, original_pc),\n+\t\t\t  paddress (gdbarch, displaced_pc));\n \n   return DISPLACED_STEP_PREPARE_STATUS_OK;\n }\n@@ -1797,33 +1753,6 @@ displaced_step_prepare (thread_info *thread)\n   return status;\n }\n \n-static void\n-write_memory_ptid (ptid_t ptid, CORE_ADDR memaddr,\n-\t\t   const gdb_byte *myaddr, int len)\n-{\n-  scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n-\n-  inferior_ptid = ptid;\n-  write_memory (memaddr, myaddr, len);\n-}\n-\n-/* Restore the contents of the copy area for thread PTID.  */\n-\n-static void\n-displaced_step_restore (struct displaced_step_inferior_state *displaced,\n-\t\t\tptid_t ptid)\n-{\n-  ULONGEST len = gdbarch_max_insn_length (displaced->step_gdbarch);\n-\n-  write_memory_ptid (ptid, displaced->step_copy,\n-\t\t     displaced->step_saved_copy.data (), len);\n-\n-  displaced_debug_printf (\"restored %s %s\",\n-\t\t\t  target_pid_to_str (ptid).c_str (),\n-\t\t\t  paddress (displaced->step_gdbarch,\n-\t\t\t\t    displaced->step_copy));\n-}\n-\n /* If we displaced stepped an instruction successfully, adjust registers and\n    memory to yield the same effect the instruction would have had if we had\n    executed it at its original address, and return\n@@ -1836,13 +1765,15 @@ displaced_step_restore (struct displaced_step_inferior_state *displaced,\n static displaced_step_finish_status\n displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n {\n-  displaced_step_inferior_state *displaced\n-    = &event_thread->inf->displaced_step_state;\n+  displaced_step_thread_state *displaced = &event_thread->displaced_step_state;\n \n-  /* Was this event for the thread we displaced?  */\n-  if (displaced->step_thread != event_thread)\n+  /* Was this thread performing a displaced step?  */\n+  if (!displaced->in_progress ())\n     return DISPLACED_STEP_FINISH_STATUS_OK;\n \n+  gdb_assert (event_thread->inf->displaced_step_state.in_progress_count > 0);\n+  event_thread->inf->displaced_step_state.in_progress_count--;\n+\n   /* Fixup may need to read memory/registers.  Switch to the thread\n      that we're fixing up.  Also, target_stopped_by_watchpoint checks\n      the current thread, and displaced_step_restore performs ptid-dependent\n@@ -1851,35 +1782,10 @@ displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n \n   displaced_step_reset_cleanup cleanup (displaced);\n \n-  displaced_step_restore (displaced, displaced->step_thread->ptid);\n-\n-  /* Did the instruction complete successfully?  */\n-  if (signal == GDB_SIGNAL_TRAP\n-      && !(target_stopped_by_watchpoint ()\n-\t   && (gdbarch_have_nonsteppable_watchpoint (displaced->step_gdbarch)\n-\t       || target_have_steppable_watchpoint ())))\n-    {\n-      /* Fix up the resulting state.  */\n-      gdbarch_displaced_step_fixup (displaced->step_gdbarch,\n-\t\t\t\t    displaced->step_closure.get (),\n-\t\t\t\t    displaced->step_original,\n-\t\t\t\t    displaced->step_copy,\n-\t\t\t\t    get_thread_regcache (displaced->step_thread));\n-\n-      return DISPLACED_STEP_FINISH_STATUS_OK;\n-    }\n-  else\n-    {\n-      /* Since the instruction didn't complete, all we can do is\n-\t relocate the PC.  */\n-      struct regcache *regcache = get_thread_regcache (event_thread);\n-      CORE_ADDR pc = regcache_read_pc (regcache);\n-\n-      pc = displaced->step_original + (pc - displaced->step_copy);\n-      regcache_write_pc (regcache, pc);\n-\n-      return DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED;\n-    }\n+  /* Do the fixup, and release the resources acquired to do the displaced\n+     step. */\n+  return gdbarch_displaced_step_finish (displaced->get_original_gdbarch (),\n+\t\t\t\t\tevent_thread, signal);\n }\n \n /* Data to be passed around while handling an event.  This data is\n@@ -1927,14 +1833,42 @@ static step_over_what thread_still_needs_step_over (struct thread_info *tp);\n static bool\n start_step_over (void)\n {\n-  struct thread_info *tp, *next;\n+  thread_info *next;\n \n   /* Don't start a new step-over if we already have an in-line\n      step-over operation ongoing.  */\n   if (step_over_info_valid_p ())\n     return false;\n \n-  for (tp = global_thread_step_over_chain_head; tp != NULL; tp = next)\n+  /* Steal the global thread step over chain.  As we try to initiate displaced\n+     steps, threads will be enqueued in the global chain if no buffers are\n+     available.  If we iterated on the global chain directly, we might iterate\n+     indefinitely.  */\n+  thread_info *threads_to_step = global_thread_step_over_chain_head;\n+  global_thread_step_over_chain_head = NULL;\n+\n+  infrun_debug_printf (\"stealing global queue of threads to step, length = %d\",\n+\t\t       thread_step_over_chain_length (threads_to_step));\n+\n+  bool started = false;\n+\n+  /* On scope exit (whatever the reason, return or exception), if there are\n+     threads left in the THREADS_TO_STEP chain, put back these threads in the\n+     global list.  */\n+  SCOPE_EXIT\n+    {\n+      if (threads_to_step == nullptr)\n+\tinfrun_debug_printf (\"step-over queue now empty\");\n+      else\n+\t{\n+\t  infrun_debug_printf (\"putting back %d threads to step in global queue\",\n+\t\t\t       thread_step_over_chain_length (threads_to_step));\n+\n+\t  global_thread_step_over_chain_enqueue_chain (threads_to_step);\n+\t}\n+    };\n+\n+  for (thread_info *tp = threads_to_step; tp != NULL; tp = next)\n     {\n       struct execution_control_state ecss;\n       struct execution_control_state *ecs = &ecss;\n@@ -1943,12 +1877,23 @@ start_step_over (void)\n \n       gdb_assert (!tp->stop_requested);\n \n-      next = global_thread_step_over_chain_next (tp);\n+      next = thread_step_over_chain_next (threads_to_step, tp);\n \n-      /* If this inferior already has a displaced step in process,\n-\t don't start a new one.  */\n-      if (displaced_step_in_progress (tp->inf))\n-\tcontinue;\n+      if (tp->inf->displaced_step_state.unavailable)\n+\t{\n+\t  /* The arch told us to not even try preparing another displaced step\n+\t     for this inferior.  Just leave the thread in THREADS_TO_STEP, it\n+\t     will get moved to the global chain on scope exit.  */\n+\t  continue;\n+\t}\n+\n+      /* Remove thread from the THREADS_TO_STEP chain.  If anything goes wrong\n+\t while we try to prepare the displaced step, we don't add it back to\n+\t the global step over chain.  This is to avoid a thread staying in the\n+\t step over chain indefinitely if something goes wrong when resuming it\n+\t If the error is intermittent and it still needs a step over, it will\n+\t get enqueued again when we try to resume it normally.  */\n+      thread_step_over_chain_remove (&threads_to_step, tp);\n \n       step_what = thread_still_needs_step_over (tp);\n       must_be_in_line = ((step_what & STEP_OVER_WATCHPOINT)\n@@ -1958,13 +1903,11 @@ start_step_over (void)\n       /* We currently stop all threads of all processes to step-over\n \t in-line.  If we need to start a new in-line step-over, let\n \t any pending displaced steps finish first.  */\n-      if (must_be_in_line && displaced_step_in_progress_any_inferior ())\n-\treturn false;\n-\n-      global_thread_step_over_chain_remove (tp);\n-\n-      if (global_thread_step_over_chain_head == NULL)\n-\tinfrun_debug_printf (\"step-over queue now empty\");\n+      if (must_be_in_line && displaced_step_in_progress_any_thread ())\n+\t{\n+\t  global_thread_step_over_chain_enqueue (tp);\n+\t  continue;\n+\t}\n \n       if (tp->control.trap_expected\n \t  || tp->resumed\n@@ -1998,13 +1941,27 @@ start_step_over (void)\n       if (!ecs->wait_some_more)\n \terror (_(\"Command aborted.\"));\n \n-      gdb_assert (tp->resumed);\n+      /* If the thread's step over could not be initiated because no buffers\n+\t were available, it was re-added to the global step over chain.  */\n+      if (tp->resumed)\n+\t{\n+\t  infrun_debug_printf (\"[%s] was resumed.\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t  gdb_assert (!thread_is_in_step_over_chain (tp));\n+\t}\n+      else\n+\t{\n+\t  infrun_debug_printf (\"[%s] was NOT resumed.\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t  gdb_assert (thread_is_in_step_over_chain (tp));\n+\t}\n \n       /* If we started a new in-line step-over, we're done.  */\n       if (step_over_info_valid_p ())\n \t{\n \t  gdb_assert (tp->control.trap_expected);\n-\t  return true;\n+\t  started = true;\n+\t  break;\n \t}\n \n       if (!target_is_non_stop_p ())\n@@ -2017,7 +1974,8 @@ start_step_over (void)\n \t  /* With remote targets (at least), in all-stop, we can't\n \t     issue any further remote commands until the program stops\n \t     again.  */\n-\t  return true;\n+\t  started = true;\n+\t  break;\n \t}\n \n       /* Either the thread no longer needed a step-over, or a new\n@@ -2026,7 +1984,7 @@ start_step_over (void)\n \t displaced step on a thread of other process. */\n     }\n \n-  return false;\n+  return started;\n }\n \n /* Update global variables holding ptids to hold NEW_PTID if they were\n@@ -3611,18 +3569,16 @@ prepare_for_detach (void)\n   struct inferior *inf = current_inferior ();\n   ptid_t pid_ptid = ptid_t (inf->pid);\n \n-  displaced_step_inferior_state *displaced = &inf->displaced_step_state;\n-\n   /* Is any thread of this process displaced stepping?  If not,\n      there's nothing else to do.  */\n-  if (displaced->step_thread == nullptr)\n+  if (displaced_step_in_progress (inf))\n     return;\n \n   infrun_debug_printf (\"displaced-stepping in-process while detaching\");\n \n   scoped_restore restore_detaching = make_scoped_restore (&inf->detaching, true);\n \n-  while (displaced->step_thread != nullptr)\n+  while (displaced_step_in_progress (inf))\n     {\n       struct execution_control_state ecss;\n       struct execution_control_state *ecs;\n@@ -5288,17 +5244,12 @@ handle_inferior_event (struct execution_control_state *ecs)\n \tstruct gdbarch *gdbarch = regcache->arch ();\n \tinferior *parent_inf = find_inferior_ptid (ecs->target, ecs->ptid);\n \n-\t/* If this is a fork (child gets its own address space copy) and the\n-\t   displaced step buffer was in use at the time of the fork, restore\n-\t   displaced step buffer bytes in the child process.  */\n+\t/* If this is a fork (child gets its own address space copy) and some\n+\t   displaced step buffers were in use at the time of the fork, restore\n+\t   the displaced step buffer bytes in the child process.  */\n \tif (ecs->ws.kind == TARGET_WAITKIND_FORKED)\n-\t  {\n-\t    displaced_step_inferior_state *displaced\n-\t      = &parent_inf->displaced_step_state;\n-\n-\t    if (displaced->step_thread != nullptr)\n-\t      displaced_step_restore (displaced, ecs->ws.value.related_pid);\n-\t  }\n+\t  gdbarch_displaced_step_restore_all_in_ptid\n+\t    (gdbarch, parent_inf, ecs->ws.value.related_pid);\n \n \t/* If displaced stepping is supported, and thread ecs->ptid is\n \t   displaced stepping.  */"
    },
    {
      "sha": "d5e6d279f1a093d18959b8bd4e16376b5eaeb0a0",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -226,9 +226,6 @@ extern void clear_exit_convenience_vars (void);\n /* Dump LEN bytes at BUF in hex to a string and return it.  */\n extern std::string displaced_step_dump_bytes (const gdb_byte *buf, size_t len);\n \n-extern struct displaced_step_copy_insn_closure *\n-  get_displaced_step_copy_insn_closure_by_addr (CORE_ADDR addr);\n-\n extern void update_observer_mode (void);\n \n extern void signal_catch_update (const unsigned int *);"
    },
    {
      "sha": "70e74d510971b328ca43210557248a561e998616",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 75,
      "deletions": 1,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -199,6 +199,9 @@ struct linux_info\n      yet.  Positive if we tried looking it up, and found it.  Negative\n      if we tried looking it up but failed.  */\n   int vsyscall_range_p = 0;\n+\n+  /* Inferior's displaced step buffer.  */\n+  gdb::optional<displaced_step_buffer> disp_step_buf;\n };\n \n /* Per-inferior data key.  */\n@@ -2531,6 +2534,65 @@ linux_displaced_step_location (struct gdbarch *gdbarch)\n \n /* See linux-tdep.h.  */\n \n+displaced_step_prepare_status\n+linux_displaced_step_prepare (gdbarch *arch, thread_info *thread,\n+\t\t\t      CORE_ADDR &displaced_pc)\n+{\n+  linux_info *per_inferior = get_linux_inferior_data (thread->inf);\n+\n+  if (!per_inferior->disp_step_buf.has_value ())\n+    {\n+      CORE_ADDR disp_step_buf_addr\n+\t= linux_displaced_step_location (thread->inf->gdbarch);\n+\n+      per_inferior->disp_step_buf.emplace (disp_step_buf_addr);\n+    }\n+\n+  return per_inferior->disp_step_buf->prepare (thread, displaced_pc);\n+}\n+\n+/* See linux-tdep.h.  */\n+\n+displaced_step_finish_status\n+linux_displaced_step_finish (gdbarch *arch, thread_info *thread, gdb_signal sig)\n+{\n+  linux_info *per_inferior = get_linux_inferior_data (thread->inf);\n+\n+  gdb_assert (per_inferior->disp_step_buf.has_value ());\n+\n+  return per_inferior->disp_step_buf->finish (arch, thread, sig);\n+}\n+\n+/* See linux-tdep.h.  */\n+\n+const displaced_step_copy_insn_closure *\n+linux_displaced_step_copy_insn_closure_by_addr (inferior *inf, CORE_ADDR addr)\n+{\n+  linux_info *per_inferior = linux_inferior_data.get (inf);\n+\n+  if (per_inferior == nullptr\n+      || !per_inferior->disp_step_buf.has_value ())\n+    return nullptr;\n+\n+  return per_inferior->disp_step_buf->copy_insn_closure_by_addr (addr);\n+}\n+\n+/* See linux-tdep.h.  */\n+\n+void\n+linux_displaced_step_restore_all_in_ptid (inferior *parent_inf, ptid_t ptid)\n+{\n+  linux_info *per_inferior = linux_inferior_data.get (parent_inf);\n+\n+  if (per_inferior == nullptr\n+      || !per_inferior->disp_step_buf.has_value ())\n+    return;\n+\n+  per_inferior->disp_step_buf->restore_in_ptid (ptid);\n+}\n+\n+/* See linux-tdep.h.  */\n+\n CORE_ADDR\n linux_get_hwcap (struct target_ops *target)\n {\n@@ -2577,8 +2639,19 @@ show_dump_excluded_mappings (struct ui_file *file, int from_tty,\n    various GNU/Linux architectures and machine types.  */\n \n void\n-linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n+linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch,\n+\t\tbool supports_displaced_step)\n {\n+  if (supports_displaced_step)\n+    {\n+      set_gdbarch_displaced_step_prepare (gdbarch, linux_displaced_step_prepare);\n+      set_gdbarch_displaced_step_finish (gdbarch, linux_displaced_step_finish);\n+      set_gdbarch_displaced_step_copy_insn_closure_by_addr\n+\t(gdbarch, linux_displaced_step_copy_insn_closure_by_addr);\n+      set_gdbarch_displaced_step_restore_all_in_ptid\n+\t(gdbarch, linux_displaced_step_restore_all_in_ptid);\n+    }\n+\n   set_gdbarch_core_pid_to_str (gdbarch, linux_core_pid_to_str);\n   set_gdbarch_info_proc (gdbarch, linux_info_proc);\n   set_gdbarch_core_info_proc (gdbarch, linux_core_info_proc);\n@@ -2608,6 +2681,7 @@ _initialize_linux_tdep ()\n   /* Observers used to invalidate the cache when needed.  */\n   gdb::observers::inferior_exit.attach (invalidate_linux_cache_inf);\n   gdb::observers::inferior_appeared.attach (invalidate_linux_cache_inf);\n+  gdb::observers::inferior_execd.attach (invalidate_linux_cache_inf);\n \n   add_setshow_boolean_cmd (\"use-coredump-filter\", class_files,\n \t\t\t   &use_coredump_filter, _(\"\\"
    },
    {
      "sha": "0f83dc3c7811bfe330420c7ddfc3c3844628f601",
      "filename": "gdb/linux-tdep.h",
      "status": "modified",
      "additions": 26,
      "deletions": 1,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/linux-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/linux-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.h?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -21,7 +21,9 @@\n #define LINUX_TDEP_H\n \n #include \"bfd.h\"\n+#include \"displaced-stepping.h\"\n \n+struct inferior;\n struct regcache;\n \n /* Enum used to define the extra fields of the siginfo type used by an\n@@ -57,7 +59,30 @@ extern int linux_gdb_signal_to_target (struct gdbarch *gdbarch,\n    the target auxiliary vector.  */\n extern CORE_ADDR linux_displaced_step_location (struct gdbarch *gdbarch);\n \n-extern void linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch);\n+\n+/* Implementation of gdbarch_displaced_step_prepare.  */\n+\n+extern displaced_step_prepare_status linux_displaced_step_prepare\n+  (gdbarch *arch, thread_info *thread, CORE_ADDR &displaced_pc);\n+\n+/* Implementation of gdbarch_displaced_step_finish.  */\n+\n+extern displaced_step_finish_status linux_displaced_step_finish\n+  (gdbarch *arch, thread_info *thread, gdb_signal sig);\n+\n+/* Implementation of gdbarch_displaced_step_copy_insn_closure_by_addr.  */\n+\n+extern const displaced_step_copy_insn_closure *\n+  linux_displaced_step_copy_insn_closure_by_addr\n+    (inferior *inf, CORE_ADDR addr);\n+\n+/* Implementation of gdbarch_displaced_step_restore_all_in_ptid.  */\n+\n+extern void linux_displaced_step_restore_all_in_ptid (inferior *parent_inf,\n+\t\t\t\t\t\t      ptid_t ptid);\n+\n+extern void linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch,\n+\t\t\t    bool supports_displaced_step);\n \n extern int linux_is_uclinux (void);\n "
    },
    {
      "sha": "961d54a2ca261dc618070100939d8d1ca33114d3",
      "filename": "gdb/m32r-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/m32r-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/m32r-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32r-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -449,7 +449,7 @@ static void\n m32r_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Since EVB register is not available for native debug, we reduce\n      the number of registers.  */"
    },
    {
      "sha": "509333558ec93f94fc860a9a14ff3a0614a12847",
      "filename": "gdb/m68k-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/m68k-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/m68k-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -385,7 +385,7 @@ m68k_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   tdep->jb_pc = M68K_LINUX_JB_PC;\n   tdep->jb_elt_size = M68K_LINUX_JB_ELEMENT_SIZE;"
    },
    {
      "sha": "2a91e1bb39a876acff800bf53956f772ba65e587",
      "filename": "gdb/microblaze-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/microblaze-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/microblaze-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/microblaze-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -117,7 +117,7 @@ static void\n microblaze_linux_init_abi (struct gdbarch_info info,\n \t\t\t   struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   set_gdbarch_memory_remove_breakpoint (gdbarch,\n \t\t\t\t\tmicroblaze_linux_memory_remove_breakpoint);"
    },
    {
      "sha": "9ca59e5b296b3b4b8ad2704b20e8b736a67179f8",
      "filename": "gdb/mips-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/mips-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/mips-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1531,7 +1531,7 @@ mips_linux_init_abi (struct gdbarch_info info,\n   enum mips_abi abi = mips_abi (gdbarch);\n   struct tdesc_arch_data *tdesc_data = info.tdesc_data;\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Get the syscall number from the arch's register.  */\n   set_gdbarch_get_syscall_number (gdbarch, mips_linux_get_syscall_number);"
    },
    {
      "sha": "27645b1260c858e527cca0f389aad69765fc44f7",
      "filename": "gdb/mn10300-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/mn10300-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/mn10300-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -704,7 +704,7 @@ am33_linux_sigframe_cache_init (const struct tramp_frame *self,\n static void\n am33_linux_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   set_gdbarch_iterate_over_regset_sections\n     (gdbarch, am33_iterate_over_regset_sections);"
    },
    {
      "sha": "b5c12852c70565e8f45904164d59b2d4b74e6230",
      "filename": "gdb/nios2-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/nios2-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/nios2-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -219,7 +219,7 @@ nios2_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Shared library handling.  */\n   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);"
    },
    {
      "sha": "33ddd10e85f377f3b9a8541e0881215ff40eeff8",
      "filename": "gdb/or1k-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/or1k-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/or1k-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -140,7 +140,7 @@ or1k_linux_sigframe_init (const struct tramp_frame *self,\n static void\n or1k_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   set_solib_svr4_fetch_link_map_offsets (gdbarch,\n \t\t\t\t\t svr4_ilp32_fetch_link_map_offsets);"
    },
    {
      "sha": "e6c10dd83db512392f6487ab8e66cb2c63238086",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1993,7 +1993,7 @@ ppc_linux_init_abi (struct gdbarch_info info,\n   static const char *const stap_register_indirection_suffixes[] = { \")\",\n \t\t\t\t\t\t\t\t    NULL };\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* PPC GNU/Linux uses either 64-bit or 128-bit long doubles; where\n      128-bit, they can be either IBM long double or IEEE quad long double.\n@@ -2143,9 +2143,6 @@ ppc_linux_init_abi (struct gdbarch_info info,\n \t}\n     }\n \n-  set_gdbarch_displaced_step_location (gdbarch,\n-\t\t\t\t       linux_displaced_step_location);\n-\n   /* Support reverse debugging.  */\n   set_gdbarch_process_record (gdbarch, ppc_process_record);\n   set_gdbarch_process_record_signal (gdbarch, ppc_linux_record_signal);"
    },
    {
      "sha": "a2238ad786eb64de26384757c4f15f17cd0b4ba9",
      "filename": "gdb/riscv-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/riscv-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/riscv-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -159,7 +159,7 @@ riscv_linux_sigframe_init (const struct tramp_frame *self,\n static void\n riscv_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   set_gdbarch_software_single_step (gdbarch, riscv_software_single_step);\n "
    },
    {
      "sha": "b5b398ed4d7f4a7ce42ec192408d718d66822797",
      "filename": "gdb/rs6000-aix-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/rs6000-aix-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/rs6000-aix-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-aix-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1132,10 +1132,12 @@ rs6000_aix_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   set_gdbarch_software_single_step (gdbarch, rs6000_software_single_step);\n \n   /* Displaced stepping is currently not supported in combination with\n-     software single-stepping.  */\n+     software single-stepping.  These override the values set by\n+     rs6000_gdbarch_init.  */\n   set_gdbarch_displaced_step_copy_insn (gdbarch, NULL);\n   set_gdbarch_displaced_step_fixup (gdbarch, NULL);\n-  set_gdbarch_displaced_step_location (gdbarch, NULL);\n+  set_gdbarch_displaced_step_prepare (gdbarch, NULL);\n+  set_gdbarch_displaced_step_finish (gdbarch, NULL);\n \n   set_gdbarch_push_dummy_call (gdbarch, rs6000_push_dummy_call);\n   set_gdbarch_return_value (gdbarch, rs6000_return_value);"
    },
    {
      "sha": "1a7c7fcb9f169ffe4b6b66dabe2565929eace8cd",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 76,
      "deletions": 2,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -153,6 +153,31 @@ static const char *const powerpc_vector_strings[] =\n static enum powerpc_vector_abi powerpc_vector_abi_global = POWERPC_VEC_AUTO;\n static const char *powerpc_vector_abi_string = \"auto\";\n \n+/* PowerPC-related per-inferior data.  */\n+\n+struct ppc_inferior_data\n+{\n+  /* This is an optional in case we add more fields to ppc_inferior_data, we\n+     don't want it instantiated as soon as we get the ppc_inferior_data for an\n+     inferior.  */\n+  gdb::optional<displaced_step_buffer> disp_step_buf;\n+};\n+\n+static inferior_key<ppc_inferior_data> ppc_inferior_data_key;\n+\n+/* Get the per-inferior PowerPC data for INF.  */\n+\n+static ppc_inferior_data *\n+get_ppc_per_inferior (inferior *inf)\n+{\n+  ppc_inferior_data *per_inf = ppc_inferior_data_key.get (inf);\n+\n+  if (per_inf == nullptr)\n+    per_inf = ppc_inferior_data_key.emplace (inf);\n+\n+  return per_inf;\n+}\n+\n /* To be used by skip_prologue.  */\n \n struct rs6000_framedata\n@@ -979,6 +1004,53 @@ ppc_displaced_step_fixup (struct gdbarch *gdbarch,\n \t\t\t\t    from + offset);\n }\n \n+/* Implementation of gdbarch_displaced_step_prepare.  */\n+\n+static displaced_step_prepare_status\n+ppc_displaced_step_prepare  (gdbarch *arch, thread_info *thread,\n+\t\t\t     CORE_ADDR &displaced_pc)\n+{\n+  ppc_inferior_data *per_inferior = get_ppc_per_inferior (thread->inf);\n+\n+  if (!per_inferior->disp_step_buf.has_value ())\n+    {\n+      /* Figure out where the displaced step buffer is.  */\n+      CORE_ADDR disp_step_buf_addr\n+\t= displaced_step_at_entry_point (thread->inf->gdbarch);\n+\n+      per_inferior->disp_step_buf.emplace (disp_step_buf_addr);\n+    }\n+\n+  return per_inferior->disp_step_buf->prepare (thread, displaced_pc);\n+}\n+\n+/* Implementation of gdbarch_displaced_step_finish.  */\n+\n+static displaced_step_finish_status\n+ppc_displaced_step_finish (gdbarch *arch, thread_info *thread,\n+\t\t\t   gdb_signal sig)\n+{\n+  ppc_inferior_data *per_inferior = get_ppc_per_inferior (thread->inf);\n+\n+  gdb_assert (per_inferior->disp_step_buf.has_value ());\n+\n+  return per_inferior->disp_step_buf->finish (arch, thread, sig);\n+}\n+\n+/* Implementation of gdbarch_displaced_step_restore_all_in_ptid.  */\n+\n+static void\n+ppc_displaced_step_restore_all_in_ptid (inferior *parent_inf, ptid_t ptid)\n+{\n+  ppc_inferior_data *per_inferior = ppc_inferior_data_key.get (parent_inf);\n+\n+  if (per_inferior == nullptr\n+      || !per_inferior->disp_step_buf.has_value ())\n+    return;\n+\n+  per_inferior->disp_step_buf->restore_in_ptid (ptid);\n+}\n+\n /* Always use hardware single-stepping to execute the\n    displaced instruction.  */\n static bool\n@@ -6990,8 +7062,10 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   set_gdbarch_displaced_step_hw_singlestep (gdbarch,\n \t\t\t\t\t    ppc_displaced_step_hw_singlestep);\n   set_gdbarch_displaced_step_fixup (gdbarch, ppc_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch,\n-\t\t\t\t       displaced_step_at_entry_point);\n+  set_gdbarch_displaced_step_prepare (gdbarch, ppc_displaced_step_prepare);\n+  set_gdbarch_displaced_step_finish (gdbarch, ppc_displaced_step_finish);\n+  set_gdbarch_displaced_step_restore_all_in_ptid\n+    (gdbarch, ppc_displaced_step_restore_all_in_ptid);\n \n   set_gdbarch_max_insn_length (gdbarch, PPC_INSN_SIZE);\n "
    },
    {
      "sha": "14e92d2c6f33ba967d4420ee4a9cfcad6bddded5",
      "filename": "gdb/s390-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/s390-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/s390-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1119,7 +1119,7 @@ s390_linux_init_abi_any (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   tdep->s390_syscall_record = s390_linux_syscall_record;\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Register handling.  */\n   set_gdbarch_core_read_description (gdbarch, s390_core_read_description);"
    },
    {
      "sha": "76eeda64c7ca563afc5d3d5a9e97683e689cbd9c",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -7047,7 +7047,10 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   set_gdbarch_displaced_step_copy_insn (gdbarch,\n \t\t\t\t\ts390_displaced_step_copy_insn);\n   set_gdbarch_displaced_step_fixup (gdbarch, s390_displaced_step_fixup);\n-  set_gdbarch_displaced_step_location (gdbarch, linux_displaced_step_location);\n+  set_gdbarch_displaced_step_prepare (gdbarch, linux_displaced_step_prepare);\n+  set_gdbarch_displaced_step_finish (gdbarch, linux_displaced_step_finish);\n+  set_gdbarch_displaced_step_restore_all_in_ptid\n+    (gdbarch, linux_displaced_step_restore_all_in_ptid);\n   set_gdbarch_displaced_step_hw_singlestep (gdbarch, s390_displaced_step_hw_singlestep);\n   set_gdbarch_software_single_step (gdbarch, s390_software_single_step);\n   set_gdbarch_max_insn_length (gdbarch, S390_MAX_INSTR_SIZE);"
    },
    {
      "sha": "b7c66b70294e3df55a3f5c94315de540753d9ab1",
      "filename": "gdb/sh-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sh-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sh-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -184,7 +184,7 @@ static struct tramp_frame sh_linux_rt_sigreturn_tramp_frame = {\n static void\n sh_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* GNU/Linux uses SVR4-style shared libraries.  */\n   set_gdbarch_skip_trampoline_code (gdbarch, find_solib_trampoline_target);"
    },
    {
      "sha": "3dbc65ca24df3a5c41b81bdbd67cbff63993acab",
      "filename": "gdb/sparc-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sparc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sparc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -422,7 +422,7 @@ sparc32_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   tdep->gregset = &sparc32_linux_gregset;\n   tdep->sizeof_gregset = 152;"
    },
    {
      "sha": "10a6eb527785142a2563e09ba58f51ff99f2b4bf",
      "filename": "gdb/sparc64-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sparc64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/sparc64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -365,7 +365,7 @@ sparc64_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   tdep->gregset = &sparc64_linux_gregset;\n   tdep->sizeof_gregset = 288;"
    },
    {
      "sha": "2c4553d6448c8ae64466bb3cface3b2aae1218a1",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -1,3 +1,9 @@\n+2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdb.arch/amd64-disp-step-avx.exp: Adjust pattern.\n+\t* gdb.threads/forking-threads-plus-breakpoint.exp: Likewise.\n+\t* gdb.threads/non-stop-fair-events.exp: Likewise.\n+\n 2020-12-04  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdb.threads/step-over-exec.exp: New."
    },
    {
      "sha": "a2cd682d5435ecbfe1e65ed6eda4b748aa0e46d8",
      "filename": "gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/amd64-disp-step-avx.exp?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -97,7 +97,7 @@ proc disp_step_func { func } {\n     gdb_test_no_output \"set debug displaced on\"\n \n     gdb_test \"continue\" \\\n-\t\"Continuing.*displaced pc to.*Breakpoint.*, ${test_end_label} ().*\" \\\n+\t\"Continuing.*prepared successfully .*Breakpoint.*, ${test_end_label} ().*\" \\\n \t\"continue to ${test_end_label}\"\n \n     gdb_test_no_output \"set debug displaced off\""
    },
    {
      "sha": "4ce30154bdf81127cf6a3a7f98d3a869545cbed8",
      "filename": "gdb/testsuite/gdb.threads/forking-threads-plus-breakpoint.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.threads/forking-threads-plus-breakpoint.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.threads/forking-threads-plus-breakpoint.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/forking-threads-plus-breakpoint.exp?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -48,7 +48,7 @@ proc probe_displaced_stepping_support {} {\n \t# that breakpoint.\n \tgdb_test_no_output \"set debug displaced 1\"\n \tgdb_test_multiple \"next\" \"probe\" {\n-\t    -re \"displaced pc to.*$gdb_prompt $\" {\n+\t    -re \"prepared successfully .*$gdb_prompt $\" {\n \t\tpass \"supported\"\n \t    }\n \t    -re \".*$gdb_prompt $\" {"
    },
    {
      "sha": "11776616150045e69f78aae20ca9b270c96208c7",
      "filename": "gdb/testsuite/gdb.threads/non-stop-fair-events.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.threads/non-stop-fair-events.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/testsuite/gdb.threads/non-stop-fair-events.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/non-stop-fair-events.exp?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -69,7 +69,7 @@ set displaced_stepping_enabled 0\n set msg \"check displaced-stepping\"\n gdb_test_no_output \"set debug displaced 1\"\n gdb_test_multiple \"next\" $msg {\n-    -re \"displaced pc to.*$gdb_prompt $\" {\n+    -re \"prepared successfully .*$gdb_prompt $\" {\n \tset displaced_stepping_enabled 1\n     }\n     -re \".*$gdb_prompt $\" {"
    },
    {
      "sha": "856bdee97b387b31c8a7a238bf7481d7b36fe43c",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 62,
      "deletions": 6,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -362,10 +362,10 @@ step_over_chain_enqueue (struct thread_info **list_p, struct thread_info *tp)\n     }\n }\n \n-/* Remove TP from step-over chain LIST_P.  */\n+/* See gdbthread.h.  */\n \n-static void\n-thread_step_over_chain_remove (struct thread_info **list_p, struct thread_info *tp)\n+void\n+thread_step_over_chain_remove (thread_info **list_p, thread_info *tp)\n {\n   gdb_assert (tp->step_over_next != NULL);\n   gdb_assert (tp->step_over_prev != NULL);\n@@ -385,12 +385,20 @@ thread_step_over_chain_remove (struct thread_info **list_p, struct thread_info *\n \n /* See gdbthread.h.  */\n \n+thread_info *\n+thread_step_over_chain_next (thread_info *chain_head, thread_info *tp)\n+{\n+  thread_info *next = tp->step_over_next;\n+\n+  return next == chain_head ? NULL : next;\n+}\n+\n+/* See gdbthread.h.  */\n+\n struct thread_info *\n global_thread_step_over_chain_next (struct thread_info *tp)\n {\n-  struct thread_info *next = tp->step_over_next;\n-\n-  return (next == global_thread_step_over_chain_head ? NULL : next);\n+  return thread_step_over_chain_next (global_thread_step_over_chain_head, tp);\n }\n \n /* See gdbthread.h.  */\n@@ -403,17 +411,65 @@ thread_is_in_step_over_chain (struct thread_info *tp)\n \n /* See gdbthread.h.  */\n \n+int\n+thread_step_over_chain_length (thread_info *tp)\n+{\n+  if (tp == nullptr)\n+    return 0;\n+\n+  gdb_assert (thread_is_in_step_over_chain (tp));\n+\n+  int num = 1;\n+\n+  for (thread_info *iter = tp->step_over_next;\n+       iter != tp;\n+       iter = iter->step_over_next)\n+    ++num;\n+\n+  return num;\n+}\n+\n+/* See gdbthread.h.  */\n+\n void\n global_thread_step_over_chain_enqueue (struct thread_info *tp)\n {\n+  infrun_debug_printf (\"enqueueing thread %s in global step over chain\",\n+\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\n   step_over_chain_enqueue (&global_thread_step_over_chain_head, tp);\n }\n \n /* See gdbthread.h.  */\n \n+void\n+global_thread_step_over_chain_enqueue_chain (thread_info *chain_head)\n+{\n+  gdb_assert (chain_head->step_over_next != nullptr);\n+  gdb_assert (chain_head->step_over_prev != nullptr);\n+\n+  if (global_thread_step_over_chain_head == nullptr)\n+    global_thread_step_over_chain_head = chain_head;\n+  else\n+    {\n+      thread_info *global_last = global_thread_step_over_chain_head->step_over_prev;\n+      thread_info *chain_last = chain_head->step_over_prev;\n+\n+      chain_last->step_over_next = global_thread_step_over_chain_head;\n+      global_last->step_over_next = chain_head;\n+      global_thread_step_over_chain_head->step_over_prev = chain_last;\n+      chain_head->step_over_prev = global_last;\n+    }\n+}\n+\n+/* See gdbthread.h.  */\n+\n void\n global_thread_step_over_chain_remove (struct thread_info *tp)\n {\n+  infrun_debug_printf (\"removing thread %s from global step over chain\",\n+\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\n   thread_step_over_chain_remove (&global_thread_step_over_chain_head, tp);\n }\n "
    },
    {
      "sha": "5a8d7c7f8258b860f59cebe1b53b46ac2709b1f5",
      "filename": "gdb/tic6x-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/tic6x-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/tic6x-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -167,7 +167,7 @@ tic6x_uclinux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   /* Shared library handling.  */\n   set_solib_ops (gdbarch, &dsbt_so_ops);"
    },
    {
      "sha": "14cfafe33dec0d22018bf305e8d9701ab9b42157",
      "filename": "gdb/tilegx-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/tilegx-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/tilegx-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tilegx-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -111,7 +111,7 @@ tilegx_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   int arch_size = gdbarch_addr_bit (gdbarch);\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   tramp_frame_prepend_unwinder (gdbarch, &tilegx_linux_rt_sigframe);\n "
    },
    {
      "sha": "c2aeb8e9397b7df9eaaf60dbd97835103e4ec175",
      "filename": "gdb/xtensa-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/187b041e2514827b9d86190ed2471c4c7a352874/gdb/xtensa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/187b041e2514827b9d86190ed2471c4c7a352874/gdb/xtensa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xtensa-linux-tdep.c?ref=187b041e2514827b9d86190ed2471c4c7a352874",
      "patch": "@@ -110,7 +110,7 @@ xtensa_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n       set_gdbarch_num_pseudo_regs (gdbarch, tdep->num_pseudo_regs);\n     }\n \n-  linux_init_abi (info, gdbarch);\n+  linux_init_abi (info, gdbarch, false);\n \n   set_solib_svr4_fetch_link_map_offsets\n     (gdbarch, svr4_ilp32_fetch_link_map_offsets);"
    }
  ]
}