{
  "sha": "f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjM4YTI2ODBjMmYwNGRiNmVhYzRmZDg3MzgwY2QzY2Y3YmNiM2JjYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:09:51Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:19:23Z"
    },
    "message": "Use bool in ld\n\n\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n\t* configure.ac (elf_list_options, elf_shlib_list_options=false),\n\t(elf_plt_unwind_list_options=false): Replace FALSE with false,\n\tand TRUE with true.\n\t* emulparams/call_nop.sh, * emulparams/cet.sh,\n\t* emulparams/dynamic_undefined_weak.sh,\n\t* emulparams/elf32b4300.sh, * emulparams/elf32lm32.sh,\n\t* emulparams/elf32lr5900.sh, * emulparams/elf32lr5900n32.sh,\n\t* emulparams/elf32visium.sh, * emulparams/elf_x86_64.sh,\n\t* emulparams/extern_protected_data.sh, * emulparams/plt_unwind.sh,\n\t* emulparams/reloc_overflow.sh, * emulparams/static.sh,\n\t* emulparams/x86-64-lam.sh, * emultempl/aarch64elf.em,\n\t* emultempl/aix.em, * emultempl/alphaelf.em,\n\t* emultempl/armcoff.em, * emultempl/armelf.em,\n\t* emultempl/avrelf.em, * emultempl/beos.em, * emultempl/bfin.em,\n\t* emultempl/cr16elf.em, * emultempl/crxelf.em,\n\t* emultempl/cskyelf.em, * emultempl/elf.em, * emultempl/genelf.em,\n\t* emultempl/hppaelf.em, * emultempl/linux.em,\n\t* emultempl/m68hc1xelf.em, * emultempl/metagelf.em,\n\t* emultempl/mipself.em, * emultempl/mmix-elfnmmo.em,\n\t* emultempl/mmixelf.em, * emultempl/mmo.em, * emultempl/msp430.em,\n\t* emultempl/nios2elf.em, * emultempl/pdp11.em, * emultempl/pe.em,\n\t* emultempl/pep.em, * emultempl/ppc32elf.em,\n\t* emultempl/ppc64elf.em, * emultempl/rxelf.em,\n\t* emultempl/rxlinux.em, * emultempl/scoreelf.em,\n\t* emultempl/solaris2.em, * emultempl/spuelf.em,\n\t* emultempl/ticoff.em, * emultempl/v850elf.em, * emultempl/vms.em,\n\t* emultempl/xtensaelf.em, * emultempl/z80.em, * ld.h,\n\t* ldbuildid.c, * ldbuildid.h, * ldcref.c, * ldctor.c, * ldctor.h,\n\t* ldelf.c, * ldelf.h, * ldelfgen.c, * ldelfgen.h, * ldemul.c,\n\t* ldemul.h, * ldexp.c, * ldexp.h, * ldfile.c, * ldfile.h,\n\t* ldgram.y, * ldlang.c, * ldlang.h, * ldmain.c, * ldmain.h,\n\t* ldmisc.c, * ldmisc.h, * ldwrite.c, * lexsup.c, * mri.c,\n\t* pe-dll.c, * pe-dll.h, * pep-dll.h, * plugin.c, * plugin.h,\n\t* testplug.c, * testplug2.c, * testplug3.c, * testplug4.c: Replace\n\tbfd_boolean with bool, FALSE with false, and TRUE with true.\n\t* configure: Regenerate.",
    "tree": {
      "sha": "38d5b486b39b163f1581abf67889d191a8e5cc9f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/38d5b486b39b163f1581abf67889d191a8e5cc9f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/015dc7e1f8a971692a910e6cfc64faf9216e75c3"
    }
  ],
  "stats": {
    "total": 3103,
    "additions": 1571,
    "deletions": 1532
  },
  "files": [
    {
      "sha": "d2c3c04745c0e784e00f85d8d74b402f0f103ff6",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -1,3 +1,43 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n+\t* configure.ac (elf_list_options, elf_shlib_list_options=false),\n+\t(elf_plt_unwind_list_options=false): Replace FALSE with false,\n+\tand TRUE with true.\n+\t* emulparams/call_nop.sh, * emulparams/cet.sh,\n+\t* emulparams/dynamic_undefined_weak.sh,\n+\t* emulparams/elf32b4300.sh, * emulparams/elf32lm32.sh,\n+\t* emulparams/elf32lr5900.sh, * emulparams/elf32lr5900n32.sh,\n+\t* emulparams/elf32visium.sh, * emulparams/elf_x86_64.sh,\n+\t* emulparams/extern_protected_data.sh, * emulparams/plt_unwind.sh,\n+\t* emulparams/reloc_overflow.sh, * emulparams/static.sh,\n+\t* emulparams/x86-64-lam.sh, * emultempl/aarch64elf.em,\n+\t* emultempl/aix.em, * emultempl/alphaelf.em,\n+\t* emultempl/armcoff.em, * emultempl/armelf.em,\n+\t* emultempl/avrelf.em, * emultempl/beos.em, * emultempl/bfin.em,\n+\t* emultempl/cr16elf.em, * emultempl/crxelf.em,\n+\t* emultempl/cskyelf.em, * emultempl/elf.em, * emultempl/genelf.em,\n+\t* emultempl/hppaelf.em, * emultempl/linux.em,\n+\t* emultempl/m68hc1xelf.em, * emultempl/metagelf.em,\n+\t* emultempl/mipself.em, * emultempl/mmix-elfnmmo.em,\n+\t* emultempl/mmixelf.em, * emultempl/mmo.em, * emultempl/msp430.em,\n+\t* emultempl/nios2elf.em, * emultempl/pdp11.em, * emultempl/pe.em,\n+\t* emultempl/pep.em, * emultempl/ppc32elf.em,\n+\t* emultempl/ppc64elf.em, * emultempl/rxelf.em,\n+\t* emultempl/rxlinux.em, * emultempl/scoreelf.em,\n+\t* emultempl/solaris2.em, * emultempl/spuelf.em,\n+\t* emultempl/ticoff.em, * emultempl/v850elf.em, * emultempl/vms.em,\n+\t* emultempl/xtensaelf.em, * emultempl/z80.em, * ld.h,\n+\t* ldbuildid.c, * ldbuildid.h, * ldcref.c, * ldctor.c, * ldctor.h,\n+\t* ldelf.c, * ldelf.h, * ldelfgen.c, * ldelfgen.h, * ldemul.c,\n+\t* ldemul.h, * ldexp.c, * ldexp.h, * ldfile.c, * ldfile.h,\n+\t* ldgram.y, * ldlang.c, * ldlang.h, * ldmain.c, * ldmain.h,\n+\t* ldmisc.c, * ldmisc.h, * ldwrite.c, * lexsup.c, * mri.c,\n+\t* pe-dll.c, * pe-dll.h, * pep-dll.h, * plugin.c, * plugin.h,\n+\t* testplug.c, * testplug2.c, * testplug3.c, * testplug4.c: Replace\n+\tbfd_boolean with bool, FALSE with false, and TRUE with true.\n+\t* configure: Regenerate.\n+\n 2021-03-31  Alan Modra  <amodra@gmail.com>\n \n \t* elf-hints-local.h: Include stdint.h in place of bfd_stdint.h."
    },
    {
      "sha": "9eacaddab6b5c900971c554d12d306bddb71c5f7",
      "filename": "ld/configure",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/configure?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -17613,16 +17613,16 @@ _ACEOF\n   fi\n fi\n \n-elf_list_options=FALSE\n-elf_shlib_list_options=FALSE\n-elf_plt_unwind_list_options=FALSE\n+elf_list_options=false\n+elf_shlib_list_options=false\n+elf_plt_unwind_list_options=false\n for targ_alias in `echo $target_alias $enable_targets | sed 's/,/ /g'`\n do\n   if test \"$targ_alias\" = \"all\"; then\n     all_targets=true\n-    elf_list_options=TRUE\n-    elf_shlib_list_options=TRUE\n-    elf_plt_unwind_list_options=TRUE\n+    elf_list_options=true\n+    elf_shlib_list_options=true\n+    elf_plt_unwind_list_options=true\n   else\n     # Canonicalize the secondary target names.\n     result=`$ac_config_sub $targ_alias 2>/dev/null`\n@@ -17658,25 +17658,25 @@ do\n tdir_$i=$result\"\n \t  case \"${i}\" in\n \t  *elf*)\n-\t    elf_list_options=TRUE\n+\t    elf_list_options=true\n \t    ;;\n \t  *)\n \t    if $GREP \"TEMPLATE_NAME=elf\" ${srcdir}/emulparams/${i}.sh >/dev/null 2>/dev/null; then\n-\t      elf_list_options=TRUE\n+\t      elf_list_options=true\n \t    fi\n \t    ;;\n \t  esac\n-\t  if test \"$elf_list_options\" = \"TRUE\"; then\n+\t  if test \"$elf_list_options\" = \"true\"; then\n \t    source_sh()\n \t    {\n \t      . $1\n \t    }\n \t    source_sh ${srcdir}/emulparams/${i}.sh\n \t    if test x${GENERATE_SHLIB_SCRIPT} = xyes; then\n-\t      elf_shlib_list_options=TRUE\n+\t      elf_shlib_list_options=true\n \t    fi\n \t    if test x${PLT_UNWIND} = xyes; then\n-\t      elf_plt_unwind_list_options=TRUE\n+\t      elf_plt_unwind_list_options=true\n \t    fi\n \t  fi\n \t  ;;"
    },
    {
      "sha": "19a5df12c95e3d094da1c1328542894aa2ac28f4",
      "filename": "ld/configure.ac",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/configure.ac?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -359,16 +359,16 @@ if test x${want64} = xfalse; then\n   fi\n fi\n \n-elf_list_options=FALSE\n-elf_shlib_list_options=FALSE\n-elf_plt_unwind_list_options=FALSE\n+elf_list_options=false\n+elf_shlib_list_options=false\n+elf_plt_unwind_list_options=false\n for targ_alias in `echo $target_alias $enable_targets | sed 's/,/ /g'`\n do\n   if test \"$targ_alias\" = \"all\"; then\n     all_targets=true\n-    elf_list_options=TRUE\n-    elf_shlib_list_options=TRUE\n-    elf_plt_unwind_list_options=TRUE\n+    elf_list_options=true\n+    elf_shlib_list_options=true\n+    elf_plt_unwind_list_options=true\n   else\n     # Canonicalize the secondary target names.\n     result=`$ac_config_sub $targ_alias 2>/dev/null`\n@@ -404,25 +404,25 @@ do\n tdir_$i=$result\"\n \t  case \"${i}\" in\n \t  *elf*)\n-\t    elf_list_options=TRUE\n+\t    elf_list_options=true\n \t    ;;\n \t  *)\n \t    if $GREP \"TEMPLATE_NAME=elf\" ${srcdir}/emulparams/${i}.sh >/dev/null 2>/dev/null; then\n-\t      elf_list_options=TRUE\n+\t      elf_list_options=true\n \t    fi\n \t    ;;\n \t  esac\n-\t  if test \"$elf_list_options\" = \"TRUE\"; then\n+\t  if test \"$elf_list_options\" = \"true\"; then\n \t    source_sh()\n \t    {\n \t      . $1\n \t    }\n \t    source_sh ${srcdir}/emulparams/${i}.sh\n \t    if test x${GENERATE_SHLIB_SCRIPT} = xyes; then\n-\t      elf_shlib_list_options=TRUE\n+\t      elf_shlib_list_options=true\n \t    fi\n \t    if test x${PLT_UNWIND} = xyes; then\n-\t      elf_plt_unwind_list_options=TRUE\n+\t      elf_plt_unwind_list_options=true\n \t    fi\n \t  fi\n \t  ;;"
    },
    {
      "sha": "2c3c305f0e8b51ba730f7b08cc5964cc90eaaf1c",
      "filename": "ld/emulparams/call_nop.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/call_nop.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/call_nop.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/call_nop.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -7,12 +7,12 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='\n \t{\n \t  if (strcmp (optarg + 9, \"prefix-addr\") == 0)\n \t    {\n-\t      params.call_nop_as_suffix = FALSE;\n+\t      params.call_nop_as_suffix = false;\n \t      params.call_nop_byte = 0x67;\n \t    }\n \t  else if (strcmp (optarg + 9, \"suffix-nop\") == 0)\n \t    {\n-\t      params.call_nop_as_suffix = TRUE;\n+\t      params.call_nop_as_suffix = true;\n \t      params.call_nop_byte = 0x90;\n \t    }\n \t  else if (strncmp (optarg + 9, \"prefix-\", 7) == 0)\n@@ -22,7 +22,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='\n \t      if (*end)\n \t\teinfo (_(\"%F%P: invalid number for -z call-nop=prefix-: %s\\n\"),\n \t\t       optarg + 16);\n-\t      params.call_nop_as_suffix = FALSE;\n+\t      params.call_nop_as_suffix = false;\n \t    }\n \t  else if (strncmp (optarg + 9, \"suffix-\", 7) == 0)\n \t    {\n@@ -31,7 +31,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_CALL_NOP='\n \t      if (*end)\n \t\teinfo (_(\"%F%P: invalid number for -z call-nop=suffix-: %s\\n\"),\n \t\t       optarg + 16);\n-\t      params.call_nop_as_suffix = TRUE;\n+\t      params.call_nop_as_suffix = true;\n \t    }\n \t  else\n \t    einfo (_(\"%F%P: unsupported option: -z %s\\n\"), optarg);"
    },
    {
      "sha": "2c62799450176658e52aa980567eacb98a2f58a0",
      "filename": "ld/emulparams/cet.sh",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/cet.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/cet.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/cet.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -11,11 +11,11 @@ PARSE_AND_LIST_OPTIONS_CET='\n '\n PARSE_AND_LIST_ARGS_CASE_Z_CET='\n       else if (strcmp (optarg, \"ibtplt\") == 0)\n-\tparams.ibtplt = TRUE;\n+\tparams.ibtplt = true;\n       else if (strcmp (optarg, \"ibt\") == 0)\n-\tparams.ibt = TRUE;\n+\tparams.ibt = true;\n       else if (strcmp (optarg, \"shstk\") == 0)\n-\tparams.shstk = TRUE;\n+\tparams.shstk = true;\n       else if (strncmp (optarg, \"cet-report=\", 11) == 0)\n \t{\n \t  if (strcmp (optarg + 11, \"none\") == 0)"
    },
    {
      "sha": "21393d40d26572c65ac051c0a0dbc4cba6c88fd7",
      "filename": "ld/emulparams/dynamic_undefined_weak.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/dynamic_undefined_weak.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/dynamic_undefined_weak.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/dynamic_undefined_weak.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -6,9 +6,9 @@ PARSE_AND_LIST_OPTIONS_DYNAMIC_UNDEFINED_WEAK='\n \n PARSE_AND_LIST_ARGS_CASE_Z_DYNAMIC_UNDEFINED_WEAK='\n       else if (strcmp (optarg, \"dynamic-undefined-weak\") == 0)\n-\tlink_info.dynamic_undefined_weak = TRUE;\n+\tlink_info.dynamic_undefined_weak = true;\n       else if (strcmp (optarg, \"nodynamic-undefined-weak\") == 0)\n-\tlink_info.dynamic_undefined_weak = FALSE;\n+\tlink_info.dynamic_undefined_weak = false;\n '\n \n PARSE_AND_LIST_OPTIONS=\"$PARSE_AND_LIST_OPTIONS $PARSE_AND_LIST_OPTIONS_DYNAMIC_UNDEFINED_WEAK\""
    },
    {
      "sha": "4b1921c229760643ea08b02bc02aad029478fa13",
      "filename": "ld/emulparams/elf32b4300.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32b4300.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32b4300.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf32b4300.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -6,4 +6,4 @@ source_sh ${srcdir}/emulparams/elf32bmip.sh\n TEXT_START_ADDR=0xa0020000\n unset SHLIB_TEXT_START_ADDR\n EXECUTABLE_SYMBOLS='_DYNAMIC_LINK = 0;'\n-DYNAMIC_LINK=FALSE\n+DYNAMIC_LINK=false"
    },
    {
      "sha": "fde662907c788555306855d0cd4411e180ee5e47",
      "filename": "ld/emulparams/elf32lm32.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lm32.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lm32.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf32lm32.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -6,5 +6,5 @@ MAXPAGESIZE=0x1000\n EMBEDDED=yes\n TEMPLATE_NAME=elf\n TEXT_START_ADDR=0x0000\n-DYNAMIC_LINK=FALSE\n+DYNAMIC_LINK=false\n ALIGNMENT=4"
    },
    {
      "sha": "7b725693de9c3f3a72869e87069c58df2192406e",
      "filename": "ld/emulparams/elf32lr5900.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lr5900.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lr5900.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf32lr5900.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -9,7 +9,7 @@ ARCH=mips:5900\n MACHINE=\n MAXPAGESIZE=128\n EMBEDDED=yes\n-DYNAMIC_LINK=FALSE\n+DYNAMIC_LINK=false\n \n unset DATA_ADDR\n SHLIB_TEXT_START_ADDR=0"
    },
    {
      "sha": "29209dfaa6cd22f760fbf7cde5a03cec38fe1ec8",
      "filename": "ld/emulparams/elf32lr5900n32.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lr5900n32.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32lr5900n32.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf32lr5900n32.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -9,7 +9,7 @@ ARCH=mips:5900\n MACHINE=\n MAXPAGESIZE=128\n EMBEDDED=yes\n-DYNAMIC_LINK=FALSE\n+DYNAMIC_LINK=false\n \n OTHER_TEXT_SECTIONS='*(.mips16.fn.*) *(.mips16.call.*)'\n OTHER_SECTIONS=\""
    },
    {
      "sha": "e8b879c82c9f81ed5f909bf1ebd99ea02111d05e",
      "filename": "ld/emulparams/elf32visium.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32visium.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf32visium.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf32visium.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -6,4 +6,4 @@ NONPAGED_TEXT_START_ADDR=0x10000\n ARCH=visium\n MACHINE=\n TEMPLATE_NAME=elf\n-DYNAMIC_LINK=FALSE\n+DYNAMIC_LINK=false"
    },
    {
      "sha": "48d0974711bdebfed2168f086b75a23e237521a1",
      "filename": "ld/emulparams/elf_x86_64.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf_x86_64.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/elf_x86_64.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/elf_x86_64.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -52,7 +52,7 @@ case \"$target\" in\n '\n \tPARSE_AND_LIST_ARGS_CASE_Z_BNDPLT='\n       else if (strcmp (optarg, \"bndplt\") == 0)\n-\tparams.bndplt = TRUE;\n+\tparams.bndplt = true;\n '\n \tPARSE_AND_LIST_OPTIONS=\"$PARSE_AND_LIST_OPTIONS $PARSE_AND_LIST_OPTIONS_BNDPLT\"\n \tPARSE_AND_LIST_ARGS_CASE_Z=\"$PARSE_AND_LIST_ARGS_CASE_Z $PARSE_AND_LIST_ARGS_CASE_Z_BNDPLT\""
    },
    {
      "sha": "30f3d1cdee5c836f13ed6e8034083b01c96e61f8",
      "filename": "ld/emulparams/extern_protected_data.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/extern_protected_data.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/extern_protected_data.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/extern_protected_data.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -5,7 +5,7 @@ PARSE_AND_LIST_OPTIONS_NOEXTEN_PROTECTED_DATA='\n \n PARSE_AND_LIST_ARGS_CASE_Z_NOEXTEN_PROTECTED_DATA='\n       else if (strcmp (optarg, \"noextern-protected-data\") == 0)\n-\tlink_info.extern_protected_data = FALSE;\n+\tlink_info.extern_protected_data = false;\n '\n \n "
    },
    {
      "sha": "ab16156415e8dd98d3b1ba949566ce0d8d643b8d",
      "filename": "ld/emulparams/plt_unwind.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/plt_unwind.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/plt_unwind.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/plt_unwind.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -14,10 +14,10 @@ PARSE_AND_LIST_LONGOPTS='\n \n PARSE_AND_LIST_ARGS_CASES='\n     case OPTION_LD_GENERATED_UNWIND_INFO:\n-      link_info.no_ld_generated_unwind_info = FALSE;\n+      link_info.no_ld_generated_unwind_info = false;\n       break;\n \n     case OPTION_NO_LD_GENERATED_UNWIND_INFO:\n-      link_info.no_ld_generated_unwind_info = TRUE;\n+      link_info.no_ld_generated_unwind_info = true;\n       break;\n '"
    },
    {
      "sha": "248143711c967005682aaf2e5fe6da16fe53adc8",
      "filename": "ld/emulparams/reloc_overflow.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/reloc_overflow.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/reloc_overflow.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/reloc_overflow.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -4,7 +4,7 @@ PARSE_AND_LIST_OPTIONS_RELOC_OVERFLOW='\n '\n PARSE_AND_LIST_ARGS_CASE_Z_RELOC_OVERFLOW='\n       else if (strcmp (optarg, \"noreloc-overflow\") == 0)\n-\tparams.no_reloc_overflow_check = TRUE;\n+\tparams.no_reloc_overflow_check = true;\n '\n \n PARSE_AND_LIST_OPTIONS=\"$PARSE_AND_LIST_OPTIONS $PARSE_AND_LIST_OPTIONS_RELOC_OVERFLOW\""
    },
    {
      "sha": "295251e38e9053fc2ff951545530f409ffd04d55",
      "filename": "ld/emulparams/static.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/static.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/static.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/static.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -1,12 +1,12 @@\n PARSE_AND_LIST_ARGS_CASES=\"$PARSE_AND_LIST_ARGS_CASES\n     case OPTION_DYNAMIC_LINKER:\n-      params.has_dynamic_linker = TRUE;\n-      return FALSE;\n+      params.has_dynamic_linker = true;\n+      return false;\n \n     case OPTION_NON_SHARED:\n       /* Check if -static is passed at command-line before all input\n \t files.  */\n       if (!lang_has_input_file)\n-\tparams.static_before_all_inputs = TRUE;\n-      return FALSE;\n+\tparams.static_before_all_inputs = true;\n+      return false;\n \""
    },
    {
      "sha": "fab42ff1df2b6ebc3f07314a07c1aaae71ef22db",
      "filename": "ld/emulparams/x86-64-lam.sh",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/x86-64-lam.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emulparams/x86-64-lam.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/x86-64-lam.sh?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -15,7 +15,7 @@ PARSE_AND_LIST_OPTIONS_LAM='\n '\n PARSE_AND_LIST_ARGS_CASE_Z_LAM='\n       else if (strcmp (optarg, \"lam-u48\") == 0)\n-\tparams.lam_u48 = TRUE;\n+\tparams.lam_u48 = true;\n       else if (strncmp (optarg, \"lam-u48-report=\", 15) == 0)\n \t{\n \t  if (strcmp (optarg + 15, \"none\") == 0)\n@@ -29,7 +29,7 @@ PARSE_AND_LIST_ARGS_CASE_Z_LAM='\n \t\t   optarg + 15);\n \t}\n       else if (strcmp (optarg, \"lam-u57\") == 0)\n-\tparams.lam_u57 = TRUE;\n+\tparams.lam_u57 = true;\n       else if (strncmp (optarg, \"lam-u57-report=\", 15) == 0)\n \t{\n \t  if (strcmp (optarg + 15, \"none\") == 0)"
    },
    {
      "sha": "4e1d8f8a240a0d775c25b7b98ff1e1716281ee49",
      "filename": "ld/emultempl/aarch64elf.em",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/aarch64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/aarch64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aarch64elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -43,10 +43,10 @@ gld${EMULATION_NAME}_before_parse (void)\n #ifndef TARGET_\t\t\t/* I.e., if not generic.  */\n   ldfile_set_output_arch (\"`echo ${ARCH}`\", bfd_arch_unknown);\n #endif /* not TARGET_ */\n-  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};\n-  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo TRUE ; else echo FALSE ; fi`;\n-  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo TRUE ; else echo FALSE ; fi`;\n-  link_info.check_relocs_after_open_input = TRUE;\n+  input_flags.dynamic = ${DYNAMIC_LINK-true};\n+  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo true ; else echo false ; fi`;\n+  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo true ; else echo false ; fi`;\n+  link_info.check_relocs_after_open_input = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF\n@@ -94,11 +94,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -136,7 +136,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t after its associated input section.  */\n \t      *(info->add.tail) = l->header.next;\n \t      l->header.next = info->add.head;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -157,7 +157,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -213,7 +213,7 @@ gldaarch64_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n "
    },
    {
      "sha": "8ea3c165a70182e4714e024d0310965cc560461b",
      "filename": "ld/emultempl/aix.em",
      "status": "modified",
      "additions": 46,
      "deletions": 46,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/aix.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/aix.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aix.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -58,7 +58,7 @@ fragment <<EOF\n #include \"libxcoff.h\"\n #include \"xcofflink.h\"\n \n-static void gld${EMULATION_NAME}_read_file (const char *, bfd_boolean);\n+static void gld${EMULATION_NAME}_read_file (const char *, bool);\n static void gld${EMULATION_NAME}_free (void *);\n static void gld${EMULATION_NAME}_find_relocs (lang_statement_union_type *);\n static void gld${EMULATION_NAME}_find_exp_assignment (etree_type *);\n@@ -145,8 +145,8 @@ gld${EMULATION_NAME}_before_parse (void)\n {\n   ldfile_set_output_arch (\"${OUTPUT_ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n \n-  input_flags.dynamic = TRUE;\n-  config.has_shared = TRUE;\n+  input_flags.dynamic = true;\n+  config.has_shared = true;\n \n   /* The link_info.[init|fini]_functions are initialized in ld/lexsup.c.\n      Override them here so we can use the link_info.init_function as a\n@@ -275,7 +275,7 @@ gld${EMULATION_NAME}_add_options\n   memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_parse_args (int argc, char **argv)\n {\n   int indx;\n@@ -300,7 +300,7 @@ gld${EMULATION_NAME}_parse_args (int argc, char **argv)\n \t    }\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Helper for option '-f', which specify a list of input files.\n@@ -373,7 +373,7 @@ read_file_list (const char *filename)\n   fclose (f);\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   bfd_signed_vma val;\n@@ -382,7 +382,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case 0:\n       /* Long option which just sets a flag.  */\n@@ -423,7 +423,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n \t ignore the AIX option, because gcc passes it to the linker.  */\n       val = bfd_scan_vma (optarg, &end, 0);\n       if (*end != '\\0')\n-\treturn FALSE;\n+\treturn false;\n       lang_section_start (\".text\", exp_intop (val), NULL);\n       break;\n \n@@ -468,7 +468,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n \n     case OPTION_AUTOIMP:\n-      link_info.static_link = FALSE;\n+      link_info.static_link = false;\n       break;\n \n     case OPTION_ERNOTOK:\n@@ -492,7 +492,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n \n     case OPTION_EXPORT:\n-      gld${EMULATION_NAME}_read_file (optarg, FALSE);\n+      gld${EMULATION_NAME}_read_file (optarg, false);\n       break;\n \n     case OPTION_IMPORT:\n@@ -545,7 +545,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n \n     case OPTION_NOAUTOIMP:\n-      link_info.static_link = TRUE;\n+      link_info.static_link = true;\n       break;\n \n     case OPTION_NOEXPALL:\n@@ -559,7 +559,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n \n     case OPTION_NOSTRCMPCT:\n-      link_info.traditional_format = TRUE;\n+      link_info.traditional_format = true;\n       break;\n \n     case OPTION_PD:\n@@ -608,11 +608,11 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n \n     case OPTION_STRCMPCT:\n-      link_info.traditional_format = FALSE;\n+      link_info.traditional_format = false;\n       break;\n \n     case OPTION_UNIX:\n-      unix_ld = TRUE;\n+      unix_ld = true;\n       break;\n \n     case OPTION_32:\n@@ -637,24 +637,24 @@ gld${EMULATION_NAME}_handle_option (int optc)\n \n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is called when an input file can not be recognized as a BFD\n    object or an archive.  If the file starts with #!, we must treat it\n    as an import file.  This is for AIX compatibility.  */\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry)\n {\n   FILE *e;\n-  bfd_boolean ret;\n+  bool ret;\n \n   e = fopen (entry->filename, FOPEN_RT);\n   if (e == NULL)\n-    return FALSE;\n+    return false;\n \n-  ret = FALSE;\n+  ret = false;\n \n   if (getc (e) == '#' && getc (e) == '!')\n     {\n@@ -669,8 +669,8 @@ gld${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry)\n \tflpp = &(*flpp)->next;\n       *flpp = n;\n \n-      ret = TRUE;\n-      entry->flags.loaded = TRUE;\n+      ret = true;\n+      entry->flags.loaded = true;\n     }\n \n   fclose (e);\n@@ -744,12 +744,12 @@ gld${EMULATION_NAME}_before_allocation (void)\n \n   /* Handle the import and export files, if any.  */\n   for (fl = import_files; fl != NULL; fl = fl->next)\n-    gld${EMULATION_NAME}_read_file (fl->name, TRUE);\n+    gld${EMULATION_NAME}_read_file (fl->name, true);\n   for (el = export_symbols; el != NULL; el = el->next)\n     {\n       struct bfd_link_hash_entry *h;\n \n-      h = bfd_link_hash_lookup (link_info.hash, el->name, FALSE, FALSE, FALSE);\n+      h = bfd_link_hash_lookup (link_info.hash, el->name, false, false, false);\n       if (h == NULL)\n \teinfo (_(\"%F%P: bfd_link_hash_lookup of export symbol failed: %E\\n\"));\n       if (!bfd_xcoff_export_symbol (link_info.output_bfd, &link_info, h))\n@@ -833,8 +833,8 @@ gld${EMULATION_NAME}_before_allocation (void)\n \n   /* Let the XCOFF backend set up the .loader section.  */\n   if (!bfd_xcoff_size_dynamic_sections\n-      (link_info.output_bfd, &link_info, libpath, entry_symbol.name, file_align,\n-       maxstack, maxdata, gc && !unix_ld,\n+      (link_info.output_bfd, &link_info, libpath, entry_symbol.name,\n+       file_align, maxstack, maxdata, gc && !unix_ld,\n        modtype, textro, flags, special_sections, rtld))\n     einfo (_(\"%F%P: failed to set dynamic section sizes: %E\\n\"));\n \n@@ -847,7 +847,7 @@ gld${EMULATION_NAME}_before_allocation (void)\n       lang_statement_union_type **pls;\n       lang_input_section_type *is;\n       const char *oname;\n-      bfd_boolean start;\n+      bool start;\n \n       sec = special_sections[i];\n       if (sec == NULL)\n@@ -907,32 +907,32 @@ gld${EMULATION_NAME}_before_allocation (void)\n \tcase XCOFF_SPECIAL_SECTION_TEXT:\n \t  /* _text */\n \t  oname = \".text\";\n-\t  start = TRUE;\n+\t  start = true;\n \t  break;\n \n \tcase XCOFF_SPECIAL_SECTION_ETEXT:\n \t  /* _etext */\n \t  oname = \".text\";\n-\t  start = FALSE;\n+\t  start = false;\n \t  break;\n \n \tcase XCOFF_SPECIAL_SECTION_DATA:\n \t  /* _data */\n \t  oname = \".data\";\n-\t  start = TRUE;\n+\t  start = true;\n \t  break;\n \n \tcase XCOFF_SPECIAL_SECTION_EDATA:\n \t  /* _edata */\n \t  oname = \".data\";\n-\t  start = FALSE;\n+\t  start = false;\n \t  break;\n \n \tcase XCOFF_SPECIAL_SECTION_END:\n \tcase XCOFF_SPECIAL_SECTION_END2:\n \t  /* _end and end */\n \t  oname = \".bss\";\n-\t  start = FALSE;\n+\t  start = false;\n \t  break;\n \t}\n \n@@ -983,7 +983,7 @@ gld${EMULATION_NAME}_before_allocation (void)\n \t{\n \t  expld.phase = lang_mark_phase_enum;\n \t  expld.dataseg.phase = exp_seg_none;\n-\t  one_lang_size_sections_pass (NULL, FALSE);\n+\t  one_lang_size_sections_pass (NULL, false);\n \t  lang_reset_memory_regions ();\n \t}\n \n@@ -1129,13 +1129,13 @@ is_syscall (char *input, unsigned int *flag)\n    this is called by the handle_option emulation routine.  */\n \n static void\n-gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)\n+gld${EMULATION_NAME}_read_file (const char *filename, bool import)\n {\n   struct obstack *o;\n   FILE *f;\n   int lineno;\n   int c;\n-  bfd_boolean keep;\n+  bool keep;\n   const char *imppath;\n   const char *impfile;\n   const char *impmember;\n@@ -1151,7 +1151,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)\n       return;\n     }\n \n-  keep = FALSE;\n+  keep = false;\n \n   imppath = NULL;\n   impfile = NULL;\n@@ -1218,7 +1218,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)\n \t      char *start;\n \n \t      (void) obstack_finish (o);\n-\t      keep = TRUE;\n+\t      keep = true;\n \t      start = s;\n \t      while (!ISSPACE (*s) && *s != '(' && *s != '\\0')\n \t\t++s;\n@@ -1314,7 +1314,7 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)\n \t    {\n \t      struct export_symbol_list *n;\n \n-\t      ldlang_add_undef (symname, TRUE);\n+\t      ldlang_add_undef (symname, true);\n \t      n = ((struct export_symbol_list *)\n \t\t   xmalloc (sizeof (struct export_symbol_list)));\n \t      n->next = export_symbols;\n@@ -1323,8 +1323,8 @@ gld${EMULATION_NAME}_read_file (const char *filename, bfd_boolean import)\n \t    }\n \t  else\n \t    {\n-\t      h = bfd_link_hash_lookup (link_info.hash, symname, FALSE, FALSE,\n-\t\t\t\t\tTRUE);\n+\t      h = bfd_link_hash_lookup (link_info.hash, symname, false, false,\n+\t\t\t\t\ttrue);\n \t      if (h == NULL || h->type == bfd_link_hash_new)\n \t\t{\n \t\t  /* We can just ignore attempts to import an unreferenced\n@@ -1403,7 +1403,7 @@ gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)\n     case etree_provide:\n     case etree_provided:\n       h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,\n-\t\t\t\tFALSE, FALSE, FALSE);\n+\t\t\t\tfalse, false, false);\n       if (h == NULL)\n \tbreak;\n       /* Fall through.  */\n@@ -1543,15 +1543,15 @@ gld${EMULATION_NAME}_set_output_arch (void)\n   ldfile_output_machine_name = bfd_printable_name (link_info.output_bfd);\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_open_dynamic_archive (const char *arch,\n \t\t\t\t\t   search_dirs_type *search,\n \t\t\t\t\t   lang_input_statement_type *entry)\n {\n   char *path;\n \n   if (!entry->flags.maybe_archive)\n-    return FALSE;\n+    return false;\n \n   if (entry->flags.full_name_provided)\n     path = concat (search->name, \"/\", entry->filename,\n@@ -1563,16 +1563,16 @@ gld${EMULATION_NAME}_open_dynamic_archive (const char *arch,\n   if (!ldfile_try_open_bfd (path, entry))\n     {\n       free (path);\n-      return FALSE;\n+      return false;\n     }\n   /* Don't include the searched directory in the import path.  */\n   bfd_xcoff_set_archive_import_path (&link_info, entry->the_bfd,\n \t\t\t\t     path + strlen (search->name) + 1);\n   entry->filename = path;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_print_symbol (struct bfd_link_hash_entry *hash_entry,\n \t\t\t\t   void *ptr)\n {\n@@ -1599,7 +1599,7 @@ gld${EMULATION_NAME}_print_symbol (struct bfd_link_hash_entry *hash_entry,\n       minfo (\"             %pT\\n\", hash_entry->root.string);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = {"
    },
    {
      "sha": "0e2416cd69f97e68d1501627914e86e4295e4834",
      "filename": "ld/emultempl/alphaelf.em",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/alphaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/alphaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/alphaelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -28,9 +28,9 @@ fragment <<EOF\n #include \"elf/alpha.h\"\n #include \"elf-bfd.h\"\n \n-static bfd_boolean limit_32bit;\n+static bool limit_32bit;\n \n-extern bfd_boolean elf64_alpha_use_secureplt;\n+extern bool elf64_alpha_use_secureplt;\n \n \n /* Set the start address as in the Tru64 ld.  */\n@@ -138,10 +138,10 @@ PARSE_AND_LIST_ARGS_CASES='\n       limit_32bit = 1;\n       break;\n     case OPTION_SECUREPLT:\n-      elf64_alpha_use_secureplt = TRUE;\n+      elf64_alpha_use_secureplt = true;\n       break;\n     case OPTION_NO_SECUREPLT:\n-      elf64_alpha_use_secureplt = FALSE;\n+      elf64_alpha_use_secureplt = false;\n       break;\n '\n "
    },
    {
      "sha": "57b17a3f1975f96bcb6acc5e1fcd5b5e5463c0fe",
      "filename": "ld/emultempl/armcoff.em",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/armcoff.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/armcoff.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armcoff.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -74,13 +74,13 @@ gld${EMULATION_NAME}_list_options (FILE *file)\n   fprintf (file, _(\"  --thumb-entry=<sym>         Set the entry point to be Thumb symbol <sym>\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_SUPPORT_OLD_CODE:\n       support_old_code = 1;\n@@ -91,7 +91,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n static void\n@@ -164,7 +164,7 @@ gld${EMULATION_NAME}_finish (void)\n       struct bfd_link_hash_entry * h;\n \n       h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n \n       if (h != (struct bfd_link_hash_entry *) NULL\n \t  && (h->type == bfd_link_hash_defined"
    },
    {
      "sha": "bcb60d252ce31db45e25406d140d7fdcdaf00fa1",
      "filename": "ld/emultempl/armelf.em",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/armelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/armelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -56,10 +56,10 @@ gld${EMULATION_NAME}_before_parse (void)\n #ifndef TARGET_\t\t\t/* I.e., if not generic.  */\n   ldfile_set_output_arch (\"`echo ${ARCH}`\", bfd_arch_unknown);\n #endif /* not TARGET_ */\n-  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};\n-  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo TRUE ; else echo FALSE ; fi`;\n-  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo TRUE ; else echo FALSE ; fi`;\n-  link_info.check_relocs_after_open_input = TRUE;\n+  input_flags.dynamic = ${DYNAMIC_LINK-true};\n+  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo true ; else echo false ; fi`;\n+  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo true ; else echo false ; fi`;\n+  link_info.check_relocs_after_open_input = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF\n@@ -149,11 +149,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -191,7 +191,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t after its associated input section.  */\n \t      *(info->add.tail) = l->header.next;\n \t      l->header.next = info->add.head;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -212,7 +212,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -284,7 +284,7 @@ gldarm_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n \n@@ -457,7 +457,7 @@ gld${EMULATION_NAME}_finish (void)\n   if (params.thumb_entry_symbol)\n     {\n       h = bfd_link_hash_lookup (link_info.hash, params.thumb_entry_symbol,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n     }\n   else\n     {\n@@ -467,7 +467,7 @@ gld${EMULATION_NAME}_finish (void)\n \treturn;\n \n       h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n       eh = (struct elf_link_hash_entry *)h;\n       if (!h || ARM_GET_SYM_BRANCH_TYPE (eh->target_internal)\n \t\t!= ST_BRANCH_TO_THUMB)"
    },
    {
      "sha": "eb01c8f2e0ac2c9b7dd6425b91be4e226904d68b",
      "filename": "ld/emultempl/avrelf.em",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/avrelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/avrelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/avrelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -39,10 +39,10 @@ static asection *avr_stub_section;\n /* Variables set by the command-line parameters and transferred\n    to the bfd without use of global shared variables.  */\n \n-static bfd_boolean avr_no_stubs = FALSE;\n-static bfd_boolean avr_debug_relax = FALSE;\n-static bfd_boolean avr_debug_stubs = FALSE;\n-static bfd_boolean avr_replace_call_ret_sequences = TRUE;\n+static bool avr_no_stubs = false;\n+static bool avr_debug_relax = false;\n+static bool avr_debug_stubs = false;\n+static bool avr_replace_call_ret_sequences = true;\n static bfd_vma avr_pc_wrap_around = 0x10000000;\n \n /* Transfers information to the bfd frontend.  */\n@@ -73,22 +73,22 @@ avr_elf_${EMULATION_NAME}_before_allocation (void)\n \n   if (bfd_get_flavour (link_info.output_bfd) != bfd_target_elf_flavour)\n     {\n-      avr_no_stubs = TRUE;\n+      avr_no_stubs = true;\n       return;\n     }\n \n   /* We only need stubs for avr6, avrxmega6, and avrxmega7.  */\n   if (strcmp (\"${EMULATION_NAME}\", \"avr6\") != 0\n       && strcmp (\"${EMULATION_NAME}\", \"avrxmega6\") != 0\n       && strcmp (\"${EMULATION_NAME}\", \"avrxmega7\") != 0)\n-    avr_no_stubs = TRUE;\n+    avr_no_stubs = true;\n \n   avr_elf_set_global_bfd_parameters ();\n \n   /* If generating a relocatable output file, then\n      we don't  have to generate the trampolines.  */\n   if (bfd_link_relocatable (&link_info))\n-    avr_no_stubs = TRUE;\n+    avr_no_stubs = true;\n \n   if (avr_no_stubs)\n     return;\n@@ -102,7 +102,7 @@ avr_elf_${EMULATION_NAME}_before_allocation (void)\n     return;\n \n   /* Call into the BFD backend to do the real \"stub\"-work.  */\n-  if (! elf32_avr_size_stubs (link_info.output_bfd, &link_info, TRUE))\n+  if (! elf32_avr_size_stubs (link_info.output_bfd, &link_info, true))\n     einfo (_(\"%X%P: can not size stub section: %E\\n\"));\n }\n \n@@ -165,7 +165,7 @@ avr_elf_after_allocation (void)\n     {\n       /* If relaxing, elf32_avr_size_stubs will be called from\n \t elf32_avr_relax_section.  */\n-      if (!elf32_avr_size_stubs (link_info.output_bfd, &link_info, TRUE))\n+      if (!elf32_avr_size_stubs (link_info.output_bfd, &link_info, true))\n \teinfo (_(\"%X%P: can not size stub section: %E\\n\"));\n     }\n \n@@ -184,7 +184,7 @@ avr_elf_before_parse (void)\n {\n   /* Don't create a demand-paged executable, since this feature isn't\n      meaningful in AVR. */\n-  config.magic_demand_paged = FALSE;\n+  config.magic_demand_paged = false;\n \n   gld${EMULATION_NAME}_before_parse ();\n }\n@@ -193,11 +193,11 @@ static void\n avr_finish (void)\n {\n   bfd *abfd;\n-  bfd_boolean avr_link_relax;\n+  bool avr_link_relax;\n \n   if (bfd_link_relocatable (&link_info))\n     {\n-      avr_link_relax = TRUE;\n+      avr_link_relax = true;\n       for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)\n \t{\n \t  /* Don't let the linker stubs prevent the final object being\n@@ -206,7 +206,7 @@ avr_finish (void)\n \t       & EF_AVR_LINKRELAX_PREPARED) == 0\n \t      && abfd != stub_file->the_bfd)\n \t    {\n-\t      avr_link_relax = FALSE;\n+\t      avr_link_relax = false;\n \t      break;\n \t    }\n \t}\n@@ -296,26 +296,26 @@ PARSE_AND_LIST_ARGS_CASES='\n \telse if ((!strcmp (optarg,\"64k\")) || (!strcmp (optarg,\"64K\")))\n \t  avr_pc_wrap_around = 0x10000;\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n       break;\n \n     case OPTION_DEBUG_STUBS:\n-      avr_debug_stubs = TRUE;\n+      avr_debug_stubs = true;\n       break;\n \n     case OPTION_DEBUG_RELAX:\n-      avr_debug_relax = TRUE;\n+      avr_debug_relax = true;\n       break;\n \n     case OPTION_NO_STUBS:\n-      avr_no_stubs = TRUE;\n+      avr_no_stubs = true;\n       break;\n \n     case OPTION_NO_CALL_RET_REPLACEMENT:\n       {\n \t/* This variable is defined in the bfd library.  */\n-\tavr_replace_call_ret_sequences = FALSE;\n+\tavr_replace_call_ret_sequences = false;\n       }\n       break;\n '"
    },
    {
      "sha": "2de34482e91e1dca1741d059235eee112b3b7380",
      "filename": "ld/emultempl/beos.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/beos.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/beos.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/beos.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -260,13 +260,13 @@ set_pe_stack_heap (char *resname, char *comname)\n }\n \n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_BASE_FILE:\n       link_info.base_file = fopen (optarg, FOPEN_WB);\n@@ -315,7 +315,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       set_pe_value (\"__image_base__\");\n       break;\n     }\n-  return TRUE;\n+  return true;\n }\n \f\n /* Assign values to the special symbols before the linker script is\n@@ -349,7 +349,7 @@ gld_${EMULATION_NAME}_set_symbols (void)\n     {\n       long val = init[j].value;\n       lang_add_assignment (exp_assign (init[j].symbol, exp_intop (val),\n-\t\t\t\t       FALSE));\n+\t\t\t\t       false));\n       if (init[j].size == sizeof(short))\n \t*(short *)init[j].ptr = val;\n       else if (init[j].size == sizeof(int))\n@@ -678,7 +678,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,\n   output_secname = xstrdup (secname);\n   ps = strchr (output_secname + 1, '\\$');\n   *ps = 0;\n-  os = lang_output_section_statement_lookup (output_secname, constraint, TRUE);\n+  os = lang_output_section_statement_lookup (output_secname, constraint, true);\n \n   /* Find the '\\$' wild statement for this section.  We currently require the\n      linker script to explicitly mention \"*(.foo\\$)\".  */"
    },
    {
      "sha": "dfe4b665a20a7a7b4386ec913960561b0b0998a3",
      "filename": "ld/emultempl/bfin.em",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/bfin.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/bfin.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/bfin.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -28,10 +28,10 @@ fragment <<EOF\n #include \"elf32-bfin.h\"\n \n /* Whether to put code in Blackfin L1 SRAM.  */\n-extern bfd_boolean elf32_bfin_code_in_l1;\n+extern bool elf32_bfin_code_in_l1;\n \n /* Whether to put (writable) data in Blackfin L1 SRAM.  */\n-extern bfd_boolean elf32_bfin_data_in_l1;\n+extern bool elf32_bfin_data_in_l1;\n \n EOF\n \n@@ -58,9 +58,9 @@ PARSE_AND_LIST_OPTIONS='\n \n PARSE_AND_LIST_ARGS_CASES='\n     case OPTION_CODE_IN_L1:\n-      elf32_bfin_code_in_l1 = TRUE;\n+      elf32_bfin_code_in_l1 = true;\n       break;\n     case OPTION_DATA_IN_L1:\n-      elf32_bfin_data_in_l1 = TRUE;\n+      elf32_bfin_data_in_l1 = true;\n       break;\n '"
    },
    {
      "sha": "b155dd63e502546e49eee640d50e6b32cf9f94c9",
      "filename": "ld/emultempl/cr16elf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/cr16elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/cr16elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cr16elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -112,12 +112,12 @@ cr16elf_after_parse (void)\n      option.\n      This is to emulate the CRTools' method of keeping variables\n      of different alignment in separate sections.  */\n-  config.sort_common = TRUE;\n+  config.sort_common = true;\n \n   /* Don't create a demand-paged executable, since this feature isn't\n      meaninful in CR16 embedded systems. Moreover, when magic_demand_paged\n      is true the link sometimes fails.  */\n-  config.magic_demand_paged = FALSE;\n+  config.magic_demand_paged = false;\n \n   ldelf_after_parse ();\n }"
    },
    {
      "sha": "5c5784fb06bdb0d504fb2b6e7a9b9542d0b93c96",
      "filename": "ld/emultempl/crxelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/crxelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/crxelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/crxelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -33,12 +33,12 @@ crxelf_after_parse (void)\n      option.\n      This is to emulate the CRTools' method of keeping variables\n      of different alignment in separate sections.  */\n-  config.sort_common = TRUE;\n+  config.sort_common = true;\n \n   /* Don't create a demand-paged executable, since this feature isn't\n      meaninful in CRX embedded systems. Moreover, when magic_demand_paged\n      is true the link sometimes fails.  */\n-  config.magic_demand_paged = FALSE;\n+  config.magic_demand_paged = false;\n \n   ldelf_after_parse ();\n }"
    },
    {
      "sha": "ff3c2f41f390ff8396fe1b1714b28c5b344e7e45",
      "filename": "ld/emultempl/cskyelf.em",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/cskyelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/cskyelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cskyelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -28,7 +28,7 @@ fragment <<EOF\n #include \"elf32-csky.h\"\n \n /* To use branch stub or not.  */\n-extern bfd_boolean use_branch_stub;\n+extern bool use_branch_stub;\n \n /* Fake input file for stubs.  */\n static lang_input_statement_type *stub_file;\n@@ -48,11 +48,11 @@ struct hook_stub_info\n };\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (l = *lp; l != NULL; lp = &l->header.next, l = *lp)\n     switch (l->header.type)\n@@ -89,7 +89,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t       after its associated input section.  */\n \t    *(info->add.tail) = l->header.next;\n \t    l->header.next = info->add.head;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \tbreak;\n \n@@ -110,7 +110,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \tbreak;\n       }\n \n-  return FALSE;\n+  return false;\n }\n EOF\n \n@@ -121,7 +121,7 @@ fragment <<EOF\n static void\n csky_elf_before_parse (void)\n {\n-  use_branch_stub = FALSE;\n+  use_branch_stub = false;\n   gld${EMULATION_NAME}_before_parse ();\n }\n EOF\n@@ -137,7 +137,7 @@ csky_elf_create_output_section_statements (void)\n {\n   if (!(bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour\n \t&& elf_object_id (link_info.output_bfd) == CSKY_ELF_DATA))\n-    use_branch_stub = FALSE;\n+    use_branch_stub = false;\n \n   /* If don't use branch stub, just do not emit stub_file.  */\n   if (!use_branch_stub)\n@@ -209,7 +209,7 @@ gldcsky_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n \n@@ -312,10 +312,10 @@ PARSE_AND_LIST_OPTIONS='\n \n PARSE_AND_LIST_ARGS_CASES='\n   case OPTION_BRANCH_STUB:\n-    use_branch_stub = TRUE;\n+    use_branch_stub = true;\n     break;\n   case OPTION_NO_BRANCH_STUB:\n-    use_branch_stub = FALSE;\n+    use_branch_stub = false;\n     break;\n \n   case OPTION_STUBGROUP_SIZE:"
    },
    {
      "sha": "bfaf8130a3e62802057a83b9dabf791283ddbecb",
      "filename": "ld/emultempl/elf.em",
      "status": "modified",
      "additions": 39,
      "deletions": 39,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -78,10 +78,10 @@ static void\n gld${EMULATION_NAME}_before_parse (void)\n {\n   ldfile_set_output_arch (\"${OUTPUT_ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n-  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};\n-  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo TRUE ; else echo FALSE ; fi`;\n-  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo TRUE ; else echo FALSE ; fi`;\n-  link_info.check_relocs_after_open_input = TRUE;\n+  input_flags.dynamic = ${DYNAMIC_LINK-true};\n+  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo true ; else echo false ; fi`;\n+  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo true ; else echo false ; fi`;\n+  link_info.check_relocs_after_open_input = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF\n@@ -106,21 +106,21 @@ EOF\n \n if test x\"$LDEMUL_AFTER_OPEN\" != xgld\"$EMULATION_NAME\"_after_open; then\n \n-  IS_LINUX_TARGET=FALSE\n-  IS_FREEBSD_TARGET=FALSE\n+  IS_LINUX_TARGET=false\n+  IS_FREEBSD_TARGET=false\n   case ${target} in\n     *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)\n-      IS_LINUX_TARGET=TRUE ;;\n+      IS_LINUX_TARGET=true ;;\n     *-*-freebsd* | *-*-dragonfly*)\n-      IS_FREEBSD_TARGET=TRUE ;;\n+      IS_FREEBSD_TARGET=true ;;\n   esac\n-  IS_LIBPATH=FALSE\n+  IS_LIBPATH=false\n   if test \"x${USE_LIBPATH}\" = xyes; then\n-    IS_LIBPATH=TRUE\n+    IS_LIBPATH=true\n   fi\n-  IS_NATIVE=FALSE\n+  IS_NATIVE=false\n   if test \"x${NATIVE}\" = xyes; then\n-    IS_NATIVE=TRUE\n+    IS_NATIVE=true\n   fi\n \n fragment <<EOF\n@@ -617,13 +617,13 @@ fragment <<EOF\n \n #define DEFAULT_BUILD_ID_STYLE\t\"sha1\"\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_BUILD_ID:\n       free ((char *) ldelf_emit_note_gnu_build_id);\n@@ -660,11 +660,11 @@ fragment <<EOF\n \tbreak;\n \n     case OPTION_DISABLE_NEW_DTAGS:\n-      link_info.new_dtags = FALSE;\n+      link_info.new_dtags = false;\n       break;\n \n     case OPTION_ENABLE_NEW_DTAGS:\n-      link_info.new_dtags = TRUE;\n+      link_info.new_dtags = true;\n       break;\n \n     case OPTION_EH_FRAME_HDR:\n@@ -687,16 +687,16 @@ fragment <<EOF\n       break;\n \n     case OPTION_HASH_STYLE:\n-      link_info.emit_hash = FALSE;\n-      link_info.emit_gnu_hash = FALSE;\n+      link_info.emit_hash = false;\n+      link_info.emit_gnu_hash = false;\n       if (strcmp (optarg, \"sysv\") == 0)\n-\tlink_info.emit_hash = TRUE;\n+\tlink_info.emit_hash = true;\n       else if (strcmp (optarg, \"gnu\") == 0)\n-\tlink_info.emit_gnu_hash = TRUE;\n+\tlink_info.emit_gnu_hash = true;\n       else if (strcmp (optarg, \"both\") == 0)\n \t{\n-\t  link_info.emit_hash = TRUE;\n-\t  link_info.emit_gnu_hash = TRUE;\n+\t  link_info.emit_hash = true;\n+\t  link_info.emit_gnu_hash = true;\n \t}\n       else\n \teinfo (_(\"%F%P: invalid hash style \\`%s'\\n\"), optarg);\n@@ -711,7 +711,7 @@ fragment <<EOF\n       else if (strcmp (optarg, \"undefs\") == 0)\n \tlink_info.unresolved_syms_in_objects = RM_IGNORE;\n       else if (strcmp (optarg, \"muldefs\") == 0)\n-\tlink_info.allow_multiple_definition = TRUE;\n+\tlink_info.allow_multiple_definition = true;\n       else if (startswith (optarg, \"max-page-size=\"))\n \t{\n \t  char *end;\n@@ -744,26 +744,26 @@ fragment <<EOF\n \t}\n       else if (strcmp (optarg, \"execstack\") == 0)\n \t{\n-\t  link_info.execstack = TRUE;\n-\t  link_info.noexecstack = FALSE;\n+\t  link_info.execstack = true;\n+\t  link_info.noexecstack = false;\n \t}\n       else if (strcmp (optarg, \"noexecstack\") == 0)\n \t{\n-\t  link_info.noexecstack = TRUE;\n-\t  link_info.execstack = FALSE;\n+\t  link_info.noexecstack = true;\n+\t  link_info.execstack = false;\n \t}\n       else if (strcmp (optarg, \"unique-symbol\") == 0)\n-\tlink_info.unique_symbol = TRUE;\n+\tlink_info.unique_symbol = true;\n       else if (strcmp (optarg, \"nounique-symbol\") == 0)\n-\tlink_info.unique_symbol = FALSE;\n+\tlink_info.unique_symbol = false;\n       else if (strcmp (optarg, \"globalaudit\") == 0)\n \t{\n \t  link_info.flags_1 |= DF_1_GLOBAUDIT;\n \t}\n       else if (startswith (optarg, \"start-stop-gc\"))\n-\tlink_info.start_stop_gc = TRUE;\n+\tlink_info.start_stop_gc = true;\n       else if (startswith (optarg, \"nostart-stop-gc\"))\n-\tlink_info.start_stop_gc = FALSE;\n+\tlink_info.start_stop_gc = false;\n       else if (startswith (optarg, \"start-stop-visibility=\"))\n \t{\n \t  if (strcmp (optarg, \"start-stop-visibility=default\") == 0)\n@@ -819,25 +819,25 @@ fragment <<EOF\n       else if (strcmp (optarg, \"nounique\") == 0)\n \tlink_info.gnu_flags_1 &= ~(bfd_vma) DF_GNU_1_UNIQUE;\n       else if (strcmp (optarg, \"combreloc\") == 0)\n-\tlink_info.combreloc = TRUE;\n+\tlink_info.combreloc = true;\n       else if (strcmp (optarg, \"nocombreloc\") == 0)\n-\tlink_info.combreloc = FALSE;\n+\tlink_info.combreloc = false;\n       else if (strcmp (optarg, \"nocopyreloc\") == 0)\n-\tlink_info.nocopyreloc = TRUE;\n+\tlink_info.nocopyreloc = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF\n       else if (strcmp (optarg, \"relro\") == 0)\n-\tlink_info.relro = TRUE;\n+\tlink_info.relro = true;\n       else if (strcmp (optarg, \"norelro\") == 0)\n-\tlink_info.relro = FALSE;\n+\tlink_info.relro = false;\n EOF\n fi\n fragment <<EOF\n       else if (strcmp (optarg, \"separate-code\") == 0)\n-\tlink_info.separate_code = TRUE;\n+\tlink_info.separate_code = true;\n       else if (strcmp (optarg, \"noseparate-code\") == 0)\n-\tlink_info.separate_code = FALSE;\n+\tlink_info.separate_code = false;\n       else if (strcmp (optarg, \"common\") == 0)\n \tlink_info.elf_stt_common = elf_stt_common;\n       else if (strcmp (optarg, \"nocommon\") == 0)\n@@ -872,7 +872,7 @@ fi\n fragment <<EOF\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n EOF"
    },
    {
      "sha": "067b9243c6fac2a9dbea44e71c2464a94e74462d",
      "filename": "ld/emultempl/genelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/genelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/genelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/genelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -64,7 +64,7 @@ gld${EMULATION_NAME}_before_allocation (void)\n static void\n gld${EMULATION_NAME}_after_allocation (void)\n {\n-  ldelf_map_segments (FALSE);\n+  ldelf_map_segments (false);\n }\n EOF\n # Put these extra routines in ld_${EMULATION_NAME}_emulation"
    },
    {
      "sha": "37567b0c3a5a8474389c7a61c039119eb6b93f7a",
      "filename": "ld/emultempl/hppaelf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/hppaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/hppaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/hppaelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -100,11 +100,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -142,7 +142,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t before its associated input section.  */\n \t      *lp = info->add.head;\n \t      *(info->add.tail) = l;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -163,7 +163,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -215,7 +215,7 @@ hppaelf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n "
    },
    {
      "sha": "e4d87bc69e0e5547d0ced725f996b5f27fb0f9ca",
      "filename": "ld/emultempl/linux.em",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/linux.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/linux.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/linux.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -49,9 +49,9 @@ static void\n gld${EMULATION_NAME}_before_parse (void)\n {\n   ldfile_set_output_arch (\"${OUTPUT_ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n-  input_flags.dynamic = TRUE;\n-  config.has_shared = TRUE;\n-  link_info.check_relocs_after_open_input = TRUE;\n+  input_flags.dynamic = true;\n+  config.has_shared = true;\n+  link_info.check_relocs_after_open_input = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF\n@@ -64,14 +64,14 @@ fragment <<EOF\n /* Try to open a dynamic archive.  This is where we know that Linux\n    dynamic libraries have an extension of .sa.  */\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_open_dynamic_archive\n   (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)\n {\n   char *string;\n \n   if (! entry->flags.maybe_archive || entry->flags.full_name_provided)\n-    return FALSE;\n+    return false;\n \n   string = (char *) xmalloc (strlen (search->name)\n \t\t\t     + strlen (entry->filename)\n@@ -83,12 +83,12 @@ gld${EMULATION_NAME}_open_dynamic_archive\n   if (! ldfile_try_open_bfd (string, entry))\n     {\n       free (string);\n-      return FALSE;\n+      return false;\n     }\n \n   entry->filename = string;\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is called by the create_output_section_statements routine via"
    },
    {
      "sha": "480d1b7d8f33f5299633d8e1c835a515118f8d6c",
      "filename": "ld/emultempl/m68hc1xelf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/m68hc1xelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/m68hc1xelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/m68hc1xelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -105,7 +105,7 @@ m68hc11_elf_${EMULATION_NAME}_before_allocation (void)\n \n      But for 68HC11 this is board specific.  The definition of such\n      memory region allows one to control how this paged memory is accessed.  */\n-  region = lang_memory_region_lookup (bank_window_name, FALSE);\n+  region = lang_memory_region_lookup (bank_window_name, false);\n \n   /* Check the length to see if it was defined in the script.  */\n   if (region->length != 0)\n@@ -175,11 +175,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -219,7 +219,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t before its associated input section.  */\n \t      *lp = info->add.head;\n \t      *(info->add.tail) = l;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -240,7 +240,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n "
    },
    {
      "sha": "96bffbc8a9e044232e18d33b248fc818f6f2fb9c",
      "filename": "ld/emultempl/metagelf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/metagelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/metagelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/metagelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -76,11 +76,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -118,7 +118,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t before its associated input section.  */\n \t      *lp = info->add.head;\n \t      *(info->add.tail) = l;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -139,7 +139,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -191,7 +191,7 @@ metagelf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n "
    },
    {
      "sha": "8f28fcd22ee77825312d48f53f6d120a05b16ea0",
      "filename": "ld/emultempl/mipself.em",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mipself.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mipself.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mipself.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -20,10 +20,10 @@\n \n case ${target} in\n   *-*-*gnu*)\n-    gnu_target=TRUE\n+    gnu_target=true\n     ;;\n   *)\n-    gnu_target=FALSE\n+    gnu_target=false\n     ;;\n esac\n \n@@ -42,9 +42,9 @@ fragment <<EOF\n static lang_input_statement_type *stub_file;\n static bfd *stub_bfd;\n \n-static bfd_boolean insn32;\n-static bfd_boolean ignore_branch_isa;\n-static bfd_boolean compact_branches;\n+static bool insn32;\n+static bool ignore_branch_isa;\n+static bool compact_branches;\n \n struct hook_stub_info\n {\n@@ -54,11 +54,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -97,7 +97,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t before its associated input section.  */\n \t      *lp = info->add.head;\n \t      *(info->add.tail) = l;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -118,7 +118,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Create a new stub section called STUB_SEC_NAME and arrange for it to\n@@ -278,27 +278,27 @@ PARSE_AND_LIST_OPTIONS='\n \n PARSE_AND_LIST_ARGS_CASES='\n     case OPTION_INSN32:\n-      insn32 = TRUE;\n+      insn32 = true;\n       break;\n \n     case OPTION_NO_INSN32:\n-      insn32 = FALSE;\n+      insn32 = false;\n       break;\n \n     case OPTION_IGNORE_BRANCH_ISA:\n-      ignore_branch_isa = TRUE;\n+      ignore_branch_isa = true;\n       break;\n \n     case OPTION_NO_IGNORE_BRANCH_ISA:\n-      ignore_branch_isa = FALSE;\n+      ignore_branch_isa = false;\n       break;\n \n     case OPTION_COMPACT_BRANCHES:\n-      compact_branches = TRUE;\n+      compact_branches = true;\n       break;\n \n     case OPTION_NO_COMPACT_BRANCHES:\n-      compact_branches = FALSE;\n+      compact_branches = false;\n       break;\n '\n "
    },
    {
      "sha": "a88fc5a6596f563c160007a642c927885acc7b03",
      "filename": "ld/emultempl/mmix-elfnmmo.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmix-elfnmmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmix-elfnmmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmix-elfnmmo.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -30,7 +30,7 @@ static void gld${EMULATION_NAME}_before_parse (void);\n static void\n mmix_before_parse (void)\n {\n-  link_info.check_relocs_after_open_input = TRUE;\n+  link_info.check_relocs_after_open_input = true;\n   gld${EMULATION_NAME}_before_parse ();\n }\n "
    },
    {
      "sha": "44c82872448a485fde3b72cefba5a16228cde492",
      "filename": "ld/emultempl/mmixelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmixelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmixelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmixelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -37,9 +37,9 @@ elfmmix_before_parse (void)\n      page in the linked file, which is non-intuitive.  If there's ever a\n      full system with shared libraries and demand paging, you will want to\n      exclude this file.  */\n-  config.magic_demand_paged = FALSE;\n+  config.magic_demand_paged = false;\n \n-  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo TRUE ; else echo FALSE ; fi`;\n+  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo true ; else echo false ; fi`;\n }\n EOF\n "
    },
    {
      "sha": "a3a229954a790469818f040d8315fdf3dcc33bc0",
      "filename": "ld/emultempl/mmo.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/mmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmo.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -202,7 +202,7 @@ static void\n gld${EMULATION_NAME}_after_allocation (void)\n {\n   bfd_map_over_sections (link_info.output_bfd, mmo_wipe_sec_reloc_flag, NULL);\n-  ldelf_map_segments (FALSE);\n+  ldelf_map_segments (false);\n }\n \f\n /* To get on-demand global register allocation right, we need to parse the"
    },
    {
      "sha": "c09db93f6f7e4f3ade1af6a5cbbfa57bb9965bd8",
      "filename": "ld/emultempl/msp430.em",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/msp430.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/msp430.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/msp430.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -61,7 +61,7 @@ enum { ROM, RAM };\n \n static int data_region = REGION_NONE;\n static int code_region = REGION_NONE;\n-static bfd_boolean disable_sec_transformation = FALSE;\n+static bool disable_sec_transformation = false;\n \n #define MAX_PREFIX_LENGTH 7\n \n@@ -228,21 +228,21 @@ scan_children (lang_statement_union_type * l)\n static void\n warn_no_output_section (const char *name)\n {\n-  static bfd_boolean warned[2][4] = {{FALSE, FALSE, FALSE, FALSE},\n-\t\t\t\t     {FALSE, FALSE, FALSE, FALSE}};\n+  static bool warned[2][4] = {{false, false, false, false},\n+\t\t\t      {false, false, false, false}};\n   int i = WARN_LOWER;\n \n   if (strncmp (name, \".upper.\", 7) == 0)\n     i = WARN_UPPER;\n \n   if (!warned[i][WARN_TEXT] && strcmp (name + 6, \".text\") == 0)\n-    warned[i][WARN_TEXT] = TRUE;\n+    warned[i][WARN_TEXT] = true;\n   else if (!warned[i][WARN_DATA] && strcmp (name + 6, \".data\") == 0)\n-    warned[i][WARN_DATA] = TRUE;\n+    warned[i][WARN_DATA] = true;\n   else if (!warned[i][WARN_BSS] && strcmp (name + 6, \".bss\") == 0)\n-    warned[i][WARN_BSS] = TRUE;\n+    warned[i][WARN_BSS] = true;\n   else if (!warned[i][WARN_RODATA] && strcmp (name + 6, \".rodata\") == 0)\n-    warned[i][WARN_RODATA] = TRUE;\n+    warned[i][WARN_RODATA] = true;\n   else\n     return;\n   einfo (\"%P: warning: no input section rule matches %s in linker script\\n\",\n@@ -336,7 +336,7 @@ fi\n \n fragment <<EOF\n \n-static bfd_boolean\n+static bool\n change_output_section (lang_statement_union_type **head,\n \t\t       asection *s,\n \t\t       lang_output_section_statement_type *new_os,\n@@ -371,21 +371,21 @@ change_output_section (lang_statement_union_type **head,\n \t      if (old_list->tail == (lang_statement_union_type **) curr)\n \t\told_list->tail = (lang_statement_union_type **) prev;\n \n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \tcase lang_wild_statement_enum:\n \t  if (change_output_section (&(curr->wild_statement.children.head),\n \t\t\t\t     s, new_os, old_os))\n-\t    return TRUE;\n+\t    return true;\n \t  break;\n \tdefault:\n \t  break;\n \t}\n       prev = curr;\n       curr = curr->header.next;\n     }\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -483,7 +483,7 @@ gld${EMULATION_NAME}_list_options (FILE * file)\n         add the {either,lower,upper,none} prefixes\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n@@ -501,13 +501,13 @@ gld${EMULATION_NAME}_handle_option (int optc)\n \t{\n \t  einfo (_(\"%P: --code-region requires an argument: \"\n \t\t   \"{upper,lower,either,none}\\n\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \t{\n \t  einfo (_(\"%P: error: unrecognized argument to --code-region= option: \"\n \t\t   \"\\\"%s\\\"\\n\"), optarg);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n@@ -524,24 +524,24 @@ gld${EMULATION_NAME}_handle_option (int optc)\n \t{\n \t  einfo (_(\"%P: --data-region requires an argument: \"\n \t\t   \"{upper,lower,either,none}\\n\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \t{\n \t  einfo (_(\"%P: error: unrecognized argument to --data-region= option: \"\n \t\t   \"\\\"%s\\\"\\n\"), optarg);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n \n     case OPTION_DISABLE_TRANS:\n-      disable_sec_transformation = TRUE;\n+      disable_sec_transformation = true;\n       break;\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -730,7 +730,7 @@ intermediate_relax_sections (void)\n \n   while (i--)\n     {\n-      bfd_boolean relax_again;\n+      bool relax_again;\n \n       link_info.relax_trip = -1;\n       do\n@@ -741,8 +741,8 @@ intermediate_relax_sections (void)\n \n \t  lang_reset_memory_regions ();\n \n-\t  relax_again = FALSE;\n-\t  lang_size_sections (&relax_again, FALSE);\n+\t  relax_again = false;\n+\t  lang_size_sections (&relax_again, false);\n \t}\n       while (relax_again);\n \n@@ -840,20 +840,20 @@ input_section_exists (lang_statement_union_type * l, const char * name)\n \t  if ((l->input_section.section->flags & SEC_ALLOC)\n \t      && l->input_section.section->size > 0\n \t      && !strcmp (l->input_section.section->name, name))\n-\t    return TRUE;\n+\t    return true;\n \t  break;\n \n \tcase lang_wild_statement_enum:\n \t  if (input_section_exists (l->wild_statement.children.head, name))\n-\t    return TRUE;\n+\t    return true;\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n       l = l->header.next;\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Some MSP430 linker scripts do not include ALIGN directives to ensure\n@@ -889,7 +889,7 @@ check_array_section_alignment (void)\n \t   || (rodata2_sec && input_section_exists (rodata2_sec->children.head,\n \t\t\t\t\t\t    array_names[i][0])))\n \t  && (sym = bfd_link_hash_lookup (link_info.hash, array_names[i][1],\n-\t\t\t\t\t  FALSE, FALSE, TRUE))\n+\t\t\t\t\t  false, false, true))\n \t  && sym->type == bfd_link_hash_defined\n \t  && sym->u.def.value % 2)\n \t{"
    },
    {
      "sha": "d0d5cc02a006f7f65cf26a912820a105a675a985",
      "filename": "ld/emultempl/nios2elf.em",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/nios2elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/nios2elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/nios2elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -81,12 +81,12 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp,\n-\t      bfd_boolean afterp)\n+\t      bool afterp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -133,7 +133,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp,\n \t\t  *lp = info->add.head;\n \t\t  *(info->add.tail) = l;\n \t\t}\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -154,7 +154,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp,\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Call-back for elf32_nios2_size_stubs.  */\n@@ -164,7 +164,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp,\n \n static asection *\n nios2elf_add_stub_section (const char *stub_sec_name, asection *input_section,\n-\t\t\t   bfd_boolean afterp)\n+\t\t\t   bool afterp)\n {\n   asection *stub_sec;\n   flagword flags;\n@@ -208,7 +208,7 @@ nios2elf_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n   need_laying_out = -1;\n }\n "
    },
    {
      "sha": "2ed1e61eb434a3af5b89fb2cdeec743baf101e96",
      "filename": "ld/emultempl/pdp11.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pdp11.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pdp11.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pdp11.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -28,8 +28,8 @@ gld${EMULATION_NAME}_before_parse (void)\n {\n   ldfile_set_output_arch (\"`echo ${ARCH}`\", bfd_arch_unknown);\n   /* for PDP11 Unix compatibility, default to --omagic */\n-  config.magic_demand_paged = FALSE;\n-  config.text_read_only = FALSE;\n+  config.magic_demand_paged = false;\n+  config.text_read_only = false;\n }\n \n /* PDP11 specific options.  */\n@@ -67,13 +67,13 @@ gld${EMULATION_NAME}_list_options (FILE *file)\n   fprintf (file, _(\"  --no-omagic    Equivalent to --nmagic\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case 'z':\n     case OPTION_IMAGIC:\n@@ -84,7 +84,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       break;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* We need a special case to prepare an additional linker script for option"
    },
    {
      "sha": "c5aed5f126a95b98c7dba1609b7bab1690689aee",
      "filename": "ld/emultempl/pe.em",
      "status": "modified",
      "additions": 71,
      "deletions": 71,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pe.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pe.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pe.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -133,7 +133,7 @@ static int support_old_code = 0;\n static char * thumb_entry_symbol = NULL;\n static lang_assignment_statement_type *image_base_statement = 0;\n static unsigned short pe_dll_characteristics = DEFAULT_DLL_CHARACTERISTICS;\n-static bfd_boolean insert_timestamp = TRUE;\n+static bool insert_timestamp = true;\n static const char *emit_build_id;\n \n #ifdef DLL_SUPPORT\n@@ -167,7 +167,7 @@ gld_${EMULATION_NAME}_before_parse (void)\n   ldfile_set_output_arch (\"${OUTPUT_ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n   output_filename = \"${EXECUTABLE_NAME:-a.exe}\";\n #ifdef DLL_SUPPORT\n-  input_flags.dynamic = TRUE;\n+  input_flags.dynamic = true;\n   config.has_shared = 1;\n EOF\n \n@@ -395,7 +395,7 @@ typedef struct\n   /* FALSE for an assembly level symbol and TRUE for a C visible symbol.\n      C visible symbols can be prefixed by underscore dependent to target's\n      settings.  */\n-  bfd_boolean is_c_symbol;\n+  bool is_c_symbol;\n } definfo;\n \n /* Get symbol name dependent to kind and C visible state of\n@@ -414,31 +414,31 @@ static definfo init[] =\n {\n   /* imagebase must be first */\n #define IMAGEBASEOFF 0\n-  D(ImageBase,\"__image_base__\", NT_EXE_IMAGE_BASE, FALSE),\n+  D(ImageBase,\"__image_base__\", NT_EXE_IMAGE_BASE, false),\n #define DLLOFF 1\n-  {&dll, sizeof(dll), 0, \"__dll__\", 0, FALSE},\n+  {&dll, sizeof(dll), 0, \"__dll__\", 0, false},\n #define MSIMAGEBASEOFF\t2\n-  D(ImageBase, \"___ImageBase\", NT_EXE_IMAGE_BASE, TRUE),\n-  D(SectionAlignment,\"__section_alignment__\", PE_DEF_SECTION_ALIGNMENT, FALSE),\n-  D(FileAlignment,\"__file_alignment__\", PE_DEF_FILE_ALIGNMENT, FALSE),\n-  D(MajorOperatingSystemVersion,\"__major_os_version__\", 4, FALSE),\n-  D(MinorOperatingSystemVersion,\"__minor_os_version__\", 0, FALSE),\n-  D(MajorImageVersion,\"__major_image_version__\", 1, FALSE),\n-  D(MinorImageVersion,\"__minor_image_version__\", 0, FALSE),\n+  D(ImageBase, \"___ImageBase\", NT_EXE_IMAGE_BASE, true),\n+  D(SectionAlignment,\"__section_alignment__\", PE_DEF_SECTION_ALIGNMENT, false),\n+  D(FileAlignment,\"__file_alignment__\", PE_DEF_FILE_ALIGNMENT, false),\n+  D(MajorOperatingSystemVersion,\"__major_os_version__\", 4, false),\n+  D(MinorOperatingSystemVersion,\"__minor_os_version__\", 0, false),\n+  D(MajorImageVersion,\"__major_image_version__\", 1, false),\n+  D(MinorImageVersion,\"__minor_image_version__\", 0, false),\n #if defined(TARGET_IS_armpe)  || defined(TARGET_IS_arm_wince_pe)\n-  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 3, FALSE),\n+  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 3, false),\n #else\n-  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 4, FALSE),\n+  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 4, false),\n #endif\n-  D(MinorSubsystemVersion,\"__minor_subsystem_version__\", 0, FALSE),\n-  D(Subsystem,\"__subsystem__\", ${SUBSYSTEM}, FALSE),\n-  D(SizeOfStackReserve,\"__size_of_stack_reserve__\", 0x200000, FALSE),\n-  D(SizeOfStackCommit,\"__size_of_stack_commit__\", 0x1000, FALSE),\n-  D(SizeOfHeapReserve,\"__size_of_heap_reserve__\", 0x100000, FALSE),\n-  D(SizeOfHeapCommit,\"__size_of_heap_commit__\", 0x1000, FALSE),\n-  D(LoaderFlags,\"__loader_flags__\", 0x0, FALSE),\n-  D(DllCharacteristics, \"__dll_characteristics__\", DEFAULT_DLL_CHARACTERISTICS, FALSE),\n-  { NULL, 0, 0, NULL, 0 , FALSE}\n+  D(MinorSubsystemVersion,\"__minor_subsystem_version__\", 0, false),\n+  D(Subsystem,\"__subsystem__\", ${SUBSYSTEM}, false),\n+  D(SizeOfStackReserve,\"__size_of_stack_reserve__\", 0x200000, false),\n+  D(SizeOfStackCommit,\"__size_of_stack_commit__\", 0x1000, false),\n+  D(SizeOfHeapReserve,\"__size_of_heap_reserve__\", 0x100000, false),\n+  D(SizeOfHeapCommit,\"__size_of_heap_commit__\", 0x1000, false),\n+  D(LoaderFlags,\"__loader_flags__\", 0x0, false),\n+  D(DllCharacteristics, \"__dll_characteristics__\", DEFAULT_DLL_CHARACTERISTICS, false),\n+  { NULL, 0, 0, NULL, 0 , false}\n };\n \n \n@@ -716,13 +716,13 @@ set_pe_stack_heap (char *resname, char *comname)\n \n #define DEFAULT_BUILD_ID_STYLE\t\"md5\"\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_BASE_FILE:\n       link_info.base_file = fopen (optarg, FOPEN_WB);\n@@ -777,7 +777,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       thumb_entry_symbol = optarg;\n       break;\n     case OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:\n-      pe_use_nul_prefixed_import_tables = TRUE;\n+      pe_use_nul_prefixed_import_tables = true;\n       break;\n     case OPTION_NO_LEADING_UNDERSCORE:\n       pe_leading_underscore = 0;\n@@ -786,10 +786,10 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       pe_leading_underscore = 1;\n       break;\n     case OPTION_INSERT_TIMESTAMP:\n-      insert_timestamp = TRUE;\n+      insert_timestamp = true;\n       break;\n     case OPTION_NO_INSERT_TIMESTAMP:\n-      insert_timestamp = FALSE;\n+      insert_timestamp = false;\n       break;\n #ifdef DLL_SUPPORT\n     case OPTION_OUT_DEF:\n@@ -949,7 +949,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n   /*  Set DLLCharacteristics bits  */\n   set_pe_name (\"__dll_characteristics__\", pe_dll_characteristics);\n \n-  return TRUE;\n+  return true;\n }\n \f\n \n@@ -1031,7 +1031,7 @@ gld_${EMULATION_NAME}_set_symbols (void)\n       lang_assignment_statement_type *rv;\n \n       rv = lang_add_assignment (exp_assign (GET_INIT_SYMBOL_NAME (j),\n-\t\t\t\t\t    exp_intop (val), FALSE));\n+\t\t\t\t\t    exp_intop (val), false));\n       if (init[j].size == sizeof (short))\n \t*(short *) init[j].ptr = val;\n       else if (init[j].size == sizeof (int))\n@@ -1074,7 +1074,7 @@ gld_${EMULATION_NAME}_after_parse (void)\n #ifdef DLL_SUPPORT\n static struct bfd_link_hash_entry *pe_undef_found_sym;\n \n-static bfd_boolean\n+static bool\n pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)\n {\n   int sl;\n@@ -1089,9 +1089,9 @@ pe_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)\n       && h->root.string[sl] == '@')\n     {\n       pe_undef_found_sym = h;\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Change UNDEF to a defined symbol, taking data from SYM.  */\n@@ -1100,7 +1100,7 @@ static void\n change_undef (struct bfd_link_hash_entry * undef,\n \t      struct bfd_link_hash_entry * sym)\n {\n-  static bfd_boolean  gave_warning_message = FALSE;\n+  static bool  gave_warning_message = false;\n \n   undef->type = bfd_link_hash_defined;\n   undef->u.def.value = sym->u.def.value;\n@@ -1115,7 +1115,7 @@ change_undef (struct bfd_link_hash_entry * undef,\n \t{\n \t  einfo (_(\"Use --enable-stdcall-fixup to disable these warnings\\n\"));\n \t  einfo (_(\"Use --disable-stdcall-fixup to disable these fixups\\n\"));\n-\t  gave_warning_message = TRUE;\n+\t  gave_warning_message = true;\n \t}\n     }\n \n@@ -1153,7 +1153,7 @@ pe_fixup_stdcalls (void)\n \t      *cname = '_';\n \t    if (at)\n \t      * strchr (cname, '@') = 0;\n-\t    sym = bfd_link_hash_lookup (link_info.hash, cname, FALSE, FALSE, TRUE);\n+\t    sym = bfd_link_hash_lookup (link_info.hash, cname, false, false, true);\n \n \t    if (sym && sym->type == bfd_link_hash_defined)\n \t      change_undef (undef, sym);\n@@ -1190,12 +1190,12 @@ make_import_fixup (arelent *rel, asection *s, char *name, const char *symname)\n   pe_create_import_fixup (rel, s, _addend, name, symname);\n }\n \n-static bfd_boolean\n+static bool\n pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n {\n   printf (\"+%s\\n\", h->string);\n \n-  return TRUE;\n+  return true;\n }\n #endif /* DLL_SUPPORT */\n \n@@ -1207,7 +1207,7 @@ debug_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)\n     *found = 1;\n }\n \n-static bfd_boolean\n+static bool\n pecoff_checksum_contents (bfd *abfd,\n \t\t\t  void (*process) (const void *, size_t, void *),\n \t\t\t  void *arg)\n@@ -1232,10 +1232,10 @@ pecoff_checksum_contents (bfd *abfd,\n       filepos += 1;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n write_build_id (bfd *abfd)\n {\n   struct pe_tdata *t = pe_data (abfd);\n@@ -1270,7 +1270,7 @@ write_build_id (bfd *abfd)\n     {\n       einfo (_(\"%P: warning: .buildid section discarded,\"\n \t       \" --build-id ignored\\n\"));\n-      return TRUE;\n+      return true;\n     }\n \n   if (t->build_id.sec->contents == NULL)\n@@ -1329,11 +1329,11 @@ write_build_id (bfd *abfd)\n   pe_data (link_info.output_bfd)->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size\n     = sizeof (struct external_IMAGE_DEBUG_DIRECTORY);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make .buildid section, and set up coff_tdata->build_id. */\n-static bfd_boolean\n+static bool\n setup_build_id (bfd *ibfd)\n {\n   asection *s;\n@@ -1342,7 +1342,7 @@ setup_build_id (bfd *ibfd)\n   if (!validate_build_id_style (emit_build_id))\n     {\n       einfo (_(\"%P: warning: unrecognized --build-id style ignored\\n\"));\n-      return FALSE;\n+      return false;\n     }\n \n   flags = (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n@@ -1362,12 +1362,12 @@ setup_build_id (bfd *ibfd)\n       s->size = sizeof (struct external_IMAGE_DEBUG_DIRECTORY)\n \t+ sizeof (CV_INFO_PDB70) + 1;\n \n-      return TRUE;\n+      return true;\n     }\n \n   einfo (_(\"%P: warning: cannot create .buildid section,\"\n \t   \" --build-id ignored\\n\"));\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1582,7 +1582,7 @@ gld_${EMULATION_NAME}_after_open (void)\n \t\t\t/* Thunk section with reloc to another bfd.  */\n \t\t\tblhe = bfd_link_hash_lookup (link_info.hash,\n \t\t\t\t\t\t     s->name,\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n+\t\t\t\t\t\t     false, false, true);\n \n \t\t\tif (blhe == NULL\n \t\t\t    || blhe->type != bfd_link_hash_defined)\n@@ -1774,7 +1774,7 @@ gld_${EMULATION_NAME}_after_open (void)\n \t\t\t   the stub.  */\n \t\t\tblhe = bfd_link_hash_lookup (link_info.hash,\n \t\t\t\t\t\t     symbols[src_count]->name,\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n+\t\t\t\t\t\t     false, false, true);\n \t\t\t/* If the symbol in the stub section has no other\n \t\t\t   undefined references, exclude the stub section\n \t\t\t   from the final link.  */\n@@ -1837,7 +1837,7 @@ saw_option (char *option)\n }\n #endif /* DLL_SUPPORT */\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)\n {\n #ifdef DLL_SUPPORT\n@@ -1868,7 +1868,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      sprintf (buf, \"%s%s\", U (\"\"),\n \t\t       pe_def_file->exports[i].internal_name);\n \n-\t      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);\n+\t      h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);\n \t      if (h == (struct bfd_link_hash_entry *) NULL)\n \t\teinfo (_(\"%F%P: bfd_link_hash_lookup failed: %E\\n\"));\n \t      if (h->type == bfd_link_hash_new)\n@@ -1894,7 +1894,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      if (image_base_statement)\n \t\timage_base_statement->exp\n \t\t  = exp_assign (\"__image_base__\", exp_intop (pe.ImageBase),\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \t    }\n \n \t  if (pe_def_file->stack_reserve != -1\n@@ -1911,14 +1911,14 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      if (pe_def_file->heap_commit != -1)\n \t\tpe.SizeOfHeapCommit = pe_def_file->heap_commit;\n \t    }\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n #endif\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)\n {\n #ifdef DLL_SUPPORT\n@@ -1937,7 +1937,7 @@ gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUT\n   if (pe_bfd_is_dll (entry->the_bfd))\n     return pe_implied_import_dll (entry->filename);\n #endif\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1949,7 +1949,7 @@ gld_${EMULATION_NAME}_finish (void)\n   if (thumb_entry_symbol != NULL)\n     {\n       h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n \n       if (h != (struct bfd_link_hash_entry *) NULL\n \t  && (h->type == bfd_link_hash_defined\n@@ -2239,7 +2239,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n   return os;\n }\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_open_dynamic_archive\n   (const char *arch ATTRIBUTE_UNUSED,\n    search_dirs_type *search,\n@@ -2248,34 +2248,34 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n   static const struct\n     {\n       const char * format;\n-      bfd_boolean use_prefix;\n+      bool use_prefix;\n     }\n   libname_fmt [] =\n     {\n       /* Preferred explicit import library for dll's.  */\n-      { \"lib%s.dll.a\", FALSE },\n+      { \"lib%s.dll.a\", false },\n       /* Alternate explicit import library for dll's.  */\n-      { \"%s.dll.a\", FALSE },\n+      { \"%s.dll.a\", false },\n       /* \"libfoo.a\" could be either an import lib or a static lib.\n \t For backwards compatibility, libfoo.a needs to precede\n \t libfoo.dll and foo.dll in the search.  */\n-      { \"lib%s.a\", FALSE },\n+      { \"lib%s.a\", false },\n       /* The 'native' spelling of an import lib name is \"foo.lib\".  */\n-      { \"%s.lib\", FALSE },\n+      { \"%s.lib\", false },\n       /* PR 22948 - Check for an import library.  */\n-      { \"lib%s.lib\", FALSE },\n+      { \"lib%s.lib\", false },\n #ifdef DLL_SUPPORT\n       /* Try \"<prefix>foo.dll\" (preferred dll name, if specified).  */\n-      {\t\"%s%s.dll\", TRUE },\n+      {\t\"%s%s.dll\", true },\n #endif\n       /* Try \"libfoo.dll\" (default preferred dll name).  */\n-      {\t\"lib%s.dll\", FALSE },\n+      {\t\"lib%s.dll\", false },\n       /* Finally try 'native' dll name \"foo.dll\".  */\n-      {  \"%s.dll\", FALSE },\n+      {  \"%s.dll\", false },\n       /* Note: If adding more formats to this table, make sure to check to\n \t see if their length is longer than libname_fmt[0].format, and if\n \t so, update the call to xmalloc() below.  */\n-      { NULL, FALSE }\n+      { NULL, false }\n     };\n   static unsigned int format_max_len = 0;\n   const char * filename;\n@@ -2285,7 +2285,7 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n \n \n   if (! entry->flags.maybe_archive || entry->flags.full_name_provided)\n-    return FALSE;\n+    return false;\n \n   filename = entry->filename;\n \n@@ -2337,12 +2337,12 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n   if (!libname_fmt[i].format)\n     {\n       free (full_string);\n-      return FALSE;\n+      return false;\n     }\n \n   entry->filename = full_string;\n \n-  return TRUE;\n+  return true;\n }\n \n static int"
    },
    {
      "sha": "c6fd8b8f8d942abac0b085fa0c55fc2207100bdc",
      "filename": "ld/emultempl/pep.em",
      "status": "modified",
      "additions": 65,
      "deletions": 65,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pep.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/pep.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pep.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -152,7 +152,7 @@ static flagword real_flags = IMAGE_FILE_LARGE_ADDRESS_AWARE;\n static int support_old_code = 0;\n static lang_assignment_statement_type *image_base_statement = 0;\n static unsigned short pe_dll_characteristics = DEFAULT_DLL_CHARACTERISTICS;\n-static bfd_boolean insert_timestamp = TRUE;\n+static bool insert_timestamp = true;\n static const char *emit_build_id;\n \n #ifdef DLL_SUPPORT\n@@ -186,7 +186,7 @@ gld_${EMULATION_NAME}_before_parse (void)\n   ldfile_set_output_arch (\"${OUTPUT_ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n   output_filename = \"${EXECUTABLE_NAME:-a.exe}\";\n #ifdef DLL_SUPPORT\n-  input_flags.dynamic = TRUE;\n+  input_flags.dynamic = true;\n   config.has_shared = 1;\n   link_info.pei386_auto_import = 1;\n   link_info.pei386_runtime_pseudo_reloc = 2; /* Use by default version 2.  */\n@@ -372,7 +372,7 @@ typedef struct\n   /* FALSE for an assembly level symbol and TRUE for a C visible symbol.\n      C visible symbols can be prefixed by underscore dependent on target's\n      settings.  */\n-  bfd_boolean is_c_symbol;\n+  bool is_c_symbol;\n } definfo;\n \n #define GET_INIT_SYMBOL_NAME(IDX) \\\n@@ -389,27 +389,27 @@ static definfo init[] =\n {\n   /* imagebase must be first */\n #define IMAGEBASEOFF 0\n-  D(ImageBase,\"__image_base__\", NT_EXE_IMAGE_BASE, FALSE),\n+  D(ImageBase,\"__image_base__\", NT_EXE_IMAGE_BASE, false),\n #define DLLOFF 1\n-  {&dll, sizeof(dll), 0, \"__dll__\", 0, FALSE},\n+  {&dll, sizeof(dll), 0, \"__dll__\", 0, false},\n #define MSIMAGEBASEOFF\t2\n-  D(ImageBase, \"___ImageBase\", NT_EXE_IMAGE_BASE, TRUE),\n-  D(SectionAlignment,\"__section_alignment__\", PE_DEF_SECTION_ALIGNMENT, FALSE),\n-  D(FileAlignment,\"__file_alignment__\", PE_DEF_FILE_ALIGNMENT, FALSE),\n-  D(MajorOperatingSystemVersion,\"__major_os_version__\", 4, FALSE),\n-  D(MinorOperatingSystemVersion,\"__minor_os_version__\", 0, FALSE),\n-  D(MajorImageVersion,\"__major_image_version__\", 0, FALSE),\n-  D(MinorImageVersion,\"__minor_image_version__\", 0, FALSE),\n-  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 5, FALSE),\n-  D(MinorSubsystemVersion,\"__minor_subsystem_version__\", 2, FALSE),\n-  D(Subsystem,\"__subsystem__\", ${SUBSYSTEM}, FALSE),\n-  D(SizeOfStackReserve,\"__size_of_stack_reserve__\", 0x200000, FALSE),\n-  D(SizeOfStackCommit,\"__size_of_stack_commit__\", 0x1000, FALSE),\n-  D(SizeOfHeapReserve,\"__size_of_heap_reserve__\", 0x100000, FALSE),\n-  D(SizeOfHeapCommit,\"__size_of_heap_commit__\", 0x1000, FALSE),\n-  D(LoaderFlags,\"__loader_flags__\", 0x0, FALSE),\n-  D(DllCharacteristics, \"__dll_characteristics__\", DEFAULT_DLL_CHARACTERISTICS, FALSE),\n-  { NULL, 0, 0, NULL, 0, FALSE}\n+  D(ImageBase, \"___ImageBase\", NT_EXE_IMAGE_BASE, true),\n+  D(SectionAlignment,\"__section_alignment__\", PE_DEF_SECTION_ALIGNMENT, false),\n+  D(FileAlignment,\"__file_alignment__\", PE_DEF_FILE_ALIGNMENT, false),\n+  D(MajorOperatingSystemVersion,\"__major_os_version__\", 4, false),\n+  D(MinorOperatingSystemVersion,\"__minor_os_version__\", 0, false),\n+  D(MajorImageVersion,\"__major_image_version__\", 0, false),\n+  D(MinorImageVersion,\"__minor_image_version__\", 0, false),\n+  D(MajorSubsystemVersion,\"__major_subsystem_version__\", 5, false),\n+  D(MinorSubsystemVersion,\"__minor_subsystem_version__\", 2, false),\n+  D(Subsystem,\"__subsystem__\", ${SUBSYSTEM}, false),\n+  D(SizeOfStackReserve,\"__size_of_stack_reserve__\", 0x200000, false),\n+  D(SizeOfStackCommit,\"__size_of_stack_commit__\", 0x1000, false),\n+  D(SizeOfHeapReserve,\"__size_of_heap_reserve__\", 0x100000, false),\n+  D(SizeOfHeapCommit,\"__size_of_heap_commit__\", 0x1000, false),\n+  D(LoaderFlags,\"__loader_flags__\", 0x0, false),\n+  D(DllCharacteristics, \"__dll_characteristics__\", DEFAULT_DLL_CHARACTERISTICS, false),\n+  { NULL, 0, 0, NULL, 0, false}\n };\n \n \n@@ -679,14 +679,14 @@ set_pep_stack_heap (char *resname, char *comname)\n \n #define DEFAULT_BUILD_ID_STYLE\t\"md5\"\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   is_underscoring ();\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_BASE_FILE:\n       link_info.base_file = fopen (optarg, FOPEN_WB);\n@@ -738,7 +738,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       support_old_code = 1;\n       break;\n     case OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:\n-      pep_use_nul_prefixed_import_tables = TRUE;\n+      pep_use_nul_prefixed_import_tables = true;\n       break;\n     case OPTION_NO_LEADING_UNDERSCORE:\n       pep_leading_underscore = 0;\n@@ -747,10 +747,10 @@ gld${EMULATION_NAME}_handle_option (int optc)\n       pep_leading_underscore = 1;\n       break;\n     case OPTION_INSERT_TIMESTAMP:\n-      insert_timestamp = TRUE;\n+      insert_timestamp = true;\n       break;\n     case OPTION_NO_INSERT_TIMESTAMP:\n-      insert_timestamp = FALSE;\n+      insert_timestamp = false;\n       break;\n #ifdef DLL_SUPPORT\n     case OPTION_OUT_DEF:\n@@ -900,7 +900,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n   /*  Set DLLCharacteristics bits  */\n   set_pep_name (\"__dll_characteristics__\", pe_dll_characteristics);\n \n-  return TRUE;\n+  return true;\n }\n \f\n \n@@ -982,7 +982,7 @@ gld_${EMULATION_NAME}_set_symbols (void)\n       lang_assignment_statement_type *rv;\n \n       rv = lang_add_assignment (exp_assign (GET_INIT_SYMBOL_NAME (j),\n-\t\t\t\t\t    exp_intop (val), FALSE));\n+\t\t\t\t\t    exp_intop (val), false));\n       if (init[j].size == sizeof (short))\n \t*(short *) init[j].ptr = (short) val;\n       else if (init[j].size == sizeof (int))\n@@ -1025,7 +1025,7 @@ gld_${EMULATION_NAME}_after_parse (void)\n #ifdef DLL_SUPPORT\n static struct bfd_link_hash_entry *pep_undef_found_sym;\n \n-static bfd_boolean\n+static bool\n pep_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)\n {\n   int sl;\n@@ -1040,9 +1040,9 @@ pep_undef_cdecl_match (struct bfd_link_hash_entry *h, void *inf)\n       && h->root.string[sl] == '@')\n     {\n       pep_undef_found_sym = h;\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -1181,12 +1181,12 @@ make_import_fixup (arelent *rel, asection *s, char *name, const char *symname)\n   pep_create_import_fixup (rel, s, _addend, name, symname);\n }\n \n-static bfd_boolean\n+static bool\n pr_sym (struct bfd_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n {\n   printf (\"+%s\\n\", h->string);\n \n-  return TRUE;\n+  return true;\n }\n #endif /* DLL_SUPPORT */\n \n@@ -1199,7 +1199,7 @@ debug_section_p (bfd *abfd ATTRIBUTE_UNUSED, asection *sect, void *obj)\n     *found = 1;\n }\n \n-static bfd_boolean\n+static bool\n pecoff_checksum_contents (bfd *abfd,\n \t\t\t  void (*process) (const void *, size_t, void *),\n \t\t\t  void *arg)\n@@ -1224,10 +1224,10 @@ pecoff_checksum_contents (bfd *abfd,\n       filepos += 1;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n write_build_id (bfd *abfd)\n {\n   struct pe_tdata *t = pe_data (abfd);\n@@ -1262,7 +1262,7 @@ write_build_id (bfd *abfd)\n     {\n       einfo (_(\"%P: warning: .buildid section discarded,\"\n \t       \" --build-id ignored\\n\"));\n-      return TRUE;\n+      return true;\n     }\n \n   if (t->build_id.sec->contents == NULL)\n@@ -1321,11 +1321,11 @@ write_build_id (bfd *abfd)\n   pe_data (link_info.output_bfd)->pe_opthdr.DataDirectory[PE_DEBUG_DATA].Size\n     = sizeof (struct external_IMAGE_DEBUG_DIRECTORY);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make .buildid section, and set up coff_tdata->build_id. */\n-static bfd_boolean\n+static bool\n setup_build_id (bfd *ibfd)\n {\n   asection *s;\n@@ -1334,7 +1334,7 @@ setup_build_id (bfd *ibfd)\n   if (!validate_build_id_style (emit_build_id))\n     {\n       einfo (_(\"%P: warning: unrecognized --build-id style ignored\\n\"));\n-      return FALSE;\n+      return false;\n     }\n \n   flags = (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n@@ -1354,12 +1354,12 @@ setup_build_id (bfd *ibfd)\n       s->size = sizeof (struct external_IMAGE_DEBUG_DIRECTORY)\n \t+ sizeof (CV_INFO_PDB70) + 1;\n \n-      return TRUE;\n+      return true;\n     }\n \n   einfo (_(\"%P: warning: cannot create .buildid section,\"\n \t   \" --build-id ignored\\n\"));\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1554,7 +1554,7 @@ gld_${EMULATION_NAME}_after_open (void)\n \t\t\t/* Thunk section with reloc to another bfd.  */\n \t\t\tblhe = bfd_link_hash_lookup (link_info.hash,\n \t\t\t\t\t\t     s->name,\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n+\t\t\t\t\t\t     false, false, true);\n \n \t\t\tif (blhe == NULL\n \t\t\t    || blhe->type != bfd_link_hash_defined)\n@@ -1715,7 +1715,7 @@ saw_option (char *option)\n }\n #endif /* DLL_SUPPORT */\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)\n {\n #ifdef DLL_SUPPORT\n@@ -1746,7 +1746,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      sprintf (buf, \"%s%s\", U (\"\"),\n \t\t       pep_def_file->exports[i].internal_name);\n \n-\t      h = bfd_link_hash_lookup (link_info.hash, buf, TRUE, TRUE, TRUE);\n+\t      h = bfd_link_hash_lookup (link_info.hash, buf, true, true, true);\n \t      if (h == (struct bfd_link_hash_entry *) NULL)\n \t\teinfo (_(\"%F%P: bfd_link_hash_lookup failed: %E\\n\"));\n \t      if (h->type == bfd_link_hash_new)\n@@ -1772,7 +1772,7 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      if (image_base_statement)\n \t\timage_base_statement->exp\n \t\t  = exp_assign (\"__image_base__\", exp_intop (pep.ImageBase),\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \t    }\n \n \t  if (pep_def_file->stack_reserve != -1\n@@ -1789,14 +1789,14 @@ gld_${EMULATION_NAME}_unrecognized_file (lang_input_statement_type *entry ATTRIB\n \t      if (pep_def_file->heap_commit != -1)\n \t\tpep.SizeOfHeapCommit = pep_def_file->heap_commit;\n \t    }\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n #endif\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUTE_UNUSED)\n {\n   is_underscoring ();\n@@ -1807,7 +1807,7 @@ gld_${EMULATION_NAME}_recognized_file (lang_input_statement_type *entry ATTRIBUT\n   if (pep_bfd_is_dll (entry->the_bfd))\n     return pep_implied_import_dll (entry->filename);\n #endif\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -2059,7 +2059,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n   return os;\n }\n \n-static bfd_boolean\n+static bool\n gld_${EMULATION_NAME}_open_dynamic_archive\n   (const char *arch ATTRIBUTE_UNUSED,\n    search_dirs_type *search,\n@@ -2068,34 +2068,34 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n   static const struct\n     {\n       const char * format;\n-      bfd_boolean use_prefix;\n+      bool use_prefix;\n     }\n   libname_fmt [] =\n     {\n       /* Preferred explicit import library for dll's.  */\n-      { \"lib%s.dll.a\", FALSE },\n+      { \"lib%s.dll.a\", false },\n       /* Alternate explicit import library for dll's.  */\n-      { \"%s.dll.a\", FALSE },\n+      { \"%s.dll.a\", false },\n       /* \"libfoo.a\" could be either an import lib or a static lib.\n \t For backwards compatibility, libfoo.a needs to precede\n \t libfoo.dll and foo.dll in the search.  */\n-      { \"lib%s.a\", FALSE },\n+      { \"lib%s.a\", false },\n       /* The 'native' spelling of an import lib name is \"foo.lib\".  */\n-      { \"%s.lib\", FALSE },\n+      { \"%s.lib\", false },\n       /* PR 22948 - Check for an import library.  */\n-      { \"lib%s.lib\", FALSE },\n+      { \"lib%s.lib\", false },\n #ifdef DLL_SUPPORT\n       /* Try \"<prefix>foo.dll\" (preferred dll name, if specified).  */\n-      {\t\"%s%s.dll\", TRUE },\n+      {\t\"%s%s.dll\", true },\n #endif\n       /* Try \"libfoo.dll\" (default preferred dll name).  */\n-      {\t\"lib%s.dll\", FALSE },\n+      {\t\"lib%s.dll\", false },\n       /* Finally try 'native' dll name \"foo.dll\".  */\n-      {  \"%s.dll\", FALSE },\n+      {  \"%s.dll\", false },\n       /* Note: If adding more formats to this table, make sure to check to\n \t see if their length is longer than libname_fmt[0].format, and if\n \t so, update the call to xmalloc() below.  */\n-      { NULL, FALSE }\n+      { NULL, false }\n     };\n   static unsigned int format_max_len = 0;\n   const char * filename;\n@@ -2105,7 +2105,7 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n \n \n   if (! entry->flags.maybe_archive || entry->flags.full_name_provided)\n-    return FALSE;\n+    return false;\n \n   filename = entry->filename;\n \n@@ -2157,12 +2157,12 @@ gld_${EMULATION_NAME}_open_dynamic_archive\n   if (!libname_fmt[i].format)\n     {\n       free (full_string);\n-      return FALSE;\n+      return false;\n     }\n \n   entry->filename = full_string;\n \n-  return TRUE;\n+  return true;\n }\n \n static int"
    },
    {
      "sha": "c8d39d84dc7d68c29784cec86124cc6bd4c26c7a",
      "filename": "ld/emultempl/ppc32elf.em",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ppc32elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ppc32elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc32elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -125,7 +125,7 @@ prelim_size_sections (void)\n     {\n       expld.phase = lang_mark_phase_enum;\n       expld.dataseg.phase = exp_seg_none;\n-      one_lang_size_sections_pass (NULL, FALSE);\n+      one_lang_size_sections_pass (NULL, false);\n       /* We must not cache anything from the preliminary sizing.  */\n       lang_reset_memory_regions ();\n     }\n@@ -246,13 +246,13 @@ EOF\n if grep -q 'ld_elf32_spu_emulation' ldemul-list.h; then\n   fragment <<EOF\n /* Special handling for embedded SPU executables.  */\n-extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);\n+extern bool embedded_spu_file (lang_input_statement_type *, const char *);\n \n-static bfd_boolean\n+static bool\n ppc_recognized_file (lang_input_statement_type *entry)\n {\n   if (embedded_spu_file (entry, \"-m32\"))\n-    return TRUE;\n+    return true;\n \n   return ldelf_load_symbols (entry);\n }\n@@ -408,7 +408,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'\n     case OPTION_TRADITIONAL_FORMAT:\n       notlsopt = 1;\n       params.no_tls_get_addr_opt = 1;\n-      return FALSE;\n+      return false;\n \n     case OPTION_PPC476_WORKAROUND:\n       params.ppc476_workaround = 1;"
    },
    {
      "sha": "5b07a045cb461639f1ce0d9f098767a5e5d8a585",
      "filename": "ld/emultempl/ppc64elf.em",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ppc64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ppc64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc64elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -272,7 +272,7 @@ prelim_size_sections (void)\n     {\n       expld.phase = lang_mark_phase_enum;\n       expld.dataseg.phase = exp_seg_none;\n-      one_lang_size_sections_pass (NULL, FALSE);\n+      one_lang_size_sections_pass (NULL, false);\n       /* We must not cache anything from the preliminary sizing.  */\n       lang_reset_memory_regions ();\n     }\n@@ -347,11 +347,11 @@ struct hook_stub_info\n \n /* Traverse the linker tree to find the spot where the stub goes.  */\n \n-static bfd_boolean\n+static bool\n hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n {\n   lang_statement_union_type *l;\n-  bfd_boolean ret;\n+  bool ret;\n \n   for (; (l = *lp) != NULL; lp = &l->header.next)\n     {\n@@ -389,7 +389,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t\t before its associated input section.  */\n \t      *lp = info->add.head;\n \t      *(info->add.tail) = l;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  break;\n \n@@ -410,7 +410,7 @@ hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)\n \t  break;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -467,7 +467,7 @@ ppc_layout_sections_again (void)\n   /* If we have changed sizes of the stub sections, then we need\n      to recalculate all the section offsets.  This may mean we need to\n      add even more stubs.  */\n-  ldelf_map_segments (TRUE);\n+  ldelf_map_segments (true);\n \n   if (!bfd_link_relocatable (&link_info))\n     ppc64_elf_set_toc (&link_info, link_info.output_bfd);\n@@ -667,13 +667,13 @@ EOF\n if grep -q 'ld_elf32_spu_emulation' ldemul-list.h; then\n   fragment <<EOF\n /* Special handling for embedded SPU executables.  */\n-extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);\n+extern bool embedded_spu_file (lang_input_statement_type *, const char *);\n \n-static bfd_boolean\n+static bool\n ppc64_recognized_file (lang_input_statement_type *entry)\n {\n   if (embedded_spu_file (entry, \"-m64\"))\n-    return TRUE;\n+    return true;\n \n   return ldelf_load_symbols (entry);\n }\n@@ -1007,7 +1007,7 @@ PARSE_AND_LIST_ARGS_CASES=${PARSE_AND_LIST_ARGS_CASES}'\n       no_toc_sort = 1;\n       params.plt_static_chain = 1;\n       params.no_pcrel_opt = 1;\n-      return FALSE;\n+      return false;\n '\n \n # Put these extra ppc64elf routines in ld_${EMULATION_NAME}_emulation"
    },
    {
      "sha": "3be9c6d7370991ecb88c01e8f4f125197e4ef30b",
      "filename": "ld/emultempl/rxelf.em",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/rxelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/rxelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/rxelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -27,15 +27,15 @@ fragment <<EOF\n \n #include \"elf32-rx.h\"\n \n-static bfd_boolean no_flag_mismatch_warnings = TRUE;\n-static bfd_boolean ignore_lma = TRUE;\n+static bool no_flag_mismatch_warnings = true;\n+static bool ignore_lma = true;\n \n /* This is a convenient point to tell BFD about target specific flags.\n    After the output has been created, but before inputs are read.  */\n static void\n rx_elf_create_output_section_statements (void)\n {\n-  extern void bfd_elf32_rx_set_target_flags (bfd_boolean, bfd_boolean);\n+  extern void bfd_elf32_rx_set_target_flags (bool, bool);\n \n   bfd_elf32_rx_set_target_flags (no_flag_mismatch_warnings, ignore_lma);\n }\n@@ -71,19 +71,19 @@ PARSE_AND_LIST_OPTIONS='\n \n PARSE_AND_LIST_ARGS_CASES='\n     case OPTION_NO_FLAG_MISMATCH_WARNINGS:\n-      no_flag_mismatch_warnings = TRUE;\n+      no_flag_mismatch_warnings = true;\n       break;\n \n     case OPTION_FLAG_MISMATCH_WARNINGS:\n-      no_flag_mismatch_warnings = FALSE;\n+      no_flag_mismatch_warnings = false;\n       break;\n \n     case OPTION_IGNORE_LMA:\n-      ignore_lma = TRUE;\n+      ignore_lma = true;\n       break;\n \n     case OPTION_NO_IGNORE_LMA:\n-      ignore_lma = FALSE;\n+      ignore_lma = false;\n       break;\n '\n "
    },
    {
      "sha": "d3a1c61ef92a414f8530d99fc91214c98f1ca70c",
      "filename": "ld/emultempl/rxlinux.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/rxlinux.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/rxlinux.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/rxlinux.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -32,9 +32,9 @@ fragment <<EOF\n static void\n rx_linux_create_output_section_statements (void)\n {\n-  extern void bfd_elf32_rx_set_target_flags (bfd_boolean, bfd_boolean);\n+  extern void bfd_elf32_rx_set_target_flags (bool, bool);\n \n-  bfd_elf32_rx_set_target_flags (FALSE, FALSE);\n+  bfd_elf32_rx_set_target_flags (false, false);\n }\n \n EOF"
    },
    {
      "sha": "9aea76a8f51c37f29c5440acb8b5ed01bb008fba",
      "filename": "ld/emultempl/scoreelf.em",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/scoreelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/scoreelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/scoreelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -36,10 +36,10 @@ gld${EMULATION_NAME}_before_parse (void)\n #ifndef TARGET_\t\t\t/* I.e., if not generic.  */\n   ldfile_set_output_arch (\"`echo ${ARCH}`\", bfd_arch_unknown);\n #endif /* not TARGET_ */\n-  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};\n-  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo TRUE ; else echo FALSE ; fi`;\n-  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo TRUE ; else echo FALSE ; fi`;\n-  link_info.check_relocs_after_open_input = TRUE;\n+  input_flags.dynamic = ${DYNAMIC_LINK-true};\n+  config.has_shared = `if test -n \"$GENERATE_SHLIB_SCRIPT\" ; then echo true ; else echo false ; fi`;\n+  config.separate_code = `if test \"x${SEPARATE_CODE}\" = xyes ; then echo true ; else echo false ; fi`;\n+  link_info.check_relocs_after_open_input = true;\n EOF\n if test -n \"$COMMONPAGESIZE\"; then\n fragment <<EOF"
    },
    {
      "sha": "9fb739c598b1b5a42de15e0d2bbe0b4d1e629199",
      "filename": "ld/emultempl/solaris2.em",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/solaris2.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/solaris2.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/solaris2.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -72,7 +72,7 @@ elf_solaris2_before_allocation (void)\n \n \t  /* Lookup symbol.  */\n \t  h = elf_link_hash_lookup (elf_hash_table (&link_info), *sym,\n-\t\t\t\t    FALSE, FALSE, FALSE);\n+\t\t\t\t    false, false, false);\n \t  if (h == NULL)\n \t    continue;\n \n@@ -90,7 +90,7 @@ elf_solaris2_before_allocation (void)\n \n \t  /* Lookup symbol.  */\n \t  h = elf_link_hash_lookup (elf_hash_table (&link_info), *sym,\n-\t\t\t\t    FALSE, FALSE, FALSE);\n+\t\t\t\t    false, false, false);\n \t  if (h == NULL)\n \t    continue;\n \n@@ -115,8 +115,8 @@ elf_solaris2_before_allocation (void)\n \t{\n \t  /* Create a version pattern for this symbol.  Some of them start\n \t     off as local, others as global, so try both.  */\n-\t  globals = lang_new_vers_pattern (globals, *sym, NULL, TRUE);\n-\t  locals = lang_new_vers_pattern (locals, *sym, NULL, TRUE);\n+\t  globals = lang_new_vers_pattern (globals, *sym, NULL, true);\n+\t  locals = lang_new_vers_pattern (locals, *sym, NULL, true);\n \t}\n \n       /* New version node for those symbols.  */"
    },
    {
      "sha": "b4cdc4b3c1103576a234a039364c17c12cae2d9c",
      "filename": "ld/emultempl/spuelf.em",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/spuelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/spuelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/spuelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -165,7 +165,7 @@ spu_place_special_section (asection *s, asection *o, const char *output_name)\n \n \t  push_stat_ptr (&os->children);\n \t  e_size = exp_intop (params.line_size - s->size);\n-\t  lang_add_assignment (exp_assign (\".\", e_size, FALSE));\n+\t  lang_add_assignment (exp_assign (\".\", e_size, false));\n \t  pop_stat_ptr ();\n \t}\n       lang_add_section (&os->children, s, NULL, NULL, os);\n@@ -192,7 +192,7 @@ spu_elf_load_ovl_mgr (void)\n       mgr_stream = &icache_mgr_stream;\n     }\n   h = elf_link_hash_lookup (elf_hash_table (&link_info),\n-\t\t\t    ovly_mgr_entry, FALSE, FALSE, FALSE);\n+\t\t\t    ovly_mgr_entry, false, false, false);\n \n   if (h != NULL\n       && (h->root.type == bfd_link_hash_defined\n@@ -273,7 +273,7 @@ spu_before_allocation (void)\n \t rough layout so that overlays can be found.  */\n       expld.phase = lang_mark_phase_enum;\n       expld.dataseg.phase = exp_seg_none;\n-      one_lang_size_sections_pass (NULL, TRUE);\n+      one_lang_size_sections_pass (NULL, true);\n \n       /* Find overlays by inspecting section vmas.  */\n       ret = spu_elf_find_overlays (&link_info);\n@@ -476,9 +476,9 @@ base_name (const char *path)\n \n /* This function is called when building a ppc32 or ppc64 executable\n    to handle embedded spu images.  */\n-extern bfd_boolean embedded_spu_file (lang_input_statement_type *, const char *);\n+extern bool embedded_spu_file (lang_input_statement_type *, const char *);\n \n-bfd_boolean\n+bool\n embedded_spu_file (lang_input_statement_type *entry, const char *flags)\n {\n   const char *cmd[6];\n@@ -497,7 +497,7 @@ embedded_spu_file (lang_input_statement_type *entry, const char *flags)\n       || strcmp (entry->the_bfd->xvec->name, \"elf32-spu\") != 0\n       || (entry->the_bfd->tdata.elf_obj_data->elf_header->e_type != ET_EXEC\n \t  && entry->the_bfd->tdata.elf_obj_data->elf_header->e_type != ET_DYN))\n-    return FALSE;\n+    return false;\n \n   /* Use the filename as the symbol marking the program handle struct.  */\n   sym = base_name (bfd_get_filename (entry->the_bfd));\n@@ -509,7 +509,7 @@ embedded_spu_file (lang_input_statement_type *entry, const char *flags)\n \n   fd = new_tmp_file (&oname);\n   if (fd == -1)\n-    return FALSE;\n+    return false;\n   close (fd);\n \n   for (search = (void *) input_file_chain.head;\n@@ -557,13 +557,13 @@ embedded_spu_file (lang_input_statement_type *entry, const char *flags)\n       }\n   }\n   if (status)\n-    return FALSE;\n+    return false;\n \n \n   old_stat_tail = stat_ptr->tail;\n   old_file_tail = input_file_chain.tail;\n   if (lang_add_input_file (oname, lang_input_file_is_file_enum, NULL) == NULL)\n-    return FALSE;\n+    return false;\n \n   /* lang_add_input_file puts the new list entry at the end of the statement\n      and input file lists.  Move it to just after the current entry.  */\n@@ -579,8 +579,8 @@ embedded_spu_file (lang_input_statement_type *entry, const char *flags)\n \n   /* Ensure bfd sections are excluded from the output.  */\n   bfd_section_list_clear (entry->the_bfd);\n-  entry->flags.loaded = TRUE;\n-  return TRUE;\n+  entry->flags.loaded = true;\n+  return true;\n }\n \n EOF"
    },
    {
      "sha": "5df4116e411fae5f522ce36a0af04a4b18156eaa",
      "filename": "ld/emultempl/ticoff.em",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ticoff.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/ticoff.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ticoff.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -69,13 +69,13 @@ gld_${EMULATION_NAME}_list_options (FILE * file)\n   fprintf (file, _(\"  --format 0|1|2              Specify which COFF version to use\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_COFF_FORMAT:\n       if ((*optarg == '0' || *optarg == '1' || *optarg == '2')\n@@ -92,7 +92,7 @@ gld${EMULATION_NAME}_handle_option (int optc)\n \t}\n       break;\n     }\n-  return FALSE;\n+  return false;\n }\n \n static void"
    },
    {
      "sha": "6735999e6acce4c48b43cf6da8d4b48fb22a4a87",
      "filename": "ld/emultempl/v850elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/v850elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/v850elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/v850elf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -26,7 +26,7 @@ fragment <<EOF\n #include \"ldctor.h\"\n #include \"elf32-v850.h\"\n \n-static bfd_boolean\n+static bool\n is_v850_target (void)\n {\n   extern const bfd_target v850_elf32_vec;"
    },
    {
      "sha": "243064f8993d393e976c53c6d065ed9e979ac3e4",
      "filename": "ld/emultempl/vms.em",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/vms.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/vms.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/vms.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -28,11 +28,11 @@ static void\n gld${EMULATION_NAME}_before_parse (void)\n {\n   ldfile_set_output_arch (\"${ARCH}\", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);\n-  input_flags.dynamic = TRUE;\n-  config.has_shared = FALSE; /* Not yet.  */\n+  input_flags.dynamic = true;\n+  config.has_shared = false; /* Not yet.  */\n \n   /* For ia64, harmless for alpha.  */\n-  link_info.emit_hash = FALSE;\n+  link_info.emit_hash = false;\n   link_info.spare_dynamic_tags = 0;\n }\n \n@@ -50,15 +50,15 @@ gld${EMULATION_NAME}_create_output_section_statements (void)\n /* Try to open a dynamic archive.  This is where we know that VMS\n    shared images (dynamic libraries) have an extension of .exe.  */\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_open_dynamic_archive (const char *arch ATTRIBUTE_UNUSED,\n \t\t\t\t\t   search_dirs_type *search,\n \t\t\t\t\t   lang_input_statement_type *entry)\n {\n   char *string;\n \n   if (! entry->flags.maybe_archive || entry->flags.full_name_provided)\n-    return FALSE;\n+    return false;\n \n   string = (char *) xmalloc (strlen (search->name)\n \t\t\t     + strlen (entry->filename)\n@@ -69,12 +69,12 @@ gld${EMULATION_NAME}_open_dynamic_archive (const char *arch ATTRIBUTE_UNUSED,\n   if (! ldfile_try_open_bfd (string, entry))\n     {\n       free (string);\n-      return FALSE;\n+      return false;\n     }\n \n   entry->filename = string;\n \n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -152,20 +152,20 @@ gld${EMULATION_NAME}_list_options (FILE *file)\n   fprintf (file, _(\"  --identification <string>          Set the identification of the output\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n gld${EMULATION_NAME}_handle_option (int optc)\n {\n   switch (optc)\n     {\n     default:\n-      return FALSE;\n+      return false;\n \n     case OPTION_IDENTIFICATION:\n       /* Currently ignored.  */\n       break;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n EOF"
    },
    {
      "sha": "23ce9a3534de872de0ad2e0d1f6e55418eb5bfe0",
      "filename": "ld/emultempl/xtensaelf.em",
      "status": "modified",
      "additions": 86,
      "deletions": 86,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/xtensaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/xtensaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/xtensaelf.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -52,8 +52,8 @@ static void xtensa_strip_inconsistent_linkonce_sections\n static bfd_vma xtensa_page_power = 12; /* 4K pages.  */\n \n /* To force a page break between literals and text, change\n-   xtensa_use_literal_pages to \"TRUE\".  */\n-static bfd_boolean xtensa_use_literal_pages = FALSE;\n+   xtensa_use_literal_pages to \"true\".  */\n+static bool xtensa_use_literal_pages = false;\n \n #define EXTRA_VALIDATION 0\n \n@@ -96,7 +96,7 @@ remove_section (bfd *abfd, asection *os)\n }\n \n \n-static bfd_boolean\n+static bool\n replace_insn_sec_with_prop_sec (bfd *abfd,\n \t\t\t\tconst char *insn_sec_name,\n \t\t\t\tconst char *prop_sec_name,\n@@ -115,14 +115,14 @@ replace_insn_sec_with_prop_sec (bfd *abfd,\n   *error_message = \"\";\n   insn_sec = bfd_get_section_by_name (abfd, insn_sec_name);\n   if (insn_sec == NULL)\n-    return TRUE;\n+    return true;\n   entry_count = insn_sec->size / 8;\n \n   prop_sec = bfd_get_section_by_name (abfd, prop_sec_name);\n   if (prop_sec != NULL && insn_sec != NULL)\n     {\n       *error_message = _(\"file already has property tables\");\n-      return FALSE;\n+      return false;\n     }\n \n   if (insn_sec->size != 0)\n@@ -173,7 +173,7 @@ replace_insn_sec_with_prop_sec (bfd *abfd,\n \n       elf_section_data (insn_sec)->relocs = NULL;\n       internal_relocs =\n-\t_bfd_elf_link_read_relocs (abfd, insn_sec, NULL, NULL, FALSE);\n+\t_bfd_elf_link_read_relocs (abfd, insn_sec, NULL, NULL, false);\n       elf_section_data (insn_sec)->relocs = saved_relocs;\n \n       if (internal_relocs == NULL)\n@@ -230,15 +230,15 @@ replace_insn_sec_with_prop_sec (bfd *abfd,\n \n   free (insn_contents);\n \n-  return TRUE;\n+  return true;\n \n  cleanup:\n   if (prop_sec && prop_sec->owner)\n     remove_section (abfd, prop_sec);\n   free (insn_contents);\n   free (internal_relocs);\n \n-  return FALSE;\n+  return false;\n }\n \n \n@@ -312,15 +312,15 @@ elf_xtensa_after_open (void)\n }\n \n \n-static bfd_boolean\n+static bool\n xt_config_info_unpack_and_check (char *data,\n-\t\t\t\t bfd_boolean *pmismatch,\n+\t\t\t\t bool *pmismatch,\n \t\t\t\t char **pmsg)\n {\n   char *d, *key;\n   int num;\n \n-  *pmismatch = FALSE;\n+  *pmismatch = false;\n \n   d = data;\n   while (*d)\n@@ -359,15 +359,15 @@ xt_config_info_unpack_and_check (char *data,\n \t\t}\n \t      else if (num != elf32xtensa_abi)\n \t\t{\n-\t\t  *pmismatch = TRUE;\n+\t\t  *pmismatch = true;\n \t\t  *pmsg = \"ABI does not match\";\n \t\t}\n \t    }\n \t  else if (! strcmp (key, \"USE_ABSOLUTE_LITERALS\"))\n \t    {\n \t      if (num != XSHAL_USE_ABSOLUTE_LITERALS)\n \t\t{\n-\t\t  *pmismatch = TRUE;\n+\t\t  *pmismatch = true;\n \t\t  *pmsg = \"incompatible use of the Extended L32R option\";\n \t\t}\n \t    }\n@@ -377,10 +377,10 @@ xt_config_info_unpack_and_check (char *data,\n \tgoto error;\n     }\n \n-  return TRUE;\n+  return true;\n \n  error:\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -392,7 +392,7 @@ static void\n check_xtensa_info (bfd *abfd, asection *info_sec)\n {\n   char *data, *errmsg = \"\";\n-  bfd_boolean mismatch;\n+  bool mismatch;\n \n   data = xmalloc (info_sec->size);\n   if (! bfd_get_section_contents (abfd, info_sec, data, 0, info_sec->size))\n@@ -425,7 +425,7 @@ elf_xtensa_before_allocation (void)\n {\n   asection *info_sec, *first_info_sec;\n   bfd *first_bfd;\n-  bfd_boolean is_big_endian = XCHAL_HAVE_BE;\n+  bool is_big_endian = XCHAL_HAVE_BE;\n \n   /* Check that the output endianness matches the Xtensa\n      configuration.  The BFD library always includes both big and\n@@ -565,7 +565,7 @@ struct reloc_deps_section_t\n {\n   reloc_deps_e *preds;\n   reloc_deps_e *succs;\n-  bfd_boolean is_only_literal;\n+  bool is_only_literal;\n };\n \n \n@@ -585,16 +585,16 @@ typedef void (*deps_callback_t) (asection *, /* src_sec */\n \t\t\t\t bfd_vma,    /* target_offset */\n \t\t\t\t void *);    /* closure */\n \n-extern bfd_boolean xtensa_callback_required_dependence\n+extern bool xtensa_callback_required_dependence\n   (bfd *, asection *, struct bfd_link_info *, deps_callback_t, void *);\n static void xtensa_ldlang_clear_addresses (lang_statement_union_type *);\n-static bfd_boolean ld_local_file_relocations_fit\n+static bool ld_local_file_relocations_fit\n   (lang_statement_union_type *, const reloc_deps_graph *);\n static bfd_vma ld_assign_relative_paged_dot\n   (bfd_vma, lang_statement_union_type *, const reloc_deps_graph *,\n-   bfd_boolean);\n+   bool);\n static bfd_vma ld_xtensa_insert_page_offsets\n-  (bfd_vma, lang_statement_union_type *, reloc_deps_graph *, bfd_boolean);\n+  (bfd_vma, lang_statement_union_type *, reloc_deps_graph *, bool);\n #if EXTRA_VALIDATION\n static size_t ld_count_children (lang_statement_union_type *);\n #endif\n@@ -691,39 +691,39 @@ free_reloc_deps_graph (reloc_deps_graph *deps)\n }\n \n \n-static bfd_boolean\n+static bool\n section_is_source (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n \t\t   lang_statement_union_type *s)\n {\n   asection *sec;\n   const reloc_deps_section *sec_deps;\n \n   if (s->header.type != lang_input_section_enum)\n-    return FALSE;\n+    return false;\n   sec = s->input_section.section;\n \n   sec_deps = xtensa_get_section_deps (deps, sec);\n   return sec_deps && sec_deps->succs != NULL;\n }\n \n \n-static bfd_boolean\n+static bool\n section_is_target (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n \t\t   lang_statement_union_type *s)\n {\n   asection *sec;\n   const reloc_deps_section *sec_deps;\n \n   if (s->header.type != lang_input_section_enum)\n-    return FALSE;\n+    return false;\n   sec = s->input_section.section;\n \n   sec_deps = xtensa_get_section_deps (deps, sec);\n   return sec_deps && sec_deps->preds != NULL;\n }\n \n \n-static bfd_boolean\n+static bool\n section_is_source_or_target (const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n \t\t\t     lang_statement_union_type *s)\n {\n@@ -802,14 +802,14 @@ ld_xtensa_move_section_after (xtensa_ld_iter *to, xtensa_ld_iter *current)\n /* Can only be called with lang_statements that have lists.  Returns\n    FALSE if the list is empty.  */\n \n-static bfd_boolean\n+static bool\n iter_stack_empty (xtensa_ld_iter_stack **stack_p)\n {\n   return *stack_p == NULL;\n }\n \n \n-static bfd_boolean\n+static bool\n iter_stack_push (xtensa_ld_iter_stack **stack_p,\n \t\t lang_statement_union_type *parent)\n {\n@@ -829,12 +829,12 @@ iter_stack_push (xtensa_ld_iter_stack **stack_p,\n       break;\n     default:\n       ASSERT (0);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Empty. do not push.  */\n   if (l->tail == &l->head)\n-    return FALSE;\n+    return false;\n \n   stack = xmalloc (sizeof (xtensa_ld_iter_stack));\n   memset (stack, 0, sizeof (xtensa_ld_iter_stack));\n@@ -847,7 +847,7 @@ iter_stack_push (xtensa_ld_iter_stack **stack_p,\n   if (*stack_p != NULL)\n     (*stack_p)->prev = stack;\n   *stack_p = stack;\n-  return TRUE;\n+  return true;\n }\n \n \n@@ -968,7 +968,7 @@ xtensa_colocate_literals (reloc_deps_graph *deps,\n \n   xtensa_ld_iter current; /* Location we are checking.  */\n   xtensa_ld_iter *current_p = NULL;\n-  bfd_boolean in_literals = FALSE;\n+  bool in_literals = false;\n \n   if (deps->count == 0)\n     return;\n@@ -977,15 +977,15 @@ xtensa_colocate_literals (reloc_deps_graph *deps,\n \n   while (!iter_stack_empty (stack_p))\n     {\n-      bfd_boolean skip_increment = FALSE;\n+      bool skip_increment = false;\n       lang_statement_union_type *l = iter_stack_current (stack_p);\n \n       switch (l->header.type)\n \t{\n \tcase lang_assignment_statement_enum:\n \t  /* Any assignment statement should block reordering across it.  */\n \t  front_p = NULL;\n-\t  in_literals = FALSE;\n+\t  in_literals = false;\n \t  break;\n \n \tcase lang_input_section_enum:\n@@ -1001,7 +1001,7 @@ xtensa_colocate_literals (reloc_deps_graph *deps,\n \t    }\n \t  else\n \t    {\n-\t      bfd_boolean is_target;\n+\t      bool is_target;\n \t      current_p = &current;\n \t      iter_stack_copy_current (stack_p, current_p);\n \t      is_target = (section_is_target (deps, l)\n@@ -1011,7 +1011,7 @@ xtensa_colocate_literals (reloc_deps_graph *deps,\n \t\t{\n \t\t  iter_stack_copy_current (stack_p, front_p);\n \t\t  if (!is_target)\n-\t\t    in_literals = FALSE;\n+\t\t    in_literals = false;\n \t\t}\n \t      else\n \t\t{\n@@ -1038,7 +1038,7 @@ xtensa_colocate_literals (reloc_deps_graph *deps,\n \t\t\t  front_p->loc = &(*front_p->loc)->header.next;\n \n \t\t\t  /* Do not increment the current pointer.  */\n-\t\t\t  skip_increment = TRUE;\n+\t\t\t  skip_increment = true;\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -1104,42 +1104,42 @@ xtensa_move_dependencies_to_front (reloc_deps_graph *deps,\n }\n \n \n-static bfd_boolean\n+static bool\n deps_has_sec_edge (const reloc_deps_graph *deps, asection *src, asection *tgt)\n {\n   const reloc_deps_section *sec_deps;\n   const reloc_deps_e *sec_deps_e;\n \n   sec_deps = xtensa_get_section_deps (deps, src);\n   if (sec_deps == NULL)\n-    return FALSE;\n+    return false;\n \n   for (sec_deps_e = sec_deps->succs;\n        sec_deps_e != NULL;\n        sec_deps_e = sec_deps_e->next)\n     {\n       ASSERT (sec_deps_e->src == src);\n       if (sec_deps_e->tgt == tgt)\n-\treturn TRUE;\n+\treturn true;\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n-static bfd_boolean\n+static bool\n deps_has_edge (const reloc_deps_graph *deps,\n \t       lang_statement_union_type *src,\n \t       lang_statement_union_type *tgt)\n {\n   if (!section_is_source (deps, src))\n-    return FALSE;\n+    return false;\n   if (!section_is_target (deps, tgt))\n-    return FALSE;\n+    return false;\n \n   if (src->header.type != lang_input_section_enum)\n-    return FALSE;\n+    return false;\n   if (tgt->header.type != lang_input_section_enum)\n-    return FALSE;\n+    return false;\n \n   return deps_has_sec_edge (deps, src->input_section.section,\n \t\t\t    tgt->input_section.section);\n@@ -1275,21 +1275,21 @@ ld_count_children (lang_statement_union_type *s)\n /* Check if a particular section is included in the link.  This will only\n    be true for one instance of a particular linkonce section.  */\n \n-static bfd_boolean input_section_found = FALSE;\n+static bool input_section_found = false;\n static asection *input_section_target = NULL;\n \n static void\n input_section_linked_worker (lang_statement_union_type *statement)\n {\n   if ((statement->header.type == lang_input_section_enum\n        && (statement->input_section.section == input_section_target)))\n-    input_section_found = TRUE;\n+    input_section_found = true;\n }\n \n-static bfd_boolean\n+static bool\n input_section_linked (asection *sec)\n {\n-  input_section_found = FALSE;\n+  input_section_found = false;\n   input_section_target = sec;\n   lang_for_each_statement_worker (input_section_linked_worker, stat_ptr->head);\n   return input_section_found;\n@@ -1306,7 +1306,7 @@ input_section_linked (asection *sec)\n \n static int linkonce_len = sizeof (\".gnu.linkonce.\") - 1;\n \n-static bfd_boolean\n+static bool\n is_inconsistent_linkonce_section (asection *sec)\n {\n   bfd *abfd = sec->owner;\n@@ -1315,7 +1315,7 @@ is_inconsistent_linkonce_section (asection *sec)\n \n   if ((bfd_section_flags (sec) & SEC_LINK_ONCE) == 0\n       || strncmp (sec_name, \".gnu.linkonce.\", linkonce_len) != 0)\n-    return FALSE;\n+    return false;\n \n   /* Check if this is an Xtensa property section or an exception table\n      for Tensilica's XCC compiler.  */\n@@ -1342,12 +1342,12 @@ is_inconsistent_linkonce_section (asection *sec)\n       if (dep_sec == NULL || ! input_section_linked (dep_sec))\n \t{\n \t  free (dep_sec_name);\n-\t  return TRUE;\n+\t  return true;\n \t}\n       free (dep_sec_name);\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n \n@@ -1428,20 +1428,20 @@ xtensa_wild_group_interleave_callback (lang_statement_union_type *statement)\n       size_t old_child_count;\n       size_t new_child_count;\n #endif\n-      bfd_boolean no_reorder;\n+      bool no_reorder;\n \n       w = &statement->wild_statement;\n \n-      no_reorder = FALSE;\n+      no_reorder = false;\n \n       /* If it has 0 or 1 section bound, then do not reorder.  */\n       if (w->children.head == NULL\n \t  || (w->children.head->header.type == lang_input_section_enum\n \t      && w->children.head->header.next == NULL))\n-\tno_reorder = TRUE;\n+\tno_reorder = true;\n \n       if (w->filenames_sorted)\n-\tno_reorder = TRUE;\n+\tno_reorder = true;\n \n       /* Check for sorting in a section list wildcard spec as well.  */\n       if (!no_reorder)\n@@ -1451,7 +1451,7 @@ xtensa_wild_group_interleave_callback (lang_statement_union_type *statement)\n \t    {\n \t      if (l->spec.sorted == by_name)\n \t\t{\n-\t\t  no_reorder = TRUE;\n+\t\t  no_reorder = true;\n \t\t  break;\n \t\t}\n \t    }\n@@ -1470,7 +1470,7 @@ xtensa_wild_group_interleave_callback (lang_statement_union_type *statement)\n \t\t  && ((strcmp (\".init\", l->spec.name) == 0)\n \t\t      || (strcmp (\".fini\", l->spec.name) == 0)))\n \t\t{\n-\t\t  no_reorder = TRUE;\n+\t\t  no_reorder = true;\n \t\t  break;\n \t\t}\n \t    }\n@@ -1533,9 +1533,9 @@ xtensa_layout_wild (const reloc_deps_graph *deps, lang_wild_statement_type *w)\n   literal_wild.header.next = NULL;\n   literal_wild.header.type = lang_wild_statement_enum;\n   literal_wild.filename = NULL;\n-  literal_wild.filenames_sorted = FALSE;\n+  literal_wild.filenames_sorted = false;\n   literal_wild.section_list = NULL;\n-  literal_wild.keep_sections = FALSE;\n+  literal_wild.keep_sections = false;\n   literal_wild.children.head = NULL;\n   literal_wild.children.tail = &literal_wild.children.head;\n \n@@ -1579,7 +1579,7 @@ xtensa_layout_wild (const reloc_deps_graph *deps, lang_wild_statement_type *w)\n   while (literal_wild.children.head != NULL)\n     {\n       lang_statement_union_type *lit = literal_wild.children.head;\n-      bfd_boolean placed = FALSE;\n+      bool placed = false;\n \n #if EXTRA_VALIDATION\n       ASSERT (ct2 > 0);\n@@ -1601,7 +1601,7 @@ xtensa_layout_wild (const reloc_deps_graph *deps, lang_wild_statement_type *w)\n \t      /* Place it here.  */\n \t      lit->header.next = *s_p;\n \t      *s_p = lit;\n-\t      placed = TRUE;\n+\t      placed = true;\n \t      break;\n \t    }\n \t}\n@@ -1643,7 +1643,7 @@ xtensa_colocate_output_literals_callback (lang_statement_union_type *statement)\n       size_t old_child_count;\n       size_t new_child_count;\n #endif\n-      bfd_boolean no_reorder = FALSE;\n+      bool no_reorder = false;\n \n #if EXTRA_VALIDATION\n       old_child_count = ld_count_children (statement);\n@@ -1709,16 +1709,16 @@ static bfd_vma\n ld_assign_relative_paged_dot (bfd_vma dot,\n \t\t\t      lang_statement_union_type *s,\n \t\t\t      const reloc_deps_graph *deps ATTRIBUTE_UNUSED,\n-\t\t\t      bfd_boolean lit_align)\n+\t\t\t      bool lit_align)\n {\n   /* Walk through all of the input statements in this wild statement\n      assign dot to all of them.  */\n \n   xtensa_ld_iter_stack *stack = NULL;\n   xtensa_ld_iter_stack **stack_p = &stack;\n \n-  bfd_boolean first_section = FALSE;\n-  bfd_boolean in_literals = FALSE;\n+  bool first_section = false;\n+  bool in_literals = false;\n \n   for (iter_stack_create (stack_p, s);\n        !iter_stack_empty (stack_p);\n@@ -1732,21 +1732,21 @@ ld_assign_relative_paged_dot (bfd_vma dot,\n \t  {\n \t    asection *section = l->input_section.section;\n \t    size_t align_pow = section->alignment_power;\n-\t    bfd_boolean do_xtensa_alignment = FALSE;\n+\t    bool do_xtensa_alignment = false;\n \n \t    if (lit_align)\n \t      {\n-\t\tbfd_boolean sec_is_target = section_is_target (deps, l);\n-\t\tbfd_boolean sec_is_source = section_is_source (deps, l);\n+\t\tbool sec_is_target = section_is_target (deps, l);\n+\t\tbool sec_is_source = section_is_source (deps, l);\n \n \t\tif (section->size != 0\n \t\t    && (first_section\n \t\t\t|| (in_literals && !sec_is_target)\n \t\t\t|| (!in_literals && sec_is_target)))\n \t\t  {\n-\t\t    do_xtensa_alignment = TRUE;\n+\t\t    do_xtensa_alignment = true;\n \t\t  }\n-\t\tfirst_section = FALSE;\n+\t\tfirst_section = false;\n \t\tif (section->size != 0)\n \t\t  in_literals = (sec_is_target && !sec_is_source);\n \t      }\n@@ -1773,7 +1773,7 @@ ld_assign_relative_paged_dot (bfd_vma dot,\n }\n \n \n-static bfd_boolean\n+static bool\n ld_local_file_relocations_fit (lang_statement_union_type *statement,\n \t\t\t       const reloc_deps_graph *deps ATTRIBUTE_UNUSED)\n {\n@@ -1831,34 +1831,34 @@ ld_local_file_relocations_fit (lang_statement_union_type *statement,\n \t\t      fprintf (stderr, \"Warning: \"\n \t\t\t       \"l32r target section before l32r\\n\");\n \t\t      fflush (stderr);\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t    }\n \n \t\t  if (l32r_addr - target_addr > 256 * 1024 - align_penalty)\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t    }\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n \n static bfd_vma\n ld_xtensa_insert_page_offsets (bfd_vma dot,\n \t\t\t       lang_statement_union_type *s,\n \t\t\t       reloc_deps_graph *deps,\n-\t\t\t       bfd_boolean lit_align)\n+\t\t\t       bool lit_align)\n {\n   xtensa_ld_iter_stack *stack = NULL;\n   xtensa_ld_iter_stack **stack_p = &stack;\n \n-  bfd_boolean first_section = FALSE;\n-  bfd_boolean in_literals = FALSE;\n+  bool first_section = false;\n+  bool in_literals = false;\n \n   if (!lit_align)\n-    return FALSE;\n+    return false;\n \n   for (iter_stack_create (stack_p, s);\n        !iter_stack_empty (stack_p);\n@@ -1871,7 +1871,7 @@ ld_xtensa_insert_page_offsets (bfd_vma dot,\n \tcase lang_input_section_enum:\n \t  {\n \t    asection *section = l->input_section.section;\n-\t    bfd_boolean do_xtensa_alignment = FALSE;\n+\t    bool do_xtensa_alignment = false;\n \n \t    if (lit_align)\n \t      {\n@@ -1880,9 +1880,9 @@ ld_xtensa_insert_page_offsets (bfd_vma dot,\n \t\t\t|| (in_literals && !section_is_target (deps, l))\n \t\t\t|| (!in_literals && section_is_target (deps, l))))\n \t\t  {\n-\t\t    do_xtensa_alignment = TRUE;\n+\t\t    do_xtensa_alignment = true;\n \t\t  }\n-\t\tfirst_section = FALSE;\n+\t\tfirst_section = false;\n \t\tif (section->size != 0)\n \t\t  {\n \t\t    in_literals = (section_is_target (deps, l)\n@@ -1897,7 +1897,7 @@ ld_xtensa_insert_page_offsets (bfd_vma dot,\n \t\tetree_type *name_op = exp_nameop (NAME, \".\");\n \t\tetree_type *addend_op = exp_intop (1 << xtensa_page_power);\n \t\tetree_type *add_op = exp_binop ('+', name_op, addend_op);\n-\t\tetree_type *assign_op = exp_assign (\".\", add_op, FALSE);\n+\t\tetree_type *assign_op = exp_assign (\".\", add_op, false);\n \n \t\tlang_assignment_statement_type *assign_stmt;\n \t\tlang_statement_union_type *assign_union;"
    },
    {
      "sha": "b72132eb30e59b61547843a827269553f5b237f0",
      "filename": "ld/emultempl/z80.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/z80.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/emultempl/z80.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/z80.em?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -46,7 +46,7 @@ z80_after_open (void)\n   for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link.next)\n     {\n       const bfd_arch_info_type *info;\n-      info = bfd_arch_get_compatible (link_info.output_bfd, abfd, FALSE);\n+      info = bfd_arch_get_compatible (link_info.output_bfd, abfd, false);\n       if (info == NULL)\n \teinfo (_(\"%F%P: %pB: Instruction sets of object files incompatible\\n\"),\n \t       abfd);"
    },
    {
      "sha": "1f52be9add652c1d06e334cbfd79076258494a15",
      "filename": "ld/ld.h",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ld.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ld.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ld.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -122,25 +122,25 @@ enum endian_enum { ENDIAN_UNSET = 0, ENDIAN_BIG, ENDIAN_LITTLE };\n typedef struct\n {\n   /* 1 => assign space to common symbols even if `relocatable_output'.  */\n-  bfd_boolean force_common_definition;\n+  bool force_common_definition;\n \n   /* If TRUE, build MIPS embedded PIC relocation tables in the output\n      file.  */\n-  bfd_boolean embedded_relocs;\n+  bool embedded_relocs;\n \n   /* If TRUE, force generation of a file with a .exe file.  */\n-  bfd_boolean force_exe_suffix;\n+  bool force_exe_suffix;\n \n   /* If TRUE, generate a cross reference report.  */\n-  bfd_boolean cref;\n+  bool cref;\n \n   /* If TRUE (which is the default), warn about mismatched input\n      files.  */\n-  bfd_boolean warn_mismatch;\n+  bool warn_mismatch;\n \n   /* Warn on attempting to open an incompatible library during a library\n      search.  */\n-  bfd_boolean warn_search_mismatch;\n+  bool warn_search_mismatch;\n \n   /* If non-zero check section addresses, once computed,\n      for overlaps.  Relocatable links only check when this is > 0.  */\n@@ -150,21 +150,21 @@ typedef struct\n      assuming that the user knows what they are doing.  This was the old\n      behaviour of the linker.  The new default behaviour is to reject such\n      input files.  */\n-  bfd_boolean accept_unknown_input_arch;\n+  bool accept_unknown_input_arch;\n \n   /* Name of the import library to generate.  */\n   char *out_implib_filename;\n \n   /* If TRUE we'll just print the default output on stdout.  */\n-  bfd_boolean print_output_format;\n+  bool print_output_format;\n \n   /* If set, display the target memory usage (per memory region).  */\n-  bfd_boolean print_memory_usage;\n+  bool print_memory_usage;\n \n   /* Should we force section groups to be resolved?  Controlled with\n      --force-group-allocation on the command line or FORCE_GROUP_ALLOCATION\n      in the linker script.  */\n-  bfd_boolean force_group_allocation;\n+  bool force_group_allocation;\n \n   /* Big or little endian as set on command line.  */\n   enum endian_enum endian;\n@@ -224,61 +224,61 @@ enum orphan_handling_enum\n \n typedef struct\n {\n-  bfd_boolean magic_demand_paged;\n-  bfd_boolean make_executable;\n+  bool magic_demand_paged;\n+  bool make_executable;\n \n   /* If TRUE, -shared is supported.  */\n   /* ??? A better way to do this is perhaps to define this in the\n      ld_emulation_xfer_struct since this is really a target dependent\n      parameter.  */\n-  bfd_boolean has_shared;\n+  bool has_shared;\n \n   /* If TRUE, build constructors.  */\n-  bfd_boolean build_constructors;\n+  bool build_constructors;\n \n   /* If TRUE, warn about any constructors.  */\n-  bfd_boolean warn_constructors;\n+  bool warn_constructors;\n \n   /* If TRUE, warn about merging common symbols with others.  */\n-  bfd_boolean warn_common;\n+  bool warn_common;\n \n   /* If TRUE, only warn once about a particular undefined symbol.  */\n-  bfd_boolean warn_once;\n+  bool warn_once;\n \n   /* How should we deal with orphan sections.  */\n   enum orphan_handling_enum orphan_handling;\n \n   /* If TRUE, warn if multiple global-pointers are needed (Alpha\n      only).  */\n-  bfd_boolean warn_multiple_gp;\n+  bool warn_multiple_gp;\n \n   /* If TRUE, warn if the starting address of an output section\n      changes due to the alignment of an input section.  */\n-  bfd_boolean warn_section_align;\n+  bool warn_section_align;\n \n   /* If TRUE, warning messages are fatal */\n-  bfd_boolean fatal_warnings;\n+  bool fatal_warnings;\n \n   sort_order sort_common;\n \n-  bfd_boolean text_read_only;\n+  bool text_read_only;\n \n-  bfd_boolean stats;\n+  bool stats;\n \n   /* If set, orphan input sections will be mapped to separate output\n      sections.  */\n-  bfd_boolean unique_orphan_sections;\n+  bool unique_orphan_sections;\n \n   /* If set, only search library directories explicitly selected\n      on the command line.  */\n-  bfd_boolean only_cmd_line_lib_dirs;\n+  bool only_cmd_line_lib_dirs;\n \n   /* If set, numbers and absolute symbols are simply treated as\n      numbers everywhere.  */\n-  bfd_boolean sane_expr;\n+  bool sane_expr;\n \n   /* If set, code and non-code sections should never be in one segment.  */\n-  bfd_boolean separate_code;\n+  bool separate_code;\n \n   /* The rpath separation character.  Usually ':'.  */\n   char rpath_separator;\n@@ -295,25 +295,25 @@ typedef struct\n   unsigned long hash_table_size;\n \n   /* If set, print discarded sections in map file output.  */\n-  bfd_boolean print_map_discarded;\n+  bool print_map_discarded;\n \n   /* If set, emit the names and types of statically-linked variables\n      into the CTF.  */\n-  bfd_boolean ctf_variables;\n+  bool ctf_variables;\n \n   /* If set, share only duplicated types in CTF, rather than sharing\n      all types that are not in conflict.  */\n-  bfd_boolean ctf_share_duplicated;\n+  bool ctf_share_duplicated;\n } ld_config_type;\n \n extern ld_config_type config;\n \n extern FILE * saved_script_handle;\n-extern bfd_boolean force_make_executable;\n+extern bool force_make_executable;\n \n extern int yyparse (void);\n extern void add_cref (const char *, bfd *, asection *, bfd_vma);\n-extern bfd_boolean handle_asneeded_cref (bfd *, enum notice_asneeded_action);\n+extern bool handle_asneeded_cref (bfd *, enum notice_asneeded_action);\n extern void output_cref (FILE *);\n extern void check_nocrossrefs (void);\n extern void ld_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;"
    },
    {
      "sha": "c0e91bcefc975716a4a499a42495e818fb3ecc49",
      "filename": "ld/ldbuildid.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldbuildid.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldbuildid.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldbuildid.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -32,14 +32,14 @@\n #define streq(a,b)     strcmp ((a), (b)) == 0\n #define strneq(a,b,n)  strncmp ((a), (b), (n)) == 0\n \n-bfd_boolean\n+bool\n validate_build_id_style (const char *style)\n {\n   if ((streq (style, \"md5\")) || (streq (style, \"sha1\"))\n       || (streq (style, \"uuid\")) || (strneq (style, \"0x\", 2)))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n bfd_size_type\n@@ -94,7 +94,7 @@ read_hex (const char xdigit)\n   return 0;\n }\n \n-bfd_boolean\n+bool\n generate_build_id (bfd *abfd,\n \t\t   const char *style,\n \t\t   checksum_fn checksum_contents,\n@@ -107,7 +107,7 @@ generate_build_id (bfd *abfd,\n \n       md5_init_ctx (&ctx);\n       if (!(*checksum_contents) (abfd, (sum_fn) &md5_process_bytes, &ctx))\n-\treturn FALSE;\n+\treturn false;\n       md5_finish_ctx (&ctx, id_bits);\n     }\n   else if (streq (style, \"sha1\"))\n@@ -116,7 +116,7 @@ generate_build_id (bfd *abfd,\n \n       sha1_init_ctx (&ctx);\n       if (!(*checksum_contents) (abfd, (sum_fn) &sha1_process_bytes, &ctx))\n-\treturn FALSE;\n+\treturn false;\n       sha1_finish_ctx (&ctx, id_bits);\n     }\n   else if (streq (style, \"uuid\"))\n@@ -126,30 +126,30 @@ generate_build_id (bfd *abfd,\n       int fd = open (\"/dev/urandom\", O_RDONLY);\n \n       if (fd < 0)\n-\treturn FALSE;\n+\treturn false;\n       n = read (fd, id_bits, size);\n       close (fd);\n       if (n < size)\n-\treturn FALSE;\n+\treturn false;\n #else /* __MINGW32__ */\n       typedef RPC_STATUS (RPC_ENTRY * UuidCreateFn) (UUID *);\n       UUID          uuid;\n       UuidCreateFn  uuid_create = 0;\n       HMODULE       rpc_library = LoadLibrary (\"rpcrt4.dll\");\n \n       if (!rpc_library)\n-\treturn FALSE;\n+\treturn false;\n       uuid_create = (UuidCreateFn) (void (WINAPI *)(void)) GetProcAddress (rpc_library, \"UuidCreate\");\n       if (!uuid_create)\n \t{\n \t  FreeLibrary (rpc_library);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (uuid_create (&uuid) != RPC_S_OK)\n \t{\n \t  FreeLibrary (rpc_library);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       FreeLibrary (rpc_library);\n       memcpy (id_bits, &uuid,\n@@ -179,5 +179,5 @@ generate_build_id (bfd *abfd,\n   else\n     abort ();\t\t\t/* Should have been validated earlier.  */\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "7cb9d957dad84e9dd39c11f4798aa998ac7d0a1d",
      "filename": "ld/ldbuildid.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldbuildid.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldbuildid.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldbuildid.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -21,19 +21,19 @@\n #ifndef LDBUILDID_H\n #define LDBUILDID_H\n \n-extern bfd_boolean\n+extern bool\n validate_build_id_style (const char *);\n \n extern bfd_size_type\n compute_build_id_size (const char *);\n \n typedef void (*sum_fn) (const void *, size_t, void *);\n \n-typedef bfd_boolean (*checksum_fn) (bfd *,\n-\t\t\t\t    void (*) (const void *, size_t, void *),\n-\t\t\t\t    void *);\n+typedef bool (*checksum_fn) (bfd *,\n+\t\t\t     void (*) (const void *, size_t, void *),\n+\t\t\t     void *);\n \n-extern bfd_boolean\n+extern bool\n generate_build_id (bfd *, const char *, checksum_fn, unsigned char *, int);\n \n #endif /* LDBUILDID_H */"
    },
    {
      "sha": "1a54bbf438adcb569597bb448340fe56e1080a38",
      "filename": "ld/ldcref.c",
      "status": "modified",
      "additions": 36,
      "deletions": 37,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldcref.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldcref.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldcref.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -77,8 +77,8 @@ struct cref_hash_table\n \n static void output_one_cref (FILE *, struct cref_hash_entry *);\n static void check_local_sym_xref (lang_input_statement_type *);\n-static bfd_boolean check_nocrossref (struct cref_hash_entry *, void *);\n-static void check_refs (const char *, bfd_boolean, asection *, bfd *,\n+static bool check_nocrossref (struct cref_hash_entry *, void *);\n+static void check_refs (const char *, bool, asection *, bfd *,\n \t\t\tstruct lang_nocrossrefs *);\n static void check_reloc_refs (bfd *, asection *, void *);\n \n@@ -93,16 +93,15 @@ static void check_reloc_refs (bfd *, asection *, void *);\n #define cref_hash_traverse(table, func, info)\t\t\t\t\\\n   (bfd_hash_traverse\t\t\t\t\t\t\t\\\n    (&(table)->root,\t\t\t\t\t\t\t\\\n-    (bfd_boolean (*) (struct bfd_hash_entry *, void *)) (func),\t\t\\\n-    (info)))\n+    (bool (*) (struct bfd_hash_entry *, void *)) (func), (info)))\n \n /* The cref hash table.  */\n \n static struct cref_hash_table cref_table;\n \n /* Whether the cref hash table has been initialized.  */\n \n-static bfd_boolean cref_initialized;\n+static bool cref_initialized;\n \n /* The number of symbols seen so far.  */\n \n@@ -169,10 +168,10 @@ add_cref (const char *name,\n       if (!bfd_hash_table_init (&cref_table.root, cref_hash_newfunc,\n \t\t\t\tsizeof (struct cref_hash_entry)))\n \teinfo (_(\"%X%P: bfd_hash_table_init of cref table failed: %E\\n\"));\n-      cref_initialized = TRUE;\n+      cref_initialized = true;\n     }\n \n-  h = cref_hash_lookup (&cref_table, name, TRUE, FALSE);\n+  h = cref_hash_lookup (&cref_table, name, true, false);\n   if (h == NULL)\n     einfo (_(\"%X%P: cref_hash_lookup failed: %E\\n\"));\n \n@@ -188,31 +187,31 @@ add_cref (const char *name,\n       r->next = h->refs;\n       h->refs = r;\n       r->abfd = abfd;\n-      r->def = FALSE;\n-      r->common = FALSE;\n-      r->undef = FALSE;\n+      r->def = false;\n+      r->common = false;\n+      r->undef = false;\n     }\n \n   if (bfd_is_und_section (section))\n-    r->undef = TRUE;\n+    r->undef = true;\n   else if (bfd_is_com_section (section))\n-    r->common = TRUE;\n+    r->common = true;\n   else\n-    r->def = TRUE;\n+    r->def = true;\n }\n \n /* Called before loading an as-needed library to take a snapshot of\n    the cref hash table, and after we have loaded or found that the\n    library was not needed.  */\n \n-bfd_boolean\n+bool\n handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t      enum notice_asneeded_action act)\n {\n   unsigned int i;\n \n   if (!cref_initialized)\n-    return TRUE;\n+    return true;\n \n   if (act == notice_as_needed)\n     {\n@@ -238,7 +237,7 @@ handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,\n \n       alloc_mark = bfd_hash_allocate (&cref_table.root, 1);\n       if (alloc_mark == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       memcpy (old_tab, cref_table.root.table, tabsize);\n       old_ent = (char *) old_tab + tabsize;\n@@ -266,7 +265,7 @@ handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t}\n \t    }\n \t}\n-      return TRUE;\n+      return true;\n     }\n \n   if (act == notice_not_needed)\n@@ -278,8 +277,8 @@ handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,\n \t  /* The only way old_tab can be NULL is if the cref hash table\n \t     had not been initialised when notice_as_needed.  */\n \t  bfd_hash_table_free (&cref_table.root);\n-\t  cref_initialized = FALSE;\n-\t  return TRUE;\n+\t  cref_initialized = false;\n+\t  return true;\n \t}\n \n       old_ent = (char *) old_tab + tabsize;\n@@ -313,18 +312,18 @@ handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t   alloc_mark);\n     }\n   else if (act != notice_needed)\n-    return FALSE;\n+    return false;\n \n   free (old_tab);\n   old_tab = NULL;\n-  return TRUE;\n+  return true;\n }\n \n /* Copy the addresses of the hash table entries into an array.  This\n    is called via cref_hash_traverse.  We also fill in the demangled\n    name.  */\n \n-static bfd_boolean\n+static bool\n cref_fill_array (struct cref_hash_entry *h, void *data)\n {\n   struct cref_hash_entry ***pph = (struct cref_hash_entry ***) data;\n@@ -339,7 +338,7 @@ cref_fill_array (struct cref_hash_entry *h, void *data)\n \n   ++*pph;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Sort an array of cref hash table entries by name.  */\n@@ -408,8 +407,8 @@ output_one_cref (FILE *fp, struct cref_hash_entry *h)\n   struct bfd_link_hash_entry *hl;\n   struct cref_ref *r;\n \n-  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, FALSE,\n-\t\t\t     FALSE, TRUE);\n+  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, false,\n+\t\t\t     false, true);\n   if (hl == NULL)\n     einfo (_(\"%P: symbol `%pT' missing from main hash table\\n\"),\n \t   h->root.string);\n@@ -537,7 +536,7 @@ check_local_sym_xref (lang_input_statement_type *statement)\n \t    for (ncr = ncrs->list; ncr != NULL; ncr = ncr->next)\n \t      {\n \t\tif (strcmp (ncr->name, outsecname) == 0)\n-\t\t  check_refs (symname, FALSE, sym->section, abfd, ncrs);\n+\t\t  check_refs (symname, false, sym->section, abfd, ncrs);\n \t\t/* The NOCROSSREFS_TO command only checks symbols defined in\n \t\t   the first section in the list.  */\n \t\tif (ncrs->onlyfirst)\n@@ -549,7 +548,7 @@ check_local_sym_xref (lang_input_statement_type *statement)\n \n /* Check one symbol to see if it is a prohibited cross reference.  */\n \n-static bfd_boolean\n+static bool\n check_nocrossref (struct cref_hash_entry *h, void *ignore ATTRIBUTE_UNUSED)\n {\n   struct bfd_link_hash_entry *hl;\n@@ -559,38 +558,38 @@ check_nocrossref (struct cref_hash_entry *h, void *ignore ATTRIBUTE_UNUSED)\n   struct lang_nocrossref *ncr;\n   struct cref_ref *ref;\n \n-  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, FALSE,\n-\t\t\t     FALSE, TRUE);\n+  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, false,\n+\t\t\t     false, true);\n   if (hl == NULL)\n     {\n       einfo (_(\"%P: symbol `%pT' missing from main hash table\\n\"),\n \t     h->root.string);\n-      return TRUE;\n+      return true;\n     }\n \n   if (hl->type != bfd_link_hash_defined\n       && hl->type != bfd_link_hash_defweak)\n-    return TRUE;\n+    return true;\n \n   defsec = hl->u.def.section->output_section;\n   if (defsec == NULL)\n-    return TRUE;\n+    return true;\n   defsecname = bfd_section_name (defsec);\n \n   for (ncrs = nocrossref_list; ncrs != NULL; ncrs = ncrs->next)\n     for (ncr = ncrs->list; ncr != NULL; ncr = ncr->next)\n       {\n \tif (strcmp (ncr->name, defsecname) == 0)\n \t  for (ref = h->refs; ref != NULL; ref = ref->next)\n-\t    check_refs (hl->root.string, TRUE, hl->u.def.section,\n+\t    check_refs (hl->root.string, true, hl->u.def.section,\n \t\t\tref->abfd, ncrs);\n \t/* The NOCROSSREFS_TO command only checks symbols defined in the first\n \t   section in the list.  */\n \tif (ncrs->onlyfirst)\n \t  break;\n       }\n \n-  return TRUE;\n+  return true;\n }\n \n /* The struct is used to pass information from check_refs to\n@@ -602,7 +601,7 @@ struct check_refs_info\n   asection *defsec;\n   struct lang_nocrossrefs *ncrs;\n   asymbol **asymbols;\n-  bfd_boolean global;\n+  bool global;\n };\n \n /* This function is called for each symbol defined in a section which\n@@ -612,7 +611,7 @@ struct check_refs_info\n \n static void\n check_refs (const char *name,\n-\t    bfd_boolean global,\n+\t    bool global,\n \t    asection *sec,\n \t    bfd *abfd,\n \t    struct lang_nocrossrefs *ncrs)\n@@ -652,7 +651,7 @@ check_reloc_refs (bfd *abfd, asection *sec, void *iarg)\n   const char *outdefsecname;\n   struct lang_nocrossref *ncr;\n   const char *symname;\n-  bfd_boolean global;\n+  bool global;\n   long relsize;\n   arelent **relpp;\n   long relcount;"
    },
    {
      "sha": "830ec6e87e243f23a7ecf12ba84c9a879619a93c",
      "filename": "ld/ldctor.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldctor.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldctor.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldctor.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -40,7 +40,7 @@ lang_statement_list_type constructor_list;\n /* Whether the constructors should be sorted.  Note that this is\n    global for the entire link; we assume that there is only a single\n    CONSTRUCTORS command in the linker script.  */\n-bfd_boolean constructors_sorted;\n+bool constructors_sorted;\n \n /* The sets we have seen.  */\n struct set_info *sets;\n@@ -195,15 +195,15 @@ ctor_cmp (const void *p1, const void *p2)\n void\n ldctor_build_sets (void)\n {\n-  static bfd_boolean called;\n-  bfd_boolean header_printed;\n+  static bool called;\n+  bool header_printed;\n   struct set_info *p;\n \n   /* The emulation code may call us directly, but we only want to do\n      this once.  */\n   if (called)\n     return;\n-  called = TRUE;\n+  called = true;\n \n   if (constructors_sorted)\n     {\n@@ -246,7 +246,7 @@ ldctor_build_sets (void)\n   lang_list_init (&constructor_list);\n   push_stat_ptr (&constructor_list);\n \n-  header_printed = FALSE;\n+  header_printed = false;\n   for (p = sets; p != NULL; p = p->next)\n     {\n       struct set_element *e;\n@@ -326,10 +326,10 @@ ldctor_build_sets (void)\n       lang_add_assignment (exp_assign (\".\",\n \t\t\t\t       exp_unop (ALIGN_K,\n \t\t\t\t\t\t exp_intop (reloc_size)),\n-\t\t\t\t       FALSE));\n+\t\t\t\t       false));\n       lang_add_assignment (exp_assign (p->h->root.string,\n \t\t\t\t       exp_nameop (NAME, \".\"),\n-\t\t\t\t       FALSE));\n+\t\t\t\t       false));\n       lang_add_data (size, exp_intop (p->count));\n \n       for (e = p->elements; e != NULL; e = e->u.next)\n@@ -341,7 +341,7 @@ ldctor_build_sets (void)\n \t      if (!header_printed)\n \t\t{\n \t\t  minfo (_(\"\\nSet                 Symbol\\n\\n\"));\n-\t\t  header_printed = TRUE;\n+\t\t  header_printed = true;\n \t\t}\n \n \t      minfo (\"%s\", p->h->root.string);"
    },
    {
      "sha": "6efe349bb833b9e3d9a66a830a84e9092ac77c0f",
      "filename": "ld/ldctor.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldctor.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldctor.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldctor.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -27,7 +27,7 @@ extern lang_statement_list_type constructor_list;\n /* Whether the constructors should be sorted.  Note that this is\n    global for the entire link; we assume that there is only a single\n    CONSTRUCTORS command in the linker script.  */\n-extern bfd_boolean constructors_sorted;\n+extern bool constructors_sorted;\n \n /* We keep a list of these structures for each set we build.  */\n "
    },
    {
      "sha": "631d11b921748216b1d7345f35f4cf706a9a9f64",
      "filename": "ld/ldelf.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -56,7 +56,7 @@ static struct bfd_link_needed_list *global_needed;\n static lang_input_statement_type *global_found;\n static struct stat global_stat;\n static struct bfd_link_needed_list *global_vercheck_needed;\n-static bfd_boolean global_vercheck_failed;\n+static bool global_vercheck_failed;\n \n void\n ldelf_after_parse (void)\n@@ -76,7 +76,7 @@ ldelf_after_parse (void)\n \n /* Handle the generation of DT_NEEDED tags.  */\n \n-bfd_boolean\n+bool\n ldelf_load_symbols (lang_input_statement_type *entry)\n {\n   int link_class = 0;\n@@ -100,13 +100,13 @@ ldelf_load_symbols (lang_input_statement_type *entry)\n \n   if (link_class == 0\n       || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)\n-    return FALSE;\n+    return false;\n \n   bfd_elf_set_dyn_lib_class (entry->the_bfd,\n \t\t\t     (enum dynamic_lib_link_class) link_class);\n \n   /* Continue on with normal load_symbols processing.  */\n-  return FALSE;\n+  return false;\n }\n \n /* On Linux, it's possible to have different versions of the same\n@@ -168,7 +168,7 @@ ldelf_vercheck (lang_input_statement_type *s)\n \t     FOO.SO.VER2, and VER1 and VER2 are different.  This\n \t     appears to be a version mismatch, so we tell the caller\n \t     to try a different version of this library.  */\n-\t  global_vercheck_failed = TRUE;\n+\t  global_vercheck_failed = true;\n \t  return;\n \t}\n     }\n@@ -246,7 +246,7 @@ ldelf_stat_needed (lang_input_statement_type *s)\n    named by a DT_NEEDED entry.  The FORCE parameter indicates whether\n    to skip the check for a conflicting version.  */\n \n-static bfd_boolean\n+static bool\n ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n {\n   bfd *abfd;\n@@ -259,7 +259,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n     {\n       if (verbose)\n \tinfo_msg (_(\"attempt to open %s failed\\n\"), name);\n-      return FALSE;\n+      return false;\n     }\n \n   track_dependency_files (name);\n@@ -270,19 +270,19 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n   if (! bfd_check_format (abfd, bfd_object))\n     {\n       bfd_close (abfd);\n-      return FALSE;\n+      return false;\n     }\n   if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)\n     {\n       bfd_close (abfd);\n-      return FALSE;\n+      return false;\n     }\n \n   /* For DT_NEEDED, they have to match.  */\n   if (abfd->xvec != link_info.output_bfd->xvec)\n     {\n       bfd_close (abfd);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Check whether this object would include any conflicting library\n@@ -300,14 +300,14 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n       if (needs != NULL)\n \t{\n \t  global_vercheck_needed = needs;\n-\t  global_vercheck_failed = FALSE;\n+\t  global_vercheck_failed = false;\n \t  lang_for_each_input_file (ldelf_vercheck);\n \t  if (global_vercheck_failed)\n \t    {\n \t      bfd_close (abfd);\n \t      /* Return FALSE to force the caller to move on to try\n \t\t another file on the search path.  */\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* But wait!  It gets much worse.  On Linux, if a shared\n@@ -326,7 +326,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n \t      if (l == NULL)\n \t\t{\n \t\t  bfd_close (abfd);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t}\n@@ -357,7 +357,7 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n     {\n       /* Return TRUE to indicate that we found the file, even though\n \t we aren't going to do anything with it.  */\n-      return TRUE;\n+      return true;\n     }\n \n   /* Specify the soname to use.  */\n@@ -384,12 +384,12 @@ ldelf_try_needed (struct dt_needed *needed, int force, int is_linux)\n   if (! bfd_link_add_symbols (abfd, &link_info))\n     einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), abfd);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Search for a needed file in a path.  */\n \n-static bfd_boolean\n+static bool\n ldelf_search_needed (const char *path, struct dt_needed *n, int force,\n \t\t     int is_linux, int elfsize)\n {\n@@ -402,7 +402,7 @@ ldelf_search_needed (const char *path, struct dt_needed *n, int force,\n     return ldelf_try_needed (n, force, is_linux);\n \n   if (path == NULL || *path == '\\0')\n-    return FALSE;\n+    return false;\n \n   needed.by = n->by;\n   needed.name = n->name;\n@@ -586,7 +586,7 @@ ldelf_search_needed (const char *path, struct dt_needed *n, int force,\n       needed.name = filename;\n \n       if (ldelf_try_needed (&needed, force, is_linux))\n-\treturn TRUE;\n+\treturn true;\n \n       free (filename);\n \n@@ -595,7 +595,7 @@ ldelf_search_needed (const char *path, struct dt_needed *n, int force,\n       path = s + 1;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Prefix the sysroot to absolute paths in PATH, a string containing\n@@ -687,11 +687,11 @@ ldelf_add_sysroot (const char *path)\n #include \"elf-hints-local.h\"\n #endif\n \n-static bfd_boolean\n+static bool\n ldelf_check_ld_elf_hints (const struct bfd_link_needed_list *l, int force,\n \t\t\t  int elfsize)\n {\n-  static bfd_boolean initialized;\n+  static bool initialized;\n   static const char *ld_elf_hints;\n   struct dt_needed needed;\n \n@@ -726,15 +726,15 @@ ldelf_check_ld_elf_hints (const struct bfd_link_needed_list *l, int force,\n \t  fclose (f);\n \t}\n \n-      initialized = TRUE;\n+      initialized = true;\n     }\n \n   if (ld_elf_hints == NULL)\n-    return FALSE;\n+    return false;\n \n   needed.by = l->by;\n   needed.name = l->name;\n-  return ldelf_search_needed (ld_elf_hints, &needed, force, FALSE, elfsize);\n+  return ldelf_search_needed (ld_elf_hints, &needed, force, false, elfsize);\n }\n \n /* For a native linker, check the file /etc/ld.so.conf for directories\n@@ -747,7 +747,7 @@ struct ldelf_ld_so_conf\n   size_t len, alloc;\n };\n \n-static bfd_boolean\n+static bool\n ldelf_parse_ld_so_conf (struct ldelf_ld_so_conf *, const char *);\n \n static void\n@@ -788,15 +788,15 @@ ldelf_parse_ld_so_conf_include (struct ldelf_ld_so_conf *info,\n   free (newp);\n }\n \n-static bfd_boolean\n+static bool\n ldelf_parse_ld_so_conf (struct ldelf_ld_so_conf *info, const char *filename)\n {\n   FILE *f = fopen (filename, FOPEN_RT);\n   char *line;\n   size_t linelen;\n \n   if (f == NULL)\n-    return FALSE;\n+    return false;\n \n   linelen = 256;\n   line = xmalloc (linelen);\n@@ -893,14 +893,14 @@ ldelf_parse_ld_so_conf (struct ldelf_ld_so_conf *info, const char *filename)\n   while (! feof (f));\n   free (line);\n   fclose (f);\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n ldelf_check_ld_so_conf (const struct bfd_link_needed_list *l, int force,\n \t\t\tint elfsize, const char *prefix)\n {\n-  static bfd_boolean initialized;\n+  static bool initialized;\n   static const char *ld_so_conf;\n   struct dt_needed needed;\n \n@@ -927,16 +927,16 @@ ldelf_check_ld_so_conf (const struct bfd_link_needed_list *l, int force,\n \t  ld_so_conf = ldelf_add_sysroot (info.path);\n \t  free (info.path);\n \t}\n-      initialized = TRUE;\n+      initialized = true;\n     }\n \n   if (ld_so_conf == NULL)\n-    return FALSE;\n+    return false;\n \n \n   needed.by = l->by;\n   needed.name = l->name;\n-  return ldelf_search_needed (ld_so_conf, &needed, force, TRUE, elfsize);\n+  return ldelf_search_needed (ld_so_conf, &needed, force, true, elfsize);\n }\n \n /* See if an input file matches a DT_NEEDED entry by name.  */\n@@ -1073,7 +1073,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n   if (!link_info.traditional_format)\n     {\n       bfd *elfbfd = NULL;\n-      bfd_boolean warn_eh_frame = FALSE;\n+      bool warn_eh_frame = false;\n       int seen_type = 0;\n \n       for (abfd = link_info.input_bfds; abfd; abfd = abfd->link.next)\n@@ -1116,7 +1116,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n \t\t  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n \t\t    elfbfd = abfd;\n \n-\t\t  warn_eh_frame = TRUE;\n+\t\t  warn_eh_frame = true;\n \t\t}\n \t    }\n \n@@ -1135,7 +1135,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n \t      && bfd_set_section_alignment (s, 2))\n \t    {\n \t      htab->eh_info.hdr_sec = s;\n-\t      warn_eh_frame = FALSE;\n+\t      warn_eh_frame = false;\n \t    }\n \t}\n       if (warn_eh_frame)\n@@ -1202,7 +1202,7 @@ ldelf_after_open (int use_libpath, int native, int is_linux, int is_freebsd,\n       if (global_found != NULL)\n \t{\n \t  nn.name = global_found->filename;\n-\t  if (ldelf_try_needed (&nn, TRUE, is_linux))\n+\t  if (ldelf_try_needed (&nn, true, is_linux))\n \t    continue;\n \t}\n \n@@ -1347,7 +1347,7 @@ id_note_section_size (bfd *abfd ATTRIBUTE_UNUSED)\n   return size;\n }\n \n-static bfd_boolean\n+static bool\n write_build_id (bfd *abfd)\n {\n   const struct elf_backend_data *bed = get_elf_backend_data (abfd);\n@@ -1366,7 +1366,7 @@ write_build_id (bfd *abfd)\n     {\n       einfo (_(\"%P: warning: .note.gnu.build-id section discarded,\"\n \t       \" --build-id ignored\\n\"));\n-      return TRUE;\n+      return true;\n     }\n   i_shdr = &elf_section_data (asec->output_section)->this_hdr;\n \n@@ -1400,7 +1400,7 @@ write_build_id (bfd *abfd)\n \n /* Make .note.gnu.build-id section, and set up elf_tdata->build_id.  */\n \n-bfd_boolean\n+bool\n ldelf_setup_build_id (bfd *ibfd)\n {\n   asection *s;\n@@ -1411,7 +1411,7 @@ ldelf_setup_build_id (bfd *ibfd)\n   if (size == 0)\n     {\n       einfo (_(\"%P: warning: unrecognized --build-id style ignored\\n\"));\n-      return FALSE;\n+      return false;\n     }\n \n   flags = (SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY\n@@ -1425,26 +1425,26 @@ ldelf_setup_build_id (bfd *ibfd)\n       t->o->build_id.sec = s;\n       elf_section_type (s) = SHT_NOTE;\n       s->size = size;\n-      return TRUE;\n+      return true;\n     }\n \n   einfo (_(\"%P: warning: cannot create .note.gnu.build-id section,\"\n \t   \" --build-id ignored\\n\"));\n-  return FALSE;\n+  return false;\n }\n \n /* Look through an expression for an assignment statement.  */\n \n static void\n ldelf_find_exp_assignment (etree_type *exp)\n {\n-  bfd_boolean provide = FALSE;\n+  bool provide = false;\n \n   switch (exp->type.node_class)\n     {\n     case etree_provide:\n     case etree_provided:\n-      provide = TRUE;\n+      provide = true;\n       /* Fallthru */\n     case etree_assign:\n       /* We call record_link_assignment even if the symbol is defined.\n@@ -1564,7 +1564,7 @@ ldelf_before_allocation (char *audit, char *depaudit,\n \t{\n \t  struct elf_link_hash_table *htab = elf_hash_table (&link_info);\n \t  struct elf_link_hash_entry *h\n-\t    = elf_link_hash_lookup (htab, \"__ehdr_start\", FALSE, FALSE, TRUE);\n+\t    = elf_link_hash_lookup (htab, \"__ehdr_start\", false, false, true);\n \n \t  /* Only adjust the export class if the symbol was referenced\n \t     and not defined, otherwise leave it alone.  */\n@@ -1576,7 +1576,7 @@ ldelf_before_allocation (char *audit, char *depaudit,\n \t    {\n \t      const struct elf_backend_data *bed;\n \t      bed = get_elf_backend_data (link_info.output_bfd);\n-\t      (*bed->elf_backend_hide_symbol) (&link_info, h, TRUE);\n+\t      (*bed->elf_backend_hide_symbol) (&link_info, h, true);\n \t      if (ELF_ST_VISIBILITY (h->other) != STV_INTERNAL)\n \t\th->other = (h->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;\n \t      /* Don't leave the symbol undefined.  Undefined hidden\n@@ -1725,17 +1725,17 @@ ldelf_before_allocation (char *audit, char *depaudit,\n    dynamic libraries have an extension of .so (or .sl on oddball systems\n    like hpux).  */\n \n-bfd_boolean\n+bool\n ldelf_open_dynamic_archive (const char *arch, search_dirs_type *search,\n \t\t\t    lang_input_statement_type *entry)\n {\n   const char *filename;\n   char *string;\n   size_t len;\n-  bfd_boolean opened = FALSE;\n+  bool opened = false;\n \n   if (! entry->flags.maybe_archive)\n-    return FALSE;\n+    return false;\n \n   filename = entry->filename;\n   len = strlen (search->name) + strlen (filename);\n@@ -1769,7 +1769,7 @@ ldelf_open_dynamic_archive (const char *arch, search_dirs_type *search,\n   if (!opened && !ldfile_try_open_bfd (string, entry))\n     {\n       free (string);\n-      return FALSE;\n+      return false;\n     }\n \n   entry->filename = string;\n@@ -1800,7 +1800,7 @@ ldelf_open_dynamic_archive (const char *arch, search_dirs_type *search,\n       bfd_elf_set_dt_needed_name (entry->the_bfd, filename);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* A variant of lang_output_section_find used by place_orphan.  */\n@@ -1869,7 +1869,7 @@ output_rel_find (int isdyn, int rela)\n \n /* Return whether IN is suitable to be part of OUT.  */\n \n-static bfd_boolean\n+static bool\n elf_orphan_compatible (asection *in, asection *out)\n {\n   /* Non-zero sh_info implies a section with SHF_INFO_LINK with\n@@ -1880,15 +1880,15 @@ elf_orphan_compatible (asection *in, asection *out)\n      shouldn't merge sections with differing unknown semantics.  */\n   if (elf_section_data (out)->this_hdr.sh_info\n       != elf_section_data (in)->this_hdr.sh_info)\n-    return FALSE;\n+    return false;\n   /* We can't merge with a member of an output section group or merge\n      two sections with differing SHF_EXCLUDE or other processor and OS\n      specific flags when doing a relocatable link.  */\n   if (bfd_link_relocatable (&link_info)\n       && (elf_next_in_group (out) != NULL\n \t  || ((elf_section_flags (out) ^ elf_section_flags (in))\n \t      & (SHF_MASKPROC | SHF_MASKOS)) != 0))\n-    return FALSE;\n+    return false;\n   return _bfd_elf_match_sections_by_type (link_info.output_bfd, out,\n \t\t\t\t\t  in->owner, in);\n }"
    },
    {
      "sha": "267dd3ba192499049d841fcb11835668fbb9bfe7",
      "filename": "ld/ldelf.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -21,12 +21,12 @@\n extern const char *ldelf_emit_note_gnu_build_id;\n \n extern void ldelf_after_parse (void);\n-extern bfd_boolean ldelf_load_symbols (lang_input_statement_type *);\n+extern bool ldelf_load_symbols (lang_input_statement_type *);\n extern void ldelf_after_open (int, int, int, int, int, const char *);\n-extern bfd_boolean ldelf_setup_build_id (bfd *);\n+extern bool ldelf_setup_build_id (bfd *);\n extern void ldelf_append_to_separated_string (char **, char *);\n extern void ldelf_before_allocation (char *, char *, const char *);\n-extern bfd_boolean ldelf_open_dynamic_archive\n+extern bool ldelf_open_dynamic_archive\n   (const char *, search_dirs_type *, lang_input_statement_type *);\n extern lang_output_section_statement_type *ldelf_place_orphan\n   (asection *, const char *, int);"
    },
    {
      "sha": "495fa8451fcc683e6c615ce2fd95cc59a9dfdcd7",
      "filename": "ld/ldelfgen.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelfgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelfgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -52,7 +52,7 @@ struct os_sections\n \n /* Add IS to data kept for OS.  */\n \n-static bfd_boolean\n+static bool\n add_link_order_input_section (lang_input_section_type *is,\n \t\t\t      lang_output_section_statement_type *os)\n {\n@@ -83,40 +83,40 @@ add_link_order_input_section (lang_input_section_type *is,\n       && (s->flags & SEC_LINKER_CREATED) == 0\n       && elf_linked_to_section (s) != NULL)\n     os_info->ordered++;\n-  return FALSE;\n+  return false;\n }\n \n /* Run over the linker's statement list, extracting info about input\n    sections attached to each output section.  */\n \n-static bfd_boolean\n+static bool\n link_order_scan (lang_statement_union_type *u,\n \t\t lang_output_section_statement_type *os)\n {\n   asection *s;\n-  bfd_boolean ret = FALSE;\n+  bool ret = false;\n \n   for (; u != NULL; u = u->header.next)\n     {\n       switch (u->header.type)\n \t{\n \tcase lang_wild_statement_enum:\n \t  if (link_order_scan (u->wild_statement.children.head, os))\n-\t    ret = TRUE;\n+\t    ret = true;\n \t  break;\n \tcase lang_constructors_statement_enum:\n \t  if (link_order_scan (constructor_list.head, os))\n-\t    ret = TRUE;\n+\t    ret = true;\n \t  break;\n \tcase lang_output_section_statement_enum:\n \t  if (u->output_section_statement.constraint != -1\n \t      && link_order_scan (u->output_section_statement.children.head,\n \t\t\t\t  &u->output_section_statement))\n-\t    ret = TRUE;\n+\t    ret = true;\n \t  break;\n \tcase lang_group_statement_enum:\n \t  if (link_order_scan (u->group_statement.children.head, os))\n-\t    ret = TRUE;\n+\t    ret = true;\n \t  break;\n \tcase lang_input_section_enum:\n \t  s = u->input_section.section;\n@@ -127,7 +127,7 @@ link_order_scan (lang_statement_union_type *u,\n \t\t  || ((s->output_section->flags & (SEC_LOAD | SEC_THREAD_LOCAL))\n \t\t      == (SEC_LOAD | SEC_THREAD_LOCAL))))\n \t    if (add_link_order_input_section (&u->input_section, os))\n-\t      ret = TRUE;\n+\t      ret = true;\n \t  break;\n \tdefault:\n \t  break;\n@@ -195,7 +195,7 @@ compare_link_order (const void *a, const void *b)\n /* Rearrange sections with SHF_LINK_ORDER into the same order as their\n    linked sections.  */\n \n-static bfd_boolean\n+static bool\n fixup_link_order (lang_output_section_statement_type *os)\n {\n   struct os_sections *os_info = os->data;\n@@ -223,7 +223,7 @@ fixup_link_order (lang_output_section_statement_type *os)\n     if (os_info->isec[i].idx != i)\n       break;\n   if (i == os_info->count)\n-    return FALSE;\n+    return false;\n \n   /* Now reorder the linker input section statements to reflect the\n      proper sorting.  The is done by rewriting the existing statements\n@@ -247,27 +247,27 @@ fixup_link_order (lang_output_section_statement_type *os)\n       }\n   free (save_s);\n   free (orig_is);\n-  return TRUE;\n+  return true;\n }\n \n void\n-ldelf_map_segments (bfd_boolean need_layout)\n+ldelf_map_segments (bool need_layout)\n {\n   int tries = 10;\n-  static bfd_boolean done_link_order_scan = FALSE;\n+  static bool done_link_order_scan = false;\n \n   do\n     {\n       lang_relax_sections (need_layout);\n-      need_layout = FALSE;\n+      need_layout = false;\n \n       if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour)\n \t{\n \t  lang_output_section_statement_type *os;\n \t  if (!done_link_order_scan)\n \t    {\n \t      link_order_scan (statement_list.head, NULL);\n-\t      done_link_order_scan = TRUE;\n+\t      done_link_order_scan = true;\n \t    }\n \t  for (os = (void *) lang_os_list.head; os != NULL; os = os->next)\n \t    {\n@@ -284,7 +284,7 @@ ldelf_map_segments (bfd_boolean need_layout)\n \t\t    }\n \t\t  if (os_info->count > 1\n \t\t      && fixup_link_order (os))\n-\t\t    need_layout = TRUE;\n+\t\t    need_layout = true;\n \t\t}\n \t    }\n \t}\n@@ -308,11 +308,11 @@ ldelf_map_segments (bfd_boolean need_layout)\n \t      if (tries > 6)\n \t\t/* The first few times we allow any change to\n \t\t   phdr_size .  */\n-\t\tneed_layout = TRUE;\n+\t\tneed_layout = true;\n \t      else if (phdr_size\n \t\t       < elf_program_header_size (link_info.output_bfd))\n \t\t/* After that we only allow the size to grow.  */\n-\t\tneed_layout = TRUE;\n+\t\tneed_layout = true;\n \t      else\n \t\telf_program_header_size (link_info.output_bfd) = phdr_size;\n \t    }"
    },
    {
      "sha": "704893bf853e6bd7d7b182f46b8d0f255c6b26a1",
      "filename": "ld/ldelfgen.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelfgen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldelfgen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -22,7 +22,7 @@ struct elf_internal_sym;\n struct elf_strtab_hash;\n struct ctf_dict;\n \n-extern void ldelf_map_segments (bfd_boolean);\n+extern void ldelf_map_segments (bool);\n extern int ldelf_emit_ctf_early (void);\n extern void ldelf_acquire_strings_for_ctf\n   (struct ctf_dict *ctf_output, struct elf_strtab_hash *strtab);"
    },
    {
      "sha": "9c51af0bd6da411fe76a22b27ab5dfba96821db1",
      "filename": "ld/ldemul.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldemul.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldemul.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldemul.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -121,13 +121,13 @@ ldemul_get_script (int *isfile)\n   return ld_emulation->get_script (isfile);\n }\n \n-bfd_boolean\n+bool\n ldemul_open_dynamic_archive (const char *arch, search_dirs_type *search,\n \t\t\t     lang_input_statement_type *entry)\n {\n   if (ld_emulation->open_dynamic_archive)\n     return (*ld_emulation->open_dynamic_archive) (arch, search, entry);\n-  return FALSE;\n+  return false;\n }\n \n lang_output_section_statement_type *\n@@ -148,41 +148,41 @@ ldemul_add_options (int ns, char **shortopts, int nl,\n \t\t\t\t  nrl, really_longopts);\n }\n \n-bfd_boolean\n+bool\n ldemul_handle_option (int optc)\n {\n   if (ld_emulation->handle_option)\n     return (*ld_emulation->handle_option) (optc);\n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n ldemul_parse_args (int argc, char **argv)\n {\n   /* Try and use the emulation parser if there is one.  */\n   if (ld_emulation->parse_args)\n     return (*ld_emulation->parse_args) (argc, argv);\n-  return FALSE;\n+  return false;\n }\n \n /* Let the emulation code handle an unrecognized file.  */\n \n-bfd_boolean\n+bool\n ldemul_unrecognized_file (lang_input_statement_type *entry)\n {\n   if (ld_emulation->unrecognized_file)\n     return (*ld_emulation->unrecognized_file) (entry);\n-  return FALSE;\n+  return false;\n }\n \n /* Let the emulation code handle a recognized file.  */\n \n-bfd_boolean\n+bool\n ldemul_recognized_file (lang_input_statement_type *entry)\n {\n   if (ld_emulation->recognized_file)\n     return (*ld_emulation->recognized_file) (entry);\n-  return FALSE;\n+  return false;\n }\n \n char *\n@@ -220,7 +220,7 @@ after_parse_default (void)\n   if (entry_symbol.name != NULL\n       && (bfd_link_executable (&link_info) || entry_from_cmdline))\n     {\n-      bfd_boolean is_vma = FALSE;\n+      bool is_vma = false;\n \n       if (entry_from_cmdline)\n \t{\n@@ -242,25 +242,25 @@ after_parse_default (void)\n void\n after_open_default (void)\n {\n-  link_info.big_endian = TRUE;\n+  link_info.big_endian = true;\n \n   if (bfd_big_endian (link_info.output_bfd))\n     ;\n   else if (bfd_little_endian (link_info.output_bfd))\n-    link_info.big_endian = FALSE;\n+    link_info.big_endian = false;\n   else\n     {\n       if (command_line.endian == ENDIAN_BIG)\n \t;\n       else if (command_line.endian == ENDIAN_LITTLE)\n-\tlink_info.big_endian = FALSE;\n+\tlink_info.big_endian = false;\n       else if (command_line.endian == ENDIAN_UNSET)\n \t{\n \t  LANG_FOR_EACH_INPUT_STATEMENT (s)\n \t    if (s->the_bfd != NULL)\n \t      {\n \t\tif (bfd_little_endian (s->the_bfd))\n-\t\t  link_info.big_endian = FALSE;\n+\t\t  link_info.big_endian = false;\n \t\tbreak;\n \t      }\n \t}\n@@ -280,7 +280,7 @@ before_place_orphans_default (void)\n void\n after_allocation_default (void)\n {\n-  lang_relax_sections (FALSE);\n+  lang_relax_sections (false);\n }\n \n void\n@@ -344,12 +344,12 @@ void\n ldemul_list_emulations (FILE *f)\n {\n   ld_emulation_xfer_type **eptr = ld_emulations;\n-  bfd_boolean first = TRUE;\n+  bool first = true;\n \n   for (; *eptr; eptr++)\n     {\n       if (first)\n-\tfirst = FALSE;\n+\tfirst = false;\n       else\n \tfprintf (f, \" \");\n       fprintf (f, \"%s\", (*eptr)->emulation_name);\n@@ -430,7 +430,7 @@ ldemul_new_dynsym_for_ctf (struct ctf_dict *ctf_output, int symidx,\n     ld_emulation->new_dynsym_for_ctf (ctf_output, symidx, sym);\n }\n \n-bfd_boolean\n+bool\n ldemul_print_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)\n {\n   if (ld_emulation->print_symbol)"
    },
    {
      "sha": "1e0bdc07786daa4d8d97270455415637852cc267",
      "filename": "ld/ldemul.h",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldemul.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldemul.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldemul.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -62,17 +62,17 @@ extern void ldemul_create_output_section_statements\n   (void);\n extern lang_output_section_statement_type *ldemul_place_orphan\n   (asection *, const char *, int);\n-extern bfd_boolean ldemul_parse_args\n+extern bool ldemul_parse_args\n   (int, char **);\n extern void ldemul_add_options\n   (int, char **, int, struct option **, int, struct option **);\n-extern bfd_boolean ldemul_handle_option\n+extern bool ldemul_handle_option\n   (int);\n-extern bfd_boolean ldemul_unrecognized_file\n+extern bool ldemul_unrecognized_file\n   (struct lang_input_statement_struct *);\n-extern bfd_boolean ldemul_recognized_file\n+extern bool ldemul_recognized_file\n   (struct lang_input_statement_struct *);\n-extern bfd_boolean ldemul_open_dynamic_archive\n+extern bool ldemul_open_dynamic_archive\n   (const char *, struct search_dirs *, struct lang_input_statement_struct *);\n extern char *ldemul_default_target\n   (int, char**);\n@@ -114,7 +114,7 @@ extern void ldemul_acquire_strings_for_ctf\n extern void ldemul_new_dynsym_for_ctf\n   (struct ctf_dict *, int symidx, struct elf_internal_sym *);\n \n-extern bfd_boolean ldemul_print_symbol\n+extern bool ldemul_print_symbol\n   (struct bfd_link_hash_entry *hash_entry, void *ptr);\n \n typedef struct ld_emulation_xfer_struct {\n@@ -170,7 +170,7 @@ typedef struct ld_emulation_xfer_struct {\n   /* Try to open a dynamic library.  ARCH is an architecture name, and\n      is normally the empty string.  ENTRY is the lang_input_statement\n      that should be opened.  */\n-  bfd_boolean (*open_dynamic_archive)\n+  bool (*open_dynamic_archive)\n     (const char *arch, struct search_dirs *,\n      struct lang_input_statement_struct *entry);\n \n@@ -186,7 +186,7 @@ typedef struct ld_emulation_xfer_struct {\n \n   /* Parse args which the base linker doesn't understand.\n      Return TRUE if the arg needs no further processing.  */\n-  bfd_boolean (*parse_args) (int, char **);\n+  bool (*parse_args) (int, char **);\n \n   /* Hook to add options to parameters passed by the base linker to\n      getopt_long and getopt_long_only calls.  */\n@@ -195,19 +195,19 @@ typedef struct ld_emulation_xfer_struct {\n \n   /* Companion to the above to handle an option.  Returns TRUE if it is\n      one of our options.  */\n-  bfd_boolean (*handle_option) (int);\n+  bool (*handle_option) (int);\n \n   /* Run to handle files which are not recognized as object files or\n      archives.  Return TRUE if the file was handled.  */\n-  bfd_boolean (*unrecognized_file)\n+  bool (*unrecognized_file)\n     (struct lang_input_statement_struct *);\n \n   /* Run to list the command line options which parse_args handles.  */\n   void (* list_options) (FILE *);\n \n   /* Run to specially handle files which *are* recognized as object\n      files or archives.  Return TRUE if the file was handled.  */\n-  bfd_boolean (*recognized_file)\n+  bool (*recognized_file)\n     (struct lang_input_statement_struct *);\n \n   /* Called when looking for libraries in a directory specified\n@@ -251,7 +251,7 @@ typedef struct ld_emulation_xfer_struct {\n \n   /* Called when printing a symbol to the map file.   AIX uses this\n      hook to flag gc'd symbols.  */\n-  bfd_boolean (*print_symbol)\n+  bool (*print_symbol)\n     (struct bfd_link_hash_entry *hash_entry, void *ptr);\n \n } ld_emulation_xfer_type;"
    },
    {
      "sha": "2efbec658be07dad40f112d14418591c8a0c0c3d",
      "filename": "ld/ldexp.c",
      "status": "modified",
      "additions": 62,
      "deletions": 62,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -161,14 +161,14 @@ make_log2ceil (void)\n {\n   bfd_vma value = expld.result.value;\n   bfd_vma result = -1;\n-  bfd_boolean round_up = FALSE;\n+  bool round_up = false;\n \n   do\n     {\n       result++;\n       /* If more than one bit is set in the value we will need to round up.  */\n       if ((value > 1) && (value & 1))\n-\tround_up = TRUE;\n+\tround_up = true;\n     }\n   while (value >>= 1);\n \n@@ -184,13 +184,13 @@ make_abs (void)\n   if (expld.result.section != NULL)\n     expld.result.value += expld.result.section->vma;\n   expld.result.section = bfd_abs_section_ptr;\n-  expld.rel_from_abs = FALSE;\n+  expld.rel_from_abs = false;\n }\n \n static void\n new_abs (bfd_vma value)\n {\n-  expld.result.valid_p = TRUE;\n+  expld.result.valid_p = true;\n   expld.result.section = bfd_abs_section_ptr;\n   expld.result.value = value;\n   expld.result.str = NULL;\n@@ -240,7 +240,7 @@ exp_relop (asection *section, bfd_vma value)\n static void\n new_number (bfd_vma value)\n {\n-  expld.result.valid_p = TRUE;\n+  expld.result.valid_p = true;\n   expld.result.value = value;\n   expld.result.str = NULL;\n   expld.result.section = NULL;\n@@ -249,7 +249,7 @@ new_number (bfd_vma value)\n static void\n new_rel (bfd_vma value, asection *section)\n {\n-  expld.result.valid_p = TRUE;\n+  expld.result.valid_p = true;\n   expld.result.value = value;\n   expld.result.str = NULL;\n   expld.result.section = section;\n@@ -260,8 +260,8 @@ new_rel_from_abs (bfd_vma value)\n {\n   asection *s = expld.section;\n \n-  expld.rel_from_abs = TRUE;\n-  expld.result.valid_p = TRUE;\n+  expld.rel_from_abs = true;\n+  expld.result.valid_p = true;\n   expld.result.value = value - s->vma;\n   expld.result.str = NULL;\n   expld.result.section = s;\n@@ -297,26 +297,26 @@ static struct definedness_hash_entry *\n symbol_defined (const char *name)\n {\n   return ((struct definedness_hash_entry *)\n-\t  bfd_hash_lookup (&definedness_table, name, FALSE, FALSE));\n+\t  bfd_hash_lookup (&definedness_table, name, false, false));\n }\n \n /* Update the definedness state of NAME.  Return FALSE if script symbol\n    is multiply defining a strong symbol in an object.  */\n \n-static bfd_boolean\n+static bool\n update_definedness (const char *name, struct bfd_link_hash_entry *h)\n {\n-  bfd_boolean ret;\n+  bool ret;\n   struct definedness_hash_entry *defentry\n     = (struct definedness_hash_entry *)\n-    bfd_hash_lookup (&definedness_table, name, TRUE, FALSE);\n+    bfd_hash_lookup (&definedness_table, name, true, false);\n \n   if (defentry == NULL)\n     einfo (_(\"%F%P: bfd_hash_lookup failed creating symbol %s\\n\"), name);\n \n   /* If the symbol was already defined, and not by a script, then it\n      must be defined by an object file or by the linker target code.  */\n-  ret = TRUE;\n+  ret = true;\n   if (!h->ldscript_def\n       && (h->type == bfd_link_hash_defined\n \t  || h->type == bfd_link_hash_defweak\n@@ -326,7 +326,7 @@ update_definedness (const char *name, struct bfd_link_hash_entry *h)\n       if (h->type == bfd_link_hash_defined\n \t  && h->u.def.section->output_section != NULL\n \t  && !h->linker_def)\n-\tret = FALSE;\n+\tret = false;\n     }\n \n   defentry->iteration = lang_statement_iteration;\n@@ -344,7 +344,7 @@ fold_segment_end (seg_align_type *seg)\n   if (expld.phase == lang_first_phase_enum\n       || expld.section != bfd_abs_section_ptr)\n     {\n-      expld.result.valid_p = FALSE;\n+      expld.result.valid_p = false;\n     }\n   else if (seg->phase == exp_seg_align_seen\n \t   || seg->phase == exp_seg_relro_seen)\n@@ -359,7 +359,7 @@ fold_segment_end (seg_align_type *seg)\n       /* OK.  */\n     }\n   else\n-    expld.result.valid_p = FALSE;\n+    expld.result.valid_p = false;\n }\n \n static void\n@@ -374,7 +374,7 @@ fold_unary (etree_type *tree)\n \t  if (expld.phase != lang_first_phase_enum)\n \t    new_rel_from_abs (align_n (expld.dot, expld.result.value));\n \t  else\n-\t    expld.result.valid_p = FALSE;\n+\t    expld.result.valid_p = false;\n \t  break;\n \n \tcase ABSOLUTE:\n@@ -405,7 +405,7 @@ fold_unary (etree_type *tree)\n \t      expld.result.value = align_n (expld.dot, expld.result.value);\n \t    }\n \t  else\n-\t    expld.result.valid_p = FALSE;\n+\t    expld.result.valid_p = false;\n \t  break;\n \n \tcase DATA_SEGMENT_END:\n@@ -451,7 +451,7 @@ fold_segment_align (seg_align_type *seg, etree_value_type *lhs)\n   seg->relro = exp_seg_relro_start;\n   if (expld.phase == lang_first_phase_enum\n       || expld.section != bfd_abs_section_ptr)\n-    expld.result.valid_p = FALSE;\n+    expld.result.valid_p = false;\n   else\n     {\n       bfd_vma maxpage = lhs->value;\n@@ -482,7 +482,7 @@ fold_segment_align (seg_align_type *seg, etree_value_type *lhs)\n \t      seg->relro_end = 0;\n \t    }\n \t  else\n-\t    expld.result.valid_p = FALSE;\n+\t    expld.result.valid_p = false;\n \t}\n     }\n }\n@@ -496,7 +496,7 @@ fold_segment_relro_end (seg_align_type *seg, etree_value_type *lhs)\n   seg->relro_offset = expld.result.value;\n   if (expld.phase == lang_first_phase_enum\n       || expld.section != bfd_abs_section_ptr)\n-    expld.result.valid_p = FALSE;\n+    expld.result.valid_p = false;\n   else if (seg->phase == exp_seg_align_seen\n \t   || seg->phase == exp_seg_adjust\n \t   || seg->phase == exp_seg_relro_adjust\n@@ -520,7 +520,7 @@ fold_segment_relro_end (seg_align_type *seg, etree_value_type *lhs)\n \tseg->phase = exp_seg_relro_seen;\n     }\n   else\n-    expld.result.valid_p = FALSE;\n+    expld.result.valid_p = false;\n }\n \n static void\n@@ -552,7 +552,7 @@ fold_binary (etree_type *tree)\n \t      einfo (_(\"%P: warning: address of `%s' \"\n \t\t       \"isn't multiple of maximum page size\\n\"),\n \t\t     segment_name);\n-\t    seg->used = TRUE;\n+\t    seg->used = true;\n \t    value = seg->value;\n \t    break;\n \t  }\n@@ -710,7 +710,7 @@ fold_name (etree_type *tree)\n       h = bfd_wrapped_link_hash_lookup (link_info.output_bfd,\n \t\t\t\t\t&link_info,\n \t\t\t\t\ttree->name.name,\n-\t\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\t\tfalse, false, true);\n       new_number (h != NULL\n \t\t  && (h->type == bfd_link_hash_defined\n \t\t      || h->type == bfd_link_hash_defweak\n@@ -729,7 +729,7 @@ fold_name (etree_type *tree)\n \t  h = bfd_wrapped_link_hash_lookup (link_info.output_bfd,\n \t\t\t\t\t    &link_info,\n \t\t\t\t\t    tree->name.name,\n-\t\t\t\t\t    TRUE, FALSE, TRUE);\n+\t\t\t\t\t    true, false, true);\n \t  if (!h)\n \t    {\n \t      if (expld.phase != lang_first_phase_enum)\n@@ -872,7 +872,7 @@ fold_name (etree_type *tree)\n       {\n \tlang_memory_region_type *mem;\n \n-\tmem = lang_memory_region_lookup (tree->name.name, FALSE);\n+\tmem = lang_memory_region_lookup (tree->name.name, false);\n \tif (mem != NULL)\n \t  new_number (mem->length);\n \telse\n@@ -886,7 +886,7 @@ fold_name (etree_type *tree)\n       {\n \tlang_memory_region_type *mem;\n \n-\tmem = lang_memory_region_lookup (tree->name.name, FALSE);\n+\tmem = lang_memory_region_lookup (tree->name.name, false);\n \tif (mem != NULL)\n \t  new_rel_from_abs (mem->origin);\n \telse\n@@ -914,7 +914,7 @@ fold_name (etree_type *tree)\n \n /* Return true if TREE is '.'.  */\n \n-static bfd_boolean\n+static bool\n is_dot (const etree_type *tree)\n {\n   return (tree->type.node_class == etree_name\n@@ -925,7 +925,7 @@ is_dot (const etree_type *tree)\n \n /* Return true if TREE is a constant equal to VAL.  */\n \n-static bfd_boolean\n+static bool\n is_value (const etree_type *tree, bfd_vma val)\n {\n   return (tree->type.node_class == etree_value\n@@ -935,7 +935,7 @@ is_value (const etree_type *tree, bfd_vma val)\n /* Return true if TREE is an absolute symbol equal to VAL defined in\n    a linker script.  */\n \n-static bfd_boolean\n+static bool\n is_sym_value (const etree_type *tree, bfd_vma val)\n {\n   struct bfd_link_hash_entry *h;\n@@ -948,7 +948,7 @@ is_sym_value (const etree_type *tree, bfd_vma val)\n \t  && (h = bfd_wrapped_link_hash_lookup (link_info.output_bfd,\n \t\t\t\t\t\t&link_info,\n \t\t\t\t\t\ttree->name.name,\n-\t\t\t\t\t\tFALSE, FALSE, TRUE)) != NULL\n+\t\t\t\t\t\tfalse, false, true)) != NULL\n \t  && h->ldscript_def\n \t  && h->type == bfd_link_hash_defined\n \t  && h->u.def.section == bfd_abs_section_ptr\n@@ -957,7 +957,7 @@ is_sym_value (const etree_type *tree, bfd_vma val)\n \n /* Return true if TREE is \". != 0\".  */\n \n-static bfd_boolean\n+static bool\n is_dot_ne_0 (const etree_type *tree)\n {\n   return (tree->type.node_class == etree_binary\n@@ -969,7 +969,7 @@ is_dot_ne_0 (const etree_type *tree)\n /* Return true if TREE is \". = . + 0\" or \". = . + sym\" where sym is an\n    absolute constant with value 0 defined in a linker script.  */\n \n-static bfd_boolean\n+static bool\n is_dot_plus_0 (const etree_type *tree)\n {\n   return (tree->type.node_class == etree_binary\n@@ -981,7 +981,7 @@ is_dot_plus_0 (const etree_type *tree)\n \n /* Return true if TREE is \"ALIGN (. != 0 ? some_expression : 1)\".  */\n \n-static bfd_boolean\n+static bool\n is_align_conditional (const etree_type *tree)\n {\n   if (tree->type.node_class == etree_unary\n@@ -992,7 +992,7 @@ is_align_conditional (const etree_type *tree)\n \t      && is_dot_ne_0 (tree->trinary.cond)\n \t      && is_value (tree->trinary.rhs, 1));\n     }\n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1055,9 +1055,9 @@ exp_fold_tree_1 (etree_type *tree)\n \t  if (expld.phase != lang_first_phase_enum)\n \t    {\n \t      /* Notify the folder that this is an assignment to dot.  */\n-\t      expld.assigning_to_dot = TRUE;\n+\t      expld.assigning_to_dot = true;\n \t      exp_fold_tree_1 (tree->assign.src);\n-\t      expld.assigning_to_dot = FALSE;\n+\t      expld.assigning_to_dot = false;\n \n \t      /* If we are assigning to dot inside an output section\n \t\t arrange to keep the section, except for certain\n@@ -1126,7 +1126,7 @@ exp_fold_tree_1 (etree_type *tree)\n \t  if (tree->type.node_class == etree_provide)\n \t    {\n \t      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n-\t\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\t\tfalse, false, true);\n \t      if (h == NULL\n \t\t  || !(h->type == bfd_link_hash_new\n \t\t       || h->type == bfd_link_hash_undefined\n@@ -1164,7 +1164,7 @@ exp_fold_tree_1 (etree_type *tree)\n \t      if (h == NULL)\n \t\t{\n \t\t  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,\n-\t\t\t\t\t    TRUE, FALSE, TRUE);\n+\t\t\t\t\t    true, false, true);\n \t\t  if (h == NULL)\n \t\t    einfo (_(\"%F%P:%s: hash creation failed\\n\"),\n \t\t\t   tree->assign.dst);\n@@ -1179,7 +1179,7 @@ exp_fold_tree_1 (etree_type *tree)\n                 {\n                   expld.result.value = 0;\n                   expld.result.section = NULL;\n-                  expld.result.valid_p = TRUE;\n+                  expld.result.valid_p = true;\n                 }\n \n \t      if (expld.result.valid_p)\n@@ -1231,7 +1231,7 @@ exp_fold_tree_1 (etree_type *tree)\n \t\t\t{\n \t\t\t  bfd_copy_link_hash_symbol_type (link_info.output_bfd,\n \t\t\t\t\t\t\t  h, expld.assign_src);\n-\t\t\t  expld.assign_src->non_ir_ref_regular = TRUE;\n+\t\t\t  expld.assign_src->non_ir_ref_regular = true;\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -1255,7 +1255,7 @@ exp_fold_tree_1 (etree_type *tree)\n void\n exp_fold_tree (etree_type *tree, asection *current_section, bfd_vma *dotp)\n {\n-  expld.rel_from_abs = FALSE;\n+  expld.rel_from_abs = false;\n   expld.dot = *dotp;\n   expld.dotp = dotp;\n   expld.section = current_section;\n@@ -1265,7 +1265,7 @@ exp_fold_tree (etree_type *tree, asection *current_section, bfd_vma *dotp)\n void\n exp_fold_tree_no_dot (etree_type *tree)\n {\n-  expld.rel_from_abs = FALSE;\n+  expld.rel_from_abs = false;\n   expld.dot = 0;\n   expld.dotp = NULL;\n   expld.section = bfd_abs_section_ptr;\n@@ -1363,7 +1363,7 @@ static etree_type *\n exp_assop (const char *dst,\n \t   etree_type *src,\n \t   enum node_tree_enum class,\n-\t   bfd_boolean hidden)\n+\t   bool hidden)\n {\n   etree_type *n;\n \n@@ -1381,7 +1381,7 @@ exp_assop (const char *dst,\n /* Handle linker script assignments and HIDDEN.  */\n \n etree_type *\n-exp_assign (const char *dst, etree_type *src, bfd_boolean hidden)\n+exp_assign (const char *dst, etree_type *src, bool hidden)\n {\n   return exp_assop (dst, src, etree_assign, hidden);\n }\n@@ -1391,13 +1391,13 @@ exp_assign (const char *dst, etree_type *src, bfd_boolean hidden)\n etree_type *\n exp_defsym (const char *dst, etree_type *src)\n {\n-  return exp_assop (dst, src, etree_assign, FALSE);\n+  return exp_assop (dst, src, etree_assign, false);\n }\n \n /* Handle PROVIDE.  */\n \n etree_type *\n-exp_provide (const char *dst, etree_type *src, bfd_boolean hidden)\n+exp_provide (const char *dst, etree_type *src, bool hidden)\n {\n   return exp_assop (dst, src, etree_provide, hidden);\n }\n@@ -1422,7 +1422,7 @@ exp_assert (etree_type *exp, const char *message)\n void\n exp_print_tree (etree_type *tree)\n {\n-  bfd_boolean function_like;\n+  bool function_like;\n \n   if (config.map_file == NULL)\n     config.map_file = stderr;\n@@ -1445,7 +1445,7 @@ exp_print_tree (etree_type *tree)\n       return;\n     case etree_assign:\n       fputs (tree->assign.dst, config.map_file);\n-      exp_print_token (tree->type.node_code, TRUE);\n+      exp_print_token (tree->type.node_code, true);\n       exp_print_tree (tree->assign.src);\n       break;\n     case etree_provide:\n@@ -1455,20 +1455,20 @@ exp_print_tree (etree_type *tree)\n       fputc (')', config.map_file);\n       break;\n     case etree_binary:\n-      function_like = FALSE;\n+      function_like = false;\n       switch (tree->type.node_code)\n \t{\n \tcase MAX_K:\n \tcase MIN_K:\n \tcase ALIGN_K:\n \tcase DATA_SEGMENT_ALIGN:\n \tcase DATA_SEGMENT_RELRO_END:\n-\t  function_like = TRUE;\n+\t  function_like = true;\n \t  break;\n \tcase SEGMENT_START:\n \t  /* Special handling because arguments are in reverse order and\n \t     the segment name is quoted.  */\n-\t  exp_print_token (tree->type.node_code, FALSE);\n+\t  exp_print_token (tree->type.node_code, false);\n \t  fputs (\" (\\\"\", config.map_file);\n \t  exp_print_tree (tree->binary.rhs);\n \t  fputs (\"\\\", \", config.map_file);\n@@ -1478,15 +1478,15 @@ exp_print_tree (etree_type *tree)\n \t}\n       if (function_like)\n \t{\n-\t  exp_print_token (tree->type.node_code, FALSE);\n+\t  exp_print_token (tree->type.node_code, false);\n \t  fputc (' ', config.map_file);\n \t}\n       fputc ('(', config.map_file);\n       exp_print_tree (tree->binary.lhs);\n       if (function_like)\n \tfprintf (config.map_file, \", \");\n       else\n-\texp_print_token (tree->type.node_code, TRUE);\n+\texp_print_token (tree->type.node_code, true);\n       exp_print_tree (tree->binary.rhs);\n       fputc (')', config.map_file);\n       break;\n@@ -1498,7 +1498,7 @@ exp_print_tree (etree_type *tree)\n       exp_print_tree (tree->trinary.rhs);\n       break;\n     case etree_unary:\n-      exp_print_token (tree->unary.type.node_code, FALSE);\n+      exp_print_token (tree->unary.type.node_code, false);\n       if (tree->unary.child)\n \t{\n \t  fprintf (config.map_file, \" (\");\n@@ -1518,7 +1518,7 @@ exp_print_tree (etree_type *tree)\n \tfputs (tree->name.name, config.map_file);\n       else\n \t{\n-\t  exp_print_token (tree->type.node_code, FALSE);\n+\t  exp_print_token (tree->type.node_code, false);\n \t  if (tree->name.name)\n \t    fprintf (config.map_file, \" (%s)\", tree->name.name);\n \t}\n@@ -1673,15 +1673,15 @@ ldexp_init (void)\n    SEGMENT_START or ORIGIN) outside of an output section statement,\n    to section relative.  */\n \n-static bfd_boolean\n+static bool\n set_sym_sections (struct bfd_hash_entry *bh, void *inf ATTRIBUTE_UNUSED)\n {\n   struct definedness_hash_entry *def = (struct definedness_hash_entry *) bh;\n   if (def->final_sec != bfd_abs_section_ptr)\n     {\n       struct bfd_link_hash_entry *h;\n       h = bfd_link_hash_lookup (link_info.hash, bh->string,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n       if (h != NULL\n \t  && h->type == bfd_link_hash_defined\n \t  && h->u.def.section == bfd_abs_section_ptr)\n@@ -1690,7 +1690,7 @@ set_sym_sections (struct bfd_hash_entry *bh, void *inf ATTRIBUTE_UNUSED)\n \t  h->u.def.section = def->final_sec;\n \t}\n     }\n-  return TRUE;\n+  return true;\n }\n \n void\n@@ -1702,7 +1702,7 @@ ldexp_finalize_syms (void)\n /* Determine whether a symbol is going to remain absolute even after\n    ldexp_finalize_syms() has run.  */\n \n-bfd_boolean\n+bool\n ldexp_is_final_sym_absolute (const struct bfd_link_hash_entry *h)\n {\n   if (h->type == bfd_link_hash_defined\n@@ -1711,14 +1711,14 @@ ldexp_is_final_sym_absolute (const struct bfd_link_hash_entry *h)\n       const struct definedness_hash_entry *def;\n \n       if (!h->ldscript_def)\n-\treturn TRUE;\n+\treturn true;\n \n       def = symbol_defined (h->root.string);\n       if (def != NULL)\n \treturn def->final_sec == bfd_abs_section_ptr;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n void"
    },
    {
      "sha": "ebe82f6088f58ce7772a796b5b7492465a859ba9",
      "filename": "ld/ldexp.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldexp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldexp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldexp.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -26,7 +26,7 @@ typedef struct {\n   bfd_vma value;\n   char *str;\n   asection *section;\n-  bfd_boolean valid_p;\n+  bool valid_p;\n } etree_value_type;\n \n enum node_tree_enum {\n@@ -66,7 +66,7 @@ typedef union etree_union {\n     node_type type;\n     const char *dst;\n     union etree_union *src;\n-    bfd_boolean hidden;\n+    bool hidden;\n   } assign;\n   struct {\n     node_type type;\n@@ -149,14 +149,14 @@ struct ldexp_control {\n   lang_phase_type phase;\n \n   /* Principally used for diagnostics.  */\n-  bfd_boolean assigning_to_dot;\n+  bool assigning_to_dot;\n \n   /* Set if the current expression used \"dot\", SEGMENT_START or\n      ORIGIN, but not ABSOLUTE or combined symbols in a way that forces\n      an absolute result.  Used in tracking symbols assigned from dot\n      outside of output section statements, in order to later convert\n      them from absolute.  */\n-  bfd_boolean rel_from_abs;\n+  bool rel_from_abs;\n \n   /* If evaluating an assignment, the destination.  Cleared if an\n      etree_name NAME matches this, to signal a self-assignment.\n@@ -193,7 +193,7 @@ typedef struct segment_struct {\n   bfd_vma value;\n   /* True if a SEGMENT_START directive corresponding to this segment\n      has been seen.  */\n-  bfd_boolean used;\n+  bool used;\n } segment_type;\n \n /* The segments specified by the user on the command-line.  */\n@@ -220,11 +220,11 @@ etree_type *exp_unop\n etree_type *exp_nameop\n   (int, const char *);\n etree_type *exp_assign\n-  (const char *, etree_type *, bfd_boolean);\n+  (const char *, etree_type *, bool);\n etree_type *exp_defsym\n   (const char *, etree_type *);\n etree_type *exp_provide\n-  (const char *, etree_type *, bfd_boolean);\n+  (const char *, etree_type *, bool);\n etree_type *exp_assert\n   (etree_type *, const char *);\n void exp_print_tree\n@@ -239,7 +239,7 @@ bfd_vma exp_get_abs_int\n   (etree_type *, int, char *);\n void ldexp_init (void);\n void ldexp_finalize_syms (void);\n-bfd_boolean ldexp_is_final_sym_absolute (const struct bfd_link_hash_entry *);\n+bool ldexp_is_final_sym_absolute (const struct bfd_link_hash_entry *);\n void ldexp_finish (void);\n \n #endif"
    },
    {
      "sha": "9d0af06f1f6eb94eb6d735a6824a7d7ebb5d86d9",
      "filename": "ld/ldfile.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldfile.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -39,7 +39,7 @@\n #include \"plugin.h\"\n #endif /* BFD_SUPPORTS_PLUGINS */\n \n-bfd_boolean ldfile_assumed_script = FALSE;\n+bool ldfile_assumed_script = false;\n const char *ldfile_output_machine_name = \"\";\n unsigned long ldfile_output_machine;\n enum bfd_architecture ldfile_output_architecture;\n@@ -68,19 +68,19 @@ static search_arch_type **search_arch_tail_ptr = &search_arch_head;\n /* Test whether a pathname, after canonicalization, is the same or a\n    sub-directory of the sysroot directory.  */\n \n-static bfd_boolean\n+static bool\n is_sysrooted_pathname (const char *name)\n {\n   char *realname;\n   int len;\n-  bfd_boolean result;\n+  bool result;\n \n   if (ld_canon_sysroot == NULL)\n-    return FALSE;\n+    return false;\n \n   realname = lrealpath (name);\n   len = strlen (realname);\n-  result = FALSE;\n+  result = false;\n   if (len > ld_canon_sysroot_len\n       && IS_DIR_SEPARATOR (realname[ld_canon_sysroot_len]))\n     {\n@@ -96,7 +96,7 @@ is_sysrooted_pathname (const char *name)\n    Makes a copy of NAME using xmalloc().  */\n \n void\n-ldfile_add_library_path (const char *name, bfd_boolean cmdline)\n+ldfile_add_library_path (const char *name, bool cmdline)\n {\n   search_dirs_type *new_dirs;\n \n@@ -121,7 +121,7 @@ ldfile_add_library_path (const char *name, bfd_boolean cmdline)\n \n /* Try to open a BFD for a lang_input_statement.  */\n \n-bfd_boolean\n+bool\n ldfile_try_open_bfd (const char *attempt,\n \t\t     lang_input_statement_type *entry)\n {\n@@ -139,7 +139,7 @@ ldfile_try_open_bfd (const char *attempt,\n     {\n       if (bfd_get_error () == bfd_error_invalid_target)\n \teinfo (_(\"%F%P: invalid BFD target `%s'\\n\"), entry->target);\n-      return FALSE;\n+      return false;\n     }\n \n   track_dependency_files (attempt);\n@@ -162,8 +162,8 @@ ldfile_try_open_bfd (const char *attempt,\n      a dynamic object.\n \n      In the code below, it's OK to exit early if the check fails,\n-     closing the checked BFD and returning FALSE, but if the BFD\n-     checks out compatible, do not exit early returning TRUE, or\n+     closing the checked BFD and returning false, but if the BFD\n+     checks out compatible, do not exit early returning true, or\n      the plugins will not get a chance to claim the file.  */\n \n   if (entry->flags.search_dirs || !entry->flags.dynamic)\n@@ -191,7 +191,7 @@ ldfile_try_open_bfd (const char *attempt,\n \t\t  /* Try to interpret the file as a linker script.  */\n \t\t  ldfile_open_command_file (attempt);\n \n-\t\t  ldfile_assumed_script = TRUE;\n+\t\t  ldfile_assumed_script = true;\n \t\t  parser_input = input_selected;\n \t\t  ldlex_both ();\n \t\t  token = INPUT_SCRIPT;\n@@ -258,7 +258,7 @@ ldfile_try_open_bfd (const char *attempt,\n \t\t      token = yylex ();\n \t\t    }\n \t\t  ldlex_popstate ();\n-\t\t  ldfile_assumed_script = FALSE;\n+\t\t  ldfile_assumed_script = false;\n \t\t  fclose (yyin);\n \t\t  yyin = NULL;\n \t\t  if (skip)\n@@ -269,7 +269,7 @@ ldfile_try_open_bfd (const char *attempt,\n \t\t\t       attempt, entry->local_sym_name);\n \t\t      bfd_close (entry->the_bfd);\n \t\t      entry->the_bfd = NULL;\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t    }\n \t\t}\n \t      goto success;\n@@ -281,7 +281,7 @@ ldfile_try_open_bfd (const char *attempt,\n \t\t     attempt);\n \t      bfd_close (entry->the_bfd);\n \t      entry->the_bfd = NULL;\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if (entry->flags.search_dirs\n@@ -299,7 +299,7 @@ ldfile_try_open_bfd (const char *attempt,\n \t\t       attempt, entry->local_sym_name);\n \t      bfd_close (entry->the_bfd);\n \t      entry->the_bfd = NULL;\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n     }\n@@ -322,13 +322,13 @@ ldfile_try_open_bfd (const char *attempt,\n \n   /* It opened OK, the format checked out, and the plugins have had\n      their chance to claim it, so this is success.  */\n-  return TRUE;\n+  return true;\n }\n \n /* Search for and open the file specified by ENTRY.  If it is an\n    archive, use ARCH, LIB and SUFFIX to modify the file name.  */\n \n-bfd_boolean\n+bool\n ldfile_open_file_search (const char *arch,\n \t\t\t lang_input_statement_type *entry,\n \t\t\t const char *lib,\n@@ -347,15 +347,15 @@ ldfile_open_file_search (const char *arch,\n \t  if (ldfile_try_open_bfd (name, entry))\n \t    {\n \t      entry->filename = name;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  free (name);\n \t}\n       else if (ldfile_try_open_bfd (entry->filename, entry))\n-\treturn TRUE;\n+\treturn true;\n \n       if (IS_ABSOLUTE_PATH (entry->filename))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   for (search = search_head; search != NULL; search = search->next)\n@@ -365,7 +365,7 @@ ldfile_open_file_search (const char *arch,\n       if (entry->flags.dynamic && !bfd_link_relocatable (&link_info))\n \t{\n \t  if (ldemul_open_dynamic_archive (arch, search, entry))\n-\t    return TRUE;\n+\t    return true;\n \t}\n \n       if (entry->flags.maybe_archive && !entry->flags.full_name_provided)\n@@ -378,13 +378,13 @@ ldfile_open_file_search (const char *arch,\n       if (ldfile_try_open_bfd (string, entry))\n \t{\n \t  entry->filename = string;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \n       free (string);\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Open the input file specified by ENTRY.\n@@ -409,13 +409,13 @@ ldfile_open_file (lang_input_statement_type *entry)\n       else\n \teinfo (_(\"%P: cannot find %s: %E\\n\"), entry->local_sym_name);\n \n-      entry->flags.missing_file = TRUE;\n-      input_flags.missing_file = TRUE;\n+      entry->flags.missing_file = true;\n+      input_flags.missing_file = true;\n     }\n   else\n     {\n       search_arch_type *arch;\n-      bfd_boolean found = FALSE;\n+      bool found = false;\n \n       /* If extra_search_path is set, entry->filename is a relative path.\n \t Search the directory of the current linker script before searching\n@@ -427,7 +427,7 @@ ldfile_open_file (lang_input_statement_type *entry)\n \t  if (ldfile_try_open_bfd (path, entry))\n \t    {\n \t      entry->filename = path;\n-\t      entry->flags.search_dirs = FALSE;\n+\t      entry->flags.search_dirs = false;\n \t      return;\n \t    }\n \n@@ -453,7 +453,7 @@ ldfile_open_file (lang_input_statement_type *entry)\n       /* If we have found the file, we don't need to search directories\n \t again.  */\n       if (found)\n-\tentry->flags.search_dirs = FALSE;\n+\tentry->flags.search_dirs = false;\n       else\n \t{\n \t  if (entry->flags.sysrooted\n@@ -513,16 +513,16 @@ ldfile_open_file (lang_input_statement_type *entry)\n \t\t}\n \t    }\n \n-\t  entry->flags.missing_file = TRUE;\n-\t  input_flags.missing_file = TRUE;\n+\t  entry->flags.missing_file = true;\n+\t  input_flags.missing_file = true;\n \t}\n     }\n }\n \n /* Try to open NAME.  */\n \n static FILE *\n-try_open (const char *name, bfd_boolean *sysrooted)\n+try_open (const char *name, bool *sysrooted)\n {\n   FILE *result;\n \n@@ -544,12 +544,12 @@ try_open (const char *name, bfd_boolean *sysrooted)\n \n /* Return TRUE iff directory DIR contains an \"ldscripts\" subdirectory.  */\n \n-static bfd_boolean\n+static bool\n check_for_scripts_dir (char *dir)\n {\n   char *buf;\n   struct stat s;\n-  bfd_boolean res;\n+  bool res;\n \n   buf = concat (dir, \"/ldscripts\", (const char *) NULL);\n   res = stat (buf, &s) == 0 && S_ISDIR (s.st_mode);\n@@ -604,8 +604,8 @@ find_scripts_dir (void)\n \n static FILE *\n ldfile_find_command_file (const char *name,\n-\t\t\t  bfd_boolean default_only,\n-\t\t\t  bfd_boolean *sysrooted)\n+\t\t\t  bool default_only,\n+\t\t\t  bool *sysrooted)\n {\n   search_dirs_type *search;\n   FILE *result = NULL;\n@@ -627,7 +627,7 @@ ldfile_find_command_file (const char *name,\n \t{\n \t  search_dirs_type **save_tail_ptr = search_tail_ptr;\n \t  search_tail_ptr = &script_search;\n-\t  ldfile_add_library_path (script_dir, TRUE);\n+\t  ldfile_add_library_path (script_dir, true);\n \t  search_tail_ptr = save_tail_ptr;\n \t}\n     }\n@@ -673,7 +673,7 @@ static void\n ldfile_open_command_file_1 (const char *name, enum script_open_style open_how)\n {\n   FILE *ldlex_input_stack;\n-  bfd_boolean sysrooted;\n+  bool sysrooted;\n   static struct script_name_list *processed_scripts = NULL;\n   struct script_name_list *script;\n   size_t len;"
    },
    {
      "sha": "5b0b27a2fb42d32104eae731783b635bda3f19b7",
      "filename": "ld/ldfile.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldfile.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -21,7 +21,7 @@\n #ifndef LDFILE_H\n #define LDFILE_H\n \n-extern bfd_boolean ldfile_assumed_script;\n+extern bool ldfile_assumed_script;\n extern unsigned long ldfile_output_machine;\n extern enum bfd_architecture ldfile_output_architecture;\n extern const char *ldfile_output_machine_name;\n@@ -35,15 +35,15 @@ typedef struct search_dirs {\n   /* Name of directory.  */\n   const char *name;\n   /* TRUE if this is from the command line.  */\n-  bfd_boolean cmdline;\n+  bool cmdline;\n } search_dirs_type;\n \n extern search_dirs_type *search_head;\n \n extern void ldfile_add_arch\n   (const char *);\n extern void ldfile_add_library_path\n-  (const char *, bfd_boolean cmdline);\n+  (const char *, bool cmdline);\n extern void ldfile_open_command_file\n   (const char *name);\n extern void ldfile_open_script_file\n@@ -52,11 +52,11 @@ extern void ldfile_open_default_command_file\n   (const char *name);\n extern void ldfile_open_file\n   (struct lang_input_statement_struct *);\n-extern bfd_boolean ldfile_try_open_bfd\n+extern bool ldfile_try_open_bfd\n   (const char *, struct lang_input_statement_struct *);\n extern void ldfile_set_output_arch\n   (const char *, enum bfd_architecture);\n-extern bfd_boolean ldfile_open_file_search\n+extern bool ldfile_open_file_search\n   (const char *arch, struct lang_input_statement_struct *,\n    const char *lib, const char *suffix);\n "
    },
    {
      "sha": "dd911f461693292042f798a86fd5b3d8b1feee19",
      "filename": "ld/ldgram.y",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldgram.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldgram.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldgram.y?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -49,7 +49,7 @@\n static enum section_type sectype;\n static lang_memory_region_type *region;\n \n-static bfd_boolean ldgram_had_keep = FALSE;\n+static bool ldgram_had_keep = false;\n static char *ldgram_vers_current_lang = NULL;\n \n #define ERROR_NAME_MAX 20\n@@ -77,8 +77,8 @@ static int error_index;\n   union etree_union *etree;\n   struct phdr_info\n     {\n-      bfd_boolean filehdr;\n-      bfd_boolean phdrs;\n+      bool filehdr;\n+      bool phdrs;\n       union etree_union *at;\n       union etree_union *flags;\n     } phdr;\n@@ -252,7 +252,7 @@ mri_script_command:\n \t\tmri_script_lines END\n \t\t{ ldlex_popstate (); }\n \t|\tSTART NAME\n-\t\t{ lang_add_entry ($2, FALSE); }\n+\t\t{ lang_add_entry ($2, false); }\n \t|\n \t;\n \n@@ -289,11 +289,11 @@ extern_name_list:\n \n extern_name_list_body:\n \t  NAME\n-\t\t\t{ ldlang_add_undef ($1, FALSE); }\n+\t\t\t{ ldlang_add_undef ($1, false); }\n \t| extern_name_list_body NAME\n-\t\t\t{ ldlang_add_undef ($2, FALSE); }\n+\t\t\t{ ldlang_add_undef ($2, false); }\n \t| extern_name_list_body ',' NAME\n-\t\t\t{ ldlang_add_undef ($3, FALSE); }\n+\t\t\t{ ldlang_add_undef ($3, false); }\n \t;\n \n script_file:\n@@ -322,7 +322,7 @@ ifile_p1:\n \t|\tTARGET_K '(' NAME ')'\n \t\t{ lang_add_target($3); }\n \t|\tSEARCH_DIR '(' filename ')'\n-\t\t{ ldfile_add_library_path ($3, FALSE); }\n+\t\t{ ldfile_add_library_path ($3, false); }\n \t|\tOUTPUT '(' filename ')'\n \t\t{ lang_add_output($3, 1); }\n \t|\tOUTPUT_FORMAT '(' NAME ')'\n@@ -333,11 +333,11 @@ ifile_p1:\n \t|\tOUTPUT_ARCH '(' NAME ')'\n \t\t  { ldfile_set_output_arch ($3, bfd_arch_unknown); }\n \t|\tFORCE_COMMON_ALLOCATION\n-\t\t{ command_line.force_common_definition = TRUE ; }\n+\t\t{ command_line.force_common_definition = true ; }\n \t|\tFORCE_GROUP_ALLOCATION\n-\t\t{ command_line.force_group_allocation = TRUE ; }\n+\t\t{ command_line.force_group_allocation = true ; }\n \t|\tINHIBIT_COMMON_ALLOCATION\n-\t\t{ link_info.inhibit_common_definition = TRUE ; }\n+\t\t{ link_info.inhibit_common_definition = true ; }\n \t|\tINPUT '(' input_list ')'\n \t|\tGROUP\n \t\t  { lang_enter_group (); }\n@@ -394,17 +394,17 @@ input_list1:\n \t\t\t\t (char *)NULL); }\n \t|\tAS_NEEDED '('\n \t\t  { $<integer>$ = input_flags.add_DT_NEEDED_for_regular;\n-\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n+\t\t    input_flags.add_DT_NEEDED_for_regular = true; }\n \t\t     input_list1 ')'\n \t\t  { input_flags.add_DT_NEEDED_for_regular = $<integer>3; }\n \t|\tinput_list1 ',' AS_NEEDED '('\n \t\t  { $<integer>$ = input_flags.add_DT_NEEDED_for_regular;\n-\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n+\t\t    input_flags.add_DT_NEEDED_for_regular = true; }\n \t\t     input_list1 ')'\n \t\t  { input_flags.add_DT_NEEDED_for_regular = $<integer>5; }\n \t|\tinput_list1 AS_NEEDED '('\n \t\t  { $<integer>$ = input_flags.add_DT_NEEDED_for_regular;\n-\t\t    input_flags.add_DT_NEEDED_for_regular = TRUE; }\n+\t\t    input_flags.add_DT_NEEDED_for_regular = true; }\n \t\t     input_list1 ')'\n \t\t  { input_flags.add_DT_NEEDED_for_regular = $<integer>4; }\n \t;\n@@ -421,7 +421,7 @@ sec_or_group_p1:\n \n statement_anywhere:\n \t\tENTRY '(' NAME ')'\n-\t\t{ lang_add_entry ($3, FALSE); }\n+\t\t{ lang_add_entry ($3, false); }\n \t|\tassignment end\n \t|\tASSERT_K  {ldlex_expression ();} '(' exp ',' NAME ')'\n \t\t{ ldlex_popstate ();\n@@ -534,7 +534,7 @@ sect_flag_list:\tNAME\n \t\t\t      n->with = with_flags;\n \t\t\t      n->name = $1;\n \t\t\t    }\n-\t\t\t  n->valid = FALSE;\n+\t\t\t  n->valid = false;\n \t\t\t  n->next = NULL;\n \t\t\t  $$ = n;\n \t\t\t}\n@@ -552,7 +552,7 @@ sect_flag_list:\tNAME\n \t\t\t      n->with = with_flags;\n \t\t\t      n->name = $3;\n \t\t\t    }\n-\t\t\t  n->valid = FALSE;\n+\t\t\t  n->valid = false;\n \t\t\t  n->next = $1;\n \t\t\t  $$ = n;\n \t\t\t}\n@@ -564,7 +564,7 @@ sect_flags:\n \t\t\t  struct flag_info *n;\n \t\t\t  n = ((struct flag_info *) xmalloc (sizeof *n));\n \t\t\t  n->flag_list = $3;\n-\t\t\t  n->flags_initialized = FALSE;\n+\t\t\t  n->flags_initialized = false;\n \t\t\t  n->not_with_flags = 0;\n \t\t\t  n->only_with_flags = 0;\n \t\t\t  $$ = n;\n@@ -657,9 +657,9 @@ input_section_spec_no_keep:\n input_section_spec:\n \t\tinput_section_spec_no_keep\n \t|\tKEEP '('\n-\t\t\t{ ldgram_had_keep = TRUE; }\n+\t\t\t{ ldgram_had_keep = true; }\n \t\tinput_section_spec_no_keep ')'\n-\t\t\t{ ldgram_had_keep = FALSE; }\n+\t\t\t{ ldgram_had_keep = false; }\n \t;\n \n statement:\n@@ -676,7 +676,7 @@ statement:\n \t\t}\n \t| SORT_BY_NAME '(' CONSTRUCTORS ')'\n \t\t{\n-\t\t  constructors_sorted = TRUE;\n+\t\t  constructors_sorted = true;\n \t\t  lang_add_attribute (lang_constructors_statement_enum);\n \t\t}\n \t| input_section_spec\n@@ -761,27 +761,27 @@ end:\t';' | ','\n assignment:\n \t\tNAME '=' mustbe_exp\n \t\t{\n-\t\t  lang_add_assignment (exp_assign ($1, $3, FALSE));\n+\t\t  lang_add_assignment (exp_assign ($1, $3, false));\n \t\t}\n \t|\tNAME assign_op mustbe_exp\n \t\t{\n \t\t  lang_add_assignment (exp_assign ($1,\n \t\t\t\t\t\t   exp_binop ($2,\n \t\t\t\t\t\t\t      exp_nameop (NAME,\n \t\t\t\t\t\t\t\t\t  $1),\n-\t\t\t\t\t\t\t      $3), FALSE));\n+\t\t\t\t\t\t\t      $3), false));\n \t\t}\n \t|\tHIDDEN '(' NAME '=' mustbe_exp ')'\n \t\t{\n-\t\t  lang_add_assignment (exp_assign ($3, $5, TRUE));\n+\t\t  lang_add_assignment (exp_assign ($3, $5, true));\n \t\t}\n \t|\tPROVIDE '(' NAME '=' mustbe_exp ')'\n \t\t{\n-\t\t  lang_add_assignment (exp_provide ($3, $5, FALSE));\n+\t\t  lang_add_assignment (exp_provide ($3, $5, false));\n \t\t}\n \t|\tPROVIDE_HIDDEN '(' NAME '=' mustbe_exp ')'\n \t\t{\n-\t\t  lang_add_assignment (exp_provide ($3, $5, TRUE));\n+\t\t  lang_add_assignment (exp_provide ($3, $5, true));\n \t\t}\n \t;\n \n@@ -803,7 +803,7 @@ memory_spec_list:\n \n \n memory_spec:\tNAME\n-\t\t{ region = lang_memory_region_lookup ($1, TRUE); }\n+\t\t{ region = lang_memory_region_lookup ($1, true); }\n \t\tattributes_opt ':'\n \t\torigin_spec opt_comma length_spec\n \t\t{}\n@@ -875,9 +875,9 @@ low_level_library_NAME_list:\n \n floating_point_support:\n \t\tFLOAT\n-\t\t\t{ lang_float(TRUE); }\n+\t\t\t{ lang_float(true); }\n \t|\tNOFLOAT\n-\t\t\t{ lang_float(FALSE); }\n+\t\t\t{ lang_float(false); }\n \t;\n \n nocrossref_list:\n@@ -1108,7 +1108,7 @@ section:\tNAME\t\t{ ldlex_expression(); }\n \t\topt_exp_with_type\n \t\t{\n \t\t  ldlex_popstate ();\n-\t\t  lang_add_assignment (exp_assign (\".\", $3, FALSE));\n+\t\t  lang_add_assignment (exp_assign (\".\", $3, false));\n \t\t}\n \t\t'{' sec_or_group_p1 '}'\n \t|\tINCLUDE filename\n@@ -1173,7 +1173,7 @@ phdr_opt:\n \t\t  n = ((struct lang_output_section_phdr_list *)\n \t\t       xmalloc (sizeof *n));\n \t\t  n->name = $3;\n-\t\t  n->used = FALSE;\n+\t\t  n->used = false;\n \t\t  n->next = $1;\n \t\t  $$ = n;\n \t\t}\n@@ -1269,9 +1269,9 @@ phdr_qualifiers:\n \t\t{\n \t\t  $$ = $3;\n \t\t  if (strcmp ($1, \"FILEHDR\") == 0 && $2 == NULL)\n-\t\t    $$.filehdr = TRUE;\n+\t\t    $$.filehdr = true;\n \t\t  else if (strcmp ($1, \"PHDRS\") == 0 && $2 == NULL)\n-\t\t    $$.phdrs = TRUE;\n+\t\t    $$.phdrs = true;\n \t\t  else if (strcmp ($1, \"FLAGS\") == 0 && $2 != NULL)\n \t\t    $$.flags = $2;\n \t\t  else\n@@ -1407,19 +1407,19 @@ vers_tag:\n vers_defns:\n \t\tVERS_IDENTIFIER\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern (NULL, $1, ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern (NULL, $1, ldgram_vers_current_lang, false);\n \t\t}\n \t|\tNAME\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern (NULL, $1, ldgram_vers_current_lang, TRUE);\n+\t\t  $$ = lang_new_vers_pattern (NULL, $1, ldgram_vers_current_lang, true);\n \t\t}\n \t|\tvers_defns ';' VERS_IDENTIFIER\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern ($1, $3, ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern ($1, $3, ldgram_vers_current_lang, false);\n \t\t}\n \t|\tvers_defns ';' NAME\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern ($1, $3, ldgram_vers_current_lang, TRUE);\n+\t\t  $$ = lang_new_vers_pattern ($1, $3, ldgram_vers_current_lang, true);\n \t\t}\n \t|\tvers_defns ';' EXTERN NAME '{'\n \t\t\t{\n@@ -1446,27 +1446,27 @@ vers_defns:\n \t\t\t}\n \t|\tGLOBAL\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern (NULL, \"global\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern (NULL, \"global\", ldgram_vers_current_lang, false);\n \t\t}\n \t|\tvers_defns ';' GLOBAL\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern ($1, \"global\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern ($1, \"global\", ldgram_vers_current_lang, false);\n \t\t}\n \t|\tLOCAL\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern (NULL, \"local\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern (NULL, \"local\", ldgram_vers_current_lang, false);\n \t\t}\n \t|\tvers_defns ';' LOCAL\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern ($1, \"local\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern ($1, \"local\", ldgram_vers_current_lang, false);\n \t\t}\n \t|\tEXTERN\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern (NULL, \"extern\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern (NULL, \"extern\", ldgram_vers_current_lang, false);\n \t\t}\n \t|\tvers_defns ';' EXTERN\n \t\t{\n-\t\t  $$ = lang_new_vers_pattern ($1, \"extern\", ldgram_vers_current_lang, FALSE);\n+\t\t  $$ = lang_new_vers_pattern ($1, \"extern\", ldgram_vers_current_lang, false);\n \t\t}\n \t;\n "
    },
    {
      "sha": "891089932367f53e26234ace901adb76ce18aff2",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 249,
      "deletions": 250,
      "changes": 499,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -63,9 +63,9 @@ static struct obstack map_obstack;\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n static const char *entry_symbol_default = \"start\";\n-static bfd_boolean map_head_is_link_order = FALSE;\n+static bool map_head_is_link_order = false;\n static lang_output_section_statement_type *default_common_section;\n-static bfd_boolean map_option_f;\n+static bool map_option_f;\n static bfd_vma print_dot;\n static lang_input_statement_type *first_file;\n static const char *current_target;\n@@ -79,19 +79,19 @@ static unsigned int opb_shift = 0;\n static void exp_init_os (etree_type *);\n static lang_input_statement_type *lookup_name (const char *);\n static void insert_undefined (const char *);\n-static bfd_boolean sort_def_symbol (struct bfd_link_hash_entry *, void *);\n+static bool sort_def_symbol (struct bfd_link_hash_entry *, void *);\n static void print_statement (lang_statement_union_type *,\n \t\t\t     lang_output_section_statement_type *);\n static void print_statement_list (lang_statement_union_type *,\n \t\t\t\t  lang_output_section_statement_type *);\n static void print_statements (void);\n-static void print_input_section (asection *, bfd_boolean);\n-static bfd_boolean lang_one_common (struct bfd_link_hash_entry *, void *);\n+static void print_input_section (asection *, bool);\n+static bool lang_one_common (struct bfd_link_hash_entry *, void *);\n static void lang_record_phdrs (void);\n static void lang_do_version_exports_section (void);\n static void lang_finalize_version_expr_head\n   (struct bfd_elf_version_expr_head *);\n-static void lang_do_memory_regions (bfd_boolean);\n+static void lang_do_memory_regions (bool);\n \n /* Exported variables.  */\n const char *output_target;\n@@ -122,11 +122,11 @@ struct bfd_elf_dynamic_list **current_dynamic_list_p;\n struct bfd_sym_chain entry_symbol = { NULL, NULL };\n const char *entry_section = \".text\";\n struct lang_input_statement_flags input_flags;\n-bfd_boolean entry_from_cmdline;\n-bfd_boolean lang_has_input_file = FALSE;\n-bfd_boolean had_output_filename = FALSE;\n-bfd_boolean lang_float_flag = FALSE;\n-bfd_boolean delete_output_file_on_failure = FALSE;\n+bool entry_from_cmdline;\n+bool lang_has_input_file = false;\n+bool had_output_filename = false;\n+bool lang_float_flag = false;\n+bool delete_output_file_on_failure = false;\n struct lang_phdr *lang_phdr_list;\n struct lang_nocrossrefs *nocrossref_list;\n struct asneeded_minfo **asneeded_list_tail;\n@@ -219,18 +219,18 @@ archive_path (const char *pattern)\n /* Given that FILE_SPEC results in a non-NULL SEP result from archive_path,\n    return whether F matches FILE_SPEC.  */\n \n-static bfd_boolean\n+static bool\n input_statement_is_archive_path (const char *file_spec, char *sep,\n \t\t\t\t lang_input_statement_type *f)\n {\n-  bfd_boolean match = FALSE;\n+  bool match = false;\n \n   if ((*(sep + 1) == 0\n        || name_match (sep + 1, f->filename) == 0)\n       && ((sep != file_spec)\n \t  == (f->the_bfd != NULL && f->the_bfd->my_archive != NULL)))\n     {\n-      match = TRUE;\n+      match = true;\n \n       if (sep != file_spec)\n \t{\n@@ -243,7 +243,7 @@ input_statement_is_archive_path (const char *file_spec, char *sep,\n   return match;\n }\n \n-static bfd_boolean\n+static bool\n unique_section_p (const asection *sec,\n \t\t  const lang_output_section_statement_type *os)\n {\n@@ -259,17 +259,17 @@ unique_section_p (const asection *sec,\n   secnam = sec->name;\n   for (unam = unique_section_list; unam; unam = unam->next)\n     if (name_match (unam->name, secnam) == 0)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Generic traversal routines for finding matching sections.  */\n \n /* Return true if FILE matches a pattern in EXCLUDE_LIST, otherwise return\n    false.  */\n \n-static bfd_boolean\n+static bool\n walk_wild_file_in_exclude_list (struct name_list *exclude_list,\n \t\t\t\tlang_input_statement_type *file)\n {\n@@ -284,11 +284,11 @@ walk_wild_file_in_exclude_list (struct name_list *exclude_list,\n       if (p != NULL)\n \t{\n \t  if (input_statement_is_archive_path (list_tmp->name, p, file))\n-\t    return TRUE;\n+\t    return true;\n \t}\n \n       else if (name_match (list_tmp->name, file->filename) == 0)\n-\treturn TRUE;\n+\treturn true;\n \n       /* FIXME: Perhaps remove the following at some stage?  Matching\n \t unadorned archives like this was never documented and has\n@@ -297,10 +297,10 @@ walk_wild_file_in_exclude_list (struct name_list *exclude_list,\n \t       && file->the_bfd->my_archive != NULL\n \t       && name_match (list_tmp->name,\n \t\t\t      bfd_get_filename (file->the_bfd->my_archive)) == 0)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Try processing a section against a wildcard.  This just calls\n@@ -343,7 +343,7 @@ walk_wild_section_general (lang_wild_statement_type *ptr,\n \n       while (sec != NULL)\n \t{\n-\t  bfd_boolean skip = FALSE;\n+\t  bool skip = false;\n \n \t  if (sec->spec.name != NULL)\n \t    {\n@@ -366,30 +366,30 @@ walk_wild_section_general (lang_wild_statement_type *ptr,\n typedef struct\n {\n   asection *found_section;\n-  bfd_boolean multiple_sections_found;\n+  bool multiple_sections_found;\n } section_iterator_callback_data;\n \n-static bfd_boolean\n+static bool\n section_iterator_callback (bfd *abfd ATTRIBUTE_UNUSED, asection *s, void *data)\n {\n   section_iterator_callback_data *d = (section_iterator_callback_data *) data;\n \n   if (d->found_section != NULL)\n     {\n-      d->multiple_sections_found = TRUE;\n-      return TRUE;\n+      d->multiple_sections_found = true;\n+      return true;\n     }\n \n   d->found_section = s;\n-  return FALSE;\n+  return false;\n }\n \n static asection *\n find_section (lang_input_statement_type *file,\n \t      struct wildcard_list *sec,\n-\t      bfd_boolean *multiple_sections_found)\n+\t      bool *multiple_sections_found)\n {\n-  section_iterator_callback_data cb_data = { NULL, FALSE };\n+  section_iterator_callback_data cb_data = { NULL, false };\n \n   bfd_get_section_by_name_if (file->the_bfd, sec->spec.name,\n \t\t\t      section_iterator_callback, &cb_data);\n@@ -403,29 +403,29 @@ find_section (lang_input_statement_type *file,\n /* A simple wild is a literal string followed by a single '*',\n    where the literal part is at least 4 characters long.  */\n \n-static bfd_boolean\n+static bool\n is_simple_wild (const char *name)\n {\n   size_t len = strcspn (name, \"*?[\");\n   return len >= 4 && name[len] == '*' && name[len + 1] == '\\0';\n }\n \n-static bfd_boolean\n+static bool\n match_simple_wild (const char *pattern, const char *name)\n {\n   /* The first four characters of the pattern are guaranteed valid\n      non-wildcard characters.  So we can go faster.  */\n   if (pattern[0] != name[0] || pattern[1] != name[1]\n       || pattern[2] != name[2] || pattern[3] != name[3])\n-    return FALSE;\n+    return false;\n \n   pattern += 4;\n   name += 4;\n   while (*pattern != '*')\n     if (*name++ != *pattern++)\n-      return FALSE;\n+      return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Return the numerical value of the init_priority attribute from\n@@ -622,7 +622,7 @@ walk_wild_section_specs1_wild0 (lang_wild_statement_type *ptr,\n      (should be rare), we fall back to the general algorithm because\n      we would otherwise have to sort the sections to make sure they\n      get processed in the bfd's order.  */\n-  bfd_boolean multiple_sections_found;\n+  bool multiple_sections_found;\n   struct wildcard_list *sec0 = ptr->handler_data[0];\n   asection *s0 = find_section (file, sec0, &multiple_sections_found);\n \n@@ -644,7 +644,7 @@ walk_wild_section_specs1_wild1 (lang_wild_statement_type *ptr,\n   for (s = file->the_bfd->sections; s != NULL; s = s->next)\n     {\n       const char *sname = bfd_section_name (s);\n-      bfd_boolean skip = !match_simple_wild (wildsec0->spec.name, sname);\n+      bool skip = !match_simple_wild (wildsec0->spec.name, sname);\n \n       if (!skip)\n \twalk_wild_consider_section (ptr, file, s, wildsec0, callback, data);\n@@ -660,7 +660,7 @@ walk_wild_section_specs2_wild1 (lang_wild_statement_type *ptr,\n   asection *s;\n   struct wildcard_list *sec0 = ptr->handler_data[0];\n   struct wildcard_list *wildsec1 = ptr->handler_data[1];\n-  bfd_boolean multiple_sections_found;\n+  bool multiple_sections_found;\n   asection *s0 = find_section (file, sec0, &multiple_sections_found);\n \n   if (multiple_sections_found)\n@@ -681,7 +681,7 @@ walk_wild_section_specs2_wild1 (lang_wild_statement_type *ptr,\n       else\n \t{\n \t  const char *sname = bfd_section_name (s);\n-\t  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);\n+\t  bool skip = !match_simple_wild (wildsec1->spec.name, sname);\n \n \t  if (!skip)\n \t    walk_wild_consider_section (ptr, file, s, wildsec1, callback,\n@@ -700,7 +700,7 @@ walk_wild_section_specs3_wild2 (lang_wild_statement_type *ptr,\n   struct wildcard_list *sec0 = ptr->handler_data[0];\n   struct wildcard_list *wildsec1 = ptr->handler_data[1];\n   struct wildcard_list *wildsec2 = ptr->handler_data[2];\n-  bfd_boolean multiple_sections_found;\n+  bool multiple_sections_found;\n   asection *s0 = find_section (file, sec0, &multiple_sections_found);\n \n   if (multiple_sections_found)\n@@ -716,7 +716,7 @@ walk_wild_section_specs3_wild2 (lang_wild_statement_type *ptr,\n       else\n \t{\n \t  const char *sname = bfd_section_name (s);\n-\t  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);\n+\t  bool skip = !match_simple_wild (wildsec1->spec.name, sname);\n \n \t  if (!skip)\n \t    walk_wild_consider_section (ptr, file, s, wildsec1, callback, data);\n@@ -742,7 +742,7 @@ walk_wild_section_specs4_wild2 (lang_wild_statement_type *ptr,\n   struct wildcard_list *sec1 = ptr->handler_data[1];\n   struct wildcard_list *wildsec2 = ptr->handler_data[2];\n   struct wildcard_list *wildsec3 = ptr->handler_data[3];\n-  bfd_boolean multiple_sections_found;\n+  bool multiple_sections_found;\n   asection *s0 = find_section (file, sec0, &multiple_sections_found), *s1;\n \n   if (multiple_sections_found)\n@@ -768,8 +768,7 @@ walk_wild_section_specs4_wild2 (lang_wild_statement_type *ptr,\n \telse\n \t  {\n \t    const char *sname = bfd_section_name (s);\n-\t    bfd_boolean skip = !match_simple_wild (wildsec2->spec.name,\n-\t\t\t\t\t\t   sname);\n+\t    bool skip = !match_simple_wild (wildsec2->spec.name, sname);\n \n \t    if (!skip)\n \t      walk_wild_consider_section (ptr, file, s, wildsec2, callback,\n@@ -802,7 +801,7 @@ walk_wild_section (lang_wild_statement_type *ptr,\n    only if the prefixes of name1 and name2 are different up to the\n    first wildcard character.  */\n \n-static bfd_boolean\n+static bool\n wild_spec_can_overlap (const char *name1, const char *name2)\n {\n   size_t prefix1_len = strcspn (name1, \"?*[\");\n@@ -1114,7 +1113,7 @@ new_afile (const char *name,\n {\n   lang_input_statement_type *p;\n \n-  lang_has_input_file = TRUE;\n+  lang_has_input_file = true;\n \n   p = new_stat (lang_input_statement, stat_ptr);\n   memset (&p->the_bfd, 0,\n@@ -1132,8 +1131,8 @@ new_afile (const char *name,\n     case lang_input_file_is_symbols_only_enum:\n       p->filename = name;\n       p->local_sym_name = name;\n-      p->flags.real = TRUE;\n-      p->flags.just_syms = TRUE;\n+      p->flags.real = true;\n+      p->flags.just_syms = true;\n       break;\n     case lang_input_file_is_fake_enum:\n       p->filename = name;\n@@ -1143,19 +1142,19 @@ new_afile (const char *name,\n       if (name[0] == ':' && name[1] != '\\0')\n \t{\n \t  p->filename = name + 1;\n-\t  p->flags.full_name_provided = TRUE;\n+\t  p->flags.full_name_provided = true;\n \t}\n       else\n \tp->filename = name;\n       p->local_sym_name = concat (\"-l\", name, (const char *) NULL);\n-      p->flags.maybe_archive = TRUE;\n-      p->flags.real = TRUE;\n-      p->flags.search_dirs = TRUE;\n+      p->flags.maybe_archive = true;\n+      p->flags.real = true;\n+      p->flags.search_dirs = true;\n       break;\n     case lang_input_file_is_marker_enum:\n       p->filename = name;\n       p->local_sym_name = name;\n-      p->flags.search_dirs = TRUE;\n+      p->flags.search_dirs = true;\n       break;\n     case lang_input_file_is_search_file_enum:\n       p->filename = name;\n@@ -1164,13 +1163,13 @@ new_afile (const char *name,\n          script first. */\n       if (from_filename && !IS_ABSOLUTE_PATH (name))\n         p->extra_search_path = ldirname (from_filename);\n-      p->flags.real = TRUE;\n-      p->flags.search_dirs = TRUE;\n+      p->flags.real = true;\n+      p->flags.search_dirs = true;\n       break;\n     case lang_input_file_is_file_enum:\n       p->filename = name;\n       p->local_sym_name = name;\n-      p->flags.real = TRUE;\n+      p->flags.real = true;\n       break;\n     default:\n       FAIL ();\n@@ -1346,7 +1345,7 @@ static lang_memory_region_type **lang_memory_region_list_tail\n   = &lang_memory_region_list;\n \n lang_memory_region_type *\n-lang_memory_region_lookup (const char *const name, bfd_boolean create)\n+lang_memory_region_lookup (const char *const name, bool create)\n {\n   lang_memory_region_name *n;\n   lang_memory_region_type *r;\n@@ -1383,7 +1382,7 @@ lang_memory_region_lookup (const char *const name, bfd_boolean create)\n   new_region->last_os = NULL;\n   new_region->flags = 0;\n   new_region->not_flags = 0;\n-  new_region->had_full_message = FALSE;\n+  new_region->had_full_message = false;\n \n   *lang_memory_region_list_tail = new_region;\n   lang_memory_region_list_tail = &new_region->next;\n@@ -1451,7 +1450,7 @@ lang_memory_default (asection *section)\n \t  return p;\n \t}\n     }\n-  return lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);\n+  return lang_memory_region_lookup (DEFAULT_MEMORY_REGION, false);\n }\n \n /* Get the output section statement directly from the userdata.  */\n@@ -1478,7 +1477,7 @@ lang_output_section_statement_lookup (const char *name,\n \n   entry = ((struct out_section_hash_entry *)\n \t   bfd_hash_lookup (&output_section_statement_table, name,\n-\t\t\t    create != 0, FALSE));\n+\t\t\t    create != 0, false));\n   if (entry == NULL)\n     {\n       if (create)\n@@ -1655,7 +1654,7 @@ lang_output_section_find_by_flags (const asection *sec,\n     {\n       /* .tdata can go after .data, .tbss after .tdata.  Treat .tbss\n \t as if it were a loaded section, and don't use match_type.  */\n-      bfd_boolean seen_thread_local = FALSE;\n+      bool seen_thread_local = false;\n \n       match_type = NULL;\n       for (look = first; look; look = look->next)\n@@ -1675,7 +1674,7 @@ lang_output_section_find_by_flags (const asection *sec,\n \t\t   previous section.  */\n \t\tbreak;\n \t      found = look;\n-\t      seen_thread_local = TRUE;\n+\t      seen_thread_local = true;\n \t    }\n \t  else if (seen_thread_local)\n \t    break;\n@@ -1803,7 +1802,7 @@ insert_os_after (lang_output_section_statement_type *after)\n {\n   lang_statement_union_type **where;\n   lang_statement_union_type **assign = NULL;\n-  bfd_boolean ignore_first;\n+  bool ignore_first;\n \n   ignore_first = after == (void *) lang_os_list.head;\n \n@@ -1825,7 +1824,7 @@ insert_os_after (lang_output_section_statement_type *after)\n \t\t{\n \t\t  if (!ignore_first)\n \t\t    assign = where;\n-\t\t  ignore_first = FALSE;\n+\t\t  ignore_first = false;\n \t\t}\n \t    }\n \t  continue;\n@@ -1838,7 +1837,7 @@ insert_os_after (lang_output_section_statement_type *after)\n \tcase lang_padding_statement_enum:\n \tcase lang_constructors_statement_enum:\n \t  assign = NULL;\n-\t  ignore_first = FALSE;\n+\t  ignore_first = false;\n \t  continue;\n \tcase lang_output_section_statement_enum:\n \t  if (assign != NULL)\n@@ -1921,8 +1920,8 @@ lang_insert_orphan (asection *s,\n   if (after != NULL && os->bfd_section != NULL)\n     {\n       asection *snew, *as;\n-      bfd_boolean place_after = place->stmt == NULL;\n-      bfd_boolean insert_after = TRUE;\n+      bool place_after = place->stmt == NULL;\n+      bool insert_after = true;\n \n       snew = os->bfd_section;\n \n@@ -1977,7 +1976,7 @@ lang_insert_orphan (asection *s,\n \t  asection *after_sec;\n \t  /* True if we need to insert the orphan section after a\n \t     specific section to maintain output note section order.  */\n-\t  bfd_boolean after_sec_note = FALSE;\n+\t  bool after_sec_note = false;\n \n \t  static asection *first_orphan_note = NULL;\n \n@@ -2021,14 +2020,14 @@ lang_insert_orphan (asection *s,\n \t\t     alignments, place the section before all\n \t\t     output orphan note sections.  */\n \t\t  after_sec = first_orphan_note;\n-\t\t  insert_after = FALSE;\n+\t\t  insert_after = false;\n \t\t}\n \t    }\n \t  else if (first_orphan_note)\n \t    {\n \t      /* Don't place non-note sections in the middle of orphan\n \t         note sections.  */\n-\t      after_sec_note = TRUE;\n+\t      after_sec_note = true;\n \t      after_sec = as;\n \t      for (sec = as->next;\n \t\t   (sec != NULL\n@@ -2046,16 +2045,16 @@ lang_insert_orphan (asection *s,\n \t\t  /* Search forward to insert OS after AFTER_SEC output\n \t\t     statement.  */\n \t\t  lang_output_section_statement_type *stmt, *next;\n-\t\t  bfd_boolean found = FALSE;\n+\t\t  bool found = false;\n \t\t  for (stmt = after; stmt != NULL; stmt = next)\n \t\t    {\n \t\t      next = stmt->next;\n \t\t      if (insert_after)\n \t\t\t{\n \t\t\t  if (stmt->bfd_section == after_sec)\n \t\t\t    {\n-\t\t\t      place_after = TRUE;\n-\t\t\t      found = TRUE;\n+\t\t\t      place_after = true;\n+\t\t\t      found = true;\n \t\t\t      after = stmt;\n \t\t\t      break;\n \t\t\t    }\n@@ -2066,8 +2065,8 @@ lang_insert_orphan (asection *s,\n \t\t\t     AFTER_SEC output statement.  */\n \t\t\t  if (next && next->bfd_section == after_sec)\n \t\t\t    {\n-\t\t\t      place_after = TRUE;\n-\t\t\t      found = TRUE;\n+\t\t\t      place_after = true;\n+\t\t\t      found = true;\n \t\t\t      after = stmt;\n \t\t\t      break;\n \t\t\t    }\n@@ -2083,7 +2082,7 @@ lang_insert_orphan (asection *s,\n \t\t\t  {\n \t\t\t    if (stmt->bfd_section == after_sec)\n \t\t\t      {\n-\t\t\t\tplace_after = TRUE;\n+\t\t\t\tplace_after = true;\n \t\t\t\tafter = stmt;\n \t\t\t\tbreak;\n \t\t\t      }\n@@ -2094,7 +2093,7 @@ lang_insert_orphan (asection *s,\n \t\t\t       AFTER_SEC output statement.  */\n \t\t\t    if (stmt->next->bfd_section == after_sec)\n \t\t\t      {\n-\t\t\t\tplace_after = TRUE;\n+\t\t\t\tplace_after = true;\n \t\t\t\tafter = stmt;\n \t\t\t\tbreak;\n \t\t\t      }\n@@ -2266,7 +2265,7 @@ void\n lang_map (void)\n {\n   lang_memory_region_type *m;\n-  bfd_boolean dis_header_printed = FALSE;\n+  bool dis_header_printed = false;\n \n   LANG_FOR_EACH_INPUT_STATEMENT (file)\n     {\n@@ -2285,10 +2284,10 @@ lang_map (void)\n \t      if (! dis_header_printed)\n \t\t{\n \t\t  fprintf (config.map_file, _(\"\\nDiscarded input sections\\n\\n\"));\n-\t\t  dis_header_printed = TRUE;\n+\t\t  dis_header_printed = true;\n \t\t}\n \n-\t      print_input_section (s, TRUE);\n+\t      print_input_section (s, true);\n \t    }\n     }\n \n@@ -2349,7 +2348,7 @@ lang_map (void)\n \t\t\t      config.map_file);\n }\n \n-static bfd_boolean\n+static bool\n sort_def_symbol (struct bfd_link_hash_entry *hash_entry,\n \t\t void *info ATTRIBUTE_UNUSED)\n {\n@@ -2378,7 +2377,7 @@ sort_def_symbol (struct bfd_link_hash_entry *hash_entry,\n       ud->map_symbol_def_tail = &def->next;\n       ud->map_symbol_def_count++;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Initialize an output section.  */\n@@ -2502,10 +2501,10 @@ section_already_linked (bfd *abfd, asection *sec, void *data)\n /* Returns true if SECTION is one we know will be discarded based on its\n    section flags, otherwise returns false.  */\n \n-static bfd_boolean\n+static bool\n lang_discard_section_p (asection *section)\n {\n-  bfd_boolean discard;\n+  bool discard;\n   flagword flags = section->flags;\n \n   /* Discard sections marked with SEC_EXCLUDE.  */\n@@ -2515,13 +2514,13 @@ lang_discard_section_p (asection *section)\n      sections from within the group.  */\n   if ((flags & SEC_GROUP) != 0\n       && link_info.resolve_section_groups)\n-    discard = TRUE;\n+    discard = true;\n \n   /* Discard debugging sections if we are stripping debugging\n      information.  */\n   if ((link_info.strip == strip_debugger || link_info.strip == strip_all)\n       && (flags & SEC_DEBUGGING) != 0)\n-    discard = TRUE;\n+    discard = true;\n \n   return discard;\n }\n@@ -2544,7 +2543,7 @@ lang_add_section (lang_statement_list_type *ptr,\n {\n   flagword flags = section->flags;\n \n-  bfd_boolean discard;\n+  bool discard;\n   lang_input_section_type *new_section;\n   bfd *abfd = link_info.output_bfd;\n \n@@ -2554,7 +2553,7 @@ lang_add_section (lang_statement_list_type *ptr,\n   /* Discard input sections which are assigned to a section named\n      DISCARD_SECTION_NAME.  */\n   if (strcmp (output->name, DISCARD_SECTION_NAME) == 0)\n-    discard = TRUE;\n+    discard = true;\n \n   if (discard)\n     {\n@@ -2573,7 +2572,7 @@ lang_add_section (lang_statement_list_type *ptr,\n \n   if (sflag_info)\n     {\n-      bfd_boolean keep;\n+      bool keep;\n \n       keep = bfd_lookup_section_flags (&link_info, sflag_info, section);\n       if (!keep)\n@@ -2753,7 +2752,7 @@ wild_sort (lang_wild_statement_type *wild,\n       if (wild->filenames_sorted)\n \t{\n \t  const char *fn, *ln;\n-\t  bfd_boolean fa, la;\n+\t  bool fa, la;\n \t  int i;\n \n \t  /* The PE support for the .idata section as generated by\n@@ -2765,23 +2764,23 @@ wild_sort (lang_wild_statement_type *wild,\n \t      && file->the_bfd->my_archive != NULL)\n \t    {\n \t      fn = bfd_get_filename (file->the_bfd->my_archive);\n-\t      fa = TRUE;\n+\t      fa = true;\n \t    }\n \t  else\n \t    {\n \t      fn = file->filename;\n-\t      fa = FALSE;\n+\t      fa = false;\n \t    }\n \n \t  if (ls->section->owner->my_archive != NULL)\n \t    {\n \t      ln = bfd_get_filename (ls->section->owner->my_archive);\n-\t      la = TRUE;\n+\t      la = true;\n \t    }\n \t  else\n \t    {\n \t      ln = bfd_get_filename (ls->section->owner);\n-\t      la = FALSE;\n+\t      la = false;\n \t    }\n \n \t  i = filename_cmp (fn, ln);\n@@ -2892,7 +2891,7 @@ check_section_callback (lang_wild_statement_type *ptr ATTRIBUTE_UNUSED,\n     return;\n \n   if (section->output_section == NULL && (section->flags & SEC_READONLY) == 0)\n-    os->all_input_readonly = FALSE;\n+    os->all_input_readonly = false;\n }\n \n /* This is passed a file name which must have been seen already and\n@@ -2994,7 +2993,7 @@ check_excluded_libs (bfd *abfd)\n \n       if (strcmp (lib->name, \"ALL\") == 0)\n \t{\n-\t  abfd->no_export = TRUE;\n+\t  abfd->no_export = true;\n \t  return;\n \t}\n \n@@ -3003,7 +3002,7 @@ check_excluded_libs (bfd *abfd)\n \t      || (filename[len] == '.' && filename[len + 1] == 'a'\n \t\t  && filename[len + 2] == '\\0')))\n \t{\n-\t  abfd->no_export = TRUE;\n+\t  abfd->no_export = true;\n \t  return;\n \t}\n \n@@ -3013,20 +3012,20 @@ check_excluded_libs (bfd *abfd)\n \n /* Get the symbols for an input file.  */\n \n-bfd_boolean\n+bool\n load_symbols (lang_input_statement_type *entry,\n \t      lang_statement_list_type *place)\n {\n   char **matching;\n \n   if (entry->flags.loaded)\n-    return TRUE;\n+    return true;\n \n   ldfile_open_file (entry);\n \n   /* Do not process further if the file was missing.  */\n   if (entry->flags.missing_file)\n-    return TRUE;\n+    return true;\n \n   if (trace_files || verbose)\n     info_msg (\"%pI\\n\", entry);\n@@ -3042,7 +3041,7 @@ load_symbols (lang_input_statement_type *entry,\n \n       /* See if the emulation has some special knowledge.  */\n       if (ldemul_unrecognized_file (entry))\n-\treturn TRUE;\n+\treturn true;\n \n       if (err == bfd_error_file_ambiguously_recognized)\n \t{\n@@ -3073,12 +3072,12 @@ load_symbols (lang_input_statement_type *entry,\n       input_flags.whole_archive = entry->flags.whole_archive;\n       input_flags.dynamic = entry->flags.dynamic;\n \n-      ldfile_assumed_script = TRUE;\n+      ldfile_assumed_script = true;\n       parser_input = input_script;\n       current_input_file = entry->filename;\n       yyparse ();\n       current_input_file = NULL;\n-      ldfile_assumed_script = FALSE;\n+      ldfile_assumed_script = false;\n \n       /* missing_file is sticky.  sysrooted will already have been\n \t restored when seeing EOF in yyparse, but no harm to restore\n@@ -3088,13 +3087,13 @@ load_symbols (lang_input_statement_type *entry,\n       pop_stat_ptr ();\n       fclose (yyin);\n       yyin = NULL;\n-      entry->flags.loaded = TRUE;\n+      entry->flags.loaded = true;\n \n-      return TRUE;\n+      return true;\n     }\n \n   if (ldemul_recognized_file (entry))\n-    return TRUE;\n+    return true;\n \n   /* We don't call ldlang_add_file for an archive.  Instead, the\n      add_symbols entry point will call ldlang_add_file, via the\n@@ -3117,7 +3116,7 @@ load_symbols (lang_input_statement_type *entry,\n       if (entry->flags.whole_archive)\n \t{\n \t  bfd *member = NULL;\n-\t  bfd_boolean loaded = TRUE;\n+\t  bool loaded = true;\n \n \t  for (;;)\n \t    {\n@@ -3131,7 +3130,7 @@ load_symbols (lang_input_statement_type *entry,\n \t\t{\n \t\t  einfo (_(\"%F%P: %pB: member %pB in archive is not an object\\n\"),\n \t\t\t entry->the_bfd, member);\n-\t\t  loaded = FALSE;\n+\t\t  loaded = false;\n \t\t}\n \n \t      subsbfd = member;\n@@ -3145,7 +3144,7 @@ load_symbols (lang_input_statement_type *entry,\n \t      if (!bfd_link_add_symbols (subsbfd, &link_info))\n \t\t{\n \t\t  einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), member);\n-\t\t  loaded = FALSE;\n+\t\t  loaded = false;\n \t\t}\n \t    }\n \n@@ -3156,7 +3155,7 @@ load_symbols (lang_input_statement_type *entry,\n     }\n \n   if (bfd_link_add_symbols (entry->the_bfd, &link_info))\n-    entry->flags.loaded = TRUE;\n+    entry->flags.loaded = true;\n   else\n     einfo (_(\"%F%P: %pB: error adding symbols: %E\\n\"), entry->the_bfd);\n \n@@ -3451,7 +3450,7 @@ open_output (const char *name)\n       einfo (_(\"%F%P: cannot open output file %s: %E\\n\"), name);\n     }\n \n-  delete_output_file_on_failure = TRUE;\n+  delete_output_file_on_failure = true;\n \n   if (!bfd_set_format (link_info.output_bfd, bfd_object))\n     einfo (_(\"%F%P: %s: can not make object file: %E\\n\"), name);\n@@ -3618,15 +3617,15 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)\n \t\t\t  && bfd_get_flavour (abfd) == bfd_target_elf_flavour\n \t\t\t  && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0)))\n \t\t{\n-\t\t  s->input_statement.flags.loaded = FALSE;\n-\t\t  s->input_statement.flags.reload = TRUE;\n+\t\t  s->input_statement.flags.loaded = false;\n+\t\t  s->input_statement.flags.reload = true;\n \t\t}\n \n \t      os_tail = lang_os_list.tail;\n \t      lang_list_init (&add);\n \n \t      if (!load_symbols (&s->input_statement, &add))\n-\t\tconfig.make_executable = FALSE;\n+\t\tconfig.make_executable = false;\n \n \t      if (add.head != NULL)\n \t\t{\n@@ -3957,7 +3956,7 @@ typedef struct bfd_sym_chain ldlang_undef_chain_list_type;\n #define ldlang_undef_chain_list_head entry_symbol.next\n \n void\n-ldlang_add_undef (const char *const name, bfd_boolean cmdline ATTRIBUTE_UNUSED)\n+ldlang_add_undef (const char *const name, bool cmdline ATTRIBUTE_UNUSED)\n {\n   ldlang_undef_chain_list_type *new_undef;\n \n@@ -3978,14 +3977,14 @@ insert_undefined (const char *name)\n {\n   struct bfd_link_hash_entry *h;\n \n-  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);\n+  h = bfd_link_hash_lookup (link_info.hash, name, true, false, true);\n   if (h == NULL)\n     einfo (_(\"%F%P: bfd_link_hash_lookup failed: %E\\n\"));\n   if (h->type == bfd_link_hash_new)\n     {\n       h->type = bfd_link_hash_undefined;\n       h->u.undef.abfd = NULL;\n-      h->non_ir_ref_regular = TRUE;\n+      h->non_ir_ref_regular = true;\n       bfd_link_add_undef (link_info.hash, h);\n     }\n }\n@@ -4014,7 +4013,7 @@ lang_mark_undefineds (void)\n     for (ptr = ldlang_undef_chain_list_head; ptr != NULL; ptr = ptr->next)\n       {\n \tstruct elf_link_hash_entry *h = (struct elf_link_hash_entry *)\n-\t  bfd_link_hash_lookup (link_info.hash, ptr->name, FALSE, FALSE, TRUE);\n+\t  bfd_link_hash_lookup (link_info.hash, ptr->name, false, false, true);\n \tif (h != NULL)\n \t  h->mark = 1;\n       }\n@@ -4041,7 +4040,7 @@ ldlang_add_require_defined (const char *const name)\n {\n   struct require_defined_symbol *ptr;\n \n-  ldlang_add_undef (name, TRUE);\n+  ldlang_add_undef (name, true);\n   ptr = stat_alloc (sizeof (*ptr));\n   ptr->next = require_defined_symbol_list;\n   ptr->name = strdup (name);\n@@ -4061,7 +4060,7 @@ ldlang_check_require_defined_symbols (void)\n       struct bfd_link_hash_entry *h;\n \n       h = bfd_link_hash_lookup (link_info.hash, ptr->name,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n       if (h == NULL\n \t  || (h->type != bfd_link_hash_defined\n \t      && h->type != bfd_link_hash_defweak))\n@@ -4197,7 +4196,7 @@ map_input_to_output_sections\n \t  if (tos->constraint == ONLY_IF_RW\n \t      || tos->constraint == ONLY_IF_RO)\n \t    {\n-\t      tos->all_input_readonly = TRUE;\n+\t      tos->all_input_readonly = true;\n \t      check_input_sections (tos->children.head, tos);\n \t      if (tos->all_input_readonly != (tos->constraint == ONLY_IF_RO))\n \t\ttos->constraint = -1;\n@@ -4495,7 +4494,7 @@ strip_excluded_output_sections (void)\n     {\n       expld.phase = lang_mark_phase_enum;\n       expld.dataseg.phase = exp_seg_none;\n-      one_lang_size_sections_pass (NULL, FALSE);\n+      one_lang_size_sections_pass (NULL, false);\n       lang_reset_memory_regions ();\n     }\n \n@@ -4504,7 +4503,7 @@ strip_excluded_output_sections (void)\n        os = os->next)\n     {\n       asection *output_section;\n-      bfd_boolean exclude;\n+      bool exclude;\n \n       if (os->constraint < 0)\n \tcontinue;\n@@ -4531,7 +4530,7 @@ strip_excluded_output_sections (void)\n \t\t&& ((s->flags & SEC_LINKER_CREATED) != 0\n \t\t    || link_info.emitrelocations))\n \t      {\n-\t\texclude = FALSE;\n+\t\texclude = false;\n \t\tbreak;\n \t      }\n \t}\n@@ -4541,7 +4540,7 @@ strip_excluded_output_sections (void)\n \t  /* We don't set bfd_section to NULL since bfd_section of the\n \t     removed output section statement may still be used.  */\n \t  if (!os->update_dot)\n-\t    os->ignored = TRUE;\n+\t    os->ignored = true;\n \t  output_section->flags |= SEC_EXCLUDE;\n \t  bfd_section_list_remove (link_info.output_bfd, output_section);\n \t  link_info.output_bfd->section_count--;\n@@ -4580,7 +4579,7 @@ lang_clear_os_map (void)\n \n   /* Stop future calls to lang_add_section from messing with map_head\n      and map_tail link_order fields.  */\n-  map_head_is_link_order = TRUE;\n+  map_head_is_link_order = true;\n }\n \n static void\n@@ -4632,7 +4631,7 @@ print_assignment (lang_assignment_statement_type *assignment,\n \t\t  lang_output_section_statement_type *output_section)\n {\n   unsigned int i;\n-  bfd_boolean is_dot;\n+  bool is_dot;\n   etree_type *tree;\n   asection *osec;\n \n@@ -4641,7 +4640,7 @@ print_assignment (lang_assignment_statement_type *assignment,\n \n   if (assignment->exp->type.node_class == etree_assert)\n     {\n-      is_dot = FALSE;\n+      is_dot = false;\n       tree = assignment->exp->assert_s.child;\n     }\n   else\n@@ -4659,7 +4658,7 @@ print_assignment (lang_assignment_statement_type *assignment,\n   if (assignment->exp->type.node_class != etree_provide)\n     exp_fold_tree (tree, osec, &print_dot);\n   else\n-    expld.result.valid_p = FALSE;\n+    expld.result.valid_p = false;\n \n   if (expld.result.valid_p)\n     {\n@@ -4683,7 +4682,7 @@ print_assignment (lang_assignment_statement_type *assignment,\n \t  struct bfd_link_hash_entry *h;\n \n \t  h = bfd_link_hash_lookup (link_info.hash, assignment->exp->assign.dst,\n-\t\t\t\t    FALSE, FALSE, TRUE);\n+\t\t\t\t    false, false, true);\n \t  if (h != NULL\n \t      && (h->type == bfd_link_hash_defined\n \t\t  || h->type == bfd_link_hash_defweak))\n@@ -4725,7 +4724,7 @@ print_input_statement (lang_input_statement_type *statm)\n /* Print all symbols defined in a particular section.  This is called\n    via bfd_link_hash_traverse, or by print_all_symbols.  */\n \n-bfd_boolean\n+bool\n print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)\n {\n   asection *sec = (asection *) ptr;\n@@ -4746,7 +4745,7 @@ print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)\n       minfo (\"             %pT\\n\", hash_entry->root.string);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -4797,7 +4796,7 @@ print_all_symbols (asection *sec)\n /* Print information about an input section to the map file.  */\n \n static void\n-print_input_section (asection *i, bfd_boolean is_discarded)\n+print_input_section (asection *i, bool is_discarded)\n {\n   bfd_size_type size = i->size;\n   int len;\n@@ -5169,7 +5168,7 @@ print_statement (lang_statement_union_type *s,\n       print_reloc_statement (&s->reloc_statement);\n       break;\n     case lang_input_section_enum:\n-      print_input_section (s->input_section.section, FALSE);\n+      print_input_section (s->input_section.section, false);\n       break;\n     case lang_padding_statement_enum:\n       print_padding_statement (&s->padding_statement);\n@@ -5286,7 +5285,7 @@ size_input_section\n   (lang_statement_union_type **this_ptr,\n    lang_output_section_statement_type *output_section_statement,\n    fill_type *fill,\n-   bfd_boolean *removed,\n+   bool *removed,\n    bfd_vma dot)\n {\n   lang_input_section_type *is = &((*this_ptr)->input_section);\n@@ -5391,7 +5390,7 @@ size_input_section\n struct check_sec\n {\n   asection *sec;\n-  bfd_boolean warned;\n+  bool warned;\n };\n \n static int\n@@ -5453,7 +5452,7 @@ lang_check_section_addresses (void)\n   bfd_vma p_start = 0;\n   bfd_vma p_end = 0;\n   lang_memory_region_type *m;\n-  bfd_boolean overlays;\n+  bool overlays;\n \n   /* Detect address space overflow on allocated sections.  */\n   addr_mask = ((bfd_vma) 1 <<\n@@ -5490,7 +5489,7 @@ lang_check_section_addresses (void)\n \tcontinue;\n \n       sections[count].sec = s;\n-      sections[count].warned = FALSE;\n+      sections[count].warned = false;\n       count++;\n     }\n \n@@ -5525,7 +5524,7 @@ lang_check_section_addresses (void)\n \t      einfo (_(\"%X%P: section %s LMA [%V,%V]\"\n \t\t       \" overlaps section %s LMA [%V,%V]\\n\"),\n \t\t     s->name, s_start, s_end, p->name, p_start, p_end);\n-\t      sections[i].warned = TRUE;\n+\t      sections[i].warned = true;\n \t    }\n \t  p = s;\n \t  p_start = s_start;\n@@ -5539,14 +5538,14 @@ lang_check_section_addresses (void)\n      this property.  It is possible to intentionally generate overlays\n      that fail this test, but it would be unusual.  */\n   qsort (sections, count, sizeof (*sections), sort_sections_by_vma);\n-  overlays = FALSE;\n+  overlays = false;\n   p_start = sections[0].sec->vma;\n   for (i = 1; i < count; i++)\n     {\n       s_start = sections[i].sec->vma;\n       if (p_start == s_start)\n \t{\n-\t  overlays = TRUE;\n+\t  overlays = true;\n \t  break;\n \t}\n       p_start = s_start;\n@@ -5623,7 +5622,7 @@ os_region_check (lang_output_section_statement_type *os,\n \t}\n       else if (!region->had_full_message)\n \t{\n-\t  region->had_full_message = TRUE;\n+\t  region->had_full_message = true;\n \n \t  einfo (_(\"%X%P: %pB section `%s' will not fit in region `%s'\\n\"),\n \t\t os->bfd_section->owner,\n@@ -5665,17 +5664,17 @@ lang_size_sections_1\n    lang_output_section_statement_type *output_section_statement,\n    fill_type *fill,\n    bfd_vma dot,\n-   bfd_boolean *relax,\n-   bfd_boolean check_regions)\n+   bool *relax,\n+   bool check_regions)\n {\n   lang_statement_union_type *s;\n   lang_statement_union_type *prev_s = NULL;\n-  bfd_boolean removed_prev_s = FALSE;\n+  bool removed_prev_s = false;\n \n   /* Size up the sections from their constituent parts.  */\n   for (s = *prev; s != NULL; prev_s = s, s = s->header.next)\n     {\n-      bfd_boolean removed=FALSE;\n+      bool removed = false;\n \n       switch (s->header.type)\n \t{\n@@ -5701,7 +5700,7 @@ lang_size_sections_1\n \t      os->addr_tree = exp_intop (0);\n \t    if (os->addr_tree != NULL)\n \t      {\n-\t\tos->processed_vma = FALSE;\n+\t\tos->processed_vma = false;\n \t\texp_fold_tree (os->addr_tree, bfd_abs_section_ptr, &dot);\n \n \t\tif (expld.result.valid_p)\n@@ -5845,7 +5844,7 @@ lang_size_sections_1\n \t    lang_size_sections_1 (&os->children.head, os,\n \t\t\t\t  os->fill, newdot, relax, check_regions);\n \n-\t    os->processed_vma = TRUE;\n+\t    os->processed_vma = true;\n \n \t    if (bfd_is_abs_section (os->bfd_section) || os->ignored)\n \t      /* Except for some special linker created sections,\n@@ -5873,7 +5872,7 @@ lang_size_sections_1\n \t    /* Set section lma.  */\n \t    r = os->region;\n \t    if (r == NULL)\n-\t      r = lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);\n+\t      r = lang_memory_region_lookup (DEFAULT_MEMORY_REGION, false);\n \n \t    if (os->load_base)\n \t      {\n@@ -5944,7 +5943,7 @@ lang_size_sections_1\n \t\t    os->bfd_section->lma = lma;\n \t\t  }\n \t      }\n-\t    os->processed_lma = TRUE;\n+\t    os->processed_lma = true;\n \n \t    /* Keep track of normal sections using the default\n \t       lma region.  We use this to set the lma for\n@@ -6102,12 +6101,12 @@ lang_size_sections_1\n \t    i = s->input_section.section;\n \t    if (relax)\n \t      {\n-\t\tbfd_boolean again;\n+\t\tbool again;\n \n \t\tif (!bfd_relax_section (i->owner, i, &link_info, &again))\n \t\t  einfo (_(\"%F%P: can't relax section: %E\\n\"));\n \t\tif (again)\n-\t\t  *relax = TRUE;\n+\t\t  *relax = true;\n \t      }\n \t    dot = size_input_section (prev, output_section_statement,\n \t\t\t\t      fill, &removed, dot);\n@@ -6153,7 +6152,7 @@ lang_size_sections_1\n \t\t    /* If we don't have an output section, then just adjust\n \t\t       the default memory address.  */\n \t\t    lang_memory_region_lookup (DEFAULT_MEMORY_REGION,\n-\t\t\t\t\t       FALSE)->current = newdot;\n+\t\t\t\t\t       false)->current = newdot;\n \t\t  }\n \t\telse if (newdot != dot)\n \t\t  {\n@@ -6233,13 +6232,13 @@ lang_size_sections_1\n \t\t the current one.  */\n \t      prev_s->header.next=s->header.next;\n \t      s = prev_s;\n-\t      removed_prev_s = FALSE;\n+\t      removed_prev_s = false;\n \t    }\n \t  else\n \t    {\n \t      /* Remove the first input section of the list.  */\n \t      *prev = s->header.next;\n-\t      removed_prev_s = TRUE;\n+\t      removed_prev_s = true;\n \t    }\n \n \t  /* Move to next element, unless we removed the head of the\n@@ -6250,7 +6249,7 @@ lang_size_sections_1\n       else\n \t{\n \t  prev = &s->header.next;\n-\t  removed_prev_s = FALSE;\n+\t  removed_prev_s = false;\n \t}\n     }\n   return dot;\n@@ -6261,20 +6260,20 @@ lang_size_sections_1\n    CURRENT_SECTION and PREVIOUS_SECTION ought to be placed into different\n    segments.  We are allowed an opportunity to override this decision.  */\n \n-bfd_boolean\n+bool\n ldlang_override_segment_assignment (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t\t\t    bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t    asection *current_section,\n \t\t\t\t    asection *previous_section,\n-\t\t\t\t    bfd_boolean new_segment)\n+\t\t\t\t    bool new_segment)\n {\n   lang_output_section_statement_type *cur;\n   lang_output_section_statement_type *prev;\n \n   /* The checks below are only necessary when the BFD library has decided\n      that the two sections ought to be placed into the same segment.  */\n   if (new_segment)\n-    return TRUE;\n+    return true;\n \n   /* Paranoia checks.  */\n   if (current_section == NULL || previous_section == NULL)\n@@ -6284,7 +6283,7 @@ ldlang_override_segment_assignment (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n      sections comingled in the same segment.  */\n   if (config.separate_code\n       && ((current_section->flags ^ previous_section->flags) & SEC_CODE))\n-    return TRUE;\n+    return true;\n \n   /* Find the memory regions associated with the two sections.\n      We call lang_output_section_find() here rather than scanning the list\n@@ -6305,7 +6304,7 @@ ldlang_override_segment_assignment (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n }\n \n void\n-one_lang_size_sections_pass (bfd_boolean *relax, bfd_boolean check_regions)\n+one_lang_size_sections_pass (bool *relax, bool check_regions)\n {\n   lang_statement_iteration++;\n   if (expld.phase != lang_mark_phase_enum)\n@@ -6314,7 +6313,7 @@ one_lang_size_sections_pass (bfd_boolean *relax, bfd_boolean check_regions)\n \t\t\t0, 0, relax, check_regions);\n }\n \n-static bfd_boolean\n+static bool\n lang_size_segment (seg_align_type *seg)\n {\n   /* If XXX_SEGMENT_ALIGN XXX_SEGMENT_END pair was seen, check whether\n@@ -6329,11 +6328,11 @@ lang_size_segment (seg_align_type *seg)\n       && first + last <= seg->pagesize)\n     {\n       seg->phase = exp_seg_adjust;\n-      return TRUE;\n+      return true;\n     }\n \n   seg->phase = exp_seg_done;\n-  return FALSE;\n+  return false;\n }\n \n static bfd_vma\n@@ -6377,22 +6376,22 @@ lang_size_relro_segment_1 (seg_align_type *seg)\n   return relro_end;\n }\n \n-static bfd_boolean\n-lang_size_relro_segment (bfd_boolean *relax, bfd_boolean check_regions)\n+static bool\n+lang_size_relro_segment (bool *relax, bool check_regions)\n {\n-  bfd_boolean do_reset = FALSE;\n-  bfd_boolean do_data_relro;\n+  bool do_reset = false;\n+  bool do_data_relro;\n   bfd_vma data_initial_base, data_relro_end;\n \n   if (link_info.relro && expld.dataseg.relro_end)\n     {\n-      do_data_relro = TRUE;\n+      do_data_relro = true;\n       data_initial_base = expld.dataseg.base;\n       data_relro_end = lang_size_relro_segment_1 (&expld.dataseg);\n     }\n   else\n     {\n-      do_data_relro = FALSE;\n+      do_data_relro = false;\n       data_initial_base = data_relro_end = 0;\n     }\n \n@@ -6406,18 +6405,18 @@ lang_size_relro_segment (bfd_boolean *relax, bfd_boolean check_regions)\n       if (do_data_relro && expld.dataseg.relro_end > data_relro_end)\n \t{\n \t  expld.dataseg.base = data_initial_base;;\n-\t  do_reset = TRUE;\n+\t  do_reset = true;\n \t}\n     }\n \n   if (!do_data_relro && lang_size_segment (&expld.dataseg))\n-    do_reset = TRUE;\n+    do_reset = true;\n \n   return do_reset;\n }\n \n void\n-lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)\n+lang_size_sections (bool *relax, bool check_regions)\n {\n   expld.phase = lang_allocating_phase_enum;\n   expld.dataseg.phase = exp_seg_none;\n@@ -6429,7 +6428,7 @@ lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)\n \n   if (expld.dataseg.phase == exp_seg_end_seen)\n     {\n-      bfd_boolean do_reset\n+      bool do_reset\n \t= lang_size_relro_segment (relax, check_regions);\n \n       if (do_reset)\n@@ -6448,7 +6447,7 @@ lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)\n \n static lang_output_section_statement_type *current_section;\n static lang_assignment_statement_type *current_assign;\n-static bfd_boolean prefer_next_section;\n+static bool prefer_next_section;\n \n /* Worker function for lang_do_assignments.  Recursiveness goes here.  */\n \n@@ -6457,7 +6456,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,\n \t\t       lang_output_section_statement_type *current_os,\n \t\t       fill_type *fill,\n \t\t       bfd_vma dot,\n-\t\t       bfd_boolean *found_end)\n+\t\t       bool *found_end)\n {\n   for (; s != NULL; s = s->header.next)\n     {\n@@ -6481,7 +6480,7 @@ lang_do_assignments_1 (lang_statement_union_type *s,\n \t\tif ((os->bfd_section->flags & SEC_ALLOC) != 0)\n \t\t  {\n \t\t    current_section = os;\n-\t\t    prefer_next_section = FALSE;\n+\t\t    prefer_next_section = false;\n \t\t  }\n \t\tdot = os->bfd_section->vma;\n \t      }\n@@ -6586,12 +6585,12 @@ lang_do_assignments_1 (lang_statement_union_type *s,\n \t      const char *p = current_assign->exp->assign.dst;\n \n \t      if (current_os == abs_output_section && p[0] == '.' && p[1] == 0)\n-\t\tprefer_next_section = TRUE;\n+\t\tprefer_next_section = true;\n \n \t      while (*p == '_')\n \t\t++p;\n \t      if (strcmp (p, \"end\") == 0)\n-\t\t*found_end = TRUE;\n+\t\t*found_end = true;\n \t    }\n \t  exp_fold_tree (s->assignment_statement.exp,\n \t\t\t (current_os->bfd_section != NULL\n@@ -6625,10 +6624,10 @@ lang_do_assignments_1 (lang_statement_union_type *s,\n void\n lang_do_assignments (lang_phase_type phase)\n {\n-  bfd_boolean found_end = FALSE;\n+  bool found_end = false;\n \n   current_section = NULL;\n-  prefer_next_section = FALSE;\n+  prefer_next_section = false;\n   expld.phase = phase;\n   lang_statement_iteration++;\n   lang_do_assignments_1 (statement_list.head,\n@@ -6830,7 +6829,7 @@ undef_start_stop (struct bfd_link_hash_entry *h)\n \t  unsigned int was_forced = eh->forced_local;\n \n \t  bed = get_elf_backend_data (link_info.output_bfd);\n-\t  (*bed->elf_backend_hide_symbol) (&link_info, eh, TRUE);\n+\t  (*bed->elf_backend_hide_symbol) (&link_info, eh, true);\n \t  if (!eh->ref_regular_nonweak)\n \t    h->type = bfd_link_hash_undefweak;\n \t  eh->def_regular = 0;\n@@ -6912,13 +6911,13 @@ static void\n lang_end (void)\n {\n   struct bfd_link_hash_entry *h;\n-  bfd_boolean warn;\n+  bool warn;\n \n   if ((bfd_link_relocatable (&link_info) && !link_info.gc_sections)\n       || bfd_link_dll (&link_info))\n     warn = entry_from_cmdline;\n   else\n-    warn = TRUE;\n+    warn = true;\n \n   /* Force the user to specify a root when generating a relocatable with\n      --gc-sections, unless --gc-keep-exported was also given.  */\n@@ -6931,7 +6930,7 @@ lang_end (void)\n       for (sym = link_info.gc_sym_list; sym != NULL; sym = sym->next)\n \t{\n \t  h = bfd_link_hash_lookup (link_info.hash, sym->name,\n-\t\t\t\t    FALSE, FALSE, FALSE);\n+\t\t\t\t    false, false, false);\n \t  if (h != NULL\n \t      && (h->type == bfd_link_hash_defined\n \t\t  || h->type == bfd_link_hash_defweak)\n@@ -6948,11 +6947,11 @@ lang_end (void)\n       /* No entry has been specified.  Look for the default entry, but\n \t don't warn if we don't find it.  */\n       entry_symbol.name = entry_symbol_default;\n-      warn = FALSE;\n+      warn = false;\n     }\n \n   h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,\n-\t\t\t    FALSE, FALSE, TRUE);\n+\t\t\t    false, false, true);\n   if (h != NULL\n       && (h->type == bfd_link_hash_defined\n \t  || h->type == bfd_link_hash_defweak)\n@@ -7140,25 +7139,25 @@ lang_common (void)\n \n /* Place one common symbol in the correct section.  */\n \n-static bfd_boolean\n+static bool\n lang_one_common (struct bfd_link_hash_entry *h, void *info)\n {\n   unsigned int power_of_two;\n   bfd_vma size;\n   asection *section;\n \n   if (h->type != bfd_link_hash_common)\n-    return TRUE;\n+    return true;\n \n   size = h->u.c.size;\n   power_of_two = h->u.c.p->alignment_power;\n \n   if (config.sort_common == sort_descending\n       && power_of_two < *(unsigned int *) info)\n-    return TRUE;\n+    return true;\n   else if (config.sort_common == sort_ascending\n \t   && power_of_two > *(unsigned int *) info)\n-    return TRUE;\n+    return true;\n \n   section = h->u.c.p->section;\n   if (!bfd_define_common_symbol (link_info.output_bfd, &link_info, h))\n@@ -7167,7 +7166,7 @@ lang_one_common (struct bfd_link_hash_entry *h, void *info)\n \n   if (config.map_file != NULL)\n     {\n-      static bfd_boolean header_printed;\n+      static bool header_printed;\n       int len;\n       char *name;\n       char buf[50];\n@@ -7176,7 +7175,7 @@ lang_one_common (struct bfd_link_hash_entry *h, void *info)\n \t{\n \t  minfo (_(\"\\nAllocating common symbols\\n\"));\n \t  minfo (_(\"Common symbol       size              file\\n\\n\"));\n-\t  header_printed = TRUE;\n+\t  header_printed = true;\n \t}\n \n       name = bfd_demangle (link_info.output_bfd, h->root.string,\n@@ -7221,7 +7220,7 @@ lang_one_common (struct bfd_link_hash_entry *h, void *info)\n       minfo (\"%pB\\n\", section->owner);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Handle a single orphan section S, placing the orphan into an appropriate\n@@ -7429,7 +7428,7 @@ lang_add_output (const char *name, int from_script)\n   if (!had_output_filename || !from_script)\n     {\n       output_filename = name;\n-      had_output_filename = TRUE;\n+      had_output_filename = true;\n     }\n }\n \n@@ -7503,8 +7502,8 @@ lang_reset_memory_regions (void)\n        os != NULL;\n        os = os->next)\n     {\n-      os->processed_vma = FALSE;\n-      os->processed_lma = FALSE;\n+      os->processed_vma = false;\n+      os->processed_lma = false;\n     }\n \n   for (o = link_info.output_bfd->sections; o != NULL; o = o->next)\n@@ -7604,8 +7603,8 @@ find_relro_section_callback (lang_wild_statement_type *ptr ATTRIBUTE_UNUSED,\n       && !IGNORE_SECTION (section)\n       && section->size != 0)\n     {\n-      bfd_boolean *has_relro_section = (bfd_boolean *) data;\n-      *has_relro_section = TRUE;\n+      bool *has_relro_section = (bool *) data;\n+      *has_relro_section = true;\n     }\n }\n \n@@ -7614,7 +7613,7 @@ find_relro_section_callback (lang_wild_statement_type *ptr ATTRIBUTE_UNUSED,\n static void\n lang_find_relro_sections_1 (lang_statement_union_type *s,\n \t\t\t    seg_align_type *seg,\n-\t\t\t    bfd_boolean *has_relro_section)\n+\t\t\t    bool *has_relro_section)\n {\n   if (*has_relro_section)\n     return;\n@@ -7652,21 +7651,21 @@ lang_find_relro_sections_1 (lang_statement_union_type *s,\n static void\n lang_find_relro_sections (void)\n {\n-  bfd_boolean has_relro_section = FALSE;\n+  bool has_relro_section = false;\n \n   /* Check all sections in the link script.  */\n \n   lang_find_relro_sections_1 (expld.dataseg.relro_start_stat,\n \t\t\t      &expld.dataseg, &has_relro_section);\n \n   if (!has_relro_section)\n-    link_info.relro = FALSE;\n+    link_info.relro = false;\n }\n \n /* Relax all sections until bfd_relax_section gives up.  */\n \n void\n-lang_relax_sections (bfd_boolean need_layout)\n+lang_relax_sections (bool need_layout)\n {\n   if (RELAXATION_ENABLED)\n     {\n@@ -7679,7 +7678,7 @@ lang_relax_sections (bfd_boolean need_layout)\n       while (i--)\n \t{\n \t  /* Keep relaxing until bfd_relax_section gives up.  */\n-\t  bfd_boolean relax_again;\n+\t  bool relax_again;\n \n \t  link_info.relax_trip = -1;\n \t  do\n@@ -7700,22 +7699,22 @@ lang_relax_sections (bfd_boolean need_layout)\n \n \t      /* Perform another relax pass - this time we know where the\n \t\t globals are, so can make a better guess.  */\n-\t      relax_again = FALSE;\n-\t      lang_size_sections (&relax_again, FALSE);\n+\t      relax_again = false;\n+\t      lang_size_sections (&relax_again, false);\n \t    }\n \t  while (relax_again);\n \n \t  link_info.relax_pass++;\n \t}\n-      need_layout = TRUE;\n+      need_layout = true;\n     }\n \n   if (need_layout)\n     {\n       /* Final extra sizing to report errors.  */\n       lang_do_assignments (lang_assigning_phase_enum);\n       lang_reset_memory_regions ();\n-      lang_size_sections (NULL, TRUE);\n+      lang_size_sections (NULL, true);\n     }\n }\n \n@@ -7732,7 +7731,7 @@ lang_relax_sections (bfd_boolean need_layout)\n    inserted at the head of the file_chain.  */\n \n static lang_input_statement_type *\n-find_replacements_insert_point (bfd_boolean *before)\n+find_replacements_insert_point (bool *before)\n {\n   lang_input_statement_type *claim1, *lastobject;\n   lastobject = (void *) input_file_chain.head;\n@@ -7752,7 +7751,7 @@ find_replacements_insert_point (bfd_boolean *before)\n   /* No files were claimed by the plugin.  Choose the last object\n      file found on the list (maybe the first, dummy entry) as the\n      insert point.  */\n-  *before = FALSE;\n+  *before = false;\n   return lastobject;\n }\n \n@@ -7895,7 +7894,7 @@ lang_check_relocs (void)\n \tif (!bfd_link_check_relocs (abfd, &link_info))\n \t  {\n \t    /* No object output, fail return.  */\n-\t    config.make_executable = FALSE;\n+\t    config.make_executable = false;\n \t    /* Note: we do not abort the loop, but rather\n \t       continue the scan in case there are other\n \t       bad relocations to report.  */\n@@ -7951,7 +7950,7 @@ lang_process (void)\n      means that when we call open_input_bfds PROVIDE statements will\n      trigger to provide any needed symbols.  The regions origins and\n      lengths are not assigned as a result of this call.  */\n-  lang_do_memory_regions (FALSE);\n+  lang_do_memory_regions (false);\n \n   /* Create a bfd for each input file.  */\n   current_target = default_target;\n@@ -7960,7 +7959,7 @@ lang_process (void)\n \n   /* Now that open_input_bfds has processed assignments and provide\n      statements we can give values to symbolic origin/length now.  */\n-  lang_do_memory_regions (TRUE);\n+  lang_do_memory_regions (true);\n \n #if BFD_SUPPORTS_PLUGINS\n   if (link_info.lto_plugin_active)\n@@ -7981,7 +7980,7 @@ lang_process (void)\n       if (plugin_call_all_symbols_read ())\n \teinfo (_(\"%F%P: %s: plugin reported error after all symbols read\\n\"),\n \t       plugin_error_plugin ());\n-      link_info.lto_all_symbols_read = TRUE;\n+      link_info.lto_all_symbols_read = true;\n       /* Open any newly added files, updating the file chains.  */\n       plugin_undefs = link_info.hash->undefs_tail;\n       open_input_bfds (*added.tail, OPEN_BFD_NORMAL);\n@@ -7999,7 +7998,7 @@ lang_process (void)\n \t     after the first input file that was claimed by the plugin,\n \t     unless that file was an archive in which case it is inserted\n \t     immediately before.  */\n-\t  bfd_boolean before;\n+\t  bool before;\n \t  lang_statement_union_type **prev;\n \t  plugin_insert = find_replacements_insert_point (&before);\n \t  /* If a plugin adds input files without having claimed any, we\n@@ -8249,7 +8248,7 @@ lang_process (void)\n void\n lang_add_wild (struct wildcard_spec *filespec,\n \t       struct wildcard_list *section_list,\n-\t       bfd_boolean keep_sections)\n+\t       bool keep_sections)\n {\n   struct wildcard_list *curr, *next;\n   lang_wild_statement_type *new_stmt;\n@@ -8268,12 +8267,12 @@ lang_add_wild (struct wildcard_spec *filespec,\n       if (strcmp (filespec->name, \"*\") == 0)\n \tfilespec->name = NULL;\n       else if (!wildcardp (filespec->name))\n-\tlang_has_input_file = TRUE;\n+\tlang_has_input_file = true;\n     }\n \n   new_stmt = new_stat (lang_wild_statement, stat_ptr);\n   new_stmt->filename = NULL;\n-  new_stmt->filenames_sorted = FALSE;\n+  new_stmt->filenames_sorted = false;\n   new_stmt->section_flag_list = NULL;\n   new_stmt->exclude_name_list = NULL;\n   if (filespec != NULL)\n@@ -8307,7 +8306,7 @@ lang_section_start (const char *name, etree_type *address,\n    precedence.  */\n \n void\n-lang_add_entry (const char *name, bfd_boolean cmdline)\n+lang_add_entry (const char *name, bool cmdline)\n {\n   if (entry_symbol.name == NULL\n       || cmdline\n@@ -8345,7 +8344,7 @@ lang_add_map (const char *name)\n       switch (*name)\n \t{\n \tcase 'F':\n-\t  map_option_f = TRUE;\n+\t  map_option_f = true;\n \t  break;\n \t}\n       name++;\n@@ -8423,11 +8422,11 @@ lang_startup (const char *name)\n     }\n   first_file->filename = name;\n   first_file->local_sym_name = name;\n-  first_file->flags.real = TRUE;\n+  first_file->flags.real = true;\n }\n \n void\n-lang_float (bfd_boolean maybe)\n+lang_float (bool maybe)\n {\n   lang_float_flag = maybe;\n }\n@@ -8449,10 +8448,10 @@ lang_get_regions (lang_memory_region_type **region,\n \t\t  lang_memory_region_type **lma_region,\n \t\t  const char *memspec,\n \t\t  const char *lma_memspec,\n-\t\t  bfd_boolean have_lma,\n-\t\t  bfd_boolean have_vma)\n+\t\t  bool have_lma,\n+\t\t  bool have_vma)\n {\n-  *lma_region = lang_memory_region_lookup (lma_memspec, FALSE);\n+  *lma_region = lang_memory_region_lookup (lma_memspec, false);\n \n   /* If no runtime region or VMA has been specified, but the load region\n      has been specified, then use the load region for the runtime region\n@@ -8462,7 +8461,7 @@ lang_get_regions (lang_memory_region_type **region,\n       && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)\n     *region = *lma_region;\n   else\n-    *region = lang_memory_region_lookup (memspec, FALSE);\n+    *region = lang_memory_region_lookup (memspec, false);\n \n   if (have_lma && lma_memspec != 0)\n     einfo (_(\"%X%P:%pS: section has both a load address and a load region\\n\"),\n@@ -8547,13 +8546,13 @@ lang_leave_group (void)\n void\n lang_new_phdr (const char *name,\n \t       etree_type *type,\n-\t       bfd_boolean filehdr,\n-\t       bfd_boolean phdrs,\n+\t       bool filehdr,\n+\t       bool phdrs,\n \t       etree_type *at,\n \t       etree_type *flags)\n {\n   struct lang_phdr *n, **pp;\n-  bfd_boolean hdrs;\n+  bool hdrs;\n \n   n = stat_alloc (sizeof (struct lang_phdr));\n   n->next = NULL;\n@@ -8573,7 +8572,7 @@ lang_new_phdr (const char *name,\n       {\n \teinfo (_(\"%X%P:%pS: PHDRS and FILEHDR are not supported\"\n \t\t \" when prior PT_LOAD headers lack them\\n\"), NULL);\n-\thdrs = FALSE;\n+\thdrs = false;\n       }\n \n   *pp = n;\n@@ -8664,7 +8663,7 @@ lang_record_phdrs (void)\n \t\t    }\n \t\t  secs[c] = os->bfd_section;\n \t\t  ++c;\n-\t\t  pl->used = TRUE;\n+\t\t  pl->used = true;\n \t\t}\n \t    }\n \t}\n@@ -8717,11 +8716,11 @@ lang_add_nocrossref (lang_nocrossref_type *l)\n   n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);\n   n->next = nocrossref_list;\n   n->list = l;\n-  n->onlyfirst = FALSE;\n+  n->onlyfirst = false;\n   nocrossref_list = n;\n \n   /* Set notice_all so that we get informed about all symbols.  */\n-  link_info.notice_all = TRUE;\n+  link_info.notice_all = true;\n }\n \n /* Record a section that cannot be referenced from a list of sections.  */\n@@ -8730,7 +8729,7 @@ void\n lang_add_nocrossref_to (lang_nocrossref_type *l)\n {\n   lang_add_nocrossref (l);\n-  nocrossref_list->onlyfirst = TRUE;\n+  nocrossref_list->onlyfirst = true;\n }\n \f\n /* Overlay handling.  We handle overlays with some static variables.  */\n@@ -8833,15 +8832,15 @@ lang_leave_overlay_section (fill_type *fill,\n   sprintf (buf, \"__load_start_%s\", clean);\n   lang_add_assignment (exp_provide (buf,\n \t\t\t\t    exp_nameop (LOADADDR, name),\n-\t\t\t\t    FALSE));\n+\t\t\t\t    false));\n \n   buf = (char *) xmalloc (strlen (clean) + sizeof \"__load_stop_\");\n   sprintf (buf, \"__load_stop_%s\", clean);\n   lang_add_assignment (exp_provide (buf,\n \t\t\t\t    exp_binop ('+',\n \t\t\t\t\t       exp_nameop (LOADADDR, name),\n \t\t\t\t\t       exp_nameop (SIZEOF, name)),\n-\t\t\t\t    FALSE));\n+\t\t\t\t    false));\n \n   free (clean);\n }\n@@ -8864,7 +8863,7 @@ lang_leave_overlay (etree_type *lma_expr,\n \n   lang_get_regions (&region, &lma_region,\n \t\t    memspec, lma_memspec,\n-\t\t    lma_expr != NULL, FALSE);\n+\t\t    lma_expr != NULL, false);\n \n   nocrossref = NULL;\n \n@@ -8874,7 +8873,7 @@ lang_leave_overlay (etree_type *lma_expr,\n     {\n       overlay_list->os->update_dot = 1;\n       overlay_list->os->update_dot_tree\n-\t= exp_assign (\".\", exp_binop ('+', overlay_vma, overlay_max), FALSE);\n+\t= exp_assign (\".\", exp_binop ('+', overlay_vma, overlay_max), false);\n     }\n \n   l = overlay_list;\n@@ -9054,7 +9053,7 @@ static const char *\n realsymbol (const char *pattern)\n {\n   const char *p;\n-  bfd_boolean changed = FALSE, backslash = FALSE;\n+  bool changed = false, backslash = false;\n   char *s, *symbol = (char *) xmalloc (strlen (pattern) + 1);\n \n   for (p = pattern, s = symbol; *p != '\\0'; ++p)\n@@ -9065,8 +9064,8 @@ realsymbol (const char *pattern)\n \t{\n \t  /* Remove the preceding backslash.  */\n \t  *(s - 1) = *p;\n-\t  backslash = FALSE;\n-\t  changed = TRUE;\n+\t  backslash = false;\n+\t  changed = true;\n \t}\n       else\n \t{\n@@ -9101,20 +9100,20 @@ struct bfd_elf_version_expr *\n lang_new_vers_pattern (struct bfd_elf_version_expr *orig,\n \t\t       const char *new_name,\n \t\t       const char *lang,\n-\t\t       bfd_boolean literal_p)\n+\t\t       bool literal_p)\n {\n   struct bfd_elf_version_expr *ret;\n \n   ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);\n   ret->next = orig;\n   ret->symver = 0;\n   ret->script = 0;\n-  ret->literal = TRUE;\n+  ret->literal = true;\n   ret->pattern = literal_p ? new_name : realsymbol (new_name);\n   if (ret->pattern == NULL)\n     {\n       ret->pattern = new_name;\n-      ret->literal = FALSE;\n+      ret->literal = false;\n     }\n \n   if (lang == NULL || strcasecmp (lang, \"C\") == 0)\n@@ -9405,7 +9404,7 @@ lang_do_version_exports_section (void)\n       p = contents;\n       while (p < contents + len)\n \t{\n-\t  greg = lang_new_vers_pattern (greg, p, NULL, FALSE);\n+\t  greg = lang_new_vers_pattern (greg, p, NULL, false);\n \t  p = strchr (p, '\\0') + 1;\n \t}\n \n@@ -9415,7 +9414,7 @@ lang_do_version_exports_section (void)\n       sec->flags |= SEC_EXCLUDE | SEC_KEEP;\n     }\n \n-  lreg = lang_new_vers_pattern (NULL, \"*\", NULL, FALSE);\n+  lreg = lang_new_vers_pattern (NULL, \"*\", NULL, false);\n   lang_register_vers_node (command_line.version_exports_section,\n \t\t\t   lang_new_vers_node (greg, lreg), NULL);\n }\n@@ -9429,7 +9428,7 @@ lang_do_version_exports_section (void)\n    data structures, and throw errors if missing symbols are encountered.  */\n \n static void\n-lang_do_memory_regions (bfd_boolean update_regions_p)\n+lang_do_memory_regions (bool update_regions_p)\n {\n   lang_memory_region_type *r = lang_memory_region_list;\n \n@@ -9521,7 +9520,7 @@ lang_append_dynamic_list_cpp_typeinfo (void)\n \n   for (i = 0; i < ARRAY_SIZE (symbols); i++)\n     dynamic = lang_new_vers_pattern (dynamic, symbols [i], \"C++\",\n-\t\t\t\t     FALSE);\n+\t\t\t\t     false);\n \n   lang_append_dynamic_list (&link_info.dynamic_list, dynamic);\n }\n@@ -9542,7 +9541,7 @@ lang_append_dynamic_list_cpp_new (void)\n \n   for (i = 0; i < ARRAY_SIZE (symbols); i++)\n     dynamic = lang_new_vers_pattern (dynamic, symbols [i], \"C++\",\n-\t\t\t\t     FALSE);\n+\t\t\t\t     false);\n \n   lang_append_dynamic_list (&link_info.dynamic_list, dynamic);\n }\n@@ -9568,7 +9567,7 @@ lang_ld_feature (char *str)\n       sep = *q;\n       *q = 0;\n       if (strcasecmp (p, \"SANE_EXPR\") == 0)\n-\tconfig.sane_expr = TRUE;\n+\tconfig.sane_expr = true;\n       else\n \teinfo (_(\"%X%P: unknown feature `%s'\\n\"), p);\n       *q = sep;"
    },
    {
      "sha": "6fbe16d97d9594ab2436836e8076c72ac058d107",
      "filename": "ld/ldlang.h",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldlang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldlang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -65,7 +65,7 @@ typedef struct memory_region_struct\n   union lang_statement_union *last_os;\n   flagword flags;\n   flagword not_flags;\n-  bfd_boolean had_full_message;\n+  bool had_full_message;\n } lang_memory_region_type;\n \n enum statement_enum\n@@ -131,7 +131,7 @@ typedef struct lang_output_section_phdr_list\n {\n   struct lang_output_section_phdr_list *next;\n   const char *name;\n-  bfd_boolean used;\n+  bool used;\n } lang_output_section_phdr_list;\n \n typedef struct lang_output_section_statement_struct\n@@ -343,7 +343,7 @@ typedef struct input_section_userdata_struct\n   unsigned long map_symbol_def_count;\n } input_section_userdata_type;\n \n-static inline bfd_boolean\n+static inline bool\n bfd_input_just_syms (const bfd *abfd)\n {\n   lang_input_statement_type *is = bfd_usrdata (abfd);\n@@ -360,8 +360,8 @@ typedef void (*walk_wild_section_handler_t) (lang_wild_statement_type *,\n \t\t\t\t\t     callback_t callback,\n \t\t\t\t\t     void *data);\n \n-typedef bfd_boolean (*lang_match_sec_type_func) (bfd *, const asection *,\n-\t\t\t\t\t\t bfd *, const asection *);\n+typedef bool (*lang_match_sec_type_func) (bfd *, const asection *,\n+\t\t\t\t\t  bfd *, const asection *);\n \n /* Binary search tree structure to efficiently sort sections by\n    name.  */\n@@ -377,9 +377,9 @@ struct lang_wild_statement_struct\n {\n   lang_statement_header_type header;\n   const char *filename;\n-  bfd_boolean filenames_sorted;\n+  bool filenames_sorted;\n   struct wildcard_list *section_list;\n-  bfd_boolean keep_sections;\n+  bool keep_sections;\n   lang_statement_list_type children;\n   struct name_list *exclude_name_list;\n \n@@ -421,7 +421,7 @@ typedef struct\n {\n   lang_statement_header_type header;\n   const char *where;\n-  bfd_boolean is_before;\n+  bool is_before;\n } lang_insert_statement_type;\n \n typedef union lang_statement_union\n@@ -451,8 +451,8 @@ struct lang_phdr\n   struct lang_phdr *next;\n   const char *name;\n   unsigned long type;\n-  bfd_boolean filehdr;\n-  bfd_boolean phdrs;\n+  bool filehdr;\n+  bool phdrs;\n   etree_type *at;\n   etree_type *flags;\n };\n@@ -472,7 +472,7 @@ struct lang_nocrossrefs\n {\n   struct lang_nocrossrefs *next;\n   lang_nocrossref_type *list;\n-  bfd_boolean onlyfirst;\n+  bool onlyfirst;\n };\n \n /* This structure is used to hold a list of input section names which\n@@ -510,14 +510,14 @@ extern const char *output_target;\n extern lang_output_section_statement_type *abs_output_section;\n extern lang_statement_list_type lang_os_list;\n extern struct lang_input_statement_flags input_flags;\n-extern bfd_boolean lang_has_input_file;\n+extern bool lang_has_input_file;\n extern lang_statement_list_type statement_list;\n extern lang_statement_list_type *stat_ptr;\n-extern bfd_boolean delete_output_file_on_failure;\n+extern bool delete_output_file_on_failure;\n \n extern struct bfd_sym_chain entry_symbol;\n extern const char *entry_section;\n-extern bfd_boolean entry_from_cmdline;\n+extern bool entry_from_cmdline;\n extern lang_statement_list_type file_chain;\n extern lang_statement_list_type input_file_chain;\n \n@@ -533,7 +533,7 @@ extern void lang_init\n extern void lang_finish\n   (void);\n extern lang_memory_region_type * lang_memory_region_lookup\n-  (const char * const, bfd_boolean);\n+  (const char * const, bool);\n extern void lang_memory_region_alias\n   (const char *, const char *);\n extern void lang_map\n@@ -548,19 +548,19 @@ extern lang_output_section_statement_type *lang_enter_output_section_statement\n extern void lang_final\n   (void);\n extern void lang_relax_sections\n-  (bfd_boolean);\n+  (bool);\n extern void lang_process\n   (void);\n extern void lang_section_start\n   (const char *, union etree_union *, const segment_type *);\n extern void lang_add_entry\n-  (const char *, bfd_boolean);\n+  (const char *, bool);\n extern void lang_default_entry\n   (const char *);\n extern void lang_add_target\n   (const char *);\n extern void lang_add_wild\n-  (struct wildcard_spec *, struct wildcard_list *, bfd_boolean);\n+  (struct wildcard_spec *, struct wildcard_list *, bool);\n extern void lang_add_map\n   (const char *);\n extern void lang_add_fill\n@@ -572,7 +572,7 @@ extern void lang_add_attribute\n extern void lang_startup\n   (const char *);\n extern void lang_float\n-  (bfd_boolean);\n+  (bool);\n extern void lang_leave_output_section_statement\n   (fill_type *, const char *, lang_output_section_phdr_list *,\n    const char *);\n@@ -617,7 +617,7 @@ extern lang_output_section_statement_type *lang_output_section_statement_lookup\n extern lang_output_section_statement_type *next_matching_output_section_statement\n   (lang_output_section_statement_type *, int);\n extern void ldlang_add_undef\n-  (const char *const, bfd_boolean);\n+  (const char *const, bool);\n extern void ldlang_add_require_defined\n   (const char *const);\n extern void lang_add_output_format\n@@ -646,9 +646,9 @@ extern void lang_clear_os_map\n extern void dprint_statement\n   (lang_statement_union_type *, int);\n extern void lang_size_sections\n-  (bfd_boolean *, bfd_boolean);\n+  (bool *, bool);\n extern void one_lang_size_sections_pass\n-  (bfd_boolean *, bfd_boolean);\n+  (bool *, bool);\n extern void lang_add_insert\n   (const char *, int);\n extern void lang_enter_group\n@@ -659,7 +659,7 @@ extern void lang_add_section\n   (lang_statement_list_type *, asection *, struct wildcard_list *,\n    struct flag_info *, lang_output_section_statement_type *);\n extern void lang_new_phdr\n-  (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,\n+  (const char *, etree_type *, bool, bool, etree_type *,\n    etree_type *);\n extern void lang_add_nocrossref\n   (lang_nocrossref_type *);\n@@ -676,7 +676,7 @@ extern void lang_leave_overlay\n    lang_output_section_phdr_list *, const char *);\n \n extern struct bfd_elf_version_expr *lang_new_vers_pattern\n-  (struct bfd_elf_version_expr *, const char *, const char *, bfd_boolean);\n+  (struct bfd_elf_version_expr *, const char *, const char *, bool);\n extern struct bfd_elf_version_tree *lang_new_vers_node\n   (struct bfd_elf_version_expr *, struct bfd_elf_version_expr *);\n extern struct bfd_elf_version_deps *lang_add_vers_depend\n@@ -692,7 +692,7 @@ extern void lang_add_unique\n extern const char *lang_get_output_target\n   (void);\n extern void add_excluded_libs (const char *);\n-extern bfd_boolean load_symbols\n+extern bool load_symbols\n   (lang_input_statement_type *, lang_statement_list_type *);\n \n struct elf_sym_strtab;\n@@ -703,9 +703,9 @@ extern void ldlang_ctf_new_dynsym\n   (int symidx, struct elf_internal_sym *);\n extern void ldlang_write_ctf_late\n   (void);\n-extern bfd_boolean\n+extern bool\n ldlang_override_segment_assignment\n-  (struct bfd_link_info *, bfd *, asection *, asection *, bfd_boolean);\n+  (struct bfd_link_info *, bfd *, asection *, asection *, bool);\n \n extern void\n lang_ld_feature (char *);\n@@ -716,7 +716,7 @@ lang_print_memory_usage (void);\n extern void\n lang_add_gc_name (const char *);\n \n-extern bfd_boolean\n+extern bool\n print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr);\n \n #endif"
    },
    {
      "sha": "b99d518ea311ed6992ffccac5759dafffbbebb87",
      "filename": "ld/ldmain.c",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmain.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmain.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldmain.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -60,7 +60,7 @@\n \n FILE *saved_script_handle = NULL;\n FILE *previous_script_handle = NULL;\n-bfd_boolean force_make_executable = FALSE;\n+bool force_make_executable = false;\n \n char *default_target;\n const char *output_filename = \"a.out\";\n@@ -82,14 +82,14 @@ int g_switch_value = 8;\n unsigned int trace_files;\n \n /* Nonzero means report actions taken by the linker, and describe the linker script in use.  */\n-bfd_boolean verbose;\n+bool verbose;\n \n /* Nonzero means version number was printed, so exit successfully\n    instead of complaining if no input files are given.  */\n-bfd_boolean version_printed;\n+bool version_printed;\n \n /* TRUE if we should demangle symbol names.  */\n-bfd_boolean demangling;\n+bool demangling;\n \n args_type command_line;\n \n@@ -101,7 +101,7 @@ static const char *get_sysroot\n   (int, char **);\n static char *get_emulation\n   (int, char **);\n-static bfd_boolean add_archive_element\n+static bool add_archive_element\n   (struct bfd_link_info *, bfd *, const char *, bfd **);\n static void multiple_definition\n   (struct bfd_link_info *, struct bfd_link_hash_entry *,\n@@ -113,7 +113,7 @@ static void add_to_set\n   (struct bfd_link_info *, struct bfd_link_hash_entry *,\n    bfd_reloc_code_real_type, bfd *, asection *, bfd_vma);\n static void constructor_callback\n-  (struct bfd_link_info *, bfd_boolean, const char *, bfd *,\n+  (struct bfd_link_info *, bool, const char *, bfd *,\n    asection *, bfd_vma);\n static void warning_callback\n   (struct bfd_link_info *, const char *, const char *, bfd *,\n@@ -122,15 +122,15 @@ static void warning_find_reloc\n   (bfd *, asection *, void *);\n static void undefined_symbol\n   (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma,\n-   bfd_boolean);\n+   bool);\n static void reloc_overflow\n   (struct bfd_link_info *, struct bfd_link_hash_entry *, const char *,\n    const char *, bfd_vma, bfd *, asection *, bfd_vma);\n static void reloc_dangerous\n   (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);\n static void unattached_reloc\n   (struct bfd_link_info *, const char *, bfd *, asection *, bfd_vma);\n-static bfd_boolean notice\n+static bool notice\n   (struct bfd_link_info *, struct bfd_link_hash_entry *,\n    struct bfd_link_hash_entry *, bfd *, asection *, bfd_vma, flagword);\n \n@@ -226,7 +226,7 @@ static void\n ld_bfd_assert_handler (const char *fmt, const char *bfdver,\n \t\t       const char *file, int line)\n {\n-  config.make_executable = FALSE;\n+  config.make_executable = false;\n   (*default_bfd_assert_handler) (fmt, bfdver, file, line);\n }\n \n@@ -236,7 +236,7 @@ static void\n ld_bfd_error_handler (const char *fmt, va_list ap)\n {\n   if (config.fatal_warnings)\n-    config.make_executable = FALSE;\n+    config.make_executable = false;\n   (*default_bfd_error_handler) (fmt, ap);\n }\n \n@@ -310,18 +310,18 @@ main (int argc, char **argv)\n   }\n #endif\n \n-  config.build_constructors = TRUE;\n+  config.build_constructors = true;\n   config.rpath_separator = ':';\n   config.split_by_reloc = (unsigned) -1;\n   config.split_by_file = (bfd_size_type) -1;\n-  config.make_executable = TRUE;\n-  config.magic_demand_paged = TRUE;\n-  config.text_read_only = TRUE;\n-  config.print_map_discarded = TRUE;\n+  config.make_executable = true;\n+  config.magic_demand_paged = true;\n+  config.text_read_only = true;\n+  config.print_map_discarded = true;\n   link_info.disable_target_specific_optimizations = -1;\n \n-  command_line.warn_mismatch = TRUE;\n-  command_line.warn_search_mismatch = TRUE;\n+  command_line.warn_mismatch = true;\n+  command_line.warn_search_mismatch = true;\n   command_line.check_section_addresses = -1;\n \n   /* We initialize DEMANGLING based on the environment variable\n@@ -331,11 +331,11 @@ main (int argc, char **argv)\n      interface by default.  */\n   demangling = getenv (\"COLLECT_NO_DEMANGLE\") == NULL;\n \n-  link_info.allow_undefined_version = TRUE;\n-  link_info.keep_memory = TRUE;\n-  link_info.combreloc = TRUE;\n-  link_info.strip_discarded = TRUE;\n-  link_info.prohibit_multiple_definition_absolute = FALSE;\n+  link_info.allow_undefined_version = true;\n+  link_info.keep_memory = true;\n+  link_info.combreloc = true;\n+  link_info.strip_discarded = true;\n+  link_info.prohibit_multiple_definition_absolute = false;\n   link_info.textrel_check = DEFAULT_LD_TEXTREL_CHECK;\n   link_info.emit_hash = DEFAULT_EMIT_SYSV_HASH;\n   link_info.emit_gnu_hash = DEFAULT_EMIT_GNU_HASH;\n@@ -357,7 +357,7 @@ main (int argc, char **argv)\n #ifdef DEFAULT_NEW_DTAGS\n   link_info.new_dtags = DEFAULT_NEW_DTAGS;\n #endif\n-  link_info.start_stop_gc = FALSE;\n+  link_info.start_stop_gc = false;\n   link_info.start_stop_visibility = STV_PROTECTED;\n \n   ldfile_add_arch (\"\");\n@@ -367,7 +367,7 @@ main (int argc, char **argv)\n   lang_init ();\n   ldexp_init ();\n   ldemul_before_parse ();\n-  lang_has_input_file = FALSE;\n+  lang_has_input_file = false;\n   parse_args (argc, argv);\n \n   if (config.hash_table_size != 0)\n@@ -444,9 +444,9 @@ main (int argc, char **argv)\n \n   if (command_line.force_group_allocation\n       || !bfd_link_relocatable (&link_info))\n-    link_info.resolve_section_groups = TRUE;\n+    link_info.resolve_section_groups = true;\n   else\n-    link_info.resolve_section_groups = FALSE;\n+    link_info.resolve_section_groups = false;\n \n   if (command_line.print_output_format)\n     info_msg (\"%s\\n\", lang_get_output_target ());\n@@ -491,7 +491,7 @@ main (int argc, char **argv)\n \t\t     config.map_filename);\n \t    }\n \t}\n-      link_info.has_map_file = TRUE;\n+      link_info.has_map_file = true;\n     }\n \n   lang_process ();\n@@ -749,7 +749,7 @@ add_ysym (const char *name)\n \teinfo (_(\"%F%P: bfd_hash_table_init failed: %E\\n\"));\n     }\n \n-  if (bfd_hash_lookup (link_info.notice_hash, name, TRUE, TRUE) == NULL)\n+  if (bfd_hash_lookup (link_info.notice_hash, name, true, true) == NULL)\n     einfo (_(\"%F%P: bfd_hash_lookup failed: %E\\n\"));\n }\n \n@@ -766,7 +766,7 @@ add_ignoresym (struct bfd_link_info *info, const char *name)\n \teinfo (_(\"%F%P: bfd_hash_table_init failed: %E\\n\"));\n     }\n \n-  if (bfd_hash_lookup (info->ignore_hash, name, TRUE, TRUE) == NULL)\n+  if (bfd_hash_lookup (info->ignore_hash, name, true, true) == NULL)\n     einfo (_(\"%F%P: bfd_hash_lookup failed: %E\\n\"));\n }\n \n@@ -786,7 +786,7 @@ add_wrap (const char *name)\n \teinfo (_(\"%F%P: bfd_hash_table_init failed: %E\\n\"));\n     }\n \n-  if (bfd_hash_lookup (link_info.wrap_hash, name, TRUE, TRUE) == NULL)\n+  if (bfd_hash_lookup (link_info.wrap_hash, name, true, true) == NULL)\n     einfo (_(\"%F%P: bfd_hash_lookup failed: %E\\n\"));\n }\n \n@@ -844,7 +844,7 @@ add_keepsyms_file (const char *filename)\n \n \t  buf[len] = '\\0';\n \n-\t  if (bfd_hash_lookup (link_info.keep_hash, buf, TRUE, TRUE) == NULL)\n+\t  if (bfd_hash_lookup (link_info.keep_hash, buf, true, true) == NULL)\n \t    einfo (_(\"%F%P: bfd_hash_lookup for insertion failed: %E\\n\"));\n \t}\n     }\n@@ -862,7 +862,7 @@ add_keepsyms_file (const char *filename)\n /* This is called when BFD has decided to include an archive member in\n    a link.  */\n \n-static bfd_boolean\n+static bool\n add_archive_element (struct bfd_link_info *info,\n \t\t     bfd *abfd,\n \t\t     const char *name,\n@@ -898,9 +898,9 @@ add_archive_element (struct bfd_link_info *info,\n \t\tinfo_msg (\"%pI: no new IR symbols to claim\\n\",\n \t\t\t  &orig_input);\n \t      input->flags.claimed = 0;\n-\t      return FALSE;\n+\t      return false;\n \t    }\n-\t  input->flags.claim_archive = TRUE;\n+\t  input->flags.claim_archive = true;\n \t  *subsbfd = input->the_bfd;\n \t}\n     }\n@@ -914,7 +914,7 @@ add_archive_element (struct bfd_link_info *info,\n \t match actual symbols defined by the element.  */\n       free (input);\n       bfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Set the file_chain pointer of archives to the last element loaded\n@@ -927,16 +927,16 @@ add_archive_element (struct bfd_link_info *info,\n \n   if (config.map_file != NULL)\n     {\n-      static bfd_boolean header_printed;\n+      static bool header_printed;\n       struct bfd_link_hash_entry *h;\n       bfd *from;\n       int len;\n \n-      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);\n+      h = bfd_link_hash_lookup (info->hash, name, false, false, true);\n       if (h == NULL\n \t  && info->pei386_auto_import\n \t  && startswith (name, \"__imp_\"))\n-\th = bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE, TRUE);\n+\th = bfd_link_hash_lookup (info->hash, name + 6, false, false, true);\n \n       if (h == NULL)\n \tfrom = NULL;\n@@ -967,7 +967,7 @@ add_archive_element (struct bfd_link_info *info,\n       if (!header_printed)\n \t{\n \t  minfo (_(\"Archive member included to satisfy reference by file (symbol)\\n\\n\"));\n-\t  header_printed = TRUE;\n+\t  header_printed = true;\n \t}\n \n       if (abfd->my_archive == NULL\n@@ -1008,7 +1008,7 @@ add_archive_element (struct bfd_link_info *info,\n       || trace_files > 1\n       || (trace_files && bfd_is_thin_archive (orig_input.the_bfd->my_archive)))\n     info_msg (\"%pI\\n\", &orig_input);\n-  return TRUE;\n+  return true;\n }\n \n /* This is called when BFD has discovered a symbol which is defined\n@@ -1233,7 +1233,7 @@ add_to_set (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n \n static void\n constructor_callback (struct bfd_link_info *info,\n-\t\t      bfd_boolean constructor,\n+\t\t      bool constructor,\n \t\t      const char *name,\n \t\t      bfd *abfd,\n \t\t      asection *section,\n@@ -1264,7 +1264,7 @@ constructor_callback (struct bfd_link_info *info,\n   else\n     strcpy (s, \"__DTOR_LIST__\");\n \n-  h = bfd_link_hash_lookup (info->hash, set_name, TRUE, TRUE, TRUE);\n+  h = bfd_link_hash_lookup (info->hash, set_name, true, true, true);\n   if (h == (struct bfd_link_hash_entry *) NULL)\n     einfo (_(\"%F%P: bfd_link_hash_lookup failed: %E\\n\"));\n   if (h->type == bfd_link_hash_new)\n@@ -1284,7 +1284,7 @@ constructor_callback (struct bfd_link_info *info,\n \n struct warning_callback_info\n {\n-  bfd_boolean found;\n+  bool found;\n   const char *warning;\n   const char *symbol;\n   asymbol **asymbols;\n@@ -1293,15 +1293,15 @@ struct warning_callback_info\n /* Look through the relocs to see if we can find a plausible address\n    for SYMBOL in ABFD.  Return TRUE if found.  Otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n symbol_warning (const char *warning, const char *symbol, bfd *abfd)\n {\n   struct warning_callback_info cinfo;\n \n   if (!bfd_generic_link_read_symbols (abfd))\n     einfo (_(\"%F%P: %pB: could not read symbols: %E\\n\"), abfd);\n \n-  cinfo.found = FALSE;\n+  cinfo.found = false;\n   cinfo.warning = warning;\n   cinfo.symbol = symbol;\n   cinfo.asymbols = bfd_get_outsymbols (abfd);\n@@ -1383,7 +1383,7 @@ warning_find_reloc (bfd *abfd, asection *sec, void *iarg)\n \t  /* We found a reloc for the symbol we are looking for.  */\n \t  einfo (\"%P: %C: %s%s\\n\", abfd, sec, q->address, _(\"warning: \"),\n \t\t info->warning);\n-\t  info->found = TRUE;\n+\t  info->found = true;\n \t  break;\n \t}\n     }\n@@ -1403,15 +1403,15 @@ undefined_symbol (struct bfd_link_info *info,\n \t\t  bfd *abfd,\n \t\t  asection *section,\n \t\t  bfd_vma address,\n-\t\t  bfd_boolean error)\n+\t\t  bool error)\n {\n   static char *error_name;\n   static unsigned int error_count;\n \n #define MAX_ERRORS_IN_A_ROW 5\n \n   if (info->ignore_hash != NULL\n-      && bfd_hash_lookup (info->ignore_hash, name, FALSE, FALSE) != NULL)\n+      && bfd_hash_lookup (info->ignore_hash, name, false, false) != NULL)\n     return;\n \n   if (config.warn_once)\n@@ -1616,7 +1616,7 @@ unattached_reloc (struct bfd_link_info *info ATTRIBUTE_UNUSED,\n    linker script; and if plugins are active, since they need to monitor\n    all references from non-IR files.  */\n \n-static bfd_boolean\n+static bool\n notice (struct bfd_link_info *info,\n \tstruct bfd_link_hash_entry *h,\n \tstruct bfd_link_hash_entry *inh ATTRIBUTE_UNUSED,\n@@ -1631,12 +1631,12 @@ notice (struct bfd_link_info *info,\n     {\n       if (command_line.cref || nocrossref_list != NULL)\n \treturn handle_asneeded_cref (abfd, (enum notice_asneeded_action) value);\n-      return TRUE;\n+      return true;\n     }\n \n   name = h->root.string;\n   if (info->notice_hash != NULL\n-      && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL)\n+      && bfd_hash_lookup (info->notice_hash, name, false, false) != NULL)\n     {\n       if (bfd_is_und_section (section))\n \teinfo (_(\"%P: %pB: reference to %s\\n\"), abfd, name);\n@@ -1647,5 +1647,5 @@ notice (struct bfd_link_info *info,\n   if (command_line.cref || nocrossref_list != NULL)\n     add_cref (name, abfd, section, value);\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "39d08a6c378fe7d377a4491f880fce27eb8641ac",
      "filename": "ld/ldmain.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmain.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmain.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldmain.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -27,12 +27,12 @@ extern char *ld_canon_sysroot;\n extern int ld_canon_sysroot_len;\n extern FILE *saved_script_handle;\n extern FILE *previous_script_handle;\n-extern bfd_boolean force_make_executable;\n+extern bool force_make_executable;\n extern char *default_target;\n extern unsigned int trace_files;\n-extern bfd_boolean verbose;\n-extern bfd_boolean version_printed;\n-extern bfd_boolean demangling;\n+extern bool verbose;\n+extern bool version_printed;\n+extern bool demangling;\n extern int g_switch_value;\n extern const char *output_filename;\n extern struct bfd_link_info link_info;"
    },
    {
      "sha": "28b9448d8f10df548f43fde6f15916e954e0eab7",
      "filename": "ld/ldmisc.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldmisc.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -66,9 +66,9 @@\n */\n \n void\n-vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n+vfinfo (FILE *fp, const char *fmt, va_list ap, bool is_warning)\n {\n-  bfd_boolean fatal = FALSE;\n+  bool fatal = false;\n   const char *scan;\n   int arg_type;\n   unsigned int arg_count = 0;\n@@ -235,7 +235,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \n \t    case 'X':\n \t      /* no object output, fail return */\n-\t      config.make_executable = FALSE;\n+\t      config.make_executable = false;\n \t      break;\n \n \t    case 'V':\n@@ -291,7 +291,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \n \t    case 'F':\n \t      /* Error is fatal.  */\n-\t      fatal = TRUE;\n+\t      fatal = true;\n \t      break;\n \n \t    case 'P':\n@@ -321,8 +321,8 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \t\tconst char *filename;\n \t\tconst char *functionname;\n \t\tunsigned int linenumber;\n-\t\tbfd_boolean discard_last;\n-\t\tbfd_boolean done;\n+\t\tbool discard_last;\n+\t\tbool done;\n \t\tbfd_error_type last_bfd_error = bfd_get_error ();\n \n \t\tabfd = args[arg_no].reladdr.abfd;\n@@ -346,7 +346,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \t\t   We do not always have a line number available so if\n \t\t   we cannot find them we print out the section name and\n \t\t   offset instead.  */\n-\t\tdiscard_last = TRUE;\n+\t\tdiscard_last = true;\n \t\tif (abfd != NULL\n \t\t    && bfd_find_nearest_line (abfd, section, asymbols, offset,\n \t\t\t\t\t      &filename, &functionname,\n@@ -383,7 +383,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \t\t\t    free (last_function);\n \t\t\t    last_function = xstrdup (functionname);\n \t\t\t  }\n-\t\t\tdiscard_last = FALSE;\n+\t\t\tdiscard_last = false;\n \t\t      }\n \t\t    else\n \t\t      lfinfo (fp, \"%pB:\", abfd);\n@@ -397,12 +397,12 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n \t\t    else if (filename != NULL && linenumber != 0)\n \t\t      fprintf (fp, \"%u%s\", linenumber, done ? \"\" : \":\");\n \t\t    else\n-\t\t      done = FALSE;\n+\t\t      done = false;\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    lfinfo (fp, \"%pB:\", abfd);\n-\t\t    done = FALSE;\n+\t\t    done = false;\n \t\t  }\n \t\tif (!done)\n \t\t  lfinfo (fp, \"(%pA+0x%v)\", section, offset);\n@@ -581,7 +581,7 @@ vfinfo (FILE *fp, const char *fmt, va_list ap, bfd_boolean is_warning)\n     }\n \n   if (is_warning && config.fatal_warnings)\n-    config.make_executable = FALSE;\n+    config.make_executable = false;\n \n   if (fatal)\n     xexit (1);\n@@ -598,7 +598,7 @@ info_msg (const char *fmt, ...)\n   va_list arg;\n \n   va_start (arg, fmt);\n-  vfinfo (stdout, fmt, arg, FALSE);\n+  vfinfo (stdout, fmt, arg, false);\n   va_end (arg);\n }\n \n@@ -611,7 +611,7 @@ einfo (const char *fmt, ...)\n \n   fflush (stdout);\n   va_start (arg, fmt);\n-  vfinfo (stderr, fmt, arg, TRUE);\n+  vfinfo (stderr, fmt, arg, true);\n   va_end (arg);\n   fflush (stderr);\n }\n@@ -647,7 +647,7 @@ minfo (const char *fmt, ...)\n \t  asneeded_list_tail = &m->next;\n \t}\n       else\n-\tvfinfo (config.map_file, fmt, arg, FALSE);\n+\tvfinfo (config.map_file, fmt, arg, false);\n       va_end (arg);\n     }\n }\n@@ -658,7 +658,7 @@ lfinfo (FILE *file, const char *fmt, ...)\n   va_list arg;\n \n   va_start (arg, fmt);\n-  vfinfo (file, fmt, arg, FALSE);\n+  vfinfo (file, fmt, arg, false);\n   va_end (arg);\n }\n \f"
    },
    {
      "sha": "3b8a13f0725ac176151c7ecfbadcdc482d7832ba",
      "filename": "ld/ldmisc.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmisc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldmisc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldmisc.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -21,7 +21,7 @@\n #ifndef LDMISC_H\n #define LDMISC_H\n \n-extern void vfinfo (FILE *fp, const char *fmt, va_list arg, bfd_boolean is_warning);\n+extern void vfinfo (FILE *fp, const char *fmt, va_list arg, bool is_warning);\n extern void einfo (const char *, ...);\n extern void minfo (const char *, ...);\n extern void info_msg (const char *, ...);"
    },
    {
      "sha": "73bac2e80a45f48273468ebd0c4adf21fec13b96",
      "filename": "ld/ldwrite.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldwrite.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/ldwrite.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldwrite.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -278,7 +278,7 @@ build_link_order (lang_statement_union_type *statement)\n /* Return true if NAME is the name of an unsplittable section. These\n    are the stabs strings, dwarf strings.  */\n \n-static bfd_boolean\n+static bool\n unsplittable_name (const char *name)\n {\n   if (startswith (name, \".stab\"))\n@@ -287,11 +287,11 @@ unsplittable_name (const char *name)\n \t \".stab...str\"  */\n       unsigned len = strlen (name);\n       if (strcmp (&name[len-3], \"str\") == 0)\n-\treturn TRUE;\n+\treturn true;\n     }\n   else if (strcmp (name, \"$GDB_STRINGS$\") == 0)\n-    return TRUE;\n-  return FALSE;\n+    return true;\n+  return false;\n }\n \n /* Wander around the input sections, make sure that\n@@ -339,7 +339,7 @@ clone_section (bfd *abfd, asection *s, const char *name, int *count)\n   if ((sname = bfd_get_unique_section_name (abfd, tname, count)) == NULL\n       || (n = bfd_make_section_anyway (abfd, sname)) == NULL\n       || (h = bfd_link_hash_lookup (link_info.hash,\n-\t\t\t\t    sname, TRUE, TRUE, FALSE)) == NULL)\n+\t\t\t\t    sname, true, true, false)) == NULL)\n     {\n       einfo (_(\"%F%P: clone section failed: %E\\n\"));\n       /* Silence gcc warnings.  einfo exits, so we never reach here.  */"
    },
    {
      "sha": "f6b6b2ec20274bdadd9042020cc8810544dde6c5",
      "filename": "ld/lexsup.c",
      "status": "modified",
      "additions": 102,
      "deletions": 103,
      "changes": 205,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/lexsup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/lexsup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/lexsup.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -805,10 +805,10 @@ parse_args (unsigned argc, char **argv)\n \t     ``use only shared libraries'' but, then, we don't\n \t     currently support shared libraries on HP/UX anyhow.  */\n \t  if (strcmp (optarg, \"archive\") == 0)\n-\t    input_flags.dynamic = FALSE;\n+\t    input_flags.dynamic = false;\n \t  else if (strcmp (optarg, \"shared\") == 0\n \t\t   || strcmp (optarg, \"default\") == 0)\n-\t    input_flags.dynamic = TRUE;\n+\t    input_flags.dynamic = true;\n \t  else\n \t    einfo (_(\"%F%P: unrecognized -a option `%s'\\n\"), optarg);\n \t  break;\n@@ -837,20 +837,20 @@ parse_args (unsigned argc, char **argv)\n \t  yyparse ();\n \t  break;\n \tcase OPTION_CALL_SHARED:\n-\t  input_flags.dynamic = TRUE;\n+\t  input_flags.dynamic = true;\n \t  break;\n \tcase OPTION_NON_SHARED:\n-\t  input_flags.dynamic = FALSE;\n+\t  input_flags.dynamic = false;\n \t  break;\n \tcase OPTION_CREF:\n-\t  command_line.cref = TRUE;\n-\t  link_info.notice_all = TRUE;\n+\t  command_line.cref = true;\n+\t  link_info.notice_all = true;\n \t  break;\n \tcase 'd':\n-\t  command_line.force_common_definition = TRUE;\n+\t  command_line.force_common_definition = true;\n \t  break;\n \tcase OPTION_FORCE_GROUP_ALLOCATION:\n-\t  command_line.force_group_allocation = TRUE;\n+\t  command_line.force_group_allocation = true;\n \t  break;\n \tcase OPTION_DEFSYM:\n \t  lex_string = optarg;\n@@ -860,7 +860,7 @@ parse_args (unsigned argc, char **argv)\n \t  lex_string = NULL;\n \t  break;\n \tcase OPTION_DEMANGLE:\n-\t  demangling = TRUE;\n+\t  demangling = true;\n \t  if (optarg != NULL)\n \t    {\n \t      enum demangling_styles style;\n@@ -891,23 +891,23 @@ parse_args (unsigned argc, char **argv)\n \t  command_line.endian = ENDIAN_LITTLE;\n \t  break;\n \tcase OPTION_EMBEDDED_RELOCS:\n-\t  command_line.embedded_relocs = TRUE;\n+\t  command_line.embedded_relocs = true;\n \t  break;\n \tcase OPTION_EXPORT_DYNAMIC:\n \tcase 'E': /* HP/UX compatibility.  */\n-\t  link_info.export_dynamic = TRUE;\n+\t  link_info.export_dynamic = true;\n \t  break;\n \tcase OPTION_NO_EXPORT_DYNAMIC:\n-\t  link_info.export_dynamic = FALSE;\n+\t  link_info.export_dynamic = false;\n \t  break;\n \tcase OPTION_NON_CONTIGUOUS_REGIONS:\n-\t  link_info.non_contiguous_regions = TRUE;\n+\t  link_info.non_contiguous_regions = true;\n \t  break;\n \tcase OPTION_NON_CONTIGUOUS_REGIONS_WARNINGS:\n-\t  link_info.non_contiguous_regions_warnings = TRUE;\n+\t  link_info.non_contiguous_regions_warnings = true;\n \t  break;\n \tcase 'e':\n-\t  lang_add_entry (optarg, TRUE);\n+\t  lang_add_entry (optarg, true);\n \t  break;\n \tcase 'f':\n \t  if (command_line.auxiliary_filters == NULL)\n@@ -936,7 +936,7 @@ parse_args (unsigned argc, char **argv)\n \t  command_line.filter_shlib = optarg;\n \t  break;\n \tcase OPTION_FORCE_EXE_SUFFIX:\n-\t  command_line.force_exe_suffix = TRUE;\n+\t  command_line.force_exe_suffix = true;\n \t  break;\n \tcase 'G':\n \t  {\n@@ -950,20 +950,20 @@ parse_args (unsigned argc, char **argv)\n \t  /* Ignore.  */\n \t  break;\n \tcase OPTION_GC_SECTIONS:\n-\t  link_info.gc_sections = TRUE;\n+\t  link_info.gc_sections = true;\n \t  break;\n \tcase OPTION_PRINT_GC_SECTIONS:\n-\t  link_info.print_gc_sections = TRUE;\n+\t  link_info.print_gc_sections = true;\n \t  break;\n \tcase OPTION_GC_KEEP_EXPORTED:\n-\t  link_info.gc_keep_exported = TRUE;\n+\t  link_info.gc_keep_exported = true;\n \t  break;\n \tcase OPTION_HELP:\n \t  help ();\n \t  xexit (0);\n \t  break;\n \tcase 'L':\n-\t  ldfile_add_library_path (optarg, TRUE);\n+\t  ldfile_add_library_path (optarg, true);\n \t  break;\n \tcase 'l':\n \t  lang_add_input_file (optarg, lang_input_file_is_l_enum, NULL);\n@@ -978,35 +978,35 @@ parse_args (unsigned argc, char **argv)\n \t  config.map_filename = optarg;\n \t  break;\n \tcase 'N':\n-\t  config.text_read_only = FALSE;\n-\t  config.magic_demand_paged = FALSE;\n-\t  input_flags.dynamic = FALSE;\n+\t  config.text_read_only = false;\n+\t  config.magic_demand_paged = false;\n+\t  input_flags.dynamic = false;\n \t  break;\n \tcase OPTION_NO_OMAGIC:\n-\t  config.text_read_only = TRUE;\n-\t  config.magic_demand_paged = TRUE;\n+\t  config.text_read_only = true;\n+\t  config.magic_demand_paged = true;\n \t  /* NB/ Does not set input_flags.dynamic to TRUE.\n \t     Use --call-shared or -Bdynamic for this.  */\n \t  break;\n \tcase 'n':\n-\t  config.text_read_only = TRUE;\n-\t  config.magic_demand_paged = FALSE;\n-\t  input_flags.dynamic = FALSE;\n+\t  config.text_read_only = true;\n+\t  config.magic_demand_paged = false;\n+\t  input_flags.dynamic = false;\n \t  break;\n \tcase OPTION_NO_DEFINE_COMMON:\n-\t  link_info.inhibit_common_definition = TRUE;\n+\t  link_info.inhibit_common_definition = true;\n \t  break;\n \tcase OPTION_NO_DEMANGLE:\n-\t  demangling = FALSE;\n+\t  demangling = false;\n \t  break;\n \tcase OPTION_NO_GC_SECTIONS:\n-\t  link_info.gc_sections = FALSE;\n+\t  link_info.gc_sections = false;\n \t  break;\n \tcase OPTION_NO_PRINT_GC_SECTIONS:\n-\t  link_info.print_gc_sections = FALSE;\n+\t  link_info.print_gc_sections = false;\n \t  break;\n \tcase OPTION_NO_KEEP_MEMORY:\n-\t  link_info.keep_memory = FALSE;\n+\t  link_info.keep_memory = false;\n \t  break;\n \tcase OPTION_NO_UNDEFINED:\n \t  link_info.unresolved_syms_in_objects = RM_DIAGNOSE;\n@@ -1042,13 +1042,13 @@ parse_args (unsigned argc, char **argv)\n \t    einfo (_(\"%F%P: bad --unresolved-symbols option: %s\\n\"), optarg);\n \t  break;\n \tcase OPTION_WARN_UNRESOLVED_SYMBOLS:\n-\t  link_info.warn_unresolved_syms = TRUE;\n+\t  link_info.warn_unresolved_syms = true;\n \t  break;\n \tcase OPTION_ERROR_UNRESOLVED_SYMBOLS:\n-\t  link_info.warn_unresolved_syms = FALSE;\n+\t  link_info.warn_unresolved_syms = false;\n \t  break;\n \tcase OPTION_ALLOW_MULTIPLE_DEFINITION:\n-\t  link_info.allow_multiple_definition = TRUE;\n+\t  link_info.allow_multiple_definition = true;\n \t  break;\n \n #if SUPPORT_ERROR_HANDLING_SCRIPT\n@@ -1060,28 +1060,28 @@ parse_args (unsigned argc, char **argv)\n #endif\n \n \tcase OPTION_NO_UNDEFINED_VERSION:\n-\t  link_info.allow_undefined_version = FALSE;\n+\t  link_info.allow_undefined_version = false;\n \t  break;\n \tcase OPTION_DEFAULT_SYMVER:\n-\t  link_info.create_default_symver = TRUE;\n+\t  link_info.create_default_symver = true;\n \t  break;\n \tcase OPTION_DEFAULT_IMPORTED_SYMVER:\n-\t  link_info.default_imported_symver = TRUE;\n+\t  link_info.default_imported_symver = true;\n \t  break;\n \tcase OPTION_NO_WARN_MISMATCH:\n-\t  command_line.warn_mismatch = FALSE;\n+\t  command_line.warn_mismatch = false;\n \t  break;\n \tcase OPTION_NO_WARN_SEARCH_MISMATCH:\n-\t  command_line.warn_search_mismatch = FALSE;\n+\t  command_line.warn_search_mismatch = false;\n \t  break;\n \tcase OPTION_NOINHIBIT_EXEC:\n-\t  force_make_executable = TRUE;\n+\t  force_make_executable = true;\n \t  break;\n \tcase OPTION_NOSTDLIB:\n-\t  config.only_cmd_line_lib_dirs = TRUE;\n+\t  config.only_cmd_line_lib_dirs = true;\n \t  break;\n \tcase OPTION_NO_WHOLE_ARCHIVE:\n-\t  input_flags.whole_archive = FALSE;\n+\t  input_flags.whole_archive = false;\n \t  break;\n \tcase 'O':\n \t  /* FIXME \"-O<non-digits> <value>\" used to set the address of\n@@ -1108,7 +1108,7 @@ parse_args (unsigned argc, char **argv)\n \t  xexit (0);\n \t  break;\n \tcase OPTION_PRINT_OUTPUT_FORMAT:\n-\t  command_line.print_output_format = TRUE;\n+\t  command_line.print_output_format = true;\n \t  break;\n #if BFD_SUPPORTS_PLUGINS\n \tcase OPTION_PLUGIN:\n@@ -1120,7 +1120,7 @@ parse_args (unsigned argc, char **argv)\n \t  break;\n #endif /* BFD_SUPPORTS_PLUGINS */\n \tcase 'q':\n-\t  link_info.emitrelocations = TRUE;\n+\t  link_info.emitrelocations = true;\n \t  break;\n \tcase 'i':\n \tcase 'r':\n@@ -1140,10 +1140,10 @@ parse_args (unsigned argc, char **argv)\n \t\t     bfd_link_dll (&link_info) ? \"-shared\" : \"-pie\");\n \n \t  link_info.type = type_relocatable;\n-\t  config.build_constructors = FALSE;\n-\t  config.magic_demand_paged = FALSE;\n-\t  config.text_read_only = FALSE;\n-\t  input_flags.dynamic = FALSE;\n+\t  config.build_constructors = false;\n+\t  config.magic_demand_paged = false;\n+\t  config.text_read_only = false;\n+\t  input_flags.dynamic = false;\n \t  break;\n \tcase 'R':\n \t  /* The GNU linker traditionally uses -R to mean to include\n@@ -1234,13 +1234,13 @@ parse_args (unsigned argc, char **argv)\n \t  link_info.strip = strip_all;\n \t  break;\n \tcase OPTION_STRIP_DISCARDED:\n-\t  link_info.strip_discarded = TRUE;\n+\t  link_info.strip_discarded = true;\n \t  break;\n \tcase OPTION_NO_STRIP_DISCARDED:\n-\t  link_info.strip_discarded = FALSE;\n+\t  link_info.strip_discarded = false;\n \t  break;\n \tcase OPTION_DISABLE_MULTIPLE_DEFS_ABS:\n-\t  link_info.prohibit_multiple_definition_absolute = TRUE;\n+\t  link_info.prohibit_multiple_definition_absolute = true;\n \t  break;\n \tcase OPTION_SHARED:\n \t  if (config.has_shared)\n@@ -1299,7 +1299,7 @@ parse_args (unsigned argc, char **argv)\n \t\t   optarg);\n \t  break;\n \tcase OPTION_STATS:\n-\t  config.stats = TRUE;\n+\t  config.stats = true;\n \t  break;\n \tcase OPTION_SYMBOLIC:\n \t  opt_symbolic = symbolic;\n@@ -1373,24 +1373,24 @@ parse_args (unsigned argc, char **argv)\n \t  set_segment_start (\".ldata-segment\", optarg);\n \t  break;\n \tcase OPTION_TRADITIONAL_FORMAT:\n-\t  link_info.traditional_format = TRUE;\n+\t  link_info.traditional_format = true;\n \t  break;\n \tcase OPTION_TASK_LINK:\n-\t  link_info.task_link = TRUE;\n+\t  link_info.task_link = true;\n \t  /* Fall through.  */\n \tcase OPTION_UR:\n \t  if (bfd_link_pic (&link_info))\n \t    einfo (_(\"%F%P: -r and %s may not be used together\\n\"),\n \t\t     bfd_link_dll (&link_info) ? \"-shared\" : \"-pie\");\n \n \t  link_info.type = type_relocatable;\n-\t  config.build_constructors = TRUE;\n-\t  config.magic_demand_paged = FALSE;\n-\t  config.text_read_only = FALSE;\n-\t  input_flags.dynamic = FALSE;\n+\t  config.build_constructors = true;\n+\t  config.magic_demand_paged = false;\n+\t  config.text_read_only = false;\n+\t  input_flags.dynamic = false;\n \t  break;\n \tcase 'u':\n-\t  ldlang_add_undef (optarg, TRUE);\n+\t  ldlang_add_undef (optarg, true);\n \t  break;\n \tcase OPTION_REQUIRE_DEFINED_SYMBOL:\n \t  ldlang_add_require_defined (optarg);\n@@ -1399,12 +1399,12 @@ parse_args (unsigned argc, char **argv)\n \t  if (optarg != NULL)\n \t    lang_add_unique (optarg);\n \t  else\n-\t    config.unique_orphan_sections = TRUE;\n+\t    config.unique_orphan_sections = true;\n \t  break;\n \tcase OPTION_VERBOSE:\n \t  ldversion (1);\n-\t  version_printed = TRUE;\n-\t  verbose = TRUE;\n+\t  version_printed = true;\n+\t  verbose = true;\n \t  overflow_cutoff_limit = -2;\n \t  if (optarg != NULL)\n \t    {\n@@ -1419,11 +1419,11 @@ parse_args (unsigned argc, char **argv)\n \t  break;\n \tcase 'v':\n \t  ldversion (0);\n-\t  version_printed = TRUE;\n+\t  version_printed = true;\n \t  break;\n \tcase 'V':\n \t  ldversion (1);\n-\t  version_printed = TRUE;\n+\t  version_printed = true;\n \t  break;\n \tcase OPTION_VERSION:\n \t  ldversion (2);\n@@ -1483,7 +1483,7 @@ parse_args (unsigned argc, char **argv)\n \t  {\n \t    struct bfd_elf_version_expr *expr\n \t      = lang_new_vers_pattern (NULL, xstrdup (optarg), NULL,\n-\t\t\t\t       FALSE);\n+\t\t\t\t       false);\n \t    lang_append_dynamic_list (&export_list, expr);\n \t  }\n \t  break;\n@@ -1503,46 +1503,46 @@ parse_args (unsigned argc, char **argv)\n \t  }\n \t  break;\n \tcase OPTION_WARN_COMMON:\n-\t  config.warn_common = TRUE;\n+\t  config.warn_common = true;\n \t  break;\n \tcase OPTION_WARN_CONSTRUCTORS:\n-\t  config.warn_constructors = TRUE;\n+\t  config.warn_constructors = true;\n \t  break;\n \tcase OPTION_WARN_FATAL:\n-\t  config.fatal_warnings = TRUE;\n+\t  config.fatal_warnings = true;\n \t  break;\n \tcase OPTION_NO_WARN_FATAL:\n-\t  config.fatal_warnings = FALSE;\n+\t  config.fatal_warnings = false;\n \t  break;\n \tcase OPTION_WARN_MULTIPLE_GP:\n-\t  config.warn_multiple_gp = TRUE;\n+\t  config.warn_multiple_gp = true;\n \t  break;\n \tcase OPTION_WARN_ONCE:\n-\t  config.warn_once = TRUE;\n+\t  config.warn_once = true;\n \t  break;\n \tcase OPTION_WARN_SECTION_ALIGN:\n-\t  config.warn_section_align = TRUE;\n+\t  config.warn_section_align = true;\n \t  break;\n \tcase OPTION_WARN_TEXTREL:\n \t  link_info.textrel_check = textrel_check_warning;\n \t  break;\n \tcase OPTION_WARN_ALTERNATE_EM:\n-\t  link_info.warn_alternate_em = TRUE;\n+\t  link_info.warn_alternate_em = true;\n \t  break;\n \tcase OPTION_WHOLE_ARCHIVE:\n-\t  input_flags.whole_archive = TRUE;\n+\t  input_flags.whole_archive = true;\n \t  break;\n \tcase OPTION_ADD_DT_NEEDED_FOR_DYNAMIC:\n-\t  input_flags.add_DT_NEEDED_for_dynamic = TRUE;\n+\t  input_flags.add_DT_NEEDED_for_dynamic = true;\n \t  break;\n \tcase OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC:\n-\t  input_flags.add_DT_NEEDED_for_dynamic = FALSE;\n+\t  input_flags.add_DT_NEEDED_for_dynamic = false;\n \t  break;\n \tcase OPTION_ADD_DT_NEEDED_FOR_REGULAR:\n-\t  input_flags.add_DT_NEEDED_for_regular = TRUE;\n+\t  input_flags.add_DT_NEEDED_for_regular = true;\n \t  break;\n \tcase OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR:\n-\t  input_flags.add_DT_NEEDED_for_regular = FALSE;\n+\t  input_flags.add_DT_NEEDED_for_regular = false;\n \t  break;\n \tcase OPTION_WRAP:\n \t  add_wrap (optarg);\n@@ -1590,10 +1590,10 @@ parse_args (unsigned argc, char **argv)\n \t  command_line.check_section_addresses = 0;\n \t  break;\n \tcase OPTION_ACCEPT_UNKNOWN_INPUT_ARCH:\n-\t  command_line.accept_unknown_input_arch = TRUE;\n+\t  command_line.accept_unknown_input_arch = true;\n \t  break;\n \tcase OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH:\n-\t  command_line.accept_unknown_input_arch = FALSE;\n+\t  command_line.accept_unknown_input_arch = false;\n \t  break;\n \tcase '(':\n \t  lang_enter_group ();\n@@ -1616,7 +1616,7 @@ parse_args (unsigned argc, char **argv)\n \t  break;\n \n \tcase OPTION_REDUCE_MEMORY_OVERHEADS:\n-\t  link_info.reduce_memory_overheads = TRUE;\n+\t  link_info.reduce_memory_overheads = true;\n \t  if (config.hash_table_size == 0)\n \t    config.hash_table_size = 1021;\n \t  break;\n@@ -1651,7 +1651,7 @@ parse_args (unsigned argc, char **argv)\n \t  break;\n \n \tcase OPTION_PRINT_MEMORY_USAGE:\n-\t  command_line.print_memory_usage = TRUE;\n+\t  command_line.print_memory_usage = true;\n \t  break;\n \n \tcase OPTION_ORPHAN_HANDLING:\n@@ -1669,30 +1669,30 @@ parse_args (unsigned argc, char **argv)\n \t  break;\n \n \tcase OPTION_NO_PRINT_MAP_DISCARDED:\n-\t  config.print_map_discarded = FALSE;\n+\t  config.print_map_discarded = false;\n \t  break;\n \n \tcase OPTION_PRINT_MAP_DISCARDED:\n-\t  config.print_map_discarded = TRUE;\n+\t  config.print_map_discarded = true;\n \t  break;\n \n \tcase OPTION_DEPENDENCY_FILE:\n \t  config.dependency_file = optarg;\n \t  break;\n \n \tcase OPTION_CTF_VARIABLES:\n-\t  config.ctf_variables = TRUE;\n+\t  config.ctf_variables = true;\n \t  break;\n \n \tcase OPTION_NO_CTF_VARIABLES:\n-\t  config.ctf_variables = FALSE;\n+\t  config.ctf_variables = false;\n \t  break;\n \n \tcase OPTION_CTF_SHARE_TYPES:\n \t  if (strcmp (optarg, \"share-unconflicted\") == 0)\n-\t    config.ctf_share_duplicated = FALSE;\n+\t    config.ctf_share_duplicated = false;\n \t  else if (strcmp (optarg, \"share-duplicated\") == 0)\n-\t    config.ctf_share_duplicated = TRUE;\n+\t    config.ctf_share_duplicated = true;\n \t  else\n \t    einfo (_(\"%F%P: bad --ctf-share-types option: %s\\n\"), optarg);\n \t  break;\n@@ -1851,10 +1851,10 @@ parse_args (unsigned argc, char **argv)\n     case dynamic_list_unset:\n       break;\n     case dynamic_list_data:\n-      link_info.dynamic_data = TRUE;\n+      link_info.dynamic_data = true;\n       /* Fall through.  */\n     case dynamic_list:\n-      link_info.dynamic = TRUE;\n+      link_info.dynamic = true;\n       opt_symbolic = symbolic_unset;\n       break;\n     }\n@@ -1866,7 +1866,7 @@ parse_args (unsigned argc, char **argv)\n       case symbolic_unset:\n \tbreak;\n       case symbolic:\n-\tlink_info.symbolic = TRUE;\n+\tlink_info.symbolic = true;\n \tif (link_info.dynamic_list)\n \t  {\n \t    struct bfd_elf_version_expr *ent, *next;\n@@ -1880,8 +1880,8 @@ parse_args (unsigned argc, char **argv)\n \t  }\n \tbreak;\n       case symbolic_functions:\n-\tlink_info.dynamic = TRUE;\n-\tlink_info.dynamic_data = TRUE;\n+\tlink_info.dynamic = true;\n+\tlink_info.dynamic_data = true;\n \tbreak;\n       }\n \n@@ -1918,7 +1918,7 @@ set_default_dirlist (char *dirlist_ptr)\n       if (p != NULL)\n \t*p = '\\0';\n       if (*dirlist_ptr != '\\0')\n-\tldfile_add_library_path (dirlist_ptr, TRUE);\n+\tldfile_add_library_path (dirlist_ptr, true);\n       if (p == NULL)\n \tbreak;\n       dirlist_ptr = p + 1;\n@@ -1960,7 +1960,7 @@ set_segment_start (const char *section, char *valstr)\n   seg = stat_alloc (sizeof (*seg));\n   seg->name = name;\n   seg->value = val;\n-  seg->used = FALSE;\n+  seg->used = false;\n   /* Add it to the linked list of segments.  */\n   seg->next = segments;\n   segments = seg;\n@@ -2149,8 +2149,7 @@ elf_plt_unwind_list_options (FILE *file)\n }\n \n static void\n-ld_list_options (FILE *file, bfd_boolean elf, bfd_boolean shlib,\n-\t\t bfd_boolean plt_unwind)\n+ld_list_options (FILE *file, bool elf, bool shlib, bool plt_unwind)\n {\n   if (!elf)\n     return;\n@@ -2179,12 +2178,12 @@ help (void)\n     {\n       if (ld_options[i].doc != NULL)\n \t{\n-\t  bfd_boolean comma;\n+\t  bool comma;\n \t  unsigned j;\n \n \t  printf (\"  \");\n \n-\t  comma = FALSE;\n+\t  comma = false;\n \t  len = 2;\n \n \t  j = i;\n@@ -2205,7 +2204,7 @@ help (void)\n \t\t      printf (\"%s\", _(ld_options[j].arg));\n \t\t      len += strlen (_(ld_options[j].arg));\n \t\t    }\n-\t\t  comma = TRUE;\n+\t\t  comma = true;\n \t\t}\n \t      ++j;\n \t    }\n@@ -2234,7 +2233,7 @@ help (void)\n \t\t      printf (\" %s\", _(ld_options[j].arg));\n \t\t      len += 1 + strlen (_(ld_options[j].arg));\n \t\t    }\n-\t\t  comma = TRUE;\n+\t\t  comma = true;\n \t\t}\n \t      ++j;\n \t    }"
    },
    {
      "sha": "bbaf42c6c4b6b5a5bd890dd397c11ec073a5675a",
      "filename": "ld/mri.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/mri.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/mri.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/mri.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -219,7 +219,7 @@ mri_draw_tree (void)\n \t  tmp->spec.exclude_name_list = NULL;\n \t  tmp->spec.sorted = none;\n \t  tmp->spec.section_flag_list = NULL;\n-\t  lang_add_wild (NULL, tmp, FALSE);\n+\t  lang_add_wild (NULL, tmp, false);\n \n \t  /* If there is an alias for this section, add it too.  */\n \t  for (aptr = alias; aptr; aptr = aptr->next)\n@@ -231,7 +231,7 @@ mri_draw_tree (void)\n \t\ttmp->spec.exclude_name_list = NULL;\n \t\ttmp->spec.sorted = none;\n \t\ttmp->spec.section_flag_list = NULL;\n-\t\tlang_add_wild (NULL, tmp, FALSE);\n+\t\tlang_add_wild (NULL, tmp, false);\n \t      }\n \n \t  lang_leave_output_section_statement (0, \"*default*\", NULL, NULL);\n@@ -294,7 +294,7 @@ mri_format (const char *name)\n void\n mri_public (const char *name, etree_type *exp)\n {\n-  lang_add_assignment (exp_assign (name, exp, FALSE));\n+  lang_add_assignment (exp_assign (name, exp, false));\n }\n \n void"
    },
    {
      "sha": "cdb343bb98b50cae623466e30609da6e5d25ef35",
      "filename": "ld/pe-dll.c",
      "status": "modified",
      "additions": 58,
      "deletions": 58,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pe-dll.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pe-dll.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/pe-dll.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -170,7 +170,7 @@ static struct bfd_section *edata_s, *reloc_s;\n static unsigned char *edata_d, *reloc_d;\n static size_t edata_sz, reloc_sz;\n static int runtime_pseudo_relocs_created = 0;\n-static bfd_boolean runtime_pseudp_reloc_v2_init = FALSE;\n+static bool runtime_pseudp_reloc_v2_init = false;\n \n typedef struct\n {\n@@ -186,7 +186,7 @@ typedef struct\n   unsigned int imagebase_reloc;\n   int pe_arch;\n   int bfd_arch;\n-  bfd_boolean underscored;\n+  bool underscored;\n   const autofilter_entry_type* autofilter_symbollist;\n }\n pe_details_type;\n@@ -264,9 +264,9 @@ static pe_details_type pe_detail_list[] =\n     PE_ARCH_i386,\n     bfd_arch_i386,\n #ifdef pe_use_x86_64\n-    FALSE,\n+    false,\n #else\n-    TRUE,\n+    true,\n #endif\n     autofilter_symbollist_i386\n   },\n@@ -277,7 +277,7 @@ static pe_details_type pe_detail_list[] =\n     3 /* R_IMAGEBASE */,\n     PE_ARCH_i386,\n     bfd_arch_i386,\n-    FALSE,\n+    false,\n     autofilter_symbollist_i386\n   },\n #else\n@@ -287,7 +287,7 @@ static pe_details_type pe_detail_list[] =\n     7 /* R_IMAGEBASE */,\n     PE_ARCH_i386,\n     bfd_arch_i386,\n-    TRUE,\n+    true,\n     autofilter_symbollist_i386\n   },\n #endif\n@@ -297,7 +297,7 @@ static pe_details_type pe_detail_list[] =\n     16 /* R_SH_IMAGEBASE */,\n     PE_ARCH_sh,\n     bfd_arch_sh,\n-    TRUE,\n+    true,\n     autofilter_symbollist_generic\n   },\n   {\n@@ -306,7 +306,7 @@ static pe_details_type pe_detail_list[] =\n     34 /* MIPS_R_RVA */,\n     PE_ARCH_mips,\n     bfd_arch_mips,\n-    FALSE,\n+    false,\n     autofilter_symbollist_generic\n   },\n   {\n@@ -315,7 +315,7 @@ static pe_details_type pe_detail_list[] =\n     11 /* ARM_RVA32 */,\n     PE_ARCH_arm,\n     bfd_arch_arm,\n-    TRUE,\n+    true,\n     autofilter_symbollist_generic\n   },\n   {\n@@ -324,10 +324,10 @@ static pe_details_type pe_detail_list[] =\n     2,  /* ARM_RVA32 on Windows CE, see bfd/coff-arm.c.  */\n     PE_ARCH_arm_wince,\n     bfd_arch_arm,\n-    FALSE,\n+    false,\n     autofilter_symbollist_generic\n   },\n-  { NULL, NULL, 0, 0, 0, FALSE, NULL }\n+  { NULL, NULL, 0, 0, 0, false, NULL }\n };\n \n static const pe_details_type *pe_details;\n@@ -542,7 +542,7 @@ pe_dll_add_excludes (const char *new_excludes, const exclude_type type)\n   free (local_copy);\n }\n \n-static bfd_boolean\n+static bool\n is_import (const char* n)\n {\n   return (startswith (n, \"__imp_\"));\n@@ -674,7 +674,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n   bfd *b;\n   struct bfd_section *s;\n   def_file_export *e = 0;\n-  bfd_boolean resort_needed;\n+  bool resort_needed;\n \n   if (!pe_def_file)\n     pe_def_file = def_file_empty ();\n@@ -707,7 +707,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n \t{\n \t  struct coff_link_hash_entry *sym_hash;\n \t  sym_hash = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t    ac->symbol_name, FALSE, FALSE, FALSE);\n+\t\t\t\t\t    ac->symbol_name, false, false, false);\n \t  if (sym_hash && sym_hash->root.type == bfd_link_hash_common\n \t      && sym_hash->root.u.c.p->alignment_power < (unsigned) ac->alignment)\n \t    {\n@@ -746,7 +746,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n \t      /* We should export symbols which are either global or not\n \t\t anything at all.  (.bss data is the latter)\n \t\t We should not export undefined symbols.  */\n-\t      bfd_boolean would_export\n+\t      bool would_export\n \t\t= (symbols[j]->section != bfd_und_section_ptr\n \t\t   && ((symbols[j]->flags & BSF_GLOBAL)\n \t\t       || (symbols[j]->flags == 0)));\n@@ -768,7 +768,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n \t\t    sprintf (name, \"%s%s\", \"__imp_\", sn);\n \n \t\t    blhe = bfd_link_hash_lookup (info->hash, name,\n-\t\t\t\t\t\t FALSE, FALSE, FALSE);\n+\t\t\t\t\t\t false, false, false);\n \t\t    free (name);\n \n \t\t    if (blhe && blhe->type == bfd_link_hash_defined)\n@@ -801,7 +801,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n   if (NE == 0)\n     return;\n \n-  resort_needed = FALSE;\n+  resort_needed = false;\n \n   /* Canonicalize the export list.  */\n   if (pe_dll_kill_ats)\n@@ -826,7 +826,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n \t\teinfo (_(\"%X%P: cannot export %s: invalid export name\\n\"),\n \t\t       pe_def_file->exports[i].name);\n \t      pe_def_file->exports[i].name = tmp;\n-\t      resort_needed = TRUE;\n+\t      resort_needed = true;\n \t    }\n \t}\n     }\n@@ -937,7 +937,7 @@ process_def_file_and_drectve (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *\n \n       blhe = bfd_link_hash_lookup (info->hash,\n \t\t\t\t   name,\n-\t\t\t\t   FALSE, FALSE, TRUE);\n+\t\t\t\t   false, false, true);\n \n       if (blhe\n \t  && (blhe->type == bfd_link_hash_defined\n@@ -1186,7 +1186,7 @@ fill_exported_offsets (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n \n       blhe = bfd_link_hash_lookup (info->hash,\n \t\t\t\t   name,\n-\t\t\t\t   FALSE, FALSE, TRUE);\n+\t\t\t\t   false, false, true);\n \n       if (blhe && blhe->type == bfd_link_hash_defined)\n \texported_symbol_offsets[i] = blhe->u.def.value;\n@@ -1342,7 +1342,7 @@ pe_walk_relocs (struct bfd_link_info *info,\n \t      /* Warning: the callback needs to be passed NAME directly.  */\n \t      if (import_hash)\n \t\t{\n-\t\t  if (bfd_hash_lookup (import_hash, sym->name, FALSE, FALSE))\n+\t\t  if (bfd_hash_lookup (import_hash, sym->name, false, false))\n \t\t    {\n \t\t      strcpy (name, sym->name);\n \t\t      cb (relocs[i], s, name, symname);\n@@ -1423,7 +1423,7 @@ pe_find_data_imports (const char *symhead,\n \tif (sym && sym->type == bfd_link_hash_defined)\n \t  {\n \t    if (import_hash)\n-\t      bfd_hash_lookup (import_hash, undef->root.string, TRUE, FALSE);\n+\t      bfd_hash_lookup (import_hash, undef->root.string, true, false);\n \t    else\n \t      {\n \t\tbfd *b = sym->u.def.section->owner;\n@@ -1471,7 +1471,7 @@ pe_find_data_imports (const char *symhead,\n \n \t    if (link_info.pei386_auto_import == -1)\n \t      {\n-\t\tstatic bfd_boolean warned = FALSE;\n+\t\tstatic bool warned = false;\n \n \t\tinfo_msg (_(\"Info: resolving %s by linking to %s \"\n \t\t\t    \"(auto-import)\\n\"), name, impname);\n@@ -1484,7 +1484,7 @@ pe_find_data_imports (const char *symhead,\n \t\t\t     \"command line; this should work unless it \"\n \t\t\t     \"involves constant data structures referencing \"\n \t\t\t     \"symbols from auto-imported DLLs\\n\"));\n-\t\t    warned = TRUE;\n+\t\t    warned = true;\n \t\t  }\n \t      }\n \t  }\n@@ -1581,7 +1581,7 @@ generate_reloc (bfd *abfd, struct bfd_link_info *info)\n \t\t  struct bfd_symbol *sym = *relocs[i]->sym_ptr_ptr;\n \t\t  const struct bfd_link_hash_entry *blhe\n \t\t    = bfd_wrapped_link_hash_lookup (abfd, info, sym->name,\n-\t\t\t\t\t\t    FALSE, FALSE, FALSE);\n+\t\t\t\t\t\t    false, false, false);\n \n \t\t  /* Don't create relocs for undefined weak symbols.  */\n \t\t  if (sym->flags == BSF_WEAK)\n@@ -2271,7 +2271,7 @@ static const unsigned char jmp_arm_bytes[] =\n \n \n static bfd *\n-make_one (def_file_export *exp, bfd *parent, bfd_boolean include_jmp_stub)\n+make_one (def_file_export *exp, bfd *parent, bool include_jmp_stub)\n {\n   asection *tx, *id7, *id5, *id4, *id6;\n   unsigned char *td = NULL, *d7, *d5, *d4, *d6 = NULL;\n@@ -2552,7 +2552,7 @@ make_import_fixup_mark (arelent *rel, char *name)\n   bh = NULL;\n   bfd_coff_link_add_one_symbol (&link_info, abfd, fixup_name, BSF_GLOBAL,\n \t\t\t\tcurrent_sec, /* sym->section, */\n-\t\t\t\trel->address, NULL, TRUE, FALSE, &bh);\n+\t\t\t\trel->address, NULL, true, false, &bh);\n \n   return bh->root.string;\n }\n@@ -2664,7 +2664,7 @@ make_runtime_pseudo_reloc (const char *name ATTRIBUTE_UNUSED,\n       if (!runtime_pseudp_reloc_v2_init)\n \t{\n \t  size += 12;\n-\t  runtime_pseudp_reloc_v2_init = TRUE;\n+\t  runtime_pseudp_reloc_v2_init = true;\n \t}\n \n       quick_symbol (abfd, \"__imp_\", name, \"\", UNDSEC, BSF_GLOBAL, 0);\n@@ -2774,7 +2774,7 @@ pe_create_import_fixup (arelent *rel, asection *s, bfd_vma addend, char *name,\n \t  add_bfd_to_link (b, bfd_get_filename (b), &link_info);\n \n \t  /* If we ever use autoimport, we have to cast text section writable.  */\n-\t  config.text_read_only = FALSE;\n+\t  config.text_read_only = false;\n \t  link_info.output_bfd->flags &= ~WP_TEXT;\n \t}\n \n@@ -2926,7 +2926,7 @@ pe_dll_generate_implib (def_file *def, const char *impfilename, struct bfd_link_\n \tstruct coff_link_hash_entry *h;\n \n \th = coff_link_hash_lookup (coff_hash_table (info), internal,\n-\t\t\t\t   FALSE, FALSE, FALSE);\n+\t\t\t\t   false, false, false);\n \tif (h != NULL\n \t    /* If the symbol is hidden and undefined then it\n \t       has been swept up by garbage collection.  */\n@@ -2943,7 +2943,7 @@ pe_dll_generate_implib (def_file *def, const char *impfilename, struct bfd_link_\n \t    sprintf (name, \"_%s\", internal);\n \n \t    h = coff_link_hash_lookup (coff_hash_table (info), name,\n-\t\t\t\t       FALSE, FALSE, FALSE);\n+\t\t\t\t       false, false, false);\n \t    free (name);\n \n \t    if (h != NULL\n@@ -3024,7 +3024,7 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n \n   if (kv)\n     {\n-      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);\n+      h = bfd_link_hash_lookup (linfo->hash, kv->oname, false, false, false);\n       if (h->type == bfd_link_hash_undefined)\n \tgoto return_h;\n     }\n@@ -3047,7 +3047,7 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n \t\t\tsizeof (struct key_value), undef_sort_cmp);\n \t  if (kv)\n \t    {\n-\t      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);\n+\t      h = bfd_link_hash_lookup (linfo->hash, kv->oname, false, false, false);\n \t      if (h->type == bfd_link_hash_undefined)\n \t\tgoto return_h;\n \t    }\n@@ -3059,7 +3059,7 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n \t\t    sizeof (struct key_value), undef_sort_cmp);\n       if (kv)\n \t{\n-\t  h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);\n+\t  h = bfd_link_hash_lookup (linfo->hash, kv->oname, false, false, false);\n \t  if (h->type == bfd_link_hash_undefined)\n \t    goto return_h;\n \t}\n@@ -3073,7 +3073,7 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n \n   if (kv)\n     {\n-      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);\n+      h = bfd_link_hash_lookup (linfo->hash, kv->oname, false, false, false);\n       if (h->type == bfd_link_hash_undefined)\n \tgoto return_h;\n     }\n@@ -3092,7 +3092,7 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n \n   if (kv)\n     {\n-      h = bfd_link_hash_lookup (linfo->hash, kv->oname, FALSE, FALSE, FALSE);\n+      h = bfd_link_hash_lookup (linfo->hash, kv->oname, false, false, false);\n       if (h->type == bfd_link_hash_undefined)\n \tgoto return_h;\n     }\n@@ -3104,16 +3104,16 @@ pe_find_cdecl_alias_match (struct bfd_link_info *linfo, char *name)\n   return h;\n }\n \n-static bfd_boolean\n+static bool\n pe_undef_count (struct bfd_link_hash_entry *h ATTRIBUTE_UNUSED,\n \t\tvoid *inf ATTRIBUTE_UNUSED)\n {\n   if (h->type == bfd_link_hash_undefined)\n     undef_count++;\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n pe_undef_fill (struct bfd_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n {\n   if (h->type == bfd_link_hash_undefined)\n@@ -3128,7 +3128,7 @@ pe_undef_fill (struct bfd_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)\n       udef_table[undef_count].oname = h->root.string;\n       undef_count++;\n     }\n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -3204,20 +3204,20 @@ pe_process_import_defs (bfd *output_bfd, struct bfd_link_info *linfo)\n \t  /* See if we need this import.  */\n \t  size_t len = strlen (imp[i].internal_name);\n \t  char *name = xmalloc (len + 2 + 6);\n-\t  bfd_boolean include_jmp_stub = FALSE;\n-\t  bfd_boolean is_cdecl = FALSE;\n-\t  bfd_boolean is_undef = FALSE;\n+\t  bool include_jmp_stub = false;\n+\t  bool is_cdecl = false;\n+\t  bool is_undef = false;\n \n \t  if (!lead_at && strchr (imp[i].internal_name, '@') == NULL)\n-\t      is_cdecl = TRUE;\n+\t      is_cdecl = true;\n \n \t  if (lead_at)\n \t    sprintf (name, \"%s\", imp[i].internal_name);\n \t  else\n \t    sprintf (name, \"%s%s\",U (\"\"), imp[i].internal_name);\n \n \t  blhe = bfd_link_hash_lookup (linfo->hash, name,\n-\t\t\t\t       FALSE, FALSE, FALSE);\n+\t\t\t\t       false, false, false);\n \n \t  /* Include the jump stub for <sym> only if the <sym>\n \t     is undefined.  */\n@@ -3230,21 +3230,21 @@ pe_process_import_defs (bfd *output_bfd, struct bfd_link_info *linfo)\n \t\t\t imp[i].internal_name);\n \n \t      blhe = bfd_link_hash_lookup (linfo->hash, name,\n-\t\t\t\t\t   FALSE, FALSE, FALSE);\n+\t\t\t\t\t   false, false, false);\n \t      if (blhe)\n \t\tis_undef = (blhe->type == bfd_link_hash_undefined);\n \t    }\n \t  else\n \t    {\n-\t      include_jmp_stub = TRUE;\n+\t      include_jmp_stub = true;\n \t      is_undef = (blhe->type == bfd_link_hash_undefined);\n \t    }\n \n \t  if (is_cdecl && (!blhe || (blhe && blhe->type != bfd_link_hash_undefined)))\n \t    {\n \t      sprintf (name, \"%s%s\",U (\"\"), imp[i].internal_name);\n \t      blhe = pe_find_cdecl_alias_match (linfo, name);\n-\t      include_jmp_stub = TRUE;\n+\t      include_jmp_stub = true;\n \t      if (blhe)\n \t\tis_undef = (blhe->type == bfd_link_hash_undefined);\n \t    }\n@@ -3323,7 +3323,7 @@ pe_as32 (void *ptr)\n   return b[0] + (b[1] << 8) + (b[2] << 16) + ((unsigned) b[3] << 24);\n }\n \n-bfd_boolean\n+bool\n pe_implied_import_dll (const char *filename)\n {\n   bfd *dll;\n@@ -3350,7 +3350,7 @@ pe_implied_import_dll (const char *filename)\n   if (!dll)\n     {\n       einfo (_(\"%X%P: open %s: %E\\n\"), filename);\n-      return FALSE;\n+      return false;\n     }\n \n   track_dependency_files (filename);\n@@ -3359,7 +3359,7 @@ pe_implied_import_dll (const char *filename)\n   if (!bfd_check_format (dll, bfd_object))\n     {\n       einfo (_(\"%X%P: %s: this doesn't appear to be a DLL\\n\"), filename);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Get pe_header, optional header and numbers of directory entries.  */\n@@ -3373,7 +3373,7 @@ pe_implied_import_dll (const char *filename)\n \n   /* No import or export directory entry.  */\n   if (num_entries < 1)\n-    return FALSE;\n+    return false;\n \n #ifdef pe_use_x86_64\n   export_rva  = pe_get32 (dll, opthdr_ofs + 96 + 4 * 4);\n@@ -3385,7 +3385,7 @@ pe_implied_import_dll (const char *filename)\n \n   /* No export table - nothing to export.  */\n   if (export_size == 0)\n-    return FALSE;\n+    return false;\n \n   nsections = pe_get16 (dll, pe_header_offset + 4 + 2);\n   secptr = (pe_header_offset + 4 + 20 +\n@@ -3482,7 +3482,7 @@ pe_implied_import_dll (const char *filename)\n     {\n       if (pe_dll_extra_pe_debug)\n \tprintf (\"%s is already loaded\\n\", dllname);\n-      return TRUE;\n+      return true;\n     }\n \n   /* This is an optimized version of the insertion loop, which avoids lots of\n@@ -3516,7 +3516,7 @@ pe_implied_import_dll (const char *filename)\n \t\t    (unsigned long) func_rva, is_data ? \"(data)\" : \"\");\n \t}\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Iterate through the list of symbols.  */\n@@ -3554,7 +3554,7 @@ pe_implied_import_dll (const char *filename)\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n void\n@@ -3631,7 +3631,7 @@ pe_exe_fill_sections (bfd *abfd, struct bfd_link_info *info)\n \n       /* Resize the sections.  */\n       lang_reset_memory_regions ();\n-      lang_size_sections (NULL, TRUE);\n+      lang_size_sections (NULL, true);\n \n       /* Redo special stuff.  */\n       ldemul_after_allocation ();\n@@ -3643,7 +3643,7 @@ pe_exe_fill_sections (bfd *abfd, struct bfd_link_info *info)\n     reloc_s->contents = reloc_d;\n }\n \n-bfd_boolean\n+bool\n pe_bfd_is_dll (bfd *abfd)\n {\n   return (bfd_get_format (abfd) == bfd_object"
    },
    {
      "sha": "ce5e9455949db68769aa62fbf5f250442bbaf416",
      "filename": "ld/pe-dll.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pe-dll.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pe-dll.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/pe-dll.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -52,7 +52,7 @@ extern void pe_dll_generate_implib\n   (def_file *, const char *, struct bfd_link_info *);\n extern void pe_process_import_defs\n   (bfd *, struct bfd_link_info *);\n-extern bfd_boolean pe_implied_import_dll\n+extern bool pe_implied_import_dll\n   (const char *);\n extern void pe_dll_build_sections\n   (bfd *, struct bfd_link_info *);\n@@ -66,7 +66,7 @@ extern void pe_find_data_imports\n   (const char *, void (*cb) (arelent *, asection *, char *, const char *));\n extern void pe_create_import_fixup\n   (arelent * rel, asection *, bfd_vma, char *, const char *);\n-extern bfd_boolean pe_bfd_is_dll\n+extern bool pe_bfd_is_dll\n   (bfd *);\n extern void pe_output_file_set_long_section_names\n   (bfd *);"
    },
    {
      "sha": "943637b77a581af8f82b307424ab668f3d14890f",
      "filename": "ld/pep-dll.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pep-dll.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/pep-dll.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/pep-dll.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -48,7 +48,7 @@ extern void pep_dll_add_excludes  (const char *, const exclude_type);\n extern void pep_dll_generate_def_file  (const char *);\n extern void pep_dll_generate_implib  (def_file *, const char *, struct bfd_link_info *);\n extern void pep_process_import_defs  (bfd *, struct bfd_link_info *);\n-extern bfd_boolean pep_implied_import_dll  (const char *);\n+extern bool pep_implied_import_dll  (const char *);\n extern void pep_dll_build_sections  (bfd *, struct bfd_link_info *);\n extern void pep_exe_build_sections  (bfd *, struct bfd_link_info *);\n extern void pep_dll_fill_sections  (bfd *, struct bfd_link_info *);\n@@ -58,7 +58,7 @@ extern void pep_find_data_imports  (const char *,\n \t\t\t\t\t\tconst char *));\n extern void pep_create_import_fixup  (arelent * rel, asection *, bfd_vma,\n \t\t\t\t      char *, const char *);\n-extern bfd_boolean pep_bfd_is_dll  (bfd *);\n+extern bool pep_bfd_is_dll  (bfd *);\n extern void pep_output_file_set_long_section_names (bfd *);\n \n #endif /* PEP_DLL_H */"
    },
    {
      "sha": "adaba32edaa19d4e6ec0fa73385d8348f18efcfb",
      "filename": "ld/plugin.c",
      "status": "modified",
      "additions": 41,
      "deletions": 41,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/plugin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/plugin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/plugin.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -56,7 +56,7 @@ extern int errno;\n #endif\n \n /* Report plugin symbols.  */\n-bfd_boolean report_plugin_symbols;\n+bool report_plugin_symbols;\n \n /* The suffix to append to the name of the real (claimed) object file\n    when generating a dummy BFD to hold the IR symbols sent from the\n@@ -88,7 +88,7 @@ typedef struct plugin\n   ld_plugin_all_symbols_read_handler all_symbols_read_handler;\n   ld_plugin_cleanup_handler cleanup_handler;\n   /* TRUE if the cleanup handlers have been called.  */\n-  bfd_boolean cleanup_done;\n+  bool cleanup_done;\n } plugin_t;\n \n typedef struct view_buffer\n@@ -106,7 +106,7 @@ typedef struct plugin_input_file\n   view_buffer_t view_buffer;\n   char *name;\n   int fd;\n-  bfd_boolean use_mmap;\n+  bool use_mmap;\n   off_t offset;\n   off_t filesize;\n } plugin_input_file_t;\n@@ -130,15 +130,15 @@ static plugin_t *called_plugin = NULL;\n static const char *error_plugin = NULL;\n \n /* State of linker \"notice\" interface before we poked at it.  */\n-static bfd_boolean orig_notice_all;\n+static bool orig_notice_all;\n \n /* Original linker callbacks, and the plugin version.  */\n static const struct bfd_link_callbacks *orig_callbacks;\n static struct bfd_link_callbacks plugin_callbacks;\n \n /* Set at all symbols read time, to avoid recursively offering the plugin\n    its own newly-added input files and libs to claim.  */\n-bfd_boolean no_more_claiming = FALSE;\n+bool no_more_claiming = false;\n \n #if HAVE_MMAP && HAVE_GETPAGESIZE\n /* Page size used by mmap.  */\n@@ -171,10 +171,10 @@ static const enum ld_plugin_tag tv_header_tags[] =\n static const size_t tv_header_size = ARRAY_SIZE (tv_header_tags);\n \n /* Forward references.  */\n-static bfd_boolean plugin_notice (struct bfd_link_info *,\n-\t\t\t\t  struct bfd_link_hash_entry *,\n-\t\t\t\t  struct bfd_link_hash_entry *,\n-\t\t\t\t  bfd *, asection *, bfd_vma, flagword);\n+static bool plugin_notice (struct bfd_link_info *,\n+\t\t\t   struct bfd_link_hash_entry *,\n+\t\t\t   struct bfd_link_hash_entry *,\n+\t\t\t   bfd *, asection *, bfd_vma, flagword);\n \n static bfd_cleanup plugin_object_p (bfd *);\n \n@@ -220,7 +220,7 @@ set_plugin_error (const char *plugin)\n }\n \n /* Test if an error occurred.  */\n-static bfd_boolean\n+static bool\n plugin_error_p (void)\n {\n   return error_plugin != NULL;\n@@ -309,7 +309,7 @@ static bfd *\n plugin_get_ir_dummy_bfd (const char *name, bfd *srctemplate)\n {\n   bfd *abfd;\n-  bfd_boolean bfd_plugin_target;\n+  bool bfd_plugin_target;\n \n   bfd_use_reserved_id = 1;\n   bfd_plugin_target = bfd_plugin_target_p (srctemplate->xvec);\n@@ -343,7 +343,7 @@ plugin_get_ir_dummy_bfd (const char *name, bfd *srctemplate)\n }\n \n /* Check if the BFD passed in is an IR dummy object file.  */\n-static inline bfd_boolean\n+static inline bool\n is_ir_dummy_bfd (const bfd *abfd)\n {\n   /* ABFD can sometimes legitimately be NULL, e.g. when called from one\n@@ -563,7 +563,7 @@ get_view (const void *handle, const void **viewp)\n   buffer = mmap (NULL, size, PROT_READ, MAP_PRIVATE, input->fd, offset);\n   if (buffer != MAP_FAILED)\n     {\n-      input->use_mmap = TRUE;\n+      input->use_mmap = true;\n # if HAVE_GETPAGESIZE\n       buffer += bias;\n # endif\n@@ -573,7 +573,7 @@ get_view (const void *handle, const void **viewp)\n     {\n       char *p;\n \n-      input->use_mmap = FALSE;\n+      input->use_mmap = false;\n \n       if (lseek (input->fd, offset, SEEK_SET) < 0)\n \treturn LDPS_ERR;\n@@ -621,20 +621,20 @@ release_input_file (const void *handle)\n \n /* Return TRUE if a defined symbol might be reachable from outside the\n    universe of claimed objects.  */\n-static inline bfd_boolean\n+static inline bool\n is_visible_from_outside (struct ld_plugin_symbol *lsym,\n \t\t\t struct bfd_link_hash_entry *blhe)\n {\n   if (bfd_link_relocatable (&link_info))\n-    return TRUE;\n+    return true;\n   if (blhe->non_ir_ref_dynamic\n       || link_info.export_dynamic\n       || bfd_link_dll (&link_info))\n     {\n       /* Check if symbol is hidden by version script.  */\n       if (bfd_hide_sym_by_version (link_info.version_info,\n \t\t\t\t   blhe->root.string))\n-\treturn FALSE;\n+\treturn false;\n       /* Only ELF symbols really have visibility.  */\n       if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour)\n \t{\n@@ -656,7 +656,7 @@ is_visible_from_outside (struct ld_plugin_symbol *lsym,\n \t      || lsym->visibility == LDPV_PROTECTED);\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return LTO kind string name that corresponds to IDX enum value.  */\n@@ -743,7 +743,7 @@ get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,\n       int res;\n       struct bfd_link_hash_entry *h\n \t= bfd_link_hash_lookup (link_info.hash, syms[n].name,\n-\t\t\t\tFALSE, FALSE, TRUE);\n+\t\t\t\tfalse, false, true);\n       enum { wrap_none, wrapper, wrapped } wrap_status = wrap_none;\n \n       if (syms[n].def != LDPK_UNDEF && syms[n].def != LDPK_WEAKUNDEF)\n@@ -762,7 +762,7 @@ get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,\n \t{\n \t  blhe = bfd_wrapped_link_hash_lookup (link_info.output_bfd,\n \t\t\t\t\t       &link_info, syms[n].name,\n-\t\t\t\t\t       FALSE, FALSE, TRUE);\n+\t\t\t\t\t       false, false, true);\n \t  /* Check if a symbol is a wrapped symbol.  */\n \t  if (blhe && blhe != h)\n \t    wrap_status = wrapped;\n@@ -922,7 +922,7 @@ static enum ld_plugin_status\n set_extra_library_path (const char *path)\n {\n   ASSERT (called_plugin);\n-  ldfile_add_library_path (xstrdup (path), FALSE);\n+  ldfile_add_library_path (xstrdup (path), false);\n   return LDPS_OK;\n }\n \n@@ -936,14 +936,14 @@ message (int level, const char *format, ...)\n   switch (level)\n     {\n     case LDPL_INFO:\n-      vfinfo (stdout, format, args, FALSE);\n+      vfinfo (stdout, format, args, false);\n       putchar ('\\n');\n       break;\n     case LDPL_WARNING:\n       {\n \tchar *newfmt = concat (_(\"%P: warning: \"), format, \"\\n\",\n \t\t\t       (const char *) NULL);\n-\tvfinfo (stdout, newfmt, args, TRUE);\n+\tvfinfo (stdout, newfmt, args, true);\n \tfree (newfmt);\n       }\n       break;\n@@ -955,7 +955,7 @@ message (int level, const char *format, ...)\n \t\t\t       _(\"%P: error: \"), format, \"\\n\",\n \t\t\t       (const char *) NULL);\n \tfflush (stdout);\n-\tvfinfo (stderr, newfmt, args, TRUE);\n+\tvfinfo (stderr, newfmt, args, true);\n \tfflush (stderr);\n \tfree (newfmt);\n       }\n@@ -1115,8 +1115,8 @@ plugin_load_plugins (void)\n   orig_callbacks = link_info.callbacks;\n   plugin_callbacks = *orig_callbacks;\n   plugin_callbacks.notice = &plugin_notice;\n-  link_info.notice_all = TRUE;\n-  link_info.lto_plugin_active = TRUE;\n+  link_info.notice_all = true;\n+  link_info.lto_plugin_active = true;\n   link_info.callbacks = &plugin_callbacks;\n \n   register_ld_plugin_object_p (plugin_object_p);\n@@ -1131,7 +1131,7 @@ static int\n plugin_call_claim_file (const struct ld_plugin_input_file *file, int *claimed)\n {\n   plugin_t *curplug = plugins_list;\n-  *claimed = FALSE;\n+  *claimed = false;\n   while (curplug && !*claimed)\n     {\n       if (curplug->claim_file_handler)\n@@ -1215,7 +1215,7 @@ plugin_object_p (bfd *ibfd)\n   input->view_buffer.filesize = 0;\n   input->view_buffer.offset = 0;\n   input->fd = file.fd;\n-  input->use_mmap = FALSE;\n+  input->use_mmap = false;\n   input->offset = file.offset;\n   input->filesize = file.filesize;\n   input->name = plugin_strdup (abfd, bfd_get_filename (ibfd));\n@@ -1301,7 +1301,7 @@ plugin_call_all_symbols_read (void)\n   plugin_t *curplug = plugins_list;\n \n   /* Disable any further file-claiming.  */\n-  no_more_claiming = TRUE;\n+  no_more_claiming = true;\n \n   while (curplug)\n     {\n@@ -1329,7 +1329,7 @@ plugin_call_cleanup (void)\n       if (curplug->cleanup_handler && !curplug->cleanup_done)\n \t{\n \t  enum ld_plugin_status rv;\n-\t  curplug->cleanup_done = TRUE;\n+\t  curplug->cleanup_done = true;\n \t  called_plugin = curplug;\n \t  rv = (*curplug->cleanup_handler) ();\n \t  called_plugin = NULL;\n@@ -1349,7 +1349,7 @@ plugin_call_cleanup (void)\n    non_ir_ref_dynamic as appropriate.  We have to notice_all symbols,\n    because we won't necessarily know until later which ones will be\n    contributed by IR files.  */\n-static bfd_boolean\n+static bool\n plugin_notice (struct bfd_link_info *info,\n \t       struct bfd_link_hash_entry *h,\n \t       struct bfd_link_hash_entry *inh,\n@@ -1363,7 +1363,7 @@ plugin_notice (struct bfd_link_info *info,\n   if (h != NULL)\n     {\n       bfd *sym_bfd;\n-      bfd_boolean ref = FALSE;\n+      bool ref = false;\n \n       if (h->type == bfd_link_hash_warning)\n \th = h->u.i.link;\n@@ -1383,13 +1383,13 @@ plugin_notice (struct bfd_link_info *info,\n \t      || inh->type == bfd_link_hash_new)\n \t    {\n \t      if ((abfd->flags & DYNAMIC) == 0)\n-\t\tinh->non_ir_ref_regular = TRUE;\n+\t\tinh->non_ir_ref_regular = true;\n \t      else\n-\t\tinh->non_ir_ref_dynamic = TRUE;\n+\t\tinh->non_ir_ref_dynamic = true;\n \t    }\n \n \t  if (h->type != bfd_link_hash_new)\n-\t    ref = TRUE;\n+\t    ref = true;\n \t}\n \n       /* Nothing to do here for warning symbols.  */\n@@ -1409,7 +1409,7 @@ plugin_notice (struct bfd_link_info *info,\n \t       && (h->u.undef.abfd == NULL\n \t\t   || (h->u.undef.abfd->flags & BFD_PLUGIN) != 0))\n \t     h->u.undef.abfd = abfd;\n-\t  ref = TRUE;\n+\t  ref = true;\n \t}\n \n \n@@ -1425,7 +1425,7 @@ plugin_notice (struct bfd_link_info *info,\n \t      h->type = bfd_link_hash_undefweak;\n \t      h->u.undef.abfd = sym_bfd;\n \t    }\n-\t  ref = TRUE;\n+\t  ref = true;\n \t}\n \n       /* Otherwise, it must be a new def.\n@@ -1453,9 +1453,9 @@ plugin_notice (struct bfd_link_info *info,\n       if (ref)\n \t{\n \t  if ((abfd->flags & DYNAMIC) == 0)\n-\t    h->non_ir_ref_regular = TRUE;\n+\t    h->non_ir_ref_regular = true;\n \t  else\n-\t    h->non_ir_ref_dynamic = TRUE;\n+\t    h->non_ir_ref_dynamic = true;\n \t}\n     }\n \n@@ -1464,9 +1464,9 @@ plugin_notice (struct bfd_link_info *info,\n       || orig_notice_all\n       || (info->notice_hash != NULL\n \t  && bfd_hash_lookup (info->notice_hash, orig_h->root.string,\n-\t\t\t      FALSE, FALSE) != NULL))\n+\t\t\t      false, false) != NULL))\n     return (*orig_callbacks->notice) (info, orig_h, inh,\n \t\t\t\t      abfd, section, value, flags);\n-  return TRUE;\n+  return true;\n }\n #endif /* BFD_SUPPORTS_PLUGINS */"
    },
    {
      "sha": "775dbb4e90269fec19e89c740e11ffebbd787846",
      "filename": "ld/plugin.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/plugin.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/plugin.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/plugin.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -22,11 +22,11 @@\n #define GLD_PLUGIN_H\n \n /* Report plugin symbols.  */\n-extern bfd_boolean report_plugin_symbols;\n+extern bool report_plugin_symbols;\n \n /* Set at all symbols read time, to avoid recursively offering the plugin\n    its own newly-added input files and libs to claim.  */\n-extern bfd_boolean no_more_claiming;\n+extern bool no_more_claiming;\n \n /* This is the only forward declaration we need to avoid having\n    to include the plugin-api.h header in order to use this file.  */"
    },
    {
      "sha": "27bce0adf38a137adb2077c82f197e8f55dcc450",
      "filename": "ld/sysdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/sysdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/sysdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/sysdep.h?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -123,4 +123,6 @@ extern char *getenv ();\n extern char **environ;\n #endif\n \n+#define POISON_BFD_BOOLEAN 1\n+\n #endif /* ! defined (LD_SYSDEP_H) */"
    },
    {
      "sha": "c1d7c22e6b4dd094f4b337d4bf9bdef0d66c0e0b",
      "filename": "ld/testplug.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testplug.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -41,7 +41,7 @@ typedef struct claim_file\n {\n   struct claim_file *next;\n   struct ld_plugin_input_file file;\n-  bfd_boolean claimed;\n+  bool claimed;\n   struct ld_plugin_symbol *symbols;\n   int n_syms_allocated;\n   int n_syms_used;\n@@ -122,10 +122,10 @@ static enum ld_plugin_status onload_ret = LDPS_OK;\n static enum ld_plugin_status claim_file_ret = LDPS_OK;\n static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;\n static enum ld_plugin_status cleanup_ret = LDPS_OK;\n-static bfd_boolean register_claimfile_hook = FALSE;\n-static bfd_boolean register_allsymbolsread_hook = FALSE;\n-static bfd_boolean register_cleanup_hook = FALSE;\n-static bfd_boolean dumpresolutions = FALSE;\n+static bool register_claimfile_hook = false;\n+static bool register_allsymbolsread_hook = false;\n+static bool register_cleanup_hook = false;\n+static bool dumpresolutions = false;\n \n /* The master list of all claimable/claimed files.  */\n static claim_file_t *claimfiles_list = NULL;\n@@ -324,7 +324,7 @@ set_ret_val (const char *whichval, enum ld_plugin_status retval)\n \n /* Records hooks which should be registered.  */\n static enum ld_plugin_status\n-set_register_hook (const char *whichhook, bfd_boolean yesno)\n+set_register_hook (const char *whichhook, bool yesno)\n {\n   if (!strcmp (\"claimfile\", whichhook))\n     register_claimfile_hook = yesno;\n@@ -346,9 +346,9 @@ parse_option (const char *opt)\n   else if (!strncmp (\"pass\", opt, 4))\n     return set_ret_val (opt + 4, LDPS_OK);\n   else if (!strncmp (\"register\", opt, 8))\n-    return set_register_hook (opt + 8, TRUE);\n+    return set_register_hook (opt + 8, true);\n   else if (!strncmp (\"noregister\", opt, 10))\n-    return set_register_hook (opt + 10, FALSE);\n+    return set_register_hook (opt + 10, false);\n   else if (!strncmp (\"claim:\", opt, 6))\n     return record_claim_file (opt + 6);\n   else if (!strncmp (\"read:\", opt, 5))\n@@ -362,7 +362,7 @@ parse_option (const char *opt)\n   else if (!strncmp (\"dir:\", opt, 4))\n     return record_add_file (opt + 4, ADD_DIR);\n   else if (!strcmp (\"dumpresolutions\", opt))\n-    dumpresolutions = TRUE;\n+    dumpresolutions = true;\n   else\n     return LDPS_ERR;\n   return LDPS_OK;\n@@ -589,7 +589,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   *claimed = (claimfile != 0);\n   if (claimfile)\n     {\n-      claimfile->claimed = TRUE;\n+      claimfile->claimed = true;\n       claimfile->file = *file;\n       if (claimfile->n_syms_used && !tv_add_symbols)\n \treturn LDPS_ERR;"
    },
    {
      "sha": "ddf2ea3d92e8a666e1f3e68b0610a53c08a3a391",
      "filename": "ld/testplug2.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testplug2.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -41,7 +41,7 @@ typedef struct claim_file\n {\n   struct claim_file *next;\n   struct ld_plugin_input_file file;\n-  bfd_boolean claimed;\n+  bool claimed;\n   struct ld_plugin_symbol *symbols;\n   int n_syms_allocated;\n   int n_syms_used;\n@@ -122,11 +122,11 @@ static enum ld_plugin_status onload_ret = LDPS_OK;\n static enum ld_plugin_status claim_file_ret = LDPS_OK;\n static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;\n static enum ld_plugin_status cleanup_ret = LDPS_OK;\n-static bfd_boolean register_claimfile_hook = TRUE;\n-static bfd_boolean register_allsymbolsread_hook = FALSE;\n-static bfd_boolean register_cleanup_hook = FALSE;\n-static bfd_boolean dumpresolutions = FALSE;\n-static bfd_boolean allsymbolsread_silent = FALSE;\n+static bool register_claimfile_hook = true;\n+static bool register_allsymbolsread_hook = false;\n+static bool register_cleanup_hook = false;\n+static bool dumpresolutions = false;\n+static bool allsymbolsread_silent = false;\n \n /* The master list of all claimable/claimed files.  */\n static claim_file_t *claimfiles_list = NULL;\n@@ -306,7 +306,7 @@ set_ret_val (const char *whichval, enum ld_plugin_status retval)\n \n /* Records hooks which should be registered.  */\n static enum ld_plugin_status\n-set_register_hook (const char *whichhook, bfd_boolean yesno)\n+set_register_hook (const char *whichhook, bool yesno)\n {\n   if (!strcmp (\"claimfile\", whichhook))\n     register_claimfile_hook = yesno;\n@@ -315,7 +315,7 @@ set_register_hook (const char *whichhook, bfd_boolean yesno)\n   else if (!strcmp (\"allsymbolsreadsilent\", whichhook))\n     {\n       register_allsymbolsread_hook = yesno;\n-      allsymbolsread_silent = TRUE;\n+      allsymbolsread_silent = true;\n     }\n   else if (!strcmp (\"cleanup\", whichhook))\n     register_cleanup_hook = yesno;\n@@ -348,9 +348,9 @@ parse_option (const char *opt)\n   else if (!strncmp (\"pass\", opt, 4))\n     return set_ret_val (opt + 4, LDPS_OK);\n   else if (!strncmp (\"register\", opt, 8))\n-    return set_register_hook (opt + 8, TRUE);\n+    return set_register_hook (opt + 8, true);\n   else if (!strncmp (\"noregister\", opt, 10))\n-    return set_register_hook (opt + 10, FALSE);\n+    return set_register_hook (opt + 10, false);\n   else if (!strncmp (\"claim:\", opt, 6))\n     return record_claim_file (opt + 6, 0);\n   else if (!strncmp (\"sym:\", opt, 4))\n@@ -362,7 +362,7 @@ parse_option (const char *opt)\n   else if (!strncmp (\"dir:\", opt, 4))\n     return record_add_file (opt + 4, ADD_DIR);\n   else if (!strcmp (\"dumpresolutions\", opt))\n-    dumpresolutions = TRUE;\n+    dumpresolutions = true;\n   else\n     return LDPS_ERR;\n   return LDPS_OK;\n@@ -518,7 +518,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   size_t len = strlen (file->name);\n   char *name = xstrdup (file->name);\n   char *p = name + len;\n-  bfd_boolean islib;\n+  bool islib;\n \n   /* Only match the file name without the directory part.  */\n   islib = *p == 'a' && *(p - 1) == '.';\n@@ -547,7 +547,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   *claimed = (claimfile != 0);\n   if (claimfile)\n     {\n-      claimfile->claimed = TRUE;\n+      claimfile->claimed = true;\n       claimfile->file = *file;\n       if (claimfile->n_syms_used && !tv_add_symbols)\n \treturn LDPS_ERR;"
    },
    {
      "sha": "155b5df523a7fee3e3d769b3ff5b38b983297e08",
      "filename": "ld/testplug3.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug3.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug3.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testplug3.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -41,7 +41,7 @@ typedef struct claim_file\n {\n   struct claim_file *next;\n   struct ld_plugin_input_file file;\n-  bfd_boolean claimed;\n+  bool claimed;\n   struct ld_plugin_symbol *symbols;\n   int n_syms_allocated;\n   int n_syms_used;\n@@ -122,10 +122,10 @@ static enum ld_plugin_status onload_ret = LDPS_OK;\n static enum ld_plugin_status claim_file_ret = LDPS_OK;\n static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;\n static enum ld_plugin_status cleanup_ret = LDPS_OK;\n-static bfd_boolean register_claimfile_hook = TRUE;\n-static bfd_boolean register_allsymbolsread_hook = FALSE;\n-static bfd_boolean register_cleanup_hook = FALSE;\n-static bfd_boolean dumpresolutions = FALSE;\n+static bool register_claimfile_hook = true;\n+static bool register_allsymbolsread_hook = false;\n+static bool register_cleanup_hook = false;\n+static bool dumpresolutions = false;\n \n /* The master list of all claimable/claimed files.  */\n static claim_file_t *claimfiles_list = NULL;\n@@ -305,7 +305,7 @@ set_ret_val (const char *whichval, enum ld_plugin_status retval)\n \n /* Records hooks which should be registered.  */\n static enum ld_plugin_status\n-set_register_hook (const char *whichhook, bfd_boolean yesno)\n+set_register_hook (const char *whichhook, bool yesno)\n {\n   if (!strcmp (\"claimfile\", whichhook))\n     register_claimfile_hook = yesno;\n@@ -327,9 +327,9 @@ parse_option (const char *opt)\n   else if (!strncmp (\"pass\", opt, 4))\n     return set_ret_val (opt + 4, LDPS_OK);\n   else if (!strncmp (\"register\", opt, 8))\n-    return set_register_hook (opt + 8, TRUE);\n+    return set_register_hook (opt + 8, true);\n   else if (!strncmp (\"noregister\", opt, 10))\n-    return set_register_hook (opt + 10, FALSE);\n+    return set_register_hook (opt + 10, false);\n   else if (!strncmp (\"claim:\", opt, 6))\n     return record_claim_file (opt + 6, 0);\n   else if (!strncmp (\"sym:\", opt, 4))\n@@ -341,7 +341,7 @@ parse_option (const char *opt)\n   else if (!strncmp (\"dir:\", opt, 4))\n     return record_add_file (opt + 4, ADD_DIR);\n   else if (!strcmp (\"dumpresolutions\", opt))\n-    dumpresolutions = TRUE;\n+    dumpresolutions = true;\n   else\n     return LDPS_ERR;\n   return LDPS_OK;\n@@ -497,7 +497,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   size_t len = strlen (file->name);\n   char *name = xstrdup (file->name);\n   char *p = name + len;\n-  bfd_boolean islib;\n+  bool islib;\n \n   /* Only match the file name without the directory part.  */\n   islib = *p == 'a' && *(p - 1) == '.';\n@@ -532,7 +532,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n       TV_MESSAGE (LDPL_INFO, \"Claimed: %s [@%ld/%ld]\", file->name,\n \t\t  (long)file->offset, (long)file->filesize);\n \n-      claimfile->claimed = TRUE;\n+      claimfile->claimed = true;\n       claimfile->file = *file;\n       if (claimfile->n_syms_used && !tv_add_symbols)\n \tclaim_file_ret = LDPS_ERR;"
    },
    {
      "sha": "9cbb9276c8f81be8dfba9ebb5f754a0191b14876",
      "filename": "ld/testplug4.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc/ld/testplug4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testplug4.c?ref=f38a2680c2f04db6eac4fd87380cd3cf7bcb3bcc",
      "patch": "@@ -41,7 +41,7 @@ typedef struct claim_file\n {\n   struct claim_file *next;\n   struct ld_plugin_input_file file;\n-  bfd_boolean claimed;\n+  bool claimed;\n   struct ld_plugin_symbol *symbols;\n   int n_syms_allocated;\n   int n_syms_used;\n@@ -122,11 +122,11 @@ static enum ld_plugin_status onload_ret = LDPS_OK;\n static enum ld_plugin_status claim_file_ret = LDPS_OK;\n static enum ld_plugin_status all_symbols_read_ret = LDPS_OK;\n static enum ld_plugin_status cleanup_ret = LDPS_OK;\n-static bfd_boolean register_claimfile_hook = TRUE;\n-static bfd_boolean register_allsymbolsread_hook = FALSE;\n-static bfd_boolean register_cleanup_hook = FALSE;\n-static bfd_boolean dumpresolutions = FALSE;\n-static bfd_boolean allsymbolsread_silent = FALSE;\n+static bool register_claimfile_hook = true;\n+static bool register_allsymbolsread_hook = false;\n+static bool register_cleanup_hook = false;\n+static bool dumpresolutions = false;\n+static bool allsymbolsread_silent = false;\n \n /* The master list of all claimable/claimed files.  */\n static claim_file_t *claimfiles_list = NULL;\n@@ -306,7 +306,7 @@ set_ret_val (const char *whichval, enum ld_plugin_status retval)\n \n /* Records hooks which should be registered.  */\n static enum ld_plugin_status\n-set_register_hook (const char *whichhook, bfd_boolean yesno)\n+set_register_hook (const char *whichhook, bool yesno)\n {\n   if (!strcmp (\"claimfile\", whichhook))\n     register_claimfile_hook = yesno;\n@@ -315,7 +315,7 @@ set_register_hook (const char *whichhook, bfd_boolean yesno)\n   else if (!strcmp (\"allsymbolsreadsilent\", whichhook))\n     {\n       register_allsymbolsread_hook = yesno;\n-      allsymbolsread_silent = TRUE;\n+      allsymbolsread_silent = true;\n     }\n   else if (!strcmp (\"cleanup\", whichhook))\n     register_cleanup_hook = yesno;\n@@ -348,9 +348,9 @@ parse_option (const char *opt)\n   else if (!strncmp (\"pass\", opt, 4))\n     return set_ret_val (opt + 4, LDPS_OK);\n   else if (!strncmp (\"register\", opt, 8))\n-    return set_register_hook (opt + 8, TRUE);\n+    return set_register_hook (opt + 8, true);\n   else if (!strncmp (\"noregister\", opt, 10))\n-    return set_register_hook (opt + 10, FALSE);\n+    return set_register_hook (opt + 10, false);\n   else if (!strncmp (\"claim:\", opt, 6))\n     return record_claim_file (opt + 6, 0);\n   else if (!strncmp (\"sym:\", opt, 4))\n@@ -362,7 +362,7 @@ parse_option (const char *opt)\n   else if (!strncmp (\"dir:\", opt, 4))\n     return record_add_file (opt + 4, ADD_DIR);\n   else if (!strcmp (\"dumpresolutions\", opt))\n-    dumpresolutions = TRUE;\n+    dumpresolutions = true;\n   else\n     return LDPS_ERR;\n   return LDPS_OK;\n@@ -524,7 +524,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   size_t len = strlen (file->name);\n   char *name = xstrdup (file->name);\n   char *p = name + len;\n-  bfd_boolean islib;\n+  bool islib;\n \n   /* Only match the file name without the directory part.  */\n   islib = *p == 'a' && *(p - 1) == '.';\n@@ -553,7 +553,7 @@ onclaim_file (const struct ld_plugin_input_file *file, int *claimed)\n   *claimed = (claimfile != 0);\n   if (claimfile)\n     {\n-      claimfile->claimed = TRUE;\n+      claimfile->claimed = true;\n       claimfile->file = *file;\n       if (claimfile->n_syms_used && !tv_add_symbols)\n \treturn LDPS_ERR;"
    }
  ]
}