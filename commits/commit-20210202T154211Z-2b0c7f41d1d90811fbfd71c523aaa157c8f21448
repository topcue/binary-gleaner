{
  "sha": "2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmIwYzdmNDFkMWQ5MDgxMWZiZmQ3MWM1MjNhYWExNTdjOGYyMTQ0OA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-02-02T15:41:59Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-02-02T15:42:11Z"
    },
    "message": "gdb/dwarf: split dwarf2_cu::ranges_base in two\n\nConsider the test case added in this patch.  It defines a compilation\nunit with a DW_AT_rnglists_base attribute (used for attributes of form\nDW_FORM_rnglistx), but also uses DW_AT_ranges of form\nDW_FORM_sec_offset:\n\n    0x00000027: DW_TAG_compile_unit\n                  DW_AT_ranges [DW_FORM_sec_offset] (0x0000004c\n                     [0x0000000000005000, 0x0000000000006000))\n                  DW_AT_rnglists_base [DW_FORM_sec_offset]  (0x00000044)\n\nThe DW_AT_rnglists_base does not play a role in reading the DW_AT_ranges of\nform DW_FORM_sec_offset, but it should also not do any harm.\n\nThis case is currently not handled correctly by GDB.  This is not\nsomething that a compiler is likely to emit, but in my opinion there's\nno reason why GDB should fail reading it.\n\nThe problem is that in partial_die_info::read and a few other places\nwhere the same logic is replicated, the cu->ranges_base value,\ncontaining the DW_AT_rnglists_base value, is wrongfully added to the\nDW_AT_ranges value.\n\nIt is quite messy how to decide whether cu->ranges_base should be added\nto the attribute's value or not.  But to summarize, the only time we\nwant to add it is when the attribute comes from a pre-DWARF 5 split unit\nfile (a .dwo) [1].  In this case, the DW_AT_ranges attribute from the\nsplit unit file will have form DW_FORM_sec_offset, pointing somewhere in\nthe linked file's .debug_ranges section.  *But* it's not a \"true\"\nDW_FORM_sec_offset, in that it's an offset relative to the beginning of\nthat CU's contribution in the section, not relative to the beginning of\nthe section.  So in that case, and only that case, do we want to add the\nranges base value, which we found from the DW_AT_GNU_ranges_base\nattribute on the skeleton unit.\n\nAlmost all instances of the DW_AT_ranges attribute will be found in the\nsplit unit (on DW_TAG_subprogram, for example), and therefore need to\nhave the ranges base added.  However, the DW_TAG_compile_unit DIE in the\nskeleton may also have a DW_AT_ranges attribute.  For that one, the\nranges base must not be added.  Once the DIEs have been loaded in GDB,\nhowever, the distinction between what's coming from the skeleton and\nwhat's coming from the split unit is not clear.  It is all merged in one\nbig happy tree.  So how do we know if a given attribute comes from the\nsplit unit or not?\n\nWe use the fact that in pre-DWARF 5 split DWARF, DW_AT_ranges is found\non the skeleton's DW_TAG_compile_unit (in the linked file) and never in\nthe split unit's DW_TAG_compile_unit.  This is why you have this in\npartial_die_info::read:\n\n      int need_ranges_base = (tag != DW_TAG_compile_unit\n\t\t\t      && attr.form != DW_FORM_rnglistx);\n\nHowever, with the corner case described above (where we have a\nDW_AT_rnglists_base attribute and a DW_AT_ranges attribute of form\nDW_FORM_sec_offset) the condition gets it wrong when it encounters an\nattribute like DW_TAG_subprogram with a DW_AT_ranges attribute of\nDW_FORM_sec_offset form: it thinks that it is necessary to add the base,\nwhen it reality it is not.\n\nThe problem boils down to failing to differentiate these cases:\n\n  - a DW_AT_ranges attribute of form DW_FORM_sec_offset in a\n    pre-DWARF 5 split unit (in which case we need to add the base)\n  - a DW_AT_ranges attribute of form DW_FORM_sec_offset in a DWARF 5\n    non-split unit (in which case we must not add the base)\n\nWhat makes it unnecessarily complex is that the cu->ranges_base field is\noverloaded, used to hold the pre-DWARF 5, non-standard\nDW_AT_GNU_ranges_base and the DWARF 5 DW_AT_rnglists_base.  In reality,\nthese two are called \"bases\" but are not the same thing.  The result is\nthat we need twisted conditions to try to determine whether or not we\nshould add the base to the attribute's value.\n\nTo fix it, split the field in two distinct fields.  I renamed everything\nrelated to the \"old\" ranges base to \"gnu_ranges_base\", to make it clear\nthat it's about the non-standard, pre-DWARF 5 thing.  And everything\nrelated to the DWARF 5 thing gets renamed \"rnglists\".  I think it\nbecomes much easier to reason this way.\n\nThe issue described above gets fixed by the fact that the\nDW_AT_rnglists_base value does not end up in cu->gnu_ranges_base, so\ncu->gnu_ranges_base stays 0.  The condition to determine whether\ngnu_ranges_base should be added can therefore be simplified back to:\n\n  tag != DW_TAG_compile_unit\n\n... as it was before rnglistx support was added.\n\nExtend the gdb.dwarf2/rnglists-sec-offset.exp to cover this case.  I\nalso extended the test case for loclists similarly, just to see if there\nwould be some similar problem.  There wasn't, but I think it's not a bad\nidea to test that case for loclists as well, so I left it in the patch.\n\n[1] https://gcc.gnu.org/wiki/DebugFission\n\ngdb/ChangeLog:\n\n\t* dwarf2/die.h (struct die_info) <ranges_base>: Split in...\n\t<gnu_ranges_base>: ... this...\n\t<rnglists_base>: ... and this.\n\t* dwarf2/read.c (struct dwarf2_cu) <ranges_base>: Split in...\n\t<gnu_ranges_base>: ... this...\n\t<rnglists_base>: ... and this.\n\t(read_cutu_die_from_dwo): Adjust\n\t(dwarf2_get_pc_bounds): Adjust\n\t(dwarf2_record_block_ranges): Adjust.\n\t(read_full_die_1): Adjust\n\t(partial_die_info::read): Adjust.\n\t(read_rnglist_index): Adjust.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.dwarf2/rnglists-sec-offset.exp: Add test for DW_AT_ranges\n\tof DW_FORM_sec_offset form plus DW_AT_rnglists_base attribute.\n\t* gdb.dwarf2/loclists-sec-offset.exp: Add test for\n\tDW_AT_location of DW_FORM_sec_offset plus DW_AT_loclists_base\n\tattribute\n\nChange-Id: Icd109038634b75d0e6e9d7d1dcb62fb9eb951d83",
    "tree": {
      "sha": "d6bfaa2ff97f9c5a371d6e916fc18f11e9946b75",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d6bfaa2ff97f9c5a371d6e916fc18f11e9946b75"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ecfda20dcc4b658560cd4f0178f6c9cd569d4cad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ecfda20dcc4b658560cd4f0178f6c9cd569d4cad",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ecfda20dcc4b658560cd4f0178f6c9cd569d4cad"
    }
  ],
  "stats": {
    "total": 336,
    "additions": 251,
    "deletions": 85
  },
  "files": [
    {
      "sha": "9f60a77168e3fee3cca377902fc2d9d87b5eef84",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -1,3 +1,18 @@\n+2021-02-02  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/die.h (struct die_info) <ranges_base>: Split in...\n+\t<gnu_ranges_base>: ... this...\n+\t<rnglists_base>: ... and this.\n+\t* dwarf2/read.c (struct dwarf2_cu) <ranges_base>: Split in...\n+\t<gnu_ranges_base>: ... this...\n+\t<rnglists_base>: ... and this.\n+\t(read_cutu_die_from_dwo): Adjust\n+\t(dwarf2_get_pc_bounds): Adjust\n+\t(dwarf2_record_block_ranges): Adjust.\n+\t(read_full_die_1): Adjust\n+\t(partial_die_info::read): Adjust.\n+\t(read_rnglist_index): Adjust.\n+\n 2021-02-02  Simon Marchi  <simon.marchi@efficios.com>\n \n \tPR gdb/26813"
    },
    {
      "sha": "792b7214023aa14b2fecf41ea08f60cec8a822d2",
      "filename": "gdb/dwarf2/die.h",
      "status": "modified",
      "additions": 25,
      "deletions": 11,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/dwarf2/die.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/dwarf2/die.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/die.h?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -55,26 +55,40 @@ struct die_info\n     return gdb::optional<ULONGEST> ();\n   }\n \n-  /* Return range lists base of the compile unit, which, if exists, is\n-     stored either at the attribute DW_AT_rnglists_base or\n-     DW_AT_GNU_ranges_base.  */\n-  ULONGEST ranges_base ()\n+  /* Return the base address of the compile unit into the .debug_ranges section,\n+     which, if exists, is stored in the DW_AT_GNU_ranges_base attribute.  This\n+     value is only relevant in pre-DWARF 5 split-unit scenarios.  */\n+  ULONGEST gnu_ranges_base ()\n   {\n     for (unsigned i = 0; i < num_attrs; ++i)\n-      if (attrs[i].name == DW_AT_rnglists_base\n-\t  || attrs[i].name == DW_AT_GNU_ranges_base)\n+      if (attrs[i].name == DW_AT_GNU_ranges_base)\n \t{\n \t  if (attrs[i].form_is_unsigned ())\n-\t    {\n-\t      /* If both exist, just use the first one.  */\n-\t      return attrs[i].as_unsigned ();\n-\t    }\n-\t  complaint (_(\"ranges base attribute (offset %s) as wrong form\"),\n+\t    return attrs[i].as_unsigned ();\n+\n+\t  complaint (_(\"ranges base attribute (offset %s) has wrong form\"),\n \t\t     sect_offset_str (sect_off));\n \t}\n+\n     return 0;\n   }\n \n+  /* Return the rnglists base of the compile unit, which, if exists, is stored\n+     in the DW_AT_rnglists_base attribute.  */\n+  ULONGEST rnglists_base ()\n+  {\n+    for (unsigned i = 0; i < num_attrs; ++i)\n+      if (attrs[i].name == DW_AT_rnglists_base)\n+\t{\n+\t  if (attrs[i].form_is_unsigned ())\n+\t    return attrs[i].as_unsigned ();\n+\n+\t  complaint (_(\"rnglists base attribute (offset %s) has wrong form\"),\n+\t\t     sect_offset_str (sect_off));\n+\t}\n+\n+    return 0;\n+  }\n \n   /* DWARF-2 tag for this DIE.  */\n   ENUM_BITFIELD(dwarf_tag) tag : 16;"
    },
    {
      "sha": "dd2a885691bf1eec00b51e214f801d86518a66e1",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 77,
      "deletions": 65,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -551,16 +551,41 @@ struct dwarf2_cu\n      Note this value comes from the Fission stub CU/TU's DIE.  */\n   gdb::optional<ULONGEST> addr_base;\n \n-  /* The DW_AT_rnglists_base attribute if present.\n-     Note this value comes from the Fission stub CU/TU's DIE.\n-     Also note that the value is zero in the non-DWO case so this value can\n-     be used without needing to know whether DWO files are in use or not.\n-     N.B. This does not apply to DW_AT_ranges appearing in\n-     DW_TAG_compile_unit dies.  This is a bit of a wart, consider if ever\n-     DW_AT_ranges appeared in the DW_TAG_compile_unit of DWO DIEs: then\n-     DW_AT_rnglists_base *would* have to be applied, and we'd have to care\n-     whether the DW_AT_ranges attribute came from the skeleton or DWO.  */\n-  ULONGEST ranges_base = 0;\n+  /* The DW_AT_GNU_ranges_base attribute, if present.\n+\n+     This is only relevant in the context of pre-DWARF 5 split units.  In this\n+     context, there is a .debug_ranges section in the linked executable,\n+     containing all the ranges data for all the compilation units.  Each\n+     skeleton/stub unit has (if needed) a DW_AT_GNU_ranges_base attribute that\n+     indicates the base of its contribution to that section.  The DW_AT_ranges\n+     attributes in the split-unit are of the form DW_FORM_sec_offset and point\n+     into the .debug_ranges section of the linked file.  However, they are not\n+     \"true\" DW_FORM_sec_offset, because they are relative to the base of their\n+     compilation unit's contribution, rather than relative to the beginning of\n+     the section.  The DW_AT_GNU_ranges_base value must be added to it to make\n+     it relative to the beginning of the section.\n+\n+     Note that the value is zero when we are not in a pre-DWARF 5 split-unit\n+     case, so this value can be added without needing to know whether we are in\n+     this case or not.\n+\n+     N.B. If a DW_AT_ranges attribute is found on the DW_TAG_compile_unit in the\n+     skeleton/stub, it must not have the base added, as it already points to the\n+     right place.  And since the DW_TAG_compile_unit DIE in the split-unit can't\n+     have a DW_AT_ranges attribute, we can use the\n+\n+       die->tag != DW_AT_compile_unit\n+\n+     to determine whether the base should be added or not.  */\n+  ULONGEST gnu_ranges_base = 0;\n+\n+  /* The DW_AT_rnglists_base attribute, if present.\n+\n+     This is used when processing attributes of form DW_FORM_rnglistx in\n+     non-split units.  Attributes of this form found in a split unit don't\n+     use it, as split-unit files have their own non-shared .debug_rnglists.dwo\n+     section.  */\n+  ULONGEST rnglists_base = 0;\n \n   /* The DW_AT_loclists_base attribute if present.  */\n   ULONGEST loclist_base = 0;\n@@ -6967,10 +6992,17 @@ read_cutu_die_from_dwo (dwarf2_cu *cu,\n \n       cu->addr_base = stub_comp_unit_die->addr_base ();\n \n-      /* There should be a DW_AT_rnglists_base (DW_AT_GNU_ranges_base) attribute\n-\t here (if needed). We need the value before we can process\n-\t DW_AT_ranges.  */\n-      cu->ranges_base = stub_comp_unit_die->ranges_base ();\n+      /* There should be a DW_AT_GNU_ranges_base attribute here (if needed).\n+         We need the value before we can process DW_AT_ranges values from the\n+         DWO.  */\n+      cu->gnu_ranges_base = stub_comp_unit_die->gnu_ranges_base ();\n+\n+      /* For DWARF5: record the DW_AT_rnglists_base value from the skeleton.  If\n+         there are attributes of form DW_FORM_rnglistx in the skeleton, they'll\n+         need the rnglists base.  Attributes of form DW_FORM_rnglistx in the\n+         split unit don't use it, as the DWO has its own .debug_rnglists.dwo\n+         section.  */\n+      cu->rnglists_base = stub_comp_unit_die->rnglists_base ();\n     }\n   else if (stub_comp_dir != NULL)\n     {\n@@ -14659,20 +14691,14 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n       attr = dwarf2_attr (die, DW_AT_ranges, cu);\n       if (attr != nullptr && attr->form_is_unsigned ())\n \t{\n-\t  /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n-\t     We take advantage of the fact that DW_AT_ranges does not appear\n-\t     in DW_TAG_compile_unit of DWO files.\n-\n-\t     Attributes of the form DW_FORM_rnglistx have already had their\n-\t     value changed by read_rnglist_index and already include\n-\t     DW_AT_rnglists_base, so don't need to add the ranges base,\n-\t     either.  */\n-\t  int need_ranges_base = (die->tag != DW_TAG_compile_unit\n-\t\t\t\t  && attr->form != DW_FORM_rnglistx);\n-\t  unsigned int ranges_offset = (attr->as_unsigned ()\n-\t\t\t\t\t+ (need_ranges_base\n-\t\t\t\t\t   ? cu->ranges_base\n-\t\t\t\t\t   : 0));\n+\t  /* Offset in the .debug_ranges or .debug_rnglist section (depending\n+\t     on DWARF version).  */\n+\t  ULONGEST ranges_offset = attr->as_unsigned ();\n+\n+\t  /* See dwarf2_cu::gnu_ranges_base's doc for why we might want to add\n+\t     this value.  */\n+\t  if (die->tag != DW_TAG_compile_unit)\n+\t    ranges_offset += cu->gnu_ranges_base;\n \n \t  /* Value of the DW_AT_ranges attribute is the offset in the\n \t     .debug_ranges section.  */\n@@ -14837,24 +14863,17 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n   attr = dwarf2_attr (die, DW_AT_ranges, cu);\n   if (attr != nullptr && attr->form_is_unsigned ())\n     {\n-      /* DW_AT_rnglists_base does not apply to DIEs from the DWO skeleton.\n-\t We take advantage of the fact that DW_AT_ranges does not appear\n-\t in DW_TAG_compile_unit of DWO files.\n-\n-\t Attributes of the form DW_FORM_rnglistx have already had their\n-\t value changed by read_rnglist_index and already include\n-\t DW_AT_rnglists_base, so don't need to add the ranges base,\n-\t either.  */\n-      int need_ranges_base = (die->tag != DW_TAG_compile_unit\n-\t\t\t      && attr->form != DW_FORM_rnglistx);\n+      /* Offset in the .debug_ranges or .debug_rnglist section (depending\n+\t on DWARF version).  */\n+      ULONGEST ranges_offset = attr->as_unsigned ();\n \n-      /* The value of the DW_AT_ranges attribute is the offset of the\n-\t address range list in the .debug_ranges section.  */\n-      unsigned long offset = (attr->as_unsigned ()\n-\t\t\t      + (need_ranges_base ? cu->ranges_base : 0));\n+      /* See dwarf2_cu::gnu_ranges_base's doc for why we might want to add\n+\t this value.  */\n+      if (die->tag != DW_TAG_compile_unit)\n+\tranges_offset += cu->gnu_ranges_base;\n \n       std::vector<blockrange> blockvec;\n-      dwarf2_ranges_process (offset, cu, die->tag,\n+      dwarf2_ranges_process (ranges_offset, cu, die->tag,\n \t[&] (CORE_ADDR start, CORE_ADDR end)\n \t{\n \t  start += baseaddr;\n@@ -19292,7 +19311,7 @@ read_full_die_1 (const struct die_reader_specs *reader,\n \n   attr = die->attr (DW_AT_rnglists_base);\n   if (attr != nullptr)\n-    cu->ranges_base = attr->as_unsigned ();\n+    cu->rnglists_base = attr->as_unsigned ();\n \n   if (any_need_reprocess)\n     {\n@@ -19820,26 +19839,15 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \n \tcase DW_AT_ranges:\n \t  {\n-\t    /* DW_AT_rnglists_base does not apply to DIEs from the DWO\n-\t       skeleton.  We take advantage of the fact the DW_AT_ranges\n-\t       does not appear in DW_TAG_compile_unit of DWO files.\n-\n-\t       Attributes of the form DW_FORM_rnglistx have already had\n-\t       their value changed by read_rnglist_index and already\n-\t       include DW_AT_rnglists_base, so don't need to add the ranges\n-\t       base, either.  */\n-\t    int need_ranges_base = (tag != DW_TAG_compile_unit\n-\t\t\t\t    && attr.form != DW_FORM_rnglistx);\n-\t    /* It would be nice to reuse dwarf2_get_pc_bounds here,\n-\t       but that requires a full DIE, so instead we just\n-\t       reimplement it.  */\n-\t    unsigned int ranges_offset = (attr.as_unsigned ()\n-\t\t\t\t\t  + (need_ranges_base\n-\t\t\t\t\t     ? cu->ranges_base\n-\t\t\t\t\t     : 0));\n-\n-\t    /* Value of the DW_AT_ranges attribute is the offset in the\n-\t       .debug_ranges section.  */\n+\t    /* Offset in the .debug_ranges or .debug_rnglist section (depending\n+\t       on DWARF version).  */\n+\t    ULONGEST ranges_offset = attr.as_unsigned ();\n+\n+\t    /* See dwarf2_cu::gnu_ranges_base's doc for why we might want to add\n+\t       this value.  */\n+\t    if (tag != DW_TAG_compile_unit)\n+\t      ranges_offset += cu->gnu_ranges_base;\n+\n \t    if (dwarf2_ranges_read (ranges_offset, &lowpc, &highpc, cu,\n \t\t\t\t    nullptr, tag))\n \t      has_pc_info = 1;\n@@ -20282,8 +20290,12 @@ read_rnglist_index (struct dwarf2_cu *cu, ULONGEST rnglist_index,\n   ULONGEST rnglist_header_size =\n     (cu->header.initial_length_size == 4 ? RNGLIST_HEADER_SIZE32\n      : RNGLIST_HEADER_SIZE64);\n+\n+  /* When reading a DW_FORM_rnglistx from a DWO, we read from the DWO's\n+     .debug_rnglists.dwo section.  The rnglists base given in the skeleton\n+     doesn't apply.  */\n   ULONGEST rnglist_base =\n-      (cu->dwo_unit != nullptr) ? rnglist_header_size : cu->ranges_base;\n+      (cu->dwo_unit != nullptr) ? rnglist_header_size : cu->rnglists_base;\n \n   /* Offset in .debug_rnglists of the offset for RNGLIST_INDEX.  */\n   ULONGEST start_offset ="
    },
    {
      "sha": "be5afad904ebefe07ccb2284daca66a35543f6ce",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -1,3 +1,11 @@\n+2021-02-02  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdb.dwarf2/rnglists-sec-offset.exp: Add test for DW_AT_ranges\n+\tof DW_FORM_sec_offset form plus DW_AT_rnglists_base attribute.\n+\t* gdb.dwarf2/loclists-sec-offset.exp: Add test for\n+\tDW_AT_location of DW_FORM_sec_offset plus DW_AT_loclists_base\n+\tattribute\n+\n 2021-02-02  Simon Marchi  <simon.marchi@efficios.com>\n \n \tPR gdb/26813"
    },
    {
      "sha": "924c6ccd4126e3f330f7632f867dc6b8f8928f31",
      "filename": "gdb/testsuite/gdb.dwarf2/loclists-sec-offset.c",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.c?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -29,9 +29,25 @@ func2 (void)\n   return 2;\n }\n \n+static int\n+func3 (void)\n+{\n+  asm (\"func3_label: .global func3_label\\n\");\n+  return 3;\n+}\n+\n+static int\n+func4 (void)\n+{\n+  asm (\"func4_label: .global func4_label\\n\");\n+  return 4;\n+}\n+\n int\n main (void)\n {\n   func1 ();\n   func2 ();\n+  func3 ();\n+  func4 ();\n }"
    },
    {
      "sha": "ecd85ee116c1e89e834c06fb6a39894ac176ca2f",
      "filename": "gdb/testsuite/gdb.dwarf2/loclists-sec-offset.exp",
      "status": "modified",
      "additions": 73,
      "deletions": 5,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/loclists-sec-offset.exp?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -32,14 +32,18 @@ foreach_with_prefix is_64 {false true} {\n \tset testfile ${testfile}-dw32\n     }\n \n-    # Get the addresses / lengths of func1 and func2.\n+    # Get the addresses / lengths of functions.\n     lassign [function_range func1 $srcdir/$subdir/$srcfile] func1_addr func1_len\n     lassign [function_range func2 $srcdir/$subdir/$srcfile] func2_addr func2_len\n+    lassign [function_range func3 $srcdir/$subdir/$srcfile] func3_addr func3_len\n+    lassign [function_range func4 $srcdir/$subdir/$srcfile] func4_addr func4_len\n \n     set asm_file [standard_output_file $srcfile2]\n     Dwarf::assemble $asm_file {\n \tglobal func1_addr func1_len\n \tglobal func2_addr func2_len\n+\tglobal func3_addr func3_len\n+\tglobal func4_addr func4_len\n \tglobal is_64\n \n \tdeclare_labels cu_range_list foo_range_list\n@@ -50,12 +54,13 @@ foreach_with_prefix is_64 {false true} {\n \t    version 5\n \t    is_64 $is_64\n \t} {\n-\t    declare_labels int_type\n-\t    declare_labels foo_location_list\n+\t    declare_labels int_type1\n+\t    declare_labels int_type2\n+\t    declare_labels foo_location_list bar_location_list\n \n \t    DW_TAG_compile_unit {\n \t    } {\n-\t\tint_type: DW_TAG_base_type {\n+\t\tint_type1: DW_TAG_base_type {\n \t\t    {DW_AT_byte_size 4 DW_FORM_data1}\n \t\t    {DW_AT_encoding @DW_ATE_signed}\n \t\t    {DW_AT_name \"int\"}\n@@ -64,7 +69,7 @@ foreach_with_prefix is_64 {false true} {\n \t\tDW_TAG_variable {\n \t\t    {DW_AT_name \"foo\"}\n \t\t    {DW_AT_location $foo_location_list DW_FORM_sec_offset}\n-\t\t    {DW_AT_type :$int_type}\n+\t\t    {DW_AT_type :$int_type1}\n \t\t}\n \n \t\tDW_TAG_subprogram {\n@@ -81,6 +86,43 @@ foreach_with_prefix is_64 {false true} {\n \t    }\n \t}\n \n+\t# This CU uses the DW_FORM_sec_offset form to refer to the\n+\t# .debug_loclists section, but also has the DW_AT_loclists_base\n+\t# attribute present.  The DW_AT_loclists_base is not used to interpret\n+\t# the DW_AT_location value, but it should also do no harm.\n+\tcu {\n+\t    version 5\n+\t    is_64 $is_64\n+\t} {\n+\t    DW_TAG_compile_unit {\n+\t\t{DW_AT_loclists_base cu2_table DW_FORM_sec_offset}\n+\t    } {\n+\t\tint_type2: DW_TAG_base_type {\n+\t\t    {DW_AT_byte_size 4 DW_FORM_data1}\n+\t\t    {DW_AT_encoding @DW_ATE_signed}\n+\t\t    {DW_AT_name \"int\"}\n+\t\t}\n+\n+\t\tDW_TAG_variable {\n+\t\t    {DW_AT_name \"bar\"}\n+\t\t    {DW_AT_location $bar_location_list DW_FORM_sec_offset}\n+\t\t    {DW_AT_type :$int_type2}\n+\t\t}\n+\n+\t\tDW_TAG_subprogram {\n+\t\t    {DW_AT_name \"func3\"}\n+\t\t    {DW_AT_low_pc $func3_addr}\n+\t\t    {DW_AT_high_pc $func3_len DW_FORM_udata}\n+\t\t}\n+\n+\t\tDW_TAG_subprogram {\n+\t\t    {DW_AT_name \"func4\"}\n+\t\t    {DW_AT_low_pc $func4_addr}\n+\t\t    {DW_AT_high_pc $func4_len DW_FORM_udata}\n+\t\t}\n+\t    }\n+\t}\n+\n \tloclists -is-64 $is_64 {\n \t    # The lists in this table are accessed by direct offset\n \t    # (DW_FORM_sec_offset).\n@@ -97,6 +139,20 @@ foreach_with_prefix is_64 {false true} {\n \t\t    }\n \t\t}\n \t    }\n+\n+\t    table -post-header-label cu2_table {\n+\t\tbar_location_list: list_ {\n+\t\t    start_length $func3_addr $func3_len {\n+\t\t\tDW_OP_constu 0x345678\n+\t\t\tDW_OP_stack_value\n+\t\t    }\n+\n+\t\t    start_length $func4_addr $func4_len {\n+\t\t\tDW_OP_constu 0x456789\n+\t\t\tDW_OP_stack_value\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -112,6 +168,8 @@ foreach_with_prefix is_64 {false true} {\n \n     gdb_breakpoint \"func1\"\n     gdb_breakpoint \"func2\"\n+    gdb_breakpoint \"func3\"\n+    gdb_breakpoint \"func4\"\n \n     gdb_continue_to_breakpoint \"func1\"\n     with_test_prefix \"at func1\" {\n@@ -122,4 +180,14 @@ foreach_with_prefix is_64 {false true} {\n     with_test_prefix \"at func2\" {\n \tgdb_test \"print /x foo\" \" = 0x234567\"\n     }\n+\n+    gdb_continue_to_breakpoint \"func3\"\n+    with_test_prefix \"at func3\" {\n+\tgdb_test \"print /x bar\" \" = 0x345678\"\n+    }\n+\n+    gdb_continue_to_breakpoint \"func4\"\n+    with_test_prefix \"at func4\" {\n+\tgdb_test \"print /x bar\" \" = 0x456789\"\n+    }\n }"
    },
    {
      "sha": "2bcbe0aeea8a519f15213fd4a6fdb15f0d88552f",
      "filename": "gdb/testsuite/gdb.dwarf2/rnglists-sec-offset.exp",
      "status": "modified",
      "additions": 37,
      "deletions": 4,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/rnglists-sec-offset.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c7f41d1d90811fbfd71c523aaa157c8f21448/gdb/testsuite/gdb.dwarf2/rnglists-sec-offset.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/rnglists-sec-offset.exp?ref=2b0c7f41d1d90811fbfd71c523aaa157c8f21448",
      "patch": "@@ -35,7 +35,8 @@ foreach_with_prefix is_64 {false true} {\n     Dwarf::assemble $asm_file {\n \tglobal is_64\n \n-\tdeclare_labels cu_range_list foo_range_list\n+\tdeclare_labels cu1_range_list cu2_range_list\n+\tdeclare_labels foo_range_list bar_range_list\n \n \t# This CU uses the DW_FORM_sec_offset form to refer to the .debug_rnglists\n \t# section.\n@@ -44,7 +45,7 @@ foreach_with_prefix is_64 {false true} {\n \t    is_64 $is_64\n \t} {\n \t    DW_TAG_compile_unit {\n-\t\t{DW_AT_ranges $cu_range_list DW_FORM_sec_offset}\n+\t\t{DW_AT_ranges $cu1_range_list DW_FORM_sec_offset}\n \t    } {\n \t\tDW_TAG_subprogram {\n \t\t    {DW_AT_name \"foo\"}\n@@ -53,12 +54,31 @@ foreach_with_prefix is_64 {false true} {\n \t    }\n \t}\n \n+\t# This CU uses the DW_FORM_sec_offset form to refer to the\n+\t# .debug_rnglists section, but also has the DW_AT_rnglists_base\n+\t# attribute present.  The DW_AT_rnglists_base attribute is not used to\n+\t# interpret the DW_AT_ranges value, but it should also do no harm.\n+\tcu {\n+\t    version 5\n+\t    is_64 $is_64\n+\t} {\n+\t    DW_TAG_compile_unit {\n+\t\t{DW_AT_ranges $cu2_range_list DW_FORM_sec_offset}\n+\t\t{DW_AT_rnglists_base cu2_table DW_FORM_sec_offset}\n+\t    } {\n+\t\tDW_TAG_subprogram {\n+\t\t    {DW_AT_name \"bar\"}\n+\t\t    {DW_AT_ranges $bar_range_list DW_FORM_sec_offset}\n+\t\t}\n+\t    }\n+\t}\n+\n \trnglists -is-64 $is_64 {\n \t    # The lists in this table are accessed by direct offset\n \t    # (DW_FORM_sec_offset).\n \t    table {\n-\t\t# For the CU.\n-\t\tcu_range_list: list_ {\n+\t\t# For the first CU.\n+\t\tcu1_range_list: list_ {\n \t\t    start_end 0x4000 0x5000\n \t\t}\n \n@@ -67,6 +87,18 @@ foreach_with_prefix is_64 {false true} {\n \t\t    start_end 0x4000 0x4010\n \t\t}\n \t    }\n+\n+\t    table -post-header-label cu2_table {\n+\t\t# For the second CU.\n+\t\tcu2_range_list: list_ {\n+\t\t    start_end 0x5000 0x6000\n+\t\t}\n+\n+\t\t# For the bar function.\n+\t\tbar_range_list: list_ {\n+\t\t    start_end 0x5000 0x5010\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -77,4 +109,5 @@ foreach_with_prefix is_64 {false true} {\n \n     # Sanity checks to make sure GDB slurped the symbols correctly.\n     gdb_test \"p/x &foo\" \" = 0x4000\"\n+    gdb_test \"p/x &bar\" \" = 0x5000\"\n }"
    }
  ]
}