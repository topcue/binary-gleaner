{
  "sha": "03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDM2NDJiNzE4OWJjMGJmZGY2MTM1NGE2ZDlhM2YzZTQ2ZDgyNzA5Yw==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-09T21:41:30Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-09T21:46:12Z"
    },
    "message": "gdb: revert \"gdb: unify parts of the Linux and FreeBSD core dumping code\"\n\nThis reverts commit 82a1fd3a4935fe665cf08bc6820942c4a091184c.\n\nIt was pointed out:\n\n  https://sourceware.org/pipermail/gdb-patches/2021-February/175750.html\n\nthat commit 82a1fd3a4935 caused GDB to have an unconditional\ndependency on ELF specific parts of BFD.  What this means is that if\nGDB and BFD are built for a non-elf target then there will be\nundefined symbol references within GDB.\n\nThe right solution isn't immediately obvious.  So rather than rush a\nfix in I'm reverting this commit for now, and will bring it back once\nI have a good solution.\n\ngdb/ChangeLog:\n\n\t* gcore.c (struct gcore_collect_regset_section_cb_data): Delete.\n\t(gcore_collect_regset_section_cb): Delete.\n\t(gcore_collect_thread_registers): Delete.\n\t(gcore_build_thread_register_notes): Delete.\n\t(gcore_find_signalled_thread): Delete.\n\t* gcore.h: Remove 'gdbsupport/gdb_signals.h' include and delete\n\t'gdbarch' and 'thread_info' declarations.\n\t(gcore_build_thread_register_notes): Delete declaration.\n\t(gcore_find_signalled_thread): Likewise.\n\t* fbsd-tdep.c: Remove 'gcore.h' include.\n\t(struct fbsd_collect_regset_section_cb_data): New struct.\n\t(fbsd_collect_regset_section_cb): New function.\n\t(fbsd_collect_thread_registers): New function.\n\t(struct fbsd_corefile_thread_data): New struct.\n\t(fbsd_corefile_thread): New function.\n\t(fbsd_make_corefile_notes): Call FreeBSD specific code.\n\t* linux-tdep.c: Remove 'gcore.h' include.\n\t(struct linux_collect_regset_section_cb_data): New struct.\n\t(linux_collect_regset_section_cb): New function.\n\t(linux_collect_thread_registers): New function.\n\t(linux_corefile_thread): Call Linux specific code.\n\t(find_signalled_thread): New function.\n\t(linux_make_corefile_notes): Call find_signalled_thread.",
    "tree": {
      "sha": "4c18b49e25fceaab1b1a658fc868b55d61d4387f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4c18b49e25fceaab1b1a658fc868b55d61d4387f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b61f78118a850a28a41a461fdaea4026ddc17658",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b61f78118a850a28a41a461fdaea4026ddc17658",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b61f78118a850a28a41a461fdaea4026ddc17658"
    }
  ],
  "stats": {
    "total": 458,
    "additions": 288,
    "deletions": 170
  },
  "files": [
    {
      "sha": "220ef2a52a4e7fc272a3d5b0ad29d14ddd727747",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
      "patch": "@@ -1,3 +1,29 @@\n+2021-02-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcore.c (struct gcore_collect_regset_section_cb_data): Delete.\n+\t(gcore_collect_regset_section_cb): Delete.\n+\t(gcore_collect_thread_registers): Delete.\n+\t(gcore_build_thread_register_notes): Delete.\n+\t(gcore_find_signalled_thread): Delete.\n+\t* gcore.h: Remove 'gdbsupport/gdb_signals.h' include and delete\n+\t'gdbarch' and 'thread_info' declarations.\n+\t(gcore_build_thread_register_notes): Delete declaration.\n+\t(gcore_find_signalled_thread): Likewise.\n+\t* fbsd-tdep.c: Remove 'gcore.h' include.\n+\t(struct fbsd_collect_regset_section_cb_data): New struct.\n+\t(fbsd_collect_regset_section_cb): New function.\n+\t(fbsd_collect_thread_registers): New function.\n+\t(struct fbsd_corefile_thread_data): New struct.\n+\t(fbsd_corefile_thread): New function.\n+\t(fbsd_make_corefile_notes): Call FreeBSD specific code.\n+\t* linux-tdep.c: Remove 'gcore.h' include.\n+\t(struct linux_collect_regset_section_cb_data): New struct.\n+\t(linux_collect_regset_section_cb): New function.\n+\t(linux_collect_thread_registers): New function.\n+\t(linux_corefile_thread): Call Linux specific code.\n+\t(find_signalled_thread): New function.\n+\t(linux_make_corefile_notes): Call find_signalled_thread.\n+\n 2021-02-09  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (coerce_unspec_val_to_type): Avoid making lazy"
    },
    {
      "sha": "cc51e921ae2f5d4bc9d129c8877fe25e39f52fb1",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 128,
      "deletions": 7,
      "changes": 135,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
      "patch": "@@ -32,7 +32,6 @@\n \n #include \"elf-bfd.h\"\n #include \"fbsd-tdep.h\"\n-#include \"gcore.h\"\n \n /* This enum is derived from FreeBSD's <sys/signal.h>.  */\n \n@@ -584,6 +583,129 @@ find_signalled_thread (struct thread_info *info, void *data)\n   return 0;\n }\n \n+/* Structure for passing information from\n+   fbsd_collect_thread_registers via an iterator to\n+   fbsd_collect_regset_section_cb. */\n+\n+struct fbsd_collect_regset_section_cb_data\n+{\n+  fbsd_collect_regset_section_cb_data (const struct regcache *regcache,\n+\t\t\t\t       bfd *obfd,\n+\t\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n+\t\t\t\t       int *note_size,\n+\t\t\t\t       unsigned long lwp,\n+\t\t\t\t       gdb_signal stop_signal)\n+    : regcache (regcache),\n+      obfd (obfd),\n+      note_data (note_data),\n+      note_size (note_size),\n+      lwp (lwp),\n+      stop_signal (stop_signal)\n+  {}\n+\n+  const struct regcache *regcache;\n+  bfd *obfd;\n+  gdb::unique_xmalloc_ptr<char> &note_data;\n+  int *note_size;\n+  unsigned long lwp;\n+  enum gdb_signal stop_signal;\n+  bool abort_iteration = false;\n+};\n+\n+static void\n+fbsd_collect_regset_section_cb (const char *sect_name, int supply_size,\n+\t\t\t\tint collect_size, const struct regset *regset,\n+\t\t\t\tconst char *human_name, void *cb_data)\n+{\n+  char *buf;\n+  struct fbsd_collect_regset_section_cb_data *data\n+    = (struct fbsd_collect_regset_section_cb_data *) cb_data;\n+\n+  if (data->abort_iteration)\n+    return;\n+\n+  gdb_assert (regset->collect_regset);\n+\n+  buf = (char *) xmalloc (collect_size);\n+  regset->collect_regset (regset, data->regcache, -1, buf, collect_size);\n+\n+  /* PRSTATUS still needs to be treated specially.  */\n+  if (strcmp (sect_name, \".reg\") == 0)\n+    data->note_data.reset (elfcore_write_prstatus\n+\t\t\t     (data->obfd, data->note_data.release (),\n+\t\t\t      data->note_size, data->lwp,\n+\t\t\t      gdb_signal_to_host (data->stop_signal),\n+\t\t\t      buf));\n+  else\n+    data->note_data.reset (elfcore_write_register_note\n+\t\t\t     (data->obfd, data->note_data.release (),\n+\t\t\t      data->note_size, sect_name, buf,\n+\t\t\t      collect_size));\n+  xfree (buf);\n+\n+  if (data->note_data == NULL)\n+    data->abort_iteration = true;\n+}\n+\n+/* Records the thread's register state for the corefile note\n+   section.  */\n+\n+static void\n+fbsd_collect_thread_registers (const struct regcache *regcache,\n+\t\t\t       ptid_t ptid, bfd *obfd,\n+\t\t\t       gdb::unique_xmalloc_ptr<char> &note_data,\n+\t\t\t       int *note_size,\n+\t\t\t       enum gdb_signal stop_signal)\n+{\n+  fbsd_collect_regset_section_cb_data data (regcache, obfd, note_data,\n+\t\t\t\t\t    note_size, ptid.lwp (),\n+\t\t\t\t\t    stop_signal);\n+\n+  gdbarch_iterate_over_regset_sections (regcache->arch (),\n+\t\t\t\t\tfbsd_collect_regset_section_cb,\n+\t\t\t\t\t&data, regcache);\n+}\n+\n+struct fbsd_corefile_thread_data\n+{\n+  fbsd_corefile_thread_data (struct gdbarch *gdbarch,\n+\t\t\t     bfd *obfd,\n+\t\t\t     gdb::unique_xmalloc_ptr<char> &note_data,\n+\t\t\t     int *note_size,\n+\t\t\t     gdb_signal stop_signal)\n+    : gdbarch (gdbarch),\n+      obfd (obfd),\n+      note_data (note_data),\n+      note_size (note_size),\n+      stop_signal (stop_signal)\n+  {}\n+\n+  struct gdbarch *gdbarch;\n+  bfd *obfd;\n+  gdb::unique_xmalloc_ptr<char> &note_data;\n+  int *note_size;\n+  enum gdb_signal stop_signal;\n+};\n+\n+/* Records the thread's register state for the corefile note\n+   section.  */\n+\n+static void\n+fbsd_corefile_thread (struct thread_info *info,\n+\t\t      struct fbsd_corefile_thread_data *args)\n+{\n+  struct regcache *regcache;\n+\n+  regcache = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\t       info->ptid, args->gdbarch);\n+\n+  target_fetch_registers (regcache, -1);\n+\n+  fbsd_collect_thread_registers (regcache, info->ptid, args->obfd,\n+\t\t\t\t args->note_data, args->note_size,\n+\t\t\t\t args->stop_signal);\n+}\n+\n /* Return a byte_vector containing the contents of a core dump note\n    for the target object of type OBJECT.  If STRUCTSIZE is non-zero,\n    the data is prefixed with a 32-bit integer size to match the format\n@@ -660,17 +782,16 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \tsignalled_thr = curr_thr;\n     }\n \n-  gcore_build_thread_register_notes (gdbarch, signalled_thr,\n-\t\t\t\t     signalled_thr->suspend.stop_signal,\n-\t\t\t\t     obfd, &note_data, note_size);\n+  fbsd_corefile_thread_data thread_args (gdbarch, obfd, note_data, note_size,\n+\t\t\t\t\t signalled_thr->suspend.stop_signal);\n+\n+  fbsd_corefile_thread (signalled_thr, &thread_args);\n   for (thread_info *thr : current_inferior ()->non_exited_threads ())\n     {\n       if (thr == signalled_thr)\n \tcontinue;\n \n-      gcore_build_thread_register_notes (gdbarch, thr,\n-\t\t\t\t\t signalled_thr->suspend.stop_signal,\n-\t\t\t\t\t obfd, &note_data, note_size);\n+      fbsd_corefile_thread (thr, &thread_args);\n     }\n \n   /* Auxiliary vector.  */"
    },
    {
      "sha": "73ac6b09c7028fd219035f97056f7d51f9ff4b6f",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 0,
      "deletions": 136,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
      "patch": "@@ -579,142 +579,6 @@ gcore_memory_sections (bfd *obfd)\n   return 1;\n }\n \n-/* Structure for passing information from GCORE_COLLECT_THREAD_REGISTERS\n-   via an iterator to GCORE_COLLECT_REGSET_SECTION_CB. */\n-\n-struct gcore_collect_regset_section_cb_data\n-{\n-  gcore_collect_regset_section_cb_data (struct gdbarch *gdbarch,\n-\t\t\t\t\tconst struct regcache *regcache,\n-\t\t\t\t\tbfd *obfd, ptid_t ptid,\n-\t\t\t\t\tgdb_signal stop_signal,\n-\t\t\t\t\tgdb::unique_xmalloc_ptr<char> *note_data,\n-\t\t\t\t\tint *note_size)\n-\n-    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n-      note_data (note_data), note_size (note_size),\n-      stop_signal (stop_signal)\n-  {\n-    /* The LWP is often not available for bare metal target, in which case\n-       use the tid instead.  */\n-    if (ptid.lwp_p ())\n-      lwp = ptid.lwp ();\n-    else\n-      lwp = ptid.tid ();\n-  }\n-\n-  struct gdbarch *gdbarch;\n-  const struct regcache *regcache;\n-  bfd *obfd;\n-  gdb::unique_xmalloc_ptr<char> *note_data;\n-  int *note_size;\n-  unsigned long lwp;\n-  enum gdb_signal stop_signal;\n-  bool abort_iteration = false;\n-};\n-\n-/* Callback for ITERATE_OVER_REGSET_SECTIONS that records a single\n-   regset in the core file note section.  */\n-\n-static void\n-gcore_collect_regset_section_cb (const char *sect_name, int supply_size,\n-\t\t\t\t int collect_size,\n-\t\t\t\t const struct regset *regset,\n-\t\t\t\t const char *human_name, void *cb_data)\n-{\n-  struct gcore_collect_regset_section_cb_data *data\n-    = (struct gcore_collect_regset_section_cb_data *) cb_data;\n-  bool variable_size_section = (regset != NULL\n-\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n-\n-  gdb_assert (variable_size_section || supply_size == collect_size);\n-\n-  if (data->abort_iteration)\n-    return;\n-\n-  gdb_assert (regset != nullptr && regset->collect_regset != nullptr);\n-\n-  /* This is intentionally zero-initialized by using std::vector, so\n-     that any padding bytes in the core file will show as 0.  */\n-  std::vector<gdb_byte> buf (collect_size);\n-\n-  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n-\t\t\t  collect_size);\n-\n-  /* PRSTATUS still needs to be treated specially.  */\n-  if (strcmp (sect_name, \".reg\") == 0)\n-    data->note_data->reset (elfcore_write_prstatus\n-\t\t\t    (data->obfd, data->note_data->release (),\n-\t\t\t     data->note_size, data->lwp,\n-\t\t\t     gdb_signal_to_host (data->stop_signal),\n-\t\t\t     buf.data ()));\n-  else\n-    data->note_data->reset (elfcore_write_register_note\n-\t\t\t    (data->obfd, data->note_data->release (),\n-\t\t\t     data->note_size, sect_name, buf.data (),\n-\t\t\t     collect_size));\n-\n-  if (data->note_data == nullptr)\n-    data->abort_iteration = true;\n-}\n-\n-/* Records the register state of thread PTID out of REGCACHE into the note\n-   buffer represented by *NOTE_DATA and NOTE_SIZE.  OBFD is the bfd into\n-   which the core file is being created, and STOP_SIGNAL is the signal that\n-   cause thread PTID to stop.  */\n-\n-static void\n-gcore_collect_thread_registers (const struct regcache *regcache,\n-\t\t\t\tptid_t ptid, bfd *obfd,\n-\t\t\t\tgdb::unique_xmalloc_ptr<char> *note_data,\n-\t\t\t\tint *note_size,\n-\t\t\t\tenum gdb_signal stop_signal)\n-{\n-  struct gdbarch *gdbarch = regcache->arch ();\n-  gcore_collect_regset_section_cb_data data (gdbarch, regcache, obfd, ptid,\n-\t\t\t\t\t     stop_signal, note_data,\n-\t\t\t\t\t     note_size);\n-  gdbarch_iterate_over_regset_sections (gdbarch,\n-\t\t\t\t\tgcore_collect_regset_section_cb,\n-\t\t\t\t\t&data, regcache);\n-}\n-\n-/* See gcore.h.  */\n-\n-void\n-gcore_build_thread_register_notes\n-  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n-   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size)\n-{\n-  struct regcache *regcache\n-    = get_thread_arch_regcache (info->inf->process_target (),\n-\t\t\t\tinfo->ptid, gdbarch);\n-  target_fetch_registers (regcache, -1);\n-  gcore_collect_thread_registers (regcache, info->ptid, obfd, note_data,\n-\t\t\t\t  note_size, stop_signal);\n-}\n-\n-/* See gcore.h.  */\n-\n-thread_info *\n-gcore_find_signalled_thread ()\n-{\n-  thread_info *curr_thr = inferior_thread ();\n-  if (curr_thr->state != THREAD_EXITED\n-      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n-    return curr_thr;\n-\n-  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n-    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n-      return thr;\n-\n-  /* Default to the current thread, unless it has exited.  */\n-  if (curr_thr->state != THREAD_EXITED)\n-    return curr_thr;\n-\n-  return nullptr;\n-}\n-\n void _initialize_gcore ();\n void\n _initialize_gcore ()"
    },
    {
      "sha": "af37ff39b414d1cf9bfa1930563ecfbd82248c05",
      "filename": "gdb/gcore.h",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/gcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/gcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.h?ref=03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
      "patch": "@@ -21,31 +21,11 @@\n #define GCORE_H 1\n \n #include \"gdb_bfd.h\"\n-#include \"gdbsupport/gdb_signals.h\"\n-\n-struct gdbarch;\n-struct thread_info;\n \n extern gdb_bfd_ref_ptr create_gcore_bfd (const char *filename);\n extern void write_gcore_file (bfd *obfd);\n extern int objfile_find_memory_regions (struct target_ops *self,\n \t\t\t\t\tfind_memory_region_ftype func,\n \t\t\t\t\tvoid *obfd);\n \n-/* Add content to *NOTE_DATA (and update *NOTE_SIZE) to describe the\n-   registers of thread INFO.  Report the thread as having stopped with\n-   STOP_SIGNAL.  The core file is being written to OFD, and GDBARCH is the\n-   architecture for which the core file is being generated.  */\n-\n-extern void gcore_build_thread_register_notes\n-  (struct gdbarch *gdbarch, struct thread_info *info, gdb_signal stop_signal,\n-   bfd *obfd, gdb::unique_xmalloc_ptr<char> *note_data, int *note_size);\n-\n-/* Find the signalled thread.  In case there's more than one signalled\n-   thread, prefer the current thread, if it is signalled.  If no thread was\n-   signalled, default to the current thread, unless it has exited, in which\n-   case return NULL.  */\n-\n-extern thread_info *gcore_find_signalled_thread ();\n-\n #endif /* GCORE_H */"
    },
    {
      "sha": "e9f8e1b61336ad4d4d4492680b0bd1878e9dfe78",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 134,
      "deletions": 7,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/03642b7189bc0bfdf61354a6d9a3f3e46d82709c/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=03642b7189bc0bfdf61354a6d9a3f3e46d82709c",
      "patch": "@@ -39,7 +39,6 @@\n #include \"gdb_regex.h\"\n #include \"gdbsupport/enum-flags.h\"\n #include \"gdbsupport/gdb_optional.h\"\n-#include \"gcore.h\"\n \n #include <ctype.h>\n \n@@ -1598,6 +1597,104 @@ linux_make_mappings_corefile_notes (struct gdbarch *gdbarch, bfd *obfd,\n     }\n }\n \n+/* Structure for passing information from\n+   linux_collect_thread_registers via an iterator to\n+   linux_collect_regset_section_cb. */\n+\n+struct linux_collect_regset_section_cb_data\n+{\n+  linux_collect_regset_section_cb_data (struct gdbarch *gdbarch,\n+\t\t\t\t\tconst struct regcache *regcache,\n+\t\t\t\t\tbfd *obfd,\n+\t\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n+\t\t\t\t\tint *note_size,\n+\t\t\t\t\tunsigned long lwp,\n+\t\t\t\t\tgdb_signal stop_signal)\n+    : gdbarch (gdbarch), regcache (regcache), obfd (obfd),\n+      note_data (note_data), note_size (note_size), lwp (lwp),\n+      stop_signal (stop_signal)\n+  {}\n+\n+  struct gdbarch *gdbarch;\n+  const struct regcache *regcache;\n+  bfd *obfd;\n+  gdb::unique_xmalloc_ptr<char> &note_data;\n+  int *note_size;\n+  unsigned long lwp;\n+  enum gdb_signal stop_signal;\n+  bool abort_iteration = false;\n+};\n+\n+/* Callback for iterate_over_regset_sections that records a single\n+   regset in the corefile note section.  */\n+\n+static void\n+linux_collect_regset_section_cb (const char *sect_name, int supply_size,\n+\t\t\t\t int collect_size, const struct regset *regset,\n+\t\t\t\t const char *human_name, void *cb_data)\n+{\n+  struct linux_collect_regset_section_cb_data *data\n+    = (struct linux_collect_regset_section_cb_data *) cb_data;\n+  bool variable_size_section = (regset != NULL\n+\t\t\t\t&& regset->flags & REGSET_VARIABLE_SIZE);\n+\n+  if (!variable_size_section)\n+    gdb_assert (supply_size == collect_size);\n+\n+  if (data->abort_iteration)\n+    return;\n+\n+  gdb_assert (regset && regset->collect_regset);\n+\n+  /* This is intentionally zero-initialized by using std::vector, so\n+     that any padding bytes in the core file will show as 0.  */\n+  std::vector<gdb_byte> buf (collect_size);\n+\n+  regset->collect_regset (regset, data->regcache, -1, buf.data (),\n+\t\t\t  collect_size);\n+\n+  /* PRSTATUS still needs to be treated specially.  */\n+  if (strcmp (sect_name, \".reg\") == 0)\n+    data->note_data.reset (elfcore_write_prstatus\n+\t\t\t     (data->obfd, data->note_data.release (),\n+\t\t\t      data->note_size, data->lwp,\n+\t\t\t      gdb_signal_to_host (data->stop_signal),\n+\t\t\t      buf.data ()));\n+  else\n+    data->note_data.reset (elfcore_write_register_note\n+\t\t\t   (data->obfd, data->note_data.release (),\n+\t\t\t    data->note_size, sect_name, buf.data (),\n+\t\t\t    collect_size));\n+\n+  if (data->note_data == NULL)\n+    data->abort_iteration = true;\n+}\n+\n+/* Records the thread's register state for the corefile note\n+   section.  */\n+\n+static void\n+linux_collect_thread_registers (const struct regcache *regcache,\n+\t\t\t\tptid_t ptid, bfd *obfd,\n+\t\t\t\tgdb::unique_xmalloc_ptr<char> &note_data,\n+\t\t\t\tint *note_size,\n+\t\t\t\tenum gdb_signal stop_signal)\n+{\n+  struct gdbarch *gdbarch = regcache->arch ();\n+\n+  /* For remote targets the LWP may not be available, so use the TID.  */\n+  long lwp = ptid.lwp ();\n+  if (lwp == 0)\n+    lwp = ptid.tid ();\n+\n+  linux_collect_regset_section_cb_data data (gdbarch, regcache, obfd, note_data,\n+\t\t\t\t\t     note_size, lwp, stop_signal);\n+\n+  gdbarch_iterate_over_regset_sections (gdbarch,\n+\t\t\t\t\tlinux_collect_regset_section_cb,\n+\t\t\t\t\t&data, regcache);\n+}\n+\n /* Fetch the siginfo data for the specified thread, if it exists.  If\n    there is no data, or we could not read it, return an empty\n    buffer.  */\n@@ -1649,16 +1746,22 @@ static void\n linux_corefile_thread (struct thread_info *info,\n \t\t       struct linux_corefile_thread_data *args)\n {\n-  gcore_build_thread_register_notes (args->gdbarch, info, args->stop_signal,\n-\t\t\t\t     args->obfd, &args->note_data,\n-\t\t\t\t     args->note_size);\n+  struct regcache *regcache;\n+\n+  regcache = get_thread_arch_regcache (info->inf->process_target (),\n+\t\t\t\t       info->ptid, args->gdbarch);\n+\n+  target_fetch_registers (regcache, -1);\n+  gdb::byte_vector siginfo_data = linux_get_siginfo_data (info, args->gdbarch);\n+\n+  linux_collect_thread_registers (regcache, info->ptid, args->obfd,\n+\t\t\t\t  args->note_data, args->note_size,\n+\t\t\t\t  args->stop_signal);\n \n   /* Don't return anything if we got no register information above,\n      such a core file is useless.  */\n   if (args->note_data != NULL)\n     {\n-      gdb::byte_vector siginfo_data\n-\t= linux_get_siginfo_data (info, args->gdbarch);\n       if (!siginfo_data.empty ())\n \targs->note_data.reset (elfcore_write_note (args->obfd,\n \t\t\t\t\t\t   args->note_data.release (),\n@@ -1857,6 +1960,30 @@ linux_fill_prpsinfo (struct elf_internal_linux_prpsinfo *p)\n   return 1;\n }\n \n+/* Find the signalled thread.  In case there's more than one signalled\n+   thread, prefer the current thread, if it is signalled.  If no\n+   thread was signalled, default to the current thread, unless it has\n+   exited, in which case return NULL.  */\n+\n+static thread_info *\n+find_signalled_thread ()\n+{\n+  thread_info *curr_thr = inferior_thread ();\n+  if (curr_thr->state != THREAD_EXITED\n+      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+    return curr_thr;\n+\n+  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n+    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n+      return thr;\n+\n+  /* Default to the current thread, unless it has exited.  */\n+  if (curr_thr->state != THREAD_EXITED)\n+    return curr_thr;\n+\n+  return nullptr;\n+}\n+\n /* Build the note section for a corefile, and return it in a malloc\n    buffer.  */\n \n@@ -1894,7 +2021,7 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n   /* Like the kernel, prefer dumping the signalled thread first.\n      \"First thread\" is what tools use to infer the signalled\n      thread.  */\n-  thread_info *signalled_thr = gcore_find_signalled_thread ();\n+  thread_info *signalled_thr = find_signalled_thread ();\n   gdb_signal stop_signal;\n   if (signalled_thr != nullptr)\n     stop_signal = signalled_thr->suspend.stop_signal;"
    }
  ]
}