{
  "sha": "b7874836c331d13e5478c775477b12abf7c481a0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yjc4NzQ4MzZjMzMxZDEzZTU0NzhjNzc1NDc3YjEyYWJmN2M0ODFhMA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-12-18T11:59:54Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-12-24T16:45:40Z"
    },
    "message": "gdb: avoid resolving dynamic properties for non-allocated arrays\n\nIn PR gdb/27059 an issue was discovered where GDB would sometimes\ntrigger undefined behaviour in the form of signed integer overflow.\nThe problem here is that GDB was reading random garbage from the\ninferior memory space, assuming this data was valid, and performing\narithmetic on it.\n\nThis bug raises an interesting general problem with GDB's DWARF\nexpression evaluator, which is this:\n\nWe currently assume that the DWARF expressions being evaluated are\nwell formed, and well behaving.  As an example, this is the expression\nthat the bug was running into problems on, this was used as the\nexpression for a DW_AT_byte_stride of a DW_TAG_subrange_type:\n\n\tDW_OP_push_object_address;\n\tDW_OP_plus_uconst: 88;\n\tDW_OP_deref;\n\tDW_OP_push_object_address;\n\tDW_OP_plus_uconst: 32;\n\tDW_OP_deref;\n\tDW_OP_mul\n\nTwo values are read from the inferior and multiplied together.  GDB\nshould not assume that any value read from the inferior is in any way\nsane, as such the implementation of DW_OP_mul should be guarding\nagainst overflow and doing something semi-sane here.\n\nHowever, it turns out that the original bug PR gdb/27059, is hitting a\nmore specific case, which doesn't require changes to the DWARF\nexpression evaluator, so I'm going to leave the above issue for\nanother day.\n\nIn the test mentioned in the bug GDB is actually trying to resolve the\ndynamic type of a Fortran array that is NOT allocated.  A\nnon-allocated Fortran array is one that does not have any data\nallocated for it yet, and even the upper and lower bounds of the array\nare not yet known.\n\nIt turns out that, at least for gfortran compiled code, the data\nfields that describe the byte-stride are not initialised until the\narray is allocated.\n\nThis leads me to the following conclusion: GDB should not try to\nresolve the bounds, or stride information for an array that is not\nallocated (or not associated, a similar, but slightly different\nFortran feature).  Instead, each of these properties should be set to\nundefined if the array is not allocated (or associated).\n\nThat is what this commit does.  There's a new flag that is passed\naround during the dynamic array resolution.  When this flag is true\nthe dynamic properties are resolved using the DWARF expressions as\nthey currently are, but when this flag is false the expressions are\nnot evaluated, and instead the properties are set to undefined.\n\ngdb/ChangeLog:\n\n\tPR gdb/27059\n\t* eval.c (evaluate_subexp_for_sizeof): Handle not allocated and\n\tnot associated arrays.\n\t* f-lang.c (fortran_adjust_dynamic_array_base_address_hack): Don't\n\tadjust arrays that are not allocated/associated.\n\t* gdbtypes.c (resolve_dynamic_range): Update header comment.  Add\n\tnew parameter which is used to sometimes set dynamic properties to\n\tundefined.\n\t(resolve_dynamic_array_or_string): Update header comment.  Add new\n\tparameter which is used to guard evaluating dynamic properties.\n\tResolve allocated/associated properties first.\n\ngdb/testsuite/ChangeLog:\n\n\tPR gdb/27059\n\t* gdb.dwarf2/dyn-type-unallocated.c: New file.\n\t* gdb.dwarf2/dyn-type-unallocated.exp: New file.",
    "tree": {
      "sha": "c2bd2f017919f0f581d7dc16facbb558a75241d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c2bd2f017919f0f581d7dc16facbb558a75241d0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b7874836c331d13e5478c775477b12abf7c481a0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b7874836c331d13e5478c775477b12abf7c481a0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b7874836c331d13e5478c775477b12abf7c481a0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b7874836c331d13e5478c775477b12abf7c481a0/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5ba3b20ec23816e07ecc5ce58bc7585f371e2f8c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ba3b20ec23816e07ecc5ce58bc7585f371e2f8c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5ba3b20ec23816e07ecc5ce58bc7585f371e2f8c"
    }
  ],
  "stats": {
    "total": 264,
    "additions": 240,
    "deletions": 24
  },
  "files": [
    {
      "sha": "649652ec6025a1e9c15d2527e68e235167a4aa35",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -1,3 +1,17 @@\n+2020-12-24  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\tPR gdb/27059\n+\t* eval.c (evaluate_subexp_for_sizeof): Handle not allocated and\n+\tnot associated arrays.\n+\t* f-lang.c (fortran_adjust_dynamic_array_base_address_hack): Don't\n+\tadjust arrays that are not allocated/associated.\n+\t* gdbtypes.c (resolve_dynamic_range): Update header comment.  Add\n+\tnew parameter which is used to sometimes set dynamic properties to\n+\tundefined.\n+\t(resolve_dynamic_array_or_string): Update header comment.  Add new\n+\tparameter which is used to guard evaluating dynamic properties.\n+\tResolve allocated/associated properties first.\n+\n 2020-12-24  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdbtypes (recursive_dump_type): Include allocated and associated"
    },
    {
      "sha": "dadadbb83537783fcb4ce21362e4ba702d055174",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -2961,10 +2961,14 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n \t{\n \t  val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n \t  type = value_type (val);\n-\t  if (type->code () == TYPE_CODE_ARRAY\n-\t      && is_dynamic_type (type->index_type ())\n-\t      && type->bounds ()->high.kind () == PROP_UNDEFINED)\n-\t    return allocate_optimized_out_value (size_type);\n+\t  if (type->code () == TYPE_CODE_ARRAY)\n+\t    {\n+\t      if (type_not_allocated (type) || type_not_associated (type))\n+\t\treturn value_zero (size_type, not_lval);\n+\t      else if (is_dynamic_type (type->index_type ())\n+\t\t       && type->bounds ()->high.kind () == PROP_UNDEFINED)\n+\t\treturn allocate_optimized_out_value (size_type);\n+\t    }\n \t}\n       else\n \t(*pos) += 4;"
    },
    {
      "sha": "e06bbb42956c3ae9619a11eaff45a5989e694922",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -1391,6 +1391,10 @@ fortran_adjust_dynamic_array_base_address_hack (struct type *type,\n {\n   gdb_assert (type->code () == TYPE_CODE_ARRAY);\n \n+  /* We can't adjust the base address for arrays that have no content.  */\n+  if (type_not_allocated (type) || type_not_associated (type))\n+    return address;\n+\n   int ndimensions = calc_f77_array_dims (type);\n   LONGEST total_offset = 0;\n "
    },
    {
      "sha": "e84aeb056edca8eb13b09d8723f341557a1f89dd",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 49,
      "deletions": 20,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -2177,11 +2177,20 @@ static struct type *resolve_dynamic_type_internal\n \n /* Given a dynamic range type (dyn_range_type) and a stack of\n    struct property_addr_info elements, return a static version\n-   of that type.  */\n+   of that type.\n+\n+   When RESOLVE_P is true then the returned static range is created by\n+   actually evaluating any dynamic properties within the range type, while\n+   when RESOLVE_P is false the returned static range has all of the bounds\n+   and stride information set to undefined.  The RESOLVE_P set to false\n+   case will be used when evaluating a dynamic array that is not\n+   allocated, or not associated, i.e. the bounds information might not be\n+   initialized yet.  */\n \n static struct type *\n resolve_dynamic_range (struct type *dyn_range_type,\n-\t\t       struct property_addr_info *addr_stack)\n+\t\t       struct property_addr_info *addr_stack,\n+\t\t       bool resolve_p = true)\n {\n   CORE_ADDR value;\n   struct type *static_range_type, *static_target_type;\n@@ -2190,13 +2199,13 @@ resolve_dynamic_range (struct type *dyn_range_type,\n   gdb_assert (dyn_range_type->code () == TYPE_CODE_RANGE);\n \n   const struct dynamic_prop *prop = &dyn_range_type->bounds ()->low;\n-  if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+  if (resolve_p && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     low_bound.set_const_val (value);\n   else\n     low_bound.set_undefined ();\n \n   prop = &dyn_range_type->bounds ()->high;\n-  if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+  if (resolve_p && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     {\n       high_bound.set_const_val (value);\n \n@@ -2209,7 +2218,7 @@ resolve_dynamic_range (struct type *dyn_range_type,\n \n   bool byte_stride_p = dyn_range_type->bounds ()->flag_is_byte_stride;\n   prop = &dyn_range_type->bounds ()->stride;\n-  if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+  if (resolve_p && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n     {\n       stride.set_const_val (value);\n \n@@ -2242,11 +2251,16 @@ resolve_dynamic_range (struct type *dyn_range_type,\n \n /* Resolves dynamic bound values of an array or string type TYPE to static\n    ones.  ADDR_STACK is a stack of struct property_addr_info to be used if\n-   needed during the dynamic resolution.  */\n+   needed during the dynamic resolution.\n+\n+   When RESOLVE_P is true then the dynamic properties of TYPE are\n+   evaluated, otherwise the dynamic properties of TYPE are not evaluated,\n+   instead we assume the array is not allocated/associated yet.  */\n \n static struct type *\n resolve_dynamic_array_or_string (struct type *type,\n-\t\t\t\t struct property_addr_info *addr_stack)\n+\t\t\t\t struct property_addr_info *addr_stack,\n+\t\t\t\t bool resolve_p = true)\n {\n   CORE_ADDR value;\n   struct type *elt_type;\n@@ -2262,29 +2276,44 @@ resolve_dynamic_array_or_string (struct type *type,\n \n   type = copy_type (type);\n \n-  elt_type = type;\n-  range_type = check_typedef (elt_type->index_type ());\n-  range_type = resolve_dynamic_range (range_type, addr_stack);\n-\n-  /* Resolve allocated/associated here before creating a new array type, which\n-     will update the length of the array accordingly.  */\n+  /* Resolve the allocated and associated properties before doing anything\n+     else.  If an array is not allocated or not associated then (at least\n+     for Fortran) there is no guarantee that the data to define the upper\n+     bound, lower bound, or stride will be correct.  If RESOLVE_P is\n+     already false at this point then this is not the first dimension of\n+     the array and a more outer dimension has already marked this array as\n+     not allocated/associated, as such we just ignore this property.  This\n+     is fine as GDB only checks the allocated/associated on the outer most\n+     dimension of the array.  */\n   prop = TYPE_ALLOCATED_PROP (type);\n-  if (prop != NULL && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    prop->set_const_val (value);\n+  if (prop != NULL && resolve_p\n+      && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+    {\n+      prop->set_const_val (value);\n+      if (value == 0)\n+\tresolve_p = false;\n+    }\n \n   prop = TYPE_ASSOCIATED_PROP (type);\n-  if (prop != NULL && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n-    prop->set_const_val (value);\n+  if (prop != NULL && resolve_p\n+      && dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+    {\n+      prop->set_const_val (value);\n+      if (value == 0)\n+\tresolve_p = false;\n+    }\n \n-  ary_dim = check_typedef (TYPE_TARGET_TYPE (elt_type));\n+  range_type = check_typedef (type->index_type ());\n+  range_type = resolve_dynamic_range (range_type, addr_stack, resolve_p);\n \n+  ary_dim = check_typedef (TYPE_TARGET_TYPE (type));\n   if (ary_dim != NULL && ary_dim->code () == TYPE_CODE_ARRAY)\n-    elt_type = resolve_dynamic_array_or_string (ary_dim, addr_stack);\n+    elt_type = resolve_dynamic_array_or_string (ary_dim, addr_stack, resolve_p);\n   else\n     elt_type = TYPE_TARGET_TYPE (type);\n \n   prop = type->dyn_prop (DYN_PROP_BYTE_STRIDE);\n-  if (prop != NULL)\n+  if (prop != NULL && resolve_p)\n     {\n       if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n \t{"
    },
    {
      "sha": "205355383831ffd91d1bbe03d004bc1285c01dd8",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -1,3 +1,9 @@\n+2020-12-24  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\tPR gdb/27059\n+\t* gdb.dwarf2/dyn-type-unallocated.c: New file.\n+\t* gdb.dwarf2/dyn-type-unallocated.exp: New file.\n+\n 2020-12-21  Peter Waller  <p@pwaller.net>\n \n \t* gdb.base/style-interp-exec-mi.exp: New."
    },
    {
      "sha": "453c54d626bd337973159d460eb8eeb597768c6e",
      "filename": "gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.c",
      "status": "added",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.c?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -0,0 +1,40 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"../lib/attributes.h\"\n+\n+/* Our fake dynamic object.  */\n+void *dyn_object;\n+\n+void __attribute__((noinline)) ATTRIBUTE_NOCLONE\n+marker ()\n+{ /* Nothing.  */ }\n+\n+int\n+main ()\n+{\n+  asm (\"main_label: .globl main_label\");\n+\n+  /* Initialise the dynamic object.  */\n+  dyn_object = 0;\n+\n+  asm (\"marker_label: .globl marker_label\");\n+  marker ();\t/* Break here.  */\n+\n+  return 0;\n+}\n+"
    },
    {
      "sha": "37bc06bda7f7f1da428fede93afe16085437f89d",
      "filename": "gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.exp",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b7874836c331d13e5478c775477b12abf7c481a0/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dyn-type-unallocated.exp?ref=b7874836c331d13e5478c775477b12abf7c481a0",
      "patch": "@@ -0,0 +1,119 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test for issue PR gdb/27059.  The problem was that when resolving a\n+# dynamic type that was not-allocated GDB would still try to execute\n+# the DWARF expressions for the upper, lower, and byte-stride values.\n+#\n+# The problem is that, at least in some gfortran compiled programs,\n+# these values are undefined until the array is allocated.\n+#\n+# As a result, executing the dwarf expressions was triggering integer\n+# overflow in some cases.\n+#\n+# This test aims to make the sometimes occurring integer overflow a\n+# more noticeable error by creating an array that is always marked as\n+# not-allocated.\n+#\n+# The dwarf expressions for the various attributes then contains an\n+# infinite loop.  If GDB ever tries to execute these expressions we\n+# will get a test timeout.  With this issue fixed the expressions are\n+# never executed and the test completes as we'd expect.\n+\n+load_lib dwarf.exp\n+\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+standard_testfile .c -dw.S\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n+    return -1\n+}\n+\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    cu {} {\n+\tglobal srcfile\n+\n+\tcompile_unit {\n+\t    {producer \"gcc\" }\n+            {language @DW_LANG_Fortran90}\n+            {name ${srcfile}}\n+            {low_pc 0 addr}\n+        } {\n+\t    declare_labels array_type_label integer_type_label\n+\n+\t    set int_size [get_sizeof \"int\" \"UNKNOWN\"]\n+\t    set voidp_size [get_sizeof \"void *\" \"UNKNOWN\"]\n+\n+            integer_type_label: DW_TAG_base_type {\n+                {DW_AT_byte_size $int_size DW_FORM_sdata}\n+                {DW_AT_encoding  @DW_ATE_signed}\n+                {DW_AT_name      integer}\n+            }\n+\n+\t    array_type_label: DW_TAG_array_type {\n+\t\t{DW_AT_type :$integer_type_label}\n+\t\t{DW_AT_data_location {\n+\t\t    DW_OP_push_object_address\n+\t\t    DW_OP_deref\n+\t\t} SPECIAL_expr}\n+\t\t{DW_AT_allocated {\n+\t\t    DW_OP_lit0\n+\t\t} SPECIAL_expr}\n+\t    } {\n+\t\tDW_TAG_subrange_type {\n+\t\t    {DW_AT_type        :$integer_type_label}\n+\t\t    {DW_AT_lower_bound {\n+\t\t\tDW_OP_skip -3\n+\t\t    } SPECIAL_expr}\n+\t\t    {DW_AT_upper_bound {\n+\t\t\tDW_OP_skip -3\n+\t\t    } SPECIAL_expr}\n+\t\t    {DW_AT_byte_stride {\n+\t\t\tDW_OP_skip -3\n+\t\t    } SPECIAL_expr}\n+\t\t}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+                {DW_AT_location {\n+                    DW_OP_addr [gdb_target_symbol dyn_object]\n+                } SPECIAL_expr}\n+\t\t{name \"dyn_object\"}\n+\t\t{type :$array_type_label}\n+\t    }\n+            subprogram {\n+                {external 1 flag}\n+                {MACRO_AT_func {main}}\n+            }\n+        }\n+    }\n+}\n+\n+if { [prepare_for_testing \"failed to prepare\" \"${testfile}\" \\\n+\t  [list $srcfile $asm_file] {nodebug}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    return -1\n+}\n+\n+gdb_breakpoint \"marker_label\"\n+gdb_continue_to_breakpoint \"stop at marker_label\"\n+gdb_test \"ptype dyn_object\" \"type = integer, allocatable \\\\(:\\\\)\""
    }
  ]
}