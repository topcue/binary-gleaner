{
  "sha": "2fdb65f247379befd548a33ea185172968b9ebb9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmZkYjY1ZjI0NzM3OWJlZmQ1NDhhMzNlYTE4NTE3Mjk2OGI5ZWJiOQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-06-01T04:51:50Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-06-01T14:03:28Z"
    },
    "message": "alpha-vms: ETIR checks\n\nBetter validity checks, and remove a fuzzer vulnerability of sorts that\ntargeted the store-immediate-repeat command with a zero length but\nvery large repeat counts to chew cpu.\n\n\t* vms-alpha.c (_bfd_vms_slurp_etir): Check bound for the current\n\tcommand against cmd_length, not the end of record.  For\n\tETIR__C_STO_IMMR check size against cmd_length, mask repeat count\n\tto 32-bits and break out on zero size.  Add ETIR__C_STC_LP_PSB\n\tcmd_length test.",
    "tree": {
      "sha": "adc90cec8f4d5c1b596aa7551852f73003f88ec8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/adc90cec8f4d5c1b596aa7551852f73003f88ec8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2fdb65f247379befd548a33ea185172968b9ebb9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2fdb65f247379befd548a33ea185172968b9ebb9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2fdb65f247379befd548a33ea185172968b9ebb9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2fdb65f247379befd548a33ea185172968b9ebb9/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3c3d03769e4d6fea4c8ee97bf36a2ca7d572461c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c3d03769e4d6fea4c8ee97bf36a2ca7d572461c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3c3d03769e4d6fea4c8ee97bf36a2ca7d572461c"
    }
  ],
  "stats": {
    "total": 42,
    "additions": 29,
    "deletions": 13
  },
  "files": [
    {
      "sha": "d4d4c4565b06ab4ca964b30196088c6582184c36",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2fdb65f247379befd548a33ea185172968b9ebb9/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2fdb65f247379befd548a33ea185172968b9ebb9/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=2fdb65f247379befd548a33ea185172968b9ebb9",
      "patch": "@@ -1,3 +1,11 @@\n+2020-06-01  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-alpha.c (_bfd_vms_slurp_etir): Check bound for the current\n+\tcommand against cmd_length, not the end of record.  For\n+\tETIR__C_STO_IMMR check size against cmd_length, mask repeat count\n+\tto 32-bits and break out on zero size.  Add ETIR__C_STC_LP_PSB\n+\tcmd_length test.\n+\n 2020-05-28  David Faust  <david.faust@oracle.com>\n \n \t* elf64-bpf.c (bpf_elf_relocate_section): Fix handling of"
    },
    {
      "sha": "e31a9e4ca10bca344dab67ea208b0784ffb85458",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 21,
      "deletions": 13,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2fdb65f247379befd548a33ea185172968b9ebb9/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2fdb65f247379befd548a33ea185172968b9ebb9/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=2fdb65f247379befd548a33ea185172968b9ebb9",
      "patch": "@@ -1925,11 +1925,12 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  return FALSE;\n \t}\n       ptr += 4;\n+      cmd_length -= 4;\n \n #if VMS_DEBUG\n       _bfd_vms_debug (4, \"etir: %s(%d)\\n\",\n \t\t      _bfd_vms_etir_name (cmd), cmd);\n-      _bfd_hexdump (8, ptr, cmd_length - 4, 0);\n+      _bfd_hexdump (8, ptr, cmd_length, 0);\n #endif\n \n       switch (cmd)\n@@ -1939,7 +1940,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n \t     stack 32 bit value of symbol (high bits set to 0).  */\n \tcase ETIR__C_STA_GBL:\n-\t  _bfd_vms_get_value (abfd, ptr, maxptr, info, &op1, &h);\n+\t  _bfd_vms_get_value (abfd, ptr, ptr + cmd_length, info, &op1, &h);\n \t  if (!_bfd_vms_push (abfd, op1, alpha_vms_sym_to_ctxt (h)))\n \t    return FALSE;\n \t  break;\n@@ -1949,7 +1950,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n \t     stack 32 bit value, sign extend to 64 bit.  */\n \tcase ETIR__C_STA_LW:\n-\t  if (ptr + 4 > maxptr)\n+\t  if (cmd_length < 4)\n \t    goto corrupt_etir;\n \t  if (!_bfd_vms_push (abfd, bfd_getl32 (ptr), RELC_NONE))\n \t    return FALSE;\n@@ -1960,7 +1961,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \n \t     stack 64 bit value of symbol.  */\n \tcase ETIR__C_STA_QW:\n-\t  if (ptr + 8 > maxptr)\n+\t  if (cmd_length < 8)\n \t    goto corrupt_etir;\n \t  if (!_bfd_vms_push (abfd, bfd_getl64 (ptr), RELC_NONE))\n \t    return FALSE;\n@@ -1976,7 +1977,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    int psect;\n \n-\t    if (ptr + 12 > maxptr)\n+\t    if (cmd_length < 12)\n \t      goto corrupt_etir;\n \t    psect = bfd_getl32 (ptr);\n \t    if ((unsigned int) psect >= PRIV (section_count))\n@@ -2079,13 +2080,18 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    int size;\n \n-\t    if (ptr + 4 > maxptr)\n+\t    if (cmd_length < 4)\n \t      goto corrupt_etir;\n \t    size = bfd_getl32 (ptr);\n+\t    if (size > cmd_length - 4)\n+\t      goto corrupt_etir;\n \t    if (!_bfd_vms_pop (abfd, &op1, &rel1))\n \t      return FALSE;\n \t    if (rel1 != RELC_NONE)\n \t      goto bad_context;\n+\t    if (size == 0)\n+\t      break;\n+\t    op1 &= 0xffffffff;\n \t    while (op1-- > 0)\n \t      if (!image_write (abfd, ptr + 4, size))\n \t\treturn FALSE;\n@@ -2095,7 +2101,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store global: write symbol value\n \t     arg: cs\tglobal symbol name.  */\n \tcase ETIR__C_STO_GBL:\n-\t  _bfd_vms_get_value (abfd, ptr, maxptr, info, &op1, &h);\n+\t  _bfd_vms_get_value (abfd, ptr, ptr + cmd_length, info, &op1, &h);\n \t  if (h && h->sym)\n \t    {\n \t      if (h->sym->typ == EGSD__C_SYMG)\n@@ -2120,7 +2126,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Store code address: write address of entry point\n \t     arg: cs\tglobal symbol name (procedure).  */\n \tcase ETIR__C_STO_CA:\n-\t  _bfd_vms_get_value (abfd, ptr, maxptr, info, &op1, &h);\n+\t  _bfd_vms_get_value (abfd, ptr, ptr + cmd_length, info, &op1, &h);\n \t  if (h && h->sym)\n \t    {\n \t      if (h->sym->flags & EGSY__V_NORM)\n@@ -2172,7 +2178,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  {\n \t    unsigned int size;\n \n-\t    if (ptr + 4 > maxptr)\n+\t    if (cmd_length < 4)\n \t      goto corrupt_etir;\n \t    size = bfd_getl32 (ptr);\n \t    if (!image_write (abfd, ptr + 4, size))\n@@ -2187,7 +2193,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t     store global longword: store 32bit value of symbol\n \t     arg: cs\tsymbol name.  */\n \tcase ETIR__C_STO_GBL_LW:\n-\t  _bfd_vms_get_value (abfd, ptr, maxptr, info, &op1, &h);\n+\t  _bfd_vms_get_value (abfd, ptr, ptr + cmd_length, info, &op1, &h);\n #if 0\n \t  abort ();\n #endif\n@@ -2241,7 +2247,9 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t     da\tsignature.  */\n \n \tcase ETIR__C_STC_LP_PSB:\n-\t  _bfd_vms_get_value (abfd, ptr + 4, maxptr, info, &op1, &h);\n+\t  if (cmd_length < 4)\n+\t    goto corrupt_etir;\n+\t  _bfd_vms_get_value (abfd, ptr + 4, ptr + cmd_length, info, &op1, &h);\n \t  if (h && h->sym)\n \t    {\n \t      if (h->sym->typ == EGSD__C_SYMG)\n@@ -2340,7 +2348,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  /* Augment relocation base: increment image location counter by offset\n \t     arg: lw\toffset value.  */\n \tcase ETIR__C_CTL_AUGRB:\n-\t  if (ptr + 4 > maxptr)\n+\t  if (cmd_length < 4)\n \t    goto corrupt_etir;\n \t  op1 = bfd_getl32 (ptr);\n \t  image_inc_ptr (abfd, op1);\n@@ -2554,7 +2562,7 @@ _bfd_vms_slurp_etir (bfd *abfd, struct bfd_link_info *info)\n \t  break;\n \t}\n \n-      ptr += cmd_length - 4;\n+      ptr += cmd_length;\n     }\n \n   return TRUE;"
    }
  ]
}