{
  "sha": "9f63756509bc44663c9d15c7b9578cedb406e356",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWY2Mzc1NjUwOWJjNDQ2NjNjOWQxNWM3Yjk1NzhjZWRiNDA2ZTM1Ng==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-08-27T14:38:53Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-08-27T14:38:53Z"
    },
    "message": "[gdb/testsuite] Support .debug_aranges in dwarf assembly\n\nAdd a proc aranges such that we can generate .debug_aranges sections in dwarf\nassembly using:\n...\n  cu { label cu_label } {\n  ...\n  }\n\n  aranges {} cu_label {\n    arange $addr $len [<comment>] [$segment_selector]\n  }\n...\n\nTested on x86_64-linux.",
    "tree": {
      "sha": "199592beaf3d6a5286a23386410151169ebe7e11",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/199592beaf3d6a5286a23386410151169ebe7e11"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9f63756509bc44663c9d15c7b9578cedb406e356",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f63756509bc44663c9d15c7b9578cedb406e356",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9f63756509bc44663c9d15c7b9578cedb406e356",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f63756509bc44663c9d15c7b9578cedb406e356/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "698c974ffc97f845f65d2e93d31bdbb1b24d6caf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/698c974ffc97f845f65d2e93d31bdbb1b24d6caf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/698c974ffc97f845f65d2e93d31bdbb1b24d6caf"
    }
  ],
  "stats": {
    "total": 153,
    "additions": 153,
    "deletions": 0
  },
  "files": [
    {
      "sha": "a058a78df2eb1bc3fe6af962d907f2139e7d1253",
      "filename": "gdb/testsuite/lib/dwarf.exp",
      "status": "modified",
      "additions": 153,
      "deletions": 0,
      "changes": 153,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9f63756509bc44663c9d15c7b9578cedb406e356/gdb/testsuite/lib/dwarf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9f63756509bc44663c9d15c7b9578cedb406e356/gdb/testsuite/lib/dwarf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/dwarf.exp?ref=9f63756509bc44663c9d15c7b9578cedb406e356",
      "patch": "@@ -2210,6 +2210,159 @@ namespace eval Dwarf {\n \tdefine_label $unit_end_label\n     }\n \n+    # Emit a DWARF .debug_aranges entry.\n+\n+    proc arange { arange_start arange_length {comment \"\"} {seg_sel \"\"} } {\n+\tif { $comment != \"\" } {\n+\t    # Wrap\n+\t    set comment \" ($comment)\"\n+\t}\n+\n+\tif { $seg_sel != \"\" } {\n+\t    variable _seg_size\n+\t    if { $_seg_size == 8 } {\n+\t\tset seg_op .8byte\n+\t    } elseif { $_seg_size == 4 } {\n+\t\tset seg_op .4byte\n+\t    } else {\n+\t\terror \\\n+\t\t    \"Don't know how to handle segment selector size $_seg_size\"\n+\t    }\n+\t    _op $seg_op $seg_sel \"Address range segment selector$comment\"\n+\t}\n+\n+\tvariable _addr_size\n+\tif { $_addr_size == 8 } {\n+\t    set addr_op .8byte\n+\t} elseif { $_addr_size == 4 } {\n+\t    set addr_op .4byte\n+\t}\n+\n+\t_op $addr_op $arange_start \"Address range start$comment\"\n+\t_op $addr_op $arange_length \"Address range length$comment\"\n+    }\n+\n+    # Emit a DWARF .debug_aranges unit.\n+    #\n+    # OPTIONS is a list with an even number of elements containing\n+    # option-name and option-value pairs.\n+    # Current options are:\n+    # is_64 0|1    - boolean indicating if you want to emit 64-bit DWARF\n+    #                default = 0 (32-bit)\n+    # cu_is_64 0|1 - boolean indicating if LABEL refers to a 64-bit DWARF CU\n+    #                default = 0 (32-bit)\n+    # section_version n\n+    #                - section version number to emit\n+    #                default = 2\n+    # seg_size n   - the size of the adress selector in bytes: 0, 4, or 8\n+    #                default = 0\n+    #\n+    # LABEL is the label of the corresponding CU.\n+    #\n+    # BODY is Tcl code that emits the parts which make up the body of\n+    # the aranges unit.  It is evaluated in the caller's context.  The\n+    # following commands are available for the BODY section:\n+    #\n+    #   arange [-c <comment>] [<segment selector>] <start> <length>\n+    #     -- adds an address range.\n+\n+    proc aranges { options label body } {\n+\tvariable _addr_size\n+\tvariable _seg_size\n+\n+\t# Establish the defaults.\n+\tset is_64 0\n+\tset cu_is_64 0\n+\tset section_version 2\n+\tset _seg_size 0\n+\n+\t# Handle options.\n+\tforeach { name value } $options {\n+\t    switch -exact -- $name {\n+\t\tis_64 { set is_64 $value }\n+\t\tcu_is_64 { set cu_is_64 $value }\n+\t\tsection_version {set section_version $value }\n+\t\tseg_size { set _seg_size $value }\n+\t\tdefault { error \"unknown option $name\" }\n+\t    }\n+\t}\n+\n+\tif { [is_64_target] } {\n+\t    set _addr_size 8\n+\t} else {\n+\t    set _addr_size 4\n+\t}\n+\n+\t# Switch to .debug_aranges section.\n+\t_section .debug_aranges\n+\n+\t# Keep track of offset from start of section entry to determine\n+\t# padding amount.\n+\tset offset 0\n+\n+\t# Initial length.\n+\tdeclare_labels aranges_start aranges_end\n+\tset length \"$aranges_end - $aranges_start\"\n+\tset comment \"Length\"\n+\tif { $is_64 } {\n+\t    _op .4byte 0xffffffff\n+\t    _op .8byte $length $comment\n+\t    incr offset 12\n+\t} else {\n+\t    _op .4byte $length $comment\n+\t    incr offset 4\n+\t}\n+\n+\t# Start label.\n+\taranges_start:\n+\n+\t# Section version.\n+\t_op .2byte $section_version \"Section version\"\n+\tincr offset 2\n+\n+\t# Offset into .debug_info.\n+\tupvar $label my_label\n+\tif { $cu_is_64 } {\n+\t    _op .8byte $my_label \"Offset into .debug_info\"\n+\t    incr offset 8\n+\t} else {\n+\t    _op .4byte $my_label \"Offset into .debug_info\"\n+\t    incr offset 4\n+\t}\n+\n+\t# Address size.\n+\t_op .byte $_addr_size \"Address size\"\n+\tincr offset\n+\n+\t# Segment selector size.\n+\t_op .byte $_seg_size \"Segment selector size\"\n+\tincr offset\n+\n+\t# Padding.\n+\tset tuple_size [expr 2 * $_addr_size + $_seg_size]\n+\twhile { 1 } {\n+\t    if { [expr $offset % $tuple_size] == 0 } {\n+\t\tbreak\n+\t    }\n+\t    _op .byte 0 \"Pad to $tuple_size byte boundary\"\n+\t    incr offset\n+\t}\n+\n+\t# Range tuples.\n+\tuplevel $body\n+\n+\t# Terminator tuple.\n+\tset comment \"Terminator\"\n+\tif { $_seg_size == 0 } {\n+\t    arange 0 0 $comment\n+\t} else {\n+\t    arange 0 0 $comment 0\n+\t}\n+\n+\t# End label.\n+\taranges_end:\n+    }\n+\n     proc _empty_array {name} {\n \tupvar $name the_array\n "
    }
  ]
}