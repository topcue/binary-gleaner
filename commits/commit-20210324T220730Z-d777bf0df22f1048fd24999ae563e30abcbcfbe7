{
  "sha": "d777bf0df22f1048fd24999ae563e30abcbcfbe7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDc3N2JmMGRmMjJmMTA0OGZkMjQ5OTlhZTU2M2UzMGFiY2JjZmJlNw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-03-24T22:07:30Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-03-24T22:07:30Z"
    },
    "message": "gdb: move all \"current target\" wrapper implementations to target.c\n\nThe following patch removes the current_top_target function, replacing\nuses with `current_inferior ()->top_target ()`.  This is a problem for\nuses in target.h, because they don't have access to the current_inferior\nfunction and the inferior structure: target.h can't include inferior.h,\notherwise that would make a cyclic inclusion.\n\nAvoid this by moving all implementations of the wrappers that call\ntarget methods with the current target to target.c.  Many of them are\nchanged from a macro to a function, which is an improvement for\nreadability and debuggability, IMO.\n\ntarget_shortname and target_longname were not function-like macros, so a\nfew adjustments are needed.\n\ngdb/ChangeLog:\n\n\t* target.h (target_shortname): Change to function declaration.\n\t(target_longname): Likewise.\n\t(target_attach_no_wait): Likewise.\n\t(target_post_attach): Likewise.\n\t(target_prepare_to_store): Likewise.\n\t(target_supports_enable_disable_tracepoint): Likewise.\n\t(target_supports_string_tracing): Likewise.\n\t(target_supports_evaluation_of_breakpoint_conditions): Likewise.\n\t(target_supports_dumpcore): Likewise.\n\t(target_dumpcore): Likewise.\n\t(target_can_run_breakpoint_commands): Likewise.\n\t(target_files_info): Likewise.\n\t(target_post_startup_inferior): Likewise.\n\t(target_insert_fork_catchpoint): Likewise.\n\t(target_remove_fork_catchpoint): Likewise.\n\t(target_insert_vfork_catchpoint): Likewise.\n\t(target_remove_vfork_catchpoint): Likewise.\n\t(target_insert_exec_catchpoint): Likewise.\n\t(target_remove_exec_catchpoint): Likewise.\n\t(target_set_syscall_catchpoint): Likewise.\n\t(target_rcmd): Likewise.\n\t(target_can_lock_scheduler): Likewise.\n\t(target_can_async_p): Likewise.\n\t(target_is_async_p): Likewise.\n\t(target_execution_direction): Likewise.\n\t(target_extra_thread_info): Likewise.\n\t(target_pid_to_exec_file): Likewise.\n\t(target_thread_architecture): Likewise.\n\t(target_find_memory_regions): Likewise.\n\t(target_make_corefile_notes): Likewise.\n\t(target_get_bookmark): Likewise.\n\t(target_goto_bookmark): Likewise.\n\t(target_stopped_by_watchpoint): Likewise.\n\t(target_stopped_by_sw_breakpoint): Likewise.\n\t(target_supports_stopped_by_sw_breakpoint): Likewise.\n\t(target_stopped_by_hw_breakpoint): Likewise.\n\t(target_supports_stopped_by_hw_breakpoint): Likewise.\n\t(target_have_steppable_watchpoint): Likewise.\n\t(target_can_use_hardware_watchpoint): Likewise.\n\t(target_region_ok_for_hw_watchpoint): Likewise.\n\t(target_can_do_single_step): Likewise.\n\t(target_insert_watchpoint): Likewise.\n\t(target_remove_watchpoint): Likewise.\n\t(target_insert_hw_breakpoint): Likewise.\n\t(target_remove_hw_breakpoint): Likewise.\n\t(target_can_accel_watchpoint_condition): Likewise.\n\t(target_can_execute_reverse): Likewise.\n\t(target_get_ada_task_ptid): Likewise.\n\t(target_filesystem_is_local): Likewise.\n\t(target_trace_init): Likewise.\n\t(target_download_tracepoint): Likewise.\n\t(target_can_download_tracepoint): Likewise.\n\t(target_download_trace_state_variable): Likewise.\n\t(target_enable_tracepoint): Likewise.\n\t(target_disable_tracepoint): Likewise.\n\t(target_trace_start): Likewise.\n\t(target_trace_set_readonly_regions): Likewise.\n\t(target_get_trace_status): Likewise.\n\t(target_get_tracepoint_status): Likewise.\n\t(target_trace_stop): Likewise.\n\t(target_trace_find): Likewise.\n\t(target_get_trace_state_variable_value): Likewise.\n\t(target_save_trace_data): Likewise.\n\t(target_upload_tracepoints): Likewise.\n\t(target_upload_trace_state_variables): Likewise.\n\t(target_get_raw_trace_data): Likewise.\n\t(target_get_min_fast_tracepoint_insn_len): Likewise.\n\t(target_set_disconnected_tracing): Likewise.\n\t(target_set_circular_trace_buffer): Likewise.\n\t(target_set_trace_buffer_size): Likewise.\n\t(target_set_trace_notes): Likewise.\n\t(target_get_tib_address): Likewise.\n\t(target_set_permissions): Likewise.\n\t(target_static_tracepoint_marker_at): Likewise.\n\t(target_static_tracepoint_markers_by_strid): Likewise.\n\t(target_traceframe_info): Likewise.\n\t(target_use_agent): Likewise.\n\t(target_can_use_agent): Likewise.\n\t(target_augmented_libraries_svr4_read): Likewise.\n\t(target_log_command): Likewise.\n\t* target.c (target_shortname): New.\n\t(target_longname): New.\n\t(target_attach_no_wait): New.\n\t(target_post_attach): New.\n\t(target_prepare_to_store): New.\n\t(target_supports_enable_disable_tracepoint): New.\n\t(target_supports_string_tracing): New.\n\t(target_supports_evaluation_of_breakpoint_conditions): New.\n\t(target_supports_dumpcore): New.\n\t(target_dumpcore): New.\n\t(target_can_run_breakpoint_commands): New.\n\t(target_files_info): New.\n\t(target_post_startup_inferior): New.\n\t(target_insert_fork_catchpoint): New.\n\t(target_remove_fork_catchpoint): New.\n\t(target_insert_vfork_catchpoint): New.\n\t(target_remove_vfork_catchpoint): New.\n\t(target_insert_exec_catchpoint): New.\n\t(target_remove_exec_catchpoint): New.\n\t(target_set_syscall_catchpoint): New.\n\t(target_rcmd): New.\n\t(target_can_lock_scheduler): New.\n\t(target_can_async_p): New.\n\t(target_is_async_p): New.\n\t(target_execution_direction): New.\n\t(target_extra_thread_info): New.\n\t(target_pid_to_exec_file): New.\n\t(target_thread_architecture): New.\n\t(target_find_memory_regions): New.\n\t(target_make_corefile_notes): New.\n\t(target_get_bookmark): New.\n\t(target_goto_bookmark): New.\n\t(target_stopped_by_watchpoint): New.\n\t(target_stopped_by_sw_breakpoint): New.\n\t(target_supports_stopped_by_sw_breakpoint): New.\n\t(target_stopped_by_hw_breakpoint): New.\n\t(target_supports_stopped_by_hw_breakpoint): New.\n\t(target_have_steppable_watchpoint): New.\n\t(target_can_use_hardware_watchpoint): New.\n\t(target_region_ok_for_hw_watchpoint): New.\n\t(target_can_do_single_step): New.\n\t(target_insert_watchpoint): New.\n\t(target_remove_watchpoint): New.\n\t(target_insert_hw_breakpoint): New.\n\t(target_remove_hw_breakpoint): New.\n\t(target_can_accel_watchpoint_condition): New.\n\t(target_can_execute_reverse): New.\n\t(target_get_ada_task_ptid): New.\n\t(target_filesystem_is_local): New.\n\t(target_trace_init): New.\n\t(target_download_tracepoint): New.\n\t(target_can_download_tracepoint): New.\n\t(target_download_trace_state_variable): New.\n\t(target_enable_tracepoint): New.\n\t(target_disable_tracepoint): New.\n\t(target_trace_start): New.\n\t(target_trace_set_readonly_regions): New.\n\t(target_get_trace_status): New.\n\t(target_get_tracepoint_status): New.\n\t(target_trace_stop): New.\n\t(target_trace_find): New.\n\t(target_get_trace_state_variable_value): New.\n\t(target_save_trace_data): New.\n\t(target_upload_tracepoints): New.\n\t(target_upload_trace_state_variables): New.\n\t(target_get_raw_trace_data): New.\n\t(target_get_min_fast_tracepoint_insn_len): New.\n\t(target_set_disconnected_tracing): New.\n\t(target_set_circular_trace_buffer): New.\n\t(target_set_trace_buffer_size): New.\n\t(target_set_trace_notes): New.\n\t(target_get_tib_address): New.\n\t(target_set_permissions): New.\n\t(target_static_tracepoint_marker_at): New.\n\t(target_static_tracepoint_markers_by_strid): New.\n\t(target_traceframe_info): New.\n\t(target_use_agent): New.\n\t(target_can_use_agent): New.\n\t(target_augmented_libraries_svr4_read): New.\n\t(target_log_command): New.\n\t* bfin-tdep.c (bfin_sw_breakpoint_from_kind): Adjust.\n\t* infrun.c (set_schedlock_func): Adjust.\n\t* mi/mi-main.c (exec_reverse_continue): Adjust.\n\t* reverse.c (exec_reverse_once): Adjust.\n\t* sh-tdep.c (sh_sw_breakpoint_from_kind): Adjust.\n\t* tui/tui-stack.c (tui_locator_window::make_status_line): Adjust.\n\t* remote-sim.c (gdbsim_target::detach): Adjust.\n\t(gdbsim_target::files_info): Adjust.\n\nChange-Id: I72ef56e9a25adeb0b91f1ad05e34c89f77ebeaa8",
    "tree": {
      "sha": "2684c5c36d0be37f3b542e5ae60930e5e4be705a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2684c5c36d0be37f3b542e5ae60930e5e4be705a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d777bf0df22f1048fd24999ae563e30abcbcfbe7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d777bf0df22f1048fd24999ae563e30abcbcfbe7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d777bf0df22f1048fd24999ae563e30abcbcfbe7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d777bf0df22f1048fd24999ae563e30abcbcfbe7/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b64f703b51914e4e335e61492882a8137f75e082",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b64f703b51914e4e335e61492882a8137f75e082",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b64f703b51914e4e335e61492882a8137f75e082"
    }
  ],
  "stats": {
    "total": 1064,
    "additions": 870,
    "deletions": 194
  },
  "files": [
    {
      "sha": "a14592592e4e5203f2cbe3b4907095a1574173c8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 171,
      "deletions": 0,
      "changes": 171,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -1,3 +1,174 @@\n+2021-03-24  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* target.h (target_shortname): Change to function declaration.\n+\t(target_longname): Likewise.\n+\t(target_attach_no_wait): Likewise.\n+\t(target_post_attach): Likewise.\n+\t(target_prepare_to_store): Likewise.\n+\t(target_supports_enable_disable_tracepoint): Likewise.\n+\t(target_supports_string_tracing): Likewise.\n+\t(target_supports_evaluation_of_breakpoint_conditions): Likewise.\n+\t(target_supports_dumpcore): Likewise.\n+\t(target_dumpcore): Likewise.\n+\t(target_can_run_breakpoint_commands): Likewise.\n+\t(target_files_info): Likewise.\n+\t(target_post_startup_inferior): Likewise.\n+\t(target_insert_fork_catchpoint): Likewise.\n+\t(target_remove_fork_catchpoint): Likewise.\n+\t(target_insert_vfork_catchpoint): Likewise.\n+\t(target_remove_vfork_catchpoint): Likewise.\n+\t(target_insert_exec_catchpoint): Likewise.\n+\t(target_remove_exec_catchpoint): Likewise.\n+\t(target_set_syscall_catchpoint): Likewise.\n+\t(target_rcmd): Likewise.\n+\t(target_can_lock_scheduler): Likewise.\n+\t(target_can_async_p): Likewise.\n+\t(target_is_async_p): Likewise.\n+\t(target_execution_direction): Likewise.\n+\t(target_extra_thread_info): Likewise.\n+\t(target_pid_to_exec_file): Likewise.\n+\t(target_thread_architecture): Likewise.\n+\t(target_find_memory_regions): Likewise.\n+\t(target_make_corefile_notes): Likewise.\n+\t(target_get_bookmark): Likewise.\n+\t(target_goto_bookmark): Likewise.\n+\t(target_stopped_by_watchpoint): Likewise.\n+\t(target_stopped_by_sw_breakpoint): Likewise.\n+\t(target_supports_stopped_by_sw_breakpoint): Likewise.\n+\t(target_stopped_by_hw_breakpoint): Likewise.\n+\t(target_supports_stopped_by_hw_breakpoint): Likewise.\n+\t(target_have_steppable_watchpoint): Likewise.\n+\t(target_can_use_hardware_watchpoint): Likewise.\n+\t(target_region_ok_for_hw_watchpoint): Likewise.\n+\t(target_can_do_single_step): Likewise.\n+\t(target_insert_watchpoint): Likewise.\n+\t(target_remove_watchpoint): Likewise.\n+\t(target_insert_hw_breakpoint): Likewise.\n+\t(target_remove_hw_breakpoint): Likewise.\n+\t(target_can_accel_watchpoint_condition): Likewise.\n+\t(target_can_execute_reverse): Likewise.\n+\t(target_get_ada_task_ptid): Likewise.\n+\t(target_filesystem_is_local): Likewise.\n+\t(target_trace_init): Likewise.\n+\t(target_download_tracepoint): Likewise.\n+\t(target_can_download_tracepoint): Likewise.\n+\t(target_download_trace_state_variable): Likewise.\n+\t(target_enable_tracepoint): Likewise.\n+\t(target_disable_tracepoint): Likewise.\n+\t(target_trace_start): Likewise.\n+\t(target_trace_set_readonly_regions): Likewise.\n+\t(target_get_trace_status): Likewise.\n+\t(target_get_tracepoint_status): Likewise.\n+\t(target_trace_stop): Likewise.\n+\t(target_trace_find): Likewise.\n+\t(target_get_trace_state_variable_value): Likewise.\n+\t(target_save_trace_data): Likewise.\n+\t(target_upload_tracepoints): Likewise.\n+\t(target_upload_trace_state_variables): Likewise.\n+\t(target_get_raw_trace_data): Likewise.\n+\t(target_get_min_fast_tracepoint_insn_len): Likewise.\n+\t(target_set_disconnected_tracing): Likewise.\n+\t(target_set_circular_trace_buffer): Likewise.\n+\t(target_set_trace_buffer_size): Likewise.\n+\t(target_set_trace_notes): Likewise.\n+\t(target_get_tib_address): Likewise.\n+\t(target_set_permissions): Likewise.\n+\t(target_static_tracepoint_marker_at): Likewise.\n+\t(target_static_tracepoint_markers_by_strid): Likewise.\n+\t(target_traceframe_info): Likewise.\n+\t(target_use_agent): Likewise.\n+\t(target_can_use_agent): Likewise.\n+\t(target_augmented_libraries_svr4_read): Likewise.\n+\t(target_log_command): Likewise.\n+\t* target.c (target_shortname): New.\n+\t(target_longname): New.\n+\t(target_attach_no_wait): New.\n+\t(target_post_attach): New.\n+\t(target_prepare_to_store): New.\n+\t(target_supports_enable_disable_tracepoint): New.\n+\t(target_supports_string_tracing): New.\n+\t(target_supports_evaluation_of_breakpoint_conditions): New.\n+\t(target_supports_dumpcore): New.\n+\t(target_dumpcore): New.\n+\t(target_can_run_breakpoint_commands): New.\n+\t(target_files_info): New.\n+\t(target_post_startup_inferior): New.\n+\t(target_insert_fork_catchpoint): New.\n+\t(target_remove_fork_catchpoint): New.\n+\t(target_insert_vfork_catchpoint): New.\n+\t(target_remove_vfork_catchpoint): New.\n+\t(target_insert_exec_catchpoint): New.\n+\t(target_remove_exec_catchpoint): New.\n+\t(target_set_syscall_catchpoint): New.\n+\t(target_rcmd): New.\n+\t(target_can_lock_scheduler): New.\n+\t(target_can_async_p): New.\n+\t(target_is_async_p): New.\n+\t(target_execution_direction): New.\n+\t(target_extra_thread_info): New.\n+\t(target_pid_to_exec_file): New.\n+\t(target_thread_architecture): New.\n+\t(target_find_memory_regions): New.\n+\t(target_make_corefile_notes): New.\n+\t(target_get_bookmark): New.\n+\t(target_goto_bookmark): New.\n+\t(target_stopped_by_watchpoint): New.\n+\t(target_stopped_by_sw_breakpoint): New.\n+\t(target_supports_stopped_by_sw_breakpoint): New.\n+\t(target_stopped_by_hw_breakpoint): New.\n+\t(target_supports_stopped_by_hw_breakpoint): New.\n+\t(target_have_steppable_watchpoint): New.\n+\t(target_can_use_hardware_watchpoint): New.\n+\t(target_region_ok_for_hw_watchpoint): New.\n+\t(target_can_do_single_step): New.\n+\t(target_insert_watchpoint): New.\n+\t(target_remove_watchpoint): New.\n+\t(target_insert_hw_breakpoint): New.\n+\t(target_remove_hw_breakpoint): New.\n+\t(target_can_accel_watchpoint_condition): New.\n+\t(target_can_execute_reverse): New.\n+\t(target_get_ada_task_ptid): New.\n+\t(target_filesystem_is_local): New.\n+\t(target_trace_init): New.\n+\t(target_download_tracepoint): New.\n+\t(target_can_download_tracepoint): New.\n+\t(target_download_trace_state_variable): New.\n+\t(target_enable_tracepoint): New.\n+\t(target_disable_tracepoint): New.\n+\t(target_trace_start): New.\n+\t(target_trace_set_readonly_regions): New.\n+\t(target_get_trace_status): New.\n+\t(target_get_tracepoint_status): New.\n+\t(target_trace_stop): New.\n+\t(target_trace_find): New.\n+\t(target_get_trace_state_variable_value): New.\n+\t(target_save_trace_data): New.\n+\t(target_upload_tracepoints): New.\n+\t(target_upload_trace_state_variables): New.\n+\t(target_get_raw_trace_data): New.\n+\t(target_get_min_fast_tracepoint_insn_len): New.\n+\t(target_set_disconnected_tracing): New.\n+\t(target_set_circular_trace_buffer): New.\n+\t(target_set_trace_buffer_size): New.\n+\t(target_set_trace_notes): New.\n+\t(target_get_tib_address): New.\n+\t(target_set_permissions): New.\n+\t(target_static_tracepoint_marker_at): New.\n+\t(target_static_tracepoint_markers_by_strid): New.\n+\t(target_traceframe_info): New.\n+\t(target_use_agent): New.\n+\t(target_can_use_agent): New.\n+\t(target_augmented_libraries_svr4_read): New.\n+\t(target_log_command): New.\n+\t* bfin-tdep.c (bfin_sw_breakpoint_from_kind): Adjust.\n+\t* infrun.c (set_schedlock_func): Adjust.\n+\t* mi/mi-main.c (exec_reverse_continue): Adjust.\n+\t* reverse.c (exec_reverse_once): Adjust.\n+\t* sh-tdep.c (sh_sw_breakpoint_from_kind): Adjust.\n+\t* tui/tui-stack.c (tui_locator_window::make_status_line): Adjust.\n+\t* remote-sim.c (gdbsim_target::detach): Adjust.\n+\t(gdbsim_target::files_info): Adjust.\n+\n 2021-03-24  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (dw2_map_matching_symbols): Update."
    },
    {
      "sha": "e3d6eee8832e4dd335a672dc06074e7153c8cf1c",
      "filename": "gdb/bfin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/bfin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/bfin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfin-tdep.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -597,7 +597,7 @@ bfin_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n \n   *size = kind;\n \n-  if (strcmp (target_shortname, \"sim\") == 0)\n+  if (strcmp (target_shortname (), \"sim\") == 0)\n     return bfin_sim_breakpoint;\n   else\n     return bfin_breakpoint;"
    },
    {
      "sha": "b6f399d5478ed16fd5eadaf2bc076d35241d4f1d",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -2030,7 +2030,8 @@ set_schedlock_func (const char *args, int from_tty, struct cmd_list_element *c)\n   if (!target_can_lock_scheduler ())\n     {\n       scheduler_mode = schedlock_off;\n-      error (_(\"Target '%s' cannot support this command.\"), target_shortname);\n+      error (_(\"Target '%s' cannot support this command.\"),\n+\t     target_shortname ());\n     }\n }\n "
    },
    {
      "sha": "d5ce08e95ed271ecd38e487a73ea89ebdee7b2f9",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -322,7 +322,7 @@ exec_reverse_continue (char **argv, int argc)\n     error (_(\"Already in reverse mode.\"));\n \n   if (!target_can_execute_reverse ())\n-    error (_(\"Target %s does not support this command.\"), target_shortname);\n+    error (_(\"Target %s does not support this command.\"), target_shortname ());\n \n   scoped_restore save_exec_dir = make_scoped_restore (&execution_direction,\n \t\t\t\t\t\t      EXEC_REVERSE);"
    },
    {
      "sha": "f2cf8dbd7117985c3e5b94f9b9389c2c8cdc295b",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -836,7 +836,7 @@ gdbsim_target::detach (inferior *inf, int from_tty)\n \n   inf->unpush_target (this);\t\t/* calls gdbsim_close to do the real work */\n   if (from_tty)\n-    printf_filtered (\"Ending simulator %s debugging\\n\", target_shortname);\n+    printf_filtered (\"Ending simulator %s debugging\\n\", target_shortname ());\n }\n \n /* Resume execution of the target process.  STEP says whether to single-step\n@@ -1119,7 +1119,7 @@ gdbsim_target::files_info ()\n   if (current_program_space->exec_bfd ())\n     {\n       fprintf_unfiltered (gdb_stdlog, \"\\tAttached to %s running program %s\\n\",\n-\t\t\t  target_shortname, file);\n+\t\t\t  target_shortname (), file);\n       sim_info (sim_data->gdbsim_desc, 0);\n     }\n }"
    },
    {
      "sha": "e51defb27a3c47837413fa545295125689e72ee3",
      "filename": "gdb/reverse.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/reverse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/reverse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/reverse.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -45,7 +45,7 @@ exec_reverse_once (const char *cmd, const char *args, int from_tty)\n \t   cmd);\n \n   if (!target_can_execute_reverse ())\n-    error (_(\"Target %s does not support this command.\"), target_shortname);\n+    error (_(\"Target %s does not support this command.\"), target_shortname ());\n \n   std::string reverse_command = string_printf (\"%s %s\", cmd, args ? args : \"\");\n   scoped_restore restore_exec_dir"
    },
    {
      "sha": "5a71d3ac6896c25cbce5e22e5c532442d612c295",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -432,7 +432,7 @@ sh_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n   *size = kind;\n \n   /* For remote stub targets, trapa #20 is used.  */\n-  if (strcmp (target_shortname, \"remote\") == 0)\n+  if (strcmp (target_shortname (), \"remote\") == 0)\n     {\n       static unsigned char big_remote_breakpoint[] = { 0xc3, 0x20 };\n       static unsigned char little_remote_breakpoint[] = { 0x20, 0xc3 };"
    },
    {
      "sha": "9c4af5beaf0e8f8c750c8201a8224e40bf7edd22",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 578,
      "deletions": 0,
      "changes": 578,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -215,6 +215,584 @@ target_has_execution (inferior *inf)\n   return false;\n }\n \n+const char *\n+target_shortname ()\n+{\n+  return current_top_target ()->shortname ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_attach_no_wait ()\n+{\n+  return current_top_target ()->attach_no_wait ();\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_post_attach (int pid)\n+{\n+  return current_top_target ()->post_attach (pid);\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_prepare_to_store (regcache *regcache)\n+{\n+  return current_top_target ()->prepare_to_store (regcache);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_supports_enable_disable_tracepoint ()\n+{\n+  return current_top_target ()->supports_enable_disable_tracepoint ();\n+}\n+\n+bool\n+target_supports_string_tracing ()\n+{\n+  return current_top_target ()->supports_string_tracing ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_supports_evaluation_of_breakpoint_conditions ()\n+{\n+  return current_top_target ()->supports_evaluation_of_breakpoint_conditions ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_supports_dumpcore ()\n+{\n+  return current_top_target ()->supports_dumpcore ();\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_dumpcore (const char *filename)\n+{\n+  return current_top_target ()->dumpcore (filename);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_run_breakpoint_commands ()\n+{\n+  return current_top_target ()->can_run_breakpoint_commands ();\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_files_info ()\n+{\n+  return current_top_target ()->files_info ();\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_post_startup_inferior (ptid_t ptid)\n+{\n+  return current_top_target ()->post_startup_inferior (ptid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_insert_fork_catchpoint (int pid)\n+{\n+  return current_top_target ()->insert_fork_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_remove_fork_catchpoint (int pid)\n+{\n+  return current_top_target ()->remove_fork_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_insert_vfork_catchpoint (int pid)\n+{\n+  return current_top_target ()->insert_vfork_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_remove_vfork_catchpoint (int pid)\n+{\n+  return current_top_target ()->remove_vfork_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_insert_exec_catchpoint (int pid)\n+{\n+  return current_top_target ()->insert_exec_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_remove_exec_catchpoint (int pid)\n+{\n+  return current_top_target ()->remove_exec_catchpoint (pid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_set_syscall_catchpoint (int pid, bool needed, int any_count,\n+\t\t\t       gdb::array_view<const int> syscall_counts)\n+{\n+  return current_top_target ()->set_syscall_catchpoint (pid, needed, any_count,\n+\t\t\t\t\t\t\tsyscall_counts);\n+}\n+\n+/* See target.h.  */\n+\n+void\n+target_rcmd (const char *command, struct ui_file *outbuf)\n+{\n+  return current_top_target ()->rcmd (command, outbuf);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_lock_scheduler ()\n+{\n+  return (current_top_target ()->get_thread_control_capabilities ()\n+\t  & tc_schedlock) != 0;\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_async_p ()\n+{\n+  return current_top_target ()->can_async_p ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_is_async_p ()\n+{\n+  return current_top_target ()->is_async_p ();\n+}\n+\n+exec_direction_kind\n+target_execution_direction ()\n+{\n+  return current_top_target ()->execution_direction ();\n+}\n+\n+/* See target.h.  */\n+\n+const char *\n+target_extra_thread_info (thread_info *tp)\n+{\n+  return current_top_target ()->extra_thread_info (tp);\n+}\n+\n+/* See target.h.  */\n+\n+char *\n+target_pid_to_exec_file (int pid)\n+{\n+  return current_top_target ()->pid_to_exec_file (pid);\n+}\n+\n+/* See target.h.  */\n+\n+gdbarch *\n+target_thread_architecture (ptid_t ptid)\n+{\n+  return current_top_target ()->thread_architecture (ptid);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_find_memory_regions (find_memory_region_ftype func, void *data)\n+{\n+  return current_top_target ()->find_memory_regions (func, data);\n+}\n+\n+/* See target.h.  */\n+\n+gdb::unique_xmalloc_ptr<char>\n+target_make_corefile_notes (bfd *bfd, int *size_p)\n+{\n+  return current_top_target ()->make_corefile_notes (bfd, size_p);\n+}\n+\n+gdb_byte *\n+target_get_bookmark (const char *args, int from_tty)\n+{\n+  return current_top_target ()->get_bookmark (args, from_tty);\n+}\n+\n+void\n+target_goto_bookmark (const gdb_byte *arg, int from_tty)\n+{\n+  return current_top_target ()->goto_bookmark (arg, from_tty);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_stopped_by_watchpoint ()\n+{\n+  return current_top_target ()->stopped_by_watchpoint ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_stopped_by_sw_breakpoint ()\n+{\n+  return current_top_target ()->stopped_by_sw_breakpoint ();\n+}\n+\n+bool\n+target_supports_stopped_by_sw_breakpoint ()\n+{\n+  return current_top_target ()->supports_stopped_by_sw_breakpoint ();\n+}\n+\n+bool\n+target_stopped_by_hw_breakpoint ()\n+{\n+  return current_top_target ()->stopped_by_hw_breakpoint ();\n+}\n+\n+bool\n+target_supports_stopped_by_hw_breakpoint ()\n+{\n+  return current_top_target ()->supports_stopped_by_hw_breakpoint ();\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_have_steppable_watchpoint ()\n+{\n+  return current_top_target ()->have_steppable_watchpoint ();\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_can_use_hardware_watchpoint (bptype type, int cnt, int othertype)\n+{\n+  return current_top_target ()->can_use_hw_breakpoint (type, cnt, othertype);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)\n+{\n+  return current_top_target ()->region_ok_for_hw_watchpoint (addr, len);\n+}\n+\n+\n+int\n+target_can_do_single_step ()\n+{\n+  return current_top_target ()->can_do_single_step ();\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_insert_watchpoint (CORE_ADDR addr, int len, target_hw_bp_type type,\n+\t\t\t  expression *cond)\n+{\n+  return current_top_target ()->insert_watchpoint (addr, len, type, cond);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_remove_watchpoint (CORE_ADDR addr, int len, target_hw_bp_type type,\n+\t\t\t  expression *cond)\n+{\n+  return current_top_target ()->remove_watchpoint (addr, len, type, cond);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_insert_hw_breakpoint (gdbarch *gdbarch, bp_target_info *bp_tgt)\n+{\n+  return current_top_target ()->insert_hw_breakpoint (gdbarch, bp_tgt);\n+}\n+\n+/* See target.h.  */\n+\n+int\n+target_remove_hw_breakpoint (gdbarch *gdbarch, bp_target_info *bp_tgt)\n+{\n+  return current_top_target ()->remove_hw_breakpoint (gdbarch, bp_tgt);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_accel_watchpoint_condition (CORE_ADDR addr, int len, int type,\n+\t\t\t\t       expression *cond)\n+{\n+  return current_top_target ()->can_accel_watchpoint_condition (addr, len, type, cond);\n+}\n+\n+/* See target.h.  */\n+\n+bool\n+target_can_execute_reverse ()\n+{\n+  return current_top_target ()->can_execute_reverse ();\n+}\n+\n+ptid_t\n+target_get_ada_task_ptid (long lwp, long tid)\n+{\n+  return current_top_target ()->get_ada_task_ptid (lwp, tid);\n+}\n+\n+bool\n+target_filesystem_is_local ()\n+{\n+  return current_top_target ()->filesystem_is_local ();\n+}\n+\n+void\n+target_trace_init ()\n+{\n+  return current_top_target ()->trace_init ();\n+}\n+\n+void\n+target_download_tracepoint (bp_location *location)\n+{\n+  return current_top_target ()->download_tracepoint (location);\n+}\n+\n+bool\n+target_can_download_tracepoint ()\n+{\n+  return current_top_target ()->can_download_tracepoint ();\n+}\n+\n+void\n+target_download_trace_state_variable (const trace_state_variable &tsv)\n+{\n+  return current_top_target ()->download_trace_state_variable (tsv);\n+}\n+\n+void\n+target_enable_tracepoint (bp_location *loc)\n+{\n+  return current_top_target ()->enable_tracepoint (loc);\n+}\n+\n+void\n+target_disable_tracepoint (bp_location *loc)\n+{\n+  return current_top_target ()->disable_tracepoint (loc);\n+}\n+\n+void\n+target_trace_start ()\n+{\n+  return current_top_target ()->trace_start ();\n+}\n+\n+void\n+target_trace_set_readonly_regions ()\n+{\n+  current_top_target ()->trace_set_readonly_regions ();\n+}\n+\n+int\n+target_get_trace_status (trace_status *ts)\n+{\n+  return current_top_target ()->get_trace_status (ts);\n+}\n+\n+void\n+target_get_tracepoint_status (breakpoint *tp, uploaded_tp *utp)\n+{\n+  return current_top_target ()->get_tracepoint_status (tp, utp);\n+}\n+\n+void\n+target_trace_stop ()\n+{\n+  return current_top_target ()->trace_stop ();\n+}\n+\n+int\n+target_trace_find (trace_find_type type, int num,\n+\t\t   CORE_ADDR addr1, CORE_ADDR addr2, int *tpp)\n+{\n+  return current_top_target ()->trace_find (type, num, addr1, addr2, tpp);\n+}\n+\n+bool\n+target_get_trace_state_variable_value (int tsv, LONGEST *val)\n+{\n+  return current_top_target ()->get_trace_state_variable_value (tsv, val);\n+}\n+\n+int\n+target_save_trace_data (const char *filename)\n+{\n+  return current_top_target ()->save_trace_data (filename);\n+}\n+\n+int\n+target_upload_tracepoints (uploaded_tp **utpp)\n+{\n+  return current_top_target ()->upload_tracepoints (utpp);\n+}\n+\n+int\n+target_upload_trace_state_variables (uploaded_tsv **utsvp)\n+{\n+  return current_top_target ()->upload_trace_state_variables (utsvp);\n+}\n+\n+LONGEST\n+target_get_raw_trace_data (gdb_byte *buf, ULONGEST offset, LONGEST len)\n+{\n+  return current_top_target ()->get_raw_trace_data (buf, offset, len);\n+}\n+\n+int\n+target_get_min_fast_tracepoint_insn_len ()\n+{\n+  return current_top_target ()->get_min_fast_tracepoint_insn_len ();\n+}\n+\n+void\n+target_set_disconnected_tracing (int val)\n+{\n+  return current_top_target ()->set_disconnected_tracing (val);\n+}\n+\n+void\n+target_set_circular_trace_buffer (int val)\n+{\n+  return current_top_target ()->set_circular_trace_buffer (val);\n+}\n+\n+void\n+target_set_trace_buffer_size (LONGEST val)\n+{\n+  return current_top_target ()->set_trace_buffer_size (val);\n+}\n+\n+bool\n+target_set_trace_notes (const char *user, const char *notes,\n+\t\t\tconst char *stopnotes)\n+{\n+  return current_top_target ()->set_trace_notes (user, notes, stopnotes);\n+}\n+\n+bool\n+target_get_tib_address (ptid_t ptid, CORE_ADDR *addr)\n+{\n+  return current_top_target ()->get_tib_address (ptid, addr);\n+}\n+\n+void\n+target_set_permissions ()\n+{\n+  return current_top_target ()->set_permissions ();\n+}\n+\n+bool\n+target_static_tracepoint_marker_at (CORE_ADDR addr,\n+\t\t\t\t    static_tracepoint_marker *marker)\n+{\n+  return current_top_target ()->static_tracepoint_marker_at (addr, marker);\n+}\n+\n+std::vector<static_tracepoint_marker>\n+target_static_tracepoint_markers_by_strid (const char *marker_id)\n+{\n+  return current_top_target ()->static_tracepoint_markers_by_strid (marker_id);\n+}\n+\n+traceframe_info_up\n+target_traceframe_info ()\n+{\n+  return current_top_target ()->traceframe_info ();\n+}\n+\n+bool\n+target_use_agent (bool use)\n+{\n+  return current_top_target ()->use_agent (use);\n+}\n+\n+bool\n+target_can_use_agent ()\n+{\n+  return current_top_target ()->can_use_agent ();\n+}\n+\n+bool\n+target_augmented_libraries_svr4_read ()\n+{\n+  return current_top_target ()->augmented_libraries_svr4_read ();\n+}\n+\n+bool\n+target_supports_memory_tagging ()\n+{\n+  return current_top_target ()->supports_memory_tagging ();\n+}\n+\n+bool\n+target_fetch_memtags (CORE_ADDR address, size_t len, gdb::byte_vector &tags,\n+\t\t      int type)\n+{\n+  return current_top_target ()->fetch_memtags (address, len, tags, type);\n+}\n+\n+bool\n+target_store_memtags (CORE_ADDR address, size_t len,\n+\t\t      const gdb::byte_vector &tags, int type)\n+{\n+  return current_top_target ()->store_memtags (address, len, tags, type);\n+}\n+\n+void\n+target_log_command (const char *p)\n+{\n+  return current_top_target ()->log_command (p);\n+}\n+\n /* This is used to implement the various target commands.  */\n \n static void"
    },
    {
      "sha": "482952e5f5d21e360a63bc23de34f0baf502a789",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 111,
      "deletions": 185,
      "changes": 296,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -917,8 +917,8 @@ struct target_ops\n \n     /* Target file operations.  */\n \n-    /* Return nonzero if the filesystem seen by the current inferior\n-       is the local filesystem, zero otherwise.  */\n+    /* Return true if the filesystem seen by the current inferior\n+       is the local filesystem, false otherwise.  */\n     virtual bool filesystem_is_local ()\n       TARGET_DEFAULT_RETURN (true);\n \n@@ -1069,8 +1069,8 @@ struct target_ops\n     virtual void set_trace_buffer_size (LONGEST val)\n       TARGET_DEFAULT_IGNORE ();\n \n-    /* Add/change textual notes about the trace run, returning 1 if\n-       successful, 0 otherwise.  */\n+    /* Add/change textual notes about the trace run, returning true if\n+       successful, false otherwise.  */\n     virtual bool set_trace_notes (const char *user, const char *notes,\n \t\t\t\t  const char *stopnotes)\n       TARGET_DEFAULT_RETURN (false);\n@@ -1395,7 +1395,7 @@ extern target_ops *get_dummy_target ();\n \n /* Define easy words for doing these operations on our current target.  */\n \n-#define\ttarget_shortname\t(current_top_target ()->shortname ())\n+extern const char *target_shortname ();\n \n /* Does whatever cleanup is required for a target that we are no\n    longer going to be calling.  This routine is automatically always\n@@ -1422,16 +1422,15 @@ extern struct target_ops *find_run_target (void);\n    or their target_attach implementation takes care of the waiting.\n    These targets must set to_attach_no_wait.  */\n \n-#define target_attach_no_wait() \\\n-  (current_top_target ()->attach_no_wait ())\n+extern bool target_attach_no_wait ();\n \n /* The target_attach operation places a process under debugger control,\n    and stops the process.\n \n    This operation provides a target-specific hook that allows the\n    necessary bookkeeping to be performed after an attach completes.  */\n-#define target_post_attach(pid) \\\n-     (current_top_target ()->post_attach) (pid)\n+\n+extern void target_post_attach (int pid);\n \n /* Display a message indicating we're about to detach from the current\n    inferior process.  */\n@@ -1512,8 +1511,7 @@ extern void target_store_registers (struct regcache *regcache, int regs);\n    that REGISTERS contains all the registers from the program being\n    debugged.  */\n \n-#define\ttarget_prepare_to_store(regcache)\t\\\n-     (current_top_target ()->prepare_to_store) (regcache)\n+extern void target_prepare_to_store (regcache *regcache);\n \n /* Determine current address space of thread PTID.  */\n \n@@ -1533,33 +1531,27 @@ int target_supports_disable_randomization (void);\n /* Returns true if this target can enable and disable tracepoints\n    while a trace experiment is running.  */\n \n-#define target_supports_enable_disable_tracepoint() \\\n-  (current_top_target ()->supports_enable_disable_tracepoint) ()\n+extern bool target_supports_enable_disable_tracepoint ();\n \n-#define target_supports_string_tracing() \\\n-  (current_top_target ()->supports_string_tracing) ()\n+extern bool target_supports_string_tracing ();\n \n /* Returns true if this target can handle breakpoint conditions\n    on its end.  */\n \n-#define target_supports_evaluation_of_breakpoint_conditions() \\\n-  (current_top_target ()->supports_evaluation_of_breakpoint_conditions) ()\n+extern bool target_supports_evaluation_of_breakpoint_conditions ();\n \n /* Does this target support dumpcore API?  */\n \n-#define target_supports_dumpcore() \\\n-  (current_top_target ()->supports_dumpcore) ()\n+extern bool target_supports_dumpcore ();\n \n /* Generate the core file with target API.  */\n \n-#define target_dumpcore(x) \\\n-  (current_top_target ()->dumpcore (x))\n+extern void target_dumpcore (const char *filename);\n \n /* Returns true if this target can handle breakpoint commands\n    on its end.  */\n \n-#define target_can_run_breakpoint_commands() \\\n-  (current_top_target ()->can_run_breakpoint_commands) ()\n+extern bool target_can_run_breakpoint_commands ();\n \n /* Read a string from target memory at address MEMADDR.  The string\n    will be at most LEN bytes long (note that excess bytes may be read\n@@ -1646,8 +1638,7 @@ int target_write_memory_blocks\n \n /* Print a line about the current target.  */\n \n-#define\ttarget_files_info()\t\\\n-     (current_top_target ()->files_info) ()\n+extern void target_files_info ();\n \n /* Insert a breakpoint at address BP_TGT->placed_address in\n    the target machine.  Returns 0 for success, and returns non-zero or\n@@ -1696,25 +1687,20 @@ extern void target_load (const char *arg, int from_tty);\n \n    Such targets will supply an appropriate definition for this function.  */\n \n-#define target_post_startup_inferior(ptid) \\\n-     (current_top_target ()->post_startup_inferior) (ptid)\n+extern void target_post_startup_inferior (ptid_t ptid);\n \n /* On some targets, we can catch an inferior fork or vfork event when\n    it occurs.  These functions insert/remove an already-created\n    catchpoint for such events.  They return  0 for success, 1 if the\n    catchpoint type is not supported and -1 for failure.  */\n \n-#define target_insert_fork_catchpoint(pid) \\\n-     (current_top_target ()->insert_fork_catchpoint) (pid)\n+extern int target_insert_fork_catchpoint (int pid);\n \n-#define target_remove_fork_catchpoint(pid) \\\n-     (current_top_target ()->remove_fork_catchpoint) (pid)\n+extern int target_remove_fork_catchpoint (int pid);\n \n-#define target_insert_vfork_catchpoint(pid) \\\n-     (current_top_target ()->insert_vfork_catchpoint) (pid)\n+extern int target_insert_vfork_catchpoint (int pid);\n \n-#define target_remove_vfork_catchpoint(pid) \\\n-     (current_top_target ()->remove_vfork_catchpoint) (pid)\n+extern int target_remove_vfork_catchpoint (int pid);\n \n /* If the inferior forks or vforks, this function will be called at\n    the next resume in order to perform any bookkeeping and fiddling\n@@ -1736,11 +1722,9 @@ void target_follow_exec (struct inferior *inf, const char *execd_pathname);\n    catchpoint for such events.  They return  0 for success, 1 if the\n    catchpoint type is not supported and -1 for failure.  */\n \n-#define target_insert_exec_catchpoint(pid) \\\n-     (current_top_target ()->insert_exec_catchpoint) (pid)\n+extern int target_insert_exec_catchpoint (int pid);\n \n-#define target_remove_exec_catchpoint(pid) \\\n-     (current_top_target ()->remove_exec_catchpoint) (pid)\n+extern int target_remove_exec_catchpoint (int pid);\n \n /* Syscall catch.\n \n@@ -1758,9 +1742,9 @@ void target_follow_exec (struct inferior *inf, const char *execd_pathname);\n    Return 0 for success, 1 if syscall catchpoints are not supported or -1\n    for failure.  */\n \n-#define target_set_syscall_catchpoint(pid, needed, any_count, syscall_counts) \\\n-     (current_top_target ()->set_syscall_catchpoint) (pid, needed, any_count, \\\n-\t\t\t\t\t     syscall_counts)\n+extern int target_set_syscall_catchpoint\n+  (int pid, bool needed, int any_count,\n+   gdb::array_view<const int> syscall_counts);\n \n /* The debugger has completed a blocking wait() call.  There is now\n    some process event that must be processed.  This function should\n@@ -1844,9 +1828,7 @@ extern void default_target_pass_ctrlc (struct target_ops *ops);\n    (shell,interpreter) for execution.  The result of the query is\n    placed in OUTBUF.  */\n \n-#define target_rcmd(command, outbuf) \\\n-     (current_top_target ()->rcmd) (command, outbuf)\n-\n+extern void target_rcmd (const char *command, struct ui_file *outbuf);\n \n /* Does the target include memory?  (Dummy targets don't.)  */\n \n@@ -1875,21 +1857,16 @@ extern bool target_has_execution (inferior *inf = nullptr);\n /* Can the target support the debugger control of thread execution?\n    Can it lock the thread scheduler?  */\n \n-static inline bool\n-target_can_lock_scheduler ()\n-{\n-  return (current_top_target ()->get_thread_control_capabilities ()\n-\t  & tc_schedlock) != 0;\n-}\n+extern bool target_can_lock_scheduler ();\n \n /* Controls whether async mode is permitted.  */\n extern bool target_async_permitted;\n \n /* Can the target support asynchronous execution?  */\n-#define target_can_async_p() (current_top_target ()->can_async_p ())\n+extern bool target_can_async_p ();\n \n /* Is the target in asynchronous execution mode?  */\n-#define target_is_async_p() (current_top_target ()->is_async_p ())\n+extern bool target_is_async_p ();\n \n /* Enables/disabled async target events.  */\n extern void target_async (int enable);\n@@ -1909,8 +1886,7 @@ extern bool target_is_non_stop_p ();\n /* Return true if at least one inferior has a non-stop target.  */\n extern bool exists_non_stop_target ();\n \n-#define target_execution_direction() \\\n-  (current_top_target ()->execution_direction ())\n+extern exec_direction_kind target_execution_direction ();\n \n /* Converts a process id to a string.  Usually, the string just contains\n    `process xyz', but on some systems it may contain\n@@ -1924,8 +1900,7 @@ extern std::string normal_pid_to_str (ptid_t ptid);\n    e.g. \"sleeping\", \"runnable\", \"running on LWP 3\".  Null return value\n    is okay.  */\n \n-#define target_extra_thread_info(TP) \\\n-     (current_top_target ()->extra_thread_info (TP))\n+extern const char *target_extra_thread_info (thread_info *tp);\n \n /* Return the thread's name, or NULL if the target is unable to determine it.\n    The returned value must not be freed by the caller.  */\n@@ -1956,13 +1931,11 @@ extern gdb::byte_vector target_thread_info_to_thread_handle\n    the client if the string will not be immediately used, or if\n    it must persist.  */\n \n-#define target_pid_to_exec_file(pid) \\\n-     (current_top_target ()->pid_to_exec_file) (pid)\n+extern char *target_pid_to_exec_file (int pid);\n \n /* See the to_thread_architecture description in struct target_ops.  */\n \n-#define target_thread_architecture(ptid) \\\n-     (current_top_target ()->thread_architecture (ptid))\n+extern gdbarch *target_thread_architecture (ptid_t ptid);\n \n /*\n  * Iterator function for target memory regions.\n@@ -1971,22 +1944,20 @@ extern gdb::byte_vector target_thread_info_to_thread_handle\n  * as a function macro so that it can be tested for nullity.\n  */\n \n-#define target_find_memory_regions(FUNC, DATA) \\\n-     (current_top_target ()->find_memory_regions) (FUNC, DATA)\n+extern int target_find_memory_regions (find_memory_region_ftype func,\n+\t\t\t\t       void *data);\n \n /*\n  * Compose corefile .note section.\n  */\n \n-#define target_make_corefile_notes(BFD, SIZE_P) \\\n-     (current_top_target ()->make_corefile_notes) (BFD, SIZE_P)\n+extern gdb::unique_xmalloc_ptr<char> target_make_corefile_notes (bfd *bfd,\n+\t\t\t\t\t\t\t\t int *size_p);\n \n /* Bookmark interfaces.  */\n-#define target_get_bookmark(ARGS, FROM_TTY) \\\n-     (current_top_target ()->get_bookmark) (ARGS, FROM_TTY)\n+extern gdb_byte *target_get_bookmark (const char *args, int from_tty);\n \n-#define target_goto_bookmark(ARG, FROM_TTY) \\\n-     (current_top_target ()->goto_bookmark) (ARG, FROM_TTY)\n+extern void target_goto_bookmark (const gdb_byte *arg, int from_tty);\n \n /* Hardware watchpoint interfaces.  */\n \n@@ -2024,34 +1995,25 @@ extern gdb::byte_vector target_thread_info_to_thread_handle\n    gdbarch_have_nonsteppable_watchpoint, GDB assumes continuable\n    watchpoints.  */\n \n-/* Returns non-zero if we were stopped by a hardware watchpoint (memory read or\n+/* Returns true if we were stopped by a hardware watchpoint (memory read or\n    write).  Only the INFERIOR_PTID task is being queried.  */\n \n-#define target_stopped_by_watchpoint()\t\t\\\n-  ((current_top_target ()->stopped_by_watchpoint) ())\n+extern bool target_stopped_by_watchpoint ();\n \n-/* Returns non-zero if the target stopped because it executed a\n+/* Returns true if the target stopped because it executed a\n    software breakpoint instruction.  */\n \n-#define target_stopped_by_sw_breakpoint()\t\t\\\n-  ((current_top_target ()->stopped_by_sw_breakpoint) ())\n+extern bool target_stopped_by_sw_breakpoint ();\n \n-#define target_supports_stopped_by_sw_breakpoint() \\\n-  ((current_top_target ()->supports_stopped_by_sw_breakpoint) ())\n+extern bool target_supports_stopped_by_sw_breakpoint ();\n \n-#define target_stopped_by_hw_breakpoint()\t\t\t\t\\\n-  ((current_top_target ()->stopped_by_hw_breakpoint) ())\n+extern bool target_stopped_by_hw_breakpoint ();\n \n-#define target_supports_stopped_by_hw_breakpoint() \\\n-  ((current_top_target ()->supports_stopped_by_hw_breakpoint) ())\n+extern bool target_supports_stopped_by_hw_breakpoint ();\n \n-/* Non-zero if we have steppable watchpoints  */\n+/* True if we have steppable watchpoints  */\n \n-static inline bool\n-target_have_steppable_watchpoint ()\n-{\n-  return current_top_target ()->have_steppable_watchpoint ();\n-}\n+extern bool target_have_steppable_watchpoint ();\n \n /* Provide defaults for hardware watchpoint functions.  */\n \n@@ -2067,31 +2029,27 @@ target_have_steppable_watchpoint ()\n    one.  OTHERTYPE is the number of watchpoints of other types than\n    this one used so far.  */\n \n-#define target_can_use_hardware_watchpoint(TYPE,CNT,OTHERTYPE) \\\n- (current_top_target ()->can_use_hw_breakpoint) ( \\\n-\t\t\t\t\t     TYPE, CNT, OTHERTYPE)\n+extern int target_can_use_hardware_watchpoint (bptype type, int cnt,\n+\t\t\t\t\t       int othertype);\n \n /* Returns the number of debug registers needed to watch the given\n    memory region, or zero if not supported.  */\n \n-#define target_region_ok_for_hw_watchpoint(addr, len) \\\n-    (current_top_target ()->region_ok_for_hw_watchpoint) (addr, len)\n-\n+extern int target_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len);\n \n-#define target_can_do_single_step() \\\n-  (current_top_target ()->can_do_single_step) ()\n+extern int target_can_do_single_step ();\n \n /* Set/clear a hardware watchpoint starting at ADDR, for LEN bytes.\n    TYPE is 0 for write, 1 for read, and 2 for read/write accesses.\n    COND is the expression for its condition, or NULL if there's none.\n    Returns 0 for success, 1 if the watchpoint type is not supported,\n    -1 for failure.  */\n \n-#define\ttarget_insert_watchpoint(addr, len, type, cond) \\\n-     (current_top_target ()->insert_watchpoint) (addr, len, type, cond)\n+extern int target_insert_watchpoint (CORE_ADDR addr, int len,\n+\t\t\t\t     target_hw_bp_type type, expression *cond);\n \n-#define\ttarget_remove_watchpoint(addr, len, type, cond) \\\n-     (current_top_target ()->remove_watchpoint) (addr, len, type, cond)\n+extern int target_remove_watchpoint (CORE_ADDR addr, int len,\n+\t\t\t\t     target_hw_bp_type type, expression *cond);\n \n /* Insert a new masked watchpoint at ADDR using the mask MASK.\n    RW may be hw_read for a read watchpoint, hw_write for a write watchpoint\n@@ -2114,11 +2072,11 @@ extern int target_remove_mask_watchpoint (CORE_ADDR, CORE_ADDR,\n    throws an error (with a detailed failure reason error code and\n    message) otherwise.  */\n \n-#define target_insert_hw_breakpoint(gdbarch, bp_tgt) \\\n-     (current_top_target ()->insert_hw_breakpoint) (gdbarch, bp_tgt)\n+extern int target_insert_hw_breakpoint (gdbarch *gdbarch,\n+\t\t\t\t\tbp_target_info *bp_tgt);\n \n-#define target_remove_hw_breakpoint(gdbarch, bp_tgt) \\\n-     (current_top_target ()->remove_hw_breakpoint) (gdbarch, bp_tgt)\n+extern int target_remove_hw_breakpoint (gdbarch *gdbarch,\n+\t\t\t\t\tbp_target_info *bp_tgt);\n \n /* Return number of debug registers needed for a ranged breakpoint,\n    or -1 if ranged breakpoints are not supported.  */\n@@ -2146,8 +2104,9 @@ extern int target_ranged_break_num_registers (void);\n    expression is false, but may report some false positives as well.\n    For this reason, GDB will still evaluate the condition expression when\n    the watchpoint triggers.  */\n-#define target_can_accel_watchpoint_condition(addr, len, type, cond) \\\n-  (current_top_target ()->can_accel_watchpoint_condition) (addr, len, type, cond)\n+\n+extern bool target_can_accel_watchpoint_condition (CORE_ADDR addr, int len,\n+\t\t\t\t\t\t   int type, expression *cond);\n \n /* Return number of debug registers needed for a masked watchpoint,\n    -1 if masked watchpoints are not supported or -2 if the given address\n@@ -2156,16 +2115,12 @@ extern int target_ranged_break_num_registers (void);\n extern int target_masked_watch_num_registers (CORE_ADDR addr, CORE_ADDR mask);\n \n /* Target can execute in reverse?  */\n-static inline bool\n-target_can_execute_reverse ()\n-{\n-  return current_top_target ()->can_execute_reverse ();\n-}\n+\n+extern bool target_can_execute_reverse ();\n \n extern const struct target_desc *target_read_description (struct target_ops *);\n \n-#define target_get_ada_task_ptid(lwp, tid) \\\n-     (current_top_target ()->get_ada_task_ptid) (lwp,tid)\n+extern ptid_t target_get_ada_task_ptid (long lwp, long tid);\n \n /* Main entry point for searching memory.  */\n extern int target_search_memory (CORE_ADDR start_addr,\n@@ -2176,10 +2131,10 @@ extern int target_search_memory (CORE_ADDR start_addr,\n \n /* Target file operations.  */\n \n-/* Return nonzero if the filesystem seen by the current inferior\n+/* Return true if the filesystem seen by the current inferior\n    is the local filesystem, zero otherwise.  */\n-#define target_filesystem_is_local() \\\n-  current_top_target ()->filesystem_is_local ()\n+\n+extern bool target_filesystem_is_local ();\n \n /* Open FILENAME on the target, in the filesystem as seen by INF,\n    using FLAGS and MODE.  If INF is NULL, use the filesystem seen by\n@@ -2259,111 +2214,82 @@ extern gdb::unique_xmalloc_ptr<char> target_fileio_read_stralloc\n \n /* Tracepoint-related operations.  */\n \n-#define target_trace_init() \\\n-  (current_top_target ()->trace_init) ()\n+extern void target_trace_init ();\n \n-#define target_download_tracepoint(t) \\\n-  (current_top_target ()->download_tracepoint) (t)\n+extern void target_download_tracepoint (bp_location *location);\n \n-#define target_can_download_tracepoint() \\\n-  (current_top_target ()->can_download_tracepoint) ()\n+extern bool target_can_download_tracepoint ();\n \n-#define target_download_trace_state_variable(tsv) \\\n-  (current_top_target ()->download_trace_state_variable) (tsv)\n+extern void target_download_trace_state_variable (const trace_state_variable &tsv);\n \n-#define target_enable_tracepoint(loc) \\\n-  (current_top_target ()->enable_tracepoint) (loc)\n+extern void target_enable_tracepoint (bp_location *loc);\n \n-#define target_disable_tracepoint(loc) \\\n-  (current_top_target ()->disable_tracepoint) (loc)\n+extern void target_disable_tracepoint (bp_location *loc);\n \n-#define target_trace_start() \\\n-  (current_top_target ()->trace_start) ()\n+extern void target_trace_start ();\n \n-#define target_trace_set_readonly_regions() \\\n-  (current_top_target ()->trace_set_readonly_regions) ()\n+extern void target_trace_set_readonly_regions ();\n \n-#define target_get_trace_status(ts) \\\n-  (current_top_target ()->get_trace_status) (ts)\n+extern int target_get_trace_status (trace_status *ts);\n \n-#define target_get_tracepoint_status(tp,utp)\t\t\\\n-  (current_top_target ()->get_tracepoint_status) (tp, utp)\n+extern void target_get_tracepoint_status (breakpoint *tp, uploaded_tp *utp);\n \n-#define target_trace_stop() \\\n-  (current_top_target ()->trace_stop) ()\n+extern void target_trace_stop ();\n \n-#define target_trace_find(type,num,addr1,addr2,tpp) \\\n-  (current_top_target ()->trace_find) (\\\n-\t\t\t\t   (type), (num), (addr1), (addr2), (tpp))\n+extern int target_trace_find (trace_find_type type, int num, CORE_ADDR addr1,\n+\t\t\t      CORE_ADDR addr2, int *tpp);\n \n-#define target_get_trace_state_variable_value(tsv,val) \\\n-  (current_top_target ()->get_trace_state_variable_value) ((tsv), (val))\n+extern bool target_get_trace_state_variable_value (int tsv, LONGEST *val);\n \n-#define target_save_trace_data(filename) \\\n-  (current_top_target ()->save_trace_data) (filename)\n+extern int target_save_trace_data (const char *filename);\n \n-#define target_upload_tracepoints(utpp) \\\n-  (current_top_target ()->upload_tracepoints) (utpp)\n+extern int target_upload_tracepoints (uploaded_tp **utpp);\n \n-#define target_upload_trace_state_variables(utsvp) \\\n-  (current_top_target ()->upload_trace_state_variables) (utsvp)\n+extern int target_upload_trace_state_variables (uploaded_tsv **utsvp);\n \n-#define target_get_raw_trace_data(buf,offset,len) \\\n-  (current_top_target ()->get_raw_trace_data) ((buf), (offset), (len))\n+extern LONGEST target_get_raw_trace_data (gdb_byte *buf, ULONGEST offset,\n+\t\t\t\t\t  LONGEST len);\n \n-#define target_get_min_fast_tracepoint_insn_len() \\\n-  (current_top_target ()->get_min_fast_tracepoint_insn_len) ()\n+extern int target_get_min_fast_tracepoint_insn_len ();\n \n-#define target_set_disconnected_tracing(val) \\\n-  (current_top_target ()->set_disconnected_tracing) (val)\n+extern void target_set_disconnected_tracing (int val);\n \n-#define\ttarget_set_circular_trace_buffer(val)\t\\\n-  (current_top_target ()->set_circular_trace_buffer) (val)\n+extern void target_set_circular_trace_buffer (int val);\n \n-#define\ttarget_set_trace_buffer_size(val)\t\\\n-  (current_top_target ()->set_trace_buffer_size) (val)\n+extern void target_set_trace_buffer_size (LONGEST val);\n \n-#define\ttarget_set_trace_notes(user,notes,stopnotes)\t\t\\\n-  (current_top_target ()->set_trace_notes) ((user), (notes), (stopnotes))\n+extern bool target_set_trace_notes (const char *user, const char *notes,\n+\t\t\t\t    const char *stopnotes);\n \n-#define target_get_tib_address(ptid, addr) \\\n-  (current_top_target ()->get_tib_address) ((ptid), (addr))\n+extern bool target_get_tib_address (ptid_t ptid, CORE_ADDR *addr);\n \n-#define target_set_permissions() \\\n-  (current_top_target ()->set_permissions) ()\n+extern void target_set_permissions ();\n \n-#define target_static_tracepoint_marker_at(addr, marker) \\\n-  (current_top_target ()->static_tracepoint_marker_at) (addr, marker)\n+extern bool target_static_tracepoint_marker_at\n+  (CORE_ADDR addr, static_tracepoint_marker *marker);\n \n-#define target_static_tracepoint_markers_by_strid(marker_id) \\\n-  (current_top_target ()->static_tracepoint_markers_by_strid) (marker_id)\n+extern std::vector<static_tracepoint_marker>\n+  target_static_tracepoint_markers_by_strid (const char *marker_id);\n \n-#define target_traceframe_info() \\\n-  (current_top_target ()->traceframe_info) ()\n+extern traceframe_info_up target_traceframe_info ();\n \n-#define target_use_agent(use) \\\n-  (current_top_target ()->use_agent) (use)\n+extern bool target_use_agent (bool use);\n \n-#define target_can_use_agent() \\\n-  (current_top_target ()->can_use_agent) ()\n+extern bool target_can_use_agent ();\n \n-#define target_augmented_libraries_svr4_read() \\\n-  (current_top_target ()->augmented_libraries_svr4_read) ()\n+extern bool target_augmented_libraries_svr4_read ();\n \n-#define target_supports_memory_tagging() \\\n-  ((current_top_target ()->supports_memory_tagging) ())\n+extern bool target_supports_memory_tagging ();\n \n-#define target_fetch_memtags(address, len, tags, type) \\\n-  (current_top_target ()->fetch_memtags) ((address), (len), (tags), (type))\n+extern bool target_fetch_memtags (CORE_ADDR address, size_t len,\n+\t\t\t\t  gdb::byte_vector &tags, int type);\n \n-#define target_store_memtags(address, len, tags, type) \\\n-  (current_top_target ()->store_memtags) ((address), (len), (tags), (type))\n+extern bool target_store_memtags (CORE_ADDR address, size_t len,\n+\t\t\t\t  const gdb::byte_vector &tags, int type);\n \n /* Command logging facility.  */\n \n-#define target_log_command(p)\t\t\t\t\t\\\n-  (current_top_target ()->log_command) (p)\n-\n+extern void target_log_command (const char *p);\n \n extern int target_core_of_thread (ptid_t ptid);\n "
    },
    {
      "sha": "0200a111c92148ee9e65878a7049894406cefe23",
      "filename": "gdb/tui/tui-stack.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/tui/tui-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d777bf0df22f1048fd24999ae563e30abcbcfbe7/gdb/tui/tui-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-stack.c?ref=d777bf0df22f1048fd24999ae563e30abcbcfbe7",
      "patch": "@@ -77,7 +77,7 @@ tui_locator_window::make_status_line () const\n       pid_name = pid_name_holder.c_str ();\n     }\n \n-  target_width = strlen (target_shortname);\n+  target_width = strlen (target_shortname ());\n   if (target_width > MAX_TARGET_WIDTH)\n     target_width = MAX_TARGET_WIDTH;\n \n@@ -149,7 +149,7 @@ tui_locator_window::make_status_line () const\n   string_file string;\n \n   if (target_width > 0)\n-    string.printf (\"%*.*s \", -target_width, target_width, target_shortname);\n+    string.printf (\"%*.*s \", -target_width, target_width, target_shortname ());\n   if (pid_width > 0)\n     string.printf (\"%*.*s \", -pid_width, pid_width, pid_name);\n "
    }
  ]
}