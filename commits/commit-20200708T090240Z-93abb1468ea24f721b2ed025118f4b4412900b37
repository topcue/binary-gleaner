{
  "sha": "93abb1468ea24f721b2ed025118f4b4412900b37",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTNhYmIxNDY4ZWEyNGY3MjFiMmVkMDI1MTE4ZjRiNDQxMjkwMGIzNw==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2020-07-08T09:02:40Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2020-07-08T09:02:40Z"
    },
    "message": "x86: re-work operand handling for 5-operand XOP insns\n\nThere's no need for custom operand handling here, except for the VEX.W\ncontrolled operand swapping and the printing of the remaining 4-bit\nimmediate. VEX.W can be handled just like 4-operand insns.\n\nAlso take the opportunity and drop the stray indirection through\nvex_w_table[].",
    "tree": {
      "sha": "1ea662b1c30a00dd9fa3affe57e37ae3291f7082",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1ea662b1c30a00dd9fa3affe57e37ae3291f7082"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/93abb1468ea24f721b2ed025118f4b4412900b37",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/93abb1468ea24f721b2ed025118f4b4412900b37",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/93abb1468ea24f721b2ed025118f4b4412900b37",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/93abb1468ea24f721b2ed025118f4b4412900b37/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b13b1bc05435d2b8b2f1a0f48eba127a7c99fbb4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b13b1bc05435d2b8b2f1a0f48eba127a7c99fbb4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b13b1bc05435d2b8b2f1a0f48eba127a7c99fbb4"
    }
  ],
  "stats": {
    "total": 213,
    "additions": 19,
    "deletions": 194
  },
  "files": [
    {
      "sha": "18605c849bb9ec492330c1e5dfac7e767c91779a",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93abb1468ea24f721b2ed025118f4b4412900b37/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93abb1468ea24f721b2ed025118f4b4412900b37/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=93abb1468ea24f721b2ed025118f4b4412900b37",
      "patch": "@@ -1,3 +1,13 @@\n+2020-07-08  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-dis.c (OP_EX_VexImmW, OP_XMM_VexW, EXVexImmW, XMVexW,\n+\tVEX_W_0F3A48_P_2, VEX_W_0F3A49_P_2, vex_w_done, get_vex_imm8,\n+\tOP_EX_VexReg): Delete.\n+\t(OP_VexI4, VexI4): New.\n+\t(vex_w_table): Move vpermil2ps and vpermil2pd entries ...\n+\t(prefix_table): ... here.\n+\t(print_insn): Drop setting of vex_w_done.\n+\n 2020-07-08  Jan Beulich  <jbeulich@suse.com>\n \n \t* i386-dis.c (OP_EX_VexW, EXVexW, EXdVexW, EXqVexW): Delete."
    },
    {
      "sha": "1e4c75cdc5fa0351867f0a692877872bf6664501",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 9,
      "deletions": 194,
      "changes": 203,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93abb1468ea24f721b2ed025118f4b4412900b37/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93abb1468ea24f721b2ed025118f4b4412900b37/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=93abb1468ea24f721b2ed025118f4b4412900b37",
      "patch": "@@ -89,11 +89,10 @@ static void OP_XS (int, int);\n static void OP_M (int, int);\n static void OP_VEX (int, int);\n static void OP_EX_Vex (int, int);\n-static void OP_EX_VexImmW (int, int);\n static void OP_XMM_Vex (int, int);\n-static void OP_XMM_VexW (int, int);\n static void OP_Rounding (int, int);\n static void OP_REG_VexI4 (int, int);\n+static void OP_VexI4 (int, int);\n static void PCLMUL_Fixup (int, int);\n static void VCMP_Fixup (int, int);\n static void VPCMP_Fixup (int, int);\n@@ -422,10 +421,9 @@ fetch_data (struct disassemble_info *info, bfd_byte *addr)\n #define VexGdq { OP_VEX, dq_mode }\n #define EXdVexScalarS { OP_EX_Vex, d_scalar_swap_mode }\n #define EXqVexScalarS { OP_EX_Vex, q_scalar_swap_mode }\n-#define EXVexImmW { OP_EX_VexImmW, x_mode }\n #define XMVexScalar { OP_XMM_Vex, scalar_mode }\n-#define XMVexW { OP_XMM_VexW, 0 }\n #define XMVexI4 { OP_REG_VexI4, x_mode }\n+#define VexI4 { OP_VexI4, 0 }\n #define PCLMUL { PCLMUL_Fixup, 0 }\n #define VCMP { VCMP_Fixup, 0 }\n #define VPCMP { VPCMP_Fixup, 0 }\n@@ -1944,8 +1942,6 @@ enum\n   VEX_W_0F3A38_P_2,\n   VEX_W_0F3A39_P_2,\n   VEX_W_0F3A46_P_2,\n-  VEX_W_0F3A48_P_2,\n-  VEX_W_0F3A49_P_2,\n   VEX_W_0F3A4A_P_2,\n   VEX_W_0F3A4B_P_2,\n   VEX_W_0F3A4C_P_2,\n@@ -2877,7 +2873,6 @@ static struct\n vex;\n static unsigned char need_vex;\n static unsigned char need_vex_reg;\n-static unsigned char vex_w_done;\n \n struct op\n   {\n@@ -6413,14 +6408,14 @@ static const struct dis386 prefix_table[][4] = {\n   {\n     { Bad_Opcode },\n     { Bad_Opcode },\n-    { VEX_W_TABLE (VEX_W_0F3A48_P_2) },\n+    { \"vpermil2ps\",\t{ XM, Vex, EXx, XMVexI4, VexI4 }, 0 },\n   },\n \n   /* PREFIX_VEX_0F3A49 */\n   {\n     { Bad_Opcode },\n     { Bad_Opcode },\n-    { VEX_W_TABLE (VEX_W_0F3A49_P_2) },\n+    { \"vpermil2pd\",\t{ XM, Vex, EXx, XMVexI4, VexI4 }, 0 },\n   },\n \n   /* PREFIX_VEX_0F3A4A */\n@@ -10020,16 +10015,6 @@ static const struct dis386 vex_w_table[][2] = {\n     /* VEX_W_0F3A46_P_2 */\n     { \"vperm2i128\",\t{ XM, Vex256, EXx, Ib }, 0 },\n   },\n-  {\n-    /* VEX_W_0F3A48_P_2 */\n-    { \"vpermil2ps\",\t{ XMVexW, Vex, EXVexImmW, EXVexImmW, EXVexImmW }, 0 },\n-    { \"vpermil2ps\",\t{ XMVexW, Vex, EXVexImmW, EXVexImmW, EXVexImmW }, 0 },\n-  },\n-  {\n-    /* VEX_W_0F3A49_P_2 */\n-    { \"vpermil2pd\",\t{ XMVexW, Vex, EXVexImmW, EXVexImmW, EXVexImmW }, 0 },\n-    { \"vpermil2pd\",\t{ XMVexW, Vex, EXVexImmW, EXVexImmW, EXVexImmW }, 0 },\n-  },\n   {\n     /* VEX_W_0F3A4A_P_2 */\n     { \"vblendvps\",\t{ XM, Vex, EXx, XMVexI4 }, 0 },\n@@ -11992,7 +11977,6 @@ print_insn (bfd_vma pc, disassemble_info *info)\n \n   need_vex = 0;\n   need_vex_reg = 0;\n-  vex_w_done = 0;\n   memset (&vex, 0, sizeof (vex));\n \n   if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n@@ -15865,175 +15849,6 @@ OP_VEX (int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n   oappend (names[reg]);\n }\n \n-/* Get the VEX immediate byte without moving codep.  */\n-\n-static unsigned char\n-get_vex_imm8 (int sizeflag, int opnum)\n-{\n-  int bytes_before_imm = 0;\n-\n-  if (modrm.mod != 3)\n-    {\n-      /* There are SIB/displacement bytes.  */\n-      if ((sizeflag & AFLAG) || address_mode == mode_64bit)\n-\t{\n-\t  /* 32/64 bit address mode */\n-\t  int base = modrm.rm;\n-\n-\t  /* Check SIB byte.  */\n-\t  if (base == 4)\n-\t    {\n-\t      FETCH_DATA (the_info, codep + 1);\n-\t      base = *codep & 7;\n-\t      /* When decoding the third source, don't increase\n-\t\t bytes_before_imm as this has already been incremented\n-\t\t by one in OP_E_memory while decoding the second\n-\t\t source operand.  */\n-\t      if (opnum == 0)\n-\t\tbytes_before_imm++;\n-\t    }\n-\n-\t  /* Don't increase bytes_before_imm when decoding the third source,\n-\t     it has already been incremented by OP_E_memory while decoding\n-\t     the second source operand.  */\n-\t  if (opnum == 0)\n-\t    {\n-\t      switch (modrm.mod)\n-\t\t{\n-\t\t  case 0:\n-\t\t    /* When modrm.rm == 5 or modrm.rm == 4 and base in\n-\t\t       SIB == 5, there is a 4 byte displacement.  */\n-\t\t    if (base != 5)\n-\t\t      /* No displacement. */\n-\t\t      break;\n-\t\t    /* Fall through.  */\n-\t\t  case 2:\n-\t\t    /* 4 byte displacement.  */\n-\t\t    bytes_before_imm += 4;\n-\t\t    break;\n-\t\t  case 1:\n-\t\t    /* 1 byte displacement.  */\n-\t\t    bytes_before_imm++;\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* 16 bit address mode */\n-\t  /* Don't increase bytes_before_imm when decoding the third source,\n-\t     it has already been incremented by OP_E_memory while decoding\n-\t     the second source operand.  */\n-\t  if (opnum == 0)\n-\t    {\n-\t      switch (modrm.mod)\n-\t\t{\n-\t\tcase 0:\n-\t\t  /* When modrm.rm == 6, there is a 2 byte displacement.  */\n-\t\t  if (modrm.rm != 6)\n-\t\t    /* No displacement. */\n-\t\t    break;\n-\t\t  /* Fall through.  */\n-\t\tcase 2:\n-\t\t  /* 2 byte displacement.  */\n-\t\t  bytes_before_imm += 2;\n-\t\t  break;\n-\t\tcase 1:\n-\t\t  /* 1 byte displacement: when decoding the third source,\n-\t\t     don't increase bytes_before_imm as this has already\n-\t\t     been incremented by one in OP_E_memory while decoding\n-\t\t     the second source operand.  */\n-\t\t  if (opnum == 0)\n-\t\t    bytes_before_imm++;\n-\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  FETCH_DATA (the_info, codep + bytes_before_imm + 1);\n-  return codep [bytes_before_imm];\n-}\n-\n-static void\n-OP_EX_VexReg (int bytemode, int sizeflag, int reg)\n-{\n-  const char **names;\n-\n-  if (reg == -1 && modrm.mod != 3)\n-    {\n-      OP_E_memory (bytemode, sizeflag);\n-      return;\n-    }\n-  else\n-    {\n-      if (reg == -1)\n-\t{\n-\t  reg = modrm.rm;\n-\t  USED_REX (REX_B);\n-\t  if (rex & REX_B)\n-\t    reg += 8;\n-\t}\n-      if (address_mode != mode_64bit)\n-\treg &= 7;\n-    }\n-\n-  switch (vex.length)\n-    {\n-    case 128:\n-      names = names_xmm;\n-      break;\n-    case 256:\n-      names = names_ymm;\n-      break;\n-    default:\n-      abort ();\n-    }\n-  oappend (names[reg]);\n-}\n-\n-static void\n-OP_EX_VexImmW (int bytemode, int sizeflag)\n-{\n-  int reg = -1;\n-  static unsigned char vex_imm8;\n-\n-  if (vex_w_done == 0)\n-    {\n-      vex_w_done = 1;\n-\n-      /* Skip mod/rm byte.  */\n-      MODRM_CHECK;\n-      codep++;\n-\n-      vex_imm8 = get_vex_imm8 (sizeflag, 0);\n-\n-      if (vex.w)\n-\t  reg = vex_imm8 >> 4;\n-\n-      OP_EX_VexReg (bytemode, sizeflag, reg);\n-    }\n-  else if (vex_w_done == 1)\n-    {\n-      vex_w_done = 2;\n-\n-      if (!vex.w)\n-\t  reg = vex_imm8 >> 4;\n-\n-      OP_EX_VexReg (bytemode, sizeflag, reg);\n-    }\n-  else\n-    {\n-      /* Output the imm8 directly.  */\n-      scratchbuf[0] = '$';\n-      print_operand_value (scratchbuf + 1, 1, vex_imm8 & 0xf);\n-      oappend_maybe_intel (scratchbuf);\n-      scratchbuf[0] = '\\0';\n-      codep++;\n-    }\n-}\n-\n static void\n OP_Vex_2src (int bytemode, int sizeflag)\n {\n@@ -16135,12 +15950,12 @@ OP_REG_VexI4 (int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n }\n \n static void\n-OP_XMM_VexW (int bytemode, int sizeflag)\n+OP_VexI4 (int bytemode ATTRIBUTE_UNUSED,\n+\t  int sizeflag ATTRIBUTE_UNUSED)\n {\n-  /* Turn off the REX.W bit since it is used for swapping operands\n-     now.  */\n-  rex &= ~REX_W;\n-  OP_XMM (bytemode, sizeflag);\n+  scratchbuf[0] = '$';\n+  print_operand_value (scratchbuf + 1, 1, codep[-1] & 0xf);\n+  oappend_maybe_intel (scratchbuf);\n }\n \n static void"
    }
  ]
}