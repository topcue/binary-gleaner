{
  "sha": "bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmYwYWVjY2U2ZWJjNzE4MmIwY2ZkMzY3NzNiY2E2MjJlMmExOWMzZQ==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T18:55:02Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T18:09:59Z"
    },
    "message": "Add memory tagging testcases\n\nAdd an AArch64-specific test and a more generic memory tagging test that\nother architectures can run.\n\nEven though architectures not supporting memory tagging can run the memory\ntagging tests, the runtime check will make the tests bail out early, as it\nwould make no sense to proceed without proper support.\n\nIt is also tricky to do any further runtime tests for memory tagging, given\nwe'd need to deal with tags, and those are arch-specific.  Therefore the\ntest in gdb.base is more of a smoke test.\n\nIf an architecture wants to implement memory tagging, then it makes sense to\nhave tests within gdb.arch instead.\n\ngdb/testsuite/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* gdb.arch/aarch64-mte.c: New file.\n\t* gdb.arch/aarch64-mte.exp: New test.\n\t* gdb.base/memtag.c: New file.\n\t* gdb.base/memtag.exp: New test.\n\t* lib/gdb.exp (supports_memtag): New function.",
    "tree": {
      "sha": "f5c548df37491eeb53910e3af8aa9bce3ff9c763",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f5c548df37491eeb53910e3af8aa9bce3ff9c763"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ce192338645499d4ed5a9a3a9f8105f0135a7cfd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ce192338645499d4ed5a9a3a9f8105f0135a7cfd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ce192338645499d4ed5a9a3a9f8105f0135a7cfd"
    }
  ],
  "stats": {
    "total": 589,
    "additions": 589,
    "deletions": 0
  },
  "files": [
    {
      "sha": "5bd09ce4fce7128c9502a2a15f72e34807e9627a",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -1,3 +1,11 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* gdb.arch/aarch64-mte.c: New file.\n+\t* gdb.arch/aarch64-mte.exp: New test.\n+\t* gdb.base/memtag.c: New file.\n+\t* gdb.base/memtag.exp: New test.\n+\t* lib/gdb.exp (supports_memtag): New function.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* gdb.base/options.exp: Adjust for new print options."
    },
    {
      "sha": "43401b666728d926a022a4a4fa10afaa7574f3bb",
      "filename": "gdb/testsuite/gdb.arch/aarch64-mte.c",
      "status": "added",
      "additions": 107,
      "deletions": 0,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.arch/aarch64-mte.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.arch/aarch64-mte.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/aarch64-mte.c?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -0,0 +1,107 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Exercise AArch64's Memory Tagging Extension with tagged pointers.  */\n+\n+/* This test was based on the documentation for the AArch64 Memory Tagging\n+   Extension from the Linux Kernel, found in the sources in\n+   Documentation/arm64/memory-tagging-extension.rst.  */\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/auxv.h>\n+#include <sys/mman.h>\n+#include <sys/prctl.h>\n+\n+/* From arch/arm64/include/uapi/asm/hwcap.h */\n+#define HWCAP2_MTE              (1 << 18)\n+\n+/* From arch/arm64/include/uapi/asm/mman.h */\n+#define PROT_MTE  0x20\n+\n+/* From include/uapi/linux/prctl.h */\n+#define PR_SET_TAGGED_ADDR_CTRL 55\n+#define PR_GET_TAGGED_ADDR_CTRL 56\n+#define PR_TAGGED_ADDR_ENABLE\t(1UL << 0)\n+#define PR_MTE_TCF_SHIFT\t1\n+#define PR_MTE_TCF_NONE\t\t(0UL << PR_MTE_TCF_SHIFT)\n+#define PR_MTE_TCF_SYNC\t\t(1UL << PR_MTE_TCF_SHIFT)\n+#define PR_MTE_TCF_ASYNC\t(2UL << PR_MTE_TCF_SHIFT)\n+#define PR_MTE_TCF_MASK\t\t(3UL << PR_MTE_TCF_SHIFT)\n+#define PR_MTE_TAG_SHIFT\t3\n+#define PR_MTE_TAG_MASK\t\t(0xffffUL << PR_MTE_TAG_SHIFT)\n+\n+void\n+access_memory (unsigned char *tagged_ptr, unsigned char *untagged_ptr)\n+{\n+  tagged_ptr[0] = 'a';\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  unsigned char *tagged_ptr;\n+  unsigned char *untagged_ptr;\n+  unsigned long page_sz = sysconf (_SC_PAGESIZE);\n+  unsigned long hwcap2 = getauxval(AT_HWCAP2);\n+\n+  /* Bail out if MTE is not supported.  */\n+  if (!(hwcap2 & HWCAP2_MTE))\n+    return 1;\n+\n+  /* Enable the tagged address ABI, synchronous MTE tag check faults and\n+     allow all non-zero tags in the randomly generated set.  */\n+  if (prctl (PR_SET_TAGGED_ADDR_CTRL,\n+\t     PR_TAGGED_ADDR_ENABLE | PR_MTE_TCF_SYNC\n+\t     | (0xfffe << PR_MTE_TAG_SHIFT),\n+\t     0, 0, 0))\n+    {\n+      perror (\"prctl () failed\");\n+      return 1;\n+    }\n+\n+  /* Create a mapping that will have PROT_MTE set.  */\n+  tagged_ptr = mmap (0, page_sz, PROT_READ | PROT_WRITE,\n+\t\t     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (tagged_ptr == MAP_FAILED)\n+    {\n+      perror (\"mmap () failed\");\n+      return 1;\n+    }\n+\n+  /* Create another mapping that won't have PROT_MTE set.  */\n+  untagged_ptr = mmap (0, page_sz, PROT_READ | PROT_WRITE,\n+\t\t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (untagged_ptr == MAP_FAILED)\n+    {\n+      perror (\"mmap () failed\");\n+      return 1;\n+    }\n+\n+  /* Enable MTE on the above anonymous mmap.  */\n+  if (mprotect (tagged_ptr, page_sz, PROT_READ | PROT_WRITE | PROT_MTE))\n+    {\n+      perror (\"mprotect () failed\");\n+      return 1;\n+    }\n+\n+  access_memory (tagged_ptr, untagged_ptr);\n+\n+  return 0;\n+}"
    },
    {
      "sha": "62dfc86374883d5d8aeea9ce70d86e28f968f1df",
      "filename": "gdb/testsuite/gdb.arch/aarch64-mte.exp",
      "status": "added",
      "additions": 370,
      "deletions": 0,
      "changes": 370,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.arch/aarch64-mte.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.arch/aarch64-mte.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.arch/aarch64-mte.exp?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -0,0 +1,370 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test a binary that uses MTE and exercise various MTE-related scenarios.\n+\n+global hex\n+global decimal\n+\n+# Return TAG in hex format with no leading zeroes.\n+proc get_hex_tag { tag } {\n+    return [format \"%x\" $tag]\n+}\n+\n+# Return TAG in the NN format where N is 4 bits of the byte.\n+proc get_tag_nn { tag } {\n+    return [format \"%02x\" $tag]\n+}\n+\n+# Return the address of PTR with a tag of TAG.\n+proc get_tagged_ptr { tag ptr } {\n+  set addr [get_hexadecimal_valueof $ptr -1]\n+  return [get_valueof \"/x\" \\\n+\t      \"${addr} & (0xf0ffffffffffffff) | ((unsigned long) ${tag} << 56)\" \\\n+\t      \"0\" \"fetch pointer ${ptr} with tag ${tag}\"]\n+}\n+\n+# Return the logical TAG from PTR.\n+proc get_ltag_from_ptr { ptr } {\n+  set addr [get_hexadecimal_valueof $ptr -1]\n+  return [get_valueof \"/x\" \"${addr} >> 56 & 0xf\" -1 \\\n+\t\t      \"fetch tag from pointer ${ptr}\"]\n+}\n+\n+if {![is_aarch64_target]} {\n+    verbose \"Skipping ${gdb_test_file_name}.\"\n+    return\n+}\n+\n+standard_testfile\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+# Targets that don't support memory tagging should not execute the\n+# runtime memory tagging tests.\n+if {![supports_memtag]} {\n+    unsupported \"memory tagging unsupported\"\n+    return -1\n+}\n+\n+gdb_breakpoint \"access_memory\"\n+\n+if [gdb_continue \"access_memory\"] {\n+    return -1\n+}\n+\n+# Fetch a known pointer to an area mapped with PROT_MTE.\n+set tagged_ptr_symbol \"tagged_ptr\"\n+set tagged_ptr_addr [get_hexadecimal_valueof $tagged_ptr_symbol -1]\n+\n+if {$tagged_ptr_addr == -1} {\n+    unresolved \"unexpected pointer or tag value\"\n+    return -1\n+}\n+\n+# Fetch a known pointer to an area not mapped with PROT_MTE.\n+set untagged_ptr_symbol \"untagged_ptr\"\n+set untagged_ptr_addr [get_hexadecimal_valueof $untagged_ptr_symbol -1]\n+\n+if {$untagged_ptr_addr == -1} {\n+    unresolved \"unexpected pointer or tag value\"\n+    return -1\n+}\n+\n+with_test_prefix \"literals\" {\n+    # Test inspecting an allocation tag from a pointer to a memory area that\n+    # is not mapped with PROT_MTE.\n+    set msg \"Address ${untagged_ptr_addr} not in a region mapped with a memory tagging flag\\.\"\n+    gdb_test \"memory-tag print-allocation-tag ${untagged_ptr_addr}\" $msg \\\n+\t     \"memory-tag print-allocation-tag with an untagged address\"\n+\n+    gdb_test \"memory-tag set-allocation-tag ${untagged_ptr_addr} 1 00\" $msg \\\n+\t     \"memory-tag set-allocation-tag with an untagged address\"\n+\n+    set addr_tagged 0\n+    set addr_tagged_valid 0\n+\n+    # Test setting and showing the logical tags for a literal address.\n+    for {set i 0} {$i < 32} {incr i} {\n+\twith_test_prefix \"tag ${i}\" {\n+\t    set addr_tagged [get_tagged_ptr $i ${tagged_ptr_addr}]\n+\t}\n+\n+\tset tag_hexnz [get_hex_tag [expr $i % 16]]\n+\tgdb_test \"memory-tag print-logical-tag ${addr_tagged}\" \\\n+\t\t \" = 0x${tag_hexnz}\" \\\n+\t\t \"print-logical-tag with tag ${i}\"\n+\n+\tset tag_hexnn [get_tag_nn $i]\n+\tgdb_test \"memory-tag with-logical-tag ${addr_tagged} ${tag_hexnn}\" \\\n+\t\t \" = \\\\(void \\\\*\\\\) ${addr_tagged}\" \\\n+\t\t \"with-logical-tag with tag ${i}\"\n+    }\n+\n+    set atag_msg \"Allocation tag\\\\(s\\\\) updated successfully\\.\"\n+    # Test setting and showing the allocation tags.\n+    for {set i 0} {$i < 32} {incr i} {\n+\n+\tset tag_hexnn [get_tag_nn $i]\n+\tgdb_test \"memory-tag set-allocation-tag ${tagged_ptr_addr} 1 ${tag_hexnn}\" \\\n+\t\t $atag_msg \\\n+\t\t \"set-allocation-tag with tag ${i}\"\n+\n+\tset tag_hexnz [get_hex_tag [expr $i % 16]]\n+\tgdb_test \"memory-tag print-allocation-tag ${tagged_ptr_addr}\" \" = 0x${tag_hexnz}\" \\\n+\t\t \"print-allocation-tag with tag ${i}\"\n+    }\n+\n+    # Test tag mismatches.\n+    with_test_prefix \"tag mismatches\" {\n+\tfor {set i 0} {$i < 32} {incr i} {\n+\n+\t    # Set the allocation tag to a known value.\n+\t    set tag_hexnn [get_tag_nn $i]\n+\t    gdb_test \"memory-tag set-allocation-tag ${tagged_ptr_addr} 1 ${tag_hexnn}\" \\\n+\t\t     $atag_msg \\\n+\t\t     \"set-allocation-tag with tag ${i}\"\n+\n+\t    set atag_hexnz [get_hex_tag [expr $i % 16]]\n+\n+\t    # Validate that the logical tag matches the allocation tag.\n+\t    with_test_prefix \"tag ${i}\" {\n+\t\tset addr_tagged [get_tagged_ptr $i ${tagged_ptr_addr}]\n+\t    }\n+\n+\t    gdb_test \"memory-tag check ${addr_tagged}\" \\\n+\t\t     \"Memory tags for address $hex match \\\\(0x${atag_hexnz}\\\\)\\.\" \\\n+\t\t     \"check match with tag ${i}\"\n+\n+\t    # Get a pointer with the logical tag that does not match the\n+\t    # allocation tag.\n+\t    set ltag [expr $i + 1]\n+\t    with_test_prefix \"fetch mismatch tag ${i}\" {\n+\t\tset addr_tagged [get_tagged_ptr $ltag ${tagged_ptr_addr}]\n+\t    }\n+\n+\t    # Validate that the logical tag does not match the allocation\n+\t    # tag.\n+\t    set ltag_hexnz [get_hex_tag [expr [expr $i + 1]% 16]]\n+\t    gdb_test \"memory-tag check ${addr_tagged}\" \\\n+\t\t     \"Logical tag \\\\(0x${ltag_hexnz}\\\\) does not match the allocation tag \\\\(0x${atag_hexnz}\\\\) for address $hex\\.\" \\\n+\t\t     \"check mismatch with tag ${i}\"\n+\t}\n+    }\n+}\n+\n+with_test_prefix \"symbolic\" {\n+    # Test inspecting an allocation tag from a pointer to a memory area that\n+    # is not mapped with PROT_MTE.\n+    set msg \"Address ${untagged_ptr_addr} not in a region mapped with a memory tagging flag\\.\"\n+    gdb_test \"memory-tag print-allocation-tag ${untagged_ptr_symbol}\" $msg \\\n+\t     \"memory-tag print-allocation-tag with an untagged address\"\n+\n+    gdb_test \"memory-tag set-allocation-tag ${untagged_ptr_symbol} 1 00\" $msg \\\n+\t     \"memory-tag set-allocation-tag with an untagged address\"\n+\n+    # Test setting and showing the logical tags for a literal address.\n+    for {set i 0} {$i < 32} {incr i} {\n+\tset addr_tagged 0\n+\n+\twith_test_prefix \"tag ${i}\" {\n+\t    set addr_tagged [get_tagged_ptr $i ${tagged_ptr_addr}]\n+\t    gdb_test_no_output \"set variable ${tagged_ptr_symbol} = ${addr_tagged}\" \\\n+\t\t\t       \"update value of symbol ${tagged_ptr_symbol}\"\n+\t}\n+\n+\tset tag_hexnz [get_hex_tag [expr $i % 16]]\n+\tgdb_test \"memory-tag print-logical-tag ${tagged_ptr_symbol}\" \\\n+\t\t \" = 0x${tag_hexnz}\" \\\n+\t\t \"print-logical-tag with tag ${i}\"\n+\n+\tset tag_hexnn [get_tag_nn $i]\n+\tgdb_test \"memory-tag with-logical-tag ${tagged_ptr_symbol} ${tag_hexnn}\" \\\n+\t\t \" = \\\\(void \\\\*\\\\) ${addr_tagged}\" \\\n+\t\t \"with-logical-tag with tag ${i}\"\n+    }\n+\n+    # Reset the tagged ptr to its original value\n+    gdb_test_no_output \"set variable ${tagged_ptr_symbol} = ${tagged_ptr_addr}\" \\\n+\t\t       \"reset ${tagged_ptr_symbol} to ${tagged_ptr_addr}\"\n+\n+    set atag_msg \"Allocation tag\\\\(s\\\\) updated successfully\\.\"\n+    # Test setting and showing the allocation tags.\n+    for {set i 0} {$i < 32} {incr i} {\n+\n+\tset tag_hexnn [get_tag_nn $i]\n+\tgdb_test \"memory-tag set-allocation-tag ${tagged_ptr_symbol} 1 ${tag_hexnn}\" \\\n+\t\t $atag_msg \\\n+\t\t \"set-allocation-tag with tag ${i}\"\n+\n+\tset tag_hexnz [get_hex_tag [expr $i % 16]]\n+\tgdb_test \"memory-tag print-allocation-tag ${tagged_ptr_symbol}\" \\\n+\t\t \" = 0x${tag_hexnz}\" \\\n+\t\t \"print-allocation-tag with tag ${i}\"\n+    }\n+\n+    # Test tag mismatches.\n+    with_test_prefix \"tag mismatches\" {\n+\tfor {set i 0} {$i < 32} {incr i} {\n+\n+\t    # Set the allocation tag to a known value (0).\n+\t    set tag_hexnn [get_tag_nn $i]\n+\t    gdb_test \"memory-tag set-allocation-tag ${tagged_ptr_symbol} 1 ${tag_hexnn}\" \\\n+\t\t     $atag_msg \\\n+\t\t     \"set-allocation-tag with tag ${i}\"\n+\n+\t    set atag_hexnz [get_hex_tag [expr $i % 16]]\n+\n+\t    # Validate that the logical tag matches the allocation tag.\n+\t    with_test_prefix \"tag ${i}\" {\n+\t\tset addr_tagged [get_tagged_ptr $i ${tagged_ptr_addr}]\n+\t    }\n+\n+\t    with_test_prefix \"tag ${i}\" {\n+\t\tgdb_test_no_output \"set variable ${tagged_ptr_symbol} = ${addr_tagged}\" \\\n+\t\t\t\t   \"set ${tagged_ptr_symbol} to a matching logical tag\"\n+\t    }\n+\n+\t    gdb_test \"memory-tag check ${tagged_ptr_symbol}\" \\\n+\t\t     \"Memory tags for address $hex match \\\\(0x${atag_hexnz}\\\\)\\.\" \\\n+\t\t     \"check match with tag ${i}\"\n+\n+\t    # Get a pointer with the logical tag that does not match the\n+\t    # allocation tag.\n+\t    set ltag [expr $i + 1]\n+\t    with_test_prefix \"fetch mismatch tag ${i}\" {\n+\t\tset addr_tagged [get_tagged_ptr $ltag ${tagged_ptr_addr}]\n+\t    }\n+\n+\t    with_test_prefix \"tag ${i}\" {\n+\t\tgdb_test_no_output \"set variable ${tagged_ptr_symbol} = ${addr_tagged}\" \\\n+\t\t\t\t   \"set ${tagged_ptr_symbol} to a mismatching logical tag\"\n+\t    }\n+\n+\t    # Validate that the logical tag does not match the allocation\n+\t    # tag.\n+\t    set ltag_hexnz [get_hex_tag [expr [expr $i + 1]% 16]]\n+\t    gdb_test \"memory-tag check ${tagged_ptr_symbol}\" \\\n+\t\t     \"Logical tag \\\\(0x${ltag_hexnz}\\\\) does not match the allocation tag \\\\(0x${atag_hexnz}\\\\) for address $hex\\.\" \\\n+\t\t     \"check mismatch with tag ${i}\"\n+\t}\n+\t# Reset the tagged ptr to its original value\n+\tgdb_test_no_output \"set variable ${tagged_ptr_symbol} = ${tagged_ptr_addr}\" \\\n+\t\t\t   \"reset ${tagged_ptr_symbol} to ${tagged_ptr_addr}\"\n+    }\n+}\n+\n+# Test the memory tagging extensions for the \"print\" command.\n+with_test_prefix \"print command\" {\n+    set untagged_ptr [get_tagged_ptr 0 ${tagged_ptr_addr}]\n+\n+    with_test_prefix \"fetch ltag\" {\n+\tset ltag [get_ltag_from_ptr ${tagged_ptr_addr}]\n+    }\n+\n+    if {$ltag == -1} {\n+\tunresolved \"unexpected tag value\"\n+\treturn -1\n+    }\n+\n+    set atag [expr [expr $ltag + 1] % 16]\n+    set atag_hexnn [get_tag_nn $atag]\n+\n+    gdb_test \"memory-tag set-allocation-tag ${tagged_ptr_symbol} 1 ${atag_hexnn}\" \\\n+\t     $atag_msg \\\n+\t     \"make atag and ltag different\"\n+\n+    set atag_hexnz [get_hex_tag $atag]\n+    gdb_test \"p/x ${tagged_ptr_symbol}\" \\\n+\t[multi_line \\\n+\t    \"Logical tag \\\\(${ltag}\\\\) does not match the allocation tag \\\\(0x${atag_hexnz}\\\\)\\.\" \\\n+\t    \"\\\\\\$\\[0-9\\]+ = ${untagged_ptr}\"] \\\n+\t    \"show tag mismatch\"\n+}\n+\n+# Test the memory tagging extensions for the \"x\" command.\n+with_test_prefix \"x command\" {\n+\n+    # Check if the allocation tags match what we expect.\n+    gdb_test \"x/gxm ${tagged_ptr_symbol}\" \\\n+\t[multi_line \\\n+\t    \"<Allocation Tag $hex for range \\\\\\[$hex,$hex\\\\)>\" \\\n+\t    \"$hex:\\[ \\t\\]+$hex\"] \\\n+\t\"outputs tag information\"\n+\n+    # Also make sure no tag information is output for memory areas without\n+    # PROT_MTE mappings.\n+    gdb_test \"x/gxm ${untagged_ptr_symbol}\" \\\n+\t     \"$hex:\\[ \\t\\]+$hex\" \\\n+\t     \"does not output tag information\"\n+}\n+\n+# Validate the presence of the MTE registers.\n+foreach reg {\"tag_ctl\" } {\n+    gdb_test \"info registers $reg\" \\\n+\t     \"$reg\\[ \\t\\]+$hex\\[ \\t\\]+$decimal\" \\\n+\t     \"register $reg available\"\n+}\n+\n+# Run until a crash and confirm GDB displays memory tag violation\n+# information.\n+gdb_test \"continue\" \\\n+    [multi_line \\\n+\t\"Program received signal SIGSEGV, Segmentation fault\" \\\n+\t\"Memory tag violation while accessing address $hex\" \\\n+\t\"Allocation tag $hex\" \\\n+\t\"Logical tag $hex\\.\" \\\n+\t\"$hex in access_memory \\\\(.*\\\\) at .*\" \\\n+\t\".*tagged_ptr\\\\\\[0\\\\\\] = 'a';\"] \\\n+\t \"display tag violation information\"\n+\n+# Restart to execute the async tag fault test.\n+with_test_prefix \"async\" {\n+    if ![runto_main] {\n+\tuntested \"could not run to main\"\n+\treturn -1\n+    }\n+\n+    gdb_breakpoint \"access_memory\"\n+\n+    if [gdb_continue \"access_memory\"] {\n+\tfail \"could not run to tagged memory test function\"\n+\treturn -1\n+    }\n+\n+    # Force a tag fault.\n+    gdb_test \"memory-tag set-allocation-tag tagged_ptr 1 05\" \\\n+\t     $atag_msg \\\n+\t     \"make atag and ltag different\"\n+\n+    # Force the tag fault to be async.\n+    gdb_test_no_output \"set \\$tag_ctl=0x7fff5\" \"set tag_ctl to async\"\n+\n+    # Run until a crash and confirm GDB displays memory tag violation\n+    # information for async mode\n+    gdb_test \"continue\" \\\n+\t[multi_line \\\n+\t    \"Program received signal SIGSEGV, Segmentation fault\" \\\n+\t    \"Memory tag violation\" \\\n+\t    \"Fault address unavailable\\.\" \\\n+\t    \"$hex in .* \\\\(.*\\\\) .*\"] \\\n+\t    \"display tag violation information\"\n+}"
    },
    {
      "sha": "8fbcca2d971399a9f55a04ff09940d80c80f7e66",
      "filename": "gdb/testsuite/gdb.base/memtag.c",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.base/memtag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.base/memtag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/memtag.c?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -0,0 +1,22 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  return 0;\n+}"
    },
    {
      "sha": "aa21f7f365426aba00cbe5ae0df3ea9d20ac9e0c",
      "filename": "gdb/testsuite/gdb.base/memtag.exp",
      "status": "added",
      "additions": 66,
      "deletions": 0,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.base/memtag.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/gdb.base/memtag.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/memtag.exp?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -0,0 +1,66 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Smoke testing for the various memory tagging commands in GDB.\n+\n+set u_msg \"Memory tagging not supported or disabled by the current architecture\\.\"\n+\n+standard_testfile\n+if {[prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}]} {\n+    return -1\n+}\n+\n+if {[target_info gdb_protocol] == \"extended-remote\"} {\n+    # Make sure we're disconnected, in case we're testing with an\n+    # extended-remote board, therefore already connected.\n+    gdb_test \"disconnect\" \".*\"\n+}\n+\n+# Test commands without running the program.\n+with_test_prefix \"before program execution\" {\n+    # These commands should all fails without a running program.\n+    foreach subcmd {\"with-logical-tag\" \"print-logical-tag\" \\\n+\t\t    \"set-allocation-tag\" \"print-allocation-tag\" \"check\"} {\n+\tgdb_test \"memory-tag $subcmd\" $u_msg\n+    }\n+}\n+\n+clean_restart $testfile\n+\n+if ![runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+# Targets that don't support memory tagging should not execute the\n+# runtime memory tagging tests.\n+if {![supports_memtag]} {\n+    unsupported \"memory tagging unsupported\"\n+    return -1\n+}\n+\n+# With the program running, try to use the memory tagging commands.\n+with_test_prefix \"during program execution\" {\n+    set msg \"Argument required \\\\(address or pointer\\\\)\\.\"\n+\n+    # Test the various memory-tag commands again.\n+    gdb_test \"memory-tag print-logical-tag\" $msg\n+    gdb_test \"memory-tag print-allocation-tag\" $msg\n+    gdb_test \"memory-tag with-logical-tag\" \\\n+\t     \"Argument required \\\\(<address> <tag>\\\\)\\.\"\n+    gdb_test \"memory-tag set-allocation-tag\" \\\n+\t     \"Argument required \\\\(<starting address> <length> <tag bytes>\\\\)\\.\"\n+    gdb_test \"memory-tag check\" $msg\n+}"
    },
    {
      "sha": "73fea3a104d922a6c248960209934b707c605f43",
      "filename": "gdb/testsuite/lib/gdb.exp",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/lib/gdb.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf0aecce6ebc7182b0cfd36773bca622e2a19c3e/gdb/testsuite/lib/gdb.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/gdb.exp?ref=bf0aecce6ebc7182b0cfd36773bca622e2a19c3e",
      "patch": "@@ -2748,6 +2748,22 @@ proc supports_get_siginfo_type {} {\n     }\n }\n \n+# Return 1 if memory tagging is supported at runtime, otherwise return 0.\n+\n+gdb_caching_proc supports_memtag {\n+    global gdb_prompt\n+\n+    gdb_test_multiple \"memory-tag check\" \"\" {\n+\t-re \"Memory tagging not supported or disabled by the current architecture\\..*$gdb_prompt $\" {\n+\t  return 0\n+\t}\n+\t-re \"Argument required \\\\(address or pointer\\\\).*$gdb_prompt $\" {\n+\t    return 1\n+\t}\n+    }\n+    return 0\n+}\n+\n # Return 1 if the target supports hardware single stepping.\n \n proc can_hardware_single_step {} {"
    }
  ]
}