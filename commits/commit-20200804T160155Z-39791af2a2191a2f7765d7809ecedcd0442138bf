{
  "sha": "39791af2a2191a2f7765d7809ecedcd0442138bf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mzk3OTFhZjJhMjE5MWEyZjc3NjVkNzgwOWVjZWRjZDA0NDIxMzhiZg==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-08-04T16:01:55Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-08-04T16:01:55Z"
    },
    "message": "gdb: support for eBPF\n\nThis patch adds basic support for the eBPF target: tdep and build\nmachinery.  The accompanying simulator is introduced in subsequent\npatches.\n\ngdb/ChangeLog:\n\n2020-08-04  Weimin Pan <weimin.pan@oracle.com>\n\t    Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* configure.tgt: Add entry for bpf-*-*.\n\t* Makefile.in (ALL_TARGET_OBS): Add bpf-tdep.o\n\t(ALLDEPFILES): Add bpf-tdep.c.\n\t* bpf-tdep.c: New file.\n\t* MAINTAINERS: Add bpf target and maintainer.\n\ngdb/doc/ChangeLog:\n\n2020-08-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* gdb.texinfo (Contributors): Add information for the eBPF\n\tsupport.\n\t(BPF): New section.",
    "tree": {
      "sha": "bb7328d6686a00b465206f118d8cb9f959b7e165",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bb7328d6686a00b465206f118d8cb9f959b7e165"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/39791af2a2191a2f7765d7809ecedcd0442138bf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/39791af2a2191a2f7765d7809ecedcd0442138bf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/39791af2a2191a2f7765d7809ecedcd0442138bf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/39791af2a2191a2f7765d7809ecedcd0442138bf/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "10c381b53f8d0295287b8205f170dfedd953993b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/10c381b53f8d0295287b8205f170dfedd953993b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/10c381b53f8d0295287b8205f170dfedd953993b"
    }
  ],
  "stats": {
    "total": 434,
    "additions": 434,
    "deletions": 0
  },
  "files": [
    {
      "sha": "3199a266d1b7f193416075376ddda3c969bd1bd7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -1,3 +1,13 @@\n+2020-08-04  Weimin Pan <weimin.pan@oracle.com>\n+\t    Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* configure.tgt: Add entry for bpf-*-*.\n+\t* Makefile.in (ALL_TARGET_OBS): Add bpf-tdep.o\n+\t(ALLDEPFILES): Add bpf-tdep.c.\n+\t* bpf-tdep.c: New file.\n+\t* MAINTAINERS: Add bpf target and maintainer.\n+\t* NEWS: Mention the support for the new target.\n+\n 2020-08-04  Tom de Vries  <tdevries@suse.de>\n \n \tPR symtab/23270"
    },
    {
      "sha": "9dd6f65b5c8e82e41bca2bfa1e5add2d60bbfcad",
      "filename": "gdb/MAINTAINERS",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/MAINTAINERS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/MAINTAINERS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/MAINTAINERS?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -247,6 +247,9 @@ the native maintainer when resolving ABI issues.\n \n \tavr\t\t--target=avr ,-Werror\n \n+\tbpf\t\t--target=bpf-unknown-none\n+\t\t\tJose E. Marchesi\tjose.marchesi@oracle.com\n+\n \tcris\t\t--target=cris-elf ,-Werror ,\n \t\t\t(sim does not build with -Werror)\n "
    },
    {
      "sha": "67dc9daf16a04ca08097408f4ca83ab398c88100",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -719,6 +719,7 @@ ALL_TARGET_OBS = \\\n \tavr-tdep.o \\\n \tbfin-linux-tdep.o \\\n \tbfin-tdep.o \\\n+\tbpf-tdep.o \\\n \tbsd-uthread.o \\\n \tcris-linux-tdep.o \\\n \tcris-tdep.o \\\n@@ -2147,6 +2148,7 @@ ALLDEPFILES = \\\n \tavr-tdep.c \\\n \tbfin-linux-tdep.c \\\n \tbfin-tdep.c \\\n+\tbpf-tdep.c \\\n \tbsd-kvm.c \\\n \tbsd-uthread.c \\\n \tcsky-linux-tdep.c \\"
    },
    {
      "sha": "0e2406fefc306f414032dd29e3761fd89d967f0b",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -107,6 +107,7 @@ alias [-a] [--] ALIAS = COMMAND [DEFAULT-ARGS...]\n * New targets\n \n GNU/Linux/RISC-V (gdbserver)\triscv*-*-linux*\n+BPF\t\t\t\tbpf-unknown-none\n \n * Python API\n "
    },
    {
      "sha": "4854325cd1542a3f63b8a764c68ec6c6911eb8d6",
      "filename": "gdb/bpf-tdep.c",
      "status": "added",
      "additions": 386,
      "deletions": 0,
      "changes": 386,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/bpf-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/bpf-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bpf-tdep.c?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -0,0 +1,386 @@\n+/* Target-dependent code for BPF.\n+\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"arch-utils.h\"\n+#include \"dis-asm.h\"\n+#include \"frame.h\"\n+#include \"frame-unwind.h\"\n+#include \"trad-frame.h\"\n+#include \"symtab.h\"\n+#include \"value.h\"\n+#include \"gdbcmd.h\"\n+#include \"breakpoint.h\"\n+#include \"inferior.h\"\n+#include \"regcache.h\"\n+#include \"target.h\"\n+#include \"dwarf2/frame.h\"\n+#include \"osabi.h\"\n+#include \"target-descriptions.h\"\n+#include \"remote.h\"\n+\n+\f\n+/* eBPF registers.  */\n+\n+enum bpf_regnum\n+{\n+  BPF_R0_REGNUM,\t\t/* return value */\n+  BPF_R1_REGNUM,\n+  BPF_R2_REGNUM,\n+  BPF_R3_REGNUM,\n+  BPF_R4_REGNUM,\n+  BPF_R5_REGNUM,\n+  BPF_R6_REGNUM,\n+  BPF_R7_REGNUM,\n+  BPF_R8_REGNUM,\n+  BPF_R9_REGNUM,\n+  BPF_R10_REGNUM,\t\t/* sp */\n+  BPF_PC_REGNUM,\n+};\n+\n+#define BPF_NUM_REGS\t(BPF_PC_REGNUM + 1)\n+\n+/* Target-dependent structure in gdbarch.  */\n+struct gdbarch_tdep\n+{\n+};\n+\n+\f\n+/* Internal debugging facilities.  */\n+\n+/* When this is set to non-zero debugging information will be\n+   printed.  */\n+\n+static unsigned int bpf_debug_flag = 0;\n+\n+/* The show callback for 'show debug bpf'.  */\n+\n+static void\n+show_bpf_debug (struct ui_file *file, int from_tty,\n+\t        struct cmd_list_element *c, const char *value)\n+{\n+  fprintf_filtered (file, _(\"Debugging of BPF is %s.\\n\"), value);\n+}\n+\n+\f\n+/* BPF registers.  */\n+\n+static const char *bpf_register_names[] =\n+{\n+  \"r0\",   \"r1\",  \"r2\",    \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",\n+  \"r8\",   \"r9\",  \"r10\",   \"pc\"\n+};\n+\n+/* Return the name of register REGNUM.  */\n+\n+static const char *\n+bpf_register_name (struct gdbarch *gdbarch, int reg)\n+{\n+  if (reg >= 0 && reg < BPF_NUM_REGS)\n+    return bpf_register_names[reg];\n+  return NULL;\n+}\n+\n+/* Return the GDB type of register REGNUM.  */\n+\n+static struct type *\n+bpf_register_type (struct gdbarch *gdbarch, int reg)\n+{\n+  if (reg == BPF_R10_REGNUM)\n+    return builtin_type (gdbarch)->builtin_data_ptr;\n+  else if (reg == BPF_PC_REGNUM)\n+    return builtin_type (gdbarch)->builtin_func_ptr;\n+  return builtin_type (gdbarch)->builtin_int64;\n+}\n+\n+/* Return the GDB register number corresponding to DWARF's REG.  */\n+\n+static int\n+bpf_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n+{\n+  if (reg >= 0 && reg < BPF_NUM_REGS)\n+    return reg;\n+  return -1;\n+}\n+\n+/* Implement the \"print_insn\" gdbarch method.  */\n+\n+static int\n+bpf_gdb_print_insn (bfd_vma memaddr, disassemble_info *info)\n+{\n+  info->symbols = NULL;\n+  return default_print_insn (memaddr, info);\n+}\n+\n+\f\n+/* Return PC of first real instruction of the function starting at\n+   START_PC.  */\n+\n+static CORE_ADDR\n+bpf_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)\n+{\n+  fprintf_unfiltered (gdb_stdlog,\n+\t\t      \"Skipping prologue: start_pc=%s\\n\",\n+\t\t      paddress (gdbarch, start_pc));\n+  /* XXX: to be completed.  */\n+  return start_pc + 0;\n+}\n+\n+\f\n+/* Frame unwinder.\n+\n+   XXX it is not clear how to unwind in eBPF, since the stack is not\n+   guaranteed to be contiguous, and therefore no relative stack\n+   addressing can be done in the callee in order to access the\n+   caller's stack frame.  To explore with xBPF, which will relax this\n+   restriction.  */\n+\n+/* Given THIS_FRAME, return its ID.  */\n+\n+static void\n+bpf_frame_this_id (struct frame_info *this_frame,\n+\t\t   void **this_prologue_cache,\n+\t\t   struct frame_id *this_id)\n+{\n+  /* Note that THIS_ID defaults to the outermost frame if we don't set\n+     anything here.  See frame.c:compute_frame_id.  */\n+}\n+\n+/* Return the reason why we can't unwind past THIS_FRAME.  */\n+\n+static enum unwind_stop_reason\n+bpf_frame_unwind_stop_reason (struct frame_info *this_frame,\n+\t\t\t      void **this_cache)\n+{\n+  return UNWIND_OUTERMOST;\n+}\n+\n+/* Ask THIS_FRAME to unwind its register.  */\n+\n+static struct value *\n+bpf_frame_prev_register (struct frame_info *this_frame,\n+\t\t\t void **this_prologue_cache, int regnum)\n+{\n+  return frame_unwind_got_register (this_frame, regnum, regnum);\n+}\n+\n+/* Frame unwinder machinery for BPF.  */\n+\n+static const struct frame_unwind bpf_frame_unwind =\n+{\n+  NORMAL_FRAME,\n+  bpf_frame_unwind_stop_reason,\n+  bpf_frame_this_id,\n+  bpf_frame_prev_register,\n+  NULL,\n+  default_frame_sniffer\n+};\n+\n+\f\n+/* Breakpoints.  */\n+\n+/* Enum describing the different kinds of breakpoints.  We currently\n+   just support one, implemented by the brkpt xbpf instruction.   */\n+\n+enum bpf_breakpoint_kinds\n+{\n+  BPF_BP_KIND_BRKPT = 0,\n+};\n+\n+/* Implement the breakpoint_kind_from_pc gdbarch method.  */\n+\n+static int\n+bpf_breakpoint_kind_from_pc (struct gdbarch *gdbarch, CORE_ADDR *start_pc)\n+{\n+  /* We support just one kind of breakpoint.  */\n+  return BPF_BP_KIND_BRKPT;\n+}\n+\n+/* Implement the sw_breakpoint_from_kind gdbarch method.  */\n+\n+static const gdb_byte *\n+bpf_sw_breakpoint_from_kind (struct gdbarch *gdbarch, int kind, int *size)\n+{\n+  static unsigned char brkpt_insn[]\n+    = {0x8c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n+\n+  switch (kind)\n+    {\n+    case BPF_BP_KIND_BRKPT:\n+      *size = 8;\n+      return brkpt_insn;\n+    default:\n+      gdb_assert_not_reached (\"unexpected BPF breakpoint kind\");\n+    }\n+}\n+\n+\f\n+/* Assuming THIS_FRAME is a dummy frame, return its frame ID.  */\n+\n+static struct frame_id\n+bpf_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)\n+{\n+  CORE_ADDR sp = get_frame_register_unsigned (this_frame,\n+\t\t\t\t\t      gdbarch_sp_regnum (gdbarch));\n+  return frame_id_build (sp, get_frame_pc (this_frame));\n+}\n+\n+/* Implement the push dummy call gdbarch callback.  */\n+\n+static CORE_ADDR\n+bpf_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n+\t\t     struct regcache *regcache, CORE_ADDR bp_addr,\n+\t\t     int nargs, struct value **args, CORE_ADDR sp,\n+\t\t     function_call_return_method return_method,\n+\t\t     CORE_ADDR struct_addr)\n+{\n+  fprintf_unfiltered (gdb_stdlog, \"Pushing dummy call: sp=%s\\n\",\n+\t\t      paddress (gdbarch, sp));\n+  /* XXX writeme  */\n+  return sp;\n+}\n+\n+/* Extract a function return value of TYPE from REGCACHE,\n+   and copy it into VALBUF.  */\n+\n+static void\n+bpf_extract_return_value (struct type *type, struct regcache *regcache,\n+\t\t\t  gdb_byte *valbuf)\n+{\n+  int len = TYPE_LENGTH (type);\n+  gdb_byte vbuf[8];\n+\n+  gdb_assert (len <= 8);\n+  regcache->cooked_read (BPF_R0_REGNUM, vbuf);\n+  memcpy (valbuf, vbuf + 8 - len, len);\n+}\n+\n+/* Store the function return value of type TYPE from VALBUF into REGNAME.  */\n+\n+static void\n+bpf_store_return_value (struct type *type, struct regcache *regcache,\n+\t\t\tconst gdb_byte *valbuf)\n+{\n+  int len = TYPE_LENGTH (type);\n+  gdb_byte vbuf[8];\n+\n+  gdb_assert (len <= 8);\n+  memset (vbuf, 0, sizeof (vbuf));\n+  memcpy (vbuf + 8 - len, valbuf, len);\n+  regcache->cooked_write (BPF_R0_REGNUM, vbuf);\n+}\n+\n+/* Handle function's return value.  */\n+\n+static enum return_value_convention\n+bpf_return_value (struct gdbarch *gdbarch, struct value *function,\n+\t\t  struct type *type, struct regcache *regcache,\n+\t\t  gdb_byte *readbuf, const gdb_byte *writebuf)\n+{\n+  int len = TYPE_LENGTH (type);\n+\n+  if (len > 8)\n+    return RETURN_VALUE_STRUCT_CONVENTION;\n+\n+  if (readbuf != NULL)\n+    bpf_extract_return_value (type, regcache, readbuf);\n+  if (writebuf != NULL)\n+    bpf_store_return_value (type, regcache, writebuf);\n+\n+  return RETURN_VALUE_REGISTER_CONVENTION;\n+}\n+\n+\f\n+/* Initialize the current architecture based on INFO.  If possible, re-use an\n+   architecture from ARCHES, which is a list of architectures already created\n+   during this debugging session.  */\n+\n+static struct gdbarch *\n+bpf_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n+{\n+  /* If there is already a candidate, use it.  */\n+  arches = gdbarch_list_lookup_by_info (arches, &info);\n+  if (arches != NULL)\n+    return arches->gdbarch;\n+\n+  /* Allocate space for the new architecture.  */\n+  struct gdbarch_tdep *tdep = XCNEW (struct gdbarch_tdep);\n+  struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n+\n+  /* Information about registers, etc.  */\n+  set_gdbarch_num_regs (gdbarch, BPF_NUM_REGS);\n+  set_gdbarch_register_name (gdbarch, bpf_register_name);\n+  set_gdbarch_register_type (gdbarch, bpf_register_type);\n+\n+  /* Register numbers of various important registers.  */\n+  set_gdbarch_sp_regnum (gdbarch, BPF_R10_REGNUM);\n+  set_gdbarch_pc_regnum (gdbarch, BPF_PC_REGNUM);\n+\n+  /* Map DWARF2 registers to GDB registers.  */\n+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, bpf_dwarf2_reg_to_regnum);\n+\n+  /* Call dummy code.  */\n+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);\n+  set_gdbarch_dummy_id (gdbarch, bpf_dummy_id);\n+  set_gdbarch_push_dummy_call (gdbarch, bpf_push_dummy_call);\n+\n+  /* Returning results.  */\n+  set_gdbarch_return_value (gdbarch, bpf_return_value);\n+\n+  /* Advance PC across function entry code.  */\n+  set_gdbarch_skip_prologue (gdbarch, bpf_skip_prologue);\n+\n+  /* Stack grows downward.  */\n+  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);\n+\n+  /* Breakpoint manipulation.  */\n+  set_gdbarch_breakpoint_kind_from_pc (gdbarch, bpf_breakpoint_kind_from_pc);\n+  set_gdbarch_sw_breakpoint_from_kind (gdbarch, bpf_sw_breakpoint_from_kind);\n+\n+  /* Frame handling.  */\n+  set_gdbarch_frame_args_skip (gdbarch, 8);\n+\n+  /* Disassembly.  */\n+  set_gdbarch_print_insn (gdbarch, bpf_gdb_print_insn);\n+\n+  /* Hook in ABI-specific overrides, if they have been registered.  */\n+  gdbarch_init_osabi (info, gdbarch);\n+\n+  /* Install unwinders.  */\n+  frame_unwind_append_unwinder (gdbarch, &bpf_frame_unwind);\n+\n+  return gdbarch;\n+}\n+\n+void _initialize_bpf_tdep ();\n+void\n+_initialize_bpf_tdep (void)\n+{\n+  register_gdbarch_init (bfd_arch_bpf, bpf_gdbarch_init);\n+\n+  /* Add commands 'set/show debug bpf'.  */\n+  add_setshow_zuinteger_cmd (\"bpf\", class_maintenance,\n+\t\t\t     &bpf_debug_flag,\n+\t\t\t     _(\"Set BPF debugging.\"),\n+\t\t\t     _(\"Show BPF debugging.\"),\n+\t\t\t     _(\"Enables BPF specific debugging output.\"),\n+\t\t\t     NULL,\n+\t\t\t     &show_bpf_debug,\n+\t\t\t     &setdebuglist, &showdebuglist);\n+}"
    },
    {
      "sha": "7e84eff444554905411645324cfccd2fa3a60318",
      "filename": "gdb/configure.tgt",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/configure.tgt?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -205,6 +205,11 @@ bfin-*-*)\n \tgdb_sim=../sim/bfin/libsim.a\n \t;;\n \n+bpf-*-*)\n+\t# Target: eBPF\n+\tgdb_target_obs=\"bpf-tdep.o\"\n+\t;;\n+\n cris*)\n \t# Target: CRIS\n \tgdb_target_obs=\"cris-tdep.o cris-linux-tdep.o linux-tdep.o solib-svr4.o\""
    },
    {
      "sha": "7d17b01c37471250db339f250c788af3daf4cf95",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -1,3 +1,9 @@\n+2020-08-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* gdb.texinfo (Contributors): Add information for the eBPF\n+\tsupport.\n+\t(BPF): New section.\n+\n 2020-07-28  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* python.texi (Unwinding Frames in Python): Update descriptions"
    },
    {
      "sha": "09317fa0bd03b62ebcace4e14c9235a24b8b5f85",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39791af2a2191a2f7765d7809ecedcd0442138bf/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=39791af2a2191a2f7765d7809ecedcd0442138bf",
      "patch": "@@ -557,6 +557,10 @@ Alessandro Forin and Per Bothner.  More recent ports have been the work\n of Jeremy Bennett, Franck Jullien, Stefan Wallentowitz and\n Stafford Horne.\n \n+Weimin Pan, David Faust and Jose E. Marchesi contributed support for\n+the Linux kernel BPF virtual architecture.  This work was sponsored by\n+Oracle.\n+\n @node Sample Session\n @chapter A Sample @value{GDBN} Session\n \n@@ -24381,6 +24385,7 @@ acceptable commands.\n @menu\n * ARC::                         Synopsys ARC\n * ARM::                         ARM\n+* BPF::                         eBPF\n * M68K::                        Motorola M68K\n * MicroBlaze::\t\t\tXilinx MicroBlaze\n * MIPS Embedded::               MIPS Embedded\n@@ -24515,6 +24520,22 @@ The default value is @code{all}.\n @end table\n @end table\n \n+@node BPF\n+@subsection BPF\n+\n+@table @code\n+@item target sim @r{[}@var{simargs}@r{]} @dots{}\n+The @value{GDBN} BPF simulator accepts the following optional arguments.\n+\n+@table @code\n+@item --skb-data-offset=@var{offset}\n+Tell the simulator the offset, measured in bytes, of the\n+@code{skb_data} field in the kernel @code{struct sk_buff} structure.\n+This offset is used by some BPF specific-purpose load/store\n+instructions.  Defaults to 0.\n+@end table\n+@end table\n+\n @node M68K\n @subsection M68k\n "
    }
  ]
}