{
  "sha": "2a61252965c91540133bece7deb92eb22e3cf929",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmE2MTI1Mjk2NWM5MTU0MDEzM2JlY2U3ZGViOTJlYjIyZTNjZjkyOQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-25T04:50:14Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-04-05T01:55:11Z"
    },
    "message": "Move completion parsing to parser_state\n\nThis moves the globals and functions related to parsing for completion\nto parser_state.  A new structure is introduced in order to return\ncompletion results from the parse back to\nparse_expression_for_completion.\n\ngdb/ChangeLog\n2019-04-04  Tom Tromey  <tom@tromey.com>\n\n\t* rust-exp.y (rust_parser::lex_identifier, rustyylex)\n\t(rust_parser::convert_ast_to_expression, rust_parse)\n\t(rust_lex_test_completion, rust_lex_tests): Update.\n\t* parser-defs.h (struct expr_completion_state): New.\n\t(struct parser_state) <parser_state>: Add completion parameter.\n\t<mark_struct_expression, mark_completion_tag>: New methods.\n\t<parse_completion, m_completion_state>: New members.\n\t(prefixify_expression, null_post_parser): Update.\n\t(mark_struct_expression, mark_completion_tag): Don't declare.\n\t* parse.c (parse_completion, expout_last_struct)\n\t(expout_tag_completion_type, expout_completion_name): Remove\n\tglobals.\n\t(parser_state::mark_struct_expression)\n\t(parser_state::mark_completion_tag): Now methods.\n\t(prefixify_expression): Add last_struct parameter.\n\t(prefixify_subexp): Likewise.\n\t(parse_exp_1): Update.\n\t(parse_exp_in_context): Add cstate parameter.  Update.\n\t(parse_expression_for_completion): Create an\n\texpr_completion_state.\n\t(null_post_parser): Add \"completion\" parameter.\n\t* p-exp.y: Update rules.\n\t(yylex): Update.\n\t* language.h (struct language_defn) <la_post_parser>: Add\n\t\"completing\" parameter.\n\t* go-exp.y: Update rules.\n\t(lex_one_token): Update.\n\t* expression.h (parse_completion): Don't declare.\n\t* d-exp.y: Update rules.\n\t(lex_one_token): Update rules.\n\t* c-exp.y: Update rules.\n\t(lex_one_token): Update.\n\t* ada-lang.c (resolve): Add \"parse_completion\" parameter.\n\t(resolve_subexp): Likewise.\n\t(ada_resolve_function): Likewise.",
    "tree": {
      "sha": "5774206de4966e8835801e71da5c6661b368dcec",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5774206de4966e8835801e71da5c6661b368dcec"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2a61252965c91540133bece7deb92eb22e3cf929",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a61252965c91540133bece7deb92eb22e3cf929",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2a61252965c91540133bece7deb92eb22e3cf929",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a61252965c91540133bece7deb92eb22e3cf929/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "43476f0b1b628352ad8e3064e50128cb3461d3d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43476f0b1b628352ad8e3064e50128cb3461d3d0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/43476f0b1b628352ad8e3064e50128cb3461d3d0"
    }
  ],
  "stats": {
    "total": 311,
    "additions": 188,
    "deletions": 123
  },
  "files": [
    {
      "sha": "7d415d29e10ce4d1a8fbf56ecf1dd61d15a3fd71",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -1,3 +1,41 @@\n+2019-04-04  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-exp.y (rust_parser::lex_identifier, rustyylex)\n+\t(rust_parser::convert_ast_to_expression, rust_parse)\n+\t(rust_lex_test_completion, rust_lex_tests): Update.\n+\t* parser-defs.h (struct expr_completion_state): New.\n+\t(struct parser_state) <parser_state>: Add completion parameter.\n+\t<mark_struct_expression, mark_completion_tag>: New methods.\n+\t<parse_completion, m_completion_state>: New members.\n+\t(prefixify_expression, null_post_parser): Update.\n+\t(mark_struct_expression, mark_completion_tag): Don't declare.\n+\t* parse.c (parse_completion, expout_last_struct)\n+\t(expout_tag_completion_type, expout_completion_name): Remove\n+\tglobals.\n+\t(parser_state::mark_struct_expression)\n+\t(parser_state::mark_completion_tag): Now methods.\n+\t(prefixify_expression): Add last_struct parameter.\n+\t(prefixify_subexp): Likewise.\n+\t(parse_exp_1): Update.\n+\t(parse_exp_in_context): Add cstate parameter.  Update.\n+\t(parse_expression_for_completion): Create an\n+\texpr_completion_state.\n+\t(null_post_parser): Add \"completion\" parameter.\n+\t* p-exp.y: Update rules.\n+\t(yylex): Update.\n+\t* language.h (struct language_defn) <la_post_parser>: Add\n+\t\"completing\" parameter.\n+\t* go-exp.y: Update rules.\n+\t(lex_one_token): Update.\n+\t* expression.h (parse_completion): Don't declare.\n+\t* d-exp.y: Update rules.\n+\t(lex_one_token): Update rules.\n+\t* c-exp.y: Update rules.\n+\t(lex_one_token): Update.\n+\t* ada-lang.c (resolve): Add \"parse_completion\" parameter.\n+\t(resolve_subexp): Likewise.\n+\t(ada_resolve_function): Likewise.\n+\n 2019-04-04  Tom Tromey  <tom@tromey.com>\n \n \t* parser-defs.h (struct parser_state) <start_arglist,"
    },
    {
      "sha": "6e1c2cbeb3dfbc8e07749357dbd1c78c281d65c1",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 19,
      "deletions": 16,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -125,7 +125,7 @@ static int num_defns_collected (struct obstack *);\n static struct block_symbol *defns_collected (struct obstack *, int);\n \n static struct value *resolve_subexp (expression_up *, int *, int,\n-                                     struct type *);\n+                                     struct type *, int);\n \n static void replace_operator_with_call (expression_up *, int, int, int,\n                                         struct symbol *, const struct block *);\n@@ -225,7 +225,7 @@ static int find_struct_field (const char *, struct type *, int,\n \n static int ada_resolve_function (struct block_symbol *, int,\n                                  struct value **, int, const char *,\n-                                 struct type *);\n+                                 struct type *, int);\n \n static int ada_is_direct_array_type (struct type *);\n \n@@ -3220,15 +3220,15 @@ ada_decoded_op_name (enum exp_opcode op)\n    return type is preferred.  May change (expand) *EXP.  */\n \n static void\n-resolve (expression_up *expp, int void_context_p)\n+resolve (expression_up *expp, int void_context_p, int parse_completion)\n {\n   struct type *context_type = NULL;\n   int pc = 0;\n \n   if (void_context_p)\n     context_type = builtin_type ((*expp)->gdbarch)->builtin_void;\n \n-  resolve_subexp (expp, &pc, 1, context_type);\n+  resolve_subexp (expp, &pc, 1, context_type, parse_completion);\n }\n \n /* Resolve the operator of the subexpression beginning at\n@@ -3242,7 +3242,7 @@ resolve (expression_up *expp, int void_context_p)\n \n static struct value *\n resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n-                struct type *context_type)\n+                struct type *context_type, int parse_completion)\n {\n   int pc = *pos;\n   int i;\n@@ -3267,19 +3267,20 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n       else\n         {\n           *pos += 3;\n-          resolve_subexp (expp, pos, 0, NULL);\n+          resolve_subexp (expp, pos, 0, NULL, parse_completion);\n         }\n       nargs = longest_to_int (exp->elts[pc + 1].longconst);\n       break;\n \n     case UNOP_ADDR:\n       *pos += 1;\n-      resolve_subexp (expp, pos, 0, NULL);\n+      resolve_subexp (expp, pos, 0, NULL, parse_completion);\n       break;\n \n     case UNOP_QUAL:\n       *pos += 3;\n-      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type));\n+      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type),\n+\t\t      parse_completion);\n       break;\n \n     case OP_ATR_MODULUS:\n@@ -3310,11 +3311,11 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n         struct value *arg1;\n \n         *pos += 1;\n-        arg1 = resolve_subexp (expp, pos, 0, NULL);\n+        arg1 = resolve_subexp (expp, pos, 0, NULL, parse_completion);\n         if (arg1 == NULL)\n-          resolve_subexp (expp, pos, 1, NULL);\n+          resolve_subexp (expp, pos, 1, NULL, parse_completion);\n         else\n-          resolve_subexp (expp, pos, 1, value_type (arg1));\n+          resolve_subexp (expp, pos, 1, value_type (arg1), parse_completion);\n         break;\n       }\n \n@@ -3402,7 +3403,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \n   argvec = XALLOCAVEC (struct value *, nargs + 1);\n   for (i = 0; i < nargs; i += 1)\n-    argvec[i] = resolve_subexp (expp, pos, 1, NULL);\n+    argvec[i] = resolve_subexp (expp, pos, 1, NULL, parse_completion);\n   argvec[i] = NULL;\n   exp = expp->get ();\n \n@@ -3471,7 +3472,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n               i = ada_resolve_function\n                 (candidates.data (), n_candidates, NULL, 0,\n                  SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),\n-                 context_type);\n+                 context_type, parse_completion);\n               if (i < 0)\n                 error (_(\"Could not find a match for %s\"),\n                        SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n@@ -3522,7 +3523,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n                   (candidates.data (), n_candidates,\n                    argvec, nargs,\n                    SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),\n-                   context_type);\n+                   context_type, parse_completion);\n                 if (i < 0)\n                   error (_(\"Could not find a match for %s\"),\n                          SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));\n@@ -3566,7 +3567,8 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n                                     &candidates);\n \n           i = ada_resolve_function (candidates.data (), n_candidates, argvec,\n-\t\t\t\t    nargs, ada_decoded_op_name (op), NULL);\n+\t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n+\t\t\t\t    parse_completion);\n           if (i < 0)\n             break;\n \n@@ -3733,7 +3735,8 @@ return_match (struct type *func_type, struct type *context_type)\n static int\n ada_resolve_function (struct block_symbol syms[],\n                       int nsyms, struct value **args, int nargs,\n-                      const char *name, struct type *context_type)\n+                      const char *name, struct type *context_type,\n+\t\t      int parse_completion)\n {\n   int fallback;\n   int k;"
    },
    {
      "sha": "842b492e58af9c1559ec53f8b0dae06c8ea1603c",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 23,
      "deletions": 20,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -364,15 +364,15 @@ exp\t:\texp ARROW field_name\n \t;\n \n exp\t:\texp ARROW field_name COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n \t\t\t  write_exp_string (pstate, $3);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n \t;\n \n exp\t:\texp ARROW COMPLETE\n \t\t\t{ struct stoken s;\n-\t\t\t  mark_struct_expression (pstate);\n+\t\t\t  pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n \t\t\t  s.ptr = \"\";\n \t\t\t  s.length = 0;\n@@ -387,7 +387,7 @@ exp\t:\texp ARROW '~' name\n \t;\n \n exp\t:\texp ARROW '~' name COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n \t\t\t  write_destructor_name (pstate, $4);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n@@ -412,15 +412,15 @@ exp\t:\texp '.' field_name\n \t;\n \n exp\t:\texp '.' field_name COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  write_exp_string (pstate, $3);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n \t;\n \n exp\t:\texp '.' COMPLETE\n \t\t\t{ struct stoken s;\n-\t\t\t  mark_struct_expression (pstate);\n+\t\t\t  pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  s.ptr = \"\";\n \t\t\t  s.length = 0;\n@@ -435,7 +435,7 @@ exp\t:\texp '.' '~' name\n \t;\n \n exp\t:\texp '.' '~' name COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  write_destructor_name (pstate, $4);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n@@ -1406,13 +1406,14 @@ typebase\n \t\t\t}\n \t|\tSTRUCT COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, \"\", 0);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_STRUCT,\n+\t\t\t\t\t\t       \"\", 0);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tSTRUCT name COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, $2.ptr,\n-\t\t\t\t\t       $2.length);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_STRUCT,\n+\t\t\t\t\t\t       $2.ptr, $2.length);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tCLASS name\n@@ -1421,13 +1422,14 @@ typebase\n \t\t\t}\n \t|\tCLASS COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, \"\", 0);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_STRUCT,\n+\t\t\t\t\t\t       \"\", 0);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tCLASS name COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_STRUCT, $2.ptr,\n-\t\t\t\t\t       $2.length);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_STRUCT,\n+\t\t\t\t\t\t       $2.ptr, $2.length);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tUNION name\n@@ -1437,13 +1439,14 @@ typebase\n \t\t\t}\n \t|\tUNION COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_UNION, \"\", 0);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_UNION,\n+\t\t\t\t\t\t       \"\", 0);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tUNION name COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_UNION, $2.ptr,\n-\t\t\t\t\t       $2.length);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_UNION,\n+\t\t\t\t\t\t       $2.ptr, $2.length);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tENUM name\n@@ -1452,13 +1455,13 @@ typebase\n \t\t\t}\n \t|\tENUM COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_ENUM, \"\", 0);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_ENUM, \"\", 0);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tENUM name COMPLETE\n \t\t\t{\n-\t\t\t  mark_completion_tag (TYPE_CODE_ENUM, $2.ptr,\n-\t\t\t\t\t       $2.length);\n+\t\t\t  pstate->mark_completion_tag (TYPE_CODE_ENUM, $2.ptr,\n+\t\t\t\t\t\t       $2.length);\n \t\t\t  $$ = NULL;\n \t\t\t}\n \t|\tUNSIGNED type_name\n@@ -2608,7 +2611,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n \t  saw_name_at_eof = 0;\n \t  return COMPLETE;\n \t}\n-      else if (parse_completion && saw_structop)\n+      else if (par_state->parse_completion && saw_structop)\n \treturn COMPLETE;\n       else\n         return 0;\n@@ -2902,7 +2905,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   if (*tokstart == '$')\n     return DOLLAR_VARIABLE;\n \n-  if (parse_completion && *pstate->lexptr == '\\0')\n+  if (pstate->parse_completion && *pstate->lexptr == '\\0')\n     saw_name_at_eof = 1;\n \n   yylval.ssym.stoken = yylval.sval;"
    },
    {
      "sha": "4d51cfdcb7134a74ddeada5aa10bbd7ac3f91d1b",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -338,7 +338,7 @@ PostfixExpression:\n \tPrimaryExpression\n |\tPostfixExpression '.' COMPLETE\n \t\t{ struct stoken s;\n-\t\t  mark_struct_expression (pstate);\n+\t\t  pstate->mark_struct_expression ();\n \t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t  s.ptr = \"\";\n \t\t  s.length = 0;\n@@ -349,7 +349,7 @@ PostfixExpression:\n \t\t  write_exp_string (pstate, $3);\n \t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n |\tPostfixExpression '.' IDENTIFIER COMPLETE\n-\t\t{ mark_struct_expression (pstate);\n+\t\t{ pstate->mark_struct_expression ();\n \t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t  write_exp_string (pstate, $3);\n \t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n@@ -1107,7 +1107,7 @@ lex_one_token (struct parser_state *par_state)\n       /* Might be a floating point number.  */\n       if (pstate->lexptr[1] < '0' || pstate->lexptr[1] > '9')\n \t{\n-\t  if (parse_completion)\n+\t  if (pstate->parse_completion)\n \t    last_was_structop = 1;\n \t  goto symbol;\t\t/* Nope, must be a symbol.  */\n \t}\n@@ -1308,7 +1308,7 @@ lex_one_token (struct parser_state *par_state)\n \treturn NAME_OR_INT;\n     }\n \n-  if (parse_completion && *pstate->lexptr == '\\0')\n+  if (pstate->parse_completion && *pstate->lexptr == '\\0')\n     saw_name_at_eof = 1;\n \n   return IDENTIFIER;"
    },
    {
      "sha": "8ce8c3269e3e87c3b0b2bc240a3254e434854d48",
      "filename": "gdb/expression.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expression.h?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -123,10 +123,6 @@ extern expression_up parse_exp_1 (const char **, CORE_ADDR pc,\n \t\t\t\t  innermost_block_tracker_types\n \t\t\t\t    = INNERMOST_BLOCK_FOR_SYMBOLS);\n \n-/* For use by parsers; set if we want to parse an expression and\n-   attempt completion.  */\n-extern int parse_completion;\n-\n /* From eval.c */\n \n /* Values of NOSIDE argument to eval_subexp.  */"
    },
    {
      "sha": "771adc4416b8f1ebe907e64d8e4de85371b903a1",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -246,15 +246,15 @@ exp\t:\texp '.' name_not_typename\n \t;\n \n exp\t:\texp '.' name_not_typename COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  write_exp_string (pstate, $3.stoken);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n \t;\n \n exp\t:\texp '.' COMPLETE\n \t\t\t{ struct stoken s;\n-\t\t\t  mark_struct_expression (pstate);\n+\t\t\t  pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  s.ptr = \"\";\n \t\t\t  s.length = 0;\n@@ -1087,7 +1087,7 @@ lex_one_token (struct parser_state *par_state)\n       /* Might be a floating point number.  */\n       if (par_state->lexptr[1] < '0' || par_state->lexptr[1] > '9')\n \t{\n-\t  if (parse_completion)\n+\t  if (pstate->parse_completion)\n \t    last_was_structop = 1;\n \t  goto symbol;\t\t/* Nope, must be a symbol. */\n \t}\n@@ -1276,7 +1276,7 @@ lex_one_token (struct parser_state *par_state)\n   if (*tokstart == '$')\n     return DOLLAR_VARIABLE;\n \n-  if (parse_completion && *par_state->lexptr == '\\0')\n+  if (pstate->parse_completion && *par_state->lexptr == '\\0')\n     saw_name_at_eof = 1;\n   return NAME;\n }"
    },
    {
      "sha": "5fc175703a072a84bd427e5fe9443e5d02c11d81",
      "filename": "gdb/language.h",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/language.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/language.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.h?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -176,9 +176,12 @@ struct language_defn\n        la_parser, perform any remaining processing necessary to complete\n        its translation.  *EXPP may change; la_post_parser is responsible \n        for releasing its previous contents, if necessary.  If \n-       VOID_CONTEXT_P, then no value is expected from the expression.  */\n+       VOID_CONTEXT_P, then no value is expected from the expression.\n+       If COMPLETING is non-zero, then the expression has been parsed\n+       for completion, not evaluation.  */\n \n-    void (*la_post_parser) (expression_up *expp, int void_context_p);\n+    void (*la_post_parser) (expression_up *expp, int void_context_p,\n+\t\t\t    int completing);\n \n     void (*la_printchar) (int ch, struct type *chtype,\n \t\t\t  struct ui_file * stream);"
    },
    {
      "sha": "493876815d95e9b22f85519adb2dafa737fdfe96",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -285,14 +285,14 @@ exp\t:\tfield_exp name\n \t\t\t}\n \t;\n exp\t:\tfield_exp  name COMPLETE\n-\t\t\t{ mark_struct_expression (pstate);\n+\t\t\t{ pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  write_exp_string (pstate, $2);\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n \t;\n exp\t:\tfield_exp COMPLETE\n \t\t\t{ struct stoken s;\n-\t\t\t  mark_struct_expression (pstate);\n+\t\t\t  pstate->mark_struct_expression ();\n \t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \t\t\t  s.ptr = \"\";\n \t\t\t  s.length = 0;\n@@ -1162,7 +1162,7 @@ yylex (void)\n   switch (c = *tokstart)\n     {\n     case 0:\n-      if (search_field && parse_completion)\n+      if (search_field && pstate->parse_completion)\n \treturn COMPLETE;\n       else\n        return 0;"
    },
    {
      "sha": "7984a324fe0ea3a5859eec80a245f7cd1eaad8ea",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 42,
      "deletions": 51,
      "changes": 93,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -69,20 +69,6 @@ const struct exp_descriptor exp_descriptor_standard =\n innermost_block_tracker innermost_block;\n static struct type_stack type_stack;\n \n-/* True if parsing an expression to attempt completion.  */\n-int parse_completion;\n-\n-/* The index of the last struct expression directly before a '.' or\n-   '->'.  This is set when parsing and is only used when completing a\n-   field name.  It is -1 if no dereference operation was found.  */\n-static int expout_last_struct = -1;\n-\n-/* If we are completing a tagged type name, this will be nonzero.  */\n-static enum type_code expout_tag_completion_type = TYPE_CODE_UNDEF;\n-\n-/* The token for tagged type name completion.  */\n-static gdb::unique_xmalloc_ptr<char> expout_completion_name;\n-\n \f\n static unsigned int expressiondebug = 0;\n static void\n@@ -105,12 +91,13 @@ show_parserdebug (struct ui_file *file, int from_tty,\n \n \n static int prefixify_subexp (struct expression *, struct expression *, int,\n-\t\t\t     int);\n+\t\t\t     int, int);\n \n static expression_up parse_exp_in_context (const char **, CORE_ADDR,\n \t\t\t\t\t   const struct block *, int,\n \t\t\t\t\t   int, int *,\n-\t\t\t\t\t   innermost_block_tracker_types);\n+\t\t\t\t\t   innermost_block_tracker_types,\n+\t\t\t\t\t   expr_completion_state *);\n \n static void increase_expout_size (struct expr_builder *ps, size_t lenelt);\n \n@@ -507,33 +494,35 @@ write_exp_msymbol (struct expr_builder *ps,\n   write_exp_elt_opcode (ps, OP_VAR_MSYM_VALUE);\n }\n \n-/* Mark the current index as the starting location of a structure\n-   expression.  This is used when completing on field names.  */\n+/* See parser-defs.h.  */\n \n void\n-mark_struct_expression (struct expr_builder *ps)\n+parser_state::mark_struct_expression ()\n {\n   gdb_assert (parse_completion\n-\t      && expout_tag_completion_type == TYPE_CODE_UNDEF);\n-  expout_last_struct = ps->expout_ptr;\n+\t      && (m_completion_state.expout_tag_completion_type\n+\t\t  == TYPE_CODE_UNDEF));\n+  m_completion_state.expout_last_struct = expout_ptr;\n }\n \n /* Indicate that the current parser invocation is completing a tag.\n    TAG is the type code of the tag, and PTR and LENGTH represent the\n    start of the tag name.  */\n \n void\n-mark_completion_tag (enum type_code tag, const char *ptr, int length)\n+parser_state::mark_completion_tag (enum type_code tag, const char *ptr,\n+\t\t\t\t   int length)\n {\n   gdb_assert (parse_completion\n-\t      && expout_tag_completion_type == TYPE_CODE_UNDEF\n-\t      && expout_completion_name == NULL\n-\t      && expout_last_struct == -1);\n+\t      && (m_completion_state.expout_tag_completion_type\n+\t\t  == TYPE_CODE_UNDEF)\n+\t      && m_completion_state.expout_completion_name == NULL\n+\t      && m_completion_state.expout_last_struct == -1);\n   gdb_assert (tag == TYPE_CODE_UNION\n \t      || tag == TYPE_CODE_STRUCT\n \t      || tag == TYPE_CODE_ENUM);\n-  expout_tag_completion_type = tag;\n-  expout_completion_name.reset (xstrndup (ptr, length));\n+  m_completion_state.expout_tag_completion_type = tag;\n+  m_completion_state.expout_completion_name.reset (xstrndup (ptr, length));\n }\n \n \f\n@@ -755,7 +744,7 @@ copy_name (struct stoken token)\n /* See comments on parser-defs.h.  */\n \n int\n-prefixify_expression (struct expression *expr)\n+prefixify_expression (struct expression *expr, int last_struct)\n {\n   gdb_assert (expr->nelts > 0);\n   int len = sizeof (struct expression) + EXP_ELEM_TO_BYTES (expr->nelts);\n@@ -767,7 +756,7 @@ prefixify_expression (struct expression *expr)\n   /* Copy the original expression into temp.  */\n   memcpy (temp, expr, len);\n \n-  return prefixify_subexp (temp, expr, inpos, outpos);\n+  return prefixify_subexp (temp, expr, inpos, outpos, last_struct);\n }\n \n /* Return the number of exp_elements in the postfix subexpression \n@@ -987,13 +976,14 @@ operator_length_standard (const struct expression *expr, int endpos,\n /* Copy the subexpression ending just before index INEND in INEXPR\n    into OUTEXPR, starting at index OUTBEG.\n    In the process, convert it from suffix to prefix form.\n-   If EXPOUT_LAST_STRUCT is -1, then this function always returns -1.\n+   If LAST_STRUCT is -1, then this function always returns -1.\n    Otherwise, it returns the index of the subexpression which is the\n-   left-hand-side of the expression at EXPOUT_LAST_STRUCT.  */\n+   left-hand-side of the expression at LAST_STRUCT.  */\n \n static int\n prefixify_subexp (struct expression *inexpr,\n-\t\t  struct expression *outexpr, int inend, int outbeg)\n+\t\t  struct expression *outexpr, int inend, int outbeg,\n+\t\t  int last_struct)\n {\n   int oplen;\n   int args;\n@@ -1010,7 +1000,7 @@ prefixify_subexp (struct expression *inexpr,\n \t  EXP_ELEM_TO_BYTES (oplen));\n   outbeg += oplen;\n \n-  if (expout_last_struct == inend)\n+  if (last_struct == inend)\n     result = outbeg - oplen;\n \n   /* Find the lengths of the arg subexpressions.  */\n@@ -1034,7 +1024,7 @@ prefixify_subexp (struct expression *inexpr,\n \n       oplen = arglens[i];\n       inend += oplen;\n-      r = prefixify_subexp (inexpr, outexpr, inend, outbeg);\n+      r = prefixify_subexp (inexpr, outexpr, inend, outbeg, last_struct);\n       if (r != -1)\n \t{\n \t  /* Return immediately.  We probably have only parsed a\n@@ -1063,7 +1053,7 @@ parse_exp_1 (const char **stringptr, CORE_ADDR pc, const struct block *block,\n \t     int comma, innermost_block_tracker_types tracker_types)\n {\n   return parse_exp_in_context (stringptr, pc, block, comma, 0, NULL,\n-\t\t\t       tracker_types);\n+\t\t\t       tracker_types, nullptr);\n }\n \n /* As for parse_exp_1, except that if VOID_CONTEXT_P, then\n@@ -1077,15 +1067,13 @@ static expression_up\n parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n \t\t      const struct block *block,\n \t\t      int comma, int void_context_p, int *out_subexp,\n-\t\t      innermost_block_tracker_types tracker_types)\n+\t\t      innermost_block_tracker_types tracker_types,\n+\t\t      expr_completion_state *cstate)\n {\n   const struct language_defn *lang = NULL;\n   int subexp;\n \n   type_stack.elements.clear ();\n-  expout_last_struct = -1;\n-  expout_tag_completion_type = TYPE_CODE_UNDEF;\n-  expout_completion_name.reset ();\n   innermost_block.reset (tracker_types);\n \n   if (*stringptr == 0 || **stringptr == 0)\n@@ -1147,7 +1135,8 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n      to the value matching SELECTED_FRAME as set by get_current_arch.  */\n \n   parser_state ps (lang, get_current_arch (), expression_context_block,\n-\t\t   expression_context_pc, comma, *stringptr);\n+\t\t   expression_context_pc, comma, *stringptr,\n+\t\t   cstate != nullptr);\n \n   scoped_restore_current_language lang_saver;\n   set_language (lang->la_language);\n@@ -1161,7 +1150,7 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n       /* If parsing for completion, allow this to succeed; but if no\n \t expression elements have been written, then there's nothing\n \t to do, so fail.  */\n-      if (! parse_completion || ps.expout_ptr == 0)\n+      if (! ps.parse_completion || ps.expout_ptr == 0)\n \tthrow_exception (except);\n     }\n   END_CATCH\n@@ -1177,15 +1166,18 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n     dump_raw_expression (result.get (), gdb_stdlog,\n \t\t\t \"before conversion to prefix form\");\n \n-  subexp = prefixify_expression (result.get ());\n+  subexp = prefixify_expression (result.get (),\n+\t\t\t\t ps.m_completion_state.expout_last_struct);\n   if (out_subexp)\n     *out_subexp = subexp;\n \n-  lang->la_post_parser (&result, void_context_p);\n+  lang->la_post_parser (&result, void_context_p, ps.parse_completion);\n \n   if (expressiondebug)\n     dump_prefix_expression (result.get (), gdb_stdlog);\n \n+  if (cstate != nullptr)\n+    *cstate = std::move (ps.m_completion_state);\n   *stringptr = ps.lexptr;\n   return result;\n }\n@@ -1233,31 +1225,30 @@ parse_expression_for_completion (const char *string,\n   expression_up exp;\n   struct value *val;\n   int subexp;\n+  expr_completion_state cstate;\n \n   TRY\n     {\n-      parse_completion = 1;\n       exp = parse_exp_in_context (&string, 0, 0, 0, 0, &subexp,\n-\t\t\t\t  INNERMOST_BLOCK_FOR_SYMBOLS);\n+\t\t\t\t  INNERMOST_BLOCK_FOR_SYMBOLS, &cstate);\n     }\n   CATCH (except, RETURN_MASK_ERROR)\n     {\n       /* Nothing, EXP remains NULL.  */\n     }\n   END_CATCH\n \n-  parse_completion = 0;\n   if (exp == NULL)\n     return NULL;\n \n-  if (expout_tag_completion_type != TYPE_CODE_UNDEF)\n+  if (cstate.expout_tag_completion_type != TYPE_CODE_UNDEF)\n     {\n-      *code = expout_tag_completion_type;\n-      *name = std::move (expout_completion_name);\n+      *code = cstate.expout_tag_completion_type;\n+      *name = std::move (cstate.expout_completion_name);\n       return NULL;\n     }\n \n-  if (expout_last_struct == -1)\n+  if (cstate.expout_last_struct == -1)\n     return NULL;\n \n   const char *fieldname = extract_field_op (exp.get (), &subexp);\n@@ -1278,7 +1269,7 @@ parse_expression_for_completion (const char *string,\n /* A post-parser that does nothing.  */\n \n void\n-null_post_parser (expression_up *exp, int void_context_p)\n+null_post_parser (expression_up *exp, int void_context_p, int completin)\n {\n }\n "
    },
    {
      "sha": "2c1ea15d05e7d9fae21c763d34b84f011e65bb51",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 42,
      "deletions": 11,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -76,6 +76,22 @@ struct expr_builder\n   size_t expout_ptr;\n };\n \n+/* This is used for expression completion.  */\n+\n+struct expr_completion_state\n+{\n+  /* The index of the last struct expression directly before a '.' or\n+     '->'.  This is set when parsing and is only used when completing a\n+     field name.  It is -1 if no dereference operation was found.  */\n+  int expout_last_struct = -1;\n+\n+  /* If we are completing a tagged type name, this will be nonzero.  */\n+  enum type_code expout_tag_completion_type = TYPE_CODE_UNDEF;\n+\n+  /* The token for tagged type name completion.  */\n+  gdb::unique_xmalloc_ptr<char> expout_completion_name;\n+};\n+\n /* An instance of this type is instantiated during expression parsing,\n    and passed to the appropriate parser.  It holds both inputs to the\n    parser, and result.  */\n@@ -90,12 +106,14 @@ struct parser_state : public expr_builder\n \t\tconst struct block *context_block,\n \t\tCORE_ADDR context_pc,\n \t\tint comma,\n-\t\tconst char *input)\n+\t\tconst char *input,\n+\t\tint completion)\n     : expr_builder (lang, gdbarch),\n       expression_context_block (context_block),\n       expression_context_pc (context_pc),\n       comma_terminates (comma),\n-      lexptr (input)\n+      lexptr (input),\n+      parse_completion (completion)\n   {\n   }\n \n@@ -121,6 +139,17 @@ struct parser_state : public expr_builder\n     return val;\n   }\n \n+  /* Mark the current index as the starting location of a structure\n+     expression.  This is used when completing on field names.  */\n+\n+  void mark_struct_expression ();\n+\n+  /* Indicate that the current parser invocation is completing a tag.\n+     TAG is the type code of the tag, and PTR and LENGTH represent the\n+     start of the tag name.  */\n+\n+  void mark_completion_tag (enum type_code tag, const char *ptr, int length);\n+\n \n   /* If this is nonzero, this block is used as the lexical context for\n      symbol names.  */\n@@ -151,6 +180,12 @@ struct parser_state : public expr_builder\n \n   int arglist_len = 0;\n \n+  /* True if parsing an expression to attempt completion.  */\n+  int parse_completion;\n+\n+  /* Completion state is updated here.  */\n+  expr_completion_state m_completion_state;\n+\n private:\n \n   /* Data structure for saving values of arglist_len for function calls whose\n@@ -300,12 +335,13 @@ struct type_stack\n \n /* Reverse an expression from suffix form (in which it is constructed)\n    to prefix form (in which we can conveniently print or execute it).\n-   Ordinarily this always returns -1.  However, if EXPOUT_LAST_STRUCT\n+   Ordinarily this always returns -1.  However, if LAST_STRUCT\n    is not -1 (i.e., we are trying to complete a field name), it will\n    return the index of the subexpression which is the left-hand-side\n-   of the struct operation at EXPOUT_LAST_STRUCT.  */\n+   of the struct operation at LAST_STRUCT.  */\n \n-extern int prefixify_expression (struct expression *expr);\n+extern int prefixify_expression (struct expression *expr,\n+\t\t\t\t int last_struct = -1);\n \n extern void write_exp_elt_opcode (struct expr_builder *, enum exp_opcode);\n \n@@ -336,8 +372,6 @@ extern void write_exp_msymbol (struct expr_builder *,\n \n extern void write_dollar_variable (struct parser_state *, struct stoken str);\n \n-extern void mark_struct_expression (struct expr_builder *);\n-\n extern const char *find_template_name_end (const char *);\n \n extern char *copy_name (struct stoken);\n@@ -384,7 +418,7 @@ extern struct type *follow_types (struct type *);\n \n extern type_instance_flags follow_type_instance_flags ();\n \n-extern void null_post_parser (expression_up *, int);\n+extern void null_post_parser (expression_up *, int, int);\n \n extern bool parse_float (const char *p, int len,\n \t\t\t const struct type *type, gdb_byte *data);\n@@ -483,8 +517,5 @@ extern void parser_fprintf (FILE *, const char *, ...) ATTRIBUTE_PRINTF (2, 3);\n \n extern int exp_uses_objfile (struct expression *exp, struct objfile *objfile);\n \n-extern void mark_completion_tag (enum type_code, const char *ptr,\n-\t\t\t\t int length);\n-\n #endif /* PARSER_DEFS_H */\n "
    },
    {
      "sha": "999ab25f070ee427fc5b65d9a2931c7d2b0b45ed",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a61252965c91540133bece7deb92eb22e3cf929/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a61252965c91540133bece7deb92eb22e3cf929/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=2a61252965c91540133bece7deb92eb22e3cf929",
      "patch": "@@ -1438,10 +1438,10 @@ rust_parser::lex_identifier (YYSTYPE *lvalp)\n       return 0;\n     }\n \n-  if (token == NULL || (parse_completion && pstate->lexptr[0] == '\\0'))\n+  if (token == NULL || (pstate->parse_completion && pstate->lexptr[0] == '\\0'))\n     lvalp->sval = make_stoken (copy_name (start, length));\n \n-  if (parse_completion && pstate->lexptr[0] == '\\0')\n+  if (pstate->parse_completion && pstate->lexptr[0] == '\\0')\n     {\n       /* Prevent rustyylex from returning two COMPLETE tokens.  */\n       pstate->prev_lexptr = pstate->lexptr;\n@@ -1650,7 +1650,7 @@ rustyylex (YYSTYPE *lvalp, rust_parser *parser)\n   pstate->prev_lexptr = pstate->lexptr;\n   if (pstate->lexptr[0] == '\\0')\n     {\n-      if (parse_completion)\n+      if (pstate->parse_completion)\n \t{\n \t  lvalp->sval = make_stoken (\"\");\n \t  return COMPLETE;\n@@ -2225,7 +2225,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \tconvert_ast_to_expression (operation->left.op, top);\n \n \tif (operation->completing)\n-\t  mark_struct_expression (pstate);\n+\t  pstate->mark_struct_expression ();\n \twrite_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n \twrite_exp_string (pstate, operation->right.sval);\n \twrite_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n@@ -2544,7 +2544,7 @@ rust_parse (struct parser_state *state)\n \n   result = rustyyparse (&parser);\n \n-  if (!result || (parse_completion && parser.rust_ast != NULL))\n+  if (!result || (state->parse_completion && parser.rust_ast != NULL))\n     parser.convert_ast_to_expression (parser.rust_ast, parser.rust_ast);\n \n   return result;\n@@ -2684,14 +2684,14 @@ rust_lex_test_completion (rust_parser *parser)\n {\n   const int expected[] = { IDENT, '.', COMPLETE, 0 };\n \n-  parse_completion = 1;\n+  parser->pstate->parse_completion = 1;\n \n   rust_lex_test_sequence (parser, \"something.wha\", ARRAY_SIZE (expected),\n \t\t\t  expected);\n   rust_lex_test_sequence (parser, \"something.\", ARRAY_SIZE (expected),\n \t\t\t  expected);\n \n-  parse_completion = 0;\n+  parser->pstate->parse_completion = 0;\n }\n \n /* Test pushback.  */\n@@ -2726,7 +2726,7 @@ rust_lex_tests (void)\n \n   // Set up dummy \"parser\", so that rust_type works.\n   struct parser_state ps (&rust_language_defn, target_gdbarch (),\n-\t\t\t  nullptr, 0, 0, nullptr);\n+\t\t\t  nullptr, 0, 0, nullptr, 0);\n   rust_parser parser (&ps);\n \n   rust_lex_test_one (&parser, \"\", 0);"
    }
  ]
}