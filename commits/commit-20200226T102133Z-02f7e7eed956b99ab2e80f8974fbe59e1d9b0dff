{
  "sha": "02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDJmN2U3ZWVkOTU2Yjk5YWIyZTgwZjg5NzRmYmU1OWUxZDliMGRmZg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-26T06:32:38Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-26T10:21:33Z"
    },
    "message": "Archive sanity checks\n\nAdds some sanity checking to size values read from file.\n\n\t* archive.c (do_slurp_bsd_armap): Increase minimum parsed_size, and\n\tbfd_set_error on failing test.  Don't bother changing bfd_error on\n\tfile read error.  Check symdef_count is multiple of BSD_SYMDEF_SIZE.\n\tCheck sym name is within string buffer.  Use size_t for some vars.\n\t(do_slurp_coff_armap): Use size_t for some variables, fix size of\n\tint_buf.  Don't change bfd_error on file read error.  Use\n\t_bfd_mul_overflow when calculating carsym buffer size.  Reorder\n\tcalculations to catch overflows before they occur.  malloc and\n\tfree raw armap rather than using bfd_alloc.  Read raw armap before\n\tallocating carsym+strings buffer.\n\t(_bfd_slurp_extended_name_table): Localize variables.  Check\n\tname size against file size.",
    "tree": {
      "sha": "bbf2050990524db353f484d2f8499d7d8252c6c9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bbf2050990524db353f484d2f8499d7d8252c6c9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cc4c4f40a2b46e355684e450f59154cece591c39",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc4c4f40a2b46e355684e450f59154cece591c39",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cc4c4f40a2b46e355684e450f59154cece591c39"
    }
  ],
  "stats": {
    "total": 171,
    "additions": 103,
    "deletions": 68
  },
  "files": [
    {
      "sha": "f0b7a4a238e00009299d564a86b3b7df0146bdcc",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
      "patch": "@@ -1,3 +1,18 @@\n+2020-02-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* archive.c (do_slurp_bsd_armap): Increase minimum parsed_size, and\n+\tbfd_set_error on failing test.  Don't bother changing bfd_error on\n+\tfile read error.  Check symdef_count is multiple of BSD_SYMDEF_SIZE.\n+\tCheck sym name is within string buffer.  Use size_t for some vars.\n+\t(do_slurp_coff_armap): Use size_t for some variables, fix size of\n+\tint_buf.  Don't change bfd_error on file read error.  Use\n+\t_bfd_mul_overflow when calculating carsym buffer size.  Reorder\n+\tcalculations to catch overflows before they occur.  malloc and\n+\tfree raw armap rather than using bfd_alloc.  Read raw armap before\n+\tallocating carsym+strings buffer.\n+\t(_bfd_slurp_extended_name_table): Localize variables.  Check\n+\tname size against file size.\n+\n 2020-02-26  Alan Modra  <amodra@gmail.com>\n \n \t* vms-lib.c (vms_lib_read_index): Release correct buffer."
    },
    {
      "sha": "71bc6a4323c999be30d551d42b05f013043276b8",
      "filename": "bfd/archive.c",
      "status": "modified",
      "additions": 88,
      "deletions": 68,
      "changes": 156,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff/bfd/archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff/bfd/archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/archive.c?ref=02f7e7eed956b99ab2e80f8974fbe59e1d9b0dff",
      "patch": "@@ -951,11 +951,12 @@ static bfd_boolean\n do_slurp_bsd_armap (bfd *abfd)\n {\n   struct areltdata *mapdata;\n-  unsigned int counter;\n+  size_t counter;\n   bfd_byte *raw_armap, *rbase;\n   struct artdata *ardata = bfd_ardata (abfd);\n   char *stringbase;\n-  bfd_size_type parsed_size, amt;\n+  bfd_size_type parsed_size;\n+  size_t amt, string_size;\n   carsym *set;\n \n   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n@@ -965,44 +966,51 @@ do_slurp_bsd_armap (bfd *abfd)\n   free (mapdata);\n   /* PR 17512: file: 883ff754.  */\n   /* PR 17512: file: 0458885f.  */\n-  if (parsed_size < 4)\n-    return FALSE;\n-\n-  raw_armap = (bfd_byte *) _bfd_alloc_and_read (abfd, parsed_size, parsed_size);\n-  if (raw_armap == NULL)\n+  if (parsed_size < BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE)\n     {\n-      if (bfd_get_error () != bfd_error_system_call)\n-\tbfd_set_error (bfd_error_malformed_archive);\n+      bfd_set_error (bfd_error_malformed_archive);\n       return FALSE;\n     }\n \n-  ardata->symdef_count = H_GET_32 (abfd, raw_armap) / BSD_SYMDEF_SIZE;\n-  if (ardata->symdef_count * BSD_SYMDEF_SIZE >\n-      parsed_size - BSD_SYMDEF_COUNT_SIZE)\n+  raw_armap = (bfd_byte *) _bfd_alloc_and_read (abfd, parsed_size, parsed_size);\n+  if (raw_armap == NULL)\n+    return FALSE;\n+\n+  parsed_size -= BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE;\n+  amt = H_GET_32 (abfd, raw_armap);\n+  if (amt > parsed_size\n+      || amt % BSD_SYMDEF_SIZE != 0)\n     {\n       /* Probably we're using the wrong byte ordering.  */\n       bfd_set_error (bfd_error_wrong_format);\n-      bfd_release (abfd, raw_armap);\n-      return FALSE;\n+      goto release_armap;\n     }\n \n   rbase = raw_armap + BSD_SYMDEF_COUNT_SIZE;\n-  stringbase = ((char *) rbase\n-\t\t+ ardata->symdef_count * BSD_SYMDEF_SIZE\n-\t\t+ BSD_STRING_COUNT_SIZE);\n-  amt = ardata->symdef_count * sizeof (carsym);\n-  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);\n-  if (!ardata->symdefs)\n+  stringbase = (char *) rbase + amt + BSD_STRING_COUNT_SIZE;\n+  string_size = parsed_size - amt;\n+\n+  ardata->symdef_count = amt / BSD_SYMDEF_SIZE;\n+  if (_bfd_mul_overflow (ardata->symdef_count, sizeof (carsym), &amt))\n     {\n-      bfd_release (abfd, raw_armap);\n-      return FALSE;\n+      bfd_set_error (bfd_error_no_memory);\n+      goto release_armap;\n     }\n+  ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);\n+  if (!ardata->symdefs)\n+    goto release_armap;\n \n   for (counter = 0, set = ardata->symdefs;\n        counter < ardata->symdef_count;\n        counter++, set++, rbase += BSD_SYMDEF_SIZE)\n     {\n-      set->name = H_GET_32 (abfd, rbase) + stringbase;\n+      unsigned nameoff = H_GET_32 (abfd, rbase);\n+      if (nameoff >= string_size)\n+\t{\n+\t  bfd_set_error (bfd_error_malformed_archive);\n+\t  goto release_armap;\n+\t}\n+      set->name = stringbase + nameoff;\n       set->file_offset = H_GET_32 (abfd, rbase + BSD_SYMDEF_OFFSET_SIZE);\n     }\n \n@@ -1014,6 +1022,12 @@ do_slurp_bsd_armap (bfd *abfd)\n      to be allocated on an objalloc anyway...  */\n   abfd->has_armap = TRUE;\n   return TRUE;\n+\n+ release_armap:\n+  ardata->symdef_count = 0;\n+  ardata->symdefs = NULL;\n+  bfd_release (abfd, raw_armap);\n+  return FALSE;\n }\n \n /* Read a COFF archive symbol table.  Returns FALSE on error, TRUE\n@@ -1029,12 +1043,12 @@ do_slurp_coff_armap (bfd *abfd)\n   char *stringend;\n   bfd_size_type stringsize;\n   bfd_size_type parsed_size;\n+  ufile_ptr filesize;\n+  size_t nsymz, carsym_size, ptrsize, i;\n   carsym *carsyms;\n-  bfd_size_type nsymz;\t\t/* Number of symbols in armap.  */\n   bfd_vma (*swap) (const void *);\n-  char int_buf[sizeof (long)];\n-  bfd_size_type carsym_size, ptrsize;\n-  unsigned int i;\n+  char int_buf[4];\n+  struct areltdata *tmp;\n \n   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n   if (mapdata == NULL)\n@@ -1043,51 +1057,54 @@ do_slurp_coff_armap (bfd *abfd)\n   free (mapdata);\n \n   if (bfd_bread (int_buf, 4, abfd) != 4)\n-    {\n-      if (bfd_get_error () != bfd_error_system_call)\n-\tbfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n-    }\n+    return FALSE;\n+\n   /* It seems that all numeric information in a coff archive is always\n-     in big endian format, nomatter the host or target.  */\n+     in big endian format, no matter the host or target.  */\n   swap = bfd_getb32;\n   nsymz = bfd_getb32 (int_buf);\n-  stringsize = parsed_size - (4 * nsymz) - 4;\n \n   /* The coff armap must be read sequentially.  So we construct a\n      bsd-style one in core all at once, for simplicity.  */\n \n-  if (nsymz > ~ (bfd_size_type) 0 / sizeof (carsym))\n+  if (_bfd_mul_overflow (nsymz, sizeof (carsym), &carsym_size))\n     {\n       bfd_set_error (bfd_error_no_memory);\n       return FALSE;\n     }\n \n-  carsym_size = (nsymz * sizeof (carsym));\n-  ptrsize = (4 * nsymz);\n+  filesize = bfd_get_file_size (abfd);\n+  ptrsize = 4 * nsymz;\n+  if ((filesize != 0 && parsed_size > filesize)\n+      || parsed_size < 4\n+      || parsed_size - 4 < ptrsize)\n+    {\n+      bfd_set_error (bfd_error_malformed_archive);\n+      return FALSE;\n+    }\n+\n+  stringsize = parsed_size - ptrsize - 4;\n \n   if (carsym_size + stringsize + 1 <= carsym_size)\n     {\n       bfd_set_error (bfd_error_no_memory);\n       return FALSE;\n     }\n \n+  /* Allocate and read in the raw offsets.  */\n+  raw_armap = (int *) _bfd_malloc_and_read (abfd, ptrsize, ptrsize);\n+  if (raw_armap == NULL)\n+    return FALSE;\n+\n   ardata->symdefs = (struct carsym *) bfd_alloc (abfd,\n \t\t\t\t\t\t carsym_size + stringsize + 1);\n   if (ardata->symdefs == NULL)\n-    return FALSE;\n+    goto free_armap;\n   carsyms = ardata->symdefs;\n   stringbase = ((char *) ardata->symdefs) + carsym_size;\n \n-  /* Allocate and read in the raw offsets.  */\n-  raw_armap = (int *) _bfd_alloc_and_read (abfd, ptrsize, ptrsize);\n-  if (raw_armap == NULL\n-      || (bfd_bread (stringbase, stringsize, abfd) != stringsize))\n-    {\n-      if (bfd_get_error () != bfd_error_system_call)\n-\tbfd_set_error (bfd_error_malformed_archive);\n-      goto release_symdefs;\n-    }\n+  if (bfd_bread (stringbase, stringsize, abfd) != stringsize)\n+    goto release_symdefs;\n \n   /* OK, build the carsyms.  */\n   stringend = stringbase + stringsize;\n@@ -1107,32 +1124,29 @@ do_slurp_coff_armap (bfd *abfd)\n   ardata->first_file_filepos = bfd_tell (abfd);\n   /* Pad to an even boundary if you have to.  */\n   ardata->first_file_filepos += (ardata->first_file_filepos) % 2;\n+  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) != 0)\n+    goto release_symdefs;\n \n   abfd->has_armap = TRUE;\n-  bfd_release (abfd, raw_armap);\n+  free (raw_armap);\n \n   /* Check for a second archive header (as used by PE).  */\n-  {\n-    struct areltdata *tmp;\n-\n-    bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET);\n-    tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n-    if (tmp != NULL)\n-      {\n-\tif (tmp->arch_header[0] == '/'\n-\t    && tmp->arch_header[1] == ' ')\n-\t  {\n-\t    ardata->first_file_filepos +=\n-\t      (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~(unsigned) 1;\n-\t  }\n-\tfree (tmp);\n-      }\n-  }\n+  tmp = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n+  if (tmp != NULL)\n+    {\n+      if (tmp->arch_header[0] == '/'\n+\t  && tmp->arch_header[1] == ' ')\n+\tardata->first_file_filepos\n+\t  += (tmp->parsed_size + sizeof (struct ar_hdr) + 1) & ~(unsigned) 1;\n+      free (tmp);\n+    }\n \n   return TRUE;\n \n  release_symdefs:\n   bfd_release (abfd, (ardata)->symdefs);\n+ free_armap:\n+  free (raw_armap);\n   return FALSE;\n }\n \n@@ -1209,8 +1223,6 @@ bfd_boolean\n _bfd_slurp_extended_name_table (bfd *abfd)\n {\n   char nextname[17];\n-  struct areltdata *namedata;\n-  bfd_size_type amt;\n \n   /* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,\n      we probably don't want to return TRUE.  */\n@@ -1219,6 +1231,10 @@ _bfd_slurp_extended_name_table (bfd *abfd)\n \n   if (bfd_bread (nextname, 16, abfd) == 16)\n     {\n+      struct areltdata *namedata;\n+      bfd_size_type amt;\n+      ufile_ptr filesize;\n+\n       if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)\n \treturn FALSE;\n \n@@ -1234,9 +1250,13 @@ _bfd_slurp_extended_name_table (bfd *abfd)\n       if (namedata == NULL)\n \treturn FALSE;\n \n+      filesize = bfd_get_file_size (abfd);\n       amt = namedata->parsed_size;\n-      if (amt + 1 == 0)\n-\tgoto byebye;\n+      if (amt + 1 == 0 || (filesize != 0 && amt > filesize))\n+\t{\n+\t  bfd_set_error (bfd_error_malformed_archive);\n+\t  goto byebye;\n+\t}\n \n       bfd_ardata (abfd)->extended_names_size = amt;\n       bfd_ardata (abfd)->extended_names = (char *) bfd_alloc (abfd, amt + 1);"
    }
  ]
}