{
  "sha": "991a3e2e9944a4b3a27bd989ac03c18285bd545d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTkxYTNlMmU5OTQ0YTRiM2EyN2JkOTg5YWMwM2MxODI4NWJkNTQ1ZA==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-04-25T03:32:44Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-04-27T12:04:55Z"
    },
    "message": "Fix remaining inline/tailcall unwinding breakage for x86_64\n\nCommit 5939967b355ba6a940887d19847b7893a4506067 fixed inline\nframe unwinding breakage for some targets (aarch64, riscv, s390...)\nbut regressed a few amd64 testcases related to tailcalls.\n\nGiven the following example situation...\n\nFrame #-1 - sentinel frame\nFrame # 0 - inline frame\nFrame # 1 - normal frame\n\n... suppose we're at level #1 and call into dwarf2_tailcall_sniffer_first.\n\nWe'll attempt to fetch PC, which used to be done via the gdbarch_unwind_pc call\n(before 5939967b355ba6a940887d19847b7893a4506067), but now it is being handled\nby the get_frame_register function.\n\ngdbarch_unwind_pc will attempt to use frame #1's cache to retrieve information\nabout the PC. Here's where different architectures behave differently.\n\nx86_64 will find a dwarf rule to retrieve PC from memory, at a CFA + offset\nlocation. So the PC value is readily available and there is no need to\ncreate a lazy value.\n\nFor aarch64 (and others), GCC doesn't emit an explicit location for PC, so we\neventually will find that PC is DWARF2_FRAME_REG_UNSPECIFIED. This is known\nand is handled by GDB by assuming GCC really meant DWARF2_FRAME_REG_SAME_VALUE.\n\nThis means we'll attempt to fetch the register value from frame #0, via a call\nto frame_unwind_got_register, which will trigger the creation of a lazy value\nthat requires a valid frame id for frame #0.\n\nWe don't have a valid id for frame #0 yet, so we assert.\n\nGiven the above, the following patch attempts to handle the situation without\nbeing too hacky. We verify if the next frame is an inline frame and if its\nframe id has been computed already. If it hasn't been computed yet, then we\nuse the safer get_frame_register function, otherwise we use the regular\ngdbarch_unwind_pc hook.\n\ngdb/ChangeLog:\n\n2020-04-27  Luis Machado  <luis.machado@linaro.org>\n\n\t* dwarf2/frame-tailcall.c (dwarf2_tailcall_sniffer_first): Handle\n\tproblematic inline frame unwinding situation.\n\t* frame.c (frame_id_computed_p): New function.\n\t* frame.h (frame_id_computed_p): New prototype.",
    "tree": {
      "sha": "eeb5a348ca16d779b3e32ef4d12c678d55a3a569",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/eeb5a348ca16d779b3e32ef4d12c678d55a3a569"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/991a3e2e9944a4b3a27bd989ac03c18285bd545d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/991a3e2e9944a4b3a27bd989ac03c18285bd545d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/991a3e2e9944a4b3a27bd989ac03c18285bd545d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/991a3e2e9944a4b3a27bd989ac03c18285bd545d/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/714e6c969ff1ce0fdb0cd3703d41ef2fef424535",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/714e6c969ff1ce0fdb0cd3703d41ef2fef424535"
    }
  ],
  "stats": {
    "total": 58,
    "additions": 55,
    "deletions": 3
  },
  "files": [
    {
      "sha": "b076a45a9a1d28c64aefe17ffe961c4987d2fe94",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=991a3e2e9944a4b3a27bd989ac03c18285bd545d",
      "patch": "@@ -1,3 +1,10 @@\n+2020-04-27  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* dwarf2/frame-tailcall.c (dwarf2_tailcall_sniffer_first): Handle\n+\tproblematic inline frame unwinding situation.\n+\t* frame.c (frame_id_computed_p): New function.\n+\t* frame.h (frame_id_computed_p): New prototype.\n+\n 2020-04-26  Tom Tromey  <tom@tromey.com>\n \n \t* command.h (enum command_class) <class_pseudo>: Remove."
    },
    {
      "sha": "16dba2b201ac62e35c35c5adac1146aca4875254",
      "filename": "gdb/dwarf2/frame-tailcall.c",
      "status": "modified",
      "additions": 36,
      "deletions": 3,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/dwarf2/frame-tailcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/dwarf2/frame-tailcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame-tailcall.c?ref=991a3e2e9944a4b3a27bd989ac03c18285bd545d",
      "patch": "@@ -384,10 +384,43 @@ dwarf2_tailcall_sniffer_first (struct frame_info *this_frame,\n \n       prev_gdbarch = frame_unwind_arch (this_frame);\n \n+      /* The dwarf2 tailcall sniffer runs early, at the end of populating the\n+\t dwarf2 frame cache for the current frame.  If there exists inline\n+\t frames inner (next) to the current frame, there is a good possibility\n+\t of that inline frame not having a computed frame id yet.\n+\n+\t This is because computing such a frame id requires us to walk through\n+\t the frame chain until we find the first normal frame after the inline\n+\t frame and then compute the normal frame's id first.\n+\n+\t Some architectures' compilers generate enough register location\n+\t information for a dwarf unwinder to fetch PC without relying on inner\n+\t frames (x86_64 for example).  In this case the PC is retrieved\n+\t according to dwarf rules.\n+\n+\t But others generate less strict dwarf data for which assumptions are\n+\t made (like interpreting DWARF2_FRAME_REG_UNSPECIFIED as\n+\t DWARF2_FRAME_REG_SAME_VALUE).  For such cases, GDB may attempt to\n+\t create lazy values for registers, and those lazy values must be\n+\t created with a valid frame id, but we potentially have no valid id.\n+\n+\t So, to avoid breakage, if we see a dangerous situation with inline\n+\t frames without a computed id, use safer functions to retrieve the\n+\t current frame's PC.  Otherwise use the provided dwarf rules.  */\n+      frame_info *next_frame = get_next_frame (this_frame);\n+\n       /* Simulate frame_unwind_pc without setting this_frame->prev_pc.p.  */\n-      get_frame_register (this_frame, gdbarch_pc_regnum (prev_gdbarch),\n-\t\t\t  (gdb_byte *) &prev_pc);\n-      prev_pc = gdbarch_addr_bits_remove (prev_gdbarch, prev_pc);\n+      if (next_frame != nullptr && get_frame_type (next_frame) == INLINE_FRAME\n+\t  && !frame_id_computed_p (next_frame))\n+\t{\n+\t  /* The next frame is an inline frame and its frame id has not been\n+\t     computed yet.  */\n+\t  get_frame_register (this_frame, gdbarch_pc_regnum (prev_gdbarch),\n+\t\t\t      (gdb_byte *) &prev_pc);\n+\t  prev_pc = gdbarch_addr_bits_remove (prev_gdbarch, prev_pc);\n+\t}\n+      else\n+\tprev_pc = gdbarch_unwind_pc (prev_gdbarch, this_frame);\n \n       /* call_site_find_chain can throw an exception.  */\n       chain = call_site_find_chain (prev_gdbarch, prev_pc, this_pc);"
    },
    {
      "sha": "ff27b9f00e9f73bef6fe0a7a946b716f180ce5dc",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=991a3e2e9944a4b3a27bd989ac03c18285bd545d",
      "patch": "@@ -687,6 +687,14 @@ frame_id_build_wild (CORE_ADDR stack_addr)\n   return id;\n }\n \n+bool\n+frame_id_computed_p (struct frame_info *frame)\n+{\n+  gdb_assert (frame != nullptr);\n+\n+  return frame->this_id.p != 0;\n+}\n+\n int\n frame_id_p (struct frame_id l)\n {"
    },
    {
      "sha": "e835d49f9ca993147c467d83a98afc40a69d563e",
      "filename": "gdb/frame.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/991a3e2e9944a4b3a27bd989ac03c18285bd545d/gdb/frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.h?ref=991a3e2e9944a4b3a27bd989ac03c18285bd545d",
      "patch": "@@ -236,6 +236,10 @@ extern struct frame_id\n    as the special identifier address are set to indicate wild cards.  */\n extern struct frame_id frame_id_build_wild (CORE_ADDR stack_addr);\n \n+/* Returns true if FRAME's id has been computed.\n+   Returns false otherwise.  */\n+extern bool frame_id_computed_p (struct frame_info *frame);\n+\n /* Returns non-zero when L is a valid frame (a valid frame has a\n    non-zero .base).  The outermost frame is valid even without an\n    ID.  */"
    }
  ]
}