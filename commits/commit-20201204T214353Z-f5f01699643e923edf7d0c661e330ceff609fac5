{
  "sha": "f5f01699643e923edf7d0c661e330ceff609fac5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjVmMDE2OTk2NDNlOTIzZWRmN2QwYzY2MWUzMzBjZWZmNjA5ZmFjNQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-12-04T21:43:53Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-04T21:43:53Z"
    },
    "message": "gdb: get rid of get_displaced_stepping_state\n\nRemove function get_displaced_stepping_state.  When it was introduced,\ninferiors' displaced stepping state was kept in a linked list in\ninfrun.c, so it was handy.  Nowadays, the state is kept inside struct\ninferior directly, so we can just access it directly instead.\n\ngdb/ChangeLog:\n\n\t* infrun.c (get_displaced_stepping_state): Remove, change\n\tcallers to access the field directly.\n\nChange-Id: I9a733e32e29c7ebf856ab0befe1076bbb8c7af69",
    "tree": {
      "sha": "0f4ec211afc96fca1625c42ccdb532bcab50626a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0f4ec211afc96fca1625c42ccdb532bcab50626a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f5f01699643e923edf7d0c661e330ceff609fac5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5f01699643e923edf7d0c661e330ceff609fac5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f5f01699643e923edf7d0c661e330ceff609fac5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5f01699643e923edf7d0c661e330ceff609fac5/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c0aba012edb6068e2433cbac855715a349a8555f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0aba012edb6068e2433cbac855715a349a8555f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c0aba012edb6068e2433cbac855715a349a8555f"
    }
  ],
  "stats": {
    "total": 49,
    "additions": 19,
    "deletions": 30
  },
  "files": [
    {
      "sha": "15f95bf6b2d8d100c008df5c9684b09bd353d6ac",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5f01699643e923edf7d0c661e330ceff609fac5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5f01699643e923edf7d0c661e330ceff609fac5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f5f01699643e923edf7d0c661e330ceff609fac5",
      "patch": "@@ -1,3 +1,8 @@\n+2020-12-04  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* infrun.c (get_displaced_stepping_state): Remove, change\n+\tcallers to access the field directly.\n+\n 2020-12-04  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* infrun.c (handle_inferior_event): Restore displaced step"
    },
    {
      "sha": "7bde61597d690bc0001939372726ee600c209ad2",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 14,
      "deletions": 30,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5f01699643e923edf7d0c661e330ceff609fac5/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5f01699643e923edf7d0c661e330ceff609fac5/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=f5f01699643e923edf7d0c661e330ceff609fac5",
      "patch": "@@ -1463,14 +1463,6 @@ step_over_info_valid_p (void)\n \n displaced_step_closure::~displaced_step_closure () = default;\n \n-/* Get the displaced stepping state of inferior INF.  */\n-\n-static displaced_step_inferior_state *\n-get_displaced_stepping_state (inferior *inf)\n-{\n-  return &inf->displaced_step_state;\n-}\n-\n /* Returns true if any inferior has a thread doing a displaced\n    step.  */\n \n@@ -1493,15 +1485,15 @@ displaced_step_in_progress_thread (thread_info *thread)\n {\n   gdb_assert (thread != NULL);\n \n-  return get_displaced_stepping_state (thread->inf)->step_thread == thread;\n+  return thread->inf->displaced_step_state.step_thread == thread;\n }\n \n /* Return true if INF has a thread doing a displaced step.  */\n \n static bool\n displaced_step_in_progress (inferior *inf)\n {\n-  return get_displaced_stepping_state (inf)->step_thread != nullptr;\n+  return inf->displaced_step_state.step_thread != nullptr;\n }\n \n /* If inferior is in displaced stepping, and ADDR equals to starting address\n@@ -1511,13 +1503,13 @@ displaced_step_in_progress (inferior *inf)\n struct displaced_step_closure*\n get_displaced_step_closure_by_addr (CORE_ADDR addr)\n {\n-  displaced_step_inferior_state *displaced\n-    = get_displaced_stepping_state (current_inferior ());\n+  displaced_step_inferior_state &displaced\n+    = current_inferior ()->displaced_step_state;\n \n   /* If checking the mode of displaced instruction in copy area.  */\n-  if (displaced->step_thread != nullptr\n-      && displaced->step_copy == addr)\n-    return displaced->step_closure.get ();\n+  if (displaced.step_thread != nullptr\n+      && displaced.step_copy == addr)\n+    return displaced.step_closure.get ();\n \n   return NULL;\n }\n@@ -1606,12 +1598,9 @@ use_displaced_stepping (thread_info *tp)\n   if (find_record_target () != nullptr)\n     return false;\n \n-  displaced_step_inferior_state *displaced_state\n-    = get_displaced_stepping_state (tp->inf);\n-\n   /* If displaced stepping failed before for this inferior, don't bother trying\n      again.  */\n-  if (displaced_state->failed_before)\n+  if (tp->inf->displaced_step_state.failed_before)\n     return false;\n \n   return true;\n@@ -1690,8 +1679,7 @@ displaced_step_prepare_throw (thread_info *tp)\n   /* We have to displaced step one thread at a time, as we only have\n      access to a single scratch space per inferior.  */\n \n-  displaced_step_inferior_state *displaced\n-    = get_displaced_stepping_state (tp->inf);\n+  displaced_step_inferior_state *displaced = &tp->inf->displaced_step_state;\n \n   if (displaced->step_thread != nullptr)\n     {\n@@ -1795,8 +1783,6 @@ displaced_step_prepare (thread_info *thread)\n     }\n   catch (const gdb_exception_error &ex)\n     {\n-      struct displaced_step_inferior_state *displaced_state;\n-\n       if (ex.error != MEMORY_ERROR\n \t  && ex.error != NOT_SUPPORTED_ERROR)\n \tthrow;\n@@ -1813,9 +1799,7 @@ displaced_step_prepare (thread_info *thread)\n \t}\n \n       /* Disable further displaced stepping attempts.  */\n-      displaced_state\n-\t= get_displaced_stepping_state (thread->inf);\n-      displaced_state->failed_before = 1;\n+      thread->inf->displaced_step_state.failed_before = 1;\n     }\n \n   return prepared;\n@@ -1857,8 +1841,8 @@ displaced_step_restore (struct displaced_step_inferior_state *displaced,\n static int\n displaced_step_fixup (thread_info *event_thread, enum gdb_signal signal)\n {\n-  struct displaced_step_inferior_state *displaced\n-    = get_displaced_stepping_state (event_thread->inf);\n+  displaced_step_inferior_state *displaced\n+    = &event_thread->inf->displaced_step_state;\n   int ret;\n \n   /* Was this event for the thread we displaced?  */\n@@ -3629,7 +3613,7 @@ prepare_for_detach (void)\n   struct inferior *inf = current_inferior ();\n   ptid_t pid_ptid = ptid_t (inf->pid);\n \n-  displaced_step_inferior_state *displaced = get_displaced_stepping_state (inf);\n+  displaced_step_inferior_state *displaced = &inf->displaced_step_state;\n \n   /* Is any thread of this process displaced stepping?  If not,\n      there's nothing else to do.  */\n@@ -5310,7 +5294,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \tif (ecs->ws.kind == TARGET_WAITKIND_FORKED)\n \t  {\n \t    displaced_step_inferior_state *displaced\n-\t      = get_displaced_stepping_state (parent_inf);\n+\t      = &parent_inf->displaced_step_state;\n \n \t    if (displaced->step_thread != nullptr)\n \t      displaced_step_restore (displaced, ecs->ws.value.related_pid);"
    }
  ]
}