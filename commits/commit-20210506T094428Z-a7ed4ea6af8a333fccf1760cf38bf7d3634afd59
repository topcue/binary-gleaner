{
  "sha": "a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTdlZDRlYTZhZjhhMzMzZmNjZjE3NjBjZjM4YmY3ZDM2MzRhZmQ1OQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-05-06T09:37:04Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-05-06T09:44:28Z"
    },
    "message": "gdb/testsuite: use proc_with_prefix in gdb.guile/scm-breakpoint.exp\n\nConvert gdb.guile/scm-breakpoint.exp to use proc_with_prefix instead\nof using nested with_test_prefix calls.  Allows a level of indentation\nto be removed from most of the test procs.\n\nThere were two procs that didn't use with_test_prefix, but I converted\nthem to be proc_with_prefix anyway, for consistency.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.guile/scm-breakpoint.exp (test_bkpt_basic): Convert to\n\t'proc_with_prefix', remove use of 'with_test_prefix', and\n\treindent.\n\t(test_bkpt_deletion): Likewise.\n\t(test_bkpt_cond_and_cmds): Likewise.\n\t(test_bkpt_invisible): Likewise.\n\t(test_watchpoints): Likewise.\n\t(test_bkpt_internal): Likewise.\n\t(test_bkpt_eval_funcs): Likewise.\n\t(test_bkpt_registration): Likewise.\n\t(test_bkpt_address): Convert to 'proc_with_prefix'.\n\t(test_bkpt_probe): Likewise.",
    "tree": {
      "sha": "56d33db85eec53a4b705393232cec6874b974a87",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/56d33db85eec53a4b705393232cec6874b974a87"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7ebbaa1c0aa3aadcf536f8590232a4466405093d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ebbaa1c0aa3aadcf536f8590232a4466405093d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7ebbaa1c0aa3aadcf536f8590232a4466405093d"
    }
  ],
  "stats": {
    "total": 847,
    "additions": 423,
    "deletions": 424
  },
  "files": [
    {
      "sha": "a9671475306b512ce58a2b32e55503b429a2fd6c",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
      "patch": "@@ -1,3 +1,18 @@\n+2021-05-06  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.guile/scm-breakpoint.exp (test_bkpt_basic): Convert to\n+\t'proc_with_prefix', remove use of 'with_test_prefix', and\n+\treindent.\n+\t(test_bkpt_deletion): Likewise.\n+\t(test_bkpt_cond_and_cmds): Likewise.\n+\t(test_bkpt_invisible): Likewise.\n+\t(test_watchpoints): Likewise.\n+\t(test_bkpt_internal): Likewise.\n+\t(test_bkpt_eval_funcs): Likewise.\n+\t(test_bkpt_registration): Likewise.\n+\t(test_bkpt_address): Convert to 'proc_with_prefix'.\n+\t(test_bkpt_probe): Likewise.\n+\n 2021-05-06  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.guile/scm-breakpoint.exp (test_bkpt_basic): Extend test"
    },
    {
      "sha": "9d271739852d9c852e072c4d0d90e52ec541af73",
      "filename": "gdb/testsuite/gdb.guile/scm-breakpoint.exp",
      "status": "modified",
      "additions": 408,
      "deletions": 424,
      "changes": 832,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59/gdb/testsuite/gdb.guile/scm-breakpoint.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a7ed4ea6af8a333fccf1760cf38bf7d3634afd59/gdb/testsuite/gdb.guile/scm-breakpoint.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.guile/scm-breakpoint.exp?ref=a7ed4ea6af8a333fccf1760cf38bf7d3634afd59",
      "patch": "@@ -27,469 +27,453 @@ if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n # Skip all tests if Guile scripting is not enabled.\n if { [skip_guile_tests] } { continue }\n \n-proc test_bkpt_basic { } {\n+proc_with_prefix test_bkpt_basic { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix \"test_bkpt_basic\" {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\t# Initially there should be one breakpoint: main.\n-\n-\tgdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n-\t    \"get breakpoint list 1\"\n-\tgdb_test \"guile (print (car blist))\" \\\n-\t    \"<gdb:breakpoint #1 BP_BREAKPOINT enabled noisy hit:1 ignore:0 @-qualified main>\" \\\n-\t    \"check main breakpoint\"\n-\tgdb_test \"guile (print (breakpoint-location (car blist)))\" \\\n-\t    \"main\" \"check main breakpoint location\"\n-\n-\tset mult_line [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_breakpoint ${mult_line}\n-\tgdb_continue_to_breakpoint \"Break at multiply, first time\"\n-\n-\t# Check that the Guile breakpoint code noted the addition of a\n-\t# breakpoint \"behind the scenes\".\n-\tgdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n-\t    \"get breakpoint list 2\"\n-\tgdb_scm_test_silent_cmd \"guile (define mult-bkpt (cadr blist))\" \\\n-\t    \"get multiply breakpoint\"\n-\tgdb_test \"guile (print (length blist))\" \\\n-\t    \"= 2\" \"check for two breakpoints\"\n-\tgdb_test \"guile (print mult-bkpt)\" \\\n-\t    \"= #<gdb:breakpoint #2 BP_BREAKPOINT enabled noisy hit:1 ignore:0 @.*scm-breakpoint.c:$mult_line>\" \\\n-\t    \"check multiply breakpoint\"\n-\tgdb_test \"guile (print (breakpoint-location mult-bkpt))\" \\\n-\t    \"scm-breakpoint\\.c:${mult_line}*\" \\\n-\t    \"check multiply breakpoint location\"\n-\n-\t# Check hit and ignore counts. \n-\tgdb_test \"guile (print (breakpoint-hit-count mult-bkpt))\" \\\n-\t    \"= 1\" \"check multiply breakpoint hit count\"\n-\tgdb_scm_test_silent_cmd \"guile (set-breakpoint-ignore-count! mult-bkpt 4)\" \\\n-\t    \"set multiply breakpoint ignore count\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, second time\"\n-\tgdb_test \"guile (print (breakpoint-hit-count mult-bkpt))\" \\\n-\t    \"= 6\" \"check multiply breakpoint hit count 2\"\n-\tgdb_test \"print result\" \\\n-\t    \" = 545\" \"check expected variable result after 6 iterations\"\n-\n-\t# Test breakpoint is enabled and disabled correctly.\n-\tgdb_breakpoint [gdb_get_line_number \"Break at add.\"]\n-\tgdb_continue_to_breakpoint \"Break at add, first time\"\n-\tgdb_test \"guile (print (breakpoint-enabled? mult-bkpt))\" \\\n-\t    \"= #t\" \"check multiply breakpoint enabled\"\n-\tgdb_scm_test_silent_cmd  \"guile (set-breakpoint-enabled! mult-bkpt #f)\" \\\n-\t    \"set multiply breakpoint disabled\"\n-\tgdb_continue_to_breakpoint \"Break at add, second time\"\n-\tgdb_scm_test_silent_cmd  \"guile (set-breakpoint-enabled! mult-bkpt #t)\" \\\n-\t    \"set multiply breakpoint enabled\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, third time\"\n-\n-\t# Test other getters and setters.\n-\tgdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n-\t    \"get breakpoint list 3\"\n-\tgdb_test \"guile (print (breakpoint-thread mult-bkpt))\" \\\n-\t    \"= #f\" \"check breakpoint thread\"\n-\tgdb_test \"guile (print (= (breakpoint-type mult-bkpt) BP_BREAKPOINT))\" \\\n-\t    \"= #t\" \"check breakpoint type\"\n-\tgdb_test \"guile (print (map breakpoint-number blist))\" \\\n-\t    \"= \\\\(1 2 3\\\\)\" \"check breakpoint numbers\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    # Initially there should be one breakpoint: main.\n+\n+    gdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n+\t\"get breakpoint list 1\"\n+    gdb_test \"guile (print (car blist))\" \\\n+\t\"<gdb:breakpoint #1 BP_BREAKPOINT enabled noisy hit:1 ignore:0 @-qualified main>\" \\\n+\t\"check main breakpoint\"\n+    gdb_test \"guile (print (breakpoint-location (car blist)))\" \\\n+\t\"main\" \"check main breakpoint location\"\n+\n+    set mult_line [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_breakpoint ${mult_line}\n+    gdb_continue_to_breakpoint \"Break at multiply, first time\"\n+\n+    # Check that the Guile breakpoint code noted the addition of a\n+    # breakpoint \"behind the scenes\".\n+    gdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n+\t\"get breakpoint list 2\"\n+    gdb_scm_test_silent_cmd \"guile (define mult-bkpt (cadr blist))\" \\\n+\t\"get multiply breakpoint\"\n+    gdb_test \"guile (print (length blist))\" \\\n+\t\"= 2\" \"check for two breakpoints\"\n+    gdb_test \"guile (print mult-bkpt)\" \\\n+\t\"= #<gdb:breakpoint #2 BP_BREAKPOINT enabled noisy hit:1 ignore:0 @.*scm-breakpoint.c:$mult_line>\" \\\n+\t\"check multiply breakpoint\"\n+    gdb_test \"guile (print (breakpoint-location mult-bkpt))\" \\\n+\t\"scm-breakpoint\\.c:${mult_line}*\" \\\n+\t\"check multiply breakpoint location\"\n+\n+    # Check hit and ignore counts. \n+    gdb_test \"guile (print (breakpoint-hit-count mult-bkpt))\" \\\n+\t\"= 1\" \"check multiply breakpoint hit count\"\n+    gdb_scm_test_silent_cmd \"guile (set-breakpoint-ignore-count! mult-bkpt 4)\" \\\n+\t\"set multiply breakpoint ignore count\"\n+    gdb_continue_to_breakpoint \"Break at multiply, second time\"\n+    gdb_test \"guile (print (breakpoint-hit-count mult-bkpt))\" \\\n+\t\"= 6\" \"check multiply breakpoint hit count 2\"\n+    gdb_test \"print result\" \\\n+\t\" = 545\" \"check expected variable result after 6 iterations\"\n+\n+    # Test breakpoint is enabled and disabled correctly.\n+    gdb_breakpoint [gdb_get_line_number \"Break at add.\"]\n+    gdb_continue_to_breakpoint \"Break at add, first time\"\n+    gdb_test \"guile (print (breakpoint-enabled? mult-bkpt))\" \\\n+\t\"= #t\" \"check multiply breakpoint enabled\"\n+    gdb_scm_test_silent_cmd  \"guile (set-breakpoint-enabled! mult-bkpt #f)\" \\\n+\t\"set multiply breakpoint disabled\"\n+    gdb_continue_to_breakpoint \"Break at add, second time\"\n+    gdb_scm_test_silent_cmd  \"guile (set-breakpoint-enabled! mult-bkpt #t)\" \\\n+\t\"set multiply breakpoint enabled\"\n+    gdb_continue_to_breakpoint \"Break at multiply, third time\"\n+\n+    # Test other getters and setters.\n+    gdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n+\t\"get breakpoint list 3\"\n+    gdb_test \"guile (print (breakpoint-thread mult-bkpt))\" \\\n+\t\"= #f\" \"check breakpoint thread\"\n+    gdb_test \"guile (print (= (breakpoint-type mult-bkpt) BP_BREAKPOINT))\" \\\n+\t\"= #t\" \"check breakpoint type\"\n+    gdb_test \"guile (print (map breakpoint-number blist))\" \\\n+\t\"= \\\\(1 2 3\\\\)\" \"check breakpoint numbers\"\n }\n \n-proc test_bkpt_deletion { } {\n+proc_with_prefix test_bkpt_deletion { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_bkpt_deletion {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\t# Test breakpoints are deleted correctly.\n-\tset deltst_location [gdb_get_line_number \"Break at multiply.\"]\n-\tset end_location [gdb_get_line_number \"Break at end.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define dp1 (make-breakpoint \\\"$deltst_location\\\"))\" \\\n-\t    \"create deltst breakpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! dp1)\" \\\n-\t    \"register dp1\"\n-\tgdb_breakpoint [gdb_get_line_number \"Break at end.\"]\n-\tgdb_scm_test_silent_cmd \"guile (define del-list (breakpoints))\" \\\n-\t    \"get breakpoint list 4\"\n-\tgdb_test \"guile (print (length del-list))\" \\\n-\t    \"= 3\" \"number of breakpoints before delete\"\n-\tgdb_continue_to_breakpoint \"Break at multiply.\" \\\n-\t    \".*$srcfile:$deltst_location.*\"\n-\tgdb_scm_test_silent_cmd  \"guile (delete-breakpoint! dp1)\" \\\n-\t    \"delete breakpoint\"\n-\tgdb_test \"guile (print (breakpoint-number dp1))\" \\\n-\t    \"ERROR: .*: Invalid object: <gdb:breakpoint> in position 1: #<gdb:breakpoint #-1>.*\" \\\n-\t    \"check breakpoint invalidated\"\n-\tgdb_scm_test_silent_cmd \"guile (set! del-list (breakpoints))\" \\\n-\t    \"get breakpoint list 5\"\n-\tgdb_test \"guile (print (length del-list))\" \\\n-\t    \"= 2\" \"number of breakpoints after delete\"\n-\tgdb_continue_to_breakpoint \"Break at end.\" \".*$srcfile:$end_location.*\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    # Test breakpoints are deleted correctly.\n+    set deltst_location [gdb_get_line_number \"Break at multiply.\"]\n+    set end_location [gdb_get_line_number \"Break at end.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define dp1 (make-breakpoint \\\"$deltst_location\\\"))\" \\\n+\t\"create deltst breakpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! dp1)\" \\\n+\t\"register dp1\"\n+    gdb_breakpoint [gdb_get_line_number \"Break at end.\"]\n+    gdb_scm_test_silent_cmd \"guile (define del-list (breakpoints))\" \\\n+\t\"get breakpoint list 4\"\n+    gdb_test \"guile (print (length del-list))\" \\\n+\t\"= 3\" \"number of breakpoints before delete\"\n+    gdb_continue_to_breakpoint \"Break at multiply.\" \\\n+\t\".*$srcfile:$deltst_location.*\"\n+    gdb_scm_test_silent_cmd  \"guile (delete-breakpoint! dp1)\" \\\n+\t\"delete breakpoint\"\n+    gdb_test \"guile (print (breakpoint-number dp1))\" \\\n+\t\"ERROR: .*: Invalid object: <gdb:breakpoint> in position 1: #<gdb:breakpoint #-1>.*\" \\\n+\t\"check breakpoint invalidated\"\n+    gdb_scm_test_silent_cmd \"guile (set! del-list (breakpoints))\" \\\n+\t\"get breakpoint list 5\"\n+    gdb_test \"guile (print (length del-list))\" \\\n+\t\"= 2\" \"number of breakpoints after delete\"\n+    gdb_continue_to_breakpoint \"Break at end.\" \".*$srcfile:$end_location.*\"\n }\n \n-proc test_bkpt_cond_and_cmds { } {\n+proc_with_prefix test_bkpt_cond_and_cmds { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_bkpt_cond_and_cmds {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\t# Test conditional setting.\n-\tset bp_location1 [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define bp1 (make-breakpoint \\\"$bp_location1\\\"))\" \\\n-\t    \"create multiply breakpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n-\t    \"register bp1\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, first time\"\n-\tgdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! bp1 \\\"i == 5\\\")\" \\\n-\t    \"set condition\"\n-\tgdb_test \"guile (print (breakpoint-condition bp1))\" \\\n-\t    \"= i == 5\" \"test condition has been set\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, second time\"\n-\tgdb_test \"print i\" \\\n-\t    \"5\" \"test conditional breakpoint stopped after five iterations\"\n-\tgdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! bp1 #f)\" \\\n-\t    \"clear condition\"\n-\tgdb_test \"guile (print (breakpoint-condition bp1))\" \\\n-\t    \"= #f\" \"test condition has been removed\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, third time\"\n-\tgdb_test \"print i\" \"6\" \"test breakpoint stopped after six iterations\"\n-\n-\t# Test commands.\n-\tgdb_breakpoint [gdb_get_line_number \"Break at add.\"]\n-\tset test {commands $bpnum}\n-\tgdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n-\tset test {print \"Command for breakpoint has been executed.\"}\n-\tgdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n-\tset test {print result}\n-\tgdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n-\tgdb_test \"end\"\n-\n-\tgdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n-\t    \"get breakpoint list 6\"\n-\tgdb_test \"guile (print (breakpoint-commands (list-ref blist (- (length blist) 1))))\" \\\n-\t    \"print \\\"Command for breakpoint has been executed.\\\".*print result\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    # Test conditional setting.\n+    set bp_location1 [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define bp1 (make-breakpoint \\\"$bp_location1\\\"))\" \\\n+\t\"create multiply breakpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n+\t\"register bp1\"\n+    gdb_continue_to_breakpoint \"Break at multiply, first time\"\n+    gdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! bp1 \\\"i == 5\\\")\" \\\n+\t\"set condition\"\n+    gdb_test \"guile (print (breakpoint-condition bp1))\" \\\n+\t\"= i == 5\" \"test condition has been set\"\n+    gdb_continue_to_breakpoint \"Break at multiply, second time\"\n+    gdb_test \"print i\" \\\n+\t\"5\" \"test conditional breakpoint stopped after five iterations\"\n+    gdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! bp1 #f)\" \\\n+\t\"clear condition\"\n+    gdb_test \"guile (print (breakpoint-condition bp1))\" \\\n+\t\"= #f\" \"test condition has been removed\"\n+    gdb_continue_to_breakpoint \"Break at multiply, third time\"\n+    gdb_test \"print i\" \"6\" \"test breakpoint stopped after six iterations\"\n+\n+    # Test commands.\n+    gdb_breakpoint [gdb_get_line_number \"Break at add.\"]\n+    set test {commands $bpnum}\n+    gdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n+    set test {print \"Command for breakpoint has been executed.\"}\n+    gdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n+    set test {print result}\n+    gdb_test_multiple $test $test { -re \"\\r\\n>$\" { pass $test } }\n+    gdb_test \"end\"\n+\n+    gdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n+\t\"get breakpoint list 6\"\n+    gdb_test \"guile (print (breakpoint-commands (list-ref blist (- (length blist) 1))))\" \\\n+\t\"print \\\"Command for breakpoint has been executed.\\\".*print result\"\n }\n \n-proc test_bkpt_invisible { } {\n+proc_with_prefix test_bkpt_invisible { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_bkpt_invisible {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\t# Test invisible breakpoints.\n-\tdelete_breakpoints\n-\tset ibp_location [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define vbp1 (make-breakpoint \\\"$ibp_location\\\" #:internal #f))\" \\\n-\t    \"create visible breakpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! vbp1)\" \\\n-\t    \"register vbp1\"\n-\tgdb_scm_test_silent_cmd \"guile (define vbp (car (breakpoints)))\" \\\n-\t    \"get visible breakpoint\"\n-\tgdb_test \"guile (print vbp)\" \\\n-\t    \"= #<gdb:breakpoint #2 BP_BREAKPOINT enabled noisy hit:0 ignore:0 @.*scm-breakpoint.c:$ibp_location>\" \\\n-\t    \"check visible bp obj exists\"\n-\tgdb_test \"guile (print (breakpoint-location vbp))\" \\\n-\t    \"scm-breakpoint\\.c:$ibp_location*\" \"check visible breakpoint location\"\n-\tgdb_test \"guile (print (breakpoint-visible? vbp))\" \\\n-\t    \"= #t\" \"check breakpoint visibility\"\n-\tgdb_test \"info breakpoints\" \\\n-\t    \"scm-breakpoint\\.c:$ibp_location.*\" \\\n-\t    \"check info breakpoints shows visible breakpoints\"\n-\tdelete_breakpoints\n-\tgdb_scm_test_silent_cmd  \"guile (define ibp (make-breakpoint \\\"$ibp_location\\\" #:internal #t))\" \\\n-\t    \"create invisible breakpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! ibp)\" \\\n-\t    \"register ibp\"\n-\tgdb_test \"guile (print ibp)\" \\\n-\t    \"= #<gdb:breakpoint #-$decimal BP_BREAKPOINT enabled noisy hit:0 ignore:0 @.*scm-breakpoint.c:$ibp_location>\" \\\n-\t    \"check invisible bp obj exists\"\n-\tgdb_test \"guile (print (breakpoint-location ibp))\" \\\n-\t    \"scm-breakpoint\\.c:$ibp_location*\" \"check invisible breakpoint location\"\n-\tgdb_test \"guile (print (breakpoint-visible? ibp))\" \\\n-\t    \"= #f\" \"check breakpoint invisibility\"\n-\tgdb_test \"info breakpoints\" \\\n-\t    \"No breakpoints or watchpoints.*\" \\\n-\t    \"check info breakpoints does not show invisible breakpoints\"\n-\tgdb_test \"maint info breakpoints\" \\\n-\t    \"scm-breakpoint\\.c:$ibp_location.*\" \\\n-\t    \"check maint info breakpoints shows invisible breakpoints\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    # Test invisible breakpoints.\n+    delete_breakpoints\n+    set ibp_location [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define vbp1 (make-breakpoint \\\"$ibp_location\\\" #:internal #f))\" \\\n+\t\"create visible breakpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! vbp1)\" \\\n+\t\"register vbp1\"\n+    gdb_scm_test_silent_cmd \"guile (define vbp (car (breakpoints)))\" \\\n+\t\"get visible breakpoint\"\n+    gdb_test \"guile (print vbp)\" \\\n+\t\"= #<gdb:breakpoint #2 BP_BREAKPOINT enabled noisy hit:0 ignore:0 @.*scm-breakpoint.c:$ibp_location>\" \\\n+\t\"check visible bp obj exists\"\n+    gdb_test \"guile (print (breakpoint-location vbp))\" \\\n+\t\"scm-breakpoint\\.c:$ibp_location*\" \"check visible breakpoint location\"\n+    gdb_test \"guile (print (breakpoint-visible? vbp))\" \\\n+\t\"= #t\" \"check breakpoint visibility\"\n+    gdb_test \"info breakpoints\" \\\n+\t\"scm-breakpoint\\.c:$ibp_location.*\" \\\n+\t\"check info breakpoints shows visible breakpoints\"\n+    delete_breakpoints\n+    gdb_scm_test_silent_cmd  \"guile (define ibp (make-breakpoint \\\"$ibp_location\\\" #:internal #t))\" \\\n+\t\"create invisible breakpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! ibp)\" \\\n+\t\"register ibp\"\n+    gdb_test \"guile (print ibp)\" \\\n+\t\"= #<gdb:breakpoint #-$decimal BP_BREAKPOINT enabled noisy hit:0 ignore:0 @.*scm-breakpoint.c:$ibp_location>\" \\\n+\t\"check invisible bp obj exists\"\n+    gdb_test \"guile (print (breakpoint-location ibp))\" \\\n+\t\"scm-breakpoint\\.c:$ibp_location*\" \"check invisible breakpoint location\"\n+    gdb_test \"guile (print (breakpoint-visible? ibp))\" \\\n+\t\"= #f\" \"check breakpoint invisibility\"\n+    gdb_test \"info breakpoints\" \\\n+\t\"No breakpoints or watchpoints.*\" \\\n+\t\"check info breakpoints does not show invisible breakpoints\"\n+    gdb_test \"maint info breakpoints\" \\\n+\t\"scm-breakpoint\\.c:$ibp_location.*\" \\\n+\t\"check maint info breakpoints shows invisible breakpoints\"\n }\n \n-proc test_watchpoints { } {\n+proc_with_prefix test_watchpoints { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_watchpoints {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\t# Disable hardware watchpoints if necessary.\n-\tif [target_info exists gdb,no_hardware_watchpoints] {\n-\t    gdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n-\t}\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\tgdb_scm_test_silent_cmd  \"guile (define wp1 (make-breakpoint \\\"result\\\" #:type BP_WATCHPOINT #:wp-class WP_WRITE))\" \\\n-\t    \"create watchpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! wp1)\" \\\n-\t    \"register wp1\"\n-\tgdb_test \"continue\" \\\n-\t    \".*\\[Ww\\]atchpoint.*result.*Old value = 0.*New value = 25.*main.*\" \\\n-\t    \"test watchpoint write\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    # Disable hardware watchpoints if necessary.\n+    if [target_info exists gdb,no_hardware_watchpoints] {\n+\tgdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n+    }\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    gdb_scm_test_silent_cmd  \"guile (define wp1 (make-breakpoint \\\"result\\\" #:type BP_WATCHPOINT #:wp-class WP_WRITE))\" \\\n+\t\"create watchpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! wp1)\" \\\n+\t\"register wp1\"\n+    gdb_test \"continue\" \\\n+\t\".*\\[Ww\\]atchpoint.*result.*Old value = 0.*New value = 25.*main.*\" \\\n+\t\"test watchpoint write\"\n }\n \n-proc test_bkpt_internal { } {\n+proc_with_prefix test_bkpt_internal { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_bkpt_internal {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\t# Disable hardware watchpoints if necessary.\n-\tif [target_info exists gdb,no_hardware_watchpoints] {\n-\t    gdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n-\t}\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\tdelete_breakpoints\n-\n-\tgdb_scm_test_silent_cmd  \"guile (define wp1 (make-breakpoint \\\"result\\\" #:type BP_WATCHPOINT #:wp-class WP_WRITE #:internal #t))\" \\\n-\t    \"create invisible watchpoint\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! wp1)\" \\\n-\t    \"register wp1\"\n-\tgdb_test \"info breakpoints\" \\\n-\t    \"No breakpoints or watchpoints.*\" \\\n-\t    \"check info breakpoints does not show invisible watchpoint\"\n-\tgdb_test \"maint info breakpoints\" \\\n-\t    \".*watchpoint.*result.*\" \\\n-\t    \"check maint info breakpoints shows invisible watchpoint\"\n-\tgdb_test \"continue\" \\\n-\t    \".*\\[Ww\\]atchpoint.*result.*Old value = 0.*New value = 25.*\" \\\n-\t    \"test invisible watchpoint write\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    # Disable hardware watchpoints if necessary.\n+    if [target_info exists gdb,no_hardware_watchpoints] {\n+\tgdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n     }\n+    if ![gdb_guile_runto_main] {\n+\treturn\n+    }\n+\n+    delete_breakpoints\n+\n+    gdb_scm_test_silent_cmd  \"guile (define wp1 (make-breakpoint \\\"result\\\" #:type BP_WATCHPOINT #:wp-class WP_WRITE #:internal #t))\" \\\n+\t\"create invisible watchpoint\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! wp1)\" \\\n+\t\"register wp1\"\n+    gdb_test \"info breakpoints\" \\\n+\t\"No breakpoints or watchpoints.*\" \\\n+\t\"check info breakpoints does not show invisible watchpoint\"\n+    gdb_test \"maint info breakpoints\" \\\n+\t\".*watchpoint.*result.*\" \\\n+\t\"check maint info breakpoints shows invisible watchpoint\"\n+    gdb_test \"continue\" \\\n+\t\".*\\[Ww\\]atchpoint.*result.*Old value = 0.*New value = 25.*\" \\\n+\t\"test invisible watchpoint write\"\n }\n \n-proc test_bkpt_eval_funcs { } {\n+proc_with_prefix test_bkpt_eval_funcs { } {\n     global srcfile testfile hex decimal\n \n-    with_test_prefix test_bkpt_eval_funcs {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\t# Disable hardware watchpoints if necessary.\n-\tif [target_info exists gdb,no_hardware_watchpoints] {\n-\t    gdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n-\t}\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\tdelete_breakpoints\n-\n-\t# Define create-breakpoint! as a convenient wrapper around\n-\t# make-breakpoint, register-breakpoint!\n-\tgdb_test_no_output \"guile (define (create-breakpoint! . args) (let ((bp (apply make-breakpoint args))) (register-breakpoint! bp) bp))\" \\\n-\t    \"define create-breakpoint!\"\n-\n-\tgdb_test_multiline \"data collection breakpoint 1\" \\\n-\t    \"guile\" \"\" \\\n-\t    \"(define (make-bp-data) (cons 0 0))\" \"\" \\\n-\t    \"(define bp-data-count car)\" \"\" \\\n-\t    \"(define set-bp-data-count! set-car!)\" \"\" \\\n-\t    \"(define bp-data-inf-i cdr)\" \"\" \\\n-\t    \"(define set-bp-data-inf-i! set-cdr!)\" \"\" \\\n-\t    \"(define (bp-eval-count bkpt) (bp-data-count (object-property bkpt 'bp-data)))\" \"\" \\\n-\t    \"(define (bp-eval-inf-i bkpt) (bp-data-inf-i (object-property bkpt 'bp-data)))\" \"\" \\\n-\t    \"(define (make-bp-eval location)\" \"\" \\\n-\t    \"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n-\t    \"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n-\t    \"    (set-breakpoint-stop! bp\" \"\" \\\n-\t    \"       (lambda (bkpt)\" \"\" \\\n-\t    \"         (let ((data (object-property bkpt 'bp-data))\" \"\" \\\n-\t    \"               (inf-i (parse-and-eval \\\"i\\\")))\" \"\" \\\n-\t    \"           (set-bp-data-count! data (+ (bp-data-count data) 1))\" \"\" \\\n-\t    \"           (set-bp-data-inf-i! data inf-i)\" \"\" \\\n-\t    \"           (value=? inf-i 3))))\" \"\" \\\n-\t    \"    bp))\" \"\" \\\n-\t    \"end\" \"\"\n-\n-\tgdb_test_multiline \"data collection breakpoint 2\" \\\n-\t    \"guile\" \"\" \\\n-\t    \"(define (make-bp-also-eval location)\" \"\" \\\n-\t    \"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n-\t    \"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n-\t    \"    (set-breakpoint-stop! bp\" \"\" \\\n-\t    \"       (lambda (bkpt)\" \"\" \\\n-\t    \"         (let* ((data (object-property bkpt 'bp-data))\" \"\" \\\n-\t    \"                (count (+ (bp-data-count data) 1)))\" \"\" \\\n-\t    \"           (set-bp-data-count! data count)\" \"\" \\\n-\t    \"           (= count 9))))\" \"\" \\\n-\t    \"    bp))\" \"\" \\\n-\t    \"end\" \"\"\n-\n-\tgdb_test_multiline \"data collection breakpoint 3\" \\\n-\t    \"guile\" \"\" \\\n-\t    \"(define (make-bp-basic location)\" \"\" \\\n-\t    \"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n-\t    \"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n-\t    \"    bp))\" \"\" \\\n-\t    \"end\" \"\"\n-\n-\tset bp_location2 [gdb_get_line_number \"Break at multiply.\"]\n-\tset end_location [gdb_get_line_number \"Break at end.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define eval-bp1 (make-bp-eval \\\"$bp_location2\\\"))\" \\\n-\t    \"create eval-bp1 breakpoint\"\n-\tgdb_scm_test_silent_cmd  \"guile (define also-eval-bp1 (make-bp-also-eval \\\"$bp_location2\\\"))\" \\\n-\t    \"create also-eval-bp1 breakpoint\"\n-\tgdb_scm_test_silent_cmd  \"guile (define never-eval-bp1 (make-bp-also-eval \\\"$end_location\\\"))\" \\\n-\t    \"create never-eval-bp1 breakpoint\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, first time\" \\\n-\t    \".*$srcfile:$bp_location2.*\"\n-\tgdb_test \"print i\" \"3\" \"check inferior value matches guile accounting\"\n-\tgdb_test \"guile (print (bp-eval-inf-i eval-bp1))\" \\\n-\t    \"= 3\" \"check guile accounting matches inferior\"\n-\tgdb_test \"guile (print (bp-eval-count also-eval-bp1))\" \\\n-\t    \"= 4\" \\\n-\t    \"check non firing same-location breakpoint eval function was also called at each stop 1\"\n-\tgdb_test \"guile (print (bp-eval-count eval-bp1))\" \\\n-\t    \"= 4\" \\\n-\t    \"check non firing same-location breakpoint eval function was also called at each stop 2\"\n-\n-\t# Check we cannot assign a condition to a breakpoint with a stop-func,\n-\t# and cannot assign a stop-func to a breakpoint with a condition.\n-\n-\tdelete_breakpoints\n-\tset cond_bp [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define eval-bp1 (make-bp-eval \\\"$cond_bp\\\"))\" \\\n-\t    \"create eval-bp1 breakpoint 2\"\n-\tset test_cond {cond $bpnum}\n-\tgdb_test \"$test_cond \\\"foo==3\\\"\" \\\n-\t    \"Only one stop condition allowed.*\"\n-\tgdb_scm_test_silent_cmd  \"guile (define eval-bp2 (make-bp-basic \\\"$cond_bp\\\"))\" \\\n-\t    \"create basic breakpoint\"\n-\tgdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! eval-bp2 \\\"1==1\\\")\" \\\n-\t    \"set a condition\"\n-\tgdb_test_multiline \"construct an eval function\" \\\n-\t    \"guile\" \"\" \\\n-\t    \"(define (stop-func bkpt)\" \"\" \\\n-\t    \"   return #t)\" \"\" \\\n-\t    \"end\" \"\"\n-\tgdb_test \"guile (set-breakpoint-stop! eval-bp2 stop-func)\"  \\\n-\t    \"Only one stop condition allowed.*\"\n-\n-\t# Check that stop-func is run when location has normal bp.\n-\n-\tdelete_breakpoints\n-\tgdb_breakpoint [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define check-eval (make-bp-eval \\\"$bp_location2\\\"))\" \\\n-\t    \"create check-eval breakpoint\"\n-\tgdb_test \"guile (print (bp-eval-count check-eval))\" \\\n-\t    \"= 0\" \\\n-\t    \"test that evaluate function has not been yet executed (ie count = 0)\"\n-\tgdb_continue_to_breakpoint \"Break at multiply, second time\" \\\n-\t    \".*$srcfile:$bp_location2.*\"\n-\tgdb_test \"guile (print (bp-eval-count check-eval))\" \\\n-\t    \"= 1\" \\\n-\t    \"test that evaluate function is run when location also has normal bp\"\n-\n-\t# Test watchpoints with stop-func.\n-\n-\tgdb_test_multiline \"watchpoint stop func\" \\\n-\t    \"guile\" \"\" \\\n-\t    \"(define (make-wp-eval location)\" \"\" \\\n-\t    \"  (let ((wp (create-breakpoint! location #:type BP_WATCHPOINT #:wp-class WP_WRITE)))\" \"\" \\\n-\t    \"    (set-breakpoint-stop! wp\" \"\" \\\n-\t    \"      (lambda (bkpt)\" \"\" \\\n-\t    \"        (let ((result (parse-and-eval \\\"result\\\")))\" \"\" \\\n-\t    \"          (value=? result 788))))\" \"\" \\\n-\t    \"    wp))\" \"\" \\\n-\t    \"end\" \"\"\n-\n-\tdelete_breakpoints\n-\tgdb_scm_test_silent_cmd  \"guile (define wp1 (make-wp-eval \\\"result\\\"))\" \\\n-\t    \"create watchpoint\"\n-\tgdb_test \"continue\" \".*\\[Ww\\]atchpoint.*result.*Old value =.*New value = 788.*\" \\\n-\t    \"test watchpoint write\"\n-\n-\t# Misc final tests.\n-\n-\tgdb_test \"guile (print (bp-eval-count never-eval-bp1))\" \\\n-\t    \"= 0\" \\\n-\t    \"check that this unrelated breakpoints eval function was never called\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    # Disable hardware watchpoints if necessary.\n+    if [target_info exists gdb,no_hardware_watchpoints] {\n+\tgdb_test_no_output \"set can-use-hw-watchpoints 0\" \"\"\n     }\n+    if ![gdb_guile_runto_main] {\n+\treturn\n+    }\n+\n+    delete_breakpoints\n+\n+    # Define create-breakpoint! as a convenient wrapper around\n+    # make-breakpoint, register-breakpoint!\n+    gdb_test_no_output \"guile (define (create-breakpoint! . args) (let ((bp (apply make-breakpoint args))) (register-breakpoint! bp) bp))\" \\\n+\t\"define create-breakpoint!\"\n+\n+    gdb_test_multiline \"data collection breakpoint 1\" \\\n+\t\"guile\" \"\" \\\n+\t\"(define (make-bp-data) (cons 0 0))\" \"\" \\\n+\t\"(define bp-data-count car)\" \"\" \\\n+\t\"(define set-bp-data-count! set-car!)\" \"\" \\\n+\t\"(define bp-data-inf-i cdr)\" \"\" \\\n+\t\"(define set-bp-data-inf-i! set-cdr!)\" \"\" \\\n+\t\"(define (bp-eval-count bkpt) (bp-data-count (object-property bkpt 'bp-data)))\" \"\" \\\n+\t\"(define (bp-eval-inf-i bkpt) (bp-data-inf-i (object-property bkpt 'bp-data)))\" \"\" \\\n+\t\"(define (make-bp-eval location)\" \"\" \\\n+\t\"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n+\t\"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n+\t\"    (set-breakpoint-stop! bp\" \"\" \\\n+\t\"       (lambda (bkpt)\" \"\" \\\n+\t\"         (let ((data (object-property bkpt 'bp-data))\" \"\" \\\n+\t\"               (inf-i (parse-and-eval \\\"i\\\")))\" \"\" \\\n+\t\"           (set-bp-data-count! data (+ (bp-data-count data) 1))\" \"\" \\\n+\t\"           (set-bp-data-inf-i! data inf-i)\" \"\" \\\n+\t\"           (value=? inf-i 3))))\" \"\" \\\n+\t\"    bp))\" \"\" \\\n+\t\"end\" \"\"\n+\n+    gdb_test_multiline \"data collection breakpoint 2\" \\\n+\t\"guile\" \"\" \\\n+\t\"(define (make-bp-also-eval location)\" \"\" \\\n+\t\"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n+\t\"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n+\t\"    (set-breakpoint-stop! bp\" \"\" \\\n+\t\"       (lambda (bkpt)\" \"\" \\\n+\t\"         (let* ((data (object-property bkpt 'bp-data))\" \"\" \\\n+\t\"                (count (+ (bp-data-count data) 1)))\" \"\" \\\n+\t\"           (set-bp-data-count! data count)\" \"\" \\\n+\t\"           (= count 9))))\" \"\" \\\n+\t\"    bp))\" \"\" \\\n+\t\"end\" \"\"\n+\n+    gdb_test_multiline \"data collection breakpoint 3\" \\\n+\t\"guile\" \"\" \\\n+\t\"(define (make-bp-basic location)\" \"\" \\\n+\t\"  (let ((bp (create-breakpoint! location)))\" \"\" \\\n+\t\"    (set-object-property! bp 'bp-data (make-bp-data))\" \"\" \\\n+\t\"    bp))\" \"\" \\\n+\t\"end\" \"\"\n+\n+    set bp_location2 [gdb_get_line_number \"Break at multiply.\"]\n+    set end_location [gdb_get_line_number \"Break at end.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define eval-bp1 (make-bp-eval \\\"$bp_location2\\\"))\" \\\n+\t\"create eval-bp1 breakpoint\"\n+    gdb_scm_test_silent_cmd  \"guile (define also-eval-bp1 (make-bp-also-eval \\\"$bp_location2\\\"))\" \\\n+\t\"create also-eval-bp1 breakpoint\"\n+    gdb_scm_test_silent_cmd  \"guile (define never-eval-bp1 (make-bp-also-eval \\\"$end_location\\\"))\" \\\n+\t\"create never-eval-bp1 breakpoint\"\n+    gdb_continue_to_breakpoint \"Break at multiply, first time\" \\\n+\t\".*$srcfile:$bp_location2.*\"\n+    gdb_test \"print i\" \"3\" \"check inferior value matches guile accounting\"\n+    gdb_test \"guile (print (bp-eval-inf-i eval-bp1))\" \\\n+\t\"= 3\" \"check guile accounting matches inferior\"\n+    gdb_test \"guile (print (bp-eval-count also-eval-bp1))\" \\\n+\t\"= 4\" \\\n+\t\"check non firing same-location breakpoint eval function was also called at each stop 1\"\n+    gdb_test \"guile (print (bp-eval-count eval-bp1))\" \\\n+\t\"= 4\" \\\n+\t\"check non firing same-location breakpoint eval function was also called at each stop 2\"\n+\n+    # Check we cannot assign a condition to a breakpoint with a stop-func,\n+    # and cannot assign a stop-func to a breakpoint with a condition.\n+\n+    delete_breakpoints\n+    set cond_bp [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define eval-bp1 (make-bp-eval \\\"$cond_bp\\\"))\" \\\n+\t\"create eval-bp1 breakpoint 2\"\n+    set test_cond {cond $bpnum}\n+    gdb_test \"$test_cond \\\"foo==3\\\"\" \\\n+\t\"Only one stop condition allowed.*\"\n+    gdb_scm_test_silent_cmd  \"guile (define eval-bp2 (make-bp-basic \\\"$cond_bp\\\"))\" \\\n+\t\"create basic breakpoint\"\n+    gdb_scm_test_silent_cmd  \"guile (set-breakpoint-condition! eval-bp2 \\\"1==1\\\")\" \\\n+\t\"set a condition\"\n+    gdb_test_multiline \"construct an eval function\" \\\n+\t\"guile\" \"\" \\\n+\t\"(define (stop-func bkpt)\" \"\" \\\n+\t\"   return #t)\" \"\" \\\n+\t\"end\" \"\"\n+    gdb_test \"guile (set-breakpoint-stop! eval-bp2 stop-func)\"  \\\n+\t\"Only one stop condition allowed.*\"\n+\n+    # Check that stop-func is run when location has normal bp.\n+\n+    delete_breakpoints\n+    gdb_breakpoint [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define check-eval (make-bp-eval \\\"$bp_location2\\\"))\" \\\n+\t\"create check-eval breakpoint\"\n+    gdb_test \"guile (print (bp-eval-count check-eval))\" \\\n+\t\"= 0\" \\\n+\t\"test that evaluate function has not been yet executed (ie count = 0)\"\n+    gdb_continue_to_breakpoint \"Break at multiply, second time\" \\\n+\t\".*$srcfile:$bp_location2.*\"\n+    gdb_test \"guile (print (bp-eval-count check-eval))\" \\\n+\t\"= 1\" \\\n+\t\"test that evaluate function is run when location also has normal bp\"\n+\n+    # Test watchpoints with stop-func.\n+\n+    gdb_test_multiline \"watchpoint stop func\" \\\n+\t\"guile\" \"\" \\\n+\t\"(define (make-wp-eval location)\" \"\" \\\n+\t\"  (let ((wp (create-breakpoint! location #:type BP_WATCHPOINT #:wp-class WP_WRITE)))\" \"\" \\\n+\t\"    (set-breakpoint-stop! wp\" \"\" \\\n+\t\"      (lambda (bkpt)\" \"\" \\\n+\t\"        (let ((result (parse-and-eval \\\"result\\\")))\" \"\" \\\n+\t\"          (value=? result 788))))\" \"\" \\\n+\t\"    wp))\" \"\" \\\n+\t\"end\" \"\"\n+\n+    delete_breakpoints\n+    gdb_scm_test_silent_cmd  \"guile (define wp1 (make-wp-eval \\\"result\\\"))\" \\\n+\t\"create watchpoint\"\n+    gdb_test \"continue\" \".*\\[Ww\\]atchpoint.*result.*Old value =.*New value = 788.*\" \\\n+\t\"test watchpoint write\"\n+\n+    # Misc final tests.\n+\n+    gdb_test \"guile (print (bp-eval-count never-eval-bp1))\" \\\n+\t\"= 0\" \\\n+\t\"check that this unrelated breakpoints eval function was never called\"\n }\n \n-proc test_bkpt_registration {} {\n+proc_with_prefix test_bkpt_registration {} {\n     global srcfile testfile\n \n-    with_test_prefix \"test_bkpt_registration\" {\n-\t# Start with a fresh gdb.\n-\tclean_restart ${testfile}\n-\n-\tif ![gdb_guile_runto_main] {\n-\t    return\n-\t}\n-\n-\t# Initially there should be one breakpoint: main.\n-\tgdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n-\t    \"get breakpoint list 1\"\n-\tgdb_test \"guile (register-breakpoint! (car blist))\" \\\n-\t    \"ERROR: .*: not a Scheme breakpoint.*\" \\\n-\t    \"try to register a non-guile breakpoint\"\n-\n-\tset bp_location1 [gdb_get_line_number \"Break at multiply.\"]\n-\tgdb_scm_test_silent_cmd  \"guile (define bp1 (make-breakpoint \\\"$bp_location1\\\"))\" \\\n-\t    \"create multiply breakpoint\"\n-\tgdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n-\t    \"= #f\" \"breakpoint invalid after creation\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n-\t    \"register bp1\"\n-\tgdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n-\t    \"= #t\" \"breakpoint valid after registration\"\n-\tgdb_test \"guile (register-breakpoint! bp1)\" \\\n-\t    \"ERROR: .*: breakpoint is already registered.*\" \\\n-\t    \"re-register already registered bp1\"\n-\tgdb_scm_test_silent_cmd \"guile (delete-breakpoint! bp1)\" \\\n-\t    \"delete registered breakpoint\"\n-\tgdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n-\t    \"= #f\" \"breakpoint invalid after deletion\"\n-\tgdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n-\t    \"re-register bp1\"\n-\tgdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n-\t    \"= #t\" \"breakpoint valid after re-registration\"\n+    # Start with a fresh gdb.\n+    clean_restart ${testfile}\n+\n+    if ![gdb_guile_runto_main] {\n+\treturn\n     }\n+\n+    # Initially there should be one breakpoint: main.\n+    gdb_scm_test_silent_cmd \"guile (define blist (breakpoints))\" \\\n+\t\"get breakpoint list 1\"\n+    gdb_test \"guile (register-breakpoint! (car blist))\" \\\n+\t\"ERROR: .*: not a Scheme breakpoint.*\" \\\n+\t\"try to register a non-guile breakpoint\"\n+\n+    set bp_location1 [gdb_get_line_number \"Break at multiply.\"]\n+    gdb_scm_test_silent_cmd  \"guile (define bp1 (make-breakpoint \\\"$bp_location1\\\"))\" \\\n+\t\"create multiply breakpoint\"\n+    gdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n+\t\"= #f\" \"breakpoint invalid after creation\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n+\t\"register bp1\"\n+    gdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n+\t\"= #t\" \"breakpoint valid after registration\"\n+    gdb_test \"guile (register-breakpoint! bp1)\" \\\n+\t\"ERROR: .*: breakpoint is already registered.*\" \\\n+\t\"re-register already registered bp1\"\n+    gdb_scm_test_silent_cmd \"guile (delete-breakpoint! bp1)\" \\\n+\t\"delete registered breakpoint\"\n+    gdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n+\t\"= #f\" \"breakpoint invalid after deletion\"\n+    gdb_scm_test_silent_cmd \"guile (register-breakpoint! bp1)\" \\\n+\t\"re-register bp1\"\n+    gdb_test \"guile (print (breakpoint-valid? bp1))\" \\\n+\t\"= #t\" \"breakpoint valid after re-registration\"\n }\n \n-proc test_bkpt_address {} {\n+proc_with_prefix test_bkpt_address {} {\n     global decimal srcfile\n \n     # Leading whitespace is intentional!\n@@ -501,7 +485,7 @@ proc test_bkpt_address {} {\n \t\".*Breakpoint ($decimal)+ at .*$srcfile, line ($decimal)+\\.\"\n }\n \n-proc test_bkpt_probe {} {\n+proc_with_prefix test_bkpt_probe {} {\n     global decimal hex testfile srcfile\n \n     if { [prepare_for_testing \"failed to prepare\" ${testfile}-probes \\"
    }
  ]
}