{
  "sha": "c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzA3NTRjZGQ5YWY2ZDgyNTllYWM1YzlkYWFkOWY5YjA2MTEzNThkZA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-23T21:12:16Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:07:29Z"
    },
    "message": "libctf: hashing\n\nlibctf maintains two distinct hash ADTs, one (ctf_dynhash) for wrapping\ndynamically-generated unknown-sized hashes during CTF file construction,\none (ctf_hash) for wrapping unchanging hashes whose size is known at\ncreation time for reading CTF files that were previously created.\n\nIn the binutils implementation, these are both fairly thin wrappers\naround libiberty hashtab.\n\nUnusually, this code is not kept synchronized with libdtrace-ctf,\ndue to its dependence on libiberty hashtab.\n\nlibctf/\n\t* ctf-hash.c: New file.\n\t* ctf-impl.h: New declarations.",
    "tree": {
      "sha": "625374afe71c3246193da4a6c8be8df14d0859be",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/625374afe71c3246193da4a6c8be8df14d0859be"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "479604f44fc1eaa02a97ebcc1b60f55a606c4046",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/479604f44fc1eaa02a97ebcc1b60f55a606c4046",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/479604f44fc1eaa02a97ebcc1b60f55a606c4046"
    }
  ],
  "stats": {
    "total": 311,
    "additions": 311,
    "deletions": 0
  },
  "files": [
    {
      "sha": "40f292d5d473f977389fbde3182f052d1a334171",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
      "patch": "@@ -1,3 +1,8 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-hash.c: New file.\n+\t* ctf-impl.h: New declarations.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-error.c: New file."
    },
    {
      "sha": "adfe93e5c09a69c5d8cbf164f73e2d59598d1569",
      "filename": "libctf/ctf-hash.c",
      "status": "added",
      "additions": 277,
      "deletions": 0,
      "changes": 277,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
      "patch": "@@ -0,0 +1,277 @@\n+/* Interface to hashtable implementations.\n+   Copyright (C) 2006-2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+#include \"libiberty.h\"\n+#include \"hashtab.h\"\n+\n+/* We have two hashtable implementations: one, ctf_dynhash_*(), is an interface to\n+   a dynamically-expanding hash with unknown size that should support addition\n+   of large numbers of items, and removal as well, and is used only at\n+   type-insertion time; the other, ctf_dynhash_*(), is an interface to a\n+   fixed-size hash from const char * -> ctf_id_t with number of elements\n+   specified at creation time, that should support addition of items but need\n+   not support removal.  These can be implemented by the same underlying hashmap\n+   if you wish.  */\n+\n+typedef struct ctf_helem\n+{\n+  void *key;\t\t\t /* Either a pointer, or a coerced ctf_id_t.  */\n+  void *value;\t\t\t /* The value (possibly a coerced int).  */\n+  ctf_hash_free_fun key_free;\n+  ctf_hash_free_fun value_free;\n+} ctf_helem_t;\n+\n+struct ctf_dynhash\n+{\n+  struct htab *htab;\n+  ctf_hash_free_fun key_free;\n+  ctf_hash_free_fun value_free;\n+};\n+\n+/* Hash functions. */\n+\n+unsigned int\n+ctf_hash_integer (const void *ptr)\n+{\n+  ctf_helem_t *hep = (ctf_helem_t *) ptr;\n+\n+  return htab_hash_pointer (hep->key);\n+}\n+\n+int\n+ctf_hash_eq_integer (const void *a, const void *b)\n+{\n+  ctf_helem_t *hep_a = (ctf_helem_t *) a;\n+  ctf_helem_t *hep_b = (ctf_helem_t *) b;\n+\n+  return htab_eq_pointer (hep_a->key, hep_b->key);\n+}\n+\n+unsigned int\n+ctf_hash_string (const void *ptr)\n+{\n+  ctf_helem_t *hep = (ctf_helem_t *) ptr;\n+\n+  return htab_hash_string (hep->key);\n+}\n+\n+int\n+ctf_hash_eq_string (const void *a, const void *b)\n+{\n+  ctf_helem_t *hep_a = (ctf_helem_t *) a;\n+  ctf_helem_t *hep_b = (ctf_helem_t *) b;\n+\n+  return !strcmp((const char *) hep_a->key, (const char *) hep_b->key);\n+}\n+\n+/* The dynhash, used for hashes whose size is not known at creation time. */\n+\n+/* Free a single ctf_helem.  */\n+\n+static void\n+ctf_dynhash_item_free (void *item)\n+{\n+  ctf_helem_t *helem = item;\n+\n+  if (helem->key_free && helem->key)\n+    helem->key_free (helem->key);\n+  if (helem->value_free && helem->value)\n+    helem->value_free (helem->value);\n+  free (helem);\n+}\n+\n+ctf_dynhash_t *\n+ctf_dynhash_create (ctf_hash_fun hash_fun, ctf_hash_eq_fun eq_fun,\n+                    ctf_hash_free_fun key_free, ctf_hash_free_fun value_free)\n+{\n+  ctf_dynhash_t *dynhash;\n+\n+  dynhash = malloc (sizeof (ctf_dynhash_t));\n+  if (!dynhash)\n+    return NULL;\n+\n+  /* 7 is arbitrary and untested for now..  */\n+  if ((dynhash->htab = htab_create_alloc (7, (htab_hash) hash_fun, eq_fun,\n+                                          ctf_dynhash_item_free, xcalloc, free)) == NULL)\n+    {\n+      free (dynhash);\n+      return NULL;\n+    }\n+\n+  dynhash->key_free = key_free;\n+  dynhash->value_free = value_free;\n+\n+  return dynhash;\n+}\n+\n+static ctf_helem_t **\n+ctf_hashtab_lookup (struct htab *htab, const void *key, enum insert_option insert)\n+{\n+  ctf_helem_t tmp = { .key = (void *) key };\n+  return (ctf_helem_t **) htab_find_slot (htab, &tmp, insert);\n+}\n+\n+static ctf_helem_t *\n+ctf_hashtab_insert (struct htab *htab, void *key, void *value)\n+{\n+  ctf_helem_t **slot;\n+\n+  slot = ctf_hashtab_lookup (htab, key, INSERT);\n+\n+  if (!slot)\n+    {\n+      errno = -ENOMEM;\n+      return NULL;\n+    }\n+\n+  if (!*slot)\n+    {\n+      *slot = malloc (sizeof (ctf_helem_t));\n+      if (!*slot)\n+\treturn NULL;\n+      (*slot)->key = key;\n+    }\n+  (*slot)->value = value;\n+  return *slot;\n+}\n+\n+int\n+ctf_dynhash_insert (ctf_dynhash_t *hp, void *key, void *value)\n+{\n+  ctf_helem_t *slot;\n+\n+  slot = ctf_hashtab_insert (hp->htab, key, value);\n+\n+  if (!slot)\n+    return errno;\n+\n+  /* We need to keep the key_free and value_free around in each item because the\n+     del function has no visiblity into the hash as a whole, only into the\n+     individual items.  */\n+\n+  slot->key_free = hp->key_free;\n+  slot->value_free = hp->value_free;\n+\n+  return 0;\n+}\n+\n+void\n+ctf_dynhash_remove (ctf_dynhash_t *hp, const void *key)\n+{\n+  htab_remove_elt (hp->htab, (void *) key);\n+}\n+\n+void *\n+ctf_dynhash_lookup (ctf_dynhash_t *hp, const void *key)\n+{\n+  ctf_helem_t **slot;\n+\n+  slot = ctf_hashtab_lookup (hp->htab, key, NO_INSERT);\n+\n+  if (slot)\n+    return (*slot)->value;\n+\n+  return NULL;\n+}\n+\n+void\n+ctf_dynhash_destroy (ctf_dynhash_t *hp)\n+{\n+  if (hp != NULL)\n+    htab_delete (hp->htab);\n+  free (hp);\n+}\n+\n+/* ctf_hash, used for fixed-size maps from const char * -> ctf_id_t without\n+   removal.  This is a straight cast of a hashtab.  */\n+\n+ctf_hash_t *\n+ctf_hash_create (unsigned long nelems, ctf_hash_fun hash_fun,\n+\t\t ctf_hash_eq_fun eq_fun)\n+{\n+  return (ctf_hash_t *) htab_create_alloc (nelems, (htab_hash) hash_fun,\n+\t\t\t\t\t   eq_fun, free, xcalloc, free);\n+}\n+\n+uint32_t\n+ctf_hash_size (const ctf_hash_t *hp)\n+{\n+  return htab_elements ((struct htab *) hp);\n+}\n+\n+int\n+ctf_hash_insert_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n+\t\t      uint32_t name)\n+{\n+  ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n+  const char *str = ctsp->cts_strs + CTF_NAME_OFFSET (name);\n+\n+  if (type == 0)\n+    return EINVAL;\n+\n+  if (ctsp->cts_strs == NULL)\n+    return ECTF_STRTAB;\n+\n+  if (ctsp->cts_len <= CTF_NAME_OFFSET (name))\n+    return ECTF_BADNAME;\n+\n+  if (str[0] == '\\0')\n+    return 0;\t\t   /* Just ignore empty strings on behalf of caller.  */\n+\n+  if (ctf_hashtab_insert ((struct htab *) hp, (char *) str,\n+\t\t\t  (void *) (ptrdiff_t) type) != NULL)\n+    return 0;\n+  return errno;\n+}\n+\n+/* if the key is already in the hash, override the previous definition with\n+   this new official definition. If the key is not present, then call\n+   ctf_hash_insert_type() and hash it in.  */\n+int\n+ctf_hash_define_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n+                      uint32_t name)\n+{\n+  /* This matches the semantics of ctf_hash_insert_type() in this\n+     implementation anyway.  */\n+\n+  return ctf_hash_insert_type (hp, fp, type, name);\n+}\n+\n+ctf_id_t\n+ctf_hash_lookup_type (ctf_hash_t *hp, ctf_file_t *fp __attribute__ ((__unused__)),\n+\t\t      const char *key)\n+{\n+  ctf_helem_t **slot;\n+\n+  slot = ctf_hashtab_lookup ((struct htab *) hp, key, NO_INSERT);\n+\n+  if (slot)\n+    return (ctf_id_t) ((*slot)->value);\n+\n+  return 0;\n+}\n+\n+void\n+ctf_hash_destroy (ctf_hash_t *hp)\n+{\n+  if (hp != NULL)\n+    htab_delete ((struct htab *) hp);\n+}"
    },
    {
      "sha": "31207cd5d72f98830fe8c206468d3a6537bfdf97",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c0754cdd9af6d8259eac5c9daad9f9b0611358dd/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=c0754cdd9af6d8259eac5c9daad9f9b0611358dd",
      "patch": "@@ -58,12 +58,41 @@ extern \"C\"\n \n #endif\n \n+/* libctf in-memory state.  */\n+\n+typedef struct ctf_fixed_hash ctf_hash_t; /* Private to ctf-hash.c.  */\n+typedef struct ctf_dynhash ctf_dynhash_t; /* Private to ctf-hash.c.  */\n+\n typedef struct ctf_list\n {\n   struct ctf_list *l_prev;\t/* Previous pointer or tail pointer.  */\n   struct ctf_list *l_next;\t/* Next pointer or head pointer.  */\n } ctf_list_t;\n \n+typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n+extern unsigned int ctf_hash_integer (const void *ptr);\n+extern unsigned int ctf_hash_string (const void *ptr);\n+\n+typedef int (*ctf_hash_eq_fun) (const void *, const void *);\n+extern int ctf_hash_eq_integer (const void *, const void *);\n+extern int ctf_hash_eq_string (const void *, const void *);\n+\n+typedef void (*ctf_hash_free_fun) (void *);\n+\n+extern ctf_hash_t *ctf_hash_create (unsigned long, ctf_hash_fun, ctf_hash_eq_fun);\n+extern int ctf_hash_insert_type (ctf_hash_t *, ctf_file_t *, uint32_t, uint32_t);\n+extern int ctf_hash_define_type (ctf_hash_t *, ctf_file_t *, uint32_t, uint32_t);\n+extern ctf_id_t ctf_hash_lookup_type (ctf_hash_t *, ctf_file_t *, const char *);\n+extern uint32_t ctf_hash_size (const ctf_hash_t *);\n+extern void ctf_hash_destroy (ctf_hash_t *);\n+\n+extern ctf_dynhash_t *ctf_dynhash_create (ctf_hash_fun, ctf_hash_eq_fun,\n+\t\t\t\t\t  ctf_hash_free_fun, ctf_hash_free_fun);\n+extern int ctf_dynhash_insert (ctf_dynhash_t *, void *, void *);\n+extern void ctf_dynhash_remove (ctf_dynhash_t *, const void *);\n+extern void *ctf_dynhash_lookup (ctf_dynhash_t *, const void *);\n+extern void ctf_dynhash_destroy (ctf_dynhash_t *);\n+\n #define\tctf_list_prev(elem)\t((void *)(((ctf_list_t *)(elem))->l_prev))\n #define\tctf_list_next(elem)\t((void *)(((ctf_list_t *)(elem))->l_next))\n "
    }
  ]
}