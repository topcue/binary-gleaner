{
  "sha": "775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzc1ZTI0MWU5YzVmMmIyZmYyYjU5OTcyYWI3MGU1ZjIwNzYzZmFlNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-10-07T18:52:13Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-08-12T16:57:56Z"
    },
    "message": "Import readline 7.0 (patch 5)\n\nThis imports readline 7.0 (up to patch 5) while preserving all\ngdb-local changes.\n\nThis was done by checking out the readline git repository, making a\nbranch based on the gdb baseline revision, applying the gdb changes to\nthat branch, and then merging from readline 7.\n\nreadline/ChangeLog.gdb\n2019-08-12  Tom Tromey  <tom@tromey.com>\n\n\t* Imported readline 7.0 patch 5.",
    "tree": {
      "sha": "597ab643dce69ee6e98e46ecac00ee85f447bb4b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/597ab643dce69ee6e98e46ecac00ee85f447bb4b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "08132bdd876fa1825810f90ecc25390dd4ded457",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08132bdd876fa1825810f90ecc25390dd4ded457",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/08132bdd876fa1825810f90ecc25390dd4ded457"
    }
  ],
  "stats": {
    "total": 10867,
    "additions": 9072,
    "deletions": 1795
  },
  "files": [
    {
      "sha": "be107bbad478f4873b9fdf03092ab3410eecabf7",
      "filename": "readline/.gitignore",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/.gitignore",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/.gitignore",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/.gitignore?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,37 @@\n+Makefile\n+\n+*.o\n+*.a\n+*.so\n+*.sl\n+*.dll\n+\n+config.cache\n+config.h\n+config.log\n+config.status\n+\n+doc/Makefile\n+examples/Makefile\n+shlib/Makefile\n+\n+examples/fileman\n+examples/hist_erasedups\n+examples/hist_purgecmd\n+examples/histexamp\n+examples/rl\n+examples/rl-callbacktest\n+examples/rlbasic\n+examples/rlcat\n+examples/rlevent\n+examples/rltest\n+examples/rlversion\n+\n+libhistory.so.*\n+libreadline.so.*\n+\n+*.dylib\n+\n+readline.pc\n+\n+stamp-h"
    },
    {
      "sha": "67945911cf4479b6e6fa540f5805906b3e21c7c8",
      "filename": "readline/CHANGELOG",
      "status": "modified",
      "additions": 211,
      "deletions": 0,
      "changes": 211,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/CHANGELOG",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/CHANGELOG",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/CHANGELOG?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1093,3 +1093,214 @@ xfree.c\n \t\t\t\t   -----\n {examples,shlib}/Makefile.in\n \t- Cygwin-based changes from Eric Blake <eblake@redhat.com>\n+\n+\t\t\t\t 3/26/2011\n+\t\t\t\t ---------\n+Makefile.in\n+\t- don't ignore failures when building, installing, or cleaning in\n+\t  the shlib subdirectory.  Sample patch from Mike Frysinger\n+\t  <vapier@gentoo.org>\n+\n+shlib/Makefile.in\n+\t- split the install and uninstall targets into install-supported and\n+\t  install-unsupported targets that depend on the value of\n+\t  SHLIB_STATUS\n+\n+\t\t\t\t    4/2\n+\t\t\t\t    ---\n+{,shlib}/Makefile.in\n+\t- add dependency for callback.o/callback.so on xmalloc.h.  From\n+\t  Jan Kratochvil  <jan.kratochvil@redhat.com>\n+\n+{,doc,examples,shlib}/Makefile.in\n+\t- fix typo: htm target should be html.  From Jan Kratochvil\n+\t  <jan.kratochvil@redhat.com>\n+\t- remove `.' from VPATH.  From Jan Kratochvil\n+\t   <jan.kratochvil@redhat.com>\n+\n+examples/rlfe/configure.in\n+\t- quote AC_PROGRAM_SOURCE.  From Jan Kratochvil\n+\t   <jan.kratochvil@redhat.com>\n+\n+\t\t\t\t   5/17\n+\t\t\t\t   ----\n+config.h.in\n+\t- WCWIDTH_BROKEN: new define, picked up from bash, defined on systems\n+\t  where wcwidth returns 1 for Unicode combining characters\n+\n+\t\t\t\t   11/28\n+\t\t\t\t   -----\n+support/shlib-install\n+\t- make sure solaris2 systems make the installed shared library\n+\t  executable.  ldd warns about it otherwise.  Bug and fix from\n+\t  Tim Mooney <tim.mooney@ndsu.edu>\n+\n+examples/hist_erasedups.c\n+\t- new example program, shows how to erase duplicates from the history\n+\t  list\n+\n+examples/hist_purgecmd.c\n+\t- new example program, shows how to remove all entries matching a\n+\t  string or pattern from the history list\n+\n+\t\t\t\t 1/12/2012\n+\t\t\t\t ---------\n+colors.[ch],parse-colors.[ch]}\n+\t- new files, part of color infrastructure support\n+\n+Makefile.in,shlib/Makefile.in\n+\t- arrange to have colors.o and parse-colors.o added to library\n+\t  (static and shared versions)\n+\n+{configure,config.h}.in\n+\t- check for stdbool.h, define HAVE_STDBOOL_H if found\n+\n+rldefs.h\n+\t- COLOR_SUPPORT: if defined, compile in colors.c and parse-colors.c\n+\t  for color support\n+\n+\t\t\t\t   1/18\n+\t\t\t\t   ----\n+\n+{configure,config.h}.in\n+        - new check: check for AUDIT_USER_TTY defined in <linux/audit.h>,\n+          define HAVE_DECL_AUDIT_USER_TTY if both are found\n+\n+\t\t\t\t    8/7\n+\t\t\t\t    ---\n+configure.in\n+\t- AC_CANONICAL_BUILD: call to set the build_xxx variables\n+\t- use $build_os instead of $host_os to decide when DJGPP should run\n+\t  `pwd.exe' to figure out the build directory.  Report and fix from\n+\t  Yao Qi <yao@codesourcery.com>\n+\n+\t\t\t\t   8/29\n+\t\t\t\t   ----\n+configure.ac\n+\t- new name for configure.in\n+\n+MANIFEST,Makefile.in\n+\t- configure.in -> configure.ac\n+\n+\t\t\t\t 1/5/2013\n+\t\t\t\t --------\n+configure.ac\n+\t- move version number up to 6.3\n+\n+\t\t\t\t   1/31\n+\t\t\t\t   ----\n+configure.ac\n+\t- use AC_CHECK_TOOL instead of AC_CHECK_PROG to check for ar, since it\n+\t  will find $host-prefixed versions of utilities.  Report and fix from\n+\t  Mike Frysinger <vapier@gentoo.org>\n+\n+\t\t\t\t    3/4\n+\t\t\t\t    ---\n+Makefile.in\n+        - PACKAGE_TARNAME, docdir: new variables substituted by autoconf\n+        - OTHER_DOCS,OTHER_INSTALLED_DOCS: new variables with auxiliary\n+\t  documentation files to be installed into $(docdir)\n+        - install: add new rule to install $(OTHER_DOCS)\n+        - uninstall: add new rule to uninstall $(docdir)/$(OTHER_INSTALLED_DOCS)\n+\n+\t\t\t\t   4/29\n+\t\t\t\t   ----\n+Makefile.in\n+\t- installdirs: make sure to create $(DESTDIR)$(docdir).  Report from\n+\t  <hiroo.hayashi@computer.org>\n+\n+\t\t\t\t 1/27/2014\n+\t\t\t\t ---------\n+Makefile.in\n+\t- install-examples: should not depend on `shared', since the examples\n+\t  themselves are not built using shared libraries.  Report from\n+\t  <hiroo.hayashi@computer.org>\n+\n+support/shobj-conf\n+\t- [from bash] darwin: changed the install_name embedded into the\n+\t  shared library to contain only the major version number, not the\n+\t  minor one. The idea is that the minor versions should all be API/ABI\n+\t  compatible, and it is better to link automatically with the latest\n+\t  one.  Idea from Max Horn <max@quendi.de>\n+\n+\t\t\t\t 2/26/2014\n+\t\t\t\t ---------\n+[readline-6.3 released]\n+\n+\t\t\t\t   3/14\n+\t\t\t\t   ----\n+shlib/Makefile.in\n+\t- fix typo in dependency list for vi_mode.so: it should not depend on\n+\t  just $(topdir). Report and fix from Natanael Copa\n+\t  <ncopa@alpinelinux.org>\n+\n+\t\t\t\t   4/15\n+\t\t\t\t   ----\n+{.,shlib,examples}/Makefile.in\n+\t- make sure $(INCLUDES) appears before $(CPPFLAGS) in the various\n+\t  CFLAGS assignments so readline looks in its own source and build\n+\t  directories (INCLUDES) before some directories specified by the\n+\t  user or builder (CPPFLAGS).  Report and fix from Max Horn\n+\t  <max@quendi.de>\n+\n+\t\t\t\t    6/2\n+\t\t\t\t    ---\n+config.h.in\n+\t- use correct symbols: HAVE_STRUCT_DIRENT_D_INO, HAVE_STRUCT_DIRENT_D_FILENO\n+\t  HAVE_STRUCT_DIRENT_D_NAMLEN.  They don't really matter, but they are\n+\t  what posixdir.h looks for.  Report from Ross Burton <ross.burton@intel.com>\n+\n+\t\t\t\t   6/11\n+\t\t\t\t   ----\n+readline.pc.in\n+\t- new file, config file for pkgconfig. Patch to add from Jirka Klimes\n+\t  <jklimes@redhat.com>\n+\n+{MANIFEST,configure.ac,Makefile.in}\n+\t- readline.pc: changes to create file for pkgconfig\n+\n+\t\t\t\t   10/13\n+\t\t\t\t   -----\n+doc/Makefile.in\n+\t- readline.pdf, history.pdf, rluserman.pdf: use texi2dvi --pdf to generate\n+\t  these.  Suggestion from Siep Kroonenberg <siepo@cybercomm.nl>\n+\n+\t\t\t\t   11/29\n+\t\t\t\t   -----\n+config.h.in\n+        - HAVE_PSELECT: define if pselect(2) available\n+\n+configure.ac\n+        - check for pselect(2), define HAVE_PSELECT if found\n+\n+\t\t\t\t   12/29\n+\t\t\t\t   -----\n+configure.ac\n+\t- bump version number up to 6.4\n+\n+\t\t\t\t 1/6/2015\n+\t\t\t\t --------\n+configure.ac,config.h.in\n+\t- look for ncurses/termcap.h, define HAVE_NCURSES_TERMCAP_H\n+\n+\t\t\t\t   4/20\n+\t\t\t\t   ----\n+configure.ac\n+\t- add template definitions set by AC_USE_SYSTEM_EXTENSIONS from a report\n+\t  from Andreas Schwab <schwab@linux-m68k.org>\n+\n+\t\t\t\t   4/24\n+\t\t\t\t   ----\n+configure.ac,config.h.in\n+\t- add check for sys/ioctl.h to AC_CHECK_HEADERS, define HAVE_SYS_IOCTL_H\n+\t  if found\n+\n+\t\t\t\t   5/29\n+\t\t\t\t   ----\n+configure.ac\n+\t- bump library version to 7.0 because of addition of rl_callback_sigcleanup\n+\n+\t\t\t\t   8/26\n+\t\t\t\t   ----\n+configure.ac,Makefile.in,examples/Makefile.in\n+\t- remove references to purify"
    },
    {
      "sha": "b5e16b716c9f37d82bae7f0e239abdb92b441263",
      "filename": "readline/CHANGES",
      "status": "modified",
      "additions": 324,
      "deletions": 0,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/CHANGES",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/CHANGES",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/CHANGES?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,3 +1,327 @@\n+This document details the changes between this version, readline-7.0, and the\n+previous version, readline-6.3.\n+\n+1.  Changes to Readline\n+\n+a.  A bug that caused vi-mode `.' to be unable to redo `c', `d', and `y'\n+    commands with modifiers was fixed.\n+\n+b.  Fixed a bug that caused callback mode to dump core when reading a\n+    multiple-key sequence (e.g., arrow keys).\n+\n+c.  Fixed a bug that caused the redisplay code to erase some of the line when\n+    using horizontal scrolling with incremental search.\n+\n+d.  Readline's input handler now performs signal processing if read(2) is\n+    interrupted by SIGALRM or SIGVTALRM.\n+\n+e.  Fixed a problem with revert-all-at-newline freeing freed memory.\n+\n+f.  Clarified the documentation for the history_quotes_inhibit_expansion\n+    variable to note that it inhibits scanning for the history comment\n+    character and that it only affects double-quoted strings.\n+\n+g.  Fixed an off-by-one error in the prompt printed when performing searches.\n+\n+h.  Use pselect(2), if available, to wait for input before calling read(2), so\n+    a SIGWINCH can interrupt it, since it doesn't interrupt read(2).\n+\n+i.  Some memory leaks caused by signals interrupting filename completion have\n+    been fixed.\n+\n+j.  Reading EOF twice on a non-empty line causes EOF to be returned, rather\n+    than the partial line.  This can cause partial lines to be executed on\n+    SIGHUP, for example.\n+\n+k.  Fixed a bug concerning deleting multibyte characters from the search\n+    string while performing an incremental search.\n+\n+l.  Fixed a bug with tilde expanding directory names in filename completion.\n+\n+m.  Fixed a bug that did not allow binding sequences beginning with a `\\'.\n+\n+n.  Fixed a redisplay bug involving incorrect line wrapping when the prompt\n+    contains a multibyte character in the last screen column.\n+\n+o.  Fixed a bug that caused history expansion to disregard characters that are\n+    documented to delimit a history event specifier without requiring `:'.\n+\n+p.  Fixed a bug that could cause reading past the end of a string when reading\n+    the value when binding the set of isearch terminators.\n+\n+q.  Fixed a bug that caused readline commands that depend on knowing which  \n+    key invoked them to misbehave when dispatching key sequences that are\n+    prefixes of other key bindings. \n+\n+r.  Paren matching now works in vi insert mode.\n+\n+s.  Colored completion prefixes are now displayed using a different color, less\n+    likely to collide with files.\n+\n+t.  Fixed a bug that caused vi-mode character search to misbehave when\n+    running in callback mode.\n+\n+u.  Fixed a bug that caused output to be delayed when input is coming from a\n+    macro in vi-mode.\n+\n+v.  Fixed a bug that caused the vi-mode `.' command to misbehave when redoing\n+    a multi-key key sequence via a macro.\n+\n+w.  Fixed a bug that caused problems with applications that supply their own\n+    input function when performing completion.\n+\n+x.  When read returns -1/EIO when attempting to read a key, return an error\n+    instead of line termination back to the caller.\n+\n+y.  Updated tty auditing feature based on patch from Red Hat.\n+\n+z.  Fixed a bug that could cause the history library to crash on overflows\n+    introduced by malicious editing of timestamps in the history file.\n+\n+aa. The history file writing functions only attempt to create and use a backup\n+    history file if the history file exists and is a regular file.\n+\n+bb. Fixed an out-of-bounds read in readline's internal tilde expansion interface.\n+\n+cc. Fixed several redisplay bugs with prompt strings containing multibyte\n+    and non-visible characters whose physical length is longer than the screen\n+    width.\n+\n+dd. Fixed a redisplay bug with prompt strings containing invisible characters\n+    whose physical length exceeds the screen width and using incremental search.\n+\n+ee. Readline prints more descriptive error messages when it encounters errors\n+    while reading an inputrc file.\n+\n+ff. Fixed a bug in the character insertion code that attempts to optimize\n+    typeahead when it reads a character that is not bound to self-insert and\n+    resets the key sequence state.\n+\n+gg.  When refreshing the line as the result of a key sequence, Readline attempts\n+     to redraw only the last line of a multiline prompt.\n+\n+hh.  Fixed an issue that caused completion of git commands to display\n+     incorrectly when using colored-completion-prefix.\n+\n+ii.  Fixed several redisplay bugs having to do with multibyte characters and\n+     invisible characters in prompt strings.\n+\n+jj. Fixed a bug that caused mode strings to be displayed incorrectly if the\n+    prompt was shorter than the mode string.\n+\n+2.  New Features in Readline\n+\n+a.  The history truncation code now uses the same error recovery mechansim as\n+    the history writing code, and restores the old version of the history file\n+    on error.  The error recovery mechanism handles symlinked history files.\n+\n+b.  There is a new bindable variable, `enable-bracketed-paste', which enables\n+    support for a terminal's bracketed paste mode.\n+\n+c.  The editing mode indicators can now be strings and are user-settable\n+    (new `emacs-mode-string', `vi-cmd-mode-string' and `vi-ins-mode-string'\n+    variables).  Mode strings can contain invisible character sequences.\n+    Setting mode strings to null strings restores the defaults.\n+\n+d.  Prompt expansion adds the mode string to the last line of a multi-line\n+    prompt (one with embedded newlines).\n+\n+e.  There is a new bindable variable, `colored-completion-prefix', which, if\n+    set, causes the common prefix of a set of possible completions to be\n+    displayed in color.\n+\n+f.  There is a new bindable command `vi-yank-pop', a vi-mode version of emacs-\n+    mode yank-pop.\n+\n+g.  The redisplay code underwent several efficiency improvements for multibyte\n+    locales.\n+\n+h.  The insert-char function attempts to batch-insert all pending typeahead\n+    that maps to self-insert, as long as it is coming from the terminal.\n+\n+i.  rl_callback_sigcleanup: a new application function that can clean up and\n+    unset any state set by readline's callback mode.  Intended to be used\n+    after a signal.\n+\n+j.  If an incremental search string has its last character removed with DEL, the\n+    resulting empty search string no longer matches the previous line.\n+\n+k.  If readline reads a history file that begins with `#' (or the value of\n+    the history comment character) and has enabled history timestamps, the history\n+    entries are assumed to be delimited by timestamps.  This allows multi-line\n+    history entries.\n+\n+l.  Readline now throws an error if it parses a key binding without a terminating\n+    `:' or whitespace.\n+\n+m.  The default binding for ^W in vi mode now uses word boundaries specified\n+    by Posix (vi-unix-word-rubout is bindable command name).\n+\n+n.  rl_clear_visible_line: new application-callable function; clears all\n+    screen lines occupied by the current visible readline line.\n+\n+o.  rl_tty_set_echoing: application-callable function that controls whether\n+    or not readline thinks it is echoing terminal output.\n+\n+p.  Handle >| and strings of digits preceding and following redirection\n+    specifications as single tokens when tokenizing the line for history\n+    expansion.\n+\n+q.  Fixed a bug with displaying completions when the prefix display length\n+    is greater than the length of the completions to be displayed.\n+\n+r.  The :p history modifier now applies to the entire line, so any expansion\n+    specifying :p causes the line to be printed instead of expanded.\n+\n+s.  New application-callable function: rl_pending_signal(): returns the signal\n+    number of any signal readline has caught but not yet handled.\n+    \n+t.  New application-settable variable: rl_persistent_signal_handlers: if set\n+    to a non-zero value, readline will enable the readline-6.2 signal handler\n+    behavior in callback mode: handlers are installed when\n+    rl_callback_handler_install is called and removed removed when a complete\n+    line has been read.\n+\n+-------------------------------------------------------------------------------\n+This document details the changes between this version, readline-6.3, and the\n+previous version, readline-6.2.\n+\n+1.  Changes to Readline\n+\n+a.  Fixed a bug that did not allow the `dd', `cc', or `yy' vi editing mode\n+    commands to work on the entire line.\n+\n+b.  Fixed a bug that caused redisplay problems with prompts longer than 128\n+    characters and history searches.\n+\n+c.  Fixed a bug that caused readline to try and run code to modify its idea\n+    of the screen size in a signal handler context upon receiving a SIGWINCH.\n+\n+d.  Fixed a bug that caused the `meta' key to be enabled beyond the duration\n+    of an individual call top readline().\n+    \n+e.  Added a workaround for a wcwidth bug in Mac OS X that caused readline's\n+    redisplay to mishandle zero-width combining characters.\n+\n+f.  Fixed a bug that caused readline to `forget' part of a key sequence when\n+    a multiple-key sequence caused it to break out of an incremental search.\n+\n+g.  Fixed bugs that caused readline to execute code in a signal handler\n+    context if interrupted while reading from the file system during completion.\n+\n+h.  Fixed a bug that caused readline to `forget' part of a key sequence when\n+    reading an unbound multi-character key sequence.\n+\n+i.  Fixed a bug that caused Readline's signal handlers to be installed beyond\n+    the bounds of a single call to readline().\n+\n+j.  Fixed a bug that caused the `.' command to not redo the most recent `R'\n+    command in vi mode.\n+\n+k.  Fixed a bug that caused ignoring case in completion matches to result in\n+    readline using the wrong match.\n+\n+l.  Paren matching now works in vi insert mode.\n+\n+m.  Fix menu-completion to make show-all-if-ambiguous and menu-complete-display-prefix\n+    work together.\n+\n+n.  Fixed a bug that didn't allow the `cc', `dd', or `yy' commands to be redone\n+    in vi editing mode.\n+\n+o.  Fixed a bug that caused the filename comparison code to not compare\n+    multibyte characters correctly when using case-sensitive or case-mapping\n+    comparisons.\n+\n+p.  Fixed the input reading loop to call the input hook function only when there\n+    is no terminal input available.\n+\n+q.  Fixed a bug that caused binding a macro to a multi-character key sequence\n+    where the sequence and macro value share a common prefix to not perform\n+    the macro replacement.\n+\n+r.  Fixed several redisplay errors with multibyte characters and prompts\n+    containing invisible characters when using horizontal scrolling.\n+\n+s.  Fixed a bug that caused redisplay errors when trying to overwrite\n+    existing characters using multibyte characters.\n+\n+t.  Fixed a bug in vi mode that caused the arrow keys to set the saved last\n+    vi-mode command to the wrong value.\n+\n+u.  Fixed a bug that caused double-quoted strings to be scanned incorrectly\n+    when being used as the value of a readline variable assignment.\n+\n+v.  Fixed a bug with vi mode that prevented `.' from repeating a command\n+    entered on a previous line (command).\n+\n+w.  Fixed a bug that could cause completion to core dump if it was interrupted\n+    by a signal.\n+\n+x. Fixed a bug that could cause readline to crash and seg fault attempting to\n+   expand an empty history entry.\n+\n+y. Fixed a bug that caused display problems with multi-line prompts containing\n+   invisible characters on multiple lines.\n+   \n+z. Fixed a bug that caused effects made by undoing changes to a history line to\n+   be discarded.\n+\n+2.  New Features in Readline\n+\n+a.  Readline is now more responsive to SIGHUP and other fatal signals when\n+    reading input from the terminal or performing word completion but no\n+    longer attempts to run any not-allowable functions from a signal handler\n+    context.\n+\n+b.  There are new bindable commands to search the history for the string of\n+    characters between the beginning of the line and the point\n+    (history-substring-search-forward, history-substring-search-backward)\n+\n+c.  Readline allows quoted strings as the values of variables when setting\n+    them with `set'.  As a side effect, trailing spaces and tabs are ignored\n+    when setting a string variable's value.\n+\n+d.  The history library creates a backup of the history file when writing it\n+    and restores the backup on a write error.\n+\n+e.  New application-settable variable: rl_filename_stat_hook: a function called\n+    with a filename before using it in a call to stat(2).  Bash uses it to\n+    expand shell variables so things like $HOME/Downloads have a slash\n+    appended.\n+\n+f.  New bindable function `print-last-kbd-macro', prints the most-recently-\n+    defined keyboard macro in a reusable format.\n+\n+g.  New user-settable variable `colored-stats', enables use of colored text\n+    to denote file types when displaying possible completions (colored analog\n+    of visible-stats).\n+\n+h.  New user-settable variable `keyseq-timout', acts as an inter-character\n+    timeout when reading input or incremental search strings.\n+\n+i.  New application-callable function: rl_clear_history. Clears the history list\n+    and frees all readline-associated private data.\n+\n+j.  New user-settable variable, show-mode-in-prompt, adds a characters to the\n+    beginning of the prompt indicating the current editing mode.\n+\n+k.  New application-settable variable: rl_input_available_hook; function to be\n+    called when readline needs to check whether there is data available on its\n+    input source.  The default hook checks rl_instream.\n+\n+l.  Readline calls an application-set event hook (rl_signal_event_hook) after\n+    it gets a signal while reading input (read returns -1/EINTR but readline    \n+    does not handle the signal immediately) to allow the application to handle\n+    or otherwise note it.  Not currently called for SIGHUP or SIGTERM.\n+    \n+m.  If the user-settable variable `history-size' is set to a value less than\n+    0, the history list size is unlimited.\n+\n+n.  When creating shared libraries on Mac OS X, the pathname written into the\n+    library (install_name) no longer includes the minor version number.\n+\n+-------------------------------------------------------------------------------\n This document details the changes between this version, readline-6.2,\n and the previous version, readline-6.1.\n "
    },
    {
      "sha": "fb53dc604cc37dd099489c4aae08a41bbb6e35a9",
      "filename": "readline/ChangeLog.gdb",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/ChangeLog.gdb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/ChangeLog.gdb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/ChangeLog.gdb?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,3 +1,7 @@\n+2019-08-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* Imported readline 7.0 patch 5.\n+\n 2019-07-12  Tom de Vries  <tdevries@suse.de>\n \t    Chet Ramey  <chet.ramey@case.edu>\n "
    },
    {
      "sha": "e1a92d32667f83215e34edb02e239d27e1803ee8",
      "filename": "readline/INSTALL",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/INSTALL",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/INSTALL",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/INSTALL?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n Basic Installation\n ==================\n \n-These are installation instructions for Readline-6.2.\n+These are installation instructions for Readline-7.0.\n \n The simplest way to compile readline is:\n "
    },
    {
      "sha": "bfd05470644a62a0857411975777a62ef1f319d8",
      "filename": "readline/MANIFEST",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/MANIFEST",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/MANIFEST",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/MANIFEST?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -18,13 +18,16 @@ USAGE\t\tf\n aclocal.m4\tf\n config.h.in\tf\n configure\tf\n-configure.in\tf\n+configure.ac\tf\n Makefile.in\tf\n+readline.pc.in\tf\n ansi_stdlib.h\tf\n chardefs.h\tf\n+colors.h\tf\n history.h\tf\n histlib.h\tf\n keymaps.h\tf\n+parse-colors.h\tf\n posixdir.h\tf\n posixjmp.h\tf\n posixselect.h\tf\n@@ -44,6 +47,7 @@ tilde.h\t\tf\n xmalloc.h\tf\n bind.c\t\tf\n callback.c\tf\n+colors.c\tf\n compat.c\tf\n complete.c\tf\n display.c\tf\n@@ -58,6 +62,7 @@ mbutil.c\tf\n misc.c\t\tf\n nls.c\t\tf\n parens.c\tf\n+parse-colors.c\tf\n readline.c\tf\n rltty.c\t\tf\n savestring.c\tf\n@@ -110,13 +115,17 @@ examples/fileman.c\tf\n examples/manexamp.c\tf\n examples/readlinebuf.h\tf\n examples/rl-fgets.c\tf\n+examples/rlbasic.c\tf\n examples/rlcat.c\tf\n examples/rlevent.c\tf\n examples/rltest.c\tf\n+examples/rl-callbacktest.c\tf\n examples/rl.c\t\tf\n examples/rlptytest.c\tf\n examples/rlversion.c\tf\n examples/histexamp.c\tf\n+examples/hist_erasedups.c\tf\n+examples/hist_purgecmd.c\tf\n examples/Inputrc\tf\n examples/autoconf/BASH_CHECK_LIB_TERMCAP\tf\n examples/autoconf/RL_LIB_READLINE_VERSION\tf"
    },
    {
      "sha": "0916d33e065c4bd4a65007705aa8b210d9f25562",
      "filename": "readline/Makefile.in",
      "status": "modified",
      "additions": 45,
      "deletions": 15,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/Makefile.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -26,6 +26,8 @@ PACKAGE_NAME = @PACKAGE_NAME@\n PACKAGE_STRING = @PACKAGE_STRING@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n \n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+\n srcdir = @srcdir@\n VPATH = @srcdir@\n top_srcdir = @top_srcdir@\n@@ -43,8 +45,6 @@ RM = rm -f\n CP = cp\n MV = mv\n \n-PURIFY = @PURIFY@\n-\n @SET_MAKE@\n SHELL = @MAKE_SHELL@\n \n@@ -62,6 +62,8 @@ localedir = @localedir@\n \n infodir = @infodir@\n \n+docdir = @docdir@\n+\n man3dir = $(mandir)/man3\n \n # Support an alternate destination root directory for package building\n@@ -83,7 +85,7 @@ TERMCAP_LIB = @TERMCAP_LIB@\n # For libraries which include headers from other libraries.\n INCLUDES = -I. -I$(srcdir)\n \n-XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES)\n+XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(INCLUDES) $(CPPFLAGS)\n CCFLAGS = $(XCCFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)\n \n # could add -Werror here\n@@ -121,14 +123,17 @@ HSOURCES = $(srcdir)/readline.h $(srcdir)/rldefs.h $(srcdir)/chardefs.h \\\n \t   $(srcdir)/tilde.h $(srcdir)/rlconf.h $(srcdir)/rltty.h \\\n \t   $(srcdir)/ansi_stdlib.h $(srcdir)/tcap.h $(srcdir)/rlstdc.h \\\n \t   $(srcdir)/xmalloc.h $(srcdir)/rlprivate.h $(srcdir)/rlshell.h \\\n-\t   $(srcdir)/rltypedefs.h $(srcdir)/rlmbutil.h\n+\t   $(srcdir)/rltypedefs.h $(srcdir)/rlmbutil.h \\\n+\t   $(srcdir)/colors.h $(srcdir)/parse-colors.h\n \n HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o mbutil.o\n TILDEOBJ = tilde.o\n+COLORSOBJ = colors.o parse-colors.o\n OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \\\n \t  rltty.o complete.o bind.o isearch.o display.o signals.o \\\n \t  util.o kill.o undo.o macro.o input.o callback.o terminal.o \\\n-\t  text.o nls.o misc.o compat.o xfree.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)\n+\t  text.o nls.o misc.o $(HISTOBJ) $(TILDEOBJ) $(COLORSOBJ) \\\n+\t  xmalloc.o xfree.o compat.o\n \n # The texinfo files which document this library.\n DOCSOURCE = doc/rlman.texinfo doc/rltech.texinfo doc/rluser.texinfo\n@@ -138,12 +143,15 @@ DOCUMENTATION = $(DOCSOURCE) $(DOCOBJECT) $(DOCSUPPORT)\n \n CREATED_MAKEFILES = Makefile doc/Makefile examples/Makefile shlib/Makefile\n CREATED_CONFIGURE = config.status config.h config.cache config.log \\\n-\t\t    stamp-config stamp-h\n+\t\t    stamp-config stamp-h readline.pc\n CREATED_TAGS = TAGS tags\n \n INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \\\n \t\t    rlstdc.h rlconf.h rltypedefs.h\n \n+OTHER_DOCS = $(srcdir)/CHANGES $(srcdir)/INSTALL $(srcdir)/README\n+OTHER_INSTALLED_DOCS = CHANGES INSTALL README\n+\n ##########################################################################\n TARGETS = @STATIC_TARGET@ @SHARED_TARGET@\n INSTALL_TARGETS = @STATIC_INSTALL_TARGET@ @SHARED_INSTALL_TARGET@\n@@ -193,13 +201,13 @@ stamp-h: config.status $(srcdir)/config.h.in\n \tCONFIG_FILES= CONFIG_HEADERS=config.h ./config.status\n \techo > $@\n \n-#$(srcdir)/configure: $(srcdir)/configure.in\t## Comment-me-out in distribution\n+#$(srcdir)/configure: $(srcdir)/configure.ac\t## Comment-me-out in distribution\n #\tcd $(srcdir) && autoconf\t## Comment-me-out in distribution\n \n \n shared:\tforce\n \t-test -d shlib || mkdir shlib\n-\t-( cd shlib ; ${MAKE} ${MFLAGS} all )\n+\t( cd shlib ; ${MAKE} ${MFLAGS} all )\n \n documentation: force\n \t-test -d doc || mkdir doc\n@@ -245,32 +253,34 @@ install-static: installdirs $(STATIC_LIBS) install-headers install-doc install-e\n installdirs: $(srcdir)/support/mkinstalldirs\n \t-$(SHELL) $(srcdir)/support/mkinstalldirs $(DESTDIR)$(includedir) \\\n \t\t$(DESTDIR)$(includedir)/readline $(DESTDIR)$(libdir) \\\n-\t\t$(DESTDIR)$(infodir) $(DESTDIR)$(man3dir)\n+\t\t$(DESTDIR)$(infodir) $(DESTDIR)$(man3dir) $(DESTDIR)$(docdir)\n \n uninstall: uninstall-headers uninstall-doc uninstall-examples\n \t-test -n \"$(DESTDIR)$(libdir)\" && cd $(DESTDIR)$(libdir) && \\\n \t\t${RM} libreadline.a libreadline.old libhistory.a libhistory.old $(SHARED_LIBS)\n \t-( cd shlib; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} uninstall )\n \n install-shared: installdirs install-headers shared install-doc\n-\t-( cd shlib ; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} install )\n+\t( cd shlib ; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} install )\n \t\n uninstall-shared: maybe-uninstall-headers\n \t-( cd shlib; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} uninstall )\n \n-install-examples: installdirs install-headers shared\n+install-examples: installdirs install-headers\n \t-( cd examples ; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} install )\n \t\n uninstall-examples: maybe-uninstall-headers\n \t-( cd examples; ${MAKE} ${MFLAGS} DESTDIR=${DESTDIR} uninstall )\n \n install-doc:\tinstalldirs\n+\t$(INSTALL_DATA) $(OTHER_DOCS) $(DESTDIR)$(docdir)\n \t-( if test -d doc ; then \\\n \t\tcd doc && \\\n \t\t${MAKE} ${MFLAGS} infodir=$(infodir) DESTDIR=${DESTDIR} install; \\\n \t  fi )\n \n uninstall-doc:\n+\t-( cd $(DESTDIR)$(docdir) && ${RM} ${OTHER_INSTALLED_DOCS} )\n \t-( if test -d doc ; then \\\n \t\tcd doc && \\\n \t\t${MAKE} ${MFLAGS} infodir=$(infodir) DESTDIR=${DESTDIR} uninstall; \\\n@@ -285,23 +295,26 @@ tags:\tforce\n clean:\tforce\n \t$(RM) $(OBJECTS) $(STATIC_LIBS)\n \t$(RM) readline readline.exe\n-\t-( cd shlib && $(MAKE) $(MFLAGS) $@ )\n+\t( cd shlib && $(MAKE) $(MFLAGS) $@ )\n \t-( cd doc && $(MAKE) $(MFLAGS) $@ )\n \t-( cd examples && $(MAKE) $(MFLAGS) $@ )\n \n mostlyclean: clean\n-\t-( cd shlib && $(MAKE) $(MFLAGS) $@ )\n+\t( cd shlib && $(MAKE) $(MFLAGS) $@ )\n \t-( cd doc && $(MAKE) $(MFLAGS) $@ )\n \t-( cd examples && $(MAKE) $(MFLAGS) $@ )\n \n distclean maintainer-clean: clean\n-\t-( cd shlib && $(MAKE) $(MFLAGS) $@ )\n+\t( cd shlib && $(MAKE) $(MFLAGS) $@ )\n \t-( cd doc && $(MAKE) $(MFLAGS) $@ )\n \t-( cd examples && $(MAKE) $(MFLAGS) $@ )\n \t$(RM) Makefile\n \t$(RM) $(CREATED_CONFIGURE)\n \t$(RM) $(CREATED_TAGS)\n \n+readline.pc:\tconfig.status $(srcdir)/readline.pc.in\n+\t$(SHELL) config.status\n+\n info dvi html pdf ps:\n \t-( cd doc && $(MAKE) $(MFLAGS) $@ )\n \n@@ -332,7 +345,8 @@ bind.o: history.h\n callback.o: rlconf.h\n callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h\n callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h\n-compat.o: rlstdc.h\n+compat.o: ${BUILD_DIR}/config.h\n+compat.o: rlstdc.h rltypedefs.h\n complete.o: ansi_stdlib.h posixdir.h posixstat.h\n complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h\n complete.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h\n@@ -393,6 +407,7 @@ readline.o: posixstat.h ansi_stdlib.h posixjmp.h\n rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h\n rltty.o: rltty.h\n rltty.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h\n+savestring.o: ${BUILD_DIR}/config.h\n search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h\n search.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h\n search.o: ansi_stdlib.h history.h rlstdc.h\n@@ -426,6 +441,14 @@ xfree.o: ansi_stdlib.h readline.h\n xmalloc.o: ${BUILD_DIR}/config.h\n xmalloc.o: ansi_stdlib.h\n \n+colors.o: ${BUILD_DIR}/config.h colors.h\n+colors.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h\n+colors.o: rlconf.h  \n+colors.o: ansi_stdlib.h posixstat.h\n+parse-colors.o: ${BUILD_DIR}/config.h colors.h parse-colors.h\n+parse-colors.o: rldefs.h rlconf.h\n+parse-colors.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h\n+\n bind.o: rlshell.h\n histfile.o: rlshell.h\n nls.o: rlshell.h\n@@ -455,6 +478,8 @@ text.o: rlprivate.h\n undo.o: rlprivate.h\n util.o: rlprivate.h\n vi_mode.o: rlprivate.h\n+colors.o: rlprivate.h\n+parse-colors.o: rlprivate.h\n \n bind.o: xmalloc.h\n callback.o: xmalloc.h\n@@ -483,6 +508,8 @@ util.o: xmalloc.h\n vi_mode.o: xmalloc.h\n xfree.o: xmalloc.h\n xmalloc.o: xmalloc.h\n+colors.o: xmalloc.h\n+parse-colors.o: xmalloc.h\n \n complete.o: rlmbutil.h\n display.o: rlmbutil.h\n@@ -526,6 +553,9 @@ vi_mode.o: $(srcdir)/vi_mode.c\n xfree.o: $(srcdir)/xfree.c\n xmalloc.o: $(srcdir)/xmalloc.c\n \n+colors.o: $(srcdir)/parse-colors.c\n+parse-colors.o: $(srcdir)/parse-colors.c\n+\n histexpand.o: $(srcdir)/histexpand.c\n histfile.o: $(srcdir)/histfile.c\n history.o: $(srcdir)/history.c"
    },
    {
      "sha": "cf7107e7f691d1aad278072aa41d14155dc494d1",
      "filename": "readline/NEWS",
      "status": "modified",
      "additions": 288,
      "deletions": 14,
      "changes": 302,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/NEWS?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,19 +1,293 @@\n-This is a terse description of the new features added to readline-6.2 since\n-the release of readline-6.1.\n+This is a terse description of the new features added to readline-7.0 since\n+the release of readline-6.3.\n \n-a.  The history library does not try to write the history filename in the\n-    current directory if $HOME is unset.  This closes a potential security\n-    problem if the application does not specify a history filename.\n+New Features in Readline\n \n-b.  New bindable variable `completion-display-width' to set the number of\n-    columns used when displaying completions.\n+a.  The history truncation code now uses the same error recovery mechansim as\n+    the history writing code, and restores the old version of the history file\n+    on error.  The error recovery mechanism handles symlinked history files.\n \n-c.  New bindable variable `completion-case-map' to cause case-insensitive\n-    completion to treat `-' and `_' as identical.\n+b.  There is a new bindable variable, `enable-bracketed-paste', which enables\n+    support for a terminal's bracketed paste mode.\n \n-d.  There are new bindable vi-mode command names to avoid readline's case-\n-    insensitive matching not allowing them to be bound separately.\n+c.  The editing mode indicators can now be strings and are user-settable\n+    (new `emacs-mode-string', `vi-cmd-mode-string' and `vi-ins-mode-string'\n+    variables).  Mode strings can contain invisible character sequences.\n+    Setting mode strings to null strings restores the defaults.\n \n-e.  New bindable variable `menu-complete-display-prefix' causes the menu\n-    completion code to display the common prefix of the possible completions\n-    before cycling through the list, instead of after.\n+d.  Prompt expansion adds the mode string to the last line of a multi-line\n+    prompt (one with embedded newlines).\n+\n+e.  There is a new bindable variable, `colored-completion-prefix', which, if\n+    set, causes the common prefix of a set of possible completions to be\n+    displayed in color.\n+\n+f.  There is a new bindable command `vi-yank-pop', a vi-mode version of emacs-\n+    mode yank-pop.\n+\n+g.  The redisplay code underwent several efficiency improvements for multibyte\n+    locales.\n+\n+h.  The insert-char function attempts to batch-insert all pending typeahead\n+    that maps to self-insert, as long as it is coming from the terminal.\n+\n+i.  rl_callback_sigcleanup: a new application function that can clean up and\n+    unset any state set by readline's callback mode.  Intended to be used\n+    after a signal.\n+\n+j.  If an incremental search string has its last character removed with DEL, the\n+    resulting empty search string no longer matches the previous line.\n+\n+k.  If readline reads a history file that begins with `#' (or the value of\n+    the history comment character) and has enabled history timestamps, the history\n+    entries are assumed to be delimited by timestamps.  This allows multi-line\n+    history entries.\n+\n+l.  Readline now throws an error if it parses a key binding without a terminating\n+    `:' or whitespace.\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-6.3 since\n+the release of readline-6.2.\n+\n+New Features in Readline\n+\n+a.  Readline is now more responsive to SIGHUP and other fatal signals when\n+    reading input from the terminal or performing word completion but no\n+    longer attempts to run any not-allowable functions from a signal handler\n+    context.\n+\n+b.  There are new bindable commands to search the history for the string of\n+    characters between the beginning of the line and the point\n+    (history-substring-search-forward, history-substring-search-backward)\n+\n+c.  Readline allows quoted strings as the values of variables when setting\n+    them with `set'.  As a side effect, trailing spaces and tabs are ignored\n+    when setting a string variable's value.\n+\n+d.  The history library creates a backup of the history file when writing it\n+    and restores the backup on a write error.\n+\n+e.  New application-settable variable: rl_filename_stat_hook: a function called\n+    with a filename before using it in a call to stat(2).  Bash uses it to\n+    expand shell variables so things like $HOME/Downloads have a slash\n+    appended.\n+\n+f.  New bindable function `print-last-kbd-macro', prints the most-recently-\n+    defined keyboard macro in a reusable format.\n+\n+g.  New user-settable variable `colored-stats', enables use of colored text\n+    to denote file types when displaying possible completions (colored analog\n+    of visible-stats).\n+\n+h.  New user-settable variable `keyseq-timout', acts as an inter-character\n+    timeout when reading input or incremental search strings.\n+\n+i.  New application-callable function: rl_clear_history. Clears the history list\n+    and frees all readline-associated private data.\n+\n+j.  New user-settable variable, show-mode-in-prompt, adds a characters to the\n+    beginning of the prompt indicating the current editing mode.\n+\n+k.  New application-settable variable: rl_input_available_hook; function to be\n+    called when readline detects there is data available on its input file\n+    descriptor.\n+\n+l.  Readline calls an application-set event hook (rl_event_hook) after it gets\n+    a signal while reading input (read returns -1/EINTR but readline does not\n+    handle the signal immediately) to allow the application to handle or\n+    otherwise note it.\n+\n+m.  If the user-settable variable `history-size' is set to a value less than\n+    0, the history list size is unlimited.\n+\n+n.  New application-settable variable: rl_signal_event_hook; function that is\n+    called when readline is reading terminal input and read(2) is interrupted\n+    by a signal.  Currently not called for SIGHUP or SIGTERM.\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-6.1 since\n+the release of readline-6.0.\n+\n+New Features in Readline\n+\n+a.  New bindable function: menu-complete-backward.\n+\n+b.  In the vi insertion keymap, C-n is now bound to menu-complete by default,\n+    and C-p to menu-complete-backward.\n+\n+c.  When in vi command mode, repeatedly hitting ESC now does nothing, even\n+    when ESC introduces a bound key sequence.  This is closer to how\n+    historical vi behaves.\n+\n+d.  New bindable function: skip-csi-sequence.  Can be used as a default to\n+    consume key sequences generated by keys like Home and End without having\n+    to bind all keys.\n+\n+e.  New application-settable function: rl_filename_rewrite_hook.  Can be used\n+    to rewite or modify filenames read from the file system before they are\n+    compared to the word to be completed.\n+\n+f.  New bindable variable: skip-completed-text, active when completing in the\n+    middle of a word.  If enabled, it means that characters in the completion\n+    that match characters in the remainder of the word are \"skipped\" rather\n+    than inserted into the line.\n+\n+g.  The pre-readline-6.0 version of menu completion is available as\n+    \"old-menu-complete\" for users who do not like the readline-6.0 version.\n+\n+h.  New bindable variable: echo-control-characters.  If enabled, and the\n+    tty ECHOCTL bit is set, controls the echoing of characters corresponding\n+    to keyboard-generated signals.\n+\n+i.  New bindable variable: enable-meta-key.  Controls whether or not readline\n+    sends the smm/rmm sequences if the terminal indicates it has a meta key\n+    that enables eight-bit characters.\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-6.0 since\n+the release of readline-5.2.\n+\n+New Features in Readline\n+\n+a.  A new variable, rl_sort_completion_matches; allows applications to inhibit\n+    match list sorting (but beware: some things don't work right if\n+    applications do this).\n+\n+b.  A new variable, rl_completion_invoking_key; allows applications to discover\n+    the key that invoked rl_complete or rl_menu_complete.\n+\n+c.  The functions rl_block_sigint and rl_release_sigint are now public and\n+    available to calling applications who want to protect critical sections\n+    (like redisplay).\n+\n+d.  The functions rl_save_state and rl_restore_state are now public and\n+    available to calling applications; documented rest of readline's state\n+    flag values.\n+\n+e.  A new user-settable variable, `history-size', allows setting the maximum\n+    number of entries in the history list.\n+\n+f.  There is a new implementation of menu completion, with several improvements\n+    over the old; the most notable improvement is a better `completions\n+    browsing' mode.\n+\n+g.  The menu completion code now uses the rl_menu_completion_entry_function\n+    variable, allowing applications to provide their own menu completion\n+    generators.\n+\n+h.  There is support for replacing a prefix  of a pathname with a `...' when\n+    displaying possible completions.  This is controllable by setting the\n+    `completion-prefix-display-length' variable.  Matches with a common prefix\n+    longer than this value have the common prefix replaced with `...'.\n+\n+i.  There is a new `revert-all-at-newline' variable.  If enabled, readline will\n+    undo all outstanding changes to all history lines when `accept-line' is\n+    executed.\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-5.2 since\n+the release of readline-5.1.\n+\n+New Features in Readline\n+\n+a.  Calling applications can now set the keyboard timeout to 0, allowing\n+    poll-like behavior.\n+\n+b.  The value of SYS_INPUTRC (configurable at compilation time) is now used as\n+    the default last-ditch startup file.\n+\n+c.  The history file reading functions now allow windows-like \\r\\n line\n+    terminators.\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-5.1 since\n+the release of readline-5.0.\n+\n+New Features in Readline\n+\n+a.  The key sequence sent by the keypad `delete' key is now automatically   \n+    bound to delete-char.\n+\n+b.  A negative argument to menu-complete now cycles backward through the\n+    completion list.\n+\n+c.  A new bindable readline variable:  bind-tty-special-chars.  If non-zero,\n+    readline will bind the terminal special characters to their readline\n+    equivalents when it's called (on by default).\n+\n+d.  New bindable command: vi-rubout.  Saves deleted text for possible  \n+    reinsertion, as with any vi-mode `text modification' command; `X' is bound\n+    to this in vi command mode.\n+\n+e.  If the rl_completion_query_items is set to a value < 0, readline never\n+    asks the user whether or not to view the possible completions.\n+\n+f.  New application-callable auxiliary function, rl_variable_value, returns\n+    a string corresponding to a readline variable's value.\n+\n+g.  When parsing inputrc files and variable binding commands, the parser\n+    strips trailing whitespace from values assigned to boolean variables\n+    before checking them.\n+\n+h.  A new external application-controllable variable that allows the LINES\n+    and COLUMNS environment variables to set the window size regardless of\n+    what the kernel returns.\n+\n+\n+-------------------------------------------------------------------------------\n+This is a terse description of the new features added to readline-5.0 since\n+the release of readline-4.3.\n+\n+New Features in Readline\n+\n+a.  History expansion has a new `a' modifier equivalent to the `g' modifier\n+    for compatibility with the BSD csh.\n+\n+b.  History expansion has a new `G' modifier equivalent to the BSD csh `g'\n+    modifier, which performs a substitution once per word.\n+\n+c.  All non-incremental search operations may now undo the operation of\n+    replacing the current line with the history line.\n+\n+d.  The text inserted by an `a' command in vi mode can be reinserted with\n+    `.'.\n+\n+e.  New bindable variable, `show-all-if-unmodified'.  If set, the readline\n+    completer will list possible completions immediately if there is more\n+    than one completion and partial completion cannot be performed.\n+\n+f.  There is a new application-callable `free_history_entry()' function.\n+\n+g.  History list entries now contain timestamp information; the history file\n+    functions know how to read and write timestamp information associated\n+    with each entry.\n+\n+h.  Four new key binding functions have been added:\n+\n+\trl_bind_key_if_unbound()\n+\trl_bind_key_if_unbound_in_map()\n+\trl_bind_keyseq_if_unbound()\n+\trl_bind_keyseq_if_unbound_in_map()\n+\n+i.  New application variable, rl_completion_quote_character, set to any\n+    quote character readline finds before it calls the application completion\n+    function.\n+\n+j.  New application variable, rl_completion_suppress_quote, settable by an   \n+    application completion function.  If set to non-zero, readline does not\n+    attempt to append a closing quote to a completed word.\n+    \n+k.  New application variable, rl_completion_found_quote, set to a non-zero\n+    value if readline determines that the word to be completed is quoted.\n+    Set before readline calls any application completion function.\n+\n+l.  New function hook, rl_completion_word_break_hook, called when readline\n+    needs to break a line into words when completion is attempted.  Allows\n+    the word break characters to vary based on position in the line.\n+\n+m.  New bindable command: unix-filename-rubout.  Does the same thing as\n+    unix-word-rubout, but adds `/' to the set of word delimiters.\n+\n+n.  When listing completions, directories have a `/' appended if the\n+    `mark-directories' option has been enabled."
    },
    {
      "sha": "6a9c2b9097dccdfee28d1309bc4dc4c6a25b6f6b",
      "filename": "readline/README",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/README",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/README",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/README?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n Introduction\n ============\n \n-This is the Gnu Readline library, version 6.2.\n+This is the Gnu Readline library, version 7.0.\n \n The Readline library provides a set of functions for use by applications\n that allow users to edit command lines as they are typed in.  Both\n@@ -159,6 +159,15 @@ Readline library.  The texinfo files include both user and\n programmer's manuals.  HTML versions of the manuals appear in the\n `doc' subdirectory as well. \n \n+Usage\n+=====\n+\n+Our position on the use of Readline through a shared-library linking\n+mechanism is that there is no legal difference between shared-library\n+linking and static linking--either kind of linking combines various\n+modules into a single larger work.  The conditions for using Readline\n+in a larger work are stated in section 3 of the GNU GPL.\n+\n Reporting Bugs\n ==============\n "
    },
    {
      "sha": "d3bac077b106023b5c2ea91af5088a37e8916b00",
      "filename": "readline/aclocal.m4",
      "status": "modified",
      "additions": 34,
      "deletions": 6,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/aclocal.m4?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1692,13 +1692,14 @@ AC_CHECK_HEADERS(wctype.h)\n AC_CHECK_HEADERS(wchar.h)\n AC_CHECK_HEADERS(langinfo.h)\n \n+AC_CHECK_HEADERS(mbstr.h)\n+\n AC_CHECK_FUNC(mbrlen, AC_DEFINE(HAVE_MBRLEN))\n AC_CHECK_FUNC(mbscasecmp, AC_DEFINE(HAVE_MBSCMP))\n AC_CHECK_FUNC(mbscmp, AC_DEFINE(HAVE_MBSCMP))\n AC_CHECK_FUNC(mbsnrtowcs, AC_DEFINE(HAVE_MBSNRTOWCS))\n AC_CHECK_FUNC(mbsrtowcs, AC_DEFINE(HAVE_MBSRTOWCS))\n \n-\n AC_REPLACE_FUNCS(mbschr)\n \n AC_CHECK_FUNC(wcrtomb, AC_DEFINE(HAVE_WCRTOMB))\n@@ -1763,9 +1764,36 @@ if test $bash_cv_type_wint_t = yes; then\n         AC_DEFINE(HAVE_WINT_T, 1, [systems should define this type here])\n fi\n \n+dnl check for broken wcwidth\n+AC_CACHE_CHECK([for wcwidth broken with unicode combining characters],\n+bash_cv_wcwidth_broken,\n+[AC_TRY_RUN([\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <locale.h>\n+#include <wchar.h>\n+\n+main(c, v)\n+int     c;\n+char    **v;\n+{\n+        int     w;\n+\n+        setlocale(LC_ALL, \"en_US.UTF-8\");\n+        w = wcwidth (0x0301);\n+        exit (w == 0);  /* exit 0 if wcwidth broken */\n+}\n+],\n+bash_cv_wcwidth_broken=yes, bash_cv_wcwidth_broken=no, bash_cv_wcwidth_broken=no)])\n+if test \"$bash_cv_wcwidth_broken\" = yes; then\n+        AC_DEFINE(WCWIDTH_BROKEN, 1, [wcwidth is usually not broken])\n+fi\n+\n if test \"$am_cv_func_iconv\" = yes; then\n \tOLDLIBS=\"$LIBS\"\n-\tLIBS=\"$LIBS $LIBICONV\"\n+\tLIBS=\"$LIBS $LIBINTL $LIBICONV\"\n \tAC_CHECK_FUNCS(locale_charset)\n \tLIBS=\"$OLDLIBS\"\n fi\n@@ -1828,7 +1856,7 @@ main()\n ],\n ac_cv_rl_version=`cat conftest.rlv`,\n ac_cv_rl_version='0.0',\n-ac_cv_rl_version='4.2')])\n+ac_cv_rl_version='6.3')])\n \n CFLAGS=\"$_save_CFLAGS\"\n LDFLAGS=\"$_save_LDFLAGS\"\n@@ -3098,7 +3126,7 @@ AC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n           found_so=\n           found_a=\n           if test $use_additional = yes; then\n-            if test -n \"$shlibext\" && test -f \"$additional_libdir/lib$name.$shlibext\"; then\n+            if test \"X$prefer_shared\" = \"Xyes\" && test -n \"$shlibext\" && test -f \"$additional_libdir/lib$name.$shlibext\"; then\n               found_dir=\"$additional_libdir\"\n               found_so=\"$additional_libdir/lib$name.$shlibext\"\n               if test -f \"$additional_libdir/lib$name.la\"; then\n@@ -3120,7 +3148,7 @@ AC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n               case \"$x\" in\n                 -L*)\n                   dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n-                  if test -n \"$shlibext\" && test -f \"$dir/lib$name.$shlibext\"; then\n+                  if test \"X$prefer_shared\" = \"Xyes\" && test -n \"$shlibext\" && test -f \"$dir/lib$name.$shlibext\"; then\n                     found_dir=\"$dir\"\n                     found_so=\"$dir/lib$name.$shlibext\"\n                     if test -f \"$dir/lib$name.la\"; then\n@@ -4123,7 +4151,7 @@ main()\n AC_DEFUN(BASH_STRUCT_WEXITSTATUS_OFFSET,\n [AC_MSG_CHECKING(for offset of exit status in return status from wait)\n AC_CACHE_VAL(bash_cv_wexitstatus_offset,\n-[AC_RUN_IFELSE([\n+[AC_TRY_RUN([\n #include <stdlib.h>\n #include <unistd.h>\n "
    },
    {
      "sha": "f1098c48b17ef910b18edea72c4d36926bb362c4",
      "filename": "readline/bind.c",
      "status": "modified",
      "additions": 344,
      "deletions": 80,
      "changes": 424,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/bind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/bind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/bind.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* bind.c -- key binding and startup file support for the readline library. */\n \n-/* Copyright (C) 1987-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -72,11 +72,20 @@ extern char *strchr (), *strrchr ();\n /* Variables exported by this file. */\n Keymap rl_binding_keymap;\n \n+static int _rl_skip_to_delim PARAMS((char *, int, int));\n+\n+#if defined (USE_VARARGS) && defined (PREFER_STDARG)\n+static void _rl_init_file_error (const char *, ...)  __attribute__((__format__ (printf, 1, 2)));\n+#else\n+static void _rl_init_file_error ();\n+#endif\n+\n static char *_rl_read_file PARAMS((char *, size_t *));\n-static void _rl_init_file_error PARAMS((const char *));\n static int _rl_read_init_file PARAMS((const char *, int));\n static int glean_key_from_name PARAMS((char *));\n+\n static int find_boolean_var PARAMS((const char *));\n+static int find_string_var PARAMS((const char *));\n \n static char *_rl_get_string_variable_value PARAMS((const char *));\n static int substring_member_of_array PARAMS((const char *, const char * const *));\n@@ -113,6 +122,9 @@ rl_bind_key (key, function)\n      int key;\n      rl_command_func_t *function;\n {\n+  char keyseq[3];\n+  int l;\n+\n   if (key < 0)\n     return (key);\n \n@@ -131,8 +143,24 @@ rl_bind_key (key, function)\n       return (key);\n     }\n \n-  _rl_keymap[key].type = ISFUNC;\n-  _rl_keymap[key].function = function;\n+  /* If it's bound to a function or macro, just overwrite.  Otherwise we have\n+     to treat it as a key sequence so rl_generic_bind handles shadow keymaps\n+     for us.  If we are binding '\\' make sure to escape it so it makes it\n+     through the call to rl_translate_keyseq. */\n+  if (_rl_keymap[key].type != ISKMAP)\n+    {\n+      _rl_keymap[key].type = ISFUNC;\n+      _rl_keymap[key].function = function;\n+    }\n+  else\n+    {\n+      l = 0;\n+      if (key == '\\\\')\n+\tkeyseq[l++] = '\\\\';\n+      keyseq[l++] = key;\n+      keyseq[l] = '\\0';\n+      rl_bind_keyseq (keyseq, function);\n+    }\n   rl_binding_keymap = _rl_keymap;\n   return (0);\n }\n@@ -538,7 +566,7 @@ rl_translate_keyseq (seq, array, len)\n \t    case '0': case '1': case '2': case '3':\n \t    case '4': case '5': case '6': case '7':\n \t      i++;\n-\t      for (temp = 2, c -= '0'; ISOCTAL (seq[i]) && temp--; i++)\n+\t      for (temp = 2, c -= '0'; ISOCTAL ((unsigned char)seq[i]) && temp--; i++)\n \t        c = (c * 8) + OCTVALUE (seq[i]);\n \t      i--;\t/* auto-increment in for loop */\n \t      array[l++] = c & largest_char;\n@@ -567,6 +595,40 @@ rl_translate_keyseq (seq, array, len)\n   return (0);\n }\n \n+static int\n+_rl_isescape (c)\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case '\\007':\n+    case '\\b':\n+    case '\\f':\n+    case '\\n':\n+    case '\\r':\n+    case TAB:\n+    case 0x0b:  return (1);\n+    default: return (0);\n+    }\n+}\n+\n+static int\n+_rl_escchar (c)\n+     int c;\n+{\n+  switch (c)\n+    {\n+    case '\\007':  return ('a');\n+    case '\\b':  return ('b');\n+    case '\\f':  return ('f');\n+    case '\\n':  return ('n');\n+    case '\\r':  return ('r');\n+    case TAB:  return ('t');\n+    case 0x0b:  return ('v');\n+    default: return (c);\n+    }\n+}\n+\n char *\n rl_untranslate_keyseq (seq)\n      int seq;\n@@ -618,9 +680,10 @@ rl_untranslate_keyseq (seq)\n   return kseq;\n }\n \n-static char *\n-_rl_untranslate_macro_value (seq)\n+char *\n+_rl_untranslate_macro_value (seq, use_escapes)\n      char *seq;\n+     int use_escapes;\n {\n   char *ret, *r, *s;\n   int c;\n@@ -644,9 +707,14 @@ _rl_untranslate_macro_value (seq)\n       else if (CTRL_CHAR (c))\n \t{\n \t  *r++ = '\\\\';\n-\t  *r++ = 'C';\n-\t  *r++ = '-';\n-\t  c = _rl_to_lower (UNCTRL (c));\n+\t  if (use_escapes && _rl_isescape (c))\n+\t    c = _rl_escchar (c);\n+\t  else\n+\t    {\n+\t      *r++ = 'C';\n+\t      *r++ = '-';\n+\t      c = _rl_to_lower (UNCTRL (c));\n+\t    }\n \t}\n       else if (c == RUBOUT)\n  \t{\n@@ -926,14 +994,35 @@ _rl_read_init_file (filename, include_level)\n }\n \n static void\n-_rl_init_file_error (msg)\n-     const char *msg;\n+#if defined (PREFER_STDARG)\n+_rl_init_file_error (const char *format, ...)\n+#else\n+_rl_init_file_error (va_alist)\n+     va_dcl\n+#endif\n {\n+  va_list args;\n+#if defined (PREFER_VARARGS)\n+  char *format;\n+#endif\n+\n+#if defined (PREFER_STDARG)\n+  va_start (args, format);\n+#else\n+  va_start (args);\n+  format = va_arg (args, char *);\n+#endif\n+\n+  fprintf (stderr, \"readline: \");\n   if (currently_reading_init_file)\n-    _rl_errmsg (\"%s: line %d: %s\\n\", current_readline_init_file,\n-\t\t     current_readline_init_lineno, msg);\n-  else\n-    _rl_errmsg (\"%s\", msg);\n+    fprintf (stderr, \"%s: line %d: \", current_readline_init_file,\n+\t\t     current_readline_init_lineno);\n+\n+  vfprintf (stderr, format, args);\n+  fprintf (stderr, \"\\n\");\n+  fflush (stderr);\n+\n+  va_end (args);\n }\n \n /* **************************************************************** */\n@@ -1153,10 +1242,42 @@ handle_parser_directive (statement)\n       }\n \n   /* display an error message about the unknown parser directive */\n-  _rl_init_file_error (\"unknown parser directive\");\n+  _rl_init_file_error (\"%s: unknown parser directive\", directive);\n   return (1);\n }\n \n+/* Start at STRING[START] and look for DELIM.  Return I where STRING[I] ==\n+   DELIM or STRING[I] == 0.  DELIM is usually a double quote. */\n+static int\n+_rl_skip_to_delim (string, start, delim)\n+     char *string;\n+     int start, delim;\n+{\n+  int i, c, passc;\n+\n+  for (i = start,passc = 0; c = string[i]; i++)\n+    {\n+      if (passc)\n+\t{\n+\t  passc = 0;\n+\t  if (c == 0)\n+\t    break;\n+\t  continue;\n+\t}\n+\n+      if (c == '\\\\')\n+\t{\n+\t  passc = 1;\n+\t  continue;\n+\t}\n+\n+      if (c == delim)\n+\tbreak;\n+    }\n+\n+  return i;\n+}\n+\n /* Read the binding command from STRING and perform it.\n    A key binding command looks like: Keyname: function-name\\0,\n    a variable binding command looks like: set variable value.\n@@ -1167,12 +1288,12 @@ rl_parse_and_bind (string)\n {\n   char *funname, *kname;\n   register int c, i;\n-  int key, equivalency;\n+  int key, equivalency, foundmod, foundsep;\n \n   while (string && whitespace (*string))\n     string++;\n \n-  if (!string || !*string || *string == '#')\n+  if (string == 0 || *string == 0 || *string == '#')\n     return 0;\n \n   /* If this is a parser directive, act on it. */\n@@ -1192,38 +1313,25 @@ rl_parse_and_bind (string)\n      backslash to quote characters in the key expression. */\n   if (*string == '\"')\n     {\n-      int passc = 0;\n-\n-      for (i = 1; c = string[i]; i++)\n-\t{\n-\t  if (passc)\n-\t    {\n-\t      passc = 0;\n-\t      continue;\n-\t    }\n-\n-\t  if (c == '\\\\')\n-\t    {\n-\t      passc++;\n-\t      continue;\n-\t    }\n+      i = _rl_skip_to_delim (string, 1, '\"');\n \n-\t  if (c == '\"')\n-\t    break;\n-\t}\n       /* If we didn't find a closing quote, abort the line. */\n       if (string[i] == '\\0')\n         {\n-          _rl_init_file_error (\"no closing `\\\"' in key binding\");\n+          _rl_init_file_error (\"%s: no closing `\\\"' in key binding\", string);\n           return 1;\n         }\n+      else\n+        i++;\t/* skip past closing double quote */\n     }\n \n   /* Advance to the colon (:) or whitespace which separates the two objects. */\n   for (; (c = string[i]) && c != ':' && c != ' ' && c != '\\t'; i++ );\n \n   equivalency = (c == ':' && string[i + 1] == '=');\n \n+  foundsep = c != 0;\n+\n   /* Mark the end of the command (or keyname). */\n   if (string[i])\n     string[i++] = '\\0';\n@@ -1236,32 +1344,45 @@ rl_parse_and_bind (string)\n   if (_rl_stricmp (string, \"set\") == 0)\n     {\n       char *var, *value, *e;\n+      int s;\n \n       var = string + i;\n       /* Make VAR point to start of variable name. */\n       while (*var && whitespace (*var)) var++;\n \n       /* Make VALUE point to start of value string. */\n       value = var;\n-      while (*value && !whitespace (*value)) value++;\n+      while (*value && whitespace (*value) == 0) value++;\n       if (*value)\n \t*value++ = '\\0';\n       while (*value && whitespace (*value)) value++;\n \n-      /* Strip trailing whitespace from values to boolean variables.  Temp\n-\t fix until I get a real quoted-string parser here. */\n-      i = find_boolean_var (var);\n-      if (i >= 0)\n+      /* Strip trailing whitespace from values of boolean variables. */\n+      if (find_boolean_var (var) >= 0)\n \t{\n \t  /* remove trailing whitespace */\n+remove_trailing:\n \t  e = value + strlen (value) - 1;\n \t  while (e >= value && whitespace (*e))\n \t    e--;\n \t  e++;\t\t/* skip back to whitespace or EOS */\n+\t  \n \t  if (*e && e >= value)\n \t    *e = '\\0';\n \t}\n-\n+      else if ((i = find_string_var (var)) >= 0)\n+\t{\n+\t  /* Allow quoted strings in variable values */\n+\t  if (*value == '\"')\n+\t    {\n+\t      i = _rl_skip_to_delim (value, 1, *value);\n+\t      value[i] = '\\0';\n+\t      value++;\t/* skip past the quote */\n+\t    }\n+\t  else\n+\t    goto remove_trailing;\n+\t}\n+\t\n       rl_variable_bind (var, value);\n       return 0;\n     }\n@@ -1282,32 +1403,13 @@ rl_parse_and_bind (string)\n      the quoted string delimiter, like the shell. */\n   if (*funname == '\\'' || *funname == '\"')\n     {\n-      int delimiter, passc;\n-\n-      delimiter = string[i++];\n-      for (passc = 0; c = string[i]; i++)\n-\t{\n-\t  if (passc)\n-\t    {\n-\t      passc = 0;\n-\t      continue;\n-\t    }\n-\n-\t  if (c == '\\\\')\n-\t    {\n-\t      passc = 1;\n-\t      continue;\n-\t    }\n-\n-\t  if (c == delimiter)\n-\t    break;\n-\t}\n-      if (c)\n+      i = _rl_skip_to_delim (string, i+1, *funname);\n+      if (string[i])\n \ti++;\n     }\n \n   /* Advance to the end of the string.  */\n-  for (; string[i] && !whitespace (string[i]); i++);\n+  for (; string[i] && whitespace (string[i]) == 0; i++);\n \n   /* No extra whitespace at the end of the string. */\n   string[i] = '\\0';\n@@ -1319,6 +1421,12 @@ rl_parse_and_bind (string)\n       return 0;\n     }\n \n+  if (foundsep == 0)\n+    {\n+      _rl_init_file_error (\"%s: no key sequence terminator\", string);\n+      return 1;\n+    }\n+\n   /* If this is a new-style key-binding, then do the binding with\n      rl_bind_keyseq ().  Otherwise, let the older code deal with it. */\n   if (*string == '\"')\n@@ -1367,19 +1475,32 @@ rl_parse_and_bind (string)\n \n   /* Get the actual character we want to deal with. */\n   kname = strrchr (string, '-');\n-  if (!kname)\n+  if (kname == 0)\n     kname = string;\n   else\n     kname++;\n \n   key = glean_key_from_name (kname);\n \n   /* Add in control and meta bits. */\n+  foundmod = 0;\n   if (substring_member_of_array (string, _rl_possible_control_prefixes))\n-    key = CTRL (_rl_to_upper (key));\n+    {\n+      key = CTRL (_rl_to_upper (key));\n+      foundmod = 1;\n+    }\n \n   if (substring_member_of_array (string, _rl_possible_meta_prefixes))\n-    key = META (key);\n+    {\n+      key = META (key);\n+      foundmod = 1;\n+    }\n+\n+  if (foundmod == 0 && kname != string)\n+    {\n+      _rl_init_file_error (\"%s: unknown key modifier\", string);\n+      return 1;\n+    }\n \n   /* Temporary.  Handle old-style keyname with macro-binding. */\n   if (*funname == '\\'' || *funname == '\"')\n@@ -1406,6 +1527,7 @@ rl_parse_and_bind (string)\n #endif /* PREFIX_META_HACK */\n   else\n     rl_bind_key (key, rl_named_function (funname));\n+\n   return 0;\n }\n \n@@ -1423,11 +1545,16 @@ static const struct {\n   { \"bind-tty-special-chars\",\t&_rl_bind_stty_chars,\t\t0 },\n   { \"blink-matching-paren\",\t&rl_blink_matching_paren,\tV_SPECIAL },\n   { \"byte-oriented\",\t\t&rl_byte_oriented,\t\t0 },\n+#if defined (COLOR_SUPPORT)\n+  { \"colored-completion-prefix\",&_rl_colored_completion_prefix,\t0 },\n+  { \"colored-stats\",\t\t&_rl_colored_stats,\t\t0 },\n+#endif\n   { \"completion-ignore-case\",\t&_rl_completion_case_fold,\t0 },\n   { \"completion-map-case\",\t&_rl_completion_case_map,\t0 },\n   { \"convert-meta\",\t\t&_rl_convert_meta_chars_to_ascii, 0 },\n   { \"disable-completion\",\t&rl_inhibit_completion,\t\t0 },\n   { \"echo-control-characters\",\t&_rl_echo_control_chars,\t0 },\n+  { \"enable-bracketed-paste\",\t&_rl_enable_bracketed_paste,\t0 },\n   { \"enable-keypad\",\t\t&_rl_enable_keypad,\t\t0 },\n   { \"enable-meta-key\",\t\t&_rl_enable_meta,\t\t0 },\n   { \"expand-tilde\",\t\t&rl_complete_with_tilde_expansion, 0 },\n@@ -1447,6 +1574,7 @@ static const struct {\n   { \"revert-all-at-newline\",\t&_rl_revert_all_at_newline,\t0 },\n   { \"show-all-if-ambiguous\",\t&_rl_complete_show_all,\t\t0 },\n   { \"show-all-if-unmodified\",\t&_rl_complete_show_unmodified,\t0 },\n+  { \"show-mode-in-prompt\",\t&_rl_show_mode_in_prompt,\t0 },\n   { \"skip-completed-text\",\t&_rl_skip_completed_text,\t0 },\n #if defined (VISIBLE_STATS)\n   { \"visible-stats\",\t\t&rl_visible_stats,\t\t0 },\n@@ -1486,6 +1614,8 @@ hack_special_boolean_var (i)\n       else\n \t_rl_bell_preference = AUDIBLE_BELL;\n     }\n+  else if (_rl_stricmp (name, \"show-mode-in-prompt\") == 0)\n+    _rl_reset_prompt ();\n }\n \n typedef int _rl_sv_func_t PARAMS((const char *));\n@@ -1508,9 +1638,13 @@ static int sv_dispprefix PARAMS((const char *));\n static int sv_compquery PARAMS((const char *));\n static int sv_compwidth PARAMS((const char *));\n static int sv_editmode PARAMS((const char *));\n+static int sv_emacs_modestr PARAMS((const char *));\n static int sv_histsize PARAMS((const char *));\n static int sv_isrchterm PARAMS((const char *));\n static int sv_keymap PARAMS((const char *));\n+static int sv_seqtimeout PARAMS((const char *));\n+static int sv_viins_modestr PARAMS((const char *));\n+static int sv_vicmd_modestr PARAMS((const char *));\n \n static const struct {\n   const char * const name;\n@@ -1523,9 +1657,13 @@ static const struct {\n   { \"completion-prefix-display-length\", V_INT,\tsv_dispprefix },\n   { \"completion-query-items\", V_INT,\tsv_compquery },\n   { \"editing-mode\",\tV_STRING,\tsv_editmode },\n+  { \"emacs-mode-string\", V_STRING,\tsv_emacs_modestr },  \n   { \"history-size\",\tV_INT,\t\tsv_histsize },\n   { \"isearch-terminators\", V_STRING,\tsv_isrchterm },\n   { \"keymap\",\t\tV_STRING,\tsv_keymap },\n+  { \"keyseq-timeout\",\tV_INT,\t\tsv_seqtimeout },\n+  { \"vi-cmd-mode-string\", V_STRING,\tsv_vicmd_modestr }, \n+  { \"vi-ins-mode-string\", V_STRING,\tsv_viins_modestr }, \n   { (char *)NULL,\t0, (_rl_sv_func_t *)0 }\n };\n \n@@ -1542,7 +1680,7 @@ find_string_var (name)\n }\n \n /* A boolean value that can appear in a `set variable' command is true if\n-   the value is null or empty, `on' (case-insenstive), or \"1\".  Any other\n+   the value is null or empty, `on' (case-insensitive), or \"1\".  Any other\n    values result in 0 (false). */\n static int\n bool_to_int (value)\n@@ -1591,10 +1729,14 @@ rl_variable_bind (name, value)\n \n   i = find_string_var (name);\n \n-  /* For the time being, unknown variable names or string names without a\n-     handler function are simply ignored. */\n+  /* For the time being, string names without a handler function are simply\n+     ignored. */\n   if (i < 0 || string_varlist[i].set_func == 0)\n-    return 0;\n+    {\n+      if (i < 0)\n+\t_rl_init_file_error (\"%s: unknown variable name\", name);\n+      return 0;\n+    }\n \n   v = (*string_varlist[i].set_func) (value);\n   return v;\n@@ -1683,13 +1825,17 @@ static int\n sv_histsize (value)\n      const char *value;\n {\n-  int nval = 500;\n+  int nval;\n \n+  nval = 500;\n   if (value && *value)\n     {\n       nval = atoi (value);\n       if (nval < 0)\n-\treturn 1;\n+\t{\n+\t  unstifle_history ();\n+\t  return 0;\n+\t}\n     }\n   stifle_history (nval);\n   return 0;\n@@ -1710,6 +1856,23 @@ sv_keymap (value)\n   return 1;\n }\n \n+static int\n+sv_seqtimeout (value)\n+     const char *value;\n+{\n+  int nval;\n+\n+  nval = 0;\n+  if (value && *value)\n+    {\n+      nval = atoi (value);\n+      if (nval < 0)\n+\tnval = 0;\n+    }\n+  _rl_keyseq_timeout = nval;\n+  return 0;\n+}\n+\n static int\n sv_bell_style (value)\n      const char *value;\n@@ -1748,7 +1911,7 @@ sv_isrchterm (value)\n     }\n   else\n     {\n-      for (beg = end = 0; whitespace (v[end]) == 0; end++)\n+      for (beg = end = 0; v[end] && whitespace (v[end]) == 0; end++)\n \t;\n     }\n \n@@ -1762,7 +1925,96 @@ sv_isrchterm (value)\n   xfree (v);\n   return 0;\n }\n-      \n+\n+extern char *_rl_emacs_mode_str;\n+\n+static int\n+sv_emacs_modestr (value)\n+     const char *value;\n+{\n+  if (value && *value)\n+    {\n+      FREE (_rl_emacs_mode_str);\n+      _rl_emacs_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n+      rl_translate_keyseq (value, _rl_emacs_mode_str, &_rl_emacs_modestr_len);\n+      _rl_emacs_mode_str[_rl_emacs_modestr_len] = '\\0';\n+      return 0;\n+    }\n+  else if (value)\n+    {\n+      FREE (_rl_emacs_mode_str);\n+      _rl_emacs_mode_str = (char *)xmalloc (1);\n+      _rl_emacs_mode_str[_rl_emacs_modestr_len = 0] = '\\0';\n+      return 0;\n+    }\n+  else if (value == 0)\n+    {\n+      FREE (_rl_emacs_mode_str);\n+      _rl_emacs_mode_str = 0;\t/* prompt_modestr does the right thing */\n+      _rl_emacs_modestr_len = 0;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+static int\n+sv_viins_modestr (value)\n+     const char *value;\n+{\n+  if (value && *value)\n+    {\n+      FREE (_rl_vi_ins_mode_str);\n+      _rl_vi_ins_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n+      rl_translate_keyseq (value, _rl_vi_ins_mode_str, &_rl_vi_ins_modestr_len);\n+      _rl_vi_ins_mode_str[_rl_vi_ins_modestr_len] = '\\0';\n+      return 0;\n+    }\n+  else if (value)\n+    {\n+      FREE (_rl_vi_ins_mode_str);\n+      _rl_vi_ins_mode_str = (char *)xmalloc (1);\n+      _rl_vi_ins_mode_str[_rl_vi_ins_modestr_len = 0] = '\\0';\n+      return 0;\n+    }\n+  else if (value == 0)\n+    {\n+      FREE (_rl_vi_ins_mode_str);\n+      _rl_vi_ins_mode_str = 0;\t/* prompt_modestr does the right thing */\n+      _rl_vi_ins_modestr_len = 0;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+static int\n+sv_vicmd_modestr (value)\n+     const char *value;\n+{\n+  if (value && *value)\n+    {\n+      FREE (_rl_vi_cmd_mode_str);\n+      _rl_vi_cmd_mode_str = (char *)xmalloc (2 * strlen (value) + 1);\n+      rl_translate_keyseq (value, _rl_vi_cmd_mode_str, &_rl_vi_cmd_modestr_len);\n+      _rl_vi_cmd_mode_str[_rl_vi_cmd_modestr_len] = '\\0';\n+      return 0;\n+    }\n+  else if (value)\n+    {\n+      FREE (_rl_vi_cmd_mode_str);\n+      _rl_vi_cmd_mode_str = (char *)xmalloc (1);\n+      _rl_vi_cmd_mode_str[_rl_vi_cmd_modestr_len = 0] = '\\0';\n+      return 0;\n+    }\n+  else if (value == 0)\n+    {\n+      FREE (_rl_vi_cmd_mode_str);\n+      _rl_vi_cmd_mode_str = 0;\t/* prompt_modestr does the right thing */\n+      _rl_vi_cmd_modestr_len = 0;\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n /* Return the character which matches NAME.\n    For example, `Space' returns ' '. */\n \n@@ -2167,7 +2419,8 @@ rl_function_dumper (print_readably)\n \t    }\n \t}\n     }\n-  free (names);\n+\n+  xfree (names);\n }\n \n /* Print all of the current functions and their bindings to\n@@ -2200,7 +2453,7 @@ _rl_macro_dumper_internal (print_readably, map, prefix)\n \t{\n \tcase ISMACR:\n \t  keyname = _rl_get_keyname (key);\n-\t  out = _rl_untranslate_macro_value ((char *)map[key].function);\n+\t  out = _rl_untranslate_macro_value ((char *)map[key].function, 0);\n \n \t  if (print_readably)\n \t    fprintf (rl_outstream, \"\\\"%s%s\\\": \\\"%s\\\"\\n\", prefix ? prefix : \"\",\n@@ -2312,7 +2565,7 @@ _rl_get_string_variable_value (name)\n     {\n       if (_rl_isearch_terminators == 0)\n \treturn 0;\n-      ret = _rl_untranslate_macro_value (_rl_isearch_terminators);\n+      ret = _rl_untranslate_macro_value (_rl_isearch_terminators, 0);\n       if (ret)\n \t{\n \t  strncpy (numbuf, ret, sizeof (numbuf) - 1);\n@@ -2330,6 +2583,17 @@ _rl_get_string_variable_value (name)\n \tret = rl_get_keymap_name_from_edit_mode ();\n       return (ret ? ret : \"none\");\n     }\n+  else if (_rl_stricmp (name, \"keyseq-timeout\") == 0)\n+    {\n+      sprintf (numbuf, \"%d\", _rl_keyseq_timeout);    \n+      return (numbuf);\n+    }\n+  else if (_rl_stricmp (name, \"emacs-mode-string\") == 0)\n+    return (_rl_emacs_mode_str ? _rl_emacs_mode_str : RL_EMACS_MODESTR_DEFAULT);\n+  else if (_rl_stricmp (name, \"vi-cmd-mode-string\") == 0)\n+    return (_rl_vi_cmd_mode_str ? _rl_vi_cmd_mode_str : RL_VI_CMD_MODESTR_DEFAULT);\n+  else if (_rl_stricmp (name, \"vi-ins-mode-string\") == 0)\n+    return (_rl_vi_ins_mode_str ? _rl_vi_ins_mode_str : RL_VI_INS_MODESTR_DEFAULT);\n   else\n     return (0);\n }"
    },
    {
      "sha": "cc3ce11f19174dd79ea6dc1ad864fdd168665f49",
      "filename": "readline/callback.c",
      "status": "modified",
      "additions": 102,
      "deletions": 11,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/callback.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/callback.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/callback.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* callback.c -- functions to use readline as an X `callback' mechanism. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -50,6 +50,14 @@\n _rl_callback_func_t *_rl_callback_func = 0;\n _rl_callback_generic_arg *_rl_callback_data = 0;\n \n+/* Applications can set this to non-zero to have readline's signal handlers\n+   installed during the entire duration of reading a complete line, as in\n+   readline-6.2.  This should be used with care, because it can result in\n+   readline receiving signals and not handling them until it's called again\n+   via rl_callback_read_char, thereby stealing them from the application.\n+   By default, signal handlers are only active while readline is active. */   \n+int rl_persistent_signal_handlers = 0;\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tCallback Readline Functions\t\t */\n@@ -62,8 +70,10 @@ _rl_callback_generic_arg *_rl_callback_data = 0;\n    whenever a complete line of input is ready.  The user must then\n    call rl_callback_read_char() every time some input is available, and \n    rl_callback_read_char() will call the user's function with the complete\n-   text read in at each end of line.  The terminal is kept prepped and\n-   signals handled all the time, except during calls to the user's function. */\n+   text read in at each end of line.  The terminal is kept prepped\n+   all the time, except during calls to the user's function.  Signal\n+   handlers are only installed when the application calls back into\n+   readline, so readline doesn't `steal' signals from the application.  */\n \n rl_vcpfunc_t *rl_linefunc;\t\t/* user callback function */\n static int in_handler;\t\t/* terminal_prepped and signals set? */\n@@ -82,7 +92,8 @@ _rl_callback_newline ()\n \t(*rl_prep_term_function) (_rl_meta_flag);\n \n #if defined (HANDLE_SIGNALS)\n-      rl_set_signals ();\n+      if (rl_persistent_signal_handlers)\n+\trl_set_signals ();\n #endif\n     }\n \n@@ -102,6 +113,17 @@ rl_callback_handler_install (prompt, linefunc)\n   _rl_callback_newline ();\n }\n \n+#if defined (HANDLE_SIGNALS)\n+#define CALLBACK_READ_RETURN() \\\n+  do { \\\n+    if (rl_persistent_signal_handlers == 0) \\\n+      rl_clear_signals (); \\\n+    return; \\\n+  } while (0)\n+#else\n+#define CALLBACK_READ_RETURN() return\n+#endif\n+\n /* Read one character, and dispatch to the handler if it ends the line. */\n void\n rl_callback_read_char ()\n@@ -117,15 +139,25 @@ rl_callback_read_char ()\n     }\n \n   memcpy ((void *)olevel, (void *)_rl_top_level, sizeof (procenv_t));\n+#if defined (HAVE_POSIX_SIGSETJMP)\n+  jcode = sigsetjmp (_rl_top_level, 0);\n+#else\n   jcode = setjmp (_rl_top_level);\n+#endif\n   if (jcode)\n     {\n       (*rl_redisplay_function) ();\n       _rl_want_redisplay = 0;\n       memcpy ((void *)_rl_top_level, (void *)olevel, sizeof (procenv_t));\n-      return;\n+      CALLBACK_READ_RETURN ();\n     }\n \n+#if defined (HANDLE_SIGNALS)\n+  /* Install signal handlers only when readline has control. */\n+  if (rl_persistent_signal_handlers == 0)\n+    rl_set_signals ();\n+#endif\n+\n   do\n     {\n       RL_CHECK_SIGNALS ();\n@@ -135,14 +167,45 @@ rl_callback_read_char ()\n \t  if (eof == 0 && (RL_ISSTATE (RL_STATE_ISEARCH) == 0) && RL_ISSTATE (RL_STATE_INPUTPENDING))\n \t    rl_callback_read_char ();\n \n-\t  return;\n+\t  CALLBACK_READ_RETURN ();\n \t}\n       else if  (RL_ISSTATE (RL_STATE_NSEARCH))\n \t{\n \t  eof = _rl_nsearch_callback (_rl_nscxt);\n-\t  return;\n+\n+\t  CALLBACK_READ_RETURN ();\n \t}\n #if defined (VI_MODE)\n+      /* States that can occur while in state VIMOTION have to be checked\n+\t before RL_STATE_VIMOTION */\n+      else if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n+\t{\n+\t  int k;\n+\n+\t  k = _rl_callback_data->i2;\n+\n+\t  eof = (*_rl_callback_func) (_rl_callback_data);\n+\t  /* If the function `deregisters' itself, make sure the data is\n+\t     cleaned up. */\n+\t  if (_rl_callback_func == 0)\t/* XXX - just sanity check */\n+\t    {\n+\t      if (_rl_callback_data)\n+\t\t{\n+\t\t  _rl_callback_data_dispose (_rl_callback_data);\n+\t\t  _rl_callback_data = 0;\n+\t\t}\n+\t    }\n+\n+\t  /* Messy case where vi motion command can be char search */\n+\t  if (RL_ISSTATE (RL_STATE_VIMOTION))\n+\t    {\n+\t      _rl_vi_domove_motion_cleanup (k, _rl_vimvcxt);\n+\t      _rl_internal_char_cleanup ();\n+\t      CALLBACK_READ_RETURN ();\t      \n+\t    }\n+\n+\t  _rl_internal_char_cleanup ();\n+\t}\n       else if (RL_ISSTATE (RL_STATE_VIMOTION))\n \t{\n \t  eof = _rl_vi_domove_callback (_rl_vimvcxt);\n@@ -151,7 +214,7 @@ rl_callback_read_char ()\n \t  if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n \t    _rl_internal_char_cleanup ();\n \n-\t  return;\n+\t  CALLBACK_READ_RETURN ();\n \t}\n #endif\n       else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n@@ -163,7 +226,7 @@ rl_callback_read_char ()\n \t  else if (RL_ISSTATE (RL_STATE_NUMERICARG) == 0)\n \t    _rl_internal_char_cleanup ();\n \n-\t  return;\n+\t  CALLBACK_READ_RETURN ();\n \t}\n       else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n \t{\n@@ -180,7 +243,7 @@ rl_callback_read_char ()\n \t{\n \t  /* This allows functions that simply need to read an additional\n \t     character (like quoted-insert) to register a function to be\n-\t     called when input is available.  _rl_callback_data is simply a\n+\t     called when input is available.  _rl_callback_data is a\n \t     pointer to a struct that has the argument count originally\n \t     passed to the registering function and space for any additional\n \t     parameters.  */\n@@ -230,6 +293,8 @@ rl_callback_read_char ()\n \t}\n     }\n   while (rl_pending_input || _rl_pushed_input_available () || RL_ISSTATE (RL_STATE_MACROINPUT));\n+\n+  CALLBACK_READ_RETURN ();\n }\n \n /* Remove the handler, and make sure the terminal is in its normal state. */\n@@ -264,10 +329,36 @@ _rl_callback_data_alloc (count)\n   return arg;\n }\n \n-void _rl_callback_data_dispose (arg)\n+void\n+_rl_callback_data_dispose (arg)\n      _rl_callback_generic_arg *arg;\n {\n   xfree (arg);\n }\n \n+/* Make sure that this agrees with cases in rl_callback_read_char */\n+void\n+rl_callback_sigcleanup ()\n+{\n+  if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n+    return;\n+\n+  if (RL_ISSTATE (RL_STATE_ISEARCH))\n+    _rl_isearch_cleanup (_rl_iscxt, 0);\n+  else if (RL_ISSTATE (RL_STATE_NSEARCH))\n+    _rl_nsearch_cleanup (_rl_nscxt, 0);\n+  else if (RL_ISSTATE (RL_STATE_VIMOTION))\n+    RL_UNSETSTATE (RL_STATE_VIMOTION);\n+  else if (RL_ISSTATE (RL_STATE_NUMERICARG))\n+    {\n+      _rl_argcxt = 0;\n+      RL_UNSETSTATE (RL_STATE_NUMERICARG);\n+    }\n+  else if (RL_ISSTATE (RL_STATE_MULTIKEY))\n+    RL_UNSETSTATE (RL_STATE_MULTIKEY);\n+  if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n+    RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n+\n+  _rl_callback_func = 0;\n+}\n #endif"
    },
    {
      "sha": "3cf1326aab7515d572d405ad3330a4757735331c",
      "filename": "readline/chardefs.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/chardefs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/chardefs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/chardefs.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* chardefs.h -- Character definitions for readline. */\n \n-/* Copyright (C) 1994-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -72,8 +72,8 @@\n #  define IN_CTYPE_DOMAIN(c) isascii(c)\n #endif\n \n-#if !defined (isxdigit) && !defined (HAVE_ISXDIGIT)\n-#  define isxdigit(c)   (isdigit((c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))\n+#if !defined (isxdigit) && !defined (HAVE_ISXDIGIT) && !defined (__cplusplus)\n+#  define isxdigit(c)   (isdigit((unsigned char)(c)) || ((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))\n #endif\n \n #if defined (CTYPE_NON_ASCII)\n@@ -87,13 +87,13 @@\n \n /* Beware:  these only work with single-byte ASCII characters. */\n \n-#define ISALNUM(c)\t(IN_CTYPE_DOMAIN (c) && isalnum (c))\n-#define ISALPHA(c)\t(IN_CTYPE_DOMAIN (c) && isalpha (c))\n-#define ISDIGIT(c)\t(IN_CTYPE_DOMAIN (c) && isdigit (c))\n-#define ISLOWER(c)\t(IN_CTYPE_DOMAIN (c) && islower (c))\n-#define ISPRINT(c)\t(IN_CTYPE_DOMAIN (c) && isprint (c))\n-#define ISUPPER(c)\t(IN_CTYPE_DOMAIN (c) && isupper (c))\n-#define ISXDIGIT(c)\t(IN_CTYPE_DOMAIN (c) && isxdigit (c))\n+#define ISALNUM(c)\t(IN_CTYPE_DOMAIN (c) && isalnum ((unsigned char)c))\n+#define ISALPHA(c)\t(IN_CTYPE_DOMAIN (c) && isalpha ((unsigned char)c))\n+#define ISDIGIT(c)\t(IN_CTYPE_DOMAIN (c) && isdigit ((unsigned char)c))\n+#define ISLOWER(c)\t(IN_CTYPE_DOMAIN (c) && islower ((unsigned char)c))\n+#define ISPRINT(c)\t(IN_CTYPE_DOMAIN (c) && isprint ((unsigned char)c))\n+#define ISUPPER(c)\t(IN_CTYPE_DOMAIN (c) && isupper ((unsigned char)c))\n+#define ISXDIGIT(c)\t(IN_CTYPE_DOMAIN (c) && isxdigit ((unsigned char)c))\n \n #define _rl_lowercase_p(c)\t(NON_NEGATIVE(c) && ISLOWER(c))\n #define _rl_uppercase_p(c)\t(NON_NEGATIVE(c) && ISUPPER(c))"
    },
    {
      "sha": "7859f5d2bc7f4b21c62596d355e8d6692ab7ea6f",
      "filename": "readline/colors.c",
      "status": "added",
      "additions": 279,
      "deletions": 0,
      "changes": 279,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/colors.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/colors.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/colors.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,279 @@\n+/* `dir', `vdir' and `ls' directory listing programs for GNU.\n+\n+   Modified by Chet Ramey for Readline.\n+\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2015\n+   Free Software Foundation, Inc.\n+\n+   This program is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Written by Richard Stallman and David MacKenzie.  */\n+\n+/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis\n+   Flaherty <dennisf@denix.elk.miles.com> based on original patches by\n+   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */\n+\n+#define READLINE_LIBRARY\n+\n+#if defined (HAVE_CONFIG_H)\n+#  include <config.h>\n+#endif\n+\n+#include \"rlconf.h\"\n+\n+#include <stdio.h>\n+\n+#include \"posixstat.h\" // stat related macros (S_ISREG, ...)\n+#include <fcntl.h> // S_ISUID\n+\n+// strlen()\n+#if defined (HAVE_STRING_H)\n+#  include <string.h>\n+#else /* !HAVE_STRING_H */\n+#  include <strings.h>\n+#endif /* !HAVE_STRING_H */\n+\n+// abort()\n+#if defined (HAVE_STDLIB_H)\n+#  include <stdlib.h>\n+#else\n+#  include \"ansi_stdlib.h\"\n+#endif /* HAVE_STDLIB_H */\n+\n+#include \"readline.h\"\n+#include \"rldefs.h\"\n+\n+#ifdef COLOR_SUPPORT\n+\n+#include \"xmalloc.h\"\n+#include \"colors.h\"\n+\n+static bool is_colored (enum indicator_no type);\n+static void restore_default_color (void);\n+\n+COLOR_EXT_TYPE *_rl_color_ext_list = 0;\n+\n+/* Output a color indicator (which may contain nulls).  */\n+void\n+_rl_put_indicator (const struct bin_str *ind) {\n+  fwrite (ind->string, ind->len, 1, rl_outstream);\n+}\n+\n+static bool\n+is_colored (enum indicator_no colored_filetype)\n+{\n+  size_t len = _rl_color_indicator[colored_filetype].len;\n+  char const *s = _rl_color_indicator[colored_filetype].string;\n+  return ! (len == 0\n+            || (len == 1 && strncmp (s, \"0\", 1) == 0)\n+            || (len == 2 && strncmp (s, \"00\", 2) == 0));\n+}\n+\n+static void\n+restore_default_color (void)\n+{\n+  _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n+  _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n+}\n+\n+void\n+_rl_set_normal_color (void)\n+{\n+  if (is_colored (C_NORM))\n+    {\n+      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n+      _rl_put_indicator (&_rl_color_indicator[C_NORM]);\n+      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n+    }\n+}\n+\n+bool\n+_rl_print_prefix_color (void)\n+{\n+  struct bin_str *s;\n+\n+  /* What do we want to use for the prefix? Let's try cyan first, see colors.h */\n+  s = &_rl_color_indicator[C_PREFIX];\n+  if (s->string != NULL)\n+    {\n+      if (is_colored (C_NORM))\n+\trestore_default_color ();\n+      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n+      _rl_put_indicator (s);\n+      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n+      return 0;\n+    }\n+  else\n+    return 1;\n+}\n+  \n+/* Returns whether any color sequence was printed. */\n+bool\n+_rl_print_color_indicator (const char *f)\n+{\n+  enum indicator_no colored_filetype;\n+  COLOR_EXT_TYPE *ext;\t/* Color extension */\n+  size_t len;\t\t/* Length of name */\n+\n+  const char* name;\n+  char *filename;\n+  struct stat astat, linkstat;\n+  mode_t mode;\n+  int linkok;\t/* 1 == ok, 0 == dangling symlink, -1 == missing */\n+  int stat_ok;\n+\n+  name = f;\n+\n+  /* This should already have undergone tilde expansion */\n+  filename = 0;\n+  if (rl_filename_stat_hook)\n+    {\n+      filename = savestring (f);\n+      (*rl_filename_stat_hook) (&filename);\n+      name = filename;\n+    }\n+\n+#if defined (HAVE_LSTAT)\n+  stat_ok = lstat(name, &astat);\n+#else\n+  stat_ok = stat(name, &astat);\n+#endif\n+  if (stat_ok == 0)\n+    {\n+      mode = astat.st_mode;\n+#if defined (HAVE_LSTAT)\n+      if (S_ISLNK (mode))\n+\t{\n+\t  linkok = stat (name, &linkstat) == 0;\n+\t  if (linkok && strncmp (_rl_color_indicator[C_LINK].string, \"target\", 6) == 0)\n+\t    mode = linkstat.st_mode;\n+\t}\n+      else\n+#endif\n+\tlinkok = 1;\n+    }\n+  else\n+    linkok = -1;\n+\n+  /* Is this a nonexistent file?  If so, linkok == -1.  */\n+\n+  if (linkok == -1 && _rl_color_indicator[C_MISSING].string != NULL)\n+    colored_filetype = C_MISSING;\n+  else if (linkok == 0 && S_ISLNK(mode) && _rl_color_indicator[C_ORPHAN].string != NULL)\n+    colored_filetype = C_ORPHAN;\t/* dangling symlink */\n+  else if(stat_ok != 0)\n+    {\n+      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;\n+      colored_filetype = filetype_indicator[normal]; //f->filetype];\n+    }\n+  else\n+    {\n+      if (S_ISREG (mode))\n+        {\n+          colored_filetype = C_FILE;\n+\n+          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))\n+            colored_filetype = C_SETUID;\n+          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))\n+            colored_filetype = C_SETGID;\n+          else if (is_colored (C_CAP) && 0) //f->has_capability)\n+            colored_filetype = C_CAP;\n+          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))\n+            colored_filetype = C_EXEC;\n+          else if ((1 < astat.st_nlink) && is_colored (C_MULTIHARDLINK))\n+            colored_filetype = C_MULTIHARDLINK;\n+        }\n+      else if (S_ISDIR (mode))\n+        {\n+          colored_filetype = C_DIR;\n+\n+#if defined (S_ISVTX)\n+          if ((mode & S_ISVTX) && (mode & S_IWOTH)\n+              && is_colored (C_STICKY_OTHER_WRITABLE))\n+            colored_filetype = C_STICKY_OTHER_WRITABLE;\n+          else\n+#endif\n+          if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))\n+            colored_filetype = C_OTHER_WRITABLE;\n+#if defined (S_ISVTX)\n+          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))\n+            colored_filetype = C_STICKY;\n+#endif\n+        }\n+      else if (S_ISLNK (mode))\n+        colored_filetype = C_LINK;\n+      else if (S_ISFIFO (mode))\n+        colored_filetype = C_FIFO;\n+      else if (S_ISSOCK (mode))\n+        colored_filetype = C_SOCK;\n+      else if (S_ISBLK (mode))\n+        colored_filetype = C_BLK;\n+      else if (S_ISCHR (mode))\n+        colored_filetype = C_CHR;\n+      else\n+        {\n+          /* Classify a file of some other type as C_ORPHAN.  */\n+          colored_filetype = C_ORPHAN;\n+        }\n+    }\n+\n+  /* Check the file's suffix only if still classified as C_FILE.  */\n+  ext = NULL;\n+  if (colored_filetype == C_FILE)\n+    {\n+      /* Test if NAME has a recognized suffix.  */\n+      len = strlen (name);\n+      name += len;\t\t/* Pointer to final \\0.  */\n+      for (ext = _rl_color_ext_list; ext != NULL; ext = ext->next)\n+        {\n+          if (ext->ext.len <= len\n+              && strncmp (name - ext->ext.len, ext->ext.string,\n+                          ext->ext.len) == 0)\n+            break;\n+        }\n+    }\n+\n+  free (filename);\t/* NULL or savestring return value */\n+\n+  {\n+    const struct bin_str *const s\n+      = ext ? &(ext->seq) : &_rl_color_indicator[colored_filetype];\n+    if (s->string != NULL)\n+      {\n+        /* Need to reset so not dealing with attribute combinations */\n+        if (is_colored (C_NORM))\n+\t  restore_default_color ();\n+        _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n+        _rl_put_indicator (s);\n+        _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n+        return 0;\n+      }\n+    else\n+      return 1;\n+  }\n+}\n+\n+void\n+_rl_prep_non_filename_text (void)\n+{\n+  if (_rl_color_indicator[C_END].string != NULL)\n+    _rl_put_indicator (&_rl_color_indicator[C_END]);\n+  else\n+    {\n+      _rl_put_indicator (&_rl_color_indicator[C_LEFT]);\n+      _rl_put_indicator (&_rl_color_indicator[C_RESET]);\n+      _rl_put_indicator (&_rl_color_indicator[C_RIGHT]);\n+    }\n+}\n+#endif /* COLOR_SUPPORT */"
    },
    {
      "sha": "6561ad90c1cf7c017bb1bdde130b655fe69e6110",
      "filename": "readline/colors.h",
      "status": "added",
      "additions": 126,
      "deletions": 0,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/colors.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/colors.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/colors.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,126 @@\n+/* `dir', `vdir' and `ls' directory listing programs for GNU.\n+\n+   Modified by Chet Ramey for Readline.\n+\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012, 2015\n+   Free Software Foundation, Inc.\n+\n+   This program is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Written by Richard Stallman and David MacKenzie.  */\n+\n+/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis\n+   Flaherty <dennisf@denix.elk.miles.com> based on original patches by\n+   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */\n+\n+#ifndef _COLORS_H_\n+#define _COLORS_H_\n+\n+#include <stdio.h> // size_t\n+\n+#if defined(__TANDEM) && defined(HAVE_STDBOOL_H) && (__STDC_VERSION__ < 199901L)\n+typedef int _Bool;\n+#endif\n+\n+#if defined (HAVE_STDBOOL_H)\n+#  include <stdbool.h> // bool\n+#else\n+typedef int _rl_bool_t;\n+\n+#ifdef bool\n+#  undef bool\n+#endif\n+#define bool _rl_bool_t\n+\n+#ifndef true\n+#  define true 1\n+#  define false 0\n+#endif\n+\n+#endif /* !HAVE_STDBOOL_H */\n+\n+/* Null is a valid character in a color indicator (think about Epson\n+   printers, for example) so we have to use a length/buffer string\n+   type. */\n+struct bin_str\n+  {\n+    size_t len;\n+    const char *string;\n+  };\n+\n+/* file type indicators (dir, sock, fifo, ...)\n+   Default value is initialized in parse-colors.c.\n+   It is then modified from the values of $LS_COLORS. */\n+extern struct bin_str _rl_color_indicator[];\n+\n+/* The LS_COLORS variable is in a termcap-like format. */\n+typedef struct _color_ext_type\n+  {\n+    struct bin_str ext;         \t/* The extension we're looking for */\n+    struct bin_str seq;         \t/* The sequence to output when we do */\n+    struct _color_ext_type *next;\t/* Next in list */\n+  } COLOR_EXT_TYPE;\n+\n+/* file extensions indicators (.txt, .log, .jpg, ...)\n+   Values are taken from $LS_COLORS in rl_parse_colors(). */\n+extern COLOR_EXT_TYPE *_rl_color_ext_list;\n+\n+#define FILETYPE_INDICATORS\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,\t\\\n+    C_LINK, C_SOCK, C_FILE, C_DIR\t\t\t\\\n+  }\n+\n+/* Whether we used any colors in the output so far.  If so, we will\n+   need to restore the default color later.  If not, we will need to\n+   call prep_non_filename_text before using color for the first time. */\n+\n+enum indicator_no\n+  {\n+    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,\n+    C_FIFO, C_SOCK,\n+    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,\n+    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,\n+    C_CLR_TO_EOL\n+  };\n+\n+\n+#if !S_IXUGO\n+# define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)\n+#endif\n+\n+enum filetype\n+  {\n+    unknown,\n+    fifo,\n+    chardev,\n+    directory,\n+    blockdev,\n+    normal,\n+    symbolic_link,\n+    sock,\n+    whiteout,\n+    arg_directory\n+  };\n+\n+/* Prefix color, currently same as socket */\n+#define C_PREFIX\tC_SOCK\n+\n+extern void _rl_put_indicator (const struct bin_str *ind);\n+extern void _rl_set_normal_color (void);\n+extern bool _rl_print_prefix_color (void);\n+extern bool _rl_print_color_indicator (const char *f);\n+extern void _rl_prep_non_filename_text (void);\n+\n+#endif /* !_COLORS_H_ */"
    },
    {
      "sha": "ac54d76a255e6d49e5e32f6de7459e94b33132b7",
      "filename": "readline/complete.c",
      "status": "modified",
      "additions": 426,
      "deletions": 93,
      "changes": 519,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/complete.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/complete.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/complete.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* complete.c -- filename completion for readline. */\n \n-/* Copyright (C) 1987-2011 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.\n@@ -31,6 +31,8 @@\n #  include <sys/file.h>\n #endif\n \n+#include <signal.h>\n+\n #if defined (HAVE_UNISTD_H)\n #  include <unistd.h>\n #endif /* HAVE_UNISTD_H */\n@@ -64,6 +66,10 @@ extern int errno;\n #include \"xmalloc.h\"\n #include \"rlprivate.h\"\n \n+#if defined (COLOR_SUPPORT)\n+#  include \"colors.h\"\n+#endif\n+\n #ifdef __STDC__\n typedef int QSFUNC (const void *, const void *);\n #else\n@@ -94,23 +100,35 @@ extern struct passwd *getpwent PARAMS((void));\n    longest string in that array. */\n rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;\n \n-#if defined (VISIBLE_STATS)\n+#if defined (VISIBLE_STATS) || defined (COLOR_SUPPORT)\n #  if !defined (X_OK)\n #    define X_OK 1\n #  endif\n+#endif\n+\n+#if defined (VISIBLE_STATS)\n static int stat_char PARAMS((char *));\n #endif\n \n+#if defined (COLOR_SUPPORT)\n+static int colored_stat_start PARAMS((const char *));\n+static void colored_stat_end PARAMS((void));\n+static int colored_prefix_start PARAMS((void));\n+static void colored_prefix_end PARAMS((void));\n+#endif\n+\n static int path_isdir PARAMS((const char *));\n \n static char *rl_quote_filename PARAMS((char *, int, char *));\n \n+static void _rl_complete_sigcleanup PARAMS((int, void *));\n+\n static void set_completion_defaults PARAMS((int));\n static int get_y_or_n PARAMS((int));\n static int _rl_internal_pager PARAMS((int));\n static char *printable_part PARAMS((char *));\n static int fnwidth PARAMS((const char *));\n-static int fnprint PARAMS((const char *, int));\n+static int fnprint PARAMS((const char *, int, const char *));\n static int print_filename PARAMS((char *, char *, int));\n \n static char **gen_completion_matches PARAMS((char *, int, int, rl_compentry_func_t *, int, int));\n@@ -156,8 +174,7 @@ int _rl_complete_mark_symlink_dirs = 0;\n int _rl_print_completions_horizontally;\n \n /* Non-zero means that case is not significant in filename completion. */\n-#if defined (__MSDOS__) && !defined (__DJGPP__)\t\\\n-  || (defined (_WIN32) && !defined (__CYGWIN__))\n+#if (defined (__MSDOS__) && !defined (__DJGPP__)) || (defined (_WIN32) && !defined (__CYGWIN__))\n int _rl_completion_case_fold = 1;\n #else\n int _rl_completion_case_fold = 0;\n@@ -190,6 +207,16 @@ int _rl_completion_columns = -1;\n int rl_visible_stats = 0;\n #endif /* VISIBLE_STATS */\n \n+#if defined (COLOR_SUPPORT)\n+/* Non-zero means to use colors to indicate file type when listing possible\n+   completions.  The colors used are taken from $LS_COLORS, if set. */\n+int _rl_colored_stats = 0;\n+\n+/* Non-zero means to use a color (currently magenta) to indicate the common\n+   prefix of a set of possible word completions. */\n+int _rl_colored_completion_prefix = 0;\n+#endif\n+\n /* If non-zero, when completing in the middle of a word, don't insert\n    characters from the match that match characters following point in\n    the word.  This means, for instance, completing when the cursor is\n@@ -207,6 +234,8 @@ rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;\n \n rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;\n \n+rl_icppfunc_t *rl_filename_stat_hook = (rl_icppfunc_t *)NULL;\n+\n /* If non-zero, this is the address of a function to call when reading\n    directory entries from the filesystem for completion and comparing\n    them to the partial word to be completed.  The function should\n@@ -381,6 +410,8 @@ static int completion_changed_buffer;\n /* The result of the query to the user about displaying completion matches */\n static int completion_y_or_n;\n \n+static int _rl_complete_display_matches_interrupt = 0;\n+\n /*************************************/\n /*\t\t\t\t     */\n /*    Bindable completion functions  */\n@@ -458,6 +489,18 @@ _rl_reset_completion_state ()\n   rl_completion_quote_character = 0;\n }\n \n+static void\n+_rl_complete_sigcleanup (sig, ptr)\n+     int sig;\n+     void *ptr;\n+{\n+  if (sig == SIGINT)\t/* XXX - for now */\n+    {\n+      _rl_free_match_list ((char **)ptr);\n+      _rl_complete_display_matches_interrupt = 1;\n+    }\n+}\n+\n /* Set default values for readline word completion.  These are the variables\n    that application completion functions can change or inspect. */\n static void\n@@ -473,6 +516,9 @@ set_completion_defaults (what_to_do)\n \n   /* The completion entry function may optionally change this. */\n   rl_completion_mark_symlink_dirs = _rl_complete_mark_symlink_dirs;\n+\n+  /* Reset private state. */\n+  _rl_complete_display_matches_interrupt = 0;\n }\n \n /* The user must press \"y\" or \"n\". Non-zero return means \"y\" pressed. */\n@@ -557,6 +603,8 @@ stat_char (filename)\n {\n   struct stat finfo;\n   int character, r;\n+  char *f;\n+  const char *fn;\n \n   /* Short-circuit a //server on cygwin, since that will always behave as\n      a directory. */\n@@ -565,10 +613,20 @@ stat_char (filename)\n     return '/';\n #endif\n \n+  f = 0;\n+  if (rl_filename_stat_hook)\n+    {\n+      f = savestring (filename);\n+      (*rl_filename_stat_hook) (&f);\n+      fn = f;\n+    }\n+  else\n+    fn = filename;\n+    \n #if defined (HAVE_LSTAT) && defined (S_ISLNK)\n-  r = lstat (filename, &finfo);\n+  r = lstat (fn, &finfo);\n #else\n-  r = stat (filename, &finfo);\n+  r = stat (fn, &finfo);\n #endif\n \n   if (r == -1)\n@@ -600,25 +658,56 @@ stat_char (filename)\n   else if (S_ISREG (finfo.st_mode))\n     {\n #if defined (_WIN32) && !defined (__CYGWIN__)\n-      /* Windows 'access' doesn't support X_OK and on latest Windows\n-\t versions even invokes an invalid parameter exception.  */\n-      char *ext = strrchr (filename, '.');\n-\n-      if (ext\n-\t  && (_rl_stricmp (ext, \".exe\") == 0\n-\t      || _rl_stricmp (ext, \".cmd\") == 0\n-\t      || _rl_stricmp (ext, \".bat\") == 0\n-\t      || _rl_stricmp (ext, \".com\") == 0))\n+      char *ext;\n+\n+      /* Windows doesn't do access and X_OK; check file extension instead */\n+      ext = strrchr (fn, '.');\n+      if (ext && (_rl_stricmp (ext, \".exe\") == 0 ||\n+\t\t  _rl_stricmp (ext, \".cmd\") == 0 ||\n+\t\t  _rl_stricmp (ext, \".bat\") == 0 ||\n+\t\t  _rl_stricmp (ext, \".com\") == 0))\n \tcharacter = '*';\n #else\n       if (access (filename, X_OK) == 0)\n \tcharacter = '*';\n #endif\n     }\n+\n+  xfree (f);\n   return (character);\n }\n #endif /* VISIBLE_STATS */\n \n+#if defined (COLOR_SUPPORT)\n+static int\n+colored_stat_start (filename)\n+     const char *filename;\n+{\n+  _rl_set_normal_color ();\n+  return (_rl_print_color_indicator (filename));\n+}\n+\n+static void\n+colored_stat_end ()\n+{\n+  _rl_prep_non_filename_text ();\n+  _rl_put_indicator (&_rl_color_indicator[C_CLR_TO_EOL]);\n+}\n+\n+static int\n+colored_prefix_start ()\n+{\n+  _rl_set_normal_color ();\n+  return (_rl_print_prefix_color ());\n+}\n+\n+static void\n+colored_prefix_end ()\n+{\n+  colored_stat_end ();\t\t/* for now */\n+}\n+#endif\n+\n /* Return the portion of PATHNAME that should be output when listing\n    possible completions.  If we are hacking filename completion, we\n    are only interested in the basename, the portion following the\n@@ -644,6 +733,8 @@ printable_part (pathname)\n \n   if (temp == 0 || *temp == '\\0')\n     return (pathname);\n+  else if (temp[1] == 0 && temp == pathname)\n+    return (pathname);\n   /* If the basename is NULL, we might have a pathname like '/usr/src/'.\n      Look for a previous slash and, if one is found, return the portion\n      following that slash.  If there's no previous slash, just return the\n@@ -698,7 +789,7 @@ fnwidth (string)\n \t  else\n \t    {\n \t      pos += clen;\n-\t      w = wcwidth (wc);\n+\t      w = WCWIDTH (wc);\n \t      width += (w >= 0) ? w : 1;\n \t    }\n #else\n@@ -714,31 +805,41 @@ fnwidth (string)\n #define ELLIPSIS_LEN\t3\n \n static int\n-fnprint (to_print, prefix_bytes)\n+fnprint (to_print, prefix_bytes, real_pathname)\n      const char *to_print;\n      int prefix_bytes;\n+     const char *real_pathname;\n {\n   int printed_len, w;\n   const char *s;\n+  int common_prefix_len, print_len;\n #if defined (HANDLE_MULTIBYTE)\n   mbstate_t ps;\n   const char *end;\n   size_t tlen;\n   int width;\n   wchar_t wc;\n \n-  end = to_print + strlen (to_print) + 1;\n+  print_len = strlen (to_print);\n+  end = to_print + print_len + 1;\n   memset (&ps, 0, sizeof (mbstate_t));\n #endif\n \n-  printed_len = 0;\n+  printed_len = common_prefix_len = 0;\n \n   /* Don't print only the ellipsis if the common prefix is one of the\n-     possible completions */\n-  if (to_print[prefix_bytes] == '\\0')\n+     possible completions.  Only cut off prefix_bytes if we're going to be\n+     printing the ellipsis, which takes precedence over coloring the\n+     completion prefix (see print_filename() below). */\n+  if (_rl_completion_prefix_display_length > 0 && prefix_bytes >= print_len)\n     prefix_bytes = 0;\n \n-  if (prefix_bytes)\n+#if defined (COLOR_SUPPORT)\n+  if (_rl_colored_stats && (prefix_bytes == 0 || _rl_colored_completion_prefix <= 0))\n+    colored_stat_start (real_pathname);\n+#endif\n+\n+  if (prefix_bytes && _rl_completion_prefix_display_length > 0)\n     {\n       char ellipsis;\n \n@@ -747,6 +848,15 @@ fnprint (to_print, prefix_bytes)\n \tputc (ellipsis, rl_outstream);\n       printed_len = ELLIPSIS_LEN;\n     }\n+#if defined (COLOR_SUPPORT)\n+  else if (prefix_bytes && _rl_colored_completion_prefix > 0)\n+    {\n+      common_prefix_len = prefix_bytes;\n+      prefix_bytes = 0;\n+      /* XXX - print color indicator start here */\n+      colored_prefix_start ();\n+    }\n+#endif\n \n   s = to_print + prefix_bytes;\n   while (*s)\n@@ -785,7 +895,7 @@ fnprint (to_print, prefix_bytes)\n \t    break;\n \t  else\n \t    {\n-\t      w = wcwidth (wc);\n+\t      w = WCWIDTH (wc);\n \t      width = (w >= 0) ? w : 1;\n \t    }\n \t  fwrite (s, 1, tlen, rl_outstream);\n@@ -797,8 +907,25 @@ fnprint (to_print, prefix_bytes)\n \t  printed_len++;\n #endif\n \t}\n+      if (common_prefix_len > 0 && (s - to_print) >= common_prefix_len)\n+\t{\n+#if defined (COLOR_SUPPORT)\n+\t  /* printed bytes = s - to_print */\n+\t  /* printed bytes should never be > but check for paranoia's sake */\n+\t  colored_prefix_end ();\n+\t  if (_rl_colored_stats)\n+\t    colored_stat_start (real_pathname);\t\t/* XXX - experiment */\n+#endif\n+\t  common_prefix_len = 0;\n+\t}\n     }\n \n+#if defined (COLOR_SUPPORT)\n+  /* XXX - unconditional for now */\n+  if (_rl_colored_stats)\n+    colored_stat_end ();\n+#endif\n+\n   return printed_len;\n }\n \n@@ -815,13 +942,20 @@ print_filename (to_print, full_pathname, prefix_bytes)\n   char *s, c, *new_full_pathname, *dn;\n \n   extension_char = 0;\n-  printed_len = fnprint (to_print, prefix_bytes);\n+#if defined (COLOR_SUPPORT)\n+  /* Defer printing if we want to prefix with a color indicator */\n+  if (_rl_colored_stats == 0 || rl_filename_completion_desired == 0)\n+#endif\n+    printed_len = fnprint (to_print, prefix_bytes, to_print);\n \n+  if (rl_filename_completion_desired && (\n #if defined (VISIBLE_STATS)\n- if (rl_filename_completion_desired && (rl_visible_stats || _rl_complete_mark_directories))\n-#else\n- if (rl_filename_completion_desired && _rl_complete_mark_directories)\n+     rl_visible_stats ||\n+#endif\n+#if defined (COLOR_SUPPORT)\n+     _rl_colored_stats ||\n #endif\n+     _rl_complete_mark_directories))\n     {\n       /* If to_print != full_pathname, to_print is the basename of the\n \t path passed.  In this case, we try to expand the directory\n@@ -867,8 +1001,25 @@ print_filename (to_print, full_pathname, prefix_bytes)\n \t    extension_char = stat_char (new_full_pathname);\n \t  else\n #endif\n-\t  if (path_isdir (new_full_pathname))\n-\t    extension_char = '/';\n+\t  if (_rl_complete_mark_directories)\n+\t    {\n+\t      dn = 0;\n+\t      if (rl_directory_completion_hook == 0 && rl_filename_stat_hook)\n+\t\t{\n+\t\t  dn = savestring (new_full_pathname);\n+\t\t  (*rl_filename_stat_hook) (&dn);\n+\t\t  xfree (new_full_pathname);\n+\t\t  new_full_pathname = dn;\n+\t\t}\n+\t      if (path_isdir (new_full_pathname))\n+\t\textension_char = '/';\n+\t    }\n+\n+\t  /* Move colored-stats code inside fnprint() */\n+#if defined (COLOR_SUPPORT)\n+\t  if (_rl_colored_stats)\n+\t    printed_len = fnprint (to_print, prefix_bytes, new_full_pathname);\n+#endif\n \n \t  xfree (new_full_pathname);\n \t  to_print[-1] = c;\n@@ -881,8 +1032,14 @@ print_filename (to_print, full_pathname, prefix_bytes)\n \t    extension_char = stat_char (s);\n \t  else\n #endif\n-\t    if (path_isdir (s))\n+\t    if (_rl_complete_mark_directories && path_isdir (s))\n \t      extension_char = '/';\n+\n+\t  /* Move colored-stats code inside fnprint() */\n+#if defined (COLOR_SUPPORT)\n+\t  if (_rl_colored_stats)\n+\t    printed_len = fnprint (to_print, prefix_bytes, s);\n+#endif\n \t}\n \n       xfree (s);\n@@ -1077,10 +1234,13 @@ gen_completion_matches (text, start, end, our_func, found_quote, quote_char)\n      variable rl_attempted_completion_function. */\n   if (rl_attempted_completion_function)\n     {\n-      _rl_interrupt_immediately++;\n       matches = (*rl_attempted_completion_function) (text, start, end);\n-      if (_rl_interrupt_immediately > 0)\n-\t_rl_interrupt_immediately--;\n+      if (RL_SIG_RECEIVED())\n+\t{\n+\t  _rl_free_match_list (matches);\n+\t  matches = 0;\n+\t  RL_CHECK_SIGNALS ();\n+\t}\n \n       if (matches || rl_attempted_completion_over)\n \t{\n@@ -1091,7 +1251,15 @@ gen_completion_matches (text, start, end, our_func, found_quote, quote_char)\n \n   /* XXX -- filename dequoting moved into rl_filename_completion_function */\n \n+  /* rl_completion_matches will check for signals as well to avoid a long\n+     delay while reading a directory. */\n   matches = rl_completion_matches (text, our_func);\n+  if (RL_SIG_RECEIVED())\n+    {\n+      _rl_free_match_list (matches);\n+      matches = 0;\n+      RL_CHECK_SIGNALS ();\n+    }\n   return matches;  \n }\n \n@@ -1166,9 +1334,11 @@ compute_lcd_of_matches (match_list, matches, text)\n {\n   register int i, c1, c2, si;\n   int low;\t\t/* Count of max-matched characters. */\n+  int lx;\n   char *dtext;\t\t/* dequoted TEXT, if needed */\n #if defined (HANDLE_MULTIBYTE)\n   int v;\n+  size_t v1, v2;\n   mbstate_t ps1, ps2;\n   wchar_t wc1, wc2;\n #endif\n@@ -1201,14 +1371,20 @@ compute_lcd_of_matches (match_list, matches, text)\n #if defined (HANDLE_MULTIBYTE)\n \t    if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \t      {\n-\t\tv = mbrtowc (&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);\n-\t\tmbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);\n+\t\tv1 = mbrtowc(&wc1, match_list[i]+si, strlen (match_list[i]+si), &ps1);\n+\t\tv2 = mbrtowc (&wc2, match_list[i+1]+si, strlen (match_list[i+1]+si), &ps2);\n+\t\tif (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n+\t\t  {\n+\t\t    if (c1 != c2)\t/* do byte comparison */\n+\t\t      break;\n+\t\t    continue;\n+\t\t  }\n \t\twc1 = towlower (wc1);\n \t\twc2 = towlower (wc2);\n \t\tif (wc1 != wc2)\n \t\t  break;\n-\t\telse if (v > 1)\n-\t\t  si += v - 1;\n+\t\telse if (v1 > 1)\n+\t\t  si += v1 - 1;\n \t      }\n \t    else\n #endif\n@@ -1283,21 +1459,20 @@ compute_lcd_of_matches (match_list, matches, text)\n \t  qsort (match_list+1, matches, sizeof(char *), (QSFUNC *)_rl_qsort_string_compare);\n \n \t  si = strlen (text);\n-\t  if (si <= low)\n-\t    {\n-\t      for (i = 1; i <= matches; i++)\n-\t\tif (strncmp (match_list[i], text, si) == 0)\n-\t\t  {\n-\t\t    strncpy (match_list[0], match_list[i], low);\n-\t\t    break;\n-\t\t  }\n-\t      /* no casematch, use first entry */\n-\t      if (i > matches)\n-\t\tstrncpy (match_list[0], match_list[1], low);\n-\t    }\n-\t  else\n-\t    /* otherwise, just use the text the user typed. */\n-\t    strncpy (match_list[0], text, low);\n+\t  lx = (si <= low) ? si : low;\t/* check shorter of text and matches */\n+\t  /* Try to preserve the case of what the user typed in the presence of\n+\t     multiple matches: check each match for something that matches\n+\t     what the user typed taking case into account; use it up to common\n+\t     length of matches if one is found.  If not, just use first match. */\n+\t  for (i = 1; i <= matches; i++)\n+\t    if (strncmp (match_list[i], text, lx) == 0)\n+\t      {\n+\t\tstrncpy (match_list[0], match_list[i], low);\n+\t\tbreak;\n+\t      }\n+\t  /* no casematch, use first entry */\n+\t  if (i > matches)\n+\t    strncpy (match_list[0], match_list[1], low);\n \n \t  FREE (dtext);\n \t}\n@@ -1324,7 +1499,7 @@ postprocess_matches (matchesp, matching_filenames)\n     return 0;\n \n   /* It seems to me that in all the cases we handle we would like\n-     to ignore duplicate possiblilities.  Scan for the text to\n+     to ignore duplicate possibilities.  Scan for the text to\n      insert being identical to the other completions. */\n   if (rl_ignore_completion_duplicates)\n     {\n@@ -1402,15 +1577,29 @@ rl_display_match_list (matches, len, max)\n   if (_rl_completion_prefix_display_length > 0)\n     {\n       t = printable_part (matches[0]);\n-      temp = strrchr (t, '/');\n+      /* check again in case of /usr/src/ */\n+      temp = rl_filename_completion_desired ? strrchr (t, '/') : 0;\n       common_length = temp ? fnwidth (temp) : fnwidth (t);\n       sind = temp ? strlen (temp) : strlen (t);\n+      if (common_length > max || sind > max)\n+\tcommon_length = sind = 0;\n \n       if (common_length > _rl_completion_prefix_display_length && common_length > ELLIPSIS_LEN)\n \tmax -= common_length - ELLIPSIS_LEN;\n       else\n \tcommon_length = sind = 0;\n     }\n+#if defined (COLOR_SUPPORT)\n+  else if (_rl_colored_completion_prefix > 0)\n+    {\n+      t = printable_part (matches[0]);\n+      temp = rl_filename_completion_desired ? strrchr (t, '/') : 0;\n+      common_length = temp ? fnwidth (temp) : fnwidth (t);\n+      sind = temp ? RL_STRLEN (temp+1) : RL_STRLEN (t);\t\t/* want portion after final slash */\n+      if (common_length > max || sind > max)\n+\tcommon_length = sind = 0;\n+    }\n+#endif\n \n   /* How many items of MAX length can we fit in the screen window? */\n   cols = complete_get_screenwidth ();\n@@ -1457,12 +1646,23 @@ rl_display_match_list (matches, len, max)\n \t\t  printed_len = print_filename (temp, matches[l], sind);\n \n \t\t  if (j + 1 < limit)\n-\t\t    for (k = 0; k < max - printed_len; k++)\n-\t\t      putc (' ', rl_outstream);\n+\t\t    {\n+\t\t      if (max <= printed_len)\n+\t\t\tputc (' ', rl_outstream);\n+\t\t      else\n+\t\t\tfor (k = 0; k < max - printed_len; k++)\n+\t\t\t  putc (' ', rl_outstream);\n+\t\t    }\n \t\t}\n \t      l += count;\n \t    }\n \t  rl_crlf ();\n+#if defined (SIGWINCH)\n+\t  if (RL_SIG_RECEIVED () && RL_SIGWINCH_RECEIVED() == 0)\n+#else\n+\t  if (RL_SIG_RECEIVED ())\n+#endif\n+\t    return;\n \t  lines++;\n \t  if (_rl_page_completions && lines >= (_rl_screenheight - 1) && i < count)\n \t    {\n@@ -1480,9 +1680,15 @@ rl_display_match_list (matches, len, max)\n \t  temp = printable_part (matches[i]);\n \t  printed_len = print_filename (temp, matches[i], sind);\n \t  /* Have we reached the end of this line? */\n+#if defined (SIGWINCH)\n+\t  if (RL_SIG_RECEIVED () && RL_SIGWINCH_RECEIVED() == 0)\n+#else\n+\t  if (RL_SIG_RECEIVED ())\n+#endif\n+\t    return;\n \t  if (matches[i+1])\n \t    {\n-\t      if (i && (limit > 1) && (i % limit) == 0)\n+\t      if (limit == 1 || (i && (limit > 1) && (i % limit) == 0))\n \t\t{\n \t\t  rl_crlf ();\n \t\t  lines++;\n@@ -1493,6 +1699,8 @@ rl_display_match_list (matches, len, max)\n \t\t\treturn;\n \t\t    }\n \t\t}\n+\t      else if (max <= printed_len)\n+\t\tputc (' ', rl_outstream);\n \t      else\n \t\tfor (k = 0; k < max - printed_len; k++)\n \t\t  putc (' ', rl_outstream);\n@@ -1691,7 +1899,7 @@ append_to_match (text, delimiter, quote_char, nontrivial_match)\n      char *text;\n      int delimiter, quote_char, nontrivial_match;\n {\n-  char temp_string[4], *filename;\n+  char temp_string[4], *filename, *fn;\n   int temp_string_index, s;\n   struct stat finfo;\n \n@@ -1710,6 +1918,13 @@ append_to_match (text, delimiter, quote_char, nontrivial_match)\n   if (rl_filename_completion_desired)\n     {\n       filename = tilde_expand (text);\n+      if (rl_filename_stat_hook)\n+        {\n+          fn = savestring (filename);\n+\t  (*rl_filename_stat_hook) (&fn);\n+\t  xfree (filename);\n+\t  filename = fn;\n+        }\n       s = (nontrivial_match && rl_completion_mark_symlink_dirs == 0)\n \t\t? LSTAT (filename, &finfo)\n \t\t: stat (filename, &finfo);\n@@ -1729,8 +1944,7 @@ append_to_match (text, delimiter, quote_char, nontrivial_match)\n #ifdef S_ISLNK\n       /* Don't add anything if the filename is a symlink and resolves to a\n \t directory. */\n-      else if (s == 0 && S_ISLNK (finfo.st_mode) &&\n-\t       stat (filename, &finfo) == 0 && S_ISDIR (finfo.st_mode))\n+      else if (s == 0 && S_ISLNK (finfo.st_mode) && path_isdir (filename))\n \t;\n #endif\n       else\n@@ -1850,10 +2064,8 @@ rl_complete_internal (what_to_do)\n   /* nontrivial_lcd is set if the common prefix adds something to the word\n      being completed. */\n   nontrivial_lcd = matches && strcmp (text, matches[0]) != 0;\n-#if 1\n   if (what_to_do == '!' || what_to_do == '@')\n     tlen = strlen (text);\n-#endif\n   xfree (text);\n \n   if (matches == 0)\n@@ -1887,10 +2099,6 @@ rl_complete_internal (what_to_do)\n     case '!':\n     case '@':\n       /* Insert the first match with proper quoting. */\n-#if 0\n-      if (*matches[0])\n-\tinsert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n-#else\n       if (what_to_do == TAB)\n         {\n           if (*matches[0])\n@@ -1905,7 +2113,6 @@ rl_complete_internal (what_to_do)\n \t  if (mlen >= tlen)\n \t    insert_match (matches[0], start, matches[1] ? MULT_MATCH : SINGLE_MATCH, &quote_char);\n \t}\n-#endif\n \n       /* If there are more matches, ring the bell to indicate.\n \t If we are in vi mode, Posix.2 says to not ring the bell.\n@@ -1941,14 +2148,30 @@ rl_complete_internal (what_to_do)\n       break;\n \n     case '?':\n+      if (rl_completion_display_matches_hook == 0)\n+\t{\n+\t  _rl_sigcleanup = _rl_complete_sigcleanup;\n+\t  _rl_sigcleanarg = matches;\n+\t  _rl_complete_display_matches_interrupt = 0;\n+\t}\n       display_matches (matches);\n+      if (_rl_complete_display_matches_interrupt)\n+        {\n+          matches = 0;\t\t/* already freed by rl_complete_sigcleanup */\n+          _rl_complete_display_matches_interrupt = 0;\n+\t  if (rl_signal_event_hook)\n+\t    (*rl_signal_event_hook) ();\t\t/* XXX */\n+        }\n+      _rl_sigcleanup = 0;\n+      _rl_sigcleanarg = 0;\n       break;\n \n     default:\n       _rl_ttymsg (\"bad value %d for what_to_do in rl_complete\", what_to_do);\n       rl_ding ();\n       FREE (saved_line_buffer);\n       RL_UNSETSTATE(RL_STATE_COMPLETING);\n+      _rl_free_match_list (matches);\n       _rl_reset_completion_state ();\n       return 1;\n     }\n@@ -1964,6 +2187,8 @@ rl_complete_internal (what_to_do)\n \n   RL_UNSETSTATE(RL_STATE_COMPLETING);\n   _rl_reset_completion_state ();\n+\n+  RL_CHECK_SIGNALS ();\n   return 0;\n }\n \n@@ -1990,6 +2215,8 @@ rl_completion_matches (text, entry_function)\n      const char *text;\n      rl_compentry_func_t *entry_function;\n {\n+  register int i;\n+\n   /* Number of slots in match_list. */\n   int match_list_size;\n \n@@ -2007,18 +2234,36 @@ rl_completion_matches (text, entry_function)\n   match_list = (char **)xmalloc ((match_list_size + 1) * sizeof (char *));\n   match_list[1] = (char *)NULL;\n \n-  _rl_interrupt_immediately++;\n   while (string = (*entry_function) (text, matches))\n     {\n-      if (matches + 1 == match_list_size)\n+      if (RL_SIG_RECEIVED ())\n+\t{\n+\t  /* Start at 1 because we don't set matches[0] in this function.\n+\t     Only free the list members if we're building match list from\n+\t     rl_filename_completion_function, since we know that doesn't\n+\t     free the strings it returns. */\n+\t  if (entry_function == rl_filename_completion_function)\n+\t    {\n+\t      for (i = 1; match_list[i]; i++)\n+\t\txfree (match_list[i]);\n+\t    }\n+\t  xfree (match_list);\n+\t  match_list = 0;\n+\t  match_list_size = 0;\n+\t  matches = 0;\n+\t  RL_CHECK_SIGNALS ();\n+\t}\n+\n+      if (matches + 1 >= match_list_size)\n \tmatch_list = (char **)xrealloc\n \t  (match_list, ((match_list_size += 10) + 1) * sizeof (char *));\n \n+      if (match_list == 0)\n+\treturn (match_list);\n+\n       match_list[++matches] = string;\n       match_list[matches + 1] = (char *)NULL;\n     }\n-  if (_rl_interrupt_immediately > 0)\n-    _rl_interrupt_immediately--;\n \n   /* If there were any matches, then look through them finding out the\n      lowest common denominator.  That then becomes match_list[0]. */\n@@ -2057,7 +2302,9 @@ rl_username_completion_function (text, state)\n \n       username = savestring (&text[first_char_loc]);\n       namelen = strlen (username);\n+#if defined (HAVE_GETPWENT)\n       setpwent ();\n+#endif\n     }\n \n #if defined (HAVE_GETPWENT)\n@@ -2094,8 +2341,9 @@ rl_username_completion_function (text, state)\n \n /* Return non-zero if CONVFN matches FILENAME up to the length of FILENAME\n    (FILENAME_LEN).  If _rl_completion_case_fold is set, compare without\n-   regard to the alphabetic case of characters.  CONVFN is the possibly-\n-   converted directory entry; FILENAME is what the user typed. */\n+   regard to the alphabetic case of characters.  If\n+   _rl_completion_case_map is set, make `-' and `_' equivalent.  CONVFN is\n+   the possibly-converted directory entry; FILENAME is what the user typed. */\n static int\n complete_fncmp (convfn, convlen, filename, filename_len)\n      const char *convfn;\n@@ -2105,34 +2353,110 @@ complete_fncmp (convfn, convlen, filename, filename_len)\n {\n   register char *s1, *s2;\n   int d, len;\n+#if defined (HANDLE_MULTIBYTE)\n+  size_t v1, v2;\n+  mbstate_t ps1, ps2;\n+  wchar_t wc1, wc2;\n+#endif\n+\n+#if defined (HANDLE_MULTIBYTE)\n+  memset (&ps1, 0, sizeof (mbstate_t));\n+  memset (&ps2, 0, sizeof (mbstate_t));\n+#endif\n+\n+  if (filename_len == 0)\n+    return 1;\n+  if (convlen < filename_len)\n+    return 0;\n+\n+  len = filename_len;\n+  s1 = (char *)convfn;\n+  s2 = (char *)filename;\n \n   /* Otherwise, if these match up to the length of filename, then\n      it is a match. */\n   if (_rl_completion_case_fold && _rl_completion_case_map)\n     {\n       /* Case-insensitive comparison treating _ and - as equivalent */\n-      if (filename_len == 0)\n-\treturn 1;\n-      if (convlen < filename_len)\n-\treturn 0;\n-      s1 = (char *)convfn;\n-      s2 = (char *)filename;\n-      len = filename_len;\n-      do\n+#if defined (HANDLE_MULTIBYTE)\n+      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \t{\n-\t  d = _rl_to_lower (*s1) - _rl_to_lower (*s2);\n-\t  /* *s1 == [-_] && *s2 == [-_] */\n-\t  if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))\n-\t    d = 0;\n-\t  if (d != 0)\n-\t    return 0;\n-\t  s1++; s2++;\t/* already checked convlen >= filename_len */\n+\t  do\n+\t    {\n+\t      v1 = mbrtowc (&wc1, s1, convlen, &ps1);\n+\t      v2 = mbrtowc (&wc2, s2, filename_len, &ps2);\n+\t      if (v1 == 0 && v2 == 0)\n+\t\treturn 1;\n+\t      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n+\t\t{\n+\t\t  if (*s1 != *s2)\t\t/* do byte comparison */\n+\t\t    return 0;\n+\t\t  else if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))\n+\t\t    return 0;\n+\t\t  s1++; s2++; len--;\n+\t\t  continue;\n+\t\t}\n+\t      wc1 = towlower (wc1);\n+\t      wc2 = towlower (wc2);\n+\t      s1 += v1;\n+\t      s2 += v1;\n+\t      len -= v1;\n+\t      if ((wc1 == L'-' || wc1 == L'_') && (wc2 == L'-' || wc2 == L'_'))\n+\t        continue;\n+\t      if (wc1 != wc2)\n+\t\treturn 0;\n+\t    }\n+\t  while (len != 0);\n \t}\n-      while (--len != 0);\n+      else\n+#endif\n+\t{\n+\tdo\n+\t  {\n+\t    d = _rl_to_lower (*s1) - _rl_to_lower (*s2);\n+\t    /* *s1 == [-_] && *s2 == [-_] */\n+\t    if ((*s1 == '-' || *s1 == '_') && (*s2 == '-' || *s2 == '_'))\n+\t      d = 0;\n+\t    if (d != 0)\n+\t      return 0;\n+\t    s1++; s2++;\t/* already checked convlen >= filename_len */\n+\t  }\n+\twhile (--len != 0);\n+\t}\n+\n       return 1;\n     }\n   else if (_rl_completion_case_fold)\n     {\n+#if defined (HANDLE_MULTIBYTE)\n+      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t{\n+\t  do\n+\t    {\n+\t      v1 = mbrtowc (&wc1, s1, convlen, &ps1);\n+\t      v2 = mbrtowc (&wc2, s2, filename_len, &ps2);\n+\t      if (v1 == 0 && v2 == 0)\n+\t\treturn 1;\n+\t      else if (MB_INVALIDCH (v1) || MB_INVALIDCH (v2))\n+\t\t{\n+\t\t  if (*s1 != *s2)\t\t/* do byte comparison */\n+\t\t    return 0;\n+\t\t  s1++; s2++; len--;\n+\t\t  continue;\n+\t\t}\n+\t      wc1 = towlower (wc1);\n+\t      wc2 = towlower (wc2);\n+\t      if (wc1 != wc2)\n+\t\treturn 0;\n+\t      s1 += v1;\n+\t      s2 += v1;\n+\t      len -= v1;\n+\t    }\n+\t  while (len != 0);\n+\t  return 1;\n+\t}\n+      else\n+#endif\n       if ((_rl_to_lower (convfn[0]) == _rl_to_lower (filename[0])) &&\n \t  (convlen >= filename_len) &&\n \t  (_rl_strnicmp (filename, convfn, filename_len) == 0))\n@@ -2164,6 +2488,7 @@ rl_filename_completion_function (text, state)\n   static int filename_len;\n   char *temp, *dentry, *convfn;\n   int dirlen, dentlen, convlen;\n+  int tilde_dirname;\n   struct dirent *entry;\n \n   /* If we don't have any state, then do some initialization. */\n@@ -2221,11 +2546,13 @@ rl_filename_completion_function (text, state)\n       else\n \tusers_dirname = savestring (dirname);\n \n+      tilde_dirname = 0;\n       if (*dirname == '~')\n \t{\n \t  temp = tilde_expand (dirname);\n \t  xfree (dirname);\n \t  dirname = temp;\n+\t  tilde_dirname = 1;\n \t}\n \n       /* We have saved the possibly-dequoted version of the directory name\n@@ -2244,16 +2571,17 @@ rl_filename_completion_function (text, state)\n \t  xfree (users_dirname);\n \t  users_dirname = savestring (dirname);\n \t}\n-      else if (rl_completion_found_quote && rl_filename_dequoting_function)\n+      else if (tilde_dirname == 0 && rl_completion_found_quote && rl_filename_dequoting_function)\n \t{\n \t  /* delete single and double quotes */\n \t  xfree (dirname);\n \t  dirname = savestring (users_dirname);\n \t}\n       directory = opendir (dirname);\n \n-      /* Now dequote a non-null filename. */\n-      if (filename && *filename && rl_completion_found_quote && rl_filename_dequoting_function)\n+      /* Now dequote a non-null filename.  FILENAME will not be NULL, but may\n+\t be empty. */\n+      if (*filename && rl_completion_found_quote && rl_filename_dequoting_function)\n \t{\n \t  /* delete single and double quotes */\n \t  temp = (*rl_filename_dequoting_function) (filename, rl_completion_quote_character);\n@@ -2617,6 +2945,11 @@ rl_menu_complete (count, ignore)\n \t      full_completion = 1;\n \t      return (0);\n \t    }\n+\t  else if (_rl_menu_complete_prefix_first)\n+\t    {\n+\t      rl_ding ();\n+\t      return (0);\n+\t    }\n \t}\n       else if (match_list_size <= 1)\n \t{"
    },
    {
      "sha": "d03ebe00844d2d602d254b2b6441df74985b7af0",
      "filename": "readline/config.h.in",
      "status": "modified",
      "additions": 33,
      "deletions": 17,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/config.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/config.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/config.h.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -16,9 +16,6 @@\n \n #undef _FILE_OFFSET_BITS\n \n-/* Define if on MINIX.  */\n-#undef _MINIX\n-\n /* Define as the return type of signal handlers (int or void).  */\n #undef RETSIGTYPE\n \n@@ -36,12 +33,16 @@\n #undef volatile\n \n #undef PROTOTYPES\n+#undef __PROTOTYPES\n \n #undef __CHAR_UNSIGNED__\n \n /* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */\n #undef STAT_MACROS_BROKEN\n \n+/* Define if you have the chown function. */\n+#undef HAVE_CHOWN\n+\n /* Define if you have the fcntl function. */\n #undef HAVE_FCNTL\n \n@@ -87,9 +88,15 @@\n /* Define if you have the memmove function. */\n #undef HAVE_MEMMOVE\n \n+/* Define if you have the pselect function.  */\n+#undef HAVE_PSELECT\n+\n /* Define if you have the putenv function.  */\n #undef HAVE_PUTENV\n \n+/* Define if you have the readlink function.  */\n+#undef HAVE_READLINK\n+\n /* Define if you have the select function.  */\n #undef HAVE_SELECT\n \n@@ -134,6 +141,9 @@\n /* Define if you have the wcwidth function.  */\n #undef HAVE_WCWIDTH\n \n+/* and whether it works */\n+#undef WCWIDTH_BROKEN\n+\n #undef STDC_HEADERS\n \n /* Define if you have the <dirent.h> header file.  */\n@@ -145,6 +155,9 @@\n /* Define if you have the <langinfo.h> header file.  */\n #undef HAVE_LANGINFO_H\n \n+/* Define if you have the <libaudit.h> header file.  */\n+#undef HAVE_LIBAUDIT_H\n+\n /* Define if you have the <limits.h> header file.  */\n #undef HAVE_LIMITS_H\n \n@@ -157,12 +170,18 @@\n /* Define if you have the <ndir.h> header file.  */\n #undef HAVE_NDIR_H\n \n+/* Define if you have the <ncurses/termcap.h> header file.  */\n+#undef HAVE_NCURSES_TERMCAP_H\n+\n /* Define if you have the <pwd.h> header file.  */\n #undef HAVE_PWD_H\n \n /* Define if you have the <stdarg.h> header file.  */\n #undef HAVE_STDARG_H\n \n+/* Define if you have the <stdbool.h> header file.  */\n+#undef HAVE_STDBOOL_H\n+\n /* Define if you have the <stdlib.h> header file.  */\n #undef HAVE_STDLIB_H\n \n@@ -178,6 +197,9 @@\n /* Define if you have the <sys/file.h> header file.  */\n #undef HAVE_SYS_FILE_H\n \n+/* Define if you have the <sys/ioctl.h> header file.  */\n+#undef HAVE_SYS_IOCTL_H\n+\n /* Define if you have the <sys/ndir.h> header file.  */\n #undef HAVE_SYS_NDIR_H\n \n@@ -196,9 +218,6 @@\n /* Define if you have the <termcap.h> header file.  */\n #undef HAVE_TERMCAP_H\n \n-/* Define if you have the <ncurses/termcap.h> header file.  */\n-#undef HAVE_NCURSES_TERMCAP_H\n-\n /* Define if you have the <termio.h> header file.  */\n #undef HAVE_TERMIO_H\n \n@@ -231,6 +250,9 @@\n /* Define if you have <langinfo.h> and nl_langinfo(CODESET). */\n #undef HAVE_LANGINFO_CODESET\n \n+/* Define if you have <linux/audit.h> and it defines AUDIT_USER_TTY */\n+#undef HAVE_DECL_AUDIT_USER_TTY\n+\n /* Definitions pulled in from aclocal.m4. */\n #undef VOID_SIGHANDLER\n \n@@ -248,9 +270,11 @@\n \n #undef HAVE_GETPW_DECLS\n \n-#undef STRUCT_DIRENT_HAS_D_INO\n+#undef HAVE_STRUCT_DIRENT_D_INO\n \n-#undef STRUCT_DIRENT_HAS_D_FILENO\n+#undef HAVE_STRUCT_DIRENT_D_FILENO\n+\n+#undef HAVE_STRUCT_DIRENT_D_NAMLEN\n \n #undef HAVE_BSD_SIGNALS\n \n@@ -272,12 +296,4 @@\n #  define TERMIOS_MISSING\n #endif\n \n-#if defined (__STDC__) && defined (HAVE_STDARG_H)\n-#  define PREFER_STDARG\n-#  define USE_VARARGS\n-#else\n-#  if defined (HAVE_VARARGS_H)\n-#    define PREFER_VARARGS\n-#    define USE_VARARGS\n-#  endif\n-#endif\n+/* VARARGS defines moved to rlstdc.h */"
    },
    {
      "sha": "3054c479abcf2d4c89c15dda369770f9f829b1ec",
      "filename": "readline/configure",
      "status": "modified",
      "additions": 305,
      "deletions": 39,
      "changes": 344,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/configure?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n #! /bin/sh\n-# From configure.in for Readline 6.2, version 2.67.\n+# From configure.ac for Readline 7.0, version 2.81.\n # Guess values for system-dependent variables and create Makefiles.\n-# Generated by GNU Autoconf 2.69 for readline 6.2.\n+# Generated by GNU Autoconf 2.69 for readline 7.0.\n #\n # Report bugs to <bug-readline@gnu.org>.\n #\n@@ -581,8 +581,8 @@ MAKEFLAGS=\n # Identity of this package.\n PACKAGE_NAME='readline'\n PACKAGE_TARNAME='readline'\n-PACKAGE_VERSION='6.2'\n-PACKAGE_STRING='readline 6.2'\n+PACKAGE_VERSION='7.0'\n+PACKAGE_STRING='readline 7.0'\n PACKAGE_BUGREPORT='bug-readline@gnu.org'\n PACKAGE_URL=''\n \n@@ -631,7 +631,6 @@ LOCAL_DEFS\n LOCAL_LDFLAGS\n LOCAL_CFLAGS\n BUILD_DIR\n-PURIFY\n SHARED_INSTALL_TARGET\n STATIC_INSTALL_TARGET\n SHARED_TARGET\n@@ -722,7 +721,6 @@ ac_subst_files=''\n ac_user_opts='\n enable_option_checking\n with_curses\n-with_purify\n enable_multibyte\n enable_static\n enable_largefile\n@@ -1276,7 +1274,7 @@ if test \"$ac_init_help\" = \"long\"; then\n   # Omit some internal or obsolete options to make the list less imposing.\n   # This message is too long to be a string in the A/UX 3.1 sh.\n   cat <<_ACEOF\n-\\`configure' configures readline 6.2 to adapt to many kinds of systems.\n+\\`configure' configures readline 7.0 to adapt to many kinds of systems.\n \n Usage: $0 [OPTION]... [VAR=VALUE]...\n \n@@ -1341,7 +1339,7 @@ fi\n \n if test -n \"$ac_init_help\"; then\n   case $ac_init_help in\n-     short | recursive ) echo \"Configuration of readline 6.2:\";;\n+     short | recursive ) echo \"Configuration of readline 7.0:\";;\n    esac\n   cat <<\\_ACEOF\n \n@@ -1358,7 +1356,6 @@ Optional Packages:\n   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)\n   --with-curses           use the curses library instead of the termcap\n                           library\n-  --with-purify           configure to postprocess with purify\n \n Some influential environment variables:\n   CC          C compiler command\n@@ -1436,7 +1433,7 @@ fi\n test -n \"$ac_init_help\" && exit $ac_status\n if $ac_init_version; then\n   cat <<\\_ACEOF\n-readline configure 6.2\n+readline configure 7.0\n generated by GNU Autoconf 2.69\n \n Copyright (C) 2012 Free Software Foundation, Inc.\n@@ -1855,11 +1852,57 @@ $as_echo \"$ac_res\" >&6; }\n   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n \n } # ac_fn_c_check_func\n+\n+# ac_fn_c_check_decl LINENO SYMBOL VAR INCLUDES\n+# ---------------------------------------------\n+# Tests whether SYMBOL is declared in INCLUDES, setting cache variable VAR\n+# accordingly.\n+ac_fn_c_check_decl ()\n+{\n+  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n+  as_decl_name=`echo $2|sed 's/ *(.*//'`\n+  as_decl_use=`echo $2|sed -e 's/(/((/' -e 's/)/) 0&/' -e 's/,/) 0& (/g'`\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether $as_decl_name is declared\" >&5\n+$as_echo_n \"checking whether $as_decl_name is declared... \" >&6; }\n+if eval \\${$3+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$4\n+int\n+main ()\n+{\n+#ifndef $as_decl_name\n+#ifdef __cplusplus\n+  (void) $as_decl_use;\n+#else\n+  (void) $as_decl_name;\n+#endif\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  eval \"$3=yes\"\n+else\n+  eval \"$3=no\"\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+eval ac_res=\\$$3\n+\t       { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\n+$as_echo \"$ac_res\" >&6; }\n+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n+\n+} # ac_fn_c_check_decl\n cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n \n-It was created by readline $as_me 6.2, which was\n+It was created by readline $as_me 7.0, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   $ $0 $@\n@@ -2246,7 +2289,7 @@ ac_configure=\"$SHELL $ac_aux_dir/configure\"  # Please don't use this var.\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-LIBVERSION=6.2\n+LIBVERSION=7.0\n \n # Make sure we can run config.sub.\n $SHELL \"$ac_aux_dir/config.sub\" sun4 >/dev/null 2>&1 ||\n@@ -2322,7 +2365,6 @@ case $host_os in *\\ *) host_os=`echo \"$host_os\" | sed 's/ /-/g'`;; esac\n \n \n opt_curses=no\n-opt_purify=no\n \n \n # Check whether --with-curses was given.\n@@ -2331,22 +2373,10 @@ if test \"${with_curses+set}\" = set; then :\n fi\n \n \n-# Check whether --with-purify was given.\n-if test \"${with_purify+set}\" = set; then :\n-  withval=$with_purify; opt_purify=$withval\n-fi\n-\n-\n if test \"$opt_curses\" = \"yes\"; then\n \tprefer_curses=yes\n fi\n \n-if test \"$opt_purify\" = yes; then\n-\tPURIFY=\"purify\"\n-else\n-\tPURIFY=\n-fi\n-\n opt_multibyte=yes\n opt_static_libs=yes\n opt_shared_libs=no\n@@ -3819,8 +3849,9 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL}'\n \n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n-# Extract the first word of \"ar\", so it can be a program name with args.\n-set dummy ar; ac_word=$2\n+if test -n \"$ac_tool_prefix\"; then\n+  # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n+set dummy ${ac_tool_prefix}ar; ac_word=$2\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n $as_echo_n \"checking for $ac_word... \" >&6; }\n if ${ac_cv_prog_AR+:} false; then :\n@@ -3836,15 +3867,14 @@ do\n   test -z \"$as_dir\" && as_dir=.\n     for ac_exec_ext in '' $ac_executable_extensions; do\n   if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n-    ac_cv_prog_AR=\"\"\n+    ac_cv_prog_AR=\"${ac_tool_prefix}ar\"\n     $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n     break 2\n   fi\n done\n   done\n IFS=$as_save_IFS\n \n-  test -z \"$ac_cv_prog_AR\" && ac_cv_prog_AR=\"ar\"\n fi\n fi\n AR=$ac_cv_prog_AR\n@@ -3857,6 +3887,60 @@ $as_echo \"no\" >&6; }\n fi\n \n \n+fi\n+if test -z \"$ac_cv_prog_AR\"; then\n+  ac_ct_AR=$AR\n+  # Extract the first word of \"ar\", so it can be a program name with args.\n+set dummy ar; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if ${ac_cv_prog_ac_ct_AR+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$ac_ct_AR\"; then\n+  ac_cv_prog_ac_ct_AR=\"$ac_ct_AR\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if as_fn_executable_p \"$as_dir/$ac_word$ac_exec_ext\"; then\n+    ac_cv_prog_ac_ct_AR=\"ar\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+ac_ct_AR=$ac_cv_prog_ac_ct_AR\n+if test -n \"$ac_ct_AR\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR\" >&5\n+$as_echo \"$ac_ct_AR\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+  if test \"x$ac_ct_AR\" = x; then\n+    AR=\"\"\n+  else\n+    case $cross_compiling:$ac_tool_warned in\n+yes:)\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\n+$as_echo \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\n+ac_tool_warned=yes ;;\n+esac\n+    AR=$ac_ct_AR\n+  fi\n+else\n+  AR=\"$ac_cv_prog_AR\"\n+fi\n+\n test -n \"$ARFLAGS\" || ARFLAGS=\"cr\"\n if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n@@ -4490,7 +4574,7 @@ fi\n fi\n \n \n-for ac_func in fcntl kill lstat\n+for ac_func in fcntl kill lstat readlink\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\"\n@@ -4502,7 +4586,7 @@ _ACEOF\n fi\n done\n \n-for ac_func in memmove putenv select setenv setlocale \\\n+for ac_func in memmove pselect putenv select setenv setlocale \\\n \t\tstrcasecmp strpbrk tcgetattr vsnprintf\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n@@ -4540,6 +4624,101 @@ fi\n done\n \n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for uid_t in sys/types.h\" >&5\n+$as_echo_n \"checking for uid_t in sys/types.h... \" >&6; }\n+if ${ac_cv_type_uid_t+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+#include <sys/types.h>\n+\n+_ACEOF\n+if (eval \"$ac_cpp conftest.$ac_ext\") 2>&5 |\n+  $EGREP \"uid_t\" >/dev/null 2>&1; then :\n+  ac_cv_type_uid_t=yes\n+else\n+  ac_cv_type_uid_t=no\n+fi\n+rm -f conftest*\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_type_uid_t\" >&5\n+$as_echo \"$ac_cv_type_uid_t\" >&6; }\n+if test $ac_cv_type_uid_t = no; then\n+\n+$as_echo \"#define uid_t int\" >>confdefs.h\n+\n+\n+$as_echo \"#define gid_t int\" >>confdefs.h\n+\n+fi\n+\n+for ac_header in unistd.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"unistd.h\" \"ac_cv_header_unistd_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_unistd_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_UNISTD_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for working chown\" >&5\n+$as_echo_n \"checking for working chown... \" >&6; }\n+if ${ac_cv_func_chown_works+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test \"$cross_compiling\" = yes; then :\n+  ac_cv_func_chown_works=no\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+$ac_includes_default\n+#include <fcntl.h>\n+\n+int\n+main ()\n+{\n+  char *f = \"conftest.chown\";\n+  struct stat before, after;\n+\n+  if (creat (f, 0600) < 0)\n+    return 1;\n+  if (stat (f, &before) < 0)\n+    return 1;\n+  if (chown (f, (uid_t) -1, (gid_t) -1) == -1)\n+    return 1;\n+  if (stat (f, &after) < 0)\n+    return 1;\n+  return ! (before.st_uid == after.st_uid && before.st_gid == after.st_gid);\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  ac_cv_func_chown_works=yes\n+else\n+  ac_cv_func_chown_works=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+rm -f conftest.chown\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_func_chown_works\" >&5\n+$as_echo \"$ac_cv_func_chown_works\" >&6; }\n+if test $ac_cv_func_chown_works = yes; then\n+\n+$as_echo \"#define HAVE_CHOWN 1\" >>confdefs.h\n+\n+fi\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for working strcoll\" >&5\n $as_echo_n \"checking for working strcoll... \" >&6; }\n if ${ac_cv_func_strcoll_works+:} false; then :\n@@ -4580,7 +4759,8 @@ $as_echo \"#define HAVE_STRCOLL 1\" >>confdefs.h\n fi\n \n \n-for ac_header in fcntl.h unistd.h stdlib.h varargs.h stdarg.h string.h strings.h \\\n+for ac_header in fcntl.h unistd.h stdlib.h varargs.h stdarg.h stdbool.h \\\n+\t\tstring.h strings.h \\\n \t\tlimits.h locale.h pwd.h memory.h termcap.h termios.h termio.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n@@ -4594,7 +4774,7 @@ fi\n \n done\n \n-for ac_header in sys/pte.h sys/stream.h sys/select.h sys/file.h\n+for ac_header in sys/ioctl.h sys/pte.h sys/stream.h sys/select.h sys/file.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -5678,6 +5858,31 @@ $as_echo \"#define HAVE_STRUCT_DIRENT_D_FILENO 1\" >>confdefs.h\n fi\n \n \n+for ac_header in libaudit.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"libaudit.h\" \"ac_cv_header_libaudit_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_libaudit_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_LIBAUDIT_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+ac_fn_c_check_decl \"$LINENO\" \"AUDIT_USER_TTY\" \"ac_cv_have_decl_AUDIT_USER_TTY\" \"#include <linux/audit.h>\n+\"\n+if test \"x$ac_cv_have_decl_AUDIT_USER_TTY\" = xyes; then :\n+  ac_have_decl=1\n+else\n+  ac_have_decl=0\n+fi\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_AUDIT_USER_TTY $ac_have_decl\n+_ACEOF\n+\n+\n case \"$host_os\" in\n aix*)   prefer_curses=yes ;;\n esac\n@@ -5899,6 +6104,7 @@ if test \"$TERMCAP_LIB\" = \"./lib/termcap/libtermcap.a\"; then\n \t\tTERMCAP_LIB=-ltermcap\t#default\n \tfi\n fi\n+# Windows ncurses installation\n if test \"$TERMCAP_LIB\" = \"-lncurses\"; then\n \tfor ac_header in ncurses/termcap.h\n do :\n@@ -5952,6 +6158,19 @@ fi\n done\n \n \n+for ac_header in mbstr.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"mbstr.h\" \"ac_cv_header_mbstr_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_mbstr_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_MBSTR_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n+\n ac_fn_c_check_func \"$LINENO\" \"mbrlen\" \"ac_cv_func_mbrlen\"\n if test \"x$ac_cv_func_mbrlen\" = xyes; then :\n   $as_echo \"#define HAVE_MBRLEN 1\" >>confdefs.h\n@@ -5983,7 +6202,6 @@ if test \"x$ac_cv_func_mbsrtowcs\" = xyes; then :\n fi\n \n \n-\n ac_fn_c_check_func \"$LINENO\" \"mbschr\" \"ac_cv_func_mbschr\"\n if test \"x$ac_cv_func_mbschr\" = xyes; then :\n   $as_echo \"#define HAVE_MBSCHR 1\" >>confdefs.h\n@@ -6234,9 +6452,57 @@ $as_echo \"#define HAVE_WINT_T 1\" >>confdefs.h\n \n fi\n \n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for wcwidth broken with unicode combining characters\" >&5\n+$as_echo_n \"checking for wcwidth broken with unicode combining characters... \" >&6; }\n+if ${bash_cv_wcwidth_broken+:} false; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test \"$cross_compiling\" = yes; then :\n+  bash_cv_wcwidth_broken=no\n+else\n+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <locale.h>\n+#include <wchar.h>\n+\n+main(c, v)\n+int     c;\n+char    **v;\n+{\n+        int     w;\n+\n+        setlocale(LC_ALL, \"en_US.UTF-8\");\n+        w = wcwidth (0x0301);\n+        exit (w == 0);  /* exit 0 if wcwidth broken */\n+}\n+\n+_ACEOF\n+if ac_fn_c_try_run \"$LINENO\"; then :\n+  bash_cv_wcwidth_broken=yes\n+else\n+  bash_cv_wcwidth_broken=no\n+fi\n+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \\\n+  conftest.$ac_objext conftest.beam conftest.$ac_ext\n+fi\n+\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $bash_cv_wcwidth_broken\" >&5\n+$as_echo \"$bash_cv_wcwidth_broken\" >&6; }\n+if test \"$bash_cv_wcwidth_broken\" = yes; then\n+\n+$as_echo \"#define WCWIDTH_BROKEN 1\" >>confdefs.h\n+\n+fi\n+\n if test \"$am_cv_func_iconv\" = yes; then\n \tOLDLIBS=\"$LIBS\"\n-\tLIBS=\"$LIBS $LIBICONV\"\n+\tLIBS=\"$LIBS $LIBINTL $LIBICONV\"\n \tfor ac_func in locale_charset\n do :\n   ac_fn_c_check_func \"$LINENO\" \"locale_charset\" \"ac_cv_func_locale_charset\"\n@@ -6350,8 +6616,7 @@ esac\n \n \n \n-\n-ac_config_files=\"$ac_config_files Makefile doc/Makefile examples/Makefile shlib/Makefile\"\n+ac_config_files=\"$ac_config_files Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc\"\n \n ac_config_commands=\"$ac_config_commands default\"\n \n@@ -6861,7 +7126,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n # report actual input values of CONFIG_FILES etc. instead of their\n # values after options handling.\n ac_log=\"\n-This file was extended by readline $as_me 6.2, which was\n+This file was extended by readline $as_me 7.0, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   CONFIG_FILES    = $CONFIG_FILES\n@@ -6927,7 +7192,7 @@ _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n ac_cs_config=\"`$as_echo \"$ac_configure_args\" | sed 's/^ //; s/[\\\\\"\"\\`\\$]/\\\\\\\\&/g'`\"\n ac_cs_version=\"\\\\\n-readline config.status 6.2\n+readline config.status 7.0\n configured by $0, generated by GNU Autoconf 2.69,\n   with options \\\\\"\\$ac_cs_config\\\\\"\n \n@@ -7054,6 +7319,7 @@ do\n     \"doc/Makefile\") CONFIG_FILES=\"$CONFIG_FILES doc/Makefile\" ;;\n     \"examples/Makefile\") CONFIG_FILES=\"$CONFIG_FILES examples/Makefile\" ;;\n     \"shlib/Makefile\") CONFIG_FILES=\"$CONFIG_FILES shlib/Makefile\" ;;\n+    \"readline.pc\") CONFIG_FILES=\"$CONFIG_FILES readline.pc\" ;;\n     \"default\") CONFIG_COMMANDS=\"$CONFIG_COMMANDS default\" ;;\n \n   *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;"
    },
    {
      "sha": "f48257943f93d5c0231bd94a24c50d99af252a33",
      "filename": "readline/configure.ac",
      "status": "renamed",
      "additions": 16,
      "deletions": 19,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/configure.ac?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -5,7 +5,7 @@ dnl report bugs to chet@po.cwru.edu\n dnl\n dnl Process this file with autoconf to produce a configure script.\n \n-# Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+# Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n #   This program is free software: you can redistribute it and/or modify\n #   it under the terms of the GNU General Public License as published by\n@@ -20,11 +20,11 @@ dnl Process this file with autoconf to produce a configure script.\n #   You should have received a copy of the GNU General Public License\n #   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n-AC_REVISION([for Readline 6.2, version 2.67])\n+AC_REVISION([for Readline 7.0, version 2.81])\n \n m4_include([../config/override.m4])\n \n-AC_INIT(readline, 6.2, bug-readline@gnu.org)\n+AC_INIT(readline, 7.0, bug-readline@gnu.org)\n \n dnl make sure we are using a recent autoconf version\n AC_PREREQ(2.50)\n@@ -36,29 +36,21 @@ AC_CONFIG_AUX_DIR(`cd $srcdir;pwd`/..)\n AC_CONFIG_HEADERS(config.h)\n \n dnl update the value of RL_READLINE_VERSION in readline.h when this changes\n-LIBVERSION=6.2\n+LIBVERSION=7.0\n \n AC_CANONICAL_HOST\n AC_CANONICAL_BUILD\n \n dnl configure defaults\n opt_curses=no\n-opt_purify=no\n \n dnl arguments to configure\n AC_ARG_WITH(curses, AC_HELP_STRING([--with-curses], [use the curses library instead of the termcap library]), opt_curses=$withval)\n-AC_ARG_WITH(purify, AC_HELP_STRING([--with-purify], [configure to postprocess with purify]), opt_purify=$withval)\n \n if test \"$opt_curses\" = \"yes\"; then\n \tprefer_curses=yes\n fi\n \n-if test \"$opt_purify\" = yes; then\n-\tPURIFY=\"purify\"\n-else\n-\tPURIFY=\n-fi\n-\n dnl option parsing for optional features\n opt_multibyte=yes\n opt_static_libs=yes\n@@ -119,7 +111,7 @@ test -n \"$GCC\" && test -n \"$auto_cflags\" && CFLAGS=\"$CFLAGS -O\"\n \n AC_PROG_GCC_TRADITIONAL\n AC_PROG_INSTALL\n-AC_CHECK_PROG(AR, ar, , ar)\n+AC_CHECK_TOOL(AR, ar)\n dnl Set default for ARFLAGS, since autoconf does not have a macro for it.\n dnl This allows people to set it when running configure or make\n test -n \"$ARFLAGS\" || ARFLAGS=\"cr\"\n@@ -143,17 +135,19 @@ AC_HEADER_STDC\n AC_HEADER_STAT\n AC_HEADER_DIRENT\n \n-AC_CHECK_FUNCS(fcntl kill lstat)\n-AC_CHECK_FUNCS(memmove putenv select setenv setlocale \\\n+AC_CHECK_FUNCS(fcntl kill lstat readlink)\n+AC_CHECK_FUNCS(memmove pselect putenv select setenv setlocale \\\n \t\tstrcasecmp strpbrk tcgetattr vsnprintf)\n AC_CHECK_FUNCS(isascii isxdigit)\n AC_CHECK_FUNCS(getpwent getpwnam getpwuid)\n \n+AC_FUNC_CHOWN\n AC_FUNC_STRCOLL\n \n-AC_CHECK_HEADERS(fcntl.h unistd.h stdlib.h varargs.h stdarg.h string.h strings.h \\\n+AC_CHECK_HEADERS(fcntl.h unistd.h stdlib.h varargs.h stdarg.h stdbool.h \\\n+\t\tstring.h strings.h \\\n \t\tlimits.h locale.h pwd.h memory.h termcap.h termios.h termio.h)\n-AC_CHECK_HEADERS(sys/pte.h sys/stream.h sys/select.h sys/file.h)\n+AC_CHECK_HEADERS(sys/ioctl.h sys/pte.h sys/stream.h sys/select.h sys/file.h)\n \n AC_CHECK_HEADERS(sys/ptem.h,,,\n [[\n@@ -186,6 +180,9 @@ BASH_STRUCT_WINSIZE\n BASH_STRUCT_DIRENT_D_INO\n BASH_STRUCT_DIRENT_D_FILENO\n \n+AC_CHECK_HEADERS(libaudit.h)\n+AC_CHECK_DECLS([AUDIT_USER_TTY],,, [[#include <linux/audit.h>]])\n+\n dnl yuck\n case \"$host_os\" in\n aix*)   prefer_curses=yes ;;\n@@ -198,6 +195,7 @@ if test \"$TERMCAP_LIB\" = \"./lib/termcap/libtermcap.a\"; then\n \t\tTERMCAP_LIB=-ltermcap\t#default\n \tfi\n fi\n+# Windows ncurses installation\n if test \"$TERMCAP_LIB\" = \"-lncurses\"; then\n \tAC_CHECK_HEADERS(ncurses/termcap.h)\n fi\n@@ -282,7 +280,6 @@ case \"$BUILD_DIR\" in\n *)\t;;\n esac\n \n-AC_SUBST(PURIFY)\n AC_SUBST(BUILD_DIR)\n \n AC_SUBST(CFLAGS)\n@@ -300,7 +297,7 @@ AC_SUBST(LIBVERSION)\n \n AC_SUBST(TERMCAP_LIB)\n \n-AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile],\n+AC_OUTPUT([Makefile doc/Makefile examples/Makefile shlib/Makefile readline.pc],\n [\n # Makefile uses this timestamp file to record whether config.h is up to date.\n echo > stamp-h",
      "previous_filename": "readline/configure.in"
    },
    {
      "sha": "cfe816402a44ad832f05f351bfc904912feca74a",
      "filename": "readline/display.c",
      "status": "modified",
      "additions": 510,
      "deletions": 193,
      "changes": 703,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/display.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/display.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/display.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* display.c -- readline redisplay facility. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library    \n    for reading lines of text with interactive input and history editing.\n@@ -42,7 +42,7 @@\n #include <stdio.h>\n \n #ifdef __MSDOS__\n-# include <pc.h>\n+#  include <pc.h>\n #endif\n \n /* System-specific feature definitions and include files. */\n@@ -67,7 +67,14 @@ static void update_line PARAMS((char *, char *, int, int, int, int));\n static void space_to_eol PARAMS((int));\n static void delete_chars PARAMS((int));\n static void insert_some_chars PARAMS((char *, int, int));\n+static void open_some_spaces PARAMS((int));\n static void cr PARAMS((void));\n+static void redraw_prompt PARAMS((char *));\n+\n+/* Values for FLAGS */\n+#define PMT_MULTILINE\t0x01\n+\n+static char *expand_prompt PARAMS((char *, int, int *, int *, int *, int *));\n \n /* State of visible and invisible lines. */\n struct line_state\n@@ -76,8 +83,8 @@ struct line_state\n     int *lbreaks;\n     int lbsize;\n #if defined (HANDLE_MULTIBYTE)\n-    int *wrapped_line;\n     int wbsize;\n+    int *wrapped_line;\n #endif\n   };\n \n@@ -112,6 +119,8 @@ static int _rl_col_width PARAMS((const char *, int, int, int));\n    buffer index in others.  This macro is used when deciding whether the\n    current cursor position is in the middle of a prompt string containing\n    invisible characters.  XXX - might need to take `modmark' into account. */\n+/* XXX - only valid when tested against _rl_last_c_pos; buffer indices need\n+   to use prompt_last_invisible directly. */\n #define PROMPT_ENDING_INDEX \\\n   ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) ? prompt_physical_chars : prompt_last_invisible+1)\n   \n@@ -157,6 +166,16 @@ int _rl_want_redisplay = 0;\n    This is usually pointing to rl_prompt. */\n char *rl_display_prompt = (char *)NULL;\n \n+/* Variables used to include the editing mode in the prompt. */\n+char *_rl_emacs_mode_str;\n+int _rl_emacs_modestr_len;\n+\n+char *_rl_vi_ins_mode_str;\n+int _rl_vi_ins_modestr_len;\n+\n+char *_rl_vi_cmd_mode_str;\n+int _rl_vi_cmd_modestr_len;\n+\n /* Pseudo-global variables declared here. */\n \n /* The visible cursor position.  If you print some text, adjust this. */\n@@ -169,18 +188,22 @@ int _rl_last_v_pos = 0;\n \n static int cpos_adjusted;\n static int cpos_buffer_position;\n+static int displaying_prompt_first_line;\n static int prompt_multibyte_chars;\n \n /* Number of lines currently on screen minus 1. */\n int _rl_vis_botlin = 0;\n \n+static int _rl_inv_botlin = 0;\n+\n /* Variables used only in this file. */\n /* The last left edge of text that was displayed.  This is used when\n    doing horizontal scrolling.  It shifts in thirds of a screenwidth. */\n static int last_lmargin;\n \n /* A buffer for `modeline' messages. */\n-static char msg_buf[128];\n+static char *msg_buf = 0;\n+static int msg_bufsiz = 0;\n \n /* Non-zero forces the redisplay even if we thought it was unnecessary. */\n static int forced_display;\n@@ -236,6 +259,32 @@ static int saved_local_length;\n static int saved_invis_chars_first_line;\n static int saved_physical_chars;\n \n+/* Return a string indicating the editing mode, for use in the prompt. */\n+\n+static char *\n+prompt_modestr (lenp)\n+     int *lenp;\n+{\n+  if (rl_editing_mode == emacs_mode)\n+    {\n+      if (lenp)\n+\t*lenp = _rl_emacs_mode_str ? _rl_emacs_modestr_len : RL_EMACS_MODESTR_DEFLEN;\n+      return _rl_emacs_mode_str ? _rl_emacs_mode_str : RL_EMACS_MODESTR_DEFAULT;\n+    }\n+  else if (_rl_keymap == vi_insertion_keymap)\n+    {\n+      if (lenp)\n+\t*lenp = _rl_vi_ins_mode_str ? _rl_vi_ins_modestr_len : RL_VI_INS_MODESTR_DEFLEN;\n+      return _rl_vi_ins_mode_str ? _rl_vi_ins_mode_str : RL_VI_INS_MODESTR_DEFAULT;\t\t/* vi insert mode */\n+    }\n+  else\n+    {\n+      if (lenp)\n+\t*lenp = _rl_vi_cmd_mode_str ? _rl_vi_cmd_modestr_len : RL_VI_CMD_MODESTR_DEFLEN;\n+      return _rl_vi_cmd_mode_str ? _rl_vi_cmd_mode_str : RL_VI_CMD_MODESTR_DEFAULT;\t\t/* vi command mode */\n+    }\n+}\n+\n /* Expand the prompt string S and return the number of visible\n    characters in *LP, if LP is not null.  This is currently more-or-less\n    a placeholder for expansion.  LIP, if non-null is a place to store the\n@@ -251,18 +300,38 @@ static int saved_physical_chars;\n    the returned string; all characters except those between \\001 and\n    \\002 are assumed to be `visible'. */\t\n \n+/* Possible values for FLAGS:\n+\tPMT_MULTILINE\tcaller indicates that this is part of a multiline prompt\n+*/\n+\n static char *\n-expand_prompt (pmt, lp, lip, niflp, vlp)\n+expand_prompt (pmt, flags, lp, lip, niflp, vlp)\n      char *pmt;\n+     int flags;\n      int *lp, *lip, *niflp, *vlp;\n {\n-  char *r, *ret, *p, *igstart;\n+  char *r, *ret, *p, *igstart, *nprompt, *ms;\n   int l, rl, last, ignoring, ninvis, invfl, invflset, ind, pind, physchars;\n+  int mlen;\n+\n+  /* We only expand the mode string for the last line of a multiline prompt\n+     (a prompt with embedded newlines). */\n+  ms = (((pmt == rl_prompt) ^ (flags & PMT_MULTILINE)) && _rl_show_mode_in_prompt) ? prompt_modestr (&mlen) : 0;\n+  if (ms)\n+    {\n+      l = strlen (pmt);\n+      nprompt = (char *)xmalloc (l + mlen + 1);\n+      memcpy (nprompt, ms, mlen);\n+      strcpy (nprompt + mlen, pmt);\n+    }\n+  else\n+    nprompt = pmt;\n \n   /* Short-circuit if we can. */\n-  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (pmt, RL_PROMPT_START_IGNORE) == 0)\n+  if ((MB_CUR_MAX <= 1 || rl_byte_oriented) && strchr (nprompt, RL_PROMPT_START_IGNORE) == 0)\n     {\n-      r = savestring (pmt);\n+      r = (nprompt == pmt) ? savestring (pmt) : nprompt;\n+\n       if (lp)\n \t*lp = strlen (r);\n       if (lip)\n@@ -274,14 +343,15 @@ expand_prompt (pmt, lp, lip, niflp, vlp)\n       return r;\n     }\n \n-  l = strlen (pmt);\n+  l = strlen (nprompt);\t\t\t/* XXX */\n   r = ret = (char *)xmalloc (l + 1);\n \n+  rl = physchars = 0;\t/* mode string now part of nprompt */\n   invfl = 0;\t/* invisible chars in first line of prompt */\n   invflset = 0;\t/* we only want to set invfl once */\n-\n   igstart = 0;\n-  for (rl = ignoring = last = ninvis = physchars = 0, p = pmt; p && *p; p++)\n+\n+  for (ignoring = last = ninvis = 0, p = nprompt; p && *p; p++)\n     {\n       /* This code strips the invisible character string markers\n \t RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */\n@@ -303,8 +373,8 @@ expand_prompt (pmt, lp, lip, niflp, vlp)\n #if defined (HANDLE_MULTIBYTE)\n \t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \t    {\n-\t      pind = p - pmt;\n-\t      ind = _rl_find_next_mbchar (pmt, pind, 1, MB_FIND_NONZERO);\n+\t      pind = p - nprompt;\n+\t      ind = _rl_find_next_mbchar (nprompt, pind, 1, MB_FIND_NONZERO);\n \t      l = ind - pind;\n \t      while (l--)\n \t        *r++ = *p++;\n@@ -316,7 +386,7 @@ expand_prompt (pmt, lp, lip, niflp, vlp)\n \t\t     not be the same as the number of physical characters\n \t\t     on the screen in the presence of multibyte characters */\n \t\t  rl += ind - pind;\n-\t\t  physchars += _rl_col_width (pmt, pind, ind, 0);\n+\t\t  physchars += _rl_col_width (nprompt, pind, ind, 0);\n \t\t}\n \t      else\n \t\tninvis += ind - pind;\n@@ -355,6 +425,10 @@ expand_prompt (pmt, lp, lip, niflp, vlp)\n     *niflp = invfl;\n   if  (vlp)\n     *vlp = physchars;\n+\n+  if (nprompt != pmt)\n+    free (nprompt);\n+\n   return ret;\n }\n \n@@ -366,10 +440,16 @@ _rl_strip_prompt (pmt)\n {\n   char *ret;\n \n-  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);\n+  ret = expand_prompt (pmt, 0, (int *)NULL, (int *)NULL, (int *)NULL, (int *)NULL);\n   return ret;\n }\n \n+void\n+_rl_reset_prompt ()\n+{\n+  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);\n+}\n+\n /*\n  * Expand the prompt string into the various display components, if\n  * necessary.\n@@ -407,13 +487,13 @@ rl_expand_prompt (prompt)\n     return (0);\n \n   p = strrchr (prompt, '\\n');\n-  if (!p)\n+  if (p == 0)\n     {\n       /* The prompt is only one logical line, though it might wrap. */\n-      local_prompt = expand_prompt (prompt, &prompt_visible_length,\n-\t\t\t\t\t    &prompt_last_invisible,\n-\t\t\t\t\t    &prompt_invis_chars_first_line,\n-\t\t\t\t\t    &prompt_physical_chars);\n+      local_prompt = expand_prompt (prompt, 0, &prompt_visible_length,\n+\t\t\t\t\t       &prompt_last_invisible,\n+\t\t\t\t\t       &prompt_invis_chars_first_line,\n+\t\t\t\t\t       &prompt_physical_chars);\n       local_prompt_prefix = (char *)0;\n       local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n       return (prompt_visible_length);\n@@ -422,14 +502,16 @@ rl_expand_prompt (prompt)\n     {\n       /* The prompt spans multiple lines. */\n       t = ++p;\n-      local_prompt = expand_prompt (p, &prompt_visible_length,\n+      local_prompt = expand_prompt (p, PMT_MULTILINE,\n+\t\t\t\t       &prompt_visible_length,\n \t\t\t\t       &prompt_last_invisible,\n \t\t\t\t       &prompt_invis_chars_first_line,\n \t\t\t\t       &prompt_physical_chars);\n       c = *t; *t = '\\0';\n       /* The portion of the prompt string up to and including the\n \t final newline is now null-terminated. */\n-      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,\n+      local_prompt_prefix = expand_prompt (prompt, PMT_MULTILINE,\n+\t\t\t\t\t\t   &prompt_prefix_length,\n \t\t\t\t\t\t   (int *)NULL,\n \t\t\t\t\t\t   (int *)NULL,\n \t\t\t\t\t\t   (int *)NULL);\n@@ -505,6 +587,7 @@ rl_redisplay ()\n   int inv_botlin, lb_botlin, lb_linenum, o_cpos;\n   int newlines, lpos, temp, n0, num, prompt_lines_estimate;\n   char *prompt_this_line;\n+  int mb_cur_max = MB_CUR_MAX;\n #if defined (HANDLE_MULTIBYTE)\n   wchar_t wc;\n   size_t wc_bytes;\n@@ -663,6 +746,8 @@ rl_redisplay ()\n \n   /* inv_lbreaks[i] is where line i starts in the buffer. */\n   inv_lbreaks[newlines = 0] = 0;\n+  /* lpos is a physical cursor position, so it needs to be adjusted by the\n+     number of invisible characters in the prompt, per line */\n   lpos = prompt_physical_chars + modmark;\n \n #if defined (HANDLE_MULTIBYTE)\n@@ -682,7 +767,19 @@ rl_redisplay ()\n      contents of the command line? */\n   while (lpos >= _rl_screenwidth)\n     {\n-      int z;\n+      int z, p;\n+      int nocorrect, wadjust;\n+\n+      nocorrect = 0;\n+      /* Adjust depending on the invisible characters in the line.  We use a\n+\t heuristic based on experience: invisible characters nearly always\n+\t appear in the first and last lines of the prompt */\n+      wadjust = (newlines == 0)\n+\t\t  ? prompt_invis_chars_first_line\n+\t\t  : ((newlines == prompt_lines_estimate)\n+\t\t  \t? (wrap_offset - prompt_invis_chars_first_line)\n+\t\t  \t: 0);\n+\n       /* fix from Darin Johnson <darin@acuson.com> for prompt string with\n          invisible characters that is longer than the screen width.  The\n          prompt_invis_chars_first_line variable could be made into an array\n@@ -691,20 +788,31 @@ rl_redisplay ()\n          prompts that exceed two physical lines?\n          Additional logic fix from Edward Catmur <ed@catmur.co.uk> */\n #if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n \t{\n+\t  nocorrect = 1;\n \t  n0 = num;\n           temp = local_prompt_len;\n           while (num < temp)\n \t    {\n-\t      z = _rl_col_width  (local_prompt, n0, num, 1);\n+\t      /* This has to take invisible characters in the prompt into\n+\t\t account. */\n+\t      z = _rl_col_width  (local_prompt, n0, num, 1) - wadjust;\n \t      if (z > _rl_screenwidth)\n \t\t{\n \t          num = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n \t          break;\n \t\t}\n \t      else if (z == _rl_screenwidth)\n-\t        break;\n+\t\t{\n+\t\t  /* If we are in the middle or at the end of a multibyte\n+\t\t     character, we want to move to the start, then find out\n+\t\t     where it ends so we know where to insert the newline.\n+\t\t     If this isn't a multibyte character, its the same as num++ */\n+\t\t  p = _rl_find_prev_mbchar (local_prompt, num, MB_FIND_ANY);\n+\t\t  num = _rl_find_next_mbchar (local_prompt, p, 1, MB_FIND_ANY);\n+\t\t  break;\n+\t\t}\n \t      num++;\n \t    }\n           temp = num;\n@@ -716,17 +824,18 @@ rl_redisplay ()\n       /* Now account for invisible characters in the current line. */\n       /* XXX - this assumes that the invisible characters may be split, but only\n \t between the first and the last lines. */\n-      temp += ((local_prompt_prefix == 0) ? ((newlines == 0) ? prompt_invis_chars_first_line\n-\t\t\t\t\t\t\t     : ((newlines == prompt_lines_estimate) ? wrap_offset : prompt_invis_chars_first_line))\n-\t\t\t\t\t  : ((newlines == 0) ? wrap_offset : 0));\n-             \n+      if (nocorrect == 0)\n+\ttemp += wadjust;\n+\n       inv_lbreaks[++newlines] = temp;\n #if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n-\tlpos -= _rl_col_width (local_prompt, n0, num, 1);\n+      /* lpos is a physical cursor position, so it needs to take the invisible\n+\t characters into account. */\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0 && prompt_multibyte_chars > 0)\n+\tlpos -= _rl_col_width (local_prompt, n0, num, 1) - wadjust;\n       else\n #endif\n-\tlpos -= _rl_screenwidth;\n+\tlpos -= _rl_screenwidth;\t/* all physical cursor positions */\n     }\n \n   prompt_last_screen_line = newlines;\n@@ -739,7 +848,7 @@ rl_redisplay ()\n   lb_linenum = 0;\n #if defined (HANDLE_MULTIBYTE)\n   in = 0;\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       memset (&ps, 0, sizeof (mbstate_t));\n       /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n@@ -755,7 +864,7 @@ rl_redisplay ()\n       c = (unsigned char)rl_line_buffer[in];\n \n #if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  if (MB_INVALIDCH (wc_bytes))\n \t    {\n@@ -770,7 +879,7 @@ rl_redisplay ()\n \t    break;\t\t\t/* Found '\\0' */\n \t  else\n \t    {\n-\t      temp = wcwidth (wc);\n+\t      temp = WCWIDTH (wc);\n \t      wc_width = (temp >= 0) ? temp : 1;\n \t    }\n \t}\n@@ -864,7 +973,7 @@ rl_redisplay ()\n       else\n \t{\n #if defined (HANDLE_MULTIBYTE)\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    {\n \t      register int i;\n \n@@ -900,7 +1009,7 @@ rl_redisplay ()\n \t}\n \n #if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  in += wc_bytes;\n \t  /* XXX - what if wc_bytes ends up <= 0? check for MB_INVALIDCH */\n@@ -918,7 +1027,7 @@ rl_redisplay ()\n       lb_linenum = newlines;\n     }\n \n-  inv_botlin = lb_botlin = newlines;\n+  inv_botlin = lb_botlin = _rl_inv_botlin = newlines;\n   CHECK_INV_LBREAKS ();\n   inv_lbreaks[newlines+1] = out;\n   cursor_linenum = lb_linenum;\n@@ -934,7 +1043,7 @@ rl_redisplay ()\n   /* If we can move the cursor up and down, then use multiple lines,\n      otherwise, let long lines display in a single terminal line, and\n      horizontally scroll it. */\n-\n+  displaying_prompt_first_line = 1;\n   if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)\n     {\n       int nleft, pos, changed_screen_line, tx;\n@@ -948,9 +1057,11 @@ rl_redisplay ()\n \t     not the first.  */\n \t  if (out >= _rl_screenchars)\n \t    {\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+#if defined (HANDLE_MULTIBYTE)\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\tout = _rl_find_prev_mbchar (line, _rl_screenchars, MB_FIND_ANY);\n \t      else\n+#endif\n \t\tout = _rl_screenchars - 1;\n \t    }\n \n@@ -996,15 +1107,15 @@ rl_redisplay ()\n \t\t time update_line is called, then we can assume in our\n \t\t calculations that o_cpos does not need to be adjusted by\n \t\t wrap_offset. */\n-\t      if (linenum == 0 && (MB_CUR_MAX > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n+\t      if (linenum == 0 && (mb_cur_max > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n \t\t_rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n \t      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&\n-\t\t\t(MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&\n+\t\t\t(mb_cur_max > 1 && rl_byte_oriented == 0) &&\n \t\t\tcpos_adjusted == 0 &&\n \t\t\t_rl_last_c_pos != o_cpos &&\n \t\t\t_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))\n \t\t_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);\n-\t\t  \n+\n \t      /* If this is the line with the prompt, we might need to\n \t\t compensate for invisible characters in the new line. Do\n \t\t this only if there is not more than one new line (which\n@@ -1016,7 +1127,7 @@ rl_redisplay ()\n \t\t  (wrap_offset > visible_wrap_offset) &&\n \t\t  (_rl_last_c_pos < visible_first_line_len))\n \t\t{\n-\t\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\t    nleft = _rl_screenwidth - _rl_last_c_pos;\n \t\t  else\n \t\t    nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;\n@@ -1068,7 +1179,7 @@ rl_redisplay ()\n \t\t the physical cursor position on the screen stays the same,\n \t\t but the buffer position needs to be adjusted to account\n \t\t for invisible characters. */\n-\t      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)\n+\t      if ((mb_cur_max == 1 || rl_byte_oriented) && cursor_linenum == 0 && wrap_offset)\n \t\t_rl_last_c_pos += wrap_offset;\n \t    }\n \n@@ -1095,7 +1206,7 @@ rl_redisplay ()\n \t\t_rl_output_some_chars (\"*\", 1);\n \n \t      _rl_output_some_chars (local_prompt, nleft);\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\t_rl_last_c_pos = _rl_col_width (local_prompt, 0, nleft, 1) - wrap_offset + modmark;\n \t      else\n \t\t_rl_last_c_pos = nleft + modmark;\n@@ -1119,7 +1230,7 @@ rl_redisplay ()\n \t  if (wrap_offset && cursor_linenum == 0 && nleft < _rl_last_c_pos)\n \t    {\n \t      /* TX == new physical cursor position in multibyte locale. */\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\ttx = _rl_col_width (&visible_line[pos], 0, nleft, 1) - visible_wrap_offset;\n \t      else\n \t\ttx = nleft;\n@@ -1134,7 +1245,7 @@ rl_redisplay ()\n \t     _rl_last_c_pos as an absolute cursor position, but moving to a\n \t     point specified by a buffer position (NLEFT) that doesn't take\n \t     invisible characters into account. */\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n \t  else if (nleft != _rl_last_c_pos)\n \t    _rl_move_cursor_relative (nleft, &invisible_line[pos]);\n@@ -1188,6 +1299,8 @@ rl_redisplay ()\n       else\n \tlmargin = last_lmargin;\n \n+      displaying_prompt_first_line = lmargin < nleft;\n+\n       /* If the first character on the screen isn't the first character\n \t in the display line, indicate this with a special character. */\n       if (lmargin > 0)\n@@ -1213,15 +1326,16 @@ rl_redisplay ()\n \t\t       _rl_screenwidth + (lmargin ? 0 : wrap_offset),\n \t\t       0);\n \n-\t  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && OLD_CPOS_IN_PROMPT())\n+\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n+\t\tdisplaying_prompt_first_line && OLD_CPOS_IN_PROMPT())\n \t    _rl_last_c_pos -= prompt_invis_chars_first_line;\t/* XXX - was wrap_offset */\n \n \t  /* If the visible new line is shorter than the old, but the number\n \t     of invisible characters is greater, and we are at the end of\n \t     the new line, we need to clear to eol. */\n \t  t = _rl_last_c_pos - M_OFFSET (lmargin, wrap_offset);\n \t  if ((M_OFFSET (lmargin, wrap_offset) > visible_wrap_offset) &&\n-\t      (_rl_last_c_pos == out) &&\n+\t      (_rl_last_c_pos == out) && displaying_prompt_first_line &&\n \t      t < visible_first_line_len)\n \t    {\n \t      nleft = _rl_screenwidth - t;\n@@ -1283,6 +1397,8 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n   int temp, lendiff, wsatend, od, nd, twidth, o_cpos;\n   int current_invis_chars;\n   int col_lendiff, col_temp;\n+  int bytes_to_insert;\n+  int mb_cur_max = MB_CUR_MAX;\n #if defined (HANDLE_MULTIBYTE)\n   mbstate_t ps_new, ps_old;\n   int new_offset, old_offset;\n@@ -1293,29 +1409,29 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n      the exact cursor position and cut-and-paste with certain terminal\n      emulators.  In this calculation, TEMP is the physical screen\n      position of the cursor. */\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     temp = _rl_last_c_pos;\n   else\n     temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);\n   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode\n \t&& _rl_last_v_pos == current_line - 1)\n     {\n #if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  wchar_t wc;\n \t  mbstate_t ps;\n \t  int tempwidth, bytes;\n \t  size_t ret;\n \n \t  /* This fixes only double-column characters, but if the wrapped\n-\t     character comsumes more than three columns, spaces will be\n+\t     character consumes more than three columns, spaces will be\n \t     inserted in the string buffer. */\n \t  if (current_line < line_state_visible->wbsize && line_state_visible->wrapped_line[current_line] > 0)\n \t    _rl_clear_to_eol (line_state_visible->wrapped_line[current_line]);\n \n \t  memset (&ps, 0, sizeof (mbstate_t));\n-\t  ret = mbrtowc (&wc, new, MB_CUR_MAX, &ps);\n+\t  ret = mbrtowc (&wc, new, mb_cur_max, &ps);\n \t  if (MB_INVALIDCH (ret))\n \t    {\n \t      tempwidth = 1;\n@@ -1324,7 +1440,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t  else if (MB_NULLWCH (ret))\n \t    tempwidth = 0;\n \t  else\n-\t    tempwidth = wcwidth (wc);\n+\t    tempwidth = WCWIDTH (wc);\n \n \t  if (tempwidth > 0)\n \t    {\n@@ -1335,7 +1451,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t      _rl_last_c_pos = tempwidth;\n \t      _rl_last_v_pos++;\n \t      memset (&ps, 0, sizeof (mbstate_t));\n-\t      ret = mbrtowc (&wc, old, MB_CUR_MAX, &ps);\n+\t      ret = mbrtowc (&wc, old, mb_cur_max, &ps);\n \t      if (ret != 0 && bytes != 0)\n \t\t{\n \t\t  if (MB_INVALIDCH (ret))\n@@ -1344,7 +1460,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t  memcpy (old, new, bytes);\n \t\t  /* Fix up indices if we copy data from one line to another */\n \t\t  omax += bytes - ret;\n-\t\t  for (i = current_line+1; i < inv_botlin+1; i++)\n+\t\t  for (i = current_line+1; i <= inv_botlin+1; i++)\n \t\t    vis_lbreaks[i] += bytes - ret;\n \t\t}\n \t    }\n@@ -1374,13 +1490,14 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n       \n   /* Find first difference. */\n #if defined (HANDLE_MULTIBYTE)\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       /* See if the old line is a subset of the new line, so that the\n \t only change is adding characters. */\n       temp = (omax < nmax) ? omax : nmax;\n       if (memcmp (old, new, temp) == 0)\t\t/* adding at the end */\n \t{\n+\t  new_offset = old_offset = temp;\n \t  ofd = old + temp;\n \t  nfd = new + temp;\n \t}\n@@ -1391,6 +1508,8 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \n \t  if (omax == nmax && STREQN (new, old, omax))\n \t    {\n+\t      old_offset = omax;\n+\t      new_offset = nmax;\n \t      ofd = old + omax;\n \t      nfd = new + nmax;\n \t    }\n@@ -1403,6 +1522,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t{\n \t\t  old_offset = _rl_find_next_mbchar (old, old_offset, 1, MB_FIND_ANY);\n \t\t  new_offset = _rl_find_next_mbchar (new, new_offset, 1, MB_FIND_ANY);\n+\n \t\t  ofd = old + old_offset;\n \t\t  nfd = new + new_offset;\n \t\t}\n@@ -1426,13 +1546,35 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n   if (ofd == oe && nfd == ne)\n     return;\n \n+#if defined (HANDLE_MULTIBYTE)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0 && _rl_utf8locale)\n+    {\n+      wchar_t wc;\n+      mbstate_t ps = { 0 };\n+      int t;\n+\n+      /* If the first character in the difference is a zero-width character,\n+\t assume it's a combining character and back one up so the two base\n+\t characters no longer compare equivalently. */\n+      t = mbrtowc (&wc, ofd, mb_cur_max, &ps);\n+      if (t > 0 && UNICODE_COMBINING_CHAR (wc) && WCWIDTH (wc) == 0)\n+\t{\n+\t  old_offset = _rl_find_prev_mbchar (old, ofd - old, MB_FIND_ANY);\n+\t  new_offset = _rl_find_prev_mbchar (new, nfd - new, MB_FIND_ANY);\n+\t  ofd = old + old_offset;\t/* equal by definition */\n+\t  nfd = new + new_offset;\n+\t}\n+    }\n+#endif\n+\n   wsatend = 1;\t\t\t/* flag for trailing whitespace */\n \n #if defined (HANDLE_MULTIBYTE)\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       ols = old + _rl_find_prev_mbchar (old, oe - old, MB_FIND_ANY);\n       nls = new + _rl_find_prev_mbchar (new, ne - new, MB_FIND_ANY);\n+\n       while ((ols > ofd) && (nls > nfd))\n \t{\n \t  memset (&ps_old, 0, sizeof (mbstate_t));\n@@ -1486,14 +1628,14 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n     {\n       if (*ols)\t\t\t/* don't step past the NUL */\n \t{\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    ols = old + _rl_find_next_mbchar (old, ols - old, 1, MB_FIND_ANY);\n \t  else\n \t    ols++;\n \t}\n       if (*nls)\n \t{\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    nls = new + _rl_find_next_mbchar (new, nls - new, 1, MB_FIND_ANY);\n \t  else\n \t    nls++;\n@@ -1505,7 +1647,12 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n   if (_rl_last_v_pos != current_line)\n     {\n       _rl_move_vert (current_line);\n-      if ((MB_CUR_MAX == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)\n+      /* We have moved up to a new screen line.  This line may or may not have\n+         invisible characters on it, but we do our best to recalculate\n+         visible_wrap_offset based on what we know. */\n+      if (current_line == 0)\n+\tvisible_wrap_offset = prompt_invis_chars_first_line;\t/* XXX */\n+      if ((mb_cur_max == 1 || rl_byte_oriented) && current_line == 0 && visible_wrap_offset)\n \t_rl_last_c_pos += visible_wrap_offset;\n     }\n \n@@ -1516,16 +1663,31 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n      string, then redraw the entire prompt string.  We can only do this\n      reliably if the terminal supports a `cr' capability.\n \n+     This can also happen if the prompt string has changed, and the first\n+     difference in the line is in the middle of the prompt string, after a\n+     sequence of invisible characters (worst case) and before the end of\n+     the prompt.  In this case, we have to redraw the entire prompt string\n+     so that the entire sequence of invisible characters is drawn.  We need\n+     to handle the worst case, when the difference is after (or in the middle\n+     of) a sequence of invisible characters that changes the text color and\n+     before the sequence that restores the text color to normal.  Then we have\n+     to make sure that the lines still differ -- if they don't, we can\n+     return immediately.\n+\n      This is not an efficiency hack -- there is a problem with redrawing\n      portions of the prompt string if they contain terminal escape\n      sequences (like drawing the `unbold' sequence without a corresponding\n      `bold') that manifests itself on certain terminals. */\n \n   lendiff = local_prompt_len;\n+  if (lendiff > nmax)\n+    lendiff = nmax;\n   od = ofd - old;\t/* index of first difference in visible line */\n+  nd = nfd - new;\t/* nd, od are buffer indexes */\n   if (current_line == 0 && !_rl_horizontal_scroll_mode &&\n       _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&\n-      od >= lendiff && _rl_last_c_pos < PROMPT_ENDING_INDEX)\n+      (((od > 0 || nd > 0) && (od <= prompt_last_invisible || nd <= prompt_last_invisible)) ||\n+\t\t((od >= lendiff) && _rl_last_c_pos < PROMPT_ENDING_INDEX)))\n     {\n #if defined (__MSDOS__)\n       putc ('\\r', rl_outstream);\n@@ -1535,7 +1697,7 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n       if (modmark)\n \t_rl_output_some_chars (\"*\", 1);\n       _rl_output_some_chars (local_prompt, lendiff);\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  /* We take wrap_offset into account here so we can pass correct\n \t     information to _rl_move_cursor_relative. */\n@@ -1544,43 +1706,79 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t}\n       else\n \t_rl_last_c_pos = lendiff + modmark;\n+\n+      /* Now if we have printed the prompt string because the first difference\n+\t was within the prompt, see if we need to recompute where the lines\n+\t differ.  Check whether where we are now is past the last place where\n+\t the old and new lines are the same and short-circuit now if we are. */\n+      if ((od <= prompt_last_invisible || nd <= prompt_last_invisible) &&\n+          omax == nmax &&\n+\t  lendiff > (ols-old) && lendiff > (nls-new))\n+\treturn;\n+\n+      /* XXX - we need to fix up our calculations if we are now past the\n+\t old ofd/nfd and the prompt length (or line length) has changed.\n+\t We punt on the problem and do a dumb update.  We'd like to be able\n+\t to just output the prompt from the beginning of the line up to the\n+\t first difference, but you don't know the number of invisible\n+\t characters in that case.\n+\t This needs a lot of work to be efficient. */\n+      if ((od <= prompt_last_invisible || nd <= prompt_last_invisible))\n+\t{\n+\t  nfd = new + lendiff;\t/* number of characters we output above */\n+\t  nd = lendiff;\n+\n+\t  /* Do a dumb update and return */\n+\t  temp = ne - nfd;\n+\t  if (temp > 0)\n+\t    {\n+\t      _rl_output_some_chars (nfd, temp);\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n+\t\t_rl_last_c_pos += _rl_col_width (new, nd, ne - new, 1);\n+\t      else\n+\t\t_rl_last_c_pos += temp;\n+\t    }\n+\t  if (nmax < omax)\n+\t    goto clear_rest_of_line;\t/* XXX */\n+\t  else\n+\t    return;\n+\t}\n     }\n \n   o_cpos = _rl_last_c_pos;\n \n   /* When this function returns, _rl_last_c_pos is correct, and an absolute\n-     cursor postion in multibyte mode, but a buffer index when not in a\n+     cursor position in multibyte mode, but a buffer index when not in a\n      multibyte locale. */\n   _rl_move_cursor_relative (od, old);\n-#if 1\n+\n #if defined (HANDLE_MULTIBYTE)\n   /* We need to indicate that the cursor position is correct in the presence of\n      invisible characters in the prompt string.  Let's see if setting this when\n      we make sure we're at the end of the drawn prompt string works. */\n-  if (current_line == 0 && MB_CUR_MAX > 1 && rl_byte_oriented == 0 &&\n+  if (current_line == 0 && mb_cur_max > 1 && rl_byte_oriented == 0 &&\n       (_rl_last_c_pos > 0 || o_cpos > 0) &&\n       _rl_last_c_pos == prompt_physical_chars)\n     cpos_adjusted = 1;\n-#endif\n #endif\n \n   /* if (len (new) > len (old))\n-     lendiff == difference in buffer\n-     col_lendiff == difference on screen\n+     lendiff == difference in buffer (bytes)\n+     col_lendiff == difference on screen (columns)\n      When not using multibyte characters, these are equal */\n   lendiff = (nls - nfd) - (ols - ofd);\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     col_lendiff = _rl_col_width (new, nfd - new, nls - new, 1) - _rl_col_width (old, ofd - old, ols - old, 1);\n   else\n     col_lendiff = lendiff;\n \n   /* If we are changing the number of invisible characters in a line, and\n      the spot of first difference is before the end of the invisible chars,\n      lendiff needs to be adjusted. */\n-  if (current_line == 0 && !_rl_horizontal_scroll_mode &&\n+  if (current_line == 0 && /* !_rl_horizontal_scroll_mode && */\n       current_invis_chars != visible_wrap_offset)\n     {\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  lendiff += visible_wrap_offset - current_invis_chars;\n \t  col_lendiff += visible_wrap_offset - current_invis_chars;\n@@ -1592,13 +1790,21 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t}\n     }\n \n+  /* We use temp as a count of the number of bytes from the first difference\n+     to the end of the new line.  col_temp is the corresponding number of\n+     screen columns.  A `dumb' update moves to the spot of first difference\n+     and writes TEMP bytes. */\n   /* Insert (diff (len (old), len (new)) ch. */\n   temp = ne - nfd;\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     col_temp = _rl_col_width (new, nfd - new, ne - new, 1);\n   else\n     col_temp = temp;\n \n+  /* how many bytes from the new line buffer to write to the display */\n+  bytes_to_insert = nls - nfd;\n+\n+  /* col_lendiff > 0 if we are adding characters to the line */\n   if (col_lendiff > 0)\t/* XXX - was lendiff */\n     {\n       /* Non-zero if we're increasing the number of lines. */\n@@ -1612,11 +1818,11 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n       if (lendiff < 0)\n \t{\n \t  _rl_output_some_chars (nfd, temp);\n-\t  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);\n+\t  _rl_last_c_pos += col_temp;\t/* XXX - was _rl_col_width (nfd, 0, temp, 1); */\n \t  /* If nfd begins before any invisible characters in the prompt,\n \t     adjust _rl_last_c_pos to account for wrap_offset and set\n \t     cpos_adjusted to let the caller know. */\n-\t  if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n+\t  if (current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t    {\n \t      _rl_last_c_pos -= wrap_offset;\n \t      cpos_adjusted = 1;\n@@ -1641,63 +1847,48 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t\t_rl_last_c_pos == 0 &&\n \t\t\tlendiff > prompt_visible_length &&\n \t\t\tcurrent_invis_chars > 0) == 0) &&\n-\t\t      (((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&\n+\t\t      (((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n \t\t        current_line == 0 && wrap_offset &&\n \t\t        ((nfd - new) <= prompt_last_invisible) &&\n \t\t        (col_lendiff < prompt_visible_length)) == 0) &&\n \t\t      (visible_wrap_offset >= current_invis_chars))\n \t    {\n-\t      insert_some_chars (nfd, lendiff, col_lendiff);\n-\t      _rl_last_c_pos += col_lendiff;\n-\t    }\n-#if 0\t\t/* XXX - for now */\n-\t  else if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && _rl_last_c_pos == 0 && wrap_offset && (nfd-new) <= prompt_last_invisible && col_lendiff < prompt_visible_length && visible_wrap_offset >= current_invis_chars)\n-\t    {\n-\t      _rl_output_some_chars (nfd, lendiff);\n-\t      _rl_last_c_pos += col_lendiff;\n+\t      open_some_spaces (col_lendiff);\n+\t      _rl_output_some_chars (nfd, bytes_to_insert);\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n+\t\t_rl_last_c_pos += _rl_col_width (nfd, 0, bytes_to_insert, 1);\n+\t      else\n+\t\t_rl_last_c_pos += bytes_to_insert;\n \t    }\n-#endif\n-\t  else if ((MB_CUR_MAX == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)\n+\t  else if ((mb_cur_max == 1 || rl_byte_oriented != 0) && *ols == 0 && lendiff > 0)\n \t    {\n \t      /* At the end of a line the characters do not have to\n \t\t be \"inserted\".  They can just be placed on the screen. */\n-\t      /* However, this screws up the rest of this block, which\n-\t\t assumes you've done the insert because you can. */\n-\t      _rl_output_some_chars (nfd, lendiff);\n-\t      _rl_last_c_pos += col_lendiff;\n+\t      _rl_output_some_chars (nfd, temp);\n+\t      _rl_last_c_pos += col_temp;\n+\t      return;\n \t    }\n-\t  else\n+\t  else\t/* just write from first difference to end of new line */\n \t    {\n \t      _rl_output_some_chars (nfd, temp);\n \t      _rl_last_c_pos += col_temp;\n \t      /* If nfd begins before the last invisible character in the\n \t\t prompt, adjust _rl_last_c_pos to account for wrap_offset\n \t\t and set cpos_adjusted to let the caller know. */\n-\t      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n+\t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t\t{\n \t\t  _rl_last_c_pos -= wrap_offset;\n \t\t  cpos_adjusted = 1;\n \t\t}\n \t      return;\n \t    }\n-\t  /* Copy (new) chars to screen from first diff to last match. */\n-\t  temp = nls - nfd;\n-\t  if ((temp - lendiff) > 0)\n+\n+\t  if (bytes_to_insert > lendiff)\n \t    {\n-\t      _rl_output_some_chars (nfd + lendiff, temp - lendiff);\n-\t     /* XXX -- this bears closer inspection.  Fixes a redisplay bug\n-\t\treported against bash-3.0-alpha by Andreas Schwab involving\n-\t\tmultibyte characters and prompt strings with invisible\n-\t\tcharacters, but was previously disabled. */\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n-\t\ttwidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff, 1);\n-\t      else\n-\t\ttwidth = temp - lendiff;\n-\t      _rl_last_c_pos += twidth;\n \t      /* If nfd begins before the last invisible character in the\n \t\t prompt, adjust _rl_last_c_pos to account for wrap_offset\n \t\t and set cpos_adjusted to let the caller know. */\n-\t      if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) && current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n+\t      if ((mb_cur_max > 1 && rl_byte_oriented == 0) && current_line == 0 && displaying_prompt_first_line && wrap_offset && ((nfd - new) <= prompt_last_invisible))\n \t\t{\n \t\t  _rl_last_c_pos -= wrap_offset;\n \t\t  cpos_adjusted = 1;\n@@ -1713,10 +1904,15 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t     char in the current line (which implies we just output some invisible\n \t     characters) we need to adjust _rl_last_c_pos, since it represents\n \t     a physical character position. */\n-\t  if ((MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&\n+\t  /* The current_line*rl_screenwidth+prompt_invis_chars_first_line is a\n+\t     crude attempt to compute how far into the new line buffer we are.\n+\t     It doesn't work well in the face of multibyte characters and needs\n+\t     to be rethought. XXX */\n+\t  if ((mb_cur_max > 1 && rl_byte_oriented == 0) &&\n \t\tcurrent_line == prompt_last_screen_line && wrap_offset &&\n+\t\tdisplaying_prompt_first_line &&\n \t\twrap_offset != prompt_invis_chars_first_line &&\n-\t\t((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth))))\n+\t\t((nfd-new) < (prompt_last_invisible-(current_line*_rl_screenwidth+prompt_invis_chars_first_line))))\n \t    {\n \t      _rl_last_c_pos -= wrap_offset - prompt_invis_chars_first_line;\n \t      cpos_adjusted = 1;\n@@ -1732,32 +1928,52 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t     prompt string, don't bother.  It screws up the assumptions\n \t     about what's on the screen. */\n \t  if (_rl_horizontal_scroll_mode && _rl_last_c_pos == 0 &&\n+\t      displaying_prompt_first_line &&\n \t      -lendiff == visible_wrap_offset)\n \t    col_lendiff = 0;\n \n+\t  /* If we have moved lmargin and we're shrinking the line, we've\n+\t     already moved the cursor to the first character of the new line,\n+\t     so deleting -col_lendiff characters will mess up the cursor\n+\t     position calculation */\n+\t  if (_rl_horizontal_scroll_mode && displaying_prompt_first_line == 0 &&\n+\t\tcol_lendiff && _rl_last_c_pos < -col_lendiff)\n+\t    col_lendiff = 0;\n+\n \t  if (col_lendiff)\n \t    delete_chars (-col_lendiff); /* delete (diff) characters */\n \n-\t  /* Copy (new) chars to screen from first diff to last match */\n-\t  temp = nls - nfd;\n-\t  if (temp > 0)\n+\t  /* Copy (new) chars to screen from first diff to last match,\n+\t     overwriting what is there. */\n+\t  if (bytes_to_insert > 0)\n \t    {\n \t      /* If nfd begins at the prompt, or before the invisible\n \t\t characters in the prompt, we need to adjust _rl_last_c_pos\n \t\t in a multibyte locale to account for the wrap offset and\n \t\t set cpos_adjusted accordingly. */\n-\t      _rl_output_some_chars (nfd, temp);\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t      _rl_output_some_chars (nfd, bytes_to_insert);\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\t{\n-\t\t  _rl_last_c_pos += _rl_col_width (nfd, 0, temp, 1);\n-\t\t  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))\n+\t\t  _rl_last_c_pos += _rl_col_width (nfd, 0, bytes_to_insert, 1);\n+\t\t  if (current_line == 0 && wrap_offset &&\n+\t\t\tdisplaying_prompt_first_line &&\n+\t\t\t_rl_last_c_pos > wrap_offset &&\n+\t\t\t((nfd - new) <= prompt_last_invisible))\n \t\t    {\n \t\t      _rl_last_c_pos -= wrap_offset;\n \t\t      cpos_adjusted = 1;\n \t\t    }\n \t\t}\n \t      else\n-\t\t_rl_last_c_pos += temp;\n+\t\t_rl_last_c_pos += bytes_to_insert;\n+\n+\t      /* XXX - we only want to do this if we are at the end of the line\n+\t\t so we move there with _rl_move_cursor_relative */\n+\t      if (_rl_horizontal_scroll_mode && ((oe-old) > (ne-new)))\n+\t\t{\n+\t\t  _rl_move_cursor_relative (ne-new, new);\n+\t\t  goto clear_rest_of_line;\n+\t\t}\n \t    }\n \t}\n       /* Otherwise, print over the existing material. */\n@@ -1771,31 +1987,31 @@ update_line (old, new, current_line, omax, nmax, inv_botlin)\n \t\t set cpos_adjusted accordingly. */\n \t      _rl_output_some_chars (nfd, temp);\n \t      _rl_last_c_pos += col_temp;\t\t/* XXX */\n-\t      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t\t{\n-\t\t  if (current_line == 0 && wrap_offset &&  ((nfd - new) <= prompt_last_invisible))\n+\t\t  if (current_line == 0 && wrap_offset &&\n+\t\t\tdisplaying_prompt_first_line &&\n+\t\t\t_rl_last_c_pos > wrap_offset &&\n+\t\t\t((nfd - new) <= prompt_last_invisible))\n \t\t    {\n \t\t      _rl_last_c_pos -= wrap_offset;\n \t\t      cpos_adjusted = 1;\n \t\t    }\n \t\t}\n \t    }\n+clear_rest_of_line:\n \t  lendiff = (oe - old) - (ne - new);\n-\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t    col_lendiff = _rl_col_width (old, 0, oe - old, 1) - _rl_col_width (new, 0, ne - new, 1);\n \t  else\n \t    col_lendiff = lendiff;\n \n-#if 0\n-\t  if (col_lendiff)\n-#else\n \t  /* If we've already printed over the entire width of the screen,\n \t     including the old material, then col_lendiff doesn't matter and\n \t     space_to_eol will insert too many spaces.  XXX - maybe we should\n \t     adjust col_lendiff based on the difference between _rl_last_c_pos\n \t     and _rl_screenwidth */\n-\t  if (col_lendiff && ((MB_CUR_MAX == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))\n-#endif\n+\t  if (col_lendiff && ((mb_cur_max == 1 || rl_byte_oriented) || (_rl_last_c_pos < _rl_screenwidth)))\n \t    {\t  \n \t      if (_rl_term_autowrap && current_line < inv_botlin)\n \t\tspace_to_eol (col_lendiff);\n@@ -1821,6 +2037,34 @@ rl_on_new_line ()\n   return 0;\n }\n \n+/* Clear all screen lines occupied by the current readline line buffer\n+   (visible line) */\n+int\n+rl_clear_visible_line ()\n+{\n+  int curr_line;\n+\n+  /* Make sure we move to column 0 so we clear the entire line */\n+#if defined (__MSDOS__)\n+  putc ('\\r', rl_outstream);\n+#else\n+  tputs (_rl_term_cr, 1, _rl_output_character_function);\n+#endif\n+  _rl_last_c_pos = 0;\n+\n+  /* Move to the last screen line of the current visible line */\n+  _rl_move_vert (_rl_vis_botlin);\n+\n+  /* And erase screen lines going up to line 0 (first visible line) */\n+  for (curr_line = _rl_last_v_pos; curr_line >= 0; curr_line--)\n+    {\n+      _rl_move_vert (curr_line);\n+      _rl_clear_to_eol (0);\n+    }\n+\n+  return 0;\n+}\n+\n /* Tell the update routines that we have moved onto a new line with the\n    prompt already displayed.  Code originally from the version of readline\n    distributed with CLISP.  rl_expand_prompt must have already been called\n@@ -1898,11 +2142,25 @@ rl_forced_update_display ()\n   return 0;\n }\n \n+/* Redraw only the last line of a multi-line prompt. */\n+void\n+rl_redraw_prompt_last_line ()\n+{\n+  char *t;\n+\n+  t = strrchr (rl_display_prompt, '\\n');\n+  if (t)\n+    redraw_prompt (++t);\n+  else\n+    rl_forced_update_display ();\n+}\n+\n /* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.\n    (Well, when we don't have multibyte characters, _rl_last_c_pos is a\n    buffer index.)\n    DATA is the contents of the screen line of interest; i.e., where\n-   the movement is being done. */\n+   the movement is being done.\n+   DATA is always the visible line or the invisible line */\n void\n _rl_move_cursor_relative (new, data)\n      int new;\n@@ -1912,6 +2170,8 @@ _rl_move_cursor_relative (new, data)\n   int woff;\t\t\t/* number of invisible chars on current line */\n   int cpos, dpos;\t\t/* current and desired cursor positions */\n   int adjust;\n+  int in_invisline;\n+  int mb_cur_max = MB_CUR_MAX;\n \n   woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);\n   cpos = _rl_last_c_pos;\n@@ -1925,7 +2185,7 @@ _rl_move_cursor_relative (new, data)\n      this case, NEW's display position is not obvious and must be\n      calculated.  We need to account for invisible characters in this line,\n      as long as we are past them and they are counted by _rl_col_width. */\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     {\n       adjust = 1;\n       /* Try to short-circuit common cases and eliminate a bunch of multibyte\n@@ -1947,14 +2207,31 @@ _rl_move_cursor_relative (new, data)\n       else\n         dpos = _rl_col_width (data, 0, new, 1);\n \n+      if (displaying_prompt_first_line == 0)\n+\tadjust = 0;\n+\n+      /* yet another special case: printing the last line of a prompt with\n+\t multibyte characters and invisible characters whose printable length\n+\t exceeds the screen width with the last invisible character\n+\t (prompt_last_invisible) in the last line.  IN_INVISLINE is the\n+\t offset of DATA in invisible_line */\n+      in_invisline = 0;\n+      if (data > invisible_line && data < invisible_line+inv_lbreaks[_rl_inv_botlin+1])\n+\tin_invisline = data - invisible_line;\n+\n       /* Use NEW when comparing against the last invisible character in the\n \t prompt string, since they're both buffer indices and DPOS is a\n \t desired display position. */\n+      /* NEW is relative to the current displayed line, while\n+\t PROMPT_LAST_INVISIBLE is relative to the entire (wrapped) line.\n+\t Need a way to reconcile these two variables by turning NEW into a\n+\t buffer position relative to the start of the line */\n       if (adjust && ((new > prompt_last_invisible) ||\t\t/* XXX - don't use woff here */\n-\t  (prompt_physical_chars >= _rl_screenwidth &&\n+\t\t     (new+in_invisline > prompt_last_invisible) ||\t/* invisible line */\n+\t  (prompt_physical_chars >= _rl_screenwidth &&\t\t/* visible line */\n \t   _rl_last_v_pos == prompt_last_screen_line &&\n \t   wrap_offset >= woff && dpos >= woff &&\n-\t   new > (prompt_last_invisible-(_rl_screenwidth*_rl_last_v_pos)-wrap_offset))))\n+\t   new > (prompt_last_invisible-(vis_lbreaks[_rl_last_v_pos])-wrap_offset))))\n \t   /* XXX last comparison might need to be >= */\n \t{\n \t  dpos -= woff;\n@@ -1976,7 +2253,7 @@ _rl_move_cursor_relative (new, data)\n      of moving backwards. */\n   /* i == current physical cursor position. */\n #if defined (HANDLE_MULTIBYTE)\n-  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+  if (mb_cur_max > 1 && rl_byte_oriented == 0)\n     i = _rl_last_c_pos;\n   else\n #endif\n@@ -2011,7 +2288,7 @@ _rl_move_cursor_relative (new, data)\n \t in the buffer and we have to go back to the beginning of the screen\n \t line.  In this case, we can use the terminal sequence to move forward\n \t if it's available. */\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+      if (mb_cur_max > 1 && rl_byte_oriented == 0)\n \t{\n \t  if (_rl_term_forward_char)\n \t    {\n@@ -2065,18 +2342,18 @@ _rl_move_vert (to)\n     }\n   else\n     {\t\t\t/* delta < 0 */\n-#ifdef __MSDOS__\n+#ifdef __DJGPP__\n       int row, col;\n \n-      fflush (rl_outstream); /* make sure the cursor pos is current! */\n+      fflush (rl_outstream);\n       ScreenGetCursor (&row, &col);\n       ScreenSetCursor (row + delta, col);\n-      i = -delta;    /* in case someone wants to use it after the loop */\n-#else /* !__MSDOS__ */\n+      i = -delta;\n+#else\n       if (_rl_term_up && *_rl_term_up)\n \tfor (i = 0; i < -delta; i++)\n \t  tputs (_rl_term_up, 1, _rl_output_character_function);\n-#endif /* !__MSDOS__ */\n+#endif /* !__DJGPP__ */\n     }\n \n   _rl_last_v_pos = to;\t\t/* Now TO is here */\n@@ -2154,6 +2431,9 @@ rl_message (va_alist)\n #if defined (PREFER_VARARGS)\n   char *format;\n #endif\n+#if defined (HAVE_VSNPRINTF)\n+  int bneed;\n+#endif\n \n #if defined (PREFER_STDARG)\n   va_start (args, format);\n@@ -2162,11 +2442,28 @@ rl_message (va_alist)\n   format = va_arg (args, char *);\n #endif\n \n+  if (msg_buf == 0)\n+    msg_buf = xmalloc (msg_bufsiz = 128);\n+\n #if defined (HAVE_VSNPRINTF)\n-  vsnprintf (msg_buf, sizeof (msg_buf) - 1, format, args);\n+  bneed = vsnprintf (msg_buf, msg_bufsiz, format, args);\n+  if (bneed >= msg_bufsiz - 1)\n+    {\n+      msg_bufsiz = bneed + 1;\n+      msg_buf = xrealloc (msg_buf, msg_bufsiz);\n+      va_end (args);\n+\n+#if defined (PREFER_STDARG)\n+      va_start (args, format);\n+#else\n+      va_start (args);\n+      format = va_arg (args, char *);\n+#endif\n+      vsnprintf (msg_buf, msg_bufsiz - 1, format, args);\n+    }\n #else\n   vsprintf (msg_buf, format, args);\n-  msg_buf[sizeof(msg_buf) - 1] = '\\0';\t/* overflow? */\n+  msg_buf[msg_bufsiz - 1] = '\\0';\t/* overflow? */\n #endif\n   va_end (args);\n \n@@ -2175,11 +2472,17 @@ rl_message (va_alist)\n       rl_save_prompt ();\n       msg_saved_prompt = 1;\n     }\n+  else if (local_prompt != saved_local_prompt)\n+    {\n+      FREE (local_prompt);\n+      FREE (local_prompt_prefix);\n+      local_prompt = (char *)NULL;\n+    }\n   rl_display_prompt = msg_buf;\n-  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,\n-\t\t\t\t\t &prompt_last_invisible,\n-\t\t\t\t\t &prompt_invis_chars_first_line,\n-\t\t\t\t\t &prompt_physical_chars);\n+  local_prompt = expand_prompt (msg_buf, 0, &prompt_visible_length,\n+\t\t\t\t\t    &prompt_last_invisible,\n+\t\t\t\t\t    &prompt_invis_chars_first_line,\n+\t\t\t\t\t    &prompt_physical_chars);\n   local_prompt_prefix = (char *)NULL;\n   local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n   (*rl_redisplay_function) ();\n@@ -2191,19 +2494,28 @@ int\n rl_message (format, arg1, arg2)\n      char *format;\n {\n+  if (msg_buf == 0)\n+    msg_buf = xmalloc (msg_bufsiz = 128);\n+\n   sprintf (msg_buf, format, arg1, arg2);\n-  msg_buf[sizeof(msg_buf) - 1] = '\\0';\t/* overflow? */\n+  msg_buf[msg_bufsiz - 1] = '\\0';\t/* overflow? */\n \n   rl_display_prompt = msg_buf;\n   if (saved_local_prompt == 0)\n     {\n       rl_save_prompt ();\n       msg_saved_prompt = 1;\n     }\n-  local_prompt = expand_prompt (msg_buf, &prompt_visible_length,\n-\t\t\t\t\t &prompt_last_invisible,\n-\t\t\t\t\t &prompt_invis_chars_first_line,\n-\t\t\t\t\t &prompt_physical_chars);\n+  else if (local_prompt != saved_local_prompt)\n+    {\n+      FREE (local_prompt);\n+      FREE (local_prompt_prefix);\n+      local_prompt = (char *)NULL;\n+    }\n+  local_prompt = expand_prompt (msg_buf, 0, &prompt_visible_length,\n+\t\t\t\t\t    &prompt_last_invisible,\n+\t\t\t\t\t    &prompt_invis_chars_first_line,\n+\t\t\t\t\t    &prompt_physical_chars);\n   local_prompt_prefix = (char *)NULL;\n   local_prompt_len = local_prompt ? strlen (local_prompt) : 0;\n   (*rl_redisplay_function) ();\n@@ -2341,8 +2653,8 @@ _rl_clear_to_eol (count)\n     tputs (_rl_term_clreol, 1, _rl_output_character_function);\n   else\n #endif\n-  if (count)\n-    space_to_eol (count);\n+    if (count)\n+      space_to_eol (count);\n }\n \n /* Clear to the end of the line using spaces.  COUNT is the minimum\n@@ -2362,15 +2674,15 @@ space_to_eol (count)\n void\n _rl_clear_screen ()\n {\n-#if defined (__GO32__)\n-  ScreenClear ();\t/* FIXME: only works in text modes */\n-  ScreenSetCursor (0, 0);  /* term_clrpag is \"cl\" which homes the cursor */\n-#else\n+#ifndef __DJGPP__\n   if (_rl_term_clrpag)\n     tputs (_rl_term_clrpag, 1, _rl_output_character_function);\n   else\n     rl_crlf ();\n-#endif\n+#else\n+  ScreenClear ();\n+  ScreenSetCursor (0, 0);\n+#endif /* __DJGPP__ */\n }\n \n /* Insert COUNT characters from STRING to the output stream at column COL. */\n@@ -2379,48 +2691,47 @@ insert_some_chars (string, count, col)\n      char *string;\n      int count, col;\n {\n-#if defined (__MSDOS__) || (defined (__MINGW32__) && !defined (NCURSES_VERSION))\n+  open_some_spaces (col);\n   _rl_output_some_chars (string, count);\n-#else\n-  /* DEBUGGING */\n-  if (MB_CUR_MAX == 1 || rl_byte_oriented)\n-    if (count != col)\n-      _rl_ttymsg (\"debug: insert_some_chars: count (%d) != col (%d)\", count, col);\n+}\n+\n+/* Insert COL spaces, keeping the cursor at the same position.  We follow the\n+   ncurses documentation and use either im/ei with explicit spaces, or IC/ic\n+   by itself.  We assume there will either be ei or we don't need to use it. */\n+static void\n+open_some_spaces (col)\n+     int col;\n+{\n+#if !defined (__MSDOS__) && (!defined (__MINGW32__) || defined (NCURSES_VERSION))\n+  char *buffer;\n+  register int i;\n \n   /* If IC is defined, then we do not have to \"enter\" insert mode. */\n   if (_rl_term_IC)\n     {\n-      char *buffer;\n-\n       buffer = tgoto (_rl_term_IC, 0, col);\n       tputs (buffer, 1, _rl_output_character_function);\n-      _rl_output_some_chars (string, count);\n     }\n-  else\n+  else if (_rl_term_im && *_rl_term_im)\n     {\n-      register int i;\n-\n-      /* If we have to turn on insert-mode, then do so. */\n-      if (_rl_term_im && *_rl_term_im)\n-\ttputs (_rl_term_im, 1, _rl_output_character_function);\n-\n-      /* If there is a special command for inserting characters, then\n-\t use that first to open up the space. */\n-      if (_rl_term_ic && *_rl_term_ic)\n-\t{\n-\t  for (i = col; i--; )\n-\t    tputs (_rl_term_ic, 1, _rl_output_character_function);\n-\t}\n-\n-      /* Print the text. */\n-      _rl_output_some_chars (string, count);\n-\n-      /* If there is a string to turn off insert mode, we had best use\n-\t it now. */\n+      tputs (_rl_term_im, 1, _rl_output_character_function);\n+      /* just output the desired number of spaces */\n+      for (i = col; i--; )\n+\t_rl_output_character_function (' ');\n+      /* If there is a string to turn off insert mode, use it now. */\n       if (_rl_term_ei && *_rl_term_ei)\n \ttputs (_rl_term_ei, 1, _rl_output_character_function);\n+      /* and move back the right number of spaces */\n+      _rl_backspace (col);\n     }\n-#endif /* __MSDOS__ || __MINGW32__ */\n+  else if (_rl_term_ic && *_rl_term_ic)\n+    {\n+      /* If there is a special command for inserting characters, then\n+\t use that first to open up the space. */\n+      for (i = col; i--; )\n+\ttputs (_rl_term_ic, 1, _rl_output_character_function);\n+    }\n+#endif /* !__MSDOS__ && (!__MINGW32__ || NCURSES_VERSION)*/\n }\n \n /* Delete COUNT characters from the display line. */\n@@ -2431,7 +2742,7 @@ delete_chars (count)\n   if (count > _rl_screenwidth)\t/* XXX */\n     return;\n \n-#if !defined (__MSDOS__) && !(defined (__MINGW32__) && !defined (NCURSES_VERSION))\n+#if !defined (__MSDOS__) && (!defined (__MINGW32__) || defined (NCURSES_VERSION))\n   if (_rl_term_DC && *_rl_term_DC)\n     {\n       char *buffer;\n@@ -2444,7 +2755,7 @@ delete_chars (count)\n \twhile (count--)\n \t  tputs (_rl_term_dc, 1, _rl_output_character_function);\n     }\n-#endif /* !__MSDOS__ && !__MINGW32__ */\n+#endif /* !__MSDOS__ && (!__MINGW32__ || NCURSES_VERSION)*/\n }\n \n void\n@@ -2507,7 +2818,8 @@ redraw_prompt (t)\n   rl_save_prompt ();\n \n   rl_display_prompt = t;\n-  local_prompt = expand_prompt (t, &prompt_visible_length,\n+  local_prompt = expand_prompt (t, PMT_MULTILINE,\n+\t\t\t\t   &prompt_visible_length,\n \t\t\t\t   &prompt_last_invisible,\n \t\t\t\t   &prompt_invis_chars_first_line,\n \t\t\t\t   &prompt_physical_chars);\n@@ -2571,7 +2883,8 @@ _rl_clean_up_for_exit ()\n {\n   if (_rl_echoing_p)\n     {\n-      _rl_move_vert (_rl_vis_botlin);\n+      if (_rl_vis_botlin > 0)\t/* minor optimization plus bug fix */\n+\t_rl_move_vert (_rl_vis_botlin);\n       _rl_vis_botlin = 0;\n       fflush (rl_outstream);\n       rl_restart_output (1, 0);\n@@ -2587,6 +2900,12 @@ _rl_erase_entire_line ()\n   fflush (rl_outstream);\n }\n \n+void\n+_rl_ttyflush ()\n+{\n+  fflush (rl_outstream);\n+}\n+\n /* return the `current display line' of the cursor -- the number of lines to\n    move up to get to the first screen line of the current readline line. */\n int\n@@ -2625,10 +2944,8 @@ _rl_col_width (str, start, end, flags)\n   if (end <= start)\n     return 0;\n   if (MB_CUR_MAX == 1 || rl_byte_oriented)\n-{\n-_rl_ttymsg (\"_rl_col_width: called with MB_CUR_MAX == 1\");\n+    /* this can happen in some cases where it's inconvenient to check */\n     return (end - start);\n-}\n \n   memset (&ps, 0, sizeof (mbstate_t));\n \n@@ -2702,7 +3019,7 @@ _rl_ttymsg (\"_rl_col_width: called with MB_CUR_MAX == 1\");\n \t{\n \t  point += tmp;\n \t  max -= tmp;\n-\t  tmp = wcwidth(wc);\n+\t  tmp = WCWIDTH(wc);\n \t  width += (tmp >= 0) ? tmp : 1;\n \t}\n     }"
    },
    {
      "sha": "a38bc9eb4a876c181fd6f134e5f4211f77ad7177",
      "filename": "readline/doc/Makefile.in",
      "status": "modified",
      "additions": 18,
      "deletions": 3,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/Makefile.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -16,6 +16,8 @@\n #   You should have received a copy of the GNU General Public License\n #   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+\n topdir = @top_srcdir@\n srcdir = @srcdir@\n VPATH = @srcdir@\n@@ -24,6 +26,7 @@ prefix = @prefix@\n \n datarootdir = @datarootdir@\n \n+docdir = @docdir@\n infodir = @infodir@\n \n mandir = @mandir@\n@@ -56,6 +59,8 @@ QUIETPS     = #set this to -q to shut up dvips\n PAPERSIZE   = letter\n PSDPI       = 600\n DVIPS       = dvips -D ${PSDPI} $(QUIETPS) -t ${PAPERSIZE} -o $@     # tricky\n+# experimental; uses external texi2dvi for now; this needs pdftex to be present\n+TEXI2PDF    = texi2dvi --pdf\n \n # These tools might not be available; they're not required\n DVIPDF      = dvipdfm -o $@ -p ${PAPERSIZE}\n@@ -98,6 +103,10 @@ DIST_DOCS = $(DVIOBJ) $(PSOBJ) $(HTMLOBJ) $(INFOOBJ) $(TEXTOBJ) $(PDFOBJ)\n \t$(RM) $@\n \t-${DVIPDF} $<\n \n+#.texi.pdf:\n+#\t$(RM) $@\n+#\t-${TEXI2PDF} $<\n+\n all: info dvi html ps text pdf\n nodvi: info html text\n \n@@ -167,9 +176,15 @@ history_3.ps: $(srcdir)/history.3\n \t${RM} $@\n \t${GROFF} -man < $(srcdir)/history.3 > $@ \n \n-readline.pdf:\treadline.dvi\n-history.pdf:\thistory.dvi\n-rluserman.pdf:\trluserman.dvi\n+readline.pdf:\t$(RLSRC)\n+\tTEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2PDF) $(srcdir)/rlman.texi\n+\tmv rlman.pdf $@\n+\n+history.pdf:\t$(HISTSRC)\n+\tTEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2PDF) $(srcdir)/history.texi\n+\n+rluserman.pdf:\t$(RLSRC)\n+\tTEXINPUTS=.:$(TEXINPUTDIR):$$TEXINPUTS $(TEXI2PDF) $(srcdir)/rluserman.texi\n \n clean:\n \t$(RM) *.aux *.bak *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps \\"
    },
    {
      "sha": "7ddc26ae353d33956b936d8f470f39303aff2de6",
      "filename": "readline/doc/history.3",
      "status": "modified",
      "additions": 18,
      "deletions": 15,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/history.3",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/history.3",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/history.3?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -4,11 +4,11 @@\n .\\\"\tChet Ramey\n .\\\"\tInformation Network Services\n .\\\"\tCase Western Reserve University\n-.\\\"\tchet@ins.CWRU.Edu\n+.\\\"\tchet.ramey@case.edu\n .\\\"\n-.\\\"\tLast Change: Thu Aug 12 22:24:41 EDT 2010\n+.\\\"\tLast Change: Sun May 24 18:01:17 EDT 2015\n .\\\"\n-.TH HISTORY 3 \"2010 August 12\" \"GNU History 6.2\"\n+.TH HISTORY 3 \"2015 May 24\" \"GNU History 6.3\"\n .\\\"\n .\\\" File Name macro.  This used to be `.PN', for Path Name,\n .\\\" but Sun doesn't seem to like that very much.\n@@ -40,8 +40,8 @@\n .SH NAME\n history \\- GNU History Library\n .SH COPYRIGHT\n-.if t The GNU History Library is Copyright \\(co 1989-2011 by the Free Software Foundation, Inc.\n-.if n The GNU History Library is Copyright (C) 1989-2011 by the Free Software Foundation, Inc.\n+.if t The GNU History Library is Copyright \\(co 1989-2014 by the Free Software Foundation, Inc.\n+.if n The GNU History Library is Copyright (C) 1989-2014 by the Free Software Foundation, Inc.\n .SH DESCRIPTION\n Many programs read input from the user a line at a time.  The GNU\n History library is able to keep track of those lines, associate arbitrary\n@@ -112,7 +112,7 @@ starting with\n .TP\n .B !?\\fIstring\\fR\\fB[?]\\fR\n Refer to the most recent command\n-preceding the current postition in the history list\n+preceding the current position in the history list\n containing\n .IR string .\n The trailing \\fB?\\fP may be omitted if\n@@ -134,7 +134,7 @@ The entire command line typed so far.\n .SS Word Designators\n .PP\n Word designators are used to select desired words from the event.\n-A \n+A\n .B :\n separates the event specification from the word designator.\n It may be omitted if the word designator begins with a\n@@ -161,7 +161,8 @@ The \\fIn\\fRth word.\n The first argument.  That is, word 1.\n .TP\n .B $\n-The last argument.\n+The last word.  This is usually the last argument, but will expand to the\n+zeroth word if there is only one word in the line.\n .TP\n .B %\n The word matched by the most recent `?\\fIstring\\fR?' search.\n@@ -440,9 +441,11 @@ return a pointer to that entry.  If there is no previous entry, return\n a \\fBNULL\\fP pointer.\n \n .Fn1 \"HIST_ENTRY *\" next_history \"void\"\n-Move the current history offset forward to the next history entry, and\n-return the a pointer to that entry.  If there is no next entry, return\n-a \\fBNULL\\fP pointer.\n+If the current history offset refers to a valid history entry,\n+increment the current history offset.\n+If the possibly-incremented history offset refers to a valid history\n+entry, return a pointer to that entry;\n+otherwise, return a \\fBNULL\\fP pointer.\n \n .SS Searching the History List\n \n@@ -612,8 +615,8 @@ string, in addition to space, tab, \\fI:\\fP and \\fI?\\fP in the case of\n a substring search.  The default is empty.\n \n .Vb int history_quotes_inhibit_expansion\n-If non-zero, single-quoted words are not scanned for the history expansion\n-character.  The default value is 0.\n+If non-zero, double-quoted words are not scanned for the history expansion\n+character or the history comment character.  The default value is 0.\n \n .Vb \"rl_linebuf_func_t *\" history_inhibit_expansion_function\n This should be set to the address of a function that takes two arguments:\n@@ -649,7 +652,7 @@ bfox@gnu.org\n .PP\n Chet Ramey, Case Western Reserve University\n .br\n-chet@ins.CWRU.Edu\n+chet.ramey@case.edu\n .SH BUG REPORTS\n If you find a bug in the\n .B history\n@@ -669,4 +672,4 @@ newsgroup\n .PP\n Comments and bug reports concerning\n this manual page should be directed to\n-.IR chet@ins.CWRU.Edu .\n+.IR chet.ramey@case.edu ."
    },
    {
      "sha": "98e22332770c17f3bf8c3598fbe8165869f293ed",
      "filename": "readline/doc/history.texi",
      "status": "modified",
      "additions": 6,
      "deletions": 20,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/history.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/history.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/history.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,33 +2,25 @@\n @c %**start of header (This is for running Texinfo on a region.)\n @setfilename history.info\n @settitle GNU History Library\n-@c %**end of header (This is for running Texinfo on a region.)\n-\n @include version.texi\n \n+@c %**end of header (This is for running Texinfo on a region.)\n+\n @copying\n This document describes the GNU History library\n (version @value{VERSION}, @value{UPDATED}),\n a programming tool that provides a consistent user interface for\n recalling lines of previously typed input.\n \n-Copyright @copyright{} 1988--2011 Free Software Foundation, Inc.\n-\n-Permission is granted to make and distribute verbatim copies of\n-this manual provided the copyright notice and this permission notice\n-are preserved on all copies.\n+Copyright @copyright{} 1988--2016 Free Software Foundation, Inc.\n \n @quotation\n Permission is granted to copy, distribute and/or modify this document\n under the terms of the GNU Free Documentation License, Version 1.3 or\n any later version published by the Free Software Foundation; with no\n-Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',\n-and with the Back-Cover Texts as in (a) below.  A copy of the license is\n-included in the section entitled ``GNU Free Documentation License''.\n-\n-(a) The FSF's Back-Cover Text is: You are free to copy and modify\n-this GNU manual.  Buying copies from GNU Press supports the FSF in\n-developing GNU and promoting software freedom.''\n+Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n+A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n \n @end quotation\n @end copying\n@@ -50,12 +42,6 @@ developing GNU and promoting software freedom.''\n @vskip 0pt plus 1filll\n @insertcopying\n \n-@sp 1\n-Published by the Free Software Foundation @*\n-59 Temple Place, Suite 330, @*\n-Boston, MA 02111-1307 @*\n-USA @*\n-\n @end titlepage\n \n @contents"
    },
    {
      "sha": "bba7b590eddf5deb96172a5d40375bb81f6045ca",
      "filename": "readline/doc/hstech.texi",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/hstech.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/hstech.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/hstech.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n @ignore\n This file documents the user interface to the GNU History library.\n \n-Copyright (C) 1988-2011 Free Software Foundation, Inc.\n+Copyright (C) 1988-2016 Free Software Foundation, Inc.\n Authored by Brian Fox and Chet Ramey.\n \n Permission is granted to make and distribute verbatim copies of this manual\n@@ -242,6 +242,7 @@ is greater than the history length, return a @code{NULL} pointer.\n \n @deftypefun time_t history_get_time (HIST_ENTRY *entry)\n Return the time stamp associated with the history entry @var{entry}.\n+If the timestamp is missing or invalid, return 0.\n @end deftypefun\n \n @deftypefun int history_total_bytes (void)\n@@ -270,9 +271,11 @@ a @code{NULL} pointer.\n @end deftypefun\n \n @deftypefun {HIST_ENTRY *} next_history (void)\n-Move the current history offset forward to the next history entry, and\n-return the a pointer to that entry.  If there is no next entry, return\n-a @code{NULL} pointer.\n+If the current history offset refers to a valid history entry,\n+increment the current history offset.\n+If the possibly-incremented history offset refers to a valid history\n+entry, return a pointer to that entry;\n+otherwise, return a @code{BNULL} pointer.\n @end deftypefun\n \n @node Searching the History List\n@@ -377,7 +380,7 @@ if the returned line should be displayed, but not executed,\n as with the @code{:p} modifier (@pxref{Modifiers}).\n @end table\n \n-If an error ocurred in expansion, then @var{output} contains a descriptive\n+If an error occurred in expansion, then @var{output} contains a descriptive\n error message.\n @end deftypefun\n \n@@ -467,8 +470,8 @@ carriage return, and @samp{=}.\n @end deftypevar\n \n @deftypevar int history_quotes_inhibit_expansion\n-If non-zero, single-quoted words are not scanned for the history expansion\n-character.  The default value is 0.\n+If non-zero, double-quoted words are not scanned for the history expansion\n+character or the history comment character.  The default value is 0.\n @end deftypevar\n \n @deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function"
    },
    {
      "sha": "311933ab43fbc79b43e09d88b5d5026f924c823a",
      "filename": "readline/doc/hsuser.texi",
      "status": "modified",
      "additions": 26,
      "deletions": 15,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/hsuser.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/hsuser.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/hsuser.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n @ignore\n This file documents the user interface to the GNU History library.\n \n-Copyright (C) 1988--2011 Free Software Foundation, Inc.\n+Copyright (C) 1988--2016 Free Software Foundation, Inc.\n Authored by Brian Fox and Chet Ramey.\n \n Permission is granted to make and distribute verbatim copies of this manual\n@@ -86,24 +86,25 @@ file named by the @env{HISTFILE} variable (default @file{~/.bash_history}).\n The file named by the value of @env{HISTFILE} is truncated, if\n necessary, to contain no more than the number of lines specified by\n the value of the @env{HISTFILESIZE} variable.\n-When an interactive shell exits, the last\n+When a shell with history enabled exits, the last\n @env{$HISTSIZE} lines are copied from the history list to the file\n named by @env{$HISTFILE}.\n If the @code{histappend} shell option is set (@pxref{Bash Builtins}),\n the lines are appended to the history file,\n otherwise the history file is overwritten.\n If @env{HISTFILE}\n-is unset, or if the history file is unwritable, the history is\n-not saved.  After saving the history, the history file is truncated\n-to contain no more than @env{$HISTFILESIZE}\n-lines.  If @env{HISTFILESIZE} is not set, no truncation is performed.\n+is unset, or if the history file is unwritable, the history is not saved.\n+After saving the history, the history file is truncated\n+to contain no more than @env{$HISTFILESIZE} lines.\n+If @env{HISTFILESIZE} is unset, or set to null, a non-numeric value, or\n+a numeric value less than zero, the history file is not truncated.\n \n If the @env{HISTTIMEFORMAT} is set, the time stamp information\n associated with each history entry is written to the history file,\n marked with the history comment character.\n When the history file is read, lines beginning with the history\n comment character followed immediately by a digit are interpreted\n-as timestamps for the previous history line.\n+as timestamps for the following history entry.\n \n The builtin command @code{fc} may be used to list or edit and re-execute\n a portion of the history list.\n@@ -143,8 +144,10 @@ history list and history file.\n @code{fc -s [@var{pat}=@var{rep}] [@var{command}]}\n @end example\n \n-Fix Command.  In the first form, a range of commands from @var{first} to\n-@var{last} is selected from the history list.  Both @var{first} and\n+The first form selects a range of commands from @var{first} to\n+@var{last} from the history list and displays or edits and re-executes\n+them.\n+Both @var{first} and\n @var{last} may be specified as a string (to locate the most recent\n command beginning with that string) or as a number (an index into the\n history list, where a negative number is used as an offset from the\n@@ -163,6 +166,7 @@ When editing is complete, the edited commands are echoed and executed.\n \n In the second form, @var{command} is re-executed after each instance\n of @var{pat} in the selected command is replaced by @var{rep}.\n+@var{command} is intepreted the same as @var{first} above.\n \n A useful alias to use with the @code{fc} command is @code{r='fc -s'}, so\n that typing @samp{r cc} runs the last command beginning with @code{cc}\n@@ -200,21 +204,21 @@ Delete the history entry at position @var{offset}.\n displayed.\n \n @item -a\n-Append the new\n-history lines (history lines entered since the beginning of the\n-current Bash session) to the history file.\n+Append the new history lines to the history file.\n+These are history lines entered since the beginning of the current\n+Bash session, but not already appended to the history file.\n \n @item -n\n Append the history lines not already read from the history file\n to the current history list.  These are lines appended to the history\n file since the beginning of the current Bash session.\n \n @item -r\n-Read the current history file and append its contents to\n+Read the history file and append its contents to\n the history list.\n \n @item -w\n-Write out the current history to the history file.\n+Write out the current history list to the history file.\n \n @item -p\n Perform history substitution on the @var{arg}s and display the result\n@@ -247,6 +251,11 @@ the input stream, making it easy to repeat commands, insert the\n arguments to a previous command into the current input line, or\n fix errors in previous commands quickly.\n \n+@ifset BashFeatures\n+History expansion is performed immediately after a complete line\n+is read, before the shell breaks it into words.\n+@end ifset\n+\n History expansion takes place in two parts.  The first is to determine\n which line from the history list should be used during substitution.\n The second is to select portions of that line for inclusion into the\n@@ -260,7 +269,9 @@ History expansions are introduced by the appearance of the\n history expansion character, which is @samp{!} by default.\n @ifset BashFeatures\n Only @samp{\\} and @samp{'} may be used to escape the history expansion\n-character.\n+character, but the history expansion character is\n+also treated as quoted if it immediately precedes the closing double quote\n+in a double-quoted string. \n @end ifset\n \n @ifset BashFeatures"
    },
    {
      "sha": "b57f00b90b0baecbaa9e1f90fcdf303d916d228e",
      "filename": "readline/doc/readline.3",
      "status": "modified",
      "additions": 146,
      "deletions": 36,
      "changes": 182,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/readline.3",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/readline.3",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/readline.3?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -4,11 +4,11 @@\n .\\\"\tChet Ramey\n .\\\"\tInformation Network Services\n .\\\"\tCase Western Reserve University\n-.\\\"\tchet@ins.CWRU.Edu\n+.\\\"\tchet.ramey@case.edu\n .\\\"\n-.\\\"\tLast Change: Sat Aug 28 18:56:32 EDT 2010\n+.\\\"\tLast Change: Sun Feb 28 15:42:34 EST 2016\n .\\\"\n-.TH READLINE 3 \"2010 August 28\" \"GNU Readline 6.2\"\n+.TH READLINE 3 \"2016 February 28\" \"GNU Readline 7.0\"\n .\\\"\n .\\\" File Name macro.  This used to be `.PN', for Path Name,\n .\\\" but Sun doesn't seem to like that very much.\n@@ -34,8 +34,8 @@ readline \\- get a line from a user with editing\n \\fBreadline\\fP (\\fIconst char *prompt\\fP);\n .fi\n .SH COPYRIGHT\n-.if n Readline is Copyright (C) 1989\\-2011 Free Software Foundation,  Inc.\n-.if t Readline is Copyright \\(co 1989\\-2011 Free Software Foundation, Inc.\n+.if n Readline is Copyright (C) 1989\\-2014 Free Software Foundation,  Inc.\n+.if t Readline is Copyright \\(co 1989\\-2014 Free Software Foundation, Inc.\n .SH DESCRIPTION\n .LP\n .B readline\n@@ -78,10 +78,10 @@ treated as a newline.\n .LP\n An Emacs-style notation is used to denote\n keystrokes.  Control keys are denoted by C\\-\\fIkey\\fR, e.g., C\\-n\n-means Control\\-N.  Similarly, \n+means Control\\-N.  Similarly,\n .I meta\n keys are denoted by M\\-\\fIkey\\fR, so M\\-x means Meta\\-X.  (On keyboards\n-without a \n+without a\n .I meta\n key, M\\-\\fIx\\fP means ESC \\fIx\\fP, i.e., press the Escape key\n then the\n@@ -98,14 +98,15 @@ Readline commands may be given numeric\n which normally act as a repeat count.  Sometimes, however, it is the\n sign of the argument that is significant.  Passing a negative argument\n to a command that acts in the forward direction (e.g., \\fBkill\\-line\\fP)\n-causes that command to act in a backward direction.  Commands whose\n-behavior with arguments deviates from this are noted.\n+causes that command to act in a backward direction.\n+Commands whose behavior with arguments deviates from this are noted\n+below.\n .PP\n When a command is described as \\fIkilling\\fP text, the text\n deleted is saved for possible future retrieval\n (\\fIyanking\\fP).  The killed text is saved in a\n \\fIkill ring\\fP.  Consecutive kills cause the text to be\n-accumulated into one unit, which can be yanked all at once. \n+accumulated into one unit, which can be yanked all at once.\n Commands which do not kill text separate the chunks of text\n on the kill ring.\n .SH INITIALIZATION FILE\n@@ -138,7 +139,7 @@ or\n C\\-Meta\\-u: universal\\-argument\n .RE\n .sp\n-into the \n+into the\n .I inputrc\n would make M\\-C\\-u execute the readline command\n .IR universal\\-argument .\n@@ -167,7 +168,7 @@ The syntax for controlling key bindings in the\n .I inputrc\n file is simple.  All that is required is the name of the\n command or the text of a macro and a key sequence to which\n-it should be bound. The name may be specified in one of two ways:\n+it should be bound.  The name may be specified in one of two ways:\n as a symbolic key name, possibly with \\fIMeta\\-\\fP or \\fIControl\\-\\fP\n prefixes, or as a key sequence.\n The name and key sequence are separated by a colon.  There can be no\n@@ -225,7 +226,7 @@ is again bound to the function\n .I \"C-x C-r\"\n is bound to the function\n .BR re\\-read\\-init\\-file ,\n-and \n+and\n .I \"ESC [ 1 1 ~\"\n is bound to insert the text\n .if t \\f(CWFunction Key 1\\fP.\n@@ -347,9 +348,25 @@ If set to \\fBnone\\fP, readline never rings the bell.  If set to\n If set to \\fBaudible\\fP, readline attempts to ring the terminal's bell.\n .TP\n .B bind\\-tty\\-special\\-chars (On)\n-If set to \\fBOn\\fP, readline attempts to bind the control characters  \n-treated specially by the kernel's terminal driver to their readline\n-equivalents.\n+If set to \\fBOn\\fP (the default), readline attempts to bind the control\n+characters   treated specially by the kernel's terminal driver to their\n+readline equivalents.\n+.TP\n+.B blink\\-matching\\-paren (Off)\n+If set to \\fBOn\\fP, readline attempts to briefly move the cursor to an\n+opening parenthesis when a closing parenthesis is inserted.\n+.TP\n+.B colored\\-completion\\-prefix (Off)\n+If set to \\fBOn\\fP, when listing completions, readline displays the\n+common prefix of the set of possible completions using a different color.\n+The color definitions are taken from the value of the \\fBLS_COLORS\\fP\n+environment variable.\n+.TP\n+.B colored\\-stats (Off)\n+If set to \\fBOn\\fP, readline displays possible completions using different\n+colors to indicate their file type.\n+The color definitions are taken from the value of the \\fBLS_COLORS\\fP\n+environment variable.\n .TP\n .B comment\\-begin (``#'')\n The string that is inserted in \\fBvi\\fP mode when the\n@@ -399,12 +416,19 @@ If set to \\fBOn\\fP, readline will convert characters with the\n eighth bit set to an ASCII key sequence\n by stripping the eighth bit and prefixing it with an\n escape character (in effect, using escape as the \\fImeta prefix\\fP).\n+The default is \\fIOn\\fP, but readline will set it to \\fIOff\\fP if the\n+locale contains eight-bit characters.\n .TP\n .B disable\\-completion (Off)\n If set to \\fBOn\\fP, readline will inhibit word completion.  Completion \n characters will be inserted into the line as if they had been\n mapped to \\fBself-insert\\fP.\n .TP\n+.B echo\\-control\\-characters (On)\n+When set to \\fBOn\\fP, on operating systems that indicate they support it,\n+readline echoes a character corresponding to a signal generated from the\n+keyboard.\n+.TP\n .B editing\\-mode (emacs)\n Controls whether readline begins with a set of key bindings similar\n to \\fIEmacs\\fP or \\fIvi\\fP.\n@@ -414,10 +438,12 @@ can be set to either\n or\n .BR vi .\n .TP\n-.B echo\\-control\\-characters (On)\n-When set to \\fBOn\\fP, on operating systems that indicate they support it,\n-readline echoes a character corresponding to a signal generated from the\n-keyboard.\n+.B enable\\-bracketed\\-paste (Off)\n+When set to \\fBOn\\fP, readline will configure the terminal in a way\n+that will enable it to insert each paste into the editing buffer as a\n+single string of characters, instead of treating each character as if\n+it had been read from the keyboard.  This can prevent pasted characters\n+from being interpreted as editing commands.\n .TP\n .B enable\\-keypad (Off)\n When set to \\fBOn\\fP, readline will try to enable the application\n@@ -438,9 +464,15 @@ If set to \\fBOn\\fP, the history code attempts to place point at the\n same location on each history line retrieved with \\fBprevious-history\\fP \n or \\fBnext-history\\fP.\n .TP\n-.B history\\-size (0)\n-Set the maximum number of history entries saved in the history list.  If\n-set to zero, the number of entries in the history list is not limited.\n+.B history\\-size (unset)\n+Set the maximum number of history entries saved in the history list.\n+If set to zero, any existing history entries are deleted and no new entries\n+are saved.\n+If set to a value less than zero, the number of history entries is not\n+limited.\n+By default, the number of history entries is not limited.\n+If an attempt is made to set \\fIhistory\\-size\\fP to a non-numeric value,\n+the maximum number of history entries will be set to 500.\n .TP\n .B horizontal\\-scroll\\-mode (Off)\n When set to \\fBOn\\fP, makes readline use a single line for display,\n@@ -453,6 +485,8 @@ it will not clear the eighth bit in the characters it reads),\n regardless of what the terminal claims it can support.  The name\n .B meta\\-flag\n is a synonym for this variable.\n+The default is \\fIOff\\fP, but readline will set it to \\fIOn\\fP if the \n+locale contains eight-bit characters.\n .TP\n .B isearch\\-terminators (``C\\-[ C\\-J'')\n The string of characters that should terminate an incremental\n@@ -472,6 +506,28 @@ The value of\n .B editing\\-mode\n also affects the default keymap.\n .TP\n+.B emacs\\-mode\\-string (@)\n+This string is displayed immediately before the last line of the primary\n+prompt when emacs editing mode is active.  The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the \\e1 and \\e2 escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control \n+sequence into the mode string.\n+.TP\n+.B keyseq\\-timeout (500)\n+Specifies the duration \\fIreadline\\fP will wait for a character when reading an\n+ambiguous key sequence (one that can form a complete key sequence using\n+the input read so far, or can take additional input to complete a longer \n+key sequence).\n+If no input is received within the timeout, \\fIreadline\\fP will use the shorter\n+but complete key sequence.\n+The value is specified in milliseconds, so a value of 1000 means that\n+\\fIreadline\\fP will wait one second for additional input.\n+If this variable is set to a value less than or equal to zero, or to a\n+non-numeric value, \\fIreadline\\fP will wait until another key is pressed to\n+decide which key sequence to complete.\n+.TP\n .B mark\\-directories (On)\n If set to \\fBOn\\fP, completed directory names have a slash\n appended.\n@@ -487,7 +543,7 @@ have a slash appended (subject to the value of\n .TP\n .B match\\-hidden\\-files (On)\n This variable, when set to \\fBOn\\fP, causes readline to match files whose \n-names begin with a `.' (hidden files) when performing filename     \n+names begin with a `.' (hidden files) when performing filename\n completion.\n If set to \\fBOff\\fP, the leading `.' must be\n supplied by the user in the filename to be completed.\n@@ -501,6 +557,8 @@ the list.\n If set to \\fBOn\\fP, readline will display characters with the\n eighth bit set directly rather than as a meta-prefixed escape\n sequence.\n+The default is \\fIOff\\fP, but readline will set it to \\fIOn\\fP if the\n+locale contains eight-bit characters.\n .TP\n .B page\\-completions (On)\n If set to \\fBOn\\fP, readline uses an internal \\fImore\\fP-like pager\n@@ -533,6 +591,11 @@ possible partial completion (the possible completions don't share\n a common prefix) cause the matches to be listed immediately instead\n of ringing the bell.\n .TP\n+.B show\\-mode\\-in\\-prompt (Off)\n+If set to \\fBOn\\fP, add a character to the beginning of the prompt\n+indicating the editing mode: emacs, vi command, or vi insertion.\n+The mode strings are user-settable.\n+.TP\n .B skip\\-completed\\-text (Off)\n If set to \\fBOn\\fP, this alters the default completion behavior when\n inserting a single match into the line.  It's only active when\n@@ -541,6 +604,26 @@ does not insert characters from the completion that match characters\n after point in the word being completed, so portions of the word\n following the cursor are not duplicated.\n .TP\n+.B vi\\-cmd\\-mode\\-string ((cmd))\n+This string is displayed immediately before the last line of the primary\n+prompt when vi editing mode is active and in command mode.\n+The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the \\e1 and \\e2 escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control\n+sequence into the mode string.\n+.TP\n+.B vi\\-ins\\-mode\\-string ((ins))\n+This string is displayed immediately before the last line of the primary\n+prompt when vi editing mode is active and in insertion mode.  \n+The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and  \n+backslash escape sequences is available.\n+Use the \\e1 and \\e2 escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control \n+sequence into the mode string.\n+.TP\n .B visible\\-stats (Off)\n If set to \\fBOn\\fP, a character denoting a file's type as reported  \n by \\fIstat\\fP(2) is appended to the filename when listing possible\n@@ -553,7 +636,7 @@ compilation features of the C preprocessor which allows key\n bindings and variable settings to be performed as the result\n of tests.  There are four parser directives used.\n .IP \\fB$if\\fP\n-The \n+The\n .B $if\n construct allows bindings to be made based on the\n editing mode, the terminal being used, or the application using\n@@ -738,15 +821,30 @@ using a non-incremental search for a string supplied by the user.\n Search forward through the history using a non-incremental search\n for a string supplied by the user.\n .TP\n+.B history\\-search\\-backward\n+Search backward through the history for the string of characters\n+between the start of the current line and the current cursor\n+position (the \\fIpoint\\fP).\n+The search string must match at the beginning of a history line.\n+This is a non-incremental search.\n+.TP\n .B history\\-search\\-forward\n Search forward through the history for the string of characters\n+between the start of the current line and the point.\n+The search string must match at the beginning of a history line.\n+This is a non-incremental search.\n+.TP\n+.B history\\-substring\\-search\\-backward\n+Search backward through the history for the string of characters\n between the start of the current line and the current cursor\n position (the \\fIpoint\\fP).\n+The search string may match anywhere in a history line.\n This is a non-incremental search.\n .TP\n-.B history\\-search\\-backward\n-Search backward through the history for the string of characters\n+.B history\\-substring\\-search\\-forward\n+Search forward through the history for the string of characters\n between the start of the current line and the point.\n+The search string may match anywhere in a history line.\n This is a non-incremental search.\n .TP\n .B yank\\-nth\\-arg (M\\-C\\-y)\n@@ -778,13 +876,22 @@ as if the \"!$\" history expansion had been specified.\n .PP\n .PD 0\n .TP\n-.B delete\\-char (C\\-d)\n-Delete the character at point.  If point is at the\n-beginning of the line, there are no characters in the line, and\n-the last character typed was not bound to \\fBdelete\\-char\\fP, then return\n+.B \\fIend\\-of\\-file\\fP (usually C\\-d)\n+The character indicating end-of-file as set, for example, by\n+.if t \\f(CWstty\\fP.\n+.if n ``stty''.\n+If this character is read when there are no characters\n+on the line, and point is at the beginning of the line, Readline\n+interprets it as the end of input and returns\n .SM\n .BR EOF .\n .TP\n+.B delete\\-char (C\\-d)\n+Delete the character at point.\n+If this function is bound to the\n+same character as the tty \\fBEOF\\fP character, as \\fBC\\-d\\fP\n+commonly is, see above for the effects.\n+.TP\n .B backward\\-delete\\-char (Rubout)\n Delete the character behind the cursor.  When given a numeric argument,\n save the deleted text on the kill ring.\n@@ -835,7 +942,7 @@ switches to overwrite mode.  With an explicit non-positive numeric\n argument, switches to insert mode.  This command affects only\n \\fBemacs\\fP mode; \\fBvi\\fP mode does overwrite differently.\n Each call to \\fIreadline()\\fP starts in insert mode.\n-In overwrite mode, characters bound to \\fBself\\-insert\\fP replace   \n+In overwrite mode, characters bound to \\fBself\\-insert\\fP replace\n the text at point rather than pushing the text to the right.\n Characters bound to \\fBbackward\\-delete\\-char\\fP replace the character\n before point with a space.  By default, this command is unbound.\n@@ -858,7 +965,7 @@ The killed text is saved on the kill-ring.\n .B kill\\-whole\\-line\n Kill all characters on the current line, no matter where point is.\n .TP\n-.B kill\\-word  (M\\-d)\n+.B kill\\-word (M\\-d)\n Kill from point the end of the current word, or if between\n words, to the end of the next word.  Word boundaries are the same as\n those used by \\fBforward\\-word\\fP.\n@@ -996,6 +1103,9 @@ and store the definition.\n .B call\\-last\\-kbd\\-macro (C\\-x e)\n Re-execute the last keyboard macro defined, by making the characters\n in the macro appear as if typed at the keyboard.\n+.B print\\-last\\-kbd\\-macro ()\n+Print the last keyboard macro defined in a format suitable for the\n+\\fIinputrc\\fP file.\n .PD\n .SS Miscellaneous\n .PP\n@@ -1062,7 +1172,7 @@ but usually bound to ESC\\-[.\n Without a numeric argument, the value of the readline\n .B comment\\-begin\n variable is inserted at the beginning of the current line.\n-If a numeric argument is supplied, this command acts as a toggle:  if\n+If a numeric argument is supplied, this command acts as a toggle: if\n the characters at the beginning of the line do not match the value   \n of \\fBcomment\\-begin\\fP, the value is inserted, otherwise             \n the characters in \\fBcomment-begin\\fP are deleted from the beginning of\n@@ -1355,7 +1465,7 @@ bfox@gnu.org\n .PP\n Chet Ramey, Case Western Reserve University\n .br\n-chet@ins.CWRU.Edu\n+chet.ramey@case.edu\n .SH BUG REPORTS\n If you find a bug in\n .B readline,\n@@ -1375,7 +1485,7 @@ newsgroup\n .PP\n Comments and bug reports concerning\n this manual page should be directed to\n-.IR chet@ins.CWRU.Edu .\n+.IR chet.ramey@case.edu .\n .SH BUGS\n .PP\n It's too big and too slow."
    },
    {
      "sha": "737f971ddd1d545e341102961ca55b533cf43ba1",
      "filename": "readline/doc/rlman.texi",
      "status": "modified",
      "additions": 7,
      "deletions": 20,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rlman.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rlman.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rlman.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,34 +2,26 @@\n @comment %**start of header (This is for running Texinfo on a region.)\n @setfilename readline.info\n @settitle GNU Readline Library\n+@include version.texi\n+\n @comment %**end of header (This is for running Texinfo on a region.)\n @synindex vr fn\n \n-@include version.texi\n-\n @copying\n This manual describes the GNU Readline Library\n (version @value{VERSION}, @value{UPDATED}), a library which aids in the\n consistency of user interface across discrete programs which provide\n a command line interface.\n \n-Copyright @copyright{} 1988--2011 Free Software Foundation, Inc.\n-\n-Permission is granted to make and distribute verbatim copies of\n-this manual provided the copyright notice and this permission notice\n-are preserved on all copies.\n+Copyright @copyright{} 1988--2016 Free Software Foundation, Inc.\n \n @quotation\n Permission is granted to copy, distribute and/or modify this document\n under the terms of the GNU Free Documentation License, Version 1.3 or\n any later version published by the Free Software Foundation; with no\n-Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',\n-and with the Back-Cover Texts as in (a) below.  A copy of the license is\n-included in the section entitled ``GNU Free Documentation License''.\n-\n-(a) The FSF's Back-Cover Text is: You are free to copy and modify\n-this GNU manual.  Buying copies from GNU Press supports the FSF in\n-developing GNU and promoting software freedom.''\n+Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n+A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n \n @end quotation\n @end copying\n@@ -50,12 +42,6 @@ developing GNU and promoting software freedom.''\n @vskip 0pt plus 1filll\n @insertcopying\n \n-@sp 1\n-Published by the Free Software Foundation @*\n-59 Temple Place, Suite 330, @*\n-Boston, MA 02111-1307 @*\n-USA @*\n-\n @end titlepage\n \n @contents\n@@ -67,6 +53,7 @@ USA @*\n This document describes the GNU Readline Library, a utility which aids\n in the consistency of user interface across discrete programs which\n provide a command line interface.\n+The Readline home page is @url{http://www.gnu.org/software/readline/}.\n \n @menu\n * Command Line Editing::\t   GNU Readline User's Manual."
    },
    {
      "sha": "b8ce90f95d5b64bbe10d0272ad4e680ab4016521",
      "filename": "readline/doc/rltech.texi",
      "status": "modified",
      "additions": 283,
      "deletions": 26,
      "changes": 309,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rltech.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rltech.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rltech.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -7,7 +7,7 @@ This document describes the GNU Readline Library, a utility for aiding\n in the consistency of user interface across discrete programs that need\n to provide a command line interface.\n \n-Copyright (C) 1988--2011 Free Software Foundation, Inc.\n+Copyright (C) 1988--2016 Free Software Foundation, Inc.\n \n Permission is granted to make and distribute verbatim copies of\n this manual provided the copyright notice and this permission notice\n@@ -195,7 +195,7 @@ For Readline 4.2, for example, the value of\n @node Readline Typedefs\n @subsection Readline Typedefs\n \n-For readabilty, we declare a number of new object types, all pointers\n+For readability, we declare a number of new object types, all pointers\n to functions.\n \n The reason for declaring these new types is to make it easier to write\n@@ -282,7 +282,7 @@ At the very least, it should be aware that it can be passed a\n negative argument.\n \n A command function should return 0 if its action completes successfully,\n-and a non-zero value if some error occurs.\n+and a value greater than zero if some error occurs.\n This is the convention obeyed by all of the builtin Readline bindable\n command functions.\n \n@@ -440,6 +440,35 @@ If non-zero, Readline will call indirectly through this pointer\n to get a character from the input stream.  By default, it is set to\n @code{rl_getc}, the default Readline character input function\n (@pxref{Character Input}).\n+In general, an application that sets @var{rl_getc_function} should consider\n+setting @var{rl_input_available_hook} as well.\n+@end deftypevar\n+\n+@deftypevar {rl_hook_func_t *} rl_signal_event_hook\n+If non-zero, this is the address of a function to call if a read system\n+call is interrupted when Readline is reading terminal input.\n+@end deftypevar\n+\n+@deftypevar {rl_hook_func_t *} rl_input_available_hook\n+If non-zero, Readline will use this function's return value when it needs\n+to determine whether or not there is available input on the current input\n+source.\n+The default hook checks @code{rl_instream}; if an application is using a\n+different input source, it should set the hook appropriately.\n+Readline queries for available input when implementing intra-key-sequence\n+timeouts during input and incremental searches.\n+This may use an application-specific timeout before returning a value;\n+Readline uses the value passed to @code{rl_set_keyboard_input_timeout()}\n+or the value of the user-settable @var{keyseq-timeout} variable.\n+This is designed for use by applications using Readline's callback interface\n+(@pxref{Alternate Interface}), which may not use the traditional\n+@code{read(2)} and file descriptor interface, or other applications using\n+a different input mechanism.\n+If an application uses an input mechanism or hook that can potentially exceed\n+the value of @var{keyseq-timeout}, it should increase the timeout or set\n+this hook appropriately even when not using the callback interface.\n+In general, an application that sets @var{rl_getc_function} should consider\n+setting @var{rl_input_available_hook} as well.\n @end deftypevar\n \n @deftypevar {rl_voidfunc_t *} rl_redisplay_function\n@@ -479,6 +508,19 @@ last key binding occurred.\n This variable is set to the text of any currently-executing macro.\n @end deftypevar\n \n+@deftypevar int rl_executing_key\n+The key that caused the dispatch to the currently-executing Readline function.\n+@end deftypevar\n+\n+@deftypevar {char *} rl_executing_keyseq\n+The full key sequence that caused the dispatch to the currently-executing\n+Readline function.\n+@end deftypevar\n+\n+@deftypevar int rl_key_sequence_length\n+The number of characters in @var{rl_executing_keyseq}.\n+@end deftypevar\n+\n @deftypevar {int} rl_readline_state\n A variable with bit values that encapsulate the current Readline state.\n A bit is set with the @code{RL_SETSTATE} macro, and unset with the\n@@ -487,7 +529,7 @@ whether a particular state bit is set.  Current state bits include:\n \n @table @code\n @item RL_STATE_NONE\n-Readline has not yet been called, nor has it begun to intialize.\n+Readline has not yet been called, nor has it begun to initialize.\n @item RL_STATE_INITIALIZING\n Readline is initializing its internal data structures.\n @item RL_STATE_INITIALIZED\n@@ -580,6 +622,7 @@ means that vi mode is active.\n * Miscellaneous Functions::\tFunctions that don't fall into any category.\n * Alternate Interface::\tUsing Readline in a `callback' fashion.\n * A Readline Example::\t\tAn example Readline function.\n+* Alternate Interface Example::\tAn example program using the alternate interface.\n @end menu\n \n @node Function Naming\n@@ -908,7 +951,7 @@ Readline thinks the screen display is correct.\n \n @deftypefun int rl_on_new_line (void)\n Tell the update functions that we have moved onto a new (empty) line,\n-usually after ouputting a newline.\n+usually after outputting a newline.\n @end deftypefun\n \n @deftypefun int rl_on_new_line_with_prompt (void)\n@@ -920,6 +963,10 @@ redisplay.\n It should be used after setting @var{rl_already_prompted}.\n @end deftypefun\n \n+@deftypefun int rl_clear_visible_line (void)\n+Clear the screen lines corresponding to the current line's contents.\n+@end deftypefun\n+\n @deftypefun int rl_reset_line_state (void)\n Reset the display state to a clean state and redisplay the current line\n starting on a new line.\n@@ -977,7 +1024,7 @@ It returns the number of visible characters on the last line of the\n Applications may indicate that the prompt contains characters that take\n up no physical screen space when displayed by bracketing a sequence of\n such characters with the special markers @code{RL_PROMPT_START_IGNORE}\n-and @code{RL_PROMPT_END_IGNORE} (declared in @file{readline.h}.  This may\n+and @code{RL_PROMPT_END_IGNORE} (declared in @file{readline.h}).  This may\n be used to embed terminal-specific escape sequences in prompts.\n @end deftypefun\n \n@@ -1093,6 +1140,14 @@ that the terminal editing characters are bound to @code{rl_insert}.\n The bindings are performed in @var{kmap}.\n @end deftypefun\n \n+@deftypefun int rl_tty_set_echoing (int value)\n+Set Readline's idea of whether or not it is echoing output to its output\n+stream (@var{rl_outstream}).  If @var{value} is 0, Readline does not display\n+output to @var{rl_outstream}; any other value enables output.  The initial\n+value is set when Readline initializes the terminal settings.\n+This function returns the previous value.\n+@end deftypefun\n+\n @deftypefun int rl_reset_terminal (const char *terminal_name)\n Reinitialize Readline's idea of the terminal settings using\n @var{terminal_name} as the terminal type (e.g., @code{vt100}).\n@@ -1241,42 +1296,61 @@ use all of a terminal's capabilities, and this function will return\n values for only those capabilities Readline uses.\n @end deftypefun\n \n+@deftypefun {void} rl_clear_history (void)\n+Clear the history list by deleting all of the entries, in the same manner\n+as the History library's @code{clear_history()} function.\n+This differs from @code{clear_history} because it frees private data\n+Readline saves in the history list.\n+@end deftypefun\n+\n @node Alternate Interface\n @subsection Alternate Interface\n \n An alternate interface is available to plain @code{readline()}.  Some\n applications need to interleave keyboard I/O with file, device, or\n window system I/O, typically by using a main loop to @code{select()}\n-on various file descriptors.  To accomodate this need, readline can\n+on various file descriptors.  To accommodate this need, readline can\n also be invoked as a `callback' function from an event loop.  There\n are functions available to make this easy.\n \n @deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)\n Set up the terminal for readline I/O and display the initial\n expanded value of @var{prompt}.  Save the value of @var{lhandler} to\n-use as a function to call when a complete line of input has been entered.\n-The function takes the text of the line as an argument.\n+use as a handler function to call when a complete line of input has been\n+entered.\n+The handler function receives the text of the line as an argument.\n+As with @code{readline()}, the handler function should @code{free} the\n+line when it it finished with it.\n @end deftypefun\n \n @deftypefun void rl_callback_read_char (void)\n Whenever an application determines that keyboard input is available, it\n should call @code{rl_callback_read_char()}, which will read the next\n character from the current input source.\n If that character completes the line, @code{rl_callback_read_char} will\n-invoke the @var{lhandler} function saved by @code{rl_callback_handler_install}\n-to process the line.\n+invoke the @var{lhandler} function installed by\n+@code{rl_callback_handler_install} to process the line.\n Before calling the @var{lhandler} function, the terminal settings are\n reset to the values they had before calling\n @code{rl_callback_handler_install}.\n If the @var{lhandler} function returns,\n+and the line handler remains installed,\n the terminal settings are modified for Readline's use again.\n-@code{EOF} is  indicated by calling @var{lhandler} with a\n+@code{EOF} is indicated by calling @var{lhandler} with a\n @code{NULL} line.\n @end deftypefun\n \n+@deftypefun void rl_callback_sigcleanup (void)\n+Clean up any internal state the callback interface uses to maintain state\n+between calls to rl_callback_read_char (e.g., the state of any active\n+incremental searches).  This is intended to be used by applications that\n+wish to perform their own signal handling; Readline's internal signal handler\n+calls this when appropriate.\n+@end deftypefun\n+\n @deftypefun void rl_callback_handler_remove (void)\n Restore the terminal to its initial state and remove the line handler.\n-This may be called from within a callback as well as independently.\n+You may call this function from within a callback as well as independently.\n If the @var{lhandler} installed by @code{rl_callback_handler_install}\n does not exit the program, either this function or the function referred\n to by the value of @code{rl_deprep_term_function} should be called before\n@@ -1350,6 +1424,126 @@ invert_case_line (count, key)\n @}\n @end example\n \n+@node Alternate Interface Example\n+@subsection Alternate Interface Example\n+\n+Here is a complete program that illustrates Readline's alternate interface.\n+It reads lines from the terminal and displays them, providing the\n+standard history and TAB completion functions.\n+It understands the EOF character or \"exit\" to exit the program.\n+\n+@example\n+/* Standard include files. stdio.h is required. */\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+#include <locale.h>\n+\n+/* Used for select(2) */\n+#include <sys/types.h>\n+#include <sys/select.h>\n+\n+#include <signal.h>\n+\n+#include <stdio.h>\n+\n+/* Standard readline include files. */\n+#include <readline/readline.h>\n+#include <readline/history.h>\n+\n+static void cb_linehandler (char *);\n+static void sighandler (int);\n+\n+int running;\n+int sigwinch_received;\n+const char *prompt = \"rltest$ \";\n+\n+/* Handle SIGWINCH and window size changes when readline is not active and\n+   reading a character. */\n+static void\n+sighandler (int sig)\n+@{\n+  sigwinch_received = 1;\n+@}\n+\n+/* Callback function called for each line when accept-line executed, EOF\n+   seen, or EOF character read.  This sets a flag and returns; it could\n+   also call exit(3). */\n+static void\n+cb_linehandler (char *line)\n+@{\n+  /* Can use ^D (stty eof) or `exit' to exit. */\n+  if (line == NULL || strcmp (line, \"exit\") == 0)\n+    @{\n+      if (line == 0)\n+        printf (\"\\n\");\n+      printf (\"exit\\n\");\n+      /* This function needs to be called to reset the terminal settings,\n+         and calling it from the line handler keeps one extra prompt from\n+         being displayed. */\n+      rl_callback_handler_remove ();\n+\n+      running = 0;\n+    @}\n+  else\n+    @{\n+      if (*line)\n+        add_history (line);\n+      printf (\"input line: %s\\n\", line);\n+      free (line);\n+    @}\n+@}\n+\n+int\n+main (int c, char **v)\n+@{\n+  fd_set fds;\n+  int r;\n+\n+  /* Set the default locale values according to environment variables. */\n+  setlocale (LC_ALL, \"\");\n+\n+  /* Handle window size changes when readline is not active and reading\n+     characters. */\n+  signal (SIGWINCH, sighandler);\n+\n+  /* Install the line handler. */\n+  rl_callback_handler_install (prompt, cb_linehandler);\n+\n+  /* Enter a simple event loop.  This waits until something is available\n+     to read on readline's input stream (defaults to standard input) and\n+     calls the builtin character read callback to read it.  It does not\n+     have to modify the user's terminal settings. */\n+  running = 1;\n+  while (running)\n+    @{\n+      FD_ZERO (&fds);\n+      FD_SET (fileno (rl_instream), &fds);    \n+\n+      r = select (FD_SETSIZE, &fds, NULL, NULL, NULL);\n+      if (r < 0 && errno != EINTR)\n+        @{\n+          perror (\"rltest: select\");\n+          rl_callback_handler_remove ();\n+          break;\n+        @}\n+      if (sigwinch_received)\n+\t@{\n+\t  rl_resize_terminal ();\n+\t  sigwinch_received = 0;\n+\t@}\n+      if (r < 0)\n+\tcontinue;     \n+\n+      if (FD_ISSET (fileno (rl_instream), &fds))\n+        rl_callback_read_char ();\n+    @}\n+\n+  printf (\"rltest: Event loop has exited\\n\");\n+  return 0;\n+@}\n+@end example\n+\n @node Readline Signal Handling\n @section Readline Signal Handling\n \n@@ -1365,6 +1559,7 @@ functions to do so manually.\n \n Readline contains an internal signal handler that is installed for a\n number of signals (@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM},\n+@code{SIGHUP}, \n @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}).\n When one of these signals is received, the signal handler\n will reset the terminal attributes to those that were in effect before\n@@ -1387,7 +1582,30 @@ resetting the terminal to its original state.  If the application's signal\n handler does more than update its idea of the terminal size and return (for\n example, a @code{longjmp} back to a main processing loop), it @emph{must}\n call @code{rl_cleanup_after_signal()} (described below), to restore the\n-terminal state. \n+terminal state.\n+\n+When an application is using the callback interface\n+(@pxref{Alternate Interface}), Readline installs signal handlers only for\n+the duration of the call to @code{rl_callback_read_char}.  Applications\n+using the callback interface should be prepared to clean up Readline's\n+state if they wish to handle the signal before the line handler completes\n+and restores the terminal state.\n+\n+If an application using the callback interface wishes to have Readline\n+install its signal handlers at the time the application calls\n+@code{rl_callback_handler_install} and remove them only when a complete\n+line of input has been read, it should set the\n+@code{rl_persistent_signal_handlers} variable to a non-zero value.\n+This allows an application to defer all of the handling of the signals\n+Readline catches to Readline.\n+Applications should use this variable with care; it can result in Readline\n+catching signals and not acting on them (or allowing the application to react\n+to them) until the application calls @code{rl_callback_read_char}.  This\n+can result in an application becoming less responsive to keyboard signals\n+like SIGINT.\n+If an application does not want or need to perform any signal handling, or\n+does not need to do any processing between calls to @code{rl_callback_read_char},\n+setting this variable may be desirable.\n \n Readline provides two variables that allow application writers to\n control whether or not it will catch certain signals and act on them\n@@ -1397,25 +1615,48 @@ a signal handler, so Readline's internal signal state is not corrupted.\n \n @deftypevar int rl_catch_signals\n If this variable is non-zero, Readline will install signal handlers for\n-@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM}, @code{SIGALRM},\n+@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM}, @code{SIGHUP}, @code{SIGALRM},\n @code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}.\n \n The default value of @code{rl_catch_signals} is 1.\n @end deftypevar\n \n @deftypevar int rl_catch_sigwinch\n-If this variable is non-zero, Readline will install a signal handler for\n-@code{SIGWINCH}.\n+If this variable is set to a non-zero value,\n+Readline will install a signal handler for @code{SIGWINCH}.\n \n The default value of @code{rl_catch_sigwinch} is 1.\n @end deftypevar\n \n+@deftypevar int rl_persistent_signal_handlers\n+If an application using the callback interface wishes Readline's signal\n+handlers to be installed and active during the set of calls to\n+@code{rl_callback_read_char} that constitutes an entire single line,\n+it should set this variable to a non-zero value.\n+\n+The default value of @code{rl_persistent_signal_handlers} is 0.\n+@end deftypevar\n+\n+@deftypevar int rl_change_environment\n+If this variable is set to a non-zero value,\n+and Readline is handling @code{SIGWINCH}, Readline will modify the\n+@var{LINES} and @var{COLUMNS} environment variables upon receipt of a\n+@code{SIGWINCH}\n+\n+The default value of @code{rl_change_environment} is 1.\n+@end deftypevar\n+\n If an application does not wish to have Readline catch any signals, or\n to handle signals other than those Readline catches (@code{SIGHUP},\n for example), \n Readline provides convenience functions to do the necessary terminal\n and internal state cleanup upon receipt of a signal.\n \n+@deftypefun int rl_pending_signal (void)\n+Return the signal number of the most recent signal Readline received but\n+has not yet handled, or 0 if there is no pending signal.\n+@end deftypefun\n+\n @deftypefun void rl_cleanup_after_signal (void)\n This function will reset the state of the terminal to what it was before\n @code{readline()} was called, and remove the Readline signal handlers for\n@@ -1477,7 +1718,7 @@ The following functions install and remove Readline's signal handlers.\n \n @deftypefun int rl_set_signals (void)\n Install Readline's signal handler for @code{SIGINT}, @code{SIGQUIT},\n-@code{SIGTERM}, @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN},\n+@code{SIGTERM}, @code{SIGHUP}, @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN},\n @code{SIGTTOU}, and @code{SIGWINCH}, depending on the values of\n @code{rl_catch_signals} and @code{rl_catch_sigwinch}.\n @end deftypefun\n@@ -1611,7 +1852,7 @@ This calls @code{rl_complete_internal()} with an argument of @samp{*}.\n @end deftypefun\n \n @deftypefun int rl_completion_mode (rl_command_func_t *cfunc)\n-Returns the apppriate value to pass to @code{rl_complete_internal()}\n+Returns the appropriate value to pass to @code{rl_complete_internal()}\n depending on whether @var{cfunc} was called twice in succession and\n the values of the @code{show-all-if-ambiguous} and\n @code{show-all-if-unmodified} variables.\n@@ -1728,29 +1969,45 @@ the directory portion of the pathname the user typed.\n At the least, even if no other expansion is performed, this function should\n remove any quote characters from the directory name, because its result will\n be passed directly to @code{opendir()}.\n+\n The directory completion hook returns an integer that should be non-zero if\n the function modifies its directory argument.\n The function should not modify the directory argument if it returns 0.\n @end deftypevar\n \n-@ignore\n-@deftypevar extern rl_icppfunc_t *rl_directory_rewrite_hook;\n+@deftypevar {rl_icppfunc_t *} rl_directory_rewrite_hook;\n If non-zero, this is the address of a function to call when completing\n a directory name.  This function takes the address of the directory name\n to be modified as an argument.  Unlike @code{rl_directory_completion_hook},\n it only modifies the directory name used in @code{opendir}, not what is\n displayed when the possible completions are printed or inserted.  It is\n called before rl_directory_completion_hook.\n+At the least, even if no other expansion is performed, this function should\n+remove any quote characters from the directory name, because its result will\n+be passed directly to @code{opendir()}.\n \n-I'm not happy with how this works yet, so it's undocumented.\n+The directory rewrite hook returns an integer that should be non-zero if\n+the function modfies its directory argument.\n+The function should not modify the directory argument if it returns 0.\n+@end deftypevar\n+\n+@deftypevar {rl_icppfunc_t *} rl_filename_stat_hook\n+If non-zero, this is the address of a function for the completer to\n+call before deciding which character to append to a completed name.\n+This function modifies its filename name argument, and the modified value\n+is passed to @code{stat()} to determine the file's type and characteristics.\n+This function does not need to remove quote characters from the filename.\n+\n+The stat hook returns an integer that should be non-zero if\n+the function modfies its directory argument.\n+The function should not modify the directory argument if it returns 0.\n @end deftypevar\n-@end ignore\n \n @deftypevar {rl_dequote_func_t *} rl_filename_rewrite_hook\n If non-zero, this is the address of a function called when reading\n directory entries from the filesystem for completion and comparing\n them to the partial word to be completed.  The function should\n-perform any necesary application or system-specific conversion on\n+perform any necessary application or system-specific conversion on\n the filename, such as converting between character sets or converting\n from a filesystem format to a character input format.\n The function takes two arguments: @var{fname}, the filename to be converted,\n@@ -1772,8 +2029,8 @@ where @var{matches} is the array of matching strings,\n @var{num_matches} is the number of strings in that array, and\n @var{max_length} is the length of the longest string in that array.\n Readline provides a convenience function, @code{rl_display_match_list},\n-that takes care of doing the display to Readline's output stream.  That\n-function may be called from this hook.\n+that takes care of doing the display to Readline's output stream.\n+You may call that function from this hook.\n @end deftypevar\n \n @deftypevar {const char *} rl_basic_word_break_characters"
    },
    {
      "sha": "4c094c88c69bd19dfe9c5124d8331fa295413da0",
      "filename": "readline/doc/rluser.texi",
      "status": "modified",
      "additions": 310,
      "deletions": 35,
      "changes": 345,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rluser.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rluser.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rluser.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -9,7 +9,7 @@ use these features.  There is a document entitled \"readline.texinfo\"\n which contains both end-user and programmer documentation for the\n GNU Readline Library.\n \n-Copyright (C) 1988--2011 Free Software Foundation, Inc.\n+Copyright (C) 1988--2016 Free Software Foundation, Inc.\n \n Authored by Brian Fox and Chet Ramey.\n \n@@ -72,6 +72,8 @@ Line editing can be enabled at any time using the @option{-o emacs} or\n \t\t\t\ta specific command.\n * Programmable Completion Builtins::\tBuiltin commands to specify how to\n \t\t\t\tcomplete arguments for a particular command.\n+* A Programmable Completion Example::\tAn example shell function for\n+\t\t\t\tgenerating possible completions.\n @end ifset\n @end menu\n \n@@ -421,9 +423,31 @@ the terminal's bell.\n \n @item bind-tty-special-chars\n @vindex bind-tty-special-chars\n-If set to @samp{on}, Readline attempts to bind the control characters  \n-treated specially by the kernel's terminal driver to their Readline\n-equivalents.\n+If set to @samp{on} (the default), Readline attempts to bind the control\n+characters   treated specially by the kernel's terminal driver to their\n+Readline equivalents.\n+\n+@item blink-matching-paren\n+@vindex blink-matching-paren\n+If set to @samp{on}, Readline attempts to briefly move the cursor to an\n+opening parenthesis when a closing parenthesis is inserted.  The default\n+is @samp{off}.\n+\n+@item colored-completion-prefix\n+@vindex colored-completion-prefix\n+If set to @samp{on}, when listing completions, Readline displays the\n+common prefix of the set of possible completions using a different color.\n+The color definitions are taken from the value of the @env{LS_COLORS}\n+environment variable.\n+The default is @samp{off}.\n+\n+@item colored-stats\n+@vindex colored-stats\n+If set to @samp{on}, Readline displays possible completions using different\n+colors to indicate their file type.\n+The color definitions are taken from the value of the @env{LS_COLORS}\n+environment variable.\n+The default is @samp{off}.\n \n @item comment-begin\n @vindex comment-begin\n@@ -475,25 +499,47 @@ The default limit is @code{100}.\n If set to @samp{on}, Readline will convert characters with the\n eighth bit set to an @sc{ascii} key sequence by stripping the eighth\n bit and prefixing an @key{ESC} character, converting them to a\n-meta-prefixed key sequence.  The default value is @samp{on}.\n+meta-prefixed key sequence.  The default value is @samp{on}, but\n+will be set to @samp{off} if the locale is one that contains\n+eight-bit characters.\n \n @item disable-completion\n @vindex disable-completion\n If set to @samp{On}, Readline will inhibit word completion.\n Completion  characters will be inserted into the line as if they had\n been mapped to @code{self-insert}.  The default is @samp{off}.\n \n+@item echo-control-characters\n+@vindex echo-control-characters\n+When set to @samp{on}, on operating systems that indicate they support it,\n+readline echoes a character corresponding to a signal generated from the\n+keyboard.  The default is @samp{on}.\n+\n @item editing-mode\n @vindex editing-mode\n The @code{editing-mode} variable controls which default set of\n key bindings is used.  By default, Readline starts up in Emacs editing\n mode, where the keystrokes are most similar to Emacs.  This variable can be\n set to either @samp{emacs} or @samp{vi}.\n \n-@item echo-control-characters\n-When set to @samp{on}, on operating systems that indicate they support it,\n-readline echoes a character corresponding to a signal generated from the\n-keyboard.  The default is @samp{on}.\n+@item emacs-mode-string\n+@vindex emacs-mode-string\n+This string is displayed immediately before the last line of the primary\n+prompt when emacs editing mode is active.  The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the @samp{\\1} and @samp{\\2} escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control\n+sequence into the mode string.\n+The default is @samp{@@}.\n+\n+@item enable-bracketed-paste\n+@vindex enable-bracketed-paste\n+When set to @samp{On}, Readline will configure the terminal in a way\n+that will enable it to insert each paste into the editing buffer as a\n+single string of characters, instead of treating each character as if\n+it had been read from the keyboard.  This can prevent pasted characters\n+from being interpreted as editing commands.  The default is @samp{off}.\n \n @item enable-keypad\n @vindex enable-keypad\n@@ -521,8 +567,14 @@ or @code{next-history}.  The default is @samp{off}.\n \n @item history-size\n @vindex history-size\n-Set the maximum number of history entries saved in the history list.  If\n-set to zero, the number of entries in the history list is not limited.\n+Set the maximum number of history entries saved in the history list.\n+If set to zero, any existing history entries are deleted and no new entries\n+are saved.\n+If set to a value less than zero, the number of history entries is not\n+limited.\n+By default, the number of history entries is not limited.\n+If an attempt is made to set @var{history-size} to a non-numeric value,\n+the maximum number of history entries will be set to 500.\n \n @item horizontal-scroll-mode\n @vindex horizontal-scroll-mode\n@@ -538,8 +590,9 @@ this variable is set to @samp{off}.\n If set to @samp{on}, Readline will enable eight-bit input (it\n will not clear the eighth bit in the characters it reads),\n regardless of what the terminal claims it can support.  The\n-default value is @samp{off}.  The name @code{meta-flag} is a\n-synonym for this variable.\n+default value is @samp{off}, but Readline will set it to @samp{on} if the \n+locale contains eight-bit characters.\n+The name @code{meta-flag} is a synonym for this variable.\n \n @item isearch-terminators\n @vindex isearch-terminators\n@@ -560,11 +613,28 @@ Acceptable @code{keymap} names are\n @code{vi-move},\n @code{vi-command}, and\n @code{vi-insert}.\n-@code{vi} is equivalent to @code{vi-command}; @code{emacs} is\n-equivalent to @code{emacs-standard}.  The default value is @code{emacs}.\n+@code{vi} is equivalent to @code{vi-command} (@code{vi-move} is also a\n+synonym); @code{emacs} is equivalent to @code{emacs-standard}.\n+The default value is @code{emacs}.\n The value of the @code{editing-mode} variable also affects the\n default keymap.\n \n+@item keyseq-timeout\n+Specifies the duration Readline will wait for a character when reading an\n+ambiguous key sequence (one that can form a complete key sequence using\n+the input read so far, or can take additional input to complete a longer\n+key sequence).\n+If no input is received within the timeout, Readline will use the shorter\n+but complete key sequence.\n+Readline uses this value to determine whether or not input is\n+available on the current input source (@code{rl_instream} by default).\n+The value is specified in milliseconds, so a value of 1000 means that\n+Readline will wait one second for additional input.\n+If this variable is set to a value less than or equal to zero, or to a\n+non-numeric value, Readline will wait until another key is pressed to\n+decide which key sequence to complete.\n+The default value is @code{500}.\n+\n @item mark-directories\n If set to @samp{on}, completed directory names have a slash\n appended.  The default is @samp{on}.\n@@ -601,7 +671,9 @@ the list.  The default is @samp{off}.\n @vindex output-meta\n If set to @samp{on}, Readline will display characters with the\n eighth bit set directly rather than as a meta-prefixed escape\n-sequence.  The default is @samp{off}.\n+sequence.\n+The default is @samp{off}, but Readline will set it to @samp{on} if the\n+locale contains eight-bit characters.\n \n @item page-completions\n @vindex page-completions\n@@ -640,6 +712,13 @@ a common prefix) cause the matches to be listed immediately instead\n of ringing the bell.\n The default value is @samp{off}.\n \n+@item show-mode-in-prompt\n+@vindex show-mode-in-prompt\n+If set to @samp{on}, add a character to the beginning of the prompt\n+indicating the editing mode: emacs, vi command, or vi insertion.\n+The mode strings are user-settable.\n+The default value is @samp{off}.\n+\n @item skip-completed-text\n @vindex skip-completed-text\n If set to @samp{on}, this alters the default completion behavior when\n@@ -654,6 +733,30 @@ rather than @samp{Makefilefile}, assuming there is a single possible\n completion.\n The default value is @samp{off}.\n \n+@item vi-cmd-mode-string\n+@vindex vi-cmd-mode-string\n+This string is displayed immediately before the last line of the primary\n+prompt when vi editing mode is active and in command mode.\n+The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the @samp{\\1} and @samp{\\2} escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control\n+sequence into the mode string.\n+The default is @samp{(cmd)}.\n+\n+@item vi-ins-mode-string\n+@vindex vi-ins-mode-string\n+This string is displayed immediately before the last line of the primary\n+prompt when vi editing mode is active and in insertion mode.\n+The value is expanded like a\n+key binding, so the standard set of meta- and control prefixes and\n+backslash escape sequences is available.\n+Use the @samp{\\1} and @samp{\\2} escapes to begin and end sequences of\n+non-printing characters, which can be used to embed a terminal control\n+sequence into the mode string.\n+The default is @samp{(ins)}.\n+\n @item visible-stats\n @vindex visible-stats\n If set to @samp{on}, a character denoting a file's type\n@@ -880,7 +983,7 @@ binding, variable assignment, and conditional syntax.\n # You can re-read the inputrc file with C-x C-r.\n # Lines beginning with '#' are comments.\n #\n-# First, include any systemwide bindings and variable\n+# First, include any system-wide bindings and variable\n # assignments from /etc/Inputrc\n $include /etc/Inputrc\n \n@@ -1085,28 +1188,47 @@ the history as necessary.  This is an incremental search.\n \n @item forward-search-history (C-s)\n Search forward starting at the current line and moving `down' through\n-the the history as necessary.  This is an incremental search.\n+the history as necessary.  This is an incremental search.\n \n @item non-incremental-reverse-search-history (M-p)\n Search backward starting at the current line and moving `up'\n through the history as necessary using a non-incremental search\n for a string supplied by the user.\n+The search string may match anywhere in a history line.\n \n @item non-incremental-forward-search-history (M-n)\n Search forward starting at the current line and moving `down'\n-through the the history as necessary using a non-incremental search\n+through the history as necessary using a non-incremental search\n for a string supplied by the user.\n+The search string may match anywhere in a history line.\n \n @item history-search-forward ()\n Search forward through the history for the string of characters\n between the start of the current line and the point.\n+The search string must match at the beginning of a history line.\n This is a non-incremental search.\n By default, this command is unbound.\n \n @item history-search-backward ()\n Search backward through the history for the string of characters\n-between the start of the current line and the point.  This\n-is a non-incremental search.  By default, this command is unbound.\n+between the start of the current line and the point.\n+The search string must match at the beginning of a history line.\n+This is a non-incremental search.\n+By default, this command is unbound.\n+\n+@item history-substr-search-forward ()\n+Search forward through the history for the string of characters\n+between the start of the current line and the point.\n+The search string may match anywhere in a history line.\n+This is a non-incremental search.\n+By default, this command is unbound.\n+\n+@item history-substr-search-backward ()\n+Search backward through the history for the string of characters\n+between the start of the current line and the point.\n+The search string may match anywhere in a history line.\n+This is a non-incremental search.\n+By default, this command is unbound.\n \n @item yank-nth-arg (M-C-y)\n Insert the first argument to the previous command (usually\n@@ -1137,11 +1259,17 @@ as if the @samp{!$} history expansion had been specified.\n @subsection Commands For Changing Text\n \n @ftable @code\n+\n+@item @i{end-of-file} (usually C-d)\n+The character indicating end-of-file as set, for example, by\n+@code{stty}.  If this character is read when there are no characters\n+on the line, and point is at the beginning of the line, Readline\n+interprets it as the end of input and returns @sc{eof}.\n+\n @item delete-char (C-d)\n-Delete the character at point.  If point is at the\n-beginning of the line, there are no characters in the line, and\n-the last character typed was not bound to @code{delete-char}, then\n-return @sc{eof}.\n+Delete the character at point.  If this function is bound to the\n+same character as the tty @sc{eof} character, as @kbd{C-d}\n+commonly is, see above for the effects.\n \n @item backward-delete-char (Rubout)\n Delete the character behind the cursor.  A numeric argument means\n@@ -1164,6 +1292,14 @@ Insert a tab character.\n @item self-insert (a, b, A, 1, !, @dots{})\n Insert yourself.\n \n+@item bracketed-paste-begin ()\n+This function is intended to be bound to the \"bracketed paste\" escape\n+sequence sent by some terminals, and such a binding is assigned by default.\n+It allows Readline to insert the pasted text as a single unit without treating\n+each character as if it had been read from the keyboard.  The characters\n+are inserted as if each one was bound to @code{self-insert}) instead of\n+executing any editing commands.\n+\n @item transpose-chars (C-t)\n Drag the character before the cursor forward over\n the character at the cursor, moving the\n@@ -1215,7 +1351,7 @@ By default, this command is unbound.\n Kill the text from point to the end of the line.\n \n @item backward-kill-line (C-x Rubout)\n-Kill backward to the beginning of the line.\n+Kill backward from the cursor to the beginning of the current line.\n \n @item unix-line-discard (C-u)\n Kill backward from the cursor to the beginning of the current line.\n@@ -1297,7 +1433,7 @@ leading minus sign, those digits define the argument.\n If the command is followed by digits, executing @code{universal-argument}\n again ends the numeric argument, but is otherwise ignored.\n As a special case, if this command is immediately followed by a\n-character that is neither a digit or minus sign, the argument count\n+character that is neither a digit nor minus sign, the argument count\n for the next command is multiplied by four.\n The argument count is initially one, so executing this function the\n first time makes the argument count four, a second time makes the\n@@ -1435,6 +1571,10 @@ and save the definition.\n Re-execute the last keyboard macro defined, by making the characters\n in the macro appear as if typed at the keyboard.\n \n+@item print-last-kbd-macro ()\n+Print the last keboard macro defined in a format suitable for the\n+@var{inputrc} file.\n+\n @end ftable\n \n @node Miscellaneous Commands\n@@ -1693,10 +1833,11 @@ When the command or function is invoked, the @env{COMP_LINE},\n assigned values as described above (@pxref{Bash Variables}).\n If a shell function is being invoked, the @env{COMP_WORDS} and\n @env{COMP_CWORD} variables are also set.\n-When the function or command is invoked, the first argument is the\n+When the function or command is invoked, the first argument ($1) is the\n name of the command whose arguments are being completed, the\n-second argument is the word being completed, and the third argument\n-is the word preceding the word being completed on the current command line.\n+second argument ($2) is the word being completed, and the third argument\n+($3) is the word preceding the word being completed on the current command\n+line.\n No filtering of the generated completions against the word being completed\n is performed; the function or command has complete freedom in generating\n the matches.\n@@ -1706,7 +1847,7 @@ The function may use any of the shell facilities, including the\n @code{compgen} and @code{compopt} builtins described below\n (@pxref{Programmable Completion Builtins}), to generate the matches.\n It must put the possible completions in the @env{COMPREPLY} array\n-variable.\n+variable, one per array element.\n \n Next, any command specified with the @option{-C} option is invoked\n in an environment equivalent to command substitution.\n@@ -1723,6 +1864,10 @@ is removed before attempting a match.\n Any completion that matches the pattern will be removed from the list.\n A leading @samp{!} negates the pattern; in this case any completion\n not matching the pattern will be removed.\n+If the @code{nocasematch} shell option\n+(see the description of @code{shopt} in @ref{The Shopt Builtin})\n+is enabled, the match is performed without regard to the case\n+of alphabetic characters.\n \n Finally, any prefix and suffix specified with the @option{-P} and @option{-S}\n options are added to each member of the completion list, and the result is\n@@ -1774,17 +1919,18 @@ completion function would load completions dynamically:\n @example\n _completion_loader()\n @{\n-\t. \"/etc/bash_completion.d/$1.sh\" >/dev/null 2>&1 && return 124\n+    . \"/etc/bash_completion.d/$1.sh\" >/dev/null 2>&1 && return 124\n @}\n-complete -D -F _completion_loader\n+complete -D -F _completion_loader -o bashdefault -o default\n @end example\n \n @node Programmable Completion Builtins\n @section Programmable Completion Builtins\n @cindex completion builtins\n \n-Two builtin commands are available to manipulate the programmable completion\n-facilities.\n+Three builtin commands are available to manipulate the programmable completion\n+facilities: one to specify how the arguments to a particular command are to\n+be completed, and two to modify the completion as it is happening.\n \n @table @code\n @item compgen\n@@ -1871,6 +2017,13 @@ quoting special characters, or suppressing trailing spaces).\n This option is intended to be used with shell functions specified\n with @option{-F}.\n \n+@item noquote\n+Tell Readline not to quote the completed words if they are filenames\n+(quoting filenames is the default).\n+\n+@item nosort\n+Tell Readline not to sort the list of possible completions alphabetically.\n+\n @item nospace\n Tell Readline not to append a space (the default) to words completed at\n the end of the line.\n@@ -1970,6 +2123,10 @@ used as the possible completions.\n @item -F @var{function}\n The shell function @var{function} is executed in the current shell\n environment.\n+When it is executed, $1 is the name of the command whose arguments are\n+being completed, $2 is the word being completed, and $3 is the word\n+preceding the word being completed, as described above\n+(@pxref{Programmable Completion}).\n When it finishes, the possible completions are retrieved from the value\n of the @env{COMPREPLY} array variable.\n \n@@ -2034,4 +2191,122 @@ specification exists, or an output error occurs.\n \n @end table\n \n+@node A Programmable Completion Example\n+@section A Programmable Completion Example\n+\n+The most common way to obtain additional completion functionality beyond\n+the default actions @code{complete} and @code{compgen} provide is to use\n+a shell function and bind it to a particular command using @code{complete -F}.\n+\n+The following function provides completions for the @code{cd} builtin.\n+It is a reasonably good example of what shell functions must do when\n+used for completion.  This function uses the word passsed as @code{$2}\n+to determine the directory name to complete.  You can also use the\n+@code{COMP_WORDS} array variable; the current word is indexed by the\n+@code{COMP_CWORD} variable.\n+\n+The function relies on the @code{complete} and @code{compgen} builtins\n+to do much of the work, adding only the things that the Bash @code{cd}\n+does beyond accepting basic directory names:\n+tilde expansion (@pxref{Tilde Expansion}),\n+searching directories in @var{$CDPATH}, which is described above\n+(@pxref{Bourne Shell Builtins}),\n+and basic support for the @code{cdable_vars} shell option\n+(@pxref{The Shopt Builtin}).\n+@code{_comp_cd} modifies the value of @var{IFS} so that it contains only\n+a newline to accommodate file names containing spaces and tabs --\n+@code{compgen} prints the possible completions it generates one per line.\n+\n+Possible completions go into the @var{COMPREPLY} array variable, one\n+completion per array element.  The programmable completion system retrieves\n+the completions from there when the function returns.\n+\n+@example\n+# A completion function for the cd builtin\n+# based on the cd completion function from the bash_completion package\n+_comp_cd()\n+@{\n+    local IFS=$' \\t\\n'    # normalize IFS\n+    local cur _skipdot _cdpath\n+    local i j k\n+\n+    # Tilde expansion, with side effect of expanding tilde to full pathname\n+    case \"$2\" in\n+    \\~*)    eval cur=\"$2\" ;;\n+    *)      cur=$2 ;;\n+    esac\n+\n+    # no cdpath or absolute pathname -- straight directory completion\n+    if [[ -z \"$@{CDPATH:-@}\" ]] || [[ \"$cur\" == @@(./*|../*|/*) ]]; then\n+        # compgen prints paths one per line; could also use while loop\n+        IFS=$'\\n'\n+        COMPREPLY=( $(compgen -d -- \"$cur\") )\n+        IFS=$' \\t\\n'\n+    # CDPATH+directories in the current directory if not in CDPATH\n+    else\n+        IFS=$'\\n'\n+        _skipdot=false\n+        # preprocess CDPATH to convert null directory names to .\n+        _cdpath=$@{CDPATH/#:/.:@}\n+        _cdpath=$@{_cdpath//::/:.:@}\n+        _cdpath=$@{_cdpath/%:/:.@}\n+        for i in $@{_cdpath//:/$'\\n'@}; do\n+            if [[ $i -ef . ]]; then _skipdot=true; fi\n+            k=\"$@{#COMPREPLY[@@]@}\"\n+            for j in $( compgen -d -- \"$i/$cur\" ); do\n+                COMPREPLY[k++]=$@{j#$i/@}        # cut off directory\n+            done\n+        done\n+        $_skipdot || COMPREPLY+=( $(compgen -d -- \"$cur\") )\n+        IFS=$' \\t\\n'\n+    fi\n+\n+    # variable names if appropriate shell option set and no completions\n+    if shopt -q cdable_vars && [[ $@{#COMPREPLY[@@]@} -eq 0 ]]; then\n+        COMPREPLY=( $(compgen -v -- \"$cur\") )\n+    fi\n+\n+    return 0\n+@}\n+@end example\n+\n+We install the completion function using the @option{-F} option to\n+@code{complete}:\n+\n+@example\n+# Tell readline to quote appropriate and append slashes to directories;\n+# use the bash default completion for other arguments\n+complete -o filenames -o nospace -o bashdefault -F _comp_cd cd\n+@end example\n+\n+@noindent\n+Since we'd like Bash and Readline to take care of some\n+of the other details for us, we use several other options to tell Bash\n+and Readline what to do.  The @option{-o filenames} option tells Readline\n+that the possible completions should be treated as filenames, and quoted\n+appropriately.  That option will also cause Readline to append a slash to\n+filenames it can determine are directories (which is why we might want to\n+extend @code{_comp_cd} to append a slash if we're using directories found\n+via @var{CDPATH}: Readline can't tell those completions are directories).\n+The @option{-o nospace} option tells Readline to not append a space\n+character to the directory name, in case we want to append to it.\n+The @option{-o bashdefault} option brings in the rest of the \"Bash default\"\n+completions -- possible completion that Bash adds to the default Readline\n+set.  These include things like command name completion, variable completion\n+for words beginning with @samp{@{}, completions containing pathname\n+expansion patterns (@pxref{Filename Expansion}), and so on.\n+\n+Once installed using @code{complete}, @code{_comp_cd} will be called every\n+time we attempt word completion for a @code{cd} command.\n+\n+Many more examples -- an extensive collection of completions for most of\n+the common GNU, Unix, and Linux commands -- are available as part of the\n+bash_completion project.  This is installed by default on many GNU/Linux\n+distributions.  Originally written by Ian Macdonald, the project now lives\n+at @url{http://bash-completion.alioth.debian.org/}.  There are ports for\n+other systems such as Solaris and Mac OS X.\n+\n+An older version of the bash_completion package is distributed with bash\n+in the @file{examples/complete} subdirectory.\n+\n @end ifset"
    },
    {
      "sha": "b5754389eb2a6e439ae0cb8ec5a3e3abef276849",
      "filename": "readline/doc/rluserman.texi",
      "status": "modified",
      "additions": 7,
      "deletions": 20,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rluserman.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/rluserman.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/rluserman.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,33 +2,25 @@\n @comment %**start of header (This is for running Texinfo on a region.)\n @setfilename rluserman.info\n @settitle GNU Readline Library\n-@comment %**end of header (This is for running Texinfo on a region.)\n-\n @include version.texi\n \n+@comment %**end of header (This is for running Texinfo on a region.)\n+\n @copying\n This manual describes the end user interface of the GNU Readline Library\n (version @value{VERSION}, @value{UPDATED}), a library which aids in the\n consistency of user interface across discrete programs which provide\n a command line interface.\n \n-Copyright @copyright{} 1988--2011 Free Software Foundation, Inc.\n-\n-Permission is granted to make and distribute verbatim copies of\n-this manual provided the copyright notice and this permission notice\n-are preserved on all copies.\n+Copyright @copyright{} 1988--2016 Free Software Foundation, Inc.\n \n @quotation\n Permission is granted to copy, distribute and/or modify this document\n under the terms of the GNU Free Documentation License, Version 1.3 or\n any later version published by the Free Software Foundation; with no\n-Invariant Sections, with the Front-Cover texts being ``A GNU Manual'',\n-and with the Back-Cover Texts as in (a) below.  A copy of the license is\n-included in the section entitled ``GNU Free Documentation License''.\n-\n-(a) The FSF's Back-Cover Text is: You are free to copy and modify\n-this GNU manual.  Buying copies from GNU Press supports the FSF in\n-developing GNU and promoting software freedom.''\n+Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.\n+A copy of the license is included in the section entitled\n+``GNU Free Documentation License''.\n \n @end quotation\n @end copying\n@@ -49,12 +41,6 @@ developing GNU and promoting software freedom.''\n @vskip 0pt plus 1filll\n @insertcopying\n \n-@sp 1\n-Published by the Free Software Foundation @*\n-59 Temple Place, Suite 330, @*\n-Boston, MA 02111-1307 @*\n-USA @*\n-\n @end titlepage\n \n @contents\n@@ -66,6 +52,7 @@ USA @*\n This document describes the end user interface of the GNU Readline Library,\n a utility which aids in the consistency of user interface across discrete\n programs which provide a command line interface.\n+The Readline home page is @url{http://www.gnu.org/software/readline/}.\n \n @menu\n * Command Line Editing::\t   GNU Readline User's Manual."
    },
    {
      "sha": "173e8ab4bb518c0f97d90e72f505c6cea2ef6e42",
      "filename": "readline/doc/texi2dvi",
      "status": "modified",
      "additions": 1811,
      "deletions": 525,
      "changes": 2336,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/texi2dvi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/texi2dvi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/texi2dvi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,119 +1,1634 @@\n #! /bin/sh\n-# texi2dvi --- produce DVI (or PDF) files from Texinfo (or LaTeX) sources.\n-# $Id$\n+# texi2dvi --- produce DVI (or PDF) files from Texinfo (or (La)TeX) sources.\n+# $Id: texi2dvi 5704 2014-07-07 17:45:16Z karl $\n #\n-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001,\n-# 2002, 2003 Free Software Foundation, Inc.\n+# Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014\n+# Free Software Foundation, Inc.\n #\n-#   This program is free software: you can redistribute it and/or modify\n-#   it under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License,\n+# or (at your option) any later version.\n #\n-#   This program is distributed in the hope that it will be useful,\n-#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-#   GNU General Public License for more details.\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n #\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n #\n-# Original author: Noah Friedman <friedman@gnu.org>.\n+# Originally written by Noah Friedman.\n #\n # Please send bug reports, etc. to bug-texinfo@gnu.org.\n # If possible, please send a copy of the output of the script called with\n # the `--debug' option when making a bug report.\n \n-# This string is expanded by rcs automatically when this file is checked out.\n-rcs_revision='$Revision$'\n+test -f /bin/ksh && test -z \"$RUNNING_KSH\" \\\n+  && { UNAMES=`uname -s`; test \"x$UNAMES\" = xULTRIX; } 2>/dev/null \\\n+  && { RUNNING_KSH=true; export RUNNING_KSH; exec /bin/ksh $0 ${1+\"$@\"}; }\n+unset RUNNING_KSH\n+\n+# No failure shall remain unpunished.\n+set -e\n+\n+# In case the default sed doesn't suffice.\n+: ${SED=sed}\n+\n+# This string is expanded automatically when this file is checked out.\n+rcs_revision='$Revision: 5704 $'\n rcs_version=`set - $rcs_revision; echo $2`\n-program=`echo $0 | sed -e 's!.*/!!'`\n-version=\"texi2dvi (GNU Texinfo 4.5) $rcs_version\n+program=`echo $0 | $SED -e 's!.*/!!'`\n+\n+build_mode=${TEXI2DVI_BUILD_MODE:-local}\n+build_dir=${TEXI2DVI_BUILD_DIRECTORY:-.}\n+\n+# Initialize variables for option overriding and otherwise.\n+# Don't use `unset' since old bourne shells don't have this command.\n+# Instead, assign them an empty value.\n+action=compile\n+batch=false     # interact normally\n+catcode_special=maybe\n+debug=false\n+escape=\"\\\\\"\n+expand=false    # true for expansion via makeinfo\n+includes=\n+line_error=true # pass --file-line-error to TeX\n+max_iters=7     # when to quit\n+oname=          # --output\n+out_lang=dvi\n+quiet=false     # let the tools' message be displayed\n+set_language=\n+src_specials=\n+shell_escape=\n+latex2html=hevea  # or set to tex4ht\n+textra=         # Extra TeX commands to insert in the input file.\n+txiprereq=19990129 # minimum texinfo.tex version with macro expansion\n+verb=false      # true for verbose mode\n+translate_file= # name of charset translation file\n+\n+orig_pwd=`pwd`\n+\n+# We have to initialize IFS to space tab newline since we save and\n+# restore IFS and apparently POSIX allows stupid/broken behavior with\n+# empty-but-set IFS.\n+# http://lists.gnu.org/archive/html/automake-patches/2006-05/msg00008.html\n+# We need space, tab and new line, in precisely that order.  And don't leave\n+# trailing blanks.\n+space=' '\n+tab='\t'\n+newline='\n+'\n+IFS=\"$space$tab$newline\"\n+\n+# In case someone pedantic insists on using grep -E.\n+: ${EGREP=egrep}\n+\n+# Systems which define $COMSPEC or $ComSpec use semicolons to separate\n+# directories in TEXINPUTS -- except for Cygwin et al., where COMSPEC\n+# might be inherited, but : is used.\n+if test -n \"$COMSPEC$ComSpec\" \\\n+   && uname | $EGREP -iv 'cygwin|mingw|djgpp' >/dev/null; then\n+  path_sep=\";\"\n+else\n+  path_sep=\":\"\n+fi\n+\n+# Pacify verbose cds.\n+CDPATH=${ZSH_VERSION+.}$path_sep\n+\n+# If $TEX is set to a directory, don't use it.\n+test -n \"$TEX\" && test -d \"$TEX\" && unset TEX\n+\n+# \f\n+## --------------------- ##\n+## Auxiliary functions.  ##\n+## --------------------- ##\n+\n+# In case `local' is not supported by the shell, provide a function\n+# that simulates it by simply performing the assignments.  This means\n+# that we must not expect `local' to work, i.e., we must not (i) rely\n+# on it during recursion, and (ii) have two local declarations of the\n+# same variable.  (ii) is easy to check statically, and our test suite\n+# does make sure there is never twice a static local declaration of a\n+# variable.  (i) cannot be checked easily, so just be careful.\n+#\n+# Note that since we might use a function simulating `local', we can\n+# no longer rely on the fact that no IFS-splitting is performed.  So,\n+# while\n+#\n+# foo=$bar\n+#\n+# is fine (no IFS-splitting), never write\n+#\n+# local foo=$bar\n+#\n+# but rather\n+#\n+# local foo=\"$bar\"\n+(\n+  foo=bar\n+  test_local () {\n+    local foo=foo\n+  }\n+  test_local >/dev/null 2>&1\n+  test $foo = bar\n+) || eval '\n+local () {\n+  case $1 in\n+    *=*) eval \"$1\";;\n+  esac\n+}\n+'\n+\n+\n+# cd_orig\n+# -------\n+# Return to the original directory.\n+cd_orig ()\n+{\n+  # In case $orig_pwd is on a different drive (for DOS).\n+  cd /\n+\n+  # Return to the original directory so that\n+  # - the next file is processed in correct conditions\n+  # - the temporary file can be removed\n+  cd \"$orig_pwd\" || exit 1\n+}\n+\n+# func_dirname FILE\n+# -----------------\n+# Return the directory part of FILE.\n+func_dirname ()\n+{\n+  dirname \"$1\" 2>/dev/null \\\n+  || { echo \"$1\" | $SED 's!/[^/]*$!!;s!^$!.!'; }\n+}\n+\n+\n+# noexit FILE\n+# -----------\n+# Return FILE with one extension remove.  foo.bar.baz -> foo.bar.\n+noext ()\n+{\n+  echo \"$1\" | $SED -e 's/\\.[^/.][^/.]*$//'\n+}\n+\n+\n+# absolute NAME -> ABS-NAME\n+# -------------------------\n+# Return an absolute path to NAME.\n+absolute ()\n+{\n+  case $1 in\n+   [\\\\/]* | ?:[\\\\/]*)\n+      # Absolute paths don't need to be expanded.\n+      echo \"$1\"\n+      ;;\n+   *) local slashes\n+      slashes=`echo \"$1\" | $SED -n 's,.*[^/]\\(/*\\)$,\\1,p'`\n+      local rel\n+      rel=$orig_pwd/`func_dirname \"$1\"`\n+      if test -d \"$rel\"; then\n+        (cd \"$rel\" 2>/dev/null \\\n+         && local n\n+         n=`pwd`/`basename \"$1\"`\"$slashes\"\n+         echo \"$n\")\n+      else\n+        error 1 \"not a directory: $rel\"\n+      fi\n+      ;;\n+  esac\n+}\n+\n+\n+# ensure_dir DIR1 DIR2...\n+# -----------------------\n+# Make sure the directories exist.\n+ensure_dir ()\n+{\n+  for dir\n+  do\n+    # Beware that in parallel builds we may have several concurrent\n+    # attempts to create the directory.  So fail only if \"mkdir\"\n+    # failed *and* the directory still does not exist.\n+    test -d \"$dir\" \\\n+      || mkdir \"$dir\" \\\n+      || test -d \"$dir\" \\\n+      || error 1 \"cannot create directory: $dir\"\n+  done\n+}\n+\n+\n+# error EXIT_STATUS LINE1 LINE2...\n+# --------------------------------\n+# Report an error and exit with failure if EXIT_STATUS is non-null.\n+error ()\n+{\n+  local s=\"$1\"\n+  shift\n+  report \"$@\"\n+  if test \"$s\" != 0; then\n+    exit $s\n+  fi\n+}\n+\n+\n+# findprog PROG\n+# -------------\n+# Return true if PROG is somewhere in PATH, else false.\n+findprog ()\n+{\n+  local saveIFS=\"$IFS\"\n+  IFS=$path_sep  # break path components at the path separator\n+  for dir in $PATH; do\n+    IFS=$saveIFS\n+    # The basic test for an executable is `test -f $f && test -x $f'.\n+    # (`test -x' is not enough, because it can also be true for directories.)\n+    # We have to try this both for $1 and $1.exe.\n+    #\n+    # Note: On Cygwin and DJGPP, `test -x' also looks for .exe.  On Cygwin,\n+    # also `test -f' has this enhancement, but not on DJGPP.  (Both are\n+    # design decisions, so there is little chance to make them consistent.)\n+    # Thusly, it seems to be difficult to make use of these enhancements.\n+    #\n+    if   { test -f \"$dir/$1\"     && test -x \"$dir/$1\"; } \\\n+      || { test -f \"$dir/$1.exe\" && test -x \"$dir/$1.exe\"; }; then\n+      return 0\n+    fi\n+  done\n+  return 1\n+}\n+\n+# report LINE1 LINE2...\n+# ---------------------\n+# Report some information on stderr.\n+report ()\n+{\n+  for i in \"$@\"\n+  do\n+    echo >&2 \"$0: $i\"\n+  done\n+}\n+\n+\n+# run COMMAND-LINE\n+# ----------------\n+# Run the COMMAND-LINE verbosely, and catching errors as failures.\n+run ()\n+{\n+  verbose \"Running $@\"\n+  \"$@\" 2>&5 1>&2 \\\n+  || error 1 \"$1 failed\"\n+}\n+\n+\n+# usage\n+# -----\n+# Display usage and exit successfully.\n+usage ()\n+{\n+  # We used to simply have `echo \"$usage\"', but coping with the\n+  # changing behavior of `echo' is much harder than simply using a\n+  # here-doc.\n+  #\n+  #             echo '\\noto'   echo '\\\\noto'   echo -e '\\\\noto'\n+  # bash 3.1      \\noto           \\\\noto          \\noto\n+  # bash 3.2       %oto           \\noto           -e \\noto\n+  #\n+  # where % denotes the eol character.\n+  cat <<EOF\n+Usage: $program [OPTION]... FILE...\n+  or:  texi2pdf [OPTION]... FILE...\n+  or:  pdftexi2dvi [OPTION]... FILE...\n+\n+Run each Texinfo or (La)TeX FILE through TeX in turn until all\n+cross-references are resolved, building all indices.  The directory\n+containing each FILE is searched for included files.  The suffix of FILE\n+is used to determine its language ((La)TeX or Texinfo).  To process\n+(e)plain TeX files, set the environment variable LATEX=tex.\n+\n+In order to make texi2dvi a drop-in replacement of TeX/LaTeX in AUC-TeX,\n+the FILE may also be composed of the following simple TeX commands.\n+  \\`\\\\input{FILE}'     the actual file to compile\n+  \\`\\\\nonstopmode'     same as --batch\n+\n+When invoked as \\`texi2pdf' or \\`pdftexi2dvi', or given the option --pdf\n+or --dvipdf, generate PDF output.  Otherwise, generate DVI.\n+\n+General options:\n+  -b, --batch         no interaction\n+  -D, --debug         turn on shell debugging (set -x)\n+  -h, --help          display this help and exit successfully\n+  -o, --output=OFILE  leave output in OFILE; only one input FILE is allowed\n+  -q, --quiet         no output unless errors (implies --batch)\n+  -s, --silent        same as --quiet\n+  -v, --version       display version information and exit successfully\n+  -V, --verbose       report on what is done\n+\n+Output format:\n+      --dvi     output a DVI file [default]\n+      --dvipdf  output a PDF file via DVI (using a dvi-to-pdf program)\n+      --html    output an HTML file from LaTeX, using HeVeA\n+      --info    output an Info file from LaTeX, using HeVeA\n+  -p, --pdf     use pdftex or pdflatex for processing\n+      --ps      output a PostScript file via DVI (using dvips)\n+      --text    output a plain text file from LaTeX, using HeVeA\n+\n+TeX tuning:\n+  -@                         use @input instead of \\input for preloaded Texinfo\n+  -e, -E, --expand           force macro expansion using makeinfo\n+  -I DIR                     search DIR for Texinfo files\n+  -l, --language=LANG        specify LANG for FILE, either latex or texinfo\n+      --no-line-error        do not pass --file-line-error to TeX\n+      --shell-escape         pass --shell-escape to TeX\n+      --src-specials         pass --src-specials to TeX\n+  -t, --command=CMD          insert CMD in copy of input file\n+   or --texinfo=CMD          multiple values accumulate\n+      --translate-file=FILE  use given charset translation file for TeX\n+\n+Build modes:\n+  --build=MODE         specify the treatment of auxiliary files [$build_mode]\n+      --tidy           same as --build=tidy\n+  -c, --clean          same as --build=clean\n+      --build-dir=DIR  specify where the tidy compilation is performed;\n+                         implies --tidy;\n+                         defaults to TEXI2DVI_BUILD_DIRECTORY [$build_dir]\n+  --mostly-clean       remove the auxiliary files and directories\n+                         but not the output\n+  --max-iterations=N   don't process files more than N times [$max_iters]\n+\n+The MODE specifies where the TeX compilation takes place, and, as a\n+consequence, how auxiliary files are treated.  The build mode\n+can also be set using the environment variable TEXI2DVI_BUILD_MODE.\n+\n+Valid MODEs are:\n+  \\`local'      compile in the current directory, leaving all the auxiliary\n+               files around.  This is the traditional TeX use.\n+  \\`tidy'       compile in a local *.t2d directory, where the auxiliary files\n+               are left.  Output files are copied back to the original file.\n+  \\`clean'      same as \\`tidy', but remove the auxiliary directory afterwards.\n+               Every compilation therefore requires the full cycle.\n+\n+Using the \\`tidy' mode brings several advantages:\n+  - the current directory is not cluttered with plethora of temporary files.\n+  - clutter can be even further reduced using --build-dir=dir: all the *.t2d\n+    directories are stored there.\n+  - clutter can be reduced to zero using, e.g., --build-dir=/tmp/\\$USER.t2d\n+    or --build-dir=\\$HOME/.t2d.\n+  - the output file is updated after every successful TeX run, for\n+    sake of concurrent visualization of the output.  In a \\`local' build\n+    the viewer stops during the whole TeX run.\n+  - if the compilation fails, the previous state of the output file\n+    is preserved.\n+  - PDF and DVI compilation are kept in separate subdirectories\n+    preventing any possibility of auxiliary file incompatibility.\n+\n+On the other hand, because \\`tidy' compilation takes place in another\n+directory, occasionally TeX won't be able to find some files (e.g., when\n+using \\\\graphicspath): in that case, use -I to specify the additional\n+directories to consider.\n+\n+The values of the BIBER, BIBTEX, DVIPDF, DVIPS, HEVEA, LATEX, MAKEINDEX,\n+MAKEINFO, PDFLATEX, PDFTEX, SED, T4HT, TEX, TEX4HT, TEXINDEX, and THUMBPDF_CMD\n+environment variables are used to run those commands, if they are set.\n+\n+Regarding --dvipdf, if DVIPDF is not set in the environment, the\n+following programs are looked for (in this order): dvipdfmx dvipdfm\n+dvipdf dvi2pdf dvitopdf.\n+\n+Any CMD strings are added after @setfilename for Texinfo input, or in\n+the first line for LaTeX input.\n+\n+Report bugs to bug-texinfo@gnu.org,\n+general questions and discussion to help-texinfo@gnu.org.\n+GNU Texinfo home page: <http://www.gnu.org/software/texinfo/>\n+General help using GNU software: <http://www.gnu.org/gethelp/>\n+EOF\n+  exit 0\n+}\n+\n+\n+# verbose WORD1 WORD2\n+# -------------------\n+# Report some verbose information.\n+verbose ()\n+{\n+  if $verb; then\n+    echo >&2 \"$0: $@\"\n+  fi\n+}\n+\n+\n+# version\n+# -------\n+# Display version info and exit successfully.\n+version ()\n+{\n+  cat <<EOF\n+texi2dvi (GNU Texinfo 5.2) $rcs_version\n+\n+Copyright (C) 2014 Free Software Foundation, Inc.\n+License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n+This is free software: you are free to change and redistribute it.\n+There is NO WARRANTY, to the extent permitted by law.\n+EOF\n+  exit 0\n+}\n+\n+\n+## ---------------- ##\n+## Handling lists.  ##\n+## ---------------- ##\n+\n+\n+# list_append LIST-NAME ELEM\n+# --------------------------\n+# Set LIST-NAME to its former contents, with ELEM appended.\n+list_append ()\n+{\n+  local la_l=\"$1\"\n+  shift\n+  eval set X \\$$la_l \"$@\"\n+  shift\n+  eval $la_l=\\\"\"$@\"\\\"\n+}\n+\n+\n+# list_concat_dirs LIST-NAME DIR-LIST\n+# -----------------------------------\n+# Append to LIST-NAME all the components (included empty) from\n+# the $path_sep separated list DIR-LIST.  Make the paths absolute.\n+list_concat_dirs ()\n+{\n+  local lcd_list=\"$1\"\n+  # Empty path components are meaningful to tex.  We rewrite them as\n+  # `EMPTY' so they don't get lost when we split on $path_sep.\n+  # Hopefully no one will have an actual directory named EMPTY.\n+  local replace_EMPTY=\"-e 's/^$path_sep/EMPTY$path_sep/g' \\\n+                       -e 's/$path_sep\\$/${path_sep}EMPTY/g' \\\n+                       -e 's/$path_sep$path_sep/${path_sep}EMPTY:/g'\"\n+  save_IFS=$IFS\n+  IFS=$path_sep\n+  set x `echo \"$2\" | eval $SED $replace_EMPTY`; shift\n+  IFS=$save_IFS\n+  local dir\n+  for dir\n+  do\n+    case $dir in\n+      EMPTY)\n+       list_append $lcd_list \"\"\n+       ;;\n+      *)\n+       if test -d $dir; then\n+          dir=`absolute \"$dir\"`\n+         list_append $lcd_list \"$dir\"\n+       fi\n+       ;;\n+    esac\n+  done\n+}\n+\n+\n+# list_prefix LIST-NAME SEP -> STRING\n+# -----------------------------------\n+# Return a string that is composed of the LIST-NAME with each item\n+# preceded by SEP.\n+list_prefix ()\n+{\n+  local lp_p=\"$2\"\n+  eval set X \\$$1\n+  shift\n+  local lp_res\n+  for i\n+  do\n+    lp_res=\"$lp_res \\\"$lp_p\\\" \\\"$i\\\"\"\n+  done\n+  echo \"$lp_res\"\n+}\n+\n+# list_infix LIST-NAME SEP -> STRING\n+# ----------------------------------\n+# Same as list_prefix, but a separator.\n+list_infix ()\n+{\n+  eval set X \\$$1\n+  shift\n+  local la_IFS=\"$IFS\"\n+  IFS=$path_sep\n+  echo \"$*\"\n+  IFS=$la_IFS\n+}\n+\n+# list_dir_to_abs LIST-NAME\n+# -------------------------\n+# Convert the list to using only absolute dir names.\n+# Currently unused, but should replace absolute_filenames some day.\n+list_dir_to_abs ()\n+{\n+  local ld_l=\"$1\"\n+  eval set X \\$$ld_l\n+  shift\n+  local ld_res\n+  for dir\n+  do\n+    dir=`absolute \"$dir\"`\n+    test -d \"$dir\" || continue\n+    ld_res=\"$ld_res \\\"$dir\\\"\"\n+  done\n+  set X $ld_res; shift\n+  eval $ld_l=\\\"$@\\\"\n+}\n+\n+\n+## ------------------------------ ##\n+## Language auxiliary functions.  ##\n+## ------------------------------ ##\n+\n+\n+# out_lang_set LANG\n+# -----------------\n+out_lang_set ()\n+{\n+  case $1 in\n+    dvi|dvipdf|html|info|pdf|ps|text) out_lang=$1;;\n+    *) error 1 \"invalid output format: $1\";;\n+  esac\n+}\n+\n+\n+# out_lang_tex\n+# ------------\n+# Return the tex output language (DVI or PDF) for $OUT_LANG.\n+out_lang_tex ()\n+{\n+  case $out_lang in\n+    dvi | ps | dvipdf ) echo dvi;;\n+    pdf ) echo $out_lang;;\n+    html | info | text ) echo $out_lang;;\n+    *)    error 1 \"invalid out_lang: $1\";;\n+  esac\n+}\n+\n+\n+# out_lang_ext\n+# ------------\n+# Return the extension for $OUT_LANG.\n+out_lang_ext ()\n+{\n+  case $out_lang in\n+    dvipdf ) echo pdf;;\n+    dvi | html | info | pdf | ps | text ) echo $out_lang;;\n+    *)    error 1 \"invalid out_lang: $1\";;\n+  esac\n+}\n+\n+\n+## ------------------------- ##\n+## TeX auxiliary functions.  ##\n+## ------------------------- ##\n+\n+# Save TEXINPUTS so we can construct a new TEXINPUTS path for each file.\n+# Likewise for bibtex and makeindex.\n+tex_envvars=\"BIBINPUTS BSTINPUTS DVIPSHEADERS INDEXSTYLE MFINPUTS MPINPUTS \\\n+TEXINPUTS TFMFONTS\"\n+for var in $tex_envvars; do\n+  eval ${var}_orig=\\$$var\n+  export $var\n+done\n+\n+\n+# absolute_filenames TEX-PATH -> TEX-PATH\n+# ---------------------------------------\n+# Convert relative paths to absolute paths, so we can run in another\n+# directory (e.g., in tidy build mode, or during the macro-support\n+# detection).  Prepend \".\".\n+absolute_filenames ()\n+{\n+  # Empty path components are meaningful to tex.  We rewrite them as\n+  # `EMPTY' so they don't get lost when we split on $path_sep.\n+  # Hopefully no one will have an actual directory named EMPTY.\n+  local replace_empty=\"-e 's/^$path_sep/EMPTY$path_sep/g' \\\n+                       -e 's/$path_sep\\$/${path_sep}EMPTY/g' \\\n+                       -e 's/$path_sep$path_sep/${path_sep}EMPTY:/g'\"\n+  local res\n+  res=`echo \"$1\" | eval $SED $replace_empty`\n+  save_IFS=$IFS\n+  IFS=$path_sep\n+  set x $res; shift\n+  res=.\n+  for dir\n+  do\n+    case $dir in\n+      EMPTY)\n+        res=$res$path_sep\n+        ;;\n+      *)\n+        if test -d \"$dir\"; then\n+          res=$res$path_sep`absolute \"$dir\"`\n+        else\n+          # Even if $dir is not a directory, preserve it in the path.\n+          # It might contain metacharacters that TeX will expand in\n+          # turn, e.g., /some/path/{a,b,c}.  This will not get the\n+          # implicit absolutification of the path, but we can't help that.\n+          res=$res$path_sep$dir\n+        fi\n+        ;;\n+    esac\n+  done\n+  echo \"$res\"\n+}\n+\n+\n+# output_base_name FILE\n+# ---------------------\n+# The name of FILE, possibly renamed to satisfy --output.\n+# FILE is local, there is no directory part.\n+output_base_name ()\n+{\n+  case $oname in\n+    '') echo \"$1\";;\n+     *) local out_noext\n+        out_noext=`noext \"$oname\"`\n+        local file_ext\n+        file_ext=`echo \"$1\" | $SED 's/^.*\\.//'`\n+        echo \"$out_noext.$file_ext\"\n+      ;;\n+  esac\n+}\n+\n+\n+# destdir\n+# -------\n+# Return the name of the directory where the output is expected.\n+destdir ()\n+{\n+  case $oname in\n+    '')  echo \"$orig_pwd\";;\n+    *)   dirname \"$oname\";;\n+  esac\n+}\n+\n+\n+# move_to_dest FILE...\n+# --------------------\n+# Move FILE to the place where the user expects it.  Truly move it, that\n+# is, it must not remain in its build location unless that is also the\n+# output location.  (Otherwise it might appear as an extra file in make\n+# distcheck.)\n+#\n+# FILE can be the principal output (in which case -o directly applies), or\n+# an auxiliary file with the same base name.\n+move_to_dest ()\n+{\n+#  echo \"move_to_dest $*, tidy=$tidy, oname=$oname\"\n+\n+  # If we built in place and have no output name, there is nothing to\n+  # do, so just return.\n+  case $tidy:$oname in\n+    false:) return;;\n+  esac\n+\n+  local destfile\n+  local destdir\n+  local destbase\n+  local sourcedir\n+  local sourcebase\n+\n+  for file\n+  do\n+    test -f \"$file\" \\\n+    || error 1 \"no such file or directory: $file\"\n+    case $tidy:$oname in\n+      true:)  destdir=$orig_pwd\n+              destfile=$destdir/$file;;\n+      true:*) destfile=`output_base_name \"$file\"`\n+              destdir=`dirname \"$destfile\"`;;\n+      false:*) destfile=$oname\n+               destdir=`dirname \"$destfile\"`;;\n+    esac\n+ \n+    # We want to compare the source location and the output location,\n+    # and if they are different, do the move.  But if they are the\n+    # same, we must preserve the source.  Since we can't assume\n+    # stat(1) or test -ef is available, resort to comparing the\n+    # directory names, canonicalized with pwd.  We can't use cmp -s\n+    # since the output file might not actually change from run to run;\n+    # e.g., TeX DVI output is timestamped to only the nearest minute.\n+    destdir=`cd \"$destdir\" && pwd`\n+    destbase=`basename \"$destfile\"`\n+\n+    sourcedir=`dirname \"$file\"`\n+    sourcedir=`cd \"$sourcedir\" && pwd`\n+    sourcebase=`basename \"$file\"`\n+\n+    if test \"$sourcedir/$sourcebase\" != \"$destdir/$destbase\"; then\n+      verbose \"Moving $file to $destfile\"\n+      rm -f \"$destfile\"\n+      mv \"$file\" \"$destfile\"\n+    fi\n+  done\n+}\n+\n+\n+## --------------------- ##\n+## Managing xref files.  ##\n+## --------------------- ##\n+\n+# aux_file_p FILE\n+# ---------------\n+# Return with success if FILE is an aux file.\n+aux_file_p ()\n+{\n+  test -f \"$1\" || return 1\n+  case $1 in\n+    *.aux) return 0;;\n+    *)     return 1;;\n+  esac\n+}\n+\n+# bibaux_file_p FILE\n+# ------------------\n+# Return with success if FILE is an aux file containing citation\n+# requests.\n+bibaux_file_p ()\n+{\n+  test -s \"$1\" || return 1\n+  if (grep '^\\\\bibstyle[{]' \"$1\"   \\\n+      && grep '^\\\\bibdata[{]' \"$1\" \\\n+      ## The following line is suspicious: fails when there\n+      ## are citations in sub aux files.  We need to be\n+      ## smarter in this case.\n+      ## && grep '^\\\\citation[{]' \"$f\"\n+      ) >&6 2>&1;\n+  then\n+    return 0\n+  fi\n+  return 1\n+}\n+\n+# index_file_p FILE\n+# -----------------\n+# Return with success if FILE is an index file.\n+index_file_p ()\n+{\n+  test -f \"$1\" || return 1\n+  case $in_lang:$latex2html:`out_lang_tex`:`$SED '1q' \"$1\"` in\n+    # When working with TeX4HT, *.idx are created by LaTeX.  They must\n+    # be processed to produce *.4ix, *.4dx files.  The *.4dx file is\n+    # passed to makeindex to produce the *.ind file.  This sequence is\n+    # handled by run_index, so we are only interested in the *.idx\n+    # files, which have each \"\\indexentry\" preceded by a\n+    # \"\\beforeentry\".\n+    latex:tex4ht:html:\"\\\\beforeentry {\"*) return 0;;\n+\n+    # When index.sty is used, there is a space before the brace.\n+    latex:*:*:\"\\\\indexentry{\"*|latex:*:*:\"\\\\indexentry {\"*) return 0;;\n+\n+    texinfo:*:*:\"\\\\entry{\"*) return 0;;\n+\n+    *) return 1;;\n+  esac\n+}\n+\n+# xref_file_p FILE\n+# ----------------\n+# Return with success if FILE is an xref file (indexes, tables and lists).\n+xref_file_p ()\n+{\n+  test -f \"$1\" || return 1\n+  # If the file is not suitable to be an index or xref file, don't\n+  # process it.  It's suitable if the first character is a\n+  # backslash or right quote or at, as long as the first line isn't\n+  # \\input texinfo.\n+  case `$SED '1q' \"$1\"` in\n+    \"\\\\input texinfo\"*) return 1;;\n+    [\\\\''@]*)           return 0;;\n+           *)           return 1;;\n+  esac\n+}\n+\n+\n+# generated_files_get FILENAME-NOEXT [PREDICATE-FILTER]\n+# -----------------------------------------------------\n+# Return the list of files generated by the TeX compilation of FILENAME-NOEXT.\n+generated_files_get ()\n+{\n+  local filter=true\n+  if test -n \"$2\"; then\n+    filter=$2\n+  fi\n+\n+  # Gather the files created by TeX.\n+  (\n+    if test -f \"$1.log\"; then\n+      $SED -n -e \"s,^\\\\\\\\openout.* = \\`\\\\(.*\\\\)'\\\\.,\\\\1,p\" \"$1.log\"\n+    fi\n+    echo \"$1.log\"\n+  ) |\n+  # Depending on these files, infer outputs from other tools.\n+  while read file; do\n+    echo $file\n+    case $in_lang in\n+      texinfo)\n+        # texindex: texinfo.cp -> texinfo.cps\n+       if index_file_p $file; then\n+         echo ${file}s\n+       fi\n+       ;;\n+      latex)\n+        if aux_file_p $file; then\n+          # bibtex: *.aux -> *.bbl and *.blg.\n+          echo $file | $SED 's/^\\(.*\\)\\.aux$/\\1.bbl/'\n+          echo $file | $SED 's/^\\(.*\\)\\.aux$/\\1.blg/'\n+          # -recorder: .fls\n+          echo $file | $SED 's/^\\(.*\\)\\.aux$/\\1.fls/'\n+       fi\n+       ;;\n+    esac\n+  done |\n+  # Filter existing files matching the criterion.\n+  #\n+  # With an input file name containing a space, this produces a\n+  # \"command not found\" message (and filtering is ineffective).\n+  # The situation with a newline is presumably even worse.\n+  while read file; do\n+    if $filter \"$file\"; then\n+      echo $file\n+    fi\n+  done |\n+  sort |\n+  # Some files are opened several times, e.g., listings.sty's *.vrb.\n+  uniq\n+}\n+\n+\n+# xref_files_save\n+# ---------------\n+# Save the xref files.\n+xref_files_save ()\n+{\n+  # Save copies of auxiliary files for later comparison.\n+  xref_files_orig=`generated_files_get \"$in_noext\" xref_file_p`\n+  if test -n \"$xref_files_orig\"; then\n+    verbose \"Backing up xref files: $xref_files_orig\"\n+    # The following line improves `cp $xref_files_orig \"$work_bak\"'\n+    # by preserving the directory parts.  Think of\n+    # cp chap1/main.aux chap2/main.aux $work_bak.\n+    #\n+    # Users may have, e.g., --keep-old-files.  Don't let this interfere.\n+    # (Don't use unset for the sake of ancient shells.)\n+    TAR_OPTIONS=; export TAR_OPTIONS\n+    tar cf - $xref_files_orig | (cd \"$work_bak\" && tar xf -)\n+  fi\n+}\n+\n+\n+# xref_files_changed\n+# ------------------\n+# Whether the xref files were changed since the previous run.\n+xref_files_changed ()\n+{\n+  # LaTeX (and the package changebar) report in the LOG file if it\n+  # should be rerun.  This is needed for files included from\n+  # subdirs, since texi2dvi does not try to compare xref files in\n+  # subdirs.  Performing xref files test is still good since LaTeX\n+  # does not report changes in xref files.\n+  if grep \"Rerun to get\" \"$in_noext.log\" >&6 2>&1; then\n+    return 0\n+  fi\n+  # biblatex report of whether rerunning is needed.\n+  if grep \"biblatex.*(re)run\" \"$in_noext.log\" >&6 2>&1; then\n+    return 0\n+  fi\n+\n+  # If old and new lists don't have the same file list,\n+  # then something has definitely changed.\n+  xref_files_new=`generated_files_get \"$in_noext\" xref_file_p`\n+  verbose \"Original xref files = $xref_files_orig\"\n+  verbose \"New xref files      = $xref_files_new\"\n+  if test \"x$xref_files_orig\" != \"x$xref_files_new\"; then\n+    return 0\n+  fi\n+\n+  # Compare each file until we find a difference.\n+  for this_file in $xref_files_new; do\n+    verbose \"Comparing xref file `echo $this_file | $SED 's|\\./||g'` ...\"\n+    # cmp -s returns nonzero exit status if files differ.\n+    if cmp -s \"$this_file\" \"$work_bak/$this_file\"; then :; else\n+      verbose \"xref file `echo $this_file | $SED 's|\\./||g'` differed ...\"\n+      if $debug; then\n+        diff -u \"$work_bak/$this_file\" \"$this_file\"\n+      fi\n+      return 0\n+    fi\n+  done\n+\n+  # No change.\n+  return 1\n+}\n+\n+\n+\n+## ----------------------- ##\n+## Running the TeX suite.  ##\n+## ----------------------- ##\n+\n+\n+\n+# run_tex ()\n+# ----------\n+# Run TeX as \"$tex $in_input\", taking care of errors and logs.\n+run_tex ()\n+{\n+  case $in_lang:$latex2html:`out_lang_tex` in\n+    latex:*:dvi|latex:tex4ht:html)\n+        tex=${LATEX:-latex};;\n+    latex:*:pdf)\n+        tex=${PDFLATEX:-pdflatex};;\n+    texinfo:*:dvi)\n+        # MetaPost also uses the TEX environment variable.  If the user\n+        # has set TEX=latex for that reason, don't bomb out.\n+        case $TEX in\n+          *latex) tex=tex;; # don't bother trying to find etex\n+               *) tex=$TEX\n+        esac;;\n+    texinfo:*:pdf) tex=$PDFTEX;;\n+\n+    *) error 1 \"$out_lang not supported for $in_lang\";;\n+  esac\n+\n+  # do the special catcode trick for ~ in filenames only for Texinfo,\n+  # not LaTeX.\n+  if test x\"$in_lang\" = xtexinfo && test $catcode_special = maybe; then\n+    catcode_special=true\n+  else\n+    catcode_special=false\n+  fi\n+\n+  # Beware of aux files in subdirectories that require the\n+  # subdirectory to exist.\n+  case $in_lang:$tidy in\n+    latex:true)\n+       $SED -n 's|^[ ]*\\\\include{\\(.*\\)/.*}.*|\\1|p' \"$in_input\" |\n+       sort -u |\n+       while read d\n+       do\n+         ensure_dir \"$work_build/$d\"\n+       done\n+       ;;\n+  esac\n+\n+  # Note that this will be used via an eval: quote properly.\n+  local cmd=\"$tex\"\n+\n+  # If possible, make TeX report error locations in GNU format.\n+  if $line_error; then\n+    if test \"${tex_help:+set}\" != set; then\n+      # Go to a temporary directory to try --help, since old versions that\n+      # don't accept --help will generate a texput.log.\n+      tex_help_dir=$t2ddir/tex_help\n+      ensure_dir \"$tex_help_dir\"\n+      tex_help=`cd \"$tex_help_dir\" >&6 && $tex --help </dev/null 2>&1 || true`\n+    fi\n+    # The mk program and perhaps others want to parse TeX's\n+    # original error messages.\n+    case $tex_help in\n+      *file-line-error*) cmd=\"$cmd --file-line-error\";;\n+    esac\n+  fi\n+\n+  # Tell TeX about TCX file, if specified.\n+  test -n \"$translate_file\" && cmd=\"$cmd --translate-file=$translate_file\"\n+\n+  # Tell TeX to make source specials (for backtracking from output to\n+  # source, given a sufficiently smart editor), if specified.\n+  test -n \"$src_specials\" && cmd=\"$cmd $src_specials\"\n+\n+  # Tell TeX to allow running external executables\n+  test -n \"$shell_escape\" && cmd=\"$cmd $shell_escape\"\n+\n+  # Tell TeX to be batch if requested.\n+  if $batch; then\n+    # \\batchmode does not show terminal output at all, so we don't\n+    # want that.  And even in batch mode, TeX insists on having input\n+    # from the user.  Close its stdin to make it impossible.\n+    cmd=\"$cmd </dev/null '${escape}nonstopmode'\"\n+  fi\n+\n+  # we'd like to handle arbitrary input file names, especially\n+  # foo~bar/a~b.tex, since Debian likes ~ characters.\n+  if $catcode_special; then\n+    # $normaltilde is just to reduce line length in this source file.\n+    # The idea is to define \\normaltilde as a catcode other ~ character,\n+    # then make the active ~ be equivalent to that, instead of the plain\n+    # TeX tie.  Then when the active ~ appears in the filename, it will\n+    # be expanded to itself, as far as \\input will see.  (This is the\n+    # same thing that texinfo.tex does in general, BTW.)\n+    normaltilde=\"${escape}catcode126=12 ${escape}def${escape}normaltilde{~}\"\n+    cmd=\"$cmd '$normaltilde${escape}catcode126=13 ${escape}let~\\normaltilde '\"\n+  fi\n+  # Other special (non-active) characters could be supported by\n+  # resetting their catcodes to other on the command line and changing\n+  # texinfo.tex to initialize everything to plain catcodes.  Maybe someday.\n+\n+  # append the \\input command.\n+  cmd=\"$cmd '${escape}input'\"\n+\n+  # TeX's \\input does not (easily or reliably) support whitespace\n+  # characters or other special characters in file names.  Our intensive\n+  # use of absolute file names makes this worse: the enclosing directory\n+  # names may include white spaces.  Improve the situation using a\n+  # symbolic link to the filename in the current directory, in tidy mode\n+  # only.  Do not alter in_input.\n+  #\n+  # The filename is almost always tokenized using plain TeX conventions\n+  # (the exception would be if the user made a texinfo.fmt file).  Not\n+  # all the plain TeX special characters cause trouble, but there's no\n+  # harm in making the link.\n+  #\n+  case $tidy:`func_dirname \"$in_input\"` in\n+    true:*[\"$space$tab$newline\\\"#\\$%\\\\^_{}~\"]*)\n+      _run_tex_file_name=`basename \"$in_input\"`\n+      if test ! -f \"$_run_tex_file_name\"; then\n+        # It might not be a file, clear it.\n+        run rm -f \"$_run_tex_file_name\"\n+        run ln -s \"$in_input\"\n+      fi\n+      cmd=\"$cmd '$_run_tex_file_name'\"\n+      ;;\n+\n+    *)\n+      cmd=\"$cmd '$in_input'\"\n+      ;;\n+  esac\n+\n+  verbose \"$0: Running $cmd ...\"\n+  if eval \"$cmd\" >&5; then\n+    case $out_lang in\n+      dvi | pdf ) move_to_dest \"$in_noext.$out_lang\";;\n+    esac\n+  else\n+    error 1 \"$tex exited with bad status, quitting.\"\n+  fi\n+}\n+\n+# run_bibtex ()\n+# -------------\n+# Run bibtex on (or biber) current file.\n+# - If its input (AUX) exists.\n+# - If some citations are missing (LOG contains `Citation').\n+#   or the LOG complains of a missing .bbl\n+#\n+# Don't try to be too smart:\n+# 1. Running bibtex only if the bbl file exists and is older than\n+# the LaTeX file is wrong, since the document might include files\n+# that have changed.\n+#\n+# 3. Because there can be several AUX (if there are \\include's),\n+# but a single LOG, looking for missing citations in LOG is\n+# easier, though we take the risk of matching false messages.\n+run_bibtex ()\n+{\n+  case $in_lang in\n+    latex)   bibtex=${BIBTEX:-bibtex};;\n+    texinfo) return;;\n+  esac\n+\n+  # \"Citation undefined\" is for LaTeX, \"Undefined citation\" for btxmac.tex.\n+  # The no .aux && \\bibdata test is also for btxmac, in case it was the\n+  # first run of a bibtex-using document.  Otherwise, it's possible that\n+  # bibtex would never be run.\n+  if test -r \"$in_noext.aux\" \\\n+     && test -r \"$in_noext.log\" \\\n+     && ( (grep 'Warning:.*Citation.*undefined' \"$in_noext.log\" \\\n+          || grep '.*Undefined citation' \"$in_noext.log\" \\\n+          || grep 'No file .*\\.bbl\\.' \"$in_noext.log\") \\\n+          || (grep 'No \\.aux file' \"$in_noext.log\" \\\n+              && grep '^\\\\bibdata' \"$in_noext.aux\") ) \\\n+        >&6 2>&1; \\\n+  then\n+    bibtex_aux=`generated_files_get \"$in_noext\" bibaux_file_p`\n+    for f in $bibtex_aux; do\n+      run $bibtex \"$f\"\n+    done\n+  fi\n+\n+  # biber(+biblatex) check.\n+  if test -r \"$in_noext.bcf\" \\\n+     && grep '</bcf:controlfile>' \"$in_noext.bcf\" >/dev/null; then\n+    run ${BIBER:-biber} \"$in_noext\"\n+  fi\n+}\n+\n+# run_index ()\n+# ------------\n+# Run texindex (or makeindex or texindy) on current index files.  If\n+# they already exist, and after running TeX a first time the index\n+# files don't change, then there's no reason to run TeX again.  But we\n+# won't know that if the index files are out of date or nonexistent.\n+run_index ()\n+{\n+  local index_files\n+  index_files=`generated_files_get $in_noext index_file_p`\n+  test -n \"$index_files\" \\\n+  || return 0\n+\n+  : ${MAKEINDEX:=makeindex}\n+  : ${TEXINDEX:=texindex}\n+  : ${TEXINDY:=texindy}\n+\n+  local index_file\n+  local index_noext\n+  case $in_lang:$latex2html:`out_lang_tex` in\n+    latex:tex4ht:html)\n+      for index_file in $index_files\n+      do\n+        index_noext=`noext \"$index_file\"`\n+        run tex \\\n+            '\\def\\filename{{'\"$index_noext\"'}{idx}{4dx}{ind}}\n+             \\input idxmake.4ht'\n+        run $MAKEINDEX -o $index_noext.ind $index_noext.4dx\n+      done\n+      ;;\n+\n+    latex:*)\n+      if $TEXINDY --version >&6 2>&1; then\n+        run $TEXINDY $index_files\n+      else\n+        run $MAKEINDEX $index_files\n+      fi\n+      ;;\n+\n+    texinfo:*)\n+      run $TEXINDEX $index_files\n+      ;;\n+  esac\n+}\n+\n+\n+# run_tex4ht ()\n+# -------------\n+# Run the last two phases of TeX4HT: tex4ht extracts the HTML from the\n+# instrumented DVI file, and t4ht converts the figures and installs\n+# the files when given -d.\n+#\n+# Because knowing exactly which files are created is complex (in\n+# addition the names are not simple to compute), which makes it\n+# difficult to install the output files in a second step, it is much\n+# simpler to install directly the output files.\n+run_tex4ht ()\n+{\n+  case $in_lang:$latex2html:`out_lang_tex` in\n+    latex:tex4ht:html)\n+      : ${TEX4HT:=tex4ht} ${T4HT:=t4ht}\n+      run \"$TEX4HT\" \"-f/$in_noext\"\n+      # Do not remove the / after the destdir.\n+      run \"$T4HT\" \"-d`destdir`/\" \"-f/$in_noext\"\n+      ;;\n+  esac\n+}\n+\n+\n+# run_thumbpdf ()\n+# ---------------\n+run_thumbpdf ()\n+{\n+  if test `out_lang_tex` = pdf \\\n+     && test -r \"$in_noext.log\" \\\n+     && grep 'thumbpdf\\.sty'  \"$in_noext.log\" >&6 2>&1; \\\n+  then\n+    thumbpdf=${THUMBPDF_CMD:-thumbpdf}\n+    thumbcmd=\"$thumbpdf $in_dir/$in_noext\"\n+    verbose \"Running $thumbcmd ...\"\n+    if $thumbcmd >&5; then\n+      run_tex\n+    else\n+      report \"$thumbpdf exited with bad status.\" \\\n+             \"Ignoring its output.\"\n+    fi\n+  fi\n+}\n+\n+\n+# run_dvipdf FILE.dvi\n+# -------------------\n+# Convert FILE.dvi to FILE.pdf.\n+run_dvipdf ()\n+{\n+  # Find which dvi->pdf program is available.\n+  if test -z \"$dvipdf\"; then\n+    for i in \"$DVIPDF\" dvipdfmx dvipdfm dvipdf dvi2pdf dvitopdf; do\n+      if findprog $i; then\n+        dvipdf=$i\n+      fi\n+    done\n+  fi\n+  # These tools have varying interfaces, some 'input output', others\n+  # 'input -o output'.  They all seem to accept 'input' only,\n+  # outputting using the expected file name.\n+  run $dvipdf \"$1\"\n+  if test ! -f `echo \"$1\" | $SED -e 's/\\.dvi$/.pdf/'`; then\n+    error 1 \"cannot find output file\"\n+  fi\n+}\n+\n+# run_tex_suite ()\n+# ----------------\n+# Run the TeX tools until a fix point is reached.\n+run_tex_suite ()\n+{\n+  # Move to the working directory.\n+  if $tidy; then\n+    verbose \"cd $work_build\"\n+    cd \"$work_build\" || exit 1\n+  fi\n+\n+  # Count the number of cycles.\n+  local cycle=0\n+\n+  while :; do\n+    # check for probably LaTeX loop (e.g. varioref)\n+    if test $cycle -eq \"$max_iters\"; then\n+      error 0 \"Maximum of $max_iters cycles exceeded\"\n+      break\n+    fi\n \n-Copyright (C) 2003 Free Software Foundation, Inc.\n-There is NO warranty.  You may redistribute this software\n-under the terms of the GNU General Public License.\n-For more information about these matters, see the files named COPYING.\"\n+    # report progress\n+    cycle=`expr $cycle + 1`\n+    verbose \"Cycle $cycle for $command_line_filename\"\n \n-usage=\"Usage: $program [OPTION]... FILE...\n+    xref_files_save\n \n-Run each Texinfo or LaTeX FILE through TeX in turn until all\n-cross-references are resolved, building all indices.  The directory\n-containing each FILE is searched for included files.  The suffix of FILE\n-is used to determine its language (LaTeX or Texinfo).\n+    # We run bibtex first, because it's more likely for the indexes\n+    # to change after bibtex is run than the reverse, though either\n+    # would be rare.\n+    run_bibtex\n+    run_index\n+    run_core_conversion\n \n-Makeinfo is used to perform Texinfo macro expansion before running TeX\n-when needed.\n+    xref_files_changed || break\n+  done\n \n-Operation modes:\n-  -b, --batch         no interaction\n-  -c, --clean         remove all auxiliary files\n-  -D, --debug         turn on shell debugging (set -x)\n-  -h, --help          display this help and exit successfully\n-  -o, --output=OFILE  leave output in OFILE (implies --clean);\n-                      Only one input FILE may be specified in this case\n-  -q, --quiet         no output unless errors (implies --batch)\n-  -s, --silent        same as --quiet\n-  -v, --version       display version information and exit successfully\n-  -V, --verbose       report on what is done\n+  # If we were using thumbpdf and producing PDF, then run thumbpdf\n+  # and TeX one last time.\n+  run_thumbpdf\n \n-TeX tuning:\n-  -@                   use @input instead of \\input; for preloaded Texinfo\n-  -e, -E, --expand     force macro expansion using makeinfo\n-  -I DIR               search DIR for Texinfo files\n-  -l, --language=LANG  specify the LANG of FILE (LaTeX or Texinfo)\n-  -p, --pdf            use pdftex or pdflatex for processing\n-  -t, --texinfo=CMD    insert CMD after @setfilename in copy of input file\n-                       multiple values accumulate\n-\n-The values of the BIBTEX, LATEX (or PDFLATEX), MAKEINDEX, MAKEINFO,\n-TEX (or PDFTEX), and TEXINDEX environment variables are used to run\n-those commands, if they are set.\n-\n-Email bug reports to <bug-texinfo@gnu.org>,\n-general questions and discussion to <help-texinfo@gnu.org>.\n-Texinfo home page: http://www.gnu.org/software/texinfo/\"\n+  # If we are using tex4ht, call it.\n+  run_tex4ht\n \n-# Initialize variables for option overriding and otherwise.\n-# Don't use `unset' since old bourne shells don't have this command.\n-# Instead, assign them an empty value.\n-batch=false     # eval for batch mode\n-clean=\n-debug=\n-escape='\\'\n-expand=         # t for expansion via makeinfo\n-miincludes=     # makeinfo include path\n-oformat=dvi\n-oname=          # --output\n-quiet=          # by default let the tools' message be displayed\n-set_language=\n-textra=\n-tmpdir=${TMPDIR:-/tmp}/t2d$$  # avoid collisions on 8.3 filesystems.\n-txincludes=     # TEXINPUTS extensions, with trailing colon\n-txiprereq=19990129 # minimum texinfo.tex version to have macro expansion\n-verbose=false   # echo for verbose mode\n+  # Install the result if we didn't already (i.e., if the output is\n+  # dvipdf or ps).\n+  case $latex2html:$out_lang in\n+    *:dvipdf)\n+      run_dvipdf \"$in_noext.`out_lang_tex`\"\n+      move_to_dest \"$in_noext.`out_lang_ext`\"\n+      ;;\n+    *:ps)\n+      : ${DVIPS:=dvips}\n+      run $DVIPS -o \"$in_noext.`out_lang_ext`\" \"$in_noext.`out_lang_tex`\"\n+      move_to_dest \"$in_noext.`out_lang_ext`\"\n+      ;;\n+  esac\n \n-orig_pwd=`pwd`\n+  cd_orig\n+}\n \n-# Systems which define $COMSPEC or $ComSpec use semicolons to separate\n-# directories in TEXINPUTS.\n-if test -n \"$COMSPEC$ComSpec\"; then\n-  path_sep=\";\"\n-else\n-  path_sep=\":\"\n-fi\n+## -------------------------------- ##\n+## TeX processing auxiliary tools.  ##\n+## -------------------------------- ##\n \n-# Pacify verbose cds.\n-CDPATH=${ZSH_VERSION+.}$path_sep\n \n-# In case someone crazy insists on using grep -E.\n-: ${EGREP=egrep}\n+# A sed script that preprocesses Texinfo sources in order to keep the\n+# iftex sections only.  We want to remove non-TeX sections, and comment\n+# (with `@c _texi2dvi') TeX sections so that makeinfo does not try to\n+# parse them.  Nevertheless, while commenting TeX sections, don't\n+# comment @macro/@end macro so that makeinfo does propagate them.\n+# Unfortunately makeinfo --iftex --no-ifinfo doesn't work well enough\n+# (yet), makeinfo can't parse the TeX commands, so work around with sed.\n+#\n+# We assume that `@c _texi2dvi' starting a line is not present in the\n+# document.\n+#\n+comment_iftex=\\\n+'/^@tex/,/^@end tex/{\n+  s/^/@c _texi2dvi/\n+}\n+/^@iftex/,/^@end iftex/{\n+  s/^/@c _texi2dvi/\n+  /^@c _texi2dvi@macro/,/^@c _texi2dvi@end macro/{\n+    s/^@c _texi2dvi//\n+  }\n+}\n+/^@ifnottex/,/^@end ifnottex/{\n+  s/^/@c (_texi2dvi)/\n+}\n+/^@ifinfo/,/^@end ifinfo/{\n+  /^@node/p\n+  /^@menu/,/^@end menu/p\n+  t\n+  s/^/@c (_texi2dvi)/\n+}\n+s/^@ifnotinfo/@c _texi2dvi@ifnotinfo/\n+s/^@end ifnotinfo/@c _texi2dvi@end ifnotinfo/'\n+\n+# Uncommenting is simpler: remove any leading `@c texi2dvi'; repeated\n+# copies can sneak in via macro invocations.\n+uncomment_iftex='s/^@c _texi2dvi\\(@c _texi2dvi\\)*//'\n+\n+\n+# run_makeinfo ()\n+# ---------------\n+# Expand macro commands in the original source file using Makeinfo.\n+# Always use `end' footnote style, since the `separate' style\n+# generates different output (arguably this is a bug in -E).  Discard\n+# main info output, the user asked to run TeX, not makeinfo.\n+run_makeinfo ()\n+{\n+  test $in_lang = texinfo \\\n+    || return 0\n+\n+  # Unless required by the user, makeinfo expansion is wanted only\n+  # if texinfo.tex is too old.\n+  if $expand; then\n+    makeinfo=${MAKEINFO:-makeinfo}\n+  else\n+    # Check if texinfo.tex performs macro expansion by looking for\n+    # its version.  The version is a date of the form YEAR-MO-DA.\n+    # We don't need to use [0-9] to match the digits since anyway\n+    # the comparison with $txiprereq, a number, will fail with non-digits.\n+    # Run in a temporary directory to avoid leaving files.\n+    version_test_dir=$t2ddir/version_test\n+    ensure_dir \"$version_test_dir\"\n+    if (\n+       cd \"$version_test_dir\"\n+       echo '\\input texinfo.tex @bye' >txiversion.tex\n+       # Be sure that if tex wants to fail, it is not interactive:\n+       # close stdin.\n+       $TEX txiversion.tex </dev/null >txiversion.out 2>txiversion.err\n+    ); then :; else\n+      report \"texinfo.tex appears to be broken.\n+This may be due to the environment variable TEX set to something\n+other than (plain) tex, a corrupt texinfo.tex file, or \n+to tex itself simply not working.\"\n+      cat \"$version_test_dir/txiversion.out\"\n+      cat \"$version_test_dir/txiversion.err\" >&2\n+      error 1 \"quitting.\"\n+    fi\n+    eval `$SED -n 's/^.*\\[\\(.*\\)version \\(....\\)-\\(..\\)-\\(..\\).*$/txiformat=\\1 txiversion=\"\\2\\3\\4\"/p' \"$version_test_dir/txiversion.out\"`\n+    verbose \"texinfo.tex preloaded as \\`$txiformat', version is \\`$txiversion' ...\"\n+    if test \"$txiprereq\" -le \"$txiversion\" >&6 2>&1; then\n+      makeinfo=\n+    else\n+      makeinfo=${MAKEINFO:-makeinfo}\n+    fi\n+    # If TeX is preloaded, offer the user this convenience:\n+    if test \"$txiformat\" = Texinfo; then\n+      escape=@\n+    fi\n+  fi\n+\n+  if test -n \"$makeinfo\"; then\n+    # in_src: the file with macros expanded.\n+    # Use the same basename to generate the same aux file names.\n+    work_src=$workdir/src\n+    ensure_dir \"$work_src\"\n+    in_src=$work_src/$in_base\n+    local miincludes\n+    miincludes=`list_prefix includes -I`\n+    verbose \"Macro-expanding $command_line_filename to $in_src ...\"\n+    # eval $makeinfo because it might be defined as something complex\n+    # (running missing) and then we end up with things like '\"-I\"',\n+    # and \"-I\" (including the quotes) is not an option name.  This\n+    # happens with gettext 0.14.5, at least.\n+    $SED \"$comment_iftex\" \"$command_line_filename\" \\\n+      | eval $makeinfo --footnote-style=end -I \"$in_dir\" $miincludes \\\n+        -o /dev/null --macro-expand=- \\\n+      | $SED \"$uncomment_iftex\" >\"$in_src\"\n+    # Continue only if everything succeeded.\n+    if test $? -ne 0 \\\n+       || test ! -r \"$in_src\"; then\n+      verbose \"Expansion failed, ignored...\";\n+    else\n+      in_input=$in_src\n+    fi\n+  fi\n+}\n+\n+# insert_commands ()\n+# ------------------\n+# Used most commonly for @finalout, @smallbook, etc.\n+insert_commands ()\n+{\n+  if test -n \"$textra\"; then\n+    # _xtr.  The file with the user's extra commands.\n+    work_xtr=$workdir/xtr\n+    in_xtr=$work_xtr/$in_base\n+    ensure_dir \"$work_xtr\"\n+    verbose \"Inserting extra commands: $textra\"\n+    local textra_cmd\n+    case $in_lang in\n+      latex)   textra_cmd=1i;;\n+      texinfo) textra_cmd='/^@setfilename/a';;\n+      *)       error 1 \"internal error, unknown language: $in_lang\";;\n+    esac\n+    $SED \"$textra_cmd\\\\\n+$textra\" \"$in_input\" >\"$in_xtr\"\n+    in_input=$in_xtr\n+  fi\n \n-# Save this so we can construct a new TEXINPUTS path for each file.\n-TEXINPUTS_orig=\"$TEXINPUTS\"\n-# Unfortunately makeindex does not read TEXINPUTS.\n-INDEXSTYLE_orig=\"$INDEXSTYLE\"\n-export TEXINPUTS INDEXSTYLE\n+  case $in_lang:$latex2html:`out_lang_tex` in\n+    latex:tex4ht:html)\n+      # _tex4ht.  The file with the added \\usepackage{tex4ht}.\n+      work_tex4ht=$workdir/tex4ht\n+      in_tex4ht=$work_tex4ht/$in_base\n+      ensure_dir \"$work_tex4ht\"\n+      verbose \"Inserting \\\\usepackage{tex4ht}\"\n+      perl -pe 's<\\\\documentclass(?:\\[.*\\])?{.*}>\n+                 <$&\\\\usepackage[xhtml]{tex4ht}>' \\\n+        \"$in_input\" >\"$in_tex4ht\"\n+      in_input=$in_tex4ht\n+      ;;\n+  esac\n+}\n+\n+# compute_language FILENAME\n+# -------------------------\n+# Return the short string describing the language in which FILENAME\n+# is written: `texinfo' or `latex'.\n+compute_language ()\n+{\n+  # If the user explicitly specified the language, use that.\n+  # Otherwise, if the first line is \\input texinfo, assume it's texinfo.\n+  # Otherwise, guess from the file extension.\n+  if test -n \"$set_language\"; then\n+    echo $set_language\n+  elif $SED 1q \"$1\" | grep 'input texinfo' >&6; then\n+    echo texinfo\n+  else\n+    # Get the type of the file (latex or texinfo) from the given language\n+    # we just guessed, or from the file extension if not set yet.\n+    case $1 in\n+      *.ltx | *.tex | *.drv | *.dtx) echo latex;;\n+      *)                             echo texinfo;;\n+    esac\n+  fi\n+}\n+\n+\n+# run_hevea (MODE)\n+# ----------------\n+# Convert to HTML/INFO/TEXT.\n+#\n+# Don't pass `-noiso' to hevea: it's useless in HTML since anyway the\n+# charset is set to latin1, and troublesome in other modes since\n+# accented characters loose their accents.\n+#\n+# Don't pass `-o DEST' to hevea because in that case it leaves all its\n+# auxiliary files there too...  Too bad, because it means we will need\n+# to handle images some day.\n+run_hevea ()\n+{\n+  local hevea=\"${HEVEA:-hevea}\"\n+  local run_hevea=\"$hevea\"\n+\n+  case $1 in\n+    html) ;;\n+    text|info) run_hevea=\"$run_hevea -$1\";;\n+    *) error 1 \"run_hevea: invalid argument: $1\";;\n+  esac\n+\n+  # Compiling to the tmp directory enables to preserve a previous\n+  # successful compilation.\n+  run_hevea=\"$run_hevea -fix -O -o '$out_base'\"\n+  run_hevea=\"$run_hevea `list_prefix includes -I` -I '$orig_pwd' \"\n+  run_hevea=\"$run_hevea '$in_input'\"\n+\n+  if $debug; then\n+    run_hevea=\"$run_hevea -v -v\"\n+  fi\n+\n+  verbose \"running $run_hevea\"\n+  if eval \"$run_hevea\" >&5; then\n+    # hevea leaves trailing white spaces, this is annoying.\n+    case $1 in text|info)\n+      perl -pi -e 's/[ \\t]+$//g' \"$out_base\"*;;\n+    esac\n+    case $1 in\n+    html|text) move_to_dest \"$out_base\";;\n+    info) # There can be foo.info-1, foo.info-2 etc.\n+               move_to_dest \"$out_base\"*;;\n+    esac\n+  else\n+    error 1 \"$hevea exited with bad status, quitting.\"\n+  fi\n+}\n+\n+\n+# run_core_conversion ()\n+# ----------------------\n+# Run the TeX (or HeVeA).\n+run_core_conversion ()\n+{\n+  case $in_lang:$latex2html:`out_lang_tex` in\n+    *:dvi|*:pdf|latex:tex4ht:html)\n+        run_tex;;\n+    latex:*:html|latex:*:text|latex:*:info)\n+        run_hevea $out_lang;;\n+    *)\n+        error 1 \"invalid input/output combination: $in_lang/$out_lang\";;\n+  esac\n+}\n+\n+\n+# compile ()\n+# ----------\n+# Run the full compilation chain, from pre-processing to installation\n+# of the output at its expected location.\n+compile ()\n+{\n+  # Source file might include additional sources.\n+  # We want `.:$orig_pwd' before anything else.  (We'll add `.:' later\n+  # after all other directories have been turned into absolute paths.)\n+  # `.' goes first to ensure that any old .aux, .cps,\n+  # etc. files in ${directory} don't get used in preference to fresher\n+  # files in `.'.  Include orig_pwd in case we are in clean build mode, where\n+  # we have cd'd to a temp directory.\n+  common=\"$orig_pwd$path_sep$in_dir$path_sep\"\n+  #\n+  # If we have any includes, put those at the end.\n+  # Keep a final path_sep to get the default (system) TeX directories included.\n+  txincludes=`list_infix includes $path_sep`\n+  test -n \"$txincludes\" && common=\"$common$txincludes$path_sep\"\n+  #\n+  for var in $tex_envvars; do\n+    eval val=\"\\$common\\$${var}_orig\"\n+    # Convert relative paths to absolute paths, so we can run in another\n+    # directory (e.g., in clean build mode, or during the macro-support\n+    # detection). \".:\" is added here.\n+    val=`absolute_filenames \"$val\"`\n+    eval $var=\"\\\"$val\\\"\"\n+    export $var\n+    eval verbose \\\"$var=\\'\\$${var}\\'\\\"\n+  done\n+\n+  # --expand\n+  run_makeinfo\n+\n+  # --command, --texinfo\n+  insert_commands\n+\n+  # Run until a fix point is reached.\n+  run_tex_suite\n+}\n+\n+\n+# remove FILES\n+# ------------\n+remove ()\n+{\n+  verbose \"Removing\" \"$@\"\n+  rm -rf \"$@\"\n+}\n+\n+\n+# mostly_clean\n+# ------------\n+# Remove auxiliary files and directories.  Changes the current directory.\n+mostly_clean ()\n+{\n+  cd_orig\n+  set X \"$t2ddir\"\n+  shift\n+  $tidy || {\n+    local log=\"$work_build/$in_noext.log\"\n+    set X ${1+\"$@\"} \"$log\" `generated_files_get \"$work_build/$in_noext\"`\n+    shift\n+  }\n+  remove ${1+\"$@\"}\n+}\n+\n+\n+# cleanup ()\n+# ----------\n+# Remove what should be removed according to options.\n+# Called at the end of each compilation cycle, and at the end of\n+# the script.  Changes the current directory.\n+cleanup ()\n+{\n+  case $build_mode in\n+    local) cd_orig; remove \"$t2ddir\";;\n+    clean) mostly_clean;;\n+    tidy)  ;;\n+  esac\n+}\n+\n+\n+\n+## ---------------------- ##\n+## Command line parsing.  ##\n+## ---------------------- ##\n \n # Push a token among the arguments that will be used to notice when we\n # ended options/arguments parsing.\n@@ -132,41 +1647,50 @@ while test x\"$1\" != x\"$arg_sep\"; do\n   # Handle --option=value by splitting apart and putting back on argv.\n   case \"$1\" in\n     --*=*)\n-      opt=`echo \"$1\" | sed -e 's/=.*//'`\n-      val=`echo \"$1\" | sed -e 's/[^=]*=//'`\n+      opt=`echo \"$1\" | $SED -e 's/=.*//'`\n+      val=`echo \"$1\" | $SED -e 's/[^=]*=//'`\n       shift\n       set dummy \"$opt\" \"$val\" ${1+\"$@\"}; shift\n       ;;\n   esac\n \n-  # This recognizes --quark as --quiet.  So what.\n   case \"$1\" in\n     -@ ) escape=@;;\n+    -~ ) catcode_special=false;;\n     # Silently and without documentation accept -b and --b[atch] as synonyms.\n-    -b | --b*) batch=eval;;\n-    -q | -s | --q* | --s*) quiet=t; batch=eval;;\n-    -c | --c*) clean=t;;\n-    -D | --d*) debug=t;;\n-    -e | -E | --e*) expand=t;;\n-    -h | --h*) echo \"$usage\"; exit 0;;\n-    -I | --I*)\n+    -b | --batch) batch=true;;\n+         --build)      shift; build_mode=$1;;\n+         --build-dir)  shift; build_dir=$1; build_mode=tidy;;\n+    -c | --clean) build_mode=clean;;\n+    -D | --debug) debug=true;;\n+    -e | -E | --expand) expand=true;;\n+    -h | --help) usage;;\n+    -I)   shift; list_concat_dirs includes \"$1\";;\n+    -l | --lang | --language) shift; set_language=$1;;\n+    --mostly-clean) action=mostly-clean;;\n+    --no-line-error) line_error=false;;\n+    --max-iterations) shift; max_iters=$1;;\n+    -o | --out  | --output)\n       shift\n-      miincludes=\"$miincludes -I $1\"\n-      txincludes=\"$txincludes$1$path_sep\"\n-      ;;\n-    -l | --l*) shift; set_language=$1;;\n-    -o | --o*)\n-      shift\n-      clean=t\n-      case \"$1\" in\n-        /* | ?:/*) oname=$1;;\n-                *) oname=\"$orig_pwd/$1\";;\n-      esac;;\n-    -p | --p*) oformat=pdf;;\n-    -t | --t*) shift; textra=\"$textra\\\\\n-$1\";;\n-    -v | --vers*) echo \"$version\"; exit 0;;\n-    -V | --verb*) verbose=echo;;\n+      # Make it absolute, just in case we also have --clean, or whatever.\n+      oname=`absolute \"$1\"`;;\n+\n+    # Output formats.\n+    -O|--output-format) shift; out_lang_set \"$1\";;\n+       --dvi|--dvipdf|--html|--info|--pdf|--ps|--text)\n+       out_lang_set `echo \"x$1\" | $SED 's/^x--//'`;;\n+\n+    -p) out_lang_set pdf;;\n+    -q | -s | --quiet | --silent) quiet=true; batch=true;;\n+    --src-specials) src_specials=--src-specials;;\n+    --shell-escape) shell_escape=--shell-escape;;  \n+    --tex4ht) latex2html=tex4ht;;\n+    -t | --texinfo | --command ) shift; textra=\"$textra\\\\\n+\"`echo \"$1\" | $SED 's/\\\\\\\\/\\\\\\\\\\\\\\\\/g'`;;\n+    --translate-file ) shift; translate_file=\"$1\";;\n+    --tidy) build_mode=tidy;;\n+    -v | --vers*) version;;\n+    -V | --verb*) verb=true;;\n     --) # What remains are not options.\n       shift\n       while test x\"$1\" != x\"$arg_sep\"; do\n@@ -175,113 +1699,69 @@ $1\";;\n       done\n       break;;\n     -*)\n-      echo \"$0: Unknown or ambiguous option \\`$1'.\" >&2\n-      echo \"$0: Try \\`--help' for more information.\" >&2\n-      exit 1;;\n+      error 1 \"Unknown or ambiguous option \\`$1'.\" \\\n+              \"Try \\`--help' for more information.\"\n+      ;;\n     *) set dummy ${1+\"$@\"} \"$1\"; shift;;\n    esac\n    shift\n done\n # Pop the token\n shift\n \n+# $tidy:  compile in a t2d directory.\n+# $clean: remove all the aux files.\n+case $build_mode in\n+  local) clean=false; tidy=false;;\n+  tidy)  clean=false; tidy=true;;\n+  clean) clean=true;  tidy=true;;\n+      *) error 1 \"invalid build mode: $build_mode\";;\n+esac\n+\n # Interpret remaining command line args as filenames.\n case $# in\n  0)\n-  echo \"$0: Missing file arguments.\" >&2\n-  echo \"$0: Try \\`--help' for more information.\" >&2\n-  exit 2\n+  error 2 \"Missing file arguments.\" \"Try \\`--help' for more information.\"\n   ;;\n  1) ;;\n  *)\n   if test -n \"$oname\"; then\n-    echo \"$0: Can't use option \\`--output' with more than one argument.\" >&2\n-    exit 2\n+    error 2 \"Can't use option \\`--output' with more than one argument.\"\n   fi\n   ;;\n esac\n \n-# Prepare the temporary directory.  Remove it at exit, unless debugging.\n-if test -z \"$debug\"; then\n-  trap \"cd / && rm -rf $tmpdir\" 0 1 2 15\n-fi\n \n-# Create the temporary directory with strict rights\n-(umask 077 && mkdir $tmpdir) || exit 1\n+# We can't do much without tex.\n+#\n+if findprog ${TEX:-tex}; then :; else cat <<EOM\n+You don't have a working TeX binary (${TEX:-tex}) installed anywhere in\n+your PATH, and texi2dvi cannot proceed without one.  If you want to use\n+this script, you'll need to install TeX (if you don't have it) or change\n+your PATH or TEX environment variable (if you do).  See the --help\n+output for more details.\n \n-# Prepare the tools we might need.  This may be extra work in some\n-# cases, but improves the readibility of the script.\n-utildir=$tmpdir/utils\n-mkdir $utildir || exit 1\n+For information about obtaining TeX, please see http://tug.org/texlive,\n+or do a web search for TeX and your operating system or distro.\n+EOM\n+  exit 1\n+fi\n \n-# A sed script that preprocesses Texinfo sources in order to keep the\n-# iftex sections only.  We want to remove non TeX sections, and\n-# comment (with `@c texi2dvi') TeX sections so that makeinfo does not\n-# try to parse them.  Nevertheless, while commenting TeX sections,\n-# don't comment @macro/@end macro so that makeinfo does propagate\n-# them.  Unfortunately makeinfo --iftex --no-ifhtml --no-ifinfo\n-# doesn't work well enough (yet) to use that, so work around with sed.\n-comment_iftex_sed=$utildir/comment.sed\n-cat <<EOF >$comment_iftex_sed\n-/^@tex/,/^@end tex/{\n-  s/^/@c texi2dvi/\n-}\n-/^@iftex/,/^@end iftex/{\n-  s/^/@c texi2dvi/\n-  /^@c texi2dvi@macro/,/^@c texi2dvi@end macro/{\n-    s/^@c texi2dvi//\n-  }\n-}\n-/^@html/,/^@end html/{\n-  s/^/@c (texi2dvi)/\n-}\n-/^@ifhtml/,/^@end ifhtml/{\n-  s/^/@c (texi2dvi)/\n-}\n-/^@ifnottex/,/^@end ifnottex/{\n-  s/^/@c (texi2dvi)/\n-}\n-/^@ifinfo/,/^@end ifinfo/{\n-  /^@node/p\n-  /^@menu/,/^@end menu/p\n-  t\n-  s/^/@c (texi2dvi)/\n-}\n-s/^@ifnotinfo/@c texi2dvi@ifnotinfo/\n-s/^@end ifnotinfo/@c texi2dvi@end ifnotinfo/\n-EOF\n-# Uncommenting is simple: Remove any leading `@c texi2dvi'.\n-uncomment_iftex_sed=$utildir/uncomment.sed\n-cat <<EOF >$uncomment_iftex_sed\n-s/^@c texi2dvi//\n-EOF\n \n-# A shell script that computes the list of xref files.\n-# Takes the filename (without extension) of which we look for xref\n-# files as argument.  The index files must be reported last.\n-get_xref_files=$utildir/get_xref.sh\n-cat <<\\EOF >$get_xref_files\n-#! /bin/sh\n+# We want to use etex (or pdftex) if they are available, and the user\n+# didn't explicitly specify.  We don't check for elatex and pdfelatex\n+# because (as of 2003), the LaTeX team has asked that new distributions\n+# use etex by default anyway.\n+#\n+# End up with the TEX and PDFTEX variables set to what we are going to use.\n+if test -z \"$TEX\"; then\n+  if findprog etex; then TEX=etex; else TEX=tex; fi\n+fi\n+#\n+if test -z \"$PDFTEX\"; then\n+  if findprog pdfetex; then PDFTEX=pdfetex; else PDFTEX=pdftex; fi\n+fi\n \n-# Get list of xref files (indexes, tables and lists).\n-# Find all files having root filename with a two-letter extension,\n-# saves the ones that are really Texinfo-related files.  .?o? catches\n-# many files: .toc, .log, LaTeX tables and lists, FiXme's .lox, maybe more.\n-for this_file in \"$1\".?o? \"$1\".aux \"$1\".?? \"$1\".idx; do\n-  # If file is empty, skip it.\n-  test -s \"$this_file\" || continue\n-  # If the file is not suitable to be an index or xref file, don't\n-  # process it.  The file can't be if its first character is not a\n-  # backslash or single quote.\n-  first_character=`sed -n '1s/^\\(.\\).*$/\\1/p;q' $this_file`\n-  if test \"x$first_character\" = \"x\\\\\" \\\n-     || test \"x$first_character\" = \"x'\"; then\n-    xref_files=\"$xref_files ./$this_file\"\n-  fi\n-done\n-echo \"$xref_files\"\n-EOF\n-chmod 500 $get_xref_files\n \n # File descriptor usage:\n # 0 standard input\n@@ -290,369 +1770,175 @@ chmod 500 $get_xref_files\n # 3 some systems may open it to /dev/tty\n # 4 used on the Kubota Titan\n # 5 tools output (turned off by --quiet)\n+# 6 tracing/debugging (set -x output, etc.)\n+\n \n-# Tools' output.  If quiet, discard, else redirect to the message flow.\n-if test \"$quiet\" = t; then\n+# Main tools' output (TeX, etc.) that TeX users are used to seeing.\n+#\n+# If quiet, discard, else redirect to the message flow.\n+if $quiet; then\n   exec 5>/dev/null\n else\n   exec 5>&1\n fi\n \n-# Enable tracing\n-test \"$debug\" = t && set -x\n+\n+# Enable tracing, and auxiliary tools output.\n+# \n+# This fd should be used where you'd typically use /dev/null to throw\n+# output away.  But sometimes it is convenient to see that output (e.g.,\n+# from a grep) to aid debugging.  Especially debugging at distance, via\n+# the user.\n+# \n+if $debug; then\n+  exec 6>&1\n+  set -vx\n+else\n+  exec 6>/dev/null\n+fi\n \n # \f\n-# TeXify files.\n \n-for command_line_filename in ${1+\"$@\"}; do\n-  $verbose \"Processing $command_line_filename ...\"\n+# input_file_name_decode\n+# ----------------------\n+# Decode COMMAND_LINE_FILENAME, and compute:\n+# - COMMAND_LINE_FILENAME clean of TeX commands\n+# - IN_DIR\n+#   The directory to the input file, possibly absolute if needed.\n+# - IN_DIR_ABS\n+#   The absolute directory of the input file.\n+# - IN_BASE\n+#   The input file base name (no directory part).\n+# - IN_NOEXT\n+#   The input file name without extensions (nor directory part).\n+# - IN_INPUT\n+#   Defaults to COMMAND_LINE_FILENAME, but might change if the\n+#   input is preprocessed.  With directory, possibly absolute.\n+input_file_name_decode ()\n+{\n+  # See if we are run from within AUC-Tex, in which case we are\n+  # passed `\\input{FOO.tex}' or even `\\nonstopmode\\input{FOO.tex}'.\n+  case $command_line_filename in\n+    *\\\\nonstopmode*)\n+      batch=true;;\n+  esac\n+  case $command_line_filename in\n+    *\\\\input{*}*)\n+      # Let AUC-TeX error parser deal with line numbers.\n+      line_error=false\n+      command_line_filename=`\\\n+        expr X\"$command_line_filename\" : X'.*input{\\([^}]*\\)}'`\n+      ;;\n+  esac\n \n   # If the COMMAND_LINE_FILENAME is not absolute (e.g., --debug.tex),\n   # prepend `./' in order to avoid that the tools take it as an option.\n-  echo \"$command_line_filename\" | $EGREP '^(/|[A-z]:/)' >/dev/null \\\n+  echo \"$command_line_filename\" | LC_ALL=C $EGREP '^(/|[A-Za-z]:/)' >&6 \\\n   || command_line_filename=\"./$command_line_filename\"\n \n   # See if the file exists.  If it doesn't we're in trouble since, even\n   # though the user may be able to reenter a valid filename at the tex\n   # prompt (assuming they're attending the terminal), this script won't\n   # be able to find the right xref files and so forth.\n-  if test ! -r \"$command_line_filename\"; then\n-    echo \"$0: Could not read $command_line_filename, skipping.\" >&2\n-    continue\n-  fi\n+  test -r \"$command_line_filename\" \\\n+  || error 1 \"cannot read $command_line_filename, skipping.\"\n \n-  # Get the name of the current directory.  We want the full path\n-  # because in clean mode we are in tmp, in which case a relative\n-  # path has no meaning.\n-  filename_dir=`echo $command_line_filename | sed 's!/[^/]*$!!;s!^$!.!'`\n-  filename_dir=`cd \"$filename_dir\" >/dev/null && pwd`\n+  # Get the name of the current directory.\n+  in_dir=`func_dirname \"$command_line_filename\"`\n+  in_dir_abs=`absolute \"$in_dir\"`\n+  # In a clean build, we `cd', so get an absolute file name.\n+  if $tidy; then\n+    in_dir=$in_dir_abs\n+  fi\n \n   # Strip directory part but leave extension.\n-  filename_ext=`basename \"$command_line_filename\"`\n+  in_base=`basename \"$command_line_filename\"`\n   # Strip extension.\n-  filename_noext=`echo \"$filename_ext\" | sed 's/\\.[^.]*$//'`\n-  ext=`echo \"$filename_ext\" | sed 's/^.*\\.//'`\n-\n-  # _src.  Use same basename since we want to generate aux files with\n-  # the same basename as the manual.  If --expand, then output the\n-  # macro-expanded file to here, else copy the original file.\n-  tmpdir_src=$tmpdir/src\n-  filename_src=$tmpdir_src/$filename_noext.$ext\n-\n-  # _xtr.  The file with the user's extra commands.\n-  tmpdir_xtr=$tmpdir/xtr\n-  filename_xtr=$tmpdir_xtr/$filename_noext.$ext\n-\n-  # _bak.  Copies of the previous xref files (another round is run if\n-  # they differ from the new one).\n-  tmpdir_bak=$tmpdir/bak\n+  in_noext=`noext \"$in_base\"`\n \n-  # Make all those directories and give up if we can't succeed.\n-  mkdir $tmpdir_src $tmpdir_xtr $tmpdir_bak || exit 1\n+  # The normalized file name to compile.  Must always point to the\n+  # file to actually compile (in case of recoding, macro-expansion etc.).\n+  in_input=$in_dir/$in_base\n \n-  # Source file might include additional sources.\n-  # We want `.:$orig_pwd' before anything else.  (We'll add `.:' later\n-  # after all other directories have been turned into absolute paths.)\n-  # `.' goes first to ensure that any old .aux, .cps,\n-  # etc. files in ${directory} don't get used in preference to fresher\n-  # files in `.'.  Include orig_pwd in case we are in clean mode, where\n-  # we've cd'd to a temp directory.\n-  common=\"$orig_pwd$path_sep$filename_dir$path_sep$txincludes\"\n-   TEXINPUTS=\"$common$TEXINPUTS_orig\"\n-  INDEXSTYLE=\"$common$INDEXSTYLE_orig\"\n-\n-  # Convert relative paths to absolute paths, so we can run in another\n-  # directory (e.g., in --clean mode, or during the macro-support\n-  # detection.)\n-  #\n-  # Empty path components are meaningful to tex.  We rewrite them\n-  # as `EMPTY' so they don't get lost when we split on $path_sep.\n-   TEXINPUTS=`echo $TEXINPUTS  |sed 's/^:/EMPTY:/;s/:$/:EMPTY/;s/::/:EMPTY:/g'`\n-  INDEXSTYLE=`echo $INDEXSTYLE |sed 's/^:/EMPTY:/;s/:$/:EMPTY/;s/::/:EMPTY:/g'`\n-  save_IFS=$IFS\n-  IFS=$path_sep\n-  set x $TEXINPUTS; shift\n-  TEXINPUTS=.\n-  for dir\n-  do\n-    case $dir in\n-      EMPTY)\n-        TEXINPUTS=$TEXINPUTS$path_sep\n-        ;;\n-      [\\\\/]* | ?:[\\\\/]*)        # Absolute paths don't need to be expansed.\n-        TEXINPUTS=$TEXINPUTS$path_sep$dir\n-        ;;\n-      *)\n-        abs=`cd \"$dir\" && pwd` && TEXINPUTS=$TEXINPUTS$path_sep$abs\n-        ;;\n-    esac\n-  done\n-  set x $INDEXSTYLE; shift\n-  INDEXSTYLE=.\n-  for dir\n-  do\n-    case $dir in\n-      EMPTY)\n-        INDEXSTYLE=$INDEXSTYLE$path_sep\n-        ;;\n-      [\\\\/]* | ?:[\\\\/]*)        # Absolute paths don't need to be expansed.\n-        INDEXSTYLE=$INDEXSTYLE$path_sep$dir\n-        ;;\n-      *)\n-        abs=`cd \"$dir\" && pwd` && INDEXSTYLE=$INDEXSTYLE$path_sep$abs\n-        ;;\n-    esac\n-  done\n-  IFS=$save_IFS\n \n-  # If the user explicitly specified the language, use that.\n-  # Otherwise, if the first line is \\input texinfo, assume it's texinfo.\n-  # Otherwise, guess from the file extension.\n-  if test -n \"$set_language\"; then\n-    language=$set_language\n-  elif sed 1q \"$command_line_filename\" | grep 'input texinfo' >/dev/null; then\n-    language=texinfo\n+  # Compute the output file name.\n+  if test x\"$oname\" != x; then\n+    out_name=$oname\n   else\n-    language=\n-  fi\n-\n-  # Get the type of the file (latex or texinfo) from the given language\n-  # we just guessed, or from the file extension if not set yet.\n-  case ${language:-$filename_ext} in\n-    [lL]a[tT]e[xX] | *.ltx | *.tex)\n-      # Assume a LaTeX file.  LaTeX needs bibtex and uses latex for\n-      # compilation.  No makeinfo.\n-      bibtex=${BIBTEX:-bibtex}\n-      makeinfo= # no point in running makeinfo on latex source.\n-      texindex=${MAKEINDEX:-makeindex}\n-      if test $oformat = dvi; then\n-        tex=${LATEX:-latex}\n-      else\n-        tex=${PDFLATEX:-pdflatex}\n-      fi\n-      ;;\n-\n-    *)\n-      # Assume a Texinfo file.  Texinfo files need makeinfo, texindex and tex.\n-      bibtex=\n-      texindex=${TEXINDEX:-texindex}\n-      if test $oformat = dvi; then\n-        tex=${TEX:-tex}\n-      else\n-        tex=${PDFTEX:-pdftex}\n-      fi\n-      # Unless required by the user, makeinfo expansion is wanted only\n-      # if texinfo.tex is too old.\n-      if test \"$expand\" = t; then\n-        makeinfo=${MAKEINFO:-makeinfo}\n-      else\n-        # Check if texinfo.tex performs macro expansion by looking for\n-        # its version.  The version is a date of the form YEAR-MO-DA.\n-        # We don't need to use [0-9] to match the digits since anyway\n-        # the comparison with $txiprereq, a number, will fail with non\n-        # digits.\n-        txiversion_tex=txiversion.tex\n-        echo '\\input texinfo.tex @bye' >$tmpdir/$txiversion_tex\n-        # Run in the tmpdir to avoid leaving files.\n-        eval `cd $tmpdir >/dev/null &&\n-              $tex $txiversion_tex 2>/dev/null |\n-              sed -n 's/^.*\\[\\(.*\\)version \\(....\\)-\\(..\\)-\\(..\\).*$/txiformat=\\1 txiversion=\"\\2\\3\\4\"/p'`\n-        $verbose \"texinfo.tex preloaded as \\`$txiformat', version is \\`$txiversion' ...\"\n-        if test \"$txiprereq\" -le \"$txiversion\" >/dev/null 2>&1; then\n-          makeinfo=\n-        else\n-          makeinfo=${MAKEINFO:-makeinfo}\n-        fi\n-        # As long as we had to run TeX, offer the user this convenience\n-        if test \"$txiformat\" = Texinfo; then\n-          escape=@\n-        fi\n-      fi\n-      ;;\n-  esac\n-\n-  # Expand macro commands in the original source file using Makeinfo.\n-  # Always use `end' footnote style, since the `separate' style\n-  #   generates different output (arguably this is a bug in -E).\n-  # Discard main info output, the user asked to run TeX, not makeinfo.\n-  if test -n \"$makeinfo\"; then\n-    $verbose \"Macro-expanding $command_line_filename to $filename_src ...\"\n-    sed -f $comment_iftex_sed \"$command_line_filename\" \\\n-      | $makeinfo --footnote-style=end -I \"$filename_dir\" $miincludes \\\n-        -o /dev/null --macro-expand=- \\\n-      | sed -f $uncomment_iftex_sed >\"$filename_src\"\n-    filename_input=$filename_src\n-  fi\n-\n-  # If makeinfo failed (or was not even run), use the original file as input.\n-  if test $? -ne 0 \\\n-     || test ! -r \"$filename_src\"; then\n-    $verbose \"Reverting to $command_line_filename ...\"\n-    filename_input=$filename_dir/$filename_ext\n-  fi\n-\n-  # Used most commonly for @finalout, @smallbook, etc.\n-  if test -n \"$textra\"; then\n-    $verbose \"Inserting extra commands: $textra\"\n-    sed '/^@setfilename/a\\\n-'\"$textra\" \"$filename_input\" >$filename_xtr\n-    filename_input=$filename_xtr\n+    out_name=$in_noext.`out_lang_ext`\n   fi\n+  out_dir=`func_dirname \"$out_name\"`\n+  out_dir_abs=`absolute \"$out_dir\"`\n+  out_base=`basename \"$out_name\"`\n+  out_noext=`noext \"$out_base\"`\n+}\n \n-  # If clean mode was specified, then move to the temporary directory.\n-  if test \"$clean\" = t; then\n-    $verbose \"cd $tmpdir_src\"\n-    cd \"$tmpdir_src\" || exit 1\n-  fi\n \n-  while :; do # will break out of loop below\n-    orig_xref_files=`$get_xref_files \"$filename_noext\"`\n+## -------------- ##\n+## TeXify files.  ##\n+## -------------- ##\n \n-    # Save copies of originals for later comparison.\n-    if test -n \"$orig_xref_files\"; then\n-      $verbose \"Backing up xref files: `echo $orig_xref_files | sed 's|\\./||g'`\"\n-      cp $orig_xref_files $tmpdir_bak\n-    fi\n+for command_line_filename\n+do\n+  verbose \"Processing $command_line_filename ...\"\n \n-    # Run bibtex on current file.\n-    # - If its input (AUX) exists.\n-    # - If AUX contains both `\\bibdata' and `\\bibstyle'.\n-    # - If some citations are missing (LOG contains `Citation').\n-    #   or the LOG complains of a missing .bbl\n-    #\n-    # We run bibtex first, because I can see reasons for the indexes\n-    # to change after bibtex is run, but I see no reason for the\n-    # converse.\n-    #\n-    # Don't try to be too smart.  Running bibtex only if the bbl file\n-    # exists and is older than the LaTeX file is wrong, since the\n-    # document might include files that have changed.  Because there\n-    # can be several AUX (if there are \\include's), but a single LOG,\n-    # looking for missing citations in LOG is easier, though we take\n-    # the risk to match false messages.\n-    if test -n \"$bibtex\" \\\n-       && test -r \"$filename_noext.aux\" \\\n-       && test -r \"$filename_noext.log\" \\\n-       && (grep '^\\\\bibdata[{]'  \"$filename_noext.aux\" \\\n-           && grep '^\\\\bibstyle[{]' \"$filename_noext.aux\" \\\n-           && (grep 'Warning:.*Citation.*undefined' \"$filename_noext.log\" \\\n-               || grep 'No file .*\\.bbl\\.' \"$filename_noext.log\")) \\\n-          >/dev/null 2>&1; \\\n-    then\n-      $verbose \"Running $bibtex $filename_noext ...\"\n-      if $bibtex \"$filename_noext\" >&5; then :; else\n-        echo \"$0: $bibtex exited with bad status, quitting.\" >&2\n-        exit 1\n-      fi\n-    fi\n+  input_file_name_decode\n \n-    # What we'll run texindex on -- exclude non-index files.\n-    # Since we know index files are last, it is correct to remove everything\n-    # before .aux and .?o?.  But don't really do <anything>o<anything>\n-    # -- don't match whitespace as <anything>.\n-    # Otherwise, if orig_xref_files contains something like\n-    #   foo.xo foo.whatever\n-    # the space after the o will get matched.\n-    index_files=`echo \"$orig_xref_files\" \\\n-                 | sed \"s!.*\\.aux!!g;\n-                        s!./$filename_noext\\.[^ ]o[^ ]!!g;\n-                        s/^[ ]*//;s/[ ]*$//\"`\n-    # Run texindex (or makeindex) on current index files.  If they\n-    # already exist, and after running TeX a first time the index\n-    # files don't change, then there's no reason to run TeX again.\n-    # But we won't know that if the index files are out of date or\n-    # nonexistent.\n-    if test -n \"$texindex\" && test -n \"$index_files\"; then\n-      $verbose \"Running $texindex $index_files ...\"\n-      if $texindex $index_files 2>&5 1>&2; then :; else\n-         echo \"$0: $texindex exited with bad status, quitting.\" >&2\n-         exit 1\n-      fi\n-    fi\n+  # `texinfo' or `latex'?\n+  in_lang=`compute_language \"$command_line_filename\"`\n \n-    # Finally, run TeX.\n-    # Prevent $ESCAPE from being interpreted by the shell if it happens\n-    # to be `/'.\n-    $batch tex_args=\"\\\\${escape}nonstopmode\\ \\\\${escape}input\"\n-    cmd=\"$tex $tex_args $filename_input\"\n-    $verbose \"Running $cmd ...\"\n-    if $cmd >&5; then :; else\n-      echo \"$0: $tex exited with bad status, quitting.\" >&2\n-      echo \"$0: see $filename_noext.log for errors.\" >&2\n-      test \"$clean\" = t \\\n-        && cp \"$filename_noext.log\" \"$orig_pwd\"\n-      exit 1\n-    fi\n+  # An auxiliary directory used for all the auxiliary tasks involved\n+  # in compiling this document.\n+  case $build_dir in\n+      '' | . ) t2ddir=$out_noext.t2d ;;\n+      *) # Avoid collisions between multiple occurrences of the same\n+         # file, so depend on the output path.  Remove leading `./',\n+         # at least to avoid creating a file starting with `.!', i.e.,\n+         # an invisible file. The sed expression is fragile if the cwd\n+         # has active characters.  Transform / into ! so that we don't\n+         # need `mkdir -p'.  It might be something to reconsider.\n+         t2ddir=$build_dir/`echo \"$out_dir_abs/$out_noext.t2d\" |\n+             $SED \"s,^$orig_pwd/,,;s,^\\./,,;s,/,!,g\"`\n+  esac\n+  # Remove it at exit if clean mode.\n+  trap \"cleanup\" 0 1 2 15\n \n+  ensure_dir \"$build_dir\" \"$t2ddir\"\n \n-    # Decide if looping again is needed.\n-    finished=t\n+  # We will change directory, better work with an absolute path...\n+  t2ddir=`absolute \"$t2ddir\"`\n+  # Sometimes there are incompatibilities between auxiliary files for\n+  # DVI and PDF.  The contents can also change whether we work on PDF\n+  # and/or DVI.  So keep separate spaces for each.\n+  workdir=$t2ddir/`out_lang_tex`\n+  ensure_dir \"$workdir\"\n \n-    # LaTeX (and the package changebar) report in the LOG file if it\n-    # should be rerun.  This is needed for files included from\n-    # subdirs, since texi2dvi does not try to compare xref files in\n-    # subdirs.  Performing xref files test is still good since LaTeX\n-    # does not report changes in xref files.\n-    if grep \"Rerun to get\" \"$filename_noext.log\" >/dev/null 2>&1; then\n-      finished=\n-    fi\n+  # _build.  In a tidy build, where the auxiliary files are output.\n+  if $tidy; then\n+    work_build=$workdir/build\n+  else\n+    work_build=.\n+  fi\n \n-    # Check if xref files changed.\n-    new_xref_files=`$get_xref_files \"$filename_noext\"`\n-    $verbose \"Original xref files = `echo $orig_xref_files | sed 's|\\./||g'`\"\n-    $verbose \"New xref files      = `echo $new_xref_files | sed 's|\\./||g'`\"\n-\n-    # If old and new lists don't at least have the same file list,\n-    # then one file or another has definitely changed.\n-    test \"x$orig_xref_files\" != \"x$new_xref_files\" && finished=\n-\n-    # File list is the same.  We must compare each file until we find\n-    # a difference.\n-    if test -n \"$finished\"; then\n-      for this_file in $new_xref_files; do\n-        $verbose \"Comparing xref file `echo $this_file | sed 's|\\./||g'` ...\"\n-        # cmp -s returns nonzero exit status if files differ.\n-        if cmp -s \"$this_file\" \"$tmpdir_bak/$this_file\"; then :; else\n-          # We only need to keep comparing until we find one that\n-          # differs, because we'll have to run texindex & tex again no\n-          # matter how many more there might be.\n-          finished=\n-          $verbose \"xref file `echo $this_file | sed 's|\\./||g'` differed ...\"\n-          test \"$debug\" = t && diff -c \"$tmpdir_bak/$this_file\" \"$this_file\"\n-          break\n-        fi\n-      done\n-    fi\n+  # _bak.  Copies of the previous auxiliary files (another round is\n+  # run if they differ from the new ones).\n+  work_bak=$workdir/bak\n \n-    # If finished, exit the loop, else rerun the loop.\n-    test -n \"$finished\" && break\n-  done\n+  # Make those directories.\n+  ensure_dir \"$work_build\" \"$work_bak\"\n \n-  # If we were in clean mode, compilation was in a tmp directory.\n-  # Copy the DVI (or PDF) file into the directory where the compilation\n-  # has been done.  (The temp dir is about to get removed anyway.)\n-  # We also return to the original directory so that\n-  # - the next file is processed in correct conditions\n-  # - the temporary file can be removed\n-  if test -n \"$clean\"; then\n-    if test -n \"$oname\"; then\n-       dest=$oname\n-    else\n-       dest=$orig_pwd\n-    fi\n-    $verbose \"Copying $oformat file from `pwd` to $dest\"\n-    cp -p \"./$filename_noext.$oformat\" \"$dest\"\n-    cd / # in case $orig_pwd is on a different drive (for DOS)\n-    cd $orig_pwd || exit 1\n-  fi\n+  case $action in\n+    compile)\n+      # Compile the document.\n+      compile\n+      cleanup\n+      ;;\n \n-  # Remove temporary files.\n-  if test \"x$debug\" = \"x\"; then\n-    $verbose \"Removing $tmpdir_src $tmpdir_xtr $tmpdir_bak ...\"\n-    cd /\n-    rm -rf $tmpdir_src $tmpdir_xtr $tmpdir_bak\n-  fi\n+    mostly-clean)\n+      mostly_clean\n+      ;;\n+  esac\n done\n \n-$verbose \"$0 done.\"\n+verbose \"done.\"\n exit 0 # exit successfully, not however we ended the loop."
    },
    {
      "sha": "13b55884c34c1c37a4107661b53e922d4c365ceb",
      "filename": "readline/doc/texi2html",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/texi2html",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/texi2html",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/texi2html?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -35,7 +35,7 @@ require 5.0;\n #--##############################################################################\n \n # CVS version:\n-# $Id$\n+# $Id: texi2html.pl,v 1.55 2000/07/27 14:39:41 obachman Exp $\n \n # Homepage:\n $T2H_HOMEPAGE = <<EOT;\n@@ -91,7 +91,7 @@ eval { ($T2H_USER = (getpwuid ($<))[6]) =~ s/,.*//;}; # Who am i\n # Copy this file and make changes to it, if you like.\n # Afterwards, either, load it with command-line option -init_file <your_init_file>\n #\n-# $Id$\n+# $Id: texi2html.init,v 1.34 2000/07/27 14:09:02 obachman Exp $\n \n ######################################################################\n # stuff which can also be set by command-line options\n@@ -1509,7 +1509,7 @@ package Getopt::MySimple;\n \n # --------------------------------------------------------------------------\n # Locally modified by obachman (Display type instead of env, order by cmp)\n-# $Id$\n+# $Id: MySimple.pm,v 1.1 2000/07/03 08:44:13 obachman Exp $\n \n # use strict;\n # no strict 'refs';"
    },
    {
      "sha": "9dc2998ab1390038396c65e0732f105df1cfb18c",
      "filename": "readline/doc/version.texi",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/version.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/doc/version.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/doc/version.texi?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,10 +1,10 @@\n @ignore\n-Copyright (C) 1988-2011 Free Software Foundation, Inc. \n+Copyright (C) 1988-2016 Free Software Foundation, Inc. \n @end ignore\n \n-@set EDITION 6.2\n-@set VERSION 6.2\n-@set UPDATED September 6 2010\n-@set UPDATED-MONTH September 2010\n+@set EDITION 7.0\n+@set VERSION 7.0\n+@set UPDATED 16 July 2016\n+@set UPDATED-MONTH July 2016\n \n-@set LASTCHANGE Mon Sep  6 22:07:10 EDT 2010\n+@set LASTCHANGE Sat Jul 16 13:43:15 EDT 2016"
    },
    {
      "sha": "5094c6c5254f16894bdce9775f7223292369c0c2",
      "filename": "readline/examples/Makefile.in",
      "status": "modified",
      "additions": 41,
      "deletions": 15,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/Makefile.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -53,11 +53,9 @@ CPPFLAGS = @CPPFLAGS@\n \n INCLUDES = -I$(srcdir) -I$(top_srcdir) -I..\n \n-CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(CPPFLAGS) $(INCLUDES) $(CFLAGS)\n+CCFLAGS  = $(DEFS) $(LOCAL_CFLAGS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n LDFLAGS = -g -L.. @LDFLAGS@\n \n-PURIFY = @PURIFY@\n-\n READLINE_LIB = ../libreadline.a\n HISTORY_LIB = ../libhistory.a\n \n@@ -68,11 +66,19 @@ TERMCAP_LIB = @TERMCAP_LIB@\n \t$(CC) $(CCFLAGS) -c $<\n \n SOURCES = excallback.c fileman.c histexamp.c manexamp.c rl-fgets.c rl.c \\\n-\t\trlcat.c rlevent.c rlptytest.c rltest.c rlversion.c\n+\t\trlbasic.c rlcat.c rlevent.c rlptytest.c rltest.c rlversion.c \\\n+\t\trl-callbacktest.c hist_erasedups.c hist_purgecmd.c \n \n EXECUTABLES = fileman$(EXEEXT) rltest$(EXEEXT) rl$(EXEEXT) rlcat$(EXEEXT) \\\n-\t\trlevent$(EXEEXT) rlversion$(EXEEXT) histexamp$(EXEEXT)\n-OBJECTS = fileman.o rltest.o rl.o rlevent.o rlcat.o rlversion.o histexamp.o\n+\t\trlevent$(EXEEXT) rlversion$(EXEEXT) histexamp$(EXEEXT) \\\n+\t\trl-callbacktest$(EXEEXT) rlbasic$(EXEEXT) \\\n+\t\thist_erasedups$(EXEEXT) hist_purgecmd$(EXEEXT)\n+\n+OBJECTS = fileman.o rltest.o rl.o rlevent.o rlcat.o rlversion.o histexamp.o \\\n+\t  rl-callbacktest.o rlbasic.o hist_erasedups.o hist_purgecmd.o\n+\n+OTHEREXE = rlptytest$(EXEEXT)\n+OTHEROBJ = rlptytest.o\n \n all: $(EXECUTABLES)\n everything: all\n@@ -96,32 +102,44 @@ uninstall:\n \t-rmdir $(DESTDIR)$(installdir)\n \n rl$(EXEEXT): rl.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ rl.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rl.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\n+rlbasic$(EXEEXT): rlbasic.o $(READLINE_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rlbasic.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n rlcat$(EXEEXT): rlcat.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ rlcat.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rlcat.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n rlevent$(EXEEXT): rlevent.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ rlevent.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rlevent.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n fileman$(EXEEXT): fileman.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ fileman.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ fileman.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n rltest$(EXEEXT): rltest.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ rltest.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rltest.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\n+rl-callbacktest$(EXEEXT): rl-callbacktest.o $(READLINE_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rl-callbacktest.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n rlptytest$(EXEEXT): rlptytest.o $(READLINE_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ rlptytest.o $(READLINE_LIB) $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ rlptytest.o $(READLINE_LIB) $(TERMCAP_LIB) $(LIBUTIL)\n \n rlversion$(EXEEXT): rlversion.o $(READLINE_LIB)\n \t$(CC) $(LDFLAGS) -o $@ rlversion.o $(READLINE_LIB) $(TERMCAP_LIB)\n \n histexamp$(EXEEXT): histexamp.o $(HISTORY_LIB)\n-\t$(PURIFY) $(CC) $(LDFLAGS) -o $@ histexamp.o -lhistory $(TERMCAP_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ histexamp.o -lhistory $(TERMCAP_LIB)\n+\n+hist_erasedups$(EXEEXT): hist_erasedups.o $(HISTORY_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ hist_erasedups.o -lhistory $(TERMCAP_LIB)\n+\n+hist_purgecmd$(EXEEXT): hist_purgecmd.o $(HISTORY_LIB)\n+\t$(CC) $(LDFLAGS) -o $@ hist_purgecmd.o -lhistory $(TERMCAP_LIB)\n \n clean mostlyclean:\n-\t$(RM) $(OBJECTS)\n-\t$(RM) $(EXECUTABLES) *.exe\n+\t$(RM) $(OBJECTS) $(OTHEROBJ)\n+\t$(RM) $(EXECUTABLES) $(OTHEREXE) *.exe\n \n distclean maintainer-clean: clean\n \t$(RM) Makefile\n@@ -131,13 +149,21 @@ rltest.o: rltest.c\n rl.o: rl.c\n rlversion.o: rlversion.c\n histexamp.o: histexamp.c\n+hist_erasedups.o: hist_erasedups.c\n+hist_purgecmd.o: hist_purgecmd.c\n+rlbasic.o: rlbasic.c\n rlcat.o: rlcat.c\n rlptytest.o: rlptytest.c\n+rl-callbacktest.o: rl-callbacktest.c\n \n fileman.o: $(top_srcdir)/readline.h\n rltest.o: $(top_srcdir)/readline.h\n rl.o: $(top_srcdir)/readline.h\n rlversion.o: $(top_srcdir)/readline.h\n histexamp.o: $(top_srcdir)/history.h\n+hist_erasedups.o: $(top_srcdir)/history.h\n+hist_purgecmd.o: $(top_srcdir)/history.h\n+rlbasic.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h\n rlcat.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h\n rlptytest.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h\n+rl-callbacktest.o: $(top_srcdir)/readline.h $(top_srcdir)/history.h"
    },
    {
      "sha": "4206acfca4a518c8081d1e5389e2fdcb1b51bb8c",
      "filename": "readline/examples/excallback.c",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/excallback.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/excallback.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/excallback.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -40,13 +40,14 @@ Copyright (C) 1999 Jeff Solomon\n #include <config.h>\n #endif\n \n-#include <stdio.h>\n #include <sys/types.h>\n \n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n+#include <stdlib.h>\n \n+#include <stdio.h>\n #include <termios.h>\t/* xxx - should make this more general */\n \n #ifdef READLINE_LIBRARY\n@@ -55,6 +56,10 @@ Copyright (C) 1999 Jeff Solomon\n #  include <readline/readline.h>\n #endif\n \n+#ifndef STDIN_FILENO\n+#  define STDIN_FILENO 0\n+#endif\n+\n /* This little examples demonstrates the alternate interface to using readline.\n  * In the alternate interface, the user maintains control over program flow and\n  * only calls readline when STDIN is readable. Using the alternate interface,"
    },
    {
      "sha": "c821df033aa8b42702d016bc767f66d4f676d1f8",
      "filename": "readline/examples/fileman.c",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/fileman.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/fileman.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/fileman.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -63,6 +63,12 @@\n \n extern char *xmalloc PARAMS((size_t));\n \n+void initialize_readline PARAMS((void));\n+void too_dangerous PARAMS((char *));\n+\n+int execute_line PARAMS((char *));\n+int valid_argument PARAMS((char *, char *));\n+\n /* The names of functions that actually do the manipulation. */\n int com_list PARAMS((char *));\n int com_view PARAMS((char *));\n@@ -119,6 +125,7 @@ dupstr (s)\n   return (r);\n }\n \n+int\n main (argc, argv)\n      int argc;\n      char **argv;\n@@ -241,6 +248,7 @@ char **fileman_completion PARAMS((const char *, int, int));\n /* Tell the GNU Readline library how to complete.  We want to try to complete\n    on command names if this is the first word in the line, or on filenames\n    if not. */\n+void\n initialize_readline ()\n {\n   /* Allow conditional parsing of the ~/.inputrc file. */\n@@ -317,6 +325,7 @@ command_generator (text, state)\n static char syscom[1024];\n \n /* List the file(s) named in arg. */\n+int\n com_list (arg)\n      char *arg;\n {\n@@ -327,6 +336,7 @@ com_list (arg)\n   return (system (syscom));\n }\n \n+int\n com_view (arg)\n      char *arg;\n {\n@@ -342,13 +352,15 @@ com_view (arg)\n   return (system (syscom));\n }\n \n+int\n com_rename (arg)\n      char *arg;\n {\n   too_dangerous (\"rename\");\n   return (1);\n }\n \n+int\n com_stat (arg)\n      char *arg;\n {\n@@ -377,6 +389,7 @@ com_stat (arg)\n   return (0);\n }\n \n+int\n com_delete (arg)\n      char *arg;\n {\n@@ -386,6 +399,7 @@ com_delete (arg)\n \n /* Print out help for ARG, or for all of the commands if ARG is\n    not present. */\n+int\n com_help (arg)\n      char *arg;\n {\n@@ -425,6 +439,7 @@ com_help (arg)\n }\n \n /* Change to the directory ARG. */\n+int\n com_cd (arg)\n      char *arg;\n {\n@@ -439,6 +454,7 @@ com_cd (arg)\n }\n \n /* Print out the current working directory. */\n+int\n com_pwd (ignore)\n      char *ignore;\n {\n@@ -456,6 +472,7 @@ com_pwd (ignore)\n }\n \n /* The user wishes to quit using this program.  Just set DONE non-zero. */\n+int\n com_quit (arg)\n      char *arg;\n {\n@@ -464,6 +481,7 @@ com_quit (arg)\n }\n \n /* Function which tells you that you can't do this. */\n+void\n too_dangerous (caller)\n      char *caller;\n {"
    },
    {
      "sha": "2ecee899c3b0bb1e7b0c9a3be05fec1aa2529abf",
      "filename": "readline/examples/hist_erasedups.c",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/hist_erasedups.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/hist_erasedups.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/hist_erasedups.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,119 @@\n+/* hist_erasedups -- remove all duplicate entries from history file */\n+\n+/* Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Readline Library (Readline), a library for\n+   reading lines of text with interactive input and history editing.\n+\n+   Readline is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Readline is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with Readline.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+#ifndef READLINE_LIBRARY\n+#define READLINE_LIBRARY 1\n+#endif\n+\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#ifdef READLINE_LIBRARY\n+#  include \"history.h\"\n+#else\n+#  include <readline/history.h>\n+#endif\n+\n+#include <string.h>\n+\n+#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)\n+#define STREQN(a, b, n) ((n == 0) ? (1) \\\n+                                  : ((a)[0] == (b)[0] && strncmp(a, b, n) == 0))\n+\n+static void\n+usage()\n+{\n+  fprintf (stderr, \"hist_erasedups: usage: hist_erasedups [-t] [filename]\\n\");\n+  exit (2);\n+}\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *fn;\n+  int r;\n+\n+  while ((r = getopt (argc, argv, \"t\")) != -1)\n+    {\n+      switch (r)\n+\t{\n+\tcase 't':\n+\t  history_write_timestamps = 1;\n+\t  break;\n+\tdefault:\n+\t  usage ();\n+\t}\n+    }\n+  argv += optind;\n+  argc -= optind;\n+\n+  fn = argc ? argv[0] : getenv (\"HISTFILE\");\n+  if (fn == 0)\n+    {\n+      fprintf (stderr, \"hist_erasedups: no history file\\n\");\n+      usage ();\n+    }\n+\n+  if ((r = read_history (fn)) != 0)\n+    {\n+      fprintf (stderr, \"hist_erasedups: read_history: %s: %s\\n\", fn, strerror (r));\n+      exit (1);\n+    }\n+\n+  hist_erasedups ();\n+\n+  if ((r = write_history (fn)) != 0)\n+    {\n+      fprintf (stderr, \"hist_erasedups: write_history: %s: %s\\n\", fn, strerror (r));\n+      exit (1);\n+    }\n+\n+  exit (0);\n+}\n+\n+int\n+hist_erasedups ()\n+{\n+  int r, n;\n+  HIST_ENTRY *h, *temp;\n+\n+  using_history ();\n+  while (h = previous_history ())\n+    {\n+      r = where_history ();\n+      for (n = 0; n < r; n++)\n+\t{\n+\t  temp = history_get (n+history_base);\n+\t  if (STREQ (h->line, temp->line))\n+\t    {\n+\t      remove_history (n);\n+\t      r--;\t\t\t/* have to get one fewer now */\n+\t      n--;\t\t\t/* compensate for above increment */\n+\t      history_offset--;\t\t/* moving backwards in history list */\n+\t    }\n+\t}\n+    }\n+  using_history ();\n+\n+  return r;\n+}"
    },
    {
      "sha": "d836d146ebd58aecd106485e901cf82bf03f8e31",
      "filename": "readline/examples/hist_purgecmd.c",
      "status": "added",
      "additions": 149,
      "deletions": 0,
      "changes": 149,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/hist_purgecmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/hist_purgecmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/hist_purgecmd.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,149 @@\n+/* hist_purgecmd -- remove all instances of command or pattern from history\n+   file */\n+\n+/* Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU Readline Library (Readline), a library for\n+   reading lines of text with interactive input and history editing.\n+\n+   Readline is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Readline is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with Readline.  If not, see <http://www.gnu.org/licenses/>.\n+*/\n+#ifndef READLINE_LIBRARY\n+#define READLINE_LIBRARY 1\n+#endif\n+\n+#include <unistd.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+#include <regex.h>\n+\n+#ifdef READLINE_LIBRARY\n+#  include \"history.h\"\n+#else\n+#  include <readline/history.h>\n+#endif\n+\n+#include <string.h>\n+\n+#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp(a, b) == 0)\n+#define STREQN(a, b, n) ((n == 0) ? (1) \\\n+                                  : ((a)[0] == (b)[0] && strncmp(a, b, n) == 0))\n+\n+#define PURGE_REGEXP\t0x01\n+\n+static void\n+usage()\n+{\n+  fprintf (stderr, \"hist_purgecmd: usage: hist_purgecmd [-r] [-t] [-f filename] command-spec\\n\");\n+  exit (2);\n+}\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char **argv;\n+{\n+  char *fn;\n+  int r, flags;\n+\n+  flags = 0;\n+  fn = 0;\n+  while ((r = getopt (argc, argv, \"f:rt\")) != -1)\n+    {\n+      switch (r)\n+\t{\n+\tcase 'f':\n+\t  fn = optarg;\n+\t  break;\n+\tcase 'r':\n+\t  flags |= PURGE_REGEXP;\n+\t  break;\n+\tcase 't':\n+\t  history_write_timestamps = 1;\n+\t  break;\n+\tdefault:\n+\t  usage ();\n+\t}\n+    }\n+  argv += optind;\n+  argc -= optind;\n+\n+  if (fn == 0)\n+    fn = getenv (\"HISTFILE\");\n+  if (fn == 0)\n+    {\n+      fprintf (stderr, \"hist_purgecmd: no history file\\n\");\n+      usage ();\n+    }\n+\n+  if ((r = read_history (fn)) != 0)\n+    {\n+      fprintf (stderr, \"hist_purgecmd: read_history: %s: %s\\n\", fn, strerror (r));\n+      exit (1);\n+    }\n+\n+  for (r = 0; r < argc; r++)\n+    hist_purgecmd (argv[r], flags);\n+\n+  if ((r = write_history (fn)) != 0)\n+    {\n+      fprintf (stderr, \"hist_purgecmd: write_history: %s: %s\\n\", fn, strerror (r));\n+      exit (1);\n+    }\n+\n+  exit (0);\n+}\n+\n+int\n+hist_purgecmd (cmd, flags)\n+     char *cmd;\n+     int flags;\n+{\n+  int r, n, rflags;\n+  HIST_ENTRY *temp;\n+  regex_t regex = { 0 };\n+\n+  if (flags & PURGE_REGEXP)\n+    {\n+      rflags = REG_EXTENDED|REG_NOSUB;\n+      if (regcomp (&regex, cmd, rflags))\n+\t{\n+\t  fprintf (stderr, \"hist_purgecmd: %s: invalid regular expression\\n\", cmd);\n+\t  return -1;\n+\t}\n+    }\n+\n+  r = 0;\n+  using_history ();\n+  r = where_history ();\n+  for (n = 0; n < r; n++)\n+    {\n+      temp = history_get (n+history_base);\n+      if (((flags & PURGE_REGEXP) && (regexec (&regex, temp->line, 0, 0, 0) == 0)) ||\n+\t  ((flags & PURGE_REGEXP) == 0 && STREQ (temp->line, cmd)))\n+\t{\n+\t  remove_history (n);\n+\t  r--;\t\t\t/* have to get one fewer now */\n+\t  n--;\t\t\t/* compensate for above increment */\n+\t  history_offset--;\t/* moving backwards in history list */\n+\t}\n+    }\n+  using_history ();\n+\n+  if (flags & PURGE_REGEXP)\n+    regfree (&regex);\n+\n+  return r;\n+}"
    },
    {
      "sha": "c8f3a7b41e2d888cd190bc310272d867e1eab633",
      "filename": "readline/examples/readlinebuf.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/readlinebuf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/readlinebuf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/readlinebuf.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n /*******************************************************************************\n- * $Revision$\n- * $Date$\n- * $Author$\n+ * $Revision: 1.2 $\n+ * $Date: 2001/09/11 06:19:36 $\n+ * $Author: vyzo $\n  *\n  * Contents: A streambuf which uses the GNU readline library for line I/O\n  * (c) 2001 by Dimitris Vyzovitis [vyzo@media.mit.edu]"
    },
    {
      "sha": "3525ffd99935c4d3e841a1a69ca703adede08451",
      "filename": "readline/examples/rl-callbacktest.c",
      "status": "added",
      "additions": 115,
      "deletions": 0,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rl-callbacktest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rl-callbacktest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rl-callbacktest.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,115 @@\n+/* Standard include files. stdio.h is required. */\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <string.h>\n+#include <locale.h>\n+\n+/* Used for select(2) */\n+#include <sys/types.h>\n+#include <sys/select.h>\n+\n+#include <signal.h>\n+\n+#include <errno.h>\n+#include <stdio.h>\n+\n+/* Standard readline include files. */\n+#if defined (READLINE_LIBRARY)\n+#  include \"readline.h\"\n+#  include \"history.h\"\n+#else\n+#  include <readline/readline.h>\n+#  include <readline/history.h>\n+#endif\n+\n+extern int errno;\n+\n+static void cb_linehandler (char *);\n+static void signandler (int);\n+\n+int running, sigwinch_received;\n+const char *prompt = \"rltest$ \";\n+\n+/* Handle SIGWINCH and window size changes when readline is not active and\n+   reading a character. */\n+static void\n+sighandler (int sig)\n+{\n+  sigwinch_received = 1;\n+}\n+\n+/* Callback function called for each line when accept-line executed, EOF\n+   seen, or EOF character read.  This sets a flag and returns; it could\n+   also call exit(3). */\n+static void\n+cb_linehandler (char *line)\n+{\n+  /* Can use ^D (stty eof) or `exit' to exit. */\n+  if (line == NULL || strcmp (line, \"exit\") == 0)\n+    {\n+      if (line == 0)\n+        printf (\"\\n\");\n+      printf (\"exit\\n\");\n+      /* This function needs to be called to reset the terminal settings,\n+\t and calling it from the line handler keeps one extra prompt from\n+\t being displayed. */\n+      rl_callback_handler_remove ();\n+\n+      running = 0;\n+    }\n+  else\n+    {\n+      if (*line)\n+\tadd_history (line);\n+      printf (\"input line: %s\\n\", line);\n+      free (line);\n+    }\n+}\n+\n+int\n+main (int c, char **v)\n+{\n+  fd_set fds;\n+  int r;\n+\n+\n+  setlocale (LC_ALL, \"\");\n+\n+  /* Handle SIGWINCH */\n+  signal (SIGWINCH, sighandler);\n+  \n+  /* Install the line handler. */\n+  rl_callback_handler_install (prompt, cb_linehandler);\n+\n+  /* Enter a simple event loop.  This waits until something is available\n+     to read on readline's input stream (defaults to standard input) and\n+     calls the builtin character read callback to read it.  It does not\n+     have to modify the user's terminal settings. */\n+  running = 1;\n+  while (running)\n+    {\n+      FD_ZERO (&fds);\n+      FD_SET (fileno (rl_instream), &fds);    \n+\n+      r = select (FD_SETSIZE, &fds, NULL, NULL, NULL);\n+      if (r < 0 && errno != EINTR)\n+\t{\n+\t  perror (\"rltest: select\");\n+\t  rl_callback_handler_remove ();\n+\t  break;\n+\t}\n+      if (sigwinch_received)\n+\t{\n+\t  rl_resize_terminal ();\n+\t  sigwinch_received = 0;\n+\t}\n+      if (r < 0)\n+\tcontinue;\n+\n+      if (FD_ISSET (fileno (rl_instream), &fds))\n+\trl_callback_read_char ();\n+    }\n+\n+  printf (\"rltest: Event loop has exited\\n\");\n+  return 0;\n+}"
    },
    {
      "sha": "a5cf276cb943afcf88a12691c2d7c160dcb11262",
      "filename": "readline/examples/rl.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rl.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -28,6 +28,7 @@\n #  include <config.h>\n #endif\n \n+#include <unistd.h>\n #include <stdio.h>\n #include <sys/types.h>\n "
    },
    {
      "sha": "6a9601f52a699caa033273abf85e9689406ad07a",
      "filename": "readline/examples/rlbasic.c",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlbasic.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlbasic.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlbasic.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,29 @@\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#if defined (READLINE_LIBRARY)\n+#  include \"readline.h\"\n+#  include \"history.h\"\n+#else\n+#  include <readline/readline.h>\n+#  include <readline/history.h>\n+#endif\n+\n+int\n+main (int c, char **v)\n+{\n+\tchar *input;\n+\n+\tfor (;;) {\n+\t\tinput = readline ((char *)NULL);\n+\t\tif (input == 0)\n+\t\t\tbreak;\n+\t\tprintf (\"%s\\n\", input);\n+\t\tif (strcmp (input, \"exit\") == 0)\n+\t\t\tbreak;\n+\t\tfree (input);\n+\t}\n+\texit (0);\n+}"
    },
    {
      "sha": "a843fecc4ac824b8f67483fbbf0e8b2b834b7a09",
      "filename": "readline/examples/rlfe/config.h.in",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/config.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/config.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/config.h.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -21,7 +21,7 @@\n  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n  *\n  ****************************************************************\n- * $Id$ FAU\n+ * $Id: config.h.in,v 1.12 1994/05/31 12:31:36 mlschroe Exp $ FAU\n  */\n \n \n@@ -377,3 +377,7 @@\n #undef HAVE_SYS_STROPTS_H\n \n #undef HAVE_SYS_WAIT_H\n+\n+#undef HAVE_SGTTY_H\n+\n+#undef HAVE_SYS_SELECT_H"
    },
    {
      "sha": "b6d9b5be46c324a7bbda12666e6920d123653299",
      "filename": "readline/examples/rlfe/configure",
      "status": "modified",
      "additions": 14,
      "deletions": 1,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/configure?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -3705,6 +3705,7 @@ else\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n \n+extern char *tgoto();\n main()\n {\n  exit(strcmp(tgoto(\"%p1%d\", 0, 1), \"1\") ? 0 : 1);\n@@ -4341,7 +4342,7 @@ fi\n done\n \n \n-for ac_header in sys/stropts.h sys/wait.h\n+for ac_header in sys/stropts.h sys/wait.h sgtty.h sys/select.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\"\n@@ -4354,6 +4355,18 @@ fi\n \n done\n \n+for ac_header in term.h\n+do :\n+  ac_fn_c_check_header_mongrel \"$LINENO\" \"term.h\" \"ac_cv_header_term_h\" \"$ac_includes_default\"\n+if test \"x$ac_cv_header_term_h\" = xyes; then :\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_TERM_H 1\n+_ACEOF\n+\n+fi\n+\n+done\n+\n \n ac_config_files=\"$ac_config_files Makefile\"\n "
    },
    {
      "sha": "5c0678ab4d8fe376ba493b8dad075c125ee8ce1f",
      "filename": "readline/examples/rlfe/configure.in",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/configure.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/configure.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/configure.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -225,6 +225,7 @@ AC_TRY_LINK(,tgetent((char *)0, (char *)0);,,\n AC_MSG_ERROR(!!! no tgetent - no screen))))))\n \n AC_TRY_RUN([\n+extern char *tgoto();\n main()\n {\n  exit(strcmp(tgoto(\"%p1%d\", 0, 1), \"1\") ? 0 : 1);\n@@ -437,6 +438,7 @@ main()\n \n fi\n \n-AC_CHECK_HEADERS(sys/stropts.h sys/wait.h)\n+AC_CHECK_HEADERS(sys/stropts.h sys/wait.h sgtty.h sys/select.h)\n+AC_CHECK_HEADERS(term.h)\n \n AC_OUTPUT(Makefile)"
    },
    {
      "sha": "2fe50250cc4c1a93838d44f7f7c94f0ec7586cfe",
      "filename": "readline/examples/rlfe/extern.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/extern.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/extern.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/extern.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -19,7 +19,7 @@\n  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n  *\n  ****************************************************************\n- * $Id$ FAU\n+ * $Id: extern.h,v 1.18 1994/05/31 12:31:57 mlschroe Exp $ FAU\n  */\n \n #if !defined(__GNUC__) || __GNUC__ < 2"
    },
    {
      "sha": "df06c758099209b836c438595ccf94a52f66845c",
      "filename": "readline/examples/rlfe/os.h",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/os.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/os.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/os.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -19,7 +19,7 @@\n  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\n  *\n  ****************************************************************\n- * $Id$ FAU\n+ * $Id: os.h,v 1.10 1994/05/31 12:32:22 mlschroe Exp $ FAU\n  */\n \n #include <stdio.h>\n@@ -208,7 +208,9 @@ extern int errno;\n #   include <cytermio.h>\n #  endif\n # else /* TERMIO */\n-#  include <sgtty.h>\n+#  if defined (HAVE_SGTTY_H)\n+#    include <sgtty.h>\n+#  endif\n # endif /* TERMIO */\n #endif /* POSIX */\n \n@@ -490,7 +492,7 @@ extern int errno;\n  *    select stuff\n  */\n \n-#if defined(M_XENIX) || defined(M_UNIX) || defined(_SEQUENT_)\n+#if defined(M_XENIX) || defined(M_UNIX) || defined(_SEQUENT_) || defined (__INTERIX)\n #include <sys/select.h>\t\t/* for timeval + FD... */\n #endif\n "
    },
    {
      "sha": "f40b2ddaf00fcd060a2d8b1b895d759481bc92ea",
      "filename": "readline/examples/rlfe/rlfe.c",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/rlfe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlfe/rlfe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlfe/rlfe.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -547,7 +547,14 @@ main(int argc, char** argv)\n #endif\n \n   t.c_lflag &= ~(ICANON | ISIG | ECHO | ECHOCTL | ECHOE | \\\n-\t\t ECHOK | ECHOKE | ECHONL | ECHOPRT );\n+\t\t ECHOK | ECHONL\n+#if defined (ECHOKE)\n+\t\t| ECHOKE\n+#endif\n+#if defined (ECHOPRT)\n+\t\t| ECHOPRT\n+#endif\n+\t\t);\n   t.c_iflag &= ~ICRNL;\n   t.c_iflag |= IGNBRK;\n   t.c_cc[VMIN] = 1;"
    },
    {
      "sha": "9c42f8a2795385dc0ae49eb339264a72f77f8ead",
      "filename": "readline/examples/rlptytest.c",
      "status": "modified",
      "additions": 11,
      "deletions": 3,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlptytest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlptytest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlptytest.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -19,7 +19,7 @@\n \n #include <signal.h>\n \n-#if 0\t/* LINUX */\n+#if 1\t/* LINUX */\n #include <pty.h>\n #else\n #include <util.h>\n@@ -48,6 +48,13 @@ sigint (s)\n   exit (0);\n }\n \n+void\n+sigwinch (s)\n+     int s;\n+{\n+  rl_resize_terminal ();\n+}\n+\n static int \n user_input()\n {\n@@ -316,6 +323,9 @@ main()\n   if (val == -1)\n     return -1;\n \n+  signal (SIGWINCH, sigwinch);\n+  signal (SIGINT, sigint);\n+\n   val = init_readline (slavefd, slavefd);\n   if (val == -1)\n     return -1;\n@@ -324,8 +334,6 @@ main()\n   if (val == -1)\n     return -1;\n \n-  signal (SIGINT, sigint);\n-\n   val = main_loop ();\n \n   tty_reset (STDIN_FILENO);"
    },
    {
      "sha": "f36567becf463b1c587fce0b327569493fa083f9",
      "filename": "readline/examples/rlversion.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlversion.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/examples/rlversion.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/examples/rlversion.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -41,6 +41,7 @@ extern void exit();\n #  include <readline/readline.h>\n #endif\n \n+int\n main()\n {\n \tprintf (\"%s\\n\", rl_library_version ? rl_library_version : \"unknown\");"
    },
    {
      "sha": "34b1d6ba79fb827a0c2d20c475f764523ec15068",
      "filename": "readline/funmap.c",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/funmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/funmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/funmap.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* funmap.c -- attach names to functions. */\n \n-/* Copyright (C) 1987-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -68,6 +68,7 @@ static const FUNMAP default_funmap[] = {\n   { \"backward-word\", rl_backward_word },\n   { \"beginning-of-history\", rl_beginning_of_history },\n   { \"beginning-of-line\", rl_beg_of_line },\n+  { \"bracketed-paste-begin\", rl_bracketed_paste_begin },\n   { \"call-last-kbd-macro\", rl_call_last_kbd_macro },\n   { \"capitalize-word\", rl_capitalize_word },\n   { \"character-search\", rl_char_search },\n@@ -98,6 +99,8 @@ static const FUNMAP default_funmap[] = {\n   { \"forward-word\", rl_forward_word },\n   { \"history-search-backward\", rl_history_search_backward },\n   { \"history-search-forward\", rl_history_search_forward },\n+  { \"history-substring-search-backward\", rl_history_substr_search_backward },\n+  { \"history-substring-search-forward\", rl_history_substr_search_forward },\n   { \"insert-comment\", rl_insert_comment },\n   { \"insert-completions\", rl_insert_completions },\n   { \"kill-whole-line\", rl_kill_full_line },\n@@ -113,11 +116,12 @@ static const FUNMAP default_funmap[] = {\n   { \"non-incremental-reverse-search-history-again\", rl_noninc_reverse_search_again },\n   { \"old-menu-complete\", rl_old_menu_complete },\n   { \"overwrite-mode\", rl_overwrite_mode },\n-#ifdef _WIN32\n+#if defined (_WIN32)\n   { \"paste-from-clipboard\", rl_paste_from_clipboard },\n #endif\n   { \"possible-completions\", rl_possible_completions },\n   { \"previous-history\", rl_get_previous_history },\n+  { \"print-last-kbd-macro\", rl_print_last_kbd_macro },\n   { \"quoted-insert\", rl_quoted_insert },\n   { \"re-read-init-file\", rl_re_read_init_file },\n   { \"redraw-current-line\", rl_refresh_line},\n@@ -174,7 +178,7 @@ static const FUNMAP default_funmap[] = {\n   { \"vi-fword\", rl_vi_fword },\n   { \"vi-goto-mark\", rl_vi_goto_mark },\n   { \"vi-insert-beg\", rl_vi_insert_beg },\n-  { \"vi-insertion-mode\", rl_vi_insertion_mode },\n+  { \"vi-insertion-mode\", rl_vi_insert_mode },\n   { \"vi-match\", rl_vi_match },\n   { \"vi-movement-mode\", rl_vi_movement_mode },\n   { \"vi-next-word\", rl_vi_next_word },\n@@ -190,7 +194,9 @@ static const FUNMAP default_funmap[] = {\n   { \"vi-set-mark\", rl_vi_set_mark },\n   { \"vi-subst\", rl_vi_subst },\n   { \"vi-tilde-expand\", rl_vi_tilde_expand },\n+  { \"vi-unix-word-rubout\", rl_vi_unix_word_rubout },\n   { \"vi-yank-arg\", rl_vi_yank_arg },\n+  { \"vi-yank-pop\", rl_vi_yank_pop },\n   { \"vi-yank-to\", rl_vi_yank_to },\n #endif /* VI_MODE */\n \n@@ -236,7 +242,7 @@ rl_initialize_funmap ()\n \n /* Produce a NULL terminated array of known function names.  The array\n    is sorted.  The array itself is allocated, but not the strings inside.\n-   You should free () the array when you done, but not the pointrs. */\n+   You should free () the array when you done, but not the pointers. */\n const char **\n rl_funmap_names ()\n {"
    },
    {
      "sha": "b84a6b8ac4b21e3c139a3e5eb66276e8b9f753bf",
      "filename": "readline/histexpand.c",
      "status": "modified",
      "additions": 73,
      "deletions": 43,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histexpand.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histexpand.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histexpand.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* histexpand.c -- history expansion. */\n \n-/* Copyright (C) 1989-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2015 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -44,12 +44,14 @@\n \n #include \"history.h\"\n #include \"histlib.h\"\n+#include \"chardefs.h\"\n \n #include \"rlshell.h\"\n #include \"xmalloc.h\"\n \n #define HISTORY_WORD_DELIMITERS\t\t\" \\t\\n;&()|<>\"\n #define HISTORY_QUOTE_CHARACTERS\t\"\\\"'`\"\n+#define HISTORY_EVENT_DELIMITERS\t\"^$*%-\"\n \n #define slashify_in_quotes \"\\\\`\\\"$\"\n \n@@ -62,6 +64,10 @@ static char *subst_rhs;\n static int subst_lhs_len;\n static int subst_rhs_len;\n \n+/* Characters that delimit history event specifications and separate event\n+   specifications from word designators.  Static for now */\n+static char *history_event_delimiter_chars = HISTORY_EVENT_DELIMITERS;\n+\n static char *get_history_word_specifier PARAMS((char *, char *, int *));\n static int history_tokenize_word PARAMS((const char *, int));\n static char **history_tokenize_internal PARAMS((const char *, int, int *));\n@@ -112,7 +118,6 @@ rl_linebuf_func_t *history_inhibit_expansion_function;\n \n /* The last string searched for by a !?string? search. */\n static char *search_string;\n-\n /* The last string matched by a !?string? search. */\n static char *search_match;\n \n@@ -225,6 +230,7 @@ get_history_event (string, caller_index, delimiting_quote)\n \n #endif /* HANDLE_MULTIBYTE */\n       if ((!substring_okay && (whitespace (c) || c == ':' ||\n+          (history_event_delimiter_chars && member (c, history_event_delimiter_chars)) ||\n \t  (history_search_delimiter_chars && member (c, history_search_delimiter_chars)) ||\n \t  string[i] == delimiting_quote)) ||\n \t  string[i] == '\\n' ||\n@@ -272,6 +278,8 @@ get_history_event (string, caller_index, delimiting_quote)\n       if (local_index == 0 || substring_okay)\n \t{\n \t  entry = current_history ();\n+\t  if (entry == 0)\n+\t    FAIL_SEARCH ();\n \t  history_offset = history_length;\n \t\n \t  /* If this was a substring search, then remember the\n@@ -519,9 +527,9 @@ postproc_subst_rhs ()\n    the returned string.  Returns the new index into string in\n    *END_INDEX_PTR, and the expanded specifier in *RET_STRING. */\n static int\n-history_expand_internal (string, start, end_index_ptr, ret_string, current_line)\n+history_expand_internal (string, start, qc, end_index_ptr, ret_string, current_line)\n      char *string;\n-     int start, *end_index_ptr;\n+     int start, qc, *end_index_ptr;\n      char **ret_string;\n      char *current_line;\t/* for !# */\n {\n@@ -557,30 +565,7 @@ history_expand_internal (string, start, end_index_ptr, ret_string, current_line)\n       event = current_line;\n     }\n   else\n-    {\n-      int quoted_search_delimiter = 0;\n-\n-      /* If the character before this `!' is a double or single\n-\t quote, then this expansion takes place inside of the\n-\t quoted string.  If we have to search for some text (\"!foo\"),\n-\t allow the delimiter to end the search string. */\n-#if defined (HANDLE_MULTIBYTE)\n-      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n-\t{\n-\t  int ch, l;\n-\t  l = _rl_find_prev_mbchar (string, i, MB_FIND_ANY);\n-\t  ch = string[l];\n-\t  /* XXX - original patch had i - 1 ???  If i == 0 it would fail. */\n-\t  if (i && (ch == '\\'' || ch == '\"'))\n-\t    quoted_search_delimiter = ch;\n-\t}\n-      else\n-#endif /* HANDLE_MULTIBYTE */\t  \n-\tif (i && (string[i - 1] == '\\'' || string[i - 1] == '\"'))\n-\t  quoted_search_delimiter = string[i - 1];\n-\n-      event = get_history_event (string, &i, quoted_search_delimiter);\n-    }\n+    event = get_history_event (string, &i, qc);\n \t  \n   if (event == 0)\n     {\n@@ -854,7 +839,7 @@ history_expand_internal (string, start, end_index_ptr, ret_string, current_line)\n \t}\n       i += 2;\n     }\n-  /* Done with modfiers. */\n+  /* Done with modifiers. */\n   /* Believe it or not, we have to back the pointer up by one. */\n   --i;\n \n@@ -894,7 +879,7 @@ history_expand_internal (string, start, end_index_ptr, ret_string, current_line)\n    1) If expansions did take place\n    2) If the `p' modifier was given and the caller should print the result\n \n-  If an error ocurred in expansion, then OUTPUT contains a descriptive\n+  If an error occurred in expansion, then OUTPUT contains a descriptive\n   error message. */\n \n #define ADD_STRING(s) \\\n@@ -928,7 +913,7 @@ history_expand (hstring, output)\n      char **output;\n {\n   register int j;\n-  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, flag;\n+  int i, r, l, passc, cc, modified, eindex, only_printing, dquote, squote, flag;\n   char *string;\n \n   /* The output string, and its length. */\n@@ -991,7 +976,7 @@ history_expand (hstring, output)\n \n       /* `!' followed by one of the characters in history_no_expand_chars\n \t is NOT an expansion. */\n-      for (i = dquote = 0; string[i]; i++)\n+      for (i = dquote = squote = 0; string[i]; i++)\n \t{\n #if defined (HANDLE_MULTIBYTE)\n \t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n@@ -1012,6 +997,7 @@ history_expand (hstring, output)\n \t     history expansion performed on it.\n \t     Skip the rest of the line and break out of the loop. */\n \t  if (history_comment_char && string[i] == history_comment_char &&\n+\t      dquote == 0 &&\n \t      (i == 0 || member (string[i - 1], history_word_delimiters)))\n \t    {\n \t      while (string[i])\n@@ -1022,6 +1008,13 @@ history_expand (hstring, output)\n \t    {\n \t      if (cc == 0 || member (cc, history_no_expand_chars))\n \t\tcontinue;\n+\t      /* DQUOTE won't be set unless history_quotes_inhibit_expansion\n+\t\t is set.  The idea here is to treat double-quoted strings the\n+\t\t same as the word outside double quotes; in effect making the\n+\t\t double quote part of history_no_expand_chars when DQUOTE is\n+\t\t set. */\n+\t      else if (dquote && cc == '\"')\n+\t\tcontinue;\n \t      /* If the calling application has set\n \t\t history_inhibit_expansion_function to a function that checks\n \t\t for special cases that should not be history expanded,\n@@ -1071,9 +1064,9 @@ history_expand (hstring, output)\n     }\n \n   /* Extract and perform the substitution. */\n-  for (passc = dquote = i = j = 0; i < l; i++)\n+  for (passc = dquote = squote = i = j = 0; i < l; i++)\n     {\n-      int tchar = string[i];\n+      int qc, tchar = string[i];\n \n       if (passc)\n \t{\n@@ -1130,8 +1123,14 @@ history_expand (hstring, output)\n \tcase '\\'':\n \t  {\n \t    /* If history_quotes_inhibit_expansion is set, single quotes\n-\t       inhibit history expansion. */\n-\t    if (dquote == 0 && history_quotes_inhibit_expansion)\n+\t       inhibit history expansion, otherwise they are treated like\n+\t       double quotes. */\n+\t    if (squote)\n+\t      {\n+\t        squote = 0;\n+\t        ADD_CHAR (tchar);\n+\t      }\n+\t    else if (dquote == 0 && history_quotes_inhibit_expansion)\n \t      {\n \t\tint quote, slen;\n \n@@ -1146,13 +1145,19 @@ history_expand (hstring, output)\n \t\tADD_STRING (temp);\n \t\txfree (temp);\n \t      }\n+\t    else if (dquote == 0 && squote == 0 && history_quotes_inhibit_expansion == 0)\n+\t      {\n+\t        squote = 1;\n+\t        ADD_CHAR (string[i]);\n+\t      }\n \t    else\n \t      ADD_CHAR (string[i]);\n \t    break;\n \t  }\n \n \tcase -2:\t\t/* history_comment_char */\n-\t  if (i == 0 || member (string[i - 1], history_word_delimiters))\n+\t  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&\n+\t      (i == 0 || member (string[i - 1], history_word_delimiters)))\n \t    {\n \t      temp = (char *)xmalloc (l - i + 1);\n \t      strcpy (temp, string + i);\n@@ -1171,6 +1176,7 @@ history_expand (hstring, output)\n \t     characters in history_no_expand_chars, then it is not a\n \t     candidate for expansion of any kind. */\n \t  if (cc == 0 || member (cc, history_no_expand_chars) ||\n+\t\t\t (dquote && cc == '\"') ||\n \t  \t\t (history_inhibit_expansion_function && (*history_inhibit_expansion_function) (string, i)))\n \t    {\n \t      ADD_CHAR (string[i]);\n@@ -1196,8 +1202,8 @@ history_expand (hstring, output)\n \t      break;\n \t    }\n #endif\n-\n-\t  r = history_expand_internal (string, i, &eindex, &temp, result);\n+\t  qc = squote ? '\\'' : (dquote ? '\"' : 0);\n+\t  r = history_expand_internal (string, i, qc, &eindex, &temp, result);\n \t  if (r < 0)\n \t    {\n \t      *output = temp;\n@@ -1215,7 +1221,7 @@ history_expand (hstring, output)\n \t\t    ADD_STRING (temp);\n \t\t  xfree (temp);\n \t\t}\n-\t      only_printing = r == 1;\n+\t      only_printing += r == 1;\n \t      i = eindex;\n \t    }\n \t  break;\n@@ -1416,7 +1422,7 @@ history_tokenize_word (string, ind)\n      const char *string;\n      int ind;\n {\n-  register int i;\n+  register int i, j;\n   int delimiter, nestdelim, delimopen;\n \n   i = ind;\n@@ -1428,6 +1434,22 @@ history_tokenize_word (string, ind)\n       return i;\n     }\n \n+  if (ISDIGIT (string[i]))\n+    {\n+      j = i;\n+      while (string[j] && ISDIGIT (string[j]))\n+\tj++;\n+      if (string[j] == 0)\n+\treturn (j);\n+      if (string[j] == '<' || string[j] == '>')\n+\ti = j;\t\t\t/* digit sequence is a file descriptor */\n+      else\n+\t{\n+\t  i = j;\n+\t  goto get_word;\t/* digit sequence is part of a word */\n+\t}\n+    }\n+\n   if (member (string[i], \"<>;&|$\"))\n     {\n       int peek = string[i + 1];\n@@ -1441,8 +1463,16 @@ history_tokenize_word (string, ind)\n \t  i += 2;\n \t  return i;\n \t}\n-      else if ((peek == '&' && (string[i] == '>' || string[i] == '<')) ||\n-\t\t(peek == '>' && string[i] == '&'))\n+      else if (peek == '&' && (string[i] == '>' || string[i] == '<'))\n+\t{\n+\t  j = i + 2;\n+\t  while (string[j] && ISDIGIT (string[j]))\t/* file descriptor */\n+\t    j++;\n+\t  if (string[j] =='-')\t\t/* <&[digits]-, >&[digits]- */\n+\t    j++;\n+\t  return j;\n+\t}\n+      else if ((peek == '>' && string[i] == '&') || (peek == '|' && string[i] == '>'))\n \t{\n \t  i += 2;\n \t  return i;"
    },
    {
      "sha": "5b057cdef4ea6b51a75e3eb1a00607712d6d6c71",
      "filename": "readline/histfile.c",
      "status": "modified",
      "additions": 268,
      "deletions": 38,
      "changes": 306,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histfile.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* histfile.c - functions to manipulate the history file. */\n \n-/* Copyright (C) 1989-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2016 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -35,6 +35,10 @@\n \n #include <stdio.h>\n \n+#if defined (HAVE_LIMITS_H)\n+#  include <limits.h>\n+#endif\n+\n #include <sys/types.h>\n #if ! defined (_MINIX) && defined (HAVE_SYS_FILE_H)\n #  include <sys/file.h>\n@@ -99,12 +103,41 @@ extern int errno;\n #include \"rlshell.h\"\n #include \"xmalloc.h\"\n \n+#if !defined (PATH_MAX)\n+#  define PATH_MAX\t1024\t/* default */\n+#endif\n+\n+extern void _hs_append_history_line PARAMS((int, const char *));\n+\n+/* history file version; currently unused */\n+int history_file_version = 1;\n+\n /* If non-zero, we write timestamps to the history file in history_do_write() */\n int history_write_timestamps = 0;\n \n+/* If non-zero, we assume that a history file that starts with a timestamp\n+   uses timestamp-delimited entries and can include multi-line history\n+   entries. Used by read_history_range */\n+int history_multiline_entries = 0;\n+\n+/* Immediately after a call to read_history() or read_history_range(), this\n+   will return the number of lines just read from the history file in that\n+   call. */\n+int history_lines_read_from_file = 0;\n+\n+/* Immediately after a call to write_history() or history_do_write(), this\n+   will return the number of lines just written to the history file in that\n+   call.  This also works with history_truncate_file. */\n+int history_lines_written_to_file = 0;\n+\n /* Does S look like the beginning of a history timestamp entry?  Placeholder\n    for more extensive tests. */\n-#define HIST_TIMESTAMP_START(s)\t\t(*(s) == history_comment_char && isdigit ((s)[1]) )\n+#define HIST_TIMESTAMP_START(s)\t\t(*(s) == history_comment_char && isdigit ((unsigned char)(s)[1]) )\n+\n+static char *history_backupfile PARAMS((const char *));\n+static char *history_tempfile PARAMS((const char *));\n+static int histfile_backup PARAMS((const char *, const char *));\n+static int histfile_restore PARAMS((const char *, const char *));\n \n /* Return the string that should be used in the place of this\n    filename.  This only matters when you don't specify the\n@@ -123,20 +156,13 @@ history_filename (filename)\n     return (return_val);\n   \n   home = sh_get_env_value (\"HOME\");\n-#ifdef _WIN32\n-  if (!home)\n+#if defined (_WIN32)\n+  if (home == 0)\n     home = sh_get_env_value (\"APPDATA\");\n #endif\n \n   if (home == 0)\n-    {\n-#if 0\n-      home = \".\";\n-      home_len = 1;\n-#else\n-      return (NULL);\n-#endif\n-    }\n+    return (NULL);\n   else\n     home_len = strlen (home);\n \n@@ -152,6 +178,75 @@ history_filename (filename)\n   return (return_val);\n }\n \n+static char *\n+history_backupfile (filename)\n+     const char *filename;\n+{\n+  const char *fn;\n+  char *ret, linkbuf[PATH_MAX+1];\n+  size_t len;\n+  ssize_t n;\n+  struct stat fs;\n+\n+  fn = filename;  \n+#if defined (HAVE_READLINK)\n+  /* Follow symlink to avoid backing up symlink itself; call will fail if\n+     not a symlink */\n+  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n+    {\n+      linkbuf[n] = '\\0';\n+      fn = linkbuf;\n+    }\n+#endif\n+      \n+  len = strlen (fn);\n+  ret = xmalloc (len + 2);\n+  strcpy (ret, fn);\n+  ret[len] = '-';\n+  ret[len+1] = '\\0';\n+  return ret;\n+}\n+  \n+static char *\n+history_tempfile (filename)\n+     const char *filename;\n+{\n+  const char *fn;\n+  char *ret, linkbuf[PATH_MAX+1];\n+  size_t len;\n+  ssize_t n;\n+  struct stat fs;\n+  int pid;\n+\n+  fn = filename;  \n+#if defined (HAVE_READLINK)\n+  /* Follow symlink so tempfile created in the same directory as any symlinked\n+     history file; call will fail if not a symlink */\n+  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n+    {\n+      linkbuf[n] = '\\0';\n+      fn = linkbuf;\n+    }\n+#endif\n+      \n+  len = strlen (fn);\n+  ret = xmalloc (len + 11);\n+  strcpy (ret, fn);\n+\n+  pid = (int)getpid ();\n+\n+  /* filename-PID.tmp */\n+  ret[len] = '-';\n+  ret[len+1] = (pid / 10000 % 10) + '0';\n+  ret[len+2] = (pid / 1000 % 10) + '0';\n+  ret[len+3] = (pid / 100 % 10) + '0';\n+  ret[len+4] = (pid / 10 % 10) + '0';\n+  ret[len+5] = (pid % 10) + '0';\n+  strcpy (ret + len + 6, \".tmp\");\n+\n+  return ret;\n+}\n+  \n /* Add the contents of FILENAME to the history list, a line at a time.\n    If FILENAME is NULL, then read from ~/.history.  Returns 0 if\n    successful, or errno if not. */\n@@ -174,7 +269,7 @@ read_history_range (filename, from, to)\n {\n   register char *line_start, *line_end, *p;\n   char *input, *buffer, *bufend, *last_ts;\n-  int file, current_line, chars_read;\n+  int file, current_line, chars_read, has_timestamps, reset_comment_char;\n   struct stat finfo;\n   size_t file_size;\n #if defined (EFBIG)\n@@ -185,6 +280,8 @@ read_history_range (filename, from, to)\n   int overflow_errno = EIO;\n #endif\n \n+  history_lines_read_from_file = 0;\n+\n   buffer = last_ts = (char *)NULL;\n   input = history_filename (filename);\n   file = input ? open (input, O_RDONLY|O_BINARY, 0666) : -1;\n@@ -249,6 +346,19 @@ read_history_range (filename, from, to)\n   bufend = buffer + chars_read;\n   current_line = 0;\n \n+  /* Heuristic: the history comment character rarely changes, so assume we\n+     have timestamps if the buffer starts with `#[:digit:]' and temporarily\n+     set history_comment_char so timestamp parsing works right */\n+  reset_comment_char = 0;\n+  if (history_comment_char == '\\0' && buffer[0] == '#' && isdigit ((unsigned char)buffer[1]))\n+    {\n+      history_comment_char = '#';\n+      reset_comment_char = 1;\n+    }\n+\n+  has_timestamps = HIST_TIMESTAMP_START (buffer);\n+  history_multiline_entries += has_timestamps && history_write_timestamps;  \n+\n   /* Skip lines until we are at FROM. */\n   for (line_start = line_end = buffer; line_end < bufend && current_line < from; line_end++)\n     if (*line_end == '\\n')\n@@ -275,7 +385,10 @@ read_history_range (filename, from, to)\n \t  {\n \t    if (HIST_TIMESTAMP_START(line_start) == 0)\n \t      {\n-\t\tadd_history (line_start);\n+\t      \tif (last_ts == NULL && history_multiline_entries)\n+\t\t  _hs_append_history_line (history_length - 1, line_start);\n+\t\telse\n+\t\t  add_history (line_start);\n \t\tif (last_ts)\n \t\t  {\n \t\t    add_history_time (last_ts);\n@@ -297,6 +410,10 @@ read_history_range (filename, from, to)\n \tline_start = line_end + 1;\n       }\n \n+  history_lines_read_from_file = current_line;\n+  if (reset_comment_char)\n+    history_comment_char = '\\0';\n+\n   FREE (input);\n #ifndef HISTORY_USE_MMAP\n   FREE (buffer);\n@@ -307,23 +424,68 @@ read_history_range (filename, from, to)\n   return (0);\n }\n \n+/* Save FILENAME to BACK, handling case where FILENAME is a symlink\n+   (e.g., ~/.bash_history -> .histfiles/.bash_history.$HOSTNAME) */\n+static int\n+histfile_backup (filename, back)\n+     const char *filename;\n+     const char *back;\n+{\n+#if defined (HAVE_READLINK)\n+  char linkbuf[PATH_MAX+1];\n+  ssize_t n;\n+\n+  /* Follow to target of symlink to avoid renaming symlink itself */\n+  if ((n = readlink (filename, linkbuf, sizeof (linkbuf) - 1)) > 0)\n+    {\n+      linkbuf[n] = '\\0';\n+      return (rename (linkbuf, back));\n+    }\n+#endif\n+  return (rename (filename, back));\n+}\n+\n+/* Restore ORIG from BACKUP handling case where ORIG is a symlink\n+   (e.g., ~/.bash_history -> .histfiles/.bash_history.$HOSTNAME) */\n+static int\n+histfile_restore (backup, orig)\n+     const char *backup;\n+     const char *orig;\n+{\n+#if defined (HAVE_READLINK)\n+  char linkbuf[PATH_MAX+1];\n+  ssize_t n;\n+\n+  /* Follow to target of symlink to avoid renaming symlink itself */\n+  if ((n = readlink (orig, linkbuf, sizeof (linkbuf) - 1)) > 0)\n+    {\n+      linkbuf[n] = '\\0';\n+      return (rename (backup, linkbuf));\n+    }\n+#endif\n+  return (rename (backup, orig));\n+}\n+\n /* Truncate the history file FNAME, leaving only LINES trailing lines.\n-   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno\n-   on failure. */\n+   If FNAME is NULL, then use ~/.history.  Writes a new file and renames\n+   it to the original name.  Returns 0 on success, errno on failure. */\n int\n history_truncate_file (fname, lines)\n      const char *fname;\n      int lines;\n {\n-  char *buffer, *filename, *bp, *bp1;\t\t/* bp1 == bp+1 */\n-  int file, chars_read, rv;\n+  char *buffer, *filename, *tempname, *bp, *bp1;\t\t/* bp1 == bp+1 */\n+  int file, chars_read, rv, orig_lines, exists, r;\n   struct stat finfo;\n   size_t file_size;\n \n+  history_lines_written_to_file = 0;\n+\n   buffer = (char *)NULL;\n   filename = history_filename (fname);\n+  tempname = 0;\n   file = filename ? open (filename, O_RDONLY|O_BINARY, 0666) : -1;\n-  rv = 0;\n+  rv = exists = 0;\n \n   /* Don't try to truncate non-regular files. */\n   if (file == -1 || fstat (file, &finfo) == -1)\n@@ -333,6 +495,7 @@ history_truncate_file (fname, lines)\n \tclose (file);\n       goto truncate_exit;\n     }\n+  exists = 1;\n \n   if (S_ISREG (finfo.st_mode) == 0)\n     {\n@@ -364,6 +527,7 @@ history_truncate_file (fname, lines)\n   buffer = (char *)malloc (file_size + 1);\n   if (buffer == 0)\n     {\n+      rv = errno;\n       close (file);\n       goto truncate_exit;\n     }\n@@ -377,6 +541,7 @@ history_truncate_file (fname, lines)\n       goto truncate_exit;\n     }\n \n+  orig_lines = lines;\n   /* Count backwards from the end of buffer until we have passed\n      LINES lines.  bp1 is set funny initially.  But since bp[1] can't\n      be a comment character (since it's off the end) and *bp can't be\n@@ -405,28 +570,56 @@ history_truncate_file (fname, lines)\n \n   /* Write only if there are more lines in the file than we want to\n      truncate to. */\n-  if (bp > buffer && ((file = open (filename, O_WRONLY|O_TRUNC|O_BINARY, 0600)) != -1))\n+  if (bp <= buffer)\n+    {\n+      rv = 0;\n+      /* No-op if LINES == 0 at this point */\n+      history_lines_written_to_file = orig_lines - lines;\n+      goto truncate_exit;\n+    }\n+\n+  tempname = history_tempfile (filename);\n+\n+  if ((file = open (tempname, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY, 0600)) != -1)\n     {\n       if (write (file, bp, chars_read - (bp - buffer)) < 0)\n \trv = errno;\n \n-#if defined (__BEOS__)\n-      /* BeOS ignores O_TRUNC. */\n-      ftruncate (file, chars_read - (bp - buffer));\n-#endif\n-\n-      close (file);\n+      if (close (file) < 0 && rv == 0)\n+\trv = errno;\n     }\n+  else\n+    rv = errno;\n \n  truncate_exit:\n-\n   FREE (buffer);\n \n+  history_lines_written_to_file = orig_lines - lines;\n+\n+  if (rv == 0 && filename && tempname)\n+    rv = histfile_restore (tempname, filename);\n+\n+  if (rv != 0)\n+    {\n+      if (tempname)\n+\tunlink (tempname);\n+      history_lines_written_to_file = 0;\n+    }\n+\n+  /* Make sure the new filename is owned by the same user as the old.  If one\n+     user is running this, it's a no-op.  If the shell is running after sudo\n+     with a shared history file, we don't want to leave the history file\n+     owned by root. */\n+  if (rv == 0 && exists)\n+    r = chown (filename, finfo.st_uid, finfo.st_gid);\n+\n   xfree (filename);\n+  FREE (tempname);\n+\n   return rv;\n }\n \n-/* Workhorse function for writing history.  Writes NELEMENT entries\n+/* Workhorse function for writing history.  Writes the last NELEMENT entries\n    from the history list to FILENAME.  OVERWRITE is non-zero if you\n    wish to replace FILENAME with the entries. */\n static int\n@@ -435,23 +628,33 @@ history_do_write (filename, nelements, overwrite)\n      int nelements, overwrite;\n {\n   register int i;\n-  char *output;\n-  int file, mode, rv;\n+  char *output, *tempname, *histname;\n+  int file, mode, rv, exists;\n+  struct stat finfo;\n #ifdef HISTORY_USE_MMAP\n   size_t cursize;\n \n+  history_lines_written_to_file = 0;\n+\n   mode = overwrite ? O_RDWR|O_CREAT|O_TRUNC|O_BINARY : O_RDWR|O_APPEND|O_BINARY;\n #else\n   mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;\n #endif\n-  output = history_filename (filename);\n+  histname = history_filename (filename);\n+  exists = histname ? (stat (histname, &finfo) == 0) : 0;\n+\n+  tempname = (overwrite && exists && S_ISREG (finfo.st_mode)) ? history_tempfile (histname) : 0;\n+  output = tempname ? tempname : histname;\n+\n   file = output ? open (output, mode, 0600) : -1;\n   rv = 0;\n \n   if (file == -1)\n     {\n-      FREE (output);\n-      return (errno);\n+      rv = errno;\n+      FREE (histname);\n+      FREE (tempname);\n+      return (rv);\n     }\n \n #ifdef HISTORY_USE_MMAP\n@@ -491,17 +694,23 @@ history_do_write (filename, nelements, overwrite)\n       {\n mmap_error:\n \trv = errno;\n-\tFREE (output);\n \tclose (file);\n+\tif (tempname)\n+\t  unlink (tempname);\n+\tFREE (histname);\n+\tFREE (tempname);\n \treturn rv;\n       }\n #else    \n     buffer = (char *)malloc (buffer_size);\n     if (buffer == 0)\n       {\n       \trv = errno;\n-\tFREE (output);\n \tclose (file);\n+\tif (tempname)\n+\t  unlink (tempname);\n+\tFREE (histname);\n+\tFREE (tempname);\n \treturn rv;\n       }\n #endif\n@@ -520,7 +729,7 @@ history_do_write (filename, nelements, overwrite)\n       }\n \n #ifdef HISTORY_USE_MMAP\n-    if (msync (buffer, buffer_size, 0) != 0 || munmap (buffer, buffer_size) != 0)\n+    if (msync (buffer, buffer_size, MS_ASYNC) != 0 || munmap (buffer, buffer_size) != 0)\n       rv = errno;\n #else\n     if (write (file, buffer, buffer_size) < 0)\n@@ -529,9 +738,30 @@ history_do_write (filename, nelements, overwrite)\n #endif\n   }\n \n-  close (file);\n+  history_lines_written_to_file = nelements;\n+\n+  if (close (file) < 0 && rv == 0)\n+    rv = errno;\n+\n+  if (rv == 0 && histname && tempname)\n+    rv = histfile_restore (tempname, histname);\n+\n+  if (rv != 0)\n+    {\n+      if (tempname)\n+\tunlink (tempname);\n+      history_lines_written_to_file = 0;\n+    }\n+\n+  /* Make sure the new filename is owned by the same user as the old.  If one\n+     user is running this, it's a no-op.  If the shell is running after sudo\n+     with a shared history file, we don't want to leave the history file\n+     owned by root. */\n+  if (rv == 0 && exists)\n+    mode = chown (histname, finfo.st_uid, finfo.st_gid);\n \n-  FREE (output);\n+  FREE (histname);\n+  FREE (tempname);\n \n   return (rv);\n }"
    },
    {
      "sha": "28cad14a58aa7df4879334705221ea856519cc1b",
      "filename": "readline/histlib.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histlib.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/histlib.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/histlib.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -76,7 +76,4 @@ extern char *strchr ();\n #define HISTORY_APPEND 0\n #define HISTORY_OVERWRITE 1\n \n-/* Some variable definitions shared across history source files. */\n-extern int history_offset;\n-\n #endif /* !_HISTLIB_H_ */"
    },
    {
      "sha": "129c57a3080c545eb6ee5c79d74fac948241b623",
      "filename": "readline/history.c",
      "status": "modified",
      "additions": 59,
      "deletions": 13,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/history.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/history.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/history.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* history.c -- standalone history library */\n \n-/* Copyright (C) 1989-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2015 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -43,11 +43,22 @@\n #  include <unistd.h>\n #endif\n \n+#include <errno.h>\n+\n #include \"history.h\"\n #include \"histlib.h\"\n \n #include \"xmalloc.h\"\n \n+#if !defined (errno)\n+extern int errno;\n+#endif\n+\n+/* How big to make the_history when we first allocate it. */\n+#define DEFAULT_HISTORY_INITIAL_SIZE\t502\n+\n+#define MAX_HISTORY_INITIAL_SIZE\t8192\n+\n /* The number of slots to increase the_history by. */\n #define DEFAULT_HISTORY_GROW_SIZE 50\n \n@@ -236,7 +247,10 @@ history_get_time (hist)\n   ts = hist->timestamp;\n   if (ts[0] != history_comment_char)\n     return 0;\n-  t = (time_t) atol (ts + 1);\t\t/* XXX - should use strtol() here */\n+  errno = 0;\n+  t = (time_t) strtol (ts + 1, (char **)NULL, 10);\t\t/* XXX - should use strtol() here */\n+  if (errno == ERANGE)\n+    return (time_t)0;\n   return t;\n }\n \n@@ -265,6 +279,7 @@ add_history (string)\n      const char *string;\n {\n   HIST_ENTRY *temp;\n+  int new_length;\n \n   if (history_stifled && (history_length == history_max_entries))\n     {\n@@ -279,19 +294,25 @@ add_history (string)\n       if (the_history[0])\n \t(void) free_history_entry (the_history[0]);\n \n-      /* Copy the rest of the entries, moving down one slot. */\n-      for (i = 0; i < history_length; i++)\n-\tthe_history[i] = the_history[i + 1];\n+      /* Copy the rest of the entries, moving down one slot.  Copy includes\n+\t trailing NULL.  */\n+      memmove (the_history, the_history + 1, history_length * sizeof (HIST_ENTRY *));\n \n+      new_length = history_length;\n       history_base++;\n     }\n   else\n     {\n       if (history_size == 0)\n \t{\n-\t  history_size = DEFAULT_HISTORY_GROW_SIZE;\n+\t  if (history_stifled && history_max_entries > 0)\n+\t    history_size = (history_max_entries > MAX_HISTORY_INITIAL_SIZE)\n+\t\t\t\t? MAX_HISTORY_INITIAL_SIZE\n+\t\t\t\t: history_max_entries + 2;\n+\t  else\n+\t    history_size = DEFAULT_HISTORY_INITIAL_SIZE;\n \t  the_history = (HIST_ENTRY **)xmalloc (history_size * sizeof (HIST_ENTRY *));\n-\t  history_length = 1;\n+\t  new_length = 1;\n \t}\n       else\n \t{\n@@ -301,14 +322,15 @@ add_history (string)\n \t      the_history = (HIST_ENTRY **)\n \t\txrealloc (the_history, history_size * sizeof (HIST_ENTRY *));\n \t    }\n-\t  history_length++;\n+\t  new_length = history_length + 1;\n \t}\n     }\n \n-  temp = alloc_history_entry (string, hist_inittime ());\n+  temp = alloc_history_entry ((char *)string, hist_inittime ());\n \n-  the_history[history_length] = (HIST_ENTRY *)NULL;\n-  the_history[history_length - 1] = temp;\n+  the_history[new_length] = (HIST_ENTRY *)NULL;\n+  the_history[new_length - 1] = temp;\n+  history_length = new_length;\n }\n \n /* Change the time stamp of the most recent history entry to STRING. */\n@@ -318,7 +340,7 @@ add_history_time (string)\n {\n   HIST_ENTRY *hs;\n \n-  if (string == 0)\n+  if (string == 0 || history_length < 1)\n     return;\n   hs = the_history[history_length - 1];\n   FREE (hs->timestamp);\n@@ -387,14 +409,38 @@ replace_history_entry (which, line, data)\n   return (old_value);\n }\n \n+/* Append LINE to the history line at offset WHICH, adding a newline to the\n+   end of the current line first.  This can be used to construct multi-line\n+   history entries while reading lines from the history file. */\n+void\n+_hs_append_history_line (which, line)\n+     int which;\n+     const char *line;\n+{\n+  HIST_ENTRY *hent;\n+  size_t newlen, curlen;\n+  char *newline;\n+\n+  hent = the_history[which];\n+  curlen = strlen (hent->line);\n+  newlen = curlen + strlen (line) + 2;\n+  newline = realloc (hent->line, newlen);\n+  if (newline)\n+    {\n+      hent->line = newline;\n+      hent->line[curlen++] = '\\n';\n+      strcpy (hent->line + curlen, line);\n+    }\n+}\n+\n /* Replace the DATA in the specified history entries, replacing OLD with\n    NEW.  WHICH says which one(s) to replace:  WHICH == -1 means to replace\n    all of the history entries where entry->data == OLD; WHICH == -2 means\n    to replace the `newest' history entry where entry->data == OLD; and\n    WHICH >= 0 means to replace that particular history entry's data, as\n    long as it matches OLD. */\n void\n-replace_history_data (which,old, new)\n+_hs_replace_history_data (which, old, new)\n      int which;\n      histdata_t *old, *new;\n {"
    },
    {
      "sha": "8ce7c805d168f88e77e6d7be14aaea6ada69e981",
      "filename": "readline/history.h",
      "status": "modified",
      "additions": 18,
      "deletions": 2,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/history.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/history.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/history.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* history.h -- the names of functions that you can call in history. */\n \n-/* Copyright (C) 1989-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1989-2015 Free Software Foundation, Inc.\n \n    This file contains the GNU History Library (History), a set of\n    routines for managing the text of previously typed lines.\n@@ -91,6 +91,13 @@ extern void add_history_time PARAMS((const char *));\n    elements are numbered from 0. */\n extern HIST_ENTRY *remove_history PARAMS((int));\n \n+/* Allocate a history entry consisting of STRING and TIMESTAMP and return\n+   a pointer to it. */\n+extern HIST_ENTRY *alloc_history_entry PARAMS((char *, char *));\n+\n+/* Copy the history entry H, but not the (opaque) data pointer */\n+extern HIST_ENTRY *copy_history_entry PARAMS((HIST_ENTRY *));\n+\n /* Free the history entry H and return any application-specific data\n    associated with it. */\n extern histdata_t free_history_entry PARAMS((HIST_ENTRY *));\n@@ -216,7 +223,7 @@ extern int history_truncate_file PARAMS((const char *, int));\n   -1) If there was an error in expansion.\n    2) If the returned line should just be printed.\n \n-  If an error ocurred in expansion, then OUTPUT contains a descriptive\n+  If an error occurred in expansion, then OUTPUT contains a descriptive\n   error message. */\n extern int history_expand PARAMS((char *, char **));\n \n@@ -241,6 +248,11 @@ extern char **history_tokenize PARAMS((const char *));\n extern int history_base;\n extern int history_length;\n extern int history_max_entries;\n+extern int history_offset;\n+\n+extern int history_lines_read_from_file;\n+extern int history_lines_written_to_file;\n+\n extern char history_expansion_char;\n extern char history_subst_char;\n extern char *history_word_delimiters;\n@@ -251,6 +263,10 @@ extern int history_quotes_inhibit_expansion;\n \n extern int history_write_timestamps;\n \n+/* These two are undocumented; the second is reserved for future use */\n+extern int history_multiline_entries;\n+extern int history_file_version;\n+\n /* Backwards compatibility */\n extern int max_input_history;\n "
    },
    {
      "sha": "077d53c2b6a448d2dd198e142091c5ac353c2f4a",
      "filename": "readline/input.c",
      "status": "modified",
      "additions": 92,
      "deletions": 23,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/input.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/input.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/input.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* input.c -- character input functions for readline. */\n \n-/* Copyright (C) 1994-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -45,6 +45,8 @@\n #  include \"ansi_stdlib.h\"\n #endif /* HAVE_STDLIB_H */\n \n+#include <signal.h>\n+\n #include \"posixselect.h\"\n \n #if defined (FIONREAD_IN_SYS_IOCTL)\n@@ -78,6 +80,13 @@ extern int errno;\n    character input. */\n rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;\n \n+/* A function to call if a read(2) is interrupted by a signal. */\n+rl_hook_func_t *rl_signal_event_hook = (rl_hook_func_t *)NULL;\n+\n+/* A function to replace _rl_input_available for applications using the\n+   callback interface. */\n+rl_hook_func_t *rl_input_available_hook = (rl_hook_func_t *)NULL;\n+\n rl_getc_func_t *rl_getc_function = rl_getc;\n \n static int _keyboard_input_timeout = 100000;\t\t/* 0.1 seconds; it's in usec */\n@@ -135,6 +144,12 @@ _rl_any_typein ()\n   return any_typein;\n }\n \n+int\n+_rl_pushed_input_available ()\n+{\n+  return (push_index != pop_index);\n+}\n+\n /* Return the amount of space available in the buffer for stuffing\n    characters. */\n static int\n@@ -148,7 +163,7 @@ ibuffer_space ()\n \n /* Get a key from the buffer of characters to be read.\n    Return the key in KEY.\n-   Result is KEY if there was a key, or 0 if there wasn't. */\n+   Result is non-zero if there was a key, or 0 if there wasn't. */\n static int\n rl_get_char (key)\n      int *key;\n@@ -185,12 +200,6 @@ _rl_unget_char (key)\n   return (0);\n }\n \n-int\n-_rl_pushed_input_available ()\n-{\n-  return (push_index != pop_index);\n-}\n-\n /* If a character is available to be read, then read it and stuff it into\n    IBUFFER.  Otherwise, just return.  Returns number of characters read\n    (0 if none available) and -1 on error (EIO). */\n@@ -207,6 +216,7 @@ rl_gather_tyi ()\n #endif\n \n   chars_avail = 0;\n+  input = 0;\n   tty = fileno (rl_instream);\n \n #if defined (HAVE_SELECT)\n@@ -221,11 +231,13 @@ rl_gather_tyi ()\n #endif\n \n   result = -1;\n-#if defined (FIONREAD)\n   errno = 0;\n+#if defined (FIONREAD)\n   result = ioctl (tty, FIONREAD, &chars_avail);\n   if (result == -1 && errno == EIO)\n     return -1;\n+  if (result == -1)\n+    chars_avail = 0;\n #endif\n \n #if defined (O_NDELAY)\n@@ -239,6 +251,8 @@ rl_gather_tyi ()\n       fcntl (tty, F_SETFL, tem);\n       if (chars_avail == -1 && errno == EAGAIN)\n \treturn 0;\n+      if (chars_avail == -1 && errno == EIO)\n+\treturn -1;\n       if (chars_avail == 0)\t/* EOF */\n \t{\n \t  rl_stuff_char (EOF);\n@@ -322,6 +336,9 @@ _rl_input_available ()\n #endif\n   int tty;\n \n+  if (rl_input_available_hook)\n+    return (*rl_input_available_hook) ();\n+\n   tty = fileno (rl_instream);\n \n #if defined (HAVE_SELECT)\n@@ -440,9 +457,7 @@ rl_clear_pending_input ()\n int\n rl_read_key ()\n {\n-  int c;\n-\n-  rl_key_sequence_length++;\n+  int c, r;\n \n   if (rl_pending_input)\n     {\n@@ -460,14 +475,18 @@ rl_read_key ()\n \t{\n \t  while (rl_event_hook)\n \t    {\n-\t      if (rl_gather_tyi () < 0)\t/* XXX - EIO */\n+\t      if (rl_get_char (&c) != 0)\n+\t\tbreak;\n+\t\t\n+\t      if ((r = rl_gather_tyi ()) < 0)\t/* XXX - EIO */\n \t\t{\n \t\t  rl_done = 1;\n-\t\t  return ('\\n');\n+\t\t  return (errno == EIO ? (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF) : '\\n');\n \t\t}\n+\t      else if (r > 0)\t\t\t/* read something */\n+\t\tcontinue;\n+\n \t      RL_CHECK_SIGNALS ();\n-\t      if (rl_get_char (&c) != 0)\n-\t\tbreak;\n \t      if (rl_done)\t\t/* XXX - experimental */\n \t\treturn ('\\n');\n \t      (*rl_event_hook) ();\n@@ -477,6 +496,7 @@ rl_read_key ()\n \t{\n \t  if (rl_get_char (&c) == 0)\n \t    c = (*rl_getc_function) (rl_instream);\n+/* fprintf(stderr, \"rl_read_key: calling RL_CHECK_SIGNALS: _rl_caught_signal = %d\", _rl_caught_signal); */\n \t  RL_CHECK_SIGNALS ();\n \t}\n     }\n@@ -490,18 +510,31 @@ rl_getc (stream)\n {\n   int result;\n   unsigned char c;\n+#if defined (HAVE_PSELECT)\n+  sigset_t empty_set;\n+  fd_set readfds;\n+#endif\n \n   while (1)\n     {\n       RL_CHECK_SIGNALS ();\n \n+      /* We know at this point that _rl_caught_signal == 0 */\n+\n #if defined (__MINGW32__)\n-      /* Use _getch to make sure we call the function from MS runtime,\n-\t even if some curses library is linked in.  */\n       if (isatty (fileno (stream)))\n-\treturn (_getch ());\n+\treturn (_getch ());\t/* \"There is no error return.\" */\n+#endif\n+      result = 0;\n+#if defined (HAVE_PSELECT)\n+      sigemptyset (&empty_set);\n+      sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &empty_set);\n+      FD_ZERO (&readfds);\n+      FD_SET (fileno (stream), &readfds);\n+      result = pselect (fileno (stream) + 1, &readfds, NULL, NULL, NULL, &empty_set);\n #endif\n-      result = read (fileno (stream), &c, sizeof (unsigned char));\n+      if (result >= 0)\n+\tresult = read (fileno (stream), &c, sizeof (unsigned char));\n \n       if (result == sizeof (unsigned char))\n \treturn (c);\n@@ -538,11 +571,47 @@ rl_getc (stream)\n #undef X_EWOULDBLOCK\n #undef X_EAGAIN\n \n-      /* If the error that we received was SIGINT, then try again,\n-\t this is simply an interrupted system call to read ().\n-\t Otherwise, some error ocurred, also signifying EOF. */\n+/* fprintf(stderr, \"rl_getc: result = %d errno = %d\\n\", result, errno); */\n+\n+handle_error:\n+      /* If the error that we received was EINTR, then try again,\n+\t this is simply an interrupted system call to read ().  We allow\n+\t the read to be interrupted if we caught SIGHUP, SIGTERM, or any\n+\t of the other signals readline treats specially. If the\n+\t application sets an event hook, call it for other signals.\n+\t Otherwise (not EINTR), some error occurred, also signifying EOF. */\n       if (errno != EINTR)\n \treturn (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);\n+      /* fatal signals of interest */\n+#if defined (SIGHUP)\n+      else if (_rl_caught_signal == SIGHUP || _rl_caught_signal == SIGTERM)\n+#else\n+      else if (_rl_caught_signal == SIGTERM)\n+#endif\n+\treturn (RL_ISSTATE (RL_STATE_READCMD) ? READERR : EOF);\n+      /* keyboard-generated signals of interest */\n+#if defined (SIGQUIT)\n+      else if (_rl_caught_signal == SIGINT || _rl_caught_signal == SIGQUIT)\n+#else\n+      else if (_rl_caught_signal == SIGINT)\n+#endif\n+        RL_CHECK_SIGNALS ();\n+      /* non-keyboard-generated signals of interest */\n+#if defined (SIGWINCH)\n+      else if (_rl_caught_signal == SIGWINCH)\n+\tRL_CHECK_SIGNALS ();\n+#endif /* SIGWINCH */\n+#if defined (SIGALRM)\n+      else if (_rl_caught_signal == SIGALRM\n+#  if defined (SIGVTALRM)\n+\t\t|| _rl_caught_signal == SIGVTALRM\n+#  endif\n+\t      )\n+        RL_CHECK_SIGNALS ();\n+#endif  /* SIGALRM */\n+\n+      if (rl_signal_event_hook)\n+\t(*rl_signal_event_hook) ();\n     }\n }\n "
    },
    {
      "sha": "819fcbce45fc22bb37495604e762317cf133c2c3",
      "filename": "readline/isearch.c",
      "status": "modified",
      "additions": 130,
      "deletions": 21,
      "changes": 151,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/isearch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/isearch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/isearch.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -6,7 +6,7 @@\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -66,7 +66,6 @@ static int rl_search_history PARAMS((int, int));\n \n static _rl_search_cxt *_rl_isearch_init PARAMS((int));\n static void _rl_isearch_fini PARAMS((_rl_search_cxt *));\n-static int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));\n \n /* Last line found by the current incremental search, so we don't `find'\n    identical lines many times in a row.  Now part of isearch context. */\n@@ -110,7 +109,7 @@ _rl_scxt_alloc (type, flags)\n   cxt->history_pos = 0;\n   cxt->direction = 0;\n \n-  cxt->lastc = 0;\n+  cxt->prevc = cxt->lastc = 0;\n \n   cxt->sline = 0;\n   cxt->sline_len = cxt->sline_index = 0;\n@@ -156,16 +155,16 @@ rl_forward_search_history (sign, key)\n    WHERE is the history list number of the current line.  If it is\n    -1, then this line is the starting one. */\n static void\n-rl_display_search (search_string, reverse_p, where)\n+rl_display_search (search_string, flags, where)\n      char *search_string;\n-     int reverse_p, where;\n+     int flags, where;\n {\n   char *message;\n   int msglen, searchlen;\n \n   searchlen = (search_string && *search_string) ? strlen (search_string) : 0;\n \n-  message = (char *)xmalloc (searchlen + 33);\n+  message = (char *)xmalloc (searchlen + 64);\n   msglen = 0;\n \n #if defined (NOTDEF)\n@@ -178,7 +177,13 @@ rl_display_search (search_string, reverse_p, where)\n \n   message[msglen++] = '(';\n \n-  if (reverse_p)\n+  if (flags & SF_FAILED)\n+    {\n+      strcpy (message + msglen, \"failed \");\n+      msglen += 7;\n+    }\n+\n+  if (flags & SF_REVERSE)\n     {\n       strcpy (message + msglen, \"reverse-\");\n       msglen += 8;\n@@ -215,7 +220,7 @@ _rl_isearch_init (direction)\n   cxt->search_terminators = _rl_isearch_terminators ? _rl_isearch_terminators\n \t\t\t\t\t\t: default_isearch_terminators;\n \n-  /* Create an arrary of pointers to the lines that we want to search. */\n+  /* Create an array of pointers to the lines that we want to search. */\n   hlist = history_list ();\n   rl_maybe_replace_line ();\n   i = 0;\n@@ -312,13 +317,19 @@ _rl_search_getchar (cxt)\n   RL_UNSETSTATE(RL_STATE_MOREINPUT);\n \n #if defined (HANDLE_MULTIBYTE)\n+  /* This ends up with C (and LASTC) being set to the last byte of the\n+     multibyte character.  In most cases c == lastc == mb[0] */\n   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n     c = cxt->lastc = _rl_read_mbstring (cxt->lastc, cxt->mb, MB_LEN_MAX);\n #endif\n \n+  RL_CHECK_SIGNALS ();\n   return c;\n }\n \n+#define ENDSRCH_CHAR(c) \\\n+  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))\n+\n /* Process just-read character C according to isearch context CXT.  Return\n    -1 if the caller should just free the context and return, 0 if we should\n    break out of the loop, and 1 if we should continue to read characters. */\n@@ -344,13 +355,43 @@ _rl_isearch_dispatch (cxt, c)\n      incremental search, so we check */\n   if (c >= 0 && cxt->keymap[c].type == ISKMAP && strchr (cxt->search_terminators, cxt->lastc) == 0)\n     {\n+      /* _rl_keyseq_timeout specified in milliseconds; _rl_input_queued\n+\t takes microseconds, so multiply by 1000.  If we don't get any\n+\t additional input and this keymap shadows another function, process\n+\t that key as if it was all we read. */\n+      if (_rl_keyseq_timeout > 0 &&\n+\t    RL_ISSTATE (RL_STATE_CALLBACK) == 0 &&\n+\t    RL_ISSTATE (RL_STATE_INPUTPENDING) == 0 &&\n+\t    _rl_pushed_input_available () == 0 &&\n+\t    ((Keymap)(cxt->keymap[c].function))[ANYOTHERKEY].function &&\n+\t    _rl_input_queued (_rl_keyseq_timeout*1000) == 0)\n+\tgoto add_character;\n+\n+      cxt->okeymap = cxt->keymap;\n       cxt->keymap = FUNCTION_TO_KEYMAP (cxt->keymap, c);\n       cxt->sflags |= SF_CHGKMAP;\n       /* XXX - we should probably save this sequence, so we can do\n-\t something useful if this doesn't end up mapping to a command. */\n+\t something useful if this doesn't end up mapping to a command we\n+\t interpret here.  Right now we just save the most recent character\n+\t that caused the index into a new keymap. */\n+      cxt->prevc = c;\n+#if defined (HANDLE_MULTIBYTE)\n+      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t{\n+\t  if (cxt->mb[1] == 0)\n+\t    {\n+\t      cxt->pmb[0] = c;\t\t/* XXX should be == cxt->mb[0] */\n+\t      cxt->pmb[1] = '\\0';\n+\t    }\n+\t  else\n+\t    memcpy (cxt->pmb, cxt->mb, sizeof (cxt->pmb));\n+\t}\n+#endif\n       return 1;\n     }\n \n+add_character:\n+\n   /* Translate the keys we do something with to opcodes. */\n   if (c >= 0 && cxt->keymap[c].type == ISFUNC)\n     {\n@@ -376,6 +417,54 @@ _rl_isearch_dispatch (cxt, c)\n     {\n       cxt->keymap = cxt->okeymap;\n       cxt->sflags &= ~SF_CHGKMAP;\n+      /* If we indexed into a new keymap, but didn't map to a command that\n+\t affects the search (lastc > 0), and the character that mapped to a\n+\t new keymap would have ended the search (ENDSRCH_CHAR(cxt->prevc)),\n+\t handle that now as if the previous char would have ended the search\n+\t and we would have read the current character. */\n+      /* XXX - should we check cxt->mb? */\n+      if (cxt->lastc > 0 && ENDSRCH_CHAR (cxt->prevc))\n+\t{\n+\t  rl_stuff_char (cxt->lastc);\n+\t  rl_execute_next (cxt->prevc);\n+\t  /* XXX - do we insert everything in cxt->pmb? */\n+\t  return (0);\n+\t}\n+      /* Otherwise, if the current character is mapped to self-insert or\n+\t nothing (i.e., not an editing command), and the previous character\n+\t was a keymap index, then we need to insert both the previous\n+\t character and the current character into the search string. */\n+      else if (cxt->lastc > 0 && cxt->prevc > 0 &&\n+\t       cxt->keymap[cxt->prevc].type == ISKMAP &&\n+\t       (f == 0 || f == rl_insert))\n+\t{\n+\t  /* Make lastc be the next character read */\n+\t  /* XXX - do we insert everything in cxt->mb? */\n+\t  rl_execute_next (cxt->lastc);\n+\t  /* Dispatch on the previous character (insert into search string) */\n+\t  cxt->lastc = cxt->prevc;\n+#if defined (HANDLE_MULTIBYTE)\n+\t  /* Have to overwrite cxt->mb here because dispatch uses it below */\n+\t  if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n+\t    {  \n+\t      if (cxt->pmb[1] == 0)\t  \n+\t\t{\n+\t\t  cxt->mb[0] = cxt->lastc;\t/* == cxt->prevc */\n+\t\t  cxt->mb[1] = '\\0';\n+\t\t}\n+\t      else\n+\t\tmemcpy (cxt->mb, cxt->pmb, sizeof (cxt->mb));\n+\t    }\n+#endif\n+\t  cxt->prevc = 0;\t  \n+\t}\n+      else if (cxt->lastc > 0 && cxt->prevc > 0 && f && f != rl_insert)\n+\t{\n+\t  rl_stuff_char (cxt->lastc);\n+\t  rl_execute_next (cxt->prevc);\n+\t  /* XXX - do we insert everything in cxt->pmb? */\n+\t  return (0);\n+\t}\n     }\n \n   /* The characters in isearch_terminators (set from the user-settable\n@@ -393,14 +482,11 @@ _rl_isearch_dispatch (cxt, c)\n \t XXX - since _rl_input_available depends on the application-\n \t settable keyboard timeout value, this could alternatively\n \t use _rl_input_queued(100000) */\n-      if (cxt->lastc == ESC && _rl_input_available ())\n+      if (cxt->lastc == ESC && (_rl_pushed_input_available () || _rl_input_available ()))\n \trl_execute_next (ESC);\n       return (0);\n     }\n \n-#define ENDSRCH_CHAR(c) \\\n-  ((CTRL_CHAR (c) || META_CHAR (c) || (c) == RUBOUT) && ((c) != CTRL ('G')))\n-\n #if defined (HANDLE_MULTIBYTE)\n   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n     {\n@@ -436,7 +522,7 @@ _rl_isearch_dispatch (cxt, c)\n \t      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);\n \t      strcpy (cxt->search_string, last_isearch_string);\n \t      cxt->search_string_index = last_isearch_string_len;\n-\t      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);\n+\t      rl_display_search (cxt->search_string, cxt->sflags, -1);\n \t      break;\n \t    }\n \t  return (1);\n@@ -466,8 +552,20 @@ _rl_isearch_dispatch (cxt, c)\n \t do until we have a real isearch-undo. */\n       if (cxt->search_string_index == 0)\n \trl_ding ();\n-      else\n+      else if (MB_CUR_MAX == 1 || rl_byte_oriented)\n \tcxt->search_string[--cxt->search_string_index] = '\\0';\n+      else\n+\t{\n+\t  wstart = _rl_find_prev_mbchar (cxt->search_string, cxt->search_string_index, MB_FIND_NONZERO);\n+\t  if (wstart >= 0)\n+\t    cxt->search_string[cxt->search_string_index = wstart] = '\\0';\n+\t  else\n+\t    cxt->search_string[cxt->search_string_index = 0] = '\\0';\n+\t}\n+\n+      if (cxt->search_string_index == 0)\n+\trl_ding ();\n+\n       break;\n \n     case -4:\t/* C-G, abort */\n@@ -544,18 +642,28 @@ _rl_isearch_dispatch (cxt, c)\n       if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n \t{\n \t  int j, l;\n-\t  for (j = 0, l = strlen (cxt->mb); j < l; )\n-\t    cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];\n+\n+\t  if (cxt->mb[0] == 0 || cxt->mb[1] == 0)\n+\t    cxt->search_string[cxt->search_string_index++] = cxt->mb[0];\n+\t  else\n+\t    for (j = 0, l = RL_STRLEN (cxt->mb); j < l; )\n+\t      cxt->search_string[cxt->search_string_index++] = cxt->mb[j++];\n \t}\n       else\n #endif\n-\tcxt->search_string[cxt->search_string_index++] = c;\n+\tcxt->search_string[cxt->search_string_index++] = cxt->lastc;\t/* XXX - was c instead of lastc */\n       cxt->search_string[cxt->search_string_index] = '\\0';\n       break;\n     }\n \n   for (cxt->sflags &= ~(SF_FOUND|SF_FAILED);; )\n     {\n+      if (cxt->search_string_index == 0)\n+\t{\n+\t  cxt->sflags |= SF_FAILED;\n+\t  break;\n+\t}\n+\n       limit = cxt->sline_len - cxt->search_string_index + 1;\n \n       /* Search the current line. */\n@@ -606,6 +714,7 @@ _rl_isearch_dispatch (cxt, c)\n       /* We cannot find the search string.  Ding the bell. */\n       rl_ding ();\n       cxt->history_pos = cxt->last_found_line;\n+      rl_display_search (cxt->search_string, cxt->sflags, (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);\n       return 1;\n     }\n \n@@ -618,13 +727,13 @@ _rl_isearch_dispatch (cxt, c)\n       rl_replace_line (cxt->lines[cxt->history_pos], 0);\n       rl_point = cxt->sline_index;\n       cxt->last_found_line = cxt->history_pos;\n-      rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);\n+      rl_display_search (cxt->search_string, cxt->sflags, (cxt->history_pos == cxt->save_line) ? -1 : cxt->history_pos);\n     }\n \n   return 1;\n }\n \n-static int\n+int\n _rl_isearch_cleanup (cxt, r)\n      _rl_search_cxt *cxt;\n      int r;\n@@ -653,7 +762,7 @@ rl_search_history (direction, invoking_key)\n   RL_SETSTATE(RL_STATE_ISEARCH);\n   cxt = _rl_isearch_init (direction);\n \n-  rl_display_search (cxt->search_string, (cxt->sflags & SF_REVERSE), -1);\n+  rl_display_search (cxt->search_string, cxt->sflags, -1);\n \n   /* If we are using the callback interface, all we do is set up here and\n       return.  The key is that we leave RL_STATE_ISEARCH set. */"
    },
    {
      "sha": "696f1938f8e81c10c418f384f26f85f922cbd0d1",
      "filename": "readline/kill.c",
      "status": "modified",
      "additions": 94,
      "deletions": 10,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/kill.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/kill.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/kill.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* kill.c -- kill ring management. */\n \n-/* Copyright (C) 1994 Free Software Foundation, Inc.\n+/* Copyright (C) 1994-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -97,7 +97,7 @@ _rl_copy_to_kill_ring (text, append)\n   int slot;\n \n   /* First, find the slot to work with. */\n-  if (_rl_last_command_was_kill == 0)\n+  if (_rl_last_command_was_kill == 0 || rl_kill_ring == 0)\n     {\n       /* Get a new slot.  */\n       if (rl_kill_ring == 0)\n@@ -278,7 +278,7 @@ rl_backward_kill_line (direction, ignore)\n     return (rl_kill_line (1, ignore));\n   else\n     {\n-      if (!rl_point)\n+      if (rl_point == 0)\n \trl_ding ();\n       else\n \t{\n@@ -506,7 +506,7 @@ rl_yank (count, ignore)\n   if (rl_kill_ring == 0)\n     {\n       _rl_abort_internal ();\n-      return -1;\n+      return 1;\n     }\n \n   _rl_set_mark_at_pos (rl_point);\n@@ -528,7 +528,7 @@ rl_yank_pop (count, key)\n       !rl_kill_ring)\n     {\n       _rl_abort_internal ();\n-      return -1;\n+      return 1;\n     }\n \n   l = strlen (rl_kill_ring[rl_kill_index]);\n@@ -546,10 +546,44 @@ rl_yank_pop (count, key)\n   else\n     {\n       _rl_abort_internal ();\n-      return -1;\n+      return 1;\n     }\n }\n \n+#if defined (VI_MODE)\n+int\n+rl_vi_yank_pop (count, key)\n+     int count, key;\n+{\n+  int l, n;\n+\n+  if (((rl_last_func != rl_vi_yank_pop) && (rl_last_func != rl_vi_put)) ||\n+      !rl_kill_ring)\n+    {\n+      _rl_abort_internal ();\n+      return 1;\n+    }\n+\n+  l = strlen (rl_kill_ring[rl_kill_index]);\n+  n = rl_point - l;\n+  if (n >= 0 && STREQN (rl_line_buffer + n, rl_kill_ring[rl_kill_index], l))\n+    {\n+      rl_delete_text (n, rl_point);\n+      rl_point = n;\n+      rl_kill_index--;\n+      if (rl_kill_index < 0)\n+\trl_kill_index = rl_kill_ring_length - 1;\n+      rl_vi_put (1, 'p');\n+      return 0;\n+    }\n+  else\n+    {\n+      _rl_abort_internal ();\n+      return 1;\n+    }\n+}\n+#endif /* VI_MODE */\n+\n /* Yank the COUNTh argument from the previous history line, skipping\n    HISTORY_SKIP lines before looking for the `previous line'. */\n static int\n@@ -575,15 +609,15 @@ rl_yank_nth_arg_internal (count, ignore, history_skip)\n   if (entry == 0)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   arg = history_arg_extract (count, count, entry->line);\n   if (!arg || !*arg)\n     {\n       rl_ding ();\n       FREE (arg);\n-      return -1;\n+      return 1;\n     }\n \n   rl_begin_undo_group ();\n@@ -656,7 +690,57 @@ rl_yank_last_arg (count, key)\n   return retval;\n }\n \n-/* A special paste command for users of Cygnus's cygwin32. */\n+/* Having read the special escape sequence denoting the beginning of a\n+   `bracketed paste' sequence, read the rest of the pasted input until the\n+   closing sequence and insert the pasted text as a single unit without\n+   interpretation. */\n+int\n+rl_bracketed_paste_begin (count, key)\n+     int count, key;\n+{\n+  int retval, c;\n+  size_t len, cap;\n+  char *buf;\n+\n+  retval = 1;\n+  len = 0;\n+  buf = xmalloc (cap = 64);\n+\n+  RL_SETSTATE (RL_STATE_MOREINPUT);\n+  while ((c = rl_read_key ()) >= 0)\n+    {\n+      if (RL_ISSTATE (RL_STATE_MACRODEF))\n+\t_rl_add_macro_char (c);\n+\n+      if (c == '\\r')\t\t/* XXX */\n+\tc = '\\n';\n+\n+      if (len == cap)\n+\tbuf = xrealloc (buf, cap *= 2);\n+\n+      buf[len++] = c;\n+      if (len >= BRACK_PASTE_SLEN && c == BRACK_PASTE_LAST &&\n+\t  STREQN (buf + len - BRACK_PASTE_SLEN, BRACK_PASTE_SUFF, BRACK_PASTE_SLEN))\n+\t{\n+\t  len -= BRACK_PASTE_SLEN;\n+\t  break;\n+\t}\n+    }\n+  RL_UNSETSTATE (RL_STATE_MOREINPUT);\n+\n+  if (c >= 0)\n+    {\n+      if (len == cap)\n+\tbuf = xrealloc (buf, cap + 1);\n+      buf[len] = '\\0';\n+      retval = rl_insert_text (buf);\n+    }\n+\n+  xfree (buf);\n+  return (retval);\n+}\n+\n+/* A special paste command for Windows users.. */\n #if defined (_WIN32)\n #include <windows.h>\n \n@@ -691,4 +775,4 @@ rl_paste_from_clipboard (count, key)\n     }\n   return (0);\n }\n-#endif /* __CYGWIN__ */\n+#endif /* _WIN32 */"
    },
    {
      "sha": "c7017cc6b3dab6303d9278031b557bcfd0862f02",
      "filename": "readline/macro.c",
      "status": "modified",
      "additions": 39,
      "deletions": 3,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/macro.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -121,6 +121,19 @@ _rl_next_macro_key ()\n #endif\n }\n \n+int\n+_rl_prev_macro_key ()\n+{\n+  if (rl_executing_macro == 0)\n+    return (0);\n+\n+  if (executing_macro_index == 0)\n+    return (0);\n+\n+  executing_macro_index--;\n+  return (rl_executing_macro[executing_macro_index]);\n+}\n+\n /* Save the currently executing macro on a stack of saved macros. */\n void\n _rl_push_executing_macro ()\n@@ -206,7 +219,7 @@ rl_start_kbd_macro (ignore1, ignore2)\n   if (RL_ISSTATE (RL_STATE_MACRODEF))\n     {\n       _rl_abort_internal ();\n-      return -1;\n+      return 1;\n     }\n \n   if (rl_explicit_arg)\n@@ -231,10 +244,10 @@ rl_end_kbd_macro (count, ignore)\n   if (RL_ISSTATE (RL_STATE_MACRODEF) == 0)\n     {\n       _rl_abort_internal ();\n-      return -1;\n+      return 1;\n     }\n \n-  current_macro_index -= rl_key_sequence_length - 1;\n+  current_macro_index -= rl_key_sequence_length;\n   current_macro[current_macro_index] = '\\0';\n \n   RL_UNSETSTATE(RL_STATE_MACRODEF);\n@@ -263,6 +276,29 @@ rl_call_last_kbd_macro (count, ignore)\n   return 0;\n }\n \n+int\n+rl_print_last_kbd_macro (count, ignore)\n+     int count, ignore;\n+{\n+  char *m;\n+\n+  if (current_macro == 0)\n+    {\n+      rl_ding ();\n+      return 0;\n+    }\n+  m = _rl_untranslate_macro_value (current_macro, 1);\n+  rl_crlf ();\n+  printf (\"%s\", m);\n+  fflush (stdout);\n+  rl_crlf ();\n+  FREE (m);\n+  rl_forced_update_display ();\n+  rl_display_fixed = 1;\n+\n+  return 0;\n+}\n+\n void\n rl_push_macro_input (macro)\n      char *macro;"
    },
    {
      "sha": "314a49b64bff04a4f0f1bc9450497577de48324f",
      "filename": "readline/mbutil.c",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/mbutil.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/mbutil.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/mbutil.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* mbutil.c -- readline multibyte character utility functions */\n \n-/* Copyright (C) 2001-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2001-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -64,6 +64,9 @@ int rl_byte_oriented = 0;\n int rl_byte_oriented = 1;\n #endif\n \n+/* Ditto */\n+int _rl_utf8locale = 0;\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\tMultibyte Character Utility Functions\t\t    */\n@@ -119,7 +122,7 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n \t  point += tmp;\n \t  if (find_non_zero)\n \t    {\n-\t      if (wcwidth (wc) == 0)\n+\t      if (WCWIDTH (wc) == 0)\n \t\tcontinue;\n \t      else\n \t\tcount--;\n@@ -132,7 +135,7 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n   if (find_non_zero)\n     {\n       tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);\n-      while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && wcwidth (wc) == 0)\n+      while (MB_NULLWCH (tmp) == 0 && MB_INVALIDCH (tmp) == 0 && WCWIDTH (wc) == 0)\n \t{\n \t  point += tmp;\n \t  tmp = mbrtowc (&wc, string + point, strlen (string + point), &ps);\n@@ -142,7 +145,7 @@ _rl_find_next_mbchar_internal (string, seed, count, find_non_zero)\n   return point;\n }\n \n-static int\n+/*static*/ int\n _rl_find_prev_mbchar_internal (string, seed, find_non_zero)\n      char *string;\n      int seed, find_non_zero;\n@@ -184,7 +187,7 @@ _rl_find_prev_mbchar_internal (string, seed, find_non_zero)\n \t{\n \t  if (find_non_zero)\n \t    {\n-\t      if (wcwidth (wc) != 0)\n+\t      if (WCWIDTH (wc) != 0)\n \t\tprev = point;\n \t    }\n \t  else\n@@ -263,7 +266,7 @@ _rl_compare_chars (buf1, pos1, ps1, buf2, pos2, ps2)\n    if point is invalied (point < 0 || more than string length),\n    it returns -1 */\n int\n-_rl_adjust_point(string, point, ps)\n+_rl_adjust_point (string, point, ps)\n      char *string;\n      int point;\n      mbstate_t *ps;"
    },
    {
      "sha": "f7acdee06147895d61d8e43e57b971812f5f729f",
      "filename": "readline/misc.c",
      "status": "modified",
      "additions": 40,
      "deletions": 3,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/misc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/misc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/misc.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* misc.c -- miscellaneous bindable readline functions. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -126,7 +126,7 @@ _rl_arg_dispatch (cxt, c)\n \n   /* If we see a key bound to `universal-argument' after seeing digits,\n       it ends the argument but is otherwise ignored. */\n-  if (_rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)\n+  if (c >= 0 && _rl_keymap[c].type == ISFUNC && _rl_keymap[c].function == rl_universal_argument)\n     {\n       if ((cxt & NUM_SAWDIGITS) == 0)\n \t{\n@@ -266,6 +266,8 @@ _rl_arg_callback (cxt)\n   int c, r;\n \n   c = _rl_arg_getchar ();\n+  if (c < 0)\n+    return (1);\t\t/* EOF */\n \n   if (_rl_argcxt & NUM_READONE)\n     {\n@@ -459,14 +461,14 @@ _rl_revert_all_lines ()\n \t    saved_undo_list = 0;\n \t  /* Set up rl_line_buffer and other variables from history entry */\n \t  rl_replace_from_history (entry, 0);\t/* entry->line is now current */\n+\t  entry->data = 0;\t\t\t/* entry->data is now current undo list */\n \t  /* Undo all changes to this history entry */\n \t  while (rl_undo_list)\n \t    rl_do_undo ();\n \t  /* And copy the reverted line back to the history entry, preserving\n \t     the timestamp. */\n \t  FREE (entry->line);\n \t  entry->line = savestring (rl_line_buffer);\n-\t  entry->data = 0;\n \t}\n       entry = previous_history ();\n     }\n@@ -483,6 +485,37 @@ _rl_revert_all_lines ()\n   xfree (lbuf);\n }  \n \n+/* Free the history list, including private readline data and take care\n+   of pointer aliases to history data.  Resets rl_undo_list if it points\n+   to an UNDO_LIST * saved as some history entry's data member.  This\n+   should not be called while editing is active. */\n+void\n+rl_clear_history ()\n+{\n+  HIST_ENTRY **hlist, *hent;\n+  register int i;\n+  UNDO_LIST *ul, *saved_undo_list;\n+\n+  saved_undo_list = rl_undo_list;\n+  hlist = history_list ();\t\t/* direct pointer, not copy */\n+\n+  for (i = 0; i < history_length; i++)\n+    {\n+      hent = hlist[i];\n+      if (ul = (UNDO_LIST *)hent->data)\n+\t{\n+\t  if (ul == saved_undo_list)\n+\t    saved_undo_list = 0;\n+\t  _rl_free_undo_list (ul);\n+\t  hent->data = 0;\n+\t}\n+      _rl_free_history_entry (hent);\n+    }\n+\n+  history_offset = history_length = 0;\n+  rl_undo_list = saved_undo_list;\t/* should be NULL */\n+}\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tHistory Commands\t\t\t    */\n@@ -623,6 +656,10 @@ rl_emacs_editing_mode (count, key)\n   rl_editing_mode = emacs_mode;\n   _rl_set_insert_mode (RL_IM_INSERT, 1); /* emacs mode default is insert mode */\n   _rl_keymap = emacs_standard_keymap;\n+\n+  if (_rl_show_mode_in_prompt)\n+    _rl_reset_prompt ();\n+\n   return 0;\n }\n "
    },
    {
      "sha": "d3b36344f103b20945158f2e8a3db7a8a993d5f7",
      "filename": "readline/nls.c",
      "status": "modified",
      "additions": 32,
      "deletions": 3,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/nls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/nls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/nls.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -43,13 +43,19 @@\n #  include <locale.h>\n #endif\n \n+#if defined (HAVE_LANGINFO_CODESET)\n+#  include <langinfo.h>\n+#endif\n+\n #include <ctype.h>\n \n #include \"rldefs.h\"\n #include \"readline.h\"\n #include \"rlshell.h\"\n #include \"rlprivate.h\"\n \n+static int utf8locale PARAMS((char *));\n+\n #if !defined (HAVE_SETLOCALE)    \n /* A list of legal values for the LANG or LC_CTYPE environment variables.\n    If a locale name in this list is the value for the LC_ALL, LC_CTYPE,\n@@ -72,9 +78,10 @@ static char *legal_lang_values[] =\n };\n \n static char *normalize_codeset PARAMS((char *));\n-static char *find_codeset PARAMS((char *, size_t *));\n #endif /* !HAVE_SETLOCALE */\n \n+static char *find_codeset PARAMS((char *, size_t *));\n+\n static char *_rl_get_locale_var PARAMS((const char *));\n \n static char *\n@@ -91,7 +98,26 @@ _rl_get_locale_var (v)\n \n   return lspec;\n }\n-  \n+\n+static int\n+utf8locale (lspec)\n+     char *lspec;\n+{\n+  char *cp;\n+  size_t len;\n+\n+#if HAVE_LANGINFO_CODESET\n+  cp = nl_langinfo (CODESET);\n+  return (STREQ (cp, \"UTF-8\") || STREQ (cp, \"utf8\"));\n+#else\n+  cp = find_codeset (lspec, &len);\n+\n+  if (cp == 0 || len < 4 || len > 5)\n+    return 0;\n+  return ((len == 5) ? strncmp (cp, \"UTF-8\", len) == 0 : strncmp (cp, \"utf8\", 4) == 0);\n+#endif\n+}\n+\n /* Check for LC_ALL, LC_CTYPE, and LANG and use the first with a value\n    to decide the defaults for 8-bit character input and output.  Returns\n    1 if we set eight-bit mode. */\n@@ -116,6 +142,9 @@ _rl_init_eightbit ()\n     lspec = \"\";\n   t = setlocale (LC_CTYPE, lspec);\n \n+  if (t && *t)\n+    _rl_utf8locale = utf8locale (t);\n+\n   if (t && *t && (t[0] != 'C' || t[1]) && (STREQ (t, \"POSIX\") == 0))\n     {\n       _rl_meta_flag = 1;\n@@ -197,6 +226,7 @@ normalize_codeset (codeset)\n \n   return retval;\n }\n+#endif /* !HAVE_SETLOCALE */\n \n /* Isolate codeset portion of locale specification. */\n static char *\n@@ -249,4 +279,3 @@ find_codeset (name, lenp)\n \n   return result;\n }\n-#endif /* !HAVE_SETLOCALE */"
    },
    {
      "sha": "ecc465c00dfb1eaa0ab7a7cf35c4959beddc5882",
      "filename": "readline/parens.c",
      "status": "modified",
      "additions": 20,
      "deletions": 8,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parens.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parens.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/parens.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* parens.c -- implementation of matching parentheses feature. */\n \n-/* Copyright (C) 1987, 1989, 1992-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987, 1989, 1992-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -57,11 +57,7 @@ static int find_matching_open PARAMS((char *, int, int));\n \n /* Non-zero means try to blink the matching open parenthesis when the\n    close parenthesis is inserted. */\n-#if defined (HAVE_SELECT)\n-int rl_blink_matching_paren = 1;\n-#else /* !HAVE_SELECT */\n int rl_blink_matching_paren = 0;\n-#endif /* !HAVE_SELECT */\n \n static int _paren_blink_usec = 500000;\n \n@@ -72,16 +68,32 @@ _rl_enable_paren_matching (on_or_off)\n      int on_or_off;\n {\n   if (on_or_off)\n-    {\t/* ([{ */\n+    {\n+      /* ([{ */\n       rl_bind_key_in_map (')', rl_insert_close, emacs_standard_keymap);\n       rl_bind_key_in_map (']', rl_insert_close, emacs_standard_keymap);\n       rl_bind_key_in_map ('}', rl_insert_close, emacs_standard_keymap);\n+\n+#if defined (VI_MODE)\n+      /* ([{ */\n+      rl_bind_key_in_map (')', rl_insert_close, vi_insertion_keymap);\n+      rl_bind_key_in_map (']', rl_insert_close, vi_insertion_keymap);\n+      rl_bind_key_in_map ('}', rl_insert_close, vi_insertion_keymap);\n+#endif\n     }\n   else\n-    {\t/* ([{ */\n+    {\n+      /* ([{ */\n       rl_bind_key_in_map (')', rl_insert, emacs_standard_keymap);\n       rl_bind_key_in_map (']', rl_insert, emacs_standard_keymap);\n       rl_bind_key_in_map ('}', rl_insert, emacs_standard_keymap);\n+\n+#if defined (VI_MODE)\n+      /* ([{ */\n+      rl_bind_key_in_map (')', rl_insert, vi_insertion_keymap);\n+      rl_bind_key_in_map (']', rl_insert, vi_insertion_keymap);\n+      rl_bind_key_in_map ('}', rl_insert, vi_insertion_keymap);\n+#endif\n     }\n }\n \n@@ -117,7 +129,7 @@ rl_insert_close (count, invoking_key)\n \n       /* Emacs might message or ring the bell here, but I don't. */\n       if (match_point < 0)\n-\treturn -1;\n+\treturn 1;\n \n       FD_ZERO (&readfds);\n       FD_SET (fileno (rl_instream), &readfds);"
    },
    {
      "sha": "98b2e9d10a1b487698fdbbd2e73d969a213412e5",
      "filename": "readline/parse-colors.c",
      "status": "added",
      "additions": 440,
      "deletions": 0,
      "changes": 440,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parse-colors.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parse-colors.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/parse-colors.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,440 @@\n+/* `dir', `vdir' and `ls' directory listing programs for GNU.\n+\n+   Modified by Chet Ramey for Readline.\n+\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012 Free Software Foundation,\n+   Inc.\n+\n+   This program is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Written by Richard Stallman and David MacKenzie.  */\n+\n+/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis\n+   Flaherty <dennisf@denix.elk.miles.com> based on original patches by\n+   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */\n+\n+#define READLINE_LIBRARY\n+\n+#if defined (HAVE_CONFIG_H)\n+#  include <config.h>\n+#endif\n+\n+#include <stdio.h>\n+\n+// strdup() / strcpy()\n+#if defined (HAVE_STRING_H)\n+#  include <string.h>\n+#else /* !HAVE_STRING_H */\n+#  include <strings.h>\n+#endif /* !HAVE_STRING_H */\n+\n+// abort()\n+#if defined (HAVE_STDLIB_H)\n+#  include <stdlib.h>\n+#else\n+#  include \"ansi_stdlib.h\"\n+#endif /* HAVE_STDLIB_H */\n+\n+#include \"rldefs.h\"\t// STREQ, savestring\n+#include \"readline.h\"\n+#include \"rlprivate.h\"\n+#include \"rlshell.h\"\n+#include \"xmalloc.h\"\n+\n+#include \"colors.h\"\n+#include \"parse-colors.h\"\n+\n+#if defined (COLOR_SUPPORT)\n+\n+static bool get_funky_string (char **dest, const char **src, bool equals_end, size_t *output_count);\n+\n+struct bin_str _rl_color_indicator[] =\n+  {\n+    { LEN_STR_PAIR (\"\\033[\") },         //  lc: Left of color sequence\n+    { LEN_STR_PAIR (\"m\") },             //  rc: Right of color sequence\n+    { 0, NULL },                        //  ec: End color (replaces lc+no+rc)\n+    { LEN_STR_PAIR (\"0\") },             //  rs: Reset to ordinary colors\n+    { 0, NULL },                        //  no: Normal\n+    { 0, NULL },                        //  fi: File: default\n+    { LEN_STR_PAIR (\"01;34\") },         //  di: Directory: bright blue\n+    { LEN_STR_PAIR (\"01;36\") },         //  ln: Symlink: bright cyan\n+    { LEN_STR_PAIR (\"33\") },            //  pi: Pipe: yellow/brown\n+    { LEN_STR_PAIR (\"01;35\") },         //  so: Socket: bright magenta\n+    { LEN_STR_PAIR (\"01;33\") },         //  bd: Block device: bright yellow\n+    { LEN_STR_PAIR (\"01;33\") },         //  cd: Char device: bright yellow\n+    { 0, NULL },                        //  mi: Missing file: undefined\n+    { 0, NULL },                        //  or: Orphaned symlink: undefined\n+    { LEN_STR_PAIR (\"01;32\") },         //  ex: Executable: bright green\n+    { LEN_STR_PAIR (\"01;35\") },         //  do: Door: bright magenta\n+    { LEN_STR_PAIR (\"37;41\") },         //  su: setuid: white on red\n+    { LEN_STR_PAIR (\"30;43\") },         //  sg: setgid: black on yellow\n+    { LEN_STR_PAIR (\"37;44\") },         //  st: sticky: black on blue\n+    { LEN_STR_PAIR (\"34;42\") },         //  ow: other-writable: blue on green\n+    { LEN_STR_PAIR (\"30;42\") },         //  tw: ow w/ sticky: black on green\n+    { LEN_STR_PAIR (\"30;41\") },         //  ca: black on red\n+    { 0, NULL },                        //  mh: disabled by default\n+    { LEN_STR_PAIR (\"\\033[K\") },        //  cl: clear to end of line\n+  };\n+\n+/* Parse a string as part of the LS_COLORS variable; this may involve\n+   decoding all kinds of escape characters.  If equals_end is set an\n+   unescaped equal sign ends the string, otherwise only a : or \\0\n+   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return\n+   true if successful.\n+\n+   The resulting string is *not* null-terminated, but may contain\n+   embedded nulls.\n+\n+   Note that both dest and src are char **; on return they point to\n+   the first free byte after the array and the character that ended\n+   the input string, respectively.  */\n+\n+static bool\n+get_funky_string (char **dest, const char **src, bool equals_end, size_t *output_count) {\n+  char num;\t\t\t/* For numerical codes */\n+  size_t count;\t\t\t/* Something to count with */\n+  enum {\n+    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR\n+  } state;\n+  const char *p;\n+  char *q;\n+\n+  p = *src;\t\t\t/* We don't want to double-indirect */\n+  q = *dest;\t\t\t/* the whole darn time.  */\n+\n+  count = 0;\t\t\t/* No characters counted in yet.  */\n+  num = 0;\n+\n+  state = ST_GND;\t\t/* Start in ground state.  */\n+  while (state < ST_END)\n+    {\n+      switch (state)\n+        {\n+        case ST_GND:\t\t/* Ground state (no escapes) */\n+          switch (*p)\n+            {\n+            case ':':\n+            case '\\0':\n+              state = ST_END;\t/* End of string */\n+              break;\n+            case '\\\\':\n+              state = ST_BACKSLASH; /* Backslash scape sequence */\n+              ++p;\n+              break;\n+            case '^':\n+              state = ST_CARET; /* Caret escape */\n+              ++p;\n+              break;\n+            case '=':\n+              if (equals_end)\n+                {\n+                  state = ST_END; /* End */\n+                  break;\n+                }\n+              /* else fall through */\n+            default:\n+              *(q++) = *(p++);\n+              ++count;\n+              break;\n+            }\n+          break;\n+\n+        case ST_BACKSLASH:\t/* Backslash escaped character */\n+          switch (*p)\n+            {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+              state = ST_OCTAL;\t/* Octal sequence */\n+              num = *p - '0';\n+              break;\n+            case 'x':\n+            case 'X':\n+              state = ST_HEX;\t/* Hex sequence */\n+              num = 0;\n+              break;\n+            case 'a':\t\t/* Bell */\n+              num = '\\a';\n+              break;\n+            case 'b':\t\t/* Backspace */\n+              num = '\\b';\n+              break;\n+            case 'e':\t\t/* Escape */\n+              num = 27;\n+              break;\n+            case 'f':\t\t/* Form feed */\n+              num = '\\f';\n+              break;\n+            case 'n':\t\t/* Newline */\n+              num = '\\n';\n+              break;\n+            case 'r':\t\t/* Carriage return */\n+              num = '\\r';\n+              break;\n+            case 't':\t\t/* Tab */\n+              num = '\\t';\n+              break;\n+            case 'v':\t\t/* Vtab */\n+              num = '\\v';\n+              break;\n+            case '?':\t\t/* Delete */\n+              num = 127;\n+              break;\n+            case '_':\t\t/* Space */\n+              num = ' ';\n+              break;\n+            case '\\0':\t\t/* End of string */\n+              state = ST_ERROR;\t/* Error! */\n+              break;\n+            default:\t\t/* Escaped character like \\ ^ : = */\n+              num = *p;\n+              break;\n+            }\n+          if (state == ST_BACKSLASH)\n+            {\n+              *(q++) = num;\n+              ++count;\n+              state = ST_GND;\n+            }\n+          ++p;\n+          break;\n+\n+        case ST_OCTAL:\t\t/* Octal sequence */\n+          if (*p < '0' || *p > '7')\n+            {\n+              *(q++) = num;\n+              ++count;\n+              state = ST_GND;\n+            }\n+          else\n+            num = (num << 3) + (*(p++) - '0');\n+          break;\n+\n+        case ST_HEX:\t\t/* Hex sequence */\n+          switch (*p)\n+            {\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+            case '4':\n+            case '5':\n+            case '6':\n+            case '7':\n+            case '8':\n+            case '9':\n+              num = (num << 4) + (*(p++) - '0');\n+              break;\n+            case 'a':\n+            case 'b':\n+            case 'c':\n+            case 'd':\n+            case 'e':\n+            case 'f':\n+              num = (num << 4) + (*(p++) - 'a') + 10;\n+              break;\n+            case 'A':\n+            case 'B':\n+            case 'C':\n+            case 'D':\n+            case 'E':\n+            case 'F':\n+              num = (num << 4) + (*(p++) - 'A') + 10;\n+              break;\n+            default:\n+              *(q++) = num;\n+              ++count;\n+              state = ST_GND;\n+              break;\n+            }\n+          break;\n+\n+        case ST_CARET:\t\t/* Caret escape */\n+          state = ST_GND;\t/* Should be the next state... */\n+          if (*p >= '@' && *p <= '~')\n+            {\n+              *(q++) = *(p++) & 037;\n+              ++count;\n+            }\n+          else if (*p == '?')\n+            {\n+              *(q++) = 127;\n+              ++count;\n+            }\n+          else\n+            state = ST_ERROR;\n+          break;\n+\n+        default:\n+\t  /* should we ? */\n+          /* abort ();\tno, we should not */\n+          state = ST_ERROR;\n+          break;\n+        }\n+    }\n+\n+  *dest = q;\n+  *src = p;\n+  *output_count = count;\n+\n+  return state != ST_ERROR;\n+}\n+#endif /* COLOR_SUPPORT */\n+\n+void _rl_parse_colors()\n+{\n+#if defined (COLOR_SUPPORT)\n+  const char *p;\t\t/* Pointer to character being parsed */\n+  char *buf;\t\t\t/* color_buf buffer pointer */\n+  int state;\t\t\t/* State of parser */\n+  int ind_no;\t\t\t/* Indicator number */\n+  char label[3];\t\t/* Indicator label */\n+  COLOR_EXT_TYPE *ext;\t\t/* Extension we are working on */\n+\n+  p = sh_get_env_value (\"LS_COLORS\");\n+  if (p == 0 || *p == '\\0')\n+    {\n+      _rl_color_ext_list = NULL;\n+      return;\n+    }\n+\n+  ext = NULL;\n+  strcpy (label, \"??\");\n+\n+  /* This is an overly conservative estimate, but any possible\n+     LS_COLORS string will *not* generate a color_buf longer than\n+     itself, so it is a safe way of allocating a buffer in\n+     advance.  */\n+  buf = color_buf = savestring (p);\n+\n+  state = 1;\n+  while (state > 0)\n+    {\n+      switch (state)\n+        {\n+        case 1:\t\t/* First label character */\n+          switch (*p)\n+            {\n+            case ':':\n+              ++p;\n+              break;\n+\n+            case '*':\n+              /* Allocate new extension block and add to head of\n+                 linked list (this way a later definition will\n+                 override an earlier one, which can be useful for\n+                 having terminal-specific defs override global).  */\n+\n+              ext = (COLOR_EXT_TYPE *)xmalloc (sizeof *ext);\n+              ext->next = _rl_color_ext_list;\n+              _rl_color_ext_list = ext;\n+\n+              ++p;\n+              ext->ext.string = buf;\n+\n+              state = (get_funky_string (&buf, &p, true, &ext->ext.len)\n+                       ? 4 : -1);\n+              break;\n+\n+            case '\\0':\n+              state = 0;\t/* Done! */\n+              break;\n+\n+            default:\t/* Assume it is file type label */\n+              label[0] = *(p++);\n+              state = 2;\n+              break;\n+            }\n+          break;\n+\n+        case 2:\t\t/* Second label character */\n+          if (*p)\n+            {\n+              label[1] = *(p++);\n+              state = 3;\n+            }\n+          else\n+            state = -1;\t/* Error */\n+          break;\n+\n+        case 3:\t\t/* Equal sign after indicator label */\n+          state = -1;\t/* Assume failure...  */\n+          if (*(p++) == '=')/* It *should* be...  */\n+            {\n+              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)\n+                {\n+                  if (STREQ (label, indicator_name[ind_no]))\n+                    {\n+                      _rl_color_indicator[ind_no].string = buf;\n+                      state = (get_funky_string (&buf, &p, false,\n+                                                 &_rl_color_indicator[ind_no].len)\n+                               ? 1 : -1);\n+                      break;\n+                    }\n+                }\n+              if (state == -1)\n+\t\t{\n+                  _rl_errmsg (\"LS_COLORS: unrecognized prefix: %s\", label);\n+                  /* recover from an unrecognized prefix */\n+                  while (p && *p && *p != ':')\n+\t\t    p++;\n+\t\t  if (p && *p == ':')\n+\t\t    state = 1;\n+\t\t  else if (p && *p == 0)\n+\t\t    state = 0;\n+\t\t}\n+            }\n+          break;\n+\n+        case 4:\t\t/* Equal sign after *.ext */\n+          if (*(p++) == '=')\n+            {\n+              ext->seq.string = buf;\n+              state = (get_funky_string (&buf, &p, false, &ext->seq.len)\n+                       ? 1 : -1);\n+            }\n+          else\n+            state = -1;\n+          /* XXX - recover here as with an unrecognized prefix? */\n+          if (state == -1 && ext->ext.string)\n+\t    _rl_errmsg (\"LS_COLORS: syntax error: %s\", ext->ext.string);\n+          break;\n+        }\n+    }\n+\n+  if (state < 0)\n+    {\n+      COLOR_EXT_TYPE *e;\n+      COLOR_EXT_TYPE *e2;\n+\n+      _rl_errmsg (\"unparsable value for LS_COLORS environment variable\");\n+      free (color_buf);\n+      for (e = _rl_color_ext_list; e != NULL; /* empty */)\n+        {\n+          e2 = e;\n+          e = e->next;\n+          free (e2);\n+        }\n+      _rl_color_ext_list = NULL;\n+      _rl_colored_stats = 0;\t/* can't have colored stats without colors */\n+    }\n+#else /* !COLOR_SUPPORT */\n+  ;\n+#endif /* !COLOR_SUPPORT */\n+}"
    },
    {
      "sha": "aef86f784d45d519cc3a2b6f69eafd30a550dff8",
      "filename": "readline/parse-colors.h",
      "status": "added",
      "additions": 46,
      "deletions": 0,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parse-colors.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/parse-colors.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/parse-colors.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,46 @@\n+/* `dir', `vdir' and `ls' directory listing programs for GNU.\n+\n+   Modified by Chet Ramey for Readline.\n+\n+   Copyright (C) 1985, 1988, 1990-1991, 1995-2010, 2012 Free Software Foundation,\n+   Inc.\n+\n+   This program is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* Written by Richard Stallman and David MacKenzie.  */\n+\n+/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis\n+   Flaherty <dennisf@denix.elk.miles.com> based on original patches by\n+   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */\n+\n+#ifndef _PARSE_COLORS_H_\n+#define _PARSE_COLORS_H_\n+\n+#include \"readline.h\"\n+\n+#define LEN_STR_PAIR(s) sizeof (s) - 1, s\n+\n+void _rl_parse_colors (void);\n+\n+static const char *const indicator_name[]=\n+  {\n+    \"lc\", \"rc\", \"ec\", \"rs\", \"no\", \"fi\", \"di\", \"ln\", \"pi\", \"so\",\n+    \"bd\", \"cd\", \"mi\", \"or\", \"ex\", \"do\", \"su\", \"sg\", \"st\",\n+    \"ow\", \"tw\", \"ca\", \"mh\", \"cl\", NULL\n+  };\n+\n+/* Buffer for color sequences */\n+static char *color_buf;\n+\n+#endif /* !_PARSE_COLORS_H_ */"
    },
    {
      "sha": "e0ba09d8b5a8bfb97125732919b6d1c27b11b2b2",
      "filename": "readline/patchlevel",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/patchlevel",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/patchlevel",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/patchlevel?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,3 +1,3 @@\n # Do not edit -- exists only for use by patch\n \n-1\n+5"
    },
    {
      "sha": "0921c5d752b8120578bfdc2fc7170ff279493834",
      "filename": "readline/posixdir.h",
      "status": "modified",
      "additions": 12,
      "deletions": 2,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/posixdir.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/posixdir.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/posixdir.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* posixdir.h -- Posix directory reading includes and defines. */\n \n-/* Copyright (C) 1987,1991 Free Software Foundation, Inc.\n+/* Copyright (C) 1987,1991,2012 Free Software Foundation, Inc.\n \n    This file is part of GNU Bash, the Bourne Again SHell.\n \n@@ -46,16 +46,26 @@\n #  define D_NAMLEN(d)   ((d)->d_namlen)\n #endif /* !HAVE_DIRENT_H */\n \n+/* The bash code fairly consistenly uses d_fileno; make sure it's available */\n #if defined (HAVE_STRUCT_DIRENT_D_INO) && !defined (HAVE_STRUCT_DIRENT_D_FILENO)\n #  define d_fileno d_ino\n #endif\n \n-#if defined (_POSIX_SOURCE) && (!defined (HAVE_STRUCT_DIRENT_D_INO) || defined (BROKEN_DIRENT_D_INO))\n /* Posix does not require that the d_ino field be present, and some\n    systems do not provide it. */\n+#if !defined (HAVE_STRUCT_DIRENT_D_INO) || defined (BROKEN_DIRENT_D_INO)\n #  define REAL_DIR_ENTRY(dp) 1\n #else\n #  define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)\n #endif /* _POSIX_SOURCE */\n \n+#if defined (HAVE_STRUCT_DIRENT_D_INO) && !defined (BROKEN_DIRENT_D_INO)\n+#  define D_INO_AVAILABLE\n+#endif\n+\n+/* Signal the rest of the code that it can safely use dirent.d_fileno */\n+#if defined (D_INO_AVAILABLE) || defined (HAVE_STRUCT_DIRENT_D_FILENO)\n+#  define D_FILENO_AVAILABLE 1\n+#endif\n+\n #endif /* !_POSIXDIR_H_ */"
    },
    {
      "sha": "9c7e99ed42f01bb85482e7933a4d8431c9b313cb",
      "filename": "readline/posixjmp.h",
      "status": "modified",
      "additions": 13,
      "deletions": 7,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/posixjmp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/posixjmp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/posixjmp.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* posixjmp.h -- wrapper for setjmp.h with changes for POSIX systems. */\n \n-/* Copyright (C) 1987,1991 Free Software Foundation, Inc.\n+/* Copyright (C) 1987,1991-2015 Free Software Foundation, Inc.\n \n    This file is part of GNU Bash, the Bourne Again SHell.\n \n@@ -27,14 +27,20 @@\n \n #if defined (HAVE_POSIX_SIGSETJMP)\n #  define procenv_t\tsigjmp_buf\n-#  if !defined (__OPENNT)\n-#    undef setjmp\n-#    define setjmp(x)\tsigsetjmp((x), 1)\n-#    undef longjmp\n-#    define longjmp(x, n)\tsiglongjmp((x), (n))\n-#  endif /* !__OPENNT */\n+\n+#  define setjmp_nosigs(x)\tsigsetjmp((x), 0)\n+#  define setjmp_sigs(x)\tsigsetjmp((x), 1)\n+\n+#  define _rl_longjmp(x, n)\tsiglongjmp((x), (n))\n+#  define sh_longjmp(x, n)\tsiglongjmp((x), (n))\n #else\n #  define procenv_t\tjmp_buf\n+\n+#  define setjmp_nosigs\t\tsetjmp\n+#  define setjmp_sigs\t\tsetjmp\n+\n+#  define _rl_longjmp(x, n)\tlongjmp((x), (n))\n+#  define sh_longjmp(x, n)\tlongjmp((x), (n))\n #endif\n \n #endif /* _POSIXJMP_H_ */"
    },
    {
      "sha": "a05b35e5d24983dbdcfbcffd6d7887eb9c54ea09",
      "filename": "readline/readline.c",
      "status": "modified",
      "additions": 224,
      "deletions": 42,
      "changes": 266,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n /* readline.c -- a general facility for reading lines of input\n    with emacs style editing and completion. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -82,13 +82,20 @@ extern int errno;\n \n extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));\n \n+#if defined (COLOR_SUPPORT)\n+extern void _rl_parse_colors PARAMS((void));\t\t/* XXX */\n+#endif\n+\n+\n /* Forward declarations used in this file. */\n static char *readline_internal PARAMS((void));\n static void readline_initialize_everything PARAMS((void));\n \n static void bind_arrow_keys_internal PARAMS((Keymap));\n static void bind_arrow_keys PARAMS((void));\n \n+static void bind_bracketed_paste_prefix PARAMS((void));\n+\n static void readline_default_bindings PARAMS((void));\n static void reset_default_bindings PARAMS((void));\n \n@@ -112,7 +119,6 @@ int rl_gnu_readline_p = 1;\n    By default, it is the standard emacs keymap. */\n Keymap _rl_keymap = emacs_standard_keymap;\n \n-\n /* The current style of editing. */\n int rl_editing_mode = emacs_mode;\n \n@@ -145,7 +151,7 @@ static int running_in_emacs;\n #endif\n \n /* Flags word encapsulating the current readline state. */\n-int rl_readline_state = RL_STATE_NONE;\n+unsigned long rl_readline_state = RL_STATE_NONE;\n \n /* The current offset in the current input line. */\n int rl_point;\n@@ -238,13 +244,32 @@ int rl_erase_empty_line = 0;\n    character bound to accept-line. */\n int rl_num_chars_to_read;\n \n-/* Line buffer and maintenence. */\n+/* Line buffer and maintenance. */\n char *rl_line_buffer = (char *)NULL;\n int rl_line_buffer_len = 0;\n \n /* Key sequence `contexts' */\n _rl_keyseq_cxt *_rl_kscxt = 0;\n \n+int rl_executing_key;\n+char *rl_executing_keyseq = 0;\n+int _rl_executing_keyseq_size = 0;\n+\n+/* Timeout (specified in milliseconds) when reading characters making up an\n+   ambiguous multiple-key sequence */\n+int _rl_keyseq_timeout = 500;\n+\n+#define RESIZE_KEYSEQ_BUFFER() \\\n+  do \\\n+    { \\\n+      if (rl_key_sequence_length + 2 >= _rl_executing_keyseq_size) \\\n+\t{ \\\n+\t  _rl_executing_keyseq_size += 16; \\\n+\t  rl_executing_keyseq = xrealloc (rl_executing_keyseq, _rl_executing_keyseq_size); \\\n+\t} \\\n+    } \\\n+  while (0);\n+        \n /* Forward declarations used by the display, termcap, and history code. */\n \n /* **************************************************************** */\n@@ -279,6 +304,15 @@ int _rl_revert_all_at_newline = 0;\n    characters corresponding to keyboard-generated signals. */\n int _rl_echo_control_chars = 1;\n \n+/* Non-zero means to prefix the displayed prompt with a character indicating\n+   the editing mode: @ for emacs, : for vi-command, + for vi-insert. */\n+int _rl_show_mode_in_prompt = 0;\n+\n+/* Non-zero means to attempt to put the terminal in `bracketed paste mode',\n+   where it will prefix pasted text with an escape sequence and send\n+   another to mark the end of the paste. */\n+int _rl_enable_bracketed_paste = 0;\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tTop Level Functions\t\t\t    */\n@@ -352,6 +386,11 @@ readline (prompt)\n     RL_SETSTATE (RL_STATE_CALLBACK);\n #endif\n \n+#if HAVE_DECL_AUDIT_USER_TTY && defined (HAVE_LIBAUDIT_H) && defined (ENABLE_TTY_AUDIT_SUPPORT)\n+  if (value)\n+    _rl_audit_tty (value);\n+#endif\n+\n   return (value);\n }\n \n@@ -369,9 +408,19 @@ readline_internal_setup ()\n   _rl_in_stream = rl_instream;\n   _rl_out_stream = rl_outstream;\n \n+  /* Enable the meta key only for the duration of readline(), if this\n+     terminal has one and the terminal has been initialized */\n+  if (_rl_enable_meta & RL_ISSTATE (RL_STATE_TERMPREPPED))\n+    _rl_enable_meta_key ();\n+\n   if (rl_startup_hook)\n     (*rl_startup_hook) ();\n \n+#if defined (VI_MODE)\n+  if (rl_editing_mode == vi_mode)\n+    rl_vi_insertion_mode (1, 'i');\t/* don't want to reset last */\n+#endif /* VI_MODE */\n+\n   /* If we're not echoing, we still want to at least print a prompt, because\n      rl_redisplay will not do it for us.  If the calling application has a\n      custom redisplay function, though, let that function handle it. */\n@@ -394,11 +443,6 @@ readline_internal_setup ()\n       (*rl_redisplay_function) ();\n     }\n \n-#if defined (VI_MODE)\n-  if (rl_editing_mode == vi_mode)\n-    rl_vi_insert_mode (1, 'i');\n-#endif /* VI_MODE */\n-\n   if (rl_pre_input_hook)\n     (*rl_pre_input_hook) ();\n \n@@ -437,6 +481,11 @@ readline_internal_teardown (eof)\n   if (rl_undo_list)\n     rl_free_undo_list ();\n \n+  /* Disable the meta key, if this terminal has one and we were told to use it.\n+     The check whether or not we sent the enable string is in\n+     _rl_disable_meta_key(); the flag is set in _rl_enable_meta_key */\n+  _rl_disable_meta_key ();\n+\n   /* Restore normal cursor, if available. */\n   _rl_set_insert_mode (RL_IM_INSERT, 0);\n \n@@ -483,16 +532,20 @@ readline_internal_charloop ()\n   static int lastc, eof_found;\n   int c, code, lk;\n \n-  lastc = -1;\n-  eof_found = 0;\n+  lastc = EOF;\n \n #if !defined (READLINE_CALLBACKS)\n+  eof_found = 0;\n   while (rl_done == 0)\n     {\n #endif\n       lk = _rl_last_command_was_kill;\n \n+#if defined (HAVE_POSIX_SIGSETJMP)\n+      code = sigsetjmp (_rl_top_level, 0);\n+#else\n       code = setjmp (_rl_top_level);\n+#endif\n \n       if (code)\n \t{\n@@ -510,7 +563,7 @@ readline_internal_charloop ()\n \t{\n \t  /* Then initialize the argument and number of keys read. */\n \t  _rl_reset_argument ();\n-\t  rl_key_sequence_length = 0;\n+\t  rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n \t}\n \n       RL_SETSTATE(RL_STATE_READCMD);\n@@ -519,7 +572,8 @@ readline_internal_charloop ()\n \n       /* look at input.c:rl_getc() for the circumstances under which this will\n \t be returned; punt immediately on read error without converting it to\n-\t a newline. */\n+\t a newline; assume that rl_read_key has already called the signal\n+\t handler. */\n       if (c == READERR)\n \t{\n #if defined (READLINE_CALLBACKS)\n@@ -531,13 +585,36 @@ readline_internal_charloop ()\n #endif\n \t}\n \n-      /* EOF typed to a non-blank line is a <NL>. */\n+      /* EOF typed to a non-blank line is ^D the first time, EOF the second\n+\t time in a row.  This won't return any partial line read from the tty.\n+\t If we want to change this, to force any existing line to be returned\n+\t when read(2) reads EOF, for example, this is the place to change. */\n       if (c == EOF && rl_end)\n-\tc = NEWLINE;\n+\t{\n+\t  if (RL_SIG_RECEIVED ())\n+\t    {\n+\t      RL_CHECK_SIGNALS ();\n+\t      if (rl_signal_event_hook)\n+\t\t(*rl_signal_event_hook) ();\t\t/* XXX */\n+\t    }\n+\n+\t  /* XXX - reading two consecutive EOFs returns EOF */\n+\t  if (RL_ISSTATE (RL_STATE_TERMPREPPED))\n+\t    {\n+\t      if (lastc == _rl_eof_char || lastc == EOF)\n+\t\trl_end = 0;\n+\t      else\n+\t        c = _rl_eof_char;\n+\t    }\n+\t  else\n+\t    c = NEWLINE;\n+\t}\n \n       /* The character _rl_eof_char typed to blank line, and not as the\n-\t previous character is interpreted as EOF. */\n-      if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)\n+\t previous character is interpreted as EOF.  This doesn't work when\n+\t READLINE_CALLBACKS is defined, so hitting a series of ^Ds will\n+\t erase all the chars on the line and then return EOF. */\n+      if (((c == _rl_eof_char && lastc != c) || c == EOF) && rl_end == 0)\n \t{\n #if defined (READLINE_CALLBACKS)\n \t  RL_SETSTATE(RL_STATE_DONE);\n@@ -694,7 +771,8 @@ _rl_dispatch_callback (cxt)\n     r = _rl_subseq_result (r, cxt->oldmap, cxt->okey, (cxt->flags & KSEQ_SUBSEQ));\n \n   RL_CHECK_SIGNALS ();\n-  if (r == 0)\t\t\t/* success! */\n+  /* We only treat values < 0 specially to simulate recursion. */\n+  if (r >= 0 || (r == -1 && (cxt->flags & KSEQ_SUBSEQ) == 0))\t/* success! or failure! */\n     {\n       _rl_keyseq_chain_dispose ();\n       RL_UNSETSTATE (RL_STATE_MULTIKEY);\n@@ -743,9 +821,10 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t{\n \t  if (RL_ISSTATE (RL_STATE_MACRODEF))\n \t    _rl_add_macro_char (ESC);\n+\t  RESIZE_KEYSEQ_BUFFER ();\n+\t  rl_executing_keyseq[rl_key_sequence_length++] = ESC;\n \t  map = FUNCTION_TO_KEYMAP (map, ESC);\n \t  key = UNMETA (key);\n-\t  rl_key_sequence_length += 2;\n \t  return (_rl_dispatch (key, map));\n \t}\n       else\n@@ -765,13 +844,19 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t{\n \t  /* Special case rl_do_lowercase_version (). */\n \t  if (func == rl_do_lowercase_version)\n-\t    return (_rl_dispatch (_rl_to_lower (key), map));\n+\t    /* Should we do anything special if key == ANYOTHERKEY? */\n+\t    return (_rl_dispatch (_rl_to_lower ((unsigned char)key), map));\n \n \t  rl_executing_keymap = map;\n+\t  rl_executing_key = key;\n+\n+\t  RESIZE_KEYSEQ_BUFFER();\n+\t  rl_executing_keyseq[rl_key_sequence_length++] = key;\n+\t  rl_executing_keyseq[rl_key_sequence_length] = '\\0';\n \n \t  rl_dispatching = 1;\n \t  RL_SETSTATE(RL_STATE_DISPATCHING);\n-\t  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);\n+\t  r = (*func) (rl_numeric_arg * rl_arg_sign, key);\n \t  RL_UNSETSTATE(RL_STATE_DISPATCHING);\n \t  rl_dispatching = 0;\n \n@@ -788,7 +873,10 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t  /* OK, there's no function bound in this map, but there is a\n \t     shadow function that was overridden when the current keymap\n \t     was created.  Return -2 to note  that. */\n-\t  _rl_unget_char  (key);\n+\t  if (RL_ISSTATE (RL_STATE_MACROINPUT))\n+\t    _rl_prev_macro_key ();\n+\t  else\n+\t    _rl_unget_char  (key);\n \t  return -2;\n \t}\n       else if (got_subseq)\n@@ -797,7 +885,10 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t     have a matching key, nor was one overridden.  This means\n \t     we need to back up the recursion chain and find the last\n \t     subsequence that is bound to a function. */\n-\t  _rl_unget_char (key);\n+\t  if (RL_ISSTATE (RL_STATE_MACROINPUT))\n+\t    _rl_prev_macro_key ();\n+\t  else\n+\t    _rl_unget_char (key);\n \t  return -1;\n \t}\n       else\n@@ -820,18 +911,34 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t     check whether there's input in the queue, which there generally\n \t     will be if an arrow key has been pressed, and, if there's not,\n \t     just dispatch to (what we assume is) rl_vi_movement_mode right\n-\t     away.  This is essentially an input test with a zero timeout. */\n-\t  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap\n-\t      && _rl_input_queued (0) == 0)\n+\t     away.  This is essentially an input test with a zero timeout (by\n+\t     default) or a timeout determined by the value of `keyseq-timeout' */\n+\t  /* _rl_keyseq_timeout specified in milliseconds; _rl_input_queued\n+\t     takes microseconds, so multiply by 1000 */\n+\t  if (rl_editing_mode == vi_mode && key == ESC && map == vi_insertion_keymap &&\n+\t      (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n+              _rl_pushed_input_available () == 0 &&\n+\t      _rl_input_queued ((_rl_keyseq_timeout > 0) ? _rl_keyseq_timeout*1000 : 0) == 0)\n \t    return (_rl_dispatch (ANYOTHERKEY, FUNCTION_TO_KEYMAP (map, key)));\n #endif\n \n-\t  rl_key_sequence_length++;\n+\t  RESIZE_KEYSEQ_BUFFER ();\n+\t  rl_executing_keyseq[rl_key_sequence_length++] = key;\n \t  _rl_dispatching_keymap = FUNCTION_TO_KEYMAP (map, key);\n \n \t  /* Allocate new context here.  Use linked contexts (linked through\n \t     cxt->ocxt) to simulate recursion */\n #if defined (READLINE_CALLBACKS)\n+#  if defined (VI_MODE)\n+\t  /* If we're redoing a vi mode command and we know there is a shadowed\n+\t     function corresponding to this key, just call it -- all the redoable\n+\t     vi mode commands already have all the input they need, and rl_vi_redo\n+\t     assumes that one call to rl_dispatch is sufficient to complete the\n+\t     command. */\n+\t  if (_rl_vi_redoing && RL_ISSTATE (RL_STATE_CALLBACK) &&\n+\t      map[ANYOTHERKEY].function != 0)\n+\t    return (_rl_subseq_result (-2, map, key, got_subseq));\n+#  endif\n \t  if (RL_ISSTATE (RL_STATE_CALLBACK))\n \t    {\n \t      /* Return 0 only the first time, to indicate success to\n@@ -855,6 +962,18 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t    }\n #endif\n \n+\t  /* Tentative inter-character timeout for potential multi-key\n+\t     sequences?  If no input within timeout, abort sequence and\n+\t     act as if we got non-matching input. */\n+\t  /* _rl_keyseq_timeout specified in milliseconds; _rl_input_queued\n+\t     takes microseconds, so multiply by 1000 */\n+\t  if (_rl_keyseq_timeout > 0 &&\n+\t  \t(RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n+\t  \t_rl_pushed_input_available () == 0 &&\n+\t\t_rl_dispatching_keymap[ANYOTHERKEY].function &&\n+\t\t_rl_input_queued (_rl_keyseq_timeout*1000) == 0)\n+\t    return (_rl_subseq_result (-2, map, key, got_subseq));\n+\n \t  newkey = _rl_subseq_getchar (key);\n \t  if (newkey < 0)\n \t    {\n@@ -867,23 +986,26 @@ _rl_dispatch_subseq (key, map, got_subseq)\n \t}\n       else\n \t{\n-\t  _rl_abort_internal ();\n+\t  _rl_abort_internal ();\t/* XXX */\n \t  return -1;\n \t}\n       break;\n \n     case ISMACR:\n       if (map[key].function != 0)\n \t{\n+\t  rl_executing_keyseq[rl_key_sequence_length] = '\\0';\n \t  macro = savestring ((char *)map[key].function);\n \t  _rl_with_macro_input (macro);\n \t  return 0;\n \t}\n       break;\n     }\n+\n #if defined (VI_MODE)\n   if (rl_editing_mode == vi_mode && _rl_keymap == vi_movement_keymap &&\n       key != ANYOTHERKEY &&\n+      _rl_dispatching_keymap == vi_movement_keymap &&\n       _rl_vi_textmod_command (key))\n     _rl_vi_set_last (key, rl_numeric_arg, rl_arg_sign);\n #endif\n@@ -912,37 +1034,48 @@ _rl_subseq_result (r, map, key, got_subseq)\n       type = m[ANYOTHERKEY].type;\n       func = m[ANYOTHERKEY].function;\n       if (type == ISFUNC && func == rl_do_lowercase_version)\n-\tr = _rl_dispatch (_rl_to_lower (key), map);\n-      else if (type == ISFUNC && func == rl_insert)\n+\tr = _rl_dispatch (_rl_to_lower ((unsigned char)key), map);\n+      else if (type == ISFUNC)\n \t{\n-\t  /* If the function that was shadowed was self-insert, we\n-\t     somehow need a keymap with map[key].func == self-insert.\n-\t     Let's use this one. */\n+\t  /* If we shadowed a function, whatever it is, we somehow need a\n+\t     keymap with map[key].func == shadowed-function.\n+\t     Let's use this one.  Then we can dispatch using the original\n+\t     key, since there are commands (e.g., in vi mode) for which it\n+\t     matters. */\n \t  nt = m[key].type;\n \t  nf = m[key].function;\n \n \t  m[key].type = type;\n \t  m[key].function = func;\n-\t  r = _rl_dispatch (key, m);\n+\t  /* Don't change _rl_dispatching_keymap, set it here */\n+\t  _rl_dispatching_keymap = map;\t\t/* previous map */\n+\t  r = _rl_dispatch_subseq (key, m, 0);\n \t  m[key].type = nt;\n \t  m[key].function = nf;\n \t}\n       else\n+\t/* We probably shadowed a keymap, so keep going. */\n \tr = _rl_dispatch (ANYOTHERKEY, m);\n     }\n-  else if (r && map[ANYOTHERKEY].function)\n+  else if (r < 0 && map[ANYOTHERKEY].function)\n     {\n       /* We didn't match (r is probably -1), so return something to\n \t tell the caller that it should try ANYOTHERKEY for an\n \t overridden function. */\n-      _rl_unget_char (key);\n+      if (RL_ISSTATE (RL_STATE_MACROINPUT))\n+\t_rl_prev_macro_key ();\n+      else\n+\t_rl_unget_char (key);\n       _rl_dispatching_keymap = map;\n       return -2;\n     }\n-  else if (r && got_subseq)\n+  else if (r < 0 && got_subseq)\t\t/* XXX */\n     {\n       /* OK, back up the chain. */\n-      _rl_unget_char (key);\n+      if (RL_ISSTATE (RL_STATE_MACROINPUT))\n+\t_rl_prev_macro_key ();\n+      else\n+\t_rl_unget_char (key);\n       _rl_dispatching_keymap = map;\n       return -1;\n     }\n@@ -971,7 +1104,7 @@ rl_initialize ()\n       RL_SETSTATE(RL_STATE_INITIALIZED);\n     }\n \n-  /* Initalize the current line information. */\n+  /* Initialize the current line information. */\n   _rl_init_line_state ();\n \n   /* We aren't done yet.  We haven't even gotten started yet! */\n@@ -1091,14 +1224,23 @@ readline_initialize_everything ()\n   /* Try to bind a common arrow key prefix, if not already bound. */\n   bind_arrow_keys ();\n \n-  /* Enable the meta key, if this terminal has one. */\n-  if (_rl_enable_meta)\n-    _rl_enable_meta_key ();\n+  /* Bind the bracketed paste prefix assuming that the user will enable\n+     it on terminals that support it. */\n+  bind_bracketed_paste_prefix ();\n \n   /* If the completion parser's default word break characters haven't\n      been set yet, then do so now. */\n   if (rl_completer_word_break_characters == (char *)NULL)\n     rl_completer_word_break_characters = (char *)rl_basic_word_break_characters;\n+\n+#if defined (COLOR_SUPPORT)\n+  if (_rl_colored_stats || _rl_colored_completion_prefix)\n+    _rl_parse_colors ();\n+#endif\n+\n+  rl_executing_keyseq = malloc (_rl_executing_keyseq_size = 16);\n+  if (rl_executing_keyseq)\n+    rl_executing_keyseq[0] = '\\0';\n }\n \n /* If this system allows us to look at the values of the regular\n@@ -1163,6 +1305,16 @@ bind_arrow_keys_internal (map)\n   rl_bind_keyseq_if_unbound (\"\\340O\", rl_end_of_line);\n   rl_bind_keyseq_if_unbound (\"\\340S\", rl_delete);\n   rl_bind_keyseq_if_unbound (\"\\340R\", rl_overwrite_mode);\n+\n+  /* These may or may not work because of the embedded NUL. */\n+  rl_bind_keyseq_if_unbound (\"\\\\000H\", rl_get_previous_history);\n+  rl_bind_keyseq_if_unbound (\"\\\\000P\", rl_get_next_history);\n+  rl_bind_keyseq_if_unbound (\"\\\\000M\", rl_forward_char);\n+  rl_bind_keyseq_if_unbound (\"\\\\000K\", rl_backward_char);\n+  rl_bind_keyseq_if_unbound (\"\\\\000G\", rl_beg_of_line);\n+  rl_bind_keyseq_if_unbound (\"\\\\000O\", rl_end_of_line);\n+  rl_bind_keyseq_if_unbound (\"\\\\000S\", rl_delete);\n+  rl_bind_keyseq_if_unbound (\"\\\\000R\", rl_overwrite_mode);\n #endif\n \n   _rl_keymap = xkeymap;\n@@ -1186,6 +1338,22 @@ bind_arrow_keys ()\n #endif\n }\n \n+static void\n+bind_bracketed_paste_prefix ()\n+{\n+  Keymap xkeymap;\n+\n+  xkeymap = _rl_keymap;\n+\n+  _rl_keymap = emacs_standard_keymap;\n+  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n+  \n+  _rl_keymap = vi_insertion_keymap;\n+  rl_bind_keyseq_if_unbound (BRACK_PASTE_PREF, rl_bracketed_paste_begin);\n+\n+  _rl_keymap = xkeymap;\n+}\n+  \n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\tSaving and Restoring Readline's state\t\t    */\n@@ -1214,6 +1382,7 @@ rl_save_state (sp)\n   sp->lastfunc = rl_last_func;\n   sp->insmode = rl_insert_mode;\n   sp->edmode = rl_editing_mode;\n+  sp->kseq = rl_executing_keyseq;\n   sp->kseqlen = rl_key_sequence_length;\n   sp->inf = rl_instream;\n   sp->outf = rl_outstream;\n@@ -1223,6 +1392,12 @@ rl_save_state (sp)\n   sp->catchsigs = rl_catch_signals;\n   sp->catchsigwinch = rl_catch_sigwinch;\n \n+  sp->entryfunc = rl_completion_entry_function;\n+  sp->menuentryfunc = rl_menu_completion_entry_function;\n+  sp->ignorefunc = rl_ignore_some_completions_function;\n+  sp->attemptfunc = rl_attempted_completion_function;\n+  sp->wordbreakchars = rl_completer_word_break_characters;\n+\n   return (0);\n }\n \n@@ -1248,6 +1423,7 @@ rl_restore_state (sp)\n   rl_last_func = sp->lastfunc;\n   rl_insert_mode = sp->insmode;\n   rl_editing_mode = sp->edmode;\n+  rl_executing_keyseq = sp->kseq;\n   rl_key_sequence_length = sp->kseqlen;\n   rl_instream = sp->inf;\n   rl_outstream = sp->outf;\n@@ -1257,5 +1433,11 @@ rl_restore_state (sp)\n   rl_catch_signals = sp->catchsigs;\n   rl_catch_sigwinch = sp->catchsigwinch;\n \n+  rl_completion_entry_function = sp->entryfunc;\n+  rl_menu_completion_entry_function = sp->menuentryfunc;\n+  rl_ignore_some_completions_function = sp->ignorefunc;\n+  rl_attempted_completion_function = sp->attemptfunc;\n+  rl_completer_word_break_characters = sp->wordbreakchars;\n+\n   return (0);\n }"
    },
    {
      "sha": "924bbfb0f213168ff970fbed612b5ca1e9caafb7",
      "filename": "readline/readline.h",
      "status": "modified",
      "additions": 67,
      "deletions": 11,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* Readline.h -- the names of functions callable from within readline. */\n \n-/* Copyright (C) 1987-2011 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -39,9 +39,9 @@ extern \"C\" {\n #endif\n \n /* Hex-encoded Readline version number. */\n-#define RL_READLINE_VERSION\t0x0602\t\t/* Readline 6.2 */\n-#define RL_VERSION_MAJOR\t6\n-#define RL_VERSION_MINOR\t2\n+#define RL_READLINE_VERSION\t0x0700\t\t/* Readline 7.0 */\n+#define RL_VERSION_MAJOR\t7\n+#define RL_VERSION_MINOR\t0\n \n /* Readline data structures. */\n \n@@ -172,8 +172,9 @@ extern int rl_yank PARAMS((int, int));\n extern int rl_yank_pop PARAMS((int, int));\n extern int rl_yank_nth_arg PARAMS((int, int));\n extern int rl_yank_last_arg PARAMS((int, int));\n+extern int rl_bracketed_paste_begin PARAMS((int, int));\n /* Not available unless _WIN32 is defined. */\n-#ifdef _WIN32\n+#if defined (_WIN32)\n extern int rl_paste_from_clipboard PARAMS((int, int));\n #endif\n \n@@ -185,6 +186,7 @@ extern int rl_forward_search_history PARAMS((int, int));\n extern int rl_start_kbd_macro PARAMS((int, int));\n extern int rl_end_kbd_macro PARAMS((int, int));\n extern int rl_call_last_kbd_macro PARAMS((int, int));\n+extern int rl_print_last_kbd_macro PARAMS((int, int));\n \n /* Bindable undo commands. */\n extern int rl_revert_line PARAMS((int, int));\n@@ -204,6 +206,8 @@ extern int rl_tty_status PARAMS((int, int));\n /* Bindable commands for incremental and non-incremental history searching. */\n extern int rl_history_search_forward PARAMS((int, int));\n extern int rl_history_search_backward PARAMS((int, int));\n+extern int rl_history_substr_search_forward PARAMS((int, int));\n+extern int rl_history_substr_search_backward PARAMS((int, int));\n extern int rl_noninc_forward_search PARAMS((int, int));\n extern int rl_noninc_reverse_search PARAMS((int, int));\n extern int rl_noninc_forward_search_again PARAMS((int, int));\n@@ -216,6 +220,7 @@ extern int rl_insert_close PARAMS((int, int));\n extern void rl_callback_handler_install PARAMS((const char *, rl_vcpfunc_t *));\n extern void rl_callback_read_char PARAMS((void));\n extern void rl_callback_handler_remove PARAMS((void));\n+extern void rl_callback_sigcleanup PARAMS((void));\n \n /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */\n /* VI-mode bindable commands. */\n@@ -244,9 +249,11 @@ extern int rl_vi_column PARAMS((int, int));\n extern int rl_vi_delete_to PARAMS((int, int));\n extern int rl_vi_change_to PARAMS((int, int));\n extern int rl_vi_yank_to PARAMS((int, int));\n+extern int rl_vi_yank_pop PARAMS((int, int));\n extern int rl_vi_rubout PARAMS((int, int));\n extern int rl_vi_delete PARAMS((int, int));\n extern int rl_vi_back_to_indent PARAMS((int, int));\n+extern int rl_vi_unix_word_rubout PARAMS((int, int));\n extern int rl_vi_first_print PARAMS((int, int));\n extern int rl_vi_char_search PARAMS((int, int));\n extern int rl_vi_match PARAMS((int, int));\n@@ -339,6 +346,7 @@ extern Keymap rl_make_bare_keymap PARAMS((void));\n extern Keymap rl_copy_keymap PARAMS((Keymap));\n extern Keymap rl_make_keymap PARAMS((void));\n extern void rl_discard_keymap PARAMS((Keymap));\n+extern void rl_free_keymap PARAMS((Keymap));\n \n extern Keymap rl_get_keymap_by_name PARAMS((const char *));\n extern char *rl_get_keymap_name PARAMS((Keymap));\n@@ -371,6 +379,7 @@ extern void rl_redisplay PARAMS((void));\n extern int rl_on_new_line PARAMS((void));\n extern int rl_on_new_line_with_prompt PARAMS((void));\n extern int rl_forced_update_display PARAMS((void));\n+extern int rl_clear_visible_line PARAMS((void));\n extern int rl_clear_message PARAMS((void));\n extern int rl_reset_line_state PARAMS((void));\n extern int rl_crlf PARAMS((void));\n@@ -385,6 +394,7 @@ extern int rl_show_char PARAMS((int));\n \n /* Undocumented in texinfo manual. */\n extern int rl_character_len PARAMS((int, int));\n+extern void rl_redraw_prompt_last_line PARAMS((void));\n \n /* Save and restore internal prompt redisplay information. */\n extern void rl_save_prompt PARAMS((void));\n@@ -432,10 +442,16 @@ extern void rl_cleanup_after_signal PARAMS((void));\n extern void rl_reset_after_signal PARAMS((void));\n extern void rl_free_line_state PARAMS((void));\n \n+extern int rl_pending_signal PARAMS((void));\n+\n extern void rl_echo_signal_char PARAMS((int)); \n \n extern int rl_set_paren_blink_timeout PARAMS((int));\n \n+/* History management functions. */\n+\n+extern void rl_clear_history PARAMS((void));\n+\n /* Undocumented. */\n extern int rl_maybe_save_line PARAMS((void));\n extern int rl_maybe_unsave_line PARAMS((void));\n@@ -481,7 +497,7 @@ extern int rl_readline_version;\t\t\t/* e.g., 0x0402 */\n extern int rl_gnu_readline_p;\n \n /* Flags word encapsulating the current readline state. */\n-extern int rl_readline_state;\n+extern unsigned long rl_readline_state;\n \n /* Says which editing mode readline is currently using.  1 means emacs mode;\n    0 means vi mode. */\n@@ -560,6 +576,13 @@ extern rl_hook_func_t *rl_pre_input_hook;\n    awaiting character input, or NULL, for no event handling. */\n extern rl_hook_func_t *rl_event_hook;\n \n+/* The address of a function to call if a read is interrupted by a signal. */\n+extern rl_hook_func_t *rl_signal_event_hook;\n+\n+/* The address of a function to call if Readline needs to know whether or not\n+   there is data available from the current input source. */\n+extern rl_hook_func_t *rl_input_available_hook;\n+\n /* The address of the function to call to fetch a character from the current\n    Readline input stream */\n extern rl_getc_func_t *rl_getc_function;\n@@ -573,6 +596,10 @@ extern rl_voidfunc_t *rl_deprep_term_function;\n extern Keymap rl_executing_keymap;\n extern Keymap rl_binding_keymap;\n \n+extern int rl_executing_key;\n+extern char *rl_executing_keyseq;\n+extern int rl_key_sequence_length;\n+\n /* Display variables. */\n /* If non-zero, readline will erase the entire line, including any prompt,\n    if the only thing typed on an otherwise-blank line is something bound to\n@@ -603,6 +630,10 @@ extern int rl_catch_signals;\n    to do that. */\n extern int rl_catch_sigwinch;\n \n+/* If non-zero, the readline SIGWINCH handler will modify LINES and\n+   COLUMNS in the environment. */\n+extern int rl_change_environment;\n+\n /* Completion variables. */\n /* Pointer to the generator function for completion_matches ().\n    NULL means to use rl_filename_completion_function (), the default\n@@ -611,7 +642,7 @@ extern rl_compentry_func_t *rl_completion_entry_function;\n \n /* Optional generator for menu completion.  Default is\n    rl_completion_entry_function (rl_filename_completion_function). */\n- extern rl_compentry_func_t *rl_menu_completion_entry_function;\n+extern rl_compentry_func_t *rl_menu_completion_entry_function;\n \n /* If rl_ignore_some_completions_function is non-NULL it is the address\n    of a function to call after all of the possible matches have been\n@@ -686,6 +717,13 @@ extern rl_icppfunc_t *rl_directory_completion_hook;\n    it in bash to see how well it goes. */\n extern rl_icppfunc_t *rl_directory_rewrite_hook;\n \n+/* If non-zero, this is the address of a function for the completer to call\n+   before deciding which character to append to a completed name.  It should\n+   modify the directory name passed as an argument if appropriate, and return\n+   non-zero if it modifies the name.  This should not worry about dequoting\n+   the filename; that has already happened by the time it gets here. */\n+extern rl_icppfunc_t *rl_filename_stat_hook;\n+\n /* If non-zero, this is the address of a function to call when reading\n    directory entries from the filesystem for completion and comparing\n    them to the partial word to be completed.  The function should\n@@ -796,6 +834,14 @@ extern int rl_ignore_completion_duplicates;\n    completion character will be inserted as any other. */\n extern int rl_inhibit_completion;\n \n+/* Applications can set this to non-zero to have readline's signal handlers\n+   installed during the entire duration of reading a complete line, as in\n+   readline-6.2.  This should be used with care, because it can result in\n+   readline receiving signals and not handling them until it's called again\n+   via rl_callback_read_char, thereby stealing them from the application.\n+   By default, signal handlers are only active while readline is active. */   \n+extern int rl_persistent_signal_handlers;\n+\n /* Input error; can be returned by (*rl_getc_function) if readline is reading\n    a top-level command (RL_ISSTATE (RL_STATE_READCMD)). */\n #define READERR\t\t\t(-2)\n@@ -836,9 +882,10 @@ extern int rl_inhibit_completion;\n #define RL_STATE_VIMOTION\t0x0100000\t/* reading vi motion arg */\n #define RL_STATE_MULTIKEY\t0x0200000\t/* reading multiple-key command */\n #define RL_STATE_VICMDONCE\t0x0400000\t/* entered vi command mode at least once */\n-#define RL_STATE_REDISPLAYING\t0x0800000\t/* updating terminal display */\n+#define RL_STATE_CHARSEARCH\t0x0800000\t/* vi mode char search */\n+#define RL_STATE_REDISPLAYING\t0x1000000\t/* updating terminal display */\n \n-#define RL_STATE_DONE\t\t0x1000000\t/* done; accepted line */\n+#define RL_STATE_DONE\t\t0x2000000\t/* done; accepted line */\n \n #define RL_SETSTATE(x)\t\t(rl_readline_state |= (x))\n #define RL_UNSETSTATE(x)\t(rl_readline_state &= ~(x))\n@@ -849,8 +896,8 @@ struct readline_state {\n   int point;\n   int end;\n   int mark;\n-  char *buffer;\n   int buflen;\n+  char *buffer;\n   UNDO_LIST *ul;\n   char *prompt;\n \n@@ -863,10 +910,12 @@ struct readline_state {\n   rl_command_func_t *lastfunc;\n   int insmode;\n   int edmode;\n+  char *kseq;\n   int kseqlen;\n+\n+  int pendingin;\n   FILE *inf;\n   FILE *outf;\n-  int pendingin;\n   char *macro;\n \n   /* signal state */\n@@ -876,9 +925,16 @@ struct readline_state {\n   /* search state */\n \n   /* completion state */\n+  rl_compentry_func_t *entryfunc;\n+  rl_compentry_func_t *menuentryfunc;\n+  rl_compignore_func_t *ignorefunc;\n+  rl_completion_func_t *attemptfunc;\n+  char *wordbreakchars;\n \n   /* options state */\n \n+  /* hook state */\n+  \n   /* reserved for future expansion, so the struct size doesn't change */\n   char reserved[64];\n };"
    },
    {
      "sha": "fbfca8acbe8fa9612b0bdf10383c781f1407c298",
      "filename": "readline/readline.pc.in",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.pc.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/readline.pc.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/readline.pc.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -0,0 +1,12 @@\n+prefix=@prefix@\n+exec_prefix=@exec_prefix@\n+libdir=@libdir@\n+includedir=@includedir@\n+\n+Name: Readline\n+Description: Gnu Readline library for command line editing\n+URL: http://tiswww.cwru.edu/php/chet/readline/rltop.html\n+Version: @LIBVERSION@\n+Requires.private: tinfo\n+Libs: -L${libdir} -lreadline\n+Cflags: -I${includedir}/readline"
    },
    {
      "sha": "98c970aab409b4def05ec82ea452aad2054fe5cc",
      "filename": "readline/rlconf.h",
      "status": "modified",
      "additions": 20,
      "deletions": 2,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlconf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlconf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlconf.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* rlconf.h -- readline configuration definitions */\n \n-/* Copyright (C) 1992-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1992-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -28,8 +28,12 @@\n /* Define this to get an indication of file type when listing completions. */\n #define VISIBLE_STATS\n \n+/* Define this to get support for colors when listing completions and in\n+   other places. */\n+#define COLOR_SUPPORT\n+\n /* This definition is needed by readline.c, rltty.c, and signals.c. */\n-/* If on, then readline handles signals in a way that doesn't screw. */\n+/* If on, then readline handles signals in a way that doesn't suck. */\n #define HANDLE_SIGNALS\n \n /* Ugly but working hack for binding prefix meta. */\n@@ -58,4 +62,18 @@\n /* Define this if you want the cursor to indicate insert or overwrite mode. */\n /* #define CURSOR_MODE */\n \n+/* Define this if you want to enable code that talks to the Linux kernel\n+   tty auditing system. */\n+/* #define ENABLE_TTY_AUDIT_SUPPORT */\n+\n+/* Defaults for the various editing mode indicators, inserted at the beginning\n+   of the last (maybe only) line of the prompt if show-mode-in-prompt is on */\n+#define RL_EMACS_MODESTR_DEFAULT\t\"@\"\n+#define RL_EMACS_MODESTR_DEFLEN\t\t1\n+\n+#define RL_VI_INS_MODESTR_DEFAULT\t\"(ins)\"\n+#define RL_VI_INS_MODESTR_DEFLEN\t5\n+#define RL_VI_CMD_MODESTR_DEFAULT\t\"(cmd)\"\n+#define RL_VI_CMD_MODESTR_DEFLEN\t5\n+\n #endif /* _RLCONF_H_ */"
    },
    {
      "sha": "dab1beba1d72fbc6288f361b8c59fe2e3c78582e",
      "filename": "readline/rldefs.h",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rldefs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rldefs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rldefs.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,7 +2,7 @@\n    for readline.  This should be included after any files that define\n    system-specific constants like _POSIX_VERSION or USG. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2011 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -79,8 +79,8 @@ extern char *strchr (), *strrchr ();\n #define _rl_stricmp strcasecmp\n #define _rl_strnicmp strncasecmp\n #else\n-extern int _rl_stricmp PARAMS((char *, char *));\n-extern int _rl_strnicmp PARAMS((char *, char *, int));\n+extern int _rl_stricmp PARAMS((const char *, const char *));\n+extern int _rl_strnicmp PARAMS((const char *, const char *, int));\n #endif\n \n #if defined (HAVE_STRPBRK) && !defined (HAVE_MULTIBYTE)\n@@ -148,6 +148,10 @@ extern char *_rl_strpbrk PARAMS((const char *, const char *));\n \t\t\t\t    : ((a)[0] == (b)[0]) && (strncmp ((a), (b), (n)) == 0))\n #endif\n \n+#if !defined (RL_STRLEN)\n+#  define RL_STRLEN(s) (((s) && (s)[0]) ? ((s)[1] ? ((s)[2] ? strlen(s) : 2) : 1) : 0)\n+#endif\n+\n #if !defined (FREE)\n #  define FREE(x)\tif (x) free (x)\n #endif"
    },
    {
      "sha": "4748a610b0b749e44606922bac4ad7bc7fb4e69a",
      "filename": "readline/rlmbutil.h",
      "status": "modified",
      "additions": 50,
      "deletions": 1,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlmbutil.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlmbutil.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlmbutil.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* rlmbutil.h -- utility functions for multibyte characters. */\n \n-/* Copyright (C) 2001-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2001-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -123,6 +123,55 @@ extern int _rl_walphabetic PARAMS((wchar_t));\n #define MB_INVALIDCH(x)\t\t((x) == (size_t)-1 || (x) == (size_t)-2)\n #define MB_NULLWCH(x)\t\t((x) == 0)\n \n+/* Try and shortcut the printable ascii characters to cut down the number of\n+   calls to a libc wcwidth() */\n+static inline int\n+_rl_wcwidth (wc)\n+     wchar_t wc;\n+{\n+  switch (wc)\n+    {\n+    case ' ': case '!': case '\"': case '#': case '%':\n+    case '&': case '\\'': case '(': case ')': case '*':\n+    case '+': case ',': case '-': case '.': case '/':\n+    case '0': case '1': case '2': case '3': case '4':\n+    case '5': case '6': case '7': case '8': case '9':\n+    case ':': case ';': case '<': case '=': case '>':\n+    case '?':\n+    case 'A': case 'B': case 'C': case 'D': case 'E':\n+    case 'F': case 'G': case 'H': case 'I': case 'J':\n+    case 'K': case 'L': case 'M': case 'N': case 'O':\n+    case 'P': case 'Q': case 'R': case 'S': case 'T':\n+    case 'U': case 'V': case 'W': case 'X': case 'Y':\n+    case 'Z':\n+    case '[': case '\\\\': case ']': case '^': case '_':\n+    case 'a': case 'b': case 'c': case 'd': case 'e':\n+    case 'f': case 'g': case 'h': case 'i': case 'j':\n+    case 'k': case 'l': case 'm': case 'n': case 'o':\n+    case 'p': case 'q': case 'r': case 's': case 't':\n+    case 'u': case 'v': case 'w': case 'x': case 'y':\n+    case 'z': case '{': case '|': case '}': case '~':\n+      return 1;\n+    default:\n+      return wcwidth (wc);\n+    }\n+}\n+\n+/* Unicode combining characters range from U+0300 to U+036F */\n+#define UNICODE_COMBINING_CHAR(x) ((x) >= 768 && (x) <= 879)\n+\n+#if defined (WCWIDTH_BROKEN)\n+#  define WCWIDTH(wc)\t((_rl_utf8locale && UNICODE_COMBINING_CHAR(wc)) ? 0 : _rl_wcwidth(wc))\n+#else\n+#  define WCWIDTH(wc)\t_rl_wcwidth(wc)\n+#endif\n+\n+#if defined (WCWIDTH_BROKEN)\n+#  define IS_COMBINING_CHAR(x)\t(WCWIDTH(x) == 0 && iswcntrl(x) == 0)\n+#else\n+#  define IS_COMBINING_CHAR(x)\t(WCWIDTH(x) == 0)\n+#endif\n+\n #else /* !HANDLE_MULTIBYTE */\n \n #undef MB_LEN_MAX"
    },
    {
      "sha": "fc3856a1b840c4d562d24f0e99e4df51e80271af",
      "filename": "readline/rlprivate.h",
      "status": "modified",
      "additions": 63,
      "deletions": 5,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlprivate.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlprivate.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlprivate.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n /* rlprivate.h -- functions and variables global to the readline library,\n \t\t  but not intended for use by applications. */\n \n-/* Copyright (C) 1999-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1999-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -42,6 +42,13 @@\n \t  if (_rl_caught_signal) _rl_signal_handler (_rl_caught_signal); \\\n \t} while (0)\n \n+#define RL_SIG_RECEIVED() (_rl_caught_signal != 0)\n+#define RL_SIGINT_RECEIVED() (_rl_caught_signal == SIGINT)\n+#define RL_SIGWINCH_RECEIVED() (_rl_caught_signal == SIGWINCH)\n+\n+#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)\n+#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)\n+\n /*************************************************************************\n  *\t\t\t\t\t\t\t\t\t *\n  * Global structs undocumented in texinfo manual and not in readline.h   *\n@@ -86,9 +93,11 @@ typedef struct  __rl_search_context\n   int history_pos;\n   int direction;\n \n+  int prevc;\n   int lastc;\n #if defined (HANDLE_MULTIBYTE)\n   char mb[MB_LEN_MAX];\n+  char pmb[MB_LEN_MAX];\n #endif\n \n   char *sline;\n@@ -116,10 +125,11 @@ typedef struct __rl_keyseq_context\n   int flags;\n   int subseq_arg;\n   int subseq_retval;\t\t/* XXX */\n-  Keymap dmap;\n+  int okey;\n \n+  Keymap dmap;\n   Keymap oldmap;\n-  int okey;\n+\n   struct __rl_keyseq_context *ocxt;\n   int childval;\n } _rl_keyseq_cxt;\n@@ -156,6 +166,8 @@ typedef struct __rl_callback_generic_arg\n \n typedef int _rl_callback_func_t PARAMS((_rl_callback_generic_arg *));\n \n+typedef void _rl_sigcleanup_func_t PARAMS((int, void *));\n+\n /*************************************************************************\n  *\t\t\t\t\t\t\t\t\t *\n  * Global functions undocumented in texinfo manual and not in readline.h *\n@@ -173,12 +185,15 @@ extern int rl_complete_with_tilde_expansion;\n #if defined (VISIBLE_STATS)\n extern int rl_visible_stats;\n #endif /* VISIBLE_STATS */\n+#if defined (COLOR_SUPPORT)\n+extern int _rl_colored_stats;\n+extern int _rl_colored_completion_prefix;\n+#endif\n \n /* readline.c */\n extern int rl_line_buffer_len;\n extern int rl_arg_sign;\n extern int rl_visible_prompt_length;\n-extern int rl_key_sequence_length;\n extern int rl_byte_oriented;\n \n /* display.c */\n@@ -189,7 +204,7 @@ extern int rl_blink_matching_paren;\n \n /*************************************************************************\n  *\t\t\t\t\t\t\t\t\t *\n- * Global functions and variables unsed and undocumented\t\t *\n+ * Global functions and variables unused and undocumented\t\t *\n  *\t\t\t\t\t\t\t\t\t *\n  *************************************************************************/\n \n@@ -240,6 +255,7 @@ extern void _rl_callback_data_dispose PARAMS((_rl_callback_generic_arg *));\n #endif /* READLINE_CALLBACKS */\n \n /* bind.c */\n+extern char *_rl_untranslate_macro_value PARAMS((char *, int));\n \n /* complete.c */\n extern void _rl_reset_completion_state PARAMS((void));\n@@ -248,6 +264,7 @@ extern void _rl_free_match_list PARAMS((char **));\n \n /* display.c */\n extern char *_rl_strip_prompt PARAMS((char *));\n+extern void _rl_reset_prompt PARAMS((void));\n extern void _rl_move_cursor_relative PARAMS((int, const char *));\n extern void _rl_move_vert PARAMS((int));\n extern void _rl_save_prompt PARAMS((void));\n@@ -276,12 +293,24 @@ extern void _rl_scxt_dispose PARAMS((_rl_search_cxt *, int));\n \n extern int _rl_isearch_dispatch PARAMS((_rl_search_cxt *, int));\n extern int _rl_isearch_callback PARAMS((_rl_search_cxt *));\n+extern int _rl_isearch_cleanup PARAMS((_rl_search_cxt *, int));\n \n extern int _rl_search_getchar PARAMS((_rl_search_cxt *));\n \n+/* kill.c */\n+#define BRACK_PASTE_PREF\t\"\\033[200~\"\n+#define BRACK_PASTE_SUFF\t\"\\033[201~\"\n+\n+#define BRACK_PASTE_LAST\t'~'\n+#define BRACK_PASTE_SLEN\t6\n+\n+#define BRACK_PASTE_INIT\t\"\\033[?2004h\"\n+#define BRACK_PASTE_FINI\t\"\\033[?2004l\"\n+\n /* macro.c */\n extern void _rl_with_macro_input PARAMS((char *));\n extern int _rl_next_macro_key PARAMS((void));\n+extern int _rl_prev_macro_key PARAMS((void));\n extern void _rl_push_executing_macro PARAMS((void));\n extern void _rl_pop_executing_macro PARAMS((void));\n extern void _rl_add_macro_char PARAMS((int));\n@@ -319,6 +348,7 @@ extern int _rl_restore_tty_signals PARAMS((void));\n \n /* search.c */\n extern int _rl_nsearch_callback PARAMS((_rl_search_cxt *));\n+extern int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));\n \n /* signals.c */\n extern void _rl_signal_handler PARAMS((int));\n@@ -330,6 +360,7 @@ extern void _rl_release_sigwinch PARAMS((void));\n \n /* terminal.c */\n extern void _rl_get_screen_size PARAMS((int, int));\n+extern void _rl_sigwinch_resize_terminal PARAMS((void));\n extern int _rl_init_terminal_io PARAMS((const char *));\n #ifdef _MINIX\n extern void _rl_output_character_function PARAMS((int));\n@@ -339,6 +370,7 @@ extern int _rl_output_character_function PARAMS((int));\n extern void _rl_output_some_chars PARAMS((const char *, int));\n extern int _rl_backspace PARAMS((int));\n extern void _rl_enable_meta_key PARAMS((void));\n+extern void _rl_disable_meta_key PARAMS((void));\n extern void _rl_control_keypad PARAMS((int));\n extern void _rl_set_cursor PARAMS((int, int));\n \n@@ -360,6 +392,7 @@ extern int _rl_set_mark_at_pos PARAMS((int));\n /* undo.c */\n extern UNDO_LIST *_rl_copy_undo_entry PARAMS((UNDO_LIST *));\n extern UNDO_LIST *_rl_copy_undo_list PARAMS((UNDO_LIST *));\n+extern void _rl_free_undo_list PARAMS((UNDO_LIST *));\n \n /* util.c */\n #if defined (USE_VARARGS) && defined (PREFER_STDARG)\n@@ -371,6 +404,7 @@ extern void _rl_ttymsg ();\n extern void _rl_errmsg ();\n extern void _rl_trace ();\n #endif\n+extern void _rl_audit_tty PARAMS((char *));\n \n extern int _rl_tropen PARAMS((void));\n \n@@ -391,8 +425,10 @@ extern void _rl_vi_initialize_line PARAMS((void));\n extern void _rl_vi_reset_last PARAMS((void));\n extern void _rl_vi_set_last PARAMS((int, int, int));\n extern int _rl_vi_textmod_command PARAMS((int));\n+extern int _rl_vi_motion_command PARAMS((int));\n extern void _rl_vi_done_inserting PARAMS((void));\n extern int _rl_vi_domove_callback PARAMS((_rl_vimotion_cxt *));\n+extern int _rl_vi_domove_motion_cleanup PARAMS((int, _rl_vimotion_cxt *));\n \n /*************************************************************************\n  * Undocumented private variables\t\t\t\t\t *\n@@ -427,6 +463,13 @@ extern int _rl_last_c_pos;\n extern int _rl_suppress_redisplay;\n extern int _rl_want_redisplay;\n \n+extern char *_rl_emacs_mode_str;\n+extern int _rl_emacs_modestr_len;\n+extern char *_rl_vi_ins_mode_str;\n+extern int _rl_vi_ins_modestr_len;\n+extern char *_rl_vi_cmd_mode_str;\n+extern int _rl_vi_cmd_modestr_len;\n+\n /* isearch.c */\n extern char *_rl_isearch_terminators;\n \n@@ -441,6 +484,9 @@ extern int _rl_history_saved_point;\n \n extern _rl_arg_cxt _rl_argcxt;\n \n+/* nls.c */\n+extern int _rl_utf8locale;\n+\n /* readline.c */\n extern int _rl_echoing_p;\n extern int _rl_horizontal_scroll_mode;\n@@ -452,6 +498,8 @@ extern int _rl_output_meta_chars;\n extern int _rl_bind_stty_chars;\n extern int _rl_revert_all_at_newline;\n extern int _rl_echo_control_chars;\n+extern int _rl_show_mode_in_prompt;\n+extern int _rl_enable_bracketed_paste;\n extern char *_rl_comment_begin;\n extern unsigned char _rl_parsing_conditionalized_out;\n extern Keymap _rl_keymap;\n@@ -461,6 +509,9 @@ extern int _rl_last_command_was_kill;\n extern int _rl_eof_char;\n extern procenv_t _rl_top_level;\n extern _rl_keyseq_cxt *_rl_kscxt;\n+extern int _rl_keyseq_timeout;\n+\n+extern int _rl_executing_keyseq_size;\n \n /* search.c */\n extern _rl_search_cxt *_rl_nscxt;\n@@ -469,6 +520,9 @@ extern _rl_search_cxt *_rl_nscxt;\n extern int _rl_interrupt_immediately;\n extern int volatile _rl_caught_signal;\n \n+extern _rl_sigcleanup_func_t *_rl_sigcleanup;\n+extern void *_rl_sigcleanarg;\n+\n extern int _rl_echoctl;\n \n extern int _rl_intr_char;\n@@ -495,12 +549,16 @@ extern int _rl_screenchars;\n extern int _rl_terminal_can_insert;\n extern int _rl_term_autowrap;\n \n+/* text.c */\n+extern int _rl_optimize_typeahead;\n+\n /* undo.c */\n extern int _rl_doing_an_undo;\n extern int _rl_undo_group_level;\n \n /* vi_mode.c */\n extern int _rl_vi_last_command;\n+extern int _rl_vi_redoing;\n extern _rl_vimotion_cxt *_rl_vimvcxt;\n \n #endif /* _RL_PRIVATE_H_ */"
    },
    {
      "sha": "2aaa30babfbdd7e86eed5062b7324e819d5f68e8",
      "filename": "readline/rlstdc.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlstdc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rlstdc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rlstdc.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -42,4 +42,16 @@\n #  endif\n #endif\n \n+/* Moved from config.h.in because readline.h:rl_message depends on these\n+   defines. */\n+#if defined (__STDC__) && defined (HAVE_STDARG_H)\n+#  define PREFER_STDARG\n+#  define USE_VARARGS\n+#else\n+#  if defined (HAVE_VARARGS_H)\n+#    define PREFER_VARARGS\n+#    define USE_VARARGS\n+#  endif\n+#endif\n+\n #endif /* !_RL_STDC_H_ */"
    },
    {
      "sha": "b1c79294186f55667fce393b46d54c5892d44743",
      "filename": "readline/rltty.c",
      "status": "modified",
      "additions": 51,
      "deletions": 16,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rltty.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rltty.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rltty.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,10 +1,10 @@\n /* rltty.c -- functions to prepare and restore the terminal for readline's\n    use. */\n \n-/* Copyright (C) 1992-2005 Free Software Foundation, Inc.\n+/* Copyright (C) 1992-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n-   for reading lines of text with interactive input and history editing.      \n+   for reading lines of text with interactive input and history editing.\n \n    Readline is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -37,11 +37,11 @@\n \n #include \"rldefs.h\"\n \n-#if defined (GWINSZ_IN_SYS_IOCTL)\n-#  include <sys/ioctl.h>\n-#endif /* GWINSZ_IN_SYS_IOCTL */\n-\n #include \"rltty.h\"\n+#if defined (HAVE_SYS_IOCTL_H)\n+#  include <sys/ioctl.h>\t\t/* include for declaration of ioctl */\n+#endif\n+\n #include \"readline.h\"\n #include \"rlprivate.h\"\n \n@@ -60,7 +60,13 @@ static void set_winsize PARAMS((int));\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n-/* Non-zero means that the terminal is in a prepped state. */\n+/* Non-zero means that the terminal is in a prepped state.  There are several\n+   flags that are OR'd in to denote whether or not we have sent various\n+   init strings to the terminal. */\n+#define TPX_PREPPED\t0x01\n+#define TPX_BRACKPASTE\t0x02\n+#define TPX_METAKEY\t0x04\n+\n static int terminal_prepped;\n \n static _RL_TTY_CHARS _rl_tty_chars, _rl_last_tty_chars;\n@@ -121,7 +127,7 @@ static int set_tty_settings PARAMS((int, TIOTYPE *));\n \n static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));\n \n-static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));\n+static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t *));\n \n static void\n save_tty_chars (tiop)\n@@ -341,7 +347,7 @@ static int set_tty_settings PARAMS((int, TIOTYPE *));\n \n static void prepare_terminal_settings PARAMS((int, TIOTYPE, TIOTYPE *));\n \n-static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t));\n+static void set_special_char PARAMS((Keymap, TIOTYPE *, int, rl_command_func_t *));\n static void _rl_bind_tty_special_chars PARAMS((Keymap, TIOTYPE));\n \n #if defined (FLUSHO)\n@@ -528,10 +534,10 @@ prepare_terminal_settings (meta_flag, oldtio, tiop)\n \n #if defined (USE_XON_XOFF)\n #if defined (IXANY)\n-  tiop->c_iflag &= ~(IXON | IXOFF | IXANY);\n+  tiop->c_iflag &= ~(IXON | IXANY);\n #else\n   /* `strict' Posix systems do not define IXANY. */\n-  tiop->c_iflag &= ~(IXON | IXOFF);\n+  tiop->c_iflag &= ~IXON;\n #endif /* IXANY */\n #endif /* USE_XON_XOFF */\n \n@@ -595,7 +601,7 @@ void\n rl_prep_terminal (meta_flag)\n      int meta_flag;\n {\n-  int tty;\n+  int tty, nprep;\n   TIOTYPE tio;\n \n   if (terminal_prepped)\n@@ -642,7 +648,7 @@ rl_prep_terminal (meta_flag)\n       /* If editing in vi mode, make sure we set the bindings in the\n \t insertion keymap no matter what keymap we ended up in. */\n       if (rl_editing_mode == vi_mode)\n-\t_rl_bind_tty_special_chars (vi_insertion_keymap, tio);\t\n+\t_rl_bind_tty_special_chars (vi_insertion_keymap, tio);\n       else\n #endif\n \t_rl_bind_tty_special_chars (_rl_keymap, tio);\n@@ -659,8 +665,16 @@ rl_prep_terminal (meta_flag)\n   if (_rl_enable_keypad)\n     _rl_control_keypad (1);\n \n+  nprep = TPX_PREPPED;\n+\n+  if (_rl_enable_bracketed_paste)\n+    {\n+      fprintf (rl_outstream, BRACK_PASTE_INIT);\n+      nprep |= TPX_BRACKPASTE;\n+    }\n+\n   fflush (rl_outstream);\n-  terminal_prepped = 1;\n+  terminal_prepped = nprep;\n   RL_SETSTATE(RL_STATE_TERMPREPPED);\n \n   _rl_release_sigint ();\n@@ -672,13 +686,16 @@ rl_deprep_terminal ()\n {\n   int tty;\n \n-  if (!terminal_prepped)\n+  if (terminal_prepped == 0)\n     return;\n \n   /* Try to keep this function from being interrupted. */\n   _rl_block_sigint ();\n \n-  tty = rl_instream ? fileno (rl_instream) : fileno (stdout);\n+  tty = rl_instream ? fileno (rl_instream) : fileno (stdin);\n+\n+  if (terminal_prepped & TPX_BRACKPASTE)\n+    fprintf (rl_outstream, BRACK_PASTE_FINI);\n \n   if (_rl_enable_keypad)\n     _rl_control_keypad (0);\n@@ -697,6 +714,19 @@ rl_deprep_terminal ()\n   _rl_release_sigint ();\n }\n #endif /* !NO_TTY_DRIVER */\n+\n+/* Set readline's idea of whether or not it is echoing output to the terminal,\n+   returning the old value. */\n+int\n+rl_tty_set_echoing (u)\n+     int u;\n+{\n+  int o;\n+\n+  o = _rl_echoing_p;\n+  _rl_echoing_p = u;\n+  return o;\n+}\n \f\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n@@ -859,6 +889,11 @@ _rl_bind_tty_special_chars (kmap, ttybuff)\n #  endif /* VLNEXT && TERMIOS_TTY_DRIVER */\n \n #  if defined (VWERASE) && defined (TERMIOS_TTY_DRIVER)\n+#    if defined (VI_MODE)\n+  if (rl_editing_mode == vi_mode)\n+    SET_SPECIAL (VWERASE, rl_vi_unix_word_rubout);\n+  else\n+#    endif\n   SET_SPECIAL (VWERASE, rl_unix_word_rubout);\n #  endif /* VWERASE && TERMIOS_TTY_DRIVER */\n }"
    },
    {
      "sha": "f9f5cd3a5b64d8b1a64c6eeaf6c17ddba1f7e6ff",
      "filename": "readline/rltypedefs.h",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rltypedefs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/rltypedefs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/rltypedefs.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* rltypedefs.h -- Type declarations for readline functions. */\n \n-/* Copyright (C) 2000-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2000-2011 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -26,15 +26,22 @@\n extern \"C\" {\n #endif\n \n-/* Old-style */\n+/* Old-style, attempt to mark as deprecated in some way people will notice. */\n \n #if !defined (_FUNCTION_DEF)\n #  define _FUNCTION_DEF\n \n+#if defined(__GNUC__) || defined(__clang__)\n+typedef int Function () __attribute__ ((deprecated));\n+typedef void VFunction () __attribute__ ((deprecated));\n+typedef char *CPFunction () __attribute__ ((deprecated));\n+typedef char **CPPFunction () __attribute__ ((deprecated));\n+#else\n typedef int Function ();\n typedef void VFunction ();\n typedef char *CPFunction ();\n typedef char **CPPFunction ();\n+#endif\n \n #endif /* _FUNCTION_DEF */\n "
    },
    {
      "sha": "45d95d2e71dc3d3a17e4bf25a555f6459b7911be",
      "filename": "readline/search.c",
      "status": "modified",
      "additions": 80,
      "deletions": 20,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/search.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/search.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/search.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* search.c - code for non-incremental searching in emacs and vi modes. */\n \n-/* Copyright (C) 1992-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1992-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -43,6 +43,7 @@\n \n #include \"readline.h\"\n #include \"history.h\"\n+#include \"histlib.h\"\n \n #include \"rlprivate.h\"\n #include \"xmalloc.h\"\n@@ -57,7 +58,7 @@ _rl_search_cxt *_rl_nscxt = 0;\n extern HIST_ENTRY *_rl_saved_line_for_history;\n \n /* Functions imported from the rest of the library. */\n-extern int _rl_free_history_entry PARAMS((HIST_ENTRY *));\n+extern void _rl_free_history_entry PARAMS((HIST_ENTRY *));\n \n static char *noninc_search_string = (char *) NULL;\n static int noninc_history_pos;\n@@ -66,6 +67,8 @@ static char *prev_line_found = (char *) NULL;\n \n static int rl_history_search_len;\n static int rl_history_search_pos;\n+static int rl_history_search_flags;\n+\n static char *history_search_string;\n static int history_string_size;\n \n@@ -74,10 +77,9 @@ static int noninc_search_from_pos PARAMS((char *, int, int));\n static int noninc_dosearch PARAMS((char *, int));\n static int noninc_search PARAMS((int, int));\n static int rl_history_search_internal PARAMS((int, int));\n-static void rl_history_search_reinit PARAMS((void));\n+static void rl_history_search_reinit PARAMS((int));\n \n static _rl_search_cxt *_rl_nsearch_init PARAMS((int, int));\n-static int _rl_nsearch_cleanup PARAMS((_rl_search_cxt *, int));\n static void _rl_nsearch_abort PARAMS((_rl_search_cxt *));\n static int _rl_nsearch_dispatch PARAMS((_rl_search_cxt *, int));\n \n@@ -169,7 +171,8 @@ noninc_dosearch (string, dir)\n \n   oldpos = where_history ();\n   history_set_pos (noninc_history_pos);\n-  entry = current_history ();\n+  entry = current_history ();\t\t/* will never be NULL after successful search */\n+  \n #if defined (VI_MODE)\n   if (rl_editing_mode != vi_mode)\n #endif\n@@ -220,7 +223,7 @@ _rl_nsearch_init (dir, pchar)\n   return cxt;\n }\n \n-static int\n+int\n _rl_nsearch_cleanup (cxt, r)\n      _rl_search_cxt *cxt;\n      int r;\n@@ -407,7 +410,7 @@ rl_noninc_forward_search_again (count, key)\n   if (!noninc_search_string)\n     {\n       rl_ding ();\n-      return (-1);\n+      return (1);\n     }\n   r = noninc_dosearch (noninc_search_string, 1);\n   return (r != 1);\n@@ -424,7 +427,7 @@ rl_noninc_reverse_search_again (count, key)\n   if (!noninc_search_string)\n     {\n       rl_ding ();\n-      return (-1);\n+      return (1);\n     }\n   r = noninc_dosearch (noninc_search_string, -1);\n   return (r != 1);\n@@ -453,15 +456,19 @@ rl_history_search_internal (count, dir)\n {\n   HIST_ENTRY *temp;\n   int ret, oldpos;\n+  char *t;\n \n   rl_maybe_save_line ();\n   temp = (HIST_ENTRY *)NULL;\n \n-  /* Search COUNT times through the history for a line whose prefix\n-     matches history_search_string.  When this loop finishes, TEMP,\n-     if non-null, is the history line to copy into the line buffer. */\n+  /* Search COUNT times through the history for a line matching\n+     history_search_string.  If history_search_string[0] == '^', the\n+     line must match from the start; otherwise any substring can match.\n+     When this loop finishes, TEMP, if non-null, is the history line to\n+     copy into the line buffer. */\n   while (count)\n     {\n+      RL_CHECK_SIGNALS ();\n       ret = noninc_search_from_pos (history_search_string, rl_history_search_pos + dir, dir);\n       if (ret == -1)\n \tbreak;\n@@ -470,7 +477,7 @@ rl_history_search_internal (count, dir)\n       rl_history_search_pos = ret;\n       oldpos = where_history ();\n       history_set_pos (rl_history_search_pos);\n-      temp = current_history ();\n+      temp = current_history ();\t/* will never be NULL after successful search */\n       history_set_pos (oldpos);\n \n       /* Don't find multiple instances of the same line. */\n@@ -505,35 +512,49 @@ rl_history_search_internal (count, dir)\n   /* Copy the line we found into the current line buffer. */\n   make_history_line_current (temp);\n \n-  rl_point = rl_history_search_len;\n+  if (rl_history_search_flags & ANCHORED_SEARCH)\n+    rl_point = rl_history_search_len;\t/* easy case */\n+  else\n+    {\n+      t = strstr (rl_line_buffer, history_search_string);\n+      rl_point = t ? (int)(t - rl_line_buffer) + rl_history_search_len : rl_end;\n+    }\n   rl_mark = rl_end;\n \n   return 0;\n }\n \n static void\n-rl_history_search_reinit ()\n+rl_history_search_reinit (flags)\n+     int flags;\n {\n+  int sind;\n+\n   rl_history_search_pos = where_history ();\n   rl_history_search_len = rl_point;\n+  rl_history_search_flags = flags;\n+\n   prev_line_found = (char *)NULL;\n   if (rl_point)\n     {\n+      /* Allocate enough space for anchored and non-anchored searches */\n       if (rl_history_search_len >= history_string_size - 2)\n \t{\n \t  history_string_size = rl_history_search_len + 2;\n \t  history_search_string = (char *)xrealloc (history_search_string, history_string_size);\n \t}\n-      history_search_string[0] = '^';\n-      strncpy (history_search_string + 1, rl_line_buffer, rl_point);\n-      history_search_string[rl_point + 1] = '\\0';\n+      sind = 0;\n+      if (flags & ANCHORED_SEARCH)\n+\thistory_search_string[sind++] = '^';\n+      strncpy (history_search_string + sind, rl_line_buffer, rl_point);\n+      history_search_string[rl_point + sind] = '\\0';\n     }\n   _rl_free_saved_history_line ();\n }\n \n /* Search forward in the history for the string of characters\n    from the start of the line to rl_point.  This is a non-incremental\n-   search. */\n+   search.  The search is anchored to the beginning of the history line. */\n int\n rl_history_search_forward (count, ignore)\n      int count, ignore;\n@@ -543,7 +564,7 @@ rl_history_search_forward (count, ignore)\n \n   if (rl_last_func != rl_history_search_forward &&\n       rl_last_func != rl_history_search_backward)\n-    rl_history_search_reinit ();\n+    rl_history_search_reinit (ANCHORED_SEARCH);\n \n   if (rl_history_search_len == 0)\n     return (rl_get_next_history (count, ignore));\n@@ -562,7 +583,46 @@ rl_history_search_backward (count, ignore)\n \n   if (rl_last_func != rl_history_search_forward &&\n       rl_last_func != rl_history_search_backward)\n-    rl_history_search_reinit ();\n+    rl_history_search_reinit (ANCHORED_SEARCH);\n+\n+  if (rl_history_search_len == 0)\n+    return (rl_get_previous_history (count, ignore));\n+  return (rl_history_search_internal (abs (count), (count > 0) ? -1 : 1));\n+}\n+\n+/* Search forward in the history for the string of characters\n+   from the start of the line to rl_point.  This is a non-incremental\n+   search.  The search succeeds if the search string is present anywhere\n+   in the history line. */\n+int\n+rl_history_substr_search_forward (count, ignore)\n+     int count, ignore;\n+{\n+  if (count == 0)\n+    return (0);\n+\n+  if (rl_last_func != rl_history_substr_search_forward &&\n+      rl_last_func != rl_history_substr_search_backward)\n+    rl_history_search_reinit (NON_ANCHORED_SEARCH);\n+\n+  if (rl_history_search_len == 0)\n+    return (rl_get_next_history (count, ignore));\n+  return (rl_history_search_internal (abs (count), (count > 0) ? 1 : -1));\n+}\n+\n+/* Search backward through the history for the string of characters\n+   from the start of the line to rl_point.  This is a non-incremental\n+   search. */\n+int\n+rl_history_substr_search_backward (count, ignore)\n+     int count, ignore;\n+{\n+  if (count == 0)\n+    return (0);\n+\n+  if (rl_last_func != rl_history_substr_search_forward &&\n+      rl_last_func != rl_history_substr_search_backward)\n+    rl_history_search_reinit (NON_ANCHORED_SEARCH);\n \n   if (rl_history_search_len == 0)\n     return (rl_get_previous_history (count, ignore));"
    },
    {
      "sha": "6947295e50e8952f5a1af04b56a7707833932363",
      "filename": "readline/shell.c",
      "status": "modified",
      "additions": 29,
      "deletions": 19,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/shell.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/shell.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/shell.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -59,6 +59,8 @@\n \n #include \"rlstdc.h\"\n #include \"rlshell.h\"\n+#include \"rldefs.h\"\n+\n #include \"xmalloc.h\"\n \n #if defined (HAVE_GETPWUID) && !defined (HAVE_GETPW_DECLS)\n@@ -120,31 +122,27 @@ sh_single_quote (string)\n \n /* Set the environment variables LINES and COLUMNS to lines and cols,\n    respectively. */\n+static char setenv_buf[INT_STRLEN_BOUND (int) + 1];\n+static char putenv_buf1[INT_STRLEN_BOUND (int) + 6 + 1];\t/* sizeof(\"LINES=\") == 6 */\n+static char putenv_buf2[INT_STRLEN_BOUND (int) + 8 + 1];\t/* sizeof(\"COLUMNS=\") == 8 */\n+\n void\n sh_set_lines_and_columns (lines, cols)\n      int lines, cols;\n {\n-  char *b;\n-\n #if defined (HAVE_SETENV)\n-  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);\n-  sprintf (b, \"%d\", lines);\n-  setenv (\"LINES\", b, 1);\n-  xfree (b);\n-\n-  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + 1);\n-  sprintf (b, \"%d\", cols);\n-  setenv (\"COLUMNS\", b, 1);\n-  xfree (b);\n+  sprintf (setenv_buf, \"%d\", lines);\n+  setenv (\"LINES\", setenv_buf, 1);\n+\n+  sprintf (setenv_buf, \"%d\", cols);\n+  setenv (\"COLUMNS\", setenv_buf, 1);\n #else /* !HAVE_SETENV */\n #  if defined (HAVE_PUTENV)\n-  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof (\"LINES=\") + 1);\n-  sprintf (b, \"LINES=%d\", lines);\n-  putenv (b);\n+  sprintf (putenv_buf1, \"LINES=%d\", lines);\n+  putenv (putenv_buf1);\n \n-  b = (char *)xmalloc (INT_STRLEN_BOUND (int) + sizeof (\"COLUMNS=\") + 1);\n-  sprintf (b, \"COLUMNS=%d\", cols);\n-  putenv (b);\n+  sprintf (putenv_buf2, \"COLUMNS=%d\", cols);\n+  putenv (putenv_buf2);\n #  endif /* HAVE_PUTENV */\n #endif /* !HAVE_SETENV */\n }\n@@ -159,15 +157,27 @@ sh_get_env_value (varname)\n char *\n sh_get_home_dir ()\n {\n-  char *home_dir;\n+  static char *home_dir = (char *)NULL;\n   struct passwd *entry;\n \n+  if (home_dir)\n+    return (home_dir);\n+\n   home_dir = (char *)NULL;\n #if defined (HAVE_GETPWUID)\n+#  if defined (__TANDEM)\n+  entry = getpwnam (getlogin ());\n+#  else\n   entry = getpwuid (getuid ());\n+#  endif\n   if (entry)\n-    home_dir = entry->pw_dir;\n+    home_dir = savestring (entry->pw_dir);\n+#endif\n+\n+#if defined (HAVE_GETPWENT)\n+  endpwent ();\t\t/* some systems need this */\n #endif\n+\n   return (home_dir);\n }\n "
    },
    {
      "sha": "f2ec3e46b7bac4d88bd7cab2067e42fb15552150",
      "filename": "readline/shlib/Makefile.in",
      "status": "modified",
      "additions": 62,
      "deletions": 23,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/shlib/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/shlib/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/shlib/Makefile.in?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -107,7 +107,7 @@ SHLIB_MINOR=\t\t.@SHLIB_MINOR@\n # For libraries which include headers from other libraries.\n INCLUDES = -I. -I.. -I$(topdir)\n \n-CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)\n+CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(INCLUDES) $(CPPFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)\n \n .SUFFIXES:\t.so\n \n@@ -134,21 +134,29 @@ CSOURCES = $(topdir)/readline.c $(topdir)/funmap.c $(topdir)/keymaps.c \\\n \t   $(topdir)/histfile.c $(topdir)/nls.c $(topdir)/search.c \\\n \t   $(topdir)/shell.c $(topdir)/savestring.c $(topdir)/tilde.c \\\n \t   $(topdir)/text.c $(topdir)/misc.c $(topdir)/compat.c \\\n+\t   $(topdir)/colors.c $(topdir)/parse-colors.c \\\n \t   $(topdir)/mbutil.c\n \n # The header files for this library.\n-HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \\\n-\t   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \\\n-\t   ansi_stdlib.h tcap.h xmalloc.h rlprivate.h rlshell.h rlmbutil.h\n+HSOURCES = $(topdir)/readline.h $(topdir)/rldefs.h $(topdir)/chardefs.h \\\n+\t   $(topdir)/keymaps.h $(topdir)/history.h $(topdir)/histlib.h \\\n+\t   $(topdir)/posixstat.h $(topdir)/posixdir.h $(topdir)/posixjmp.h \\\n+\t   $(topdir)/tilde.h $(topdir)/rlconf.h $(topdir)/rltty.h \\\n+\t   $(topdir)/ansi_stdlib.h $(topdir)/tcap.h $(topdir)/rlstdc.h \\\n+\t   $(topdir)/xmalloc.h $(topdir)/rlprivate.h $(topdir)/rlshell.h \\\n+\t   $(topdir)/rltypedefs.h $(topdir)/rlmbutil.h \\\n+           $(topdir)/colors.h $(topdir)/parse-colors.h\n \n SHARED_HISTOBJ = history.so histexpand.so histfile.so histsearch.so shell.so \\\n \t\t mbutil.so\n SHARED_TILDEOBJ = tilde.so\n+SHARED_COLORSOBJ = colors.so parse-colors.so\n SHARED_OBJ = readline.so vi_mode.so funmap.so keymaps.so parens.so search.so \\\n \t  rltty.so complete.so bind.so isearch.so display.so signals.so \\\n \t  util.so kill.so undo.so macro.so input.so callback.so terminal.so \\\n-\t  text.so nls.so misc.so xmalloc.so xfree.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ) \\\n-\t  compat.so\n+\t  text.so nls.so misc.so \\\n+\t  $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ) $(SHARED_COLORSOBJ) \\\n+\t  xmalloc.so xfree.so compat.so\n \n ##########################################################################\n \n@@ -183,16 +191,26 @@ installdirs: $(topdir)/support/mkdirs\n \t-$(SHELL) $(topdir)/support/mkdirs $(DESTDIR)$(libdir)\n \t-$(SHELL) $(topdir)/support/mkdirs $(DESTDIR)$(bindir)\n \n-install: installdirs $(SHLIB_STATUS)\n+install-supported: installdirs $(SHLIB_STATUS)\n \t$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -V $(host_vendor) -d $(DESTDIR)$(libdir) -b $(DESTDIR)$(bindir) -i \"$(INSTALL_DATA)\" $(SHARED_HISTORY)\n \t$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -V $(host_vendor) -d $(DESTDIR)$(libdir) -b $(DESTDIR)$(bindir) -i \"$(INSTALL_DATA)\" $(SHARED_READLINE)\n \t@echo install: you may need to run ldconfig\n \n-uninstall:\n+install-unsupported:\n+\t@echo install: shared libraries not supported\n+\n+install: install-$(SHLIB_STATUS)\n+\n+uninstall-supported:\n \t$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -V $(host_vendor) -d $(DESTDIR)$(libdir) -b $(DESTDIR)$(bindir) -U $(SHARED_HISTORY)\n \t$(SHELL) $(topdir)/support/shlib-install -O $(host_os) -V $(host_vendor) -d $(DESTDIR)$(libdir) -b $(DESTDIR)$(bindir) -U $(SHARED_READLINE)\n \t@echo uninstall: you may need to run ldconfig\n \n+uninstall-unsupported:\n+\t@echo uninstall: shared libraries not supported\n+\n+uninstall: uninstall-$(SHLIB_STATUS)\n+\n clean mostlyclean:\tforce\n \t$(RM) $(SHARED_OBJ) $(SHARED_LIBS)\n \n@@ -211,13 +229,14 @@ bind.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h\n bind.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n bind.so: $(topdir)/rltypedefs.h\n bind.so: $(topdir)/tilde.h $(topdir)/history.h\n-compat.so: $(topdir)/rlstdc.h\n+compat.so: ${BUILD_DIR}/config.h\n+compat.so: $(topdir)/rlstdc.h $(topdir)/rltypedefs.h\n callback.so: $(topdir)/rlconf.h\n callback.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h\n callback.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n callback.so: $(topdir)/rltypedefs.h\n callback.so: $(topdir)/tilde.h\n-complete.so: $(topdir)/ansi_stdlib.h posixdir.h $(topdir)/posixstat.h\n+complete.so: $(topdir)/ansi_stdlib.h $(topdir)/posixdir.h $(topdir)/posixstat.h\n complete.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h\n complete.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n complete.so: $(topdir)/rltypedefs.h\n@@ -253,7 +272,6 @@ isearch.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h\n isearch.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n isearch.so: $(topdir)/rltypedefs.h\n isearch.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h\n-keymaps.so: emacs_keymap.c vi_keymap.c\n keymaps.so: $(topdir)/keymaps.h $(topdir)/chardefs.h $(topdir)/rlconf.h\n keymaps.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n keymaps.so: $(topdir)/rltypedefs.h\n@@ -286,6 +304,7 @@ rltty.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h\n rltty.so: $(topdir)/rltty.h $(topdir)/tilde.h\n rltty.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n rltty.so: $(topdir)/rltypedefs.h\n+savestring.so: ${BUILD_DIR}/config.h\n search.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h\n search.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h\n search.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h\n@@ -330,6 +349,16 @@ shell.so: $(topdir)/rlshell.h\n terminal.so: $(topdir)/rlshell.h\n histexpand.so: $(topdir)/rlshell.h\n \n+colors.so: $(BUILD_DIR)/config.h $(topdir)/colors.h\n+colors.so: $(topdir)/rlconf.h \n+colors.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/rltypedefs.h\n+colors.so: $(topdir)/chardefs.h $(topdir)/tilde.h $(topdir)/rlstdc.h\n+colors.so: $(topdir)/ansi_stdlib.h $(topdir)/posixstat.h\n+parse-colors.so: $(BUILD_DIR)/config.h $(topdir)/colors.h $(topdir)/parse-colors.h\n+parse-colors.so: $(topdir)/rldefs.h $(topdir)/rlconf.h \n+parse-colors.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/rltypedefs.h\n+parse-colors.so: $(topdir)/chardefs.h $(topdir)/tilde.h $(topdir)/rlstdc.h\n+\n bind.so: $(topdir)/rlprivate.h\n callback.so: $(topdir)/rlprivate.h\n complete.so: $(topdir)/rlprivate.h\n@@ -351,8 +380,11 @@ text.so: $(topdir)/rlprivate.h\n undo.so: $(topdir)/rlprivate.h\n util.so: $(topdir)/rlprivate.h\n vi_mode.so: $(topdir)/rlprivate.h\n+colors.so: $(topdir)/rlprivate.h\n+parse-colors.so: $(topdir)/rlprivate.h\n \n bind.so: $(topdir)/xmalloc.h\n+callback.so: $(topdir)/xmalloc.h\n complete.so: $(topdir)/xmalloc.h\n display.so: $(topdir)/xmalloc.h\n funmap.so: $(topdir)/xmalloc.h\n@@ -378,18 +410,22 @@ util.so: $(topdir)/xmalloc.h\n vi_mode.so: $(topdir)/xmalloc.h\n xfree.so: $(topdir)/xmalloc.h\n xmalloc.so: $(topdir)/xmalloc.h\n-\n-complete.o: $(topdir)/rlmbutil.h\n-display.o: $(topdir)/rlmbutil.h\n-histexpand.o: $(topdir)/rlmbutil.h\n-input.o: $(topdir)/rlmbutil.h\n-isearch.o: $(topdir)/rlmbutil.h\n-mbutil.o: $(topdir)/rlmbutil.h\n-misc.o: $(topdir)/rlmbutil.h\n-readline.o: $(topdir)/rlmbutil.h\n-search.o: $(topdir)/rlmbutil.h\n-text.o: $(topdir)/rlmbutil.h\n-vi_mode.o: $(topdir)/rlmbutil.h\n+colors.so: $(topdir)/xmalloc.h\n+parse-colors.so: $(topdir)/xmalloc.h\n+\n+complete.so: $(topdir)/rlmbutil.h\n+display.so: $(topdir)/rlmbutil.h\n+histexpand.so: $(topdir)/rlmbutil.h\n+input.so: $(topdir)/rlmbutil.h\n+isearch.so: $(topdir)/rlmbutil.h\n+mbutil.so: $(topdir)/rlmbutil.h\n+misc.so: $(topdir)/rlmbutil.h\n+readline.so: $(topdir)/rlmbutil.h\n+search.so: $(topdir)/rlmbutil.h\n+text.so: $(topdir)/rlmbutil.h\n+vi_mode.so: $(topdir)/rlmbutil.h\n+colors.so: $(topdir)/rlmbutil.h\n+parse-colors.so: $(topdir)/rlmbutil.h\n \n bind.so: $(topdir)/bind.c\n callback.so: $(topdir)/callback.c\n@@ -456,6 +492,9 @@ vi_mode.so: vi_mode.c\n xfree.so: xfree.c\n xmalloc.so: xmalloc.c\n \n+colors.so: colors.c\n+parse-colors.so: parse-colors.c\n+\n histexpand.so: histexpand.c\n histfile.so: histfile.c\n history.so: history.c"
    },
    {
      "sha": "927f532304efa51e99c9c87ca10056394d29079a",
      "filename": "readline/signals.c",
      "status": "modified",
      "additions": 112,
      "deletions": 45,
      "changes": 157,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/signals.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/signals.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/signals.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* signals.c -- signal handling support for readline. */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -80,14 +80,15 @@ typedef struct { SigHandler *sa_handler; int sa_mask, sa_flags; } sighandler_cxt\n \n static SigHandler *rl_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));\n static void rl_maybe_set_sighandler PARAMS((int, SigHandler *, sighandler_cxt *));\n+static void rl_maybe_restore_sighandler PARAMS((int, sighandler_cxt *));\n \n static RETSIGTYPE rl_signal_handler PARAMS((int));\n static RETSIGTYPE _rl_handle_signal PARAMS((int));\n      \n /* Exported variables for use by applications. */\n \n /* If non-zero, readline will install its own signal handlers for\n-   SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */\n+   SIGINT, SIGTERM, SIGHUP, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */\n int rl_catch_signals = 1;\n \n /* If non-zero, readline will install a signal handler for SIGWINCH. */\n@@ -118,14 +119,17 @@ static int sigwinch_set_flag;\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n-static sighandler_cxt old_int, old_term, old_alrm, old_quit;\n+static sighandler_cxt old_int, old_term, old_hup, old_alrm, old_quit;\n #if defined (SIGTSTP)\n static sighandler_cxt old_tstp, old_ttou, old_ttin;\n #endif\n #if defined (SIGWINCH)\n static sighandler_cxt old_winch;\n #endif\n \n+_rl_sigcleanup_func_t *_rl_sigcleanup;\n+void *_rl_sigcleanarg;\n+\n /* Readline signal handler functions. */\n \n /* Called from RL_CHECK_SIGNALS() macro */\n@@ -135,15 +139,29 @@ _rl_signal_handler (sig)\n {\n   _rl_caught_signal = 0;\t/* XXX */\n \n-  _rl_handle_signal (sig);\n+#if defined (SIGWINCH)\n+  if (sig == SIGWINCH)\n+    {\n+      rl_resize_terminal ();\n+      /* XXX - experimental for now */\n+      /* Call a signal hook because though we called the original signal handler\n+\t in rl_sigwinch_handler below, we will not resend the signal to\n+\t ourselves. */\n+      if (rl_signal_event_hook)\n+\t(*rl_signal_event_hook) ();\n+    }\n+  else\n+#endif\n+    _rl_handle_signal (sig);\n+\n   SIGHANDLER_RETURN;\n }\n \n static RETSIGTYPE\n rl_signal_handler (sig)\n      int sig;\n {\n-  if (_rl_interrupt_immediately || RL_ISSTATE(RL_STATE_CALLBACK))\n+  if (_rl_interrupt_immediately)\n     {\n       _rl_interrupt_immediately = 0;\n       _rl_handle_signal (sig);\n@@ -181,19 +199,45 @@ _rl_handle_signal (sig)\n     rl_set_sighandler (sig, SIG_IGN, &dummy_cxt);\n #endif /* !HAVE_BSD_SIGNALS && !HAVE_POSIX_SIGNALS */\n \n+  /* If there's a sig cleanup function registered, call it and `deregister'\n+     the cleanup function to avoid multiple calls */\n+  if (_rl_sigcleanup)\n+    {\n+      (*_rl_sigcleanup) (sig, _rl_sigcleanarg);\n+      _rl_sigcleanup = 0;\n+      _rl_sigcleanarg = 0;\n+    }\n+    \n   switch (sig)\n     {\n     case SIGINT:\n       _rl_reset_completion_state ();\n       rl_free_line_state ();\n+#if defined (READLINE_CALLBACKS)\n+      rl_callback_sigcleanup ();\n+#endif\n+\n       /* FALLTHROUGH */\n \n-    case SIGTERM:\n #if defined (SIGTSTP)\n     case SIGTSTP:\n-    case SIGTTOU:\n     case SIGTTIN:\n+#  if defined (HAVE_POSIX_SIGNALS)\n+      /* Block SIGTTOU so we can restore the terminal settings to something\n+\t sane without stopping on SIGTTOU if we have been placed into the\n+\t background.  Even trying to get the current terminal pgrp with\n+\t tcgetpgrp() will generate SIGTTOU, so we don't bother.  Don't bother\n+\t doing this if we've been stopped on SIGTTOU; it's aready too late. */\n+      sigemptyset (&set);\n+      sigaddset (&set, SIGTTOU);\n+      sigprocmask (SIG_BLOCK, &set, (sigset_t *)NULL);\n+#  endif\n+    case SIGTTOU:\n #endif /* SIGTSTP */\n+    case SIGTERM:\n+#if defined (SIGHUP)\n+    case SIGHUP:\n+#endif\n #if defined (SIGALRM)\n     case SIGALRM:\n #endif\n@@ -204,6 +248,10 @@ _rl_handle_signal (sig)\n       rl_cleanup_after_signal ();\n \n #if defined (HAVE_POSIX_SIGNALS)\n+      /* Unblock SIGTTOU blocked above */\n+      if (sig == SIGTTIN || sig == SIGTSTP)\n+\tsigprocmask (SIG_UNBLOCK, &set, (sigset_t *)NULL);\n+\n       sigemptyset (&set);\n       sigprocmask (SIG_BLOCK, (sigset_t *)NULL, &set);\n       sigdelset (&set, sig);\n@@ -232,7 +280,7 @@ _rl_handle_signal (sig)\n #  endif /* HAVE_BSD_SIGNALS */\n #endif /* !HAVE_POSIX_SIGNALS */\n \n-      rl_reset_after_signal ();\n+      rl_reset_after_signal ();      \n     }\n \n   RL_UNSETSTATE(RL_STATE_SIGHANDLER);\n@@ -257,7 +305,7 @@ rl_sigwinch_handler (sig)\n #endif\n \n   RL_SETSTATE(RL_STATE_SIGHANDLER);\n-  rl_resize_terminal ();\n+  _rl_caught_signal = sig;\n \n   /* If another sigwinch handler has been installed, call it. */\n   oh = (SigHandler *)old_winch.sa_handler;\n@@ -317,6 +365,8 @@ rl_set_sighandler (sig, handler, ohandler)\n   return (ohandler->sa_handler);\n }\n \n+/* Set disposition of SIG to HANDLER, returning old state in OHANDLER.  Don't\n+   change disposition if OHANDLER indicates the signal was ignored. */\n static void\n rl_maybe_set_sighandler (sig, handler, ohandler)\n      int sig;\n@@ -327,11 +377,29 @@ rl_maybe_set_sighandler (sig, handler, ohandler)\n   SigHandler *oh;\n \n   sigemptyset (&dummy.sa_mask);\n+  dummy.sa_flags = 0;\n   oh = rl_set_sighandler (sig, handler, ohandler);\n   if (oh == (SigHandler *)SIG_IGN)\n     rl_sigaction (sig, ohandler, &dummy);\n }\n \n+/* Set the disposition of SIG to HANDLER, if HANDLER->sa_handler indicates the\n+   signal was not being ignored.  MUST only be called for signals whose\n+   disposition was changed using rl_maybe_set_sighandler or for which the\n+   SIG_IGN check was performed inline (e.g., SIGALRM below). */\n+static void\n+rl_maybe_restore_sighandler (sig, handler)\n+     int sig;\n+     sighandler_cxt *handler;\n+{\n+  sighandler_cxt dummy;\n+\n+  sigemptyset (&dummy.sa_mask);\n+  dummy.sa_flags = 0;\n+  if (handler->sa_handler != SIG_IGN)\n+    rl_sigaction (sig, handler, &dummy);\n+}\n+\n int\n rl_set_signals ()\n {\n@@ -349,6 +417,9 @@ rl_set_signals ()\n \n       sigaddset (&bset, SIGINT);\n       sigaddset (&bset, SIGTERM);\n+#if defined (SIGHUP)\n+      sigaddset (&bset, SIGHUP);\n+#endif\n #if defined (SIGQUIT)\n       sigaddset (&bset, SIGQUIT);\n #endif\n@@ -377,6 +448,9 @@ rl_set_signals ()\n \n       rl_maybe_set_sighandler (SIGINT, rl_signal_handler, &old_int);\n       rl_maybe_set_sighandler (SIGTERM, rl_signal_handler, &old_term);\n+#if defined (SIGHUP)\n+      rl_maybe_set_sighandler (SIGHUP, rl_signal_handler, &old_hup);\n+#endif\n #if defined (SIGQUIT)\n       rl_maybe_set_sighandler (SIGQUIT, rl_signal_handler, &old_quit);\n #endif\n@@ -434,25 +508,33 @@ rl_clear_signals ()\n     {\n       sigemptyset (&dummy.sa_mask);\n \n-      rl_sigaction (SIGINT, &old_int, &dummy);\n-      rl_sigaction (SIGTERM, &old_term, &dummy);\n+      /* Since rl_maybe_set_sighandler doesn't override a SIG_IGN handler,\n+\t we should in theory not have to restore a handler where\n+\t old_xxx.sa_handler == SIG_IGN.  That's what rl_maybe_restore_sighandler\n+\t does.  Fewer system calls should reduce readline's per-line\n+\t overhead */\n+      rl_maybe_restore_sighandler (SIGINT, &old_int);\n+      rl_maybe_restore_sighandler (SIGTERM, &old_term);\n+#if defined (SIGHUP)\n+      rl_maybe_restore_sighandler (SIGHUP, &old_hup);\n+#endif\n #if defined (SIGQUIT)\n-      rl_sigaction (SIGQUIT, &old_quit, &dummy);\n+      rl_maybe_restore_sighandler (SIGQUIT, &old_quit);\n #endif\n #if defined (SIGALRM)\n-      rl_sigaction (SIGALRM, &old_alrm, &dummy);\n+      rl_maybe_restore_sighandler (SIGALRM, &old_alrm);\n #endif\n \n #if defined (SIGTSTP)\n-      rl_sigaction (SIGTSTP, &old_tstp, &dummy);\n+      rl_maybe_restore_sighandler (SIGTSTP, &old_tstp);\n #endif /* SIGTSTP */\n \n #if defined (SIGTTOU)\n-      rl_sigaction (SIGTTOU, &old_ttou, &dummy);\n+      rl_maybe_restore_sighandler (SIGTTOU, &old_ttou);\n #endif /* SIGTTOU */\n \n #if defined (SIGTTIN)\n-      rl_sigaction (SIGTTIN, &old_ttin, &dummy);\n+      rl_maybe_restore_sighandler (SIGTTIN, &old_ttin);\n #endif /* SIGTTIN */\n \n       signals_set_flag = 0;\n@@ -511,6 +593,11 @@ rl_free_line_state ()\n   _rl_reset_argument ();\n }\n \n+int\n+rl_pending_signal ()\n+{\n+  return (_rl_caught_signal);\n+}\n #endif  /* HANDLE_SIGNALS */\n \n /* **************************************************************** */\n@@ -540,21 +627,6 @@ _rl_block_sigint ()\n   if (sigint_blocked)\n     return;\n \n-#if defined (HAVE_POSIX_SIGNALS)\n-  sigemptyset (&sigint_set);\n-  sigemptyset (&sigint_oset);\n-  sigaddset (&sigint_set, SIGINT);\n-  sigprocmask (SIG_BLOCK, &sigint_set, &sigint_oset);\n-#else /* !HAVE_POSIX_SIGNALS */\n-#  if defined (HAVE_BSD_SIGNALS)\n-  sigint_oldmask = sigblock (sigmask (SIGINT));\n-#  else /* !HAVE_BSD_SIGNALS */\n-#    if defined (HAVE_USG_SIGHOLD)\n-  sighold (SIGINT);\n-#    endif /* HAVE_USG_SIGHOLD */\n-#  endif /* !HAVE_BSD_SIGNALS */\n-#endif /* !HAVE_POSIX_SIGNALS */\n-\n   sigint_blocked = 1;\n }\n \n@@ -565,22 +637,10 @@ _rl_release_sigint ()\n   if (sigint_blocked == 0)\n     return;\n \n-#if defined (HAVE_POSIX_SIGNALS)\n-  sigprocmask (SIG_SETMASK, &sigint_oset, (sigset_t *)NULL);\n-#else\n-#  if defined (HAVE_BSD_SIGNALS)\n-  sigsetmask (sigint_oldmask);\n-#  else /* !HAVE_BSD_SIGNALS */\n-#    if defined (HAVE_USG_SIGHOLD)\n-  sigrelse (SIGINT);\n-#    endif /* HAVE_USG_SIGHOLD */\n-#  endif /* !HAVE_BSD_SIGNALS */\n-#endif /* !HAVE_POSIX_SIGNALS */\n-\n   sigint_blocked = 0;\n+  RL_CHECK_SIGNALS ();\n }\n \n-#ifdef SIGWINCH\n /* Cause SIGWINCH to not be delivered until the corresponding call to\n    release_sigwinch(). */\n void\n@@ -589,6 +649,8 @@ _rl_block_sigwinch ()\n   if (sigwinch_blocked)\n     return;\n \n+#if defined (SIGWINCH)\n+\n #if defined (HAVE_POSIX_SIGNALS)\n   sigemptyset (&sigwinch_set);\n   sigemptyset (&sigwinch_oset);\n@@ -604,6 +666,8 @@ _rl_block_sigwinch ()\n #  endif /* !HAVE_BSD_SIGNALS */\n #endif /* !HAVE_POSIX_SIGNALS */\n \n+#endif /* SIGWINCH */\n+\n   sigwinch_blocked = 1;\n }\n \n@@ -614,6 +678,8 @@ _rl_release_sigwinch ()\n   if (sigwinch_blocked == 0)\n     return;\n \n+#if defined (SIGWINCH)\n+\n #if defined (HAVE_POSIX_SIGNALS)\n   sigprocmask (SIG_SETMASK, &sigwinch_oset, (sigset_t *)NULL);\n #else\n@@ -626,9 +692,10 @@ _rl_release_sigwinch ()\n #  endif /* !HAVE_BSD_SIGNALS */\n #endif /* !HAVE_POSIX_SIGNALS */\n \n+#endif /* SIGWINCH */\n+\n   sigwinch_blocked = 0;\n }\n-#endif /* SIGWINCH */\n \n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */"
    },
    {
      "sha": "637da2336c11a0284abcdc65374ee489d597065c",
      "filename": "readline/support/config.guess",
      "status": "modified",
      "additions": 41,
      "deletions": 1,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/config.guess",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/config.guess",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/config.guess?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,7 +2,7 @@\n # Attempt to guess a canonical system name.\n #   Copyright 1992-2019 Free Software Foundation, Inc.\n \n-timestamp='2019-04-28'\n+timestamp='2019-08-04'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -245,6 +245,10 @@ case \"$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION\" in\n \tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n \techo \"$UNAME_MACHINE_ARCH\"-unknown-bitrig\"$UNAME_RELEASE\"\n \texit ;;\n+    *:Bitrig:*:*)\n+\tUNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`\n+\techo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}\n+\texit ;;\n     *:OpenBSD:*:*)\n \tUNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`\n \techo \"$UNAME_MACHINE_ARCH\"-unknown-openbsd\"$UNAME_RELEASE\"\n@@ -390,6 +394,9 @@ case \"$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION\" in\n     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n \techo i386-pc-auroraux\"$UNAME_RELEASE\"\n \texit ;;\n+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)\n+\techo i386-pc-auroraux${UNAME_RELEASE}\n+\texit ;;\n     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)\n \tset_cc_for_build\n \tSUN_ARCH=i386\n@@ -869,6 +876,9 @@ EOF\n     *:MINGW64*:*)\n \techo \"$UNAME_MACHINE\"-pc-mingw64\n \texit ;;\n+    *:MINGW64*:*)\n+\techo ${UNAME_MACHINE}-pc-mingw64\n+\texit ;;\n     *:MINGW*:*)\n \techo \"$UNAME_MACHINE\"-pc-mingw32\n \texit ;;\n@@ -934,6 +944,30 @@ EOF\n     arc:Linux:*:* | arceb:Linux:*:*)\n \techo \"$UNAME_MACHINE\"-unknown-linux-\"$LIBC\"\n \texit ;;\n+    aarch64:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    aarch64_be:Linux:*:*)\n+\tUNAME_MACHINE=aarch64_be\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    alpha:Linux:*:*)\n+\tcase `sed -n '/^cpu model/s/^.*: \\(.*\\)/\\1/p' < /proc/cpuinfo` in\n+\t  EV5)   UNAME_MACHINE=alphaev5 ;;\n+\t  EV56)  UNAME_MACHINE=alphaev56 ;;\n+\t  PCA56) UNAME_MACHINE=alphapca56 ;;\n+\t  PCA57) UNAME_MACHINE=alphapca56 ;;\n+\t  EV6)   UNAME_MACHINE=alphaev6 ;;\n+\t  EV67)  UNAME_MACHINE=alphaev67 ;;\n+\t  EV68*) UNAME_MACHINE=alphaev68 ;;\n+\tesac\n+\tobjdump --private-headers /bin/sh | grep -q ld.so.1\n+\tif test \"$?\" = 0 ; then LIBC=\"gnulibc1\" ; fi\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n+    arc:Linux:*:* | arceb:Linux:*:*)\n+\techo ${UNAME_MACHINE}-unknown-linux-${LIBC}\n+\texit ;;\n     arm*:Linux:*:*)\n \tset_cc_for_build\n \tif echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \\\n@@ -1459,6 +1493,12 @@ EOF\n     *:Unleashed:*:*)\n \techo \"$UNAME_MACHINE\"-unknown-unleashed\"$UNAME_RELEASE\"\n \texit ;;\n+    i*86:AROS:*:*)\n+\techo ${UNAME_MACHINE}-pc-aros\n+\texit ;;\n+    x86_64:VMkernel:*:*)\n+\techo ${UNAME_MACHINE}-unknown-esx\n+\texit ;;\n esac\n \n # No uname command or uname output not recognized."
    },
    {
      "sha": "22d774e429e62b7d043528d8f6f598c7afe8015a",
      "filename": "readline/support/config.sub",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/config.sub",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/config.sub",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/config.sub?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,7 +2,7 @@\n # Configuration validation subroutine script.\n #   Copyright 1992-2019 Free Software Foundation, Inc.\n \n-timestamp='2019-05-23'\n+timestamp='2019-08-04'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -1601,6 +1601,9 @@ case $cpu-$vendor in\n \tmips*-*)\n \t\tos=elf\n \t\t;;\n+\tor1k-*)\n+\t\tos=-elf\n+\t\t;;\n \tor32-*)\n \t\tos=coff\n \t\t;;"
    },
    {
      "sha": "282431d4ad319017c5ed9ecb694313b90868fcce",
      "filename": "readline/support/mkdist",
      "status": "modified",
      "additions": 12,
      "deletions": 3,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/mkdist",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/mkdist",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/mkdist?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -2,7 +2,7 @@\n #\n # mkdist - make a distribution directory from a master manifest file\n #\n-# usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version\n+# usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-t] [-v] version\n #\n # SRCDIR defaults to src\n # MANIFEST defaults to $SRCDIR/MANIFEST\n@@ -31,7 +31,7 @@ ROOTNAME=bash\n \n usage()\n {\n-\techo usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-v] version 1>&2\n+\techo usage: mkdist [-m manifest] [-s srcdir] [-r rootname] [-t] [-v] version 1>&2\n \texit 2\n }\n \n@@ -42,12 +42,13 @@ vmsg()\n \tfi\n }\n \n-while getopts m:s:r:v name\n+while getopts m:s:r:tv name\n do\n \tcase $name in\n \tm)\tMANIFEST=$OPTARG ;;\n \ts)\tSRCDIR=$OPTARG ;;\n \tr)\tROOTNAME=$OPTARG ;;\n+\tt)\tmaketar=yes ;;\n \tv)\tverbose=yes ;;\n \t?)\tusage ;;\n \tesac\n@@ -66,6 +67,8 @@ fi\n version=$1\n newdir=${ROOTNAME}-$version\n \n+tarfile=${newdir}.tar\n+\n vmsg creating distribution for $ROOTNAME version $version in $newdir\n \n if [ ! -d $newdir ]; then\n@@ -117,4 +120,10 @@ done < $MANIFEST\n \n vmsg $newdir created\n \n+if [ -n \"$maketar\" ]; then\n+\ttar cf ${tarfile} $newdir\n+\tgzip $tarfile\n+\tvmsg ${tarfile}.gz created\n+fi\n+\n exit 0"
    },
    {
      "sha": "cfec3bd1e62e46e1b6ab4591fc506bdad1580803",
      "filename": "readline/support/shlib-install",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/shlib-install",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/shlib-install",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/shlib-install?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -66,11 +66,12 @@ fi\n # post-install/uninstall\n \n # HP-UX and Darwin/MacOS X require that a shared library have execute permission\n-# Linux does, too, and ldd warns about it\n+# Linux does, too, and ldd warns about it.  Solaris doesn't seem to mind,\n+# but ldd still warns about it.\n # Cygwin installs both a dll (which must go in $BINDIR) and an implicit\n # link library (in $libdir)\n case \"$host_os\" in\n-hpux*|darwin*|macosx*|linux*)\n+hpux*|darwin*|macosx*|linux*|solaris2*)\n \tif [ -z \"$uninstall\" ]; then\n \t\tchmod 555 ${INSTALLDIR}/${LIBNAME}\n \tfi ;;\n@@ -131,7 +132,7 @@ case \"$host_os-$host_vendor\" in\n \tfi\n \t;;\n \n-bsdi4*|*gnu*|darwin*|macosx*|netbsd*)\n+bsdi4*|*gnu*|darwin*|macosx*|netbsd*|mirbsd*)\n \t# libname.so.M -> libname.so.M.N\n \t${echo} ${RM} ${INSTALLDIR}/$LINK2\n \tif [ -z \"$uninstall\" ]; then\n@@ -177,7 +178,7 @@ freebsd3*|freebsdaout*)\n \tfi\n \t;;\n \n-freebsd[4-9]*|freebsdelf*|dragonfly*)\n+freebsd[4-9]*|freebsd1[0-9]*|freebsdelf*|dragonfly*)\n \t# libname.so -> libname.so.M\n \t${echo} ${RM} ${INSTALLDIR}/$LINK1\n \tif [ -z \"$uninstall\" ]; then"
    },
    {
      "sha": "1f64433dea83763eabe496c35bc99d3fb18cee49",
      "filename": "readline/support/shobj-conf",
      "status": "modified",
      "additions": 43,
      "deletions": 28,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/shobj-conf",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/support/shobj-conf",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/support/shobj-conf?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -10,7 +10,7 @@\n # Chet Ramey\n # chet@po.cwru.edu\n \n-#   Copyright (C) 1996-2009 Free Software Foundation, Inc.\n+#   Copyright (C) 1996-2014 Free Software Foundation, Inc.\n #\n #   This file is part of GNU Bash, the Bourne Again SHell.\n #\n@@ -65,6 +65,20 @@ while [ $# -gt 0 ]; do\n done\n \n case \"${host_os}-${SHOBJ_CC}-${host_vendor}\" in\n+nsk-cc-tandem)\n+\tSHOBJ_CFLAGS=-Wglobalized\n+\tcase `uname -m` in\n+\tNSR*)\n+\t\tSHOBJ_CFLAGS=\"${SHOBJ_CFLAGS} -Wcall_shared\" # default on TNS/E, needed on TNS/R\n+\t\tSHOBJ_LD=/usr/bin/ld # for TNS/R\n+\t\t;;\n+\tNSE*|NEO*)\n+\t\tSHOBJ_LD=/usr/bin/eld\n+\t\t;;\n+\tesac\n+\tSHOBJ_LDFLAGS='-shared -bglobalized -unres_symbols ignore'\n+\t;;\n+\n sunos4*-*gcc*)\n \tSHOBJ_CFLAGS=-fpic\n \tSHOBJ_LD=/usr/bin/ld\n@@ -146,7 +160,7 @@ freebsd3*|freebsdaout*)\n \t;;\n \n # FreeBSD-4.x and later have only ELF\n-freebsd[4-9]*|freebsdelf*|dragonfly*)\n+freebsd[4-9]*|freebsd1[0-9]*|freebsdelf*|dragonfly*)\n \tSHOBJ_CFLAGS=-fPIC\n \tSHOBJ_LD='${CC}'\n \n@@ -157,47 +171,48 @@ freebsd[4-9]*|freebsdelf*|dragonfly*)\n \t;;\n \n # Darwin/MacOS X\n-darwin[89]*|darwin10*)\n-\tSHOBJ_STATUS=supported\n-\tSHLIB_STATUS=supported\n-\t\n-\tSHOBJ_CFLAGS='-fno-common'\n-\n-\tSHOBJ_LD='MACOSX_DEPLOYMENT_TARGET=10.3 ${CC}'\n-\n-\tSHLIB_LIBVERSION='$(SHLIB_MAJOR)$(SHLIB_MINOR).$(SHLIB_LIBSUFF)'\n-\tSHLIB_LIBSUFF='dylib'\n-\n-\tSHOBJ_LDFLAGS='-dynamiclib -dynamic -undefined dynamic_lookup -arch_only `/usr/bin/arch`'\n-\tSHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n-\n-\tSHLIB_LIBS='-lncurses'\t# see if -lcurses works on MacOS X 10.1 \n-\t;;\n-\n-darwin*|macosx*)\n-\tSHOBJ_STATUS=unsupported\n-\tSHLIB_STATUS=supported\n-\n+darwin*)\n+\t# Common definitions for all darwin/mac os x versions\n \tSHOBJ_CFLAGS='-fno-common'\n \n \tSHOBJ_LD='${CC}'\n \n \tSHLIB_LIBVERSION='$(SHLIB_MAJOR)$(SHLIB_MINOR).$(SHLIB_LIBSUFF)'\n \tSHLIB_LIBSUFF='dylib'\n \n+\t# unused at this time\n+\tSHLIB_SONAME='$(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF)'\n+\n \tcase \"${host_os}\" in\n-\tdarwin[789]*|darwin10*)\tSHOBJ_LDFLAGS=''\n-\t\t\tSHLIB_XLDFLAGS='-dynamiclib -arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t# Darwin versions 1, 5, 6, 7 correspond to Mac OS X 10.0, 10.1, 10.2,\n+\t# and 10.3, respectively.\n+\tdarwin[1-7].*)\n+\t\tSHOBJ_STATUS=unsupported\n+\t\tSHOBJ_LDFLAGS='-dynamic'\n+\t\tSHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t\t;;\n+\t# Darwin 8 == Mac OS X 10.4; Mac OS X 10.N == Darwin N+4\n+\t*)\n+\t\tcase \"${host_os}\" in\n+\t\tdarwin[89]*|darwin1[012]*)\n+\t\t\tSHOBJ_ARCHFLAGS='-arch_only `/usr/bin/arch`'\n \t\t\t;;\n-\t*)\t\tSHOBJ_LDFLAGS='-dynamic'\n-\t\t\tSHLIB_XLDFLAGS='-arch_only `/usr/bin/arch` -install_name $(libdir)/$@ -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t\t *) \t# Mac OS X 10.9 (Mavericks) and later\n+\t\t\tSHOBJ_ARCHFLAGS=\n+\t\t\t# for 32 and 64bit universal library\n+\t\t\t#SHOBJ_ARCHFLAGS='-arch i386 -arch x86_64'\n+\t\t\t#SHOBJ_CFLAGS=${SHOBJ_CFLAGS}' -arch i386 -arch x86_64'\n \t\t\t;;\n+\t\t esac\n+\t\t SHOBJ_LDFLAGS=\"-dynamiclib -dynamic -undefined dynamic_lookup ${SHOBJ_ARCHFLAGS}\"\n+\t\t SHLIB_XLDFLAGS=\"-dynamiclib ${SHOBJ_ARCHFLAGS}\"' -install_name $(libdir)/`echo $@ | sed \"s:\\\\..*::\"`.$(SHLIB_MAJOR).$(SHLIB_LIBSUFF) -current_version $(SHLIB_MAJOR)$(SHLIB_MINOR) -compatibility_version $(SHLIB_MAJOR) -v'\n+\t\t;;\n \tesac\n \n \tSHLIB_LIBS='-lncurses'\t# see if -lcurses works on MacOS X 10.1 \n \t;;\n \n-openbsd*|netbsd*)\n+openbsd*|netbsd*|mirbsd*)\n \tSHOBJ_CFLAGS=-fPIC\n \tSHOBJ_LD='${CC}'\n \tSHOBJ_LDFLAGS='-shared'"
    },
    {
      "sha": "859e6eed5aabed599a3fb4c4ac43fe537c7e67d1",
      "filename": "readline/tcap.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/tcap.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/tcap.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/tcap.h?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* tcap.h -- termcap library functions and variables. */\n \n-/* Copyright (C) 1996-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1996-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      "
    },
    {
      "sha": "ef2884e0f987bc9a7741c1d01dfcaa8d7b6fb1f9",
      "filename": "readline/terminal.c",
      "status": "modified",
      "additions": 44,
      "deletions": 22,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/terminal.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/terminal.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/terminal.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* terminal.c -- controlling the terminal with termcap. */\n \n-/* Copyright (C) 1996-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1996-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -51,15 +51,14 @@\n /* System-specific feature definitions and include files. */\n #include \"rldefs.h\"\n \n-#if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)\n-#  include <sys/ioctl.h>\n-#endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */\n-\n #ifdef __MSDOS__\n-# include <pc.h>\n+#  include <pc.h>\n #endif\n \n #include \"rltty.h\"\n+#if defined (HAVE_SYS_IOCTL_H)\n+#  include <sys/ioctl.h>\t\t/* include for declaration of ioctl */\n+#endif\n #include \"tcap.h\"\n \n /* Some standard library routines. */\n@@ -81,14 +80,15 @@ static void _win_get_screensize PARAMS((int *, int *));\n static void _emx_get_screensize PARAMS((int *, int *));\n #endif\n \n-#define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)\n-#define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)\n-\n-/*  If the calling application sets this to a non-zero value, readline will\n-    use the $LINES and $COLUMNS environment variables to set its idea of the\n-    window size before interrogating the kernel. */\n+/* If the calling application sets this to a non-zero value, readline will\n+   use the $LINES and $COLUMNS environment variables to set its idea of the\n+   window size before interrogating the kernel. */\n int rl_prefer_env_winsize = 0;\n \n+/* If this is non-zero, readline will set LINES and COLUMNS in the\n+   environment when it handles SIGWINCH. */\n+int rl_change_environment = 1;\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tTerminal and Termcap\t\t\t    */\n@@ -98,7 +98,7 @@ int rl_prefer_env_winsize = 0;\n #ifndef __MSDOS__\n static char *term_buffer = (char *)NULL;\n static char *term_string_buffer = (char *)NULL;\n-#endif /* !__MSDOS__ */\n+#endif\n \n static int tcap_initialized;\n \n@@ -308,7 +308,8 @@ _rl_get_screen_size (tty, ignore_env)\n   /* If we're being compiled as part of bash, set the environment\n      variables $LINES and $COLUMNS to new values.  Otherwise, just\n      do a pair of putenv () or setenv () calls. */\n-  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);\n+  if (rl_change_environment)\n+    sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);\n \n   if (_rl_term_autowrap == 0)\n     _rl_screenwidth--;\n@@ -358,7 +359,13 @@ rl_reset_screen_size ()\n {\n   _rl_get_screen_size (fileno (rl_instream), 0);\n }\n-     \n+\n+void\n+_rl_sigwinch_resize_terminal ()\n+{\n+  _rl_get_screen_size (fileno (rl_instream), 1);\n+}\n+\t\n void\n rl_resize_terminal ()\n {\n@@ -560,7 +567,6 @@ _rl_init_terminal_io (terminal_name)\n   term_has_meta = tgetflag (\"km\") != 0;\n   if (term_has_meta == 0)\n     _rl_term_mm = _rl_term_mo = (char *)NULL;\n-\n #endif /* !__MSDOS__ */\n \n   /* Attempt to find and bind the arrow keys.  Do not override already\n@@ -694,17 +700,16 @@ rl_ding ()\n \tdefault:\n \t  break;\n \tcase VISIBLE_BELL:\n-#ifdef __MSDOS__\n-\t  ScreenVisualBell ();\n-\t  break;\n-#else\n \t  if (_rl_visible_bell)\n \t    {\n+#ifdef __DJGPP__\n+\t      ScreenVisualBell ();\n+#else\n \t      tputs (_rl_visible_bell, 1, _rl_output_character_function);\n+#endif\n \t      break;\n \t    }\n \t  /* FALLTHROUGH */\n-#endif\n \tcase AUDIBLE_BELL:\n \t  fprintf (stderr, \"\\007\");\n \t  fflush (stderr);\n@@ -721,12 +726,29 @@ rl_ding ()\n /*\t\t\t\t\t\t\t\t    */\n /* **************************************************************** */\n \n+static int enabled_meta = 0;\t/* flag indicating we enabled meta mode */\n+\n void\n _rl_enable_meta_key ()\n {\n #if !defined (__DJGPP__)\n   if (term_has_meta && _rl_term_mm)\n-    tputs (_rl_term_mm, 1, _rl_output_character_function);\n+    {\n+      tputs (_rl_term_mm, 1, _rl_output_character_function);\n+      enabled_meta = 1;\n+    }\n+#endif\n+}\n+\n+void\n+_rl_disable_meta_key ()\n+{\n+#if !defined (__DJGPP__)\n+  if (term_has_meta && _rl_term_mo && enabled_meta)\n+    {\n+      tputs (_rl_term_mo, 1, _rl_output_character_function);\n+      enabled_meta = 0;\n+    }\n #endif\n }\n "
    },
    {
      "sha": "c353252bc9fbe8adee0bf206a994c2d85d9eee73",
      "filename": "readline/text.c",
      "status": "modified",
      "additions": 70,
      "deletions": 22,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/text.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/text.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/text.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* text.c -- text handling commands for readline. */\n \n-/* Copyright (C) 1987-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -71,6 +71,8 @@ static int _rl_char_search_callback PARAMS((_rl_callback_generic_arg *));\n    rl_insert_text.  Text blocks larger than this are divided. */\n #define TEXT_COUNT_MAX\t1024\n \n+int _rl_optimize_typeahead = 1;\t/* rl_insert tries to read typeahead */\n+\n /* **************************************************************** */\n /*\t\t\t\t\t\t\t\t    */\n /*\t\t\tInsert and Delete\t\t\t    */\n@@ -240,7 +242,7 @@ rl_replace_line (text, clear_undo)\n    this is the same as rl_end.\n \n    Any command that is called interactively receives two arguments.\n-   The first is a count: the numeric arg pased to this command.\n+   The first is a count: the numeric arg passed to this command.\n    The second is the key which invoked this command.\n */\n \n@@ -570,7 +572,7 @@ rl_refresh_line (ignore1, ignore2)\n \n   _rl_clear_to_eol (0);\t\t/* arg of 0 means to not use spaces */\n \n-  rl_forced_update_display ();\n+  rl_redraw_prompt_last_line ();\n   rl_display_fixed = 1;\n \n   return 0;\n@@ -608,7 +610,7 @@ rl_skip_csi_sequence (count, key)\n   while (ch >= 0x20 && ch < 0x40);\n   RL_UNSETSTATE (RL_STATE_MOREINPUT);\n \n-  return 0;\n+  return (ch < 0);\n }\n \n int\n@@ -620,6 +622,8 @@ rl_arrow_keys (count, c)\n   RL_SETSTATE(RL_STATE_MOREINPUT);\n   ch = rl_read_key ();\n   RL_UNSETSTATE(RL_STATE_MOREINPUT);\n+  if (ch < 0)\n+    return (1);\n \n   switch (_rl_to_upper (ch))\n     {\n@@ -826,7 +830,7 @@ _rl_insert_char (count, c)\n \t pending characters that are bound to rl_insert, and insert\n \t them all.  Don't do this if we're current reading input from\n \t a macro. */\n-      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_any_typein ())\n+      if ((RL_ISSTATE (RL_STATE_MACROINPUT) == 0) && _rl_pushed_input_available ())\n \t_rl_insert_typein (c);\n       else\n \t{\n@@ -890,8 +894,49 @@ int\n rl_insert (count, c)\n      int count, c;\n {\n-  return (rl_insert_mode == RL_IM_INSERT ? _rl_insert_char (count, c)\n-  \t\t\t\t\t : _rl_overwrite_char (count, c));\n+  int r, n, x;\n+\n+  r = (rl_insert_mode == RL_IM_INSERT) ? _rl_insert_char (count, c) : _rl_overwrite_char (count, c);\n+\n+  /* XXX -- attempt to batch-insert pending input that maps to self-insert */\n+  x = 0;\n+  n = (unsigned short)-2;\n+  while (_rl_optimize_typeahead &&\n+\t (RL_ISSTATE (RL_STATE_INPUTPENDING|RL_STATE_MACROINPUT) == 0) &&\n+\t _rl_pushed_input_available () == 0 &&\n+\t _rl_input_queued (0) &&\n+\t (n = rl_read_key ()) > 0 &&\n+\t _rl_keymap[(unsigned char)n].type == ISFUNC &&\n+\t _rl_keymap[(unsigned char)n].function == rl_insert)\n+    {\n+      r = (rl_insert_mode == RL_IM_INSERT) ? _rl_insert_char (1, n) : _rl_overwrite_char (1, n);\n+      /* _rl_insert_char keeps its own set of pending characters to compose a\n+\t complete multibyte character, and only returns 1 if it sees a character\n+\t that's part of a multibyte character but too short to complete one.  We\n+\t can try to read another character in the hopes that we will get the\n+\t next one or just punt.  Right now we try to read another character.\n+\t We don't want to call rl_insert_next if _rl_insert_char has already\n+\t stored the character in the pending_bytes array because that will\n+\t result in doubled input. */\n+      n = (unsigned short)-2;\n+      x++;\t\t/* count of bytes of typeahead read, currently unused */\n+      if (r == 1)\t/* read partial multibyte character */\n+\tcontinue;\n+      if (rl_done || r != 0)\n+\tbreak;\n+    }\n+\n+  if (n != (unsigned short)-2)\t\t/* -2 = sentinel value for having inserted N */\n+    {\n+      /* setting rl_pending_input inhibits setting rl_last_func so we do it\n+\t ourselves here */\n+      rl_last_func = rl_insert; \n+      _rl_reset_argument ();\n+      rl_executing_keyseq[rl_key_sequence_length = 0] = '\\0';\n+      r = rl_execute_next (n);\n+    }\n+\n+  return r;\n }\n \n /* Insert the next typed character verbatim. */\n@@ -906,7 +951,10 @@ _rl_insert_next (count)\n   RL_UNSETSTATE(RL_STATE_MOREINPUT);\n \n   if (c < 0)\n-    return -1;\n+    return 1;\n+\n+  if (RL_ISSTATE (RL_STATE_MACRODEF))\n+    _rl_add_macro_char (c);\n \n #if defined (HANDLE_SIGNALS)\n   if (RL_ISSTATE (RL_STATE_CALLBACK) == 0)\n@@ -1063,7 +1111,7 @@ rl_rubout (count, key)\n   if (!rl_point)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   if (rl_insert_mode == RL_IM_OVERWRITE)\n@@ -1086,7 +1134,7 @@ _rl_rubout_char (count, key)\n   if (rl_point == 0)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   orig_point = rl_point;\n@@ -1100,7 +1148,7 @@ _rl_rubout_char (count, key)\n       c = rl_line_buffer[--rl_point];\n       rl_delete_text (rl_point, orig_point);\n       /* The erase-at-end-of-line hack is of questionable merit now. */\n-      if (rl_point == rl_end && ISPRINT (c) && _rl_last_c_pos)\n+      if (rl_point == rl_end && ISPRINT ((unsigned char)c) && _rl_last_c_pos)\n \t{\n \t  int l;\n \t  l = rl_character_len (c, rl_point);\n@@ -1130,7 +1178,7 @@ rl_delete (count, key)\n   if (rl_point == rl_end)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   if (count > 1 || rl_explicit_arg)\n@@ -1300,7 +1348,7 @@ rl_change_case (count, op)\n   if (op != UpCase && op != DownCase && op != CapCase)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   if (count < 0)\n@@ -1334,7 +1382,7 @@ rl_change_case (count, op)\n \t}\n       else\n \tnop = op;\n-      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii (c))\n+      if (MB_CUR_MAX == 1 || rl_byte_oriented || isascii ((unsigned char)c))\n \t{\n \t  nc = (nop == UpCase) ? _rl_to_upper (c) : _rl_to_lower (c);\n \t  rl_line_buffer[start] = nc;\n@@ -1400,7 +1448,7 @@ rl_transpose_words (count, key)\n     {\n       rl_ding ();\n       rl_point = orig_point;\n-      return -1;\n+      return 1;\n     }\n \n   /* Get the text of the words. */\n@@ -1453,7 +1501,7 @@ rl_transpose_chars (count, key)\n   if (!rl_point || rl_end < 2)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   rl_begin_undo_group ();\n@@ -1516,7 +1564,7 @@ _rl_char_search_internal (count, dir, schar)\n #endif\n \n   if (dir == 0)\n-    return -1;\n+    return 1;\n \n   pos = rl_point;\n   inc = (dir < 0) ? -1 : 1;\n@@ -1525,7 +1573,7 @@ _rl_char_search_internal (count, dir, schar)\n       if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))\n \t{\n \t  rl_ding ();\n-\t  return -1;\n+\t  return 1;\n \t}\n \n #if defined (HANDLE_MULTIBYTE)\n@@ -1580,7 +1628,7 @@ _rl_char_search (count, fdir, bdir)\n   mb_len = _rl_read_mbchar (mbchar, MB_LEN_MAX);\n \n   if (mb_len <= 0)\n-    return -1;\n+    return 1;\n \n   if (count < 0)\n     return (_rl_char_search_internal (-count, bdir, mbchar, mb_len));\n@@ -1599,7 +1647,7 @@ _rl_char_search (count, fdir, bdir)\n   RL_UNSETSTATE(RL_STATE_MOREINPUT);\n \n   if (c < 0)\n-    return -1;\n+    return 1;\n \n   if (count < 0)\n     return (_rl_char_search_internal (-count, bdir, c));\n@@ -1668,7 +1716,7 @@ _rl_set_mark_at_pos (position)\n      int position;\n {\n   if (position > rl_end)\n-    return -1;\n+    return 1;\n \n   rl_mark = position;\n   return 0;\n@@ -1693,7 +1741,7 @@ rl_exchange_point_and_mark (count, key)\n   if (rl_mark == -1)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n   else\n     SWAP (rl_point, rl_mark);"
    },
    {
      "sha": "95bc4215c525466f18acfecc1549693600fe4748",
      "filename": "readline/tilde.c",
      "status": "modified",
      "additions": 7,
      "deletions": 3,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/tilde.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/tilde.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/tilde.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -236,7 +236,11 @@ tilde_expand (string)\n       string += end;\n \n       expansion = tilde_expand_word (tilde_word);\n-      xfree (tilde_word);\n+\n+      if (expansion == 0)\n+\texpansion = tilde_word;\n+      else\n+\txfree (tilde_word);\t\n \n       len = strlen (expansion);\n #ifdef __CYGWIN__\n@@ -360,8 +364,8 @@ tilde_expand_word (filename)\n     {\n       /* Prefix $HOME to the rest of the string. */\n       expansion = sh_get_env_value (\"HOME\");\n-#ifdef _WIN32\n-      if (!expansion)\n+#if defined (_WIN32)\n+      if (expansion == 0)\n \texpansion = sh_get_env_value (\"APPDATA\");\n #endif\n "
    },
    {
      "sha": "58363040ce0ddfa7f4265693fc33faeb76dd193c",
      "filename": "readline/undo.c",
      "status": "modified",
      "additions": 35,
      "deletions": 13,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/undo.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/undo.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/undo.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,6 @@\n-/* readline.c -- a general facility for reading lines of input\n-   with emacs style editing and completion. */\n+/* undo.c - manage list of changes to lines, offering opportunity to undo them */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -50,7 +49,7 @@\n #include \"rlprivate.h\"\n #include \"xmalloc.h\"\n \n-extern void replace_history_data PARAMS((int, histdata_t *, histdata_t *));\n+extern void _hs_replace_history_data PARAMS((int, histdata_t *, histdata_t *));\n \n /* Non-zero tells rl_delete_text and rl_insert_text to not add to\n    the undo list. */\n@@ -101,25 +100,35 @@ rl_add_undo (what, start, end, text)\n   rl_undo_list = temp;\n }\n \n-/* Free the existing undo list. */\n+/* Free an UNDO_LIST */\n void\n-rl_free_undo_list ()\n+_rl_free_undo_list (ul)\n+     UNDO_LIST *ul;\n {\n-  UNDO_LIST *release, *orig_list;\n+  UNDO_LIST *release;\n \n-  orig_list = rl_undo_list;\n-  while (rl_undo_list)\n+  while (ul)\n     {\n-      release = rl_undo_list;\n-      rl_undo_list = rl_undo_list->next;\n+      release = ul;\n+      ul = ul->next;\n \n       if (release->what == UNDO_DELETE)\n \txfree (release->text);\n \n       xfree (release);\n     }\n+}\n+\n+/* Free the existing undo list. */\n+void\n+rl_free_undo_list ()\n+{\n+  UNDO_LIST *release, *orig_list;\n+\n+  orig_list = rl_undo_list;\n+  _rl_free_undo_list (rl_undo_list);\n   rl_undo_list = (UNDO_LIST *)NULL;\n-  replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)NULL);\n+  _hs_replace_history_data (-1, (histdata_t *)orig_list, (histdata_t *)NULL);\n }\n \n UNDO_LIST *\n@@ -168,6 +177,7 @@ rl_do_undo ()\n {\n   UNDO_LIST *release;\n   int waiting_for_begin, start, end;\n+  HIST_ENTRY *cur, *temp;\n \n #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))\n \n@@ -222,7 +232,19 @@ rl_do_undo ()\n \n       release = rl_undo_list;\n       rl_undo_list = rl_undo_list->next;\n-      replace_history_data (-1, (histdata_t *)release, (histdata_t *)rl_undo_list);\n+\n+      /* If we are editing a history entry, make sure the change is replicated\n+\t in the history entry's line */\n+      cur = current_history ();\n+      if (cur && cur->data && (UNDO_LIST *)cur->data == release)\n+\t{\n+\t  temp = replace_history_entry (where_history (), rl_line_buffer, (histdata_t)rl_undo_list);\n+\t  xfree (temp->line);\n+\t  FREE (temp->timestamp);\n+\t  xfree (temp);\n+\t}\n+\n+      _hs_replace_history_data (-1, (histdata_t *)release, (histdata_t *)rl_undo_list);\n \n       xfree (release);\n     }"
    },
    {
      "sha": "28a9d9d1045ba6f491e47b434b4594cff3ad90b2",
      "filename": "readline/util.c",
      "status": "modified",
      "additions": 70,
      "deletions": 10,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/util.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* util.c -- readline utility functions */\n \n-/* Copyright (C) 1987-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2015 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -108,8 +108,11 @@ _rl_abort_internal ()\n   while (rl_executing_macro)\n     _rl_pop_executing_macro ();\n \n+  RL_UNSETSTATE (RL_STATE_MULTIKEY);\t/* XXX */\n+\n   rl_last_func = (rl_command_func_t *)NULL;\n-  longjmp (_rl_top_level, 1);\n+\n+  _rl_longjmp (_rl_top_level, 1);\n   return (0);\n }\n \n@@ -195,12 +198,14 @@ rl_tilde_expand (ignore, key)\n       xfree (homedir);\n       return (0);\n     }\n-  else if (rl_line_buffer[start] != '~')\n+  else if (start >= 0 && rl_line_buffer[start] != '~')\n     {\n       for (; !whitespace (rl_line_buffer[start]) && start >= 0; start--)\n         ;\n       start++;\n     }\n+  else if (start < 0)\n+    start = 0;\n \n   end = start;\n   do\n@@ -370,11 +375,13 @@ _rl_strpbrk (string1, string2)\n    doesn't matter (strncasecmp). */\n int\n _rl_strnicmp (string1, string2, count)\n-     char *string1, *string2;\n+     const char *string1;\n+     const char *string2;\n      int count;\n {\n-  register char *s1, *s2;\n-  int d;\n+  register const char *s1;\n+  register const char *s2;\n+  register int d;\n \n   if (count <= 0 || (string1 == string2))\n     return 0;\n@@ -398,10 +405,12 @@ _rl_strnicmp (string1, string2, count)\n /* strcmp (), but caseless (strcasecmp). */\n int\n _rl_stricmp (string1, string2)\n-     char *string1, *string2;\n+     const char *string1;\n+     const char *string2;\n {\n-  register char *s1, *s2;\n-  int d;\n+  register const char *s1;\n+  register const char *s2;\n+  register int d;\n \n   s1 = string1;\n   s2 = string2;\n@@ -469,6 +478,7 @@ _rl_savestring (s)\n   return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));\n }\n \n+#if defined (DEBUG)\n #if defined (USE_VARARGS)\n static FILE *_rl_tracefp;\n \n@@ -504,7 +514,7 @@ _rl_trace (va_alist)\n int\n _rl_tropen ()\n {\n-  char fnbuf[128];\n+  char fnbuf[128], *x;\n \n   if (_rl_tracefp)\n     fclose (_rl_tracefp);\n@@ -534,4 +544,54 @@ _rl_trclose ()\n   return r;\n }\n \n+void\n+_rl_settracefp (fp)\n+     FILE *fp;\n+{\n+  _rl_tracefp = fp;\n+}\n+#endif\n+#endif /* DEBUG */\n+\n+\n+#if HAVE_DECL_AUDIT_USER_TTY && defined (HAVE_LIBAUDIT_H) && defined (ENABLE_TTY_AUDIT_SUPPORT)\n+#include <sys/socket.h>\n+#include <libaudit.h>\n+#include <linux/audit.h>\n+#include <linux/netlink.h>\n+\n+/* Report STRING to the audit system. */\n+void\n+_rl_audit_tty (string)\n+     char *string;\n+{\n+  struct audit_message req;\n+  struct sockaddr_nl addr;\n+  size_t size;\n+  int fd;\n+\n+  fd = socket (PF_NETLINK, SOCK_RAW, NETLINK_AUDIT);\n+  if (fd < 0)\n+    return;\n+  size = strlen (string) + 1;\n+\n+  if (NLMSG_SPACE (size) > MAX_AUDIT_MESSAGE_LENGTH)\n+    return;\n+\n+  memset (&req, 0, sizeof(req));\n+  req.nlh.nlmsg_len = NLMSG_SPACE (size);\n+  req.nlh.nlmsg_type = AUDIT_USER_TTY;\n+  req.nlh.nlmsg_flags = NLM_F_REQUEST;\n+  req.nlh.nlmsg_seq = 0;\n+  if (size && string)\n+    memcpy (NLMSG_DATA(&req.nlh), string, size);\n+  memset (&addr, 0, sizeof(addr));\n+\n+  addr.nl_family = AF_NETLINK;\n+  addr.nl_pid = 0;\n+  addr.nl_groups = 0;\n+\n+  sendto (fd, &req, req.nlh.nlmsg_len, 0, (struct sockaddr*)&addr, sizeof(addr));\n+  close (fd);\n+}\n #endif"
    },
    {
      "sha": "e5da2e0fa0b572ce0e3aa938b6a1076e2ed787fc",
      "filename": "readline/vi_keymap.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/vi_keymap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/vi_keymap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/vi_keymap.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,6 +1,6 @@\n /* vi_keymap.c -- the keymap for vi_mode in readline (). */\n \n-/* Copyright (C) 1987-2009 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -55,7 +55,7 @@ KEYMAP_ENTRY_ARRAY vi_movement_keymap = {\n   { ISFUNC, rl_transpose_chars },\t\t/* Control-t */\n   { ISFUNC, rl_unix_line_discard },\t\t/* Control-u */\n   { ISFUNC, rl_quoted_insert },\t\t\t/* Control-v */\n-  { ISFUNC, rl_unix_word_rubout },\t\t/* Control-w */\n+  { ISFUNC, rl_vi_unix_word_rubout },\t\t/* Control-w */\n   { ISFUNC, (rl_command_func_t *)0x0 },\t\t/* Control-x */\n   { ISFUNC, rl_yank },\t\t\t\t/* Control-y */\n   { ISFUNC, (rl_command_func_t *)0x0 },\t\t/* Control-z */\n@@ -309,7 +309,6 @@ KEYMAP_ENTRY_ARRAY vi_movement_keymap = {\n #endif /* KEYMAP_SIZE > 128 */\n };\n \n-\n KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {\n   /* The regular control keys come first. */\n   { ISFUNC, (rl_command_func_t *)0x0 },\t\t/* Control-@ */\n@@ -335,7 +334,7 @@ KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {\n   { ISFUNC, rl_transpose_chars },\t\t/* Control-t */\n   { ISFUNC, rl_unix_line_discard },\t\t/* Control-u */\n   { ISFUNC, rl_quoted_insert },\t\t\t/* Control-v */\n-  { ISFUNC, rl_unix_word_rubout },\t\t/* Control-w */\n+  { ISFUNC, rl_vi_unix_word_rubout },\t\t/* Control-w */\n   { ISFUNC, rl_insert },\t\t\t/* Control-x */\n   { ISFUNC, rl_yank },\t\t\t\t/* Control-y */\n   { ISFUNC, rl_insert },\t\t\t/* Control-z */"
    },
    {
      "sha": "56d2e72fb7f2da12747c93db67404777fd5fd1cd",
      "filename": "readline/vi_mode.c",
      "status": "modified",
      "additions": 248,
      "deletions": 43,
      "changes": 291,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/vi_mode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/775e241e9c5f2b2ff2b59972ab70e5f20763fae6/readline/vi_mode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/readline/vi_mode.c?ref=775e241e9c5f2b2ff2b59972ab70e5f20763fae6",
      "patch": "@@ -1,7 +1,7 @@\n /* vi_mode.c -- A vi emulation mode for Bash.\n    Derived from code written by Jeff Sparkes (jsparkes@bnr.ca).  */\n \n-/* Copyright (C) 1987-2010 Free Software Foundation, Inc.\n+/* Copyright (C) 1987-2016 Free Software Foundation, Inc.\n \n    This file is part of the GNU Readline Library (Readline), a library\n    for reading lines of text with interactive input and history editing.      \n@@ -67,6 +67,9 @@ int _rl_vi_last_command = 'i';\t/* default `.' puts you in insert mode */\n \n _rl_vimotion_cxt *_rl_vimvcxt = 0;\n \n+/* Non-zero indicates we are redoing a vi-mode command with `.' */\n+int _rl_vi_redoing;\n+\n /* Non-zero means enter insertion mode. */\n static int _rl_vi_doing_insert;\n \n@@ -100,17 +103,19 @@ static int _rl_vi_last_replacement;\n \n static int _rl_vi_last_key_before_insert;\n \n-static int vi_redoing;\n-\n /* Text modification commands.  These are the `redoable' commands. */\n static const char * const vi_textmod = \"_*\\\\AaIiCcDdPpYyRrSsXx~\";\n \n /* Arrays for the saved marks. */\n static int vi_mark_chars['z' - 'a' + 1];\n \n+static void _rl_vi_replace_insert PARAMS((int));\n+static void _rl_vi_save_replace PARAMS((void));\n static void _rl_vi_stuff_insert PARAMS((int));\n static void _rl_vi_save_insert PARAMS((UNDO_LIST *));\n \n+static void vi_save_insert_buffer PARAMS ((int, int));\n+\n static void _rl_vi_backup PARAMS((void));\n \n static int _rl_vi_arg_dispatch PARAMS((int));\n@@ -188,6 +193,29 @@ _rl_vi_textmod_command (c)\n   return (member (c, vi_textmod));\n }\n \n+int\n+_rl_vi_motion_command (c)\n+     int c;\n+{\n+  return (member (c, vi_motion));\n+}\n+\n+static void\n+_rl_vi_replace_insert (count)\n+     int count;\n+{\n+  int nchars;\n+\n+  nchars = strlen (vi_insert_buffer);\n+\n+  rl_begin_undo_group ();\n+  while (count--)\n+    /* nchars-1 to compensate for _rl_replace_text using `end+1' in call\n+       to rl_delete_text */\n+    _rl_replace_text (vi_insert_buffer, rl_point, rl_point+nchars-1);\n+  rl_end_undo_group ();\n+}\n+\n static void\n _rl_vi_stuff_insert (count)\n      int count;\n@@ -207,14 +235,14 @@ rl_vi_redo (count, c)\n {\n   int r;\n \n-  if (!rl_explicit_arg)\n+  if (rl_explicit_arg == 0)\n     {\n       rl_numeric_arg = _rl_vi_last_repeat;\n       rl_arg_sign = _rl_vi_last_arg_sign;\n     }\n \n   r = 0;\n-  vi_redoing = 1;\n+  _rl_vi_redoing = 1;\n   /* If we're redoing an insert with `i', stuff in the inserted text\n      and do not go into insertion mode. */\n   if (_rl_vi_last_command == 'i' && vi_insert_buffer && *vi_insert_buffer)\n@@ -224,6 +252,13 @@ rl_vi_redo (count, c)\n       if (rl_point > 0)\n \t_rl_vi_backup ();\n     }\n+  else if (_rl_vi_last_command == 'R' && vi_insert_buffer && *vi_insert_buffer)\n+    {\n+      _rl_vi_replace_insert (count);\n+      /* And back up point over the last character inserted. */\n+      if (rl_point > 0)\n+\t_rl_vi_backup ();\n+    }\n   /* Ditto for redoing an insert with `I', but move to the beginning of the\n      line like the `I' command does. */\n   else if (_rl_vi_last_command == 'I' && vi_insert_buffer && *vi_insert_buffer)\n@@ -253,7 +288,8 @@ rl_vi_redo (count, c)\n     }\n   else\n     r = _rl_dispatch (_rl_vi_last_command, _rl_keymap);\n-  vi_redoing = 0;\n+\n+  _rl_vi_redoing = 0;\n \n   return (r);\n }\n@@ -437,7 +473,7 @@ rl_vi_end_word (count, key)\n   if (count < 0)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   if (_rl_uppercase_p (key))\n@@ -679,6 +715,8 @@ rl_vi_insertion_mode (count, key)\n {\n   _rl_keymap = vi_insertion_keymap;\n   _rl_vi_last_key_before_insert = key;\n+  if (_rl_show_mode_in_prompt)\n+    _rl_reset_prompt ();\n   return (0);\n }\n \n@@ -690,6 +728,43 @@ rl_vi_insert_mode (count, key)\n   return (0);\n }\n \n+static void\n+vi_save_insert_buffer (start, len)\n+     int start, len;\n+{\n+  /* Same code as _rl_vi_save_insert below */\n+  if (len >= vi_insert_buffer_size)\n+    {\n+      vi_insert_buffer_size += (len + 32) - (len % 32);\n+      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);\n+    }\n+  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);\n+  vi_insert_buffer[len-1] = '\\0';\n+}\n+\n+static void\n+_rl_vi_save_replace ()\n+{\n+  int len, start, end;\n+  UNDO_LIST *up;\n+\n+  up = rl_undo_list;\n+  if (up == 0 || up->what != UNDO_END || vi_replace_count <= 0)\n+    {\n+      if (vi_insert_buffer_size >= 1)\n+\tvi_insert_buffer[0] = '\\0';\n+      return;\n+    }\n+  /* Let's try it the quick and easy way for now.  This should essentially\n+     accommodate every UNDO_INSERT and save the inserted text to\n+     vi_insert_buffer */\n+  end = rl_point;\n+  start = end - vi_replace_count + 1;\n+  len = vi_replace_count + 1;\n+\n+  vi_save_insert_buffer (start, len);  \n+}\n+\n static void\n _rl_vi_save_insert (up)\n       UNDO_LIST *up;\n@@ -706,13 +781,8 @@ _rl_vi_save_insert (up)\n   start = up->start;\n   end = up->end;\n   len = end - start + 1;\n-  if (len >= vi_insert_buffer_size)\n-    {\n-      vi_insert_buffer_size += (len + 32) - (len % 32);\n-      vi_insert_buffer = (char *)xrealloc (vi_insert_buffer, vi_insert_buffer_size);\n-    }\n-  strncpy (vi_insert_buffer, rl_line_buffer + start, len - 1);\n-  vi_insert_buffer[len-1] = '\\0';\n+\n+  vi_save_insert_buffer (start, len);\n }\n     \n void\n@@ -728,7 +798,10 @@ _rl_vi_done_inserting ()\n \t on absolute indices into the line which may change (though they\n \t probably will not). */\n       _rl_vi_doing_insert = 0;\n-      _rl_vi_save_insert (rl_undo_list->next);\n+      if (_rl_vi_last_key_before_insert == 'R')\n+\t_rl_vi_save_replace ();\t\t/* Half the battle */\n+      else\n+\t_rl_vi_save_insert (rl_undo_list->next);\n       vi_continued_command = 1;\n     }\n   else\n@@ -762,6 +835,9 @@ rl_vi_movement_mode (count, key)\n   if (RL_ISSTATE (RL_STATE_VICMDONCE) == 0)\n     rl_free_undo_list ();\n \n+  if (_rl_show_mode_in_prompt)\n+    _rl_reset_prompt ();\n+\n   RL_SETSTATE (RL_STATE_VICMDONCE);\n   return (0);\n }\n@@ -1022,28 +1098,55 @@ static int\n rl_domove_motion_callback (m)\n      _rl_vimotion_cxt *m;\n {\n-  int c, save, r;\n-  int old_end;\n+  int c;\n \n   _rl_vi_last_motion = c = m->motion;\n \n   /* Append a blank character temporarily so that the motion routines\n-     work right at the end of the line. */\n-  old_end = rl_end;\n+     work right at the end of the line.  Original value of rl_end is saved\n+     as m->end. */\n   rl_line_buffer[rl_end++] = ' ';\n   rl_line_buffer[rl_end] = '\\0';\n \n   _rl_dispatch (c, _rl_keymap);\n \n-  /* Remove the blank that we added. */\n-  rl_end = old_end;\n+#if defined (READLINE_CALLBACKS)\n+  if (RL_ISSTATE (RL_STATE_CALLBACK))\n+    {\n+      /* Messy case where char search can be vi motion command; see rest of\n+\t details in callback.c.  vi_char_search and callback_char_search just\n+\t set and unset the CHARSEARCH state.  This is where any vi motion\n+\t command that needs to set its own state should be handled, with any\n+\t corresponding code to manage that state in callback.c */\n+      if (RL_ISSTATE (RL_STATE_CHARSEARCH))\n+\treturn 0;\n+      else\n+\treturn (_rl_vi_domove_motion_cleanup (c, m));\n+    }\n+#endif\n+\n+  return (_rl_vi_domove_motion_cleanup (c, m));\n+}\n+\n+int\n+_rl_vi_domove_motion_cleanup (c, m)\n+     int c;\n+     _rl_vimotion_cxt *m;\n+{\n+  int r;\n+\n+  /* Remove the blank that we added in rl_domove_motion_callback. */\n+  rl_end = m->end;\n   rl_line_buffer[rl_end] = '\\0';\n   if (rl_point > rl_end)\n     rl_point = rl_end;\n \n   /* No change in position means the command failed. */\n   if (rl_mark == rl_point)\n-    return (-1);\n+    {\n+      RL_UNSETSTATE (RL_STATE_VIMOTION);\n+      return (-1);\n+    }\n \n   /* rl_vi_f[wW]ord () leaves the cursor on the first character of the next\n      word.  If we are not at the end of the line, and we are on a\n@@ -1177,8 +1280,8 @@ _rl_vi_domove_callback (m)\n   int c, r;\n \n   m->motion = c = rl_vi_domove_getchar (m);\n-  /* XXX - what to do if this returns -1?  Should we return 1 for eof to\n-     callback code? */\n+  if (c < 0)\n+    return 1;\t\t/* EOF */\n   r = rl_domove_read_callback (m);\n \n   return ((r == 0) ? r : 1);\t/* normalize return values */\n@@ -1234,11 +1337,19 @@ rl_vi_delete_to (count, key)\n       _rl_vimvcxt->motion = '$';\n       r = rl_domove_motion_callback (_rl_vimvcxt);\n     }\n-  else if (vi_redoing)\n+  else if (_rl_vi_redoing && _rl_vi_last_motion != 'd')\t/* `dd' is special */\n     {\n       _rl_vimvcxt->motion = _rl_vi_last_motion;\n       r = rl_domove_motion_callback (_rl_vimvcxt);\n     }\n+  else if (_rl_vi_redoing)\t\t/* handle redoing `dd' here */\n+    {\n+      _rl_vimvcxt->motion = _rl_vi_last_motion;\n+      rl_mark = rl_end;\n+      rl_beg_of_line (1, key);\n+      RL_UNSETSTATE (RL_STATE_VIMOTION);\n+      r = vidomove_dispatch (_rl_vimvcxt);\n+    }\n #if defined (READLINE_CALLBACKS)\n   else if (RL_ISSTATE (RL_STATE_CALLBACK))\n     {\n@@ -1276,7 +1387,7 @@ vi_change_dispatch (m)\n   if ((_rl_to_upper (m->motion) == 'W') && rl_point < m->start)\n     rl_point = m->start;\n \n-  if (vi_redoing)\n+  if (_rl_vi_redoing)\n     {\n       if (vi_insert_buffer && *vi_insert_buffer)\n \trl_begin_undo_group ();\n@@ -1316,11 +1427,19 @@ rl_vi_change_to (count, key)\n       _rl_vimvcxt->motion = '$';\n       r = rl_domove_motion_callback (_rl_vimvcxt);\n     }\n-  else if (vi_redoing)\n+  else if (_rl_vi_redoing && _rl_vi_last_motion != 'c')\t/* `cc' is special */\n     {\n       _rl_vimvcxt->motion = _rl_vi_last_motion;\n       r = rl_domove_motion_callback (_rl_vimvcxt);\n     }\n+  else if (_rl_vi_redoing)\t\t/* handle redoing `cc' here */\n+    {\n+      _rl_vimvcxt->motion = _rl_vi_last_motion;\n+      rl_mark = rl_end;\n+      rl_beg_of_line (1, key);\n+      RL_UNSETSTATE (RL_STATE_VIMOTION);\n+      r = vidomove_dispatch (_rl_vimvcxt);\n+    }\n #if defined (READLINE_CALLBACKS)\n   else if (RL_ISSTATE (RL_STATE_CALLBACK))\n     {\n@@ -1377,6 +1496,19 @@ rl_vi_yank_to (count, key)\n       _rl_vimvcxt->motion = '$';\n       r = rl_domove_motion_callback (_rl_vimvcxt);\n     }\n+  else if (_rl_vi_redoing && _rl_vi_last_motion != 'y')\t/* `yy' is special */\n+    {\n+      _rl_vimvcxt->motion = _rl_vi_last_motion;\n+      r = rl_domove_motion_callback (_rl_vimvcxt);\n+    }\n+  else if (_rl_vi_redoing)\t\t\t/* handle redoing `yy' here */\n+    {\n+      _rl_vimvcxt->motion = _rl_vi_last_motion;\n+      rl_mark = rl_end;\n+      rl_beg_of_line (1, key);\n+      RL_UNSETSTATE (RL_STATE_VIMOTION);\n+      r = vidomove_dispatch (_rl_vimvcxt);\n+    }\n #if defined (READLINE_CALLBACKS)\n   else if (RL_ISSTATE (RL_STATE_CALLBACK))\n     {\n@@ -1438,7 +1570,7 @@ rl_vi_rubout (count, key)\n   if (rl_point == 0)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   opoint = rl_point;\n@@ -1469,7 +1601,7 @@ rl_vi_delete (count, key)\n   if (rl_end == 0)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)\n@@ -1488,6 +1620,62 @@ rl_vi_delete (count, key)\n   return (0);\n }\n \n+/* This does what Posix specifies vi-mode C-w to do: using whitespace and\n+   punctuation characters as the word boundaries. */\n+\n+#define vi_unix_word_boundary(c)\t(whitespace(c) || ispunct(c))\n+\n+int\n+rl_vi_unix_word_rubout (count, key)\n+     int count, key;\n+{\n+  int orig_point;\n+\n+  if (rl_point == 0)\n+    rl_ding ();\n+  else\n+    {\n+      orig_point = rl_point;\n+      if (count <= 0)\n+\tcount = 1;\n+\n+      while (count--)\n+\t{\n+\t  /* This isn't quite what ksh93 does but it seems to match what the\n+\t     Posix description of sh specifies, with a few accommodations\n+\t     for sequences of whitespace characters between words and at\n+\t     the end of the line. */\n+\n+\t  /* Skip over whitespace at the end of the line as a special case */\n+\t  if (rl_point > 0 && (rl_line_buffer[rl_point] == 0) &&\n+\t\twhitespace (rl_line_buffer[rl_point - 1]))\n+\t    while (--rl_point > 0 && whitespace (rl_line_buffer[rl_point]))\n+\t      ;\n+\n+\t  /* If we're at the start of a word, move back to word boundary so we\n+\t     move back to the `preceding' word */\n+\t  if (rl_point > 0 && (vi_unix_word_boundary (rl_line_buffer[rl_point]) == 0) &&\n+\t\tvi_unix_word_boundary (rl_line_buffer[rl_point - 1]))\n+\t    rl_point--;\n+\n+\t  /* If we are at a word boundary (whitespace/punct), move backward\n+\t     past a sequence of word boundary characters.  If we are at the\n+\t     end of a word (non-word boundary), move back to a word boundary */\n+\t  if (rl_point > 0 && vi_unix_word_boundary (rl_line_buffer[rl_point]))\n+\t    while (rl_point && vi_unix_word_boundary (rl_line_buffer[rl_point - 1]))\n+\t      rl_point--;\n+\t  else if (rl_point > 0 && vi_unix_word_boundary (rl_line_buffer[rl_point]) == 0)\n+\t    while (rl_point && (vi_unix_word_boundary (rl_line_buffer[rl_point - 1]) == 0))\n+\t      rl_point--;\n+\t}\n+\n+      rl_kill_text (orig_point, rl_point);\n+    }\n+\n+  return 0;\n+}\n+\n+\n int\n rl_vi_back_to_indent (count, key)\n      int count, key;\n@@ -1522,14 +1710,18 @@ _rl_vi_callback_char_search (data)\n #endif\n \n   if (c <= 0)\n-    return -1;\n+    {\n+      RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n+      return -1;\n+    }\n \n #if !defined (HANDLE_MULTIBYTE)\n   _rl_vi_last_search_char = c;\n #endif\n \n   _rl_callback_func = 0;\n   _rl_want_redisplay = 1;\n+  RL_UNSETSTATE (RL_STATE_CHARSEARCH);\n \n #if defined (HANDLE_MULTIBYTE)\n   return (_rl_char_search_internal (data->count, _rl_cs_dir, _rl_vi_last_search_mbchar, _rl_vi_last_search_mblen));\n@@ -1554,13 +1746,13 @@ rl_vi_char_search (count, key)\n   if (key == ';' || key == ',')\n     {\n       if (_rl_cs_orig_dir == 0)\n-\treturn -1;\n+\treturn 1;\n #if defined (HANDLE_MULTIBYTE)\n       if (_rl_vi_last_search_mblen == 0)\n-\treturn -1;\n+\treturn 1;\n #else\n       if (_rl_vi_last_search_char == 0)\n-\treturn -1;\n+\treturn 1;\n #endif\n       _rl_cs_dir = (key == ';') ? _rl_cs_orig_dir : -_rl_cs_orig_dir;\n     }\n@@ -1585,7 +1777,7 @@ rl_vi_char_search (count, key)\n \t  break;\n \t}\n \n-      if (vi_redoing)\n+      if (_rl_vi_redoing)\n \t{\n \t  /* set target and tlen below */\n \t}\n@@ -1594,7 +1786,9 @@ rl_vi_char_search (count, key)\n \t{\n \t  _rl_callback_data = _rl_callback_data_alloc (count);\n \t  _rl_callback_data->i1 = _rl_cs_dir;\n+\t  _rl_callback_data->i2 = key;\n \t  _rl_callback_func = _rl_vi_callback_char_search;\n+\t  RL_SETSTATE (RL_STATE_CHARSEARCH);\n \t  return (0);\n \t}\n #endif\n@@ -1659,7 +1853,7 @@ rl_vi_match (ignore, key)\n \t{\n \t  rl_point = pos;\n \t  rl_ding ();\n-\t  return -1;\n+\t  return 1;\n \t}\n     }\n \n@@ -1689,7 +1883,7 @@ rl_vi_match (ignore, key)\n \t  else\n \t    {\n \t      rl_ding ();\n-\t      return -1;\n+\t      return 1;\n \t    }\n \t}\n     }\n@@ -1713,7 +1907,7 @@ rl_vi_match (ignore, key)\n \t  else\n \t    {\n \t      rl_ding ();\n-\t      return -1;\n+\t      return 1;\n \t    }\n \t}\n     }\n@@ -1819,7 +2013,7 @@ rl_vi_change_char (count, key)\n   int c;\n   char mb[MB_LEN_MAX];\n \n-  if (vi_redoing)\n+  if (_rl_vi_redoing)\n     {\n       c = _rl_vi_last_replacement;\n       mb[0] = c;\n@@ -1847,7 +2041,7 @@ rl_vi_subst (count, key)\n      int count, key;\n {\n   /* If we are redoing, rl_vi_change_to will stuff the last motion char */\n-  if (vi_redoing == 0)\n+  if (_rl_vi_redoing == 0)\n     rl_stuff_char ((key == 'S') ? 'c' : 'l');\t/* `S' == `cc', `s' == `cl' */\n \n   return (rl_vi_change_to (count, 'c'));\n@@ -1911,14 +2105,20 @@ rl_vi_replace (count, key)\n \n   vi_replace_count = 0;\n \n-  if (!vi_replace_map)\n+  if (vi_replace_map == 0)\n     {\n       vi_replace_map = rl_make_bare_keymap ();\n \n+      for (i = 0; i < ' '; i++)\n+\tif (vi_insertion_keymap[i].type == ISFUNC)\n+\t  vi_replace_map[i].function = vi_insertion_keymap[i].function;\n+\n       for (i = ' '; i < KEYMAP_SIZE; i++)\n \tvi_replace_map[i].function = rl_vi_overstrike;\n \n       vi_replace_map[RUBOUT].function = rl_vi_overstrike_delete;\n+\n+      /* Make sure these are what we want. */\n       vi_replace_map[ESC].function = rl_vi_movement_mode;\n       vi_replace_map[RETURN].function = rl_newline;\n       vi_replace_map[NEWLINE].function = rl_newline;\n@@ -1931,7 +2131,12 @@ rl_vi_replace (count, key)\n \tvi_replace_map[CTRL ('H')].function = rl_vi_overstrike_delete;\n \n     }\n+\n+  rl_vi_start_inserting (key, 1, rl_arg_sign);\n+\n+  _rl_vi_last_key_before_insert = key;\n   _rl_keymap = vi_replace_map;\n+\n   return (0);\n }\n \n@@ -1976,7 +2181,7 @@ _rl_vi_set_mark ()\n   if (ch < 0 || ch < 'a' || ch > 'z')\t/* make test against 0 explicit */\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n   ch -= 'a';\n   vi_mark_chars[ch] = rl_point;\n@@ -2028,14 +2233,14 @@ _rl_vi_goto_mark ()\n   else if (ch < 0 || ch < 'a' || ch > 'z')\t/* make test against 0 explicit */\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n \n   ch -= 'a';\n   if (vi_mark_chars[ch] == -1)\n     {\n       rl_ding ();\n-      return -1;\n+      return 1;\n     }\n   rl_point = vi_mark_chars[ch];\n   return 0;"
    }
  ]
}