{
  "sha": "3cbc7ac344cd6b500b54588a9099c037de58e75a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2NiYzdhYzM0NGNkNmI1MDBiNTQ1ODhhOTA5OWMwMzdkZTU4ZTc1YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-16T22:34:07Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-16T22:34:08Z"
    },
    "message": "Rewrite the Rust expression parser\n\nThe Rust expression parser was written to construct its own AST, then\nlower this to GDB expressions.  I did this primarily because the old\nexpressions were difficult to work with; after rewriting those, I\nrealized I could remove the AST from the Rust parser.\n\nAfter looking at this, I realized it might be simpler to rewrite the\nparser.  This patch reimplements it as a recursive-descent parser.  I\nkept a fair amount of the existing code -- the lexer is pulled in\nnearly unchanged.\n\nThere are several benefits to this approach:\n\n* The parser is shorter now (from 2882 LOC to 2351).\n* The parser is just ordinary C++ code that can be debugged in the\n  usual way.\n* Memory management in the parser is now straightforward, as\n  parsing methods simply return a unique pointer or vector.\n\nThis required a couple of minor changes to the test suite, as some\nerrors have changed.\n\nWhile this passes the tests, it's possible there are lurking bugs,\nparticularly around error handling.\n\ngdb/ChangeLog\n2021-04-16  Tom Tromey  <tom@tromey.com>\n\n\t* rust-parse.c: New file.\n\t* rust-exp.y: Remove.\n\t* Makefile.in (COMMON_SFILES): Add rust-parse.c.\n\t(SFILES): Remove rust-exp.y.\n\t(YYFILES, local-maintainer-clean): Remove rust-exp.c.\n\ngdb/testsuite/ChangeLog\n2021-04-16  Tom Tromey  <tom@tromey.com>\n\n\t* gdb.rust/simple.exp: Change error text.\n\t* gdb.rust/expr.exp: Change error text.",
    "tree": {
      "sha": "d65283bae6379d5781766b52fb72a5b7b9dbe987",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d65283bae6379d5781766b52fb72a5b7b9dbe987"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3cbc7ac344cd6b500b54588a9099c037de58e75a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3cbc7ac344cd6b500b54588a9099c037de58e75a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3cbc7ac344cd6b500b54588a9099c037de58e75a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3cbc7ac344cd6b500b54588a9099c037de58e75a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "458620aabb33d9b0efa61d0fb402c8d19e65eabd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/458620aabb33d9b0efa61d0fb402c8d19e65eabd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/458620aabb33d9b0efa61d0fb402c8d19e65eabd"
    }
  ],
  "stats": {
    "total": 5263,
    "additions": 2373,
    "deletions": 2890
  },
  "files": [
    {
      "sha": "d5b6c30908453c9d515f0cfb6baf8c83f8186f48",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -1,3 +1,11 @@\n+2021-04-16  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-parse.c: New file.\n+\t* rust-exp.y: Remove.\n+\t* Makefile.in (COMMON_SFILES): Add rust-parse.c.\n+\t(SFILES): Remove rust-exp.y.\n+\t(YYFILES, local-maintainer-clean): Remove rust-exp.c.\n+\n 2021-04-16  Luis Machado  <luis.machado@linaro.org>\n \n \t* arch-utils.c (default_floatformat_for_type): Handle bfloat16."
    },
    {
      "sha": "490419030a32085f8d316eb70388546474fc78fb",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -1134,6 +1134,7 @@ COMMON_SFILES = \\\n \treverse.c \\\n \trun-on-main-thread.c \\\n \trust-lang.c \\\n+\trust-parse.c \\\n \tsentinel-frame.c \\\n \tser-event.c \\\n \tserial.c \\\n@@ -1200,7 +1201,6 @@ SFILES = \\\n \tm2-exp.y \\\n \tp-exp.y \\\n \tproc-service.list \\\n-\trust-exp.y \\\n \tser-base.c \\\n \tser-unix.c \\\n \tsol-thread.c \\\n@@ -1608,8 +1608,7 @@ YYFILES = \\\n \tf-exp.c \\\n \tgo-exp.c \\\n \tm2-exp.c \\\n-\tp-exp.c \\\n-\trust-exp.c\n+\tp-exp.c\n \n # ada-lex.c is included by another file, so it shouldn't wind up as a\n # .o itself.\n@@ -1969,7 +1968,7 @@ local-maintainer-clean:\n \trm -f c-exp.c \\\n \t\tcp-name-parser.c \\\n \t\tada-lex.c ada-exp.c \\\n-\t\td-exp.c f-exp.c go-exp.c m2-exp.c p-exp.c rust-exp.c\n+\t\td-exp.c f-exp.c go-exp.c m2-exp.c p-exp.c\n \trm -f TAGS\n \trm -f $(YYFILES)\n \trm -f nm.h config.status"
    },
    {
      "sha": "a0ceb6a42c7ead543c18964a7e85262415246d91",
      "filename": "gdb/rust-exp.y",
      "status": "removed",
      "additions": 0,
      "deletions": 2884,
      "changes": 2884,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/458620aabb33d9b0efa61d0fb402c8d19e65eabd/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/458620aabb33d9b0efa61d0fb402c8d19e65eabd/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=458620aabb33d9b0efa61d0fb402c8d19e65eabd",
      "patch": "@@ -1,2884 +0,0 @@\n-/* Bison parser for Rust expressions, for GDB.\n-   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* The Bison manual says that %pure-parser is deprecated, but we use\n-   it anyway because it also works with Byacc.  That is also why\n-   this uses %lex-param and %parse-param rather than the simpler\n-   %param -- Byacc does not support the latter.  */\n-%pure-parser\n-%lex-param {struct rust_parser *parser}\n-%parse-param {struct rust_parser *parser}\n-\n-/* Removing the last conflict seems difficult.  */\n-%expect 1\n-\n-%{\n-\n-#include \"defs.h\"\n-\n-#include \"block.h\"\n-#include \"charset.h\"\n-#include \"cp-support.h\"\n-#include \"gdb_obstack.h\"\n-#include \"gdb_regex.h\"\n-#include \"rust-lang.h\"\n-#include \"parser-defs.h\"\n-#include \"gdbsupport/selftest.h\"\n-#include \"value.h\"\n-#include \"gdbarch.h\"\n-#include \"rust-exp.h\"\n-#include <unordered_map>\n-#include \"gdbsupport/hash_enum.h\"\n-\n-#define GDB_YY_REMAP_PREFIX rust\n-#include \"yy-remap.h\"\n-\n-#define RUSTSTYPE YYSTYPE\n-\n-struct rust_op;\n-typedef std::vector<const struct rust_op *> rust_op_vector;\n-\n-/* A typed integer constant.  */\n-\n-struct typed_val_int\n-{\n-  LONGEST val;\n-  struct type *type;\n-};\n-\n-/* A typed floating point constant.  */\n-\n-struct typed_val_float\n-{\n-  gdb_byte val[16];\n-  struct type *type;\n-};\n-\n-/* An identifier and an expression.  This is used to represent one\n-   element of a struct initializer.  */\n-\n-struct set_field\n-{\n-  struct stoken name;\n-  const struct rust_op *init;\n-};\n-\n-typedef std::vector<set_field> rust_set_vector;\n-\n-%}\n-\n-%union\n-{\n-  /* A typed integer constant.  */\n-  struct typed_val_int typed_val_int;\n-\n-  /* A typed floating point constant.  */\n-  struct typed_val_float typed_val_float;\n-\n-  /* An identifier or string.  */\n-  struct stoken sval;\n-\n-  /* A token representing an opcode, like \"==\".  */\n-  enum exp_opcode opcode;\n-\n-  /* A list of expressions; for example, the arguments to a function\n-     call.  */\n-  rust_op_vector *params;\n-\n-  /* A list of field initializers.  */\n-  rust_set_vector *field_inits;\n-\n-  /* A single field initializer.  */\n-  struct set_field one_field_init;\n-\n-  /* An expression.  */\n-  const struct rust_op *op;\n-\n-  /* A plain integer, for example used to count the number of\n-     \"super::\" prefixes on a path.  */\n-  unsigned int depth;\n-}\n-\n-%{\n-\n-struct rust_parser;\n-static int rustyylex (YYSTYPE *, rust_parser *);\n-static void rustyyerror (rust_parser *parser, const char *msg);\n-\n-static struct stoken make_stoken (const char *);\n-\n-/* A regular expression for matching Rust numbers.  This is split up\n-   since it is very long and this gives us a way to comment the\n-   sections.  */\n-\n-static const char number_regex_text[] =\n-  /* subexpression 1: allows use of alternation, otherwise uninteresting */\n-  \"^(\"\n-  /* First comes floating point.  */\n-  /* Recognize number after the decimal point, with optional\n-     exponent and optional type suffix.\n-     subexpression 2: allows \"?\", otherwise uninteresting\n-     subexpression 3: if present, type suffix\n-  */\n-  \"[0-9][0-9_]*\\\\.[0-9][0-9_]*([eE][-+]?[0-9][0-9_]*)?(f32|f64)?\"\n-#define FLOAT_TYPE1 3\n-  \"|\"\n-  /* Recognize exponent without decimal point, with optional type\n-     suffix.\n-     subexpression 4: if present, type suffix\n-  */\n-#define FLOAT_TYPE2 4\n-  \"[0-9][0-9_]*[eE][-+]?[0-9][0-9_]*(f32|f64)?\"\n-  \"|\"\n-  /* \"23.\" is a valid floating point number, but \"23.e5\" and\n-     \"23.f32\" are not.  So, handle the trailing-. case\n-     separately.  */\n-  \"[0-9][0-9_]*\\\\.\"\n-  \"|\"\n-  /* Finally come integers.\n-     subexpression 5: text of integer\n-     subexpression 6: if present, type suffix\n-     subexpression 7: allows use of alternation, otherwise uninteresting\n-  */\n-#define INT_TEXT 5\n-#define INT_TYPE 6\n-  \"(0x[a-fA-F0-9_]+|0o[0-7_]+|0b[01_]+|[0-9][0-9_]*)\"\n-  \"([iu](size|8|16|32|64))?\"\n-  \")\";\n-/* The number of subexpressions to allocate space for, including the\n-   \"0th\" whole match subexpression.  */\n-#define NUM_SUBEXPRESSIONS 8\n-\n-/* The compiled number-matching regex.  */\n-\n-static regex_t number_regex;\n-\n-/* An instance of this is created before parsing, and destroyed when\n-   parsing is finished.  */\n-\n-struct rust_parser\n-{\n-  rust_parser (struct parser_state *state)\n-    : rust_ast (nullptr),\n-      pstate (state)\n-  {\n-  }\n-\n-  ~rust_parser ()\n-  {\n-  }\n-\n-  /* Create a new rust_set_vector.  The storage for the new vector is\n-     managed by this class.  */\n-  rust_set_vector *new_set_vector ()\n-  {\n-    rust_set_vector *result = new rust_set_vector;\n-    set_vectors.push_back (std::unique_ptr<rust_set_vector> (result));\n-    return result;\n-  }\n-\n-  /* Create a new rust_ops_vector.  The storage for the new vector is\n-     managed by this class.  */\n-  rust_op_vector *new_op_vector ()\n-  {\n-    rust_op_vector *result = new rust_op_vector;\n-    op_vectors.push_back (std::unique_ptr<rust_op_vector> (result));\n-    return result;\n-  }\n-\n-  /* Return the parser's language.  */\n-  const struct language_defn *language () const\n-  {\n-    return pstate->language ();\n-  }\n-\n-  /* Return the parser's gdbarch.  */\n-  struct gdbarch *arch () const\n-  {\n-    return pstate->gdbarch ();\n-  }\n-\n-  /* A helper to look up a Rust type, or fail.  This only works for\n-     types defined by rust_language_arch_info.  */\n-\n-  struct type *get_type (const char *name)\n-  {\n-    struct type *type;\n-\n-    type = language_lookup_primitive_type (language (), arch (), name);\n-    if (type == NULL)\n-      error (_(\"Could not find Rust type %s\"), name);\n-    return type;\n-  }\n-\n-  const char *copy_name (const char *name, int len);\n-  struct stoken concat3 (const char *s1, const char *s2, const char *s3);\n-  const struct rust_op *crate_name (const struct rust_op *name);\n-  const struct rust_op *super_name (const struct rust_op *ident,\n-\t\t\t\t    unsigned int n_supers);\n-\n-  int lex_character (YYSTYPE *lvalp);\n-  int lex_number (YYSTYPE *lvalp);\n-  int lex_string (YYSTYPE *lvalp);\n-  int lex_identifier (YYSTYPE *lvalp);\n-  uint32_t lex_hex (int min, int max);\n-  uint32_t lex_escape (int is_byte);\n-  int lex_operator (YYSTYPE *lvalp);\n-  void push_back (char c);\n-\n-  void update_innermost_block (struct block_symbol sym);\n-  struct block_symbol lookup_symbol (const char *name,\n-\t\t\t\t     const struct block *block,\n-\t\t\t\t     const domain_enum domain);\n-  struct type *rust_lookup_type (const char *name, const struct block *block);\n-  std::vector<struct type *> convert_params_to_types (rust_op_vector *params);\n-  struct type *convert_ast_to_type (const struct rust_op *operation);\n-  const char *convert_name (const struct rust_op *operation);\n-  std::vector<expr::operation_up> convert_params_to_expression\n-       (rust_op_vector *params, const struct rust_op *top);\n-  expr::operation_up convert_ast_to_expression (const struct rust_op *opn,\n-\t\t\t\t\t\tconst struct rust_op *top,\n-\t\t\t\t\t\tbool want_type = false);\n-\n-  struct rust_op *ast_basic_type (enum type_code typecode);\n-  const struct rust_op *ast_operation (enum exp_opcode opcode,\n-\t\t\t\t       const struct rust_op *left,\n-\t\t\t\t       const struct rust_op *right);\n-  const struct rust_op *ast_compound_assignment\n-  (enum exp_opcode opcode, const struct rust_op *left,\n-   const struct rust_op *rust_op);\n-  const struct rust_op *ast_literal (struct typed_val_int val);\n-  const struct rust_op *ast_dliteral (struct typed_val_float val);\n-  const struct rust_op *ast_structop (const struct rust_op *left,\n-\t\t\t\t      const char *name,\n-\t\t\t\t      int completing);\n-  const struct rust_op *ast_structop_anonymous\n-  (const struct rust_op *left, struct typed_val_int number);\n-  const struct rust_op *ast_unary (enum exp_opcode opcode,\n-\t\t\t\t   const struct rust_op *expr);\n-  const struct rust_op *ast_cast (const struct rust_op *expr,\n-\t\t\t\t  const struct rust_op *type);\n-  const struct rust_op *ast_call_ish (enum exp_opcode opcode,\n-\t\t\t\t      const struct rust_op *expr,\n-\t\t\t\t      rust_op_vector *params);\n-  const struct rust_op *ast_path (struct stoken name,\n-\t\t\t\t  rust_op_vector *params);\n-  const struct rust_op *ast_string (struct stoken str);\n-  const struct rust_op *ast_struct (const struct rust_op *name,\n-\t\t\t\t    rust_set_vector *fields);\n-  const struct rust_op *ast_range (const struct rust_op *lhs,\n-\t\t\t\t   const struct rust_op *rhs,\n-\t\t\t\t   bool inclusive);\n-  const struct rust_op *ast_array_type (const struct rust_op *lhs,\n-\t\t\t\t\tstruct typed_val_int val);\n-  const struct rust_op *ast_slice_type (const struct rust_op *type);\n-  const struct rust_op *ast_reference_type (const struct rust_op *type);\n-  const struct rust_op *ast_pointer_type (const struct rust_op *type,\n-\t\t\t\t\t  int is_mut);\n-  const struct rust_op *ast_function_type (const struct rust_op *result,\n-\t\t\t\t\t   rust_op_vector *params);\n-  const struct rust_op *ast_tuple_type (rust_op_vector *params);\n-\n-\n-  /* A pointer to this is installed globally.  */\n-  auto_obstack obstack;\n-\n-  /* Result of parsing.  Points into obstack.  */\n-  const struct rust_op *rust_ast;\n-\n-  /* This keeps track of the various vectors we allocate.  */\n-  std::vector<std::unique_ptr<rust_set_vector>> set_vectors;\n-  std::vector<std::unique_ptr<rust_op_vector>> op_vectors;\n-\n-  /* The parser state gdb gave us.  */\n-  struct parser_state *pstate;\n-\n-  /* Depth of parentheses.  */\n-  int paren_depth = 0;\n-};\n-\n-/* Rust AST operations.  We build a tree of these; then lower them to\n-   gdb expressions when parsing has completed.  */\n-\n-struct rust_op\n-{\n-  /* The opcode.  */\n-  enum exp_opcode opcode;\n-  /* If OPCODE is OP_TYPE, then this holds information about what type\n-     is described by this node.  */\n-  enum type_code typecode;\n-  /* Indicates whether OPCODE actually represents a compound\n-     assignment.  For example, if OPCODE is GTGT and this is false,\n-     then this rust_op represents an ordinary \">>\"; but if this is\n-     true, then this rust_op represents \">>=\".  Unused in other\n-     cases.  */\n-  unsigned int compound_assignment : 1;\n-  /* Only used by a field expression; if set, indicates that the field\n-     name occurred at the end of the expression and is eligible for\n-     completion.  */\n-  unsigned int completing : 1;\n-  /* For OP_RANGE, indicates whether the range is inclusive or\n-     exclusive.  */\n-  unsigned int inclusive : 1;\n-  /* Operands of expression.  Which one is used and how depends on the\n-     particular opcode.  */\n-  RUSTSTYPE left;\n-  RUSTSTYPE right;\n-};\n-\n-%}\n-\n-%token <sval> GDBVAR\n-%token <sval> IDENT\n-%token <sval> COMPLETE\n-%token <typed_val_int> INTEGER\n-%token <typed_val_int> DECIMAL_INTEGER\n-%token <sval> STRING\n-%token <sval> BYTESTRING\n-%token <typed_val_float> FLOAT\n-%token <opcode> COMPOUND_ASSIGN\n-\n-/* Keyword tokens.  */\n-%token <voidval> KW_AS\n-%token <voidval> KW_IF\n-%token <voidval> KW_TRUE\n-%token <voidval> KW_FALSE\n-%token <voidval> KW_SUPER\n-%token <voidval> KW_SELF\n-%token <voidval> KW_MUT\n-%token <voidval> KW_EXTERN\n-%token <voidval> KW_CONST\n-%token <voidval> KW_FN\n-%token <voidval> KW_SIZEOF\n-\n-/* Operator tokens.  */\n-%token <voidval> DOTDOT\n-%token <voidval> DOTDOTEQ\n-%token <voidval> OROR\n-%token <voidval> ANDAND\n-%token <voidval> EQEQ\n-%token <voidval> NOTEQ\n-%token <voidval> LTEQ\n-%token <voidval> GTEQ\n-%token <voidval> LSH RSH\n-%token <voidval> COLONCOLON\n-%token <voidval> ARROW\n-\n-%type <op> type\n-%type <op> path_for_expr\n-%type <op> identifier_path_for_expr\n-%type <op> path_for_type\n-%type <op> identifier_path_for_type\n-%type <op> just_identifiers_for_type\n-\n-%type <params> maybe_type_list\n-%type <params> type_list\n-\n-%type <depth> super_path\n-\n-%type <op> literal\n-%type <op> expr\n-%type <op> field_expr\n-%type <op> idx_expr\n-%type <op> unop_expr\n-%type <op> binop_expr\n-%type <op> binop_expr_expr\n-%type <op> type_cast_expr\n-%type <op> assignment_expr\n-%type <op> compound_assignment_expr\n-%type <op> paren_expr\n-%type <op> call_expr\n-%type <op> path_expr\n-%type <op> tuple_expr\n-%type <op> unit_expr\n-%type <op> struct_expr\n-%type <op> array_expr\n-%type <op> range_expr\n-\n-%type <params> expr_list\n-%type <params> maybe_expr_list\n-%type <params> paren_expr_list\n-\n-%type <field_inits> struct_expr_list\n-%type <one_field_init> struct_expr_tail\n-\n-/* Precedence.  */\n-%nonassoc DOTDOT DOTDOTEQ\n-%right '=' COMPOUND_ASSIGN\n-%left OROR\n-%left ANDAND\n-%nonassoc EQEQ NOTEQ '<' '>' LTEQ GTEQ\n-%left '|'\n-%left '^'\n-%left '&'\n-%left LSH RSH\n-%left '@'\n-%left '+' '-'\n-%left '*' '/' '%'\n-/* These could be %precedence in Bison, but that isn't a yacc\n-   feature.  */\n-%left KW_AS\n-%left UNARY\n-%left '[' '.' '('\n-\n-%%\n-\n-start:\n-\texpr\n-\t\t{\n-\t\t  /* If we are completing and see a valid parse,\n-\t\t     rust_ast will already have been set.  */\n-\t\t  if (parser->rust_ast == NULL)\n-\t\t    parser->rust_ast = $1;\n-\t\t}\n-;\n-\n-/* Note that the Rust grammar includes a method_call_expr, but we\n-   handle this differently, to avoid a shift/reduce conflict with\n-   call_expr.  */\n-expr:\n-\tliteral\n-|\tpath_expr\n-|\ttuple_expr\n-|\tunit_expr\n-|\tstruct_expr\n-|\tfield_expr\n-|\tarray_expr\n-|\tidx_expr\n-|\trange_expr\n-|\tunop_expr /* Must precede call_expr because of ambiguity with\n-\t\t     sizeof.  */\n-|\tbinop_expr\n-|\tparen_expr\n-|\tcall_expr\n-;\n-\n-tuple_expr:\n-\t'(' expr ',' maybe_expr_list ')'\n-\t\t{\n-\t\t  $4->push_back ($2);\n-\t\t  error (_(\"Tuple expressions not supported yet\"));\n-\t\t}\n-;\n-\n-unit_expr:\n-\t'(' ')'\n-\t\t{\n-\t\t  struct typed_val_int val;\n-\n-\t\t  val.type\n-\t\t    = (language_lookup_primitive_type\n-\t\t       (parser->language (), parser->arch (),\n-\t\t\t\"()\"));\n-\t\t  val.val = 0;\n-\t\t  $$ = parser->ast_literal (val);\n-\t\t}\n-;\n-\n-/* To avoid a shift/reduce conflict with call_expr, we don't handle\n-   tuple struct expressions here, but instead when examining the\n-   AST.  */\n-struct_expr:\n-\tpath_for_expr '{' struct_expr_list '}'\n-\t\t{ $$ = parser->ast_struct ($1, $3); }\n-;\n-\n-struct_expr_tail:\n-\tDOTDOT expr\n-\t\t{\n-\t\t  struct set_field sf;\n-\n-\t\t  sf.name.ptr = NULL;\n-\t\t  sf.name.length = 0;\n-\t\t  sf.init = $2;\n-\n-\t\t  $$ = sf;\n-\t\t}\n-|\tIDENT ':' expr\n-\t\t{\n-\t\t  struct set_field sf;\n-\n-\t\t  sf.name = $1;\n-\t\t  sf.init = $3;\n-\t\t  $$ = sf;\n-\t\t}\n-|\tIDENT\n-\t\t{\n-\t\t  struct set_field sf;\n-\n-\t\t  sf.name = $1;\n-\t\t  sf.init = parser->ast_path ($1, NULL);\n-\t\t  $$ = sf;\n-\t\t}\n-;\n-\n-struct_expr_list:\n-\t/* %empty */\n-\t\t{\n-\t\t  $$ = parser->new_set_vector ();\n-\t\t}\n-|\tstruct_expr_tail\n-\t\t{\n-\t\t  rust_set_vector *result = parser->new_set_vector ();\n-\t\t  result->push_back ($1);\n-\t\t  $$ = result;\n-\t\t}\n-|\tIDENT ':' expr ',' struct_expr_list\n-\t\t{\n-\t\t  struct set_field sf;\n-\n-\t\t  sf.name = $1;\n-\t\t  sf.init = $3;\n-\t\t  $5->push_back (sf);\n-\t\t  $$ = $5;\n-\t\t}\n-|\tIDENT ',' struct_expr_list\n-\t\t{\n-\t\t  struct set_field sf;\n-\n-\t\t  sf.name = $1;\n-\t\t  sf.init = parser->ast_path ($1, NULL);\n-\t\t  $3->push_back (sf);\n-\t\t  $$ = $3;\n-\t\t}\n-;\n-\n-array_expr:\n-\t'[' KW_MUT expr_list ']'\n-\t\t{ $$ = parser->ast_call_ish (OP_ARRAY, NULL, $3); }\n-|\t'[' expr_list ']'\n-\t\t{ $$ = parser->ast_call_ish (OP_ARRAY, NULL, $2); }\n-|\t'[' KW_MUT expr ';' expr ']'\n-\t\t{ $$ = parser->ast_operation (OP_RUST_ARRAY, $3, $5); }\n-|\t'[' expr ';' expr ']'\n-\t\t{ $$ = parser->ast_operation (OP_RUST_ARRAY, $2, $4); }\n-;\n-\n-range_expr:\n-\texpr DOTDOT\n-\t\t{ $$ = parser->ast_range ($1, NULL, false); }\n-|\texpr DOTDOT expr\n-\t\t{ $$ = parser->ast_range ($1, $3, false); }\n-|\texpr DOTDOTEQ expr\n-\t\t{ $$ = parser->ast_range ($1, $3, true); }\n-|\tDOTDOT expr\n-\t\t{ $$ = parser->ast_range (NULL, $2, false); }\n-|\tDOTDOTEQ expr\n-\t\t{ $$ = parser->ast_range (NULL, $2, true); }\n-|\tDOTDOT\n-\t\t{ $$ = parser->ast_range (NULL, NULL, false); }\n-;\n-\n-literal:\n-\tINTEGER\n-\t\t{ $$ = parser->ast_literal ($1); }\n-|\tDECIMAL_INTEGER\n-\t\t{ $$ = parser->ast_literal ($1); }\n-|\tFLOAT\n-\t\t{ $$ = parser->ast_dliteral ($1); }\n-|\tSTRING\n-\t\t{\n-\t\t  struct set_field field;\n-\t\t  struct typed_val_int val;\n-\t\t  struct stoken token;\n-\n-\t\t  rust_set_vector *fields = parser->new_set_vector ();\n-\n-\t\t  /* Wrap the raw string in the &str struct.  */\n-\t\t  field.name.ptr = \"data_ptr\";\n-\t\t  field.name.length = strlen (field.name.ptr);\n-\t\t  field.init = parser->ast_unary (UNOP_ADDR,\n-\t\t\t\t\t\t  parser->ast_string ($1));\n-\t\t  fields->push_back (field);\n-\n-\t\t  val.type = parser->get_type (\"usize\");\n-\t\t  val.val = $1.length;\n-\n-\t\t  field.name.ptr = \"length\";\n-\t\t  field.name.length = strlen (field.name.ptr);\n-\t\t  field.init = parser->ast_literal (val);\n-\t\t  fields->push_back (field);\n-\n-\t\t  token.ptr = \"&str\";\n-\t\t  token.length = strlen (token.ptr);\n-\t\t  $$ = parser->ast_struct (parser->ast_path (token, NULL),\n-\t\t\t\t\t   fields);\n-\t\t}\n-|\tBYTESTRING\n-\t\t{ $$ = parser->ast_string ($1); }\n-|\tKW_TRUE\n-\t\t{\n-\t\t  struct typed_val_int val;\n-\n-\t\t  val.type = language_bool_type (parser->language (),\n-\t\t\t\t\t\t parser->arch ());\n-\t\t  val.val = 1;\n-\t\t  $$ = parser->ast_literal (val);\n-\t\t}\n-|\tKW_FALSE\n-\t\t{\n-\t\t  struct typed_val_int val;\n-\n-\t\t  val.type = language_bool_type (parser->language (),\n-\t\t\t\t\t\t parser->arch ());\n-\t\t  val.val = 0;\n-\t\t  $$ = parser->ast_literal (val);\n-\t\t}\n-;\n-\n-field_expr:\n-\texpr '.' IDENT\n-\t\t{ $$ = parser->ast_structop ($1, $3.ptr, 0); }\n-|\texpr '.' COMPLETE\n-\t\t{\n-\t\t  $$ = parser->ast_structop ($1, $3.ptr, 1);\n-\t\t  parser->rust_ast = $$;\n-\t\t}\n-|\texpr '.' DECIMAL_INTEGER\n-\t\t{ $$ = parser->ast_structop_anonymous ($1, $3); }\n-;\n-\n-idx_expr:\n-\texpr '[' expr ']'\n-\t\t{ $$ = parser->ast_operation (BINOP_SUBSCRIPT, $1, $3); }\n-;\n-\n-unop_expr:\n-\t'+' expr\t%prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_PLUS, $2); }\n-\n-|\t'-' expr\t%prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_NEG, $2); }\n-\n-|\t'!' expr\t%prec UNARY\n-\t\t{\n-\t\t  /* Note that we provide a Rust-specific evaluator\n-\t\t     override for UNOP_COMPLEMENT, so it can do the\n-\t\t     right thing for both bool and integral\n-\t\t     values.  */\n-\t\t  $$ = parser->ast_unary (UNOP_COMPLEMENT, $2);\n-\t\t}\n-\n-|\t'*' expr\t%prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_IND, $2); }\n-\n-|\t'&' expr\t%prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_ADDR, $2); }\n-\n-|\t'&' KW_MUT expr\t%prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_ADDR, $3); }\n-|\tKW_SIZEOF '(' expr ')' %prec UNARY\n-\t\t{ $$ = parser->ast_unary (UNOP_SIZEOF, $3); }\n-;\n-\n-binop_expr:\n-\tbinop_expr_expr\n-|\ttype_cast_expr\n-|\tassignment_expr\n-|\tcompound_assignment_expr\n-;\n-\n-binop_expr_expr:\n-\texpr '*' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_MUL, $1, $3); }\n-\n-|\texpr '@' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_REPEAT, $1, $3); }\n-\n-|\texpr '/' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_DIV, $1, $3); }\n-\n-|\texpr '%' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_REM, $1, $3); }\n-\n-|\texpr '<' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_LESS, $1, $3); }\n-\n-|\texpr '>' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_GTR, $1, $3); }\n-\n-|\texpr '&' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_BITWISE_AND, $1, $3); }\n-\n-|\texpr '|' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_BITWISE_IOR, $1, $3); }\n-\n-|\texpr '^' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_BITWISE_XOR, $1, $3); }\n-\n-|\texpr '+' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_ADD, $1, $3); }\n-\n-|\texpr '-' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_SUB, $1, $3); }\n-\n-|\texpr OROR expr\n-\t\t{ $$ = parser->ast_operation (BINOP_LOGICAL_OR, $1, $3); }\n-\n-|\texpr ANDAND expr\n-\t\t{ $$ = parser->ast_operation (BINOP_LOGICAL_AND, $1, $3); }\n-\n-|\texpr EQEQ expr\n-\t\t{ $$ = parser->ast_operation (BINOP_EQUAL, $1, $3); }\n-\n-|\texpr NOTEQ expr\n-\t\t{ $$ = parser->ast_operation (BINOP_NOTEQUAL, $1, $3); }\n-\n-|\texpr LTEQ expr\n-\t\t{ $$ = parser->ast_operation (BINOP_LEQ, $1, $3); }\n-\n-|\texpr GTEQ expr\n-\t\t{ $$ = parser->ast_operation (BINOP_GEQ, $1, $3); }\n-\n-|\texpr LSH expr\n-\t\t{ $$ = parser->ast_operation (BINOP_LSH, $1, $3); }\n-\n-|\texpr RSH expr\n-\t\t{ $$ = parser->ast_operation (BINOP_RSH, $1, $3); }\n-;\n-\n-type_cast_expr:\n-\texpr KW_AS type\n-\t\t{ $$ = parser->ast_cast ($1, $3); }\n-;\n-\n-assignment_expr:\n-\texpr '=' expr\n-\t\t{ $$ = parser->ast_operation (BINOP_ASSIGN, $1, $3); }\n-;\n-\n-compound_assignment_expr:\n-\texpr COMPOUND_ASSIGN expr\n-\t\t{ $$ = parser->ast_compound_assignment ($2, $1, $3); }\n-\n-;\n-\n-paren_expr:\n-\t'(' expr ')'\n-\t\t{ $$ = $2; }\n-;\n-\n-expr_list:\n-\texpr\n-\t\t{\n-\t\t  $$ = parser->new_op_vector ();\n-\t\t  $$->push_back ($1);\n-\t\t}\n-|\texpr_list ',' expr\n-\t\t{\n-\t\t  $1->push_back ($3);\n-\t\t  $$ = $1;\n-\t\t}\n-;\n-\n-maybe_expr_list:\n-\t/* %empty */\n-\t\t{\n-\t\t  /* The result can't be NULL.  */\n-\t\t  $$ = parser->new_op_vector ();\n-\t\t}\n-|\texpr_list\n-\t\t{ $$ = $1; }\n-;\n-\n-paren_expr_list:\n-\t'(' maybe_expr_list ')'\n-\t\t{ $$ = $2; }\n-;\n-\n-call_expr:\n-\texpr paren_expr_list\n-\t\t{ $$ = parser->ast_call_ish (OP_FUNCALL, $1, $2); }\n-;\n-\n-maybe_self_path:\n-\t/* %empty */\n-|\tKW_SELF COLONCOLON\n-;\n-\n-super_path:\n-\tKW_SUPER COLONCOLON\n-\t\t{ $$ = 1; }\n-|\tsuper_path KW_SUPER COLONCOLON\n-\t\t{ $$ = $1 + 1; }\n-;\n-\n-path_expr:\n-\tpath_for_expr\n-\t\t{ $$ = $1; }\n-|\tGDBVAR\n-\t\t{ $$ = parser->ast_path ($1, NULL); }\n-|\tKW_SELF\n-\t\t{ $$ = parser->ast_path (make_stoken (\"self\"), NULL); }\n-;\n-\n-path_for_expr:\n-\tidentifier_path_for_expr\n-|\tKW_SELF COLONCOLON identifier_path_for_expr\n-\t\t{ $$ = parser->super_name ($3, 0); }\n-|\tmaybe_self_path super_path identifier_path_for_expr\n-\t\t{ $$ = parser->super_name ($3, $2); }\n-|\tCOLONCOLON identifier_path_for_expr\n-\t\t{ $$ = parser->crate_name ($2); }\n-|\tKW_EXTERN identifier_path_for_expr\n-\t\t{\n-\t\t  /* This is a gdb extension to make it possible to\n-\t\t     refer to items in other crates.  It just bypasses\n-\t\t     adding the current crate to the front of the\n-\t\t     name.  */\n-\t\t  $$ = parser->ast_path (parser->concat3 (\"::\",\n-\t\t\t\t\t\t\t  $2->left.sval.ptr,\n-\t\t\t\t\t\t\t  NULL),\n-\t\t\t\t\t $2->right.params);\n-\t\t}\n-;\n-\n-identifier_path_for_expr:\n-\tIDENT\n-\t\t{ $$ = parser->ast_path ($1, NULL); }\n-|\tidentifier_path_for_expr COLONCOLON IDENT\n-\t\t{\n-\t\t  $$ = parser->ast_path (parser->concat3 ($1->left.sval.ptr,\n-\t\t\t\t\t\t\t  \"::\", $3.ptr),\n-\t\t\t\t\t NULL);\n-\t\t}\n-|\tidentifier_path_for_expr COLONCOLON '<' type_list '>'\n-\t\t{ $$ = parser->ast_path ($1->left.sval, $4); }\n-|\tidentifier_path_for_expr COLONCOLON '<' type_list RSH\n-\t\t{\n-\t\t  $$ = parser->ast_path ($1->left.sval, $4);\n-\t\t  parser->push_back ('>');\n-\t\t}\n-;\n-\n-path_for_type:\n-\tidentifier_path_for_type\n-|\tKW_SELF COLONCOLON identifier_path_for_type\n-\t\t{ $$ = parser->super_name ($3, 0); }\n-|\tmaybe_self_path super_path identifier_path_for_type\n-\t\t{ $$ = parser->super_name ($3, $2); }\n-|\tCOLONCOLON identifier_path_for_type\n-\t\t{ $$ = parser->crate_name ($2); }\n-|\tKW_EXTERN identifier_path_for_type\n-\t\t{\n-\t\t  /* This is a gdb extension to make it possible to\n-\t\t     refer to items in other crates.  It just bypasses\n-\t\t     adding the current crate to the front of the\n-\t\t     name.  */\n-\t\t  $$ = parser->ast_path (parser->concat3 (\"::\",\n-\t\t\t\t\t\t\t  $2->left.sval.ptr,\n-\t\t\t\t\t\t\t  NULL),\n-\t\t\t\t\t $2->right.params);\n-\t\t}\n-;\n-\n-just_identifiers_for_type:\n-\tIDENT\n-\t\t{ $$ = parser->ast_path ($1, NULL); }\n-|\tjust_identifiers_for_type COLONCOLON IDENT\n-\t\t{\n-\t\t  $$ = parser->ast_path (parser->concat3 ($1->left.sval.ptr,\n-\t\t\t\t\t\t\t  \"::\", $3.ptr),\n-\t\t\t\t\t NULL);\n-\t\t}\n-;\n-\n-identifier_path_for_type:\n-\tjust_identifiers_for_type\n-|\tjust_identifiers_for_type '<' type_list '>'\n-\t\t{ $$ = parser->ast_path ($1->left.sval, $3); }\n-|\tjust_identifiers_for_type '<' type_list RSH\n-\t\t{\n-\t\t  $$ = parser->ast_path ($1->left.sval, $3);\n-\t\t  parser->push_back ('>');\n-\t\t}\n-;\n-\n-type:\n-\tpath_for_type\n-|\t'[' type ';' INTEGER ']'\n-\t\t{ $$ = parser->ast_array_type ($2, $4); }\n-|\t'[' type ';' DECIMAL_INTEGER ']'\n-\t\t{ $$ = parser->ast_array_type ($2, $4); }\n-|\t'&' '[' type ']'\n-\t\t{ $$ = parser->ast_slice_type ($3); }\n-|\t'&' type\n-\t\t{ $$ = parser->ast_reference_type ($2); }\n-|\t'*' KW_MUT type\n-\t\t{ $$ = parser->ast_pointer_type ($3, 1); }\n-|\t'*' KW_CONST type\n-\t\t{ $$ = parser->ast_pointer_type ($3, 0); }\n-|\tKW_FN '(' maybe_type_list ')' ARROW type\n-\t\t{ $$ = parser->ast_function_type ($6, $3); }\n-|\t'(' maybe_type_list ')'\n-\t\t{ $$ = parser->ast_tuple_type ($2); }\n-;\n-\n-maybe_type_list:\n-\t/* %empty */\n-\t\t{ $$ = NULL; }\n-|\ttype_list\n-\t\t{ $$ = $1; }\n-;\n-\n-type_list:\n-\ttype\n-\t\t{\n-\t\t  rust_op_vector *result = parser->new_op_vector ();\n-\t\t  result->push_back ($1);\n-\t\t  $$ = result;\n-\t\t}\n-|\ttype_list ',' type\n-\t\t{\n-\t\t  $1->push_back ($3);\n-\t\t  $$ = $1;\n-\t\t}\n-;\n-\n-%%\n-\n-/* A struct of this type is used to describe a token.  */\n-\n-struct token_info\n-{\n-  const char *name;\n-  int value;\n-  enum exp_opcode opcode;\n-};\n-\n-/* Identifier tokens.  */\n-\n-static const struct token_info identifier_tokens[] =\n-{\n-  { \"as\", KW_AS, OP_NULL },\n-  { \"false\", KW_FALSE, OP_NULL },\n-  { \"if\", 0, OP_NULL },\n-  { \"mut\", KW_MUT, OP_NULL },\n-  { \"const\", KW_CONST, OP_NULL },\n-  { \"self\", KW_SELF, OP_NULL },\n-  { \"super\", KW_SUPER, OP_NULL },\n-  { \"true\", KW_TRUE, OP_NULL },\n-  { \"extern\", KW_EXTERN, OP_NULL },\n-  { \"fn\", KW_FN, OP_NULL },\n-  { \"sizeof\", KW_SIZEOF, OP_NULL },\n-};\n-\n-/* Operator tokens, sorted longest first.  */\n-\n-static const struct token_info operator_tokens[] =\n-{\n-  { \">>=\", COMPOUND_ASSIGN, BINOP_RSH },\n-  { \"<<=\", COMPOUND_ASSIGN, BINOP_LSH },\n-\n-  { \"<<\", LSH, OP_NULL },\n-  { \">>\", RSH, OP_NULL },\n-  { \"&&\", ANDAND, OP_NULL },\n-  { \"||\", OROR, OP_NULL },\n-  { \"==\", EQEQ, OP_NULL },\n-  { \"!=\", NOTEQ, OP_NULL },\n-  { \"<=\", LTEQ, OP_NULL },\n-  { \">=\", GTEQ, OP_NULL },\n-  { \"+=\", COMPOUND_ASSIGN, BINOP_ADD },\n-  { \"-=\", COMPOUND_ASSIGN, BINOP_SUB },\n-  { \"*=\", COMPOUND_ASSIGN, BINOP_MUL },\n-  { \"/=\", COMPOUND_ASSIGN, BINOP_DIV },\n-  { \"%=\", COMPOUND_ASSIGN, BINOP_REM },\n-  { \"&=\", COMPOUND_ASSIGN, BINOP_BITWISE_AND },\n-  { \"|=\", COMPOUND_ASSIGN, BINOP_BITWISE_IOR },\n-  { \"^=\", COMPOUND_ASSIGN, BINOP_BITWISE_XOR },\n-  { \"..=\", DOTDOTEQ, OP_NULL },\n-\n-  { \"::\", COLONCOLON, OP_NULL },\n-  { \"..\", DOTDOT, OP_NULL },\n-  { \"->\", ARROW, OP_NULL }\n-};\n-\n-/* Helper function to copy to the name obstack.  */\n-\n-const char *\n-rust_parser::copy_name (const char *name, int len)\n-{\n-  return obstack_strndup (&obstack, name, len);\n-}\n-\n-/* Helper function to make an stoken from a C string.  */\n-\n-static struct stoken\n-make_stoken (const char *p)\n-{\n-  struct stoken result;\n-\n-  result.ptr = p;\n-  result.length = strlen (result.ptr);\n-  return result;\n-}\n-\n-/* Helper function to concatenate three strings on the name\n-   obstack.  */\n-\n-struct stoken\n-rust_parser::concat3 (const char *s1, const char *s2, const char *s3)\n-{\n-  return make_stoken (obconcat (&obstack, s1, s2, s3, (char *) NULL));\n-}\n-\n-/* Return an AST node referring to NAME, but relative to the crate's\n-   name.  */\n-\n-const struct rust_op *\n-rust_parser::crate_name (const struct rust_op *name)\n-{\n-  std::string crate = rust_crate_for_block (pstate->expression_context_block);\n-  struct stoken result;\n-\n-  gdb_assert (name->opcode == OP_VAR_VALUE);\n-\n-  if (crate.empty ())\n-    error (_(\"Could not find crate for current location\"));\n-  result = make_stoken (obconcat (&obstack, \"::\", crate.c_str (), \"::\",\n-\t\t\t\t  name->left.sval.ptr, (char *) NULL));\n-\n-  return ast_path (result, name->right.params);\n-}\n-\n-/* Create an AST node referring to a \"super::\" qualified name.  IDENT\n-   is the base name and N_SUPERS is how many \"super::\"s were\n-   provided.  N_SUPERS can be zero.  */\n-\n-const struct rust_op *\n-rust_parser::super_name (const struct rust_op *ident, unsigned int n_supers)\n-{\n-  const char *scope = block_scope (pstate->expression_context_block);\n-  int offset;\n-\n-  gdb_assert (ident->opcode == OP_VAR_VALUE);\n-\n-  if (scope[0] == '\\0')\n-    error (_(\"Couldn't find namespace scope for self::\"));\n-\n-  if (n_supers > 0)\n-    {\n-      int len;\n-      std::vector<int> offsets;\n-      unsigned int current_len;\n-\n-      current_len = cp_find_first_component (scope);\n-      while (scope[current_len] != '\\0')\n-\t{\n-\t  offsets.push_back (current_len);\n-\t  gdb_assert (scope[current_len] == ':');\n-\t  /* The \"::\".  */\n-\t  current_len += 2;\n-\t  current_len += cp_find_first_component (scope\n-\t\t\t\t\t\t  + current_len);\n-\t}\n-\n-      len = offsets.size ();\n-      if (n_supers >= len)\n-\terror (_(\"Too many super:: uses from '%s'\"), scope);\n-\n-      offset = offsets[len - n_supers];\n-    }\n-  else\n-    offset = strlen (scope);\n-\n-  obstack_grow (&obstack, \"::\", 2);\n-  obstack_grow (&obstack, scope, offset);\n-  obstack_grow (&obstack, \"::\", 2);\n-  obstack_grow0 (&obstack, ident->left.sval.ptr, ident->left.sval.length);\n-\n-  return ast_path (make_stoken ((const char *) obstack_finish (&obstack)),\n-\t\t   ident->right.params);\n-}\n-\n-/* A helper that updates the innermost block as appropriate.  */\n-\n-void\n-rust_parser::update_innermost_block (struct block_symbol sym)\n-{\n-  if (symbol_read_needs_frame (sym.symbol))\n-    pstate->block_tracker->update (sym);\n-}\n-\n-/* Lex a hex number with at least MIN digits and at most MAX\n-   digits.  */\n-\n-uint32_t\n-rust_parser::lex_hex (int min, int max)\n-{\n-  uint32_t result = 0;\n-  int len = 0;\n-  /* We only want to stop at MAX if we're lexing a byte escape.  */\n-  int check_max = min == max;\n-\n-  while ((check_max ? len <= max : 1)\n-\t && ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n-\t     || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n-\t     || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')))\n-    {\n-      result *= 16;\n-      if (pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n-\tresult = result + 10 + pstate->lexptr[0] - 'a';\n-      else if (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n-\tresult = result + 10 + pstate->lexptr[0] - 'A';\n-      else\n-\tresult = result + pstate->lexptr[0] - '0';\n-      ++pstate->lexptr;\n-      ++len;\n-    }\n-\n-  if (len < min)\n-    error (_(\"Not enough hex digits seen\"));\n-  if (len > max)\n-    {\n-      gdb_assert (min != max);\n-      error (_(\"Overlong hex escape\"));\n-    }\n-\n-  return result;\n-}\n-\n-/* Lex an escape.  IS_BYTE is true if we're lexing a byte escape;\n-   otherwise we're lexing a character escape.  */\n-\n-uint32_t\n-rust_parser::lex_escape (int is_byte)\n-{\n-  uint32_t result;\n-\n-  gdb_assert (pstate->lexptr[0] == '\\\\');\n-  ++pstate->lexptr;\n-  switch (pstate->lexptr[0])\n-    {\n-    case 'x':\n-      ++pstate->lexptr;\n-      result = lex_hex (2, 2);\n-      break;\n-\n-    case 'u':\n-      if (is_byte)\n-\terror (_(\"Unicode escape in byte literal\"));\n-      ++pstate->lexptr;\n-      if (pstate->lexptr[0] != '{')\n-\terror (_(\"Missing '{' in Unicode escape\"));\n-      ++pstate->lexptr;\n-      result = lex_hex (1, 6);\n-      /* Could do range checks here.  */\n-      if (pstate->lexptr[0] != '}')\n-\terror (_(\"Missing '}' in Unicode escape\"));\n-      ++pstate->lexptr;\n-      break;\n-\n-    case 'n':\n-      result = '\\n';\n-      ++pstate->lexptr;\n-      break;\n-    case 'r':\n-      result = '\\r';\n-      ++pstate->lexptr;\n-      break;\n-    case 't':\n-      result = '\\t';\n-      ++pstate->lexptr;\n-      break;\n-    case '\\\\':\n-      result = '\\\\';\n-      ++pstate->lexptr;\n-      break;\n-    case '0':\n-      result = '\\0';\n-      ++pstate->lexptr;\n-      break;\n-    case '\\'':\n-      result = '\\'';\n-      ++pstate->lexptr;\n-      break;\n-    case '\"':\n-      result = '\"';\n-      ++pstate->lexptr;\n-      break;\n-\n-    default:\n-      error (_(\"Invalid escape \\\\%c in literal\"), pstate->lexptr[0]);\n-    }\n-\n-  return result;\n-}\n-\n-/* Lex a character constant.  */\n-\n-int\n-rust_parser::lex_character (YYSTYPE *lvalp)\n-{\n-  int is_byte = 0;\n-  uint32_t value;\n-\n-  if (pstate->lexptr[0] == 'b')\n-    {\n-      is_byte = 1;\n-      ++pstate->lexptr;\n-    }\n-  gdb_assert (pstate->lexptr[0] == '\\'');\n-  ++pstate->lexptr;\n-  /* This should handle UTF-8 here.  */\n-  if (pstate->lexptr[0] == '\\\\')\n-    value = lex_escape (is_byte);\n-  else\n-    {\n-      value = pstate->lexptr[0] & 0xff;\n-      ++pstate->lexptr;\n-    }\n-\n-  if (pstate->lexptr[0] != '\\'')\n-    error (_(\"Unterminated character literal\"));\n-  ++pstate->lexptr;\n-\n-  lvalp->typed_val_int.val = value;\n-  lvalp->typed_val_int.type = get_type (is_byte ? \"u8\" : \"char\");\n-\n-  return INTEGER;\n-}\n-\n-/* Return the offset of the double quote if STR looks like the start\n-   of a raw string, or 0 if STR does not start a raw string.  */\n-\n-static int\n-starts_raw_string (const char *str)\n-{\n-  const char *save = str;\n-\n-  if (str[0] != 'r')\n-    return 0;\n-  ++str;\n-  while (str[0] == '#')\n-    ++str;\n-  if (str[0] == '\"')\n-    return str - save;\n-  return 0;\n-}\n-\n-/* Return true if STR looks like the end of a raw string that had N\n-   hashes at the start.  */\n-\n-static bool\n-ends_raw_string (const char *str, int n)\n-{\n-  int i;\n-\n-  gdb_assert (str[0] == '\"');\n-  for (i = 0; i < n; ++i)\n-    if (str[i + 1] != '#')\n-      return false;\n-  return true;\n-}\n-\n-/* Lex a string constant.  */\n-\n-int\n-rust_parser::lex_string (YYSTYPE *lvalp)\n-{\n-  int is_byte = pstate->lexptr[0] == 'b';\n-  int raw_length;\n-\n-  if (is_byte)\n-    ++pstate->lexptr;\n-  raw_length = starts_raw_string (pstate->lexptr);\n-  pstate->lexptr += raw_length;\n-  gdb_assert (pstate->lexptr[0] == '\"');\n-  ++pstate->lexptr;\n-\n-  while (1)\n-    {\n-      uint32_t value;\n-\n-      if (raw_length > 0)\n-\t{\n-\t  if (pstate->lexptr[0] == '\"' && ends_raw_string (pstate->lexptr,\n-\t\t\t\t\t\t\t   raw_length - 1))\n-\t    {\n-\t      /* Exit with lexptr pointing after the final \"#\".  */\n-\t      pstate->lexptr += raw_length;\n-\t      break;\n-\t    }\n-\t  else if (pstate->lexptr[0] == '\\0')\n-\t    error (_(\"Unexpected EOF in string\"));\n-\n-\t  value = pstate->lexptr[0] & 0xff;\n-\t  if (is_byte && value > 127)\n-\t    error (_(\"Non-ASCII value in raw byte string\"));\n-\t  obstack_1grow (&obstack, value);\n-\n-\t  ++pstate->lexptr;\n-\t}\n-      else if (pstate->lexptr[0] == '\"')\n-\t{\n-\t  /* Make sure to skip the quote.  */\n-\t  ++pstate->lexptr;\n-\t  break;\n-\t}\n-      else if (pstate->lexptr[0] == '\\\\')\n-\t{\n-\t  value = lex_escape (is_byte);\n-\n-\t  if (is_byte)\n-\t    obstack_1grow (&obstack, value);\n-\t  else\n-\t    convert_between_encodings (\"UTF-32\", \"UTF-8\", (gdb_byte *) &value,\n-\t\t\t\t       sizeof (value), sizeof (value),\n-\t\t\t\t       &obstack, translit_none);\n-\t}\n-      else if (pstate->lexptr[0] == '\\0')\n-\terror (_(\"Unexpected EOF in string\"));\n-      else\n-\t{\n-\t  value = pstate->lexptr[0] & 0xff;\n-\t  if (is_byte && value > 127)\n-\t    error (_(\"Non-ASCII value in byte string\"));\n-\t  obstack_1grow (&obstack, value);\n-\t  ++pstate->lexptr;\n-\t}\n-    }\n-\n-  lvalp->sval.length = obstack_object_size (&obstack);\n-  lvalp->sval.ptr = (const char *) obstack_finish (&obstack);\n-  return is_byte ? BYTESTRING : STRING;\n-}\n-\n-/* Return true if STRING starts with whitespace followed by a digit.  */\n-\n-static bool\n-space_then_number (const char *string)\n-{\n-  const char *p = string;\n-\n-  while (p[0] == ' ' || p[0] == '\\t')\n-    ++p;\n-  if (p == string)\n-    return false;\n-\n-  return *p >= '0' && *p <= '9';\n-}\n-\n-/* Return true if C can start an identifier.  */\n-\n-static bool\n-rust_identifier_start_p (char c)\n-{\n-  return ((c >= 'a' && c <= 'z')\n-\t  || (c >= 'A' && c <= 'Z')\n-\t  || c == '_'\n-\t  || c == '$');\n-}\n-\n-/* Lex an identifier.  */\n-\n-int\n-rust_parser::lex_identifier (YYSTYPE *lvalp)\n-{\n-  const char *start = pstate->lexptr;\n-  unsigned int length;\n-  const struct token_info *token;\n-  int i;\n-  int is_gdb_var = pstate->lexptr[0] == '$';\n-\n-  gdb_assert (rust_identifier_start_p (pstate->lexptr[0]));\n-\n-  ++pstate->lexptr;\n-\n-  /* For the time being this doesn't handle Unicode rules.  Non-ASCII\n-     identifiers are gated anyway.  */\n-  while ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'z')\n-\t || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'Z')\n-\t || pstate->lexptr[0] == '_'\n-\t || (is_gdb_var && pstate->lexptr[0] == '$')\n-\t || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9'))\n-    ++pstate->lexptr;\n-\n-\n-  length = pstate->lexptr - start;\n-  token = NULL;\n-  for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n-    {\n-      if (length == strlen (identifier_tokens[i].name)\n-\t  && strncmp (identifier_tokens[i].name, start, length) == 0)\n-\t{\n-\t  token = &identifier_tokens[i];\n-\t  break;\n-\t}\n-    }\n-\n-  if (token != NULL)\n-    {\n-      if (token->value == 0)\n-\t{\n-\t  /* Leave the terminating token alone.  */\n-\t  pstate->lexptr = start;\n-\t  return 0;\n-\t}\n-    }\n-  else if (token == NULL\n-\t   && (strncmp (start, \"thread\", length) == 0\n-\t       || strncmp (start, \"task\", length) == 0)\n-\t   && space_then_number (pstate->lexptr))\n-    {\n-      /* \"task\" or \"thread\" followed by a number terminates the\n-\t parse, per gdb rules.  */\n-      pstate->lexptr = start;\n-      return 0;\n-    }\n-\n-  if (token == NULL || (pstate->parse_completion && pstate->lexptr[0] == '\\0'))\n-    lvalp->sval = make_stoken (copy_name (start, length));\n-\n-  if (pstate->parse_completion && pstate->lexptr[0] == '\\0')\n-    {\n-      /* Prevent rustyylex from returning two COMPLETE tokens.  */\n-      pstate->prev_lexptr = pstate->lexptr;\n-      return COMPLETE;\n-    }\n-\n-  if (token != NULL)\n-    return token->value;\n-  if (is_gdb_var)\n-    return GDBVAR;\n-  return IDENT;\n-}\n-\n-/* Lex an operator.  */\n-\n-int\n-rust_parser::lex_operator (YYSTYPE *lvalp)\n-{\n-  const struct token_info *token = NULL;\n-  int i;\n-\n-  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n-    {\n-      if (strncmp (operator_tokens[i].name, pstate->lexptr,\n-\t\t   strlen (operator_tokens[i].name)) == 0)\n-\t{\n-\t  pstate->lexptr += strlen (operator_tokens[i].name);\n-\t  token = &operator_tokens[i];\n-\t  break;\n-\t}\n-    }\n-\n-  if (token != NULL)\n-    {\n-      lvalp->opcode = token->opcode;\n-      return token->value;\n-    }\n-\n-  return *pstate->lexptr++;\n-}\n-\n-/* Lex a number.  */\n-\n-int\n-rust_parser::lex_number (YYSTYPE *lvalp)\n-{\n-  regmatch_t subexps[NUM_SUBEXPRESSIONS];\n-  int match;\n-  int is_integer = 0;\n-  int could_be_decimal = 1;\n-  int implicit_i32 = 0;\n-  const char *type_name = NULL;\n-  struct type *type;\n-  int end_index;\n-  int type_index = -1;\n-  int i;\n-\n-  match = regexec (&number_regex, pstate->lexptr, ARRAY_SIZE (subexps),\n-\t\t   subexps, 0);\n-  /* Failure means the regexp is broken.  */\n-  gdb_assert (match == 0);\n-\n-  if (subexps[INT_TEXT].rm_so != -1)\n-    {\n-      /* Integer part matched.  */\n-      is_integer = 1;\n-      end_index = subexps[INT_TEXT].rm_eo;\n-      if (subexps[INT_TYPE].rm_so == -1)\n-\t{\n-\t  type_name = \"i32\";\n-\t  implicit_i32 = 1;\n-\t}\n-      else\n-\t{\n-\t  type_index = INT_TYPE;\n-\t  could_be_decimal = 0;\n-\t}\n-    }\n-  else if (subexps[FLOAT_TYPE1].rm_so != -1)\n-    {\n-      /* Found floating point type suffix.  */\n-      end_index = subexps[FLOAT_TYPE1].rm_so;\n-      type_index = FLOAT_TYPE1;\n-    }\n-  else if (subexps[FLOAT_TYPE2].rm_so != -1)\n-    {\n-      /* Found floating point type suffix.  */\n-      end_index = subexps[FLOAT_TYPE2].rm_so;\n-      type_index = FLOAT_TYPE2;\n-    }\n-  else\n-    {\n-      /* Any other floating point match.  */\n-      end_index = subexps[0].rm_eo;\n-      type_name = \"f64\";\n-    }\n-\n-  /* We need a special case if the final character is \".\".  In this\n-     case we might need to parse an integer.  For example, \"23.f()\" is\n-     a request for a trait method call, not a syntax error involving\n-     the floating point number \"23.\".  */\n-  gdb_assert (subexps[0].rm_eo > 0);\n-  if (pstate->lexptr[subexps[0].rm_eo - 1] == '.')\n-    {\n-      const char *next = skip_spaces (&pstate->lexptr[subexps[0].rm_eo]);\n-\n-      if (rust_identifier_start_p (*next) || *next == '.')\n-\t{\n-\t  --subexps[0].rm_eo;\n-\t  is_integer = 1;\n-\t  end_index = subexps[0].rm_eo;\n-\t  type_name = \"i32\";\n-\t  could_be_decimal = 1;\n-\t  implicit_i32 = 1;\n-\t}\n-    }\n-\n-  /* Compute the type name if we haven't already.  */\n-  std::string type_name_holder;\n-  if (type_name == NULL)\n-    {\n-      gdb_assert (type_index != -1);\n-      type_name_holder = std::string ((pstate->lexptr\n-\t\t\t\t       + subexps[type_index].rm_so),\n-\t\t\t\t      (subexps[type_index].rm_eo\n-\t\t\t\t       - subexps[type_index].rm_so));\n-      type_name = type_name_holder.c_str ();\n-    }\n-\n-  /* Look up the type.  */\n-  type = get_type (type_name);\n-\n-  /* Copy the text of the number and remove the \"_\"s.  */\n-  std::string number;\n-  for (i = 0; i < end_index && pstate->lexptr[i]; ++i)\n-    {\n-      if (pstate->lexptr[i] == '_')\n-\tcould_be_decimal = 0;\n-      else\n-\tnumber.push_back (pstate->lexptr[i]);\n-    }\n-\n-  /* Advance past the match.  */\n-  pstate->lexptr += subexps[0].rm_eo;\n-\n-  /* Parse the number.  */\n-  if (is_integer)\n-    {\n-      uint64_t value;\n-      int radix = 10;\n-      int offset = 0;\n-\n-      if (number[0] == '0')\n-\t{\n-\t  if (number[1] == 'x')\n-\t    radix = 16;\n-\t  else if (number[1] == 'o')\n-\t    radix = 8;\n-\t  else if (number[1] == 'b')\n-\t    radix = 2;\n-\t  if (radix != 10)\n-\t    {\n-\t      offset = 2;\n-\t      could_be_decimal = 0;\n-\t    }\n-\t}\n-\n-      value = strtoulst (number.c_str () + offset, NULL, radix);\n-      if (implicit_i32 && value >= ((uint64_t) 1) << 31)\n-\ttype = get_type (\"i64\");\n-\n-      lvalp->typed_val_int.val = value;\n-      lvalp->typed_val_int.type = type;\n-    }\n-  else\n-    {\n-      lvalp->typed_val_float.type = type;\n-      bool parsed = parse_float (number.c_str (), number.length (),\n-\t\t\t\t lvalp->typed_val_float.type,\n-\t\t\t\t lvalp->typed_val_float.val);\n-      gdb_assert (parsed);\n-    }\n-\n-  return is_integer ? (could_be_decimal ? DECIMAL_INTEGER : INTEGER) : FLOAT;\n-}\n-\n-/* The lexer.  */\n-\n-static int\n-rustyylex (YYSTYPE *lvalp, rust_parser *parser)\n-{\n-  struct parser_state *pstate = parser->pstate;\n-\n-  /* Skip all leading whitespace.  */\n-  while (pstate->lexptr[0] == ' '\n-\t || pstate->lexptr[0] == '\\t'\n-\t || pstate->lexptr[0] == '\\r'\n-\t || pstate->lexptr[0] == '\\n')\n-    ++pstate->lexptr;\n-\n-  /* If we hit EOF and we're completing, then return COMPLETE -- maybe\n-     we're completing an empty string at the end of a field_expr.\n-     But, we don't want to return two COMPLETE tokens in a row.  */\n-  if (pstate->lexptr[0] == '\\0' && pstate->lexptr == pstate->prev_lexptr)\n-    return 0;\n-  pstate->prev_lexptr = pstate->lexptr;\n-  if (pstate->lexptr[0] == '\\0')\n-    {\n-      if (pstate->parse_completion)\n-\t{\n-\t  lvalp->sval = make_stoken (\"\");\n-\t  return COMPLETE;\n-\t}\n-      return 0;\n-    }\n-\n-  if (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')\n-    return parser->lex_number (lvalp);\n-  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\\'')\n-    return parser->lex_character (lvalp);\n-  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\"')\n-    return parser->lex_string (lvalp);\n-  else if (pstate->lexptr[0] == 'b' && starts_raw_string (pstate->lexptr + 1))\n-    return parser->lex_string (lvalp);\n-  else if (starts_raw_string (pstate->lexptr))\n-    return parser->lex_string (lvalp);\n-  else if (rust_identifier_start_p (pstate->lexptr[0]))\n-    return parser->lex_identifier (lvalp);\n-  else if (pstate->lexptr[0] == '\"')\n-    return parser->lex_string (lvalp);\n-  else if (pstate->lexptr[0] == '\\'')\n-    return parser->lex_character (lvalp);\n-  else if (pstate->lexptr[0] == '}' || pstate->lexptr[0] == ']')\n-    {\n-      /* Falls through to lex_operator.  */\n-      --parser->paren_depth;\n-    }\n-  else if (pstate->lexptr[0] == '(' || pstate->lexptr[0] == '{')\n-    {\n-      /* Falls through to lex_operator.  */\n-      ++parser->paren_depth;\n-    }\n-  else if (pstate->lexptr[0] == ',' && pstate->comma_terminates\n-\t   && parser->paren_depth == 0)\n-    return 0;\n-\n-  return parser->lex_operator (lvalp);\n-}\n-\n-/* Push back a single character to be re-lexed.  */\n-\n-void\n-rust_parser::push_back (char c)\n-{\n-  /* Can't be called before any lexing.  */\n-  gdb_assert (pstate->prev_lexptr != NULL);\n-\n-  --pstate->lexptr;\n-  gdb_assert (*pstate->lexptr == c);\n-}\n-\n-\f\n-\n-/* Make an arbitrary operation and fill in the fields.  */\n-\n-const struct rust_op *\n-rust_parser::ast_operation (enum exp_opcode opcode, const struct rust_op *left,\n-\t\t\t    const struct rust_op *right)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = opcode;\n-  result->left.op = left;\n-  result->right.op = right;\n-\n-  return result;\n-}\n-\n-/* Make a compound assignment operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_compound_assignment (enum exp_opcode opcode,\n-\t\t\t\t      const struct rust_op *left,\n-\t\t\t\t      const struct rust_op *right)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = opcode;\n-  result->compound_assignment = 1;\n-  result->left.op = left;\n-  result->right.op = right;\n-\n-  return result;\n-}\n-\n-/* Make a typed integer literal operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_literal (struct typed_val_int val)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_LONG;\n-  result->left.typed_val_int = val;\n-\n-  return result;\n-}\n-\n-/* Make a typed floating point literal operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_dliteral (struct typed_val_float val)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_FLOAT;\n-  result->left.typed_val_float = val;\n-\n-  return result;\n-}\n-\n-/* Make a unary operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_unary (enum exp_opcode opcode, const struct rust_op *expr)\n-{\n-  return ast_operation (opcode, expr, NULL);\n-}\n-\n-/* Make a cast operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_cast (const struct rust_op *expr, const struct rust_op *type)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = UNOP_CAST;\n-  result->left.op = expr;\n-  result->right.op = type;\n-\n-  return result;\n-}\n-\n-/* Make a call-like operation.  This is nominally a function call, but\n-   when lowering we may discover that it actually represents the\n-   creation of a tuple struct.  */\n-\n-const struct rust_op *\n-rust_parser::ast_call_ish (enum exp_opcode opcode, const struct rust_op *expr,\n-\t\t\t   rust_op_vector *params)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = opcode;\n-  result->left.op = expr;\n-  result->right.params = params;\n-\n-  return result;\n-}\n-\n-/* Make a structure creation operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_struct (const struct rust_op *name, rust_set_vector *fields)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_AGGREGATE;\n-  result->left.op = name;\n-  result->right.field_inits = fields;\n-\n-  return result;\n-}\n-\n-/* Make an identifier path.  */\n-\n-const struct rust_op *\n-rust_parser::ast_path (struct stoken path, rust_op_vector *params)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_VAR_VALUE;\n-  result->left.sval = path;\n-  result->right.params = params;\n-\n-  return result;\n-}\n-\n-/* Make a string constant operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_string (struct stoken str)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_STRING;\n-  result->left.sval = str;\n-\n-  return result;\n-}\n-\n-/* Make a field expression.  */\n-\n-const struct rust_op *\n-rust_parser::ast_structop (const struct rust_op *left, const char *name,\n-\t\t\t   int completing)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = STRUCTOP_STRUCT;\n-  result->completing = completing;\n-  result->left.op = left;\n-  result->right.sval = make_stoken (name);\n-\n-  return result;\n-}\n-\n-/* Make an anonymous struct operation, like 'x.0'.  */\n-\n-const struct rust_op *\n-rust_parser::ast_structop_anonymous (const struct rust_op *left,\n-\t\t\t\t     struct typed_val_int number)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = STRUCTOP_ANONYMOUS;\n-  result->left.op = left;\n-  result->right.typed_val_int = number;\n-\n-  return result;\n-}\n-\n-/* Make a range operation.  */\n-\n-const struct rust_op *\n-rust_parser::ast_range (const struct rust_op *lhs, const struct rust_op *rhs,\n-\t\t\tbool inclusive)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_RANGE;\n-  result->inclusive = inclusive;\n-  result->left.op = lhs;\n-  result->right.op = rhs;\n-\n-  return result;\n-}\n-\n-/* A helper function to make a type-related AST node.  */\n-\n-struct rust_op *\n-rust_parser::ast_basic_type (enum type_code typecode)\n-{\n-  struct rust_op *result = OBSTACK_ZALLOC (&obstack, struct rust_op);\n-\n-  result->opcode = OP_TYPE;\n-  result->typecode = typecode;\n-  return result;\n-}\n-\n-/* Create an AST node describing an array type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_array_type (const struct rust_op *lhs,\n-\t\t\t     struct typed_val_int val)\n-{\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_ARRAY);\n-\n-  result->left.op = lhs;\n-  result->right.typed_val_int = val;\n-  return result;\n-}\n-\n-/* Create an AST node describing a reference type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_slice_type (const struct rust_op *type)\n-{\n-  /* Use TYPE_CODE_COMPLEX just because it is handy.  */\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_COMPLEX);\n-\n-  result->left.op = type;\n-  return result;\n-}\n-\n-/* Create an AST node describing a reference type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_reference_type (const struct rust_op *type)\n-{\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_REF);\n-\n-  result->left.op = type;\n-  return result;\n-}\n-\n-/* Create an AST node describing a pointer type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_pointer_type (const struct rust_op *type, int is_mut)\n-{\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_PTR);\n-\n-  result->left.op = type;\n-  /* For the time being we ignore is_mut.  */\n-  return result;\n-}\n-\n-/* Create an AST node describing a function type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_function_type (const struct rust_op *rtype,\n-\t\t\t\trust_op_vector *params)\n-{\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_FUNC);\n-\n-  result->left.op = rtype;\n-  result->right.params = params;\n-  return result;\n-}\n-\n-/* Create an AST node describing a tuple type.  */\n-\n-const struct rust_op *\n-rust_parser::ast_tuple_type (rust_op_vector *params)\n-{\n-  struct rust_op *result = ast_basic_type (TYPE_CODE_STRUCT);\n-\n-  result->left.params = params;\n-  return result;\n-}\n-\n-/* A helper to appropriately munge NAME and BLOCK depending on the\n-   presence of a leading \"::\".  */\n-\n-static void\n-munge_name_and_block (const char **name, const struct block **block)\n-{\n-  /* If it is a global reference, skip the current block in favor of\n-     the static block.  */\n-  if (startswith (*name, \"::\"))\n-    {\n-      *name += 2;\n-      *block = block_static_block (*block);\n-    }\n-}\n-\n-/* Like lookup_symbol, but handles Rust namespace conventions, and\n-   doesn't require field_of_this_result.  */\n-\n-struct block_symbol\n-rust_parser::lookup_symbol (const char *name, const struct block *block,\n-\t\t\t    const domain_enum domain)\n-{\n-  struct block_symbol result;\n-\n-  munge_name_and_block (&name, &block);\n-\n-  result = ::lookup_symbol (name, block, domain, NULL);\n-  if (result.symbol != NULL)\n-    update_innermost_block (result);\n-  return result;\n-}\n-\n-/* Look up a type, following Rust namespace conventions.  */\n-\n-struct type *\n-rust_parser::rust_lookup_type (const char *name, const struct block *block)\n-{\n-  struct block_symbol result;\n-  struct type *type;\n-\n-  munge_name_and_block (&name, &block);\n-\n-  result = ::lookup_symbol (name, block, STRUCT_DOMAIN, NULL);\n-  if (result.symbol != NULL)\n-    {\n-      update_innermost_block (result);\n-      return SYMBOL_TYPE (result.symbol);\n-    }\n-\n-  type = lookup_typename (language (), name, NULL, 1);\n-  if (type != NULL)\n-    return type;\n-\n-  /* Last chance, try a built-in type.  */\n-  return language_lookup_primitive_type (language (), arch (), name);\n-}\n-\n-/* Convert a vector of rust_ops representing types to a vector of\n-   types.  */\n-\n-std::vector<struct type *>\n-rust_parser::convert_params_to_types (rust_op_vector *params)\n-{\n-  std::vector<struct type *> result;\n-\n-  if (params != nullptr)\n-    {\n-      for (const rust_op *op : *params)\n-\tresult.push_back (convert_ast_to_type (op));\n-    }\n-\n-  return result;\n-}\n-\n-/* Convert a rust_op representing a type to a struct type *.  */\n-\n-struct type *\n-rust_parser::convert_ast_to_type (const struct rust_op *operation)\n-{\n-  struct type *type, *result = NULL;\n-\n-  if (operation->opcode == OP_VAR_VALUE)\n-    {\n-      const char *varname = convert_name (operation);\n-\n-      result = rust_lookup_type (varname, pstate->expression_context_block);\n-      if (result == NULL)\n-\terror (_(\"No typed name '%s' in current context\"), varname);\n-      return result;\n-    }\n-\n-  gdb_assert (operation->opcode == OP_TYPE);\n-\n-  switch (operation->typecode)\n-    {\n-    case TYPE_CODE_ARRAY:\n-      type = convert_ast_to_type (operation->left.op);\n-      if (operation->right.typed_val_int.val < 0)\n-\terror (_(\"Negative array length\"));\n-      result = lookup_array_range_type (type, 0,\n-\t\t\t\t\toperation->right.typed_val_int.val - 1);\n-      break;\n-\n-    case TYPE_CODE_COMPLEX:\n-      {\n-\tstruct type *usize = get_type (\"usize\");\n-\n-\ttype = convert_ast_to_type (operation->left.op);\n-\tresult = rust_slice_type (\"&[*gdb*]\", type, usize);\n-      }\n-      break;\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_PTR:\n-      /* For now we treat &x and *x identically.  */\n-      type = convert_ast_to_type (operation->left.op);\n-      result = lookup_pointer_type (type);\n-      break;\n-\n-    case TYPE_CODE_FUNC:\n-      {\n-\tstd::vector<struct type *> args\n-\t  (convert_params_to_types (operation->right.params));\n-\tstruct type **argtypes = NULL;\n-\n-\ttype = convert_ast_to_type (operation->left.op);\n-\tif (!args.empty ())\n-\t  argtypes = args.data ();\n-\n-\tresult\n-\t  = lookup_function_type_with_arguments (type, args.size (),\n-\t\t\t\t\t\t argtypes);\n-\tresult = lookup_pointer_type (result);\n-      }\n-      break;\n-\n-    case TYPE_CODE_STRUCT:\n-      {\n-\tstd::vector<struct type *> args\n-\t  (convert_params_to_types (operation->left.params));\n-\tint i;\n-\tconst char *name;\n-\n-\tobstack_1grow (&obstack, '(');\n-\tfor (i = 0; i < args.size (); ++i)\n-\t  {\n-\t    std::string type_name = type_to_string (args[i]);\n-\n-\t    if (i > 0)\n-\t      obstack_1grow (&obstack, ',');\n-\t    obstack_grow_str (&obstack, type_name.c_str ());\n-\t  }\n-\n-\tobstack_grow_str0 (&obstack, \")\");\n-\tname = (const char *) obstack_finish (&obstack);\n-\n-\t/* We don't allow creating new tuple types (yet), but we do\n-\t   allow looking up existing tuple types.  */\n-\tresult = rust_lookup_type (name, pstate->expression_context_block);\n-\tif (result == NULL)\n-\t  error (_(\"could not find tuple type '%s'\"), name);\n-      }\n-      break;\n-\n-    default:\n-      gdb_assert_not_reached (\"unhandled opcode in convert_ast_to_type\");\n-    }\n-\n-  gdb_assert (result != NULL);\n-  return result;\n-}\n-\n-/* A helper function to turn a rust_op representing a name into a full\n-   name.  This applies generic arguments as needed.  The returned name\n-   is allocated on the work obstack.  */\n-\n-const char *\n-rust_parser::convert_name (const struct rust_op *operation)\n-{\n-  int i;\n-\n-  gdb_assert (operation->opcode == OP_VAR_VALUE);\n-\n-  if (operation->right.params == NULL)\n-    return operation->left.sval.ptr;\n-\n-  std::vector<struct type *> types\n-    (convert_params_to_types (operation->right.params));\n-\n-  obstack_grow_str (&obstack, operation->left.sval.ptr);\n-  obstack_1grow (&obstack, '<');\n-  for (i = 0; i < types.size (); ++i)\n-    {\n-      std::string type_name = type_to_string (types[i]);\n-\n-      if (i > 0)\n-\tobstack_1grow (&obstack, ',');\n-\n-      obstack_grow_str (&obstack, type_name.c_str ());\n-    }\n-  obstack_grow_str0 (&obstack, \">\");\n-\n-  return (const char *) obstack_finish (&obstack);\n-}\n-\n-/* A helper function that converts a vec of rust_ops to a gdb\n-   expression.  */\n-\n-std::vector<expr::operation_up>\n-rust_parser::convert_params_to_expression (rust_op_vector *params,\n-\t\t\t\t\t   const struct rust_op *top)\n-{\n-  std::vector<expr::operation_up> result;\n-  for (const rust_op *elem : *params)\n-    result.push_back (convert_ast_to_expression (elem, top));\n-  result.shrink_to_fit ();\n-  return result;\n-}\n-\n-typedef expr::operation_up binop_maker_ftype (expr::operation_up &&,\n-\t\t\t\t\t      expr::operation_up &&);\n-\n-/* Map from an expression opcode to a function that will create an\n-   instance of the appropriate operation subclass.  Only binary\n-   operations are handled this way.  */\n-static std::unordered_map<exp_opcode, binop_maker_ftype *,\n-\t\t\t  gdb::hash_enum<exp_opcode>> maker_map;\n-\n-/* Lower a rust_op to a gdb expression.  STATE is the parser state.\n-   OPERATION is the operation to lower.  TOP is a pointer to the\n-   top-most operation; it is used to handle the special case where the\n-   top-most expression is an identifier and can be optionally lowered\n-   to OP_TYPE.  WANT_TYPE is a flag indicating that, if the expression\n-   is the name of a type, then emit an OP_TYPE for it (rather than\n-   erroring).  If WANT_TYPE is set, then the similar TOP handling is\n-   not done.  */\n-\n-expr::operation_up\n-rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n-\t\t\t\t\tconst struct rust_op *top,\n-\t\t\t\t\tbool want_type)\n-{\n-  using namespace expr;\n-\n-  switch (operation->opcode)\n-    {\n-    case OP_LONG:\n-      return operation_up\n-\t(new long_const_operation (operation->left.typed_val_int.type,\n-\t\t\t\t   operation->left.typed_val_int.val));\n-\n-    case OP_FLOAT:\n-      {\n-\tfloat_data data;\n-\tmemcpy (data.data (), operation->left.typed_val_float.val,\n-\t\tsizeof (operation->left.typed_val_float.val));\n-\treturn operation_up\n-\t  (new float_const_operation (operation->left.typed_val_float.type,\n-\t\t\t\t      data));\n-      }\n-\n-    case STRUCTOP_STRUCT:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\tauto result = new rust_structop (std::move (lhs),\n-\t\t\t\t\t operation->right.sval.ptr);\n-\tif (operation->completing)\n-\t  pstate->mark_struct_expression (result);\n-\treturn operation_up (result);\n-      }\n-\n-    case STRUCTOP_ANONYMOUS:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\n-\treturn operation_up\n-\t  (new rust_struct_anon (operation->right.typed_val_int.val,\n-\t\t\t\t std::move (lhs)));\n-      }\n-\n-    case UNOP_SIZEOF:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top,\n-\t\t\t\t\t\t      true);\n-\treturn operation_up\n-\t  (new unop_sizeof_operation (std::move (lhs)));\n-      }\n-\n-    case UNOP_PLUS:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up\n-\t  (new unary_plus_operation (std::move (lhs)));\n-      }\n-    case UNOP_NEG:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up\n-\t  (new unary_neg_operation (std::move (lhs)));\n-      }\n-    case UNOP_COMPLEMENT:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up\n-\t  (new rust_unop_compl_operation (std::move (lhs)));\n-      }\n-    case UNOP_IND:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up\n-\t  (new rust_unop_ind_operation (std::move (lhs)));\n-      }\n-    case UNOP_ADDR:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up\n-\t  (new rust_unop_addr_operation (std::move (lhs)));\n-      }\n-\n-    case BINOP_SUBSCRIPT:\n-    case BINOP_MUL:\n-    case BINOP_REPEAT:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_LOGICAL_OR:\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-    case BINOP_LSH:\n-    case BINOP_RSH:\n-    case BINOP_ASSIGN:\n-    case OP_RUST_ARRAY:\n-      {\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\toperation_up rhs = convert_ast_to_expression (operation->right.op,\n-\t\t\t\t\t\t      top);\n-\toperation_up result;\n-\tif (operation->compound_assignment)\n-\t  result = (operation_up\n-\t\t    (new assign_modify_operation (operation->opcode,\n-\t\t\t\t\t\t  std::move (lhs),\n-\t\t\t\t\t\t  std::move (rhs))));\n-\telse\n-\t  {\n-\t    auto iter = maker_map.find (operation->opcode);\n-\t    gdb_assert (iter != maker_map.end ());\n-\t    result = iter->second (std::move (lhs), std::move (rhs));\n-\t  }\n-\n-\tif (operation->compound_assignment\n-\t    || operation->opcode == BINOP_ASSIGN)\n-\t  {\n-\t    struct type *type\n-\t      = language_lookup_primitive_type (pstate->language (),\n-\t\t\t\t\t\tpstate->gdbarch (),\n-\t\t\t\t\t\t\"()\");\n-\n-\t    operation_up nil (new long_const_operation (type, 0));\n-\t    result.reset (new comma_operation (std::move (result),\n-\t\t\t\t\t       std::move (nil)));\n-\t  }\n-\n-\treturn result;\n-      }\n-\n-    case UNOP_CAST:\n-      {\n-\tstruct type *type = convert_ast_to_type (operation->right.op);\n-\toperation_up lhs = convert_ast_to_expression (operation->left.op, top);\n-\treturn operation_up (new unop_cast_operation (std::move (lhs), type));\n-      }\n-\n-    case OP_FUNCALL:\n-      {\n-\tif (operation->left.op->opcode == OP_VAR_VALUE)\n-\t  {\n-\t    struct type *type;\n-\t    const char *varname = convert_name (operation->left.op);\n-\n-\t    type = rust_lookup_type (varname,\n-\t\t\t\t     pstate->expression_context_block);\n-\t    if (type != NULL)\n-\t      {\n-\t\t/* This is actually a tuple struct expression, not a\n-\t\t   call expression.  */\n-\t\trust_op_vector *params = operation->right.params;\n-\n-\t\tif (type->code () != TYPE_CODE_NAMESPACE)\n-\t\t  {\n-\t\t    if (!rust_tuple_struct_type_p (type))\n-\t\t      error (_(\"Type %s is not a tuple struct\"), varname);\n-\n-\t\t    std::vector<std::pair<std::string, operation_up>> args\n-\t\t      (params->size ());\n-\t\t    for (int i = 0; i < params->size (); ++i)\n-\t\t      {\n-\t\t\tchar *cell = get_print_cell ();\n-\n-\t\t\toperation_up op\n-\t\t\t  = convert_ast_to_expression ((*params)[i], top);\n-\t\t\txsnprintf (cell, PRINT_CELL_SIZE, \"__%d\", i);\n-\t\t\targs[i] = { cell, std::move (op) };\n-\t\t      }\n-\n-\t\t    return make_operation<rust_aggregate_operation>\n-\t\t      (type, operation_up (), std::move (args));\n-\t\t  }\n-\t      }\n-\t  }\n-\toperation_up callee = convert_ast_to_expression (operation->left.op,\n-\t\t\t\t\t\t\t top);\n-\tstd::vector<operation_up> args\n-\t  = convert_params_to_expression (operation->right.params, top);\n-\treturn make_operation<funcall_operation> (std::move (callee),\n-\t\t\t\t\t\t  std::move (args));\n-      }\n-\n-    case OP_ARRAY:\n-      {\n-\tgdb_assert (operation->left.op == NULL);\n-\tstd::vector<operation_up> subexps\n-\t  = convert_params_to_expression (operation->right.params, top);\n-\treturn make_operation<array_operation>\n-\t  (0, operation->right.params->size () - 1, std::move (subexps));\n-      }\n-\n-    case OP_VAR_VALUE:\n-      {\n-\tstruct block_symbol sym;\n-\tconst char *varname;\n-\n-\tif (operation->left.sval.ptr[0] == '$')\n-\t  {\n-\t    pstate->push_dollar (operation->left.sval);\n-\t    return pstate->pop ();\n-\t  }\n-\n-\tvarname = convert_name (operation);\n-\tsym = lookup_symbol (varname, pstate->expression_context_block,\n-\t\t\t     VAR_DOMAIN);\n-\toperation_up result;\n-\tif (sym.symbol != NULL && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n-\t  result.reset (new var_value_operation (sym));\n-\telse\n-\t  {\n-\t    struct type *type = NULL;\n-\n-\t    if (sym.symbol != NULL)\n-\t      {\n-\t\tgdb_assert (SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF);\n-\t\ttype = SYMBOL_TYPE (sym.symbol);\n-\t      }\n-\t    if (type == NULL)\n-\t      type = rust_lookup_type (varname,\n-\t\t\t\t       pstate->expression_context_block);\n-\t    if (type == NULL)\n-\t      error (_(\"No symbol '%s' in current context\"), varname);\n-\n-\t    if (!want_type\n-\t\t&& type->code () == TYPE_CODE_STRUCT\n-\t\t&& type->num_fields () == 0)\n-\t      {\n-\t\t/* A unit-like struct.  */\n-\t\tresult.reset (new rust_aggregate_operation (type, {}, {}));\n-\t      }\n-\t    else if (want_type || operation == top)\n-\t      result.reset (new type_operation (type));\n-\t    else\n-\t      error (_(\"Found type '%s', which can't be \"\n-\t\t       \"evaluated in this context\"),\n-\t\t     varname);\n-\t  }\n-\n-\treturn result;\n-      }\n-\n-    case OP_AGGREGATE:\n-      {\n-\trust_set_vector *fields = operation->right.field_inits;\n-\tstruct type *type;\n-\tconst char *name;\n-\n-\toperation_up others;\n-\tstd::vector<std::pair<std::string, operation_up>> field_v;\n-\tfor (const set_field &init : *fields)\n-\t  {\n-\t    operation_up expr = convert_ast_to_expression (init.init, top);\n-\n-\t    if (init.name.ptr == NULL)\n-\t      others = std::move (expr);\n-\t    else\n-\t      field_v.emplace_back (init.name.ptr, std::move (expr));\n-\t  }\n-\n-\tname = convert_name (operation->left.op);\n-\ttype = rust_lookup_type (name, pstate->expression_context_block);\n-\tif (type == NULL)\n-\t  error (_(\"Could not find type '%s'\"), operation->left.sval.ptr);\n-\n-\tif (type->code () != TYPE_CODE_STRUCT\n-\t    || rust_tuple_type_p (type)\n-\t    || rust_tuple_struct_type_p (type))\n-\t  error (_(\"Struct expression applied to non-struct type\"));\n-\n-\treturn operation_up\n-\t  (new rust_aggregate_operation (type, std::move (others),\n-\t\t\t\t\t std::move (field_v)));\n-      }\n-\n-    case OP_STRING:\n-      return (operation_up\n-\t      (new string_operation (::copy_name (operation->left.sval))));\n-\n-    case OP_RANGE:\n-      {\n-\tenum range_flag kind = (RANGE_HIGH_BOUND_DEFAULT\n-\t\t\t\t| RANGE_LOW_BOUND_DEFAULT);\n-\toperation_up lhs, rhs;\n-\n-\tif (operation->left.op != NULL)\n-\t  {\n-\t    lhs = convert_ast_to_expression (operation->left.op, top);\n-\t    kind &= ~RANGE_LOW_BOUND_DEFAULT;\n-\t  }\n-\tif (operation->right.op != NULL)\n-\t  {\n-\t    rhs = convert_ast_to_expression (operation->right.op, top);\n-\t    if (kind == (RANGE_HIGH_BOUND_DEFAULT | RANGE_LOW_BOUND_DEFAULT))\n-\t      {\n-\t\tkind = RANGE_LOW_BOUND_DEFAULT;\n-\t\tif (!operation->inclusive)\n-\t\t  kind |= RANGE_HIGH_BOUND_EXCLUSIVE;\n-\t      }\n-\t    else\n-\t      {\n-\t\tgdb_assert (kind == RANGE_HIGH_BOUND_DEFAULT);\n-\t\tkind = RANGE_STANDARD;\n-\t\tif (!operation->inclusive)\n-\t\t  kind |= RANGE_HIGH_BOUND_EXCLUSIVE;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    /* Nothing should make an inclusive range without an upper\n-\t       bound.  */\n-\t    gdb_assert (!operation->inclusive);\n-\t  }\n-\n-\treturn operation_up (new rust_range_operation (kind,\n-\t\t\t\t\t\t       std::move (lhs),\n-\t\t\t\t\t\t       std::move (rhs)));\n-      }\n-\n-    default:\n-      gdb_assert_not_reached (\"unhandled opcode in convert_ast_to_expression\");\n-    }\n-}\n-\n-\f\n-\n-/* The parser as exposed to gdb.  */\n-\n-int\n-rust_language::parser (struct parser_state *state) const\n-{\n-  int result;\n-\n-  /* This sets various globals and also clears them on\n-     destruction.  */\n-  rust_parser parser (state);\n-\n-  result = rustyyparse (&parser);\n-\n-  if (!result || (state->parse_completion && parser.rust_ast != NULL))\n-    {\n-      expr::operation_up op\n-\t= parser.convert_ast_to_expression (parser.rust_ast, parser.rust_ast);\n-      state->set_operation (std::move (op));\n-    }\n-\n-  return result;\n-}\n-\n-/* The parser error handler.  */\n-\n-static void\n-rustyyerror (rust_parser *parser, const char *msg)\n-{\n-  const char *where = (parser->pstate->prev_lexptr\n-\t\t       ? parser->pstate->prev_lexptr\n-\t\t       : parser->pstate->lexptr);\n-  error (_(\"%s in expression, near `%s'.\"), msg, where);\n-}\n-\n-\f\n-\n-#if GDB_SELF_TEST\n-\n-/* Initialize the lexer for testing.  */\n-\n-static void\n-rust_lex_test_init (rust_parser *parser, const char *input)\n-{\n-  parser->pstate->prev_lexptr = NULL;\n-  parser->pstate->lexptr = input;\n-  parser->paren_depth = 0;\n-}\n-\n-/* A test helper that lexes a string, expecting a single token.  It\n-   returns the lexer data for this token.  */\n-\n-static RUSTSTYPE\n-rust_lex_test_one (rust_parser *parser, const char *input, int expected)\n-{\n-  int token;\n-  RUSTSTYPE result;\n-\n-  rust_lex_test_init (parser, input);\n-\n-  token = rustyylex (&result, parser);\n-  SELF_CHECK (token == expected);\n-\n-  if (token)\n-    {\n-      RUSTSTYPE ignore;\n-      token = rustyylex (&ignore, parser);\n-      SELF_CHECK (token == 0);\n-    }\n-\n-  return result;\n-}\n-\n-/* Test that INPUT lexes as the integer VALUE.  */\n-\n-static void\n-rust_lex_int_test (rust_parser *parser, const char *input,\n-\t\t   LONGEST value, int kind)\n-{\n-  RUSTSTYPE result = rust_lex_test_one (parser, input, kind);\n-  SELF_CHECK (result.typed_val_int.val == value);\n-}\n-\n-/* Test that INPUT throws an exception with text ERR.  */\n-\n-static void\n-rust_lex_exception_test (rust_parser *parser, const char *input,\n-\t\t\t const char *err)\n-{\n-  try\n-    {\n-      /* The \"kind\" doesn't matter.  */\n-      rust_lex_test_one (parser, input, DECIMAL_INTEGER);\n-      SELF_CHECK (0);\n-    }\n-  catch (const gdb_exception_error &except)\n-    {\n-      SELF_CHECK (strcmp (except.what (), err) == 0);\n-    }\n-}\n-\n-/* Test that INPUT lexes as the identifier, string, or byte-string\n-   VALUE.  KIND holds the expected token kind.  */\n-\n-static void\n-rust_lex_stringish_test (rust_parser *parser, const char *input,\n-\t\t\t const char *value, int kind)\n-{\n-  RUSTSTYPE result = rust_lex_test_one (parser, input, kind);\n-  SELF_CHECK (result.sval.length == strlen (value));\n-  SELF_CHECK (strncmp (result.sval.ptr, value, result.sval.length) == 0);\n-}\n-\n-/* Helper to test that a string parses as a given token sequence.  */\n-\n-static void\n-rust_lex_test_sequence (rust_parser *parser, const char *input, int len,\n-\t\t\tconst int expected[])\n-{\n-  int i;\n-\n-  parser->pstate->lexptr = input;\n-  parser->paren_depth = 0;\n-\n-  for (i = 0; i < len; ++i)\n-    {\n-      RUSTSTYPE ignore;\n-      int token = rustyylex (&ignore, parser);\n-\n-      SELF_CHECK (token == expected[i]);\n-    }\n-}\n-\n-/* Tests for an integer-parsing corner case.  */\n-\n-static void\n-rust_lex_test_trailing_dot (rust_parser *parser)\n-{\n-  const int expected1[] = { DECIMAL_INTEGER, '.', IDENT, '(', ')', 0 };\n-  const int expected2[] = { INTEGER, '.', IDENT, '(', ')', 0 };\n-  const int expected3[] = { FLOAT, EQEQ, '(', ')', 0 };\n-  const int expected4[] = { DECIMAL_INTEGER, DOTDOT, DECIMAL_INTEGER, 0 };\n-\n-  rust_lex_test_sequence (parser, \"23.g()\", ARRAY_SIZE (expected1), expected1);\n-  rust_lex_test_sequence (parser, \"23_0.g()\", ARRAY_SIZE (expected2),\n-\t\t\t  expected2);\n-  rust_lex_test_sequence (parser, \"23.==()\", ARRAY_SIZE (expected3),\n-\t\t\t  expected3);\n-  rust_lex_test_sequence (parser, \"23..25\", ARRAY_SIZE (expected4), expected4);\n-}\n-\n-/* Tests of completion.  */\n-\n-static void\n-rust_lex_test_completion (rust_parser *parser)\n-{\n-  const int expected[] = { IDENT, '.', COMPLETE, 0 };\n-\n-  parser->pstate->parse_completion = 1;\n-\n-  rust_lex_test_sequence (parser, \"something.wha\", ARRAY_SIZE (expected),\n-\t\t\t  expected);\n-  rust_lex_test_sequence (parser, \"something.\", ARRAY_SIZE (expected),\n-\t\t\t  expected);\n-\n-  parser->pstate->parse_completion = 0;\n-}\n-\n-/* Test pushback.  */\n-\n-static void\n-rust_lex_test_push_back (rust_parser *parser)\n-{\n-  int token;\n-  RUSTSTYPE lval;\n-\n-  rust_lex_test_init (parser, \">>=\");\n-\n-  token = rustyylex (&lval, parser);\n-  SELF_CHECK (token == COMPOUND_ASSIGN);\n-  SELF_CHECK (lval.opcode == BINOP_RSH);\n-\n-  parser->push_back ('=');\n-\n-  token = rustyylex (&lval, parser);\n-  SELF_CHECK (token == '=');\n-\n-  token = rustyylex (&lval, parser);\n-  SELF_CHECK (token == 0);\n-}\n-\n-/* Unit test the lexer.  */\n-\n-static void\n-rust_lex_tests (void)\n-{\n-  int i;\n-\n-  /* Set up dummy \"parser\", so that rust_type works.  */\n-  struct parser_state ps (language_def (language_rust), target_gdbarch (),\n-\t\t\t  nullptr, 0, 0, nullptr, 0, nullptr, false);\n-  rust_parser parser (&ps);\n-\n-  rust_lex_test_one (&parser, \"\", 0);\n-  rust_lex_test_one (&parser, \"    \\t  \\n \\r  \", 0);\n-  rust_lex_test_one (&parser, \"thread 23\", 0);\n-  rust_lex_test_one (&parser, \"task 23\", 0);\n-  rust_lex_test_one (&parser, \"th 104\", 0);\n-  rust_lex_test_one (&parser, \"ta 97\", 0);\n-\n-  rust_lex_int_test (&parser, \"'z'\", 'z', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\xff'\", 0xff, INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\u{1016f}'\", 0x1016f, INTEGER);\n-  rust_lex_int_test (&parser, \"b'z'\", 'z', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\xfe'\", 0xfe, INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\xFE'\", 0xfe, INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\xfE'\", 0xfe, INTEGER);\n-\n-  /* Test all escapes in both modes.  */\n-  rust_lex_int_test (&parser, \"'\\\\n'\", '\\n', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\r'\", '\\r', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\t'\", '\\t', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\\\\\'\", '\\\\', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\0'\", '\\0', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\''\", '\\'', INTEGER);\n-  rust_lex_int_test (&parser, \"'\\\\\\\"'\", '\"', INTEGER);\n-\n-  rust_lex_int_test (&parser, \"b'\\\\n'\", '\\n', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\r'\", '\\r', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\t'\", '\\t', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\\\\\'\", '\\\\', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\0'\", '\\0', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\''\", '\\'', INTEGER);\n-  rust_lex_int_test (&parser, \"b'\\\\\\\"'\", '\"', INTEGER);\n-\n-  rust_lex_exception_test (&parser, \"'z\", \"Unterminated character literal\");\n-  rust_lex_exception_test (&parser, \"b'\\\\x0'\", \"Not enough hex digits seen\");\n-  rust_lex_exception_test (&parser, \"b'\\\\u{0}'\",\n-\t\t\t   \"Unicode escape in byte literal\");\n-  rust_lex_exception_test (&parser, \"'\\\\x0'\", \"Not enough hex digits seen\");\n-  rust_lex_exception_test (&parser, \"'\\\\u0'\", \"Missing '{' in Unicode escape\");\n-  rust_lex_exception_test (&parser, \"'\\\\u{0\", \"Missing '}' in Unicode escape\");\n-  rust_lex_exception_test (&parser, \"'\\\\u{0000007}\", \"Overlong hex escape\");\n-  rust_lex_exception_test (&parser, \"'\\\\u{}\", \"Not enough hex digits seen\");\n-  rust_lex_exception_test (&parser, \"'\\\\Q'\", \"Invalid escape \\\\Q in literal\");\n-  rust_lex_exception_test (&parser, \"b'\\\\Q'\", \"Invalid escape \\\\Q in literal\");\n-\n-  rust_lex_int_test (&parser, \"23\", 23, DECIMAL_INTEGER);\n-  rust_lex_int_test (&parser, \"2_344__29\", 234429, INTEGER);\n-  rust_lex_int_test (&parser, \"0x1f\", 0x1f, INTEGER);\n-  rust_lex_int_test (&parser, \"23usize\", 23, INTEGER);\n-  rust_lex_int_test (&parser, \"23i32\", 23, INTEGER);\n-  rust_lex_int_test (&parser, \"0x1_f\", 0x1f, INTEGER);\n-  rust_lex_int_test (&parser, \"0b1_101011__\", 0x6b, INTEGER);\n-  rust_lex_int_test (&parser, \"0o001177i64\", 639, INTEGER);\n-  rust_lex_int_test (&parser, \"0x123456789u64\", 0x123456789ull, INTEGER);\n-\n-  rust_lex_test_trailing_dot (&parser);\n-\n-  rust_lex_test_one (&parser, \"23.\", FLOAT);\n-  rust_lex_test_one (&parser, \"23.99f32\", FLOAT);\n-  rust_lex_test_one (&parser, \"23e7\", FLOAT);\n-  rust_lex_test_one (&parser, \"23E-7\", FLOAT);\n-  rust_lex_test_one (&parser, \"23e+7\", FLOAT);\n-  rust_lex_test_one (&parser, \"23.99e+7f64\", FLOAT);\n-  rust_lex_test_one (&parser, \"23.82f32\", FLOAT);\n-\n-  rust_lex_stringish_test (&parser, \"hibob\", \"hibob\", IDENT);\n-  rust_lex_stringish_test (&parser, \"hibob__93\", \"hibob__93\", IDENT);\n-  rust_lex_stringish_test (&parser, \"thread\", \"thread\", IDENT);\n-\n-  rust_lex_stringish_test (&parser, \"\\\"string\\\"\", \"string\", STRING);\n-  rust_lex_stringish_test (&parser, \"\\\"str\\\\ting\\\"\", \"str\\ting\", STRING);\n-  rust_lex_stringish_test (&parser, \"\\\"str\\\\\\\"ing\\\"\", \"str\\\"ing\", STRING);\n-  rust_lex_stringish_test (&parser, \"r\\\"str\\\\ing\\\"\", \"str\\\\ing\", STRING);\n-  rust_lex_stringish_test (&parser, \"r#\\\"str\\\\ting\\\"#\", \"str\\\\ting\", STRING);\n-  rust_lex_stringish_test (&parser, \"r###\\\"str\\\\\\\"ing\\\"###\", \"str\\\\\\\"ing\",\n-\t\t\t   STRING);\n-\n-  rust_lex_stringish_test (&parser, \"b\\\"string\\\"\", \"string\", BYTESTRING);\n-  rust_lex_stringish_test (&parser, \"b\\\"\\x73tring\\\"\", \"string\", BYTESTRING);\n-  rust_lex_stringish_test (&parser, \"b\\\"str\\\\\\\"ing\\\"\", \"str\\\"ing\", BYTESTRING);\n-  rust_lex_stringish_test (&parser, \"br####\\\"\\\\x73tring\\\"####\", \"\\\\x73tring\",\n-\t\t\t   BYTESTRING);\n-\n-  for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n-    rust_lex_test_one (&parser, identifier_tokens[i].name,\n-\t\t       identifier_tokens[i].value);\n-\n-  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n-    rust_lex_test_one (&parser, operator_tokens[i].name,\n-\t\t       operator_tokens[i].value);\n-\n-  rust_lex_test_completion (&parser);\n-  rust_lex_test_push_back (&parser);\n-}\n-\n-#endif /* GDB_SELF_TEST */\n-\n-void _initialize_rust_exp ();\n-void\n-_initialize_rust_exp ()\n-{\n-  int code = regcomp (&number_regex, number_regex_text, REG_EXTENDED);\n-  /* If the regular expression was incorrect, it was a programming\n-     error.  */\n-  gdb_assert (code == 0);\n-\n-  using namespace expr;\n-  maker_map[BINOP_SUBSCRIPT] = make_operation<rust_subscript_operation>;\n-  maker_map[BINOP_MUL] = make_operation<mul_operation>;\n-  maker_map[BINOP_REPEAT] = make_operation<repeat_operation>;\n-  maker_map[BINOP_DIV] = make_operation<div_operation>;\n-  maker_map[BINOP_REM] = make_operation<rem_operation>;\n-  maker_map[BINOP_LESS] = make_operation<less_operation>;\n-  maker_map[BINOP_GTR] = make_operation<gtr_operation>;\n-  maker_map[BINOP_BITWISE_AND] = make_operation<bitwise_and_operation>;\n-  maker_map[BINOP_BITWISE_IOR] = make_operation<bitwise_ior_operation>;\n-  maker_map[BINOP_BITWISE_XOR] = make_operation<bitwise_xor_operation>;\n-  maker_map[BINOP_ADD] = make_operation<add_operation>;\n-  maker_map[BINOP_SUB] = make_operation<sub_operation>;\n-  maker_map[BINOP_LOGICAL_OR] = make_operation<logical_or_operation>;\n-  maker_map[BINOP_LOGICAL_AND] = make_operation<logical_and_operation>;\n-  maker_map[BINOP_EQUAL] = make_operation<equal_operation>;\n-  maker_map[BINOP_NOTEQUAL] = make_operation<notequal_operation>;\n-  maker_map[BINOP_LEQ] = make_operation<leq_operation>;\n-  maker_map[BINOP_GEQ] = make_operation<geq_operation>;\n-  maker_map[BINOP_LSH] = make_operation<lsh_operation>;\n-  maker_map[BINOP_RSH] = make_operation<rsh_operation>;\n-  maker_map[BINOP_ASSIGN] = make_operation<assign_operation>;\n-  maker_map[OP_RUST_ARRAY] = make_operation<rust_array_operation>;\n-\n-#if GDB_SELF_TEST\n-  selftests::register_test (\"rust-lex\", rust_lex_tests);\n-#endif\n-}"
    },
    {
      "sha": "bb31782811cf11ee679a334dc001ae20a71b229b",
      "filename": "gdb/rust-parse.c",
      "status": "added",
      "additions": 2351,
      "deletions": 0,
      "changes": 2351,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/rust-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/rust-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-parse.c?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -0,0 +1,2351 @@\n+/* Rust expression parsing for GDB, the GNU debugger.\n+\n+   Copyright (C) 2016-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+\n+#include \"block.h\"\n+#include \"charset.h\"\n+#include \"cp-support.h\"\n+#include \"gdb_obstack.h\"\n+#include \"gdb_regex.h\"\n+#include \"rust-lang.h\"\n+#include \"parser-defs.h\"\n+#include \"gdbsupport/selftest.h\"\n+#include \"value.h\"\n+#include \"gdbarch.h\"\n+#include \"rust-exp.h\"\n+\n+using namespace expr;\n+\n+/* A regular expression for matching Rust numbers.  This is split up\n+   since it is very long and this gives us a way to comment the\n+   sections.  */\n+\n+static const char number_regex_text[] =\n+  /* subexpression 1: allows use of alternation, otherwise uninteresting */\n+  \"^(\"\n+  /* First comes floating point.  */\n+  /* Recognize number after the decimal point, with optional\n+     exponent and optional type suffix.\n+     subexpression 2: allows \"?\", otherwise uninteresting\n+     subexpression 3: if present, type suffix\n+  */\n+  \"[0-9][0-9_]*\\\\.[0-9][0-9_]*([eE][-+]?[0-9][0-9_]*)?(f32|f64)?\"\n+#define FLOAT_TYPE1 3\n+  \"|\"\n+  /* Recognize exponent without decimal point, with optional type\n+     suffix.\n+     subexpression 4: if present, type suffix\n+  */\n+#define FLOAT_TYPE2 4\n+  \"[0-9][0-9_]*[eE][-+]?[0-9][0-9_]*(f32|f64)?\"\n+  \"|\"\n+  /* \"23.\" is a valid floating point number, but \"23.e5\" and\n+     \"23.f32\" are not.  So, handle the trailing-. case\n+     separately.  */\n+  \"[0-9][0-9_]*\\\\.\"\n+  \"|\"\n+  /* Finally come integers.\n+     subexpression 5: text of integer\n+     subexpression 6: if present, type suffix\n+     subexpression 7: allows use of alternation, otherwise uninteresting\n+  */\n+#define INT_TEXT 5\n+#define INT_TYPE 6\n+  \"(0x[a-fA-F0-9_]+|0o[0-7_]+|0b[01_]+|[0-9][0-9_]*)\"\n+  \"([iu](size|8|16|32|64))?\"\n+  \")\";\n+/* The number of subexpressions to allocate space for, including the\n+   \"0th\" whole match subexpression.  */\n+#define NUM_SUBEXPRESSIONS 8\n+\n+/* The compiled number-matching regex.  */\n+\n+static regex_t number_regex;\n+\n+/* The kinds of tokens.  Note that single-character tokens are\n+   represented by themselves, so for instance '[' is a token.  */\n+enum token_type : int\n+{\n+  /* Make sure to start after any ASCII character.  */\n+  GDBVAR = 256,\n+  IDENT,\n+  COMPLETE,\n+  INTEGER,\n+  DECIMAL_INTEGER,\n+  STRING,\n+  BYTESTRING,\n+  FLOAT,\n+  COMPOUND_ASSIGN,\n+\n+  /* Keyword tokens.  */\n+  KW_AS,\n+  KW_IF,\n+  KW_TRUE,\n+  KW_FALSE,\n+  KW_SUPER,\n+  KW_SELF,\n+  KW_MUT,\n+  KW_EXTERN,\n+  KW_CONST,\n+  KW_FN,\n+  KW_SIZEOF,\n+\n+  /* Operator tokens.  */\n+  DOTDOT,\n+  DOTDOTEQ,\n+  OROR,\n+  ANDAND,\n+  EQEQ,\n+  NOTEQ,\n+  LTEQ,\n+  GTEQ,\n+  LSH,\n+  RSH,\n+  COLONCOLON,\n+  ARROW,\n+};\n+\n+/* A typed integer constant.  */\n+\n+struct typed_val_int\n+{\n+  LONGEST val;\n+  struct type *type;\n+};\n+\n+/* A typed floating point constant.  */\n+\n+struct typed_val_float\n+{\n+  float_data val;\n+  struct type *type;\n+};\n+\n+/* A struct of this type is used to describe a token.  */\n+\n+struct token_info\n+{\n+  const char *name;\n+  int value;\n+  enum exp_opcode opcode;\n+};\n+\n+/* Identifier tokens.  */\n+\n+static const struct token_info identifier_tokens[] =\n+{\n+  { \"as\", KW_AS, OP_NULL },\n+  { \"false\", KW_FALSE, OP_NULL },\n+  { \"if\", 0, OP_NULL },\n+  { \"mut\", KW_MUT, OP_NULL },\n+  { \"const\", KW_CONST, OP_NULL },\n+  { \"self\", KW_SELF, OP_NULL },\n+  { \"super\", KW_SUPER, OP_NULL },\n+  { \"true\", KW_TRUE, OP_NULL },\n+  { \"extern\", KW_EXTERN, OP_NULL },\n+  { \"fn\", KW_FN, OP_NULL },\n+  { \"sizeof\", KW_SIZEOF, OP_NULL },\n+};\n+\n+/* Operator tokens, sorted longest first.  */\n+\n+static const struct token_info operator_tokens[] =\n+{\n+  { \">>=\", COMPOUND_ASSIGN, BINOP_RSH },\n+  { \"<<=\", COMPOUND_ASSIGN, BINOP_LSH },\n+\n+  { \"<<\", LSH, OP_NULL },\n+  { \">>\", RSH, OP_NULL },\n+  { \"&&\", ANDAND, OP_NULL },\n+  { \"||\", OROR, OP_NULL },\n+  { \"==\", EQEQ, OP_NULL },\n+  { \"!=\", NOTEQ, OP_NULL },\n+  { \"<=\", LTEQ, OP_NULL },\n+  { \">=\", GTEQ, OP_NULL },\n+  { \"+=\", COMPOUND_ASSIGN, BINOP_ADD },\n+  { \"-=\", COMPOUND_ASSIGN, BINOP_SUB },\n+  { \"*=\", COMPOUND_ASSIGN, BINOP_MUL },\n+  { \"/=\", COMPOUND_ASSIGN, BINOP_DIV },\n+  { \"%=\", COMPOUND_ASSIGN, BINOP_REM },\n+  { \"&=\", COMPOUND_ASSIGN, BINOP_BITWISE_AND },\n+  { \"|=\", COMPOUND_ASSIGN, BINOP_BITWISE_IOR },\n+  { \"^=\", COMPOUND_ASSIGN, BINOP_BITWISE_XOR },\n+  { \"..=\", DOTDOTEQ, OP_NULL },\n+\n+  { \"::\", COLONCOLON, OP_NULL },\n+  { \"..\", DOTDOT, OP_NULL },\n+  { \"->\", ARROW, OP_NULL }\n+};\n+\n+/* An instance of this is created before parsing, and destroyed when\n+   parsing is finished.  */\n+\n+struct rust_parser\n+{\n+  explicit rust_parser (struct parser_state *state)\n+    : pstate (state)\n+  {\n+  }\n+\n+  DISABLE_COPY_AND_ASSIGN (rust_parser);\n+\n+  /* Return the parser's language.  */\n+  const struct language_defn *language () const\n+  {\n+    return pstate->language ();\n+  }\n+\n+  /* Return the parser's gdbarch.  */\n+  struct gdbarch *arch () const\n+  {\n+    return pstate->gdbarch ();\n+  }\n+\n+  /* A helper to look up a Rust type, or fail.  This only works for\n+     types defined by rust_language_arch_info.  */\n+\n+  struct type *get_type (const char *name)\n+  {\n+    struct type *type;\n+\n+    type = language_lookup_primitive_type (language (), arch (), name);\n+    if (type == NULL)\n+      error (_(\"Could not find Rust type %s\"), name);\n+    return type;\n+  }\n+\n+  std::string crate_name (const std::string &name);\n+  std::string super_name (const std::string &ident, unsigned int n_supers);\n+\n+  int lex_character ();\n+  int lex_number ();\n+  int lex_string ();\n+  int lex_identifier ();\n+  uint32_t lex_hex (int min, int max);\n+  uint32_t lex_escape (int is_byte);\n+  int lex_operator ();\n+  int lex_one_token ();\n+  void push_back (char c);\n+\n+  /* The main interface to lexing.  Lexes one token and updates the\n+     internal state.  */\n+  void lex ()\n+  {\n+    current_token = lex_one_token ();\n+  }\n+\n+  /* Assuming the current token is TYPE, lex the next token.  */\n+  void assume (int type)\n+  {\n+    gdb_assert (current_token == type);\n+    lex ();\n+  }\n+\n+  /* Require the single-character token C, and lex the next token; or\n+     throw an exception.  */\n+  void require (char type)\n+  {\n+    if (current_token != type)\n+      error (_(\"'%c' expected\"), type);\n+    lex ();\n+  }\n+\n+  /* Entry point for all parsing.  */\n+  operation_up parse_entry_point ()\n+  {\n+    lex ();\n+    return parse_expr ();\n+  }\n+\n+  operation_up parse_tuple ();\n+  operation_up parse_array ();\n+  operation_up name_to_operation (const std::string &name);\n+  operation_up parse_struct_expr (struct type *type);\n+  operation_up parse_binop (bool required);\n+  operation_up parse_range ();\n+  operation_up parse_expr ();\n+  operation_up parse_sizeof ();\n+  operation_up parse_addr ();\n+  operation_up parse_field (operation_up &&);\n+  operation_up parse_index (operation_up &&);\n+  std::vector<operation_up> parse_paren_args ();\n+  operation_up parse_call (operation_up &&);\n+  std::vector<struct type *> parse_type_list ();\n+  std::vector<struct type *> parse_maybe_type_list ();\n+  struct type *parse_array_type ();\n+  struct type *parse_slice_type ();\n+  struct type *parse_pointer_type ();\n+  struct type *parse_function_type ();\n+  struct type *parse_tuple_type ();\n+  struct type *parse_type ();\n+  std::string parse_path (bool for_expr);\n+  operation_up parse_string ();\n+  operation_up parse_tuple_struct (struct type *type);\n+  operation_up parse_path_expr ();\n+  operation_up parse_atom (bool required);\n+\n+  void update_innermost_block (struct block_symbol sym);\n+  struct block_symbol lookup_symbol (const char *name,\n+\t\t\t\t     const struct block *block,\n+\t\t\t\t     const domain_enum domain);\n+  struct type *rust_lookup_type (const char *name);\n+\n+  /* Clear some state.  This is only used for testing.  */\n+#if GDB_SELF_TEST\n+  void reset (const char *input)\n+  {\n+    pstate->prev_lexptr = nullptr;\n+    pstate->lexptr = input;\n+    paren_depth = 0;\n+    current_token = 0;\n+    current_int_val = {};\n+    current_float_val = {};\n+    current_string_val = {};\n+    current_opcode = OP_NULL;\n+  }\n+#endif /* GDB_SELF_TEST */\n+\n+  /* Return the token's string value as a string.  */\n+  std::string get_string () const\n+  {\n+    return std::string (current_string_val.ptr, current_string_val.length);\n+  }\n+\n+  /* A pointer to this is installed globally.  */\n+  auto_obstack obstack;\n+\n+  /* The parser state gdb gave us.  */\n+  struct parser_state *pstate;\n+\n+  /* Depth of parentheses.  */\n+  int paren_depth = 0;\n+\n+  /* The current token's type.  */\n+  int current_token = 0;\n+  /* The current token's payload, if any.  */\n+  typed_val_int current_int_val {};\n+  typed_val_float current_float_val {};\n+  struct stoken current_string_val {};\n+  enum exp_opcode current_opcode = OP_NULL;\n+\n+  /* When completing, this may be set to the field operation to\n+     complete.  */\n+  operation_up completion_op;\n+};\n+\n+/* Return an string referring to NAME, but relative to the crate's\n+   name.  */\n+\n+std::string\n+rust_parser::crate_name (const std::string &name)\n+{\n+  std::string crate = rust_crate_for_block (pstate->expression_context_block);\n+\n+  if (crate.empty ())\n+    error (_(\"Could not find crate for current location\"));\n+  return \"::\" + crate + \"::\" + name;\n+}\n+\n+/* Return a string referring to a \"super::\" qualified name.  IDENT is\n+   the base name and N_SUPERS is how many \"super::\"s were provided.\n+   N_SUPERS can be zero.  */\n+\n+std::string\n+rust_parser::super_name (const std::string &ident, unsigned int n_supers)\n+{\n+  const char *scope = block_scope (pstate->expression_context_block);\n+  int offset;\n+\n+  if (scope[0] == '\\0')\n+    error (_(\"Couldn't find namespace scope for self::\"));\n+\n+  if (n_supers > 0)\n+    {\n+      int len;\n+      std::vector<int> offsets;\n+      unsigned int current_len;\n+\n+      current_len = cp_find_first_component (scope);\n+      while (scope[current_len] != '\\0')\n+\t{\n+\t  offsets.push_back (current_len);\n+\t  gdb_assert (scope[current_len] == ':');\n+\t  /* The \"::\".  */\n+\t  current_len += 2;\n+\t  current_len += cp_find_first_component (scope\n+\t\t\t\t\t\t  + current_len);\n+\t}\n+\n+      len = offsets.size ();\n+      if (n_supers >= len)\n+\terror (_(\"Too many super:: uses from '%s'\"), scope);\n+\n+      offset = offsets[len - n_supers];\n+    }\n+  else\n+    offset = strlen (scope);\n+\n+  return \"::\" + std::string (scope, offset) + \"::\" + ident;\n+}\n+\n+/* A helper to appropriately munge NAME and BLOCK depending on the\n+   presence of a leading \"::\".  */\n+\n+static void\n+munge_name_and_block (const char **name, const struct block **block)\n+{\n+  /* If it is a global reference, skip the current block in favor of\n+     the static block.  */\n+  if (startswith (*name, \"::\"))\n+    {\n+      *name += 2;\n+      *block = block_static_block (*block);\n+    }\n+}\n+\n+/* Like lookup_symbol, but handles Rust namespace conventions, and\n+   doesn't require field_of_this_result.  */\n+\n+struct block_symbol\n+rust_parser::lookup_symbol (const char *name, const struct block *block,\n+\t\t\t    const domain_enum domain)\n+{\n+  struct block_symbol result;\n+\n+  munge_name_and_block (&name, &block);\n+\n+  result = ::lookup_symbol (name, block, domain, NULL);\n+  if (result.symbol != NULL)\n+    update_innermost_block (result);\n+  return result;\n+}\n+\n+/* Look up a type, following Rust namespace conventions.  */\n+\n+struct type *\n+rust_parser::rust_lookup_type (const char *name)\n+{\n+  struct block_symbol result;\n+  struct type *type;\n+\n+  const struct block *block = pstate->expression_context_block;\n+  munge_name_and_block (&name, &block);\n+\n+  result = ::lookup_symbol (name, block, STRUCT_DOMAIN, NULL);\n+  if (result.symbol != NULL)\n+    {\n+      update_innermost_block (result);\n+      return SYMBOL_TYPE (result.symbol);\n+    }\n+\n+  type = lookup_typename (language (), name, NULL, 1);\n+  if (type != NULL)\n+    return type;\n+\n+  /* Last chance, try a built-in type.  */\n+  return language_lookup_primitive_type (language (), arch (), name);\n+}\n+\n+/* A helper that updates the innermost block as appropriate.  */\n+\n+void\n+rust_parser::update_innermost_block (struct block_symbol sym)\n+{\n+  if (symbol_read_needs_frame (sym.symbol))\n+    pstate->block_tracker->update (sym);\n+}\n+\n+/* Lex a hex number with at least MIN digits and at most MAX\n+   digits.  */\n+\n+uint32_t\n+rust_parser::lex_hex (int min, int max)\n+{\n+  uint32_t result = 0;\n+  int len = 0;\n+  /* We only want to stop at MAX if we're lexing a byte escape.  */\n+  int check_max = min == max;\n+\n+  while ((check_max ? len <= max : 1)\n+\t && ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n+\t     || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n+\t     || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')))\n+    {\n+      result *= 16;\n+      if (pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'f')\n+\tresult = result + 10 + pstate->lexptr[0] - 'a';\n+      else if (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'F')\n+\tresult = result + 10 + pstate->lexptr[0] - 'A';\n+      else\n+\tresult = result + pstate->lexptr[0] - '0';\n+      ++pstate->lexptr;\n+      ++len;\n+    }\n+\n+  if (len < min)\n+    error (_(\"Not enough hex digits seen\"));\n+  if (len > max)\n+    {\n+      gdb_assert (min != max);\n+      error (_(\"Overlong hex escape\"));\n+    }\n+\n+  return result;\n+}\n+\n+/* Lex an escape.  IS_BYTE is true if we're lexing a byte escape;\n+   otherwise we're lexing a character escape.  */\n+\n+uint32_t\n+rust_parser::lex_escape (int is_byte)\n+{\n+  uint32_t result;\n+\n+  gdb_assert (pstate->lexptr[0] == '\\\\');\n+  ++pstate->lexptr;\n+  switch (pstate->lexptr[0])\n+    {\n+    case 'x':\n+      ++pstate->lexptr;\n+      result = lex_hex (2, 2);\n+      break;\n+\n+    case 'u':\n+      if (is_byte)\n+\terror (_(\"Unicode escape in byte literal\"));\n+      ++pstate->lexptr;\n+      if (pstate->lexptr[0] != '{')\n+\terror (_(\"Missing '{' in Unicode escape\"));\n+      ++pstate->lexptr;\n+      result = lex_hex (1, 6);\n+      /* Could do range checks here.  */\n+      if (pstate->lexptr[0] != '}')\n+\terror (_(\"Missing '}' in Unicode escape\"));\n+      ++pstate->lexptr;\n+      break;\n+\n+    case 'n':\n+      result = '\\n';\n+      ++pstate->lexptr;\n+      break;\n+    case 'r':\n+      result = '\\r';\n+      ++pstate->lexptr;\n+      break;\n+    case 't':\n+      result = '\\t';\n+      ++pstate->lexptr;\n+      break;\n+    case '\\\\':\n+      result = '\\\\';\n+      ++pstate->lexptr;\n+      break;\n+    case '0':\n+      result = '\\0';\n+      ++pstate->lexptr;\n+      break;\n+    case '\\'':\n+      result = '\\'';\n+      ++pstate->lexptr;\n+      break;\n+    case '\"':\n+      result = '\"';\n+      ++pstate->lexptr;\n+      break;\n+\n+    default:\n+      error (_(\"Invalid escape \\\\%c in literal\"), pstate->lexptr[0]);\n+    }\n+\n+  return result;\n+}\n+\n+/* Lex a character constant.  */\n+\n+int\n+rust_parser::lex_character ()\n+{\n+  int is_byte = 0;\n+  uint32_t value;\n+\n+  if (pstate->lexptr[0] == 'b')\n+    {\n+      is_byte = 1;\n+      ++pstate->lexptr;\n+    }\n+  gdb_assert (pstate->lexptr[0] == '\\'');\n+  ++pstate->lexptr;\n+  /* This should handle UTF-8 here.  */\n+  if (pstate->lexptr[0] == '\\\\')\n+    value = lex_escape (is_byte);\n+  else\n+    {\n+      value = pstate->lexptr[0] & 0xff;\n+      ++pstate->lexptr;\n+    }\n+\n+  if (pstate->lexptr[0] != '\\'')\n+    error (_(\"Unterminated character literal\"));\n+  ++pstate->lexptr;\n+\n+  current_int_val.val = value;\n+  current_int_val.type = get_type (is_byte ? \"u8\" : \"char\");\n+\n+  return INTEGER;\n+}\n+\n+/* Return the offset of the double quote if STR looks like the start\n+   of a raw string, or 0 if STR does not start a raw string.  */\n+\n+static int\n+starts_raw_string (const char *str)\n+{\n+  const char *save = str;\n+\n+  if (str[0] != 'r')\n+    return 0;\n+  ++str;\n+  while (str[0] == '#')\n+    ++str;\n+  if (str[0] == '\"')\n+    return str - save;\n+  return 0;\n+}\n+\n+/* Return true if STR looks like the end of a raw string that had N\n+   hashes at the start.  */\n+\n+static bool\n+ends_raw_string (const char *str, int n)\n+{\n+  int i;\n+\n+  gdb_assert (str[0] == '\"');\n+  for (i = 0; i < n; ++i)\n+    if (str[i + 1] != '#')\n+      return false;\n+  return true;\n+}\n+\n+/* Lex a string constant.  */\n+\n+int\n+rust_parser::lex_string ()\n+{\n+  int is_byte = pstate->lexptr[0] == 'b';\n+  int raw_length;\n+\n+  if (is_byte)\n+    ++pstate->lexptr;\n+  raw_length = starts_raw_string (pstate->lexptr);\n+  pstate->lexptr += raw_length;\n+  gdb_assert (pstate->lexptr[0] == '\"');\n+  ++pstate->lexptr;\n+\n+  while (1)\n+    {\n+      uint32_t value;\n+\n+      if (raw_length > 0)\n+\t{\n+\t  if (pstate->lexptr[0] == '\"' && ends_raw_string (pstate->lexptr,\n+\t\t\t\t\t\t\t   raw_length - 1))\n+\t    {\n+\t      /* Exit with lexptr pointing after the final \"#\".  */\n+\t      pstate->lexptr += raw_length;\n+\t      break;\n+\t    }\n+\t  else if (pstate->lexptr[0] == '\\0')\n+\t    error (_(\"Unexpected EOF in string\"));\n+\n+\t  value = pstate->lexptr[0] & 0xff;\n+\t  if (is_byte && value > 127)\n+\t    error (_(\"Non-ASCII value in raw byte string\"));\n+\t  obstack_1grow (&obstack, value);\n+\n+\t  ++pstate->lexptr;\n+\t}\n+      else if (pstate->lexptr[0] == '\"')\n+\t{\n+\t  /* Make sure to skip the quote.  */\n+\t  ++pstate->lexptr;\n+\t  break;\n+\t}\n+      else if (pstate->lexptr[0] == '\\\\')\n+\t{\n+\t  value = lex_escape (is_byte);\n+\n+\t  if (is_byte)\n+\t    obstack_1grow (&obstack, value);\n+\t  else\n+\t    convert_between_encodings (\"UTF-32\", \"UTF-8\", (gdb_byte *) &value,\n+\t\t\t\t       sizeof (value), sizeof (value),\n+\t\t\t\t       &obstack, translit_none);\n+\t}\n+      else if (pstate->lexptr[0] == '\\0')\n+\terror (_(\"Unexpected EOF in string\"));\n+      else\n+\t{\n+\t  value = pstate->lexptr[0] & 0xff;\n+\t  if (is_byte && value > 127)\n+\t    error (_(\"Non-ASCII value in byte string\"));\n+\t  obstack_1grow (&obstack, value);\n+\t  ++pstate->lexptr;\n+\t}\n+    }\n+\n+  current_string_val.length = obstack_object_size (&obstack);\n+  current_string_val.ptr = (const char *) obstack_finish (&obstack);\n+  return is_byte ? BYTESTRING : STRING;\n+}\n+\n+/* Return true if STRING starts with whitespace followed by a digit.  */\n+\n+static bool\n+space_then_number (const char *string)\n+{\n+  const char *p = string;\n+\n+  while (p[0] == ' ' || p[0] == '\\t')\n+    ++p;\n+  if (p == string)\n+    return false;\n+\n+  return *p >= '0' && *p <= '9';\n+}\n+\n+/* Return true if C can start an identifier.  */\n+\n+static bool\n+rust_identifier_start_p (char c)\n+{\n+  return ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || c == '_'\n+\t  || c == '$');\n+}\n+\n+/* Lex an identifier.  */\n+\n+int\n+rust_parser::lex_identifier ()\n+{\n+  const char *start = pstate->lexptr;\n+  unsigned int length;\n+  const struct token_info *token;\n+  int i;\n+  int is_gdb_var = pstate->lexptr[0] == '$';\n+\n+  gdb_assert (rust_identifier_start_p (pstate->lexptr[0]));\n+\n+  ++pstate->lexptr;\n+\n+  /* For the time being this doesn't handle Unicode rules.  Non-ASCII\n+     identifiers are gated anyway.  */\n+  while ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'z')\n+\t || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'Z')\n+\t || pstate->lexptr[0] == '_'\n+\t || (is_gdb_var && pstate->lexptr[0] == '$')\n+\t || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9'))\n+    ++pstate->lexptr;\n+\n+\n+  length = pstate->lexptr - start;\n+  token = NULL;\n+  for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n+    {\n+      if (length == strlen (identifier_tokens[i].name)\n+\t  && strncmp (identifier_tokens[i].name, start, length) == 0)\n+\t{\n+\t  token = &identifier_tokens[i];\n+\t  break;\n+\t}\n+    }\n+\n+  if (token != NULL)\n+    {\n+      if (token->value == 0)\n+\t{\n+\t  /* Leave the terminating token alone.  */\n+\t  pstate->lexptr = start;\n+\t  return 0;\n+\t}\n+    }\n+  else if (token == NULL\n+\t   && (strncmp (start, \"thread\", length) == 0\n+\t       || strncmp (start, \"task\", length) == 0)\n+\t   && space_then_number (pstate->lexptr))\n+    {\n+      /* \"task\" or \"thread\" followed by a number terminates the\n+\t parse, per gdb rules.  */\n+      pstate->lexptr = start;\n+      return 0;\n+    }\n+\n+  if (token == NULL || (pstate->parse_completion && pstate->lexptr[0] == '\\0'))\n+    {\n+      current_string_val.length = length;\n+      current_string_val.ptr = start;\n+    }\n+\n+  if (pstate->parse_completion && pstate->lexptr[0] == '\\0')\n+    {\n+      /* Prevent rustyylex from returning two COMPLETE tokens.  */\n+      pstate->prev_lexptr = pstate->lexptr;\n+      return COMPLETE;\n+    }\n+\n+  if (token != NULL)\n+    return token->value;\n+  if (is_gdb_var)\n+    return GDBVAR;\n+  return IDENT;\n+}\n+\n+/* Lex an operator.  */\n+\n+int\n+rust_parser::lex_operator ()\n+{\n+  const struct token_info *token = NULL;\n+  int i;\n+\n+  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n+    {\n+      if (strncmp (operator_tokens[i].name, pstate->lexptr,\n+\t\t   strlen (operator_tokens[i].name)) == 0)\n+\t{\n+\t  pstate->lexptr += strlen (operator_tokens[i].name);\n+\t  token = &operator_tokens[i];\n+\t  break;\n+\t}\n+    }\n+\n+  if (token != NULL)\n+    {\n+      current_opcode = token->opcode;\n+      return token->value;\n+    }\n+\n+  return *pstate->lexptr++;\n+}\n+\n+/* Lex a number.  */\n+\n+int\n+rust_parser::lex_number ()\n+{\n+  regmatch_t subexps[NUM_SUBEXPRESSIONS];\n+  int match;\n+  int is_integer = 0;\n+  int could_be_decimal = 1;\n+  int implicit_i32 = 0;\n+  const char *type_name = NULL;\n+  struct type *type;\n+  int end_index;\n+  int type_index = -1;\n+  int i;\n+\n+  match = regexec (&number_regex, pstate->lexptr, ARRAY_SIZE (subexps),\n+\t\t   subexps, 0);\n+  /* Failure means the regexp is broken.  */\n+  gdb_assert (match == 0);\n+\n+  if (subexps[INT_TEXT].rm_so != -1)\n+    {\n+      /* Integer part matched.  */\n+      is_integer = 1;\n+      end_index = subexps[INT_TEXT].rm_eo;\n+      if (subexps[INT_TYPE].rm_so == -1)\n+\t{\n+\t  type_name = \"i32\";\n+\t  implicit_i32 = 1;\n+\t}\n+      else\n+\t{\n+\t  type_index = INT_TYPE;\n+\t  could_be_decimal = 0;\n+\t}\n+    }\n+  else if (subexps[FLOAT_TYPE1].rm_so != -1)\n+    {\n+      /* Found floating point type suffix.  */\n+      end_index = subexps[FLOAT_TYPE1].rm_so;\n+      type_index = FLOAT_TYPE1;\n+    }\n+  else if (subexps[FLOAT_TYPE2].rm_so != -1)\n+    {\n+      /* Found floating point type suffix.  */\n+      end_index = subexps[FLOAT_TYPE2].rm_so;\n+      type_index = FLOAT_TYPE2;\n+    }\n+  else\n+    {\n+      /* Any other floating point match.  */\n+      end_index = subexps[0].rm_eo;\n+      type_name = \"f64\";\n+    }\n+\n+  /* We need a special case if the final character is \".\".  In this\n+     case we might need to parse an integer.  For example, \"23.f()\" is\n+     a request for a trait method call, not a syntax error involving\n+     the floating point number \"23.\".  */\n+  gdb_assert (subexps[0].rm_eo > 0);\n+  if (pstate->lexptr[subexps[0].rm_eo - 1] == '.')\n+    {\n+      const char *next = skip_spaces (&pstate->lexptr[subexps[0].rm_eo]);\n+\n+      if (rust_identifier_start_p (*next) || *next == '.')\n+\t{\n+\t  --subexps[0].rm_eo;\n+\t  is_integer = 1;\n+\t  end_index = subexps[0].rm_eo;\n+\t  type_name = \"i32\";\n+\t  could_be_decimal = 1;\n+\t  implicit_i32 = 1;\n+\t}\n+    }\n+\n+  /* Compute the type name if we haven't already.  */\n+  std::string type_name_holder;\n+  if (type_name == NULL)\n+    {\n+      gdb_assert (type_index != -1);\n+      type_name_holder = std::string ((pstate->lexptr\n+\t\t\t\t       + subexps[type_index].rm_so),\n+\t\t\t\t      (subexps[type_index].rm_eo\n+\t\t\t\t       - subexps[type_index].rm_so));\n+      type_name = type_name_holder.c_str ();\n+    }\n+\n+  /* Look up the type.  */\n+  type = get_type (type_name);\n+\n+  /* Copy the text of the number and remove the \"_\"s.  */\n+  std::string number;\n+  for (i = 0; i < end_index && pstate->lexptr[i]; ++i)\n+    {\n+      if (pstate->lexptr[i] == '_')\n+\tcould_be_decimal = 0;\n+      else\n+\tnumber.push_back (pstate->lexptr[i]);\n+    }\n+\n+  /* Advance past the match.  */\n+  pstate->lexptr += subexps[0].rm_eo;\n+\n+  /* Parse the number.  */\n+  if (is_integer)\n+    {\n+      uint64_t value;\n+      int radix = 10;\n+      int offset = 0;\n+\n+      if (number[0] == '0')\n+\t{\n+\t  if (number[1] == 'x')\n+\t    radix = 16;\n+\t  else if (number[1] == 'o')\n+\t    radix = 8;\n+\t  else if (number[1] == 'b')\n+\t    radix = 2;\n+\t  if (radix != 10)\n+\t    {\n+\t      offset = 2;\n+\t      could_be_decimal = 0;\n+\t    }\n+\t}\n+\n+      value = strtoulst (number.c_str () + offset, NULL, radix);\n+      if (implicit_i32 && value >= ((uint64_t) 1) << 31)\n+\ttype = get_type (\"i64\");\n+\n+      current_int_val.val = value;\n+      current_int_val.type = type;\n+    }\n+  else\n+    {\n+      current_float_val.type = type;\n+      bool parsed = parse_float (number.c_str (), number.length (),\n+\t\t\t\t current_float_val.type,\n+\t\t\t\t current_float_val.val.data ());\n+      gdb_assert (parsed);\n+    }\n+\n+  return is_integer ? (could_be_decimal ? DECIMAL_INTEGER : INTEGER) : FLOAT;\n+}\n+\n+/* The lexer.  */\n+\n+int\n+rust_parser::lex_one_token ()\n+{\n+  /* Skip all leading whitespace.  */\n+  while (pstate->lexptr[0] == ' '\n+\t || pstate->lexptr[0] == '\\t'\n+\t || pstate->lexptr[0] == '\\r'\n+\t || pstate->lexptr[0] == '\\n')\n+    ++pstate->lexptr;\n+\n+  /* If we hit EOF and we're completing, then return COMPLETE -- maybe\n+     we're completing an empty string at the end of a field_expr.\n+     But, we don't want to return two COMPLETE tokens in a row.  */\n+  if (pstate->lexptr[0] == '\\0' && pstate->lexptr == pstate->prev_lexptr)\n+    return 0;\n+  pstate->prev_lexptr = pstate->lexptr;\n+  if (pstate->lexptr[0] == '\\0')\n+    {\n+      if (pstate->parse_completion)\n+\t{\n+\t  current_string_val.length =0;\n+\t  current_string_val.ptr = \"\";\n+\t  return COMPLETE;\n+\t}\n+      return 0;\n+    }\n+\n+  if (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')\n+    return lex_number ();\n+  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\\'')\n+    return lex_character ();\n+  else if (pstate->lexptr[0] == 'b' && pstate->lexptr[1] == '\"')\n+    return lex_string ();\n+  else if (pstate->lexptr[0] == 'b' && starts_raw_string (pstate->lexptr + 1))\n+    return lex_string ();\n+  else if (starts_raw_string (pstate->lexptr))\n+    return lex_string ();\n+  else if (rust_identifier_start_p (pstate->lexptr[0]))\n+    return lex_identifier ();\n+  else if (pstate->lexptr[0] == '\"')\n+    return lex_string ();\n+  else if (pstate->lexptr[0] == '\\'')\n+    return lex_character ();\n+  else if (pstate->lexptr[0] == '}' || pstate->lexptr[0] == ']')\n+    {\n+      /* Falls through to lex_operator.  */\n+      --paren_depth;\n+    }\n+  else if (pstate->lexptr[0] == '(' || pstate->lexptr[0] == '{')\n+    {\n+      /* Falls through to lex_operator.  */\n+      ++paren_depth;\n+    }\n+  else if (pstate->lexptr[0] == ',' && pstate->comma_terminates\n+\t   && paren_depth == 0)\n+    return 0;\n+\n+  return lex_operator ();\n+}\n+\n+/* Push back a single character to be re-lexed.  */\n+\n+void\n+rust_parser::push_back (char c)\n+{\n+  /* Can't be called before any lexing.  */\n+  gdb_assert (pstate->prev_lexptr != NULL);\n+\n+  --pstate->lexptr;\n+  gdb_assert (*pstate->lexptr == c);\n+}\n+\n+\f\n+\n+/* Parse a tuple or paren expression.  */\n+\n+operation_up\n+rust_parser::parse_tuple ()\n+{\n+  assume ('(');\n+\n+  if (current_token == ')')\n+    {\n+      lex ();\n+      struct type *unit = get_type (\"()\");\n+      return make_operation<long_const_operation> (unit, 0);\n+    }\n+\n+  operation_up expr = parse_expr ();\n+  if (current_token == ')')\n+    {\n+      /* Parenthesized expression.  */\n+      lex ();\n+      return expr;\n+    }\n+\n+  std::vector<operation_up> ops;\n+  ops.push_back (std::move (expr));\n+  while (current_token != ')')\n+    {\n+      if (current_token != ',')\n+\terror (_(\"',' or ')' expected\"));\n+      lex ();\n+\n+      /* A trailing \",\" is ok.  */\n+      if (current_token != ')')\n+\tops.push_back (parse_expr ());\n+    }\n+\n+  assume (')');\n+\n+  error (_(\"Tuple expressions not supported yet\"));\n+}\n+\n+/* Parse an array expression.  */\n+\n+operation_up\n+rust_parser::parse_array ()\n+{\n+  assume ('[');\n+\n+  if (current_token == KW_MUT)\n+    lex ();\n+\n+  operation_up result;\n+  operation_up expr = parse_expr ();\n+  if (current_token == ';')\n+    {\n+      lex ();\n+      operation_up rhs = parse_expr ();\n+      result = make_operation<rust_array_operation> (std::move (expr),\n+\t\t\t\t\t\t     std::move (rhs));\n+    }\n+  else if (current_token == ',')\n+    {\n+      std::vector<operation_up> ops;\n+      ops.push_back (std::move (expr));\n+      while (current_token != ']')\n+\t{\n+\t  if (current_token != ',')\n+\t    error (_(\"',' or ']' expected\"));\n+\t  lex ();\n+\t  ops.push_back (parse_expr ());\n+\t}\n+      ops.shrink_to_fit ();\n+      int len = ops.size () - 1;\n+      result = make_operation<array_operation> (0, len, std::move (ops));\n+    }\n+  else if (current_token != ']')\n+    error (_(\"',', ';', or ']' expected\"));\n+\n+  require (']');\n+\n+  return result;\n+}\n+\n+/* Turn a name into an operation.  */\n+\n+operation_up\n+rust_parser::name_to_operation (const std::string &name)\n+{\n+  struct block_symbol sym = lookup_symbol (name.c_str (),\n+\t\t\t\t\t   pstate->expression_context_block,\n+\t\t\t\t\t   VAR_DOMAIN);\n+  if (sym.symbol != nullptr && SYMBOL_CLASS (sym.symbol) != LOC_TYPEDEF)\n+    return make_operation<var_value_operation> (sym);\n+\n+  struct type *type = nullptr;\n+\n+  if (sym.symbol != nullptr)\n+    {\n+      gdb_assert (SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF);\n+      type = SYMBOL_TYPE (sym.symbol);\n+    }\n+  if (type == nullptr)\n+    type = rust_lookup_type (name.c_str ());\n+  if (type == nullptr)\n+    error (_(\"No symbol '%s' in current context\"), name.c_str ());\n+\n+  if (type->code () == TYPE_CODE_STRUCT && type->num_fields () == 0)\n+    {\n+      /* A unit-like struct.  */\n+      operation_up result (new rust_aggregate_operation (type, {}, {}));\n+      return result;\n+    }\n+  else\n+    return make_operation<type_operation> (type);\n+}\n+\n+/* Parse a struct expression.  */\n+\n+operation_up\n+rust_parser::parse_struct_expr (struct type *type)\n+{\n+  assume ('{');\n+\n+  if (type->code () != TYPE_CODE_STRUCT\n+      || rust_tuple_type_p (type)\n+      || rust_tuple_struct_type_p (type))\n+    error (_(\"Struct expression applied to non-struct type\"));\n+\n+  std::vector<std::pair<std::string, operation_up>> field_v;\n+  while (current_token != '}' && current_token != DOTDOT)\n+    {\n+      if (current_token != IDENT)\n+\terror (_(\"'}', '..', or identifier expected\"));\n+\n+      std::string name = get_string ();\n+      lex ();\n+\n+      operation_up expr;\n+      if (current_token == ',' || current_token == '}'\n+\t  || current_token == DOTDOT)\n+\texpr = name_to_operation (name);\n+      else\n+\t{\n+\t  require (':');\n+\t  expr = parse_expr ();\n+\t}\n+      field_v.emplace_back (std::move (name), std::move (expr));\n+\n+      /* A trailing \",\" is ok.  */\n+      if (current_token == ',')\n+\tlex ();\n+    }\n+\n+  operation_up others;\n+  if (current_token == DOTDOT)\n+    {\n+      lex ();\n+      others = parse_expr ();\n+    }\n+\n+  require ('}');\n+\n+  return make_operation<rust_aggregate_operation> (type,\n+\t\t\t\t\t\t   std::move (others),\n+\t\t\t\t\t\t   std::move (field_v));\n+}\n+\n+/* Used by the operator precedence parser.  */\n+struct rustop_item\n+{\n+  rustop_item (int token_, int precedence_, enum exp_opcode opcode_,\n+\t       operation_up &&op_)\n+    : token (token_),\n+      precedence (precedence_),\n+      opcode (opcode_),\n+      op (std::move (op_))\n+  {\n+  }\n+\n+  /* The token value.  */\n+  int token;\n+  /* Precedence of this operator.  */\n+  int precedence;\n+  /* This is used only for assign-modify.  */\n+  enum exp_opcode opcode;\n+  /* The right hand side of this operation.  */\n+  operation_up op;\n+};\n+\n+/* An operator precedence parser for binary operations, including\n+   \"as\".  */\n+\n+operation_up\n+rust_parser::parse_binop (bool required)\n+{\n+  /* All the binary  operators.  Each one is of the form\n+     OPERATION(TOKEN, PRECEDENCE, TYPE)\n+     TOKEN is the corresponding operator token.\n+     PRECEDENCE is a value indicating relative precedence.\n+     TYPE is the operation type corresponding to the operator.\n+     Assignment operations are handled specially, not via this\n+     table; they have precedence 0.  */\n+#define ALL_OPS\t\t\t\t\t\\\n+  OPERATION ('*', 10, mul_operation)\t\t\\\n+  OPERATION ('/', 10, div_operation)\t\t\\\n+  OPERATION ('%', 10, rem_operation)\t\t\\\n+  OPERATION ('@', 9, repeat_operation)\t\t\\\n+  OPERATION ('+', 8, add_operation)\t\t\\\n+  OPERATION ('-', 8, sub_operation)\t\t\\\n+  OPERATION (LSH, 7, lsh_operation)\t\t\\\n+  OPERATION (RSH, 7, rsh_operation)\t\t\\\n+  OPERATION ('&', 6, bitwise_and_operation)\t\\\n+  OPERATION ('^', 5, bitwise_xor_operation)\t\\\n+  OPERATION ('|', 4, bitwise_ior_operation)\t\\\n+  OPERATION (EQEQ, 3, equal_operation)\t\t\\\n+  OPERATION (NOTEQ, 3, notequal_operation)\t\\\n+  OPERATION ('<', 3, less_operation)\t\t\\\n+  OPERATION (LTEQ, 3, leq_operation)\t\t\\\n+  OPERATION ('>', 3, gtr_operation)\t\t\\\n+  OPERATION (GTEQ, 3, geq_operation)\t\t\\\n+  OPERATION (ANDAND, 2, logical_and_operation)\t\\\n+  OPERATION (OROR, 1, logical_or_operation)\n+\n+  operation_up start = parse_atom (required);\n+  if (start == nullptr)\n+    {\n+      gdb_assert (!required);\n+      return start;\n+    }\n+\n+  std::vector<rustop_item> operator_stack;\n+  operator_stack.emplace_back (0, -1, OP_NULL, std::move (start));\n+\n+  while (true)\n+    {\n+      int this_token = current_token;\n+      enum exp_opcode compound_assign_op = OP_NULL;\n+      int precedence = -2;\n+\n+      switch (this_token)\n+\t{\n+#define OPERATION(TOKEN, PRECEDENCE, TYPE)\t\t\\\n+\t  case TOKEN:\t\t\t\t\\\n+\t    precedence = PRECEDENCE;\t\t\\\n+\t    lex ();\t\t\t\t\\\n+\t    break;\n+\n+\t  ALL_OPS\n+\n+#undef OPERATION\n+\n+\tcase COMPOUND_ASSIGN:\n+\t  compound_assign_op = current_opcode;\n+\t  /* FALLTHROUGH */\n+\tcase '=':\n+\t  precedence = 0;\n+\t  lex ();\n+\t  break;\n+\n+\t  /* \"as\" must be handled specially.  */\n+\tcase KW_AS:\n+\t  {\n+\t    lex ();\n+\t    rustop_item &lhs = operator_stack.back ();\n+\t    struct type *type = parse_type ();\n+\t    lhs.op = make_operation<unop_cast_operation> (std::move (lhs.op),\n+\t\t\t\t\t\t\t  type);\n+\t  }\n+\t  /* Bypass the rest of the loop.  */\n+\t  continue;\n+\n+\tdefault:\n+\t  /* Arrange to pop the entire stack.  */\n+\t  precedence = -2;\n+\t  break;\n+        }\n+\n+      while (precedence < operator_stack.back ().precedence\n+\t     && operator_stack.size () > 1)\n+\t{\n+\t  rustop_item rhs = std::move (operator_stack.back ());\n+\t  operator_stack.pop_back ();\n+\n+\t  rustop_item &lhs = operator_stack.back ();\n+\n+\t  switch (rhs.token)\n+\t    {\n+#define OPERATION(TOKEN, PRECEDENCE, TYPE)\t\t\t\\\n+\t  case TOKEN:\t\t\t\t\t\t\\\n+\t    lhs.op = make_operation<TYPE> (std::move (lhs.op),\t\\\n+\t\t\t\t\t   std::move (rhs.op)); \\\n+\t    break;\n+\n+\t      ALL_OPS\n+\n+#undef OPERATION\n+\n+\t    case '=':\n+\t    case COMPOUND_ASSIGN:\n+\t      {\n+\t\tif (rhs.token == '=')\n+\t\t  lhs.op = (make_operation<assign_operation>\n+\t\t\t    (std::move (lhs.op), std::move (rhs.op)));\n+\t\telse\n+\t\t  lhs.op = (make_operation<assign_modify_operation>\n+\t\t\t    (rhs.opcode, std::move (lhs.op),\n+\t\t\t     std::move (rhs.op)));\n+\n+\t\tstruct type *unit_type = get_type (\"()\");\n+\n+\t\toperation_up nil (new long_const_operation (unit_type, 0));\n+\t\tlhs.op = (make_operation<comma_operation>\n+\t\t\t  (std::move (lhs.op), std::move (nil)));\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      gdb_assert_not_reached (\"bad binary operator\");\n+\t    }\n+\t}\n+\n+      if (precedence == -2)\n+\tbreak;\n+\n+      operator_stack.emplace_back (this_token, precedence, compound_assign_op,\n+\t\t\t\t   parse_atom (true));\n+    }\n+\n+  gdb_assert (operator_stack.size () == 1);\n+  return std::move (operator_stack[0].op);\n+#undef ALL_OPS\n+}\n+\n+/* Parse a range expression.  */\n+\n+operation_up\n+rust_parser::parse_range ()\n+{\n+  enum range_flag kind = (RANGE_HIGH_BOUND_DEFAULT\n+\t\t\t  | RANGE_LOW_BOUND_DEFAULT);\n+\n+  operation_up lhs;\n+  if (current_token != DOTDOT && current_token != DOTDOTEQ)\n+    {\n+      lhs = parse_binop (true);\n+      kind &= ~RANGE_LOW_BOUND_DEFAULT;\n+    }\n+\n+  if (current_token == DOTDOT)\n+    kind |= RANGE_HIGH_BOUND_EXCLUSIVE;\n+  else if (current_token != DOTDOTEQ)\n+    return lhs;\n+  lex ();\n+\n+  /* A \"..=\" range requires a high bound, but otherwise it is\n+     optional.  */\n+  operation_up rhs = parse_binop ((kind & RANGE_HIGH_BOUND_EXCLUSIVE) == 0);\n+  if (rhs != nullptr)\n+    kind &= ~RANGE_HIGH_BOUND_DEFAULT;\n+\n+  return make_operation<rust_range_operation> (kind,\n+\t\t\t\t\t       std::move (lhs),\n+\t\t\t\t\t       std::move (rhs));\n+}\n+\n+/* Parse an expression.  */\n+\n+operation_up\n+rust_parser::parse_expr ()\n+{\n+  return parse_range ();\n+}\n+\n+/* Parse a sizeof expression.  */\n+\n+operation_up\n+rust_parser::parse_sizeof ()\n+{\n+  assume (KW_SIZEOF);\n+\n+  if (current_token == KW_MUT)\n+    lex ();\n+\n+  require ('(');\n+  operation_up result = make_operation<unop_sizeof_operation> (parse_expr ());\n+  require (')');\n+  return result;\n+}\n+\n+/* Parse an address-of operation.  */\n+\n+operation_up\n+rust_parser::parse_addr ()\n+{\n+  assume ('&');\n+\n+  if (current_token == KW_MUT)\n+    lex ();\n+\n+  return make_operation<rust_unop_addr_operation> (parse_atom (true));\n+}\n+\n+/* Parse a field expression.  */\n+\n+operation_up\n+rust_parser::parse_field (operation_up &&lhs)\n+{\n+  assume ('.');\n+\n+  operation_up result;\n+  switch (current_token)\n+    {\n+    case IDENT:\n+    case COMPLETE:\n+      {\n+\tbool is_complete = current_token == COMPLETE;\n+\tauto struct_op = new rust_structop (std::move (lhs), get_string ());\n+\tlex ();\n+\tif (is_complete)\n+\t  {\n+\t    completion_op.reset (struct_op);\n+\t    pstate->mark_struct_expression (struct_op);\n+\t    /* Throw to the outermost level of the parser.  */\n+\t    error (_(\"not really an error\"));\n+\t  }\n+\tresult.reset (struct_op);\n+      }\n+      break;\n+\n+    case DECIMAL_INTEGER:\n+      result = make_operation<rust_struct_anon> (current_int_val.val,\n+\t\t\t\t\t\t std::move (lhs));\n+      lex ();\n+      break;\n+\n+    case INTEGER:\n+      error (_(\"'_' not allowed in integers in anonymous field references\"));\n+\n+    default:\n+      error (_(\"field name expected\"));\n+    }\n+\n+  return result;\n+}\n+\n+/* Parse an index expression.  */\n+\n+operation_up\n+rust_parser::parse_index (operation_up &&lhs)\n+{\n+  assume ('[');\n+  operation_up rhs = parse_expr ();\n+  require (']');\n+\n+  return make_operation<rust_subscript_operation> (std::move (lhs),\n+\t\t\t\t\t\t   std::move (rhs));\n+}\n+\n+/* Parse a sequence of comma-separated expressions in parens.  */\n+\n+std::vector<operation_up>\n+rust_parser::parse_paren_args ()\n+{\n+  assume ('(');\n+\n+  std::vector<operation_up> args;\n+  while (current_token != ')')\n+    {\n+      if (!args.empty ())\n+\t{\n+\t  if (current_token != ',')\n+\t    error (_(\"',' or ')' expected\"));\n+\t  lex ();\n+\t}\n+\n+      args.push_back (parse_expr ());\n+    }\n+\n+  assume (')');\n+\n+  return args;\n+}\n+\n+/* Parse the parenthesized part of a function call.  */\n+\n+operation_up\n+rust_parser::parse_call (operation_up &&lhs)\n+{\n+  std::vector<operation_up> args = parse_paren_args ();\n+\n+  return make_operation<funcall_operation> (std::move (lhs),\n+\t\t\t\t\t    std::move (args));\n+}\n+\n+/* Parse a list of types.  */\n+\n+std::vector<struct type *>\n+rust_parser::parse_type_list ()\n+{\n+  std::vector<struct type *> result;\n+  result.push_back (parse_type ());\n+  while (current_token == ',')\n+    {\n+      lex ();\n+      result.push_back (parse_type ());\n+    }\n+  return result;\n+}\n+\n+/* Parse a possibly-empty list of types, surrounded in parens.  */\n+\n+std::vector<struct type *>\n+rust_parser::parse_maybe_type_list ()\n+{\n+  assume ('(');\n+  std::vector<struct type *> types;\n+  if (current_token != ')')\n+    types = parse_type_list ();\n+  require (')');\n+  return types;\n+}\n+\n+/* Parse an array type.  */\n+\n+struct type *\n+rust_parser::parse_array_type ()\n+{\n+  assume ('[');\n+  struct type *elt_type = parse_type ();\n+  require (';');\n+\n+  if (current_token != INTEGER && current_token != DECIMAL_INTEGER)\n+    error (_(\"integer expected\"));\n+  LONGEST val = current_int_val.val;\n+  if (val < 0)\n+    error (_(\"Negative array length\"));\n+  lex ();\n+  require (']');\n+\n+  return lookup_array_range_type (elt_type, 0, val - 1);\n+}\n+\n+/* Parse a slice type.  */\n+\n+struct type *\n+rust_parser::parse_slice_type ()\n+{\n+  assume ('&');\n+\n+  bool is_slice = current_token == '[';\n+  if (is_slice)\n+    lex ();\n+\n+  struct type *target = parse_type ();\n+\n+  if (is_slice)\n+    {\n+      require (']');\n+      return rust_slice_type (\"&[*gdb*]\", target, get_type (\"usize\"));\n+    }\n+\n+  /* For now we treat &x and *x identically.  */\n+  return lookup_pointer_type (target);\n+}\n+\n+/* Parse a pointer type.  */\n+\n+struct type *\n+rust_parser::parse_pointer_type ()\n+{\n+  assume ('*');\n+\n+  if (current_token == KW_MUT || current_token == KW_CONST)\n+    lex ();\n+\n+  struct type *target = parse_type ();\n+  /* For the time being we ignore mut/const.  */\n+  return lookup_pointer_type (target);\n+}\n+\n+/* Parse a function type.  */\n+\n+struct type *\n+rust_parser::parse_function_type ()\n+{\n+  assume (KW_FN);\n+\n+  if (current_token != '(')\n+    error (_(\"'(' expected\"));\n+\n+  std::vector<struct type *> types = parse_maybe_type_list ();\n+\n+  if (current_token != ARROW)\n+    error (_(\"'->' expected\"));\n+  lex ();\n+\n+  struct type *result_type = parse_type ();\n+\n+  struct type **argtypes = nullptr;\n+  if (!types.empty ())\n+    argtypes = types.data ();\n+\n+  result_type = lookup_function_type_with_arguments (result_type,\n+\t\t\t\t\t\t     types.size (),\n+\t\t\t\t\t\t     argtypes);\n+  return lookup_pointer_type (result_type);\n+}\n+\n+/* Parse a tuple type.  */\n+\n+struct type *\n+rust_parser::parse_tuple_type ()\n+{\n+  std::vector<struct type *> types = parse_maybe_type_list ();\n+\n+  auto_obstack obstack;\n+  obstack_1grow (&obstack, '(');\n+  for (int i = 0; i < types.size (); ++i)\n+    {\n+      std::string type_name = type_to_string (types[i]);\n+\n+      if (i > 0)\n+\tobstack_1grow (&obstack, ',');\n+      obstack_grow_str (&obstack, type_name.c_str ());\n+    }\n+\n+  obstack_grow_str0 (&obstack, \")\");\n+  const char *name = (const char *) obstack_finish (&obstack);\n+\n+  /* We don't allow creating new tuple types (yet), but we do allow\n+     looking up existing tuple types.  */\n+  struct type *result = rust_lookup_type (name);\n+  if (result == nullptr)\n+    error (_(\"could not find tuple type '%s'\"), name);\n+\n+  return result;\n+}\n+\n+/* Parse a type.  */\n+\n+struct type *\n+rust_parser::parse_type ()\n+{\n+  switch (current_token)\n+    {\n+    case '[':\n+      return parse_array_type ();\n+    case '&':\n+      return parse_slice_type ();\n+    case '*':\n+      return parse_pointer_type ();\n+    case KW_FN:\n+      return parse_function_type ();\n+    case '(':\n+      return parse_tuple_type ();\n+    case KW_SELF:\n+    case KW_SUPER:\n+    case COLONCOLON:\n+    case KW_EXTERN:\n+    case IDENT:\n+      {\n+\tstd::string path = parse_path (false);\n+\tstruct type *result = rust_lookup_type (path.c_str ());\n+\tif (result == nullptr)\n+\t  error (_(\"No type name '%s' in current context\"), path.c_str ());\n+\treturn result;\n+      }\n+    default:\n+      error (_(\"type expected\"));\n+    }\n+}\n+\n+/* Parse a path.  */\n+\n+std::string\n+rust_parser::parse_path (bool for_expr)\n+{\n+  unsigned n_supers = 0;\n+  int first_token = current_token;\n+\n+  switch (current_token)\n+    {\n+    case KW_SELF:\n+      lex ();\n+      if (current_token != COLONCOLON)\n+\treturn \"self\";\n+      lex ();\n+      /* FALLTHROUGH */\n+    case KW_SUPER:\n+      while (current_token == KW_SUPER)\n+\t{\n+\t  ++n_supers;\n+\t  lex ();\n+\t  if (current_token != COLONCOLON)\n+\t    error (_(\"'::' expected\"));\n+\t  lex ();\n+\t}\n+      break;\n+\n+    case COLONCOLON:\n+      lex ();\n+      break;\n+\n+    case KW_EXTERN:\n+      /* This is a gdb extension to make it possible to refer to items\n+\t in other crates.  It just bypasses adding the current crate\n+\t to the front of the name.  */\n+      lex ();\n+      break;\n+    }\n+\n+  if (current_token != IDENT)\n+    error (_(\"identifier expected\"));\n+  std::string path = get_string ();\n+  bool saw_ident = true;\n+  lex ();\n+\n+  /* The condition here lets us enter the loop even if we see\n+     \"ident<...>\".  */\n+  while (current_token == COLONCOLON || current_token == '<')\n+    {\n+      if (current_token == COLONCOLON)\n+\t{\n+\t  lex ();\n+\t  saw_ident = false;\n+\n+\t  if (current_token == IDENT)\n+\t    {\n+\t      path = path + \"::\" + get_string ();\n+\t      lex ();\n+\t      saw_ident = true;\n+\t    }\n+\t  else if (current_token == COLONCOLON)\n+\t    {\n+\t      /* The code below won't detect this scenario.  */\n+\t      error (_(\"unexpected '::'\"));\n+\t    }\n+\t}\n+\n+      if (current_token != '<')\n+\tcontinue;\n+\n+      /* Expression use name::<...>, whereas types use name<...>.  */\n+      if (for_expr)\n+\t{\n+\t  /* Expressions use \"name::<...>\", so if we saw an identifier\n+\t     after the \"::\", we ignore the \"<\" here.  */\n+\t  if (saw_ident)\n+\t    break;\n+\t}\n+      else\n+\t{\n+\t  /* Types use \"name<...>\", so we need to have seen the\n+\t     identifier.  */\n+\t  if (!saw_ident)\n+\t    break;\n+\t}\n+\n+      lex ();\n+      std::vector<struct type *> types = parse_type_list ();\n+      if (current_token == '>')\n+\tlex ();\n+      else if (current_token == RSH)\n+\t{\n+\t  push_back ('>');\n+\t  lex ();\n+\t}\n+      else\n+\terror (_(\"'>' expected\"));\n+\n+      path += \"<\";\n+      for (int i = 0; i < types.size (); ++i)\n+\t{\n+\t  if (i > 0)\n+\t    path += \",\";\n+\t  path += type_to_string (types[i]);\n+\t}\n+      path += \">\";\n+      break;\n+    }\n+\n+  switch (first_token)\n+    {\n+    case KW_SELF:\n+    case KW_SUPER:\n+      return super_name (path, n_supers);\n+\n+    case COLONCOLON:\n+      return crate_name (path);\n+\n+    case KW_EXTERN:\n+      return \"::\" + path;\n+\n+    case IDENT:\n+      return path;\n+\n+    default:\n+      gdb_assert_not_reached (\"missing case in path parsing\");\n+    }\n+}\n+\n+/* Handle the parsing for a string expression.  */\n+\n+operation_up\n+rust_parser::parse_string ()\n+{\n+  gdb_assert (current_token == STRING);\n+\n+  /* Wrap the raw string in the &str struct.  */\n+  struct type *type = rust_lookup_type (\"&str\");\n+  if (type == nullptr)\n+    error (_(\"Could not find type '&str'\"));\n+\n+  std::vector<std::pair<std::string, operation_up>> field_v;\n+\n+  size_t len = current_string_val.length;\n+  operation_up str = make_operation<string_operation> (get_string ());\n+  operation_up addr\n+    = make_operation<rust_unop_addr_operation> (std::move (str));\n+  field_v.emplace_back (\"data_ptr\", std::move (addr));\n+\n+  struct type *valtype = get_type (\"usize\");\n+  operation_up lenop = make_operation<long_const_operation> (valtype, len);\n+  field_v.emplace_back (\"length\", std::move (lenop));\n+\n+  return make_operation<rust_aggregate_operation> (type,\n+\t\t\t\t\t\t   operation_up (),\n+\t\t\t\t\t\t   std::move (field_v));\n+}\n+\n+/* Parse a tuple struct expression.  */\n+\n+operation_up\n+rust_parser::parse_tuple_struct (struct type *type)\n+{\n+  std::vector<operation_up> args = parse_paren_args ();\n+\n+  std::vector<std::pair<std::string, operation_up>> field_v (args.size ());\n+  for (int i = 0; i < args.size (); ++i)\n+    field_v[i] = { string_printf (\"__%d\", i), std::move (args[i]) };\n+\n+  return (make_operation<rust_aggregate_operation>\n+\t  (type, operation_up (), std::move (field_v)));\n+}\n+\n+/* Parse a path expression.  */\n+\n+operation_up\n+rust_parser::parse_path_expr ()\n+{\n+  std::string path = parse_path (true);\n+\n+  if (current_token == '{')\n+    {\n+      struct type *type = rust_lookup_type (path.c_str ());\n+      if (type == nullptr)\n+\terror (_(\"Could not find type '%s'\"), path.c_str ());\n+      \n+      return parse_struct_expr (type);\n+    }\n+  else if (current_token == '(')\n+    {\n+      struct type *type = rust_lookup_type (path.c_str ());\n+      /* If this is actually a tuple struct expression, handle it\n+\t here.  If it is a call, it will be handled elsewhere.  */\n+      if (type != nullptr)\n+\t{\n+\t  if (!rust_tuple_struct_type_p (type))\n+\t    error (_(\"Type %s is not a tuple struct\"), path.c_str ());\n+\t  return parse_tuple_struct (type);\n+\t}\n+    }\n+\n+  return name_to_operation (path);\n+}\n+\n+/* Parse an atom.  \"Atom\" isn't a Rust term, but this refers to a\n+   single unitary item in the grammar; but here including some unary\n+   prefix and postfix expressions.  */\n+\n+operation_up\n+rust_parser::parse_atom (bool required)\n+{\n+  operation_up result;\n+\n+  switch (current_token)\n+    {\n+    case '(':\n+      result = parse_tuple ();\n+      break;\n+\n+    case '[':\n+      result = parse_array ();\n+      break;\n+\n+    case INTEGER:\n+    case DECIMAL_INTEGER:\n+      result = make_operation<long_const_operation> (current_int_val.type,\n+\t\t\t\t\t\t     current_int_val.val);\n+      lex ();\n+      break;\n+\n+    case FLOAT:\n+      result = make_operation<float_const_operation> (current_float_val.type,\n+\t\t\t\t\t\t      current_float_val.val);\n+      lex ();\n+      break;\n+\n+    case STRING:\n+      result = parse_string ();\n+      break;\n+\n+    case BYTESTRING:\n+      result = make_operation<string_operation> (get_string ());\n+      lex ();\n+      break;\n+\n+    case KW_TRUE:\n+    case KW_FALSE:\n+      result = make_operation<bool_operation> (current_token == KW_TRUE);\n+      lex ();\n+      break;\n+\n+    case GDBVAR:\n+      /* This is kind of a hacky approach.  */\n+      {\n+\tpstate->push_dollar (current_string_val);\n+\tresult = pstate->pop ();\n+\tlex ();\n+      }\n+      break;\n+\n+    case KW_SELF:\n+    case KW_SUPER:\n+    case COLONCOLON:\n+    case KW_EXTERN:\n+    case IDENT:\n+      result = parse_path_expr ();\n+      break;\n+\n+    case '*':\n+      lex ();\n+      result = make_operation<rust_unop_ind_operation> (parse_atom (true));\n+      break;\n+    case '+':\n+      lex ();\n+      result = make_operation<unary_plus_operation> (parse_atom (true));\n+      break;\n+    case '-':\n+      lex ();\n+      result = make_operation<unary_neg_operation> (parse_atom (true));\n+      break;\n+    case '!':\n+      lex ();\n+      result = make_operation<rust_unop_compl_operation> (parse_atom (true));\n+      break;\n+    case KW_SIZEOF:\n+      result = parse_sizeof ();\n+      break;\n+    case '&':\n+      result = parse_addr ();\n+      break;\n+\n+    default:\n+      if (!required)\n+\treturn {};\n+      error (_(\"unexpected token\"));\n+    }\n+\n+  /* Now parse suffixes.  */\n+  while (true)\n+    {\n+      switch (current_token)\n+\t{\n+\tcase '.':\n+\t  result = parse_field (std::move (result));\n+\t  break;\n+\n+\tcase '[':\n+\t  result = parse_index (std::move (result));\n+\t  break;\n+\n+\tcase '(':\n+\t  result = parse_call (std::move (result));\n+\t  break;\n+\n+\tdefault:\n+\t  return result;\n+\t}\n+    }\n+}\n+\n+\f\n+\n+/* The parser as exposed to gdb.  */\n+\n+int\n+rust_language::parser (struct parser_state *state) const\n+{\n+  rust_parser parser (state);\n+\n+  operation_up result;\n+  try\n+    {\n+      result = parser.parse_entry_point ();\n+    }\n+  catch (const gdb_exception &exc)\n+    {\n+      if (state->parse_completion)\n+\t{\n+\t  result = std::move (parser.completion_op);\n+\t  if (result == nullptr)\n+\t    throw;\n+\t}\n+      else\n+\tthrow;\n+    }\n+\n+  state->set_operation (std::move (result));\n+\n+  return 0;\n+}\n+\n+\f\n+\n+#if GDB_SELF_TEST\n+\n+/* A test helper that lexes a string, expecting a single token.  */\n+\n+static void\n+rust_lex_test_one (rust_parser *parser, const char *input, int expected)\n+{\n+  int token;\n+\n+  parser->reset (input);\n+\n+  token = parser->lex_one_token ();\n+  SELF_CHECK (token == expected);\n+\n+  if (token)\n+    {\n+      token = parser->lex_one_token ();\n+      SELF_CHECK (token == 0);\n+    }\n+}\n+\n+/* Test that INPUT lexes as the integer VALUE.  */\n+\n+static void\n+rust_lex_int_test (rust_parser *parser, const char *input,\n+\t\t   LONGEST value, int kind)\n+{\n+  rust_lex_test_one (parser, input, kind);\n+  SELF_CHECK (parser->current_int_val.val == value);\n+}\n+\n+/* Test that INPUT throws an exception with text ERR.  */\n+\n+static void\n+rust_lex_exception_test (rust_parser *parser, const char *input,\n+\t\t\t const char *err)\n+{\n+  try\n+    {\n+      /* The \"kind\" doesn't matter.  */\n+      rust_lex_test_one (parser, input, DECIMAL_INTEGER);\n+      SELF_CHECK (0);\n+    }\n+  catch (const gdb_exception_error &except)\n+    {\n+      SELF_CHECK (strcmp (except.what (), err) == 0);\n+    }\n+}\n+\n+/* Test that INPUT lexes as the identifier, string, or byte-string\n+   VALUE.  KIND holds the expected token kind.  */\n+\n+static void\n+rust_lex_stringish_test (rust_parser *parser, const char *input,\n+\t\t\t const char *value, int kind)\n+{\n+  rust_lex_test_one (parser, input, kind);\n+  SELF_CHECK (parser->get_string () == value);\n+}\n+\n+/* Helper to test that a string parses as a given token sequence.  */\n+\n+static void\n+rust_lex_test_sequence (rust_parser *parser, const char *input, int len,\n+\t\t\tconst int expected[])\n+{\n+  int i;\n+\n+  parser->reset (input);\n+\n+  for (i = 0; i < len; ++i)\n+    {\n+      int token = parser->lex_one_token ();\n+      SELF_CHECK (token == expected[i]);\n+    }\n+}\n+\n+/* Tests for an integer-parsing corner case.  */\n+\n+static void\n+rust_lex_test_trailing_dot (rust_parser *parser)\n+{\n+  const int expected1[] = { DECIMAL_INTEGER, '.', IDENT, '(', ')', 0 };\n+  const int expected2[] = { INTEGER, '.', IDENT, '(', ')', 0 };\n+  const int expected3[] = { FLOAT, EQEQ, '(', ')', 0 };\n+  const int expected4[] = { DECIMAL_INTEGER, DOTDOT, DECIMAL_INTEGER, 0 };\n+\n+  rust_lex_test_sequence (parser, \"23.g()\", ARRAY_SIZE (expected1), expected1);\n+  rust_lex_test_sequence (parser, \"23_0.g()\", ARRAY_SIZE (expected2),\n+\t\t\t  expected2);\n+  rust_lex_test_sequence (parser, \"23.==()\", ARRAY_SIZE (expected3),\n+\t\t\t  expected3);\n+  rust_lex_test_sequence (parser, \"23..25\", ARRAY_SIZE (expected4), expected4);\n+}\n+\n+/* Tests of completion.  */\n+\n+static void\n+rust_lex_test_completion (rust_parser *parser)\n+{\n+  const int expected[] = { IDENT, '.', COMPLETE, 0 };\n+\n+  parser->pstate->parse_completion = 1;\n+\n+  rust_lex_test_sequence (parser, \"something.wha\", ARRAY_SIZE (expected),\n+\t\t\t  expected);\n+  rust_lex_test_sequence (parser, \"something.\", ARRAY_SIZE (expected),\n+\t\t\t  expected);\n+\n+  parser->pstate->parse_completion = 0;\n+}\n+\n+/* Test pushback.  */\n+\n+static void\n+rust_lex_test_push_back (rust_parser *parser)\n+{\n+  int token;\n+\n+  parser->reset (\">>=\");\n+\n+  token = parser->lex_one_token ();\n+  SELF_CHECK (token == COMPOUND_ASSIGN);\n+  SELF_CHECK (parser->current_opcode == BINOP_RSH);\n+\n+  parser->push_back ('=');\n+\n+  token = parser->lex_one_token ();\n+  SELF_CHECK (token == '=');\n+\n+  token = parser->lex_one_token ();\n+  SELF_CHECK (token == 0);\n+}\n+\n+/* Unit test the lexer.  */\n+\n+static void\n+rust_lex_tests (void)\n+{\n+  int i;\n+\n+  /* Set up dummy \"parser\", so that rust_type works.  */\n+  struct parser_state ps (language_def (language_rust), target_gdbarch (),\n+\t\t\t  nullptr, 0, 0, nullptr, 0, nullptr, false);\n+  rust_parser parser (&ps);\n+\n+  rust_lex_test_one (&parser, \"\", 0);\n+  rust_lex_test_one (&parser, \"    \\t  \\n \\r  \", 0);\n+  rust_lex_test_one (&parser, \"thread 23\", 0);\n+  rust_lex_test_one (&parser, \"task 23\", 0);\n+  rust_lex_test_one (&parser, \"th 104\", 0);\n+  rust_lex_test_one (&parser, \"ta 97\", 0);\n+\n+  rust_lex_int_test (&parser, \"'z'\", 'z', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\xff'\", 0xff, INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\u{1016f}'\", 0x1016f, INTEGER);\n+  rust_lex_int_test (&parser, \"b'z'\", 'z', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\xfe'\", 0xfe, INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\xFE'\", 0xfe, INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\xfE'\", 0xfe, INTEGER);\n+\n+  /* Test all escapes in both modes.  */\n+  rust_lex_int_test (&parser, \"'\\\\n'\", '\\n', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\r'\", '\\r', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\t'\", '\\t', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\\\\\'\", '\\\\', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\0'\", '\\0', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\''\", '\\'', INTEGER);\n+  rust_lex_int_test (&parser, \"'\\\\\\\"'\", '\"', INTEGER);\n+\n+  rust_lex_int_test (&parser, \"b'\\\\n'\", '\\n', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\r'\", '\\r', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\t'\", '\\t', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\\\\\'\", '\\\\', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\0'\", '\\0', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\''\", '\\'', INTEGER);\n+  rust_lex_int_test (&parser, \"b'\\\\\\\"'\", '\"', INTEGER);\n+\n+  rust_lex_exception_test (&parser, \"'z\", \"Unterminated character literal\");\n+  rust_lex_exception_test (&parser, \"b'\\\\x0'\", \"Not enough hex digits seen\");\n+  rust_lex_exception_test (&parser, \"b'\\\\u{0}'\",\n+\t\t\t   \"Unicode escape in byte literal\");\n+  rust_lex_exception_test (&parser, \"'\\\\x0'\", \"Not enough hex digits seen\");\n+  rust_lex_exception_test (&parser, \"'\\\\u0'\", \"Missing '{' in Unicode escape\");\n+  rust_lex_exception_test (&parser, \"'\\\\u{0\", \"Missing '}' in Unicode escape\");\n+  rust_lex_exception_test (&parser, \"'\\\\u{0000007}\", \"Overlong hex escape\");\n+  rust_lex_exception_test (&parser, \"'\\\\u{}\", \"Not enough hex digits seen\");\n+  rust_lex_exception_test (&parser, \"'\\\\Q'\", \"Invalid escape \\\\Q in literal\");\n+  rust_lex_exception_test (&parser, \"b'\\\\Q'\", \"Invalid escape \\\\Q in literal\");\n+\n+  rust_lex_int_test (&parser, \"23\", 23, DECIMAL_INTEGER);\n+  rust_lex_int_test (&parser, \"2_344__29\", 234429, INTEGER);\n+  rust_lex_int_test (&parser, \"0x1f\", 0x1f, INTEGER);\n+  rust_lex_int_test (&parser, \"23usize\", 23, INTEGER);\n+  rust_lex_int_test (&parser, \"23i32\", 23, INTEGER);\n+  rust_lex_int_test (&parser, \"0x1_f\", 0x1f, INTEGER);\n+  rust_lex_int_test (&parser, \"0b1_101011__\", 0x6b, INTEGER);\n+  rust_lex_int_test (&parser, \"0o001177i64\", 639, INTEGER);\n+  rust_lex_int_test (&parser, \"0x123456789u64\", 0x123456789ull, INTEGER);\n+\n+  rust_lex_test_trailing_dot (&parser);\n+\n+  rust_lex_test_one (&parser, \"23.\", FLOAT);\n+  rust_lex_test_one (&parser, \"23.99f32\", FLOAT);\n+  rust_lex_test_one (&parser, \"23e7\", FLOAT);\n+  rust_lex_test_one (&parser, \"23E-7\", FLOAT);\n+  rust_lex_test_one (&parser, \"23e+7\", FLOAT);\n+  rust_lex_test_one (&parser, \"23.99e+7f64\", FLOAT);\n+  rust_lex_test_one (&parser, \"23.82f32\", FLOAT);\n+\n+  rust_lex_stringish_test (&parser, \"hibob\", \"hibob\", IDENT);\n+  rust_lex_stringish_test (&parser, \"hibob__93\", \"hibob__93\", IDENT);\n+  rust_lex_stringish_test (&parser, \"thread\", \"thread\", IDENT);\n+\n+  rust_lex_stringish_test (&parser, \"\\\"string\\\"\", \"string\", STRING);\n+  rust_lex_stringish_test (&parser, \"\\\"str\\\\ting\\\"\", \"str\\ting\", STRING);\n+  rust_lex_stringish_test (&parser, \"\\\"str\\\\\\\"ing\\\"\", \"str\\\"ing\", STRING);\n+  rust_lex_stringish_test (&parser, \"r\\\"str\\\\ing\\\"\", \"str\\\\ing\", STRING);\n+  rust_lex_stringish_test (&parser, \"r#\\\"str\\\\ting\\\"#\", \"str\\\\ting\", STRING);\n+  rust_lex_stringish_test (&parser, \"r###\\\"str\\\\\\\"ing\\\"###\", \"str\\\\\\\"ing\",\n+\t\t\t   STRING);\n+\n+  rust_lex_stringish_test (&parser, \"b\\\"string\\\"\", \"string\", BYTESTRING);\n+  rust_lex_stringish_test (&parser, \"b\\\"\\x73tring\\\"\", \"string\", BYTESTRING);\n+  rust_lex_stringish_test (&parser, \"b\\\"str\\\\\\\"ing\\\"\", \"str\\\"ing\", BYTESTRING);\n+  rust_lex_stringish_test (&parser, \"br####\\\"\\\\x73tring\\\"####\", \"\\\\x73tring\",\n+\t\t\t   BYTESTRING);\n+\n+  for (i = 0; i < ARRAY_SIZE (identifier_tokens); ++i)\n+    rust_lex_test_one (&parser, identifier_tokens[i].name,\n+\t\t       identifier_tokens[i].value);\n+\n+  for (i = 0; i < ARRAY_SIZE (operator_tokens); ++i)\n+    rust_lex_test_one (&parser, operator_tokens[i].name,\n+\t\t       operator_tokens[i].value);\n+\n+  rust_lex_test_completion (&parser);\n+  rust_lex_test_push_back (&parser);\n+}\n+\n+#endif /* GDB_SELF_TEST */\n+\n+\f\n+\n+void _initialize_rust_exp ();\n+void\n+_initialize_rust_exp ()\n+{\n+  int code = regcomp (&number_regex, number_regex_text, REG_EXTENDED);\n+  /* If the regular expression was incorrect, it was a programming\n+     error.  */\n+  gdb_assert (code == 0);\n+\n+#if GDB_SELF_TEST\n+  selftests::register_test (\"rust-lex\", rust_lex_tests);\n+#endif\n+}"
    },
    {
      "sha": "995bb783bee815031a9d727fae507c8873ee482c",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -1,3 +1,8 @@\n+2021-04-16  Tom Tromey  <tom@tromey.com>\n+\n+\t* gdb.rust/simple.exp: Change error text.\n+\t* gdb.rust/expr.exp: Change error text.\n+\n 2021-04-16  Tom Tromey  <tom@tromey.com>\n \n \t* gdb.rust/simple.exp: Add parens to 'as' test."
    },
    {
      "sha": "d81b6fcbf57b022669cc83abb2cceb816c992b4a",
      "filename": "gdb/testsuite/gdb.rust/expr.exp",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/gdb.rust/expr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/gdb.rust/expr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.rust/expr.exp?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -136,6 +136,10 @@ gdb_test \"print \\[mut 23usize; 4\\]\" \" = \\\\\\[23, 23, 23, 23\\\\\\]\"\n # Test lexer corner cases.\n gdb_test \"print 0x0 as *mut ()\" \" = \\\\\\(\\\\*mut \\\\\\(\\\\\\)\\\\\\) 0x0\"\n gdb_test \"print 0x0 as fn(i64) -> ()\" \" = \\\\\\(\\\\*mut fn \\\\\\(i64\\\\\\) -> \\\\\\(\\\\\\)\\\\\\) 0x0\"\n-gdb_test \"print r#\" \"syntax error in expression, near `#'\\\\.\"\n+\n+# The lexer doesn't treat this as a failure, but rather as two tokens,\n+# and we error out while trying to look up 'r'.  This is fine, though\n+# -- what's important is that it isn't accepted.\n+gdb_test \"print r#\" \"No symbol 'r' in current context\"\n \n gdb_test \"printf \\\"%d %d\\\\n\\\", 23+1, 23-1\" \"24 22\""
    },
    {
      "sha": "0be0e94ac4c71c1c6f9f0a5dd7893f092c314d27",
      "filename": "gdb/testsuite/gdb.rust/simple.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/gdb.rust/simple.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3cbc7ac344cd6b500b54588a9099c037de58e75a/gdb/testsuite/gdb.rust/simple.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.rust/simple.exp?ref=3cbc7ac344cd6b500b54588a9099c037de58e75a",
      "patch": "@@ -165,7 +165,7 @@ gdb_test \"print simple::HiBob(0xff, 5)\" \\\n     \"Type simple::HiBob is not a tuple struct\"\n gdb_test \"print sizeof(simple::HiBob)\" \" = \\[0-9\\]+\"\n gdb_test \"print simple::HiBob + 5\" \\\n-    \"Found type 'simple::HiBob', which can't be evaluated in this context\"\n+    \"Attempt to use a type name as an expression\"\n gdb_test \"print nosuchsymbol\" \\\n     \"No symbol 'nosuchsymbol' in current context\"\n "
    }
  ]
}