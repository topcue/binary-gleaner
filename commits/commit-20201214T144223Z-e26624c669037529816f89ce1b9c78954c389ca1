{
  "sha": "e26624c669037529816f89ce1b9c78954c389ca1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTI2NjI0YzY2OTAzNzUyOTgxNmY4OWNlMWI5Yzc4OTU0YzM4OWNhMQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-12-14T14:42:23Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-12-14T14:42:23Z"
    },
    "message": "Be more careful when rewriting thick pointer array type\n\nTo handle thick pointers with -fgnat-encodings=minimal, gdb will\nrewrite the underlying array type to remove the bounds.  However, if\nthe same DWARF type is used both for a thick pointer and for an\nordinary array, this will have the side effect of removing the bounds\nfrom the array.  This breaks the printing of objects of this type.\n\nThis patch fixes the problem by copying the array type, its range, and\nits bounds.\n\ngdb/ChangeLog\n2020-12-14  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.c (rewrite_array_type): New function.\n        (quirk_ada_thick_pointer_struct): Use rewrite_array_type.\n\ngdb/testsuite/ChangeLog\n2020-12-14  Tom Tromey  <tromey@adacore.com>\n\n\t* gdb.dwarf2/ada-thick-pointer.exp: New file.",
    "tree": {
      "sha": "e2b683793e2f22b56ce2dac69d4f67eccc21a848",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e2b683793e2f22b56ce2dac69d4f67eccc21a848"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e26624c669037529816f89ce1b9c78954c389ca1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e26624c669037529816f89ce1b9c78954c389ca1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e26624c669037529816f89ce1b9c78954c389ca1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e26624c669037529816f89ce1b9c78954c389ca1/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a3bdae4ef826f2b59cc475e530b2a4130185cfac",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a3bdae4ef826f2b59cc475e530b2a4130185cfac",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a3bdae4ef826f2b59cc475e530b2a4130185cfac"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 162,
    "deletions": 13
  },
  "files": [
    {
      "sha": "f87f6df6578d935b8aa3484c5526bbca7c71b616",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e26624c669037529816f89ce1b9c78954c389ca1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e26624c669037529816f89ce1b9c78954c389ca1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e26624c669037529816f89ce1b9c78954c389ca1",
      "patch": "@@ -1,3 +1,8 @@\n+2020-12-14  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.c (rewrite_array_type): New function.\n+        (quirk_ada_thick_pointer_struct): Use rewrite_array_type.\n+\n 2020-12-14  Tom Tromey  <tromey@adacore.com>\n \n \t* valarith.c (fixed_point_binop): Call error on division by zero."
    },
    {
      "sha": "4edd8d4d9d6858226f09d30624413239b42a487c",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 58,
      "deletions": 13,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e26624c669037529816f89ce1b9c78954c389ca1/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e26624c669037529816f89ce1b9c78954c389ca1/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=e26624c669037529816f89ce1b9c78954c389ca1",
      "patch": "@@ -15890,6 +15890,55 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   smash_to_methodptr_type (type, new_type);\n }\n \n+/* Helper for quirk_ada_thick_pointer.  If TYPE is an array type that\n+   requires rewriting, then copy it and return the updated copy.\n+   Otherwise return nullptr.  */\n+\n+static struct type *\n+rewrite_array_type (struct type *type)\n+{\n+  if (type->code () != TYPE_CODE_ARRAY)\n+    return nullptr;\n+\n+  struct type *index_type = type->index_type ();\n+  range_bounds *current_bounds = index_type->bounds ();\n+\n+  /* Handle multi-dimensional arrays.  */\n+  struct type *new_target = rewrite_array_type (TYPE_TARGET_TYPE (type));\n+  if (new_target == nullptr)\n+    {\n+      /* Maybe we don't need to rewrite this array.  */\n+      if (current_bounds->low.kind () == PROP_CONST\n+\t  && current_bounds->high.kind () == PROP_CONST)\n+\treturn nullptr;\n+    }\n+\n+  /* Either the target type was rewritten, or the bounds have to be\n+     updated.  Either way we want to copy the type and update\n+     everything.  */\n+  struct type *copy = copy_type (type);\n+  int nfields = copy->num_fields ();\n+  field *new_fields\n+    = ((struct field *) TYPE_ZALLOC (copy,\n+\t\t\t\t     nfields * sizeof (struct field)));\n+  memcpy (new_fields, copy->fields (), nfields * sizeof (struct field));\n+  copy->set_fields (new_fields);\n+  if (new_target != nullptr)\n+    TYPE_TARGET_TYPE (copy) = new_target;\n+\n+  struct type *index_copy = copy_type (index_type);\n+  range_bounds *bounds\n+    = (struct range_bounds *) TYPE_ZALLOC (index_copy,\n+\t\t\t\t\t   sizeof (range_bounds));\n+  *bounds = *current_bounds;\n+  bounds->low.set_const_val (1);\n+  bounds->high.set_const_val (0);\n+  index_copy->set_bounds (bounds);\n+  copy->set_index_type (index_copy);\n+\n+  return copy;\n+}\n+\n /* While some versions of GCC will generate complicated DWARF for an\n    array (see quirk_ada_thick_pointer), more recent versions were\n    modified to emit an explicit thick pointer structure.  However, in\n@@ -15916,20 +15965,16 @@ quirk_ada_thick_pointer_struct (struct die_info *die, struct dwarf2_cu *cu,\n   /* Make sure we're looking at a pointer to an array.  */\n   if (type->field (0).type ()->code () != TYPE_CODE_PTR)\n     return;\n-  struct type *ary_type = TYPE_TARGET_TYPE (type->field (0).type ());\n-\n-  while (ary_type->code () == TYPE_CODE_ARRAY)\n-    {\n-      /* The Ada code already knows how to handle these types, so all\n-\t that we need to do is turn the bounds into static bounds.  */\n-      struct type *index_type = ary_type->index_type ();\n \n-      index_type->bounds ()->low.set_const_val (1);\n-      index_type->bounds ()->high.set_const_val (0);\n-\n-      /* Handle multi-dimensional arrays.  */\n-      ary_type = TYPE_TARGET_TYPE (ary_type);\n-    }\n+  /* The Ada code already knows how to handle these types, so all that\n+     we need to do is turn the bounds into static bounds.  However, we\n+     don't want to rewrite existing array or index types in-place,\n+     because those may be referenced in other contexts where this\n+     rewriting is undesirable.  */\n+  struct type *new_ary_type\n+    = rewrite_array_type (TYPE_TARGET_TYPE (type->field (0).type ()));\n+  if (new_ary_type != nullptr)\n+    type->field (0).set_type (lookup_pointer_type (new_ary_type));\n }\n \n /* If the DIE has a DW_AT_alignment attribute, return its value, doing"
    },
    {
      "sha": "f0d452b7a3126340a52a8046fe9486c655b247c6",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e26624c669037529816f89ce1b9c78954c389ca1/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e26624c669037529816f89ce1b9c78954c389ca1/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=e26624c669037529816f89ce1b9c78954c389ca1",
      "patch": "@@ -1,3 +1,7 @@\n+2020-12-14  Tom Tromey  <tromey@adacore.com>\n+\n+\t* gdb.dwarf2/ada-thick-pointer.exp: New file.\n+\n 2020-12-14  Tom Tromey  <tromey@adacore.com>\n \n \t* gdb.dwarf2/dw2-fixed-point.exp: Add test for division by zero."
    },
    {
      "sha": "7077b4c76f1dcdf5ebd33ba67cb8b2a34300424f",
      "filename": "gdb/testsuite/gdb.dwarf2/ada-thick-pointer.exp",
      "status": "added",
      "additions": 95,
      "deletions": 0,
      "changes": 95,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e26624c669037529816f89ce1b9c78954c389ca1/gdb/testsuite/gdb.dwarf2/ada-thick-pointer.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e26624c669037529816f89ce1b9c78954c389ca1/gdb/testsuite/gdb.dwarf2/ada-thick-pointer.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/ada-thick-pointer.exp?ref=e26624c669037529816f89ce1b9c78954c389ca1",
      "patch": "@@ -0,0 +1,95 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test that handling of Ada thick pointers does not rewrite other\n+# similar types.\n+\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF-2 and use gas.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+standard_testfile main.c -debug.S\n+\n+# Set up the DWARF for the test.\n+\n+set asm_file [standard_output_file $srcfile2]\n+Dwarf::assemble $asm_file {\n+    global srcdir subdir srcfile\n+\n+    cu {} {\n+\tDW_TAG_compile_unit {\n+                {DW_AT_language @DW_LANG_Ada95}\n+                {DW_AT_name     $srcfile}\n+        } {\n+\t    declare_labels integer array array_pointer bounds_pointer\n+\n+            integer: DW_TAG_base_type {\n+                {DW_AT_byte_size 8 DW_FORM_sdata}\n+                {DW_AT_encoding  @DW_ATE_signed}\n+                {DW_AT_name      integer}\n+            }\n+\n+\t    array: DW_TAG_array_type {\n+\t\t{DW_AT_name array_type}\n+\t\t{DW_AT_type :$integer}\n+\t    } {\n+\t\tDW_TAG_subrange_type {\n+\t\t    {DW_AT_type        :$integer}\n+\t\t    {DW_AT_lower_bound 1 DW_FORM_data1}\n+\t\t    {DW_AT_upper_bound 7 DW_FORM_data1}\n+\t\t}\n+\t    }\n+\n+\t    array_pointer: DW_TAG_pointer_type {\n+\t\t{DW_AT_type :$array}\n+\t\t{DW_AT_byte_size 8 DW_FORM_sdata}\n+\t    }\n+\n+\t    # This isn't exactly what GNAT emits, but it doesn't\n+\t    # matter.\n+\t    bounds_pointer: DW_TAG_pointer_type {\n+\t\t{DW_AT_type :$integer}\n+\t\t{DW_AT_byte_size 8 DW_FORM_sdata}\n+\t    }\n+\n+\t    DW_TAG_structure_type {\n+\t\t{DW_AT_name thick_pointer_type}\n+\t\t{DW_AT_byte_size 8 DW_FORM_sdata}\n+\t    } {\n+\t\tDW_TAG_member {\n+\t\t    {DW_AT_name P_ARRAY}\n+\t\t    {DW_AT_type :$array_pointer}\n+\t\t    {DW_AT_data_member_location 0 DW_FORM_sdata}\n+\t\t}\n+\t\tDW_TAG_member {\n+\t\t    {DW_AT_name P_BOUNDS}\n+\t\t    {DW_AT_type :$bounds_pointer}\n+\t\t    {DW_AT_data_member_location 8 DW_FORM_sdata}\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+\t  [list $srcfile $asm_file] {nodebug}] } {\n+    return -1\n+}\n+\n+gdb_test_no_output \"set language ada\"\n+gdb_test \"ptype array_type\" \"type = array \\\\(1 \\\\.\\\\. 7\\\\) of integer\""
    }
  ]
}