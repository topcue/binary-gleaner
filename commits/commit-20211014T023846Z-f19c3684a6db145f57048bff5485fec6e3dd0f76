{
  "sha": "f19c3684a6db145f57048bff5485fec6e3dd0f76",
  "node_id": "C_kwDOANOeidoAKGYxOWMzNjg0YTZkYjE0NWY1NzA0OGJmZjU0ODVmZWM2ZTNkZDBmNzY",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-08T23:33:21Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-14T02:38:46Z"
    },
    "message": "[GOLD] Two GOT sections for PowerPC64\n\nSplit .got into two piece, one with the header and entries for small\nmodel got entries, the other with entries for medium/large model got\nentries.  The idea is to better support mixed pcrel/non-pcrel code\nwhere non-pcrel small-model .toc entries need to be within 32k of the\ntoc pointer.\n\n\t* target.h (Target::tls_offset_for_local): Add got param.\n\t(Target::tls_offset_for_global): Likewise.\n\t(Target::do_tls_offset_for_local, do_tls_offset_for_global): Likewise.\n\t* output.h (Output_data_got::Got_entry::write): Add got param.\n\t* output.cc (Output_data_got::Got_entry::write): Likewise, pass to\n\ttls_offset_for_local/global calls.\n\t(Output_data_got::do_write): Adjust to suit.\n\t* s390.cc (Target_s390::do_tls_offset_for_local): Likewise.\n\t(Target_s390::do_tls_offset_for_global): Likewise.\n\t* powerpc.cc (enum Got_type): Extend with small types, move from\n\tclass Target_powerpc.\n\t(Target_powerpc::biggot_): New.\n\t(Traget_powerpc::do_tls_offset_for_local, do_tls_offset_for_global,\n\tgot_size, got_section, got_base_offset): Handle biggot_.\n\t(Target_powerpc::do_define_standard_symbols): Adjust.\n\t(Target_powerpc::make_plt_section, do_finalize_sections): Likewise.\n\t(Output_data_got_powerpc::Output_data_got_powerpc): Only make\n\t64-bit header for small got section.\n\t(Output_data_got_powerpc::g_o_t): Only return a result for small\n\tgot section.\n\t(Output_data_got_powerpc::write): Only write small got section\n\theader.\n\t(Target_powerpc::Scan::local, global): Select small/big Got_type\n\tand section to suit reloc.\n\t(Target_powerpc::Relocate::relocate): Similarly.\n\t(Sort_toc_sections): Rewrite.",
    "tree": {
      "sha": "f9a488503e22d7ecae390a551b5bbadddd0ec52a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f9a488503e22d7ecae390a551b5bbadddd0ec52a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f19c3684a6db145f57048bff5485fec6e3dd0f76",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f19c3684a6db145f57048bff5485fec6e3dd0f76",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f19c3684a6db145f57048bff5485fec6e3dd0f76",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f19c3684a6db145f57048bff5485fec6e3dd0f76/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a19da04b3c3a01699aaf7a59b03f5f008355b23d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a19da04b3c3a01699aaf7a59b03f5f008355b23d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a19da04b3c3a01699aaf7a59b03f5f008355b23d"
    }
  ],
  "stats": {
    "total": 372,
    "additions": 244,
    "deletions": 128
  },
  "files": [
    {
      "sha": "f2890c87f8ccaa7f5c15bdde8e98a6ec10e5fa20",
      "filename": "gold/output.cc",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/output.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/output.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/output.cc?ref=f19c3684a6db145f57048bff5485fec6e3dd0f76",
      "patch": "@@ -1367,6 +1367,7 @@ Output_data_group<size, big_endian>::do_write(Output_file* of)\n template<int got_size, bool big_endian>\n void\n Output_data_got<got_size, big_endian>::Got_entry::write(\n+    Output_data_got_base* got,\n     unsigned int got_indx,\n     unsigned char* pov) const\n {\n@@ -1421,7 +1422,7 @@ Output_data_got<got_size, big_endian>::Got_entry::write(\n \t    if (this->use_plt_or_tls_offset_\n \t\t&& gsym->type() == elfcpp::STT_TLS)\n \t      val += parameters->target().tls_offset_for_global(gsym,\n-\t\t\t\t\t\t\t\tgot_indx,\n+\t\t\t\t\t\t\t\tgot, got_indx,\n \t\t\t\t\t\t\t\tthis->addend_);\n \t  }\n       }\n@@ -1451,7 +1452,7 @@ Output_data_got<got_size, big_endian>::Got_entry::write(\n \t    val = convert_types<Valtype, uint64_t>(lval);\n \t    if (this->use_plt_or_tls_offset_ && is_tls)\n \t      val += parameters->target().tls_offset_for_local(object, lsi,\n-\t\t\t\t\t\t\t       got_indx,\n+\t\t\t\t\t\t\t       got, got_indx,\n \t\t\t\t\t\t\t       this->addend_);\n \t  }\n       }\n@@ -1699,7 +1700,7 @@ Output_data_got<got_size, big_endian>::do_write(Output_file* of)\n   unsigned char* pov = oview;\n   for (unsigned int i = 0; i < this->entries_.size(); ++i)\n     {\n-      this->entries_[i].write(i, pov);\n+      this->entries_[i].write(this, i, pov);\n       pov += add;\n     }\n "
    },
    {
      "sha": "9f1ed6cc5679b12177e64f1618883f4fadf1eccc",
      "filename": "gold/output.h",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/output.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/output.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/output.h?ref=f19c3684a6db145f57048bff5485fec6e3dd0f76",
      "patch": "@@ -2633,7 +2633,8 @@ class Output_data_got : public Output_data_got_base\n \n     // Write the GOT entry to an output view.\n     void\n-    write(unsigned int got_indx, unsigned char* pov) const;\n+    write(Output_data_got_base* got, unsigned int got_indx,\n+\t  unsigned char* pov) const;\n \n    private:\n     enum"
    },
    {
      "sha": "d10b11e003b1bce6cb3307b7854da1027e0d4523",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 222,
      "deletions": 118,
      "changes": 340,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=f19c3684a6db145f57048bff5485fec6e3dd0f76",
      "patch": "@@ -659,6 +659,21 @@ class Powerpc_copy_relocs : public Copy_relocs<sh_type, size, big_endian>\n   emit(Output_data_reloc<sh_type, true, size, big_endian>*);\n };\n \n+// The types of GOT entries needed for this platform.\n+// These values are exposed to the ABI in an incremental link, but\n+// powerpc does not support incremental linking as yet.\n+enum Got_type\n+  {\n+    GOT_TYPE_STANDARD = 0,\n+    GOT_TYPE_TLSGD = 1,\t\t// double entry for @got@tlsgd\n+    GOT_TYPE_DTPREL = 2,\t// entry for @got@dtprel\n+    GOT_TYPE_TPREL = 3,\t\t// entry for @got@tprel\n+    GOT_TYPE_SMALL = 4,\n+    GOT_TYPE_SMALL_TLSGD = 5,\n+    GOT_TYPE_SMALL_DTPREL = 6,\n+    GOT_TYPE_SMALL_TPREL = 7\n+  };\n+\n template<int size, bool big_endian>\n class Target_powerpc : public Sized_target<size, big_endian>\n {\n@@ -675,8 +690,8 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \n   Target_powerpc()\n     : Sized_target<size, big_endian>(&powerpc_info),\n-      got_(NULL), plt_(NULL), iplt_(NULL), lplt_(NULL), brlt_section_(NULL),\n-      glink_(NULL), rela_dyn_(NULL), copy_relocs_(),\n+      got_(NULL), biggot_(NULL), plt_(NULL), iplt_(NULL), lplt_(NULL),\n+      brlt_section_(NULL), glink_(NULL), rela_dyn_(NULL), copy_relocs_(),\n       tlsld_got_offset_(-1U),\n       stub_tables_(), branch_lookup_table_(), branch_info_(), tocsave_loc_(),\n       power10_relocs_(false), plt_thread_safe_(false), plt_localentry0_(false),\n@@ -819,13 +834,15 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   int64_t\n   do_tls_offset_for_local(const Relobj* object,\n \t\t\t  unsigned int symndx,\n+\t\t\t  Output_data_got_base* got,\n \t\t\t  unsigned int got_indx,\n \t\t\t  uint64_t addend) const;\n \n   // Return the offset to use for the GOT_INDX'th got entry which is\n   // for global tls symbol GSYM.\n   int64_t\n-  do_tls_offset_for_global(Symbol* gsym, unsigned int got_indx,\n+  do_tls_offset_for_global(Symbol* gsym,\n+\t\t\t   Output_data_got_base* got, unsigned int got_indx,\n \t\t\t   uint64_t addend) const;\n \n   void\n@@ -908,12 +925,13 @@ class Target_powerpc : public Sized_target<size, big_endian>\n     return strcmp(sym->name(), \"__tls_get_addr\") == 0;\n   }\n \n-  // Return the size of the GOT section.\n+  // Return the size of the GOT section, for incremental linking\n   section_size_type\n   got_size() const\n   {\n     gold_assert(this->got_ != NULL);\n-    return this->got_->data_size();\n+    return this->got_->data_size() + (this->biggot_\n+\t\t\t\t      ? this->biggot_->data_size() : 0);\n   }\n \n   // Get the PLT section.\n@@ -986,15 +1004,18 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \n   // Get the GOT section.\n   const Output_data_got_powerpc<size, big_endian>*\n-  got_section() const\n+  got_section(Got_type got_type) const\n   {\n     gold_assert(this->got_ != NULL);\n-    return this->got_;\n+    if (size == 32 || (got_type & GOT_TYPE_SMALL))\n+      return this->got_;\n+    gold_assert(this->biggot_ != NULL);\n+    return this->biggot_;\n   }\n \n   // Get the GOT section, creating it if necessary.\n   Output_data_got_powerpc<size, big_endian>*\n-  got_section(Symbol_table*, Layout*);\n+  got_section(Symbol_table*, Layout*, Got_type);\n \n   // The toc/got pointer reg will be set to this value.\n   Address\n@@ -1005,9 +1026,11 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \n   // Offset of base used to access the GOT/TOC relative to the GOT section.\n   Address\n-  got_base_offset() const\n+  got_base_offset(Got_type got_type) const\n   {\n-    return this->got_->g_o_t();\n+    if (size == 32 || (got_type & GOT_TYPE_SMALL))\n+      return this->got_->g_o_t();\n+    return this->toc_pointer() - this->biggot_->address();\n   }\n \n   Object*\n@@ -1698,20 +1721,13 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   // general Target structure.\n   static Target::Target_info powerpc_info;\n \n-  // The types of GOT entries needed for this platform.\n-  // These values are exposed to the ABI in an incremental link.\n-  // Do not renumber existing values without changing the version\n-  // number of the .gnu_incremental_inputs section.\n-  enum Got_type\n-  {\n-    GOT_TYPE_STANDARD,\n-    GOT_TYPE_TLSGD,\t// double entry for @got@tlsgd\n-    GOT_TYPE_DTPREL,\t// entry for @got@dtprel\n-    GOT_TYPE_TPREL\t// entry for @got@tprel\n-  };\n-\n-  // The GOT section.\n+  // The small GOT section used by ppc32, and by ppc64 for entries that\n+  // must be addresseed +/-32k from the got pointer.\n   Output_data_got_powerpc<size, big_endian>* got_;\n+  // Another GOT section used for entries that can be addressed +/- 2G\n+  // from the got pointer.\n+  Output_data_got_powerpc<size, big_endian>* biggot_;\n+\n   // The PLT section.  This is a container for a table of addresses,\n   // and their relocations.  Each address in the PLT has a dynamic\n   // relocation (R_*_JMP_SLOT) and each address will have a\n@@ -1931,7 +1947,7 @@ is_plt16_reloc(unsigned int r_type)\n \t  || (size == 64 && r_type == elfcpp::R_PPC64_PLT16_LO_DS));\n }\n \n-// GOT_TYPE_STANDARD (ie. not TLS) GOT relocs\n+// GOT_TYPE_STANDARD or GOT_TYPE_SMALL (ie. not TLS) GOT relocs\n inline bool\n is_got_reloc(unsigned int r_type)\n {\n@@ -2843,7 +2859,7 @@ Target_powerpc<size, big_endian>::do_define_standard_symbols(\n \t    static_cast<Target_powerpc<size, big_endian>*>(\n \t\tparameters->sized_target<size, big_endian>());\n \t  Output_data_got_powerpc<size, big_endian>* got\n-\t    = target->got_section(symtab, layout);\n+\t    = target->got_section(symtab, layout, GOT_TYPE_SMALL);\n \t  symtab->define_in_output_data(\"_GLOBAL_OFFSET_TABLE_\", NULL,\n \t\t\t\t\tSymbol_table::PREDEFINED,\n \t\t\t\t\tgot, 0, 0,\n@@ -2880,7 +2896,7 @@ Target_powerpc<size, big_endian>::do_define_standard_symbols(\n \t    static_cast<Target_powerpc<size, big_endian>*>(\n \t\tparameters->sized_target<size, big_endian>());\n \t  Output_data_got_powerpc<size, big_endian>* got\n-\t    = target->got_section(symtab, layout);\n+\t    = target->got_section(symtab, layout, GOT_TYPE_SMALL);\n \t  symtab->define_in_output_data(\".TOC.\", NULL,\n \t\t\t\t\tSymbol_table::PREDEFINED,\n \t\t\t\t\tgot, 0x8000, 0,\n@@ -2963,15 +2979,16 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n   typedef typename elfcpp::Elf_types<size>::Elf_Addr Valtype;\n   typedef Output_data_reloc<elfcpp::SHT_RELA, true, size, big_endian> Rela_dyn;\n \n-  Output_data_got_powerpc(Symbol_table* symtab, Layout* layout)\n+  Output_data_got_powerpc(Symbol_table* symtab, Layout* layout,\n+\t\t\t  Got_type got_type)\n     : Output_data_got<size, big_endian>(),\n       symtab_(symtab), layout_(layout),\n       header_ent_cnt_(size == 32 ? 3 : 1),\n       header_index_(size == 32 ? 0x2000 : -1u)\n   {\n     if (size == 64)\n       this->set_addralign(256);\n-    if (size == 64)\n+    if (size == 64 && (got_type & GOT_TYPE_SMALL))\n       this->make_header();\n   }\n \n@@ -3079,8 +3096,10 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n   {\n     if (size == 32)\n       return this->got_offset(this->header_index_);\n-    else\n+    else if (this->header_index_ != -1u)\n       return this->got_offset(this->header_index_) + 0x8000;\n+    else\n+      gold_unreachable();\n   }\n \n   // Ensure our GOT has a header.\n@@ -3098,12 +3117,15 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n   void\n   do_write(Output_file* of)\n   {\n-    Valtype val = 0;\n-    if (size == 32 && this->layout_->dynamic_data() != NULL)\n-      val = this->layout_->dynamic_section()->address();\n-    if (size == 64)\n-      val = this->address() + this->g_o_t();\n-    this->replace_constant(this->header_index_, val);\n+    if (this->header_index_ != -1u)\n+      {\n+\tValtype val = 0;\n+\tif (size == 32 && this->layout_->dynamic_data() != NULL)\n+\t  val = this->layout_->dynamic_section()->address();\n+\tif (size == 64)\n+\t  val = this->address() + this->g_o_t();\n+\tthis->replace_constant(this->header_index_, val);\n+      }\n     Output_data_got<size, big_endian>::do_write(of);\n   }\n \n@@ -3163,21 +3185,37 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n template<int size, bool big_endian>\n Output_data_got_powerpc<size, big_endian>*\n Target_powerpc<size, big_endian>::got_section(Symbol_table* symtab,\n-\t\t\t\t\t      Layout* layout)\n+\t\t\t\t\t      Layout* layout,\n+\t\t\t\t\t      Got_type got_type)\n {\n   if (this->got_ == NULL)\n     {\n       gold_assert(symtab != NULL && layout != NULL);\n \n       this->got_\n-\t= new Output_data_got_powerpc<size, big_endian>(symtab, layout);\n+\t= new Output_data_got_powerpc<size, big_endian>(symtab, layout,\n+\t\t\t\t\t\t\tGOT_TYPE_SMALL);\n \n       layout->add_output_section_data(\".got\", elfcpp::SHT_PROGBITS,\n \t\t\t\t      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,\n \t\t\t\t      this->got_, ORDER_DATA, false);\n     }\n \n-  return this->got_;\n+  if (size == 32 || (got_type & GOT_TYPE_SMALL))\n+    return this->got_;\n+\n+  if (this->biggot_ == NULL)\n+    {\n+      this->biggot_\n+\t= new Output_data_got_powerpc<size, big_endian>(symtab, layout,\n+\t\t\t\t\t\t\tGOT_TYPE_STANDARD);\n+\n+      layout->add_output_section_data(\".got\", elfcpp::SHT_PROGBITS,\n+\t\t\t\t      elfcpp::SHF_ALLOC | elfcpp::SHF_WRITE,\n+\t\t\t\t      this->biggot_, ORDER_DATA, false);\n+    }\n+\n+  return this->biggot_;\n }\n \n // Get the dynamic reloc section, creating it if necessary.\n@@ -4361,7 +4399,7 @@ Target_powerpc<size, big_endian>::make_plt_section(Symbol_table* symtab,\n   if (this->plt_ == NULL)\n     {\n       if (this->got_ == NULL)\n-\tthis->got_section(symtab, layout);\n+\tthis->got_section(symtab, layout, GOT_TYPE_SMALL);\n \n       if (this->glink_ == NULL)\n \tmake_glink_section(layout);\n@@ -7465,7 +7503,7 @@ Target_powerpc<size, big_endian>::tlsld_got_offset(\n       gold_assert(symtab != NULL && layout != NULL && object != NULL);\n       Reloc_section* rela_dyn = this->rela_dyn_section(layout);\n       Output_data_got_powerpc<size, big_endian>* got\n-\t= this->got_section(symtab, layout);\n+\t= this->got_section(symtab, layout, GOT_TYPE_SMALL);\n       unsigned int got_offset = got->add_constant_pair(0, 0);\n       rela_dyn->add_local(object, 0, elfcpp::R_POWERPC_DTPMOD, got,\n \t\t\t  got_offset, 0);\n@@ -7964,7 +8002,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_PPC64_TOC:\n       {\n \tOutput_data_got_powerpc<size, big_endian>* got\n-\t  = target->got_section(symtab, layout);\n+\t  = target->got_section(symtab, layout, GOT_TYPE_SMALL);\n \tif (parameters->options().output_is_position_independent())\n \t  {\n \t    Address off = reloc.get_r_offset();\n@@ -8160,26 +8198,30 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_PPC64_GOT16_LO_DS:\n       {\n \t// The symbol requires a GOT entry.\n+\tGot_type got_type = ((size == 32\n+\t\t\t      || r_type == elfcpp::R_POWERPC_GOT16\n+\t\t\t      || r_type == elfcpp::R_PPC64_GOT16_DS)\n+\t\t\t     ? GOT_TYPE_SMALL : GOT_TYPE_STANDARD);\n \tOutput_data_got_powerpc<size, big_endian>* got\n-\t  = target->got_section(symtab, layout);\n+\t  = target->got_section(symtab, layout, got_type);\n \tunsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n \tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \n \tif (!parameters->options().output_is_position_independent())\n \t  {\n \t    if (is_ifunc\n \t\t&& (size == 32 || target->abiversion() >= 2))\n-\t      got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD, addend);\n+\t      got->add_local_plt(object, r_sym, got_type, addend);\n \t    else\n-\t      got->add_local(object, r_sym, GOT_TYPE_STANDARD, addend);\n+\t      got->add_local(object, r_sym, got_type, addend);\n \t  }\n-\telse if (!object->local_has_got_offset(r_sym, GOT_TYPE_STANDARD, addend))\n+\telse if (!object->local_has_got_offset(r_sym, got_type, addend))\n \t  {\n \t    // If we are generating a shared object or a pie, this\n \t    // symbol's GOT entry will be set by a dynamic relocation.\n \t    unsigned int off;\n \t    off = got->add_constant(0);\n-\t    object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off, addend);\n+\t    object->set_local_got_offset(r_sym, got_type, off, addend);\n \n \t    Reloc_section* rela_dyn = target->rela_dyn_section(symtab, layout,\n \t\t\t\t\t\t\t       is_ifunc);\n@@ -8198,7 +8240,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_PPC64_TOC16_DS:\n     case elfcpp::R_PPC64_TOC16_LO_DS:\n       // We need a GOT section.\n-      target->got_section(symtab, layout);\n+      target->got_section(symtab, layout, GOT_TYPE_SMALL);\n       break;\n \n     case elfcpp::R_PPC64_GOT_TLSGD_PCREL34:\n@@ -8212,12 +8254,15 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t  tls_type = target->optimize_tls_gd(true);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n+\t    Got_type got_type = ((size == 32\n+\t\t\t\t  || r_type == elfcpp::R_POWERPC_GOT_TLSGD16)\n+\t\t\t\t ? GOT_TYPE_SMALL_TLSGD : GOT_TYPE_TLSGD);\n \t    Output_data_got_powerpc<size, big_endian>* got\n-\t      = target->got_section(symtab, layout);\n+\t      = target->got_section(symtab, layout, got_type);\n \t    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n \t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n-\t    got->add_local_tls_pair(object, r_sym, GOT_TYPE_TLSGD,\n+\t    got->add_local_tls_pair(object, r_sym, got_type,\n \t\t\t\t    rela_dyn, elfcpp::R_POWERPC_DTPMOD,\n \t\t\t\t    addend);\n \t  }\n@@ -8264,11 +8309,14 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_POWERPC_GOT_DTPREL16_HI:\n     case elfcpp::R_POWERPC_GOT_DTPREL16_HA:\n       {\n+\tGot_type got_type = ((size == 32\n+\t\t\t      || r_type == elfcpp::R_POWERPC_GOT_DTPREL16)\n+\t\t\t     ? GOT_TYPE_SMALL_DTPREL : GOT_TYPE_DTPREL);\n \tOutput_data_got_powerpc<size, big_endian>* got\n-\t  = target->got_section(symtab, layout);\n+\t  = target->got_section(symtab, layout, got_type);\n \tunsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n \tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n-\tgot->add_local_tls(object, r_sym, GOT_TYPE_DTPREL, addend);\n+\tgot->add_local_tls(object, r_sym, got_type, addend);\n       }\n       break;\n \n@@ -8283,12 +8331,15 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t  {\n \t    unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n \t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n-\t    if (!object->local_has_got_offset(r_sym, GOT_TYPE_TPREL, addend))\n+\t    Got_type got_type = ((size == 32\n+\t\t\t\t  || r_type == elfcpp::R_POWERPC_GOT_TPREL16)\n+\t\t\t\t ? GOT_TYPE_SMALL_TPREL : GOT_TYPE_TPREL);\n+\t    if (!object->local_has_got_offset(r_sym, got_type, addend))\n \t      {\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n-\t\t  = target->got_section(symtab, layout);\n+\t\t  = target->got_section(symtab, layout, got_type);\n \t\tunsigned int off = got->add_constant(0);\n-\t\tobject->set_local_got_offset(r_sym, GOT_TYPE_TPREL, off, addend);\n+\t\tobject->set_local_got_offset(r_sym, got_type, off, addend);\n \n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t\trela_dyn->add_symbolless_local_addend(object, r_sym,\n@@ -8679,7 +8730,7 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_PPC64_TOC:\n       {\n \tOutput_data_got_powerpc<size, big_endian>* got\n-\t  = target->got_section(symtab, layout);\n+\t  = target->got_section(symtab, layout, GOT_TYPE_SMALL);\n \tif (parameters->options().output_is_position_independent())\n \t  {\n \t    Address off = reloc.get_r_offset();\n@@ -8952,22 +9003,26 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t// The symbol requires a GOT entry.\n \tOutput_data_got_powerpc<size, big_endian>* got;\n \tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n+\tGot_type got_type = ((size == 32\n+\t\t\t      || r_type == elfcpp::R_POWERPC_GOT16\n+\t\t\t      || r_type == elfcpp::R_PPC64_GOT16_DS)\n+\t\t\t     ? GOT_TYPE_SMALL : GOT_TYPE_STANDARD);\n \n-\tgot = target->got_section(symtab, layout);\n+\tgot = target->got_section(symtab, layout, got_type);\n \tif (gsym->final_value_is_known())\n \t  {\n \t    if (is_ifunc\n \t\t&& (size == 32 || target->abiversion() >= 2))\n-\t      got->add_global_plt(gsym, GOT_TYPE_STANDARD, addend);\n+\t      got->add_global_plt(gsym, got_type, addend);\n \t    else\n-\t      got->add_global(gsym, GOT_TYPE_STANDARD, addend);\n+\t      got->add_global(gsym, got_type, addend);\n \t  }\n-\telse if (!gsym->has_got_offset(GOT_TYPE_STANDARD, addend))\n+\telse if (!gsym->has_got_offset(got_type, addend))\n \t  {\n \t    // If we are generating a shared object or a pie, this\n \t    // symbol's GOT entry will be set by a dynamic relocation.\n \t    unsigned int off = got->add_constant(0);\n-\t    gsym->set_got_offset(GOT_TYPE_STANDARD, off, addend);\n+\t    gsym->set_got_offset(got_type, off, addend);\n \n \t    Reloc_section* rela_dyn\n \t      = target->rela_dyn_section(symtab, layout, is_ifunc);\n@@ -8999,7 +9054,7 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_PPC64_TOC16_DS:\n     case elfcpp::R_PPC64_TOC16_LO_DS:\n       // We need a GOT section.\n-      target->got_section(symtab, layout);\n+      target->got_section(symtab, layout, GOT_TYPE_SMALL);\n       break;\n \n     case elfcpp::R_PPC64_GOT_TLSGD_PCREL34:\n@@ -9016,33 +9071,39 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t  }\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n+\t    Got_type got_type = ((size == 32\n+\t\t\t\t  || r_type == elfcpp::R_POWERPC_GOT_TLSGD16)\n+\t\t\t\t ? GOT_TYPE_SMALL_TLSGD : GOT_TYPE_TLSGD);\n \t    Output_data_got_powerpc<size, big_endian>* got\n-\t      = target->got_section(symtab, layout);\n+\t      = target->got_section(symtab, layout, got_type);\n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t    uint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n-\t    got->add_global_pair_with_rel(gsym, GOT_TYPE_TLSGD, rela_dyn,\n+\t    got->add_global_pair_with_rel(gsym, got_type, rela_dyn,\n \t\t\t\t\t  elfcpp::R_POWERPC_DTPMOD,\n \t\t\t\t\t  elfcpp::R_POWERPC_DTPREL,\n \t\t\t\t\t  addend);\n \t  }\n \telse if (tls_type == tls::TLSOPT_TO_IE)\n \t  {\n-\t    if (!gsym->has_got_offset(GOT_TYPE_TPREL))\n+\t    Got_type got_type = ((size == 32\n+\t\t\t\t  || r_type == elfcpp::R_POWERPC_GOT_TLSGD16)\n+\t\t\t\t ? GOT_TYPE_SMALL_TPREL : GOT_TYPE_TPREL);\n+\t    if (!gsym->has_got_offset(got_type))\n \t      {\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n-\t\t  = target->got_section(symtab, layout);\n+\t\t  = target->got_section(symtab, layout, got_type);\n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t\tif (gsym->is_undefined()\n \t\t    || gsym->is_from_dynobj())\n \t\t  {\n-\t\t    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,\n+\t\t    got->add_global_with_rel(gsym, got_type, rela_dyn,\n \t\t\t\t\t     elfcpp::R_POWERPC_TPREL, addend);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    unsigned int off = got->add_constant(0);\n-\t\t    gsym->set_got_offset(GOT_TYPE_TPREL, off);\n+\t\t    gsym->set_got_offset(got_type, off);\n \t\t    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;\n \t\t    rela_dyn->add_symbolless_global_addend(gsym, dynrel,\n \t\t\t\t\t\t\t   got, off, addend);\n@@ -9093,18 +9154,21 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_GOT_DTPREL16_HI:\n     case elfcpp::R_POWERPC_GOT_DTPREL16_HA:\n       {\n+\tGot_type got_type = ((size == 32\n+\t\t\t      || r_type == elfcpp::R_POWERPC_GOT_DTPREL16)\n+\t\t\t     ? GOT_TYPE_SMALL_DTPREL : GOT_TYPE_DTPREL);\n \tOutput_data_got_powerpc<size, big_endian>* got\n-\t  = target->got_section(symtab, layout);\n+\t  = target->got_section(symtab, layout, got_type);\n \tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \tif (!gsym->final_value_is_known()\n \t    && (gsym->is_from_dynobj()\n \t\t|| gsym->is_undefined()\n \t\t|| gsym->is_preemptible()))\n-\t  got->add_global_with_rel(gsym, GOT_TYPE_DTPREL,\n+\t  got->add_global_with_rel(gsym, got_type,\n \t\t\t\t   target->rela_dyn_section(layout),\n \t\t\t\t   elfcpp::R_POWERPC_DTPREL, addend);\n \telse\n-\t  got->add_global_tls(gsym, GOT_TYPE_DTPREL, addend);\n+\t  got->add_global_tls(gsym, got_type, addend);\n       }\n       break;\n \n@@ -9118,22 +9182,25 @@ Target_powerpc<size, big_endian>::Scan::global(\n \ttls::Tls_optimization tls_type = target->optimize_tls_ie(final);\n \tif (tls_type == tls::TLSOPT_NONE)\n \t  {\n-\t    if (!gsym->has_got_offset(GOT_TYPE_TPREL))\n+\t    Got_type got_type = ((size == 32\n+\t\t\t\t  || r_type == elfcpp::R_POWERPC_GOT_TPREL16)\n+\t\t\t\t ? GOT_TYPE_SMALL_TPREL : GOT_TYPE_TPREL);\n+\t    if (!gsym->has_got_offset(got_type))\n \t      {\n \t\tOutput_data_got_powerpc<size, big_endian>* got\n-\t\t  = target->got_section(symtab, layout);\n+\t\t  = target->got_section(symtab, layout, got_type);\n \t\tReloc_section* rela_dyn = target->rela_dyn_section(layout);\n \t\tuint64_t addend = size == 32 ? 0 : reloc.get_r_addend();\n \t\tif (gsym->is_undefined()\n \t\t    || gsym->is_from_dynobj())\n \t\t  {\n-\t\t    got->add_global_with_rel(gsym, GOT_TYPE_TPREL, rela_dyn,\n+\t\t    got->add_global_with_rel(gsym, got_type, rela_dyn,\n \t\t\t\t\t     elfcpp::R_POWERPC_TPREL, addend);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    unsigned int off = got->add_constant(0);\n-\t\t    gsym->set_got_offset(GOT_TYPE_TPREL, off);\n+\t\t    gsym->set_got_offset(got_type, off);\n \t\t    unsigned int dynrel = elfcpp::R_POWERPC_TPREL;\n \t\t    rela_dyn->add_symbolless_global_addend(gsym, dynrel,\n \t\t\t\t\t\t\t   got, off, addend);\n@@ -9791,22 +9858,35 @@ Target_powerpc<size, big_endian>::define_save_restore_funcs(\n template<bool big_endian>\n class Sort_toc_sections\n {\n+  const Output_section_data*\n+  small_got_section() const\n+  {\n+    return (static_cast<Target_powerpc<64, big_endian>*>(\n+\t\tparameters->sized_target<64, big_endian>())\n+\t    ->got_section(GOT_TYPE_SMALL));\n+  }\n+\n+  int\n+  rank(const Output_section::Input_section& isec) const\n+  {\n+    if (!isec.is_input_section())\n+      {\n+\tif (isec.output_section_data() == this->small_got_section())\n+\t  return 0;\n+\treturn 2;\n+      }\n+    if (static_cast<const Powerpc_relobj<64, big_endian>*>(isec.relobj())\n+\t->has_small_toc_reloc())\n+      return 1;\n+    return 3;\n+  }\n+\n  public:\n   bool\n   operator()(const Output_section::Input_section& is1,\n \t     const Output_section::Input_section& is2) const\n   {\n-    if (!is1.is_input_section() && is2.is_input_section())\n-      return true;\n-    bool small1\n-      = (is1.is_input_section()\n-\t && (static_cast<const Powerpc_relobj<64, big_endian>*>(is1.relobj())\n-\t     ->has_small_toc_reloc()));\n-    bool small2\n-      = (is2.is_input_section()\n-\t && (static_cast<const Powerpc_relobj<64, big_endian>*>(is2.relobj())\n-\t     ->has_small_toc_reloc()));\n-    return small1 && !small2;\n+    return rank(is1) < rank(is2);\n   }\n };\n \n@@ -9861,9 +9941,13 @@ Target_powerpc<size, big_endian>::do_finalize_sections(\n \t  // Annoyingly, we need to make these sections now whether or\n \t  // not we need them.  If we delay until do_relax then we\n \t  // need to mess with the relaxation machinery checkpointing.\n-\t  this->got_section(symtab, layout);\n+\t  this->got_section(symtab, layout, GOT_TYPE_STANDARD);\n \t  this->make_brlt_section(layout);\n \n+\t  // FIXME, maybe.  Here we could run through all the got\n+\t  // entries in the small got section, removing any duplicates\n+\t  // found in the big got section and renumbering offsets.\n+\n \t  if (parameters->options().toc_sort())\n \t    {\n \t      Output_section* os = this->got_->output_section();\n@@ -10632,14 +10716,18 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n   else if (is_got_reloc(r_type))\n     {\n       uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n+      Got_type got_type = ((size == 32\n+\t\t\t    || r_type == elfcpp::R_POWERPC_GOT16\n+\t\t\t    || r_type == elfcpp::R_PPC64_GOT16_DS)\n+\t\t\t   ? GOT_TYPE_SMALL : GOT_TYPE_STANDARD);\n       if (gsym != NULL)\n-\tvalue = gsym->got_offset(GOT_TYPE_STANDARD, addend);\n+\tvalue = gsym->got_offset(got_type, addend);\n       else\n-\tvalue = object->local_got_offset(r_sym, GOT_TYPE_STANDARD, addend);\n+\tvalue = object->local_got_offset(r_sym, got_type, addend);\n       if (r_type == elfcpp::R_PPC64_GOT_PCREL34)\n-\tvalue += target->got_section()->address();\n+\tvalue += target->got_section(got_type)->address();\n       else\n-\tvalue -= target->got_base_offset();\n+\tvalue -= target->got_base_offset(got_type);\n     }\n   else if (r_type == elfcpp::R_PPC64_TOC)\n     {\n@@ -10727,22 +10815,24 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  bool final = gsym == NULL || gsym->final_value_is_known();\n \t  tls_type = target->optimize_tls_gd(final);\n \t}\n-      enum Got_type got_type = GOT_TYPE_STANDARD;\n+      Got_type got_type = ((size == 32\n+\t\t\t    || r_type == elfcpp::R_POWERPC_GOT_TLSGD16)\n+\t\t\t   ? GOT_TYPE_SMALL : GOT_TYPE_STANDARD);\n       if (tls_type == tls::TLSOPT_NONE)\n-\tgot_type = GOT_TYPE_TLSGD;\n+\tgot_type = Got_type(got_type | GOT_TYPE_TLSGD);\n       else if (tls_type == tls::TLSOPT_TO_IE)\n-\tgot_type = GOT_TYPE_TPREL;\n-      if (got_type != GOT_TYPE_STANDARD)\n+\tgot_type = Got_type(got_type | GOT_TYPE_TPREL);\n+      if ((got_type & ~GOT_TYPE_SMALL) != GOT_TYPE_STANDARD)\n \t{\n \t  uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n \t  if (gsym != NULL)\n \t    value = gsym->got_offset(got_type, addend);\n \t  else\n \t    value = object->local_got_offset(r_sym, got_type, addend);\n \t  if (r_type == elfcpp::R_PPC64_GOT_TLSGD_PCREL34)\n-\t    value += target->got_section()->address();\n+\t    value += target->got_section(got_type)->address();\n \t  else\n-\t    value -= target->got_base_offset();\n+\t    value -= target->got_base_offset(got_type);\n \t}\n       if (tls_type == tls::TLSOPT_TO_IE)\n \t{\n@@ -10833,9 +10923,9 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t{\n \t  value = target->tlsld_got_offset();\n \t  if (r_type == elfcpp::R_PPC64_GOT_TLSLD_PCREL34)\n-\t    value += target->got_section()->address();\n+\t    value += target->got_section(GOT_TYPE_SMALL)->address();\n \t  else\n-\t    value -= target->got_base_offset();\n+\t    value -= target->got_base_offset(GOT_TYPE_SMALL);\n \t}\n       else\n \t{\n@@ -10886,14 +10976,17 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       // Accesses relative to a local dynamic sequence address,\n       // no optimisation here.\n       uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n+      Got_type got_type = ((size == 32\n+\t\t\t    || r_type == elfcpp::R_POWERPC_GOT_DTPREL16)\n+\t\t\t   ? GOT_TYPE_SMALL_DTPREL : GOT_TYPE_DTPREL);\n       if (gsym != NULL)\n-\tvalue = gsym->got_offset(GOT_TYPE_DTPREL, addend);\n+\tvalue = gsym->got_offset(got_type, addend);\n       else\n-\tvalue = object->local_got_offset(r_sym, GOT_TYPE_DTPREL, addend);\n+\tvalue = object->local_got_offset(r_sym, got_type, addend);\n       if (r_type == elfcpp::R_PPC64_GOT_DTPREL_PCREL34)\n-\tvalue += target->got_section()->address();\n+\tvalue += target->got_section(got_type)->address();\n       else\n-\tvalue -= target->got_base_offset();\n+\tvalue -= target->got_base_offset(got_type);\n     }\n   else if (r_type == elfcpp::R_POWERPC_GOT_TPREL16\n \t   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO\n@@ -10907,14 +11000,17 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       if (tls_type == tls::TLSOPT_NONE)\n \t{\n \t  uint64_t addend = size == 32 ? 0 : rela.get_r_addend();\n+\t  Got_type got_type = ((size == 32\n+\t\t\t\t|| r_type == elfcpp::R_POWERPC_GOT_TPREL16)\n+\t\t\t       ? GOT_TYPE_SMALL_TPREL : GOT_TYPE_TPREL);\n \t  if (gsym != NULL)\n-\t    value = gsym->got_offset(GOT_TYPE_TPREL, addend);\n+\t    value = gsym->got_offset(got_type, addend);\n \t  else\n-\t    value = object->local_got_offset(r_sym, GOT_TYPE_TPREL, addend);\n+\t    value = object->local_got_offset(r_sym, got_type, addend);\n \t  if (r_type == elfcpp::R_PPC64_GOT_TPREL_PCREL34)\n-\t    value += target->got_section()->address();\n+\t    value += target->got_section(got_type)->address();\n \t  else\n-\t    value -= target->got_base_offset();\n+\t    value -= target->got_base_offset(got_type);\n \t}\n       else\n \t{\n@@ -12745,25 +12841,29 @@ int64_t\n Target_powerpc<size, big_endian>::do_tls_offset_for_local(\n     const Relobj* object,\n     unsigned int symndx,\n+    Output_data_got_base* got,\n     unsigned int got_indx,\n     uint64_t addend) const\n {\n   const Powerpc_relobj<size, big_endian>* ppc_object\n     = static_cast<const Powerpc_relobj<size, big_endian>*>(object);\n   if (ppc_object->local_symbol(symndx)->is_tls_symbol())\n     {\n-      for (Got_type got_type = GOT_TYPE_TLSGD;\n-\t   got_type <= GOT_TYPE_TPREL;\n+      for (Got_type got_type = (size == 32\n+\t\t\t\t? GOT_TYPE_SMALL_TLSGD : GOT_TYPE_TLSGD);\n+\t   got_type <= GOT_TYPE_SMALL_TPREL;\n \t   got_type = Got_type(got_type + 1))\n-\tif (ppc_object->local_has_got_offset(symndx, got_type, addend))\n+\tif (got_type != GOT_TYPE_SMALL\n+\t    && ppc_object->local_has_got_offset(symndx, got_type, addend))\n \t  {\n \t    unsigned int off\n \t      = ppc_object->local_got_offset(symndx, got_type, addend);\n-\t    if (got_type == GOT_TYPE_TLSGD)\n+\t    if ((got_type & ~GOT_TYPE_SMALL) == GOT_TYPE_TLSGD)\n \t      off += size / 8;\n-\t    if (off == got_indx * (size / 8))\n+\t    if (off == got_indx * (size / 8)\n+\t\t&& (size == 32 || got == this->got_section(got_type)))\n \t      {\n-\t\tif (got_type == GOT_TYPE_TPREL)\n+\t\tif ((got_type & ~GOT_TYPE_SMALL) == GOT_TYPE_TPREL)\n \t\t  return -tp_offset;\n \t\telse\n \t\t  return -dtp_offset;\n@@ -12779,22 +12879,26 @@ template<int size, bool big_endian>\n int64_t\n Target_powerpc<size, big_endian>::do_tls_offset_for_global(\n     Symbol* gsym,\n+    Output_data_got_base* got,\n     unsigned int got_indx,\n     uint64_t addend) const\n {\n   if (gsym->type() == elfcpp::STT_TLS)\n     {\n-      for (Got_type got_type = GOT_TYPE_TLSGD;\n-\t   got_type <= GOT_TYPE_TPREL;\n+      for (Got_type got_type = (size == 32\n+\t\t\t\t? GOT_TYPE_SMALL_TLSGD : GOT_TYPE_TLSGD);\n+\t   got_type <= GOT_TYPE_SMALL_TPREL;\n \t   got_type = Got_type(got_type + 1))\n-\tif (gsym->has_got_offset(got_type, addend))\n+\tif (got_type != GOT_TYPE_SMALL\n+\t    && gsym->has_got_offset(got_type, addend))\n \t  {\n \t    unsigned int off = gsym->got_offset(got_type, addend);\n-\t    if (got_type == GOT_TYPE_TLSGD)\n+\t    if ((got_type & ~GOT_TYPE_SMALL) == GOT_TYPE_TLSGD)\n \t      off += size / 8;\n-\t    if (off == got_indx * (size / 8))\n+\t    if (off == got_indx * (size / 8)\n+\t\t&& (size == 32 || got == this->got_section(got_type)))\n \t      {\n-\t\tif (got_type == GOT_TYPE_TPREL)\n+\t\tif ((got_type & ~GOT_TYPE_SMALL) == GOT_TYPE_TPREL)\n \t\t  return -tp_offset;\n \t\telse\n \t\t  return -dtp_offset;"
    },
    {
      "sha": "a515f801c58846b7e6e61fd96e7d03733494d823",
      "filename": "gold/s390.cc",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/s390.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/s390.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/s390.cc?ref=f19c3684a6db145f57048bff5485fec6e3dd0f76",
      "patch": "@@ -401,13 +401,16 @@ class Target_s390 : public Sized_target<size, true>\n   int64_t\n   do_tls_offset_for_local(const Relobj* object,\n \t\t\t  unsigned int symndx,\n+\t\t\t  Output_data_got_base* got,\n \t\t\t  unsigned int got_indx,\n \t\t\t  uint64_t addend) const;\n \n   // Return the offset to use for the GOT_INDX'th got entry which is\n   // for global tls symbol GSYM.\n   int64_t\n-  do_tls_offset_for_global(Symbol* gsym, unsigned int got_indx,\n+  do_tls_offset_for_global(Symbol* gsym,\n+\t\t\t   Output_data_got_base* got,\n+\t\t\t   unsigned int got_indx,\n \t\t\t   uint64_t addend) const;\n \n   // This function should be defined in targets that can use relocation\n@@ -4220,6 +4223,7 @@ int64_t\n Target_s390<size>::do_tls_offset_for_local(\n     const Relobj*,\n     unsigned int,\n+    Output_data_got_base*,\n     unsigned int,\n     uint64_t) const\n {\n@@ -4235,6 +4239,7 @@ template<int size>\n int64_t\n Target_s390<size>::do_tls_offset_for_global(\n     Symbol*,\n+    Output_data_got_base*,\n     unsigned int,\n     uint64_t) const\n {"
    },
    {
      "sha": "b9a27d5a0d29ca36354e5971e99ccbdc584fe4df",
      "filename": "gold/target.h",
      "status": "modified",
      "additions": 10,
      "deletions": 5,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f19c3684a6db145f57048bff5485fec6e3dd0f76/gold/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/target.h?ref=f19c3684a6db145f57048bff5485fec6e3dd0f76",
      "patch": "@@ -289,16 +289,19 @@ class Target\n   int64_t\n   tls_offset_for_local(const Relobj* object,\n \t\t       unsigned int symndx,\n+\t\t       Output_data_got_base* got,\n \t\t       unsigned int got_indx,\n \t\t       uint64_t addend) const\n-  { return do_tls_offset_for_local(object, symndx, got_indx, addend); }\n+  { return do_tls_offset_for_local(object, symndx, got, got_indx, addend); }\n \n   // Return the offset to use for the GOT_INDX'th got entry which is\n   // for global tls symbol GSYM.\n   int64_t\n-  tls_offset_for_global(Symbol* gsym, unsigned int got_indx,\n+  tls_offset_for_global(Symbol* gsym,\n+\t\t\tOutput_data_got_base* got,\n+\t\t\tunsigned int got_indx,\n \t\t\tuint64_t addend) const\n-  { return do_tls_offset_for_global(gsym, got_indx, addend); }\n+  { return do_tls_offset_for_global(gsym, got, got_indx, addend); }\n \n   // For targets that use function descriptors, if LOC is the location\n   // of a function, modify it to point at the function entry location.\n@@ -650,12 +653,14 @@ class Target\n   { gold_unreachable(); }\n \n   virtual int64_t\n-  do_tls_offset_for_local(const Relobj*, unsigned int, unsigned int,\n+  do_tls_offset_for_local(const Relobj*, unsigned int,\n+\t\t\t  Output_data_got_base*, unsigned int,\n \t\t\t  uint64_t) const\n   { gold_unreachable(); }\n \n   virtual int64_t\n-  do_tls_offset_for_global(Symbol*, unsigned int, uint64_t) const\n+  do_tls_offset_for_global(Symbol*, Output_data_got_base*, unsigned int,\n+\t\t\t   uint64_t) const\n   { gold_unreachable(); }\n \n   virtual void"
    }
  ]
}