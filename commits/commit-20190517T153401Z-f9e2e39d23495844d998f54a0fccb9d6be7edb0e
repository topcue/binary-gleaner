{
  "sha": "f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjllMmUzOWQyMzQ5NTg0NGQ5OThmNTRhMGZjY2I5ZDZiZTdlZGIwZQ==",
  "commit": {
    "author": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-05-17T15:30:09Z"
    },
    "committer": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-05-17T15:34:01Z"
    },
    "message": "testsuite: Record all gdb input to gdb.in\n\nWhen debugging testsuite failures, it can be awkward parsing gdb.log to\nobtain all the commands run in order to manually re-run the test.\n\nThis patch adds the functionality to save all gdb commands to the file gdb.in\nwhen the testsuite is run. The file is saved in the directory for the test and\nif gdb is restarted then .1, .2, .3 etc is added to the filename.\n\nOnce a test has been run, the .in file can be used to re-run the test in the\nfollowing way:\n\n  gdb -x outputs/gdb.store/gdb.in outputs/gdb.store/store\n\nThe code works by intercepting send_gdb.  I've added a TYPE to ensure that any\ncommands that would destroy the playback are kept from the log (for example the\nY from an answer to a y/n question).\n\nAdds library function standard_output_file_with_gdb_instance to open a file\npostfixed with count of the gdb instance.  Ensure this count is reset when a new\n.exp script is run.\n\nI've re-run a random selection of .in files to check they do not error. Logs with\ncommands such as \"attach <pid>\" will not directly work when re-run.\n\ngdb/testsuite/ChangeLog:\n\n\t* lib/gdb.exp (gdb_unload): Mark Y as an answer.\n\t(delete_breakpoints): Likewise.\n\t(gdb_run_cmd): Likewise.\n\t(gdb_start_cmd): Likewise.\n\t(gdb_starti_cmd): Likewise.\n\t(gdb_internal_error_resync): Likewise.\n\t(gdb_test_multiple): Likewise.\n\t(gdb_reinitialize_dir): Likewise.\n\t(default_gdb_exit): Likewise.\n\t(gdb_file_cmd): Mark kill as optional.\n\t(default_gdb_start): Call gdb_stdin_log_init.\n\t(send_gdb): Call gdb_stdin_log_write.\n\t(rerun_to_main): Mark Y as an answer.\n\t(gdb_stdin_log_init): New function.\n\t(gdb_stdin_log_write): Likewise.",
    "tree": {
      "sha": "c35f247eab501c27d46d93fe2bc001899de68fdc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c35f247eab501c27d46d93fe2bc001899de68fdc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9e2e39d23495844d998f54a0fccb9d6be7edb0e/comments",
  "author": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "81f47ac29f8cdb888f2d81c5daa9bfc4747738aa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/81f47ac29f8cdb888f2d81c5daa9bfc4747738aa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/81f47ac29f8cdb888f2d81c5daa9bfc4747738aa"
    }
  ],
  "stats": {
    "total": 124,
    "additions": 106,
    "deletions": 18
  },
  "files": [
    {
      "sha": "b3cc028f82c5332b59850db50e446f086ac919e0",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f9e2e39d23495844d998f54a0fccb9d6be7edb0e/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f9e2e39d23495844d998f54a0fccb9d6be7edb0e/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
      "patch": "@@ -1,3 +1,21 @@\n+2019-05-17  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* lib/gdb.exp (gdb_unload): Mark Y as an answer.\n+\t(delete_breakpoints): Likewise.\n+\t(gdb_run_cmd): Likewise.\n+\t(gdb_start_cmd): Likewise.\n+\t(gdb_starti_cmd): Likewise.\n+\t(gdb_internal_error_resync): Likewise.\n+\t(gdb_test_multiple): Likewise.\n+\t(gdb_reinitialize_dir): Likewise.\n+\t(default_gdb_exit): Likewise.\n+\t(gdb_file_cmd): Mark kill as optional.\n+\t(default_gdb_start): Call gdb_stdin_log_init.\n+\t(send_gdb): Call gdb_stdin_log_write.\n+\t(rerun_to_main): Mark Y as an answer.\n+\t(gdb_stdin_log_init): New function.\n+\t(gdb_stdin_log_write): Likewise.\n+\n 2019-05-17  Alan Hayward  <alan.hayward@arm.com>\n \n \t* gdb.base/breakpoint-in-ro-region.exp: Disable when debugging."
    },
    {
      "sha": "d00f1cefd3366fe057e20d3468e880f27f7a6af5",
      "filename": "gdb/testsuite/lib/gdb.exp",
      "status": "modified",
      "additions": 88,
      "deletions": 18,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f9e2e39d23495844d998f54a0fccb9d6be7edb0e/gdb/testsuite/lib/gdb.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f9e2e39d23495844d998f54a0fccb9d6be7edb0e/gdb/testsuite/lib/gdb.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/gdb.exp?ref=f9e2e39d23495844d998f54a0fccb9d6be7edb0e",
      "patch": "@@ -167,11 +167,11 @@ proc gdb_unload {} {\n \t-re \"No executable file now\\[^\\r\\n\\]*\\[\\r\\n\\]\" { exp_continue }\n \t-re \"No symbol file now\\[^\\r\\n\\]*\\[\\r\\n\\]\" { exp_continue }\n \t-re \"A program is being debugged already.*Are you sure you want to change the file.*y or n. $\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-re \"Discard symbol table from .*y or n.*$\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-re \"$gdb_prompt $\" {}\n@@ -201,7 +201,7 @@ proc delete_breakpoints {} {\n     set deleted 0\n     gdb_test_multiple \"delete breakpoints\" \"$msg\" {\n \t-re \"Delete all breakpoints.*y or n.*$\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-re \"$gdb_prompt $\" {\n@@ -307,7 +307,7 @@ proc gdb_run_cmd {args} {\n \t\t    set start_attempt 0\n \t\t}\n \t\t-re \"Line.* Jump anyway.*y or n. $\" {\n-\t\t    send_gdb \"y\\n\"\n+\t\t    send_gdb \"y\\n\" answer\n \t\t}\n \t\t-re \"The program is not being run.*$gdb_prompt $\" {\n \t\t    if { [gdb_reload] != 0 } {\n@@ -335,7 +335,7 @@ proc gdb_run_cmd {args} {\n # may test for additional start-up messages.\n    gdb_expect 60 {\n \t-re \"The program .* has been started already.*y or n. $\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-notransfer -re \"Starting program: \\[^\\r\\n\\]*\" {}\n@@ -374,7 +374,7 @@ proc gdb_start_cmd {args} {\n     # may test for additional start-up messages.\n     gdb_expect 60 {\n \t-re \"The program .* has been started already.*y or n. $\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-notransfer -re \"Starting program: \\[^\\r\\n\\]*\" {\n@@ -411,7 +411,7 @@ proc gdb_starti_cmd {args} {\n     send_gdb \"starti $args\\n\"\n     gdb_expect 60 {\n \t-re \"The program .* has been started already.*y or n. $\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    exp_continue\n \t}\n \t-re \"Starting program: \\[^\\r\\n\\]*\" {\n@@ -673,11 +673,11 @@ proc gdb_internal_error_resync {} {\n     while {$count < 10} {\n \tgdb_expect {\n \t    -re \"Quit this debugging session\\\\? \\\\(y or n\\\\) $\" {\n-\t\tsend_gdb \"n\\n\"\n+\t\tsend_gdb \"n\\n\" answer\n \t\tincr count\n \t    }\n \t    -re \"Create a core file of GDB\\\\? \\\\(y or n\\\\) $\" {\n-\t\tsend_gdb \"n\\n\"\n+\t\tsend_gdb \"n\\n\" answer\n \t\tincr count\n \t    }\n \t    -re \"$gdb_prompt $\" {\n@@ -971,7 +971,7 @@ proc gdb_test_multiple { command message user_code } {\n \t    set result -1\n \t}\n \t-re \"\\\\((y or n|y or \\\\\\[n\\\\\\]|\\\\\\[y\\\\\\] or n)\\\\) \" {\n-\t    send_gdb \"n\\n\"\n+\t    send_gdb \"n\\n\" answer\n \t    gdb_expect -re \"$gdb_prompt $\"\n \t    fail \"$message (got interactive prompt)\"\n \t    set result -1\n@@ -1451,7 +1451,7 @@ proc gdb_reinitialize_dir { subdir } {\n     send_gdb \"dir\\n\"\n     gdb_expect 60 {\n \t-re \"Reinitialize source path to empty.*y or n. \" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    gdb_expect 60 {\n \t\t-re \"Source directories searched.*$gdb_prompt $\" {\n \t\t    send_gdb \"dir $subdir\\n\"\n@@ -1511,7 +1511,7 @@ proc default_gdb_exit {} {\n \tsend_gdb \"quit\\n\"\n \tgdb_expect 10 {\n \t    -re \"y or n\" {\n-\t\tsend_gdb \"y\\n\"\n+\t\tsend_gdb \"y\\n\" answer\n \t\texp_continue\n \t    }\n \t    -re \"DOSEXIT code\" { }\n@@ -1568,11 +1568,12 @@ proc gdb_file_cmd { arg } {\n     }\n \n     # The file command used to kill the remote target.  For the benefit\n-    # of the testsuite, preserve this behavior.\n-    send_gdb \"kill\\n\"\n+    # of the testsuite, preserve this behavior.  Mark as optional so it doesn't\n+    # get written to the stdin log.\n+    send_gdb \"kill\\n\" optional\n     gdb_expect 120 {\n \t-re \"Kill the program being debugged. .y or n. $\" {\n-\t    send_gdb \"y\\n\"\n+\t    send_gdb \"y\\n\" answer\n \t    verbose \"\\t\\tKilling previous program being debugged\"\n \t    exp_continue\n \t}\n@@ -1599,7 +1600,7 @@ proc gdb_file_cmd { arg } {\n \t    return 0\n         }\n         -re \"Load new symbol table from \\\".*\\\".*y or n. $\" {\n-            send_gdb \"y\\n\"\n+            send_gdb \"y\\n\" answer\n             gdb_expect 120 {\n                 -re \"Reading symbols from.*$gdb_prompt $\" {\n                     verbose \"\\t\\tLoaded $arg with new symbol table into $GDB\"\n@@ -1695,6 +1696,12 @@ proc default_gdb_start { } {\n \treturn 0\n     }\n \n+    # Keep track of the number of times GDB has been launched.\n+    global gdb_instances\n+    incr gdb_instances\n+\n+    gdb_stdin_log_init\n+\n     set res [gdb_spawn]\n     if { $res != 0} {\n \treturn $res\n@@ -3965,11 +3972,15 @@ proc gdb_compile_objc {source dest type options} {\n     }\n }\n \n-proc send_gdb { string } {\n+# Send a command to GDB.\n+# For options for TYPE see gdb_stdin_log_write\n+\n+proc send_gdb { string {type standard}} {\n     global suppress_flag\n     if { $suppress_flag } {\n \treturn \"suppressed\"\n     }\n+    gdb_stdin_log_write $string $type\n     return [remote_send host \"$string\"]\n }\n \n@@ -4635,6 +4646,20 @@ proc standard_output_file {basename} {\n     return [file join $dir $basename]\n }\n \n+# Turn BASENAME into a full file name in the standard output directory.  If\n+# GDB has been launched more than once then append the count, starting with\n+# a \".1\" postfix.\n+\n+proc standard_output_file_with_gdb_instance {basename} {\n+    global gdb_instances\n+    set count [expr $gdb_instances - 1 ]\n+\n+    if {$count == 0} {\n+      return [standard_output_file $basename]\n+    }\n+    return [standard_output_file ${basename}.${count}]\n+}\n+\n # Return the name of a file in our standard temporary directory.\n \n proc standard_temp_file {basename} {\n@@ -4829,6 +4854,10 @@ proc gdb_init { test_file_name } {\n     set gdbserver_reconnect_p 1\n     unset gdbserver_reconnect_p\n \n+    # Reset GDB number of instances\n+    global gdb_instances\n+    set gdb_instances 0\n+\n     return [default_gdb_init $test_file_name]\n }\n \n@@ -5097,7 +5126,7 @@ proc rerun_to_main {} {\n     send_gdb \"run\\n\"\n     gdb_expect {\n       -re \"The program .* has been started already.*y or n. $\" {\n-\t  send_gdb \"y\\n\"\n+\t  send_gdb \"y\\n\" answer\n \t  exp_continue\n       }\n       -re \"Starting program.*$gdb_prompt $\"\\\n@@ -6470,5 +6499,46 @@ proc gdbserver_debug_enabled { } {\n     return 0\n }\n \n+# Open the file for logging gdb input\n+\n+proc gdb_stdin_log_init { } {\n+    global in_file\n+\n+    if {[info exists in_file]} {\n+      # Close existing file.\n+      catch \"close $in_file\"\n+    }\n+\n+    set logfile [standard_output_file_with_gdb_instance gdb.in]\n+    set in_file [open $logfile w]\n+}\n+\n+# Write to the file for logging gdb input.\n+# TYPE can be one of the following:\n+# \"standard\" : Default. Standard message written to the log\n+# \"answer\" : Answer to a question (eg \"Y\"). Not written the log.\n+# \"optional\" : Optional message. Not written to the log.\n+\n+proc gdb_stdin_log_write { message {type standard} } {\n+\n+    global in_file\n+    if {![info exists in_file]} {\n+      return\n+    }\n+\n+    # Check message types.\n+    switch -regexp -- $type {\n+        \"answer\" {\n+            return\n+        }\n+        \"optional\" {\n+            return\n+        }\n+    }\n+\n+    #Write to the log\n+    puts -nonewline $in_file \"$message\"\n+}\n+\n # Always load compatibility stuff.\n load_lib future.exp"
    }
  ]
}