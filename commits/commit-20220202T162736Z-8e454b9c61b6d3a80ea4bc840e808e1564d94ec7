{
  "sha": "8e454b9c61b6d3a80ea4bc840e808e1564d94ec7",
  "node_id": "C_kwDOANOeidoAKDhlNDU0YjljNjFiNmQzYTgwZWE0YmM4NDBlODA4ZTE1NjRkOTRlYzc",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-07T13:25:47Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2022-02-02T16:27:36Z"
    },
    "message": "gdb: add empty string check in parse_linespec\n\nIf parse_linespec (linespec.c) is passed ARG as an empty string then\nwe end up calling `strchr (linespec_quote_characters, '\\0')`, which\nwill return a pointer to the '\\0' at the end of\nlinespec_quote_characters.  This then results in GDB calling\nskip_quote_char with `ARG + 1`, which is undefined behaviour (as ARG\nonly contained a single character, the '\\0').\n\nFix this by checking for the first character of ARG being '\\0' before\nthe call to strchr.\n\nI have additionally added an assertion that ARG can't itself be\nnullptr, as calling is_ada_operator with nullptr can end up calling\n'startswith' on the nullptr, which is undefined behaviour.\n\nFinally, I moved the declaration of TOKEN into the body of\nparse_linespec, to where TOKEN is defined.\n\nThis patch came about while I was working on fixes for PR cli/28665\nand PR gdb/28797.  The actual fixes for these two issues will be in a\nlater commit in this series, but, with this patch in place, both of\nthe above bugs would hit the new assertion rather than accessing\ninvalid memory and crashing.  The '\\0' check is not currently ever\nhit, but just makes the code a little safer.\n\nBecause this patch only changes the nature of the failure for the\nabove two bugs, there's no tests here.  A later commit will fix the\nabove two issues, at which point I'll add some tests.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28665\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28797",
    "tree": {
      "sha": "74459cf15a623c6cc50538565f0b9bf8b0e8a770",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/74459cf15a623c6cc50538565f0b9bf8b0e8a770"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "b6e05abee333e1cf322efac82bd7032c9d6b0add",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b6e05abee333e1cf322efac82bd7032c9d6b0add",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b6e05abee333e1cf322efac82bd7032c9d6b0add"
    }
  ],
  "stats": {
    "total": 14,
    "additions": 7,
    "deletions": 7
  },
  "files": [
    {
      "sha": "27ceaa41adbda021aadec6b0b91a288aa407752e",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8e454b9c61b6d3a80ea4bc840e808e1564d94ec7/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=8e454b9c61b6d3a80ea4bc840e808e1564d94ec7",
      "patch": "@@ -2522,14 +2522,15 @@ convert_explicit_location_to_sals (struct linespec_state *self,\n    if no file is validly specified.  Callers must check that.\n    Also, the line number returned may be invalid.  */\n \n-/* Parse the linespec in ARG.  MATCH_TYPE indicates how function names\n-   should be matched.  */\n+/* Parse the linespec in ARG, which must not be nullptr.  MATCH_TYPE\n+   indicates how function names should be matched.  */\n \n static std::vector<symtab_and_line>\n parse_linespec (linespec_parser *parser, const char *arg,\n \t\tsymbol_name_match_type match_type)\n {\n-  linespec_token token;\n+  gdb_assert (arg != nullptr);\n+\n   struct gdb_exception file_exception;\n \n   /* A special case to start.  It has become quite popular for\n@@ -2538,11 +2539,10 @@ parse_linespec (linespec_parser *parser, const char *arg,\n   parser->is_quote_enclosed = 0;\n   if (parser->completion_tracker == NULL\n       && !is_ada_operator (arg)\n+      && *arg != '\\0'\n       && strchr (linespec_quote_characters, *arg) != NULL)\n     {\n-      const char *end;\n-\n-      end = skip_quote_char (arg + 1, *arg);\n+      const char *end = skip_quote_char (arg + 1, *arg);\n       if (end != NULL && is_closing_quote_enclosed (end))\n \t{\n \t  /* Here's the special case.  Skip ARG past the initial\n@@ -2583,7 +2583,7 @@ parse_linespec (linespec_parser *parser, const char *arg,\n   /* Start parsing.  */\n \n   /* Get the first token.  */\n-  token = linespec_lexer_consume_token (parser);\n+  linespec_token token = linespec_lexer_consume_token (parser);\n \n   /* It must be either LSTOKEN_STRING or LSTOKEN_NUMBER.  */\n   if (token.type == LSTOKEN_STRING && *LS_TOKEN_STOKEN (token).ptr == '$')"
    }
  ]
}