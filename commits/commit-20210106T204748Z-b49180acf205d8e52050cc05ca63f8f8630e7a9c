{
  "sha": "b49180acf205d8e52050cc05ca63f8f8630e7a9c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjQ5MTgwYWNmMjA1ZDhlNTIwNTBjYzA1Y2E2M2Y4Zjg2MzBlN2E5Yw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-01-06T20:47:48Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-01-06T20:47:48Z"
    },
    "message": "Fix fixed-point binary operation type handling\n\nTesting showed that gdb was not correctly handling some fixed-point\nbinary operations correctly.\n\nAddition and subtraction worked by casting the result to the type of\nleft hand operand.  So, \"fixed+int\" had a different type -- and\ndifferent value -- from \"int+fixed\".\n\nFurthermore, for multiplication and division, it does not make sense\nto first cast both sides to the fixed-point type.  For example, this\ncan prevent \"f * 1\" from yielding \"f\", if 1 is not in the domain of\n\"f\".  Instead, this patch changes gdb to use the value.  (This is\nsomewhat different from Ada semantics, as those can yield a \"universal\nfixed point\".)\n\nThis includes a new test case.  It is only run in \"minimal\" mode, as\nthe old-style fixed point works differently, and is obsolete, so I\nhave no plans to change it.\n\ngdb/ChangeLog\n2021-01-06  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (ada_evaluate_subexp) <BINOP_ADD, BINOP_SUB>:\n\tDo not cast result.\n\t* valarith.c (fixed_point_binop): Handle multiplication\n\tand division specially.\n\t* valops.c (value_to_gdb_mpq): New function.\n\t(value_cast_to_fixed_point): Use it.\n\ngdb/testsuite/ChangeLog\n2021-01-06  Tom Tromey  <tromey@adacore.com>\n\n\t* gdb.ada/fixed_points/pck.ads (Delta4): New constant.\n\t(FP4_Type): New type.\n\t(FP4_Var): New variable.\n\t* gdb.ada/fixed_points/fixed_points.adb: Update.\n\t* gdb.ada/fixed_points.exp: Add tests for binary operators.",
    "tree": {
      "sha": "97f6648672f7c041a7648101da8ff96eaa119db7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/97f6648672f7c041a7648101da8ff96eaa119db7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b49180acf205d8e52050cc05ca63f8f8630e7a9c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b49180acf205d8e52050cc05ca63f8f8630e7a9c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b49180acf205d8e52050cc05ca63f8f8630e7a9c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b49180acf205d8e52050cc05ca63f8f8630e7a9c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3c55062cc1d8fdb6788164a55c1e4b773c781985",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c55062cc1d8fdb6788164a55c1e4b773c781985",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3c55062cc1d8fdb6788164a55c1e4b773c781985"
    }
  ],
  "stats": {
    "total": 212,
    "additions": 152,
    "deletions": 60
  },
  "files": [
    {
      "sha": "44dfabf62d43696c81dd84f606857882f3f637e0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -1,3 +1,12 @@\n+2021-01-06  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (ada_evaluate_subexp) <BINOP_ADD, BINOP_SUB>:\n+\tDo not cast result.\n+\t* valarith.c (fixed_point_binop): Handle multiplication\n+\tand division specially.\n+\t* valops.c (value_to_gdb_mpq): New function.\n+\t(value_cast_to_fixed_point): Use it.\n+\n 2021-01-05  Hannes Domani  <ssbssa@yahoo.de>\n \n \t* tui/tui-winsource.c (tui_source_window_base::refresh_window):"
    },
    {
      "sha": "3bc7bdd63880b620e5f72690f605e497f6a9b6b9",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 39,
      "deletions": 19,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -10195,18 +10195,28 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \treturn (value_from_longest\n \t\t (value_type (arg2),\n \t\t  value_as_long (arg1) + value_as_long (arg2)));\n-      if ((ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n-\t   || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\t  && value_type (arg1) != value_type (arg2))\n-\terror (_(\"Operands of fixed-point addition must have the same type\"));\n-      /* Do the addition, and cast the result to the type of the first\n-\t argument.  We cannot cast the result to a reference type, so if\n-\t ARG1 is a reference type, find its underlying type.  */\n+      /* Preserve the original type for use by the range case below.\n+\t We cannot cast the result to a reference type, so if ARG1 is\n+\t a reference type, find its underlying type.  */\n       type = value_type (arg1);\n       while (type->code () == TYPE_CODE_REF)\n \ttype = TYPE_TARGET_TYPE (type);\n-      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n-      return value_cast (type, value_binop (arg1, arg2, BINOP_ADD));\n+      if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n+\t  || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n+\t{\n+\t  if (value_type (arg1) != value_type (arg2))\n+\t    error (_(\"Operands of fixed-point addition must have the same type\"));\n+\t}\n+      else\n+\tbinop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n+      arg1 = value_binop (arg1, arg2, BINOP_ADD);\n+      /* We need to special-case the result of adding to a range.\n+\t This is done for the benefit of \"ptype\".  gdb's Ada support\n+\t historically used the LHS to set the result type here, so\n+\t preserve this behavior.  */\n+      if (type->code () == TYPE_CODE_RANGE)\n+\targ1 = value_cast (type, arg1);\n+      return arg1;\n \n     case BINOP_SUB:\n       arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n@@ -10221,19 +10231,29 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \treturn (value_from_longest\n \t\t (value_type (arg2),\n \t\t  value_as_long (arg1) - value_as_long (arg2)));\n-      if ((ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n-\t   || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\t  && value_type (arg1) != value_type (arg2))\n-\terror (_(\"Operands of fixed-point subtraction \"\n-\t\t \"must have the same type\"));\n-      /* Do the substraction, and cast the result to the type of the first\n-\t argument.  We cannot cast the result to a reference type, so if\n-\t ARG1 is a reference type, find its underlying type.  */\n+      /* Preserve the original type for use by the range case below.\n+\t We cannot cast the result to a reference type, so if ARG1 is\n+\t a reference type, find its underlying type.  */\n       type = value_type (arg1);\n       while (type->code () == TYPE_CODE_REF)\n \ttype = TYPE_TARGET_TYPE (type);\n-      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n-      return value_cast (type, value_binop (arg1, arg2, BINOP_SUB));\n+      if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n+\t  || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n+\t{\n+\t  if (value_type (arg1) != value_type (arg2))\n+\t    error (_(\"Operands of fixed-point subtraction \"\n+\t\t     \"must have the same type\"));\n+\t}\n+      else\n+\tbinop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n+      arg1 = value_binop (arg1, arg2, BINOP_SUB);\n+      /* We need to special-case the result of adding to a range.\n+\t This is done for the benefit of \"ptype\".  gdb's Ada support\n+\t historically used the LHS to set the result type here, so\n+\t preserve this behavior.  */\n+      if (type->code () == TYPE_CODE_RANGE)\n+\targ1 = value_cast (type, arg1);\n+      return arg1;\n \n     case BINOP_MUL:\n     case BINOP_DIV:"
    },
    {
      "sha": "8d5a2ee4599f707796c3e954a850f3f770f711cf",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -1,3 +1,11 @@\n+2021-01-06  Tom Tromey  <tromey@adacore.com>\n+\n+\t* gdb.ada/fixed_points/pck.ads (Delta4): New constant.\n+\t(FP4_Type): New type.\n+\t(FP4_Var): New variable.\n+\t* gdb.ada/fixed_points/fixed_points.adb: Update.\n+\t* gdb.ada/fixed_points.exp: Add tests for binary operators.\n+\n 2021-01-06  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* lib/gdb.exp (gdb_test_sequence): Accept -prompt switch."
    },
    {
      "sha": "0d24453497542d49fcaddba85f1ad724ecf41401",
      "filename": "gdb/testsuite/gdb.ada/fixed_points.exp",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points.exp?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -107,4 +107,21 @@ foreach_with_prefix scenario {all minimal} {\n \t    pass $gdb_test_name\n \t}\n     }\n+\n+    # One of the benefits of minimal encoding is that operations work\n+    # a bit better.\n+    if {$scenario == \"minimal\"} {\n+\tgdb_test \"print fp2_var + 0\" \\\n+\t    \" = -0.01\"\n+\tgdb_test \"print 0 + fp2_var\" \\\n+\t    \" = -0.01\"\n+\tgdb_test \"print fp2_var - 0\" \\\n+\t    \" = -0.01\"\n+\n+\tset fp4 \"= 2e-07\"\n+\tgdb_test \"print fp4_var\" $fp4\n+\tgdb_test \"print fp4_var * 1\" $fp4\n+\tgdb_test \"print 1 * fp4_var\" $fp4\n+\tgdb_test \"print fp4_var / 1\" $fp4\n+    }\n }"
    },
    {
      "sha": "cc2c637776133dd6d91cb7210172cee92d483f56",
      "filename": "gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -63,4 +63,5 @@ begin\n    Do_Nothing (FP1_Var'Address);\n    Do_Nothing (FP2_Var'Address);\n    Do_Nothing (FP3_Var'Address);\n+   Do_Nothing (FP4_Var'Address);\n end Fixed_Points;"
    },
    {
      "sha": "b5c1bc01c4484e1d956c0935bcdc1c025e213715",
      "filename": "gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/testsuite/gdb.ada/fixed_points/pck.ads",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points/pck.ads?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -25,6 +25,11 @@ package Pck is\n    type FP3_Type is delta 0.1 range 0.0 .. 1.0 with Small => 0.1/3.0;\n    FP3_Var : FP3_Type := 0.1;\n \n+   Delta4 : constant := 0.000_000_1;\n+   type FP4_Type is delta Delta4 range 0.0 .. Delta4 * 10\n+      with Small => Delta4 / 3.0;\n+   FP4_Var : FP4_Type := 2 * Delta4;\n+\n    procedure Do_Nothing (A : System.Address);\n end pck;\n "
    },
    {
      "sha": "81d48aae82a6603088b7e72cf6f68b907ac01644",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 30,
      "deletions": 16,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -903,27 +903,41 @@ fixed_point_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n   struct gdbarch *gdbarch = get_type_arch (type1);\n   struct value *val;\n \n+  gdb_mpq v1, v2, res;\n+\n   gdb_assert (is_fixed_point_type (type1) || is_fixed_point_type (type2));\n-  if (!is_fixed_point_type (type1))\n+  if (op == BINOP_MUL || op == BINOP_DIV)\n     {\n-      arg1 = value_cast (type2, arg1);\n-      type1 = type2;\n+      v1 = value_to_gdb_mpq (arg1);\n+      v2 = value_to_gdb_mpq (arg2);\n+\n+      /* The code below uses TYPE1 for the result type, so make sure\n+\t it is set properly.  */\n+      if (!is_fixed_point_type (type1))\n+\ttype1 = type2;\n     }\n-  if (!is_fixed_point_type (type2))\n+  else\n     {\n-      arg2 = value_cast (type1, arg2);\n-      type2 = type1;\n-    }\n+      if (!is_fixed_point_type (type1))\n+\t{\n+\t  arg1 = value_cast (type2, arg1);\n+\t  type1 = type2;\n+\t}\n+      if (!is_fixed_point_type (type2))\n+\t{\n+\t  arg2 = value_cast (type1, arg2);\n+\t  type2 = type1;\n+\t}\n \n-  gdb_mpq v1, v2, res;\n-  v1.read_fixed_point (gdb::make_array_view (value_contents (arg1),\n-\t\t\t\t\t     TYPE_LENGTH (type1)),\n-\t\t       type_byte_order (type1), type1->is_unsigned (),\n-\t\t       type1->fixed_point_scaling_factor ());\n-  v2.read_fixed_point (gdb::make_array_view (value_contents (arg2),\n-\t\t\t\t\t     TYPE_LENGTH (type2)),\n-\t\t       type_byte_order (type2), type2->is_unsigned (),\n-\t\t       type2->fixed_point_scaling_factor ());\n+      v1.read_fixed_point (gdb::make_array_view (value_contents (arg1),\n+\t\t\t\t\t\t TYPE_LENGTH (type1)),\n+\t\t\t   type_byte_order (type1), type1->is_unsigned (),\n+\t\t\t   type1->fixed_point_scaling_factor ());\n+      v2.read_fixed_point (gdb::make_array_view (value_contents (arg2),\n+\t\t\t\t\t\t TYPE_LENGTH (type2)),\n+\t\t\t   type_byte_order (type2), type2->is_unsigned (),\n+\t\t\t   type2->fixed_point_scaling_factor ());\n+    }\n \n   auto fixed_point_to_value = [type1] (const gdb_mpq &fp)\n     {"
    },
    {
      "sha": "6a9cbdce710d591475c8faad6428d6e64eff1e83",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 38,
      "deletions": 25,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -331,6 +331,39 @@ value_cast_pointers (struct type *type, struct value *arg2,\n   return arg2;\n }\n \n+/* See value.h.  */\n+\n+gdb_mpq\n+value_to_gdb_mpq (struct value *value)\n+{\n+  struct type *type = check_typedef (value_type (value));\n+\n+  gdb_mpq result;\n+  if (is_floating_type (type))\n+    {\n+      double d = target_float_to_host_double (value_contents (value),\n+\t\t\t\t\t      type);\n+      mpq_set_d (result.val, d);\n+    }\n+  else\n+    {\n+      gdb_assert (is_integral_type (type)\n+\t\t  || is_fixed_point_type (type));\n+\n+      gdb_mpz vz;\n+      vz.read (gdb::make_array_view (value_contents (value),\n+\t\t\t\t     TYPE_LENGTH (type)),\n+\t       type_byte_order (type), type->is_unsigned ());\n+      mpq_set_z (result.val, vz.val);\n+\n+      if (is_fixed_point_type (type))\n+\tmpq_mul (result.val, result.val,\n+\t\t type->fixed_point_scaling_factor ().val);\n+    }\n+\n+  return result;\n+}\n+\n /* Assuming that TO_TYPE is a fixed point type, return a value\n    corresponding to the cast of FROM_VAL to that type.  */\n \n@@ -342,34 +375,14 @@ value_cast_to_fixed_point (struct type *to_type, struct value *from_val)\n   if (from_type == to_type)\n     return from_val;\n \n-  gdb_mpq vq;\n-\n-  /* Extract the value as a rational number.  */\n-\n-  if (is_floating_type (from_type))\n-    {\n-      double d = target_float_to_host_double (value_contents (from_val),\n-\t\t\t\t\t      from_type);\n-      mpq_set_d (vq.val, d);\n-    }\n-\n-  else if (is_integral_type (from_type) || is_fixed_point_type (from_type))\n-    {\n-      gdb_mpz vz;\n-\n-      vz.read (gdb::make_array_view (value_contents (from_val),\n-\t\t\t\t     TYPE_LENGTH (from_type)),\n-\t       type_byte_order (from_type), from_type->is_unsigned ());\n-      mpq_set_z (vq.val, vz.val);\n-\n-      if (is_fixed_point_type (from_type))\n-\tmpq_mul (vq.val, vq.val, from_type->fixed_point_scaling_factor ().val);\n-    }\n-\n-  else\n+  if (!is_floating_type (from_type)\n+      && !is_integral_type (from_type)\n+      && !is_fixed_point_type (from_type))\n     error (_(\"Invalid conversion from type %s to fixed point type %s\"),\n \t   from_type->name (), to_type->name ());\n \n+  gdb_mpq vq = value_to_gdb_mpq (from_val);\n+\n   /* Divide that value by the scaling factor to obtain the unscaled\n      value, first in rational form, and then in integer form.  */\n "
    },
    {
      "sha": "39e94f45ea600a098f8510ea35cd79a53889fc9b",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b49180acf205d8e52050cc05ca63f8f8630e7a9c/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=b49180acf205d8e52050cc05ca63f8f8630e7a9c",
      "patch": "@@ -23,6 +23,7 @@\n #include \"frame.h\"\t\t/* For struct frame_id.  */\n #include \"extension.h\"\n #include \"gdbsupport/gdb_ref_ptr.h\"\n+#include \"gmp-utils.h\"\n \n struct block;\n struct expression;\n@@ -1222,4 +1223,8 @@ extern struct value *call_xmethod (struct value *method,\n    exiting (e.g., on quit_force).  */\n extern void finalize_values ();\n \n+/* Convert VALUE to a gdb_mpq.  The caller must ensure that VALUE is\n+   of floating-point, fixed-point, or integer type.  */\n+extern gdb_mpq value_to_gdb_mpq (struct value *value);\n+\n #endif /* !defined (VALUE_H) */"
    }
  ]
}