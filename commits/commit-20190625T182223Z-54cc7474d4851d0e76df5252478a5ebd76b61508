{
  "sha": "54cc7474d4851d0e76df5252478a5ebd76b61508",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTRjYzc0NzRkNDg1MWQwZTc2ZGY1MjUyNDc4YTVlYmQ3NmI2MTUwOA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2019-06-25T18:22:23Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2019-06-25T18:22:23Z"
    },
    "message": "arm-tdep: replace arm_mapping_symbol VEC with std::vector\n\nThis patch replaces VEC (arm_mapping_symbol) with an std::vector.  No\nfunctional changes intended.\n\ngdb/ChangeLog:\n\n\t* arm-tdep.c (struct arm_mapping_symbol) (operator <): New.\n\t(arm_mapping_symbol_s): Remove.\n\t(DEF_VEC_O(arm_mapping_symbol_s)): Remove.\n\t(arm_mapping_symbol_vec): New typedef.\n\t(struct arm_per_objfile): Add constructor.\n\t<section_maps>: Change type to\n\tstd::unique_ptr<arm_mapping_symbol_vec[]>.\n\t(arm_compare_mapping_symbols): Remove.\n\t(arm_find_mapping_symbol): Adjust to section_maps type change.\n\t(arm_objfile_data_free): Call delete on arm_per_objfile.\n\t(arm_record_special_symbol): Adjust to section_maps type change.\n\tAllocate arm_per_objfile with new.",
    "tree": {
      "sha": "a315627649e92cd9faf11ed049faef6a4290522f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a315627649e92cd9faf11ed049faef6a4290522f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/54cc7474d4851d0e76df5252478a5ebd76b61508",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54cc7474d4851d0e76df5252478a5ebd76b61508",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/54cc7474d4851d0e76df5252478a5ebd76b61508",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/54cc7474d4851d0e76df5252478a5ebd76b61508/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b65b566cdcb577edb57616c5b49a2f245b56325c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b65b566cdcb577edb57616c5b49a2f245b56325c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b65b566cdcb577edb57616c5b49a2f245b56325c"
    }
  ],
  "stats": {
    "total": 142,
    "additions": 70,
    "deletions": 72
  },
  "files": [
    {
      "sha": "2a26db0bc2651660fe6f520011d8240c47a691c6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54cc7474d4851d0e76df5252478a5ebd76b61508/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54cc7474d4851d0e76df5252478a5ebd76b61508/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=54cc7474d4851d0e76df5252478a5ebd76b61508",
      "patch": "@@ -1,3 +1,18 @@\n+2019-06-25  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* arm-tdep.c (struct arm_mapping_symbol) (operator <): New.\n+\t(arm_mapping_symbol_s): Remove.\n+\t(DEF_VEC_O(arm_mapping_symbol_s)): Remove.\n+\t(arm_mapping_symbol_vec): New typedef.\n+\t(struct arm_per_objfile): Add constructor.\n+\t<section_maps>: Change type to\n+\tstd::unique_ptr<arm_mapping_symbol_vec[]>.\n+\t(arm_compare_mapping_symbols): Remove.\n+\t(arm_find_mapping_symbol): Adjust to section_maps type change.\n+\t(arm_objfile_data_free): Call delete on arm_per_objfile.\n+\t(arm_record_special_symbol): Adjust to section_maps type change.\n+\tAllocate arm_per_objfile with new.\n+\n 2019-06-25  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n \n \t* cli/cli-cmds.c (alias_command): Compare the alias prefix"
    },
    {
      "sha": "bbf9a43139e71b91884104296ae12b4b15b29ceb",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 55,
      "deletions": 72,
      "changes": 127,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/54cc7474d4851d0e76df5252478a5ebd76b61508/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/54cc7474d4851d0e76df5252478a5ebd76b61508/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=54cc7474d4851d0e76df5252478a5ebd76b61508",
      "patch": "@@ -95,13 +95,30 @@ struct arm_mapping_symbol\n {\n   bfd_vma value;\n   char type;\n+\n+  bool operator< (const arm_mapping_symbol &other) const\n+  { return this->value < other.value; }\n };\n-typedef struct arm_mapping_symbol arm_mapping_symbol_s;\n-DEF_VEC_O(arm_mapping_symbol_s);\n+\n+typedef std::vector<arm_mapping_symbol> arm_mapping_symbol_vec;\n \n struct arm_per_objfile\n {\n-  VEC(arm_mapping_symbol_s) **section_maps;\n+  explicit arm_per_objfile (size_t num_sections)\n+  : section_maps (new arm_mapping_symbol_vec[num_sections])\n+  {}\n+\n+  DISABLE_COPY_AND_ASSIGN (arm_per_objfile);\n+\n+  /* Information about mapping symbols ($a, $d, $t) in the objfile.\n+\n+     The format is an array of vectors of arm_mapping_symbols, there is one\n+     vector for each section of the objfile (the array is index by BFD section\n+     index).\n+\n+     For each section, the vector of arm_mapping_symbol is sorted by\n+     symbol value (address).  */\n+  std::unique_ptr<arm_mapping_symbol_vec[]> section_maps;\n };\n \n /* The list of available \"set arm ...\" and \"show arm ...\" commands.  */\n@@ -321,15 +338,6 @@ arm_frame_is_thumb (struct frame_info *frame)\n   return (cpsr & t_bit) != 0;\n }\n \n-/* Callback for VEC_lower_bound.  */\n-\n-static inline int\n-arm_compare_mapping_symbols (const struct arm_mapping_symbol *lhs,\n-\t\t\t     const struct arm_mapping_symbol *rhs)\n-{\n-  return lhs->value < rhs->value;\n-}\n-\n /* Search for the mapping symbol covering MEMADDR.  If one is found,\n    return its type.  Otherwise, return 0.  If START is non-NULL,\n    set *START to the location of the mapping symbol.  */\n@@ -343,47 +351,41 @@ arm_find_mapping_symbol (CORE_ADDR memaddr, CORE_ADDR *start)\n   sec = find_pc_section (memaddr);\n   if (sec != NULL)\n     {\n-      struct arm_per_objfile *data;\n-      VEC(arm_mapping_symbol_s) *map;\n-      struct arm_mapping_symbol map_key = { memaddr - obj_section_addr (sec),\n-\t\t\t\t\t    0 };\n-      unsigned int idx;\n-\n-      data = (struct arm_per_objfile *) objfile_data (sec->objfile,\n-\t\t\t\t\t\t      arm_objfile_data_key);\n+      arm_per_objfile *data\n+\t= (struct arm_per_objfile *) objfile_data (sec->objfile,\n+\t\t\t\t\t\t   arm_objfile_data_key);\n       if (data != NULL)\n \t{\n-\t  map = data->section_maps[sec->the_bfd_section->index];\n-\t  if (!VEC_empty (arm_mapping_symbol_s, map))\n+\t  struct arm_mapping_symbol map_key\n+\t    = { memaddr - obj_section_addr (sec), 0 };\n+\t  const arm_mapping_symbol_vec &map\n+\t    = data->section_maps[sec->the_bfd_section->index];\n+\t  arm_mapping_symbol_vec::const_iterator it\n+\t    = std::lower_bound (map.begin (), map.end (), map_key);\n+\n+\t  /* std::lower_bound finds the earliest ordered insertion\n+\t     point.  If the symbol at this position starts at this exact\n+\t     address, we use that; otherwise, the preceding\n+\t     mapping symbol covers this address.  */\n+\t  if (it < map.end ())\n \t    {\n-\t      struct arm_mapping_symbol *map_sym;\n-\n-\t      idx = VEC_lower_bound (arm_mapping_symbol_s, map, &map_key,\n-\t\t\t\t     arm_compare_mapping_symbols);\n-\n-\t      /* VEC_lower_bound finds the earliest ordered insertion\n-\t\t point.  If the following symbol starts at this exact\n-\t\t address, we use that; otherwise, the preceding\n-\t\t mapping symbol covers this address.  */\n-\t      if (idx < VEC_length (arm_mapping_symbol_s, map))\n+\t      if (it->value == map_key.value)\n \t\t{\n-\t\t  map_sym = VEC_index (arm_mapping_symbol_s, map, idx);\n-\t\t  if (map_sym->value == map_key.value)\n-\t\t    {\n-\t\t      if (start)\n-\t\t\t*start = map_sym->value + obj_section_addr (sec);\n-\t\t      return map_sym->type;\n-\t\t    }\n-\t\t}\n-\n-\t      if (idx > 0)\n-\t\t{\n-\t\t  map_sym = VEC_index (arm_mapping_symbol_s, map, idx - 1);\n \t\t  if (start)\n-\t\t    *start = map_sym->value + obj_section_addr (sec);\n-\t\t  return map_sym->type;\n+\t\t    *start = it->value + obj_section_addr (sec);\n+\t\t  return it->type;\n \t\t}\n \t    }\n+\n+\t  if (it > map.begin ())\n+\t    {\n+\t      arm_mapping_symbol_vec::const_iterator prev_it\n+\t\t= it - 1;\n+\n+\t      if (start)\n+\t\t*start = prev_it->value + obj_section_addr (sec);\n+\t      return prev_it->type;\n+\t    }\n \t}\n     }\n \n@@ -8516,10 +8518,8 @@ static void\n arm_objfile_data_free (struct objfile *objfile, void *arg)\n {\n   struct arm_per_objfile *data = (struct arm_per_objfile *) arg;\n-  unsigned int i;\n \n-  for (i = 0; i < objfile->obfd->section_count; i++)\n-    VEC_free (arm_mapping_symbol_s, data->section_maps[i]);\n+  delete data;\n }\n \n static void\n@@ -8528,7 +8528,6 @@ arm_record_special_symbol (struct gdbarch *gdbarch, struct objfile *objfile,\n {\n   const char *name = bfd_asymbol_name (sym);\n   struct arm_per_objfile *data;\n-  VEC(arm_mapping_symbol_s) **map_p;\n   struct arm_mapping_symbol new_map_sym;\n \n   gdb_assert (name[0] == '$');\n@@ -8539,37 +8538,21 @@ arm_record_special_symbol (struct gdbarch *gdbarch, struct objfile *objfile,\n \t\t\t\t\t\t  arm_objfile_data_key);\n   if (data == NULL)\n     {\n-      data = OBSTACK_ZALLOC (&objfile->objfile_obstack,\n-\t\t\t     struct arm_per_objfile);\n+      data = new arm_per_objfile (objfile->obfd->section_count);\n       set_objfile_data (objfile, arm_objfile_data_key, data);\n-      data->section_maps = OBSTACK_CALLOC (&objfile->objfile_obstack,\n-\t\t\t\t\t   objfile->obfd->section_count,\n-\t\t\t\t\t   VEC(arm_mapping_symbol_s) *);\n     }\n-  map_p = &data->section_maps[bfd_get_section (sym)->index];\n+  arm_mapping_symbol_vec &map\n+    = data->section_maps[bfd_get_section (sym)->index];\n \n   new_map_sym.value = sym->value;\n   new_map_sym.type = name[1];\n \n   /* Assume that most mapping symbols appear in order of increasing\n      value.  If they were randomly distributed, it would be faster to\n      always push here and then sort at first use.  */\n-  if (!VEC_empty (arm_mapping_symbol_s, *map_p))\n-    {\n-      struct arm_mapping_symbol *prev_map_sym;\n-\n-      prev_map_sym = VEC_last (arm_mapping_symbol_s, *map_p);\n-      if (prev_map_sym->value >= sym->value)\n-\t{\n-\t  unsigned int idx;\n-\t  idx = VEC_lower_bound (arm_mapping_symbol_s, *map_p, &new_map_sym,\n-\t\t\t\t arm_compare_mapping_symbols);\n-\t  VEC_safe_insert (arm_mapping_symbol_s, *map_p, idx, &new_map_sym);\n-\t  return;\n-\t}\n-    }\n-\n-  VEC_safe_push (arm_mapping_symbol_s, *map_p, &new_map_sym);\n+  arm_mapping_symbol_vec::iterator it\n+    = std::lower_bound (map.begin (), map.end (), new_map_sym);\n+  map.insert (it, new_map_sym);\n }\n \n static void"
    }
  ]
}