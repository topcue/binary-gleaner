{
  "sha": "1e735120b95236b1f0fd8c383e64b02b64909d7c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWU3MzUxMjBiOTUyMzZiMWYwZmQ4YzM4M2U2NGIwMmI2NDkwOWQ3Yw==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T17:24:53Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:54:50Z"
    },
    "message": "Refactor parsing of /proc/<pid>/smaps\n\nThe Linux kernel exposes the information about MTE-protected pages via the\nproc filesystem, more specifically through the smaps file.\n\nWhat we're looking for is a mapping with the 'mt' flag, which tells us that\nmapping was created with a PROT_MTE flag and, thus, is capable of using memory\ntagging.\n\nWe already parse that file for other purposes (core file\ngeneration/filtering), so this patch refactors the code to make the parsing\nof the smaps file reusable for memory tagging.\n\nThe function linux_address_in_memtag_page uses the refactored code to allow\nquerying for memory tag support in a particular address, and it gets used in the\nnext patch.\n\ngdb/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* linux-tdep.c (struct smaps_vmflags) <memory_tagging>: New flag\n\tbit.\n\t(struct smaps_data): New struct.\n\t(decode_vmflags): Handle the 'mt' flag.\n\t(parse_smaps_data): New function, refactored from\n\tlinux_find_memory_regions_full.\n\t(linux_address_in_memtag_page): New function.\n\t(linux_find_memory_regions_full): Refactor into parse_smaps_data.\n\t* linux-tdep.h (linux_address_in_memtag_page): New prototype.",
    "tree": {
      "sha": "9db3580d29028767a59b98cb49c7d2cb142e704d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9db3580d29028767a59b98cb49c7d2cb142e704d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1e735120b95236b1f0fd8c383e64b02b64909d7c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e735120b95236b1f0fd8c383e64b02b64909d7c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1e735120b95236b1f0fd8c383e64b02b64909d7c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e735120b95236b1f0fd8c383e64b02b64909d7c/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "93e447c605e549f183681ed60e729d3d50f4d113",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/93e447c605e549f183681ed60e729d3d50f4d113",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/93e447c605e549f183681ed60e729d3d50f4d113"
    }
  ],
  "stats": {
    "total": 373,
    "additions": 251,
    "deletions": 122
  },
  "files": [
    {
      "sha": "9d155b8f5e57adfe90cea1045b5b8733375f68ae",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1e735120b95236b1f0fd8c383e64b02b64909d7c",
      "patch": "@@ -1,3 +1,15 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* linux-tdep.c (struct smaps_vmflags) <memory_tagging>: New flag\n+\tbit.\n+\t(struct smaps_data): New struct.\n+\t(decode_vmflags): Handle the 'mt' flag.\n+\t(parse_smaps_data): New function, refactored from\n+\tlinux_find_memory_regions_full.\n+\t(linux_address_in_memtag_page): New function.\n+\t(linux_find_memory_regions_full): Refactor into parse_smaps_data.\n+\t* linux-tdep.h (linux_address_in_memtag_page): New prototype.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* linux-tdep.c (linux_find_memory_regions_full): Use std::string"
    },
    {
      "sha": "38c5ecf5b593975b14069370aa6832616f862cb4",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 235,
      "deletions": 122,
      "changes": 357,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=1e735120b95236b1f0fd8c383e64b02b64909d7c",
      "patch": "@@ -88,8 +88,33 @@ struct smaps_vmflags\n     /* Is this a MAP_SHARED mapping (VM_SHARED, \"sh\").  */\n \n     unsigned int shared_mapping : 1;\n+\n+    /* Memory map has memory tagging enabled.  */\n+\n+    unsigned int memory_tagging : 1;\n   };\n \n+/* Data structure that holds the information contained in the\n+   /proc/<pid>/smaps file.  */\n+\n+struct smaps_data\n+{\n+  ULONGEST start_address;\n+  ULONGEST end_address;\n+  std::string filename;\n+  struct smaps_vmflags vmflags;\n+  bool read;\n+  bool write;\n+  bool exec;\n+  bool priv;\n+  bool has_anonymous;\n+  bool mapping_anon_p;\n+  bool mapping_file_p;\n+\n+  ULONGEST inode;\n+  ULONGEST offset;\n+};\n+\n /* Whether to take the /proc/PID/coredump_filter into account when\n    generating a corefile.  */\n \n@@ -476,6 +501,8 @@ decode_vmflags (char *p, struct smaps_vmflags *v)\n \tv->exclude_coredump = 1;\n       else if (strcmp (s, \"sh\") == 0)\n \tv->shared_mapping = 1;\n+      else if (strcmp (s, \"mt\") == 0)\n+\tv->memory_tagging = 1;\n     }\n }\n \n@@ -1271,6 +1298,180 @@ typedef int linux_dump_mapping_p_ftype (filter_flags filterflags,\n \t\t\t\t\tULONGEST addr,\n \t\t\t\t\tULONGEST offset);\n \n+/* Helper function to parse the contents of /proc/<pid>/smaps into a data\n+   structure, for easy access.\n+\n+   DATA is the contents of the smaps file.  The parsed contents are stored\n+   into the SMAPS vector.  */\n+\n+static std::vector<struct smaps_data>\n+parse_smaps_data (const char *data,\n+\t\t  const std::string maps_filename)\n+{\n+  char *line, *t;\n+\n+  gdb_assert (data != nullptr);\n+\n+  line = strtok_r ((char *) data, \"\\n\", &t);\n+\n+  std::vector<struct smaps_data> smaps;\n+\n+  while (line != NULL)\n+    {\n+      ULONGEST addr, endaddr, offset, inode;\n+      const char *permissions, *device, *filename;\n+      struct smaps_vmflags v;\n+      size_t permissions_len, device_len;\n+      int read, write, exec, priv;\n+      int has_anonymous = 0;\n+      int mapping_anon_p;\n+      int mapping_file_p;\n+\n+      memset (&v, 0, sizeof (v));\n+      read_mapping (line, &addr, &endaddr, &permissions, &permissions_len,\n+\t\t    &offset, &device, &device_len, &inode, &filename);\n+      mapping_anon_p = mapping_is_anonymous_p (filename);\n+      /* If the mapping is not anonymous, then we can consider it\n+\t to be file-backed.  These two states (anonymous or\n+\t file-backed) seem to be exclusive, but they can actually\n+\t coexist.  For example, if a file-backed mapping has\n+\t \"Anonymous:\" pages (see more below), then the Linux\n+\t kernel will dump this mapping when the user specified\n+\t that she only wants anonymous mappings in the corefile\n+\t (*even* when she explicitly disabled the dumping of\n+\t file-backed mappings).  */\n+      mapping_file_p = !mapping_anon_p;\n+\n+      /* Decode permissions.  */\n+      read = (memchr (permissions, 'r', permissions_len) != 0);\n+      write = (memchr (permissions, 'w', permissions_len) != 0);\n+      exec = (memchr (permissions, 'x', permissions_len) != 0);\n+      /* 'private' here actually means VM_MAYSHARE, and not\n+\t VM_SHARED.  In order to know if a mapping is really\n+\t private or not, we must check the flag \"sh\" in the\n+\t VmFlags field.  This is done by decode_vmflags.  However,\n+\t if we are using a Linux kernel released before the commit\n+\t 834f82e2aa9a8ede94b17b656329f850c1471514 (3.10), we will\n+\t not have the VmFlags there.  In this case, there is\n+\t really no way to know if we are dealing with VM_SHARED,\n+\t so we just assume that VM_MAYSHARE is enough.  */\n+      priv = memchr (permissions, 'p', permissions_len) != 0;\n+\n+      /* Try to detect if region should be dumped by parsing smaps\n+\t counters.  */\n+      for (line = strtok_r (NULL, \"\\n\", &t);\n+\t   line != NULL && line[0] >= 'A' && line[0] <= 'Z';\n+\t   line = strtok_r (NULL, \"\\n\", &t))\n+\t{\n+\t  char keyword[64 + 1];\n+\n+\t  if (sscanf (line, \"%64s\", keyword) != 1)\n+\t    {\n+\t      warning (_(\"Error parsing {s,}maps file '%s'\"),\n+\t\t       maps_filename.c_str ());\n+\t      break;\n+\t    }\n+\n+\t  if (strcmp (keyword, \"Anonymous:\") == 0)\n+\t    {\n+\t      /* Older Linux kernels did not support the\n+\t\t \"Anonymous:\" counter.  Check it here.  */\n+\t      has_anonymous = 1;\n+\t    }\n+\t  else if (strcmp (keyword, \"VmFlags:\") == 0)\n+\t    decode_vmflags (line, &v);\n+\n+\t  if (strcmp (keyword, \"AnonHugePages:\") == 0\n+\t      || strcmp (keyword, \"Anonymous:\") == 0)\n+\t    {\n+\t      unsigned long number;\n+\n+\t      if (sscanf (line, \"%*s%lu\", &number) != 1)\n+\t\t{\n+\t\t  warning (_(\"Error parsing {s,}maps file '%s' number\"),\n+\t\t\t   maps_filename.c_str ());\n+\t\t  break;\n+\t\t}\n+\t      if (number > 0)\n+\t\t{\n+\t\t  /* Even if we are dealing with a file-backed\n+\t\t     mapping, if it contains anonymous pages we\n+\t\t     consider it to be *also* an anonymous\n+\t\t     mapping, because this is what the Linux\n+\t\t     kernel does:\n+\n+\t\t     // Dump segments that have been written to.\n+\t\t     if (vma->anon_vma && FILTER(ANON_PRIVATE))\n+\t\t       goto whole;\n+\n+\t\t    Note that if the mapping is already marked as\n+\t\t    file-backed (i.e., mapping_file_p is\n+\t\t    non-zero), then this is a special case, and\n+\t\t    this mapping will be dumped either when the\n+\t\t    user wants to dump file-backed *or* anonymous\n+\t\t    mappings.  */\n+\t\t  mapping_anon_p = 1;\n+\t\t}\n+\t    }\n+\t}\n+      /* Save the smaps entry to the vector.  */\n+\tstruct smaps_data map;\n+\n+\tmap.start_address = addr;\n+\tmap.end_address = endaddr;\n+\tmap.filename = filename;\n+\tmap.vmflags = v;\n+\tmap.read = read? true : false;\n+\tmap.write = write? true : false;\n+\tmap.exec = exec? true : false;\n+\tmap.priv = priv? true : false;\n+\tmap.has_anonymous = has_anonymous;\n+\tmap.mapping_anon_p = mapping_anon_p? true : false;\n+\tmap.mapping_file_p = mapping_file_p? true : false;\n+\tmap.offset = offset;\n+\tmap.inode = inode;\n+\n+\tsmaps.emplace_back (map);\n+    }\n+\n+  return smaps;\n+}\n+\n+/* See linux-tdep.h.  */\n+\n+bool\n+linux_address_in_memtag_page (CORE_ADDR address)\n+{\n+  if (current_inferior ()->fake_pid_p)\n+    return false;\n+\n+  pid_t pid = current_inferior ()->pid;\n+\n+  std::string smaps_file = string_printf (\"/proc/%d/smaps\", pid);\n+\n+  gdb::unique_xmalloc_ptr<char> data\n+    = target_fileio_read_stralloc (NULL, smaps_file.c_str ());\n+\n+  if (data == nullptr)\n+    return false;\n+\n+  /* Parse the contents of smaps into a vector.  */\n+  std::vector<struct smaps_data> smaps\n+    = parse_smaps_data (data.get (), smaps_file);\n+\n+  for (const smaps_data &map : smaps)\n+    {\n+      /* Is the address within [start_address, end_address) in a page\n+\t mapped with memory tagging?  */\n+      if (address >= map.start_address\n+\t  && address < map.end_address\n+\t  && map.vmflags.memory_tagging)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* List memory regions in the inferior for a corefile.  */\n \n static int\n@@ -1321,137 +1522,49 @@ linux_find_memory_regions_full (struct gdbarch *gdbarch,\n       /* Older Linux kernels did not support /proc/PID/smaps.  */\n       maps_filename = string_printf (\"/proc/%d/maps\", pid);\n       data = target_fileio_read_stralloc (NULL, maps_filename.c_str ());\n+\n+      if (data == nullptr)\n+\treturn 1;\n     }\n \n-  if (data != NULL)\n+  /* Parse the contents of smaps into a vector.  */\n+  std::vector<struct smaps_data> smaps\n+    = parse_smaps_data (data.get (), maps_filename.c_str ());\n+\n+  for (const struct smaps_data &map : smaps)\n     {\n-      char *line, *t;\n+      int should_dump_p = 0;\n \n-      line = strtok_r (data.get (), \"\\n\", &t);\n-      while (line != NULL)\n+      if (map.has_anonymous)\n \t{\n-\t  ULONGEST addr, endaddr, offset, inode;\n-\t  const char *permissions, *device, *filename;\n-\t  struct smaps_vmflags v;\n-\t  size_t permissions_len, device_len;\n-\t  int read, write, exec, priv;\n-\t  int has_anonymous = 0;\n-\t  int should_dump_p = 0;\n-\t  int mapping_anon_p;\n-\t  int mapping_file_p;\n-\n-\t  memset (&v, 0, sizeof (v));\n-\t  read_mapping (line, &addr, &endaddr, &permissions, &permissions_len,\n-\t\t\t&offset, &device, &device_len, &inode, &filename);\n-\t  mapping_anon_p = mapping_is_anonymous_p (filename);\n-\t  /* If the mapping is not anonymous, then we can consider it\n-\t     to be file-backed.  These two states (anonymous or\n-\t     file-backed) seem to be exclusive, but they can actually\n-\t     coexist.  For example, if a file-backed mapping has\n-\t     \"Anonymous:\" pages (see more below), then the Linux\n-\t     kernel will dump this mapping when the user specified\n-\t     that she only wants anonymous mappings in the corefile\n-\t     (*even* when she explicitly disabled the dumping of\n-\t     file-backed mappings).  */\n-\t  mapping_file_p = !mapping_anon_p;\n-\n-\t  /* Decode permissions.  */\n-\t  read = (memchr (permissions, 'r', permissions_len) != 0);\n-\t  write = (memchr (permissions, 'w', permissions_len) != 0);\n-\t  exec = (memchr (permissions, 'x', permissions_len) != 0);\n-\t  /* 'private' here actually means VM_MAYSHARE, and not\n-\t     VM_SHARED.  In order to know if a mapping is really\n-\t     private or not, we must check the flag \"sh\" in the\n-\t     VmFlags field.  This is done by decode_vmflags.  However,\n-\t     if we are using a Linux kernel released before the commit\n-\t     834f82e2aa9a8ede94b17b656329f850c1471514 (3.10), we will\n-\t     not have the VmFlags there.  In this case, there is\n-\t     really no way to know if we are dealing with VM_SHARED,\n-\t     so we just assume that VM_MAYSHARE is enough.  */\n-\t  priv = memchr (permissions, 'p', permissions_len) != 0;\n-\n-\t  /* Try to detect if region should be dumped by parsing smaps\n-\t     counters.  */\n-\t  for (line = strtok_r (NULL, \"\\n\", &t);\n-\t       line != NULL && line[0] >= 'A' && line[0] <= 'Z';\n-\t       line = strtok_r (NULL, \"\\n\", &t))\n-\t    {\n-\t      char keyword[64 + 1];\n-\n-\t      if (sscanf (line, \"%64s\", keyword) != 1)\n-\t\t{\n-\t\t  warning (_(\"Error parsing {s,}maps file '%s'\"),\n-\t\t\t   maps_filename.c_str ());\n-\t\t  break;\n-\t\t}\n-\n-\t      if (strcmp (keyword, \"Anonymous:\") == 0)\n-\t\t{\n-\t\t  /* Older Linux kernels did not support the\n-\t\t     \"Anonymous:\" counter.  Check it here.  */\n-\t\t  has_anonymous = 1;\n-\t\t}\n-\t      else if (strcmp (keyword, \"VmFlags:\") == 0)\n-\t\tdecode_vmflags (line, &v);\n-\n-\t      if (strcmp (keyword, \"AnonHugePages:\") == 0\n-\t\t  || strcmp (keyword, \"Anonymous:\") == 0)\n-\t\t{\n-\t\t  unsigned long number;\n-\n-\t\t  if (sscanf (line, \"%*s%lu\", &number) != 1)\n-\t\t    {\n-\t\t      warning (_(\"Error parsing {s,}maps file '%s' number\"),\n-\t\t\t       maps_filename.c_str ());\n-\t\t      break;\n-\t\t    }\n-\t\t  if (number > 0)\n-\t\t    {\n-\t\t      /* Even if we are dealing with a file-backed\n-\t\t\t mapping, if it contains anonymous pages we\n-\t\t\t consider it to be *also* an anonymous\n-\t\t\t mapping, because this is what the Linux\n-\t\t\t kernel does:\n-\n-\t\t\t // Dump segments that have been written to.\n-\t\t\t if (vma->anon_vma && FILTER(ANON_PRIVATE))\n-\t\t\t \tgoto whole;\n-\n-\t\t\t Note that if the mapping is already marked as\n-\t\t\t file-backed (i.e., mapping_file_p is\n-\t\t\t non-zero), then this is a special case, and\n-\t\t\t this mapping will be dumped either when the\n-\t\t\t user wants to dump file-backed *or* anonymous\n-\t\t\t mappings.  */\n-\t\t      mapping_anon_p = 1;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (has_anonymous)\n-\t    should_dump_p = should_dump_mapping_p (filterflags, &v, priv,\n-\t\t\t\t\t\t   mapping_anon_p,\n-\t\t\t\t\t\t   mapping_file_p,\n-\t\t\t\t\t\t   filename, addr, offset);\n-\t  else\n-\t    {\n-\t      /* Older Linux kernels did not support the \"Anonymous:\" counter.\n-\t\t If it is missing, we can't be sure - dump all the pages.  */\n-\t      should_dump_p = 1;\n-\t    }\n-\n-\t  /* Invoke the callback function to create the corefile segment.  */\n-\t  if (should_dump_p)\n-\t    func (addr, endaddr - addr, offset, inode,\n-\t\t  read, write, exec, 1, /* MODIFIED is true because we\n-\t\t\t\t\t   want to dump the mapping.  */\n-\t\t  filename, obfd);\n+\t  should_dump_p\n+\t    = should_dump_mapping_p (filterflags, &map.vmflags,\n+\t\t\t\t     map.priv,\n+\t\t\t\t     map.mapping_anon_p,\n+\t\t\t\t     map.mapping_file_p,\n+\t\t\t\t     map.filename.c_str (),\n+\t\t\t\t     map.start_address,\n+\t\t\t\t     map.offset);\n+\t}\n+      else\n+\t{\n+\t  /* Older Linux kernels did not support the \"Anonymous:\" counter.\n+\t     If it is missing, we can't be sure - dump all the pages.  */\n+\t  should_dump_p = 1;\n \t}\n \n-      return 0;\n+      /* Invoke the callback function to create the corefile segment.  */\n+      if (should_dump_p)\n+\t{\n+\t  func (map.start_address, map.end_address - map.start_address,\n+\t\tmap.offset, map.inode, map.read, map.write, map.exec,\n+\t\t1, /* MODIFIED is true because we want to dump\n+\t\t      the mapping.  */\n+\t\tmap.filename.c_str (), obfd);\n+\t}\n     }\n \n-  return 1;\n+  return 0;\n }\n \n /* A structure for passing information through"
    },
    {
      "sha": "28b60e46579bb26057b0a047df7b5c3243541833",
      "filename": "gdb/linux-tdep.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/linux-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1e735120b95236b1f0fd8c383e64b02b64909d7c/gdb/linux-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.h?ref=1e735120b95236b1f0fd8c383e64b02b64909d7c",
      "patch": "@@ -43,6 +43,10 @@ DEF_ENUM_FLAGS_TYPE (enum linux_siginfo_extra_field_values,\n struct type *linux_get_siginfo_type_with_fields (struct gdbarch *gdbarch,\n \t\t\t\t\t\t linux_siginfo_extra_fields);\n \n+/* Return true if ADDRESS is within the boundaries of a page mapped with\n+   memory tagging protection.  */\n+bool linux_address_in_memtag_page (CORE_ADDR address);\n+\n typedef char *(*linux_collect_thread_registers_ftype) (const struct regcache *,\n \t\t\t\t\t\t       ptid_t,\n \t\t\t\t\t\t       bfd *, char *, int *,"
    }
  ]
}