{
  "sha": "32f598441988e5a086ba8580e82f4944c3692eb5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzJmNTk4NDQxOTg4ZTVhMDg2YmE4NTgwZTgyZjQ5NDRjMzY5MmViNQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-06-18T06:03:38Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-07-13T00:27:50Z"
    },
    "message": "[GOLD] PowerPC64 ELFv2 notoc support\n\nCalls from notoc functions via the PLT need different stubs.  Even\ncalls to local functions requiring a valid toc pointer must go via a\nstub.  This patch provides the support in gold.\n\nelfcpp/\n\t* powerpc.h (R_PPC64_PLTSEQ_NOTOC, R_PPC64_PLTCALL_NOTOC): Define.\ngold/\n\t* powerpc.cc (Target_powerpc::maybe_skip_tls_get_addr_call): Handle\n\tnotoc calls.\n\t(is_branch_reloc): Template on size.  Return true for REL24_NOTOC.\n\tUpdate all callers.\n\t(max_branch_delta): Likewise.\n\t(Target_powerpc::Branch_info::make_stub): Add a stub for notoc\n\tcalls to functions needing a valid toc pointer.\n\t(Target_powerpc::do_relax): Layout stubs again if any need resize.\n\t(add_12_11_12, addi_12_11, addis_12_11, ldx_12_11_12, ori_12_12_0),\n\t(oris_12_12_0, sldi_12_12_32): Define.\n\t(Stub_table::Plt_stub_ent): Add notoc_ and iter_ fields.\n\t(Stub_table::Branch_stub_key, Branch_stub_key_hash): Rename from\n\tBranch_stub_ent and Branch_stub_ent hash.  Remove save_res_ from key.\n\t(Stub_table::Branch_stub_ent): New struct.\n\t(class Stub_table): Add need_resize and resizing vars.\n\t(Stub_table::need_resize, branch_size): New accessors.\n\t(Stub_table::set_resizing): New function.\n\t(Stub_table::add_plt_call_entry): Handle notoc calls and resizing\n\ton seeing such or a tocsave stubs after a normal stub using the\n\tsame sym.\n\t(Stub_table::add_long_branch_entry): Similarly.\n\t(Stub_table::find_long_branch_entry): Return a Branch_stub_ent*.\n\t(Stub_table::define_stub_syms): Adjust\n\t(Stub_table::build_tls_opt_head, build_tls_opt_tail): New functions.\n\t(build_notoc_offset): New function.\n\t(Stub_table::plt_call_size): Move out of line.  Handle notoc calls.\n\t(Stub_table::branch_stub_size): Similarly.\n\t(Stub_table::do_write): Separate loop for ELFv2 stubs, handling\n\tnotoc calls.  Simplify ELFv1 loop.  Output notoc branch stubs.\n\tUse build_tls_opt_head and build_tls_opt_tail.\n\t(Target_powerpc::Scan::get_reference_flags): Handle REL24_NOTOC.\n\t(Target_powerpc::Scan::reloc_needs_plt_for_ifunc): Likewise,\n\tand PLTSEQ_NOTOC and PLTCALL_NOTOC.\n\t(Target_powerpc::Scan::local, global, relocate): Likewise.",
    "tree": {
      "sha": "02470bbe7c1b886192709f199dfad34e6f9df411",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/02470bbe7c1b886192709f199dfad34e6f9df411"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/32f598441988e5a086ba8580e82f4944c3692eb5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/32f598441988e5a086ba8580e82f4944c3692eb5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/32f598441988e5a086ba8580e82f4944c3692eb5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/32f598441988e5a086ba8580e82f4944c3692eb5/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "154a0a90ddde3a5d538830527ffd6d128cb23b1b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/154a0a90ddde3a5d538830527ffd6d128cb23b1b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/154a0a90ddde3a5d538830527ffd6d128cb23b1b"
    }
  ],
  "stats": {
    "total": 1013,
    "additions": 752,
    "deletions": 261
  },
  "files": [
    {
      "sha": "b2409388338125af07b4a72d69c261474704d594",
      "filename": "elfcpp/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32f598441988e5a086ba8580e82f4944c3692eb5/elfcpp/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32f598441988e5a086ba8580e82f4944c3692eb5/elfcpp/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/elfcpp/ChangeLog?ref=32f598441988e5a086ba8580e82f4944c3692eb5",
      "patch": "@@ -1,3 +1,7 @@\n+2019-07-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* powerpc.h (R_PPC64_PLTSEQ_NOTOC, R_PPC64_PLTCALL_NOTOC): Define.\n+\n 2019-06-28  Alan Modra  <amodra@gmail.com>\n \n \t* powerpc.h (R_PPC64_REL16_HIGH, R_PPC64_REL16_HIGHA),"
    },
    {
      "sha": "5e5e39abd812314a72a6205f39d239a035ae5a64",
      "filename": "elfcpp/powerpc.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32f598441988e5a086ba8580e82f4944c3692eb5/elfcpp/powerpc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32f598441988e5a086ba8580e82f4944c3692eb5/elfcpp/powerpc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/elfcpp/powerpc.h?ref=32f598441988e5a086ba8580e82f4944c3692eb5",
      "patch": "@@ -181,6 +181,8 @@ enum\n   R_PPC64_ENTRY = 118,\n   R_POWERPC_PLTSEQ = 119,\n   R_POWERPC_PLTCALL = 120,\n+  R_PPC64_PLTSEQ_NOTOC = 121,\n+  R_PPC64_PLTCALL_NOTOC = 122,\n \n   R_PPC_VLE_REL8 = 216,\n   R_PPC_VLE_REL15 = 217,"
    },
    {
      "sha": "e8bfea973efb0f847b9d405f91017af0517588f7",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32f598441988e5a086ba8580e82f4944c3692eb5/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32f598441988e5a086ba8580e82f4944c3692eb5/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=32f598441988e5a086ba8580e82f4944c3692eb5",
      "patch": "@@ -1,3 +1,40 @@\n+2019-07-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* powerpc.cc (Target_powerpc::maybe_skip_tls_get_addr_call): Handle\n+\tnotoc calls.\n+\t(is_branch_reloc): Template on size.  Return true for REL24_NOTOC.\n+\tUpdate all callers.\n+\t(max_branch_delta): Likewise.\n+\t(Target_powerpc::Branch_info::make_stub): Add a stub for notoc\n+\tcalls to functions needing a valid toc pointer.\n+\t(Target_powerpc::do_relax): Layout stubs again if any need resize.\n+\t(add_12_11_12, addi_12_11, addis_12_11, ldx_12_11_12, ori_12_12_0),\n+\t(oris_12_12_0, sldi_12_12_32): Define.\n+\t(Stub_table::Plt_stub_ent): Add notoc_ and iter_ fields.\n+\t(Stub_table::Branch_stub_key, Branch_stub_key_hash): Rename from\n+\tBranch_stub_ent and Branch_stub_ent hash.  Remove save_res_ from key.\n+\t(Stub_table::Branch_stub_ent): New struct.\n+\t(class Stub_table): Add need_resize and resizing vars.\n+\t(Stub_table::need_resize, branch_size): New accessors.\n+\t(Stub_table::set_resizing): New function.\n+\t(Stub_table::add_plt_call_entry): Handle notoc calls and resizing\n+\ton seeing such or a tocsave stubs after a normal stub using the\n+\tsame sym.\n+\t(Stub_table::add_long_branch_entry): Similarly.\n+\t(Stub_table::find_long_branch_entry): Return a Branch_stub_ent*.\n+\t(Stub_table::define_stub_syms): Adjust\n+\t(Stub_table::build_tls_opt_head, build_tls_opt_tail): New functions.\n+\t(build_notoc_offset): New function.\n+\t(Stub_table::plt_call_size): Move out of line.  Handle notoc calls.\n+\t(Stub_table::branch_stub_size): Similarly.\n+\t(Stub_table::do_write): Separate loop for ELFv2 stubs, handling\n+\tnotoc calls.  Simplify ELFv1 loop.  Output notoc branch stubs.\n+\tUse build_tls_opt_head and build_tls_opt_tail.\n+\t(Target_powerpc::Scan::get_reference_flags): Handle REL24_NOTOC.\n+\t(Target_powerpc::Scan::reloc_needs_plt_for_ifunc): Likewise,\n+\tand PLTSEQ_NOTOC and PLTCALL_NOTOC.\n+\t(Target_powerpc::Scan::local, global, relocate): Likewise.\n+\n 2019-06-28  Alan Modra  <amodra@gmail.com>\n \n \t* powerpc.cc (Target_powerpc::Relocate::relocate): Don't look"
    },
    {
      "sha": "1b62f5552c479231412e6b62916e4515261309c7",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 709,
      "deletions": 261,
      "changes": 970,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32f598441988e5a086ba8580e82f4944c3692eb5/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32f598441988e5a086ba8580e82f4944c3692eb5/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=32f598441988e5a086ba8580e82f4944c3692eb5",
      "patch": "@@ -79,6 +79,7 @@ struct Stub_table_owner\n   const Output_section::Input_section* owner;\n };\n \n+template<int size>\n inline bool is_branch_reloc(unsigned int);\n \n template<int size>\n@@ -390,6 +391,14 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n   ppc64_local_entry_offset(unsigned int symndx) const\n   { return elfcpp::ppc64_decode_local_entry(this->st_other_[symndx] >> 5); }\n \n+  bool\n+  ppc64_needs_toc(const Symbol* sym) const\n+  { return sym->nonvis() > 1 << 3; }\n+\n+  bool\n+  ppc64_needs_toc(unsigned int symndx) const\n+  { return this->st_other_[symndx] > 1 << 5; }\n+\n   // The contents of the .gnu.attributes section if there is one.\n   const Attributes_section_data*\n   attributes_section_data() const\n@@ -1237,14 +1246,18 @@ class Target_powerpc : public Sized_target<size, big_endian>\n     maybe_skip_tls_get_addr_call(Target_powerpc<size, big_endian>* target,\n \t\t\t\t unsigned int r_type, const Symbol* gsym)\n     {\n-      bool is_tls_call = ((r_type == elfcpp::R_POWERPC_REL24\n-\t\t\t   || r_type == elfcpp::R_PPC_PLTREL24\n-\t\t\t   || is_plt16_reloc<size>(r_type)\n-\t\t\t   || r_type == elfcpp::R_POWERPC_PLTSEQ\n-\t\t\t   || r_type == elfcpp::R_POWERPC_PLTCALL)\n-\t\t\t  && gsym != NULL\n-\t\t\t  && (gsym == target->tls_get_addr()\n-\t\t\t      || gsym == target->tls_get_addr_opt()));\n+      bool is_tls_call\n+\t= ((r_type == elfcpp::R_POWERPC_REL24\n+\t    || (size == 64 && r_type == elfcpp::R_PPC64_REL24_NOTOC)\n+\t    || r_type == elfcpp::R_PPC_PLTREL24\n+\t    || is_plt16_reloc<size>(r_type)\n+\t    || r_type == elfcpp::R_POWERPC_PLTSEQ\n+\t    || r_type == elfcpp::R_POWERPC_PLTCALL\n+\t    || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC\n+\t    || r_type == elfcpp::R_PPC64_PLTCALL_NOTOC)\n+\t   && gsym != NULL\n+\t   && (gsym == target->tls_get_addr()\n+\t       || gsym == target->tls_get_addr_opt()));\n       Tls_get_addr last_tls = this->tls_get_addr_state_;\n       this->tls_get_addr_state_ = NOT_EXPECTED;\n       if (is_tls_call && last_tls != EXPECTED)\n@@ -1262,7 +1275,7 @@ class Target_powerpc : public Sized_target<size, big_endian>\n     // On powerpc, the branch and link insn making a call to\n     // __tls_get_addr is marked with a relocation, R_PPC64_TLSGD,\n     // R_PPC64_TLSLD, R_PPC_TLSGD or R_PPC_TLSLD, in addition to the\n-    // usual R_POWERPC_REL24 or R_PPC_PLTREL25 relocation on a call.\n+    // usual R_POWERPC_REL24 or R_PPC_PLTREL24 relocation on a call.\n     // The marker relocation always comes first, and has the same\n     // symbol as the reloc on the insn setting up the __tls_get_addr\n     // argument.  This ties the arg setup insn with the call insn,\n@@ -1328,7 +1341,7 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \t}\n       // For 32-bit and ELFv2, conservatively assume anything but calls to\n       // function code might be taking the address of the function.\n-      return !is_branch_reloc(r_type);\n+      return !is_branch_reloc<size>(r_type);\n     }\n \n     inline bool\n@@ -1349,7 +1362,7 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \t  if (ppcobj->abiversion() == 1)\n \t    return false;\n \t}\n-      return !is_branch_reloc(r_type);\n+      return !is_branch_reloc<size>(r_type);\n     }\n \n     static bool\n@@ -1799,10 +1812,12 @@ Target::Target_info Target_powerpc<64, false>::powerpc_info =\n   elfcpp::SHT_PROGBITS,\t// unwind_section_type\n };\n \n+template<int size>\n inline bool\n is_branch_reloc(unsigned int r_type)\n {\n   return (r_type == elfcpp::R_POWERPC_REL24\n+\t  || (size == 64 && r_type == elfcpp::R_PPC64_REL24_NOTOC)\n \t  || r_type == elfcpp::R_PPC_PLTREL24\n \t  || r_type == elfcpp::R_PPC_LOCAL24PC\n \t  || r_type == elfcpp::R_POWERPC_REL14\n@@ -3268,6 +3283,7 @@ Target_powerpc<size, big_endian>::group_sections(Layout* layout,\n     }\n }\n \n+template<int size>\n static unsigned long\n max_branch_delta (unsigned int r_type)\n {\n@@ -3276,6 +3292,7 @@ max_branch_delta (unsigned int r_type)\n       || r_type == elfcpp::R_POWERPC_REL14_BRNTAKEN)\n     return 1L << 15;\n   if (r_type == elfcpp::R_POWERPC_REL24\n+      || (size == 64 && r_type == elfcpp::R_PPC64_REL24_NOTOC)\n       || r_type == elfcpp::R_PPC_PLTREL24\n       || r_type == elfcpp::R_PPC_LOCAL24PC)\n     return 1L << 25;\n@@ -3344,15 +3361,15 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(\n \t  && gsym != NULL\n \t  && target->abiversion() >= 2\n \t  && !parameters->options().output_is_position_independent()\n-\t  && !is_branch_reloc(this->r_type_))\n+\t  && !is_branch_reloc<size>(this->r_type_))\n \ttarget->glink_section()->add_global_entry(gsym);\n       else\n \t{\n \t  if (stub_table == NULL\n \t      && !(size == 32\n \t\t   && gsym != NULL\n \t\t   && !parameters->options().output_is_position_independent()\n-\t\t   && !is_branch_reloc(this->r_type_)))\n+\t\t   && !is_branch_reloc<size>(this->r_type_)))\n \t    stub_table = this->object_->stub_table(this->shndx_);\n \t  if (stub_table == NULL)\n \t    {\n@@ -3380,7 +3397,7 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(\n     }\n   else\n     {\n-      Address max_branch_offset = max_branch_delta(this->r_type_);\n+      Address max_branch_offset = max_branch_delta<size>(this->r_type_);\n       if (max_branch_offset == 0)\n \treturn true;\n       Address from = this->object_->get_output_section_offset(this->shndx_);\n@@ -3448,7 +3465,12 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(\n \t    return true;\n \t}\n       Address delta = to - from;\n-      if (delta + max_branch_offset >= 2 * max_branch_offset)\n+      if (delta + max_branch_offset >= 2 * max_branch_offset\n+\t  || (size == 64\n+\t      && this->r_type_ == elfcpp::R_PPC64_REL24_NOTOC\n+\t      && (gsym != NULL\n+\t\t  ? this->object_->ppc64_needs_toc(gsym)\n+\t\t  : this->object_->ppc64_needs_toc(this->r_sym_))))\n \t{\n \t  if (stub_table == NULL)\n \t    {\n@@ -3620,6 +3642,40 @@ Target_powerpc<size, big_endian>::do_relax(int pass,\n \t    return true;\n \t}\n     }\n+  bool do_resize = false;\n+  for (typename Stub_tables::iterator p = this->stub_tables_.begin();\n+       p != this->stub_tables_.end();\n+       ++p)\n+    if ((*p)->need_resize())\n+      {\n+\tdo_resize = true;\n+\tbreak;\n+      }\n+  if (do_resize)\n+    {\n+      this->branch_lookup_table_.clear();\n+      for (typename Stub_tables::iterator p = this->stub_tables_.begin();\n+\t   p != this->stub_tables_.end();\n+\t   ++p)\n+\t(*p)->set_resizing(true);\n+      for (typename Branches::const_iterator b = this->branch_info_.begin();\n+\t   b != this->branch_info_.end();\n+\t   b++)\n+\t{\n+\t  if (!b->make_stub(one_stub_table, ifunc_stub_table, symtab)\n+\t      && !this->relax_failed_)\n+\t    {\n+\t      this->relax_failed_ = true;\n+\t      this->relax_fail_count_++;\n+\t      if (this->relax_fail_count_ < 3)\n+\t\treturn true;\n+\t    }\n+\t}\n+      for (typename Stub_tables::iterator p = this->stub_tables_.begin();\n+\t   p != this->stub_tables_.end();\n+\t   ++p)\n+\t(*p)->set_resizing(false);\n+    }\n \n   // Did anything change size?\n   unsigned int num_huge_branches = this->branch_lookup_table_.size();\n@@ -3987,11 +4043,13 @@ static const uint32_t add_3_12_13\t= 0x7c6c6a14;\n static const uint32_t add_11_0_11\t= 0x7d605a14;\n static const uint32_t add_11_2_11\t= 0x7d625a14;\n static const uint32_t add_11_11_2\t= 0x7d6b1214;\n+static const uint32_t add_12_11_12\t= 0x7d8b6214;\n static const uint32_t addi_0_12\t\t= 0x380c0000;\n static const uint32_t addi_2_2\t\t= 0x38420000;\n static const uint32_t addi_3_3\t\t= 0x38630000;\n static const uint32_t addi_11_11\t= 0x396b0000;\n static const uint32_t addi_12_1\t\t= 0x39810000;\n+static const uint32_t addi_12_11\t= 0x398b0000;\n static const uint32_t addi_12_12\t= 0x398c0000;\n static const uint32_t addis_0_2\t\t= 0x3c020000;\n static const uint32_t addis_0_13\t= 0x3c0d0000;\n@@ -4001,6 +4059,7 @@ static const uint32_t addis_11_11\t= 0x3d6b0000;\n static const uint32_t addis_11_30\t= 0x3d7e0000;\n static const uint32_t addis_12_1\t= 0x3d810000;\n static const uint32_t addis_12_2\t= 0x3d820000;\n+static const uint32_t addis_12_11\t= 0x3d8b0000;\n static const uint32_t addis_12_12\t= 0x3d8c0000;\n static const uint32_t b\t\t\t= 0x48000000;\n static const uint32_t bcl_20_31\t\t= 0x429f0005;\n@@ -4029,6 +4088,7 @@ static const uint32_t ld_12_2\t\t= 0xe9820000;\n static const uint32_t ld_12_3\t\t= 0xe9830000;\n static const uint32_t ld_12_11\t\t= 0xe98b0000;\n static const uint32_t ld_12_12\t\t= 0xe98c0000;\n+static const uint32_t ldx_12_11_12\t= 0x7d8b602a;\n static const uint32_t lfd_0_1\t\t= 0xc8010000;\n static const uint32_t li_0_0\t\t= 0x38000000;\n static const uint32_t li_12_0\t\t= 0x39800000;\n@@ -4057,6 +4117,9 @@ static const uint32_t mtlr_11\t\t= 0x7d6803a6;\n static const uint32_t mtlr_12\t\t= 0x7d8803a6;\n static const uint32_t nop\t\t= 0x60000000;\n static const uint32_t ori_0_0_0\t\t= 0x60000000;\n+static const uint32_t ori_12_12_0\t= 0x618c0000;\n+static const uint32_t oris_12_12_0\t= 0x658c0000;\n+static const uint32_t sldi_12_12_32\t= 0x799c07c6;\n static const uint32_t srdi_0_0_2\t= 0x7800f082;\n static const uint32_t std_0_1\t\t= 0xf8010000;\n static const uint32_t std_0_12\t\t= 0xf80c0000;\n@@ -4443,14 +4506,27 @@ class Stub_table : public Output_relaxed_input_section\n   struct Plt_stub_ent\n   {\n     Plt_stub_ent(unsigned int off, unsigned int indx)\n-      : off_(off), indx_(indx), r2save_(0), localentry0_(0)\n+      : off_(off), indx_(indx), iter_(0), notoc_(0), r2save_(0), localentry0_(0)\n     { }\n \n     unsigned int off_;\n-    unsigned int indx_ : 30;\n+    unsigned int indx_ : 28;\n+    unsigned int iter_ : 1;\n+    unsigned int notoc_ : 1;\n     unsigned int r2save_ : 1;\n     unsigned int localentry0_ : 1;\n   };\n+  struct Branch_stub_ent\n+  {\n+    Branch_stub_ent(unsigned int off, bool notoc, bool save_res)\n+      : off_(off), iter_(false), notoc_(notoc), save_res_(save_res)\n+    { }\n+\n+    unsigned int off_;\n+    bool iter_;\n+    bool notoc_;\n+    bool save_res_;\n+  };\n   typedef typename elfcpp::Elf_types<size>::Elf_Addr Address;\n   static const Address invalid_address = static_cast<Address>(0) - 1;\n \n@@ -4465,8 +4541,8 @@ class Stub_table : public Output_relaxed_input_section\n       orig_data_size_(owner->current_data_size()),\n       plt_size_(0), last_plt_size_(0),\n       branch_size_(0), last_branch_size_(0), min_size_threshold_(0),\n-      need_save_res_(false), uniq_(id), tls_get_addr_opt_bctrl_(-1u),\n-      plt_fde_len_(0)\n+      need_save_res_(false), need_resize_(false), resizing_(false),\n+      uniq_(id), tls_get_addr_opt_bctrl_(-1u), plt_fde_len_(0)\n   {\n     this->set_output_section(output_section);\n \n@@ -4517,14 +4593,14 @@ class Stub_table : public Output_relaxed_input_section\n   add_long_branch_entry(const Powerpc_relobj<size, big_endian>*,\n \t\t\tunsigned int, Address, Address, bool);\n \n-  Address\n+  const Branch_stub_ent*\n   find_long_branch_entry(const Powerpc_relobj<size, big_endian>*,\n \t\t\t Address) const;\n \n   bool\n   can_reach_stub(Address from, unsigned int off, unsigned int r_type)\n   {\n-    Address max_branch_offset = max_branch_delta(r_type);\n+    Address max_branch_offset = max_branch_delta<size>(r_type);\n     if (max_branch_offset == 0)\n       return true;\n     gold_assert(from != invalid_address);\n@@ -4547,6 +4623,23 @@ class Stub_table : public Output_relaxed_input_section\n       }\n   }\n \n+  bool\n+  need_resize() const\n+  { return need_resize_; }\n+\n+  void\n+  set_resizing(bool val)\n+  {\n+    this->resizing_ = val;\n+    if (val)\n+      {\n+\tthis->need_resize_ = false;\n+\tthis->plt_size_ = 0;\n+\tthis->branch_size_ = 0;\n+\tthis->need_save_res_ = false;\n+      }\n+  }\n+\n   Address\n   set_address_and_size(const Output_section* os, Address off)\n   {\n@@ -4589,6 +4682,10 @@ class Stub_table : public Output_relaxed_input_section\n   plt_size() const\n   { return this->plt_size_; }\n \n+  section_size_type\n+  branch_size() const\n+  { return this->branch_size_; }\n+\n   void\n   set_min_size_threshold(Address min_size)\n   { this->min_size_threshold_ = min_size; }\n@@ -4648,10 +4745,10 @@ class Stub_table : public Output_relaxed_input_section\n   class Plt_stub_key_hash;\n   typedef Unordered_map<Plt_stub_key, Plt_stub_ent,\n \t\t\tPlt_stub_key_hash> Plt_stub_entries;\n-  class Branch_stub_ent;\n-  class Branch_stub_ent_hash;\n-  typedef Unordered_map<Branch_stub_ent, unsigned int,\n-\t\t\tBranch_stub_ent_hash> Branch_stub_entries;\n+  class Branch_stub_key;\n+  class Branch_stub_key_hash;\n+  typedef Unordered_map<Branch_stub_key, Branch_stub_ent,\n+\t\t\tBranch_stub_key_hash> Branch_stub_entries;\n \n   // Alignment of stub section.\n   unsigned int\n@@ -4680,38 +4777,7 @@ class Stub_table : public Output_relaxed_input_section\n \n   // Size of a given plt call stub.\n   unsigned int\n-  plt_call_size(typename Plt_stub_entries::const_iterator p) const\n-  {\n-    if (size == 32)\n-      {\n-\tconst Symbol* gsym = p->first.sym_;\n-\treturn (4 * 4\n-\t\t+ (this->targ_->is_tls_get_addr_opt(gsym) ? 8 * 4 : 0));\n-      }\n-\n-    const Output_data_plt_powerpc<size, big_endian>* plt;\n-    Address plt_addr = this->plt_off(p, &plt);\n-    plt_addr += plt->address();\n-    Address got_addr = this->targ_->got_section()->output_section()->address();\n-    const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-      <const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n-    got_addr += ppcobj->toc_base_offset();\n-    Address off = plt_addr - got_addr;\n-    unsigned int bytes = 4 * 4 + 4 * (ha(off) != 0);\n-    const Symbol* gsym = p->first.sym_;\n-    if (this->targ_->is_tls_get_addr_opt(gsym))\n-      bytes += 13 * 4;\n-    if (this->targ_->abiversion() < 2)\n-      {\n-\tbool static_chain = parameters->options().plt_static_chain();\n-\tbool thread_safe = this->targ_->plt_thread_safe();\n-\tbytes += (4\n-\t\t  + 4 * static_chain\n-\t\t  + 8 * thread_safe\n-\t\t  + 4 * (ha(off + 8 + 8 * static_chain) != ha(off)));\n-      }\n-    return bytes;\n-  }\n+  plt_call_size(typename Plt_stub_entries::const_iterator p) const;\n \n   unsigned int\n   plt_call_align(unsigned int bytes) const\n@@ -4722,16 +4788,16 @@ class Stub_table : public Output_relaxed_input_section\n \n   // Return long branch stub size.\n   unsigned int\n-  branch_stub_size(typename Branch_stub_entries::const_iterator p)\n-  {\n-    Address loc = this->stub_address() + this->last_plt_size_ + p->second;\n-    if (p->first.dest_ - loc + (1 << 25) < 2 << 25)\n-      return 4;\n-    unsigned int bytes = 16;\n-    if (size == 32 && parameters->options().output_is_position_independent())\n-      bytes += 16;\n-    return bytes;\n-  }\n+  branch_stub_size(typename Branch_stub_entries::const_iterator p,\n+\t\t   bool* need_lt);\n+\n+  bool\n+  build_tls_opt_head(unsigned char** pp,\n+\t\t     typename Plt_stub_entries::const_iterator cs);\n+\n+  bool\n+  build_tls_opt_tail(unsigned char* p,\n+\t\t     typename Plt_stub_entries::const_iterator cs);\n \n   void\n   plt_error(const Plt_stub_key& p);\n@@ -4812,18 +4878,17 @@ class Stub_table : public Output_relaxed_input_section\n   };\n \n   // Long branch stub keys.\n-  class Branch_stub_ent\n+  class Branch_stub_key\n   {\n   public:\n-    Branch_stub_ent(const Powerpc_relobj<size, big_endian>* obj,\n-\t\t    Address to, bool save_res)\n-      : dest_(to), toc_base_off_(0), save_res_(save_res)\n+    Branch_stub_key(const Powerpc_relobj<size, big_endian>* obj, Address to)\n+      : dest_(to), toc_base_off_(0)\n     {\n       if (size == 64)\n \ttoc_base_off_ = obj->toc_base_offset();\n     }\n \n-    bool operator==(const Branch_stub_ent& that) const\n+    bool operator==(const Branch_stub_key& that) const\n     {\n       return (this->dest_ == that.dest_\n \t      && (size == 32\n@@ -4832,14 +4897,13 @@ class Stub_table : public Output_relaxed_input_section\n \n     Address dest_;\n     unsigned int toc_base_off_;\n-    bool save_res_;\n   };\n \n-  class Branch_stub_ent_hash\n+  class Branch_stub_key_hash\n   {\n   public:\n-    size_t operator()(const Branch_stub_ent& ent) const\n-    { return ent.dest_ ^ ent.toc_base_off_; }\n+    size_t operator()(const Branch_stub_key& key) const\n+    { return key.dest_ ^ key.toc_base_off_; }\n   };\n \n   // In a sane world this would be a global.\n@@ -4862,6 +4926,10 @@ class Stub_table : public Output_relaxed_input_section\n   // Set if this stub group needs a copy of out-of-line register\n   // save/restore functions.\n   bool need_save_res_;\n+  // Set when notoc_/r2save_ changes after sizing a stub\n+  bool need_resize_;\n+  // Set when resizing stubs\n+  bool resizing_;\n   // Per stub table unique identifier.\n   uint32_t uniq_;\n   // The bctrl in the __tls_get_addr_opt stub, if present.\n@@ -4888,27 +4956,43 @@ Stub_table<size, big_endian>::add_plt_call_entry(\n   Plt_stub_ent ent(this->plt_size_, this->plt_call_stubs_.size());\n   std::pair<typename Plt_stub_entries::iterator, bool> p\n     = this->plt_call_stubs_.insert(std::make_pair(key, ent));\n-  if (p.second)\n+  if (size == 64)\n     {\n-      this->plt_size_ = ent.off_ + this->plt_call_size(p.first);\n-      if (size == 64\n+      if (p.second\n \t  && this->targ_->is_elfv2_localentry0(gsym))\n \t{\n \t  p.first->second.localentry0_ = 1;\n \t  this->targ_->set_has_localentry0();\n \t}\n+      if (r_type == elfcpp::R_PPC64_REL24_NOTOC)\n+\t{\n+\t  if (!p.second && !p.first->second.notoc_)\n+\t    this->need_resize_ = true;\n+\t  p.first->second.notoc_ = 1;\n+\t}\n+      else if (!tocsave && !p.first->second.localentry0_)\n+\t{\n+\t  if (!p.second && !p.first->second.r2save_)\n+\t    this->need_resize_ = true;\n+\t  p.first->second.r2save_ = 1;\n+\t}\n+    }\n+  if (p.second || (this->resizing_ && !p.first->second.iter_))\n+    {\n+      if (this->resizing_)\n+\t{\n+\t  p.first->second.iter_ = 1;\n+\t  p.first->second.off_ = this->plt_size_;\n+\t}\n+      this->plt_size_ += this->plt_call_size(p.first);\n       if (this->targ_->is_tls_get_addr_opt(gsym))\n \t{\n \t  this->targ_->set_has_tls_get_addr_opt();\n \t  this->tls_get_addr_opt_bctrl_ = this->plt_size_ - 5 * 4;\n \t}\n       this->plt_size_ = this->plt_call_align(this->plt_size_);\n     }\n-  if (size == 64\n-      && !tocsave\n-      && !p.first->second.localentry0_)\n-    p.first->second.r2save_ = 1;\n-  return this->can_reach_stub(from, ent.off_, r_type);\n+  return this->can_reach_stub(from, p.first->second.off_, r_type);\n }\n \n template<int size, bool big_endian>\n@@ -4925,22 +5009,38 @@ Stub_table<size, big_endian>::add_plt_call_entry(\n   Plt_stub_ent ent(this->plt_size_, this->plt_call_stubs_.size());\n   std::pair<typename Plt_stub_entries::iterator, bool> p\n     = this->plt_call_stubs_.insert(std::make_pair(key, ent));\n-  if (p.second)\n+  if (size == 64)\n     {\n-      this->plt_size_ = ent.off_ + this->plt_call_size(p.first);\n-      this->plt_size_ = this->plt_call_align(this->plt_size_);\n-      if (size == 64\n+      if (p.second\n \t  && this->targ_->is_elfv2_localentry0(object, locsym_index))\n \t{\n \t  p.first->second.localentry0_ = 1;\n \t  this->targ_->set_has_localentry0();\n \t}\n+      if (r_type == elfcpp::R_PPC64_REL24_NOTOC)\n+\t{\n+\t  if (!p.second && !p.first->second.notoc_)\n+\t    this->need_resize_ = true;\n+\t  p.first->second.notoc_ = 1;\n+\t}\n+      else if (!tocsave && !p.first->second.localentry0_)\n+\t{\n+\t  if (!p.second && !p.first->second.r2save_)\n+\t    this->need_resize_ = true;\n+\t  p.first->second.r2save_ = 1;\n+\t}\n     }\n-  if (size == 64\n-      && !tocsave\n-      && !p.first->second.localentry0_)\n-    p.first->second.r2save_ = 1;\n-  return this->can_reach_stub(from, ent.off_, r_type);\n+  if (p.second || (this->resizing_ && !p.first->second.iter_))\n+    {\n+      if (this->resizing_)\n+\t{\n+\t  p.first->second.iter_ = 1;\n+\t  p.first->second.off_ = this->plt_size_;\n+\t}\n+      this->plt_size_ += this->plt_call_size(p.first);\n+      this->plt_size_ = this->plt_call_align(this->plt_size_);\n+    }\n+  return this->can_reach_stub(from, p.first->second.off_, r_type);\n }\n \n // Find a plt call stub.\n@@ -5011,41 +5111,52 @@ Stub_table<size, big_endian>::add_long_branch_entry(\n     Address to,\n     bool save_res)\n {\n-  Branch_stub_ent ent(object, to, save_res);\n-  Address off = this->branch_size_;\n+  Branch_stub_key key(object, to);\n+  bool notoc = (size == 64 && r_type == elfcpp::R_PPC64_REL24_NOTOC);\n+  Branch_stub_ent ent(this->branch_size_, notoc, save_res);\n   std::pair<typename Branch_stub_entries::iterator, bool> p\n-    = this->long_branch_stubs_.insert(std::make_pair(ent, off));\n-  if (p.second)\n+    = this->long_branch_stubs_.insert(std::make_pair(key, ent));\n+  if (notoc && !p.first->second.notoc_)\n     {\n+      this->need_resize_ = true;\n+      p.first->second.notoc_ = true;\n+    }\n+  gold_assert(save_res == p.first->second.save_res_);\n+  if (p.second || (this->resizing_ && !p.first->second.iter_))\n+    {\n+      if (this->resizing_)\n+\t{\n+\t  p.first->second.iter_ = 1;\n+\t  p.first->second.off_ = this->branch_size_;\n+\t}\n       if (save_res)\n \tthis->need_save_res_ = true;\n       else\n \t{\n-\t  unsigned int stub_size = this->branch_stub_size(p.first);\n-\t  this->branch_size_ = off + stub_size;\n-\t  if (size == 64 && stub_size != 4)\n+\t  bool need_lt = false;\n+\t  unsigned int stub_size = this->branch_stub_size(p.first, &need_lt);\n+\t  this->branch_size_ += stub_size;\n+\t  if (size == 64 && need_lt)\n \t    this->targ_->add_branch_lookup_table(to);\n \t}\n     }\n-  return this->can_reach_stub(from, off, r_type);\n+  return this->can_reach_stub(from, p.first->second.off_, r_type);\n }\n \n // Find long branch stub offset.\n \n template<int size, bool big_endian>\n-typename Stub_table<size, big_endian>::Address\n+const typename Stub_table<size, big_endian>::Branch_stub_ent*\n Stub_table<size, big_endian>::find_long_branch_entry(\n     const Powerpc_relobj<size, big_endian>* object,\n     Address to) const\n {\n-  Branch_stub_ent ent(object, to, false);\n+  Branch_stub_key key(object, to);\n   typename Branch_stub_entries::const_iterator p\n-    = this->long_branch_stubs_.find(ent);\n+    = this->long_branch_stubs_.find(key);\n   if (p == this->long_branch_stubs_.end())\n-    return invalid_address;\n-  if (p->first.save_res_)\n-    return to - this->targ_->savres_section()->address() + this->branch_size_;\n-  return p->second;\n+    return NULL;\n+  return &p->second;\n }\n \n // Generate a suitable FDE to describe code in this stub group.\n@@ -5374,19 +5485,312 @@ Stub_table<size, big_endian>::define_stub_syms(Symbol_table* symtab)\n        bs != this->long_branch_stubs_.end();\n        ++bs)\n     {\n-      if (bs->first.save_res_)\n+      if (bs->second.save_res_)\n \tcontinue;\n \n       char* name = new char[8 + 13 + 16 + 1];\n       sprintf(name, \"%08x.long_branch.%llx\", this->uniq_,\n \t      static_cast<unsigned long long>(bs->first.dest_));\n       Address value = (this->stub_address() - this->address()\n-\t\t       + this->plt_size_ + bs->second);\n-      unsigned int stub_size = this->branch_stub_size(bs);\n+\t\t       + this->plt_size_ + bs->second.off_);\n+      bool need_lt = false;\n+      unsigned int stub_size = this->branch_stub_size(bs, &need_lt);\n       this->targ_->define_local(symtab, name, this, value, stub_size);\n     }\n }\n \n+// Emit the start of a __tls_get_addr_opt plt call stub.\n+\n+template<int size, bool big_endian>\n+bool\n+Stub_table<size, big_endian>::build_tls_opt_head(\n+     unsigned char** pp,\n+     typename Plt_stub_entries::const_iterator cs)\n+{\n+  if (this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+    {\n+      unsigned char* p = *pp;\n+      if (size == 64)\n+\t{\n+\t  write_insn<big_endian>(p, ld_11_3 + 0);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, ld_12_3 + 8);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, mr_0_3);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, cmpdi_11_0);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, add_3_12_13);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, beqlr);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, mr_3_0);\n+\t  p += 4;\n+\t  if (cs->second.r2save_ && !cs->second.localentry0_)\n+\t    {\n+\t      write_insn<big_endian>(p, mflr_11);\n+\t      p += 4;\n+\t      write_insn<big_endian>(p, (std_11_1 + this->targ_->stk_linker()));\n+\t      p += 4;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  write_insn<big_endian>(p, lwz_11_3 + 0);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, lwz_12_3 + 4);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, mr_0_3);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, cmpwi_11_0);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, add_3_12_2);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, beqlr);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, mr_3_0);\n+\t  p += 4;\n+\t  write_insn<big_endian>(p, nop);\n+\t  p += 4;\n+\t}\n+      *pp = p;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// Emit the tail of a __tls_get_addr_opt plt call stub.\n+\n+template<int size, bool big_endian>\n+bool\n+Stub_table<size, big_endian>::build_tls_opt_tail(\n+     unsigned char* p,\n+     typename Plt_stub_entries::const_iterator cs)\n+{\n+  if (size == 64\n+      && cs->second.r2save_\n+      && !cs->second.localentry0_\n+      && this->targ_->is_tls_get_addr_opt(cs->first.sym_))\n+    {\n+      write_insn<big_endian>(p, bctrl);\n+      p += 4;\n+      write_insn<big_endian>(p, ld_2_1 + this->targ_->stk_toc());\n+      p += 4;\n+      write_insn<big_endian>(p, ld_11_1 + this->targ_->stk_linker());\n+      p += 4;\n+      write_insn<big_endian>(p, mtlr_11);\n+      p += 4;\n+      write_insn<big_endian>(p, blr);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+// Gets the address of a label (1:) in r11 and builds an offset in r12,\n+// then adds it to r11 (LOAD false) or loads r12 from r11+r12 (LOAD true).\n+//\tmflr\t%r12\n+//\tbcl\t20,31,1f\n+// 1:\tmflr\t%r11\n+//\tmtlr\t%r12\n+//\tlis\t%r12,xxx-1b@highest\n+//\tori\t%r12,%r12,xxx-1b@higher\n+//\tsldi\t%r12,%r12,32\n+//\toris\t%r12,%r12,xxx-1b@high\n+//\tori\t%r12,%r12,xxx-1b@l\n+//\tadd/ldx\t%r12,%r11,%r12\n+\n+template<bool big_endian>\n+static unsigned char*\n+build_notoc_offset(unsigned char* p, uint64_t off, bool load)\n+{\n+  write_insn<big_endian>(p, mflr_12);\n+  p += 4;\n+  write_insn<big_endian>(p, bcl_20_31);\n+  p += 4;\n+  write_insn<big_endian>(p, mflr_11);\n+  p += 4;\n+  write_insn<big_endian>(p, mtlr_12);\n+  p += 4;\n+  if (off + 0x8000 < 0x10000)\n+    {\n+      if (load)\n+\twrite_insn<big_endian>(p, ld_12_11 + l(off));\n+      else\n+\twrite_insn<big_endian>(p, addi_12_11 + l(off));\n+    }\n+  else if (off + 0x80008000ULL < 0x100000000ULL)\n+    {\n+      write_insn<big_endian>(p, addis_12_11 + ha(off));\n+      p += 4;\n+      if (load)\n+\twrite_insn<big_endian>(p, ld_12_12 + l(off));\n+      else\n+\twrite_insn<big_endian>(p, addi_12_12 + l(off));\n+    }\n+  else\n+    {\n+      if (off + 0x800000000000ULL < 0x1000000000000ULL)\n+\t{\n+\t  write_insn<big_endian>(p, li_12_0 + ((off >> 32) & 0xffff));\n+\t  p += 4;\n+\t}\n+      else\n+\t{\n+\t  write_insn<big_endian>(p, lis_12 + ((off >> 48) & 0xffff));\n+\t  p += 4;\n+\t  if (((off >> 32) & 0xffff) != 0)\n+\t    {\n+\t      write_insn<big_endian>(p, ori_12_12_0 + ((off >> 32) & 0xffff));\n+\t      p += 4;\n+\t    }\n+\t}\n+      if (((off >> 32) & 0xffffffffULL) != 0)\n+\t{\n+\t  write_insn<big_endian>(p, sldi_12_12_32);\n+\t  p += 4;\n+\t}\n+      if (hi(off) != 0)\n+\t{\n+\t  write_insn<big_endian>(p, oris_12_12_0 + hi(off));\n+\t  p += 4;\n+\t}\n+      if (l(off) != 0)\n+\t{\n+\t  write_insn<big_endian>(p, ori_12_12_0 + l(off));\n+\t  p += 4;\n+\t}\n+      if (load)\n+\twrite_insn<big_endian>(p, ldx_12_11_12);\n+      else\n+\twrite_insn<big_endian>(p, add_12_11_12);\n+    }\n+  p += 4;\n+  return p;\n+}\n+\n+// Size of a given plt call stub.\n+\n+template<int size, bool big_endian>\n+unsigned int\n+Stub_table<size, big_endian>::plt_call_size(\n+    typename Plt_stub_entries::const_iterator p) const\n+{\n+  if (size == 32)\n+    {\n+      const Symbol* gsym = p->first.sym_;\n+      return (4 * 4\n+\t      + (this->targ_->is_tls_get_addr_opt(gsym) ? 8 * 4 : 0));\n+    }\n+\n+  const Output_data_plt_powerpc<size, big_endian>* plt;\n+  uint64_t plt_addr = this->plt_off(p, &plt);\n+  plt_addr += plt->address();\n+  unsigned int bytes = 0;\n+  const Symbol* gsym = p->first.sym_;\n+  if (this->targ_->is_tls_get_addr_opt(gsym))\n+    {\n+      if (p->second.r2save_ && !p->second.localentry0_)\n+\tbytes = 13 * 4;\n+      else\n+\tbytes = 7 * 4;\n+    }\n+\n+  if (p->second.r2save_)\n+    bytes += 4;\n+\n+  if (p->second.notoc_)\n+    {\n+      uint64_t from = this->stub_address() + p->second.off_ + bytes + 2 * 4;\n+      if (bytes > 32)\n+\tfrom -= 4 * 4;\n+      uint64_t off = plt_addr - from;\n+      if (off + 0x8000 < 0x10000)\n+\tbytes += 7 * 4;\n+      else if (off + 0x80008000ULL < 0x100000000ULL)\n+\tbytes += 8 * 4;\n+      else\n+\t{\n+\t  bytes += 8 * 4;\n+\t  if (off + 0x800000000000ULL >= 0x1000000000000ULL\n+\t      && ((off >> 32) & 0xffff) != 0)\n+\t    bytes += 4;\n+\t  if (((off >> 32) & 0xffffffffULL) != 0)\n+\t    bytes += 4;\n+\t  if (hi(off) != 0)\n+\t    bytes += 4;\n+\t  if (l(off) != 0)\n+\t    bytes += 4;\n+\t}\n+      return bytes;\n+    }\n+\n+  uint64_t got_addr = this->targ_->got_section()->output_section()->address();\n+  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n+    <const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n+  got_addr += ppcobj->toc_base_offset();\n+  uint64_t off = plt_addr - got_addr;\n+  bytes += 3 * 4 + 4 * (ha(off) != 0);\n+  if (this->targ_->abiversion() < 2)\n+    {\n+      bool static_chain = parameters->options().plt_static_chain();\n+      bool thread_safe = this->targ_->plt_thread_safe();\n+      bytes += (4\n+\t\t+ 4 * static_chain\n+\t\t+ 8 * thread_safe\n+\t\t+ 4 * (ha(off + 8 + 8 * static_chain) != ha(off)));\n+    }\n+  return bytes;\n+}\n+\n+// Return long branch stub size.\n+\n+template<int size, bool big_endian>\n+unsigned int\n+Stub_table<size, big_endian>::branch_stub_size(\n+     typename Branch_stub_entries::const_iterator p,\n+     bool* need_lt)\n+{\n+  Address loc = this->stub_address() + this->last_plt_size_ + p->second.off_;\n+  if (size == 32)\n+    {\n+      if (p->first.dest_ - loc + (1 << 25) < 2 << 25)\n+\treturn 4;\n+      if (parameters->options().output_is_position_independent())\n+\treturn 32;\n+      return 16;\n+    }\n+\n+  uint64_t off = p->first.dest_ - loc;\n+  if (p->second.notoc_)\n+    {\n+      off -= 8;\n+      if (off + 0x8000 < 0x10000)\n+\treturn 24;\n+      if (off + 0x80008000ULL < 0x100000000ULL)\n+\t{\n+\t  if (off + 24 + (1 << 25) < 2 << 25)\n+\t    return 28;\n+\t  return 32;\n+\t}\n+      unsigned int bytes = 32;\n+      if (off + 0x800000000000ULL >= 0x1000000000000ULL\n+\t  && ((off >> 32) & 0xffff) != 0)\n+\tbytes += 4;\n+      if (((off >> 32) & 0xffffffffULL) != 0)\n+\tbytes += 4;\n+      if (hi(off) != 0)\n+\tbytes += 4;\n+      if (l(off) != 0)\n+\tbytes += 4;\n+      return bytes;\n+    }\n+\n+  if (off + (1 << 25) < 2 << 25)\n+    return 4;\n+  *need_lt = true;\n+  return 16;\n+}\n+\n template<int size, bool big_endian>\n void\n Stub_table<size, big_endian>::plt_error(const Plt_stub_key& p)\n@@ -5423,9 +5827,64 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t= this->targ_->got_section();\n       Address got_os_addr = got->output_section()->address();\n \n-      if (!this->plt_call_stubs_.empty())\n+      if (!this->plt_call_stubs_.empty()\n+\t  && this->targ_->abiversion() >= 2)\n \t{\n-\t  // Write out plt call stubs.\n+\t  // Write out plt call stubs for ELFv2.\n+\t  typename Plt_stub_entries::const_iterator cs;\n+\t  for (cs = this->plt_call_stubs_.begin();\n+\t       cs != this->plt_call_stubs_.end();\n+\t       ++cs)\n+\t    {\n+\t      const Output_data_plt_powerpc<size, big_endian>* plt;\n+\t      Address pltoff = this->plt_off(cs, &plt);\n+\t      Address plt_addr = pltoff + plt->address();\n+\n+\t      p = oview + cs->second.off_;\n+\t      this->build_tls_opt_head(&p, cs);\n+\t      if (cs->second.r2save_)\n+\t\t{\n+\t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n+\t\t  p += 4;\n+\t\t}\n+\t      if (cs->second.notoc_)\n+\t\t{\n+\t\t  Address from = this->stub_address() + (p - oview) + 8;\n+\t\t  Address off = plt_addr - from;\n+\t\t  p = build_notoc_offset<big_endian>(p, off, true);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n+\t\t    <const Powerpc_relobj<size, big_endian>*>(cs->first.object_);\n+\t\t  Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n+\t\t  Address off = plt_addr - got_addr;\n+\n+\t\t  if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)\n+\t\t    this->plt_error(cs->first);\n+\n+\t\t  if (ha(off) != 0)\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, addis_12_2 + ha(off));\n+\t\t      p += 4;\n+\t\t      write_insn<big_endian>(p, ld_12_12 + l(off));\n+\t\t      p += 4;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, ld_12_2 + l(off));\n+\t\t      p += 4;\n+\t\t    }\n+\t\t}\n+\t      write_insn<big_endian>(p, mtctr_12);\n+\t      p += 4;\n+\t      if (!this->build_tls_opt_tail(p, cs))\n+\t\twrite_insn<big_endian>(p, bctr);\n+\t    }\n+\t}\n+      else if (!this->plt_call_stubs_.empty())\n+\t{\n+\t  // Write out plt call stubs for ELFv1.\n \t  typename Plt_stub_entries::const_iterator cs;\n \t  for (cs = this->plt_call_stubs_.begin();\n \t       cs != this->plt_call_stubs_.end();\n@@ -5439,14 +5898,12 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n \t      Address off = plt_addr - got_addr;\n \n-\t      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)\n+\t      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0\n+\t\t  || cs->second.notoc_)\n \t\tthis->plt_error(cs->first);\n \n-\t      bool plt_load_toc = this->targ_->abiversion() < 2;\n-\t      bool static_chain\n-\t\t= plt_load_toc && parameters->options().plt_static_chain();\n-\t      bool thread_safe\n-\t\t= plt_load_toc && this->targ_->plt_thread_safe();\n+\t      bool static_chain = parameters->options().plt_static_chain();\n+\t      bool thread_safe = this->targ_->plt_thread_safe();\n \t      bool use_fake_dep = false;\n \t      Address cmp_branch_off = 0;\n \t      if (thread_safe)\n@@ -5472,132 +5929,71 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t}\n \n \t      p = oview + cs->second.off_;\n-\t      const Symbol* gsym = cs->first.sym_;\n-\t      if (this->targ_->is_tls_get_addr_opt(gsym))\n+\t      if (this->build_tls_opt_head(&p, cs))\n+\t\tuse_fake_dep = thread_safe;\n+\t      if (cs->second.r2save_)\n \t\t{\n-\t\t  write_insn<big_endian>(p, ld_11_3 + 0);\n+\t\t  write_insn<big_endian>(p, std_2_1 + this->targ_->stk_toc());\n \t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, ld_12_3 + 8);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, mr_0_3);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, cmpdi_11_0);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, add_3_12_13);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, beqlr);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, mr_3_0);\n-\t\t  p += 4;\n-\t\t  if (!cs->second.localentry0_)\n-\t\t    {\n-\t\t      write_insn<big_endian>(p, mflr_11);\n-\t\t      p += 4;\n-\t\t      write_insn<big_endian>(p, (std_11_1\n-\t\t\t\t\t\t + this->targ_->stk_linker()));\n-\t\t      p += 4;\n-\t\t    }\n-\t\t  use_fake_dep = thread_safe;\n \t\t}\n \t      if (ha(off) != 0)\n \t\t{\n-\t\t  if (cs->second.r2save_)\n-\t\t    {\n-\t\t      write_insn<big_endian>(p,\n-\t\t\t\t\t     std_2_1 + this->targ_->stk_toc());\n-\t\t      p += 4;\n-\t\t    }\n-\t\t  if (plt_load_toc)\n+\t\t  write_insn<big_endian>(p, addis_11_2 + ha(off));\n+\t\t  p += 4;\n+\t\t  write_insn<big_endian>(p, ld_12_11 + l(off));\n+\t\t  p += 4;\n+\t\t  if (ha(off + 8 + 8 * static_chain) != ha(off))\n \t\t    {\n-\t\t      write_insn<big_endian>(p, addis_11_2 + ha(off));\n-\t\t      p += 4;\n-\t\t      write_insn<big_endian>(p, ld_12_11 + l(off));\n+\t\t      write_insn<big_endian>(p, addi_11_11 + l(off));\n \t\t      p += 4;\n+\t\t      off = 0;\n \t\t    }\n-\t\t  else\n+\t\t  write_insn<big_endian>(p, mtctr_12);\n+\t\t  p += 4;\n+\t\t  if (use_fake_dep)\n \t\t    {\n-\t\t      write_insn<big_endian>(p, addis_12_2 + ha(off));\n+\t\t      write_insn<big_endian>(p, xor_2_12_12);\n \t\t      p += 4;\n-\t\t      write_insn<big_endian>(p, ld_12_12 + l(off));\n+\t\t      write_insn<big_endian>(p, add_11_11_2);\n \t\t      p += 4;\n \t\t    }\n-\t\t  if (plt_load_toc\n-\t\t      && ha(off + 8 + 8 * static_chain) != ha(off))\n-\t\t    {\n-\t\t      write_insn<big_endian>(p, addi_11_11 + l(off));\n-\t\t      p += 4;\n-\t\t      off = 0;\n-\t\t    }\n-\t\t  write_insn<big_endian>(p, mtctr_12);\n+\t\t  write_insn<big_endian>(p, ld_2_11 + l(off + 8));\n \t\t  p += 4;\n-\t\t  if (plt_load_toc)\n+\t\t  if (static_chain)\n \t\t    {\n-\t\t      if (use_fake_dep)\n-\t\t\t{\n-\t\t\t  write_insn<big_endian>(p, xor_2_12_12);\n-\t\t\t  p += 4;\n-\t\t\t  write_insn<big_endian>(p, add_11_11_2);\n-\t\t\t  p += 4;\n-\t\t\t}\n-\t\t      write_insn<big_endian>(p, ld_2_11 + l(off + 8));\n+\t\t      write_insn<big_endian>(p, ld_11_11 + l(off + 16));\n \t\t      p += 4;\n-\t\t      if (static_chain)\n-\t\t\t{\n-\t\t\t  write_insn<big_endian>(p, ld_11_11 + l(off + 16));\n-\t\t\t  p += 4;\n-\t\t\t}\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (cs->second.r2save_)\n-\t\t    {\n-\t\t      write_insn<big_endian>(p,\n-\t\t\t\t\t     std_2_1 + this->targ_->stk_toc());\n-\t\t      p += 4;\n-\t\t    }\n \t\t  write_insn<big_endian>(p, ld_12_2 + l(off));\n \t\t  p += 4;\n-\t\t  if (plt_load_toc\n-\t\t      && ha(off + 8 + 8 * static_chain) != ha(off))\n+\t\t  if (ha(off + 8 + 8 * static_chain) != ha(off))\n \t\t    {\n \t\t      write_insn<big_endian>(p, addi_2_2 + l(off));\n \t\t      p += 4;\n \t\t      off = 0;\n \t\t    }\n \t\t  write_insn<big_endian>(p, mtctr_12);\n \t\t  p += 4;\n-\t\t  if (plt_load_toc)\n+\t\t  if (use_fake_dep)\n \t\t    {\n-\t\t      if (use_fake_dep)\n-\t\t\t{\n-\t\t\t  write_insn<big_endian>(p, xor_11_12_12);\n-\t\t\t  p += 4;\n-\t\t\t  write_insn<big_endian>(p, add_2_2_11);\n-\t\t\t  p += 4;\n-\t\t\t}\n-\t\t      if (static_chain)\n-\t\t\t{\n-\t\t\t  write_insn<big_endian>(p, ld_11_2 + l(off + 16));\n-\t\t\t  p += 4;\n-\t\t\t}\n-\t\t      write_insn<big_endian>(p, ld_2_2 + l(off + 8));\n+\t\t      write_insn<big_endian>(p, xor_11_12_12);\n+\t\t      p += 4;\n+\t\t      write_insn<big_endian>(p, add_2_2_11);\n \t\t      p += 4;\n \t\t    }\n-\t\t}\n-\t      if (!cs->second.localentry0_\n-\t\t  && this->targ_->is_tls_get_addr_opt(gsym))\n-\t\t{\n-\t\t  write_insn<big_endian>(p, bctrl);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, ld_2_1 + this->targ_->stk_toc());\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, ld_11_1 + this->targ_->stk_linker());\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, mtlr_11);\n+\t\t  if (static_chain)\n+\t\t    {\n+\t\t      write_insn<big_endian>(p, ld_11_2 + l(off + 16));\n+\t\t      p += 4;\n+\t\t    }\n+\t\t  write_insn<big_endian>(p, ld_2_2 + l(off + 8));\n \t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, blr);\n \t\t}\n+\t      if (this->build_tls_opt_tail(p, cs))\n+\t\t;\n \t      else if (thread_safe && !use_fake_dep)\n \t\t{\n \t\t  write_insn<big_endian>(p, cmpldi_2_0);\n@@ -5617,14 +6013,19 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t   bs != this->long_branch_stubs_.end();\n \t   ++bs)\n \t{\n-\t  if (bs->first.save_res_)\n+\t  if (bs->second.save_res_)\n \t    continue;\n-\t  p = oview + this->plt_size_ + bs->second;\n-\t  Address loc = this->stub_address() + this->plt_size_ + bs->second;\n+\t  Address off = this->plt_size_ + bs->second.off_;\n+\t  p = oview + off;\n+\t  Address loc = this->stub_address() + off;\n \t  Address delta = bs->first.dest_ - loc;\n-\t  if (delta + (1 << 25) < 2 << 25)\n-\t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n-\t  else\n+\t  if (bs->second.notoc_)\n+\t    {\n+\t      unsigned char* startp = p;\n+\t      p = build_notoc_offset<big_endian>(p, off, false);\n+\t      delta -= p - startp;\n+\t    }\n+\t  else if (delta + (1 << 25) >= 2 << 25)\n \t    {\n \t      Address brlt_addr\n \t\t= this->targ_->find_branch_lookup_table(bs->first.dest_);\n@@ -5634,19 +6035,28 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      Address brltoff = brlt_addr - got_addr;\n \t      if (ha(brltoff) == 0)\n \t\t{\n-\t\t  write_insn<big_endian>(p, ld_12_2 + l(brltoff)),\tp += 4;\n+\t\t  write_insn<big_endian>(p, ld_12_2 + l(brltoff));\n+\t\t  p += 4;\n \t\t}\n \t      else\n \t\t{\n-\t\t  write_insn<big_endian>(p, addis_12_2 + ha(brltoff)),\tp += 4;\n-\t\t  write_insn<big_endian>(p, ld_12_12 + l(brltoff)),\tp += 4;\n+\t\t  write_insn<big_endian>(p, addis_12_2 + ha(brltoff));\n+\t\t  p += 4;\n+\t\t  write_insn<big_endian>(p, ld_12_12 + l(brltoff));\n+\t\t  p += 4;\n \t\t}\n-\t      write_insn<big_endian>(p, mtctr_12),\t\t\tp += 4;\n+\t    }\n+\t  if (delta + (1 << 25) < 2 << 25)\n+\t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n+\t  else\n+\t    {\n+\t      write_insn<big_endian>(p, mtctr_12);\n+\t      p += 4;\n \t      write_insn<big_endian>(p, bctr);\n \t    }\n \t}\n     }\n-  else\n+  else // size == 32\n     {\n       if (!this->plt_call_stubs_.empty())\n \t{\n@@ -5664,26 +6074,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      plt_addr += plt->address();\n \n \t      p = oview + cs->second.off_;\n-\t      const Symbol* gsym = cs->first.sym_;\n-\t      if (this->targ_->is_tls_get_addr_opt(gsym))\n-\t\t{\n-\t\t  write_insn<big_endian>(p, lwz_11_3 + 0);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, lwz_12_3 + 4);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, mr_0_3);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, cmpwi_11_0);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, add_3_12_2);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, beqlr);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, mr_3_0);\n-\t\t  p += 4;\n-\t\t  write_insn<big_endian>(p, nop);\n-\t\t  p += 4;\n-\t\t}\n+\t      this->build_tls_opt_head(&p, cs);\n \t      if (parameters->options().output_is_position_independent())\n \t\t{\n \t\t  Address got_addr;\n@@ -5738,10 +6129,11 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t   bs != this->long_branch_stubs_.end();\n \t   ++bs)\n \t{\n-\t  if (bs->first.save_res_)\n+\t  if (bs->second.save_res_)\n \t    continue;\n-\t  p = oview + this->plt_size_ + bs->second;\n-\t  Address loc = this->stub_address() + this->plt_size_ + bs->second;\n+\t  Address off = this->plt_size_ + bs->second.off_;\n+\t  p = oview + off;\n+\t  Address loc = this->stub_address() + off;\n \t  Address delta = bs->first.dest_ - loc;\n \t  if (delta + (1 << 25) < 2 << 25)\n \t    write_insn<big_endian>(p, b | (delta & 0x3fffffc));\n@@ -6486,6 +6878,10 @@ Target_powerpc<size, big_endian>::Scan::get_reference_flags(\n       ref = Symbol::RELATIVE_REF;\n       break;\n \n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_POWERPC_REL24:\n     case elfcpp::R_PPC_PLTREL24:\n     case elfcpp::R_POWERPC_REL14:\n@@ -6700,10 +7096,16 @@ Target_powerpc<size, big_endian>::Scan::reloc_needs_plt_for_ifunc(\n     case elfcpp::R_PPC64_PLT16_LO_DS:\n     case elfcpp::R_POWERPC_PLTSEQ:\n     case elfcpp::R_POWERPC_PLTCALL:\n+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:\n+    case elfcpp::R_PPC64_PLTCALL_NOTOC:\n       return true;\n       break;\n \n     // Function calls are good, and these do need a PLT entry.\n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_POWERPC_ADDR24:\n     case elfcpp::R_POWERPC_ADDR14:\n     case elfcpp::R_POWERPC_ADDR14_BRTAKEN:\n@@ -6839,6 +7241,8 @@ Target_powerpc<size, big_endian>::Scan::local(\n     case elfcpp::R_PPC64_ENTRY:\n     case elfcpp::R_POWERPC_PLTSEQ:\n     case elfcpp::R_POWERPC_PLTCALL:\n+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:\n+    case elfcpp::R_PPC64_PLTCALL_NOTOC:\n       break;\n \n     case elfcpp::R_PPC64_TOC:\n@@ -6941,6 +7345,10 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t}\n       break;\n \n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_POWERPC_REL24:\n     case elfcpp::R_PPC_PLTREL24:\n     case elfcpp::R_PPC_LOCAL24PC:\n@@ -7407,6 +7815,8 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_PPC64_ENTRY:\n     case elfcpp::R_POWERPC_PLTSEQ:\n     case elfcpp::R_POWERPC_PLTCALL:\n+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:\n+    case elfcpp::R_PPC64_PLTCALL_NOTOC:\n       break;\n \n     case elfcpp::R_PPC64_TOC:\n@@ -7550,6 +7960,10 @@ Target_powerpc<size, big_endian>::Scan::global(\n \ttarget->make_plt_entry(symtab, layout, gsym);\n       break;\n \n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_PPC_PLTREL24:\n     case elfcpp::R_POWERPC_REL24:\n       if (!is_ifunc)\n@@ -8902,7 +9316,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       break;\n     case Track_tls::SKIP:\n       if (is_plt16_reloc<size>(r_type)\n-\t  || r_type == elfcpp::R_POWERPC_PLTSEQ)\n+\t  || r_type == elfcpp::R_POWERPC_PLTSEQ\n+\t  || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC)\n \t{\n \t  Insn* iview = reinterpret_cast<Insn*>(view);\n \t  elfcpp::Swap<32, big_endian>::writeval(iview, nop);\n@@ -8934,14 +9349,16 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       && !is_plt16_reloc<size>(r_type)\n       && r_type != elfcpp::R_POWERPC_PLTSEQ\n       && r_type != elfcpp::R_POWERPC_PLTCALL\n+      && r_type != elfcpp::R_PPC64_PLTSEQ_NOTOC\n+      && r_type != elfcpp::R_PPC64_PLTCALL_NOTOC\n       && (!psymval->is_ifunc_symbol()\n \t  || Scan::reloc_needs_plt_for_ifunc(target, object, r_type, false)))\n     {\n       if (size == 64\n \t  && gsym != NULL\n \t  && target->abiversion() >= 2\n \t  && !parameters->options().output_is_position_independent()\n-\t  && !is_branch_reloc(r_type))\n+\t  && !is_branch_reloc<size>(r_type))\n \t{\n \t  Address off = target->glink_section()->find_global_entry(gsym);\n \t  if (off != invalid_address)\n@@ -8959,7 +9376,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t      && !(size == 32\n \t\t   && gsym != NULL\n \t\t   && !parameters->options().output_is_position_independent()\n-\t\t   && !is_branch_reloc(r_type)))\n+\t\t   && !is_branch_reloc<size>(r_type)))\n \t    stub_table = object->stub_table(relinfo->data_shndx);\n \t  if (stub_table == NULL)\n \t    {\n@@ -8986,7 +9403,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t  size_t reloc_count = shdr.get_sh_size() / reloc_size;\n \t\t  if (size == 64\n \t\t      && ent->r2save_\n-\t\t      && relnum < reloc_count - 1)\n+\t\t      && r_type == elfcpp::R_PPC64_REL24_NOTOC)\n+\t\t    value += 4;\n+\t\t  else if (size == 64\n+\t\t\t   && ent->r2save_\n+\t\t\t   && relnum < reloc_count - 1)\n \t\t    {\n \t\t      Reltype next_rela(preloc + reloc_size);\n \t\t      if (elfcpp::elf_r_type<size>(next_rela.get_r_info())\n@@ -9033,7 +9454,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     }\n   else if (!has_plt_offset\n \t   && (is_plt16_reloc<size>(r_type)\n-\t       || r_type == elfcpp::R_POWERPC_PLTSEQ))\n+\t       || r_type == elfcpp::R_POWERPC_PLTSEQ\n+\t       || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC))\n     {\n       Insn* iview = reinterpret_cast<Insn*>(view);\n       elfcpp::Swap<32, big_endian>::writeval(iview, nop);\n@@ -9375,7 +9797,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     }\n   else if (!has_stub_value)\n     {\n-      if (!has_plt_offset && r_type == elfcpp::R_POWERPC_PLTCALL)\n+      if (!has_plt_offset && (r_type == elfcpp::R_POWERPC_PLTCALL\n+\t\t\t      || r_type == elfcpp::R_PPC64_PLTCALL_NOTOC))\n \t{\n \t  // PLTCALL without plt entry => convert to direct call\n \t  Insn* iview = reinterpret_cast<Insn*>(view);\n@@ -9384,6 +9807,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  elfcpp::Swap<32, big_endian>::writeval(iview, insn);\n \t  if (size == 32)\n \t    r_type = elfcpp::R_PPC_PLTREL24;\n+\t  else if (r_type == elfcpp::R_PPC64_PLTCALL_NOTOC)\n+\t    r_type = elfcpp::R_PPC64_REL24_NOTOC;\n \t  else\n \t    r_type = elfcpp::R_POWERPC_REL24;\n \t}\n@@ -9395,7 +9820,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t|| r_type == elfcpp::R_POWERPC_PLT16_HA)))\n \taddend = rela.get_r_addend();\n       value = psymval->value(object, addend);\n-      if (size == 64 && is_branch_reloc(r_type))\n+      if (size == 64 && is_branch_reloc<size>(r_type))\n \t{\n \t  if (target->abiversion() >= 2)\n \t    {\n@@ -9411,19 +9836,29 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t\t\t\t&value, &dest_shndx);\n \t    }\n \t}\n-      Address max_branch_offset = max_branch_delta(r_type);\n+      Address max_branch_offset = max_branch_delta<size>(r_type);\n       if (max_branch_offset != 0\n-\t  && value - address + max_branch_offset >= 2 * max_branch_offset)\n+\t  && (value - address + max_branch_offset >= 2 * max_branch_offset\n+\t      || (size == 64\n+\t\t  && r_type == elfcpp::R_PPC64_REL24_NOTOC\n+\t\t  && (gsym != NULL\n+\t\t      ? object->ppc64_needs_toc(gsym)\n+\t\t      : object->ppc64_needs_toc(r_sym)))))\n \t{\n \t  Stub_table<size, big_endian>* stub_table\n \t    = object->stub_table(relinfo->data_shndx);\n \t  if (stub_table != NULL)\n \t    {\n-\t      Address off = stub_table->find_long_branch_entry(object, value);\n-\t      if (off != invalid_address)\n+\t      const typename Stub_table<size, big_endian>::Branch_stub_ent* ent\n+\t\t= stub_table->find_long_branch_entry(object, value);\n+\t      if (ent != NULL)\n \t\t{\n-\t\t  value = (stub_table->stub_address() + stub_table->plt_size()\n-\t\t\t   + off);\n+\t\t  if (ent->save_res_)\n+\t\t    value = (value - target->savres_section()->address()\n+\t\t\t     + stub_table->branch_size());\n+\t\t  else\n+\t\t    value = (stub_table->stub_address() + stub_table->plt_size()\n+\t\t\t     + ent->off_);\n \t\t  has_stub_value = true;\n \t\t}\n \t    }\n@@ -9432,6 +9867,10 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \n   switch (r_type)\n     {\n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_PPC64_REL64:\n     case elfcpp::R_POWERPC_REL32:\n     case elfcpp::R_POWERPC_REL24:\n@@ -9871,6 +10310,10 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       overflow = Reloc::CHECK_LOW_INSN;\n       break;\n \n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tbreak;\n+      // Fall through.\n     case elfcpp::R_POWERPC_ADDR24:\n     case elfcpp::R_POWERPC_ADDR14:\n     case elfcpp::R_POWERPC_ADDR14_BRTAKEN:\n@@ -9924,6 +10367,8 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     case elfcpp::R_POWERPC_GNU_VTENTRY:\n     case elfcpp::R_POWERPC_PLTSEQ:\n     case elfcpp::R_POWERPC_PLTCALL:\n+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:\n+    case elfcpp::R_PPC64_PLTCALL_NOTOC:\n       break;\n \n     case elfcpp::R_PPC64_ADDR64:\n@@ -9954,6 +10399,10 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       status = Reloc::addr32_u(view, value, overflow);\n       break;\n \n+    case elfcpp::R_PPC64_REL24_NOTOC:\n+      if (size == 32)\n+\tgoto unsupp; // R_PPC_EMB_RELSDA\n+      // Fall through.\n     case elfcpp::R_POWERPC_ADDR24:\n     case elfcpp::R_POWERPC_REL24:\n     case elfcpp::R_PPC_PLTREL24:\n@@ -10182,7 +10631,6 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     case elfcpp::R_PPC64_PLTGOT16_HA:\n     case elfcpp::R_PPC64_PLTGOT16_DS:\n     case elfcpp::R_PPC64_PLTGOT16_LO_DS:\n-    case elfcpp::R_PPC_EMB_RELSDA:\n     case elfcpp::R_PPC_TOC16:\n     default:\n     unsupp:\n@@ -10215,7 +10663,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       && (has_stub_value\n \t  || !(gsym != NULL\n \t       && gsym->is_undefined()\n-\t       && is_branch_reloc(r_type))))\n+\t       && is_branch_reloc<size>(r_type))))\n     {\n       gold_error_at_location(relinfo, relnum, rela.get_r_offset(),\n \t\t\t     _(\"relocation overflow\"));"
    }
  ]
}