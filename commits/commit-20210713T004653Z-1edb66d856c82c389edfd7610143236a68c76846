{
  "sha": "1edb66d856c82c389edfd7610143236a68c76846",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWVkYjY2ZDg1NmM4MmMzODllZGZkNzYxMDE0MzIzNmE2OGM3Njg0Ng==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-28T03:37:03Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-13T00:46:53Z"
    },
    "message": "gdb: make thread_info::suspend private, add getters / setters\n\nA following patch will want to take some action when a pending wait\nstatus is set on or removed from a thread.  Add a getter and a setter on\nthread_info for the pending waitstatus, so that we can add some code in\nthe setter later.\n\nThe thing is, the pending wait status field is in the\nthread_suspend_state, along with other fields that we need to backup\nbefore and restore after the thread does an inferior function call.\nTherefore, make the thread_suspend_state member private\n(thread_info::suspend becomes thread_info::m_suspend), and add getters /\nsetters for all of its fields:\n\n - pending wait status\n - stop signal\n - stop reason\n - stop pc\n\nFor the pending wait status, add the additional has_pending_waitstatus\nand clear_pending_waitstatus methods.\n\nI think this makes the thread_info interface a bit nicer, because we\nnow access the fields as:\n\n  thread->stop_pc ()\n\nrather than\n\n  thread->suspend.stop_pc\n\nThe stop_pc field being in the `suspend` structure is an implementation\ndetail of thread_info that callers don't need to be aware of.\n\nFor the backup / restore of the thread_suspend_state structure, add\nsave_suspend_to and restore_suspend_from methods.  You might wonder why\n`save_suspend_to`, as opposed to a simple getter like\n\n  thread_suspend_state &suspend ();\n\nI want to make it clear that this is to be used only for backing up and\nrestoring the suspend state, _not_ to access fields like:\n\n  thread->suspend ()->stop_pc\n\nAdding some getters / setters allows adding some assertions.  I find\nthat this helps understand how things are supposed to work.  Add:\n\n - When getting the pending status (pending_waitstatus method), ensure\n   that there is a pending status.\n - When setting a pending status (set_pending_waitstatus method), ensure\n   there is no pending status.\n\nThere is one case I found where this wasn't true - in\nremote_target::process_initial_stop_replies - which needed adjustments\nto respect that contract.  I think it's because\nprocess_initial_stop_replies is kind of (ab)using the\nthread_info::suspend::waitstatus to store some statuses temporarily, for\nits internal use (statuses it doesn't intent on leaving pending).\n\nprocess_initial_stop_replies pulls out stop replies received during the\ninitial connection using target_wait.  It always stores the received\nevent in `evthread->suspend.waitstatus`.  But it only sets\nwaitstatus_pending_p, if it deems the event interesting enough to leave\npending, to be reported to the core:\n\n      if (ws.kind != TARGET_WAITKIND_STOPPED\n\t  || ws.value.sig != GDB_SIGNAL_0)\n\tevthread->suspend.waitstatus_pending_p = 1;\n\nIt later uses this flag a bit below, to choose which thread to make the\n\"selected\" one:\n\n      if (selected == NULL\n\t  && thread->suspend.waitstatus_pending_p)\n\tselected = thread;\n\nAnd ultimately that's used if the user-visible mode is all-stop, so that\nwe print the stop for that interesting thread:\n\n  /* In all-stop, we only print the status of one thread, and leave\n     others with their status pending.  */\n  if (!non_stop)\n    {\n      thread_info *thread = selected;\n      if (thread == NULL)\n\tthread = lowest_stopped;\n      if (thread == NULL)\n\tthread = first;\n\n      print_one_stopped_thread (thread);\n    }\n\nBut in any case (all-stop or non-stop), print_one_stopped_thread needs\nto access the waitstatus value of these threads that don't have a\npending waitstatus (those that had TARGET_WAITKIND_STOPPED +\nGDB_SIGNAL_0).  This doesn't work with the assertions I've\nput.\n\nSo, change the code to only set the thread's wait status if it is an\ninteresting one that we are going to leave pending.  If the thread\nstopped due to a non-interesting event (TARGET_WAITKIND_STOPPED +\nGDB_SIGNAL_0), don't store it.  Adjust print_one_stopped_thread to\nunderstand that if a thread has no pending waitstatus, it's because it\nstopped with TARGET_WAITKIND_STOPPED + GDB_SIGNAL_0.\n\nThe call to set_last_target_status also uses the pending waitstatus.\nHowever, given that the pending waitstatus for the thread may have been\ncleared in print_one_stopped_thread (and that there might not even be a\npending waitstatus in the first place, as explained above), it is no\nlonger possible to do it at this point.  To fix that, move the call to\nset_last_target_status in print_one_stopped_thread.  I think this will\npreserve the existing behavior, because set_last_target_status is\ncurrently using the current thread's wait status.  And the current\nthread is the last one for which print_one_stopped_thread is called.  So\nby calling set_last_target_status in print_one_stopped_thread, we'll get\nthe same result.  set_last_target_status will possibly be called\nmultiple times, but only the last call will matter.  It just means\npossibly more calls to set_last_target_status, but those are cheap.\n\nChange-Id: Iedab9653238eaf8231abcf0baa20145acc8b77a7",
    "tree": {
      "sha": "1135a03310b26169ca204e1060483665e9ddeb69",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1135a03310b26169ca204e1060483665e9ddeb69"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1edb66d856c82c389edfd7610143236a68c76846",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1edb66d856c82c389edfd7610143236a68c76846",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1edb66d856c82c389edfd7610143236a68c76846",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1edb66d856c82c389edfd7610143236a68c76846/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7846f3aa61ae21fae8c3861917b44388de6b9ede"
    }
  ],
  "stats": {
    "total": 572,
    "additions": 332,
    "deletions": 240
  },
  "files": [
    {
      "sha": "7fd23348a8e8a31a3f543940e14e6649519ed5e4",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -407,7 +407,7 @@ breakpoints_should_be_inserted_now (void)\n       /* Don't remove breakpoints yet if, even though all threads are\n \t stopped, we still have events to process.  */\n       for (thread_info *tp : all_non_exited_threads ())\n-\tif (tp->resumed () && tp->suspend.waitstatus_pending_p)\n+\tif (tp->resumed () && tp->has_pending_waitstatus ())\n \t  return 1;\n     }\n   return 0;"
    },
    {
      "sha": "52a6281290fabb96c560e16b0a93d77a3bc27bbc",
      "filename": "gdb/elf-none-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/elf-none-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/elf-none-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elf-none-tdep.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -92,7 +92,7 @@ elf_none_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd,\n      that stopped SIGNALLED_THR.  */\n   gdb_signal stop_signal;\n   if (signalled_thr != nullptr)\n-    stop_signal = signalled_thr->suspend.stop_signal;\n+    stop_signal = signalled_thr->stop_signal ();\n   else\n     stop_signal = GDB_SIGNAL_0;\n "
    },
    {
      "sha": "eb792c36a54d6d17b992b5dcaf0254b5c467142b",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -634,7 +634,7 @@ fbsd_core_xfer_siginfo (struct gdbarch *gdbarch, gdb_byte *readbuf,\n static int\n find_signalled_thread (struct thread_info *info, void *data)\n {\n-  if (info->suspend.stop_signal != GDB_SIGNAL_0\n+  if (info->stop_signal () != GDB_SIGNAL_0\n       && info->ptid.pid () == inferior_ptid.pid ())\n     return 1;\n \n@@ -708,7 +708,7 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n      In case there's more than one signalled thread, prefer the\n      current thread, if it is signalled.  */\n   curr_thr = inferior_thread ();\n-  if (curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+  if (curr_thr->stop_signal () != GDB_SIGNAL_0)\n     signalled_thr = curr_thr;\n   else\n     {\n@@ -717,7 +717,7 @@ fbsd_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n \tsignalled_thr = curr_thr;\n     }\n \n-  enum gdb_signal stop_signal = signalled_thr->suspend.stop_signal;\n+  enum gdb_signal stop_signal = signalled_thr->stop_signal ();\n   gcore_elf_build_thread_register_notes (gdbarch, signalled_thr, stop_signal,\n \t\t\t\t\t obfd, &note_data, note_size);\n   for (thread_info *thr : current_inferior ()->non_exited_threads ())"
    },
    {
      "sha": "dccb77052bacab2f7da7c4fa8a7d0a64ced51909",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -586,11 +586,11 @@ gcore_find_signalled_thread ()\n {\n   thread_info *curr_thr = inferior_thread ();\n   if (curr_thr->state != THREAD_EXITED\n-      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+      && curr_thr->stop_signal () != GDB_SIGNAL_0)\n     return curr_thr;\n \n   for (thread_info *thr : current_inferior ()->non_exited_threads ())\n-    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n+    if (thr->stop_signal () != GDB_SIGNAL_0)\n       return thr;\n \n   /* Default to the current thread, unless it has exited.  */"
    },
    {
      "sha": "e9d1bbedfb9a139de3337a275c1788025b7b92ba",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 89,
      "deletions": 3,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -310,9 +310,91 @@ class thread_info : public refcounted_object,\n      See `struct thread_control_state'.  */\n   thread_control_state control;\n \n-  /* State of inferior thread to restore after GDB is done with an inferior\n-     call.  See `struct thread_suspend_state'.  */\n-  thread_suspend_state suspend;\n+  /* Save M_SUSPEND to SUSPEND.  */\n+\n+  void save_suspend_to (thread_suspend_state &suspend) const\n+  {\n+    suspend = m_suspend;\n+  }\n+\n+  /* Restore M_SUSPEND from SUSPEND.  */\n+\n+  void restore_suspend_from (const thread_suspend_state &suspend)\n+  {\n+    m_suspend = suspend;\n+  }\n+\n+  /* Return this thread's stop PC.  */\n+\n+  CORE_ADDR stop_pc () const\n+  {\n+    return m_suspend.stop_pc;\n+  }\n+\n+  /* Set this thread's stop PC.  */\n+\n+  void set_stop_pc (CORE_ADDR stop_pc)\n+  {\n+    m_suspend.stop_pc = stop_pc;\n+  }\n+\n+  /* Return true if this thread has a pending wait status.  */\n+\n+  bool has_pending_waitstatus () const\n+  {\n+    return m_suspend.waitstatus_pending_p;\n+  }\n+\n+  /* Get this thread's pending wait status.\n+\n+     May only be called if has_pending_waitstatus returns true.  */\n+\n+  const target_waitstatus &pending_waitstatus () const\n+  {\n+    gdb_assert (this->has_pending_waitstatus ());\n+\n+    return m_suspend.waitstatus;\n+  }\n+\n+  /* Set this thread's pending wait status.\n+\n+     May only be called if has_pending_waitstatus returns false.  */\n+\n+  void set_pending_waitstatus (const target_waitstatus &ws);\n+\n+  /* Clear this thread's pending wait status.\n+\n+     May only be called if has_pending_waitstatus returns true.  */\n+\n+  void clear_pending_waitstatus ();\n+\n+  /* Return this thread's stop signal.  */\n+\n+  gdb_signal stop_signal () const\n+  {\n+    return m_suspend.stop_signal;\n+  }\n+\n+  /* Set this thread's stop signal.  */\n+\n+  void set_stop_signal (gdb_signal sig)\n+  {\n+    m_suspend.stop_signal = sig;\n+  }\n+\n+  /* Return this thread's stop reason.  */\n+\n+  target_stop_reason stop_reason () const\n+  {\n+    return m_suspend.stop_reason;\n+  }\n+\n+  /* Set this thread's stop reason.  */\n+\n+  void set_stop_reason (target_stop_reason reason)\n+  {\n+    m_suspend.stop_reason = reason;\n+  }\n \n   int current_line = 0;\n   struct symtab *current_symtab = NULL;\n@@ -400,6 +482,10 @@ class thread_info : public refcounted_object,\n      we should not process that wait status if we didn't try to let\n      the thread run.  */\n   bool m_resumed = false;\n+\n+  /* State of inferior thread to restore after GDB is done with an inferior\n+     call.  See `struct thread_suspend_state'.  */\n+  thread_suspend_state m_suspend;\n };\n \n /* A gdb::ref_ptr pointer to a thread_info.  */"
    },
    {
      "sha": "0a5edef698249fb17315de3b64e5b2a944ce7cc0",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 17,
      "deletions": 16,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -298,11 +298,11 @@ post_create_inferior (int from_tty)\n      missing registers info), ignore it.  */\n   thread_info *thr = inferior_thread ();\n \n-  thr->suspend.stop_pc = 0;\n+  thr->set_stop_pc (0);\n   try\n     {\n       regcache *rc = get_thread_regcache (thr);\n-      thr->suspend.stop_pc = regcache_read_pc (rc);\n+      thr->set_stop_pc (regcache_read_pc (rc));\n     }\n   catch (const gdb_exception_error &ex)\n     {\n@@ -534,9 +534,10 @@ run_command_1 (const char *args, int from_tty, enum run_how run_how)\n   if (run_how == RUN_STOP_AT_FIRST_INSN)\n     {\n       thread_info *thr = inferior_thread ();\n-      thr->suspend.waitstatus_pending_p = 1;\n-      thr->suspend.waitstatus.kind = TARGET_WAITKIND_STOPPED;\n-      thr->suspend.waitstatus.value.sig = GDB_SIGNAL_0;\n+      target_waitstatus ws;\n+      ws.kind = TARGET_WAITKIND_STOPPED;\n+      ws.value.sig = GDB_SIGNAL_0;\n+      thr->set_pending_waitstatus (ws);\n     }\n \n   /* Start the target running.  Do not use -1 continuation as it would skip\n@@ -1223,15 +1224,15 @@ signal_command (const char *signum_exp, int from_tty)\n \t  if (tp == current)\n \t    continue;\n \n-\t  if (tp->suspend.stop_signal != GDB_SIGNAL_0\n-\t      && signal_pass_state (tp->suspend.stop_signal))\n+\t  if (tp->stop_signal () != GDB_SIGNAL_0\n+\t      && signal_pass_state (tp->stop_signal ()))\n \t    {\n \t      if (!must_confirm)\n \t\tprintf_unfiltered (_(\"Note:\\n\"));\n \t      printf_unfiltered (_(\"  Thread %s previously stopped with signal %s, %s.\\n\"),\n \t\t\t\t print_thread_id (tp),\n-\t\t\t\t gdb_signal_to_name (tp->suspend.stop_signal),\n-\t\t\t\t gdb_signal_to_string (tp->suspend.stop_signal));\n+\t\t\t\t gdb_signal_to_name (tp->stop_signal ()),\n+\t\t\t\t gdb_signal_to_string (tp->stop_signal ()));\n \t      must_confirm = 1;\n \t    }\n \t}\n@@ -1294,7 +1295,7 @@ queue_signal_command (const char *signum_exp, int from_tty)\n     error (_(\"Signal handling set to not pass this signal to the program.\"));\n \n   tp = inferior_thread ();\n-  tp->suspend.stop_signal = oursig;\n+  tp->set_stop_signal (oursig);\n }\n \n /* Data for the FSM that manages the until (with no argument)\n@@ -1914,7 +1915,7 @@ info_program_command (const char *args, int from_tty)\n \n   target_files_info ();\n   printf_filtered (_(\"Program stopped at %s.\\n\"),\n-\t\t   paddress (target_gdbarch (), tp->suspend.stop_pc));\n+\t\t   paddress (target_gdbarch (), tp->stop_pc ()));\n   if (tp->control.stop_step)\n     printf_filtered (_(\"It stopped after being stepped.\\n\"));\n   else if (stat != 0)\n@@ -1933,11 +1934,11 @@ info_program_command (const char *args, int from_tty)\n \t  stat = bpstat_num (&bs, &num);\n \t}\n     }\n-  else if (tp->suspend.stop_signal != GDB_SIGNAL_0)\n+  else if (tp->stop_signal () != GDB_SIGNAL_0)\n     {\n       printf_filtered (_(\"It stopped with signal %s, %s.\\n\"),\n-\t\t       gdb_signal_to_name (tp->suspend.stop_signal),\n-\t\t       gdb_signal_to_string (tp->suspend.stop_signal));\n+\t\t       gdb_signal_to_name (tp->stop_signal ()),\n+\t\t       gdb_signal_to_string (tp->stop_signal ()));\n     }\n \n   if (from_tty)\n@@ -2425,7 +2426,7 @@ proceed_after_attach (inferior *inf)\n   for (thread_info *thread : inf->non_exited_threads ())\n     if (!thread->executing\n \t&& !thread->stop_requested\n-\t&& thread->suspend.stop_signal == GDB_SIGNAL_0)\n+\t&& thread->stop_signal () == GDB_SIGNAL_0)\n       {\n \tswitch_to_thread (thread);\n \tclear_proceed_status (0);\n@@ -2500,7 +2501,7 @@ attach_post_wait (int from_tty, enum attach_post_wait_mode mode)\n \tproceed_after_attach (inferior);\n       else\n \t{\n-\t  if (inferior_thread ()->suspend.stop_signal == GDB_SIGNAL_0)\n+\t  if (inferior_thread ()->stop_signal () == GDB_SIGNAL_0)\n \t    {\n \t      clear_proceed_status (0);\n \t      proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);"
    },
    {
      "sha": "970450632159483fa778322478ae036995bdd3f9",
      "filename": "gdb/inflow.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/inflow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/inflow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inflow.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -530,7 +530,7 @@ child_interrupt (struct target_ops *self)\n \t  resumed = thr;\n \t  break;\n \t}\n-      if (thr->suspend.waitstatus_pending_p)\n+      if (thr->has_pending_waitstatus ())\n \tresumed = thr;\n     }\n "
    },
    {
      "sha": "6c652ea3677b4f84702fc5f1447419fb606ef895",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 145,
      "deletions": 170,
      "changes": 315,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -899,7 +899,7 @@ proceed_after_vfork_done (struct thread_info *thread,\n       && thread->state == THREAD_RUNNING\n       && !thread->executing\n       && !thread->stop_requested\n-      && thread->suspend.stop_signal == GDB_SIGNAL_0)\n+      && thread->stop_signal () == GDB_SIGNAL_0)\n     {\n       infrun_debug_printf (\"resuming vfork parent thread %s\",\n \t\t\t   target_pid_to_str (thread->ptid).c_str ());\n@@ -2151,7 +2151,7 @@ do_target_resume (ptid_t resume_ptid, bool step, enum gdb_signal sig)\n \n   /* Avoid confusing the next resume, if the next stop/resume\n      happens to apply to another thread.  */\n-  tp->suspend.stop_signal = GDB_SIGNAL_0;\n+  tp->set_stop_signal (GDB_SIGNAL_0);\n \n   /* Advise target which signals may be handled silently.\n \n@@ -2209,13 +2209,13 @@ resume_1 (enum gdb_signal sig)\n   gdb_assert (!tp->stop_requested);\n   gdb_assert (!thread_is_in_step_over_chain (tp));\n \n-  if (tp->suspend.waitstatus_pending_p)\n+  if (tp->has_pending_waitstatus ())\n     {\n       infrun_debug_printf\n \t(\"thread %s has pending wait \"\n \t \"status %s (currently_stepping=%d).\",\n \t target_pid_to_str (tp->ptid).c_str (),\n-\t target_waitstatus_to_string (&tp->suspend.waitstatus).c_str (),\n+\t target_waitstatus_to_string (&tp->pending_waitstatus ()).c_str (),\n \t currently_stepping (tp));\n \n       tp->inf->process_target ()->threads_executing = true;\n@@ -2231,7 +2231,7 @@ resume_1 (enum gdb_signal sig)\n \t\t   target_pid_to_str (tp->ptid).c_str ());\n \t}\n \n-      tp->suspend.stop_signal = GDB_SIGNAL_0;\n+      tp->set_stop_signal (GDB_SIGNAL_0);\n \n       if (target_can_async_p ())\n \t{\n@@ -2617,31 +2617,31 @@ clear_proceed_status_thread (struct thread_info *tp)\n \n   /* If we're starting a new sequence, then the previous finished\n      single-step is no longer relevant.  */\n-  if (tp->suspend.waitstatus_pending_p)\n+  if (tp->has_pending_waitstatus ())\n     {\n-      if (tp->suspend.stop_reason == TARGET_STOPPED_BY_SINGLE_STEP)\n+      if (tp->stop_reason () == TARGET_STOPPED_BY_SINGLE_STEP)\n \t{\n \t  infrun_debug_printf (\"pending event of %s was a finished step. \"\n \t\t\t       \"Discarding.\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n-\t  tp->suspend.waitstatus_pending_p = 0;\n-\t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n+\t  tp->clear_pending_waitstatus ();\n+\t  tp->set_stop_reason (TARGET_STOPPED_BY_NO_REASON);\n \t}\n       else\n \t{\n \t  infrun_debug_printf\n \t    (\"thread %s has pending wait status %s (currently_stepping=%d).\",\n \t     target_pid_to_str (tp->ptid).c_str (),\n-\t     target_waitstatus_to_string (&tp->suspend.waitstatus).c_str (),\n+\t     target_waitstatus_to_string (&tp->pending_waitstatus ()).c_str (),\n \t     currently_stepping (tp));\n \t}\n     }\n \n   /* If this signal should not be seen by program, give it zero.\n      Used for debugging signals.  */\n-  if (!signal_pass_state (tp->suspend.stop_signal))\n-    tp->suspend.stop_signal = GDB_SIGNAL_0;\n+  if (!signal_pass_state (tp->stop_signal ()))\n+    tp->set_stop_signal (GDB_SIGNAL_0);\n \n   delete tp->thread_fsm;\n   tp->thread_fsm = NULL;\n@@ -2802,7 +2802,7 @@ maybe_set_commit_resumed_all_targets ()\n \t resuming more threads.  */\n       bool has_thread_with_pending_status = false;\n       for (thread_info *thread : all_non_exited_threads (proc_target))\n-\tif (thread->resumed () && thread->suspend.waitstatus_pending_p)\n+\tif (thread->resumed () && thread->has_pending_waitstatus ())\n \t  {\n \t    has_thread_with_pending_status = true;\n \t    break;\n@@ -3095,7 +3095,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n   if (addr == (CORE_ADDR) -1)\n     {\n-      if (pc == cur_thr->suspend.stop_pc\n+      if (pc == cur_thr->stop_pc ()\n \t  && breakpoint_here_p (aspace, pc) == ordinary_breakpoint_here\n \t  && execution_direction != EXEC_REVERSE)\n \t/* There is a breakpoint at the address we will resume at,\n@@ -3120,7 +3120,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n     }\n \n   if (siggnal != GDB_SIGNAL_DEFAULT)\n-    cur_thr->suspend.stop_signal = siggnal;\n+    cur_thr->set_stop_signal (siggnal);\n \n   /* If an exception is thrown from this point on, make sure to\n      propagate GDB's knowledge of the executing state to the\n@@ -3241,7 +3241,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t      {\n \t\tinfrun_debug_printf (\"[%s] resumed\",\n \t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n-\t\tgdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n+\t\tgdb_assert (tp->executing || tp->has_pending_waitstatus ());\n \t\tcontinue;\n \t      }\n \n@@ -3386,11 +3386,12 @@ infrun_thread_stop_requested (ptid_t ptid)\n \t know about that yet, queue a pending event, as if the\n \t thread had just stopped now.  Unless the thread already had\n \t a pending event.  */\n-      if (!tp->suspend.waitstatus_pending_p)\n+      if (!tp->has_pending_waitstatus ())\n \t{\n-\t  tp->suspend.waitstatus_pending_p = 1;\n-\t  tp->suspend.waitstatus.kind = TARGET_WAITKIND_STOPPED;\n-\t  tp->suspend.waitstatus.value.sig = GDB_SIGNAL_0;\n+\t  target_waitstatus ws;\n+\t  ws.kind = TARGET_WAITKIND_STOPPED;\n+\t  ws.value.sig = GDB_SIGNAL_0;\n+\t  tp->set_pending_waitstatus (ws);\n \t}\n \n       /* Clear the inline-frame state, since we're re-processing the\n@@ -3505,7 +3506,7 @@ random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n     {\n       return (tp->ptid.matches (waiton_ptid)\n \t      && tp->resumed ()\n-\t      && tp->suspend.waitstatus_pending_p);\n+\t      && tp->has_pending_waitstatus ());\n     };\n \n   /* First see how many events we have.  Count only resumed threads\n@@ -3566,13 +3567,13 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n       /* We have a specific thread to check.  */\n       tp = find_thread_ptid (inf, ptid);\n       gdb_assert (tp != NULL);\n-      if (!tp->suspend.waitstatus_pending_p)\n+      if (!tp->has_pending_waitstatus ())\n \ttp = NULL;\n     }\n \n   if (tp != NULL\n-      && (tp->suspend.stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n-\t  || tp->suspend.stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT))\n+      && (tp->stop_reason () == TARGET_STOPPED_BY_SW_BREAKPOINT\n+\t  || tp->stop_reason () == TARGET_STOPPED_BY_HW_BREAKPOINT))\n     {\n       struct regcache *regcache = get_thread_regcache (tp);\n       struct gdbarch *gdbarch = regcache->arch ();\n@@ -3581,11 +3582,11 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \n       pc = regcache_read_pc (regcache);\n \n-      if (pc != tp->suspend.stop_pc)\n+      if (pc != tp->stop_pc ())\n \t{\n \t  infrun_debug_printf (\"PC of %s changed.  was=%s, now=%s\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str (),\n-\t\t\t       paddress (gdbarch, tp->suspend.stop_pc),\n+\t\t\t       paddress (gdbarch, tp->stop_pc ()),\n \t\t\t       paddress (gdbarch, pc));\n \t  discard = 1;\n \t}\n@@ -3603,22 +3604,25 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \t  infrun_debug_printf (\"pending event of %s cancelled.\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n-\t  tp->suspend.waitstatus.kind = TARGET_WAITKIND_SPURIOUS;\n-\t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n+\t  tp->clear_pending_waitstatus ();\n+\t  target_waitstatus ws;\n+\t  ws.kind = TARGET_WAITKIND_SPURIOUS;\n+\t  tp->set_pending_waitstatus (ws);\n+\t  tp->set_stop_reason (TARGET_STOPPED_BY_NO_REASON);\n \t}\n     }\n \n   if (tp != NULL)\n     {\n       infrun_debug_printf (\"Using pending wait status %s for %s.\",\n \t\t\t   target_waitstatus_to_string\n-\t\t\t     (&tp->suspend.waitstatus).c_str (),\n+\t\t\t     (&tp->pending_waitstatus ()).c_str (),\n \t\t\t   target_pid_to_str (tp->ptid).c_str ());\n \n       /* Now that we've selected our final event LWP, un-adjust its PC\n \t if it was a software breakpoint (and the target doesn't\n \t always adjust the PC itself).  */\n-      if (tp->suspend.stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT\n+      if (tp->stop_reason () == TARGET_STOPPED_BY_SW_BREAKPOINT\n \t  && !target_supports_stopped_by_sw_breakpoint ())\n \t{\n \t  struct regcache *regcache;\n@@ -3638,9 +3642,9 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \t    }\n \t}\n \n-      tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n-      *status = tp->suspend.waitstatus;\n-      tp->suspend.waitstatus_pending_p = 0;\n+      tp->set_stop_reason (TARGET_STOPPED_BY_NO_REASON);\n+      *status = tp->pending_waitstatus ();\n+      tp->clear_pending_waitstatus ();\n \n       /* Wake up the event loop again, until all pending events are\n \t processed.  */\n@@ -4289,7 +4293,7 @@ context_switch (execution_control_state *ecs)\n \n static void\n adjust_pc_after_break (struct thread_info *thread,\n-\t\t       struct target_waitstatus *ws)\n+\t\t       const target_waitstatus *ws)\n {\n   struct regcache *regcache;\n   struct gdbarch *gdbarch;\n@@ -4517,7 +4521,7 @@ handle_syscall_event (struct execution_control_state *ecs)\n \n   regcache = get_thread_regcache (ecs->event_thread);\n   syscall_number = ecs->ws.value.syscall_number;\n-  ecs->event_thread->suspend.stop_pc = regcache_read_pc (regcache);\n+  ecs->event_thread->set_stop_pc (regcache_read_pc (regcache));\n \n   if (catch_syscall_enabled () > 0\n       && catching_syscall_number (syscall_number) > 0)\n@@ -4526,7 +4530,7 @@ handle_syscall_event (struct execution_control_state *ecs)\n \n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (regcache->aspace (),\n-\t\t\t      ecs->event_thread->suspend.stop_pc,\n+\t\t\t      ecs->event_thread->stop_pc (),\n \t\t\t      ecs->event_thread, &ecs->ws);\n \n       if (handle_stop_requested (ecs))\n@@ -4561,7 +4565,7 @@ fill_in_stop_func (struct gdbarch *gdbarch,\n \n       /* Don't care about return value; stop_func_start and stop_func_name\n \t will both be 0 if it doesn't work.  */\n-      find_pc_partial_function_sym (ecs->event_thread->suspend.stop_pc,\n+      find_pc_partial_function_sym (ecs->event_thread->stop_pc (),\n \t\t\t\t    &gsi,\n \t\t\t\t    &ecs->stop_func_start,\n \t\t\t\t    &ecs->stop_func_end,\n@@ -4714,8 +4718,7 @@ save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n \t\t       tp->ptid.tid ());\n \n   /* Record for later.  */\n-  tp->suspend.waitstatus = *ws;\n-  tp->suspend.waitstatus_pending_p = 1;\n+  tp->set_pending_waitstatus (*ws);\n \n   if (ws->kind == TARGET_WAITKIND_STOPPED\n       && ws->value.sig == GDB_SIGNAL_TRAP)\n@@ -4724,48 +4727,28 @@ save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n       const address_space *aspace = regcache->aspace ();\n       CORE_ADDR pc = regcache_read_pc (regcache);\n \n-      adjust_pc_after_break (tp, &tp->suspend.waitstatus);\n+      adjust_pc_after_break (tp, &tp->pending_waitstatus ());\n \n       scoped_restore_current_thread restore_thread;\n       switch_to_thread (tp);\n \n       if (target_stopped_by_watchpoint ())\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_WATCHPOINT;\n-\t}\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_WATCHPOINT);\n       else if (target_supports_stopped_by_sw_breakpoint ()\n \t       && target_stopped_by_sw_breakpoint ())\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_SW_BREAKPOINT;\n-\t}\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_SW_BREAKPOINT);\n       else if (target_supports_stopped_by_hw_breakpoint ()\n \t       && target_stopped_by_hw_breakpoint ())\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_HW_BREAKPOINT;\n-\t}\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_HW_BREAKPOINT);\n       else if (!target_supports_stopped_by_hw_breakpoint ()\n-\t       && hardware_breakpoint_inserted_here_p (aspace,\n-\t\t\t\t\t\t       pc))\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_HW_BREAKPOINT;\n-\t}\n+\t       && hardware_breakpoint_inserted_here_p (aspace, pc))\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_HW_BREAKPOINT);\n       else if (!target_supports_stopped_by_sw_breakpoint ()\n-\t       && software_breakpoint_inserted_here_p (aspace,\n-\t\t\t\t\t\t       pc))\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_SW_BREAKPOINT;\n-\t}\n+\t       && software_breakpoint_inserted_here_p (aspace, pc))\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_SW_BREAKPOINT);\n       else if (!thread_has_single_step_breakpoints_set (tp)\n \t       && currently_stepping (tp))\n-\t{\n-\t  tp->suspend.stop_reason\n-\t    = TARGET_STOPPED_BY_SINGLE_STEP;\n-\t}\n+\ttp->set_stop_reason (TARGET_STOPPED_BY_SINGLE_STEP);\n     }\n }\n \n@@ -4906,9 +4889,7 @@ handle_one (const wait_one_event &event)\n \t  && event.ws.value.sig == GDB_SIGNAL_0)\n \t{\n \t  /* We caught the event that we intended to catch, so\n-\t     there's no event pending.  */\n-\t  t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n-\t  t->suspend.waitstatus_pending_p = 0;\n+\t     there's no event to save as pending.  */\n \n \t  if (displaced_step_finish (t, GDB_SIGNAL_0)\n \t      == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n@@ -4949,12 +4930,11 @@ handle_one (const wait_one_event &event)\n \t    }\n \n \t  regcache = get_thread_regcache (t);\n-\t  t->suspend.stop_pc = regcache_read_pc (regcache);\n+\t  t->set_stop_pc (regcache_read_pc (regcache));\n \n \t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n \t\t\t       \"(currently_stepping=%d)\",\n-\t\t\t       paddress (target_gdbarch (),\n-\t\t\t\t\t t->suspend.stop_pc),\n+\t\t\t       paddress (target_gdbarch (), t->stop_pc ()),\n \t\t\t       target_pid_to_str (t->ptid).c_str (),\n \t\t\t       currently_stepping (t));\n \t}\n@@ -5190,8 +5170,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n \t}\n \n       if (!ignore_event\n-\t  && (thread->executing\n-\t      || thread->suspend.waitstatus_pending_p))\n+\t  && (thread->executing || thread->has_pending_waitstatus ()))\n \t{\n \t  /* Either there were no unwaited-for children left in the\n \t     target at some point, but there are now, or some target\n@@ -5352,7 +5331,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n \t    ecs->event_thread->control.stop_bpstat\n \t      = bpstat_stop_status (regcache->aspace (),\n-\t\t\t\t    ecs->event_thread->suspend.stop_pc,\n+\t\t\t\t    ecs->event_thread->stop_pc (),\n \t\t\t\t    ecs->event_thread, &ecs->ws);\n \n \t    if (handle_stop_requested (ecs))\n@@ -5369,7 +5348,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t       gdb of events.  This allows the user to get control\n \t       and place breakpoints in initializer routines for\n \t       dynamically loaded objects (among other things).  */\n-\t    ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t    ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \t    if (stop_on_solib_events)\n \t      {\n \t\t/* Make sure we print \"Stopped due to solib-event\" in\n@@ -5590,12 +5569,12 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t and not immediately.  */\n       ecs->event_thread->pending_follow = ecs->ws;\n \n-      ecs->event_thread->suspend.stop_pc\n-\t= regcache_read_pc (get_thread_regcache (ecs->event_thread));\n+      ecs->event_thread->set_stop_pc\n+\t(regcache_read_pc (get_thread_regcache (ecs->event_thread)));\n \n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (get_current_regcache ()->aspace (),\n-\t\t\t      ecs->event_thread->suspend.stop_pc,\n+\t\t\t      ecs->event_thread->stop_pc (),\n \t\t\t      ecs->event_thread, &ecs->ws);\n \n       if (handle_stop_requested (ecs))\n@@ -5610,7 +5589,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t  bool follow_child\n \t    = (follow_fork_mode_string == follow_fork_mode_child);\n \n-\t  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t  ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \n \t  process_stratum_target *targ\n \t    = ecs->event_thread->inf->process_target ();\n@@ -5702,12 +5681,12 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t execd thread for that case (this is a nop otherwise).  */\n       ecs->event_thread = inferior_thread ();\n \n-      ecs->event_thread->suspend.stop_pc\n-\t= regcache_read_pc (get_thread_regcache (ecs->event_thread));\n+      ecs->event_thread->set_stop_pc\n+\t(regcache_read_pc (get_thread_regcache (ecs->event_thread)));\n \n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (get_current_regcache ()->aspace (),\n-\t\t\t      ecs->event_thread->suspend.stop_pc,\n+\t\t\t      ecs->event_thread->stop_pc (),\n \t\t\t      ecs->event_thread, &ecs->ws);\n \n       /* Note that this may be referenced from inside\n@@ -5721,7 +5700,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       /* If no catchpoint triggered for this, then keep going.  */\n       if (!bpstat_causes_stop (ecs->event_thread->control.stop_bpstat))\n \t{\n-\t  ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t  ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \t  keep_going (ecs);\n \t  return;\n \t}\n@@ -5758,8 +5737,8 @@ handle_inferior_event (struct execution_control_state *ecs)\n       infrun_debug_printf (\"stopped\");\n \n       delete_just_stopped_threads_single_step_breakpoints ();\n-      ecs->event_thread->suspend.stop_pc\n-\t= regcache_read_pc (get_thread_regcache (inferior_thread ()));\n+      ecs->event_thread->set_stop_pc\n+\t(regcache_read_pc (get_thread_regcache (inferior_thread ())));\n \n       if (handle_stop_requested (ecs))\n \treturn;\n@@ -5809,7 +5788,7 @@ restart_threads (struct thread_info *event_thread)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] resumed\",\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n-\t  gdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n+\t  gdb_assert (tp->executing || tp->has_pending_waitstatus ());\n \t  continue;\n \t}\n \n@@ -5822,7 +5801,7 @@ restart_threads (struct thread_info *event_thread)\n \t}\n \n \n-      if (tp->suspend.waitstatus_pending_p)\n+      if (tp->has_pending_waitstatus ())\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] has pending status\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n@@ -5870,8 +5849,7 @@ static int\n resumed_thread_with_pending_status (struct thread_info *tp,\n \t\t\t\t    void *arg)\n {\n-  return (tp->resumed ()\n-\t  && tp->suspend.waitstatus_pending_p);\n+  return tp->resumed () && tp->has_pending_waitstatus ();\n }\n \n /* Called when we get an event that may finish an in-line or\n@@ -5883,8 +5861,7 @@ resumed_thread_with_pending_status (struct thread_info *tp,\n static int\n finish_step_over (struct execution_control_state *ecs)\n {\n-  displaced_step_finish (ecs->event_thread,\n-\t\t\t ecs->event_thread->suspend.stop_signal);\n+  displaced_step_finish (ecs->event_thread, ecs->event_thread->stop_signal ());\n \n   bool had_step_over_info = step_over_info_valid_p ();\n \n@@ -5961,12 +5938,11 @@ finish_step_over (struct execution_control_state *ecs)\n \t  gdb_assert (!tp->executing);\n \n \t  regcache = get_thread_regcache (tp);\n-\t  tp->suspend.stop_pc = regcache_read_pc (regcache);\n+\t  tp->set_stop_pc (regcache_read_pc (regcache));\n \n \t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n \t\t\t       \"(currently_stepping=%d)\",\n-\t\t\t       paddress (target_gdbarch (),\n-\t\t\t\t\t tp->suspend.stop_pc),\n+\t\t\t       paddress (target_gdbarch (), tp->stop_pc ()),\n \t\t\t       target_pid_to_str (tp->ptid).c_str (),\n \t\t\t       currently_stepping (tp));\n \n@@ -5999,7 +5975,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n   gdb_assert (ecs->ws.kind == TARGET_WAITKIND_STOPPED);\n \n-  ecs->event_thread->suspend.stop_signal = ecs->ws.value.sig;\n+  ecs->event_thread->set_stop_signal (ecs->ws.value.sig);\n \n   /* Do we need to clean up the state of a thread that has\n      completed a displaced single-step?  (Doing so usually affects\n@@ -6011,11 +5987,11 @@ handle_signal_stop (struct execution_control_state *ecs)\n      the user wanted this thread to be stopped, pretend we got a\n      SIG0 (generic unsignaled stop).  */\n   if (ecs->event_thread->stop_requested\n-      && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)\n-    ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+      && ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP)\n+    ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \n-  ecs->event_thread->suspend.stop_pc\n-    = regcache_read_pc (get_thread_regcache (ecs->event_thread));\n+  ecs->event_thread->set_stop_pc\n+    (regcache_read_pc (get_thread_regcache (ecs->event_thread)));\n \n   context_switch (ecs);\n \n@@ -6027,9 +6003,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n       struct regcache *regcache = get_thread_regcache (ecs->event_thread);\n       struct gdbarch *reg_gdbarch = regcache->arch ();\n \n-      infrun_debug_printf (\"stop_pc=%s\",\n-\t\t\t   paddress (reg_gdbarch,\n-\t\t\t\t     ecs->event_thread->suspend.stop_pc));\n+      infrun_debug_printf\n+\t(\"stop_pc=%s\", paddress (reg_gdbarch, ecs->event_thread->stop_pc ()));\n       if (target_stopped_by_watchpoint ())\n \t{\n \t  CORE_ADDR addr;\n@@ -6077,13 +6052,13 @@ handle_signal_stop (struct execution_control_state *ecs)\n      GDB_SIGNAL_0, meaning: stopped for no particular reason\n      other than GDB's request.  */\n   if (stop_soon == STOP_QUIETLY_NO_SIGSTOP\n-      && (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_STOP\n-\t  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n-\t  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_0))\n+      && (ecs->event_thread->stop_signal () == GDB_SIGNAL_STOP\n+\t  || ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n+\t  || ecs->event_thread->stop_signal () == GDB_SIGNAL_0))\n     {\n       stop_print_frame = true;\n       stop_waiting (ecs);\n-      ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+      ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n       return;\n     }\n \n@@ -6092,7 +6067,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   gdbarch = get_frame_arch (frame);\n \n   /* Pull the single step breakpoints out of the target.  */\n-  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)\n+  if (ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP)\n     {\n       struct regcache *regcache;\n       CORE_ADDR pc;\n@@ -6124,7 +6099,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n     }\n   delete_just_stopped_threads_single_step_breakpoints ();\n \n-  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+  if (ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n       && ecs->event_thread->control.trap_expected\n       && ecs->event_thread->stepping_over_watchpoint)\n     stopped_by_watchpoint = 0;\n@@ -6201,16 +6176,16 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t skip_inline_frames call would break things.  Fortunately\n \t that's an extremely unlikely scenario.  */\n       if (!pc_at_non_inline_function (aspace,\n-\t\t\t\t      ecs->event_thread->suspend.stop_pc,\n+\t\t\t\t      ecs->event_thread->stop_pc (),\n \t\t\t\t      &ecs->ws)\n-\t  && !(ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+\t  && !(ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n \t       && ecs->event_thread->control.trap_expected\n \t       && pc_at_non_inline_function (aspace,\n \t\t\t\t\t     ecs->event_thread->prev_pc,\n \t\t\t\t\t     &ecs->ws)))\n \t{\n \t  stop_chain = build_bpstat_chain (aspace,\n-\t\t\t\t\t   ecs->event_thread->suspend.stop_pc,\n+\t\t\t\t\t   ecs->event_thread->stop_pc (),\n \t\t\t\t\t   &ecs->ws);\n \t  skip_inline_frames (ecs->event_thread, stop_chain);\n \n@@ -6221,7 +6196,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t}\n     }\n \n-  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+  if (ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n       && ecs->event_thread->control.trap_expected\n       && gdbarch_single_step_through_delay_p (gdbarch)\n       && currently_stepping (ecs->event_thread))\n@@ -6262,7 +6237,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n      handles this event.  */\n   ecs->event_thread->control.stop_bpstat\n     = bpstat_stop_status (get_current_regcache ()->aspace (),\n-\t\t\t  ecs->event_thread->suspend.stop_pc,\n+\t\t\t  ecs->event_thread->stop_pc (),\n \t\t\t  ecs->event_thread, &ecs->ws, stop_chain);\n \n   /* Following in case break condition called a\n@@ -6277,7 +6252,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n      simply make sure to ignore it if `stopped_by_watchpoint' is\n      set.  */\n \n-  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+  if (ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n       && !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,\n \t\t\t\t  GDB_SIGNAL_TRAP)\n       && stopped_by_watchpoint)\n@@ -6309,14 +6284,14 @@ handle_signal_stop (struct execution_control_state *ecs)\n   /* See if the breakpoints module can explain the signal.  */\n   random_signal\n     = !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,\n-\t\t\t       ecs->event_thread->suspend.stop_signal);\n+\t\t\t       ecs->event_thread->stop_signal ());\n \n   /* Maybe this was a trap for a software breakpoint that has since\n      been removed.  */\n   if (random_signal && target_stopped_by_sw_breakpoint ())\n     {\n       if (gdbarch_program_breakpoint_here_p (gdbarch,\n-\t\t\t\t\t     ecs->event_thread->suspend.stop_pc))\n+\t\t\t\t\t     ecs->event_thread->stop_pc ()))\n \t{\n \t  struct regcache *regcache;\n \t  int decr_pc;\n@@ -6335,7 +6310,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t\t  (record_full_gdb_operation_disable_set ());\n \n \t      regcache_write_pc (regcache,\n-\t\t\t\t ecs->event_thread->suspend.stop_pc + decr_pc);\n+\t\t\t\t ecs->event_thread->stop_pc () + decr_pc);\n \t    }\n \t}\n       else\n@@ -6358,7 +6333,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n   /* If not, perhaps stepping/nexting can.  */\n   if (random_signal)\n-    random_signal = !(ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+    random_signal = !(ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP\n \t\t      && currently_stepping (ecs->event_thread));\n \n   /* Perhaps the thread hit a single-step breakpoint of _another_\n@@ -6385,7 +6360,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (random_signal)\n     {\n       /* Signal not for debugging purposes.  */\n-      enum gdb_signal stop_signal = ecs->event_thread->suspend.stop_signal;\n+      enum gdb_signal stop_signal = ecs->event_thread->stop_signal ();\n \n       infrun_debug_printf (\"random signal (%s)\",\n \t\t\t   gdb_signal_to_symbol_string (stop_signal));\n@@ -6397,7 +6372,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t to remain stopped.  */\n       if (stop_soon != NO_STOP_QUIETLY\n \t  || ecs->event_thread->stop_requested\n-\t  || signal_stop_state (ecs->event_thread->suspend.stop_signal))\n+\t  || signal_stop_state (ecs->event_thread->stop_signal ()))\n \t{\n \t  stop_waiting (ecs);\n \t  return;\n@@ -6406,19 +6381,19 @@ handle_signal_stop (struct execution_control_state *ecs)\n       /* Notify observers the signal has \"handle print\" set.  Note we\n \t returned early above if stopping; normal_stop handles the\n \t printing in that case.  */\n-      if (signal_print[ecs->event_thread->suspend.stop_signal])\n+      if (signal_print[ecs->event_thread->stop_signal ()])\n \t{\n \t  /* The signal table tells us to print about this signal.  */\n \t  target_terminal::ours_for_output ();\n-\t  gdb::observers::signal_received.notify (ecs->event_thread->suspend.stop_signal);\n+\t  gdb::observers::signal_received.notify (ecs->event_thread->stop_signal ());\n \t  target_terminal::inferior ();\n \t}\n \n       /* Clear the signal if it should not be passed.  */\n-      if (signal_program[ecs->event_thread->suspend.stop_signal] == 0)\n-\tecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+      if (signal_program[ecs->event_thread->stop_signal ()] == 0)\n+\tecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \n-      if (ecs->event_thread->prev_pc == ecs->event_thread->suspend.stop_pc\n+      if (ecs->event_thread->prev_pc == ecs->event_thread->stop_pc ()\n \t  && ecs->event_thread->control.trap_expected\n \t  && ecs->event_thread->control.step_resume_breakpoint == NULL)\n \t{\n@@ -6446,8 +6421,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t  return;\n \t}\n \n-      if (ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_0\n-\t  && (pc_in_thread_step_range (ecs->event_thread->suspend.stop_pc,\n+      if (ecs->event_thread->stop_signal () != GDB_SIGNAL_0\n+\t  && (pc_in_thread_step_range (ecs->event_thread->stop_pc (),\n \t\t\t\t       ecs->event_thread)\n \t      || ecs->event_thread->control.step_range_end == 1)\n \t  && frame_id_eq (get_stack_frame_id (frame),\n@@ -6665,7 +6640,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t  return;\n \t}\n       fill_in_stop_func (gdbarch, ecs);\n-      if (ecs->event_thread->suspend.stop_pc == ecs->stop_func_start\n+      if (ecs->event_thread->stop_pc () == ecs->stop_func_start\n \t  && execution_direction == EXEC_REVERSE)\n \t{\n \t  /* We are stepping over a function call in reverse, and just\n@@ -6789,7 +6764,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n      through a function epilogue and therefore must detect when\n      the current-frame changes in the middle of a line.  */\n \n-  if (pc_in_thread_step_range (ecs->event_thread->suspend.stop_pc,\n+  if (pc_in_thread_step_range (ecs->event_thread->stop_pc (),\n \t\t\t       ecs->event_thread)\n       && (execution_direction != EXEC_REVERSE\n \t  || frame_id_eq (get_frame_id (frame),\n@@ -6808,7 +6783,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       /* When stepping backward, stop at beginning of line range\n \t (unless it's the function entry point, in which case\n \t keep going back to the call point).  */\n-      CORE_ADDR stop_pc = ecs->event_thread->suspend.stop_pc;\n+      CORE_ADDR stop_pc = ecs->event_thread->stop_pc ();\n       if (stop_pc == ecs->event_thread->control.step_range_start\n \t  && stop_pc != ecs->stop_func_start\n \t  && execution_direction == EXEC_REVERSE)\n@@ -6835,11 +6810,10 @@ process_event_stop_test (struct execution_control_state *ecs)\n \n   if (execution_direction != EXEC_REVERSE\n       && ecs->event_thread->control.step_over_calls == STEP_OVER_UNDEBUGGABLE\n-      && in_solib_dynsym_resolve_code (ecs->event_thread->suspend.stop_pc))\n+      && in_solib_dynsym_resolve_code (ecs->event_thread->stop_pc ()))\n     {\n       CORE_ADDR pc_after_resolver =\n-\tgdbarch_skip_solib_resolver (gdbarch,\n-\t\t\t\t     ecs->event_thread->suspend.stop_pc);\n+\tgdbarch_skip_solib_resolver (gdbarch, ecs->event_thread->stop_pc ());\n \n       infrun_debug_printf (\"stepped into dynsym resolve code\");\n \n@@ -6862,7 +6836,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n   /* Step through an indirect branch thunk.  */\n   if (ecs->event_thread->control.step_over_calls != STEP_OVER_NONE\n       && gdbarch_in_indirect_branch_thunk (gdbarch,\n-\t\t\t\t\t   ecs->event_thread->suspend.stop_pc))\n+\t\t\t\t\t   ecs->event_thread->stop_pc ()))\n     {\n       infrun_debug_printf (\"stepped into indirect branch thunk\");\n       keep_going (ecs);\n@@ -6890,12 +6864,12 @@ process_event_stop_test (struct execution_control_state *ecs)\n      call check below as on some targets return trampolines look\n      like subroutine calls (MIPS16 return thunks).  */\n   if (gdbarch_in_solib_return_trampoline (gdbarch,\n-\t\t\t\t\t  ecs->event_thread->suspend.stop_pc,\n+\t\t\t\t\t  ecs->event_thread->stop_pc (),\n \t\t\t\t\t  ecs->stop_func_name)\n       && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE)\n     {\n       /* Determine where this trampoline returns.  */\n-      CORE_ADDR stop_pc = ecs->event_thread->suspend.stop_pc;\n+      CORE_ADDR stop_pc = ecs->event_thread->stop_pc ();\n       CORE_ADDR real_stop_pc\n \t= gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc);\n \n@@ -6947,9 +6921,9 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t  && (!frame_id_eq (ecs->event_thread->control.step_stack_frame_id,\n \t\t\t    outer_frame_id)\n \t      || (ecs->event_thread->control.step_start_function\n-\t\t  != find_pc_function (ecs->event_thread->suspend.stop_pc)))))\n+\t\t  != find_pc_function (ecs->event_thread->stop_pc ())))))\n     {\n-      CORE_ADDR stop_pc = ecs->event_thread->suspend.stop_pc;\n+      CORE_ADDR stop_pc = ecs->event_thread->stop_pc ();\n       CORE_ADDR real_stop_pc;\n \n       infrun_debug_printf (\"stepped into subroutine\");\n@@ -7107,7 +7081,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n   if (execution_direction == EXEC_REVERSE\n       && ecs->event_thread->control.step_over_calls != STEP_OVER_NONE)\n     {\n-      CORE_ADDR stop_pc = ecs->event_thread->suspend.stop_pc;\n+      CORE_ADDR stop_pc = ecs->event_thread->stop_pc ();\n \n       if (gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc)\n \t  || (ecs->stop_func_start == 0\n@@ -7140,7 +7114,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n      stack of inlined frames, even if GDB actually believes that it is in a\n      more outer frame.  This is checked for below by calls to\n      inline_skipped_frames.  */\n-  stop_pc_sal = find_pc_line (ecs->event_thread->suspend.stop_pc, 0);\n+  stop_pc_sal = find_pc_line (ecs->event_thread->stop_pc (), 0);\n \n   /* NOTE: tausq/2004-05-24: This if block used to be done before all\n      the trampoline processing logic, however, there are some trampolines \n@@ -7267,7 +7241,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n     }\n \n   bool refresh_step_info = true;\n-  if ((ecs->event_thread->suspend.stop_pc == stop_pc_sal.pc)\n+  if ((ecs->event_thread->stop_pc () == stop_pc_sal.pc)\n       && (ecs->event_thread->current_line != stop_pc_sal.line\n \t  || ecs->event_thread->current_symtab != stop_pc_sal.symtab))\n     {\n@@ -7362,7 +7336,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       /* Check if the current thread is blocked on an incomplete\n \t step-over, interrupted by a random signal.  */\n       if (ecs->event_thread->control.trap_expected\n-\t  && ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_TRAP)\n+\t  && ecs->event_thread->stop_signal () != GDB_SIGNAL_TRAP)\n \t{\n \t  infrun_debug_printf\n \t    (\"need to finish step-over of [%s]\",\n@@ -7407,8 +7381,8 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       ecs->event_thread->control.trap_expected = 0;\n \n       /* Likewise, clear the signal if it should not be passed.  */\n-      if (!signal_program[ecs->event_thread->suspend.stop_signal])\n-\tecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+      if (!signal_program[ecs->event_thread->stop_signal ()])\n+\tecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n \n       if (restart_stepped_thread (ecs->target, ecs->ptid))\n \t{\n@@ -7441,7 +7415,7 @@ restart_stepped_thread (process_stratum_target *resume_target,\n       if (tp->state == THREAD_EXITED)\n \tcontinue;\n \n-      if (tp->suspend.waitstatus_pending_p)\n+      if (tp->has_pending_waitstatus ())\n \tcontinue;\n \n       /* Ignore threads of processes the caller is not\n@@ -7465,7 +7439,7 @@ restart_stepped_thread (process_stratum_target *resume_target,\n       if (tp->state == THREAD_EXITED)\n \tcontinue;\n \n-      if (tp->suspend.waitstatus_pending_p)\n+      if (tp->has_pending_waitstatus ())\n \tcontinue;\n \n       /* Ignore threads of processes the caller is not\n@@ -7516,7 +7490,7 @@ restart_after_all_stop_detach (process_stratum_target *proc_target)\n \n       /* If we have a pending event to process, skip resuming the\n \t target and go straight to processing it.  */\n-      if (thr->resumed () && thr->suspend.waitstatus_pending_p)\n+      if (thr->resumed () && thr->has_pending_waitstatus ())\n \treturn;\n     }\n \n@@ -7583,7 +7557,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n   reset_ecs (ecs, tp);\n   switch_to_thread (tp);\n \n-  tp->suspend.stop_pc = regcache_read_pc (get_thread_regcache (tp));\n+  tp->set_stop_pc (regcache_read_pc (get_thread_regcache (tp)));\n   frame = get_current_frame ();\n \n   /* If the PC of the thread we were trying to single-step has\n@@ -7599,13 +7573,13 @@ keep_going_stepped_thread (struct thread_info *tp)\n      This prevents us continuously moving the single-step breakpoint\n      forward, one instruction at a time, overstepping.  */\n \n-  if (tp->suspend.stop_pc != tp->prev_pc)\n+  if (tp->stop_pc () != tp->prev_pc)\n     {\n       ptid_t resume_ptid;\n \n       infrun_debug_printf (\"expected thread advanced also (%s -> %s)\",\n \t\t\t   paddress (target_gdbarch (), tp->prev_pc),\n-\t\t\t   paddress (target_gdbarch (), tp->suspend.stop_pc));\n+\t\t\t   paddress (target_gdbarch (), tp->stop_pc ()));\n \n       /* Clear the info of the previous step-over, as it's no longer\n \t valid (if the thread was trying to step over a breakpoint, it\n@@ -7619,7 +7593,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n \n       insert_single_step_breakpoint (get_frame_arch (frame),\n \t\t\t\t     get_frame_address_space (frame),\n-\t\t\t\t     tp->suspend.stop_pc);\n+\t\t\t\t     tp->stop_pc ());\n \n       tp->set_resumed (true);\n       resume_ptid = internal_resume_ptid (tp->control.stepping_command);\n@@ -7660,7 +7634,7 @@ handle_step_into_function (struct gdbarch *gdbarch,\n   fill_in_stop_func (gdbarch, ecs);\n \n   compunit_symtab *cust\n-    = find_pc_compunit_symtab (ecs->event_thread->suspend.stop_pc);\n+    = find_pc_compunit_symtab (ecs->event_thread->stop_pc ());\n   if (cust != NULL && compunit_language (cust) != language_asm)\n     ecs->stop_func_start\n       = gdbarch_skip_prologue_noexcept (gdbarch, ecs->stop_func_start);\n@@ -7700,7 +7674,7 @@ handle_step_into_function (struct gdbarch *gdbarch,\n \t\t\t\t\t     ecs->stop_func_start);\n     }\n \n-  if (ecs->stop_func_start == ecs->event_thread->suspend.stop_pc)\n+  if (ecs->stop_func_start == ecs->event_thread->stop_pc ())\n     {\n       /* We are already there: stop now.  */\n       end_stepping_range (ecs);\n@@ -7739,15 +7713,15 @@ handle_step_into_function_backward (struct gdbarch *gdbarch,\n \n   fill_in_stop_func (gdbarch, ecs);\n \n-  cust = find_pc_compunit_symtab (ecs->event_thread->suspend.stop_pc);\n+  cust = find_pc_compunit_symtab (ecs->event_thread->stop_pc ());\n   if (cust != NULL && compunit_language (cust) != language_asm)\n     ecs->stop_func_start\n       = gdbarch_skip_prologue_noexcept (gdbarch, ecs->stop_func_start);\n \n-  stop_func_sal = find_pc_line (ecs->event_thread->suspend.stop_pc, 0);\n+  stop_func_sal = find_pc_line (ecs->event_thread->stop_pc (), 0);\n \n   /* OK, we're just going to keep stepping here.  */\n-  if (stop_func_sal.pc == ecs->event_thread->suspend.stop_pc)\n+  if (stop_func_sal.pc == ecs->event_thread->stop_pc ())\n     {\n       /* We're there already.  Just stop stepping now.  */\n       end_stepping_range (ecs);\n@@ -8054,7 +8028,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \t non-signal event (e.g., a fork); or took a signal which we\n \t are supposed to pass through to the inferior.  Simply\n \t continue.  */\n-      resume (ecs->event_thread->suspend.stop_signal);\n+      resume (ecs->event_thread->stop_signal ());\n     }\n   else if (step_over_info_valid_p ())\n     {\n@@ -8145,7 +8119,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \n       ecs->event_thread->control.trap_expected = (remove_bp || remove_wps);\n \n-      resume (ecs->event_thread->suspend.stop_signal);\n+      resume (ecs->event_thread->stop_signal ());\n     }\n \n   prepare_to_wait (ecs);\n@@ -8159,11 +8133,11 @@ static void\n keep_going (struct execution_control_state *ecs)\n {\n   if (ecs->event_thread->control.trap_expected\n-      && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP)\n+      && ecs->event_thread->stop_signal () == GDB_SIGNAL_TRAP)\n     ecs->event_thread->control.trap_expected = 0;\n \n-  if (!signal_program[ecs->event_thread->suspend.stop_signal])\n-    ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n+  if (!signal_program[ecs->event_thread->stop_signal ()])\n+    ecs->event_thread->set_stop_signal (GDB_SIGNAL_0);\n   keep_going_pass_signal (ecs);\n }\n \n@@ -8349,7 +8323,7 @@ print_stop_location (struct target_waitstatus *ws)\n \t  && frame_id_eq (tp->control.step_frame_id,\n \t\t\t  get_frame_id (get_current_frame ()))\n \t  && (tp->control.step_start_function\n-\t      == find_pc_function (tp->suspend.stop_pc)))\n+\t      == find_pc_function (tp->stop_pc ())))\n \t{\n \t  /* Finished step, just print source line.  */\n \t  source_flag = SRC_LINE;\n@@ -8545,7 +8519,7 @@ normal_stop (void)\n   update_thread_list ();\n \n   if (last.kind == TARGET_WAITKIND_STOPPED && stopped_by_random_signal)\n-    gdb::observers::signal_received.notify (inferior_thread ()->suspend.stop_signal);\n+    gdb::observers::signal_received.notify (inferior_thread ()->stop_signal ());\n \n   /* As with the notification of thread events, we want to delay\n      notifying the user that we've switched thread context until\n@@ -9134,9 +9108,10 @@ class infcall_suspend_state\n   infcall_suspend_state (struct gdbarch *gdbarch,\n \t\t\t const struct thread_info *tp,\n \t\t\t struct regcache *regcache)\n-    : m_thread_suspend (tp->suspend),\n-      m_registers (new readonly_detached_regcache (*regcache))\n+    : m_registers (new readonly_detached_regcache (*regcache))\n   {\n+    tp->save_suspend_to (m_thread_suspend);\n+\n     gdb::unique_xmalloc_ptr<gdb_byte> siginfo_data;\n \n     if (gdbarch_get_siginfo_type_p (gdbarch))\n@@ -9175,7 +9150,7 @@ class infcall_suspend_state\n \t\tstruct thread_info *tp,\n \t\tstruct regcache *regcache) const\n   {\n-    tp->suspend = m_thread_suspend;\n+    tp->restore_suspend_from (m_thread_suspend);\n \n     if (m_siginfo_gdbarch == gdbarch)\n       {\n@@ -9225,7 +9200,7 @@ save_infcall_suspend_state ()\n      any stop signal information.  The stop signal is not useful when\n      starting an inferior function call, and run_inferior_call will not use\n      the signal due to its `proceed' call with GDB_SIGNAL_0.  */\n-  tp->suspend.stop_signal = GDB_SIGNAL_0;\n+  tp->set_stop_signal (GDB_SIGNAL_0);\n \n   return inf_state;\n }"
    },
    {
      "sha": "1559ad9fd717e786470535b101288ac866712b97",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -224,8 +224,7 @@ fork_load_infrun_state (struct fork_info *fp)\n   registers_changed ();\n   reinit_frame_cache ();\n \n-  inferior_thread ()->suspend.stop_pc\n-    = regcache_read_pc (get_current_regcache ());\n+  inferior_thread ()->set_stop_pc (regcache_read_pc (get_current_regcache ()));\n   nullify_last_target_wait_ptid ();\n \n   /* Now restore the file positions of open file descriptors.  */"
    },
    {
      "sha": "dbdae284881bd57f91fdf5dd5feba9a758ef83a6",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -1301,10 +1301,10 @@ get_detach_signal (struct lwp_info *lp)\n \n       if (target_is_non_stop_p () && !tp->executing)\n \t{\n-\t  if (tp->suspend.waitstatus_pending_p)\n-\t    signo = tp->suspend.waitstatus.value.sig;\n+\t  if (tp->has_pending_waitstatus ())\n+\t    signo = tp->pending_waitstatus ().value.sig;\n \t  else\n-\t    signo = tp->suspend.stop_signal;\n+\t    signo = tp->stop_signal ();\n \t}\n       else if (!target_is_non_stop_p ())\n \t{\n@@ -1315,7 +1315,7 @@ get_detach_signal (struct lwp_info *lp)\n \n \t  if (last_target == linux_target\n \t      && lp->ptid.lwp () == last_ptid.lwp ())\n-\t    signo = tp->suspend.stop_signal;\n+\t    signo = tp->stop_signal ();\n \t}\n     }\n \n@@ -1631,8 +1631,8 @@ linux_nat_resume_callback (struct lwp_info *lp, struct lwp_info *except)\n       thread = find_thread_ptid (linux_target, lp->ptid);\n       if (thread != NULL)\n \t{\n-\t  signo = thread->suspend.stop_signal;\n-\t  thread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t  signo = thread->stop_signal ();\n+\t  thread->set_stop_signal (GDB_SIGNAL_0);\n \t}\n     }\n "
    },
    {
      "sha": "8c0885ed5b49ba1f0a0f3337220b22b348c11c43",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -2017,7 +2017,7 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n   thread_info *signalled_thr = gcore_find_signalled_thread ();\n   gdb_signal stop_signal;\n   if (signalled_thr != nullptr)\n-    stop_signal = signalled_thr->suspend.stop_signal;\n+    stop_signal = signalled_thr->stop_signal ();\n   else\n     stop_signal = GDB_SIGNAL_0;\n "
    },
    {
      "sha": "cfbc2f6574f1cf5a57ce54378b8908c9516f7edb",
      "filename": "gdb/python/py-inferior.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/python/py-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/python/py-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-inferior.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -96,7 +96,7 @@ python_on_normal_stop (struct bpstats *bs, int print_frame)\n   if (inferior_ptid == null_ptid)\n     return;\n \n-  stop_signal = inferior_thread ()->suspend.stop_signal;\n+  stop_signal = inferior_thread ()->stop_signal ();\n \n   gdbpy_enter enter_py (get_current_arch (), current_language);\n "
    },
    {
      "sha": "85e357e604a35f266e63d669969626bb03b19d41",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -2795,8 +2795,7 @@ record_btrace_set_replay (struct thread_info *tp,\n   /* Start anew from the new replay position.  */\n   record_btrace_clear_histories (btinfo);\n \n-  inferior_thread ()->suspend.stop_pc\n-    = regcache_read_pc (get_current_regcache ());\n+  inferior_thread ()->set_stop_pc (regcache_read_pc (get_current_regcache ()));\n   print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC, 1);\n }\n "
    },
    {
      "sha": "f5c4244f0edd5e07fbbcfcd6b7ba2bb866748355",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -1993,8 +1993,7 @@ record_full_goto_entry (struct record_full_entry *p)\n \n   registers_changed ();\n   reinit_frame_cache ();\n-  inferior_thread ()->suspend.stop_pc\n-    = regcache_read_pc (get_current_regcache ());\n+  inferior_thread ()->set_stop_pc (regcache_read_pc (get_current_regcache ()));\n   print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC, 1);\n }\n "
    },
    {
      "sha": "6d674c8139f02bd96f37649df7777423cf905033",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 39,
      "deletions": 27,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -766,6 +766,7 @@ class remote_target : public process_stratum_target\n \n   void remote_notice_new_inferior (ptid_t currthread, bool executing);\n \n+  void print_one_stopped_thread (thread_info *thread);\n   void process_initial_stop_replies (int from_tty);\n \n   thread_info *remote_add_thread (ptid_t ptid, bool running, bool executing);\n@@ -4479,20 +4480,36 @@ remote_target::add_current_inferior_and_thread (const char *wait_status)\n /* Print info about a thread that was found already stopped on\n    connection.  */\n \n-static void\n-print_one_stopped_thread (struct thread_info *thread)\n+void\n+remote_target::print_one_stopped_thread (thread_info *thread)\n {\n-  struct target_waitstatus *ws = &thread->suspend.waitstatus;\n+  target_waitstatus ws;\n+\n+  /* If there is a pending waitstatus, use it.  If there isn't it's because\n+     the thread's stop was reported with TARGET_WAITKIND_STOPPED / GDB_SIGNAL_0\n+     and process_initial_stop_replies decided it wasn't interesting to save\n+     and report to the core.  */\n+  if (thread->has_pending_waitstatus ())\n+    {\n+      ws = thread->pending_waitstatus ();\n+      thread->clear_pending_waitstatus ();\n+    }\n+  else\n+    {\n+      ws.kind = TARGET_WAITKIND_STOPPED;\n+      ws.value.sig = GDB_SIGNAL_0;\n+    }\n \n   switch_to_thread (thread);\n-  thread->suspend.stop_pc = get_frame_pc (get_current_frame ());\n+  thread->set_stop_pc (get_frame_pc (get_current_frame ()));\n   set_current_sal_from_frame (get_current_frame ());\n \n-  thread->suspend.waitstatus_pending_p = 0;\n+  /* For \"info program\".  */\n+  set_last_target_status (this, thread->ptid, ws);\n \n-  if (ws->kind == TARGET_WAITKIND_STOPPED)\n+  if (ws.kind == TARGET_WAITKIND_STOPPED)\n     {\n-      enum gdb_signal sig = ws->value.sig;\n+      enum gdb_signal sig = ws.value.sig;\n \n       if (signal_print_state (sig))\n \tgdb::observers::signal_received.notify (sig);\n@@ -4513,6 +4530,9 @@ remote_target::process_initial_stop_replies (int from_tty)\n   struct thread_info *lowest_stopped = NULL;\n   struct thread_info *first = NULL;\n \n+  /* This is only used when the target is non-stop.  */\n+  gdb_assert (target_is_non_stop_p ());\n+\n   /* Consume the initial pending events.  */\n   while (pending_stop_replies-- > 0)\n     {\n@@ -4557,15 +4577,13 @@ remote_target::process_initial_stop_replies (int from_tty)\n \t     instead of signal 0.  Suppress it.  */\n \t  if (sig == GDB_SIGNAL_TRAP)\n \t    sig = GDB_SIGNAL_0;\n-\t  evthread->suspend.stop_signal = sig;\n+\t  evthread->set_stop_signal (sig);\n \t  ws.value.sig = sig;\n \t}\n \n-      evthread->suspend.waitstatus = ws;\n-\n       if (ws.kind != TARGET_WAITKIND_STOPPED\n \t  || ws.value.sig != GDB_SIGNAL_0)\n-\tevthread->suspend.waitstatus_pending_p = 1;\n+\tevthread->set_pending_waitstatus (ws);\n \n       set_executing (this, event_ptid, false);\n       set_running (this, event_ptid, false);\n@@ -4619,8 +4637,7 @@ remote_target::process_initial_stop_replies (int from_tty)\n       else if (thread->state != THREAD_STOPPED)\n \tcontinue;\n \n-      if (selected == NULL\n-\t  && thread->suspend.waitstatus_pending_p)\n+      if (selected == nullptr && thread->has_pending_waitstatus ())\n \tselected = thread;\n \n       if (lowest_stopped == NULL\n@@ -4644,11 +4661,6 @@ remote_target::process_initial_stop_replies (int from_tty)\n \n       print_one_stopped_thread (thread);\n     }\n-\n-  /* For \"info program\".  */\n-  thread_info *thread = inferior_thread ();\n-  if (thread->state == THREAD_STOPPED)\n-    set_last_target_status (this, inferior_ptid, thread->suspend.waitstatus);\n }\n \n /* Start the remote connection and sync state.  */\n@@ -6260,11 +6272,11 @@ remote_target::append_pending_thread_resumptions (char *p, char *endp,\n {\n   for (thread_info *thread : all_non_exited_threads (this, ptid))\n     if (inferior_ptid != thread->ptid\n-\t&& thread->suspend.stop_signal != GDB_SIGNAL_0)\n+\t&& thread->stop_signal () != GDB_SIGNAL_0)\n       {\n \tp = append_resumption (p, endp, thread->ptid,\n-\t\t\t       0, thread->suspend.stop_signal);\n-\tthread->suspend.stop_signal = GDB_SIGNAL_0;\n+\t\t\t       0, thread->stop_signal ());\n+\tthread->set_stop_signal (GDB_SIGNAL_0);\n \tresume_clear_thread_private_info (thread);\n       }\n \n@@ -7202,7 +7214,7 @@ struct notif_client notif_client_stop =\n    -1 if we want to check all threads.  */\n \n static int\n-is_pending_fork_parent (struct target_waitstatus *ws, int event_pid,\n+is_pending_fork_parent (const target_waitstatus *ws, int event_pid,\n \t\t\tptid_t thread_ptid)\n {\n   if (ws->kind == TARGET_WAITKIND_FORKED\n@@ -7218,11 +7230,11 @@ is_pending_fork_parent (struct target_waitstatus *ws, int event_pid,\n /* Return the thread's pending status used to determine whether the\n    thread is a fork parent stopped at a fork event.  */\n \n-static struct target_waitstatus *\n+static const target_waitstatus *\n thread_pending_fork_status (struct thread_info *thread)\n {\n-  if (thread->suspend.waitstatus_pending_p)\n-    return &thread->suspend.waitstatus;\n+  if (thread->has_pending_waitstatus ())\n+    return &thread->pending_waitstatus ();\n   else\n     return &thread->pending_follow;\n }\n@@ -7232,7 +7244,7 @@ thread_pending_fork_status (struct thread_info *thread)\n static int\n is_pending_fork_parent_thread (struct thread_info *thread)\n {\n-  struct target_waitstatus *ws = thread_pending_fork_status (thread);\n+  const target_waitstatus *ws = thread_pending_fork_status (thread);\n   int pid = -1;\n \n   return is_pending_fork_parent (ws, pid, thread->ptid);\n@@ -7254,7 +7266,7 @@ remote_target::remove_new_fork_children (threads_listing_context *context)\n      fork child threads from the CONTEXT list.  */\n   for (thread_info *thread : all_non_exited_threads (this))\n     {\n-      struct target_waitstatus *ws = thread_pending_fork_status (thread);\n+      const target_waitstatus *ws = thread_pending_fork_status (thread);\n \n       if (is_pending_fork_parent (ws, pid, thread->ptid))\n \tcontext->remove_thread (ws->value.related_pid);"
    },
    {
      "sha": "289d33c74c3b3c41536b5df31cdb0369ec6e4171",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 23,
      "deletions": 2,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1edb66d856c82c389edfd7610143236a68c76846/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1edb66d856c82c389edfd7610143236a68c76846/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=1edb66d856c82c389edfd7610143236a68c76846",
      "patch": "@@ -275,7 +275,7 @@ thread_info::thread_info (struct inferior *inf_, ptid_t ptid_)\n   /* Nothing to follow yet.  */\n   memset (&this->pending_follow, 0, sizeof (this->pending_follow));\n   this->pending_follow.kind = TARGET_WAITKIND_SPURIOUS;\n-  this->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+  this->m_suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n }\n \n thread_info::~thread_info ()\n@@ -295,6 +295,27 @@ thread_info::deletable () const\n \n /* See gdbthread.h.  */\n \n+void\n+thread_info::set_pending_waitstatus (const target_waitstatus &ws)\n+{\n+  gdb_assert (!this->has_pending_waitstatus ());\n+\n+  m_suspend.waitstatus = ws;\n+  m_suspend.waitstatus_pending_p = 1;\n+}\n+\n+/* See gdbthread.h.  */\n+\n+void\n+thread_info::clear_pending_waitstatus ()\n+{\n+  gdb_assert (this->has_pending_waitstatus ());\n+\n+  m_suspend.waitstatus_pending_p = 0;\n+}\n+\n+/* See gdbthread.h.  */\n+\n int\n thread_is_in_step_over_chain (struct thread_info *tp)\n {\n@@ -771,7 +792,7 @@ set_executing_thread (thread_info *thr, bool executing)\n {\n   thr->executing = executing;\n   if (executing)\n-    thr->suspend.stop_pc = ~(CORE_ADDR) 0;\n+    thr->set_stop_pc (~(CORE_ADDR) 0);\n }\n \n void"
    }
  ]
}