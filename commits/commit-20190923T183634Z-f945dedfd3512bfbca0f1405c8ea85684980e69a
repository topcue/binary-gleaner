{
  "sha": "f945dedfd3512bfbca0f1405c8ea85684980e69a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Zjk0NWRlZGZkMzUxMmJmYmNhMGYxNDA1YzhlYTg1Njg0OTgwZTY5YQ==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-08-28T20:40:31Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-09-23T18:36:34Z"
    },
    "message": "Make ada_decode not use a static buffer\n\nThis makes it safer to use in general, and also allows using it on a\nbackground thread in the future.\n\nInspired by tromey's patch at:\nhttps://github.com/tromey/gdb/commit/1226cbdfa436297a5dec054d94592c45891afa93\n(however, implemented in a different way)\n\ngdb/ChangeLog:\n\n2019-09-23  Christian Biesinger  <cbiesinger@google.com>\n\n\t* ada-exp.y (write_object_remaining): Update.\n\t* ada-lang.c (ada_decode): Return a std::string instead of a char*\n\tand eliminate the static buffer.\n\t(ada_decode_symbol): Update.\n\t(ada_la_decode): Update.\n\t(ada_sniff_from_mangled_name): Update.\n\t(is_valid_name_for_wild_match): Update.\n\t(ada_lookup_name_info::matches): Update and simplify.\n\t(name_matches_regex): Update.\n\t(ada_add_global_exceptions): Update.\n\t* ada-lang.h (ada_decode): Update signature.\n\t* ada-varobj.c (ada_varobj_describe_simple_array_child): Update.\n\t* dwarf-index-write.c (debug_names::insert): Update.",
    "tree": {
      "sha": "706c59bb9ef87edd16339939c6b547c72494bfcd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/706c59bb9ef87edd16339939c6b547c72494bfcd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f945dedfd3512bfbca0f1405c8ea85684980e69a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f945dedfd3512bfbca0f1405c8ea85684980e69a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f945dedfd3512bfbca0f1405c8ea85684980e69a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f945dedfd3512bfbca0f1405c8ea85684980e69a/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4a41f3face78a551ea5c85db24125989754f2ee8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a41f3face78a551ea5c85db24125989754f2ee8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4a41f3face78a551ea5c85db24125989754f2ee8"
    }
  ],
  "stats": {
    "total": 98,
    "additions": 52,
    "deletions": 46
  },
  "files": [
    {
      "sha": "33951b88c633dadf45561f412e11b140cb9655eb",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -1,3 +1,19 @@\n+2019-09-23  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* ada-exp.y (write_object_remaining): Update.\n+\t* ada-lang.c (ada_decode): Return a std::string instead of a char*\n+\tand eliminate the static buffer.\n+\t(ada_decode_symbol): Update.\n+\t(ada_la_decode): Update.\n+\t(ada_sniff_from_mangled_name): Update.\n+\t(is_valid_name_for_wild_match): Update.\n+\t(ada_lookup_name_info::matches): Update and simplify.\n+\t(name_matches_regex): Update.\n+\t(ada_add_global_exceptions): Update.\n+\t* ada-lang.h (ada_decode): Update signature.\n+\t* ada-varobj.c (ada_varobj_describe_simple_array_child): Update.\n+\t* dwarf-index-write.c (debug_names::insert): Update.\n+\n 2019-09-21  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* solib-svr4.c (svr4_iterate_over_objfiles_in_search_order): Fix"
    },
    {
      "sha": "160e64bc05be5a6d3f44e49e5ff75decaca81794",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -816,7 +816,7 @@ write_object_renaming (struct parser_state *par_state,\n \t\t\t  renamed_entity_len);\n   ada_lookup_encoded_symbol (name, orig_left_context, VAR_DOMAIN, &sym_info);\n   if (sym_info.symbol == NULL)\n-    error (_(\"Could not find renamed variable: %s\"), ada_decode (name));\n+    error (_(\"Could not find renamed variable: %s\"), ada_decode (name).c_str ());\n   else if (SYMBOL_CLASS (sym_info.symbol) == LOC_TYPEDEF)\n     /* We have a renaming of an old-style renaming symbol.  Don't\n        trust the block information.  */"
    },
    {
      "sha": "063b98bde5b725a5f59e1e3fb7e067fc0dcf4cd7",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 24,
      "deletions": 39,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -1105,22 +1105,16 @@ ada_remove_po_subprogram_suffix (const char *encoded, int *len)\n \n /* If ENCODED follows the GNAT entity encoding conventions, then return\n    the decoded form of ENCODED.  Otherwise, return \"<%s>\" where \"%s\" is\n-   replaced by ENCODED.\n+   replaced by ENCODED.  */\n \n-   The resulting string is valid until the next call of ada_decode.\n-   If the string is unchanged by decoding, the original string pointer\n-   is returned.  */\n-\n-const char *\n+std::string\n ada_decode (const char *encoded)\n {\n   int i, j;\n   int len0;\n   const char *p;\n-  char *decoded;\n   int at_start_name;\n-  static char *decoding_buffer = NULL;\n-  static size_t decoding_buffer_size = 0;\n+  std::string decoded;\n \n   /* With function descriptors on PPC64, the value of a symbol named\n      \".FN\", if it exists, is the entry point of the function \"FN\".  */\n@@ -1179,8 +1173,7 @@ ada_decode (const char *encoded)\n \n   /* Make decoded big enough for possible expansion by operator name.  */\n \n-  GROW_VECT (decoding_buffer, decoding_buffer_size, 2 * len0 + 1);\n-  decoded = decoding_buffer;\n+  decoded.resize (2 * len0 + 1, 'X');\n \n   /* Remove trailing __{digit}+ or trailing ${digit}+.  */\n \n@@ -1217,7 +1210,7 @@ ada_decode (const char *encoded)\n                             op_len - 1) == 0)\n                   && !isalnum (encoded[i + op_len]))\n                 {\n-                  strcpy (decoded + j, ada_opname_table[k].decoded);\n+                  strcpy (&decoded.front() + j, ada_opname_table[k].decoded);\n                   at_start_name = 0;\n                   i += op_len;\n                   j += strlen (ada_opname_table[k].decoded);\n@@ -1338,27 +1331,22 @@ ada_decode (const char *encoded)\n           j += 1;\n         }\n     }\n-  decoded[j] = '\\000';\n+  decoded.resize (j);\n \n   /* Decoded names should never contain any uppercase character.\n      Double-check this, and abort the decoding if we find one.  */\n \n-  for (i = 0; decoded[i] != '\\0'; i += 1)\n+  for (i = 0; i < decoded.length(); ++i)\n     if (isupper (decoded[i]) || decoded[i] == ' ')\n       goto Suppress;\n \n-  if (strcmp (decoded, encoded) == 0)\n-    return encoded;\n-  else\n-    return decoded;\n+  return decoded;\n \n Suppress:\n-  GROW_VECT (decoding_buffer, decoding_buffer_size, strlen (encoded) + 3);\n-  decoded = decoding_buffer;\n   if (encoded[0] == '<')\n-    strcpy (decoded, encoded);\n+    decoded = encoded;\n   else\n-    xsnprintf (decoded, decoding_buffer_size, \"<%s>\", encoded);\n+    decoded = '<' + std::string(encoded) + '>';\n   return decoded;\n \n }\n@@ -1389,13 +1377,13 @@ ada_decode_symbol (const struct general_symbol_info *arg)\n \n   if (!gsymbol->ada_mangled)\n     {\n-      const char *decoded = ada_decode (gsymbol->name);\n+      std::string decoded = ada_decode (gsymbol->name);\n       struct obstack *obstack = gsymbol->language_specific.obstack;\n \n       gsymbol->ada_mangled = 1;\n \n       if (obstack != NULL)\n-\t*resultp = obstack_strdup (obstack, decoded);\n+\t*resultp = obstack_strdup (obstack, decoded.c_str ());\n       else\n         {\n \t  /* Sometimes, we can't find a corresponding objfile, in\n@@ -1404,10 +1392,10 @@ ada_decode_symbol (const struct general_symbol_info *arg)\n \t     significant memory leak (FIXME).  */\n \n           char **slot = (char **) htab_find_slot (decoded_names_store,\n-                                                  decoded, INSERT);\n+                                                  decoded.c_str (), INSERT);\n \n           if (*slot == NULL)\n-            *slot = xstrdup (decoded);\n+            *slot = xstrdup (decoded.c_str ());\n           *resultp = *slot;\n         }\n     }\n@@ -1418,19 +1406,19 @@ ada_decode_symbol (const struct general_symbol_info *arg)\n static char *\n ada_la_decode (const char *encoded, int options)\n {\n-  return xstrdup (ada_decode (encoded));\n+  return xstrdup (ada_decode (encoded).c_str ());\n }\n \n /* Implement la_sniff_from_mangled_name for Ada.  */\n \n static int\n ada_sniff_from_mangled_name (const char *mangled, char **out)\n {\n-  const char *demangled = ada_decode (mangled);\n+  std::string demangled = ada_decode (mangled);\n \n   *out = NULL;\n \n-  if (demangled != mangled && demangled != NULL && demangled[0] != '<')\n+  if (demangled != mangled && demangled[0] != '<')\n     {\n       /* Set the gsymbol language to Ada, but still return 0.\n \t Two reasons for that:\n@@ -5993,7 +5981,7 @@ is_name_suffix (const char *str)\n static int\n is_valid_name_for_wild_match (const char *name0)\n {\n-  const char *decoded_name = ada_decode (name0);\n+  std::string decoded_name = ada_decode (name0);\n   int i;\n \n   /* If the decoded name starts with an angle bracket, it means that\n@@ -6233,19 +6221,16 @@ ada_lookup_name_info::matches\n   if (strncmp (sym_name, text, text_len) == 0)\n     match = true;\n \n+  std::string decoded_name = ada_decode (sym_name);\n   if (match && !m_encoded_p)\n     {\n       /* One needed check before declaring a positive match is to verify\n          that iff we are doing a verbatim match, the decoded version\n          of the symbol name starts with '<'.  Otherwise, this symbol name\n          is not a suitable completion.  */\n-      const char *sym_name_copy = sym_name;\n-      bool has_angle_bracket;\n \n-      sym_name = ada_decode (sym_name);\n-      has_angle_bracket = (sym_name[0] == '<');\n+      bool has_angle_bracket = (decoded_name[0] == '<');\n       match = (has_angle_bracket == m_verbatim_p);\n-      sym_name = sym_name_copy;\n     }\n \n   if (match && !m_verbatim_p)\n@@ -6269,7 +6254,7 @@ ada_lookup_name_info::matches\n       /* Since we are doing wild matching, this means that TEXT\n          may represent an unqualified symbol name.  We therefore must\n          also compare TEXT against the unqualified name of the symbol.  */\n-      sym_name = ada_unqualified_name (ada_decode (sym_name));\n+      sym_name = ada_unqualified_name (decoded_name.c_str ());\n \n       if (strncmp (sym_name, text, text_len) == 0)\n \tmatch = true;\n@@ -13494,7 +13479,7 @@ static bool\n name_matches_regex (const char *name, compiled_regex *preg)\n {\n   return (preg == NULL\n-\t  || preg->exec (ada_decode (name), 0, NULL, 0) == 0);\n+\t  || preg->exec (ada_decode (name).c_str (), 0, NULL, 0) == 0);\n }\n \n /* Add all exceptions defined globally whose name name match\n@@ -13527,8 +13512,8 @@ ada_add_global_exceptions (compiled_regex *preg,\n \t\t\t   lookup_name_info::match_any (),\n \t\t\t   [&] (const char *search_name)\n \t\t\t   {\n-\t\t\t     const char *decoded = ada_decode (search_name);\n-\t\t\t     return name_matches_regex (decoded, preg);\n+\t\t\t     std::string decoded = ada_decode (search_name);\n+\t\t\t     return name_matches_regex (decoded.c_str (), preg);\n \t\t\t   },\n \t\t\t   NULL,\n \t\t\t   VARIABLES_DOMAIN);"
    },
    {
      "sha": "c7279d5ac39fbd7dcac688c956c647e5180fa36e",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -227,7 +227,7 @@ extern struct type *ada_get_decoded_type (struct type *type);\n \n extern const char *ada_decode_symbol (const struct general_symbol_info *);\n \n-extern const char *ada_decode (const char*);\n+extern std::string ada_decode (const char*);\n \n extern enum language ada_update_initial_language (enum language);\n "
    },
    {
      "sha": "1a5d0ac2393909cb084cb5bef82292c0fe8ebab9",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -624,6 +624,7 @@ ada_varobj_describe_simple_array_child (struct value *parent_value,\n \t of the array index type when such type qualification is\n \t needed.  */\n       const char *index_type_name = NULL;\n+      std::string decoded;\n \n       /* If the index type is a range type, find the base type.  */\n       while (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n@@ -634,7 +635,10 @@ ada_varobj_describe_simple_array_child (struct value *parent_value,\n \t{\n \t  index_type_name = ada_type_name (index_type);\n \t  if (index_type_name)\n-\t    index_type_name = ada_decode (index_type_name);\n+\t    {\n+\t      decoded = ada_decode (index_type_name);\n+\t      index_type_name = decoded.c_str ();\n+\t    }\n \t}\n \n       if (index_type_name != NULL)"
    },
    {
      "sha": "0947ba9ec149ade815d9457fd7f21fe83e0752ca",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f945dedfd3512bfbca0f1405c8ea85684980e69a/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "patch": "@@ -714,13 +714,14 @@ class debug_names\n \t   name (of the form \"<MumBle>\") must be entered without the\n \t   angle brackets.  Note that the current index is unusual,\n \t   see PR symtab/24820 for details.  */\n-\tconst char *decoded = ada_decode (name);\n+\tstd::string decoded = ada_decode (name);\n \tif (decoded[0] == '<')\n \t  name = (char *) obstack_copy0 (&m_string_obstack,\n-\t\t\t\t\t decoded + 1,\n-\t\t\t\t\t strlen (decoded + 1) - 1);\n+\t\t\t\t\t decoded.c_str () + 1,\n+\t\t\t\t\t decoded.length () - 2);\n \telse\n-\t  name = obstack_strdup (&m_string_obstack, ada_encode (decoded));\n+\t  name = obstack_strdup (&m_string_obstack,\n+\t\t\t\t ada_encode (decoded.c_str ()));\n       }\n \n     const auto insertpair"
    }
  ]
}