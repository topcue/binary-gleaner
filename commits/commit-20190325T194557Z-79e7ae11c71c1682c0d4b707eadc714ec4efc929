{
  "sha": "79e7ae11c71c1682c0d4b707eadc714ec4efc929",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzllN2FlMTFjNzFjMTY4MmMwZDRiNzA3ZWFkYzcxNGVjNGVmYzkyOQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-03-25T19:45:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-03-25T19:45:57Z"
    },
    "message": "Clean up some comments in minsyms.c\n\nPhilippe pointed out that some comments in minsyms.c still referred to\nobstack allocation.  This patch fixes these up.\n\nIn most cases here, my view is that the comments were more misleading\nthan helpful.  So, I've generally removed text.\n\ngdb/ChangeLog\n2019-03-25  Tom Tromey  <tromey@adacore.com>\n\n\t* minsyms.c (BUNCH_SIZE): Update comment.\n\t(~minimal_symbol_reader): Remove old comment.\n\t(compact_minimal_symbols): Update comment.\n\t(minimal_symbol_reader::install): Remove old comment.  Update\n\tother comments.",
    "tree": {
      "sha": "28fa405b2700eddabfca24556a42ac4872d2428a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/28fa405b2700eddabfca24556a42ac4872d2428a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/79e7ae11c71c1682c0d4b707eadc714ec4efc929",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/79e7ae11c71c1682c0d4b707eadc714ec4efc929",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/79e7ae11c71c1682c0d4b707eadc714ec4efc929",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/79e7ae11c71c1682c0d4b707eadc714ec4efc929/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d45963c2b26369e3b375cf5b3b6f52f50f767ef3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d45963c2b26369e3b375cf5b3b6f52f50f767ef3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d45963c2b26369e3b375cf5b3b6f52f50f767ef3"
    }
  ],
  "stats": {
    "total": 57,
    "additions": 15,
    "deletions": 42
  },
  "files": [
    {
      "sha": "3d0481fcba15bf0cc3ba02349a241044eb000f6e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79e7ae11c71c1682c0d4b707eadc714ec4efc929/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79e7ae11c71c1682c0d4b707eadc714ec4efc929/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=79e7ae11c71c1682c0d4b707eadc714ec4efc929",
      "patch": "@@ -1,3 +1,11 @@\n+2019-03-25  Tom Tromey  <tromey@adacore.com>\n+\n+\t* minsyms.c (BUNCH_SIZE): Update comment.\n+\t(~minimal_symbol_reader): Remove old comment.\n+\t(compact_minimal_symbols): Update comment.\n+\t(minimal_symbol_reader::install): Remove old comment.  Update\n+\tother comments.\n+\n 2019-03-25  Alan Hayward  <alan.hayward@arm.com>\n \n \t* s390-linux-nat.c: Add include."
    },
    {
      "sha": "777f545d84aaa91999810f57e7fc81ad257b54cf",
      "filename": "gdb/minsyms.c",
      "status": "modified",
      "additions": 7,
      "deletions": 42,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/79e7ae11c71c1682c0d4b707eadc714ec4efc929/gdb/minsyms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/79e7ae11c71c1682c0d4b707eadc714ec4efc929/gdb/minsyms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/minsyms.c?ref=79e7ae11c71c1682c0d4b707eadc714ec4efc929",
      "patch": "@@ -92,8 +92,7 @@ msymbol_is_function (struct objfile *objfile, minimal_symbol *minsym,\n }\n \n /* Accumulate the minimal symbols for each objfile in bunches of BUNCH_SIZE.\n-   At the end, copy them all into one newly allocated location on an objfile's\n-   per-BFD storage obstack.  */\n+   At the end, copy them all into one newly allocated array.  */\n \n #define BUNCH_SIZE 127\n \n@@ -1031,11 +1030,7 @@ minimal_symbol_reader::minimal_symbol_reader (struct objfile *obj)\n \n /* Discard the currently collected minimal symbols, if any.  If we wish\n    to save them for later use, we must have already copied them somewhere\n-   else before calling this function.\n-\n-   FIXME:  We could allocate the minimal symbol bunches on their own\n-   obstack and then simply blow the obstack away when we are done with\n-   it.  Is it worth the extra trouble though?  */\n+   else before calling this function.  */\n \n minimal_symbol_reader::~minimal_symbol_reader ()\n {\n@@ -1231,15 +1226,6 @@ compare_minimal_symbols (const void *fn1p, const void *fn2p)\n    to linearly scan the table, which is done in a number of places.  So we\n    just do one linear scan here and toss out the duplicates.\n \n-   Note that we are not concerned here about recovering the space that\n-   is potentially freed up, because the strings themselves are allocated\n-   on the storage_obstack, and will get automatically freed when the symbol\n-   table is freed.  The caller can free up the unused minimal symbols at\n-   the end of the compacted region if their allocation strategy allows it.\n-\n-   Also note we only go up to the next to last entry within the loop\n-   and then copy the last entry explicitly after the loop terminates.\n-\n    Since the different sources of information for each symbol may\n    have different levels of \"completeness\", we may have duplicates\n    that have one entry with type \"mst_unknown\" and the other with a\n@@ -1315,24 +1301,7 @@ build_minimal_symbol_hash_tables (struct objfile *objfile)\n    minimal symbol table.  In most cases there is no minimal symbol table yet\n    for this objfile, and the existing bunches are used to create one.  Once\n    in a while (for shared libraries for example), we add symbols (e.g. common\n-   symbols) to an existing objfile.\n-\n-   Because of the way minimal symbols are collected, we generally have no way\n-   of knowing what source language applies to any particular minimal symbol.\n-   Specifically, we have no way of knowing if the minimal symbol comes from a\n-   C++ compilation unit or not.  So for the sake of supporting cached\n-   demangled C++ names, we have no choice but to try and demangle each new one\n-   that comes in.  If the demangling succeeds, then we assume it is a C++\n-   symbol and set the symbol's language and demangled name fields\n-   appropriately.  Note that in order to avoid unnecessary demanglings, and\n-   allocating obstack space that subsequently can't be freed for the demangled\n-   names, we mark all newly added symbols with language_auto.  After\n-   compaction of the minimal symbols, we go back and scan the entire minimal\n-   symbol table looking for these new symbols.  For each new symbol we attempt\n-   to demangle it, and if successful, record it as a language_cplus symbol\n-   and cache the demangled form on the symbol obstack.  Symbols which don't\n-   demangle are marked as language_unknown symbols, which inhibits future\n-   attempts to demangle them if we later add more minimal symbols.  */\n+   symbols) to an existing objfile.  */\n \n void\n minimal_symbol_reader::install ()\n@@ -1354,10 +1323,10 @@ minimal_symbol_reader::install ()\n \t\t\t      m_msym_count, objfile_name (m_objfile));\n \t}\n \n-      /* Allocate enough space in the obstack, into which we will gather the\n-         bunches of new and existing minimal symbols, sort them, and then\n-         compact out the duplicate entries.  Once we have a final table,\n-         we will give back the excess space.  */\n+      /* Allocate enough space, into which we will gather the bunches\n+         of new and existing minimal symbols, sort them, and then\n+         compact out the duplicate entries.  Once we have a final\n+         table, we will give back the excess space.  */\n \n       alloc_count = m_msym_count + m_objfile->per_bfd->minimal_symbol_count;\n       gdb::unique_xmalloc_ptr<minimal_symbol>\n@@ -1407,10 +1376,6 @@ minimal_symbol_reader::install ()\n       m_objfile->per_bfd->minimal_symbol_count = mcount;\n       m_objfile->per_bfd->msymbols = std::move (msym_holder);\n \n-      /* Now build the hash tables; we can't do this incrementally\n-         at an earlier point since we weren't finished with the obstack\n-\t yet.  (And if the msymbol obstack gets moved, all the internal\n-\t pointers to other msymbols need to be adjusted.)  */\n       build_minimal_symbol_hash_tables (m_objfile);\n     }\n }"
    }
  ]
}