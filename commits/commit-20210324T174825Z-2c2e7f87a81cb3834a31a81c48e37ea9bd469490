{
  "sha": "2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmMyZTdmODdhODFjYjM4MzRhMzFhODFjNDhlMzdlYTliZDQ2OTQ5MA==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-15T18:18:55Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:48:25Z"
    },
    "message": "Add GDB-side remote target support for memory tagging\n\nThis patch adds memory tagging support to GDB's remote side, with\npacket string checks, new packet support and an implementation of\nthe two new tags methods fetch_memtags and store_memtags.\n\nGDBserver needs to know how to read/write allocation tags, since that is\ndone via ptrace.  It doesn't need to know about logical tags.\n\nThe new packets are:\n\nqMemTags:<address>,<length>:<type>\n--\n\nReads tags of the specified type from the address range\n[<address>, <address + length>)\n\nQMemTags:<address>,<length>:<type>:<uninterpreted tag bytes>\n--\nWrites the tags of specified type represented by the uninterpreted bytes to\nthe address range [<address>, <address + length>).\n\nThe interpretation of what to do with the tag bytes is up to the arch-specific\ncode.\n\nNote that these new packets consider the case of packet size overflow as an\nerror, given the common use case is to read/write only a few memory tags at\na time.  Having to use a couple new packets for multi-part transfers wouldn't\nmake sense for the little use it would have.\n\ngdb/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* remote.c (PACKET_memory_tagging_feature): New enum.\n\t(remote_memory_tagging_p): New function.\n\t(remote_protocol_features): New \"memory-tagging\" entry.\n\t(remote_target::remote_query_supported): Handle memory tagging\n\tsupport.\n\t(remote_target::supports_memory_tagging): Implement.\n\t(create_fetch_memtags_request, parse_fetch_memtags_reply)\n\t(create_store_memtags_request): New functions.\n\t(remote_target::fetch_memtags): Implement.\n\t(remote_target::store_memtags): Implement.\n\t(_initialize_remote): Add new \"memory-tagging-feature\"\n\tconfig command.",
    "tree": {
      "sha": "96ab0612a95413a5643999adf1233ab0e85cdd5d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/96ab0612a95413a5643999adf1233ab0e85cdd5d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c2e7f87a81cb3834a31a81c48e37ea9bd469490/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c193949e75809a656b99c8408e5b29504aec436a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c193949e75809a656b99c8408e5b29504aec436a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c193949e75809a656b99c8408e5b29504aec436a"
    }
  ],
  "stats": {
    "total": 121,
    "additions": 118,
    "deletions": 3
  },
  "files": [
    {
      "sha": "333b3c2e275d2857328dba0e79fbd9c101002110",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c2e7f87a81cb3834a31a81c48e37ea9bd469490/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c2e7f87a81cb3834a31a81c48e37ea9bd469490/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
      "patch": "@@ -1,3 +1,18 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* remote.c (PACKET_memory_tagging_feature): New enum.\n+\t(remote_memory_tagging_p): New function.\n+\t(remote_protocol_features): New \"memory-tagging\" entry.\n+\t(remote_target::remote_query_supported): Handle memory tagging\n+\tsupport.\n+\t(remote_target::supports_memory_tagging): Implement.\n+\t(create_fetch_memtags_request, parse_fetch_memtags_reply)\n+\t(create_store_memtags_request): New functions.\n+\t(remote_target::fetch_memtags): Implement.\n+\t(remote_target::store_memtags): Implement.\n+\t(_initialize_remote): Add new \"memory-tagging-feature\"\n+\tconfig command.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* arch-utils.c (default_memtag_to_string, default_tagged_address_p)"
    },
    {
      "sha": "1fe6ed44fdf30995a5885c2c7f0274783eefed6e",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 103,
      "deletions": 3,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2c2e7f87a81cb3834a31a81c48e37ea9bd469490/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2c2e7f87a81cb3834a31a81c48e37ea9bd469490/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=2c2e7f87a81cb3834a31a81c48e37ea9bd469490",
      "patch": "@@ -2175,6 +2175,10 @@ enum {\n   /* Support TARGET_WAITKIND_NO_RESUMED.  */\n   PACKET_no_resumed,\n \n+  /* Support for memory tagging, allocation tag fetch/store\n+     packets and the tag violation stop replies.  */\n+  PACKET_memory_tagging_feature,\n+\n   PACKET_MAX\n };\n \n@@ -2316,6 +2320,14 @@ remote_exec_event_p (struct remote_state *rs)\n   return packet_support (PACKET_exec_event_feature) == PACKET_ENABLE;\n }\n \n+/* Returns true if memory tagging is supported, false otherwise.  */\n+\n+static bool\n+remote_memory_tagging_p ()\n+{\n+  return packet_support (PACKET_memory_tagging_feature) == PACKET_ENABLE;\n+}\n+\n /* Insert fork catchpoint target routine.  If fork events are enabled\n    then return success, nothing more to do.  */\n \n@@ -5315,6 +5327,8 @@ static const struct protocol_feature remote_protocol_features[] = {\n   { \"vContSupported\", PACKET_DISABLE, remote_supported_packet, PACKET_vContSupported },\n   { \"QThreadEvents\", PACKET_DISABLE, remote_supported_packet, PACKET_QThreadEvents },\n   { \"no-resumed\", PACKET_DISABLE, remote_supported_packet, PACKET_no_resumed },\n+  { \"memory-tagging\", PACKET_DISABLE, remote_supported_packet,\n+    PACKET_memory_tagging_feature },\n };\n \n static char *remote_support_xml;\n@@ -5409,6 +5423,10 @@ remote_target::remote_query_supported ()\n       if (packet_set_cmd_state (PACKET_no_resumed) != AUTO_BOOLEAN_FALSE)\n \tremote_query_supported_append (&q, \"no-resumed+\");\n \n+      if (packet_set_cmd_state (PACKET_memory_tagging_feature)\n+\t  != AUTO_BOOLEAN_FALSE)\n+\tremote_query_supported_append (&q, \"memory-tagging+\");\n+\n       /* Keep this one last to work around a gdbserver <= 7.10 bug in\n \t the qSupported:xmlRegisters=i386 handling.  */\n       if (remote_support_xml != NULL\n@@ -14502,7 +14520,63 @@ show_remote_timeout (struct ui_file *file, int from_tty,\n bool\n remote_target::supports_memory_tagging ()\n {\n-  return false;\n+  return remote_memory_tagging_p ();\n+}\n+\n+/* Create the qMemTags packet given ADDRESS, LEN and TYPE.  */\n+\n+static void\n+create_fetch_memtags_request (gdb::char_vector &packet, CORE_ADDR address,\n+\t\t\t      size_t len, int type)\n+{\n+  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;\n+\n+  std::string request = string_printf (\"qMemTags:%s,%s:%s\",\n+\t\t\t\t       phex_nz (address, addr_size),\n+\t\t\t\t       phex_nz (len, sizeof (len)),\n+\t\t\t\t       phex_nz (type, sizeof (type)));\n+\n+  strcpy (packet.data (), request.c_str ());\n+}\n+\n+/* Parse the qMemTags packet reply into TAGS.\n+\n+   Return true if successful, false otherwise.  */\n+\n+static bool\n+parse_fetch_memtags_reply (const gdb::char_vector &reply,\n+\t\t\t   gdb::byte_vector &tags)\n+{\n+  if (reply.empty () || reply[0] == 'E' || reply[0] != 'm')\n+    return false;\n+\n+  /* Copy the tag data.  */\n+  tags = hex2bin (reply.data () + 1);\n+\n+  return true;\n+}\n+\n+/* Create the QMemTags packet given ADDRESS, LEN, TYPE and TAGS.  */\n+\n+static void\n+create_store_memtags_request (gdb::char_vector &packet, CORE_ADDR address,\n+\t\t\t      size_t len, int type,\n+\t\t\t      const gdb::byte_vector &tags)\n+{\n+  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;\n+\n+  /* Put together the main packet, address and length.  */\n+  std::string request = string_printf (\"QMemTags:%s,%s:%s:\",\n+\t\t\t\t       phex_nz (address, addr_size),\n+\t\t\t\t       phex_nz (len, sizeof (len)),\n+\t\t\t\t       phex_nz (type, sizeof (type)));\n+  request += bin2hex (tags.data (), tags.size ());\n+\n+  /* Check if we have exceeded the maximum packet size.  */\n+  if (packet.size () < request.length ())\n+    error (_(\"Contents too big for packet QMemTags.\"));\n+\n+  strcpy (packet.data (), request.c_str ());\n }\n \n /* Implement the \"fetch_memtags\" target_ops method.  */\n@@ -14511,7 +14585,18 @@ bool\n remote_target::fetch_memtags (CORE_ADDR address, size_t len,\n \t\t\t      gdb::byte_vector &tags, int type)\n {\n-  return false;\n+  /* Make sure the qMemTags packet is supported.  */\n+  if (!remote_memory_tagging_p ())\n+    gdb_assert_not_reached (\"remote fetch_memtags called with packet disabled\");\n+\n+  struct remote_state *rs = get_remote_state ();\n+\n+  create_fetch_memtags_request (rs->buf, address, len, type);\n+\n+  putpkt (rs->buf);\n+  getpkt (&rs->buf, 0);\n+\n+  return parse_fetch_memtags_reply (rs->buf, tags);\n }\n \n /* Implement the \"store_memtags\" target_ops method.  */\n@@ -14520,7 +14605,19 @@ bool\n remote_target::store_memtags (CORE_ADDR address, size_t len,\n \t\t\t      const gdb::byte_vector &tags, int type)\n {\n-  return false;\n+  /* Make sure the QMemTags packet is supported.  */\n+  if (!remote_memory_tagging_p ())\n+    gdb_assert_not_reached (\"remote store_memtags called with packet disabled\");\n+\n+  struct remote_state *rs = get_remote_state ();\n+\n+  create_store_memtags_request (rs->buf, address, len, type, tags);\n+\n+  putpkt (rs->buf);\n+  getpkt (&rs->buf, 0);\n+\n+  /* Verify if the request was successful.  */\n+  return packet_check_result (rs->buf.data ()) == PACKET_OK;\n }\n \n void _initialize_remote ();\n@@ -14922,6 +15019,9 @@ Show the maximum size of the address (in bits) in a memory packet.\"), NULL,\n   add_packet_config_cmd (&remote_protocol_packets[PACKET_no_resumed],\n \t\t\t \"N stop reply\", \"no-resumed-stop-reply\", 0);\n \n+  add_packet_config_cmd (&remote_protocol_packets[PACKET_memory_tagging_feature],\n+\t\t\t \"memory-tagging-feature\", \"memory-tagging-feature\", 0);\n+\n   /* Assert that we've registered \"set remote foo-packet\" commands\n      for all packet configs.  */\n   {"
    }
  ]
}