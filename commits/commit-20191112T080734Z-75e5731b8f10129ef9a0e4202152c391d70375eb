{
  "sha": "75e5731b8f10129ef9a0e4202152c391d70375eb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzVlNTczMWI4ZjEwMTI5ZWY5YTBlNDIwMjE1MmMzOTFkNzAzNzVlYg==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2019-11-12T08:07:34Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2019-11-12T08:07:34Z"
    },
    "message": "x86: introduce operand type \"instance\"\n\nSpecial register \"class\" instances can't be combined with one another\n(neither in templates nor in register entries), and hence it is not a\ngood use of resources (memory as well as execution time) to represent\nthem as individual bits of a bit field.\n\nFurthermore the generalization becoming possible will allow\nimprovements to the handling of insns accepting only individual\nregisters as their operands.",
    "tree": {
      "sha": "79bbb36fee586624bba5b92acdf7c3bc6dc86622",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/79bbb36fee586624bba5b92acdf7c3bc6dc86622"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/75e5731b8f10129ef9a0e4202152c391d70375eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/75e5731b8f10129ef9a0e4202152c391d70375eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/75e5731b8f10129ef9a0e4202152c391d70375eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/75e5731b8f10129ef9a0e4202152c391d70375eb/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "aa16be3993e2b29d4f6a774fca82c67a43956864",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aa16be3993e2b29d4f6a774fca82c67a43956864",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/aa16be3993e2b29d4f6a774fca82c67a43956864"
    }
  ],
  "stats": {
    "total": 28535,
    "additions": 14307,
    "deletions": 14228
  },
  "files": [
    {
      "sha": "efc5395458ee30ae75c7376e666b261531a920eb",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -1,3 +1,14 @@\n+2019-11-12  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (operand_type_set, operand_type_and,\n+\toperand_type_and_not, operand_type_or, operand_type_xor): Handle\n+\t\"instance\" field specially.\n+\t(operand_size_match, md_assemble, match_template, process_suffix,\n+\tcheck_byte_reg, check_long_reg, check_qword_reg, check_word_reg,\n+\tprocess_operands, build_modrm_byte): Use \"instance\" instead of\n+\t\"acc\" / \"inoutportreg\" / \"shiftcount\" fields.\n+\t(optimize_imm): Adjust comment.\n+\n 2019-11-11  Jan Beulich  <jbeulich@suse.com>\n \n \t* testsuite/gas/aarch64/illegal-sve2.s: Add smaxp/sminp cases"
    },
    {
      "sha": "75ea225efddfddf0c071da027689bcb9e3908d45",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 44,
      "deletions": 29,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -1613,6 +1613,7 @@ operand_type_set (union i386_operand_type *x, unsigned int v)\n     }\n \n   x->bitfield.class = ClassNone;\n+  x->bitfield.instance = InstanceNone;\n }\n \n static INLINE int\n@@ -1829,6 +1830,8 @@ operand_type_and (i386_operand_type x, i386_operand_type y)\n {\n   if (x.bitfield.class != y.bitfield.class)\n     x.bitfield.class = ClassNone;\n+  if (x.bitfield.instance != y.bitfield.instance)\n+    x.bitfield.instance = InstanceNone;\n \n   switch (ARRAY_SIZE (x.array))\n     {\n@@ -1851,6 +1854,7 @@ static INLINE i386_operand_type\n operand_type_and_not (i386_operand_type x, i386_operand_type y)\n {\n   gas_assert (y.bitfield.class == ClassNone);\n+  gas_assert (y.bitfield.instance == InstanceNone);\n \n   switch (ARRAY_SIZE (x.array))\n     {\n@@ -1875,6 +1879,9 @@ operand_type_or (i386_operand_type x, i386_operand_type y)\n   gas_assert (x.bitfield.class == ClassNone ||\n               y.bitfield.class == ClassNone ||\n               x.bitfield.class == y.bitfield.class);\n+  gas_assert (x.bitfield.instance == InstanceNone ||\n+              y.bitfield.instance == InstanceNone ||\n+              x.bitfield.instance == y.bitfield.instance);\n \n   switch (ARRAY_SIZE (x.array))\n     {\n@@ -1897,6 +1904,7 @@ static INLINE i386_operand_type\n operand_type_xor (i386_operand_type x, i386_operand_type y)\n {\n   gas_assert (y.bitfield.class == ClassNone);\n+  gas_assert (y.bitfield.instance == InstanceNone);\n \n   switch (ARRAY_SIZE (x.array))\n     {\n@@ -2084,7 +2092,7 @@ operand_size_match (const insn_template *t)\n \t  break;\n \t}\n \n-      if (t->operand_types[j].bitfield.acc\n+      if (t->operand_types[j].bitfield.instance == Accum\n \t  && (!match_operand_size (t, j, j) || !match_simd_size (t, j, j)))\n \t{\n \t  match = 0;\n@@ -2121,7 +2129,7 @@ operand_size_match (const insn_template *t)\n \t  && !match_simd_size (t, j, given))\n \tgoto mismatch;\n \n-      if (t->operand_types[j].bitfield.acc\n+      if (t->operand_types[j].bitfield.instance == Accum\n \t  && (!match_operand_size (t, j, given)\n \t      || !match_simd_size (t, j, given)))\n \tgoto mismatch;\n@@ -4453,9 +4461,8 @@ md_assemble (char *line)\n      with 3 operands or less.  */\n   if (i.operands <= 3)\n     for (j = 0; j < i.operands; j++)\n-      if (i.types[j].bitfield.inoutportreg\n-\t  || i.types[j].bitfield.shiftcount\n-\t  || (i.types[j].bitfield.acc && !i.types[j].bitfield.xmmword))\n+      if (i.types[j].bitfield.instance != InstanceNone\n+\t  && !i.types[j].bitfield.xmmword)\n \ti.reg_operands--;\n \n   /* ImmExt should be processed after SSE2AVX.  */\n@@ -5076,9 +5083,9 @@ optimize_imm (void)\n   else if (i.reg_operands)\n     {\n       /* Figure out a suffix from the last register operand specified.\n-\t We can't do this properly yet, ie. excluding InOutPortReg,\n-\t but the following works for instructions with immediates.\n-\t In any case, we can't set i.suffix yet.  */\n+\t We can't do this properly yet, i.e. excluding special register\n+\t instances, but the following works for instructions with\n+\t immediates.  In any case, we can't set i.suffix yet.  */\n       for (op = i.operands; --op >= 0;)\n \tif (i.types[op].bitfield.class != Reg)\n \t  continue;\n@@ -5897,15 +5904,17 @@ match_template (char mnem_suffix)\n \t     zero-extend %eax to %rax.  */\n \t  if (flag_code == CODE_64BIT\n \t      && t->base_opcode == 0x90\n-\t      && i.types[0].bitfield.acc && i.types[0].bitfield.dword\n-\t      && i.types[1].bitfield.acc && i.types[1].bitfield.dword)\n+\t      && i.types[0].bitfield.instance == Accum\n+\t      && i.types[0].bitfield.dword\n+\t      && i.types[1].bitfield.instance == Accum\n+\t      && i.types[1].bitfield.dword)\n \t    continue;\n \t  /* xrelease mov %eax, <disp> is another special case. It must not\n \t     match the accumulator-only encoding of mov.  */\n \t  if (flag_code != CODE_64BIT\n \t      && i.hle_prefix\n \t      && t->base_opcode == 0xa0\n-\t      && i.types[0].bitfield.acc\n+\t      && i.types[0].bitfield.instance == Accum\n \t      && (i.flags[1] & Operand_Mem))\n \t    continue;\n \t  /* Fall through.  */\n@@ -6284,8 +6293,8 @@ process_suffix (void)\n \t\t}\n \n \t      for (op = i.operands; --op >= 0;)\n-\t\tif (!i.tm.operand_types[op].bitfield.inoutportreg\n-\t\t    && !i.tm.operand_types[op].bitfield.shiftcount)\n+\t\tif (i.tm.operand_types[op].bitfield.instance == InstanceNone\n+\t\t    || i.tm.operand_types[op].bitfield.instance == Accum)\n \t\t  {\n \t\t    if (i.types[op].bitfield.class != Reg)\n \t\t      continue;\n@@ -6502,8 +6511,10 @@ process_suffix (void)\n \t  && ! (i.operands == 2\n \t\t&& i.tm.base_opcode == 0x90\n \t\t&& i.tm.extension_opcode == None\n-\t\t&& i.types[0].bitfield.acc && i.types[0].bitfield.qword\n-\t\t&& i.types[1].bitfield.acc && i.types[1].bitfield.qword))\n+\t\t&& i.types[0].bitfield.instance == Accum\n+\t\t&& i.types[0].bitfield.qword\n+\t\t&& i.types[1].bitfield.instance == Accum\n+\t\t&& i.types[1].bitfield.qword))\n \ti.rex |= REX_W;\n \n       break;\n@@ -6565,7 +6576,8 @@ check_byte_reg (void)\n \tcontinue;\n \n       /* I/O port address operands are OK too.  */\n-      if (i.tm.operand_types[op].bitfield.inoutportreg)\n+      if (i.tm.operand_types[op].bitfield.instance == RegD\n+\t  && i.tm.operand_types[op].bitfield.word)\n \tcontinue;\n \n       /* crc32 doesn't generate this warning.  */\n@@ -6626,7 +6638,7 @@ check_long_reg (void)\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n       {\n@@ -6641,7 +6653,7 @@ check_long_reg (void)\n     else if ((!quiet_warnings || flag_code == CODE_64BIT)\n \t     && i.types[op].bitfield.word\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && i.tm.operand_types[op].bitfield.dword)\n       {\n \t/* Prohibit these changes in the 64bit mode, since the\n@@ -6663,7 +6675,7 @@ check_long_reg (void)\n     /* Warn if the r prefix on a general reg is present.  */\n     else if (i.types[op].bitfield.qword\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && i.tm.operand_types[op].bitfield.dword)\n       {\n \tif (intel_syntax\n@@ -6697,7 +6709,7 @@ check_qword_reg (void)\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n       {\n@@ -6712,7 +6724,7 @@ check_qword_reg (void)\n     else if ((i.types[op].bitfield.word\n \t      || i.types[op].bitfield.dword)\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && i.tm.operand_types[op].bitfield.qword)\n       {\n \t/* Prohibit these changes in the 64bit mode, since the\n@@ -6747,7 +6759,7 @@ check_word_reg (void)\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n       {\n@@ -6763,7 +6775,7 @@ check_word_reg (void)\n \t     && (i.types[op].bitfield.dword\n \t\t || i.types[op].bitfield.qword)\n \t     && (i.tm.operand_types[op].bitfield.class == Reg\n-\t\t || i.tm.operand_types[op].bitfield.acc)\n+\t\t || i.tm.operand_types[op].bitfield.instance == Accum)\n \t     && i.tm.operand_types[op].bitfield.word)\n       {\n \t/* Prohibit these changes in the 64bit mode, since the\n@@ -6888,14 +6900,14 @@ process_operands (void)\n \t\t  && MAX_OPERANDS > dupl\n \t\t  && operand_type_equal (&i.types[dest], &regxmm));\n \n-      if (i.tm.operand_types[0].bitfield.acc\n+      if (i.tm.operand_types[0].bitfield.instance == Accum\n \t  && i.tm.operand_types[0].bitfield.xmmword)\n \t{\n \t  if (i.tm.opcode_modifier.vexsources == VEX3SOURCES)\n \t    {\n \t      /* Keep xmm0 for instructions with VEX prefix and 3\n \t\t sources.  */\n-\t      i.tm.operand_types[0].bitfield.acc = 0;\n+\t      i.tm.operand_types[0].bitfield.instance = InstanceNone;\n \t      i.tm.operand_types[0].bitfield.class = RegSIMD;\n \t      goto duplicate;\n \t    }\n@@ -6960,7 +6972,7 @@ process_operands (void)\n        if (i.tm.opcode_modifier.immext)\n \t process_immext ();\n     }\n-  else if (i.tm.operand_types[0].bitfield.acc\n+  else if (i.tm.operand_types[0].bitfield.instance == Accum\n \t   && i.tm.operand_types[0].bitfield.xmmword)\n     {\n       unsigned int j;\n@@ -7207,9 +7219,11 @@ build_modrm_byte (void)\n \t  gas_assert (i.imm_operands == 1\n \t\t      || (i.imm_operands == 0\n \t\t\t  && (i.tm.opcode_modifier.vexvvvv == VEXXDS\n-\t\t\t      || i.types[0].bitfield.shiftcount)));\n+\t\t\t      || (i.types[0].bitfield.instance == RegC\n+\t\t\t\t  && i.types[0].bitfield.byte))));\n \t  if (operand_type_check (i.types[0], imm)\n-\t      || i.types[0].bitfield.shiftcount)\n+\t      || (i.types[0].bitfield.instance == RegC\n+\t\t  && i.types[0].bitfield.byte))\n \t    source = 1;\n \t  else\n \t    source = 0;\n@@ -10320,7 +10334,8 @@ i386_att_operand (char *operand_string)\n \n       /* Special case for (%dx) while doing input/output op.  */\n       if (i.base_reg\n-\t  && i.base_reg->reg_type.bitfield.inoutportreg\n+\t  && i.base_reg->reg_type.bitfield.instance == RegD\n+\t  && i.base_reg->reg_type.bitfield.word\n \t  && i.index_reg == 0\n \t  && i.log2_scale_factor == 0\n \t  && i.seg[i.mem_operands] == 0"
    },
    {
      "sha": "ff69492567370dc4b5def52725298b992e7e87a9",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -1,3 +1,24 @@\n+2019-11-12  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-gen.c (operand_type_init): Adjust\n+\tOPERAND_TYPE_INOUTPORTREG, OPERAND_TYPE_SHIFTCOUNT,\n+\tOPERAND_TYPE_FLOATACC, OPERAND_TYPE_ACC8, OPERAND_TYPE_ACC16,\n+\tOPERAND_TYPE_ACC32, and OPERAND_TYPE_ACC64 entries.\n+\t(operand_instances): New.\n+\t(operand_types): Drop InOutPortReg, ShiftCount, and Acc entries.\n+\t(output_operand_type): New parameter \"instance\". Process it.\n+\t(process_i386_operand_type): New local variable \"instance\".\n+\t(main): Adjust static assertions.\n+\t* i386-opc.h (INSTANCE_WIDTH): Define.\n+\t(enum operand_instance): New.\n+\t(Acc, InOutPortReg, ShiftCount): Replace by ClassInstance.\n+\t(union i386_operand_type): Replace acc, inoutportreg, and\n+\tshiftcount by instance.\n+\t* i386-opc.tbl (Acc, InOutPortReg, ShiftCount): Define.\n+\t* i386-reg.tbl (st, al, cl, ax, dx, eax, rax, xmm0, st(0)):\n+\tAdd Instance=.\n+\t* i386-init.h, i386-tbl.h: Re-generate.\n+\n 2019-11-11  Jan Beulich  <jbeulich@suse.com>\n \n \t* aarch64-tbl.h (aarch64_opcode_table): Switch SVE2's"
    },
    {
      "sha": "28212cd28fdc3fd07aea1a7ecdc567d872f6edc4",
      "filename": "opcodes/i386-gen.c",
      "status": "modified",
      "additions": 42,
      "deletions": 17,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-gen.c?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -422,9 +422,9 @@ static initializer operand_type_init[] =\n   { \"OPERAND_TYPE_DISP64\",\n     \"Disp64\" },\n   { \"OPERAND_TYPE_INOUTPORTREG\",\n-    \"InOutPortReg\" },\n+    \"Instance=RegD|Word\" },\n   { \"OPERAND_TYPE_SHIFTCOUNT\",\n-    \"ShiftCount\" },\n+    \"Instance=RegC|Byte\" },\n   { \"OPERAND_TYPE_CONTROL\",\n     \"Class=RegCR\" },\n   { \"OPERAND_TYPE_TEST\",\n@@ -434,7 +434,7 @@ static initializer operand_type_init[] =\n   { \"OPERAND_TYPE_FLOATREG\",\n     \"Class=Reg|Tbyte\" },\n   { \"OPERAND_TYPE_FLOATACC\",\n-    \"Acc|Tbyte\" },\n+    \"Instance=Accum|Tbyte\" },\n   { \"OPERAND_TYPE_SREG\",\n     \"Class=SReg\" },\n   { \"OPERAND_TYPE_JUMPABSOLUTE\",\n@@ -454,13 +454,13 @@ static initializer operand_type_init[] =\n   { \"OPERAND_TYPE_ESSEG\",\n     \"EsSeg\" },\n   { \"OPERAND_TYPE_ACC8\",\n-    \"Acc|Byte\" },\n+    \"Instance=Accum|Byte\" },\n   { \"OPERAND_TYPE_ACC16\",\n-    \"Acc|Word\" },\n+    \"Instance=Accum|Word\" },\n   { \"OPERAND_TYPE_ACC32\",\n-    \"Acc|Dword\" },\n+    \"Instance=Accum|Dword\" },\n   { \"OPERAND_TYPE_ACC64\",\n-    \"Acc|Qword\" },\n+    \"Instance=Accum|Qword\" },\n   { \"OPERAND_TYPE_DISP16_32\",\n     \"Disp16|Disp32\" },\n   { \"OPERAND_TYPE_ANYDISP\",\n@@ -695,6 +695,19 @@ static const struct {\n \n #undef CLASS\n \n+#define INSTANCE(n) #n, n\n+\n+static const struct {\n+  const char *name;\n+  enum operand_instance value;\n+} operand_instances[] = {\n+    INSTANCE (Accum),\n+    INSTANCE (RegC),\n+    INSTANCE (RegD),\n+};\n+\n+#undef INSTANCE\n+\n static bitfield operand_types[] =\n {\n   BITFIELD (Imm1),\n@@ -710,9 +723,6 @@ static bitfield operand_types[] =\n   BITFIELD (Disp32),\n   BITFIELD (Disp32S),\n   BITFIELD (Disp64),\n-  BITFIELD (InOutPortReg),\n-  BITFIELD (ShiftCount),\n-  BITFIELD (Acc),\n   BITFIELD (JumpAbsolute),\n   BITFIELD (EsSeg),\n   BITFIELD (Byte),\n@@ -1147,20 +1157,21 @@ enum stage {\n \n static void\n output_operand_type (FILE *table, enum operand_class class,\n+\t\t     enum operand_instance instance,\n \t\t     const bitfield *types, unsigned int size,\n \t\t     enum stage stage, const char *indent)\n {\n   unsigned int i;\n \n-  fprintf (table, \"{ { %d, \", class);\n+  fprintf (table, \"{ { %d, %d, \", class, instance);\n \n   for (i = 0; i < size - 1; i++)\n     {\n-      if (((i + 2) % 20) != 0)\n+      if (((i + 3) % 20) != 0)\n \tfprintf (table, \"%d, \", types[i].value);\n       else\n \tfprintf (table, \"%d,\", types[i].value);\n-      if (((i + 2) % 20) == 0)\n+      if (((i + 3) % 20) == 0)\n \t{\n \t  /* We need \\\\ for macro.  */\n \t  if (stage == stage_macros)\n@@ -1179,6 +1190,7 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n {\n   char *str, *next, *last;\n   enum operand_class class = ClassNone;\n+  enum operand_instance instance = InstanceNone;\n   bitfield types [ARRAY_SIZE (operand_types)];\n \n   /* Copy the default operand type.  */\n@@ -1206,6 +1218,17 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n \t\t\tbreak;\n \t\t      }\n \t\t}\n+\n+\t      if (str && !strncmp(str, \"Instance=\", 9))\n+\t\t{\n+\t\t  for (i = 0; i < ARRAY_SIZE(operand_instances); ++i)\n+\t\t    if (!strcmp(str + 9, operand_instances[i].name))\n+\t\t      {\n+\t\t\tinstance = operand_instances[i].value;\n+\t\t\tstr = NULL;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n \t    }\n \t  if (str)\n \t    {\n@@ -1226,8 +1249,8 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n \t    set_bitfield(\"Disp32S\", types, 1, ARRAY_SIZE (types), lineno);\n \t}\n     }\n-  output_operand_type (table, class, types, ARRAY_SIZE (types), stage,\n-\t\t       indent);\n+  output_operand_type (table, class, instance, types, ARRAY_SIZE (types),\n+\t\t       stage, indent);\n }\n \n static void\n@@ -1717,9 +1740,11 @@ main (int argc, char **argv)\n \n   /* Check the unused bitfield in i386_operand_type.  */\n #ifdef OTUnused\n-  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH == OTNum + 1);\n+  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH + INSTANCE_WIDTH\n+\t\t == OTNum + 1);\n #else\n-  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH == OTNum);\n+  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH + INSTANCE_WIDTH\n+\t\t == OTNum);\n \n   c = OTNumOfBits - OTMax - 1;\n   if (c)"
    },
    {
      "sha": "40250f48fa031b4c3559b123c9fbf019b4aaa901",
      "filename": "opcodes/i386-init.h",
      "status": "modified",
      "additions": 84,
      "deletions": 84,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-init.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-init.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-init.h?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -1365,196 +1365,196 @@\n \n #define OPERAND_TYPE_NONE \\\n   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REG8 \\\n-  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REG16 \\\n-  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REG32 \\\n-  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REG64 \\\n   { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 1, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM1 \\\n-  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM8 \\\n-  { { 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM8S \\\n-  { { 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM16 \\\n-  { { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32 \\\n-  { { 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32S \\\n-  { { 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM64 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_BASEINDEX \\\n   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP8 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP16 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP32 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP32S \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP64 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_INOUTPORTREG \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_SHIFTCOUNT \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_CONTROL \\\n   { { 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_TEST \\\n   { { 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DEBUG \\\n   { { 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_FLOATREG \\\n   { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 1, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_FLOATACC \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 1, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_SREG \\\n   { { 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_JUMPABSOLUTE \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGMMX \\\n   { { 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGXMM \\\n   { { 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 1, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGYMM \\\n   { { 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 1, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGZMM \\\n   { { 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 1, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGMASK \\\n   { { 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_REGBND \\\n   { { 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ESSEG \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ACC8 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ACC16 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n-      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ACC32 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n-      0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ACC64 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 1, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_DISP16_32 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ANYDISP \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM16_32 \\\n-  { { 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM16_32S \\\n-  { { 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM16_32_32S \\\n-  { { 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32_64 \\\n-  { { 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32_32S_DISP32 \\\n-  { { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM64_DISP64 \\\n-  { { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32_32S_64_DISP32 \\\n-  { { 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_IMM32_32S_64_DISP32_64 \\\n-  { { 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n #define OPERAND_TYPE_ANYIMM \\\n-  { { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+  { { 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0 } }"
    },
    {
      "sha": "0bfb4d808cb235a93e367398d95b8f27da000f44",
      "filename": "opcodes/i386-opc.h",
      "status": "modified",
      "additions": 14,
      "deletions": 11,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-opc.h?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -719,12 +719,23 @@ enum operand_class\n   RegBND, /* Bound register */\n };\n \n+/* Special operand instances.  */\n+\n+#define INSTANCE_WIDTH 3\n+enum operand_instance\n+{\n+  InstanceNone,\n+  Accum, /* Accumulator %al/%ax/%eax/%rax/%st(0)/%xmm0 */\n+  RegC,  /* Register to hold shift count = %cl */\n+  RegD,  /* Register to hold in/out port addr = %dx */\n+};\n+\n /* Position of operand_type bits.  */\n \n enum\n {\n-  /* Class */\n-  Class = CLASS_WIDTH - 1,\n+  /* Class and Instance */\n+  ClassInstance = CLASS_WIDTH + INSTANCE_WIDTH - 1,\n   /* 1 bit immediate */\n   Imm1,\n   /* 8 bit immediate */\n@@ -756,14 +767,8 @@ enum\n   Disp32S,\n   /* 64 bit displacement */\n   Disp64,\n-  /* Accumulator %al/%ax/%eax/%rax/%st(0)/%xmm0 */\n-  Acc,\n   /* Register which can be used for base or index in memory operand.  */\n   BaseIndex,\n-  /* Register to hold in/out port addr = dx */\n-  InOutPortReg,\n-  /* Register to hold shift count = cl */\n-  ShiftCount,\n   /* Absolute address for jump.  */\n   JumpAbsolute,\n   /* String insn operand with fixed es segment */\n@@ -809,6 +814,7 @@ typedef union i386_operand_type\n   struct\n     {\n       unsigned int class:CLASS_WIDTH;\n+      unsigned int instance:INSTANCE_WIDTH;\n       unsigned int imm1:1;\n       unsigned int imm8:1;\n       unsigned int imm8s:1;\n@@ -821,10 +827,7 @@ typedef union i386_operand_type\n       unsigned int disp32:1;\n       unsigned int disp32s:1;\n       unsigned int disp64:1;\n-      unsigned int acc:1;\n       unsigned int baseindex:1;\n-      unsigned int inoutportreg:1;\n-      unsigned int shiftcount:1;\n       unsigned int jumpabsolute:1;\n       unsigned int esseg:1;\n       unsigned int byte:1;"
    },
    {
      "sha": "b40dcbe2df9389570350d172aaa0bd588382a470",
      "filename": "opcodes/i386-opc.tbl",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-opc.tbl",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-opc.tbl",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-opc.tbl?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -27,6 +27,10 @@\n #define Reg32 Class=Reg|Dword\n #define Reg64 Class=Reg|Qword\n \n+#define Acc          Instance=Accum\n+#define ShiftCount   Instance=RegC|Byte\n+#define InOutPortReg Instance=RegD|Word\n+\n #define FloatAcc Acc|Tbyte\n #define FloatReg Class=Reg|Tbyte\n "
    },
    {
      "sha": "5a569d2b358c8d401e101dc01f38c77a5bd39245",
      "filename": "opcodes/i386-reg.tbl",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-reg.tbl",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-reg.tbl",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-reg.tbl?ref=75e5731b8f10129ef9a0e4202152c391d70375eb",
      "patch": "@@ -19,10 +19,10 @@\n // 02110-1301, USA.\n \n // Make %st first as we test for it.\n-st, Class=Reg|Acc|Tbyte, 0, 0, 11, 33\n+st, Class=Reg|Instance=Accum|Tbyte, 0, 0, 11, 33\n // 8 bit regs\n-al, Class=Reg|Acc|Byte, 0, 0, Dw2Inval, Dw2Inval\n-cl, Class=Reg|Byte|ShiftCount, 0, 1, Dw2Inval, Dw2Inval\n+al, Class=Reg|Instance=Accum|Byte, 0, 0, Dw2Inval, Dw2Inval\n+cl, Class=Reg|Instance=RegC|Byte, 0, 1, Dw2Inval, Dw2Inval\n dl, Class=Reg|Byte, 0, 2, Dw2Inval, Dw2Inval\n bl, Class=Reg|Byte, 0, 3, Dw2Inval, Dw2Inval\n ah, Class=Reg|Byte, 0, 4, Dw2Inval, Dw2Inval\n@@ -46,9 +46,9 @@ r13b, Class=Reg|Byte, RegRex|RegRex64, 5, Dw2Inval, Dw2Inval\n r14b, Class=Reg|Byte, RegRex|RegRex64, 6, Dw2Inval, Dw2Inval\n r15b, Class=Reg|Byte, RegRex|RegRex64, 7, Dw2Inval, Dw2Inval\n // 16 bit regs\n-ax, Class=Reg|Acc|Word, 0, 0, Dw2Inval, Dw2Inval\n+ax, Class=Reg|Instance=Accum|Word, 0, 0, Dw2Inval, Dw2Inval\n cx, Class=Reg|Word, 0, 1, Dw2Inval, Dw2Inval\n-dx, Class=Reg|Word|InOutPortReg, 0, 2, Dw2Inval, Dw2Inval\n+dx, Class=Reg|Instance=RegD|Word, 0, 2, Dw2Inval, Dw2Inval\n bx, Class=Reg|Word|BaseIndex, 0, 3, Dw2Inval, Dw2Inval\n sp, Class=Reg|Word, 0, 4, Dw2Inval, Dw2Inval\n bp, Class=Reg|Word|BaseIndex, 0, 5, Dw2Inval, Dw2Inval\n@@ -63,7 +63,7 @@ r13w, Class=Reg|Word, RegRex, 5, Dw2Inval, Dw2Inval\n r14w, Class=Reg|Word, RegRex, 6, Dw2Inval, Dw2Inval\n r15w, Class=Reg|Word, RegRex, 7, Dw2Inval, Dw2Inval\n // 32 bit regs\n-eax, Class=Reg|Acc|Dword|BaseIndex, 0, 0, 0, Dw2Inval\n+eax, Class=Reg|Instance=Accum|Dword|BaseIndex, 0, 0, 0, Dw2Inval\n ecx, Class=Reg|Dword|BaseIndex, 0, 1, 1, Dw2Inval\n edx, Class=Reg|Dword|BaseIndex, 0, 2, 2, Dw2Inval\n ebx, Class=Reg|Dword|BaseIndex, 0, 3, 3, Dw2Inval\n@@ -79,7 +79,7 @@ r12d, Class=Reg|Dword|BaseIndex, RegRex, 4, Dw2Inval, Dw2Inval\n r13d, Class=Reg|Dword|BaseIndex, RegRex, 5, Dw2Inval, Dw2Inval\n r14d, Class=Reg|Dword|BaseIndex, RegRex, 6, Dw2Inval, Dw2Inval\n r15d, Class=Reg|Dword|BaseIndex, RegRex, 7, Dw2Inval, Dw2Inval\n-rax, Class=Reg|Acc|Qword|BaseIndex, 0, 0, Dw2Inval, 0\n+rax, Class=Reg|Instance=Accum|Qword|BaseIndex, 0, 0, Dw2Inval, 0\n rcx, Class=Reg|Qword|BaseIndex, 0, 1, Dw2Inval, 2\n rdx, Class=Reg|Qword|BaseIndex, 0, 2, Dw2Inval, 1\n rbx, Class=Reg|Qword|BaseIndex, 0, 3, Dw2Inval, 3\n@@ -180,7 +180,7 @@ mm4, Class=RegMMX, 0, 4, 33, 45\n mm5, Class=RegMMX, 0, 5, 34, 46\n mm6, Class=RegMMX, 0, 6, 35, 47\n mm7, Class=RegMMX, 0, 7, 36, 48\n-xmm0, Class=RegSIMD|Acc|Xmmword, 0, 0, 21, 17\n+xmm0, Class=RegSIMD|Instance=Accum|Xmmword, 0, 0, 21, 17\n xmm1, Class=RegSIMD|Xmmword, 0, 1, 22, 18\n xmm2, Class=RegSIMD|Xmmword, 0, 2, 23, 19\n xmm3, Class=RegSIMD|Xmmword, 0, 3, 24, 20\n@@ -292,7 +292,7 @@ eip, Dword, RegRex64, RegIP, 8, Dw2Inval\n riz, Qword|BaseIndex, RegRex64, RegIZ, Dw2Inval, Dw2Inval\n eiz, Dword|BaseIndex, 0, RegIZ, Dw2Inval, Dw2Inval\n // fp regs.\n-st(0), Class=Reg|Acc|Tbyte, 0, 0, 11, 33\n+st(0), Class=Reg|Instance=Accum|Tbyte, 0, 0, 11, 33\n st(1), Class=Reg|Tbyte, 0, 1, 12, 34\n st(2), Class=Reg|Tbyte, 0, 2, 13, 35\n st(3), Class=Reg|Tbyte, 0, 3, 14, 36"
    },
    {
      "sha": "d9843148ae9fceb5cbabad34d22b27b6b0733e45",
      "filename": "opcodes/i386-tbl.h",
      "status": "modified",
      "additions": 14078,
      "deletions": 14078,
      "changes": 28156,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-tbl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/75e5731b8f10129ef9a0e4202152c391d70375eb/opcodes/i386-tbl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-tbl.h?ref=75e5731b8f10129ef9a0e4202152c391d70375eb"
    }
  ]
}