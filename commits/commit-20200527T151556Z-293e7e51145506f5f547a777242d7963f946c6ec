{
  "sha": "293e7e51145506f5f547a777242d7963f946c6ec",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjkzZTdlNTExNDU1MDZmNWY1NDdhNzc3MjQyZDc5NjNmOTQ2YzZlYw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:14:00Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:15:56Z"
    },
    "message": "Move int type methods out of dwarf2_per_cu_data\n\nThese methods rely on the current objfile to create types based on it.\nSince dwarf2_per_cu_data is to become objfile-independent, these methods\nneed to mvoe.\n\nint_type can be in dwarf2_per_objfile, as it only requires knowing about\nthe objfile.\n\naddr_sized_int_type and addr_type also need to know about the DWARF\naddress type size, which is CU-specific.  The dwarf2_cu objects seems\nlike a good place for it, as it knows both about the current objfile and\nthe current CU.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.h (struct dwarf2_per_cu_data) <addr_type,\n\taddr_sized_int_type>: Move to dwarf2_cu.\n\t<int_type>: Move to dwarf2_per_objfile.\n\t(struct dwarf2_per_objfile) <int_type>: Move here.\n\t* dwarf2/read.c (struct dwarf2_cu) <addr_type,\n\taddr_sized_int_type>: Move here.\n\t(read_func_scope): Update.\n\t(read_array_type): Update.\n\t(read_tag_string_type): Update.\n\t(attr_to_dynamic_prop): Update.\n\t(dwarf2_per_cu_data::int_type): Rename to...\n\t(dwarf2_per_objfile::int_type): ... this.\n\t(dwarf2_per_cu_data::addr_sized_int_type): Rename to...\n\t(dwarf2_cu::addr_sized_int_type): ... this.\n\t(read_subrange_type): Update.\n\t(dwarf2_per_cu_data::addr_type): Rename to...\n\t(dwarf2_cu::addr_type): ... this.\n\t(set_die_type): Update.\n\nChange-Id: Ic4708ef99d43a8d99325ff91dee59b2eb706cb8f",
    "tree": {
      "sha": "18688adf0a40c0a47e7a1c9c1c9918a9362c8539",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/18688adf0a40c0a47e7a1c9c1c9918a9362c8539"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/293e7e51145506f5f547a777242d7963f946c6ec",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/293e7e51145506f5f547a777242d7963f946c6ec",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/293e7e51145506f5f547a777242d7963f946c6ec",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/293e7e51145506f5f547a777242d7963f946c6ec/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "64874a40306f556c290c8829f42526443db0f9e9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64874a40306f556c290c8829f42526443db0f9e9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/64874a40306f556c290c8829f42526443db0f9e9"
    }
  ],
  "stats": {
    "total": 88,
    "additions": 53,
    "deletions": 35
  },
  "files": [
    {
      "sha": "e754c13d45f406b7c1bb0cc2c974f811efe76914",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/293e7e51145506f5f547a777242d7963f946c6ec/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/293e7e51145506f5f547a777242d7963f946c6ec/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=293e7e51145506f5f547a777242d7963f946c6ec",
      "patch": "@@ -1,3 +1,24 @@\n+2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/read.h (struct dwarf2_per_cu_data) <addr_type,\n+\taddr_sized_int_type>: Move to dwarf2_cu.\n+\t<int_type>: Move to dwarf2_per_objfile.\n+\t(struct dwarf2_per_objfile) <int_type>: Move here.\n+\t* dwarf2/read.c (struct dwarf2_cu) <addr_type,\n+\taddr_sized_int_type>: Move here.\n+\t(read_func_scope): Update.\n+\t(read_array_type): Update.\n+\t(read_tag_string_type): Update.\n+\t(attr_to_dynamic_prop): Update.\n+\t(dwarf2_per_cu_data::int_type): Rename to...\n+\t(dwarf2_per_objfile::int_type): ... this.\n+\t(dwarf2_per_cu_data::addr_sized_int_type): Rename to...\n+\t(dwarf2_cu::addr_sized_int_type): ... this.\n+\t(read_subrange_type): Update.\n+\t(dwarf2_per_cu_data::addr_type): Rename to...\n+\t(dwarf2_cu::addr_type): ... this.\n+\t(set_die_type): Update.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/read.c (queue_and_load_all_dwo_tus): Access per_objfile"
    },
    {
      "sha": "5ab0e8eefa28d0569c0376e4212b12060beceb6e",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 28,
      "deletions": 21,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/293e7e51145506f5f547a777242d7963f946c6ec/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/293e7e51145506f5f547a777242d7963f946c6ec/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=293e7e51145506f5f547a777242d7963f946c6ec",
      "patch": "@@ -421,6 +421,16 @@ struct dwarf2_cu\n   /* Reset the builder.  */\n   void reset_builder () { m_builder.reset (); }\n \n+  /* Return a type that is a generic pointer type, the size of which\n+     matches the address size given in the compilation unit header for\n+     this CU.  */\n+  struct type *addr_type () const;\n+\n+  /* Find an integer type the same size as the address size given in\n+     the compilation unit header for this CU.  UNSIGNED_P controls if\n+     the integer is unsigned or not.  */\n+  struct type *addr_sized_int_type (bool unsigned_p) const;\n+\n   /* The header of the compilation unit.  */\n   struct comp_unit_head header {};\n \n@@ -13107,7 +13117,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n       newobj->static_link\n \t= XOBNEW (&objfile->objfile_obstack, struct dynamic_prop);\n       attr_to_dynamic_prop (attr, die, cu, newobj->static_link,\n-\t\t\t    cu->per_cu->addr_type ());\n+\t\t\t    cu->addr_type ());\n     }\n \n   cu->list_in_scope = cu->get_builder ()->get_local_symbols ();\n@@ -15499,8 +15509,7 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n       else\n \t{\n \t  struct dynamic_prop prop;\n-\t  if (attr_to_dynamic_prop (attr, die, cu, &prop,\n-\t\t\t\t    cu->per_cu->addr_type ()))\n+\t  if (attr_to_dynamic_prop (attr, die, cu, &prop, cu->addr_type ()))\n \t    type->add_dyn_prop (DYN_PROP_BYTE_SIZE, prop);\n           TYPE_LENGTH (type) = 0;\n \t}\n@@ -16186,7 +16195,7 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (attr != NULL)\n     {\n       int stride_ok;\n-      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n+      struct type *prop_type = cu->addr_sized_int_type (false);\n \n       byte_stride_prop\n \t= (struct dynamic_prop *) alloca (sizeof (struct dynamic_prop));\n@@ -16986,13 +16995,13 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n \t  /* Pass 0 as the default as we know this attribute is constant\n \t     and the default value will not be returned.  */\n \t  LONGEST sz = len->constant_value (0);\n-\t  prop_type = cu->per_cu->int_type (sz, true);\n+\t  prop_type = cu->per_objfile->int_type (sz, true);\n \t}\n       else\n \t{\n \t  /* If the size is not specified then we assume it is the size of\n \t     an address on this target.  */\n-\t  prop_type = cu->per_cu->addr_sized_int_type (true);\n+\t  prop_type = cu->addr_sized_int_type (true);\n \t}\n \n       /* Convert the attribute into a dynamic property.  */\n@@ -17622,9 +17631,8 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n /* See read.h.  */\n \n struct type *\n-dwarf2_per_cu_data::int_type (int size_in_bytes, bool unsigned_p) const\n+dwarf2_per_objfile::int_type (int size_in_bytes, bool unsigned_p) const\n {\n-  struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct type *int_type;\n \n   /* Helper macro to examine the various builtin types.  */\n@@ -17649,10 +17657,10 @@ dwarf2_per_cu_data::int_type (int size_in_bytes, bool unsigned_p) const\n /* See read.h.  */\n \n struct type *\n-dwarf2_per_cu_data::addr_sized_int_type (bool unsigned_p) const\n+dwarf2_cu::addr_sized_int_type (bool unsigned_p) const\n {\n-  int addr_size = this->addr_size ();\n-  return int_type (addr_size, unsigned_p);\n+  int addr_size = this->per_cu->addr_size ();\n+  return this->per_objfile->int_type (addr_size, unsigned_p);\n }\n \n /* Read the DW_AT_type attribute for a sub-range.  If this attribute is not\n@@ -17677,7 +17685,7 @@ read_subrange_index_type (struct die_info *die, struct dwarf2_cu *cu)\n      FIXME: muller/2010-05-28: Possible references to object for low bound,\n      high bound or count are not yet handled by this code.  */\n   if (index_type->code () == TYPE_CODE_VOID)\n-    index_type = cu->per_cu->addr_sized_int_type (false);\n+    index_type = cu->addr_sized_int_type (false);\n \n   return index_type;\n }\n@@ -17807,7 +17815,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n   attribute *attr_byte_stride = dwarf2_attr (die, DW_AT_byte_stride, cu);\n   if (attr_byte_stride != nullptr)\n     {\n-      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n+      struct type *prop_type = cu->addr_sized_int_type (false);\n       attr_to_dynamic_prop (attr_byte_stride, die, cu, &byte_stride_prop,\n \t\t\t    prop_type);\n     }\n@@ -17827,7 +17835,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n       else\n \t{\n-\t  struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n+\t  struct type *prop_type = cu->addr_sized_int_type (false);\n \t  attr_to_dynamic_prop (attr_bit_stride, die, cu, &bit_stride_prop,\n \t\t\t\tprop_type);\n \t}\n@@ -23395,12 +23403,12 @@ dwarf2_per_cu_data::text_offset () const\n /* See read.h.  */\n \n struct type *\n-dwarf2_per_cu_data::addr_type () const\n+dwarf2_cu::addr_type () const\n {\n-  struct objfile *objfile = dwarf2_per_objfile->objfile;\n+  struct objfile *objfile = this->per_objfile->objfile;\n   struct type *void_type = objfile_type (objfile)->builtin_void;\n   struct type *addr_type = lookup_pointer_type (void_type);\n-  int addr_size = this->addr_size ();\n+  int addr_size = this->per_cu->addr_size ();\n \n   if (TYPE_LENGTH (addr_type) == addr_size)\n     return addr_type;\n@@ -23738,7 +23746,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_allocated, cu);\n   if (attr != NULL && attr->form_is_block ())\n     {\n-      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n+      struct type *prop_type = cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         type->add_dyn_prop (DYN_PROP_ALLOCATED, prop);\n     }\n@@ -23753,7 +23761,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_associated, cu);\n   if (attr != NULL && attr->form_is_block ())\n     {\n-      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n+      struct type *prop_type = cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         type->add_dyn_prop (DYN_PROP_ASSOCIATED, prop);\n     }\n@@ -23766,8 +23774,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n \n   /* Read DW_AT_data_location and set in type.  */\n   attr = dwarf2_attr (die, DW_AT_data_location, cu);\n-  if (attr_to_dynamic_prop (attr, die, cu, &prop,\n-\t\t\t    cu->per_cu->addr_type ()))\n+  if (attr_to_dynamic_prop (attr, die, cu, &prop, cu->addr_type ()))\n     type->add_dyn_prop (DYN_PROP_DATA_LOCATION, prop);\n \n   if (dwarf2_per_objfile->die_type_hash == NULL)"
    },
    {
      "sha": "77c1f246db741ce17033cb8b8ad9189fdd49d0a0",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 4,
      "deletions": 14,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/293e7e51145506f5f547a777242d7963f946c6ec/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/293e7e51145506f5f547a777242d7963f946c6ec/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=293e7e51145506f5f547a777242d7963f946c6ec",
      "patch": "@@ -301,6 +301,10 @@ struct dwarf2_per_objfile\n   /* Set the compunit_symtab associated to PER_CU.  */\n   void set_symtab (const dwarf2_per_cu_data *per_cu, compunit_symtab *symtab);\n \n+  /* Find an integer type SIZE_IN_BYTES bytes in size and return it.\n+     UNSIGNED_P controls if the integer is unsigned or not.  */\n+  struct type *int_type (int size_in_bytes, bool unsigned_p) const;\n+\n   /* Back link.  */\n   struct objfile *objfile;\n \n@@ -510,20 +514,6 @@ struct dwarf2_per_cu_data\n      corresponding offset in the parent objfile.  */\n   CORE_ADDR text_offset () const;\n \n-  /* Return a type that is a generic pointer type, the size of which\n-     matches the address size given in the compilation unit header for\n-     this CU.  */\n-  struct type *addr_type () const;\n-\n-  /* Find an integer type SIZE_IN_BYTES bytes in size and return it.\n-     UNSIGNED_P controls if the integer is unsigned or not.  */\n-  struct type *int_type (int size_in_bytes, bool unsigned_p) const;\n-\n-  /* Find an integer type the same size as the address size given in\n-     the compilation unit header for this CU.  UNSIGNED_P controls if\n-     the integer is unsigned or not.  */\n-  struct type *addr_sized_int_type (bool unsigned_p) const;\n-\n   /* Return DWARF version number of this CU.  */\n   short version () const\n   {"
    }
  ]
}