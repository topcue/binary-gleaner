{
  "sha": "ddd44b7053386b82769c27c871a08c72e589e93e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGRkNDRiNzA1MzM4NmI4Mjc2OWMyN2M4NzFhMDhjNzJlNTg5ZTkzZQ==",
  "commit": {
    "author": {
      "name": "Dimitar Dimitrov",
      "email": "dimitar@dinux.eu",
      "date": "2019-09-23T16:54:42Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-09-23T21:11:02Z"
    },
    "message": "sim: Add PRU simulator port\n\nA simulator port for the TI PRU I/O processor.\n\nv1: https://sourceware.org/ml/gdb-patches/2016-12/msg00143.html\nv2: https://sourceware.org/ml/gdb-patches/2017-02/msg00397.html\nv3: https://sourceware.org/ml/gdb-patches/2017-02/msg00516.html\nv4: https://sourceware.org/ml/gdb-patches/2018-06/msg00484.html\nv5: https://sourceware.org/ml/gdb-patches/2019-08/msg00584.html\nv6: https://sourceware.org/ml/gdb-patches/2019-09/msg00036.html\n\ngdb/ChangeLog:\n\n\t* NEWS: Mention new simulator port for PRU.\n\nsim/ChangeLog:\n\n\t* MAINTAINERS: Add myself as PRU maintainer.\n\t* configure: Regenerated.\n\t* configure.tgt: Add PRU.\n\nsim/common/ChangeLog:\n\n\t* gennltvals.sh: Add PRU libgloss target.\n\t* nltvals.def: Regenerate from the latest libgloss sources.\n\nsim/pru/ChangeLog:\n\n\t* Makefile.in: New file.\n\t* aclocal.m4: Regenerated.\n\t* config.in: Regenerated.\n\t* configure: Regenerated.\n\t* configure.ac: New file.\n\t* interp.c: New file.\n\t* pru.h: New file.\n\t* pru.isa: New file.\n\t* sim-main.h: New file.",
    "tree": {
      "sha": "fdedd45defc0b083ca3445de34abfdba5d128981",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fdedd45defc0b083ca3445de34abfdba5d128981"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ddd44b7053386b82769c27c871a08c72e589e93e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ddd44b7053386b82769c27c871a08c72e589e93e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ddd44b7053386b82769c27c871a08c72e589e93e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ddd44b7053386b82769c27c871a08c72e589e93e/comments",
  "author": null,
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f945dedfd3512bfbca0f1405c8ea85684980e69a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f945dedfd3512bfbca0f1405c8ea85684980e69a"
    }
  ],
  "stats": {
    "total": 17775,
    "additions": 17775,
    "deletions": 0
  },
  "files": [
    {
      "sha": "77aab7649247b646e8a714b10e096e99865776be",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -1,3 +1,7 @@\n+2019-09-23  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* NEWS: Mention new simulator port for PRU.\n+\n 2019-09-23  Christian Biesinger  <cbiesinger@google.com>\n \n \t* ada-exp.y (write_object_remaining): Update."
    },
    {
      "sha": "779fd91d3a62bfea16f51c2ac2bcf8a6583395cc",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -350,6 +350,10 @@ focus, winheight, +, -, >, <\n   both debugging standalone Cell/B.E. SPU applications and integrated debugging\n   of Cell/B.E. applications that use both the PPU and SPU architectures.\n \n+* New Simulators\n+\n+TI PRU\t\t\t\t\tpru-*-elf\n+\n *** Changes in GDB 8.3\n \n * GDB and GDBserver now support access to additional registers on"
    },
    {
      "sha": "7443e8442d9b32a0178afe61e46198674df525c9",
      "filename": "sim/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ChangeLog?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -1,3 +1,9 @@\n+2019-09-23  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* MAINTAINERS: Add myself as PRU maintainer.\n+\t* configure: Regenerated.\n+\t* configure.tgt: Add PRU.\n+\n 2019-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* ppc/emul_generic.c (emul_add_tree_options): Delete old bfd code."
    },
    {
      "sha": "4ca67cfd1d74aae8dc02952c7263b2fa4e48020d",
      "filename": "sim/MAINTAINERS",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/MAINTAINERS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/MAINTAINERS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/MAINTAINERS?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -29,6 +29,7 @@ mips I-IV\tMaciej W. Rozycki <macro@linux-mips.org>\n moxie\t\tAnthony Green <green@moxielogic.com>\n msp430\t\tNick Clifton <nickc@redhat.com>\n or1k\t\tStafford Horne <shorne@gmail.com>\n+pru\t\tDimitar Dimitrov <dimitar@dinux.eu>\n sh\t\t(global maintainers)\n sh64\t\tDave Brolley <brolley@redhat.com>\n common\t\tFrank Ch. Eigler <fche@redhat.com>"
    },
    {
      "sha": "a7ec5c7121eb009576bf7b9ecb45850da1c30f8f",
      "filename": "sim/common/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/ChangeLog?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -1,3 +1,8 @@\n+2019-09-23  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* gennltvals.sh: Add PRU libgloss target.\n+\t* nltvals.def: Regenerate from the latest libgloss sources.\n+\n 2019-06-13  Stafford Horne  <shorne@gmail.com>\n \n \t* cgen-accfp.c (unorderedsf, unordereddf): New functions."
    },
    {
      "sha": "79180335b627b6e9e4b4d0270c5ef645313aeffd",
      "filename": "sim/common/gennltvals.sh",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/gennltvals.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/gennltvals.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/gennltvals.sh?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -95,3 +95,7 @@ $shell ${srccom}/gentvals.sh $target sys ${newlibroot}/$dir \\\n dir=libgloss target=lm32\n $shell ${srccom}/gentvals.sh $target sys ${newlibroot}/$dir \\\n \t\"syscall.h\" 'SYS_[_[:alnum:]]*' \"${cpp}\"\n+\n+dir=libgloss target=pru\n+$shell ${srccom}/gentvals.sh $target sys ${newlibroot}/$dir \\\n+\t\"syscall.h\" 'SYS_[_[:alnum:]]*' \"${cpp}\""
    },
    {
      "sha": "92ccc9aded8b9c69fbd3d2247c6377efeb39b42c",
      "filename": "sim/common/nltvals.def",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/nltvals.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/common/nltvals.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/nltvals.def?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -574,3 +574,34 @@\n /* end lm32 sys target macros */\n #endif\n #endif\n+#ifdef NL_TARGET_pru\n+#ifdef sys_defs\n+/* from syscall.h */\n+/* begin pru sys target macros */\n+ { \"SYS_argc\", 22 },\n+ { \"SYS_argn\", 24 },\n+ { \"SYS_argnlen\", 23 },\n+ { \"SYS_argv\", 13 },\n+ { \"SYS_argvlen\", 12 },\n+ { \"SYS_chdir\", 14 },\n+ { \"SYS_chmod\", 16 },\n+ { \"SYS_close\", 3 },\n+ { \"SYS_exit\", 1 },\n+ { \"SYS_fstat\", 10 },\n+ { \"SYS_getpid\", 8 },\n+ { \"SYS_gettimeofday\", 19 },\n+ { \"SYS_kill\", 9 },\n+ { \"SYS_link\", 21 },\n+ { \"SYS_lseek\", 6 },\n+ { \"SYS_open\", 2 },\n+ { \"SYS_read\", 4 },\n+ { \"SYS_reconfig\", 25 },\n+ { \"SYS_stat\", 15 },\n+ { \"SYS_time\", 18 },\n+ { \"SYS_times\", 20 },\n+ { \"SYS_unlink\", 7 },\n+ { \"SYS_utime\", 17 },\n+ { \"SYS_write\", 5 },\n+/* end pru sys target macros */\n+#endif\n+#endif"
    },
    {
      "sha": "72f95cd5c7ace59d51bdd708c60a38e63df181b6",
      "filename": "sim/configure",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/configure?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -686,6 +686,7 @@ mn10300\n moxie\n msp430\n or1k\n+pru\n rl78\n rx\n sh64\n@@ -3837,6 +3838,13 @@ subdirs=\"$subdirs aarch64\"\n   subdirs=\"$subdirs or1k\"\n \n \n+       ;;\n+   pru*-*-*)\n+\n+  sim_arch=pru\n+  subdirs=\"$subdirs pru\"\n+\n+\n        ;;\n    rl78-*-*)\n "
    },
    {
      "sha": "8a8e03d96f4e8a6604c9002556e79430148b2e2f",
      "filename": "sim/configure.tgt",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/configure.tgt?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -79,6 +79,9 @@ case \"${target}\" in\n    or1k-*-* | or1knd-*-*)\n        SIM_ARCH(or1k)\n        ;;\n+   pru*-*-*)\n+       SIM_ARCH(pru)\n+       ;;\n    rl78-*-*)\n        SIM_ARCH(rl78)\n        ;;"
    },
    {
      "sha": "bccc3efd5314d818d34744ee8988e5bc6063e9ed",
      "filename": "sim/pru/ChangeLog",
      "status": "added",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/ChangeLog?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,11 @@\n+2019-09-23  Dimitar Dimitrov  <dimitar@dinux.eu>\n+\n+\t* Makefile.in: New file.\n+\t* aclocal.m4: Regenerated.\n+\t* config.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* configure.ac: New file.\n+\t* interp.c: New file.\n+\t* pru.h: New file.\n+\t* pru.isa: New file.\n+\t* sim-main.h: New file."
    },
    {
      "sha": "5235a5ff07b6b3d5ff42552d6ade9602b3dd3cab",
      "filename": "sim/pru/Makefile.in",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/Makefile.in?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,29 @@\n+#    Makefile template for Configure for the PRU sim library.\n+#    Copyright (C) 1990-2019 Free Software Foundation, Inc.\n+#    Written by Dimitar Dimitrov <dimitar@dinux.eu>\n+#\n+#    Based on the MCore sim library\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+## COMMON_PRE_CONFIG_FRAG\n+\n+SIM_OBJS = \\\n+\t$(SIM_NEW_COMMON_OBJS) \\\n+\tinterp.o \\\n+\tsim-resume.o\n+\n+NL_TARGET = -DNL_TARGET_pru\n+\n+## COMMON_POST_CONFIG_FRAG"
    },
    {
      "sha": "e9f11c775c310ba5c0051681d74d579dd6f39321",
      "filename": "sim/pru/aclocal.m4",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/aclocal.m4?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,119 @@\n+# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ([2.52])dnl\n+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 2003-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# Check whether the underlying file-system supports filenames\n+# with a leading dot.  For instance MS-DOS doesn't.\n+AC_DEFUN([AM_SET_LEADING_DOT],\n+[rm -rf .tst 2>/dev/null\n+mkdir .tst 2>/dev/null\n+if test -d .tst; then\n+  am__leading_dot=.\n+else\n+  am__leading_dot=_\n+fi\n+rmdir .tst 2>/dev/null\n+AC_SUBST([am__leading_dot])])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless 'enable' is passed literally.\n+# For symmetry, 'disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n+      am_maintainer_other[ make rules and dependencies not useful\n+      (and sometimes confusing) to the casual installer])],\n+    [USE_MAINTAINER_MODE=$enableval],\n+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# --------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+"
    },
    {
      "sha": "7c667a1c0d4147429afd5d30d58f04f590cfee36",
      "filename": "sim/pru/config.in",
      "status": "added",
      "additions": 248,
      "deletions": 0,
      "changes": 248,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/config.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/config.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/config.in?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,248 @@\n+/* config.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n+/* Sim debug setting */\n+#undef DEBUG\n+\n+/* Define to 1 if translation of program messages to the user's native\n+   language is requested. */\n+#undef ENABLE_NLS\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the <errno.h> header file. */\n+#undef HAVE_ERRNO_H\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#undef HAVE_FCNTL_H\n+\n+/* Define to 1 if you have the <fpu_control.h> header file. */\n+#undef HAVE_FPU_CONTROL_H\n+\n+/* Define to 1 if you have the `ftruncate' function. */\n+#undef HAVE_FTRUNCATE\n+\n+/* Define to 1 if you have the `getrusage' function. */\n+#undef HAVE_GETRUSAGE\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the `nsl' library (-lnsl). */\n+#undef HAVE_LIBNSL\n+\n+/* Define to 1 if you have the `socket' library (-lsocket). */\n+#undef HAVE_LIBSOCKET\n+\n+/* Define to 1 if you have the `lstat' function. */\n+#undef HAVE_LSTAT\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the `mmap' function. */\n+#undef HAVE_MMAP\n+\n+/* Define to 1 if you have the `munmap' function. */\n+#undef HAVE_MUNMAP\n+\n+/* Define to 1 if you have the `posix_fallocate' function. */\n+#undef HAVE_POSIX_FALLOCATE\n+\n+/* Define to 1 if you have the `sigaction' function. */\n+#undef HAVE_SIGACTION\n+\n+/* Define to 1 if the system has the type `socklen_t'. */\n+#undef HAVE_SOCKLEN_T\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if `st_atime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_ATIME\n+\n+/* Define to 1 if `st_blksize' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_BLKSIZE\n+\n+/* Define to 1 if `st_blocks' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_BLOCKS\n+\n+/* Define to 1 if `st_ctime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_CTIME\n+\n+/* Define to 1 if `st_dev' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_DEV\n+\n+/* Define to 1 if `st_gid' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_GID\n+\n+/* Define to 1 if `st_ino' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_INO\n+\n+/* Define to 1 if `st_mode' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_MODE\n+\n+/* Define to 1 if `st_mtime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_MTIME\n+\n+/* Define to 1 if `st_nlink' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_NLINK\n+\n+/* Define to 1 if `st_rdev' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_RDEV\n+\n+/* Define to 1 if `st_size' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_SIZE\n+\n+/* Define to 1 if `st_uid' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_UID\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/resource.h> header file. */\n+#undef HAVE_SYS_RESOURCE_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/times.h> header file. */\n+#undef HAVE_SYS_TIMES_H\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#undef HAVE_SYS_TIME_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the `time' function. */\n+#undef HAVE_TIME\n+\n+/* Define to 1 if you have the <time.h> header file. */\n+#undef HAVE_TIME_H\n+\n+/* Define to 1 if you have the `truncate' function. */\n+#undef HAVE_TRUNCATE\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to 1 if you have the <windows.h> header file. */\n+#undef HAVE_WINDOWS_H\n+\n+/* Define to 1 if you have the `__setfpucw' function. */\n+#undef HAVE___SETFPUCW\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of this package. */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Additional package description */\n+#undef PKGVERSION\n+\n+/* Sim profile settings */\n+#undef PROFILE\n+\n+/* Bug reporting address */\n+#undef REPORT_BUGS_TO\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#undef RETSIGTYPE\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# undef _ALL_SOURCE\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# undef _GNU_SOURCE\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# undef _POSIX_PTHREAD_SEMANTICS\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# undef _TANDEM_SOURCE\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n+\n+\n+/* Sim assert settings */\n+#undef WITH_ASSERT\n+\n+/* Sim debug setting */\n+#undef WITH_DEBUG\n+\n+/* Sim default environment */\n+#undef WITH_ENVIRONMENT\n+\n+/* Sim profile settings */\n+#undef WITH_PROFILE\n+\n+/* How to route I/O */\n+#undef WITH_STDIO\n+\n+/* Sim trace settings */\n+#undef WITH_TRACE\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n+/* Define to 1 if on MINIX. */\n+#undef _MINIX\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+#undef _POSIX_1_SOURCE\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+#undef _POSIX_SOURCE"
    },
    {
      "sha": "aa99e9e984be2cf6192c7a8009a659eab7643f30",
      "filename": "sim/pru/configure",
      "status": "added",
      "additions": 15973,
      "deletions": 0,
      "changes": 15973,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/configure?ref=ddd44b7053386b82769c27c871a08c72e589e93e"
    },
    {
      "sha": "e7132b4493f1a298cd8bd9ff3689bda82a14a201",
      "filename": "sim/pru/configure.ac",
      "status": "added",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/configure.ac?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,31 @@\n+dnl Process this file with autoconf to produce a configure script.\n+\n+dnl Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+dnl Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+dnl\n+dnl This file is part of the GNU simulators.\n+dnl\n+dnl This program is free software; you can redistribute it and/or modify\n+dnl it under the terms of the GNU General Public License as published by\n+dnl the Free Software Foundation; either version 3 of the License, or\n+dnl (at your option) any later version.\n+dnl\n+dnl This program is distributed in the hope that it will be useful,\n+dnl but WITHOUT ANY WARRANTY; without even the implied warranty of\n+dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+dnl GNU General Public License for more details.\n+dnl\n+dnl You should have received a copy of the GNU General Public License\n+dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+dnl\n+AC_PREREQ(2.64)dnl\n+AC_INIT(Makefile.in)\n+sinclude(../common/acinclude.m4)\n+\n+SIM_AC_COMMON\n+\n+SIM_AC_OPTION_ENDIAN(LITTLE)\n+SIM_AC_OPTION_ALIGNMENT(STRICT_ALIGNMENT,STRICT_ALIGNMENT)\n+SIM_AC_OPTION_WARNINGS\n+\n+SIM_AC_OUTPUT"
    },
    {
      "sha": "0e783c121cbbdb6d0af021145035c2755fb4ea67",
      "filename": "sim/pru/interp.c",
      "status": "added",
      "additions": 848,
      "deletions": 0,
      "changes": 848,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/interp.c?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,848 @@\n+/* Simulator for the Texas Instruments PRU processor\n+   Copyright 2009-2019 Free Software Foundation, Inc.\n+   Inspired by the Microblaze simulator\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of the simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include \"bfd.h\"\n+#include \"gdb/callback.h\"\n+#include \"libiberty.h\"\n+#include \"gdb/remote-sim.h\"\n+#include \"sim-main.h\"\n+#include \"sim-assert.h\"\n+#include \"sim-options.h\"\n+#include \"sim-syscall.h\"\n+#include \"pru.h\"\n+\n+/* DMEM zero address is perfectly valid.  But if CRT leaves the first word\n+   alone, we can use it as a trap to catch NULL pointer access.  */\n+static bfd_boolean abort_on_dmem_zero_access;\n+\n+enum {\n+  OPTION_ERROR_NULL_DEREF = OPTION_START,\n+};\n+\n+/* Extract (from PRU endianess) and return an integer in HOST's endianness.  */\n+static uint32_t\n+pru_extract_unsigned_integer (uint8_t *addr, size_t len)\n+{\n+  uint32_t retval;\n+  uint8_t *p;\n+  uint8_t *startaddr = addr;\n+  uint8_t *endaddr = startaddr + len;\n+\n+  /* Start at the most significant end of the integer, and work towards\n+     the least significant.  */\n+  retval = 0;\n+\n+  for (p = endaddr; p > startaddr;)\n+    retval = (retval << 8) | * -- p;\n+  return retval;\n+}\n+\n+/* Store \"val\" (which is in HOST's endianess) into \"addr\"\n+   (using PRU's endianness).  */\n+static void\n+pru_store_unsigned_integer (uint8_t *addr, size_t len, uint32_t val)\n+{\n+  uint8_t *p;\n+  uint8_t *startaddr = (uint8_t *)addr;\n+  uint8_t *endaddr = startaddr + len;\n+\n+  for (p = startaddr; p < endaddr;)\n+    {\n+      *p++ = val & 0xff;\n+      val >>= 8;\n+    }\n+}\n+\n+/* Extract a field value from CPU register using the given REGSEL selector.\n+\n+   Byte number maps directly to first values of RSEL, so we can\n+   safely use \"regsel\" as a register byte number (0..3).  */\n+static inline uint32_t\n+extract_regval (uint32_t val, uint32_t regsel)\n+{\n+  ASSERT (RSEL_7_0 == 0);\n+  ASSERT (RSEL_15_8 == 1);\n+  ASSERT (RSEL_23_16 == 2);\n+  ASSERT (RSEL_31_24 == 3);\n+\n+  switch (regsel)\n+    {\n+    case RSEL_7_0:    return (val >> 0) & 0xff;\n+    case RSEL_15_8:   return (val >> 8) & 0xff;\n+    case RSEL_23_16:  return (val >> 16) & 0xff;\n+    case RSEL_31_24:  return (val >> 24) & 0xff;\n+    case RSEL_15_0:   return (val >> 0) & 0xffff;\n+    case RSEL_23_8:   return (val >> 8) & 0xffff;\n+    case RSEL_31_16:  return (val >> 16) & 0xffff;\n+    case RSEL_31_0:   return val;\n+    default:\t      sim_io_error (NULL, \"invalid regsel\");\n+    }\n+}\n+\n+/* Write a value into CPU subregister pointed by reg and regsel.  */\n+static inline void\n+write_regval (uint32_t val, uint32_t *reg, uint32_t regsel)\n+{\n+  uint32_t mask, sh;\n+\n+  switch (regsel)\n+    {\n+    case RSEL_7_0:    mask = (0xffu << 0); sh = 0; break;\n+    case RSEL_15_8:   mask = (0xffu << 8); sh = 8; break;\n+    case RSEL_23_16:  mask = (0xffu << 16); sh = 16; break;\n+    case RSEL_31_24:  mask = (0xffu << 24); sh = 24; break;\n+    case RSEL_15_0:   mask = (0xffffu << 0); sh = 0; break;\n+    case RSEL_23_8:   mask = (0xffffu << 8); sh = 8; break;\n+    case RSEL_31_16:  mask = (0xffffu << 16); sh = 16; break;\n+    case RSEL_31_0:   mask = 0xffffffffu; sh = 0; break;\n+    default:\t      sim_io_error (NULL, \"invalid regsel\");\n+    }\n+\n+  *reg = (*reg & ~mask) | ((val << sh) & mask);\n+}\n+\n+/* Convert the given IMEM word address to a regular byte address used by the\n+   GNU ELF container.  */\n+static uint32_t\n+imem_wordaddr_to_byteaddr (SIM_CPU *cpu, uint16_t wa)\n+{\n+  return (((uint32_t) wa << 2) & IMEM_ADDR_MASK) | PC_ADDR_SPACE_MARKER;\n+}\n+\n+/* Convert the given ELF text byte address to IMEM word address.  */\n+static uint16_t\n+imem_byteaddr_to_wordaddr (SIM_CPU *cpu, uint32_t ba)\n+{\n+  return (ba >> 2) & 0xffff;\n+}\n+\n+\n+/* Store \"nbytes\" into DMEM \"addr\" from CPU register file, starting with\n+   register \"regn\", and byte \"regb\" within it.  */\n+static inline void\n+pru_reg2dmem (SIM_CPU *cpu, uint32_t addr, unsigned int nbytes,\n+\t      int regn, int regb)\n+{\n+  /* GDB assumes unconditional access to all memories, so enable additional\n+     checks only in standalone mode.  */\n+  bool standalone = (STATE_OPEN_KIND (CPU_STATE (cpu)) == SIM_OPEN_STANDALONE);\n+\n+  if (abort_on_dmem_zero_access && addr < 4)\n+    {\n+      sim_core_signal (CPU_STATE (cpu), cpu, PC_byteaddr, write_map,\n+\t\t       nbytes, addr, write_transfer,\n+\t\t       sim_core_unmapped_signal);\n+    }\n+  else if (standalone && ((addr >= PC_ADDR_SPACE_MARKER)\n+\t\t\t  || (addr + nbytes > PC_ADDR_SPACE_MARKER)))\n+    {\n+      sim_core_signal (CPU_STATE (cpu), cpu, PC_byteaddr, write_map,\n+\t\t       nbytes, addr, write_transfer,\n+\t\t       sim_core_unmapped_signal);\n+    }\n+  else if ((regn * 4 + regb + nbytes) > (32 * 4))\n+    {\n+      sim_io_eprintf (CPU_STATE (cpu),\n+\t\t      \"SBBO/SBCO with invalid store data length\\n\");\n+      RAISE_SIGILL (CPU_STATE (cpu));\n+    }\n+  else\n+    {\n+      TRACE_MEMORY (cpu, \"write of %d bytes to %08x\", nbytes, addr);\n+      while (nbytes--)\n+\t{\n+\t  sim_core_write_1 (cpu,\n+\t\t\t    PC_byteaddr,\n+\t\t\t    write_map,\n+\t\t\t    addr++,\n+\t\t\t    extract_regval (CPU.regs[regn], regb));\n+\n+\t  if (++regb >= 4)\n+\t    {\n+\t      regb = 0;\n+\t      regn++;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Load \"nbytes\" from DMEM \"addr\" into CPU register file, starting with\n+   register \"regn\", and byte \"regb\" within it.  */\n+static inline void\n+pru_dmem2reg (SIM_CPU *cpu, uint32_t addr, unsigned int nbytes,\n+\t      int regn, int regb)\n+{\n+  /* GDB assumes unconditional access to all memories, so enable additional\n+     checks only in standalone mode.  */\n+  bool standalone = (STATE_OPEN_KIND (CPU_STATE (cpu)) == SIM_OPEN_STANDALONE);\n+\n+  if (abort_on_dmem_zero_access && addr < 4)\n+    {\n+      sim_core_signal (CPU_STATE (cpu), cpu, PC_byteaddr, read_map,\n+\t\t       nbytes, addr, read_transfer,\n+\t\t       sim_core_unmapped_signal);\n+    }\n+  else if (standalone && ((addr >= PC_ADDR_SPACE_MARKER)\n+\t\t\t  || (addr + nbytes > PC_ADDR_SPACE_MARKER)))\n+    {\n+      /* This check is necessary because our IMEM \"address space\"\n+\t is not really accessible, yet we have mapped it as a generic\n+\t memory space.  */\n+      sim_core_signal (CPU_STATE (cpu), cpu, PC_byteaddr, read_map,\n+\t\t       nbytes, addr, read_transfer,\n+\t\t       sim_core_unmapped_signal);\n+    }\n+  else if ((regn * 4 + regb + nbytes) > (32 * 4))\n+    {\n+      sim_io_eprintf (CPU_STATE (cpu),\n+\t\t      \"LBBO/LBCO with invalid load data length\\n\");\n+      RAISE_SIGILL (CPU_STATE (cpu));\n+    }\n+  else\n+    {\n+      unsigned int b;\n+      TRACE_MEMORY (cpu, \"read of %d bytes from %08x\", nbytes, addr);\n+      while (nbytes--)\n+\t{\n+\t  b = sim_core_read_1 (cpu, PC_byteaddr, read_map, addr++);\n+\n+\t  /* Reuse the fact the Register Byte Number maps directly to RSEL.  */\n+\t  ASSERT (RSEL_7_0 == 0);\n+\t  write_regval (b, &CPU.regs[regn], regb);\n+\n+\t  if (++regb >= 4)\n+\t    {\n+\t      regb = 0;\n+\t      regn++;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Set reset values of general-purpose registers.  */\n+static void\n+set_initial_gprs (SIM_CPU *cpu)\n+{\n+  int i;\n+\n+  /* Set up machine just out of reset.  */\n+  CPU_PC_SET (cpu, 0);\n+  PC_ADDR_SPACE_MARKER = IMEM_ADDR_DEFAULT; /* from default linker script? */\n+\n+  /* Clean out the GPRs.  */\n+  for (i = 0; i < ARRAY_SIZE (CPU.regs); i++)\n+    CPU.regs[i] = 0;\n+  for (i = 0; i < ARRAY_SIZE (CPU.macregs); i++)\n+    CPU.macregs[i] = 0;\n+\n+  CPU.loop.looptop = CPU.loop.loopend = 0;\n+  CPU.loop.loop_in_progress = 0;\n+  CPU.loop.loop_counter = 0;\n+\n+  CPU.carry = 0;\n+  CPU.insts = 0;\n+  CPU.cycles = 0;\n+\n+  /* AM335x should provide sane defaults.  */\n+  CPU.ctable[0] = 0x00020000;\n+  CPU.ctable[1] = 0x48040000;\n+  CPU.ctable[2] = 0x4802a000;\n+  CPU.ctable[3] = 0x00030000;\n+  CPU.ctable[4] = 0x00026000;\n+  CPU.ctable[5] = 0x48060000;\n+  CPU.ctable[6] = 0x48030000;\n+  CPU.ctable[7] = 0x00028000;\n+  CPU.ctable[8] = 0x46000000;\n+  CPU.ctable[9] = 0x4a100000;\n+  CPU.ctable[10] = 0x48318000;\n+  CPU.ctable[11] = 0x48022000;\n+  CPU.ctable[12] = 0x48024000;\n+  CPU.ctable[13] = 0x48310000;\n+  CPU.ctable[14] = 0x481cc000;\n+  CPU.ctable[15] = 0x481d0000;\n+  CPU.ctable[16] = 0x481a0000;\n+  CPU.ctable[17] = 0x4819c000;\n+  CPU.ctable[18] = 0x48300000;\n+  CPU.ctable[19] = 0x48302000;\n+  CPU.ctable[20] = 0x48304000;\n+  CPU.ctable[21] = 0x00032400;\n+  CPU.ctable[22] = 0x480c8000;\n+  CPU.ctable[23] = 0x480ca000;\n+  CPU.ctable[24] = 0x00000000;\n+  CPU.ctable[25] = 0x00002000;\n+  CPU.ctable[26] = 0x0002e000;\n+  CPU.ctable[27] = 0x00032000;\n+  CPU.ctable[28] = 0x00000000;\n+  CPU.ctable[29] = 0x49000000;\n+  CPU.ctable[30] = 0x40000000;\n+  CPU.ctable[31] = 0x80000000;\n+}\n+\n+/* Map regsel selector to subregister field width.  */\n+static inline unsigned int\n+regsel_width (uint32_t regsel)\n+{\n+  switch (regsel)\n+    {\n+    case RSEL_7_0:    return 8;\n+    case RSEL_15_8:   return 8;\n+    case RSEL_23_16:  return 8;\n+    case RSEL_31_24:  return 8;\n+    case RSEL_15_0:   return 16;\n+    case RSEL_23_8:   return 16;\n+    case RSEL_31_16:  return 16;\n+    case RSEL_31_0:   return 32;\n+    default:\t      sim_io_error (NULL, \"invalid regsel\");\n+    }\n+}\n+\n+/* Handle XIN instruction addressing the MAC peripheral.  */\n+static void\n+pru_sim_xin_mac (SIM_DESC sd, SIM_CPU *cpu, unsigned int rd_regn,\n+\t\t unsigned int rdb, unsigned int length)\n+{\n+  if (rd_regn < 25 || (rd_regn * 4 + rdb + length) > (27 + 1) * 4)\n+    sim_io_error (sd, \"XIN MAC: invalid transfer regn=%u.%u, length=%u\\n\",\n+\t\t  rd_regn, rdb, length);\n+\n+  /* Copy from MAC to PRU regs.  Ranges have been validated above.  */\n+  while (length--)\n+    {\n+      write_regval (CPU.macregs[rd_regn - 25] >> (rdb * 8),\n+\t\t    &CPU.regs[rd_regn],\n+\t\t    rdb);\n+      if (++rdb == 4)\n+\t{\n+\t  rdb = 0;\n+\t  rd_regn++;\n+\t}\n+    }\n+}\n+\n+/* Handle XIN instruction.  */\n+static void\n+pru_sim_xin (SIM_DESC sd, SIM_CPU *cpu, unsigned int wba,\n+\t     unsigned int rd_regn, unsigned int rdb, unsigned int length)\n+{\n+  if (wba == 0)\n+    {\n+      pru_sim_xin_mac (sd, cpu, rd_regn, rdb, length);\n+    }\n+  else if (wba == XFRID_SCRATCH_BANK_0 || wba == XFRID_SCRATCH_BANK_1\n+\t   || wba == XFRID_SCRATCH_BANK_2 || wba == XFRID_SCRATCH_BANK_PEER)\n+    {\n+      while (length--)\n+\t{\n+\t  unsigned int val;\n+\n+\t  val = extract_regval (CPU.scratchpads[wba][rd_regn], rdb);\n+\t  write_regval (val, &CPU.regs[rd_regn], rdb);\n+\t  if (++rdb == 4)\n+\t    {\n+\t      rdb = 0;\n+\t      rd_regn++;\n+\t    }\n+\t}\n+    }\n+  else if (wba == 254 || wba == 255)\n+    {\n+      /* FILL/ZERO pseudos implemented via XIN.  */\n+      unsigned int fillbyte = (wba == 254) ? 0xff : 0x00;\n+      while (length--)\n+\t{\n+\t  write_regval (fillbyte, &CPU.regs[rd_regn], rdb);\n+\t  if (++rdb == 4)\n+\t    {\n+\t      rdb = 0;\n+\t      rd_regn++;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      sim_io_error (sd, \"XIN: XFR device %d not supported.\\n\", wba);\n+    }\n+}\n+\n+/* Handle XOUT instruction addressing the MAC peripheral.  */\n+static void\n+pru_sim_xout_mac (SIM_DESC sd, SIM_CPU *cpu, unsigned int rd_regn,\n+\t\t  unsigned int rdb, unsigned int length)\n+{\n+  const int modereg_accessed = (rd_regn == 25);\n+\n+  /* Multiple Accumulate.  */\n+  if (rd_regn < 25 || (rd_regn * 4 + rdb + length) > (27 + 1) * 4)\n+    sim_io_error (sd, \"XOUT MAC: invalid transfer regn=%u.%u, length=%u\\n\",\n+\t\t  rd_regn, rdb, length);\n+\n+  /* Copy from PRU to MAC regs.  Ranges have been validated above.  */\n+  while (length--)\n+    {\n+      write_regval (CPU.regs[rd_regn] >> (rdb * 8),\n+\t\t    &CPU.macregs[rd_regn - 25],\n+\t\t    rdb);\n+      if (++rdb == 4)\n+\t{\n+\t  rdb = 0;\n+\t  rd_regn++;\n+\t}\n+    }\n+\n+  if (modereg_accessed\n+      && (CPU.macregs[PRU_MACREG_MODE] & MAC_R25_MAC_MODE_MASK))\n+    {\n+      /* MUL/MAC operands are sampled every XOUT in multiply and\n+\t accumulate mode.  */\n+      uint64_t prod, oldsum, sum;\n+      CPU.macregs[PRU_MACREG_OP_0] = CPU.regs[28];\n+      CPU.macregs[PRU_MACREG_OP_1] = CPU.regs[29];\n+\n+      prod = CPU.macregs[PRU_MACREG_OP_0];\n+      prod *= (uint64_t)CPU.macregs[PRU_MACREG_OP_1];\n+\n+      oldsum = CPU.macregs[PRU_MACREG_ACC_L];\n+      oldsum += (uint64_t)CPU.macregs[PRU_MACREG_ACC_H] << 32;\n+      sum = oldsum + prod;\n+\n+      CPU.macregs[PRU_MACREG_PROD_L] = sum & 0xfffffffful;\n+      CPU.macregs[PRU_MACREG_PROD_H] = sum >> 32;\n+      CPU.macregs[PRU_MACREG_ACC_L] = CPU.macregs[PRU_MACREG_PROD_L];\n+      CPU.macregs[PRU_MACREG_ACC_H] = CPU.macregs[PRU_MACREG_PROD_H];\n+\n+      if (oldsum > sum)\n+\tCPU.macregs[PRU_MACREG_MODE] |= MAC_R25_ACC_CARRY_MASK;\n+    }\n+  if (modereg_accessed\n+      && (CPU.macregs[PRU_MACREG_MODE] & MAC_R25_ACC_CARRY_MASK))\n+    {\n+      /* store 1 to clear.  */\n+      CPU.macregs[PRU_MACREG_MODE] &= ~MAC_R25_ACC_CARRY_MASK;\n+      CPU.macregs[PRU_MACREG_ACC_L] = 0;\n+      CPU.macregs[PRU_MACREG_ACC_H] = 0;\n+    }\n+\n+}\n+\n+/* Handle XOUT instruction.  */\n+static void\n+pru_sim_xout (SIM_DESC sd, SIM_CPU *cpu, unsigned int wba,\n+\t      unsigned int rd_regn, unsigned int rdb, unsigned int length)\n+{\n+  if (wba == 0)\n+    {\n+      pru_sim_xout_mac (sd, cpu, rd_regn, rdb, length);\n+    }\n+  else if (wba == XFRID_SCRATCH_BANK_0 || wba == XFRID_SCRATCH_BANK_1\n+\t   || wba == XFRID_SCRATCH_BANK_2 || wba == XFRID_SCRATCH_BANK_PEER)\n+    {\n+      while (length--)\n+\t{\n+\t  unsigned int val;\n+\n+\t  val = extract_regval (CPU.regs[rd_regn], rdb);\n+\t  write_regval (val, &CPU.scratchpads[wba][rd_regn], rdb);\n+\t  if (++rdb == 4)\n+\t    {\n+\t      rdb = 0;\n+\t      rd_regn++;\n+\t    }\n+\t}\n+    }\n+  else\n+    sim_io_error (sd, \"XOUT: XFR device %d not supported.\\n\", wba);\n+}\n+\n+/* Handle XCHG instruction.  */\n+static void\n+pru_sim_xchg (SIM_DESC sd, SIM_CPU *cpu, unsigned int wba,\n+\t      unsigned int rd_regn, unsigned int rdb, unsigned int length)\n+{\n+  if (wba == XFRID_SCRATCH_BANK_0 || wba == XFRID_SCRATCH_BANK_1\n+\t   || wba == XFRID_SCRATCH_BANK_2 || wba == XFRID_SCRATCH_BANK_PEER)\n+    {\n+      while (length--)\n+\t{\n+\t  unsigned int valr, vals;\n+\n+\t  valr = extract_regval (CPU.regs[rd_regn], rdb);\n+\t  vals = extract_regval (CPU.scratchpads[wba][rd_regn], rdb);\n+\t  write_regval (valr, &CPU.scratchpads[wba][rd_regn], rdb);\n+\t  write_regval (vals, &CPU.regs[rd_regn], rdb);\n+\t  if (++rdb == 4)\n+\t    {\n+\t      rdb = 0;\n+\t      rd_regn++;\n+\t    }\n+\t}\n+    }\n+  else\n+    sim_io_error (sd, \"XOUT: XFR device %d not supported.\\n\", wba);\n+}\n+\n+/* Handle syscall simulation.  Its ABI is specific to the GNU simulator.  */\n+static void\n+pru_sim_syscall (SIM_DESC sd, SIM_CPU *cpu)\n+{\n+  /* If someday TI confirms that the \"reserved\" HALT opcode fields\n+     can be used for extra arguments, then maybe we can embed\n+     the syscall number there.  Until then, let's use R1.  */\n+  const uint32_t syscall_num = CPU.regs[1];\n+  long ret;\n+\n+  ret = sim_syscall (cpu, syscall_num,\n+\t\t     CPU.regs[14], CPU.regs[15],\n+\t\t     CPU.regs[16], CPU.regs[17]);\n+  CPU.regs[14] = ret;\n+}\n+\n+/* Simulate one instruction.  */\n+static void\n+sim_step_once (SIM_DESC sd)\n+{\n+  SIM_CPU *cpu = STATE_CPU (sd, 0);\n+  const struct pru_opcode *op;\n+  uint32_t inst;\n+  uint32_t _RDVAL, OP2;\t/* intermediate values.  */\n+  int rd_is_modified = 0;\t/* RD modified and must be stored back.  */\n+\n+  /* Fetch the initial instruction that we'll decode.  */\n+  inst = sim_core_read_4 (cpu, PC_byteaddr, exec_map, PC_byteaddr);\n+  TRACE_MEMORY (cpu, \"read of insn 0x%08x from %08x\", inst, PC_byteaddr);\n+\n+  op = pru_find_opcode (inst);\n+\n+  if (!op)\n+    {\n+      sim_io_eprintf (sd, \"Unknown instruction 0x%04x\\n\", inst);\n+      RAISE_SIGILL (sd);\n+    }\n+  else\n+    {\n+      TRACE_DISASM (cpu, PC_byteaddr);\n+\n+      /* In multiply-only mode, R28/R29 operands are sampled on every clock\n+\t cycle.  */\n+      if ((CPU.macregs[PRU_MACREG_MODE] & MAC_R25_MAC_MODE_MASK) == 0)\n+\t{\n+\t  CPU.macregs[PRU_MACREG_OP_0] = CPU.regs[28];\n+\t  CPU.macregs[PRU_MACREG_OP_1] = CPU.regs[29];\n+\t}\n+\n+      switch (op->type)\n+\t{\n+/* Helper macro to improve clarity of pru.isa.  The empty while is a\n+   guard against using RD as a left-hand side value.  */\n+#define RD  do { } while (0); rd_is_modified = 1; _RDVAL\n+#define INSTRUCTION(NAME, ACTION)\t\t\\\n+\tcase prui_ ## NAME:\t\t\t\\\n+\t\tACTION;\t\t\t\t\\\n+\t  break;\n+#include \"pru.isa\"\n+#undef INSTRUCTION\n+#undef RD\n+\n+\tdefault:\n+\t  RAISE_SIGILL (sd);\n+\t}\n+\n+      if (rd_is_modified)\n+\twrite_regval (_RDVAL, &CPU.regs[RD_REGN], RDSEL);\n+\n+      /* Don't treat r30 and r31 as regular registers, they are I/O!  */\n+      CPU.regs[30] = 0;\n+      CPU.regs[31] = 0;\n+\n+      /* Handle PC match of loop end.  */\n+      if (LOOP_IN_PROGRESS && (PC == LOOPEND))\n+\t{\n+\t  SIM_ASSERT (LOOPCNT > 0);\n+\t  if (--LOOPCNT == 0)\n+\t    LOOP_IN_PROGRESS = 0;\n+\t  else\n+\t    PC = LOOPTOP;\n+\t}\n+\n+      /* In multiply-only mode, MAC does multiplication every cycle.  */\n+      if ((CPU.macregs[PRU_MACREG_MODE] & MAC_R25_MAC_MODE_MASK) == 0)\n+\t{\n+\t  uint64_t prod;\n+\t  prod = CPU.macregs[PRU_MACREG_OP_0];\n+\t  prod *= (uint64_t)CPU.macregs[PRU_MACREG_OP_1];\n+\t  CPU.macregs[PRU_MACREG_PROD_L] = prod & 0xfffffffful;\n+\t  CPU.macregs[PRU_MACREG_PROD_H] = prod >> 32;\n+\n+\t  /* Clear the MAC accumulator when in normal mode.  */\n+\t  CPU.macregs[PRU_MACREG_ACC_L] = 0;\n+\t  CPU.macregs[PRU_MACREG_ACC_H] = 0;\n+\t}\n+\n+      /* Update cycle counts.  */\n+      CPU.insts += 1;\t\t  /* One instruction completed ...  */\n+      CPU.cycles += 1;\t\t  /* ... and it takes a single cycle.  */\n+\n+      /* Account for memory access latency with a reasonable estimate.\n+\t No distinction is currently made between SRAM, DRAM and generic\n+\t L3 slaves.  */\n+      if (op->type == prui_lbbo || op->type == prui_sbbo\n+\t  || op->type == prui_lbco || op->type == prui_sbco)\n+\tCPU.cycles += 2;\n+\n+    }\n+}\n+\n+/* Implement standard sim_engine_run function.  */\n+void\n+sim_engine_run (SIM_DESC sd,\n+\t\tint next_cpu_nr, /* ignore  */\n+\t\tint nr_cpus, /* ignore  */\n+\t\tint siggnal) /* ignore  */\n+{\n+  while (1)\n+    {\n+      sim_step_once (sd);\n+      if (sim_events_tick (sd))\n+\tsim_events_process (sd);\n+    }\n+}\n+\n+\n+/* Implement callback for standard CPU_PC_FETCH routine.  */\n+static sim_cia\n+pru_pc_get (sim_cpu *cpu)\n+{\n+  /* Present PC as byte address.  */\n+  return imem_wordaddr_to_byteaddr (cpu, cpu->pru_cpu.pc);\n+}\n+\n+/* Implement callback for standard CPU_PC_STORE routine.  */\n+static void\n+pru_pc_set (sim_cpu *cpu, sim_cia pc)\n+{\n+  /* PC given as byte address.  */\n+  cpu->pru_cpu.pc = imem_byteaddr_to_wordaddr (cpu, pc);\n+}\n+\n+\n+/* Implement callback for standard CPU_REG_STORE routine.  */\n+static int\n+pru_store_register (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n+{\n+  if (rn < NUM_REGS && rn >= 0)\n+    {\n+      if (length == 4)\n+\t{\n+\t  /* Misalignment safe.  */\n+\t  long ival = pru_extract_unsigned_integer (memory, 4);\n+\t  if (rn < 32)\n+\t    CPU.regs[rn] = ival;\n+\t  else\n+\t    pru_pc_set (cpu, ival);\n+\t  return 4;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Implement callback for standard CPU_REG_FETCH routine.  */\n+static int\n+pru_fetch_register (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n+{\n+  long ival;\n+\n+  if (rn < NUM_REGS && rn >= 0)\n+    {\n+      if (length == 4)\n+\t{\n+\t  if (rn < 32)\n+\t    ival = CPU.regs[rn];\n+\t  else\n+\t    ival = pru_pc_get (cpu);\n+\n+\t  /* Misalignment-safe.  */\n+\t  pru_store_unsigned_integer (memory, 4, ival);\n+\t  return 4;\n+\t}\n+      else\n+\treturn 0;\n+    }\n+  else\n+    return 0;\n+}\n+\n+static void\n+free_state (SIM_DESC sd)\n+{\n+  if (STATE_MODULES (sd) != NULL)\n+    sim_module_uninstall (sd);\n+  sim_cpu_free_all (sd);\n+  sim_state_free (sd);\n+}\n+\n+/* Declare the PRU option handler.  */\n+static DECLARE_OPTION_HANDLER (pru_option_handler);\n+\n+/* Implement the PRU option handler.  */\n+static SIM_RC\n+pru_option_handler (SIM_DESC sd, sim_cpu *cpu, int opt, char *arg,\n+\t\t    int is_command)\n+{\n+  switch (opt)\n+    {\n+    case OPTION_ERROR_NULL_DEREF:\n+      abort_on_dmem_zero_access = TRUE;\n+      return SIM_RC_OK;\n+\n+    default:\n+      sim_io_eprintf (sd, \"Unknown PRU option %d\\n\", opt);\n+      return SIM_RC_FAIL;\n+    }\n+}\n+\n+/* List of PRU-specific options.  */\n+static const OPTION pru_options[] =\n+{\n+  { {\"error-null-deref\", no_argument, NULL, OPTION_ERROR_NULL_DEREF},\n+      '\\0', NULL, \"Trap any access to DMEM address zero\",\n+      pru_option_handler, NULL },\n+\n+  { {NULL, no_argument, NULL, 0}, '\\0', NULL, NULL, NULL, NULL }\n+};\n+\n+/* Implement standard sim_open function.  */\n+SIM_DESC\n+sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n+\t  struct bfd *abfd, char * const *argv)\n+{\n+  int i;\n+  char c;\n+  SIM_DESC sd = sim_state_alloc (kind, cb);\n+  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);\n+\n+  /* The cpu data is kept in a separately allocated chunk of memory.  */\n+  if (sim_cpu_alloc_all (sd, 1, /*cgen_cpu_max_extra_bytes ()*/0) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+  sim_add_option_table (sd, NULL, pru_options);\n+\n+  /* The parser will print an error message for us, so we silently return.  */\n+  if (sim_parse_args (sd, argv) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* Check for/establish a reference program image.  */\n+  if (sim_analyze_program (sd,\n+\t\t\t   (STATE_PROG_ARGV (sd) != NULL\n+\t\t\t    ? *STATE_PROG_ARGV (sd)\n+\t\t\t    : NULL), abfd) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* Configure/verify the target byte order and other runtime\n+     configuration options.  */\n+  if (sim_config (sd) != SIM_RC_OK)\n+    {\n+      sim_module_uninstall (sd);\n+      return 0;\n+    }\n+\n+  if (sim_post_argv_init (sd) != SIM_RC_OK)\n+    {\n+      /* Uninstall the modules to avoid memory leaks,\n+\t file descriptor leaks, etc.  */\n+      sim_module_uninstall (sd);\n+      return 0;\n+    }\n+\n+  /* CPU specific initialization.  */\n+  for (i = 0; i < MAX_NR_PROCESSORS; ++i)\n+    {\n+      SIM_CPU *cpu = STATE_CPU (sd, i);\n+\n+      CPU_REG_STORE (cpu) = pru_store_register;\n+      CPU_REG_FETCH (cpu) = pru_fetch_register;\n+      CPU_PC_FETCH (cpu) = pru_pc_get;\n+      CPU_PC_STORE (cpu) = pru_pc_set;\n+\n+      set_initial_gprs (cpu);\n+    }\n+\n+  /* Allocate external memory if none specified by user.\n+     Use address 4 here in case the user wanted address 0 unmapped.  */\n+  if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)\n+    {\n+      sim_do_commandf (sd, \"memory-region 0x%x,0x%x\",\n+\t\t       0,\n+\t\t       DMEM_DEFAULT_SIZE);\n+    }\n+  if (sim_core_read_buffer (sd, NULL, read_map, &c, IMEM_ADDR_DEFAULT, 1) == 0)\n+    {\n+      sim_do_commandf (sd, \"memory-region 0x%x,0x%x\",\n+\t\t       IMEM_ADDR_DEFAULT,\n+\t\t       IMEM_DEFAULT_SIZE);\n+    }\n+\n+  return sd;\n+}\n+\n+/* Implement standard sim_create_inferior function.  */\n+SIM_RC\n+sim_create_inferior (SIM_DESC sd, struct bfd *prog_bfd,\n+\t\t     char * const *argv, char * const *env)\n+{\n+  SIM_CPU *cpu = STATE_CPU (sd, 0);\n+  SIM_ADDR addr;\n+\n+  addr = bfd_get_start_address (prog_bfd);\n+\n+  sim_pc_set (cpu, addr);\n+  PC_ADDR_SPACE_MARKER = addr & ~IMEM_ADDR_MASK;\n+\n+  /* Standalone mode (i.e. `run`) will take care of the argv for us in\n+     sim_open () -> sim_parse_args ().  But in debug mode (i.e. 'target sim'\n+     with `gdb`), we need to handle it because the user can change the\n+     argv on the fly via gdb's 'run'.  */\n+  if (STATE_PROG_ARGV (sd) != argv)\n+    {\n+      freeargv (STATE_PROG_ARGV (sd));\n+      STATE_PROG_ARGV (sd) = dupargv (argv);\n+    }\n+\n+  return SIM_RC_OK;\n+}"
    },
    {
      "sha": "d4835a548cb46cb19c4b1c9e07fd55bde2f592eb",
      "filename": "sim/pru/pru.h",
      "status": "added",
      "additions": 110,
      "deletions": 0,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/pru.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/pru.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/pru.h?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,110 @@\n+/* Copyright 2016-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of the PRU simulator.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef PRU_H\n+#define PRU_H\n+\n+#include \"config.h\"\n+#include \"opcode/pru.h\"\n+\n+/* Needed for handling the dual PRU address space.  */\n+#define IMEM_ADDR_MASK\t((1u << 23) - 1)\n+\n+#define IMEM_ADDR_DEFAULT 0x20000000\n+\n+/* Define memory sizes to allocate for simulated target.  Sizes are\n+   artificially large to accommodate execution of compiler test suite.\n+   Please synchronize with the linker script for prusim target.  */\n+#define DMEM_DEFAULT_SIZE (64 * 1024 * 1024)\n+\n+/* 16-bit word addressable space.  */\n+#define IMEM_DEFAULT_SIZE (64 * 4 * 1024)\n+\n+/* For AM335x SoCs.  */\n+#define XFRID_SCRATCH_BANK_0\t  10\n+#define XFRID_SCRATCH_BANK_1\t  11\n+#define XFRID_SCRATCH_BANK_2\t  12\n+#define XFRID_SCRATCH_BANK_PEER\t  14\n+#define XFRID_MAX\t\t  255\n+\n+#define CPU     (cpu->pru_cpu)\n+\n+#define PC\t\t(CPU.pc)\n+#define PC_byteaddr\t((PC << 2) | PC_ADDR_SPACE_MARKER)\n+\n+/* Various opcode fields.  */\n+#define RS1 extract_regval (CPU.regs[GET_INSN_FIELD (RS1, inst)], \\\n+\t\t\t    GET_INSN_FIELD (RS1SEL, inst))\n+#define RS2 extract_regval (CPU.regs[GET_INSN_FIELD (RS2, inst)], \\\n+\t\t\t    GET_INSN_FIELD (RS2SEL, inst))\n+\n+#define RS2_w0 extract_regval (CPU.regs[GET_INSN_FIELD (RS2, inst)], \\\n+\t\t\t       RSEL_15_0)\n+\n+#define XBBO_BASEREG (CPU.regs[GET_INSN_FIELD (RS1, inst)])\n+\n+#define RDSEL GET_INSN_FIELD (RDSEL, inst)\n+#define RD_WIDTH regsel_width (RDSEL)\n+#define RD_REGN GET_INSN_FIELD (RD, inst)\n+#define IO GET_INSN_FIELD (IO, inst)\n+#define IMM8 GET_INSN_FIELD (IMM8, inst)\n+#define IMM16 GET_INSN_FIELD (IMM16, inst)\n+#define WAKEONSTATUS GET_INSN_FIELD (WAKEONSTATUS, inst)\n+#define CB GET_INSN_FIELD (CB, inst)\n+#define RDB GET_INSN_FIELD (RDB, inst)\n+#define XFR_WBA GET_INSN_FIELD (XFR_WBA, inst)\n+#define LOOP_JMPOFFS GET_INSN_FIELD (LOOP_JMPOFFS, inst)\n+#define BROFF ((uint32_t) GET_BROFF_SIGNED (inst))\n+\n+#define _BURSTLEN_CALCULATE(BITFIELD)\t\t\t\t\t    \\\n+  ((BITFIELD) >= LSSBBO_BYTECOUNT_R0_BITS7_0 ?\t\t\t\t    \\\n+  (CPU.regs[0] >> ((BITFIELD) - LSSBBO_BYTECOUNT_R0_BITS7_0) * 8) & 0xff    \\\n+  : (BITFIELD) + 1)\n+\n+#define BURSTLEN _BURSTLEN_CALCULATE (GET_BURSTLEN (inst))\n+#define XFR_LENGTH _BURSTLEN_CALCULATE (GET_INSN_FIELD (XFR_LENGTH, inst))\n+\n+#define DO_XIN(wba,regn,rdb,l)\t  \\\n+  pru_sim_xin (sd, cpu, (wba), (regn), (rdb), (l))\n+#define DO_XOUT(wba,regn,rdb,l)\t  \\\n+  pru_sim_xout (sd, cpu, (wba), (regn), (rdb), (l))\n+#define DO_XCHG(wba,regn,rdb,l)\t  \\\n+  pru_sim_xchg (sd, cpu, (wba), (regn), (rdb), (l))\n+\n+#define RAISE_SIGILL(sd)  sim_engine_halt ((sd), NULL, NULL, PC_byteaddr, \\\n+\t\t\t\t\t   sim_stopped, SIM_SIGILL)\n+#define RAISE_SIGINT(sd)  sim_engine_halt ((sd), NULL, NULL, PC_byteaddr, \\\n+\t\t\t\t\t   sim_stopped, SIM_SIGINT)\n+\n+#define MAC_R25_MAC_MODE_MASK\t  (1u << 0)\n+#define MAC_R25_ACC_CARRY_MASK\t  (1u << 1)\n+\n+#define CARRY\tCPU.carry\n+#define CTABLE\tCPU.ctable\n+\n+#define PC_ADDR_SPACE_MARKER\tCPU.pc_addr_space_marker\n+\n+#define LOOPTOP\t\t  CPU.loop.looptop\n+#define LOOPEND\t\t  CPU.loop.loopend\n+#define LOOP_IN_PROGRESS  CPU.loop.loop_in_progress\n+#define LOOPCNT\t\t  CPU.loop.loop_counter\n+\n+/* 32 GP registers plus PC.  */\n+#define NUM_REGS\t33\n+\n+#endif /* PRU_H */"
    },
    {
      "sha": "c906b2a16922a2b65e42b63d0501ea9d0aff6b4e",
      "filename": "sim/pru/pru.isa",
      "status": "added",
      "additions": 249,
      "deletions": 0,
      "changes": 249,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/pru.isa",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/pru.isa",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/pru.isa?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,249 @@\n+/* Copyright 2016-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of the PRU simulator.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */\n+\n+/*\n+   PRU Instruction Set Architecture\n+\n+   INSTRUCTION (NAME,\n+\t\tSEMANTICS)\n+ */\n+\n+INSTRUCTION (add,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 + OP2;\n+\t     CARRY = (((uint64_t) RS1 + (uint64_t) OP2) >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (adc,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 + OP2 + CARRY;\n+\t     CARRY = (((uint64_t) RS1 + (uint64_t) OP2 + (uint64_t) CARRY)\n+\t\t      >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (sub,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 - OP2;\n+\t     CARRY = (((uint64_t) RS1 - (uint64_t) OP2) >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (suc,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 - OP2 - CARRY;\n+\t     CARRY = (((uint64_t) RS1 - (uint64_t) OP2 - (uint64_t) CARRY)\n+\t\t      >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (rsb,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = OP2 - RS1;\n+\t     CARRY = (((uint64_t) OP2 - (uint64_t) RS1) >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (rsc,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = OP2 - RS1 - CARRY;\n+\t     CARRY = (((uint64_t) OP2 - (uint64_t) RS1 - (uint64_t) CARRY)\n+\t\t      >> RD_WIDTH) & 1;\n+\t     PC++)\n+\n+INSTRUCTION (lsl,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 << (OP2 & 0x1f);\n+\t     PC++)\n+\n+INSTRUCTION (lsr,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 >> (OP2 & 0x1f);\n+\t     PC++)\n+\n+INSTRUCTION (and,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 & OP2;\n+\t     PC++)\n+\n+INSTRUCTION (or,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 | OP2;\n+\t     PC++)\n+\n+INSTRUCTION (xor,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 ^ OP2;\n+\t     PC++)\n+\n+INSTRUCTION (not,\n+\t     RD = ~RS1;\n+\t     PC++)\n+\n+INSTRUCTION (min,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 < OP2 ? RS1 : OP2;\n+\t     PC++)\n+\n+INSTRUCTION (max,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 > OP2 ? RS1 : OP2;\n+\t     PC++)\n+\n+INSTRUCTION (clr,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 & ~(1u << (OP2 & 0x1f));\n+\t     PC++)\n+\n+INSTRUCTION (set,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     RD = RS1 | (1u << (OP2 & 0x1f));\n+\t     PC++)\n+\n+INSTRUCTION (jmp,\n+\t     OP2 = (IO ? IMM16 : RS2);\n+\t     PC = OP2)\n+\n+INSTRUCTION (jal,\n+\t     OP2 = (IO ? IMM16 : RS2);\n+\t     RD = PC + 1;\n+\t     PC = OP2)\n+\n+INSTRUCTION (ldi,\n+\t     RD = IMM16;\n+\t     PC++)\n+\n+INSTRUCTION (halt,\n+\t     pru_sim_syscall (sd, cpu);\n+\t     PC++)\n+\n+INSTRUCTION (slp,\n+\t     if (!WAKEONSTATUS)\n+\t      {\n+\t\tRAISE_SIGINT (sd);\n+\t      }\n+\t     else\n+\t      {\n+\t\tPC++;\n+\t      })\n+\n+INSTRUCTION (qbgt,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 > RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qbge,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 >= RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qblt,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 < RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qble,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 <= RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qbeq,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 == RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qbne,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (OP2 != RS1) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qba,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = PC + BROFF)\n+\n+INSTRUCTION (qbbs,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = (RS1 & (1u << (OP2 & 0x1f))) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (qbbc,\n+\t     OP2 = (IO ? IMM8 : RS2);\n+\t     PC = !(RS1 & (1u << (OP2 & 0x1f))) ? (PC + BROFF) : (PC + 1))\n+\n+INSTRUCTION (lbbo,\n+\t     pru_dmem2reg (cpu, XBBO_BASEREG + (IO ? IMM8 : RS2),\n+\t\t\t   BURSTLEN, RD_REGN, RDB);\n+\t     PC++)\n+\n+INSTRUCTION (sbbo,\n+\t     pru_reg2dmem (cpu, XBBO_BASEREG + (IO ? IMM8 : RS2),\n+\t\t\t   BURSTLEN, RD_REGN, RDB);\n+\t     PC++)\n+\n+INSTRUCTION (lbco,\n+\t     pru_dmem2reg (cpu, CTABLE[CB] + (IO ? IMM8 : RS2),\n+\t\t\t   BURSTLEN, RD_REGN, RDB);\n+\t     PC++)\n+\n+INSTRUCTION (sbco,\n+\t     pru_reg2dmem (cpu, CTABLE[CB] + (IO ? IMM8 : RS2),\n+\t\t\t   BURSTLEN, RD_REGN, RDB);\n+\t     PC++)\n+\n+INSTRUCTION (xin,\n+\t     DO_XIN (XFR_WBA, RD_REGN, RDB, XFR_LENGTH);\n+\t     PC++)\n+\n+INSTRUCTION (xout,\n+\t     DO_XOUT (XFR_WBA, RD_REGN, RDB, XFR_LENGTH);\n+\t     PC++)\n+\n+INSTRUCTION (xchg,\n+\t     DO_XCHG (XFR_WBA, RD_REGN, RDB, XFR_LENGTH);\n+\t     PC++)\n+\n+INSTRUCTION (sxin,\n+\t     sim_io_eprintf (sd, \"SXIN instruction not supported by sim\\n\");\n+\t     RAISE_SIGILL (sd))\n+\n+INSTRUCTION (sxout,\n+\t     sim_io_eprintf (sd, \"SXOUT instruction not supported by sim\\n\");\n+\t     RAISE_SIGILL (sd))\n+\n+INSTRUCTION (sxchg,\n+\t     sim_io_eprintf (sd, \"SXCHG instruction not supported by sim\\n\");\n+\t     RAISE_SIGILL (sd))\n+\n+INSTRUCTION (loop,\n+\t     OP2 = (IO ? IMM8 + 1 : RS2_w0);\n+\t     if (OP2 == 0)\n+\t      {\n+\t\tPC = LOOPEND;\n+\t      }\n+\t     else\n+\t      {\n+\t\tLOOPTOP = PC + 1;\n+\t\tLOOPEND = PC + LOOP_JMPOFFS;\n+\t\tLOOPCNT = OP2;\n+\t\tLOOP_IN_PROGRESS = 1;\n+\t\tPC++;\n+\t     })\n+\n+INSTRUCTION (iloop,\n+\t     OP2 = (IO ? IMM8 + 1 : RS2_w0);\n+\t     if (OP2 == 0)\n+\t      {\n+\t\tPC = LOOPEND;\n+\t      }\n+\t     else\n+\t      {\n+\t\tLOOPTOP = PC + 1;\n+\t\tLOOPEND = PC + LOOP_JMPOFFS;\n+\t\tLOOPCNT = OP2;\n+\t\tLOOP_IN_PROGRESS = 1;\n+\t\tPC++;\n+\t     })"
    },
    {
      "sha": "b8a2c20ea8c56b2f083d1b7ed71ad3be18399edb",
      "filename": "sim/pru/sim-main.h",
      "status": "added",
      "additions": 91,
      "deletions": 0,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ddd44b7053386b82769c27c871a08c72e589e93e/sim/pru/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/pru/sim-main.h?ref=ddd44b7053386b82769c27c871a08c72e589e93e",
      "patch": "@@ -0,0 +1,91 @@\n+/* Copyright 2016-2019 Free Software Foundation, Inc.\n+   Contributed by Dimitar Dimitrov <dimitar@dinux.eu>\n+\n+   This file is part of the PRU simulator.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef PRU_SIM_MAIN\n+#define PRU_SIM_MAIN\n+\n+#include <stdint.h>\n+#include <stddef.h>\n+#include \"pru.h\"\n+#include \"sim-basics.h\"\n+\n+#include \"sim-base.h\"\n+\n+/* The machine state.\n+   This state is maintained in host byte order.  The\n+   fetch/store register functions must translate between host\n+   byte order and the target processor byte order.\n+   Keeping this data in target byte order simplifies the register\n+   read/write functions.  Keeping this data in host order improves\n+   the performance of the simulator.  Simulation speed is deemed more\n+   important.  */\n+\n+/* For clarity, please keep the same relative order in this enum as in the\n+   corresponding group of GP registers.\n+\n+   In PRU ISA, Multiplier-Accumulator-Unit's registers are like \"shadows\" of\n+   the GP registers.  MAC registers are implicitly addressed when executing\n+   the XIN/XOUT instructions to access them.  Transfer to/from a MAC register\n+   can happen only from/to its corresponding GP peer register.  */\n+\n+enum pru_macreg_id {\n+    /* MAC register\t  CPU GP register     Description.  */\n+    PRU_MACREG_MODE,\t  /* r25 */\t      /* Mode (MUL/MAC).  */\n+    PRU_MACREG_PROD_L,\t  /* r26 */\t      /* Lower 32 bits of product.  */\n+    PRU_MACREG_PROD_H,\t  /* r27 */\t      /* Higher 32 bits of product.  */\n+    PRU_MACREG_OP_0,\t  /* r28 */\t      /* First operand.  */\n+    PRU_MACREG_OP_1,\t  /* r29 */\t      /* Second operand.  */\n+    PRU_MACREG_ACC_L,\t  /* N/A */\t      /* Accumulator (not exposed)  */\n+    PRU_MACREG_ACC_H,\t  /* N/A */\t      /* Higher 32 bits of MAC\n+\t\t\t\t\t\t accumulator.  */\n+    PRU_MAC_NREGS\n+};\n+\n+struct pru_regset\n+{\n+  uint32_t\t  regs[32];\t\t/* Primary registers.  */\n+  uint16_t\t  pc;\t\t\t/* IMEM _word_ address.  */\n+  uint32_t\t  pc_addr_space_marker; /* IMEM virtual linker offset.  This\n+\t\t\t\t\t   is the artificial offset that\n+\t\t\t\t\t   we invent in order to \"separate\"\n+\t\t\t\t\t   the DMEM and IMEM memory spaces.  */\n+  unsigned int\t  carry : 1;\n+  uint32_t\t  ctable[32];\t\t/* Constant offsets table for xBCO.  */\n+  uint32_t\t  macregs[PRU_MAC_NREGS];\n+  uint32_t\t  scratchpads[XFRID_MAX + 1][32];\n+  struct {\n+    uint16_t looptop;\t\t\t/* LOOP top (PC of loop instr).  */\n+    uint16_t loopend;\t\t\t/* LOOP end (PC of loop end label).  */\n+    int loop_in_progress;\t\t/* Whether to check for PC==loopend.  */\n+    uint32_t loop_counter;\t\t/* LOOP counter.  */\n+  } loop;\n+  int\t\t  cycles;\n+  int\t\t  insts;\n+};\n+\n+struct _sim_cpu {\n+  struct pru_regset pru_cpu;\n+  sim_cpu_base base;\n+};\n+\n+struct sim_state {\n+  sim_cpu *cpu[MAX_NR_PROCESSORS];\n+\n+  sim_state_base base;\n+};\n+#endif /* PRU_SIM_MAIN */"
    }
  ]
}