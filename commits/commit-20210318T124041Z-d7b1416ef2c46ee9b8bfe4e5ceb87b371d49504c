{
  "sha": "d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDdiMTQxNmVmMmM0NmVlOWI4YmZlNGU1Y2ViODdiMzcxZDQ5NTA0Yw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:40:41Z"
    },
    "message": "libctf: types: unify code dealing with small-vs-large struct members\n\nThis completes the job of unifying what was once three separate code\npaths full of duplication for every function dealing with querying the\nproperties of struct and union members.  The dynamic code path was\nalready removed: this change removes the distinction between small and\nlarge members, by adding a helper that copies out members from the vlen,\nexpanding small members into large ones as it does so.\n\nThis makes it possible to have *more* representations of things like\nstructure members without needing to change the querying functions at\nall.  It also lets us check for buffer overruns more effectively,\nverifying that we don't accidentally overrun the end of the vlen in\neither the dynamic or static type case.\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_next_t) <ctn_tp>: New.\n\t<u.ctn_mp>: Remove.\n\t<u.ctn_lmp>: Remove.\n\t<u.ctn_vlen>: New.\n\t* ctf-types.c (ctf_struct_member): New.\n\t(ctf_member_next): Use it, dropping separate large/small code paths.\n\t(ctf_type_align): Likewise.\n\t(ctf_member_info): Likewise.\n\t(ctf_type_rvisit): Likewise.",
    "tree": {
      "sha": "5ffb5632494d12c100d5c2891d00fa729149b3cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5ffb5632494d12c100d5c2891d00fa729149b3cd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "08c428aff4a793b63c7dd2229ae172879623e3a2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08c428aff4a793b63c7dd2229ae172879623e3a2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/08c428aff4a793b63c7dd2229ae172879623e3a2"
    }
  ],
  "stats": {
    "total": 307,
    "additions": 150,
    "deletions": 157
  },
  "files": [
    {
      "sha": "85eb09dd9d0d6c50dcd9432e37d79e1aefa60323",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
      "patch": "@@ -1,3 +1,15 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_next_t) <ctn_tp>: New.\n+\t<u.ctn_mp>: Remove.\n+\t<u.ctn_lmp>: Remove.\n+\t<u.ctn_vlen>: New.\n+\t* ctf-types.c (ctf_struct_member): New.\n+\t(ctf_member_next): Use it, dropping separate large/small code paths.\n+\t(ctf_type_align): Likewise.\n+\t(ctf_member_info): Likewise.\n+\t(ctf_type_rvisit): Likewise.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_dtdef_t) <dtu_members>: Remove."
    },
    {
      "sha": "ad4af32e7eef63be9b2f25cab901af306a25b02a",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
      "patch": "@@ -530,6 +530,7 @@ struct ctf_next\n   ctf_id_t ctn_type;\n   ssize_t ctn_size;\n   ssize_t ctn_increment;\n+  const ctf_type_t *ctn_tp;\n   uint32_t ctn_n;\n \n   /* Some iterators contain other iterators, in addition to their other\n@@ -542,8 +543,7 @@ struct ctf_next\n      members, and the structure, variable and enum members, etc.  */\n   union\n   {\n-    const ctf_member_t *ctn_mp;\n-    const ctf_lmember_t *ctn_lmp;\n+    unsigned char *ctn_vlen;\n     const ctf_enum_t *ctn_en;\n     const ctf_dvdef_t *ctn_dvd;\n     ctf_next_hkv_t *ctn_sorted_hkv;"
    },
    {
      "sha": "ed76eca8463405fc51f80942bcc59df728ad94dc",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 136,
      "deletions": 155,
      "changes": 291,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=d7b1416ef2c46ee9b8bfe4e5ceb87b371d49504c",
      "patch": "@@ -35,6 +35,36 @@ ctf_type_ischild (ctf_dict_t * fp, ctf_id_t id)\n   return (LCTF_TYPE_ISCHILD (fp, id));\n }\n \n+/* Expand a structure element into the passed-in ctf_lmember_t.  */\n+\n+static int\n+ctf_struct_member (ctf_dict_t *fp, ctf_lmember_t *dst, const ctf_type_t *tp,\n+\t\t   unsigned char *vlen, size_t vbytes, size_t n)\n+{\n+  if (!ctf_assert (fp, n < LCTF_INFO_VLEN (fp, tp->ctt_info)))\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  /* Already large.  */\n+  if (tp->ctt_size == CTF_LSIZE_SENT)\n+    {\n+      ctf_lmember_t *lmp = (ctf_lmember_t *) vlen;\n+\n+      if (!ctf_assert (fp, (n + 1) * sizeof (ctf_lmember_t) <= vbytes))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      memcpy (dst, &lmp[n], sizeof (ctf_lmember_t));\n+    }\n+  else\n+    {\n+      ctf_member_t *mp = (ctf_member_t *) vlen;\n+      dst->ctlm_name = mp[n].ctm_name;\n+      dst->ctlm_type = mp[n].ctm_type;\n+      dst->ctlm_offsetlo = mp[n].ctm_offset;\n+      dst->ctlm_offsethi = 0;\n+    }\n+  return 0;\n+}\n+\n /* Iterate over the members of a STRUCT or UNION.  We pass the name, member\n    type, and offset of each member to the specified callback function.  */\n \n@@ -72,12 +102,14 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n   ctf_dict_t *ofp = fp;\n   uint32_t kind;\n   ssize_t offset;\n+  uint32_t max_vlen;\n   ctf_next_t *i = *it;\n \n   if (!i)\n     {\n       const ctf_type_t *tp;\n       ctf_dtdef_t *dtd;\n+      ssize_t size;\n       ssize_t increment;\n \n       if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n@@ -89,8 +121,9 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n       if ((i = ctf_next_create ()) == NULL)\n \treturn ctf_set_errno (ofp, ENOMEM);\n       i->cu.ctn_fp = ofp;\n+      i->ctn_tp = tp;\n \n-      (void) ctf_get_ctt_size (fp, tp, &i->ctn_size, &increment);\n+      ctf_get_ctt_size (fp, tp, &size, &increment);\n       kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n \n       if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n@@ -99,20 +132,20 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n \t  return (ctf_set_errno (ofp, ECTF_NOTSOU));\n \t}\n \n-      dtd = ctf_dynamic_type (fp, type);\n-      i->ctn_iter_fun = (void (*) (void)) ctf_member_next;\n-      i->ctn_n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n-\n-      if (dtd == NULL)\n+      if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n \t{\n-\t  if (i->ctn_size < CTF_LSTRUCT_THRESH)\n-\t    i->u.ctn_mp = (const ctf_member_t *) ((uintptr_t) tp + increment);\n-\t  else\n-\t    i->u.ctn_lmp = (const ctf_lmember_t *) ((uintptr_t) tp + increment);\n+\t  i->u.ctn_vlen = dtd->dtd_vlen;\n+\t  i->ctn_size = dtd->dtd_vlen_alloc;\n \t}\n       else\n-\ti->u.ctn_lmp = (const ctf_lmember_t *) dtd->dtd_vlen;\n+\t{\n+\t  unsigned long vlen = LCTF_INFO_VLEN (fp, tp->ctt_info);\n \n+\t  i->u.ctn_vlen = (unsigned char *) tp + increment;\n+\t  i->ctn_size = LCTF_VBYTES (fp, kind, size, vlen);;\n+\t}\n+      i->ctn_iter_fun = (void (*) (void)) ctf_member_next;\n+      i->ctn_n = 0;\n       *it = i;\n     }\n \n@@ -126,6 +159,8 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n   if ((fp = ctf_get_dict (ofp, type)) == NULL)\n     return (ctf_set_errno (ofp, ECTF_NOPARENT));\n \n+  max_vlen = LCTF_INFO_VLEN (fp, i->ctn_tp->ctt_info);\n+\n   /* When we hit an unnamed struct/union member, we set ctn_type to indicate\n      that we are inside one, then return the unnamed member: on the next call,\n      we must skip over top-level member iteration in favour of iteration within\n@@ -134,46 +169,29 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n  retry:\n   if (!i->ctn_type)\n     {\n-      if (i->ctn_n == 0)\n-\tgoto end_iter;\n-\n-      /* Dynamic structures in read-write dicts always use lmembers.  */\n-      if (i->ctn_size < CTF_LSTRUCT_THRESH\n-\t  && !(fp->ctf_flags & LCTF_RDWR))\n-\t{\n-\t  const char *membname = ctf_strptr (fp, i->u.ctn_mp->ctm_name);\n+      ctf_lmember_t memb;\n+      const char *membname;\n \n-\t  if (name)\n-\t    *name = membname;\n-\t  if (membtype)\n-\t    *membtype = i->u.ctn_mp->ctm_type;\n-\t  offset = i->u.ctn_mp->ctm_offset;\n-\n-\t  if (membname[0] == 0\n-\t      && (ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_UNION))\n-\t    i->ctn_type = i->u.ctn_mp->ctm_type;\n+      if (i->ctn_n == max_vlen)\n+\tgoto end_iter;\n \n-\t  i->u.ctn_mp++;\n-\t}\n-      else\n-\t{\n-\t  const char *membname = ctf_strptr (fp, i->u.ctn_lmp->ctlm_name);\n+      if (ctf_struct_member (fp, &memb, i->ctn_tp, i->u.ctn_vlen, i->ctn_size,\n+\t\t\t     i->ctn_n) < 0)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n \n-\t  if (name)\n-\t    *name = membname;\n-\t  if (membtype)\n-\t    *membtype = i->u.ctn_lmp->ctlm_type;\n-\t  offset = (unsigned long) CTF_LMEM_OFFSET (i->u.ctn_lmp);\n+      membname = ctf_strptr (fp, memb.ctlm_name);\n \n-\t  if (membname[0] == 0\n-\t      && (ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_UNION))\n-\t    i->ctn_type = i->u.ctn_lmp->ctlm_type;\n+      if (name)\n+\t*name = membname;\n+      if (membtype)\n+\t*membtype = memb.ctlm_type;\n+      offset = (unsigned long) CTF_LMEM_OFFSET (&memb);\n \n-\t  i->u.ctn_lmp++;\n-\t}\n-      i->ctn_n--;\n+      if (membname[0] == 0\n+\t  && (ctf_type_kind (fp, memb.ctlm_type) == CTF_K_STRUCT\n+\t      || ctf_type_kind (fp, memb.ctlm_type) == CTF_K_UNION))\n+\ti->ctn_type = memb.ctlm_type;\n+      i->ctn_n++;\n \n       /* The callers might want automatic recursive sub-struct traversal.  */\n       if (!(flags & CTF_MN_RECURSE))\n@@ -964,43 +982,36 @@ ctf_type_align (ctf_dict_t *fp, ctf_id_t type)\n     case CTF_K_UNION:\n       {\n \tsize_t align = 0;\n-\tint dynamic = 0;\n \tctf_dtdef_t *dtd;\n+\tunsigned char *vlen;\n+\tuint32_t i = 0, n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+\tssize_t size, increment, vbytes;\n \n-\tif ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n-\t  dynamic = 1;\n-\n-\tuint32_t n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n-\tssize_t size, increment;\n-\tconst void *vmp;\n+\tctf_get_ctt_size (fp, tp, &size, &increment);\n \n-\t(void) ctf_get_ctt_size (fp, tp, &size, &increment);\n-\n-\tif (!dynamic)\n-\t  vmp = (unsigned char *) tp + increment;\n+\tif ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+\t  {\n+\t    vlen = dtd->dtd_vlen;\n+\t    vbytes = dtd->dtd_vlen_alloc;\n+\t  }\n \telse\n-\t  vmp = dtd->dtd_vlen;\n+\t  {\n+\t    vlen = (unsigned char *) tp + increment;\n+\t    vbytes = LCTF_VBYTES (fp, kind, size, n);\n+\t  }\n \n \tif (kind == CTF_K_STRUCT)\n \t  n = MIN (n, 1);\t/* Only use first member for structs.  */\n \n-\tif (size < CTF_LSTRUCT_THRESH && !dynamic)\n+\tfor (; n != 0; n--, i++)\n \t  {\n-\t    const ctf_member_t *mp = vmp;\n-\t    for (; n != 0; n--, mp++)\n-\t      {\n-\t\tssize_t am = ctf_type_align (ofp, mp->ctm_type);\n-\t\talign = MAX (align, (size_t) am);\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    const ctf_lmember_t *lmp = vmp;\n-\t    for (; n != 0; n--, lmp++)\n-\t      {\n-\t\tssize_t am = ctf_type_align (ofp, lmp->ctlm_type);\n-\t\talign = MAX (align, (size_t) am);\n-\t      }\n+\t    ctf_lmember_t memb;\n+\n+\t    if (ctf_struct_member (fp, &memb, tp, vlen, vbytes, i) < 0)\n+\t      return -1;\t\t\t\t/* errno is set for us.  */\n+\n+\t    ssize_t am = ctf_type_align (ofp, memb.ctlm_type);\n+\t    align = MAX (align, (size_t) am);\n \t  }\n \treturn align;\n       }\n@@ -1349,73 +1360,55 @@ ctf_member_info (ctf_dict_t *fp, ctf_id_t type, const char *name,\n   ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   ctf_dtdef_t *dtd;\n-  const void *vmp;\n-  ssize_t size, increment;\n-  uint32_t kind, n;\n-  int dynamic = 0;\n+  unsigned char *vlen;\n+  ssize_t size, increment, vbytes;\n+  uint32_t kind, n, i = 0;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n     return -1;\t\t\t/* errno is set for us.  */\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n     return -1;\t\t\t/* errno is set for us.  */\n \n-  (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+  ctf_get_ctt_size (fp, tp, &size, &increment);\n   kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n \n   if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n     return (ctf_set_errno (ofp, ECTF_NOTSOU));\n \n-  if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n-    dynamic = 1;\n-\n-  if (!dynamic)\n-    vmp = (unsigned char *) tp + increment;\n+  n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+  if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+    {\n+      vlen = dtd->dtd_vlen;\n+      vbytes = dtd->dtd_vlen_alloc;\n+    }\n   else\n-    vmp = dtd->dtd_vlen;\n+    {\n+      vlen = (unsigned char *) tp + increment;\n+      vbytes = LCTF_VBYTES (fp, kind, size, n);\n+    }\n \n-  if (size < CTF_LSTRUCT_THRESH && !dynamic)\n+  for (; n != 0; n--, i++)\n     {\n-      const ctf_member_t *mp = vmp;\n+      ctf_lmember_t memb;\n+      const char *membname;\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n-\t{\n-\t  const char *membname = ctf_strptr (fp, mp->ctm_name);\n+      if (ctf_struct_member (fp, &memb, tp, vlen, vbytes, i) < 0)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n \n-\t  if (membname[0] == 0\n-\t      && (ctf_type_kind (fp, mp->ctm_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, mp->ctm_type) == CTF_K_UNION)\n-\t      && (ctf_member_info (fp, mp->ctm_type, name, mip) == 0))\n-\t    return 0;\n+      membname = ctf_strptr (fp, memb.ctlm_name);\n \n-\t  if (strcmp (membname, name) == 0)\n-\t    {\n-\t      mip->ctm_type = mp->ctm_type;\n-\t      mip->ctm_offset = mp->ctm_offset;\n-\t      return 0;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      const ctf_lmember_t *lmp = vmp;\n+      if (membname[0] == 0\n+\t  && (ctf_type_kind (fp, memb.ctlm_type) == CTF_K_STRUCT\n+\t      || ctf_type_kind (fp, memb.ctlm_type) == CTF_K_UNION)\n+\t  && (ctf_member_info (fp, memb.ctlm_type, name, mip) == 0))\n+\treturn 0;\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n+      if (strcmp (membname, name) == 0)\n \t{\n-\t  const char *membname = ctf_strptr (fp, lmp->ctlm_name);\n-\n-\t  if (membname[0] == 0\n-\t      && (ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_UNION)\n-\t      && (ctf_member_info (fp, lmp->ctlm_type, name, mip) == 0))\n-\t    return 0;\n-\n-\t  if (strcmp (membname, name) == 0)\n-\t    {\n-\t      mip->ctm_type = lmp->ctlm_type;\n-\t      mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n-\t      return 0;\n-\t    }\n+\t  mip->ctm_type = memb.ctlm_type;\n+\t  mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (&memb);\n+\t  return 0;\n \t}\n     }\n \n@@ -1630,10 +1623,9 @@ ctf_type_rvisit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func,\n   ctf_id_t otype = type;\n   const ctf_type_t *tp;\n   const ctf_dtdef_t *dtd;\n-  const void *vmp;\n-  ssize_t size, increment;\n-  uint32_t kind, n;\n-  int dynamic = 0;\n+  unsigned char *vlen;\n+  ssize_t size, increment, vbytes;\n+  uint32_t kind, n, i = 0;\n   int rc;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n@@ -1650,43 +1642,32 @@ ctf_type_rvisit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func,\n   if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n     return 0;\n \n-  (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n+  ctf_get_ctt_size (fp, tp, &size, &increment);\n \n+  n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n   if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n-    dynamic = 1;\n-\n-  if (!dynamic)\n-    vmp = (unsigned char *) tp + increment;\n-  else\n-    vmp = dtd->dtd_vlen;\n-\n-  if (size < CTF_LSTRUCT_THRESH && !dynamic)\n     {\n-      const ctf_member_t *mp = vmp;\n-\n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n-\t{\n-\t  if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n-\t\t\t\t     func, arg, ctf_strptr (fp,\n-\t\t\t\t\t\t\t    mp->ctm_name),\n-\t\t\t\t     offset + mp->ctm_offset,\n-\t\t\t\t     depth + 1)) != 0)\n-\t    return rc;\n-\t}\n+      vlen = dtd->dtd_vlen;\n+      vbytes = dtd->dtd_vlen_alloc;\n     }\n   else\n     {\n-      const ctf_lmember_t *lmp = vmp;\n+      vlen = (unsigned char *) tp + increment;\n+      vbytes = LCTF_VBYTES (fp, kind, size, n);\n+    }\n \n-      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n-\t{\n-\t  if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n-\t\t\t\t     func, arg, ctf_strptr (fp,\n-\t\t\t\t\t\t\t    lmp->ctlm_name),\n-\t\t\t\t     offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n-\t\t\t\t     depth + 1)) != 0)\n-\t    return rc;\n-\t}\n+  for (; n != 0; n--, i++)\n+    {\n+      ctf_lmember_t memb;\n+\n+      if (ctf_struct_member (fp, &memb, tp, vlen, vbytes, i) < 0)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      if ((rc = ctf_type_rvisit (fp, memb.ctlm_type,\n+\t\t\t\t func, arg, ctf_strptr (fp, memb.ctlm_name),\n+\t\t\t\t offset + (unsigned long) CTF_LMEM_OFFSET (&memb),\n+\t\t\t\t depth + 1)) != 0)\n+\treturn rc;\n     }\n \n   return 0;"
    }
  ]
}