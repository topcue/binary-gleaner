{
  "sha": "351031f22adc77a63663cb2ac729864867d149c1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzUxMDMxZjIyYWRjNzdhNjM2NjNjYjJhYzcyOTg2NDg2N2QxNDljMQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-08-10T13:41:30Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-09-08T09:47:27Z"
    },
    "message": "gdb: make thread_suspend_state::stop_pc optional\n\nCurrently the stop_pc field of thread_suspect_state is a CORE_ADDR and\nwhen we want to indicate that there is no stop_pc available we set\nthis field back to a special value.\n\nThere are actually two special values used, in post_create_inferior\nthe stop_pc is set to 0.  This is a little unfortunate, there are\nplenty of embedded targets where 0 is a valid pc value.  The more\ncommon special value for stop_pc though, is set in\nthread_info::set_executing, where the value (~(CORE_ADDR) 0) is used.\n\nThis commit changes things so that the stop_pc is instead a\ngdb::optional.  We can now explicitly reset the field to an\nuninitialised state, we also have asserts that we don't read the\nstop_pc when its in an uninitialised state (both in\ngdbsupport/gdb_optional.h, when compiling with _GLIBCXX_DEBUG\ndefined, and in thread_info::stop_pc).\n\nOne situation where a thread will not have a stop_pc value is when the\nthread is stopped as a consequence of GDB being in all stop mode, and\nsome other thread stopped at an interesting event.  When GDB brings\nall the other threads to a stop those other threads will not have a\nstop_pc set (thus avoiding an unnecessary read of the pc register).\n\nPreviously, when GDB passed through handle_one (in infrun.c) the\nthreads executing flag was set to false and the stop_pc field was left\nunchanged, i.e. it would (previous) have been left as ~0.\n\nNow, handle_one leaves the stop_pc with no value.\n\nThis caused a problem when we later try to set these threads running\nagain, in proceed() we compare the current pc with the cached stop_pc.\nIf the thread was stopped via handle_one then the stop_pc would have\nbeen left as ~0, and the compare (in proceed) would (likely) fail.\nNow however, this compare tries to read the stop_pc when it has no\nvalue and this would trigger an assert.\n\nTo resolve this I've added thread_info::stop_pc_p() which returns true\nif the thread has a cached stop_pc.  We should only ever call\nthread_info::stop_pc() if we know that there is a cached stop_pc,\nhowever, this doesn't mean that every call to thread_info::stop_pc()\nneeds to be guarded with a call to thread_info::stop_pc_p(), in most\ncases we know that the thread we are looking at stopped due to some\ninteresting event in that thread, and so, we know that the stop_pc is\nvalid.\n\nAfter running the testsuite I've seen no other situations where\nstop_pc is read uninitialised.\n\nThere should be no user visible changes after this commit.",
    "tree": {
      "sha": "938719a1e21f9b14ef29a031a2e9d296bf5ff37a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/938719a1e21f9b14ef29a031a2e9d296bf5ff37a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/351031f22adc77a63663cb2ac729864867d149c1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/351031f22adc77a63663cb2ac729864867d149c1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/351031f22adc77a63663cb2ac729864867d149c1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/351031f22adc77a63663cb2ac729864867d149c1/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "42f46152849a2d4bd06a87c2dc795de1f7fc1af7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/42f46152849a2d4bd06a87c2dc795de1f7fc1af7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/42f46152849a2d4bd06a87c2dc795de1f7fc1af7"
    }
  ],
  "stats": {
    "total": 39,
    "additions": 31,
    "deletions": 8
  },
  "files": [
    {
      "sha": "4b271943d50901f31c2f2771108e588016caa212",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 27,
      "deletions": 5,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/351031f22adc77a63663cb2ac729864867d149c1/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/351031f22adc77a63663cb2ac729864867d149c1/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=351031f22adc77a63663cb2ac729864867d149c1",
      "patch": "@@ -197,9 +197,12 @@ struct thread_suspend_state\n        stop_reason: if the thread's PC has changed since the thread\n        last stopped, a pending breakpoint waitstatus is discarded.\n \n-     - If the thread is running, this is set to -1, to avoid leaving\n-       it with a stale value, to make it easier to catch bugs.  */\n-  CORE_ADDR stop_pc = 0;\n+     - If the thread is running, then this field has its value removed by\n+       calling stop_pc.reset() (see thread_info::set_executing()).\n+       Attempting to read a gdb::optional with no value is undefined\n+       behaviour and will trigger an assertion error when _GLIBCXX_DEBUG is\n+       defined, which should make error easier to track down.  */\n+  gdb::optional<CORE_ADDR> stop_pc;\n };\n \n /* Base class for target-specific thread data.  */\n@@ -327,11 +330,15 @@ class thread_info : public refcounted_object,\n     m_suspend = suspend;\n   }\n \n-  /* Return this thread's stop PC.  */\n+  /* Return this thread's stop PC.  This should only be called when it is\n+     known that stop_pc has a value.  If this function is being used in a\n+     situation where a thread may not have had a stop_pc assigned, then\n+     stop_pc_p() can be used to check if the stop_pc is defined.  */\n \n   CORE_ADDR stop_pc () const\n   {\n-    return m_suspend.stop_pc;\n+    gdb_assert (m_suspend.stop_pc.has_value ());\n+    return *m_suspend.stop_pc;\n   }\n \n   /* Set this thread's stop PC.  */\n@@ -341,6 +348,21 @@ class thread_info : public refcounted_object,\n     m_suspend.stop_pc = stop_pc;\n   }\n \n+  /* Remove the stop_pc stored on this thread.  */\n+\n+  void clear_stop_pc ()\n+  {\n+    m_suspend.stop_pc.reset ();\n+  }\n+\n+  /* Return true if this thread has a cached stop pc value, otherwise\n+     return false.  */\n+\n+  bool stop_pc_p () const\n+  {\n+    return m_suspend.stop_pc.has_value ();\n+  }\n+\n   /* Return true if this thread has a pending wait status.  */\n \n   bool has_pending_waitstatus () const"
    },
    {
      "sha": "d948f4bafc5ce1a7844102a41bec3687a49b8670",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/351031f22adc77a63663cb2ac729864867d149c1/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/351031f22adc77a63663cb2ac729864867d149c1/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=351031f22adc77a63663cb2ac729864867d149c1",
      "patch": "@@ -249,7 +249,7 @@ post_create_inferior (int from_tty)\n      missing registers info), ignore it.  */\n   thread_info *thr = inferior_thread ();\n \n-  thr->set_stop_pc (0);\n+  thr->clear_stop_pc ();\n   try\n     {\n       regcache *rc = get_thread_regcache (thr);"
    },
    {
      "sha": "d1ac9b4cbbb51955e35ad960b598240bbe87777a",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/351031f22adc77a63663cb2ac729864867d149c1/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/351031f22adc77a63663cb2ac729864867d149c1/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=351031f22adc77a63663cb2ac729864867d149c1",
      "patch": "@@ -3051,7 +3051,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n   if (addr == (CORE_ADDR) -1)\n     {\n-      if (pc == cur_thr->stop_pc ()\n+      if (cur_thr->stop_pc_p ()\n+\t  && pc == cur_thr->stop_pc ()\n \t  && breakpoint_here_p (aspace, pc) == ordinary_breakpoint_here\n \t  && execution_direction != EXEC_REVERSE)\n \t/* There is a breakpoint at the address we will resume at,"
    },
    {
      "sha": "10c3dcd6991f919a561652f942b35f7c637917d9",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/351031f22adc77a63663cb2ac729864867d149c1/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/351031f22adc77a63663cb2ac729864867d149c1/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=351031f22adc77a63663cb2ac729864867d149c1",
      "patch": "@@ -324,7 +324,7 @@ thread_info::set_executing (bool executing)\n {\n   m_executing = executing;\n   if (executing)\n-    this->set_stop_pc (~(CORE_ADDR) 0);\n+    this->clear_stop_pc ();\n }\n \n /* See gdbthread.h.  */"
    }
  ]
}