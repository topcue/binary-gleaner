{
  "sha": "40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDBjNzViYzhiMDdhYmM1ZDU3NzRlYTFjNDM5YjY5Yzk2ZTdmZDQ4NQ==",
  "commit": {
    "author": {
      "name": "Sergey Belyashov",
      "email": "sergey.belyashov@gmail.com",
      "date": "2020-01-09T11:47:44Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-01-09T11:49:18Z"
    },
    "message": "Fix compile time warnings about comparisons always being false.\n\n\tPR 25224\ngas\t* config/tc-z80.c (emit_ld_m_rr): Use integer types when checking\n\topcode byte values.\n\t(emit_ld_r_r): Likewise.\n\t(emit_ld_rr_m): Likewise.\n\t(emit_ld_rr_nn): Likewise.\n\nopcodes\t* z80-dis.c (ld_ii_ii): Use character constant when checking\n\topcode byte value.",
    "tree": {
      "sha": "bb0efc3b78e0eb8a7ddbed1d2af4979f18ab8719",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bb0efc3b78e0eb8a7ddbed1d2af4979f18ab8719"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/comments",
  "author": {
    "login": "b-s-a",
    "id": 2833802,
    "node_id": "MDQ6VXNlcjI4MzM4MDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2833802?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/b-s-a",
    "html_url": "https://github.com/b-s-a",
    "followers_url": "https://api.github.com/users/b-s-a/followers",
    "following_url": "https://api.github.com/users/b-s-a/following{/other_user}",
    "gists_url": "https://api.github.com/users/b-s-a/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/b-s-a/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/b-s-a/subscriptions",
    "organizations_url": "https://api.github.com/users/b-s-a/orgs",
    "repos_url": "https://api.github.com/users/b-s-a/repos",
    "events_url": "https://api.github.com/users/b-s-a/events{/privacy}",
    "received_events_url": "https://api.github.com/users/b-s-a/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "72aea32839b5f4a2c8fa67e60451169b841941c0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72aea32839b5f4a2c8fa67e60451169b841941c0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/72aea32839b5f4a2c8fa67e60451169b841941c0"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 114,
    "deletions": 96
  },
  "files": [
    {
      "sha": "ee1f8e643779efb88c9acb96e7dc4a245b2d609c",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
      "patch": "@@ -1,3 +1,12 @@\n+2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>\n+\n+\tPR 25224\n+\t* config/tc-z80.c (emit_ld_m_rr): Use integer types when checking\n+\topcode byte values.\n+\t(emit_ld_r_r): Likewise.\n+\t(emit_ld_rr_m): Likewise.\n+\t(emit_ld_rr_nn): Likewise.\n+\n 2020-01-09  Jan Beulich  <jbeulich@suse.com>\n \n \t* config/tc-i386.c (optimize_encoding): Add"
    },
    {
      "sha": "28b0f2b3f528c7c5133f5b34f9edd009fa1770cb",
      "filename": "gas/config/tc-z80.c",
      "status": "modified",
      "additions": 92,
      "deletions": 89,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/gas/config/tc-z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/gas/config/tc-z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-z80.c?ref=40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
      "patch": "@@ -168,13 +168,13 @@ str_to_float48 (char *litP, int *sizeP);\n static str_to_float_t\n get_str_to_float (const char *arg)\n {\n-  if (strcasecmp(arg, \"zeda32\") == 0)\n+  if (strcasecmp (arg, \"zeda32\") == 0)\n     return str_to_zeda32;\n \n-  if (strcasecmp(arg, \"math48\") == 0)\n+  if (strcasecmp (arg, \"math48\") == 0)\n     return str_to_float48;\n \n-  if (strcasecmp(arg, \"ieee754\") != 0)\n+  if (strcasecmp (arg, \"ieee754\") != 0)\n     as_fatal (_(\"invalid floating point numbers type `%s'\"), arg);\n   return NULL;\n }\n@@ -256,11 +256,11 @@ md_parse_option (int c, const char* arg)\n       break;\n     case OPTION_MACH_INST:\n       if ((ins_ok & INS_GBZ80) == 0)\n-        return setup_instruction_list(arg, & ins_ok, & ins_err);\n+        return setup_instruction_list (arg, & ins_ok, & ins_err);\n       break;\n     case OPTION_MACH_NO_INST:\n       if ((ins_ok & INS_GBZ80) == 0)\n-        return setup_instruction_list(arg, & ins_err, & ins_ok);\n+        return setup_instruction_list (arg, & ins_err, & ins_ok);\n       break;\n     case OPTION_MACH_WUD:\n     case OPTION_MACH_IUD:\n@@ -443,11 +443,11 @@ md_begin (void)\n             {\n               for ( k = 0 ; regtable[i].name[k] ; ++k )\n                 {\n-                  buf[k] = ( j & ( 1<<k ) ) ? TOUPPER ( regtable[i].name[k] ) : regtable[i].name[k];\n+                  buf[k] = ( j & ( 1<<k ) ) ? TOUPPER (regtable[i].name[k]) : regtable[i].name[k];\n                 }\n-              symbolS * psym = symbol_find_or_make(buf);\n-\t      S_SET_SEGMENT(psym, reg_section);\n-\t      symbol_set_value_expression(psym, &reg);\n+              symbolS * psym = symbol_find_or_make (buf);\n+\t      S_SET_SEGMENT (psym, reg_section);\n+\t      symbol_set_value_expression (psym, &reg);\n             }\n         }\n     }\n@@ -586,7 +586,7 @@ z80_start_line_hook (void)\n       c = get_symbol_name (&name);\n       rest = input_line_pointer + 1;\n \n-      if (ISSPACE(c) && colonless_labels)\n+      if (ISSPACE (c) && colonless_labels)\n         {\n           if (c == '\\n')\n             {\n@@ -613,7 +613,7 @@ z80_start_line_hook (void)\n \tlen = 4;\n       else\n \tlen = 0;\n-      if (len && (!ISALPHA(rest[len]) ) )\n+      if (len && (!ISALPHA (rest[len])))\n \t{\n \t  /* Handle assignment here.  */\n \t  if (line_start[-1] == '\\n')\n@@ -722,7 +722,7 @@ static void\n wrong_mach (int ins_type)\n {\n   if (ins_type & ins_err)\n-    ill_op();\n+    ill_op ();\n   else\n     as_warn (_(\"undocumented instruction\"));\n }\n@@ -781,17 +781,18 @@ is_indir (const char *s)\n \n /* Check whether a symbol involves a register.  */\n static int\n-contains_register(symbolS *sym)\n+contains_register (symbolS *sym)\n {\n   if (sym)\n-  {\n-    expressionS * ex = symbol_get_value_expression(sym);\n-    return (O_register == ex->X_op)\n-      || (ex->X_add_symbol && contains_register(ex->X_add_symbol))\n-      || (ex->X_op_symbol && contains_register(ex->X_op_symbol));\n-  }\n-  else\n-    return 0;\n+    {\n+      expressionS * ex = symbol_get_value_expression(sym);\n+\n+      return (O_register == ex->X_op)\n+\t|| (ex->X_add_symbol && contains_register(ex->X_add_symbol))\n+\t|| (ex->X_op_symbol && contains_register(ex->X_op_symbol));\n+    }\n+\n+  return 0;\n }\n \n /* Parse general expression, not looking for indexed addressing.  */\n@@ -851,28 +852,29 @@ parse_exp_not_indexed (const char *s, expressionS *op)\n static int\n unify_indexed (expressionS *op)\n {\n-  if (O_register != symbol_get_value_expression(op->X_add_symbol)->X_op)\n+  if (O_register != symbol_get_value_expression (op->X_add_symbol)->X_op)\n     return 0;\n \n-  int rnum = symbol_get_value_expression(op->X_add_symbol)->X_add_number;\n-  if ( ((REG_IX != rnum) && (REG_IY != rnum)) || contains_register(op->X_op_symbol) )\n+  int rnum = symbol_get_value_expression (op->X_add_symbol)->X_add_number;\n+  if ( ((REG_IX != rnum) && (REG_IY != rnum)) || contains_register (op->X_op_symbol))\n     {\n-      ill_op();\n+      ill_op ();\n       return 0;\n     }\n \n-  /* convert subtraction to addition of negative value */\n+  /* Convert subtraction to addition of negative value.  */\n   if (O_subtract == op->X_op)\n     {\n       expressionS minus;\n       minus.X_op = O_uminus;\n       minus.X_add_number = 0;\n       minus.X_add_symbol = op->X_op_symbol;\n       minus.X_op_symbol = 0;\n-      op->X_op_symbol = make_expr_symbol(&minus);\n+      op->X_op_symbol = make_expr_symbol (&minus);\n       op->X_op = O_add;\n     }\n-  /* clear X_add_number of the expression */\n+\n+  /* Clear X_add_number of the expression.  */\n   if (op->X_add_number != 0)\n     {\n       expressionS add;\n@@ -881,7 +883,7 @@ unify_indexed (expressionS *op)\n       add.X_add_number = op->X_add_number;\n       add.X_add_symbol = op->X_op_symbol;\n       add.X_op_symbol = 0;\n-      op->X_add_symbol = make_expr_symbol(&add);\n+      op->X_add_symbol = make_expr_symbol (&add);\n     }\n   else\n     op->X_add_symbol = op->X_op_symbol;\n@@ -891,7 +893,7 @@ unify_indexed (expressionS *op)\n   return 1;\n }\n \n-/* Parse expression, change operator to O_md1 for indexed addressing*/\n+/* Parse expression, change operator to O_md1 for indexed addressing.  */\n static const char *\n parse_exp (const char *s, expressionS *op)\n {\n@@ -900,11 +902,11 @@ parse_exp (const char *s, expressionS *op)\n     {\n     case O_add:\n     case O_subtract:\n-      if (unify_indexed(op) && op->X_md)\n+      if (unify_indexed (op) && op->X_md)\n         op->X_op = O_md1;\n       break;\n     case O_register:\n-      if ( op->X_md && ((REG_IX == op->X_add_number)||(REG_IY == op->X_add_number)) )\n+      if (op->X_md && ((REG_IX == op->X_add_number) || (REG_IY == op->X_add_number)))\n         {\n \t  op->X_add_symbol = zero;\n \t  op->X_op = O_md1;\n@@ -1048,14 +1050,14 @@ emit_data_val (expressionS * val, int size)\n \n   if (   (val->X_op == O_register)\n       || (val->X_op == O_md1)\n-      || contains_register(val->X_add_symbol)\n-      || contains_register(val->X_op_symbol) )\n+      || contains_register (val->X_add_symbol)\n+      || contains_register (val->X_op_symbol))\n     ill_op ();\n \n   if (size <= 2 && val->X_op_symbol)\n     {\n       bfd_boolean simplify = TRUE;\n-      int shift = symbol_get_value_expression(val->X_op_symbol)->X_add_number;\n+      int shift = symbol_get_value_expression (val->X_op_symbol)->X_add_number;\n       if (val->X_op == O_bit_and && shift == (1 << (size*8))-1)\n \tshift = 0;\n       else if (val->X_op != O_right_shift)\n@@ -1106,9 +1108,9 @@ emit_byte (expressionS * val, bfd_reloc_code_real_type r_type)\n     }\n   p = frag_more (1);\n   *p = val->X_add_number;\n-  if ( contains_register(val->X_add_symbol) || contains_register(val->X_op_symbol) )\n+  if ( contains_register (val->X_add_symbol) || contains_register (val->X_op_symbol) )\n     {\n-      ill_op();\n+      ill_op ();\n     }\n   else if ((r_type == BFD_RELOC_8_PCREL) && (val->X_op == O_constant))\n     {\n@@ -1306,7 +1308,7 @@ emit_s (char prefix, char opcode, const char *args)\n   if (*p == ',' && arg_s.X_md == 0 && arg_s.X_op == O_register && arg_s.X_add_number == REG_A)\n     { /* possible instruction in generic format op A,x */\n       if (!(ins_ok & INS_EZ80) && !sdcc_compat)\n-        ill_op();\n+        ill_op ();\n       ++p;\n       p = parse_exp (p, & arg_s);\n     }\n@@ -1890,9 +1892,10 @@ emit_rst (char prefix ATTRIBUTE_UNUSED, char opcode, const char * args)\n   return p;\n }\n \n+/* For 8-bit indirect load to memory instructions like: LD (HL),n or LD (ii+d),n.  */\n static void\n-emit_ld_m_n(expressionS *dst, expressionS *src)\n-{ /* for 8-bit indirect load to memory instructions like: LD (HL),n or LD (ii+d),n */\n+emit_ld_m_n (expressionS *dst, expressionS *src)\n+{\n   char *q;\n   char prefix;\n   expressionS dst_offset;\n@@ -1921,9 +1924,10 @@ emit_ld_m_n(expressionS *dst, expressionS *src)\n   emit_byte (src, BFD_RELOC_8);\n }\n \n+/* For 8-bit load register to memory instructions: LD (<expression>),r.  */\n static void\n-emit_ld_m_r(expressionS *dst, expressionS *src)\n-{ /* for 8-bit load register to memory instructions: LD (<expression>),r */\n+emit_ld_m_r (expressionS *dst, expressionS *src)\n+{\n   char *q;\n   char prefix = 0;\n   expressionS dst_offset;\n@@ -1980,12 +1984,13 @@ emit_ld_m_r(expressionS *dst, expressionS *src)\n     ill_op ();\n }\n \n+/* For 16-bit load register to memory instructions: LD (<expression>),rr.  */\n static void\n-emit_ld_m_rr(expressionS *dst, expressionS *src)\n-{ /* for 16-bit load register to memory instructions: LD (<expression>),rr */\n+emit_ld_m_rr (expressionS *dst, expressionS *src)\n+{\n   char *q;\n-  char prefix = 0;\n-  char opcode = 0;\n+  int prefix = 0;\n+  int opcode = 0;\n   expressionS dst_offset;\n \n   switch (dst->X_op)\n@@ -2007,15 +2012,15 @@ emit_ld_m_rr(expressionS *dst, expressionS *src)\n         case REG_BC: opcode = 0x0F; break;\n         case REG_DE: opcode = 0x1F; break;\n         case REG_HL: opcode = 0x2F; break;\n-        case REG_IX: opcode = (prefix != '\\xfd') ? 0x3F : 0x3E; break;\n-        case REG_IY: opcode = (prefix != '\\xfd') ? 0x3E : 0x3F; break;\n+\tcase REG_IX: opcode = (prefix != 0xFD) ? 0x3F : 0x3E; break;\n+\tcase REG_IY: opcode = (prefix != 0xFD) ? 0x3E : 0x3F; break;\n         default:\n           ill_op ();\n         }\n         q = frag_more (prefix ? 2 : 1);\n         *q++ = prefix;\n         *q = opcode;\n-        if (prefix == '\\xfd' || prefix == '\\xdd')\n+\tif (prefix == 0xFD || prefix == 0xDD)\n           {\n             dst_offset = *dst;\n             dst_offset.X_op = O_symbol;\n@@ -2165,8 +2170,8 @@ emit_ld_r_r (expressionS *dst, expressionS *src)\n { /* mostly 8-bit load register from register instructions: LD r,r */\n   /* there are some exceptions: LD SP,HL/IX/IY; LD I,HL and LD HL,I */\n   char *q;\n-  char prefix = 0;\n-  char opcode = 0;\n+  int prefix = 0;\n+  int opcode = 0;\n   int ii_halves = 0;\n \n   switch (dst->X_add_number)\n@@ -2296,14 +2301,14 @@ emit_ld_r_r (expressionS *dst, expressionS *src)\n             break;\n           case REG_H|R_IX:\n           case REG_L|R_IX:\n-            if (prefix == '\\xfd' || dst->X_add_number == REG_H || dst->X_add_number == REG_L)\n+\t    if (prefix == 0xFD || dst->X_add_number == REG_H || dst->X_add_number == REG_L)\n               ill_op (); /* LD IYL,IXL and LD H,IXH are not permitted */\n             prefix = 0xDD;\n             ii_halves = 1;\n             break;\n           case REG_H|R_IY:\n           case REG_L|R_IY:\n-            if (prefix == '\\xdd' || dst->X_add_number == REG_H || dst->X_add_number == REG_L)\n+\t    if (prefix == 0xDD || dst->X_add_number == REG_H || dst->X_add_number == REG_L)\n               ill_op (); /* LD IXH,IYH and LD L,IYL are not permitted */\n             prefix = 0xFD;\n             ii_halves = 1;\n@@ -2325,7 +2330,7 @@ emit_ld_r_r (expressionS *dst, expressionS *src)\n         case 0x49: /* LIS prefix, in Z80 it is LD C,C */\n         case 0x52: /* SIL prefix, in Z80 it is LD D,D */\n         case 0x5B: /* LIL prefix, in Z80 it is LD E,E */\n-          as_warn(_(\"unsupported instruction, assembled as NOP\"));\n+          as_warn (_(\"unsupported instruction, assembled as NOP\"));\n           opcode = 0x00;\n           break;\n         default:;\n@@ -2341,8 +2346,8 @@ static void\n emit_ld_rr_m (expressionS *dst, expressionS *src)\n { /* for 16-bit indirect load from memory to register: LD rr,(xxx) */\n   char *q;\n-  char prefix = 0;\n-  char opcode = 0;\n+  int prefix = 0;\n+  int opcode = 0;\n   expressionS src_offset;\n \n   /* GBZ80 has no support for 16-bit load from memory instructions */\n@@ -2364,15 +2369,15 @@ emit_ld_rr_m (expressionS *dst, expressionS *src)\n         case REG_BC: opcode = 0x07; break;\n         case REG_DE: opcode = 0x17; break;\n         case REG_HL: opcode = 0x27; break;\n-        case REG_IX: opcode = (!prefix || prefix == '\\xdd') ? 0x37 : 0x31; break;\n-        case REG_IY: opcode = prefix ? ((prefix == '\\xdd') ? 0x31 : 0x37) : 0x36; break;\n+\tcase REG_IX: opcode = (!prefix || prefix == 0xDD) ? 0x37 : 0x31; break;\n+\tcase REG_IY: opcode = prefix ? ((prefix == 0xDD) ? 0x31 : 0x37) : 0x36; break;\n         default:\n           ill_op ();\n         }\n       q = frag_more (2);\n       *q++ = prefix;\n       *q = opcode;\n-      if (prefix != '\\xed')\n+      if (prefix != 0xED)\n         {\n           src_offset = *src;\n           src_offset.X_op = O_symbol;\n@@ -2405,8 +2410,8 @@ static void\n emit_ld_rr_nn (expressionS *dst, expressionS *src)\n { /* mostly load imediate value to multibyte register instructions: LD rr,nn */\n   char *q;\n-  char prefix = 0x00;\n-  char opcode = 0x21; /* LD HL,nn */\n+  int prefix = 0x00;\n+  int opcode = 0x21; /* LD HL,nn */\n   switch (dst->X_add_number)\n     {\n     case REG_IX:\n@@ -2489,7 +2494,7 @@ emit_lddldi (char prefix, char opcode, const char * args)\n   char *q;\n \n   if (!(ins_ok & INS_GBZ80))\n-    return emit_insn(prefix, opcode, args);\n+    return emit_insn (prefix, opcode, args);\n \n   p = parse_exp (args, & dst);\n   if (*p++ != ',')\n@@ -2561,7 +2566,7 @@ emit_ldh (char prefix ATTRIBUTE_UNUSED, char opcode ATTRIBUTE_UNUSED,\n               *q = 0xE2;\n             }\n           else\n-            ill_op();\n+            ill_op ();\n         }\n       else\n         {\n@@ -2643,10 +2648,10 @@ emit_lea (char prefix, char opcode, const char * args)\n   switch (rnum)\n     {\n     case REG_IX:\n-      opcode = (opcode == 0x33) ? 0x55 : (opcode|0x00);\n+      opcode = (opcode == (char)0x33) ? 0x55 : (opcode|0x00);\n       break;\n     case REG_IY:\n-      opcode = (opcode == 0x32) ? 0x54 : (opcode|0x01);\n+      opcode = (opcode == (char)0x32) ? 0x54 : (opcode|0x01);\n     }\n \n   q = frag_more (2);\n@@ -2693,7 +2698,7 @@ emit_pea (char prefix, char opcode, const char * args)\n   /* PEA ii without displacement is mostly typo,\n      because there is PUSH instruction which is shorter and faster */\n   /*if (arg.X_op == O_register)\n-    as_warn(_(\"PEA is used without displacement, use PUSH instead\"));*/\n+    as_warn (_(\"PEA is used without displacement, use PUSH instead\"));*/\n \n   q = frag_more (2);\n   *q++ = prefix;\n@@ -2710,9 +2715,9 @@ static const char *\n emit_reti (char prefix, char opcode, const char * args)\n {\n   if (ins_ok & INS_GBZ80)\n-    return emit_insn(0x00, 0xD9, args);\n+    return emit_insn (0x00, 0xD9, args);\n \n-  return emit_insn(prefix, opcode, args);\n+  return emit_insn (prefix, opcode, args);\n }\n \n static const char *\n@@ -2727,7 +2732,7 @@ emit_tst (char prefix, char opcode, const char *args)\n   if (*p == ',' && arg_s.X_md == 0 && arg_s.X_op == O_register && arg_s.X_add_number == REG_A)\n     {\n       if (!(ins_ok & INS_EZ80))\n-        ill_op();\n+        ill_op ();\n       ++p;\n       p = parse_exp (p, & arg_s);\n     }\n@@ -2776,7 +2781,7 @@ emit_tstio (char prefix, char opcode, const char *args)\n   q = frag_more (2);\n   *q++ = prefix;\n   *q = opcode;\n-  emit_byte(& arg, BFD_RELOC_8);\n+  emit_byte (& arg, BFD_RELOC_8);\n \n   return p;\n }\n@@ -2878,7 +2883,7 @@ assume (int arg ATTRIBUTE_UNUSED)\n \n   input_line_pointer = (char*)skip_space (input_line_pointer);\n   c = get_symbol_name (& name);\n-  if (strncasecmp(name, \"ADL\", 4) != 0)\n+  if (strncasecmp (name, \"ADL\", 4) != 0)\n     {\n       ill_op ();\n       return;\n@@ -2990,12 +2995,12 @@ assemble_suffix (const char **suffix)\n \n   for (i = 0; (i < 3) && (ISALPHA (*p)); i++)\n     sbuf[i] = TOLOWER (*p++);\n-  if (*p && !ISSPACE(*p))\n+  if (*p && !ISSPACE (*p))\n     return 0;\n   *suffix = p;\n   sbuf[i] = 0;\n \n-  t = bsearch(sbuf, sf, ARRAY_SIZE (sf), sizeof(sf[0]), (int(*)(const void*, const void*))strcmp);\n+  t = bsearch (sbuf, sf, ARRAY_SIZE (sf), sizeof (sf[0]), (int(*)(const void*, const void*)) strcmp);\n   if (t == NULL)\n     return 0;\n   i = t - sf;\n@@ -3026,7 +3031,7 @@ assemble_suffix (const char **suffix)\n         i = 0x40;\n         break;\n     }\n-  *frag_more(1) = (char)i;\n+  *frag_more (1) = (char)i;\n   switch (i)\n     {\n     case 0x40: inst_mode = INST_MODE_FORCED | INST_MODE_S | INST_MODE_IS; break;\n@@ -3252,7 +3257,7 @@ md_assemble (char *str)\n     {\n       if ((*p) && (!ISSPACE (*p)))\n         {\n-          if (*p != '.' || !(ins_ok & INS_EZ80) || !assemble_suffix(&p))\n+          if (*p != '.' || !(ins_ok & INS_EZ80) || !assemble_suffix (&p))\n             {\n               as_bad (_(\"syntax error\"));\n               goto end;\n@@ -3267,7 +3272,7 @@ md_assemble (char *str)\n       if (!insp || (insp->inss && !(insp->inss & ins_ok)))\n         {\n           as_bad (_(\"Unknown instruction '%s'\"), buf);\n-          *frag_more(1) = 0;\n+          *frag_more (1) = 0;\n         }\n       else\n \t{\n@@ -3466,21 +3471,21 @@ str_to_broken_float (bfd_boolean *signP, bfd_uint64_t *mantissaP, int *expP)\n   *signP = sign;\n   if (sign || *p == '+')\n     ++p;\n-  if (strncasecmp(p, \"NaN\", 3) == 0)\n+  if (strncasecmp (p, \"NaN\", 3) == 0)\n     {\n       *mantissaP = 0;\n       *expP = 0;\n       input_line_pointer = p + 3;\n       return 1;\n     }\n-  if (strncasecmp(p, \"inf\", 3) == 0)\n+  if (strncasecmp (p, \"inf\", 3) == 0)\n     {\n       *mantissaP = 1ull << 63;\n       *expP = EXP_MAX;\n       input_line_pointer = p + 3;\n       return 1;\n     }\n-  for (; ISDIGIT(*p); ++p)\n+  for (; ISDIGIT (*p); ++p)\n     {\n       if (mantissa >> 60)\n \t{\n@@ -3491,15 +3496,15 @@ str_to_broken_float (bfd_boolean *signP, bfd_uint64_t *mantissaP, int *expP)\n       mantissa = mantissa * 10 + (*p - '0');\n     }\n   /* skip non-significant digits */\n-  for (; ISDIGIT(*p); ++p)\n+  for (; ISDIGIT (*p); ++p)\n     exponent++;\n \n   if (*p == '.')\n     {\n       p++;\n-      if (!exponent) /* if no precission overflow */\n+      if (!exponent) /* If no precission overflow.  */\n \t{\n-\t  for (; ISDIGIT(*p); ++p, --exponent)\n+\t  for (; ISDIGIT (*p); ++p, --exponent)\n \t    {\n \t      if (mantissa >> 60)\n \t\t{\n@@ -3510,7 +3515,7 @@ str_to_broken_float (bfd_boolean *signP, bfd_uint64_t *mantissaP, int *expP)\n \t      mantissa = mantissa * 10 + (*p - '0');\n \t    }\n \t}\n-      for (; ISDIGIT(*p); ++p)\n+      for (; ISDIGIT (*p); ++p)\n \t;\n     }\n   if (*p == 'e' || *p == 'E')\n@@ -3521,14 +3526,14 @@ str_to_broken_float (bfd_boolean *signP, bfd_uint64_t *mantissaP, int *expP)\n       es = (*p == '-');\n       if (es || *p == '+')\n         p++;\n-      for (; ISDIGIT(*p); ++p)\n+      for (; ISDIGIT (*p); ++p)\n \t{\n \t  if (t < 100)\n \t    t = t * 10 + (*p - '0');\n \t}\n       exponent += (es) ? -t : t;\n     }\n-  if (ISALNUM(*p) || *p == '.')\n+  if (ISALNUM (*p) || *p == '.')\n     return 0;\n   input_line_pointer = p;\n   if (mantissa == 0)\n@@ -3540,10 +3545,8 @@ str_to_broken_float (bfd_boolean *signP, bfd_uint64_t *mantissaP, int *expP)\n   /* normalization */\n   for (; mantissa <= ~0ull/10; --exponent)\n     mantissa *= 10;\n-  /*\n-     now we have sign, mantissa, and signed decimal exponent\n-     need to recompute to binary exponent\n-  */\n+  /* Now we have sign, mantissa, and signed decimal exponent\n+     need to recompute to binary exponent.  */\n   for (i = 64; exponent > 0; --exponent)\n     {\n       /* be sure that no integer overflow */"
    },
    {
      "sha": "396549b8503c0ed41900d963dddf31c01efb8b15",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
      "patch": "@@ -1,3 +1,9 @@\n+2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>\n+\n+\tPR 25224\n+\t* z80-dis.c (ld_ii_ii): Use character constant when checking\n+\topcode byte value.\n+\n 2020-01-09  Jan Beulich  <jbeulich@suse.com>\n \n \t* i386-dis.c (SEP_Fixup): New."
    },
    {
      "sha": "8dc75987123e3230e18e1d6fdeeace9d58ae88e9",
      "filename": "opcodes/z80-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/opcodes/z80-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/40c75bc8b07abc5d5774ea1c439b69c96e7fd485/opcodes/z80-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/z80-dis.c?ref=40c75bc8b07abc5d5774ea1c439b69c96e7fd485",
      "patch": "@@ -82,7 +82,7 @@ fetch_data (struct buffer *buf, disassemble_info * info, int n)\n {\n   int r;\n \n-  if (buf->n_fetch + n > (int)sizeof(buf->data))\n+  if (buf->n_fetch + n > (int)sizeof (buf->data))\n     abort ();\n \n   r = info->read_memory_func (buf->base + buf->n_fetch,\n@@ -470,9 +470,9 @@ pref_ed (struct buffer *buf, disassemble_info *info,\n {\n   struct tab_elt *p;\n \n-  if (fetch_data(buf, info, 1))\n+  if (fetch_data (buf, info, 1))\n     {\n-      for (p = opc_ed; p->val != (buf->data[1] & p->mask) || !mach_inst(buf, p); ++p)\n+      for (p = opc_ed; p->val != (buf->data[1] & p->mask) || !mach_inst (buf, p); ++p)\n         ;\n       p->fp (buf, info, p->text);\n     }\n@@ -585,7 +585,7 @@ ld_r_d (struct buffer *buf, disassemble_info * info, const char *txt)\n }\n \n static int\n-ld_d_r(struct buffer *buf, disassemble_info * info, const char *txt)\n+ld_d_r (struct buffer *buf, disassemble_info * info, const char *txt)\n {\n   char mytxt[TXTSIZ];\n   signed char c;\n@@ -596,14 +596,14 @@ ld_d_r(struct buffer *buf, disassemble_info * info, const char *txt)\n }\n \n static int\n-ld_ii_ii(struct buffer *buf, disassemble_info * info, const char *txt)\n+ld_ii_ii (struct buffer *buf, disassemble_info * info, const char *txt)\n {\n   char mytxt[TXTSIZ];\n   signed char c;\n   int p;\n   static const char *ii[2] = { \"ix\", \"iy\" };\n \n-  p = (buf->data[buf->n_fetch - 2] == '\\xdd') ? 0 : 1;\n+  p = (buf->data[buf->n_fetch - 2] == (char) 0xdd) ? 0 : 1;\n   c = buf->data[buf->n_fetch - 1];\n   if ((c & 0x07) != 0x07)\n     p = 1 - p; /* 0 -> 1, 1 -> 0 */\n@@ -858,7 +858,7 @@ print_insn_z80_buf (struct buffer *buf, disassemble_info *info)\n   if (! fetch_data (buf, info, 1))\n     return -1;\n \n-  for (p = opc_main; p->val != (buf->data[0] & p->mask) || !mach_inst(buf, p); ++p)\n+  for (p = opc_main; p->val != (buf->data[0] & p->mask) || !mach_inst (buf, p); ++p)\n     ;\n   p->fp (buf, info, p->text);\n "
    }
  ]
}