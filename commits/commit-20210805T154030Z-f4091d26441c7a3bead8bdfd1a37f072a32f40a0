{
  "sha": "f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjQwOTFkMjY0NDFjN2EzYmVhZDhiZGZkMWEzN2YwNzJhMzJmNDBhMA==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-15T15:08:45Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:40:30Z"
    },
    "message": "Move piece_closure and its support to expr.c\n\nFollowing 5 patches series is trying to clean up the interface of the\nDWARF expression evaluator class (dwarf_expr_context).\n\nAfter merging all expression evaluators into one class, the next\nlogical step is to make a clean user interface for that class. To do\nthat, we first need to address the issue of class users writing and\nreading the internal data of the class directly.\n\nFixing the case of writing is simple, it makes sense for an evaluator\ninstance to be per architecture basis. Currently, the best separation\nseems to be per object file, so having that data (dwarf2_per_objfile)\nas a constructor argument makes sense. It also makes sense to get the\naddress size from that object file, but unfortunately that interface\ndoes not exist at the moment.\n\nLuckily, address size information is already available to the users\nthrough other means. As a result, the address size also needs to be a\nclass constructor argument, at least until a better interface for\nacquiring that information from an object file is implemented.\n\nThe rest of the user written data comes down to a context of an\nevaluated expression (compilation unit context, frame context and\npassed in buffer context) and a source type information that a result\nof evaluating expression is representing. So, it makes sense for all of\nthese to be arguments of an evaluation method.\n\nTo address the problem of reading the dwarf_expr_context class\ninternal data, we first need to understand why it is implemented that\nway?\n\nThis is actualy a question of which existing class can be used to\nrepresent both values and a location descriptions and why it is not\nused currently?\n\nThe answer is in a struct value class/structure, but the problem is\nthat before the evaluators were merged, only one evaluator had an\ninfrastructure to resolve composite and implicit pointer location\ndescriptions.\n\nAfter the merge, we are now able to use the struct value to represent\nany result of the expression evaluation. It also makes sense to move\nall infrastructure for those location descriptions to the expr.c file\nconsidering that that is the only place using that infrastructure.\n\nWhat we are left with in the end is a clean public interface of the\ndwarf_expr_context class containing:\n\n- constructor,\n- destructor,\n- push_address method and\n- eval_exp method.\n\nThe idea with this particular patch is to move piece_closure structure\nand the interface that handles it (lval_funcs) to expr.c file.\n\nWhile implicit pointer location descriptions are still not useful in\nthe CFI context (of the AMD's DWARF standard extensions), the composite\nlocation descriptions are certainly necessary to describe a results of\nspecific compiler optimizations.\n\nConsidering that a piece_closure structure is used to represent both,\nthere was no benefit in splitting them.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (struct piece_closure): Add from loc.c.\n\t(allocate_piece_closure): Add from loc.c.\n\t(bits_to_bytes): Add from loc.c.\n\t(rw_pieced_value): Add from loc.c.\n\t(read_pieced_value): Add from loc.c.\n\t(write_pieced_value): Add from loc.c.\n\t(check_pieced_synthetic_pointer): Add from loc.c.\n\t(indirect_pieced_value): Add from loc.c.\n\t(coerce_pieced_ref): Add from loc.c.\n\t(copy_pieced_value_closure): Add from loc.c.\n\t(free_pieced_value_closure): Add from loc.c.\n\t(sect_variable_value): Add from loc.c.\n\t* dwarf2/loc.c (sect_variable_value): Move to expr.c.\n\t(struct piece_closure): Move to expr.c.\n\t(allocate_piece_closure): Move to expr.c.\n\t(bits_to_bytes): Move to expr.c.\n\t(rw_pieced_value): Move to expr.c.\n\t(read_pieced_value): Move to expr.c.\n\t(write_pieced_value): Move to expr.c.\n\t(check_pieced_synthetic_pointer): Move to expr.c.\n\t(indirect_pieced_value): Move to expr.c.\n\t(coerce_pieced_ref): Move to expr.c.\n\t(copy_pieced_value_closure): Move to expr.c.\n\t(free_pieced_value_closure): Move to expr.c.",
    "tree": {
      "sha": "2396098716ede05f7779f4945fe7ccba77987fc0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2396098716ede05f7779f4945fe7ccba77987fc0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9e4ed8baa9eeebc71be88f863c52f81e42bed34",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f9e4ed8baa9eeebc71be88f863c52f81e42bed34"
    }
  ],
  "stats": {
    "total": 1194,
    "additions": 595,
    "deletions": 599
  },
  "files": [
    {
      "sha": "d0a74f1a586a3502271103ba21d3d04082940d45",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 571,
      "deletions": 0,
      "changes": 571,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
      "patch": "@@ -78,6 +78,15 @@ ensure_have_per_cu (dwarf2_per_cu_data *per_cu, const char* op_name)\n \t\t _(\"%s evaluation requires a compilation unit.\"), op_name);\n }\n \n+/* Return the number of bytes overlapping a contiguous chunk of N_BITS\n+   bits whose first bit is located at bit offset START.  */\n+\n+static size_t\n+bits_to_bytes (ULONGEST start, ULONGEST n_bits)\n+{\n+  return (start % HOST_CHAR_BIT + n_bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;\n+}\n+\n /* See expr.h.  */\n \n CORE_ADDR\n@@ -89,6 +98,568 @@ read_addr_from_reg (frame_info *frame, int reg)\n   return address_from_register (regnum, frame);\n }\n \n+struct piece_closure\n+{\n+  /* Reference count.  */\n+  int refc = 0;\n+\n+  /* The objfile from which this closure's expression came.  */\n+  dwarf2_per_objfile *per_objfile = nullptr;\n+\n+  /* The CU from which this closure's expression came.  */\n+  dwarf2_per_cu_data *per_cu = nullptr;\n+\n+  /* The pieces describing this variable.  */\n+  std::vector<dwarf_expr_piece> pieces;\n+\n+  /* Frame ID of frame to which a register value is relative, used\n+     only by DWARF_VALUE_REGISTER.  */\n+  struct frame_id frame_id;\n+};\n+\n+/* See expr.h.  */\n+\n+piece_closure *\n+allocate_piece_closure (dwarf2_per_cu_data *per_cu,\n+\t\t\tdwarf2_per_objfile *per_objfile,\n+\t\t\tstd::vector<dwarf_expr_piece> &&pieces,\n+\t\t\tframe_info *frame)\n+{\n+  piece_closure *c = new piece_closure;\n+\n+  c->refc = 1;\n+  /* We must capture this here due to sharing of DWARF state.  */\n+  c->per_objfile = per_objfile;\n+  c->per_cu = per_cu;\n+  c->pieces = std::move (pieces);\n+  if (frame == nullptr)\n+    c->frame_id = null_frame_id;\n+  else\n+    c->frame_id = get_frame_id (frame);\n+\n+  for (dwarf_expr_piece &piece : c->pieces)\n+    if (piece.location == DWARF_VALUE_STACK)\n+      value_incref (piece.v.value);\n+\n+  return c;\n+}\n+\n+/* Read or write a pieced value V.  If FROM != NULL, operate in \"write\n+   mode\": copy FROM into the pieces comprising V.  If FROM == NULL,\n+   operate in \"read mode\": fetch the contents of the (lazy) value V by\n+   composing it from its pieces.  */\n+\n+static void\n+rw_pieced_value (value *v, value *from)\n+{\n+  int i;\n+  LONGEST offset = 0, max_offset;\n+  gdb_byte *v_contents;\n+  const gdb_byte *from_contents;\n+  piece_closure *c\n+    = (piece_closure *) value_computed_closure (v);\n+  gdb::byte_vector buffer;\n+  bool bits_big_endian = type_byte_order (value_type (v)) == BFD_ENDIAN_BIG;\n+\n+  if (from != nullptr)\n+    {\n+      from_contents = value_contents (from);\n+      v_contents = nullptr;\n+    }\n+  else\n+    {\n+      if (value_type (v) != value_enclosing_type (v))\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"Should not be able to create a lazy value with \"\n+\t\t\t  \"an enclosing type\"));\n+      v_contents = value_contents_raw (v);\n+      from_contents = nullptr;\n+    }\n+\n+  ULONGEST bits_to_skip = 8 * value_offset (v);\n+  if (value_bitsize (v))\n+    {\n+      bits_to_skip += (8 * value_offset (value_parent (v))\n+\t\t       + value_bitpos (v));\n+      if (from != nullptr\n+\t  && (type_byte_order (value_type (from))\n+\t      == BFD_ENDIAN_BIG))\n+\t{\n+\t  /* Use the least significant bits of FROM.  */\n+\t  max_offset = 8 * TYPE_LENGTH (value_type (from));\n+\t  offset = max_offset - value_bitsize (v);\n+\t}\n+      else\n+\tmax_offset = value_bitsize (v);\n+    }\n+  else\n+    max_offset = 8 * TYPE_LENGTH (value_type (v));\n+\n+  /* Advance to the first non-skipped piece.  */\n+  for (i = 0; i < c->pieces.size () && bits_to_skip >= c->pieces[i].size; i++)\n+    bits_to_skip -= c->pieces[i].size;\n+\n+  for (; i < c->pieces.size () && offset < max_offset; i++)\n+    {\n+      dwarf_expr_piece *p = &c->pieces[i];\n+      size_t this_size_bits, this_size;\n+\n+      this_size_bits = p->size - bits_to_skip;\n+      if (this_size_bits > max_offset - offset)\n+\tthis_size_bits = max_offset - offset;\n+\n+      switch (p->location)\n+\t{\n+\tcase DWARF_VALUE_REGISTER:\n+\t  {\n+\t    frame_info *frame = frame_find_by_id (c->frame_id);\n+\t    gdbarch *arch = get_frame_arch (frame);\n+\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (arch, p->v.regno);\n+\t    ULONGEST reg_bits = 8 * register_size (arch, gdb_regnum);\n+\t    int optim, unavail;\n+\n+\t    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG\n+\t\t&& p->offset + p->size < reg_bits)\n+\t      {\n+\t\t/* Big-endian, and we want less than full size.  */\n+\t\tbits_to_skip += reg_bits - (p->offset + p->size);\n+\t      }\n+\t    else\n+\t      bits_to_skip += p->offset;\n+\n+\t    this_size = bits_to_bytes (bits_to_skip, this_size_bits);\n+\t    buffer.resize (this_size);\n+\n+\t    if (from == nullptr)\n+\t      {\n+\t\t/* Read mode.  */\n+\t\tif (!get_frame_register_bytes (frame, gdb_regnum,\n+\t\t\t\t\t       bits_to_skip / 8,\n+\t\t\t\t\t       buffer, &optim, &unavail))\n+\t\t  {\n+\t\t    if (optim)\n+\t\t      mark_value_bits_optimized_out (v, offset,\n+\t\t\t\t\t\t     this_size_bits);\n+\t\t    if (unavail)\n+\t\t      mark_value_bits_unavailable (v, offset,\n+\t\t\t\t\t\t   this_size_bits);\n+\t\t    break;\n+\t\t  }\n+\n+\t\tcopy_bitwise (v_contents, offset,\n+\t\t\t      buffer.data (), bits_to_skip % 8,\n+\t\t\t      this_size_bits, bits_big_endian);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Write mode.  */\n+\t\tif (bits_to_skip % 8 != 0 || this_size_bits % 8 != 0)\n+\t\t  {\n+\t\t    /* Data is copied non-byte-aligned into the register.\n+\t\t       Need some bits from original register value.  */\n+\t\t    get_frame_register_bytes (frame, gdb_regnum,\n+\t\t\t\t\t      bits_to_skip / 8,\n+\t\t\t\t\t      buffer, &optim, &unavail);\n+\t\t    if (optim)\n+\t\t      throw_error (OPTIMIZED_OUT_ERROR,\n+\t\t\t\t   _(\"Can't do read-modify-write to \"\n+\t\t\t\t     \"update bitfield; containing word \"\n+\t\t\t\t     \"has been optimized out\"));\n+\t\t    if (unavail)\n+\t\t      throw_error (NOT_AVAILABLE_ERROR,\n+\t\t\t\t   _(\"Can't do read-modify-write to \"\n+\t\t\t\t     \"update bitfield; containing word \"\n+\t\t\t\t     \"is unavailable\"));\n+\t\t  }\n+\n+\t\tcopy_bitwise (buffer.data (), bits_to_skip % 8,\n+\t\t\t      from_contents, offset,\n+\t\t\t      this_size_bits, bits_big_endian);\n+\t\tput_frame_register_bytes (frame, gdb_regnum,\n+\t\t\t\t\t  bits_to_skip / 8,\n+\t\t\t\t\t  buffer);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_MEMORY:\n+\t  {\n+\t    bits_to_skip += p->offset;\n+\n+\t    CORE_ADDR start_addr = p->v.mem.addr + bits_to_skip / 8;\n+\n+\t    if (bits_to_skip % 8 == 0 && this_size_bits % 8 == 0\n+\t\t&& offset % 8 == 0)\n+\t      {\n+\t\t/* Everything is byte-aligned; no buffer needed.  */\n+\t\tif (from != nullptr)\n+\t\t  write_memory_with_notification (start_addr,\n+\t\t\t\t\t\t  (from_contents\n+\t\t\t\t\t\t   + offset / 8),\n+\t\t\t\t\t\t  this_size_bits / 8);\n+\t\telse\n+\t\t  read_value_memory (v, offset,\n+\t\t\t\t     p->v.mem.in_stack_memory,\n+\t\t\t\t     p->v.mem.addr + bits_to_skip / 8,\n+\t\t\t\t     v_contents + offset / 8,\n+\t\t\t\t     this_size_bits / 8);\n+\t\tbreak;\n+\t      }\n+\n+\t    this_size = bits_to_bytes (bits_to_skip, this_size_bits);\n+\t    buffer.resize (this_size);\n+\n+\t    if (from == nullptr)\n+\t      {\n+\t\t/* Read mode.  */\n+\t\tread_value_memory (v, offset,\n+\t\t\t\t   p->v.mem.in_stack_memory,\n+\t\t\t\t   p->v.mem.addr + bits_to_skip / 8,\n+\t\t\t\t   buffer.data (), this_size);\n+\t\tcopy_bitwise (v_contents, offset,\n+\t\t\t      buffer.data (), bits_to_skip % 8,\n+\t\t\t      this_size_bits, bits_big_endian);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Write mode.  */\n+\t\tif (bits_to_skip % 8 != 0 || this_size_bits % 8 != 0)\n+\t\t  {\n+\t\t    if (this_size <= 8)\n+\t\t      {\n+\t\t\t/* Perform a single read for small sizes.  */\n+\t\t\tread_memory (start_addr, buffer.data (),\n+\t\t\t\t     this_size);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\t/* Only the first and last bytes can possibly have\n+\t\t\t   any bits reused.  */\n+\t\t\tread_memory (start_addr, buffer.data (), 1);\n+\t\t\tread_memory (start_addr + this_size - 1,\n+\t\t\t\t     &buffer[this_size - 1], 1);\n+\t\t      }\n+\t\t  }\n+\n+\t\tcopy_bitwise (buffer.data (), bits_to_skip % 8,\n+\t\t\t      from_contents, offset,\n+\t\t\t      this_size_bits, bits_big_endian);\n+\t\twrite_memory_with_notification (start_addr,\n+\t\t\t\t\t\tbuffer.data (),\n+\t\t\t\t\t\tthis_size);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_STACK:\n+\t  {\n+\t    if (from != nullptr)\n+\t      {\n+\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n+\t\tbreak;\n+\t      }\n+\n+\t    gdbarch *objfile_gdbarch = c->per_objfile->objfile->arch ();\n+\t    ULONGEST stack_value_size_bits\n+\t      = 8 * TYPE_LENGTH (value_type (p->v.value));\n+\n+\t    /* Use zeroes if piece reaches beyond stack value.  */\n+\t    if (p->offset + p->size > stack_value_size_bits)\n+\t      break;\n+\n+\t    /* Piece is anchored at least significant bit end.  */\n+\t    if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)\n+\t      bits_to_skip += stack_value_size_bits - p->offset - p->size;\n+\t    else\n+\t      bits_to_skip += p->offset;\n+\n+\t    copy_bitwise (v_contents, offset,\n+\t\t\t  value_contents_all (p->v.value),\n+\t\t\t  bits_to_skip,\n+\t\t\t  this_size_bits, bits_big_endian);\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_LITERAL:\n+\t  {\n+\t    if (from != nullptr)\n+\t      {\n+\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n+\t\tbreak;\n+\t      }\n+\n+\t    ULONGEST literal_size_bits = 8 * p->v.literal.length;\n+\t    size_t n = this_size_bits;\n+\n+\t    /* Cut off at the end of the implicit value.  */\n+\t    bits_to_skip += p->offset;\n+\t    if (bits_to_skip >= literal_size_bits)\n+\t      break;\n+\t    if (n > literal_size_bits - bits_to_skip)\n+\t      n = literal_size_bits - bits_to_skip;\n+\n+\t    copy_bitwise (v_contents, offset,\n+\t\t\t  p->v.literal.data, bits_to_skip,\n+\t\t\t  n, bits_big_endian);\n+\t  }\n+\t  break;\n+\n+\tcase DWARF_VALUE_IMPLICIT_POINTER:\n+\t    if (from != nullptr)\n+\t      {\n+\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n+\t\tbreak;\n+\t      }\n+\n+\t  /* These bits show up as zeros -- but do not cause the value to\n+\t     be considered optimized-out.  */\n+\t  break;\n+\n+\tcase DWARF_VALUE_OPTIMIZED_OUT:\n+\t  mark_value_bits_optimized_out (v, offset, this_size_bits);\n+\t  break;\n+\n+\tdefault:\n+\t  internal_error (__FILE__, __LINE__, _(\"invalid location type\"));\n+\t}\n+\n+      offset += this_size_bits;\n+      bits_to_skip = 0;\n+    }\n+}\n+\n+static void\n+read_pieced_value (value *v)\n+{\n+  rw_pieced_value (v, nullptr);\n+}\n+\n+static void\n+write_pieced_value (value *to, value *from)\n+{\n+  rw_pieced_value (to, from);\n+}\n+\n+/* An implementation of an lval_funcs method to see whether a value is\n+   a synthetic pointer.  */\n+\n+static int\n+check_pieced_synthetic_pointer (const value *value, LONGEST bit_offset,\n+\t\t\t\tint bit_length)\n+{\n+  piece_closure *c = (piece_closure *) value_computed_closure (value);\n+  int i;\n+\n+  bit_offset += 8 * value_offset (value);\n+  if (value_bitsize (value))\n+    bit_offset += value_bitpos (value);\n+\n+  for (i = 0; i < c->pieces.size () && bit_length > 0; i++)\n+    {\n+      dwarf_expr_piece *p = &c->pieces[i];\n+      size_t this_size_bits = p->size;\n+\n+      if (bit_offset > 0)\n+\t{\n+\t  if (bit_offset >= this_size_bits)\n+\t    {\n+\t      bit_offset -= this_size_bits;\n+\t      continue;\n+\t    }\n+\n+\t  bit_length -= this_size_bits - bit_offset;\n+\t  bit_offset = 0;\n+\t}\n+      else\n+\tbit_length -= this_size_bits;\n+\n+      if (p->location != DWARF_VALUE_IMPLICIT_POINTER)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* An implementation of an lval_funcs method to indirect through a\n+   pointer.  This handles the synthetic pointer case when needed.  */\n+\n+static value *\n+indirect_pieced_value (value *value)\n+{\n+  piece_closure *c\n+    = (piece_closure *) value_computed_closure (value);\n+  int i;\n+  dwarf_expr_piece *piece = NULL;\n+\n+  struct type *type = check_typedef (value_type (value));\n+  if (type->code () != TYPE_CODE_PTR)\n+    return NULL;\n+\n+  int bit_length = 8 * TYPE_LENGTH (type);\n+  LONGEST bit_offset = 8 * value_offset (value);\n+  if (value_bitsize (value))\n+    bit_offset += value_bitpos (value);\n+\n+  for (i = 0; i < c->pieces.size () && bit_length > 0; i++)\n+    {\n+      dwarf_expr_piece *p = &c->pieces[i];\n+      size_t this_size_bits = p->size;\n+\n+      if (bit_offset > 0)\n+\t{\n+\t  if (bit_offset >= this_size_bits)\n+\t    {\n+\t      bit_offset -= this_size_bits;\n+\t      continue;\n+\t    }\n+\n+\t  bit_length -= this_size_bits - bit_offset;\n+\t  bit_offset = 0;\n+\t}\n+      else\n+\tbit_length -= this_size_bits;\n+\n+      if (p->location != DWARF_VALUE_IMPLICIT_POINTER)\n+\treturn NULL;\n+\n+      if (bit_length != 0)\n+\terror (_(\"Invalid use of DW_OP_implicit_pointer\"));\n+\n+      piece = p;\n+      break;\n+    }\n+\n+  gdb_assert (piece != NULL && c->per_cu != nullptr);\n+  frame_info *frame = get_selected_frame (_(\"No frame selected.\"));\n+\n+  /* This is an offset requested by GDB, such as value subscripts.\n+     However, due to how synthetic pointers are implemented, this is\n+     always presented to us as a pointer type.  This means we have to\n+     sign-extend it manually as appropriate.  Use raw\n+     extract_signed_integer directly rather than value_as_address and\n+     sign extend afterwards on architectures that would need it\n+     (mostly everywhere except MIPS, which has signed addresses) as\n+     the later would go through gdbarch_pointer_to_address and thus\n+     return a CORE_ADDR with high bits set on architectures that\n+     encode address spaces and other things in CORE_ADDR.  */\n+  bfd_endian byte_order = gdbarch_byte_order (get_frame_arch (frame));\n+  LONGEST byte_offset\n+    = extract_signed_integer (value_contents (value),\n+\t\t\t      TYPE_LENGTH (type), byte_order);\n+  byte_offset += piece->v.ptr.offset;\n+\n+  return indirect_synthetic_pointer (piece->v.ptr.die_sect_off,\n+\t\t\t\t     byte_offset, c->per_cu,\n+\t\t\t\t     c->per_objfile, frame, type);\n+}\n+\n+/* Implementation of the coerce_ref method of lval_funcs for synthetic C++\n+   references.  */\n+\n+static value *\n+coerce_pieced_ref (const value *value)\n+{\n+  struct type *type = check_typedef (value_type (value));\n+\n+  if (value_bits_synthetic_pointer (value, value_embedded_offset (value),\n+\t\t\t\t    TARGET_CHAR_BIT * TYPE_LENGTH (type)))\n+    {\n+      const piece_closure *closure\n+\t= (piece_closure *) value_computed_closure (value);\n+      frame_info *frame\n+\t= get_selected_frame (_(\"No frame selected.\"));\n+\n+      /* gdb represents synthetic pointers as pieced values with a single\n+\t piece.  */\n+      gdb_assert (closure != NULL);\n+      gdb_assert (closure->pieces.size () == 1);\n+\n+      return indirect_synthetic_pointer\n+\t(closure->pieces[0].v.ptr.die_sect_off,\n+\t closure->pieces[0].v.ptr.offset,\n+\t closure->per_cu, closure->per_objfile, frame, type);\n+    }\n+  else\n+    {\n+      /* Else: not a synthetic reference; do nothing.  */\n+      return NULL;\n+    }\n+}\n+\n+static void *\n+copy_pieced_value_closure (const value *v)\n+{\n+  piece_closure *c = (piece_closure *) value_computed_closure (v);\n+\n+  ++c->refc;\n+  return c;\n+}\n+\n+static void\n+free_pieced_value_closure (value *v)\n+{\n+  piece_closure *c = (piece_closure *) value_computed_closure (v);\n+\n+  --c->refc;\n+  if (c->refc == 0)\n+    {\n+      for (dwarf_expr_piece &p : c->pieces)\n+\tif (p.location == DWARF_VALUE_STACK)\n+\t  value_decref (p.v.value);\n+\n+      delete c;\n+    }\n+}\n+\n+/* Functions for accessing a variable described by DW_OP_piece.  */\n+const struct lval_funcs pieced_value_funcs = {\n+  read_pieced_value,\n+  write_pieced_value,\n+  indirect_pieced_value,\n+  coerce_pieced_ref,\n+  check_pieced_synthetic_pointer,\n+  copy_pieced_value_closure,\n+  free_pieced_value_closure\n+};\n+\n+/* Given context CTX, section offset SECT_OFF, and compilation unit\n+   data PER_CU, execute the \"variable value\" operation on the DIE\n+   found at SECT_OFF.  */\n+\n+static value *\n+sect_variable_value (sect_offset sect_off,\n+\t\t     dwarf2_per_cu_data *per_cu,\n+\t\t     dwarf2_per_objfile *per_objfile)\n+{\n+  const char *var_name = nullptr;\n+  struct type *die_type\n+    = dwarf2_fetch_die_type_sect_off (sect_off, per_cu, per_objfile,\n+\t\t\t\t      &var_name);\n+\n+  if (die_type == NULL)\n+    error (_(\"Bad DW_OP_GNU_variable_value DIE.\"));\n+\n+  /* Note: Things still work when the following test is removed.  This\n+     test and error is here to conform to the proposed specification.  */\n+  if (die_type->code () != TYPE_CODE_INT\n+      && die_type->code () != TYPE_CODE_ENUM\n+      && die_type->code () != TYPE_CODE_RANGE\n+      && die_type->code () != TYPE_CODE_PTR)\n+    error (_(\"Type of DW_OP_GNU_variable_value DIE must be an integer or pointer.\"));\n+\n+  if (var_name != nullptr)\n+    {\n+      value *result = compute_var_value (var_name);\n+      if (result != nullptr)\n+\treturn result;\n+    }\n+\n+  struct type *type = lookup_pointer_type (die_type);\n+  frame_info *frame = get_selected_frame (_(\"No frame selected.\"));\n+  return indirect_synthetic_pointer (sect_off, 0, per_cu, per_objfile, frame,\n+\t\t\t\t     type, true);\n+}\n+\n /* Return the type used for DWARF operations where the type is\n    unspecified in the DWARF spec.  Only certain sizes are\n    supported.  */"
    },
    {
      "sha": "c9ba2a6325d127edd2f9b2bd677e77c673b05ff0",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
      "patch": "@@ -26,6 +26,7 @@\n #include \"gdbtypes.h\"\n \n struct dwarf2_per_objfile;\n+struct piece_closure;\n \n /* The location of a value.  */\n enum dwarf_value_location\n@@ -300,4 +301,13 @@ extern const gdb_byte *safe_read_sleb128 (const gdb_byte *buf,\n extern const gdb_byte *safe_skip_leb128 (const gdb_byte *buf,\n \t\t\t\t\t const gdb_byte *buf_end);\n \n+extern const struct lval_funcs pieced_value_funcs;\n+\n+/* Allocate a closure for a value formed from separately-described\n+   PIECES.  */\n+\n+piece_closure *allocate_piece_closure\n+  (dwarf2_per_cu_data *per_cu, dwarf2_per_objfile *per_objfile,\n+   std::vector<dwarf_expr_piece> &&pieces, frame_info *frame);\n+\n #endif /* dwarf2expr.h */"
    },
    {
      "sha": "4e1316dcbd4afaa932ffe8172513c59826317e27",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 4,
      "deletions": 593,
      "changes": 597,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
      "patch": "@@ -52,13 +52,6 @@ static struct value *dwarf2_evaluate_loc_desc_full\n    size_t size, dwarf2_per_cu_data *per_cu, dwarf2_per_objfile *per_objfile,\n    struct type *subobj_type, LONGEST subobj_byte_offset);\n \n-static struct value *indirect_synthetic_pointer\n-  (sect_offset die, LONGEST byte_offset,\n-   dwarf2_per_cu_data *per_cu,\n-   dwarf2_per_objfile *per_objfile,\n-   struct frame_info *frame,\n-   struct type *type, bool resolve_abstract_p = false);\n-\n /* Until these have formal names, we define these here.\n    ref: http://gcc.gnu.org/wiki/DebugFission\n    Each entry in .debug_loc.dwo begins with a byte that describes the entry,\n@@ -611,10 +604,9 @@ func_get_frame_base_dwarf_block (struct symbol *framefunc, CORE_ADDR pc,\n \t   framefunc->natural_name ());\n }\n \n-/* A helper function to find the definition of NAME and compute its\n-   value.  Returns nullptr if the name is not found.  */\n+/* See loc.h.  */\n \n-static value *\n+value *\n compute_var_value (const char *name)\n {\n   struct block_symbol sym = lookup_symbol (name, nullptr, VAR_DOMAIN,\n@@ -624,42 +616,6 @@ compute_var_value (const char *name)\n   return nullptr;\n }\n \n-/* See loc.h.  */\n-\n-struct value *\n-sect_variable_value (sect_offset sect_off,\n-\t\t     dwarf2_per_cu_data *per_cu,\n-\t\t     dwarf2_per_objfile *per_objfile)\n-{\n-  const char *var_name = nullptr;\n-  struct type *die_type\n-    = dwarf2_fetch_die_type_sect_off (sect_off, per_cu, per_objfile,\n-\t\t\t\t      &var_name);\n-\n-  if (die_type == NULL)\n-    error (_(\"Bad DW_OP_GNU_variable_value DIE.\"));\n-\n-  /* Note: Things still work when the following test is removed.  This\n-     test and error is here to conform to the proposed specification.  */\n-  if (die_type->code () != TYPE_CODE_INT\n-      && die_type->code () != TYPE_CODE_ENUM\n-      && die_type->code () != TYPE_CODE_RANGE\n-      && die_type->code () != TYPE_CODE_PTR)\n-    error (_(\"Type of DW_OP_GNU_variable_value DIE must be an integer or pointer.\"));\n-\n-  if (var_name != nullptr)\n-    {\n-      value *result = compute_var_value (var_name);\n-      if (result != nullptr)\n-\treturn result;\n-    }\n-\n-  struct type *type = lookup_pointer_type (die_type);\n-  struct frame_info *frame = get_selected_frame (_(\"No frame selected.\"));\n-  return indirect_synthetic_pointer (sect_off, 0, per_cu, per_objfile, frame,\n-\t\t\t\t     type, true);\n-}\n-\n /* See dwarf2loc.h.  */\n \n unsigned int entry_values_debug = 0;\n@@ -1419,403 +1375,6 @@ value_of_dwarf_block_entry (struct type *type, struct frame_info *frame,\n \t\t \"only for single DW_OP_reg* or for DW_OP_fbreg(*)\"));\n }\n \n-struct piece_closure\n-{\n-  /* Reference count.  */\n-  int refc = 0;\n-\n-  /* The objfile from which this closure's expression came.  */\n-  dwarf2_per_objfile *per_objfile = nullptr;\n-\n-  /* The CU from which this closure's expression came.  */\n-  struct dwarf2_per_cu_data *per_cu = NULL;\n-\n-  /* The pieces describing this variable.  */\n-  std::vector<dwarf_expr_piece> pieces;\n-\n-  /* Frame ID of frame to which a register value is relative, used\n-     only by DWARF_VALUE_REGISTER.  */\n-  struct frame_id frame_id;\n-};\n-\n-/* Allocate a closure for a value formed from separately-described\n-   PIECES.  */\n-\n-static struct piece_closure *\n-allocate_piece_closure (dwarf2_per_cu_data *per_cu,\n-\t\t\tdwarf2_per_objfile *per_objfile,\n-\t\t\tstd::vector<dwarf_expr_piece> &&pieces,\n-\t\t\tstruct frame_info *frame)\n-{\n-  struct piece_closure *c = new piece_closure;\n-\n-  c->refc = 1;\n-  /* We must capture this here due to sharing of DWARF state.  */\n-  c->per_objfile = per_objfile;\n-  c->per_cu = per_cu;\n-  c->pieces = std::move (pieces);\n-  if (frame == NULL)\n-    c->frame_id = null_frame_id;\n-  else\n-    c->frame_id = get_frame_id (frame);\n-\n-  for (dwarf_expr_piece &piece : c->pieces)\n-    if (piece.location == DWARF_VALUE_STACK)\n-      value_incref (piece.v.value);\n-\n-  return c;\n-}\n-\n-/* Return the number of bytes overlapping a contiguous chunk of N_BITS\n-   bits whose first bit is located at bit offset START.  */\n-\n-static size_t\n-bits_to_bytes (ULONGEST start, ULONGEST n_bits)\n-{\n-  return (start % 8 + n_bits + 7) / 8;\n-}\n-\n-/* Read or write a pieced value V.  If FROM != NULL, operate in \"write\n-   mode\": copy FROM into the pieces comprising V.  If FROM == NULL,\n-   operate in \"read mode\": fetch the contents of the (lazy) value V by\n-   composing it from its pieces.  */\n-\n-static void\n-rw_pieced_value (struct value *v, struct value *from)\n-{\n-  int i;\n-  LONGEST offset = 0, max_offset;\n-  ULONGEST bits_to_skip;\n-  gdb_byte *v_contents;\n-  const gdb_byte *from_contents;\n-  struct piece_closure *c\n-    = (struct piece_closure *) value_computed_closure (v);\n-  gdb::byte_vector buffer;\n-  bool bits_big_endian = type_byte_order (value_type (v)) == BFD_ENDIAN_BIG;\n-\n-  if (from != NULL)\n-    {\n-      from_contents = value_contents (from);\n-      v_contents = NULL;\n-    }\n-  else\n-    {\n-      if (value_type (v) != value_enclosing_type (v))\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"Should not be able to create a lazy value with \"\n-\t\t\t  \"an enclosing type\"));\n-      v_contents = value_contents_raw (v);\n-      from_contents = NULL;\n-    }\n-\n-  bits_to_skip = 8 * value_offset (v);\n-  if (value_bitsize (v))\n-    {\n-      bits_to_skip += (8 * value_offset (value_parent (v))\n-\t\t       + value_bitpos (v));\n-      if (from != NULL\n-\t  && (type_byte_order (value_type (from))\n-\t      == BFD_ENDIAN_BIG))\n-\t{\n-\t  /* Use the least significant bits of FROM.  */\n-\t  max_offset = 8 * TYPE_LENGTH (value_type (from));\n-\t  offset = max_offset - value_bitsize (v);\n-\t}\n-      else\n-\tmax_offset = value_bitsize (v);\n-    }\n-  else\n-    max_offset = 8 * TYPE_LENGTH (value_type (v));\n-\n-  /* Advance to the first non-skipped piece.  */\n-  for (i = 0; i < c->pieces.size () && bits_to_skip >= c->pieces[i].size; i++)\n-    bits_to_skip -= c->pieces[i].size;\n-\n-  for (; i < c->pieces.size () && offset < max_offset; i++)\n-    {\n-      struct dwarf_expr_piece *p = &c->pieces[i];\n-      size_t this_size_bits, this_size;\n-\n-      this_size_bits = p->size - bits_to_skip;\n-      if (this_size_bits > max_offset - offset)\n-\tthis_size_bits = max_offset - offset;\n-\n-      switch (p->location)\n-\t{\n-\tcase DWARF_VALUE_REGISTER:\n-\t  {\n-\t    struct frame_info *frame = frame_find_by_id (c->frame_id);\n-\t    struct gdbarch *arch = get_frame_arch (frame);\n-\t    int gdb_regnum = dwarf_reg_to_regnum_or_error (arch, p->v.regno);\n-\t    ULONGEST reg_bits = 8 * register_size (arch, gdb_regnum);\n-\t    int optim, unavail;\n-\n-\t    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG\n-\t\t&& p->offset + p->size < reg_bits)\n-\t      {\n-\t\t/* Big-endian, and we want less than full size.  */\n-\t\tbits_to_skip += reg_bits - (p->offset + p->size);\n-\t      }\n-\t    else\n-\t      bits_to_skip += p->offset;\n-\n-\t    this_size = bits_to_bytes (bits_to_skip, this_size_bits);\n-\t    buffer.resize (this_size);\n-\n-\t    if (from == NULL)\n-\t      {\n-\t\t/* Read mode.  */\n-\t\tif (!get_frame_register_bytes (frame, gdb_regnum,\n-\t\t\t\t\t       bits_to_skip / 8,\n-\t\t\t\t\t       buffer,\n-\t\t\t\t\t       &optim, &unavail))\n-\t\t  {\n-\t\t    if (optim)\n-\t\t      mark_value_bits_optimized_out (v, offset,\n-\t\t\t\t\t\t     this_size_bits);\n-\t\t    if (unavail)\n-\t\t      mark_value_bits_unavailable (v, offset,\n-\t\t\t\t\t\t   this_size_bits);\n-\t\t    break;\n-\t\t  }\n-\n-\t\tcopy_bitwise (v_contents, offset,\n-\t\t\t      buffer.data (), bits_to_skip % 8,\n-\t\t\t      this_size_bits, bits_big_endian);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Write mode.  */\n-\t\tif (bits_to_skip % 8 != 0 || this_size_bits % 8 != 0)\n-\t\t  {\n-\t\t    /* Data is copied non-byte-aligned into the register.\n-\t\t       Need some bits from original register value.  */\n-\t\t    get_frame_register_bytes (frame, gdb_regnum,\n-\t\t\t\t\t      bits_to_skip / 8,\n-\t\t\t\t\t      buffer,\n-\t\t\t\t\t      &optim, &unavail);\n-\t\t    if (optim)\n-\t\t      throw_error (OPTIMIZED_OUT_ERROR,\n-\t\t\t\t   _(\"Can't do read-modify-write to \"\n-\t\t\t\t     \"update bitfield; containing word \"\n-\t\t\t\t     \"has been optimized out\"));\n-\t\t    if (unavail)\n-\t\t      throw_error (NOT_AVAILABLE_ERROR,\n-\t\t\t\t   _(\"Can't do read-modify-write to \"\n-\t\t\t\t     \"update bitfield; containing word \"\n-\t\t\t\t     \"is unavailable\"));\n-\t\t  }\n-\n-\t\tcopy_bitwise (buffer.data (), bits_to_skip % 8,\n-\t\t\t      from_contents, offset,\n-\t\t\t      this_size_bits, bits_big_endian);\n-\t\tput_frame_register_bytes (frame, gdb_regnum,\n-\t\t\t\t\t  bits_to_skip / 8,\n-\t\t\t\t\t  buffer);\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_MEMORY:\n-\t  {\n-\t    bits_to_skip += p->offset;\n-\n-\t    CORE_ADDR start_addr = p->v.mem.addr + bits_to_skip / 8;\n-\n-\t    if (bits_to_skip % 8 == 0 && this_size_bits % 8 == 0\n-\t\t&& offset % 8 == 0)\n-\t      {\n-\t\t/* Everything is byte-aligned; no buffer needed.  */\n-\t\tif (from != NULL)\n-\t\t  write_memory_with_notification (start_addr,\n-\t\t\t\t\t\t  (from_contents\n-\t\t\t\t\t\t   + offset / 8),\n-\t\t\t\t\t\t  this_size_bits / 8);\n-\t\telse\n-\t\t  read_value_memory (v, offset,\n-\t\t\t\t     p->v.mem.in_stack_memory,\n-\t\t\t\t     p->v.mem.addr + bits_to_skip / 8,\n-\t\t\t\t     v_contents + offset / 8,\n-\t\t\t\t     this_size_bits / 8);\n-\t\tbreak;\n-\t      }\n-\n-\t    this_size = bits_to_bytes (bits_to_skip, this_size_bits);\n-\t    buffer.resize (this_size);\n-\n-\t    if (from == NULL)\n-\t      {\n-\t\t/* Read mode.  */\n-\t\tread_value_memory (v, offset,\n-\t\t\t\t   p->v.mem.in_stack_memory,\n-\t\t\t\t   p->v.mem.addr + bits_to_skip / 8,\n-\t\t\t\t   buffer.data (), this_size);\n-\t\tcopy_bitwise (v_contents, offset,\n-\t\t\t      buffer.data (), bits_to_skip % 8,\n-\t\t\t      this_size_bits, bits_big_endian);\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Write mode.  */\n-\t\tif (bits_to_skip % 8 != 0 || this_size_bits % 8 != 0)\n-\t\t  {\n-\t\t    if (this_size <= 8)\n-\t\t      {\n-\t\t\t/* Perform a single read for small sizes.  */\n-\t\t\tread_memory (start_addr, buffer.data (),\n-\t\t\t\t     this_size);\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\t/* Only the first and last bytes can possibly have\n-\t\t\t   any bits reused.  */\n-\t\t\tread_memory (start_addr, buffer.data (), 1);\n-\t\t\tread_memory (start_addr + this_size - 1,\n-\t\t\t\t     &buffer[this_size - 1], 1);\n-\t\t      }\n-\t\t  }\n-\n-\t\tcopy_bitwise (buffer.data (), bits_to_skip % 8,\n-\t\t\t      from_contents, offset,\n-\t\t\t      this_size_bits, bits_big_endian);\n-\t\twrite_memory_with_notification (start_addr,\n-\t\t\t\t\t\tbuffer.data (),\n-\t\t\t\t\t\tthis_size);\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_STACK:\n-\t  {\n-\t    if (from != NULL)\n-\t      {\n-\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n-\t\tbreak;\n-\t      }\n-\n-\t    gdbarch *objfile_gdbarch = c->per_objfile->objfile->arch ();\n-\t    ULONGEST stack_value_size_bits\n-\t      = 8 * TYPE_LENGTH (value_type (p->v.value));\n-\n-\t    /* Use zeroes if piece reaches beyond stack value.  */\n-\t    if (p->offset + p->size > stack_value_size_bits)\n-\t      break;\n-\n-\t    /* Piece is anchored at least significant bit end.  */\n-\t    if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)\n-\t      bits_to_skip += stack_value_size_bits - p->offset - p->size;\n-\t    else\n-\t      bits_to_skip += p->offset;\n-\n-\t    copy_bitwise (v_contents, offset,\n-\t\t\t  value_contents_all (p->v.value),\n-\t\t\t  bits_to_skip,\n-\t\t\t  this_size_bits, bits_big_endian);\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_LITERAL:\n-\t  {\n-\t    if (from != NULL)\n-\t      {\n-\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n-\t\tbreak;\n-\t      }\n-\n-\t    ULONGEST literal_size_bits = 8 * p->v.literal.length;\n-\t    size_t n = this_size_bits;\n-\n-\t    /* Cut off at the end of the implicit value.  */\n-\t    bits_to_skip += p->offset;\n-\t    if (bits_to_skip >= literal_size_bits)\n-\t      break;\n-\t    if (n > literal_size_bits - bits_to_skip)\n-\t      n = literal_size_bits - bits_to_skip;\n-\n-\t    copy_bitwise (v_contents, offset,\n-\t\t\t  p->v.literal.data, bits_to_skip,\n-\t\t\t  n, bits_big_endian);\n-\t  }\n-\t  break;\n-\n-\tcase DWARF_VALUE_IMPLICIT_POINTER:\n-\t    if (from != NULL)\n-\t      {\n-\t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n-\t\tbreak;\n-\t      }\n-\n-\t  /* These bits show up as zeros -- but do not cause the value to\n-\t     be considered optimized-out.  */\n-\t  break;\n-\n-\tcase DWARF_VALUE_OPTIMIZED_OUT:\n-\t  mark_value_bits_optimized_out (v, offset, this_size_bits);\n-\t  break;\n-\n-\tdefault:\n-\t  internal_error (__FILE__, __LINE__, _(\"invalid location type\"));\n-\t}\n-\n-      offset += this_size_bits;\n-      bits_to_skip = 0;\n-    }\n-}\n-\n-\n-static void\n-read_pieced_value (struct value *v)\n-{\n-  rw_pieced_value (v, NULL);\n-}\n-\n-static void\n-write_pieced_value (struct value *to, struct value *from)\n-{\n-  rw_pieced_value (to, from);\n-}\n-\n-/* An implementation of an lval_funcs method to see whether a value is\n-   a synthetic pointer.  */\n-\n-static int\n-check_pieced_synthetic_pointer (const struct value *value, LONGEST bit_offset,\n-\t\t\t\tint bit_length)\n-{\n-  struct piece_closure *c\n-    = (struct piece_closure *) value_computed_closure (value);\n-  int i;\n-\n-  bit_offset += 8 * value_offset (value);\n-  if (value_bitsize (value))\n-    bit_offset += value_bitpos (value);\n-\n-  for (i = 0; i < c->pieces.size () && bit_length > 0; i++)\n-    {\n-      struct dwarf_expr_piece *p = &c->pieces[i];\n-      size_t this_size_bits = p->size;\n-\n-      if (bit_offset > 0)\n-\t{\n-\t  if (bit_offset >= this_size_bits)\n-\t    {\n-\t      bit_offset -= this_size_bits;\n-\t      continue;\n-\t    }\n-\n-\t  bit_length -= this_size_bits - bit_offset;\n-\t  bit_offset = 0;\n-\t}\n-      else\n-\tbit_length -= this_size_bits;\n-\n-      if (p->location != DWARF_VALUE_IMPLICIT_POINTER)\n-\treturn 0;\n-    }\n-\n-  return 1;\n-}\n-\n /* Fetch a DW_AT_const_value through a synthetic pointer.  */\n \n static struct value *\n@@ -1849,9 +1408,9 @@ fetch_const_value_from_synthetic_pointer (sect_offset die, LONGEST byte_offset,\n   return result;\n }\n \n-/* Fetch the value pointed to by a synthetic pointer.  */\n+/* See loc.h.  */\n \n-static struct value *\n+struct value *\n indirect_synthetic_pointer (sect_offset die, LONGEST byte_offset,\n \t\t\t    dwarf2_per_cu_data *per_cu,\n \t\t\t    dwarf2_per_objfile *per_objfile,\n@@ -1888,154 +1447,6 @@ indirect_synthetic_pointer (sect_offset die, LONGEST byte_offset,\n \t\t\t\t\t\t     per_objfile, type);\n }\n \n-/* An implementation of an lval_funcs method to indirect through a\n-   pointer.  This handles the synthetic pointer case when needed.  */\n-\n-static struct value *\n-indirect_pieced_value (struct value *value)\n-{\n-  struct piece_closure *c\n-    = (struct piece_closure *) value_computed_closure (value);\n-  struct type *type;\n-  struct frame_info *frame;\n-  int i, bit_length;\n-  LONGEST bit_offset;\n-  struct dwarf_expr_piece *piece = NULL;\n-  LONGEST byte_offset;\n-  enum bfd_endian byte_order;\n-\n-  type = check_typedef (value_type (value));\n-  if (type->code () != TYPE_CODE_PTR)\n-    return NULL;\n-\n-  bit_length = 8 * TYPE_LENGTH (type);\n-  bit_offset = 8 * value_offset (value);\n-  if (value_bitsize (value))\n-    bit_offset += value_bitpos (value);\n-\n-  for (i = 0; i < c->pieces.size () && bit_length > 0; i++)\n-    {\n-      struct dwarf_expr_piece *p = &c->pieces[i];\n-      size_t this_size_bits = p->size;\n-\n-      if (bit_offset > 0)\n-\t{\n-\t  if (bit_offset >= this_size_bits)\n-\t    {\n-\t      bit_offset -= this_size_bits;\n-\t      continue;\n-\t    }\n-\n-\t  bit_length -= this_size_bits - bit_offset;\n-\t  bit_offset = 0;\n-\t}\n-      else\n-\tbit_length -= this_size_bits;\n-\n-      if (p->location != DWARF_VALUE_IMPLICIT_POINTER)\n-\treturn NULL;\n-\n-      if (bit_length != 0)\n-\terror (_(\"Invalid use of DW_OP_implicit_pointer\"));\n-\n-      piece = p;\n-      break;\n-    }\n-\n-  gdb_assert (piece != NULL);\n-  frame = get_selected_frame (_(\"No frame selected.\"));\n-\n-  /* This is an offset requested by GDB, such as value subscripts.\n-     However, due to how synthetic pointers are implemented, this is\n-     always presented to us as a pointer type.  This means we have to\n-     sign-extend it manually as appropriate.  Use raw\n-     extract_signed_integer directly rather than value_as_address and\n-     sign extend afterwards on architectures that would need it\n-     (mostly everywhere except MIPS, which has signed addresses) as\n-     the later would go through gdbarch_pointer_to_address and thus\n-     return a CORE_ADDR with high bits set on architectures that\n-     encode address spaces and other things in CORE_ADDR.  */\n-  byte_order = gdbarch_byte_order (get_frame_arch (frame));\n-  byte_offset = extract_signed_integer (value_contents (value),\n-\t\t\t\t\tTYPE_LENGTH (type), byte_order);\n-  byte_offset += piece->v.ptr.offset;\n-\n-  return indirect_synthetic_pointer (piece->v.ptr.die_sect_off,\n-\t\t\t\t     byte_offset, c->per_cu,\n-\t\t\t\t     c->per_objfile, frame, type);\n-}\n-\n-/* Implementation of the coerce_ref method of lval_funcs for synthetic C++\n-   references.  */\n-\n-static struct value *\n-coerce_pieced_ref (const struct value *value)\n-{\n-  struct type *type = check_typedef (value_type (value));\n-\n-  if (value_bits_synthetic_pointer (value, value_embedded_offset (value),\n-\t\t\t\t    TARGET_CHAR_BIT * TYPE_LENGTH (type)))\n-    {\n-      const struct piece_closure *closure\n-\t= (struct piece_closure *) value_computed_closure (value);\n-      struct frame_info *frame\n-\t= get_selected_frame (_(\"No frame selected.\"));\n-\n-      /* gdb represents synthetic pointers as pieced values with a single\n-\t piece.  */\n-      gdb_assert (closure != NULL);\n-      gdb_assert (closure->pieces.size () == 1);\n-\n-      return indirect_synthetic_pointer\n-\t(closure->pieces[0].v.ptr.die_sect_off,\n-\t closure->pieces[0].v.ptr.offset,\n-\t closure->per_cu, closure->per_objfile, frame, type);\n-    }\n-  else\n-    {\n-      /* Else: not a synthetic reference; do nothing.  */\n-      return NULL;\n-    }\n-}\n-\n-static void *\n-copy_pieced_value_closure (const struct value *v)\n-{\n-  struct piece_closure *c\n-    = (struct piece_closure *) value_computed_closure (v);\n-  \n-  ++c->refc;\n-  return c;\n-}\n-\n-static void\n-free_pieced_value_closure (struct value *v)\n-{\n-  struct piece_closure *c\n-    = (struct piece_closure *) value_computed_closure (v);\n-\n-  --c->refc;\n-  if (c->refc == 0)\n-    {\n-      for (dwarf_expr_piece &p : c->pieces)\n-\tif (p.location == DWARF_VALUE_STACK)\n-\t  value_decref (p.v.value);\n-\n-      delete c;\n-    }\n-}\n-\n-/* Functions for accessing a variable described by DW_OP_piece.  */\n-static const struct lval_funcs pieced_value_funcs = {\n-  read_pieced_value,\n-  write_pieced_value,\n-  indirect_pieced_value,\n-  coerce_pieced_ref,\n-  check_pieced_synthetic_pointer,\n-  copy_pieced_value_closure,\n-  free_pieced_value_closure\n-};\n-\n /* Evaluate a location description, starting at DATA and with length\n    SIZE, to find the current location of variable of TYPE in the\n    context of FRAME.  If SUBOBJ_TYPE is non-NULL, return instead the"
    },
    {
      "sha": "33a5e8adc109309b3fe45d54ad9d73ad68404a0d",
      "filename": "gdb/dwarf2/loc.h",
      "status": "modified",
      "additions": 10,
      "deletions": 6,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4091d26441c7a3bead8bdfd1a37f072a32f40a0/gdb/dwarf2/loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.h?ref=f4091d26441c7a3bead8bdfd1a37f072a32f40a0",
      "patch": "@@ -53,13 +53,10 @@ extern void func_get_frame_base_dwarf_block (struct symbol *framefunc,\n \t\t\t\t\t     const gdb_byte **start,\n \t\t\t\t\t     size_t *length);\n \n-/* Given section offset SECT_OFF, and compilation unit data\n-   PER_CU, execute the \"variable value\" operation on the DIE\n-   found at SECT_OFF.  */\n+/* A helper function to find the definition of NAME and compute its\n+   value.  Returns nullptr if the name is not found.  */\n \n-struct value *sect_variable_value (sect_offset sect_off,\n-\t\t\t\t   dwarf2_per_cu_data *per_cu,\n-\t\t\t\t   dwarf2_per_objfile *per_objfile);\n+value *compute_var_value (const char *name);\n \n /* Fetch call_site_parameter from caller matching KIND and KIND_U.\n    FRAME is for callee.\n@@ -283,4 +280,11 @@ extern int dwarf_reg_to_regnum (struct gdbarch *arch, int dwarf_reg);\n extern int dwarf_reg_to_regnum_or_error (struct gdbarch *arch,\n \t\t\t\t\t ULONGEST dwarf_reg);\n \n+/* Fetch the value pointed to by a synthetic pointer.  */\n+\n+extern struct value *indirect_synthetic_pointer\n+  (sect_offset die, LONGEST byte_offset, dwarf2_per_cu_data *per_cu,\n+   dwarf2_per_objfile *per_objfile, struct frame_info *frame,\n+   struct type *type, bool resolve_abstract_p = false);\n+\n #endif /* dwarf2loc.h */"
    }
  ]
}