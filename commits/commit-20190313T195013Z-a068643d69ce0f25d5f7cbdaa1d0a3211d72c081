{
  "sha": "a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTA2ODY0M2Q2OWNlMGYyNWQ1ZjdjYmRhYTFkMGEzMjExZDcyYzA4MQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-02-28T16:09:55Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-03-13T19:50:13Z"
    },
    "message": "Change pid_to_str to return std::string\n\nCurrently the target pid_to_str method returns a const char *, so many\nimplementations have a static buffer that they update.  This patch\nchanges these methods to return a std::string instead.  I think this\nis cleaner and avoids possible gotchas when calling pid_to_str on\ndifferent ptids in a single statement.  (Though no such calls exist\ncurrently.)\n\nThis also updates various helper functions, and the gdbarch pid_to_str\nmethods.\n\nI also made a best effort to fix all the callers, but I can't build\nsome of the *-nat.c files.\n\nTested by the buildbot.\n\ngdb/ChangeLog\n2019-03-13  Tom Tromey  <tromey@adacore.com>\n\n\t* i386-gnu-nat.c (i386_gnu_nat_target::fetch_registers)\n\t(i386_gnu_nat_target::store_registers): Update.\n\t* target-debug.h (target_debug_print_std_string): New macro.\n\t* x86-linux-nat.c (x86_linux_nat_target::enable_btrace): Update.\n\t* windows-tdep.c (display_one_tib): Update.\n\t* tui/tui-stack.c (tui_make_status_line): Update.\n\t* top.c (print_inferior_quit_action): Update.\n\t* thread.c (thr_try_catch_cmd): Update.\n\t(add_thread_with_info): Update.\n\t(thread_target_id_str): Update.\n\t(thr_try_catch_cmd): Update.\n\t(thread_command): Update.\n\t(thread_find_command): Update.\n\t* record-btrace.c (record_btrace_target::info_record)\n\t(record_btrace_resume_thread, record_btrace_target::resume)\n\t(record_btrace_cancel_resume, record_btrace_step_thread)\n\t(record_btrace_target::wait, record_btrace_target::wait)\n\t(record_btrace_target::wait, record_btrace_target::stop): Update.\n\t* progspace.c (print_program_space): Update.\n\t* process-stratum-target.c\n\t(process_stratum_target::thread_address_space): Update.\n\t* linux-fork.c (linux_fork_mourn_inferior)\n\t(detach_checkpoint_command, info_checkpoints_command)\n\t(linux_fork_context): Update.\n\t(linux_fork_detach): Update.\n\t(class scoped_switch_fork_info): Update.\n\t(delete_checkpoint_command): Update.\n\t* infrun.c (follow_fork_inferior): Update.\n\t(follow_fork_inferior): Update.\n\t(proceed_after_vfork_done): Update.\n\t(handle_vfork_child_exec_or_exit): Update.\n\t(follow_exec): Update.\n\t(displaced_step_prepare_throw): Update.\n\t(displaced_step_restore): Update.\n\t(start_step_over): Update.\n\t(resume_1): Update.\n\t(clear_proceed_status_thread): Update.\n\t(proceed): Update.\n\t(print_target_wait_results): Update.\n\t(do_target_wait): Update.\n\t(context_switch): Update.\n\t(stop_all_threads): Update.\n\t(restart_threads): Update.\n\t(finish_step_over): Update.\n\t(handle_signal_stop): Update.\n\t(switch_back_to_stepped_thread): Update.\n\t(keep_going_pass_signal): Update.\n\t(print_exited_reason): Update.\n\t(normal_stop): Update.\n\t* inferior.c (inferior_pid_to_str): Change return type.\n\t(print_selected_inferior): Update.\n\t(add_inferior): Update.\n\t(detach_inferior): Update.\n\t* dummy-frame.c (fprint_dummy_frames): Update.\n\t* dcache.c (dcache_info_1): Update.\n\t* btrace.c (btrace_enable, btrace_disable, btrace_teardown)\n\t(btrace_fetch, btrace_clear): Update.\n\t* linux-tdep.c (linux_core_pid_to_str): Change return type.\n\t* i386-cygwin-tdep.c (i386_windows_core_pid_to_str): Change return\n\ttype.\n\t* fbsd-tdep.c (fbsd_core_pid_to_str): Change return type.\n\t* sol2-tdep.h (sol2_core_pid_to_str): Change return type.\n\t* sol2-tdep.c (sol2_core_pid_to_str): Change return type.\n\t* gdbarch.c, gdbarch.h: Rebuild.\n\t* gdbarch.sh (core_pid_to_str): Change return type.\n\t* windows-nat.c (struct windows_nat_target) <pid_to_str>: Change\n\treturn type.\n\t(windows_nat_target::pid_to_str): Change return type.\n\t(windows_delete_thread): Update.\n\t(windows_nat_target::attach): Update.\n\t(windows_nat_target::files_info): Update.\n\t* target-delegates.c: Rebuild.\n\t* sol-thread.c (class sol_thread_target) <pid_to_str>: Change\n\treturn type.\n\t(sol_thread_target::pid_to_str): Change return type.\n\t* remote.c (class remote_target) <pid_to_str>: Change return\n\ttype.\n\t(remote_target::pid_to_str): Change return type.\n\t(extended_remote_target::attach, remote_target::remote_stop_ns)\n\t(remote_target::remote_notif_remove_queued_reply)\n\t(remote_target::push_stop_reply, remote_target::disable_btrace):\n\tUpdate.\n\t(extended_remote_target::attach): Update.\n\t* remote-sim.c (struct gdbsim_target) <pid_to_str>: Change return\n\ttype.\n\t(gdbsim_target::pid_to_str): Change return type.\n\t* ravenscar-thread.c (struct ravenscar_thread_target)\n\t<pid_to_str>: Change return type.\n\t(ravenscar_thread_target::pid_to_str): Change return type.\n\t* procfs.c (class procfs_target) <pid_to_str>: Change return\n\ttype.\n\t(procfs_target::pid_to_str): Change return type.\n\t(procfs_target::attach): Update.\n\t(procfs_target::detach): Update.\n\t(procfs_target::fetch_registers): Update.\n\t(procfs_target::store_registers): Update.\n\t(procfs_target::wait): Update.\n\t(procfs_target::files_info): Update.\n\t* obsd-nat.c (obsd_nat_target::pid_to_str): Change return type.\n\t* nto-procfs.c (struct nto_procfs_target) <pid_to_str>: Change\n\treturn type.\n\t(nto_procfs_target::pid_to_str): Change return type.\n\t(nto_procfs_target::files_info, nto_procfs_target::attach): Update.\n\t* linux-thread-db.c (class thread_db_target) <pid_to_str>: Change\n\treturn type.\n\t* linux-nat.c (linux_nat_target::pid_to_str): Change return type.\n\t(exit_lwp): Update.\n\t(attach_proc_task_lwp_callback, get_detach_signal)\n\t(detach_one_lwp, resume_lwp, linux_nat_target::resume)\n\t(linux_nat_target::resume, wait_lwp, stop_callback)\n\t(maybe_clear_ignore_sigint, stop_wait_callback, status_callback)\n\t(save_stop_reason, select_event_lwp, linux_nat_filter_event)\n\t(linux_nat_wait_1, resume_stopped_resumed_lwps)\n\t(linux_nat_target::wait, linux_nat_stop_lwp): Update.\n\t* inf-ptrace.c (inf_ptrace_target::pid_to_str): Change return\n\ttype.\n\t(inf_ptrace_target::attach): Update.\n\t(inf_ptrace_target::files_info): Update.\n\t* go32-nat.c (struct go32_nat_target) <pid_to_str>: Change return\n\ttype.\n\t(go32_nat_target::pid_to_str): Change return type.\n\t* gnu-nat.c (gnu_nat_target::pid_to_str): Change return type.\n\t(gnu_nat_target::wait): Update.\n\t(gnu_nat_target::wait): Update.\n\t(gnu_nat_target::resume): Update.\n\t* fbsd-nat.c (fbsd_nat_target::pid_to_str): Change return type.\n\t(fbsd_nat_target::wait): Update.\n\t* darwin-nat.c (darwin_nat_target::pid_to_str): Change return\n\ttype.\n\t(darwin_nat_target::attach): Update.\n\t* corelow.c (class core_target) <pid_to_str>: Change return type.\n\t(core_target::pid_to_str): Change return type.\n\t* target.c (normal_pid_to_str): Change return type.\n\t(default_pid_to_str): Likewise.\n\t(target_pid_to_str): Change return type.\n\t(target_translate_tls_address): Update.\n\t(target_announce_detach): Update.\n\t* bsd-uthread.c (struct bsd_uthread_target) <pid_to_str>: Change\n\treturn type.\n\t(bsd_uthread_target::pid_to_str): Change return type.\n\t* bsd-kvm.c (class bsd_kvm_target) <pid_to_str>: Change return\n\ttype.\n\t(bsd_kvm_target::pid_to_str): Change return type.\n\t* aix-thread.c (class aix_thread_target) <pid_to_str>: Change\n\treturn type.\n\t(aix_thread_target::pid_to_str): Change return type.\n\t* target.h (struct target_ops) <pid_to_str>: Change return type.\n\t(target_pid_to_str, normal_pid_to_str): Likewise.\n\t* obsd-nat.h (class obsd_nat_target) <pid_to_str>: Change return\n\ttype.\n\t* linux-nat.h (class linux_nat_target) <pid_to_str>: Change return\n\ttype.\n\t* inf-ptrace.h (struct inf_ptrace_target) <pid_to_str>: Change\n\treturn type.\n\t* gnu-nat.h (struct gnu_nat_target) <pid_to_str>: Change return\n\ttype.\n\t* fbsd-nat.h (class fbsd_nat_target) <pid_to_str>: Change return\n\ttype.\n\t* darwin-nat.h (class darwin_nat_target) <pid_to_str>: Change\n\treturn type.",
    "tree": {
      "sha": "4b0da08750a1d8fb4db7889fd2f42ea49580cbae",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4b0da08750a1d8fb4db7889fd2f42ea49580cbae"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b4be1b0648608a2578bbed39841c8ee411773edd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4be1b0648608a2578bbed39841c8ee411773edd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b4be1b0648608a2578bbed39841c8ee411773edd"
    }
  ],
  "stats": {
    "total": 907,
    "additions": 499,
    "deletions": 408
  },
  "files": [
    {
      "sha": "24de651bf92838b7a0f3fb10286f2a10f99cbc92",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 163,
      "deletions": 0,
      "changes": 163,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -1,3 +1,166 @@\n+2019-03-13  Tom Tromey  <tromey@adacore.com>\n+\n+\t* i386-gnu-nat.c (i386_gnu_nat_target::fetch_registers)\n+\t(i386_gnu_nat_target::store_registers): Update.\n+\t* target-debug.h (target_debug_print_std_string): New macro.\n+\t* x86-linux-nat.c (x86_linux_nat_target::enable_btrace): Update.\n+\t* windows-tdep.c (display_one_tib): Update.\n+\t* tui/tui-stack.c (tui_make_status_line): Update.\n+\t* top.c (print_inferior_quit_action): Update.\n+\t* thread.c (thr_try_catch_cmd): Update.\n+\t(add_thread_with_info): Update.\n+\t(thread_target_id_str): Update.\n+\t(thr_try_catch_cmd): Update.\n+\t(thread_command): Update.\n+\t(thread_find_command): Update.\n+\t* record-btrace.c (record_btrace_target::info_record)\n+\t(record_btrace_resume_thread, record_btrace_target::resume)\n+\t(record_btrace_cancel_resume, record_btrace_step_thread)\n+\t(record_btrace_target::wait, record_btrace_target::wait)\n+\t(record_btrace_target::wait, record_btrace_target::stop): Update.\n+\t* progspace.c (print_program_space): Update.\n+\t* process-stratum-target.c\n+\t(process_stratum_target::thread_address_space): Update.\n+\t* linux-fork.c (linux_fork_mourn_inferior)\n+\t(detach_checkpoint_command, info_checkpoints_command)\n+\t(linux_fork_context): Update.\n+\t(linux_fork_detach): Update.\n+\t(class scoped_switch_fork_info): Update.\n+\t(delete_checkpoint_command): Update.\n+\t* infrun.c (follow_fork_inferior): Update.\n+\t(follow_fork_inferior): Update.\n+\t(proceed_after_vfork_done): Update.\n+\t(handle_vfork_child_exec_or_exit): Update.\n+\t(follow_exec): Update.\n+\t(displaced_step_prepare_throw): Update.\n+\t(displaced_step_restore): Update.\n+\t(start_step_over): Update.\n+\t(resume_1): Update.\n+\t(clear_proceed_status_thread): Update.\n+\t(proceed): Update.\n+\t(print_target_wait_results): Update.\n+\t(do_target_wait): Update.\n+\t(context_switch): Update.\n+\t(stop_all_threads): Update.\n+\t(restart_threads): Update.\n+\t(finish_step_over): Update.\n+\t(handle_signal_stop): Update.\n+\t(switch_back_to_stepped_thread): Update.\n+\t(keep_going_pass_signal): Update.\n+\t(print_exited_reason): Update.\n+\t(normal_stop): Update.\n+\t* inferior.c (inferior_pid_to_str): Change return type.\n+\t(print_selected_inferior): Update.\n+\t(add_inferior): Update.\n+\t(detach_inferior): Update.\n+\t* dummy-frame.c (fprint_dummy_frames): Update.\n+\t* dcache.c (dcache_info_1): Update.\n+\t* btrace.c (btrace_enable, btrace_disable, btrace_teardown)\n+\t(btrace_fetch, btrace_clear): Update.\n+\t* linux-tdep.c (linux_core_pid_to_str): Change return type.\n+\t* i386-cygwin-tdep.c (i386_windows_core_pid_to_str): Change return\n+\ttype.\n+\t* fbsd-tdep.c (fbsd_core_pid_to_str): Change return type.\n+\t* sol2-tdep.h (sol2_core_pid_to_str): Change return type.\n+\t* sol2-tdep.c (sol2_core_pid_to_str): Change return type.\n+\t* gdbarch.c, gdbarch.h: Rebuild.\n+\t* gdbarch.sh (core_pid_to_str): Change return type.\n+\t* windows-nat.c (struct windows_nat_target) <pid_to_str>: Change\n+\treturn type.\n+\t(windows_nat_target::pid_to_str): Change return type.\n+\t(windows_delete_thread): Update.\n+\t(windows_nat_target::attach): Update.\n+\t(windows_nat_target::files_info): Update.\n+\t* target-delegates.c: Rebuild.\n+\t* sol-thread.c (class sol_thread_target) <pid_to_str>: Change\n+\treturn type.\n+\t(sol_thread_target::pid_to_str): Change return type.\n+\t* remote.c (class remote_target) <pid_to_str>: Change return\n+\ttype.\n+\t(remote_target::pid_to_str): Change return type.\n+\t(extended_remote_target::attach, remote_target::remote_stop_ns)\n+\t(remote_target::remote_notif_remove_queued_reply)\n+\t(remote_target::push_stop_reply, remote_target::disable_btrace):\n+\tUpdate.\n+\t(extended_remote_target::attach): Update.\n+\t* remote-sim.c (struct gdbsim_target) <pid_to_str>: Change return\n+\ttype.\n+\t(gdbsim_target::pid_to_str): Change return type.\n+\t* ravenscar-thread.c (struct ravenscar_thread_target)\n+\t<pid_to_str>: Change return type.\n+\t(ravenscar_thread_target::pid_to_str): Change return type.\n+\t* procfs.c (class procfs_target) <pid_to_str>: Change return\n+\ttype.\n+\t(procfs_target::pid_to_str): Change return type.\n+\t(procfs_target::attach): Update.\n+\t(procfs_target::detach): Update.\n+\t(procfs_target::fetch_registers): Update.\n+\t(procfs_target::store_registers): Update.\n+\t(procfs_target::wait): Update.\n+\t(procfs_target::files_info): Update.\n+\t* obsd-nat.c (obsd_nat_target::pid_to_str): Change return type.\n+\t* nto-procfs.c (struct nto_procfs_target) <pid_to_str>: Change\n+\treturn type.\n+\t(nto_procfs_target::pid_to_str): Change return type.\n+\t(nto_procfs_target::files_info, nto_procfs_target::attach): Update.\n+\t* linux-thread-db.c (class thread_db_target) <pid_to_str>: Change\n+\treturn type.\n+\t* linux-nat.c (linux_nat_target::pid_to_str): Change return type.\n+\t(exit_lwp): Update.\n+\t(attach_proc_task_lwp_callback, get_detach_signal)\n+\t(detach_one_lwp, resume_lwp, linux_nat_target::resume)\n+\t(linux_nat_target::resume, wait_lwp, stop_callback)\n+\t(maybe_clear_ignore_sigint, stop_wait_callback, status_callback)\n+\t(save_stop_reason, select_event_lwp, linux_nat_filter_event)\n+\t(linux_nat_wait_1, resume_stopped_resumed_lwps)\n+\t(linux_nat_target::wait, linux_nat_stop_lwp): Update.\n+\t* inf-ptrace.c (inf_ptrace_target::pid_to_str): Change return\n+\ttype.\n+\t(inf_ptrace_target::attach): Update.\n+\t(inf_ptrace_target::files_info): Update.\n+\t* go32-nat.c (struct go32_nat_target) <pid_to_str>: Change return\n+\ttype.\n+\t(go32_nat_target::pid_to_str): Change return type.\n+\t* gnu-nat.c (gnu_nat_target::pid_to_str): Change return type.\n+\t(gnu_nat_target::wait): Update.\n+\t(gnu_nat_target::wait): Update.\n+\t(gnu_nat_target::resume): Update.\n+\t* fbsd-nat.c (fbsd_nat_target::pid_to_str): Change return type.\n+\t(fbsd_nat_target::wait): Update.\n+\t* darwin-nat.c (darwin_nat_target::pid_to_str): Change return\n+\ttype.\n+\t(darwin_nat_target::attach): Update.\n+\t* corelow.c (class core_target) <pid_to_str>: Change return type.\n+\t(core_target::pid_to_str): Change return type.\n+\t* target.c (normal_pid_to_str): Change return type.\n+\t(default_pid_to_str): Likewise.\n+\t(target_pid_to_str): Change return type.\n+\t(target_translate_tls_address): Update.\n+\t(target_announce_detach): Update.\n+\t* bsd-uthread.c (struct bsd_uthread_target) <pid_to_str>: Change\n+\treturn type.\n+\t(bsd_uthread_target::pid_to_str): Change return type.\n+\t* bsd-kvm.c (class bsd_kvm_target) <pid_to_str>: Change return\n+\ttype.\n+\t(bsd_kvm_target::pid_to_str): Change return type.\n+\t* aix-thread.c (class aix_thread_target) <pid_to_str>: Change\n+\treturn type.\n+\t(aix_thread_target::pid_to_str): Change return type.\n+\t* target.h (struct target_ops) <pid_to_str>: Change return type.\n+\t(target_pid_to_str, normal_pid_to_str): Likewise.\n+\t* obsd-nat.h (class obsd_nat_target) <pid_to_str>: Change return\n+\ttype.\n+\t* linux-nat.h (class linux_nat_target) <pid_to_str>: Change return\n+\ttype.\n+\t* inf-ptrace.h (struct inf_ptrace_target) <pid_to_str>: Change\n+\treturn type.\n+\t* gnu-nat.h (struct gnu_nat_target) <pid_to_str>: Change return\n+\ttype.\n+\t* fbsd-nat.h (class fbsd_nat_target) <pid_to_str>: Change return\n+\ttype.\n+\t* darwin-nat.h (class darwin_nat_target) <pid_to_str>: Change\n+\treturn type.\n+\n 2019-03-13  Simon Marchi  <simon.marchi@ericsson.com>\n \n \t* NEWS: Mention that the new default MI version is 3.  Mention"
    },
    {
      "sha": "ffa3352d03992338614c3883d8ac2f268e597ed8",
      "filename": "gdb/aix-thread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 10,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/aix-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/aix-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aix-thread.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -140,7 +140,7 @@ class aix_thread_target final : public target_ops\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   const char *extra_thread_info (struct thread_info *) override;\n \n@@ -1746,20 +1746,13 @@ aix_thread_target::thread_alive (ptid_t ptid)\n /* Return a printable representation of composite PID for use in\n    \"info threads\" output.  */\n \n-const char *\n+std::string\n aix_thread_target::pid_to_str (ptid_t ptid)\n {\n-  static char *ret = NULL;\n-\n   if (!PD_TID (ptid))\n     return beneath ()->pid_to_str (ptid);\n \n-  /* Free previous return value; a new one will be allocated by\n-     xstrprintf().  */\n-  xfree (ret);\n-\n-  ret = xstrprintf (_(\"Thread %ld\"), ptid.tid ());\n-  return ret;\n+  return string_printf (_(\"Thread %ld\"), ptid.tid ());\n }\n \n /* Return a printable representation of extra information about"
    },
    {
      "sha": "21f978728da629ef3569f996af9cfe7aa12fe8f6",
      "filename": "gdb/bsd-kvm.c",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/bsd-kvm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/bsd-kvm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-kvm.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -92,7 +92,7 @@ class bsd_kvm_target final : public process_stratum_target\n \n   void files_info () override;\n   bool thread_alive (ptid_t ptid) override;\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   bool has_memory () override { return true; }\n   bool has_stack () override { return true; }\n@@ -368,12 +368,10 @@ bsd_kvm_target::thread_alive (ptid_t ptid)\n   return true;\n }\n \n-const char *\n+std::string\n bsd_kvm_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[64];\n-  xsnprintf (buf, sizeof buf, \"<kvm>\");\n-  return buf;\n+  return \"<kvm>\";\n }\n \n /* Add the libkvm interface to the list of all possible targets and"
    },
    {
      "sha": "af048f7a18f940c02633c228a864f8f68d46d5cd",
      "filename": "gdb/bsd-uthread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 9,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/bsd-uthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/bsd-uthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-uthread.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -62,7 +62,7 @@ struct bsd_uthread_target final : public target_ops\n \n   const char *extra_thread_info (struct thread_info *) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n };\n \n static bsd_uthread_target bsd_uthread_ops;\n@@ -530,17 +530,12 @@ bsd_uthread_target::extra_thread_info (thread_info *info)\n   return NULL;\n }\n \n-const char *\n+std::string\n bsd_uthread_target::pid_to_str (ptid_t ptid)\n {\n   if (ptid.tid () != 0)\n-    {\n-      static char buf[64];\n-\n-      xsnprintf (buf, sizeof buf, \"process %d, thread 0x%lx\",\n-\t\t ptid.pid (), ptid.tid ());\n-      return buf;\n-    }\n+    return string_printf (\"process %d, thread 0x%lx\",\n+\t\t\t  ptid.pid (), ptid.tid ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "12af46814a9db0586d8e1109574528f6cf610576",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -1608,7 +1608,7 @@ btrace_enable (struct thread_info *tp, const struct btrace_config *conf)\n #endif /* !defined (HAVE_LIBIPT) */\n \n   DEBUG (\"enable thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid));\n+\t target_pid_to_str (tp->ptid).c_str ());\n \n   tp->btrace.target = target_enable_btrace (tp->ptid, conf);\n \n@@ -1663,7 +1663,7 @@ btrace_disable (struct thread_info *tp)\n     return;\n \n   DEBUG (\"disable thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid));\n+\t target_pid_to_str (tp->ptid).c_str ());\n \n   target_disable_btrace (btp->target);\n   btp->target = NULL;\n@@ -1682,7 +1682,7 @@ btrace_teardown (struct thread_info *tp)\n     return;\n \n   DEBUG (\"teardown thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid));\n+\t target_pid_to_str (tp->ptid).c_str ());\n \n   target_teardown_btrace (btp->target);\n   btp->target = NULL;\n@@ -1905,7 +1905,7 @@ btrace_fetch (struct thread_info *tp, const struct btrace_cpu *cpu)\n   int errcode;\n \n   DEBUG (\"fetch thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid));\n+\t target_pid_to_str (tp->ptid).c_str ());\n \n   btinfo = &tp->btrace;\n   tinfo = btinfo->target;\n@@ -1981,7 +1981,7 @@ btrace_clear (struct thread_info *tp)\n   struct btrace_thread_info *btinfo;\n \n   DEBUG (\"clear thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid));\n+\t target_pid_to_str (tp->ptid).c_str ());\n \n   /* Make sure btrace frames that may hold a pointer into the branch\n      trace data are destroyed.  */"
    },
    {
      "sha": "7fb42970de4f87ba08c9416ac3065f4186a8de38",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -83,7 +83,7 @@ class core_target final : public process_stratum_target\n   bool thread_alive (ptid_t ptid) override;\n   const struct target_desc *read_description () override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   const char *thread_name (struct thread_info *) override;\n \n@@ -985,10 +985,9 @@ core_target::read_description ()\n   return this->beneath ()->read_description ();\n }\n \n-const char *\n+std::string\n core_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[64];\n   struct inferior *inf;\n   int pid;\n \n@@ -1013,8 +1012,7 @@ core_target::pid_to_str (ptid_t ptid)\n     return normal_pid_to_str (ptid);\n \n   /* No luck.  We simply don't have a valid PID to print.  */\n-  xsnprintf (buf, sizeof buf, \"<main task>\");\n-  return buf;\n+  return \"<main task>\";\n }\n \n const char *"
    },
    {
      "sha": "6247b0656c9507de3a8f89e1b74a42b8b4dc30a5",
      "filename": "gdb/darwin-nat.c",
      "status": "modified",
      "additions": 5,
      "deletions": 9,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/darwin-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/darwin-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -2052,10 +2052,10 @@ darwin_nat_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_unfiltered (_(\"Attaching to program: %s, %s\\n\"), exec_file,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (_(\"Attaching to %s\\n\"),\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n   if (pid == 0 || ::kill (pid, 0) < 0)\n@@ -2126,18 +2126,14 @@ darwin_nat_target::detach (inferior *inf, int from_tty)\n   mourn_inferior ();\n }\n \n-const char *\n+std::string\n darwin_nat_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[80];\n   long tid = ptid.tid ();\n \n   if (tid != 0)\n-    {\n-      snprintf (buf, sizeof (buf), _(\"Thread 0x%lx of process %u\"),\n-\t\ttid, ptid.pid ());\n-      return buf;\n-    }\n+    return string_printf (_(\"Thread 0x%lx of process %u\"),\n+\t\t\t  tid, ptid.pid ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "9091efd88f14b866fb98729e829e77d726986430",
      "filename": "gdb/darwin-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/darwin-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/darwin-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -45,7 +45,7 @@ class darwin_nat_target : public inf_child_target\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   char *pid_to_exec_file (int pid) override;\n "
    },
    {
      "sha": "5a2e8f8000b7c7de9f0fbac640611043b2187b02",
      "filename": "gdb/dcache.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/dcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/dcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dcache.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -615,7 +615,7 @@ dcache_info_1 (DCACHE *dcache, const char *exp)\n     }\n \n   printf_filtered (_(\"Contains data for %s\\n\"),\n-\t\t   target_pid_to_str (dcache->ptid));\n+\t\t   target_pid_to_str (dcache->ptid).c_str ());\n \n   refcount = 0;\n "
    },
    {
      "sha": "aebdd233d74074fb1f723c7bd0bd9e03147e24db",
      "filename": "gdb/dummy-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/dummy-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/dummy-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dummy-frame.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -409,7 +409,7 @@ fprint_dummy_frames (struct ui_file *file)\n       fprintf_unfiltered (file, \" id=\");\n       fprint_frame_id (file, s->id.id);\n       fprintf_unfiltered (file, \", ptid=%s\",\n-\t\t\t  target_pid_to_str (s->id.thread->ptid));\n+\t\t\t  target_pid_to_str (s->id.thread->ptid).c_str ());\n       fprintf_unfiltered (file, \"\\n\");\n     }\n }"
    },
    {
      "sha": "d4f4c8cf3592b5eaf61ccdd7b3514287feef9d54",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -897,22 +897,19 @@ fbsd_nat_target::thread_alive (ptid_t ptid)\n   return true;\n }\n \n-/* Convert PTID to a string.  Returns the string in a static\n-   buffer.  */\n+/* Convert PTID to a string.  */\n \n-const char *\n+std::string\n fbsd_nat_target::pid_to_str (ptid_t ptid)\n {\n   lwpid_t lwp;\n \n   lwp = ptid.lwp ();\n   if (lwp != 0)\n     {\n-      static char buf[64];\n       int pid = ptid.pid ();\n \n-      xsnprintf (buf, sizeof buf, \"LWP %d of process %d\", lwp, pid);\n-      return buf;\n+      return string_printf (\"LWP %d of process %d\", lwp, pid);\n     }\n \n   return normal_pid_to_str (ptid);\n@@ -1350,8 +1347,8 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t\t\t\t\"FLWP: deleting thread for LWP %u\\n\",\n \t\t\t\t\tpl.pl_lwpid);\n \t\t  if (print_thread_events)\n-\t\t    printf_unfiltered (_(\"[%s exited]\\n\"), target_pid_to_str\n-\t\t\t\t       (wptid));\n+\t\t    printf_unfiltered (_(\"[%s exited]\\n\"),\n+\t\t\t\t       target_pid_to_str (wptid).c_str ());\n \t\t  delete_thread (thr);\n \t\t}\n \t      if (ptrace (PT_CONTINUE, pid, (caddr_t) 1, 0) == -1)"
    },
    {
      "sha": "b0c9eb16c7754f6b2353838b837d4a9671dfc373",
      "filename": "gdb/fbsd-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -51,7 +51,7 @@ class fbsd_nat_target : public inf_ptrace_target\n \n #ifdef PT_LWPINFO\n   bool thread_alive (ptid_t ptid) override;\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n #ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_TDNAME\n   const char *thread_name (struct thread_info *) override;"
    },
    {
      "sha": "cd207d88bc384f097fa42f72402537783d8b9248",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -482,16 +482,11 @@ fbsd_pspace_data_cleanup (struct program_space *pspace, void *data)\n \n /* This is how we want PTIDs from core files to be printed.  */\n \n-static const char *\n+static std::string\n fbsd_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n {\n-  static char buf[80];\n-\n   if (ptid.lwp () != 0)\n-    {\n-      xsnprintf (buf, sizeof buf, \"LWP %ld\", ptid.lwp ());\n-      return buf;\n-    }\n+    return string_printf (\"LWP %ld\", ptid.lwp ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "210defffea39a12b40354aa92d79d3ceb7e75be2",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -3766,7 +3766,7 @@ gdbarch_core_pid_to_str_p (struct gdbarch *gdbarch)\n   return gdbarch->core_pid_to_str != NULL;\n }\n \n-const char *\n+std::string\n gdbarch_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n {\n   gdb_assert (gdbarch != NULL);"
    },
    {
      "sha": "7e185241872d350c7bcf46d496b36d8153a11fd0",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -959,8 +959,8 @@ extern void set_gdbarch_core_xfer_shared_libraries_aix (struct gdbarch *gdbarch,\n \n extern int gdbarch_core_pid_to_str_p (struct gdbarch *gdbarch);\n \n-typedef const char * (gdbarch_core_pid_to_str_ftype) (struct gdbarch *gdbarch, ptid_t ptid);\n-extern const char * gdbarch_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n+typedef std::string (gdbarch_core_pid_to_str_ftype) (struct gdbarch *gdbarch, ptid_t ptid);\n+extern std::string gdbarch_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n extern void set_gdbarch_core_pid_to_str (struct gdbarch *gdbarch, gdbarch_core_pid_to_str_ftype *core_pid_to_str);\n \n /* How the core target extracts the name of a thread from a core file. */"
    },
    {
      "sha": "5e3e4346a4ea6f5a361884a719a566cf5c660bdb",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -767,7 +767,7 @@ M;ULONGEST;core_xfer_shared_libraries;gdb_byte *readbuf, ULONGEST offset, ULONGE\n M;ULONGEST;core_xfer_shared_libraries_aix;gdb_byte *readbuf, ULONGEST offset, ULONGEST len;readbuf, offset, len\n \n # How the core target converts a PTID from a core file to a string.\n-M;const char *;core_pid_to_str;ptid_t ptid;ptid\n+M;std::string;core_pid_to_str;ptid_t ptid;ptid\n \n # How the core target extracts the name of a thread from a core file.\n M;const char *;core_thread_name;struct thread_info *thr;thr"
    },
    {
      "sha": "c1fafed156efc81f0971e8e8c6b6fa4cab200aef",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 11,
      "deletions": 14,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -1493,7 +1493,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   waiting_inf = inf;\n \n-  inf_debug (inf, \"waiting for: %s\", target_pid_to_str (ptid));\n+  inf_debug (inf, \"waiting for: %s\", target_pid_to_str (ptid).c_str ());\n \n rewait:\n   if (proc_wait_pid != inf->pid && !inf->no_wait)\n@@ -1648,7 +1648,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     }\n \n   inf_debug (inf, \"returning ptid = %s, status = %s (%d)\",\n-\t     target_pid_to_str (ptid),\n+\t     target_pid_to_str (ptid).c_str (),\n \t     status->kind == TARGET_WAITKIND_EXITED ? \"EXITED\"\n \t     : status->kind == TARGET_WAITKIND_STOPPED ? \"STOPPED\"\n \t     : status->kind == TARGET_WAITKIND_SIGNALLED ? \"SIGNALLED\"\n@@ -2012,7 +2012,7 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n   struct inf *inf = gnu_current_inf;\n \n   inf_debug (inf, \"ptid = %s, step = %d, sig = %d\",\n-\t     target_pid_to_str (ptid), step, sig);\n+\t     target_pid_to_str (ptid).c_str (), step, sig);\n \n   inf_validate_procinfo (inf);\n \n@@ -2058,8 +2058,9 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n \n       if (!thread)\n \terror (_(\"Can't run single thread id %s: no such thread!\"),\n-\t       target_pid_to_str (ptid));\n-      inf_debug (inf, \"running one thread: %s\", target_pid_to_str (ptid));\n+\t       target_pid_to_str (ptid).c_str ());\n+      inf_debug (inf, \"running one thread: %s\",\n+\t\t target_pid_to_str (ptid).c_str ());\n       inf_set_threads_resume_sc (inf, thread, 0);\n     }\n \n@@ -2068,9 +2069,10 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n       step_thread = inf_tid_to_thread (inf, ptid.lwp ());\n       if (!step_thread)\n \twarning (_(\"Can't step thread id %s: no such thread.\"),\n-\t\t target_pid_to_str (ptid));\n+\t\t target_pid_to_str (ptid).c_str ());\n       else\n-\tinf_debug (inf, \"stepping thread: %s\", target_pid_to_str (ptid));\n+\tinf_debug (inf, \"stepping thread: %s\",\n+\t\t   target_pid_to_str (ptid).c_str ());\n     }\n   if (step_thread != inf->step_thread)\n     inf_set_step_thread (inf, step_thread);\n@@ -2714,7 +2716,7 @@ proc_string (struct proc *proc)\n   return tid_str;\n }\n \n-const char *\n+std::string\n gnu_nat_target::pid_to_str (ptid_t ptid)\n {\n   struct inf *inf = gnu_current_inf;\n@@ -2724,12 +2726,7 @@ gnu_nat_target::pid_to_str (ptid_t ptid)\n   if (thread)\n     return proc_string (thread);\n   else\n-    {\n-      static char tid_str[80];\n-\n-      xsnprintf (tid_str, sizeof (tid_str), \"bogus thread id %d\", tid);\n-      return tid_str;\n-    }\n+    return string_printf (\"bogus thread id %d\", tid);\n }\n \n \f"
    },
    {
      "sha": "a22df89fe2de549649efeb2c415ac2aac29f2d9a",
      "filename": "gdb/gnu-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gnu-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/gnu-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -146,7 +146,7 @@ struct gnu_nat_target : public inf_child_target\n \t\t\tchar **, int) override;\n   void mourn_inferior () override;\n   bool thread_alive (ptid_t ptid) override;\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n   void stop (ptid_t) override;\n };\n "
    },
    {
      "sha": "ea0872363d3c4b3c424181cf0d80cb2287358e7c",
      "filename": "gdb/go32-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/go32-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/go32-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go32-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -377,7 +377,7 @@ struct go32_nat_target final : public x86_nat_target<inf_child_target>\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n };\n \n static go32_nat_target the_go32_nat_target;\n@@ -992,7 +992,7 @@ go32_nat_target::thread_alive (ptid_t ptid)\n   return ptid != null_ptid;\n }\n \n-const char *\n+std::string\n go32_nat_target::pid_to_str (ptid_t ptid)\n {\n   return normal_pid_to_str (ptid);"
    },
    {
      "sha": "1acd37975ee8c26dfe2873ab76e1909d21394691",
      "filename": "gdb/i386-cygwin-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/i386-cygwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/i386-cygwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-cygwin-tdep.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -178,16 +178,11 @@ windows_core_xfer_shared_libraries (struct gdbarch *gdbarch,\n \n /* This is how we want PTIDs from core files to be printed.  */\n \n-static const char *\n+static std::string\n i386_windows_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n {\n-  static char buf[80];\n-\n   if (ptid.lwp () != 0)\n-    {\n-      snprintf (buf, sizeof (buf), \"Thread 0x%lx\", ptid.lwp ());\n-      return buf;\n-    }\n+    return string_printf (\"Thread 0x%lx\", ptid.lwp ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "087445bc6269b53d3499191d07d90f53c0b949eb",
      "filename": "gdb/i386-gnu-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/i386-gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/i386-gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-gnu-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -117,7 +117,7 @@ i386_gnu_nat_target::fetch_registers (struct regcache *regcache, int regno)\n   thread = inf_tid_to_thread (gnu_current_inf, ptid.lwp ());\n   if (!thread)\n     error (_(\"Can't fetch registers from thread %s: No such thread\"),\n-\t   target_pid_to_str (ptid));\n+\t   target_pid_to_str (ptid).c_str ());\n \n   if (regno < I386_NUM_GREGS || regno == -1)\n     {\n@@ -208,7 +208,7 @@ i386_gnu_nat_target::store_registers (struct regcache *regcache, int regno)\n   thread = inf_tid_to_thread (gnu_current_inf, ptid.lwp ());\n   if (!thread)\n     error (_(\"Couldn't store registers into thread %s: No such thread\"),\n-\t   target_pid_to_str (ptid));\n+\t   target_pid_to_str (ptid).c_str ());\n \n   if (regno < I386_NUM_GREGS || regno == -1)\n     {"
    },
    {
      "sha": "e1acd8dc9df7cb1faf00a346b0cf8685bff6b0c3",
      "filename": "gdb/inf-ptrace.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inf-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inf-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -213,10 +213,10 @@ inf_ptrace_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_unfiltered (_(\"Attaching to program: %s, %s\\n\"), exec_file,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (_(\"Attaching to %s\\n\"),\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n #ifdef PT_ATTACH\n@@ -624,10 +624,10 @@ inf_ptrace_target::files_info ()\n \n   printf_filtered (_(\"\\tUsing the running image of %s %s.\\n\"),\n \t\t   inf->attach_flag ? \"attached\" : \"child\",\n-\t\t   target_pid_to_str (inferior_ptid));\n+\t\t   target_pid_to_str (inferior_ptid).c_str ());\n }\n \n-const char *\n+std::string\n inf_ptrace_target::pid_to_str (ptid_t ptid)\n {\n   return normal_pid_to_str (ptid);"
    },
    {
      "sha": "98b5d2e09e686b0c4490f1fd442e4be61bab6a61",
      "filename": "gdb/inf-ptrace.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inf-ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inf-ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -59,7 +59,7 @@ struct inf_ptrace_target : public inf_child_target\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   enum target_xfer_status xfer_partial (enum target_object object,\n \t\t\t\t\tconst char *annex,"
    },
    {
      "sha": "e995af816c13105123915bcdcd8890d064e0c774",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -126,7 +126,7 @@ add_inferior (int pid)\n       if (pid != 0)\n \tprintf_unfiltered (_(\"[New inferior %d (%s)]\\n\"),\n \t\t\t   inf->num,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (_(\"[New inferior %d]\\n\"), inf->num);\n     }\n@@ -243,7 +243,7 @@ detach_inferior (inferior *inf)\n   if (print_inferior_events)\n     printf_unfiltered (_(\"[Inferior %d (%s) detached]\\n\"),\n \t\t       inf->num,\n-\t\t       target_pid_to_str (ptid_t (pid)));\n+\t\t       target_pid_to_str (ptid_t (pid)).c_str ());\n }\n \n void\n@@ -407,7 +407,7 @@ number_of_inferiors (void)\n /* Converts an inferior process id to a string.  Like\n    target_pid_to_str, but special cases the null process.  */\n \n-static const char *\n+static std::string\n inferior_pid_to_str (int pid)\n {\n   if (pid != 0)\n@@ -428,7 +428,7 @@ print_selected_inferior (struct ui_out *uiout)\n     filename = _(\"<noexec>\");\n \n   uiout->message (_(\"[Switching to inferior %d [%s] (%s)]\\n\"),\n-\t\t  inf->num, inferior_pid_to_str (inf->pid), filename);\n+\t\t  inf->num, inferior_pid_to_str (inf->pid).c_str (), filename);\n }\n \n /* Prints the list of inferiors and their details on UIOUT.  This is a"
    },
    {
      "sha": "3d7f36b447490482e77d9328f4bf32fd9666b86c",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 63,
      "deletions": 60,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -471,7 +471,7 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      fprintf_filtered (gdb_stdlog,\n \t\t\t\t_(\"[Detaching after %s from child %s]\\n\"),\n \t\t\t\thas_vforked ? \"vfork\" : \"fork\",\n-\t\t\t\ttarget_pid_to_str (process_ptid));\n+\t\t\t\ttarget_pid_to_str (process_ptid).c_str ());\n \t    }\n \t}\n       else\n@@ -607,7 +607,7 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      fprintf_filtered (gdb_stdlog,\n \t\t\t\t_(\"[Detaching after fork from \"\n \t\t\t\t  \"parent %s]\\n\"),\n-\t\t\t\ttarget_pid_to_str (process_ptid));\n+\t\t\t\ttarget_pid_to_str (process_ptid).c_str ());\n \t    }\n \n \t  target_detach (parent_inf, 0);\n@@ -876,7 +876,7 @@ proceed_after_vfork_done (struct thread_info *thread,\n       if (debug_infrun)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"infrun: resuming vfork parent thread %s\\n\",\n-\t\t\t    target_pid_to_str (thread->ptid));\n+\t\t\t    target_pid_to_str (thread->ptid).c_str ());\n \n       switch_to_thread (thread);\n       clear_proceed_status (0);\n@@ -963,7 +963,7 @@ handle_vfork_child_exec_or_exit (int exec)\n \n \t  if (print_inferior_events)\n \t    {\n-\t      const char *pidstr\n+\t      std::string pidstr\n \t\t= target_pid_to_str (ptid_t (inf->vfork_parent->pid));\n \n \t      target_terminal::ours_for_output ();\n@@ -972,13 +972,13 @@ handle_vfork_child_exec_or_exit (int exec)\n \t\t{\n \t\t  fprintf_filtered (gdb_stdlog,\n \t\t\t\t    _(\"[Detaching vfork parent %s \"\n-\t\t\t\t      \"after child exec]\\n\"), pidstr);\n+\t\t\t\t      \"after child exec]\\n\"), pidstr.c_str ());\n \t\t}\n \t      else\n \t\t{\n \t\t  fprintf_filtered (gdb_stdlog,\n \t\t\t\t    _(\"[Detaching vfork parent %s \"\n-\t\t\t\t      \"after child exit]\\n\"), pidstr);\n+\t\t\t\t      \"after child exit]\\n\"), pidstr.c_str ());\n \t\t}\n \t    }\n \n@@ -1154,7 +1154,7 @@ follow_exec (ptid_t ptid, char *exec_file_target)\n   /* What is this a.out's name?  */\n   process_ptid = ptid_t (pid);\n   printf_unfiltered (_(\"%s is executing new program: %s\\n\"),\n-\t\t     target_pid_to_str (process_ptid),\n+\t\t     target_pid_to_str (process_ptid).c_str (),\n \t\t     exec_file_target);\n \n   /* We've followed the inferior through an exec.  Therefore, the\n@@ -1668,7 +1668,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       if (debug_displaced)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"displaced: deferring step of %s\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \n       thread_step_over_chain_enqueue (tp);\n       return 0;\n@@ -1678,7 +1678,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       if (debug_displaced)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"displaced: stepping %s now\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n     }\n \n   displaced_step_clear (displaced);\n@@ -1831,7 +1831,7 @@ displaced_step_restore (struct displaced_step_inferior_state *displaced,\n \t\t     displaced->step_saved_copy.data (), len);\n   if (debug_displaced)\n     fprintf_unfiltered (gdb_stdlog, \"displaced: restored %s %s\\n\",\n-\t\t\ttarget_pid_to_str (ptid),\n+\t\t\ttarget_pid_to_str (ptid).c_str (),\n \t\t\tpaddress (displaced->step_gdbarch,\n \t\t\t\t  displaced->step_copy));\n }\n@@ -1985,7 +1985,7 @@ start_step_over (void)\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"[%s] has inconsistent state: \"\n \t\t\t  \"trap_expected=%d, resumed=%d, executing=%d\\n\",\n-\t\t\t  target_pid_to_str (tp->ptid),\n+\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n \t\t\t  tp->control.trap_expected,\n \t\t\t  tp->resumed,\n \t\t\t  tp->executing);\n@@ -1994,7 +1994,7 @@ start_step_over (void)\n       if (debug_infrun)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"infrun: resuming [%s] for step-over\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \n       /* keep_going_pass_signal skips the step-over if the breakpoint\n \t is no longer inserted.  In all-stop, we want to keep looking\n@@ -2253,7 +2253,8 @@ resume_1 (enum gdb_signal sig)\n \t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t      \"infrun: resume: thread %s has pending wait \"\n \t\t\t      \"status %s (currently_stepping=%d).\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid), statstr.c_str (),\n+\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t      statstr.c_str (),\n \t\t\t      currently_stepping (tp));\n \t}\n \n@@ -2265,7 +2266,8 @@ resume_1 (enum gdb_signal sig)\n       if (sig != GDB_SIGNAL_0)\n \t{\n \t  warning (_(\"Couldn't deliver signal %s to %s.\"),\n-\t\t   gdb_signal_to_name (sig), target_pid_to_str (tp->ptid));\n+\t\t   gdb_signal_to_name (sig),\n+\t\t   target_pid_to_str (tp->ptid).c_str ());\n \t}\n \n       tp->suspend.stop_signal = GDB_SIGNAL_0;\n@@ -2309,7 +2311,7 @@ resume_1 (enum gdb_signal sig)\n \t\t\t\"trap_expected=%d, current thread [%s] at %s\\n\",\n \t\t\tstep, gdb_signal_to_symbol_string (sig),\n \t\t\ttp->control.trap_expected,\n-\t\t\ttarget_pid_to_str (inferior_ptid),\n+\t\t\ttarget_pid_to_str (inferior_ptid).c_str (),\n \t\t\tpaddress (gdbarch, pc));\n \n   /* Normally, by the time we reach `resume', the breakpoints are either\n@@ -2558,7 +2560,7 @@ resume_1 (enum gdb_signal sig)\n       if (debug_infrun)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"infrun: resume: [%s] stepped breakpoint\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \n       tp->stepped_breakpoint = 1;\n \n@@ -2663,7 +2665,7 @@ clear_proceed_status_thread (struct thread_info *tp)\n   if (debug_infrun)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"infrun: clear_proceed_status_thread (%s)\\n\",\n-\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \n   /* If we're starting a new sequence, then the previous finished\n      single-step is no longer relevant.  */\n@@ -2676,7 +2678,7 @@ clear_proceed_status_thread (struct thread_info *tp)\n \t\t\t\t\"infrun: clear_proceed_status: pending \"\n \t\t\t\t\"event of %s was a finished step. \"\n \t\t\t\t\"Discarding.\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \n \t  tp->suspend.waitstatus_pending_p = 0;\n \t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n@@ -2690,7 +2692,8 @@ clear_proceed_status_thread (struct thread_info *tp)\n \t\t\t      \"infrun: clear_proceed_status_thread: thread %s \"\n \t\t\t      \"has pending wait status %s \"\n \t\t\t      \"(currently_stepping=%d).\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid), statstr.c_str (),\n+\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t      statstr.c_str (),\n \t\t\t      currently_stepping (tp));\n \t}\n     }\n@@ -2960,7 +2963,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: need to step-over [%s] first\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \n \t  thread_step_over_chain_enqueue (tp);\n \t}\n@@ -3005,7 +3008,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t      if (debug_infrun)\n \t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t    \"infrun: proceed: [%s] resumed\\n\",\n-\t\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \t      gdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n \t      continue;\n \t    }\n@@ -3015,14 +3018,14 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t      if (debug_infrun)\n \t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t    \"infrun: proceed: [%s] needs step-over\\n\",\n-\t\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \t      continue;\n \t    }\n \n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: proceed: resuming %s\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \n \t  reset_ecs (ecs, tp);\n \t  switch_to_thread (tp);\n@@ -3256,13 +3259,13 @@ print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n \t      waiton_ptid.lwp (),\n \t      waiton_ptid.tid ());\n   if (waiton_ptid.pid () != -1)\n-    stb.printf (\" [%s]\", target_pid_to_str (waiton_ptid));\n+    stb.printf (\" [%s]\", target_pid_to_str (waiton_ptid).c_str ());\n   stb.printf (\", status) =\\n\");\n   stb.printf (\"infrun:   %d.%ld.%ld [%s],\\n\",\n \t      result_ptid.pid (),\n \t      result_ptid.lwp (),\n \t      result_ptid.tid (),\n-\t      target_pid_to_str (result_ptid));\n+\t      target_pid_to_str (result_ptid).c_str ());\n   stb.printf (\"infrun:   %s\\n\", status_string.c_str ());\n \n   /* This uses %s in part to handle %'s in the text, but also to avoid\n@@ -3332,7 +3335,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n       if (debug_infrun)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"infrun: Waiting for specific thread %s.\\n\",\n-\t\t\t    target_pid_to_str (ptid));\n+\t\t\t    target_pid_to_str (ptid).c_str ());\n \n       /* We have a specific thread to check.  */\n       tp = find_thread_ptid (ptid);\n@@ -3357,7 +3360,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: PC of %s changed.  was=%s, now=%s\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid),\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str (),\n \t\t\t\tpaddress (gdbarch, tp->suspend.stop_pc),\n \t\t\t\tpaddress (gdbarch, pc));\n \t  discard = 1;\n@@ -3367,7 +3370,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: previous breakpoint of %s, at %s gone\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid),\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str (),\n \t\t\t\tpaddress (gdbarch, pc));\n \n \t  discard = 1;\n@@ -3378,7 +3381,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: pending event of %s cancelled.\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \n \t  tp->suspend.waitstatus.kind = TARGET_WAITKIND_SPURIOUS;\n \t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n@@ -3395,7 +3398,7 @@ do_target_wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t      \"infrun: Using pending wait status %s for %s.\\n\",\n \t\t\t      statstr.c_str (),\n-\t\t\t      target_pid_to_str (tp->ptid));\n+\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \t}\n \n       /* Now that we've selected our final event LWP, un-adjust its PC\n@@ -3870,9 +3873,9 @@ context_switch (execution_control_state *ecs)\n       && ecs->event_thread != inferior_thread ())\n     {\n       fprintf_unfiltered (gdb_stdlog, \"infrun: Switching context from %s \",\n-\t\t\t  target_pid_to_str (inferior_ptid));\n+\t\t\t  target_pid_to_str (inferior_ptid).c_str ());\n       fprintf_unfiltered (gdb_stdlog, \"to %s\\n\",\n-\t\t\t  target_pid_to_str (ecs->ptid));\n+\t\t\t  target_pid_to_str (ecs->ptid).c_str ());\n     }\n \n   switch_to_thread (ecs->event_thread);\n@@ -4312,7 +4315,7 @@ stop_all_threads (void)\n \t\t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t    \"infrun:   %s executing, \"\n \t\t\t\t\t    \"need stop\\n\",\n-\t\t\t\t\t    target_pid_to_str (t->ptid));\n+\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n \t\t      target_stop (t->ptid);\n \t\t      t->stop_requested = 1;\n \t\t    }\n@@ -4322,7 +4325,7 @@ stop_all_threads (void)\n \t\t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t    \"infrun:   %s executing, \"\n \t\t\t\t\t    \"already stopping\\n\",\n-\t\t\t\t\t    target_pid_to_str (t->ptid));\n+\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n \t\t    }\n \n \t\t  if (t->stop_requested)\n@@ -4333,7 +4336,7 @@ stop_all_threads (void)\n \t\t  if (debug_infrun)\n \t\t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\t\"infrun:   %s not executing\\n\",\n-\t\t\t\t\ttarget_pid_to_str (t->ptid));\n+\t\t\t\t\ttarget_pid_to_str (t->ptid).c_str ());\n \n \t\t  /* The thread may be not executing, but still be\n \t\t     resumed with a pending status to process.  */\n@@ -4367,7 +4370,7 @@ stop_all_threads (void)\n \t\t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t      \"infrun: %s exited while \"\n \t\t\t\t      \"stopping threads\\n\",\n-\t\t\t\t      target_pid_to_str (ptid));\n+\t\t\t\t      target_pid_to_str (ptid).c_str ());\n \t\t}\n \t    }\n \t  else\n@@ -4407,7 +4410,7 @@ stop_all_threads (void)\n \t\t\t\t\t      \"infrun: displaced-step of %s \"\n \t\t\t\t\t      \"canceled: adding back to the \"\n \t\t\t\t\t      \"step-over queue\\n\",\n-\t\t\t\t\t      target_pid_to_str (t->ptid));\n+\t\t\t\t\t      target_pid_to_str (t->ptid).c_str ());\n \t\t\t}\n \t\t      t->control.trap_expected = 0;\n \t\t      thread_step_over_chain_enqueue (t);\n@@ -4454,7 +4457,7 @@ stop_all_threads (void)\n \t\t\t\t\t  \"(currently_stepping=%d)\\n\",\n \t\t\t\t\t  paddress (target_gdbarch (),\n \t\t\t\t\t\t    t->suspend.stop_pc),\n-\t\t\t\t\t  target_pid_to_str (t->ptid),\n+\t\t\t\t\t  target_pid_to_str (t->ptid).c_str (),\n \t\t\t\t\t  currently_stepping (t));\n \t\t    }\n \t\t}\n@@ -5220,7 +5223,7 @@ restart_threads (struct thread_info *event_thread)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: \"\n \t\t\t\t\"[%s] is event thread\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  continue;\n \t}\n \n@@ -5230,7 +5233,7 @@ restart_threads (struct thread_info *event_thread)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: \"\n \t\t\t\t\"[%s] not meant to be running\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  continue;\n \t}\n \n@@ -5239,7 +5242,7 @@ restart_threads (struct thread_info *event_thread)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: [%s] resumed\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  gdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n \t  continue;\n \t}\n@@ -5250,7 +5253,7 @@ restart_threads (struct thread_info *event_thread)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: \"\n \t\t\t\t\"[%s] needs step-over\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  gdb_assert (!tp->resumed);\n \t  continue;\n \t}\n@@ -5262,7 +5265,7 @@ restart_threads (struct thread_info *event_thread)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: \"\n \t\t\t\t\"[%s] has pending status\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  tp->resumed = 1;\n \t  continue;\n \t}\n@@ -5277,15 +5280,15 @@ restart_threads (struct thread_info *event_thread)\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"thread [%s] needs a step-over, but not in \"\n \t\t\t  \"step-over queue\\n\",\n-\t\t\t  target_pid_to_str (tp->ptid));\n+\t\t\t  target_pid_to_str (tp->ptid).c_str ());\n \t}\n \n       if (currently_stepping (tp))\n \t{\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: [%s] was stepping\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  keep_going_stepped_thread (tp);\n \t}\n       else\n@@ -5296,7 +5299,7 @@ restart_threads (struct thread_info *event_thread)\n \t  if (debug_infrun)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: restart threads: [%s] continuing\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  reset_ecs (ecs, tp);\n \t  switch_to_thread (tp);\n \t  keep_going_pass_signal (ecs);\n@@ -5417,7 +5420,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t\t\t\t  \"(currently_stepping=%d)\\n\",\n \t\t\t\t  paddress (target_gdbarch (),\n \t\t\t\t\t    tp->suspend.stop_pc),\n-\t\t\t\t  target_pid_to_str (tp->ptid),\n+\t\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n \t\t\t\t  currently_stepping (tp));\n \t    }\n \n@@ -5580,7 +5583,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t\t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t      \"infrun: [%s] hit another thread's \"\n \t\t\t\t      \"single-step breakpoint\\n\",\n-\t\t\t\t      target_pid_to_str (ecs->ptid));\n+\t\t\t\t      target_pid_to_str (ecs->ptid).c_str ());\n \t\t}\n \t      ecs->hit_singlestep_breakpoint = 1;\n \t    }\n@@ -5592,7 +5595,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t  \"infrun: [%s] hit its \"\n \t\t\t\t  \"single-step breakpoint\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->ptid));\n+\t\t\t\t  target_pid_to_str (ecs->ptid).c_str ());\n \t    }\n \t}\n     }\n@@ -6842,7 +6845,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t    {\n \t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t  \"infrun: need to finish step-over of [%s]\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid));\n+\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t    }\n \t  keep_going (ecs);\n \t  return 1;\n@@ -6857,7 +6860,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t \"infrun: need to step [%s] over single-step \"\n \t\t\t\t \"breakpoint\\n\",\n-\t\t\t\t target_pid_to_str (ecs->ptid));\n+\t\t\t\t target_pid_to_str (ecs->ptid).c_str ());\n \t   }\n \t keep_going (ecs);\n \t return 1;\n@@ -6872,7 +6875,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t    {\n \t      fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t  \"infrun: thread [%s] still needs step-over\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid));\n+\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t    }\n \t  keep_going (ecs);\n \t  return 1;\n@@ -6923,7 +6926,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t      internal_error (__FILE__, __LINE__,\n \t\t\t      \"[%s] has inconsistent state: \"\n \t\t\t      \"trap_expected=%d\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid),\n+\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n \t\t\t      tp->control.trap_expected);\n \t    }\n \n@@ -7493,7 +7496,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"infrun: %s has trap_expected set, \"\n \t\t\t    \"resuming to collect trap\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid));\n+\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n \n       /* We haven't yet gotten our trap, and either: intercepted a\n \t non-signal event (e.g., a fork); or took a signal which we\n@@ -7515,7 +7518,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: step-over already in progress: \"\n \t\t\t\t\"step-over for %s deferred\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t  thread_step_over_chain_enqueue (tp);\n \t}\n       else\n@@ -7524,7 +7527,7 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"infrun: step-over in progress: \"\n \t\t\t\t\"resume of %s deferred\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid));\n+\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n \t}\n     }\n   else\n@@ -7692,7 +7695,7 @@ void\n print_exited_reason (struct ui_out *uiout, int exitstatus)\n {\n   struct inferior *inf = current_inferior ();\n-  const char *pidstr = target_pid_to_str (ptid_t (inf->pid));\n+  std::string pidstr = target_pid_to_str (ptid_t (inf->pid));\n \n   annotate_exited (exitstatus);\n   if (exitstatus)\n@@ -7702,7 +7705,7 @@ print_exited_reason (struct ui_out *uiout, int exitstatus)\n       uiout->text (\"[Inferior \");\n       uiout->text (plongest (inf->num));\n       uiout->text (\" (\");\n-      uiout->text (pidstr);\n+      uiout->text (pidstr.c_str ());\n       uiout->text (\") exited with code \");\n       uiout->field_fmt (\"exit-code\", \"0%o\", (unsigned int) exitstatus);\n       uiout->text (\"]\\n\");\n@@ -7715,7 +7718,7 @@ print_exited_reason (struct ui_out *uiout, int exitstatus)\n       uiout->text (\"[Inferior \");\n       uiout->text (plongest (inf->num));\n       uiout->text (\" (\");\n-      uiout->text (pidstr);\n+      uiout->text (pidstr.c_str ());\n       uiout->text (\") exited normally]\\n\");\n     }\n }\n@@ -8046,7 +8049,7 @@ normal_stop (void)\n \t{\n \t  target_terminal::ours_for_output ();\n \t  printf_filtered (_(\"[Switching to %s]\\n\"),\n-\t\t\t   target_pid_to_str (inferior_ptid));\n+\t\t\t   target_pid_to_str (inferior_ptid).c_str ());\n \t  annotate_thread_changed ();\n \t}\n       previous_inferior_ptid = inferior_ptid;"
    },
    {
      "sha": "dde63d5572f0b4f1664fb1b6ea85d219eb46cf6d",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 13,
      "deletions": 11,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -352,7 +352,7 @@ linux_fork_mourn_inferior (void)\n   last = find_last_fork ();\n   fork_load_infrun_state (last);\n   printf_filtered (_(\"[Switching to %s]\\n\"),\n-\t\t   target_pid_to_str (inferior_ptid));\n+\t\t   target_pid_to_str (inferior_ptid).c_str ());\n \n   /* If there's only one fork, switch back to non-fork mode.  */\n   if (one_fork_p ())\n@@ -371,7 +371,8 @@ linux_fork_detach (int from_tty)\n      fork.  */\n \n   if (ptrace (PTRACE_DETACH, inferior_ptid.pid (), 0, 0))\n-    error (_(\"Unable to detach %s\"), target_pid_to_str (inferior_ptid));\n+    error (_(\"Unable to detach %s\"),\n+\t   target_pid_to_str (inferior_ptid).c_str ());\n \n   delete_fork (inferior_ptid);\n \n@@ -384,7 +385,7 @@ linux_fork_detach (int from_tty)\n \n   if (from_tty)\n     printf_filtered (_(\"[Switching to %s]\\n\"),\n-\t\t     target_pid_to_str (inferior_ptid));\n+\t\t     target_pid_to_str (inferior_ptid).c_str ());\n \n   /* If there's only one fork, switch back to non-fork mode.  */\n   if (one_fork_p ())\n@@ -435,7 +436,7 @@ class scoped_switch_fork_info\n \tCATCH (ex, RETURN_MASK_ALL)\n \t  {\n \t    warning (_(\"Couldn't restore checkpoint state in %s: %s\"),\n-\t\t     target_pid_to_str (m_oldfp->ptid), ex.message);\n+\t\t     target_pid_to_str (m_oldfp->ptid).c_str (), ex.message);\n \t  }\n \tEND_CATCH\n       }\n@@ -504,14 +505,14 @@ delete_checkpoint_command (const char *args, int from_tty)\n Please switch to another checkpoint before deleting the current one\"));\n \n   if (ptrace (PTRACE_KILL, ptid.pid (), 0, 0))\n-    error (_(\"Unable to kill pid %s\"), target_pid_to_str (ptid));\n+    error (_(\"Unable to kill pid %s\"), target_pid_to_str (ptid).c_str ());\n \n   fi = find_fork_ptid (ptid);\n   gdb_assert (fi);\n   pptid = fi->parent_ptid;\n \n   if (from_tty)\n-    printf_filtered (_(\"Killed %s\\n\"), target_pid_to_str (ptid));\n+    printf_filtered (_(\"Killed %s\\n\"), target_pid_to_str (ptid).c_str ());\n \n   delete_fork (ptid);\n \n@@ -524,7 +525,8 @@ Please switch to another checkpoint before deleting the current one\"));\n       || (parent != NULL && parent->state == THREAD_STOPPED))\n     {\n       if (inferior_call_waitpid (pptid, ptid.pid ()))\n-        warning (_(\"Unable to wait pid %s\"), target_pid_to_str (ptid));\n+        warning (_(\"Unable to wait pid %s\"),\n+\t\t target_pid_to_str (ptid).c_str ());\n     }\n }\n \n@@ -545,10 +547,10 @@ detach_checkpoint_command (const char *args, int from_tty)\n Please switch to another checkpoint before detaching the current one\"));\n \n   if (ptrace (PTRACE_DETACH, ptid.pid (), 0, 0))\n-    error (_(\"Unable to detach %s\"), target_pid_to_str (ptid));\n+    error (_(\"Unable to detach %s\"), target_pid_to_str (ptid).c_str ());\n \n   if (from_tty)\n-    printf_filtered (_(\"Detached %s\\n\"), target_pid_to_str (ptid));\n+    printf_filtered (_(\"Detached %s\\n\"), target_pid_to_str (ptid).c_str ());\n \n   delete_fork (ptid);\n }\n@@ -577,7 +579,7 @@ info_checkpoints_command (const char *arg, int from_tty)\n \tprintf_filtered (\"  \");\n \n       ULONGEST pc = fi.pc;\n-      printf_filtered (\"%d %s\", fi.num, target_pid_to_str (fi.ptid));\n+      printf_filtered (\"%d %s\", fi.num, target_pid_to_str (fi.ptid).c_str ());\n       if (fi.num == 0)\n \tprintf_filtered (_(\" (main process)\"));\n       printf_filtered (_(\" at \"));\n@@ -730,7 +732,7 @@ linux_fork_context (struct fork_info *newfp, int from_tty)\n   insert_breakpoints ();\n \n   printf_filtered (_(\"Switching to %s\\n\"),\n-\t\t   target_pid_to_str (inferior_ptid));\n+\t\t   target_pid_to_str (inferior_ptid).c_str ());\n \n   print_stack_frame (get_selected_frame (NULL), 1, SRC_AND_LOC, 1);\n }"
    },
    {
      "sha": "58da62a79640b5d5784779bc4344408a572d1a73",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 53,
      "deletions": 56,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -1013,7 +1013,8 @@ exit_lwp (struct lwp_info *lp)\n   if (th)\n     {\n       if (print_thread_events)\n-\tprintf_unfiltered (_(\"[%s exited]\\n\"), target_pid_to_str (lp->ptid));\n+\tprintf_unfiltered (_(\"[%s exited]\\n\"),\n+\t\t\t   target_pid_to_str (lp->ptid).c_str ());\n \n       delete_thread (th);\n     }\n@@ -1149,7 +1150,7 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"PTRACE_ATTACH %s, 0, 0 (OK)\\n\",\n-\t\t\t\ttarget_pid_to_str (ptid));\n+\t\t\t\ttarget_pid_to_str (ptid).c_str ());\n \n \t  lp = add_lwp (ptid);\n \n@@ -1335,23 +1336,23 @@ get_detach_signal (struct lwp_info *lp)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"GPT: lwp %s has no pending signal\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (!signal_pass_state (signo))\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"GPT: lwp %s had signal %s, \"\n \t\t\t    \"but it is in no pass state\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid),\n+\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n \t\t\t    gdb_signal_to_string (signo));\n     }\n   else\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"GPT: lwp %s has pending signal %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid),\n+\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n \t\t\t    gdb_signal_to_string (signo));\n \n       return gdb_signal_to_host (signo);\n@@ -1375,15 +1376,15 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n   if (debug_linux_nat && lp->status)\n     fprintf_unfiltered (gdb_stdlog, \"DC:  Pending %s for %s on detach.\\n\",\n \t\t\tstrsignal (WSTOPSIG (lp->status)),\n-\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n   /* If there is a pending SIGSTOP, get rid of it.  */\n   if (lp->signalled)\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"DC: Sending SIGCONT to %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n \n       kill_lwp (lwpid, SIGCONT);\n       lp->signalled = 0;\n@@ -1438,15 +1439,16 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n \t}\n       else\n \t{\n-\t  error (_(\"Can't detach %s: %s\"), target_pid_to_str (lp->ptid),\n+\t  error (_(\"Can't detach %s: %s\"),\n+\t\t target_pid_to_str (lp->ptid).c_str (),\n \t\t safe_strerror (save_errno));\n \t}\n     }\n   else if (debug_linux_nat)\n     {\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"PTRACE_DETACH (%s, %s, 0) (OK)\\n\",\n-\t\t\t  target_pid_to_str (lp->ptid),\n+\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n \t\t\t  strsignal (signo));\n     }\n \n@@ -1608,14 +1610,14 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"RC: Not resuming %s (vfork parent)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t}\n       else if (!lwp_status_pending_p (lp))\n \t{\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"RC: Resuming sibling %s, %s, %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t\t(signo != GDB_SIGNAL_0\n \t\t\t\t ? strsignal (gdb_signal_to_host (signo))\n \t\t\t\t : \"0\"),\n@@ -1628,15 +1630,15 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"RC: Not resuming sibling %s (has pending)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t}\n     }\n   else\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"RC: Not resuming sibling %s (not stopped)\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n }\n \n@@ -1693,10 +1695,10 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"LLR: Preparing to %s %s, %s, inferior_ptid %s\\n\",\n \t\t\tstep ? \"step\" : \"resume\",\n-\t\t\ttarget_pid_to_str (ptid),\n+\t\t\ttarget_pid_to_str (ptid).c_str (),\n \t\t\t(signo != GDB_SIGNAL_0\n \t\t\t ? strsignal (gdb_signal_to_host (signo)) : \"0\"),\n-\t\t\ttarget_pid_to_str (inferior_ptid));\n+\t\t\ttarget_pid_to_str (inferior_ptid).c_str ());\n \n   /* A specific PTID means `step only this process id'.  */\n   resume_many = (minus_one_ptid == ptid\n@@ -1773,7 +1775,7 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"LLR: %s %s, %s (resume event thread)\\n\",\n \t\t\tstep ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t(signo != GDB_SIGNAL_0\n \t\t\t ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \n@@ -2174,7 +2176,7 @@ wait_lwp (struct lwp_info *lp)\n \t  thread_dead = 1;\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog, \"WL: %s vanished.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t}\n       if (pid != 0)\n \tbreak;\n@@ -2200,7 +2202,7 @@ wait_lwp (struct lwp_info *lp)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"WL: Thread group leader %s vanished.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t  break;\n \t}\n \n@@ -2223,7 +2225,7 @@ wait_lwp (struct lwp_info *lp)\n \t{\n \t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t      \"WL: waitpid %s received %s\\n\",\n-\t\t\t      target_pid_to_str (lp->ptid),\n+\t\t\t      target_pid_to_str (lp->ptid).c_str (),\n \t\t\t      status_to_str (status));\n \t}\n \n@@ -2248,7 +2250,7 @@ wait_lwp (struct lwp_info *lp)\n \t  thread_dead = 1;\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog, \"WL: %s exited.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t}\n     }\n \n@@ -2316,7 +2318,7 @@ stop_callback (struct lwp_info *lp)\n \t{\n \t  fprintf_unfiltered (gdb_stdlog,\n \t\t\t      \"SC:  kill %s **<SIGSTOP>**\\n\",\n-\t\t\t      target_pid_to_str (lp->ptid));\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n \t}\n       errno = 0;\n       ret = kill_lwp (lp->ptid.lwp (), SIGSTOP);\n@@ -2417,7 +2419,7 @@ maybe_clear_ignore_sigint (struct lwp_info *lp)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"MCIS: Clearing bogus flag for %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n       lp->ignore_sigint = 0;\n     }\n }\n@@ -2517,7 +2519,7 @@ stop_wait_callback (struct lwp_info *lp)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"PTRACE_CONT %s, 0, 0 (%s) \"\n \t\t\t\t\"(discarding SIGINT)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t\terrno ? safe_strerror (errno) : \"OK\");\n \n \t  return stop_wait_callback (lp);\n@@ -2533,7 +2535,7 @@ stop_wait_callback (struct lwp_info *lp)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SWC: Pending event %s in %s\\n\",\n \t\t\t\tstatus_to_str ((int) status),\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n \t  /* Save the sigtrap event.  */\n \t  lp->status = status;\n@@ -2547,7 +2549,7 @@ stop_wait_callback (struct lwp_info *lp)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SWC: Expected SIGSTOP caught for %s.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n \t  lp->signalled = 0;\n \n@@ -2594,7 +2596,7 @@ status_callback (struct lwp_info *lp)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SC: PC of %s changed.  was=%s, now=%s\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t\tpaddress (target_gdbarch (), lp->stop_pc),\n \t\t\t\tpaddress (target_gdbarch (), pc));\n \t  discard = 1;\n@@ -2606,7 +2608,7 @@ status_callback (struct lwp_info *lp)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SC: previous breakpoint of %s, at %s gone\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t\tpaddress (target_gdbarch (), lp->stop_pc));\n \n \t  discard = 1;\n@@ -2618,7 +2620,7 @@ status_callback (struct lwp_info *lp)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SC: pending event of %s cancelled.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n \t  lp->status = 0;\n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n@@ -2744,7 +2746,7 @@ save_stop_reason (struct lwp_info *lp)\n \t      if (debug_linux_nat)\n \t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t    \"CSBB: %s stopped by trace\\n\",\n-\t\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n \n \t      /* We may have single stepped an instruction that\n \t\t triggered a watchpoint.  In that case, on some\n@@ -2777,7 +2779,7 @@ save_stop_reason (struct lwp_info *lp)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"CSBB: %s stopped by software breakpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n \n       /* Back up the PC if necessary.  */\n       if (pc != sw_bp_pc)\n@@ -2791,14 +2793,14 @@ save_stop_reason (struct lwp_info *lp)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"CSBB: %s stopped by hardware breakpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (lp->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"CSBB: %s stopped by hardware watchpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   lp->stop_pc = pc;\n@@ -2875,7 +2877,7 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"SEL: Select single-step %s\\n\",\n-\t\t\t\ttarget_pid_to_str (event_lp->ptid));\n+\t\t\t\ttarget_pid_to_str (event_lp->ptid).c_str ());\n \t}\n     }\n \n@@ -3038,7 +3040,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"LLW: %s exited.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n \t  /* If there is at least one more LWP, then the exit signal\n \t     was not the end of the debugged application and should be\n@@ -3077,7 +3079,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"LLW: resume_stop SIGSTOP caught for %s.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \t}\n       else\n \t{\n@@ -3088,7 +3090,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t\t\t\t\"LLW: %s %s, 0, 0 (discard delayed SIGSTOP)\\n\",\n \t\t\t\tlp->step ?\n \t\t\t\t\"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid));\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n \n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n \t  gdb_assert (lp->resumed);\n@@ -3104,7 +3106,7 @@ linux_nat_filter_event (int lwpid, int status)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"LLW: Delayed SIGINT caught for %s.\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n \n       /* This is a delayed SIGINT.  */\n       lp->ignore_sigint = 0;\n@@ -3115,7 +3117,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t\t\t    \"LLW: %s %s, 0, 0 (discard SIGINT)\\n\",\n \t\t\t    lp->step ?\n \t\t\t    \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n       gdb_assert (lp->resumed);\n \n       /* Discard the event.  */\n@@ -3164,7 +3166,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t\t\t\t\"LLW: %s %s, %s (preempt 'handle')\\n\",\n \t\t\t\tlp->step ?\n \t\t\t\t\"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid),\n+\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n \t\t\t\t(signo != GDB_SIGNAL_0\n \t\t\t\t ? strsignal (gdb_signal_to_host (signo))\n \t\t\t\t : \"0\"));\n@@ -3293,7 +3295,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"LLW: Using pending wait status %s for %s.\\n\",\n \t\t\t    status_to_str (lp->status),\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   /* But if we don't find a pending event, we'll have to wait.  Always\n@@ -3453,7 +3455,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"LLW: trap ptid is %s.\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n@@ -3502,21 +3504,21 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"RSRL: NOT resuming LWP %s, not stopped\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (!lp->resumed)\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"RSRL: NOT resuming LWP %s, not resumed\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (lwp_status_pending_p (lp))\n     {\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"RSRL: NOT resuming LWP %s, has pending status\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid));\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n     }\n   else\n     {\n@@ -3542,7 +3544,7 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n \t\tfprintf_unfiltered (gdb_stdlog,\n \t\t\t\t    \"RSRL: resuming stopped-resumed LWP %s at \"\n \t\t\t\t    \"%s: step=%d\\n\",\n-\t\t\t\t    target_pid_to_str (lp->ptid),\n+\t\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n \t\t\t\t    paddress (gdbarch, pc),\n \t\t\t\t    lp->step);\n \n@@ -3571,7 +3573,7 @@ linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       std::string options_string = target_options_to_string (target_options);\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"linux_nat_wait: [%s], [%s]\\n\",\n-\t\t\t  target_pid_to_str (ptid),\n+\t\t\t  target_pid_to_str (ptid).c_str (),\n \t\t\t  options_string.c_str ());\n     }\n \n@@ -3943,18 +3945,13 @@ linux_nat_target::update_thread_list ()\n     }\n }\n \n-const char *\n+std::string\n linux_nat_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[64];\n-\n   if (ptid.lwp_p ()\n       && (ptid.pid () != ptid.lwp ()\n \t  || num_lwps (ptid.pid ()) > 1))\n-    {\n-      snprintf (buf, sizeof (buf), \"LWP %ld\", ptid.lwp ());\n-      return buf;\n-    }\n+    return string_printf (\"LWP %ld\", ptid.lwp ());\n \n   return normal_pid_to_str (ptid);\n }\n@@ -4434,7 +4431,7 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n       if (debug_linux_nat)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"LNSL: running -> suspending %s\\n\",\n-\t\t\t    target_pid_to_str (lwp->ptid));\n+\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n \n \n       if (lwp->last_resume_kind == resume_stop)\n@@ -4459,12 +4456,12 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n \t  if (find_thread_ptid (lwp->ptid)->stop_requested)\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"LNSL: already stopped/stop_requested %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lwp->ptid));\n+\t\t\t\ttarget_pid_to_str (lwp->ptid).c_str ());\n \t  else\n \t    fprintf_unfiltered (gdb_stdlog,\n \t\t\t\t\"LNSL: already stopped/no \"\n \t\t\t\t\"stop_requested yet %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lwp->ptid));\n+\t\t\t\ttarget_pid_to_str (lwp->ptid).c_str ());\n \t}\n     }\n   return 0;"
    },
    {
      "sha": "0c1695ad1020aa176752e6bb8e877bf815e63077",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -64,7 +64,7 @@ class linux_nat_target : public inf_ptrace_target\n \n   void update_thread_list () override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   const char *thread_name (struct thread_info *) override;\n "
    },
    {
      "sha": "77bc7142865ea196a4d96c7ac3c2036e38deca6e",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -414,16 +414,11 @@ linux_has_shared_address_space (struct gdbarch *gdbarch)\n \n /* This is how we want PTIDs from core files to be printed.  */\n \n-static const char *\n+static std::string\n linux_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n {\n-  static char buf[80];\n-\n   if (ptid.lwp () != 0)\n-    {\n-      snprintf (buf, sizeof (buf), \"LWP %ld\", ptid.lwp ());\n-      return buf;\n-    }\n+    return string_printf (\"LWP %ld\", ptid.lwp ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "186525a1e5844f7927737eeb3560bb1aa12610ac",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -95,7 +95,7 @@ class thread_db_target final : public target_ops\n   void resume (ptid_t, int, enum gdb_signal) override;\n   void mourn_inferior () override;\n   void update_thread_list () override;\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n   CORE_ADDR get_thread_local_address (ptid_t ptid,\n \t\t\t\t      CORE_ADDR load_module_addr,\n \t\t\t\t      CORE_ADDR offset) override;\n@@ -1631,20 +1631,17 @@ thread_db_target::update_thread_list ()\n   this->beneath ()->update_thread_list ();\n }\n \n-const char *\n+std::string\n thread_db_target::pid_to_str (ptid_t ptid)\n {\n   struct thread_info *thread_info = find_thread_ptid (ptid);\n \n   if (thread_info != NULL && thread_info->priv != NULL)\n     {\n-      static char buf[64];\n       thread_db_thread_info *priv = get_thread_db_thread_info (thread_info);\n \n-      snprintf (buf, sizeof (buf), \"Thread 0x%lx (LWP %ld)\",\n-\t\t(unsigned long) priv->tid, ptid.lwp ());\n-\n-      return buf;\n+      return string_printf (\"Thread 0x%lx (LWP %ld)\",\n+\t\t\t    (unsigned long) priv->tid, ptid.lwp ());\n     }\n \n   return beneath ()->pid_to_str (ptid);"
    },
    {
      "sha": "9dd35a4c8aafcce2e9c7bec459941dcb7831c47c",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -115,7 +115,7 @@ struct nto_procfs_target : public inf_child_target\n \n   void update_thread_list () override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   void interrupt () override;\n \n@@ -658,7 +658,7 @@ nto_procfs_target::files_info ()\n \n   printf_unfiltered (\"\\tUsing the running image of %s %s via %s.\\n\",\n \t\t     inf->attach_flag ? \"attached\" : \"child\",\n-\t\t     target_pid_to_str (inferior_ptid),\n+\t\t     target_pid_to_str (inferior_ptid).c_str (),\n \t\t     (nodestr != NULL) ? nodestr : \"local node\");\n }\n \n@@ -708,10 +708,10 @@ nto_procfs_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_unfiltered (\"Attaching to program `%s', %s\\n\", exec_file,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (\"Attaching to %s\\n\",\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n   inferior_ptid = do_attach (ptid_t (pid));\n   inf = current_inferior ();\n@@ -1455,25 +1455,22 @@ nto_procfs_target::pass_signals\n     }\n }\n \n-char *\n+std::string\n nto_procfs_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[1024];\n-  int pid, tid, n;\n+  int pid, tid;\n   struct tidinfo *tip;\n \n   pid = ptid.pid ();\n   tid = ptid.tid ();\n \n-  n = snprintf (buf, 1023, \"process %d\", pid);\n-\n #if 0\t\t\t\t/* NYI */\n   tip = procfs_thread_info (pid, tid);\n   if (tip != NULL)\n     snprintf (&buf[n], 1023, \" (state = 0x%02x)\", tip->state);\n #endif\n \n-  return buf;\n+  return string_printf (\"process %d\", pid);\n }\n \n /* to_can_run implementation for \"target procfs\".  Note this really"
    },
    {
      "sha": "0a99bd021df6b2edfa8fe4bded96c1da6e0c3528",
      "filename": "gdb/obsd-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 7,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/obsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/obsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/obsd-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -35,16 +35,11 @@\n \n #ifdef PT_GET_THREAD_FIRST\n \n-const char *\n+std::sring\n obsd_nat_target::pid_to_str (ptid_t ptid)\n {\n   if (ptid.lwp () != 0)\n-    {\n-      static char buf[64];\n-\n-      xsnprintf (buf, sizeof buf, \"thread %ld\", ptid.lwp ());\n-      return buf;\n-    }\n+    return string_printf (\"thread %ld\", ptid.lwp ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "c8016ed91218f0c6c4cdf603c29278b0833d5e7a",
      "filename": "gdb/obsd-nat.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/obsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/obsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/obsd-nat.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -25,7 +25,7 @@\n class obsd_nat_target : public inf_ptrace_target\n {\n   /* Override some methods to support threads.  */\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n   void update_thread_list () override;\n   ptid_t wait (ptid_t, struct target_waitstatus *, int) override;\n };"
    },
    {
      "sha": "2c4b812f86379f4f32bdcf0358d5e18e1897189a",
      "filename": "gdb/process-stratum-target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/process-stratum-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/process-stratum-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -35,7 +35,7 @@ process_stratum_target::thread_address_space (ptid_t ptid)\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"Can't determine the current \"\n \t\t      \"address space of thread %s\\n\"),\n-\t\t    target_pid_to_str (ptid));\n+\t\t    target_pid_to_str (ptid).c_str ());\n \n   return inf->aspace;\n }"
    },
    {
      "sha": "020336e5ba4b3bcf320e59a6a3192dcdeb9f7ad3",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 13,
      "deletions": 18,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -127,7 +127,7 @@ class procfs_target final : public inf_child_target\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   char *pid_to_exec_file (int pid) override;\n \n@@ -1884,10 +1884,10 @@ procfs_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_filtered (_(\"Attaching to program `%s', %s\\n\"),\n-\t\t\t exec_file, target_pid_to_str (ptid_t (pid)));\n+\t\t\t exec_file, target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_filtered (_(\"Attaching to %s\\n\"),\n-\t\t\t target_pid_to_str (ptid_t (pid)));\n+\t\t\t target_pid_to_str (ptid_t (pid)).c_str ());\n \n       fflush (stdout);\n     }\n@@ -1910,7 +1910,7 @@ procfs_target::detach (inferior *inf, int from_tty)\n \texec_file = \"\";\n \n       printf_filtered (_(\"Detaching from program: %s, %s\\n\"), exec_file,\n-\t\t       target_pid_to_str (ptid_t (pid)));\n+\t\t       target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n   do_detach ();\n@@ -2063,7 +2063,7 @@ procfs_target::fetch_registers (struct regcache *regcache, int regnum)\n \n   if (pi == NULL)\n     error (_(\"procfs: fetch_registers failed to find procinfo for %s\"),\n-\t   target_pid_to_str (ptid));\n+\t   target_pid_to_str (ptid).c_str ());\n \n   gregs = proc_get_gregs (pi);\n   if (gregs == NULL)\n@@ -2112,7 +2112,7 @@ procfs_target::store_registers (struct regcache *regcache, int regnum)\n \n   if (pi == NULL)\n     error (_(\"procfs: store_registers: failed to find procinfo for %s\"),\n-\t   target_pid_to_str (ptid));\n+\t   target_pid_to_str (ptid).c_str ());\n \n   gregs = proc_get_gregs (pi);\n   if (gregs == NULL)\n@@ -2285,7 +2285,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t  {\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n-\t\t\t\t\t target_pid_to_str (retval));\n+\t\t\t\t\t target_pid_to_str (retval).c_str ());\n \t\t    delete_thread (find_thread_ptid (retval));\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n@@ -2406,7 +2406,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t  {\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n-\t\t\t\t\t target_pid_to_str (retval));\n+\t\t\t\t\t target_pid_to_str (retval).c_str ());\n \t\t    delete_thread (find_thread_ptid (retval));\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n@@ -2804,7 +2804,7 @@ procfs_target::files_info ()\n \n   printf_filtered (_(\"\\tUsing the running image of %s %s via /proc.\\n\"),\n \t\t   inf->attach_flag? \"attached\": \"child\",\n-\t\t   target_pid_to_str (inferior_ptid));\n+\t\t   target_pid_to_str (inferior_ptid).c_str ());\n }\n \n /* Make it die.  Wait for it to die.  Clean up after it.  Note: this\n@@ -3189,20 +3189,15 @@ procfs_target::thread_alive (ptid_t ptid)\n   return true;\n }\n \n-/* Convert PTID to a string.  Returns the string in a static\n-   buffer.  */\n+/* Convert PTID to a string.  */\n \n-const char *\n+std::string\n procfs_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[80];\n-\n   if (ptid.lwp () == 0)\n-    xsnprintf (buf, sizeof (buf), \"process %d\", ptid.pid ());\n+    return string_printf (\"process %d\", ptid.pid ());\n   else\n-    xsnprintf (buf, sizeof (buf), \"LWP %ld\", ptid.lwp ());\n-\n-  return buf;\n+    return string_printf (\"LWP %ld\", ptid.lwp ());\n }\n \n /* Accepts an integer PID; Returns a string representing a file that"
    },
    {
      "sha": "1c749621ad6a615c257066e21b4a9545579e1a85",
      "filename": "gdb/progspace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/progspace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/progspace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -293,12 +293,12 @@ print_program_space (struct ui_out *uiout, int requested)\n \t\tprinted_header = 1;\n \t\tprintf_filtered (\"\\n\\tBound inferiors: ID %d (%s)\",\n \t\t\t\t inf->num,\n-\t\t\t\t target_pid_to_str (ptid_t (inf->pid)));\n+\t\t\t\t target_pid_to_str (ptid_t (inf->pid)).c_str ());\n \t      }\n \t    else\n \t      printf_filtered (\", ID %d (%s)\",\n \t\t\t       inf->num,\n-\t\t\t       target_pid_to_str (ptid_t (inf->pid)));\n+\t\t\t       target_pid_to_str (ptid_t (inf->pid)).c_str ());\n \t  }\n \n       uiout->text (\"\\n\");"
    },
    {
      "sha": "6636a89554b29ed488182a9a99afe9b59f2927bb",
      "filename": "gdb/ravenscar-thread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ravenscar-thread.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -110,7 +110,7 @@ struct ravenscar_thread_target final : public target_ops\n \n   const char *extra_thread_info (struct thread_info *) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   ptid_t get_ada_task_ptid (long lwp, long thread) override;\n \n@@ -406,13 +406,10 @@ ravenscar_thread_target::thread_alive (ptid_t ptid)\n   return true;\n }\n \n-const char *\n+std::string\n ravenscar_thread_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[30];\n-\n-  snprintf (buf, sizeof (buf), \"Thread %#x\", (int) ptid.tid ());\n-  return buf;\n+  return string_printf (\"Thread %#x\", (int) ptid.tid ());\n }\n \n void"
    },
    {
      "sha": "4c896944d7a8830a66777c51bfff7e25bd798291",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -596,7 +596,8 @@ record_btrace_target::info_record ()\n \n   printf_unfiltered (_(\"Recorded %u instructions in %u functions (%u gaps) \"\n \t\t       \"for thread %s (%s).\\n\"), insns, calls, gaps,\n-\t\t     print_thread_id (tp), target_pid_to_str (tp->ptid));\n+\t\t     print_thread_id (tp),\n+\t\t     target_pid_to_str (tp->ptid).c_str ());\n \n   if (btrace_is_replaying (tp))\n     printf_unfiltered (_(\"Replay in progress.  At instruction %u.\\n\"),\n@@ -1949,7 +1950,8 @@ record_btrace_resume_thread (struct thread_info *tp,\n   struct btrace_thread_info *btinfo;\n \n   DEBUG (\"resuming thread %s (%s): %x (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid), flag, btrace_thread_flag_to_str (flag));\n+\t target_pid_to_str (tp->ptid).c_str (), flag,\n+\t btrace_thread_flag_to_str (flag));\n \n   btinfo = &tp->btrace;\n \n@@ -2127,7 +2129,7 @@ record_btrace_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n {\n   enum btrace_thread_flag flag, cflag;\n \n-  DEBUG (\"resume %s: %s%s\", target_pid_to_str (ptid),\n+  DEBUG (\"resume %s: %s%s\", target_pid_to_str (ptid).c_str (),\n \t ::execution_direction == EXEC_REVERSE ? \"reverse-\" : \"\",\n \t step ? \"step\" : \"cont\");\n \n@@ -2214,7 +2216,7 @@ record_btrace_cancel_resume (struct thread_info *tp)\n \n   DEBUG (\"cancel resume thread %s (%s): %x (%s)\",\n \t print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid), flags,\n+\t target_pid_to_str (tp->ptid).c_str (), flags,\n \t btrace_thread_flag_to_str (flags));\n \n   tp->btrace.flags &= ~(BTHR_MOVE | BTHR_STOP);\n@@ -2442,7 +2444,7 @@ record_btrace_step_thread (struct thread_info *tp)\n   btinfo->flags &= ~(BTHR_MOVE | BTHR_STOP);\n \n   DEBUG (\"stepping thread %s (%s): %x (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid), flags,\n+\t target_pid_to_str (tp->ptid).c_str (), flags,\n \t btrace_thread_flag_to_str (flags));\n \n   /* We can't step without an execution history.  */\n@@ -2527,7 +2529,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n   std::vector<thread_info *> moving;\n   std::vector<thread_info *> no_history;\n \n-  DEBUG (\"wait %s (0x%x)\", target_pid_to_str (ptid), options);\n+  DEBUG (\"wait %s (0x%x)\", target_pid_to_str (ptid).c_str (), options);\n \n   /* As long as we're not replaying, just forward the request.  */\n   if ((::execution_direction != EXEC_REVERSE)\n@@ -2545,7 +2547,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     {\n       *status = btrace_step_no_resumed ();\n \n-      DEBUG (\"wait ended by %s: %s\", target_pid_to_str (null_ptid),\n+      DEBUG (\"wait ended by %s: %s\", target_pid_to_str (null_ptid).c_str (),\n \t     target_waitstatus_to_string (status).c_str ());\n \n       return null_ptid;\n@@ -2636,7 +2638,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   DEBUG (\"wait ended by thread %s (%s): %s\",\n \t print_thread_id (eventing),\n-\t target_pid_to_str (eventing->ptid),\n+\t target_pid_to_str (eventing->ptid).c_str (),\n \t target_waitstatus_to_string (status).c_str ());\n \n   return eventing->ptid;\n@@ -2647,7 +2649,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n void\n record_btrace_target::stop (ptid_t ptid)\n {\n-  DEBUG (\"stop %s\", target_pid_to_str (ptid));\n+  DEBUG (\"stop %s\", target_pid_to_str (ptid).c_str ());\n \n   /* As long as we're not replaying, just forward the request.  */\n   if ((::execution_direction != EXEC_REVERSE)"
    },
    {
      "sha": "8a6cb6b18e3fe0cb7e2c9e9a83e5da4408f1dc8b",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -124,7 +124,7 @@ struct gdbsim_target final\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   bool has_all_memory ()  override;\n   bool has_memory ()  override;\n@@ -1280,10 +1280,9 @@ gdbsim_target::thread_alive (ptid_t ptid)\n   return false;\n }\n \n-/* Convert a thread ID to a string.  Returns the string in a static\n-   buffer.  */\n+/* Convert a thread ID to a string.  */\n \n-const char *\n+std::string\n gdbsim_target::pid_to_str (ptid_t ptid)\n {\n   return normal_pid_to_str (ptid);"
    },
    {
      "sha": "657a4a25cac5609b4a7d3386d5be1fa0bd86421c",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 19,
      "deletions": 26,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -475,7 +475,7 @@ class remote_target : public process_stratum_target\n \n   void update_thread_list () override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   const char *extra_thread_info (struct thread_info *) override;\n \n@@ -5814,10 +5814,10 @@ extended_remote_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_unfiltered (_(\"Attaching to program: %s, %s\\n\"), exec_file,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (_(\"Attaching to %s\\n\"),\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n   xsnprintf (rs->buf.data (), get_remote_packet_size (), \"vAttach;%x\", pid);\n@@ -5836,14 +5836,14 @@ extended_remote_target::attach (const char *args, int from_tty)\n \t}\n       else if (strcmp (rs->buf.data (), \"OK\") != 0)\n \terror (_(\"Attaching to %s failed with: %s\"),\n-\t       target_pid_to_str (ptid_t (pid)),\n+\t       target_pid_to_str (ptid_t (pid)).c_str (),\n \t       rs->buf.data ());\n       break;\n     case PACKET_UNKNOWN:\n       error (_(\"This target does not support attaching to a process\"));\n     default:\n       error (_(\"Attaching to %s failed\"),\n-\t     target_pid_to_str (ptid_t (pid)));\n+\t     target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n   set_current_inferior (remote_add_inferior (0, pid, 1, 0));\n@@ -6638,7 +6638,7 @@ remote_target::remote_stop_ns (ptid_t ptid)\n   putpkt (rs->buf);\n   getpkt (&rs->buf, 0);\n   if (strcmp (rs->buf.data (), \"OK\") != 0)\n-    error (_(\"Stopping %s failed: %s\"), target_pid_to_str (ptid),\n+    error (_(\"Stopping %s failed: %s\"), target_pid_to_str (ptid).c_str (),\n \t   rs->buf.data ());\n }\n \n@@ -7096,7 +7096,7 @@ remote_target::remote_notif_remove_queued_reply (ptid_t ptid)\n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"notif: discard queued event: 'Stop' in %s\\n\",\n-\t\t\ttarget_pid_to_str (ptid));\n+\t\t\ttarget_pid_to_str (ptid).c_str ());\n \n   return result;\n }\n@@ -7134,7 +7134,7 @@ remote_target::push_stop_reply (struct stop_reply *new_event)\n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"notif: push 'Stop' %s to queue %d\\n\",\n-\t\t\ttarget_pid_to_str (new_event->ptid),\n+\t\t\ttarget_pid_to_str (new_event->ptid).c_str (),\n \t\t\tint (rs->stop_reply_queue.size ()));\n \n   mark_async_event_handler (rs->remote_async_inferior_event_token);\n@@ -11397,13 +11397,11 @@ init_remote_threadtests (void)\n \n #endif /* 0 */\n \n-/* Convert a thread ID to a string.  Returns the string in a static\n-   buffer.  */\n+/* Convert a thread ID to a string.  */\n \n-const char *\n+std::string\n remote_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[64];\n   struct remote_state *rs = get_remote_state ();\n \n   if (ptid == null_ptid)\n@@ -11422,27 +11420,22 @@ remote_target::pid_to_str (ptid_t ptid)\n \t attached to a process, and reporting yes to qAttached, hence\n \t no smart special casing here.  */\n       if (!remote_multi_process_p (rs))\n-\t{\n-\t  xsnprintf (buf, sizeof buf, \"Remote target\");\n-\t  return buf;\n-\t}\n+\treturn \"Remote target\";\n \n       return normal_pid_to_str (ptid);\n     }\n   else\n     {\n       if (magic_null_ptid == ptid)\n-\txsnprintf (buf, sizeof buf, \"Thread <main>\");\n+\treturn \"Thread <main>\";\n       else if (remote_multi_process_p (rs))\n \tif (ptid.lwp () == 0)\n \t  return normal_pid_to_str (ptid);\n \telse\n-\t  xsnprintf (buf, sizeof buf, \"Thread %d.%ld\",\n-\t\t     ptid.pid (), ptid.lwp ());\n+\t  return string_printf (\"Thread %d.%ld\",\n+\t\t\t\tptid.pid (), ptid.lwp ());\n       else\n-\txsnprintf (buf, sizeof buf, \"Thread %ld\",\n-\t\t   ptid.lwp ());\n-      return buf;\n+\treturn string_printf (\"Thread %ld\", ptid.lwp ());\n     }\n }\n \n@@ -13786,10 +13779,10 @@ remote_target::enable_btrace (ptid_t ptid, const struct btrace_config *conf)\n     {\n       if (rs->buf[0] == 'E' && rs->buf[1] == '.')\n \terror (_(\"Could not enable branch tracing for %s: %s\"),\n-\t       target_pid_to_str (ptid), &rs->buf[2]);\n+\t       target_pid_to_str (ptid).c_str (), &rs->buf[2]);\n       else\n \terror (_(\"Could not enable branch tracing for %s.\"),\n-\t       target_pid_to_str (ptid));\n+\t       target_pid_to_str (ptid).c_str ());\n     }\n \n   tinfo = XCNEW (struct btrace_target_info);\n@@ -13834,10 +13827,10 @@ remote_target::disable_btrace (struct btrace_target_info *tinfo)\n     {\n       if (rs->buf[0] == 'E' && rs->buf[1] == '.')\n \terror (_(\"Could not disable branch tracing for %s: %s\"),\n-\t       target_pid_to_str (tinfo->ptid), &rs->buf[2]);\n+\t       target_pid_to_str (tinfo->ptid).c_str (), &rs->buf[2]);\n       else\n \terror (_(\"Could not disable branch tracing for %s.\"),\n-\t       target_pid_to_str (tinfo->ptid));\n+\t       target_pid_to_str (tinfo->ptid).c_str ());\n     }\n \n   xfree (tinfo);"
    },
    {
      "sha": "68fa85130a1d917ad4992424958ef5b70dec69e0",
      "filename": "gdb/sol-thread.c",
      "status": "modified",
      "additions": 10,
      "deletions": 14,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol-thread.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -87,7 +87,7 @@ class sol_thread_target final : public target_ops\n   ptid_t wait (ptid_t, struct target_waitstatus *, int) override;\n   void resume (ptid_t, int, enum gdb_signal) override;\n   void mourn_inferior () override;\n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n   ptid_t get_ada_task_ptid (long lwp, long thread) override;\n \n   void fetch_registers (struct regcache *, int) override;\n@@ -997,33 +997,29 @@ ps_lgetLDT (struct ps_prochandle *ph, lwpid_t lwpid, struct ssd *pldt)\t/* ARI: e\n \n /* Convert PTID to printable form.  */\n \n-const char *\n+std::string\n sol_thread_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[100];\n-\n   if (ptid.tid_p ())\n     {\n       ptid_t lwp;\n \n       lwp = thread_to_lwp (ptid, -2);\n \n       if (lwp.pid () == -1)\n-\txsnprintf (buf, sizeof (buf), \"Thread %ld (defunct)\",\n-\t\t   ptid.tid ());\n+\treturn string_printf (\"Thread %ld (defunct)\",\n+\t\t\t      ptid.tid ());\n       else if (lwp.pid () != -2)\n-\txsnprintf (buf, sizeof (buf), \"Thread %ld (LWP %ld)\",\n-\t\t ptid.tid (), lwp.lwp ());\n+\treturn string_printf (\"Thread %ld (LWP %ld)\",\n+\t\t\t      ptid.tid (), lwp.lwp ());\n       else\n-\txsnprintf (buf, sizeof (buf), \"Thread %ld        \",\n-\t\t   ptid.tid ());\n+\treturn string_printf (\"Thread %ld        \",\n+\t\t\t      ptid.tid ());\n     }\n   else if (ptid.lwp () != 0)\n-    xsnprintf (buf, sizeof (buf), \"LWP    %ld        \", ptid.lwp ());\n+    return string_printf (\"LWP    %ld        \", ptid.lwp ());\n   else\n-    xsnprintf (buf, sizeof (buf), \"process %d    \", ptid.pid ());\n-\n-  return buf;\n+    return string_printf (\"process %d    \", ptid.pid ());\n }\n \f\n "
    },
    {
      "sha": "014b7d79a735dea42f4d638f962050163990f006",
      "filename": "gdb/sol2-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 8,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol2-tdep.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -40,10 +40,9 @@ sol2_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc)\n /* This is how we want PTIDs from Solaris core files to be\n    printed.  */\n \n-const char *\n+std::string\n sol2_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n {\n-  static char buf[80];\n   struct inferior *inf;\n   int pid;\n \n@@ -53,19 +52,15 @@ sol2_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n   if (pid != 0)\n     {\n       /* A thread.  */\n-      xsnprintf (buf, sizeof buf, \"LWP %ld\", ptid.lwp ());\n-      return buf;\n+      return string_printf (\"LWP %ld\", ptid.lwp ());\n     }\n \n   /* GDB didn't use to put a NT_PSTATUS note in Solaris cores.  If\n      that's missing, then we're dealing with a fake PID corelow.c made\n      up.  */\n   inf = find_inferior_ptid (ptid);\n   if (inf == NULL || inf->fake_pid_p)\n-    {\n-      xsnprintf (buf, sizeof buf, \"<core>\");\n-      return buf;\n-    }\n+    return \"<core>\";\n \n   /* Not fake; print as usual.  */\n   return normal_pid_to_str (ptid);"
    },
    {
      "sha": "cdc4bbfbe88c4e538313149fe9efbe9ceacdb874",
      "filename": "gdb/sol2-tdep.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol2-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/sol2-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol2-tdep.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -24,6 +24,6 @@ struct gdbarch;\n \n CORE_ADDR sol2_skip_solib_resolver (struct gdbarch *, CORE_ADDR);\n \n-const char *sol2_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n+std::string sol2_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid);\n \n #endif /* sol2-tdep.h */"
    },
    {
      "sha": "bef8a7f330d9744a167c2453da6448301c424f9f",
      "filename": "gdb/target-debug.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target-debug.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target-debug.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-debug.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -184,6 +184,8 @@\n   target_debug_do_print (host_address_to_string (X))\n #define target_debug_print_thread_info_pp(X)\t\t\\\n   target_debug_do_print (host_address_to_string (X))\n+#define target_debug_print_std_string(X) \\\n+  target_debug_do_print ((X).c_str ())\n \n static void\n target_debug_print_struct_target_waitstatus_p (struct target_waitstatus *status)"
    },
    {
      "sha": "3654f02e63ba1af7a6d866ef10fd9253ce2cbcf4",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -66,7 +66,7 @@ struct dummy_target : public target_ops\n   void program_signals (gdb::array_view<const unsigned char> arg0) override;\n   bool thread_alive (ptid_t arg0) override;\n   void update_thread_list () override;\n-  const char *pid_to_str (ptid_t arg0) override;\n+  std::string pid_to_str (ptid_t arg0) override;\n   const char *extra_thread_info (thread_info *arg0) override;\n   const char *thread_name (thread_info *arg0) override;\n   thread_info *thread_handle_to_thread_info (const gdb_byte *arg0, int arg1, inferior *arg2) override;\n@@ -233,7 +233,7 @@ struct debug_target : public target_ops\n   void program_signals (gdb::array_view<const unsigned char> arg0) override;\n   bool thread_alive (ptid_t arg0) override;\n   void update_thread_list () override;\n-  const char *pid_to_str (ptid_t arg0) override;\n+  std::string pid_to_str (ptid_t arg0) override;\n   const char *extra_thread_info (thread_info *arg0) override;\n   const char *thread_name (thread_info *arg0) override;\n   thread_info *thread_handle_to_thread_info (const gdb_byte *arg0, int arg1, inferior *arg2) override;\n@@ -1746,28 +1746,28 @@ debug_target::update_thread_list ()\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n \n-const char *\n+std::string\n target_ops::pid_to_str (ptid_t arg0)\n {\n   return this->beneath ()->pid_to_str (arg0);\n }\n \n-const char *\n+std::string\n dummy_target::pid_to_str (ptid_t arg0)\n {\n   return default_pid_to_str (this, arg0);\n }\n \n-const char *\n+std::string\n debug_target::pid_to_str (ptid_t arg0)\n {\n-  const char * result;\n+  std::string result;\n   fprintf_unfiltered (gdb_stdlog, \"-> %s->pid_to_str (...)\\n\", this->beneath ()->shortname ());\n   result = this->beneath ()->pid_to_str (arg0);\n   fprintf_unfiltered (gdb_stdlog, \"<- %s->pid_to_str (\", this->beneath ()->shortname ());\n   target_debug_print_ptid_t (arg0);\n   fputs_unfiltered (\") = \", gdb_stdlog);\n-  target_debug_print_const_char_p (result);\n+  target_debug_print_std_string (result);\n   fputs_unfiltered (\"\\n\", gdb_stdlog);\n   return result;\n }"
    },
    {
      "sha": "5f596b6a3c93c0b9fa0dc76a86d271fe9d5fa761",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -92,7 +92,7 @@ static int dummy_find_memory_regions (struct target_ops *self,\n static char *dummy_make_corefile_notes (struct target_ops *self,\n \t\t\t\t\tbfd *ignore1, int *ignore2);\n \n-static const char *default_pid_to_str (struct target_ops *ops, ptid_t ptid);\n+static std::string default_pid_to_str (struct target_ops *ops, ptid_t ptid);\n \n static enum exec_direction_kind default_execution_direction\n     (struct target_ops *self);\n@@ -744,24 +744,26 @@ target_translate_tls_address (struct objfile *objfile, CORE_ADDR offset)\n \t\t         \" thread-local variables in\\n\"\n \t\t         \"the shared library `%s'\\n\"\n \t\t         \"for %s\"),\n-\t\t       objfile_name (objfile), target_pid_to_str (ptid));\n+\t\t       objfile_name (objfile),\n+\t\t       target_pid_to_str (ptid).c_str ());\n \t      else\n \t\terror (_(\"The inferior has not yet allocated storage for\"\n \t\t         \" thread-local variables in\\n\"\n \t\t         \"the executable `%s'\\n\"\n \t\t         \"for %s\"),\n-\t\t       objfile_name (objfile), target_pid_to_str (ptid));\n+\t\t       objfile_name (objfile),\n+\t\t       target_pid_to_str (ptid).c_str ());\n \t      break;\n \t    case TLS_GENERIC_ERROR:\n \t      if (objfile_is_library)\n \t\terror (_(\"Cannot find thread-local storage for %s, \"\n \t\t         \"shared library %s:\\n%s\"),\n-\t\t       target_pid_to_str (ptid),\n+\t\t       target_pid_to_str (ptid).c_str (),\n \t\t       objfile_name (objfile), ex.message);\n \t      else\n \t\terror (_(\"Cannot find thread-local storage for %s, \"\n \t\t         \"executable file %s:\\n%s\"),\n-\t\t       target_pid_to_str (ptid),\n+\t\t       target_pid_to_str (ptid).c_str (),\n \t\t       objfile_name (objfile), ex.message);\n \t      break;\n \t    default:\n@@ -2073,7 +2075,7 @@ default_target_wait (struct target_ops *ops,\n   return minus_one_ptid;\n }\n \n-const char *\n+std::string\n target_pid_to_str (ptid_t ptid)\n {\n   return current_top_target ()->pid_to_str (ptid);\n@@ -3168,7 +3170,7 @@ target_announce_detach (int from_tty)\n \n   pid = inferior_ptid.pid ();\n   printf_unfiltered (_(\"Detaching from program: %s, %s\\n\"), exec_file,\n-\t\t     target_pid_to_str (ptid_t (pid)));\n+\t\t     target_pid_to_str (ptid_t (pid)).c_str ());\n }\n \n /* The inferior process has died.  Long live the inferior!  */\n@@ -3205,16 +3207,13 @@ generic_mourn_inferior (void)\n /* Convert a normal process ID to a string.  Returns the string in a\n    static buffer.  */\n \n-const char *\n+std::string\n normal_pid_to_str (ptid_t ptid)\n {\n-  static char buf[32];\n-\n-  xsnprintf (buf, sizeof buf, \"process %d\", ptid.pid ());\n-  return buf;\n+  return string_printf (\"process %d\", ptid.pid ());\n }\n \n-static const char *\n+static std::string\n default_pid_to_str (struct target_ops *ops, ptid_t ptid)\n {\n   return normal_pid_to_str (ptid);"
    },
    {
      "sha": "4f7a43e1a8b30a986e062d109540b156f498cb54",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -649,7 +649,7 @@ struct target_ops\n       TARGET_DEFAULT_RETURN (false);\n     virtual void update_thread_list ()\n       TARGET_DEFAULT_IGNORE ();\n-    virtual const char *pid_to_str (ptid_t)\n+    virtual std::string pid_to_str (ptid_t)\n       TARGET_DEFAULT_FUNC (default_pid_to_str);\n     virtual const char *extra_thread_info (thread_info *)\n       TARGET_DEFAULT_RETURN (NULL);\n@@ -1829,9 +1829,9 @@ extern int target_is_non_stop_p (void);\n    `process xyz', but on some systems it may contain\n    `process xyz thread abc'.  */\n \n-extern const char *target_pid_to_str (ptid_t ptid);\n+extern std::string target_pid_to_str (ptid_t ptid);\n \n-extern const char *normal_pid_to_str (ptid_t ptid);\n+extern std::string normal_pid_to_str (ptid_t ptid);\n \n /* Return a short string describing extra information about PID,\n    e.g. \"sleeping\", \"runnable\", \"running on LWP 3\".  Null return value"
    },
    {
      "sha": "91741c76f0d322b57aee824b4c6c60aaea1425e6",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 14,
      "deletions": 13,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -319,7 +319,7 @@ add_thread_with_info (ptid_t ptid, private_thread_info *priv)\n   result->priv.reset (priv);\n \n   if (print_thread_events)\n-    printf_unfiltered (_(\"[New %s]\\n\"), target_pid_to_str (ptid));\n+    printf_unfiltered (_(\"[New %s]\\n\"), target_pid_to_str (ptid).c_str ());\n \n   annotate_new_thread ();\n   return result;\n@@ -992,16 +992,17 @@ should_print_thread (const char *requested_threads, int default_inf_num,\n static std::string\n thread_target_id_str (thread_info *tp)\n {\n-  const char *target_id = target_pid_to_str (tp->ptid);\n+  std::string target_id = target_pid_to_str (tp->ptid);\n   const char *extra_info = target_extra_thread_info (tp);\n   const char *name = tp->name != nullptr ? tp->name : target_thread_name (tp);\n \n   if (extra_info != nullptr && name != nullptr)\n-    return string_printf (\"%s \\\"%s\\\" (%s)\", target_id, name, extra_info);\n+    return string_printf (\"%s \\\"%s\\\" (%s)\", target_id.c_str (), name,\n+\t\t\t  extra_info);\n   else if (extra_info != nullptr)\n-    return string_printf (\"%s (%s)\", target_id, extra_info);\n+    return string_printf (\"%s (%s)\", target_id.c_str (), extra_info);\n   else if (name != nullptr)\n-    return string_printf (\"%s \\\"%s\\\"\", target_id, name);\n+    return string_printf (\"%s \\\"%s\\\"\", target_id.c_str (), name);\n   else\n     return target_id;\n }\n@@ -1466,7 +1467,7 @@ thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n \t  if (!flags.quiet)\n \t    printf_filtered (_(\"\\nThread %s (%s):\\n\"),\n \t\t\t     print_thread_id (thr),\n-\t\t\t     target_pid_to_str (inferior_ptid));\n+\t\t\t     target_pid_to_str (inferior_ptid).c_str ());\n \t  printf_filtered (\"%s\", cmd_result.c_str ());\n \t}\n     }\n@@ -1477,7 +1478,7 @@ thr_try_catch_cmd (thread_info *thr, const char *cmd, int from_tty,\n \t  if (!flags.quiet)\n \t    printf_filtered (_(\"\\nThread %s (%s):\\n\"),\n \t\t\t     print_thread_id (thr),\n-\t\t\t     target_pid_to_str (inferior_ptid));\n+\t\t\t     target_pid_to_str (inferior_ptid).c_str ());\n \t  if (flags.cont)\n \t    printf_filtered (\"%s\\n\", ex.message);\n \t  else\n@@ -1675,11 +1676,11 @@ thread_command (const char *tidstr, int from_tty)\n \t  if (tp->state == THREAD_EXITED)\n \t    printf_filtered (_(\"[Current thread is %s (%s) (exited)]\\n\"),\n \t\t\t     print_thread_id (tp),\n-\t\t\t     target_pid_to_str (inferior_ptid));\n+\t\t\t     target_pid_to_str (inferior_ptid).c_str ());\n \t  else\n \t    printf_filtered (_(\"[Current thread is %s (%s)]\\n\"),\n \t\t\t     print_thread_id (tp),\n-\t\t\t     target_pid_to_str (inferior_ptid));\n+\t\t\t     target_pid_to_str (inferior_ptid).c_str ());\n \t}\n       else\n \terror (_(\"No stack.\"));\n@@ -1756,11 +1757,11 @@ thread_find_command (const char *arg, int from_tty)\n \t  match++;\n \t}\n \n-      tmp = target_pid_to_str (tp->ptid);\n-      if (tmp != NULL && re_exec (tmp))\n+      std::string name = target_pid_to_str (tp->ptid);\n+      if (!name.empty () && re_exec (name.c_str ()))\n \t{\n \t  printf_filtered (_(\"Thread %s has target id '%s'\\n\"),\n-\t\t\t   print_thread_id (tp), tmp);\n+\t\t\t   print_thread_id (tp), name.c_str ());\n \t  match++;\n \t}\n \n@@ -1824,7 +1825,7 @@ print_selected_thread_frame (struct ui_out *uiout,\n \t  uiout->text (\"[Switching to thread \");\n \t  uiout->field_string (\"new-thread-id\", print_thread_id (tp));\n \t  uiout->text (\" (\");\n-\t  uiout->text (target_pid_to_str (inferior_ptid));\n+\t  uiout->text (target_pid_to_str (inferior_ptid).c_str ());\n \t  uiout->text (\")]\");\n \t}\n     }"
    },
    {
      "sha": "b10b0649e9c571c241a7eb4bb49a66fd585b2921",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -1548,11 +1548,11 @@ print_inferior_quit_action (struct inferior *inf, void *arg)\n   if (inf->attach_flag)\n     fprintf_filtered (stb,\n \t\t      _(\"\\tInferior %d [%s] will be detached.\\n\"), inf->num,\n-\t\t      target_pid_to_str (ptid_t (inf->pid)));\n+\t\t      target_pid_to_str (ptid_t (inf->pid)).c_str ());\n   else\n     fprintf_filtered (stb,\n \t\t      _(\"\\tInferior %d [%s] will be killed.\\n\"), inf->num,\n-\t\t      target_pid_to_str (ptid_t (inf->pid)));\n+\t\t      target_pid_to_str (ptid_t (inf->pid)).c_str ());\n \n   return 0;\n }"
    },
    {
      "sha": "b85b7a5d43771bd4635dbd3755a58a15d2c5bba0",
      "filename": "gdb/tui/tui-stack.c",
      "status": "modified",
      "additions": 5,
      "deletions": 1,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/tui/tui-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/tui/tui-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-stack.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -72,10 +72,14 @@ tui_make_status_line (struct tui_locator_element *loc)\n   int pid_width;\n   int line_width;\n \n+  std::string pid_name_holder;\n   if (inferior_ptid == null_ptid)\n     pid_name = \"No process\";\n   else\n-    pid_name = target_pid_to_str (inferior_ptid);\n+    {\n+      pid_name_holder = target_pid_to_str (inferior_ptid);\n+      pid_name = pid_name_holder.c_str ();\n+    }\n \n   target_width = strlen (target_shortname);\n   if (target_width > MAX_TARGET_WIDTH)"
    },
    {
      "sha": "5caaa3b56508aff544db9ceb25aaa68dc6d0178b",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 9,
      "deletions": 14,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -341,7 +341,7 @@ struct windows_nat_target final : public x86_nat_target<inf_child_target>\n \n   bool thread_alive (ptid_t ptid) override;\n \n-  const char *pid_to_str (ptid_t) override;\n+  std::string pid_to_str (ptid_t) override;\n \n   void interrupt () override;\n \n@@ -525,10 +525,11 @@ windows_delete_thread (ptid_t ptid, DWORD exit_code, bool main_thread_p)\n      here as well.  */\n \n   if (info_verbose)\n-    printf_unfiltered (\"[Deleting %s]\\n\", target_pid_to_str (ptid));\n+    printf_unfiltered (\"[Deleting %s]\\n\", target_pid_to_str (ptid).c_str ());\n   else if (print_thread_events && !main_thread_p)\n     printf_unfiltered (_(\"[%s exited with code %u]\\n\"),\n-\t\t       target_pid_to_str (ptid), (unsigned) exit_code);\n+\t\t       target_pid_to_str (ptid).c_str (),\n+\t\t       (unsigned) exit_code);\n \n   delete_thread (find_thread_ptid (ptid));\n \n@@ -2011,10 +2012,10 @@ windows_nat_target::attach (const char *args, int from_tty)\n \n       if (exec_file)\n \tprintf_unfiltered (\"Attaching to program `%s', %s\\n\", exec_file,\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n       else\n \tprintf_unfiltered (\"Attaching to %s\\n\",\n-\t\t\t   target_pid_to_str (ptid_t (pid)));\n+\t\t\t   target_pid_to_str (ptid_t (pid)).c_str ());\n     }\n \n   do_initial_windows_stuff (this, pid, 1);\n@@ -2142,7 +2143,7 @@ windows_nat_target::files_info ()\n \n   printf_unfiltered (\"\\tUsing the running image of %s %s.\\n\",\n \t\t     inf->attach_flag ? \"attached\" : \"child\",\n-\t\t     target_pid_to_str (inferior_ptid));\n+\t\t     target_pid_to_str (inferior_ptid).c_str ());\n }\n \n /* Modify CreateProcess parameters for use of a new separate console.\n@@ -2934,17 +2935,11 @@ windows_nat_target::close ()\n }\n \n /* Convert pid to printable format.  */\n-const char *\n+std::string\n windows_nat_target::pid_to_str (ptid_t ptid)\n {\n-  static char buf[80];\n-\n   if (ptid.tid () != 0)\n-    {\n-      snprintf (buf, sizeof (buf), \"Thread %d.0x%lx\",\n-\t\tptid.pid (), ptid.tid ());\n-      return buf;\n-    }\n+    return string_printf (\"Thread %d.0x%lx\", ptid.pid (), ptid.tid ());\n \n   return normal_pid_to_str (ptid);\n }"
    },
    {
      "sha": "42083e789a580811070645ddbaaae267b9608470",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -327,7 +327,7 @@ display_one_tib (ptid_t ptid)\n   if (target_get_tib_address (ptid, &thread_local_base) == 0)\n     {\n       printf_filtered (_(\"Unable to get thread local base for %s\\n\"),\n-\ttarget_pid_to_str (ptid));\n+\t\t       target_pid_to_str (ptid).c_str ());\n       return -1;\n     }\n \n@@ -336,13 +336,13 @@ display_one_tib (ptid_t ptid)\n     {\n       printf_filtered (_(\"Unable to read thread information \"\n \t\t\t \"block for %s at address %s\\n\"),\n-\ttarget_pid_to_str (ptid), \n-\tpaddress (target_gdbarch (), thread_local_base));\n+\t\t       target_pid_to_str (ptid).c_str (), \n+\t\t       paddress (target_gdbarch (), thread_local_base));\n       return -1;\n     }\n \n   printf_filtered (_(\"Thread Information Block %s at %s\\n\"),\n-\t\t   target_pid_to_str (ptid),\n+\t\t   target_pid_to_str (ptid).c_str (),\n \t\t   paddress (target_gdbarch (), thread_local_base));\n \n   index = (gdb_byte *) tib;"
    },
    {
      "sha": "9a451e0e1aa0a41d49273c34231d6ef0ad95ae0f",
      "filename": "gdb/x86-linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/x86-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a068643d69ce0f25d5f7cbdaa1d0a3211d72c081/gdb/x86-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/x86-linux-nat.c?ref=a068643d69ce0f25d5f7cbdaa1d0a3211d72c081",
      "patch": "@@ -224,7 +224,7 @@ x86_linux_nat_target::enable_btrace (ptid_t ptid,\n   CATCH (exception, RETURN_MASK_ERROR)\n     {\n       error (_(\"Could not enable branch tracing for %s: %s\"),\n-\t     target_pid_to_str (ptid), exception.message);\n+\t     target_pid_to_str (ptid).c_str (), exception.message);\n     }\n   END_CATCH\n "
    }
  ]
}