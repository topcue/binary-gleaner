{
  "sha": "bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmY4MDkzMTA4MTY0YTdlZDdmZGY0YzZkYzc1MWUwYjIwNDNjYWY3Yg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-06-11T22:28:32Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-13T00:46:52Z"
    },
    "message": "gdb: introduce intrusive_list, make thread_info use it\n\nGDB currently has several objects that are put in a singly linked list,\nby having the object's type have a \"next\" pointer directly.  For\nexample, struct thread_info and struct inferior.  Because these are\nsimply-linked lists, and we don't keep track of a \"tail\" pointer, when\nwe want to append a new element on the list, we need to walk the whole\nlist to find the current tail.  It would be nice to get rid of that\nwalk.  Removing elements from such lists also requires a walk, to find\nthe \"previous\" position relative to the element being removed.  To\neliminate the need for that walk, we could make those lists\ndoubly-linked, by adding a \"prev\" pointer alongside \"next\".  It would be\nnice to avoid the boilerplate associated with maintaining such a list\nmanually, though.  That is what the new intrusive_list type addresses.\n\nWith an intrusive list, it's also possible to move items out of the\nlist without destroying them, which is interesting in our case for\nexample for threads, when we exit them, but can't destroy them\nimmediately.  We currently keep exited threads on the thread list, but\nwe could change that which would simplify some things.\n\nNote that with std::list, element removal is O(N).  I.e., with\nstd::list, we need to walk the list to find the iterator pointing to\nthe position to remove.  However, we could store a list iterator\ninside the object as soon as we put the object in the list, to address\nit, because std::list iterators are not invalidated when other\nelements are added/removed.  However, if you need to put the same\nobject in more than one list, then std::list<object> doesn't work.\nYou need to instead use std::list<object *>, which is less efficient\nfor requiring extra memory allocations.  For an example of an object\nin multiple lists, see the step_over_next/step_over_prev fields in\nthread_info:\n\n  /* Step-over chain.  A thread is in the step-over queue if these are\n     non-NULL.  If only a single thread is in the chain, then these\n     fields point to self.  */\n  struct thread_info *step_over_prev = NULL;\n  struct thread_info *step_over_next = NULL;\n\nThe new intrusive_list type gives us the advantages of an intrusive\nlinked list, while avoiding the boilerplate associated with manually\nmaintaining it.\n\nintrusive_list's API follows the standard container interface, and thus\nstd::list's interface.  It is based the API of Boost's intrusive list,\nhere:\n\n https://www.boost.org/doc/libs/1_73_0/doc/html/boost/intrusive/list.html\n\nOur implementation is relatively simple, while Boost's is complicated\nand intertwined due to a lot of customization options, which our version\ndoesn't have.\n\nThe easiest way to use an intrusive_list is to make the list's element\ntype inherit from intrusive_node.  This adds a prev/next pointers to\nthe element type.  However, to support putting the same object in more\nthan one list, intrusive_list supports putting the \"node\" info as a\nfield member, so you can have more than one such nodes, one per list.\n\nAs a first guinea pig, this patch makes the per-inferior thread list use\nintrusive_list using the base class method.\n\nUnlike Boost's implementation, ours is not a circular list.  An earlier\nversion of the patch was circular: the intrusive_list type included an\nintrusive_list_node \"head\".  In this design, a node contained pointers\nto the previous and next nodes, not the previous and next elements.\nThis wasn't great for when debugging GDB with GDB, as it was difficult\nto get from a pointer to the node to a pointer to the element.  With the\ndesign proposed in this patch, nodes contain pointers to the previous\nand next elements, making it easy to traverse the list by hand and\ninspect each element.\n\nThe intrusive_list object contains pointers to the first and last\nelements of the list.  They are nullptr if the list is empty.\nEach element's node contains a pointer to the previous and next\nelements.  The first element's previous pointer is nullptr and the last\nelement's next pointer is nullptr.  Therefore, if there's a single\nelement in the list, both its previous and next pointers are nullptr.\nTo differentiate such an element from an element that is not linked into\na list, the previous and next pointers contain a special value (-1) when\nthe node is not linked.  This is necessary to be able to reliably tell\nif a given node is currently linked or not.\n\nA begin() iterator points to the first item in the list.  An end()\niterator contains nullptr.  This makes iteration until end naturally\nwork, as advancing past the last element will make the iterator contain\nnullptr, making it equal to the end iterator.  If the list is empty,\na begin() iterator will contain nullptr from the start, and therefore be\nimmediately equal to the end.\n\nIterating on an intrusive_list yields references to objects (e.g.\n`thread_info&`).  The rest of GDB currently expects iterators and ranges\nto yield pointers (e.g. `thread_info*`).  To bridge the gap, add the\nreference_to_pointer_iterator type.  It is used to define\ninf_threads_iterator.\n\nAdd a Python pretty-printer, to help inspecting intrusive lists when\ndebugging GDB with GDB.  Here's an example of the output:\n\n    (top-gdb) p current_inferior_.m_obj.thread_list\n    $1 = intrusive list of thread_info = {0x61700002c000, 0x617000069080, 0x617000069400, 0x61700006d680, 0x61700006eb80}\n\nIt's not possible with current master, but with this patch [1] that I\nhope will be merged eventually, it's possible to index the list and\naccess the pretty-printed value's children:\n\n    (top-gdb) p current_inferior_.m_obj.thread_list[1]\n    $2 = (thread_info *) 0x617000069080\n    (top-gdb) p current_inferior_.m_obj.thread_list[1].ptid\n    $3 = {\n      m_pid = 406499,\n      m_lwp = 406503,\n      m_tid = 0\n    }\n\nEven though iterating the list in C++ yields references, the Python\npretty-printer yields pointers.  The reason for this is that the output\nof printing the thread list above would be unreadable, IMO, if each\nthread_info object was printed in-line, since they contain so much\ninformation.  I think it's more useful to print pointers, and let the\nuser drill down as needed.\n\n[1] https://sourceware.org/pipermail/gdb-patches/2021-April/178050.html\n\nCo-Authored-By: Simon Marchi <simon.marchi@efficios.com>\nChange-Id: I3412a14dc77f25876d742dab8f44e0ba7c7586c0",
    "tree": {
      "sha": "0b37758a65adfb5e6c26fb17cf52e3976936f8c4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0b37758a65adfb5e6c26fb17cf52e3976936f8c4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c9e7dfb64f8c8a6fe4788b15b23b709f87827a39",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9e7dfb64f8c8a6fe4788b15b23b709f87827a39",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c9e7dfb64f8c8a6fe4788b15b23b709f87827a39"
    }
  ],
  "stats": {
    "total": 1645,
    "additions": 1561,
    "deletions": 84
  },
  "files": [
    {
      "sha": "2274b9b6a61a32ce641bd0d08305ca59118e2358",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -449,6 +449,7 @@ SELFTESTS_SRCS = \\\n \tunittests/function-view-selftests.c \\\n \tunittests/gdb_tilde_expand-selftests.c \\\n \tunittests/gmp-utils-selftests.c \\\n+\tunittests/intrusive_list-selftests.c \\\n \tunittests/lookup_name_info-selftests.c \\\n \tunittests/memory-map-selftests.c \\\n \tunittests/memrange-selftests.c \\"
    },
    {
      "sha": "15dbf385654fc1e856a3b63c45f0dbb40bd6fcb6",
      "filename": "gdb/gdb-gdb.py.in",
      "status": "modified",
      "additions": 95,
      "deletions": 3,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/gdb-gdb.py.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/gdb-gdb.py.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb-gdb.py.in?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -276,16 +276,108 @@ class CoreAddrPrettyPrinter:\n         return hex(int(self._val))\n \n \n+class IntrusiveListPrinter:\n+    \"\"\"Print a struct intrusive_list.\"\"\"\n+\n+    def __init__(self, val):\n+        self._val = val\n+\n+        # Type of linked items.\n+        self._item_type = self._val.type.template_argument(0)\n+        self._node_ptr_type = gdb.lookup_type(\n+            \"intrusive_list_node<{}>\".format(self._item_type.tag)\n+        ).pointer()\n+\n+        # Type of value -> node converter.\n+        self._conv_type = self._val.type.template_argument(1)\n+\n+        if self._uses_member_node():\n+            # The second template argument of intrusive_member_node is a member\n+            # pointer value.  Its value is the offset of the node member in the\n+            # enclosing type.\n+            member_node_ptr = self._conv_type.template_argument(1)\n+            member_node_ptr = member_node_ptr.cast(gdb.lookup_type(\"int\"))\n+            self._member_node_offset = int(member_node_ptr)\n+\n+            # This is only needed in _as_node_ptr if using a member node.  Look it\n+            # up here so we only do it once.\n+            self._char_ptr_type = gdb.lookup_type(\"char\").pointer()\n+\n+    def display_hint(self):\n+        return \"array\"\n+\n+    def _uses_member_node(self):\n+        \"\"\"Return True if the list items use a node as a member, False if\n+        they use a node as a base class.\n+        \"\"\"\n+\n+        if self._conv_type.name.startswith(\"intrusive_member_node<\"):\n+            return True\n+        elif self._conv_type.name.startswith(\"intrusive_base_node<\"):\n+            return False\n+        else:\n+            raise RuntimeError(\n+                \"Unexpected intrusive_list value -> node converter type: {}\".format(\n+                    self._conv_type.name\n+                )\n+            )\n+\n+    def to_string(self):\n+        s = \"intrusive list of {}\".format(self._item_type)\n+\n+        if self._uses_member_node():\n+            node_member = self._conv_type.template_argument(1)\n+            s += \", linked through {}\".format(node_member)\n+\n+        return s\n+\n+    def _as_node_ptr(self, elem_ptr):\n+        \"\"\"Given ELEM_PTR, a pointer to a list element, return a pointer to the\n+        corresponding intrusive_list_node.\n+        \"\"\"\n+\n+        assert elem_ptr.type.code == gdb.TYPE_CODE_PTR\n+\n+        if self._uses_member_node():\n+            # Node as a member: add the member node offset from to the element's\n+            # address to get the member node's address.\n+            elem_char_ptr = elem_ptr.cast(self._char_ptr_type)\n+            node_char_ptr = elem_char_ptr + self._member_node_offset\n+            return node_char_ptr.cast(self._node_ptr_type)\n+        else:\n+            # Node as a base: just casting from node pointer to item pointer\n+            # will adjust the pointer value.\n+            return elem_ptr.cast(self._node_ptr_type)\n+\n+    def _children_generator(self):\n+        \"\"\"Generator that yields one tuple per list item.\"\"\"\n+\n+        elem_ptr = self._val[\"m_front\"]\n+        idx = 0\n+        while elem_ptr != 0:\n+            yield (str(idx), elem_ptr.dereference())\n+            node_ptr = self._as_node_ptr(elem_ptr)\n+            elem_ptr = node_ptr[\"next\"]\n+            idx += 1\n+\n+    def children(self):\n+        return self._children_generator()\n+\n+\n def type_lookup_function(val):\n     \"\"\"A routine that returns the correct pretty printer for VAL\n     if appropriate.  Returns None otherwise.\n     \"\"\"\n-    if val.type.tag == \"type\":\n+    tag = val.type.tag\n+    name = val.type.name\n+    if tag == \"type\":\n         return StructTypePrettyPrinter(val)\n-    elif val.type.tag == \"main_type\":\n+    elif tag == \"main_type\":\n         return StructMainTypePrettyPrinter(val)\n-    elif val.type.name == \"CORE_ADDR\":\n+    elif name == \"CORE_ADDR\":\n         return CoreAddrPrettyPrinter(val)\n+    elif tag is not None and tag.startswith(\"intrusive_list<\"):\n+        return IntrusiveListPrinter(val)\n     return None\n \n "
    },
    {
      "sha": "1305b20ca497312a5c16b5c37b839e09cc170847",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -33,6 +33,7 @@ struct symtab;\n #include \"gdbsupport/common-gdbthread.h\"\n #include \"gdbsupport/forward-scope-exit.h\"\n #include \"displaced-stepping.h\"\n+#include \"gdbsupport/intrusive_list.h\"\n \n struct inferior;\n struct process_stratum_target;\n@@ -222,9 +223,12 @@ struct private_thread_info\n    delete_thread).  All other thread references are considered weak\n    references.  Placing a thread in the thread list is an implicit\n    strong reference, and is thus not accounted for in the thread's\n-   refcount.  */\n+   refcount.\n \n-class thread_info : public refcounted_object\n+   The intrusive_list_node base links threads in a per-inferior list.  */\n+\n+class thread_info : public refcounted_object,\n+\t\t    public intrusive_list_node<thread_info>\n {\n public:\n   explicit thread_info (inferior *inf, ptid_t ptid);\n@@ -235,7 +239,6 @@ class thread_info : public refcounted_object\n   /* Mark this thread as running and notify observers.  */\n   void set_running (bool running);\n \n-  struct thread_info *next = NULL;\n   ptid_t ptid;\t\t\t/* \"Actual process id\";\n \t\t\t\t    In fact, this may be overloaded with \n \t\t\t\t    kernel thread id, etc.  */\n@@ -435,6 +438,10 @@ extern void delete_thread (struct thread_info *thread);\n    this thread belonged to has already exited, for example.  */\n extern void delete_thread_silent (struct thread_info *thread);\n \n+/* Mark the thread exited, but don't delete it or remove it from the\n+   inferior thread list.  */\n+extern void set_thread_exited (thread_info *tp, bool silent);\n+\n /* Delete a step_resume_breakpoint from the thread database.  */\n extern void delete_step_resume_breakpoint (struct thread_info *);\n "
    },
    {
      "sha": "3accf9780a66acbd43f193ca24e416c6f396d150",
      "filename": "gdb/inferior.c",
      "status": "modified",
      "additions": 15,
      "deletions": 9,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.c?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -163,6 +163,19 @@ add_inferior (int pid)\n   return inf;\n }\n \n+/* See inferior.h.  */\n+\n+void\n+inferior::clear_thread_list (bool silent)\n+{\n+  thread_list.clear_and_dispose ([=] (thread_info *thr)\n+    {\n+      set_thread_exited (thr, silent);\n+      if (thr->deletable ())\n+\tdelete thr;\n+    });\n+}\n+\n void\n delete_inferior (struct inferior *todel)\n {\n@@ -177,8 +190,7 @@ delete_inferior (struct inferior *todel)\n   if (!inf)\n     return;\n \n-  for (thread_info *tp : inf->threads_safe ())\n-    delete_thread_silent (tp);\n+  inf->clear_thread_list (true);\n \n   if (infprev)\n     infprev->next = inf->next;\n@@ -209,13 +221,7 @@ exit_inferior_1 (struct inferior *inftoex, int silent)\n   if (!inf)\n     return;\n \n-  for (thread_info *tp : inf->threads_safe ())\n-    {\n-      if (silent)\n-\tdelete_thread_silent (tp);\n-      else\n-\tdelete_thread (tp);\n-    }\n+  inf->clear_thread_list (silent);\n \n   gdb::observers::inferior_exit.notify (inf);\n "
    },
    {
      "sha": "2ae9f9a5f9c491e97223de4a97842c8e4156c90a",
      "filename": "gdb/inferior.h",
      "status": "modified",
      "additions": 9,
      "deletions": 5,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -390,8 +390,8 @@ class inferior : public refcounted_object\n   /* Pointer to next inferior in singly-linked list of inferiors.  */\n   struct inferior *next = NULL;\n \n-  /* This inferior's thread list.  */\n-  thread_info *thread_list = nullptr;\n+  /* This inferior's thread list, sorted by creation order.  */\n+  intrusive_list<thread_info> thread_list;\n \n   /* Returns a range adapter covering the inferior's threads,\n      including exited threads.  Used like this:\n@@ -400,7 +400,7 @@ class inferior : public refcounted_object\n \t { .... }\n   */\n   inf_threads_range threads ()\n-  { return inf_threads_range (this->thread_list); }\n+  { return inf_threads_range (this->thread_list.begin ()); }\n \n   /* Returns a range adapter covering the inferior's non-exited\n      threads.  Used like this:\n@@ -409,7 +409,7 @@ class inferior : public refcounted_object\n \t { .... }\n   */\n   inf_non_exited_threads_range non_exited_threads ()\n-  { return inf_non_exited_threads_range (this->thread_list); }\n+  { return inf_non_exited_threads_range (this->thread_list.begin ()); }\n \n   /* Like inferior::threads(), but returns a range adapter that can be\n      used with range-for, safely.  I.e., it is safe to delete the\n@@ -420,7 +420,11 @@ class inferior : public refcounted_object\n \t delete f;\n   */\n   inline safe_inf_threads_range threads_safe ()\n-  { return safe_inf_threads_range (this->thread_list); }\n+  { return safe_inf_threads_range (this->thread_list.begin ()); }\n+\n+  /* Delete all threads in the thread list.  If SILENT, exit threads\n+     silently.  */\n+  void clear_thread_list (bool silent);\n \n   /* Continuations-related methods.  A continuation is an std::function\n      to be called to finish the execution of a command when running"
    },
    {
      "sha": "37ffe511742334be99bb315760a492421b997961",
      "filename": "gdb/scoped-mock-context.h",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/scoped-mock-context.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/scoped-mock-context.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/scoped-mock-context.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -44,16 +44,14 @@ struct scoped_mock_context\n \n   scoped_restore_current_pspace_and_thread restore_pspace_thread;\n \n-  scoped_restore_tmpl<thread_info *> restore_thread_list\n-    {&mock_inferior.thread_list, &mock_thread};\n-\n   /* Add the mock inferior to the inferior list so that look ups by\n      target+ptid can find it.  */\n   scoped_restore_tmpl<inferior *> restore_inferior_list\n     {&inferior_list, &mock_inferior};\n \n   explicit scoped_mock_context (gdbarch *gdbarch)\n   {\n+    mock_inferior.thread_list.push_back (mock_thread);\n     mock_inferior.gdbarch = gdbarch;\n     mock_inferior.aspace = mock_pspace.aspace;\n     mock_inferior.pspace = &mock_pspace;"
    },
    {
      "sha": "a1cdd0206bd4c81508bebf575b5f04ca5f08cd6d",
      "filename": "gdb/thread-iter.c",
      "status": "modified",
      "additions": 39,
      "deletions": 14,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread-iter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread-iter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-iter.c?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -27,30 +27,42 @@ all_threads_iterator::all_threads_iterator (begin_t)\n {\n   /* Advance M_INF/M_THR to the first thread's position.  */\n   for (m_inf = inferior_list; m_inf != NULL; m_inf = m_inf->next)\n-    if ((m_thr = m_inf->thread_list) != NULL)\n-      return;\n+    {\n+      auto thr_iter = m_inf->thread_list.begin ();\n+      if (thr_iter != m_inf->thread_list.end ())\n+\t{\n+\t  m_thr = &*thr_iter;\n+\t  return;\n+\t}\n+    }\n+  m_thr = nullptr;\n }\n \n /* See thread-iter.h.  */\n \n void\n all_threads_iterator::advance ()\n {\n+  intrusive_list<thread_info>::iterator thr_iter (m_thr);\n+\n   /* The loop below is written in the natural way as-if we'd always\n      start at the beginning of the inferior list.  This fast forwards\n      the algorithm to the actual current position.  */\n   goto start;\n \n   for (; m_inf != NULL; m_inf = m_inf->next)\n     {\n-      m_thr = m_inf->thread_list;\n-      while (m_thr != NULL)\n+      thr_iter = m_inf->thread_list.begin ();\n+      while (thr_iter != m_inf->thread_list.end ())\n \t{\n+\t  m_thr = &*thr_iter;\n \t  return;\n \tstart:\n-\t  m_thr = m_thr->next;\n+\t  ++thr_iter;\n \t}\n     }\n+\n+  m_thr = nullptr;\n }\n \n /* See thread-iter.h.  */\n@@ -74,19 +86,27 @@ all_matching_threads_iterator::all_matching_threads_iterator\n   gdb_assert ((filter_target == nullptr && filter_ptid == minus_one_ptid)\n \t      || filter_target->stratum () == process_stratum);\n \n-  m_thr = nullptr;\n   for (m_inf = inferior_list; m_inf != NULL; m_inf = m_inf->next)\n     if (m_inf_matches ())\n-      for (m_thr = m_inf->thread_list; m_thr != NULL; m_thr = m_thr->next)\n-\tif (m_thr->ptid.matches (m_filter_ptid))\n-\t  return;\n+      for (auto thr_iter = m_inf->thread_list.begin ();\n+\t   thr_iter != m_inf->thread_list.end ();\n+\t   ++thr_iter)\n+\tif (thr_iter->ptid.matches (m_filter_ptid))\n+\t  {\n+\t    m_thr = &*thr_iter;\n+\t    return;\n+\t  }\n+\n+  m_thr = nullptr;\n }\n \n /* See thread-iter.h.  */\n \n void\n all_matching_threads_iterator::advance ()\n {\n+  intrusive_list<thread_info>::iterator thr_iter (m_thr);\n+\n   /* The loop below is written in the natural way as-if we'd always\n      start at the beginning of the inferior list.  This fast forwards\n      the algorithm to the actual current position.  */\n@@ -95,13 +115,18 @@ all_matching_threads_iterator::advance ()\n   for (; m_inf != NULL; m_inf = m_inf->next)\n     if (m_inf_matches ())\n       {\n-\tm_thr = m_inf->thread_list;\n-\twhile (m_thr != NULL)\n+\tthr_iter = m_inf->thread_list.begin ();\n+\twhile (thr_iter != m_inf->thread_list.end ())\n \t  {\n-\t    if (m_thr->ptid.matches (m_filter_ptid))\n-\t      return;\n+\t    if (thr_iter->ptid.matches (m_filter_ptid))\n+\t      {\n+\t\tm_thr = &*thr_iter;\n+\t\treturn;\n+\t      }\n \t  start:\n-\t    m_thr = m_thr->next;\n+\t    ++thr_iter;\n \t  }\n       }\n+\n+  m_thr = nullptr;\n }"
    },
    {
      "sha": "2e43034550e8e6dcfddfb8744212ac6c065c4add",
      "filename": "gdb/thread-iter.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread-iter.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread-iter.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread-iter.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -20,13 +20,16 @@\n #define THREAD_ITER_H\n \n #include \"gdbsupport/filtered-iterator.h\"\n+#include \"gdbsupport/iterator-range.h\"\n #include \"gdbsupport/next-iterator.h\"\n+#include \"gdbsupport/reference-to-pointer-iterator.h\"\n #include \"gdbsupport/safe-iterator.h\"\n \n /* A forward iterator that iterates over a given inferior's\n    threads.  */\n \n-using inf_threads_iterator = next_iterator<thread_info>;\n+using inf_threads_iterator\n+  = reference_to_pointer_iterator<intrusive_list<thread_info>::iterator>;\n \n /* A forward iterator that iterates over all threads of all\n    inferiors.  */"
    },
    {
      "sha": "89f51c01c993fe5c41d60c3300250a33e4b08049",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 15,
      "deletions": 46,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -177,9 +177,9 @@ clear_thread_inferior_resources (struct thread_info *tp)\n   clear_inline_frame_state (tp);\n }\n \n-/* Set the TP's state as exited.  */\n+/* See gdbthread.h.  */\n \n-static void\n+void\n set_thread_exited (thread_info *tp, bool silent)\n {\n   /* Dead threads don't need to step-over.  Remove from chain.  */\n@@ -203,17 +203,8 @@ init_thread_list (void)\n {\n   highest_thread_num = 0;\n \n-  for (thread_info *tp : all_threads_safe ())\n-    {\n-      inferior *inf = tp->inf;\n-\n-      if (tp->deletable ())\n-\tdelete tp;\n-      else\n-\tset_thread_exited (tp, 1);\n-\n-      inf->thread_list = NULL;\n-    }\n+  for (inferior *inf : all_inferiors ())\n+    inf->clear_thread_list (true);\n }\n \n /* Allocate a new thread of inferior INF with target id PTID and add\n@@ -224,21 +215,7 @@ new_thread (struct inferior *inf, ptid_t ptid)\n {\n   thread_info *tp = new thread_info (inf, ptid);\n \n-  if (inf->thread_list == NULL)\n-    inf->thread_list = tp;\n-  else\n-    {\n-      struct thread_info *last;\n-\n-      for (last = inf->thread_list; last->next != NULL; last = last->next)\n-\tgdb_assert (ptid != last->ptid\n-\t\t    || last->state == THREAD_EXITED);\n-\n-      gdb_assert (ptid != last->ptid\n-\t\t  || last->state == THREAD_EXITED);\n-\n-      last->next = tp;\n-    }\n+  inf->thread_list.push_back (*tp);\n \n   return tp;\n }\n@@ -462,29 +439,18 @@ delete_thread_1 (thread_info *thr, bool silent)\n {\n   gdb_assert (thr != nullptr);\n \n-  struct thread_info *tp, *tpprev = NULL;\n-\n-  for (tp = thr->inf->thread_list; tp; tpprev = tp, tp = tp->next)\n-    if (tp == thr)\n-      break;\n+  set_thread_exited (thr, silent);\n \n-  if (!tp)\n-    return;\n-\n-  set_thread_exited (tp, silent);\n-\n-  if (!tp->deletable ())\n+  if (!thr->deletable ())\n     {\n        /* Will be really deleted some other time.  */\n        return;\n      }\n \n-  if (tpprev)\n-    tpprev->next = tp->next;\n-  else\n-    tp->inf->thread_list = tp->next;\n+  auto it = thr->inf->thread_list.iterator_to (*thr);\n+  thr->inf->thread_list.erase (it);\n \n-  delete tp;\n+  delete thr;\n }\n \n /* See gdbthread.h.  */\n@@ -629,7 +595,10 @@ in_thread_list (process_stratum_target *targ, ptid_t ptid)\n thread_info *\n first_thread_of_inferior (inferior *inf)\n {\n-  return inf->thread_list;\n+  if (inf->thread_list.empty ())\n+    return nullptr;\n+\n+  return &inf->thread_list.front ();\n }\n \n thread_info *\n@@ -2018,7 +1987,7 @@ update_threads_executing (void)\n \n       /* If the process has no threads, then it must be we have a\n \t process-exit event pending.  */\n-      if (inf->thread_list == NULL)\n+      if (inf->thread_list.empty ())\n \t{\n \t  targ->threads_executing = true;\n \t  return;"
    },
    {
      "sha": "5497a012dd9dd3c4843105e390050408ab3b62fb",
      "filename": "gdb/unittests/intrusive_list-selftests.c",
      "status": "added",
      "additions": 734,
      "deletions": 0,
      "changes": 734,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/unittests/intrusive_list-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdb/unittests/intrusive_list-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/intrusive_list-selftests.c?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -0,0 +1,734 @@\n+/* Tests fpr intrusive double linked list for GDB, the GNU debugger.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+\n+#include \"gdbsupport/intrusive_list.h\"\n+#include \"gdbsupport/selftest.h\"\n+#include <unordered_set>\n+\n+/* An item type using intrusive_list_node by inheriting from it and its\n+   corresponding list type.  Put another base before intrusive_list_node\n+   so that a pointer to the node != a pointer to the item.  */\n+\n+struct other_base\n+{\n+  int n = 1;\n+};\n+\n+struct item_with_base : public other_base,\n+\t\t\tpublic intrusive_list_node<item_with_base>\n+{\n+  explicit item_with_base (const char *name)\n+    : name (name)\n+  {}\n+\n+  const char *const name;\n+};\n+\n+using item_with_base_list = intrusive_list<item_with_base>;\n+\n+/* An item type using intrusive_list_node as a field and its corresponding\n+   list type.  Put the other field before the node, so that a pointer to the\n+   node != a pointer to the item.  */\n+\n+struct item_with_member\n+{\n+  explicit item_with_member (const char *name)\n+    : name (name)\n+  {}\n+\n+  const char *const name;\n+  intrusive_list_node<item_with_member> node;\n+};\n+\n+using item_with_member_node\n+  = intrusive_member_node<item_with_member, &item_with_member::node>;\n+using item_with_member_list\n+  = intrusive_list<item_with_member, item_with_member_node>;\n+\n+/* To run all tests using both the base and member methods, all tests are\n+   declared in this templated class, which is instantiated once for each\n+   list type.  */\n+\n+template <typename ListType>\n+struct intrusive_list_test\n+{\n+  using item_type = typename ListType::value_type;\n+\n+  /* Verify that LIST contains exactly the items in EXPECTED.\n+\n+     Traverse the list forward and backwards to exercise all links.  */\n+\n+  static void\n+  verify_items (const ListType &list,\n+\t\tgdb::array_view<const typename ListType::value_type *> expected)\n+  {\n+    int i = 0;\n+\n+    for (typename ListType::iterator it = list.begin ();\n+\t it != list.end ();\n+\t ++it)\n+      {\n+\tconst item_type &item = *it;\n+\n+\tgdb_assert (i < expected.size ());\n+\tgdb_assert (&item == expected[i]);\n+\n+\t++i;\n+      }\n+\n+    gdb_assert (i == expected.size ());\n+\n+    for (typename ListType::reverse_iterator it = list.rbegin ();\n+\t it != list.rend ();\n+\t ++it)\n+      {\n+\tconst item_type &item = *it;\n+\n+\t--i;\n+\n+\tgdb_assert (i >= 0);\n+\tgdb_assert (&item == expected[i]);\n+      }\n+\n+    gdb_assert (i == 0);\n+  }\n+\n+  static void\n+  test_move_constructor ()\n+  {\n+    {\n+      /* Other list is not empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list1;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list1.push_back (b);\n+      list1.push_back (c);\n+\n+      ListType list2 (std::move (list1));\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Other list contains 1 element.  */\n+      item_type a (\"a\");\n+      ListType list1;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+\n+      ListType list2 (std::move (list1));\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Other list is empty.  */\n+      ListType list1;\n+      std::vector<const item_type *> expected;\n+\n+      ListType list2 (std::move (list1));\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+  }\n+\n+  static void\n+  test_move_assignment ()\n+  {\n+    {\n+      /* Both lists are not empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\"), d (\"d\"), e (\"e\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list1.push_back (b);\n+      list1.push_back (c);\n+\n+      list2.push_back (d);\n+      list2.push_back (e);\n+\n+      list2 = std::move (list1);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* rhs list is empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list2.push_back (a);\n+      list2.push_back (b);\n+      list2.push_back (c);\n+\n+      list2 = std::move (list1);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* lhs list is empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list1.push_back (b);\n+      list1.push_back (c);\n+\n+      list2 = std::move (list1);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Both lists contain 1 item.  */\n+      item_type a (\"a\"), b (\"b\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list2.push_back (b);\n+\n+      list2 = std::move (list1);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Both lists are empty.  */\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list2 = std::move (list1);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+  }\n+\n+  static void\n+  test_swap ()\n+  {\n+    {\n+      /* Two non-empty lists.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\"), d (\"d\"), e (\"e\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list1.push_back (b);\n+      list1.push_back (c);\n+\n+      list2.push_back (d);\n+      list2.push_back (e);\n+\n+      std::swap (list1, list2);\n+\n+      expected = {&d, &e};\n+      verify_items (list1, expected);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Other is empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+      list1.push_back (b);\n+      list1.push_back (c);\n+\n+      std::swap (list1, list2);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* *this is empty.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list2.push_back (a);\n+      list2.push_back (b);\n+      list2.push_back (c);\n+\n+      std::swap (list1, list2);\n+\n+      expected = {&a, &b, &c};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Both lists empty.  */\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      std::swap (list1, list2);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+\n+    {\n+      /* Swap one element twice.  */\n+      item_type a (\"a\");\n+      ListType list1;\n+      ListType list2;\n+      std::vector<const item_type *> expected;\n+\n+      list1.push_back (a);\n+\n+      std::swap (list1, list2);\n+\n+      expected = {};\n+      verify_items (list1, expected);\n+\n+      expected = {&a};\n+      verify_items (list2, expected);\n+\n+      std::swap (list1, list2);\n+\n+      expected = {&a};\n+      verify_items (list1, expected);\n+\n+      expected = {};\n+      verify_items (list2, expected);\n+    }\n+  }\n+\n+  static void\n+  test_front_back ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    const ListType &clist = list;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    gdb_assert (&list.front () == &a);\n+    gdb_assert (&clist.front () == &a);\n+    gdb_assert (&list.back () == &c);\n+    gdb_assert (&clist.back () == &c);\n+  }\n+\n+  static void\n+  test_push_front ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    expected = {};\n+    verify_items (list, expected);\n+\n+    list.push_front (a);\n+    expected = {&a};\n+    verify_items (list, expected);\n+\n+    list.push_front (b);\n+    expected = {&b, &a};\n+    verify_items (list, expected);\n+\n+    list.push_front (c);\n+    expected = {&c, &b, &a};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_push_back ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    expected = {};\n+    verify_items (list, expected);\n+\n+    list.push_back (a);\n+    expected = {&a};\n+    verify_items (list, expected);\n+\n+    list.push_back (b);\n+    expected = {&a, &b};\n+    verify_items (list, expected);\n+\n+    list.push_back (c);\n+    expected = {&a, &b, &c};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_insert ()\n+  {\n+    std::vector<const item_type *> expected;\n+\n+    {\n+      /* Insert at beginning.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list;\n+\n+\n+      list.insert (list.begin (), a);\n+      expected = {&a};\n+      verify_items (list, expected);\n+\n+      list.insert (list.begin (), b);\n+      expected = {&b, &a};\n+      verify_items (list, expected);\n+\n+      list.insert (list.begin (), c);\n+      expected = {&c, &b, &a};\n+      verify_items (list, expected);\n+    }\n+\n+    {\n+      /* Insert at end.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list;\n+\n+\n+      list.insert (list.end (), a);\n+      expected = {&a};\n+      verify_items (list, expected);\n+\n+      list.insert (list.end (), b);\n+      expected = {&a, &b};\n+      verify_items (list, expected);\n+\n+      list.insert (list.end (), c);\n+      expected = {&a, &b, &c};\n+      verify_items (list, expected);\n+    }\n+\n+    {\n+      /* Insert in the middle.  */\n+      item_type a (\"a\"), b (\"b\"), c (\"c\");\n+      ListType list;\n+\n+      list.push_back (a);\n+      list.push_back (b);\n+\n+      list.insert (list.iterator_to (b), c);\n+      expected = {&a, &c, &b};\n+      verify_items (list, expected);\n+    }\n+\n+    {\n+      /* Insert in empty list. */\n+      item_type a (\"a\");\n+      ListType list;\n+\n+      list.insert (list.end (), a);\n+      expected = {&a};\n+      verify_items (list, expected);\n+    }\n+  }\n+\n+  static void\n+  test_pop_front ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    list.pop_front ();\n+    expected = {&b, &c};\n+    verify_items (list, expected);\n+\n+    list.pop_front ();\n+    expected = {&c};\n+    verify_items (list, expected);\n+\n+    list.pop_front ();\n+    expected = {};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_pop_back ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    list.pop_back();\n+    expected = {&a, &b};\n+    verify_items (list, expected);\n+\n+    list.pop_back ();\n+    expected = {&a};\n+    verify_items (list, expected);\n+\n+    list.pop_back ();\n+    expected = {};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_erase ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    list.erase (list.iterator_to (b));\n+    expected = {&a, &c};\n+    verify_items (list, expected);\n+\n+    list.erase (list.iterator_to (c));\n+    expected = {&a};\n+    verify_items (list, expected);\n+\n+    list.erase (list.iterator_to (a));\n+    expected = {};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_clear ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    list.clear ();\n+    expected = {};\n+    verify_items (list, expected);\n+\n+    /* Verify idempotency.  */\n+    list.clear ();\n+    expected = {};\n+    verify_items (list, expected);\n+  }\n+\n+  static void\n+  test_clear_and_dispose ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    std::vector<const item_type *> expected;\n+    std::unordered_set<const item_type *> disposer_seen;\n+    int disposer_calls = 0;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    auto disposer = [&] (const item_type *item)\n+      {\n+\tdisposer_seen.insert (item);\n+\tdisposer_calls++;\n+      };\n+    list.clear_and_dispose (disposer);\n+\n+    expected = {};\n+    verify_items (list, expected);\n+    gdb_assert (disposer_calls == 3);\n+    gdb_assert (disposer_seen.find (&a) != disposer_seen.end ());\n+    gdb_assert (disposer_seen.find (&b) != disposer_seen.end ());\n+    gdb_assert (disposer_seen.find (&c) != disposer_seen.end ());\n+\n+    /* Verify idempotency.  */\n+    list.clear_and_dispose (disposer);\n+    gdb_assert (disposer_calls == 3);\n+  }\n+\n+  static void\n+  test_empty ()\n+  {\n+    item_type a (\"a\");\n+    ListType list;\n+\n+    gdb_assert (list.empty ());\n+    list.push_back (a);\n+    gdb_assert (!list.empty ());\n+    list.erase (list.iterator_to (a));\n+    gdb_assert (list.empty ());\n+  }\n+\n+  static void\n+  test_begin_end ()\n+  {\n+    item_type a (\"a\"), b (\"b\"), c (\"c\");\n+    ListType list;\n+    const ListType &clist = list;\n+\n+    list.push_back (a);\n+    list.push_back (b);\n+    list.push_back (c);\n+\n+    gdb_assert (&*list.begin () == &a);\n+    gdb_assert (&*list.cbegin () == &a);\n+    gdb_assert (&*clist.begin () == &a);\n+    gdb_assert (&*list.rbegin () == &c);\n+    gdb_assert (&*list.crbegin () == &c);\n+    gdb_assert (&*clist.rbegin () == &c);\n+\n+    /* At least check that they compile.  */\n+    list.end ();\n+    list.cend ();\n+    clist.end ();\n+    list.rend ();\n+    list.crend ();\n+    clist.end ();\n+  }\n+};\n+\n+template <typename ListType>\n+static void\n+test_intrusive_list ()\n+{\n+  intrusive_list_test<ListType> tests;\n+\n+  tests.test_move_constructor ();\n+  tests.test_move_assignment ();\n+  tests.test_swap ();\n+  tests.test_front_back ();\n+  tests.test_push_front ();\n+  tests.test_push_back ();\n+  tests.test_insert ();\n+  tests.test_pop_front ();\n+  tests.test_pop_back ();\n+  tests.test_erase ();\n+  tests.test_clear ();\n+  tests.test_clear_and_dispose ();\n+  tests.test_empty ();\n+  tests.test_begin_end ();\n+}\n+\n+static void\n+test_node_is_linked ()\n+{\n+  {\n+    item_with_base a (\"a\");\n+    item_with_base_list list;\n+\n+    gdb_assert (!a.is_linked ());\n+    list.push_back (a);\n+    gdb_assert (a.is_linked ());\n+    list.pop_back ();\n+    gdb_assert (!a.is_linked ());\n+  }\n+\n+  {\n+    item_with_member a (\"a\");\n+    item_with_member_list list;\n+\n+    gdb_assert (!a.node.is_linked ());\n+    list.push_back (a);\n+    gdb_assert (a.node.is_linked ());\n+    list.pop_back ();\n+    gdb_assert (!a.node.is_linked ());\n+  }\n+}\n+\n+static void\n+test_intrusive_list ()\n+{\n+  test_intrusive_list<item_with_base_list> ();\n+  test_intrusive_list<item_with_member_list> ();\n+  test_node_is_linked ();\n+}\n+\n+void _initialize_intrusive_list_selftests ();\n+void\n+_initialize_intrusive_list_selftests ()\n+{\n+  selftests::register_test\n+    (\"intrusive_list\", test_intrusive_list);\n+}"
    },
    {
      "sha": "8d49ce4551729264ffd28195edccec785ecf8ab8",
      "filename": "gdbsupport/intrusive_list.h",
      "status": "added",
      "additions": 559,
      "deletions": 0,
      "changes": 559,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdbsupport/intrusive_list.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdbsupport/intrusive_list.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/intrusive_list.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -0,0 +1,559 @@\n+/* Intrusive double linked list for GDB, the GNU debugger.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDBSUPPORT_INTRUSIVE_LIST_H\n+#define GDBSUPPORT_INTRUSIVE_LIST_H\n+\n+#define INTRUSIVE_LIST_UNLINKED_VALUE ((T *) -1)\n+\n+/* A list node.  The elements put in an intrusive_list either inherit\n+   from this, or have a field of this type.  */\n+template<typename T>\n+struct intrusive_list_node\n+{\n+  bool is_linked () const\n+  {\n+    return next != INTRUSIVE_LIST_UNLINKED_VALUE;\n+  }\n+\n+  T *next = INTRUSIVE_LIST_UNLINKED_VALUE;\n+  T *prev = INTRUSIVE_LIST_UNLINKED_VALUE;\n+};\n+\n+/* Follows a couple types used by intrusive_list as template parameter to find\n+   the intrusive_list_node for a given element.  One for lists where the\n+   elements inherit intrusive_list_node, and another for elements that keep the\n+   node as member field.  */\n+\n+/* For element types that inherit from intrusive_list_node.  */\n+\n+template<typename T>\n+struct intrusive_base_node\n+{\n+  static intrusive_list_node<T> *as_node (T *elem)\n+  { return elem; }\n+};\n+\n+/* For element types that keep the node as member field.  */\n+\n+template<typename T, intrusive_list_node<T> T::*MemberNode>\n+struct intrusive_member_node\n+{\n+  static intrusive_list_node<T> *as_node (T *elem)\n+  { return &(elem->*MemberNode); }\n+};\n+\n+/* Common code for forward and reverse iterators.  */\n+\n+template<typename T, typename AsNode, typename SelfType>\n+struct intrusive_list_base_iterator\n+{\n+  using self_type = SelfType;\n+  using iterator_category = std::bidirectional_iterator_tag;\n+  using value_type = T;\n+  using pointer = T *;\n+  using const_pointer = const T *;\n+  using reference = T &;\n+  using const_reference = const T &;\n+  using difference_type = ptrdiff_t;\n+  using size_type = size_t;\n+  using node_type = intrusive_list_node<T>;\n+\n+  /* Create an iterator pointing to ELEM.  */\n+  explicit intrusive_list_base_iterator (T *elem)\n+    : m_elem (elem)\n+  {}\n+\n+  /* Create a past-the-end iterator.  */\n+  intrusive_list_base_iterator ()\n+    : m_elem (nullptr)\n+  {}\n+\n+  reference operator* () const\n+  { return *m_elem; }\n+\n+  pointer operator-> () const\n+  { return m_elem; }\n+\n+  bool operator== (const self_type &other) const\n+  { return m_elem == other.m_elem; }\n+\n+  bool operator!= (const self_type &other) const\n+  { return m_elem != other.m_elem; }\n+\n+protected:\n+  static node_type *as_node (T *elem)\n+  { return AsNode::as_node (elem); }\n+\n+  /* A past-end-the iterator points to the list's head.  */\n+  pointer m_elem;\n+};\n+\n+/* Forward iterator for an intrusive_list.  */\n+\n+template<typename T, typename AsNode = intrusive_base_node<T>>\n+struct intrusive_list_iterator\n+  : public intrusive_list_base_iterator\n+\t     <T, AsNode, intrusive_list_iterator<T, AsNode>>\n+{\n+  using base = intrusive_list_base_iterator\n+\t\t <T, AsNode, intrusive_list_iterator<T, AsNode>>;\n+  using self_type = typename base::self_type;\n+  using node_type = typename base::node_type;\n+\n+  /* Inherit constructor and M_NODE visibility from base.  */\n+  using base::base;\n+  using base::m_elem;\n+\n+  self_type &operator++ ()\n+  {\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->next;\n+    return *this;\n+  }\n+\n+  self_type operator++ (int)\n+  {\n+    self_type temp = *this;\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->next;\n+    return temp;\n+  }\n+\n+  self_type &operator-- ()\n+  {\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->prev;\n+    return *this;\n+  }\n+\n+  self_type operator-- (int)\n+  {\n+    self_type temp = *this;\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->prev;\n+    return temp;\n+  }\n+};\n+\n+/* Reverse iterator for an intrusive_list.  */\n+\n+template<typename T, typename AsNode = intrusive_base_node<T>>\n+struct intrusive_list_reverse_iterator\n+  : public intrusive_list_base_iterator\n+\t     <T, AsNode, intrusive_list_reverse_iterator<T, AsNode>>\n+{\n+  using base = intrusive_list_base_iterator\n+\t\t <T, AsNode, intrusive_list_reverse_iterator<T, AsNode>>;\n+  using self_type = typename base::self_type;\n+\n+  /* Inherit constructor and M_NODE visibility from base.  */\n+  using base::base;\n+  using base::m_elem;\n+  using node_type = typename base::node_type;\n+\n+  self_type &operator++ ()\n+  {\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->prev;\n+    return *this;\n+  }\n+\n+  self_type operator++ (int)\n+  {\n+    self_type temp = *this;\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->prev;\n+    return temp;\n+  }\n+\n+  self_type &operator-- ()\n+  {\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->next;\n+    return *this;\n+  }\n+\n+  self_type operator-- (int)\n+  {\n+    self_type temp = *this;\n+    node_type *node = this->as_node (m_elem);\n+    m_elem = node->next;\n+    return temp;\n+  }\n+};\n+\n+/* An intrusive double-linked list.\n+\n+   T is the type of the elements to link.  The type T must either:\n+\n+    - inherit from intrusive_list_node<T>\n+    - have an intrusive_list_node<T> member\n+\n+   AsNode is a type with an as_node static method used to get a node from an\n+   element.  If elements inherit from intrusive_list_node<T>, use the default\n+   intrusive_base_node<T>.  If elements have an intrusive_list_node<T> member,\n+   use:\n+\n+     intrusive_member_node<T, &T::member>\n+\n+   where `member` is the name of the member.  */\n+\n+template <typename T, typename AsNode = intrusive_base_node<T>>\n+class intrusive_list\n+{\n+public:\n+  using value_type = T;\n+  using pointer = T *;\n+  using const_pointer = const T *;\n+  using reference = T &;\n+  using const_reference = const T &;\n+  using difference_type = ptrdiff_t;\n+  using size_type = size_t;\n+  using iterator = intrusive_list_iterator<T, AsNode>;\n+  using reverse_iterator = intrusive_list_reverse_iterator<T, AsNode>;\n+  using const_iterator = const intrusive_list_iterator<T, AsNode>;\n+  using const_reverse_iterator\n+    = const intrusive_list_reverse_iterator<T, AsNode>;\n+  using node_type = intrusive_list_node<T>;\n+\n+  intrusive_list () = default;\n+\n+  ~intrusive_list ()\n+  {\n+    clear ();\n+  }\n+\n+  intrusive_list (intrusive_list &&other)\n+    : m_front (other.m_front),\n+      m_back (other.m_back)\n+  {\n+    other.m_front = nullptr;\n+    other.m_back = nullptr;\n+  }\n+\n+  intrusive_list &operator= (intrusive_list &&other)\n+  {\n+    m_front = other.m_front;\n+    m_back = other.m_back;\n+    other.m_front = nullptr;\n+    other.m_back = nullptr;\n+\n+    return *this;\n+  }\n+\n+  void swap (intrusive_list &other)\n+  {\n+    std::swap (m_front, other.m_front);\n+    std::swap (m_back, other.m_back);\n+  }\n+\n+  iterator iterator_to (reference value)\n+  {\n+    return iterator (&value);\n+  }\n+\n+  const_iterator iterator_to (const_reference value)\n+  {\n+    return const_iterator (&value);\n+  }\n+\n+  reference front ()\n+  {\n+    gdb_assert (!this->empty ());\n+    return *m_front;\n+  }\n+\n+  const_reference front () const\n+  {\n+    gdb_assert (!this->empty ());\n+    return *m_front;\n+  }\n+\n+  reference back ()\n+  {\n+    gdb_assert (!this->empty ());\n+    return *m_back;\n+  }\n+\n+  const_reference back () const\n+  {\n+    gdb_assert (!this->empty ());\n+    return *m_back;\n+  }\n+\n+  void push_front (reference elem)\n+  {\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    if (this->empty ())\n+      this->push_empty (elem);\n+    else\n+      this->push_front_non_empty (elem);\n+  }\n+\n+  void push_back (reference elem)\n+  {\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    if (this->empty ())\n+      this->push_empty (elem);\n+    else\n+      this->push_back_non_empty (elem);\n+  }\n+\n+  /* Inserts ELEM before POS.  */\n+  void insert (const_iterator pos, reference elem)\n+  {\n+    if (this->empty ())\n+      return this->push_empty (elem);\n+\n+    if (pos == this->begin ())\n+      return this->push_front_non_empty (elem);\n+\n+    if (pos == this->end ())\n+      return this->push_back_non_empty (elem);\n+\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+    T *pos_elem = &*pos;\n+    intrusive_list_node<T> *pos_node = as_node (pos_elem);\n+    T *prev_elem = pos_node->prev;\n+    intrusive_list_node<T> *prev_node = as_node (prev_elem);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    elem_node->prev = prev_elem;\n+    prev_node->next = &elem;\n+    elem_node->next = pos_elem;\n+    pos_node->prev = &elem;\n+  }\n+\n+  void pop_front ()\n+  {\n+    gdb_assert (!this->empty ());\n+    erase_element (*m_front);\n+  }\n+\n+  void pop_back ()\n+  {\n+    gdb_assert (!this->empty ());\n+    erase_element (*m_back);\n+  }\n+\n+private:\n+  /* Push ELEM in the list, knowing the list is empty.  */\n+  void push_empty (T &elem)\n+  {\n+    gdb_assert (this->empty ());\n+\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    m_front = &elem;\n+    m_back = &elem;\n+    elem_node->prev = nullptr;\n+    elem_node->next = nullptr;\n+  }\n+\n+  /* Push ELEM at the front of the list, knowing the list is not empty.  */\n+  void push_front_non_empty (T &elem)\n+  {\n+    gdb_assert (!this->empty ());\n+\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+    intrusive_list_node<T> *front_node = as_node (m_front);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    elem_node->next = m_front;\n+    front_node->prev = &elem;\n+    elem_node->prev = nullptr;\n+    m_front = &elem;\n+  }\n+\n+  /* Push ELEM at the back of the list, knowing the list is not empty.  */\n+  void push_back_non_empty (T &elem)\n+  {\n+    gdb_assert (!this->empty ());\n+\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+    intrusive_list_node<T> *back_node = as_node (m_back);\n+\n+    gdb_assert (elem_node->next == INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->prev == INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    elem_node->prev = m_back;\n+    back_node->next = &elem;\n+    elem_node->next = nullptr;\n+    m_back = &elem;\n+  }\n+\n+  void erase_element (T &elem)\n+  {\n+    intrusive_list_node<T> *elem_node = as_node (&elem);\n+\n+    gdb_assert (elem_node->prev != INTRUSIVE_LIST_UNLINKED_VALUE);\n+    gdb_assert (elem_node->next != INTRUSIVE_LIST_UNLINKED_VALUE);\n+\n+    if (m_front == &elem)\n+      {\n+\tgdb_assert (elem_node->prev == nullptr);\n+\tm_front = elem_node->next;\n+      }\n+    else\n+      {\n+\tgdb_assert (elem_node->prev != nullptr);\n+\tintrusive_list_node<T> *prev_node = as_node (elem_node->prev);\n+\tprev_node->next = elem_node->next;\n+      }\n+\n+    if (m_back == &elem)\n+      {\n+\tgdb_assert (elem_node->next == nullptr);\n+\tm_back = elem_node->prev;\n+      }\n+    else\n+      {\n+\tgdb_assert (elem_node->next != nullptr);\n+\tintrusive_list_node<T> *next_node = as_node (elem_node->next);\n+\tnext_node->prev = elem_node->prev;\n+      }\n+\n+    elem_node->next = INTRUSIVE_LIST_UNLINKED_VALUE;\n+    elem_node->prev = INTRUSIVE_LIST_UNLINKED_VALUE;\n+  }\n+\n+public:\n+  /* Remove the element pointed by I from the list.  The element\n+     pointed by I is not destroyed.  */\n+  iterator erase (const_iterator i)\n+  {\n+    iterator ret = i;\n+    ++ret;\n+\n+    erase_element (*i);\n+\n+    return ret;\n+  }\n+\n+  /* Erase all the elements.  The elements are not destroyed.  */\n+  void clear ()\n+  {\n+    while (!this->empty ())\n+      pop_front ();\n+  }\n+\n+  /* Erase all the elements.  Disposer::operator()(pointer) is called\n+     for each of the removed elements.  */\n+  template<typename Disposer>\n+  void clear_and_dispose (Disposer disposer)\n+  {\n+    while (!this->empty ())\n+      {\n+\tpointer p = &front ();\n+\tpop_front ();\n+\tdisposer (p);\n+      }\n+  }\n+\n+  bool empty () const\n+  {\n+    return m_front == nullptr;\n+  }\n+\n+  iterator begin () noexcept\n+  {\n+    return iterator (m_front);\n+  }\n+\n+  const_iterator begin () const noexcept\n+  {\n+    return const_iterator (m_front);\n+  }\n+\n+  const_iterator cbegin () const noexcept\n+  {\n+    return const_iterator (m_front);\n+  }\n+\n+  iterator end () noexcept\n+  {\n+    return {};\n+  }\n+\n+  const_iterator end () const noexcept\n+  {\n+    return {};\n+  }\n+\n+  const_iterator cend () const noexcept\n+  {\n+    return {};\n+  }\n+\n+  reverse_iterator rbegin () noexcept\n+  {\n+    return reverse_iterator (m_back);\n+  }\n+\n+  const_reverse_iterator rbegin () const noexcept\n+  {\n+    return const_reverse_iterator (m_back);\n+  }\n+\n+  const_reverse_iterator crbegin () const noexcept\n+  {\n+    return const_reverse_iterator (m_back);\n+  }\n+\n+  reverse_iterator rend () noexcept\n+  {\n+    return {};\n+  }\n+\n+  const_reverse_iterator rend () const noexcept\n+  {\n+    return {};\n+  }\n+\n+  const_reverse_iterator crend () const noexcept\n+  {\n+    return {};\n+  }\n+\n+private:\n+  static node_type *as_node (T *elem)\n+  {\n+    return AsNode::as_node (elem);\n+  }\n+\n+  T *m_front = nullptr;\n+  T *m_back = nullptr;\n+};\n+\n+#endif /* GDBSUPPORT_INTRUSIVE_LIST_H */"
    },
    {
      "sha": "7303fa4a04ae25ec01fb6599b7c3410f6609dd26",
      "filename": "gdbsupport/reference-to-pointer-iterator.h",
      "status": "added",
      "additions": 79,
      "deletions": 0,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdbsupport/reference-to-pointer-iterator.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf8093108164a7ed7fdf4c6dc751e0b2043caf7b/gdbsupport/reference-to-pointer-iterator.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/reference-to-pointer-iterator.h?ref=bf8093108164a7ed7fdf4c6dc751e0b2043caf7b",
      "patch": "@@ -0,0 +1,79 @@\n+/* An iterator wrapper that yields pointers instead of references.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDBSUPPORT_REFERENCE_TO_POINTER_ITERATOR_H\n+#define GDBSUPPORT_REFERENCE_TO_POINTER_ITERATOR_H\n+\n+/* Wrap an iterator that yields references to objects so that it yields\n+   pointers to objects instead.\n+\n+   This is useful for example to bridge the gap between iterators on intrusive\n+   lists, which yield references, and the rest of GDB, which for legacy reasons\n+   expects to iterate on pointers.  */\n+\n+template <typename IteratorType>\n+struct reference_to_pointer_iterator\n+{\n+  using self_type = reference_to_pointer_iterator;\n+  using value_type = typename IteratorType::value_type *;\n+  using reference = typename IteratorType::value_type *&;\n+  using pointer = typename IteratorType::value_type **;\n+  using iterator_category = typename IteratorType::iterator_category;\n+  using difference_type = typename IteratorType::difference_type;\n+\n+  /* Construct a reference_to_pointer_iterator, passing args to the underyling\n+     iterator.  */\n+  template <typename... Args>\n+  reference_to_pointer_iterator (Args &&...args)\n+    : m_it (std::forward<Args> (args)...)\n+  {}\n+\n+  /* Create a past-the-end iterator.\n+\n+     Assumes that default-constructing an underlying iterator creates a\n+     past-the-end iterator.  */\n+  reference_to_pointer_iterator ()\n+  {}\n+\n+  /* Need these as the variadic constructor would be a better match\n+     otherwise.  */\n+  reference_to_pointer_iterator (reference_to_pointer_iterator &) = default;\n+  reference_to_pointer_iterator (const reference_to_pointer_iterator &) = default;\n+  reference_to_pointer_iterator (reference_to_pointer_iterator &&) = default;\n+\n+  value_type operator* () const\n+  { return &*m_it; }\n+\n+  self_type &operator++ ()\n+  {\n+    ++m_it;\n+    return *this;\n+  }\n+\n+  bool operator== (const self_type &other) const\n+  { return m_it == other.m_it; }\n+\n+  bool operator!= (const self_type &other) const\n+  { return m_it != other.m_it; }\n+\n+private:\n+  /* The underlying iterator.  */\n+  IteratorType m_it;\n+};\n+\n+#endif /* GDBSUPPORT_REFERENCE_TO_POINTER_ITERATOR_H */"
    }
  ]
}