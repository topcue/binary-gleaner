{
  "sha": "1d67fe3b6e696fccb902d9919b9e58b7299a3205",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWQ2N2ZlM2I2ZTY5NmZjY2I5MDJkOTkxOWI5ZTU4YjcyOTlhMzIwNQ==",
  "commit": {
    "author": {
      "name": "Thomas Troeger",
      "email": "tstroege@gmx.de",
      "date": "2020-01-13T12:36:55Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-01-13T12:36:55Z"
    },
    "message": "Add an option to objdump's disassembler to generate ascii art diagrams showing the destinations of flow control instructions.\n\nbinutils* objdump.c (visualize_jumps, color_output, extended_color_output)\n\t(detected_jumps): New variables.\n\t(usage): Add the new jump visualization options.\n\t(option_values): Add new option value.\n\t(long_options): Add the new option.\n\t(jump_info_new, jump_info_free): New functions.\n\t(jump_info_min_address, jump_info_max_address): Likewise.\n\t(jump_info_end_address, jump_info_is_start_address): Likewise.\n\t(jump_info_is_end_address, jump_info_size): Likewise.\n\t(jump_info_unlink, jump_info_insert): Likewise.\n\t(jump_info_add_front, jump_info_move_linked): Likewise.\n\t(jump_info_intersect, jump_info_merge): Likewise.\n\t(jump_info_sort, jump_info_visualize_address): Likewise.\n\t(disassemble_jumps): New function - used to locate jumps.\n\t(disassemble_bytes): Add ascii art generation.\n\t(disassemble_section): Add scan to locate jumps.\n\t(main): Parse the new visualization option.\n\t* doc/binutils.texi: Document the new feature.\n\t* NEWS: Mention the new feature.\n\nopcodes\t* arm-dis.c (print_insn_arm): Fill in insn info fields for control\n\tflow instructions.\n\t(print_insn_thumb16, print_insn_thumb32): Likewise.\n\t(print_insn): Initialize the insn info.\n\t* i386-dis.c (print_insn): Initialize the insn info fields, and\n\tdetect jumps.",
    "tree": {
      "sha": "84e284092b19da0c349671ccc287d8afd7c1c4b6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/84e284092b19da0c349671ccc287d8afd7c1c4b6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1d67fe3b6e696fccb902d9919b9e58b7299a3205",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d67fe3b6e696fccb902d9919b9e58b7299a3205",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1d67fe3b6e696fccb902d9919b9e58b7299a3205",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d67fe3b6e696fccb902d9919b9e58b7299a3205/comments",
  "author": {
    "login": "hochl",
    "id": 6332453,
    "node_id": "MDQ6VXNlcjYzMzI0NTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6332453?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hochl",
    "html_url": "https://github.com/hochl",
    "followers_url": "https://api.github.com/users/hochl/followers",
    "following_url": "https://api.github.com/users/hochl/following{/other_user}",
    "gists_url": "https://api.github.com/users/hochl/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hochl/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hochl/subscriptions",
    "organizations_url": "https://api.github.com/users/hochl/orgs",
    "repos_url": "https://api.github.com/users/hochl/repos",
    "events_url": "https://api.github.com/users/hochl/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hochl/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a4f2b7c5d931f2aa27851b59ae5817a6ee43cfcb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a4f2b7c5d931f2aa27851b59ae5817a6ee43cfcb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a4f2b7c5d931f2aa27851b59ae5817a6ee43cfcb"
    }
  ],
  "stats": {
    "total": 886,
    "additions": 877,
    "deletions": 9
  },
  "files": [
    {
      "sha": "d496369636d3ed3e9779ec2477accaefb525117c",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -1,3 +1,25 @@\n+2020-01-13  Thomas Troeger  <tstroege@gmx.de>\n+\n+\t* objdump.c (visualize_jumps, color_output, extended_color_output)\n+\t(detected_jumps): New variables.\n+\t(usage): Add the new jump visualization options.\n+\t(option_values): Add new option value.\n+\t(long_options): Add the new option.\n+\t(jump_info_new, jump_info_free): New functions.\n+\t(jump_info_min_address, jump_info_max_address): Likewise.\n+\t(jump_info_end_address, jump_info_is_start_address): Likewise.\n+\t(jump_info_is_end_address, jump_info_size): Likewise.\n+\t(jump_info_unlink, jump_info_insert): Likewise.\n+\t(jump_info_add_front, jump_info_move_linked): Likewise.\n+\t(jump_info_intersect, jump_info_merge): Likewise.\n+\t(jump_info_sort, jump_info_visualize_address): Likewise.\n+\t(disassemble_jumps): New function - used to locate jumps.\n+\t(disassemble_bytes): Add ascii art generation.\n+\t(disassemble_section): Add scan to locate jumps.\n+\t(main): Parse the new visualization option.\n+\t* doc/binutils.texi: Document the new feature.\n+\t* NEWS: Mention the new feature.\n+\n 2020-01-13  Alan Modra  <amodra@gmail.com>\n \n \tPR 25360"
    },
    {
      "sha": "92ec6bc07acd3c6c4d36d92d93daa3b07f6a2717",
      "filename": "binutils/NEWS",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/NEWS?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -15,6 +15,25 @@\n * Add --keep-section option to objcopy and strip.  This option keeps the\n   specified section from being removed.\n \n+ * Add visualization of jumps inside a function by drawing an ascii character\n+   graph between the address and the disassembler column.  Enabled via the\n+   --visualize-jumps command line option for objdump.  Currently supported by\n+   the x86, x86_64, and ARM targets.  The output looks something like this:\n+\n+  c6:\t|  |     \\----------> be 00 00 00 00       \tmov    $0x0,%esi\n+  cb:\t|  |           /----> 48 8b 3d 00 00 00 00 \tmov    0x0(%rip),%rdi        # d2 <main+0xd2>\n+  d2:\t|  |           |      31 c0                \txor    %eax,%eax\n+  d4:\t|  |           |  /-- e8 00 00 00 00       \tcallq  d9 <main+0xd9>\n+  d9:\t|  |           |  \\-> bf 02 00 00 00       \tmov    $0x2,%edi\n+  de:\t|  +-----------|----- e8 00 00 00 00       \tcallq  e3 <main+0xe3>\n+  e3:\t|  \\-----------|----> 48 89 da             \tmov    %rbx,%rdx\n+  e6:\t|              |      be 00 00 00 00       \tmov    $0x0,%esi\n+  eb:\t|              \\----- eb de                \tjmp    cb <main+0xcb>\n+  ed:\t\\-------------------> 48 8b 16             \tmov    (%rsi),%rdx\n+\n+  Additional arguments to the --visualize-jumps option add colors to the\n+  output.\n+\n Changes in 2.33:\n \n * Add --source-comment[=<txt>] option to objdump which if present,"
    },
    {
      "sha": "669bee968f13e804f2f65f063ab1a8803947b311",
      "filename": "binutils/doc/binutils.texi",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/doc/binutils.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/doc/binutils.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/doc/binutils.texi?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -2169,6 +2169,7 @@ objdump [@option{-a}|@option{--archive-headers}]\n         [@option{--prefix=}@var{prefix}]\n         [@option{--prefix-strip=}@var{level}]\n         [@option{--insn-width=}@var{width}]\n+        [@option{--visualize-jumps[=color|=extended-color|=off]}\n         [@option{-V}|@option{--version}]\n         [@option{-H}|@option{--help}]\n         @var{objfile}@dots{}\n@@ -2681,6 +2682,17 @@ This is the default when @option{--prefix-addresses} is used.\n Display @var{width} bytes on a single line when disassembling\n instructions.\n \n+@item --visualize-jumps[=color|=extended-color|=off]\n+Visualize jumps that stay inside a function by drawing ASCII art between\n+the start and target addresses.  The optional @option{=color} argument\n+adds color to the output using simple terminal colors.  Alternatively\n+the @option{=extended-color} argument will add color using 8bit\n+colors, but these might not work on all terminals.\n+\n+If it is necessary to disable the @option{visualize-jumps} option\n+after it has previously been enabled then use\n+@option{visualize-jumps=off}.\n+\n @item -W[lLiaprmfFsoRtUuTgAckK]\n @itemx --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges,=pubtypes,=trace_info,=trace_abbrev,=trace_aranges,=gdb_index,=addr,=cu_index,=links,=follow-links]\n @include debug.options.texi"
    },
    {
      "sha": "a031e9de12291e1d2025f753d92d44aae1e89215",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 711,
      "deletions": 5,
      "changes": 716,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -124,6 +124,9 @@ static size_t prefix_length;\n static bfd_boolean unwind_inlines;\t/* --inlines.  */\n static const char * disasm_sym;\t\t/* Disassembly start symbol.  */\n static const char * source_comment;     /* --source_comment.  */\n+static bfd_boolean visualize_jumps = FALSE;          /* --visualize-jumps.  */\n+static bfd_boolean color_output = FALSE;             /* --visualize-jumps=color.  */\n+static bfd_boolean extended_color_output = FALSE;    /* --visualize-jumps=extended-color.  */\n \n static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;\n \n@@ -198,6 +201,9 @@ static const struct objdump_private_desc * const objdump_private_vectors[] =\n     OBJDUMP_PRIVATE_VECTORS\n     NULL\n   };\n+\n+/* The list of detected jumps inside a function.  */\n+static struct jump_info *detected_jumps = NULL;\n \f\n static void usage (FILE *, int) ATTRIBUTE_NORETURN;\n static void\n@@ -278,7 +284,12 @@ usage (FILE *stream, int status)\n                              or deeper\\n\\\n       --dwarf-check          Make additional dwarf internal consistency checks.\\\n       \\n\\\n-      --ctf-parent=SECTION     Use SECTION as the CTF parent\\n\\n\"));\n+      --ctf-parent=SECTION       Use SECTION as the CTF parent\\n\\\n+      --visualize-jumps          Visualize jumps by drawing ASCII art lines\\n\\\n+      --visualize-jumps=color    Use colors in the ASCII art\\n\\\n+      --visualize-jumps=extended-color   Use extended 8-bit color codes\\n\\\n+      --visualize-jumps=off      Disable jump visualization\\n\\n\"));\n+\n       list_supported_targets (program_name, stream);\n       list_supported_architectures (program_name, stream);\n \n@@ -316,7 +327,8 @@ enum option_values\n     OPTION_INLINES,\n     OPTION_SOURCE_COMMENT,\n     OPTION_CTF,\n-    OPTION_CTF_PARENT\n+    OPTION_CTF_PARENT,\n+    OPTION_VISUALIZE_JUMPS\n   };\n \n static struct option long_options[]=\n@@ -376,6 +388,7 @@ static struct option long_options[]=\n   {\"dwarf-start\", required_argument, 0, OPTION_DWARF_START},\n   {\"dwarf-check\", no_argument, 0, OPTION_DWARF_CHECK},\n   {\"inlines\", no_argument, 0, OPTION_INLINES},\n+  {\"visualize-jumps\", optional_argument, 0, OPTION_VISUALIZE_JUMPS},\n   {0, no_argument, 0, 0}\n };\n \f\n@@ -1845,6 +1858,583 @@ objdump_sprintf (SFILE *f, const char *format, ...)\n   return n;\n }\n \n+/* Code for generating (colored) diagrams of control flow start and end\n+   points.  */\n+\n+/* Structure used to store the properties of a jump.  */\n+\n+struct jump_info\n+{\n+  /* The next jump, or NULL if this is the last object.  */\n+  struct jump_info *next;\n+  /* The previous jump, or NULL if this is the first object.  */\n+  struct jump_info *prev;\n+  /* The start addresses of the jump.  */\n+  struct\n+    {\n+      /* The list of start addresses.  */\n+      bfd_vma *addresses;\n+      /* The number of elements.  */\n+      size_t count;\n+      /* The maximum number of elements that fit into the array.  */\n+      size_t max_count;\n+    } start;\n+  /* The end address of the jump.  */\n+  bfd_vma end;\n+  /* The drawing level of the jump.  */\n+  int level;\n+};\n+\n+/* Construct a jump object for a jump from start\n+   to end with the corresponding level.  */\n+\n+static struct jump_info *\n+jump_info_new (bfd_vma start, bfd_vma end, int level)\n+{\n+  struct jump_info *result = xmalloc (sizeof (struct jump_info));\n+\n+  result->next = NULL;\n+  result->prev = NULL;\n+  result->start.addresses = xmalloc (sizeof (bfd_vma *) * 2);\n+  result->start.addresses[0] = start;\n+  result->start.count = 1;\n+  result->start.max_count = 2;\n+  result->end = end;\n+  result->level = level;\n+\n+  return result;\n+}\n+\n+/* Free a jump object and return the next object\n+   or NULL if this was the last one.  */\n+\n+static struct jump_info *\n+jump_info_free (struct jump_info *ji)\n+{\n+  struct jump_info *result = NULL;\n+\n+  if (ji)\n+    {\n+      result = ji->next;\n+      if (ji->start.addresses)\n+\tfree (ji->start.addresses);\n+      free (ji);\n+    }\n+\n+  return result;\n+}\n+\n+/* Get the smallest value of all start and end addresses.  */\n+\n+static bfd_vma\n+jump_info_min_address (const struct jump_info *ji)\n+{\n+  bfd_vma min_address = ji->end;\n+  size_t i;\n+\n+  for (i = ji->start.count; i-- > 0;)\n+    if (ji->start.addresses[i] < min_address)\n+      min_address = ji->start.addresses[i];\n+  return min_address;\n+}\n+\n+/* Get the largest value of all start and end addresses.  */\n+\n+static bfd_vma\n+jump_info_max_address (const struct jump_info *ji)\n+{\n+  bfd_vma max_address = ji->end;\n+  size_t i;\n+\n+  for (i = ji->start.count; i-- > 0;)\n+    if (ji->start.addresses[i] > max_address)\n+      max_address = ji->start.addresses[i];\n+  return max_address;\n+}\n+\n+/* Get the target address of a jump.  */\n+\n+static bfd_vma\n+jump_info_end_address (const struct jump_info *ji)\n+{\n+  return ji->end;\n+}\n+\n+/* Test if an address is one of the start addresses of a jump.  */\n+\n+static bfd_boolean\n+jump_info_is_start_address (const struct jump_info *ji, bfd_vma address)\n+{\n+  bfd_boolean result = FALSE;\n+  size_t i;\n+\n+  for (i = ji->start.count; i-- > 0;)\n+    if (address == ji->start.addresses[i])\n+      {\n+\tresult = TRUE;\n+\tbreak;\n+      }\n+\n+  return result;\n+}\n+\n+/* Test if an address is the target address of a jump.  */\n+\n+static bfd_boolean\n+jump_info_is_end_address (const struct jump_info *ji, bfd_vma address)\n+{\n+  return (address == ji->end);\n+}\n+\n+/* Get the difference between the smallest and largest address of a jump.  */\n+\n+static bfd_vma\n+jump_info_size (const struct jump_info *ji)\n+{\n+  return jump_info_max_address (ji) - jump_info_min_address (ji);\n+}\n+\n+/* Unlink a jump object from a list.  */\n+\n+static void\n+jump_info_unlink (struct jump_info *node,\n+\t\t  struct jump_info **base)\n+{\n+  if (node->next)\n+    node->next->prev = node->prev;\n+  if (node->prev)\n+    node->prev->next = node->next;\n+  else\n+    *base = node->next;\n+  node->next = NULL;\n+  node->prev = NULL;\n+}\n+\n+/* Insert unlinked jump info node into a list.  */\n+\n+static void\n+jump_info_insert (struct jump_info *node,\n+\t\t  struct jump_info *target,\n+\t\t  struct jump_info **base)\n+{\n+  node->next = target;\n+  node->prev = target->prev;\n+  target->prev = node;\n+  if (node->prev)\n+    node->prev->next = node;\n+  else\n+    *base = node;\n+}\n+\n+/* Add unlinked node to the front of a list.  */\n+\n+static void\n+jump_info_add_front (struct jump_info *node,\n+\t\t     struct jump_info **base)\n+{\n+  node->next = *base;\n+  if (node->next)\n+    node->next->prev = node;\n+  node->prev = NULL;\n+  *base = node;\n+}\n+\n+/* Move linked node to target position.  */\n+\n+static void\n+jump_info_move_linked (struct jump_info *node,\n+\t\t       struct jump_info *target,\n+\t\t       struct jump_info **base)\n+{\n+  /* Unlink node.  */\n+  jump_info_unlink (node, base);\n+  /* Insert node at target position.  */\n+  jump_info_insert (node, target, base);\n+}\n+\n+/* Test if two jumps intersect.  */\n+\n+static bfd_boolean\n+jump_info_intersect (const struct jump_info *a,\n+\t\t     const struct jump_info *b)\n+{\n+  return ((jump_info_max_address (a) >= jump_info_min_address (b))\n+\t  && (jump_info_min_address (a) <= jump_info_max_address (b)));\n+}\n+\n+/* Merge two compatible jump info objects.  */\n+\n+static void\n+jump_info_merge (struct jump_info **base)\n+{\n+  struct jump_info *a;\n+\n+  for (a = *base; a; a = a->next)\n+    {\n+      struct jump_info *b;\n+\n+      for (b = a->next; b; b = b->next)\n+\t{\n+\t  /* Merge both jumps into one.  */\n+\t  if (a->end == b->end)\n+\t    {\n+\t      /* Reallocate addresses.  */\n+\t      size_t needed_size = a->start.count + b->start.count;\n+\t      size_t i;\n+\n+\t      if (needed_size > a->start.max_count)\n+\t\t{\n+\t\t  a->start.max_count += b->start.max_count;\n+\t\t  a->start.addresses =\n+\t\t    xrealloc (a->start.addresses,\n+\t\t\t      a->start.max_count * sizeof(bfd_vma *));\n+\t\t}\n+\n+\t      /* Append start addresses.  */\n+\t      for (i = 0; i < b->start.count; ++i)\n+\t\ta->start.addresses[a->start.count++] =\n+\t\t  b->start.addresses[i];\n+\n+\t      /* Remove and delete jump.  */\n+\t      struct jump_info *tmp = b->prev;\n+\t      jump_info_unlink (b, base);\n+\t      jump_info_free (b);\n+\t      b = tmp;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Sort jumps by their size and starting point using a stable\n+   minsort. This could be improved if sorting performance is\n+   an issue, for example by using mergesort.  */\n+\n+static void\n+jump_info_sort (struct jump_info **base)\n+{\n+  struct jump_info *current_element = *base;\n+\n+  while (current_element)\n+    {\n+      struct jump_info *best_match = current_element;\n+      struct jump_info *runner = current_element->next;\n+      bfd_vma best_size = jump_info_size (best_match);\n+\n+      while (runner)\n+\t{\n+\t  bfd_vma runner_size = jump_info_size (runner);\n+\n+\t  if ((runner_size < best_size)\n+\t      || ((runner_size == best_size)\n+\t\t  && (jump_info_min_address (runner)\n+\t\t      < jump_info_min_address (best_match))))\n+\t    {\n+\t      best_match = runner;\n+\t      best_size = runner_size;\n+\t    }\n+\n+\t  runner = runner->next;\n+\t}\n+\n+      if (best_match == current_element)\n+\tcurrent_element = current_element->next;\n+      else\n+\tjump_info_move_linked (best_match, current_element, base);\n+    }\n+}\n+\n+/* Visualize all jumps at a given address.  */\n+\n+static void\n+jump_info_visualize_address (const struct jump_info *jumps,\n+\t\t\t     bfd_vma address,\n+\t\t\t     int max_level,\n+\t\t\t     char *line_buffer,\n+\t\t\t     uint8_t *color_buffer)\n+{\n+  size_t len = (max_level + 1) * 3;\n+  const struct jump_info *ji;\n+\n+  /* Clear line buffer.  */\n+  memset(line_buffer, ' ', len);\n+  memset(color_buffer, 0, len);\n+\n+  /* Iterate over jumps and add their ASCII art.  */\n+  for (ji = jumps; ji; ji = ji->next)\n+    {\n+      if ((jump_info_min_address (ji) <= address)\n+\t  && (jump_info_max_address (ji) >= address))\n+\t{\n+\t  /* Hash target address to get an even\n+\t     distribution between all values.  */\n+\t  bfd_vma hash_address = jump_info_end_address (ji);\n+\t  uint8_t color = iterative_hash_object (hash_address, 0);\n+\t  /* Fetch line offset.  */\n+\t  int offset = (max_level - ji->level) * 3;\n+\n+\t  /* Draw start line.  */\n+\t  if (jump_info_is_start_address (ji, address))\n+\t    {\n+\t      size_t i = offset + 1;\n+\n+\t      for (; i < len - 1; ++i)\n+\t\tif (line_buffer[i] == ' ')\n+\t\t  {\n+\t\t    line_buffer[i] = '-';\n+\t\t    color_buffer[i] = color;\n+\t\t  }\n+\n+\t      if (line_buffer[i] == ' ')\n+\t\t{\n+\t\t  line_buffer[i] = '-';\n+\t\t  color_buffer[i] = color;\n+\t\t}\n+\t      else if (line_buffer[i] == '>')\n+\t\t{\n+\t\t  line_buffer[i] = 'X';\n+\t\t  color_buffer[i] = color;\n+\t\t}\n+\n+\t      if (line_buffer[offset] == ' ')\n+\t\t{\n+\t\t  if (address <= ji->end)\n+\t\t    line_buffer[offset] =\n+\t\t      (jump_info_min_address (ji) == address) ? '/': '+';\n+\t\t  else\n+\t\t    line_buffer[offset] =\n+\t\t      (jump_info_max_address (ji) == address) ? '\\\\': '+';\n+\t\t  color_buffer[offset] = color;\n+\t\t}\n+\t    }\n+\t  /* Draw jump target.  */\n+\t  else if (jump_info_is_end_address (ji, address))\n+\t    {\n+\t      size_t i = offset + 1;\n+\n+\t      for (; i < len - 1; ++i)\n+\t\tif (line_buffer[i] == ' ')\n+\t\t  {\n+\t\t    line_buffer[i] = '-';\n+\t\t    color_buffer[i] = color;\n+\t\t  }\n+\n+\t      if (line_buffer[i] == ' ')\n+\t\t{\n+\t\t  line_buffer[i] = '>';\n+\t\t  color_buffer[i] = color;\n+\t\t}\n+\t      else if (line_buffer[i] == '-')\n+\t\t{\n+\t\t  line_buffer[i] = 'X';\n+\t\t  color_buffer[i] = color;\n+\t\t}\n+\n+\t      if (line_buffer[offset] == ' ')\n+\t\t{\n+\t\t  if (jump_info_min_address (ji) < address)\n+\t\t    line_buffer[offset] =\n+\t\t      (jump_info_max_address (ji) > address) ? '>' : '\\\\';\n+\t\t  else\n+\t\t    line_buffer[offset] = '/';\n+\t\t  color_buffer[offset] = color;\n+\t\t}\n+\t    }\n+\t  /* Draw intermediate line segment.  */\n+\t  else if (line_buffer[offset] == ' ')\n+\t    {\n+\t      line_buffer[offset] = '|';\n+\t      color_buffer[offset] = color;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Clone of disassemble_bytes to detect jumps inside a function.  */\n+/* FIXME: is this correct? Can we strip it down even further?  */\n+\n+static struct jump_info *\n+disassemble_jumps (struct disassemble_info * inf,\n+\t\t   disassembler_ftype        disassemble_fn,\n+\t\t   bfd_vma                   start_offset,\n+\t\t   bfd_vma                   stop_offset,\n+\t\t   bfd_vma\t\t     rel_offset,\n+\t\t   arelent ***               relppp,\n+\t\t   arelent **                relppend)\n+{\n+  struct objdump_disasm_info *aux;\n+  struct jump_info *jumps = NULL;\n+  asection *section;\n+  bfd_vma addr_offset;\n+  unsigned int opb = inf->octets_per_byte;\n+  int octets = opb;\n+  SFILE sfile;\n+\n+  aux = (struct objdump_disasm_info *) inf->application_data;\n+  section = inf->section;\n+\n+  sfile.alloc = 120;\n+  sfile.buffer = (char *) xmalloc (sfile.alloc);\n+  sfile.pos = 0;\n+\n+  inf->insn_info_valid = 0;\n+  inf->fprintf_func = (fprintf_ftype) objdump_sprintf;\n+  inf->stream = &sfile;\n+\n+  addr_offset = start_offset;\n+  while (addr_offset < stop_offset)\n+    {\n+      int previous_octets;\n+\n+      /* Remember the length of the previous instruction.  */\n+      previous_octets = octets;\n+      octets = 0;\n+\n+      sfile.pos = 0;\n+      inf->bytes_per_line = 0;\n+      inf->bytes_per_chunk = 0;\n+      inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)\n+        | (wide_output ? WIDE_OUTPUT : 0));\n+      if (machine)\n+\tinf->flags |= USER_SPECIFIED_MACHINE_TYPE;\n+\n+      if (inf->disassembler_needs_relocs\n+\t  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0\n+\t  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0\n+\t  && *relppp < relppend)\n+\t{\n+\t  bfd_signed_vma distance_to_rel;\n+\n+\t  distance_to_rel = (**relppp)->address - (rel_offset + addr_offset);\n+\n+\t  /* Check to see if the current reloc is associated with\n+\t     the instruction that we are about to disassemble.  */\n+\t  if (distance_to_rel == 0\n+\t      /* FIXME: This is wrong.  We are trying to catch\n+\t\t relocs that are addressed part way through the\n+\t\t current instruction, as might happen with a packed\n+\t\t VLIW instruction.  Unfortunately we do not know the\n+\t\t length of the current instruction since we have not\n+\t\t disassembled it yet.  Instead we take a guess based\n+\t\t upon the length of the previous instruction.  The\n+\t\t proper solution is to have a new target-specific\n+\t\t disassembler function which just returns the length\n+\t\t of an instruction at a given address without trying\n+\t\t to display its disassembly. */\n+\t      || (distance_to_rel > 0\n+\t\t&& distance_to_rel < (bfd_signed_vma) (previous_octets/ opb)))\n+\t    {\n+\t      inf->flags |= INSN_HAS_RELOC;\n+\t    }\n+\t}\n+\n+      if (! disassemble_all\n+\t  && (section->flags & (SEC_CODE | SEC_HAS_CONTENTS))\n+\t  == (SEC_CODE | SEC_HAS_CONTENTS))\n+\t/* Set a stop_vma so that the disassembler will not read\n+\t   beyond the next symbol.  We assume that symbols appear on\n+\t   the boundaries between instructions.  We only do this when\n+\t   disassembling code of course, and when -D is in effect.  */\n+\tinf->stop_vma = section->vma + stop_offset;\n+\n+      inf->stop_offset = stop_offset;\n+\n+      /* Extract jump information.  */\n+      inf->insn_info_valid = 0;\n+      octets = (*disassemble_fn) (section->vma + addr_offset, inf);\n+      /* Test if a jump was detected.  */\n+      if (inf->insn_info_valid\n+\t  && ((inf->insn_type == dis_branch)\n+\t      || (inf->insn_type == dis_condbranch)\n+\t      || (inf->insn_type == dis_jsr)\n+\t      || (inf->insn_type == dis_condjsr))\n+\t  && (inf->target >= section->vma + start_offset)\n+\t  && (inf->target < section->vma + stop_offset))\n+\t{\n+\t  struct jump_info *ji =\n+\t    jump_info_new (section->vma + addr_offset, inf->target, -1);\n+\t  jump_info_add_front (ji, &jumps);\n+\t}\n+\n+      inf->stop_vma = 0;\n+\n+      addr_offset += octets / opb;\n+    }\n+\n+  inf->fprintf_func = (fprintf_ftype) fprintf;\n+  inf->stream = stdout;\n+\n+  free (sfile.buffer);\n+\n+  /* Merge jumps.  */\n+  jump_info_merge (&jumps);\n+  /* Process jumps.  */\n+  jump_info_sort (&jumps);\n+\n+  /* Group jumps by level.  */\n+  struct jump_info *last_jump = jumps;\n+  int max_level = -1;\n+\n+  while (last_jump)\n+    {\n+      /* The last jump is part of the next group.  */\n+      struct jump_info *base = last_jump;\n+      /* Increment level.  */\n+      base->level = ++max_level;\n+\n+      /* Find jumps that can be combined on the same\n+\t level, with the largest jumps tested first.\n+\t This has the advantage that large jumps are on\n+\t lower levels and do not intersect with small\n+\t jumps that get grouped on higher levels.  */\n+      struct jump_info *exchange_item = last_jump->next;\n+      struct jump_info *it = exchange_item;\n+\n+      for (; it; it = it->next)\n+\t{\n+\t  /* Test if the jump intersects with any\n+\t     jump from current group.  */\n+\t  bfd_boolean ok = TRUE;\n+\t  struct jump_info *it_collision;\n+\n+\t  for (it_collision = base;\n+\t       it_collision != exchange_item;\n+\t       it_collision = it_collision->next)\n+\t    {\n+\t      /* This jump intersects so we leave it out.  */\n+\t      if (jump_info_intersect (it_collision, it))\n+\t\t{\n+\t\t  ok = FALSE;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* Add jump to group.  */\n+\t  if (ok)\n+\t    {\n+\t      /* Move current element to the front.  */\n+\t      if (it != exchange_item)\n+\t\t{\n+\t\t  struct jump_info *save = it->prev;\n+\t\t  jump_info_move_linked (it, exchange_item, &jumps);\n+\t\t  last_jump = it;\n+\t\t  it = save;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  last_jump = exchange_item;\n+\t\t  exchange_item = exchange_item->next;\n+\t\t}\n+\t      last_jump->level = max_level;\n+\t    }\n+\t}\n+\n+      /* Move to next group.  */\n+      last_jump = exchange_item;\n+    }\n+\n+  return jumps;\n+}\n+\n /* The number of zeroes we want to see before we start skipping them.\n    The number is arbitrarily chosen.  */\n \n@@ -1927,6 +2517,30 @@ disassemble_bytes (struct disassemble_info * inf,\n \n   inf->insn_info_valid = 0;\n \n+  /* Determine maximum level. */\n+  int max_level = -1;\n+  struct jump_info *base = detected_jumps ? detected_jumps : NULL;\n+  struct jump_info *ji;\n+\n+  for (ji = base; ji; ji = ji->next)\n+    {\n+      if (ji->level > max_level)\n+\t{\n+\t  max_level = ji->level;\n+\t}\n+    }\n+\n+  /* Allocate line buffer if there are any jumps.  */\n+  size_t len = (max_level + 1) * 3 + 1;\n+  char *line_buffer = (max_level >= 0) ? xmalloc(len): NULL;\n+  uint8_t *color_buffer = (max_level >= 0) ? xmalloc(len): NULL;\n+\n+  if (line_buffer)\n+    {\n+      line_buffer[len - 1] = 0;\n+      color_buffer[len - 1] = 0;\n+    }\n+\n   addr_offset = start_offset;\n   while (addr_offset < stop_offset)\n     {\n@@ -1998,6 +2612,44 @@ disassemble_bytes (struct disassemble_info * inf,\n \t      putchar (' ');\n \t    }\n \n+\t  /* Visualize jumps. */\n+\t  if (line_buffer)\n+\t    {\n+\t      jump_info_visualize_address (base,\n+\t\t\t\t\t   section->vma + addr_offset,\n+\t\t\t\t\t   max_level,\n+\t\t\t\t\t   line_buffer,\n+\t\t\t\t\t   color_buffer);\n+\n+\t      size_t line_buffer_size = strlen (line_buffer);\n+\t      char last_color = 0;\n+\n+\t      for (size_t i = 0; i <= line_buffer_size; ++i)\n+\t\t{\n+\t\t  if (color_output)\n+\t\t    {\n+\t\t      uint8_t color = (i < line_buffer_size) ? color_buffer[i]: 0;\n+\n+\t\t      if (color != last_color)\n+\t\t\t{\n+\t\t\t  if (color)\n+\t\t\t    if (extended_color_output)\n+\t\t\t      /* Use extended 8bit color, but\n+\t\t\t         do not choose dark colors.  */\n+\t\t\t      printf (\"\\033[38;5;%dm\", 124 + (color % 108));\n+\t\t\t    else\n+\t\t\t      /* Use simple terminal colors.  */\n+\t\t\t      printf (\"\\033[%dm\", 31 + (color % 7));\n+\t\t\t  else\n+\t\t\t    /* Clear color.  */\n+\t\t\t    printf (\"\\033[0m\");\n+\t\t\t  last_color = color;\n+\t\t\t}\n+\t\t    }\n+\t\t  putchar ((i < line_buffer_size) ? line_buffer[i]: ' ');\n+\t\t}\n+\t    }\n+\n \t  if (insns)\n \t    {\n \t      sfile.pos = 0;\n@@ -2291,6 +2943,8 @@ disassemble_bytes (struct disassemble_info * inf,\n     }\n \n   free (sfile.buffer);\n+  free (line_buffer);\n+  free (color_buffer);\n }\n \n static void\n@@ -2611,9 +3265,42 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \tinsns = FALSE;\n \n       if (do_print)\n-\tdisassemble_bytes (pinfo, paux->disassemble_fn, insns, data,\n-\t\t\t   addr_offset, nextstop_offset,\n-\t\t\t   rel_offset, &rel_pp, rel_ppend);\n+\t{\n+\t  /* Resolve symbol name.  */\n+\t  if (visualize_jumps && abfd && sym && sym->name)\n+\t    {\n+\t      struct disassemble_info di;\n+\t      SFILE sf;\n+\n+\t      sf.alloc = strlen (sym->name) + 40;\n+\t      sf.buffer = (char*) xmalloc (sf.alloc);\n+\t      sf.pos = 0;\n+\t      di.fprintf_func = (fprintf_ftype) objdump_sprintf;\n+\t      di.stream = &sf;\n+\n+\t      objdump_print_symname (abfd, &di, sym);\n+\n+\t      /* Fetch jump information.  */\n+\t      detected_jumps = disassemble_jumps\n+\t\t(pinfo, paux->disassemble_fn,\n+\t\t addr_offset, nextstop_offset,\n+\t\t rel_offset, &rel_pp, rel_ppend);\n+\n+\t      /* Free symbol name.  */\n+\t      free (sf.buffer);\n+\t    }\n+\n+\t  /* Add jumps to output.  */\n+\t  disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,\n+\t\t\t     addr_offset, nextstop_offset,\n+\t\t\t     rel_offset, &rel_pp, rel_ppend);\n+\n+\t  /* Free jumps.  */\n+\t  while (detected_jumps)\n+\t    {\n+\t      detected_jumps = jump_info_free (detected_jumps);\n+\t    }\n+\t}\n \n       addr_offset = nextstop_offset;\n       sym = nextsym;\n@@ -4437,6 +5124,25 @@ main (int argc, char **argv)\n \tcase OPTION_INLINES:\n \t  unwind_inlines = TRUE;\n \t  break;\n+\tcase OPTION_VISUALIZE_JUMPS:\n+\t  visualize_jumps = TRUE;\n+\t  color_output = FALSE;\n+\t  extended_color_output = FALSE;\n+\t  if (optarg != NULL)\n+\t    {\n+\t      if (streq (optarg, \"color\"))\n+\t\tcolor_output = TRUE;\n+\t      else if (streq (optarg, \"extended-color\"))\n+\t\t{\n+\t\t  color_output = TRUE;\n+\t\t  extended_color_output = TRUE;\n+\t\t}\n+\t      else if (streq (optarg, \"off\"))\n+\t\tvisualize_jumps = FALSE;\n+\t      else\n+\t\tnonfatal (_(\"unrecognized argument to --visualize-option\"));\n+\t    }\n+\t  break;\n \tcase 'E':\n \t  if (strcmp (optarg, \"B\") == 0)\n \t    endian = BFD_ENDIAN_BIG;"
    },
    {
      "sha": "8f3f94414b2e73a8ee5b5c4683916fa66036328a",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -1,3 +1,12 @@\n+2020-01-13  Thomas Troeger  <tstroege@gmx.de>\n+\n+\t* arm-dis.c (print_insn_arm): Fill in insn info fields for control\n+\tflow instructions.\n+\t(print_insn_thumb16, print_insn_thumb32): Likewise.\n+\t(print_insn): Initialize the insn info.\n+\t* i386-dis.c (print_insn): Initialize the insn info fields, and\n+\tdetect jumps.\n+\n 2012-01-13  Claudiu Zissulescu <claziss@gmail.com>\n \n \t* arc-opc.c (C_NE): Make it required."
    },
    {
      "sha": "b174f8335cdf7c3f90cafcb35995bf624512d719",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 44,
      "deletions": 3,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -9886,7 +9886,13 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t    case 'b':\n \t\t      {\n \t\t\tbfd_vma disp = (((given & 0xffffff) ^ 0x800000) - 0x800000);\n-\t\t\tinfo->print_address_func (disp * 4 + pc + 8, info);\n+\t\t\tbfd_vma target = disp * 4 + pc + 8;\n+\t\t\tinfo->print_address_func (target, info);\n+\n+\t\t\t/* Fill in instruction information.  */\n+\t\t\tinfo->insn_info_valid = 1;\n+\t\t\tinfo->insn_type = dis_branch;\n+\t\t\tinfo->target = target;\n \t\t      }\n \t\t      break;\n \n@@ -10024,6 +10030,11 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t  address += 2;\n \n \t\t        info->print_address_func (address, info);\n+\n+\t\t\t/* Fill in instruction information.  */\n+\t\t\tinfo->insn_info_valid = 1;\n+\t\t\tinfo->insn_type = dis_branch;\n+\t\t\tinfo->target = address;\n \t\t      }\n \t\t      break;\n \n@@ -10388,6 +10399,11 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t     + ((given & 0x00f8) >> 2)\n \t\t\t\t     + ((given & 0x0200) >> 3));\n \t\t  info->print_address_func (address, info);\n+\n+\t\t  /* Fill in instruction information.  */\n+\t\t  info->insn_info_valid = 1;\n+\t\t  info->insn_type = dis_branch;\n+\t\t  info->target = address;\n \t\t}\n \t\tbreak;\n \n@@ -10461,8 +10477,14 @@ print_insn_thumb16 (bfd_vma pc, struct disassemble_info *info, long given)\n \n \t\t\t  case 'B':\n \t\t\t    reg = ((reg ^ (1 << bitend)) - (1 << bitend));\n-\t\t\t    info->print_address_func (reg * 2 + pc + 4, info);\n+\t\t\t    bfd_vma target = reg * 2 + pc + 4;\n+\t\t\t    info->print_address_func (target, info);\n \t\t\t    value_in_comment = 0;\n+\n+\t\t\t    /* Fill in instruction information.  */\n+\t\t\t    info->insn_info_valid = 1;\n+\t\t\t    info->insn_type = dis_branch;\n+\t\t\t    info->target = target;\n \t\t\t    break;\n \n \t\t\t  case 'c':\n@@ -11019,7 +11041,13 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t  offset |= (given & 0x000007ff) << 1;\n \t\t  offset -= (1 << 20);\n \n-\t\t  info->print_address_func (pc + 4 + offset, info);\n+\t\t  bfd_vma target = pc + 4 + offset;\n+\t\t  info->print_address_func (target, info);\n+\n+\t\t  /* Fill in instruction information.  */\n+\t\t  info->insn_info_valid = 1;\n+\t\t  info->insn_type = dis_branch;\n+\t\t  info->target = target;\n \t\t}\n \t\tbreak;\n \n@@ -11043,6 +11071,11 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t      offset &= ~2u;\n \n \t\t  info->print_address_func (offset, info);\n+\n+\t\t  /* Fill in instruction information.  */\n+\t\t  info->insn_info_valid = 1;\n+\t\t  info->insn_type = dis_branch;\n+\t\t  info->target = offset;\n \t\t}\n \t\tbreak;\n \n@@ -11715,6 +11748,14 @@ print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n   bfd_boolean   found = FALSE;\n   struct arm_private_data *private_data;\n \n+  /* Clear instruction information field.  */\n+  info->insn_info_valid = 0;\n+  info->branch_delay_insns = 0;\n+  info->data_size = 0;\n+  info->insn_type = dis_noninsn;\n+  info->target = 0;\n+  info->target2 = 0;\n+\n   if (info->disassembler_options)\n     {\n       parse_arm_disassembler_options (info->disassembler_options);"
    },
    {
      "sha": "c73e964b5469b6f43c6a54f2a3227ad37dd71960",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 60,
      "deletions": 1,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1d67fe3b6e696fccb902d9919b9e58b7299a3205/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=1d67fe3b6e696fccb902d9919b9e58b7299a3205",
      "patch": "@@ -11069,6 +11069,9 @@ static const struct dis386 rm_table[][8] = {\n #define BND_PREFIX\t(0xf2 | 0x400)\n #define NOTRACK_PREFIX\t(0x3e | 0x100)\n \n+/* Remember if the current op is a jump instruction.  */\n+static bfd_boolean op_is_jump = FALSE;\n+\n static int\n ckprefix (void)\n {\n@@ -12143,6 +12146,50 @@ print_insn (bfd_vma pc, disassemble_info *info)\n \t}\n     }\n \n+  /* Clear instruction information.  */\n+  if (the_info)\n+    {\n+      the_info->insn_info_valid = 0;\n+      the_info->branch_delay_insns = 0;\n+      the_info->data_size = 0;\n+      the_info->insn_type = dis_noninsn;\n+      the_info->target = 0;\n+      the_info->target2 = 0;\n+    }\n+\n+  /* Reset jump operation indicator.  */\n+  op_is_jump = FALSE;\n+\n+  {\n+    int jump_detection = 0;\n+\n+    /* Extract flags.  */\n+    for (i = 0; i < MAX_OPERANDS; ++i)\n+      {\n+\tif ((dp->op[i].rtn == OP_J)\n+\t    || (dp->op[i].rtn == OP_indirE))\n+\t  jump_detection |= 1;\n+\telse if ((dp->op[i].rtn == BND_Fixup)\n+\t\t || (!dp->op[i].rtn && !dp->op[i].bytemode))\n+\t  jump_detection |= 2;\n+\telse if ((dp->op[i].bytemode == cond_jump_mode)\n+\t\t || (dp->op[i].bytemode == loop_jcxz_mode))\n+\t  jump_detection |= 4;\n+      }\n+\n+    /* Determine if this is a jump or branch.  */\n+    if ((jump_detection & 0x3) == 0x3)\n+      {\n+\top_is_jump = TRUE;\n+\tif (jump_detection & 0x4)\n+\t  the_info->insn_type = dis_condbranch;\n+\telse\n+\t  the_info->insn_type =\n+\t    (dp->name && !strncmp(dp->name, \"call\", 4))\n+\t    ? dis_jsr : dis_branch;\n+      }\n+  }\n+\n   /* If VEX.vvvv and EVEX.vvvv are unused, they must be all 1s, which\n      are all 0s in inverted form.  */\n   if (need_vex && vex.register_specifier != 0)\n@@ -12256,7 +12303,19 @@ print_insn (bfd_vma pc, disassemble_info *info)\n \tif (needcomma)\n \t  (*info->fprintf_func) (info->stream, \",\");\n \tif (op_index[i] != -1 && !op_riprel[i])\n-\t  (*info->print_address_func) ((bfd_vma) op_address[op_index[i]], info);\n+\t  {\n+\t    bfd_vma target = (bfd_vma) op_address[op_index[i]];\n+\n+\t    if (the_info && op_is_jump)\n+\t      {\n+\t\tthe_info->insn_info_valid = 1;\n+\t\tthe_info->branch_delay_insns = 0;\n+\t\tthe_info->data_size = 0;\n+\t\tthe_info->target = target;\n+\t\tthe_info->target2 = 0;\n+\t      }\n+\t    (*info->print_address_func) (target, info);\n+\t  }\n \telse\n \t  (*info->fprintf_func) (info->stream, \"%s\", op_txt[i]);\n \tneedcomma = 1;"
    }
  ]
}