{
  "sha": "2735d4218ea81ea83458007a80e4132fa6e73668",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjczNWQ0MjE4ZWE4MWVhODM0NTgwMDdhODBlNDEzMmZhNmU3MzY2OA==",
  "commit": {
    "author": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2020-03-05T00:42:42Z"
    },
    "committer": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2020-07-22T19:38:33Z"
    },
    "message": "Provide access to non SEC_HAS_CONTENTS core file sections\n\nConsider the following program:\n\n- - - mkmmapcore.c - - -\n\nstatic char *buf;\n\nint\nmain (int argc, char **argv)\n{\n  buf = mmap (NULL, 8192, PROT_READ | PROT_WRITE,\n              MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n  abort ();\n}\n- - - end mkmmapcore.c - - -\n\nCompile it like this:\n\ngcc -g -o mkmmapcore mkmmapcore.c\n\nNow let's run it from GDB.  I've already placed a breakpoint on the\nline with the abort() call and have run to that breakpoint.\n\nBreakpoint 1, main (argc=1, argv=0x7fffffffd678) at mkmmapcore.c:11\n11\t  abort ();\n(gdb) x/x buf\n0x7ffff7fcb000:\t0x00000000\n\nNote that we can examine the memory allocated via the call to mmap().\n\nNow let's try debugging a core file created by running this program.\nDepending on your system, in order to make a core file, you may have to\nrun the following as root (or using sudo):\n\n    echo core > /proc/sys/kernel/core_pattern\n\nIt may also be necessary to do:\n\n    ulimit -c unlimited\n\nI'm using Fedora 31. YMMV if you're using one of the BSDs or some other\n(non-Linux) system.\n\nThis is what things look like when we debug the core file:\n\n    [kev@f31-1 tmp]$ gdb -q ./mkmmapcore core.304767\n    Reading symbols from ./mkmmapcore...\n    [New LWP 304767]\n    Core was generated by `/tmp/mkmmapcore'.\n    Program terminated with signal SIGABRT, Aborted.\n    #0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:50\n    50\t  return ret;\n    (gdb) x/x buf\n    0x7ffff7fcb000:\tCannot access memory at address 0x7ffff7fcb000\n\nNote that we can no longer access the memory region allocated by mmap().\n\nBack in 2007, a hack for GDB was added to _bfd_elf_make_section_from_phdr()\nin bfd/elf.c:\n\n\t  /* Hack for gdb.  Segments that have not been modified do\n\t     not have their contents written to a core file, on the\n\t     assumption that a debugger can find the contents in the\n\t     executable.  We flag this case by setting the fake\n\t     section size to zero.  Note that \"real\" bss sections will\n\t     always have their contents dumped to the core file.  */\n\t  if (bfd_get_format (abfd) == bfd_core)\n\t    newsect->size = 0;\n\nYou can find the entire patch plus links to other discussion starting\nhere:\n\n    https://sourceware.org/ml/binutils/2007-08/msg00047.html\n\nThis hack sets the size of certain BFD sections to 0, which\neffectively causes GDB to ignore them.  I think it's likely that the\nbug described above existed even before this hack was added, but I\nhave no easy way to test this now.\n\nThe output from objdump -h shows the result of this hack:\n\n 25 load13        00000000  00007ffff7fcb000  0000000000000000  00013000  2**12\n                  ALLOC\n\n(The first field, after load13, shows the size of 0.)\n\nOnce the hack is removed, the output from objdump -h shows the correct\nsize:\n\n 25 load13        00002000  00007ffff7fcb000  0000000000000000  00013000  2**12\n                  ALLOC\n\n(This is a digression, but I think it's good that objdump will now show\nthe correct size.)\n\nIf we remove the hack from bfd/elf.c, but do nothing to GDB, we'll\nsee the following regression:\n\nFAIL: gdb.base/corefile.exp: print coremaker_ro\n\nThe reason for this is that all sections which have the BFD flag\nSEC_ALLOC set, but for which SEC_HAS_CONTENTS is not set no longer\nhave zero size.  Some of these sections have data that can (and should)\nbe read from the executable.  (Sections for which SEC_HAS_CONTENTS\nis set should be read from the core file; sections which do not have\nthis flag set need to either be read from the executable or, failing\nthat, from the core file using whatever BFD decides is the best value\nto present to the user - it uses zeros.)\n\nAt present, due to the way that the target strata are traversed when\nattempting to access memory, the non-SEC_HAS_CONTENTS sections will be\nread as zeroes from the process_stratum (which in this case is the\ncore file stratum) without first checking the file stratum, which is\nwhere the data might actually be found.\n\nWhat we should be doing is this:\n\n- Attempt to access core file data for SEC_HAS_CONTENTS sections.\n- Attempt to access executable file data if the above fails.\n- Attempt to access core file data for non SEC_HAS_CONTENTS sections, if\n  both of the above fail.\n\nThis corresponds to the analysis of Daniel Jacobowitz back in 2007\nwhen the hack was added to BFD:\n\n    https://sourceware.org/legacy-ml/binutils/2007-08/msg00045.html\n\nThe difference, observed by Pedro in his review of my v1 patches, is\nthat I'm using \"the section flags as proxy for the p_filesz/p_memsz\nchecks.\"\n\ngdb/ChangeLog:\n\n\tPR corefiles/25631\n\t* corelow.c (core_target:xfer_partial):  Revise\n\tTARGET_OBJECT_MEMORY case to consider non-SEC_HAS_CONTENTS\n\tcase after first checking the stratum beneath the core\n\ttarget.\n\t(has_all_memory): Return true.\n\t* target.c (raw_memory_xfer_partial): Revise comment\n\tregarding use of has_all_memory.",
    "tree": {
      "sha": "eb74841883875c325209f2d625422809ec9c39d2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/eb74841883875c325209f2d625422809ec9c39d2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2735d4218ea81ea83458007a80e4132fa6e73668",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2735d4218ea81ea83458007a80e4132fa6e73668",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2735d4218ea81ea83458007a80e4132fa6e73668",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2735d4218ea81ea83458007a80e4132fa6e73668/comments",
  "author": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e56cb451c9ca63bdafc11cc3d3ee14b74e409fa9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e56cb451c9ca63bdafc11cc3d3ee14b74e409fa9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e56cb451c9ca63bdafc11cc3d3ee14b74e409fa9"
    }
  ],
  "stats": {
    "total": 65,
    "additions": 57,
    "deletions": 8
  },
  "files": [
    {
      "sha": "2c7506e0d44e978a854d0bd5f9e4e58611fafe05",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2735d4218ea81ea83458007a80e4132fa6e73668",
      "patch": "@@ -1,3 +1,14 @@\n+2020-07-22  Kevin Buettner  <kevinb@redhat.com>\n+\n+\tPR corefiles/25631\n+\t* corelow.c (core_target:xfer_partial):  Revise\n+\tTARGET_OBJECT_MEMORY case to consider non-SEC_HAS_CONTENTS\n+\tcase after first checking the stratum beneath the core\n+\ttarget.\n+\t(has_all_memory): Return true.\n+\t* target.c (raw_memory_xfer_partial): Revise comment\n+\tregarding use of has_all_memory.\n+\n 2020-07-22  Kevin Buettner  <kevinb@redhat.com>\n \n \t* exec.h (section_table_xfer_memory): Revise declaration,"
    },
    {
      "sha": "31d313860b4e2784c0fd38552fc82e21e143c7a9",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 41,
      "deletions": 6,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=2735d4218ea81ea83458007a80e4132fa6e73668",
      "patch": "@@ -87,7 +87,7 @@ class core_target final : public process_stratum_target\n \n   const char *thread_name (struct thread_info *) override;\n \n-  bool has_all_memory () override { return false; }\n+  bool has_all_memory () override { return true; }\n   bool has_memory () override;\n   bool has_stack () override;\n   bool has_registers () override;\n@@ -614,12 +614,47 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n   switch (object)\n     {\n     case TARGET_OBJECT_MEMORY:\n-      return (section_table_xfer_memory_partial\n-\t      (readbuf, writebuf,\n-\t       offset, len, xfered_len,\n-\t       m_core_section_table.sections,\n-\t       m_core_section_table.sections_end));\n+      {\n+\tenum target_xfer_status xfer_status;\n+\n+\t/* Try accessing memory contents from core file data,\n+\t   restricting consideration to those sections for which\n+\t   the BFD section flag SEC_HAS_CONTENTS is set.  */\n+\tauto has_contents_cb = [] (const struct target_section *s)\n+\t  {\n+\t    return ((s->the_bfd_section->flags & SEC_HAS_CONTENTS) != 0);\n+\t  };\n+\txfer_status = section_table_xfer_memory_partial\n+\t\t\t(readbuf, writebuf,\n+\t\t\t offset, len, xfered_len,\n+\t\t\t m_core_section_table.sections,\n+\t\t\t m_core_section_table.sections_end,\n+\t\t\t has_contents_cb);\n+\tif (xfer_status == TARGET_XFER_OK)\n+\t  return TARGET_XFER_OK;\n+\n+\t/* Now check the stratum beneath us; this should be file_stratum.  */\n+\txfer_status = this->beneath ()->xfer_partial (object, annex, readbuf,\n+\t\t\t\t\t\t      writebuf, offset, len,\n+\t\t\t\t\t\t      xfered_len);\n+\tif (xfer_status == TARGET_XFER_OK)\n+\t  return TARGET_XFER_OK;\n \n+\t/* Finally, attempt to access data in core file sections with\n+\t   no contents.  These will typically read as all zero.  */\n+\tauto no_contents_cb = [&] (const struct target_section *s)\n+\t  {\n+\t    return !has_contents_cb (s);\n+\t  };\n+\txfer_status = section_table_xfer_memory_partial\n+\t\t\t(readbuf, writebuf,\n+\t\t\t offset, len, xfered_len,\n+\t\t\t m_core_section_table.sections,\n+\t\t\t m_core_section_table.sections_end,\n+\t\t\t no_contents_cb);\n+\n+\treturn xfer_status;\n+      }\n     case TARGET_OBJECT_AUXV:\n       if (readbuf)\n \t{"
    },
    {
      "sha": "58189e6202442d85e24d93e1b809aa50b2800b60",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 5,
      "deletions": 2,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2735d4218ea81ea83458007a80e4132fa6e73668/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=2735d4218ea81ea83458007a80e4132fa6e73668",
      "patch": "@@ -925,8 +925,11 @@ raw_memory_xfer_partial (struct target_ops *ops, gdb_byte *readbuf,\n       if (res == TARGET_XFER_UNAVAILABLE)\n \tbreak;\n \n-      /* We want to continue past core files to executables, but not\n-\t past a running target's memory.  */\n+      /* Don't continue past targets which have all the memory.\n+         At one time, this code was necessary to read data from\n+\t executables / shared libraries when data for the requested\n+\t addresses weren't available in the core file.  But now the\n+\t core target handles this case itself.  */\n       if (ops->has_all_memory ())\n \tbreak;\n "
    }
  ]
}