{
  "sha": "34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
  "node_id": "C_kwDOANOeidoAKDM0YzliMmI0OWJlMGJiMGVhM2VmZGMxOTNmYzBhOGY2MTU3NzVmMDk",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "message": "Don't enable async mode at the end of target ::resume methods.\n\nNow that target_resume always enables async mode after target::resume\nreturns, these calls are redundant.\n\nThe other place that target resume methods are invoked outside of\ntarget_resume are as the beneath target in record_full_wait_1.  In\nthis case, async mode should already be enabled when supported by the\ntarget before the resume method is invoked due to the following:\n\n  In general, targets which support async mode run as async until\n  ::wait returns TARGET_WAITKIND_NO_RESUMED to indicate that there are\n  no unwaited for children (either they have exited or are stopped).\n  When that occurs, the loop in wait_one disables async mode.  Later\n  if a stopped child is resumed, async mode is re-enabled in\n  do_target_resume before waiting for the next event.\n\n  In the case of record_full_wait_1, this function is invoked from the\n  ::wait target method when fetching an event.  If the underlying\n  target supports async mode, then an earlier call to do_target_resume\n  to resume the child reporting an event in the loop in\n  record_full_wait_1 would have already enabled async mode before\n  ::wait was invoked.  In addition, nothing in the code executed in\n  the loop in record_full_wait_1 disables async mode.  Async mode is\n  only disabled higher in the call stack in wait_one after ::wait\n  returns.\n\n  It is also true that async mode can be disabled by an\n  INF_EXEC_COMPLETE event passed to inferior_event_handle, but all of\n  the places that invoke that are in the gdb core which is \"above\" a\n  target ::wait method.\n\nNote that there is an earlier call to enable async mode in\nlinux_nat_target::resume.  That call also marks the async event pipe\nto report an existing event after enabling async mode, so it needs to\nstay.",
    "tree": {
      "sha": "d0a40b9e917242d4e1de24a08622c4acd89ae547",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d0a40b9e917242d4e1de24a08622c4acd89ae547"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "38ba82db783e7dde2e73212be71c92872d875e4d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/38ba82db783e7dde2e73212be71c92872d875e4d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/38ba82db783e7dde2e73212be71c92872d875e4d"
    }
  ],
  "stats": {
    "total": 23,
    "additions": 0,
    "deletions": 23
  },
  "files": [
    {
      "sha": "58660f0f80e457a1ee3fffe3779f1c41e45ce483",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
      "patch": "@@ -1703,9 +1703,6 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t\t\t   ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \n   linux_resume_one_lwp (lp, step, signo);\n-\n-  if (target_can_async_p ())\n-    target_async (1);\n }\n \n /* Send a signal to an LWP.  */"
    },
    {
      "sha": "bd8c49c1abea4e6d0a9a296b474ab5767c553fb8",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
      "patch": "@@ -1095,11 +1095,6 @@ record_full_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n \n       this->beneath ()->resume (ptid, step, signal);\n     }\n-\n-  /* We are about to start executing the inferior (or simulate it),\n-     let's register it with the event loop.  */\n-  if (target_can_async_p ())\n-    target_async (1);\n }\n \n static int record_full_get_sig = 0;\n@@ -2062,11 +2057,6 @@ record_full_core_target::resume (ptid_t ptid, int step,\n   record_full_resume_step = step;\n   record_full_resumed = 1;\n   record_full_execution_dir = ::execution_direction;\n-\n-  /* We are about to start executing the inferior (or simulate it),\n-     let's register it with the event loop.  */\n-  if (target_can_async_p ())\n-    target_async (1);\n }\n \n /* \"kill\" method for prec over corefile.  */"
    },
    {
      "sha": "f285beb9d140b23246e7606db46a8a99d7cd1a3b",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/34c9b2b49be0bb0ea3efdc193fc0a8f615775f09/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=34c9b2b49be0bb0ea3efdc193fc0a8f615775f09",
      "patch": "@@ -6571,16 +6571,6 @@ remote_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n   for (thread_info *tp : all_non_exited_threads (this, ptid))\n     get_remote_thread_info (tp)->set_resumed ();\n \n-  /* We are about to start executing the inferior, let's register it\n-     with the event loop.  NOTE: this is the one place where all the\n-     execution commands end up.  We could alternatively do this in each\n-     of the execution commands in infcmd.c.  */\n-  /* FIXME: ezannoni 1999-09-28: We may need to move this out of here\n-     into infcmd.c in order to allow inferior function calls to work\n-     NOT asynchronously.  */\n-  if (target_can_async_p ())\n-    target_async (1);\n-\n   /* We've just told the target to resume.  The remote server will\n      wait for the inferior to stop, and then send a stop reply.  In\n      the mean time, we can't start another command/query ourselves"
    }
  ]
}