{
  "sha": "000fe1a756e707624d387eeacbaa959a01f0d040",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDAwZmUxYTc1NmU3MDc2MjRkMzg3ZWVhY2JhYTk1OWEwMWYwZDA0MA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-20T00:26:29Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-20T03:06:06Z"
    },
    "message": "ubsan: m68hc1x: left shift of negative value\n\n\t* m68hc11-dis.c (read_memory): Delete forward decls.\n\t(print_indexed_operand, print_insn): Likewise.\n\t(print_indexed_operand): Formatting.  Don't rely on short being\n\texactly 16 bits, make sign extension explicit.\n\t(print_insn): Likewise.  Avoid signed overflow.",
    "tree": {
      "sha": "0f606d22dd6404817490848b2719ba9c9ab2107a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0f606d22dd6404817490848b2719ba9c9ab2107a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/000fe1a756e707624d387eeacbaa959a01f0d040",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/000fe1a756e707624d387eeacbaa959a01f0d040",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/000fe1a756e707624d387eeacbaa959a01f0d040",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/000fe1a756e707624d387eeacbaa959a01f0d040/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9d78076ef8ef07890ad89c1122bdf49932a979a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d78076ef8ef07890ad89c1122bdf49932a979a5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9d78076ef8ef07890ad89c1122bdf49932a979a5"
    }
  ],
  "stats": {
    "total": 186,
    "additions": 81,
    "deletions": 105
  },
  "files": [
    {
      "sha": "36667aea510da387481b6a396c1914a3d5301911",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/000fe1a756e707624d387eeacbaa959a01f0d040/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/000fe1a756e707624d387eeacbaa959a01f0d040/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=000fe1a756e707624d387eeacbaa959a01f0d040",
      "patch": "@@ -1,3 +1,11 @@\n+2019-12-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* m68hc11-dis.c (read_memory): Delete forward decls.\n+\t(print_indexed_operand, print_insn): Likewise.\n+\t(print_indexed_operand): Formatting.  Don't rely on short being\n+\texactly 16 bits, make sign extension explicit.\n+\t(print_insn): Likewise.  Avoid signed overflow.\n+\n 2019-12-19  Alan Modra  <amodra@gmail.com>\n \n \t* vax-dis.c (print_insn_mode): Stop index mode recursion."
    },
    {
      "sha": "2a1048167072bfd831571cb28899aa0d29a7568d",
      "filename": "opcodes/m68hc11-dis.c",
      "status": "modified",
      "additions": 73,
      "deletions": 105,
      "changes": 178,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/000fe1a756e707624d387eeacbaa959a01f0d040/opcodes/m68hc11-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/000fe1a756e707624d387eeacbaa959a01f0d040/opcodes/m68hc11-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m68hc11-dis.c?ref=000fe1a756e707624d387eeacbaa959a01f0d040",
      "patch": "@@ -45,11 +45,6 @@ static const char *const reg_dst_table[] =\n \n #define OP_PAGE_MASK (M6811_OP_PAGE2|M6811_OP_PAGE3|M6811_OP_PAGE4)\n \n-/* Prototypes for local functions.  */\n-static int read_memory (bfd_vma, bfd_byte *, int, struct disassemble_info *);\n-static int print_indexed_operand (bfd_vma, struct disassemble_info *,\n-                                  int*, int, int, bfd_vma, int);\n-static int print_insn (bfd_vma, struct disassemble_info *, int);\n \n static int\n read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,\n@@ -73,13 +68,13 @@ read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,\n    Returns the number of bytes read or -1 if failure.  */\n static int\n print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,\n-                       int* indirect, int mov_insn, int pc_offset,\n-                       bfd_vma endaddr, int arch)\n+\t\t       int* indirect, int mov_insn, int pc_offset,\n+\t\t       bfd_vma endaddr, int arch)\n {\n   bfd_byte buffer[4];\n   int reg;\n   int status;\n-  short sval;\n+  bfd_vma val;\n   int pos = 1;\n \n   if (indirect)\n@@ -95,23 +90,22 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,\n   if ((buffer[0] & 0x20) == 0)\n     {\n       reg = (buffer[0] >> 6) & 3;\n-      sval = (buffer[0] & 0x1f);\n-      if (sval & 0x10)\n-\tsval |= 0xfff0;\n+      val = ((buffer[0] & 0x1f) ^ 0x10) - 0x10;\n       /* 68HC12 requires an adjustment for movb/movw pc relative modes.  */\n       if (reg == PC_REGNUM && info->mach == bfd_mach_m6812 && mov_insn)\n-        sval += pc_offset;\n+\tval += pc_offset;\n       (*info->fprintf_func) (info->stream, \"0x%x,%s\",\n-\t\t\t     (unsigned short) sval, reg_name[reg]);\n+\t\t\t     (unsigned) val & 0xffff, reg_name[reg]);\n \n       if (reg == PC_REGNUM)\n-        {\n-          (* info->fprintf_func) (info->stream, \" {\");\n-\t      if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */\n-\t        (*info->fprintf_func) (info->stream, \"0x\");\n-          (* info->print_address_func) (endaddr + sval, info);\n-          (* info->fprintf_func) (info->stream, \"}\");\n-        }\n+\t{\n+\t  (* info->fprintf_func) (info->stream, \" {\");\n+\t   /* Avoid duplicate 0x from core binutils.  */\n+\t  if (info->symtab_size > 0)\n+\t    (*info->fprintf_func) (info->stream, \"0x\");\n+\t  (* info->print_address_func) (endaddr + val, info);\n+\t  (* info->fprintf_func) (info->stream, \"}\");\n+\t}\n     }\n \n   /* Auto pre/post increment/decrement.  */\n@@ -120,88 +114,81 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,\n       const char *mode;\n \n       reg = (buffer[0] >> 6) & 3;\n-      sval = (buffer[0] & 0x0f);\n-      if (sval & 0x8)\n+      val = buffer[0] & 7;\n+      if (buffer[0] & 8)\n \t{\n-\t  sval |= 0xfff0;\n-\t  sval = -sval;\n+\t  val = 8 - val;\n \t  mode = \"-\";\n \t}\n       else\n \t{\n-\t  sval = sval + 1;\n+\t  val = val + 1;\n \t  mode = \"+\";\n \t}\n       (*info->fprintf_func) (info->stream, \"%d,%s%s%s\",\n-\t\t\t     (unsigned short) sval,\n-\t\t\t     (buffer[0] & 0x10 ? \"\" : mode),\n-\t\t\t     reg_name[reg], (buffer[0] & 0x10 ? mode : \"\"));\n+\t\t\t     (unsigned) val,\n+\t\t\t     buffer[0] & 0x10 ? \"\" : mode,\n+\t\t\t     reg_name[reg], buffer[0] & 0x10 ? mode : \"\");\n     }\n \n   /* [n,r] 16-bits offset indexed indirect.  */\n   else if ((buffer[0] & 0x07) == 3)\n     {\n       if ((mov_insn) && (!(arch & cpu9s12x)))\n-      \t{\n-      \t  (*info->fprintf_func) (info->stream, \"<invalid op: 0x%x>\",\n-    \t\t\t\t buffer[0] & 0x0ff);\n-      \t  return 0;\n-      \t}\n+\t{\n+\t  (*info->fprintf_func) (info->stream, \"<invalid op: 0x%x>\",\n+\t\t\t\t buffer[0] & 0x0ff);\n+\t  return 0;\n+\t}\n       reg = (buffer[0] >> 3) & 0x03;\n       status = read_memory (memaddr + pos, &buffer[0], 2, info);\n       if (status != 0)\n-\t{\n-\t  return status;\n-\t}\n+\treturn status;\n \n       pos += 2;\n-      sval = ((buffer[0] << 8) | (buffer[1] & 0x0FF));\n+      val = (buffer[0] << 8) | buffer[1];\n       (*info->fprintf_func) (info->stream, \"[0x%x,%s]\",\n-\t\t\t     sval & 0x0ffff, reg_name[reg]);\n+\t\t\t     (unsigned) val & 0xffff, reg_name[reg]);\n       if (indirect)\n-        *indirect = 1;\n+\t*indirect = 1;\n     }\n \n   /* n,r with 9 and 16 bit signed constant.  */\n   else if ((buffer[0] & 0x4) == 0)\n     {\n       if ((mov_insn) && (!(arch & cpu9s12x)))\n-      \t{\n-      \t  (*info->fprintf_func) (info->stream, \"<invalid op: 0x%x>\",\n-    \t\t\t\t buffer[0] & 0x0ff);\n-      \t  return 0;\n-      \t}\n+\t{\n+\t  (*info->fprintf_func) (info->stream, \"<invalid op: 0x%x>\",\n+\t\t\t\t buffer[0] & 0x0ff);\n+\t  return 0;\n+\t}\n \n       reg = (buffer[0] >> 3) & 0x03;\n       status = read_memory (memaddr + pos,\n \t\t\t    &buffer[1], (buffer[0] & 0x2 ? 2 : 1), info);\n       if (status != 0)\n-\t{\n-\t  return status;\n-\t}\n+\treturn status;\n+\n       if (buffer[0] & 2)\n \t{\n-\t  sval = ((buffer[1] << 8) | (buffer[2] & 0x0FF));\n-\t  sval &= 0x0FFFF;\n+\t  val = (((buffer[1] << 8) | buffer[2]) ^ 0x8000) - 0x8000;\n \t  pos += 2;\n-          endaddr += 2;\n+\t  endaddr += 2;\n \t}\n       else\n \t{\n-\t  sval = buffer[1] & 0x00ff;\n-\t  if (buffer[0] & 0x01)\n-\t    sval |= 0xff00;\n+\t  val = buffer[1] - ((buffer[0] & 1) << 8);\n \t  pos++;\n-          endaddr++;\n+\t  endaddr++;\n \t}\n       (*info->fprintf_func) (info->stream, \"0x%x,%s\",\n-\t\t\t     (unsigned short) sval, reg_name[reg]);\n+\t\t\t     (unsigned) val & 0xffff, reg_name[reg]);\n       if (reg == PC_REGNUM)\n-        {\n-          (* info->fprintf_func) (info->stream, \" {0x\");\n-          (* info->print_address_func) (endaddr + sval, info);\n-          (* info->fprintf_func) (info->stream, \"}\");\n-        }\n+\t{\n+\t  (* info->fprintf_func) (info->stream, \" {0x\");\n+\t  (* info->print_address_func) (endaddr + val, info);\n+\t  (* info->fprintf_func) (info->stream, \"}\");\n+\t}\n     }\n   else\n     {\n@@ -220,8 +207,8 @@ print_indexed_operand (bfd_vma memaddr, struct disassemble_info* info,\n \tcase 3:\n \tdefault:\n \t  (*info->fprintf_func) (info->stream, \"[D,%s]\", reg_name[reg]);\n-          if (indirect)\n-            *indirect = 1;\n+\t  if (indirect)\n+\t    *indirect = 1;\n \t  break;\n \t}\n     }\n@@ -238,12 +225,11 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n   bfd_byte buffer[4];\n   unsigned int code;\n   long format, pos, i;\n-  short sval;\n+  bfd_vma val;\n   const struct m68hc11_opcode *opcode;\n \n   if (arch & cpuxgate)\n     {\n-      int val;\n       /* Get two bytes as all XGATE instructions are 16bit.  */\n       status = read_memory (memaddr, buffer, 2, info);\n       if (status != 0)\n@@ -295,17 +281,14 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \t  else if (format & M68XG_OP_REL9)\n \t    {\n \t      (*info->fprintf_func) (info->stream, \" 0x\");\n-\t      val = (buffer[0] & 0x1) ? buffer[1] | 0xFFFFFF00 : buffer[1];\n+\t      val = buffer[1] - ((buffer[0] & 1) << 8);\n \t      (*info->print_address_func) (memaddr + (val << 1) + 2, info);\n \t    }\n \t  else if (format & M68XG_OP_REL10)\n \t    {\n \t      (*info->fprintf_func) (info->stream, \" 0x\");\n-\t      val = (buffer[0] << 8) | (unsigned int) buffer[1];\n-\t      if (val & 0x200)\n-\t\tval |= 0xfffffc00;\n-\t      else\n-\t\tval &= 0x000001ff;\n+\t      val = (buffer[0] << 8) | buffer[1];\n+\t      val = ((val & 0x3ff) ^ 0x200) - 0x200;\n \t      (*info->print_address_func) (memaddr + (val << 1) + 2, info);\n \t    }\n \t  else if ((code & 0x00ff) == 0x00f8)\n@@ -639,13 +622,11 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \n \t  (*info->fprintf_func) (info->stream, \"%s,\",\n \t\t\t\t reg_src_table[buffer[0] & 0x07]);\n-\t  sval = buffer[1] & 0x0ff;\n-\t  if (buffer[0] & 0x10)\n-\t    sval |= 0xff00;\n+\t  val = buffer[1] - ((buffer[0] & 0x10) << 4);\n \n \t  pos += 2;\n \t  (*info->fprintf_func) (info->stream, \"0x\");\n-\t  (*info->print_address_func) (memaddr + pos + sval, info);\n+\t  (*info->print_address_func) (memaddr + pos + val, info);\n \t  format &= ~(M6812_OP_REG | M6811_OP_JUMP_REL);\n \t}\n       else if (format & (M6812_OP_REG | M6812_OP_REG_2))\n@@ -662,7 +643,6 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \n       if (format & (M6811_OP_IMM16 | M6811_OP_IND16))\n \t{\n-\t  int val;\n \t  bfd_vma addr;\n \t  unsigned page = 0;\n \n@@ -676,26 +656,23 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \t    offset = 0;\n \t  pos += 2;\n \n-\t  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));\n-\t  val &= 0x0FFFF;\n-\t  addr = val;\n+\t  addr = val = (buffer[0] << 8) | buffer[1];\n \t  pc_dst_offset = 2;\n \t  if (format & M6812_OP_PAGE)\n \t    {\n \t      status = read_memory (memaddr + pos + offset, buffer, 1, info);\n \t      if (status != 0)\n \t\treturn status;\n \n-\t      page = (unsigned) buffer[0];\n+\t      page = buffer[0];\n \t      if (addr >= M68HC12_BANK_BASE && addr < 0x0c000)\n-\t\taddr = ((val - M68HC12_BANK_BASE)\n-\t\t\t| (page << M68HC12_BANK_SHIFT))\n-\t\t  + M68HC12_BANK_VIRT;\n+\t\taddr = (val - M68HC12_BANK_BASE + (page << M68HC12_BANK_SHIFT)\n+\t\t\t+ M68HC12_BANK_VIRT);\n \t    }\n \t  else if ((arch & cpu6812)\n \t\t   && addr >= M68HC12_BANK_BASE && addr < 0x0c000)\n \t    {\n-\t      int cur_page;\n+\t      unsigned cur_page;\n \t      bfd_vma vaddr;\n \n \t      if (memaddr >= M68HC12_BANK_VIRT)\n@@ -704,9 +681,8 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \t      else\n \t\tcur_page = 0;\n \n-\t      vaddr = ((addr - M68HC12_BANK_BASE)\n-\t\t       + (cur_page << M68HC12_BANK_SHIFT))\n-\t\t+ M68HC12_BANK_VIRT;\n+\t      vaddr = (addr - M68HC12_BANK_BASE\n+\t\t       + (cur_page << M68HC12_BANK_SHIFT)) + M68HC12_BANK_VIRT;\n \t      if (!info->symbol_at_address_func (addr, info)\n \t\t  && info->symbol_at_address_func (vaddr, info))\n \t\taddr = vaddr;\n@@ -721,14 +697,16 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \t      format &= ~M6811_OP_IND16;\n \t    }\n \n-\t  if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */\n+\t  /* Avoid duplicate 0x from core binutils.  */\n+\t  if (info->symtab_size > 0)\n \t    (*info->fprintf_func) (info->stream, \"0x\");\n \n \t  (*info->print_address_func) (addr, info);\n \t  if (format & M6812_OP_PAGE)\n \t    {\n \t      (* info->fprintf_func) (info->stream, \" {\");\n-\t      if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */\n+\t      /* Avoid duplicate 0x from core binutils.  */\n+\t      if (info->symtab_size > 0)\n \t\t(*info->fprintf_func) (info->stream, \"0x\");\n \t      (* info->print_address_func) (val, info);\n \t      (* info->fprintf_func) (info->stream, \", 0x%x}\", page);\n@@ -750,8 +728,6 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \n       if (format & M6812_OP_IND16_P2)\n \t{\n-\t  int val;\n-\n \t  (*info->fprintf_func) (info->stream, \", \");\n \n \t  status = read_memory (memaddr + pos + offset, &buffer[0], 2, info);\n@@ -760,9 +736,9 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \n \t  pos += 2;\n \n-\t  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));\n-\t  val &= 0x0FFFF;\n-\t  if (info->symtab_size > 0) /* Avoid duplicate 0x from core binutils. */\n+\t  val = (buffer[0] << 8) | buffer[1];\n+\t  /* Avoid duplicate 0x from core binutils.  */\n+\t  if (info->symtab_size > 0)\n \t    (*info->fprintf_func) (info->stream, \"0x\");\n \t  (*info->print_address_func) (val, info);\n \t}\n@@ -784,30 +760,24 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \t}\n       if (format & M6811_OP_JUMP_REL)\n \t{\n-\t  int val;\n-\n \t  status = read_memory (memaddr + pos, &buffer[0], 1, info);\n \t  if (status != 0)\n \t    return status;\n \n \t  (*info->fprintf_func) (info->stream, \"0x\");\n \t  pos++;\n-\t  val = (buffer[0] & 0x80) ? buffer[0] | 0xFFFFFF00 : buffer[0];\n+\t  val = (buffer[0] ^ 0x80) - 0x80;\n \t  (*info->print_address_func) (memaddr + pos + val, info);\n \t  format &= ~M6811_OP_JUMP_REL;\n \t}\n       else if (format & M6812_OP_JUMP_REL16)\n \t{\n-\t  int val;\n-\n \t  status = read_memory (memaddr + pos, &buffer[0], 2, info);\n \t  if (status != 0)\n \t    return status;\n \n \t  pos += 2;\n-\t  val = ((buffer[0] << 8) | (buffer[1] & 0x0FF));\n-\t  if (val & 0x8000)\n-\t    val |= 0xffff0000;\n+\t  val = (((buffer[0] << 8) | buffer[1]) ^ 0x8000) - 0x8000;\n \n \t  (*info->fprintf_func) (info->stream, \"0x\");\n \t  (*info->print_address_func) (memaddr + pos + val, info);\n@@ -816,16 +786,14 @@ print_insn (bfd_vma memaddr, struct disassemble_info* info, int arch)\n \n       if (format & M6812_OP_PAGE)\n \t{\n-\t  int val;\n-\n \t  status = read_memory (memaddr + pos + offset, &buffer[0], 1, info);\n \t  if (status != 0)\n \t    return status;\n \n \t  pos += 1;\n \n-\t  val = buffer[0] & 0x0ff;\n-\t  (*info->fprintf_func) (info->stream, \", 0x%x\", val);\n+\t  val = buffer[0];\n+\t  (*info->fprintf_func) (info->stream, \", 0x%x\", (unsigned) val);\n \t}\n \n #ifdef DEBUG"
    }
  ]
}