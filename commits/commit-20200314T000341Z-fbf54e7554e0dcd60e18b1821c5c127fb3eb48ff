{
  "sha": "fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmJmNTRlNzU1NGUwZGNkNjBlMThiMTgyMWM1YzEyN2ZiM2ViNDhmZg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-13T23:39:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-14T00:03:41Z"
    },
    "message": "Introduce cp_print_value\n\nThis adds cp_print_value, a value-based analogue of cp_print_val, and\nchanges cp_print_value_fields to use it.\n\ngdb/ChangeLog\n2020-03-13  Tom Tromey  <tom@tromey.com>\n\n\t* cp-valprint.c (cp_print_value_fields): Update.\n\t(cp_print_value): New function.",
    "tree": {
      "sha": "c679640d934e2ceeddd09b28200a98ffb5024cb4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c679640d934e2ceeddd09b28200a98ffb5024cb4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "64b653ca7058bfd4f91879dea628809d398b488e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64b653ca7058bfd4f91879dea628809d398b488e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/64b653ca7058bfd4f91879dea628809d398b488e"
    }
  ],
  "stats": {
    "total": 173,
    "additions": 169,
    "deletions": 4
  },
  "files": [
    {
      "sha": "dea6a8d286f497d2a586ff54961bcd5d28854ba7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
      "patch": "@@ -1,3 +1,8 @@\n+2020-03-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* cp-valprint.c (cp_print_value_fields): Update.\n+\t(cp_print_value): New function.\n+\n 2020-03-13  Tom Tromey  <tom@tromey.com>\n \n \t* m2-valprint.c (m2_value_print_inner): Use"
    },
    {
      "sha": "77725b7f3c4117a8ee162fc9b8b293dc3cdbe894",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 164,
      "deletions": 4,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=fbf54e7554e0dcd60e18b1821c5c127fb3eb48ff",
      "patch": "@@ -54,6 +54,10 @@ static void cp_print_value (struct type *, struct type *,\n \t\t\t    const struct value_print_options *,\n \t\t\t    struct type **);\n \n+static void cp_print_value (struct value *, struct ui_file *,\n+\t\t\t    int, const struct value_print_options *,\n+\t\t\t    struct type **);\n+\n \n /* GCC versions after 2.4.5 use this.  */\n const char vtbl_ptr_name[] = \"__vtbl_ptr_type\";\n@@ -412,7 +416,6 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n   static int last_set_recurse = -1;\n \n   struct type *type = check_typedef (value_type (val));\n-  CORE_ADDR address = value_address (val);\n \n   if (recurse == 0)\n     {\n@@ -441,9 +444,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n      duplicates of virtual baseclasses.  */\n \n   if (n_baseclasses > 0)\n-    cp_print_value (type, type, 0, address, stream,\n-\t\t    recurse + 1, val, options,\n-\t\t    dont_print_vb);\n+    cp_print_value (val, stream, recurse + 1, options, dont_print_vb);\n \n   /* Second, print out data fields */\n \n@@ -608,6 +609,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t\t    {\n \t\t      CORE_ADDR addr;\n \n+\t\t      i_offset += value_embedded_offset (val);\n \t\t      addr = extract_typed_address (valaddr + i_offset, i_type);\n \t\t      print_function_pointer_address (opts,\n \t\t\t\t\t\t      get_type_arch (type),\n@@ -881,6 +883,164 @@ cp_print_value (struct type *type, struct type *real_type,\n     }\n }\n \n+/* Special val_print routine to avoid printing multiple copies of\n+   virtual baseclasses.  */\n+\n+static void\n+cp_print_value (struct value *val, struct ui_file *stream,\n+\t\tint recurse, const struct value_print_options *options,\n+\t\tstruct type **dont_print_vb)\n+{\n+  struct type *type = check_typedef (value_type (val));\n+  CORE_ADDR address = value_address (val);\n+  struct type **last_dont_print\n+    = (struct type **) obstack_next_free (&dont_print_vb_obstack);\n+  struct obstack tmp_obstack = dont_print_vb_obstack;\n+  int i, n_baseclasses = TYPE_N_BASECLASSES (type);\n+  const gdb_byte *valaddr = value_contents_for_printing (val);\n+\n+  if (dont_print_vb == 0)\n+    {\n+      /* If we're at top level, carve out a completely fresh chunk of\n+         the obstack and use that until this particular invocation\n+         returns.  */\n+      /* Bump up the high-water mark.  Now alpha is omega.  */\n+      obstack_finish (&dont_print_vb_obstack);\n+    }\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      LONGEST boffset = 0;\n+      int skip = 0;\n+      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n+      const char *basename = TYPE_NAME (baseclass);\n+      struct value *base_val = NULL;\n+\n+      if (BASETYPE_VIA_VIRTUAL (type, i))\n+\t{\n+\t  struct type **first_dont_print\n+\t    = (struct type **) obstack_base (&dont_print_vb_obstack);\n+\n+\t  int j = (struct type **)\n+\t    obstack_next_free (&dont_print_vb_obstack) - first_dont_print;\n+\n+\t  while (--j >= 0)\n+\t    if (baseclass == first_dont_print[j])\n+\t      goto flush_it;\n+\n+\t  obstack_ptr_grow (&dont_print_vb_obstack, baseclass);\n+\t}\n+\n+      try\n+\t{\n+\t  boffset = baseclass_offset (type, i, valaddr,\n+\t\t\t\t      value_embedded_offset (val),\n+\t\t\t\t      address, val);\n+\t}\n+      catch (const gdb_exception_error &ex)\n+\t{\n+\t  if (ex.error == NOT_AVAILABLE_ERROR)\n+\t    skip = -1;\n+\t  else\n+\t    skip = 1;\n+\t}\n+\n+      if (skip == 0)\n+\t{\n+\t  if (BASETYPE_VIA_VIRTUAL (type, i))\n+\t    {\n+\t      /* The virtual base class pointer might have been\n+\t\t clobbered by the user program. Make sure that it\n+\t\t still points to a valid memory location.  */\n+\n+\t      if (boffset < 0 || boffset >= TYPE_LENGTH (type))\n+\t\t{\n+\t\t  gdb::byte_vector buf (TYPE_LENGTH (baseclass));\n+\n+\t\t  if (target_read_memory (address + boffset, buf.data (),\n+\t\t\t\t\t  TYPE_LENGTH (baseclass)) != 0)\n+\t\t    skip = 1;\n+\t\t  base_val = value_from_contents_and_address (baseclass,\n+\t\t\t\t\t\t\t      buf.data (),\n+\t\t\t\t\t\t\t      address + boffset);\n+\t\t  baseclass = value_type (base_val);\n+\t\t  boffset = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  base_val = val;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      base_val = val;\n+\t    }\n+\t}\n+\n+      /* Now do the printing.  */\n+      if (options->prettyformat)\n+\t{\n+\t  fprintf_filtered (stream, \"\\n\");\n+\t  print_spaces_filtered (2 * recurse, stream);\n+\t}\n+      fputs_filtered (\"<\", stream);\n+      /* Not sure what the best notation is in the case where there is\n+         no baseclass name.  */\n+      fputs_filtered (basename ? basename : \"\", stream);\n+      fputs_filtered (\"> = \", stream);\n+\n+      if (skip < 0)\n+\tval_print_unavailable (stream);\n+      else if (skip > 0)\n+\tval_print_invalid_address (stream);\n+      else\n+\t{\n+\t  int result = 0;\n+\n+\t  if (options->max_depth > -1\n+\t      && recurse >= options->max_depth)\n+\t    {\n+\t      const struct language_defn *language = current_language;\n+\t      gdb_assert (language->la_struct_too_deep_ellipsis != NULL);\n+\t      fputs_filtered (language->la_struct_too_deep_ellipsis, stream);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Attempt to run an extension language pretty-printer on the\n+\t\t baseclass if possible.  */\n+\t      if (!options->raw)\n+\t\tresult\n+\t\t  = apply_ext_lang_val_pretty_printer (baseclass, boffset,\n+\t\t\t\t\t\t       value_address (base_val),\n+\t\t\t\t\t\t       stream, recurse,\n+\t\t\t\t\t\t       base_val, options,\n+\t\t\t\t\t\t       current_language);\n+\n+\t      if (!result)\n+\t\tcp_print_value_fields (value_primitive_field (val, 0, i, type),\n+\t\t\t\t       stream, recurse, options,\n+\t\t\t\t       ((struct type **)\n+\t\t\t\t\tobstack_base (&dont_print_vb_obstack)),\n+\t\t\t\t       0);\n+\t    }\n+\t}\n+      fputs_filtered (\", \", stream);\n+\n+    flush_it:\n+      ;\n+    }\n+\n+  if (dont_print_vb == 0)\n+    {\n+      /* Free the space used to deal with the printing\n+         of this type from top level.  */\n+      obstack_free (&dont_print_vb_obstack, last_dont_print);\n+      /* Reset watermark so that we can continue protecting\n+         ourselves from whatever we were protecting ourselves.  */\n+      dont_print_vb_obstack = tmp_obstack;\n+    }\n+}\n+\n /* Print value of a static member.  To avoid infinite recursion when\n    printing a class that contains a static instance of the class, we\n    keep the addresses of all printed static member classes in an"
    }
  ]
}