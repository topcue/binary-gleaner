{
  "sha": "2e6711003b8c69abe25100a7b2630409a4aafb8d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmU2NzExMDAzYjhjNjlhYmUyNTEwMGE3YjI2MzA0MDlhNGFhZmI4ZA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:14:10Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:19:40Z"
    },
    "message": "Pass existing_cu object to cutu_reader\n\nIt is possible, seemingly for a special case described in\nfind_partial_die, for cutu_reader to re-use an existing dwarf2_cu\ninstead of creating a new one.  This happens when running this test, for\nexample:\n\n    make check TESTS=\"gdb.dwarf2/fission-reread.exp\"\n\nRight now the, `use_existing_cu` flag tells cutu_reader to use the\ndwarf2_cu object at dwarf2_per_cu_data::cu.  However, we'll remove that\nfield, so we need to find another solution.\n\nThis situation arises when some caller up the stack has already created\nthe dwarf2_cu to read a dwarf2_per_cu_data, but needs to re-read it with\nsome other parameters.  Therefore, it's possible to just have that\ncaller pass down the dwarf2_cu object to use as a `existing_cu`\nparameter.  If `existing_cu` is NULL, it tells cutu_reader that it needs\nto instantiate a new one.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.c (class cutu_reader) <cutu_reader>: Replace\n\t`int use_existing_cu` parameter with `dwarf2_cu *existing_cu`.\n\t(init_tu_and_read_dwo_dies): Likewise.\n\t(cutu_reader::init_tu_and_read_dwo_dies): Likewise.\n\t(cutu_reader::cutu_reader): Likewise.\n\t(load_partial_comp_unit): Likewise.\n\t(process_psymtab_comp_unit): Update.\n\t(build_type_psymtabs_1): Update.\n\t(process_skeletonless_type_unit): Update.\n\t(load_full_comp_unit): Update.\n\t(find_partial_die): Update.\n\t(dwarf2_read_addr_index): Update.\n\t(read_signatured_type): Update.\n\nChange-Id: Id03e3bc3de3cf99d9e4b4080ad83b029c93bf434",
    "tree": {
      "sha": "619f634263b22ec32a32a8d628360c835e364e88",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/619f634263b22ec32a32a8d628360c835e364e88"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2e6711003b8c69abe25100a7b2630409a4aafb8d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e6711003b8c69abe25100a7b2630409a4aafb8d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2e6711003b8c69abe25100a7b2630409a4aafb8d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e6711003b8c69abe25100a7b2630409a4aafb8d/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2e6a9f7959dca5af9a7e6e5cea8c5dccd2e510f0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e6a9f7959dca5af9a7e6e5cea8c5dccd2e510f0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2e6a9f7959dca5af9a7e6e5cea8c5dccd2e510f0"
    }
  ],
  "stats": {
    "total": 73,
    "additions": 48,
    "deletions": 25
  },
  "files": [
    {
      "sha": "9a281943bca7d98d162a6cc9db7e316e530c75a0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e6711003b8c69abe25100a7b2630409a4aafb8d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e6711003b8c69abe25100a7b2630409a4aafb8d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2e6711003b8c69abe25100a7b2630409a4aafb8d",
      "patch": "@@ -1,3 +1,19 @@\n+2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/read.c (class cutu_reader) <cutu_reader>: Replace\n+\t`int use_existing_cu` parameter with `dwarf2_cu *existing_cu`.\n+\t(init_tu_and_read_dwo_dies): Likewise.\n+\t(cutu_reader::init_tu_and_read_dwo_dies): Likewise.\n+\t(cutu_reader::cutu_reader): Likewise.\n+\t(load_partial_comp_unit): Likewise.\n+\t(process_psymtab_comp_unit): Update.\n+\t(build_type_psymtabs_1): Update.\n+\t(process_skeletonless_type_unit): Update.\n+\t(load_full_comp_unit): Update.\n+\t(find_partial_die): Update.\n+\t(dwarf2_read_addr_index): Update.\n+\t(read_signatured_type): Update.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.h (struct dwarf2_per_cu_data) <m_header,"
    },
    {
      "sha": "c2dc34477f7794e98e4fec4f8b931658ed6f1aea",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 32,
      "deletions": 25,
      "changes": 57,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2e6711003b8c69abe25100a7b2630409a4aafb8d/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2e6711003b8c69abe25100a7b2630409a4aafb8d/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=2e6711003b8c69abe25100a7b2630409a4aafb8d",
      "patch": "@@ -912,7 +912,7 @@ class cutu_reader : public die_reader_specs\n   cutu_reader (dwarf2_per_cu_data *this_cu,\n \t       dwarf2_per_objfile *per_objfile,\n \t       struct abbrev_table *abbrev_table,\n-\t       int use_existing_cu,\n+\t       dwarf2_cu *existing_cu,\n \t       bool skip_partial);\n \n   explicit cutu_reader (struct dwarf2_per_cu_data *this_cu,\n@@ -933,7 +933,7 @@ class cutu_reader : public die_reader_specs\n private:\n   void init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n \t\t\t\t  dwarf2_per_objfile *per_objfile,\n-\t\t\t\t  int use_existing_cu);\n+\t\t\t\t  dwarf2_cu *existing_cu);\n \n   struct dwarf2_per_cu_data *m_this_cu;\n   std::unique_ptr<dwarf2_cu> m_new_cu;\n@@ -6902,7 +6902,7 @@ lookup_dwo_unit (dwarf2_cu *cu, die_info *comp_unit_die, const char *dwo_name)\n void\n cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n \t\t\t\t\tdwarf2_per_objfile *per_objfile,\n-\t\t\t\t\tint use_existing_cu)\n+\t\t\t\t\tdwarf2_cu *existing_cu)\n {\n   struct signatured_type *sig_type;\n \n@@ -6912,24 +6912,28 @@ cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n   sig_type = (struct signatured_type *) this_cu;\n   gdb_assert (sig_type->dwo_unit != NULL);\n \n-  if (use_existing_cu && this_cu->cu != NULL)\n+  dwarf2_cu *cu;\n+\n+  if (existing_cu != nullptr)\n     {\n-      gdb_assert (this_cu->cu->dwo_unit == sig_type->dwo_unit);\n+      cu = existing_cu;\n+      gdb_assert (cu->dwo_unit == sig_type->dwo_unit);\n       /* There's no need to do the rereading_dwo_cu handling that\n \t cutu_reader does since we don't read the stub.  */\n     }\n   else\n     {\n-      /* If !use_existing_cu, this_cu->cu must be NULL.  */\n+      /* If an existing_cu is provided, this_cu->cu must be NULL.  */\n       gdb_assert (this_cu->cu == NULL);\n       m_new_cu.reset (new dwarf2_cu (this_cu, per_objfile));\n+      cu = m_new_cu.get ();\n     }\n \n   /* A future optimization, if needed, would be to use an existing\n      abbrev table.  When reading DWOs with skeletonless TUs, all the TUs\n      could share abbrev tables.  */\n \n-  if (read_cutu_die_from_dwo (this_cu->cu, sig_type->dwo_unit,\n+  if (read_cutu_die_from_dwo (cu, sig_type->dwo_unit,\n \t\t\t      NULL /* stub_comp_unit_die */,\n \t\t\t      sig_type->dwo_unit->dwo_file->comp_dir,\n \t\t\t      this, &info_ptr,\n@@ -6948,21 +6952,20 @@ cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n    Otherwise the table specified in the comp unit header is read in and used.\n    This is an optimization for when we already have the abbrev table.\n \n-   If USE_EXISTING_CU is non-zero, and THIS_CU->cu is non-NULL, then use it.\n-   Otherwise, a new CU is allocated with xmalloc.  */\n+   If EXISTING_CU is non-NULL, then use it.  Otherwise, a new CU is\n+   allocated.  */\n \n cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n \t\t\t  dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t  struct abbrev_table *abbrev_table,\n-\t\t\t  int use_existing_cu,\n+\t\t\t  dwarf2_cu *existing_cu,\n \t\t\t  bool skip_partial)\n   : die_reader_specs {},\n     m_this_cu (this_cu)\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n   bfd *abfd = section->get_bfd_owner ();\n-  struct dwarf2_cu *cu;\n   const gdb_byte *begin_info_ptr;\n   struct signatured_type *sig_type = NULL;\n   struct dwarf2_section_info *abbrev_section;\n@@ -6983,7 +6986,7 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n       /* Narrow down the scope of possibilities to have to understand.  */\n       gdb_assert (this_cu->is_debug_types);\n       gdb_assert (abbrev_table == NULL);\n-      init_tu_and_read_dwo_dies (this_cu, dwarf2_per_objfile, use_existing_cu);\n+      init_tu_and_read_dwo_dies (this_cu, dwarf2_per_objfile, existing_cu);\n       return;\n     }\n \n@@ -6994,9 +6997,11 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n \n   abbrev_section = get_abbrev_section_for_cu (this_cu);\n \n-  if (use_existing_cu && this_cu->cu != NULL)\n+  dwarf2_cu *cu;\n+\n+  if (existing_cu != nullptr)\n     {\n-      cu = this_cu->cu;\n+      cu = existing_cu;\n       /* If this CU is from a DWO file we need to start over, we need to\n \t refetch the attributes from the skeleton CU.\n \t This could be optimized by retrieving those attributes from when we\n@@ -7008,7 +7013,7 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n     }\n   else\n     {\n-      /* If !use_existing_cu, this_cu->cu must be NULL.  */\n+      /* If an existing_cu is provided, this_cu->cu must be NULL.  */\n       gdb_assert (this_cu->cu == NULL);\n       m_new_cu.reset (new dwarf2_cu (this_cu, dwarf2_per_objfile));\n       cu = m_new_cu.get ();\n@@ -7561,7 +7566,7 @@ process_psymtab_comp_unit (dwarf2_per_cu_data *this_cu,\n   if (this_cu->cu != NULL)\n     free_one_cached_comp_unit (this_cu, per_objfile);\n \n-  cutu_reader reader (this_cu, per_objfile, NULL, 0, false);\n+  cutu_reader reader (this_cu, per_objfile, nullptr, nullptr, false);\n \n   switch (reader.comp_unit_die->tag)\n     {\n@@ -7743,7 +7748,7 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t}\n \n       cutu_reader reader (&tu.sig_type->per_cu, dwarf2_per_objfile,\n-\t\t\t  abbrev_table.get (), 0, false);\n+\t\t\t  abbrev_table.get (), nullptr, false);\n       if (!reader.dummy_p)\n \tbuild_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\t    reader.comp_unit_die);\n@@ -7848,7 +7853,8 @@ process_skeletonless_type_unit (void **slot, void *info)\n   *slot = entry;\n \n   /* This does the job that build_type_psymtabs_1 would have done.  */\n-  cutu_reader reader (&entry->per_cu, dwarf2_per_objfile, NULL, 0, false);\n+  cutu_reader reader (&entry->per_cu, dwarf2_per_objfile, nullptr, nullptr,\n+\t\t      false);\n   if (!reader.dummy_p)\n     build_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\treader.comp_unit_die);\n@@ -7984,9 +7990,10 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n static void\n load_partial_comp_unit (dwarf2_per_cu_data *this_cu,\n-\t\t\tdwarf2_per_objfile *per_objfile)\n+\t\t\tdwarf2_per_objfile *per_objfile,\n+\t\t\tdwarf2_cu *existing_cu)\n {\n-  cutu_reader reader (this_cu, per_objfile, NULL, 1, false);\n+  cutu_reader reader (this_cu, per_objfile, nullptr, existing_cu, false);\n \n   if (!reader.dummy_p)\n     {\n@@ -9105,7 +9112,7 @@ load_full_comp_unit (dwarf2_per_cu_data *this_cu,\n {\n   gdb_assert (! this_cu->is_debug_types);\n \n-  cutu_reader reader (this_cu, per_objfile, NULL, 1, skip_partial);\n+  cutu_reader reader (this_cu, per_objfile, NULL, this_cu->cu, skip_partial);\n   if (reader.dummy_p)\n     return;\n \n@@ -18713,7 +18720,7 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \t\t\t\t\t\t dwarf2_per_objfile);\n \n       if (per_cu->cu == NULL || per_cu->cu->partial_dies == NULL)\n-\tload_partial_comp_unit (per_cu, cu->per_objfile);\n+\tload_partial_comp_unit (per_cu, cu->per_objfile, nullptr);\n \n       per_cu->cu->last_used = 0;\n       pd = per_cu->cu->find_partial_die (sect_off);\n@@ -18732,7 +18739,7 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \t DIEs alone (which can still be in use, e.g. in scan_partial_symbols),\n \t and clobber THIS_CU->cu->partial_dies with the hash table for the new\n \t set.  */\n-      load_partial_comp_unit (per_cu, cu->per_objfile);\n+      load_partial_comp_unit (per_cu, cu->per_objfile, cu);\n \n       pd = per_cu->cu->find_partial_die (sect_off);\n     }\n@@ -19449,7 +19456,7 @@ dwarf2_read_addr_index (dwarf2_per_cu_data *per_cu,\n     }\n   else\n     {\n-      cutu_reader reader (per_cu, dwarf2_per_objfile, NULL, 0, false);\n+      cutu_reader reader (per_cu, dwarf2_per_objfile, nullptr, nullptr, false);\n       addr_base = reader.cu->addr_base;\n       addr_size = reader.cu->header.addr_size;\n     }\n@@ -22831,7 +22838,7 @@ read_signatured_type (signatured_type *sig_type,\n   gdb_assert (per_cu->is_debug_types);\n   gdb_assert (per_cu->cu == NULL);\n \n-  cutu_reader reader (per_cu, per_objfile, NULL, 0, false);\n+  cutu_reader reader (per_cu, per_objfile, nullptr, nullptr, false);\n \n   if (!reader.dummy_p)\n     {"
    }
  ]
}