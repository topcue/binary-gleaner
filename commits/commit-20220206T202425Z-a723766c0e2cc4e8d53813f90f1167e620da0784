{
  "sha": "a723766c0e2cc4e8d53813f90f1167e620da0784",
  "node_id": "C_kwDOANOeidoAKGE3MjM3NjZjMGUyY2M0ZThkNTM4MTNmOTBmMTE2N2U2MjBkYTA3ODQ",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-26T22:39:03Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-02-06T20:24:25Z"
    },
    "message": "Allow non-ASCII characters in Rust identifiers\n\nRust 1.53 (quite a while ago now) ungated the support for non-ASCII\nidentifiers.  This didn't work in gdb.  This is PR rust/20166.\n\nThis patch fixes the problem by allowing non-ASCII characters to be\nconsidered as identifier components.  It seemed simplest to just pass\nthem through -- doing any extra checking didn't seem worthwhile.\n\nThe new test also verifies that such characters are allowed in strings\nand character literals as well.  The latter also required a bit of\nwork in the lexer.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=20166",
    "tree": {
      "sha": "df2381918760793f58aff764dd8612de819d6b3c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/df2381918760793f58aff764dd8612de819d6b3c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a723766c0e2cc4e8d53813f90f1167e620da0784",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a723766c0e2cc4e8d53813f90f1167e620da0784",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a723766c0e2cc4e8d53813f90f1167e620da0784",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a723766c0e2cc4e8d53813f90f1167e620da0784/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c1f5e54825e4ac2d64b267578fd87409e0ea901c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1f5e54825e4ac2d64b267578fd87409e0ea901c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c1f5e54825e4ac2d64b267578fd87409e0ea901c"
    }
  ],
  "stats": {
    "total": 147,
    "additions": 129,
    "deletions": 18
  },
  "files": [
    {
      "sha": "8be7d33cfe98a27a2049da37ac9424dc52b7e4ca",
      "filename": "gdb/rust-parse.c",
      "status": "modified",
      "additions": 52,
      "deletions": 18,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/rust-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/rust-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-parse.c?ref=a723766c0e2cc4e8d53813f90f1167e620da0784",
      "patch": "@@ -33,6 +33,12 @@\n \n using namespace expr;\n \n+#if WORDS_BIGENDIAN\n+#define UTF32 \"UTF-32BE\"\n+#else\n+#define UTF32 \"UTF-32LE\"\n+#endif\n+\n /* A regular expression for matching Rust numbers.  This is split up\n    since it is very long and this gives us a way to comment the\n    sections.  */\n@@ -577,6 +583,35 @@ rust_parser::lex_escape (int is_byte)\n   return result;\n }\n \n+/* A helper for lex_character.  Search forward for the closing single\n+   quote, then convert the bytes from the host charset to UTF-32.  */\n+\n+static uint32_t\n+lex_multibyte_char (const char *text, int *len)\n+{\n+  /* Only look a maximum of 5 bytes for the closing quote.  This is\n+     the maximum for UTF-8.  */\n+  int quote;\n+  gdb_assert (text[0] != '\\'');\n+  for (quote = 1; text[quote] != '\\0' && text[quote] != '\\''; ++quote)\n+    ;\n+  *len = quote;\n+  /* The caller will issue an error.  */\n+  if (text[quote] == '\\0')\n+    return 0;\n+\n+  auto_obstack result;\n+  convert_between_encodings (host_charset (), UTF32, (const gdb_byte *) text,\n+\t\t\t     quote, 1, &result, translit_none);\n+\n+  int size = obstack_object_size (&result);\n+  if (size > 4)\n+    error (_(\"overlong character literal\"));\n+  uint32_t value;\n+  memcpy (&value, obstack_finish (&result), size);\n+  return value;\n+}\n+\n /* Lex a character constant.  */\n \n int\n@@ -592,13 +627,15 @@ rust_parser::lex_character ()\n     }\n   gdb_assert (pstate->lexptr[0] == '\\'');\n   ++pstate->lexptr;\n-  /* This should handle UTF-8 here.  */\n-  if (pstate->lexptr[0] == '\\\\')\n+  if (pstate->lexptr[0] == '\\'')\n+    error (_(\"empty character literal\"));\n+  else if (pstate->lexptr[0] == '\\\\')\n     value = lex_escape (is_byte);\n   else\n     {\n-      value = pstate->lexptr[0] & 0xff;\n-      ++pstate->lexptr;\n+      int len;\n+      value = lex_multibyte_char (&pstate->lexptr[0], &len);\n+      pstate->lexptr += len;\n     }\n \n   if (pstate->lexptr[0] != '\\'')\n@@ -695,16 +732,9 @@ rust_parser::lex_string ()\n \t  if (is_byte)\n \t    obstack_1grow (&obstack, value);\n \t  else\n-\t    {\n-#if WORDS_BIGENDIAN\n-#define UTF32 \"UTF-32BE\"\n-#else\n-#define UTF32 \"UTF-32LE\"\n-#endif\n-\t      convert_between_encodings (UTF32, \"UTF-8\", (gdb_byte *) &value,\n-\t\t\t\t\t sizeof (value), sizeof (value),\n-\t\t\t\t\t &obstack, translit_none);\n-\t    }\n+\t    convert_between_encodings (UTF32, \"UTF-8\", (gdb_byte *) &value,\n+\t\t\t\t       sizeof (value), sizeof (value),\n+\t\t\t\t       &obstack, translit_none);\n \t}\n       else if (pstate->lexptr[0] == '\\0')\n \terror (_(\"Unexpected EOF in string\"));\n@@ -746,7 +776,10 @@ rust_identifier_start_p (char c)\n   return ((c >= 'a' && c <= 'z')\n \t  || (c >= 'A' && c <= 'Z')\n \t  || c == '_'\n-\t  || c == '$');\n+\t  || c == '$'\n+\t  /* Allow any non-ASCII character as an identifier.  There\n+\t     doesn't seem to be a need to be picky about this.  */\n+\t  || (c & 0x80) != 0);\n }\n \n /* Lex an identifier.  */\n@@ -772,13 +805,14 @@ rust_parser::lex_identifier ()\n \n   ++pstate->lexptr;\n \n-  /* For the time being this doesn't handle Unicode rules.  Non-ASCII\n-     identifiers are gated anyway.  */\n+  /* Allow any non-ASCII character here.  This \"handles\" UTF-8 by\n+     passing it through.  */\n   while ((pstate->lexptr[0] >= 'a' && pstate->lexptr[0] <= 'z')\n \t || (pstate->lexptr[0] >= 'A' && pstate->lexptr[0] <= 'Z')\n \t || pstate->lexptr[0] == '_'\n \t || (is_gdb_var && pstate->lexptr[0] == '$')\n-\t || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9'))\n+\t || (pstate->lexptr[0] >= '0' && pstate->lexptr[0] <= '9')\n+\t || (pstate->lexptr[0] & 0x80) != 0)\n     ++pstate->lexptr;\n \n "
    },
    {
      "sha": "9de0a0e724f6db9d9af4df255fae842d301af6c7",
      "filename": "gdb/testsuite/gdb.rust/unicode.exp",
      "status": "added",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/testsuite/gdb.rust/unicode.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/testsuite/gdb.rust/unicode.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.rust/unicode.exp?ref=a723766c0e2cc4e8d53813f90f1167e620da0784",
      "patch": "@@ -0,0 +1,51 @@\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test raw identifiers.\n+\n+load_lib rust-support.exp\n+if {[skip_rust_tests]} {\n+    continue\n+}\n+\n+# Non-ASCII identifiers were allowed starting in 1.53.\n+set v [split [rust_compiler_version] .]\n+if {[lindex $v 0] == 1 && [lindex $v 1] < 53} {\n+    untested \"this test requires rust 1.53 or greater\"\n+    return -1\n+}\n+\n+# Enable basic use of UTF-8.  LC_ALL gets reset for each testfile.\n+setenv LC_ALL C.UTF-8\n+\n+standard_testfile .rs\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug rust}]} {\n+    return -1\n+}\n+\n+set line [gdb_get_line_number \"set breakpoint here\"]\n+if {![runto ${srcfile}:$line]} {\n+    untested \"could not run to breakpoint\"\n+    return -1\n+}\n+\n+gdb_test \"print \ud835\udd6f\" \" = 98\" \"print D\"\n+gdb_test \"print \\\"\ud835\udd6f\\\"\" \" = \\\"\ud835\udd6f\\\"\" \"print D in string\"\n+# This output is maybe not ideal, but it also isn't incorrect.\n+gdb_test \"print '\ud835\udd6f'\" \" = 120175 '\\\\\\\\u\\\\\\{01d56f\\\\\\}'\" \\\n+    \"print D as char\"\n+gdb_test \"print c\u00e7\" \" = 97\" \"print cc\"\n+\n+gdb_test \"print '\u00e7c'\" \"overlong character literal\" \"print cc as char\""
    },
    {
      "sha": "c6ca90e6450a7efe13a044976dc5f904d5609adb",
      "filename": "gdb/testsuite/gdb.rust/unicode.rs",
      "status": "added",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/testsuite/gdb.rust/unicode.rs",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a723766c0e2cc4e8d53813f90f1167e620da0784/gdb/testsuite/gdb.rust/unicode.rs",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.rust/unicode.rs?ref=a723766c0e2cc4e8d53813f90f1167e620da0784",
      "patch": "@@ -0,0 +1,26 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+\n+// This program is free software; you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation; either version 3 of the License, or\n+// (at your option) any later version.\n+//\n+// This program is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(unused_assignments)]\n+#![allow(uncommon_codepoints)]\n+#![allow(non_snake_case)]\n+\n+fn main() {\n+    let \ud835\udd6f = 98;\n+    let c\u00e7 = 97;\n+    println!(\"{}, {}\", \ud835\udd6f, c\u00e7);        // set breakpoint here\n+}"
    }
  ]
}