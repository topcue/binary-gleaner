{
  "sha": "7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2U5NGNmNmNiMDE4ZGY3Y2MxMzExYWZiMmIxNWU5ZjY5YWRiNjBkOQ==",
  "commit": {
    "author": {
      "name": "Stafford Horne",
      "email": "shorne@gmail.com",
      "date": "2020-05-19T13:26:33Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-05-19T13:26:33Z"
    },
    "message": "OpenRISC BFD fixups for Glibc:\n\n  or1k: Fix static linking when with .rela.got relocations\n  or1k: Fix dynamic TLS symbol flag\n  or1k: Add TLS mask to handle multiple model access\n  or1k: Fix issue with multiple PCREL relocations\n  or1k: TLS offset to use tcb size and section alignment\n  or1k: refactor: Rename p to sec_relocs\n  or1k: refactor: Rename s to sgot and splt\n  or1k: Add dynamic flag to tpoff\n\nbfd\t* elf32-or1k.c (or1k_elf_finish_dynamic_symbol): Rename srela\n\tto relgot.\n\t(or1k_elf_relocate_section): Access srelgot via\n\thtab->root.srelgot.  Add assertions for srelgot->contents.\n\tIntroduce local variable for srelgot to not reuse global\n\tsreloc.\n\t(or1k_elf_relocate_section): Fixup dynamic symbol detection.\n\t(or1k_set_got_and_rela_sizes): New function.\n\t(or1k_initial_exec_offset): New function.\n\t(TLS_GD, TLS_IE, TLS_LD, TLS_LE): Redefine macros as masks.\n\t(or1k_elf_relocate_section): Allow for TLS to handle multiple\n\tmodel access.\n\t(or1k_elf_check_relocs): Use OR to set TLS access.\n\t(allocate_dynrelocs): Use or1k_set_got_and_rela_sizes to set\n\tsizes.\n\t(or1k_elf_size_dynamic_sections): Use\n\tor1k_set_got_and_rela_sizes to set sizes.\n\t(or1k_elf_relocate_section): Fixup PCREL relocation calculation.\n\t(TCB_SIZE): New macro.\n\t(tpoff): Use TCB_SIZE and alignment to calculate offset.\n\t(allocate_dynrelocs, readonly_dynrelocs, or1k_elf_check_relocs)\n\t(or1k_elf_size_dynamic_sections): Rename p to sec_relocs.\n\t(allocate_dynrelocs): Rename s to splt or sgot based on usage.\n\t(tpoff): Add dynamic boolean argument.\n\t(or1k_elf_relocate_section): Pass dynamic flag to tpoff.",
    "tree": {
      "sha": "45ef687eb128b7471be1fa5fcf50753f21bbc864",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/45ef687eb128b7471be1fa5fcf50753f21bbc864"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9/comments",
  "author": {
    "login": "stffrdhrn",
    "id": 2404255,
    "node_id": "MDQ6VXNlcjI0MDQyNTU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2404255?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/stffrdhrn",
    "html_url": "https://github.com/stffrdhrn",
    "followers_url": "https://api.github.com/users/stffrdhrn/followers",
    "following_url": "https://api.github.com/users/stffrdhrn/following{/other_user}",
    "gists_url": "https://api.github.com/users/stffrdhrn/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/stffrdhrn/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/stffrdhrn/subscriptions",
    "organizations_url": "https://api.github.com/users/stffrdhrn/orgs",
    "repos_url": "https://api.github.com/users/stffrdhrn/repos",
    "events_url": "https://api.github.com/users/stffrdhrn/events{/privacy}",
    "received_events_url": "https://api.github.com/users/stffrdhrn/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "164446e04c89c7f5d8fd3efd7874a1af01035d72",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/164446e04c89c7f5d8fd3efd7874a1af01035d72",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/164446e04c89c7f5d8fd3efd7874a1af01035d72"
    }
  ],
  "stats": {
    "total": 396,
    "additions": 264,
    "deletions": 132
  },
  "files": [
    {
      "sha": "7ec1ce3e86316ab8c0549c506eaa392cf41cdfc1",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
      "patch": "@@ -1,3 +1,31 @@\n+2020-05-19  Stafford Horne  <shorne@gmail.com>\n+\n+\t* elf32-or1k.c (or1k_elf_finish_dynamic_symbol): Rename srela\n+\tto relgot.\n+\t(or1k_elf_relocate_section): Access srelgot via\n+\thtab->root.srelgot.  Add assertions for srelgot->contents.\n+\tIntroduce local variable for srelgot to not reuse global\n+\tsreloc.\n+\t(or1k_elf_relocate_section): Fixup dynamic symbol detection.\n+\t(or1k_set_got_and_rela_sizes): New function.\n+\t(or1k_initial_exec_offset): New function.\n+\t(TLS_GD, TLS_IE, TLS_LD, TLS_LE): Redefine macros as masks.\n+\t(or1k_elf_relocate_section): Allow for TLS to handle multiple\n+\tmodel access.\n+\t(or1k_elf_check_relocs): Use OR to set TLS access.\n+\t(allocate_dynrelocs): Use or1k_set_got_and_rela_sizes to set\n+\tsizes.\n+\t(or1k_elf_size_dynamic_sections): Use\n+\tor1k_set_got_and_rela_sizes to set sizes.\n+\t(or1k_elf_relocate_section): Fixup PCREL relocation calculation.\n+\t(TCB_SIZE): New macro.\n+\t(tpoff): Use TCB_SIZE and alignment to calculate offset.\n+\t(allocate_dynrelocs, readonly_dynrelocs, or1k_elf_check_relocs)\n+\t(or1k_elf_size_dynamic_sections): Rename p to sec_relocs.\n+\t(allocate_dynrelocs): Rename s to splt or sgot based on usage.\n+\t(tpoff): Add dynamic boolean argument.\n+\t(or1k_elf_relocate_section): Pass dynamic flag to tpoff.\n+\n 2020-05-19  Siddhesh Poyarekar  <siddesh.poyarekar@arm.com>\n \n \t* elfnn-aarch64.c (elfNN_aarch64_final_link_relocate): Club"
    },
    {
      "sha": "a7fe0a9c7c55414a1bcb213e0a953b5982d7f0c8",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 236,
      "deletions": 132,
      "changes": 368,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e94cf6cb018df7cc1311afb2b15e9f69adb60d9/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=7e94cf6cb018df7cc1311afb2b15e9f69adb60d9",
      "patch": "@@ -873,12 +873,19 @@ static const struct or1k_reloc_map or1k_reloc_map[] =\n   { BFD_RELOC_OR1K_PLTA26,\tR_OR1K_PLTA26 },\n };\n \n+/* tls_type is a mask used to track how each symbol is accessed,\n+   it may be accessed via multiple types of TLS access methods.\n+   We track this for sizing (allocating got + relocation section space) and\n+   for how to process relocations.  */\n #define TLS_UNKNOWN    0\n #define TLS_NONE       1\n #define TLS_GD\t       2\n-#define TLS_LD\t       3\n-#define TLS_IE\t       4\n-#define TLS_LE\t       5\n+#define TLS_LD\t       4\n+#define TLS_IE\t       8\n+#define TLS_LE\t      16\n+\n+/* The size of the TLS thread control block, used to offset LE access.  */\n+#define TCB_SIZE      16\n \n /* ELF linker hash entry.  */\n struct elf_or1k_link_hash_entry\n@@ -1043,19 +1050,49 @@ or1k_info_to_howto_rela (bfd * abfd,\n   return TRUE;\n }\n \n-\n /* Return the relocation value for @tpoff relocations..  */\n static bfd_vma\n-tpoff (struct bfd_link_info *info, bfd_vma address)\n+tpoff (struct bfd_link_info *info, bfd_vma address, bfd_boolean dynamic)\n {\n+  struct elf_link_hash_table *htab = elf_hash_table (info);\n+  bfd_vma base;\n+\n   /* If tls_sec is NULL, we should have signalled an error already.  */\n-  if (elf_hash_table (info)->tls_sec == NULL)\n+  if (htab->tls_sec == NULL)\n     return 0;\n \n-  /* The thread pointer on or1k stores the address after the TCB where\n-     the data is, just compute the difference. No need to compensate\n-     for the size of TCB.  */\n-  return (address - elf_hash_table (info)->tls_sec->vma);\n+  if (dynamic)\n+    return address - htab->tls_sec->vma;\n+  else\n+    {\n+      /* On or1k, the tp points to just after the tcb, if we have an alignment\n+\t greater than the tcb size we need to offset by the alignment difference.  */\n+      base = align_power ((bfd_vma) TCB_SIZE, htab->tls_sec->alignment_power)\n+\t     - TCB_SIZE;\n+\n+      /* The thread pointer on or1k stores the address after the TCB where\n+\t the data is, just compute the difference. No need to compensate\n+\t for the size of TCB.  */\n+      return address - htab->tls_sec->vma + base;\n+    }\n+}\n+\n+/* If we have both IE and GD accesses to a symbol the IE relocations should be\n+   offset by 8 bytes because the got contains both GD and IE entries.  */\n+static bfd_vma\n+or1k_initial_exec_offset (reloc_howto_type *howto, unsigned char tls_type_mask)\n+{\n+   switch (howto->type)\n+     {\n+     case R_OR1K_TLS_IE_HI16:\n+     case R_OR1K_TLS_IE_LO16:\n+     case R_OR1K_TLS_IE_PG21:\n+     case R_OR1K_TLS_IE_LO13:\n+     case R_OR1K_TLS_IE_AHI16:\n+       return (tls_type_mask & TLS_GD) != 0 ? 8 : 0;\n+     default:\n+       return 0;\n+     }\n }\n \n /* Like _bfd_final_link_relocate, but handles non-contiguous fields.  */\n@@ -1226,7 +1263,6 @@ or1k_elf_relocate_section (bfd *output_bfd,\n   Elf_Internal_Rela *rel;\n   Elf_Internal_Rela *relend;\n   struct elf_or1k_link_hash_table *htab = or1k_elf_hash_table (info);\n-  bfd *dynobj;\n   asection *sreloc;\n   bfd_vma *local_got_offsets;\n   asection *sgot, *splt;\n@@ -1236,7 +1272,6 @@ or1k_elf_relocate_section (bfd *output_bfd,\n   if (htab == NULL)\n     return FALSE;\n \n-  dynobj = htab->root.dynobj;\n   local_got_offsets = elf_local_got_offsets (input_bfd);\n \n   sreloc = elf_section_data (input_section)->sreloc;\n@@ -1254,7 +1289,7 @@ or1k_elf_relocate_section (bfd *output_bfd,\n       got_sym_value = (hgot->root.u.def.value\n \t\t       + hgot->root.u.def.section->output_section->vma\n \t\t       + hgot->root.u.def.section->output_offset);\n-    got_base = sgot->output_section->vma + sgot->output_offset;\n+      got_base = sgot->output_section->vma + sgot->output_offset;\n     }\n \n   symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;\n@@ -1416,16 +1451,16 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \n \t\t      /* We need to generate a R_OR1K_RELATIVE reloc\n \t\t\t for the dynamic linker.  */\n-\t\t\tsrelgot = bfd_get_section_by_name (dynobj, \".rela.got\");\n+\t\t      srelgot = htab->root.srelgot;\n \t\t      BFD_ASSERT (srelgot != NULL);\n \n \t\t      outrel.r_offset = got_base + off;\n \t\t      outrel.r_info = ELF32_R_INFO (0, R_OR1K_RELATIVE);\n \t\t      outrel.r_addend = relocation;\n \t\t      loc = srelgot->contents;\n-\t\t\tloc += (srelgot->reloc_count\n-\t\t\t\t* sizeof (Elf32_External_Rela));\n-\t\t      bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);\n+\t\t      loc += (srelgot->reloc_count\n+\t\t\t      * sizeof (Elf32_External_Rela));\n+\t\t      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);\n \t\t      ++srelgot->reloc_count;\n \t\t    }\n \t\t  local_got_offsets[r_symndx] |= 1;\n@@ -1591,54 +1626,80 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \t  {\n \t    bfd_vma gotoff;\n \t    Elf_Internal_Rela rela;\n+\t    asection *srelgot;\n \t    bfd_byte *loc;\n-\t    int dynamic;\n+\t    bfd_boolean dynamic;\n+\t    int indx = 0;\n+\t    unsigned char tls_type;\n \n-\t    sreloc = bfd_get_section_by_name (dynobj, \".rela.got\");\n+\t    srelgot = htab->root.srelgot;\n \n \t    /* Mark as TLS related GOT entry by setting\n-\t       bit 2 as well as bit 1.  */\n+\t       bit 2 to indcate TLS and bit 1 to indicate GOT.  */\n \t    if (h != NULL)\n \t      {\n \t\tgotoff = h->got.offset;\n+\t\ttls_type = ((struct elf_or1k_link_hash_entry *) h)->tls_type;\n \t\th->got.offset |= 3;\n \t      }\n \t    else\n \t      {\n+\t\tunsigned char *local_tls_type;\n+\n \t\tgotoff = local_got_offsets[r_symndx];\n+\t\tlocal_tls_type = (unsigned char *) elf_or1k_local_tls_type (input_bfd);\n+\t\ttls_type = local_tls_type == NULL ? TLS_NONE\n+\t\t\t\t\t\t  : local_tls_type[r_symndx];\n \t\tlocal_got_offsets[r_symndx] |= 3;\n \t      }\n \n \t    /* Only process the relocation once.  */\n-\t    if (gotoff & 1)\n+\t    if ((gotoff & 1) != 0)\n \t      {\n-\t\trelocation = sgot->output_offset + (gotoff  & ~3);\n+\t\tgotoff += or1k_initial_exec_offset (howto, tls_type);\n+\n+\t\t/* The PG21 and LO13 relocs are pc-relative, while the\n+\t\t   rest are GOT relative.  */\n+\t\trelocation = got_base + (gotoff & ~3);\n+\t\tif (!(r_type == R_OR1K_TLS_GD_PG21\n+\t\t    || r_type == R_OR1K_TLS_GD_LO13\n+\t\t    || r_type == R_OR1K_TLS_IE_PG21\n+\t\t    || r_type == R_OR1K_TLS_IE_LO13))\n+\t\t  relocation -= got_sym_value;\n \t\tbreak;\n \t      }\n \n \t    BFD_ASSERT (elf_hash_table (info)->hgot == NULL\n \t\t\t|| elf_hash_table (info)->hgot->root.u.def.value == 0);\n \n-\t    /* Dynamic entries will require relocations. if we do not need\n+\t    if (h != NULL)\n+\t      {\n+\t\tbfd_boolean dyn = htab->root.dynamic_sections_created;\n+\t\tbfd_boolean pic = bfd_link_pic (info);\n+\n+\t\tif (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, pic, h)\n+\t\t    && (!pic || !SYMBOL_REFERENCES_LOCAL (info, h)))\n+\t\t  indx = h->dynindx;\n+\t      }\n+\n+\t    /* Dynamic entries will require relocations.  If we do not need\n \t       them we will just use the default R_OR1K_NONE and\n \t       not set anything.  */\n-\t    dynamic = bfd_link_pic (info)\n-\t      || (sec && (sec->flags & SEC_ALLOC) != 0\n-\t\t  && h != NULL\n-\t\t  && (h->root.type == bfd_link_hash_defweak || !h->def_regular));\n+\t    dynamic = (bfd_link_pic (info) || indx != 0)\n+\t\t       && (h == NULL\n+\t\t\t   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT\n+\t\t\t   || h->root.type != bfd_link_hash_undefweak);\n \n \t    /* Shared GD.  */\n-\t    if (dynamic\n-\t\t&& (howto->type == R_OR1K_TLS_GD_HI16\n-\t\t    || howto->type == R_OR1K_TLS_GD_LO16\n-\t\t    || howto->type == R_OR1K_TLS_GD_PG21\n-\t\t    || howto->type == R_OR1K_TLS_GD_LO13))\n+\t    if (dynamic && ((tls_type & TLS_GD) != 0))\n \t      {\n \t\tint i;\n \n \t\t/* Add DTPMOD and DTPOFF GOT and rela entries.  */\n \t\tfor (i = 0; i < 2; ++i)\n \t\t  {\n+\t\t    BFD_ASSERT (srelgot->contents != NULL);\n+\n \t\t    rela.r_offset = got_base + gotoff + i*4;\n \t\t    if (h != NULL && h->dynindx != -1)\n \t\t      {\n@@ -1650,30 +1711,33 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \t\t      {\n \t\t\trela.r_info = ELF32_R_INFO (0,\n \t\t\t    (i == 0 ? R_OR1K_TLS_DTPMOD : R_OR1K_TLS_DTPOFF));\n-\t\t\trela.r_addend = tpoff (info, relocation);\n+\t\t\trela.r_addend =\n+\t\t\t    (i == 0 ? 0 : tpoff (info, relocation, dynamic));\n \t\t      }\n \n-\t\t    loc = sreloc->contents;\n-\t\t    loc += sreloc->reloc_count++ *\n-\t\t      sizeof (Elf32_External_Rela);\n+\t\t    loc = srelgot->contents;\n+\t\t    loc += (srelgot->reloc_count++\n+\t\t\t    * sizeof (Elf32_External_Rela));\n \n \t\t    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n \t\t    bfd_put_32 (output_bfd, 0, sgot->contents + gotoff + i*4);\n \t\t  }\n \t      }\n \t    /* Static GD.  */\n-\t    else if (howto->type == R_OR1K_TLS_GD_HI16\n-\t\t     || howto->type == R_OR1K_TLS_GD_LO16\n-\t\t     || howto->type == R_OR1K_TLS_GD_PG21\n-\t\t     || howto->type == R_OR1K_TLS_GD_LO13)\n+\t    else if ((tls_type & TLS_GD) != 0)\n \t      {\n \t\tbfd_put_32 (output_bfd, 1, sgot->contents + gotoff);\n-\t\tbfd_put_32 (output_bfd, tpoff (info, relocation),\n+\t\tbfd_put_32 (output_bfd, tpoff (info, relocation, dynamic),\n \t\t    sgot->contents + gotoff + 4);\n \t      }\n+\n+\t    gotoff += or1k_initial_exec_offset (howto, tls_type);\n+\n \t    /* Shared IE.  */\n-\t    else if (dynamic)\n+\t    if (dynamic && ((tls_type & TLS_IE) != 0))\n \t      {\n+\t\tBFD_ASSERT (srelgot->contents != NULL);\n+\n \t\t/* Add TPOFF GOT and rela entries.  */\n \t\trela.r_offset = got_base + gotoff;\n \t\tif (h != NULL && h->dynindx != -1)\n@@ -1684,21 +1748,19 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \t\telse\n \t\t  {\n \t\t    rela.r_info = ELF32_R_INFO (0, R_OR1K_TLS_TPOFF);\n-\t\t    rela.r_addend = tpoff (info, relocation);\n+\t\t    rela.r_addend = tpoff (info, relocation, dynamic);\n \t\t  }\n \n-\t\tloc = sreloc->contents;\n-\t\tloc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);\n+\t\tloc = srelgot->contents;\n+\t\tloc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);\n \n \t\tbfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n \t\tbfd_put_32 (output_bfd, 0, sgot->contents + gotoff);\n \t      }\n \t    /* Static IE.  */\n-\t    else\n-\t      {\n-\t\tbfd_put_32 (output_bfd, tpoff (info, relocation),\n-\t\t\t    sgot->contents + gotoff);\n-\t      }\n+\t    else if ((tls_type & TLS_IE) != 0)\n+\t      bfd_put_32 (output_bfd, tpoff (info, relocation, dynamic),\n+\t\t\t  sgot->contents + gotoff);\n \n \t    /* The PG21 and LO13 relocs are pc-relative, while the\n \t       rest are GOT relative.  */\n@@ -1716,7 +1778,7 @@ or1k_elf_relocate_section (bfd *output_bfd,\n \tcase R_OR1K_TLS_LE_AHI16:\n \tcase R_OR1K_TLS_LE_SLO16:\n \t  /* Relocation is offset from TP.  */\n-\t  relocation = tpoff (info, relocation);\n+\t  relocation = tpoff (info, relocation, 0);\n \t  break;\n \n \tcase R_OR1K_TLS_DTPMOD:\n@@ -1895,7 +1957,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \n       /* Record TLS type.  */\n       if (h != NULL)\n-\t  ((struct elf_or1k_link_hash_entry *) h)->tls_type = tls_type;\n+\t  ((struct elf_or1k_link_hash_entry *) h)->tls_type |= tls_type;\n       else\n \t{\n \t  unsigned char *local_tls_type;\n@@ -1912,7 +1974,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\treturn FALSE;\n \t      elf_or1k_local_tls_type (abfd) = local_tls_type;\n \t    }\n-\t  local_tls_type[r_symndx] = tls_type;\n+\t  local_tls_type[r_symndx] |= tls_type;\n \t}\n \n       switch (r_type)\n@@ -2047,7 +2109,7 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\t    && (h->root.type == bfd_link_hash_defweak\n \t\t\t|| !h->def_regular)))\n \t      {\n-\t\tstruct elf_dyn_relocs *p;\n+\t\tstruct elf_dyn_relocs *sec_relocs;\n \t\tstruct elf_dyn_relocs **head;\n \n \t\t/* When creating a shared object, we must copy these\n@@ -2115,24 +2177,26 @@ or1k_elf_check_relocs (bfd *abfd,\n \t\t    head = (struct elf_dyn_relocs **) vpp;\n \t\t  }\n \n-\t\tp = *head;\n-\t\tif (p == NULL || p->sec != sec)\n+\t\tsec_relocs = *head;\n+\t\t/* Allocate this sections dynamic reolcations structure if this\n+\t\t   is a new section.  */\n+\t\tif (sec_relocs == NULL || sec_relocs->sec != sec)\n \t\t  {\n-\t\t    size_t amt = sizeof *p;\n-\t\t    p = ((struct elf_dyn_relocs *)\n-\t\t\t bfd_alloc (htab->root.dynobj, amt));\n-\t\t    if (p == NULL)\n+\t\t    size_t amt = sizeof *sec_relocs;\n+\t\t    sec_relocs = ((struct elf_dyn_relocs *)\n+\t\t\t\t  bfd_alloc (htab->root.dynobj, amt));\n+\t\t    if (sec_relocs == NULL)\n \t\t      return FALSE;\n-\t\t    p->next = *head;\n-\t\t    *head = p;\n-\t\t    p->sec = sec;\n-\t\t    p->count = 0;\n-\t\t    p->pc_count = 0;\n+\t\t    sec_relocs->next = *head;\n+\t\t    *head = sec_relocs;\n+\t\t    sec_relocs->sec = sec;\n+\t\t    sec_relocs->count = 0;\n+\t\t    sec_relocs->pc_count = 0;\n \t\t  }\n \n-\t\tp->count += 1;\n+\t\tsec_relocs->count += 1;\n \t\tif (r_type == R_OR1K_INSN_REL_26)\n-\t\t  p->pc_count += 1;\n+\t\t  sec_relocs->pc_count += 1;\n \t      }\n \t  }\n \t  break;\n@@ -2402,14 +2466,14 @@ or1k_elf_finish_dynamic_symbol (bfd *output_bfd,\n       && (h->got.offset & 2) == 0) /* Homemade TLS check.  */\n     {\n       asection *sgot;\n-      asection *srela;\n+      asection *srelgot;\n       Elf_Internal_Rela rela;\n \n       /* This symbol has an entry in the global offset table.  Set it\n \t up.  */\n       sgot = htab->root.sgot;\n-      srela = htab->root.srelgot;\n-      BFD_ASSERT (sgot != NULL && srela != NULL);\n+      srelgot = htab->root.srelgot;\n+      BFD_ASSERT (sgot != NULL && srelgot != NULL);\n \n       rela.r_offset = (sgot->output_section->vma\n \t\t       + sgot->output_offset\n@@ -2435,10 +2499,10 @@ or1k_elf_finish_dynamic_symbol (bfd *output_bfd,\n \t  rela.r_addend = 0;\n \t}\n \n-      loc = srela->contents;\n-      loc += srela->reloc_count * sizeof (Elf32_External_Rela);\n+      loc = srelgot->contents;\n+      loc += srelgot->reloc_count * sizeof (Elf32_External_Rela);\n       bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);\n-      ++srela->reloc_count;\n+      ++srelgot->reloc_count;\n     }\n \n   if (h->needs_copy)\n@@ -2492,15 +2556,17 @@ or1k_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,\n static asection *\n readonly_dynrelocs (struct elf_link_hash_entry *h)\n {\n-  struct elf_dyn_relocs *p;\n+  struct elf_dyn_relocs *sec_relocs;\n   struct elf_or1k_link_hash_entry *eh = (struct elf_or1k_link_hash_entry *) h;\n \n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (sec_relocs = eh->dyn_relocs;\n+       sec_relocs != NULL;\n+       sec_relocs = sec_relocs->next)\n     {\n-      asection *s = p->sec->output_section;\n+      asection *s = sec_relocs->sec->output_section;\n \n       if (s != NULL && (s->flags & SEC_READONLY) != 0)\n-\treturn p->sec;\n+\treturn sec_relocs->sec;\n     }\n   return NULL;\n }\n@@ -2634,6 +2700,56 @@ or1k_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n   return _bfd_elf_adjust_dynamic_copy (info, h, s);\n }\n \n+/* Caclulate an update the sizes required for a symbol in the GOT and\n+   RELA relocation section based on the TLS_TYPE and whether or not the symbol\n+   is DYNAMIC.\n+\n+   Symbols with TLS_GD access require 8 bytes in the GOT and, if dynamic,\n+   require two relocation entries.  Symbols with TLS_IE access require 4 bytes\n+   in the GOT and, if dynamic, require one relocation entry.  Symbols may have\n+   both TLS_GD and TLS_IE access to be accounted for.\n+\n+   Other symbols require 4 bytes in the GOT table and, if dynamic, require one\n+   relocation entry.  */\n+\n+static void\n+or1k_set_got_and_rela_sizes (const unsigned char tls_type,\n+\t\t\t     const bfd_boolean dynamic,\n+\t\t\t     bfd_vma *got_size,\n+\t\t\t     bfd_vma *rela_size)\n+{\n+  bfd_boolean is_tls_entry = FALSE;\n+\n+  /* TLS GD requires two GOT entries and two relocs.  */\n+  if ((tls_type & TLS_GD) != 0)\n+    {\n+      *got_size += 8;\n+      is_tls_entry = TRUE;\n+    }\n+\n+  if ((tls_type & TLS_IE) != 0)\n+    {\n+      *got_size += 4;\n+      is_tls_entry = TRUE;\n+    }\n+\n+  if (is_tls_entry == FALSE)\n+    *got_size += 4;\n+\n+  if (dynamic)\n+    {\n+      if ((tls_type & TLS_GD) != 0)\n+\t*rela_size += 2 * sizeof (Elf32_External_Rela);\n+\n+      if ((tls_type & TLS_IE) != 0)\n+\t*rela_size += sizeof (Elf32_External_Rela);\n+\n+      if (is_tls_entry == FALSE)\n+\t*rela_size += sizeof (Elf32_External_Rela);\n+    }\n+}\n+\n+\n /* Allocate space in .plt, .got and associated reloc sections for\n    dynamic relocs.  */\n \n@@ -2643,7 +2759,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   struct bfd_link_info *info;\n   struct elf_or1k_link_hash_table *htab;\n   struct elf_or1k_link_hash_entry *eh;\n-  struct elf_dyn_relocs *p;\n+  struct elf_dyn_relocs *sec_relocs;\n \n   if (h->root.type == bfd_link_hash_indirect)\n     return TRUE;\n@@ -2669,14 +2785,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n       if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, bfd_link_pic (info), h))\n \t{\n-\t  asection *s = htab->root.splt;\n+\t  asection *splt = htab->root.splt;\n \n \t  /* If this is the first .plt entry, make room for the special\n \t     first entry.  */\n-\t  if (s->size == 0)\n-\t    s->size = PLT_ENTRY_SIZE;\n+\t  if (splt->size == 0)\n+\t    splt->size = PLT_ENTRY_SIZE;\n \n-\t  h->plt.offset = s->size;\n+\t  h->plt.offset = splt->size;\n \n \t  /* If this symbol is not defined in a regular file, and we are\n \t     not generating a shared library, then set the symbol to this\n@@ -2686,12 +2802,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t  if (! bfd_link_pic (info)\n \t      && !h->def_regular)\n \t    {\n-\t      h->root.u.def.section = s;\n+\t      h->root.u.def.section = splt;\n \t      h->root.u.def.value = h->plt.offset;\n \t    }\n \n \t  /* Make room for this entry.  */\n-\t  s->size += PLT_ENTRY_SIZE;\n+\t  splt->size += PLT_ENTRY_SIZE;\n \n \t  /* We also need to make an entry in the .got.plt section, which\n \t     will be placed in the .got section by the linker script.  */\n@@ -2714,7 +2830,7 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \n   if (h->got.refcount > 0)\n     {\n-      asection *s;\n+      asection *sgot;\n       bfd_boolean dyn;\n       unsigned char tls_type;\n \n@@ -2727,25 +2843,16 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t    return FALSE;\n \t}\n \n-      s = htab->root.sgot;\n+      sgot = htab->root.sgot;\n \n-      h->got.offset = s->size;\n+      h->got.offset = sgot->size;\n \n       tls_type = ((struct elf_or1k_link_hash_entry *) h)->tls_type;\n \n-      /* TLS GD requires two GOT and two relocs.  */\n-      if (tls_type == TLS_GD)\n-\ts->size += 8;\n-      else\n-\ts->size += 4;\n       dyn = htab->root.dynamic_sections_created;\n-      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h))\n-\t{\n-\t  if (tls_type == TLS_GD)\n-\t    htab->root.srelgot->size += 2 * sizeof (Elf32_External_Rela);\n-\t  else\n-\t    htab->root.srelgot->size += sizeof (Elf32_External_Rela);\n-\t}\n+      dyn = WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, bfd_link_pic (info), h);\n+      or1k_set_got_and_rela_sizes (tls_type, dyn,\n+\t\t\t\t   &sgot->size, &htab->root.srelgot->size);\n     }\n   else\n     h->got.offset = (bfd_vma) -1;\n@@ -2765,14 +2872,14 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n \t{\n \t  struct elf_dyn_relocs **pp;\n \n-\t  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)\n+\t  for (pp = &eh->dyn_relocs; (sec_relocs = *pp) != NULL;)\n \t    {\n-\t      p->count -= p->pc_count;\n-\t      p->pc_count = 0;\n-\t      if (p->count == 0)\n-\t\t*pp = p->next;\n+\t      sec_relocs->count -= sec_relocs->pc_count;\n+\t      sec_relocs->pc_count = 0;\n+\t      if (sec_relocs->count == 0)\n+\t\t*pp = sec_relocs->next;\n \t      else\n-\t\tpp = &p->next;\n+\t\tpp = &sec_relocs->next;\n \t    }\n \t}\n \n@@ -2828,10 +2935,12 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n     }\n \n   /* Finally, allocate space.  */\n-  for (p = eh->dyn_relocs; p != NULL; p = p->next)\n+  for (sec_relocs = eh->dyn_relocs;\n+       sec_relocs != NULL;\n+       sec_relocs = sec_relocs->next)\n     {\n-      asection *sreloc = elf_section_data (p->sec)->sreloc;\n-      sreloc->size += p->count * sizeof (Elf32_External_Rela);\n+      asection *sreloc = elf_section_data (sec_relocs->sec)->sreloc;\n+      sreloc->size += sec_relocs->count * sizeof (Elf32_External_Rela);\n     }\n \n   return TRUE;\n@@ -2911,26 +3020,28 @@ or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       for (s = ibfd->sections; s != NULL; s = s->next)\n \t{\n-\t  struct elf_dyn_relocs *p;\n+\t  struct elf_dyn_relocs *sec_relocs;\n \n-\t  for (p = ((struct elf_dyn_relocs *)\n-\t\t    elf_section_data (s)->local_dynrel);\n-\t       p != NULL;\n-\t       p = p->next)\n+\t  for (sec_relocs = ((struct elf_dyn_relocs *)\n+\t\t\t     elf_section_data (s)->local_dynrel);\n+\t       sec_relocs != NULL;\n+\t       sec_relocs = sec_relocs->next)\n \t    {\n-\t      if (! bfd_is_abs_section (p->sec)\n-\t\t  && bfd_is_abs_section (p->sec->output_section))\n+\t      if (! bfd_is_abs_section (sec_relocs->sec)\n+\t\t  && bfd_is_abs_section (sec_relocs->sec->output_section))\n \t\t{\n \t\t  /* Input section has been discarded, either because\n \t\t     it is a copy of a linkonce section or due to\n \t\t     linker script /DISCARD/, so we'll be discarding\n \t\t     the relocs too.  */\n \t\t}\n-\t      else if (p->count != 0)\n+\t      else if (sec_relocs->count != 0)\n \t\t{\n-\t\t  srel = elf_section_data (p->sec)->sreloc;\n-\t\t  srel->size += p->count * sizeof (Elf32_External_Rela);\n-\t\t  if ((p->sec->output_section->flags & SEC_READONLY) != 0)\n+\t\t  srel = elf_section_data (sec_relocs->sec)->sreloc;\n+\t\t  srel->size += sec_relocs->count\n+\t\t\t\t* sizeof (Elf32_External_Rela);\n+\t\t  if ((sec_relocs->sec->output_section->flags & SEC_READONLY)\n+\t\t      != 0)\n \t\t    info->flags |= DF_TEXTREL;\n \t\t}\n \t    }\n@@ -2950,20 +3061,13 @@ or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t{\n \t  if (*local_got > 0)\n \t    {\n-\t      *local_got = s->size;\n+\t      unsigned char tls_type = (local_tls_type == NULL)\n+\t\t\t\t\t? TLS_UNKNOWN\n+\t\t\t\t\t: *local_tls_type;\n \n-\t      /* TLS GD requires two GOT and two relocs.  */\n-\t      if (local_tls_type != NULL && *local_tls_type == TLS_GD)\n-\t\ts->size += 8;\n-\t      else\n-\t\ts->size += 4;\n-\t      if (bfd_link_pic (info))\n-\t\t{\n-\t\t  if (local_tls_type != NULL && *local_tls_type == TLS_GD)\n-\t\t    srel->size += 2 * sizeof (Elf32_External_Rela);\n-\t\t  else\n-\t\t    srel->size += sizeof (Elf32_External_Rela);\n-\t\t}\n+\t      *local_got = s->size;\n+\t      or1k_set_got_and_rela_sizes (tls_type, bfd_link_pic (info),\n+\t\t\t\t\t   &s->size, &srel->size);\n \t    }\n \t  else\n "
    }
  ]
}