{
  "sha": "32603266e5688718faad35b7502aa0b72a42764a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzI2MDMyNjZlNTY4ODcxOGZhYWQzNWI3NTAyYWEwYjcyYTQyNzY0YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-24T05:16:53Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-06T23:04:31Z"
    },
    "message": "C++ify remote notification code\n\nThis C++ifies the remote notification code -- replacing function\npointers with virtual methods and using unique_ptr.  This allows for\nthe removal of some cleanups.\n\n2019-03-06  Tom Tromey  <tom@tromey.com>\n\n\t* remote.c (struct stop_reply_deleter): Remove.\n\t(stop_reply_up): Update.\n\t(struct stop_reply): Derive from notif_event.  Don't typedef.\n\t<regcache>: Now a std::vector.\n\t(stop_reply_xfree): Remove.\n\t(stop_reply::~stop_reply): Rename from stop_reply_dtr.\n\t(remote_notif_stop_alloc_reply): Return a unique_ptr.  Use new.\n\t(remote_target::discard_pending_stop_replies): Use delete.\n\t(remote_target::remote_parse_stop_reply): Update.\n\t(remote_target::process_stop_reply): Update.\n\t* remote-notif.h (struct notif_event): Add virtual destructor.\n\tRemove \"dtr\" member.\n\t(struct notif_client) <alloc_event>: Return a unique_ptr.\n\t(notif_event_xfree): Don't declare.\n\t(notif_event_up): New typedef.\n\t* remote-notif.c (remote_notif_ack, remote_notif_parse): Update.\n\t(notif_event_xfree, do_notif_event_xfree): Remove.\n\t(remote_notif_state_xfree): Update.",
    "tree": {
      "sha": "f686b0e4adf854552bacf4aa2079bd9ae6ac0a4b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f686b0e4adf854552bacf4aa2079bd9ae6ac0a4b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/32603266e5688718faad35b7502aa0b72a42764a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/32603266e5688718faad35b7502aa0b72a42764a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/32603266e5688718faad35b7502aa0b72a42764a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/32603266e5688718faad35b7502aa0b72a42764a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9799571ecb648ea2e911498cfdc7fafe3237c94a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9799571ecb648ea2e911498cfdc7fafe3237c94a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9799571ecb648ea2e911498cfdc7fafe3237c94a"
    }
  ],
  "stats": {
    "total": 158,
    "additions": 59,
    "deletions": 99
  },
  "files": [
    {
      "sha": "2d7e32895256a695b08972ceeaa05cfae7ee14ac",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32603266e5688718faad35b7502aa0b72a42764a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32603266e5688718faad35b7502aa0b72a42764a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=32603266e5688718faad35b7502aa0b72a42764a",
      "patch": "@@ -1,3 +1,24 @@\n+2019-03-06  Tom Tromey  <tom@tromey.com>\n+\n+\t* remote.c (struct stop_reply_deleter): Remove.\n+\t(stop_reply_up): Update.\n+\t(struct stop_reply): Derive from notif_event.  Don't typedef.\n+\t<regcache>: Now a std::vector.\n+\t(stop_reply_xfree): Remove.\n+\t(stop_reply::~stop_reply): Rename from stop_reply_dtr.\n+\t(remote_notif_stop_alloc_reply): Return a unique_ptr.  Use new.\n+\t(remote_target::discard_pending_stop_replies): Use delete.\n+\t(remote_target::remote_parse_stop_reply): Update.\n+\t(remote_target::process_stop_reply): Update.\n+\t* remote-notif.h (struct notif_event): Add virtual destructor.\n+\tRemove \"dtr\" member.\n+\t(struct notif_client) <alloc_event>: Return a unique_ptr.\n+\t(notif_event_xfree): Don't declare.\n+\t(notif_event_up): New typedef.\n+\t* remote-notif.c (remote_notif_ack, remote_notif_parse): Update.\n+\t(notif_event_xfree, do_notif_event_xfree): Remove.\n+\t(remote_notif_state_xfree): Update.\n+\n 2019-03-06  Tom Tromey  <tom@tromey.com>\n \n \t* infrun.c (displaced_step_clear_cleanup): Now a"
    },
    {
      "sha": "eece9470061f41ddda3d94c75e4f33bf1cfb93fe",
      "filename": "gdb/remote-notif.c",
      "status": "modified",
      "additions": 7,
      "deletions": 35,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote-notif.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote-notif.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-notif.c?ref=32603266e5688718faad35b7502aa0b72a42764a",
      "patch": "@@ -52,27 +52,21 @@ static struct notif_client *notifs[] =\n \n gdb_static_assert (ARRAY_SIZE (notifs) == REMOTE_NOTIF_LAST);\n \n-static void do_notif_event_xfree (void *arg);\n-\n /* Parse the BUF for the expected notification NC, and send packet to\n    acknowledge.  */\n \n void\n remote_notif_ack (remote_target *remote,\n \t\t  struct notif_client *nc, const char *buf)\n {\n-  struct notif_event *event = nc->alloc_event ();\n-  struct cleanup *old_chain\n-    = make_cleanup (do_notif_event_xfree, event);\n+  notif_event_up event = nc->alloc_event ();\n \n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog, \"notif: ack '%s'\\n\",\n \t\t\tnc->ack_command);\n \n-  nc->parse (remote, nc, buf, event);\n-  nc->ack (remote, nc, buf, event);\n-\n-  discard_cleanups (old_chain);\n+  nc->parse (remote, nc, buf, event.get ());\n+  nc->ack (remote, nc, buf, event.release ());\n }\n \n /* Parse the BUF for the expected notification NC.  */\n@@ -81,17 +75,14 @@ struct notif_event *\n remote_notif_parse (remote_target *remote,\n \t\t    struct notif_client *nc, const char *buf)\n {\n-  struct notif_event *event = nc->alloc_event ();\n-  struct cleanup *old_chain\n-    = make_cleanup (do_notif_event_xfree, event);\n+  notif_event_up event = nc->alloc_event ();\n \n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog, \"notif: parse '%s'\\n\", nc->name);\n \n-  nc->parse (remote, nc, buf, event);\n+  nc->parse (remote, nc, buf, event.get ());\n \n-  discard_cleanups (old_chain);\n-  return event;\n+  return event.release ();\n }\n \n DEFINE_QUEUE_P (notif_client_p);\n@@ -216,25 +207,6 @@ handle_notification (struct remote_notif_state *state, const char *buf)\n     }\n }\n \n-/* Invoke destructor of EVENT and xfree it.  */\n-\n-void\n-notif_event_xfree (struct notif_event *event)\n-{\n-  if (event != NULL && event->dtr != NULL)\n-    event->dtr (event);\n-\n-  xfree (event);\n-}\n-\n-/* Cleanup wrapper.  */\n-\n-static void\n-do_notif_event_xfree (void *arg)\n-{\n-  notif_event_xfree ((struct notif_event *) arg);\n-}\n-\n /* Return an allocated remote_notif_state.  */\n \n struct remote_notif_state *\n@@ -269,7 +241,7 @@ remote_notif_state_xfree (struct remote_notif_state *state)\n     delete_async_event_handler (&state->get_pending_events_token);\n \n   for (i = 0; i < REMOTE_NOTIF_LAST; i++)\n-    notif_event_xfree (state->pending_event[i]);\n+    delete state->pending_event[i];\n \n   xfree (state);\n }"
    },
    {
      "sha": "87b52a18f9ec7fc6b98084d7ee2273563485f67e",
      "filename": "gdb/remote-notif.h",
      "status": "modified",
      "additions": 9,
      "deletions": 6,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote-notif.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote-notif.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-notif.h?ref=32603266e5688718faad35b7502aa0b72a42764a",
      "patch": "@@ -20,17 +20,22 @@\n #ifndef REMOTE_NOTIF_H\n #define REMOTE_NOTIF_H\n \n+#include <memory>\n #include \"common/queue.h\"\n \n /* An event of a type of async remote notification.  */\n \n struct notif_event\n {\n-  /* Destructor.  Release everything from SELF, but not SELF\n-     itself.  */\n-  void (*dtr) (struct notif_event *self);\n+  virtual ~notif_event ()\n+  {\n+  }\n };\n \n+/* A unique pointer holding a notif_event.  */\n+\n+typedef std::unique_ptr<notif_event> notif_event_up;\n+\n /* ID of the notif_client.  */\n \n enum REMOTE_NOTIF_ID\n@@ -70,7 +75,7 @@ typedef struct notif_client\n \t\t\t\t struct notif_client *self);\n \n   /* Allocate an event.  */\n-  struct notif_event *(*alloc_event) (void);\n+  notif_event_up (*alloc_event) ();\n \n   /* Id of this notif_client.  */\n   const enum REMOTE_NOTIF_ID id;\n@@ -112,8 +117,6 @@ struct notif_event *remote_notif_parse (remote_target *remote,\n \t\t\t\t\tnotif_client *nc,\n \t\t\t\t\tconst char *buf);\n \n-void notif_event_xfree (struct notif_event *event);\n-\n void handle_notification (struct remote_notif_state *notif_state,\n \t\t\t  const char *buf);\n "
    },
    {
      "sha": "7d556add0df354e1391a4c5fb0896685b9a7ee16",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 22,
      "deletions": 58,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/32603266e5688718faad35b7502aa0b72a42764a/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=32603266e5688718faad35b7502aa0b72a42764a",
      "patch": "@@ -96,17 +96,7 @@ struct protocol_feature;\n struct packet_reg;\n \n struct stop_reply;\n-static void stop_reply_xfree (struct stop_reply *);\n-\n-struct stop_reply_deleter\n-{\n-  void operator() (stop_reply *r) const\n-  {\n-    stop_reply_xfree (r);\n-  }\n-};\n-\n-typedef std::unique_ptr<stop_reply, stop_reply_deleter> stop_reply_up;\n+typedef std::unique_ptr<stop_reply> stop_reply_up;\n \n /* Generic configuration support for packets the stub optionally\n    supports.  Allows the user to specify the use of the packet as well\n@@ -6813,11 +6803,9 @@ remote_console_output (const char *msg)\n   gdb_flush (gdb_stdtarg);\n }\n \n-DEF_VEC_O(cached_reg_t);\n-\n-typedef struct stop_reply\n+struct stop_reply : public notif_event\n {\n-  struct notif_event base;\n+  ~stop_reply ();\n \n   /* The identifier of the thread about this event  */\n   ptid_t ptid;\n@@ -6836,20 +6824,14 @@ typedef struct stop_reply\n      efficient for those targets that provide critical registers as\n      part of their normal status mechanism (as another roundtrip to\n      fetch them is avoided).  */\n-  VEC(cached_reg_t) *regcache;\n+  std::vector<cached_reg_t> regcache;\n \n   enum target_stop_reason stop_reason;\n \n   CORE_ADDR watch_data_address;\n \n   int core;\n-} *stop_reply_p;\n-\n-static void\n-stop_reply_xfree (struct stop_reply *r)\n-{\n-  notif_event_xfree ((struct notif_event *) r);\n-}\n+};\n \n /* Return the length of the stop reply queue.  */\n \n@@ -6901,30 +6883,16 @@ remote_notif_stop_can_get_pending_events (remote_target *remote,\n   return 0;\n }\n \n-static void\n-stop_reply_dtr (struct notif_event *event)\n+stop_reply::~stop_reply ()\n {\n-  struct stop_reply *r = (struct stop_reply *) event;\n-  cached_reg_t *reg;\n-  int ix;\n-\n-  for (ix = 0;\n-       VEC_iterate (cached_reg_t, r->regcache, ix, reg);\n-       ix++)\n-    xfree (reg->data);\n-\n-  VEC_free (cached_reg_t, r->regcache);\n+  for (cached_reg_t &reg : regcache)\n+    xfree (reg.data);\n }\n \n-static struct notif_event *\n-remote_notif_stop_alloc_reply (void)\n+static notif_event_up\n+remote_notif_stop_alloc_reply ()\n {\n-  /* We cast to a pointer to the \"base class\".  */\n-  struct notif_event *r = (struct notif_event *) XNEW (struct stop_reply);\n-\n-  r->dtr = stop_reply_dtr;\n-\n-  return r;\n+  return notif_event_up (new struct stop_reply ());\n }\n \n /* A client of notification Stop.  */\n@@ -7067,7 +7035,7 @@ remote_target::discard_pending_stop_replies (struct inferior *inf)\n   /* Discard the in-flight notification.  */\n   if (reply != NULL && reply->ptid.pid () == inf->pid)\n     {\n-      stop_reply_xfree (reply);\n+      delete reply;\n       rns->pending_event[notif_client_stop.id] = NULL;\n     }\n \n@@ -7211,7 +7179,7 @@ remote_target::remote_parse_stop_reply (const char *buf, stop_reply *event)\n   event->ws.kind = TARGET_WAITKIND_IGNORE;\n   event->ws.value.integer = 0;\n   event->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n-  event->regcache = NULL;\n+  event->regcache.clear ();\n   event->core = -1;\n \n   switch (buf[0])\n@@ -7447,7 +7415,7 @@ Packet: '%s'\\n\"),\n \t\t  if (fieldsize < register_size (event->arch, reg->regnum))\n \t\t    warning (_(\"Remote reply is too short: %s\"), buf);\n \n-\t\t  VEC_safe_push (cached_reg_t, event->regcache, &cached_reg);\n+\t\t  event->regcache.push_back (cached_reg);\n \t\t}\n \t      else\n \t\t{\n@@ -7663,22 +7631,18 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n       && status->kind != TARGET_WAITKIND_NO_RESUMED)\n     {\n       /* Expedited registers.  */\n-      if (stop_reply->regcache)\n+      if (!stop_reply->regcache.empty ())\n \t{\n \t  struct regcache *regcache\n \t    = get_thread_arch_regcache (ptid, stop_reply->arch);\n-\t  cached_reg_t *reg;\n-\t  int ix;\n \n-\t  for (ix = 0;\n-\t       VEC_iterate (cached_reg_t, stop_reply->regcache, ix, reg);\n-\t       ix++)\n-\t  {\n-\t    regcache->raw_supply (reg->num, reg->data);\n-\t    xfree (reg->data);\n-\t  }\n+\t  for (cached_reg_t &reg : stop_reply->regcache)\n+\t    {\n+\t      regcache->raw_supply (reg.num, reg.data);\n+\t      xfree (reg.data);\n+\t    }\n \n-\t  VEC_free (cached_reg_t, stop_reply->regcache);\n+\t  stop_reply->regcache.clear ();\n \t}\n \n       remote_notice_new_inferior (ptid, 0);\n@@ -7689,7 +7653,7 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n       remote_thr->vcont_resumed = 0;\n     }\n \n-  stop_reply_xfree (stop_reply);\n+  delete stop_reply;\n   return ptid;\n }\n "
    }
  ]
}