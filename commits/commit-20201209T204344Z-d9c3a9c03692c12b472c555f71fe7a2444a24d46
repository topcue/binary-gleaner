{
  "sha": "d9c3a9c03692c12b472c555f71fe7a2444a24d46",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDljM2E5YzAzNjkyYzEyYjQ3MmM1NTVmNzFmZTdhMjQ0NGEyNGQ0Ng==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-12-09T20:43:44Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-12-09T20:43:44Z"
    },
    "message": "Unify all operators into std-operator.def\n\nThis removes ada-operator.def and fortran-operator.def, merging their\ncontents into std-operator.def.\n\nNote that the comment for OP_EXTENDED0 is a bit wrong.  IMO this\nconstant could be removed, as it is only used for a single assert that\ndoes not provide much value.  However, I haven't done so here.\n\ngdb/ChangeLog\n2020-12-09  Tom Tromey  <tromey@adacore.com>\n\n\t* expprint.c (op_name): Update.\n\t* expression.h (enum exp_opcode): Update.\n\t* std-operator.def: Add more opcodes.\n\t* ada-operator.def, fortran-operator.def: Remove, moving contents\n\tinto std-operator.def.",
    "tree": {
      "sha": "29ec48164b06f4af8983f1f3ca0761cc8371f272",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/29ec48164b06f4af8983f1f3ca0761cc8371f272"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d9c3a9c03692c12b472c555f71fe7a2444a24d46",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d9c3a9c03692c12b472c555f71fe7a2444a24d46",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d9c3a9c03692c12b472c555f71fe7a2444a24d46",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d9c3a9c03692c12b472c555f71fe7a2444a24d46/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6ad368b8caf6650852983fc23814c9f393da0439",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6ad368b8caf6650852983fc23814c9f393da0439",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6ad368b8caf6650852983fc23814c9f393da0439"
    }
  ],
  "stats": {
    "total": 257,
    "additions": 113,
    "deletions": 144
  },
  "files": [
    {
      "sha": "6c76405458a9c2f19d330aa8fccc75203ebc7f11",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d9c3a9c03692c12b472c555f71fe7a2444a24d46",
      "patch": "@@ -1,3 +1,11 @@\n+2020-12-09  Tom Tromey  <tromey@adacore.com>\n+\n+\t* expprint.c (op_name): Update.\n+\t* expression.h (enum exp_opcode): Update.\n+\t* std-operator.def: Add more opcodes.\n+\t* ada-operator.def, fortran-operator.def: Remove, moving contents\n+\tinto std-operator.def.\n+\n 2020-12-09  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* gdbtypes.c (get_discrete_low_bound, get_discrete_high_bound):"
    },
    {
      "sha": "8a578cbc46581c3a56f6c318463dbdc29e7c7df3",
      "filename": "gdb/ada-operator.def",
      "status": "removed",
      "additions": 0,
      "deletions": 98,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ad368b8caf6650852983fc23814c9f393da0439/gdb/ada-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ad368b8caf6650852983fc23814c9f393da0439/gdb/ada-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-operator.def?ref=6ad368b8caf6650852983fc23814c9f393da0439",
      "patch": "@@ -1,98 +0,0 @@\n-/* Ada language operator definitions for GDB, the GNU debugger.\n-\n-   Copyright (C) 1992-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* X IN A'RANGE(N).  N is an immediate operand, surrounded by \n-   BINOP_IN_BOUNDS before and after.  A is an array, X an index \n-   value.  Evaluates to true iff X is within range of the Nth\n-   dimension (1-based) of A.  (A multi-dimensional array\n-   type is represented as array of array of ...) */\n-OP (BINOP_IN_BOUNDS)\n-\n-/* X IN L .. U.  True iff L <= X <= U.  */\n-OP (TERNOP_IN_RANGE)\n-\n-/* Ada attributes ('Foo). */\n-OP (OP_ATR_FIRST)\n-OP (OP_ATR_LAST)\n-OP (OP_ATR_LENGTH)\n-OP (OP_ATR_IMAGE)\n-OP (OP_ATR_MAX)\n-OP (OP_ATR_MIN)\n-OP (OP_ATR_MODULUS)\n-OP (OP_ATR_POS)\n-OP (OP_ATR_SIZE)\n-OP (OP_ATR_TAG)\n-OP (OP_ATR_VAL)\n-\n-/* Ada type qualification.  It is encoded as for UNOP_CAST, above, \n-   and denotes the TYPE'(EXPR) construct. */\n-OP (UNOP_QUAL)\n-\n-/* X IN TYPE.  The `TYPE' argument is immediate, with \n-   UNOP_IN_RANGE before and after it. True iff X is a member of \n-   type TYPE (typically a subrange). */\n-OP (UNOP_IN_RANGE)\n-\n-/* An aggregate.   A single immediate operand, N>0, gives\n-   the number of component specifications that follow.  The\n-   immediate operand is followed by a second OP_AGGREGATE.  \n-   Next come N component specifications.  A component\n-   specification is either an OP_OTHERS (others=>...), an\n-   OP_CHOICES (for named associations), or other expression (for\n-   positional aggregates only).  Aggregates currently\n-   occur only as the right sides of assignments. */\n-OP (OP_AGGREGATE)\n-\n-/* An others clause.  Followed by a single expression. */\n-OP (OP_OTHERS)\n-\n-/* An aggregate component association.  A single immediate operand, N, \n-   gives the number of choices that follow.  This is followed by a second\n-   OP_CHOICES operator.  Next come N operands, each of which is an\n-   expression, an OP_DISCRETE_RANGE, or an OP_NAME---the latter \n-   for a simple name that must be a record component name and does \n-   not correspond to a single existing symbol.  After the N choice \n-   indicators comes an expression giving the value.\n-\n-   In an aggregate such as (X => E1, ...), where X is a simple\n-   name, X could syntactically be either a component_selector_name \n-   or an expression used as a discrete_choice, depending on the\n-   aggregate's type context.  Since this is not known at parsing\n-   time, we don't attempt to disambiguate X if it has multiple\n-   definitions, but instead supply an OP_NAME.  If X has a single\n-   definition, we represent it with an OP_VAR_VALUE, even though\n-   it may turn out to be within a record aggregate.  Aggregate \n-   evaluation can use either OP_NAMEs or OP_VAR_VALUEs to get a\n-   record field name, and can evaluate OP_VAR_VALUE normally to\n-   get its value as an expression.  Unfortunately, we lose out in\n-   cases where X has multiple meanings and is part of an array\n-   aggregate.  I hope these are not common enough to annoy users,\n-   who can work around the problem in any case by putting\n-   parentheses around X. */\n-OP (OP_CHOICES)\n-\n-/* A positional aggregate component association.  The operator is \n-   followed by a single integer indicating the position in the \n-   aggregate (0-based), followed by a second OP_POSITIONAL.  Next \n-   follows a single expression giving the component value.  */\n-OP (OP_POSITIONAL)\n-\n-/* A range of values.  Followed by two expressions giving the\n-   upper and lower bounds of the range. */\n-OP (OP_DISCRETE_RANGE)"
    },
    {
      "sha": "5b4ea14d440b955d29e670f4a70567d172f5ee0d",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=d9c3a9c03692c12b472c555f71fe7a2444a24d46",
      "patch": "@@ -704,8 +704,6 @@ op_name (enum exp_opcode opcode)\n     case name:\t\t\\\n       return #name ;\n #include \"std-operator.def\"\n-#include \"ada-operator.def\"\n-#include \"fortran-operator.def\"\n #undef OP\n     }\n }"
    },
    {
      "sha": "9ac940fa4d005e2002a685d6963fe4404bc99103",
      "filename": "gdb/expression.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expression.h?ref=d9c3a9c03692c12b472c555f71fe7a2444a24d46",
      "patch": "@@ -61,15 +61,6 @@ enum exp_opcode : uint8_t\n \n #include \"std-operator.def\"\n \n-    /* First extension operator.  Individual language modules define extra\n-       operators in *.def include files below with numbers higher than\n-       OP_EXTENDED0.  */\n-    OP (OP_EXTENDED0)\n-\n-/* Language specific operators.  */\n-#include \"ada-operator.def\"\n-#include \"fortran-operator.def\"\n-\n #undef OP\n \n     /* Existing only to swallow the last comma (',') from last .inc file.  */"
    },
    {
      "sha": "bfdbc40171186b6d52e794325555f7933f6489da",
      "filename": "gdb/fortran-operator.def",
      "status": "removed",
      "additions": 0,
      "deletions": 35,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6ad368b8caf6650852983fc23814c9f393da0439/gdb/fortran-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6ad368b8caf6650852983fc23814c9f393da0439/gdb/fortran-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fortran-operator.def?ref=6ad368b8caf6650852983fc23814c9f393da0439",
      "patch": "@@ -1,35 +0,0 @@\n-/* Fortran language operator definitions for GDB, the GNU debugger.\n-\n-   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-/* This is EXACTLY like OP_FUNCALL but is semantically different.\n-   In F77, array subscript expressions, substring expressions and\n-   function calls are all exactly the same syntactically.  They\n-   may only be disambiguated at runtime.  Thus this operator,\n-   which indicates that we have found something of the form\n-   <name> ( <stuff> ).  */\n-OP (OP_F77_UNDETERMINED_ARGLIST)\n-\n-/* Single operand builtins.  */\n-OP (UNOP_FORTRAN_KIND)\n-OP (UNOP_FORTRAN_FLOOR)\n-OP (UNOP_FORTRAN_CEILING)\n-\n-/* Two operand builtins.  */\n-OP (BINOP_FORTRAN_CMPLX)\n-OP (BINOP_FORTRAN_MODULO)"
    },
    {
      "sha": "fadd092a15b0a3f02a163956bdecda3c35a5d3dd",
      "filename": "gdb/std-operator.def",
      "status": "modified",
      "additions": 105,
      "deletions": 0,
      "changes": 105,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/std-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d9c3a9c03692c12b472c555f71fe7a2444a24d46/gdb/std-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/std-operator.def?ref=d9c3a9c03692c12b472c555f71fe7a2444a24d46",
      "patch": "@@ -337,3 +337,108 @@ OP (OP_TYPEID)\n /* This is used for the Rust [expr; N] form of array construction.  It\n    takes two expression arguments.  */\n OP (OP_RUST_ARRAY)\n+\n+/* First extension operator.  Some language modules define extra\n+   operators below with numbers higher than OP_EXTENDED0.  */\n+OP (OP_EXTENDED0)\n+\n+/* ================ Ada operators ================ */\n+\n+/* X IN A'RANGE(N).  N is an immediate operand, surrounded by \n+   BINOP_IN_BOUNDS before and after.  A is an array, X an index \n+   value.  Evaluates to true iff X is within range of the Nth\n+   dimension (1-based) of A.  (A multi-dimensional array\n+   type is represented as array of array of ...) */\n+OP (BINOP_IN_BOUNDS)\n+\n+/* X IN L .. U.  True iff L <= X <= U.  */\n+OP (TERNOP_IN_RANGE)\n+\n+/* Ada attributes ('Foo). */\n+OP (OP_ATR_FIRST)\n+OP (OP_ATR_LAST)\n+OP (OP_ATR_LENGTH)\n+OP (OP_ATR_IMAGE)\n+OP (OP_ATR_MAX)\n+OP (OP_ATR_MIN)\n+OP (OP_ATR_MODULUS)\n+OP (OP_ATR_POS)\n+OP (OP_ATR_SIZE)\n+OP (OP_ATR_TAG)\n+OP (OP_ATR_VAL)\n+\n+/* Ada type qualification.  It is encoded as for UNOP_CAST, above, \n+   and denotes the TYPE'(EXPR) construct. */\n+OP (UNOP_QUAL)\n+\n+/* X IN TYPE.  The `TYPE' argument is immediate, with \n+   UNOP_IN_RANGE before and after it. True iff X is a member of \n+   type TYPE (typically a subrange). */\n+OP (UNOP_IN_RANGE)\n+\n+/* An aggregate.   A single immediate operand, N>0, gives\n+   the number of component specifications that follow.  The\n+   immediate operand is followed by a second OP_AGGREGATE.  \n+   Next come N component specifications.  A component\n+   specification is either an OP_OTHERS (others=>...), an\n+   OP_CHOICES (for named associations), or other expression (for\n+   positional aggregates only).  Aggregates currently\n+   occur only as the right sides of assignments. */\n+OP (OP_AGGREGATE)\n+\n+/* An others clause.  Followed by a single expression. */\n+OP (OP_OTHERS)\n+\n+/* An aggregate component association.  A single immediate operand, N, \n+   gives the number of choices that follow.  This is followed by a second\n+   OP_CHOICES operator.  Next come N operands, each of which is an\n+   expression, an OP_DISCRETE_RANGE, or an OP_NAME---the latter \n+   for a simple name that must be a record component name and does \n+   not correspond to a single existing symbol.  After the N choice \n+   indicators comes an expression giving the value.\n+\n+   In an aggregate such as (X => E1, ...), where X is a simple\n+   name, X could syntactically be either a component_selector_name \n+   or an expression used as a discrete_choice, depending on the\n+   aggregate's type context.  Since this is not known at parsing\n+   time, we don't attempt to disambiguate X if it has multiple\n+   definitions, but instead supply an OP_NAME.  If X has a single\n+   definition, we represent it with an OP_VAR_VALUE, even though\n+   it may turn out to be within a record aggregate.  Aggregate \n+   evaluation can use either OP_NAMEs or OP_VAR_VALUEs to get a\n+   record field name, and can evaluate OP_VAR_VALUE normally to\n+   get its value as an expression.  Unfortunately, we lose out in\n+   cases where X has multiple meanings and is part of an array\n+   aggregate.  I hope these are not common enough to annoy users,\n+   who can work around the problem in any case by putting\n+   parentheses around X. */\n+OP (OP_CHOICES)\n+\n+/* A positional aggregate component association.  The operator is \n+   followed by a single integer indicating the position in the \n+   aggregate (0-based), followed by a second OP_POSITIONAL.  Next \n+   follows a single expression giving the component value.  */\n+OP (OP_POSITIONAL)\n+\n+/* A range of values.  Followed by two expressions giving the\n+   upper and lower bounds of the range. */\n+OP (OP_DISCRETE_RANGE)\n+\n+/* ================ Fortran operators ================ */\n+\n+/* This is EXACTLY like OP_FUNCALL but is semantically different.\n+   In F77, array subscript expressions, substring expressions and\n+   function calls are all exactly the same syntactically.  They\n+   may only be disambiguated at runtime.  Thus this operator,\n+   which indicates that we have found something of the form\n+   <name> ( <stuff> ).  */\n+OP (OP_F77_UNDETERMINED_ARGLIST)\n+\n+/* Single operand builtins.  */\n+OP (UNOP_FORTRAN_KIND)\n+OP (UNOP_FORTRAN_FLOOR)\n+OP (UNOP_FORTRAN_CEILING)\n+\n+/* Two operand builtins.  */\n+OP (BINOP_FORTRAN_CMPLX)\n+OP (BINOP_FORTRAN_MODULO)"
    }
  ]
}