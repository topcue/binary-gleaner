{
  "sha": "4d496013a253a068fe2f8c3a9f8a72efe298a790",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGQ0OTYwMTNhMjUzYTA2OGZlMmY4YzNhOWY4YTcyZWZlMjk4YTc5MA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-02-20T05:12:22Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-02-20T07:56:10Z"
    },
    "message": "Fail run_dump_test when an error is expected but not seen\n\n\t* testsuite/lib/binutils-common.exp: Whitespace fixes throughout.\n\t(run_dump_test): Fail if expecting errors from a file like we do\n\tfor error strings, if no error is seen.",
    "tree": {
      "sha": "c287ebfdb139776eb47b82a186ce2f8a74309680",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c287ebfdb139776eb47b82a186ce2f8a74309680"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4d496013a253a068fe2f8c3a9f8a72efe298a790",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d496013a253a068fe2f8c3a9f8a72efe298a790",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4d496013a253a068fe2f8c3a9f8a72efe298a790",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d496013a253a068fe2f8c3a9f8a72efe298a790/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c3bf9dc5aa3f9be3369e5ab364111d5e0c8567bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c3bf9dc5aa3f9be3369e5ab364111d5e0c8567bd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c3bf9dc5aa3f9be3369e5ab364111d5e0c8567bd"
    }
  ],
  "stats": {
    "total": 692,
    "additions": 349,
    "deletions": 343
  },
  "files": [
    {
      "sha": "582beb89f8bfc54ccbd0f41babc82a5e11554470",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d496013a253a068fe2f8c3a9f8a72efe298a790/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d496013a253a068fe2f8c3a9f8a72efe298a790/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=4d496013a253a068fe2f8c3a9f8a72efe298a790",
      "patch": "@@ -1,3 +1,9 @@\n+2021-02-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* testsuite/lib/binutils-common.exp: Whitespace fixes throughout.\n+\t(run_dump_test): Fail if expecting errors from a file like we do\n+\tfor error strings, if no error is seen.\n+\n 2021-02-19  Alan Modra  <amodra@gmail.com>\n \n \t* testsuite/binutils-all/readelf.exp (pr26548): Run for 32-bit too."
    },
    {
      "sha": "59e25df99b0a59e25fa34a78cf622dfe806a2172",
      "filename": "binutils/testsuite/lib/binutils-common.exp",
      "status": "modified",
      "additions": 343,
      "deletions": 343,
      "changes": 686,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d496013a253a068fe2f8c3a9f8a72efe298a790/binutils/testsuite/lib/binutils-common.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d496013a253a068fe2f8c3a9f8a72efe298a790/binutils/testsuite/lib/binutils-common.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/testsuite/lib/binutils-common.exp?ref=4d496013a253a068fe2f8c3a9f8a72efe298a790",
      "patch": "@@ -66,7 +66,7 @@ proc is_elf_format {} {\n     if { ![istarget *-*-netbsdelf*]\n \t && (   [istarget vax-*-netbsd*]\n \t     || [istarget ns32k-*-netbsd*]) } {\n-    \treturn 0\n+\treturn 0\n     }\n \n     if {    [istarget arm-*-openbsd*]\n@@ -221,7 +221,7 @@ proc supports_gnu_osabi {} {\n \treturn 1\n     }\n     if { [istarget \"wasm32*-*-*\"] } {\n-        return 1\n+\treturn 1\n     }\n     if { ![istarget \"*-*-elf*\"] } {\n \treturn 0\n@@ -966,8 +966,8 @@ proc run_dump_test { name {extra_options {}} } {\n \t    }\n \t    default {\n \t\tif { !$in_extra\n-                     && [string length $opts($opt_name)]\n-                     && $opt_name != \"as\" } {\n+\t\t     && [string length $opts($opt_name)]\n+\t\t     && $opt_name != \"as\" } {\n \t\t    perror \"option $opt_name multiply set in $file.d\"\n \t\t    unresolved $subdir/$name\n \t\t    return\n@@ -991,13 +991,13 @@ proc run_dump_test { name {extra_options {}} } {\n \t    error {\n \t\tappend opts($opt_name) $opt_val\n \t    }\n-            as {\n-                if { $in_extra } {\n-                    set as_additional_flags [concat $as_additional_flags $opt_val]\n-                } else {\n-                    lappend opts(as) $opt_val\n-                }\n-            }\n+\t    as {\n+\t\tif { $in_extra } {\n+\t\t    set as_additional_flags [concat $as_additional_flags $opt_val]\n+\t\t} else {\n+\t\t    lappend opts(as) $opt_val\n+\t\t}\n+\t    }\n \t    default {\n \t\tset opts($opt_name) [concat $opts($opt_name) $opt_val]\n \t    }\n@@ -1006,20 +1006,20 @@ proc run_dump_test { name {extra_options {}} } {\n \n     # Ensure there is something in $opts(as) for the foreach loop below.\n     if { [llength $opts(as)] == 0 } {\n-        set opts(as) [list \" \"]\n+\tset opts(as) [list \" \"]\n     }\n     foreach x $opts(as) {\n-        if { [string length $x] && [string length $as_additional_flags] } {\n-            append x \" \"\n-        }\n-        append x $as_additional_flags\n-        regsub {\\[big_or_little_endian\\]} $x \\\n-            [big_or_little_endian] x\n-        lappend as_final_flags $x\n+\tif { [string length $x] && [string length $as_additional_flags] } {\n+\t    append x \" \"\n+\t}\n+\tappend x $as_additional_flags\n+\tregsub {\\[big_or_little_endian\\]} $x \\\n+\t    [big_or_little_endian] x\n+\tlappend as_final_flags $x\n     }\n \n     regsub {\\[big_or_little_endian\\]} $opts(ld) \\\n-        [big_or_little_endian] opts(ld)\n+\t[big_or_little_endian] opts(ld)\n \n     if { $opts(name) == \"\" } {\n \tset testname \"$subdir/$name\"\n@@ -1159,7 +1159,7 @@ proc run_dump_test { name {extra_options {}} } {\n \t    regsub \"\\n$\" $comp_output \"\" comp_output\n \t    if { $cmdret != 0} {\n \t\tsend_log \"compilation of $cfile failed, exit status $cmdret with <$comp_output>\"\n-                # Should this be 'unresolved', or is that too silent?\n+\t\t# Should this be 'unresolved', or is that too silent?\n \t\tfail $testname\n \t\treturn 0\n \t    }\n@@ -1197,334 +1197,334 @@ proc run_dump_test { name {extra_options {}} } {\n     }\n \n     foreach as_flags $as_final_flags {\n-        # Assemble each file.\n-        set objfiles {}\n-        for { set i 0 } { $i < [llength $sourcefiles] } { incr i } {\n-            set sourcefile [lindex $sourcefiles $i]\n-            set sourceasflags [lindex $asflags $i]\n-            set run_objcopy_objects 0\n-\n-            if { [string match \"*RUN_OBJCOPY*\" $sourceasflags] } {\n-                set run_objcopy_objects 1\n-            }\n-            regsub \"RUN_OBJCOPY\" $sourceasflags \"\" sourceasflags\n-\n-            set objfile [lindex $objfile_names $i]\n-            catch \"exec rm -f $objfile\" exec_output\n-            lappend objfiles $objfile\n-\n-            if { $as_flags == \"binary\" } {\n-                while {[file type $sourcefile] eq \"link\"} {\n-                    set newfile [file readlink $sourcefile]\n-                    if {[string index $newfile 0] ne \"/\"} {\n-                        set newfile [file dirname $sourcefile]/$newfile\n-                    }\n-                    set sourcefile $newfile\n-                }\n-                set newfile [remote_download host $sourcefile $objfile]\n-                set cmdret 0\n-                if { $newfile == \"\" } {\n-                    set cmdret 1\n-                }\n-            } else {\n-                if { [istarget \"hppa*-*-*\"] \\\n-                         && ![istarget \"*-*-linux*\"] \\\n-                         && ![istarget \"*-*-netbsd*\" ] } {\n-                    set cmd \"sed -e 's/^\\[\t \\]*\\.comm \\\\(\\[^,\\]*\\\\),\\\\(.*\\\\)/\\\\1 .comm \\\\2/' < $sourcefile > tmpdir/asm.s\"\n-                    send_log \"$cmd\\n\"\n-                    set cmdret [remote_exec host [concat sh -c [list \"$cmd\"]]]\n-                    set cmdret [lindex $cmdret 0]\n-                    if { $cmdret != 0 } {\n-                        perror \"sed failure\"\n-                        unresolved $testname\n-                        continue\n-                    }\n-                    set sourcefile tmpdir/asm.s\n-                }\n-                set cmd \"$AS $ASFLAGS $as_flags $sourceasflags -o $objfile $sourcefile\"\n-\n-                send_log \"$cmd\\n\"\n-                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-                remote_upload host \"dump.tmp\"\n-                set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-                remote_file host delete \"dump.tmp\"\n-                remote_file build delete \"dump.tmp\"\n-                set cmdret [lindex $cmdret 0]\n-            }\n-            if { $cmdret == 0 && $run_objcopy_objects } {\n-                set cmd \"$OBJCOPY $opts(objcopy_objects) $objfile\"\n-\n-                send_log \"$cmd\\n\"\n-                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \\\n-                                \"\" \"/dev/null\" \"dump.tmp\"]\n-                remote_upload host \"dump.tmp\"\n-                append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-                remote_file host delete \"dump.tmp\"\n-                remote_file build delete \"dump.tmp\"\n-                set cmdret [lindex $cmdret 0]\n-            }\n-        }\n-\n-        # Perhaps link the file(s).\n-        if { $cmdret == 0 && $run_ld } {\n-            set objfile \"tmpdir/dump\"\n-            catch \"exec rm -f $objfile\" exec_output\n-\n-            set ld_extra_opt \"\"\n-            global ld\n-            set ld \"$LD\"\n+\t# Assemble each file.\n+\tset objfiles {}\n+\tfor { set i 0 } { $i < [llength $sourcefiles] } { incr i } {\n+\t    set sourcefile [lindex $sourcefiles $i]\n+\t    set sourceasflags [lindex $asflags $i]\n+\t    set run_objcopy_objects 0\n+\n+\t    if { [string match \"*RUN_OBJCOPY*\" $sourceasflags] } {\n+\t\tset run_objcopy_objects 1\n+\t    }\n+\t    regsub \"RUN_OBJCOPY\" $sourceasflags \"\" sourceasflags\n+\n+\t    set objfile [lindex $objfile_names $i]\n+\t    catch \"exec rm -f $objfile\" exec_output\n+\t    lappend objfiles $objfile\n+\n+\t    if { $as_flags == \"binary\" } {\n+\t\twhile {[file type $sourcefile] eq \"link\"} {\n+\t\t    set newfile [file readlink $sourcefile]\n+\t\t    if {[string index $newfile 0] ne \"/\"} {\n+\t\t\tset newfile [file dirname $sourcefile]/$newfile\n+\t\t    }\n+\t\t    set sourcefile $newfile\n+\t\t}\n+\t\tset newfile [remote_download host $sourcefile $objfile]\n+\t\tset cmdret 0\n+\t\tif { $newfile == \"\" } {\n+\t\t    set cmdret 1\n+\t\t}\n+\t    } else {\n+\t\tif { [istarget \"hppa*-*-*\"] \\\n+\t\t\t && ![istarget \"*-*-linux*\"] \\\n+\t\t\t && ![istarget \"*-*-netbsd*\" ] } {\n+\t\t    set cmd \"sed -e 's/^\\[\t \\]*\\.comm \\\\(\\[^,\\]*\\\\),\\\\(.*\\\\)/\\\\1 .comm \\\\2/' < $sourcefile > tmpdir/asm.s\"\n+\t\t    send_log \"$cmd\\n\"\n+\t\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd\"]]]\n+\t\t    set cmdret [lindex $cmdret 0]\n+\t\t    if { $cmdret != 0 } {\n+\t\t\tperror \"sed failure\"\n+\t\t\tunresolved $testname\n+\t\t\tcontinue\n+\t\t    }\n+\t\t    set sourcefile tmpdir/asm.s\n+\t\t}\n+\t\tset cmd \"$AS $ASFLAGS $as_flags $sourceasflags -o $objfile $sourcefile\"\n+\n+\t\tsend_log \"$cmd\\n\"\n+\t\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+\t\tremote_upload host \"dump.tmp\"\n+\t\tset comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+\t\tremote_file host delete \"dump.tmp\"\n+\t\tremote_file build delete \"dump.tmp\"\n+\t\tset cmdret [lindex $cmdret 0]\n+\t    }\n+\t    if { $cmdret == 0 && $run_objcopy_objects } {\n+\t\tset cmd \"$OBJCOPY $opts(objcopy_objects) $objfile\"\n+\n+\t\tsend_log \"$cmd\\n\"\n+\t\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \\\n+\t\t\t\t\"\" \"/dev/null\" \"dump.tmp\"]\n+\t\tremote_upload host \"dump.tmp\"\n+\t\tappend comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+\t\tremote_file host delete \"dump.tmp\"\n+\t\tremote_file build delete \"dump.tmp\"\n+\t\tset cmdret [lindex $cmdret 0]\n+\t    }\n+\t}\n+\n+\t# Perhaps link the file(s).\n+\tif { $cmdret == 0 && $run_ld } {\n+\t    set objfile \"tmpdir/dump\"\n+\t    catch \"exec rm -f $objfile\" exec_output\n+\n+\t    set ld_extra_opt \"\"\n+\t    global ld\n+\t    set ld \"$LD\"\n \t    if [check_relro_support] {\n \t\tset ld_extra_opt \"-z norelro\"\n \t    }\n \n-            # Add -L$srcdir/$subdir so that the linker command can use\n-            # linker scripts in the source directory.\n-            set cmd \"$LD $ld_extra_opt $LDFLAGS -L$srcdir/$subdir \\\n+\t    # Add -L$srcdir/$subdir so that the linker command can use\n+\t    # linker scripts in the source directory.\n+\t    set cmd \"$LD $ld_extra_opt $LDFLAGS -L$srcdir/$subdir \\\n \t\t   $opts(ld) -o $objfile $objfiles $opts(ld_after_inputfiles)\"\n \n-            # If needed then check for, or add a -Map option.\n-            set mapfile \"\"\n-            if { $opts(map) != \"\" } then {\n-                if { [regexp -- \"-Map=(\\[^ \\]+)\" $cmd all mapfile] } then {\n-                    # Found existing mapfile option\n-                    verbose -log \"Existing mapfile '$mapfile' found\"\n-                } else {\n-                    # No mapfile option.\n-                    set mapfile \"tmpdir/dump.map\"\n-                    verbose -log \"Adding mapfile '$mapfile'\"\n-                    set cmd \"$cmd -Map=$mapfile\"\n-                }\n-            }\n-\n-            send_log \"$cmd\\n\"\n-            set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-            remote_upload host \"dump.tmp\"\n-            append comp_output [file_contents \"dump.tmp\"]\n-            remote_file host delete \"dump.tmp\"\n-            remote_file build delete \"dump.tmp\"\n-            set cmdret [lindex $cmdret 0]\n-\n-            if { $cmdret == 0 && $run_objcopy } {\n-                set infile $objfile\n-                set objfile \"tmpdir/dump1\"\n-                remote_file host delete $objfile\n-\n-                # Note that we don't use OBJCOPYFLAGS here; any flags must be\n-                # explicitly specified.\n-                set cmd \"$OBJCOPY $opts(objcopy_linked_file) $infile $objfile\"\n-\n-                send_log \"$cmd\\n\"\n-                set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n-                remote_upload host \"dump.tmp\"\n-                append comp_output [file_contents \"dump.tmp\"]\n-                remote_file host delete \"dump.tmp\"\n-                remote_file build delete \"dump.tmp\"\n-                set cmdret [lindex $cmdret 0]\n-            }\n-        } else {\n-            set objfile [lindex $objfiles 0]\n-        }\n-\n-        if { $cmdret == 0 && $opts(PROG) != \"\" } {\n-            set destopt ${copyfile}.o\n-            switch -- $opts(PROG) {\n-                ar\t\t{ set program ar }\n-                elfedit\t{\n-                    set program elfedit\n-                    set destopt \"\"\n-                }\n-                nm\t\t{ set program nm }\n-                objcopy\t{ set program objcopy }\n-                ranlib\t{ set program ranlib }\n-                strings\t{ set program strings }\n-                strip\t{\n-                    set program strip\n-                    set destopt \"-o $destopt\"\n-                }\n-                default\t{\n-                    perror \"unrecognized PROG option $opts(PROG) in $file.d\"\n-                    unresolved $testname\n-                    continue\n-                }\n-            }\n-\n-            set progopts1 $opts($program)\n-            eval set progopts \\$[string toupper $program]FLAGS\n-            eval set binary \\$[string toupper $program]\n-\n-            if { ![is_remote host] && [which $binary] == 0 } {\n-                untested $testname\n-                continue\n-            }\n-\n-            verbose \"running $binary $progopts $progopts1\" 3\n-            set cmd \"$binary $progopts $progopts1 $objfile $destopt\"\n-\n-            # Ensure consistent sorting of symbols\n-            if {[info exists env(LC_ALL)]} {\n-                set old_lc_all $env(LC_ALL)\n-            }\n-            set env(LC_ALL) \"C\"\n-            send_log \"$cmd\\n\"\n-            set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n-            set cmdret [lindex $cmdret 0]\n-            remote_upload host \"dump.tmp\"\n-            append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-            remote_file host delete \"dump.tmp\"\n-            remote_file build delete \"dump.tmp\"\n-            if {[info exists old_lc_all]} {\n-                set env(LC_ALL) $old_lc_all\n-            } else {\n-                unset env(LC_ALL)\n-            }\n-            if { $destopt != \"\" } {\n-                set objfile ${copyfile}.o\n-            }\n-        }\n-\n-        set want_out(source) \"\"\n-        set want_out(terminal) 0\n-        if { $err_warn } {\n-            if { $opts(error) != \"\" || $opts(error_output) != \"\" } {\n-                set want_out(terminal) 1\n-            }\n-\n-            if { $opts(error) != \"\" || $opts(warning) != \"\" } {\n-                set want_out(source) \"regex\"\n-                if { $opts(error) != \"\" } {\n-                    set want_out(regex) $opts(error)\n-                } else {\n-                    set want_out(regex) $opts(warning)\n-                }\n-            } else {\n-                set want_out(source) \"file\"\n-                if { $opts(error_output) != \"\" } {\n-                    set want_out(file) $opts(error_output)\n-                } else {\n-                    set want_out(file) $opts(warning_output)\n-                }\n-            }\n-        }\n-\n-        regsub \"\\n$\" $comp_output \"\" comp_output\n-        if { $cmdret != 0 || $comp_output != \"\" || $want_out(source) != \"\" } {\n-            set exitstat \"succeeded\"\n-            if { $cmdret != 0 } { set exitstat \"failed\" }\n-\n-            if { $want_out(source) == \"regex\" } {\n-                verbose -log \"$exitstat with: <$comp_output>, expected: <$want_out(regex)>\"\n-            } elseif { $want_out(source) == \"file\" } {\n-                verbose -log \"$exitstat with: <$comp_output>, expected in file $want_out(file)\"\n-                set_file_contents \"tmpdir/ld.messages\" \"$comp_output\"\n-            } else {\n-                verbose -log \"$exitstat with: <$comp_output>, no expected output\"\n-            }\n-\n-            if { (($want_out(source) == \"\") == ($comp_output == \"\")) \\\n-                     && (($cmdret == 0) == ($want_out(terminal) == 0)) \\\n-                     && ((($want_out(source) == \"regex\") \\\n-                              && [regexp -- $want_out(regex) $comp_output]) \\\n-                             || (($want_out(source) == \"file\") \\\n-                                     && (![regexp_diff \"tmpdir/ld.messages\" \"$srcdir/$subdir/$want_out(file)\"]))) } {\n-                # We have the expected output.\n-                if { $want_out(terminal) || $dumpprogram == \"\" } {\n-                    pass $testname\n-                    continue\n-                }\n-            } else {\n-                fail $testname\n-                continue\n-            }\n-        }\n-\n-        # We must not have expected failure if we get here.\n-        if { $opts(error) != \"\" } {\n-            fail $testname\n-            continue\n-        }\n-\n-        if { $opts(map) != \"\" } then {\n-            # Check the map file matches.\n-            set map_pattern_file $srcdir/$subdir/$opts(map)\n-            verbose -log \"Compare '$mapfile' against '$map_pattern_file'\"\n-            if { [regexp_diff $mapfile $map_pattern_file] } then {\n-                fail \"$testname (map file check)\"\n-            } else {\n-                pass \"$testname (map file check)\"\n-            }\n-\n-            if { $dumpprogram == \"\" } then {\n-                continue\n-            }\n-        }\n-\n-        set progopts1 $opts($dumpprogram)\n-        eval set progopts \\$[string toupper $dumpprogram]FLAGS\n-        eval set binary \\$[string toupper $dumpprogram]\n-\n-        if { ![is_remote host] && [which $binary] == 0 } {\n-            untested $testname\n-            continue\n-        }\n-\n-        # For objdump of gas output, automatically translate standard section names\n-        set sect_names \"\"\n-        if { !$run_ld && $dumpprogram == \"objdump\" \\\n-                 && $opts(section_subst) != \"no\" \\\n-                 && ![string match \"*-b binary*\" $progopts1] } {\n-            set sect_names [get_standard_section_names]\n-            if { $sect_names != \"\"} {\n-                regsub -- \"\\\\.text\" $progopts1 \"[lindex $sect_names 0]\" progopts1\n-                regsub -- \"\\\\.data\" $progopts1 \"[lindex $sect_names 1]\" progopts1\n-                regsub -- \"\\\\.bss\"  $progopts1 \"[lindex $sect_names 2]\" progopts1\n-            }\n-        }\n-\n-        if { $progopts1 == \"\" } { set $progopts1 \"-r\" }\n-        verbose \"running $binary $progopts $progopts1\" 3\n-\n-        set cmd \"$binary $progopts $progopts1 $objfile > $dumpfile\"\n-\n-        # Ensure consistent sorting of symbols\n-        if {[info exists env(LC_ALL)]} {\n-            set old_lc_all $env(LC_ALL)\n-        }\n-        set env(LC_ALL) \"C\"\n-        send_log \"$cmd\\n\"\n-        set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n-        set cmdret [lindex $cmdret 0]\n-        remote_upload host \"dump.tmp\"\n-        set comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n-        remote_file host delete \"dump.tmp\"\n-        remote_file build delete \"dump.tmp\"\n-        if {[info exists old_lc_all]} {\n-            set env(LC_ALL) $old_lc_all\n-        } else {\n-            unset env(LC_ALL)\n-        }\n-        if { $cmdret != 0 || $comp_output != \"\" } {\n-            send_log \"exited abnormally with $cmdret, output:$comp_output\\n\"\n-            fail $testname\n-            continue\n-        }\n-\n-        if { $verbose > 2 } then { verbose \"output is [file_contents $dumpfile]\" 3 }\n-\n-        # Create the substition list for objdump output.\n-        set regexp_subst \"\"\n-        if { $sect_names != \"\" } {\n-            set regexp_subst [list \"\\\\\\\\?\\\\.text\" [lindex $sect_names 0] \\\n-                                  \"\\\\\\\\?\\\\.data\" [lindex $sect_names 1] \\\n-                                  \"\\\\\\\\?\\\\.bss\" [lindex $sect_names 2] ]\n-        }\n-\n-        if { [regexp_diff $dumpfile \"${dfile}\" $regexp_subst] } then {\n-            fail $testname\n-            if { $verbose == 2 } then { verbose \"output is [file_contents $dumpfile]\" 2 }\n-            continue\n-        }\n-\n-        pass $testname\n+\t    # If needed then check for, or add a -Map option.\n+\t    set mapfile \"\"\n+\t    if { $opts(map) != \"\" } then {\n+\t\tif { [regexp -- \"-Map=(\\[^ \\]+)\" $cmd all mapfile] } then {\n+\t\t    # Found existing mapfile option\n+\t\t    verbose -log \"Existing mapfile '$mapfile' found\"\n+\t\t} else {\n+\t\t    # No mapfile option.\n+\t\t    set mapfile \"tmpdir/dump.map\"\n+\t\t    verbose -log \"Adding mapfile '$mapfile'\"\n+\t\t    set cmd \"$cmd -Map=$mapfile\"\n+\t\t}\n+\t    }\n+\n+\t    send_log \"$cmd\\n\"\n+\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+\t    remote_upload host \"dump.tmp\"\n+\t    append comp_output [file_contents \"dump.tmp\"]\n+\t    remote_file host delete \"dump.tmp\"\n+\t    remote_file build delete \"dump.tmp\"\n+\t    set cmdret [lindex $cmdret 0]\n+\n+\t    if { $cmdret == 0 && $run_objcopy } {\n+\t\tset infile $objfile\n+\t\tset objfile \"tmpdir/dump1\"\n+\t\tremote_file host delete $objfile\n+\n+\t\t# Note that we don't use OBJCOPYFLAGS here; any flags must be\n+\t\t# explicitly specified.\n+\t\tset cmd \"$OBJCOPY $opts(objcopy_linked_file) $infile $objfile\"\n+\n+\t\tsend_log \"$cmd\\n\"\n+\t\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>&1\"]] \"\" \"/dev/null\" \"dump.tmp\"]\n+\t\tremote_upload host \"dump.tmp\"\n+\t\tappend comp_output [file_contents \"dump.tmp\"]\n+\t\tremote_file host delete \"dump.tmp\"\n+\t\tremote_file build delete \"dump.tmp\"\n+\t\tset cmdret [lindex $cmdret 0]\n+\t    }\n+\t} else {\n+\t    set objfile [lindex $objfiles 0]\n+\t}\n+\n+\tif { $cmdret == 0 && $opts(PROG) != \"\" } {\n+\t    set destopt ${copyfile}.o\n+\t    switch -- $opts(PROG) {\n+\t\tar\t{ set program ar }\n+\t\telfedit\t{\n+\t\t    set program elfedit\n+\t\t    set destopt \"\"\n+\t\t}\n+\t\tnm\t{ set program nm }\n+\t\tobjcopy\t{ set program objcopy }\n+\t\tranlib\t{ set program ranlib }\n+\t\tstrings\t{ set program strings }\n+\t\tstrip\t{\n+\t\t    set program strip\n+\t\t    set destopt \"-o $destopt\"\n+\t\t}\n+\t\tdefault\t{\n+\t\t    perror \"unrecognized PROG option $opts(PROG) in $file.d\"\n+\t\t    unresolved $testname\n+\t\t    continue\n+\t\t}\n+\t    }\n+\n+\t    set progopts1 $opts($program)\n+\t    eval set progopts \\$[string toupper $program]FLAGS\n+\t    eval set binary \\$[string toupper $program]\n+\n+\t    if { ![is_remote host] && [which $binary] == 0 } {\n+\t\tuntested $testname\n+\t\tcontinue\n+\t    }\n+\n+\t    verbose \"running $binary $progopts $progopts1\" 3\n+\t    set cmd \"$binary $progopts $progopts1 $objfile $destopt\"\n+\n+\t    # Ensure consistent sorting of symbols\n+\t    if {[info exists env(LC_ALL)]} {\n+\t\tset old_lc_all $env(LC_ALL)\n+\t    }\n+\t    set env(LC_ALL) \"C\"\n+\t    send_log \"$cmd\\n\"\n+\t    set cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n+\t    set cmdret [lindex $cmdret 0]\n+\t    remote_upload host \"dump.tmp\"\n+\t    append comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+\t    remote_file host delete \"dump.tmp\"\n+\t    remote_file build delete \"dump.tmp\"\n+\t    if {[info exists old_lc_all]} {\n+\t\tset env(LC_ALL) $old_lc_all\n+\t    } else {\n+\t\tunset env(LC_ALL)\n+\t    }\n+\t    if { $destopt != \"\" } {\n+\t\tset objfile ${copyfile}.o\n+\t    }\n+\t}\n+\n+\tset want_out(source) \"\"\n+\tset want_out(terminal) 0\n+\tif { $err_warn } {\n+\t    if { $opts(error) != \"\" || $opts(error_output) != \"\" } {\n+\t\tset want_out(terminal) 1\n+\t    }\n+\n+\t    if { $opts(error) != \"\" || $opts(warning) != \"\" } {\n+\t\tset want_out(source) \"regex\"\n+\t\tif { $opts(error) != \"\" } {\n+\t\t    set want_out(regex) $opts(error)\n+\t\t} else {\n+\t\t    set want_out(regex) $opts(warning)\n+\t\t}\n+\t    } else {\n+\t\tset want_out(source) \"file\"\n+\t\tif { $opts(error_output) != \"\" } {\n+\t\t    set want_out(file) $opts(error_output)\n+\t\t} else {\n+\t\t    set want_out(file) $opts(warning_output)\n+\t\t}\n+\t    }\n+\t}\n+\n+\tregsub \"\\n$\" $comp_output \"\" comp_output\n+\tif { $cmdret != 0 || $comp_output != \"\" || $want_out(source) != \"\" } {\n+\t    set exitstat \"succeeded\"\n+\t    if { $cmdret != 0 } { set exitstat \"failed\" }\n+\n+\t    if { $want_out(source) == \"regex\" } {\n+\t\tverbose -log \"$exitstat with: <$comp_output>, expected: <$want_out(regex)>\"\n+\t    } elseif { $want_out(source) == \"file\" } {\n+\t\tverbose -log \"$exitstat with: <$comp_output>, expected in file $want_out(file)\"\n+\t\tset_file_contents \"tmpdir/ld.messages\" \"$comp_output\"\n+\t    } else {\n+\t\tverbose -log \"$exitstat with: <$comp_output>, no expected output\"\n+\t    }\n+\n+\t    if { (($want_out(source) == \"\") == ($comp_output == \"\")) \\\n+\t\t     && (($cmdret == 0) == ($want_out(terminal) == 0)) \\\n+\t\t     && ((($want_out(source) == \"regex\") \\\n+\t\t\t      && [regexp -- $want_out(regex) $comp_output]) \\\n+\t\t\t     || (($want_out(source) == \"file\") \\\n+\t\t\t\t     && (![regexp_diff \"tmpdir/ld.messages\" \"$srcdir/$subdir/$want_out(file)\"]))) } {\n+\t\t# We have the expected output.\n+\t\tif { $want_out(terminal) || $dumpprogram == \"\" } {\n+\t\t    pass $testname\n+\t\t    continue\n+\t\t}\n+\t    } else {\n+\t\tfail $testname\n+\t\tcontinue\n+\t    }\n+\t}\n+\n+\t# We must not have expected failure if we get here.\n+\tif { $want_out(terminal) } {\n+\t    fail $testname\n+\t    continue\n+\t}\n+\n+\tif { $opts(map) != \"\" } then {\n+\t    # Check the map file matches.\n+\t    set map_pattern_file $srcdir/$subdir/$opts(map)\n+\t    verbose -log \"Compare '$mapfile' against '$map_pattern_file'\"\n+\t    if { [regexp_diff $mapfile $map_pattern_file] } then {\n+\t\tfail \"$testname (map file check)\"\n+\t    } else {\n+\t\tpass \"$testname (map file check)\"\n+\t    }\n+\n+\t    if { $dumpprogram == \"\" } then {\n+\t\tcontinue\n+\t    }\n+\t}\n+\n+\tset progopts1 $opts($dumpprogram)\n+\teval set progopts \\$[string toupper $dumpprogram]FLAGS\n+\teval set binary \\$[string toupper $dumpprogram]\n+\n+\tif { ![is_remote host] && [which $binary] == 0 } {\n+\t    untested $testname\n+\t    continue\n+\t}\n+\n+\t# For objdump of gas output, automatically translate standard section names\n+\tset sect_names \"\"\n+\tif { !$run_ld && $dumpprogram == \"objdump\" \\\n+\t\t && $opts(section_subst) != \"no\" \\\n+\t\t && ![string match \"*-b binary*\" $progopts1] } {\n+\t    set sect_names [get_standard_section_names]\n+\t    if { $sect_names != \"\"} {\n+\t\tregsub -- \"\\\\.text\" $progopts1 \"[lindex $sect_names 0]\" progopts1\n+\t\tregsub -- \"\\\\.data\" $progopts1 \"[lindex $sect_names 1]\" progopts1\n+\t\tregsub -- \"\\\\.bss\"  $progopts1 \"[lindex $sect_names 2]\" progopts1\n+\t    }\n+\t}\n+\n+\tif { $progopts1 == \"\" } { set $progopts1 \"-r\" }\n+\tverbose \"running $binary $progopts $progopts1\" 3\n+\n+\tset cmd \"$binary $progopts $progopts1 $objfile > $dumpfile\"\n+\n+\t# Ensure consistent sorting of symbols\n+\tif {[info exists env(LC_ALL)]} {\n+\t    set old_lc_all $env(LC_ALL)\n+\t}\n+\tset env(LC_ALL) \"C\"\n+\tsend_log \"$cmd\\n\"\n+\tset cmdret [remote_exec host [concat sh -c [list \"$cmd 2>dump.tmp\"]] \"\" \"/dev/null\"]\n+\tset cmdret [lindex $cmdret 0]\n+\tremote_upload host \"dump.tmp\"\n+\tset comp_output [prune_warnings [file_contents \"dump.tmp\"]]\n+\tremote_file host delete \"dump.tmp\"\n+\tremote_file build delete \"dump.tmp\"\n+\tif {[info exists old_lc_all]} {\n+\t    set env(LC_ALL) $old_lc_all\n+\t} else {\n+\t    unset env(LC_ALL)\n+\t}\n+\tif { $cmdret != 0 || $comp_output != \"\" } {\n+\t    send_log \"exited abnormally with $cmdret, output:$comp_output\\n\"\n+\t    fail $testname\n+\t    continue\n+\t}\n+\n+\tif { $verbose > 2 } then { verbose \"output is [file_contents $dumpfile]\" 3 }\n+\n+\t# Create the substition list for objdump output.\n+\tset regexp_subst \"\"\n+\tif { $sect_names != \"\" } {\n+\t    set regexp_subst [list \"\\\\\\\\?\\\\.text\" [lindex $sect_names 0] \\\n+\t\t\t\t  \"\\\\\\\\?\\\\.data\" [lindex $sect_names 1] \\\n+\t\t\t\t  \"\\\\\\\\?\\\\.bss\" [lindex $sect_names 2] ]\n+\t}\n+\n+\tif { [regexp_diff $dumpfile \"${dfile}\" $regexp_subst] } then {\n+\t    fail $testname\n+\t    if { $verbose == 2 } then { verbose \"output is [file_contents $dumpfile]\" 2 }\n+\t    continue\n+\t}\n+\n+\tpass $testname\n     }\n }\n "
    }
  ]
}