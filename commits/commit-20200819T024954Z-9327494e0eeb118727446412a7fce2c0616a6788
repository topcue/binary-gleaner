{
  "sha": "9327494e0eeb118727446412a7fce2c0616a6788",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTMyNzQ5NGUwZWViMTE4NzI3NDQ2NDEyYTdmY2UyYzA2MTZhNjc4OA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-19T02:49:54Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-19T02:49:54Z"
    },
    "message": "gdb: add linux_nat_debug_printf macro\n\nThe debug prints inside linux-nat.c almost all have a prefix that\nindicate in which function they are located.  This prefix is an\nabbreviation of the function name.  For example, this print is in the\n`linux_nat_post_attach_wait` function:\n\n    if (debug_linux_nat)\n      fprintf_unfiltered (gdb_stdlog,\n                          \"LNPAW: Attaching to a stopped process\\n\");\n\nOver time, the code has changed, things were moved, and many of these\nprefixes are not accurate anymore.  Also, unless you know the\nlinux-nat.c file by heart, it's a bit cryptic what LLR, LNW, RSRL, etc,\nall mean.\n\nTo address both of these issues, I suggest adding this macro for\nprinting debug statements, which automatically includes the function\nname.  It also includes the `[linux-nat]` prefix to clarify which part\nof GDB printed this (I think that, ideally, all debug prints would\ninclude such a tag).\n\nThe `__func__` magic symbol is used to get the function name.\nUnfortunately, in the case of methods, it only contains the method name,\nnot the class name.  So we'll get \"wait\", where I would have liked to\nget \"linux_nat_target::wait\".  But at least with the `[linux-nat]` tag\nin the front, it's not really ambiguous.\n\nI've made the macro automatically include the trailing newline, because\nit wouldn't make sense to call it twice to print two parts of one line,\nthe `[linux-nat]` tag would be printed in the middle.\n\nAn advantage of this (IMO) is that it's less verbose, we don't have to\ncheck for `if (debug_linux_nat)` everywhere.\n\nAnother advantage is that it's easier to customize the output later,\nwithout having to touch all call sites.\n\nHere's an example of what it looks like in the end:\n\n    [linux-nat] linux_nat_wait_1: enter\n    [linux-nat] wait: [process -1], [TARGET_WNOHANG]\n\ngdb/ChangeLog:\n\n\t* linux-nat.c (linux_nat_debug_printf): New function.\n\t(linux_nat_debug_printf_1): New macro.  Use throughout the file.\n\nChange-Id: Ifcea3255b91400d3ad093cd0b75d3fac241cb998",
    "tree": {
      "sha": "6299733f5c59d9ff08ac75e3c01e20a1be2ad898",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6299733f5c59d9ff08ac75e3c01e20a1be2ad898"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9327494e0eeb118727446412a7fce2c0616a6788",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9327494e0eeb118727446412a7fce2c0616a6788",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9327494e0eeb118727446412a7fce2c0616a6788",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9327494e0eeb118727446412a7fce2c0616a6788/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6cdb985c455d12dccaf0ea9d37298865b9d47d4f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6cdb985c455d12dccaf0ea9d37298865b9d47d4f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6cdb985c455d12dccaf0ea9d37298865b9d47d4f"
    }
  ],
  "stats": {
    "total": 624,
    "additions": 231,
    "deletions": 393
  },
  "files": [
    {
      "sha": "cd950287ec23b2263bec48ca7249925c20887fcf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9327494e0eeb118727446412a7fce2c0616a6788/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9327494e0eeb118727446412a7fce2c0616a6788/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9327494e0eeb118727446412a7fce2c0616a6788",
      "patch": "@@ -1,3 +1,8 @@\n+2020-08-18  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* linux-nat.c (linux_nat_debug_printf): New function.\n+\t(linux_nat_debug_printf_1): New macro.  Use throughout the file.\n+\n 2020-08-18  Aaron Merey  <amerey@redhat.com>\n \n \t* Makefile.in (DEBUGINFOD_CFLAGS, DEBUGINFOD_LIBS): New variables."
    },
    {
      "sha": "7a4387ff8452b5225e04933d92f87939cc035005",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 226,
      "deletions": 393,
      "changes": 619,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9327494e0eeb118727446412a7fce2c0616a6788/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9327494e0eeb118727446412a7fce2c0616a6788/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=9327494e0eeb118727446412a7fce2c0616a6788",
      "patch": "@@ -198,6 +198,27 @@ show_debug_linux_nat (struct ui_file *file, int from_tty,\n \t\t    value);\n }\n \n+/* Print a debug statement.  Should be used through linux_nat_debug_printf.  */\n+\n+static void ATTRIBUTE_PRINTF (2, 3)\n+linux_nat_debug_printf_1 (const char *func_name, const char *fmt, ...)\n+{\n+  debug_printf (\"[linux-nat] %s: \", func_name);\n+\n+  va_list ap;\n+  va_start (ap, fmt);\n+  debug_vprintf (fmt, ap);\n+  va_end (ap);\n+\n+  debug_printf (\"\\n\");\n+}\n+\n+#define linux_nat_debug_printf(fmt, ...) \\\n+  do { \\\n+    if (debug_linux_nat) \\\n+      linux_nat_debug_printf_1 (__func__, fmt, ##__VA_ARGS__); \\\n+  } while (0)\n+\n struct simple_pid_list\n {\n   int pid;\n@@ -535,10 +556,8 @@ linux_nat_target::follow_fork (bool follow_child, bool detach_fork)\n \n \t  if (linux_supports_tracevforkdone ())\n \t    {\n-  \t      if (debug_linux_nat)\n-  \t\tfprintf_unfiltered (gdb_stdlog,\n-  \t\t\t\t    \"LCFF: waiting for VFORK_DONE on %d\\n\",\n-  \t\t\t\t    parent_pid);\n+\t      linux_nat_debug_printf (\"waiting for VFORK_DONE on %d\",\n+\t\t\t\t      parent_pid);\n \t      parent_lp->stopped = 1;\n \n \t      /* We'll handle the VFORK_DONE event like any other\n@@ -577,10 +596,7 @@ linux_nat_target::follow_fork (bool follow_child, bool detach_fork)\n \t\t is only the single-step breakpoint at vfork's return\n \t\t point.  */\n \n-  \t      if (debug_linux_nat)\n-  \t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"LCFF: no VFORK_DONE \"\n-\t\t\t\t    \"support, sleeping a bit\\n\");\n+\t      linux_nat_debug_printf (\"no VFORK_DONE support, sleeping a bit\");\n \n \t      usleep (10000);\n \n@@ -1030,9 +1046,7 @@ linux_nat_post_attach_wait (ptid_t ptid, int *signalled)\n \n   if (linux_proc_pid_is_stopped (pid))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LNPAW: Attaching to a stopped process\\n\");\n+      linux_nat_debug_printf (\"Attaching to a stopped process\");\n \n       /* The process is definitely stopped.  It is in a job control\n \t stop, unless the kernel predates the TASK_STOPPED /\n@@ -1063,19 +1077,16 @@ linux_nat_post_attach_wait (ptid_t ptid, int *signalled)\n   if (!WIFSTOPPED (status))\n     {\n       /* The pid we tried to attach has apparently just exited.  */\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog, \"LNPAW: Failed to stop %d: %s\",\n-\t\t\t    pid, status_to_str (status));\n+      linux_nat_debug_printf (\"Failed to stop %d: %s\", pid,\n+\t\t\t      status_to_str (status));\n       return status;\n     }\n \n   if (WSTOPSIG (status) != SIGSTOP)\n     {\n       *signalled = 1;\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LNPAW: Received %s after attaching\\n\",\n-\t\t\t    status_to_str (status));\n+      linux_nat_debug_printf (\"Received %s after attaching\",\n+\t\t\t      status_to_str (status));\n     }\n \n   return status;\n@@ -1125,13 +1136,10 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t  if (err == ESRCH\n \t      || (err == EPERM && linux_proc_pid_is_gone (lwpid)))\n \t    {\n-\t      if (debug_linux_nat)\n-\t\t{\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"Cannot attach to lwp %d: \"\n-\t\t\t\t      \"thread is gone (%d: %s)\\n\",\n-\t\t\t\t      lwpid, err, safe_strerror (err));\n-\t\t}\n+\t      linux_nat_debug_printf\n+\t\t(\"Cannot attach to lwp %d: thread is gone (%d: %s)\",\n+\t\t lwpid, err, safe_strerror (err));\n+\n \t    }\n \t  else\n \t    {\n@@ -1144,10 +1152,8 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n \t}\n       else\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"PTRACE_ATTACH %s, 0, 0 (OK)\\n\",\n-\t\t\t\ttarget_pid_to_str (ptid).c_str ());\n+\t  linux_nat_debug_printf (\"PTRACE_ATTACH %s, 0, 0 (OK)\",\n+\t\t\t\t  target_pid_to_str (ptid).c_str ());\n \n \t  lp = add_lwp (ptid);\n \n@@ -1249,10 +1255,8 @@ linux_nat_target::attach (const char *args, int from_tty)\n \n   /* Save the wait status to report later.  */\n   lp->resumed = 1;\n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"LNA: waitpid %ld, saving status %s\\n\",\n-\t\t\t(long) lp->ptid.pid (), status_to_str (status));\n+  linux_nat_debug_printf (\"waitpid %ld, saving status %s\",\n+\t\t\t  (long) lp->ptid.pid (), status_to_str (status));\n \n   lp->status = status;\n \n@@ -1331,27 +1335,20 @@ get_detach_signal (struct lwp_info *lp)\n \n   if (signo == GDB_SIGNAL_0)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"GPT: lwp %s has no pending signal\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"lwp %s has no pending signal\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (!signal_pass_state (signo))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"GPT: lwp %s had signal %s, \"\n-\t\t\t    \"but it is in no pass state\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n-\t\t\t    gdb_signal_to_string (signo));\n+      linux_nat_debug_printf\n+\t(\"lwp %s had signal %s but it is in no pass state\",\n+\t target_pid_to_str (lp->ptid).c_str (), gdb_signal_to_string (signo));\n     }\n   else\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"GPT: lwp %s has pending signal %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n-\t\t\t    gdb_signal_to_string (signo));\n+      linux_nat_debug_printf (\"lwp %s has pending signal %s\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t      gdb_signal_to_string (signo));\n \n       return gdb_signal_to_host (signo);\n     }\n@@ -1371,18 +1368,16 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n \n   gdb_assert (lp->status == 0 || WIFSTOPPED (lp->status));\n \n-  if (debug_linux_nat && lp->status)\n-    fprintf_unfiltered (gdb_stdlog, \"DC:  Pending %s for %s on detach.\\n\",\n-\t\t\tstrsignal (WSTOPSIG (lp->status)),\n-\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+  if (lp->status != 0)\n+    linux_nat_debug_printf (\"Pending %s for %s on detach.\",\n+\t\t\t    strsignal (WSTOPSIG (lp->status)),\n+\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n \n   /* If there is a pending SIGSTOP, get rid of it.  */\n   if (lp->signalled)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"DC: Sending SIGCONT to %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"Sending SIGCONT to %s\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n \n       kill_lwp (lwpid, SIGCONT);\n       lp->signalled = 0;\n@@ -1441,13 +1436,10 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n \t\t safe_strerror (save_errno));\n \t}\n     }\n-  else if (debug_linux_nat)\n-    {\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"PTRACE_DETACH (%s, %s, 0) (OK)\\n\",\n-\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n-\t\t\t  strsignal (signo));\n-    }\n+  else\n+    linux_nat_debug_printf (\"PTRACE_DETACH (%s, %s, 0) (OK)\",\n+\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t    strsignal (signo));\n \n   delete_lwp (lp->ptid);\n }\n@@ -1603,39 +1595,29 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n \n       if (inf->vfork_child != NULL)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"RC: Not resuming %s (vfork parent)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Not resuming %s (vfork parent)\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t}\n       else if (!lwp_status_pending_p (lp))\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"RC: Resuming sibling %s, %s, %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\t(signo != GDB_SIGNAL_0\n-\t\t\t\t ? strsignal (gdb_signal_to_host (signo))\n-\t\t\t\t : \"0\"),\n-\t\t\t\tstep ? \"step\" : \"resume\");\n+\t  linux_nat_debug_printf (\"Resuming sibling %s, %s, %s\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  (signo != GDB_SIGNAL_0\n+\t\t\t\t   ? strsignal (gdb_signal_to_host (signo))\n+\t\t\t\t   : \"0\"),\n+\t\t\t\t  step ? \"step\" : \"resume\");\n \n \t  linux_resume_one_lwp (lp, step, signo);\n \t}\n       else\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"RC: Not resuming sibling %s (has pending)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Not resuming sibling %s (has pending)\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t}\n     }\n   else\n-    {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"RC: Not resuming sibling %s (not stopped)\\n\",\n+    linux_nat_debug_printf (\"Not resuming sibling %s (not stopped)\",\n \t\t\t    target_pid_to_str (lp->ptid).c_str ());\n-    }\n }\n \n /* Callback for iterate_over_lwps.  If LWP is EXCEPT, do nothing.\n@@ -1687,14 +1669,12 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n   struct lwp_info *lp;\n   int resume_many;\n \n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"LLR: Preparing to %s %s, %s, inferior_ptid %s\\n\",\n-\t\t\tstep ? \"step\" : \"resume\",\n-\t\t\ttarget_pid_to_str (ptid).c_str (),\n-\t\t\t(signo != GDB_SIGNAL_0\n-\t\t\t ? strsignal (gdb_signal_to_host (signo)) : \"0\"),\n-\t\t\ttarget_pid_to_str (inferior_ptid).c_str ());\n+  linux_nat_debug_printf (\"Preparing to %s %s, %s, inferior_ptid %s\",\n+\t\t\t  step ? \"step\" : \"resume\",\n+\t\t\t  target_pid_to_str (ptid).c_str (),\n+\t\t\t  (signo != GDB_SIGNAL_0\n+\t\t\t   ? strsignal (gdb_signal_to_host (signo)) : \"0\"),\n+\t\t\t  target_pid_to_str (inferior_ptid).c_str ());\n \n   /* A specific PTID means `step only this process id'.  */\n   resume_many = (minus_one_ptid == ptid\n@@ -1729,10 +1709,8 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t  && WSTOPSIG (lp->status)\n \t  && sigismember (&pass_mask, WSTOPSIG (lp->status)))\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LLR: Not short circuiting for ignored \"\n-\t\t\t\t\"status 0x%x\\n\", lp->status);\n+\t  linux_nat_debug_printf\n+\t    (\"Not short circuiting for ignored status 0x%x\", lp->status);\n \n \t  /* FIXME: What should we do if we are supposed to continue\n \t     this thread with a signal?  */\n@@ -1748,10 +1726,8 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t this thread with a signal?  */\n       gdb_assert (signo == GDB_SIGNAL_0);\n \n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLR: Short circuiting for status 0x%x\\n\",\n-\t\t\t    lp->status);\n+      linux_nat_debug_printf (\"Short circuiting for status 0x%x\",\n+\t\t\t      lp->status);\n \n       if (target_can_async_p ())\n \t{\n@@ -1768,13 +1744,11 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t\t\t       return linux_nat_resume_callback (info, lp);\n \t\t\t     });\n \n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"LLR: %s %s, %s (resume event thread)\\n\",\n-\t\t\tstep ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t(signo != GDB_SIGNAL_0\n-\t\t\t ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n+  linux_nat_debug_printf (\"%s %s, %s (resume event thread)\",\n+\t\t\t  step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n+\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t  (signo != GDB_SIGNAL_0\n+\t\t\t   ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \n   linux_resume_one_lwp (lp, step, signo);\n \n@@ -1836,13 +1810,9 @@ linux_handle_syscall_trap (struct lwp_info *lp, int stopping)\n \t actually get to execute.  It seems it would be even more\n \t confusing to the user.  */\n \n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHST: ignoring syscall %d \"\n-\t\t\t    \"for LWP %ld (stopping threads), \"\n-\t\t\t    \"resuming with PTRACE_CONT for SIGSTOP\\n\",\n-\t\t\t    syscall_number,\n-\t\t\t    lp->ptid.lwp ());\n+      linux_nat_debug_printf\n+\t(\"ignoring syscall %d for LWP %ld (stopping threads), resuming with \"\n+\t \"PTRACE_CONT for SIGSTOP\", syscall_number, lp->ptid.lwp ());\n \n       lp->syscall_state = TARGET_WAITKIND_IGNORE;\n       ptrace (PTRACE_CONT, lp->ptid.lwp (), 0, 0);\n@@ -1867,26 +1837,18 @@ linux_handle_syscall_trap (struct lwp_info *lp, int stopping)\n \t  ourstatus->kind = lp->syscall_state;\n \t  ourstatus->value.syscall_number = syscall_number;\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LHST: stopping for %s of syscall %d\"\n-\t\t\t\t\" for LWP %ld\\n\",\n-\t\t\t\tlp->syscall_state\n-\t\t\t\t== TARGET_WAITKIND_SYSCALL_ENTRY\n-\t\t\t\t? \"entry\" : \"return\",\n-\t\t\t\tsyscall_number,\n-\t\t\t\tlp->ptid.lwp ());\n+\t  linux_nat_debug_printf\n+\t    (\"stopping for %s of syscall %d for LWP %ld\",\n+\t     (lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t      ? \"entry\" : \"return\"), syscall_number, lp->ptid.lwp ());\n+\n \t  return 0;\n \t}\n \n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHST: ignoring %s of syscall %d \"\n-\t\t\t    \"for LWP %ld\\n\",\n-\t\t\t    lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY\n-\t\t\t    ? \"entry\" : \"return\",\n-\t\t\t    syscall_number,\n-\t\t\t    lp->ptid.lwp ());\n+      linux_nat_debug_printf\n+\t(\"ignoring %s of syscall %d for LWP %ld\",\n+\t (lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t  ? \"entry\" : \"return\"), syscall_number, lp->ptid.lwp ());\n     }\n   else\n     {\n@@ -1906,13 +1868,9 @@ linux_handle_syscall_trap (struct lwp_info *lp, int stopping)\n \n \t The points above mean that the next resume, be it PT_STEP or\n \t PT_CONTINUE, can not trigger a syscall trace event.  */\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHST: caught syscall event \"\n-\t\t\t    \"with no syscall catchpoints.\"\n-\t\t\t    \" %d for LWP %ld, ignoring\\n\",\n-\t\t\t    syscall_number,\n-\t\t\t    lp->ptid.lwp ());\n+      linux_nat_debug_printf\n+\t(\"caught syscall event with no syscall catchpoints. %d for LWP %ld, \"\n+\t \"ignoring\", syscall_number, lp->ptid.lwp ());\n       lp->syscall_state = TARGET_WAITKIND_IGNORE;\n     }\n \n@@ -2017,11 +1975,8 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \n \t  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LHEW: Got clone event \"\n-\t\t\t\t\"from LWP %d, new child is LWP %ld\\n\",\n-\t\t\t\tpid, new_pid);\n+\t  linux_nat_debug_printf\n+\t    (\"Got clone event from LWP %d, new child is LWP %ld\", pid, new_pid);\n \n \t  new_lp = add_lwp (ptid_t (lp->ptid.pid (), new_pid, 0));\n \t  new_lp->stopped = 1;\n@@ -2060,12 +2015,9 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t      gdb_assert (new_lp->status == 0);\n \n \t      /* Save the wait status to report later.  */\n-\t      if (debug_linux_nat)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"LHEW: waitpid of new LWP %ld, \"\n-\t\t\t\t    \"saving status %s\\n\",\n-\t\t\t\t    (long) new_lp->ptid.lwp (),\n-\t\t\t\t    status_to_str (status));\n+\t      linux_nat_debug_printf\n+\t\t(\"waitpid of new LWP %ld, saving status %s\",\n+\t\t (long) new_lp->ptid.lwp (), status_to_str (status));\n \t      new_lp->status = status;\n \t    }\n \t  else if (report_thread_events)\n@@ -2082,10 +2034,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \n   if (event == PTRACE_EVENT_EXEC)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHEW: Got exec event from LWP %ld\\n\",\n-\t\t\t    lp->ptid.lwp ());\n+      linux_nat_debug_printf (\"Got exec event from LWP %ld\", lp->ptid.lwp ());\n \n       ourstatus->kind = TARGET_WAITKIND_EXECD;\n       ourstatus->value.execd_pathname\n@@ -2102,21 +2051,17 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n     {\n       if (current_inferior ()->waiting_for_vfork_done)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LHEW: Got expected PTRACE_EVENT_\"\n-\t\t\t\t\"VFORK_DONE from LWP %ld: stopping\\n\",\n-\t\t\t\tlp->ptid.lwp ());\n+\t  linux_nat_debug_printf\n+\t    (\"Got expected PTRACE_EVENT_VFORK_DONE from LWP %ld: stopping\",\n+\t     lp->ptid.lwp ());\n \n \t  ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;\n \t  return 0;\n \t}\n \n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHEW: Got PTRACE_EVENT_VFORK_DONE \"\n-\t\t\t    \"from LWP %ld: ignoring\\n\",\n-\t\t\t    lp->ptid.lwp ());\n+      linux_nat_debug_printf\n+\t(\"Got PTRACE_EVENT_VFORK_DONE from LWP %ld: ignoring\", lp->ptid.lwp ());\n+\n       return 1;\n     }\n \n@@ -2130,8 +2075,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n static void\n wait_for_signal ()\n {\n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog, \"linux-nat: about to sigsuspend\\n\");\n+  linux_nat_debug_printf (\"about to sigsuspend\");\n   sigsuspend (&suspend_mask);\n \n   /* If the quit flag is set, it means that the user pressed Ctrl-C\n@@ -2175,9 +2119,8 @@ wait_lwp (struct lwp_info *lp)\n \t     won't get an exit event.  See comments on exec events at\n \t     the top of the file.  */\n \t  thread_dead = 1;\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog, \"WL: %s vanished.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"%s vanished.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t}\n       if (pid != 0)\n \tbreak;\n@@ -2200,10 +2143,8 @@ wait_lwp (struct lwp_info *lp)\n \t  && linux_proc_pid_is_zombie (lp->ptid.lwp ()))\n \t{\n \t  thread_dead = 1;\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"WL: Thread group leader %s vanished.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Thread group leader %s vanished.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t  break;\n \t}\n \n@@ -2222,23 +2163,17 @@ wait_lwp (struct lwp_info *lp)\n     {\n       gdb_assert (pid == lp->ptid.lwp ());\n \n-      if (debug_linux_nat)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"WL: waitpid %s received %s\\n\",\n+      linux_nat_debug_printf (\"waitpid %s received %s\",\n \t\t\t      target_pid_to_str (lp->ptid).c_str (),\n \t\t\t      status_to_str (status));\n-\t}\n \n       /* Check if the thread has exited.  */\n       if (WIFEXITED (status) || WIFSIGNALED (status))\n \t{\n \t  if (report_thread_events\n \t      || lp->ptid.pid () == lp->ptid.lwp ())\n \t    {\n-\t      if (debug_linux_nat)\n-\t\tfprintf_unfiltered (gdb_stdlog, \"WL: LWP %d exited.\\n\",\n-\t\t\t\t    lp->ptid.pid ());\n+\t      linux_nat_debug_printf (\"LWP %d exited.\", lp->ptid.pid ());\n \n \t      /* If this is the leader exiting, it means the whole\n \t\t process is gone.  Store the status to report to the\n@@ -2249,9 +2184,8 @@ wait_lwp (struct lwp_info *lp)\n \t    }\n \n \t  thread_dead = 1;\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog, \"WL: %s exited.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"%s exited.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t}\n     }\n \n@@ -2295,10 +2229,7 @@ wait_lwp (struct lwp_info *lp)\n   if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP\n       && linux_is_extended_waitstatus (status))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"WL: Handling extended status 0x%06x\\n\",\n-\t\t\t    status);\n+      linux_nat_debug_printf (\"Handling extended status 0x%06x\", status);\n       linux_handle_extended_wait (lp, status);\n       return 0;\n     }\n@@ -2315,21 +2246,13 @@ stop_callback (struct lwp_info *lp)\n     {\n       int ret;\n \n-      if (debug_linux_nat)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"SC:  kill %s **<SIGSTOP>**\\n\",\n+      linux_nat_debug_printf (\"kill %s **<SIGSTOP>**\",\n \t\t\t      target_pid_to_str (lp->ptid).c_str ());\n-\t}\n+\n       errno = 0;\n       ret = kill_lwp (lp->ptid.lwp (), SIGSTOP);\n-      if (debug_linux_nat)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"SC:  lwp kill %d %s\\n\",\n-\t\t\t      ret,\n+      linux_nat_debug_printf (\"lwp kill %d %s\", ret,\n \t\t\t      errno ? safe_strerror (errno) : \"ERRNO-OK\");\n-\t}\n \n       lp->signalled = 1;\n       gdb_assert (lp->status == 0);\n@@ -2417,10 +2340,8 @@ maybe_clear_ignore_sigint (struct lwp_info *lp)\n \n   if (!linux_nat_has_pending_sigint (lp->ptid.lwp ()))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"MCIS: Clearing bogus flag for %s\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"Clearing bogus flag for %s\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n       lp->ignore_sigint = 0;\n     }\n }\n@@ -2516,12 +2437,10 @@ stop_wait_callback (struct lwp_info *lp)\n \t  errno = 0;\n \t  ptrace (PTRACE_CONT, lp->ptid.lwp (), 0, 0);\n \t  lp->stopped = 0;\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"PTRACE_CONT %s, 0, 0 (%s) \"\n-\t\t\t\t\"(discarding SIGINT)\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\terrno ? safe_strerror (errno) : \"OK\");\n+\t  linux_nat_debug_printf\n+\t    (\"PTRACE_CONT %s, 0, 0 (%s) (discarding SIGINT)\",\n+\t     target_pid_to_str (lp->ptid).c_str (),\n+\t     errno ? safe_strerror (errno) : \"OK\");\n \n \t  return stop_wait_callback (lp);\n \t}\n@@ -2532,11 +2451,9 @@ stop_wait_callback (struct lwp_info *lp)\n \t{\n \t  /* The thread was stopped with a signal other than SIGSTOP.  */\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SWC: Pending event %s in %s\\n\",\n-\t\t\t\tstatus_to_str ((int) status),\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Pending event %s in %s\",\n+\t\t\t\t  status_to_str ((int) status),\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \n \t  /* Save the sigtrap event.  */\n \t  lp->status = status;\n@@ -2547,10 +2464,8 @@ stop_wait_callback (struct lwp_info *lp)\n \t{\n \t  /* We caught the SIGSTOP that we intended to catch.  */\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SWC: Expected SIGSTOP caught for %s.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Expected SIGSTOP caught for %s.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \n \t  lp->signalled = 0;\n \n@@ -2594,34 +2509,28 @@ status_callback (struct lwp_info *lp)\n \n       if (pc != lp->stop_pc)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SC: PC of %s changed.  was=%s, now=%s\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\tpaddress (target_gdbarch (), lp->stop_pc),\n-\t\t\t\tpaddress (target_gdbarch (), pc));\n+\t  linux_nat_debug_printf (\"PC of %s changed.  was=%s, now=%s\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  paddress (target_gdbarch (), lp->stop_pc),\n+\t\t\t\t  paddress (target_gdbarch (), pc));\n \t  discard = 1;\n \t}\n \n #if !USE_SIGTRAP_SIGINFO\n       else if (!breakpoint_inserted_here_p (regcache->aspace (), pc))\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SC: previous breakpoint of %s, at %s gone\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\tpaddress (target_gdbarch (), lp->stop_pc));\n+\t  linux_nat_debug_printf (\"previous breakpoint of %s, at %s gone\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  paddress (target_gdbarch (), lp->stop_pc));\n \n \t  discard = 1;\n \t}\n #endif\n \n       if (discard)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SC: pending event of %s cancelled.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"pending event of %s cancelled.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \n \t  lp->status = 0;\n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n@@ -2744,10 +2653,8 @@ save_stop_reason (struct lwp_info *lp)\n \t    }\n \t  else if (siginfo.si_code == TRAP_TRACE)\n \t    {\n-\t      if (debug_linux_nat)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"CSBB: %s stopped by trace\\n\",\n-\t\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+\t      linux_nat_debug_printf (\"%s stopped by trace\",\n+\t\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n \n \t      /* We may have single stepped an instruction that\n \t\t triggered a watchpoint.  In that case, on some\n@@ -2777,10 +2684,8 @@ save_stop_reason (struct lwp_info *lp)\n \n   if (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"CSBB: %s stopped by software breakpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"%s stopped by software breakpoint\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n \n       /* Back up the PC if necessary.  */\n       if (pc != sw_bp_pc)\n@@ -2791,17 +2696,13 @@ save_stop_reason (struct lwp_info *lp)\n     }\n   else if (lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"CSBB: %s stopped by hardware breakpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"%s stopped by hardware breakpoint\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (lp->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"CSBB: %s stopped by hardware watchpoint\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"%s stopped by hardware watchpoint\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   lp->stop_pc = pc;\n@@ -2875,10 +2776,8 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n       event_lp = iterate_over_lwps (filter, select_singlestep_lwp_callback);\n       if (event_lp != NULL)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"SEL: Select single-step %s\\n\",\n-\t\t\t\ttarget_pid_to_str (event_lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"Select single-step %s\",\n+\t\t\t\t  target_pid_to_str (event_lp->ptid).c_str ());\n \t}\n     }\n \n@@ -2899,10 +2798,9 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n       random_selector = (int)\n \t((num_events * (double) rand ()) / (RAND_MAX + 1.0));\n \n-      if (debug_linux_nat && num_events > 1)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"SEL: Found %d events, selecting #%d\\n\",\n-\t\t\t    num_events, random_selector);\n+      if (num_events > 1)\n+\tlinux_nat_debug_printf (\"Found %d events, selecting #%d\",\n+\t\t\t\tnum_events, random_selector);\n \n       event_lp\n \t= (iterate_over_lwps\n@@ -2961,10 +2859,7 @@ linux_nat_filter_event (int lwpid, int status)\n       && (WSTOPSIG (status) == SIGTRAP && event == PTRACE_EVENT_EXEC))\n     {\n       /* A multi-thread exec after we had seen the leader exiting.  */\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: Re-adding thread group leader LWP %d.\\n\",\n-\t\t\t    lwpid);\n+      linux_nat_debug_printf (\"Re-adding thread group leader LWP %d.\", lwpid);\n \n       lp = add_lwp (ptid_t (lwpid, lwpid, 0));\n       lp->stopped = 1;\n@@ -2974,10 +2869,8 @@ linux_nat_filter_event (int lwpid, int status)\n \n   if (WIFSTOPPED (status) && !lp)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LHEW: saving LWP %ld status %s in stopped_pids list\\n\",\n-\t\t\t    (long) lwpid, status_to_str (status));\n+      linux_nat_debug_printf (\"saving LWP %ld status %s in stopped_pids list\",\n+\t\t\t      (long) lwpid, status_to_str (status));\n       add_to_pid_list (&stopped_pids, lwpid, status);\n       return NULL;\n     }\n@@ -3024,10 +2917,8 @@ linux_nat_filter_event (int lwpid, int status)\n   if (WIFSTOPPED (status) && WSTOPSIG (status) == SIGTRAP\n       && linux_is_extended_waitstatus (status))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: Handling extended status 0x%06x\\n\",\n-\t\t\t    status);\n+      linux_nat_debug_printf (\"Handling extended status 0x%06x\", status);\n+\n       if (linux_handle_extended_wait (lp, status))\n \treturn NULL;\n     }\n@@ -3038,10 +2929,8 @@ linux_nat_filter_event (int lwpid, int status)\n       if (!report_thread_events\n \t  && num_lwps (lp->ptid.pid ()) > 1)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LLW: %s exited.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"%s exited.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \n \t  /* If there is at least one more LWP, then the exit signal\n \t     was not the end of the debugged application and should be\n@@ -3054,10 +2943,8 @@ linux_nat_filter_event (int lwpid, int status)\n \t exit, if e.g., some other thread brings down the whole\n \t process (calls `exit').  So don't assert that the lwp is\n \t resumed.  */\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LWP %ld exited (resumed=%d)\\n\",\n-\t\t\t    lp->ptid.lwp (), lp->resumed);\n+      linux_nat_debug_printf (\"LWP %ld exited (resumed=%d)\",\n+\t\t\t      lp->ptid.lwp (), lp->resumed);\n \n       /* Dead LWP's aren't expected to reported a pending sigstop.  */\n       lp->signalled = 0;\n@@ -3077,21 +2964,17 @@ linux_nat_filter_event (int lwpid, int status)\n \n       if (lp->last_resume_kind == resume_stop)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LLW: resume_stop SIGSTOP caught for %s.\\n\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf (\"resume_stop SIGSTOP caught for %s.\",\n+\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n \t}\n       else\n \t{\n \t  /* This is a delayed SIGSTOP.  Filter out the event.  */\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LLW: %s %s, 0, 0 (discard delayed SIGSTOP)\\n\",\n-\t\t\t\tlp->step ?\n-\t\t\t\t\"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str ());\n+\t  linux_nat_debug_printf\n+\t    (\"%s %s, 0, 0 (discard delayed SIGSTOP)\",\n+\t     lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n+\t     target_pid_to_str (lp->ptid).c_str ());\n \n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n \t  gdb_assert (lp->resumed);\n@@ -3104,21 +2987,16 @@ linux_nat_filter_event (int lwpid, int status)\n   if (lp->ignore_sigint\n       && WIFSTOPPED (status) && WSTOPSIG (status) == SIGINT)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: Delayed SIGINT caught for %s.\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"Delayed SIGINT caught for %s.\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n \n       /* This is a delayed SIGINT.  */\n       lp->ignore_sigint = 0;\n \n       linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: %s %s, 0, 0 (discard SIGINT)\\n\",\n-\t\t\t    lp->step ?\n-\t\t\t    \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"%s %s, 0, 0 (discard SIGINT)\",\n+\t\t\t      lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n       gdb_assert (lp->resumed);\n \n       /* Discard the event.  */\n@@ -3165,15 +3043,12 @@ linux_nat_filter_event (int lwpid, int status)\n \t  && !linux_wstatus_maybe_breakpoint (status))\n \t{\n \t  linux_resume_one_lwp (lp, lp->step, signo);\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LLW: %s %s, %s (preempt 'handle')\\n\",\n-\t\t\t\tlp->step ?\n-\t\t\t\t\"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t\ttarget_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\t(signo != GDB_SIGNAL_0\n-\t\t\t\t ? strsignal (gdb_signal_to_host (signo))\n-\t\t\t\t : \"0\"));\n+\t  linux_nat_debug_printf\n+\t    (\"%s %s, %s (preempt 'handle')\",\n+\t     lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n+\t     target_pid_to_str (lp->ptid).c_str (),\n+\t     (signo != GDB_SIGNAL_0\n+\t      ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \t  return NULL;\n \t}\n     }\n@@ -3205,11 +3080,9 @@ check_zombie_leaders (void)\n \t  && num_lwps (inf->pid) > 1\n \t  && linux_proc_pid_is_zombie (inf->pid))\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"CZL: Thread group leader %d zombie \"\n-\t\t\t\t\"(it exited, or another thread execd).\\n\",\n-\t\t\t\tinf->pid);\n+\t  linux_nat_debug_printf (\"Thread group leader %d zombie \"\n+\t\t\t\t  \"(it exited, or another thread execd).\",\n+\t\t\t\t  inf->pid);\n \n \t  /* A leader zombie can mean one of two things:\n \n@@ -3229,10 +3102,7 @@ check_zombie_leaders (void)\n \t     previous leader did exit voluntarily before some other\n \t     thread execs).  */\n \n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"CZL: Thread group leader %d vanished.\\n\",\n-\t\t\t\tinf->pid);\n+\t  linux_nat_debug_printf (\"Thread group leader %d vanished.\", inf->pid);\n \t  exit_lwp (leader_lp);\n \t}\n     }\n@@ -3271,8 +3141,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   struct lwp_info *lp;\n   int status;\n \n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog, \"LLW: enter\\n\");\n+  linux_nat_debug_printf (\"enter\");\n \n   /* The first time we get here after starting a new inferior, we may\n      not have added it to the LWP list yet - this is the earliest\n@@ -3295,11 +3164,9 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   lp = iterate_over_lwps (ptid, status_callback);\n   if (lp != NULL)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: Using pending wait status %s for %s.\\n\",\n-\t\t\t    status_to_str (lp->status),\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"Using pending wait status %s for %s.\",\n+\t\t\t      status_to_str (lp->status),\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   /* But if we don't find a pending event, we'll have to wait.  Always\n@@ -3326,19 +3193,14 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n       errno = 0;\n       lwpid = my_waitpid (-1, &status,  __WALL | WNOHANG);\n \n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LNW: waitpid(-1, ...) returned %d, %s\\n\",\n-\t\t\t    lwpid, errno ? safe_strerror (errno) : \"ERRNO-OK\");\n+      linux_nat_debug_printf (\"waitpid(-1, ...) returned %d, %s\",\n+\t\t\t      lwpid,\n+\t\t\t      errno ? safe_strerror (errno) : \"ERRNO-OK\");\n \n       if (lwpid > 0)\n \t{\n-\t  if (debug_linux_nat)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"LLW: waitpid %ld received %s\\n\",\n+\t  linux_nat_debug_printf (\"waitpid %ld received %s\",\n \t\t\t\t  (long) lwpid, status_to_str (status));\n-\t    }\n \n \t  linux_nat_filter_event (lwpid, status);\n \t  /* Retry until nothing comes out of waitpid.  A single\n@@ -3368,8 +3230,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t forever in the sigsuspend call below otherwise.  */\n       if (iterate_over_lwps (ptid, resumed_callback) == NULL)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog, \"LLW: exit (no resumed LWP)\\n\");\n+\t  linux_nat_debug_printf (\"exit (no resumed LWP)\");\n \n \t  ourstatus->kind = TARGET_WAITKIND_NO_RESUMED;\n \n@@ -3381,8 +3242,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n       if (target_options & TARGET_WNOHANG)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog, \"LLW: exit (ignore)\\n\");\n+\t  linux_nat_debug_printf (\"exit (ignore)\");\n \n \t  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n \t  restore_child_signals_mask (&prev_mask);\n@@ -3456,10 +3316,8 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   if (linux_target->low_status_is_event (status))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LLW: trap ptid is %s.\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"trap ptid is %s.\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n \n   if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n@@ -3470,8 +3328,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   else\n     store_waitstatus (ourstatus, status);\n \n-  if (debug_linux_nat)\n-    fprintf_unfiltered (gdb_stdlog, \"LLW: exit\\n\");\n+  linux_nat_debug_printf (\"exit\");\n \n   restore_child_signals_mask (&prev_mask);\n \n@@ -3505,24 +3362,18 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n {\n   if (!lp->stopped)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"RSRL: NOT resuming LWP %s, not stopped\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"NOT resuming LWP %s, not stopped\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (!lp->resumed)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"RSRL: NOT resuming LWP %s, not resumed\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"NOT resuming LWP %s, not resumed\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n   else if (lwp_status_pending_p (lp))\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"RSRL: NOT resuming LWP %s, has pending status\\n\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+      linux_nat_debug_printf (\"NOT resuming LWP %s, has pending status\",\n+\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n   else\n     {\n@@ -3544,13 +3395,10 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n \n \t  if (!leave_stopped)\n \t    {\n-\t      if (debug_linux_nat)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"RSRL: resuming stopped-resumed LWP %s at \"\n-\t\t\t\t    \"%s: step=%d\\n\",\n-\t\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n-\t\t\t\t    paddress (gdbarch, pc),\n-\t\t\t\t    lp->step);\n+\t      linux_nat_debug_printf\n+\t\t(\"resuming stopped-resumed LWP %s at %s: step=%d\",\n+\t\t target_pid_to_str (lp->ptid).c_str (), paddress (gdbarch, pc),\n+\t\t lp->step);\n \n \t      linux_resume_one_lwp_throw (lp, lp->step, GDB_SIGNAL_0);\n \t    }\n@@ -3571,14 +3419,8 @@ linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n {\n   ptid_t event_ptid;\n \n-  if (debug_linux_nat)\n-    {\n-      std::string options_string = target_options_to_string (target_options);\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"linux_nat_wait: [%s], [%s]\\n\",\n-\t\t\t  target_pid_to_str (ptid).c_str (),\n-\t\t\t  options_string.c_str ());\n-    }\n+  linux_nat_debug_printf (\"[%s], [%s]\", target_pid_to_str (ptid).c_str (),\n+\t\t\t  target_options_to_string (target_options).c_str ());\n \n   /* Flush the async file first.  */\n   if (target_is_async_p ())\n@@ -3621,13 +3463,14 @@ kill_one_lwp (pid_t pid)\n \n   errno = 0;\n   kill_lwp (pid, SIGKILL);\n+\n   if (debug_linux_nat)\n     {\n       int save_errno = errno;\n \n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"KC:  kill (SIGKILL) %ld, 0, 0 (%s)\\n\", (long) pid,\n-\t\t\t  save_errno ? safe_strerror (save_errno) : \"OK\");\n+      linux_nat_debug_printf\n+\t(\"kill (SIGKILL) %ld, 0, 0 (%s)\", (long) pid,\n+\t save_errno != 0 ? safe_strerror (save_errno) : \"OK\");\n     }\n \n   /* Some kernels ignore even SIGKILL for processes under ptrace.  */\n@@ -3638,9 +3481,9 @@ kill_one_lwp (pid_t pid)\n     {\n       int save_errno = errno;\n \n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"KC:  PTRACE_KILL %ld, 0, 0 (%s)\\n\", (long) pid,\n-\t\t\t  save_errno ? safe_strerror (save_errno) : \"OK\");\n+      linux_nat_debug_printf\n+\t(\"PTRACE_KILL %ld, 0, 0 (%s)\", (long) pid,\n+\t save_errno ? safe_strerror (save_errno) : \"OK\");\n     }\n }\n \n@@ -3660,10 +3503,8 @@ kill_wait_one_lwp (pid_t pid)\n       res = my_waitpid (pid, NULL, __WALL);\n       if (res != (pid_t) -1)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"KWC: wait %ld received unknown.\\n\",\n-\t\t\t\t(long) pid);\n+\t  linux_nat_debug_printf (\"wait %ld received unknown.\", (long) pid);\n+\n \t  /* The Linux kernel sometimes fails to kill a thread\n \t     completely after PTRACE_KILL; that goes from the stop\n \t     point in do_fork out to the one in get_signal_to_deliver\n@@ -4306,19 +4147,14 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n {\n   if (!lwp->stopped)\n     {\n-      if (debug_linux_nat)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"LNSL: running -> suspending %s\\n\",\n-\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n+      linux_nat_debug_printf (\"running -> suspending %s\",\n+\t\t\t      target_pid_to_str (lwp->ptid).c_str ());\n \n \n       if (lwp->last_resume_kind == resume_stop)\n \t{\n-\t  if (debug_linux_nat)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"linux-nat: already stopping LWP %ld at \"\n-\t\t\t\t\"GDB's request\\n\",\n-\t\t\t\tlwp->ptid.lwp ());\n+\t  linux_nat_debug_printf (\"already stopping LWP %ld at GDB's request\",\n+\t\t\t\t  lwp->ptid.lwp ());\n \t  return 0;\n \t}\n \n@@ -4332,14 +4168,11 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n       if (debug_linux_nat)\n \t{\n \t  if (find_thread_ptid (linux_target, lwp->ptid)->stop_requested)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LNSL: already stopped/stop_requested %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lwp->ptid).c_str ());\n+\t    linux_nat_debug_printf (\"already stopped/stop_requested %s\",\n+\t\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n \t  else\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"LNSL: already stopped/no \"\n-\t\t\t\t\"stop_requested yet %s\\n\",\n-\t\t\t\ttarget_pid_to_str (lwp->ptid).c_str ());\n+\t    linux_nat_debug_printf (\"already stopped/no stop_requested yet %s\",\n+\t\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n \t}\n     }\n   return 0;"
    }
  ]
}