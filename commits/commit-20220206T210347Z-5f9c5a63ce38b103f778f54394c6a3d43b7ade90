{
  "sha": "5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
  "node_id": "C_kwDOANOeidoAKDVmOWM1YTYzY2UzOGIxMDNmNzc4ZjU0Mzk0YzZhM2Q0M2I3YWRlOTA",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2022-01-28T03:16:41Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2022-02-06T21:03:47Z"
    },
    "message": "gdb: remove SYMBOL_TYPE macro\n\nAdd a getter and a setter for a symbol's type.  Remove the corresponding\nmacro and adjust all callers.\n\nChange-Id: Ie1a137744c5bfe1df4d4f9ae5541c5299577c8de",
    "tree": {
      "sha": "c356fc03c61b9e9234aa8e187fb6c2303b8e5d2c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c356fc03c61b9e9234aa8e187fb6c2303b8e5d2c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f5abd8f234426bbe8ccd08c43e6ae7cbe635e042",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5abd8f234426bbe8ccd08c43e6ae7cbe635e042",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f5abd8f234426bbe8ccd08c43e6ae7cbe635e042"
    }
  ],
  "stats": {
    "total": 675,
    "additions": 342,
    "deletions": 333
  },
  "files": [
    {
      "sha": "916b8ef94fef99f5a931e9fcf33b0d52236b00c1",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1332,10 +1332,10 @@ select_possible_type_sym (const std::vector<struct block_symbol> &syms)\n     switch (syms[i].symbol->aclass ())\n       {\n       case LOC_TYPEDEF:\n-\tif (ada_prefer_type (SYMBOL_TYPE (syms[i].symbol), preferred_type))\n+\tif (ada_prefer_type (syms[i].symbol->type (), preferred_type))\n \t  {\n \t    preferred_index = i;\n-\t    preferred_type = SYMBOL_TYPE (syms[i].symbol);\n+\t    preferred_type = syms[i].symbol->type ();\n \t  }\n \tbreak;\n       case LOC_REGISTER:\n@@ -1374,7 +1374,7 @@ find_primitive_type (struct parser_state *par_state, const char *name)\n       strcat (expanded_name, name);\n       sym = ada_lookup_symbol (expanded_name, NULL, VAR_DOMAIN).symbol;\n       if (sym != NULL && sym->aclass () == LOC_TYPEDEF)\n-\ttype = SYMBOL_TYPE (sym);\n+\ttype = sym->type ();\n     }\n \n   return type;\n@@ -1474,7 +1474,7 @@ get_symbol_field_type (struct symbol *sym, const char *encoded_field_name)\n {\n   const char *field_name = encoded_field_name;\n   const char *subfield_name;\n-  struct type *type = SYMBOL_TYPE (sym);\n+  struct type *type = sym->type ();\n   int fieldno;\n \n   if (type == NULL || field_name == NULL)\n@@ -1595,7 +1595,7 @@ write_var_or_type (struct parser_state *par_state,\n \t      struct type *field_type;\n \t      \n \t      if (tail_index == name_len)\n-\t\treturn SYMBOL_TYPE (type_sym);\n+\t\treturn type_sym->type ();\n \n \t      /* We have some extraneous characters after the type name.\n \t\t If this is an expression \"TYPE_NAME.FIELD0.[...].FIELDN\","
    },
    {
      "sha": "fbeb176d5668152d12c5fae4ac8e9e8792c9c386",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -3163,7 +3163,7 @@ static void\n ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n \t\t\t    const struct type_print_options *flags)\n {\n-  struct type *type = SYMBOL_TYPE (sym);\n+  struct type *type = sym->type ();\n \n   fprintf_filtered (stream, \"%s\", sym->print_name ());\n   if (!print_signatures\n@@ -3348,8 +3348,8 @@ See set/show multiple-symbol.\"));\n \t{\n \t  int is_enumeral =\n \t    (syms[i].symbol->aclass () == LOC_CONST\n-\t     && SYMBOL_TYPE (syms[i].symbol) != NULL\n-\t     && SYMBOL_TYPE (syms[i].symbol)->code () == TYPE_CODE_ENUM);\n+\t     && syms[i].symbol->type () != NULL\n+\t     && syms[i].symbol->type ()->code () == TYPE_CODE_ENUM);\n \t  struct symtab *symtab = NULL;\n \n \t  if (syms[i].symbol->is_objfile_owned ())\n@@ -3365,10 +3365,10 @@ See set/show multiple-symbol.\"));\n \t\t\t       SYMBOL_LINE (syms[i].symbol));\n \t    }\n \t  else if (is_enumeral\n-\t\t   && SYMBOL_TYPE (syms[i].symbol)->name () != NULL)\n+\t\t   && syms[i].symbol->type ()->name () != NULL)\n \t    {\n \t      printf_filtered ((\"[%d] \"), i + first_choice);\n-\t      ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n+\t      ada_print_type (syms[i].symbol->type (), NULL,\n \t\t\t      gdb_stdout, -1, 0, &type_print_raw_options);\n \t      printf_filtered (_(\"'(%s) (enumeral)\\n\"),\n \t\t\t       syms[i].symbol->print_name ());\n@@ -3467,7 +3467,7 @@ ada_resolve_enum (std::vector<struct block_symbol> &syms,\n     {\n       /* We already know the name matches, so we're just looking for\n \t an element of the correct enum type.  */\n-      if (ada_check_typedef (SYMBOL_TYPE (syms[i].symbol)) == context_type)\n+      if (ada_check_typedef (syms[i].symbol->type ()) == context_type)\n \treturn i;\n     }\n \n@@ -3626,7 +3626,7 @@ static int\n ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n {\n   int i;\n-  struct type *func_type = SYMBOL_TYPE (func);\n+  struct type *func_type = func->type ();\n \n   if (func->aclass () == LOC_CONST\n       && func_type->code () == TYPE_CODE_ENUM)\n@@ -3714,7 +3714,7 @@ ada_resolve_function (std::vector<struct block_symbol> &syms,\n     {\n       for (k = 0; k < syms.size (); k += 1)\n \t{\n-\t  struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].symbol));\n+\t  struct type *type = ada_check_typedef (syms[k].symbol->type ());\n \n \t  if (ada_args_match (syms[k].symbol, args, nargs)\n \t      && (fallback || return_match (type, context_type)))\n@@ -4441,8 +4441,8 @@ static int\n is_nonfunction (const std::vector<struct block_symbol> &syms)\n {\n   for (const block_symbol &sym : syms)\n-    if (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_FUNC\n-\t&& (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_ENUM\n+    if (sym.symbol->type ()->code () != TYPE_CODE_FUNC\n+\t&& (sym.symbol->type ()->code () != TYPE_CODE_ENUM\n \t    || sym.symbol->aclass () != LOC_CONST))\n       return 1;\n \n@@ -4487,8 +4487,8 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n       return 1;\n     case LOC_TYPEDEF:\n       {\n-\tstruct type *type0 = SYMBOL_TYPE (sym0);\n-\tstruct type *type1 = SYMBOL_TYPE (sym1);\n+\tstruct type *type0 = sym0->type ();\n+\tstruct type *type1 = sym1->type ();\n \tconst char *name0 = sym0->linkage_name ();\n \tconst char *name1 = sym1->linkage_name ();\n \tint len0 = strlen (name0);\n@@ -4501,7 +4501,7 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n       }\n     case LOC_CONST:\n       return SYMBOL_VALUE (sym0) == SYMBOL_VALUE (sym1)\n-\t&& equiv_types (SYMBOL_TYPE (sym0), SYMBOL_TYPE (sym1));\n+\t&& equiv_types (sym0->type (), sym1->type ());\n \n     case LOC_STATIC:\n       {\n@@ -4675,7 +4675,7 @@ symbols_are_identical_enums (const std::vector<struct block_symbol> &syms)\n \n   /* Quick check: All symbols should have an enum type.  */\n   for (i = 0; i < syms.size (); i++)\n-    if (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_ENUM)\n+    if (syms[i].symbol->type ()->code () != TYPE_CODE_ENUM)\n       return 0;\n \n   /* Quick check: They should all have the same value.  */\n@@ -4685,16 +4685,16 @@ symbols_are_identical_enums (const std::vector<struct block_symbol> &syms)\n \n   /* Quick check: They should all have the same number of enumerals.  */\n   for (i = 1; i < syms.size (); i++)\n-    if (SYMBOL_TYPE (syms[i].symbol)->num_fields ()\n-\t!= SYMBOL_TYPE (syms[0].symbol)->num_fields ())\n+    if (syms[i].symbol->type ()->num_fields ()\n+\t!= syms[0].symbol->type ()->num_fields ())\n       return 0;\n \n   /* All the sanity checks passed, so we might have a set of\n      identical enumeration types.  Perform a more complete\n      comparison of the type of each symbol.  */\n   for (i = 1; i < syms.size (); i++)\n-    if (!ada_identical_enum_types_p (SYMBOL_TYPE (syms[i].symbol),\n-\t\t\t\t     SYMBOL_TYPE (syms[0].symbol)))\n+    if (!ada_identical_enum_types_p (syms[i].symbol->type (),\n+\t\t\t\t     syms[0].symbol->type ()))\n       return 0;\n \n   return 1;\n@@ -4725,13 +4725,13 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n       /* If two symbols have the same name and one of them is a stub type,\n \t the get rid of the stub.  */\n \n-      if (SYMBOL_TYPE ((*syms)[i].symbol)->is_stub ()\n+      if ((*syms)[i].symbol->type ()->is_stub ()\n \t  && (*syms)[i].symbol->linkage_name () != NULL)\n \t{\n \t  for (j = 0; j < syms->size (); j++)\n \t    {\n \t      if (j != i\n-\t\t  && !SYMBOL_TYPE ((*syms)[j].symbol)->is_stub ()\n+\t\t  && !(*syms)[j].symbol->type ()->is_stub ()\n \t\t  && (*syms)[j].symbol->linkage_name () != NULL\n \t\t  && strcmp ((*syms)[i].symbol->linkage_name (),\n \t\t\t     (*syms)[j].symbol->linkage_name ()) == 0)\n@@ -4744,7 +4744,7 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n \n       else if ((*syms)[i].symbol->linkage_name () != NULL\n \t  && (*syms)[i].symbol->aclass () == LOC_STATIC\n-\t  && is_nondebugging_type (SYMBOL_TYPE ((*syms)[i].symbol)))\n+\t  && is_nondebugging_type ((*syms)[i].symbol->type ()))\n \t{\n \t  for (j = 0; j < syms->size (); j += 1)\n \t    {\n@@ -4848,7 +4848,7 @@ old_renaming_is_invisible (const struct symbol *sym, const char *function_name)\n   if (sym->aclass () != LOC_TYPEDEF)\n     return 0;\n \n-  std::string scope = xget_renaming_scope (SYMBOL_TYPE (sym));\n+  std::string scope = xget_renaming_scope (sym->type ());\n \n   /* If the rename has been defined in a package, then it is visible.  */\n   if (is_package_name (scope.c_str ()))\n@@ -7231,7 +7231,7 @@ ada_find_any_type (const char *name)\n   struct symbol *sym = ada_find_any_type_symbol (name);\n \n   if (sym != NULL)\n-    return SYMBOL_TYPE (sym);\n+    return sym->type ();\n \n   return NULL;\n }\n@@ -10420,7 +10420,7 @@ ada_var_value_operation::evaluate (struct type *expect_type,\n \n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n     {\n-      struct type *type = static_unwrap_type (SYMBOL_TYPE (sym));\n+      struct type *type = static_unwrap_type (sym->type ());\n       /* Check to see if this is a tagged type.  We also need to handle\n \t the case where the type is a reference to a tagged type, but\n \t we have to be careful to exclude pointers to tagged types.\n@@ -10511,7 +10511,7 @@ ada_var_value_operation::resolve (struct expression *exp,\n     }\n \n   if (deprocedure_p\n-      && (SYMBOL_TYPE (std::get<0> (m_storage).symbol)->code ()\n+      && (std::get<0> (m_storage).symbol->type ()->code ()\n \t  == TYPE_CODE_FUNC))\n     return true;\n \n@@ -12418,7 +12418,7 @@ catch_assert_command (const char *arg_entry, int from_tty,\n static int\n ada_is_exception_sym (struct symbol *sym)\n {\n-  const char *type_name = SYMBOL_TYPE (sym)->name ();\n+  const char *type_name = sym->type ()->name ();\n \n   return (sym->aclass () != LOC_TYPEDEF\n \t  && sym->aclass () != LOC_BLOCK"
    },
    {
      "sha": "6a41d5f4b2b5f3cec7eec81ddade5f1afced39d2",
      "filename": "gdb/ada-tasks.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-tasks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ada-tasks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-tasks.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -503,42 +503,42 @@ ada_get_tcb_types_info (void)\n     lookup_symbol_in_language (entry_call_record_name, NULL, STRUCT_DOMAIN,\n \t\t\t       language_c, NULL).symbol;\n \n-  if (atcb_sym == NULL || atcb_sym->type == NULL)\n+  if (atcb_sym == NULL || atcb_sym->type () == NULL)\n     {\n       /* In Ravenscar run-time libs, the  ATCB does not have a dynamic\n \t size, so the symbol name differs.  */\n       atcb_sym = lookup_symbol_in_language (atcb_name_fixed, NULL,\n \t\t\t\t\t    STRUCT_DOMAIN, language_c,\n \t\t\t\t\t    NULL).symbol;\n \n-      if (atcb_sym == NULL || atcb_sym->type == NULL)\n+      if (atcb_sym == NULL || atcb_sym->type () == NULL)\n \treturn _(\"Cannot find Ada_Task_Control_Block type\");\n \n-      type = atcb_sym->type;\n+      type = atcb_sym->type ();\n     }\n   else\n     {\n       /* Get a static representation of the type record\n \t Ada_Task_Control_Block.  */\n-      type = atcb_sym->type;\n+      type = atcb_sym->type ();\n       type = ada_template_to_fixed_record_type_1 (type, NULL, 0, NULL, 0);\n     }\n \n-  if (common_atcb_sym == NULL || common_atcb_sym->type == NULL)\n+  if (common_atcb_sym == NULL || common_atcb_sym->type () == NULL)\n     return _(\"Cannot find Common_ATCB type\");\n-  if (private_data_sym == NULL || private_data_sym->type == NULL)\n+  if (private_data_sym == NULL || private_data_sym->type ()== NULL)\n     return _(\"Cannot find Private_Data type\");\n-  if (entry_call_record_sym == NULL || entry_call_record_sym->type == NULL)\n+  if (entry_call_record_sym == NULL || entry_call_record_sym->type () == NULL)\n     return _(\"Cannot find Entry_Call_Record type\");\n \n   /* Get the type for Ada_Task_Control_Block.Common.  */\n-  common_type = common_atcb_sym->type;\n+  common_type = common_atcb_sym->type ();\n \n   /* Get the type for Ada_Task_Control_Bloc.Common.Call.LL.  */\n-  ll_type = private_data_sym->type;\n+  ll_type = private_data_sym->type ();\n \n   /* Get the type for Common_ATCB.Call.all.  */\n-  call_type = entry_call_record_sym->type;\n+  call_type = entry_call_record_sym->type ();\n \n   /* Get the field indices.  */\n   fieldnos.common = ada_get_field_index (type, \"common\", 0);\n@@ -904,7 +904,7 @@ ada_tasks_inferior_data_sniffer (struct ada_tasks_inferior_data *data)\n       if (sym != NULL)\n \t{\n \t  /* Validate.  */\n-\t  struct type *type = check_typedef (SYMBOL_TYPE (sym));\n+\t  struct type *type = check_typedef (sym->type ());\n \t  struct type *eltype = NULL;\n \t  struct type *idxtype = NULL;\n \n@@ -950,7 +950,7 @@ ada_tasks_inferior_data_sniffer (struct ada_tasks_inferior_data *data)\n       if (sym != NULL && SYMBOL_VALUE_ADDRESS (sym) != 0)\n \t{\n \t  /* Validate.  */\n-\t  struct type *type = check_typedef (SYMBOL_TYPE (sym));\n+\t  struct type *type = check_typedef (sym->type ());\n \n \t  if (type->code () == TYPE_CODE_PTR)\n \t    {"
    },
    {
      "sha": "0b12dc3a42f155915891c76a63fd9929057321f2",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -510,7 +510,7 @@ static void\n gen_var_ref (struct agent_expr *ax, struct axs_value *value, struct symbol *var)\n {\n   /* Dereference any typedefs.  */\n-  value->type = check_typedef (SYMBOL_TYPE (var));\n+  value->type = check_typedef (var->type ());\n   value->optimized_out = 0;\n \n   if (SYMBOL_COMPUTED_OPS (var) != NULL)"
    },
    {
      "sha": "3fe096db583854377b662c7cfd42bc28c6b5043b",
      "filename": "gdb/block.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/block.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/block.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/block.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -857,7 +857,7 @@ block_find_symbol (const struct block *block, const char *name,\n int\n block_find_non_opaque_type (struct symbol *sym, void *data)\n {\n-  return !TYPE_IS_OPAQUE (SYMBOL_TYPE (sym));\n+  return !TYPE_IS_OPAQUE (sym->type ());\n }\n \n /* See block.h.  */\n@@ -867,7 +867,7 @@ block_find_non_opaque_type_preferred (struct symbol *sym, void *data)\n {\n   struct symbol **best = (struct symbol **) data;\n \n-  if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))\n+  if (!TYPE_IS_OPAQUE (sym->type ()))\n     return 1;\n   *best = sym;\n   return 0;"
    },
    {
      "sha": "50c464f44a24c8931616daec07d3b0a9aec2e43a",
      "filename": "gdb/blockframe.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/blockframe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/blockframe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/blockframe.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -426,7 +426,7 @@ find_function_type (CORE_ADDR pc)\n   struct symbol *sym = find_pc_function (pc);\n \n   if (sym != NULL && BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym)) == pc)\n-    return SYMBOL_TYPE (sym);\n+    return sym->type ();\n \n   return NULL;\n }"
    },
    {
      "sha": "999f632f4013f798addce123bd443f8b65688080",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -249,7 +249,7 @@ buildsym_compunit::finish_block_internal\n \n   if (symbol)\n     {\n-      struct type *ftype = SYMBOL_TYPE (symbol);\n+      struct type *ftype = symbol->type ();\n       struct mdict_iterator miter;\n       SYMBOL_BLOCK_VALUE (symbol) = block;\n       BLOCK_FUNCTION (block) = symbol;\n@@ -286,7 +286,7 @@ buildsym_compunit::finish_block_internal\n \n \t\t  if (sym->is_argument ())\n \t\t    {\n-\t\t      ftype->field (iparams).set_type (SYMBOL_TYPE (sym));\n+\t\t      ftype->field (iparams).set_type (sym->type ());\n \t\t      TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;\n \t\t      iparams++;\n \t\t    }"
    },
    {
      "sha": "de29d2f70e239efe9437ef5b103ecaf16c18955d",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -3090,7 +3090,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t\t\t\t&inner_is_a_field_of_this);\n \t  if (bsym.symbol != NULL)\n \t    {\n-\t      yylval.tsym.type = SYMBOL_TYPE (bsym.symbol);\n+\t      yylval.tsym.type = bsym.symbol->type ();\n \t      return TYPENAME;\n \t    }\n \t}\n@@ -3118,7 +3118,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \n   if (bsym.symbol && bsym.symbol->aclass () == LOC_TYPEDEF)\n     {\n-      yylval.tsym.type = SYMBOL_TYPE (bsym.symbol);\n+      yylval.tsym.type = bsym.symbol->type ();\n       return TYPENAME;\n     }\n \n@@ -3135,7 +3135,7 @@ classify_name (struct parser_state *par_state, const struct block *block,\n \t  sym = lookup_struct_typedef (copy.c_str (),\n \t\t\t\t       par_state->expression_context_block, 1);\n \t  if (sym)\n-\t    yylval.theclass.type = SYMBOL_TYPE (sym);\n+\t    yylval.theclass.type = sym->type ();\n \t  return CLASSNAME;\n \t}\n     }\n@@ -3231,7 +3231,7 @@ classify_inner_name (struct parser_state *par_state,\n       return ERROR;\n \n     case LOC_TYPEDEF:\n-      yylval.tsym.type = SYMBOL_TYPE (yylval.ssym.sym.symbol);\n+      yylval.tsym.type = yylval.ssym.sym.symbol->type ();\n       return TYPENAME;\n \n     default:"
    },
    {
      "sha": "405ede8b9c88ae3aa0a30385c199f75de1e7743b",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -207,10 +207,10 @@ c_print_typedef (struct type *type,\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"typedef \");\n   type_print (type, \"\", stream, -1);\n-  if ((SYMBOL_TYPE (new_symbol))->name () == 0\n-      || strcmp ((SYMBOL_TYPE (new_symbol))->name (),\n+  if ((new_symbol->type ())->name () == 0\n+      || strcmp ((new_symbol->type ())->name (),\n \t\t new_symbol->linkage_name ()) != 0\n-      || SYMBOL_TYPE (new_symbol)->code () == TYPE_CODE_TYPEDEF)\n+      || new_symbol->type ()->code () == TYPE_CODE_TYPEDEF)\n     fprintf_filtered (stream, \" %s\", new_symbol->print_name ());\n   fprintf_filtered (stream, \";\");\n }\n@@ -899,7 +899,7 @@ c_type_print_template_args (const struct type_print_options *flags,\n \t  fprintf_filtered (stream, \"%s = \", sym->linkage_name ());\n \t}\n \n-      c_print_type (SYMBOL_TYPE (sym), \"\", stream, -1, 0, flags);\n+      c_print_type (sym->type (), \"\", stream, -1, 0, flags);\n     }\n \n   if (!first)"
    },
    {
      "sha": "fadbc5b7022ca5405869f174557739604041dc69",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -210,7 +210,7 @@ print_unpacked_pointer (struct type *type, struct type *elttype,\n \n \t  if (wsym)\n \t    {\n-\t      wtype = SYMBOL_TYPE (wsym);\n+\t      wtype = wsym->type ();\n \t    }\n \t  else\n \t    {"
    },
    {
      "sha": "3ff62bc96c0208dc9038ddc9a3b7ab189919b07f",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1492,8 +1492,8 @@ patch_opaque_types (struct symtab *s)\n \t from different files with the same name.  */\n       if (real_sym->aclass () == LOC_TYPEDEF\n \t  && real_sym->domain () == VAR_DOMAIN\n-\t  && SYMBOL_TYPE (real_sym)->code () == TYPE_CODE_PTR\n-\t  && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (real_sym))) != 0)\n+\t  && real_sym->type ()->code () == TYPE_CODE_PTR\n+\t  && TYPE_LENGTH (TYPE_TARGET_TYPE (real_sym->type ())) != 0)\n \t{\n \t  const char *name = real_sym->linkage_name ();\n \t  int hash = hashname (name);\n@@ -1514,7 +1514,7 @@ patch_opaque_types (struct symtab *s)\n \t\t      opaque_type_chain[hash] = SYMBOL_VALUE_CHAIN (sym);\n \t\t    }\n \n-\t\t  patch_type (SYMBOL_TYPE (sym), SYMBOL_TYPE (real_sym));\n+\t\t  patch_type (sym->type (), real_sym->type ());\n \n \t\t  if (prev)\n \t\t    {\n@@ -1571,9 +1571,9 @@ process_coff_symbol (struct coff_symbol *cs,\n   if (ISFCN (cs->c_type))\n     {\n       SYMBOL_VALUE (sym) += objfile->text_section_offset ();\n-      SYMBOL_TYPE (sym) =\n-\tlookup_function_type (decode_function_type (cs, cs->c_type,\n-\t\t\t\t\t\t    aux, objfile));\n+      sym->set_type\n+\t(lookup_function_type (decode_function_type (cs, cs->c_type,\n+\t\t\t\t\t\t     aux, objfile)));\n \n       sym->set_aclass_index (LOC_BLOCK);\n       if (cs->c_sclass == C_STAT || cs->c_sclass == C_THUMBSTAT\n@@ -1585,7 +1585,7 @@ process_coff_symbol (struct coff_symbol *cs,\n     }\n   else\n     {\n-      SYMBOL_TYPE (sym) = decode_type (cs, cs->c_type, aux, objfile);\n+      sym->set_type (decode_type (cs, cs->c_type, aux, objfile));\n       switch (cs->c_sclass)\n \t{\n \tcase C_NULL:\n@@ -1656,10 +1656,10 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  sym->set_domain (VAR_DOMAIN);\n \n \t  /* If type has no name, give it one.  */\n-\t  if (SYMBOL_TYPE (sym)->name () == 0)\n+\t  if (sym->type ()->name () == 0)\n \t    {\n-\t      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n-\t\t  || SYMBOL_TYPE (sym)->code () == TYPE_CODE_FUNC)\n+\t      if (sym->type ()->code () == TYPE_CODE_PTR\n+\t\t  || sym->type ()->code () == TYPE_CODE_FUNC)\n \t\t{\n \t\t  /* If we are giving a name to a type such as\n \t\t     \"pointer to foo\" or \"function returning foo\", we\n@@ -1682,7 +1682,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t\t  ;\n \t\t}\n \t      else\n-\t\tSYMBOL_TYPE (sym)->set_name (xstrdup (sym->linkage_name ()));\n+\t\tsym->type ()->set_name (xstrdup (sym->linkage_name ()));\n \t    }\n \n \t  /* Keep track of any type which points to empty structured\n@@ -1691,9 +1691,9 @@ process_coff_symbol (struct coff_symbol *cs,\n \t     not an empty structured type, though; the forward\n \t     references work themselves out via the magic of\n \t     coff_lookup_type.  */\n-\t  if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n-\t      && TYPE_LENGTH (TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))) == 0\n-\t      && TYPE_TARGET_TYPE (SYMBOL_TYPE (sym))->code ()\n+\t  if (sym->type ()->code () == TYPE_CODE_PTR\n+\t      && TYPE_LENGTH (TYPE_TARGET_TYPE (sym->type ())) == 0\n+\t      && TYPE_TARGET_TYPE (sym->type ())->code ()\n \t      != TYPE_CODE_UNDEF)\n \t    {\n \t      int i = hashname (sym->linkage_name ());\n@@ -1713,11 +1713,11 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  /* Some compilers try to be helpful by inventing \"fake\"\n \t     names for anonymous enums, structures, and unions, like\n \t     \"~0fake\" or \".0fake\".  Thanks, but no thanks...  */\n-\t  if (SYMBOL_TYPE (sym)->name () == 0)\n+\t  if (sym->type ()->name () == 0)\n \t    if (sym->linkage_name () != NULL\n \t\t&& *sym->linkage_name () != '~'\n \t\t&& *sym->linkage_name () != '.')\n-\t      SYMBOL_TYPE (sym)->set_name (xstrdup (sym->linkage_name ()));\n+\t      sym->type ()->set_name (xstrdup (sym->linkage_name ()));\n \n \t  add_symbol_to_list (sym, get_file_symbols ());\n \t  break;\n@@ -2143,7 +2143,7 @@ coff_read_enum_type (int index, int length, int lastsym,\n \t{\n \t  struct symbol *xsym = syms->symbol[j];\n \n-\t  SYMBOL_TYPE (xsym) = type;\n+\t  xsym->set_type (type);\n \t  type->field (n).set_name (xsym->linkage_name ());\n \t  type->field (n).set_loc_enumval (SYMBOL_VALUE (xsym));\n \t  if (SYMBOL_VALUE (xsym) < 0)"
    },
    {
      "sha": "4f7a5b22da51251cd8cd90f4506c4f1eeeb12b32",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -65,7 +65,7 @@ convert_one_symbol (compile_c_instance *context,\n   if (sym.symbol->aclass () == LOC_LABEL)\n     sym_type = 0;\n   else\n-    sym_type = context->convert_type (SYMBOL_TYPE (sym.symbol));\n+    sym_type = context->convert_type (sym.symbol->type ());\n \n   if (sym.symbol->domain () == STRUCT_DOMAIN)\n     {\n@@ -94,12 +94,12 @@ convert_one_symbol (compile_c_instance *context,\n \tcase LOC_BLOCK:\n \t  kind = GCC_C_SYMBOL_FUNCTION;\n \t  addr = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym.symbol));\n-\t  if (is_global && SYMBOL_TYPE (sym.symbol)->is_gnu_ifunc ())\n+\t  if (is_global && sym.symbol->type ()->is_gnu_ifunc ())\n \t    addr = gnu_ifunc_resolve_addr (target_gdbarch (), addr);\n \t  break;\n \n \tcase LOC_CONST:\n-\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_ENUM)\n+\t  if (sym.symbol->type ()->code () == TYPE_CODE_ENUM)\n \t    {\n \t      /* Already handled by convert_enum.  */\n \t      return;\n@@ -405,7 +405,7 @@ gcc_symbol_address (void *datum, struct gcc_c_context *gcc_context,\n \t\t\t\t\"gcc_symbol_address \\\"%s\\\": full symbol\\n\",\n \t\t\t\tidentifier);\n \t  result = BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (sym));\n-\t  if (SYMBOL_TYPE (sym)->is_gnu_ifunc ())\n+\t  if (sym->type ()->is_gnu_ifunc ())\n \t    result = gnu_ifunc_resolve_addr (target_gdbarch (), result);\n \t  found = 1;\n \t}\n@@ -548,14 +548,14 @@ generate_c_for_for_one_variable (compile_instance *compiler,\n \n   try\n     {\n-      if (is_dynamic_type (SYMBOL_TYPE (sym)))\n+      if (is_dynamic_type (sym->type ()))\n \t{\n \t  /* We need to emit to a temporary buffer in case an error\n \t     occurs in the middle.  */\n \t  string_file local_file;\n \n \t  generate_vla_size (compiler, &local_file, gdbarch, registers_used, pc,\n-\t\t\t     SYMBOL_TYPE (sym), sym);\n+\t\t\t     sym->type (), sym);\n \n \t  stream->write (local_file.c_str (), local_file.size ());\n \t}"
    },
    {
      "sha": "7cf5703dc71d5024eb39814edab2e040564ae882",
      "filename": "gdb/compile/compile-cplus-symbols.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-cplus-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-cplus-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-symbols.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -56,7 +56,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n   if (sym.symbol->aclass () == LOC_LABEL)\n     sym_type = 0;\n   else\n-    sym_type = instance->convert_type (SYMBOL_TYPE (sym.symbol));\n+    sym_type = instance->convert_type (sym.symbol->type ());\n \n   if (sym.symbol->domain () == STRUCT_DOMAIN)\n     {\n@@ -73,9 +73,9 @@ convert_one_symbol (compile_cplus_instance *instance,\n       switch (sym.symbol->aclass ())\n \t{\n \tcase LOC_TYPEDEF:\n-\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_TYPEDEF)\n+\t  if (sym.symbol->type ()->code () == TYPE_CODE_TYPEDEF)\n \t    kind = GCC_CP_SYMBOL_TYPEDEF;\n-\t  else  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_NAMESPACE)\n+\t  else  if (sym.symbol->type ()->code () == TYPE_CODE_NAMESPACE)\n \t    return;\n \t  break;\n \n@@ -88,13 +88,13 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t  {\n \t    kind = GCC_CP_SYMBOL_FUNCTION;\n \t    addr = BLOCK_START (SYMBOL_BLOCK_VALUE (sym.symbol));\n-\t    if (is_global && SYMBOL_TYPE (sym.symbol)->is_gnu_ifunc ())\n+\t    if (is_global && sym.symbol->type ()->is_gnu_ifunc ())\n \t      addr = gnu_ifunc_resolve_addr (target_gdbarch (), addr);\n \t  }\n \t  break;\n \n \tcase LOC_CONST:\n-\t  if (SYMBOL_TYPE (sym.symbol)->code () == TYPE_CODE_ENUM)\n+\t  if (sym.symbol->type ()->code () == TYPE_CODE_ENUM)\n \t    {\n \t      /* Already handled by convert_enum.  */\n \t      return;\n@@ -190,7 +190,7 @@ convert_one_symbol (compile_cplus_instance *instance,\n \t    {\n \t      compile_scope scope\n \t\t= instance->new_scope (sym.symbol->natural_name (),\n-\t\t\t\t       SYMBOL_TYPE (sym.symbol));\n+\t\t\t\t       sym.symbol->type ());\n \t      if (scope.nested_type () != GCC_TYPE_NONE)\n \t\t{\n \t\t  /* We found a symbol for this type that was defined inside\n@@ -442,7 +442,7 @@ gcc_cplus_symbol_address (void *datum, struct gcc_cp_context *gcc_context,\n \t\t\t\t\"gcc_symbol_address \\\"%s\\\": full symbol\\n\",\n \t\t\t\tidentifier);\n \t  result = BLOCK_START (SYMBOL_BLOCK_VALUE (sym));\n-\t  if (SYMBOL_TYPE (sym)->is_gnu_ifunc ())\n+\t  if (sym->type ()->is_gnu_ifunc ())\n \t    result = gnu_ifunc_resolve_addr (target_gdbarch (), result);\n \t  found = 1;\n \t}"
    },
    {
      "sha": "1987996698653ff0e149ad5ed89e60bf90f578d9",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -161,7 +161,7 @@ type_name_to_scope (const char *type_name, const struct block *block)\n \n \t  scope.push_back (comp);\n \n-\t  if (SYMBOL_TYPE (bsymbol.symbol)->code () != TYPE_CODE_NAMESPACE)\n+\t  if (bsymbol.symbol->type ()->code () != TYPE_CODE_NAMESPACE)\n \t    {\n \t      /* We're done.  */\n \t      break;\n@@ -271,7 +271,7 @@ compile_cplus_instance::enter_scope (compile_scope &&new_scope)\n \t(m_scopes.back ().begin (), m_scopes.back ().end () - 1,\n \t [this] (const scope_component &comp)\n \t {\n-\t  gdb_assert (SYMBOL_TYPE (comp.bsymbol.symbol)->code ()\n+\t  gdb_assert (comp.bsymbol.symbol->type ()->code ()\n \t\t      == TYPE_CODE_NAMESPACE);\n \n \t  const char *ns = (comp.name == CP_ANONYMOUS_NAMESPACE_STR ? nullptr\n@@ -313,7 +313,7 @@ compile_cplus_instance::leave_scope ()\n       std::for_each\n \t(current.begin (),current.end () - 1,\n \t [this] (const scope_component &comp) {\n-\t  gdb_assert (SYMBOL_TYPE (comp.bsymbol.symbol)->code ()\n+\t  gdb_assert (comp.bsymbol.symbol->type ()->code ()\n \t\t      == TYPE_CODE_NAMESPACE);\n \t  this->plugin ().pop_binding_level (comp.name.c_str ());\n \t});\n@@ -345,14 +345,14 @@ compile_cplus_instance::new_scope (const char *type_name, struct type *type)\n \t unqualified name of the type to process.  */\n       scope_component &comp = scope.back ();\n \n-      if (!types_equal (type, SYMBOL_TYPE (comp.bsymbol.symbol))\n+      if (!types_equal (type, comp.bsymbol.symbol->type ())\n \t  && (m_scopes.empty ()\n \t      || (m_scopes.back ().back ().bsymbol.symbol\n \t\t  != comp.bsymbol.symbol)))\n \t{\n \t  /* The type is defined inside another class(es).  Convert that\n \t     type instead of defining this type.  */\n-\t  convert_type (SYMBOL_TYPE (comp.bsymbol.symbol));\n+\t  convert_type (comp.bsymbol.symbol->type ());\n \n \t  /* If the original type (passed in to us) is defined in a nested\n \t     class, the previous call will give us that type's gcc_type."
    },
    {
      "sha": "073f2fe2fd32b69aacef926da87abf8ccb95dafc",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -458,15 +458,15 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n   if (block_loop == nblocks)\n     error (_(\"No \\\"%s\\\" symbol found\"), COMPILE_I_EXPR_VAL);\n \n-  gdb_type = SYMBOL_TYPE (gdb_val_sym);\n+  gdb_type = gdb_val_sym->type ();\n   gdb_type = check_typedef (gdb_type);\n \n   gdb_ptr_type_sym = block_lookup_symbol (block, COMPILE_I_EXPR_PTR_TYPE,\n \t\t\t\t\t  symbol_name_match_type::SEARCH_NAME,\n \t\t\t\t\t  VAR_DOMAIN);\n   if (gdb_ptr_type_sym == NULL)\n     error (_(\"No \\\"%s\\\" symbol found\"), COMPILE_I_EXPR_PTR_TYPE);\n-  gdb_ptr_type = SYMBOL_TYPE (gdb_ptr_type_sym);\n+  gdb_ptr_type = gdb_ptr_type_sym->type ();\n   gdb_ptr_type = check_typedef (gdb_ptr_type);\n   if (gdb_ptr_type->code () != TYPE_CODE_PTR)\n     error (_(\"Type of \\\"%s\\\" is not a pointer\"), COMPILE_I_EXPR_PTR_TYPE);\n@@ -517,7 +517,7 @@ get_out_value_type (struct symbol *func_sym, struct objfile *objfile,\n static struct type *\n get_regs_type (struct symbol *func_sym, struct objfile *objfile)\n {\n-  struct type *func_type = SYMBOL_TYPE (func_sym);\n+  struct type *func_type = func_sym->type ();\n   struct type *regsp_type, *regs_type;\n \n   /* No register parameter present.  */\n@@ -656,7 +656,7 @@ compile_object_load (const compile_file_names &file_names,\n   if (func_sym == NULL)\n     error (_(\"Cannot find function \\\"%s\\\" in compiled module \\\"%s\\\".\"),\n \t   GCC_FE_WRAPPER_FUNCTION, objfile_name (objfile));\n-  func_type = SYMBOL_TYPE (func_sym);\n+  func_type = func_sym->type ();\n   if (func_type->code () != TYPE_CODE_FUNC)\n     error (_(\"Invalid type code %d of function \\\"%s\\\" in compiled \"\n \t     \"module \\\"%s\\\".\"),"
    },
    {
      "sha": "bce0f82a1ee272a363582418f2af29ee11081143",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -134,7 +134,7 @@ compile_object_run (compile_module_up &&module)\n \n   try\n     {\n-      struct type *func_type = SYMBOL_TYPE (func_sym);\n+      struct type *func_type = func_sym->type ();\n       int current_arg = 0;\n       struct value **vargs;\n "
    },
    {
      "sha": "18238db2c87283b210b3dbba0339801e3d03084c",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -220,7 +220,7 @@ cp_lookup_bare_symbol (const struct language_defn *langdef,\n \treturn {};\n \n \n-      type = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (lang_this.symbol)));\n+      type = check_typedef (TYPE_TARGET_TYPE (lang_this.symbol->type ()));\n       /* If TYPE_NAME is NULL, abandon trying to find this symbol.\n \t This can happen for lambda functions compiled with clang++,\n \t which outputs no name for the container class.  */\n@@ -274,7 +274,7 @@ cp_search_static_and_baseclasses (const char *name,\n   if (scope_sym.symbol == NULL)\n     return {};\n \n-  struct type *scope_type = SYMBOL_TYPE (scope_sym.symbol);\n+  struct type *scope_type = scope_sym.symbol->type ();\n \n   /* If the scope is a function/method, then look up NESTED as a local\n      static variable.  E.g., \"print 'function()::static_var'\".  */"
    },
    {
      "sha": "0be1a04852f9aa9b095526fdd75549102ea0477e",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -166,7 +166,7 @@ inspect_type (struct demangle_parse_info *info,\n \n   if (sym != NULL)\n     {\n-      struct type *otype = SYMBOL_TYPE (sym);\n+      struct type *otype = sym->type ();\n \n       if (finder != NULL)\n \t{\n@@ -512,7 +512,7 @@ replace_typedefs (struct demangle_parse_info *info,\n \n \t      if (sym != NULL)\n \t\t{\n-\t\t  struct type *otype = SYMBOL_TYPE (sym);\n+\t\t  struct type *otype = sym->type ();\n \t\t  const char *new_name = (*finder) (otype, data);\n \n \t\t  if (new_name != NULL)\n@@ -1215,7 +1215,7 @@ overload_list_add_symbol (struct symbol *sym,\n {\n   /* If there is no type information, we can't do anything, so\n      skip.  */\n-  if (SYMBOL_TYPE (sym) == NULL)\n+  if (sym->type () == NULL)\n     return;\n \n   /* skip any symbols that we've already considered.  */\n@@ -1507,7 +1507,7 @@ cp_lookup_rtti_type (const char *name, const struct block *block)\n       return NULL;\n     }\n \n-  rtti_type = check_typedef (SYMBOL_TYPE (rtti_sym));\n+  rtti_type = check_typedef (rtti_sym->type ());\n \n   switch (rtti_type->code ())\n     {"
    },
    {
      "sha": "5d965bb0e08cc98e3057e284c0001a8e919de297",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -452,7 +452,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n       sym->compute_and_set_names (name, false, ccp->of->per_bfd);\n       sym->set_aclass_index (LOC_CONST);\n       sym->set_domain (VAR_DOMAIN);\n-      SYMBOL_TYPE (sym) = fip->ptype;\n+      sym->set_type (fip->ptype);\n       add_symbol_to_list (sym, ccp->builder->get_global_symbols ());\n     }\n \n@@ -483,7 +483,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n       sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \n       if (type != nullptr)\n-\tSYMBOL_TYPE (sym) = type;\n+\tsym->set_type (type);\n \n       uint32_t kind = ctf_type_kind (fp, tid);\n       switch (kind)\n@@ -499,8 +499,8 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n \t    set_symbol_address (objfile, sym, sym->linkage_name ());\n \t    break;\n \t  case CTF_K_CONST:\n-\t    if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_VOID)\n-\t      SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_int;\n+\t    if (sym->type ()->code () == TYPE_CODE_VOID)\n+\t      sym->set_type (objfile_type (objfile)->builtin_int);\n \t    break;\n \t  case CTF_K_TYPEDEF:\n \t  case CTF_K_INTEGER:\n@@ -1169,7 +1169,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n \t  }\n \tsym = new (&ccp->of->objfile_obstack) symbol;\n \tOBJSTAT (ccp->of, n_syms++);\n-\tSYMBOL_TYPE (sym) = type;\n+\tsym->set_type (type);\n \tsym->set_domain (VAR_DOMAIN);\n \tsym->set_aclass_index (LOC_OPTIMIZED_OUT);\n \tsym->compute_and_set_names (name, false, ccp->of->per_bfd);\n@@ -1205,7 +1205,7 @@ add_stt_entries (struct ctf_context *ccp, int functions)\n \tcontinue;\n       sym = new (&ccp->of->objfile_obstack) symbol;\n       OBJSTAT (ccp->of, n_syms++);\n-      SYMBOL_TYPE (sym) = type;\n+      sym->set_type (type);\n       sym->set_domain (VAR_DOMAIN);\n       sym->set_aclass_index (LOC_STATIC);\n       sym->compute_and_set_names (tname, false, ccp->of->per_bfd);"
    },
    {
      "sha": "027a8fa206dab145a84d99cf116bbbdb7b792341",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1343,7 +1343,7 @@ classify_name (struct parser_state *par_state, const struct block *block)\n   sym = lookup_symbol (copy.c_str (), block, VAR_DOMAIN, &is_a_field_of_this);\n   if (sym.symbol && sym.symbol->aclass () == LOC_TYPEDEF)\n     {\n-      yylval.tsym.type = SYMBOL_TYPE (sym.symbol);\n+      yylval.tsym.type = sym.symbol->type ();\n       return TYPENAME;\n     }\n   else if (sym.symbol == NULL)\n@@ -1355,7 +1355,7 @@ classify_name (struct parser_state *par_state, const struct block *block)\n \n       if (sym.symbol != NULL)\n \t{\n-\t  yylval.tsym.type = SYMBOL_TYPE (sym.symbol);\n+\t  yylval.tsym.type = sym.symbol->type ();\n \t  return TYPENAME;\n \t}\n \n@@ -1390,7 +1390,7 @@ classify_inner_name (struct parser_state *par_state,\n \n   if (yylval.ssym.sym.symbol->aclass () == LOC_TYPEDEF)\n     {\n-      yylval.tsym.type = SYMBOL_TYPE (yylval.ssym.sym.symbol);\n+      yylval.tsym.type = yylval.ssym.sym.symbol->type ();\n       return TYPENAME;\n     }\n "
    },
    {
      "sha": "07c22e0eae54da4d081ff8a1e9acaeebba35c0a8",
      "filename": "gdb/d-namespace.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/d-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/d-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-namespace.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -130,7 +130,7 @@ d_lookup_symbol (const struct language_defn *langdef,\n \t  if (lang_this.symbol == NULL)\n \t    return {};\n \n-\t  type = check_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (lang_this.symbol)));\n+\t  type = check_typedef (TYPE_TARGET_TYPE (lang_this.symbol->type ()));\n \t  classname = type->name ();\n \t  nested = name;\n \t}\n@@ -151,7 +151,7 @@ d_lookup_symbol (const struct language_defn *langdef,\n \treturn {};\n \n       /* Look for a symbol named NESTED in this class.  */\n-      sym = d_lookup_nested_symbol (SYMBOL_TYPE (class_sym.symbol),\n+      sym = d_lookup_nested_symbol (class_sym.symbol->type (),\n \t\t\t\t    nested.c_str (), block);\n     }\n "
    },
    {
      "sha": "badc7f89078949fe97091ed538c4dc0a2dc2d500",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -744,7 +744,7 @@ func_addr_to_tail_call_list (struct gdbarch *gdbarch, CORE_ADDR addr)\n \t\t   \"name for address %s\"),\n \t\t paddress (gdbarch, addr));\n \n-  type = SYMBOL_TYPE (sym);\n+  type = sym->type ();\n   gdb_assert (type->code () == TYPE_CODE_FUNC);\n   gdb_assert (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_FUNC);\n \n@@ -783,7 +783,7 @@ func_verify_no_selftailcall (struct gdbarch *gdbarch, CORE_ADDR verify_addr)\n \n       func_sym = func_addr_to_tail_call_list (gdbarch, addr);\n \n-      for (call_site = TYPE_TAIL_CALL_LIST (SYMBOL_TYPE (func_sym));\n+      for (call_site = TYPE_TAIL_CALL_LIST (func_sym->type ());\n \t   call_site; call_site = call_site->tail_call_next)\n \t{\n \t  CORE_ADDR target_addr;\n@@ -985,7 +985,7 @@ call_site_find_chain_1 (struct gdbarch *gdbarch, CORE_ADDR caller_pc,\n \t  struct symbol *target_func;\n \n \t  target_func = func_addr_to_tail_call_list (gdbarch, target_func_addr);\n-\t  target_call_site = TYPE_TAIL_CALL_LIST (SYMBOL_TYPE (target_func));\n+\t  target_call_site = TYPE_TAIL_CALL_LIST (target_func->type ());\n \t}\n \n       do\n@@ -3019,7 +3019,7 @@ locexpr_read_variable (struct symbol *symbol, struct frame_info *frame)\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (symbol);\n   struct value *val;\n \n-  val = dwarf2_evaluate_loc_desc (SYMBOL_TYPE (symbol), frame, dlbaton->data,\n+  val = dwarf2_evaluate_loc_desc (symbol->type (), frame, dlbaton->data,\n \t\t\t\t  dlbaton->size, dlbaton->per_cu,\n \t\t\t\t  dlbaton->per_objfile);\n \n@@ -3036,7 +3036,7 @@ locexpr_read_variable_at_entry (struct symbol *symbol, struct frame_info *frame)\n   struct dwarf2_locexpr_baton *dlbaton\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (symbol);\n \n-  return value_of_dwarf_block_entry (SYMBOL_TYPE (symbol), frame, dlbaton->data,\n+  return value_of_dwarf_block_entry (symbol->type (), frame, dlbaton->data,\n \t\t\t\t     dlbaton->size);\n }\n \n@@ -3856,7 +3856,7 @@ loclist_read_variable (struct symbol *symbol, struct frame_info *frame)\n   CORE_ADDR pc = frame ? get_frame_address_in_block (frame) : 0;\n \n   data = dwarf2_find_location_expression (dlbaton, &size, pc);\n-  val = dwarf2_evaluate_loc_desc (SYMBOL_TYPE (symbol), frame, data, size,\n+  val = dwarf2_evaluate_loc_desc (symbol->type (), frame, data, size,\n \t\t\t\t  dlbaton->per_cu, dlbaton->per_objfile);\n \n   return val;\n@@ -3880,13 +3880,13 @@ loclist_read_variable_at_entry (struct symbol *symbol, struct frame_info *frame)\n   CORE_ADDR pc;\n \n   if (frame == NULL || !get_frame_func_if_available (frame, &pc))\n-    return allocate_optimized_out_value (SYMBOL_TYPE (symbol));\n+    return allocate_optimized_out_value (symbol->type ());\n \n   data = dwarf2_find_location_expression (dlbaton, &size, pc);\n   if (data == NULL)\n-    return allocate_optimized_out_value (SYMBOL_TYPE (symbol));\n+    return allocate_optimized_out_value (symbol->type ());\n \n-  return value_of_dwarf_block_entry (SYMBOL_TYPE (symbol), frame, data, size);\n+  return value_of_dwarf_block_entry (symbol->type (), frame, data, size);\n }\n \n /* Implementation of get_symbol_read_needs from"
    },
    {
      "sha": "3a22bcdd43d85c106b62ffa0ae668b73e8a64d72",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -8918,7 +8918,7 @@ fixup_go_packaging (struct dwarf2_cu *cu)\n \t e.g., \"main\" finds the \"main\" module and not C's main().  */\n       sym->set_domain (STRUCT_DOMAIN);\n       sym->set_aclass_index (LOC_TYPEDEF);\n-      SYMBOL_TYPE (sym) = type;\n+      sym->set_type (type);\n \n       add_symbol_to_list (sym, cu->get_builder ()->get_global_symbols ());\n     }\n@@ -21720,9 +21720,9 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       sym->set_domain (VAR_DOMAIN);\n       sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n       if (type != NULL)\n-\tSYMBOL_TYPE (sym) = type;\n+\tsym->set_type (type);\n       else\n-\tSYMBOL_TYPE (sym) = die_type (die, cu);\n+\tsym->set_type (die_type (die, cu));\n       attr = dwarf2_attr (die,\n \t\t\t  inlined_func ? DW_AT_call_line : DW_AT_decl_line,\n \t\t\t  cu);\n@@ -21764,7 +21764,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t    }\n \t  else\n \t    sym->set_aclass_index (LOC_OPTIMIZED_OUT);\n-\t  SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_core_addr;\n+\t  sym->set_type (objfile_type (objfile)->builtin_core_addr);\n \t  sym->set_domain (LABEL_DOMAIN);\n \t  add_symbol_to_list (sym, cu->list_in_scope);\n \t  break;\n@@ -21806,8 +21806,8 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  /* Compilation with minimal debug info may result in\n \t     variables with missing type entries.  Change the\n \t     misleading `void' type to something sensible.  */\n-\t  if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_VOID)\n-\t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_int;\n+\t  if (sym->type ()->code () == TYPE_CODE_VOID)\n+\t    sym->set_type (objfile_type (objfile)->builtin_int);\n \n \t  attr = dwarf2_attr (die, DW_AT_const_value, cu);\n \t  /* In the case of DW_TAG_member, we should only be called for\n@@ -21994,8 +21994,8 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t    /* The symbol's name is already allocated along\n \t\t       with this objfile, so we don't need to\n \t\t       duplicate it for the type.  */\n-\t\t    if (SYMBOL_TYPE (sym)->name () == 0)\n-\t\t      SYMBOL_TYPE (sym)->set_name (sym->search_name ());\n+\t\t    if (sym->type ()->name () == 0)\n+\t\t      sym->type ()->set_name (sym->search_name ());\n \t\t  }\n \t      }\n \t  }\n@@ -22230,7 +22230,7 @@ dwarf2_const_value (const struct attribute *attr, struct symbol *sym,\n   const gdb_byte *bytes;\n   struct dwarf2_locexpr_baton *baton;\n \n-  dwarf2_const_value_attr (attr, SYMBOL_TYPE (sym),\n+  dwarf2_const_value_attr (attr, sym->type (),\n \t\t\t   sym->print_name (),\n \t\t\t   &objfile->objfile_obstack, cu,\n \t\t\t   &value, &bytes, &baton);"
    },
    {
      "sha": "6ced0b261e78c7d37bdfd28345a1517f8dcb0385",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -564,7 +564,7 @@ evaluate_var_value (enum noside noside, const block *blk, symbol *var)\n       if (noside != EVAL_AVOID_SIDE_EFFECTS)\n \tthrow;\n \n-      ret = value_zero (SYMBOL_TYPE (var), not_lval);\n+      ret = value_zero (var->type (), not_lval);\n     }\n \n   return ret;\n@@ -580,7 +580,7 @@ var_value_operation::evaluate (struct type *expect_type,\n \t\t\t       enum noside noside)\n {\n   symbol *var = std::get<0> (m_storage).symbol;\n-  if (SYMBOL_TYPE (var)->code () == TYPE_CODE_ERROR)\n+  if (var->type ()->code () == TYPE_CODE_ERROR)\n     error_unknown_type (var->print_name ());\n   return evaluate_var_value (noside, std::get<0> (m_storage).block, var);\n }\n@@ -722,7 +722,7 @@ var_value_operation::evaluate_funcall (struct type *expect_type,\n \t\t       NULL, std::get<0> (m_storage).symbol,\n \t\t       NULL, &symp, NULL, 0, noside);\n \n-  if (SYMBOL_TYPE (symp)->code () == TYPE_CODE_ERROR)\n+  if (symp->type ()->code () == TYPE_CODE_ERROR)\n     error_unknown_type (symp->print_name ());\n   value *callee = evaluate_var_value (noside, std::get<0> (m_storage).block,\n \t\t\t\t      symp);\n@@ -1005,7 +1005,7 @@ eval_op_var_entry_value (struct type *expect_type, struct expression *exp,\n \t\t\t enum noside noside, symbol *sym)\n {\n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-    return value_zero (SYMBOL_TYPE (sym), not_lval);\n+    return value_zero (sym->type (), not_lval);\n \n   if (SYMBOL_COMPUTED_OPS (sym) == NULL\n       || SYMBOL_COMPUTED_OPS (sym)->read_variable_at_entry == NULL)\n@@ -2261,7 +2261,7 @@ adl_func_operation::evaluate (struct type *expect_type,\n \t\t       NON_METHOD,\n \t\t       nullptr, nullptr,\n \t\t       nullptr, &symp, nullptr, 0, noside);\n-  if (SYMBOL_TYPE (symp)->code () == TYPE_CODE_ERROR)\n+  if (symp->type ()->code () == TYPE_CODE_ERROR)\n     error_unknown_type (symp->print_name ());\n   value *callee = evaluate_var_value (noside, std::get<1> (m_storage), symp);\n   return evaluate_subexp_do_call (exp, noside, callee, args,\n@@ -2582,12 +2582,12 @@ var_value_operation::evaluate_for_address (struct expression *exp,\n \n   /* C++: The \"address\" of a reference should yield the address\n    * of the object pointed to.  Let value_addr() deal with it.  */\n-  if (TYPE_IS_REFERENCE (SYMBOL_TYPE (var)))\n+  if (TYPE_IS_REFERENCE (var->type ()))\n     return operation::evaluate_for_address (exp, noside);\n \n   if (noside == EVAL_AVOID_SIDE_EFFECTS)\n     {\n-      struct type *type = lookup_pointer_type (SYMBOL_TYPE (var));\n+      struct type *type = lookup_pointer_type (var->type ());\n       enum address_class sym_class = var->aclass ();\n \n       if (sym_class == LOC_CONST\n@@ -2606,7 +2606,7 @@ var_value_operation::evaluate_with_coercion (struct expression *exp,\n \t\t\t\t\t     enum noside noside)\n {\n   struct symbol *var = std::get<0> (m_storage).symbol;\n-  struct type *type = check_typedef (SYMBOL_TYPE (var));\n+  struct type *type = check_typedef (var->type ());\n   if (type->code () == TYPE_CODE_ARRAY\n       && !type->is_vector ()\n       && CAST_IS_CONVERSION (exp->language_defn))\n@@ -2735,7 +2735,7 @@ value *\n var_value_operation::evaluate_for_sizeof (struct expression *exp,\n \t\t\t\t\t  enum noside noside)\n {\n-  struct type *type = SYMBOL_TYPE (std::get<0> (m_storage).symbol);\n+  struct type *type = std::get<0> (m_storage).symbol->type ();\n   if (is_dynamic_type (type))\n     {\n       value *val = evaluate (nullptr, exp, EVAL_NORMAL);"
    },
    {
      "sha": "9cba30f68379f925520027d122089cd947c17a2e",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1489,7 +1489,7 @@ yylex (void)\n \t\t\t\tdomain, NULL);\n \tif (result.symbol && result.symbol->aclass () == LOC_TYPEDEF)\n \t  {\n-\t    yylval.tsym.type = SYMBOL_TYPE (result.symbol);\n+\t    yylval.tsym.type = result.symbol->type ();\n \t    return TYPENAME;\n \t  }\n "
    },
    {
      "sha": "47c98ab9793039397ad21fb4c2593a0e5f3a12da",
      "filename": "gdb/fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-tdep.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1952,9 +1952,9 @@ fbsd_fetch_rtld_offsets (struct gdbarch *gdbarch, struct fbsd_pspace_data *data)\n \t\t\t\t     language_c, NULL).symbol;\n       if (obj_entry_sym == NULL)\n \terror (_(\"Unable to find Struct_Obj_Entry symbol\"));\n-      data->off_linkmap = lookup_struct_elt (SYMBOL_TYPE (obj_entry_sym),\n+      data->off_linkmap = lookup_struct_elt (obj_entry_sym->type (),\n \t\t\t\t\t     \"linkmap\", 0).offset / 8;\n-      data->off_tlsindex = lookup_struct_elt (SYMBOL_TYPE (obj_entry_sym),\n+      data->off_tlsindex = lookup_struct_elt (obj_entry_sym->type (),\n \t\t\t\t\t      \"tlsindex\", 0).offset / 8;\n       data->rtld_offsets_valid = true;\n       return;"
    },
    {
      "sha": "1d22e645305e0bd6ddb0d55f226039e7db4cf5e1",
      "filename": "gdb/findvar.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/findvar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/findvar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/findvar.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -593,7 +593,7 @@ language_defn::read_var_value (struct symbol *var,\n \t\t\t       struct frame_info *frame) const\n {\n   struct value *v;\n-  struct type *type = SYMBOL_TYPE (var);\n+  struct type *type = var->type ();\n   CORE_ADDR addr;\n   enum symbol_needs_kind sym_need;\n "
    },
    {
      "sha": "ff07086b46f8ce10c0126277ef1fa46d84e040b3",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1691,7 +1691,7 @@ lookup_typename (const struct language_defn *language,\n   sym = lookup_symbol_in_language (name, block, VAR_DOMAIN,\n \t\t\t\t   language->la_language, NULL).symbol;\n   if (sym != NULL && sym->aclass () == LOC_TYPEDEF)\n-    return SYMBOL_TYPE (sym);\n+    return sym->type ();\n \n   if (noerr)\n     return NULL;\n@@ -1738,12 +1738,12 @@ lookup_struct (const char *name, const struct block *block)\n     {\n       error (_(\"No struct type named %s.\"), name);\n     }\n-  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n+  if (sym->type ()->code () != TYPE_CODE_STRUCT)\n     {\n       error (_(\"This context has class, union or enum %s, not a struct.\"),\n \t     name);\n     }\n-  return (SYMBOL_TYPE (sym));\n+  return (sym->type ());\n }\n \n /* Lookup a union type named \"union NAME\",\n@@ -1760,7 +1760,7 @@ lookup_union (const char *name, const struct block *block)\n   if (sym == NULL)\n     error (_(\"No union type named %s.\"), name);\n \n-  t = SYMBOL_TYPE (sym);\n+  t = sym->type ();\n \n   if (t->code () == TYPE_CODE_UNION)\n     return t;\n@@ -1783,12 +1783,12 @@ lookup_enum (const char *name, const struct block *block)\n     {\n       error (_(\"No enum type named %s.\"), name);\n     }\n-  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_ENUM)\n+  if (sym->type ()->code () != TYPE_CODE_ENUM)\n     {\n       error (_(\"This context has class, struct or union %s, not an enum.\"), \n \t     name);\n     }\n-  return (SYMBOL_TYPE (sym));\n+  return (sym->type ());\n }\n \n /* Lookup a template type named \"template NAME<TYPE>\",\n@@ -1813,12 +1813,12 @@ lookup_template_type (const char *name, struct type *type,\n     {\n       error (_(\"No template type named %s.\"), name);\n     }\n-  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n+  if (sym->type ()->code () != TYPE_CODE_STRUCT)\n     {\n       error (_(\"This context has class, union or enum %s, not a struct.\"),\n \t     name);\n     }\n-  return (SYMBOL_TYPE (sym));\n+  return (sym->type ());\n }\n \n /* See gdbtypes.h.  */\n@@ -2906,7 +2906,7 @@ check_typedef (struct type *type)\n \t    }\n \t  sym = lookup_symbol (name, 0, STRUCT_DOMAIN, 0).symbol;\n \t  if (sym)\n-\t    TYPE_TARGET_TYPE (type) = SYMBOL_TYPE (sym);\n+\t    TYPE_TARGET_TYPE (type) = sym->type ();\n \t  else\t\t\t\t\t/* TYPE_CODE_UNDEF */\n \t    TYPE_TARGET_TYPE (type) = alloc_type_arch (type->arch ());\n \t}\n@@ -3000,11 +3000,11 @@ check_typedef (struct type *type)\n \t  /* Same as above for opaque types, we can replace the stub\n \t     with the complete type only if they are in the same\n \t     objfile.  */\n-\t  if (SYMBOL_TYPE (sym)->objfile_owner () == type->objfile_owner ())\n-\t    type = make_qualified_type (SYMBOL_TYPE (sym),\n+\t  if (sym->type ()->objfile_owner () == type->objfile_owner ())\n+\t    type = make_qualified_type (sym->type (),\n \t\t\t\t\ttype->instance_flags (), type);\n \t  else\n-\t    type = SYMBOL_TYPE (sym);\n+\t    type = sym->type ();\n \t}\n     }\n "
    },
    {
      "sha": "0cbb8d0d3a63f1efa03cf9359684a8070b9d5475",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1071,7 +1071,7 @@ gnuv3_get_typeid_type (struct gdbarch *gdbarch)\n     typeinfo_type\n       = (struct type *) gdbarch_data (gdbarch, std_type_info_gdbarch_data);\n   else\n-    typeinfo_type = SYMBOL_TYPE (typeinfo);\n+    typeinfo_type = typeinfo->type ();\n \n   return typeinfo_type;\n }"
    },
    {
      "sha": "456920456cde957e45e1b40586de51e590208902",
      "filename": "gdb/go-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/go-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/go-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1339,7 +1339,7 @@ package_name_p (const char *name, const struct block *block)\n \n   if (sym\n       && sym->aclass () == LOC_TYPEDEF\n-      && SYMBOL_TYPE (sym)->code () == TYPE_CODE_MODULE)\n+      && sym->type ()->code () == TYPE_CODE_MODULE)\n     return 1;\n \n   return 0;"
    },
    {
      "sha": "4c28603fa63674660ed58c69dd984d5e6d2ef82f",
      "filename": "gdb/guile/scm-symbol.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/guile/scm-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/guile/scm-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-symbol.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -345,10 +345,10 @@ gdbscm_symbol_type (SCM self)\n     = syscm_get_valid_symbol_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   const struct symbol *symbol = s_smob->symbol;\n \n-  if (SYMBOL_TYPE (symbol) == NULL)\n+  if (symbol->type () == NULL)\n     return SCM_BOOL_F;\n \n-  return tyscm_scm_from_type (SYMBOL_TYPE (symbol));\n+  return tyscm_scm_from_type (symbol->type ());\n }\n \n /* (symbol-symtab <gdb:symbol>) -> <gdb:symtab> | #f"
    },
    {
      "sha": "b9fb121dbbe62015f88e78878ec5ac02bb28357a",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1567,7 +1567,7 @@ finish_command_fsm::should_stop (struct thread_info *tp)\n       /* We're done.  */\n       set_finished ();\n \n-      rv->type = TYPE_TARGET_TYPE (SYMBOL_TYPE (function));\n+      rv->type = TYPE_TARGET_TYPE (function->type ());\n       if (rv->type == NULL)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"finish_command: function has no target type\"));\n@@ -1803,7 +1803,7 @@ finish_command (const char *arg, int from_tty)\n \tprintf_filtered (_(\"Run back to call of \"));\n       else\n \t{\n-\t  if (sm->function != NULL && TYPE_NO_RETURN (sm->function->type)\n+\t  if (sm->function != NULL && TYPE_NO_RETURN (sm->function->type ())\n \t      && !query (_(\"warning: Function %s does not return normally.\\n\"\n \t\t\t   \"Try to finish anyway? \"),\n \t\t\t sm->function->print_name ()))"
    },
    {
      "sha": "7819d763ab3b061a673cb90682c2ab43cc2e75e3",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -562,7 +562,7 @@ finalize_symtab (struct gdb_symtab *stab, struct objfile *objfile)\n       block_name->set_domain (VAR_DOMAIN);\n       block_name->set_aclass_index (LOC_BLOCK);\n       symbol_set_symtab (block_name, filetab);\n-      SYMBOL_TYPE (block_name) = lookup_function_type (block_type);\n+      block_name->set_type (lookup_function_type (block_type));\n       SYMBOL_BLOCK_VALUE (block_name) = new_block;\n \n       block_name->m_name = obstack_strdup (&objfile->objfile_obstack,"
    },
    {
      "sha": "69c73b0318e1b46db6ffc0eb8bc125aac0cf65bf",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -975,7 +975,7 @@ language_arch_info::bool_type () const\n       sym = lookup_symbol (m_bool_type_name, NULL, VAR_DOMAIN, NULL).symbol;\n       if (sym != nullptr)\n \t{\n-\t  struct type *type = SYMBOL_TYPE (sym);\n+\t  struct type *type = sym->type ();\n \t  if (type != nullptr && type->code () == TYPE_CODE_BOOL)\n \t    return type;\n \t}\n@@ -1000,7 +1000,7 @@ language_arch_info::type_and_symbol::alloc_type_symbol\n   symbol->owner.arch = gdbarch;\n   symbol->set_is_objfile_owned (0);\n   symbol->set_section_index (0);\n-  SYMBOL_TYPE (symbol) = type;\n+  symbol->set_type (type);\n   symbol->set_domain (VAR_DOMAIN);\n   symbol->set_aclass_index (LOC_TYPEDEF);\n   return symbol;"
    },
    {
      "sha": "a8ae5943811a7c311b23b4ef60485efe216949cd",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -3494,7 +3494,7 @@ decode_compound_collector::operator () (block_symbol *bsym)\n   if (sym->aclass () != LOC_TYPEDEF)\n     return true; /* Continue iterating.  */\n \n-  t = SYMBOL_TYPE (sym);\n+  t = sym->type ();\n   t = check_typedef (t);\n   if (t->code () != TYPE_CODE_STRUCT\n       && t->code () != TYPE_CODE_UNION\n@@ -3686,7 +3686,7 @@ find_method (struct linespec_state *self,\n       pspace = symbol_symtab (sym)->pspace ();\n       gdb_assert (!pspace->executing_startup);\n       set_current_program_space (pspace);\n-      t = check_typedef (SYMBOL_TYPE (sym));\n+      t = check_typedef (sym->type ());\n       find_methods (t, sym->language (),\n \t\t    method_name, &result_names, &superclass_vec);\n "
    },
    {
      "sha": "7607fd753c5a616cdd8e2889c24072eb0d0ca5a6",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -163,8 +163,8 @@ m2_language::print_typedef (struct type *type, struct symbol *new_symbol,\n {\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"TYPE \");\n-  if (!SYMBOL_TYPE (new_symbol)->name ()\n-      || strcmp ((SYMBOL_TYPE (new_symbol))->name (),\n+  if (!new_symbol->type ()->name ()\n+      || strcmp ((new_symbol->type ())->name (),\n \t\t new_symbol->linkage_name ()) != 0)\n     fprintf_filtered (stream, \"%s = \", new_symbol->print_name ());\n   else"
    },
    {
      "sha": "8ede3d6aa269bb4bd45933137b8432d420a0d6c9",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -569,9 +569,9 @@ add_data_symbol (SYMR *sh, union aux_ext *ax, int bigend,\n   /* Type could be missing if file is compiled without debugging info.  */\n   if (SC_IS_UNDEF (sh->sc)\n       || sh->sc == scNil || sh->index == indexNil)\n-    SYMBOL_TYPE (s) = objfile_type (objfile)->nodebug_data_symbol;\n+    s->set_type (objfile_type (objfile)->nodebug_data_symbol);\n   else\n-    SYMBOL_TYPE (s) = parse_type (cur_fd, ax, sh->index, 0, bigend, name);\n+    s->set_type (parse_type (cur_fd, ax, sh->index, 0, bigend, name));\n   /* Value of a data symbol is its memory address.  */\n }\n \n@@ -697,7 +697,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t  break;\n \t}\n       SYMBOL_VALUE (s) = svalue;\n-      SYMBOL_TYPE (s) = parse_type (cur_fd, ax, sh->index, 0, bigend, name);\n+      s->set_type (parse_type (cur_fd, ax, sh->index, 0, bigend, name));\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n       break;\n \n@@ -706,7 +706,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       s->set_domain (VAR_DOMAIN);\t/* So that it can be used */\n       s->set_aclass_index (LOC_LABEL);\t/* but not misused.  */\n       SET_SYMBOL_VALUE_ADDRESS (s, (CORE_ADDR) sh->value);\n-      SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_int;\n+      s->set_type (objfile_type (objfile)->builtin_int);\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n       break;\n \n@@ -787,12 +787,12 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       add_symbol (s, top_stack->cur_st, b);\n \n       /* Make a type for the procedure itself.  */\n-      SYMBOL_TYPE (s) = lookup_function_type (t);\n+      s->set_type (lookup_function_type (t));\n \n       /* All functions in C++ have prototypes.  For C we don't have enough\n \t information in the debug info.  */\n       if (s->language () == language_cplus)\n-\tSYMBOL_TYPE (s)->set_is_prototyped (true);\n+\ts->type ()->set_is_prototyped (true);\n \n       /* Create and enter a new lexical context.  */\n       b = new_block (FUNCTION_BLOCK, s->language ());\n@@ -809,7 +809,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       push_parse_stack ();\n       top_stack->cur_block = b;\n       top_stack->blocktype = sh->st;\n-      top_stack->cur_type = SYMBOL_TYPE (s);\n+      top_stack->cur_type = s->type ();\n       top_stack->cur_field = -1;\n       top_stack->procadr = sh->value;\n       top_stack->numargs = 0;\n@@ -1066,7 +1066,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t\t  (obstack_strdup (&mdebugread_objfile->objfile_obstack,\n \t\t\t\t   f->name ()));\n \t\tenum_sym->set_aclass_index (LOC_CONST);\n-\t\tSYMBOL_TYPE (enum_sym) = t;\n+\t\tenum_sym->set_type (t);\n \t\tenum_sym->set_domain (VAR_DOMAIN);\n \t\tSYMBOL_VALUE (enum_sym) = tsym.value;\n \t\tif (SYMBOL_VALUE (enum_sym) < 0)\n@@ -1100,7 +1100,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \ts->set_domain (STRUCT_DOMAIN);\n \ts->set_aclass_index (LOC_TYPEDEF);\n \tSYMBOL_VALUE (s) = 0;\n-\tSYMBOL_TYPE (s) = t;\n+\ts->set_type (t);\n \tadd_symbol (s, top_stack->cur_st, top_stack->cur_block);\n \tbreak;\n \n@@ -1156,7 +1156,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t  s = new_symbol (MDEBUG_EFI_SYMBOL_NAME);\n \t  s->set_domain (LABEL_DOMAIN);\n \t  s->set_aclass_index (LOC_CONST);\n-\t  SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->builtin_void;\n+\t  s->set_type (objfile_type (mdebugread_objfile)->builtin_void);\n \t  e = OBSTACK_ZALLOC (&mdebugread_objfile->objfile_obstack,\n \t\t\t      mdebug_extra_func_info);\n \t  SYMBOL_VALUE_BYTES (s) = (gdb_byte *) e;\n@@ -1204,7 +1204,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n \t\t      if (sym->is_argument ())\n \t\t\t{\n-\t\t\t  ftype->field (iparams).set_type (SYMBOL_TYPE (sym));\n+\t\t\t  ftype->field (iparams).set_type (sym->type ());\n \t\t\t  TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;\n \t\t\t  iparams++;\n \t\t\t}\n@@ -1298,17 +1298,17 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       s->set_domain (VAR_DOMAIN);\n       s->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_BLOCK_VALUE (s) = top_stack->cur_block;\n-      SYMBOL_TYPE (s) = t;\n+      s->set_type (t);\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n \n       /* Incomplete definitions of structs should not get a name.  */\n-      if (SYMBOL_TYPE (s)->name () == NULL\n-\t  && (SYMBOL_TYPE (s)->num_fields () != 0\n-\t      || (SYMBOL_TYPE (s)->code () != TYPE_CODE_STRUCT\n-\t\t  && SYMBOL_TYPE (s)->code () != TYPE_CODE_UNION)))\n+      if (s->type ()->name () == NULL\n+\t  && (s->type ()->num_fields () != 0\n+\t      || (s->type ()->code () != TYPE_CODE_STRUCT\n+\t\t  && s->type ()->code () != TYPE_CODE_UNION)))\n \t{\n-\t  if (SYMBOL_TYPE (s)->code () == TYPE_CODE_PTR\n-\t      || SYMBOL_TYPE (s)->code () == TYPE_CODE_FUNC)\n+\t  if (s->type ()->code () == TYPE_CODE_PTR\n+\t      || s->type ()->code () == TYPE_CODE_FUNC)\n \t    {\n \t      /* If we are giving a name to a type such as \"pointer to\n \t\t foo\" or \"function returning foo\", we better not set\n@@ -1330,7 +1330,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t\t for anything except pointers or functions.  */\n \t    }\n \t  else\n-\t    SYMBOL_TYPE (s)->set_name (s->linkage_name ());\n+\t    s->type ()->set_name (s->linkage_name ());\n \t}\n       break;\n \n@@ -1990,7 +1990,7 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n       s->set_domain (VAR_DOMAIN);\n       SYMBOL_CLASS (s) = LOC_BLOCK;\n       /* Don't know its type, hope int is ok.  */\n-      SYMBOL_TYPE (s)\n+      s->type ()\n \t= lookup_function_type (objfile_type (pst->objfile)->builtin_int);\n       add_symbol (s, top_stack->cur_st, top_stack->cur_block);\n       /* Won't have symbols for this one.  */\n@@ -2044,8 +2044,8 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n \n   if (processing_gcc_compilation == 0\n       && found_ecoff_debugging_info == 0\n-      && TYPE_TARGET_TYPE (SYMBOL_TYPE (s))->code () == TYPE_CODE_VOID)\n-    SYMBOL_TYPE (s) = objfile_type (mdebugread_objfile)->nodebug_text_symbol;\n+      && TYPE_TARGET_TYPE (s->type ())->code () == TYPE_CODE_VOID)\n+    s->set_type (objfile_type (mdebugread_objfile)->nodebug_text_symbol);\n }\n \n /* Parse the external symbol ES.  Just call parse_symbol() after\n@@ -3989,7 +3989,7 @@ mdebug_expand_psymtab (legacy_psymtab *pst, struct objfile *objfile)\n \n \t\t  s->set_domain (LABEL_DOMAIN);\n \t\t  s->set_aclass_index (LOC_CONST);\n-\t\t  SYMBOL_TYPE (s) = objfile_type (objfile)->builtin_void;\n+\t\t  s->set_type (objfile_type (objfile)->builtin_void);\n \t\t  SYMBOL_VALUE_BYTES (s) = (gdb_byte *) e;\n \t\t  e->pdr.framereg = -1;\n \t\t  add_symbol_to_list (s, get_local_symbols ());"
    },
    {
      "sha": "e63f1706149754603d3eb6fbead0abbe07686235",
      "filename": "gdb/mi/mi-cmd-stack.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mi/mi-cmd-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mi/mi-cmd-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmd-stack.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -525,8 +525,8 @@ list_arg_or_local (const struct frame_arg *arg, enum what_to_list what,\n \n   if (values == PRINT_SIMPLE_VALUES)\n     {\n-      check_typedef (arg->sym->type);\n-      type_print (arg->sym->type, \"\", &stb, -1);\n+      check_typedef (arg->sym->type ());\n+      type_print (arg->sym->type (), \"\", &stb, -1);\n       uiout->field_stream (\"type\", stb);\n     }\n \n@@ -648,7 +648,7 @@ list_args_or_locals (const frame_print_options &fp_opts,\n \t      switch (values)\n \t\t{\n \t\tcase PRINT_SIMPLE_VALUES:\n-\t\t  type = check_typedef (sym2->type);\n+\t\t  type = check_typedef (sym2->type ());\n \t\t  if (type->code () != TYPE_CODE_ARRAY\n \t\t      && type->code () != TYPE_CODE_STRUCT\n \t\t      && type->code () != TYPE_CODE_UNION)"
    },
    {
      "sha": "6ed26d69269d63cb3834c8ab0701be9a796c5342",
      "filename": "gdb/mi/mi-symbol-cmds.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mi/mi-symbol-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/mi/mi-symbol-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-symbol-cmds.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -81,7 +81,7 @@ output_debug_symbol (ui_out *uiout, enum search_domain kind,\n   if (kind == FUNCTIONS_DOMAIN || kind == VARIABLES_DOMAIN)\n     {\n       string_file tmp_stream;\n-      type_print (SYMBOL_TYPE (sym), \"\", &tmp_stream, -1);\n+      type_print (sym->type (), \"\", &tmp_stream, -1);\n       uiout->field_string (\"type\", tmp_stream.string ());\n \n       std::string str = symbol_to_info_string (sym, block, kind);"
    },
    {
      "sha": "3bb9588ad480819b514846c42f030d2ff4f32f8a",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -96,7 +96,7 @@ lookup_struct_typedef (const char *name, const struct block *block, int noerr)\n       else \n \terror (_(\"No struct type named %s.\"), name);\n     }\n-  if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_STRUCT)\n+  if (sym->type ()->code () != TYPE_CODE_STRUCT)\n     {\n       if (noerr)\n \treturn 0;\n@@ -210,7 +210,7 @@ value_nsstring (struct gdbarch *gdbarch, const char *ptr, int len)\n   if (sym == NULL)\n     type = builtin_type (gdbarch)->builtin_data_ptr;\n   else\n-    type = lookup_pointer_type(SYMBOL_TYPE (sym));\n+    type = lookup_pointer_type(sym->type ());\n \n   deprecated_set_value_type (nsstringValue, type);\n   return nsstringValue;"
    },
    {
      "sha": "024a335453a1d627c665925f982e9fc5eacc23e5",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -690,7 +690,7 @@ variable:\tname_not_typename\n \t\t\t\tpstate->block_tracker->update (sym);\n \n \t\t\t      pstate->push_new<var_value_operation> (sym);\n-\t\t\t      current_type = sym.symbol->type; }\n+\t\t\t      current_type = sym.symbol->type (); }\n \t\t\t  else if ($1.is_a_field_of_this)\n \t\t\t    {\n \t\t\t      struct value * this_val;\n@@ -1640,9 +1640,9 @@ yylex (void)\n \t\tbreak;\n \t    }\n \n-\t  yylval.tsym.type = SYMBOL_TYPE (best_sym);\n+\t  yylval.tsym.type = best_sym->type ();\n #else /* not 0 */\n-\t  yylval.tsym.type = SYMBOL_TYPE (sym);\n+\t  yylval.tsym.type = sym->type ();\n #endif /* not 0 */\n \t  free (uptokstart);\n \t  return TYPENAME;"
    },
    {
      "sha": "8334ab9fe8443f1a2c7f18e69417ec5e8f0949e4",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -255,7 +255,7 @@ pascal_language::value_print_inner (struct value *val,\n \n \t      if (wsym)\n \t\t{\n-\t\t  wtype = SYMBOL_TYPE (wsym);\n+\t\t  wtype = wsym->type ();\n \t\t}\n \t      else\n \t\t{"
    },
    {
      "sha": "77e19f6deee24ebd5b5d8ea6ccec473b1969032f",
      "filename": "gdb/python/py-finishbreakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-finishbreakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-finishbreakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-finishbreakpoint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -250,7 +250,7 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t  if (function != NULL)\n \t    {\n \t      struct type *ret_type =\n-\t\tcheck_typedef (TYPE_TARGET_TYPE (SYMBOL_TYPE (function)));\n+\t\tcheck_typedef (TYPE_TARGET_TYPE (function->type ()));\n \n \t      /* Remember only non-void return types.  */\n \t      if (ret_type->code () != TYPE_CODE_VOID)"
    },
    {
      "sha": "747da481a1bf7bc17394fceb22ef06456a9788dd",
      "filename": "gdb/python/py-symbol.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-symbol.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -72,13 +72,13 @@ sympy_get_type (PyObject *self, void *closure)\n \n   SYMPY_REQUIRE_VALID (self, symbol);\n \n-  if (SYMBOL_TYPE (symbol) == NULL)\n+  if (symbol->type () == NULL)\n     {\n       Py_INCREF (Py_None);\n       return Py_None;\n     }\n \n-  return type_to_type_object (SYMBOL_TYPE (symbol));\n+  return type_to_type_object (symbol->type ());\n }\n \n static PyObject *"
    },
    {
      "sha": "9df667d2811df9c4df927e4fb4c4aedcc782461e",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -998,7 +998,7 @@ typy_template_argument (PyObject *self, PyObject *args)\n \n   sym = TYPE_TEMPLATE_ARGUMENT (type, argno);\n   if (sym->aclass () == LOC_TYPEDEF)\n-    return type_to_type_object (SYMBOL_TYPE (sym));\n+    return type_to_type_object (sym->type ());\n   else if (sym->aclass () == LOC_OPTIMIZED_OUT)\n     {\n       PyErr_Format (PyExc_RuntimeError,"
    },
    {
      "sha": "7584d2572fae148e31e2f8de44fd896b7118c25a",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1511,7 +1511,7 @@ rust_structop::evaluate_funcall (struct type *expect_type,\n   if (sym.symbol == NULL)\n     error (_(\"Could not find function named '%s'\"), name.c_str ());\n \n-  struct type *fn_type = SYMBOL_TYPE (sym.symbol);\n+  struct type *fn_type = sym.symbol->type ();\n   if (fn_type->num_fields () == 0)\n     error (_(\"Function '%s' takes no arguments\"), name.c_str ());\n "
    },
    {
      "sha": "1f75b4290c26bee8ceae75172946a73e59cd7edb",
      "filename": "gdb/rust-parse.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/rust-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/rust-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-parse.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -458,7 +458,7 @@ rust_parser::rust_lookup_type (const char *name)\n   if (result.symbol != NULL)\n     {\n       update_innermost_block (result);\n-      return SYMBOL_TYPE (result.symbol);\n+      return result.symbol->type ();\n     }\n \n   type = lookup_typename (language (), name, NULL, 1);\n@@ -1218,7 +1218,7 @@ rust_parser::name_to_operation (const std::string &name)\n   if (sym.symbol != nullptr)\n     {\n       gdb_assert (sym.symbol->aclass () == LOC_TYPEDEF);\n-      type = SYMBOL_TYPE (sym.symbol);\n+      type = sym.symbol->type ();\n     }\n   if (type == nullptr)\n     type = rust_lookup_type (name.c_str ());"
    },
    {
      "sha": "03242ed9866f76bdbb38e70f269913ea32fbeeab",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1234,7 +1234,7 @@ sparc_frame_cache (struct frame_info *this_frame, void **this_cache)\n static int\n sparc32_struct_return_from_sym (struct symbol *sym)\n {\n-  struct type *type = check_typedef (SYMBOL_TYPE (sym));\n+  struct type *type = check_typedef (sym->type ());\n   enum type_code code = type->code ();\n \n   if (code == TYPE_CODE_FUNC || code == TYPE_CODE_METHOD)"
    },
    {
      "sha": "d3a1ae99069155ca0dc1e39c547d86839e3d0cfa",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 76,
      "deletions": 76,
      "changes": 152,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -434,12 +434,12 @@ patch_block_stabs (struct pending *symbols, struct pending_stabs *stabs,\n \t\t  /* I don't think the linker does this with functions,\n \t\t     so as far as I know this is never executed.\n \t\t     But it doesn't hurt to check.  */\n-\t\t  SYMBOL_TYPE (sym) =\n-\t\t    lookup_function_type (read_type (&pp, objfile));\n+\t\t  sym->set_type\n+\t\t    (lookup_function_type (read_type (&pp, objfile)));\n \t\t}\n \t      else\n \t\t{\n-\t\t  SYMBOL_TYPE (sym) = read_type (&pp, objfile);\n+\t\t  sym->set_type (read_type (&pp, objfile));\n \t\t}\n \t      add_symbol_to_list (sym, get_global_symbols ());\n \t    }\n@@ -448,12 +448,12 @@ patch_block_stabs (struct pending *symbols, struct pending_stabs *stabs,\n \t      pp += 2;\n \t      if (*(pp - 1) == 'F' || *(pp - 1) == 'f')\n \t\t{\n-\t\t  SYMBOL_TYPE (sym) =\n-\t\t    lookup_function_type (read_type (&pp, objfile));\n+\t\t  sym->set_type\n+\t\t    (lookup_function_type (read_type (&pp, objfile)));\n \t\t}\n \t      else\n \t\t{\n-\t\t  SYMBOL_TYPE (sym) = read_type (&pp, objfile);\n+\t\t  sym->set_type (read_type (&pp, objfile));\n \t\t}\n \t    }\n \t}\n@@ -784,7 +784,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       if (*p != '=')\n \t{\n \t  sym->set_aclass_index (LOC_CONST);\n-\t  SYMBOL_TYPE (sym) = error_type (&p, objfile);\n+\t  sym->set_type (error_type (&p, objfile));\n \t  sym->set_domain (VAR_DOMAIN);\n \t  add_symbol_to_list (sym, get_file_symbols ());\n \t  return sym;\n@@ -804,7 +804,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t    target_float_from_string (dbl_valu, dbl_type, std::string (p));\n \n-\t    SYMBOL_TYPE (sym) = dbl_type;\n+\t    sym->set_type (dbl_type);\n \t    SYMBOL_VALUE_BYTES (sym) = dbl_valu;\n \t    sym->set_aclass_index (LOC_CONST_BYTES);\n \t  }\n@@ -818,15 +818,15 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t       types; other languages probably should have at least\n \t       unsigned as well as signed constants.  */\n \n-\t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_long;\n+\t    sym->set_type (objfile_type (objfile)->builtin_long);\n \t    SYMBOL_VALUE (sym) = atoi (p);\n \t    sym->set_aclass_index (LOC_CONST);\n \t  }\n \t  break;\n \n \tcase 'c':\n \t  {\n-\t    SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_char;\n+\t    sym->set_type (objfile_type (objfile)->builtin_char);\n \t    SYMBOL_VALUE (sym) = atoi (p);\n \t    sym->set_aclass_index (LOC_CONST);\n \t  }\n@@ -843,7 +843,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t    if (quote != '\\'' && quote != '\"')\n \t      {\n \t\tsym->set_aclass_index (LOC_CONST);\n-\t\tSYMBOL_TYPE (sym) = error_type (&p, objfile);\n+\t\tsym->set_type (error_type (&p, objfile));\n \t\tsym->set_domain (VAR_DOMAIN);\n \t\tadd_symbol_to_list (sym, get_file_symbols ());\n \t\treturn sym;\n@@ -868,7 +868,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t    if (*p != quote)\n \t      {\n \t\tsym->set_aclass_index (LOC_CONST);\n-\t\tSYMBOL_TYPE (sym) = error_type (&p, objfile);\n+\t\tsym->set_type (error_type (&p, objfile));\n \t\tsym->set_domain (VAR_DOMAIN);\n \t\tadd_symbol_to_list (sym, get_file_symbols ());\n \t\treturn sym;\n@@ -880,9 +880,9 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t      = create_static_range_type (NULL,\n \t\t\t\t\t  objfile_type (objfile)->builtin_int,\n \t\t\t\t\t  0, ind);\n-\t    SYMBOL_TYPE (sym) = create_array_type (NULL,\n-\t\t\t\t  objfile_type (objfile)->builtin_char,\n-\t\t\t\t  range_type);\n+\t    sym->set_type\n+\t      (create_array_type (NULL, objfile_type (objfile)->builtin_char,\n+\t\t\t\t  range_type));\n \t    string_value\n \t      = (gdb_byte *) obstack_alloc (&objfile->objfile_obstack, ind + 1);\n \t    memcpy (string_value, string_local, ind + 1);\n@@ -900,11 +900,11 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t     (where type 6 is defined by \"blobs:t6=eblob1:0,blob2:1,;\").  */\n \t  {\n \t    sym->set_aclass_index (LOC_CONST);\n-\t    SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+\t    sym->set_type (read_type (&p, objfile));\n \n \t    if (*p != ',')\n \t      {\n-\t\tSYMBOL_TYPE (sym) = error_type (&p, objfile);\n+\t\tsym->set_type (error_type (&p, objfile));\n \t\tbreak;\n \t      }\n \t    ++p;\n@@ -921,7 +921,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \tdefault:\n \t  {\n \t    sym->set_aclass_index (LOC_CONST);\n-\t    SYMBOL_TYPE (sym) = error_type (&p, objfile);\n+\t    sym->set_type (error_type (&p, objfile));\n \t  }\n \t}\n       sym->set_domain (VAR_DOMAIN);\n@@ -930,7 +930,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'C':\n       /* The name of a caught exception.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_LABEL);\n       sym->set_domain (VAR_DOMAIN);\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n@@ -939,7 +939,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'f':\n       /* A static function definition.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_BLOCK);\n       sym->set_domain (VAR_DOMAIN);\n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -949,24 +949,24 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       /* Function result types are described as the result type in stabs.\n \t We need to convert this to the function-returning-type-X type\n \t in GDB.  E.g. \"int\" is converted to \"function returning int\".  */\n-      if (SYMBOL_TYPE (sym)->code () != TYPE_CODE_FUNC)\n-\tSYMBOL_TYPE (sym) = lookup_function_type (SYMBOL_TYPE (sym));\n+      if (sym->type ()->code () != TYPE_CODE_FUNC)\n+\tsym->set_type (lookup_function_type (sym->type ()));\n \n       /* All functions in C++ have prototypes.  Stabs does not offer an\n \t explicit way to identify prototyped or unprototyped functions,\n \t but both GCC and Sun CC emit stabs for the \"call-as\" type rather\n \t than the \"declared-as\" type for unprototyped functions, so\n \t we treat all functions as if they were prototyped.  This is used\n \t primarily for promotion when calling the function from GDB.  */\n-      SYMBOL_TYPE (sym)->set_is_prototyped (true);\n+      sym->type ()->set_is_prototyped (true);\n \n       /* fall into process_prototype_types.  */\n \n     process_prototype_types:\n       /* Sun acc puts declared types of arguments here.  */\n       if (*p == ';')\n \t{\n-\t  struct type *ftype = SYMBOL_TYPE (sym);\n+\t  struct type *ftype = sym->type ();\n \t  int nsemi = 0;\n \t  int nparams = 0;\n \t  const char *p1 = p;\n@@ -1011,7 +1011,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'F':\n       /* A global function definition.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_BLOCK);\n       sym->set_domain (VAR_DOMAIN);\n       add_symbol_to_list (sym, get_global_symbols ());\n@@ -1022,7 +1022,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t value is not correct.  It is necessary to search for the\n \t corresponding linker definition to find the value.\n \t These definitions appear at the end of the namelist.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_STATIC);\n       sym->set_domain (VAR_DOMAIN);\n       /* Don't add symbol references to global_sym_chain.\n@@ -1043,7 +1043,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t Dbx data never actually contains 'l'.  */\n     case 's':\n     case 'l':\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_LOCAL);\n       SYMBOL_VALUE (sym) = valu;\n       sym->set_domain (VAR_DOMAIN);\n@@ -1057,12 +1057,12 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t   Translate it into a pointer-to-function type.  */\n \t{\n \t  p++;\n-\t  SYMBOL_TYPE (sym)\n-\t    = lookup_pointer_type\n-\t    (lookup_function_type (read_type (&p, objfile)));\n+\t  sym->set_type\n+\t    (lookup_pointer_type\n+\t       (lookup_function_type (read_type (&p, objfile))));\n \t}\n       else\n-\tSYMBOL_TYPE (sym) = read_type (&p, objfile);\n+\tsym->set_type (read_type (&p, objfile));\n \n       sym->set_aclass_index (LOC_ARG);\n       SYMBOL_VALUE (sym) = valu;\n@@ -1086,12 +1086,12 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t{\n \t  /* If PCC says a parameter is a short or a char, it is\n \t     really an int.  */\n-\t  if (TYPE_LENGTH (SYMBOL_TYPE (sym))\n+\t  if (TYPE_LENGTH (sym->type ())\n \t      < gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT\n-\t      && SYMBOL_TYPE (sym)->code () == TYPE_CODE_INT)\n+\t      && sym->type ()->code () == TYPE_CODE_INT)\n \t    {\n-\t      SYMBOL_TYPE (sym) =\n-\t\t(SYMBOL_TYPE (sym)->is_unsigned ()\n+\t      sym->set_type\n+\t\t(sym->type ()->is_unsigned ()\n \t\t ? objfile_type (objfile)->builtin_unsigned_int\n \t\t : objfile_type (objfile)->builtin_int);\n \t    }\n@@ -1105,14 +1105,14 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t with this extra information.  FIXME, it ought to.  */\n       if (type == N_FUN)\n \t{\n-\t  SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+\t  sym->set_type (read_type (&p, objfile));\n \t  goto process_prototype_types;\n \t}\n       /*FALLTHROUGH */\n \n     case 'R':\n       /* Parameter which is in a register.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (stab_register_index);\n       sym->set_is_argument (1);\n       SYMBOL_VALUE (sym) = valu;\n@@ -1122,7 +1122,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'r':\n       /* Register variable (either global or local).  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (stab_register_index);\n       SYMBOL_VALUE (sym) = valu;\n       sym->set_domain (VAR_DOMAIN);\n@@ -1150,7 +1150,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  struct pending *local_symbols = *get_local_symbols ();\n \t  if (local_symbols\n \t      && local_symbols->nsyms > 0\n-\t      && gdbarch_stabs_argument_has_addr (gdbarch, SYMBOL_TYPE (sym)))\n+\t      && gdbarch_stabs_argument_has_addr (gdbarch, sym->type ()))\n \t    {\n \t      struct symbol *prev_sym;\n \n@@ -1163,7 +1163,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t\t  prev_sym->set_aclass_index (stab_register_index);\n \t\t  /* Use the type from the LOC_REGISTER; that is the type\n \t\t     that is actually in that register.  */\n-\t\t  SYMBOL_TYPE (prev_sym) = SYMBOL_TYPE (sym);\n+\t\t  prev_sym->set_type (sym->type ());\n \t\t  SYMBOL_VALUE (prev_sym) = SYMBOL_VALUE (sym);\n \t\t  sym = prev_sym;\n \t\t  break;\n@@ -1177,7 +1177,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'S':\n       /* Static symbol at top level of file.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_STATIC);\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       sym->set_domain (VAR_DOMAIN);\n@@ -1202,7 +1202,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       synonym = (sym->language () == language_ada && p[-2] != 'T');\n \n       /* Typedef */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n \n       /* For a nameless type, we don't want a create a symbol, thus we\n \t did not use `sym'.  Return without further processing.  */\n@@ -1216,24 +1216,24 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t a base type which did not have its name defined when the\n \t derived class was output.  We fill in the derived class's\n \t base part member's name here in that case.  */\n-      if (SYMBOL_TYPE (sym)->name () != NULL)\n-\tif ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_STRUCT\n-\t     || SYMBOL_TYPE (sym)->code () == TYPE_CODE_UNION)\n-\t    && TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)))\n+      if (sym->type ()->name () != NULL)\n+\tif ((sym->type ()->code () == TYPE_CODE_STRUCT\n+\t     || sym->type ()->code () == TYPE_CODE_UNION)\n+\t    && TYPE_N_BASECLASSES (sym->type ()))\n \t  {\n \t    int j;\n \n-\t    for (j = TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)) - 1; j >= 0; j--)\n-\t      if (TYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) == 0)\n-\t\tSYMBOL_TYPE (sym)->field (j).set_name\n-\t\t  (TYPE_BASECLASS (SYMBOL_TYPE (sym), j)->name ());\n+\t    for (j = TYPE_N_BASECLASSES (sym->type ()) - 1; j >= 0; j--)\n+\t      if (TYPE_BASECLASS_NAME (sym->type (), j) == 0)\n+\t\tsym->type ()->field (j).set_name\n+\t\t  (TYPE_BASECLASS (sym->type (), j)->name ());\n \t  }\n \n-      if (SYMBOL_TYPE (sym)->name () == NULL)\n+      if (sym->type ()->name () == NULL)\n \t{\n-\t  if ((SYMBOL_TYPE (sym)->code () == TYPE_CODE_PTR\n+\t  if ((sym->type ()->code () == TYPE_CODE_PTR\n \t       && strcmp (sym->linkage_name (), vtbl_ptr_name))\n-\t      || SYMBOL_TYPE (sym)->code () == TYPE_CODE_FUNC)\n+\t      || sym->type ()->code () == TYPE_CODE_FUNC)\n \t    {\n \t      /* If we are giving a name to a type such as \"pointer to\n \t\t foo\" or \"function returning foo\", we better not set\n@@ -1272,10 +1272,10 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t      /* Pascal accepts names for pointer types.  */\n \t      if (get_current_subfile ()->language == language_pascal)\n-\t\tSYMBOL_TYPE (sym)->set_name (sym->linkage_name ());\n+\t\tsym->type ()->set_name (sym->linkage_name ());\n \t    }\n \t  else\n-\t    SYMBOL_TYPE (sym)->set_name (sym->linkage_name ());\n+\t    sym->type ()->set_name (sym->linkage_name ());\n \t}\n \n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -1289,8 +1289,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  struct_sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_VALUE (struct_sym) = valu;\n \t  struct_sym->set_domain (STRUCT_DOMAIN);\n-\t  if (SYMBOL_TYPE (sym)->name () == 0)\n-\t    SYMBOL_TYPE (sym)->set_name\n+\t  if (sym->type ()->name () == 0)\n+\t    sym->type ()->set_name\n \t      (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t (char *) NULL));\n \t  add_symbol_to_list (struct_sym, get_file_symbols ());\n@@ -1306,7 +1306,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       if (synonym)\n \tp++;\n \n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n  \n       /* For a nameless type, we don't want a create a symbol, thus we\n \t did not use `sym'.  Return without further processing.  */\n@@ -1316,8 +1316,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n       sym->set_aclass_index (LOC_TYPEDEF);\n       SYMBOL_VALUE (sym) = valu;\n       sym->set_domain (STRUCT_DOMAIN);\n-      if (SYMBOL_TYPE (sym)->name () == 0)\n-\tSYMBOL_TYPE (sym)->set_name\n+      if (sym->type ()->name () == 0)\n+\tsym->type ()->set_name\n \t  (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t     (char *) NULL));\n       add_symbol_to_list (sym, get_file_symbols ());\n@@ -1331,8 +1331,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t  typedef_sym->set_aclass_index (LOC_TYPEDEF);\n \t  SYMBOL_VALUE (typedef_sym) = valu;\n \t  typedef_sym->set_domain (VAR_DOMAIN);\n-\t  if (SYMBOL_TYPE (sym)->name () == 0)\n-\t    SYMBOL_TYPE (sym)->set_name\n+\t  if (sym->type ()->name () == 0)\n+\t    sym->type ()->set_name\n \t      (obconcat (&objfile->objfile_obstack, sym->linkage_name (),\n \t\t\t (char *) NULL));\n \t  add_symbol_to_list (typedef_sym, get_file_symbols ());\n@@ -1341,7 +1341,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'V':\n       /* Static symbol of local scope.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_STATIC);\n       SET_SYMBOL_VALUE_ADDRESS (sym, valu);\n       sym->set_domain (VAR_DOMAIN);\n@@ -1350,7 +1350,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'v':\n       /* Reference parameter */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_REF_ARG);\n       sym->set_is_argument (1);\n       SYMBOL_VALUE (sym) = valu;\n@@ -1360,7 +1360,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n     case 'a':\n       /* Reference parameter which is in a register.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (stab_regparm_index);\n       sym->set_is_argument (1);\n       SYMBOL_VALUE (sym) = valu;\n@@ -1373,15 +1373,15 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t Sun claims (\"dbx and dbxtool interfaces\", 2nd ed)\n \t that Pascal uses it too, but when I tried it Pascal used\n \t \"x:3\" (local symbol) instead.  */\n-      SYMBOL_TYPE (sym) = read_type (&p, objfile);\n+      sym->set_type (read_type (&p, objfile));\n       sym->set_aclass_index (LOC_LOCAL);\n       SYMBOL_VALUE (sym) = valu;\n       sym->set_domain (VAR_DOMAIN);\n       add_symbol_to_list (sym, get_local_symbols ());\n       break;\n \n     default:\n-      SYMBOL_TYPE (sym) = error_type (&p, objfile);\n+      sym->set_type (error_type (&p, objfile));\n       sym->set_aclass_index (LOC_CONST);\n       SYMBOL_VALUE (sym) = 0;\n       sym->set_domain (VAR_DOMAIN);\n@@ -1393,7 +1393,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n      of by value, i.e. they will pass the address of a structure (in a\n      register or on the stack) instead of the structure itself.  */\n \n-  if (gdbarch_stabs_argument_has_addr (gdbarch, SYMBOL_TYPE (sym))\n+  if (gdbarch_stabs_argument_has_addr (gdbarch, sym->type ())\n       && sym->is_argument ())\n     {\n       /* We have to convert LOC_REGISTER to LOC_REGPARM_ADDR (for\n@@ -1630,11 +1630,11 @@ read_type (const char **pp, struct objfile *objfile)\n \n \t      if (sym->aclass () == LOC_TYPEDEF\n \t\t  && sym->domain () == STRUCT_DOMAIN\n-\t\t  && (SYMBOL_TYPE (sym)->code () == code)\n+\t\t  && (sym->type ()->code () == code)\n \t\t  && strcmp (sym->linkage_name (), type_name) == 0)\n \t\t{\n \t\t  obstack_free (&objfile->objfile_obstack, type_name);\n-\t\t  type = SYMBOL_TYPE (sym);\n+\t\t  type = sym->type ();\n \t\t  if (typenums[0] != -1)\n \t\t    *dbx_lookup_type (typenums, objfile) = type;\n \t\t  return type;\n@@ -3635,7 +3635,7 @@ read_enum_type (const char **pp, struct type *type,\n \t{\n \t  struct symbol *xsym = syms->symbol[j];\n \n-\t  SYMBOL_TYPE (xsym) = type;\n+\t  xsym->set_type (type);\n \t  type->field (n).set_name (xsym->linkage_name ());\n \t  type->field (n).set_loc_enumval (SYMBOL_VALUE (xsym));\n \t  TYPE_FIELD_BITSIZE (type, n) = 0;\n@@ -4281,7 +4281,7 @@ common_block_end (struct objfile *objfile)\n     for (j = common_block_i; j < common_block->nsyms; j++)\n       add_symbol_to_list (common_block->symbol[j], &newobj);\n \n-  SYMBOL_TYPE (sym) = (struct type *) newobj;\n+  sym->set_type ((struct type *) newobj);\n \n   /* Should we be putting local_symbols back to what it was?\n      Does it matter?  */\n@@ -4299,7 +4299,7 @@ common_block_end (struct objfile *objfile)\n static void\n fix_common_block (struct symbol *sym, CORE_ADDR valu)\n {\n-  struct pending *next = (struct pending *) SYMBOL_TYPE (sym);\n+  struct pending *next = (struct pending *) sym->type ();\n \n   for (; next; next = next->next)\n     {\n@@ -4468,11 +4468,11 @@ cleanup_undefined_types_1 (void)\n \n \t\t\tif (sym->aclass () == LOC_TYPEDEF\n \t\t\t    && sym->domain () == STRUCT_DOMAIN\n-\t\t\t    && (SYMBOL_TYPE (sym)->code () == (*type)->code ())\n+\t\t\t    && (sym->type ()->code () == (*type)->code ())\n \t\t\t    && ((*type)->instance_flags ()\n-\t\t\t\t== SYMBOL_TYPE (sym)->instance_flags ())\n+\t\t\t\t== sym->type ()->instance_flags ())\n \t\t\t    && strcmp (sym->linkage_name (), type_name) == 0)\n-\t\t\t  replace_type (*type, SYMBOL_TYPE (sym));\n+\t\t\t  replace_type (*type, sym->type ());\n \t\t      }\n \t\t  }\n \t      }"
    },
    {
      "sha": "b1bbf7d0f4493805da4c34cb3afd0f5cdbf174f3",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -674,7 +674,7 @@ read_frame_arg (const frame_print_options &fp_opts,\n \t  || (fp_opts.print_entry_values == print_entry_values_preferred\n \t      && (!val || value_optimized_out (val))))\n \t{\n-\t  entryval = allocate_optimized_out_value (SYMBOL_TYPE (sym));\n+\t  entryval = allocate_optimized_out_value (sym->type ());\n \t  entryval_error = NULL;\n \t}\n     }\n@@ -779,7 +779,7 @@ print_frame_args (const frame_print_options &fp_opts,\n \t    case LOC_REF_ARG:\n \t      {\n \t\tlong current_offset = SYMBOL_VALUE (sym);\n-\t\tint arg_size = TYPE_LENGTH (SYMBOL_TYPE (sym));\n+\t\tint arg_size = TYPE_LENGTH (sym->type ());\n \n \t\t/* Compute address of next argument by adding the size of\n \t\t   this argument and rounding to an int boundary.  */\n@@ -2762,7 +2762,7 @@ return_command (const char *retval_exp, int from_tty)\n       /* Cast return value to the return type of the function.  Should\n \t the cast fail, this call throws an error.  */\n       if (thisfun != NULL)\n-\treturn_type = TYPE_TARGET_TYPE (SYMBOL_TYPE (thisfun));\n+\treturn_type = TYPE_TARGET_TYPE (thisfun->type ());\n       if (return_type == NULL)\n \t{\n \t  if (retval_expr->first_opcode () != UNOP_CAST\n@@ -2818,7 +2818,7 @@ return_command (const char *retval_exp, int from_tty)\n \t\t\t   query_prefix);\n       else\n \t{\n-\t  if (TYPE_NO_RETURN (thisfun->type))\n+\t  if (TYPE_NO_RETURN (thisfun->type ()))\n \t    warning (_(\"Function does not return normally to caller.\"));\n \t  confirmed = query (_(\"%sMake %s return now? \"), query_prefix,\n \t\t\t     thisfun->print_name ());"
    },
    {
      "sha": "160278b50a97f823b7c8213860c766aba1861d2b",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -523,20 +523,20 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \n   if (symbol->domain () == STRUCT_DOMAIN)\n     {\n-      if (SYMBOL_TYPE (symbol)->name ())\n+      if (symbol->type ()->name ())\n \t{\n-\t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), \"\", outfile, 1, depth,\n+\t  LA_PRINT_TYPE (symbol->type (), \"\", outfile, 1, depth,\n \t\t\t &type_print_raw_options);\n \t}\n       else\n \t{\n \t  fprintf_filtered (outfile, \"%s %s = \",\n-\t\t\t (SYMBOL_TYPE (symbol)->code () == TYPE_CODE_ENUM\n+\t\t\t (symbol->type ()->code () == TYPE_CODE_ENUM\n \t\t\t  ? \"enum\"\n-\t\t     : (SYMBOL_TYPE (symbol)->code () == TYPE_CODE_STRUCT\n+\t\t     : (symbol->type ()->code () == TYPE_CODE_STRUCT\n \t\t\t? \"struct\" : \"union\")),\n \t\t\t    symbol->linkage_name ());\n-\t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), \"\", outfile, 1, depth,\n+\t  LA_PRINT_TYPE (symbol->type (), \"\", outfile, 1, depth,\n \t\t\t &type_print_raw_options);\n \t}\n       fprintf_filtered (outfile, \";\\n\");\n@@ -545,12 +545,12 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n     {\n       if (symbol->aclass () == LOC_TYPEDEF)\n \tfprintf_filtered (outfile, \"typedef \");\n-      if (SYMBOL_TYPE (symbol))\n+      if (symbol->type ())\n \t{\n \t  /* Print details of types, except for enums where it's clutter.  */\n-\t  LA_PRINT_TYPE (SYMBOL_TYPE (symbol), symbol->print_name (),\n+\t  LA_PRINT_TYPE (symbol->type (), symbol->print_name (),\n \t\t\t outfile,\n-\t\t\t SYMBOL_TYPE (symbol)->code () != TYPE_CODE_ENUM,\n+\t\t\t symbol->type ()->code () != TYPE_CODE_ENUM,\n \t\t\t depth,\n \t\t\t &type_print_raw_options);\n \t  fprintf_filtered (outfile, \"; \");\n@@ -569,7 +569,7 @@ print_symbol (struct gdbarch *gdbarch, struct symbol *symbol,\n \tcase LOC_CONST_BYTES:\n \t  {\n \t    unsigned i;\n-\t    struct type *type = check_typedef (SYMBOL_TYPE (symbol));\n+\t    struct type *type = check_typedef (symbol->type ());\n \n \t    fprintf_filtered (outfile, \"const %s hex bytes:\",\n \t\t\t      pulongest (TYPE_LENGTH (type)));"
    },
    {
      "sha": "8da86b61359568244f10507de4277de56e1739d2",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -2130,7 +2130,7 @@ lookup_symbol_aux (const char *name, symbol_name_match_type match_type,\n \n       if (result.symbol)\n \t{\n-\t  struct type *t = result.symbol->type;\n+\t  struct type *t = result.symbol->type ();\n \n \t  /* I'm not really sure that type of this can ever\n \t     be typedefed; just be safe.  */\n@@ -2806,8 +2806,8 @@ basic_lookup_transparent_type_quick (struct objfile *objfile,\n \t\t\t   block_find_non_opaque_type, NULL);\n   if (sym == NULL)\n     error_in_psymtab_expansion (block_index, name, cust);\n-  gdb_assert (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)));\n-  return SYMBOL_TYPE (sym);\n+  gdb_assert (!TYPE_IS_OPAQUE (sym->type ()));\n+  return sym->type ();\n }\n \n /* Subroutine of basic_lookup_transparent_type to simplify it.\n@@ -2831,8 +2831,8 @@ basic_lookup_transparent_type_1 (struct objfile *objfile,\n \t\t\t       block_find_non_opaque_type, NULL);\n       if (sym != NULL)\n \t{\n-\t  gdb_assert (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)));\n-\t  return SYMBOL_TYPE (sym);\n+\t  gdb_assert (!TYPE_IS_OPAQUE (sym->type ()));\n+\t  return sym->type ();\n \t}\n     }\n \n@@ -4657,7 +4657,7 @@ treg_matches_sym_type_name (const compiled_regex &treg,\n \t\t\t  sym->natural_name ());\n     }\n \n-  sym_type = SYMBOL_TYPE (sym);\n+  sym_type = sym->type ();\n   if (sym_type == NULL)\n     return false;\n \n@@ -4836,7 +4836,7 @@ global_symbol_searcher::add_matching_symbols\n \t\t\t      members.  We only want to skip enums\n \t\t\t      here.  */\n \t\t\t   && !(sym->aclass () == LOC_CONST\n-\t\t\t\t&& (SYMBOL_TYPE (sym)->code ()\n+\t\t\t\t&& (sym->type ()->code ()\n \t\t\t\t    == TYPE_CODE_ENUM))\n \t\t\t   && (!treg.has_value ()\n \t\t\t       || treg_matches_sym_type_name (*treg, sym)))\n@@ -5042,10 +5042,10 @@ symbol_to_info_string (struct symbol *sym, int block,\n \t For the struct printing case below, things are worse, we force\n \t printing of the \";\" in this function, which is going to be wrong\n \t for languages that don't require a \";\" between statements.  */\n-      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_TYPEDEF)\n-\ttypedef_print (SYMBOL_TYPE (sym), sym, &tmp_stream);\n+      if (sym->type ()->code () == TYPE_CODE_TYPEDEF)\n+\ttypedef_print (sym->type (), sym, &tmp_stream);\n       else\n-\ttype_print (SYMBOL_TYPE (sym), \"\", &tmp_stream, -1);\n+\ttype_print (sym->type (), \"\", &tmp_stream, -1);\n       str += tmp_stream.string ();\n     }\n   /* variable, func, or typedef-that-is-c++-class.  */\n@@ -5055,7 +5055,7 @@ symbol_to_info_string (struct symbol *sym, int block,\n     {\n       string_file tmp_stream;\n \n-      type_print (SYMBOL_TYPE (sym),\n+      type_print (sym->type (),\n \t\t  (sym->aclass () == LOC_TYPEDEF\n \t\t   ? \"\" : sym->print_name ()),\n \t\t  &tmp_stream, 0);\n@@ -5673,7 +5673,7 @@ completion_list_add_fields (completion_tracker &tracker,\n {\n   if (sym->aclass () == LOC_TYPEDEF)\n     {\n-      struct type *t = SYMBOL_TYPE (sym);\n+      struct type *t = sym->type ();\n       enum type_code c = t->code ();\n       int j;\n \n@@ -5691,7 +5691,7 @@ completion_list_add_fields (completion_tracker &tracker,\n bool\n symbol_is_function_or_method (symbol *sym)\n {\n-  switch (SYMBOL_TYPE (sym)->code ())\n+  switch (sym->type ()->code ())\n     {\n     case TYPE_CODE_FUNC:\n     case TYPE_CODE_METHOD:\n@@ -5789,7 +5789,7 @@ add_symtab_completions (struct compunit_symtab *cust,\n \n \t  if (code == TYPE_CODE_UNDEF\n \t      || (sym->domain () == STRUCT_DOMAIN\n-\t\t  && SYMBOL_TYPE (sym)->code () == code))\n+\t\t  && sym->type ()->code () == code))\n \t    completion_list_add_symbol (tracker, sym,\n \t\t\t\t\tlookup_name,\n \t\t\t\t\ttext, word);\n@@ -5942,7 +5942,7 @@ default_collect_symbol_completion_matches_break_on\n \t\t\t\t\t    sym_text, word);\n \t      }\n \t    else if (sym->domain () == STRUCT_DOMAIN\n-\t\t     && SYMBOL_TYPE (sym)->code () == code)\n+\t\t     && sym->type ()->code () == code)\n \t      completion_list_add_symbol (tracker, sym, lookup_name,\n \t\t\t\t\t  sym_text, word);\n \t  }"
    },
    {
      "sha": "3486803cca8e679dd03b6c69c28795d0301cbaeb",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 11,
      "deletions": 2,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1203,9 +1203,19 @@ struct symbol : public general_symbol_info, public allocate_on_obstack\n     return this->subclass == SYMBOL_TEMPLATE;\n   }\n \n+  struct type *type () const\n+  {\n+    return m_type;\n+  }\n+\n+  void set_type (struct type *type)\n+  {\n+    m_type = type;\n+  }\n+\n   /* Data type of value */\n \n-  struct type *type = nullptr;\n+  struct type *m_type = nullptr;\n \n   /* The owner of this symbol.\n      Which one to use is defined by symbol.is_objfile_owned.  */\n@@ -1305,7 +1315,6 @@ struct block_symbol\n /* Note: There is no accessor macro for symbol.owner because it is\n    \"private\".  */\n \n-#define SYMBOL_TYPE(symbol)\t\t(symbol)->type\n #define SYMBOL_LINE(symbol)\t\t(symbol)->line\n #define SYMBOL_COMPUTED_OPS(symbol)\t((symbol)->impl ().ops_computed)\n #define SYMBOL_BLOCK_OPS(symbol)\t((symbol)->impl ().ops_block)"
    },
    {
      "sha": "73ebc38eb805cf61d6a37f25feaf331690456ebd",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -927,7 +927,7 @@ collection_list::collect_symbol (struct symbol *sym,\n   bfd_signed_vma offset;\n   int treat_as_expr = 0;\n \n-  len = TYPE_LENGTH (check_typedef (SYMBOL_TYPE (sym)));\n+  len = TYPE_LENGTH (check_typedef (sym->type ()));\n   switch (sym->aclass ())\n     {\n     default:\n@@ -948,7 +948,7 @@ collection_list::collect_symbol (struct symbol *sym,\n \t}\n       /* A struct may be a C++ class with static fields, go to general\n \t expression handling.  */\n-      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_STRUCT)\n+      if (sym->type ()->code () == TYPE_CODE_STRUCT)\n \ttreat_as_expr = 1;\n       else\n \tadd_memrange (gdbarch, memrange_absolute, offset, len, scope);\n@@ -960,7 +960,7 @@ collection_list::collect_symbol (struct symbol *sym,\n       add_local_register (gdbarch, reg, scope);\n       /* Check for doubles stored in two registers.  */\n       /* FIXME: how about larger types stored in 3 or more regs?  */\n-      if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_FLT &&\n+      if (sym->type ()->code () == TYPE_CODE_FLT &&\n \t  len > register_size (gdbarch, reg))\n \tadd_local_register (gdbarch, reg + 1, scope);\n       break;\n@@ -2565,8 +2565,8 @@ info_scope_command (const char *args_in, int from_tty)\n \t\t  break;\n \t\tcase LOC_CONST_BYTES:\n \t\t  printf_filtered (\"constant bytes: \");\n-\t\t  if (SYMBOL_TYPE (sym))\n-\t\t    for (j = 0; j < TYPE_LENGTH (SYMBOL_TYPE (sym)); j++)\n+\t\t  if (sym->type ())\n+\t\t    for (j = 0; j < TYPE_LENGTH (sym->type ()); j++)\n \t\t      printf_filtered (\" %02x\",\n \t\t\t\t       (unsigned) SYMBOL_VALUE_BYTES (sym)[j]);\n \t\t  break;\n@@ -2645,9 +2645,9 @@ info_scope_command (const char *args_in, int from_tty)\n \t\t  gdb_assert_not_reached (\"LOC_COMPUTED variable missing a method\");\n \t\t}\n \t    }\n-\t  if (SYMBOL_TYPE (sym))\n+\t  if (sym->type ())\n \t    {\n-\t      struct type *t = check_typedef (SYMBOL_TYPE (sym));\n+\t      struct type *t = check_typedef (sym->type ());\n \n \t      printf_filtered (\", length %s.\\n\", pulongest (TYPE_LENGTH (t)));\n \t    }"
    },
    {
      "sha": "f7a2ebac398fc1832ac238d037ee333815220f1c",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -260,7 +260,7 @@ typedef_hash_table::add_template_parameters (struct type *t)\n \n       tf = XOBNEW (&m_storage, struct decl_field);\n       tf->name = TYPE_TEMPLATE_ARGUMENT (t, i)->linkage_name ();\n-      tf->type = SYMBOL_TYPE (TYPE_TEMPLATE_ARGUMENT (t, i));\n+      tf->type = TYPE_TEMPLATE_ARGUMENT (t, i)->type ();\n \n       slot = htab_find_slot (m_table.get (), tf, INSERT);\n       if (*slot == NULL)"
    },
    {
      "sha": "3a595125752f0d0c3bef1ee40a62ca36e447fa62",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1387,7 +1387,7 @@ value_of_variable (struct symbol *var, const struct block *b)\n struct value *\n address_of_variable (struct symbol *var, const struct block *b)\n {\n-  struct type *type = SYMBOL_TYPE (var);\n+  struct type *type = var->type ();\n   struct value *val;\n \n   /* Evaluate it first; if the result is a memory address, we're fine.\n@@ -2833,7 +2833,7 @@ find_overload_match (gdb::array_view<value *> args,\n \t     the function part.  Do not try this for non-functions (e.g.\n \t     function pointers).  */\n \t  if (qualified_name\n-\t      && (check_typedef (SYMBOL_TYPE (fsym))->code ()\n+\t      && (check_typedef (fsym->type ())->code ()\n \t\t  == TYPE_CODE_FUNC))\n \t    {\n \t      temp_func = cp_func_name (qualified_name);\n@@ -3187,14 +3187,14 @@ find_oload_champ (gdb::array_view<value *> args,\n \t      static_offset = oload_method_static_p (methods, ix);\n \t    }\n \t  else\n-\t    nparms = SYMBOL_TYPE (functions[ix])->num_fields ();\n+\t    nparms = functions[ix]->type ()->num_fields ();\n \n \t  parm_types.reserve (nparms);\n \t  for (jj = 0; jj < nparms; jj++)\n \t    {\n \t      type *t = (methods != NULL\n \t\t\t ? (TYPE_FN_FIELD_ARGS (methods, ix)[jj].type ())\n-\t\t\t : SYMBOL_TYPE (functions[ix])->field (jj).type ());\n+\t\t\t : functions[ix]->type ()->field (jj).type ());\n \t      parm_types.push_back (t);\n \t    }\n \t}\n@@ -3780,7 +3780,7 @@ value_maybe_namespace_elt (const struct type *curtype,\n     return NULL;\n   else if ((noside == EVAL_AVOID_SIDE_EFFECTS)\n \t   && (sym.symbol->aclass () == LOC_TYPEDEF))\n-    result = allocate_value (SYMBOL_TYPE (sym.symbol));\n+    result = allocate_value (sym.symbol->type ());\n   else\n     result = value_of_variable (sym.symbol, sym.block);\n "
    },
    {
      "sha": "d3e9ade72cb57768b61d3dd374ed482ce38b27c7",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f9c5a63ce38b103f778f54394c6a3d43b7ade90/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=5f9c5a63ce38b103f778f54394c6a3d43b7ade90",
      "patch": "@@ -1572,7 +1572,7 @@ process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)\n \t patch_block_stabs (), unless the file was compiled without -g.  */\n \n       sym->set_linkage_name (SYMNAME_ALLOC (name, symname_alloced));\n-      SYMBOL_TYPE (sym) = objfile_type (objfile)->nodebug_text_symbol;\n+      sym->set_type (objfile_type (objfile)->nodebug_text_symbol);\n \n       sym->set_aclass_index (LOC_BLOCK);\n       sym2 = new (&objfile->objfile_obstack) symbol (*sym);\n@@ -1585,7 +1585,7 @@ process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)\n   else\n     {\n       /* In case we can't figure out the type, provide default.  */\n-      SYMBOL_TYPE (sym) = objfile_type (objfile)->nodebug_data_symbol;\n+      sym->set_type (objfile_type (objfile)->nodebug_data_symbol);\n \n       switch (cs->c_sclass)\n \t{"
    }
  ]
}