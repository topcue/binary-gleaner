{
  "sha": "abb6af934c54e386c2bca8d725a496f239a9bac2",
  "node_id": "C_kwDOANOeidoAKGFiYjZhZjkzNGM1NGUzODZjMmJjYThkNzI1YTQ5NmYyMzlhOWJhYzI",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-10-26T00:20:24Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-12T17:56:38Z"
    },
    "message": "C++-ify path substitution code\n\nI found some uses of xfree in the path substitution code in source.c.\nC++-ifying struct substitute_path_rule both simplifies the code and\nremoves manual memory management.\n\nRegression tested on x86-64 Fedora 34.",
    "tree": {
      "sha": "a3e838775742acfc3ebc044c7aec6018f8370943",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a3e838775742acfc3ebc044c7aec6018f8370943"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/abb6af934c54e386c2bca8d725a496f239a9bac2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abb6af934c54e386c2bca8d725a496f239a9bac2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/abb6af934c54e386c2bca8d725a496f239a9bac2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/abb6af934c54e386c2bca8d725a496f239a9bac2/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2749ac133972d027fe9482acc81f6e88c4f36812",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2749ac133972d027fe9482acc81f6e88c4f36812",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2749ac133972d027fe9482acc81f6e88c4f36812"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 54,
    "deletions": 121
  },
  "files": [
    {
      "sha": "44e90bfab73a683f0b4373d3fc2f838f4a0a7117",
      "filename": "gdb/source.c",
      "status": "modified",
      "additions": 53,
      "deletions": 120,
      "changes": 173,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abb6af934c54e386c2bca8d725a496f239a9bac2/gdb/source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abb6af934c54e386c2bca8d725a496f239a9bac2/gdb/source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.c?ref=abb6af934c54e386c2bca8d725a496f239a9bac2",
      "patch": "@@ -63,12 +63,17 @@ std::string source_path;\n \n struct substitute_path_rule\n {\n-  char *from;\n-  char *to;\n-  struct substitute_path_rule *next;\n+  substitute_path_rule (const char *from_, const char *to_)\n+    : from (from_),\n+      to (to_)\n+  {\n+  }\n+\n+  std::string from;\n+  std::string to;\n };\n \n-static struct substitute_path_rule *substitute_path_rules = NULL;\n+static std::list<substitute_path_rule> substitute_path_rules;\n \n /* An instance of this is attached to each program space.  */\n \n@@ -988,7 +993,7 @@ static int\n substitute_path_rule_matches (const struct substitute_path_rule *rule,\n \t\t\t      const char *path)\n {\n-  const int from_len = strlen (rule->from);\n+  const int from_len = rule->from.length ();\n   const int path_len = strlen (path);\n \n   if (path_len < from_len)\n@@ -997,7 +1002,7 @@ substitute_path_rule_matches (const struct substitute_path_rule *rule,\n   /* The substitution rules are anchored at the start of the path,\n      so the path should start with rule->from.  */\n \n-  if (filename_ncmp (path, rule->from, from_len) != 0)\n+  if (filename_ncmp (path, rule->from.c_str (), from_len) != 0)\n     return 0;\n \n   /* Make sure that the region in the path that matches the substitution\n@@ -1016,12 +1021,11 @@ substitute_path_rule_matches (const struct substitute_path_rule *rule,\n static struct substitute_path_rule *\n get_substitute_path_rule (const char *path)\n {\n-  struct substitute_path_rule *rule = substitute_path_rules;\n+  for (substitute_path_rule &rule : substitute_path_rules)\n+    if (substitute_path_rule_matches (&rule, path))\n+      return &rule;\n \n-  while (rule != NULL && !substitute_path_rule_matches (rule, path))\n-    rule = rule->next;\n-\n-  return rule;\n+  return nullptr;\n }\n \n /* If the user specified a source path substitution rule that applies\n@@ -1034,22 +1038,14 @@ gdb::unique_xmalloc_ptr<char>\n rewrite_source_path (const char *path)\n {\n   const struct substitute_path_rule *rule = get_substitute_path_rule (path);\n-  char *new_path;\n-  int from_len;\n-  \n-  if (rule == NULL)\n-    return NULL;\n \n-  from_len = strlen (rule->from);\n+  if (rule == nullptr)\n+    return nullptr;\n \n   /* Compute the rewritten path and return it.  */\n \n-  new_path =\n-    (char *) xmalloc (strlen (path) + 1 + strlen (rule->to) - from_len);\n-  strcpy (new_path, rule->to);\n-  strcat (new_path, path + from_len);\n-\n-  return gdb::unique_xmalloc_ptr<char> (new_path);\n+  return (gdb::unique_xmalloc_ptr<char>\n+\t  (concat (rule->to.c_str (), path + rule->from.length (), nullptr)));\n }\n \n /* See source.h.  */\n@@ -1730,87 +1726,20 @@ strip_trailing_directory_separator (char *path)\n     path[last] = '\\0';\n }\n \n-/* Return the path substitution rule that matches FROM.\n-   Return NULL if no rule matches.  */\n-\n-static struct substitute_path_rule *\n-find_substitute_path_rule (const char *from)\n-{\n-  struct substitute_path_rule *rule = substitute_path_rules;\n-\n-  while (rule != NULL)\n-    {\n-      if (FILENAME_CMP (rule->from, from) == 0)\n-\treturn rule;\n-      rule = rule->next;\n-    }\n-\n-  return NULL;\n-}\n-\n /* Add a new substitute-path rule at the end of the current list of rules.\n    The new rule will replace FROM into TO.  */\n \n void\n-add_substitute_path_rule (char *from, char *to)\n+add_substitute_path_rule (const char *from, const char *to)\n {\n-  struct substitute_path_rule *rule;\n-  struct substitute_path_rule *new_rule = XNEW (struct substitute_path_rule);\n-\n-  new_rule->from = xstrdup (from);\n-  new_rule->to = xstrdup (to);\n-  new_rule->next = NULL;\n-\n-  /* If the list of rules are empty, then insert the new rule\n-     at the head of the list.  */\n-\n-  if (substitute_path_rules == NULL)\n-    {\n-      substitute_path_rules = new_rule;\n-      return;\n-    }\n-\n-  /* Otherwise, skip to the last rule in our list and then append\n-     the new rule.  */\n-\n-  rule = substitute_path_rules;\n-  while (rule->next != NULL)\n-    rule = rule->next;\n-\n-  rule->next = new_rule;\n-}\n-\n-/* Remove the given source path substitution rule from the current list\n-   of rules.  The memory allocated for that rule is also deallocated.  */\n-\n-static void\n-delete_substitute_path_rule (struct substitute_path_rule *rule)\n-{\n-  if (rule == substitute_path_rules)\n-    substitute_path_rules = rule->next;\n-  else\n-    {\n-      struct substitute_path_rule *prev = substitute_path_rules;\n-\n-      while (prev != NULL && prev->next != rule)\n-\tprev = prev->next;\n-\n-      gdb_assert (prev != NULL);\n-\n-      prev->next = rule->next;\n-    }\n-\n-  xfree (rule->from);\n-  xfree (rule->to);\n-  xfree (rule);\n+  substitute_path_rules.emplace_back (from, to);\n }\n \n /* Implement the \"show substitute-path\" command.  */\n \n static void\n show_substitute_path_command (const char *args, int from_tty)\n {\n-  struct substitute_path_rule *rule = substitute_path_rules;\n   char *from = NULL;\n   \n   gdb_argv argv (args);\n@@ -1831,11 +1760,11 @@ show_substitute_path_command (const char *args, int from_tty)\n   else\n     printf_filtered (_(\"List of all source path substitution rules:\\n\"));\n \n-  while (rule != NULL)\n+  for (substitute_path_rule &rule : substitute_path_rules)\n     {\n-      if (from == NULL || substitute_path_rule_matches (rule, from) != 0)\n-\tprintf_filtered (\"  `%s' -> `%s'.\\n\", rule->from, rule->to);\n-      rule = rule->next;\n+      if (from == NULL || substitute_path_rule_matches (&rule, from) != 0)\n+\tprintf_filtered (\"  `%s' -> `%s'.\\n\", rule.from.c_str (),\n+\t\t\t rule.to.c_str ());\n     }\n }\n \n@@ -1844,10 +1773,8 @@ show_substitute_path_command (const char *args, int from_tty)\n static void\n unset_substitute_path_command (const char *args, int from_tty)\n {\n-  struct substitute_path_rule *rule = substitute_path_rules;\n   gdb_argv argv (args);\n   char *from = NULL;\n-  int rule_found = 0;\n \n   /* This function takes either 0 or 1 argument.  */\n \n@@ -1868,24 +1795,27 @@ unset_substitute_path_command (const char *args, int from_tty)\n   /* Delete the rule matching the argument.  No argument means that\n      all rules should be deleted.  */\n \n-  while (rule != NULL)\n+  if (from == nullptr)\n+    substitute_path_rules.clear ();\n+  else\n     {\n-      struct substitute_path_rule *next = rule->next;\n-\n-      if (from == NULL || FILENAME_CMP (from, rule->from) == 0)\n-\t{\n-\t  delete_substitute_path_rule (rule);\n-\t  rule_found = 1;\n-\t}\n-\n-      rule = next;\n+      auto iter\n+\t= std::remove_if (substitute_path_rules.begin (),\n+\t\t\t  substitute_path_rules.end (),\n+\t\t\t  [&] (const substitute_path_rule &rule)\n+\t\t\t  {\n+\t\t\t    return FILENAME_CMP (from,\n+\t\t\t\t\t\t rule.from.c_str ()) == 0;\n+\t\t\t  });\n+      bool rule_found = iter != substitute_path_rules.end ();\n+      substitute_path_rules.erase (iter, substitute_path_rules.end ());\n+\n+      /* If the user asked for a specific rule to be deleted but\n+\t we could not find it, then report an error.  */\n+\n+      if (!rule_found)\n+\terror (_(\"No substitution rule defined for `%s'\"), from);\n     }\n-  \n-  /* If the user asked for a specific rule to be deleted but\n-     we could not find it, then report an error.  */\n-\n-  if (from != NULL && !rule_found)\n-    error (_(\"No substitution rule defined for `%s'\"), from);\n \n   forget_cached_source_info ();\n }\n@@ -1895,8 +1825,6 @@ unset_substitute_path_command (const char *args, int from_tty)\n static void\n set_substitute_path_command (const char *args, int from_tty)\n {\n-  struct substitute_path_rule *rule;\n-  \n   gdb_argv argv (args);\n \n   if (argv == NULL || argv[0] == NULL || argv [1] == NULL)\n@@ -1916,10 +1844,15 @@ set_substitute_path_command (const char *args, int from_tty)\n   /* If a rule with the same \"from\" was previously defined, then\n      delete it.  This new rule replaces it.  */\n \n-  rule = find_substitute_path_rule (argv[0]);\n-  if (rule != NULL)\n-    delete_substitute_path_rule (rule);\n-      \n+  auto iter\n+    = std::remove_if (substitute_path_rules.begin (),\n+\t\t      substitute_path_rules.end (),\n+\t\t      [&] (const substitute_path_rule &rule)\n+\t\t      {\n+\t\t\treturn FILENAME_CMP (argv[0], rule.from.c_str ()) == 0;\n+\t\t      });\n+  substitute_path_rules.erase (iter, substitute_path_rules.end ());\n+\n   /* Insert the new substitution rule.  */\n \n   add_substitute_path_rule (argv[0], argv[1]);"
    },
    {
      "sha": "e146ce9d4a4f64b9991f2aee0b6c6fdc67d69e12",
      "filename": "gdb/source.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/abb6af934c54e386c2bca8d725a496f239a9bac2/gdb/source.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/abb6af934c54e386c2bca8d725a496f239a9bac2/gdb/source.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.h?ref=abb6af934c54e386c2bca8d725a496f239a9bac2",
      "patch": "@@ -128,7 +128,7 @@ extern symtab_and_line set_current_source_symtab_and_line\n extern void clear_current_source_symtab_and_line (void);\n \n /* Add a source path substitution rule.  */\n-extern void add_substitute_path_rule (char *, char *);\n+extern void add_substitute_path_rule (const char *, const char *);\n \n /* Flags passed as 4th argument to print_source_lines.  */\n enum print_source_lines_flag"
    }
  ]
}