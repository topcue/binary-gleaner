{
  "sha": "139633c307eb6f5746ea04f94a0b6382e51bccb9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTM5NjMzYzMwN2ViNmY1NzQ2ZWEwNGY5NGEwYjYzODJlNTFiY2NiOQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:04Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:04Z"
    },
    "message": "libctf, include, binutils, gdb, ld: rename ctf_file_t to ctf_dict_t\n\nThe naming of the ctf_file_t type in libctf is a historical curiosity.\nBack in the Solaris days, CTF dictionaries were originally generated as\na separate file and then (sometimes) merged into objects: hence the\ndatatype was named ctf_file_t, and known as a \"CTF file\".  Nowadays, raw\nCTF is essentially never written to a file on its own, and the datatype\nchanged name to a \"CTF dictionary\" years ago.  So the term \"CTF file\"\nrefers to something that is never a file!  This is at best confusing.\n\nThe type has also historically been known as a 'CTF container\", which is\neven more confusing now that we have CTF archives which are *also* a\nsort of container (they contain CTF dictionaries), but which are never\nreferred to as containers in the source code.\n\nSo fix this by completing the renaming, renaming ctf_file_t to\nctf_dict_t throughout, and renaming those few functions that refer to\nCTF files by name (keeping compatibility aliases) to refer to dicts\ninstead.  Old users who still refer to ctf_file_t will see (harmless)\npointer-compatibility warnings at compile time, but the ABI is unchanged\n(since C doesn't mangle names, and ctf_file_t was always an opaque type)\nand things will still compile fine as long as -Werror is not specified.\nAll references to CTF containers and CTF files in the source code are\nfixed to refer to CTF dicts instead.\n\nFurther (smaller) renamings of annoyingly-named functions to come, as\npart of the process of souping up queries across whole archives at once\n(needed for the function info and data object sections).\n\nbinutils/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* objdump.c (dump_ctf_errs): Rename ctf_file_t to ctf_dict_t.\n\t(dump_ctf_archive_member): Likewise.\n\t(dump_ctf): Likewise. Use ctf_dict_close, not ctf_file_close.\n\t* readelf.c (dump_ctf_errs): Rename ctf_file_t to ctf_dict_t.\n\t(dump_ctf_archive_member): Likewise.\n\t(dump_section_as_ctf): Likewise.  Use ctf_dict_close, not\n\tctf_file_close.\n\ngdb/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctfread.c: Change uses of ctf_file_t to ctf_dict_t.\n\t(ctf_fp_info::~ctf_fp_info): Call ctf_dict_close, not ctf_file_close.\n\ninclude/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (ctf_file_t): Rename to...\n\t(ctf_dict_t): ... this.  Keep ctf_file_t around for compatibility.\n\t(struct ctf_file): Likewise rename to...\n\t(struct ctf_dict): ... this.\n\t(ctf_file_close): Rename to...\n\t(ctf_dict_close): ... this, keeping compatibility function.\n\t(ctf_parent_file): Rename to...\n\t(ctf_parent_dict): ... this, keeping compatibility function.\n\tAll callers adjusted.\n\t* ctf.h: Rename references to ctf_file_t to ctf_dict_t.\n\t(struct ctf_archive) <ctfa_nfiles>: Rename to...\n\t<ctfa_ndicts>: ... this.\n\nld/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ldlang.c (ctf_output): This is a ctf_dict_t now.\n\t(lang_ctf_errs_warnings): Rename ctf_file_t to ctf_dict_t.\n\t(ldlang_open_ctf): Adjust comment.\n\t(lang_merge_ctf): Use ctf_dict_close, not ctf_file_close.\n\t* ldelfgen.h (ldelf_examine_strtab_for_ctf): Rename ctf_file_t to\n\tctf_dict_t.  Change opaque declaration accordingly.\n\t* ldelfgen.c (ldelf_examine_strtab_for_ctf): Adjust.\n\t* ldemul.h (examine_strtab_for_ctf): Likewise.\n\t(ldemul_examine_strtab_for_ctf): Likewise.\n\t* ldeuml.c (ldemul_examine_strtab_for_ctf): Likewise.\n\nlibctf/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h: Rename ctf_file_t to ctf_dict_t: all declarations\n\tadjusted.\n\t(ctf_fileops): Rename to...\n\t(ctf_dictops): ... this.\n\t(ctf_dedup_t) <cd_id_to_file_t>: Rename to...\n\t<cd_id_to_dict_t>: ... this.\n\t(ctf_file_t): Fix outdated comment.\n\t<ctf_fileops>: Rename to...\n\t<ctf_dictops>: ... this.\n\t(struct ctf_archive_internal) <ctfi_file>: Rename to...\n\t<ctfi_dict>: ... this.\n\t* ctf-archive.c: Rename ctf_file_t to ctf_dict_t.\n\tRename ctf_archive.ctfa_nfiles to ctfa_ndicts.\n\tRename ctf_file_close to ctf_dict_close.  All users adjusted.\n\t* ctf-create.c: Likewise.  Refer to CTF dicts, not CTF containers.\n\t(ctf_bundle_t) <ctb_file>: Rename to...\n\t<ctb_dict): ... this.\n\t* ctf-decl.c: Rename ctf_file_t to ctf_dict_t.\n\t* ctf-dedup.c: Likewise.  Rename ctf_file_close to\n\tctf_dict_close. Refer to CTF dicts, not CTF containers.\n\t* ctf-dump.c: Likewise.\n\t* ctf-error.c: Likewise.\n\t* ctf-hash.c: Likewise.\n\t* ctf-inlines.h: Likewise.\n\t* ctf-labels.c: Likewise.\n\t* ctf-link.c: Likewise.\n\t* ctf-lookup.c: Likewise.\n\t* ctf-open-bfd.c: Likewise.\n\t* ctf-string.c: Likewise.\n\t* ctf-subr.c: Likewise.\n\t* ctf-types.c: Likewise.\n\t* ctf-util.c: Likewise.\n\t* ctf-open.c: Likewise.\n\t(ctf_file_close): Rename to...\n\t(ctf_dict_close): ...this.\n\t(ctf_file_close): New trivial wrapper around ctf_dict_close, for\n\tcompatibility.\n\t(ctf_parent_file): Rename to...\n\t(ctf_parent_dict): ... this.\n\t(ctf_parent_file): New trivial wrapper around ctf_parent_dict, for\n\tcompatibility.\n\t* libctf.ver: Add ctf_dict_close and ctf_parent_dict.",
    "tree": {
      "sha": "6c070eeecd42d5c5bc93041be7fcc1279495a266",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6c070eeecd42d5c5bc93041be7fcc1279495a266"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/139633c307eb6f5746ea04f94a0b6382e51bccb9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/139633c307eb6f5746ea04f94a0b6382e51bccb9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/139633c307eb6f5746ea04f94a0b6382e51bccb9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/139633c307eb6f5746ea04f94a0b6382e51bccb9/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cbbcd7a716d7f1f65c57aa6ba6e034ecb9a78378",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cbbcd7a716d7f1f65c57aa6ba6e034ecb9a78378",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cbbcd7a716d7f1f65c57aa6ba6e034ecb9a78378"
    }
  ],
  "stats": {
    "total": 1723,
    "additions": 919,
    "deletions": 804
  },
  "files": [
    {
      "sha": "e1a5a3d10cf8d5e81d9e92b7ff395d7b095be84f",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -1,3 +1,13 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* objdump.c (dump_ctf_errs): Rename ctf_file_t to ctf_dict_t.\n+\t(dump_ctf_archive_member): Likewise.\n+\t(dump_ctf): Likewise. Use ctf_dict_close, not ctf_file_close.\n+\t* readelf.c (dump_ctf_errs): Rename ctf_file_t to ctf_dict_t.\n+\t(dump_ctf_archive_member): Likewise.\n+\t(dump_section_as_ctf): Likewise.  Use ctf_dict_close, not\n+\tctf_file_close.\n+\n 2020-11-20  Nick Clifton  <nickc@redhat.com>\n \n \tPR 22967"
    },
    {
      "sha": "54f4081d1c92ed4328a0726b38badf39a4e97ad3",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -4073,7 +4073,7 @@ make_ctfsect (const char *name, bfd_byte *data,\n \n /* Dump CTF errors/warnings.  */\n static void\n-dump_ctf_errs (ctf_file_t *fp)\n+dump_ctf_errs (ctf_dict_t *fp)\n {\n   ctf_next_t *it = NULL;\n   char *errtext;\n@@ -4097,9 +4097,9 @@ dump_ctf_errs (ctf_file_t *fp)\n /* Dump one CTF archive member.  */\n \n static int\n-dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n {\n-  ctf_file_t *parent = (ctf_file_t *) arg;\n+  ctf_dict_t *parent = (ctf_dict_t *) arg;\n   const char *things[] = {\"Header\", \"Labels\", \"Data objects\",\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n@@ -4155,7 +4155,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n   bfd_byte *ctfdata, *parentdata = NULL;\n   bfd_size_type ctfsize, parentsize;\n   ctf_sect_t ctfsect;\n-  ctf_file_t *parent = NULL;\n+  ctf_dict_t *parent = NULL;\n   int err;\n \n   if ((ctfdata = read_section_stabs (abfd, sect_name, &ctfsize, NULL)) == NULL)\n@@ -4204,7 +4204,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n   printf (_(\"Contents of CTF section %s:\\n\"), sanitize_string (sect_name));\n \n   ctf_archive_iter (ctfa, dump_ctf_archive_member, parent);\n-  ctf_file_close (parent);\n+  ctf_dict_close (parent);\n   ctf_close (ctfa);\n   ctf_close (parenta);\n   free (parentdata);"
    },
    {
      "sha": "e3b9f6f4d709e80eaea564ec2ee141652ffe008f",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -14598,7 +14598,7 @@ dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,\n \n /* Dump CTF errors/warnings.  */\n static void\n-dump_ctf_errs (ctf_file_t *fp)\n+dump_ctf_errs (ctf_dict_t *fp)\n {\n   ctf_next_t *it = NULL;\n   char *errtext;\n@@ -14619,9 +14619,9 @@ dump_ctf_errs (ctf_file_t *fp)\n /* Dump one CTF archive member.  */\n \n static int\n-dump_ctf_archive_member (ctf_file_t *ctf, const char *name, void *arg)\n+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n {\n-  ctf_file_t *parent = (ctf_file_t *) arg;\n+  ctf_dict_t *parent = (ctf_dict_t *) arg;\n   const char *things[] = {\"Header\", \"Labels\", \"Data objects\",\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n@@ -14685,7 +14685,7 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n   ctf_sect_t *\t       strsectp = NULL;\n   ctf_archive_t *      ctfa = NULL;\n   ctf_archive_t *      parenta = NULL, *lookparent;\n-  ctf_file_t *         parent = NULL;\n+  ctf_dict_t *         parent = NULL;\n \n   int err;\n   bfd_boolean ret = FALSE;\n@@ -14791,7 +14791,7 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n     ret = FALSE;\n \n  fail:\n-  ctf_file_close (parent);\n+  ctf_dict_close (parent);\n   ctf_close (ctfa);\n   ctf_close (parenta);\n   free (parentdata);"
    },
    {
      "sha": "3eaadddb6241ab1712eab7e452f2fdd089f539a8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -1,3 +1,8 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctfread.c: Change uses of ctf_file_t to ctf_dict_t.\n+\t(ctf_fp_info::~ctf_fp_info): Call ctf_dict_close, not ctf_file_close.\n+\n 2020-11-20  Pedro Alves  <pedro@palves.net>\n \n \t* language.c (language_arch_info::lookup_primitive_type): Use"
    },
    {
      "sha": "dd401efcb7266965eed921d8c3163c777696e414",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -91,29 +91,29 @@ static const struct objfile_key<htab, htab_deleter> ctf_tid_key;\n \n struct ctf_fp_info\n {\n-  explicit ctf_fp_info (ctf_file_t *cfp) : fp (cfp) {}\n+  explicit ctf_fp_info (ctf_dict_t *cfp) : fp (cfp) {}\n   ~ctf_fp_info ();\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n };\n \n-/* Cleanup function for the ctf_file_key data.  */\n+/* Cleanup function for the ctf_dict_key data.  */\n ctf_fp_info::~ctf_fp_info ()\n {\n   if (!fp)\n     return;\n \n   ctf_archive_t *arc = ctf_get_arc (fp);\n-  ctf_file_close (fp);\n+  ctf_dict_close (fp);\n   ctf_close (arc);\n }\n \n-static const objfile_key<ctf_fp_info> ctf_file_key;\n+static const objfile_key<ctf_fp_info> ctf_dict_key;\n \n /* A CTF context consists of a file pointer and an objfile pointer.  */\n \n struct ctf_context\n {\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n   struct objfile *of;\n   partial_symtab *pst;\n   struct buildsym_compunit *builder;\n@@ -272,7 +272,7 @@ get_tid_type (struct objfile *of, ctf_id_t tid)\n /* Return the size of storage in bits for INTEGER, FLOAT, or ENUM.  */\n \n static int\n-get_bitsize (ctf_file_t *fp, ctf_id_t tid, uint32_t kind)\n+get_bitsize (ctf_dict_t *fp, ctf_id_t tid, uint32_t kind)\n {\n   ctf_encoding_t cet;\n \n@@ -434,7 +434,7 @@ static struct symbol *\n new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n {\n   struct objfile *objfile = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct symbol *sym = NULL;\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n@@ -497,7 +497,7 @@ static struct type *\n read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   ctf_encoding_t cet;\n   struct type *type = NULL;\n   char *name;\n@@ -592,7 +592,7 @@ static struct type *\n read_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct type *type;\n   uint32_t kind;\n \n@@ -650,7 +650,7 @@ static struct type *\n read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct type *type, *rettype;\n   ctf_funcinfo_t cfi;\n \n@@ -676,7 +676,7 @@ static struct type *\n read_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct type *type, *target_type;\n   ctf_funcinfo_t fi;\n \n@@ -751,7 +751,7 @@ static struct type *\n read_array_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *objfile = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct type *element_type, *range_type, *idx_type;\n   struct type *type;\n   ctf_arinfo_t ar;\n@@ -816,7 +816,7 @@ static struct type *\n read_volatile_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n {\n   struct objfile *objfile = ccp->of;\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   struct type *base_type, *cv_type;\n \n   base_type = get_tid_type (objfile, btid);\n@@ -913,7 +913,7 @@ read_pointer_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n static struct type *\n read_type_record (struct ctf_context *ccp, ctf_id_t tid)\n {\n-  ctf_file_t *fp = ccp->fp;\n+  ctf_dict_t *fp = ccp->fp;\n   uint32_t kind;\n   struct type *type = NULL;\n   ctf_id_t btid;\n@@ -1310,7 +1310,7 @@ ctf_psymtab::read_symtab (struct objfile *objfile)\n \n static ctf_psymtab *\n create_partial_symtab (const char *name,\n-\t\t       ctf_file_t *cfp,\n+\t\t       ctf_dict_t *cfp,\n \t\t       struct objfile *objfile)\n {\n   ctf_psymtab *pst;\n@@ -1406,7 +1406,7 @@ ctf_psymtab_var_cb (const char *name, ctf_id_t id, void *arg)\n    debugging information is available.  */\n \n static void\n-scan_partial_symbols (ctf_file_t *cfp, struct objfile *of)\n+scan_partial_symbols (ctf_dict_t *cfp, struct objfile *of)\n {\n   bfd *abfd = of->obfd;\n   const char *name = bfd_get_filename (abfd);\n@@ -1482,11 +1482,11 @@ elfctf_build_psymtabs (struct objfile *of)\n     error (_(\"ctf_bfdopen failed on %s - %s\"),\n \t   bfd_get_filename (abfd), ctf_errmsg (err));\n \n-  ctf_file_t *fp = ctf_arc_open_by_name (arc, NULL, &err);\n+  ctf_dict_t *fp = ctf_arc_open_by_name (arc, NULL, &err);\n   if (fp == NULL)\n     error (_(\"ctf_arc_open_by_name failed on %s - %s\"),\n \t   bfd_get_filename (abfd), ctf_errmsg (err));\n-  ctf_file_key.emplace (of, fp);\n+  ctf_dict_key.emplace (of, fp);\n \n   scan_partial_symbols (fp, of);\n }"
    },
    {
      "sha": "e1fcc928369f3fe20082a14725c5ecacb1e1faad",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -1,3 +1,18 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_file_t): Rename to...\n+\t(ctf_dict_t): ... this.  Keep ctf_file_t around for compatibility.\n+\t(struct ctf_file): Likewise rename to...\n+\t(struct ctf_dict): ... this.\n+\t(ctf_file_close): Rename to...\n+\t(ctf_dict_close): ... this, keeping compatibility function.\n+\t(ctf_parent_file): Rename to...\n+\t(ctf_parent_dict): ... this, keeping compatibility function.\n+\tAll callers adjusted.\n+\t* ctf.h: Rename references to ctf_file_t to ctf_dict_t.\n+\t(struct ctf_archive) <ctfa_nfiles>: Rename to...\n+\t<ctfa_ndicts>: ... this.\n+\n 2020-11-18  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* elf/common.h (SHF_GNU_RETAIN): Define."
    },
    {
      "sha": "60e06b39ee7064be605f7ba4b6bfddf097504cdd",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 126,
      "deletions": 119,
      "changes": 245,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -34,13 +34,13 @@ extern \"C\"\n #endif\n \n /* Clients can open one or more CTF containers and obtain a pointer to an\n-   opaque ctf_file_t.  Types are identified by an opaque ctf_id_t token.\n+   opaque ctf_dict_t.  Types are identified by an opaque ctf_id_t token.\n    They can also open or create read-only archives of CTF containers in a\n    ctf_archive_t.\n \n    These opaque definitions allow libctf to evolve without breaking clients.  */\n \n-typedef struct ctf_file ctf_file_t;\n+typedef struct ctf_dict ctf_dict_t;\n typedef struct ctf_archive_internal ctf_archive_t;\n typedef unsigned long ctf_id_t;\n \n@@ -267,7 +267,7 @@ typedef int ctf_type_f (ctf_id_t type, void *arg);\n typedef int ctf_type_all_f (ctf_id_t type, int flag, void *arg);\n typedef int ctf_label_f (const char *name, const ctf_lblinfo_t *info,\n \t\t\t void *arg);\n-typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n+typedef int ctf_archive_member_f (ctf_dict_t *fp, const char *name, void *arg);\n typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n \t\t\t\t      size_t len, void *arg);\n typedef char *ctf_dump_decorate_f (ctf_sect_names_t sect,\n@@ -287,7 +287,7 @@ extern ctf_next_t *ctf_next_copy (ctf_next_t *);\n /* Opening.  These mostly return an abstraction over both CTF files and CTF\n    archives: so they can be used to open both.  CTF files will appear to be an\n    archive with one member named '.ctf'.  The low-level functions\n-   ctf_simple_open() and ctf_bufopen() return ctf_file_t's directly, and cannot\n+   ctf_simple_open() and ctf_bufopen() return ctf_dict_t's directly, and cannot\n    be used on CTF archives.  */\n \n extern ctf_archive_t *ctf_bfdopen (struct bfd *, int *);\n@@ -298,17 +298,17 @@ extern ctf_archive_t *ctf_fdopen (int fd, const char *filename,\n extern ctf_archive_t *ctf_open (const char *filename,\n \t\t\t\tconst char *target, int *errp);\n extern void ctf_close (ctf_archive_t *);\n-extern ctf_sect_t ctf_getdatasect (const ctf_file_t *);\n-extern ctf_archive_t *ctf_get_arc (const ctf_file_t *);\n+extern ctf_sect_t ctf_getdatasect (const ctf_dict_t *);\n+extern ctf_archive_t *ctf_get_arc (const ctf_dict_t *);\n extern ctf_archive_t *ctf_arc_open (const char *, int *);\n extern ctf_archive_t *ctf_arc_bufopen (const ctf_sect_t *,\n \t\t\t\t       const ctf_sect_t *,\n \t\t\t\t       const ctf_sect_t *,\n \t\t\t\t       int *);\n extern void ctf_arc_close (ctf_archive_t *);\n-extern ctf_file_t *ctf_arc_open_by_name (const ctf_archive_t *,\n+extern ctf_dict_t *ctf_arc_open_by_name (const ctf_archive_t *,\n \t\t\t\t\t const char *, int *);\n-extern ctf_file_t *ctf_arc_open_by_name_sections (const ctf_archive_t *,\n+extern ctf_dict_t *ctf_arc_open_by_name_sections (const ctf_archive_t *,\n \t\t\t\t\t\t  const ctf_sect_t *,\n \t\t\t\t\t\t  const ctf_sect_t *,\n \t\t\t\t\t\t  const char *, int *);\n@@ -317,95 +317,95 @@ extern size_t ctf_archive_count (const ctf_archive_t *);\n /* The next functions return or close real CTF files, or write out CTF archives,\n    not opaque containers around either.  */\n \n-extern ctf_file_t *ctf_simple_open (const char *, size_t, const char *, size_t,\n+extern ctf_dict_t *ctf_simple_open (const char *, size_t, const char *, size_t,\n \t\t\t\t   size_t, const char *, size_t, int *);\n-extern ctf_file_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,\n+extern ctf_dict_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,\n \t\t\t\tconst ctf_sect_t *, int *);\n-extern void ctf_ref (ctf_file_t *);\n-extern void ctf_file_close (ctf_file_t *);\n+extern void ctf_ref (ctf_dict_t *);\n+extern void ctf_dict_close (ctf_dict_t *);\n \n-extern int ctf_arc_write (const char *, ctf_file_t **, size_t,\n+extern int ctf_arc_write (const char *, ctf_dict_t **, size_t,\n \t\t\t  const char **, size_t);\n-extern int ctf_arc_write_fd (int, ctf_file_t **, size_t, const char **,\n+extern int ctf_arc_write_fd (int, ctf_dict_t **, size_t, const char **,\n \t\t\t     size_t);\n \n-extern const char *ctf_cuname (ctf_file_t *);\n-extern int ctf_cuname_set (ctf_file_t *, const char *);\n-extern ctf_file_t *ctf_parent_file (ctf_file_t *);\n-extern const char *ctf_parent_name (ctf_file_t *);\n-extern int ctf_parent_name_set (ctf_file_t *, const char *);\n-extern int ctf_type_isparent (ctf_file_t *, ctf_id_t);\n-extern int ctf_type_ischild (ctf_file_t *, ctf_id_t);\n+extern const char *ctf_cuname (ctf_dict_t *);\n+extern int ctf_cuname_set (ctf_dict_t *, const char *);\n+extern ctf_dict_t *ctf_parent_dict (ctf_dict_t *);\n+extern const char *ctf_parent_name (ctf_dict_t *);\n+extern int ctf_parent_name_set (ctf_dict_t *, const char *);\n+extern int ctf_type_isparent (ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_ischild (ctf_dict_t *, ctf_id_t);\n \n-extern int ctf_import (ctf_file_t *, ctf_file_t *);\n-extern int ctf_setmodel (ctf_file_t *, int);\n-extern int ctf_getmodel (ctf_file_t *);\n+extern int ctf_import (ctf_dict_t *, ctf_dict_t *);\n+extern int ctf_setmodel (ctf_dict_t *, int);\n+extern int ctf_getmodel (ctf_dict_t *);\n \n-extern void ctf_setspecific (ctf_file_t *, void *);\n-extern void *ctf_getspecific (ctf_file_t *);\n+extern void ctf_setspecific (ctf_dict_t *, void *);\n+extern void *ctf_getspecific (ctf_dict_t *);\n \n-extern int ctf_errno (ctf_file_t *);\n+extern int ctf_errno (ctf_dict_t *);\n extern const char *ctf_errmsg (int);\n extern int ctf_version (int);\n \n-extern int ctf_func_info (ctf_file_t *, unsigned long, ctf_funcinfo_t *);\n-extern int ctf_func_args (ctf_file_t *, unsigned long, uint32_t, ctf_id_t *);\n-extern int ctf_func_type_info (ctf_file_t *, ctf_id_t, ctf_funcinfo_t *);\n-extern int ctf_func_type_args (ctf_file_t *, ctf_id_t, uint32_t, ctf_id_t *);\n-\n-extern ctf_id_t ctf_lookup_by_name (ctf_file_t *, const char *);\n-extern ctf_id_t ctf_lookup_by_symbol (ctf_file_t *, unsigned long);\n-extern ctf_id_t ctf_lookup_variable (ctf_file_t *, const char *);\n-\n-extern ctf_id_t ctf_type_resolve (ctf_file_t *, ctf_id_t);\n-extern char *ctf_type_aname (ctf_file_t *, ctf_id_t);\n-extern char *ctf_type_aname_raw (ctf_file_t *, ctf_id_t);\n-extern ssize_t ctf_type_lname (ctf_file_t *, ctf_id_t, char *, size_t);\n-extern char *ctf_type_name (ctf_file_t *, ctf_id_t, char *, size_t);\n-extern const char *ctf_type_name_raw (ctf_file_t *, ctf_id_t);\n-extern ssize_t ctf_type_size (ctf_file_t *, ctf_id_t);\n-extern ssize_t ctf_type_align (ctf_file_t *, ctf_id_t);\n-extern int ctf_type_kind (ctf_file_t *, ctf_id_t);\n-extern int ctf_type_kind_forwarded (ctf_file_t *, ctf_id_t);\n-extern ctf_id_t ctf_type_reference (ctf_file_t *, ctf_id_t);\n-extern ctf_id_t ctf_type_pointer (ctf_file_t *, ctf_id_t);\n-extern int ctf_type_encoding (ctf_file_t *, ctf_id_t, ctf_encoding_t *);\n-extern int ctf_type_visit (ctf_file_t *, ctf_id_t, ctf_visit_f *, void *);\n-extern int ctf_type_cmp (ctf_file_t *, ctf_id_t, ctf_file_t *, ctf_id_t);\n-extern int ctf_type_compat (ctf_file_t *, ctf_id_t, ctf_file_t *, ctf_id_t);\n-\n-extern int ctf_member_info (ctf_file_t *, ctf_id_t, const char *,\n+extern int ctf_func_info (ctf_dict_t *, unsigned long, ctf_funcinfo_t *);\n+extern int ctf_func_args (ctf_dict_t *, unsigned long, uint32_t, ctf_id_t *);\n+extern int ctf_func_type_info (ctf_dict_t *, ctf_id_t, ctf_funcinfo_t *);\n+extern int ctf_func_type_args (ctf_dict_t *, ctf_id_t, uint32_t, ctf_id_t *);\n+\n+extern ctf_id_t ctf_lookup_by_name (ctf_dict_t *, const char *);\n+extern ctf_id_t ctf_lookup_by_symbol (ctf_dict_t *, unsigned long);\n+extern ctf_id_t ctf_lookup_variable (ctf_dict_t *, const char *);\n+\n+extern ctf_id_t ctf_type_resolve (ctf_dict_t *, ctf_id_t);\n+extern char *ctf_type_aname (ctf_dict_t *, ctf_id_t);\n+extern char *ctf_type_aname_raw (ctf_dict_t *, ctf_id_t);\n+extern ssize_t ctf_type_lname (ctf_dict_t *, ctf_id_t, char *, size_t);\n+extern char *ctf_type_name (ctf_dict_t *, ctf_id_t, char *, size_t);\n+extern const char *ctf_type_name_raw (ctf_dict_t *, ctf_id_t);\n+extern ssize_t ctf_type_size (ctf_dict_t *, ctf_id_t);\n+extern ssize_t ctf_type_align (ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_kind (ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_kind_forwarded (ctf_dict_t *, ctf_id_t);\n+extern ctf_id_t ctf_type_reference (ctf_dict_t *, ctf_id_t);\n+extern ctf_id_t ctf_type_pointer (ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_encoding (ctf_dict_t *, ctf_id_t, ctf_encoding_t *);\n+extern int ctf_type_visit (ctf_dict_t *, ctf_id_t, ctf_visit_f *, void *);\n+extern int ctf_type_cmp (ctf_dict_t *, ctf_id_t, ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_compat (ctf_dict_t *, ctf_id_t, ctf_dict_t *, ctf_id_t);\n+\n+extern int ctf_member_info (ctf_dict_t *, ctf_id_t, const char *,\n \t\t\t    ctf_membinfo_t *);\n-extern int ctf_array_info (ctf_file_t *, ctf_id_t, ctf_arinfo_t *);\n+extern int ctf_array_info (ctf_dict_t *, ctf_id_t, ctf_arinfo_t *);\n \n-extern const char *ctf_enum_name (ctf_file_t *, ctf_id_t, int);\n-extern int ctf_enum_value (ctf_file_t *, ctf_id_t, const char *, int *);\n+extern const char *ctf_enum_name (ctf_dict_t *, ctf_id_t, int);\n+extern int ctf_enum_value (ctf_dict_t *, ctf_id_t, const char *, int *);\n \n-extern void ctf_label_set (ctf_file_t *, const char *);\n-extern const char *ctf_label_get (ctf_file_t *);\n+extern void ctf_label_set (ctf_dict_t *, const char *);\n+extern const char *ctf_label_get (ctf_dict_t *);\n \n-extern const char *ctf_label_topmost (ctf_file_t *);\n-extern int ctf_label_info (ctf_file_t *, const char *, ctf_lblinfo_t *);\n+extern const char *ctf_label_topmost (ctf_dict_t *);\n+extern int ctf_label_info (ctf_dict_t *, const char *, ctf_lblinfo_t *);\n \n-extern int ctf_member_count (ctf_file_t *, ctf_id_t);\n-extern int ctf_member_iter (ctf_file_t *, ctf_id_t, ctf_member_f *, void *);\n-extern ssize_t ctf_member_next (ctf_file_t *, ctf_id_t, ctf_next_t **,\n+extern int ctf_member_count (ctf_dict_t *, ctf_id_t);\n+extern int ctf_member_iter (ctf_dict_t *, ctf_id_t, ctf_member_f *, void *);\n+extern ssize_t ctf_member_next (ctf_dict_t *, ctf_id_t, ctf_next_t **,\n \t\t\t\tconst char **name, ctf_id_t *membtype);\n-extern int ctf_enum_iter (ctf_file_t *, ctf_id_t, ctf_enum_f *, void *);\n-extern const char *ctf_enum_next (ctf_file_t *, ctf_id_t, ctf_next_t **,\n+extern int ctf_enum_iter (ctf_dict_t *, ctf_id_t, ctf_enum_f *, void *);\n+extern const char *ctf_enum_next (ctf_dict_t *, ctf_id_t, ctf_next_t **,\n \t\t\t\t  int *);\n-extern int ctf_type_iter (ctf_file_t *, ctf_type_f *, void *);\n-extern int ctf_type_iter_all (ctf_file_t *, ctf_type_all_f *, void *);\n-extern ctf_id_t ctf_type_next (ctf_file_t *, ctf_next_t **,\n+extern int ctf_type_iter (ctf_dict_t *, ctf_type_f *, void *);\n+extern int ctf_type_iter_all (ctf_dict_t *, ctf_type_all_f *, void *);\n+extern ctf_id_t ctf_type_next (ctf_dict_t *, ctf_next_t **,\n \t\t\t       int *flag, int want_hidden);\n-extern int ctf_label_iter (ctf_file_t *, ctf_label_f *, void *);\n-extern int ctf_label_next (ctf_file_t *, ctf_next_t **, const char **); /* TBD */\n-extern int ctf_variable_iter (ctf_file_t *, ctf_variable_f *, void *);\n-extern ctf_id_t ctf_variable_next (ctf_file_t *, ctf_next_t **,\n+extern int ctf_label_iter (ctf_dict_t *, ctf_label_f *, void *);\n+extern int ctf_label_next (ctf_dict_t *, ctf_next_t **, const char **); /* TBD */\n+extern int ctf_variable_iter (ctf_dict_t *, ctf_variable_f *, void *);\n+extern ctf_id_t ctf_variable_next (ctf_dict_t *, ctf_next_t **,\n \t\t\t\t   const char **);\n extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n \t\t\t     void *);\n-extern ctf_file_t *ctf_archive_next (const ctf_archive_t *, ctf_next_t **,\n+extern ctf_dict_t *ctf_archive_next (const ctf_archive_t *, ctf_next_t **,\n \t\t\t\t     const char **, int skip_parent, int *errp);\n \n /* This function alone does not currently operate on CTF files masquerading\n@@ -414,97 +414,104 @@ extern ctf_file_t *ctf_archive_next (const ctf_archive_t *, ctf_next_t **,\n    to deal with non-archives at all.  */\n extern int ctf_archive_raw_iter (const ctf_archive_t *,\n \t\t\t\t ctf_archive_raw_member_f *, void *);\n-extern char *ctf_dump (ctf_file_t *, ctf_dump_state_t **state,\n+extern char *ctf_dump (ctf_dict_t *, ctf_dump_state_t **state,\n \t\t       ctf_sect_names_t sect, ctf_dump_decorate_f *,\n \t\t       void *arg);\n \n /* Error-warning reporting: an 'iterator' that returns errors and warnings from\n    the error/warning list, in order of emission.  Errors and warnings are popped\n    after return: the caller must free the returned error-text pointer.  */\n-extern char *ctf_errwarning_next (ctf_file_t *, ctf_next_t **,\n+extern char *ctf_errwarning_next (ctf_dict_t *, ctf_next_t **,\n \t\t\t\t  int *is_warning, int *errp);\n \n-extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n+extern ctf_id_t ctf_add_array (ctf_dict_t *, uint32_t,\n \t\t\t       const ctf_arinfo_t *);\n-extern ctf_id_t ctf_add_const (ctf_file_t *, uint32_t, ctf_id_t);\n-extern ctf_id_t ctf_add_enum_encoded (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_const (ctf_dict_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_enum_encoded (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t      const ctf_encoding_t *);\n-extern ctf_id_t ctf_add_enum (ctf_file_t *, uint32_t, const char *);\n-extern ctf_id_t ctf_add_float (ctf_file_t *, uint32_t,\n+extern ctf_id_t ctf_add_enum (ctf_dict_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_float (ctf_dict_t *, uint32_t,\n \t\t\t       const char *, const ctf_encoding_t *);\n-extern ctf_id_t ctf_add_forward (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_forward (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t uint32_t);\n-extern ctf_id_t ctf_add_function (ctf_file_t *, uint32_t,\n+extern ctf_id_t ctf_add_function (ctf_dict_t *, uint32_t,\n \t\t\t\t  const ctf_funcinfo_t *, const ctf_id_t *);\n-extern ctf_id_t ctf_add_integer (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_integer (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t const ctf_encoding_t *);\n-extern ctf_id_t ctf_add_slice (ctf_file_t *, uint32_t, ctf_id_t, const ctf_encoding_t *);\n-extern ctf_id_t ctf_add_pointer (ctf_file_t *, uint32_t, ctf_id_t);\n-extern ctf_id_t ctf_add_type (ctf_file_t *, ctf_file_t *, ctf_id_t);\n-extern ctf_id_t ctf_add_typedef (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_slice (ctf_dict_t *, uint32_t, ctf_id_t, const ctf_encoding_t *);\n+extern ctf_id_t ctf_add_pointer (ctf_dict_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_type (ctf_dict_t *, ctf_dict_t *, ctf_id_t);\n+extern ctf_id_t ctf_add_typedef (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t ctf_id_t);\n-extern ctf_id_t ctf_add_restrict (ctf_file_t *, uint32_t, ctf_id_t);\n-extern ctf_id_t ctf_add_struct (ctf_file_t *, uint32_t, const char *);\n-extern ctf_id_t ctf_add_union (ctf_file_t *, uint32_t, const char *);\n-extern ctf_id_t ctf_add_struct_sized (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_restrict (ctf_dict_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_struct (ctf_dict_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_union (ctf_dict_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_struct_sized (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t      size_t);\n-extern ctf_id_t ctf_add_union_sized (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_union_sized (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t     size_t);\n-extern ctf_id_t ctf_add_volatile (ctf_file_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_volatile (ctf_dict_t *, uint32_t, ctf_id_t);\n \n-extern int ctf_add_enumerator (ctf_file_t *, ctf_id_t, const char *, int);\n-extern int ctf_add_member (ctf_file_t *, ctf_id_t, const char *, ctf_id_t);\n-extern int ctf_add_member_offset (ctf_file_t *, ctf_id_t, const char *,\n+extern int ctf_add_enumerator (ctf_dict_t *, ctf_id_t, const char *, int);\n+extern int ctf_add_member (ctf_dict_t *, ctf_id_t, const char *, ctf_id_t);\n+extern int ctf_add_member_offset (ctf_dict_t *, ctf_id_t, const char *,\n \t\t\t\t  ctf_id_t, unsigned long);\n-extern int ctf_add_member_encoded (ctf_file_t *, ctf_id_t, const char *,\n+extern int ctf_add_member_encoded (ctf_dict_t *, ctf_id_t, const char *,\n \t\t\t\t   ctf_id_t, unsigned long,\n \t\t\t\t   const ctf_encoding_t);\n \n-extern int ctf_add_variable (ctf_file_t *, const char *, ctf_id_t);\n+extern int ctf_add_variable (ctf_dict_t *, const char *, ctf_id_t);\n \n-extern int ctf_set_array (ctf_file_t *, ctf_id_t, const ctf_arinfo_t *);\n+extern int ctf_set_array (ctf_dict_t *, ctf_id_t, const ctf_arinfo_t *);\n \n-extern ctf_file_t *ctf_create (int *);\n-extern int ctf_update (ctf_file_t *);\n-extern ctf_snapshot_id_t ctf_snapshot (ctf_file_t *);\n-extern int ctf_rollback (ctf_file_t *, ctf_snapshot_id_t);\n-extern int ctf_discard (ctf_file_t *);\n-extern int ctf_write (ctf_file_t *, int);\n-extern int ctf_gzwrite (ctf_file_t *fp, gzFile fd);\n-extern int ctf_compress_write (ctf_file_t * fp, int fd);\n-extern unsigned char *ctf_write_mem (ctf_file_t *, size_t *, size_t threshold);\n+extern ctf_dict_t *ctf_create (int *);\n+extern int ctf_update (ctf_dict_t *);\n+extern ctf_snapshot_id_t ctf_snapshot (ctf_dict_t *);\n+extern int ctf_rollback (ctf_dict_t *, ctf_snapshot_id_t);\n+extern int ctf_discard (ctf_dict_t *);\n+extern int ctf_write (ctf_dict_t *, int);\n+extern int ctf_gzwrite (ctf_dict_t *fp, gzFile fd);\n+extern int ctf_compress_write (ctf_dict_t * fp, int fd);\n+extern unsigned char *ctf_write_mem (ctf_dict_t *, size_t *, size_t threshold);\n \n-extern int ctf_link_add_ctf (ctf_file_t *, ctf_archive_t *, const char *);\n+extern int ctf_link_add_ctf (ctf_dict_t *, ctf_archive_t *, const char *);\n /* The variable filter should return nonzero if a variable should not\n    appear in the output.  */\n-typedef int ctf_link_variable_filter_f (ctf_file_t *, const char *, ctf_id_t,\n+typedef int ctf_link_variable_filter_f (ctf_dict_t *, const char *, ctf_id_t,\n \t\t\t\t\tvoid *);\n-extern int ctf_link_set_variable_filter (ctf_file_t *,\n+extern int ctf_link_set_variable_filter (ctf_dict_t *,\n \t\t\t\t\t ctf_link_variable_filter_f *, void *);\n-extern int ctf_link (ctf_file_t *, int flags);\n+extern int ctf_link (ctf_dict_t *, int flags);\n typedef const char *ctf_link_strtab_string_f (uint32_t *offset, void *arg);\n-extern int ctf_link_add_strtab (ctf_file_t *, ctf_link_strtab_string_f *,\n+extern int ctf_link_add_strtab (ctf_dict_t *, ctf_link_strtab_string_f *,\n \t\t\t\tvoid *);\n typedef ctf_link_sym_t *ctf_link_iter_symbol_f (ctf_link_sym_t *dest,\n \t\t\t\t\t\tvoid *arg);\n-extern int ctf_link_shuffle_syms (ctf_file_t *, ctf_link_iter_symbol_f *,\n+extern int ctf_link_shuffle_syms (ctf_dict_t *, ctf_link_iter_symbol_f *,\n \t\t\t\t  void *);\n-extern unsigned char *ctf_link_write (ctf_file_t *, size_t *size,\n+extern unsigned char *ctf_link_write (ctf_dict_t *, size_t *size,\n \t\t\t\t      size_t threshold);\n \n /* Specialist linker functions.  These functions are not used by ld, but can be\n    used by other programs making use of the linker machinery for other purposes\n    to customize its output.  */\n-extern int ctf_link_add_cu_mapping (ctf_file_t *, const char *from,\n+extern int ctf_link_add_cu_mapping (ctf_dict_t *, const char *from,\n \t\t\t\t    const char *to);\n-typedef char *ctf_link_memb_name_changer_f (ctf_file_t *,\n+typedef char *ctf_link_memb_name_changer_f (ctf_dict_t *,\n \t\t\t\t\t    const char *, void *);\n extern void ctf_link_set_memb_name_changer\n-  (ctf_file_t *, ctf_link_memb_name_changer_f *, void *);\n+  (ctf_dict_t *, ctf_link_memb_name_changer_f *, void *);\n \n extern void ctf_setdebug (int debug);\n extern int ctf_getdebug (void);\n \n+/* Deprecated aliases for existing functions and types.  */\n+\n+struct ctf_file;\n+typedef struct ctf_dict ctf_file_t;\n+extern void ctf_file_close (ctf_file_t *);\n+extern ctf_dict_t *ctf_parent_file (ctf_dict_t *);\n+\n #ifdef\t__cplusplus\n }\n #endif"
    },
    {
      "sha": "6b8aa5315ca82eb66fde97e8900ea1997d59ae3c",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -552,7 +552,7 @@ typedef struct ctf_enum\n   int32_t cte_value;\t\t/* Value associated with this name.  */\n } ctf_enum_t;\n \n-/* The ctf_archive is a collection of ctf_file_t's stored together. The format\n+/* The ctf_archive is a collection of ctf_dict_t's stored together. The format\n    is suitable for mmap()ing: this control structure merely describes the\n    mmap()ed archive (and overlaps the first few bytes of it), hence the\n    greater care taken with integral types.  All CTF files in an archive\n@@ -578,20 +578,20 @@ struct ctf_archive\n   /* CTF data model.  */\n   uint64_t ctfa_model;\n \n-  /* Number of CTF files in the archive.  */\n-  uint64_t ctfa_nfiles;\n+  /* Number of CTF dicts in the archive.  */\n+  uint64_t ctfa_ndicts;\n \n   /* Offset of the name table.  */\n   uint64_t ctfa_names;\n \n   /* Offset of the CTF table.  Each element starts with a size (a uint64_t\n-     in network byte order) then a ctf_file_t of that size.  */\n+     in network byte order) then a ctf_dict_t of that size.  */\n   uint64_t ctfa_ctfs;\n };\n \n /* An array of ctfa_nnamed of this structure lies at\n    ctf_archive[ctf_archive->ctfa_modents] and gives the ctfa_ctfs or\n-   ctfa_names-relative offsets of each name or ctf_file_t.  */\n+   ctfa_names-relative offsets of each name or ctf_dict_t.  */\n \n typedef struct ctf_archive_modent\n {"
    },
    {
      "sha": "a00cfe96a1538063a81a905866c6b111d67d7dd8",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -1,3 +1,16 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ldlang.c (ctf_output): This is a ctf_dict_t now.\n+\t(lang_ctf_errs_warnings): Rename ctf_file_t to ctf_dict_t.\n+\t(ldlang_open_ctf): Adjust comment.\n+\t(lang_merge_ctf): Use ctf_dict_close, not ctf_file_close.\n+\t* ldelfgen.h (ldelf_examine_strtab_for_ctf): Rename ctf_file_t to\n+\tctf_dict_t.  Change opaque declaration accordingly.\n+\t* ldelfgen.c (ldelf_examine_strtab_for_ctf): Adjust.\n+\t* ldemul.h (examine_strtab_for_ctf): Likewise.\n+\t(ldemul_examine_strtab_for_ctf): Likewise.\n+\t* ldeuml.c (ldemul_examine_strtab_for_ctf): Likewise.\n+\n 2020-11-20  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* testsuite/ld-elf/retain3.s: Move symbolic reference into writeable"
    },
    {
      "sha": "e9496f918f5c316d0303a6b12355b0ab2b34b150",
      "filename": "ld/ldelfgen.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldelfgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldelfgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -175,7 +175,7 @@ ldelf_ctf_symbols_iter_cb (struct ctf_link_sym *dest,\n \n void\n ldelf_examine_strtab_for_ctf\n-  (struct ctf_file *ctf_output, struct elf_sym_strtab *syms,\n+  (struct ctf_dict *ctf_output, struct elf_sym_strtab *syms,\n    bfd_size_type symcount, struct elf_strtab_hash *symstrtab)\n {\n   struct ctf_strsym_iter_cb_arg args = { syms, symcount, symstrtab,\n@@ -205,7 +205,7 @@ extern int ldelf_emit_ctf_early (void)\n }\n \n extern void ldelf_examine_strtab_for_ctf\n-  (struct ctf_file *ctf_output ATTRIBUTE_UNUSED,\n+  (struct ctf_dict *ctf_output ATTRIBUTE_UNUSED,\n    struct elf_sym_strtab *syms ATTRIBUTE_UNUSED,\n    bfd_size_type symcount ATTRIBUTE_UNUSED,\n    struct elf_strtab_hash *symstrtab ATTRIBUTE_UNUSED)"
    },
    {
      "sha": "93bdf2981ba9c3d87e34f2e8358290901cccdc2f",
      "filename": "ld/ldelfgen.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldelfgen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldelfgen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -20,10 +20,10 @@\n \n struct elf_sym_strtab;\n struct elf_strtab_hash;\n-struct ctf_file;\n+struct ctf_dict;\n \n extern void ldelf_map_segments (bfd_boolean);\n extern int ldelf_emit_ctf_early (void);\n extern void ldelf_examine_strtab_for_ctf\n-  (struct ctf_file *ctf_output, struct elf_sym_strtab *syms,\n+  (struct ctf_dict *ctf_output, struct elf_sym_strtab *syms,\n    bfd_size_type symcount, struct elf_strtab_hash *symstrtab);"
    },
    {
      "sha": "6dc5112f7dd48907b00c4704af40bf427d587374",
      "filename": "ld/ldemul.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldemul.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldemul.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldemul.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -418,7 +418,7 @@ ldemul_emit_ctf_early (void)\n }\n \n void\n-ldemul_examine_strtab_for_ctf (struct ctf_file *ctf_output,\n+ldemul_examine_strtab_for_ctf (struct ctf_dict *ctf_output,\n \t\t\t       struct elf_sym_strtab *syms,\n \t\t\t       bfd_size_type symcount,\n \t\t\t       struct elf_strtab_hash *symstrtab)"
    },
    {
      "sha": "5efe4aa3a9f905755a1a94882a021e28eef63988",
      "filename": "ld/ldemul.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldemul.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldemul.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldemul.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -110,7 +110,7 @@ extern int ldemul_emit_ctf_early\n   (void);\n /* Called from per-target code to examine the strtab and symtab.  */\n extern void ldemul_examine_strtab_for_ctf\n-  (struct ctf_file *, struct elf_sym_strtab *, bfd_size_type,\n+  (struct ctf_dict *, struct elf_sym_strtab *, bfd_size_type,\n    struct elf_strtab_hash *);\n extern bfd_boolean ldemul_print_symbol\n   (struct bfd_link_hash_entry *hash_entry, void *ptr);\n@@ -236,7 +236,7 @@ typedef struct ld_emulation_xfer_struct {\n      waits until 'late'. (Late mode needs explicit support at per-target link\n      time to get called at all).  If set, called by ld when the examine_strtab\n      bfd_link_callback is invoked by per-target code.  */\n-  void (*examine_strtab_for_ctf) (struct ctf_file *, struct elf_sym_strtab *,\n+  void (*examine_strtab_for_ctf) (struct ctf_dict *, struct elf_sym_strtab *,\n \t\t\t\t  bfd_size_type, struct elf_strtab_hash *);\n \n   /* Called when printing a symbol to the map file.   AIX uses this"
    },
    {
      "sha": "eaf90a63cba0b1850b9e90d8214befb322b2481d",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -131,7 +131,7 @@ struct lang_phdr *lang_phdr_list;\n struct lang_nocrossrefs *nocrossref_list;\n struct asneeded_minfo **asneeded_list_tail;\n #ifdef ENABLE_LIBCTF\n-static ctf_file_t *ctf_output;\n+static ctf_dict_t *ctf_output;\n #endif\n \n /* Functions that traverse the linker script and might evaluate\n@@ -3674,7 +3674,7 @@ open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)\n /* Emit CTF errors and warnings.  fp can be NULL to report errors/warnings\n    that happened specifically at CTF open time.  */\n static void\n-lang_ctf_errs_warnings (ctf_file_t *fp)\n+lang_ctf_errs_warnings (ctf_dict_t *fp)\n {\n   ctf_next_t *i = NULL;\n   char *text;\n@@ -3713,7 +3713,7 @@ ldlang_open_ctf (void)\n     {\n       asection *sect;\n \n-      /* Incoming files from the compiler have a single ctf_file_t in them\n+      /* Incoming files from the compiler have a single ctf_dict_t in them\n \t (which is presented to us by the libctf API in a ctf_archive_t\n \t wrapper): files derived from a previous relocatable link have a CTF\n \t archive containing possibly many CTF files.  */\n@@ -3776,7 +3776,7 @@ lang_merge_ctf (void)\n   /* If the section was discarded, don't waste time merging.  */\n   if (output_sect == NULL)\n     {\n-      ctf_file_close (ctf_output);\n+      ctf_dict_close (ctf_output);\n       ctf_output = NULL;\n \n       LANG_FOR_EACH_INPUT_STATEMENT (file)\n@@ -3882,7 +3882,7 @@ lang_write_ctf (int late)\n     }\n \n   /* This also closes every CTF input file used in the link.  */\n-  ctf_file_close (ctf_output);\n+  ctf_dict_close (ctf_output);\n   ctf_output = NULL;\n \n   LANG_FOR_EACH_INPUT_STATEMENT (file)"
    },
    {
      "sha": "71a8e53384cd2970e54b92dec11af4ff438cd8fb",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 45,
      "deletions": 0,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -1,3 +1,48 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h: Rename ctf_file_t to ctf_dict_t: all declarations\n+\tadjusted.\n+\t(ctf_fileops): Rename to...\n+\t(ctf_dictops): ... this.\n+\t(ctf_dedup_t) <cd_id_to_file_t>: Rename to...\n+\t<cd_id_to_dict_t>: ... this.\n+\t(ctf_file_t): Fix outdated comment.\n+\t<ctf_fileops>: Rename to...\n+\t<ctf_dictops>: ... this.\n+\t(struct ctf_archive_internal) <ctfi_file>: Rename to...\n+\t<ctfi_dict>: ... this.\n+\t* ctf-archive.c: Rename ctf_file_t to ctf_dict_t.\n+\tRename ctf_archive.ctfa_nfiles to ctfa_ndicts.\n+\tRename ctf_file_close to ctf_dict_close.  All users adjusted.\n+\t* ctf-create.c: Likewise.  Refer to CTF dicts, not CTF containers.\n+\t(ctf_bundle_t) <ctb_file>: Rename to...\n+\t<ctb_dict): ... this.\n+\t* ctf-decl.c: Rename ctf_file_t to ctf_dict_t.\n+\t* ctf-dedup.c: Likewise.  Rename ctf_file_close to\n+\tctf_dict_close. Refer to CTF dicts, not CTF containers.\n+\t* ctf-dump.c: Likewise.\n+\t* ctf-error.c: Likewise.\n+\t* ctf-hash.c: Likewise.\n+\t* ctf-inlines.h: Likewise.\n+\t* ctf-labels.c: Likewise.\n+\t* ctf-link.c: Likewise.\n+\t* ctf-lookup.c: Likewise.\n+\t* ctf-open-bfd.c: Likewise.\n+\t* ctf-string.c: Likewise.\n+\t* ctf-subr.c: Likewise.\n+\t* ctf-types.c: Likewise.\n+\t* ctf-util.c: Likewise.\n+\t* ctf-open.c: Likewise.\n+\t(ctf_file_close): Rename to...\n+\t(ctf_dict_close): ...this.\n+\t(ctf_file_close): New trivial wrapper around ctf_dict_close, for\n+\tcompatibility.\n+\t(ctf_parent_file): Rename to...\n+\t(ctf_parent_dict): ... this.\n+\t(ctf_parent_file): New trivial wrapper around ctf_parent_dict, for\n+\tcompatibility.\n+\t* libctf.ver: Add ctf_dict_close and ctf_parent_dict.\n+\n 2020-10-21  Tom Tromey  <tromey@adacore.com>\n \n \t* mkerrors.sed: Remove."
    },
    {
      "sha": "90780da38340f9690792a1ce74c68f3316bad92c",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 58,
      "deletions": 58,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -32,8 +32,8 @@\n #include <sys/mman.h>\n #endif\n \n-static off_t arc_write_one_ctf (ctf_file_t * f, int fd, size_t threshold);\n-static ctf_file_t *ctf_arc_open_by_offset (const struct ctf_archive *arc,\n+static off_t arc_write_one_ctf (ctf_dict_t * f, int fd, size_t threshold);\n+static ctf_dict_t *ctf_arc_open_by_offset (const struct ctf_archive *arc,\n \t\t\t\t\t   const ctf_sect_t *symsect,\n \t\t\t\t\t   const ctf_sect_t *strsect,\n \t\t\t\t\t   size_t offset, int *errp);\n@@ -45,12 +45,12 @@ static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);\n \n /* Write out a CTF archive to the start of the file referenced by the passed-in\n-   fd.  The entries in CTF_FILES are referenced by name: the names are passed in\n-   the names array, which must have CTF_FILES entries.\n+   fd.  The entries in CTF_DICTS are referenced by name: the names are passed in\n+   the names array, which must have CTF_DICTS entries.\n \n    Returns 0 on success, or an errno, or an ECTF_* value.  */\n int\n-ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n+ctf_arc_write_fd (int fd, ctf_dict_t **ctf_dicts, size_t ctf_dict_cnt,\n \t\t  const char **names, size_t threshold)\n {\n   const char *errmsg;\n@@ -66,14 +66,14 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   struct ctf_archive_modent *modent;\n \n   ctf_dprintf (\"Writing CTF archive with %lu files\\n\",\n-\t       (unsigned long) ctf_file_cnt);\n+\t       (unsigned long) ctf_dict_cnt);\n \n   /* Figure out the size of the mmap()ed header, including the\n      ctf_archive_modent array.  We assume that all of this needs no\n      padding: a likely assumption, given that it's all made up of\n      uint64_t's.  */\n   headersz = sizeof (struct ctf_archive)\n-    + (ctf_file_cnt * sizeof (uint64_t) * 2);\n+    + (ctf_dict_cnt * sizeof (uint64_t) * 2);\n   ctf_dprintf (\"headersz is %lu\\n\", (unsigned long) headersz);\n \n   /* From now on we work in two pieces: an mmap()ed region from zero up to the\n@@ -101,7 +101,7 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   /* Fill in everything we can, which is everything other than the name\n      table offset.  */\n   archdr->ctfa_magic = htole64 (CTFA_MAGIC);\n-  archdr->ctfa_nfiles = htole64 (ctf_file_cnt);\n+  archdr->ctfa_ndicts = htole64 (ctf_dict_cnt);\n   archdr->ctfa_ctfs = htole64 (ctf_startoffs);\n \n   /* We could validate that all CTF files have the same data model, but\n@@ -112,8 +112,8 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n      this case, but we must be sure not to dereference uninitialized\n      memory.)  */\n \n-  if (ctf_file_cnt > 0)\n-    archdr->ctfa_model = htole64 (ctf_getmodel (ctf_files[0]));\n+  if (ctf_dict_cnt > 0)\n+    archdr->ctfa_model = htole64 (ctf_getmodel (ctf_dicts[0]));\n \n   /* Now write out the CTFs: ctf_archive_modent array via the mapping,\n      ctfs via write().  The names themselves have not been written yet: we\n@@ -122,7 +122,7 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n \n     The name table is not sorted.  */\n \n-  for (i = 0, namesz = 0; i < le64toh (archdr->ctfa_nfiles); i++)\n+  for (i = 0, namesz = 0; i < le64toh (archdr->ctfa_ndicts); i++)\n     namesz += strlen (names[i]) + 1;\n \n   nametbl = malloc (namesz);\n@@ -135,13 +135,13 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   for (i = 0, namesz = 0,\n        modent = (ctf_archive_modent_t *) ((char *) archdr\n \t\t\t\t\t  + sizeof (struct ctf_archive));\n-       i < le64toh (archdr->ctfa_nfiles); i++)\n+       i < le64toh (archdr->ctfa_ndicts); i++)\n     {\n       off_t off;\n \n       strcpy (&nametbl[namesz], names[i]);\n \n-      off = arc_write_one_ctf (ctf_files[i], fd, threshold);\n+      off = arc_write_one_ctf (ctf_dicts[i], fd, threshold);\n       if ((off < 0) && (off > -ECTF_BASE))\n \t{\n \t  errmsg = N_(\"ctf_arc_write(): cannot determine file \"\n@@ -163,7 +163,7 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n \n   ctf_qsort_r ((ctf_archive_modent_t *) ((char *) archdr\n \t\t\t\t\t + sizeof (struct ctf_archive)),\n-\t       le64toh (archdr->ctfa_nfiles),\n+\t       le64toh (archdr->ctfa_ndicts),\n \t       sizeof (struct ctf_archive_modent), sort_modent_by_name,\n \t       nametbl);\n \n@@ -204,37 +204,37 @@ ctf_arc_write_fd (int fd, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n   /* We report errors into the first file in the archive, if any: if this is a\n      zero-file archive, put it in the open-errors stream for lack of anywhere\n      else for it to go.  */\n-  ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno, \"%s\",\n+  ctf_err_warn (ctf_dict_cnt > 0 ? ctf_dicts[0] : NULL, 0, errno, \"%s\",\n \t\tgettext (errmsg));\n   return errno;\n }\n \n-/* Write out a CTF archive.  The entries in CTF_FILES are referenced by name:\n-   the names are passed in the names array, which must have CTF_FILES entries.\n+/* Write out a CTF archive.  The entries in CTF_DICTS are referenced by name:\n+   the names are passed in the names array, which must have CTF_DICTS entries.\n \n    If the filename is NULL, create a temporary file and return a pointer to it.\n \n    Returns 0 on success, or an errno, or an ECTF_* value.  */\n int\n-ctf_arc_write (const char *file, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n+ctf_arc_write (const char *file, ctf_dict_t **ctf_dicts, size_t ctf_dict_cnt,\n \t       const char **names, size_t threshold)\n {\n   int err;\n   int fd;\n \n   if ((fd = open (file, O_RDWR | O_CREAT | O_TRUNC | O_CLOEXEC, 0666)) < 0)\n     {\n-      ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno,\n+      ctf_err_warn (ctf_dict_cnt > 0 ? ctf_dicts[0] : NULL, 0, errno,\n \t\t    _(\"ctf_arc_write(): cannot create %s\"), file);\n       return errno;\n     }\n \n-  err = ctf_arc_write_fd (fd, ctf_files, ctf_file_cnt, names, threshold);\n+  err = ctf_arc_write_fd (fd, ctf_dicts, ctf_dict_cnt, names, threshold);\n   if (err)\n     goto err_close;\n \n   if ((err = close (fd)) < 0)\n-    ctf_err_warn (ctf_file_cnt > 0 ? ctf_files[0] : NULL, 0, errno,\n+    ctf_err_warn (ctf_dict_cnt > 0 ? ctf_dicts[0] : NULL, 0, errno,\n \t\t  _(\"ctf_arc_write(): cannot close after writing to archive\"));\n   goto err;\n \n@@ -252,13 +252,13 @@ ctf_arc_write (const char *file, ctf_file_t **ctf_files, size_t ctf_file_cnt,\n    negative errno or ctf_errno value.  On error, the file position may no longer\n    be at the end of the file.  */\n static off_t\n-arc_write_one_ctf (ctf_file_t * f, int fd, size_t threshold)\n+arc_write_one_ctf (ctf_dict_t * f, int fd, size_t threshold)\n {\n   off_t off, end_off;\n   uint64_t ctfsz = 0;\n   char *ctfszp;\n   size_t ctfsz_len;\n-  int (*writefn) (ctf_file_t * fp, int fd);\n+  int (*writefn) (ctf_dict_t * fp, int fd);\n \n   if (ctf_serialize (f) < 0)\n     return f->ctf_errno * -1;\n@@ -338,13 +338,13 @@ search_modent_by_name (const void *key, const void *ent, void *arg)\n }\n \n /* Make a new struct ctf_archive_internal wrapper for a ctf_archive or a\n-   ctf_file.  Closes ARC and/or FP on error.  Arrange to free the SYMSECT or\n+   ctf_dict.  Closes ARC and/or FP on error.  Arrange to free the SYMSECT or\n    STRSECT, as needed, on close.  Possibly do not unmap on close.  */\n \n struct ctf_archive_internal *\n ctf_new_archive_internal (int is_archive, int unmap_on_close,\n \t\t\t  struct ctf_archive *arc,\n-\t\t\t  ctf_file_t *fp, const ctf_sect_t *symsect,\n+\t\t\t  ctf_dict_t *fp, const ctf_sect_t *symsect,\n \t\t\t  const ctf_sect_t *strsect,\n \t\t\t  int *errp)\n {\n@@ -358,14 +358,14 @@ ctf_new_archive_internal (int is_archive, int unmap_on_close,\n \t    ctf_arc_close_internal (arc);\n \t}\n       else\n-\tctf_file_close (fp);\n+\tctf_dict_close (fp);\n       return (ctf_set_open_errno (errp, errno));\n     }\n   arci->ctfi_is_archive = is_archive;\n   if (is_archive)\n     arci->ctfi_archive = arc;\n   else\n-    arci->ctfi_file = fp;\n+    arci->ctfi_dict = fp;\n   if (symsect)\n      memcpy (&arci->ctfi_symsect, symsect, sizeof (struct ctf_sect));\n   if (strsect)\n@@ -386,7 +386,7 @@ ctf_arc_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n {\n   struct ctf_archive *arc = NULL;\n   int is_archive;\n-  ctf_file_t *fp = NULL;\n+  ctf_dict_t *fp = NULL;\n \n   if (ctfsect->cts_size > sizeof (uint64_t) &&\n       (le64toh ((*(uint64_t *) ctfsect->cts_data)) == CTFA_MAGIC))\n@@ -492,7 +492,7 @@ ctf_arc_close (ctf_archive_t *arc)\n \tctf_arc_close_internal (arc->ctfi_archive);\n     }\n   else\n-    ctf_file_close (arc->ctfi_file);\n+    ctf_dict_close (arc->ctfi_dict);\n   if (arc->ctfi_free_symsect)\n     free ((void *) arc->ctfi_symsect.cts_data);\n   if (arc->ctfi_free_strsect)\n@@ -503,9 +503,9 @@ ctf_arc_close (ctf_archive_t *arc)\n   free (arc);\n }\n \n-/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+/* Return the ctf_dict_t with the given name, or NULL if none, setting 'err' if\n    non-NULL.  A name of NULL means to open the default file.  */\n-static ctf_file_t *\n+static ctf_dict_t *\n ctf_arc_open_by_name_internal (const struct ctf_archive *arc,\n \t\t\t       const ctf_sect_t *symsect,\n \t\t\t       const ctf_sect_t *strsect,\n@@ -523,7 +523,7 @@ ctf_arc_open_by_name_internal (const struct ctf_archive *arc,\n \t\t\t\t     + sizeof (struct ctf_archive));\n \n   search_nametbl = (const char *) arc + le64toh (arc->ctfa_names);\n-  modent = bsearch_r (name, modent, le64toh (arc->ctfa_nfiles),\n+  modent = bsearch_r (name, modent, le64toh (arc->ctfa_ndicts),\n \t\t      sizeof (struct ctf_archive_modent),\n \t\t      search_modent_by_name, (void *) search_nametbl);\n \n@@ -540,13 +540,13 @@ ctf_arc_open_by_name_internal (const struct ctf_archive *arc,\n \t\t\t\t le64toh (modent->ctf_offset), errp);\n }\n \n-/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+/* Return the ctf_dict_t with the given name, or NULL if none, setting 'err' if\n    non-NULL.  A name of NULL means to open the default file.\n \n    Use the specified string and symbol table sections.\n \n    Public entry point.  */\n-ctf_file_t *\n+ctf_dict_t *\n ctf_arc_open_by_name_sections (const ctf_archive_t *arc,\n \t\t\t       const ctf_sect_t *symsect,\n \t\t\t       const ctf_sect_t *strsect,\n@@ -555,7 +555,7 @@ ctf_arc_open_by_name_sections (const ctf_archive_t *arc,\n {\n   if (arc->ctfi_is_archive)\n     {\n-      ctf_file_t *ret;\n+      ctf_dict_t *ret;\n       ret = ctf_arc_open_by_name_internal (arc->ctfi_archive, symsect, strsect,\n \t\t\t\t\t   name, errp);\n       if (ret)\n@@ -569,18 +569,18 @@ ctf_arc_open_by_name_sections (const ctf_archive_t *arc,\n \t*errp = ECTF_ARNNAME;\n       return NULL;\n     }\n-  arc->ctfi_file->ctf_archive = (ctf_archive_t *) arc;\n+  arc->ctfi_dict->ctf_archive = (ctf_archive_t *) arc;\n \n-  /* Bump the refcount so that the user can ctf_file_close() it.  */\n-  arc->ctfi_file->ctf_refcnt++;\n-  return arc->ctfi_file;\n+  /* Bump the refcount so that the user can ctf_dict_close() it.  */\n+  arc->ctfi_dict->ctf_refcnt++;\n+  return arc->ctfi_dict;\n }\n \n-/* Return the ctf_file_t with the given name, or NULL if none, setting 'err' if\n+/* Return the ctf_dict_t with the given name, or NULL if none, setting 'err' if\n    non-NULL.  A name of NULL means to open the default file.\n \n    Public entry point.  */\n-ctf_file_t *\n+ctf_dict_t *\n ctf_arc_open_by_name (const ctf_archive_t *arc, const char *name, int *errp)\n {\n   const ctf_sect_t *symsect = &arc->ctfi_symsect;\n@@ -594,16 +594,16 @@ ctf_arc_open_by_name (const ctf_archive_t *arc, const char *name, int *errp)\n   return ctf_arc_open_by_name_sections (arc, symsect, strsect, name, errp);\n }\n \n-/* Return the ctf_file_t at the given ctfa_ctfs-relative offset, or NULL if\n+/* Return the ctf_dict_t at the given ctfa_ctfs-relative offset, or NULL if\n    none, setting 'err' if non-NULL.  */\n-static ctf_file_t *\n+static ctf_dict_t *\n ctf_arc_open_by_offset (const struct ctf_archive *arc,\n \t\t\tconst ctf_sect_t *symsect,\n \t\t\tconst ctf_sect_t *strsect, size_t offset,\n \t\t\tint *errp)\n {\n   ctf_sect_t ctfsect;\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n \n   ctf_dprintf (\"ctf_arc_open_by_offset(%lu): opening\\n\", (unsigned long) offset);\n \n@@ -628,7 +628,7 @@ ctf_archive_count (const ctf_archive_t *wrapper)\n   if (!wrapper->ctfi_is_archive)\n     return 1;\n \n-  return wrapper->ctfi_archive->ctfa_nfiles;\n+  return wrapper->ctfi_archive->ctfa_ndicts;\n }\n \n /* Raw iteration over all CTF files in an archive.  We pass the raw data for all\n@@ -646,7 +646,7 @@ ctf_archive_raw_iter_internal (const struct ctf_archive *arc,\n \t\t\t\t     + sizeof (struct ctf_archive));\n   nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n \n-  for (i = 0; i < le64toh (arc->ctfa_nfiles); i++)\n+  for (i = 0; i < le64toh (arc->ctfa_ndicts); i++)\n     {\n       const char *name;\n       char *fp;\n@@ -686,15 +686,15 @@ ctf_archive_iter_internal (const ctf_archive_t *wrapper,\n {\n   int rc;\n   size_t i;\n-  ctf_file_t *f;\n+  ctf_dict_t *f;\n   struct ctf_archive_modent *modent;\n   const char *nametbl;\n \n   modent = (ctf_archive_modent_t *) ((char *) arc\n \t\t\t\t     + sizeof (struct ctf_archive));\n   nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n \n-  for (i = 0; i < le64toh (arc->ctfa_nfiles); i++)\n+  for (i = 0; i < le64toh (arc->ctfa_ndicts); i++)\n     {\n       const char *name;\n \n@@ -706,11 +706,11 @@ ctf_archive_iter_internal (const ctf_archive_t *wrapper,\n       f->ctf_archive = (ctf_archive_t *) wrapper;\n       if ((rc = func (f, name, data)) != 0)\n \t{\n-\t  ctf_file_close (f);\n+\t  ctf_dict_close (f);\n \t  return rc;\n \t}\n \n-      ctf_file_close (f);\n+      ctf_dict_close (f);\n     }\n   return 0;\n }\n@@ -733,23 +733,23 @@ ctf_archive_iter (const ctf_archive_t *arc, ctf_archive_member_f *func,\n     return ctf_archive_iter_internal (arc, arc->ctfi_archive, symsect, strsect,\n \t\t\t\t      func, data);\n \n-  return func (arc->ctfi_file, _CTF_SECTION, data);\n+  return func (arc->ctfi_dict, _CTF_SECTION, data);\n }\n \n /* Iterate over all CTF files in an archive, returning each dict in turn as a\n-   ctf_file_t, and NULL on error or end of iteration.  It is the caller's\n+   ctf_dict_t, and NULL on error or end of iteration.  It is the caller's\n    responsibility to close it.  Parent dicts may be skipped.  Regardless of\n    whether they are skipped or not, the caller must ctf_import the parent if\n    need be.\n \n    We identify parents by name rather than by flag value: for now, with the\n    linker only emitting parents named _CTF_SECTION, this works well enough.  */\n \n-ctf_file_t *\n+ctf_dict_t *\n ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **name,\n \t\t  int skip_parent, int *errp)\n {\n-  ctf_file_t *f;\n+  ctf_dict_t *f;\n   ctf_next_t *i = *it;\n   struct ctf_archive *arc;\n   struct ctf_archive_modent *modent;\n@@ -783,7 +783,7 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n       return NULL;\n     }\n \n-  /* Iteration is made a bit more complex by the need to handle ctf_file_t's\n+  /* Iteration is made a bit more complex by the need to handle ctf_dict_t's\n      transparently wrapped in a single-member archive.  These are parents: if\n      skip_parent is on, they are skipped and the iterator terminates\n      immediately.  */\n@@ -793,8 +793,8 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n       i->ctn_n++;\n       if (!skip_parent)\n \t{\n-\t  wrapper->ctfi_file->ctf_refcnt++;\n-\t  return wrapper->ctfi_file;\n+\t  wrapper->ctfi_dict->ctf_refcnt++;\n+\t  return wrapper->ctfi_dict;\n \t}\n     }\n \n@@ -809,7 +809,7 @@ ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **na\n \n   do\n     {\n-      if ((!wrapper->ctfi_is_archive) || (i->ctn_n >= le64toh (arc->ctfa_nfiles)))\n+      if ((!wrapper->ctfi_is_archive) || (i->ctn_n >= le64toh (arc->ctfa_ndicts)))\n \t{\n \t  ctf_next_destroy (i);\n \t  *it = NULL;"
    },
    {
      "sha": "c1a7a8ac62d9ea3d6750b1c4a72304219946441d",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 113,
      "deletions": 113,
      "changes": 226,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -38,7 +38,7 @@\n    at a time.  */\n \n static int\n-ctf_grow_ptrtab (ctf_file_t *fp)\n+ctf_grow_ptrtab (ctf_dict_t *fp)\n {\n   size_t new_ptrtab_len = fp->ctf_ptrtab_len;\n \n@@ -66,12 +66,12 @@ ctf_grow_ptrtab (ctf_file_t *fp)\n   return 0;\n }\n \n-/* To create an empty CTF container, we just declare a zeroed header and call\n-   ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w\n-   and initialize the dynamic members.  We start assigning type IDs at 1 because\n+/* To create an empty CTF dict, we just declare a zeroed header and call\n+   ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new dict r/w and\n+   initialize the dynamic members.  We start assigning type IDs at 1 because\n    type ID 0 is used as a sentinel and a not-found indicator.  */\n \n-ctf_file_t *\n+ctf_dict_t *\n ctf_create (int *errp)\n {\n   static const ctf_header_t hdr = { .cth_preamble = { CTF_MAGIC, CTF_VERSION, 0 } };\n@@ -80,7 +80,7 @@ ctf_create (int *errp)\n   ctf_dynhash_t *dvhash;\n   ctf_dynhash_t *structs = NULL, *unions = NULL, *enums = NULL, *names = NULL;\n   ctf_sect_t cts;\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n \n   libctf_init_debug();\n   dthash = ctf_dynhash_create (ctf_hash_integer, ctf_hash_eq_integer,\n@@ -137,7 +137,7 @@ ctf_create (int *errp)\n   if (ctf_grow_ptrtab (fp) < 0)\n     {\n       ctf_set_open_errno (errp, ctf_errno (fp));\n-      ctf_file_close (fp);\n+      ctf_dict_close (fp);\n       return NULL;\n     }\n \n@@ -156,7 +156,7 @@ ctf_create (int *errp)\n }\n \n static unsigned char *\n-ctf_copy_smembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_member_t ctm;\n@@ -181,7 +181,7 @@ ctf_copy_smembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n }\n \n static unsigned char *\n-ctf_copy_lmembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_lmember_t ctlm;\n@@ -207,7 +207,7 @@ ctf_copy_lmembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n }\n \n static unsigned char *\n-ctf_copy_emembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n+ctf_copy_emembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n   ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n   ctf_enum_t cte;\n@@ -230,7 +230,7 @@ ctf_copy_emembers (ctf_file_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n \n typedef struct ctf_sort_var_arg_cb\n {\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n   ctf_strs_t *strtab;\n } ctf_sort_var_arg_cb_t;\n \n@@ -247,7 +247,7 @@ ctf_sort_var (const void *one_, const void *two_, void *arg_)\n \n /* Compatibility: just update the threshold for ctf_discard.  */\n int\n-ctf_update (ctf_file_t *fp)\n+ctf_update (ctf_dict_t *fp)\n {\n   if (!(fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (fp, ECTF_RDONLY));\n@@ -256,20 +256,20 @@ ctf_update (ctf_file_t *fp)\n   return 0;\n }\n \n-/* If the specified CTF container is writable and has been modified, reload this\n-   container with the updated type definitions, ready for serialization.  In\n-   order to make this code and the rest of libctf as simple as possible, we\n-   perform updates by taking the dynamic type definitions and creating an\n-   in-memory CTF file containing the definitions, and then call\n-   ctf_simple_open_internal() on it.  We perform one extra trick here for the\n-   benefit of callers and to keep our code simple: ctf_simple_open_internal()\n-   will return a new ctf_file_t, but we want to keep the fp constant for the\n-   caller, so after ctf_simple_open_internal() returns, we use memcpy to swap\n-   the interior of the old and new ctf_file_t's, and then free the old.  */\n+/* If the specified CTF dict is writable and has been modified, reload this dict\n+   with the updated type definitions, ready for serialization.  In order to make\n+   this code and the rest of libctf as simple as possible, we perform updates by\n+   taking the dynamic type definitions and creating an in-memory CTF dict\n+   containing the definitions, and then call ctf_simple_open_internal() on it.\n+   We perform one extra trick here for the benefit of callers and to keep our\n+   code simple: ctf_simple_open_internal() will return a new ctf_dict_t, but we\n+   want to keep the fp constant for the caller, so after\n+   ctf_simple_open_internal() returns, we use memcpy to swap the interior of the\n+   old and new ctf_dict_t's, and then free the old.  */\n int\n-ctf_serialize (ctf_file_t *fp)\n+ctf_serialize (ctf_dict_t *fp)\n {\n-  ctf_file_t ofp, *nfp;\n+  ctf_dict_t ofp, *nfp;\n   ctf_header_t hdr, *hdrp;\n   ctf_dtdef_t *dtd;\n   ctf_dvdef_t *dvd;\n@@ -508,8 +508,8 @@ ctf_serialize (ctf_file_t *fp)\n   buf_size += hdrp->cth_strlen;\n   free (strtab.cts_strs);\n \n-  /* Finally, we are ready to ctf_simple_open() the new container.  If this\n-     is successful, we then switch nfp and fp and free the old container.  */\n+  /* Finally, we are ready to ctf_simple_open() the new dict.  If this is\n+     successful, we then switch nfp and fp and free the old dict.  */\n \n   if ((nfp = ctf_simple_open_internal ((char *) buf, buf_size, NULL, 0,\n \t\t\t\t       0, NULL, 0, fp->ctf_syn_ext_strtab,\n@@ -591,18 +591,18 @@ ctf_serialize (ctf_file_t *fp)\n   fp->ctf_enums.ctn_writable = NULL;\n   fp->ctf_names.ctn_writable = NULL;\n \n-  memcpy (&ofp, fp, sizeof (ctf_file_t));\n-  memcpy (fp, nfp, sizeof (ctf_file_t));\n-  memcpy (nfp, &ofp, sizeof (ctf_file_t));\n+  memcpy (&ofp, fp, sizeof (ctf_dict_t));\n+  memcpy (fp, nfp, sizeof (ctf_dict_t));\n+  memcpy (nfp, &ofp, sizeof (ctf_dict_t));\n \n   nfp->ctf_refcnt = 1;\t\t/* Force nfp to be freed.  */\n-  ctf_file_close (nfp);\n+  ctf_dict_close (nfp);\n \n   return 0;\n }\n \n ctf_names_t *\n-ctf_name_table (ctf_file_t *fp, int kind)\n+ctf_name_table (ctf_dict_t *fp, int kind)\n {\n   switch (kind)\n     {\n@@ -618,7 +618,7 @@ ctf_name_table (ctf_file_t *fp, int kind)\n }\n \n int\n-ctf_dtd_insert (ctf_file_t *fp, ctf_dtdef_t *dtd, int flag, int kind)\n+ctf_dtd_insert (ctf_dict_t *fp, ctf_dtdef_t *dtd, int flag, int kind)\n {\n   const char *name;\n   if (ctf_dynhash_insert (fp->ctf_dthash, (void *) (uintptr_t) dtd->dtd_type,\n@@ -642,7 +642,7 @@ ctf_dtd_insert (ctf_file_t *fp, ctf_dtdef_t *dtd, int flag, int kind)\n }\n \n void\n-ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n+ctf_dtd_delete (ctf_dict_t *fp, ctf_dtdef_t *dtd)\n {\n   ctf_dmdef_t *dmd, *nmd;\n   int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n@@ -687,14 +687,14 @@ ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n }\n \n ctf_dtdef_t *\n-ctf_dtd_lookup (const ctf_file_t *fp, ctf_id_t type)\n+ctf_dtd_lookup (const ctf_dict_t *fp, ctf_id_t type)\n {\n   return (ctf_dtdef_t *)\n     ctf_dynhash_lookup (fp->ctf_dthash, (void *) (uintptr_t) type);\n }\n \n ctf_dtdef_t *\n-ctf_dynamic_type (const ctf_file_t *fp, ctf_id_t id)\n+ctf_dynamic_type (const ctf_dict_t *fp, ctf_id_t id)\n {\n   ctf_id_t idx;\n \n@@ -712,7 +712,7 @@ ctf_dynamic_type (const ctf_file_t *fp, ctf_id_t id)\n }\n \n int\n-ctf_dvd_insert (ctf_file_t *fp, ctf_dvdef_t *dvd)\n+ctf_dvd_insert (ctf_dict_t *fp, ctf_dvdef_t *dvd)\n {\n   if (ctf_dynhash_insert (fp->ctf_dvhash, dvd->dvd_name, dvd) < 0)\n     return -1;\n@@ -721,7 +721,7 @@ ctf_dvd_insert (ctf_file_t *fp, ctf_dvdef_t *dvd)\n }\n \n void\n-ctf_dvd_delete (ctf_file_t *fp, ctf_dvdef_t *dvd)\n+ctf_dvd_delete (ctf_dict_t *fp, ctf_dvdef_t *dvd)\n {\n   ctf_dynhash_remove (fp->ctf_dvhash, dvd->dvd_name);\n   free (dvd->dvd_name);\n@@ -731,20 +731,20 @@ ctf_dvd_delete (ctf_file_t *fp, ctf_dvdef_t *dvd)\n }\n \n ctf_dvdef_t *\n-ctf_dvd_lookup (const ctf_file_t *fp, const char *name)\n+ctf_dvd_lookup (const ctf_dict_t *fp, const char *name)\n {\n   return (ctf_dvdef_t *) ctf_dynhash_lookup (fp->ctf_dvhash, name);\n }\n \n /* Discard all of the dynamic type definitions and variable definitions that\n-   have been added to the container since the last call to ctf_update().  We\n-   locate such types by scanning the dtd list and deleting elements that have\n-   type IDs greater than ctf_dtoldid, which is set by ctf_update(), above, and\n-   by scanning the variable list and deleting elements that have update IDs\n-   equal to the current value of the last-update snapshot count (indicating that\n-   they were added after the most recent call to ctf_update()).  */\n+   have been added to the dict since the last call to ctf_update().  We locate\n+   such types by scanning the dtd list and deleting elements that have type IDs\n+   greater than ctf_dtoldid, which is set by ctf_update(), above, and by\n+   scanning the variable list and deleting elements that have update IDs equal\n+   to the current value of the last-update snapshot count (indicating that they\n+   were added after the most recent call to ctf_update()).  */\n int\n-ctf_discard (ctf_file_t *fp)\n+ctf_discard (ctf_dict_t *fp)\n {\n   ctf_snapshot_id_t last_update =\n     { fp->ctf_dtoldid,\n@@ -758,7 +758,7 @@ ctf_discard (ctf_file_t *fp)\n }\n \n ctf_snapshot_id_t\n-ctf_snapshot (ctf_file_t *fp)\n+ctf_snapshot (ctf_dict_t *fp)\n {\n   ctf_snapshot_id_t snapid;\n   snapid.dtd_id = fp->ctf_typemax;\n@@ -768,7 +768,7 @@ ctf_snapshot (ctf_file_t *fp)\n \n /* Like ctf_discard(), only discards everything after a particular ID.  */\n int\n-ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n+ctf_rollback (ctf_dict_t *fp, ctf_snapshot_id_t id)\n {\n   ctf_dtdef_t *dtd, *ntd;\n   ctf_dvdef_t *dvd, *nvd;\n@@ -826,7 +826,7 @@ ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n }\n \n static ctf_id_t\n-ctf_add_generic (ctf_file_t *fp, uint32_t flag, const char *name, int kind,\n+ctf_add_generic (ctf_dict_t *fp, uint32_t flag, const char *name, int kind,\n \t\t ctf_dtdef_t **rp)\n {\n   ctf_dtdef_t *dtd;\n@@ -893,7 +893,7 @@ clp2 (size_t x)\n }\n \n ctf_id_t\n-ctf_add_encoded (ctf_file_t *fp, uint32_t flag,\n+ctf_add_encoded (ctf_dict_t *fp, uint32_t flag,\n \t\t const char *name, const ctf_encoding_t *ep, uint32_t kind)\n {\n   ctf_dtdef_t *dtd;\n@@ -914,11 +914,11 @@ ctf_add_encoded (ctf_file_t *fp, uint32_t flag,\n }\n \n ctf_id_t\n-ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n+ctf_add_reftype (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n   int child = fp->ctf_flags & LCTF_CHILD;\n \n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n@@ -963,15 +963,15 @@ ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n }\n \n ctf_id_t\n-ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n+ctf_add_slice (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref,\n \t       const ctf_encoding_t *ep)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t resolved_ref = ref;\n   ctf_id_t type;\n   int kind;\n   const ctf_type_t *tp;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n \n   if (ep == NULL)\n     return (ctf_set_errno (fp, EINVAL));\n@@ -1011,31 +1011,31 @@ ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n }\n \n ctf_id_t\n-ctf_add_integer (ctf_file_t *fp, uint32_t flag,\n+ctf_add_integer (ctf_dict_t *fp, uint32_t flag,\n \t\t const char *name, const ctf_encoding_t *ep)\n {\n   return (ctf_add_encoded (fp, flag, name, ep, CTF_K_INTEGER));\n }\n \n ctf_id_t\n-ctf_add_float (ctf_file_t *fp, uint32_t flag,\n+ctf_add_float (ctf_dict_t *fp, uint32_t flag,\n \t       const char *name, const ctf_encoding_t *ep)\n {\n   return (ctf_add_encoded (fp, flag, name, ep, CTF_K_FLOAT));\n }\n \n ctf_id_t\n-ctf_add_pointer (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+ctf_add_pointer (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref)\n {\n   return (ctf_add_reftype (fp, flag, ref, CTF_K_POINTER));\n }\n \n ctf_id_t\n-ctf_add_array (ctf_file_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n+ctf_add_array (ctf_dict_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n \n   if (arp == NULL)\n     return (ctf_set_errno (fp, EINVAL));\n@@ -1059,7 +1059,7 @@ ctf_add_array (ctf_file_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n }\n \n int\n-ctf_set_array (ctf_file_t *fp, ctf_id_t type, const ctf_arinfo_t *arp)\n+ctf_set_array (ctf_dict_t *fp, ctf_id_t type, const ctf_arinfo_t *arp)\n {\n   ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, type);\n \n@@ -1077,14 +1077,14 @@ ctf_set_array (ctf_file_t *fp, ctf_id_t type, const ctf_arinfo_t *arp)\n }\n \n ctf_id_t\n-ctf_add_function (ctf_file_t *fp, uint32_t flag,\n+ctf_add_function (ctf_dict_t *fp, uint32_t flag,\n \t\t  const ctf_funcinfo_t *ctc, const ctf_id_t *argv)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n   uint32_t vlen;\n   uint32_t *vdat = NULL;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n   size_t i;\n \n   if (ctc == NULL || (ctc->ctc_flags & ~CTF_FUNC_VARARG) != 0\n@@ -1134,7 +1134,7 @@ ctf_add_function (ctf_file_t *fp, uint32_t flag,\n }\n \n ctf_id_t\n-ctf_add_struct_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_struct_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n \t\t      size_t size)\n {\n   ctf_dtdef_t *dtd;\n@@ -1165,13 +1165,13 @@ ctf_add_struct_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n }\n \n ctf_id_t\n-ctf_add_struct (ctf_file_t *fp, uint32_t flag, const char *name)\n+ctf_add_struct (ctf_dict_t *fp, uint32_t flag, const char *name)\n {\n   return (ctf_add_struct_sized (fp, flag, name, 0));\n }\n \n ctf_id_t\n-ctf_add_union_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_union_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n \t\t     size_t size)\n {\n   ctf_dtdef_t *dtd;\n@@ -1202,13 +1202,13 @@ ctf_add_union_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n }\n \n ctf_id_t\n-ctf_add_union (ctf_file_t *fp, uint32_t flag, const char *name)\n+ctf_add_union (ctf_dict_t *fp, uint32_t flag, const char *name)\n {\n   return (ctf_add_union_sized (fp, flag, name, 0));\n }\n \n ctf_id_t\n-ctf_add_enum (ctf_file_t *fp, uint32_t flag, const char *name)\n+ctf_add_enum (ctf_dict_t *fp, uint32_t flag, const char *name)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n@@ -1230,7 +1230,7 @@ ctf_add_enum (ctf_file_t *fp, uint32_t flag, const char *name)\n }\n \n ctf_id_t\n-ctf_add_enum_encoded (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_enum_encoded (ctf_dict_t *fp, uint32_t flag, const char *name,\n \t\t      const ctf_encoding_t *ep)\n {\n   ctf_id_t type = 0;\n@@ -1258,7 +1258,7 @@ ctf_add_enum_encoded (ctf_file_t *fp, uint32_t flag, const char *name,\n }\n \n ctf_id_t\n-ctf_add_forward (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_forward (ctf_dict_t *fp, uint32_t flag, const char *name,\n \t\t uint32_t kind)\n {\n   ctf_dtdef_t *dtd;\n@@ -1286,12 +1286,12 @@ ctf_add_forward (ctf_file_t *fp, uint32_t flag, const char *name,\n }\n \n ctf_id_t\n-ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n+ctf_add_typedef (ctf_dict_t *fp, uint32_t flag, const char *name,\n \t\t ctf_id_t ref)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n \n   if (ref == CTF_ERR || ref > CTF_MAX_TYPE)\n     return (ctf_set_errno (fp, EINVAL));\n@@ -1310,25 +1310,25 @@ ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n }\n \n ctf_id_t\n-ctf_add_volatile (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+ctf_add_volatile (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref)\n {\n   return (ctf_add_reftype (fp, flag, ref, CTF_K_VOLATILE));\n }\n \n ctf_id_t\n-ctf_add_const (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+ctf_add_const (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref)\n {\n   return (ctf_add_reftype (fp, flag, ref, CTF_K_CONST));\n }\n \n ctf_id_t\n-ctf_add_restrict (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+ctf_add_restrict (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref)\n {\n   return (ctf_add_reftype (fp, flag, ref, CTF_K_RESTRICT));\n }\n \n int\n-ctf_add_enumerator (ctf_file_t *fp, ctf_id_t enid, const char *name,\n+ctf_add_enumerator (ctf_dict_t *fp, ctf_id_t enid, const char *name,\n \t\t    int value)\n {\n   ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, enid);\n@@ -1386,7 +1386,7 @@ ctf_add_enumerator (ctf_file_t *fp, ctf_id_t enid, const char *name,\n }\n \n int\n-ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t\t       ctf_id_t type, unsigned long bit_offset)\n {\n   ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, souid);\n@@ -1530,7 +1530,7 @@ ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n }\n \n int\n-ctf_add_member_encoded (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+ctf_add_member_encoded (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t\t\tctf_id_t type, unsigned long bit_offset,\n \t\t\tconst ctf_encoding_t encoding)\n {\n@@ -1548,17 +1548,17 @@ ctf_add_member_encoded (ctf_file_t *fp, ctf_id_t souid, const char *name,\n }\n \n int\n-ctf_add_member (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+ctf_add_member (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t\tctf_id_t type)\n {\n   return ctf_add_member_offset (fp, souid, name, type, (unsigned long) - 1);\n }\n \n int\n-ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n+ctf_add_variable (ctf_dict_t *fp, const char *name, ctf_id_t ref)\n {\n   ctf_dvdef_t *dvd;\n-  ctf_file_t *tmp = fp;\n+  ctf_dict_t *tmp = fp;\n \n   if (!(fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (fp, ECTF_RDONLY));\n@@ -1598,7 +1598,7 @@ ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n \n typedef struct ctf_bundle\n {\n-  ctf_file_t *ctb_file;\t\t/* CTF container handle.  */\n+  ctf_dict_t *ctb_dict;\t\t/* CTF dict handle.  */\n   ctf_id_t ctb_type;\t\t/* CTF type identifier.  */\n   ctf_dtdef_t *ctb_dtd;\t\t/* CTF dynamic type definition (if any).  */\n } ctf_bundle_t;\n@@ -1609,15 +1609,15 @@ enumcmp (const char *name, int value, void *arg)\n   ctf_bundle_t *ctb = arg;\n   int bvalue;\n \n-  if (ctf_enum_value (ctb->ctb_file, ctb->ctb_type, name, &bvalue) < 0)\n+  if (ctf_enum_value (ctb->ctb_dict, ctb->ctb_type, name, &bvalue) < 0)\n     {\n-      ctf_err_warn (ctb->ctb_file, 0, 0,\n+      ctf_err_warn (ctb->ctb_dict, 0, 0,\n \t\t    _(\"conflict due to enum %s iteration error\"), name);\n       return 1;\n     }\n   if (value != bvalue)\n     {\n-      ctf_err_warn (ctb->ctb_file, 1, ECTF_CONFLICT,\n+      ctf_err_warn (ctb->ctb_dict, 1, ECTF_CONFLICT,\n \t\t    _(\"conflict due to enum value change: %i versus %i\"),\n \t\t    value, bvalue);\n       return 1;\n@@ -1630,7 +1630,7 @@ enumadd (const char *name, int value, void *arg)\n {\n   ctf_bundle_t *ctb = arg;\n \n-  return (ctf_add_enumerator (ctb->ctb_file, ctb->ctb_type,\n+  return (ctf_add_enumerator (ctb->ctb_dict, ctb->ctb_type,\n \t\t\t      name, value) < 0);\n }\n \n@@ -1646,16 +1646,16 @@ membcmp (const char *name, ctf_id_t type _libctf_unused_, unsigned long offset,\n   if (name[0] == 0)\n     return 0;\n \n-  if (ctf_member_info (ctb->ctb_file, ctb->ctb_type, name, &ctm) < 0)\n+  if (ctf_member_info (ctb->ctb_dict, ctb->ctb_type, name, &ctm) < 0)\n     {\n-      ctf_err_warn (ctb->ctb_file, 0, 0,\n+      ctf_err_warn (ctb->ctb_dict, 0, 0,\n \t\t    _(\"conflict due to struct member %s iteration error\"),\n \t\t    name);\n       return 1;\n     }\n   if (ctm.ctm_offset != offset)\n     {\n-      ctf_err_warn (ctb->ctb_file, 1, ECTF_CONFLICT,\n+      ctf_err_warn (ctb->ctb_dict, 1, ECTF_CONFLICT,\n \t\t    _(\"conflict due to struct member %s offset change: \"\n \t\t      \"%lx versus %lx\"),\n \t\t    name, ctm.ctm_offset, offset);\n@@ -1672,12 +1672,12 @@ membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n   char *s = NULL;\n \n   if ((dmd = malloc (sizeof (ctf_dmdef_t))) == NULL)\n-    return (ctf_set_errno (ctb->ctb_file, EAGAIN));\n+    return (ctf_set_errno (ctb->ctb_dict, EAGAIN));\n \n   if (name != NULL && (s = strdup (name)) == NULL)\n     {\n       free (dmd);\n-      return (ctf_set_errno (ctb->ctb_file, EAGAIN));\n+      return (ctf_set_errno (ctb->ctb_dict, EAGAIN));\n     }\n \n   /* For now, dmd_type is copied as the src_fp's type; it is reset to an\n@@ -1689,22 +1689,22 @@ membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n \n   ctf_list_append (&ctb->ctb_dtd->dtd_u.dtu_members, dmd);\n \n-  ctb->ctb_file->ctf_flags |= LCTF_DIRTY;\n+  ctb->ctb_dict->ctf_flags |= LCTF_DIRTY;\n   return 0;\n }\n \n-/* The ctf_add_type routine is used to copy a type from a source CTF container\n-   to a dynamic destination container.  This routine operates recursively by\n+/* The ctf_add_type routine is used to copy a type from a source CTF dictionary\n+   to a dynamic destination dictionary.  This routine operates recursively by\n    following the source type's links and embedded member types.  If the\n-   destination container already contains a named type which has the same\n-   attributes, then we succeed and return this type but no changes occur.  */\n+   destination dict already contains a named type which has the same attributes,\n+   then we succeed and return this type but no changes occur.  */\n static ctf_id_t\n-ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type,\n-\t\t       ctf_file_t *proc_tracking_fp)\n+ctf_add_type_internal (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type,\n+\t\t       ctf_dict_t *proc_tracking_fp)\n {\n   ctf_id_t dst_type = CTF_ERR;\n   uint32_t dst_kind = CTF_K_UNKNOWN;\n-  ctf_file_t *tmp_fp = dst_fp;\n+  ctf_dict_t *tmp_fp = dst_fp;\n   ctf_id_t tmp;\n \n   const char *name;\n@@ -1747,9 +1747,9 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t\t\t      (void *) (uintptr_t) src_type))\n \treturn tmp;\n \n-      /* If this type has already been added from this container, and is the same\n-\t kind and (if a struct or union) has the same number of members, hand it\n-\t straight back.  */\n+      /* If this type has already been added from this dictionary, and is the\n+\t same kind and (if a struct or union) has the same number of members,\n+\t hand it straight back.  */\n \n       if (ctf_type_kind_unsliced (tmp_fp, tmp) == (int) kind)\n \t{\n@@ -1769,9 +1769,9 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n   if (kind == CTF_K_FORWARD)\n     forward_kind = src_tp->ctt_type;\n \n-  /* If the source type has a name and is a root type (visible at the\n-     top-level scope), lookup the name in the destination container and\n-     verify that it is of the same kind before we do anything else.  */\n+  /* If the source type has a name and is a root type (visible at the top-level\n+     scope), lookup the name in the destination dictionary and verify that it is\n+     of the same kind before we do anything else.  */\n \n   if ((flag & CTF_ADD_ROOT) && name[0] != '\\0'\n       && (tmp = ctf_lookup_by_rawname (dst_fp, forward_kind, name)) != 0)\n@@ -1803,7 +1803,7 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t      && kind != CTF_K_UNION))\n \t{\n \t  ctf_err_warn (dst_fp, 1, ECTF_CONFLICT,\n-\t\t\t_(\"ctf_add_file(): conflict for type %s: \"\n+\t\t\t_(\"ctf_add_type: conflict for type %s: \"\n \t\t\t  \"kinds differ, new: %i; old (ID %lx): %i\"),\n \t\t\tname, kind, dst_type, dst_kind);\n \t  return (ctf_set_errno (dst_fp, ECTF_CONFLICT));\n@@ -1821,7 +1821,7 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \n       if (dst_type != CTF_ERR)\n \t{\n-\t  ctf_file_t *fp = dst_fp;\n+\t  ctf_dict_t *fp = dst_fp;\n \n \t  if ((dst_tp = ctf_lookup_by_id (&fp, dst_type)) == NULL)\n \t    return CTF_ERR;\n@@ -1867,11 +1867,11 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \t}\n     }\n \n-  src.ctb_file = src_fp;\n+  src.ctb_dict = src_fp;\n   src.ctb_type = src_type;\n   src.ctb_dtd = NULL;\n \n-  dst.ctb_file = dst_fp;\n+  dst.ctb_dict = dst_fp;\n   dst.ctb_type = dst_type;\n   dst.ctb_dtd = NULL;\n \n@@ -2061,7 +2061,7 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n \tfor (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n \t     dmd != NULL; dmd = ctf_list_next (dmd))\n \t  {\n-\t    ctf_file_t *dst = dst_fp;\n+\t    ctf_dict_t *dst = dst_fp;\n \t    ctf_id_t memb_type;\n \n \t    memb_type = ctf_type_mapping (src_fp, dmd->dmd_type, &dst);\n@@ -2142,7 +2142,7 @@ ctf_add_type_internal (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type\n }\n \n ctf_id_t\n-ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n+ctf_add_type (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type)\n {\n   ctf_id_t id;\n \n@@ -2164,7 +2164,7 @@ ctf_add_type (ctf_file_t *dst_fp, ctf_file_t *src_fp, ctf_id_t src_type)\n \n /* Write the compressed CTF data stream to the specified gzFile descriptor.  */\n int\n-ctf_gzwrite (ctf_file_t *fp, gzFile fd)\n+ctf_gzwrite (ctf_dict_t *fp, gzFile fd)\n {\n   const unsigned char *buf;\n   ssize_t resid;\n@@ -2196,7 +2196,7 @@ ctf_gzwrite (ctf_file_t *fp, gzFile fd)\n /* Compress the specified CTF data stream and write it to the specified file\n    descriptor.  */\n int\n-ctf_compress_write (ctf_file_t *fp, int fd)\n+ctf_compress_write (ctf_dict_t *fp, int fd)\n {\n   unsigned char *buf;\n   unsigned char *bp;\n@@ -2263,7 +2263,7 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n /* Optionally compress the specified CTF data stream and return it as a new\n    dynamically-allocated string.  */\n unsigned char *\n-ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n+ctf_write_mem (ctf_dict_t *fp, size_t *size, size_t threshold)\n {\n   unsigned char *buf;\n   unsigned char *bp;\n@@ -2316,7 +2316,7 @@ ctf_write_mem (ctf_file_t *fp, size_t *size, size_t threshold)\n \n /* Write the uncompressed CTF data stream to the specified file descriptor.  */\n int\n-ctf_write (ctf_file_t *fp, int fd)\n+ctf_write (ctf_dict_t *fp, int fd)\n {\n   const unsigned char *buf;\n   ssize_t resid;"
    },
    {
      "sha": "fbb4e6c2c1a6573100532f7dbc397e76e8d9200a",
      "filename": "libctf/ctf-decl.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-decl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-decl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-decl.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -72,7 +72,7 @@ ctf_decl_fini (ctf_decl_t *cd)\n }\n \n void\n-ctf_decl_push (ctf_decl_t *cd, ctf_file_t *fp, ctf_id_t type)\n+ctf_decl_push (ctf_decl_t *cd, ctf_dict_t *fp, ctf_id_t type)\n {\n   ctf_decl_node_t *cdp;\n   ctf_decl_prec_t prec;"
    },
    {
      "sha": "3e95af09cacd81b97d8dd73d6f8c78581853e758",
      "filename": "libctf/ctf-dedup.c",
      "status": "modified",
      "additions": 87,
      "deletions": 87,
      "changes": 174,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-dedup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-dedup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dedup.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -55,7 +55,7 @@\n    *global type ID* or 'GID', a pair of an array offset and a ctf_id_t.  Since\n    both are already 32 bits or less or can easily be constrained to that range,\n    we can pack them both into a single 64-bit hash word for easy lookups, which\n-   would be much more annoying to do with a ctf_file_t * and a ctf_id_t.  (On\n+   would be much more annoying to do with a ctf_dict_t * and a ctf_id_t.  (On\n    32-bit platforms, we must do that anyway, since pointers, and thus hash keys\n    and values, are only 32 bits wide).  We track which inputs are parents of\n    which other inputs so that we can correctly recognize that types we have\n@@ -294,23 +294,23 @@\n     approach, but with a smaller key, this is all we can do.  */\n \n static void *\n-id_to_packed_id (ctf_file_t *fp, int input_num, ctf_id_t type)\n+id_to_packed_id (ctf_dict_t *fp, int input_num, ctf_id_t type)\n {\n   const void *lookup;\n   ctf_type_id_key_t *dynkey = NULL;\n   ctf_type_id_key_t key = { input_num, type };\n \n-  if (!ctf_dynhash_lookup_kv (fp->ctf_dedup.cd_id_to_file_t,\n+  if (!ctf_dynhash_lookup_kv (fp->ctf_dedup.cd_id_to_dict_t,\n \t\t\t      &key, &lookup, NULL))\n     {\n       if ((dynkey = malloc (sizeof (ctf_type_id_key_t))) == NULL)\n \tgoto oom;\n       memcpy (dynkey, &key, sizeof (ctf_type_id_key_t));\n \n-      if (ctf_dynhash_insert (fp->ctf_dedup.cd_id_to_file_t, dynkey, NULL) < 0)\n+      if (ctf_dynhash_insert (fp->ctf_dedup.cd_id_to_dict_t, dynkey, NULL) < 0)\n \tgoto oom;\n \n-      ctf_dynhash_lookup_kv (fp->ctf_dedup.cd_id_to_file_t,\n+      ctf_dynhash_lookup_kv (fp->ctf_dedup.cd_id_to_dict_t,\n \t\t\t     dynkey, &lookup, NULL);\n     }\n   /* We use a raw assert() here because there isn't really a way to get any sort\n@@ -368,7 +368,7 @@ make_set_element (ctf_dynhash_t *set, const void *key)\n \n /* Initialize the dedup atoms table.  */\n int\n-ctf_dedup_atoms_init (ctf_file_t *fp)\n+ctf_dedup_atoms_init (ctf_dict_t *fp)\n {\n   if (fp->ctf_dedup_atoms)\n     return 0;\n@@ -387,7 +387,7 @@ ctf_dedup_atoms_init (ctf_file_t *fp)\n /* Intern things in the dedup atoms table.  */\n \n static const char *\n-intern (ctf_file_t *fp, char *atom)\n+intern (ctf_dict_t *fp, char *atom)\n {\n   const void *foo;\n \n@@ -414,7 +414,7 @@ intern (ctf_file_t *fp, char *atom)\n    while allowing for the four C namespaces (normal, struct, union, enum).\n    Return a new dynamically-allocated string.  */\n static const char *\n-ctf_decorate_type_name (ctf_file_t *fp, const char *name, int kind)\n+ctf_decorate_type_name (ctf_dict_t *fp, const char *name, int kind)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   const char *ret;\n@@ -484,13 +484,13 @@ ctf_dedup_sha1_add (ctf_sha1_t *sha1, const void *buf, size_t len,\n }\n \n static const char *\n-ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n-\t\t     ctf_file_t **inputs, uint32_t *parents,\n+ctf_dedup_hash_type (ctf_dict_t *fp, ctf_dict_t *input,\n+\t\t     ctf_dict_t **inputs, uint32_t *parents,\n \t\t     int input_num, ctf_id_t type, int flags,\n \t\t     unsigned long depth,\n-\t\t     int (*populate_fun) (ctf_file_t *fp,\n-\t\t\t\t\t  ctf_file_t *input,\n-\t\t\t\t\t  ctf_file_t **inputs,\n+\t\t     int (*populate_fun) (ctf_dict_t *fp,\n+\t\t\t\t\t  ctf_dict_t *input,\n+\t\t\t\t\t  ctf_dict_t **inputs,\n \t\t\t\t\t  int input_num,\n \t\t\t\t\t  ctf_id_t type,\n \t\t\t\t\t  void *id,\n@@ -519,7 +519,7 @@ ctf_dedup_is_stub (const char *name, int kind, int fwdkind, int flags)\n    Only called for forwards or forwardable types with names, when the link mode\n    is CTF_LINK_SHARE_DUPLICATED.  */\n static int\n-ctf_dedup_record_origin (ctf_file_t *fp, int input_num, const char *decorated,\n+ctf_dedup_record_origin (ctf_dict_t *fp, int input_num, const char *decorated,\n \t\t\t void *id)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n@@ -551,14 +551,14 @@ ctf_dedup_record_origin (ctf_file_t *fp, int input_num, const char *decorated,\n    calls, recursively).  */\n \n static const char *\n-ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n+ctf_dedup_rhash_type (ctf_dict_t *fp, ctf_dict_t *input, ctf_dict_t **inputs,\n \t\t      uint32_t *parents, int input_num, ctf_id_t type,\n \t\t      void *type_id, const ctf_type_t *tp, const char *name,\n \t\t      const char *decorated, int kind, int flags,\n \t\t      unsigned long depth,\n-\t\t      int (*populate_fun) (ctf_file_t *fp,\n-\t\t\t\t\t   ctf_file_t *input,\n-\t\t\t\t\t   ctf_file_t **inputs,\n+\t\t      int (*populate_fun) (ctf_dict_t *fp,\n+\t\t\t\t\t   ctf_dict_t *input,\n+\t\t\t\t\t   ctf_dict_t **inputs,\n \t\t\t\t\t   int input_num,\n \t\t\t\t\t   ctf_id_t type,\n \t\t\t\t\t   void *id,\n@@ -990,13 +990,13 @@ ctf_dedup_rhash_type (ctf_file_t *fp, ctf_file_t *input, ctf_file_t **inputs,\n    Returns a hash value (an atom), or NULL on error.  */\n \n static const char *\n-ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n-\t\t     ctf_file_t **inputs, uint32_t *parents,\n+ctf_dedup_hash_type (ctf_dict_t *fp, ctf_dict_t *input,\n+\t\t     ctf_dict_t **inputs, uint32_t *parents,\n \t\t     int input_num, ctf_id_t type, int flags,\n \t\t     unsigned long depth,\n-\t\t     int (*populate_fun) (ctf_file_t *fp,\n-\t\t\t\t\t  ctf_file_t *input,\n-\t\t\t\t\t  ctf_file_t **inputs,\n+\t\t     int (*populate_fun) (ctf_dict_t *fp,\n+\t\t\t\t\t  ctf_dict_t *input,\n+\t\t\t\t\t  ctf_dict_t **inputs,\n \t\t\t\t\t  int input_num,\n \t\t\t\t\t  ctf_id_t type,\n \t\t\t\t\t  void *id,\n@@ -1139,8 +1139,8 @@ ctf_dedup_hash_type (ctf_file_t *fp, ctf_file_t *input,\n    cd_output_first_tu mapping.  */\n \n static int\n-ctf_dedup_populate_mappings (ctf_file_t *fp, ctf_file_t *input _libctf_unused_,\n-\t\t\t     ctf_file_t **inputs _libctf_unused_,\n+ctf_dedup_populate_mappings (ctf_dict_t *fp, ctf_dict_t *input _libctf_unused_,\n+\t\t\t     ctf_dict_t **inputs _libctf_unused_,\n \t\t\t     int input_num _libctf_unused_,\n \t\t\t     ctf_id_t type _libctf_unused_, void *id,\n \t\t\t     const char *decorated_name,\n@@ -1212,7 +1212,7 @@ ctf_dedup_populate_mappings (ctf_file_t *fp, ctf_file_t *input _libctf_unused_,\n \n       while ((err = ctf_dynset_cnext (type_ids, &i, &one_id)) == 0)\n \t{\n-\t  ctf_file_t *foo = inputs[CTF_DEDUP_GID_TO_INPUT (one_id)];\n+\t  ctf_dict_t *foo = inputs[CTF_DEDUP_GID_TO_INPUT (one_id)];\n \t  ctf_id_t bar = CTF_DEDUP_GID_TO_TYPE (one_id);\n \t  if (ctf_type_kind_unsliced (foo, bar) != orig_kind)\n \t    {\n@@ -1285,7 +1285,7 @@ ctf_dedup_populate_mappings (ctf_file_t *fp, ctf_file_t *input _libctf_unused_,\n    ctf_dedup_maybe_synthesize_forward.)  */\n \n static int\n-ctf_dedup_mark_conflicting_hash (ctf_file_t *fp, const char *hval)\n+ctf_dedup_mark_conflicting_hash (ctf_dict_t *fp, const char *hval)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   ctf_next_t *i = NULL;\n@@ -1331,7 +1331,7 @@ ctf_dedup_mark_conflicting_hash (ctf_file_t *fp, const char *hval)\n \n /* Look up a type kind from the output mapping, given a type hash value.  */\n static int\n-ctf_dedup_hash_kind (ctf_file_t *fp, ctf_file_t **inputs, const char *hash)\n+ctf_dedup_hash_kind (ctf_dict_t *fp, ctf_dict_t **inputs, const char *hash)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   void *id;\n@@ -1363,8 +1363,8 @@ ctf_dedup_hash_kind (ctf_file_t *fp, ctf_file_t **inputs, const char *hash)\n /* Used to keep a count of types: i.e. distinct type hash values.  */\n typedef struct ctf_dedup_type_counter\n {\n-  ctf_file_t *fp;\n-  ctf_file_t **inputs;\n+  ctf_dict_t *fp;\n+  ctf_dict_t **inputs;\n   int num_non_forwards;\n } ctf_dedup_type_counter_t;\n \n@@ -1401,7 +1401,7 @@ ctf_dedup_count_types (void *key_, void *value _libctf_unused_, void *arg_)\n /* Detect name ambiguity and mark ambiguous names as conflicting, other than the\n    most common.  */\n static int\n-ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n+ctf_dedup_detect_name_ambiguity (ctf_dict_t *fp, ctf_dict_t **inputs)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   ctf_next_t *i = NULL;\n@@ -1560,7 +1560,7 @@ ctf_dedup_detect_name_ambiguity (ctf_file_t *fp, ctf_file_t **inputs)\n /* Initialize the deduplication machinery.  */\n \n static int\n-ctf_dedup_init (ctf_file_t *fp)\n+ctf_dedup_init (ctf_dict_t *fp)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   size_t i;\n@@ -1569,7 +1569,7 @@ ctf_dedup_init (ctf_file_t *fp)\n       goto oom;\n \n #if IDS_NEED_ALLOCATION\n-  if ((d->cd_id_to_file_t = ctf_dynhash_create (ctf_hash_type_id_key,\n+  if ((d->cd_id_to_dict_t = ctf_dynhash_create (ctf_hash_type_id_key,\n \t\t\t\t\t\tctf_hash_eq_type_id_key,\n \t\t\t\t\t\tfree, NULL)) == NULL)\n     goto oom;\n@@ -1646,14 +1646,14 @@ ctf_dedup_init (ctf_file_t *fp)\n }\n \n void\n-ctf_dedup_fini (ctf_file_t *fp, ctf_file_t **outputs, uint32_t noutputs)\n+ctf_dedup_fini (ctf_dict_t *fp, ctf_dict_t **outputs, uint32_t noutputs)\n {\n   ctf_dedup_t *d = &fp->ctf_dedup;\n   size_t i;\n \n   /* ctf_dedup_atoms is kept across links.  */\n #if IDS_NEED_ALLOCATION\n-  ctf_dynhash_destroy (d->cd_id_to_file_t);\n+  ctf_dynhash_destroy (d->cd_id_to_dict_t);\n #endif\n   for (i = 0; i < 4; i++)\n     ctf_dynhash_destroy (d->cd_decorated_names[i]);\n@@ -1677,7 +1677,7 @@ ctf_dedup_fini (ctf_file_t *fp, ctf_file_t **outputs, uint32_t noutputs)\n \t  ctf_dedup_t *od = &outputs[i]->ctf_dedup;\n \t  ctf_dynhash_destroy (od->cd_output_emission_hashes);\n \t  ctf_dynhash_destroy (od->cd_output_emission_conflicted_forwards);\n-\t  ctf_file_close (od->cd_output);\n+\t  ctf_dict_close (od->cd_output);\n \t}\n     }\n   memset (d, 0, sizeof (ctf_dedup_t));\n@@ -1686,16 +1686,16 @@ ctf_dedup_fini (ctf_file_t *fp, ctf_file_t **outputs, uint32_t noutputs)\n /* Return 1 if this type is cited by multiple input dictionaries.  */\n \n static int\n-ctf_dedup_multiple_input_dicts (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_multiple_input_dicts (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t\tconst char *hval)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n   ctf_dynset_t *type_ids;\n   ctf_next_t *i = NULL;\n   void *id;\n-  ctf_file_t *found = NULL, *relative_found = NULL;\n+  ctf_dict_t *found = NULL, *relative_found = NULL;\n   const char *type_id;\n-  ctf_file_t *input_fp;\n+  ctf_dict_t *input_fp;\n   ctf_id_t input_id;\n   const char *name;\n   const char *decorated;\n@@ -1714,7 +1714,7 @@ ctf_dedup_multiple_input_dicts (ctf_file_t *output, ctf_file_t **inputs,\n \n   while ((err = ctf_dynset_next (type_ids, &i, &id)) == 0)\n     {\n-      ctf_file_t *fp = inputs[CTF_DEDUP_GID_TO_INPUT (id)];\n+      ctf_dict_t *fp = inputs[CTF_DEDUP_GID_TO_INPUT (id)];\n \n       if (fp == found || fp == relative_found)\n \tcontinue;\n@@ -1781,7 +1781,7 @@ ctf_dedup_multiple_input_dicts (ctf_file_t *output, ctf_file_t **inputs,\n    types.  Only used if the link mode is CTF_LINK_SHARE_DUPLICATED.  */\n \n static int\n-ctf_dedup_conflictify_unshared (ctf_file_t *output, ctf_file_t **inputs)\n+ctf_dedup_conflictify_unshared (ctf_dict_t *output, ctf_dict_t **inputs)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n   ctf_next_t *i = NULL;\n@@ -1853,7 +1853,7 @@ ctf_dedup_conflictify_unshared (ctf_file_t *output, ctf_file_t **inputs)\n    ctf_dedup_emit afterwards to do that.  */\n \n int\n-ctf_dedup (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n+ctf_dedup (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n \t   uint32_t *parents, int cu_mapped)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n@@ -1924,17 +1924,17 @@ ctf_dedup (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n }\n \n static int\n-ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_rwalk_output_mapping (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t\tuint32_t ninputs, uint32_t *parents,\n \t\t\t\tctf_dynset_t *already_visited,\n \t\t\t\tconst char *hval,\n \t\t\t\tint (*visit_fun) (const char *hval,\n-\t\t\t\t\t\t  ctf_file_t *output,\n-\t\t\t\t\t\t  ctf_file_t **inputs,\n+\t\t\t\t\t\t  ctf_dict_t *output,\n+\t\t\t\t\t\t  ctf_dict_t **inputs,\n \t\t\t\t\t\t  uint32_t ninputs,\n \t\t\t\t\t\t  uint32_t *parents,\n \t\t\t\t\t\t  int already_visited,\n-\t\t\t\t\t\t  ctf_file_t *input,\n+\t\t\t\t\t\t  ctf_dict_t *input,\n \t\t\t\t\t\t  ctf_id_t type,\n \t\t\t\t\t\t  void *id,\n \t\t\t\t\t\t  int depth,\n@@ -1944,27 +1944,27 @@ ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n /* Like ctf_dedup_rwalk_output_mapping (which see), only takes a single target\n    type and visits it.  */\n static int\n-ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n-\t\t\t\t    ctf_file_t **inputs, uint32_t ninputs,\n+ctf_dedup_rwalk_one_output_mapping (ctf_dict_t *output,\n+\t\t\t\t    ctf_dict_t **inputs, uint32_t ninputs,\n \t\t\t\t    uint32_t *parents,\n \t\t\t\t    ctf_dynset_t *already_visited,\n \t\t\t\t    int visited, void *type_id,\n \t\t\t\t    const char *hval,\n \t\t\t\t    int (*visit_fun) (const char *hval,\n-\t\t\t\t\t\t      ctf_file_t *output,\n-\t\t\t\t\t\t      ctf_file_t **inputs,\n+\t\t\t\t\t\t      ctf_dict_t *output,\n+\t\t\t\t\t\t      ctf_dict_t **inputs,\n \t\t\t\t\t\t      uint32_t ninputs,\n \t\t\t\t\t\t      uint32_t *parents,\n \t\t\t\t\t\t      int already_visited,\n-\t\t\t\t\t\t      ctf_file_t *input,\n+\t\t\t\t\t\t      ctf_dict_t *input,\n \t\t\t\t\t\t      ctf_id_t type,\n \t\t\t\t\t\t      void *id,\n \t\t\t\t\t\t      int depth,\n \t\t\t\t\t\t      void *arg),\n \t\t\t\t    void *arg, unsigned long depth)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n   int input_num;\n   ctf_id_t type;\n   int ret;\n@@ -2128,17 +2128,17 @@ ctf_dedup_rwalk_one_output_mapping (ctf_file_t *output,\n    once, but are not recursed through repeatedly: ALREADY_VISITED tracks whether\n    types have already been visited.  */\n static int\n-ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_rwalk_output_mapping (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t\tuint32_t ninputs, uint32_t *parents,\n \t\t\t\tctf_dynset_t *already_visited,\n \t\t\t\tconst char *hval,\n \t\t\t\tint (*visit_fun) (const char *hval,\n-\t\t\t\t\t\t  ctf_file_t *output,\n-\t\t\t\t\t\t  ctf_file_t **inputs,\n+\t\t\t\t\t\t  ctf_dict_t *output,\n+\t\t\t\t\t\t  ctf_dict_t **inputs,\n \t\t\t\t\t\t  uint32_t ninputs,\n \t\t\t\t\t\t  uint32_t *parents,\n \t\t\t\t\t\t  int already_visited,\n-\t\t\t\t\t\t  ctf_file_t *input,\n+\t\t\t\t\t\t  ctf_dict_t *input,\n \t\t\t\t\t\t  ctf_id_t type,\n \t\t\t\t\t\t  void *id,\n \t\t\t\t\t\t  int depth,\n@@ -2222,7 +2222,7 @@ ctf_dedup_rwalk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n \n typedef struct ctf_sort_om_cb_arg\n {\n-  ctf_file_t **inputs;\n+  ctf_dict_t **inputs;\n   uint32_t ninputs;\n   ctf_dedup_t *d;\n } ctf_sort_om_cb_arg_t;\n@@ -2241,8 +2241,8 @@ sort_output_mapping (const ctf_next_hkv_t *one, const ctf_next_hkv_t *two,\n   void *one_gid, *two_gid;\n   uint32_t one_ninput;\n   uint32_t two_ninput;\n-  ctf_file_t *one_fp;\n-  ctf_file_t *two_fp;\n+  ctf_dict_t *one_fp;\n+  ctf_dict_t *two_fp;\n   ctf_id_t one_type;\n   ctf_id_t two_type;\n \n@@ -2288,15 +2288,15 @@ sort_output_mapping (const ctf_next_hkv_t *one, const ctf_next_hkv_t *two,\n \n /* The public entry point to ctf_dedup_rwalk_output_mapping, above.  */\n static int\n-ctf_dedup_walk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_walk_output_mapping (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t       uint32_t ninputs, uint32_t *parents,\n \t\t\t       int (*visit_fun) (const char *hval,\n-\t\t\t\t\t\t ctf_file_t *output,\n-\t\t\t\t\t\t ctf_file_t **inputs,\n+\t\t\t\t\t\t ctf_dict_t *output,\n+\t\t\t\t\t\t ctf_dict_t **inputs,\n \t\t\t\t\t\t uint32_t ninputs,\n \t\t\t\t\t\t uint32_t *parents,\n \t\t\t\t\t\t int already_visited,\n-\t\t\t\t\t\t ctf_file_t *input,\n+\t\t\t\t\t\t ctf_dict_t *input,\n \t\t\t\t\t\t ctf_id_t type,\n \t\t\t\t\t\t void *id,\n \t\t\t\t\t\t int depth,\n@@ -2351,8 +2351,8 @@ ctf_dedup_walk_output_mapping (ctf_file_t *output, ctf_file_t **inputs,\n    conflicted per-TU type ID in INPUT with hash HVAL.  Return its CTF ID, or 0\n    if none was needed.  */\n static ctf_id_t\n-ctf_dedup_maybe_synthesize_forward (ctf_file_t *output, ctf_file_t *target,\n-\t\t\t\t    ctf_file_t *input, ctf_id_t id,\n+ctf_dedup_maybe_synthesize_forward (ctf_dict_t *output, ctf_dict_t *target,\n+\t\t\t\t    ctf_dict_t *input, ctf_id_t id,\n \t\t\t\t    const char *hval)\n {\n   ctf_dedup_t *od = &output->ctf_dedup;\n@@ -2430,14 +2430,14 @@ ctf_dedup_maybe_synthesize_forward (ctf_file_t *output, ctf_file_t *target,\n    make usability a bit better.  */\n \n static ctf_id_t\n-ctf_dedup_id_to_target (ctf_file_t *output, ctf_file_t *target,\n-\t\t\tctf_file_t **inputs, uint32_t ninputs,\n-\t\t\tuint32_t *parents, ctf_file_t *input, int input_num,\n+ctf_dedup_id_to_target (ctf_dict_t *output, ctf_dict_t *target,\n+\t\t\tctf_dict_t **inputs, uint32_t ninputs,\n+\t\t\tuint32_t *parents, ctf_dict_t *input, int input_num,\n \t\t\tctf_id_t id)\n {\n   ctf_dedup_t *od = &output->ctf_dedup;\n   ctf_dedup_t *td = &target->ctf_dedup;\n-  ctf_file_t *err_fp = input;\n+  ctf_dict_t *err_fp = input;\n   const char *hval;\n   void *target_id;\n   ctf_id_t emitted_forward;\n@@ -2535,7 +2535,7 @@ ctf_dedup_id_to_target (ctf_file_t *output, ctf_file_t *target,\n    have already been emitted.  (This type itself may also have been emitted.)\n \n    If the ARG is 1, this is a CU-mapped deduplication round mapping many\n-   ctf_file_t's into precisely one: conflicting types should be marked\n+   ctf_dict_t's into precisely one: conflicting types should be marked\n    non-root-visible.  If the ARG is 0, conflicting types go into per-CU\n    dictionaries stored in the input's ctf_dedup.cd_output: otherwise, everything\n    is emitted directly into the output.  No struct/union members are emitted.\n@@ -2546,16 +2546,16 @@ ctf_dedup_id_to_target (ctf_file_t *output, ctf_file_t *target,\n    data object section, backtrace section etc).  */\n \n static int\n-ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_emit_type (const char *hval, ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t     uint32_t ninputs, uint32_t *parents, int already_visited,\n-\t\t     ctf_file_t *input, ctf_id_t type, void *id, int depth,\n+\t\t     ctf_dict_t *input, ctf_id_t type, void *id, int depth,\n \t\t     void *arg)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n   int kind = ctf_type_kind_unsliced (input, type);\n   const char *name;\n-  ctf_file_t *target = output;\n-  ctf_file_t *real_input;\n+  ctf_dict_t *target = output;\n+  ctf_dict_t *real_input;\n   const ctf_type_t *tp;\n   int input_num = CTF_DEDUP_GID_TO_INPUT (id);\n   int output_num = (uint32_t) -1;\t\t/* 'shared' */\n@@ -2896,22 +2896,22 @@ ctf_dedup_emit_type (const char *hval, ctf_file_t *output, ctf_file_t **inputs,\n    point.  */\n \n static int\n-ctf_dedup_emit_struct_members (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_emit_struct_members (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t       uint32_t ninputs, uint32_t *parents)\n {\n   ctf_dedup_t *d = &output->ctf_dedup;\n   ctf_next_t *i = NULL;\n   void *input_id, *target_id;\n   int err;\n-  ctf_file_t *err_fp, *input_fp;\n+  ctf_dict_t *err_fp, *input_fp;\n   int input_num;\n   ctf_id_t err_type;\n \n   while ((err = ctf_dynhash_next (d->cd_emission_struct_members, &i,\n \t\t\t\t  &input_id, &target_id)) == 0)\n     {\n       ctf_next_t *j = NULL;\n-      ctf_file_t *target;\n+      ctf_dict_t *target;\n       uint32_t target_num;\n       ctf_id_t input_type, target_type;\n       ssize_t offset;\n@@ -2992,11 +2992,11 @@ ctf_dedup_emit_struct_members (ctf_file_t *output, ctf_file_t **inputs,\n    dict containing a non-null cd_output resulting from a ctf_dedup_emit_type\n    walk).  */\n static int\n-ctf_dedup_populate_type_mapping (ctf_file_t *shared, ctf_file_t *fp,\n-\t\t\t\t ctf_file_t **inputs)\n+ctf_dedup_populate_type_mapping (ctf_dict_t *shared, ctf_dict_t *fp,\n+\t\t\t\t ctf_dict_t **inputs)\n {\n   ctf_dedup_t *d = &shared->ctf_dedup;\n-  ctf_file_t *output = fp->ctf_dedup.cd_output;\n+  ctf_dict_t *output = fp->ctf_dedup.cd_output;\n   const void *k, *v;\n   ctf_next_t *i = NULL;\n   int err;\n@@ -3029,7 +3029,7 @@ ctf_dedup_populate_type_mapping (ctf_file_t *shared, ctf_file_t *fp,\n \n       while ((err = ctf_dynset_cnext (type_ids, &j, &id)) == 0)\n \t{\n-\t  ctf_file_t *input = inputs[CTF_DEDUP_GID_TO_INPUT (id)];\n+\t  ctf_dict_t *input = inputs[CTF_DEDUP_GID_TO_INPUT (id)];\n \t  ctf_id_t id_in = CTF_DEDUP_GID_TO_TYPE (id);\n \n #ifdef ENABLE_LIBCTF_HASH_DEBUGGING\n@@ -3057,7 +3057,7 @@ ctf_dedup_populate_type_mapping (ctf_file_t *shared, ctf_file_t *fp,\n /* Populate the type mapping machinery used by the rest of the linker,\n    by ctf_add_type, etc.  */\n static int\n-ctf_dedup_populate_type_mappings (ctf_file_t *output, ctf_file_t **inputs,\n+ctf_dedup_populate_type_mappings (ctf_dict_t *output, ctf_dict_t **inputs,\n \t\t\t\t  uint32_t ninputs)\n {\n   size_t i;\n@@ -3094,13 +3094,13 @@ ctf_dedup_populate_type_mappings (ctf_file_t *output, ctf_file_t **inputs,\n    If CU_MAPPED is set, this is a first pass for a link with a non-empty CU\n    mapping: only one output will result.  */\n \n-ctf_file_t **\n-ctf_dedup_emit (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n+ctf_dict_t **\n+ctf_dedup_emit (ctf_dict_t *output, ctf_dict_t **inputs, uint32_t ninputs,\n \t\tuint32_t *parents, uint32_t *noutputs, int cu_mapped)\n {\n   size_t num_outputs = 1;\t\t/* Always at least one output: us.  */\n-  ctf_file_t **outputs;\n-  ctf_file_t **walk;\n+  ctf_dict_t **outputs;\n+  ctf_dict_t **walk;\n   size_t i;\n \n   ctf_dprintf (\"Triggering emission.\\n\");\n@@ -3124,7 +3124,7 @@ ctf_dedup_emit (ctf_file_t *output, ctf_file_t **inputs, uint32_t ninputs,\n   if (!ctf_assert (output, !cu_mapped || (cu_mapped && num_outputs == 1)))\n     return NULL;\n \n-  if ((outputs = calloc (num_outputs, sizeof (ctf_file_t *))) == NULL)\n+  if ((outputs = calloc (num_outputs, sizeof (ctf_dict_t *))) == NULL)\n     {\n       ctf_err_warn (output, 0, ENOMEM,\n \t\t    _(\"out of memory allocating link outputs array\"));"
    },
    {
      "sha": "ced69179a62f380c449b9da133d27fdfdd93ab6e",
      "filename": "libctf/ctf-dump.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-dump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-dump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-dump.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -36,7 +36,7 @@ typedef struct ctf_dump_item\n struct ctf_dump_state\n {\n   ctf_sect_names_t cds_sect;\n-  ctf_file_t *cds_fp;\n+  ctf_dict_t *cds_fp;\n   ctf_dump_item_t *cds_current;\n   ctf_list_t cds_items;\n };\n@@ -46,7 +46,7 @@ struct ctf_dump_state\n typedef struct ctf_dump_membstate\n {\n   char **cdm_str;\n-  ctf_file_t *cdm_fp;\n+  ctf_dict_t *cdm_fp;\n } ctf_dump_membstate_t;\n \n static int\n@@ -83,7 +83,7 @@ ctf_dump_free (ctf_dump_state_t *state)\n    type's references.  */\n \n static char *\n-ctf_dump_format_type (ctf_file_t *fp, ctf_id_t id, int flag)\n+ctf_dump_format_type (ctf_dict_t *fp, ctf_id_t id, int flag)\n {\n   ctf_id_t new_id;\n   char *str = NULL, *bit = NULL, *buf = NULL;\n@@ -183,7 +183,7 @@ ctf_dump_format_type (ctf_file_t *fp, ctf_id_t id, int flag)\n \n /* Dump one string field from the file header into the cds_items.  */\n static int\n-ctf_dump_header_strfield (ctf_file_t *fp, ctf_dump_state_t *state,\n+ctf_dump_header_strfield (ctf_dict_t *fp, ctf_dump_state_t *state,\n \t\t\t  const char *name, uint32_t value)\n {\n   char *str;\n@@ -201,7 +201,7 @@ ctf_dump_header_strfield (ctf_file_t *fp, ctf_dump_state_t *state,\n \n /* Dump one section-offset field from the file header into the cds_items.  */\n static int\n-ctf_dump_header_sectfield (ctf_file_t *fp, ctf_dump_state_t *state,\n+ctf_dump_header_sectfield (ctf_dict_t *fp, ctf_dump_state_t *state,\n \t\t\t   const char *sect, uint32_t off, uint32_t nextoff)\n {\n   char *str;\n@@ -221,7 +221,7 @@ ctf_dump_header_sectfield (ctf_file_t *fp, ctf_dump_state_t *state,\n \n /* Dump the file header into the cds_items.  */\n static int\n-ctf_dump_header (ctf_file_t *fp, ctf_dump_state_t *state)\n+ctf_dump_header (ctf_dict_t *fp, ctf_dump_state_t *state)\n {\n   char *str;\n   const ctf_header_t *hp = fp->ctf_header;\n@@ -252,7 +252,7 @@ ctf_dump_header (ctf_file_t *fp, ctf_dump_state_t *state)\n \n   /* Everything else is only printed if present.  */\n \n-  /* The flags are unusual in that they represent the ctf_file_t *in memory*:\n+  /* The flags are unusual in that they represent the ctf_dict_t *in memory*:\n      flags representing compression, etc, are turned off as the file is\n      decompressed.  So we store a copy of the flags before they are changed, for\n      the dumper.  */\n@@ -339,7 +339,7 @@ ctf_dump_label (const char *name, const ctf_lblinfo_t *info,\n    them, rather than only one.  */\n \n static int\n-ctf_dump_objts (ctf_file_t *fp, ctf_dump_state_t *state)\n+ctf_dump_objts (ctf_dict_t *fp, ctf_dump_state_t *state)\n {\n   size_t i;\n \n@@ -396,7 +396,7 @@ ctf_dump_objts (ctf_file_t *fp, ctf_dump_state_t *state)\n    iterator for this section.)  */\n \n static int\n-ctf_dump_funcs (ctf_file_t *fp, ctf_dump_state_t *state)\n+ctf_dump_funcs (ctf_dict_t *fp, ctf_dump_state_t *state)\n {\n   size_t i;\n \n@@ -627,7 +627,7 @@ ctf_dump_type (ctf_id_t id, int flag, void *arg)\n /* Dump the string table into the cds_items.  */\n \n static int\n-ctf_dump_str (ctf_file_t *fp, ctf_dump_state_t *state)\n+ctf_dump_str (ctf_dict_t *fp, ctf_dump_state_t *state)\n {\n   const char *s = fp->ctf_str[CTF_STRTAB_0].cts_strs;\n \n@@ -657,7 +657,7 @@ ctf_dump_str (ctf_file_t *fp, ctf_dump_state_t *state)\n    allocate a new one and return it if it likes).  */\n \n char *\n-ctf_dump (ctf_file_t *fp, ctf_dump_state_t **statep, ctf_sect_names_t sect,\n+ctf_dump (ctf_dict_t *fp, ctf_dump_state_t **statep, ctf_sect_names_t sect,\n \t  ctf_dump_decorate_f *func, void *arg)\n {\n   char *str;"
    },
    {
      "sha": "86003039272d7396909e57d117251c1ef13dac6f",
      "filename": "libctf/ctf-error.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-error.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-error.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-error.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -77,7 +77,7 @@ ctf_errmsg (int error)\n }\n \n int\n-ctf_errno (ctf_file_t * fp)\n+ctf_errno (ctf_dict_t * fp)\n {\n   return fp->ctf_errno;\n }"
    },
    {
      "sha": "582f9debbd10a71dcb02ef1a2fc62e549e466c7f",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -781,7 +781,7 @@ ctf_hash_size (const ctf_hash_t *hp)\n }\n \n int\n-ctf_hash_insert_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n+ctf_hash_insert_type (ctf_hash_t *hp, ctf_dict_t *fp, uint32_t type,\n \t\t      uint32_t name)\n {\n   const char *str = ctf_strraw (fp, name);\n@@ -811,7 +811,7 @@ ctf_hash_insert_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n    this new official definition. If the key is not present, then call\n    ctf_hash_insert_type and hash it in.  */\n int\n-ctf_hash_define_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n+ctf_hash_define_type (ctf_hash_t *hp, ctf_dict_t *fp, uint32_t type,\n                       uint32_t name)\n {\n   /* This matches the semantics of ctf_hash_insert_type in this\n@@ -821,7 +821,7 @@ ctf_hash_define_type (ctf_hash_t *hp, ctf_file_t *fp, uint32_t type,\n }\n \n ctf_id_t\n-ctf_hash_lookup_type (ctf_hash_t *hp, ctf_file_t *fp __attribute__ ((__unused__)),\n+ctf_hash_lookup_type (ctf_hash_t *hp, ctf_dict_t *fp __attribute__ ((__unused__)),\n \t\t      const char *key)\n {\n   ctf_helem_t **slot;"
    },
    {
      "sha": "3f4cfac71528a2bd44b7ee759f6fec800b432811",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 90,
      "deletions": 89,
      "changes": 179,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -123,15 +123,15 @@ typedef struct ctf_lookup\n   ctf_names_t *ctl_hash;\t/* Pointer to hash table for lookup.  */\n } ctf_lookup_t;\n \n-typedef struct ctf_fileops\n+typedef struct ctf_dictops\n {\n   uint32_t (*ctfo_get_kind) (uint32_t);\n   uint32_t (*ctfo_get_root) (uint32_t);\n   uint32_t (*ctfo_get_vlen) (uint32_t);\n-  ssize_t (*ctfo_get_ctt_size) (const ctf_file_t *, const ctf_type_t *,\n+  ssize_t (*ctfo_get_ctt_size) (const ctf_dict_t *, const ctf_type_t *,\n \t\t\t\tssize_t *, ssize_t *);\n-  ssize_t (*ctfo_get_vbytes) (ctf_file_t *, unsigned short, ssize_t, size_t);\n-} ctf_fileops_t;\n+  ssize_t (*ctfo_get_vbytes) (ctf_dict_t *, unsigned short, ssize_t, size_t);\n+} ctf_dictops_t;\n \n typedef struct ctf_list\n {\n@@ -237,11 +237,11 @@ typedef struct ctf_str_atom_ref\n \n typedef struct ctf_link_type_key\n {\n-  ctf_file_t *cltk_fp;\n+  ctf_dict_t *cltk_fp;\n   ctf_id_t cltk_idx;\n } ctf_link_type_key_t;\n \n-/* The structure used as the key in a cd_id_to_file_t on 32-bit platforms.  */\n+/* The structure used as the key in a cd_id_to_dict_t on 32-bit platforms.  */\n typedef struct ctf_type_id_key\n {\n   int ctii_input_num;\n@@ -253,7 +253,7 @@ typedef struct ctf_type_id_key\n    The dedup state below uses three terms consistently. A \"hash\" is a\n    ctf_dynhash_t; a \"hash value\" is the hash value of a type as returned by\n    ctf_dedup_hash_type; a \"global type ID\" or \"global ID\" is a packed-together\n-   reference to a single ctf_file_t (by array index in an array of inputs) and\n+   reference to a single ctf_dict_t (by array index in an array of inputs) and\n    ctf_id_t, i.e. a single instance of some hash value in some input.\n \n    The deduplication algorithm takes a bunch of inputs and yields a single\n@@ -272,10 +272,10 @@ typedef struct ctf_dedup\n \n   /* On 32-bit platforms only, a hash of global type IDs, in the form of\n      a ctf_link_type_id_key_t.  */\n-  ctf_dynhash_t *cd_id_to_file_t;\n+  ctf_dynhash_t *cd_id_to_dict_t;\n \n   /* Atoms tables of decorated names: maps undecorated name to decorated name.\n-     (The actual allocations are in the CTF file for the former and the real\n+     (The actual allocations are in the CTF dict for the former and the real\n      atoms table for the latter).  Uses the same namespaces as ctf_lookups,\n      below, but has no need for null-termination.  */\n   ctf_dynhash_t *cd_decorated_names[4];\n@@ -339,25 +339,26 @@ typedef struct ctf_dedup\n \n   /* Points to the output counterpart of this input dictionary, at emission\n      time.  */\n-  ctf_file_t *cd_output;\n+  ctf_dict_t *cd_output;\n } ctf_dedup_t;\n \n-/* The ctf_file is the structure used to represent a CTF container to library\n+/* The ctf_dict is the structure used to represent a CTF dictionary to library\n    clients, who see it only as an opaque pointer.  Modifications can therefore\n    be made freely to this structure without regard to client versioning.  The\n-   ctf_file_t typedef appears in <ctf-api.h> and declares a forward tag.\n+   ctf_dict_t typedef appears in <ctf-api.h> and declares a forward tag.\n+   (A ctf_file_t typedef also appears there, for historical reasons.)\n \n-   NOTE: ctf_update() requires that everything inside of ctf_file either be an\n-   immediate value, a pointer to dynamically allocated data *outside* of the\n-   ctf_file itself, or a pointer to statically allocated data.  If you add a\n-   pointer to ctf_file that points to something within the ctf_file itself,\n-   you must make corresponding changes to ctf_update().  */\n+   NOTE: ctf_serialize() requires that everything inside of ctf_dict either be\n+   an immediate value, a pointer to dynamically allocated data *outside* of the\n+   ctf_dict itself, or a pointer to statically allocated data.  If you add a\n+   pointer to ctf_dict that points to something within the ctf_dict itself, you\n+   must make corresponding changes to ctf_serialize().  */\n \n-struct ctf_file\n+struct ctf_dict\n {\n-  const ctf_fileops_t *ctf_fileops; /* Version-specific file operations.  */\n-  struct ctf_header *ctf_header;    /* The header from this CTF file.  */\n-  unsigned char ctf_openflags;\t    /* Flags the file had when opened.  */\n+  const ctf_dictops_t *ctf_dictops; /* Version-specific dict operations.  */\n+  struct ctf_header *ctf_header;    /* The header from this CTF dict.  */\n+  unsigned char ctf_openflags;\t    /* Flags the dict had when opened.  */\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n@@ -390,9 +391,9 @@ struct ctf_file\n   const ctf_dmodel_t *ctf_dmodel; /* Data model pointer (see above).  */\n   const char *ctf_cuname;\t  /* Compilation unit name (if any).  */\n   char *ctf_dyncuname;\t\t  /* Dynamically allocated name of CU.  */\n-  struct ctf_file *ctf_parent;\t  /* Parent CTF container (if any).  */\n+  struct ctf_dict *ctf_parent;\t  /* Parent CTF dict (if any).  */\n   int ctf_parent_unreffed;\t  /* Parent set by ctf_import_unref?  */\n-  const char *ctf_parlabel;\t  /* Label in parent container (if any).  */\n+  const char *ctf_parlabel;\t  /* Label in parent dict (if any).  */\n   const char *ctf_parname;\t  /* Basename of parent (if any).  */\n   char *ctf_dynparname;\t\t  /* Dynamically allocated name of parent.  */\n   uint32_t ctf_parmax;\t\t  /* Highest type ID of a parent type.  */\n@@ -407,7 +408,7 @@ struct ctf_file\n   unsigned long ctf_dtoldid;\t  /* Oldest id that has been committed.  */\n   unsigned long ctf_snapshots;\t  /* ctf_snapshot() plus ctf_update() count.  */\n   unsigned long ctf_snapshot_lu;  /* ctf_snapshot() call count at last update.  */\n-  ctf_archive_t *ctf_archive;\t  /* Archive this ctf_file_t came from.  */\n+  ctf_archive_t *ctf_archive;\t  /* Archive this ctf_dict_t came from.  */\n   ctf_list_t ctf_errs_warnings;\t  /* CTF errors and warnings.  */\n   ctf_dynhash_t *ctf_link_inputs; /* Inputs to this link.  */\n   ctf_dynhash_t *ctf_link_outputs; /* Additional outputs from this link.  */\n@@ -457,13 +458,13 @@ struct ctf_file\n   void *ctf_specific;\t\t  /* Data for ctf_get/setspecific().  */\n };\n \n-/* An abstraction over both a ctf_file_t and a ctf_archive_t.  */\n+/* An abstraction over both a ctf_dict_t and a ctf_archive_t.  */\n \n struct ctf_archive_internal\n {\n   int ctfi_is_archive;\n   int ctfi_unmap_on_close;\n-  ctf_file_t *ctfi_file;\n+  ctf_dict_t *ctfi_dict;\n   struct ctf_archive *ctfi_archive;\n   ctf_sect_t ctfi_symsect;\n   ctf_sect_t ctfi_strsect;\n@@ -490,7 +491,7 @@ struct ctf_next\n   ssize_t ctn_size;\n   ssize_t ctn_increment;\n   uint32_t ctn_n;\n-  /* We can save space on this side of things by noting that a container is\n+  /* We can save space on this side of things by noting that a dictionary is\n      either dynamic or not, as a whole, and a given iterator can only iterate\n      over one kind of thing at once: so we can overlap the DTD and non-DTD\n      members, and the structure, variable and enum members, etc.  */\n@@ -504,11 +505,11 @@ struct ctf_next\n     ctf_next_hkv_t *ctn_sorted_hkv;\n     void **ctn_hash_slot;\n   } u;\n-  /* This union is of various sorts of container we can iterate over:\n+  /* This union is of various sorts of dict we can iterate over:\n      currently dictionaries and archives, dynhashes, and dynsets.  */\n   union\n   {\n-    const ctf_file_t *ctn_fp;\n+    const ctf_dict_t *ctn_fp;\n     const ctf_archive_t *ctn_arc;\n     const ctf_dynhash_t *ctn_h;\n     const ctf_dynset_t *ctn_s;\n@@ -535,23 +536,23 @@ struct ctf_next\n \t\t       (fp, i, fp->ctf_flags & LCTF_CHILD))->dtd_data) : \\\n      (ctf_type_t *)((uintptr_t)(fp)->ctf_buf + (fp)->ctf_txlate[(i)]))\n \n-#define LCTF_INFO_KIND(fp, info)\t((fp)->ctf_fileops->ctfo_get_kind(info))\n-#define LCTF_INFO_ISROOT(fp, info)\t((fp)->ctf_fileops->ctfo_get_root(info))\n-#define LCTF_INFO_VLEN(fp, info)\t((fp)->ctf_fileops->ctfo_get_vlen(info))\n+#define LCTF_INFO_KIND(fp, info)\t((fp)->ctf_dictops->ctfo_get_kind(info))\n+#define LCTF_INFO_ISROOT(fp, info)\t((fp)->ctf_dictops->ctfo_get_root(info))\n+#define LCTF_INFO_VLEN(fp, info)\t((fp)->ctf_dictops->ctfo_get_vlen(info))\n #define LCTF_VBYTES(fp, kind, size, vlen) \\\n-  ((fp)->ctf_fileops->ctfo_get_vbytes(fp, kind, size, vlen))\n+  ((fp)->ctf_dictops->ctfo_get_vbytes(fp, kind, size, vlen))\n \n-#define LCTF_CHILD\t0x0001\t/* CTF container is a child */\n-#define LCTF_RDWR\t0x0002\t/* CTF container is writable */\n-#define LCTF_DIRTY\t0x0004\t/* CTF container has been modified */\n+#define LCTF_CHILD\t0x0001\t/* CTF dict is a child */\n+#define LCTF_RDWR\t0x0002\t/* CTF dict is writable */\n+#define LCTF_DIRTY\t0x0004\t/* CTF dict has been modified */\n \n-extern ctf_names_t *ctf_name_table (ctf_file_t *, int);\n-extern const ctf_type_t *ctf_lookup_by_id (ctf_file_t **, ctf_id_t);\n-extern ctf_id_t ctf_lookup_by_rawname (ctf_file_t *, int, const char *);\n-extern ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *, ctf_names_t *, const char *);\n-extern void ctf_set_ctl_hashes (ctf_file_t *);\n+extern ctf_names_t *ctf_name_table (ctf_dict_t *, int);\n+extern const ctf_type_t *ctf_lookup_by_id (ctf_dict_t **, ctf_id_t);\n+extern ctf_id_t ctf_lookup_by_rawname (ctf_dict_t *, int, const char *);\n+extern ctf_id_t ctf_lookup_by_rawhash (ctf_dict_t *, ctf_names_t *, const char *);\n+extern void ctf_set_ctl_hashes (ctf_dict_t *);\n \n-extern ctf_file_t *ctf_get_dict (ctf_file_t *fp, ctf_id_t type);\n+extern ctf_dict_t *ctf_get_dict (ctf_dict_t *fp, ctf_id_t type);\n \n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n extern unsigned int ctf_hash_integer (const void *ptr);\n@@ -576,9 +577,9 @@ typedef int (*ctf_hash_sort_f) (const ctf_next_hkv_t *, const ctf_next_hkv_t *,\n \t\t\t\tvoid *arg);\n \n extern ctf_hash_t *ctf_hash_create (unsigned long, ctf_hash_fun, ctf_hash_eq_fun);\n-extern int ctf_hash_insert_type (ctf_hash_t *, ctf_file_t *, uint32_t, uint32_t);\n-extern int ctf_hash_define_type (ctf_hash_t *, ctf_file_t *, uint32_t, uint32_t);\n-extern ctf_id_t ctf_hash_lookup_type (ctf_hash_t *, ctf_file_t *, const char *);\n+extern int ctf_hash_insert_type (ctf_hash_t *, ctf_dict_t *, uint32_t, uint32_t);\n+extern int ctf_hash_define_type (ctf_hash_t *, ctf_dict_t *, uint32_t, uint32_t);\n+extern ctf_id_t ctf_hash_lookup_type (ctf_hash_t *, ctf_dict_t *, const char *);\n extern uint32_t ctf_hash_size (const ctf_hash_t *);\n extern void ctf_hash_destroy (ctf_hash_t *);\n \n@@ -626,101 +627,101 @@ extern void ctf_list_delete (ctf_list_t *, void *);\n extern void ctf_list_splice (ctf_list_t *, ctf_list_t *);\n extern int ctf_list_empty_p (ctf_list_t *lp);\n \n-extern int ctf_dtd_insert (ctf_file_t *, ctf_dtdef_t *, int flag, int kind);\n-extern void ctf_dtd_delete (ctf_file_t *, ctf_dtdef_t *);\n-extern ctf_dtdef_t *ctf_dtd_lookup (const ctf_file_t *, ctf_id_t);\n-extern ctf_dtdef_t *ctf_dynamic_type (const ctf_file_t *, ctf_id_t);\n+extern int ctf_dtd_insert (ctf_dict_t *, ctf_dtdef_t *, int flag, int kind);\n+extern void ctf_dtd_delete (ctf_dict_t *, ctf_dtdef_t *);\n+extern ctf_dtdef_t *ctf_dtd_lookup (const ctf_dict_t *, ctf_id_t);\n+extern ctf_dtdef_t *ctf_dynamic_type (const ctf_dict_t *, ctf_id_t);\n \n-extern int ctf_dvd_insert (ctf_file_t *, ctf_dvdef_t *);\n-extern void ctf_dvd_delete (ctf_file_t *, ctf_dvdef_t *);\n-extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_file_t *, const char *);\n+extern int ctf_dvd_insert (ctf_dict_t *, ctf_dvdef_t *);\n+extern void ctf_dvd_delete (ctf_dict_t *, ctf_dvdef_t *);\n+extern ctf_dvdef_t *ctf_dvd_lookup (const ctf_dict_t *, const char *);\n \n-extern ctf_id_t ctf_add_encoded (ctf_file_t *, uint32_t, const char *,\n+extern ctf_id_t ctf_add_encoded (ctf_dict_t *, uint32_t, const char *,\n \t\t\t\t const ctf_encoding_t *, uint32_t kind);\n-extern ctf_id_t ctf_add_reftype (ctf_file_t *, uint32_t, ctf_id_t,\n+extern ctf_id_t ctf_add_reftype (ctf_dict_t *, uint32_t, ctf_id_t,\n \t\t\t\t uint32_t kind);\n \n-extern void ctf_add_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n-\t\t\t\t  ctf_file_t *dst_fp, ctf_id_t dst_type);\n-extern ctf_id_t ctf_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n-\t\t\t\t  ctf_file_t **dst_fp);\n+extern void ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n+\t\t\t\t  ctf_dict_t *dst_fp, ctf_id_t dst_type);\n+extern ctf_id_t ctf_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n+\t\t\t\t  ctf_dict_t **dst_fp);\n \n-extern int ctf_dedup_atoms_init (ctf_file_t *);\n-extern int ctf_dedup (ctf_file_t *, ctf_file_t **, uint32_t ninputs,\n+extern int ctf_dedup_atoms_init (ctf_dict_t *);\n+extern int ctf_dedup (ctf_dict_t *, ctf_dict_t **, uint32_t ninputs,\n \t\t      uint32_t *parents, int cu_mapped);\n-extern void ctf_dedup_fini (ctf_file_t *, ctf_file_t **, uint32_t);\n-extern ctf_file_t **ctf_dedup_emit (ctf_file_t *, ctf_file_t **,\n+extern void ctf_dedup_fini (ctf_dict_t *, ctf_dict_t **, uint32_t);\n+extern ctf_dict_t **ctf_dedup_emit (ctf_dict_t *, ctf_dict_t **,\n \t\t\t\t    uint32_t ninputs, uint32_t *parents,\n \t\t\t\t    uint32_t *noutputs, int cu_mapped);\n \n extern void ctf_decl_init (ctf_decl_t *);\n extern void ctf_decl_fini (ctf_decl_t *);\n-extern void ctf_decl_push (ctf_decl_t *, ctf_file_t *, ctf_id_t);\n+extern void ctf_decl_push (ctf_decl_t *, ctf_dict_t *, ctf_id_t);\n \n _libctf_printflike_ (2, 3)\n extern void ctf_decl_sprintf (ctf_decl_t *, const char *, ...);\n extern char *ctf_decl_buf (ctf_decl_t *cd);\n \n-extern const char *ctf_strptr (ctf_file_t *, uint32_t);\n-extern const char *ctf_strraw (ctf_file_t *, uint32_t);\n-extern const char *ctf_strraw_explicit (ctf_file_t *, uint32_t,\n+extern const char *ctf_strptr (ctf_dict_t *, uint32_t);\n+extern const char *ctf_strraw (ctf_dict_t *, uint32_t);\n+extern const char *ctf_strraw_explicit (ctf_dict_t *, uint32_t,\n \t\t\t\t\tctf_strs_t *);\n-extern int ctf_str_create_atoms (ctf_file_t *);\n-extern void ctf_str_free_atoms (ctf_file_t *);\n-extern uint32_t ctf_str_add (ctf_file_t *, const char *);\n-extern uint32_t ctf_str_add_ref (ctf_file_t *, const char *, uint32_t *ref);\n-extern int ctf_str_add_external (ctf_file_t *, const char *, uint32_t offset);\n-extern void ctf_str_remove_ref (ctf_file_t *, const char *, uint32_t *ref);\n-extern void ctf_str_rollback (ctf_file_t *, ctf_snapshot_id_t);\n-extern void ctf_str_purge_refs (ctf_file_t *);\n-extern ctf_strs_writable_t ctf_str_write_strtab (ctf_file_t *);\n+extern int ctf_str_create_atoms (ctf_dict_t *);\n+extern void ctf_str_free_atoms (ctf_dict_t *);\n+extern uint32_t ctf_str_add (ctf_dict_t *, const char *);\n+extern uint32_t ctf_str_add_ref (ctf_dict_t *, const char *, uint32_t *ref);\n+extern int ctf_str_add_external (ctf_dict_t *, const char *, uint32_t offset);\n+extern void ctf_str_remove_ref (ctf_dict_t *, const char *, uint32_t *ref);\n+extern void ctf_str_rollback (ctf_dict_t *, ctf_snapshot_id_t);\n+extern void ctf_str_purge_refs (ctf_dict_t *);\n+extern ctf_strs_writable_t ctf_str_write_strtab (ctf_dict_t *);\n \n extern struct ctf_archive_internal *\n ctf_new_archive_internal (int is_archive, int unmap_on_close,\n-\t\t\t  struct ctf_archive *, ctf_file_t *,\n+\t\t\t  struct ctf_archive *, ctf_dict_t *,\n \t\t\t  const ctf_sect_t *symsect,\n \t\t\t  const ctf_sect_t *strsect, int *errp);\n extern struct ctf_archive *ctf_arc_open_internal (const char *, int *);\n extern void ctf_arc_close_internal (struct ctf_archive *);\n extern void *ctf_set_open_errno (int *, int);\n-extern unsigned long ctf_set_errno (ctf_file_t *, int);\n+extern unsigned long ctf_set_errno (ctf_dict_t *, int);\n \n-extern ctf_file_t *ctf_simple_open_internal (const char *, size_t, const char *,\n+extern ctf_dict_t *ctf_simple_open_internal (const char *, size_t, const char *,\n \t\t\t\t\t     size_t, size_t,\n \t\t\t\t\t     const char *, size_t,\n \t\t\t\t\t     ctf_dynhash_t *, int, int *);\n-extern ctf_file_t *ctf_bufopen_internal (const ctf_sect_t *, const ctf_sect_t *,\n+extern ctf_dict_t *ctf_bufopen_internal (const ctf_sect_t *, const ctf_sect_t *,\n \t\t\t\t\t const ctf_sect_t *, ctf_dynhash_t *,\n \t\t\t\t\t int, int *);\n-extern int ctf_import_unref (ctf_file_t *fp, ctf_file_t *pfp);\n-extern int ctf_serialize (ctf_file_t *);\n+extern int ctf_import_unref (ctf_dict_t *fp, ctf_dict_t *pfp);\n+extern int ctf_serialize (ctf_dict_t *);\n \n _libctf_malloc_\n extern void *ctf_mmap (size_t length, size_t offset, int fd);\n extern void ctf_munmap (void *, size_t);\n extern ssize_t ctf_pread (int fd, void *buf, ssize_t count, off_t offset);\n \n-extern void *ctf_realloc (ctf_file_t *, void *, size_t);\n+extern void *ctf_realloc (ctf_dict_t *, void *, size_t);\n extern char *ctf_str_append (char *, const char *);\n extern char *ctf_str_append_noerr (char *, const char *);\n \n-extern ctf_id_t ctf_type_resolve_unsliced (ctf_file_t *, ctf_id_t);\n-extern int ctf_type_kind_unsliced (ctf_file_t *, ctf_id_t);\n+extern ctf_id_t ctf_type_resolve_unsliced (ctf_dict_t *, ctf_id_t);\n+extern int ctf_type_kind_unsliced (ctf_dict_t *, ctf_id_t);\n \n _libctf_printflike_ (1, 2)\n extern void ctf_dprintf (const char *, ...);\n extern void libctf_init_debug (void);\n \n _libctf_printflike_ (4, 5)\n-extern void ctf_err_warn (ctf_file_t *, int is_warning, int err,\n+extern void ctf_err_warn (ctf_dict_t *, int is_warning, int err,\n \t\t\t  const char *, ...);\n-extern void ctf_err_warn_to_open (ctf_file_t *);\n-extern void ctf_assert_fail_internal (ctf_file_t *, const char *,\n+extern void ctf_err_warn_to_open (ctf_dict_t *);\n+extern void ctf_assert_fail_internal (ctf_dict_t *, const char *,\n \t\t\t\t      size_t, const char *);\n-extern const char *ctf_link_input_name (ctf_file_t *);\n+extern const char *ctf_link_input_name (ctf_dict_t *);\n \n extern Elf64_Sym *ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst);\n-extern const char *ctf_lookup_symbol_name (ctf_file_t *fp, unsigned long symidx);\n+extern const char *ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx);\n \n /* Variables, all underscore-prepended. */\n "
    },
    {
      "sha": "7486886d553f8f92b8f3fb4447aad8ef34c90275",
      "filename": "libctf/ctf-inlines.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-inlines.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-inlines.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-inlines.h?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -32,12 +32,12 @@ extern \"C\"\n #endif\n \n static inline ssize_t\n-ctf_get_ctt_size (const ctf_file_t *fp,\n+ctf_get_ctt_size (const ctf_dict_t *fp,\n \t\t  const ctf_type_t *tp,\n \t\t  ssize_t *sizep,\n \t\t  ssize_t *incrementp)\n {\n-  return (fp->ctf_fileops->ctfo_get_ctt_size (fp, tp, sizep, incrementp));\n+  return (fp->ctf_dictops->ctfo_get_ctt_size (fp, tp, sizep, incrementp));\n }\n \n static inline int\n@@ -81,7 +81,7 @@ ctf_dynset_cinsert (ctf_dynset_t *h, const void *k)\n }\n \n static inline int\n-ctf_assert_internal (ctf_file_t *fp, const char *file, size_t line,\n+ctf_assert_internal (ctf_dict_t *fp, const char *file, size_t line,\n \t\t     const char *exprstr, int expr)\n {\n   if (_libctf_unlikely_ (!expr))"
    },
    {
      "sha": "e2cbd2ed2d8ef6fcf1dd0adf2b901de7ac4ea5e2",
      "filename": "libctf/ctf-labels.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-labels.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-labels.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-labels.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -21,7 +21,7 @@\n #include <string.h>\n \n static int\n-extract_label_info (ctf_file_t *fp, const ctf_lblent_t **ctl,\n+extract_label_info (ctf_dict_t *fp, const ctf_lblent_t **ctl,\n \t\t    uint32_t *num_labels)\n {\n   const ctf_header_t *h;\n@@ -37,7 +37,7 @@ extract_label_info (ctf_file_t *fp, const ctf_lblent_t **ctl,\n /* Returns the topmost label, or NULL if any errors are encountered.  */\n \n const char *\n-ctf_label_topmost (ctf_file_t *fp)\n+ctf_label_topmost (ctf_dict_t *fp)\n {\n   const ctf_lblent_t *ctlp = NULL;\n   const char *s;\n@@ -61,7 +61,7 @@ ctf_label_topmost (ctf_file_t *fp)\n /* Iterate over all labels.  We pass the label string and the lblinfo_t struct\n    to the specified callback function.  */\n int\n-ctf_label_iter (ctf_file_t *fp, ctf_label_f *func, void *arg)\n+ctf_label_iter (ctf_dict_t *fp, ctf_label_f *func, void *arg)\n {\n   const ctf_lblent_t *ctlp = NULL;\n   uint32_t i;\n@@ -122,7 +122,7 @@ label_info_cb (const char *lname, const ctf_lblinfo_t *linfo, void *arg)\n \n /* Retrieve information about the label with name \"lname\". */\n int\n-ctf_label_info (ctf_file_t *fp, const char *lname, ctf_lblinfo_t *linfo)\n+ctf_label_info (ctf_dict_t *fp, const char *lname, ctf_lblinfo_t *linfo)\n {\n   linfo_cb_arg_t cb_arg;\n   int rc;"
    },
    {
      "sha": "c3801e6f3cbfe8ca1887e6e1fc59261ac95c1082",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 82,
      "deletions": 82,
      "changes": 164,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -28,18 +28,18 @@\n \n /* Record the correspondence between a source and ctf_add_type()-added\n    destination type: both types are translated into parent type IDs if need be,\n-   so they relate to the actual container they are in.  Outside controlled\n+   so they relate to the actual dictionary they are in.  Outside controlled\n    circumstances (like linking) it is probably not useful to do more than\n    compare these pointers, since there is nothing stopping the user closing the\n-   source container whenever they want to.\n+   source dict whenever they want to.\n \n    Our OOM handling here is just to not do anything, because this is called deep\n    enough in the call stack that doing anything useful is painfully difficult:\n    the worst consequence if we do OOM is a bit of type duplication anyway.  */\n \n void\n-ctf_add_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n-\t\t      ctf_file_t *dst_fp, ctf_id_t dst_type)\n+ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n+\t\t      ctf_dict_t *dst_fp, ctf_id_t dst_type)\n {\n   if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n     src_fp = src_fp->ctf_parent;\n@@ -83,10 +83,10 @@ ctf_add_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type,\n /* Look up a type mapping: return 0 if none.  The DST_FP is modified to point to\n    the parent if need be.  The ID returned is from the dst_fp's perspective.  */\n ctf_id_t\n-ctf_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type, ctf_file_t **dst_fp)\n+ctf_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type, ctf_dict_t **dst_fp)\n {\n   ctf_link_type_key_t key;\n-  ctf_file_t *target_fp = *dst_fp;\n+  ctf_dict_t *target_fp = *dst_fp;\n   ctf_id_t dst_type = 0;\n \n   if (LCTF_TYPE_ISPARENT (src_fp, src_type) && src_fp->ctf_parent)\n@@ -145,7 +145,7 @@ ctf_type_mapping (ctf_file_t *src_fp, ctf_id_t src_type, ctf_file_t **dst_fp)\n    to, or a non-null string otherwise: prefer the parent.  Used in debugging\n    output.  Sometimes used for outputs too.  */\n const char *\n-ctf_link_input_name (ctf_file_t *fp)\n+ctf_link_input_name (ctf_dict_t *fp)\n {\n   if (fp->ctf_parent && fp->ctf_parent->ctf_cuname)\n     return fp->ctf_parent->ctf_cuname;\n@@ -157,15 +157,15 @@ ctf_link_input_name (ctf_file_t *fp)\n \n /* The linker inputs look like this.  clin_fp is used for short-circuited\n    CU-mapped links that can entirely avoid the first link phase in some\n-   situations in favour of just passing on the contained ctf_file_t: it is\n-   always the sole ctf_file_t inside the corresponding clin_arc.  If set, it\n+   situations in favour of just passing on the contained ctf_dict_t: it is\n+   always the sole ctf_dict_t inside the corresponding clin_arc.  If set, it\n    gets assigned directly to the final link inputs and freed from there, so it\n    never gets explicitly freed in the ctf_link_input.  */\n typedef struct ctf_link_input\n {\n   const char *clin_filename;\n   ctf_archive_t *clin_arc;\n-  ctf_file_t *clin_fp;\n+  ctf_dict_t *clin_fp;\n   int n;\n } ctf_link_input_t;\n \n@@ -181,8 +181,8 @@ ctf_link_input_close (void *input)\n /* Like ctf_link_add_ctf, below, but with no error-checking, so it can be called\n    in the middle of an ongoing link.  */\n static int\n-ctf_link_add_ctf_internal (ctf_file_t *fp, ctf_archive_t *ctf,\n-\t\t\t   ctf_file_t *fp_input, const char *name)\n+ctf_link_add_ctf_internal (ctf_dict_t *fp, ctf_archive_t *ctf,\n+\t\t\t   ctf_dict_t *fp_input, const char *name)\n {\n   ctf_link_input_t *input = NULL;\n   char *dupname = NULL;\n@@ -228,7 +228,7 @@ ctf_link_add_ctf_internal (ctf_file_t *fp, ctf_archive_t *ctf,\n     implemented.  */\n \n static int\n-ctf_link_add (ctf_file_t *fp, ctf_archive_t *ctf, const char *name,\n+ctf_link_add (ctf_dict_t *fp, ctf_archive_t *ctf, const char *name,\n \t      void *buf _libctf_unused_, size_t n _libctf_unused_)\n {\n   if (buf)\n@@ -275,18 +275,18 @@ ctf_link_add (ctf_file_t *fp, ctf_archive_t *ctf, const char *name,\n     final link output, but otherwise is not important.  */\n \n int\n-ctf_link_add_ctf (ctf_file_t *fp, ctf_archive_t *ctf, const char *name)\n+ctf_link_add_ctf (ctf_dict_t *fp, ctf_archive_t *ctf, const char *name)\n {\n   return ctf_link_add (fp, ctf, name, NULL, 0);\n }\n \n /* Return a per-CU output CTF dictionary suitable for the given CU, creating and\n    interning it if need be.  */\n \n-static ctf_file_t *\n-ctf_create_per_cu (ctf_file_t *fp, const char *filename, const char *cuname)\n+static ctf_dict_t *\n+ctf_create_per_cu (ctf_dict_t *fp, const char *filename, const char *cuname)\n {\n-  ctf_file_t *cu_fp;\n+  ctf_dict_t *cu_fp;\n   const char *ctf_name = NULL;\n   char *dynname = NULL;\n \n@@ -334,21 +334,21 @@ ctf_create_per_cu (ctf_file_t *fp, const char *filename, const char *cuname)\n \n  oom:\n   free (dynname);\n-  ctf_file_close (cu_fp);\n+  ctf_dict_close (cu_fp);\n   ctf_set_errno (fp, ENOMEM);\n   return NULL;\n }\n \n /* Add a mapping directing that the CU named FROM should have its\n-   conflicting/non-duplicate types (depending on link mode) go into a container\n+   conflicting/non-duplicate types (depending on link mode) go into a dict\n    named TO.  Many FROMs can share a TO.\n \n-   We forcibly add a container named TO in every case, even though it may well\n+   We forcibly add a dict named TO in every case, even though it may well\n    wind up empty, because clients that use this facility usually expect to find\n-   every TO container present, even if empty, and malfunction otherwise.  */\n+   every TO dict present, even if empty, and malfunction otherwise.  */\n \n int\n-ctf_link_add_cu_mapping (ctf_file_t *fp, const char *from, const char *to)\n+ctf_link_add_cu_mapping (ctf_dict_t *fp, const char *from, const char *to)\n {\n   int err;\n   char *f = NULL, *t = NULL;\n@@ -431,7 +431,7 @@ ctf_link_add_cu_mapping (ctf_file_t *fp, const char *from, const char *to)\n    The changer function accepts a name and should return a new\n    dynamically-allocated name, or NULL if the name should be left unchanged.  */\n void\n-ctf_link_set_memb_name_changer (ctf_file_t *fp,\n+ctf_link_set_memb_name_changer (ctf_dict_t *fp,\n \t\t\t\tctf_link_memb_name_changer_f *changer,\n \t\t\t\tvoid *arg)\n {\n@@ -442,12 +442,12 @@ ctf_link_set_memb_name_changer (ctf_file_t *fp,\n typedef struct ctf_link_in_member_cb_arg\n {\n   /* The shared output dictionary.  */\n-  ctf_file_t *out_fp;\n+  ctf_dict_t *out_fp;\n \n   /* The filename of the input file, and an fp to each dictionary in that file\n      in turn.  */\n   const char *in_file_name;\n-  ctf_file_t *in_fp;\n+  ctf_dict_t *in_fp;\n \n   /* The CU name of the dict being processed.  */\n   const char *cu_name;\n@@ -456,7 +456,7 @@ typedef struct ctf_link_in_member_cb_arg\n   /* The parent dictionary in the input, and whether it's been processed yet.\n      Not needed by ctf_link_one_type / ctf_link_one_variable, only by higher\n      layers.  */\n-  ctf_file_t *in_fp_parent;\n+  ctf_dict_t *in_fp_parent;\n   int done_parent;\n \n   /* If true, this is the CU-mapped portion of a deduplicating link: no child\n@@ -472,7 +472,7 @@ static int\n ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n {\n   ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n-  ctf_file_t *per_cu_out_fp;\n+  ctf_dict_t *per_cu_out_fp;\n   int err;\n \n   if (arg->in_fp->ctf_link_flags != CTF_LINK_SHARE_UNCONFLICTED)\n@@ -533,18 +533,18 @@ ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n \n /* Set a function which is used to filter out unwanted variables from the link.  */\n int\n-ctf_link_set_variable_filter (ctf_file_t *fp, ctf_link_variable_filter_f *filter,\n+ctf_link_set_variable_filter (ctf_dict_t *fp, ctf_link_variable_filter_f *filter,\n \t\t\t      void *arg)\n {\n   fp->ctf_link_variable_filter = filter;\n   fp->ctf_link_variable_filter_arg = arg;\n   return 0;\n }\n \n-/* Check if we can safely add a variable with the given type to this container.  */\n+/* Check if we can safely add a variable with the given type to this dict.  */\n \n static int\n-check_variable (const char *name, ctf_file_t *fp, ctf_id_t type,\n+check_variable (const char *name, ctf_dict_t *fp, ctf_id_t type,\n \t\tctf_dvdef_t **out_dvd)\n {\n   ctf_dvdef_t *dvd;\n@@ -572,9 +572,9 @@ static int\n ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n {\n   ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n-  ctf_file_t *per_cu_out_fp;\n+  ctf_dict_t *per_cu_out_fp;\n   ctf_id_t dst_type = 0;\n-  ctf_file_t *check_fp;\n+  ctf_dict_t *check_fp;\n   ctf_dvdef_t *dvd;\n \n   /* See if this variable is filtered out.  */\n@@ -587,7 +587,7 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n     }\n \n   /* In unconflicted link mode, if this type is mapped to a type in the parent\n-     container, we want to try to add to that first: if it reports a duplicate,\n+     dict, we want to try to add to that first: if it reports a duplicate,\n      or if the type is in a child already, add straight to the child.  */\n \n   check_fp = arg->out_fp;\n@@ -657,7 +657,7 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n    ambiguous types if there is one and it's not the default: otherwise, we use\n    the name of the input file.  */\n static int\n-ctf_link_one_input_archive_member (ctf_file_t *in_fp, const char *name, void *arg_)\n+ctf_link_one_input_archive_member (ctf_dict_t *in_fp, const char *name, void *arg_)\n {\n   ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n   int err = 0;\n@@ -705,7 +705,7 @@ static void\n empty_link_type_mapping (void *key _libctf_unused_, void *value,\n \t\t\t void *arg _libctf_unused_)\n {\n-  ctf_file_t *fp = (ctf_file_t *) value;\n+  ctf_dict_t *fp = (ctf_dict_t *) value;\n \n   if (fp->ctf_link_type_mapping)\n     ctf_dynhash_empty (fp->ctf_link_type_mapping);\n@@ -716,7 +716,7 @@ empty_link_type_mapping (void *key _libctf_unused_, void *value,\n    Returns the number of files contained within the opened archive (0 for none),\n    or -1 on error, as usual.  */\n static ssize_t\n-ctf_link_lazy_open (ctf_file_t *fp, ctf_link_input_t *input)\n+ctf_link_lazy_open (ctf_dict_t *fp, ctf_link_input_t *input)\n {\n   size_t count;\n   int err;\n@@ -803,7 +803,7 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n   if (ctf_link_one_input_archive_member (arg->in_fp_parent,\n \t\t\t\t\t _CTF_SECTION, arg) < 0)\n     {\n-      ctf_file_close (arg->in_fp_parent);\n+      ctf_dict_close (arg->in_fp_parent);\n       goto out;\n     }\n   arg->done_parent = 1;\n@@ -818,7 +818,7 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n \t is zero if there was no actual error from the caller.  */\n       ctf_set_errno (arg->out_fp, 0);\n     }\n-  ctf_file_close (arg->in_fp_parent);\n+  ctf_dict_close (arg->in_fp_parent);\n \n  out:\n   ctf_link_close_one_input_archive (key, value, NULL);\n@@ -827,7 +827,7 @@ ctf_link_one_input_archive (void *key, void *value, void *arg_)\n typedef struct link_sort_inputs_cb_arg\n {\n   int is_cu_mapped;\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n } link_sort_inputs_cb_arg_t;\n \n /* Sort the inputs by N (the link order).  For CU-mapped links, this is a\n@@ -875,7 +875,7 @@ ctf_link_sort_inputs (const ctf_next_hkv_t *one, const ctf_next_hkv_t *two,\n    and optionally the name and ctf_link_input_t of the single input archive if\n    only one exists (no matter how many dicts it contains).  */\n static ssize_t\n-ctf_link_deduplicating_count_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n+ctf_link_deduplicating_count_inputs (ctf_dict_t *fp, ctf_dynhash_t *cu_names,\n \t\t\t\t     ctf_link_input_t **only_one_input)\n {\n   ctf_dynhash_t *inputs = fp->ctf_link_inputs;\n@@ -952,23 +952,23 @@ ctf_link_deduplicating_count_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n \n    If no inputs exist that correspond to these CUs, return NULL with the errno\n    set to ECTF_NOCTFDATA.  */\n-static ctf_file_t **\n-ctf_link_deduplicating_open_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n+static ctf_dict_t **\n+ctf_link_deduplicating_open_inputs (ctf_dict_t *fp, ctf_dynhash_t *cu_names,\n \t\t\t\t    ssize_t ninputs, uint32_t **parents)\n {\n   ctf_dynhash_t *inputs = fp->ctf_link_inputs;\n   ctf_next_t *i = NULL;\n   void *name, *input;\n   link_sort_inputs_cb_arg_t sort_arg;\n-  ctf_file_t **dedup_inputs = NULL;\n-  ctf_file_t **walk;\n+  ctf_dict_t **dedup_inputs = NULL;\n+  ctf_dict_t **walk;\n   uint32_t *parents_ = NULL;\n   int err;\n \n   if (cu_names)\n     inputs = cu_names;\n \n-  if ((dedup_inputs = calloc (ninputs, sizeof (ctf_file_t *))) == NULL)\n+  if ((dedup_inputs = calloc (ninputs, sizeof (ctf_dict_t *))) == NULL)\n     goto oom;\n \n   if ((parents_ = calloc (ninputs, sizeof (uint32_t))) == NULL)\n@@ -987,8 +987,8 @@ ctf_link_deduplicating_open_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n     {\n       const char *one_name = (const char *) name;\n       ctf_link_input_t *one_input;\n-      ctf_file_t *one_fp;\n-      ctf_file_t *parent_fp = NULL;\n+      ctf_dict_t *one_fp;\n+      ctf_dict_t *parent_fp = NULL;\n       uint32_t parent_i;\n       ctf_next_t *j = NULL;\n \n@@ -1088,8 +1088,8 @@ ctf_link_deduplicating_open_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n    CU_NAMES.  If CU_NAMES is not specified, close all the ctf_link_inputs in one\n    go, leaving it empty.  */\n static int\n-ctf_link_deduplicating_close_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n-\t\t\t\t     ctf_file_t **inputs, ssize_t ninputs)\n+ctf_link_deduplicating_close_inputs (ctf_dict_t *fp, ctf_dynhash_t *cu_names,\n+\t\t\t\t     ctf_dict_t **inputs, ssize_t ninputs)\n {\n   ctf_next_t *it = NULL;\n   void *name;\n@@ -1099,7 +1099,7 @@ ctf_link_deduplicating_close_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n   /* This is the inverse of ctf_link_deduplicating_open_inputs: so first, close\n      all the individual input dicts, opened by the archive iterator.  */\n   for (i = 0; i < ninputs; i++)\n-    ctf_file_close (inputs[i]);\n+    ctf_dict_close (inputs[i]);\n \n   /* Now close the archives they are part of.  */\n   if (cu_names)\n@@ -1126,7 +1126,7 @@ ctf_link_deduplicating_close_inputs (ctf_file_t *fp, ctf_dynhash_t *cu_names,\n \n /* Do a deduplicating link of all variables in the inputs.  */\n static int\n-ctf_link_deduplicating_variables (ctf_file_t *fp, ctf_file_t **inputs,\n+ctf_link_deduplicating_variables (ctf_dict_t *fp, ctf_dict_t **inputs,\n \t\t\t\t  size_t ninputs, int cu_mapped)\n {\n   ctf_link_in_member_cb_arg_t arg;\n@@ -1155,7 +1155,7 @@ ctf_link_deduplicating_variables (ctf_file_t *fp, ctf_file_t **inputs,\n \n /* Do the per-CU part of a deduplicating link.  */\n static int\n-ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n+ctf_link_deduplicating_per_cu (ctf_dict_t *fp)\n {\n   ctf_next_t *i = NULL;\n   int err;\n@@ -1172,9 +1172,9 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n     {\n       const char *out_name = (const char *) out_cu;\n       ctf_dynhash_t *in = (ctf_dynhash_t *) in_cus;\n-      ctf_file_t *out = NULL;\n-      ctf_file_t **inputs;\n-      ctf_file_t **outputs;\n+      ctf_dict_t *out = NULL;\n+      ctf_dict_t **inputs;\n+      ctf_dict_t **outputs;\n       ctf_archive_t *in_arc;\n       ssize_t ninputs;\n       ctf_link_input_t *only_input;\n@@ -1336,17 +1336,17 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \t  goto err_outputs;\n \t}\n \n-      ctf_file_close (out);\n+      ctf_dict_close (out);\n       free (outputs);\n       continue;\n \n     err_inputs_outputs:\n       ctf_list_splice (&fp->ctf_errs_warnings, &outputs[0]->ctf_errs_warnings);\n-      ctf_file_close (outputs[0]);\n+      ctf_dict_close (outputs[0]);\n       free (outputs);\n     err_inputs:\n       ctf_link_deduplicating_close_inputs (fp, in, inputs, ninputs);\n-      ctf_file_close (out);\n+      ctf_dict_close (out);\n       free (inputs);\n       free (parents);\n     err_open_inputs:\n@@ -1355,7 +1355,7 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \n     err_outputs:\n       ctf_list_splice (&fp->ctf_errs_warnings, &outputs[0]->ctf_errs_warnings);\n-      ctf_file_close (outputs[0]);\n+      ctf_dict_close (outputs[0]);\n       free (outputs);\n       ctf_next_destroy (i);\n       return -1;\t\t\t\t/* Errno is set for us.  */\n@@ -1372,10 +1372,10 @@ ctf_link_deduplicating_per_cu (ctf_file_t *fp)\n \n /* Do a deduplicating link using the ctf-dedup machinery.  */\n static void\n-ctf_link_deduplicating (ctf_file_t *fp)\n+ctf_link_deduplicating (ctf_dict_t *fp)\n {\n   size_t i;\n-  ctf_file_t **inputs, **outputs = NULL;\n+  ctf_dict_t **inputs, **outputs = NULL;\n   ssize_t ninputs;\n   uint32_t noutputs;\n   uint32_t *parents;\n@@ -1425,7 +1425,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n       /* We already have access to this one.  Close the duplicate.  */\n       if (i == 0)\n \t{\n-\t  ctf_file_close (outputs[0]);\n+\t  ctf_dict_close (outputs[0]);\n \t  continue;\n \t}\n \n@@ -1443,7 +1443,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n       free (dynname);\n \n       for (; i < noutputs; i++)\n-\tctf_file_close (outputs[i]);\n+\tctf_dict_close (outputs[i]);\n       goto err;\n     }\n \n@@ -1453,7 +1453,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n       ctf_err_warn (fp, 0, 0, _(\"deduplicating link variable emission failed for \"\n \t\t\t\t\"%s\"), ctf_link_input_name (fp));\n       for (i = 1; i < noutputs; i++)\n-\tctf_file_close (outputs[i]);\n+\tctf_dict_close (outputs[i]);\n       goto err;\n     }\n \n@@ -1469,7 +1469,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n \n  err:\n   for (i = 0; i < (size_t) ninputs; i++)\n-    ctf_file_close (inputs[i]);\n+    ctf_dict_close (inputs[i]);\n   free (inputs);\n   free (parents);\n   free (outputs);\n@@ -1479,7 +1479,7 @@ ctf_link_deduplicating (ctf_file_t *fp)\n /* Merge types and variable sections in all files added to the link\n    together.  All the added files are closed.  */\n int\n-ctf_link (ctf_file_t *fp, int flags)\n+ctf_link (ctf_dict_t *fp, int flags)\n {\n   ctf_link_in_member_cb_arg_t arg;\n   ctf_next_t *i = NULL;\n@@ -1496,7 +1496,7 @@ ctf_link (ctf_file_t *fp, int flags)\n     fp->ctf_link_outputs = ctf_dynhash_create (ctf_hash_string,\n \t\t\t\t\t       ctf_hash_eq_string, free,\n \t\t\t\t\t       (ctf_hash_free_fun)\n-\t\t\t\t\t       ctf_file_close);\n+\t\t\t\t\t       ctf_dict_close);\n \n   if (fp->ctf_link_outputs == NULL)\n     return ctf_set_errno (fp, ENOMEM);\n@@ -1555,7 +1555,7 @@ static void\n ctf_link_intern_extern_string (void *key _libctf_unused_, void *value,\n \t\t\t       void *arg_)\n {\n-  ctf_file_t *fp = (ctf_file_t *) value;\n+  ctf_dict_t *fp = (ctf_dict_t *) value;\n   ctf_link_out_string_cb_arg_t *arg = (ctf_link_out_string_cb_arg_t *) arg_;\n \n   fp->ctf_flags |= LCTF_DIRTY;\n@@ -1570,7 +1570,7 @@ ctf_link_intern_extern_string (void *key _libctf_unused_, void *value,\n    files ctf_link() can create to get their strings dedupped against the ELF\n    strtab properly.  */\n int\n-ctf_link_add_strtab (ctf_file_t *fp, ctf_link_strtab_string_f *add_string,\n+ctf_link_add_strtab (ctf_dict_t *fp, ctf_link_strtab_string_f *add_string,\n \t\t     void *arg)\n {\n   const char *str;\n@@ -1596,7 +1596,7 @@ ctf_link_add_strtab (ctf_file_t *fp, ctf_link_strtab_string_f *add_string,\n \n /* Not yet implemented.  */\n int\n-ctf_link_shuffle_syms (ctf_file_t *fp _libctf_unused_,\n+ctf_link_shuffle_syms (ctf_dict_t *fp _libctf_unused_,\n \t\t       ctf_link_iter_symbol_f *add_sym _libctf_unused_,\n \t\t       void *arg _libctf_unused_)\n {\n@@ -1606,8 +1606,8 @@ ctf_link_shuffle_syms (ctf_file_t *fp _libctf_unused_,\n typedef struct ctf_name_list_accum_cb_arg\n {\n   char **names;\n-  ctf_file_t *fp;\n-  ctf_file_t **files;\n+  ctf_dict_t *fp;\n+  ctf_dict_t **files;\n   size_t i;\n   char **dynames;\n   size_t ndynames;\n@@ -1618,9 +1618,9 @@ static void\n ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n {\n   const char *name = (const char *) key;\n-  ctf_file_t *fp = (ctf_file_t *) value;\n+  ctf_dict_t *fp = (ctf_dict_t *) value;\n   char **names;\n-  ctf_file_t **files;\n+  ctf_dict_t **files;\n   ctf_name_list_accum_cb_arg_t *arg = (ctf_name_list_accum_cb_arg_t *) arg_;\n \n   if ((names = realloc (arg->names, sizeof (char *) * ++(arg->i))) == NULL)\n@@ -1630,7 +1630,7 @@ ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n       return;\n     }\n \n-  if ((files = realloc (arg->files, sizeof (ctf_file_t *) * arg->i)) == NULL)\n+  if ((files = realloc (arg->files, sizeof (ctf_dict_t *) * arg->i)) == NULL)\n     {\n       (arg->i)--;\n       ctf_set_errno (arg->fp, ENOMEM);\n@@ -1675,7 +1675,7 @@ ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n static void\n ctf_change_parent_name (void *key _libctf_unused_, void *value, void *arg)\n {\n-  ctf_file_t *fp = (ctf_file_t *) value;\n+  ctf_dict_t *fp = (ctf_dict_t *) value;\n   const char *name = (const char *) arg;\n \n   ctf_parent_name_set (fp, name);\n@@ -1685,12 +1685,12 @@ ctf_change_parent_name (void *key _libctf_unused_, void *value, void *arg)\n    (otherwise) into a new dynamically-allocated string, and return it.\n    Members with sizes above THRESHOLD are compressed.  */\n unsigned char *\n-ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n+ctf_link_write (ctf_dict_t *fp, size_t *size, size_t threshold)\n {\n   ctf_name_list_accum_cb_arg_t arg;\n   char **names;\n   char *transformed_name = NULL;\n-  ctf_file_t **files;\n+  ctf_dict_t **files;\n   FILE *f = NULL;\n   int err;\n   long fsize;\n@@ -1710,7 +1710,7 @@ ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n \t}\n     }\n \n-  /* No extra outputs? Just write a simple ctf_file_t.  */\n+  /* No extra outputs? Just write a simple ctf_dict_t.  */\n   if (arg.i == 0)\n     return ctf_write_mem (fp, size, threshold);\n \n@@ -1741,13 +1741,13 @@ ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n     }\n \n   if ((files = realloc (arg.files,\n-\t\t\tsizeof (struct ctf_file *) * (arg.i + 1))) == NULL)\n+\t\t\tsizeof (struct ctf_dict *) * (arg.i + 1))) == NULL)\n     {\n-      errloc = \"ctf_file reallocation\";\n+      errloc = \"ctf_dict reallocation\";\n       goto err_no;\n     }\n   arg.files = files;\n-  memmove (&(arg.files[1]), arg.files, sizeof (ctf_file_t *) * (arg.i));\n+  memmove (&(arg.files[1]), arg.files, sizeof (ctf_dict_t *) * (arg.i));\n   arg.files[0] = fp;\n \n   if ((f = tmpfile ()) == NULL)"
    },
    {
      "sha": "5682bf0e610c550bcee72220ba4923266ece48cd",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -69,7 +69,7 @@ isqualifier (const char *s, size_t len)\n    integers, floats, typedefs, and pointers to any of these named types.  */\n \n ctf_id_t\n-ctf_lookup_by_name (ctf_file_t *fp, const char *name)\n+ctf_lookup_by_name (ctf_dict_t *fp, const char *name)\n {\n   static const char delimiters[] = \" \\t\\n\\r\\v\\f*\";\n \n@@ -102,7 +102,7 @@ ctf_lookup_by_name (ctf_file_t *fp, const char *name)\n \t     data includes \"struct foo *\" but not \"foo_t *\" and\n \t     the user tries to access \"foo_t *\" in the debugger.\n \n-\t     TODO need to handle parent containers too.  */\n+\t     TODO need to handle parent dicts too.  */\n \n \t  ntype = fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, type)];\n \t  if (ntype == 0)\n@@ -194,7 +194,7 @@ ctf_lookup_by_name (ctf_file_t *fp, const char *name)\n \n typedef struct ctf_lookup_var_key\n {\n-  ctf_file_t *clvk_fp;\n+  ctf_dict_t *clvk_fp;\n   const char *clvk_name;\n } ctf_lookup_var_key_t;\n \n@@ -212,7 +212,7 @@ ctf_lookup_var (const void *key_, const void *memb_)\n /* Given a variable name, return the type of the variable with that name.  */\n \n ctf_id_t\n-ctf_lookup_variable (ctf_file_t *fp, const char *name)\n+ctf_lookup_variable (ctf_dict_t *fp, const char *name)\n {\n   ctf_varent_t *ent;\n   ctf_lookup_var_key_t key = { fp, name };\n@@ -236,7 +236,7 @@ ctf_lookup_variable (ctf_file_t *fp, const char *name)\n /* Given a symbol table index, return the name of that symbol from the secondary\n    string table, or the null string (never NULL).  */\n const char *\n-ctf_lookup_symbol_name (ctf_file_t *fp, unsigned long symidx)\n+ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n   Elf64_Sym sym, *gsp;\n@@ -271,7 +271,7 @@ ctf_lookup_symbol_name (ctf_file_t *fp, unsigned long symidx)\n    by the corresponding entry in the symbol table.  */\n \n ctf_id_t\n-ctf_lookup_by_symbol (ctf_file_t *fp, unsigned long symidx)\n+ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n   ctf_id_t type;\n@@ -308,8 +308,8 @@ ctf_lookup_by_symbol (ctf_file_t *fp, unsigned long symidx)\n /* Return the native dict of a given type: if called on a child and the\n    type is in the parent, return the parent.  Needed if you plan to access\n    the type directly, without using the API.  */\n-ctf_file_t *\n-ctf_get_dict (ctf_file_t *fp, ctf_id_t type)\n+ctf_dict_t *\n+ctf_get_dict (ctf_dict_t *fp, ctf_id_t type)\n {\n     if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type))\n       return fp->ctf_parent;\n@@ -322,9 +322,9 @@ ctf_get_dict (ctf_file_t *fp, ctf_id_t type)\n    This function is not exported outside of the library.  */\n \n const ctf_type_t *\n-ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n+ctf_lookup_by_id (ctf_dict_t **fpp, ctf_id_t type)\n {\n-  ctf_file_t *fp = *fpp;\t/* Caller passes in starting CTF dict.  */\n+  ctf_dict_t *fp = *fpp;\t/* Caller passes in starting CTF dict.  */\n   ctf_id_t idx;\n \n   if ((fp = ctf_get_dict (fp, type)) == NULL)\n@@ -353,7 +353,7 @@ ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n   idx = LCTF_TYPE_TO_INDEX (fp, type);\n   if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n     {\n-      *fpp = fp;\t\t/* Function returns ending CTF container.  */\n+      *fpp = fp;\t\t/* Function returns ending CTF dict.  */\n       return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n     }\n \n@@ -365,7 +365,7 @@ ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n    by the corresponding entry in the symbol table.  */\n \n int\n-ctf_func_info (ctf_file_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n+ctf_func_info (ctf_dict_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n   const uint32_t *dp;\n@@ -422,7 +422,7 @@ ctf_func_info (ctf_file_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n    by the corresponding entry in the symbol table.  */\n \n int\n-ctf_func_args (ctf_file_t * fp, unsigned long symidx, uint32_t argc,\n+ctf_func_args (ctf_dict_t *fp, unsigned long symidx, uint32_t argc,\n \t       ctf_id_t * argv)\n {\n   const uint32_t *dp;"
    },
    {
      "sha": "449347ee39a8836a471bfe88e00f8bf1082374b1",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -209,10 +209,10 @@ err: _libctf_unused_;\n }\n \n /* Open the specified file descriptor and return a pointer to a CTF archive that\n-   contains one or more CTF containers.  The file can be an ELF file, a raw CTF\n-   file, or a CTF archive.  The caller is responsible for closing the file\n-   descriptor when it is no longer needed.  If this is an ELF file, TARGET, if\n-   non-NULL, should be the name of a suitable BFD target.  */\n+   contains one or more CTF dicts.  The file can be an ELF file, a file\n+   containing raw CTF, or a CTF archive.  The caller is responsible for closing\n+   the file descriptor when it is no longer needed.  If this is an ELF file,\n+   TARGET, if non-NULL, should be the name of a suitable BFD target.  */\n \n ctf_archive_t *\n ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n@@ -245,7 +245,7 @@ ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n       && (ctfhdr.ctp_magic == CTF_MAGIC\n \t  || ctfhdr.ctp_magic == bswap_16 (CTF_MAGIC)))\n     {\n-      ctf_file_t *fp = NULL;\n+      ctf_dict_t *fp = NULL;\n       void *data;\n \n       if ((data = ctf_mmap (st.st_size, 0, fd)) == NULL)\n@@ -316,7 +316,7 @@ ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n   return arci;\n }\n \n-/* Open the specified file and return a pointer to a CTF container.  The file\n+/* Open the specified file and return a pointer to a CTF dict.  The file\n    can be either an ELF file or raw CTF file.  This is just a convenient\n    wrapper around ctf_fdopen() for callers.  */\n "
    },
    {
      "sha": "456efa6546941a44ded9c0a4e4d88b1ef5d0c9b0",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 97,
      "deletions": 84,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -77,7 +77,7 @@ get_vlen_v2 (uint32_t info)\n }\n \n static inline ssize_t\n-get_ctt_size_common (const ctf_file_t *fp _libctf_unused_,\n+get_ctt_size_common (const ctf_dict_t *fp _libctf_unused_,\n \t\t     const ctf_type_t *tp _libctf_unused_,\n \t\t     ssize_t *sizep, ssize_t *incrementp, size_t lsize,\n \t\t     size_t csize, size_t ctf_type_size,\n@@ -105,7 +105,7 @@ get_ctt_size_common (const ctf_file_t *fp _libctf_unused_,\n }\n \n static ssize_t\n-get_ctt_size_v1 (const ctf_file_t *fp, const ctf_type_t *tp,\n+get_ctt_size_v1 (const ctf_dict_t *fp, const ctf_type_t *tp,\n \t\t ssize_t *sizep, ssize_t *incrementp)\n {\n   ctf_type_v1_t *t1p = (ctf_type_v1_t *) tp;\n@@ -119,7 +119,7 @@ get_ctt_size_v1 (const ctf_file_t *fp, const ctf_type_t *tp,\n /* Return the size that a v1 will be once it is converted to v2.  */\n \n static ssize_t\n-get_ctt_size_v2_unconverted (const ctf_file_t *fp, const ctf_type_t *tp,\n+get_ctt_size_v2_unconverted (const ctf_dict_t *fp, const ctf_type_t *tp,\n \t\t\t     ssize_t *sizep, ssize_t *incrementp)\n {\n   ctf_type_v1_t *t1p = (ctf_type_v1_t *) tp;\n@@ -131,7 +131,7 @@ get_ctt_size_v2_unconverted (const ctf_file_t *fp, const ctf_type_t *tp,\n }\n \n static ssize_t\n-get_ctt_size_v2 (const ctf_file_t *fp, const ctf_type_t *tp,\n+get_ctt_size_v2 (const ctf_dict_t *fp, const ctf_type_t *tp,\n \t\t ssize_t *sizep, ssize_t *incrementp)\n {\n   return (get_ctt_size_common (fp, tp, sizep, incrementp,\n@@ -141,7 +141,7 @@ get_ctt_size_v2 (const ctf_file_t *fp, const ctf_type_t *tp,\n }\n \n static ssize_t\n-get_vbytes_common (ctf_file_t *fp, unsigned short kind,\n+get_vbytes_common (ctf_dict_t *fp, unsigned short kind,\n \t\t   ssize_t size _libctf_unused_, size_t vlen)\n {\n   switch (kind)\n@@ -169,7 +169,7 @@ get_vbytes_common (ctf_file_t *fp, unsigned short kind,\n }\n \n static ssize_t\n-get_vbytes_v1 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n+get_vbytes_v1 (ctf_dict_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n {\n   switch (kind)\n     {\n@@ -189,7 +189,7 @@ get_vbytes_v1 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n }\n \n static ssize_t\n-get_vbytes_v2 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n+get_vbytes_v2 (ctf_dict_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n {\n   switch (kind)\n     {\n@@ -208,7 +208,7 @@ get_vbytes_v2 (ctf_file_t *fp, unsigned short kind, ssize_t size, size_t vlen)\n   return (get_vbytes_common (fp, kind, size, vlen));\n }\n \n-static const ctf_fileops_t ctf_fileops[] = {\n+static const ctf_dictops_t ctf_dictops[] = {\n   {NULL, NULL, NULL, NULL, NULL},\n   /* CTF_VERSION_1 */\n   {get_kind_v1, get_root_v1, get_vlen_v1, get_ctt_size_v1, get_vbytes_v1},\n@@ -225,7 +225,7 @@ static const ctf_fileops_t ctf_fileops[] = {\n   STT_OBJECT entry in the symbol table.  */\n \n static int\n-init_symtab (ctf_file_t *fp, const ctf_header_t *hp,\n+init_symtab (ctf_dict_t *fp, const ctf_header_t *hp,\n \t     const ctf_sect_t *sp, const ctf_sect_t *strp)\n {\n   const unsigned char *symp = sp->cts_data;\n@@ -311,14 +311,14 @@ init_symtab (ctf_file_t *fp, const ctf_header_t *hp,\n }\n \n /* Reset the CTF base pointer and derive the buf pointer from it, initializing\n-   everything in the ctf_file that depends on the base or buf pointers.\n+   everything in the ctf_dict that depends on the base or buf pointers.\n \n    The original gap between the buf and base pointers, if any -- the original,\n    unconverted CTF header -- is kept, but its contents are not specified and are\n    never used.  */\n \n static void\n-ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, unsigned char *base)\n+ctf_set_base (ctf_dict_t *fp, const ctf_header_t *hp, unsigned char *base)\n {\n   fp->ctf_buf = base + (fp->ctf_buf - fp->ctf_base);\n   fp->ctf_base = base;\n@@ -330,8 +330,8 @@ ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, unsigned char *base)\n     + hp->cth_stroff;\n   fp->ctf_str[CTF_STRTAB_0].cts_len = hp->cth_strlen;\n \n-  /* If we have a parent container name and label, store the relocated\n-     string pointers in the CTF container for easy access later. */\n+  /* If we have a parent dict name and label, store the relocated string\n+     pointers in the CTF dict for easy access later. */\n \n   /* Note: before conversion, these will be set to values that will be\n      immediately invalidated by the conversion process, but the conversion\n@@ -359,11 +359,11 @@ ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, unsigned char *base)\n    caller must ensure this has been done in advance.  */\n \n static void\n-ctf_set_version (ctf_file_t *fp, ctf_header_t *cth, int ctf_version)\n+ctf_set_version (ctf_dict_t *fp, ctf_header_t *cth, int ctf_version)\n {\n   fp->ctf_version = ctf_version;\n   cth->cth_version = ctf_version;\n-  fp->ctf_fileops = &ctf_fileops[ctf_version];\n+  fp->ctf_dictops = &ctf_dictops[ctf_version];\n }\n \n \n@@ -397,7 +397,7 @@ upgrade_header (ctf_header_t *hp)\n    Type kinds not checked here due to nonexistence in older formats:\n       CTF_K_SLICE.  */\n static int\n-upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n+upgrade_types_v1 (ctf_dict_t *fp, ctf_header_t *cth)\n {\n   const ctf_type_v1_t *tbuf;\n   const ctf_type_v1_t *tend;\n@@ -621,7 +621,7 @@ upgrade_types_v1 (ctf_file_t *fp, ctf_header_t *cth)\n \n /* Upgrade from any earlier version.  */\n static int\n-upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n+upgrade_types (ctf_dict_t *fp, ctf_header_t *cth)\n {\n   switch (cth->cth_version)\n     {\n@@ -649,7 +649,7 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n    recension of libctf supports upgrading.  */\n \n static int\n-init_types (ctf_file_t *fp, ctf_header_t *cth)\n+init_types (ctf_dict_t *fp, ctf_header_t *cth)\n {\n   const ctf_type_t *tbuf;\n   const ctf_type_t *tend;\n@@ -659,8 +659,8 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n   uint32_t id, dst;\n   uint32_t *xp;\n \n-  /* We determine whether the container is a child or a parent based on\n-     the value of cth_parname.  */\n+  /* We determine whether the dict is a child or a parent based on the value of\n+     cth_parname.  */\n \n   int child = cth->cth_parname != 0;\n   int nlstructs = 0, nlunions = 0;\n@@ -704,11 +704,11 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \n   if (child)\n     {\n-      ctf_dprintf (\"CTF container %p is a child\\n\", (void *) fp);\n+      ctf_dprintf (\"CTF dict %p is a child\\n\", (void *) fp);\n       fp->ctf_flags |= LCTF_CHILD;\n     }\n   else\n-    ctf_dprintf (\"CTF container %p is a parent\\n\", (void *) fp);\n+    ctf_dprintf (\"CTF dict %p is a parent\\n\", (void *) fp);\n \n   /* Now that we've counted up the number of each type, we can allocate\n      the hash tables, type translation table, and pointer table.  */\n@@ -885,9 +885,9 @@ init_types (ctf_file_t *fp, ctf_header_t *cth)\n \t  }\n \n \tcase CTF_K_POINTER:\n-\t  /* If the type referenced by the pointer is in this CTF container,\n-\t     then store the index of the pointer type in\n-\t     fp->ctf_ptrtab[ index of referenced type ].  */\n+\t  /* If the type referenced by the pointer is in this CTF dict, then\n+\t     store the index of the pointer type in fp->ctf_ptrtab[ index of\n+\t     referenced type ].  */\n \n \t  if (LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child\n \t      && LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n@@ -1045,7 +1045,7 @@ flip_vars (void *start, size_t len)\n    ctf_stype followed by variable data.  */\n \n static int\n-flip_types (ctf_file_t *fp, void *start, size_t len)\n+flip_types (ctf_dict_t *fp, void *start, size_t len)\n {\n   ctf_type_t *t = start;\n \n@@ -1203,7 +1203,7 @@ flip_types (ctf_file_t *fp, void *start, size_t len)\n    data, this is no real loss.  */\n \n static int\n-flip_ctf (ctf_file_t *fp, ctf_header_t *cth, unsigned char *buf)\n+flip_ctf (ctf_dict_t *fp, ctf_header_t *cth, unsigned char *buf)\n {\n   flip_lbls (buf + cth->cth_lbloff, cth->cth_objtoff - cth->cth_lbloff);\n   flip_objts (buf + cth->cth_objtoff, cth->cth_funcoff - cth->cth_objtoff);\n@@ -1214,9 +1214,9 @@ flip_ctf (ctf_file_t *fp, ctf_header_t *cth, unsigned char *buf)\n   return flip_types (fp, buf + cth->cth_typeoff, cth->cth_stroff - cth->cth_typeoff);\n }\n \n-/* Set up the ctl hashes in a ctf_file_t.  Called by both writable and\n+/* Set up the ctl hashes in a ctf_dict_t.  Called by both writable and\n    non-writable dictionary initialization.  */\n-void ctf_set_ctl_hashes (ctf_file_t *fp)\n+void ctf_set_ctl_hashes (ctf_dict_t *fp)\n {\n   /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n      array of type name prefixes and the corresponding ctf_hash to use.  */\n@@ -1239,7 +1239,7 @@ void ctf_set_ctl_hashes (ctf_file_t *fp)\n \n /* Open a CTF file, mocking up a suitable ctf_sect.  */\n \n-ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n+ctf_dict_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n \t\t\t     const char *symsect, size_t symsect_size,\n \t\t\t     size_t symsect_entsize,\n \t\t\t     const char *strsect, size_t strsect_size,\n@@ -1253,7 +1253,7 @@ ctf_file_t *ctf_simple_open (const char *ctfsect, size_t ctfsect_size,\n /* Open a CTF file, mocking up a suitable ctf_sect and overriding the external\n    strtab with a synthetic one.  */\n \n-ctf_file_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n+ctf_dict_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n \t\t\t\t      const char *symsect, size_t symsect_size,\n \t\t\t\t      size_t symsect_entsize,\n \t\t\t\t      const char *strsect, size_t strsect_size,\n@@ -1300,11 +1300,11 @@ ctf_file_t *ctf_simple_open_internal (const char *ctfsect, size_t ctfsect_size,\n }\n \n /* Decode the specified CTF buffer and optional symbol table, and create a new\n-   CTF container representing the symbolic debugging information.  This code can\n+   CTF dict representing the symbolic debugging information.  This code can\n    be used directly by the debugger, or it can be used as the engine for\n    ctf_fdopen() or ctf_open(), below.  */\n \n-ctf_file_t *\n+ctf_dict_t *\n ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t     const ctf_sect_t *strsect, int *errp)\n {\n@@ -1313,15 +1313,15 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n /* Like ctf_bufopen, but overriding the external strtab with a synthetic one.  */\n \n-ctf_file_t *\n+ctf_dict_t *\n ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t\t      const ctf_sect_t *strsect, ctf_dynhash_t *syn_strtab,\n \t\t      int writable, int *errp)\n {\n   const ctf_preamble_t *pp;\n   size_t hdrsz = sizeof (ctf_header_t);\n   ctf_header_t *hp;\n-  ctf_file_t *fp;\n+  ctf_dict_t *fp;\n   int foreign_endian = 0;\n   int err;\n \n@@ -1393,10 +1393,10 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n   if (ctfsect->cts_size < hdrsz)\n     return (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n \n-  if ((fp = malloc (sizeof (ctf_file_t))) == NULL)\n+  if ((fp = malloc (sizeof (ctf_dict_t))) == NULL)\n     return (ctf_set_open_errno (errp, ENOMEM));\n \n-  memset (fp, 0, sizeof (ctf_file_t));\n+  memset (fp, 0, sizeof (ctf_dict_t));\n \n   if (writable)\n     fp->ctf_flags |= LCTF_RDWR;\n@@ -1511,7 +1511,7 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n     }\n \n   /* Once we have uncompressed and validated the CTF data buffer, we can\n-     proceed with initializing the ctf_file_t we allocated above.\n+     proceed with initializing the ctf_dict_t we allocated above.\n \n      Nothing that depends on buf or base should be set directly in this function\n      before the init_types() call, because it may be reallocated during\n@@ -1575,8 +1575,8 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \n   ctf_set_base (fp, hp, fp->ctf_base);\n \n-  /* No need to do anything else for dynamic containers: they do not support\n-     symbol lookups, and the type table is maintained in the dthashes.  */\n+  /* No need to do anything else for dynamic dicts: they do not support symbol\n+     lookups, and the type table is maintained in the dthashes.  */\n   if (fp->ctf_flags & LCTF_RDWR)\n     {\n       fp->ctf_refcnt = 1;\n@@ -1624,37 +1624,37 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n bad:\n   ctf_set_open_errno (errp, err);\n   ctf_err_warn_to_open (fp);\n-  ctf_file_close (fp);\n+  ctf_dict_close (fp);\n   return NULL;\n }\n \n-/* Bump the refcount on the specified CTF container, to allow export of\n-   ctf_file_t's from iterators that open and close the ctf_file_t around the\n-   loop.  (This does not extend their lifetime beyond that of the ctf_archive_t\n-   in which they are contained.)  */\n+/* Bump the refcount on the specified CTF dict, to allow export of ctf_dict_t's\n+   from iterators that open and close the ctf_dict_t around the loop.  (This\n+   does not extend their lifetime beyond that of the ctf_archive_t in which they\n+   are contained.)  */\n \n void\n-ctf_ref (ctf_file_t *fp)\n+ctf_ref (ctf_dict_t *fp)\n {\n   fp->ctf_refcnt++;\n }\n \n-/* Close the specified CTF container and free associated data structures.  Note\n-   that ctf_file_close() is a reference counted operation: if the specified file\n-   is the parent of other active containers, its reference count will be greater\n-   than one and it will be freed later when no active children exist.  */\n+/* Close the specified CTF dict and free associated data structures.  Note that\n+   ctf_dict_close() is a reference counted operation: if the specified file is\n+   the parent of other active dict, its reference count will be greater than one\n+   and it will be freed later when no active children exist.  */\n \n void\n-ctf_file_close (ctf_file_t *fp)\n+ctf_dict_close (ctf_dict_t *fp)\n {\n   ctf_dtdef_t *dtd, *ntd;\n   ctf_dvdef_t *dvd, *nvd;\n   ctf_err_warning_t *err, *nerr;\n \n   if (fp == NULL)\n-    return;\t\t   /* Allow ctf_file_close(NULL) to simplify caller code.  */\n+    return;\t\t   /* Allow ctf_dict_close(NULL) to simplify caller code.  */\n \n-  ctf_dprintf (\"ctf_file_close(%p) refcnt=%u\\n\", (void *) fp, fp->ctf_refcnt);\n+  ctf_dprintf (\"ctf_dict_close(%p) refcnt=%u\\n\", (void *) fp, fp->ctf_refcnt);\n \n   if (fp->ctf_refcnt > 1)\n     {\n@@ -1672,7 +1672,7 @@ ctf_file_close (ctf_file_t *fp)\n   free (fp->ctf_dyncuname);\n   free (fp->ctf_dynparname);\n   if (fp->ctf_parent && !fp->ctf_parent_unreffed)\n-    ctf_file_close (fp->ctf_parent);\n+    ctf_dict_close (fp->ctf_parent);\n \n   for (dtd = ctf_list_next (&fp->ctf_dtdefs); dtd != NULL; dtd = ntd)\n     {\n@@ -1743,6 +1743,13 @@ ctf_file_close (ctf_file_t *fp)\n   free (fp);\n }\n \n+/* Backward compatibility.  */\n+void\n+ctf_file_close (ctf_file_t *fp)\n+{\n+  ctf_dict_close (fp);\n+}\n+\n /* The converse of ctf_open().  ctf_open() disguises whatever it opens as an\n    archive, so closing one is just like closing an archive.  */\n void\n@@ -1751,44 +1758,50 @@ ctf_close (ctf_archive_t *arc)\n   ctf_arc_close (arc);\n }\n \n-/* Get the CTF archive from which this ctf_file_t is derived.  */\n+/* Get the CTF archive from which this ctf_dict_t is derived.  */\n ctf_archive_t *\n-ctf_get_arc (const ctf_file_t *fp)\n+ctf_get_arc (const ctf_dict_t *fp)\n {\n   return fp->ctf_archive;\n }\n \n /* Return the ctfsect out of the core ctf_impl.  Useful for freeing the\n-   ctfsect's data * after ctf_file_close(), which is why we return the actual\n+   ctfsect's data * after ctf_dict_close(), which is why we return the actual\n    structure, not a pointer to it, since that is likely to become a pointer to\n    freed data before the return value is used under the expected use case of\n-   ctf_getsect()/ ctf_file_close()/free().  */\n+   ctf_getsect()/ ctf_dict_close()/free().  */\n ctf_sect_t\n-ctf_getdatasect (const ctf_file_t *fp)\n+ctf_getdatasect (const ctf_dict_t *fp)\n {\n   return fp->ctf_data;\n }\n \n-/* Return the CTF handle for the parent CTF container, if one exists.\n-   Otherwise return NULL to indicate this container has no imported parent.  */\n-ctf_file_t *\n-ctf_parent_file (ctf_file_t *fp)\n+/* Return the CTF handle for the parent CTF dict, if one exists.  Otherwise\n+   return NULL to indicate this dict has no imported parent.  */\n+ctf_dict_t *\n+ctf_parent_dict (ctf_dict_t *fp)\n {\n   return fp->ctf_parent;\n }\n \n-/* Return the name of the parent CTF container, if one exists.  Otherwise\n-   return NULL to indicate this container is a root container.  */\n+/* Backward compatibility.  */\n+ctf_dict_t *\n+ctf_parent_file (ctf_dict_t *fp)\n+{\n+  return ctf_parent_dict (fp);\n+}\n+\n+/* Return the name of the parent CTF dict, if one exists, or NULL otherwise.  */\n const char *\n-ctf_parent_name (ctf_file_t *fp)\n+ctf_parent_name (ctf_dict_t *fp)\n {\n   return fp->ctf_parname;\n }\n \n /* Set the parent name.  It is an error to call this routine without calling\n    ctf_import() at some point.  */\n int\n-ctf_parent_name_set (ctf_file_t *fp, const char *name)\n+ctf_parent_name_set (ctf_dict_t *fp, const char *name)\n {\n   if (fp->ctf_dynparname != NULL)\n     free (fp->ctf_dynparname);\n@@ -1800,16 +1813,16 @@ ctf_parent_name_set (ctf_file_t *fp, const char *name)\n }\n \n /* Return the name of the compilation unit this CTF file applies to.  Usually\n-   non-NULL only for non-parent containers.  */\n+   non-NULL only for non-parent dicts.  */\n const char *\n-ctf_cuname (ctf_file_t *fp)\n+ctf_cuname (ctf_dict_t *fp)\n {\n   return fp->ctf_cuname;\n }\n \n /* Set the compilation unit name.  */\n int\n-ctf_cuname_set (ctf_file_t *fp, const char *name)\n+ctf_cuname_set (ctf_dict_t *fp, const char *name)\n {\n   if (fp->ctf_dyncuname != NULL)\n     free (fp->ctf_dyncuname);\n@@ -1820,11 +1833,11 @@ ctf_cuname_set (ctf_file_t *fp, const char *name)\n   return 0;\n }\n \n-/* Import the types from the specified parent container by storing a pointer\n-   to it in ctf_parent and incrementing its reference count.  Only one parent\n-   is allowed: if a parent already exists, it is replaced by the new parent.  */\n+/* Import the types from the specified parent dict by storing a pointer to it in\n+   ctf_parent and incrementing its reference count.  Only one parent is allowed:\n+   if a parent already exists, it is replaced by the new parent.  */\n int\n-ctf_import (ctf_file_t *fp, ctf_file_t *pfp)\n+ctf_import (ctf_dict_t *fp, ctf_dict_t *pfp)\n {\n   if (fp == NULL || fp == pfp || (pfp != NULL && pfp->ctf_refcnt == 0))\n     return (ctf_set_errno (fp, EINVAL));\n@@ -1833,7 +1846,7 @@ ctf_import (ctf_file_t *fp, ctf_file_t *pfp)\n     return (ctf_set_errno (fp, ECTF_DMODEL));\n \n   if (fp->ctf_parent && !fp->ctf_parent_unreffed)\n-    ctf_file_close (fp->ctf_parent);\n+    ctf_dict_close (fp->ctf_parent);\n   fp->ctf_parent = NULL;\n \n   if (pfp != NULL)\n@@ -1858,7 +1871,7 @@ ctf_import (ctf_file_t *fp, ctf_file_t *pfp)\n    caller must do all freeing itself.  Used internally to avoid refcount\n    loops.  */\n int\n-ctf_import_unref (ctf_file_t *fp, ctf_file_t *pfp)\n+ctf_import_unref (ctf_dict_t *fp, ctf_dict_t *pfp)\n {\n   if (fp == NULL || fp == pfp || (pfp != NULL && pfp->ctf_refcnt == 0))\n     return (ctf_set_errno (fp, EINVAL));\n@@ -1867,7 +1880,7 @@ ctf_import_unref (ctf_file_t *fp, ctf_file_t *pfp)\n     return (ctf_set_errno (fp, ECTF_DMODEL));\n \n   if (fp->ctf_parent && !fp->ctf_parent_unreffed)\n-    ctf_file_close (fp->ctf_parent);\n+    ctf_dict_close (fp->ctf_parent);\n   fp->ctf_parent = NULL;\n \n   if (pfp != NULL)\n@@ -1886,9 +1899,9 @@ ctf_import_unref (ctf_file_t *fp, ctf_file_t *pfp)\n   return 0;\n }\n \n-/* Set the data model constant for the CTF container.  */\n+/* Set the data model constant for the CTF dict.  */\n int\n-ctf_setmodel (ctf_file_t *fp, int model)\n+ctf_setmodel (ctf_dict_t *fp, int model)\n {\n   const ctf_dmodel_t *dp;\n \n@@ -1904,24 +1917,24 @@ ctf_setmodel (ctf_file_t *fp, int model)\n   return (ctf_set_errno (fp, EINVAL));\n }\n \n-/* Return the data model constant for the CTF container.  */\n+/* Return the data model constant for the CTF dict.  */\n int\n-ctf_getmodel (ctf_file_t *fp)\n+ctf_getmodel (ctf_dict_t *fp)\n {\n   return fp->ctf_dmodel->ctd_code;\n }\n \n-/* The caller can hang an arbitrary pointer off each ctf_file_t using this\n+/* The caller can hang an arbitrary pointer off each ctf_dict_t using this\n    function.  */\n void\n-ctf_setspecific (ctf_file_t *fp, void *data)\n+ctf_setspecific (ctf_dict_t *fp, void *data)\n {\n   fp->ctf_specific = data;\n }\n \n /* Retrieve the arbitrary pointer again.  */\n void *\n-ctf_getspecific (ctf_file_t *fp)\n+ctf_getspecific (ctf_dict_t *fp)\n {\n   return fp->ctf_specific;\n }"
    },
    {
      "sha": "701cc86a71c6489ea0b4b1bb9bbcef4e6d2584e4",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -23,7 +23,7 @@\n /* Convert an encoded CTF string name into a pointer to a C string, using an\n   explicit internal strtab rather than the fp-based one.  */\n const char *\n-ctf_strraw_explicit (ctf_file_t *fp, uint32_t name, ctf_strs_t *strtab)\n+ctf_strraw_explicit (ctf_dict_t *fp, uint32_t name, ctf_strs_t *strtab)\n {\n   ctf_strs_t *ctsp = &fp->ctf_str[CTF_NAME_STID (name)];\n \n@@ -58,15 +58,15 @@ ctf_strraw_explicit (ctf_file_t *fp, uint32_t name, ctf_strs_t *strtab)\n /* Convert an encoded CTF string name into a pointer to a C string by looking\n   up the appropriate string table buffer and then adding the offset.  */\n const char *\n-ctf_strraw (ctf_file_t *fp, uint32_t name)\n+ctf_strraw (ctf_dict_t *fp, uint32_t name)\n {\n   return ctf_strraw_explicit (fp, name, NULL);\n }\n \n /* Return a guaranteed-non-NULL pointer to the string with the given CTF\n    name.  */\n const char *\n-ctf_strptr (ctf_file_t *fp, uint32_t name)\n+ctf_strptr (ctf_dict_t *fp, uint32_t name)\n {\n   const char *s = ctf_strraw (fp, name);\n   return (s != NULL ? s : \"(?)\");\n@@ -99,7 +99,7 @@ ctf_str_free_atom (void *a)\n /* Create the atoms table.  There is always at least one atom in it, the null\n    string.  */\n int\n-ctf_str_create_atoms (ctf_file_t *fp)\n+ctf_str_create_atoms (ctf_dict_t *fp)\n {\n   fp->ctf_str_atoms = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n \t\t\t\t\t  free, ctf_str_free_atom);\n@@ -131,7 +131,7 @@ ctf_str_create_atoms (ctf_file_t *fp)\n \n /* Destroy the atoms table.  */\n void\n-ctf_str_free_atoms (ctf_file_t *fp)\n+ctf_str_free_atoms (ctf_dict_t *fp)\n {\n   ctf_dynhash_destroy (fp->ctf_prov_strtab);\n   ctf_dynhash_destroy (fp->ctf_str_atoms);\n@@ -143,7 +143,7 @@ ctf_str_free_atoms (ctf_file_t *fp)\n    passed-in ref.  Possibly add a provisional entry for this string to the\n    provisional strtab.   */\n static ctf_str_atom_t *\n-ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n+ctf_str_add_ref_internal (ctf_dict_t *fp, const char *str,\n \t\t\t  int add_ref, int make_provisional, uint32_t *ref)\n {\n   char *newstr = NULL;\n@@ -215,7 +215,7 @@ ctf_str_add_ref_internal (ctf_file_t *fp, const char *str,\n    provisional offset is assigned to should be added as a ref using\n    ctf_str_add_ref() as well.) */\n uint32_t\n-ctf_str_add (ctf_file_t *fp, const char *str)\n+ctf_str_add (ctf_dict_t *fp, const char *str)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n@@ -232,7 +232,7 @@ ctf_str_add (ctf_file_t *fp, const char *str)\n    passed-in ref, whether or not the string is already present.  There is no\n    attempt to deduplicate the refs list (but duplicates are harmless).  */\n uint32_t\n-ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n+ctf_str_add_ref (ctf_dict_t *fp, const char *str, uint32_t *ref)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n@@ -248,7 +248,7 @@ ctf_str_add_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n /* Add an external strtab reference at OFFSET.  Returns zero if the addition\n    failed, nonzero otherwise.  */\n int\n-ctf_str_add_external (ctf_file_t *fp, const char *str, uint32_t offset)\n+ctf_str_add_external (ctf_dict_t *fp, const char *str, uint32_t offset)\n {\n   ctf_str_atom_t *atom;\n   if (!str)\n@@ -264,7 +264,7 @@ ctf_str_add_external (ctf_file_t *fp, const char *str, uint32_t offset)\n \n /* Remove a single ref.  */\n void\n-ctf_str_remove_ref (ctf_file_t *fp, const char *str, uint32_t *ref)\n+ctf_str_remove_ref (ctf_dict_t *fp, const char *str, uint32_t *ref)\n {\n   ctf_str_atom_ref_t *aref, *anext;\n   ctf_str_atom_t *atom = NULL;\n@@ -297,7 +297,7 @@ ctf_str_rollback_atom (void *key _libctf_unused_, void *value, void *arg)\n \n /* Roll back, deleting all atoms created after a particular ID.  */\n void\n-ctf_str_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n+ctf_str_rollback (ctf_dict_t *fp, ctf_snapshot_id_t id)\n {\n   ctf_dynhash_iter_remove (fp->ctf_str_atoms, ctf_str_rollback_atom, &id);\n }\n@@ -313,7 +313,7 @@ ctf_str_purge_one_atom_refs (void *key _libctf_unused_, void *value,\n \n /* Remove all the recorded refs from the atoms table.  */\n void\n-ctf_str_purge_refs (ctf_file_t *fp)\n+ctf_str_purge_refs (ctf_dict_t *fp)\n {\n   if (fp->ctf_str_num_refs > 0)\n     ctf_dynhash_iter (fp->ctf_str_atoms, ctf_str_purge_one_atom_refs, NULL);\n@@ -410,7 +410,7 @@ ctf_str_sort_strtab (const void *a, const void *b)\n    external strtab offsets to names, so we can look them up with ctf_strptr().\n    Only external strtab offsets with references are added.  */\n ctf_strs_writable_t\n-ctf_str_write_strtab (ctf_file_t *fp)\n+ctf_str_write_strtab (ctf_dict_t *fp)\n {\n   ctf_strs_writable_t strtab;\n   ctf_str_atom_t *nullstr;\n@@ -472,7 +472,7 @@ ctf_str_write_strtab (ctf_file_t *fp)\n \t     This is safe because you cannot ctf_rollback to before the point\n \t     when a ctf_update is done, and the strtab is written at ctf_update\n \t     time.  So any atoms we reference here are sure to stick around\n-\t     until ctf_file_close.  */\n+\t     until ctf_dict_close.  */\n \n \t  any_external = 1;\n \t  ctf_str_update_refs (sorttab[i], sorttab[i]->csa_external_offset);"
    },
    {
      "sha": "c902494590c15693a48d64009605034e0f358b0e",
      "filename": "libctf/ctf-subr.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-subr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-subr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-subr.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -201,7 +201,7 @@ static ctf_list_t open_errors;\n    debug stream instead of that recorded on fp.  */\n _libctf_printflike_ (4, 5)\n extern void\n-ctf_err_warn (ctf_file_t *fp, int is_warning, int err,\n+ctf_err_warn (ctf_dict_t *fp, int is_warning, int err,\n \t      const char *format, ...)\n {\n   va_list alist;\n@@ -244,7 +244,7 @@ ctf_err_warn (ctf_file_t *fp, int is_warning, int err,\n \n /* Move all the errors/warnings from an fp into the open_errors.  */\n void\n-ctf_err_warn_to_open (ctf_file_t *fp)\n+ctf_err_warn_to_open (ctf_dict_t *fp)\n {\n   ctf_list_splice (&open_errors, &fp->ctf_errs_warnings);\n }\n@@ -266,7 +266,7 @@ ctf_err_warn_to_open (ctf_file_t *fp)\n    means the end, and not an iterator error.  */\n \n char *\n-ctf_errwarning_next (ctf_file_t *fp, ctf_next_t **it, int *is_warning,\n+ctf_errwarning_next (ctf_dict_t *fp, ctf_next_t **it, int *is_warning,\n \t\t     int *errp)\n {\n   ctf_next_t *i = *it;\n@@ -335,7 +335,7 @@ ctf_errwarning_next (ctf_file_t *fp, ctf_next_t **it, int *is_warning,\n }\n \n void\n-ctf_assert_fail_internal (ctf_file_t *fp, const char *file, size_t line,\n+ctf_assert_fail_internal (ctf_dict_t *fp, const char *file, size_t line,\n \t\t\t  const char *exprstr)\n {\n   ctf_err_warn (fp, 0, ECTF_INTERNAL, _(\"%s: %lu: libctf assertion failed: %s\"),"
    },
    {
      "sha": "60d1bef47729254094e96b999a0c0fbd5014f2e3",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 62,
      "deletions": 62,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -24,13 +24,13 @@\n /* Determine whether a type is a parent or a child.  */\n \n int\n-ctf_type_isparent (ctf_file_t *fp, ctf_id_t id)\n+ctf_type_isparent (ctf_dict_t *fp, ctf_id_t id)\n {\n   return (LCTF_TYPE_ISPARENT (fp, id));\n }\n \n int\n-ctf_type_ischild (ctf_file_t * fp, ctf_id_t id)\n+ctf_type_ischild (ctf_dict_t * fp, ctf_id_t id)\n {\n   return (LCTF_TYPE_ISCHILD (fp, id));\n }\n@@ -39,9 +39,9 @@ ctf_type_ischild (ctf_file_t * fp, ctf_id_t id)\n    type, and offset of each member to the specified callback function.  */\n \n int\n-ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n+ctf_member_iter (ctf_dict_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n@@ -109,10 +109,10 @@ ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n    returns -1.  */\n \n ssize_t\n-ctf_member_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n+ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n \t\t const char **name, ctf_id_t *membtype)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   uint32_t kind;\n   ssize_t offset;\n   ctf_next_t *i = *it;\n@@ -227,9 +227,9 @@ ctf_member_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n    integer value of each enum element to the specified callback function.  */\n \n int\n-ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n+ctf_enum_iter (ctf_dict_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n   ctf_dtdef_t *dtd;\n@@ -279,10 +279,10 @@ ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n    enumerand's integer VALue.  */\n \n const char *\n-ctf_enum_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n+ctf_enum_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n \t       int *val)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   uint32_t kind;\n   const char *name;\n   ctf_next_t *i = *it;\n@@ -388,15 +388,15 @@ ctf_enum_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n   return NULL;\n }\n \n-/* Iterate over every root (user-visible) type in the given CTF container.\n+/* Iterate over every root (user-visible) type in the given CTF dict.\n    We pass the type ID of each type to the specified callback function.\n \n    Does not traverse parent types: you have to do that explicitly.  This is by\n    design, to avoid traversing them more than once if traversing many children\n    of a single parent.  */\n \n int\n-ctf_type_iter (ctf_file_t *fp, ctf_type_f *func, void *arg)\n+ctf_type_iter (ctf_dict_t *fp, ctf_type_f *func, void *arg)\n {\n   ctf_id_t id, max = fp->ctf_typemax;\n   int rc, child = (fp->ctf_flags & LCTF_CHILD);\n@@ -412,15 +412,15 @@ ctf_type_iter (ctf_file_t *fp, ctf_type_f *func, void *arg)\n   return 0;\n }\n \n-/* Iterate over every type in the given CTF container, user-visible or not.\n+/* Iterate over every type in the given CTF dict, user-visible or not.\n    We pass the type ID of each type to the specified callback function.\n \n    Does not traverse parent types: you have to do that explicitly.  This is by\n    design, to avoid traversing them more than once if traversing many children\n    of a single parent.  */\n \n int\n-ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n+ctf_type_iter_all (ctf_dict_t *fp, ctf_type_all_f *func, void *arg)\n {\n   ctf_id_t id, max = fp->ctf_typemax;\n   int rc, child = (fp->ctf_flags & LCTF_CHILD);\n@@ -437,7 +437,7 @@ ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n   return 0;\n }\n \n-/* Iterate over every type in the given CTF container, optionally including\n+/* Iterate over every type in the given CTF dict, optionally including\n    non-user-visible types, returning each type ID and hidden flag in turn.\n    Returns CTF_ERR on end of iteration or error.\n \n@@ -446,7 +446,7 @@ ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n    of a single parent.  */\n \n ctf_id_t\n-ctf_type_next (ctf_file_t *fp, ctf_next_t **it, int *flag, int want_hidden)\n+ctf_type_next (ctf_dict_t *fp, ctf_next_t **it, int *flag, int want_hidden)\n {\n   ctf_next_t *i = *it;\n \n@@ -486,11 +486,11 @@ ctf_type_next (ctf_file_t *fp, ctf_next_t **it, int *flag, int want_hidden)\n   return ctf_set_errno (fp, ECTF_NEXT_END);\n }\n \n-/* Iterate over every variable in the given CTF container, in arbitrary order.\n+/* Iterate over every variable in the given CTF dict, in arbitrary order.\n    We pass the name of each variable to the specified callback function.  */\n \n int\n-ctf_variable_iter (ctf_file_t *fp, ctf_variable_f *func, void *arg)\n+ctf_variable_iter (ctf_dict_t *fp, ctf_variable_f *func, void *arg)\n {\n   int rc;\n \n@@ -520,12 +520,12 @@ ctf_variable_iter (ctf_file_t *fp, ctf_variable_f *func, void *arg)\n   return 0;\n }\n \n-/* Iterate over every variable in the given CTF container, in arbitrary order,\n+/* Iterate over every variable in the given CTF dict, in arbitrary order,\n    returning the name and type of each variable in turn.  The name argument is\n    not optional.  Returns CTF_ERR on end of iteration or error.  */\n \n ctf_id_t\n-ctf_variable_next (ctf_file_t *fp, ctf_next_t **it, const char **name)\n+ctf_variable_next (ctf_dict_t *fp, ctf_next_t **it, const char **name)\n {\n   ctf_next_t *i = *it;\n \n@@ -586,10 +586,10 @@ ctf_variable_next (ctf_file_t *fp, ctf_next_t **it, const char **name)\n    Does not drill down through slices to their contained type.  */\n \n ctf_id_t\n-ctf_type_resolve (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_resolve (ctf_dict_t *fp, ctf_id_t type)\n {\n   ctf_id_t prev = type, otype = type;\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n \n   if (type == 0)\n@@ -627,7 +627,7 @@ ctf_type_resolve (ctf_file_t *fp, ctf_id_t type)\n    type.  */\n \n ctf_id_t\n-ctf_type_resolve_unsliced (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_resolve_unsliced (ctf_dict_t *fp, ctf_id_t type)\n {\n   const ctf_type_t *tp;\n \n@@ -645,7 +645,7 @@ ctf_type_resolve_unsliced (ctf_file_t *fp, ctf_id_t type)\n /* Look up a name in the given name table, in the appropriate hash given the\n    kind of the identifier.  The name is a raw, undecorated identifier.  */\n \n-ctf_id_t ctf_lookup_by_rawname (ctf_file_t *fp, int kind, const char *name)\n+ctf_id_t ctf_lookup_by_rawname (ctf_dict_t *fp, int kind, const char *name)\n {\n   return ctf_lookup_by_rawhash (fp, ctf_name_table (fp, kind), name);\n }\n@@ -654,7 +654,7 @@ ctf_id_t ctf_lookup_by_rawname (ctf_file_t *fp, int kind, const char *name)\n    readability state of the dictionary.  The name is a raw, undecorated\n    identifier.  */\n \n-ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *fp, ctf_names_t *np, const char *name)\n+ctf_id_t ctf_lookup_by_rawhash (ctf_dict_t *fp, ctf_names_t *np, const char *name)\n {\n   ctf_id_t id;\n \n@@ -669,7 +669,7 @@ ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *fp, ctf_names_t *np, const char *nam\n    string.  */\n \n char *\n-ctf_type_aname (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_aname (ctf_dict_t *fp, ctf_id_t type)\n {\n   ctf_decl_t cd;\n   ctf_decl_node_t *cdp;\n@@ -710,7 +710,7 @@ ctf_type_aname (ctf_file_t *fp, ctf_id_t type)\n       for (cdp = ctf_list_next (&cd.cd_nodes[prec]);\n \t   cdp != NULL; cdp = ctf_list_next (cdp))\n \t{\n-\t  ctf_file_t *rfp = fp;\n+\t  ctf_dict_t *rfp = fp;\n \t  const ctf_type_t *tp = ctf_lookup_by_id (&rfp, cdp->cd_type);\n \t  const char *name = ctf_strptr (rfp, tp->ctt_name);\n \n@@ -837,7 +837,7 @@ ctf_type_aname (ctf_file_t *fp, ctf_id_t type)\n    the actual number of bytes (not including \\0) needed to format the name.  */\n \n ssize_t\n-ctf_type_lname (ctf_file_t *fp, ctf_id_t type, char *buf, size_t len)\n+ctf_type_lname (ctf_dict_t *fp, ctf_id_t type, char *buf, size_t len)\n {\n   char *str = ctf_type_aname (fp, type);\n   size_t slen;\n@@ -859,17 +859,17 @@ ctf_type_lname (ctf_file_t *fp, ctf_id_t type, char *buf, size_t len)\n    is too small, return NULL: the ECTF_NAMELEN error is set on 'fp' for us.  */\n \n char *\n-ctf_type_name (ctf_file_t *fp, ctf_id_t type, char *buf, size_t len)\n+ctf_type_name (ctf_dict_t *fp, ctf_id_t type, char *buf, size_t len)\n {\n   ssize_t rv = ctf_type_lname (fp, type, buf, len);\n   return (rv >= 0 && (size_t) rv < len ? buf : NULL);\n }\n \n /* Lookup the given type ID and return its raw, unadorned, undecorated name.\n-   The name will live as long as its ctf_file_t does.  */\n+   The name will live as long as its ctf_dict_t does.  */\n \n const char *\n-ctf_type_name_raw (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_name_raw (ctf_dict_t *fp, ctf_id_t type)\n {\n   const ctf_type_t *tp;\n \n@@ -883,7 +883,7 @@ ctf_type_name_raw (ctf_file_t *fp, ctf_id_t type)\n    new dynamically-allocated string.  */\n \n char *\n-ctf_type_aname_raw (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_aname_raw (ctf_dict_t *fp, ctf_id_t type)\n {\n   const char *name = ctf_type_name_raw (fp, type);\n \n@@ -897,7 +897,7 @@ ctf_type_aname_raw (ctf_file_t *fp, ctf_id_t type)\n    of the type storage in bytes.  */\n \n ssize_t\n-ctf_type_size (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_size (ctf_dict_t *fp, ctf_id_t type)\n {\n   const ctf_type_t *tp;\n   ssize_t size;\n@@ -947,10 +947,10 @@ ctf_type_size (ctf_file_t *fp, ctf_id_t type)\n    XXX may need arch-dependent attention.  */\n \n ssize_t\n-ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_align (ctf_dict_t *fp, ctf_id_t type)\n {\n   const ctf_type_t *tp;\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   int kind;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n@@ -1039,7 +1039,7 @@ ctf_type_align (ctf_file_t *fp, ctf_id_t type)\n /* Return the kind (CTF_K_* constant) for the specified type ID.  */\n \n int\n-ctf_type_kind_unsliced (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_kind_unsliced (ctf_dict_t *fp, ctf_id_t type)\n {\n   const ctf_type_t *tp;\n \n@@ -1053,7 +1053,7 @@ ctf_type_kind_unsliced (ctf_file_t *fp, ctf_id_t type)\n    Slices are considered to be of the same kind as the type sliced.  */\n \n int\n-ctf_type_kind (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_kind (ctf_dict_t *fp, ctf_id_t type)\n {\n   int kind;\n \n@@ -1073,7 +1073,7 @@ ctf_type_kind (ctf_file_t *fp, ctf_id_t type)\n /* Return the kind of this type, except, for forwards, return the kind of thing\n    this is a forward to.  */\n int\n-ctf_type_kind_forwarded (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_kind_forwarded (ctf_dict_t *fp, ctf_id_t type)\n {\n   int kind;\n   const ctf_type_t *tp;\n@@ -1094,9 +1094,9 @@ ctf_type_kind_forwarded (ctf_file_t *fp, ctf_id_t type)\n    then return the ID of the type to which it refers.  */\n \n ctf_id_t\n-ctf_type_reference (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_reference (ctf_dict_t *fp, ctf_id_t type)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n \n   if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n@@ -1139,12 +1139,12 @@ ctf_type_reference (ctf_file_t *fp, ctf_id_t type)\n    instead.  This helps with cases where the CTF data includes \"struct foo *\"\n    but not \"foo_t *\" and the user accesses \"foo_t *\" in the debugger.\n \n-   XXX what about parent containers?  */\n+   XXX what about parent dicts?  */\n \n ctf_id_t\n-ctf_type_pointer (ctf_file_t *fp, ctf_id_t type)\n+ctf_type_pointer (ctf_dict_t *fp, ctf_id_t type)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   ctf_id_t ntype;\n \n   if (ctf_lookup_by_id (&fp, type) == NULL)\n@@ -1168,9 +1168,9 @@ ctf_type_pointer (ctf_file_t *fp, ctf_id_t type)\n /* Return the encoding for the specified INTEGER or FLOAT.  */\n \n int\n-ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n+ctf_type_encoding (ctf_dict_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   ctf_dtdef_t *dtd;\n   const ctf_type_t *tp;\n   ssize_t increment;\n@@ -1247,7 +1247,7 @@ ctf_type_encoding (ctf_file_t *fp, ctf_id_t type, ctf_encoding_t *ep)\n }\n \n int\n-ctf_type_cmp (ctf_file_t *lfp, ctf_id_t ltype, ctf_file_t *rfp,\n+ctf_type_cmp (ctf_dict_t *lfp, ctf_id_t ltype, ctf_dict_t *rfp,\n \t      ctf_id_t rtype)\n {\n   int rval;\n@@ -1284,8 +1284,8 @@ ctf_type_cmp (ctf_file_t *lfp, ctf_id_t ltype, ctf_file_t *rfp,\n    unions) member count.  */\n \n int\n-ctf_type_compat (ctf_file_t *lfp, ctf_id_t ltype,\n-\t\t ctf_file_t *rfp, ctf_id_t rtype)\n+ctf_type_compat (ctf_dict_t *lfp, ctf_id_t ltype,\n+\t\t ctf_dict_t *rfp, ctf_id_t rtype)\n {\n   const ctf_type_t *ltp, *rtp;\n   ctf_encoding_t le, re;\n@@ -1360,9 +1360,9 @@ ctf_type_compat (ctf_file_t *lfp, ctf_id_t ltype,\n    enumerators in an ENUM.  */\n \n int\n-ctf_member_count (ctf_file_t *fp, ctf_id_t type)\n+ctf_member_count (ctf_dict_t *fp, ctf_id_t type)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   uint32_t kind;\n \n@@ -1383,10 +1383,10 @@ ctf_member_count (ctf_file_t *fp, ctf_id_t type)\n /* Return the type and offset for a given member of a STRUCT or UNION.  */\n \n int\n-ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n+ctf_member_info (ctf_dict_t *fp, ctf_id_t type, const char *name,\n \t\t ctf_membinfo_t *mip)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   ctf_dtdef_t *dtd;\n   ssize_t size, increment;\n@@ -1459,9 +1459,9 @@ ctf_member_info (ctf_file_t *fp, ctf_id_t type, const char *name,\n /* Return the array type, index, and size information for the specified ARRAY.  */\n \n int\n-ctf_array_info (ctf_file_t *fp, ctf_id_t type, ctf_arinfo_t *arp)\n+ctf_array_info (ctf_dict_t *fp, ctf_id_t type, ctf_arinfo_t *arp)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_array_t *ap;\n   const ctf_dtdef_t *dtd;\n@@ -1493,9 +1493,9 @@ ctf_array_info (ctf_file_t *fp, ctf_id_t type, ctf_arinfo_t *arp)\n    matching name can be found.  Otherwise NULL is returned.  */\n \n const char *\n-ctf_enum_name (ctf_file_t *fp, ctf_id_t type, int value)\n+ctf_enum_name (ctf_dict_t *fp, ctf_id_t type, int value)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n   const ctf_dtdef_t *dtd;\n@@ -1546,9 +1546,9 @@ ctf_enum_name (ctf_file_t *fp, ctf_id_t type, int value)\n    matching name can be found.  Otherwise CTF_ERR is returned.  */\n \n int\n-ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n+ctf_enum_value (ctf_dict_t * fp, ctf_id_t type, const char *name, int *valp)\n {\n-  ctf_file_t *ofp = fp;\n+  ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   const ctf_enum_t *ep;\n   const ctf_dtdef_t *dtd;\n@@ -1607,7 +1607,7 @@ ctf_enum_value (ctf_file_t * fp, ctf_id_t type, const char *name, int *valp)\n    arg counts for that function.  */\n \n int\n-ctf_func_type_info (ctf_file_t *fp, ctf_id_t type, ctf_funcinfo_t *fip)\n+ctf_func_type_info (ctf_dict_t *fp, ctf_id_t type, ctf_funcinfo_t *fip)\n {\n   const ctf_type_t *tp;\n   uint32_t kind;\n@@ -1649,7 +1649,7 @@ ctf_func_type_info (ctf_file_t *fp, ctf_id_t type, ctf_funcinfo_t *fip)\n    function.  */\n \n int\n-ctf_func_type_args (ctf_file_t *fp, ctf_id_t type, uint32_t argc, ctf_id_t *argv)\n+ctf_func_type_args (ctf_dict_t *fp, ctf_id_t type, uint32_t argc, ctf_id_t *argv)\n {\n   const ctf_type_t *tp;\n   const uint32_t *args;\n@@ -1686,7 +1686,7 @@ ctf_func_type_args (ctf_file_t *fp, ctf_id_t type, uint32_t argc, ctf_id_t *argv\n    returns non-zero, we abort and percolate the error code back up to the top.  */\n \n static int\n-ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n+ctf_type_rvisit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func,\n \t\t void *arg, const char *name, unsigned long offset, int depth)\n {\n   ctf_id_t otype = type;\n@@ -1765,7 +1765,7 @@ ctf_type_rvisit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func,\n /* Recursively visit the members of any type.  We pass the name, member\n  type, and offset of each member to the specified callback function.  */\n int\n-ctf_type_visit (ctf_file_t *fp, ctf_id_t type, ctf_visit_f *func, void *arg)\n+ctf_type_visit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func, void *arg)\n {\n   return (ctf_type_rvisit (fp, type, func, arg, \"\", 0, 0));\n }"
    },
    {
      "sha": "c29f460b5b4985d7694f61af3946d75a28a2a158",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -162,7 +162,7 @@ ctf_str_append_noerr (char *s, const char *append)\n \n /* A realloc() that fails noisily if called with any ctf_str_num_users.  */\n void *\n-ctf_realloc (ctf_file_t *fp, void *ptr, size_t size)\n+ctf_realloc (ctf_dict_t *fp, void *ptr, size_t size)\n {\n   if (fp->ctf_str_num_refs > 0)\n     {\n@@ -184,11 +184,11 @@ ctf_set_open_errno (int *errp, int error)\n   return NULL;\n }\n \n-/* Store the specified error code into the CTF container, and then return\n-   CTF_ERR / -1 for the benefit of the caller. */\n+/* Store the specified error code into the CTF dict, and then return CTF_ERR /\n+   -1 for the benefit of the caller. */\n \n unsigned long\n-ctf_set_errno (ctf_file_t * fp, int err)\n+ctf_set_errno (ctf_dict_t *fp, int err)\n {\n   fp->ctf_errno = err;\n   return CTF_ERR;"
    },
    {
      "sha": "5f5dc57885de8850097e60a86cd6ceb6291fb55d",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/139633c307eb6f5746ea04f94a0b6382e51bccb9/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=139633c307eb6f5746ea04f94a0b6382e51bccb9",
      "patch": "@@ -174,3 +174,9 @@ LIBCTF_1.0 {\n     local:\n \t*;\n };\n+\n+LIBCTF_1.1 {\n+    global:\n+\tctf_dict_close;\n+\tctf_parent_dict;\n+} LIBCTF_1.0;"
    }
  ]
}