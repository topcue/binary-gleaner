{
  "sha": "2080266b77a21c07b5051055181e6ebcbdedcd8b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjA4MDI2NmI3N2EyMWMwN2I1MDUxMDU1MTgxZTZlYmNiZGVkY2Q4Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-08-07T16:26:45Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-08-07T16:26:46Z"
    },
    "message": "Wrap xfer_partial and enable_btrace for Ravenscar\n\nA gdb crash showed that the xfer_partial target method was not wrapped\nfor Ravenscar.  This caused remote.c to call\nremote::set_general_thread with a Ravenscar \"fake\" ptid, which showed\nup later as an event ptid.\n\nI went through all the target methods and looked to see which ones\ncould call set_general_thread or set_continue_thread (but not\nset_general_process, as I think Ravenscar targets aren't\nmulti-inferior).  This patch wraps the two that I found.\n\nxfer_partial requires special treatment, because it can be called\nrecursively via get_base_thread_from_ravenscar_task.  To avoid a\nrecursive call, this patch changes update_thread_list to record all\ntasks in the m_cpu_map, and changes get_thread_base_cpu to prefer this\nmap.  This avoids some memory reads.\n\nIt was unclear to me whether enable_btrace really makes sense for\nRavenscar; but at the same time it seemed harmless to add this patch.\n\ngdb/ChangeLog\n2020-08-07  Tom Tromey  <tromey@adacore.com>\n\n\t* ravenscar-thread.c (xfer_partial, enable_btrace, add_thread):\n\tNew methods.\n\t(ravenscar_thread_target::get_thread_base_cpu): Check m_cpu_map\n\tfirst.\n\t(ravenscar_thread_target::add_thread): Rename from\n\travenscar_add_thread.\n\t(ravenscar_thread_target::update_thread_list): Use a lambda.\n\t(ravenscar_thread_target::xfer_partial): New method.",
    "tree": {
      "sha": "2f98eae61e8e5895106673a4963aa557a2caae63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2f98eae61e8e5895106673a4963aa557a2caae63"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2080266b77a21c07b5051055181e6ebcbdedcd8b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2080266b77a21c07b5051055181e6ebcbdedcd8b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2080266b77a21c07b5051055181e6ebcbdedcd8b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2080266b77a21c07b5051055181e6ebcbdedcd8b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "78c02f21ad122c2c775cb6629bb20829b2cafa01",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78c02f21ad122c2c775cb6629bb20829b2cafa01",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/78c02f21ad122c2c775cb6629bb20829b2cafa01"
    }
  ],
  "stats": {
    "total": 75,
    "additions": 65,
    "deletions": 10
  },
  "files": [
    {
      "sha": "e67b386b418881afa9afb8b27e36491b73f06571",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2080266b77a21c07b5051055181e6ebcbdedcd8b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2080266b77a21c07b5051055181e6ebcbdedcd8b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2080266b77a21c07b5051055181e6ebcbdedcd8b",
      "patch": "@@ -1,3 +1,14 @@\n+2020-08-07  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ravenscar-thread.c (xfer_partial, enable_btrace, add_thread):\n+\tNew methods.\n+\t(ravenscar_thread_target::get_thread_base_cpu): Check m_cpu_map\n+\tfirst.\n+\t(ravenscar_thread_target::add_thread): Rename from\n+\travenscar_add_thread.\n+\t(ravenscar_thread_target::update_thread_list): Use a lambda.\n+\t(ravenscar_thread_target::xfer_partial): New method.\n+\n 2020-08-07  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.h (ada_task_list_iterator_ftype): Now a"
    },
    {
      "sha": "a67a5e9a368d1e6effbf9efd5b4d072392e65335",
      "filename": "gdb/ravenscar-thread.c",
      "status": "modified",
      "additions": 54,
      "deletions": 10,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2080266b77a21c07b5051055181e6ebcbdedcd8b/gdb/ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2080266b77a21c07b5051055181e6ebcbdedcd8b/gdb/ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ravenscar-thread.c?ref=2080266b77a21c07b5051055181e6ebcbdedcd8b",
      "patch": "@@ -103,6 +103,13 @@ struct ravenscar_thread_target final : public target_ops\n \n   bool stopped_data_address (CORE_ADDR *) override;\n \n+  enum target_xfer_status xfer_partial (enum target_object object,\n+\t\t\t\t\tconst char *annex,\n+\t\t\t\t\tgdb_byte *readbuf,\n+\t\t\t\t\tconst gdb_byte *writebuf,\n+\t\t\t\t\tULONGEST offset, ULONGEST len,\n+\t\t\t\t\tULONGEST *xfered_len) override;\n+\n   bool thread_alive (ptid_t ptid) override;\n \n   int core_of_thread (ptid_t ptid) override;\n@@ -113,6 +120,14 @@ struct ravenscar_thread_target final : public target_ops\n \n   ptid_t get_ada_task_ptid (long lwp, long thread) override;\n \n+  struct btrace_target_info *enable_btrace (ptid_t ptid,\n+\t\t\t\t\t    const struct btrace_config *conf)\n+    override\n+  {\n+    ptid = get_base_thread_from_ravenscar_task (ptid);\n+    return beneath ()->enable_btrace (ptid, conf);\n+  }\n+\n   void mourn_inferior () override;\n \n   void close () override\n@@ -134,6 +149,7 @@ struct ravenscar_thread_target final : public target_ops\n   bool runtime_initialized ();\n   int get_thread_base_cpu (ptid_t ptid);\n   ptid_t get_base_thread_from_ravenscar_task (ptid_t ptid);\n+  void add_thread (struct ada_task_info *task);\n \n   /* This maps a TID to the CPU on which it was running.  This is\n      needed because sometimes the runtime will report an active task\n@@ -170,16 +186,18 @@ ravenscar_thread_target::get_thread_base_cpu (ptid_t ptid)\n \n   if (is_ravenscar_task (ptid))\n     {\n-      struct ada_task_info *task_info = ada_get_task_info_from_ptid (ptid);\n+      /* Prefer to not read inferior memory if possible, to avoid\n+\t reentrancy problems with xfer_partial.  */\n+      auto iter = m_cpu_map.find (ptid.tid ());\n \n-      if (task_info != NULL)\n-\tbase_cpu = task_info->base_cpu;\n+      if (iter != m_cpu_map.end ())\n+\tbase_cpu = iter->second;\n       else\n \t{\n-\t  auto iter = m_cpu_map.find (ptid.tid ());\n+\t  struct ada_task_info *task_info = ada_get_task_info_from_ptid (ptid);\n \n-\t  gdb_assert (iter != m_cpu_map.end ());\n-\t  base_cpu = iter->second;\n+\t  gdb_assert (task_info != NULL);\n+\t  base_cpu = task_info->base_cpu;\n \t}\n     }\n   else\n@@ -383,11 +401,14 @@ ravenscar_thread_target::wait (ptid_t ptid,\n /* Add the thread associated to the given TASK to the thread list\n    (if the thread has already been added, this is a no-op).  */\n \n-static void\n-ravenscar_add_thread (struct ada_task_info *task)\n+void\n+ravenscar_thread_target::add_thread (struct ada_task_info *task)\n {\n   if (find_thread_ptid (current_inferior (), task->ptid) == NULL)\n-    add_thread (current_inferior ()->process_target (), task->ptid);\n+    {\n+      ::add_thread (current_inferior ()->process_target (), task->ptid);\n+      m_cpu_map[task->ptid.tid ()] = task->base_cpu;\n+    }\n }\n \n void\n@@ -398,7 +419,10 @@ ravenscar_thread_target::update_thread_list ()\n      (m_base_ptid) and the running thread, that may not have been included\n      to system.tasking.debug's list yet.  */\n \n-  iterate_over_live_ada_tasks (ravenscar_add_thread);\n+  iterate_over_live_ada_tasks ([=] (struct ada_task_info *task)\n+\t\t\t       {\n+\t\t\t\t this->add_thread (task);\n+\t\t\t       });\n }\n \n ptid_t\n@@ -541,6 +565,26 @@ ravenscar_thread_target::core_of_thread (ptid_t ptid)\n   return beneath ()->core_of_thread (inferior_ptid);\n }\n \n+/* Implement the target xfer_partial method.  */\n+\n+enum target_xfer_status\n+ravenscar_thread_target::xfer_partial (enum target_object object,\n+\t\t\t\t       const char *annex,\n+\t\t\t\t       gdb_byte *readbuf,\n+\t\t\t\t       const gdb_byte *writebuf,\n+\t\t\t\t       ULONGEST offset, ULONGEST len,\n+\t\t\t\t       ULONGEST *xfered_len)\n+{\n+  scoped_restore save_ptid = make_scoped_restore (&inferior_ptid);\n+  /* Calling get_base_thread_from_ravenscar_task can read memory from\n+     the inferior.  However, that function is written to prefer our\n+     internal map, so it should not result in recursive calls in\n+     practice.  */\n+  inferior_ptid = get_base_thread_from_ravenscar_task (inferior_ptid);\n+  return beneath ()->xfer_partial (object, annex, readbuf, writebuf,\n+\t\t\t\t   offset, len, xfered_len);\n+}\n+\n /* Observer on inferior_created: push ravenscar thread stratum if needed.  */\n \n static void"
    }
  ]
}