{
  "sha": "6b915f7d0caf868c037c387aa4feef0c7085cb48",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmI5MTVmN2QwY2FmODY4YzAzN2MzODdhYTRmZWVmMGM3MDg1Y2I0OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-07-23T23:37:48Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-09-20T19:49:07Z"
    },
    "message": "Simplify TUI disassembly\n\nThis simplifies TUI disassembly somewhat, by removing manual memory\nmanagement.\n\ngdb/ChangeLog\n2019-09-20  Tom Tromey  <tom@tromey.com>\n\n\t* tui/tui-disasm.c (struct tui_asm_line) <addr_string, insn>: Now\n\tstd::string.\n\t(tui_disassemble): Add \"pos\" parameter.\n\t(tui_disasm_window::set_contents): Simplify.",
    "tree": {
      "sha": "23bf1c3b8cc11dbf4b94e7f25d1fe2da4e76b417",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/23bf1c3b8cc11dbf4b94e7f25d1fe2da4e76b417"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6b915f7d0caf868c037c387aa4feef0c7085cb48",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6b915f7d0caf868c037c387aa4feef0c7085cb48",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6b915f7d0caf868c037c387aa4feef0c7085cb48",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6b915f7d0caf868c037c387aa4feef0c7085cb48/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2ad52f6fb3daecd928605384fcaa45ad43178b4e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2ad52f6fb3daecd928605384fcaa45ad43178b4e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2ad52f6fb3daecd928605384fcaa45ad43178b4e"
    }
  ],
  "stats": {
    "total": 78,
    "additions": 33,
    "deletions": 45
  },
  "files": [
    {
      "sha": "00d97c6602a4a7bf4d102a6ed21397bf9d19740f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6b915f7d0caf868c037c387aa4feef0c7085cb48/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6b915f7d0caf868c037c387aa4feef0c7085cb48/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6b915f7d0caf868c037c387aa4feef0c7085cb48",
      "patch": "@@ -1,3 +1,10 @@\n+2019-09-20  Tom Tromey  <tom@tromey.com>\n+\n+\t* tui/tui-disasm.c (struct tui_asm_line) <addr_string, insn>: Now\n+\tstd::string.\n+\t(tui_disassemble): Add \"pos\" parameter.\n+\t(tui_disasm_window::set_contents): Simplify.\n+\n 2019-09-20  Tom Tromey  <tom@tromey.com>\n \n \t* tui/tui-winsource.h (struct tui_source_window_base)"
    },
    {
      "sha": "53ea061afb616e0a35d1f167c35c9b9d807a7275",
      "filename": "gdb/tui/tui-disasm.c",
      "status": "modified",
      "additions": 26,
      "deletions": 45,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6b915f7d0caf868c037c387aa4feef0c7085cb48/gdb/tui/tui-disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6b915f7d0caf868c037c387aa4feef0c7085cb48/gdb/tui/tui-disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-disasm.c?ref=6b915f7d0caf868c037c387aa4feef0c7085cb48",
      "patch": "@@ -44,34 +44,32 @@\n struct tui_asm_line \n {\n   CORE_ADDR addr;\n-  char *addr_string;\n-  char *insn;\n+  std::string addr_string;\n+  std::string insn;\n };\n \n /* Function to set the disassembly window's content.\n    Disassemble count lines starting at pc.\n    Return address of the count'th instruction after pc.  */\n static CORE_ADDR\n-tui_disassemble (struct gdbarch *gdbarch, struct tui_asm_line *asm_lines,\n-\t\t CORE_ADDR pc, int count)\n+tui_disassemble (struct gdbarch *gdbarch,\n+\t\t std::vector<tui_asm_line> &asm_lines,\n+\t\t CORE_ADDR pc, int pos, int count)\n {\n   string_file gdb_dis_out;\n \n   /* Now construct each line.  */\n-  for (; count > 0; count--, asm_lines++)\n+  for (int i = 0; i < count; ++i)\n     {\n-      xfree (asm_lines->addr_string);\n-      xfree (asm_lines->insn);\n-      \n       print_address (gdbarch, pc, &gdb_dis_out);\n-      asm_lines->addr = pc;\n-      asm_lines->addr_string = xstrdup (gdb_dis_out.c_str ());\n+      asm_lines[pos + i].addr = pc;\n+      asm_lines[pos + i].addr_string = std::move (gdb_dis_out.string ());\n \n       gdb_dis_out.clear ();\n \n       pc = pc + gdb_print_insn (gdbarch, pc, &gdb_dis_out, NULL);\n \n-      asm_lines->insn = xstrdup (gdb_dis_out.c_str ());\n+      asm_lines[pos + i].insn = std::move (gdb_dis_out.string ());\n \n       /* Reset the buffer to empty.  */\n       gdb_dis_out.clear ();\n@@ -87,20 +85,17 @@ tui_find_disassembly_address (struct gdbarch *gdbarch, CORE_ADDR pc, int from)\n {\n   CORE_ADDR new_low;\n   int max_lines;\n-  int i;\n-  struct tui_asm_line *asm_lines;\n \n   max_lines = (from > 0) ? from : - from;\n   if (max_lines <= 1)\n-     return pc;\n+    return pc;\n \n-  asm_lines = XALLOCAVEC (struct tui_asm_line, max_lines);\n-  memset (asm_lines, 0, sizeof (struct tui_asm_line) * max_lines);\n+  std::vector<tui_asm_line> asm_lines (max_lines);\n \n   new_low = pc;\n   if (from > 0)\n     {\n-      tui_disassemble (gdbarch, asm_lines, pc, max_lines);\n+      tui_disassemble (gdbarch, asm_lines, pc, 0, max_lines);\n       new_low = asm_lines[max_lines - 1].addr;\n     }\n   else\n@@ -122,7 +117,7 @@ tui_find_disassembly_address (struct gdbarch *gdbarch, CORE_ADDR pc, int from)\n          else\n             new_low += 1 * max_lines;\n \n-         tui_disassemble (gdbarch, asm_lines, new_low, max_lines);\n+         tui_disassemble (gdbarch, asm_lines, new_low, 0, max_lines);\n          last_addr = asm_lines[pos].addr;\n       } while (last_addr > pc && msymbol.minsym);\n \n@@ -139,8 +134,8 @@ tui_find_disassembly_address (struct gdbarch *gdbarch, CORE_ADDR pc, int from)\n             if (pos >= max_lines)\n               pos = 0;\n \n-            next_addr = tui_disassemble (gdbarch, &asm_lines[pos],\n-\t\t\t\t\t last_addr, 1);\n+            next_addr = tui_disassemble (gdbarch, asm_lines,\n+\t\t\t\t\t last_addr, pos, 1);\n \n             /* If there are some problems while disassembling exit.  */\n             if (next_addr <= last_addr)\n@@ -152,11 +147,6 @@ tui_find_disassembly_address (struct gdbarch *gdbarch, CORE_ADDR pc, int from)\n          pos = 0;\n       new_low = asm_lines[pos].addr;\n     }\n-  for (i = 0; i < max_lines; i++)\n-    {\n-      xfree (asm_lines[i].addr_string);\n-      xfree (asm_lines[i].insn);\n-    }\n   return new_low;\n }\n \n@@ -172,10 +162,8 @@ tui_disasm_window::set_contents (struct gdbarch *arch,\n   CORE_ADDR cur_pc;\n   struct tui_locator_window *locator = tui_locator_win_info_ptr ();\n   int tab_len = tui_tab_width;\n-  struct tui_asm_line *asm_lines;\n   int insn_pos;\n   int addr_size, insn_size;\n-  char *line;\n   \n   gdb_assert (line_or_addr.loa == LOA_ADDRESS);\n   CORE_ADDR pc = line_or_addr.u.addr;\n@@ -192,56 +180,49 @@ tui_disasm_window::set_contents (struct gdbarch *arch,\n   line_width = width - TUI_EXECINFO_SIZE - 2;\n \n   /* Get temporary table that will hold all strings (addr & insn).  */\n-  asm_lines = XALLOCAVEC (struct tui_asm_line, max_lines);\n-  memset (asm_lines, 0, sizeof (struct tui_asm_line) * max_lines);\n+  std::vector<tui_asm_line> asm_lines (max_lines);\n \n-  tui_disassemble (gdbarch, asm_lines, pc, max_lines);\n+  tui_disassemble (gdbarch, asm_lines, pc, 0, max_lines);\n \n   /* Determine maximum address- and instruction lengths.  */\n   addr_size = 0;\n   insn_size = 0;\n   for (i = 0; i < max_lines; i++)\n     {\n-      size_t len = strlen (asm_lines[i].addr_string);\n+      size_t len = asm_lines[i].addr_string.size ();\n \n       if (len > addr_size)\n         addr_size = len;\n \n-      len = strlen (asm_lines[i].insn);\n+      len = asm_lines[i].insn.size ();\n       if (len > insn_size)\n \tinsn_size = len;\n     }\n \n   /* Align instructions to the same column.  */\n   insn_pos = (1 + (addr_size / tab_len)) * tab_len;\n \n-  /* Allocate memory to create each line.  */\n-  line = (char*) alloca (insn_pos + insn_size + 1);\n-\n   /* Now construct each line.  */\n   content.resize (max_lines);\n   for (i = 0; i < max_lines; i++)\n     {\n-      int cur_len;\n-\n       tui_source_element *src = &content[i];\n-      strcpy (line, asm_lines[i].addr_string);\n-      cur_len = strlen (line);\n-      memset (line + cur_len, ' ', insn_pos - cur_len);\n-      strcpy (line + insn_pos, asm_lines[i].insn);\n+\n+      std::string line\n+\t= (asm_lines[i].addr_string\n+\t   + n_spaces (insn_pos\n+\t\t       - asm_lines[i].addr_string.size ())\n+\t   + asm_lines[i].insn);\n \n       /* Now copy the line taking the offset into account.  */\n-      if (strlen (line) > offset)\n+      if (line.size() > offset)\n \tsrc->line.reset (xstrndup (&line[offset], line_width));\n       else\n \tsrc->line.reset (xstrdup (\"\"));\n \n       src->line_or_addr.loa = LOA_ADDRESS;\n       src->line_or_addr.u.addr = asm_lines[i].addr;\n       src->is_exec_point = asm_lines[i].addr == cur_pc;\n-\n-      xfree (asm_lines[i].addr_string);\n-      xfree (asm_lines[i].insn);\n     }\n   return TUI_SUCCESS;\n }"
    }
  ]
}