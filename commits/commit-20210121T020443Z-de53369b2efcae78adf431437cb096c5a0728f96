{
  "sha": "de53369b2efcae78adf431437cb096c5a0728f96",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGU1MzM2OWIyZWZjYWU3OGFkZjQzMTQzN2NiMDk2YzVhMDcyOGY5Ng==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-21T02:04:43Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-21T02:04:43Z"
    },
    "message": "gdb/dwarf: add assertion in maybe_queue_comp_unit\n\nThe symptom that leads to this is the crash described in PR 26828:\n\n/home/simark/src/binutils-gdb/gdb/dwarf2/read.c:23478:25: runtime error: member access within null pointer of type 'struct dwarf2_cu'\n\nThe line of the crash is the following, in follow_die_offset:\n\n  if (target_cu != cu)\n    target_cu->ancestor = cu;  <--- HERE\n\nThe line that assign nullptr to `target_cu` is the `per_objfile->get_cu`\ncall after having called maybe_queue_comp_unit:\n\n      /* If necessary, add it to the queue and load its DIEs.  */\n      if (maybe_queue_comp_unit (cu, per_cu, per_objfile, cu->language))\n\tload_full_comp_unit (per_cu, per_objfile, per_objfile->get_cu (per_cu),\n\t\t\t     false, cu->language);\n\n      target_cu = per_objfile->get_cu (per_cu);  <--- HERE\n\nSome background: there is an invariant, documented in\nmaybe_queue_comp_unit's doc, that if a CU is queued for expansion\n(present in dwarf2_per_bfd::queue), then its DIEs are loaded in memory.\n\"its DIEs are loaded in memory\" is a synonym for saying that a dwarf2_cu\nobject exists for this CU.  Yet another way to say it is that\n`per_objfile->get_cu (per_cu)` returns something not nullptr for that\nCU.\n\nThe crash documented in PR 26828 triggers some hard-to-reproduce\nsequence that ends up violating the invariant:\n\n- dwarf2_fetch_die_type_sect_off gets called for a DIE in CU A\n- The DIE in CU A requires some DIE in CU B\n- follow_die_offset calls maybe_queue_comp_unit.  maybe_queue_comp_unit\n  sees CU B is not queued and its DIEs are not loaded, so it enqueues it\n  and returns 1 to its caller - meaning \"the DIEs are not loaded, you\n  should load them\" - prompting follow_die_offset to load the DIEs by\n  calling load_full_comp_unit\n- Note that CU B is enqueued by maybe_queue_comp_unit even if it has\n  already been expanded.  It's a bit useless (and causes trouble, see\n  next patch), but that's how it works right now.\n- Since we entered the dwarf2/read code through\n  dwarf2_fetch_die_type_sect_off, nothing processes the queue, so we\n  exit the dwarf2/read code with CU B still lingering in the queue.\n\n- dwarf2_fetch_die_type_sect_off gets called for a DIE in CU A, again\n- The DIE in CU A requires some DIE in CU B, again\n- This time, maybe_queue_comp_unit sees that CU B is in the queue.\n  Because of the invariant that if a CU is in the queue, its DIEs are\n  loaded in the memory, it returns 0 to its caller, meaning \"you don't\n  need to load the DIEs!\".\n- That happens to be true, so everything is fine for now.\n\n- Time passes, some things call dwarf2_per_objfile::age_comp_units\n  enough so that CU B's age becomes past the dwarf_max_cache_age\n  threshold.  age_comp_units proceeds to free CU B's DIEs.  Remember\n  that CU B is still lingering in the queue (oops, the invariant just\n  got violated).\n\n- dwarf2_fetch_die_type_sect_off gets called for a DIE in CU A, again\n- The DIE in CU A requires some DIE in CU B, again\n- maybe_queue_comp_unit sees that CU B is in the queue, so returns to\n  its caller \"you don't need to load the DIEs!\".  However, we know at\n  this point this is false.\n- follow_die_offset doesn't load the DIEs and tries to obtain the DIEs for\n  CU B:\n\n    target_cu = per_objfile->get_cu (per_cu);\n\n  But since they are not loaded, target_cu is nullptr, and we get the\n  crash mentioned above a few lines after that.\n\nThis patch adds an assertions in maybe_queue_comp_unit to verify the\ninvariant, to make sure it doesn't return a falsehood to its caller.\n\nThe current patch doesn't fix the issue (the next patch does), but it\nmakes it so we catch the problem earlier and get this assertion failure\ninstead of a segmentation fault:\n\n    /home/simark/src/binutils-gdb/gdb/dwarf2/read.c:9100: internal-error:\n        int maybe_queue_comp_unit(dwarf2_cu*, dwarf2_per_cu_data*, dwarf2_per_objfile*, language):\n        Assertion `per_objfile->get_cu (per_cu) != nullptr' failed.\n\ngdb/ChangeLog:\n\n\tPR gdb/26828\n\t* dwarf2/read.c (maybe_queue_comp_unit): Add assertion.\n\nChange-Id: I4e51bd7bd58773f9fadf480179cbc4bae61508fe",
    "tree": {
      "sha": "cf7f94a88e28249da966dcb60a2b7097155e1bf2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cf7f94a88e28249da966dcb60a2b7097155e1bf2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/de53369b2efcae78adf431437cb096c5a0728f96",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de53369b2efcae78adf431437cb096c5a0728f96",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/de53369b2efcae78adf431437cb096c5a0728f96",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de53369b2efcae78adf431437cb096c5a0728f96/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "17e593e9668c000f2bfa88d11a8957dfc52297dd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/17e593e9668c000f2bfa88d11a8957dfc52297dd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/17e593e9668c000f2bfa88d11a8957dfc52297dd"
    }
  ],
  "stats": {
    "total": 12,
    "additions": 11,
    "deletions": 1
  },
  "files": [
    {
      "sha": "ed01ed727f7aa2956b48035dc8d45cab369bac6f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de53369b2efcae78adf431437cb096c5a0728f96/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de53369b2efcae78adf431437cb096c5a0728f96/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=de53369b2efcae78adf431437cb096c5a0728f96",
      "patch": "@@ -1,3 +1,8 @@\n+2021-01-20  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\tPR gdb/26828\n+\t* dwarf2/read.c (maybe_queue_comp_unit): Add assertion.\n+\n 2021-01-20  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.c (follow_die_offset): Add logging."
    },
    {
      "sha": "309ff8331e720b1796a51f558ea0ccb0d16b89d6",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de53369b2efcae78adf431437cb096c5a0728f96/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de53369b2efcae78adf431437cb096c5a0728f96/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=de53369b2efcae78adf431437cb096c5a0728f96",
      "patch": "@@ -9179,7 +9179,12 @@ maybe_queue_comp_unit (struct dwarf2_cu *dependent_cu,\n \n   /* If it's already on the queue, we have nothing to do.  */\n   if (per_cu->queued)\n-    return 0;\n+    {\n+      /* Verify the invariant that if a CU is queued for expansion, its DIEs are\n+\t loaded.  */\n+      gdb_assert (per_objfile->get_cu (per_cu) != nullptr);\n+      return 0;\n+    }\n \n   /* If the compilation unit is already loaded, just mark it as\n      used.  */"
    }
  ]
}