{
  "sha": "d08cbc5d3203118da5583296e49273cf82378042",
  "node_id": "C_kwDOANOeidoAKGQwOGNiYzVkMzIwMzExOGRhNTU4MzI5NmU0OTI3M2NmODIzNzgwNDI",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-22T12:57:44Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2022-02-07T10:24:27Z"
    },
    "message": "gdb: unbuffer all input streams when not using readline\n\nThis commit should fix PR gdb/28711.  What's actually going on is\npretty involved, and there's still a bit of the story that I don't\nunderstand completely, however, from my observed results, I think that\nthe change I propose making here (or something very similar) is going\nto be needed.\n\nThe original bug report involves using eclipse to drive gdb using mi\ncommands.  A separate tty is spun off in which to send gdb the mi\ncommands, this tty is created using the new-ui command.\n\nThe behaviour observed is that, given a particular set of mi commands\nbeing sent to gdb, we sometimes see an ESPIPE error from a lseek\ncall, which ultimately results in gdb terminating.\n\nThe problems all originate from gdb_readline_no_editing_callback in\ngdb/event-top.c, where we can (sometimes) perform calls to fgetc, and\nallow glibc to perform buffering on the FILE object being used.\n\nI say sometime, because, gdb_readline_no_editing_callback already\nincludes a call to disable the glibc buffering, but this is only done\nif the input stream is not a tty.  In our case the input stream is a\ntty, so the buffering is left in place.\n\nThe first step to understanding why this problem occurs is to\nunderstand that eclipse sends multiple commands to gdb very quickly\nwithout waiting for and answer to each command, eclipse plans to\ncollect all of the command results after sending all the commands to\ngdb.  In fact, eclipse sends the commands to gdb that they appear to\narrive in the gdb process as a single block of data.  When reproducing\nthis issue within the testsuite I find it necessary to send multiple\ncommands using a single write call.\n\nThe next bit of the story gets a little involved, and this is where my\nunderstanding is not complete.  I can describe the behaviour that I\nobserve, and (for me at least) I'm happy that what I'm seeing, if a\nlittle strange, is consistent.  In order to fully understand what's\ngoing on I think I would likely need to dive into kernel code, which\ncurrently seems unnecessary given that I'm happy with the solution I'm\nproposing.\n\nThe following description all relates to input from a tty in which I'm\nnot using readline.  I see the same problems either when using a\nnew-ui tty, or with gdb's standard, non-readline, mi tty.\n\nHere's what I observe happening when I send multiple commands to gdb\nusing a single write, if I send gdb this:\n\n  command_1\\ncommand_2\\ncommand_3\n\nthen gdb's event loop will wake up (from its select) as it sees there\nis input available.  We call into gdb_readline_no_editing_callback,\nwhere we call fgetc, glibc will do a single big read, and get back\njust:\n\n  command_1\\n\n\nthat is, despite there being multiple lines of input available, I\nconsistently get just a single line.  From glibc a single character is\nreturned from the fgetc call, and within gdb we accumulate characters,\none at a time, into our own buffer.  Eventually gdb sees the '\\n'\ncharacter, and dispatches the whole 'command_1' into gdb's command\nhandler, which processes the command and prints the result.  We then\nreturn to gdb_readline_no_editing_callback, which in turn returns to\ngdb's event loop where we re-enter the select.\n\nInside the select we immediately see that there is more input waiting\non the input stream, drop out of the select, and call back into\ngdb_readline_no_editing_callback.  In this function we again call\nfgetc where glibc performs another big read.  This time glibc gets:\n\n  command_2\\n\n\nthat is, we once again get just a single line, despite there being a\nthird line available.  Just like the first command we copy the whole\nstring, character by character into gdb's buffer, then handle the\ncommand.  After handling the command we go to the event loop, enter,\nand then exit the select, and call back to the function\ngdb_readline_no_editing_callback.\n\nIn gdb_readline_no_editing_callback we again call fgetc, this time\nglibc gets the string:\n\n  command_3\\n\n\nlike before, we copy this to gdb's buffer and handle the command, then\nwe return to the event loop.  At this point the select blocks while we\nwait for more input to arrive.\n\nThe important bit of this is that someone, somewhere is, it appears,\ntaking care to split the incoming write into lines.\n\nMy next experiment is to try something like:\n\n  this_is_a_very_long_command\\nshort_command\\n\n\nHowever, I actually make 'this_is_a_very_long_command' very long, as\nin many hundreds of characters long.  One way to do this is:\n\n  echo xxxxxx.....xxxxx\n\nand just adding more and more 'x' characters as needed.  What I'm\naiming for is to have the first command be longer than glibc's\ninternal read buffer, which, on my machine, is 1024 characters.\n\nHowever, for this discussion, lets imagine that glibc's buffer is just\n8 characters (we can create just this situation by adding a suitable\nsetbuf call into gdb_readline_no_editing_callback).\n\nNow, if I send gdb this data:\n\n  abcdefghij\\nkl\\n\n\nThe first read from glibc will get 'abcdefgh', that is a full 8\ncharacter buffer.  Once gdb has copied these to its buffer we call\nfgetc again, and now glibc will get 'ij\\n', that is, just like before,\nmultiple lines are split at the '\\n' character.  The full command,\nwhich is now in gdb's buffer can be handled 'abcdefghij', after which\nwe go (via the event loop) back to gdb_readline_no_editing_callback.\nNow we call fgetc, and glibc will get 'kl\\n', which is then handled in\nthe normal way.\n\nSo far, so good.  However, there is, apparently, one edge case where\nthe above rules don't apply.\n\nIf the '\\n' character is the first character read from the kernel,\nthen the incoming lines are not split up.  So, given glibc's 8\ncharacter buffer, if I send gdb this:\n\n  abcdefgh\\nkl\\n\n\nthat is the first command is 8 characters plus a newline, then, on the\nfirst read (from within glibc) we get 'abcdefgh' in a single buffer.\nAs there's no newline gdb calls fgetc again, and glibc does another\nlarge read, now we get:\n\n  \\nkl\\n\n\nwhich doesn't follow the above pattern - the lines are not split into\nseparate buffers!\n\nSo, gdb reads the first character from glibc using fgetc, this is the\nnewline.  Now gdb has a complete command, and so the command is\nhandled.  We then return to the event loop and enter the select.\n\nThe problem is that, as far as the kernel is concerned, there is no\nmore input pending, it's all been read into glibc's buffer, and so the\nselect doesn't return.  The second command is basically stuck in\nglibc's buffer.\n\nIf I send another command to gdb, or even just send an empty\ncommand (a lone newline) then the select returns, we call into\ngdb_readline_no_editing_callback, and now gdb sees the second\ncommand.\n\nOK, so the above is interesting, but it doesn't explain the ESPIPE\nerror.\n\nWell, that's a slightly different, but related issue.  The ESPIPE\ncase will _only_ show up when using new-ui to create the separate tty\nfor mi commands, and is a consequence of this commit:\n\n  commit afe09f0b6311a4dd1a7e2dc6491550bb228734f8\n  Date:   Thu Jul 18 17:20:04 2019 +0100\n\n      Fix for using named pipes on Windows\n\nPrior to this commit, the new-ui command would open the tty three\ntimes, once each for stdin, stderr, and stdout.  After this commit we\nopen the tty just once and reuse the FILE object for all three roles.\n\nConsider the problem case, where glibc has (unexpectedly) read the\nsecond command into its internal buffer.  When we handle the first\ncommand we usually end up having to write something to the mi output\nstream.\n\nAfter the above commit the same FILE object represents both the input\nand output streams, so, when gdb tries to write to the FILE object,\nglibc spots that there is input pending within the input buffer, and\nso assumes that we have read ahead of where we should be in the input\nfile.  To correct for this glibc tries to do an lseek call to\nreposition the file offset of the output stream prior to writing to\nit.  However, as the output stream is a tty, and seeking is not\nsupported on a tty, this lseek call fails, this results in the ESPIPE,\nwhich ultimately causes gdb to terminate.\n\nSo, now we understand why the ESPIPE triggers (which was what caused\nthe gdb crash in the original bug report), and we also understand that\nsometime gdb will not handle the second command in a timely\nfashion (if the first command is just the wrong length). So, what to\ndo about all this?\n\nWe could revert the commit mentioned above (and implement its\nfunctionality another way).  This would certainly resolve the ESPIPE\nissue, the buffered input would now only be on the input stream, the\noutput stream would have no buffered input, and so glibc would never\ntry to lseek, and so we'd never get the ESPIPE error.\n\nHowever, this only solves one of the two problems.  We would still\nsuffer from the problem where, if the first command is just the wrong\nlength, the second command will not (immediately) get handled.\n\nThe only solution I can see to this problem is to unbuffer the input\nstream.  If glibc is not buffering the input, but instead, we read\nincoming data character by character from the kernel, then everything\nwill be fine.  As soon as we see the newline at the end of the first\ncommand we will handle the first command.  As glibc will have no\nbuffered input it will not be tempted to lseek, so no ESPIPE error.\nWhen we go have to the event loop there will be more data pending in\nthe kernel, so the select will immediately return, and the second\ncommand will be processed.\n\nI'm tempted to suggest that we should move the unbuffering of the\ninput stream out of gdb_readline_no_editing_callback and do it\nsomewhere earlier, more like when we create the input streams.\nHowever, I've not done that in this commit for a couple of reasons:\n\n  1. By keeping the unbuffering in gdb_readline_no_editing_callback\n  I'm making the smallest possible change that fixes the bug.  Moving\n  the unbuffering somewhere better can be done as a refactor later, if\n  that 's felt to be important,\n\n  2. I don't think making repeated calls to unbuffer the input will\n  have that much performance impact.  We only make the unbuffer call\n  once per call to gdb_readline_no_editing_callback, and, if the input\n  stream is already unbuffered we'll return pretty quickly, so I don't\n  see this as being massively costly,\n\n  3. Tom is currently doing lots of gdb stream management changes and\n  I want to minimise the chances we'll conflict.\n\nSo, this commit just changes gdb_readline_no_editing_callback to\nalways unbuffer the input stream.\n\nThe test for this issue sends two commands in a loop, with the first\ncommand growing bigger each time around the loop.  I actually make the\nfirst command bigger by just adding whitespace to the front, as gdb\nstill has to read the complete command (including whitespace) via\nglibc, so this is enough to trigger the bug.\n\nThe original bug was reported when using a virtual machine, and in\nthis situation we see this in the strace output:\n\n  read(9, \"70-var-info-path-expression var1.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", 1024) = 64\n  read(9, \"\\n71-var-info-path-expression var1.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n\", 1024) = 67\n\nI'm not completely sure what's going on here, but it appears that the\nkernel on the virtual machine is delivering the input to glibc slower\nthan I see on my real hardware; glibc asks for 1024 bytes, but only\ngets 64 bytes the first time.  In the second read we see the problem\ncase, the first character is the newline, but then the entire second\ncommand is included.\n\nIf I run this exact example on my real hardware then the first command\nwould not be truncated at 64 bytes, instead, I'd expect to see the\nnewline included in the first read, with the second command split into\na second read.\n\nSo, for testing, I check cases where the first command is just a few\ncharacters (starting at 8 character), all the way up to 2048\ncharacters.  Hopefully, this should mean we hit the problem case for\nmost machine setups.\n\nThe only last question relates to commit afe09f0b6311a4d that I\nmentioned earlier.  That commit was intended to provide support for\nMicrosoft named pipes:\n\n  https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes\n\nI know next to nothing about this topic beyond a brief scan of the\nabove link, but I think these windows named pipe are closer in\nbehaviour to unix sockets than to unix named fifos.\n\nI am a little nervous that, after the above commit, we now use the\nsame FILE for in, err, and out streams.  In contrast, in a vanilla C\nprogram, I would expect different FILE objects for each stream.\n\nStill, I'm reluctant to revert the above commit (and provide the same\nfunctionality a different way) without a specific bug to point at,\nand, now that the streams are unbuffered, I expect a lot of the read\nand write calls are going straight to the kernel with minimal glibc\ninvolvement, so maybe it doesn't really matter.  Anyway, I haven't\ntouched the above patch, but it is something to keep in mind when\nworking in this area.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28711",
    "tree": {
      "sha": "16ecd8ef6d878e61cde809a3dda80a9ec56da247",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/16ecd8ef6d878e61cde809a3dda80a9ec56da247"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d08cbc5d3203118da5583296e49273cf82378042",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d08cbc5d3203118da5583296e49273cf82378042",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d08cbc5d3203118da5583296e49273cf82378042",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d08cbc5d3203118da5583296e49273cf82378042/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "59091b1280b4ba301a2f147fbe51ea4816246ba2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/59091b1280b4ba301a2f147fbe51ea4816246ba2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/59091b1280b4ba301a2f147fbe51ea4816246ba2"
    }
  ],
  "stats": {
    "total": 147,
    "additions": 139,
    "deletions": 8
  },
  "files": [
    {
      "sha": "52b4bfd7d1d25ec3d459e07a0eee8ec65e90824b",
      "filename": "gdb/event-top.c",
      "status": "modified",
      "additions": 11,
      "deletions": 8,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d08cbc5d3203118da5583296e49273cf82378042/gdb/event-top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d08cbc5d3203118da5583296e49273cf82378042/gdb/event-top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-top.c?ref=d08cbc5d3203118da5583296e49273cf82378042",
      "patch": "@@ -796,22 +796,25 @@ gdb_readline_no_editing_callback (gdb_client_data client_data)\n   int c;\n   char *result;\n   struct buffer line_buffer;\n-  static int done_once = 0;\n   struct ui *ui = current_ui;\n \n   buffer_init (&line_buffer);\n \n+  FILE *stream = ui->instream != nullptr ? ui->instream : ui->stdin_stream;\n+  gdb_assert (stream != nullptr);\n+\n   /* Unbuffer the input stream, so that, later on, the calls to fgetc\n      fetch only one char at the time from the stream.  The fgetc's will\n      get up to the first newline, but there may be more chars in the\n      stream after '\\n'.  If we buffer the input and fgetc drains the\n      stream, getting stuff beyond the newline as well, a select, done\n-     afterwards will not trigger.  */\n-  if (!done_once && !ISATTY (ui->instream))\n-    {\n-      setbuf (ui->instream, NULL);\n-      done_once = 1;\n-    }\n+     afterwards will not trigger.\n+\n+     This unbuffering was, at one point, not applied if the input stream\n+     was a tty, however, the buffering can cause problems, even for a tty,\n+     in some cases.  Please ensure that any changes in this area run the MI\n+     tests with the FORCE_SEPARATE_MI_TTY=1 flag being passed.  */\n+  setbuf (stream, NULL);\n \n   /* We still need the while loop here, even though it would seem\n      obvious to invoke gdb_readline_no_editing_callback at every\n@@ -825,7 +828,7 @@ gdb_readline_no_editing_callback (gdb_client_data client_data)\n     {\n       /* Read from stdin if we are executing a user defined command.\n \t This is the right thing for prompt_for_continue, at least.  */\n-      c = fgetc (ui->instream != NULL ? ui->instream : ui->stdin_stream);\n+      c = fgetc (stream);\n \n       if (c == EOF)\n \t{"
    },
    {
      "sha": "767d1d0f6797bb3dd0f1e1c09381f76466c71370",
      "filename": "gdb/testsuite/gdb.mi/mi-multi-commands.exp",
      "status": "added",
      "additions": 128,
      "deletions": 0,
      "changes": 128,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d08cbc5d3203118da5583296e49273cf82378042/gdb/testsuite/gdb.mi/mi-multi-commands.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d08cbc5d3203118da5583296e49273cf82378042/gdb/testsuite/gdb.mi/mi-multi-commands.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.mi/mi-multi-commands.exp?ref=d08cbc5d3203118da5583296e49273cf82378042",
      "patch": "@@ -0,0 +1,128 @@\n+# Copyright 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# In the past we would use glibc's buffered input for the mi tty.\n+# This buffering would cause problems if two commands are sent to gdb\n+# in a single write call, and, if the first command (excluding its\n+# trailing newline) exactly filled glibc's internal buffer.\n+#\n+# The solution to this problem was to stop using glibc's buffering for\n+# the mi tty.\n+#\n+# To test for this situation we send two command to gdb in a loop, the\n+# first command gets progressively bigger.  We check that gdb\n+# correctly sees both commands.\n+\n+load_lib mi-support.exp\n+set MIFLAGS \"-i=mi\"\n+\n+# Start gdb, passing ARGS to mi_gdb_start.  Then run a series of tests\n+# passing two commands to gdb in a single write action.  The first\n+# command is increasingly long, while the second command stays very\n+# short.\n+#\n+# Check that gdb sees, and performs, both commands.\n+proc run_test { args } {\n+    global mi_gdb_prompt\n+    global decimal\n+\n+    gdb_exit\n+    if [mi_gdb_start $args] {\n+\tcontinue\n+    }\n+\n+    set start 1\n+    set limit 2049\n+\n+    mi_gdb_test \"set \\$a = \\\"FIRST COMMAND\\\"\" \".*\"\n+    mi_gdb_test \"set \\$b = \\\"TEST COMPLETE\\\"\" \".*\"\n+\n+    for { set i $start } { $i < $limit } { incr i } {\n+\n+\tset cmd \"\"\n+\n+\t# Create a command that is at least `i` characters long.\n+\tset first_cmd \"print \\$a\"\n+\twhile { [string length $first_cmd] < $i } {\n+\t    set first_cmd \" $first_cmd\"\n+\t}\n+\n+\t# We reset `i`, our loop counter, here.  When i is large this\n+\t# should be a nop as we attempt to make the first command\n+\t# length be i above.  However, the first time around the loop\n+\t# we start with an i value of 1, however, we can't make a\n+\t# command that short, so, by resetting i here we effectively\n+\t# skip the first couple of loop iterations where i is less\n+\t# than the minimum command length.\n+\tset i [string length $first_cmd]\n+\tverbose -log \"length of first command is $i\"\n+\n+\tset cmd \"${first_cmd}\\nprint \\$b\\n\"\n+\n+\t# We need to call send_gdb ourselves here as gdb_test_multiple\n+\t# will try to send each line of the command separately (breaking\n+\t# the command at newline characters).  This splitting will more\n+\t# than likely mean that gdb will see and process the first command\n+\t# before the second command arrives, this prevents the bug from\n+\t# triggering.\n+\tsend_gdb \"$cmd\"\n+\n+\t# Now check for output from the two commands.  We do this\n+\t# using two calls to gdb_test_multiple, this is because the\n+\t# echoing of the second command can sometime get mixed\n+\t# unexpectedly with the command output, this is especially\n+\t# likely when running using the read1 technique.\n+\t#\n+\t# When using a single gdb_test_multiple we need to anchor\n+\t# patterns using a ^, however, this requires us to consume and\n+\t# discard all lines that are not part of the output that we're\n+\t# looking for.  However, due to the unpredictable\n+\t# intermingling, it's much easier if we drop the ^ anchor.\n+\t# However, with this gone dejagnu would sometimes match the\n+\t# second comand output before the first commands output.\n+\t#\n+\t# This approach just looks for the first command output, then,\n+\t# once that has been found, we start looking for the second\n+\t# command output, this seems pretty reliable.\n+\tset seen_first_message false\n+\tset seen_second_message false\n+\n+\tgdb_test_multiple \"\" \"look for first command output, command length $i\" -prompt \"$mi_gdb_prompt\" {\n+\t    -re \"(&\\\"print \\\\\\$\\[ab\\]\\\\\\\\n\\\")\\r\\n(~\\\"\\\\\\$$decimal = \\\\\\\\\\\"FIRST COMMAND\\\\\\\\\\\"\\[^\\r\\n\\]+\\r\\n\\\\^done\\r\\n$mi_gdb_prompt)\" {\n+\t\tpass $gdb_test_name\n+\t\tset seen_first_message true\n+\t    }\n+\t}\n+\n+\tgdb_test_multiple \"\" \"look for second command output, command length $i\" -prompt \"$mi_gdb_prompt\" {\n+\t    -re \"(&\\\"print \\\\\\$\\[ab\\]\\\\\\\\n\\\")\\r\\n(~\\\"\\\\\\$$decimal = \\\\\\\\\\\"TEST COMPLETE\\\\\\\\\\\"\\[^\\r\\n\\]+\\r\\n\\\\^done\\r\\n$mi_gdb_prompt)\" {\n+\t\tpass $gdb_test_name\n+\t\tset seen_second_message true\n+\t    }\n+\t}\n+\n+\t# If one of the above tests failed then lets no waste our time\n+\t# checking different command lengths.  The actual bug this\n+\t# test checks for would result in a timeout, so we don't want\n+\t# to risk lots more timeouts.\n+\tif { ! [expr $seen_first_message && $seen_second_message ] } {\n+\t    break\n+\t}\n+    }\n+}\n+\n+foreach_with_prefix args { \"\" \"separate-mi-tty\" } {\n+    run_test $args\n+}"
    }
  ]
}