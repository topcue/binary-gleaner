{
  "sha": "11659552768f6b915a6bf5aa98dfb11ba0f004d0",
  "node_id": "C_kwDOANOeidoAKDExNjU5NTUyNzY4ZjZiOTE1YTZiZjVhYTk4ZGZiMTFiYTBmMDA0ZDA",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-02-23T21:26:16Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-02-24T12:29:05Z"
    },
    "message": "gdb/linux-tdep: make read_mapping return a structure\n\nChange read_mapping to return a structure instead of taking many output\nparameters.  Change the string + length output parameters (permissions\nand device) to be gdb::string_view, since that's what string_view is\nfor (a non-NULL terminated view on a string).  No changes in behavior\nexpected.\n\nChange-Id: I86e627d84d3dda8c9b835592b0f4de8d90d12112",
    "tree": {
      "sha": "633a335c606e90ddb4a3b847d60ab07612a8799d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/633a335c606e90ddb4a3b847d60ab07612a8799d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/11659552768f6b915a6bf5aa98dfb11ba0f004d0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/11659552768f6b915a6bf5aa98dfb11ba0f004d0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/11659552768f6b915a6bf5aa98dfb11ba0f004d0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/11659552768f6b915a6bf5aa98dfb11ba0f004d0/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7190ae0d393d09c3c1f24add83d1e90727402749",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7190ae0d393d09c3c1f24add83d1e90727402749",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7190ae0d393d09c3c1f24add83d1e90727402749"
    }
  ],
  "stats": {
    "total": 109,
    "additions": 57,
    "deletions": 52
  },
  "files": [
    {
      "sha": "83bd4237286c1a2dde31213323030ce3933d165e",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 57,
      "deletions": 52,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/11659552768f6b915a6bf5aa98dfb11ba0f004d0/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/11659552768f6b915a6bf5aa98dfb11ba0f004d0/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=11659552768f6b915a6bf5aa98dfb11ba0f004d0",
      "patch": "@@ -441,42 +441,55 @@ linux_core_pid_to_str (struct gdbarch *gdbarch, ptid_t ptid)\n   return normal_pid_to_str (ptid);\n }\n \n+/* Data from one mapping from /proc/PID/maps.  */\n+\n+struct mapping\n+{\n+  ULONGEST addr;\n+  ULONGEST endaddr;\n+  gdb::string_view permissions;\n+  ULONGEST offset;\n+  gdb::string_view device;\n+  ULONGEST inode;\n+\n+  /* This field is guaranteed to be NULL-terminated, hence it is not a\n+     gdb::string_view.  */\n+  const char *filename;\n+};\n+\n /* Service function for corefiles and info proc.  */\n \n-static void\n-read_mapping (const char *line,\n-\t      ULONGEST *addr, ULONGEST *endaddr,\n-\t      const char **permissions, size_t *permissions_len,\n-\t      ULONGEST *offset,\n-\t      const char **device, size_t *device_len,\n-\t      ULONGEST *inode,\n-\t      const char **filename)\n+static mapping\n+read_mapping (const char *line)\n {\n+  struct mapping mapping;\n   const char *p = line;\n \n-  *addr = strtoulst (p, &p, 16);\n+  mapping.addr = strtoulst (p, &p, 16);\n   if (*p == '-')\n     p++;\n-  *endaddr = strtoulst (p, &p, 16);\n+  mapping.endaddr = strtoulst (p, &p, 16);\n \n   p = skip_spaces (p);\n-  *permissions = p;\n+  const char *permissions_start = p;\n   while (*p && !isspace (*p))\n     p++;\n-  *permissions_len = p - *permissions;\n+  mapping.permissions = {permissions_start, (size_t) (p - permissions_start)};\n \n-  *offset = strtoulst (p, &p, 16);\n+  mapping.offset = strtoulst (p, &p, 16);\n \n   p = skip_spaces (p);\n-  *device = p;\n+  const char *device_start = p;\n   while (*p && !isspace (*p))\n     p++;\n-  *device_len = p - *device;\n+  mapping.device = {device_start, (size_t) (p - device_start)};\n \n-  *inode = strtoulst (p, &p, 10);\n+  mapping.inode = strtoulst (p, &p, 10);\n \n   p = skip_spaces (p);\n-  *filename = p;\n+  mapping.filename = p;\n+\n+  return mapping;\n }\n \n /* Helper function to decode the \"VmFlags\" field in /proc/PID/smaps.\n@@ -895,34 +908,27 @@ linux_info_proc (struct gdbarch *gdbarch, const char *args,\n \t       line;\n \t       line = strtok_r (NULL, \"\\n\", &saveptr))\n \t    {\n-\t      ULONGEST addr, endaddr, offset, inode;\n-\t      const char *permissions, *device, *mapping_filename;\n-\t      size_t permissions_len, device_len;\n-\n-\t      read_mapping (line, &addr, &endaddr,\n-\t\t\t    &permissions, &permissions_len,\n-\t\t\t    &offset, &device, &device_len,\n-\t\t\t    &inode, &mapping_filename);\n+\t      struct mapping m = read_mapping (line);\n \n \t      if (gdbarch_addr_bit (gdbarch) == 32)\n \t\t{\n \t\t  printf_filtered (\"\\t%10s %10s %7.5s %10s %10s %s\\n\",\n-\t\t\t\t   paddress (gdbarch, addr),\n-\t\t\t\t   paddress (gdbarch, endaddr),\n-\t\t\t\t   permissions,\n-\t\t\t\t   hex_string (endaddr - addr),\n-\t\t\t\t   hex_string (offset),\n-\t\t\t\t   *mapping_filename ? mapping_filename : \"\");\n+\t\t\t\t   paddress (gdbarch, m.addr),\n+\t\t\t\t   paddress (gdbarch, m.endaddr),\n+\t\t\t\t   m.permissions.data (),\n+\t\t\t\t   hex_string (m.endaddr - m.addr),\n+\t\t\t\t   hex_string (m.offset),\n+\t\t\t\t   m.filename);\n \t\t}\n \t      else\n \t\t{\n \t\t  printf_filtered (\"  %18s %18s %7.5s %10s %10s %s\\n\",\n-\t\t\t\t   paddress (gdbarch, addr),\n-\t\t\t\t   paddress (gdbarch, endaddr),\n-\t\t\t\t   permissions,\n-\t\t\t\t   hex_string (endaddr - addr),\n-\t\t\t\t   hex_string (offset),\n-\t\t\t\t   *mapping_filename ? mapping_filename : \"\");\n+\t\t\t\t   paddress (gdbarch, m.addr),\n+\t\t\t\t   paddress (gdbarch, m.endaddr),\n+\t\t\t\t   m.permissions.data (),\n+\t\t\t\t   hex_string (m.endaddr - m.addr),\n+\t\t\t\t   hex_string (m.offset),\n+\t\t\t\t   m.filename);\n \t\t}\n \t    }\n \t}\n@@ -1322,19 +1328,15 @@ parse_smaps_data (const char *data,\n \n   while (line != NULL)\n     {\n-      ULONGEST addr, endaddr, offset, inode;\n-      const char *permissions, *device, *filename;\n       struct smaps_vmflags v;\n-      size_t permissions_len, device_len;\n       int read, write, exec, priv;\n       int has_anonymous = 0;\n       int mapping_anon_p;\n       int mapping_file_p;\n \n       memset (&v, 0, sizeof (v));\n-      read_mapping (line, &addr, &endaddr, &permissions, &permissions_len,\n-\t\t    &offset, &device, &device_len, &inode, &filename);\n-      mapping_anon_p = mapping_is_anonymous_p (filename);\n+      struct mapping m = read_mapping (line);\n+      mapping_anon_p = mapping_is_anonymous_p (m.filename);\n       /* If the mapping is not anonymous, then we can consider it\n \t to be file-backed.  These two states (anonymous or\n \t file-backed) seem to be exclusive, but they can actually\n@@ -1347,9 +1349,12 @@ parse_smaps_data (const char *data,\n       mapping_file_p = !mapping_anon_p;\n \n       /* Decode permissions.  */\n-      read = (memchr (permissions, 'r', permissions_len) != 0);\n-      write = (memchr (permissions, 'w', permissions_len) != 0);\n-      exec = (memchr (permissions, 'x', permissions_len) != 0);\n+      auto has_perm = [&m] (char c)\n+\t{ return m.permissions.find (c) != gdb::string_view::npos; };\n+      read = has_perm ('r');\n+      write = has_perm ('w');\n+      exec = has_perm ('x');\n+\n       /* 'private' here actually means VM_MAYSHARE, and not\n \t VM_SHARED.  In order to know if a mapping is really\n \t private or not, we must check the flag \"sh\" in the\n@@ -1359,7 +1364,7 @@ parse_smaps_data (const char *data,\n \t not have the VmFlags there.  In this case, there is\n \t really no way to know if we are dealing with VM_SHARED,\n \t so we just assume that VM_MAYSHARE is enough.  */\n-      priv = memchr (permissions, 'p', permissions_len) != 0;\n+      priv = has_perm ('p');\n \n       /* Try to detect if region should be dumped by parsing smaps\n \t counters.  */\n@@ -1421,9 +1426,9 @@ parse_smaps_data (const char *data,\n       /* Save the smaps entry to the vector.  */\n \tstruct smaps_data map;\n \n-\tmap.start_address = addr;\n-\tmap.end_address = endaddr;\n-\tmap.filename = filename;\n+\tmap.start_address = m.addr;\n+\tmap.end_address = m.endaddr;\n+\tmap.filename = m.filename;\n \tmap.vmflags = v;\n \tmap.read = read? true : false;\n \tmap.write = write? true : false;\n@@ -1432,8 +1437,8 @@ parse_smaps_data (const char *data,\n \tmap.has_anonymous = has_anonymous;\n \tmap.mapping_anon_p = mapping_anon_p? true : false;\n \tmap.mapping_file_p = mapping_file_p? true : false;\n-\tmap.offset = offset;\n-\tmap.inode = inode;\n+\tmap.offset = m.offset;\n+\tmap.inode = m.inode;\n \n \tsmaps.emplace_back (map);\n     }"
    }
  ]
}