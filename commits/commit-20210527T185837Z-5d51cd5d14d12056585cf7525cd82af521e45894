{
  "sha": "5d51cd5d14d12056585cf7525cd82af521e45894",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWQ1MWNkNWQxNGQxMjA1NjU4NWNmNzUyNWNkODJhZjUyMWU0NTg5NA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:37Z"
    },
    "message": "gdb: make bp_locations an std::vector\n\nChange the type of the global location list, bp_locations, to be an\nstd::vector.\n\nAdjust the users to deal with that, mostly in an obvious way by using\n.data() and .size().  The user where it's slightly less obvious is\nupdate_global_location_list.  There, we std::move the old location list\nout of the global vector into a local variable.  The code to fill the\nnew location list gets simpler, as it's now simply using .push_back(),\nno need to count the locations beforehand.\n\nIn the rest of update_global_location_list, the code is adjusted to work\nwith indices instead of `bp_location **`, to iterate on the location\nlist.  I believe it's a bit easier to understand this way.  But more\nimportantly, when we build with _GLIBCXX_DEBUG, the operator[] of the\nvector does bound checking, so we will know if we ever access past a\nvector size (which we won't if we access by raw pointer).  I think that\nwork can further be done to make that function easier to understand,\nnotably find better names than \"loc\" and \"loc2\" for variables, but\nthat's work for later.\n\ngdb/ChangeLog:\n\n\t* breakpoint.c (bp_locations): Change to std::vector, update all\n\tusers.\n\t(bp_locations_count): Remove.\n\t(update_global_location_list): Change to work with indices\n\trather than bp_location**.\n\nChange-Id: I193ce40f84d5dc930fbab8867cf946e78ff0df0b",
    "tree": {
      "sha": "39c7d4713f3f3ab8a9d4f9aea6950ac1ba368e8e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/39c7d4713f3f3ab8a9d4f9aea6950ac1ba368e8e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5d51cd5d14d12056585cf7525cd82af521e45894",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d51cd5d14d12056585cf7525cd82af521e45894",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5d51cd5d14d12056585cf7525cd82af521e45894",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d51cd5d14d12056585cf7525cd82af521e45894/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40cb8ca5396e563968fa8465a10173e7c2fd9d84",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/40cb8ca5396e563968fa8465a10173e7c2fd9d84"
    }
  ],
  "stats": {
    "total": 98,
    "additions": 40,
    "deletions": 58
  },
  "files": [
    {
      "sha": "9add064e9ec93a6b650bb5953e63ce1feb8b340c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d51cd5d14d12056585cf7525cd82af521e45894/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d51cd5d14d12056585cf7525cd82af521e45894/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5d51cd5d14d12056585cf7525cd82af521e45894",
      "patch": "@@ -1,3 +1,11 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.c (bp_locations): Change to std::vector, update all\n+\tusers.\n+\t(bp_locations_count): Remove.\n+\t(update_global_location_list): Change to work with indices\n+\trather than bp_location**.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.h (bp_locations_range): New."
    },
    {
      "sha": "f5f80794c0554974df8b56dc55b17782e64627df",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 32,
      "deletions": 58,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d51cd5d14d12056585cf7525cd82af521e45894/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d51cd5d14d12056585cf7525cd82af521e45894/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=5d51cd5d14d12056585cf7525cd82af521e45894",
      "patch": "@@ -496,8 +496,8 @@ bool target_exact_watchpoints = false;\n    while executing the block of ALL_BP_LOCATIONS.  */\n \n #define ALL_BP_LOCATIONS(B,BP_TMP)\t\t\t\t\t\\\n-\tfor (BP_TMP = bp_locations;\t\t\t\t\t\\\n-\t     BP_TMP < bp_locations + bp_locations_count && (B = *BP_TMP);\\\n+\tfor (BP_TMP = bp_locations.data ();\t\t\t\t\\\n+\t     BP_TMP < bp_locations.data () + bp_locations.size () && (B = *BP_TMP);\\\n \t     BP_TMP++)\n \n /* Iterates through locations with address ADDRESS for the currently selected\n@@ -510,7 +510,7 @@ bool target_exact_watchpoints = false;\n \tfor (BP_LOCP_START = BP_LOCP_START == NULL ? get_first_locp_gte_addr (ADDRESS) : BP_LOCP_START, \\\n \t     BP_LOCP_TMP = BP_LOCP_START;\t\t\t\t\\\n \t     BP_LOCP_START\t\t\t\t\t\t\\\n-\t     && (BP_LOCP_TMP < bp_locations + bp_locations_count\t\\\n+\t     && (BP_LOCP_TMP < bp_locations.data () + bp_locations.size () \\\n \t     && (*BP_LOCP_TMP)->address == ADDRESS);\t\t\t\\\n \t     BP_LOCP_TMP++)\n \n@@ -554,11 +554,7 @@ all_tracepoints ()\n \n /* Array is sorted by bp_location_is_less_than - primarily by the ADDRESS.  */\n \n-static struct bp_location **bp_locations;\n-\n-/* Number of elements of BP_LOCATIONS.  */\n-\n-static unsigned bp_locations_count;\n+static std::vector<bp_location *> bp_locations;\n \n /* Maximum alignment offset between bp_target_info.PLACED_ADDRESS and\n    ADDRESS for the current elements of BP_LOCATIONS which get a valid\n@@ -827,7 +823,7 @@ get_first_locp_gte_addr (CORE_ADDR address)\n \n   /* Find a close match to the first location at ADDRESS.  */\n   locp_found = ((struct bp_location **)\n-\t\tbsearch (&dummy_locp, bp_locations, bp_locations_count,\n+\t\tbsearch (&dummy_locp, bp_locations.data (), bp_locations.size (),\n \t\t\t sizeof (struct bp_location **),\n \t\t\t bp_locations_compare_addrs));\n \n@@ -837,7 +833,7 @@ get_first_locp_gte_addr (CORE_ADDR address)\n \n   /* We may have found a location that is at ADDRESS but is not the first in the\n      location's list.  Go backwards (if possible) and locate the first one.  */\n-  while ((locp_found - 1) >= bp_locations\n+  while ((locp_found - 1) >= bp_locations.data ()\n \t && (*(locp_found - 1))->address == address)\n     locp_found--;\n \n@@ -1582,7 +1578,7 @@ breakpoint_xfer_memory (gdb_byte *readbuf, gdb_byte *writebuf,\n      report higher one.  */\n \n   bc_l = 0;\n-  bc_r = bp_locations_count;\n+  bc_r = bp_locations.size ();\n   while (bc_l + 1 < bc_r)\n     {\n       struct bp_location *bl;\n@@ -1627,7 +1623,7 @@ breakpoint_xfer_memory (gdb_byte *readbuf, gdb_byte *writebuf,\n \n   /* Now do full processing of the found relevant range of elements.  */\n \n-  for (bc = bc_l; bc < bp_locations_count; bc++)\n+  for (bc = bc_l; bc < bp_locations.size (); bc++)\n   {\n     struct bp_location *bl = bp_locations[bc];\n \n@@ -11831,7 +11827,6 @@ force_breakpoint_reinsertion (struct bp_location *bl)\n static void\n update_global_location_list (enum ugll_insert_mode insert_mode)\n {\n-  struct bp_location **locp;\n   /* Last breakpoint location address that was marked for update.  */\n   CORE_ADDR last_addr = 0;\n   /* Last breakpoint location program space that was marked for update.  */\n@@ -11850,38 +11845,22 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \n   /* Saved former bp_locations array which we compare against the newly\n      built bp_locations from the current state of ALL_BREAKPOINTS.  */\n-  struct bp_location **old_locp;\n-  unsigned old_locations_count;\n-  gdb::unique_xmalloc_ptr<struct bp_location *> old_locations (bp_locations);\n-\n-  old_locations_count = bp_locations_count;\n-  bp_locations = NULL;\n-  bp_locations_count = 0;\n-\n-  for (breakpoint *b : all_breakpoints ())\n-    for (bp_location *loc ATTRIBUTE_UNUSED : b->locations ())\n-      bp_locations_count++;\n+  std::vector<bp_location *> old_locations = std::move (bp_locations);\n+  bp_locations.clear ();\n \n-  bp_locations = XNEWVEC (struct bp_location *, bp_locations_count);\n-  locp = bp_locations;\n   for (breakpoint *b : all_breakpoints ())\n     for (bp_location *loc : b->locations ())\n-      *locp++ = loc;\n+      bp_locations.push_back (loc);\n \n   /* See if we need to \"upgrade\" a software breakpoint to a hardware\n      breakpoint.  Do this before deciding whether locations are\n      duplicates.  Also do this before sorting because sorting order\n      depends on location type.  */\n-  for (locp = bp_locations;\n-       locp < bp_locations + bp_locations_count;\n-       locp++)\n-    {\n-      bp_location *loc = *locp;\n-      if (!loc->inserted && should_be_inserted (loc))\n+  for (bp_location *loc : bp_locations)\n+    if (!loc->inserted && should_be_inserted (loc))\n \thandle_automatic_hardware_breakpoints (loc);\n-    }\n \n-  std::sort (bp_locations, bp_locations + bp_locations_count,\n+  std::sort (bp_locations.begin (), bp_locations.end (),\n \t     bp_location_is_less_than);\n \n   bp_locations_target_extensions_update ();\n@@ -11896,14 +11875,9 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n      LOCP is kept in sync with OLD_LOCP, each pointing to the current\n      and former bp_location array state respectively.  */\n \n-  locp = bp_locations;\n-  for (old_locp = old_locations.get ();\n-       old_locp < old_locations.get () + old_locations_count;\n-       old_locp++)\n+  size_t loc_i = 0;\n+  for (bp_location *old_loc : old_locations)\n     {\n-      struct bp_location *old_loc = *old_locp;\n-      struct bp_location **loc2p;\n-\n       /* Tells if 'old_loc' is found among the new locations.  If\n \t not, we have to free it.  */\n       int found_object = 0;\n@@ -11913,28 +11887,28 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \n       /* Skip LOCP entries which will definitely never be needed.\n \t Stop either at or being the one matching OLD_LOC.  */\n-      while (locp < bp_locations + bp_locations_count\n-\t     && (*locp)->address < old_loc->address)\n-\tlocp++;\n+      while (loc_i < bp_locations.size ()\n+\t     && bp_locations[loc_i]->address < old_loc->address)\n+\tloc_i++;\n \n-      for (loc2p = locp;\n-\t   (loc2p < bp_locations + bp_locations_count\n-\t    && (*loc2p)->address == old_loc->address);\n-\t   loc2p++)\n+      for (size_t loc2_i = loc_i;\n+\t   (loc2_i < bp_locations.size ()\n+\t    && bp_locations[loc2_i]->address == old_loc->address);\n+\t   loc2_i++)\n \t{\n \t  /* Check if this is a new/duplicated location or a duplicated\n \t     location that had its condition modified.  If so, we want to send\n \t     its condition to the target if evaluation of conditions is taking\n \t     place there.  */\n-\t  if ((*loc2p)->condition_changed == condition_modified\n+\t  if (bp_locations[loc2_i]->condition_changed == condition_modified\n \t      && (last_addr != old_loc->address\n \t\t  || last_pspace_num != old_loc->pspace->num))\n \t    {\n-\t      force_breakpoint_reinsertion (*loc2p);\n+\t      force_breakpoint_reinsertion (bp_locations[loc2_i]);\n \t      last_pspace_num = old_loc->pspace->num;\n \t    }\n \n-\t  if (*loc2p == old_loc)\n+\t  if (bp_locations[loc2_i] == old_loc)\n \t    found_object = 1;\n \t}\n \n@@ -11977,12 +11951,12 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n \t      /* OLD_LOC comes from existing struct breakpoint.  */\n \t      if (bl_address_is_meaningful (old_loc))\n \t\t{\n-\t\t  for (loc2p = locp;\n-\t\t       (loc2p < bp_locations + bp_locations_count\n-\t\t\t&& (*loc2p)->address == old_loc->address);\n-\t\t       loc2p++)\n+\t\t  for (size_t loc2_i = loc_i;\n+\t\t       (loc2_i < bp_locations.size ()\n+\t\t\t&& bp_locations[loc2_i]->address == old_loc->address);\n+\t\t       loc2_i++)\n \t\t    {\n-\t\t      struct bp_location *loc2 = *loc2p;\n+\t\t      bp_location *loc2 = bp_locations[loc2_i];\n \n \t\t      if (loc2 == old_loc)\n \t\t\tcontinue;\n@@ -12121,7 +12095,7 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   awp_loc_first = NULL;\n   rwp_loc_first = NULL;\n \n-  bp_location *loc;\n+  bp_location *loc, **locp;\n   ALL_BP_LOCATIONS (loc, locp)\n     {\n       /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always"
    }
  ]
}