{
  "sha": "6afcd2d4161165fd976c55a9792dbcccd2d5d106",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmFmY2QyZDQxNjExNjVmZDk3NmM1NWE5NzkyZGJjY2NkMmQ1ZDEwNg==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-03-18T16:06:05Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-12-10T14:45:08Z"
    },
    "message": "[AArch64] SVE/FPSIMD fixup for big endian\n\nThe FPSIMD dump in signal frames and ptrace FPSIMD dump in the SVE context\nstructure follows the target endianness, whereas the SVE dumps are\nendianness-independent (LE).\n\nTherefore, when the system is in BE mode, we need to reverse the bytes\nfor the FPSIMD data.\n\nGiven the V registers are larger than 64-bit, I've added a way for value\nbytes to be set, as opposed to passing a 64-bit fixed quantity. This fits\nnicely with the unwinding *_got_bytes function and makes the trad-frame\nmore flexible and capable of saving larger registers.\n\nThe memory for the bytes is allocated via the frame obstack, so it gets freed\nafter we're done inspecting the frame.\n\ngdb/ChangeLog:\n\n2020-12-10  Luis Machado  <luis.machado@linaro.org>\n\n\t* aarch64-linux-tdep.c (aarch64_linux_restore_vreg) New function.\n\t(aarch64_linux_sigframe_init): Call aarch64_linux_restore_vreg.\n\t* aarch64-tdep.h (V_REGISTER_SIZE): Move to ...\n\t* arch/aarch64.h: ... here.\n\t* nat/aarch64-sve-linux-ptrace.c: Include endian.h.\n\t(aarch64_maybe_swab128): New function.\n\t(aarch64_sve_regs_copy_to_reg_buf)\n\t(aarch64_sve_regs_copy_from_reg_buf): Adjust FPSIMD entries.\n\t* trad-frame.c (trad_frame_reset_saved_regs): Initialize\n\tthe data field.\n\t(TF_REG_VALUE_BYTES): New enum value.\n\t(trad_frame_value_bytes_p): New function.\n\t(trad_frame_set_value_bytes): New function.\n\t(trad_frame_set_reg_value_bytes): New function.\n\t(trad_frame_get_prev_register): Handle register values saved as bytes.\n\t* trad-frame.h (trad_frame_set_reg_value_bytes): New prototype.\n\t(struct trad_frame_saved_reg) <data>: New field.\n\t(trad_frame_set_value_bytes): New prototype.\n\t(trad_frame_value_bytes_p): New prototype.",
    "tree": {
      "sha": "fb937c4e5014dfc25d5b05162d78f5e13af25f4c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fb937c4e5014dfc25d5b05162d78f5e13af25f4c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6afcd2d4161165fd976c55a9792dbcccd2d5d106",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6afcd2d4161165fd976c55a9792dbcccd2d5d106",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6afcd2d4161165fd976c55a9792dbcccd2d5d106",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6afcd2d4161165fd976c55a9792dbcccd2d5d106/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "15cc148fb817bc1eb91aa16e5d94e39ebafc11ee",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/15cc148fb817bc1eb91aa16e5d94e39ebafc11ee",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/15cc148fb817bc1eb91aa16e5d94e39ebafc11ee"
    }
  ],
  "stats": {
    "total": 281,
    "additions": 246,
    "deletions": 35
  },
  "files": [
    {
      "sha": "ace56aa251dfc10b02f15b49c1d32ac855d45fc0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -1,3 +1,25 @@\n+2020-12-10  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* aarch64-linux-tdep.c (aarch64_linux_restore_vreg) New function.\n+\t(aarch64_linux_sigframe_init): Call aarch64_linux_restore_vreg.\n+\t* aarch64-tdep.h (V_REGISTER_SIZE): Move to ...\n+\t* arch/aarch64.h: ... here.\n+\t* nat/aarch64-sve-linux-ptrace.c: Include endian.h.\n+\t(aarch64_maybe_swab128): New function.\n+\t(aarch64_sve_regs_copy_to_reg_buf)\n+\t(aarch64_sve_regs_copy_from_reg_buf): Adjust FPSIMD entries.\n+\t* trad-frame.c (trad_frame_reset_saved_regs): Initialize\n+\tthe data field.\n+\t(TF_REG_VALUE_BYTES): New enum value.\n+\t(trad_frame_value_bytes_p): New function.\n+\t(trad_frame_set_value_bytes): New function.\n+\t(trad_frame_set_reg_value_bytes): New function.\n+\t(trad_frame_get_prev_register): Handle register values saved as bytes.\n+\t* trad-frame.h (trad_frame_set_reg_value_bytes): New prototype.\n+\t(struct trad_frame_saved_reg) <data>: New field.\n+\t(trad_frame_set_value_bytes): New prototype.\n+\t(trad_frame_value_bytes_p): New prototype.\n+\n 2020-12-07  Mihails Strasuns  <mihails.strasuns@intel.com>\n \n \t* jit.c (mem_bfd*, bfd_open_from_target_memory): Removed."
    },
    {
      "sha": "1e8d8e9d6b33a3e46fd01de77924071eca05f061",
      "filename": "gdb/aarch64-linux-tdep.c",
      "status": "modified",
      "additions": 95,
      "deletions": 19,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/aarch64-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/aarch64-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-linux-tdep.c?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -180,6 +180,93 @@ read_aarch64_ctx (CORE_ADDR ctx_addr, enum bfd_endian byte_order,\n   return magic;\n }\n \n+/* Given CACHE, use the trad_frame* functions to restore the FPSIMD\n+   registers from a signal frame.\n+\n+   VREG_NUM is the number of the V register being restored, OFFSET is the\n+   address containing the register value, BYTE_ORDER is the endianness and\n+   HAS_SVE tells us if we have a valid SVE context or not.  */\n+\n+static void\n+aarch64_linux_restore_vreg (struct trad_frame_cache *cache, int num_regs,\n+\t\t\t    int vreg_num, CORE_ADDR offset,\n+\t\t\t    enum bfd_endian byte_order, bool has_sve)\n+{\n+  /* WARNING: SIMD state is laid out in memory in target-endian format.\n+\n+     So we have a couple cases to consider:\n+\n+     1 - If the target is big endian, then SIMD state is big endian,\n+     requiring a byteswap.\n+\n+     2 - If the target is little endian, then SIMD state is little endian, so\n+     no byteswap is needed. */\n+\n+  if (byte_order == BFD_ENDIAN_BIG)\n+    {\n+      gdb_byte buf[V_REGISTER_SIZE];\n+\n+      if (target_read_memory (offset, buf, V_REGISTER_SIZE) != 0)\n+\t{\n+\t  size_t size = V_REGISTER_SIZE/2;\n+\n+\t  /* Read the two halves of the V register in reverse byte order.  */\n+\t  CORE_ADDR u64 = extract_unsigned_integer (buf, size,\n+\t\t\t\t\t\t    byte_order);\n+\t  CORE_ADDR l64 = extract_unsigned_integer (buf + size, size,\n+\t\t\t\t\t\t    byte_order);\n+\n+\t  /* Copy the reversed bytes to the buffer.  */\n+\t  store_unsigned_integer (buf, size, BFD_ENDIAN_LITTLE, l64);\n+\t  store_unsigned_integer (buf + size , size, BFD_ENDIAN_LITTLE, u64);\n+\n+\t  /* Now we can store the correct bytes for the V register.  */\n+\t  trad_frame_set_reg_value_bytes (cache, AARCH64_V0_REGNUM + vreg_num,\n+\t\t\t\t\t  buf, V_REGISTER_SIZE);\n+\t  trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t  num_regs + AARCH64_Q0_REGNUM\n+\t\t\t\t\t  + vreg_num, buf, Q_REGISTER_SIZE);\n+\t  trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t  num_regs + AARCH64_D0_REGNUM\n+\t\t\t\t\t  + vreg_num, buf, D_REGISTER_SIZE);\n+\t  trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t  num_regs + AARCH64_S0_REGNUM\n+\t\t\t\t\t  + vreg_num, buf, S_REGISTER_SIZE);\n+\t  trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t  num_regs + AARCH64_H0_REGNUM\n+\t\t\t\t\t  + vreg_num, buf, H_REGISTER_SIZE);\n+\t  trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t  num_regs + AARCH64_B0_REGNUM\n+\t\t\t\t\t  + vreg_num, buf, B_REGISTER_SIZE);\n+\n+\t  if (has_sve)\n+\t    trad_frame_set_reg_value_bytes (cache,\n+\t\t\t\t\t    num_regs + AARCH64_SVE_V0_REGNUM\n+\t\t\t\t\t    + vreg_num, buf, V_REGISTER_SIZE);\n+\t}\n+      return;\n+    }\n+\n+  /* Little endian, just point at the address containing the register\n+     value.  */\n+  trad_frame_set_reg_addr (cache, AARCH64_V0_REGNUM + vreg_num, offset);\n+  trad_frame_set_reg_addr (cache, num_regs + AARCH64_Q0_REGNUM + vreg_num,\n+\t\t\t   offset);\n+  trad_frame_set_reg_addr (cache, num_regs + AARCH64_D0_REGNUM + vreg_num,\n+\t\t\t   offset);\n+  trad_frame_set_reg_addr (cache, num_regs + AARCH64_S0_REGNUM + vreg_num,\n+\t\t\t   offset);\n+  trad_frame_set_reg_addr (cache, num_regs + AARCH64_H0_REGNUM + vreg_num,\n+\t\t\t   offset);\n+  trad_frame_set_reg_addr (cache, num_regs + AARCH64_B0_REGNUM + vreg_num,\n+\t\t\t   offset);\n+\n+  if (has_sve)\n+    trad_frame_set_reg_addr (cache, num_regs + AARCH64_SVE_V0_REGNUM\n+\t\t\t     + vreg_num, offset);\n+\n+}\n+\n /* Implement the \"init\" method of struct tramp_frame.  */\n \n static void\n@@ -332,27 +419,16 @@ aarch64_linux_sigframe_init (const struct tramp_frame *self,\n \n       /* If there was no SVE section then set up the V registers.  */\n       if (sve_regs == 0)\n-\tfor (int i = 0; i < 32; i++)\n-\t  {\n-\t    CORE_ADDR offset = (fpsimd + AARCH64_FPSIMD_V0_OFFSET\n+\t{\n+\t  for (int i = 0; i < 32; i++)\n+\t    {\n+\t      CORE_ADDR offset = (fpsimd + AARCH64_FPSIMD_V0_OFFSET\n \t\t\t\t  + (i * AARCH64_FPSIMD_VREG_SIZE));\n \n-\t    trad_frame_set_reg_addr (this_cache, AARCH64_V0_REGNUM + i, offset);\n-\t    trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t     num_regs + AARCH64_Q0_REGNUM + i, offset);\n-\t    trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t     num_regs + AARCH64_D0_REGNUM + i, offset);\n-\t    trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t     num_regs + AARCH64_S0_REGNUM + i, offset);\n-\t    trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t     num_regs + AARCH64_H0_REGNUM + i, offset);\n-\t    trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t     num_regs + AARCH64_B0_REGNUM + i, offset);\n-\t    if (tdep->has_sve ())\n-\t      trad_frame_set_reg_addr (this_cache,\n-\t\t\t\t       num_regs + AARCH64_SVE_V0_REGNUM + i,\n-\t\t\t\t       offset);\n-\t  }\n+\t      aarch64_linux_restore_vreg (this_cache, num_regs, i, offset,\n+\t\t\t\t\t  byte_order, tdep->has_sve ());\n+\t    }\n+\t}\n     }\n \n   trad_frame_set_id (this_cache, frame_id_build (sp, func));"
    },
    {
      "sha": "7d035c1aecdc53f2409d22b222029448aefe99a7",
      "filename": "gdb/aarch64-tdep.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/aarch64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/aarch64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.h?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -48,7 +48,6 @@ struct regset;\n #define H_REGISTER_SIZE  2\n #define S_REGISTER_SIZE  4\n #define D_REGISTER_SIZE  8\n-#define V_REGISTER_SIZE 16\n #define Q_REGISTER_SIZE 16\n \n /* Total number of general (X) registers.  */"
    },
    {
      "sha": "b75352461a412e74aa8e397507ff76a1824de1c7",
      "filename": "gdb/arch/aarch64.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/arch/aarch64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/arch/aarch64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/aarch64.h?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -58,6 +58,8 @@ enum aarch64_regnum\n   AARCH64_LAST_V_ARG_REGNUM = AARCH64_V0_REGNUM + 7\n };\n \n+#define V_REGISTER_SIZE 16\n+\n /* Pseudo register base numbers.  */\n #define AARCH64_Q0_REGNUM 0\n #define AARCH64_D0_REGNUM (AARCH64_Q0_REGNUM + AARCH64_D_REGISTER_COUNT)"
    },
    {
      "sha": "5f08995f87bebc125b8c201adae7dde41cda9246",
      "filename": "gdb/nat/aarch64-sve-linux-ptrace.c",
      "status": "modified",
      "additions": 63,
      "deletions": 14,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/nat/aarch64-sve-linux-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/nat/aarch64-sve-linux-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/aarch64-sve-linux-ptrace.c?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -26,6 +26,7 @@\n #include \"arch/aarch64.h\"\n #include \"gdbsupport/common-regcache.h\"\n #include \"gdbsupport/byte-vector.h\"\n+#include <endian.h>\n \n /* See nat/aarch64-sve-linux-ptrace.h.  */\n \n@@ -142,6 +143,24 @@ aarch64_sve_get_sveregs (int tid)\n   return buf;\n }\n \n+/* If we are running in BE mode, byteswap the contents\n+   of SRC to DST for SIZE bytes.  Other, just copy the contents\n+   from SRC to DST.  */\n+\n+static void\n+aarch64_maybe_swab128 (gdb_byte *dst, const gdb_byte *src, size_t size)\n+{\n+  gdb_assert (src != nullptr && dst != nullptr);\n+  gdb_assert (size > 1);\n+\n+#if (__BYTE_ORDER == __BIG_ENDIAN)\n+  for (int i = 0; i < size - 1; i++)\n+    dst[i] = src[size - i];\n+#else\n+  memcpy (dst, src, size);\n+#endif\n+}\n+\n /* See nat/aarch64-sve-linux-ptrace.h.  */\n \n void\n@@ -184,34 +203,50 @@ aarch64_sve_regs_copy_to_reg_buf (struct reg_buffer_common *reg_buf,\n     }\n   else\n     {\n+      /* WARNING: SIMD state is laid out in memory in target-endian format,\n+\t while SVE state is laid out in an endianness-independent format (LE).\n+\n+\t So we have a couple cases to consider:\n+\n+\t 1 - If the target is big endian, then SIMD state is big endian,\n+\t requiring a byteswap.\n+\n+\t 2 - If the target is little endian, then SIMD state is little endian,\n+\t which matches the SVE format, so no byteswap is needed. */\n+\n       /* There is no SVE state yet - the register dump contains a fpsimd\n \t structure instead.  These registers still exist in the hardware, but\n \t the kernel has not yet initialised them, and so they will be null.  */\n \n-      char *zero_reg = (char *) alloca (SVE_PT_SVE_ZREG_SIZE (vq));\n+      gdb_byte *reg = (gdb_byte *) alloca (SVE_PT_SVE_ZREG_SIZE (vq));\n       struct user_fpsimd_state *fpsimd\n \t= (struct user_fpsimd_state *)(base + SVE_PT_FPSIMD_OFFSET);\n \n+      /* Make sure we have a zeroed register buffer.  We will need the zero\n+\t padding below.  */\n+      memset (reg, 0, SVE_PT_SVE_ZREG_SIZE (vq));\n+\n       /* Copy across the V registers from fpsimd structure to the Z registers,\n \t ensuring the non overlapping state is set to null.  */\n \n-      memset (zero_reg, 0, SVE_PT_SVE_ZREG_SIZE (vq));\n-\n       for (int i = 0; i < AARCH64_SVE_Z_REGS_NUM; i++)\n \t{\n-\t  memcpy (zero_reg, &fpsimd->vregs[i], sizeof (__int128_t));\n-\t  reg_buf->raw_supply (AARCH64_SVE_Z0_REGNUM + i, zero_reg);\n+\t  /* Handle big endian/little endian SIMD/SVE conversion.  */\n+\t  aarch64_maybe_swab128 (reg, (const gdb_byte *) &fpsimd->vregs[i],\n+\t\t\t\t V_REGISTER_SIZE);\n+\t  reg_buf->raw_supply (AARCH64_SVE_Z0_REGNUM + i, reg);\n \t}\n \n       reg_buf->raw_supply (AARCH64_FPSR_REGNUM, &fpsimd->fpsr);\n       reg_buf->raw_supply (AARCH64_FPCR_REGNUM, &fpsimd->fpcr);\n \n       /* Clear the SVE only registers.  */\n+      memset (reg, 0, SVE_PT_SVE_ZREG_SIZE (vq));\n \n       for (int i = 0; i < AARCH64_SVE_P_REGS_NUM; i++)\n-\treg_buf->raw_supply (AARCH64_SVE_P0_REGNUM + i, zero_reg);\n+\treg_buf->raw_supply (AARCH64_SVE_P0_REGNUM + i, reg);\n \n-      reg_buf->raw_supply (AARCH64_SVE_FFR_REGNUM, zero_reg);\n+      reg_buf->raw_supply (AARCH64_SVE_FFR_REGNUM, reg);\n     }\n }\n \n@@ -240,19 +275,19 @@ aarch64_sve_regs_copy_from_reg_buf (const struct reg_buffer_common *reg_buf,\n \t kernel, which is why we try to avoid it.  */\n \n       bool has_sve_state = false;\n-      char *zero_reg = (char *) alloca (SVE_PT_SVE_ZREG_SIZE (vq));\n+      gdb_byte *reg = (gdb_byte *) alloca (SVE_PT_SVE_ZREG_SIZE (vq));\n       struct user_fpsimd_state *fpsimd\n \t= (struct user_fpsimd_state *)(base + SVE_PT_FPSIMD_OFFSET);\n \n-      memset (zero_reg, 0, SVE_PT_SVE_ZREG_SIZE (vq));\n+      memset (reg, 0, SVE_PT_SVE_ZREG_SIZE (vq));\n \n       /* Check in the reg_buf if any of the Z registers are set after the\n \t first 128 bits, or if any of the other SVE registers are set.  */\n \n       for (int i = 0; i < AARCH64_SVE_Z_REGS_NUM; i++)\n \t{\n \t  has_sve_state |= reg_buf->raw_compare (AARCH64_SVE_Z0_REGNUM + i,\n-\t\t\t\t\t\t zero_reg, sizeof (__int128_t));\n+\t\t\t\t\t\t reg, sizeof (__int128_t));\n \t  if (has_sve_state)\n \t    break;\n \t}\n@@ -261,19 +296,31 @@ aarch64_sve_regs_copy_from_reg_buf (const struct reg_buffer_common *reg_buf,\n \tfor (int i = 0; i < AARCH64_SVE_P_REGS_NUM; i++)\n \t  {\n \t    has_sve_state |= reg_buf->raw_compare (AARCH64_SVE_P0_REGNUM + i,\n-\t\t\t\t\t\t   zero_reg, 0);\n+\t\t\t\t\t\t   reg, 0);\n \t    if (has_sve_state)\n \t      break;\n \t  }\n \n       if (!has_sve_state)\n \t  has_sve_state |= reg_buf->raw_compare (AARCH64_SVE_FFR_REGNUM,\n-\t\t\t\t\t\t zero_reg, 0);\n+\t\t\t\t\t\t reg, 0);\n \n       /* If no SVE state exists, then use the existing fpsimd structure to\n \t write out state and return.  */\n       if (!has_sve_state)\n \t{\n+\t  /* WARNING: SIMD state is laid out in memory in target-endian format,\n+\t     while SVE state is laid out in an endianness-independent format\n+\t     (LE).\n+\n+\t     So we have a couple cases to consider:\n+\n+\t     1 - If the target is big endian, then SIMD state is big endian,\n+\t     requiring a byteswap.\n+\n+\t     2 - If the target is little endian, then SIMD state is little\n+\t     endian, which matches the SVE format, so no byteswap is needed. */\n+\n \t  /* The collects of the Z registers will overflow the size of a vreg.\n \t     There is enough space in the structure to allow for this, but we\n \t     cannot overflow into the next register as we might not be\n@@ -284,8 +331,10 @@ aarch64_sve_regs_copy_from_reg_buf (const struct reg_buffer_common *reg_buf,\n \t      if (REG_VALID\n \t\t  == reg_buf->get_register_status (AARCH64_SVE_Z0_REGNUM + i))\n \t\t{\n-\t\t  reg_buf->raw_collect (AARCH64_SVE_Z0_REGNUM + i, zero_reg);\n-\t\t  memcpy (&fpsimd->vregs[i], zero_reg, sizeof (__int128_t));\n+\t\t  reg_buf->raw_collect (AARCH64_SVE_Z0_REGNUM + i, reg);\n+\t\t  /* Handle big endian/little endian SIMD/SVE conversion.  */\n+\t\t  aarch64_maybe_swab128 ((gdb_byte *) &fpsimd->vregs[i], reg,\n+\t\t\t\t\t V_REGISTER_SIZE);\n \t\t}\n \t    }\n "
    },
    {
      "sha": "8a1aa818aded96e97d9854a458b5b7765e5449c0",
      "filename": "gdb/trad-frame.c",
      "status": "modified",
      "additions": 45,
      "deletions": 1,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/trad-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/trad-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/trad-frame.c?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -56,6 +56,7 @@ trad_frame_reset_saved_regs (struct gdbarch *gdbarch,\n     {\n       regs[regnum].realreg = regnum;\n       regs[regnum].addr = -1;\n+      regs[regnum].data = nullptr;\n     }\n }\n \n@@ -83,7 +84,7 @@ trad_frame_alloc_saved_regs (struct frame_info *this_frame)\n   return trad_frame_alloc_saved_regs (gdbarch);\n }\n \n-enum { TF_REG_VALUE = -1, TF_REG_UNKNOWN = -2 };\n+enum { TF_REG_VALUE = -1, TF_REG_UNKNOWN = -2, TF_REG_VALUE_BYTES = -3 };\n \n int\n trad_frame_value_p (struct trad_frame_saved_reg this_saved_regs[], int regnum)\n@@ -106,6 +107,16 @@ trad_frame_realreg_p (struct trad_frame_saved_reg this_saved_regs[],\n \t  && this_saved_regs[regnum].addr == -1);\n }\n \n+/* See trad-frame.h.  */\n+\n+bool\n+trad_frame_value_bytes_p (struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t  int regnum)\n+{\n+  return (this_saved_regs[regnum].realreg == TF_REG_VALUE_BYTES\n+\t  && this_saved_regs[regnum].data != nullptr);\n+}\n+\n void\n trad_frame_set_value (struct trad_frame_saved_reg this_saved_regs[],\n \t\t      int regnum, LONGEST val)\n@@ -224,6 +235,35 @@ trad_frame_set_unknown (struct trad_frame_saved_reg this_saved_regs[],\n   this_saved_regs[regnum].addr = -1;\n }\n \n+/* See trad-frame.h.  */\n+\n+void\n+trad_frame_set_value_bytes (struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t    int regnum, const gdb_byte *bytes,\n+\t\t\t    size_t size)\n+{\n+  this_saved_regs[regnum].realreg = TF_REG_VALUE_BYTES;\n+\n+  /* Allocate the space and copy the data bytes.  */\n+  this_saved_regs[regnum].data = FRAME_OBSTACK_CALLOC (size, gdb_byte);\n+  memcpy (this_saved_regs[regnum].data, bytes, size);\n+}\n+\n+/* See trad-frame.h.  */\n+\n+void\n+trad_frame_set_reg_value_bytes (struct trad_frame_cache *this_trad_cache,\n+\t\t\t\tint regnum, const gdb_byte *bytes,\n+\t\t\t\tsize_t size)\n+{\n+  /* External interface for users of trad_frame_cache\n+     (who cannot access the prev_regs object directly).  */\n+  trad_frame_set_value_bytes (this_trad_cache->prev_regs, regnum, bytes,\n+\t\t\t      size);\n+}\n+\n+\n+\n struct value *\n trad_frame_get_prev_register (struct frame_info *this_frame,\n \t\t\t      struct trad_frame_saved_reg this_saved_regs[],\n@@ -240,6 +280,10 @@ trad_frame_get_prev_register (struct frame_info *this_frame,\n     /* The register's value is available.  */\n     return frame_unwind_got_constant (this_frame, regnum,\n \t\t\t\t      this_saved_regs[regnum].addr);\n+  else if (trad_frame_value_bytes_p (this_saved_regs, regnum))\n+    /* The register's value is available as a sequence of bytes.  */\n+    return frame_unwind_got_bytes (this_frame, regnum,\n+\t\t\t\t   this_saved_regs[regnum].data);\n   else\n     return frame_unwind_got_optimized (this_frame, regnum);\n }"
    },
    {
      "sha": "38db439579243138185ee5e67d770c7fc7eb7c77",
      "filename": "gdb/trad-frame.h",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/trad-frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6afcd2d4161165fd976c55a9792dbcccd2d5d106/gdb/trad-frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/trad-frame.h?ref=6afcd2d4161165fd976c55a9792dbcccd2d5d106",
      "patch": "@@ -52,6 +52,12 @@ void trad_frame_set_reg_regmap (struct trad_frame_cache *this_trad_cache,\n void trad_frame_set_reg_value (struct trad_frame_cache *this_cache,\n \t\t\t       int regnum, LONGEST val);\n \n+/* Given the cache in THIS_TRAD_CACHE, set the value of REGNUM to the bytes\n+   contained in BYTES with size SIZE.  */\n+void trad_frame_set_reg_value_bytes (struct trad_frame_cache *this_trad_cache,\n+\t\t\t\t     int regnum, const gdb_byte *bytes,\n+\t\t\t\t     size_t size);\n+\n struct value *trad_frame_get_register (struct trad_frame_cache *this_trad_cache,\n \t\t\t\t       struct frame_info *this_frame,\n \t\t\t\t       int regnum);\n@@ -86,6 +92,8 @@ struct trad_frame_saved_reg\n {\n   LONGEST addr; /* A CORE_ADDR fits in a longest.  */\n   int realreg;\n+  /* Register data (for values that don't fit in ADDR).  */\n+  gdb_byte *data;\n };\n \n /* Encode REGNUM value in the trad-frame.  */\n@@ -104,6 +112,12 @@ void trad_frame_set_addr (struct trad_frame_saved_reg this_trad_cache[],\n void trad_frame_set_unknown (struct trad_frame_saved_reg this_saved_regs[],\n \t\t\t     int regnum);\n \n+/* Encode REGNUM value in the trad-frame as a sequence of bytes.  This is\n+   useful when the value is larger than what primitive types can hold.  */\n+void trad_frame_set_value_bytes (struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t\t int regnum, const gdb_byte *bytes,\n+\t\t\t\t size_t size);\n+\n /* Convenience functions, return non-zero if the register has been\n    encoded as specified.  */\n int trad_frame_value_p (struct trad_frame_saved_reg this_saved_regs[],\n@@ -113,6 +127,11 @@ int trad_frame_addr_p (struct trad_frame_saved_reg this_saved_regs[],\n int trad_frame_realreg_p (struct trad_frame_saved_reg this_saved_regs[],\n \t\t\t  int regnum);\n \n+/* Return TRUE if REGNUM is stored as a sequence of bytes, and FALSE\n+   otherwise.  */\n+bool trad_frame_value_bytes_p (struct trad_frame_saved_reg this_saved_regs[],\n+\t\t\t      int regnum);\n+\n /* Reset the save regs cache, setting register values to -1.  */\n void trad_frame_reset_saved_regs (struct gdbarch *gdbarch,\n \t\t\t\t  struct trad_frame_saved_reg *regs);"
    }
  ]
}