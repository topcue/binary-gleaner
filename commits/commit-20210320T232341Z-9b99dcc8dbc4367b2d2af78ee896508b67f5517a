{
  "sha": "9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWI5OWRjYzhkYmM0MzY3YjJkMmFmNzhlZTg5NjUwOGI2N2Y1NTE3YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-20T23:23:40Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-20T23:23:41Z"
    },
    "message": "Move quick_symbol_functions to a new header\n\nThis introduces a new header, quick-symbol.h, and moves\nquick_symbol_functions and related typedefs into it.\n\ngdb/ChangeLog\n2021-03-20  Tom Tromey  <tom@tromey.com>\n\n\t* symfile.h (symbol_compare_ftype, symbol_filename_ftype)\n\t(expand_symtabs_file_matcher_ftype)\n\t(expand_symtabs_symbol_matcher_ftype)\n\t(expand_symtabs_exp_notify_ftype, struct quick_symbol_functions):\n\tMove to quick-symbol.h.\n\t* quick-symbol.h: New file.",
    "tree": {
      "sha": "f7594286d4adcb185600a7bbb57765a5f030f461",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f7594286d4adcb185600a7bbb57765a5f030f461"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4d080b4687deb2441a81762f3b01fc51cd13bd97",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d080b4687deb2441a81762f3b01fc51cd13bd97",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4d080b4687deb2441a81762f3b01fc51cd13bd97"
    }
  ],
  "stats": {
    "total": 443,
    "additions": 238,
    "deletions": 205
  },
  "files": [
    {
      "sha": "82a82c9795c2e6acf688073332ccb0740b1610f3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
      "patch": "@@ -1,3 +1,12 @@\n+2021-03-20  Tom Tromey  <tom@tromey.com>\n+\n+\t* symfile.h (symbol_compare_ftype, symbol_filename_ftype)\n+\t(expand_symtabs_file_matcher_ftype)\n+\t(expand_symtabs_symbol_matcher_ftype)\n+\t(expand_symtabs_exp_notify_ftype, struct quick_symbol_functions):\n+\tMove to quick-symbol.h.\n+\t* quick-symbol.h: New file.\n+\n 2021-03-20  Tom Tromey  <tom@tromey.com>\n \n \t* symtab.c (iterate_over_symtabs, expand_symtab_containing_pc)"
    },
    {
      "sha": "fa5f5012211989d2e2101751049037a83b8ed2a6",
      "filename": "gdb/quick-symbol.h",
      "status": "added",
      "additions": 228,
      "deletions": 0,
      "changes": 228,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/quick-symbol.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/quick-symbol.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/quick-symbol.h?ref=9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
      "patch": "@@ -0,0 +1,228 @@\n+/* \"Quick\" symbol functions\n+\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_QUICK_SYMBOL_H\n+#define GDB_QUICK_SYMBOL_H\n+\n+/* Comparison function for symbol look ups.  */\n+\n+typedef int (symbol_compare_ftype) (const char *string1,\n+\t\t\t\t    const char *string2);\n+\n+/* Callback for quick_symbol_functions->map_symbol_filenames.  */\n+\n+typedef void (symbol_filename_ftype) (const char *filename,\n+\t\t\t\t      const char *fullname, void *data);\n+\n+/* Callback for quick_symbol_functions->expand_symtabs_matching\n+   to match a file name.  */\n+\n+typedef bool (expand_symtabs_file_matcher_ftype) (const char *filename,\n+\t\t\t\t\t\t  bool basenames);\n+\n+/* Callback for quick_symbol_functions->expand_symtabs_matching\n+   to match a symbol name.  */\n+\n+typedef bool (expand_symtabs_symbol_matcher_ftype) (const char *name);\n+\n+/* Callback for quick_symbol_functions->expand_symtabs_matching\n+   to be called after a symtab has been expanded.  */\n+\n+typedef void (expand_symtabs_exp_notify_ftype) (compunit_symtab *symtab);\n+\n+/* The \"quick\" symbol functions exist so that symbol readers can\n+   avoiding an initial read of all the symbols.  For example, symbol\n+   readers might choose to use the \"partial symbol table\" utilities,\n+   which is one implementation of the quick symbol functions.\n+\n+   The quick symbol functions are generally opaque: the underlying\n+   representation is hidden from the caller.\n+\n+   In general, these functions should only look at whatever special\n+   index the symbol reader creates -- looking through the symbol\n+   tables themselves is handled by generic code.  If a function is\n+   defined as returning a \"symbol table\", this means that the function\n+   should only return a newly-created symbol table; it should not\n+   examine pre-existing ones.\n+\n+   The exact list of functions here was determined in an ad hoc way\n+   based on gdb's history.  */\n+\n+struct quick_symbol_functions\n+{\n+  /* Return true if this objfile has any \"partial\" symbols\n+     available.  */\n+  bool (*has_symbols) (struct objfile *objfile);\n+\n+  /* Return the symbol table for the \"last\" file appearing in\n+     OBJFILE.  */\n+  struct symtab *(*find_last_source_symtab) (struct objfile *objfile);\n+\n+  /* Forget all cached full file names for OBJFILE.  */\n+  void (*forget_cached_source_info) (struct objfile *objfile);\n+\n+  /* Expand and iterate over each \"partial\" symbol table in OBJFILE\n+     where the source file is named NAME.\n+\n+     If NAME is not absolute, a match after a '/' in the symbol table's\n+     file name will also work, REAL_PATH is NULL then.  If NAME is\n+     absolute then REAL_PATH is non-NULL absolute file name as resolved\n+     via gdb_realpath from NAME.\n+\n+     If a match is found, the \"partial\" symbol table is expanded.\n+     Then, this calls iterate_over_some_symtabs (or equivalent) over\n+     all newly-created symbol tables, passing CALLBACK to it.\n+     The result of this call is returned.  */\n+  bool (*map_symtabs_matching_filename)\n+    (struct objfile *objfile, const char *name, const char *real_path,\n+     gdb::function_view<bool (symtab *)> callback);\n+\n+  /* Check to see if the symbol is defined in a \"partial\" symbol table\n+     of OBJFILE.  BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,\n+     depending on whether we want to search global symbols or static\n+     symbols.  NAME is the name of the symbol to look for.  DOMAIN\n+     indicates what sort of symbol to search for.\n+\n+     Returns the newly-expanded compunit in which the symbol is\n+     defined, or NULL if no such symbol table exists.  If OBJFILE\n+     contains !TYPE_OPAQUE symbol prefer its compunit.  If it contains\n+     only TYPE_OPAQUE symbol(s), return at least that compunit.  */\n+  struct compunit_symtab *(*lookup_symbol) (struct objfile *objfile,\n+\t\t\t\t\t    block_enum block_index,\n+\t\t\t\t\t    const char *name,\n+\t\t\t\t\t    domain_enum domain);\n+\n+  /* Check to see if the global symbol is defined in a \"partial\" symbol table\n+     of OBJFILE. NAME is the name of the symbol to look for.  DOMAIN\n+     indicates what sort of symbol to search for.\n+\n+     If found, sets *symbol_found_p to true and returns the symbol language.\n+     defined, or NULL if no such symbol table exists.  */\n+  enum language (*lookup_global_symbol_language) (struct objfile *objfile,\n+\t\t\t\t\t\t  const char *name,\n+\t\t\t\t\t\t  domain_enum domain,\n+\t\t\t\t\t\t  bool *symbol_found_p);\n+\n+  /* Print statistics about any indices loaded for OBJFILE.  The\n+     statistics should be printed to gdb_stdout.  This is used for\n+     \"maint print statistics\".  */\n+  void (*print_stats) (struct objfile *objfile);\n+\n+  /* Dump any indices loaded for OBJFILE.  The dump should go to\n+     gdb_stdout.  This is used for \"maint print objfiles\".  */\n+  void (*dump) (struct objfile *objfile);\n+\n+  /* Find all the symbols in OBJFILE named FUNC_NAME, and ensure that\n+     the corresponding symbol tables are loaded.  */\n+  void (*expand_symtabs_for_function) (struct objfile *objfile,\n+\t\t\t\t       const char *func_name);\n+\n+  /* Read all symbol tables associated with OBJFILE.  */\n+  void (*expand_all_symtabs) (struct objfile *objfile);\n+\n+  /* Read all symbol tables associated with OBJFILE which have\n+     symtab_to_fullname equal to FULLNAME.\n+     This is for the purposes of examining code only, e.g., expand_line_sal.\n+     The routine may ignore debug info that is known to not be useful with\n+     code, e.g., DW_TAG_type_unit for dwarf debug info.  */\n+  void (*expand_symtabs_with_fullname) (struct objfile *objfile,\n+\t\t\t\t\tconst char *fullname);\n+\n+  /* Find global or static symbols in all tables that are in DOMAIN\n+     and for which MATCH (symbol name, NAME) == 0, passing each to \n+     CALLBACK, reading in partial symbol tables as needed.  Look\n+     through global symbols if GLOBAL and otherwise static symbols.\n+     Passes NAME and NAMESPACE to CALLBACK with each symbol\n+     found.  After each block is processed, passes NULL to CALLBACK.\n+     MATCH must be weaker than strcmp_iw_ordered in the sense that\n+     strcmp_iw_ordered(x,y) == 0 --> MATCH(x,y) == 0.  ORDERED_COMPARE,\n+     if non-null, must be an ordering relation compatible with\n+     strcmp_iw_ordered in the sense that\n+\t    strcmp_iw_ordered(x,y) == 0 --> ORDERED_COMPARE(x,y) == 0\n+     and \n+\t    strcmp_iw_ordered(x,y) <= 0 --> ORDERED_COMPARE(x,y) <= 0\n+     (allowing strcmp_iw_ordered(x,y) < 0 while ORDERED_COMPARE(x, y) == 0).\n+     CALLBACK returns true to indicate that the scan should continue, or\n+     false to indicate that the scan should be terminated.  */\n+\n+  void (*map_matching_symbols)\n+    (struct objfile *,\n+     const lookup_name_info &lookup_name,\n+     domain_enum domain,\n+     int global,\n+     gdb::function_view<symbol_found_callback_ftype> callback,\n+     symbol_compare_ftype *ordered_compare);\n+\n+  /* Expand all symbol tables in OBJFILE matching some criteria.\n+\n+     FILE_MATCHER is called for each file in OBJFILE.  The file name\n+     is passed to it.  If the matcher returns false, the file is\n+     skipped.  If FILE_MATCHER is NULL the file is not skipped.  If\n+     BASENAMES is true the matcher should consider only file base\n+     names (the passed file name is already only the lbasename'd\n+     part).\n+\n+     If the file is not skipped, and SYMBOL_MATCHER and LOOKUP_NAME are NULL,\n+     the symbol table is expanded.\n+\n+     Otherwise, individual symbols are considered.\n+\n+     If KIND does not match, the symbol is skipped.\n+\n+     If the symbol name does not match LOOKUP_NAME, the symbol is skipped.\n+\n+     If SYMBOL_MATCHER returns false, then the symbol is skipped.\n+\n+     Otherwise, the symbol's symbol table is expanded.  */\n+  void (*expand_symtabs_matching)\n+    (struct objfile *objfile,\n+     gdb::function_view<expand_symtabs_file_matcher_ftype> file_matcher,\n+     const lookup_name_info *lookup_name,\n+     gdb::function_view<expand_symtabs_symbol_matcher_ftype> symbol_matcher,\n+     gdb::function_view<expand_symtabs_exp_notify_ftype> expansion_notify,\n+     enum search_domain kind);\n+\n+  /* Return the comp unit from OBJFILE that contains PC and\n+     SECTION.  Return NULL if there is no such compunit.  This\n+     should return the compunit that contains a symbol whose\n+     address exactly matches PC, or, if there is no exact match, the\n+     compunit that contains a symbol whose address is closest to\n+     PC.  */\n+  struct compunit_symtab *(*find_pc_sect_compunit_symtab)\n+    (struct objfile *objfile, struct bound_minimal_symbol msymbol,\n+     CORE_ADDR pc, struct obj_section *section, int warn_if_readin);\n+\n+  /* Return the comp unit from OBJFILE that contains a symbol at\n+     ADDRESS.  Return NULL if there is no such comp unit.  Unlike\n+     find_pc_sect_compunit_symtab, any sort of symbol (not just text\n+     symbols) can be considered, and only exact address matches are\n+     considered.  This pointer may be NULL.  */\n+  struct compunit_symtab *(*find_compunit_symtab_by_address)\n+    (struct objfile *objfile, CORE_ADDR address);\n+\n+  /* Call a callback for every file defined in OBJFILE whose symtab is\n+     not already read in.  FUN is the callback.  It is passed the file's\n+     FILENAME, the file's FULLNAME (if need_fullname is non-zero), and\n+     the DATA passed to this function.  */\n+  void (*map_symbol_filenames) (struct objfile *objfile,\n+\t\t\t\tsymbol_filename_ftype *fun, void *data,\n+\t\t\t\tint need_fullname);\n+};\n+\n+#endif /* GDB_QUICK_SYMBOL_H */"
    },
    {
      "sha": "c87bbed83d83fe4943e8214da4e85cb656fb5c6b",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 1,
      "deletions": 205,
      "changes": 206,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b99dcc8dbc4367b2d2af78ee896508b67f5517a/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=9b99dcc8dbc4367b2d2af78ee896508b67f5517a",
      "patch": "@@ -28,6 +28,7 @@\n #include \"gdb_bfd.h\"\n #include \"gdbsupport/function-view.h\"\n #include \"target-section.h\"\n+#include \"quick-symbol.h\"\n \n /* Opaque declarations.  */\n struct target_section;\n@@ -41,11 +42,6 @@ struct agent_expr;\n struct axs_value;\n class probe;\n \n-/* Comparison function for symbol look ups.  */\n-\n-typedef int (symbol_compare_ftype) (const char *string1,\n-\t\t\t\t    const char *string2);\n-\n struct other_sections\n {\n   other_sections (CORE_ADDR addr_, std::string &&name_, int sectindex_)\n@@ -107,206 +103,6 @@ struct symfile_segment_data\n \n using symfile_segment_data_up = std::unique_ptr<symfile_segment_data>;\n \n-/* Callback for quick_symbol_functions->map_symbol_filenames.  */\n-\n-typedef void (symbol_filename_ftype) (const char *filename,\n-\t\t\t\t      const char *fullname, void *data);\n-\n-/* Callback for quick_symbol_functions->expand_symtabs_matching\n-   to match a file name.  */\n-\n-typedef bool (expand_symtabs_file_matcher_ftype) (const char *filename,\n-\t\t\t\t\t\t  bool basenames);\n-\n-/* Callback for quick_symbol_functions->expand_symtabs_matching\n-   to match a symbol name.  */\n-\n-typedef bool (expand_symtabs_symbol_matcher_ftype) (const char *name);\n-\n-/* Callback for quick_symbol_functions->expand_symtabs_matching\n-   to be called after a symtab has been expanded.  */\n-\n-typedef void (expand_symtabs_exp_notify_ftype) (compunit_symtab *symtab);\n-\n-/* The \"quick\" symbol functions exist so that symbol readers can\n-   avoiding an initial read of all the symbols.  For example, symbol\n-   readers might choose to use the \"partial symbol table\" utilities,\n-   which is one implementation of the quick symbol functions.\n-\n-   The quick symbol functions are generally opaque: the underlying\n-   representation is hidden from the caller.\n-\n-   In general, these functions should only look at whatever special\n-   index the symbol reader creates -- looking through the symbol\n-   tables themselves is handled by generic code.  If a function is\n-   defined as returning a \"symbol table\", this means that the function\n-   should only return a newly-created symbol table; it should not\n-   examine pre-existing ones.\n-\n-   The exact list of functions here was determined in an ad hoc way\n-   based on gdb's history.  */\n-\n-struct quick_symbol_functions\n-{\n-  /* Return true if this objfile has any \"partial\" symbols\n-     available.  */\n-  bool (*has_symbols) (struct objfile *objfile);\n-\n-  /* Return the symbol table for the \"last\" file appearing in\n-     OBJFILE.  */\n-  struct symtab *(*find_last_source_symtab) (struct objfile *objfile);\n-\n-  /* Forget all cached full file names for OBJFILE.  */\n-  void (*forget_cached_source_info) (struct objfile *objfile);\n-\n-  /* Expand and iterate over each \"partial\" symbol table in OBJFILE\n-     where the source file is named NAME.\n-\n-     If NAME is not absolute, a match after a '/' in the symbol table's\n-     file name will also work, REAL_PATH is NULL then.  If NAME is\n-     absolute then REAL_PATH is non-NULL absolute file name as resolved\n-     via gdb_realpath from NAME.\n-\n-     If a match is found, the \"partial\" symbol table is expanded.\n-     Then, this calls iterate_over_some_symtabs (or equivalent) over\n-     all newly-created symbol tables, passing CALLBACK to it.\n-     The result of this call is returned.  */\n-  bool (*map_symtabs_matching_filename)\n-    (struct objfile *objfile, const char *name, const char *real_path,\n-     gdb::function_view<bool (symtab *)> callback);\n-\n-  /* Check to see if the symbol is defined in a \"partial\" symbol table\n-     of OBJFILE.  BLOCK_INDEX should be either GLOBAL_BLOCK or STATIC_BLOCK,\n-     depending on whether we want to search global symbols or static\n-     symbols.  NAME is the name of the symbol to look for.  DOMAIN\n-     indicates what sort of symbol to search for.\n-\n-     Returns the newly-expanded compunit in which the symbol is\n-     defined, or NULL if no such symbol table exists.  If OBJFILE\n-     contains !TYPE_OPAQUE symbol prefer its compunit.  If it contains\n-     only TYPE_OPAQUE symbol(s), return at least that compunit.  */\n-  struct compunit_symtab *(*lookup_symbol) (struct objfile *objfile,\n-\t\t\t\t\t    block_enum block_index,\n-\t\t\t\t\t    const char *name,\n-\t\t\t\t\t    domain_enum domain);\n-\n-  /* Check to see if the global symbol is defined in a \"partial\" symbol table\n-     of OBJFILE. NAME is the name of the symbol to look for.  DOMAIN\n-     indicates what sort of symbol to search for.\n-\n-     If found, sets *symbol_found_p to true and returns the symbol language.\n-     defined, or NULL if no such symbol table exists.  */\n-  enum language (*lookup_global_symbol_language) (struct objfile *objfile,\n-\t\t\t\t\t\t  const char *name,\n-\t\t\t\t\t\t  domain_enum domain,\n-\t\t\t\t\t\t  bool *symbol_found_p);\n-\n-  /* Print statistics about any indices loaded for OBJFILE.  The\n-     statistics should be printed to gdb_stdout.  This is used for\n-     \"maint print statistics\".  */\n-  void (*print_stats) (struct objfile *objfile);\n-\n-  /* Dump any indices loaded for OBJFILE.  The dump should go to\n-     gdb_stdout.  This is used for \"maint print objfiles\".  */\n-  void (*dump) (struct objfile *objfile);\n-\n-  /* Find all the symbols in OBJFILE named FUNC_NAME, and ensure that\n-     the corresponding symbol tables are loaded.  */\n-  void (*expand_symtabs_for_function) (struct objfile *objfile,\n-\t\t\t\t       const char *func_name);\n-\n-  /* Read all symbol tables associated with OBJFILE.  */\n-  void (*expand_all_symtabs) (struct objfile *objfile);\n-\n-  /* Read all symbol tables associated with OBJFILE which have\n-     symtab_to_fullname equal to FULLNAME.\n-     This is for the purposes of examining code only, e.g., expand_line_sal.\n-     The routine may ignore debug info that is known to not be useful with\n-     code, e.g., DW_TAG_type_unit for dwarf debug info.  */\n-  void (*expand_symtabs_with_fullname) (struct objfile *objfile,\n-\t\t\t\t\tconst char *fullname);\n-\n-  /* Find global or static symbols in all tables that are in DOMAIN\n-     and for which MATCH (symbol name, NAME) == 0, passing each to \n-     CALLBACK, reading in partial symbol tables as needed.  Look\n-     through global symbols if GLOBAL and otherwise static symbols.\n-     Passes NAME and NAMESPACE to CALLBACK with each symbol\n-     found.  After each block is processed, passes NULL to CALLBACK.\n-     MATCH must be weaker than strcmp_iw_ordered in the sense that\n-     strcmp_iw_ordered(x,y) == 0 --> MATCH(x,y) == 0.  ORDERED_COMPARE,\n-     if non-null, must be an ordering relation compatible with\n-     strcmp_iw_ordered in the sense that\n-\t    strcmp_iw_ordered(x,y) == 0 --> ORDERED_COMPARE(x,y) == 0\n-     and \n-\t    strcmp_iw_ordered(x,y) <= 0 --> ORDERED_COMPARE(x,y) <= 0\n-     (allowing strcmp_iw_ordered(x,y) < 0 while ORDERED_COMPARE(x, y) == 0).\n-     CALLBACK returns true to indicate that the scan should continue, or\n-     false to indicate that the scan should be terminated.  */\n-\n-  void (*map_matching_symbols)\n-    (struct objfile *,\n-     const lookup_name_info &lookup_name,\n-     domain_enum domain,\n-     int global,\n-     gdb::function_view<symbol_found_callback_ftype> callback,\n-     symbol_compare_ftype *ordered_compare);\n-\n-  /* Expand all symbol tables in OBJFILE matching some criteria.\n-\n-     FILE_MATCHER is called for each file in OBJFILE.  The file name\n-     is passed to it.  If the matcher returns false, the file is\n-     skipped.  If FILE_MATCHER is NULL the file is not skipped.  If\n-     BASENAMES is true the matcher should consider only file base\n-     names (the passed file name is already only the lbasename'd\n-     part).\n-\n-     If the file is not skipped, and SYMBOL_MATCHER and LOOKUP_NAME are NULL,\n-     the symbol table is expanded.\n-\n-     Otherwise, individual symbols are considered.\n-\n-     If KIND does not match, the symbol is skipped.\n-\n-     If the symbol name does not match LOOKUP_NAME, the symbol is skipped.\n-\n-     If SYMBOL_MATCHER returns false, then the symbol is skipped.\n-\n-     Otherwise, the symbol's symbol table is expanded.  */\n-  void (*expand_symtabs_matching)\n-    (struct objfile *objfile,\n-     gdb::function_view<expand_symtabs_file_matcher_ftype> file_matcher,\n-     const lookup_name_info *lookup_name,\n-     gdb::function_view<expand_symtabs_symbol_matcher_ftype> symbol_matcher,\n-     gdb::function_view<expand_symtabs_exp_notify_ftype> expansion_notify,\n-     enum search_domain kind);\n-\n-  /* Return the comp unit from OBJFILE that contains PC and\n-     SECTION.  Return NULL if there is no such compunit.  This\n-     should return the compunit that contains a symbol whose\n-     address exactly matches PC, or, if there is no exact match, the\n-     compunit that contains a symbol whose address is closest to\n-     PC.  */\n-  struct compunit_symtab *(*find_pc_sect_compunit_symtab)\n-    (struct objfile *objfile, struct bound_minimal_symbol msymbol,\n-     CORE_ADDR pc, struct obj_section *section, int warn_if_readin);\n-\n-  /* Return the comp unit from OBJFILE that contains a symbol at\n-     ADDRESS.  Return NULL if there is no such comp unit.  Unlike\n-     find_pc_sect_compunit_symtab, any sort of symbol (not just text\n-     symbols) can be considered, and only exact address matches are\n-     considered.  This pointer may be NULL.  */\n-  struct compunit_symtab *(*find_compunit_symtab_by_address)\n-    (struct objfile *objfile, CORE_ADDR address);\n-\n-  /* Call a callback for every file defined in OBJFILE whose symtab is\n-     not already read in.  FUN is the callback.  It is passed the file's\n-     FILENAME, the file's FULLNAME (if need_fullname is non-zero), and\n-     the DATA passed to this function.  */\n-  void (*map_symbol_filenames) (struct objfile *objfile,\n-\t\t\t\tsymbol_filename_ftype *fun, void *data,\n-\t\t\t\tint need_fullname);\n-};\n-\n /* Structure of functions used for probe support.  If one of these functions\n    is provided, all must be.  */\n "
    }
  ]
}