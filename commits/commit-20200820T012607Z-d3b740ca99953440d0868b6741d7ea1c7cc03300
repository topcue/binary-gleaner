{
  "sha": "d3b740ca99953440d0868b6741d7ea1c7cc03300",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDNiNzQwY2E5OTk1MzQ0MGQwODY4YjY3NDFkN2VhMWM3Y2MwMzMwMA==",
  "commit": {
    "author": {
      "name": "Martin Liska",
      "email": "mliska@suse.cz",
      "date": "2020-08-15T17:48:17Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-20T01:26:07Z"
    },
    "message": "Use libiberty hash in gas/symbols.c.\n\n\t* symbols.c (struct symbol_entry): New.\n\t(hash_symbol_entry): Likewise.\n\t(eq_symbol_entry): Likewise.\n\t(symbol_entry_alloc): Likewise.\n\t(symbol_entry_find): Likewise.\n\t(local_symbol_make): Use htab hash table.\n\t(local_symbol_convert): Likewise.\n\t(symbol_table_insert): Likewise.\n\t(symbol_find_exact_noref): Likewise.\n\t(resolve_local_symbol): Likewise.\n\t(resolve_local_symbol_values): Likewise.\n\t(symbol_begin): Likewise.\n\t(symbol_print_statistics): Likewise.",
    "tree": {
      "sha": "7b29cf801cb454e77390dae87c4e4f1d7d92057c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7b29cf801cb454e77390dae87c4e4f1d7d92057c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3b740ca99953440d0868b6741d7ea1c7cc03300",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3b740ca99953440d0868b6741d7ea1c7cc03300",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3b740ca99953440d0868b6741d7ea1c7cc03300",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3b740ca99953440d0868b6741d7ea1c7cc03300/comments",
  "author": {
    "login": "marxin",
    "id": 2658545,
    "node_id": "MDQ6VXNlcjI2NTg1NDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/marxin",
    "html_url": "https://github.com/marxin",
    "followers_url": "https://api.github.com/users/marxin/followers",
    "following_url": "https://api.github.com/users/marxin/following{/other_user}",
    "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/marxin/subscriptions",
    "organizations_url": "https://api.github.com/users/marxin/orgs",
    "repos_url": "https://api.github.com/users/marxin/repos",
    "events_url": "https://api.github.com/users/marxin/events{/privacy}",
    "received_events_url": "https://api.github.com/users/marxin/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "32e4c1c2d7adfa71121b70c544c721b8c04b39f5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/32e4c1c2d7adfa71121b70c544c721b8c04b39f5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/32e4c1c2d7adfa71121b70c544c721b8c04b39f5"
    }
  ],
  "stats": {
    "total": 133,
    "additions": 95,
    "deletions": 38
  },
  "files": [
    {
      "sha": "aaa5d16b727aef0cddf0b57cc9f20900c9d53b3f",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3b740ca99953440d0868b6741d7ea1c7cc03300/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3b740ca99953440d0868b6741d7ea1c7cc03300/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=d3b740ca99953440d0868b6741d7ea1c7cc03300",
      "patch": "@@ -1,3 +1,19 @@\n+2020-08-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* symbols.c (struct symbol_entry): New.\n+\t(hash_symbol_entry): Likewise.\n+\t(eq_symbol_entry): Likewise.\n+\t(symbol_entry_alloc): Likewise.\n+\t(symbol_entry_find): Likewise.\n+\t(local_symbol_make): Use htab hash table.\n+\t(local_symbol_convert): Likewise.\n+\t(symbol_table_insert): Likewise.\n+\t(symbol_find_exact_noref): Likewise.\n+\t(resolve_local_symbol): Likewise.\n+\t(resolve_local_symbol_values): Likewise.\n+\t(symbol_begin): Likewise.\n+\t(symbol_print_statistics): Likewise.\n+\n 2020-08-20  Martin Liska  <mliska@suse.cz>\n \n \t* read.c (struct po_entry): New."
    },
    {
      "sha": "587d3b7efe30232548f75cb6eb83787fb8406e63",
      "filename": "gas/symbols.c",
      "status": "modified",
      "additions": 79,
      "deletions": 38,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3b740ca99953440d0868b6741d7ea1c7cc03300/gas/symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3b740ca99953440d0868b6741d7ea1c7cc03300/gas/symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/symbols.c?ref=d3b740ca99953440d0868b6741d7ea1c7cc03300",
      "patch": "@@ -151,6 +151,57 @@ struct local_symbol\n #endif\n };\n \n+struct symbol_entry\n+{\n+  const char *symbol_name;\n+  hashval_t hash;\n+  void *symbol;\n+};\n+\n+typedef struct symbol_entry symbol_entry_t;\n+\n+/* Hash function for a symbol_entry.  */\n+\n+static hashval_t\n+hash_symbol_entry (const void *e)\n+{\n+  symbol_entry_t *entry = (symbol_entry_t *) e;\n+  if (entry->hash == 0)\n+    entry->hash = htab_hash_string (entry->symbol_name);\n+\n+  return entry->hash;\n+}\n+\n+/* Equality function for a symbol_entry.  */\n+\n+static int\n+eq_symbol_entry (const void *a, const void *b)\n+{\n+  const symbol_entry_t *ea = (const symbol_entry_t *) a;\n+  const symbol_entry_t *eb = (const symbol_entry_t *) b;\n+\n+  return strcmp (ea->symbol_name, eb->symbol_name) == 0;\n+}\n+\n+static symbol_entry_t *\n+symbol_entry_alloc (const char *symbol_name, void *symbol)\n+{\n+  symbol_entry_t *entry = XNEW (symbol_entry_t);\n+  entry->symbol_name = symbol_name;\n+  entry->hash = 0;\n+  entry->symbol = symbol;\n+  return entry;\n+}\n+\n+static void *\n+symbol_entry_find (htab_t table, const char *symbol_name)\n+{\n+  symbol_entry_t needle = { symbol_name, 0, NULL };\n+  symbol_entry_t *entry = htab_find (table, &needle);\n+  return entry != NULL ? entry->symbol : NULL;\n+}\n+\n+\n #define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)\n #define local_symbol_mark_converted(l) ((l)->lsy_section = reg_section)\n #define local_symbol_resolved_p(l) ((l)->lsy_flags.sy_resolved)\n@@ -169,10 +220,10 @@ extern int new_broken_words;\n #endif\n \n /* symbol-name => struct symbol pointer */\n-static struct hash_control *sy_hash;\n+static htab_t sy_hash;\n \n /* Table of local symbols.  */\n-static struct hash_control *local_hash;\n+static htab_t local_hash;\n \n /* Below are commented in \"symbols.h\".  */\n symbolS *symbol_rootP;\n@@ -340,7 +391,7 @@ local_symbol_make (const char *name, segT section, valueT val, fragS *frag)\n   local_symbol_set_frag (ret, frag);\n   ret->lsy_value = val;\n \n-  hash_jam (local_hash, name_copy, (void *) ret);\n+  htab_insert (local_hash, symbol_entry_alloc (name_copy, ret));\n \n   return ret;\n }\n@@ -377,7 +428,7 @@ local_symbol_convert (struct local_symbol *locsym)\n   local_symbol_mark_converted (locsym);\n   local_symbol_set_real_symbol (locsym, ret);\n \n-  hash_jam (local_hash, locsym->lsy_name, NULL);\n+  htab_insert (local_hash, symbol_entry_alloc (locsym->lsy_name, NULL));\n \n   return ret;\n }\n@@ -616,26 +667,16 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n void\n symbol_table_insert (symbolS *symbolP)\n {\n-  const char *error_string;\n-\n   know (symbolP);\n   know (S_GET_NAME (symbolP));\n \n   if (LOCAL_SYMBOL_CHECK (symbolP))\n-    {\n-      error_string = hash_jam (local_hash, S_GET_NAME (symbolP),\n-\t\t\t       (void *) symbolP);\n-      if (error_string != NULL)\n-\tas_fatal (_(\"inserting \\\"%s\\\" into symbol table failed: %s\"),\n-\t\t  S_GET_NAME (symbolP), error_string);\n-      return;\n-    }\n-\n-  if ((error_string = hash_jam (sy_hash, S_GET_NAME (symbolP), (void *) symbolP)))\n-    {\n-      as_fatal (_(\"inserting \\\"%s\\\" into symbol table failed: %s\"),\n-\t\tS_GET_NAME (symbolP), error_string);\n-    }\t\t\t\t/* on error  */\n+    htab_insert (local_hash,\n+\t\t symbol_entry_alloc (S_GET_NAME (symbolP),\n+\t\t\t\t     (struct local_symbol *)symbolP));\n+  else\n+    htab_insert (sy_hash, symbol_entry_alloc (S_GET_NAME (symbolP),\n+\t\t\t\t\t      (struct local_symbol *)symbolP));\n }\n \f\n /* If a symbol name does not exist, create it as undefined, and insert\n@@ -869,14 +910,11 @@ symbol_find_exact (const char *name)\n symbolS *\n symbol_find_exact_noref (const char *name, int noref)\n {\n-  struct local_symbol *locsym;\n-  symbolS* sym;\n+  symbolS *sym = symbol_entry_find (local_hash, name);\n+  if (sym)\n+    return sym;\n \n-  locsym = (struct local_symbol *) hash_find (local_hash, name);\n-  if (locsym != NULL)\n-    return (symbolS *) locsym;\n-\n-  sym = ((symbolS *) hash_find (sy_hash, name));\n+  sym = symbol_entry_find (sy_hash, name);\n \n   /* Any references to the symbol, except for the reference in\n      .weakref, must clear this flag, such that the symbol does not\n@@ -1670,23 +1708,24 @@ resolve_symbol_value (symbolS *symp)\n   return final_val;\n }\n \n-static void resolve_local_symbol (const char *, void *);\n-\n /* A static function passed to hash_traverse.  */\n \n-static void\n-resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, void *value)\n+static int\n+resolve_local_symbol (void **slot, void *arg ATTRIBUTE_UNUSED)\n {\n-  if (value != NULL)\n-    resolve_symbol_value ((symbolS *) value);\n+  symbol_entry_t *entry = *((symbol_entry_t **) slot);\n+  if (entry->symbol != NULL)\n+    resolve_symbol_value ((symbolS *) entry->symbol);\n+\n+  return 1;\n }\n \n /* Resolve all local symbols.  */\n \n void\n resolve_local_symbol_values (void)\n {\n-  hash_traverse (local_hash, resolve_local_symbol);\n+  htab_traverse (local_hash, resolve_local_symbol, NULL);\n }\n \n /* Obtain the current value of a symbol without changing any\n@@ -2988,8 +3027,10 @@ symbol_begin (void)\n {\n   symbol_lastP = NULL;\n   symbol_rootP = NULL;\t\t/* In case we have 0 symbols (!!)  */\n-  sy_hash = hash_new ();\n-  local_hash = hash_new ();\n+  sy_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,\n+\t\t\t       NULL, xcalloc, free);\n+  local_hash = htab_create_alloc (16, hash_symbol_entry, eq_symbol_entry,\n+\t\t\t\t  NULL, xcalloc, free);\n \n   memset ((char *) (&abs_symbol), '\\0', sizeof (abs_symbol));\n #if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)\n@@ -3244,8 +3285,8 @@ print_expr (expressionS *exp)\n void\n symbol_print_statistics (FILE *file)\n {\n-  hash_print_statistics (file, \"symbol table\", sy_hash);\n-  hash_print_statistics (file, \"mini local symbol table\", local_hash);\n+  htab_print_statistics (file, \"symbol table\", sy_hash);\n+  htab_print_statistics (file, \"mini local symbol table\", local_hash);\n   fprintf (file, \"%lu mini local symbols created, %lu converted\\n\",\n \t   local_symbol_count, local_symbol_conversion_count);\n }"
    }
  ]
}