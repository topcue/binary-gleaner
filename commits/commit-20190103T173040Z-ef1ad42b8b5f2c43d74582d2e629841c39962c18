{
  "sha": "ef1ad42b8b5f2c43d74582d2e629841c39962c18",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWYxYWQ0MmI4YjVmMmM0M2Q3NDU4MmQyZTYyOTg0MWMzOTk2MmMxOA==",
  "commit": {
    "author": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-01-03T17:30:40Z"
    },
    "committer": {
      "name": "John Darrington",
      "email": "john@darrington.wattle.id.au",
      "date": "2019-01-03T17:30:40Z"
    },
    "message": "S12Z: opcodes: Separate the decoding of operations from their display.\n\nThis change adds an abstraction layer between the decoding of machine\noperations and their disassembled textual representation.  This allows\nthe decoding routines to be re-used for other purposes (at the expense)\nof slightly slower running time.\n\nChangeLog: opcodes/\n\n   * s12z-opc.c: New file.\n   * s12z-opc.h: New file.\n   * s12z-dis.c: Removed all code not directly related to display\n     of instructions.  Used the interface provided by the new files\n     instead.\n   * Makefile.am (TARGET_LIBOPCODES_CFILES) Add s12z-opc.c.\n   * Makefile.in: regenerate.\n   * configure.ac (bfd_s12z_arch): Correct the dependencies.\n   * configure: regenerate.",
    "tree": {
      "sha": "d35cab9b05e67ce5ba663688ebb0101774a47145",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d35cab9b05e67ce5ba663688ebb0101774a47145"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ef1ad42b8b5f2c43d74582d2e629841c39962c18",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ef1ad42b8b5f2c43d74582d2e629841c39962c18",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ef1ad42b8b5f2c43d74582d2e629841c39962c18",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ef1ad42b8b5f2c43d74582d2e629841c39962c18/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "444b3faef5397eee5a06fe0e683d2ac3e6628fdc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/444b3faef5397eee5a06fe0e683d2ac3e6628fdc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/444b3faef5397eee5a06fe0e683d2ac3e6628fdc"
    }
  ],
  "stats": {
    "total": 5817,
    "additions": 3255,
    "deletions": 2562
  },
  "files": [
    {
      "sha": "7f7ac9ebec2a4ea58c08a46d28bd76a23b299c26",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -1,3 +1,15 @@\n+2019-01-03  John Darrington <john@darrington.wattle.id.au>\n+\n+\t* s12z-opc.c: New file.\n+\t* s12z-opc.h: New file.\n+\t* s12z-dis.c: Removed all code not directly related to display\n+\tof instructions.  Used the interface provided by the new files\n+\tinstead.\n+\t* Makefile.am (TARGET_LIBOPCODES_CFILES) Add s12z-opc.c.\n+\t* Makefile.in: regenerate.\n+\t* configure.ac (bfd_s12z_arch): Correct the dependencies.\n+\t* configure: regenerate.\n+\n 2019-01-01  Alan Modra  <amodra@gmail.com>\n \n \tUpdate year range in copyright notice of all files."
    },
    {
      "sha": "458a2b56c5ce9472293aff8b3e01c26248e9541f",
      "filename": "opcodes/Makefile.am",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/Makefile.am?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -176,6 +176,7 @@ TARGET_LIBOPCODES_CFILES = \\\n \tm68k-dis.c \\\n \tm68k-opc.c \\\n \ts12z-dis.c \\\n+\ts12z-opc.c \\\n \tmcore-dis.c \\\n \tmep-asm.c \\\n \tmep-desc.c \\"
    },
    {
      "sha": "3277ba954a3d20ed0f97f0a0f12f3604c1edba91",
      "filename": "opcodes/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/Makefile.in?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -566,6 +566,7 @@ TARGET_LIBOPCODES_CFILES = \\\n \tm68k-dis.c \\\n \tm68k-opc.c \\\n \ts12z-dis.c \\\n+\ts12z-opc.c \\\n \tmcore-dis.c \\\n \tmep-asm.c \\\n \tmep-desc.c \\\n@@ -1022,6 +1023,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rx-decode.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rx-dis.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s12z-dis.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s12z-opc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s390-dis.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/s390-opc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/score-dis.Plo@am__quote@"
    },
    {
      "sha": "652b3731aeec2567810b89546c20c719be158f57",
      "filename": "opcodes/configure",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/configure?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -12896,7 +12896,7 @@ if test x${all_targets} = xfalse ; then\n \tbfd_m68hc12_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n \tbfd_m9s12x_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n \tbfd_m9s12xg_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n-\tbfd_s12z_arch)\tta=\"$ta s12z-dis.lo m68hc11-opc.lo\" ;;\n+\tbfd_s12z_arch)\tta=\"$ta s12z-dis.lo s12z-opc.lo\" ;;\n \tbfd_m68k_arch)\t\tta=\"$ta m68k-dis.lo m68k-opc.lo\" ;;\n \tbfd_mcore_arch)\t\tta=\"$ta mcore-dis.lo\" ;;\n \tbfd_mep_arch)\t\tta=\"$ta mep-asm.lo mep-desc.lo mep-dis.lo mep-ibld.lo mep-opc.lo\" using_cgen=yes ;;"
    },
    {
      "sha": "4eb19005e801a1e7810b2ef032bf77e86b31df16",
      "filename": "opcodes/configure.ac",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/configure.ac?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -287,7 +287,7 @@ if test x${all_targets} = xfalse ; then\n \tbfd_m68hc12_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n \tbfd_m9s12x_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n \tbfd_m9s12xg_arch)\tta=\"$ta m68hc11-dis.lo m68hc11-opc.lo\" ;;\n-\tbfd_s12z_arch)\tta=\"$ta s12z-dis.lo m68hc11-opc.lo\" ;;\n+\tbfd_s12z_arch)\t\tta=\"$ta s12z-dis.lo s12z-opc.lo\" ;;\n \tbfd_m68k_arch)\t\tta=\"$ta m68k-dis.lo m68k-opc.lo\" ;;\n \tbfd_mcore_arch)\t\tta=\"$ta mcore-dis.lo\" ;;\n \tbfd_mep_arch)\t\tta=\"$ta mep-asm.lo mep-desc.lo mep-dis.lo mep-ibld.lo mep-opc.lo\" using_cgen=yes ;;"
    },
    {
      "sha": "14176fb6d9e47f83280ec0c8eacfcfea4d1a113e",
      "filename": "opcodes/s12z-dis.c",
      "status": "modified",
      "additions": 270,
      "deletions": 2560,
      "changes": 2830,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/s12z-dis.c?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -29,266 +29,51 @@\n #include \"bfd.h\"\n #include \"dis-asm.h\"\n \n-\n #include \"disassemble.h\"\n \n-static int\n-read_memory (bfd_vma memaddr, bfd_byte* buffer, int size,\n-             struct disassemble_info* info)\n-{\n-  int status = (*info->read_memory_func) (memaddr, buffer, size, info);\n-  if (status != 0)\n-    {\n-      (*info->memory_error_func) (status, memaddr, info);\n-      return -1;\n-    }\n-  return 0;\n-}\n-\n-typedef int (* insn_bytes_f) (bfd_vma memaddr,\n-\t\t\t      struct disassemble_info* info);\n-\n-typedef void (*operands_f) (bfd_vma memaddr, struct disassemble_info* info);\n-\n-enum OPR_MODE\n-  {\n-    OPR_IMMe4,\n-    OPR_REG,\n-    OPR_OFXYS,\n-    OPR_XY_PRE_INC,\n-    OPR_XY_POST_INC,\n-    OPR_XY_PRE_DEC,\n-    OPR_XY_POST_DEC,\n-    OPR_S_PRE_DEC,\n-    OPR_S_POST_INC,\n-    OPR_REG_DIRECT,\n-    OPR_REG_INDIRECT,\n-    OPR_IDX_DIRECT,\n-    OPR_IDX_INDIRECT,\n-    OPR_EXT1,\n-    OPR_IDX2_REG,\n-    OPR_IDX3_DIRECT,\n-    OPR_IDX3_INDIRECT,\n-\n-    OPR_EXT18,\n-    OPR_IDX3_DIRECT_REG,\n-    OPR_EXT3_DIRECT,\n-    OPR_EXT3_INDIRECT\n-  };\n-\n-struct opr_pb\n-{\n-  uint8_t mask;\n-  uint8_t value;\n-  int n_operands;\n-  enum OPR_MODE mode;\n-};\n-\n-static const  struct opr_pb opr_pb[] = {\n-  {0xF0, 0x70, 1, OPR_IMMe4},\n-  {0xF8, 0xB8, 1, OPR_REG},\n-  {0xC0, 0x40, 1, OPR_OFXYS},\n-  {0xEF, 0xE3, 1, OPR_XY_PRE_INC},\n-  {0xEF, 0xE7, 1, OPR_XY_POST_INC},\n-  {0xEF, 0xC3, 1, OPR_XY_PRE_DEC},\n-  {0xEF, 0xC7, 1, OPR_XY_POST_DEC},\n-  {0xFF, 0xFB, 1, OPR_S_PRE_DEC},\n-  {0xFF, 0xFF, 1, OPR_S_POST_INC},\n-  {0xC8, 0x88, 1, OPR_REG_DIRECT},\n-  {0xE8, 0xC8, 1, OPR_REG_INDIRECT},\n-\n-  {0xCE, 0xC0, 2, OPR_IDX_DIRECT},\n-  {0xCE, 0xC4, 2, OPR_IDX_INDIRECT},\n-  {0xC0, 0x00, 2, OPR_EXT1},\n-\n-  {0xC8, 0x80, 3, OPR_IDX2_REG},\n-  {0xFA, 0xF8, 3, OPR_EXT18},\n-\n-  {0xCF, 0xC2, 4, OPR_IDX3_DIRECT},\n-  {0xCF, 0xC6, 4, OPR_IDX3_INDIRECT},\n-\n-  {0xF8, 0xE8, 4, OPR_IDX3_DIRECT_REG},\n-  {0xFF, 0xFA, 4, OPR_EXT3_DIRECT},\n-  {0xFF, 0xFE, 4, OPR_EXT3_INDIRECT},\n-};\n-\n-\n-/* Return the number of bytes in a OPR operand, including the XB postbyte.\n-   It does not include any preceeding opcodes. */\n-static int\n-opr_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte xb;\n-  int status = read_memory (memaddr, &xb, 1, info);\n-  if (status < 0)\n-    return status;\n-\n-  size_t i;\n-  for (i = 0; i < sizeof (opr_pb) / sizeof (opr_pb[0]); ++i)\n-    {\n-      const struct opr_pb *pb = opr_pb + i;\n-      if ((xb & pb->mask) == pb->value)\n-\t{\n-\t  return pb->n_operands;\n-\t}\n-    }\n-\n-  return 1;\n-}\n-\n-static int\n-opr_n_bytes_p1 (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  return 1 + opr_n_bytes (memaddr, info);\n-}\n-\n-static int\n-opr_n_bytes2 (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  int s = opr_n_bytes (memaddr, info);\n-  s += opr_n_bytes (memaddr + s, info);\n-  return s + 1;\n-}\n-\n-enum BB_MODE\n-  {\n-    BB_REG_REG_REG,\n-    BB_REG_REG_IMM,\n-    BB_REG_OPR_REG,\n-    BB_OPR_REG_REG,\n-    BB_REG_OPR_IMM,\n-    BB_OPR_REG_IMM\n-  };\n+#include \"s12z-opc.h\"\n \n-struct opr_bb\n+struct mem_read_abstraction\n {\n-  uint8_t mask;\n-  uint8_t value;\n-  int n_operands;\n-  bool opr;\n-  enum BB_MODE mode;\n+  struct mem_read_abstraction_base base;\n+  bfd_vma memaddr;\n+  struct disassemble_info* info;\n };\n \n-static const struct opr_bb bb_modes[] =\n-  {\n-    {0x60, 0x00, 2, false, BB_REG_REG_REG},\n-    {0x60, 0x20, 3, false, BB_REG_REG_IMM},\n-    {0x70, 0x40, 2, true,  BB_REG_OPR_REG},\n-    {0x70, 0x50, 2, true,  BB_OPR_REG_REG},\n-    {0x70, 0x60, 3, true,  BB_REG_OPR_IMM},\n-    {0x70, 0x70, 3, true,  BB_OPR_REG_IMM}\n-  };\n-\n-static int\n-bfextins_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte bb;\n-  int status = read_memory (memaddr, &bb, 1, info);\n-  if (status < 0)\n-    return status;\n-\n-  size_t i;\n-  const struct opr_bb *bbs = 0;\n-  for (i = 0; i < sizeof (bb_modes) / sizeof (bb_modes[0]); ++i)\n-    {\n-      bbs = bb_modes + i;\n-      if ((bb & bbs->mask) == bbs->value)\n-\t{\n-\t  break;\n-\t}\n-    }\n-\n-  int n = bbs->n_operands;\n-  if (bbs->opr)\n-    n += opr_n_bytes (memaddr + n - 1, info);\n-\n-  return n;\n-}\n-\n-static int\n-single (bfd_vma memaddr ATTRIBUTE_UNUSED,\n-\tstruct disassemble_info* info ATTRIBUTE_UNUSED)\n-{\n-  return 1;\n-}\n-\n-static int\n-two (bfd_vma memaddr ATTRIBUTE_UNUSED,\n-     struct disassemble_info* info ATTRIBUTE_UNUSED)\n-{\n-  return 2;\n-}\n-\n-static int\n-three (bfd_vma memaddr ATTRIBUTE_UNUSED,\n-       struct disassemble_info* info ATTRIBUTE_UNUSED)\n-{\n-  return 3;\n-}\n-\n-static int\n-four (bfd_vma memaddr ATTRIBUTE_UNUSED,\n-      struct disassemble_info* info ATTRIBUTE_UNUSED)\n+static void\n+advance (struct mem_read_abstraction_base *b)\n {\n-  return 4;\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n+  mra->memaddr ++;\n }\n \n-static int\n-five (bfd_vma memaddr ATTRIBUTE_UNUSED,\n-      struct disassemble_info* info ATTRIBUTE_UNUSED)\n+static bfd_vma\n+posn (struct mem_read_abstraction_base *b)\n {\n-  return 5;\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n+  return mra->memaddr;\n }\n \n static int\n-pcrel_15bit (bfd_vma memaddr, struct disassemble_info* info)\n+abstract_read_memory (struct mem_read_abstraction_base *b,\n+\t\t      int offset,\n+\t\t      size_t n, bfd_byte *bytes)\n {\n-  bfd_byte byte;\n-  int status = read_memory (memaddr, &byte, 1, info);\n-  if (status < 0)\n-    return status;\n-  return (byte & 0x80) ? 3 : 2;\n-}\n+  struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n \n+  int status =\n+    (*mra->info->read_memory_func) (mra->memaddr + offset,\n+\t\t\t\t    bytes, n, mra->info);\n \n-\f\n-\n-static void\n-operand_separator (struct disassemble_info *info)\n-{\n-  if ((info->flags & 0x2))\n-    {\n-      (*info->fprintf_func) (info->stream, \", \");\n-    }\n-  else\n+  if (status != 0)\n     {\n-      (*info->fprintf_func) (info->stream, \" \");\n+      (*mra->info->memory_error_func) (status, mra->memaddr, mra->info);\n+      return -1;\n     }\n-\n-  info->flags |= 0x2;\n-}\n-\n-\f\n-\n-static void\n-imm1 (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"#%d\", byte);\n-}\n-\n-static void\n-trap_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  imm1 (memaddr - 1, info);\n+  return 0;\n }\n \n-\n+/* Start of disassembly file.  */\n const struct reg registers[S12Z_N_REGISTERS] =\n   {\n     {\"d2\", 2},\n@@ -311,58 +96,128 @@ const struct reg registers[S12Z_N_REGISTERS] =\n     {\"ccw\", 2}\n   };\n \n-static char *\n-xys_from_postbyte (uint8_t postbyte)\n-{\n-  char *reg = \"?\";\n-  switch ((postbyte & 0x30) >> 4)\n-    {\n-    case 0:\n-      reg = \"x\";\n-      break;\n-    case 1:\n-      reg = \"y\";\n-      break;\n-    case 2:\n-      reg = \"s\";\n-      break;\n-    default:\n-      reg = \"?\";\n-      break;\n-    }\n-  return reg;\n-}\n+static const char *mnemonics[] =\n+  {\n+    \"!!invalid!!\",\n+    \"psh\",\n+    \"pul\",\n+    \"tbne\", \"tbeq\", \"tbpl\", \"tbmi\", \"tbgt\", \"tble\",\n+    \"dbne\", \"dbeq\", \"dbpl\", \"dbmi\", \"dbgt\", \"dble\",\n+    \"sex\",\n+    \"exg\",\n+    \"lsl\", \"lsr\",\n+    \"asl\", \"asr\",\n+    \"rol\", \"ror\",\n+    \"bfins\", \"bfext\",\n+\n+    \"trap\",\n+\n+    \"ld\",\n+    \"st\",\n+    \"cmp\",\n+\n+    \"stop\",\n+    \"wai\",\n+    \"sys\",\n+\n+    \"minu\",\n+    \"mins\",\n+    \"maxu\",\n+    \"maxs\",\n+\n+    \"abs\",\n+    \"adc\",\n+    \"bit\",\n+    \"sbc\",\n+    \"rti\",\n+    \"clb\",\n+    \"eor\",\n+\n+    \"sat\",\n+\n+    \"nop\",\n+    \"bgnd\",\n+    \"brclr\",\n+    \"brset\",\n+    \"rts\",\n+    \"lea\",\n+    \"mov\",\n+\n+    \"bra\",\n+    \"bsr\",\n+    \"bhi\",\n+    \"bls\",\n+    \"bcc\",\n+    \"bcs\",\n+    \"bne\",\n+    \"beq\",\n+    \"bvc\",\n+    \"bvs\",\n+    \"bpl\",\n+    \"bmi\",\n+    \"bge\",\n+    \"blt\",\n+    \"bgt\",\n+    \"ble\",\n+    \"inc\",\n+    \"clr\",\n+    \"dec\",\n+\n+    \"add\",\n+    \"sub\",\n+    \"and\",\n+    \"or\",\n+\n+    \"tfr\",\n+    \"jmp\",\n+    \"jsr\",\n+    \"com\",\n+    \"andcc\",\n+    \"neg\",\n+    \"orcc\",\n+    \"bclr\",\n+    \"bset\",\n+    \"btgl\",\n+    \"swi\",\n+\n+    \"mulu\",\n+    \"divu\",\n+    \"modu\",\n+    \"macu\",\n+    \"qmulu\",\n+\n+    \"muls\",\n+    \"divs\",\n+    \"mods\",\n+    \"macs\",\n+    \"qmuls\",\n+\n+    NULL\n+  };\n+\n \n-static char *\n-xysp_from_postbyte (uint8_t postbyte)\n+static void\n+operand_separator (struct disassemble_info *info)\n {\n-  char *reg = \"?\";\n-  switch ((postbyte & 0x30) >> 4)\n-    {\n-    case 0:\n-      reg = \"x\";\n-      break;\n-    case 1:\n-      reg = \"y\";\n-      break;\n-    case 2:\n-      reg = \"s\";\n-      break;\n-    default:\n-      reg = \"p\";\n-      break;\n-    }\n-  return reg;\n+  if ((info->flags & 0x2))\n+    (*info->fprintf_func) (info->stream, \",\");\n+\n+  (*info->fprintf_func) (info->stream, \" \");\n+\n+  info->flags |= 0x2;\n }\n \n-/* Render the symbol name whose value is ADDR or the adddress itself if there is\n-   no symbol. */\n+/* Render the symbol name whose value is ADDR + BASE or the adddress itself if\n+   there is no symbol.  If BASE is non zero, then the a PC relative adddress is\n+   assumend (ie BASE is the value in the PC.  */\n static void\n-decode_possible_symbol (bfd_vma addr, struct disassemble_info *info)\n+decode_possible_symbol (bfd_vma addr, bfd_vma base,\n+                        struct disassemble_info *info, bool relative)\n {\n-  if (!info->symbol_at_address_func (addr, info))\n+  const char *fmt = relative  ? \"*%+\" BFD_VMA_FMT \"d\" : \"%\" BFD_VMA_FMT \"d\";\n+  if (!info->symbol_at_address_func (addr + base, info))\n     {\n-      (*info->fprintf_func) (info->stream, \"%\" BFD_VMA_FMT \"d\", addr);\n+      (*info->fprintf_func) (info->stream, fmt, addr);\n     }\n   else\n     {\n@@ -371,2313 +226,168 @@ decode_possible_symbol (bfd_vma addr, struct disassemble_info *info)\n       for (j = 0; j < info->symtab_size; ++j)\n \t{\n \t  sym = info->symtab[j];\n-\t  if (bfd_asymbol_value (sym) == addr)\n+\t  if (bfd_asymbol_value (sym) == addr + base)\n \t    {\n \t      break;\n \t    }\n \t}\n       if (j < info->symtab_size)\n \t(*info->fprintf_func) (info->stream, \"%s\", bfd_asymbol_name (sym));\n       else\n-        (*info->fprintf_func) (info->stream, \"%\" BFD_VMA_FMT \"d\", addr);\n+        (*info->fprintf_func) (info->stream, fmt, addr);\n     }\n }\n \n-static void ld_18bit_decode (bfd_vma memaddr, struct disassemble_info* info);\n \n+/* Emit the disassembled text for OPR */\n static void\n-ext24_decode (bfd_vma memaddr, struct disassemble_info* info)\n+opr_emit_disassembly (const struct operand *opr,\n+\t\t      struct disassemble_info *info)\n {\n-  uint8_t buffer[3];\n-  int status = read_memory (memaddr, buffer, 3, info);\n-  if (status < 0)\n-    return;\n-\n-  int i;\n-  uint32_t addr = 0;\n-  for (i = 0; i < 3; ++i)\n-    {\n-      addr <<= 8;\n-      addr |= buffer[i];\n-    }\n-\n   operand_separator (info);\n-  decode_possible_symbol (addr, info);\n-}\n-\n-\n-static uint32_t\n-decode_signed_value (bfd_vma memaddr, struct disassemble_info* info, short size)\n-{\n-  assert (size >0);\n-  assert (size <= 4);\n-  bfd_byte buffer[4];\n-  if (0 > read_memory (memaddr, buffer, size, info))\n-    {\n-      return 0;\n-    }\n-\n-  int i;\n-  uint32_t value = 0;\n-  for (i = 0; i < size; ++i)\n-    {\n-      value |= buffer[i] << (8 * (size - i - 1));\n-    }\n-\n-  if (buffer[0] & 0x80)\n-    {\n-      /* Deal with negative values */\n-      value -= 0x1UL << (size * 8);\n-    }\n-  return value;\n-}\n-\n-\n-static void\n-opr_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte postbyte;\n-  int status = read_memory (memaddr, &postbyte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  enum OPR_MODE mode = -1;\n-  size_t i;\n-  for (i = 0; i < sizeof (opr_pb) / sizeof (opr_pb[0]); ++i)\n-    {\n-      const struct opr_pb *pb = opr_pb + i;\n-      if ((postbyte & pb->mask) == pb->value)\n-\t{\n-\t  mode = pb->mode;\n-\t  break;\n-\t}\n-    }\n \n-  operand_separator (info);\n-  switch (mode)\n+  switch (opr->cl)\n     {\n-    case OPR_IMMe4:\n-      {\n-\tint n;\n-\tuint8_t x = (postbyte & 0x0F);\n-\tif (x == 0)\n-\t  n = -1;\n-\telse\n-\t  n = x;\n-\n-\t(*info->fprintf_func) (info->stream, \"#%d\", n);\n-\tbreak;\n-      }\n-    case OPR_REG:\n-      {\n-\tuint8_t x = (postbyte & 0x07);\n-\t(*info->fprintf_func) (info->stream, \"%s\", registers[x].name);\n-\tbreak;\n-      }\n-    case OPR_OFXYS:\n-      {\n-\tconst char *reg  = xys_from_postbyte (postbyte);\n-\t(*info->fprintf_func) (info->stream, \"(%d,%s)\", postbyte & 0x0F, reg);\n-\tbreak;\n-      }\n-    case OPR_REG_DIRECT:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(%s,%s)\", registers[postbyte & 0x07].name,\n-\t\t\t       xys_from_postbyte (postbyte));\n-\tbreak;\n-      }\n-    case OPR_REG_INDIRECT:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"[%s,%s]\", registers[postbyte & 0x07].name,\n-\t\t\t       (postbyte & 0x10) ? \"y\": \"x\");\n-\tbreak;\n-      }\n-\n-    case OPR_IDX_INDIRECT:\n-      {\n-\tuint8_t x1;\n-\tread_memory (memaddr + 1, &x1, 1, info);\n-\tint idx = x1;\n-\n-\tif (postbyte & 0x01)\n-\t  {\n-\t    /* Deal with negative values */\n-\t    idx -= 0x1UL << 8;\n-\t  }\n-\n-\t(*info->fprintf_func) (info->stream, \"[%d,%s]\", idx,\n-\t\t\t       xysp_from_postbyte (postbyte));\n-\tbreak;\n-      }\n-\n-    case OPR_IDX3_DIRECT:\n-      {\n-\tuint8_t x[3];\n-\tread_memory (memaddr + 1, x, 3, info);\n-\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n-\n-\tif (x[0] & 0x80)\n-\t  {\n-\t    /* Deal with negative values */\n-\t    idx -= 0x1UL << 24;\n-\t  }\n-\n-\t(*info->fprintf_func) (info->stream, \"(%d,%s)\", idx,\n-\t\t\t       xysp_from_postbyte (postbyte));\n-\tbreak;\n-      }\n-\n-    case OPR_IDX3_DIRECT_REG:\n-      {\n-\tuint8_t x[3];\n-\tread_memory (memaddr + 1, x, 3, info);\n-\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n-\n-\tif (x[0] & 0x80)\n-\t  {\n-\t    /* Deal with negative values */\n-\t    idx -= 0x1UL << 24;\n-\t  }\n-\n-\t(*info->fprintf_func) (info->stream, \"(%d,%s)\", idx,\n-\t\t\t       registers[postbyte & 0x07].name);\n-\tbreak;\n-      }\n-\n-    case OPR_IDX3_INDIRECT:\n-      {\n-\tuint8_t x[3];\n-\tread_memory (memaddr + 1, x, 3, info);\n-\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n-\n-\tif (x[0] & 0x80)\n-\t  {\n-\t    /* Deal with negative values */\n-\t    idx -= 0x1UL << 24;\n-\t  }\n-\n-\t(*info->fprintf_func) (info->stream, \"[%d,%s]\", idx,\n-\t\t\t       xysp_from_postbyte (postbyte));\n-\tbreak;\n-      }\n-\n-    case OPR_IDX_DIRECT:\n-      {\n-\tuint8_t x1;\n-\tread_memory (memaddr + 1, &x1, 1, info);\n-\tint idx = x1;\n-\n-\tif (postbyte & 0x01)\n-\t  {\n-\t    /* Deal with negative values */\n-\t    idx -= 0x1UL << 8;\n-\t  }\n-\n-\t(*info->fprintf_func) (info->stream, \"(%d,%s)\", idx,\n-\t\t\t       xysp_from_postbyte (postbyte));\n-\tbreak;\n-      }\n-\n-    case OPR_IDX2_REG:\n-      {\n-\tuint8_t x[2];\n-\tread_memory (memaddr + 1, x, 2, info);\n-\tuint32_t offset = x[1] | x[0] << 8 ;\n-\toffset |= (postbyte & 0x30) << 12;\n-\n-\t(*info->fprintf_func) (info->stream, \"(%d,%s)\", offset,\n-\t\t\t       registers[postbyte & 0x07].name);\n-\tbreak;\n-      }\n-\n-    case OPR_XY_PRE_INC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(+%s)\",\n-\t\t\t       (postbyte & 0x10) ? \"y\": \"x\");\n-\n-\tbreak;\n-      }\n-    case OPR_XY_POST_INC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(%s+)\",\n-\t\t\t       (postbyte & 0x10) ? \"y\": \"x\");\n-\n-\tbreak;\n-      }\n-    case OPR_XY_PRE_DEC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(-%s)\",\n-\t\t\t       (postbyte & 0x10) ? \"y\": \"x\");\n-\n-\tbreak;\n-      }\n-    case OPR_XY_POST_DEC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(%s-)\",\n-\t\t\t       (postbyte & 0x10) ? \"y\": \"x\");\n-\n-\tbreak;\n-      }\n-    case OPR_S_PRE_DEC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(-s)\");\n-\tbreak;\n-      }\n-    case OPR_S_POST_INC:\n-      {\n-\t(*info->fprintf_func) (info->stream, \"(s+)\");\n-\tbreak;\n-      }\n-\n-    case OPR_EXT18:\n-      {\n-\tconst size_t size = 2;\n-\tbfd_byte buffer[4];\n-\tstatus = read_memory (memaddr + 1, buffer, size, info);\n-\tif (status < 0)\n-\t  return;\n-\n-\tuint32_t ext18 = 0;\n-\tfor (i = 0; i < size; ++i)\n-\t  {\n-\t    ext18 <<= 8;\n-\t    ext18 |= buffer[i];\n-\t  }\n-\n-\text18 |= (postbyte & 0x01) << 16;\n-\text18 |= (postbyte & 0x04) << 15;\n-\n-\tdecode_possible_symbol (ext18, info);\n-\tbreak;\n-      }\n-\n-    case OPR_EXT1:\n+    case OPND_CL_IMMEDIATE:\n+      (*info->fprintf_func) (info->stream, \"#%d\",\n+\t\t\t     ((struct immediate_operand *) opr)->value);\n+      break;\n+    case OPND_CL_REGISTER:\n       {\n-\tuint8_t x1 = 0;\n-\tread_memory (memaddr + 1, &x1, 1, info);\n-\tint16_t addr;\n-\taddr = x1;\n-\taddr |= (postbyte & 0x3f) << 8;\n-\n-\tdecode_possible_symbol (addr, info);\n-\tbreak;\n+        int r = ((struct register_operand*) opr)->reg;\n+\t(*info->fprintf_func) (info->stream, \"%s\", registers[r].name);\n       }\n-\n-    case OPR_EXT3_DIRECT:\n+      break;\n+    case OPND_CL_REGISTER_ALL16:\n+      (*info->fprintf_func) (info->stream, \"%s\", \"ALL16b\");\n+      break;\n+    case OPND_CL_REGISTER_ALL:\n+      (*info->fprintf_func) (info->stream, \"%s\", \"ALL\");\n+      break;\n+    case OPND_CL_BIT_FIELD:\n+      (*info->fprintf_func) (info->stream, \"#%d:%d\",\n+                             ((struct bitfield_operand*)opr)->width,\n+                             ((struct bitfield_operand*)opr)->offset);\n+      break;\n+    case OPND_CL_SIMPLE_MEMORY:\n       {\n-\tconst size_t size = 3;\n-\tbfd_byte buffer[4];\n-\tstatus = read_memory (memaddr + 1, buffer, size, info);\n-\tif (status < 0)\n-\t  return;\n-\n-\tuint32_t ext24 = 0;\n-\tfor (i = 0; i < size; ++i)\n-\t  {\n-\t    ext24 |= buffer[i] << (8 * (size - i - 1));\n-\t  }\n-\n-\tdecode_possible_symbol (ext24, info);\n-\tbreak;\n+        struct simple_memory_operand *mo =\n+\t  (struct simple_memory_operand *) opr;\n+\tdecode_possible_symbol (mo->addr, mo->base, info, mo->relative);\n       }\n-\n-    case OPR_EXT3_INDIRECT:\n+      break;\n+    case OPND_CL_MEMORY:\n       {\n-\tconst size_t size = 3;\n-\tbfd_byte buffer[4];\n-\tstatus = read_memory (memaddr + 1, buffer, size, info);\n-\tif (status < 0)\n-\t  return;\n+        int used_reg = 0;\n+        struct memory_operand *mo = (struct memory_operand *) opr;\n+\t(*info->fprintf_func) (info->stream, \"%c\", mo->indirect ? '[' : '(');\n \n-\tuint32_t ext24 = 0;\n-\tfor (i = 0; i < size; ++i)\n-\t  {\n-\t    ext24 |= buffer[i] << (8 * (size - i - 1));\n-\t  }\n+        if (mo->base_offset != 0)\n+          {\n+            (*info->fprintf_func) (info->stream, \"%d\", mo->base_offset);\n+          }\n+        else if (mo->n_regs > 0)\n+          {\n+\t    const char *fmt;\n+\t    switch (mo->mutation)\n+\t      {\n+\t      case OPND_RM_PRE_DEC:\n+\t\tfmt = \"-%s\";\n+\t\tbreak;\n+\t      case OPND_RM_PRE_INC:\n+\t\tfmt = \"+%s\";\n+\t\tbreak;\n+\t      case OPND_RM_POST_DEC:\n+\t\tfmt = \"%s-\";\n+\t\tbreak;\n+\t      case OPND_RM_POST_INC:\n+\t\tfmt = \"%s+\";\n+\t\tbreak;\n+\t      case OPND_RM_NONE:\n+\t      default:\n+\t\tfmt = \"%s\";\n+\t\tbreak;\n+\t      }\n+            (*info->fprintf_func) (info->stream, fmt,\n+\t\t\t\t   registers[mo->regs[0]].name);\n+            used_reg = 1;\n+          }\n \n-\t(*info->fprintf_func) (info->stream, \"[%d]\", ext24);\n+        if (mo->n_regs > used_reg)\n+          {\n+            (*info->fprintf_func) (info->stream, \",%s\",\n+\t\t\t\t   registers[mo->regs[used_reg]].name);\n+          }\n \n-\tbreak;\n+\t(*info->fprintf_func) (info->stream, \"%c\",\n+\t\t\t       mo->indirect ? ']' : ')');\n       }\n-\n-    default:\n-      (*info->fprintf_func) (info->stream, \"Unknown OPR mode #0x%x (%d)\", postbyte, mode);\n-    }\n+      break;\n+    };\n }\n \n+static const char shift_size_table[] = {\n+  'b', 'w', 'p', 'l'\n+};\n \n-static void\n-opr_decode2 (bfd_vma memaddr, struct disassemble_info* info)\n+int\n+print_insn_s12z (bfd_vma memaddr, struct disassemble_info* info)\n {\n-  int n = opr_n_bytes (memaddr, info);\n-  opr_decode (memaddr, info);\n-  opr_decode (memaddr + n, info);\n-}\n+  int o;\n+  enum operator operator = OP_INVALID;\n+  int n_operands = 0;\n+\n+  /* The longest instruction in S12Z can have 6 operands.\n+     (Most have 3 or less.  Only PSH and PUL have so many.  */\n+  struct operand *operands[6];\n+\n+  struct mem_read_abstraction mra;\n+  mra.base.read = (void *) abstract_read_memory ;\n+  mra.base.advance = advance ;\n+  mra.base.posn = posn;\n+  mra.memaddr = memaddr;\n+  mra.info = info;\n+\n+  short osize = -1;\n+  int n_bytes =\n+    decode_s12z (&operator, &osize, &n_operands, operands,\n+\t\t (struct mem_read_abstraction_base *) &mra);\n+\n+  (info->fprintf_func) (info->stream, \"%s\", mnemonics[(long)operator]);\n+  \n+  /* Ship out size sufficies for those instructions which\n+     need them.  */\n+  if (osize == -1)\n+    {\n+      bool suffix = false;\n+      for (o = 0; o < n_operands; ++o)\n+\t{\n+\t  if (operands[o]->osize != -1)\n+\t    {\n+\t      if (!suffix)\n+\t\t{\n+\t\t  (*mra.info->fprintf_func) (mra.info->stream, \"%c\", '.');\n+\t\t  suffix = true;\n+\t\t}\n+\t      (*mra.info->fprintf_func) (mra.info->stream, \"%c\",\n+\t\t\t\t     shift_size_table[operands[o]->osize]);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      (*mra.info->fprintf_func) (mra.info->stream, \".%c\",\n+\t\t\t     shift_size_table[osize]);\n+    }\n \n-static void\n-imm1234 (bfd_vma memaddr, struct disassemble_info* info, int base)\n-{\n-  bfd_byte opcode;\n-  int status = read_memory (memaddr - 1, &opcode, 1, info);\n-  if (status < 0)\n-    return;\n \n-  opcode -= base;\n-\n-  int size = registers[opcode & 0xF].bytes;\n-\n-  uint32_t imm = decode_signed_value (memaddr, info, size);\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-}\n-\n-\n-/* Special case of LD and CMP with register S and IMM operand */\n-static void\n-reg_s_imm (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"s\");\n-\n-  uint32_t imm = decode_signed_value (memaddr, info, 3);\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-}\n-\n-/* Special case of LD, CMP and ST with register S and OPR operand */\n-static void\n-reg_s_opr (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"s\");\n-\n-  opr_decode (memaddr, info);\n-}\n-\n-static void\n-imm1234_8base (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  imm1234 (memaddr, info, 8);\n-}\n-\n-static void\n-imm1234_0base (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  imm1234 (memaddr, info, 0);\n-}\n-\n-static void\n-tfr (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s, %s\",\n-\t\t\t registers[byte >> 4].name,\n-\t\t\t registers[byte & 0xF].name);\n-}\n-\n-\n-static void\n-reg (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", registers[byte & 0x07].name);\n-}\n-\n-static void\n-reg_xy (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", (byte & 0x01) ? \"y\" : \"x\");\n-}\n-\n-static void\n-lea_reg_xys_opr (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  char *reg_xys = NULL;\n-  switch (byte & 0x03)\n-    {\n-    case 0x00:\n-      reg_xys = \"x\";\n-      break;\n-    case 0x01:\n-      reg_xys = \"y\";\n-      break;\n-    case 0x02:\n-      reg_xys = \"s\";\n-      break;\n-    }\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", reg_xys);\n-  opr_decode (memaddr, info);\n-}\n-\n-\n-\n-static void\n-lea_reg_xys (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  char *reg_xys = NULL;\n-  switch (byte & 0x03)\n-    {\n-    case 0x00:\n-      reg_xys = \"x\";\n-      break;\n-    case 0x01:\n-      reg_xys = \"y\";\n-      break;\n-    case 0x02:\n-      reg_xys = \"s\";\n-      break;\n-    }\n-\n-  status = read_memory (memaddr, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  int8_t v = byte;\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s, (%d,%s)\", reg_xys, v, reg_xys);\n-}\n-\n-\n-/* PC Relative offsets of size 15 or 7 bits */\n-static void\n-rel_15_7 (bfd_vma memaddr, struct disassemble_info* info, int offset)\n-{\n-  bfd_byte upper;\n-  int status = read_memory (memaddr, &upper, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  bool rel_size = (upper & 0x80);\n-\n-  int16_t addr = upper;\n-  if (rel_size)\n-    {\n-      /* 15 bits.  Get the next byte */\n-      bfd_byte lower;\n-      status = read_memory (memaddr + 1, &lower, 1, info);\n-      if (status < 0)\n-\treturn;\n-\n-      addr <<= 8;\n-      addr |= lower;\n-      addr &= 0x7FFF;\n-\n-      bool negative = (addr & 0x4000);\n-      addr &= 0x3FFF;\n-      if (negative)\n-\taddr = addr - 0x4000;\n-    }\n-  else\n-    {\n-      /* 7 bits. */\n-      bool negative = (addr & 0x40);\n-      addr &= 0x3F;\n-      if (negative)\n-\taddr = addr - 0x40;\n-    }\n-\n-  operand_separator (info);\n-  if (!info->symbol_at_address_func (addr + memaddr - offset, info))\n-    {\n-      (*info->fprintf_func) (info->stream, \"*%+d\", addr);\n-    }\n-  else\n-    {\n-      asymbol *sym = NULL;\n-      int i;\n-      for (i = 0; i < info->symtab_size; ++i)\n-\t{\n-\t  sym = info->symtab[i];\n-\t  if (bfd_asymbol_value (sym) == addr + memaddr - offset)\n-\t    {\n-\t      break;\n-\t    }\n-\t}\n-      if (i < info->symtab_size)\n-\t(*info->fprintf_func) (info->stream, \"%s\", bfd_asymbol_name (sym));\n-      else\n-        (*info->fprintf_func) (info->stream, \"*%+d\", addr);\n-    }\n-}\n-\n-\n-/* PC Relative offsets of size 15 or 7 bits */\n-static void\n-decode_rel_15_7 (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  rel_15_7 (memaddr, info, 1);\n-}\n-\n-struct opcode\n-{\n-  const char *mnemonic;\n-  insn_bytes_f insn_bytes;\n-  operands_f operands;\n-  operands_f operands2;\n-};\n-\n-static int shift_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static int mov_imm_opr_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static int loop_prim_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static void mov_imm_opr (bfd_vma memaddr, struct disassemble_info* info);\n-static void bm_rel_decode (bfd_vma memaddr, struct disassemble_info* info);\n-static int bm_rel_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static int mul_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static void mul_decode (bfd_vma memaddr, struct disassemble_info* info);\n-static int bm_n_bytes (bfd_vma memaddr, struct disassemble_info* info);\n-static void bm_decode (bfd_vma memaddr, struct disassemble_info* info);\n-\n-static void\n-cmp_xy (bfd_vma memaddr ATTRIBUTE_UNUSED, struct disassemble_info* info)\n-{\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"x, y\");\n-}\n-\n-static void\n-sub_d6_x_y (bfd_vma memaddr ATTRIBUTE_UNUSED, struct disassemble_info* info)\n-{\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"d6, x, y\");\n-}\n-\n-static void\n-sub_d6_y_x (bfd_vma memaddr ATTRIBUTE_UNUSED, struct disassemble_info* info)\n-{\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"d6, y, x\");\n-}\n-\n-static const char shift_size_table[] = {\n-  'b', 'w', 'p', 'l'\n-};\n-\n-static const struct opcode page2[] =\n-  {\n-    [0x00] = {\"ld\",  opr_n_bytes_p1, 0, reg_s_opr},\n-    [0x01] = {\"st\",  opr_n_bytes_p1, 0, reg_s_opr},\n-    [0x02] = {\"cmp\", opr_n_bytes_p1, 0, reg_s_opr},\n-    [0x03] = {\"ld\",  four, 0, reg_s_imm},\n-    [0x04] = {\"cmp\", four, 0, reg_s_imm},\n-    [0x05] = {\"stop\", single, 0, 0},\n-    [0x06] = {\"wai\",  single, 0, 0},\n-    [0x07] = {\"sys\",  single, 0, 0},\n-    [0x08] = {NULL,  bfextins_n_bytes, 0, 0},  /* BFEXT / BFINS */\n-    [0x09] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0a] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0b] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0c] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0d] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0e] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x0f] = {NULL,  bfextins_n_bytes, 0, 0},\n-    [0x10] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x11] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x12] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x13] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x14] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x15] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x16] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x17] = {\"minu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x18] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x19] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1a] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1b] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1c] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1d] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1e] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x1f] = {\"maxu\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x20] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x21] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x22] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x23] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x24] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x25] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x26] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x27] = {\"mins\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x28] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x29] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2a] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2b] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2c] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2d] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2e] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x2f] = {\"maxs\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x30] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x31] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x32] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x33] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x34] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x35] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x36] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x37] = {\"div\", mul_n_bytes, mul_decode, 0},\n-    [0x38] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x39] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3a] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3b] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3c] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3d] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3e] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x3f] = {\"mod\", mul_n_bytes, mul_decode, 0},\n-    [0x40] = {\"abs\", single, reg, 0},\n-    [0x41] = {\"abs\", single, reg, 0},\n-    [0x42] = {\"abs\", single, reg, 0},\n-    [0x43] = {\"abs\", single, reg, 0},\n-    [0x44] = {\"abs\", single, reg, 0},\n-    [0x45] = {\"abs\", single, reg, 0},\n-    [0x46] = {\"abs\", single, reg, 0},\n-    [0x47] = {\"abs\", single, reg, 0},\n-    [0x48] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x49] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4a] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4b] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4c] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4d] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4e] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x4f] = {\"mac\", mul_n_bytes, mul_decode, 0},\n-    [0x50] = {\"adc\", three, reg, imm1234_0base},\n-    [0x51] = {\"adc\", three, reg, imm1234_0base},\n-    [0x52] = {\"adc\", three, reg, imm1234_0base},\n-    [0x53] = {\"adc\", three, reg, imm1234_0base},\n-    [0x54] = {\"adc\", two,   reg, imm1234_0base},\n-    [0x55] = {\"adc\", two,   reg, imm1234_0base},\n-    [0x56] = {\"adc\", five,  reg, imm1234_0base},\n-    [0x57] = {\"adc\", five,  reg, imm1234_0base},\n-    [0x58] = {\"bit\", three, reg, imm1234_8base},\n-    [0x59] = {\"bit\", three, reg, imm1234_8base},\n-    [0x5a] = {\"bit\", three, reg, imm1234_8base},\n-    [0x5b] = {\"bit\", three, reg, imm1234_8base},\n-    [0x5c] = {\"bit\", two,   reg, imm1234_8base},\n-    [0x5d] = {\"bit\", two,   reg, imm1234_8base},\n-    [0x5e] = {\"bit\", five,  reg, imm1234_8base},\n-    [0x5f] = {\"bit\", five,  reg, imm1234_8base},\n-    [0x60] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x61] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x62] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x63] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x64] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x65] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x66] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x67] = {\"adc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x68] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x69] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6a] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6b] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6c] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6d] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6e] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6f] = {\"bit\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x70] = {\"sbc\", three, reg, imm1234_0base},\n-    [0x71] = {\"sbc\", three, reg, imm1234_0base},\n-    [0x72] = {\"sbc\", three, reg, imm1234_0base},\n-    [0x73] = {\"sbc\", three, reg, imm1234_0base},\n-    [0x74] = {\"sbc\", two,   reg, imm1234_0base},\n-    [0x75] = {\"sbc\", two,   reg, imm1234_0base},\n-    [0x76] = {\"sbc\", five,  reg, imm1234_0base},\n-    [0x77] = {\"sbc\", five,  reg, imm1234_0base},\n-    [0x78] = {\"eor\", three, reg, imm1234_8base},\n-    [0x79] = {\"eor\", three, reg, imm1234_8base},\n-    [0x7a] = {\"eor\", three, reg, imm1234_8base},\n-    [0x7b] = {\"eor\", three, reg, imm1234_8base},\n-    [0x7c] = {\"eor\", two,   reg, imm1234_8base},\n-    [0x7d] = {\"eor\", two,   reg, imm1234_8base},\n-    [0x7e] = {\"eor\", five,  reg, imm1234_8base},\n-    [0x7f] = {\"eor\", five,  reg, imm1234_8base},\n-    [0x80] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x81] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x82] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x83] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x84] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x85] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x86] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x87] = {\"sbc\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x88] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x89] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8a] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8b] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8c] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8d] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8e] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8f] = {\"eor\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x90] = {\"rti\",  single, 0, 0},\n-    [0x91] = {\"clb\",   two, tfr, 0},\n-    [0x92] = {\"trap\",  single, trap_decode, 0},\n-    [0x93] = {\"trap\",  single, trap_decode, 0},\n-    [0x94] = {\"trap\",  single, trap_decode, 0},\n-    [0x95] = {\"trap\",  single, trap_decode, 0},\n-    [0x96] = {\"trap\",  single, trap_decode, 0},\n-    [0x97] = {\"trap\",  single, trap_decode, 0},\n-    [0x98] = {\"trap\",  single, trap_decode, 0},\n-    [0x99] = {\"trap\",  single, trap_decode, 0},\n-    [0x9a] = {\"trap\",  single, trap_decode, 0},\n-    [0x9b] = {\"trap\",  single, trap_decode, 0},\n-    [0x9c] = {\"trap\",  single, trap_decode, 0},\n-    [0x9d] = {\"trap\",  single, trap_decode, 0},\n-    [0x9e] = {\"trap\",  single, trap_decode, 0},\n-    [0x9f] = {\"trap\",  single, trap_decode, 0},\n-    [0xa0] = {\"sat\", single, reg, 0},\n-    [0xa1] = {\"sat\", single, reg, 0},\n-    [0xa2] = {\"sat\", single, reg, 0},\n-    [0xa3] = {\"sat\", single, reg, 0},\n-    [0xa4] = {\"sat\", single, reg, 0},\n-    [0xa5] = {\"sat\", single, reg, 0},\n-    [0xa6] = {\"sat\", single, reg, 0},\n-    [0xa7] = {\"sat\", single, reg, 0},\n-    [0xa8] = {\"trap\",  single, trap_decode, 0},\n-    [0xa9] = {\"trap\",  single, trap_decode, 0},\n-    [0xaa] = {\"trap\",  single, trap_decode, 0},\n-    [0xab] = {\"trap\",  single, trap_decode, 0},\n-    [0xac] = {\"trap\",  single, trap_decode, 0},\n-    [0xad] = {\"trap\",  single, trap_decode, 0},\n-    [0xae] = {\"trap\",  single, trap_decode, 0},\n-    [0xaf] = {\"trap\",  single, trap_decode, 0},\n-    [0xb0] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb1] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb2] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb3] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb4] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb5] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb6] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb7] = {\"qmul\", mul_n_bytes, mul_decode, 0},\n-    [0xb8] = {\"trap\",  single, trap_decode, 0},\n-    [0xb9] = {\"trap\",  single, trap_decode, 0},\n-    [0xba] = {\"trap\",  single, trap_decode, 0},\n-    [0xbb] = {\"trap\",  single, trap_decode, 0},\n-    [0xbc] = {\"trap\",  single, trap_decode, 0},\n-    [0xbd] = {\"trap\",  single, trap_decode, 0},\n-    [0xbe] = {\"trap\",  single, trap_decode, 0},\n-    [0xbf] = {\"trap\",  single, trap_decode, 0},\n-    [0xc0] = {\"trap\",  single, trap_decode, 0},\n-    [0xc1] = {\"trap\",  single, trap_decode, 0},\n-    [0xc2] = {\"trap\",  single, trap_decode, 0},\n-    [0xc3] = {\"trap\",  single, trap_decode, 0},\n-    [0xc4] = {\"trap\",  single, trap_decode, 0},\n-    [0xc5] = {\"trap\",  single, trap_decode, 0},\n-    [0xc6] = {\"trap\",  single, trap_decode, 0},\n-    [0xc7] = {\"trap\",  single, trap_decode, 0},\n-    [0xc8] = {\"trap\",  single, trap_decode, 0},\n-    [0xc9] = {\"trap\",  single, trap_decode, 0},\n-    [0xca] = {\"trap\",  single, trap_decode, 0},\n-    [0xcb] = {\"trap\",  single, trap_decode, 0},\n-    [0xcc] = {\"trap\",  single, trap_decode, 0},\n-    [0xcd] = {\"trap\",  single, trap_decode, 0},\n-    [0xce] = {\"trap\",  single, trap_decode, 0},\n-    [0xcf] = {\"trap\",  single, trap_decode, 0},\n-    [0xd0] = {\"trap\",  single, trap_decode, 0},\n-    [0xd1] = {\"trap\",  single, trap_decode, 0},\n-    [0xd2] = {\"trap\",  single, trap_decode, 0},\n-    [0xd3] = {\"trap\",  single, trap_decode, 0},\n-    [0xd4] = {\"trap\",  single, trap_decode, 0},\n-    [0xd5] = {\"trap\",  single, trap_decode, 0},\n-    [0xd6] = {\"trap\",  single, trap_decode, 0},\n-    [0xd7] = {\"trap\",  single, trap_decode, 0},\n-    [0xd8] = {\"trap\",  single, trap_decode, 0},\n-    [0xd9] = {\"trap\",  single, trap_decode, 0},\n-    [0xda] = {\"trap\",  single, trap_decode, 0},\n-    [0xdb] = {\"trap\",  single, trap_decode, 0},\n-    [0xdc] = {\"trap\",  single, trap_decode, 0},\n-    [0xdd] = {\"trap\",  single, trap_decode, 0},\n-    [0xde] = {\"trap\",  single, trap_decode, 0},\n-    [0xdf] = {\"trap\",  single, trap_decode, 0},\n-    [0xe0] = {\"trap\",  single, trap_decode, 0},\n-    [0xe1] = {\"trap\",  single, trap_decode, 0},\n-    [0xe2] = {\"trap\",  single, trap_decode, 0},\n-    [0xe3] = {\"trap\",  single, trap_decode, 0},\n-    [0xe4] = {\"trap\",  single, trap_decode, 0},\n-    [0xe5] = {\"trap\",  single, trap_decode, 0},\n-    [0xe6] = {\"trap\",  single, trap_decode, 0},\n-    [0xe7] = {\"trap\",  single, trap_decode, 0},\n-    [0xe8] = {\"trap\",  single, trap_decode, 0},\n-    [0xe9] = {\"trap\",  single, trap_decode, 0},\n-    [0xea] = {\"trap\",  single, trap_decode, 0},\n-    [0xeb] = {\"trap\",  single, trap_decode, 0},\n-    [0xec] = {\"trap\",  single, trap_decode, 0},\n-    [0xed] = {\"trap\",  single, trap_decode, 0},\n-    [0xee] = {\"trap\",  single, trap_decode, 0},\n-    [0xef] = {\"trap\",  single, trap_decode, 0},\n-    [0xf0] = {\"trap\",  single, trap_decode, 0},\n-    [0xf1] = {\"trap\",  single, trap_decode, 0},\n-    [0xf2] = {\"trap\",  single, trap_decode, 0},\n-    [0xf3] = {\"trap\",  single, trap_decode, 0},\n-    [0xf4] = {\"trap\",  single, trap_decode, 0},\n-    [0xf5] = {\"trap\",  single, trap_decode, 0},\n-    [0xf6] = {\"trap\",  single, trap_decode, 0},\n-    [0xf7] = {\"trap\",  single, trap_decode, 0},\n-    [0xf8] = {\"trap\",  single, trap_decode, 0},\n-    [0xf9] = {\"trap\",  single, trap_decode, 0},\n-    [0xfa] = {\"trap\",  single, trap_decode, 0},\n-    [0xfb] = {\"trap\",  single, trap_decode, 0},\n-    [0xfc] = {\"trap\",  single, trap_decode, 0},\n-    [0xfd] = {\"trap\",  single, trap_decode, 0},\n-    [0xfe] = {\"trap\",  single, trap_decode, 0},\n-    [0xff] = {\"trap\",  single, trap_decode, 0},\n-  };\n-\n-static const struct opcode page1[] =\n-  {\n-    [0x00] = {\"bgnd\", single, 0, 0},\n-    [0x01] = {\"nop\",  single, 0, 0},\n-    [0x02] = {\"brclr\", bm_rel_n_bytes, bm_rel_decode, 0},\n-    [0x03] = {\"brset\", bm_rel_n_bytes, bm_rel_decode, 0},\n-    [0x04] = {NULL,   two,    0, 0}, /* psh/pul */\n-    [0x05] = {\"rts\",  single, 0, 0},\n-    [0x06] = {\"lea\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x07] = {\"lea\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x08] = {\"lea\", opr_n_bytes_p1, lea_reg_xys_opr, 0},\n-    [0x09] = {\"lea\", opr_n_bytes_p1, lea_reg_xys_opr, 0},\n-    [0x0a] = {\"lea\", opr_n_bytes_p1, lea_reg_xys_opr, 0},\n-    [0x0b] = {NULL, loop_prim_n_bytes, 0, 0}, /* Loop primitives TBcc / DBcc */\n-    [0x0c] = {\"mov.b\", mov_imm_opr_n_bytes, mov_imm_opr, 0},\n-    [0x0d] = {\"mov.w\", mov_imm_opr_n_bytes, mov_imm_opr, 0},\n-    [0x0e] = {\"mov.p\", mov_imm_opr_n_bytes, mov_imm_opr, 0},\n-    [0x0f] = {\"mov.l\", mov_imm_opr_n_bytes, mov_imm_opr, 0},\n-    [0x10] = {NULL,   shift_n_bytes, 0, 0},  /* lsr/lsl/asl/asr/rol/ror */\n-    [0x11] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x12] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x13] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x14] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x15] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x16] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x17] = {NULL,   shift_n_bytes, 0, 0},\n-    [0x18] = {\"lea\",  two, lea_reg_xys, NULL},\n-    [0x19] = {\"lea\",  two, lea_reg_xys, NULL},\n-    [0x1a] = {\"lea\",  two, lea_reg_xys, NULL},\n-    /* 0x1b PG2 */\n-    [0x1c] = {\"mov.b\", opr_n_bytes2, 0, opr_decode2},\n-    [0x1d] = {\"mov.w\", opr_n_bytes2, 0, opr_decode2},\n-    [0x1e] = {\"mov.p\", opr_n_bytes2, 0, opr_decode2},\n-    [0x1f] = {\"mov.l\", opr_n_bytes2, 0, opr_decode2},\n-    [0x20] = {\"bra\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x21] = {\"bsr\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x22] = {\"bhi\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x23] = {\"bls\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x24] = {\"bcc\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x25] = {\"bcs\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x26] = {\"bne\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x27] = {\"beq\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x28] = {\"bvc\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x29] = {\"bvs\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2a] = {\"bpl\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2b] = {\"bmi\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2c] = {\"bge\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2d] = {\"blt\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2e] = {\"bgt\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x2f] = {\"ble\",  pcrel_15bit, decode_rel_15_7, 0},\n-    [0x30] = {\"inc\", single, reg, 0},\n-    [0x31] = {\"inc\", single, reg, 0},\n-    [0x32] = {\"inc\", single, reg, 0},\n-    [0x33] = {\"inc\", single, reg, 0},\n-    [0x34] = {\"inc\", single, reg, 0},\n-    [0x35] = {\"inc\", single, reg, 0},\n-    [0x36] = {\"inc\", single, reg, 0},\n-    [0x37] = {\"inc\", single, reg, 0},\n-    [0x38] = {\"clr\", single, reg, 0},\n-    [0x39] = {\"clr\", single, reg, 0},\n-    [0x3a] = {\"clr\", single, reg, 0},\n-    [0x3b] = {\"clr\", single, reg, 0},\n-    [0x3c] = {\"clr\", single, reg, 0},\n-    [0x3d] = {\"clr\", single, reg, 0},\n-    [0x3e] = {\"clr\", single, reg, 0},\n-    [0x3f] = {\"clr\", single, reg, 0},\n-    [0x40] = {\"dec\", single, reg, 0},\n-    [0x41] = {\"dec\", single, reg, 0},\n-    [0x42] = {\"dec\", single, reg, 0},\n-    [0x43] = {\"dec\", single, reg, 0},\n-    [0x44] = {\"dec\", single, reg, 0},\n-    [0x45] = {\"dec\", single, reg, 0},\n-    [0x46] = {\"dec\", single, reg, 0},\n-    [0x47] = {\"dec\", single, reg, 0},\n-    [0x48] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x49] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4a] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4b] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4c] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4d] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4e] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x4f] = {\"mul\", mul_n_bytes, mul_decode, 0},\n-    [0x50] = {\"add\", three, reg, imm1234_0base},\n-    [0x51] = {\"add\", three, reg, imm1234_0base},\n-    [0x52] = {\"add\", three, reg, imm1234_0base},\n-    [0x53] = {\"add\", three, reg, imm1234_0base},\n-    [0x54] = {\"add\", two,   reg, imm1234_0base},\n-    [0x55] = {\"add\", two,   reg, imm1234_0base},\n-    [0x56] = {\"add\", five,  reg, imm1234_0base},\n-    [0x57] = {\"add\", five,  reg, imm1234_0base},\n-    [0x58] = {\"and\", three, reg, imm1234_8base},\n-    [0x59] = {\"and\", three, reg, imm1234_8base},\n-    [0x5a] = {\"and\", three, reg, imm1234_8base},\n-    [0x5b] = {\"and\", three, reg, imm1234_8base},\n-    [0x5c] = {\"and\", two,   reg, imm1234_8base},\n-    [0x5d] = {\"and\", two,   reg, imm1234_8base},\n-    [0x5e] = {\"and\", five,  reg, imm1234_8base},\n-    [0x5f] = {\"and\", five,  reg, imm1234_8base},\n-    [0x60] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x61] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x62] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x63] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x64] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x65] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x66] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x67] = {\"add\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x68] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x69] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6a] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6b] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6c] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6d] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6e] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x6f] = {\"and\", opr_n_bytes_p1, reg, opr_decode},\n-    [0x70] = {\"sub\", three, reg, imm1234_0base},\n-    [0x71] = {\"sub\", three, reg, imm1234_0base},\n-    [0x72] = {\"sub\", three, reg, imm1234_0base},\n-    [0x73] = {\"sub\", three, reg, imm1234_0base},\n-    [0x74] = {\"sub\", two,   reg, imm1234_0base},\n-    [0x75] = {\"sub\", two,   reg, imm1234_0base},\n-    [0x76] = {\"sub\", five,  reg, imm1234_0base},\n-    [0x77] = {\"sub\", five,  reg, imm1234_0base},\n-    [0x78] = {\"or\", three, reg, imm1234_8base},\n-    [0x79] = {\"or\", three, reg, imm1234_8base},\n-    [0x7a] = {\"or\", three, reg, imm1234_8base},\n-    [0x7b] = {\"or\", three, reg, imm1234_8base},\n-    [0x7c] = {\"or\", two,   reg, imm1234_8base},\n-    [0x7d] = {\"or\", two,   reg, imm1234_8base},\n-    [0x7e] = {\"or\", five,  reg, imm1234_8base},\n-    [0x7f] = {\"or\", five,  reg, imm1234_8base},\n-    [0x80] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x81] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x82] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x83] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x84] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x85] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x86] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x87] = {\"sub\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x88] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x89] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8a] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8b] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8c] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8d] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8e] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x8f] = {\"or\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0x90] = {\"ld\", three,  reg, imm1234_0base},\n-    [0x91] = {\"ld\", three,  reg, imm1234_0base},\n-    [0x92] = {\"ld\", three,  reg, imm1234_0base},\n-    [0x93] = {\"ld\", three,  reg, imm1234_0base},\n-    [0x94] = {\"ld\", two,    reg, imm1234_0base},\n-    [0x95] = {\"ld\", two,    reg, imm1234_0base},\n-    [0x96] = {\"ld\", five,   reg, imm1234_0base},\n-    [0x97] = {\"ld\", five,   reg, imm1234_0base},\n-    [0x98] = {\"ld\", four,   reg_xy, imm1234_0base},\n-    [0x99] = {\"ld\", four,   reg_xy, imm1234_0base},\n-    [0x9a] = {\"clr\", single, reg_xy, 0},\n-    [0x9b] = {\"clr\", single, reg_xy, 0},\n-    [0x9c] = {\"inc.b\", opr_n_bytes_p1, 0, opr_decode},\n-    [0x9d] = {\"inc.w\", opr_n_bytes_p1, 0, opr_decode},\n-    [0x9e] = {\"tfr\", two, tfr, NULL},\n-    [0x9f] = {\"inc.l\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xa0] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa1] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa2] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa3] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa4] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa5] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa6] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa7] = {\"ld\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xa8] = {\"ld\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xa9] = {\"ld\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xaa] = {\"jmp\", opr_n_bytes_p1, opr_decode, 0},\n-    [0xab] = {\"jsr\", opr_n_bytes_p1, opr_decode, 0},\n-    [0xac] = {\"dec.b\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xad] = {\"dec.w\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xae] = {NULL,   two, 0, 0},  /* EXG / SEX */\n-    [0xaf] = {\"dec.l\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xb0] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb1] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb2] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb3] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb4] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb5] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb6] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb7] = {\"ld\", four,  reg, ext24_decode},\n-    [0xb8] = {\"ld\", four,  reg_xy, ext24_decode},\n-    [0xb9] = {\"ld\", four,  reg_xy, ext24_decode},\n-    [0xba] = {\"jmp\", four, ext24_decode, 0},\n-    [0xbb] = {\"jsr\", four, ext24_decode, 0},\n-    [0xbc] = {\"clr.b\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xbd] = {\"clr.w\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xbe] = {\"clr.p\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xbf] = {\"clr.l\", opr_n_bytes_p1, 0, opr_decode},\n-    [0xc0] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc1] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc2] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc3] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc4] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc5] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc6] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc7] = {\"st\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xc8] = {\"st\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xc9] = {\"st\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xca] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xcb] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xcc] = {\"com.b\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xcd] = {\"com.w\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xce] = {\"andcc\", two, imm1, 0},\n-    [0xcf] = {\"com.l\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xd0] = {\"st\", four,  reg, ext24_decode},\n-    [0xd1] = {\"st\", four,  reg, ext24_decode},\n-    [0xd2] = {\"st\", four,  reg, ext24_decode},\n-    [0xd3] = {\"st\", four,  reg, ext24_decode},\n-    [0xd4] = {\"st\", four,  reg, ext24_decode},\n-    [0xd5] = {\"st\", four,  reg, ext24_decode},\n-    [0xd6] = {\"st\", four,  reg, ext24_decode},\n-    [0xd7] = {\"st\", four,  reg, ext24_decode},\n-    [0xd8] = {\"st\", four,  reg_xy, ext24_decode},\n-    [0xd9] = {\"st\", four,  reg_xy, ext24_decode},\n-    [0xda] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xdb] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xdc] = {\"neg.b\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xdd] = {\"neg.w\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xde] = {\"orcc\",  two,  imm1, 0},\n-    [0xdf] = {\"neg.l\", opr_n_bytes_p1, NULL, opr_decode},\n-    [0xe0] = {\"cmp\", three,  reg, imm1234_0base},\n-    [0xe1] = {\"cmp\", three,  reg, imm1234_0base},\n-    [0xe2] = {\"cmp\", three,  reg, imm1234_0base},\n-    [0xe3] = {\"cmp\", three,  reg, imm1234_0base},\n-    [0xe4] = {\"cmp\", two,    reg, imm1234_0base},\n-    [0xe5] = {\"cmp\", two,    reg, imm1234_0base},\n-    [0xe6] = {\"cmp\", five,   reg, imm1234_0base},\n-    [0xe7] = {\"cmp\", five,   reg, imm1234_0base},\n-    [0xe8] = {\"cmp\", four,   reg_xy, imm1234_0base},\n-    [0xe9] = {\"cmp\", four,   reg_xy, imm1234_0base},\n-    [0xea] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xeb] = {\"ld\", three, reg_xy, ld_18bit_decode},\n-    [0xec] = {\"bclr\", bm_n_bytes, bm_decode, 0},\n-    [0xed] = {\"bset\", bm_n_bytes, bm_decode, 0},\n-    [0xee] = {\"btgl\", bm_n_bytes, bm_decode, 0},\n-    [0xef] = {\"!!invalid!!\", NULL, NULL, NULL}, /* SPARE */\n-    [0xf0] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf1] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf2] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf3] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf4] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf5] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf6] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf7] = {\"cmp\", opr_n_bytes_p1, reg,    opr_decode},\n-    [0xf8] = {\"cmp\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xf9] = {\"cmp\", opr_n_bytes_p1, reg_xy, opr_decode},\n-    [0xfa] = {\"ld\",  three, reg_xy, ld_18bit_decode},\n-    [0xfb] = {\"ld\",  three, reg_xy, ld_18bit_decode},\n-    [0xfc] = {\"cmp\", single, cmp_xy, 0},\n-    [0xfd] = {\"sub\", single, sub_d6_x_y, 0},\n-    [0xfe] = {\"sub\", single, sub_d6_y_x, 0},\n-    [0xff] = {\"swi\", single, 0, 0}\n-  };\n-\n-\n-static const char *oprregs1[] =\n-  {\n-    \"d3\", \"d2\", \"d1\", \"d0\", \"ccl\", \"cch\"\n-  };\n-\n-static const char *oprregs2[] =\n-  {\n-    \"y\", \"x\", \"d7\", \"d6\", \"d5\", \"d4\"\n-  };\n-\n-\n-\f\n-\n-enum MUL_MODE\n-  {\n-    MUL_REG_REG,\n-    MUL_REG_OPR,\n-    MUL_REG_IMM,\n-    MUL_OPR_OPR\n-  };\n-\n-struct mb\n-{\n-  uint8_t mask;\n-  uint8_t value;\n-  enum MUL_MODE mode;\n-};\n-\n-static const struct mb mul_table[] = {\n-  {0x40, 0x00, MUL_REG_REG},\n-\n-  {0x47, 0x40, MUL_REG_OPR},\n-  {0x47, 0x41, MUL_REG_OPR},\n-  {0x47, 0x43, MUL_REG_OPR},\n-\n-  {0x47, 0x44, MUL_REG_IMM},\n-  {0x47, 0x45, MUL_REG_IMM},\n-  {0x47, 0x47, MUL_REG_IMM},\n-\n-  {0x43, 0x42, MUL_OPR_OPR},\n-};\n-\n-static void\n-mul_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  uint8_t mb;\n-  int status = read_memory (memaddr, &mb, 1, info);\n-  if (status < 0)\n-    return;\n-\n-\n-  uint8_t byte;\n-  status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  (*info->fprintf_func) (info->stream, \"%c\", (mb & 0x80) ? 's' : 'u');\n-\n-  enum MUL_MODE mode = -1;\n-  size_t i;\n-  for (i = 0; i < sizeof (mul_table) / sizeof (mul_table[0]); ++i)\n-    {\n-      const struct mb *mm = mul_table + i;\n-      if ((mb & mm->mask) == mm->value)\n-\t{\n-\t  mode = mm->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  switch (mode)\n-    {\n-    case MUL_REG_REG:\n-      break;\n-    case MUL_OPR_OPR:\n-      {\n-\tint size1 = (mb & 0x30) >> 4;\n-\tint size2 = (mb & 0x0c) >> 2;\n-\t(*info->fprintf_func) (info->stream, \".%c%c\",\n-\t\t\t       shift_size_table [size1],\n-\t\t\t       shift_size_table [size2]);\n-      }\n-      break;\n-    default:\n-      {\n-\tint size = (mb & 0x3);\n-\t(*info->fprintf_func) (info->stream, \".%c\", shift_size_table [size]);\n-      }\n-      break;\n-    }\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", registers[byte & 0x7].name);\n-\n-  switch (mode)\n-    {\n-    case MUL_REG_REG:\n-    case MUL_REG_IMM:\n-    case MUL_REG_OPR:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[(mb & 0x38) >> 3].name);\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  switch (mode)\n-    {\n-    case MUL_REG_IMM:\n-      operand_separator (info);\n-      int size = (mb & 0x3);\n-      uint32_t imm = decode_signed_value (memaddr + 1, info, size + 1);\n-      (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      break;\n-    case MUL_REG_REG:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[mb & 0x07].name);\n-      break;\n-    case MUL_REG_OPR:\n-      opr_decode (memaddr + 1, info);\n-      break;\n-    case MUL_OPR_OPR:\n-      {\n-\tint first = opr_n_bytes (memaddr + 1, info);\n-\topr_decode (memaddr + 1, info);\n-\topr_decode (memaddr + first + 1, info);\n-\tbreak;\n-      }\n-    }\n-}\n-\n-\n-static int\n-mul_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  int nx = 2;\n-  uint8_t mb;\n-  int status = read_memory (memaddr, &mb, 1, info);\n-  if (status < 0)\n-    return 0;\n-\n-  enum MUL_MODE mode = -1;\n-  size_t i;\n-  for (i = 0; i < sizeof (mul_table) / sizeof (mul_table[0]); ++i)\n-    {\n-      const struct mb *mm = mul_table + i;\n-      if ((mb & mm->mask) == mm->value)\n-\t{\n-\t  mode = mm->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  int size = (mb & 0x3) + 1;\n-\n-  switch (mode)\n-    {\n-    case MUL_REG_IMM:\n-      nx += size;\n-      break;\n-    case MUL_REG_REG:\n-      break;\n-    case MUL_REG_OPR:\n-      nx += opr_n_bytes (memaddr + 1, info);\n-      break;\n-    case MUL_OPR_OPR:\n-      {\n-\tint first = opr_n_bytes (memaddr + nx - 1, info);\n-\tnx += first;\n-\tint second = opr_n_bytes (memaddr + nx - 1, info);\n-\tnx += second;\n-      }\n-      break;\n-    }\n-\n-  return nx;\n-}\n-\n-\f\n- /* The NXP documentation is vague about BM_RESERVED0 and BM_RESERVED1,\n-    and contains obvious typos.\n-    However the Freescale tools and experiments with the chip itself\n-    seem to indicate that they behave like BM_REG_IMM and BM_OPR_REG\n-    respectively.  */\n-\n-enum BM_MODE {\n-  BM_REG_IMM,\n-  BM_RESERVED0,\n-  BM_OPR_B,\n-  BM_OPR_W,\n-  BM_OPR_L,\n-  BM_OPR_REG,\n-  BM_RESERVED1\n-};\n-\n-struct bm\n-{\n-  uint8_t mask;\n-  uint8_t value;\n-  enum BM_MODE mode;\n-};\n-\n-static const  struct bm bm_table[] = {\n-  { 0xC6, 0x04,     BM_REG_IMM},\n-  { 0x84, 0x00,     BM_REG_IMM},\n-  { 0x06, 0x06,     BM_REG_IMM},\n-  { 0xC6, 0x44,     BM_RESERVED0},\n-  // 00\n-  { 0x8F, 0x80,     BM_OPR_B},\n-  { 0x8E, 0x82,     BM_OPR_W},\n-  { 0x8C, 0x88,     BM_OPR_L},\n-\n-  { 0x83, 0x81,     BM_OPR_REG},\n-  { 0x87, 0x84,     BM_RESERVED1},\n-};\n-\n-static void\n-bm_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  uint8_t bm;\n-  int status = read_memory (memaddr, &bm, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  size_t i;\n-  enum BM_MODE mode = -1;\n-  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n-    {\n-      const struct bm *bme = bm_table + i;\n-      if ((bm & bme->mask) == bme->value)\n-\t{\n-\t  mode = bme->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  switch (mode)\n-    {\n-    case BM_REG_IMM:\n-    case BM_RESERVED0:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[bm & 0x07].name);\n-      break;\n-    case BM_OPR_B:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'b');\n-      opr_decode (memaddr + 1, info);\n-      break;\n-    case BM_OPR_W:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'w');\n-      opr_decode (memaddr + 1, info);\n-      break;\n-    case BM_OPR_L:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'l');\n-      opr_decode (memaddr + 1, info);\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      {\n-\tuint8_t xb;\n-\tread_memory (memaddr + 1, &xb, 1, info);\n-\t/* Don't emit a size suffix for register operands */\n-\tif ((xb & 0xF8) != 0xB8)\n-\t  (*info->fprintf_func) (info->stream, \".%c\", shift_size_table[(bm & 0x0c) >> 2]);\n-\topr_decode (memaddr + 1, info);\n-      }\n-      break;\n-    }\n-\n-  uint8_t imm = 0;\n-  operand_separator (info);\n-  switch (mode)\n-    {\n-    case BM_REG_IMM:\n-      {\n-\timm = (bm & 0x38) >> 3;\n-\t(*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      }\n-      break;\n-    case BM_OPR_L:\n-      imm |= (bm & 0x03) << 3;\n-      /* fallthrough */\n-    case BM_OPR_W:\n-      imm |= (bm & 0x01) << 3;\n-      /* fallthrough */\n-    case BM_OPR_B:\n-      imm |= (bm & 0x70) >> 4;\n-      (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[(bm & 0x70) >> 4].name);\n-      break;\n-    case BM_RESERVED0:\n-      assert (0);\n-      break;\n-    }\n-}\n-\n-\n-static void\n-bm_rel_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  uint8_t bm;\n-  int status = read_memory (memaddr, &bm, 1, info);\n-  if (status < 0)\n-    return;\n-\n-  size_t i;\n-  enum BM_MODE mode = -1;\n-  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n-    {\n-      const struct bm *bme = bm_table + i;\n-      if ((bm & bme->mask) == bme->value)\n-\t{\n-\t  mode = bme->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  switch (mode)\n-    {\n-    case BM_REG_IMM:\n-    case BM_RESERVED0:\n-      break;\n-    case BM_OPR_B:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'b');\n-      break;\n-    case BM_OPR_W:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'w');\n-      break;\n-    case BM_OPR_L:\n-      (*info->fprintf_func) (info->stream, \".%c\", 'l');\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      {\n-\tuint8_t xb;\n-\tread_memory (memaddr + 1, &xb, 1, info);\n-\t/* Don't emit a size suffix for register operands */\n-\tif ((xb & 0xF8) != 0xB8)\n-\t  (*info->fprintf_func) (info->stream, \".%c\",\n-\t\t\t\t shift_size_table[(bm & 0x0C) >> 2]);\n-      }\n-      break;\n-    }\n-\n-  int n = 1;\n-  switch (mode)\n-    {\n-    case BM_REG_IMM:\n-    case BM_RESERVED0:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[bm & 0x07].name);\n-      break;\n-    case BM_OPR_B:\n-    case BM_OPR_W:\n-    case BM_OPR_L:\n-      opr_decode (memaddr + 1, info);\n-      n = 1 + opr_n_bytes (memaddr + 1, info);\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      opr_decode (memaddr + 1, info);\n-      break;\n-    }\n-\n-\n-  int imm = 0;\n-  operand_separator (info);\n-  switch (mode)\n-    {\n-    case BM_OPR_L:\n-      imm |= (bm & 0x02) << 3;\n-      /* fall through */\n-    case BM_OPR_W:\n-      imm |= (bm & 0x01) << 3;\n-      /* fall through */\n-    case BM_OPR_B:\n-      imm |= (bm & 0x70) >> 4;\n-      (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      break;\n-    case BM_RESERVED0:\n-      imm = (bm & 0x38) >> 3;\n-      (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      break;\n-    case BM_REG_IMM:\n-      imm = (bm & 0xF8) >> 3;\n-      (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[(bm & 0x70) >> 4].name);\n-      n += opr_n_bytes (memaddr + 1, info);\n-      break;\n-    }\n-\n-  rel_15_7 (memaddr + n, info, n + 1);\n-}\n-\n-static int\n-bm_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  uint8_t bm;\n-  int status = read_memory (memaddr, &bm, 1, info);\n-  if (status < 0)\n-    return status;\n-\n-  size_t i;\n-  enum BM_MODE mode = -1;\n-  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n-    {\n-      const struct bm *bme = bm_table + i;\n-      if ((bm & bme->mask) == bme->value)\n-\t{\n-\t  mode = bme->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  int n = 2;\n-  switch (mode)\n-    {\n-    case BM_REG_IMM:\n-    case BM_RESERVED0:\n-      break;\n-\n-    case BM_OPR_B:\n-    case BM_OPR_W:\n-    case BM_OPR_L:\n-      n += opr_n_bytes (memaddr + 1, info);\n-      break;\n-    case BM_OPR_REG:\n-    case BM_RESERVED1:\n-      n += opr_n_bytes (memaddr + 1, info);\n-      break;\n-  }\n-\n-  return n;\n-}\n-\n-static int\n-bm_rel_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  int n = 1 + bm_n_bytes (memaddr, info);\n-\n-  bfd_byte rb;\n-  int status = read_memory (memaddr + n - 2, &rb, 1, info);\n-  if (status != 0)\n-    return status;\n-\n-  if (rb & 0x80)\n-    n++;\n-\n-  return n;\n-}\n-\n-\n-\f\n-\n-\n-/* shift direction */\n-enum SB_DIR\n-  {\n-    SB_LEFT,\n-    SB_RIGHT\n-  };\n-\n-enum SB_TYPE\n-  {\n-    SB_ARITHMETIC,\n-    SB_LOGICAL\n-  };\n-\n-\n-enum SB_MODE\n-  {\n-    SB_REG_REG_N_EFF,\n-    SB_REG_REG_N,\n-    SB_REG_OPR_EFF,\n-    SB_ROT,\n-    SB_REG_OPR_OPR,\n-    SB_OPR_N\n-  };\n-\n-struct sb\n-{\n-  uint8_t mask;\n-  uint8_t value;\n-  enum SB_MODE mode;\n-};\n-\n-static const  struct sb sb_table[] = {\n-  {0x30, 0x00,     SB_REG_REG_N_EFF},\n-  {0x30, 0x10,     SB_REG_REG_N},\n-  {0x34, 0x20,     SB_REG_OPR_EFF},\n-  {0x34, 0x24,     SB_ROT},\n-  {0x34, 0x30,     SB_REG_OPR_OPR},\n-  {0x34, 0x34,     SB_OPR_N},\n-};\n-\n-static int\n-shift_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte sb;\n-  int status = read_memory (memaddr++, &sb, 1, info);\n-  if (status != 0)\n-    return status;\n-\n-  size_t i;\n-  enum SB_MODE mode = -1;\n-  for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n-    {\n-      const struct sb *sbe = sb_table + i;\n-      if ((sb & sbe->mask) == sbe->value)\n-\tmode = sbe->mode;\n-    }\n-\n-  switch (mode)\n-    {\n-    case SB_REG_REG_N_EFF:\n-      return 2;\n-      break;\n-    case SB_REG_OPR_EFF:\n-    case SB_ROT:\n-\treturn 2 + opr_n_bytes (memaddr, info);\n-      break;\n-    case SB_REG_OPR_OPR:\n-      {\n-\tint opr1 = opr_n_bytes (memaddr, info);\n-\tint opr2 = 0;\n-\tif ((sb & 0x30) != 0x20)\n-\t  opr2 = opr_n_bytes (memaddr + opr1, info);\n-\treturn 2 + opr1 + opr2;\n-      }\n-      break;\n-    default:\n-      return 3;\n-    }\n-\n-  /* not reached */\n-  return -1;\n-}\n-\f\n-\n-static int\n-mov_imm_opr_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return status;\n-\n-  int size = byte - 0x0c + 1;\n-\n-  return size + opr_n_bytes (memaddr + size, info) + 1;\n-}\n-\n-static void\n-mov_imm_opr (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr - 1, &byte, 1, info);\n-  if (status < 0)\n-    return ;\n-\n-  int size = byte - 0x0c + 1;\n-  uint32_t imm = decode_signed_value (memaddr, info, size);\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-  opr_decode (memaddr + size, info);\n-}\n-\n-\f\n-\n-static void\n-ld_18bit_decode (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  size_t size = 3;\n-  bfd_byte buffer[3];\n-  int status = read_memory (memaddr, buffer + 1, 2, info);\n-  if (status < 0)\n-    return ;\n-\n-\n-  status = read_memory (memaddr - 1, buffer, 1, info);\n-  if (status < 0)\n-    return ;\n-\n-  buffer[0] = (buffer[0] & 0x30) >> 4;\n-\n-  size_t i;\n-  uint32_t imm = 0;\n-  for (i = 0; i < size; ++i)\n-    {\n-      imm |= buffer[i] << (8 * (size - i - 1));\n-    }\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-}\n-\n-\f\n-\n-/* Loop Primitives */\n-\n-enum LP_MODE {\n-  LP_REG,\n-  LP_XY,\n-  LP_OPR\n-};\n-\n-struct lp\n-{\n-  uint8_t mask;\n-  uint8_t value;\n-  enum LP_MODE mode;\n-};\n-\n-static const struct lp lp_mode[] = {\n-  {0x08, 0x00, LP_REG},\n-  {0x0C, 0x08, LP_XY},\n-  {0x0C, 0x0C, LP_OPR},\n-};\n-\n-\n-static const char *lb_condition[] =\n-  {\n-    \"ne\", \"eq\", \"pl\", \"mi\", \"gt\", \"le\",\n-    \"??\", \"??\"\n-  };\n-\n-static int\n-loop_prim_n_bytes (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  int mx = 0;\n-  uint8_t lb;\n-  read_memory (memaddr + mx++, &lb, 1, info);\n-\n-  enum LP_MODE mode = -1;\n-  size_t i;\n-  for (i = 0; i < sizeof (lp_mode) / sizeof (lp_mode[0]); ++i)\n-    {\n-      const struct lp *pb = lp_mode + i;\n-      if ((lb & pb->mask) == pb->value)\n-\t{\n-\t  mode = pb->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  if (mode == LP_OPR)\n-    {\n-      mx += opr_n_bytes (memaddr + mx, info) ;\n-    }\n-\n-  uint8_t rb;\n-  read_memory (memaddr + mx++, &rb, 1, info);\n-  if (rb & 0x80)\n-    mx++;\n-\n-  return mx + 1;\n-}\n-\n-\n-\f\n-\n-static int\n-print_insn_exg_sex (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  uint8_t eb;\n-  int status = read_memory (memaddr, &eb, 1, info);\n-  if (status < 0)\n-    return -1;\n-\n-  const struct reg *first =  &registers[(eb & 0xf0) >> 4];\n-  const struct reg *second = &registers[(eb & 0xf)];\n-\n-  if (first->bytes < second->bytes)\n-    (*info->fprintf_func) (info->stream, \"sex\");\n-  else\n-    (*info->fprintf_func) (info->stream, \"exg\");\n-\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", first->name);\n-  operand_separator (info);\n-  (*info->fprintf_func) (info->stream, \"%s\", second->name);\n-  return 0;\n-}\n-\n-\n-\n-static int\n-print_insn_loop_primitive (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  int offs = 1;\n-  uint8_t lb;\n-  int status = read_memory (memaddr, &lb, 1, info);\n-\n-  char mnemonic[7];\n-  int x = 0;\n-  mnemonic[x++] = (lb & 0x80) ? 'd' : 't';\n-  mnemonic[x++] = 'b';\n-  stpcpy (mnemonic + x, lb_condition [(lb & 0x70) >> 4]);\n-  x += 2;\n-\n-  const char *reg_dxy  = NULL;\n-  enum LP_MODE mode = -1;\n-  size_t i;\n-  for (i = 0; i < sizeof (lp_mode) / sizeof (lp_mode[0]); ++i)\n-    {\n-      const struct lp *pb = lp_mode + i;\n-      if ((lb & pb->mask) == pb->value)\n-\t{\n-\t  mode = pb->mode;\n-\t  break;\n-\t}\n-    }\n-\n-  switch (mode)\n-    {\n-    case LP_REG:\n-      reg_dxy = registers [lb & 0x07].name;\n-      break;\n-    case LP_XY:\n-      reg_dxy = (lb & 0x1) ? \"y\" : \"x\";\n-      break;\n-    case LP_OPR:\n-      mnemonic[x++] = '.';\n-      mnemonic[x++] = shift_size_table [lb & 0x03];\n-      offs += opr_n_bytes (memaddr + 1, info);\n-      break;\n-    }\n-\n-  mnemonic[x++] = '\\0';\n-\n-  (*info->fprintf_func) (info->stream, \"%s\", mnemonic);\n-\n-  if (mode == LP_OPR)\n-    opr_decode (memaddr + 1, info);\n-  else\n-    {\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", reg_dxy);\n-    }\n-\n-  rel_15_7 (memaddr + offs, info, offs + 1);\n-\n-  return status;\n-}\n-\n-\n-static int\n-print_insn_shift (bfd_vma memaddr, struct disassemble_info* info, uint8_t byte)\n-{\n-  size_t i;\n-  uint8_t sb;\n-  int status = read_memory (memaddr, &sb, 1, info);\n-  if (status < 0)\n-    return status;\n-\n-  enum SB_DIR  dir = (sb & 0x40) ? SB_LEFT : SB_RIGHT;\n-  enum SB_TYPE type = (sb & 0x80) ? SB_ARITHMETIC : SB_LOGICAL;\n-  enum SB_MODE mode = -1;\n-  for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n-    {\n-      const struct sb *sbe = sb_table + i;\n-      if ((sb & sbe->mask) == sbe->value)\n-\tmode = sbe->mode;\n-    }\n-\n-  char mnemonic[6];\n-  int x = 0;\n-  if (mode == SB_ROT)\n-    {\n-      mnemonic[x++] = 'r';\n-      mnemonic[x++] = 'o';\n-    }\n-  else\n-    {\n-      mnemonic[x++] = (type == SB_LOGICAL) ? 'l' : 'a';\n-      mnemonic[x++] = 's';\n-    }\n-\n-  mnemonic[x++] = (dir == SB_LEFT) ? 'l' : 'r';\n-\n-  switch (mode)\n-    {\n-    case SB_REG_OPR_EFF:\n-    case SB_ROT:\n-    case SB_REG_OPR_OPR:\n-      mnemonic[x++] = '.';\n-      mnemonic[x++] = shift_size_table[sb & 0x03];\n-      break;\n-    case SB_OPR_N:\n-      {\n-\tuint8_t xb;\n-\tread_memory (memaddr + 1, &xb, 1, info);\n-\t/* The size suffix is not printed if the OPR operand refers\n-\t   directly to a register, because the size is implied by the\n-\t   size of that register. */\n-\tif ((xb & 0xF8) != 0xB8)\n-\t  {\n-\t    mnemonic[x++] = '.';\n-\t    mnemonic[x++] = shift_size_table[sb & 0x03];\n-\t  }\n-      }\n-      break;\n-    default:\n-      break;\n-    };\n-\n-  mnemonic[x++] = '\\0';\n-\n-  (*info->fprintf_func) (info->stream, \"%s\", mnemonic);\n-\n-  /* Destination register */\n-  switch (mode)\n-    {\n-    case SB_REG_REG_N_EFF:\n-    case SB_REG_REG_N:\n-    case SB_REG_OPR_EFF:\n-    case SB_REG_OPR_OPR:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[byte & 0x7].name);\n-      break;\n-\n-    case SB_ROT:\n-      opr_decode (memaddr + 1, info);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* Source register */\n-  switch (mode)\n-    {\n-    case SB_REG_REG_N_EFF:\n-    case SB_REG_REG_N:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"%s\", registers[sb & 0x7].name);\n-      break;\n-\n-    case SB_REG_OPR_OPR:\n-      opr_decode (memaddr + 1, info);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  /* 3rd arg */\n-  switch (mode)\n-    {\n-    case SB_REG_OPR_EFF:\n-    case SB_OPR_N:\n-      opr_decode (memaddr + 1, info);\n-      break;\n-\n-    case SB_REG_REG_N:\n-      {\n-        uint8_t xb;\n-        read_memory (memaddr + 1, &xb, 1, info);\n-        /* This case is slightly unusual.\n-           If XB matches the binary pattern 0111XXXX, then instead of\n-           interpreting this as a general OPR postbyte in the IMMe4 mode,\n-           the XB byte is interpreted in s special way.  */\n-        if ((xb & 0xF0) == 0x70)\n-          {\n-            operand_separator (info);\n-            if (byte & 0x10)\n-              {\n-                int shift = ((sb & 0x08) >> 3) | ((xb & 0x0f) << 1);\n-                (*info->fprintf_func) (info->stream, \"#%d\", shift);\n-              }\n-            else\n-              {\n-                (*info->fprintf_func) (info->stream, \"%s:%d\", __FILE__, __LINE__);\n-              }\n-          }\n-        else\n-          {\n-            opr_decode (memaddr + 1, info);\n-          }\n-      }\n-      break;\n-    case SB_REG_OPR_OPR:\n-      {\n-      uint8_t xb;\n-      int n = opr_n_bytes (memaddr + 1, info);\n-      read_memory (memaddr + 1 + n, &xb, 1, info);\n-\n-      if ((xb & 0xF0) == 0x70)\n-\t{\n-\t  int imm = xb & 0x0F;\n-\t  imm <<= 1;\n-\t  imm |= (sb & 0x08) >> 3;\n-\t  operand_separator (info);\n-\t  (*info->fprintf_func) (info->stream, \"#%d\", imm);\n-\t}\n-      else\n-\t{\n-\t  opr_decode (memaddr + 1 + n, info);\n-\t}\n-      }\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  switch (mode)\n-    {\n-    case SB_REG_REG_N_EFF:\n-    case SB_REG_OPR_EFF:\n-    case SB_OPR_N:\n-      operand_separator (info);\n-      (*info->fprintf_func) (info->stream, \"#%d\",\n-\t\t\t     (sb & 0x08) ? 2 : 1);\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-print_insn_s12z (bfd_vma memaddr, struct disassemble_info* info)\n-{\n-  bfd_byte byte;\n-  int status = read_memory (memaddr++, &byte, 1, info);\n-  if (status != 0)\n-    return status;\n-\n-  const struct opcode *opc2 = NULL;\n-  const struct opcode *opc = page1 + byte;\n-  if (opc->mnemonic)\n-    {\n-      (*info->fprintf_func) (info->stream, \"%s\", opc->mnemonic);\n-    }\n-  else\n-    {\n-      /* The special cases ... */\n-      switch (byte)\n-\t{\n-\tcase PAGE2_PREBYTE:\n-\t  {\n-\t    bfd_byte byte2;\n-\t    read_memory (memaddr++, &byte2, 1, info);\n-\t    opc2 = page2 + byte2;\n-\t    if (opc2->mnemonic)\n-\t      {\n-\t\t(*info->fprintf_func) (info->stream, \"%s\", opc2->mnemonic);\n-\n-\t\tif (opc2->operands)\n-\t\t  {\n-\t\t    opc2->operands (memaddr, info);\n-\t\t  }\n-\n-\t\tif (opc2->operands2)\n-\t\t  {\n-\t\t    opc2->operands2 (memaddr, info);\n-\t\t  }\n-\t      }\n-\t    else if (byte2 >= 0x08 && byte2 <= 0x1F)\n-\t      {\n-\t\tbfd_byte bb;\n-\t\tread_memory (memaddr, &bb, 1, info);\n-\t\tif (bb & 0x80)\n-\t\t  (*info->fprintf_func) (info->stream, \"bfins\");\n-\t\telse\n-\t\t  (*info->fprintf_func) (info->stream, \"bfext\");\n-\n-\t\tenum BB_MODE mode = -1;\n-\t\tsize_t i;\n-\t\tconst struct opr_bb *bbs = 0;\n-\t\tfor (i = 0; i < sizeof (bb_modes) / sizeof (bb_modes[0]); ++i)\n-\t\t  {\n-\t\t    bbs = bb_modes + i;\n-\t\t    if ((bb & bbs->mask) == bbs->value)\n-\t\t      {\n-\t\t\tmode = bbs->mode;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t  }\n-\n-\t\tswitch (mode)\n-\t\t  {\n-\t\t  case BB_REG_OPR_REG:\n-\t\t  case BB_REG_OPR_IMM:\n-\t\t  case BB_OPR_REG_REG:\n-\t\t  case BB_OPR_REG_IMM:\n-\t\t    {\n-\t\t      int size = (bb >> 2) & 0x03;\n-\t\t      (*info->fprintf_func) (info->stream, \".%c\",\n-\t\t\t\t\t     shift_size_table [size]);\n-\t\t    }\n-\t\t    break;\n-\t\t  default:\n-\t\t    break;\n-\t\t  }\n-\n-\t\tint reg1 = byte2 & 0x07;\n-\t\t/* First operand */\n-\t\tswitch (mode)\n-\t\t  {\n-\t\t  case BB_REG_REG_REG:\n-\t\t  case BB_REG_REG_IMM:\n-\t\t  case BB_REG_OPR_REG:\n-\t\t  case BB_REG_OPR_IMM:\n-\t\t    operand_separator (info);\n-\t\t    (*info->fprintf_func) (info->stream, \"%s\",\n-\t\t\t\t\t   registers[reg1].name);\n-\t\t    break;\n-\t\t  case BB_OPR_REG_REG:\n-\t\t    opr_decode (memaddr + 1, info);\n-\t\t    break;\n-\t\t  case BB_OPR_REG_IMM:\n-\t\t    opr_decode (memaddr + 2, info);\n-\t\t    break;\n-\t\t  }\n-\n-\t\t/* Second operand */\n-\t\tswitch (mode)\n-\t\t  {\n-\t\t  case BB_REG_REG_REG:\n-\t\t  case BB_REG_REG_IMM:\n-\t\t    {\n-\t\t      int reg_src = (bb >> 2) & 0x07;\n-\t\t      operand_separator (info);\n-\t\t      (*info->fprintf_func) (info->stream, \"%s\",\n-\t\t\t\t\t     registers[reg_src].name);\n-\t\t    }\n-\t\t    break;\n-\t\t  case BB_OPR_REG_REG:\n-\t\t  case BB_OPR_REG_IMM:\n-\t\t    {\n-\t\t      int reg_src = (byte2 & 0x07);\n-\t\t      operand_separator (info);\n-\t\t      (*info->fprintf_func) (info->stream, \"%s\",\n-\t\t\t\t\t     registers[reg_src].name);\n-\t\t    }\n-\t\t    break;\n-\t\t  case BB_REG_OPR_REG:\n-\t\t    opr_decode (memaddr + 1, info);\n-\t\t    break;\n-\t\t  case BB_REG_OPR_IMM:\n-\t\t    opr_decode (memaddr + 2, info);\n-\t\t    break;\n-\t\t  }\n-\n-\t\t/* Third operand */\n-\t\toperand_separator (info);\n-\t\tswitch (mode)\n-\t\t  {\n-\t\t  case BB_REG_REG_REG:\n-\t\t  case BB_OPR_REG_REG:\n-\t\t  case BB_REG_OPR_REG:\n-\t\t    {\n-\t\t      int reg_parm = bb & 0x03;\n-\t\t      (*info->fprintf_func) (info->stream, \"%s\",\n-\t\t\t\t\t     registers[reg_parm].name);\n-\t\t    }\n-\t\t    break;\n-\t\t  case BB_REG_REG_IMM:\n-\t\t  case BB_OPR_REG_IMM:\n-\t\t  case BB_REG_OPR_IMM:\n-\t\t    {\n-\t\t      bfd_byte i1;\n-\t\t      read_memory (memaddr + 1, &i1, 1, info);\n-\t\t      int offset = i1 & 0x1f;\n-\t\t      int width = bb & 0x03;\n-\t\t      width <<= 3;\n-\t\t      width |= i1 >> 5;\n-\t\t      (*info->fprintf_func) (info->stream, \"#%d:%d\", width,  offset);\n-\t\t    }\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t  }\n-\t  break;\n-\tcase 0xae: /* EXG / SEX */\n-\t  status = print_insn_exg_sex (memaddr, info);\n-\t  break;\n-\tcase 0x0b:  /* Loop Primitives TBcc and DBcc */\n-\t  status = print_insn_loop_primitive (memaddr, info);\n-\t  break;\n-\tcase 0x10:  \t    /* shift */\n-\tcase 0x11:  \t    /* shift */\n-\tcase 0x12:  \t    /* shift */\n-\tcase 0x13:  \t    /* shift */\n-\tcase 0x14:  \t    /* shift */\n-\tcase 0x15:  \t    /* shift */\n-\tcase 0x16:  \t    /* shift */\n-\tcase 0x17:  \t    /* shift */\n-\t  status = print_insn_shift (memaddr, info, byte);\n-\t  break;\n-\tcase 0x04:  \t    /* psh / pul */\n-\t  {\n-\t    read_memory (memaddr, &byte, 1, info);\n-\t    (*info->fprintf_func) (info->stream, (byte & 0x80) ? \"pul\" : \"psh\");\n-\t    int bit;\n-\t    if (byte & 0x40)\n-\t      {\n-\t\tif ((byte & 0x3F) == 0)\n-\t\t  {\n-\t\t    operand_separator (info);\n-\t\t    (*info->fprintf_func) (info->stream, \"%s\", \"ALL16b\");\n-\t\t  }\n-\t\telse\n-\t\t  for (bit = 5; bit >= 0; --bit)\n-\t\t    {\n-\t\t      if (byte & (0x1 << bit))\n-\t\t\t{\n-\t\t\t  operand_separator (info);\n-\t\t\t  (*info->fprintf_func) (info->stream, \"%s\", oprregs2[bit]);\n-\t\t\t}\n-\t\t    }\n-\t      }\n-\t    else\n-\t      {\n-\t\tif ((byte & 0x3F) == 0)\n-\t\t  {\n-\t\t    operand_separator (info);\n-\t\t    (*info->fprintf_func) (info->stream, \"%s\", \"ALL\");\n-\t\t  }\n-\t\telse\n-\t\t  for (bit = 5; bit >= 0; --bit)\n-\t\t    {\n-\t\t      if (byte & (0x1 << bit))\n-\t\t\t{\n-\t\t\t  operand_separator (info);\n-\t\t\t  (*info->fprintf_func) (info->stream, \"%s\", oprregs1[bit]);\n-\t\t\t}\n-\t\t    }\n-\t      }\n-\t  }\n-\t  break;\n-\tdefault:\n-\t  operand_separator (info);\n-\t  (*info->fprintf_func) (info->stream, \"???\");\n-\t  break;\n-\t}\n-    }\n-\n-  if (opc2 == NULL)\n+  /* Ship out the operands.  */\n+  for (o = 0; o < n_operands; ++o)\n     {\n-      if (opc->operands)\n-\t{\n-\t  opc->operands (memaddr, info);\n-\t}\n-\n-      if (opc->operands2)\n-\t{\n-\t  opc->operands2 (memaddr, info);\n-\t}\n+      if (operands[o])\n+\topr_emit_disassembly (operands[o], mra.info);\n+      free (operands[o]);\n     }\n \n-  int n = 0;\n-\n-  /* Opcodes in page2 have an additional byte */\n-  if (opc2)\n-    n++;\n-\n-  if (opc2 && opc2->insn_bytes == 0)\n-    return n;\n-\n-  if (!opc2 && opc->insn_bytes == 0)\n-    return n;\n-\n-  if (opc2)\n-    n += opc2->insn_bytes (memaddr, info);\n-  else\n-    n += opc->insn_bytes (memaddr, info);\n-\n-  return n;\n+  return n_bytes;\n }"
    },
    {
      "sha": "36509b58dcd8bb52278d3d5755c6ef47c41c79ec",
      "filename": "opcodes/s12z-opc.c",
      "status": "added",
      "additions": 2701,
      "deletions": 0,
      "changes": 2701,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/s12z-opc.c?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -0,0 +1,2701 @@\n+/* s12z-decode.c -- Freescale S12Z disassembly\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU opcodes library.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n+   MA 02110-1301, USA.  */\n+\n+#include \"sysdep.h\"\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <stdbool.h>\n+#include <assert.h>\n+\n+#include \"opcode/s12z.h\"\n+\n+#include \"bfd.h\"\n+\n+#include \"s12z-opc.h\"\n+\n+\n+typedef int (* insn_bytes_f) (struct mem_read_abstraction_base *);\n+\n+typedef void (*operands_f) (struct mem_read_abstraction_base *,\n+\t\t\t    int *n_operands, struct operand **operand);\n+\n+typedef enum operator (*discriminator_f) (struct mem_read_abstraction_base *,\n+\t\t\t\t\t  enum operator hint);\n+\n+enum OPR_MODE\n+  {\n+    OPR_IMMe4,\n+    OPR_REG,\n+    OPR_OFXYS,\n+    OPR_XY_PRE_INC,\n+    OPR_XY_POST_INC,\n+    OPR_XY_PRE_DEC,\n+    OPR_XY_POST_DEC,\n+    OPR_S_PRE_DEC,\n+    OPR_S_POST_INC,\n+    OPR_REG_DIRECT,\n+    OPR_REG_INDIRECT,\n+    OPR_IDX_DIRECT,\n+    OPR_IDX_INDIRECT,\n+    OPR_EXT1,\n+    OPR_IDX2_REG,\n+    OPR_IDX3_DIRECT,\n+    OPR_IDX3_INDIRECT,\n+\n+    OPR_EXT18,\n+    OPR_IDX3_DIRECT_REG,\n+    OPR_EXT3_DIRECT,\n+    OPR_EXT3_INDIRECT\n+  };\n+\n+struct opr_pb\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  int n_operands;\n+  enum OPR_MODE mode;\n+};\n+\n+static const  struct opr_pb opr_pb[] = {\n+  {0xF0, 0x70, 1, OPR_IMMe4},\n+  {0xF8, 0xB8, 1, OPR_REG},\n+  {0xC0, 0x40, 1, OPR_OFXYS},\n+  {0xEF, 0xE3, 1, OPR_XY_PRE_INC},\n+  {0xEF, 0xE7, 1, OPR_XY_POST_INC},\n+  {0xEF, 0xC3, 1, OPR_XY_PRE_DEC},\n+  {0xEF, 0xC7, 1, OPR_XY_POST_DEC},\n+  {0xFF, 0xFB, 1, OPR_S_PRE_DEC},\n+  {0xFF, 0xFF, 1, OPR_S_POST_INC},\n+  {0xC8, 0x88, 1, OPR_REG_DIRECT},\n+  {0xE8, 0xC8, 1, OPR_REG_INDIRECT},\n+\n+  {0xCE, 0xC0, 2, OPR_IDX_DIRECT},\n+  {0xCE, 0xC4, 2, OPR_IDX_INDIRECT},\n+  {0xC0, 0x00, 2, OPR_EXT1},\n+\n+  {0xC8, 0x80, 3, OPR_IDX2_REG},\n+  {0xFA, 0xF8, 3, OPR_EXT18},\n+\n+  {0xCF, 0xC2, 4, OPR_IDX3_DIRECT},\n+  {0xCF, 0xC6, 4, OPR_IDX3_INDIRECT},\n+\n+  {0xF8, 0xE8, 4, OPR_IDX3_DIRECT_REG},\n+  {0xFF, 0xFA, 4, OPR_EXT3_DIRECT},\n+  {0xFF, 0xFE, 4, OPR_EXT3_INDIRECT},\n+};\n+\n+/* Return the number of bytes in a OPR operand, including the XB postbyte.\n+   It does not include any preceeding opcodes. */\n+static int\n+x_opr_n_bytes (struct mem_read_abstraction_base *mra, int offset)\n+{\n+  bfd_byte xb;\n+  int status = mra->read (mra, offset, 1, &xb);\n+  if (status < 0)\n+    return status;\n+\n+  size_t i;\n+  for (i = 0; i < sizeof (opr_pb) / sizeof (opr_pb[0]); ++i)\n+    {\n+      const struct opr_pb *pb = opr_pb + i;\n+      if ((xb & pb->mask) == pb->value)\n+\t{\n+\t  return pb->n_operands;\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n+static int\n+opr_n_bytes_p1 (struct mem_read_abstraction_base *mra)\n+{\n+  return 1 + x_opr_n_bytes (mra, 0);\n+}\n+\n+static int\n+opr_n_bytes2 (struct mem_read_abstraction_base *mra)\n+{\n+  int s = x_opr_n_bytes (mra, 0);\n+  s += x_opr_n_bytes (mra, s);\n+  return s + 1;\n+}\n+\n+enum BB_MODE\n+  {\n+    BB_REG_REG_REG,\n+    BB_REG_REG_IMM,\n+    BB_REG_OPR_REG,\n+    BB_OPR_REG_REG,\n+    BB_REG_OPR_IMM,\n+    BB_OPR_REG_IMM\n+  };\n+\n+struct opr_bb\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  int n_operands;\n+  bool opr;\n+  enum BB_MODE mode;\n+};\n+\n+static const struct opr_bb bb_modes[] =\n+  {\n+    {0x60, 0x00, 2, false, BB_REG_REG_REG},\n+    {0x60, 0x20, 3, false, BB_REG_REG_IMM},\n+    {0x70, 0x40, 2, true,  BB_REG_OPR_REG},\n+    {0x70, 0x50, 2, true,  BB_OPR_REG_REG},\n+    {0x70, 0x60, 3, true,  BB_REG_OPR_IMM},\n+    {0x70, 0x70, 3, true,  BB_OPR_REG_IMM}\n+  };\n+\n+static int\n+bfextins_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  bfd_byte bb;\n+  int status = mra->read (mra, 0, 1, &bb);\n+  if (status < 0)\n+    return status;\n+\n+  size_t i;\n+  const struct opr_bb *bbs = 0;\n+  for (i = 0; i < sizeof (bb_modes) / sizeof (bb_modes[0]); ++i)\n+    {\n+      bbs = bb_modes + i;\n+      if ((bb & bbs->mask) == bbs->value)\n+\t{\n+\t  break;\n+\t}\n+    }\n+\n+  int n = bbs->n_operands;\n+  if (bbs->opr)\n+    n += x_opr_n_bytes (mra, n - 1);\n+\n+  return n;\n+}\n+\n+static int\n+single (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED)\n+{\n+  return 1;\n+}\n+\n+static int\n+two (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED)\n+{\n+  return 2;\n+}\n+\n+static int\n+three (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED)\n+{\n+  return 3;\n+}\n+\n+static int\n+four (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED)\n+{\n+  return 4;\n+}\n+\n+static int\n+five (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED)\n+{\n+  return 5;\n+}\n+\n+static int\n+pcrel_15bit (struct mem_read_abstraction_base *mra)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, 0, 1, &byte);\n+  if (status < 0)\n+    return status;\n+  return (byte & 0x80) ? 3 : 2;\n+}\n+\n+\n+\f\n+static int\n+xysp_reg_from_postbyte (uint8_t postbyte)\n+{\n+  int reg = -1;\n+  switch ((postbyte & 0x30) >> 4)\n+    {\n+    case 0:\n+      reg = REG_X;\n+      break;\n+    case 1:\n+      reg = REG_Y;\n+      break;\n+    case 2:\n+      reg = REG_S;\n+      break;\n+    default:\n+      reg = REG_P;\n+    }\n+  return reg;\n+}\n+\n+static struct operand * create_immediate_operand (int value)\n+{\n+  struct immediate_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_IMMEDIATE;\n+  op->value = value;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand * create_bitfield_operand (int width, int offset)\n+{\n+  struct bitfield_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_BIT_FIELD;\n+  op->width = width;\n+  op->offset = offset;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand *\n+create_register_operand_with_size (int reg, short osize)\n+{\n+  struct register_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_REGISTER;\n+  op->reg = reg;\n+  ((struct operand *)op)->osize = osize;\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand *\n+create_register_operand (int reg)\n+{\n+  return create_register_operand_with_size (reg, -1);\n+}\n+\n+static struct operand * create_register_all_operand (void)\n+{\n+  struct register_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_REGISTER_ALL;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand * create_register_all16_operand (void)\n+{\n+  struct register_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_REGISTER_ALL16;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+\n+static struct operand *\n+create_simple_memory_operand (bfd_vma addr, bfd_vma base, bool relative)\n+{\n+  struct simple_memory_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_SIMPLE_MEMORY;\n+  op->addr = addr;\n+  op->base = base;\n+  op->relative = relative;\n+  ((struct operand *)op)->osize = -1;\n+\n+  assert (relative || base == 0);\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand *\n+create_memory_operand (bool indirect, int base, int n_regs, int reg0, int reg1)\n+{\n+  struct memory_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_MEMORY;\n+  op->indirect = indirect;\n+  op->base_offset = base;\n+  op->mutation = OPND_RM_NONE;\n+  op->n_regs = n_regs;\n+  op->regs[0] = reg0;\n+  op->regs[1] = reg1;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+static struct operand *\n+create_memory_auto_operand (enum op_reg_mutation mutation, int reg)\n+{\n+  struct memory_operand *op = malloc (sizeof (*op));\n+\n+  ((struct operand *)op)->cl = OPND_CL_MEMORY;\n+  op->indirect = false;\n+  op->base_offset = 0;\n+  op->mutation = mutation;\n+  op->n_regs = 1;\n+  op->regs[0] = reg;\n+  op->regs[1] = -1;\n+  ((struct operand *)op)->osize = -1;\n+\n+  return (struct operand *) op;\n+}\n+\n+\f\n+\n+static void\n+z_ext24_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand)\n+{\n+  uint8_t buffer[3];\n+  int status = mra->read (mra, 0, 3, buffer);\n+  if (status < 0)\n+    return;\n+\n+  int i;\n+  uint32_t addr = 0;\n+  for (i = 0; i < 3; ++i)\n+    {\n+      addr <<= 8;\n+      addr |= buffer[i];\n+    }\n+\n+  operand[(*n_operands)++] = create_simple_memory_operand (addr, 0, false);\n+}\n+\n+\n+static uint32_t\n+z_decode_signed_value (struct mem_read_abstraction_base *mra, int offset, short size)\n+{\n+  assert (size >0);\n+  assert (size <= 4);\n+  bfd_byte buffer[4];\n+  if (0 > mra->read (mra, offset, size, buffer))\n+    {\n+      return 0;\n+    }\n+\n+  int i;\n+  uint32_t value = 0;\n+  for (i = 0; i < size; ++i)\n+    {\n+      value |= buffer[i] << (8 * (size - i - 1));\n+    }\n+\n+  if (buffer[0] & 0x80)\n+    {\n+      /* Deal with negative values */\n+      value -= 0x1UL << (size * 8);\n+    }\n+  return value;\n+}\n+\n+static uint32_t\n+decode_signed_value (struct mem_read_abstraction_base *mra, short size)\n+{\n+  return z_decode_signed_value (mra, 0, size);\n+}\n+\n+static void\n+x_imm1 (struct mem_read_abstraction_base *mra,\n+\tint offset,\n+\tint *n_operands, struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, offset, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  operand[(*n_operands)++] = create_immediate_operand (byte);\n+}\n+\n+/* An eight bit immediate operand.  */\n+static void\n+imm1_decode (struct mem_read_abstraction_base *mra,\n+\tint *n_operands, struct operand **operand)\n+{\n+  x_imm1 (mra, 0, n_operands, operand);\n+}\n+\n+static void\n+trap_decode (struct mem_read_abstraction_base *mra,\n+\t     int *n_operands, struct operand **operand)\n+{\n+  x_imm1 (mra, -1, n_operands, operand);\n+}\n+\n+\n+static struct operand *\n+x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n+\t\t\tshort osize)\n+{\n+  bfd_byte postbyte;\n+  int status = mra->read (mra, offset, 1, &postbyte);\n+  if (status < 0)\n+    return NULL;\n+  offset++;\n+\n+  enum OPR_MODE mode = -1;\n+  size_t i;\n+  for (i = 0; i < sizeof (opr_pb) / sizeof (opr_pb[0]); ++i)\n+    {\n+      const struct opr_pb *pb = opr_pb + i;\n+      if ((postbyte & pb->mask) == pb->value)\n+\t{\n+\t  mode = pb->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  struct operand *operand = NULL;\n+  switch (mode)\n+    {\n+    case OPR_IMMe4:\n+      {\n+\tint n;\n+\tuint8_t x = (postbyte & 0x0F);\n+\tif (x == 0)\n+\t  n = -1;\n+\telse\n+\t  n = x;\n+\n+        operand = create_immediate_operand (n);\n+\tbreak;\n+      }\n+    case OPR_REG:\n+      {\n+\tuint8_t x = (postbyte & 0x07);\n+        operand = create_register_operand (x);\n+\tbreak;\n+      }\n+    case OPR_OFXYS:\n+      {\n+        operand = create_memory_operand (false, postbyte & 0x0F, 1,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte), -1);\n+\tbreak;\n+      }\n+    case OPR_REG_DIRECT:\n+      {\n+        operand = create_memory_operand (false, 0, 2, postbyte & 0x07,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte));\n+\tbreak;\n+      }\n+    case OPR_REG_INDIRECT:\n+      {\n+        operand = create_memory_operand (true, 0, 2, postbyte & 0x07,\n+\t\t\t\t\t (postbyte & 0x10) ? REG_Y : REG_X);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX_INDIRECT:\n+      {\n+\tuint8_t x1;\n+\tmra->read (mra, offset, 1, &x1);\n+\tint idx = x1;\n+\n+\tif (postbyte & 0x01)\n+\t  {\n+\t    /* Deal with negative values */\n+\t    idx -= 0x1UL << 8;\n+\t  }\n+\n+        operand = create_memory_operand (true, idx, 1,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte), -1);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX3_DIRECT:\n+      {\n+\tuint8_t x[3];\n+\tmra->read (mra, offset, 3, x);\n+\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n+\n+\tif (x[0] & 0x80)\n+\t  {\n+\t    /* Deal with negative values */\n+\t    idx -= 0x1UL << 24;\n+\t  }\n+\n+        operand = create_memory_operand (false, idx, 1,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte), -1);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX3_DIRECT_REG:\n+      {\n+\tuint8_t x[3];\n+\tmra->read (mra, offset, 3, x);\n+\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n+\n+\tif (x[0] & 0x80)\n+\t  {\n+\t    /* Deal with negative values */\n+\t    idx -= 0x1UL << 24;\n+\t  }\n+\n+        operand = create_memory_operand (false, idx, 1, postbyte & 0x07, -1);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX3_INDIRECT:\n+      {\n+\tuint8_t x[3];\n+\tmra->read (mra, offset, 3, x);\n+\tint idx = x[0] << 16 | x[1] << 8 | x[2];\n+\n+\tif (x[0] & 0x80)\n+\t  {\n+\t    /* Deal with negative values */\n+\t    idx -= 0x1UL << 24;\n+\t  }\n+\n+\toperand = create_memory_operand (true, idx, 1,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte), -1);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX_DIRECT:\n+      {\n+\tuint8_t x1;\n+\tmra->read (mra, offset, 1, &x1);\n+\tint idx = x1;\n+\n+\tif (postbyte & 0x01)\n+\t  {\n+\t    /* Deal with negative values */\n+\t    idx -= 0x1UL << 8;\n+\t  }\n+\n+        operand = create_memory_operand (false, idx, 1,\n+\t\t\t\t\t xysp_reg_from_postbyte (postbyte), -1);\n+\tbreak;\n+      }\n+\n+    case OPR_IDX2_REG:\n+      {\n+\tuint8_t x[2];\n+\tmra->read (mra, offset, 2, x);\n+\tuint32_t idx = x[1] | x[0] << 8 ;\n+\tidx |= (postbyte & 0x30) << 12;\n+\n+        operand = create_memory_operand (false, idx, 1, postbyte & 0x07, -1);\n+\tbreak;\n+      }\n+\n+    case OPR_XY_PRE_INC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_PRE_INC,\n+\t\t\t\t\t      (postbyte & 0x10) ? REG_Y: REG_X);\n+\tbreak;\n+      }\n+    case OPR_XY_POST_INC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_POST_INC,\n+\t\t\t\t\t      (postbyte & 0x10) ? REG_Y: REG_X);\n+\tbreak;\n+      }\n+    case OPR_XY_PRE_DEC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_PRE_DEC,\n+\t\t\t\t\t      (postbyte & 0x10) ? REG_Y: REG_X);\n+\tbreak;\n+      }\n+    case OPR_XY_POST_DEC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_POST_DEC,\n+\t\t\t\t\t      (postbyte & 0x10) ? REG_Y: REG_X);\n+\tbreak;\n+      }\n+    case OPR_S_PRE_DEC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_PRE_DEC, REG_S);\n+\tbreak;\n+      }\n+    case OPR_S_POST_INC:\n+      {\n+\toperand = create_memory_auto_operand (OPND_RM_POST_INC, REG_S);\n+\tbreak;\n+      }\n+\n+    case OPR_EXT18:\n+      {\n+\tconst size_t size = 2;\n+\tbfd_byte buffer[4];\n+\tstatus = mra->read (mra, offset, size, buffer);\n+\tif (status < 0)\n+\t  operand = NULL;\n+\n+\tuint32_t ext18 = 0;\n+\tfor (i = 0; i < size; ++i)\n+\t  {\n+\t    ext18 <<= 8;\n+\t    ext18 |= buffer[i];\n+\t  }\n+\n+\text18 |= (postbyte & 0x01) << 16;\n+\text18 |= (postbyte & 0x04) << 15;\n+\n+\toperand = create_simple_memory_operand (ext18, 0, false);\n+\tbreak;\n+      }\n+\n+    case OPR_EXT1:\n+      {\n+\tuint8_t x1 = 0;\n+\tmra->read (mra, offset, 1, &x1);\n+\tint16_t addr;\n+\taddr = x1;\n+\taddr |= (postbyte & 0x3f) << 8;\n+\n+\toperand = create_simple_memory_operand (addr, 0, false);\n+\tbreak;\n+      }\n+\n+    case OPR_EXT3_DIRECT:\n+      {\n+\tconst size_t size = 3;\n+\tbfd_byte buffer[4];\n+\tstatus = mra->read (mra, offset, size, buffer);\n+\tif (status < 0)\n+\t  operand = NULL;\n+\n+\tuint32_t ext24 = 0;\n+\tfor (i = 0; i < size; ++i)\n+\t  {\n+\t    ext24 |= buffer[i] << (8 * (size - i - 1));\n+\t  }\n+\n+\toperand = create_simple_memory_operand (ext24, 0, false);\n+\tbreak;\n+      }\n+\n+    case OPR_EXT3_INDIRECT:\n+      {\n+\tconst size_t size = 3;\n+\tbfd_byte buffer[4];\n+\tstatus = mra->read (mra, offset, size, buffer);\n+\tif (status < 0)\n+\t  operand = NULL;\n+\n+\tuint32_t ext24 = 0;\n+\tfor (i = 0; i < size; ++i)\n+\t  {\n+\t    ext24 |= buffer[i] << (8 * (size - i - 1));\n+\t  }\n+\n+        operand = create_memory_operand (true, ext24, 0, -1, -1);\n+\tbreak;\n+      }\n+\n+    default:\n+      printf (\"Unknown OPR mode #0x%x (%d)\", postbyte, mode);\n+      abort ();\n+    }\n+\n+  operand->osize = osize;\n+\n+  return operand;\n+}\n+\n+static struct operand *\n+x_opr_decode (struct mem_read_abstraction_base *mra, int offset)\n+{\n+  return x_opr_decode_with_size (mra, offset, -1);\n+}\n+\n+static void\n+z_opr_decode (struct mem_read_abstraction_base *mra,\n+\t      int *n_operands, struct operand **operand)\n+{\n+  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+}\n+\n+static void\n+z_opr_decode2 (struct mem_read_abstraction_base *mra,\n+\t       int *n_operands, struct operand **operand)\n+{\n+  int n = x_opr_n_bytes (mra, 0);\n+\n+  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+  operand[(*n_operands)++] = x_opr_decode (mra, n);\n+}\n+\n+static void\n+imm1234 (struct mem_read_abstraction_base *mra, int base,\n+\t int *n_operands, struct operand **operand)\n+{\n+  bfd_byte opcode;\n+  int status = mra->read (mra, -1, 1, &opcode);\n+  if (status < 0)\n+    return;\n+\n+  opcode -= base;\n+\n+  int size = registers[opcode & 0xF].bytes;\n+\n+  uint32_t imm = decode_signed_value (mra, size);\n+\n+  operand[(*n_operands)++] = create_immediate_operand (imm);\n+}\n+\n+\n+/* Special case of LD and CMP with register S and IMM operand */\n+static void\n+reg_s_imm (struct mem_read_abstraction_base *mra, int *n_operands,\n+\t   struct operand **operand)\n+{\n+  operand[(*n_operands)++] = create_register_operand (REG_S);\n+\n+  uint32_t imm = decode_signed_value (mra, 3);\n+  operand[(*n_operands)++] = create_immediate_operand (imm);\n+}\n+\n+/* Special case of LD, CMP and ST with register S and OPR operand */\n+static void\n+reg_s_opr (struct mem_read_abstraction_base *mra, int *n_operands,\n+\t   struct operand **operand)\n+{\n+  operand[(*n_operands)++] = create_register_operand (REG_S);\n+  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+}\n+\n+static void\n+z_imm1234_8base (struct mem_read_abstraction_base *mra, int *n_operands,\n+\t\t struct operand **operand)\n+{\n+  imm1234 (mra, 8, n_operands, operand);\n+}\n+\n+static void\n+z_imm1234_0base (struct mem_read_abstraction_base *mra, int *n_operands,\n+\t\t struct operand **operand)\n+{\n+  imm1234 (mra, 0, n_operands, operand);\n+}\n+\n+\n+static void\n+z_tfr (struct mem_read_abstraction_base *mra, int *n_operands,\n+       struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, 0, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  operand[(*n_operands)++] = create_register_operand (byte >> 4);\n+  operand[(*n_operands)++] = create_register_operand (byte & 0x0F);\n+}\n+\n+static void\n+z_reg (struct mem_read_abstraction_base *mra, int *n_operands,\n+       struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  operand[(*n_operands)++] = create_register_operand (byte & 0x07);\n+}\n+\n+\n+static void\n+reg_xy (struct mem_read_abstraction_base *mra,\n+\tint *n_operands, struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  operand[(*n_operands)++] =\n+    create_register_operand ((byte & 0x01) ? REG_Y : REG_X);\n+}\n+\n+static void\n+lea_reg_xys_opr (struct mem_read_abstraction_base *mra,\n+\t\t int *n_operands, struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  int reg_xys = -1;\n+  switch (byte & 0x03)\n+    {\n+    case 0x00:\n+      reg_xys = REG_X;\n+      break;\n+    case 0x01:\n+      reg_xys = REG_Y;\n+      break;\n+    case 0x02:\n+      reg_xys = REG_S;\n+      break;\n+    }\n+\n+  operand[(*n_operands)++] = create_register_operand (reg_xys);\n+  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+}\n+\n+static void\n+lea_reg_xys (struct mem_read_abstraction_base *mra,\n+\t     int *n_operands, struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  int reg_n = -1;\n+  switch (byte & 0x03)\n+    {\n+    case 0x00:\n+      reg_n = REG_X;\n+      break;\n+    case 0x01:\n+      reg_n = REG_Y;\n+      break;\n+    case 0x02:\n+      reg_n = REG_S;\n+      break;\n+    }\n+\n+  status = mra->read (mra, 0, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  operand[(*n_operands)++] = create_register_operand (reg_n);\n+  operand[(*n_operands)++] = create_memory_operand (false, (int8_t) byte,\n+\t\t\t\t\t\t    1, reg_n, -1);\n+}\n+\n+\n+/* PC Relative offsets of size 15 or 7 bits */\n+static void\n+rel_15_7 (struct mem_read_abstraction_base *mra, int offset,\n+\t  int *n_operands, struct operand **operands)\n+{\n+  bfd_byte upper;\n+  int status = mra->read (mra, offset - 1, 1, &upper);\n+  if (status < 0)\n+    return;\n+\n+  bool rel_size = (upper & 0x80);\n+\n+  int16_t addr = upper;\n+  if (rel_size)\n+    {\n+      /* 15 bits.  Get the next byte */\n+      bfd_byte lower;\n+      status = mra->read (mra, offset, 1, &lower);\n+      if (status < 0)\n+\treturn;\n+\n+      addr <<= 8;\n+      addr |= lower;\n+      addr &= 0x7FFF;\n+\n+      bool negative = (addr & 0x4000);\n+      addr &= 0x3FFF;\n+      if (negative)\n+\taddr = addr - 0x4000;\n+    }\n+  else\n+    {\n+      /* 7 bits. */\n+      bool negative = (addr & 0x40);\n+      addr &= 0x3F;\n+      if (negative)\n+\taddr = addr - 0x40;\n+    }\n+\n+  operands[(*n_operands)++] =\n+    create_simple_memory_operand (addr, mra->posn (mra) - 1, true);\n+}\n+\n+\n+/* PC Relative offsets of size 15 or 7 bits */\n+static void\n+decode_rel_15_7 (struct mem_read_abstraction_base *mra,\n+\t\t int *n_operands, struct operand **operand)\n+{\n+  rel_15_7 (mra, 1, n_operands, operand);\n+}\n+\n+static int shift_n_bytes (struct mem_read_abstraction_base *);\n+static int mov_imm_opr_n_bytes (struct mem_read_abstraction_base *);\n+static int loop_prim_n_bytes (struct mem_read_abstraction_base *);\n+static int bm_rel_n_bytes (struct mem_read_abstraction_base *);\n+static int mul_n_bytes (struct mem_read_abstraction_base *);\n+static int bm_n_bytes (struct mem_read_abstraction_base *);\n+\n+static void psh_pul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void shift_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void mul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void bm_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void bm_rel_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void mov_imm_opr (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static void loop_primitive_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+static void bit_field_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+static void exg_sex_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+\n+\n+static enum operator shift_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+static enum operator psh_pul_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+static enum operator mul_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+static enum operator loop_primitive_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+static enum operator bit_field_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+static enum operator exg_sex_discrim (struct mem_read_abstraction_base *mra, enum operator hint);\n+\n+\n+static void\n+cmp_xy (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n+\tint *n_operands, struct operand **operand)\n+{\n+  operand[(*n_operands)++] = create_register_operand (REG_X);\n+  operand[(*n_operands)++] = create_register_operand (REG_Y);\n+}\n+\n+static void\n+sub_d6_x_y (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n+\t    int *n_operands, struct operand **operand)\n+{\n+  operand[(*n_operands)++] = create_register_operand (REG_D6);\n+  operand[(*n_operands)++] = create_register_operand (REG_X);\n+  operand[(*n_operands)++] = create_register_operand (REG_Y);\n+}\n+\n+static void\n+sub_d6_y_x (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n+\t    int *n_operands, struct operand **operand)\n+{\n+  operand[(*n_operands)++] = create_register_operand (REG_D6);\n+  operand[(*n_operands)++] = create_register_operand (REG_Y);\n+  operand[(*n_operands)++] = create_register_operand (REG_X);\n+}\n+\n+static void ld_18bit_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+\n+static enum operator\n+mul_discrim (struct mem_read_abstraction_base *mra, enum operator hint)\n+{\n+  uint8_t mb;\n+  int status = mra->read (mra, 0, 1, &mb);\n+  if (status < 0)\n+    return OP_INVALID;\n+\n+  bool signed_op = (mb & 0x80);\n+\n+  switch (hint)\n+    {\n+    case OPBASE_mul:\n+      return signed_op ? OP_muls : OP_mulu;\n+      break;\n+    case OPBASE_div:\n+      return signed_op ? OP_divs : OP_divu;\n+      break;\n+    case OPBASE_mod:\n+      return signed_op ? OP_mods : OP_modu;\n+      break;\n+    case OPBASE_mac:\n+      return signed_op ? OP_macs : OP_macu;\n+      break;\n+    case OPBASE_qmul:\n+      return signed_op ? OP_qmuls : OP_qmulu;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  return OP_INVALID;\n+}\n+\n+struct opcode\n+{\n+  /* The operation that this opcode performs.  */\n+  enum operator operator;\n+\n+  /* The size of this operation.  May be -1 if it is implied\n+     in the operands or if size is not applicable.  */\n+  short osize;\n+\n+  /* Some operations need this function to work out which operation\n+   is intended.  */\n+  discriminator_f discriminator;\n+\n+  /* A function returning the number of bytes in this instruction.  */\n+  insn_bytes_f insn_bytes;\n+\n+  operands_f operands;\n+  operands_f operands2;\n+};\n+\n+static const struct opcode page2[] =\n+  {\n+    [0x00] = {OP_ld, -1, 0,  opr_n_bytes_p1, reg_s_opr, 0},\n+    [0x01] = {OP_st, -1, 0,  opr_n_bytes_p1, reg_s_opr, 0},\n+    [0x02] = {OP_cmp, -1, 0, opr_n_bytes_p1, reg_s_opr, 0},\n+    [0x03] = {OP_ld, -1, 0,  four, reg_s_imm, 0},\n+    [0x04] = {OP_cmp, -1, 0, four, reg_s_imm, 0},\n+    [0x05] = {OP_stop, -1, 0, single, 0, 0},\n+    [0x06] = {OP_wai, -1, 0,  single, 0, 0},\n+    [0x07] = {OP_sys, -1, 0,  single, 0, 0},\n+    [0x08] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},  /* BFEXT / BFINS */\n+    [0x09] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0a] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0b] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0c] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0d] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0e] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x0f] = {0xFFFF, -1, bit_field_discrim,  bfextins_n_bytes, bit_field_decode, 0},\n+    [0x10] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x11] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x12] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x13] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x14] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x15] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x16] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x17] = {OP_minu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x18] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x19] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1a] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1b] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1c] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1d] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1e] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x1f] = {OP_maxu, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x20] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x21] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x22] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x23] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x24] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x25] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x26] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x27] = {OP_mins, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x28] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x29] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2a] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2b] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2c] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2d] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2e] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x2f] = {OP_maxs, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x30] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x31] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x32] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x33] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x34] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x35] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x36] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x37] = {OPBASE_div, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x38] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x39] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3a] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3b] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3c] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3d] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3e] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x3f] = {OPBASE_mod, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x40] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x41] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x42] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x43] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x44] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x45] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x46] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x47] = {OP_abs, -1, 0, single, z_reg, 0},\n+    [0x48] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x49] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4a] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4b] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4c] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4d] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4e] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4f] = {OPBASE_mac, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x50] = {OP_adc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x51] = {OP_adc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x52] = {OP_adc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x53] = {OP_adc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x54] = {OP_adc, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x55] = {OP_adc, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x56] = {OP_adc, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x57] = {OP_adc, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x58] = {OP_bit, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x59] = {OP_bit, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5a] = {OP_bit, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5b] = {OP_bit, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5c] = {OP_bit, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x5d] = {OP_bit, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x5e] = {OP_bit, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x5f] = {OP_bit, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x60] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x61] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x62] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x63] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x64] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x65] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x66] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x67] = {OP_adc, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x68] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x69] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6a] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6b] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6c] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6d] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6e] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6f] = {OP_bit, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x70] = {OP_sbc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x71] = {OP_sbc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x72] = {OP_sbc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x73] = {OP_sbc, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x74] = {OP_sbc, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x75] = {OP_sbc, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x76] = {OP_sbc, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x77] = {OP_sbc, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x78] = {OP_eor, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x79] = {OP_eor, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7a] = {OP_eor, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7b] = {OP_eor, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7c] = {OP_eor, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x7d] = {OP_eor, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x7e] = {OP_eor, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x7f] = {OP_eor, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x80] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x81] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x82] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x83] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x84] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x85] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x86] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x87] = {OP_sbc, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x88] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x89] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8a] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8b] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8c] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8d] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8e] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x8f] = {OP_eor, -1, 0,  opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x90] = {OP_rti, -1, 0,  single, 0, 0},\n+    [0x91] = {OP_clb, -1, 0,   two, z_tfr, 0},\n+    [0x92] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x93] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x94] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x95] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x96] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x97] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x98] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x99] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9a] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9b] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9c] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9d] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9e] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0x9f] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xa0] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa1] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa2] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa3] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa4] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa5] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa6] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa7] = {OP_sat, -1, 0, single, z_reg, 0},\n+    [0xa8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xa9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xaa] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xab] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xac] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xad] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xae] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xaf] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xb0] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb1] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb2] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb3] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb4] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb5] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb6] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb7] = {OPBASE_qmul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0xb8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xb9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xba] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xbb] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xbc] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xbd] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xbe] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xbf] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc0] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc1] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc2] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc3] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc4] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc5] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc6] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc7] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xc9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xca] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xcb] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xcc] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xcd] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xce] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xcf] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd0] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd1] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd2] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd3] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd4] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd5] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd6] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd7] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xd9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xda] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xdb] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xdc] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xdd] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xde] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xdf] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe0] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe1] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe2] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe3] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe4] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe5] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe6] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe7] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xe9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xea] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xeb] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xec] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xed] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xee] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xef] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf0] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf1] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf2] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf3] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf4] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf5] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf6] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf7] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf8] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xf9] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xfa] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xfb] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xfc] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xfd] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xfe] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+    [0xff] = {OP_trap, -1, 0,  single, trap_decode, 0},\n+  };\n+\n+static const struct opcode page1[] =\n+  {\n+    [0x00] = {OP_bgnd, -1, 0, single, 0, 0},\n+    [0x01] = {OP_nop, -1, 0,  single, 0, 0},\n+    [0x02] = {OP_brclr, -1, 0, bm_rel_n_bytes, bm_rel_decode, 0},\n+    [0x03] = {OP_brset, -1, 0, bm_rel_n_bytes, bm_rel_decode, 0},\n+    [0x04] = {0xFFFF, -1, psh_pul_discrim,   two, psh_pul_decode, 0}, /* psh/pul */\n+    [0x05] = {OP_rts, -1, 0,  single, 0, 0},\n+    [0x06] = {OP_lea, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x07] = {OP_lea, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x08] = {OP_lea, -1, 0, opr_n_bytes_p1, lea_reg_xys_opr, 0},\n+    [0x09] = {OP_lea, -1, 0, opr_n_bytes_p1, lea_reg_xys_opr, 0},\n+    [0x0a] = {OP_lea, -1, 0, opr_n_bytes_p1, lea_reg_xys_opr, 0},\n+    [0x0b] = {0xFFFF, -1, loop_primitive_discrim, loop_prim_n_bytes, loop_primitive_decode, 0}, /* Loop primitives TBcc / DBcc */\n+    [0x0c] = {OP_mov, 0, 0, mov_imm_opr_n_bytes, mov_imm_opr, 0},\n+    [0x0d] = {OP_mov, 1, 0, mov_imm_opr_n_bytes, mov_imm_opr, 0},\n+    [0x0e] = {OP_mov, 2, 0, mov_imm_opr_n_bytes, mov_imm_opr, 0},\n+    [0x0f] = {OP_mov, 3, 0, mov_imm_opr_n_bytes, mov_imm_opr, 0},\n+    [0x10] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},  /* lsr/lsl/asl/asr/rol/ror */\n+    [0x11] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x12] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x13] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x14] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x15] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x16] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x17] = {0xFFFF, -1, shift_discrim,  shift_n_bytes, shift_decode, 0},\n+    [0x18] = {OP_lea, -1, 0,  two, lea_reg_xys, NULL},\n+    [0x19] = {OP_lea, -1, 0,  two, lea_reg_xys, NULL},\n+    [0x1a] = {OP_lea, -1, 0,  two, lea_reg_xys, NULL},\n+    /* 0x1b PG2 */\n+    [0x1c] = {OP_mov, 0, 0, opr_n_bytes2, z_opr_decode2, 0},\n+    [0x1d] = {OP_mov, 1, 0, opr_n_bytes2, z_opr_decode2, 0},\n+    [0x1e] = {OP_mov, 2, 0, opr_n_bytes2, z_opr_decode2, 0},\n+    [0x1f] = {OP_mov, 3, 0, opr_n_bytes2, z_opr_decode2, 0},\n+    [0x20] = {OP_bra, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x21] = {OP_bsr, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x22] = {OP_bhi, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x23] = {OP_bls, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x24] = {OP_bcc, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x25] = {OP_bcs, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x26] = {OP_bne, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x27] = {OP_beq, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x28] = {OP_bvc, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x29] = {OP_bvs, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2a] = {OP_bpl, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2b] = {OP_bmi, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2c] = {OP_bge, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2d] = {OP_blt, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2e] = {OP_bgt, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x2f] = {OP_ble, -1, 0,  pcrel_15bit, decode_rel_15_7, 0},\n+    [0x30] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x31] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x32] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x33] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x34] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x35] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x36] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x37] = {OP_inc, -1, 0, single, z_reg, 0},\n+    [0x38] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x39] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3a] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3b] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3c] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3d] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3e] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x3f] = {OP_clr, -1, 0, single, z_reg, 0},\n+    [0x40] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x41] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x42] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x43] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x44] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x45] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x46] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x47] = {OP_dec, -1, 0, single, z_reg, 0},\n+    [0x48] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x49] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4a] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4b] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4c] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4d] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4e] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x4f] = {OPBASE_mul, -1, mul_discrim, mul_n_bytes, mul_decode, 0},\n+    [0x50] = {OP_add, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x51] = {OP_add, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x52] = {OP_add, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x53] = {OP_add, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x54] = {OP_add, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x55] = {OP_add, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x56] = {OP_add, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x57] = {OP_add, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x58] = {OP_and, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x59] = {OP_and, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5a] = {OP_and, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5b] = {OP_and, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x5c] = {OP_and, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x5d] = {OP_and, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x5e] = {OP_and, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x5f] = {OP_and, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x60] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x61] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x62] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x63] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x64] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x65] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x66] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x67] = {OP_add, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x68] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x69] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6a] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6b] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6c] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6d] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6e] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x6f] = {OP_and, -1, 0, opr_n_bytes_p1, z_reg, z_opr_decode},\n+    [0x70] = {OP_sub, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x71] = {OP_sub, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x72] = {OP_sub, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x73] = {OP_sub, -1, 0, three, z_reg, z_imm1234_0base},\n+    [0x74] = {OP_sub, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x75] = {OP_sub, -1, 0, two,   z_reg, z_imm1234_0base},\n+    [0x76] = {OP_sub, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x77] = {OP_sub, -1, 0, five,  z_reg, z_imm1234_0base},\n+    [0x78] = {OP_or, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x79] = {OP_or, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7a] = {OP_or, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7b] = {OP_or, -1, 0, three, z_reg, z_imm1234_8base},\n+    [0x7c] = {OP_or, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x7d] = {OP_or, -1, 0, two,   z_reg, z_imm1234_8base},\n+    [0x7e] = {OP_or, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x7f] = {OP_or, -1, 0, five,  z_reg, z_imm1234_8base},\n+    [0x80] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x81] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x82] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x83] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x84] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x85] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x86] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x87] = {OP_sub, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x88] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x89] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8a] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8b] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8c] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8d] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8e] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x8f] = {OP_or, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0x90] = {OP_ld, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0x91] = {OP_ld, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0x92] = {OP_ld, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0x93] = {OP_ld, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0x94] = {OP_ld, -1, 0, two,    z_reg, z_imm1234_0base},\n+    [0x95] = {OP_ld, -1, 0, two,    z_reg, z_imm1234_0base},\n+    [0x96] = {OP_ld, -1, 0, five,   z_reg, z_imm1234_0base},\n+    [0x97] = {OP_ld, -1, 0, five,   z_reg, z_imm1234_0base},\n+    [0x98] = {OP_ld, -1, 0, four,   reg_xy, z_imm1234_0base},\n+    [0x99] = {OP_ld, -1, 0, four,   reg_xy, z_imm1234_0base},\n+    [0x9a] = {OP_clr, -1, 0, single, reg_xy, 0},\n+    [0x9b] = {OP_clr, -1, 0, single, reg_xy, 0},\n+    [0x9c] = {OP_inc, 0, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0x9d] = {OP_inc, 1, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0x9e] = {OP_tfr, -1, 0, two, z_tfr, NULL},\n+    [0x9f] = {OP_inc, 3, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xa0] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa1] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa2] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa3] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa4] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa5] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa6] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa7] = {OP_ld, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xa8] = {OP_ld, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xa9] = {OP_ld, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xaa] = {OP_jmp, -1, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xab] = {OP_jsr, -1, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xac] = {OP_dec, 0, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xad] = {OP_dec, 1, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xae] = {0xFFFF, -1, exg_sex_discrim,   two, exg_sex_decode, 0},  /* EXG / SEX */\n+    [0xaf] = {OP_dec, 3, 0, opr_n_bytes_p1, 0, z_opr_decode},\n+    [0xb0] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb1] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb2] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb3] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb4] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb5] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb6] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb7] = {OP_ld, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xb8] = {OP_ld, -1, 0, four,  reg_xy, z_ext24_decode},\n+    [0xb9] = {OP_ld, -1, 0, four,  reg_xy, z_ext24_decode},\n+    [0xba] = {OP_jmp, -1, 0, four, z_ext24_decode, 0},\n+    [0xbb] = {OP_jsr, -1, 0, four, z_ext24_decode, 0},\n+    [0xbc] = {OP_clr, 0, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xbd] = {OP_clr, 1, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xbe] = {OP_clr, 2, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xbf] = {OP_clr, 3, 0, opr_n_bytes_p1, z_opr_decode, 0},\n+    [0xc0] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc1] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc2] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc3] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc4] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc5] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc6] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc7] = {OP_st, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xc8] = {OP_st, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xc9] = {OP_st, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xca] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xcb] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xcc] = {OP_com, 0, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xcd] = {OP_com, 1, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xce] = {OP_andcc, -1, 0, two, imm1_decode, 0},\n+    [0xcf] = {OP_com, 3, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xd0] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd1] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd2] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd3] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd4] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd5] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd6] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd7] = {OP_st, -1, 0, four,  z_reg, z_ext24_decode},\n+    [0xd8] = {OP_st, -1, 0, four,  reg_xy, z_ext24_decode},\n+    [0xd9] = {OP_st, -1, 0, four,  reg_xy, z_ext24_decode},\n+    [0xda] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xdb] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xdc] = {OP_neg, 0, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xdd] = {OP_neg, 1, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xde] = {OP_orcc, -1, 0,  two,  imm1_decode, 0},\n+    [0xdf] = {OP_neg,  3, 0, opr_n_bytes_p1, NULL, z_opr_decode},\n+    [0xe0] = {OP_cmp, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0xe1] = {OP_cmp, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0xe2] = {OP_cmp, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0xe3] = {OP_cmp, -1, 0, three,  z_reg, z_imm1234_0base},\n+    [0xe4] = {OP_cmp, -1, 0, two,    z_reg, z_imm1234_0base},\n+    [0xe5] = {OP_cmp, -1, 0, two,    z_reg, z_imm1234_0base},\n+    [0xe6] = {OP_cmp, -1, 0, five,   z_reg, z_imm1234_0base},\n+    [0xe7] = {OP_cmp, -1, 0, five,   z_reg, z_imm1234_0base},\n+    [0xe8] = {OP_cmp, -1, 0, four,   reg_xy, z_imm1234_0base},\n+    [0xe9] = {OP_cmp, -1, 0, four,   reg_xy, z_imm1234_0base},\n+    [0xea] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xeb] = {OP_ld, -1, 0, three, reg_xy, ld_18bit_decode},\n+    [0xec] = {OP_bclr, -1, 0, bm_n_bytes, bm_decode, 0},\n+    [0xed] = {OP_bset, -1, 0, bm_n_bytes, bm_decode, 0},\n+    [0xee] = {OP_btgl, -1, 0, bm_n_bytes, bm_decode, 0},\n+    [0xef] = {OP_INVALID, -1, 0, NULL, NULL, NULL}, /* SPARE */\n+    [0xf0] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf1] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf2] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf3] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf4] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf5] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf6] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf7] = {OP_cmp, -1, 0, opr_n_bytes_p1, z_reg,    z_opr_decode},\n+    [0xf8] = {OP_cmp, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xf9] = {OP_cmp, -1, 0, opr_n_bytes_p1, reg_xy, z_opr_decode},\n+    [0xfa] = {OP_ld, -1, 0,  three, reg_xy, ld_18bit_decode},\n+    [0xfb] = {OP_ld, -1, 0,  three, reg_xy, ld_18bit_decode},\n+    [0xfc] = {OP_cmp, -1, 0, single, cmp_xy, 0},\n+    [0xfd] = {OP_sub, -1, 0, single, sub_d6_x_y, 0},\n+    [0xfe] = {OP_sub, -1, 0, single, sub_d6_y_x, 0},\n+    [0xff] = {OP_swi, -1, 0, single, 0, 0}\n+  };\n+\n+static const int oprregs1[] =\n+  {\n+    REG_D3, REG_D2, REG_D1, REG_D0, REG_CCL, REG_CCH\n+  };\n+\n+static const int oprregs2[] =\n+  {\n+    REG_Y,  REG_X,  REG_D7, REG_D6, REG_D5,  REG_D4\n+  };\n+\n+\n+\f\n+\n+enum MUL_MODE\n+  {\n+    MUL_REG_REG,\n+    MUL_REG_OPR,\n+    MUL_REG_IMM,\n+    MUL_OPR_OPR\n+  };\n+\n+struct mb\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  enum MUL_MODE mode;\n+};\n+\n+static const struct mb mul_table[] = {\n+  {0x40, 0x00, MUL_REG_REG},\n+\n+  {0x47, 0x40, MUL_REG_OPR},\n+  {0x47, 0x41, MUL_REG_OPR},\n+  {0x47, 0x43, MUL_REG_OPR},\n+\n+  {0x47, 0x44, MUL_REG_IMM},\n+  {0x47, 0x45, MUL_REG_IMM},\n+  {0x47, 0x47, MUL_REG_IMM},\n+\n+  {0x43, 0x42, MUL_OPR_OPR},\n+};\n+\n+\n+static void\n+mul_decode (struct mem_read_abstraction_base *mra,\n+\t    int *n_operands, struct operand **operand)\n+{\n+  uint8_t mb;\n+  int status = mra->read (mra, 0, 1, &mb);\n+  if (status < 0)\n+    return;\n+\n+  uint8_t byte;\n+  status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return;\n+\n+  enum MUL_MODE mode = -1;\n+  size_t i;\n+  for (i = 0; i < sizeof (mul_table) / sizeof (mul_table[0]); ++i)\n+    {\n+      const struct mb *mm = mul_table + i;\n+      if ((mb & mm->mask) == mm->value)\n+\t{\n+\t  mode = mm->mode;\n+\t  break;\n+\t}\n+    }\n+  operand[(*n_operands)++] = create_register_operand (byte & 0x07);\n+\n+  switch (mode)\n+    {\n+    case MUL_REG_IMM:\n+      {\n+\tint size = (mb & 0x3);\n+\toperand[(*n_operands)++] =\n+\t  create_register_operand_with_size ((mb & 0x38) >> 3, size);\n+\tuint32_t imm = z_decode_signed_value (mra, 1, size + 1);\n+\toperand[(*n_operands)++] = create_immediate_operand (imm);\n+      }\n+      break;\n+    case MUL_REG_REG:\n+      operand[(*n_operands)++] = create_register_operand ((mb & 0x38) >> 3);\n+      operand[(*n_operands)++] = create_register_operand (mb & 0x07);\n+      break;\n+    case MUL_REG_OPR:\n+      operand[(*n_operands)++] = create_register_operand ((mb & 0x38) >> 3);\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, mb & 0x3);\n+      break;\n+    case MUL_OPR_OPR:\n+      {\n+\tint first = x_opr_n_bytes (mra, 1);\n+\toperand[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n+\t\t\t\t\t\t\t   (mb & 0x30) >> 4);\n+\toperand[(*n_operands)++] = x_opr_decode_with_size (mra, first + 1,\n+\t\t\t\t\t\t\t   (mb & 0x0c) >> 2);\n+\tbreak;\n+      }\n+    }\n+}\n+\n+\n+static int\n+mul_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  int nx = 2;\n+  uint8_t mb;\n+  int status = mra->read (mra, 0, 1, &mb);\n+  if (status < 0)\n+    return 0;\n+\n+  enum MUL_MODE mode = -1;\n+  size_t i;\n+  for (i = 0; i < sizeof (mul_table) / sizeof (mul_table[0]); ++i)\n+    {\n+      const struct mb *mm = mul_table + i;\n+      if ((mb & mm->mask) == mm->value)\n+\t{\n+\t  mode = mm->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  int size = (mb & 0x3) + 1;\n+\n+  switch (mode)\n+    {\n+    case MUL_REG_IMM:\n+      nx += size;\n+      break;\n+    case MUL_REG_REG:\n+      break;\n+    case MUL_REG_OPR:\n+      nx += x_opr_n_bytes (mra, 1);\n+      break;\n+    case MUL_OPR_OPR:\n+      {\n+\tint first = x_opr_n_bytes (mra, nx - 1);\n+\tnx += first;\n+\tint second = x_opr_n_bytes (mra, nx - 1);\n+\tnx += second;\n+      }\n+      break;\n+    }\n+\n+  return nx;\n+}\n+\n+\f\n+/* The NXP documentation is vague about BM_RESERVED0 and BM_RESERVED1,\n+   and contains obvious typos.\n+   However the Freescale tools and experiments with the chip itself\n+   seem to indicate that they behave like BM_REG_IMM and BM_OPR_REG\n+   respectively.  */\n+\n+enum BM_MODE\n+{\n+  BM_REG_IMM,\n+  BM_RESERVED0,\n+  BM_OPR_B,\n+  BM_OPR_W,\n+  BM_OPR_L,\n+  BM_OPR_REG,\n+  BM_RESERVED1\n+};\n+\n+struct bm\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  enum BM_MODE mode;\n+};\n+\n+static const  struct bm bm_table[] = {\n+  { 0xC6, 0x04,     BM_REG_IMM},\n+  { 0x84, 0x00,     BM_REG_IMM},\n+  { 0x06, 0x06,     BM_REG_IMM},\n+  { 0xC6, 0x44,     BM_RESERVED0},\n+  // 00\n+  { 0x8F, 0x80,     BM_OPR_B},\n+  { 0x8E, 0x82,     BM_OPR_W},\n+  { 0x8C, 0x88,     BM_OPR_L},\n+\n+  { 0x83, 0x81,     BM_OPR_REG},\n+  { 0x87, 0x84,     BM_RESERVED1},\n+};\n+\n+static void\n+bm_decode (struct mem_read_abstraction_base *mra,\n+\t   int *n_operands, struct operand **operand)\n+{\n+  uint8_t bm;\n+  int status = mra->read (mra, 0, 1, &bm);\n+  if (status < 0)\n+    return;\n+\n+  size_t i;\n+  enum BM_MODE mode = -1;\n+  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n+    {\n+      const struct bm *bme = bm_table + i;\n+      if ((bm & bme->mask) == bme->value)\n+\t{\n+\t  mode = bme->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  switch (mode)\n+    {\n+    case BM_REG_IMM:\n+    case BM_RESERVED0:\n+      operand[(*n_operands)++] = create_register_operand (bm & 0x07);\n+      break;\n+    case BM_OPR_B:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 0);\n+      break;\n+    case BM_OPR_W:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 1);\n+      break;\n+    case BM_OPR_L:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 3);\n+      break;\n+    case BM_OPR_REG:\n+    case BM_RESERVED1:\n+      {\n+\tuint8_t xb;\n+\tmra->read (mra, 1, 1, &xb);\n+\t/* Don't emit a size suffix for register operands */\n+\tif ((xb & 0xF8) != 0xB8)\n+\t  operand[(*n_operands)++] =\n+\t    x_opr_decode_with_size (mra, 1, (bm & 0x0c) >> 2);\n+\telse\n+\t  operand[(*n_operands)++] = x_opr_decode (mra, 1);\n+      }\n+      break;\n+    }\n+\n+  uint8_t imm = 0;\n+  switch (mode)\n+    {\n+    case BM_REG_IMM:\n+      imm = (bm & 0x38) >> 3;\n+      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      break;\n+    case BM_OPR_L:\n+      imm |= (bm & 0x03) << 3;\n+      /* fallthrough */\n+    case BM_OPR_W:\n+      imm |= (bm & 0x01) << 3;\n+      /* fallthrough */\n+    case BM_OPR_B:\n+      imm |= (bm & 0x70) >> 4;\n+      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      break;\n+    case BM_OPR_REG:\n+    case BM_RESERVED1:\n+      operand[(*n_operands)++] = create_register_operand ((bm & 0x70) >> 4);\n+      break;\n+    case BM_RESERVED0:\n+      assert (0);\n+      break;\n+    }\n+}\n+\n+\n+static void\n+bm_rel_decode (struct mem_read_abstraction_base *mra,\n+\t       int *n_operands, struct operand **operand)\n+{\n+  uint8_t bm;\n+  int status = mra->read (mra, 0, 1, &bm);\n+  if (status < 0)\n+    return;\n+\n+  size_t i;\n+  enum BM_MODE mode = -1;\n+  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n+    {\n+      const struct bm *bme = bm_table + i;\n+      if ((bm & bme->mask) == bme->value)\n+\t{\n+\t  mode = bme->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  int n = 1;\n+  switch (mode)\n+    {\n+    case BM_REG_IMM:\n+    case BM_RESERVED0:\n+      operand[(*n_operands)++] = create_register_operand (bm & 0x07);\n+      break;\n+    case BM_OPR_B:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 0);\n+      n = 1 + x_opr_n_bytes (mra, 1);\n+      break;\n+    case BM_OPR_W:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 1);\n+      n = 1 + x_opr_n_bytes (mra, 1);\n+      break;\n+    case BM_OPR_L:\n+      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 3);\n+      n = 1 + x_opr_n_bytes (mra, 1);\n+      break;\n+    case BM_OPR_REG:\n+    case BM_RESERVED1:\n+      {\n+\tuint8_t xb;\n+\tmra->read (mra, +1, 1, &xb);\n+\t/* Don't emit a size suffix for register operands */\n+\tif ((xb & 0xF8) != 0xB8)\n+\t  {\n+\t    short os = (bm & 0x0c) >> 2;\n+\t    operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, os);\n+\t  }\n+\telse\n+\t  operand[(*n_operands)++] = x_opr_decode (mra, 1);\n+\n+      }\n+      break;\n+    }\n+\n+  int imm = 0;\n+  switch (mode)\n+    {\n+    case BM_OPR_L:\n+      imm |= (bm & 0x02) << 3;\n+      /* fall through */\n+    case BM_OPR_W:\n+      imm |= (bm & 0x01) << 3;\n+      /* fall through */\n+    case BM_OPR_B:\n+      imm |= (bm & 0x70) >> 4;\n+      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      break;\n+    case BM_RESERVED0:\n+      imm = (bm & 0x38) >> 3;\n+      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      break;\n+    case BM_REG_IMM:\n+      imm = (bm & 0xF8) >> 3;\n+      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      break;\n+    case BM_OPR_REG:\n+    case BM_RESERVED1:\n+      operand[(*n_operands)++] = create_register_operand ((bm & 0x70) >> 4);\n+      n += x_opr_n_bytes (mra, 1);\n+      break;\n+    }\n+\n+  rel_15_7 (mra, n + 1, n_operands, operand);\n+}\n+\n+static int\n+bm_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  uint8_t bm;\n+  int status = mra->read (mra, 0, 1, &bm);\n+  if (status < 0)\n+    return status;\n+\n+  size_t i;\n+  enum BM_MODE mode = -1;\n+  for (i = 0; i < sizeof (bm_table) / sizeof (bm_table[0]); ++i)\n+    {\n+      const struct bm *bme = bm_table + i;\n+      if ((bm & bme->mask) == bme->value)\n+\t{\n+\t  mode = bme->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  int n = 2;\n+  switch (mode)\n+    {\n+    case BM_REG_IMM:\n+    case BM_RESERVED0:\n+      break;\n+\n+    case BM_OPR_B:\n+    case BM_OPR_W:\n+    case BM_OPR_L:\n+      n += x_opr_n_bytes (mra, 1);\n+      break;\n+    case BM_OPR_REG:\n+    case BM_RESERVED1:\n+      n += x_opr_n_bytes (mra, 1);\n+      break;\n+    }\n+\n+  return n;\n+}\n+\n+static int\n+bm_rel_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  int n = 1 + bm_n_bytes (mra);\n+\n+  bfd_byte rb;\n+  int status = mra->read (mra, n - 2, 1, &rb);\n+  if (status != 0)\n+    return status;\n+\n+  if (rb & 0x80)\n+    n++;\n+\n+  return n;\n+}\n+\n+\n+\f\n+\n+\n+/* shift direction */\n+enum SB_DIR\n+  {\n+    SB_LEFT,\n+    SB_RIGHT\n+  };\n+\n+enum SB_TYPE\n+  {\n+    SB_ARITHMETIC,\n+    SB_LOGICAL\n+  };\n+\n+\n+enum SB_MODE\n+  {\n+    SB_REG_REG_N_EFF,\n+    SB_REG_REG_N,\n+    SB_REG_OPR_EFF,\n+    SB_ROT,\n+    SB_REG_OPR_OPR,\n+    SB_OPR_N\n+  };\n+\n+struct sb\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  enum SB_MODE mode;\n+};\n+\n+static const  struct sb sb_table[] = {\n+  {0x30, 0x00,     SB_REG_REG_N_EFF},\n+  {0x30, 0x10,     SB_REG_REG_N},\n+  {0x34, 0x20,     SB_REG_OPR_EFF},\n+  {0x34, 0x24,     SB_ROT},\n+  {0x34, 0x30,     SB_REG_OPR_OPR},\n+  {0x34, 0x34,     SB_OPR_N},\n+};\n+\n+static int\n+shift_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  bfd_byte sb;\n+  int status = mra->read (mra, 0, 1, &sb);\n+  if (status != 0)\n+    return status;\n+\n+  size_t i;\n+  enum SB_MODE mode = -1;\n+  for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n+    {\n+      const struct sb *sbe = sb_table + i;\n+      if ((sb & sbe->mask) == sbe->value)\n+\tmode = sbe->mode;\n+    }\n+\n+  switch (mode)\n+    {\n+    case SB_REG_REG_N_EFF:\n+      return 2;\n+      break;\n+    case SB_REG_OPR_EFF:\n+    case SB_ROT:\n+      return 2 + x_opr_n_bytes (mra, 1);\n+      break;\n+    case SB_REG_OPR_OPR:\n+      {\n+\tint opr1 = x_opr_n_bytes (mra, 1);\n+\tint opr2 = 0;\n+\tif ((sb & 0x30) != 0x20)\n+\t  opr2 = x_opr_n_bytes (mra, opr1 + 1);\n+\treturn 2 + opr1 + opr2;\n+      }\n+      break;\n+    default:\n+      return 3;\n+    }\n+\n+  /* not reached */\n+  return -1;\n+}\n+\f\n+\n+static int\n+\n+mov_imm_opr_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1,  &byte);\n+  if (status < 0)\n+    return status;\n+\n+  int size = byte - 0x0c + 1;\n+\n+  return size + x_opr_n_bytes (mra, size) + 1;\n+}\n+\n+static void\n+mov_imm_opr (struct mem_read_abstraction_base *mra,\n+\t     int *n_operands, struct operand **operand)\n+{\n+  bfd_byte byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return ;\n+\n+  int size = byte - 0x0c + 1;\n+  uint32_t imm = decode_signed_value (mra, size);\n+\n+  operand[(*n_operands)++] = create_immediate_operand (imm);\n+  operand[(*n_operands)++] = x_opr_decode (mra, size);\n+}\n+\n+\f\n+\n+static void\n+ld_18bit_decode (struct mem_read_abstraction_base *mra,\n+\t\t int *n_operands, struct operand **operand)\n+{\n+  size_t size = 3;\n+  bfd_byte buffer[3];\n+  int status = mra->read (mra, 0, 2, buffer + 1);\n+  if (status < 0)\n+    return ;\n+\n+  status = mra->read (mra, -1, 1, buffer);\n+  if (status < 0)\n+    return ;\n+\n+  buffer[0] = (buffer[0] & 0x30) >> 4;\n+\n+  size_t i;\n+  uint32_t imm = 0;\n+  for (i = 0; i < size; ++i)\n+    {\n+      imm |= buffer[i] << (8 * (size - i - 1));\n+    }\n+\n+  operand[(*n_operands)++] = create_immediate_operand (imm);\n+}\n+\n+\f\n+\n+/* Loop Primitives */\n+\n+enum LP_MODE {\n+  LP_REG,\n+  LP_XY,\n+  LP_OPR\n+};\n+\n+struct lp\n+{\n+  uint8_t mask;\n+  uint8_t value;\n+  enum LP_MODE mode;\n+};\n+\n+static const struct lp lp_mode[] = {\n+  {0x08, 0x00, LP_REG},\n+  {0x0C, 0x08, LP_XY},\n+  {0x0C, 0x0C, LP_OPR},\n+};\n+\n+\n+static int\n+loop_prim_n_bytes (struct mem_read_abstraction_base *mra)\n+{\n+  int mx = 0;\n+  uint8_t lb;\n+  mra->read (mra, mx++, 1, &lb);\n+\n+  enum LP_MODE mode = -1;\n+  size_t i;\n+  for (i = 0; i < sizeof (lp_mode) / sizeof (lp_mode[0]); ++i)\n+    {\n+      const struct lp *pb = lp_mode + i;\n+      if ((lb & pb->mask) == pb->value)\n+\t{\n+\t  mode = pb->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  if (mode == LP_OPR)\n+    {\n+      mx += x_opr_n_bytes (mra, mx) ;\n+    }\n+\n+  uint8_t rb;\n+  mra->read (mra, mx++, 1, &rb);\n+  if (rb & 0x80)\n+    mx++;\n+\n+  return mx + 1;\n+}\n+\n+\n+\f\n+\n+static enum operator\n+exg_sex_discrim (struct mem_read_abstraction_base *mra, enum operator hint ATTRIBUTE_UNUSED)\n+{\n+  uint8_t eb;\n+  int status = mra->read (mra, 0, 1, &eb);\n+  if (status < 0)\n+    return OP_INVALID;\n+\n+  struct operand *op0 = create_register_operand ((eb & 0xf0) >> 4);\n+  struct operand *op1 = create_register_operand (eb & 0xf);\n+\n+  const struct reg *r0 = registers + ((struct register_operand *) op0)->reg;\n+  const struct reg *r1 = registers + ((struct register_operand *) op1)->reg;\n+\n+  enum operator operator = (r0->bytes < r1->bytes) ? OP_sex : OP_exg;\n+\n+  free (op0);\n+  free (op1);\n+  \n+  return operator;\n+}\n+\n+\n+static void\n+exg_sex_decode (struct mem_read_abstraction_base *mra,\n+\t\tint *n_operands, struct operand **operands)\n+{\n+  uint8_t eb;\n+  int status = mra->read (mra, 0, 1, &eb);\n+  if (status < 0)\n+    return;\n+\n+  /* Ship out the operands.  */\n+  operands[(*n_operands)++] =  create_register_operand ((eb & 0xf0) >> 4);\n+  operands[(*n_operands)++] =  create_register_operand (eb & 0xf);\n+}\n+\n+static enum operator\n+loop_primitive_discrim (struct mem_read_abstraction_base *mra,\n+\t\t\tenum operator hint ATTRIBUTE_UNUSED)\n+{\n+  uint8_t lb;\n+  int status = mra->read (mra, 0, 1, &lb);\n+  if (status < 0)\n+    return OP_INVALID;\n+\n+  enum operator opbase = (lb & 0x80) ? OP_dbNE : OP_tbNE;\n+  return opbase + ((lb & 0x70) >> 4);\n+}\n+\n+static void\n+loop_primitive_decode (struct mem_read_abstraction_base *mra,\n+\t\t  int *n_operands, struct operand **operands)\n+{\n+  int offs = 1;\n+  uint8_t lb;\n+  int status = mra->read (mra, 0, 1, &lb);\n+  if (status < 0)\n+    return ;\n+\n+  enum LP_MODE mode = -1;\n+  size_t i;\n+  for (i = 0; i < sizeof (lp_mode) / sizeof (lp_mode[0]); ++i)\n+    {\n+      const struct lp *pb = lp_mode + i;\n+      if ((lb & pb->mask) == pb->value)\n+\t{\n+\t  mode = pb->mode;\n+\t  break;\n+\t}\n+    }\n+\n+  switch (mode)\n+    {\n+    case LP_REG:\n+      operands[(*n_operands)++] = create_register_operand (lb & 0x07);\n+      break;\n+    case LP_XY:\n+      operands[(*n_operands)++] =\n+\tcreate_register_operand ((lb & 0x01) + REG_X);\n+      break;\n+    case LP_OPR:\n+      offs += x_opr_n_bytes (mra, 1);\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, lb & 0x03);\n+      break;\n+    }\n+\n+  rel_15_7 (mra, offs + 1, n_operands, operands);\n+}\n+\n+\n+static enum operator\n+shift_discrim (struct mem_read_abstraction_base *mra,  enum operator hint ATTRIBUTE_UNUSED)\n+{\n+  size_t i;\n+  uint8_t sb;\n+  int status = mra->read (mra, 0, 1, &sb);\n+  if (status < 0)\n+    return status;\n+\n+  enum SB_DIR  dir = (sb & 0x40) ? SB_LEFT : SB_RIGHT;\n+  enum SB_TYPE type = (sb & 0x80) ? SB_ARITHMETIC : SB_LOGICAL;\n+  enum SB_MODE mode = -1;\n+  for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n+    {\n+      const struct sb *sbe = sb_table + i;\n+      if ((sb & sbe->mask) == sbe->value)\n+\tmode = sbe->mode;\n+    }\n+\n+  if (mode == SB_ROT)\n+    return (dir == SB_LEFT) ? OP_rol : OP_ror;\n+\n+  if (type == SB_LOGICAL)\n+    return (dir == SB_LEFT) ? OP_lsl : OP_lsr;\n+\n+  return (dir == SB_LEFT) ? OP_asl : OP_asr;\n+}\n+\n+\n+static void\n+shift_decode (struct mem_read_abstraction_base *mra,  int *n_operands, struct operand **operands)\n+{\n+  size_t i;\n+\n+  uint8_t byte;\n+  int status = mra->read (mra, -1, 1, &byte);\n+  if (status < 0)\n+    return ;\n+\n+  uint8_t sb;\n+  status = mra->read (mra, 0, 1, &sb);\n+  if (status < 0)\n+    return ;\n+\n+  enum SB_MODE mode = -1;\n+  for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n+    {\n+      const struct sb *sbe = sb_table + i;\n+      if ((sb & sbe->mask) == sbe->value)\n+\tmode = sbe->mode;\n+    }\n+\n+  short osize = -1;\n+  switch (mode)\n+    {\n+    case SB_REG_OPR_EFF:\n+    case SB_ROT:\n+    case SB_REG_OPR_OPR:\n+      osize = sb & 0x03;\n+      break;\n+    case SB_OPR_N:\n+      {\n+\tuint8_t xb;\n+\tmra->read (mra, 1, 1, &xb);\n+\t/* The size suffix is not printed if the OPR operand refers\n+\t   directly to a register, because the size is implied by the\n+\t   size of that register. */\n+\tif ((xb & 0xF8) != 0xB8)\n+\t  osize = sb & 0x03;\n+      }\n+      break;\n+    default:\n+      break;\n+    };\n+\n+  /* Destination register */\n+  switch (mode)\n+    {\n+    case SB_REG_REG_N_EFF:\n+    case SB_REG_REG_N:\n+      operands[(*n_operands)++] = create_register_operand (byte & 0x07);\n+      break;\n+    case SB_REG_OPR_EFF:\n+    case SB_REG_OPR_OPR:\n+      operands[(*n_operands)++] = create_register_operand (byte & 0x07);\n+      break;\n+\n+    case SB_ROT:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Source register */\n+  switch (mode)\n+    {\n+    case SB_REG_REG_N_EFF:\n+    case SB_REG_REG_N:\n+      operands[(*n_operands)++] =\n+\tcreate_register_operand_with_size (sb & 0x07, osize);\n+      break;\n+\n+    case SB_REG_OPR_OPR:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* 3rd arg */\n+  switch (mode)\n+    {\n+    case SB_REG_OPR_EFF:\n+    case SB_OPR_N:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      break;\n+\n+    case SB_REG_REG_N:\n+      {\n+        uint8_t xb;\n+        mra->read (mra, 1, 1, &xb);\n+\n+        /* This case is slightly unusual.\n+           If XB matches the binary pattern 0111XXXX, then instead of\n+           interpreting this as a general OPR postbyte in the IMMe4 mode,\n+           the XB byte is interpreted in s special way.  */\n+        if ((xb & 0xF0) == 0x70)\n+          {\n+            if (byte & 0x10)\n+              {\n+                int shift = ((sb & 0x08) >> 3) | ((xb & 0x0f) << 1);\n+                operands[(*n_operands)++] = create_immediate_operand (shift);\n+              }\n+            else\n+              {\n+                /* This should not happen.  */\n+                abort ();\n+              }\n+          }\n+        else\n+          {\n+            operands[(*n_operands)++] = x_opr_decode (mra, 1);\n+          }\n+      }\n+      break;\n+    case SB_REG_OPR_OPR:\n+      {\n+\tuint8_t xb;\n+\tint n = x_opr_n_bytes (mra, 1);\n+\tmra->read (mra, 1 + n, 1, &xb);\n+\n+\tif ((xb & 0xF0) == 0x70)\n+\t  {\n+\t    int imm = xb & 0x0F;\n+\t    imm <<= 1;\n+\t    imm |= (sb & 0x08) >> 3;\n+\t    operands[(*n_operands)++] = create_immediate_operand (imm);\n+\t  }\n+\telse\n+\t  {\n+\t    operands[(*n_operands)++] = x_opr_decode (mra, 1 + n);\n+\t  }\n+      }\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  switch (mode)\n+    {\n+    case SB_REG_REG_N_EFF:\n+    case SB_REG_OPR_EFF:\n+    case SB_OPR_N:\n+      {\n+        int imm = (sb & 0x08) ? 2 : 1;\n+        operands[(*n_operands)++] = create_immediate_operand (imm);\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+static enum operator\n+psh_pul_discrim (struct mem_read_abstraction_base *mra,\n+\t\t enum operator hint ATTRIBUTE_UNUSED)\n+{\n+  uint8_t byte;\n+  int status = mra->read (mra, 0, 1, &byte);\n+  if (status != 0)\n+    return OP_INVALID;\n+\n+  return (byte & 0x80) ? OP_pull: OP_push;\n+}\n+\n+\n+static void\n+psh_pul_decode (struct mem_read_abstraction_base *mra,\n+\t\tint *n_operands, struct operand **operand)\n+{\n+  uint8_t byte;\n+  int status = mra->read (mra, 0, 1, &byte);\n+  if (status != 0)\n+    return;\n+  int bit;\n+  if (byte & 0x40)\n+    {\n+      if ((byte & 0x3F) == 0)\n+        {\n+\t  operand[(*n_operands)++] = create_register_all16_operand ();\n+        }\n+      else\n+\tfor (bit = 5; bit >= 0; --bit)\n+\t  {\n+\t    if (byte & (0x1 << bit))\n+\t      {\n+\t\toperand[(*n_operands)++] = create_register_operand (oprregs2[bit]);\n+\t      }\n+\t  }\n+    }\n+  else\n+    {\n+      if ((byte & 0x3F) == 0)\n+        {\n+\t  operand[(*n_operands)++] = create_register_all_operand ();\n+        }\n+      else\n+\tfor (bit = 5; bit >= 0; --bit)\n+\t  {\n+\t    if (byte & (0x1 << bit))\n+\t      {\n+\t\toperand[(*n_operands)++] = create_register_operand (oprregs1[bit]);\n+\t      }\n+\t  }\n+    }\n+}\n+\n+static enum operator\n+bit_field_discrim (struct mem_read_abstraction_base *mra, enum operator hint ATTRIBUTE_UNUSED)\n+{\n+  int status;\n+  bfd_byte bb;\n+  status = mra->read (mra, 0, 1, &bb);\n+  if (status != 0)\n+    return OP_INVALID;\n+\n+  return  (bb & 0x80) ? OP_bfins : OP_bfext;\n+}\n+\n+static void\n+bit_field_decode (struct mem_read_abstraction_base *mra,\n+\t\t  int *n_operands, struct operand **operands)\n+{\n+  int status;\n+\n+  bfd_byte byte2;\n+  status = mra->read (mra, -1, 1, &byte2);\n+  if (status != 0)\n+    return;\n+\n+  bfd_byte bb;\n+  status = mra->read (mra, 0, 1, &bb);\n+  if (status != 0)\n+    return;\n+\n+  enum BB_MODE mode = -1;\n+  size_t i;\n+  const struct opr_bb *bbs = 0;\n+  for (i = 0; i < sizeof (bb_modes) / sizeof (bb_modes[0]); ++i)\n+    {\n+      bbs = bb_modes + i;\n+      if ((bb & bbs->mask) == bbs->value)\n+        {\n+          mode = bbs->mode;\n+          break;\n+        }\n+    }\n+  int reg1 = byte2 & 0x07;\n+  /* First operand */\n+  switch (mode)\n+    {\n+    case BB_REG_REG_REG:\n+    case BB_REG_REG_IMM:\n+    case BB_REG_OPR_REG:\n+    case BB_REG_OPR_IMM:\n+      operands[(*n_operands)++] = create_register_operand (reg1);\n+      break;\n+    case BB_OPR_REG_REG:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n+\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      break;\n+    case BB_OPR_REG_IMM:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 2,\n+\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      break;\n+    }\n+\n+  /* Second operand */\n+  switch (mode)\n+    {\n+    case BB_REG_REG_REG:\n+    case BB_REG_REG_IMM:\n+      {\n+        int reg_src = (bb >> 2) & 0x07;\n+        operands[(*n_operands)++] = create_register_operand (reg_src);\n+      }\n+      break;\n+    case BB_OPR_REG_REG:\n+    case BB_OPR_REG_IMM:\n+      {\n+        int reg_src = (byte2 & 0x07);\n+        operands[(*n_operands)++] = create_register_operand (reg_src);\n+      }\n+      break;\n+    case BB_REG_OPR_REG:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n+\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      break;\n+    case BB_REG_OPR_IMM:\n+      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 2,\n+\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      break;\n+    }\n+\n+  /* Third operand */\n+  switch (mode)\n+    {\n+    case BB_REG_REG_REG:\n+    case BB_OPR_REG_REG:\n+    case BB_REG_OPR_REG:\n+      {\n+        int reg_parm = bb & 0x03;\n+\toperands[(*n_operands)++] = create_register_operand (reg_parm);\n+      }\n+      break;\n+    case BB_REG_REG_IMM:\n+    case BB_OPR_REG_IMM:\n+    case BB_REG_OPR_IMM:\n+      {\n+        bfd_byte i1;\n+        mra->read (mra, 1, 1, &i1);\n+        int offset = i1 & 0x1f;\n+        int width = bb & 0x03;\n+        width <<= 3;\n+        width |= i1 >> 5;\n+        operands[(*n_operands)++] = create_bitfield_operand (width, offset);\n+      }\n+      break;\n+    }\n+}\n+\n+\n+/* Decode the next instruction at MRA, according to OPC.\n+   The operation to be performed is returned.\n+   The number of operands, will be placed in N_OPERANDS.\n+   The operands themselved into OPERANDS.  */\n+static enum operator\n+decode_operation (const struct opcode *opc,\n+\t\t  struct mem_read_abstraction_base *mra,\n+\t\t  int *n_operands, struct operand **operands)\n+{\n+  enum operator op = opc->operator;\n+  if (opc->discriminator)\n+    op = opc->discriminator (mra, opc->operator);\n+\n+  if (opc->operands)\n+    opc->operands (mra, n_operands, operands);\n+\n+  if (opc->operands2)\n+    opc->operands2 (mra, n_operands, operands);\n+\n+  return op;\n+}\n+\n+int\n+decode_s12z (enum operator *myoperator, short *osize,\n+\t     int *n_operands, struct operand **operands,\n+\t     struct mem_read_abstraction_base *mra)\n+{\n+  int n_bytes = 0;\n+  bfd_byte byte;\n+\n+  int status = mra->read (mra, 0, 1, &byte);\n+  if (status != 0)\n+    return status;\n+\n+  mra->advance (mra);\n+\n+  const struct opcode *opc = page1 + byte;\n+  if (byte == PAGE2_PREBYTE)\n+    {\n+      /* Opcodes in page2 have an additional byte */\n+      n_bytes++;\n+\n+      bfd_byte byte2;\n+      mra->read (mra, 0, 1, &byte2);\n+      mra->advance (mra);\n+      opc = page2 + byte2;\n+    }\n+  *myoperator = decode_operation (opc, mra, n_operands, operands);\n+  *osize = opc->osize;\n+\n+  /* Return the number of bytes in the instruction.  */\n+  n_bytes += (opc && opc->insn_bytes) ? opc->insn_bytes (mra) : 0;\n+\n+  return n_bytes;\n+}\n+"
    },
    {
      "sha": "186a7f29c3f0d3485388b9f6835465461ba7d1d5",
      "filename": "opcodes/s12z-opc.h",
      "status": "added",
      "additions": 267,
      "deletions": 0,
      "changes": 267,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ef1ad42b8b5f2c43d74582d2e629841c39962c18/opcodes/s12z-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/s12z-opc.h?ref=ef1ad42b8b5f2c43d74582d2e629841c39962c18",
      "patch": "@@ -0,0 +1,267 @@\n+/* s12z-dis.h -- Header file for s12z-dis.c and s12z-decode.c\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of the GNU opcodes library.\n+\n+   This library is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING3. If not,\n+   see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef S12Z_OPC_H\n+#define S12Z_OPC_H\n+\n+#include <stdbool.h>\n+\n+/* An abstraction used to read machine code from a source.  */\n+struct mem_read_abstraction_base\n+{\n+  int (*read) (struct mem_read_abstraction_base *, int, size_t, bfd_byte *);\n+  void (*advance) (struct mem_read_abstraction_base *);\n+  bfd_vma (*posn) (struct mem_read_abstraction_base *);\n+};\n+\n+\n+/* Machine code operators.\n+   These *roughly* correspond to opcodes.\n+   But describe their purpose rather than their form.  */\n+enum operator\n+  {\n+    OP_INVALID = 0,\n+\n+    OP_push,\n+    OP_pull,\n+    /* Test and branch.  */\n+    OP_tbNE, OP_tbEQ, OP_tbPL, OP_tbMI, OP_tbGT, OP_tbLE,\n+    /* Decrement and branch.  */\n+    OP_dbNE, OP_dbEQ, OP_dbPL, OP_dbMI, OP_dbGT, OP_dbLE,\n+\n+    /* Note: sex and exg are the same opcode.\n+       They are mnemonic changes according to the operands.  */\n+    OP_sex,\n+    OP_exg,\n+\n+    /* Shifters.  */\n+    OP_lsl, OP_lsr,\n+    OP_asl, OP_asr,\n+    OP_rol, OP_ror,\n+    /* Bit field operations.  */\n+    OP_bfins, OP_bfext,\n+    OP_trap,\n+\n+    OP_ld,\n+    OP_st,\n+    OP_cmp,\n+\n+    OP_stop,\n+    OP_wai,\n+    OP_sys,\n+\n+    OP_minu,\n+    OP_mins,\n+    OP_maxu,\n+    OP_maxs,\n+\n+    OP_abs,\n+    OP_adc,\n+    OP_bit,\n+    OP_sbc,\n+    OP_rti,\n+    OP_clb,\n+    OP_eor,\n+\n+    OP_sat,\n+\n+    OP_nop,\n+    OP_bgnd,\n+    OP_brclr,\n+    OP_brset,\n+    OP_rts,\n+    OP_lea,\n+    OP_mov,\n+\n+    OP_bra,\n+    OP_bsr,\n+    OP_bhi,\n+    OP_bls,\n+    OP_bcc,\n+    OP_bcs,\n+    OP_bne,\n+    OP_beq,\n+    OP_bvc,\n+    OP_bvs,\n+    OP_bpl,\n+    OP_bmi,\n+    OP_bge,\n+    OP_blt,\n+    OP_bgt,\n+    OP_ble,\n+    OP_inc,\n+    OP_clr,\n+    OP_dec,\n+\n+    OP_add,\n+    OP_sub,\n+    OP_and,\n+    OP_or,\n+\n+    OP_tfr,\n+    OP_jmp,\n+    OP_jsr,\n+    OP_com,\n+    OP_andcc,\n+    OP_neg,\n+    OP_orcc,\n+    OP_bclr,\n+    OP_bset,\n+    OP_btgl,\n+    OP_swi,\n+\n+    OP_mulu,\n+    OP_divu,\n+    OP_modu,\n+    OP_macu,\n+    OP_qmulu,\n+\n+    OP_muls,\n+    OP_divs,\n+    OP_mods,\n+    OP_macs,\n+    OP_qmuls,\n+\n+    OPBASE_mul = 0x4000,\n+    OPBASE_div,\n+    OPBASE_mod,\n+    OPBASE_mac,\n+    OPBASE_qmul,\n+\n+    n_OPS\n+  };\n+\n+\n+/* Used for operands which mutate their index/base registers.\n+   Eg  ld d0, (s+).  */\n+enum op_reg_mutation\n+  {\n+    OPND_RM_NONE,\n+    OPND_RM_PRE_DEC,\n+    OPND_RM_PRE_INC,\n+    OPND_RM_POST_DEC,\n+    OPND_RM_POST_INC\n+  };\n+\n+/* The class of an operand.  */\n+enum opnd_class\n+  {\n+    OPND_CL_IMMEDIATE,\n+    OPND_CL_MEMORY,\n+    OPND_CL_REGISTER,\n+    OPND_CL_REGISTER_ALL,   /* Used only for psh/pul.  */\n+    OPND_CL_REGISTER_ALL16, /* Used only for psh/pul.  */\n+    OPND_CL_SIMPLE_MEMORY,\n+    OPND_CL_BIT_FIELD\n+  };\n+\n+\n+/* Base structure of all operands.  */\n+struct operand\n+{\n+  enum opnd_class cl;\n+\n+  /* OSIZE determines the size of memory access for\n+     the  operation in which the operand participates.\n+     It may be -1 which indicates either unknown\n+     (must be determined by other operands) or if\n+     it is not applicable for this operation.  */\n+  int osize;\n+};\n+\n+/* Immediate operands.  Eg: #23  */\n+struct immediate_operand\n+{\n+  struct operand parent;\n+  int value;\n+};\n+\n+/* Bitfield operands.   Used only in bfext and bfins\n+   instructions.  */\n+struct bitfield_operand\n+{\n+  struct operand parent;\n+  int width;\n+  int offset;\n+};\n+\n+/* Register operands.  */\n+struct register_operand\n+{\n+  struct operand parent;\n+  int reg;\n+};\n+\n+\n+/* Simple memory operands.  ie, direct memory,\n+   no index, no pre/post inc/dec.  May be either relative or absolute.\n+   Eg st d0, 0x123456  */\n+struct simple_memory_operand\n+{\n+  struct operand parent;\n+\n+  bfd_vma addr;\n+  bfd_vma base;\n+  bool relative;\n+};\n+\n+\n+/* Memory operands.    Should be able to represent all memory\n+   operands in the S12Z instruction set which are not simple\n+   memory operands.  */\n+struct memory_operand\n+{\n+  struct operand parent;\n+\n+  /* True for indirect operands: eg [0x123456]   */\n+  bool indirect;\n+\n+  /* The value of any offset.  eg 45 in (45,d7) */\n+    int base_offset;\n+\n+  /* Does this operand increment or decrement\n+     its participating registers.  Eg (-s) */\n+  enum op_reg_mutation mutation;\n+\n+  /* The number of registers participating in this operand.\n+     For S12Z this is always in the range [0, 6] (but for most\n+     instructions it's <= 2).  */\n+  int n_regs;\n+\n+  /* The participating registers.  */\n+  int regs[6];\n+};\n+\n+\n+/* Decode a single instruction.\n+   OPERATOR, OSIZE, N_OPERANDS and OPERANDS are pointers to\n+   variables which must be provided by the caller.\n+   N_OPERANDS will be incremented by the number of operands read, so\n+   you should assign it to something before calling this function.\n+   OPERANDS must be large enough to contain all operands read\n+   (which may be up to 6).\n+   It is the responsibility of the caller to free all operands\n+   when they are no longer needed.\n+   Returns the number of bytes read.  */\n+int decode_s12z (enum operator *myoperator, short *osize,\n+\t\t int *n_operands, struct operand **operands,\n+\t\t struct mem_read_abstraction_base *);\n+\n+\n+#endif /* S12Z_OPC_H  */"
    }
  ]
}