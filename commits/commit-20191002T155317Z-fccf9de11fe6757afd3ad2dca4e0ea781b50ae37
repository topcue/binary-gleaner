{
  "sha": "fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmNjZjlkZTExZmU2NzU3YWZkM2FkMmRjYTRlMGVhNzgxYjUwYWUzNw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-06-14T13:45:01Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-10-02T15:53:17Z"
    },
    "message": "Back out earlier Ada exception change\n\ncommit 2ff0a9473 (Fix \"catch exception\" with dynamic linking) changed\nhow ada-lang.c creates expressions to determine if an exception\ncatchpoint should stop.\n\nThat patch is no longer needed now that copy relocations are handled\nmore directly.\n\ngdb/ChangeLog\n2019-10-02  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (ada_lookup_simple_minsyms): Remove.\n\t(create_excep_cond_exprs): Simplify exception string computation.\n\t(ada_exception_catchpoint_cond_string): Likewise.",
    "tree": {
      "sha": "3ec5c9f2b6cdb9d76a90d5ea1f370491d11cbe40",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3ec5c9f2b6cdb9d76a90d5ea1f370491d11cbe40"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1d58d6a26c2a93b80f93a5d058dd678782affd5d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d58d6a26c2a93b80f93a5d058dd678782affd5d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1d58d6a26c2a93b80f93a5d058dd678782affd5d"
    }
  ],
  "stats": {
    "total": 113,
    "additions": 31,
    "deletions": 82
  },
  "files": [
    {
      "sha": "7cea3f51f4ae736a1c47cc958f36c274cec25385",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
      "patch": "@@ -1,3 +1,9 @@\n+2019-10-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (ada_lookup_simple_minsyms): Remove.\n+\t(create_excep_cond_exprs): Simplify exception string computation.\n+\t(ada_exception_catchpoint_cond_string): Likewise.\n+\n 2019-10-02  Tom Tromey  <tromey@adacore.com>\n \n \t* symmisc.c (dump_msymbols): Don't use MSYMBOL_VALUE_ADDRESS."
    },
    {
      "sha": "6e2746fe5686a4f2f1f7f8212e2493adf62c3791",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 25,
      "deletions": 82,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fccf9de11fe6757afd3ad2dca4e0ea781b50ae37/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=fccf9de11fe6757afd3ad2dca4e0ea781b50ae37",
      "patch": "@@ -4836,36 +4836,6 @@ ada_lookup_simple_minsym (const char *name)\n   return result;\n }\n \n-/* Return all the bound minimal symbols matching NAME according to Ada\n-   decoding rules.  Returns an empty vector if there is no such\n-   minimal symbol.  Names prefixed with \"standard__\" are handled\n-   specially: \"standard__\" is first stripped off, and only static and\n-   global symbols are searched.  */\n-\n-static std::vector<struct bound_minimal_symbol>\n-ada_lookup_simple_minsyms (const char *name)\n-{\n-  std::vector<struct bound_minimal_symbol> result;\n-\n-  symbol_name_match_type match_type = name_match_type_from_name (name);\n-  lookup_name_info lookup_name (name, match_type);\n-\n-  symbol_name_matcher_ftype *match_name\n-    = ada_get_symbol_name_matcher (lookup_name);\n-\n-  for (objfile *objfile : current_program_space->objfiles ())\n-    {\n-      for (minimal_symbol *msymbol : objfile->msymbols ())\n-\t{\n-\t  if (match_name (MSYMBOL_LINKAGE_NAME (msymbol), lookup_name, NULL)\n-\t      && MSYMBOL_TYPE (msymbol) != mst_solib_trampoline)\n-\t    result.push_back ({msymbol, objfile});\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n /* For all subprograms that statically enclose the subprogram of the\n    selected frame, add symbols matching identifier NAME in DOMAIN\n    and their blocks to the list of data in OBSTACKP, as for\n@@ -12355,6 +12325,8 @@ static void\n create_excep_cond_exprs (struct ada_catchpoint *c,\n                          enum ada_exception_catchpoint_kind ex)\n {\n+  struct bp_location *bl;\n+\n   /* Nothing to do if there's no specific exception to catch.  */\n   if (c->excep_string.empty ())\n     return;\n@@ -12363,45 +12335,28 @@ create_excep_cond_exprs (struct ada_catchpoint *c,\n   if (c->loc == NULL)\n     return;\n \n-  /* We have to compute the expression once for each program space,\n-     because the expression may hold the addresses of multiple symbols\n-     in some cases.  */\n-  std::multimap<program_space *, struct bp_location *> loc_map;\n-  for (bp_location *bl = c->loc; bl != NULL; bl = bl->next)\n-    loc_map.emplace (bl->pspace, bl);\n-\n-  scoped_restore_current_program_space save_pspace;\n+  /* Compute the condition expression in text form, from the specific\n+     expection we want to catch.  */\n+  std::string cond_string\n+    = ada_exception_catchpoint_cond_string (c->excep_string.c_str (), ex);\n \n-  std::string cond_string;\n-  program_space *last_ps = nullptr;\n-  for (auto iter : loc_map)\n+  /* Iterate over all the catchpoint's locations, and parse an\n+     expression for each.  */\n+  for (bl = c->loc; bl != NULL; bl = bl->next)\n     {\n       struct ada_catchpoint_location *ada_loc\n-\t= (struct ada_catchpoint_location *) iter.second;\n-\n-      if (ada_loc->pspace != last_ps)\n-\t{\n-\t  last_ps = ada_loc->pspace;\n-\t  set_current_program_space (last_ps);\n-\n-\t  /* Compute the condition expression in text form, from the\n-\t     specific expection we want to catch.  */\n-\t  cond_string\n-\t    = ada_exception_catchpoint_cond_string (c->excep_string.c_str (),\n-\t\t\t\t\t\t    ex);\n-\t}\n-\n+\t= (struct ada_catchpoint_location *) bl;\n       expression_up exp;\n \n-      if (!ada_loc->shlib_disabled)\n+      if (!bl->shlib_disabled)\n \t{\n \t  const char *s;\n \n \t  s = cond_string.c_str ();\n \t  try\n \t    {\n-\t      exp = parse_exp_1 (&s, ada_loc->address,\n-\t\t\t\t block_for_pc (ada_loc->address),\n+\t      exp = parse_exp_1 (&s, bl->address,\n+\t\t\t\t block_for_pc (bl->address),\n \t\t\t\t 0);\n \t    }\n \t  catch (const gdb_exception_error &e)\n@@ -13071,18 +13026,18 @@ ada_exception_catchpoint_cond_string (const char *excep_string,\n                                       enum ada_exception_catchpoint_kind ex)\n {\n   int i;\n+  bool is_standard_exc = false;\n   std::string result;\n-  const char *name;\n \n   if (ex == ada_catch_handlers)\n     {\n       /* For exception handlers catchpoints, the condition string does\n          not use the same parameter as for the other exceptions.  */\n-      name = (\"long_integer (GNAT_GCC_exception_Access\"\n-\t      \"(gcc_exception).all.occurrence.id)\");\n+      result = (\"long_integer (GNAT_GCC_exception_Access\"\n+\t\t\"(gcc_exception).all.occurrence.id)\");\n     }\n   else\n-    name = \"long_integer (e)\";\n+    result = \"long_integer (e)\";\n \n   /* The standard exceptions are a special case.  They are defined in\n      runtime units that have been compiled without debugging info; if\n@@ -13101,35 +13056,23 @@ ada_exception_catchpoint_cond_string (const char *excep_string,\n      If an exception named contraint_error is defined in another package of\n      the inferior program, then the only way to specify this exception as a\n      breakpoint condition is to use its fully-qualified named:\n-     e.g. my_package.constraint_error.\n-\n-     Furthermore, in some situations a standard exception's symbol may\n-     be present in more than one objfile, because the compiler may\n-     choose to emit copy relocations for them.  So, we have to compare\n-     against all the possible addresses.  */\n+     e.g. my_package.constraint_error.  */\n \n-  /* Storage for a rewritten symbol name.  */\n-  std::string std_name;\n   for (i = 0; i < sizeof (standard_exc) / sizeof (char *); i++)\n     {\n       if (strcmp (standard_exc [i], excep_string) == 0)\n \t{\n-\t  std_name = std::string (\"standard.\") + excep_string;\n-\t  excep_string = std_name.c_str ();\n+\t  is_standard_exc = true;\n \t  break;\n \t}\n     }\n \n-  excep_string = ada_encode (excep_string);\n-  std::vector<struct bound_minimal_symbol> symbols\n-    = ada_lookup_simple_minsyms (excep_string);\n-  for (const bound_minimal_symbol &msym : symbols)\n-    {\n-      if (!result.empty ())\n-\tresult += \" or \";\n-      string_appendf (result, \"%s = %s\", name,\n-\t\t      pulongest (BMSYMBOL_VALUE_ADDRESS (msym)));\n-    }\n+  result += \" = \";\n+\n+  if (is_standard_exc)\n+    string_appendf (result, \"long_integer (&standard.%s)\", excep_string);\n+  else\n+    string_appendf (result, \"long_integer (&%s)\", excep_string);\n \n   return result;\n }"
    }
  ]
}