{
  "sha": "9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWE0OWRmOWQ0YmZjN2ZmMDNmZWQ3NTFlMTJiMWJjMzJmYmVlNGZiMg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-05-08T12:16:03Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-07-12T11:09:54Z"
    },
    "message": "gdb: Carry default property type around with dynamic properties\n\nThis commit is preparation for the next one, with the aim of better\nsupporting signed dynamic properties on targets where the address size\nspecified in the DWARF headers is smaller than a CORE_ADDR, for\nexample debugging an i386 application on x86-64.\n\nConsider this small Fortran program 'bounds.f90':\n\n    program test\n      integer, allocatable :: array (:)\n      allocate (array (-5:5))\n      array(3) = 1\n    end program test\n\nCompiled with 'gfortran -m32 -g3 -O0 -o bounds bounds.f90'.  The DWARF\nfor 'array' looks like this:\n\n   <2><97>: Abbrev Number: 10 (DW_TAG_variable)\n      <98>   DW_AT_name        : (indirect string, offset: 0x0): array\n      <9c>   DW_AT_decl_file   : 1\n      <9d>   DW_AT_decl_line   : 2\n      <9e>   DW_AT_type        : <0xaf>\n      <a2>   DW_AT_location    : 2 byte block: 91 58              (DW_OP_fbreg: -40)\n   <2><a5>: Abbrev Number: 11 (DW_TAG_lexical_block)\n      <a6>   DW_AT_low_pc      : 0x80485c3\n      <aa>   DW_AT_high_pc     : 0x8b\n   <2><ae>: Abbrev Number: 0\n   <1><af>: Abbrev Number: 12 (DW_TAG_array_type)\n      <b0>   DW_AT_data_location: 2 byte block: 97 6              (DW_OP_push_object_address; DW_OP_deref)\n      <b3>   DW_AT_allocated   : 4 byte block: 97 6 30 2e         (DW_OP_push_object_address; DW_OP_deref; DW_OP_lit0; DW_OP_ne)\n      <b8>   DW_AT_type        : <0x2a>\n   <2><bc>: Abbrev Number: 13 (DW_TAG_subrange_type)\n      <bd>   DW_AT_lower_bound : 4 byte block: 97 23 10 6         (DW_OP_push_object_address; DW_OP_plus_uconst: 16; DW_OP_deref)\n      <c2>   DW_AT_upper_bound : 4 byte block: 97 23 14 6         (DW_OP_push_object_address; DW_OP_plus_uconst: 20; DW_OP_deref)\n      <c7>   DW_AT_byte_stride : 6 byte block: 97 23 c 6 34 1e    (DW_OP_push_object_address; DW_OP_plus_uconst: 12; DW_OP_deref; DW_OP_lit4; DW_OP_mul)\n   <2><ce>: Abbrev Number: 0\n\nIf we look at the DW_AT_lower_bound attribute, which will become a\ndynamic property that GDB evaluates when needed by calling\ndwarf2_evaluate_property.\n\nThe process of evaluating a dynamic property requires GDB to execute\neach DW_OP_* operation, the results of these operations is held on a\nstack of 'struct value *'s.\n\nWhen the entire expression is evaluated the result is on top of the\nstack.\n\nIf we look at DW_AT_lower_bound then the last operation is\nDW_OP_deref, this loads a signed address the size of which matches the\nDWARF address size, and so in our i386 on x86-64 situation, the top of\nthe stack will be a signed 4-byte value.\n\nThe problem is how these values are fetched from the stack.  Currently\nthey are always fetched by a call to dwarf_expr_context::fetch_address,\nwhich converts the value to an unsigned value with a length matching\nthe values current length, before converting to a CORE_ADDR.  This\nmeans we loose the signed nature of the property.\n\nI wonder if the best solution for dealing with signed properties will\nbe to move away from an over reliance on fetch_address, and instead\ncome up with a new solution that considers the current type of the\nvalue on the stack, and the type that the value needs to become;\nbasically a solution built around casting rather than assuming we\nalways want an address.\n\nHowever, before we can start to even think about moving away from\nfetch_address, there is a more urgent issue to fix, which is we don't\ncurrently know what type each property should be.  We just hold the\nvalue of the property in a CORE_ADDR as returned by fetch_address, and\nrely on higher level code (outside of the DWARF expression evaluation\ncode) to fix things up for us.  This is what this patch aims to\naddress.\n\nWhen creating a dynamic property (see attr_to_dynamic_prop in\ndwarf2read.c) we can sometimes figure out the type of a property; if\nthe property is a reference to another DIE then it will have a\nDW_AT_type attribute.\n\nHowever, the DW_AT_lower_bound case above isn't a reference to another\nDIE, it's just a DWARF expression.  We don't have any indication for\nwhat type the property should have.\n\nLuckily, the DWARF spec helps us out, for the lower and upper bounds\n5.13 of the DWARFv5 spec tells us that without any other type\ninformation the bounds are signed integers the same size as a DWARF\naddress.\n\nIt is my belief that we can find a suitable default type for every\ndynamic property, either specified explicitly in the DWARF spec, or we\ncan infer an obvious choice if the spec doesn't help us.\n\nThis commit extends the creation of all dynamic properties to include\nsuggesting a suitable default type, all dynamic properties now always\ncarry their type around with them.\n\nIn later commits we can use this property type to ensure that the\nvalue we extract from the DWARF stack is handled in a suitable manor\nto correctly maintain its sign extension.\n\nThere should be no user visible changes from this commit.  The actual\nfix to correctly support negative array bounds will come later.\n\ngdb/ChangeLog:\n\n\t* dwarf2loc.c (dwarf2_evaluate_property): Update to take account\n\tof changes to field names, and use new is_reference field to\n\tdecide if a property is a reference or not.\n\t* dwarf2loc.h (struct dwarf2_locexpr_baton): Add 'is_reference'\n\tfield.\n\t(struct dwarf2_property_baton): Update header comment, rename\n\t'referenced_type' to 'property_type' and update comments.\n\t* dwarf2read.c (attr_to_dynamic_prop): Add extra parameter to hold\n\tdefault property type, store in property baton, update to take\n\taccound of renamed field.\n\t(read_func_scope): Update call to attr_to_dynamic_prop.\n\t(read_array_type): Likewise.\n\t(dwarf2_per_cu_addr_sized_int_type): New function.\n\t(read_subrange_index_type): Move type finding code to\n\tdwarf2_per_cu_addr_sized_int_type.\n\t(read_subrange_type): Update calls to attr_to_dynamic_prop.\n\t(dwarf2_per_cu_addr_type): New function.\n\t(set_die_type): Update calls to attr_to_dynamic_prop.",
    "tree": {
      "sha": "8cc573908053c52a291263c54c6a214541b2ab1c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8cc573908053c52a291263c54c6a214541b2ab1c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 125,
    "deletions": 50
  },
  "files": [
    {
      "sha": "d2dec796a804aa31b04806d5b5bef9980f049a44",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
      "patch": "@@ -1,3 +1,24 @@\n+2019-07-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* dwarf2loc.c (dwarf2_evaluate_property): Update to take account\n+\tof changes to field names, and use new is_reference field to\n+\tdecide if a property is a reference or not.\n+\t* dwarf2loc.h (struct dwarf2_locexpr_baton): Add 'is_reference'\n+\tfield.\n+\t(struct dwarf2_property_baton): Update header comment, rename\n+\t'referenced_type' to 'property_type' and update comments.\n+\t* dwarf2read.c (attr_to_dynamic_prop): Add extra parameter to hold\n+\tdefault property type, store in property baton, update to take\n+\taccound of renamed field.\n+\t(read_func_scope): Update call to attr_to_dynamic_prop.\n+\t(read_array_type): Likewise.\n+\t(dwarf2_per_cu_addr_sized_int_type): New function.\n+\t(read_subrange_index_type): Move type finding code to\n+\tdwarf2_per_cu_addr_sized_int_type.\n+\t(read_subrange_type): Update calls to attr_to_dynamic_prop.\n+\t(dwarf2_per_cu_addr_type): New function.\n+\t(set_die_type): Update calls to attr_to_dynamic_prop.\n+\n 2019-07-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* dwarf2read.c (read_subrange_index_type): New function."
    },
    {
      "sha": "00f3d76bdbe7bfa19e8202e619041625c9b11f86",
      "filename": "gdb/dwarf2loc.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2loc.c?ref=9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
      "patch": "@@ -2443,15 +2443,15 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n       {\n \tconst struct dwarf2_property_baton *baton\n \t  = (const struct dwarf2_property_baton *) prop->data.baton;\n+\tgdb_assert (baton->property_type != NULL);\n \n \tif (dwarf2_locexpr_baton_eval (&baton->locexpr, frame,\n \t\t\t\t       addr_stack ? addr_stack->addr : 0,\n \t\t\t\t       value))\n \t  {\n-\t    if (baton->referenced_type)\n+\t    if (baton->locexpr.is_reference)\n \t      {\n-\t\tstruct value *val = value_at (baton->referenced_type, *value);\n-\n+\t\tstruct value *val = value_at (baton->property_type, *value);\n \t\t*value = value_as_address (val);\n \t      }\n \t    return true;\n@@ -2471,7 +2471,7 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n \tdata = dwarf2_find_location_expression (&baton->loclist, &size, pc);\n \tif (data != NULL)\n \t  {\n-\t    val = dwarf2_evaluate_loc_desc (baton->referenced_type, frame, data,\n+\t    val = dwarf2_evaluate_loc_desc (baton->property_type, frame, data,\n \t\t\t\t\t    size, baton->loclist.per_cu);\n \t    if (!value_optimized_out (val))\n \t      {\n@@ -2497,7 +2497,7 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n \t  {\n \t    /* This approach lets us avoid checking the qualifiers.  */\n \t    if (TYPE_MAIN_TYPE (pinfo->type)\n-\t\t== TYPE_MAIN_TYPE (baton->referenced_type))\n+\t\t== TYPE_MAIN_TYPE (baton->property_type))\n \t      break;\n \t  }\n \tif (pinfo == NULL)"
    },
    {
      "sha": "baa5762003d0d75af921ee7c1a7d3908b5f6b5c9",
      "filename": "gdb/dwarf2loc.h",
      "status": "modified",
      "additions": 17,
      "deletions": 7,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2loc.h?ref=9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
      "patch": "@@ -183,6 +183,12 @@ struct dwarf2_locexpr_baton\n      zero.  */\n   size_t size;\n \n+  /* When true this location expression is a reference and actually\n+     describes the address at which the value of the attribute can be\n+     found.  When false the expression provides the value of the attribute\n+     directly.  */\n+  bool is_reference;\n+\n   /* The compilation unit containing the symbol whose location\n      we're computing.  */\n   struct dwarf2_per_cu_data *per_cu;\n@@ -228,23 +234,27 @@ struct dwarf2_offset_baton\n \n /* A dynamic property is either expressed as a single location expression\n    or a location list.  If the property is an indirection, pointing to\n-   another die, keep track of the targeted type in REFERENCED_TYPE.  */\n+   another die, keep track of the targeted type in PROPERTY_TYPE.\n+   Alternatively, if the property location gives the property value\n+   directly then it will have PROPERTY_TYPE.  */\n \n struct dwarf2_property_baton\n {\n   /* If the property is an indirection, we need to evaluate the location\n-     in the context of the type REFERENCED_TYPE.\n-     If NULL, the location is the actual value of the property.  */\n-  struct type *referenced_type;\n+     in the context of the type PROPERTY_TYPE.  If the property is supplied\n+     by value then it will be of PROPERTY_TYPE.  This field should never be\n+     NULL.  */\n+  struct type *property_type;\n   union\n   {\n-    /* Location expression.  */\n+    /* Location expression either evaluated in the context of\n+       PROPERTY_TYPE, or a value of type PROPERTY_TYPE.  */\n     struct dwarf2_locexpr_baton locexpr;\n \n-    /* Location list to be evaluated in the context of REFERENCED_TYPE.  */\n+    /* Location list to be evaluated in the context of PROPERTY_TYPE.  */\n     struct dwarf2_loclist_baton loclist;\n \n-    /* The location is an offset to REFERENCED_TYPE.  */\n+    /* The location is an offset to PROPERTY_TYPE.  */\n     struct dwarf2_offset_baton offset_info;\n   };\n };"
    },
    {
      "sha": "3d90d6328917f039778f0cf4175fb35b21cda04d",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 82,
      "deletions": 38,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=9a49df9d4bfc7ff03fed751e12b1bc32fbee4fb2",
      "patch": "@@ -1810,7 +1810,7 @@ static void read_signatured_type (struct signatured_type *);\n \n static int attr_to_dynamic_prop (const struct attribute *attr,\n \t\t\t\t struct die_info *die, struct dwarf2_cu *cu,\n-\t\t\t\t struct dynamic_prop *prop);\n+\t\t\t\t struct dynamic_prop *prop, struct type *type);\n \n /* memory allocation interface */\n \n@@ -1890,6 +1890,10 @@ static void queue_comp_unit (struct dwarf2_per_cu_data *per_cu,\n \n static void process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile);\n \n+static struct type *dwarf2_per_cu_addr_type (struct dwarf2_per_cu_data *per_cu);\n+static struct type *dwarf2_per_cu_addr_sized_int_type\n+\t(struct dwarf2_per_cu_data *per_cu, bool unsigned_p);\n+\n /* Class, the destructor of which frees all allocated queue entries.  This\n    will only have work to do if an error was thrown while processing the\n    dwarf.  If no error was thrown then the queue entries should have all\n@@ -13683,7 +13687,8 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       newobj->static_link\n \t= XOBNEW (&objfile->objfile_obstack, struct dynamic_prop);\n-      attr_to_dynamic_prop (attr, die, cu, newobj->static_link);\n+      attr_to_dynamic_prop (attr, die, cu, newobj->static_link,\n+\t\t\t    dwarf2_per_cu_addr_type (cu->per_cu));\n     }\n \n   cu->list_in_scope = cu->get_builder ()->get_local_symbols ();\n@@ -16439,10 +16444,13 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (attr != NULL)\n     {\n       int stride_ok;\n+      struct type *prop_type\n+\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n \n       byte_stride_prop\n \t= (struct dynamic_prop *) alloca (sizeof (struct dynamic_prop));\n-      stride_ok = attr_to_dynamic_prop (attr, die, cu, byte_stride_prop);\n+      stride_ok = attr_to_dynamic_prop (attr, die, cu, byte_stride_prop,\n+\t\t\t\t\tprop_type);\n       if (!stride_ok)\n \t{\n \t  complaint (_(\"unable to read array DW_AT_byte_stride \"\n@@ -17654,22 +17662,26 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \n static int\n attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n-\t\t      struct dwarf2_cu *cu, struct dynamic_prop *prop)\n+\t\t      struct dwarf2_cu *cu, struct dynamic_prop *prop,\n+\t\t      struct type *default_type)\n {\n   struct dwarf2_property_baton *baton;\n   struct obstack *obstack\n     = &cu->per_cu->dwarf2_per_objfile->objfile->objfile_obstack;\n \n+  gdb_assert (default_type != NULL);\n+\n   if (attr == NULL || prop == NULL)\n     return 0;\n \n   if (attr_form_is_block (attr))\n     {\n       baton = XOBNEW (obstack, struct dwarf2_property_baton);\n-      baton->referenced_type = NULL;\n+      baton->property_type = default_type;\n       baton->locexpr.per_cu = cu->per_cu;\n       baton->locexpr.size = DW_BLOCK (attr)->size;\n       baton->locexpr.data = DW_BLOCK (attr)->data;\n+      baton->locexpr.is_reference = false;\n       prop->data.baton = baton;\n       prop->kind = PROP_LOCEXPR;\n       gdb_assert (prop->data.baton != NULL);\n@@ -17694,7 +17706,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t    if (attr_form_is_section_offset (target_attr))\n \t      {\n \t\tbaton = XOBNEW (obstack, struct dwarf2_property_baton);\n-\t\tbaton->referenced_type = die_type (target_die, target_cu);\n+\t\tbaton->property_type = die_type (target_die, target_cu);\n \t\tfill_in_loclist_baton (cu, &baton->loclist, target_attr);\n \t\tprop->data.baton = baton;\n \t\tprop->kind = PROP_LOCLIST;\n@@ -17703,10 +17715,11 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t    else if (attr_form_is_block (target_attr))\n \t      {\n \t\tbaton = XOBNEW (obstack, struct dwarf2_property_baton);\n-\t\tbaton->referenced_type = die_type (target_die, target_cu);\n+\t\tbaton->property_type = die_type (target_die, target_cu);\n \t\tbaton->locexpr.per_cu = cu->per_cu;\n \t\tbaton->locexpr.size = DW_BLOCK (target_attr)->size;\n \t\tbaton->locexpr.data = DW_BLOCK (target_attr)->data;\n+\t\tbaton->locexpr.is_reference = true;\n \t\tprop->data.baton = baton;\n \t\tprop->kind = PROP_LOCEXPR;\n \t\tgdb_assert (prop->data.baton != NULL);\n@@ -17727,7 +17740,7 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n \t\treturn 0;\n \n \t      baton = XOBNEW (obstack, struct dwarf2_property_baton);\n-\t      baton->referenced_type = read_type_die (target_die->parent,\n+\t      baton->property_type = read_type_die (target_die->parent,\n \t\t\t\t\t\t      target_cu);\n \t      baton->offset_info.offset = offset;\n \t      baton->offset_info.type = die_type (target_die, target_cu);\n@@ -17752,6 +17765,37 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n   return 1;\n }\n \n+/* Find an integer type the same size as the address size given in the\n+   compilation unit header for PER_CU.  UNSIGNED_P controls if the integer\n+   is unsigned or not.  */\n+\n+static struct type *\n+dwarf2_per_cu_addr_sized_int_type (struct dwarf2_per_cu_data *per_cu,\n+\t\t\t\t   bool unsigned_p)\n+{\n+  struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n+  int addr_size = dwarf2_per_cu_addr_size (per_cu);\n+  struct type *int_type;\n+\n+  /* Helper macro to examine the various builtin types.  */\n+#define TRY_TYPE(F)\t\t\t\t\t\t\\\n+  int_type = (unsigned_p\t\t\t\t\t\\\n+\t      ? objfile_type (objfile)->builtin_unsigned_ ## F\t\\\n+\t      : objfile_type (objfile)->builtin_ ## F);\t\t\\\n+  if (int_type != NULL && TYPE_LENGTH (int_type) == addr_size)\t\\\n+    return int_type\n+\n+  TRY_TYPE (char);\n+  TRY_TYPE (short);\n+  TRY_TYPE (int);\n+  TRY_TYPE (long);\n+  TRY_TYPE (long_long);\n+\n+#undef TRY_TYPE\n+\n+  gdb_assert_not_reached (\"unable to find suitable integer type\");\n+}\n+\n /* Read the DW_AT_type attribute for a sub-range.  If this attribute is not\n    present (which is valid) then compute the default type based on the\n    compilation units address size.  */\n@@ -17774,30 +17818,7 @@ read_subrange_index_type (struct die_info *die, struct dwarf2_cu *cu)\n      FIXME: muller/2010-05-28: Possible references to object for low bound,\n      high bound or count are not yet handled by this code.  */\n   if (TYPE_CODE (index_type) == TYPE_CODE_VOID)\n-    {\n-      struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n-      struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-      int addr_size = gdbarch_addr_bit (gdbarch) /8;\n-      struct type *int_type = objfile_type (objfile)->builtin_int;\n-\n-      /* Test \"int\", \"long int\", and \"long long int\" objfile types,\n-\t and select the first one having a size above or equal to the\n-\t architecture address size.  */\n-      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\tindex_type = int_type;\n-      else\n-\t{\n-\t  int_type = objfile_type (objfile)->builtin_long;\n-\t  if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\t    index_type = int_type;\n-\t  else\n-\t    {\n-\t      int_type = objfile_type (objfile)->builtin_long_long;\n-\t      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\t\tindex_type = int_type;\n-\t    }\n-\t}\n-    }\n+    index_type = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n \n   return index_type;\n }\n@@ -17866,7 +17887,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   attr = dwarf2_attr (die, DW_AT_lower_bound, cu);\n   if (attr)\n-    attr_to_dynamic_prop (attr, die, cu, &low);\n+    attr_to_dynamic_prop (attr, die, cu, &low, base_type);\n   else if (!low_default_is_valid)\n     complaint (_(\"Missing DW_AT_lower_bound \"\n \t\t\t\t      \"- DIE at %s [in module %s]\"),\n@@ -17875,10 +17896,10 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   struct attribute *attr_ub, *attr_count;\n   attr = attr_ub = dwarf2_attr (die, DW_AT_upper_bound, cu);\n-  if (!attr_to_dynamic_prop (attr, die, cu, &high))\n+  if (!attr_to_dynamic_prop (attr, die, cu, &high, base_type))\n     {\n       attr = attr_count = dwarf2_attr (die, DW_AT_count, cu);\n-      if (attr_to_dynamic_prop (attr, die, cu, &high))\n+      if (attr_to_dynamic_prop (attr, die, cu, &high, base_type))\n \t{\n \t  /* If bounds are constant do the final calculation here.  */\n \t  if (low.kind == PROP_CONST && high.kind == PROP_CONST)\n@@ -25241,6 +25262,24 @@ dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *per_cu)\n   return ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n }\n \n+/* Return a type that is a generic pointer type, the size of which matches\n+   the address size given in the compilation unit header for PER_CU.  */\n+static struct type *\n+dwarf2_per_cu_addr_type (struct dwarf2_per_cu_data *per_cu)\n+{\n+  struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n+  struct type *void_type = objfile_type (objfile)->builtin_void;\n+  struct type *addr_type = lookup_pointer_type (void_type);\n+  int addr_size = dwarf2_per_cu_addr_size (per_cu);\n+\n+  if (TYPE_LENGTH (addr_type) == addr_size)\n+    return addr_type;\n+\n+  addr_type\n+    = dwarf2_per_cu_addr_sized_int_type (per_cu, TYPE_UNSIGNED (addr_type));\n+  return addr_type;\n+}\n+\n /* Return DWARF version number of PER_CU.  */\n \n short\n@@ -25507,7 +25546,9 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_allocated, cu);\n   if (attr_form_is_block (attr))\n     {\n-      if (attr_to_dynamic_prop (attr, die, cu, &prop))\n+      struct type *prop_type\n+\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         add_dyn_prop (DYN_PROP_ALLOCATED, prop, type);\n     }\n   else if (attr != NULL)\n@@ -25521,7 +25562,9 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_associated, cu);\n   if (attr_form_is_block (attr))\n     {\n-      if (attr_to_dynamic_prop (attr, die, cu, &prop))\n+      struct type *prop_type\n+\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         add_dyn_prop (DYN_PROP_ASSOCIATED, prop, type);\n     }\n   else if (attr != NULL)\n@@ -25533,7 +25576,8 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n \n   /* Read DW_AT_data_location and set in type.  */\n   attr = dwarf2_attr (die, DW_AT_data_location, cu);\n-  if (attr_to_dynamic_prop (attr, die, cu, &prop))\n+  if (attr_to_dynamic_prop (attr, die, cu, &prop,\n+\t\t\t    dwarf2_per_cu_addr_type (cu->per_cu)))\n     add_dyn_prop (DYN_PROP_DATA_LOCATION, prop, type);\n \n   if (dwarf2_per_objfile->die_type_hash == NULL)"
    }
  ]
}