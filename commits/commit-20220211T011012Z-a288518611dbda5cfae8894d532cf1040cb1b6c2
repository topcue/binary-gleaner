{
  "sha": "a288518611dbda5cfae8894d532cf1040cb1b6c2",
  "node_id": "C_kwDOANOeidoAKGEyODg1MTg2MTFkYmRhNWNmYWU4ODk0ZDUzMmNmMTA0MGNiMWI2YzI",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-01-16T04:25:59Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-02-11T01:10:12Z"
    },
    "message": "gdb/linux: remove ptrace support check for exec, fork, vfork, vforkdone, clone, sysgood\n\nI think it's safe to remove checking support for these ptrace features,\nthey have all been added in what is now ancient times (around the\nbeginning of Linux 2.6).  This allows removing a bit of complexity in\nlinux-nat.c and nat/linux-ptrace.c.\n\nIt also allows saving one extra fork every time we start debugging on\nLinux: linux_check_ptrace_features forks a child process to test if some\nptrace features are supported.  That child process forks a grand-child,\nto test whether ptrace reports an event for the fork by the child.  This\nis no longer needed, if we assume the kernel supports reporting forks.\n\nPTRACE_O_TRACEVFORKDONE was introduced in Linux in this change, in 2003:\n\n  https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=45c1a159b85b3b30afd26a77b4be312226bba416\n\nPTRACE_O_TRACESYSGOOD was supported at least as of this change, in 2002:\n\n  https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=acc7088569c8eef04eeed0eff51d23bb5bcff964\n\nPTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, PTRACE_O_TRACEEXEC and\nPTRACE_O_TRACECLONE were introduced in this change, in 2002:\n\n  https://git.kernel.org/pub/scm/linux/kernel/git/tglx/history.git/commit/?id=a0691b116f6a4473f0fa264210ab9b95771a2b46\n\nChange-Id: Iffb906549a89cc6b619427f976ec044706ab1e8d",
    "tree": {
      "sha": "8a08bcc229f42cc2f6e64f2045d5225dcaabb06b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8a08bcc229f42cc2f6e64f2045d5225dcaabb06b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a288518611dbda5cfae8894d532cf1040cb1b6c2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a288518611dbda5cfae8894d532cf1040cb1b6c2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a288518611dbda5cfae8894d532cf1040cb1b6c2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a288518611dbda5cfae8894d532cf1040cb1b6c2/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a9dce16586c147c024b49604aa0603d772372f31",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9dce16586c147c024b49604aa0603d772372f31",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a9dce16586c147c024b49604aa0603d772372f31"
    }
  ],
  "stats": {
    "total": 277,
    "additions": 21,
    "deletions": 256
  },
  "files": [
    {
      "sha": "936250c6ef820f370faa707a0599e47221768563",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 69,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=a288518611dbda5cfae8894d532cf1040cb1b6c2",
      "patch": "@@ -535,70 +535,12 @@ linux_nat_target::follow_fork (inferior *child_inf, ptid_t child_ptid,\n \n       if (has_vforked)\n \t{\n-\t  struct lwp_info *parent_lp;\n+\t  lwp_info *parent_lp = find_lwp_pid (parent_ptid);\n+\t  linux_nat_debug_printf (\"waiting for VFORK_DONE on %d\", parent_pid);\n+\t  parent_lp->stopped = 1;\n \n-\t  parent_lp = find_lwp_pid (parent_ptid);\n-\t  gdb_assert (linux_supports_tracefork () >= 0);\n-\n-\t  if (linux_supports_tracevforkdone ())\n-\t    {\n-\t      linux_nat_debug_printf (\"waiting for VFORK_DONE on %d\",\n-\t\t\t\t      parent_pid);\n-\t      parent_lp->stopped = 1;\n-\n-\t      /* We'll handle the VFORK_DONE event like any other\n-\t\t event, in target_wait.  */\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We can't insert breakpoints until the child has\n-\t\t finished with the shared memory region.  We need to\n-\t\t wait until that happens.  Ideal would be to just\n-\t\t call:\n-\t\t - ptrace (PTRACE_SYSCALL, parent_pid, 0, 0);\n-\t\t - waitpid (parent_pid, &status, __WALL);\n-\t\t However, most architectures can't handle a syscall\n-\t\t being traced on the way out if it wasn't traced on\n-\t\t the way in.\n-\n-\t\t We might also think to loop, continuing the child\n-\t\t until it exits or gets a SIGTRAP.  One problem is\n-\t\t that the child might call ptrace with PTRACE_TRACEME.\n-\n-\t\t There's no simple and reliable way to figure out when\n-\t\t the vforked child will be done with its copy of the\n-\t\t shared memory.  We could step it out of the syscall,\n-\t\t two instructions, let it go, and then single-step the\n-\t\t parent once.  When we have hardware single-step, this\n-\t\t would work; with software single-step it could still\n-\t\t be made to work but we'd have to be able to insert\n-\t\t single-step breakpoints in the child, and we'd have\n-\t\t to insert -just- the single-step breakpoint in the\n-\t\t parent.  Very awkward.\n-\n-\t\t In the end, the best we can do is to make sure it\n-\t\t runs for a little while.  Hopefully it will be out of\n-\t\t range of any breakpoints we reinsert.  Usually this\n-\t\t is only the single-step breakpoint at vfork's return\n-\t\t point.  */\n-\n-\t      linux_nat_debug_printf (\"no VFORK_DONE support, sleeping a bit\");\n-\n-\t      usleep (10000);\n-\n-\t      /* Pretend we've seen a PTRACE_EVENT_VFORK_DONE event,\n-\t\t and leave it pending.  The next linux_nat_resume call\n-\t\t will notice a pending event, and bypasses actually\n-\t\t resuming the inferior.  */\n-\t      parent_lp->status = 0;\n-\t      parent_lp->waitstatus.set_vfork_done ();\n-\t      parent_lp->stopped = 1;\n-\n-\t      /* If we're in async mode, need to tell the event loop\n-\t\t there's something here to process.  */\n-\t      if (target_is_async_p ())\n-\t\tasync_file_mark ();\n-\t    }\n+\t  /* We'll handle the VFORK_DONE event like any other\n+\t     event, in target_wait.  */\n \t}\n     }\n   else\n@@ -615,7 +557,7 @@ linux_nat_target::follow_fork (inferior *child_inf, ptid_t child_ptid,\n int\n linux_nat_target::insert_fork_catchpoint (int pid)\n {\n-  return !linux_supports_tracefork ();\n+  return 0;\n }\n \n int\n@@ -627,7 +569,7 @@ linux_nat_target::remove_fork_catchpoint (int pid)\n int\n linux_nat_target::insert_vfork_catchpoint (int pid)\n {\n-  return !linux_supports_tracefork ();\n+  return 0;\n }\n \n int\n@@ -639,7 +581,7 @@ linux_nat_target::remove_vfork_catchpoint (int pid)\n int\n linux_nat_target::insert_exec_catchpoint (int pid)\n {\n-  return !linux_supports_tracefork ();\n+  return 0;\n }\n \n int\n@@ -652,9 +594,6 @@ int\n linux_nat_target::set_syscall_catchpoint (int pid, bool needed, int any_count,\n \t\t\t\t\t  gdb::array_view<const int> syscall_counts)\n {\n-  if (!linux_supports_tracesysgood ())\n-    return 1;\n-\n   /* On GNU/Linux, we ignore the arguments.  It means that we only\n      enable the syscall catchpoints, but do not disable them.\n "
    },
    {
      "sha": "5b3086e76a6ce34efb316bbe9a6e357e01301bfa",
      "filename": "gdb/nat/linux-ptrace.c",
      "status": "modified",
      "additions": 9,
      "deletions": 177,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/nat/linux-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/nat/linux-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-ptrace.c?ref=a288518611dbda5cfae8894d532cf1040cb1b6c2",
      "patch": "@@ -300,20 +300,6 @@ linux_fork_to_function (gdb_byte *child_stack, int (*function) (void *))\n   return child_pid;\n }\n \n-/* A helper function for linux_check_ptrace_features, called after\n-   the child forks a grandchild.  */\n-\n-static int\n-linux_grandchild_function (void *child_stack)\n-{\n-  /* Free any allocated stack.  */\n-  xfree (child_stack);\n-\n-  /* This code is only reacheable by the grandchild (child's child)\n-     process.  */\n-  _exit (0);\n-}\n-\n /* A helper function for linux_check_ptrace_features, called after\n    the parent process forks a child.  The child allows itself to\n    be traced by its parent.  */\n@@ -324,16 +310,11 @@ linux_child_function (void *child_stack)\n   ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);\n   kill (getpid (), SIGSTOP);\n \n-  /* Fork a grandchild.  */\n-  linux_fork_to_function ((gdb_byte *) child_stack, linux_grandchild_function);\n-\n   /* This code is only reacheable by the child (grandchild's parent)\n      process.  */\n   _exit (0);\n }\n \n-static void linux_test_for_tracesysgood (int child_pid);\n-static void linux_test_for_tracefork (int child_pid);\n static void linux_test_for_exitkill (int child_pid);\n \n /* Determine ptrace features available on this target.  */\n@@ -343,8 +324,15 @@ linux_check_ptrace_features (void)\n {\n   int child_pid, ret, status;\n \n-  /* Initialize the options.  */\n-  supported_ptrace_options = 0;\n+  /* Initialize the options.  We consider that these options are always\n+     supported.  */\n+  supported_ptrace_options\n+    = (PTRACE_O_TRACESYSGOOD\n+       | PTRACE_O_TRACECLONE\n+       | PTRACE_O_TRACEFORK\n+       | PTRACE_O_TRACEVFORK\n+       | PTRACE_O_TRACEVFORKDONE\n+       | PTRACE_O_TRACEEXEC);\n \n   /* Fork a child so we can do some testing.  The child will call\n      linux_child_function and will get traced.  The child will\n@@ -362,104 +350,12 @@ linux_check_ptrace_features (void)\n     error (_(\"linux_check_ptrace_features: waitpid: unexpected status %d.\"),\n \t   status);\n \n-  linux_test_for_tracesysgood (child_pid);\n-\n-  linux_test_for_tracefork (child_pid);\n-\n   linux_test_for_exitkill (child_pid);\n \n   /* Kill child_pid.  */\n   kill_child (child_pid, \"linux_check_ptrace_features\");\n }\n \n-/* Determine if PTRACE_O_TRACESYSGOOD can be used to catch\n-   syscalls.  */\n-\n-static void\n-linux_test_for_tracesysgood (int child_pid)\n-{\n-  int ret;\n-\n-  ret = ptrace (PTRACE_SETOPTIONS, child_pid, (PTRACE_TYPE_ARG3) 0,\n-\t\t(PTRACE_TYPE_ARG4) PTRACE_O_TRACESYSGOOD);\n-\n-  if (ret == 0)\n-    supported_ptrace_options |= PTRACE_O_TRACESYSGOOD;\n-}\n-\n-/* Determine if PTRACE_O_TRACEFORK can be used to follow fork\n-   events.  */\n-\n-static void\n-linux_test_for_tracefork (int child_pid)\n-{\n-  int ret, status;\n-  long second_pid;\n-\n-  /* First, set the PTRACE_O_TRACEFORK option.  If this fails, we\n-     know for sure that it is not supported.  */\n-  ret = ptrace (PTRACE_SETOPTIONS, child_pid, (PTRACE_TYPE_ARG3) 0,\n-\t\t(PTRACE_TYPE_ARG4) PTRACE_O_TRACEFORK);\n-\n-  if (ret != 0)\n-    return;\n-\n-  /* Check if the target supports PTRACE_O_TRACEVFORKDONE.  */\n-  ret = ptrace (PTRACE_SETOPTIONS, child_pid, (PTRACE_TYPE_ARG3) 0,\n-\t\t(PTRACE_TYPE_ARG4) (PTRACE_O_TRACEFORK\n-\t\t\t\t    | PTRACE_O_TRACEVFORKDONE));\n-  if (ret == 0)\n-    supported_ptrace_options |= PTRACE_O_TRACEVFORKDONE;\n-\n-  /* Setting PTRACE_O_TRACEFORK did not cause an error, however we\n-     don't know for sure that the feature is available; old\n-     versions of PTRACE_SETOPTIONS ignored unknown options.\n-     Therefore, we attach to the child process, use PTRACE_SETOPTIONS\n-     to enable fork tracing, and let it fork.  If the process exits,\n-     we assume that we can't use PTRACE_O_TRACEFORK; if we get the\n-     fork notification, and we can extract the new child's PID, then\n-     we assume that we can.\n-\n-     We do not explicitly check for vfork tracing here.  It is\n-     assumed that vfork tracing is available whenever fork tracing\n-     is available.  */\n-  ret = ptrace (PTRACE_CONT, child_pid, (PTRACE_TYPE_ARG3) 0,\n-\t\t(PTRACE_TYPE_ARG4) 0);\n-  if (ret != 0)\n-    warning (_(\"linux_test_for_tracefork: failed to resume child\"));\n-\n-  ret = my_waitpid (child_pid, &status, 0);\n-\n-  /* Check if we received a fork event notification.  */\n-  if (ret == child_pid && WIFSTOPPED (status)\n-      && linux_ptrace_get_extended_event (status) == PTRACE_EVENT_FORK)\n-    {\n-      /* We did receive a fork event notification.  Make sure its PID\n-\t is reported.  */\n-      second_pid = 0;\n-      ret = ptrace (PTRACE_GETEVENTMSG, child_pid, (PTRACE_TYPE_ARG3) 0,\n-\t\t    (PTRACE_TYPE_ARG4) &second_pid);\n-      if (ret == 0 && second_pid != 0)\n-\t{\n-\t  int second_status;\n-\n-\t  /* We got the PID from the grandchild, which means fork\n-\t     tracing is supported.  */\n-\t  supported_ptrace_options |= PTRACE_O_TRACECLONE;\n-\t  supported_ptrace_options |= (PTRACE_O_TRACEFORK\n-\t\t\t\t       | PTRACE_O_TRACEVFORK\n-\t\t\t\t       | PTRACE_O_TRACEEXEC);\n-\n-\t  /* Do some cleanup and kill the grandchild.  */\n-\t  my_waitpid (second_pid, &second_status, 0);\n-\t  kill_child (second_pid, \"linux_test_for_tracefork\");\n-\t}\n-    }\n-  else\n-    warning (_(\"linux_test_for_tracefork: unexpected result from waitpid \"\n-\t     \"(%d, status 0x%x)\"), ret, status);\n-}\n-\n /* Determine if PTRACE_O_EXITKILL can be used.  */\n \n static void\n@@ -507,70 +403,6 @@ linux_disable_event_reporting (pid_t pid)\n   ptrace (PTRACE_SETOPTIONS, pid, (PTRACE_TYPE_ARG3) 0, 0);\n }\n \n-/* Returns non-zero if PTRACE_OPTIONS is contained within\n-   SUPPORTED_PTRACE_OPTIONS, therefore supported.  Returns 0\n-   otherwise.  */\n-\n-static int\n-ptrace_supports_feature (int ptrace_options)\n-{\n-  if (supported_ptrace_options == -1)\n-    linux_check_ptrace_features ();\n-\n-  return ((supported_ptrace_options & ptrace_options) == ptrace_options);\n-}\n-\n-/* Returns non-zero if PTRACE_EVENT_FORK is supported by ptrace,\n-   0 otherwise.  Note that if PTRACE_EVENT_FORK is supported so is\n-   PTRACE_EVENT_CLONE, PTRACE_EVENT_EXEC and PTRACE_EVENT_VFORK,\n-   since they were all added to the kernel at the same time.  */\n-\n-int\n-linux_supports_tracefork (void)\n-{\n-  return ptrace_supports_feature (PTRACE_O_TRACEFORK);\n-}\n-\n-/* Returns non-zero if PTRACE_EVENT_EXEC is supported by ptrace,\n-   0 otherwise.  Note that if PTRACE_EVENT_FORK is supported so is\n-   PTRACE_EVENT_CLONE, PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK,\n-   since they were all added to the kernel at the same time.  */\n-\n-int\n-linux_supports_traceexec (void)\n-{\n-  return ptrace_supports_feature (PTRACE_O_TRACEEXEC);\n-}\n-\n-/* Returns non-zero if PTRACE_EVENT_CLONE is supported by ptrace,\n-   0 otherwise.  Note that if PTRACE_EVENT_CLONE is supported so is\n-   PTRACE_EVENT_FORK, PTRACE_EVENT_EXEC and PTRACE_EVENT_VFORK,\n-   since they were all added to the kernel at the same time.  */\n-\n-int\n-linux_supports_traceclone (void)\n-{\n-  return ptrace_supports_feature (PTRACE_O_TRACECLONE);\n-}\n-\n-/* Returns non-zero if PTRACE_O_TRACEVFORKDONE is supported by\n-   ptrace, 0 otherwise.  */\n-\n-int\n-linux_supports_tracevforkdone (void)\n-{\n-  return ptrace_supports_feature (PTRACE_O_TRACEVFORKDONE);\n-}\n-\n-/* Returns non-zero if PTRACE_O_TRACESYSGOOD is supported by ptrace,\n-   0 otherwise.  */\n-\n-int\n-linux_supports_tracesysgood (void)\n-{\n-  return ptrace_supports_feature (PTRACE_O_TRACESYSGOOD);\n-}\n-\n /* Display possible problems on this system.  Display them only once per GDB\n    execution.  */\n "
    },
    {
      "sha": "4694046e1e8da55cb1eecb7552c05f4bff44031f",
      "filename": "gdb/nat/linux-ptrace.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/nat/linux-ptrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdb/nat/linux-ptrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-ptrace.h?ref=a288518611dbda5cfae8894d532cf1040cb1b6c2",
      "patch": "@@ -187,11 +187,6 @@ extern void linux_ptrace_init_warnings (void);\n extern void linux_check_ptrace_features (void);\n extern void linux_enable_event_reporting (pid_t pid, int attached);\n extern void linux_disable_event_reporting (pid_t pid);\n-extern int linux_supports_tracefork (void);\n-extern int linux_supports_traceexec (void);\n-extern int linux_supports_traceclone (void);\n-extern int linux_supports_tracevforkdone (void);\n-extern int linux_supports_tracesysgood (void);\n extern int linux_ptrace_get_extended_event (int wstat);\n extern int linux_is_extended_waitstatus (int wstat);\n extern int linux_wstatus_maybe_breakpoint (int wstat);"
    },
    {
      "sha": "30552da7559e9fa71fee70ddc6fe3b1631a54700",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a288518611dbda5cfae8894d532cf1040cb1b6c2/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=a288518611dbda5cfae8894d532cf1040cb1b6c2",
      "patch": "@@ -5883,23 +5883,23 @@ linux_process_target::supports_multi_process ()\n bool\n linux_process_target::supports_fork_events ()\n {\n-  return linux_supports_tracefork ();\n+  return true;\n }\n \n /* Check if vfork events are supported.  */\n \n bool\n linux_process_target::supports_vfork_events ()\n {\n-  return linux_supports_tracefork ();\n+  return true;\n }\n \n /* Check if exec events are supported.  */\n \n bool\n linux_process_target::supports_exec_events ()\n {\n-  return linux_supports_traceexec ();\n+  return true;\n }\n \n /* Target hook for 'handle_new_gdb_connection'.  Causes a reset of the\n@@ -6098,8 +6098,7 @@ linux_process_target::read_loadmap (const char *annex, CORE_ADDR offset,\n bool\n linux_process_target::supports_catch_syscall ()\n {\n-  return (low_supports_catch_syscall ()\n-\t  && linux_supports_tracesysgood ());\n+  return low_supports_catch_syscall ();\n }\n \n bool"
    }
  ]
}