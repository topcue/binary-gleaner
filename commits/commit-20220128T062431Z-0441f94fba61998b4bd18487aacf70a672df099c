{
  "sha": "0441f94fba61998b4bd18487aacf70a672df099c",
  "node_id": "C_kwDOANOeidoAKDA0NDFmOTRmYmE2MTk5OGI0YmQxODQ4N2FhY2Y3MGE2NzJkZjA5OWM",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-01-27T23:16:13Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2022-01-28T06:24:31Z"
    },
    "message": "PR28827, assertion building LLVM 9 on powerpc64le-linux-gnu\n\nThe assertion is this one in ppc_build_one_stub\n  BFD_ASSERT (stub_entry->stub_offset >= stub_entry->group->stub_sec->size);\nIt is checking that a stub doesn't overwrite the tail of a previous\nstub, so not something trivial.\n\nNormally, stub sizing iterates until no stubs are added, detected by\nno change in stub section size.  Iteration also continues if no stubs\nare added but one or more stubs increases in size, which also can be\ndetected by a change in stub section size.  But there is a\npathological case where stub section sizing decreases one iteration\nthen increases the next.  To handle that situation, stub sizing also\nstops at more than STUB_SHRINK_ITER (20) iterations when calculated\nstub section size is smaller.  The previous larger size is kept for\nthe actual layout (so that building the stubs, which behaves like\nanother iteration of stub sizing, will see the stub section sizes\nshrink).  The problem with that stopping condition is that it assumes\nthat stub sizing is only affected by addresses external to the stub\nsections, which isn't always true.\n\nThis patch fixes that by also keeping larger individual stub_offset\naddresses past STUB_SHRINK_ITER.  It also catches a further\npathological case where one stub shrinks and another expands in such a\nway that no stub section size change is seen.\n\n\tPR 28827\n\t* elf64-ppc.c (struct ppc_link_hash_table): Add stub_changed.\n\t(STUB_SHRINK_ITER): Move earlier in file.\n\t(ppc_size_one_stub): Detect any change in stub_offset.  Keep\n\tlarger one if past STUB_SHRINK_ITER.\n\t(ppc64_elf_size_stubs): Iterate on stub_changed too.",
    "tree": {
      "sha": "a2dfd5067d971977544e4f9045e7a694de720b65",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a2dfd5067d971977544e4f9045e7a694de720b65"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0441f94fba61998b4bd18487aacf70a672df099c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0441f94fba61998b4bd18487aacf70a672df099c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0441f94fba61998b4bd18487aacf70a672df099c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0441f94fba61998b4bd18487aacf70a672df099c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "07c9f243b3a12cc6749bc02ee7b165859979348b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/07c9f243b3a12cc6749bc02ee7b165859979348b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/07c9f243b3a12cc6749bc02ee7b165859979348b"
    }
  ],
  "stats": {
    "total": 59,
    "additions": 36,
    "deletions": 23
  },
  "files": [
    {
      "sha": "8a8b83b283dcf229a2f45c9be538fb965140df24",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 36,
      "deletions": 23,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0441f94fba61998b4bd18487aacf70a672df099c/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0441f94fba61998b4bd18487aacf70a672df099c/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=0441f94fba61998b4bd18487aacf70a672df099c",
      "patch": "@@ -3296,6 +3296,9 @@ struct ppc_link_hash_table\n   /* Set if inline plt calls should be converted to direct calls.  */\n   unsigned int can_convert_all_inline_plt:1;\n \n+  /* Set if a stub_offset changed.  */\n+  unsigned int stub_changed:1;\n+\n   /* Set on error.  */\n   unsigned int stub_error:1;\n \n@@ -3313,6 +3316,13 @@ struct ppc_link_hash_table\n \n   /* Incremented every time we size stubs.  */\n   unsigned int stub_iteration;\n+\n+/* After 20 iterations of stub sizing we no longer allow stubs to\n+   shrink.  This is to break out of a pathological case where adding\n+   stubs or increasing their size on one iteration decreases section\n+   gaps (perhaps due to alignment), which then results in smaller\n+   stubs on the next iteration.  */\n+#define STUB_SHRINK_ITER 20\n };\n \n /* Rename some of the generic section flags to better document how they\n@@ -12164,6 +12174,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n   asection *plt;\n   bfd_vma targ, off, r2off;\n   unsigned int size, extra, lr_used, delta, odd;\n+  bfd_vma stub_offset;\n \n   /* Massage our args to the form they really have.  */\n   stub_entry = (struct ppc_stub_hash_entry *) gen_entry;\n@@ -12193,7 +12204,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t\t\t    stub_entry->target_section);\n \n   /* Make a note of the offset within the stubs for this entry.  */\n-  stub_entry->stub_offset = stub_entry->group->stub_sec->size;\n+  stub_offset = stub_entry->group->stub_sec->size;\n \n   if (stub_entry->h != NULL\n       && stub_entry->h->save_res\n@@ -12223,7 +12234,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t      + stub_entry->target_section->output_offset\n \t      + stub_entry->target_section->output_section->vma);\n       targ += PPC64_LOCAL_ENTRY_OFFSET (stub_entry->other);\n-      off = (stub_entry->stub_offset\n+      off = (stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma);\n \n@@ -12322,7 +12333,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n     }\n   else if (stub_entry->type.main == ppc_stub_long_branch)\n     {\n-      off = (stub_entry->stub_offset\n+      off = (stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma);\n       size = 0;\n@@ -12361,7 +12372,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t{\n \t  /* After the bcl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is in r12.  */\n-\t  lr_used = stub_entry->stub_offset + 8;\n+\t  lr_used = stub_offset + 8;\n \t  if (stub_entry->type.r2save)\n \t    lr_used += 4;\n \t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n@@ -12410,7 +12421,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    plt = htab->pltlocal;\n \t}\n       targ += plt->output_offset + plt->output_section->vma;\n-      off = (stub_entry->stub_offset\n+      off = (stub_offset\n \t     + stub_entry->group->stub_sec->output_offset\n \t     + stub_entry->group->stub_sec->output_section->vma\n \t     + lr_used);\n@@ -12422,7 +12433,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  unsigned pad = plt_stub_pad (htab, stub_entry, off, odd);\n \n \t  stub_entry->group->stub_sec->size += pad;\n-\t  stub_entry->stub_offset = stub_entry->group->stub_sec->size;\n+\t  stub_offset = stub_entry->group->stub_sec->size;\n \t  off -= pad;\n \t  odd ^= pad & 4;\n \t}\n@@ -12444,7 +12455,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t{\n \t  /* After the bcl, lr has been modified so we need to emit\n \t     .eh_frame info saying the return address is in r12.  */\n-\t  lr_used += stub_entry->stub_offset + 8;\n+\t  lr_used += stub_offset + 8;\n \t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n \t     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n \t     DW_CFA_restore_extended 65.  */\n@@ -12458,20 +12469,18 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t{\n \t  if (!htab->params->no_tls_get_addr_regsave)\n \t    {\n-\t      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;\n+\t      unsigned int cfa_updt = stub_offset + 18 * 4;\n \t      delta = cfa_updt - stub_entry->group->lr_restore;\n \t      stub_entry->group->eh_size += eh_advance_size (delta);\n \t      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;\n-\t      stub_entry->group->lr_restore\n-\t\t= stub_entry->stub_offset + size - 4;\n+\t      stub_entry->group->lr_restore = stub_offset + size - 4;\n \t    }\n \t  else if (stub_entry->type.r2save)\n \t    {\n-\t      lr_used = stub_entry->stub_offset + size - 20;\n+\t      lr_used = stub_offset + size - 20;\n \t      delta = lr_used - stub_entry->group->lr_restore;\n \t      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n-\t      stub_entry->group->lr_restore\n-\t\t= stub_entry->stub_offset + size - 4;\n+\t      stub_entry->group->lr_restore = stub_offset + size - 4;\n \t    }\n \t}\n     }\n@@ -12499,7 +12508,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  unsigned pad = plt_stub_pad (htab, stub_entry, off, 0);\n \n \t  stub_entry->group->stub_sec->size += pad;\n-\t  stub_entry->stub_offset = stub_entry->group->stub_sec->size;\n+\t  stub_offset = stub_entry->group->stub_sec->size;\n \t}\n \n       if (info->emitrelocations)\n@@ -12523,21 +12532,21 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t  if (!htab->params->no_tls_get_addr_regsave)\n \t    {\n \t      /* Adjustments to r1 need to be described.  */\n-\t      unsigned int cfa_updt = stub_entry->stub_offset + 18 * 4;\n+\t      unsigned int cfa_updt = stub_offset + 18 * 4;\n \t      delta = cfa_updt - stub_entry->group->lr_restore;\n \t      stub_entry->group->eh_size += eh_advance_size (delta);\n \t      stub_entry->group->eh_size += htab->opd_abi ? 36 : 35;\n \t    }\n \t  else\n \t    {\n-\t      lr_used = stub_entry->stub_offset + size - 20;\n+\t      lr_used = stub_offset + size - 20;\n \t      /* The eh_frame info will consist of a DW_CFA_advance_loc\n \t\t or variant, DW_CFA_offset_externed_sf, 65, -stackoff,\n \t\t DW_CFA_advance_loc+4, DW_CFA_restore_extended, 65.  */\n \t      delta = lr_used - stub_entry->group->lr_restore;\n \t      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n \t    }\n-\t  stub_entry->group->lr_restore = stub_entry->stub_offset + size - 4;\n+\t  stub_entry->group->lr_restore = stub_offset + size - 4;\n \t}\n     }\n   else\n@@ -12546,7 +12555,12 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       return false;\n     }\n \n-  stub_entry->group->stub_sec->size += size;\n+  if (stub_entry->stub_offset != stub_offset)\n+    htab->stub_changed = true;\n+  if (htab->stub_iteration <= STUB_SHRINK_ITER\n+      || stub_entry->stub_offset < stub_offset)\n+    stub_entry->stub_offset = stub_offset;\n+  stub_entry->group->stub_sec->size = stub_entry->stub_offset + size;\n   return true;\n }\n \n@@ -13644,12 +13658,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n       _bfd_elf_link_hash_hide_symbol (info, &htab->tga_desc_fd->elf, true);\n     }\n \n-#define STUB_SHRINK_ITER 20\n   /* Loop until no stubs added.  After iteration 20 of this loop we may\n-     exit on a stub section shrinking.  This is to break out of a\n-     pathological case where adding stubs on one iteration decreases\n-     section gaps (perhaps due to alignment), which then requires\n-     fewer or smaller stubs on the next iteration.  */\n+     exit on a stub section shrinking.  */\n \n   while (1)\n     {\n@@ -14119,6 +14129,7 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t  htab->elf.srelrdyn->size = 0;\n \t}\n \n+      htab->stub_changed = false;\n       bfd_hash_traverse (&htab->stub_hash_table, ppc_size_one_stub, info);\n \n       for (group = htab->group; group != NULL; group = group->next)\n@@ -14215,6 +14226,8 @@ ppc64_elf_size_stubs (struct bfd_link_info *info)\n \t  break;\n \n       if (group == NULL\n+\t  && (!htab->stub_changed\n+\t      || htab->stub_iteration > STUB_SHRINK_ITER)\n \t  && (htab->brlt->rawsize == htab->brlt->size\n \t      || (htab->stub_iteration > STUB_SHRINK_ITER\n \t\t  && htab->brlt->rawsize > htab->brlt->size))"
    }
  ]
}